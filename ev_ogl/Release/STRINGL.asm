; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\STRINGL.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_get_fe_edge
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_get_edge_wrap
EXTRN	_sym_inverse:DWORD
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_wrap PROC					; COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  :   WRAPTYPE wrap = *EINT(e_id,E_WRAP_ATTR) ;

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+784]
	mov	eax, DWORD PTR [eax+edx]
	pop	esi

; 165  :   return    ( inverted(e_id) ? (*sym_inverse)(wrap) : wrap );

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN4@get_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@get_edge_w:

; 166  : }

	pop	ebp
	ret	0
_get_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_get_body_density
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_body_density
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_density PROC					; COMDAT

; 305  :     { return  ( valid_id(b_id) ?  bptr(b_id)->density : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_d
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+344]
	pop	ebp
	ret	0
$LN3@get_body_d:
	fldz
	pop	ebp
	ret	0
_get_body_density ENDP
_TEXT	ENDS
PUBLIC	_edge_grav_density
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\stringl.c
;	COMDAT _edge_grav_density
_TEXT	SEGMENT
_first_fe$ = 8						; size = 4
_e_id$ = 8						; size = 4
_edge_grav_density PROC					; COMDAT

; 189  : {

	push	ebp
	mov	ebp, esp

; 190  :   facetedge_id fe,first_fe;
; 191  :   body_id  b_id;
; 192  :   REAL density = 0.0;
; 193  :   facet_id f_id;
; 194  : 
; 195  :   /* if body is on facet agreeing with edge orientation,
; 196  :       then pressure is positive. */
; 197  : 
; 198  :   fe = first_fe = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	fldz
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	test	eax, eax
	jne	SHORT $LN9@edge_grav_
	mov	DWORD PTR _first_fe$[ebp], eax
	jmp	SHORT $LN10@edge_grav_
$LN9@edge_grav_:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN8@edge_grav_
	xor	eax, 134217728				; 08000000H
$LN8@edge_grav_:
	mov	DWORD PTR _first_fe$[ebp], eax
$LN10@edge_grav_:
	mov	eax, DWORD PTR _first_fe$[ebp]
	push	edi
	mov	edi, eax

; 199  :   while ( valid_id(fe) )

	shr	eax, 28					; 0000001cH
	test	al, 1
	je	$LN41@edge_grav_
	push	ebx
	mov	ebx, DWORD PTR _web+328
	push	esi

; 200  :   { f_id = get_fe_facet(fe);

$LN13@edge_grav_:
	mov	ecx, DWORD PTR _web+460
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [edx+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN12@edge_grav_
	xor	ecx, 134217728				; 08000000H
$LN12@edge_grav_:

; 201  :     b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN19@edge_grav_
	xor	eax, eax
	jmp	SHORT $LN16@edge_grav_
$LN19@edge_grav_:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN18@edge_grav_
	xor	eax, eax
	jmp	SHORT $LN16@edge_grav_
$LN18@edge_grav_:
	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [ebx+edx+784]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN17@edge_grav_
	mov	eax, DWORD PTR [eax+edx+4]
	jmp	SHORT $LN16@edge_grav_
$LN17@edge_grav_:
	mov	eax, DWORD PTR [eax+edx]
$LN16@edge_grav_:

; 202  :     if ( (valid_id(b_id)) && (get_battr(b_id) & DENSITY) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN42@edge_grav_
	mov	edx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 16					; 00000010H
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN42@edge_grav_

; 203  :        density += get_body_density(b_id);

	fadd	QWORD PTR [edx+344]
$LN42@edge_grav_:

; 204  :     b_id = get_facet_body(inverse_id(f_id));

	xor	ecx, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	mov	eax, ecx
	jne	SHORT $LN29@edge_grav_
	xor	eax, eax
	jmp	SHORT $LN26@edge_grav_
$LN29@edge_grav_:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN28@edge_grav_
	xor	eax, eax
	jmp	SHORT $LN26@edge_grav_
$LN28@edge_grav_:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN27@edge_grav_
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ebx+eax+784]
	mov	eax, DWORD PTR [edx+ecx+4]
	jmp	SHORT $LN26@edge_grav_
$LN27@edge_grav_:
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ebx+ecx+784]
	mov	eax, DWORD PTR [eax+edx]
$LN26@edge_grav_:

; 205  :     if ( (valid_id(b_id)) && (get_battr(b_id) & DENSITY) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN43@edge_grav_
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 16					; 00000010H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN43@edge_grav_

; 206  :        density -= get_body_density(b_id);

	fsub	QWORD PTR [ecx+344]
$LN43@edge_grav_:

; 207  :     fe = get_next_facet(fe);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN37@edge_grav_
	mov	edx, DWORD PTR _web+460
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+edi*4]
	mov	edi, DWORD PTR [eax+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN36@edge_grav_
$LN37@edge_grav_:
	mov	ecx, DWORD PTR _web+460
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR [edx+40]
$LN36@edge_grav_:

; 208  :     if ( equal_id(fe,first_fe) ) break;

	cmp	edi, DWORD PTR _first_fe$[ebp]
	je	SHORT $LN45@edge_grav_

; 199  :   while ( valid_id(fe) )

	mov	eax, edi
	shr	eax, 28					; 0000001cH
	test	al, 1
	jne	$LN13@edge_grav_
$LN45@edge_grav_:
	pop	esi
	pop	ebx
$LN41@edge_grav_:

; 209  :   }
; 210  : 
; 211  :   return web.grav_const*density;

	fmul	QWORD PTR _web+832
	pop	edi

; 212  : } // end edge_grav_density()

	pop	ebp
	ret	0
_edge_grav_density ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	_edge_area_l
EXTRN	_add_body_volume:PROC
EXTRN	_dot:PROC
;	COMDAT __real@3fe0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\stringl.c
CONST	ENDS
;	COMDAT _edge_area_l
_TEXT	SEGMENT
_v1$89205 = -48						; size = 8
_v3$89207 = -40						; size = 8
_v2$89206 = -32						; size = 8
_b_id2$ = -24						; size = 4
_b_id1$ = -20						; size = 4
tv486 = -16						; size = 4
_area$ = -12						; size = 8
tv507 = -8						; size = 4
_wy$89210 = -8						; size = 4
_wx$89209 = -4						; size = 4
_wrap$89211 = -4					; size = 4
_f_id1$ = 8						; size = 4
_fe_id$ = 8						; size = 4
_edge_area_l PROC					; COMDAT

; 222  : {

	push	ebp
	mov	ebp, esp

; 223  :   REAL *xt,*xh;
; 224  :   REAL area;
; 225  :   body_id b_id1,b_id2; /* bodies to add area to */
; 226  :   facet_id f_id1,f_id2; /* facets to add area to */
; 227  :   edge_id e_id = get_fe_edge(fe_id);

	mov	ecx, DWORD PTR _fe_id$[ebp]
	sub	esp, 48					; 00000030H
	push	ebx
	mov	ebx, DWORD PTR _web+460
	push	esi
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	esi, ecx
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [edx+20]

; 228  : 
; 229  :   if ( get_eattr(e_id) & NONCONTENT ) return;

	mov	edx, DWORD PTR _web+124
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	edx, edx
	or	eax, edx
	jne	$LN1@edge_area_

; 230  : 
; 231  :   if ( inverted(e_id) ) { fe_id = inverse_id(fe_id); e_id = inverse_id(e_id); }

	test	esi, 134217728				; 08000000H
	je	SHORT $LN7@edge_area_
	xor	ecx, 134217728				; 08000000H
	xor	esi, 134217728				; 08000000H
$LN7@edge_area_:

; 232  : 
; 233  :   f_id1 = get_fe_facet(fe_id);

	mov	eax, DWORD PTR _NULLFACET
	push	edi
	mov	edi, ecx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	SHORT $LN20@edge_area_
	mov	edx, eax
	mov	DWORD PTR _f_id1$[ebp], edx
	jmp	SHORT $LN21@edge_area_
$LN20@edge_area_:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR [edx+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN19@edge_area_
	xor	edx, 134217728				; 08000000H
$LN19@edge_area_:
	mov	DWORD PTR _f_id1$[ebp], edx
$LN21@edge_area_:

; 234  :   f_id2 = facet_inverse(get_fe_facet(fe_id));

	test	edi, edi
	je	SHORT $LN23@edge_area_
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN23@edge_area_
	xor	eax, 134217728				; 08000000H
$LN23@edge_area_:

; 235  :   if ( !valid_id(f_id1) && !valid_id(f_id2) ) return; /* no facets */

	mov	ebx, edx
	xor	eax, 134217728				; 08000000H
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	mov	edi, eax
	mov	DWORD PTR tv486[ebp], ebx
	jne	SHORT $LN31@edge_area_
	test	edi, 268435456				; 10000000H
	je	$LN32@edge_area_
$LN31@edge_area_:

; 236  :   b_id1 = get_facet_body(f_id1);

	push	edx
	call	_get_facet_body

; 237  :   b_id2 = get_facet_body(f_id2);

	push	edi
	mov	DWORD PTR _b_id1$[ebp], eax
	call	_get_facet_body
	add	esp, 8

; 238  : 
; 239  :   if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	mov	DWORD PTR _b_id2$[ebp], eax
	je	$LN5@edge_area_

; 240  :   { REAL v1,v2,v3,v4;
; 241  :     int wx,wy; /* wraps */
; 242  :     WRAPTYPE wrap = get_edge_wrap(e_id);

	mov	edx, DWORD PTR _web+124
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	eax, DWORD PTR [eax+ecx]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN29@edge_area_
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN29@edge_area_:

; 243  :   
; 244  :      /* new way, accurate modulo unit cell area */
; 245  : 
; 246  :     area = 0.0;
; 247  :     xt = get_coord(get_edge_tailv(e_id));     

	mov	edx, DWORD PTR _web+104
	mov	DWORD PTR _wrap$89211[ebp], eax
	mov	eax, DWORD PTR _dymem
	mov	ebx, DWORD PTR [edx+eax+64]
	push	esi
	call	_get_edge_tailv
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]

; 248  :     xh = get_coord(get_edge_headv(e_id));     

	push	esi
	add	edi, ebx
	call	_get_edge_headv
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+eax*4]

; 249  :     v1 = dot(web.inverse_periods[0],xt,2);

	mov	eax, DWORD PTR _web+1612
	mov	ecx, DWORD PTR [eax]
	push	2
	push	edi
	push	ecx
	add	esi, ebx
	call	_dot
	fstp	QWORD PTR _v1$89205[ebp]

; 250  :     v2 = dot(web.inverse_periods[0],xh,2);

	mov	edx, DWORD PTR _web+1612
	mov	eax, DWORD PTR [edx]
	push	2
	push	esi
	push	eax
	call	_dot
	fstp	QWORD PTR _v2$89206[ebp]

; 251  :     v3 = dot(web.inverse_periods[1],xt,2);

	mov	ecx, DWORD PTR _web+1612
	mov	edx, DWORD PTR [ecx+4]
	push	2
	push	edi
	push	edx
	call	_dot
	fstp	QWORD PTR _v3$89207[ebp]

; 252  :     v4 = dot(web.inverse_periods[1],xh,2);

	mov	eax, DWORD PTR _web+1612
	mov	ecx, DWORD PTR [eax+4]
	push	2
	push	esi
	push	ecx
	call	_dot

; 253  : 
; 254  :     wx = WRAPNUM(wrap & WRAPMASK);

	mov	ecx, DWORD PTR _wrap$89211[ebp]
	mov	eax, ecx
	and	eax, 31					; 0000001fH
	add	esp, 56					; 00000038H
	cmp	eax, 16					; 00000010H
	jle	SHORT $LN11@edge_area_
	add	eax, -32				; ffffffe0H
$LN11@edge_area_:

; 255  :     wy = WRAPNUM((wrap>>TWRAPBITS) & WRAPMASK);

	sar	ecx, 6
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR _wx$89209[ebp], eax
	cmp	ecx, 16					; 00000010H
	jle	SHORT $LN13@edge_area_
	add	ecx, -32				; ffffffe0H
$LN13@edge_area_:

; 256  :     area += wy*(v2+wx);

	fild	DWORD PTR _wx$89209[ebp]
	mov	DWORD PTR _wy$89210[ebp], ecx

; 257  :      
; 258  :     area -= ((v2+wx - v1)*(v4+wy + v3)/2 );
; 259  :     area *= web.torusv;
; 260  :   }  /* end torus */
; 261  :   else

	mov	ebx, DWORD PTR tv486[ebp]
	fadd	QWORD PTR _v2$89206[ebp]
	fild	DWORD PTR _wy$89210[ebp]
	fld	ST(0)
	fmul	ST(0), ST(2)
	fadd	QWORD PTR __real@0000000000000000
	fxch	ST(1)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fadd	QWORD PTR _v3$89207[ebp]
	fxch	ST(1)
	fsub	QWORD PTR _v1$89205[ebp]
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fe0000000000000
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR _web+1600
	jmp	SHORT $LN55@edge_area_
$LN5@edge_area_:

; 262  :   { 
; 263  :     xt = get_coord(get_edge_tailv(e_id));     

	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+eax+64]
	push	esi
	mov	DWORD PTR tv507[ebp], ecx
	call	_get_edge_tailv
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+eax*4]
	add	edi, DWORD PTR tv507[ebp]

; 264  :     xh = get_coord(get_edge_headv(e_id));     

	push	esi
	call	_get_edge_headv
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	add	esp, 8
	add	eax, DWORD PTR tv507[ebp]

; 265  :      
; 266  :     /* calculate area above x1 axis */ 
; 267  :     area = (xt[0] - xh[0])*(xt[1] + xh[1])/2;

	fld	QWORD PTR [eax+8]
	fadd	QWORD PTR [edi+8]
	fld	QWORD PTR [edi]
	fsub	QWORD PTR [eax]
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fe0000000000000
$LN55@edge_area_:
	fst	QWORD PTR _area$[ebp]

; 268  :   }
; 269  : 
; 270  :   /* add to cell areas */
; 271  :   if ( valid_id(f_id1) )

	test	ebx, ebx
	je	SHORT $LN3@edge_area_

; 272  :      add_facet_area(f_id1,area);

	mov	eax, DWORD PTR _f_id1$[ebp]
	fld	ST(0)
	test	eax, 134217728				; 08000000H
	je	SHORT $LN16@edge_area_
	fchs
$LN16@edge_area_:
	mov	edx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	fadd	QWORD PTR [eax+40]
	fstp	QWORD PTR [eax+40]
$LN3@edge_area_:

; 273  :   
; 274  :   if ( valid_id(b_id1) )

	mov	eax, DWORD PTR _b_id1$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2@edge_area_

; 275  :      add_body_volume(b_id1,area);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	call	_add_body_volume
	fld	QWORD PTR _area$[ebp]
	add	esp, 12					; 0000000cH
$LN2@edge_area_:

; 276  :   
; 277  :   if ( valid_id(b_id2) )

	mov	eax, DWORD PTR _b_id2$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN53@edge_area_

; 278  :      add_body_volume(b_id2,-area);

	sub	esp, 8
	fchs
	fstp	QWORD PTR [esp]
	push	eax
	call	_add_body_volume
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 279  : } // end  edge_area_l()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@edge_area_:

; 276  :   
; 277  :   if ( valid_id(b_id2) )

	fstp	ST(0)
$LN32@edge_area_:
	pop	edi
$LN1@edge_area_:
	pop	esi
	pop	ebx

; 279  : } // end  edge_area_l()

	mov	esp, ebp
	pop	ebp
	ret	0
_edge_area_l ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_string_grad_l
EXTRN	_get_bv_new_vgrad:PROC
EXTRN	_get_edge_side:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _string_grad_l
_TEXT	SEGMENT
_v2$89282 = -212					; size = 8
_v3$89283 = -204					; size = 8
_v1$89281 = -196					; size = 8
tv3244 = -188						; size = 4
_tvgptr$ = -184						; size = 4
tv3238 = -180						; size = 4
tv3240 = -176						; size = 4
tv2830 = -172						; size = 4
tv1665 = -172						; size = 4
tv3236 = -168						; size = 4
_tailv$ = -168						; size = 4
_hvgptr$ = -164						; size = 4
_headv$ = -164						; size = 4
_fe_id$ = -160						; size = 4
tv1650 = -156						; size = 4
_wrap$89287 = -156					; size = 4
_wx$89285 = -156					; size = 4
_wy$89286 = -152					; size = 4
_bi_id$ = -152						; size = 4
_side$ = -148						; size = 48
_tgrad$89289 = -100					; size = 48
_hgrad$89288 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_string_grad_l PROC					; COMDAT

; 291  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	edi

; 292  :   body_id bi_id;  /* identifier for body i */
; 293  :   facetedge_id fe_id;
; 294  :   REAL side[MAXCOORD];
; 295  :   volgrad *hvgptr,*tvgptr;
; 296  :   vertex_id headv,tailv;
; 297  :   facet_id f_id;
; 298  :   edge_id e_id;
; 299  :   REAL *xt,*xh;
; 300  :   int i;
; 301  : 
; 302  :   FOR_ALL_FACETEDGES(fe_id)

	mov	edi, DWORD PTR _web+496
	mov	ecx, edi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _fe_id$[ebp], edi
	je	$LN22@string_gra
	push	ebx
	push	esi
	jmp	SHORT $LN24@string_gra
$LL73@string_gra:
	mov	edi, DWORD PTR _fe_id$[ebp]
$LN24@string_gra:
	mov	edx, DWORD PTR _web+460
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN23@string_gra

; 303  :   {
; 304  :     /* see which side has body, if any */
; 305  :     f_id = get_fe_facet(fe_id);

	cmp	ecx, esi
	jne	SHORT $LN32@string_gra
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN31@string_gra
$LN32@string_gra:
	mov	eax, DWORD PTR [edx+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN31@string_gra
	xor	eax, 134217728				; 08000000H
$LN31@string_gra:

; 306  :     bi_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, esi
	jne	SHORT $LN38@string_gra
	mov	DWORD PTR _bi_id$[ebp], esi
	jmp	SHORT $LN35@string_gra
$LN38@string_gra:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN37@string_gra
	mov	DWORD PTR _bi_id$[ebp], esi
	jmp	SHORT $LN35@string_gra
$LN37@string_gra:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN36@string_gra
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+328
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	ecx, DWORD PTR [edx+eax+4]
	mov	DWORD PTR _bi_id$[ebp], ecx
	jmp	SHORT $LN35@string_gra
$LN36@string_gra:
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _bi_id$[ebp], edx
$LN35@string_gra:

; 307  :     if ( !valid_id(bi_id) ) 

	test	DWORD PTR _bi_id$[ebp], 268435456	; 10000000H
	jne	SHORT $LN78@string_gra

; 308  :     { invert(fe_id);

	xor	edi, 134217728				; 08000000H
	mov	DWORD PTR _fe_id$[ebp], edi

; 309  :       bi_id = get_facet_body(get_fe_facet(fe_id));

	test	edi, 268435456				; 10000000H
	jne	SHORT $LN42@string_gra
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN41@string_gra
$LN42@string_gra:
	mov	ecx, DWORD PTR _web+460
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN41@string_gra
	xor	eax, 134217728				; 08000000H
$LN41@string_gra:
	push	eax
	call	_get_facet_body
	add	esp, 4
	mov	DWORD PTR _bi_id$[ebp], eax
$LN78@string_gra:

; 310  :     }
; 311  :     if ( !valid_id(bi_id) ) continue;  /* nothing here */

	mov	eax, DWORD PTR _bi_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	$LN23@string_gra

; 312  :     if ( !(get_battr(bi_id) & (FIXEDVOL|PRESSURE) ) ) continue;

	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1650[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2080				; 00000820H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN23@string_gra

; 313  :    
; 314  : 	e_id = get_fe_edge(fe_id);

	mov	edx, DWORD PTR _web+460

; 315  :     if ( get_eattr(e_id) & NONCONTENT ) continue;

	mov	ecx, DWORD PTR _web+124
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	ebx, DWORD PTR [eax+20]
	and	edi, 134217728				; 08000000H
	xor	ebx, edi
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1665[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN76@string_gra

; 316  : 
; 317  :     get_edge_side(e_id,side);

	lea	edx, DWORD PTR _side$[ebp]
	push	edx
	push	ebx
	call	_get_edge_side

; 318  : 
; 319  :     headv = get_fe_headv(fe_id);

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [esi+eax]
	mov	esi, DWORD PTR [ecx+20]
	xor	esi, edi
	push	esi
	call	_get_edge_headv
	mov	edi, eax

; 320  :     tailv = get_fe_tailv(fe_id);

	push	esi
	mov	DWORD PTR _headv$[ebp], edi
	call	_get_edge_tailv

; 321  :     xt = get_coord(tailv);

	mov	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx+64]
	mov	edx, eax
	mov	DWORD PTR _tailv$[ebp], eax
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [eax+edx*4]

; 322  :     xh = get_coord(headv);
; 323  : 
; 324  :     /* gradient due to edge */
; 325  : 
; 326  :     hvgptr = get_bv_new_vgrad(get_body_fixnum(bi_id),headv);

	mov	edx, DWORD PTR tv1650[ebp]
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _headv$[ebp]
	add	esi, ecx
	add	edi, ecx
	mov	ecx, DWORD PTR _web+348
	push	eax
	mov	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [eax+420]
	push	ecx
	call	_get_bv_new_vgrad

; 327  :     hvgptr->bb_id = bi_id;

	mov	edx, DWORD PTR _bi_id$[ebp]
	mov	DWORD PTR [eax+8], edx

; 328  :     tvgptr = get_bv_new_vgrad(get_body_fixnum(bi_id),tailv);

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR tv1650[ebp]
	mov	DWORD PTR _hvgptr$[ebp], eax
	mov	eax, DWORD PTR _tailv$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [eax+420]
	push	ecx
	call	_get_bv_new_vgrad

; 329  :     tvgptr->bb_id = bi_id;

	mov	edx, DWORD PTR _bi_id$[ebp]
	add	esp, 32					; 00000020H
	mov	DWORD PTR [eax+8], edx

; 330  : 
; 331  :     if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	mov	DWORD PTR _tvgptr$[ebp], eax
	je	$LN15@string_gra

; 332  :     { REAL v1,v2,v3,v4;
; 333  :       int wx=0,wy=0; /* wraps */
; 334  :       WRAPTYPE wrap = get_edge_wrap(e_id);

	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR tv1665[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN53@string_gra
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN53@string_gra:
	mov	DWORD PTR _wrap$89287[ebp], eax

; 335  :       REAL hgrad[MAXCOORD];
; 336  :       REAL tgrad[MAXCOORD];
; 337  :   
; 338  :      /* new way, accurate modulo unit cell area */
; 339  : 
; 340  :       for ( i = 0 ; i < SDIM ; i++ ) hgrad[i] = tgrad[i] = 0.0;

	mov	eax, DWORD PTR _web+616
	test	eax, eax
	jle	SHORT $LN14@string_gra
	lea	edx, DWORD PTR [eax*8]
	mov	ecx, edx
	shr	ecx, 2
	xor	eax, eax
	lea	edi, DWORD PTR _hgrad$89288[ebp]
	rep stosd
	mov	ecx, edx
	shr	ecx, 2
	lea	edi, DWORD PTR _tgrad$89289[ebp]
	rep stosd
$LN14@string_gra:

; 341  :       xt = get_coord(get_edge_tailv(e_id));     

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR [ecx+edx+64]
	push	ebx
	call	_get_edge_tailv
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]

; 342  :       xh = get_coord(get_edge_headv(e_id));     

	push	ebx
	add	edi, esi
	call	_get_edge_headv
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edx+eax*4]

; 343  :       v1 = dot(web.inverse_periods[0],xt,2);

	mov	eax, DWORD PTR _web+1612
	mov	ecx, DWORD PTR [eax]
	push	2
	push	edi
	push	ecx
	add	ebx, esi
	call	_dot
	fstp	QWORD PTR _v1$89281[ebp]

; 344  :       v2 = dot(web.inverse_periods[0],xh,2);

	mov	edx, DWORD PTR _web+1612
	mov	eax, DWORD PTR [edx]
	push	2
	push	ebx
	push	eax
	call	_dot
	fstp	QWORD PTR _v2$89282[ebp]

; 345  :       v3 = dot(web.inverse_periods[1],xt,2);

	mov	ecx, DWORD PTR _web+1612
	mov	edx, DWORD PTR [ecx+4]
	push	2
	push	edi
	push	edx
	call	_dot
	fstp	QWORD PTR _v3$89283[ebp]

; 346  :       v4 = dot(web.inverse_periods[1],xh,2);

	mov	eax, DWORD PTR _web+1612
	mov	ecx, DWORD PTR [eax+4]
	push	2
	push	ebx
	push	ecx
	call	_dot

; 347  : 
; 348  :       wx = WRAPNUM(wrap & WRAPMASK);

	mov	ecx, DWORD PTR _wrap$89287[ebp]
	mov	eax, ecx
	and	eax, 31					; 0000001fH
	add	esp, 56					; 00000038H
	cmp	eax, 16					; 00000010H
	jle	SHORT $LN27@string_gra
	add	eax, -32				; ffffffe0H
$LN27@string_gra:

; 349  :       wy = WRAPNUM((wrap>>TWRAPBITS) & WRAPMASK);

	sar	ecx, 6
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR _wx$89285[ebp], eax
	cmp	ecx, 16					; 00000010H
	jle	SHORT $LN29@string_gra
	add	ecx, -32				; ffffffe0H
$LN29@string_gra:

; 350  :       if ( wy )

	mov	eax, DWORD PTR _web+1612
	mov	edi, DWORD PTR _web+616
	mov	DWORD PTR _wy$89286[ebp], ecx
	test	ecx, ecx
	je	$LN74@string_gra

; 351  :         for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	cmp	edi, 4
	jl	SHORT $LC66@string_gra

; 352  :           hgrad[i] += wy*web.inverse_periods[0][i];

	mov	esi, DWORD PTR [eax]
	fild	DWORD PTR _wy$89286[ebp]
	lea	eax, DWORD PTR [esi+16]
	neg	esi
	lea	edx, DWORD PTR _hgrad$89288[ebp+esi]
	lea	ebx, DWORD PTR [edi-3]
	lea	esi, DWORD PTR _hgrad$89288[ebp+esi+8]
$LN77@string_gra:
	fld	QWORD PTR [eax-16]
	add	ecx, 4
	fmul	ST(0), ST(1)
	add	eax, 32					; 00000020H
	fadd	QWORD PTR _hgrad$89288[ebp+ecx*8-32]
	fstp	QWORD PTR _hgrad$89288[ebp+ecx*8-32]
	fld	QWORD PTR [eax-40]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _hgrad$89288[ebp+ecx*8-24]
	fstp	QWORD PTR _hgrad$89288[ebp+ecx*8-24]
	fld	ST(0)
	fmul	QWORD PTR [eax-32]
	fadd	QWORD PTR [eax+edx-32]
	fstp	QWORD PTR [eax+edx-32]
	fld	QWORD PTR [eax-24]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax+esi-32]
	fstp	QWORD PTR [eax+esi-32]
	cmp	ecx, ebx
	jl	SHORT $LN77@string_gra
	mov	eax, DWORD PTR _web+1612
	fstp	ST(0)
$LC66@string_gra:

; 351  :         for ( i = 0 ; i < SDIM ; i++ )

	cmp	ecx, edi
	jge	SHORT $LN74@string_gra
	mov	edx, DWORD PTR [eax]
	fild	DWORD PTR _wy$89286[ebp]
	lea	esi, DWORD PTR _hgrad$89288[ebp]
	sub	edx, esi
$LC10@string_gra:
	lea	esi, DWORD PTR [edx+ecx*8]

; 352  :           hgrad[i] += wy*web.inverse_periods[0][i];

	fld	QWORD PTR _hgrad$89288[ebp+esi]
	inc	ecx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _hgrad$89288[ebp+ecx*8-8]
	fstp	QWORD PTR _hgrad$89288[ebp+ecx*8-8]
	cmp	ecx, edi
	jl	SHORT $LC10@string_gra

; 351  :         for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN74@string_gra:

; 353  :      
; 354  :       for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	cmp	edi, 4
	jl	$LN72@string_gra

; 358  :         tgrad[i] -= (v2+wx - v1)/2*web.inverse_periods[1][i];

	fild	DWORD PTR _wy$89286[ebp]
	mov	edi, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [edi+24]
	fadd	ST(0), ST(1)
	sub	edi, esi
	lea	eax, DWORD PTR [esi+8]
	neg	esi
	fadd	QWORD PTR _v3$89283[ebp]
	lea	ebx, DWORD PTR _tgrad$89289[ebp+esi]
	fld	QWORD PTR __real@3fe0000000000000
	mov	DWORD PTR tv3236[ebp], ebx
	lea	ebx, DWORD PTR _hgrad$89288[ebp+esi+8]
	fmul	ST(1), ST(0)
	mov	DWORD PTR tv3238[ebp], ebx
	fild	DWORD PTR _wx$89285[ebp]
	lea	ebx, DWORD PTR _tgrad$89289[ebp+esi+8]
	mov	DWORD PTR tv2830[ebp], edi
	mov	DWORD PTR tv3240[ebp], ebx
	fadd	QWORD PTR _v2$89282[ebp]
	lea	edi, DWORD PTR _hgrad$89288[ebp+esi]
	lea	ebx, DWORD PTR _hgrad$89288[ebp+esi+16]
	lea	esi, DWORD PTR _tgrad$89289[ebp+esi+16]
	fsub	QWORD PTR _v1$89281[ebp]
	mov	DWORD PTR tv3244[ebp], esi
	fmul	ST(0), ST(1)
$LN75@string_gra:

; 355  :       { hgrad[i] -= (v4+wy + v3)/2*web.inverse_periods[0][i];

	fld	QWORD PTR [edx-24]
	mov	esi, DWORD PTR tv2830[ebp]
	fmul	ST(0), ST(3)

; 358  :         tgrad[i] -= (v2+wx - v1)/2*web.inverse_periods[1][i];

	add	ecx, 4
	fld	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(2)
	add	edx, 32					; 00000020H
	fld	QWORD PTR _hgrad$89288[ebp+ecx*8-32]
	fsub	ST(0), ST(2)
	fsub	ST(0), ST(1)
	fstp	QWORD PTR _hgrad$89288[ebp+ecx*8-32]
	fxch	ST(1)
	fadd	QWORD PTR _tgrad$89289[ebp+ecx*8-32]
	fsubrp	ST(1), ST(0)
	fstp	QWORD PTR _tgrad$89289[ebp+ecx*8-32]
	fld	QWORD PTR [esi+eax-32]
	mov	esi, DWORD PTR tv3236[ebp]
	fmul	ST(0), ST(3)
	fld	ST(1)
	fmul	QWORD PTR [eax-32]
	fld	QWORD PTR [eax+edi-32]
	fsub	ST(0), ST(2)
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax+edi-32]
	fxch	ST(1)
	fadd	QWORD PTR [eax+esi-32]
	fsubrp	ST(1), ST(0)
	fstp	QWORD PTR [eax+esi-32]
	mov	esi, DWORD PTR tv3238[ebp]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(3)
	fld	QWORD PTR [eax-24]
	fmul	ST(0), ST(2)
	fld	QWORD PTR [eax+esi-32]
	fsub	ST(0), ST(2)
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax+esi-32]
	mov	esi, DWORD PTR tv3240[ebp]
	fxch	ST(1)
	fadd	QWORD PTR [eax+esi-32]
	fsubrp	ST(1), ST(0)
	fstp	QWORD PTR [eax+esi-32]
	mov	esi, DWORD PTR tv3244[ebp]
	fld	ST(2)
	fmul	QWORD PTR [edx-32]
	fld	QWORD PTR [eax-16]
	fmul	ST(0), ST(2)
	fld	QWORD PTR [eax+ebx-32]
	fsub	ST(0), ST(2)
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax+ebx-32]
	fld	QWORD PTR [eax+esi-32]
	faddp	ST(2), ST(0)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax+esi-32]
	mov	esi, DWORD PTR _web+616
	add	esi, -3					; fffffffdH
	cmp	ecx, esi
	jl	$LN75@string_gra
	mov	eax, DWORD PTR _web+1612
	fstp	ST(2)
	mov	edi, DWORD PTR _web+616
	fstp	ST(1)
	jmp	SHORT $LC69@string_gra
$LN72@string_gra:
	fld	QWORD PTR __real@3fe0000000000000
$LC69@string_gra:

; 353  :      
; 354  :       for ( i = 0 ; i < SDIM ; i++ )

	cmp	ecx, edi
	jge	SHORT $LN114@string_gra
	fild	DWORD PTR _wy$89286[ebp]
	mov	edx, DWORD PTR [eax]
	lea	esi, DWORD PTR _hgrad$89288[ebp]
	sub	edx, esi
	mov	esi, DWORD PTR [eax+4]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	lea	eax, DWORD PTR _hgrad$89288[ebp]
	sub	esi, eax
	fadd	QWORD PTR _v3$89283[ebp]
	fmul	ST(0), ST(1)
	fild	DWORD PTR _wx$89285[ebp]
	fadd	QWORD PTR _v2$89282[ebp]
	fsub	QWORD PTR _v1$89281[ebp]
	fmulp	ST(2), ST(0)
$LC7@string_gra:
	lea	eax, DWORD PTR _hgrad$89288[ebp+ecx*8]

; 355  :       { hgrad[i] -= (v4+wy + v3)/2*web.inverse_periods[0][i];

	fld	QWORD PTR [eax+edx]
	inc	ecx
	fmul	ST(0), ST(1)

; 356  :         tgrad[i] += (v4+wy + v3)/2*web.inverse_periods[0][i];
; 357  :         hgrad[i] -= (v2+wx - v1)/2*web.inverse_periods[1][i];

	fld	QWORD PTR [esi+eax]
	fmul	ST(0), ST(3)
	fld	QWORD PTR [eax]
	fsub	ST(0), ST(2)
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax]
	fld	QWORD PTR _tgrad$89289[ebp+ecx*8-8]
	faddp	ST(2), ST(0)

; 358  :         tgrad[i] -= (v2+wx - v1)/2*web.inverse_periods[1][i];

	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _tgrad$89289[ebp+ecx*8-8]
	cmp	ecx, edi
	jl	SHORT $LC7@string_gra
$LN114@string_gra:

; 353  :      
; 354  :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)

; 359  :       }
; 360  :       for ( i = 0 ; i < SDIM ; i++ ) 

	xor	eax, eax
	fstp	ST(0)
	test	edi, edi
	jle	$LN76@string_gra
	npad	8
$LL4@string_gra:
	mov	ecx, DWORD PTR _hvgptr$[ebp]

; 361  :       { hvgptr->grad[i] += web.torusv*hgrad[i];

	fld	QWORD PTR _hgrad$89288[ebp+eax*8]
	mov	edx, DWORD PTR [ecx+16]
	fmul	QWORD PTR _web+1600
	lea	ecx, DWORD PTR [edx+eax*8]
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _tvgptr$[ebp]

; 362  :         tvgptr->grad[i] += web.torusv*tgrad[i];

	fld	QWORD PTR _tgrad$89289[ebp+eax*8]
	mov	edx, DWORD PTR [ecx+16]
	fmul	QWORD PTR _web+1600
	lea	ecx, DWORD PTR [edx+eax*8]
	inc	eax
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL4@string_gra

; 363  :       }
; 364  :     }  /* end torus */
; 365  :     else

	jmp	SHORT $LN76@string_gra
$LN15@string_gra:

; 366  :     { /* grads of  area = (xt[0] - xh[0])*(xt[1] + xh[1])/2 */
; 367  :       hvgptr->grad[0] += -(xt[1] + xh[1])/2;

	fld	QWORD PTR [edi+8]
	mov	edx, DWORD PTR _hvgptr$[ebp]
	fadd	QWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edx+16]
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fld	QWORD PTR [ecx]
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [ecx]

; 368  :       hvgptr->grad[1] +=  (xt[0] - xh[0])/2;

	mov	ecx, DWORD PTR [edx+16]
	fld	QWORD PTR [esi]
	fsub	QWORD PTR [edi]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx+8]
	fstp	QWORD PTR [ecx+8]

; 369  :       tvgptr->grad[0] +=  (xt[1] + xh[1])/2;

	mov	ecx, DWORD PTR [eax+16]
	fld	QWORD PTR [edi+8]
	fadd	QWORD PTR [esi+8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]

; 370  :       tvgptr->grad[1] +=  (xt[0] - xh[0])/2;

	mov	eax, DWORD PTR [eax+16]
	fld	QWORD PTR [esi]
	fsub	QWORD PTR [edi]
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
$LN76@string_gra:

; 363  :       }
; 364  :     }  /* end torus */
; 365  :     else

	mov	edi, DWORD PTR _fe_id$[ebp]
$LN23@string_gra:

; 292  :   body_id bi_id;  /* identifier for body i */
; 293  :   facetedge_id fe_id;
; 294  :   REAL side[MAXCOORD];
; 295  :   volgrad *hvgptr,*tvgptr;
; 296  :   vertex_id headv,tailv;
; 297  :   facet_id f_id;
; 298  :   edge_id e_id;
; 299  :   REAL *xt,*xh;
; 300  :   int i;
; 301  : 
; 302  :   FOR_ALL_FACETEDGES(fe_id)

	mov	eax, DWORD PTR _web+460
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR _fe_id$[ebp], ecx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL73@string_gra
	pop	esi
	pop	ebx
$LN22@string_gra:

; 371  :     }
; 372  :   }
; 373  : 
; 374  : } // end string_grad_l()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_string_grad_l ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_string_bdry_grad
EXTRN	_get_vertex_vgrad:PROC
EXTRN	_eval_all:PROC
EXTRN	_V_BOUNDARY_ATTR:DWORD
; Function compile flags: /Ogtp
;	COMDAT _string_bdry_grad
_TEXT	SEGMENT
_dummy$ = -96						; size = 8
_attr$89328 = -88					; size = 8
_start_e$89331 = -84					; size = 4
tv516 = -80						; size = 4
_next_e$89332 = -76					; size = 4
tv626 = -72						; size = 4
_v_id$ = -68						; size = 4
_vgptri$89326 = -64					; size = 4
_fe_id0$89351 = -60					; size = 4
_bdry$89327 = -56					; size = 4
_partial$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_string_bdry_grad PROC					; COMDAT

; 384  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 385  :   vertex_id v_id;
; 386  :   REAL dummy,partial[MAXCOORD]; /* for eval_all */
; 387  :   int i;
; 388  : 
; 389  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	DWORD PTR _v_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	je	$LN70@string_bdr
	push	ebx
	mov	ebx, DWORD PTR _V_BOUNDARY_ATTR
	push	esi
	push	edi
	jmp	SHORT $LN28@string_bdr
	npad	2
$LL74@string_bdr:
	mov	eax, DWORD PTR _v_id$[ebp]
$LN28@string_bdr:
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [edx+8]
	mov	edi, DWORD PTR [edx+12]
	mov	DWORD PTR tv516[ebp], eax
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN27@string_bdr

; 390  :   {
; 391  :     volgrad *vgptri;
; 392  :     struct boundary *bdry;
; 393  :     ATTR attr = get_vattr(v_id);
; 394  :     edge_id e_id, start_e, next_e;
; 395  : 
; 396  :     if ( attr & FIXED ) continue;

	mov	eax, ecx
	and	eax, 64					; 00000040H
	or	eax, esi
	mov	DWORD PTR _attr$89328[ebp+4], edi
	jne	$LN27@string_bdr

; 397  :     if ( !(attr & BOUNDARY) ) continue;

	mov	eax, ecx
	and	eax, 128				; 00000080H
	or	eax, esi
	je	$LN27@string_bdr

; 398  :     if ( !(attr & BDRY_CONTENT) ) continue;

	and	ecx, 4096				; 00001000H
	xor	eax, eax
	or	ecx, eax
	je	$LN27@string_bdr

; 399  : 
; 400  :     bdry = get_boundary(v_id);

	cmp	ebx, esi
	je	SHORT $LN31@string_bdr
	mov	ecx, DWORD PTR _dymem
	mov	eax, ebx
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	edi, DWORD PTR [eax+edx]
	imul	edi, 136				; 00000088H
	add	edi, DWORD PTR _web+776
	mov	DWORD PTR _bdry$89327[ebp], edi
	jmp	SHORT $LN32@string_bdr
$LN31@string_bdr:
	mov	DWORD PTR _bdry$89327[ebp], esi
	mov	edi, eax
$LN32@string_bdr:

; 401  :     if ( bdry->pcount != 1 ) return ;

	cmp	DWORD PTR [edi+40], 1
	jne	$LN79@string_bdr

; 402  : 
; 403  :     start_e = get_vertex_edge(v_id);

	mov	edx, DWORD PTR [edx+28]
	mov	DWORD PTR _start_e$89331[ebp], edx

; 404  :     if ( !valid_id(start_e) ) continue;

	test	edx, 268435456				; 10000000H
	je	$LN27@string_bdr

; 405  :     next_e = start_e; 

	mov	ebx, edx
	jmp	SHORT $LN18@string_bdr
$LL76@string_bdr:
	mov	ebx, DWORD PTR _next_e$89332[ebp]
$LN18@string_bdr:

; 406  : 
; 407  :     do
; 408  :     { facetedge_id fe_id0,fe_id;
; 409  :       facet_id f_id;
; 410  :       body_id bf;
; 411  :       int sign;
; 412  : 
; 413  :       e_id = next_e;
; 414  :       fe_id0 = get_edge_fe(e_id);

	mov	esi, DWORD PTR _web+124
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+ecx*4]
	test	eax, eax
	jne	SHORT $LN34@string_bdr
	mov	DWORD PTR _fe_id0$89351[ebp], eax
	jmp	SHORT $LN35@string_bdr
$LN34@string_bdr:
	mov	edx, DWORD PTR [eax+28]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN33@string_bdr
	xor	edx, 134217728				; 08000000H
$LN33@string_bdr:
	mov	DWORD PTR _fe_id0$89351[ebp], edx
$LN35@string_bdr:

; 415  :       next_e = get_next_tail_edge(e_id);

	shr	ebx, 27					; 0000001bH
	and	ebx, 1

; 416  :       if ( !valid_id(fe_id0) ) continue;

	test	DWORD PTR _fe_id0$89351[ebp], 268435456	; 10000000H
	mov	edx, DWORD PTR [eax+ebx*4+32]
	mov	DWORD PTR _next_e$89332[ebp], edx
	je	$LN17@string_bdr

; 417  :       if ( get_eattr(e_id) & NONCONTENT ) continue;

	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN17@string_bdr

; 418  : 
; 419  :       eval_all(bdry->convect[0],get_param(v_id),bdry->pcount,&dummy,
; 420  :          partial,v_id);

	mov	esi, DWORD PTR _v_id$[ebp]
	mov	edx, DWORD PTR [edi+40]
	push	esi
	lea	eax, DWORD PTR _partial$[ebp]
	push	eax
	mov	eax, DWORD PTR tv516[ebp]
	lea	ecx, DWORD PTR _dummy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _web+12
	push	edx
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+544]
	push	edx
	mov	edx, DWORD PTR [edi+96]
	push	edx
	call	_eval_all

; 421  : 
; 422  :       vgptri = get_vertex_vgrad(v_id);

	push	esi
	call	_get_vertex_vgrad
	mov	edi, DWORD PTR _web+460
	mov	ebx, DWORD PTR _web+328
	mov	DWORD PTR _vgptri$89326[ebp], eax
	mov	eax, DWORD PTR _web+236
	add	esp, 28					; 0000001cH
$LL13@string_bdr:

; 406  : 
; 407  :     do
; 408  :     { facetedge_id fe_id0,fe_id;
; 409  :       facet_id f_id;
; 410  :       body_id bf;
; 411  :       int sign;
; 412  : 
; 413  :       e_id = next_e;
; 414  :       fe_id0 = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _vgptri$89326[ebp]
	mov	edx, DWORD PTR [ecx+8]

; 423  :       do
; 424  :       {
; 425  :         sign = 0;
; 426  :         fe_id = fe_id0;

	mov	esi, DWORD PTR _fe_id0$89351[ebp]
	mov	DWORD PTR tv626[ebp], edx
	npad	1
$LL10@string_bdr:

; 427  :         do
; 428  :         { f_id = get_fe_facet(fe_id);

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN40@string_bdr
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN39@string_bdr
$LN40@string_bdr:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [edx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN39@string_bdr
	xor	ecx, 134217728				; 08000000H
$LN39@string_bdr:

; 429  :           bf = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN46@string_bdr
	xor	ecx, ecx
	jmp	SHORT $LN43@string_bdr
$LN46@string_bdr:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN45@string_bdr
	xor	ecx, ecx
	jmp	SHORT $LN43@string_bdr
$LN45@string_bdr:
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [ebx+edx+784]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN44@string_bdr
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [ecx+edx+4]
	jmp	SHORT $LN43@string_bdr
$LN44@string_bdr:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [ecx+edx]
$LN43@string_bdr:

; 430  :           if ( equal_id(bf,vgptri->bb_id) )

	cmp	ecx, DWORD PTR tv626[ebp]
	je	$LN69@string_bdr

; 431  :           { sign = 1; break; }
; 432  :           else
; 433  :           { facetedge_id fe_ida = inverse_id(fe_id);

	mov	edx, esi
	xor	edx, 134217728				; 08000000H

; 434  :             f_id = get_fe_facet(fe_ida);

	test	edx, 268435456				; 10000000H
	jne	SHORT $LN50@string_bdr
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN49@string_bdr
$LN50@string_bdr:
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN49@string_bdr
	xor	ecx, 134217728				; 08000000H
$LN49@string_bdr:

; 435  :             bf = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN56@string_bdr
	xor	ecx, ecx
	jmp	SHORT $LN53@string_bdr
$LN56@string_bdr:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN55@string_bdr
	xor	ecx, ecx
	jmp	SHORT $LN53@string_bdr
$LN55@string_bdr:
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN54@string_bdr
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ebx+ecx+784]
	mov	ecx, DWORD PTR [edx+ecx+4]
	jmp	SHORT $LN53@string_bdr
$LN54@string_bdr:
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ebx+ecx+784]
	mov	ecx, DWORD PTR [edx+ecx]
$LN53@string_bdr:

; 436  :             if ( equal_id(bf,vgptri->bb_id) )

	cmp	ecx, DWORD PTR tv626[ebp]
	je	SHORT $LN69@string_bdr

; 437  :             { sign = -1; break; }
; 438  :           }
; 439  :           fe_id = get_next_facet(fe_id);  

	test	esi, 134217728				; 08000000H
	je	SHORT $LN60@string_bdr
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+esi*4]
	mov	esi, DWORD PTR [edx+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN9@string_bdr
$LN60@string_bdr:
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+esi*4]
	mov	esi, DWORD PTR [ecx+40]
$LN9@string_bdr:

; 440  :         }
; 441  :         while ( fe_id != fe_id0 );

	cmp	esi, DWORD PTR _fe_id0$89351[ebp]
	jne	$LL10@string_bdr
	jmp	SHORT $LN78@string_bdr
$LN69@string_bdr:

; 442  : 
; 443  :         if ( sign ) 
; 444  :           for ( i = 0 ; i < bdry->pcount ; i++ )

	mov	esi, DWORD PTR _bdry$89327[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [esi+40], ecx
	jle	SHORT $LN78@string_bdr
	npad	6
$LL3@string_bdr:
	mov	edx, DWORD PTR _vgptri$89326[ebp]

; 445  :             vgptri->grad[i] += partial[i];  

	fld	QWORD PTR _partial$[ebp+ecx*8]
	mov	eax, DWORD PTR [edx+16]
	fadd	QWORD PTR [eax+ecx*8]
	lea	edx, DWORD PTR [eax+ecx*8]
	inc	ecx
	fstp	QWORD PTR [edx]
	cmp	ecx, DWORD PTR [esi+40]
	jl	SHORT $LL3@string_bdr

; 442  : 
; 443  :         if ( sign ) 
; 444  :           for ( i = 0 ; i < bdry->pcount ; i++ )

	mov	edi, DWORD PTR _web+460
	mov	ebx, DWORD PTR _web+328
	mov	eax, DWORD PTR _web+236
$LN78@string_bdr:

; 446  :         vgptri = vgptri->chain;

	mov	ecx, DWORD PTR _vgptri$89326[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR _vgptri$89326[ebp], ecx

; 447  :       } while ( vgptri );

	test	ecx, ecx
	jne	$LL13@string_bdr
	mov	edi, DWORD PTR _bdry$89327[ebp]
$LN17@string_bdr:

; 448  :     } while ( !equal_id(next_e,start_e) );

	mov	edx, DWORD PTR _next_e$89332[ebp]
	cmp	edx, DWORD PTR _start_e$89331[ebp]
	jne	$LL76@string_bdr
	mov	ebx, DWORD PTR _V_BOUNDARY_ATTR
$LN27@string_bdr:

; 385  :   vertex_id v_id;
; 386  :   REAL dummy,partial[MAXCOORD]; /* for eval_all */
; 387  :   int i;
; 388  : 
; 389  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR tv516[ebp]
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _v_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL74@string_bdr
$LN79@string_bdr:
	pop	edi
	pop	esi
	pop	ebx
$LN70@string_bdr:

; 449  :   }
; 450  : } // end string_bdry_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_string_bdry_grad ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_string_constr_grad
EXTRN	_nullcon:QWORD
; Function compile flags: /Ogtp
;	COMDAT _string_constr_grad
_TEXT	SEGMENT
_val$89442 = -96					; size = 8
_attr$89397 = -88					; size = 8
_start_e$ = -84						; size = 4
_next_e$ = -80						; size = 4
tv548 = -76						; size = 4
_conmap$89422 = -72					; size = 4
_v_id$ = -68						; size = 4
_fe_id0$89396 = -64					; size = 4
_vgptri$89393 = -60					; size = 4
tv644 = -56						; size = 4
_sign$89419 = -56					; size = 4
_derivs$89443 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_string_constr_grad PROC				; COMDAT

; 460  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 461  :   vertex_id v_id;
; 462  :   edge_id e_id, next_e, start_e;
; 463  : 
; 464  :   FOR_ALL_VERTICES(v_id)

	mov	ebx, DWORD PTR _web+48
	mov	DWORD PTR _v_id$[ebp], ebx
	test	ebx, 268435456				; 10000000H
	je	$LN28@string_con
	push	esi
	push	edi
	jmp	SHORT $LN30@string_con
	npad	6
$LL80@string_con:
	mov	ebx, DWORD PTR _v_id$[ebp]
$LN30@string_con:
	mov	eax, DWORD PTR _web+12
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ebx+eax]
	mov	ecx, DWORD PTR [edx+8]
	mov	edi, DWORD PTR [edx+12]
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv548[ebp], ebx
	je	$LN29@string_con

; 465  :   {
; 466  :     struct volgrad *vgptri;
; 467  :     struct constraint *constr;
; 468  :     facetedge_id fe_id,fe_id0;
; 469  :     ATTR attr = get_vattr(v_id);
; 470  : 
; 471  :     if ( attr & FIXED ) continue;

	mov	eax, ecx
	and	eax, 64					; 00000040H
	or	eax, esi
	mov	DWORD PTR _attr$89397[ebp+4], edi
	jne	$LN29@string_con

; 472  :     if ( !(attr & CONSTRAINT) ) continue;

	mov	eax, ecx
	and	eax, 1024				; 00000400H
	or	eax, esi
	je	$LN29@string_con

; 473  :     if ( !(attr & BDRY_CONTENT) ) continue;

	and	ecx, 4096				; 00001000H
	xor	eax, eax
	or	ecx, eax
	je	$LN29@string_con

; 474  : 
; 475  :     start_e = get_vertex_edge(v_id);

	mov	edx, DWORD PTR [edx+28]
	mov	DWORD PTR _start_e$[ebp], edx

; 476  :     if ( !valid_id(start_e) ) continue;

	test	edx, 268435456				; 10000000H
	je	$LN29@string_con

; 477  :     e_id = next_e = start_e; 

	mov	esi, edx
	jmp	SHORT $LN21@string_con
$LL81@string_con:
	mov	esi, DWORD PTR _next_e$[ebp]
$LN21@string_con:

; 478  : 
; 479  :     do
; 480  :     { e_id = next_e;
; 481  :       fe_id0 = get_edge_fe(e_id);

	mov	edi, DWORD PTR _web+124
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+ecx*4]
	test	eax, eax
	jne	SHORT $LN36@string_con
	mov	DWORD PTR _fe_id0$89396[ebp], eax
	jmp	SHORT $LN37@string_con
$LN36@string_con:
	mov	edx, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN35@string_con
	xor	edx, 134217728				; 08000000H
$LN35@string_con:
	mov	DWORD PTR _fe_id0$89396[ebp], edx
$LN37@string_con:

; 482  :       next_e = get_next_tail_edge(e_id);

	shr	esi, 27					; 0000001bH
	and	esi, 1

; 483  :       if ( !valid_id(fe_id0) ) continue;

	test	DWORD PTR _fe_id0$89396[ebp], 268435456	; 10000000H
	mov	edx, DWORD PTR [eax+esi*4+32]
	mov	DWORD PTR _next_e$[ebp], edx
	je	$LN20@string_con

; 484  :       if ( get_eattr(e_id) & NONCONTENT ) continue;

	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN20@string_con

; 485  : 
; 486  :       vgptri = get_vertex_vgrad(v_id);

	mov	eax, DWORD PTR _v_id$[ebp]
	push	eax
	call	_get_vertex_vgrad
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _vgptri$89393[ebp], esi

; 487  :       while ( vgptri )

	test	esi, esi
	je	$LN20@string_con
	mov	ebx, DWORD PTR _web+328
	mov	edi, DWORD PTR _dymem
	jmp	SHORT $LN16@string_con
$LL82@string_con:
	mov	esi, DWORD PTR _vgptri$89393[ebp]
$LN16@string_con:

; 488  :       {
; 489  :         int sign=0,i,j;
; 490  :         conmap_t * conmap = get_v_constraint_map(v_id);

	mov	ecx, DWORD PTR _web+104
	cmp	DWORD PTR [ecx+edi+1288], 0
	je	SHORT $LN33@string_con
	mov	edx, DWORD PTR tv548[ebp]
	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [edx+eax]
	add	eax, DWORD PTR [ecx+edi+1264]
	mov	DWORD PTR _conmap$89422[ebp], eax
	jmp	SHORT $LN34@string_con
$LN33@string_con:
	mov	DWORD PTR _conmap$89422[ebp], OFFSET _nullcon
$LN34@string_con:

; 510  :         if ( sign ) 
; 511  :           for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _fe_id0$89396[ebp]
	mov	DWORD PTR tv644[ebp], ecx
$LL14@string_con:

; 491  :         facet_id f_id;
; 492  :         body_id bf;
; 493  : 
; 494  :         fe_id = fe_id0;
; 495  :         do
; 496  :         { f_id = get_fe_facet(fe_id);

	mov	esi, DWORD PTR _web+460
	test	edx, 268435456				; 10000000H
	jne	SHORT $LN42@string_con
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN41@string_con
$LN42@string_con:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [ecx+24]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN41@string_con
	xor	eax, 134217728				; 08000000H
$LN41@string_con:

; 497  :           bf = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN48@string_con
	xor	eax, eax
	jmp	SHORT $LN45@string_con
$LN48@string_con:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN47@string_con
	xor	eax, eax
	jmp	SHORT $LN45@string_con
$LN47@string_con:
	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN46@string_con
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [ebx+edi+784]
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN45@string_con
$LN46@string_con:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [ebx+edi+784]
	mov	eax, DWORD PTR [eax+ecx]
$LN45@string_con:

; 498  :           if ( equal_id(bf,vgptri->bb_id) )

	cmp	eax, DWORD PTR tv644[ebp]
	je	$LN71@string_con

; 500  :           else
; 501  :           { facetedge_id fe_ida = inverse_id(fe_id);

	mov	ecx, edx
	xor	ecx, 134217728				; 08000000H

; 502  :             f_id = get_fe_facet(fe_ida);

	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN52@string_con
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN51@string_con
$LN52@string_con:
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN51@string_con
	xor	eax, 134217728				; 08000000H
$LN51@string_con:

; 503  :             bf = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN58@string_con
	xor	eax, eax
	jmp	SHORT $LN55@string_con
$LN58@string_con:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN57@string_con
	xor	eax, eax
	jmp	SHORT $LN55@string_con
$LN57@string_con:
	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN56@string_con
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [ebx+edi+784]
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN55@string_con
$LN56@string_con:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [ebx+edi+784]
	mov	eax, DWORD PTR [eax+ecx]
$LN55@string_con:

; 504  :             if ( equal_id(bf,vgptri->bb_id) )

	cmp	eax, DWORD PTR tv644[ebp]
	je	SHORT $LN72@string_con

; 506  :           }
; 507  :           fe_id = get_next_facet(fe_id);  

	test	edx, 134217728				; 08000000H
	je	SHORT $LN62@string_con
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR [edx+36]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN13@string_con
$LN62@string_con:
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR [eax+40]
$LN13@string_con:

; 508  :         }
; 509  :         while ( fe_id != fe_id0 );

	cmp	edx, DWORD PTR _fe_id0$89396[ebp]
	jne	$LL14@string_con
	jmp	$LN84@string_con
$LN71@string_con:

; 499  :           { sign = 1; break; }

	mov	DWORD PTR _sign$89419[ebp], 1
	jmp	SHORT $LN77@string_con
$LN72@string_con:

; 505  :              { sign = -1; break; }

	mov	DWORD PTR _sign$89419[ebp], -1
$LN77@string_con:

; 510  :         if ( sign ) 
; 511  :           for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	ecx, DWORD PTR _conmap$89422[ebp]
	mov	esi, 1
	cmp	DWORD PTR [ecx], esi
	jl	$LN84@string_con
	npad	4
$LL83@string_con:

; 512  :           { REAL val,derivs[MAXCOORD];
; 513  :             constr = get_constraint(conmap[j]);

	mov	edx, DWORD PTR _conmap$89422[ebp]
	mov	eax, DWORD PTR [edx+esi*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 514  :             if ( !(constr->attr & CON_CONTENT) ) continue;

	xor	edx, edx
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 128				; 00000080H
	or	ecx, edx
	je	SHORT $LN6@string_con

; 515  :             eval_all(constr->convect[0],get_coord(v_id),SDIM,&val,derivs,v_id);

	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	eax, DWORD PTR [eax+108]
	push	ecx
	lea	edx, DWORD PTR _derivs$89443[ebp]
	push	edx
	mov	edx, DWORD PTR _web+616
	lea	ecx, DWORD PTR _val$89442[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv548[ebp]
	push	edx
	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _web+104
	add	ecx, DWORD PTR [edx+edi+64]
	push	ecx
	push	eax
	call	_eval_all

; 516  :             for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	add	esp, 24					; 00000018H
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN78@string_con
	fild	DWORD PTR _sign$89419[ebp]
$LN3@string_con:

; 517  :               vgptri->grad[i] -= sign*derivs[i];  

	fld	QWORD PTR _derivs$89443[ebp+eax*8]
	mov	ecx, DWORD PTR _vgptri$89393[ebp]
	mov	edx, DWORD PTR [ecx+16]
	fmul	ST(0), ST(1)
	lea	ecx, DWORD PTR [edx+eax*8]
	inc	eax
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@string_con

; 516  :             for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN78@string_con:
	mov	edi, DWORD PTR _dymem
$LN6@string_con:

; 510  :         if ( sign ) 
; 511  :           for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _conmap$89422[ebp]
	inc	esi
	cmp	esi, DWORD PTR [eax]
	jle	$LL83@string_con
	mov	ebx, DWORD PTR _web+328
$LN84@string_con:

; 518  :           }
; 519  :         vgptri = vgptri->chain;

	mov	ecx, DWORD PTR _vgptri$89393[ebp]
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _vgptri$89393[ebp], eax
	test	eax, eax
	jne	$LL82@string_con

; 487  :       while ( vgptri )

	mov	ebx, DWORD PTR tv548[ebp]
$LN20@string_con:

; 520  :       }
; 521  :     }
; 522  :     while ( !equal_id(next_e,start_e) );

	mov	edx, DWORD PTR _next_e$[ebp]
	cmp	edx, DWORD PTR _start_e$[ebp]
	jne	$LL81@string_con
$LN29@string_con:

; 461  :   vertex_id v_id;
; 462  :   edge_id e_id, next_e, start_e;
; 463  : 
; 464  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _v_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL80@string_con
	pop	edi
	pop	esi
$LN28@string_con:

; 523  :   }
; 524  : } // end string_constr_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_string_constr_grad ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DP@BBDGHLJI@Can?5only?5do?5edge_general_integra@ ; `string'
PUBLIC	_edge_general_init
EXTRN	_kb_error:PROC
;	COMDAT ??_C@_0DP@BBDGHLJI@Can?5only?5do?5edge_general_integra@
CONST	SEGMENT
??_C@_0DP@BBDGHLJI@Can?5only?5do?5edge_general_integra@ DB 'Can only do e'
	DB	'dge_general_integral if edges are 1 dimensional.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _edge_general_init
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_edge_general_init PROC					; COMDAT

; 545  :   if ( web.dimension > 2 ) 

	cmp	DWORD PTR _web+620, 2
	jle	SHORT $LN1@edge_gener

; 546  :      kb_error(2189,
; 547  :         "Can only do edge_general_integral if edges are 1 dimensional.\n",
; 548  :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DP@BBDGHLJI@Can?5only?5do?5edge_general_integra@
	push	2189					; 0000088dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@edge_gener:

; 549  : } // end edge_general_init()

	ret	0
_edge_general_init ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@bff0000000000000
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_general_value_lagrange
EXTRN	_eval:PROC
EXTRN	_meth_inst_list:DWORD
EXTRN	_gauss_lagrange:BYTE
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _edge_general_value_lagrange
_TEXT	SEGMENT
_sign$ = -148						; size = 8
_value$ = -140						; size = 8
tv701 = -132						; size = 4
_e_info$GSCopy$ = -128					; size = 4
_gl$ = -124						; size = 4
_m$ = -120						; size = 4
tv774 = -116						; size = 4
tv375 = -116						; size = 4
tv387 = -112						; size = 4
_z$ = -108						; size = 104
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_general_value_lagrange PROC			; COMDAT

; 663  : { int m,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 664  :   REAL value = 0.0;
; 665  :   REAL z[2*MAXCOORD+1];  /*  pointers to coord and tangent */
; 666  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	ecx, DWORD PTR _web+124
	fldz
	push	ebx
	fst	QWORD PTR _value$[ebp]
	mov	ebx, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [ebx]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	or	eax, ecx
	push	esi
	push	edi

; 672  :        z[SDIM+k] = sign*e_info->sides[m][0][k];

	mov	DWORD PTR _e_info$GSCopy$[ebp], ebx
	je	SHORT $LN9@edge_gener@2

; 664  :   REAL value = 0.0;
; 665  :   REAL z[2*MAXCOORD+1];  /*  pointers to coord and tangent */
; 666  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN45@edge_gener@2
$LN9@edge_gener@2:
	fld1
$LN45@edge_gener@2:

; 667  :   struct gauss_lag *gl = &gauss_lagrange[1][web.gauss1D_order];

	mov	esi, DWORD PTR _web+1592
	fst	QWORD PTR _sign$[ebp]
	shl	esi, 5
	add	esi, DWORD PTR _gauss_lagrange+4

; 668  :  
; 669  :   for ( m = 0 ; m < gl->gnumpts ; m++ )  /*  integration point number */

	xor	edi, edi
	mov	DWORD PTR _gl$[ebp], esi
	mov	DWORD PTR _m$[ebp], edi
	cmp	DWORD PTR [esi+4], ecx
	jle	$LN27@edge_gener@2
	fstp	ST(1)
	jmp	SHORT $LN6@edge_gener@2
	npad	10
$LL43@edge_gener@2:
	fstp	ST(0)
	fld	QWORD PTR _sign$[ebp]
$LN6@edge_gener@2:

; 670  :   { for ( k = 0 ; k < SDIM ; k++ )

	mov	ecx, DWORD PTR _web+616
	xor	eax, eax
	cmp	ecx, 4
	jl	$LC16@edge_gener@2

; 668  :  
; 669  :   for ( m = 0 ; m < gl->gnumpts ; m++ )  /*  integration point number */

	mov	edx, DWORD PTR [ebx+1268]
	lea	esi, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR [ebx+1276]
	lea	edi, DWORD PTR [edx+edi*4]

; 670  :   { for ( k = 0 ; k < SDIM ; k++ )

	lea	edx, DWORD PTR _z$[ebp+ecx*8+8]

; 672  :        z[SDIM+k] = sign*e_info->sides[m][0][k];

	lea	ebx, DWORD PTR _z$[ebp+8]
	mov	ecx, 16					; 00000010H
	sub	ecx, ebx
	mov	DWORD PTR tv701[ebp], ecx
	mov	ecx, 24					; 00000018H
	sub	ecx, ebx
	mov	DWORD PTR tv387[ebp], edi
	mov	DWORD PTR tv774[ebp], ecx
$LN20@edge_gener@2:

; 671  :      { z[k] = e_info->gauss_pt[m][k]; 

	mov	ebx, DWORD PTR [esi]
	fld	QWORD PTR [ebx+eax*8]

; 672  :        z[SDIM+k] = sign*e_info->sides[m][0][k];

	lea	ecx, DWORD PTR _z$[ebp+eax*8+8]
	fstp	QWORD PTR [ecx-8]
	mov	ebx, DWORD PTR [edi]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+eax*8]
	add	eax, 4
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	fstp	QWORD PTR [edx-40]
	mov	ebx, DWORD PTR [esi]
	fld	QWORD PTR [ebx+eax*8-24]
	fstp	QWORD PTR [ecx]
	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+eax*8-24]
	mov	edi, DWORD PTR tv701[ebp]
	fmul	ST(0), ST(1)
	add	edi, ecx
	fstp	QWORD PTR [edx-32]
	mov	ebx, DWORD PTR [esi]
	fld	QWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR tv387[ebp]
	fstp	QWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR tv774[ebp]
	fmul	ST(0), ST(1)
	add	ebx, ecx
	fstp	QWORD PTR [edx-24]
	mov	edi, DWORD PTR [esi]
	fld	QWORD PTR [ebx+edi]
	mov	edi, DWORD PTR tv387[ebp]
	fstp	QWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _web+616
	fmul	ST(0), ST(1)
	lea	ebx, DWORD PTR [ecx-3]
	fstp	QWORD PTR [edx-16]
	cmp	eax, ebx
	jl	SHORT $LN20@edge_gener@2
	mov	ebx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	esi, DWORD PTR _gl$[ebp]
	mov	edi, DWORD PTR _m$[ebp]
$LC16@edge_gener@2:

; 670  :   { for ( k = 0 ; k < SDIM ; k++ )

	cmp	eax, ecx
	jge	SHORT $LN37@edge_gener@2

; 668  :  
; 669  :   for ( m = 0 ; m < gl->gnumpts ; m++ )  /*  integration point number */

	mov	edx, DWORD PTR [ebx+1268]
	lea	edx, DWORD PTR [edx+edi*4]
	mov	DWORD PTR tv375[ebp], edx
	mov	edx, DWORD PTR [ebx+1276]
	lea	edx, DWORD PTR [edx+edi*4]
	mov	DWORD PTR tv387[ebp], edx

; 670  :   { for ( k = 0 ; k < SDIM ; k++ )

	lea	edx, DWORD PTR [ecx+eax]
	lea	edx, DWORD PTR _z$[ebp+edx*8]
$LN21@edge_gener@2:

; 671  :      { z[k] = e_info->gauss_pt[m][k]; 

	mov	esi, DWORD PTR tv375[ebp]
	mov	esi, DWORD PTR [esi]
	fld	QWORD PTR [esi+eax*8]

; 672  :        z[SDIM+k] = sign*e_info->sides[m][0][k];

	mov	esi, DWORD PTR tv387[ebp]
	fstp	QWORD PTR _z$[ebp+eax*8]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi]
	fld	QWORD PTR [esi+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	add	edx, 8
	fstp	QWORD PTR [edx-8]
	cmp	eax, ecx
	jl	SHORT $LN21@edge_gener@2

; 670  :   { for ( k = 0 ; k < SDIM ; k++ )

	mov	esi, DWORD PTR _gl$[ebp]
$LN37@edge_gener@2:

; 673  :      }
; 674  :      z[2*SDIM] = m; /* kludge for attr interp */
; 675  :      value += gl->gausswt[m]*eval(METH_INSTANCE(e_info->method)->expr[0],z,e_info->id,NULL);

	mov	eax, DWORD PTR [ebx]
	fstp	ST(0)
	fild	DWORD PTR _m$[ebp]
	push	0
	push	eax
	mov	eax, DWORD PTR [ebx+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	add	ecx, ecx
	fstp	QWORD PTR _z$[ebp+ecx*8]
	mov	eax, DWORD PTR [eax+edx+232]
	lea	ecx, DWORD PTR _z$[ebp]
	push	ecx
	push	eax
	call	_eval
	mov	ecx, DWORD PTR [esi+12]
	fmul	QWORD PTR [ecx+edi*8]
	inc	edi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _m$[ebp], edi
	fadd	QWORD PTR _value$[ebp]
	fst	QWORD PTR _value$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jl	$LL43@edge_gener@2
	pop	edi
	pop	esi
	pop	ebx

; 676  :   }
; 677  :   return value;
; 678  : } // end edge_general_value_lagrange()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@edge_gener@2:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_general_value_lagrange ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_general_grad_lagrange
; Function compile flags: /Ogtp
;	COMDAT _edge_general_grad_lagrange
_TEXT	SEGMENT
_val$ = -264						; size = 8
_weight$89587 = -256					; size = 8
_sign$ = -248						; size = 8
_value$ = -240						; size = 8
tv829 = -232						; size = 4
tv838 = -228						; size = 4
_gl$ = -224						; size = 4
_m$ = -220						; size = 4
tv446 = -216						; size = 4
_e_info$GSCopy$ = -212					; size = 4
tv458 = -208						; size = 4
_derivs$ = -204						; size = 96
_z$ = -108						; size = 104
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_general_grad_lagrange PROC			; COMDAT

; 688  : { int m,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, DWORD PTR _e_info$[ebp]

; 689  :   REAL value = 0.0;

	fldz

; 690  :   REAL val;
; 691  :   REAL derivs[2*MAXCOORD];
; 692  :   REAL z[2*MAXCOORD+1];  /*  pointers to coord and tangent */
; 693  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	eax, DWORD PTR [ecx]
	fst	QWORD PTR _value$[ebp]
	mov	edx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	edx, edx
	or	eax, edx

; 695  : 
; 696  :   for ( m = 0 ; m < gl->gnumpts ; m++ )  /*  integration point number */

	mov	DWORD PTR _e_info$GSCopy$[ebp], ecx
	je	SHORT $LN15@edge_gener@3

; 690  :   REAL val;
; 691  :   REAL derivs[2*MAXCOORD];
; 692  :   REAL z[2*MAXCOORD+1];  /*  pointers to coord and tangent */
; 693  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN69@edge_gener@3
$LN15@edge_gener@3:
	fld1
$LN69@edge_gener@3:
	push	ebx
	fst	QWORD PTR _sign$[ebp]

; 694  :   struct gauss_lag *gl = &gauss_lagrange[1][web.gauss1D_order];

	mov	ebx, DWORD PTR _web+1592
	shl	ebx, 5
	add	ebx, DWORD PTR _gauss_lagrange+4
	push	edi

; 695  : 
; 696  :   for ( m = 0 ; m < gl->gnumpts ; m++ )  /*  integration point number */

	xor	edi, edi
	mov	DWORD PTR _gl$[ebp], ebx
	mov	DWORD PTR _m$[ebp], edi
	cmp	DWORD PTR [ebx+4], edx
	jle	$LN41@edge_gener@3
	push	esi
	fstp	ST(1)
	mov	esi, DWORD PTR _web+616
	jmp	SHORT $LN12@edge_gener@3
	npad	11
$LL67@edge_gener@3:
	mov	ecx, DWORD PTR _e_info$GSCopy$[ebp]
	fstp	ST(0)
	fld	QWORD PTR _sign$[ebp]
$LN12@edge_gener@3:

; 697  :   { REAL weight = gl->gausswt[m];

	mov	eax, DWORD PTR [ebx+12]
	fld	QWORD PTR [eax+edi*8]

; 698  :      for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	fstp	QWORD PTR _weight$89587[ebp]
	cmp	esi, 4
	jl	$LC26@edge_gener@3

; 695  : 
; 696  :   for ( m = 0 ; m < gl->gnumpts ; m++ )  /*  integration point number */

	mov	edx, DWORD PTR [ecx+1268]
	mov	ecx, DWORD PTR [ecx+1276]
	lea	ebx, DWORD PTR [edx+edi*4]
	lea	edx, DWORD PTR [ecx+edi*4]

; 700  :        z[SDIM+k] = sign*e_info->sides[m][0][k];

	lea	edi, DWORD PTR _z$[ebp+8]
	mov	ecx, 16					; 00000010H
	sub	ecx, edi
	mov	DWORD PTR tv829[ebp], ecx
	mov	ecx, 24					; 00000018H
	sub	ecx, edi
	mov	DWORD PTR tv458[ebp], edx
	mov	DWORD PTR tv446[ebp], ebx
	lea	edx, DWORD PTR _z$[ebp+esi*8+8]
	mov	DWORD PTR tv838[ebp], ecx
	jmp	SHORT $LN27@edge_gener@3
$LN31@edge_gener@3:
	mov	ebx, DWORD PTR tv446[ebp]

; 698  :      for ( k = 0 ; k < SDIM ; k++ )

$LN27@edge_gener@3:

; 699  :      { z[k] = e_info->gauss_pt[m][k]; 

	mov	edi, DWORD PTR [ebx]
	fld	QWORD PTR [edi+eax*8]

; 700  :        z[SDIM+k] = sign*e_info->sides[m][0][k];

	mov	edi, DWORD PTR tv458[ebp]
	fstp	QWORD PTR _z$[ebp+eax*8]
	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+eax*8]
	lea	ecx, DWORD PTR _z$[ebp+eax*8+8]
	fmul	ST(0), ST(1)
	add	eax, 4
	add	edx, 32					; 00000020H
	fstp	QWORD PTR [edx-40]
	mov	edi, DWORD PTR [ebx]
	fld	QWORD PTR [edi+eax*8-24]
	mov	edi, DWORD PTR tv458[ebp]
	fstp	QWORD PTR [ecx]
	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+eax*8-24]
	mov	edi, DWORD PTR tv829[ebp]
	fmul	ST(0), ST(1)
	add	edi, ecx
	fstp	QWORD PTR [edx-32]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR tv458[ebp]
	fstp	QWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+edi]
	mov	edi, DWORD PTR tv838[ebp]
	mov	ebx, DWORD PTR tv446[ebp]
	fmul	ST(0), ST(1)
	add	edi, ecx
	fstp	QWORD PTR [edx-24]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [edi+ebx]
	fstp	QWORD PTR [ecx+16]
	mov	ecx, DWORD PTR tv458[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [ecx+edi]
	lea	ecx, DWORD PTR [esi-3]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx-16]
	cmp	eax, ecx
	jl	$LN31@edge_gener@3
	mov	ebx, DWORD PTR _gl$[ebp]
	mov	edi, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _e_info$GSCopy$[ebp]
$LC26@edge_gener@3:

; 698  :      for ( k = 0 ; k < SDIM ; k++ )

	cmp	eax, esi
	jge	SHORT $LN52@edge_gener@3

; 695  : 
; 696  :   for ( m = 0 ; m < gl->gnumpts ; m++ )  /*  integration point number */

	mov	edx, DWORD PTR [ecx+1268]
	mov	ecx, DWORD PTR [ecx+1276]
	lea	edx, DWORD PTR [edx+edi*4]
	mov	DWORD PTR tv446[ebp], edx
	lea	edx, DWORD PTR [ecx+edi*4]

; 698  :      for ( k = 0 ; k < SDIM ; k++ )

	lea	ecx, DWORD PTR [esi+eax]
	mov	DWORD PTR tv458[ebp], edx
	lea	ecx, DWORD PTR _z$[ebp+ecx*8]
$LN34@edge_gener@3:

; 699  :      { z[k] = e_info->gauss_pt[m][k]; 

	mov	edx, DWORD PTR tv446[ebp]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+eax*8]

; 700  :        z[SDIM+k] = sign*e_info->sides[m][0][k];

	mov	edx, DWORD PTR tv458[ebp]
	fstp	QWORD PTR _z$[ebp+eax*8]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	add	ecx, 8
	fstp	QWORD PTR [ecx-8]
	cmp	eax, esi
	jl	SHORT $LN34@edge_gener@3

; 698  :      for ( k = 0 ; k < SDIM ; k++ )

	mov	ecx, DWORD PTR _e_info$GSCopy$[ebp]
$LN52@edge_gener@3:

; 701  :      }
; 702  :      z[2*SDIM] = m; /* kludge for attr interp */
; 703  :      eval_all(METH_INSTANCE(e_info->method)->expr[0],z,2*SDIM,&val,derivs,e_info->id);

	mov	edx, DWORD PTR [ecx]
	fstp	ST(0)
	fild	DWORD PTR _m$[ebp]
	push	edx
	mov	eax, esi
	add	eax, eax
	fstp	QWORD PTR _z$[ebp+eax*8]
	lea	eax, DWORD PTR _derivs$[ebp]
	push	eax
	lea	edx, DWORD PTR _val$[ebp]
	push	edx
	lea	eax, DWORD PTR [esi+esi]
	push	eax
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _meth_inst_list
	lea	edx, DWORD PTR _z$[ebp]
	push	edx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	mov	edx, DWORD PTR [eax+ecx+232]
	push	edx
	call	_eval_all

; 704  :      value += weight*val;
; 705  :      for ( k = 0 ; k < gl->lagpts ; k++ )

	mov	esi, DWORD PTR _web+616
	fld	QWORD PTR _val$[ebp]
	xor	ecx, ecx
	fld	QWORD PTR _weight$89587[ebp]
	add	esp, 24					; 00000018H
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR _value$[ebp]
	fst	QWORD PTR _value$[ebp]
	cmp	DWORD PTR [ebx+16], ecx
	jle	SHORT $LN58@edge_gener@3
$LN35@edge_gener@3:

; 706  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN5@edge_gener@3
$LN32@edge_gener@3:

; 707  :          e_info->grad[k][j] += weight*(gl->gpoly[m][k]*derivs[j]
; 708  :                                    + gl->gpolypart[m][0][k]*derivs[j+SDIM]);

	mov	ebx, DWORD PTR [ebx+24]
	mov	ebx, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR _gl$[ebp]
	mov	edx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	edx, DWORD PTR [edx+1336]
	mov	edx, DWORD PTR [edx+ecx*4]
	add	esi, eax
	fmul	QWORD PTR _derivs$[ebp+esi*8]
	mov	esi, DWORD PTR [ebx+20]
	mov	esi, DWORD PTR [esi+edi*4]
	fld	QWORD PTR [esi+ecx*8]
	lea	edx, DWORD PTR [edx+eax*8]
	fmul	QWORD PTR _derivs$[ebp+eax*8]
	inc	eax
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	esi, DWORD PTR _web+616
	cmp	eax, esi
	jl	SHORT $LN32@edge_gener@3
$LN5@edge_gener@3:

; 704  :      value += weight*val;
; 705  :      for ( k = 0 ; k < gl->lagpts ; k++ )

	inc	ecx
	cmp	ecx, DWORD PTR [ebx+16]
	jl	SHORT $LN35@edge_gener@3
$LN58@edge_gener@3:

; 695  : 
; 696  :   for ( m = 0 ; m < gl->gnumpts ; m++ )  /*  integration point number */

	inc	edi

; 704  :      value += weight*val;
; 705  :      for ( k = 0 ; k < gl->lagpts ; k++ )

	fstp	ST(1)
	mov	DWORD PTR _m$[ebp], edi
	cmp	edi, DWORD PTR [ebx+4]
	jl	$LL67@edge_gener@3
	pop	esi
	pop	edi
	pop	ebx

; 709  :   }
; 710  :   return value;
; 711  : } // end edge_general_grad_lagrange()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@edge_gener@3:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	pop	edi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_general_grad_lagrange ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_general_hess_lagrange
EXTRN	_eval_second:PROC
EXTRN	_mat2d_setup:PROC
; Function compile flags: /Ogtp
;	COMDAT _edge_general_hess_lagrange
_TEXT	SEGMENT
_secondqXvS$ = -1472					; size = 48
_val$ = -1424						; size = 8
_sign$ = -1416						; size = 8
_weight$89620 = -1408					; size = 8
tv820 = -1404						; size = 4
_value$ = -1400						; size = 8
_gl$ = -1392						; size = 4
_second$ = -1388					; size = 4
tv1081 = -1384						; size = 4
_k$ = -1384						; size = 4
_e_info$GSCopy$ = -1380					; size = 4
tv1090 = -1376						; size = 4
tv769 = -1376						; size = 4
tv737 = -1376						; size = 4
_m$ = -1372						; size = 4
tv1054 = -1368						; size = 4
tv782 = -1368						; size = 4
tv606 = -1364						; size = 4
_j$ = -1364						; size = 4
tv618 = -1360						; size = 4
_kk$ = -1360						; size = 4
_secondxJ$ = -1356					; size = 1152
_derivs$ = -204						; size = 96
_z$ = -108						; size = 104
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_general_hess_lagrange PROC			; COMDAT

; 721  : { int m,j,jj,k,kk;

	push	ebp
	mov	ebp, esp
	sub	esp, 1472				; 000005c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 722  :   REAL value = 0.0;

	fldz
	push	ebx
	push	esi
	fstp	QWORD PTR _value$[ebp]
	mov	esi, DWORD PTR _e_info$[ebp]
	push	edi

; 723  :   REAL val;
; 724  :   REAL derivs[2*MAXCOORD];
; 725  :   REAL z[2*MAXCOORD+1];  /*  pointers to coord and tangent */
; 726  :   MAT2D(second,2*MAXCOORD,2*MAXCOORD); /* second derivatives */

	push	12					; 0000000cH
	push	12					; 0000000cH
	lea	eax, DWORD PTR _secondxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _secondqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _e_info$GSCopy$[ebp], esi
	call	_mat2d_setup

; 727  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR _second$[ebp], eax
	mov	eax, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	add	esp, 16					; 00000010H
	or	eax, ecx
	je	SHORT $LN27@edge_gener@4
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN102@edge_gener@4
$LN27@edge_gener@4:
	fld1
$LN102@edge_gener@4:

; 728  :   struct gauss_lag *gl = &gauss_lagrange[1][web.gauss1D_order];

	mov	ebx, DWORD PTR _web+1592
	fst	QWORD PTR _sign$[ebp]
	shl	ebx, 5
	add	ebx, DWORD PTR _gauss_lagrange+4

; 729  : 
; 730  :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	edi, edi
	mov	DWORD PTR _gl$[ebp], ebx
	mov	DWORD PTR _m$[ebp], edi
	cmp	DWORD PTR [ebx+4], ecx
	jle	$LN62@edge_gener@4
	mov	esi, DWORD PTR _web+616
	jmp	SHORT $LN24@edge_gener@4
	npad	13
$LL100@edge_gener@4:
	mov	edi, DWORD PTR _m$[ebp]
	fstp	ST(0)
	fld	QWORD PTR _sign$[ebp]
$LN24@edge_gener@4:

; 731  :   { REAL weight = gl->gausswt[m];

	mov	ecx, DWORD PTR [ebx+12]
	fld	QWORD PTR [ecx+edi*8]

; 732  :      for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	fstp	QWORD PTR _weight$89620[ebp]
	cmp	esi, 4
	jl	$LC46@edge_gener@4

; 729  : 
; 730  :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	mov	ecx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	edx, DWORD PTR [ecx+1268]
	mov	ecx, DWORD PTR [ecx+1276]
	lea	edx, DWORD PTR [edx+edi*4]
	mov	DWORD PTR tv606[ebp], edx
	lea	edx, DWORD PTR [ecx+edi*4]

; 734  :        z[SDIM+k] = sign*e_info->sides[m][0][k];

	lea	edi, DWORD PTR _z$[ebp+8]
	mov	ecx, 16					; 00000010H
	sub	ecx, edi
	mov	DWORD PTR tv1081[ebp], ecx
	mov	ecx, 24					; 00000018H
	mov	DWORD PTR tv618[ebp], edx
	lea	edx, DWORD PTR _z$[ebp+esi*8+8]
	sub	ecx, edi
	mov	DWORD PTR tv1054[ebp], edx
	mov	DWORD PTR tv1090[ebp], ecx
$LN53@edge_gener@4:

; 733  :      { z[k] = e_info->gauss_pt[m][k]; 

	mov	edi, DWORD PTR tv606[ebp]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+eax*8]

; 734  :        z[SDIM+k] = sign*e_info->sides[m][0][k];

	mov	edi, DWORD PTR tv618[ebp]
	fstp	QWORD PTR _z$[ebp+eax*8]
	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR tv606[ebp]
	lea	ecx, DWORD PTR _z$[ebp+eax*8+8]
	fmul	ST(0), ST(1)
	add	eax, 4
	fstp	QWORD PTR [edx-8]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+eax*8-24]
	mov	edi, DWORD PTR tv618[ebp]
	fstp	QWORD PTR [ecx]
	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+eax*8-24]
	mov	edi, DWORD PTR tv606[ebp]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edi, DWORD PTR [edi]
	mov	edx, DWORD PTR tv1081[ebp]
	add	edx, ecx
	fld	QWORD PTR [edx+edi]
	mov	edi, DWORD PTR tv618[ebp]
	fstp	QWORD PTR [ecx+8]
	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+edx]
	mov	edx, DWORD PTR tv1054[ebp]
	mov	edi, DWORD PTR tv606[ebp]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx+8]
	mov	edx, DWORD PTR tv1090[ebp]
	mov	edi, DWORD PTR [edi]
	add	edx, ecx
	fld	QWORD PTR [edx+edi]
	fstp	QWORD PTR [ecx+16]
	mov	ecx, DWORD PTR tv618[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [ecx+edx]
	mov	edx, DWORD PTR tv1054[ebp]
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	lea	ecx, DWORD PTR [esi-3]
	mov	DWORD PTR tv1054[ebp], edx
	fstp	QWORD PTR [edx-16]
	cmp	eax, ecx
	jl	$LN53@edge_gener@4
	mov	edi, DWORD PTR _m$[ebp]
$LC46@edge_gener@4:

; 732  :      for ( k = 0 ; k < SDIM ; k++ )

	cmp	eax, esi
	jge	SHORT $LN75@edge_gener@4

; 729  : 
; 730  :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	mov	ecx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	edx, DWORD PTR [ecx+1268]
	mov	ecx, DWORD PTR [ecx+1276]
	lea	edx, DWORD PTR [edx+edi*4]
	mov	DWORD PTR tv606[ebp], edx
	lea	edx, DWORD PTR [ecx+edi*4]

; 732  :      for ( k = 0 ; k < SDIM ; k++ )

	lea	ecx, DWORD PTR [esi+eax]
	mov	DWORD PTR tv618[ebp], edx
	lea	ecx, DWORD PTR _z$[ebp+ecx*8]
$LN56@edge_gener@4:

; 733  :      { z[k] = e_info->gauss_pt[m][k]; 

	mov	edx, DWORD PTR tv606[ebp]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+eax*8]

; 734  :        z[SDIM+k] = sign*e_info->sides[m][0][k];

	mov	edx, DWORD PTR tv618[ebp]
	fstp	QWORD PTR _z$[ebp+eax*8]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	add	ecx, 8
	fstp	QWORD PTR [ecx-8]
	cmp	eax, esi
	jl	SHORT $LN56@edge_gener@4
$LN75@edge_gener@4:

; 735  :      }
; 736  :      z[2*SDIM] = m; /* kludge for attr interp */
; 737  :      eval_second(METH_INSTANCE(e_info->method)->expr[0],z,2*SDIM,&val,derivs,second,e_info->id);

	mov	edx, DWORD PTR _second$[ebp]
	fstp	ST(0)
	fild	DWORD PTR _m$[ebp]
	mov	eax, esi
	add	eax, eax
	fstp	QWORD PTR _z$[ebp+eax*8]
	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _derivs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _val$[ebp]
	push	edx
	lea	ecx, DWORD PTR [esi+esi]
	push	ecx
	mov	ecx, DWORD PTR _meth_inst_list
	lea	edx, DWORD PTR _z$[ebp]
	push	edx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	mov	edx, DWORD PTR [eax+ecx+232]
	push	edx
	call	_eval_second

; 738  :      value += weight*val;
; 739  :      for ( k = 0 ; k < gl->lagpts ; k++ )

	mov	esi, DWORD PTR _web+616
	fld	QWORD PTR _val$[ebp]
	xor	ecx, ecx
	fld	QWORD PTR _weight$89620[ebp]
	add	esp, 28					; 0000001cH
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR _value$[ebp]
	fst	QWORD PTR _value$[ebp]
	cmp	DWORD PTR [ebx+16], ecx
	jle	SHORT $LN16@edge_gener@4
$LN58@edge_gener@4:

; 740  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN17@edge_gener@4
$LN54@edge_gener@4:
	mov	edx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	edx, DWORD PTR [edx+1336]
	mov	edx, DWORD PTR [edx+ecx*4]
	lea	edx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR tv737[ebp], edx

; 741  :          e_info->grad[k][j] += weight*(gl->gpoly[m][k]*derivs[j]
; 742  :                                         + gl->gpolypart[m][0][k]*derivs[j+SDIM]);

	mov	edx, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR [ebx+20]
	mov	edx, DWORD PTR [edx+edi*4]
	add	esi, eax
	fmul	QWORD PTR _derivs$[ebp+esi*8]
	inc	eax
	fld	QWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR tv737[ebp]
	fmul	QWORD PTR _derivs$[ebp+eax*8-8]
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	esi, DWORD PTR _web+616
	cmp	eax, esi
	jl	SHORT $LN54@edge_gener@4
$LN17@edge_gener@4:

; 738  :      value += weight*val;
; 739  :      for ( k = 0 ; k < gl->lagpts ; k++ )

	inc	ecx
	cmp	ecx, DWORD PTR [ebx+16]
	jl	SHORT $LN58@edge_gener@4
$LN16@edge_gener@4:

; 743  :      for ( k = 0 ; k < gl->lagpts ; k++ )

	mov	eax, DWORD PTR [ebx+16]
	xor	edi, edi
	mov	DWORD PTR _k$[ebp], edi
	test	eax, eax
	jle	$LN98@edge_gener@4
$LN59@edge_gener@4:

; 744  :       for ( kk = 0 ; kk < gl->lagpts ; kk++ )

	xor	edx, edx
	mov	DWORD PTR _kk$[ebp], edx
	test	eax, eax
	jle	$LN11@edge_gener@4
$LN57@edge_gener@4:

; 745  :         for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	mov	DWORD PTR _j$[ebp], ecx
	test	esi, esi
	jle	$LN8@edge_gener@4
$LN6@edge_gener@4:

; 746  :          for ( jj = 0 ; jj < SDIM ; jj++ )

	xor	eax, eax
	test	esi, esi
	jle	$LN5@edge_gener@4
	mov	edx, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv782[ebp], ecx
$LN51@edge_gener@4:

; 747  :             e_info->hess[k][kk][j][jj] += weight*
; 748  :              (gl->gpoly[m][k]*gl->gpoly[m][kk]*second[j][jj] +
; 749  :               gl->gpolypart[m][0][k]*gl->gpoly[m][kk]*second[j+SDIM][jj] +
; 750  :               gl->gpoly[m][k]*gl->gpolypart[m][0][kk]*second[j][jj+SDIM] +
; 751  :               gl->gpolypart[m][0][k]*gl->gpolypart[m][0][kk]*second[j+SDIM][jj+SDIM]);

	mov	ecx, DWORD PTR [ebx+24]
	mov	ebx, DWORD PTR [ebx+20]
	add	esi, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _second$[ebp]
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	ebx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ebx, DWORD PTR [ebx+1340]
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR _kk$[ebp]
	mov	edi, DWORD PTR [edi+ebx*4]
	mov	ebx, DWORD PTR _j$[ebp]
	mov	edi, DWORD PTR [edi+ebx*4]
	mov	ebx, DWORD PTR _kk$[ebp]
	mov	ecx, DWORD PTR [ecx]
	lea	edi, DWORD PTR [edi+eax*8]
	mov	DWORD PTR tv820[ebp], edi
	mov	edi, DWORD PTR _k$[ebp]
	fld	QWORD PTR [edx+edi*8]
	mov	DWORD PTR tv769[ebp], esi
	fmul	QWORD PTR [edx+ebx*8]
	mov	ebx, DWORD PTR tv782[ebp]
	mov	esi, DWORD PTR _web+616
	add	esi, eax
	fmul	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR _kk$[ebp]
	fld	QWORD PTR [edx+ebx*8]
	mov	ebx, DWORD PTR tv769[ebp]
	fmul	QWORD PTR [ecx+edi*8]
	add	esi, esi
	add	esi, esi
	add	esi, esi
	fmul	QWORD PTR [ebx+eax*8]
	inc	eax
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR _kk$[ebp]
	fmul	QWORD PTR [ecx+edx*8]
	mov	edx, DWORD PTR tv782[ebp]
	fmul	QWORD PTR [esi+edx]
	mov	edx, DWORD PTR _kk$[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx+edi*8]
	fmul	QWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR tv820[ebp]
	fmul	QWORD PTR [esi+ebx]
	mov	ebx, DWORD PTR _gl$[ebp]
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	esi, DWORD PTR _web+616
	cmp	eax, esi
	jl	$LN51@edge_gener@4

; 746  :          for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	ecx, DWORD PTR _j$[ebp]
$LN5@edge_gener@4:

; 745  :         for ( j = 0 ; j < SDIM ; j++ )

	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, esi
	jl	$LN6@edge_gener@4
$LN8@edge_gener@4:

; 744  :       for ( kk = 0 ; kk < gl->lagpts ; kk++ )

	inc	edx
	mov	DWORD PTR _kk$[ebp], edx
	cmp	edx, DWORD PTR [ebx+16]
	jl	$LN57@edge_gener@4
$LN11@edge_gener@4:

; 743  :      for ( k = 0 ; k < gl->lagpts ; k++ )

	mov	eax, DWORD PTR [ebx+16]
	inc	edi
	mov	DWORD PTR _k$[ebp], edi
	cmp	edi, eax
	jl	$LN59@edge_gener@4
$LN98@edge_gener@4:

; 729  : 
; 730  :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	mov	eax, DWORD PTR _m$[ebp]

; 746  :          for ( jj = 0 ; jj < SDIM ; jj++ )

	fstp	ST(1)
	inc	eax
	mov	DWORD PTR _m$[ebp], eax
	cmp	eax, DWORD PTR [ebx+4]
	jl	$LL100@edge_gener@4
	pop	edi
	pop	esi
	pop	ebx

; 752  :   }
; 753  :   return value;
; 754  : } // end edge_general_hess_lagrange()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@edge_gener@4:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	fld	QWORD PTR _value$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_general_hess_lagrange ENDP
_TEXT	ENDS
PUBLIC	__real@4018000000000000
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_energy_l
EXTRN	_get_wulff:DWORD
EXTRN	_simplex_energy_metric:PROC
EXTRN	_klein_length:PROC
EXTRN	_klein_metric_flag:DWORD
EXTRN	_sym_wrap:DWORD
EXTRN	__CIsqrt:PROC
;	COMDAT __real@4018000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\stringl.c
CONST	ENDS
;	COMDAT _edge_energy_l
_TEXT	SEGMENT
tv850 = -184						; size = 4
tv846 = -180						; size = 4
_e_id$GSCopy$ = -176					; size = 4
_v$ = -172						; size = 8
_x$ = -164						; size = 8
tv842 = -156						; size = 4
tv424 = -156						; size = 4
tv825 = -152						; size = 4
tv417 = -152						; size = 4
_wulff$89056 = -148					; size = 48
_xx$ = -100						; size = 48
_side$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_edge_energy_l PROC					; COMDAT

; 27   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 28   :   REAL energy;
; 29   :   vertex_id v[2];
; 30   :   int i;
; 31   :   REAL *x[2];
; 32   :   REAL xx[MAXCOORD];
; 33   :   REAL side[MAXCOORD];
; 34   : 
; 35   :   v[0] = get_edge_tailv(e_id);

	mov	edx, DWORD PTR _web+216
	push	ebx
	push	esi
	mov	esi, DWORD PTR _dymem
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]
	mov	eax, edi
	shr	eax, 27					; 0000001bH
	and	eax, 1

; 64   : 
; 65   :   energy *= get_edge_density(e_id);

	mov	DWORD PTR _e_id$GSCopy$[ebp], edi
	mov	DWORD PTR tv417[ebp], eax
	je	SHORT $LN16@edge_energ

; 28   :   REAL energy;
; 29   :   vertex_id v[2];
; 30   :   int i;
; 31   :   REAL *x[2];
; 32   :   REAL xx[MAXCOORD];
; 33   :   REAL side[MAXCOORD];
; 34   : 
; 35   :   v[0] = get_edge_tailv(e_id);

	mov	eax, DWORD PTR _web+124
	mov	ebx, DWORD PTR _web+636
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	lea	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN47@edge_energ
$LN16@edge_energ:
	mov	ecx, DWORD PTR _web+124
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [ecx+edi]
	add	ecx, edi
$LN47@edge_energ:
	mov	ebx, DWORD PTR [edx+esi+304]
	mov	eax, DWORD PTR [eax+ebx]
	add	edx, esi

; 36   :   v[1] = get_edge_headv(e_id);

	cmp	DWORD PTR tv417[ebp], 0
	mov	DWORD PTR tv424[ebp], edx
	mov	DWORD PTR _v$[ebp], eax
	mov	edx, DWORD PTR [edx+304]
	je	SHORT $LN20@edge_energ
	mov	ebx, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [ebx+edx]
	jmp	SHORT $LN19@edge_energ
$LN20@edge_energ:
	mov	ebx, DWORD PTR _web+636
	mov	esi, DWORD PTR [ecx]
	lea	esi, DWORD PTR [esi+ebx*4]
	mov	ebx, DWORD PTR [esi+edx]
	mov	esi, DWORD PTR _dymem
$LN19@edge_energ:

; 37   :   x[0] = get_coord(v[0]);

	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR _v$[ebp+4], ebx
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+esi+64]

; 38   :   x[1] = get_coord(v[1]);

	mov	eax, DWORD PTR _web+12
	and	ebx, 134217727				; 07ffffffH
	mov	DWORD PTR _x$[ebp], edx
	mov	ebx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR _web+104
	add	ebx, DWORD PTR [eax+esi+64]

; 39   :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	mov	DWORD PTR _x$[ebp+4], ebx
	je	SHORT $LN12@edge_energ

; 40   :   { (*sym_wrap)(x[1],xx,get_edge_wrap(e_id));

	cmp	DWORD PTR tv417[ebp], 0
	mov	edx, DWORD PTR tv424[ebp]
	mov	eax, DWORD PTR [edx+784]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+ecx]
	je	SHORT $LN25@edge_energ
	push	eax
	call	DWORD PTR _sym_inverse
	mov	ebx, DWORD PTR _x$[ebp+4]
	add	esp, 4
$LN25@edge_energ:
	push	eax
	lea	edx, DWORD PTR _xx$[ebp]
	push	edx
	push	ebx
	call	DWORD PTR _sym_wrap

; 41   :     x[1] = xx;

	mov	edx, DWORD PTR _x$[ebp]
	lea	ebx, DWORD PTR _xx$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _x$[ebp+4], ebx
$LN12@edge_energ:

; 42   :   }
; 43   :   for ( i = 0 ; i < SDIM ; i++ ) side[i] = x[1][i] - x[0][i];

	xor	esi, esi
	cmp	DWORD PTR _web+616, 4
	jl	$LC30@edge_energ
	lea	ecx, DWORD PTR [ebx+24]
	sub	ebx, edx
	mov	DWORD PTR tv825[ebp], ebx
	lea	ebx, DWORD PTR _side$[ebp]
	sub	ebx, edx
	mov	DWORD PTR tv842[ebp], ebx
	lea	ebx, DWORD PTR _side$[ebp+8]
	sub	ebx, edx
	mov	DWORD PTR tv846[ebp], ebx
	lea	ebx, DWORD PTR _side$[ebp+16]
	sub	ebx, edx
	lea	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv850[ebp], ebx
$LL31@edge_energ:
	fld	QWORD PTR [ecx-24]
	mov	ebx, DWORD PTR tv825[ebp]
	fsub	QWORD PTR [eax-8]
	add	esi, 4
	add	eax, 32					; 00000020H
	add	ecx, 32					; 00000020H
	fstp	QWORD PTR _side$[ebp+esi*8-32]
	fld	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv842[ebp]
	fsub	QWORD PTR [eax-32]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv846[ebp]
	fld	QWORD PTR [ecx-40]
	fsub	QWORD PTR [eax-24]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv850[ebp]
	fld	QWORD PTR [ecx-32]
	fsub	QWORD PTR [eax-16]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR _web+616
	add	ebx, -3					; fffffffdH
	cmp	esi, ebx
	jl	SHORT $LL31@edge_energ
	mov	ebx, DWORD PTR _x$[ebp+4]
$LC30@edge_energ:
	cmp	esi, DWORD PTR _web+616
	jge	SHORT $LN29@edge_energ
	mov	ecx, ebx
	sub	ecx, edx
	mov	DWORD PTR tv825[ebp], ecx
	lea	ecx, DWORD PTR _side$[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv842[ebp], ecx
	mov	ecx, DWORD PTR _web+616
	lea	eax, DWORD PTR [edx+esi*8]
	sub	ecx, esi
	npad	11
$LL32@edge_energ:
	mov	esi, DWORD PTR tv825[ebp]
	fld	QWORD PTR [eax+esi]
	mov	esi, DWORD PTR tv842[ebp]
	fsub	QWORD PTR [eax]
	add	eax, 8
	dec	ecx
	fstp	QWORD PTR [eax+esi-8]
	jne	SHORT $LL32@edge_energ
$LN29@edge_energ:

; 44   : 
; 45   :   /* energy due to linear tension */
; 46   :   if ( web.metric_flag )

	cmp	DWORD PTR _web+1676, 0
	je	SHORT $LN8@edge_energ

; 47   :   { if ( klein_metric_flag )

	cmp	DWORD PTR _klein_metric_flag, 0
	je	SHORT $LN7@edge_energ

; 48   :        energy = klein_length(x[0],x[1]);

	push	ebx
	push	edx
	call	_klein_length
	add	esp, 8

; 49   :     else

	jmp	SHORT $LN4@edge_energ
$LN7@edge_energ:

; 50   :        energy = simplex_energy_metric(v,x);

	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _v$[ebp]
	push	ecx
	call	_simplex_energy_metric
	add	esp, 8

; 51   :   }
; 52   :   else

	jmp	SHORT $LN4@edge_energ
$LN8@edge_energ:

; 53   :   { /* calculate length energy */
; 54   :     energy = sqrt(SDIM_dot(side,side));

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _side$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 55   :     set_edge_length(e_id,energy);

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [edi+edx]
	fst	QWORD PTR [eax+48]

; 56   :     if ( web.wulff_flag ) 

	cmp	DWORD PTR _web+908, 0
	je	SHORT $LN4@edge_energ

; 57   :     { REAL wulff[MAXCOORD];    /* energy covector to side vector */
; 58   :       (*get_wulff)(side,wulff);

	lea	ecx, DWORD PTR _wulff$89056[ebp]
	fstp	ST(0)
	push	ecx
	lea	edx, DWORD PTR _side$[ebp]
	push	edx
	call	DWORD PTR _get_wulff

; 59   :       energy = SDIM_dot(side,wulff);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _wulff$89056[ebp]
	push	ecx
	lea	edx, DWORD PTR _side$[ebp]
	push	edx
	call	_dot
	add	esp, 20					; 00000014H
$LN4@edge_energ:

; 60   :     }
; 61   :   }
; 62   :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN3@edge_energ

; 63   :       web.total_area    += energy;    /* don't count triple junction as area */

	fld	QWORD PTR _web+992
	fadd	ST(0), ST(1)
	fstp	QWORD PTR _web+992
$LN3@edge_energ:

; 66   : 
; 67   :   /* calculate gravitational energy */
; 68   :   if ( web.gravflag && !(get_eattr(e_id) & NONCONTENT) )

	cmp	DWORD PTR _web+824, 0
	mov	eax, DWORD PTR _web+124
	mov	edi, DWORD PTR [edi+eax]
	fmul	QWORD PTR [edi+40]
	je	$LN1@edge_energ
	mov	eax, DWORD PTR [edi+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN1@edge_energ

; 69   :   { REAL *t,*h;
; 70   :     REAL grav_e;
; 71   :     REAL density = edge_grav_density(e_id);

	mov	ecx, DWORD PTR _e_id$GSCopy$[ebp]
	push	ecx
	call	_edge_grav_density

; 72   : 
; 73   :     if ( density != 0.0 )

	fld	ST(0)
	fldz
	add	esp, 4
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN43@edge_energ

; 74   :     { t = get_coord(v[0]);

	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _web+12

; 75   :       h = get_coord(v[1]);

	mov	esi, DWORD PTR _v$[ebp+4]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+esi*4]

; 76   :       grav_e = (t[0]-h[0])*(t[1]*t[1] + t[1]*h[1] + h[1]*h[1])/6;

	fld	QWORD PTR [ecx+edx+8]
	fmul	QWORD PTR [eax+edx+8]
	fld	QWORD PTR [eax+edx+8]
	fld	QWORD PTR [ecx+edx+8]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax+edx]
	fsub	QWORD PTR [ecx+edx]
	fmulp	ST(1), ST(0)
	fdiv	QWORD PTR __real@4018000000000000

; 77   :       energy += density*grav_e;

	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	jmp	SHORT $LN1@edge_energ
$LN43@edge_energ:

; 72   : 
; 73   :     if ( density != 0.0 )

	fstp	ST(0)
$LN1@edge_energ:

; 78   :     }
; 79   :   }                    
; 80   : 
; 81   :   web.total_energy = web.total_energy + energy;

	fadd	QWORD PTR _web+1240

; 82   : 
; 83   : } // end edge_energy_l()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	fstp	QWORD PTR _web+1240
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_energy_l ENDP
_TEXT	ENDS
PUBLIC	__real@4000000000000000
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_force_l
EXTRN	_sym_form_pullback:DWORD
EXTRN	_simplex_force_metric:PROC
EXTRN	_klein_length_grad:PROC
EXTRN	_memset:PROC
;	COMDAT __real@4000000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\stringl.c
CONST	ENDS
;	COMDAT _edge_force_l
_TEXT	SEGMENT
_forceptr$ = -316					; size = 8
tv1572 = -308						; size = 4
tv1589 = -304						; size = 4
_v$ = -300						; size = 8
tv1593 = -292						; size = 4
tv1096 = -288						; size = 4
_len$ = -284						; size = 8
tv1597 = -280						; size = 4
tv1001 = -276						; size = 4
tv1105 = -272						; size = 4
tv993 = -268						; size = 4
_force$ = -264						; size = 8
_density$ = -264					; size = 8
_e_id$GSCopy$ = -256					; size = 4
_t$89146 = -256						; size = 4
_x$ = -252						; size = 8
_wforce$89145 = -244					; size = 48
_xx$ = -196						; size = 48
_side$ = -148						; size = 48
_forces$ = -100						; size = 96
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_edge_force_l PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 93   :   REAL len;
; 94   :   REAL side[MAXCOORD];
; 95   :   int i,j;
; 96   :   vertex_id hv,tv;
; 97   :   REAL density = get_edge_density(e_id);

	mov	eax, DWORD PTR _web+124

; 98   :   REAL forces[2][MAXCOORD];  /* total forces from this facet */
; 99   :   REAL *forceptr[2];    /* pointers to forces */
; 100  :   REAL *force[2];  /* vertex forces */
; 101  :   WRAPTYPE wraps[2];
; 102  :   REAL xx[MAXCOORD];
; 103  :   REAL *x[2];
; 104  :   vertex_id v[2];
; 105  : 
; 106  :   v[0] = tv = get_edge_tailv(e_id);

	mov	edx, DWORD PTR _web+216
	push	ebx
	mov	ebx, DWORD PTR _e_id$[ebp]
	push	esi
	mov	esi, DWORD PTR _dymem
	push	edi
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+eax]
	fld	QWORD PTR [eax+40]
	mov	DWORD PTR _e_id$GSCopy$[ebp], ebx
	shr	ebx, 27					; 0000001bH
	fstp	QWORD PTR _density$[ebp]
	and	ebx, 1
	mov	DWORD PTR tv993[ebp], edi
	mov	DWORD PTR tv1001[ebp], ebx
	je	SHORT $LN36@edge_force
	mov	ecx, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+ecx*4]
$LN36@edge_force:
	mov	ecx, DWORD PTR [edx+esi+304]
	mov	ecx, DWORD PTR [eax+ecx]

; 107  :   v[1] = hv = get_edge_headv(e_id);

	mov	eax, DWORD PTR _web+124
	add	edx, esi
	mov	DWORD PTR _v$[ebp], ecx
	mov	eax, DWORD PTR [edi+eax]
	test	ebx, ebx
	jne	SHORT $LN103@edge_force
	mov	edi, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+edi*4]
$LN103@edge_force:
	mov	edi, DWORD PTR [edx+304]
	mov	eax, DWORD PTR [eax+edi]

; 108  :   x[0] = get_coord(v[0]);

	mov	edi, DWORD PTR _web+104
	and	ecx, 134217727				; 07ffffffH
	mov	DWORD PTR _v$[ebp+4], eax
	add	ecx, ecx
	lea	ebx, DWORD PTR [ecx+ecx]
	mov	ecx, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ebx+ecx]
	add	ecx, DWORD PTR [edi+esi+64]

; 109  :   x[1] = get_coord(v[1]);

	mov	edi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR _x$[ebp], ecx
	mov	edi, DWORD PTR [eax+edi]
	mov	DWORD PTR tv1105[ebp], eax
	mov	eax, DWORD PTR _web+104
	add	edi, DWORD PTR [eax+esi+64]

; 110  :   for ( i = 0 ; i < 2 ; i++ ) forceptr[i] = forces[i];
; 111  :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	lea	eax, DWORD PTR _forces$[ebp]
	mov	DWORD PTR _forceptr$[ebp], eax
	lea	eax, DWORD PTR _forces$[ebp+48]
	mov	DWORD PTR tv1096[ebp], ebx
	mov	DWORD PTR _x$[ebp+4], edi
	mov	DWORD PTR _forceptr$[ebp+4], eax
	je	SHORT $LN29@edge_force

; 112  :   { (*sym_wrap)(x[1],xx,get_edge_wrap(e_id));

	cmp	DWORD PTR tv1001[ebp], 0
	mov	ecx, DWORD PTR [edx+784]
	mov	eax, DWORD PTR _web+124
	mov	edx, DWORD PTR tv993[ebp]
	mov	edx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [ecx+edx]
	je	SHORT $LN45@edge_force
	push	eax
	call	DWORD PTR _sym_inverse
	mov	edi, DWORD PTR _x$[ebp+4]
	add	esp, 4
$LN45@edge_force:
	push	eax
	lea	eax, DWORD PTR _xx$[ebp]
	push	eax
	push	edi
	call	DWORD PTR _sym_wrap

; 113  :     x[1] = xx;

	mov	ecx, DWORD PTR _x$[ebp]
	lea	edi, DWORD PTR _xx$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _x$[ebp+4], edi
$LN29@edge_force:

; 114  :   }
; 115  :   for ( i = 0 ; i < SDIM ; i++ ) side[i] = x[1][i] - x[0][i];

	mov	edx, DWORD PTR _web+616
	xor	esi, esi
	cmp	edx, 4
	jl	$LC69@edge_force
	mov	ebx, edi
	sub	ebx, ecx
	mov	DWORD PTR tv1572[ebp], ebx
	lea	ebx, DWORD PTR _side$[ebp]
	sub	ebx, ecx
	mov	DWORD PTR tv1589[ebp], ebx
	lea	ebx, DWORD PTR _side$[ebp+8]
	sub	ebx, ecx
	mov	DWORD PTR tv1593[ebp], ebx
	lea	ebx, DWORD PTR _side$[ebp+16]
	sub	ebx, ecx
	lea	edx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR tv1597[ebp], ebx
	npad	10
$LL70@edge_force:
	fld	QWORD PTR [edx-24]
	mov	ebx, DWORD PTR tv1572[ebp]
	fsub	QWORD PTR [eax-8]
	add	esi, 4
	add	eax, 32					; 00000020H
	add	edx, 32					; 00000020H
	fstp	QWORD PTR _side$[ebp+esi*8-32]
	fld	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv1589[ebp]
	fsub	QWORD PTR [eax-32]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv1593[ebp]
	fld	QWORD PTR [edx-40]
	fsub	QWORD PTR [eax-24]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv1597[ebp]
	fld	QWORD PTR [edx-32]
	fsub	QWORD PTR [eax-16]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR _web+616
	add	ebx, -3					; fffffffdH
	cmp	esi, ebx
	jl	SHORT $LL70@edge_force
	mov	ebx, DWORD PTR tv1096[ebp]
	mov	edx, DWORD PTR _web+616
$LC69@edge_force:
	cmp	esi, edx
	jge	SHORT $LN68@edge_force
	lea	ebx, DWORD PTR _side$[ebp]
	sub	edi, ecx
	sub	ebx, ecx
	lea	eax, DWORD PTR [ecx+esi*8]
	sub	edx, esi
	npad	7
$LC28@edge_force:
	fld	QWORD PTR [eax+edi]
	add	eax, 8
	dec	edx
	fsub	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax+ebx-8]
	jne	SHORT $LC28@edge_force
	mov	ebx, DWORD PTR tv1096[ebp]
$LN68@edge_force:

; 116  : 
; 117  :   memset((char*)forces,0,sizeof(forces));  /* set to 0 */

	push	96					; 00000060H
	lea	ecx, DWORD PTR _forces$[ebp]
	push	0
	push	ecx
	call	_memset

; 118  : 
; 119  :   add_vertex_valence(tv,1);

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [ebx+edx]

; 120  :   add_vertex_valence(hv,1);

	mov	ecx, DWORD PTR tv1105[ebp]
	mov	edi, 1
	add	DWORD PTR [eax+36], edi
	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [ecx+eax]
	add	DWORD PTR [eax+36], edi
	add	esp, 12					; 0000000cH

; 121  : 
; 122  :   /* force due to linear tension */
; 123  :   if ( web.metric_flag )

	cmp	DWORD PTR _web+1676, 0
	je	$LN25@edge_force

; 124  :   { if ( klein_metric_flag )

	cmp	DWORD PTR _klein_metric_flag, 0
	je	SHORT $LN24@edge_force

; 125  :     { len = klein_length(x[0],x[1]);

	mov	edx, DWORD PTR _x$[ebp+4]
	mov	eax, DWORD PTR _x$[ebp]
	push	edx
	push	eax
	call	_klein_length
	fstp	QWORD PTR _len$[ebp]

; 126  :       klein_length_grad(x[0],x[1],forces[0],forces[1]);

	mov	eax, DWORD PTR _x$[ebp+4]
	lea	ecx, DWORD PTR _forces$[ebp+48]
	push	ecx
	mov	ecx, DWORD PTR _x$[ebp]
	lea	edx, DWORD PTR _forces$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_klein_length_grad

; 127  :     }
; 128  :     else

	fld	QWORD PTR _len$[ebp]
	add	esp, 24					; 00000018H
	jmp	SHORT $LN22@edge_force
$LN24@edge_force:

; 129  :     { len = simplex_energy_metric(v,x);

	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	lea	eax, DWORD PTR _v$[ebp]
	push	eax
	call	_simplex_energy_metric
	fstp	QWORD PTR _len$[ebp]

; 130  :       simplex_force_metric(v,x,density,forceptr);

	fld	QWORD PTR _density$[ebp]
	add	esp, 8
	lea	ecx, DWORD PTR _forceptr$[ebp]
	push	ecx
	sub	esp, 8
	lea	edx, DWORD PTR _x$[ebp]
	fstp	QWORD PTR [esp]
	push	edx
	lea	eax, DWORD PTR _v$[ebp]
	push	eax
	call	_simplex_force_metric

; 131  :     }

	fld	QWORD PTR _len$[ebp]
	add	esp, 20					; 00000014H
	jmp	SHORT $LN22@edge_force
$LN25@edge_force:

; 132  :   }
; 133  :   else len = sqrt(SDIM_dot(side,side));

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _side$[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
$LN22@edge_force:

; 134  : 
; 135  :   set_edge_length(e_id,len);

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv993[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	fst	QWORD PTR [eax+48]

; 136  : 
; 137  :   if ( !web.metric_flag ) 

	cmp	DWORD PTR _web+1676, 0
	fldz
	jne	$LN79@edge_force

; 138  :     if ( len != 0.0 ) 

	fld	ST(1)
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN79@edge_force

; 139  :      for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _web+616
	fld	QWORD PTR _density$[ebp]
	xor	eax, eax
	cmp	esi, 4
	jl	$LC72@edge_force
	lea	ecx, DWORD PTR [esi-3]
$LN73@edge_force:

; 140  :      { forces[0][i] += density*side[i]/len;

	fld	QWORD PTR _side$[ebp+eax*8]

; 141  :        forces[1][i] -= density*side[i]/len;

	add	eax, 4
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(3)
	fld	ST(0)
	fadd	QWORD PTR _forces$[ebp+eax*8-32]
	fstp	QWORD PTR _forces$[ebp+eax*8-32]
	fsubr	QWORD PTR _forces$[ebp+eax*8+16]
	fstp	QWORD PTR _forces$[ebp+eax*8+16]
	fld	QWORD PTR _side$[ebp+eax*8-24]
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(3)
	fld	ST(0)
	fadd	QWORD PTR _forces$[ebp+eax*8-24]
	fstp	QWORD PTR _forces$[ebp+eax*8-24]
	fsubr	QWORD PTR _forces$[ebp+eax*8+24]
	fstp	QWORD PTR _forces$[ebp+eax*8+24]
	fld	QWORD PTR _side$[ebp+eax*8-16]
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(3)
	fld	ST(0)
	fadd	QWORD PTR _forces$[ebp+eax*8-16]
	fstp	QWORD PTR _forces$[ebp+eax*8-16]
	fsubr	QWORD PTR _forces$[ebp+eax*8+32]
	fstp	QWORD PTR _forces$[ebp+eax*8+32]
	fld	QWORD PTR _side$[ebp+eax*8-8]
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(3)
	fld	ST(0)
	fadd	QWORD PTR _forces$[ebp+eax*8-8]
	fstp	QWORD PTR _forces$[ebp+eax*8-8]
	fsubr	QWORD PTR _forces$[ebp+eax*8+40]
	fstp	QWORD PTR _forces$[ebp+eax*8+40]
	cmp	eax, ecx
	jl	$LN73@edge_force
$LC72@edge_force:

; 139  :      for ( i = 0 ; i < SDIM ; i++ )

	cmp	eax, esi
	jge	SHORT $LN93@edge_force
$LC19@edge_force:

; 140  :      { forces[0][i] += density*side[i]/len;

	fld	QWORD PTR _side$[ebp+eax*8]
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(3)
	fld	ST(0)
	fadd	QWORD PTR _forces$[ebp+eax*8]
	fstp	QWORD PTR _forces$[ebp+eax*8]

; 141  :        forces[1][i] -= density*side[i]/len;

	fsubr	QWORD PTR _forces$[ebp+eax*8+48]
	fstp	QWORD PTR _forces$[ebp+eax*8+48]
	add	eax, edi
	cmp	eax, esi
	jl	SHORT $LC19@edge_force
$LN93@edge_force:

; 139  :      for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(2)
$LN79@edge_force:

; 142  :      }
; 143  : 
; 144  :   /* calculate gravitational forces */
; 145  :   if ( web.gravflag && !(get_eattr(e_id) & NONCONTENT) )

	cmp	DWORD PTR _web+824, 0
	fstp	ST(1)
	mov	esi, DWORD PTR _web+12
	mov	edi, DWORD PTR _dymem
	je	$LN101@edge_force
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN101@edge_force

; 146  :   { REAL *t,*h;
; 147  :     REAL gdensity = edge_grav_density(e_id);

	mov	edx, DWORD PTR _e_id$GSCopy$[ebp]
	push	edx
	call	_edge_grav_density

; 148  : 
; 149  :     if ( gdensity != 0.0 )

	fld	ST(0)
	fucomp	ST(2)
	add	esp, 4
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	$LN101@edge_force

; 150  :     { t = get_coord(tv);

	mov	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR [eax+edi+64]
	mov	eax, DWORD PTR [ebx+esi]

; 151  :       h = get_coord(hv);

	mov	ecx, DWORD PTR tv1105[ebp]
	mov	ecx, DWORD PTR [ecx+esi]

; 152  :       forces[0][0] += -gdensity*(t[1]*t[1] + t[1]*h[1] + h[1]*h[1])/6;

	fld	QWORD PTR [ecx+edx+8]
	add	eax, edx
	fmul	QWORD PTR [eax+8]
	add	ecx, edx
	fld	QWORD PTR [eax+8]
	fld	QWORD PTR [ecx+8]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	fld	QWORD PTR __real@4018000000000000
	fdiv	ST(1), ST(0)
	fld	QWORD PTR _forces$[ebp]
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _forces$[ebp]

; 153  :       forces[1][0] +=  gdensity*(t[1]*t[1] + t[1]*h[1] + h[1]*h[1])/6;

	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR [eax+8]
	fld	QWORD PTR [eax+8]
	fld	QWORD PTR [ecx+8]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR _forces$[ebp+48]
	fstp	QWORD PTR _forces$[ebp+48]

; 154  :       forces[0][1] += -gdensity*(t[0]-h[0])*(2*t[1] + h[1])/6;

	fld	QWORD PTR [eax]
	fsub	QWORD PTR [ecx]
	fmul	ST(0), ST(2)
	fld	QWORD PTR [eax+8]
	fld	QWORD PTR __real@4000000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR [ecx+8]
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(2)
	fsubr	QWORD PTR _forces$[ebp+8]
	fstp	QWORD PTR _forces$[ebp+8]

; 155  :       forces[1][1] += -gdensity*(t[0]-h[0])*(t[1] + 2*h[1])/6;

	fld	QWORD PTR [eax]
	fsub	QWORD PTR [ecx]
	fmulp	ST(3), ST(0)
	fmul	QWORD PTR [ecx+8]
	fadd	QWORD PTR [eax+8]
	fmulp	ST(2), ST(0)
	fdivp	ST(1), ST(0)
	fsubr	QWORD PTR _forces$[ebp+56]
	fstp	QWORD PTR _forces$[ebp+56]
	jmp	SHORT $LN15@edge_force
$LN101@edge_force:

; 148  : 
; 149  :     if ( gdensity != 0.0 )

	fstp	ST(0)
$LN15@edge_force:

; 156  :     }
; 157  :   }                    
; 158  : 
; 159  : 
; 160  : 
; 161  :   force[0] = get_force(tv);

	mov	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [edx+edi+784]

; 162  :   force[1] = get_force(hv);

	mov	edx, DWORD PTR tv1105[ebp]
	mov	eax, DWORD PTR [ebx+esi]
	mov	edx, DWORD PTR [edx+esi]
	add	eax, ecx
	add	edx, ecx

; 163  :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	mov	DWORD PTR _force$[ebp], eax
	mov	DWORD PTR _force$[ebp+4], edx
	je	$LN14@edge_force

; 164  :   { REAL wforce[MAXCOORD];  /* unwrapped forces */
; 165  :     REAL *t = get_coord(tv);

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR [ecx+edi+64]
	add	edx, DWORD PTR [ebx+esi]

; 166  : 
; 167  :     for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	mov	DWORD PTR _t$89146[ebp], edx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN11@edge_force
	lea	esi, DWORD PTR _forces$[ebp]
	sub	esi, eax
$LL13@edge_force:

; 168  :       force[0][j] += forces[0][j];

	fld	QWORD PTR [esi+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL13@edge_force

; 166  : 
; 167  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _dymem
$LN11@edge_force:

; 169  :     wraps[1] = get_edge_wrap(e_id);

	cmp	DWORD PTR tv1001[ebp], 0
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR [eax+edi+784]
	mov	eax, DWORD PTR tv993[ebp]
	mov	esi, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+esi]
	mov	eax, DWORD PTR [ecx+eax]
	je	SHORT $LN49@edge_force
	push	eax
	call	DWORD PTR _sym_inverse
	mov	edx, DWORD PTR _t$89146[ebp]
	add	esp, 4
$LN49@edge_force:

; 170  :     (*sym_form_pullback)(t,wforce,forces[1],wraps[1]);

	push	eax
	lea	ecx, DWORD PTR _forces$[ebp+48]
	push	ecx
	lea	eax, DWORD PTR _wforce$89145[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_form_pullback

; 171  :     for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN4@edge_force
	mov	eax, DWORD PTR _force$[ebp+4]
	lea	edx, DWORD PTR _wforce$89145[ebp]
	sub	edx, eax
$LL10@edge_force:

; 172  :       force[1][j] += wforce[j];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL10@edge_force
	pop	edi
	pop	esi
	pop	ebx

; 178  : } // end edge_force_l()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@edge_force:

; 173  :   }
; 174  :   else
; 175  :     for ( i = 0 ; i < 2 ; i++ )

	xor	esi, esi
	lea	edi, DWORD PTR _forces$[ebp]
	npad	3
$LL75@edge_force:

; 176  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN5@edge_force
	mov	eax, DWORD PTR _force$[ebp+esi*4]
	mov	ecx, edi
$LL3@edge_force:

; 177  :               force[i][j] += forces[i][j];

	fld	QWORD PTR [ecx]
	inc	edx
	fadd	QWORD PTR [eax]
	add	ecx, 8
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL3@edge_force
$LN5@edge_force:

; 173  :   }
; 174  :   else
; 175  :     for ( i = 0 ; i < 2 ; i++ )

	inc	esi
	add	edi, 48					; 00000030H
	cmp	esi, 2
	jl	SHORT $LL75@edge_force
$LN4@edge_force:

; 178  : } // end edge_force_l()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_force_l ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_general_value
EXTRN	_gauss1Dwt:DWORD
EXTRN	_gauss1D_num:DWORD
; Function compile flags: /Ogtp
;	COMDAT _edge_general_value
_TEXT	SEGMENT
_weight$89475 = -152					; size = 8
_sign$ = -144						; size = 8
_value$ = -136						; size = 8
tv695 = -128						; size = 4
_e_info$GSCopy$ = -124					; size = 4
tv800 = -120						; size = 4
tv375 = -120						; size = 4
_m$ = -116						; size = 4
tv387 = -112						; size = 4
_z$ = -108						; size = 104
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_general_value PROC				; COMDAT

; 560  : { int m,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 561  :   REAL value = 0.0;
; 562  :   REAL z[2*MAXCOORD+1];  /*  pointers to coord and tangent */
; 563  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	ecx, DWORD PTR _web+124
	fldz
	push	ebx
	fst	QWORD PTR _value$[ebp]
	mov	ebx, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [ebx]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	or	eax, ecx

; 570  :         z[SDIM+k] = sign*e_info->sides[m][0][k];

	mov	DWORD PTR _e_info$GSCopy$[ebp], ebx
	je	SHORT $LN10@edge_gener@5

; 561  :   REAL value = 0.0;
; 562  :   REAL z[2*MAXCOORD+1];  /*  pointers to coord and tangent */
; 563  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN48@edge_gener@5
$LN10@edge_gener@5:
	fld1
$LN48@edge_gener@5:

; 564  : 
; 565  :   if ( web.modeltype == LAGRANGE ) return edge_general_value_lagrange(e_info); 

	cmp	DWORD PTR _web+628, 3
	fst	QWORD PTR _sign$[ebp]
	jne	SHORT $LN7@edge_gener@5
	fstp	ST(0)
	push	ebx
	fstp	ST(0)
	call	_edge_general_value_lagrange
	add	esp, 4
	pop	ebx

; 574  :   }
; 575  :   return value;
; 576  : } // end edge_general_value()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@edge_gener@5:
	push	edi

; 566  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	edi, edi
	mov	DWORD PTR _m$[ebp], edi
	cmp	DWORD PTR _gauss1D_num, ecx
	jle	$LN31@edge_gener@5
	fstp	ST(1)
	push	esi
	jmp	SHORT $LN6@edge_gener@5
	npad	4
$LL46@edge_gener@5:
	fstp	ST(0)
	fld	QWORD PTR _sign$[ebp]
$LN6@edge_gener@5:

; 567  :   { REAL weight = gauss1Dwt[m];

	mov	edx, DWORD PTR _gauss1Dwt

; 568  :      for ( k = 0 ; k < SDIM ; k++ )

	mov	ecx, DWORD PTR _web+616
	fld	QWORD PTR [edx+edi*8]
	xor	eax, eax
	fstp	QWORD PTR _weight$89475[ebp]
	cmp	ecx, 4
	jl	$LC17@edge_gener@5

; 566  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	edx, DWORD PTR [ebx+1268]
	lea	esi, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR [ebx+1276]
	lea	edi, DWORD PTR [edx+edi*4]

; 567  :   { REAL weight = gauss1Dwt[m];

	lea	edx, DWORD PTR _z$[ebp+ecx*8+8]

; 570  :         z[SDIM+k] = sign*e_info->sides[m][0][k];

	lea	ebx, DWORD PTR _z$[ebp+8]
	mov	ecx, 16					; 00000010H
	sub	ecx, ebx
	mov	DWORD PTR tv695[ebp], ecx
	mov	ecx, 24					; 00000018H
	sub	ecx, ebx
	mov	DWORD PTR tv387[ebp], edi
	mov	DWORD PTR tv800[ebp], ecx
$LN20@edge_gener@5:

; 569  :      { z[k] = e_info->gauss_pt[m][k]; 

	mov	ebx, DWORD PTR [esi]
	fld	QWORD PTR [ebx+eax*8]

; 570  :         z[SDIM+k] = sign*e_info->sides[m][0][k];

	lea	ecx, DWORD PTR _z$[ebp+eax*8+8]
	fstp	QWORD PTR [ecx-8]
	mov	ebx, DWORD PTR [edi]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+eax*8]
	add	eax, 4
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	fstp	QWORD PTR [edx-40]
	mov	ebx, DWORD PTR [esi]
	fld	QWORD PTR [ebx+eax*8-24]
	fstp	QWORD PTR [ecx]
	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+eax*8-24]
	mov	edi, DWORD PTR tv695[ebp]
	fmul	ST(0), ST(1)
	add	edi, ecx
	fstp	QWORD PTR [edx-32]
	mov	ebx, DWORD PTR [esi]
	fld	QWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR tv387[ebp]
	fstp	QWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR tv800[ebp]
	fmul	ST(0), ST(1)
	add	ebx, ecx
	fstp	QWORD PTR [edx-24]
	mov	edi, DWORD PTR [esi]
	fld	QWORD PTR [ebx+edi]
	mov	edi, DWORD PTR tv387[ebp]
	fstp	QWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _web+616
	fmul	ST(0), ST(1)
	lea	ebx, DWORD PTR [ecx-3]
	fstp	QWORD PTR [edx-16]
	cmp	eax, ebx
	jl	SHORT $LN20@edge_gener@5
	mov	edi, DWORD PTR _m$[ebp]
	mov	ebx, DWORD PTR _e_info$GSCopy$[ebp]
$LC17@edge_gener@5:

; 568  :      for ( k = 0 ; k < SDIM ; k++ )

	cmp	eax, ecx
	jge	SHORT $LN44@edge_gener@5

; 566  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	edx, DWORD PTR [ebx+1268]
	lea	edx, DWORD PTR [edx+edi*4]
	mov	DWORD PTR tv375[ebp], edx
	mov	edx, DWORD PTR [ebx+1276]
	lea	edx, DWORD PTR [edx+edi*4]
	mov	DWORD PTR tv387[ebp], edx

; 568  :      for ( k = 0 ; k < SDIM ; k++ )

	lea	edx, DWORD PTR [ecx+eax]
	lea	edx, DWORD PTR _z$[ebp+edx*8]
$LN21@edge_gener@5:

; 569  :      { z[k] = e_info->gauss_pt[m][k]; 

	mov	esi, DWORD PTR tv375[ebp]
	mov	esi, DWORD PTR [esi]
	fld	QWORD PTR [esi+eax*8]

; 570  :         z[SDIM+k] = sign*e_info->sides[m][0][k];

	mov	esi, DWORD PTR tv387[ebp]
	fstp	QWORD PTR _z$[ebp+eax*8]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi]
	fld	QWORD PTR [esi+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	add	edx, 8
	fstp	QWORD PTR [edx-8]
	cmp	eax, ecx
	jl	SHORT $LN21@edge_gener@5
$LN44@edge_gener@5:

; 571  :      }
; 572  :      z[2*SDIM] = m; /* kludge for attr interp */
; 573  :      value += weight*eval(METH_INSTANCE(e_info->method)->expr[0],z,e_info->id,NULL);

	mov	eax, DWORD PTR [ebx]
	fstp	ST(0)
	fild	DWORD PTR _m$[ebp]
	push	0
	push	eax
	mov	eax, DWORD PTR [ebx+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	add	ecx, ecx
	fstp	QWORD PTR _z$[ebp+ecx*8]
	mov	eax, DWORD PTR [eax+edx+232]
	lea	ecx, DWORD PTR _z$[ebp]
	push	ecx
	push	eax
	call	_eval
	fmul	QWORD PTR _weight$89475[ebp]
	inc	edi
	add	esp, 16					; 00000010H
	fadd	QWORD PTR _value$[ebp]
	mov	DWORD PTR _m$[ebp], edi
	fst	QWORD PTR _value$[ebp]
	cmp	edi, DWORD PTR _gauss1D_num
	jl	$LL46@edge_gener@5
	pop	esi
	pop	edi
	pop	ebx

; 574  :   }
; 575  :   return value;
; 576  : } // end edge_general_value()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@edge_gener@5:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	pop	edi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_general_value ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_general_grad
EXTRN	_gauss1poly:DWORD
EXTRN	_gauss1polyd:DWORD
EXTRN	_edge_ctrl:DWORD
; Function compile flags: /Ogtp
;	COMDAT _edge_general_grad
_TEXT	SEGMENT
_val$ = -256						; size = 8
_weight$89497 = -248					; size = 8
_value$ = -240						; size = 8
_sign$ = -232						; size = 8
_e_info$GSCopy$ = -224					; size = 4
tv779 = -220						; size = 4
tv507 = -220						; size = 4
_m$ = -216						; size = 4
tv1171 = -212						; size = 4
tv788 = -212						; size = 4
tv407 = -212						; size = 4
tv1285 = -208						; size = 4
tv419 = -208						; size = 4
_derivs$ = -204						; size = 96
_z$ = -108						; size = 104
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_general_grad PROC					; COMDAT

; 586  : { int m,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 587  :   REAL value = 0.0;
; 588  :   REAL val;
; 589  :   REAL derivs[2*MAXCOORD];
; 590  :   REAL z[2*MAXCOORD+1];  /*  pointers to coord and tangent */
; 591  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	ecx, DWORD PTR _web+124
	fldz
	push	edi
	fst	QWORD PTR _value$[ebp]
	mov	edi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [edi]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	or	eax, ecx

; 598  :         z[SDIM+k] = sign*e_info->sides[m][0][k];

	mov	DWORD PTR _e_info$GSCopy$[ebp], edi
	je	SHORT $LN16@edge_gener@6

; 587  :   REAL value = 0.0;
; 588  :   REAL val;
; 589  :   REAL derivs[2*MAXCOORD];
; 590  :   REAL z[2*MAXCOORD+1];  /*  pointers to coord and tangent */
; 591  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN72@edge_gener@6
$LN16@edge_gener@6:
	fld1
$LN72@edge_gener@6:

; 592  : 
; 593  :   if ( web.modeltype == LAGRANGE ) return edge_general_grad_lagrange(e_info); 

	cmp	DWORD PTR _web+628, 3
	fst	QWORD PTR _sign$[ebp]
	jne	SHORT $LN13@edge_gener@6
	fstp	ST(0)
	push	edi
	fstp	ST(0)
	call	_edge_general_grad_lagrange
	add	esp, 4
	pop	edi

; 607  :   }
; 608  : 
; 609  :   return value;
; 610  : } // end edge_general_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@edge_gener@6:
	push	ebx

; 594  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	ebx, ebx
	mov	DWORD PTR _m$[ebp], ebx
	cmp	DWORD PTR _gauss1D_num, ecx
	jle	$LN42@edge_gener@6
	mov	ecx, DWORD PTR _web+616
	fstp	ST(1)
	push	esi
	jmp	SHORT $LN12@edge_gener@6
	npad	8
$LL70@edge_gener@6:
	fstp	ST(0)
	fld	QWORD PTR _sign$[ebp]
$LN12@edge_gener@6:

; 595  :   { REAL weight = gauss1Dwt[m];

	mov	edx, DWORD PTR _gauss1Dwt
	fld	QWORD PTR [edx+ebx*8]

; 596  :      for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	fstp	QWORD PTR _weight$89497[ebp]
	cmp	ecx, 4
	jl	$LC27@edge_gener@6

; 594  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	edx, DWORD PTR [edi+1268]
	lea	esi, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [edi+1276]
	lea	edi, DWORD PTR [edx+ebx*4]

; 595  :   { REAL weight = gauss1Dwt[m];

	lea	edx, DWORD PTR _z$[ebp+ecx*8+8]

; 598  :         z[SDIM+k] = sign*e_info->sides[m][0][k];

	lea	ebx, DWORD PTR _z$[ebp+8]
	mov	ecx, 16					; 00000010H
	sub	ecx, ebx
	mov	DWORD PTR tv779[ebp], ecx
	mov	ecx, 24					; 00000018H
	sub	ecx, ebx
	mov	DWORD PTR tv419[ebp], edi
	mov	DWORD PTR tv788[ebp], ecx
$LN31@edge_gener@6:

; 597  :      { z[k] = e_info->gauss_pt[m][k]; 

	mov	ebx, DWORD PTR [esi]
	fld	QWORD PTR [ebx+eax*8]

; 598  :         z[SDIM+k] = sign*e_info->sides[m][0][k];

	lea	ecx, DWORD PTR _z$[ebp+eax*8+8]
	fstp	QWORD PTR [ecx-8]
	mov	ebx, DWORD PTR [edi]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+eax*8]
	add	eax, 4
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	fstp	QWORD PTR [edx-40]
	mov	ebx, DWORD PTR [esi]
	fld	QWORD PTR [ebx+eax*8-24]
	fstp	QWORD PTR [ecx]
	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+eax*8-24]
	mov	edi, DWORD PTR tv779[ebp]
	fmul	ST(0), ST(1)
	add	edi, ecx
	fstp	QWORD PTR [edx-32]
	mov	ebx, DWORD PTR [esi]
	fld	QWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR tv419[ebp]
	fstp	QWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR tv788[ebp]
	fmul	ST(0), ST(1)
	add	ebx, ecx
	fstp	QWORD PTR [edx-24]
	mov	edi, DWORD PTR [esi]
	fld	QWORD PTR [ebx+edi]
	mov	edi, DWORD PTR tv419[ebp]
	fstp	QWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _web+616
	fmul	ST(0), ST(1)
	lea	ebx, DWORD PTR [ecx-3]
	fstp	QWORD PTR [edx-16]
	cmp	eax, ebx
	jl	$LN31@edge_gener@6
	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ebx, DWORD PTR _m$[ebp]
$LC27@edge_gener@6:

; 596  :      for ( k = 0 ; k < SDIM ; k++ )

	cmp	eax, ecx
	jge	SHORT $LN55@edge_gener@6

; 594  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	edx, DWORD PTR [edi+1268]
	lea	edx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv407[ebp], edx
	mov	edx, DWORD PTR [edi+1276]
	lea	edx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv419[ebp], edx

; 596  :      for ( k = 0 ; k < SDIM ; k++ )

	lea	edx, DWORD PTR [ecx+eax]
	lea	edx, DWORD PTR _z$[ebp+edx*8]
$LN32@edge_gener@6:

; 597  :      { z[k] = e_info->gauss_pt[m][k]; 

	mov	esi, DWORD PTR tv407[ebp]
	mov	esi, DWORD PTR [esi]
	fld	QWORD PTR [esi+eax*8]

; 598  :         z[SDIM+k] = sign*e_info->sides[m][0][k];

	mov	esi, DWORD PTR tv419[ebp]
	fstp	QWORD PTR _z$[ebp+eax*8]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi]
	fld	QWORD PTR [esi+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	add	edx, 8
	fstp	QWORD PTR [edx-8]
	cmp	eax, ecx
	jl	SHORT $LN32@edge_gener@6
$LN55@edge_gener@6:

; 599  :      }
; 600  :      z[2*SDIM] = m; /* kludge for attr interp */
; 601  :      eval_all(METH_INSTANCE(e_info->method)->expr[0],z,2*SDIM,&val,derivs,e_info->id);

	mov	edx, DWORD PTR [edi]
	fstp	ST(0)
	fild	DWORD PTR _m$[ebp]
	push	edx
	mov	eax, ecx
	add	eax, eax
	fstp	QWORD PTR _z$[ebp+eax*8]
	lea	eax, DWORD PTR _derivs$[ebp]
	push	eax
	lea	edx, DWORD PTR _val$[ebp]
	push	edx
	lea	eax, DWORD PTR [ecx+ecx]
	push	eax
	mov	eax, DWORD PTR [edi+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	mov	eax, DWORD PTR [eax+edx+232]
	lea	ecx, DWORD PTR _z$[ebp]
	push	ecx
	push	eax
	call	_eval_all

; 602  :      value += weight*val;
; 603  :      for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	ecx, DWORD PTR _web+616
	fld	QWORD PTR _val$[ebp]
	xor	esi, esi
	fld	QWORD PTR _weight$89497[ebp]
	add	esp, 24					; 00000018H
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR _value$[ebp]
	fst	QWORD PTR _value$[ebp]
	cmp	DWORD PTR _edge_ctrl, esi
	jle	$LN57@edge_gener@6
	mov	eax, DWORD PTR _gauss1polyd
	sub	eax, DWORD PTR _gauss1poly
	mov	DWORD PTR tv1171[ebp], eax
$LN33@edge_gener@6:

; 604  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN5@edge_gener@6

; 594  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	edx, DWORD PTR _gauss1poly
	mov	ebx, DWORD PTR tv1171[ebp]

; 602  :      value += weight*val;
; 603  :      for ( k = 0 ; k < edge_ctrl ; k++ )

	lea	edx, DWORD PTR [edx+esi*4]
	mov	ebx, DWORD PTR [edx+ebx]
	mov	DWORD PTR tv507[ebp], edx
	mov	edx, DWORD PTR _m$[ebp]
	lea	ebx, DWORD PTR [ebx+edx*8]
	mov	DWORD PTR tv1285[ebp], ebx
	mov	ebx, DWORD PTR tv507[ebp]
	mov	ebx, DWORD PTR [ebx]
	lea	ebx, DWORD PTR [ebx+edx*8]
$LN3@edge_gener@6:

; 604  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR [edi+1336]
	mov	edx, DWORD PTR [edx+esi*4]

; 605  :          e_info->grad[k][j] += weight*(gauss1poly[k][m]*derivs[j]
; 606  :                                         + gauss1polyd[k][m]*derivs[j+SDIM]);

	add	ecx, eax
	fld	QWORD PTR _derivs$[ebp+ecx*8]
	mov	ecx, DWORD PTR tv1285[ebp]
	fmul	QWORD PTR [ecx]
	lea	edx, DWORD PTR [edx+eax*8]
	fld	QWORD PTR _derivs$[ebp+eax*8]
	inc	eax
	fmul	QWORD PTR [ebx]
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN3@edge_gener@6

; 604  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _m$[ebp]
$LN5@edge_gener@6:

; 602  :      value += weight*val;
; 603  :      for ( k = 0 ; k < edge_ctrl ; k++ )

	inc	esi
	cmp	esi, DWORD PTR _edge_ctrl
	jl	SHORT $LN33@edge_gener@6
$LN57@edge_gener@6:

; 594  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	ebx

; 602  :      value += weight*val;
; 603  :      for ( k = 0 ; k < edge_ctrl ; k++ )

	fstp	ST(1)
	mov	DWORD PTR _m$[ebp], ebx
	cmp	ebx, DWORD PTR _gauss1D_num
	jl	$LL70@edge_gener@6
	pop	esi
	pop	ebx
	pop	edi

; 607  :   }
; 608  : 
; 609  :   return value;
; 610  : } // end edge_general_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@edge_gener@6:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	pop	ebx
	xor	ecx, ebp
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_general_grad ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_general_hess
; Function compile flags: /Ogtp
;	COMDAT _edge_general_hess
_TEXT	SEGMENT
_secondqXvS$ = -1476					; size = 48
_val$ = -1428						; size = 8
_sign$ = -1420						; size = 8
_value$ = -1412						; size = 8
_weight$89530 = -1404					; size = 8
tv727 = -1400						; size = 4
tv1517 = -1396						; size = 4
tv1748 = -1392						; size = 4
tv1543 = -1388						; size = 4
_second$ = -1384					; size = 4
_e_info$GSCopy$ = -1380					; size = 4
_m$ = -1376						; size = 4
tv1292 = -1372						; size = 4
tv1028 = -1372						; size = 4
tv736 = -1372						; size = 4
tv1037 = -1368						; size = 4
tv705 = -1368						; size = 4
tv670 = -1368						; size = 4
tv655 = -1368						; size = 4
tv567 = -1364						; size = 4
_k$ = -1364						; size = 4
tv579 = -1360						; size = 4
_kk$ = -1360						; size = 4
_secondxJ$ = -1356					; size = 1152
_derivs$ = -204						; size = 96
_z$ = -108						; size = 104
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_general_hess PROC					; COMDAT

; 620  : { int m,j,jj,k,kk;

	push	ebp
	mov	ebp, esp
	sub	esp, 1476				; 000005c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 621  :   REAL value = 0.0;

	fldz
	push	esi
	mov	esi, DWORD PTR _e_info$[ebp]
	fstp	QWORD PTR _value$[ebp]

; 622  :   REAL val;
; 623  :   REAL derivs[2*MAXCOORD];
; 624  :   REAL z[2*MAXCOORD+1];  /*  pointers to coord and tangent */
; 625  :   MAT2D(second,2*MAXCOORD,2*MAXCOORD); /* second derivatives */

	push	12					; 0000000cH
	push	12					; 0000000cH
	lea	eax, DWORD PTR _secondxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _secondqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _e_info$GSCopy$[ebp], esi
	call	_mat2d_setup

; 626  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR _second$[ebp], eax
	mov	eax, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	add	esp, 16					; 00000010H
	or	eax, ecx
	je	SHORT $LN28@edge_gener@7
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN110@edge_gener@7
$LN28@edge_gener@7:
	fld1
$LN110@edge_gener@7:

; 627  : 
; 628  :   if ( web.modeltype == LAGRANGE ) return edge_general_hess_lagrange(e_info); 

	cmp	DWORD PTR _web+628, 3
	fst	QWORD PTR _sign$[ebp]
	jne	SHORT $LN25@edge_gener@7
	push	esi
	fstp	ST(0)
	call	_edge_general_hess_lagrange
	add	esp, 4
	pop	esi

; 653  : } // end edge_general_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@edge_gener@7:
	push	ebx

; 629  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	ebx, ebx
	mov	DWORD PTR _m$[ebp], ebx
	cmp	DWORD PTR _gauss1D_num, ecx
	jle	$LN63@edge_gener@7
	mov	ecx, DWORD PTR _web+616
	push	edi
	jmp	SHORT $LN24@edge_gener@7
$LL50@edge_gener@7:
	fld	QWORD PTR _sign$[ebp]
	mov	esi, DWORD PTR _e_info$GSCopy$[ebp]
$LN24@edge_gener@7:

; 630  :   { REAL weight = gauss1Dwt[m];

	mov	edx, DWORD PTR _gauss1Dwt
	fld	QWORD PTR [edx+ebx*8]

; 631  :      for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	fstp	QWORD PTR _weight$89530[ebp]
	cmp	ecx, 4
	jl	$LC47@edge_gener@7

; 629  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	edx, DWORD PTR [esi+1268]
	lea	edi, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [esi+1276]
	lea	edx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv579[ebp], edx

; 633  :        z[SDIM+k] = sign*e_info->sides[m][0][k];

	lea	ebx, DWORD PTR _z$[ebp+8]
	mov	edx, 16					; 00000010H
	sub	edx, ebx
	mov	DWORD PTR tv1028[ebp], edx
	mov	edx, 24					; 00000018H
	sub	edx, ebx
	mov	DWORD PTR tv567[ebp], edi
	lea	esi, DWORD PTR _z$[ebp+ecx*8+8]
	mov	DWORD PTR tv1037[ebp], edx
	jmp	SHORT $LN48@edge_gener@7
$LN53@edge_gener@7:
	mov	edi, DWORD PTR tv567[ebp]

; 631  :      for ( k = 0 ; k < SDIM ; k++ )

$LN48@edge_gener@7:

; 632  :      { z[k] = e_info->gauss_pt[m][k]; 

	mov	ebx, DWORD PTR [edi]
	fld	QWORD PTR [ebx+eax*8]

; 633  :        z[SDIM+k] = sign*e_info->sides[m][0][k];

	mov	ebx, DWORD PTR tv579[ebp]
	fstp	QWORD PTR _z$[ebp+eax*8]
	mov	ebx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+eax*8]
	lea	edx, DWORD PTR _z$[ebp+eax*8+8]
	fmul	ST(0), ST(1)
	add	eax, 4
	add	esi, 32					; 00000020H
	fstp	QWORD PTR [esi-40]
	mov	ebx, DWORD PTR [edi]
	fld	QWORD PTR [ebx+eax*8-24]
	mov	ebx, DWORD PTR tv579[ebp]
	fstp	QWORD PTR [edx]
	mov	ebx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+eax*8-24]
	mov	ebx, DWORD PTR tv1028[ebp]
	fmul	ST(0), ST(1)
	add	ebx, edx
	fstp	QWORD PTR [esi-32]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [ebx+edi]
	mov	edi, DWORD PTR tv579[ebp]
	fstp	QWORD PTR [edx+8]
	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+ebx]
	mov	edi, DWORD PTR tv1037[ebp]
	mov	ebx, DWORD PTR tv567[ebp]
	fmul	ST(0), ST(1)
	add	edi, edx
	fstp	QWORD PTR [esi-24]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [edi+ebx]
	fstp	QWORD PTR [edx+16]
	mov	edx, DWORD PTR tv579[ebp]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+edi]
	lea	edx, DWORD PTR [ecx-3]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi-16]
	cmp	eax, edx
	jl	$LN53@edge_gener@7
	mov	ebx, DWORD PTR _m$[ebp]
	mov	esi, DWORD PTR _e_info$GSCopy$[ebp]
$LC47@edge_gener@7:

; 631  :      for ( k = 0 ; k < SDIM ; k++ )

	cmp	eax, ecx
	jge	SHORT $LN77@edge_gener@7

; 629  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	edx, DWORD PTR [esi+1268]
	lea	edx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv567[ebp], edx
	mov	edx, DWORD PTR [esi+1276]
	lea	edx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv579[ebp], edx

; 631  :      for ( k = 0 ; k < SDIM ; k++ )

	lea	edx, DWORD PTR [ecx+eax]
	lea	edx, DWORD PTR _z$[ebp+edx*8]
$LN56@edge_gener@7:

; 632  :      { z[k] = e_info->gauss_pt[m][k]; 

	mov	edi, DWORD PTR tv567[ebp]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+eax*8]

; 633  :        z[SDIM+k] = sign*e_info->sides[m][0][k];

	mov	edi, DWORD PTR tv579[ebp]
	fstp	QWORD PTR _z$[ebp+eax*8]
	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	add	edx, 8
	fstp	QWORD PTR [edx-8]
	cmp	eax, ecx
	jl	SHORT $LN56@edge_gener@7
$LN77@edge_gener@7:

; 634  :      }
; 635  :      z[2*SDIM] = m; /* kludge for attr interp */
; 636  :      eval_second(METH_INSTANCE(e_info->method)->expr[0],z,2*SDIM,&val,derivs,second,e_info->id);

	mov	edx, DWORD PTR [esi]
	fstp	ST(0)
	fild	DWORD PTR _m$[ebp]
	push	edx
	mov	eax, ecx
	add	eax, eax
	fstp	QWORD PTR _z$[ebp+eax*8]
	mov	eax, DWORD PTR _second$[ebp]
	push	eax
	lea	edx, DWORD PTR _derivs$[ebp]
	push	edx
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	eax, DWORD PTR [esi+8]
	add	ecx, ecx
	push	ecx
	mov	ecx, DWORD PTR _meth_inst_list
	lea	edx, DWORD PTR _z$[ebp]
	push	edx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	mov	edx, DWORD PTR [eax+ecx+232]
	push	edx
	call	_eval_second

; 637  :      value += weight*val;
; 638  :      for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	edi, DWORD PTR _edge_ctrl
	fld	QWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _web+616
	fld	QWORD PTR _weight$89530[ebp]
	add	esp, 28					; 0000001cH
	fmul	ST(1), ST(0)
	xor	esi, esi
	fxch	ST(1)
	fadd	QWORD PTR _value$[ebp]
	fstp	QWORD PTR _value$[ebp]
	test	edi, edi
	jle	$LN16@edge_gener@7
	mov	eax, DWORD PTR _gauss1polyd
	sub	eax, DWORD PTR _gauss1poly
	mov	DWORD PTR tv1292[ebp], eax
$LN57@edge_gener@7:

; 639  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN17@edge_gener@7

; 629  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	edx, DWORD PTR _gauss1poly
	mov	edi, DWORD PTR tv1292[ebp]

; 637  :      value += weight*val;
; 638  :      for ( k = 0 ; k < edge_ctrl ; k++ )

	lea	edx, DWORD PTR [edx+esi*4]
	mov	edi, DWORD PTR [edx+edi]
	mov	edx, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+ebx*8]
	lea	edi, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR tv670[ebp], edx
$LN15@edge_gener@7:

; 639  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	edx, DWORD PTR [edx+1336]
	mov	edx, DWORD PTR [edx+esi*4]

; 640  :          e_info->grad[k][j] += weight*(gauss1poly[k][m]*derivs[j]
; 641  :                                         + gauss1polyd[k][m]*derivs[j+SDIM]);

	add	ecx, eax
	fld	QWORD PTR _derivs$[ebp+ecx*8]
	mov	ecx, DWORD PTR tv670[ebp]
	fmul	QWORD PTR [edi]
	lea	edx, DWORD PTR [edx+eax*8]
	fld	QWORD PTR _derivs$[ebp+eax*8]
	inc	eax
	fmul	QWORD PTR [ecx]
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN15@edge_gener@7

; 639  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _edge_ctrl
$LN17@edge_gener@7:

; 637  :      value += weight*val;
; 638  :      for ( k = 0 ; k < edge_ctrl ; k++ )

	inc	esi
	cmp	esi, edi
	jl	SHORT $LN57@edge_gener@7
$LN16@edge_gener@7:

; 642  :      for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	DWORD PTR _k$[ebp], 0
	test	edi, edi
	jle	$LN109@edge_gener@7
	mov	edx, DWORD PTR _gauss1polyd
$LN12@edge_gener@7:

; 643  :       for ( kk = 0 ; kk < edge_ctrl ; kk++ )

	xor	esi, esi
	mov	DWORD PTR _kk$[ebp], esi
	test	edi, edi
	jle	$LN11@edge_gener@7
	mov	eax, DWORD PTR _gauss1poly
	sub	eax, edx
	mov	DWORD PTR tv1517[ebp], eax
$LN54@edge_gener@7:

; 644  :         for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	test	ecx, ecx
	jle	$LN8@edge_gener@7
$LN6@edge_gener@7:

; 645  :          for ( jj = 0 ; jj < SDIM ; jj++ )

	xor	eax, eax
	test	ecx, ecx
	jle	$LN5@edge_gener@7

; 629  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	lea	edx, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR tv1517[ebp]
	mov	esi, DWORD PTR [edx+esi]
	mov	edx, DWORD PTR [edx]
	lea	esi, DWORD PTR [esi+ebx*8]

; 642  :      for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	ebx, DWORD PTR _k$[ebp]
	mov	DWORD PTR tv1543[ebp], esi
	mov	esi, DWORD PTR _gauss1polyd
	lea	esi, DWORD PTR [esi+ebx*4]
	mov	ebx, DWORD PTR tv1517[ebp]
	mov	ebx, DWORD PTR [esi+ebx]
	mov	DWORD PTR tv655[ebp], esi
	mov	esi, DWORD PTR _m$[ebp]
	lea	edx, DWORD PTR [edx+esi*8]
	lea	ebx, DWORD PTR [ebx+esi*8]
	mov	DWORD PTR tv736[ebp], edx
	mov	edx, DWORD PTR tv655[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR tv1748[ebp], ebx

; 645  :          for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	ebx, DWORD PTR _second$[ebp]
	mov	ebx, DWORD PTR [ebx+edi*4]
	lea	edx, DWORD PTR [edx+esi*8]
	mov	DWORD PTR tv727[ebp], ebx
	mov	DWORD PTR tv705[ebp], edx
$LN52@edge_gener@7:

; 646  :             e_info->hess[k][kk][j][jj] += weight*
; 647  :              (gauss1poly[k][m]*gauss1poly[kk][m]*second[j][jj] +
; 648  :               gauss1polyd[k][m]*gauss1poly[kk][m]*second[j+SDIM][jj] +
; 649  :               gauss1poly[k][m]*gauss1polyd[kk][m]*second[j][jj+SDIM] +
; 650  :               gauss1polyd[k][m]*gauss1polyd[kk][m]*second[j+SDIM][jj+SDIM]);

	mov	esi, DWORD PTR _second$[ebp]
	mov	ebx, DWORD PTR _k$[ebp]
	lea	edx, DWORD PTR [ecx+edi]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR _e_info$GSCopy$[ebp]
	mov	esi, DWORD PTR [esi+1340]
	mov	esi, DWORD PTR [esi+ebx*4]
	mov	ebx, DWORD PTR _kk$[ebp]
	mov	esi, DWORD PTR [esi+ebx*4]
	mov	ebx, DWORD PTR tv1543[ebp]
	fld	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv1748[ebp]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv727[ebp]
	add	ecx, eax
	mov	esi, DWORD PTR [esi+edi*4]
	fmul	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR tv1543[ebp]
	fld	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv705[ebp]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv736[ebp]
	add	ecx, ecx
	add	ecx, ecx
	fmul	QWORD PTR [edx+eax*8]
	add	ecx, ecx
	lea	esi, DWORD PTR [esi+eax*8]
	inc	eax
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv1748[ebp]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv727[ebp]
	fmul	QWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR tv705[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv736[ebp]
	fmul	QWORD PTR [ebx]
	fmul	QWORD PTR [ecx+edx]
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	$LN52@edge_gener@7

; 645  :          for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	edx, DWORD PTR _gauss1polyd
	mov	ebx, DWORD PTR _m$[ebp]
	mov	esi, DWORD PTR _kk$[ebp]
$LN5@edge_gener@7:

; 644  :         for ( j = 0 ; j < SDIM ; j++ )

	inc	edi
	cmp	edi, ecx
	jl	$LN6@edge_gener@7
$LN8@edge_gener@7:

; 643  :       for ( kk = 0 ; kk < edge_ctrl ; kk++ )

	inc	esi
	mov	DWORD PTR _kk$[ebp], esi
	cmp	esi, DWORD PTR _edge_ctrl
	jl	$LN54@edge_gener@7
	mov	edi, DWORD PTR _edge_ctrl
$LN11@edge_gener@7:

; 642  :      for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, edi
	jl	$LN12@edge_gener@7
$LN109@edge_gener@7:

; 629  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	ebx

; 643  :       for ( kk = 0 ; kk < edge_ctrl ; kk++ )

	fstp	ST(0)
	mov	DWORD PTR _m$[ebp], ebx
	cmp	ebx, DWORD PTR _gauss1D_num
	jl	$LL50@edge_gener@7

; 651  :   }
; 652  :   return value;

	fld	QWORD PTR _value$[ebp]
	pop	edi
	pop	ebx
	pop	esi

; 653  : } // end edge_general_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@edge_gener@7:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	fld	QWORD PTR _value$[ebp]
	pop	ebx
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_general_hess ENDP
_TEXT	ENDS
END
