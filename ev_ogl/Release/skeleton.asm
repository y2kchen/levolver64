; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\skeleton.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05HIFJDKLD@array?$AA@			; `string'
PUBLIC	??_C@_0P@IMLIOJAD@procedure_type?$AA@		; `string'
PUBLIC	??_C@_0BF@NPKOHFOJ@method_instance_type?$AA@	; `string'
PUBLIC	??_C@_0O@LKOEHKMD@quantity_type?$AA@		; `string'
PUBLIC	??_C@_0BA@GMGEGKHC@constraint_type?$AA@		; `string'
PUBLIC	??_C@_0O@HLGIFPHM@boundary_type?$AA@		; `string'
PUBLIC	??_C@_0L@BBOBOLIJ@element_id?$AA@		; `string'
PUBLIC	??_C@_0P@IKCOLOFK@facetedge_type?$AA@		; `string'
PUBLIC	??_C@_09MMCKNCIB@body_type?$AA@			; `string'
PUBLIC	??_C@_0L@FMDIHOCJ@facet_type?$AA@		; `string'
PUBLIC	??_C@_09ICFCKGHM@edge_type?$AA@			; `string'
PUBLIC	??_C@_0M@NNGHDEJI@vertex_type?$AA@		; `string'
PUBLIC	??_C@_07PFMCDPMA@pointer?$AA@			; `string'
PUBLIC	??_C@_06ICGJLFIM@string?$AA@			; `string'
PUBLIC	??_C@_09PBEIAMCH@short_int?$AA@			; `string'
PUBLIC	??_C@_04ENMBGAPA@char?$AA@			; `string'
PUBLIC	??_C@_08JBGFJJOH@long_int?$AA@			; `string'
PUBLIC	??_C@_04EHNLIFAM@uint?$AA@			; `string'
PUBLIC	??_C@_0L@PGDACLAM@ushort_int?$AA@		; `string'
PUBLIC	??_C@_05GBMOKKDM@uchar?$AA@			; `string'
PUBLIC	??_C@_09IEIGKLOD@ulong_int?$AA@			; `string'
PUBLIC	??_C@_07LKHFMGFB@integer?$AA@			; `string'
PUBLIC	??_C@_04DGGKDJMA@real?$AA@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	_datatype_size
PUBLIC	_datatype_name
PUBLIC	_dip
_DATA	SEGMENT
COMM	_nullcon:DWORD:02H
_DATA	ENDS
;	COMDAT ??_C@_05HIFJDKLD@array?$AA@
CONST	SEGMENT
??_C@_05HIFJDKLD@array?$AA@ DB 'array', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IMLIOJAD@procedure_type?$AA@
CONST	SEGMENT
??_C@_0P@IMLIOJAD@procedure_type?$AA@ DB 'procedure_type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NPKOHFOJ@method_instance_type?$AA@
CONST	SEGMENT
??_C@_0BF@NPKOHFOJ@method_instance_type?$AA@ DB 'method_instance_type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LKOEHKMD@quantity_type?$AA@
CONST	SEGMENT
??_C@_0O@LKOEHKMD@quantity_type?$AA@ DB 'quantity_type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMGEGKHC@constraint_type?$AA@
CONST	SEGMENT
??_C@_0BA@GMGEGKHC@constraint_type?$AA@ DB 'constraint_type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HLGIFPHM@boundary_type?$AA@
CONST	SEGMENT
??_C@_0O@HLGIFPHM@boundary_type?$AA@ DB 'boundary_type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BBOBOLIJ@element_id?$AA@
CONST	SEGMENT
??_C@_0L@BBOBOLIJ@element_id?$AA@ DB 'element_id', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IKCOLOFK@facetedge_type?$AA@
CONST	SEGMENT
??_C@_0P@IKCOLOFK@facetedge_type?$AA@ DB 'facetedge_type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MMCKNCIB@body_type?$AA@
CONST	SEGMENT
??_C@_09MMCKNCIB@body_type?$AA@ DB 'body_type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FMDIHOCJ@facet_type?$AA@
CONST	SEGMENT
??_C@_0L@FMDIHOCJ@facet_type?$AA@ DB 'facet_type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ICFCKGHM@edge_type?$AA@
CONST	SEGMENT
??_C@_09ICFCKGHM@edge_type?$AA@ DB 'edge_type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NNGHDEJI@vertex_type?$AA@
CONST	SEGMENT
??_C@_0M@NNGHDEJI@vertex_type?$AA@ DB 'vertex_type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFMCDPMA@pointer?$AA@
CONST	SEGMENT
??_C@_07PFMCDPMA@pointer?$AA@ DB 'pointer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string?$AA@
CONST	SEGMENT
??_C@_06ICGJLFIM@string?$AA@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PBEIAMCH@short_int?$AA@
CONST	SEGMENT
??_C@_09PBEIAMCH@short_int?$AA@ DB 'short_int', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04ENMBGAPA@char?$AA@
CONST	SEGMENT
??_C@_04ENMBGAPA@char?$AA@ DB 'char', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JBGFJJOH@long_int?$AA@
CONST	SEGMENT
??_C@_08JBGFJJOH@long_int?$AA@ DB 'long_int', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EHNLIFAM@uint?$AA@
CONST	SEGMENT
??_C@_04EHNLIFAM@uint?$AA@ DB 'uint', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PGDACLAM@ushort_int?$AA@
CONST	SEGMENT
??_C@_0L@PGDACLAM@ushort_int?$AA@ DB 'ushort_int', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GBMOKKDM@uchar?$AA@
CONST	SEGMENT
??_C@_05GBMOKKDM@uchar?$AA@ DB 'uchar', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IEIGKLOD@ulong_int?$AA@
CONST	SEGMENT
??_C@_09IEIGKLOD@ulong_int?$AA@ DB 'ulong_int', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LKHFMGFB@integer?$AA@
CONST	SEGMENT
??_C@_07LKHFMGFB@integer?$AA@ DB 'integer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DGGKDJMA@real?$AA@
CONST	SEGMENT
??_C@_04DGGKDJMA@real?$AA@ DB 'real', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_datatype_size DD 00H
	DD	08H
	DD	04H
	DD	04H
	DD	01H
	DD	02H
	DD	04H
	DD	04H
	DD	01H
	DD	02H
	DD	00H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	ORG $+4
_datatype_name DD FLAT:??_C@_01CLKCMJKC@?5?$AA@
	DD	FLAT:??_C@_04DGGKDJMA@real?$AA@
	DD	FLAT:??_C@_07LKHFMGFB@integer?$AA@
	DD	FLAT:??_C@_09IEIGKLOD@ulong_int?$AA@
	DD	FLAT:??_C@_05GBMOKKDM@uchar?$AA@
	DD	FLAT:??_C@_0L@PGDACLAM@ushort_int?$AA@
	DD	FLAT:??_C@_04EHNLIFAM@uint?$AA@
	DD	FLAT:??_C@_08JBGFJJOH@long_int?$AA@
	DD	FLAT:??_C@_04ENMBGAPA@char?$AA@
	DD	FLAT:??_C@_09PBEIAMCH@short_int?$AA@
	DD	FLAT:??_C@_01CLKCMJKC@?5?$AA@
	DD	FLAT:??_C@_06ICGJLFIM@string?$AA@
	DD	FLAT:??_C@_07PFMCDPMA@pointer?$AA@
	DD	FLAT:??_C@_0M@NNGHDEJI@vertex_type?$AA@
	DD	FLAT:??_C@_09ICFCKGHM@edge_type?$AA@
	DD	FLAT:??_C@_0L@FMDIHOCJ@facet_type?$AA@
	DD	FLAT:??_C@_09MMCKNCIB@body_type?$AA@
	DD	FLAT:??_C@_0P@IKCOLOFK@facetedge_type?$AA@
	DD	FLAT:??_C@_0L@BBOBOLIJ@element_id?$AA@
	DD	FLAT:??_C@_0O@HLGIFPHM@boundary_type?$AA@
	DD	FLAT:??_C@_0BA@GMGEGKHC@constraint_type?$AA@
	DD	FLAT:??_C@_0O@LKOEHKMD@quantity_type?$AA@
	DD	FLAT:??_C@_0BF@NPKOHFOJ@method_instance_type?$AA@
	DD	FLAT:??_C@_0P@IMLIOJAD@procedure_type?$AA@
	DD	FLAT:??_C@_05HIFJDKLD@array?$AA@
	ORG $+4
_dip	DQ	0bfe0000000000000r		; -0.5
	DQ	0bfe0000000000000r		; -0.5
	DQ	00000000000000000r		; 0
	DQ	0bff0000000000000r		; -1
	DQ	03fe0000000000000r		; 0.5
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	0bfe0000000000000r		; -0.5
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	03fe0000000000000r		; 0.5
	DQ	03fe0000000000000r		; 0.5
	DQ	0bff0000000000000r		; -1
	DQ	0bff0000000000000r		; -1
	DQ	03fe0000000000000r		; 0.5
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	03fe0000000000000r		; 0.5
	DQ	0bff0000000000000r		; -1
	DQ	0bff0000000000000r		; -1
	DQ	0bfe0000000000000r		; -0.5
	DQ	0bfe0000000000000r		; -0.5
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	0bfe0000000000000r		; -0.5
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03fe0000000000000r		; 0.5
	DQ	0bff0000000000000r		; -1
	DQ	00000000000000000r		; 0
_DATA	ENDS
PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_unset_attr
; Function compile flags: /Ogtp
;	COMDAT _unset_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_unset_attr PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 29   :   elptr(id)->attr &= ~attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	not	ecx
	and	DWORD PTR [eax+8], ecx
	not	edx
	and	DWORD PTR [eax+12], edx

; 30   : }

	pop	ebp
	ret	0
_unset_attr ENDP
_TEXT	ENDS
PUBLIC	_set_fe_edge
EXTRN	_top_timestamp:DWORD
EXTRN	_global_timestamp:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_e_id$ = 12						; size = 4
_set_fe_edge PROC					; COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp

; 36   :   if ( inverted(fe_id) ) invert(e_id);

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN1@set_fe_edg
	xor	DWORD PTR _e_id$[ebp], 134217728	; 08000000H
$LN1@set_fe_edg:

; 37   :   feptr(fe_id)->fe_edge_id = e_id;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR [edx+20], eax

; 38   :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 39   : }

	pop	ebp
	ret	0
_set_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_edge
; Function compile flags: /Ogtp
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _set_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_edge PROC					; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp

; 103  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_e

; 104  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_e

; 105  :     { invert(fe);
; 106  :       feptr(fe_id)->nextedge[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+32], ecx

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 111  : }

	pop	ebp
	ret	0
$LN2@set_prev_e:

; 107  :     }
; 108  :   else
; 109  :       feptr(fe_id)->nextedge[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_e:

; 111  : }

	pop	ebp
	ret	0
_set_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_set_next_edge
; Function compile flags: /Ogtp
;	COMDAT _set_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_edge PROC					; COMDAT

; 116  : {

	push	ebp
	mov	ebp, esp

; 117  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_e

; 118  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_e

; 119  :     { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 120  :       feptr(fe_id)->nextedge[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+28], ecx

; 124  : }

	pop	ebp
	ret	0
$LN2@set_next_e:

; 121  :     }
; 122  :   else
; 123  :       feptr(fe_id)->nextedge[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN1@set_next_e:

; 124  : }

	pop	ebp
	ret	0
_set_next_edge ENDP
_TEXT	ENDS
PUBLIC	_set_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _set_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_facet PROC					; COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp

; 130  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_f

; 131  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_f

; 132  :   { invert(fe);
; 133  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+40], ecx

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 138  : }

	pop	ebp
	ret	0
$LN2@set_prev_f:

; 134  :   }
; 135  :   else
; 136  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+36], eax

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_f:

; 138  : }

	pop	ebp
	ret	0
_set_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_set_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _set_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_edge_fe PROC					; COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp

; 172  :   if ( inverted(e_id) ) invert(fe);

	mov	eax, DWORD PTR _e_id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN1@set_edge_f
	xor	DWORD PTR _fe$[ebp], 134217728		; 08000000H
$LN1@set_edge_f:

; 173  :   eptr(e_id)->fe_id = fe;

	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 174  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 175  : }

	pop	ebp
	ret	0
_set_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_set_edge_tailv
EXTRN	_insert_vertex_edge:PROC
EXTRN	_remove_vertex_edge:PROC
; Function compile flags: /Ogtp
;	COMDAT _set_edge_tailv
_TEXT	SEGMENT
tv225 = -4						; size = 4
_e_id$ = 8						; size = 4
_v_id$ = 12						; size = 4
_set_edge_tailv PROC					; COMDAT

; 210  : { vertex_id oldv;

	push	ebp
	mov	ebp, esp
	push	ecx

; 211  : 
; 212  :   /* make sure edge not in loop of old vertex */
; 213  :   oldv = get_edge_tailv(e_id);

	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR _web+216
	push	ebx
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	mov	eax, esi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	push	edi
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR tv225[ebp], eax
	je	SHORT $LN7@set_edge_t
	mov	ebx, DWORD PTR _web+636
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	add	eax, DWORD PTR [ecx+edi+304]
	mov	eax, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN6@set_edge_t
$LN7@set_edge_t:
	mov	ebx, DWORD PTR [ecx+edi+304]
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+ebx]
$LN6@set_edge_t:

; 214  :   if ( valid_id(oldv) && !equal_id(oldv,v_id) )

	mov	ebx, DWORD PTR _v_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN10@set_edge_t
	cmp	eax, ebx
	je	SHORT $LN10@set_edge_t

; 215  :     remove_vertex_edge(oldv,e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	eax
	call	_remove_vertex_edge
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	add	esp, 8
$LN10@set_edge_t:

; 216  : 
; 217  :   if ( inverted(e_id) )

	cmp	DWORD PTR tv225[ebp], 0

; 218  :      get_edge_vertices(e_id)[web.headvnum] = v_id;

	mov	edx, DWORD PTR [esi+edx]
	je	SHORT $LN2@set_edge_t
	add	edx, DWORD PTR [ecx+edi+304]
	mov	eax, DWORD PTR _web+636
	mov	DWORD PTR [edx+eax*4], ebx

; 219  :   else

	jmp	SHORT $LN1@set_edge_t
$LN2@set_edge_t:

; 220  :      get_edge_vertices(e_id)[0] = v_id;

	mov	eax, DWORD PTR [ecx+edi+304]
	mov	DWORD PTR [edx+eax], ebx
$LN1@set_edge_t:

; 221  :   insert_vertex_edge(v_id,e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	ebx
	call	_insert_vertex_edge

; 222  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	esp, 8
	pop	edi
	inc	eax
	pop	esi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	ebx

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_set_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_set_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _set_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_v_id$ = 12						; size = 4
_set_edge_headv PROC					; COMDAT

; 229  : {

	push	ebp
	mov	ebp, esp

; 230  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]
	push	esi

; 231  :      get_edge_vertices(e_id)[0] = v_id;

	mov	esi, DWORD PTR _dymem
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_edge_h
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+216
	mov	esi, DWORD PTR [ecx+esi+304]
	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	DWORD PTR [edx+esi], ecx

; 232  :   else

	jmp	SHORT $LN1@set_edge_h
$LN2@set_edge_h:

; 233  :      get_edge_vertices(e_id)[web.headvnum] = v_id;

	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	add	edx, DWORD PTR [ecx+esi+304]
	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	esi, DWORD PTR _web+636
	mov	DWORD PTR [edx+esi*4], ecx
$LN1@set_edge_h:

; 234  :   insert_vertex_edge(v_id,inverse_id(e_id));

	xor	eax, 134217728				; 08000000H
	push	eax
	push	ecx
	call	_insert_vertex_edge

; 235  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	esp, 8
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	esi

; 236  : }

	pop	ebp
	ret	0
_set_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_set_edge_midv
; Function compile flags: /Ogtp
;	COMDAT _set_edge_midv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_v_id$ = 12						; size = 4
_set_edge_midv PROC					; COMDAT

; 241  : { get_edge_vertices(e_id)[2] = v_id;

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _e_id$[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+esi+304]
	mov	eax, DWORD PTR _v_id$[ebp]
	mov	DWORD PTR [ecx+esi+8], eax

; 242  :   set_vertex_edge(v_id,e_id);

	mov	esi, DWORD PTR _web+12
	mov	ecx, eax

; 243  :   set_attr(v_id,Q_MIDPOINT);

	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	esi, DWORD PTR [ecx+esi]
	mov	DWORD PTR [esi+28], edx
	mov	edx, DWORD PTR _web[eax+12]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 131072		; 00020000H
	mov	DWORD PTR [ecx+12], eax

; 244  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	esi

; 245  : }

	pop	ebp
	ret	0
_set_edge_midv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_@2
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_@2:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_@2
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_@2:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	_get_body_facet
; Function compile flags: /Ogtp
;	COMDAT _get_body_facet
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_facet PROC					; COMDAT

; 279  : { return ( valid_id(b_id) ? bptr(b_id)->f_id : NULLID ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+400]
	pop	ebp
	ret	0
$LN3@get_body_f:
	xor	eax, eax
	pop	ebp
	ret	0
_get_body_facet ENDP
_TEXT	ENDS
PUBLIC	_set_body_facet
; Function compile flags: /Ogtp
;	COMDAT _set_body_facet
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_f_id$ = 12						; size = 4
_set_body_facet PROC					; COMDAT

; 302  : {  if ( valid_id(b_id) )  bptr(b_id)->f_id = (f_id); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _f_id$[ebp]
	mov	DWORD PTR [edx+400], eax
$LN1@set_body_f:
	pop	ebp
	ret	0
_set_body_facet ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_get_body_pressure
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_pressure PROC					; COMDAT

; 317  :     { return  ( valid_id(b_id) ?    bptr(b_id)->pressure : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_p
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+312]
	pop	ebp
	ret	0
$LN3@get_body_p:
	fldz
	pop	ebp
	ret	0
_get_body_pressure ENDP
_TEXT	ENDS
PUBLIC	_get_extra
; Function compile flags: /Ogtp
;	COMDAT _get_extra
_TEXT	SEGMENT
_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_extra PROC						; COMDAT

; 348  : { int type = id_type(id);

	push	ebp
	mov	ebp, esp

; 349  : 
; 350  :   return ( (char*)elptr(id) + EXTRAS(type)[n].offset);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	shr	eax, 29					; 0000001dH
	imul	esi, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, esi
	add	eax, DWORD PTR [edi+ecx+64]
	pop	edi
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_get_extra ENDP
_TEXT	ENDS
PUBLIC	_get_meth_offset
; Function compile flags: /Ogtp
;	COMDAT _get_meth_offset
_TEXT	SEGMENT
_type$ = 8						; size = 4
_get_meth_offset PROC					; COMDAT

; 376  : { int meth_offset;

	push	ebp
	mov	ebp, esp

; 377  :   meth_offset = EXTRAS(type)[web.meth_attr[type]].offset; 

	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR _web[eax*4+5664]
	imul	eax, 112				; 00000070H

; 378  :   return meth_offset;

	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR [ecx+edx+64]

; 379  : }

	pop	ebp
	ret	0
_get_meth_offset ENDP
_TEXT	ENDS
PUBLIC	_Ord
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\skeleton.c
;	COMDAT _Ord
_TEXT	SEGMENT
_id$ = 8						; size = 4
_Ord	PROC						; COMDAT

; 60   : { return loc_ordinal(id); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@Ord
	and	eax, 134217727				; 07ffffffH
	pop	ebp
	ret	0
$LN3@Ord:
	or	eax, -1
	pop	ebp
	ret	0
_Ord	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@EHEIENNG@Unclosed?5loop?4?$AA@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_03JDANDILB@?$CFd?5?$AA@			; `string'
PUBLIC	??_C@_0BJ@HOGOCOHJ@No?5valid?5edge?5on?5vertex?4?$AA@ ; `string'
PUBLIC	_vloop
EXTRN	_printf:PROC
EXTRN	_puts:PROC
;	COMDAT ??_C@_0P@EHEIENNG@Unclosed?5loop?4?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0P@EHEIENNG@Unclosed?5loop?4?$AA@ DB 'Unclosed loop.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JDANDILB@?$CFd?5?$AA@
CONST	SEGMENT
??_C@_03JDANDILB@?$CFd?5?$AA@ DB '%d ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HOGOCOHJ@No?5valid?5edge?5on?5vertex?4?$AA@
CONST	SEGMENT
??_C@_0BJ@HOGOCOHJ@No?5valid?5edge?5on?5vertex?4?$AA@ DB 'No valid edge o'
	DB	'n vertex.', 00H				; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\skeleton.c
CONST	ENDS
;	COMDAT _vloop
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_v_id$ = 8						; size = 4
_vloop	PROC						; COMDAT

; 67   : { edge_id e_id,ee_id;

	push	ebp
	mov	ebp, esp

; 68   :   int n = 0;
; 69   :   e_id = get_vertex_edge(v_id);

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [edx+28]
	xor	ebx, ebx
	mov	DWORD PTR _e_id$[ebp], esi

; 70   :   if ( !valid_id(e_id) ) 

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN5@vloop

; 71   :      { puts("No valid edge on vertex."); return; }

	push	OFFSET ??_C@_0BJ@HOGOCOHJ@No?5valid?5edge?5on?5vertex?4?$AA@
	call	_puts
	add	esp, 4
	pop	esi
	pop	ebx

; 79   : } // end vloop()

	pop	ebp
	ret	0
$LN5@vloop:
	push	edi
$LL4@vloop:

; 72   :   ee_id = e_id;
; 73   :   do { printf("%d ",inverted(ee_id)?-(Ord(ee_id)+1): (Ord(ee_id)+1)); 

	mov	edi, esi
	push	esi
	shr	edi, 27					; 0000001bH
	call	_Ord
	add	esp, 4
	and	edi, 1
	je	SHORT $LN8@vloop
	or	ecx, -1
	sub	ecx, eax
	jmp	SHORT $LN9@vloop
$LN8@vloop:
	lea	ecx, DWORD PTR [eax+1]
$LN9@vloop:
	push	ecx
	push	OFFSET ??_C@_03JDANDILB@?$CFd?5?$AA@
	call	_printf

; 74   :        ee_id = get_next_tail_edge(ee_id);

	mov	eax, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+edi*4+32]

; 75   :        if ( ++n > web.skel[EDGE].count )

	inc	ebx
	add	esp, 8
	cmp	ebx, DWORD PTR _web+176
	jg	SHORT $LN13@vloop

; 77   :      } while ( ee_id != e_id );

	cmp	esi, DWORD PTR _e_id$[ebp]
	jne	SHORT $LL4@vloop

; 78   :   printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 79   : } // end vloop()

	pop	ebp
	ret	0
$LN13@vloop:

; 76   :        { puts("Unclosed loop."); break;}

	push	OFFSET ??_C@_0P@EHEIENNG@Unclosed?5loop?4?$AA@
	call	_puts
	add	esp, 4

; 78   :   printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 79   : } // end vloop()

	pop	ebp
	ret	0
_vloop	ENDP
_TEXT	ENDS
PUBLIC	_set_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _set_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_facet_fe PROC					; COMDAT

; 276  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 277  :   if ( inverted(f_id) ) { invert(fe); invert(f_id); }

	mov	esi, DWORD PTR _f_id$[ebp]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN15@set_facet_
	xor	DWORD PTR _fe$[ebp], 134217728		; 08000000H
	xor	esi, 134217728				; 08000000H
$LN15@set_facet_:

; 278  :   fptr(f_id)->fe_id = fe;

	mov	ecx, DWORD PTR _web+236
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 279  :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN14@set_facet_

; 280  :   { body_id b_id = get_facet_body(f_id);

	push	esi
	call	_get_facet_body
	add	esp, 4

; 281  :     if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@set_facet_

; 282  :        set_body_facet(b_id,f_id);

	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+400], esi
$LN7@set_facet_:

; 283  :     b_id = get_facet_body(inverse_id(f_id));

	xor	esi, 134217728				; 08000000H
	push	esi
	call	_get_facet_body
	add	esp, 4

; 284  :     if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN14@set_facet_

; 285  :        set_body_facet(b_id,inverse_id(f_id));

	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+400], esi
$LN14@set_facet_:

; 286  :   }
; 287  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	esi

; 288  : } // end set_facet_fe()

	pop	ebp
	ret	0
_set_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_vertex_fvalence
EXTRN	_get_next_vertex_facet:PROC
EXTRN	_get_vertex_first_facet:PROC
; Function compile flags: /Ogtp
;	COMDAT _get_vertex_fvalence
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_get_vertex_fvalence PROC				; COMDAT

; 354  : { 

	push	ebp
	mov	ebp, esp
	push	esi

; 355  :   int valence = 0;
; 356  :   facet_id f_id = get_vertex_first_facet(v_id);

	mov	esi, DWORD PTR _v_id$[ebp]
	push	edi
	push	esi
	xor	edi, edi
	call	_get_vertex_first_facet

; 357  :   facet_id firstf = f_id;
; 358  : 
; 359  :   if ( get_vattr(v_id) & Q_MIDFACET ) return 1;

	mov	edx, DWORD PTR _web+12
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 2097152				; 00200000H
	xor	edx, edx
	add	esp, 4
	or	ecx, edx
	je	SHORT $LN5@get_vertex
	lea	eax, DWORD PTR [edi+1]
	pop	edi
	pop	esi

; 366  : } // end get_vertex_fvalence()

	pop	ebp
	ret	0
$LN5@get_vertex:

; 360  : 
; 361  :   if ( !valid_id(f_id) ) return 0;

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN8@get_vertex
	pop	edi
	xor	eax, eax
	pop	esi

; 366  : } // end get_vertex_fvalence()

	pop	ebp
	ret	0
$LN8@get_vertex:
	push	ebx

; 360  : 
; 361  :   if ( !valid_id(f_id) ) return 0;

	mov	ebx, eax
	or	ebx, 134217728				; 08000000H
$LL3@get_vertex:

; 362  :   do 
; 363  :   { valence++; f_id = get_next_vertex_facet(v_id,f_id);}

	push	eax
	push	esi
	inc	edi
	call	_get_next_vertex_facet

; 364  :   while ( !equal_element(f_id,firstf) );

	mov	ecx, eax
	or	ecx, 134217728				; 08000000H
	add	esp, 8
	cmp	ecx, ebx
	jne	SHORT $LL3@get_vertex

; 365  :   return valence; 

	pop	ebx
	mov	eax, edi
	pop	edi
	pop	esi

; 366  : } // end get_vertex_fvalence()

	pop	ebp
	ret	0
_get_vertex_fvalence ENDP
_TEXT	ENDS
PUBLIC	_set_next_body_facet
; Function compile flags: /Ogtp
;	COMDAT _set_next_body_facet
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_ff_id$ = 12						; size = 4
_set_next_body_facet PROC				; COMDAT

; 378  : { F_ELID(f_id,F_NEXT_BFACET_ATTR)[inverted(f_id)?1:0] = (ff_id) ; 

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+328
	mov	eax, DWORD PTR [eax+ecx+1264]
	mov	ecx, DWORD PTR _ff_id$[ebp]
	mov	DWORD PTR [edx+eax], ecx

; 379  : }

	pop	ebp
	ret	0
_set_next_body_facet ENDP
_TEXT	ENDS
PUBLIC	_set_prev_body_facet
; Function compile flags: /Ogtp
;	COMDAT _set_prev_body_facet
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_ff_id$ = 12						; size = 4
_set_prev_body_facet PROC				; COMDAT

; 391  : { F_ELID(f_id,F_NEXT_BFACET_ATTR)[inverted(f_id)?3:2] = (ff_id) ; 

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217728				; 08000000H
	or	ecx, 268435456				; 10000000H
	shr	ecx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+328
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+1264]
	mov	eax, DWORD PTR _ff_id$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 392  : }

	pop	ebp
	ret	0
_set_prev_body_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_body_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_body_facet
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_next_body_facet PROC				; COMDAT

; 401  : { return  F_ELID(f_id,F_NEXT_BFACET_ATTR)[inverted(f_id)?1:0]; 

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	shr	eax, 27					; 0000001bH
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 1
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+1264]
	mov	eax, DWORD PTR [edx+eax]

; 402  : }

	pop	ebp
	ret	0
_get_next_body_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_body_facet
; Function compile flags: /Ogtp
;	COMDAT _get_prev_body_facet
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_prev_body_facet PROC				; COMDAT

; 411  : { return  F_ELID(f_id,F_NEXT_BFACET_ATTR)[inverted(f_id)?3:2]; 

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217728				; 08000000H
	or	ecx, 268435456				; 10000000H
	shr	ecx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+328
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+1264]
	mov	eax, DWORD PTR [ecx+edx]

; 412  : }

	pop	ebp
	ret	0
_get_prev_body_facet ENDP
_TEXT	ENDS
PUBLIC	_set_body_volume
EXTRN	_gen_quant_list:DWORD
EXTRN	_everything_quantities_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_body_volume
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_mode$ = 20						; size = 4
_set_body_volume PROC					; COMDAT

; 425  : { struct body *b = bptr(b_id);

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _b_id$[ebp]
	mov	edx, DWORD PTR _web+348
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 426  :   if ( !valid_id(b_id) ) return;

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN1@set_body_v

; 427  :   b->volume = v; 
; 428  :   b->abstotal = fabs(v); 
; 429  :   if ( mode == SETSTAMP )

	cmp	DWORD PTR _mode$[ebp], 1
	fld	QWORD PTR _v$[ebp]
	fst	QWORD PTR [eax+40]
	fld	ST(0)
	fabs
	fstp	QWORD PTR [eax+304]
	jne	SHORT $LN2@set_body_v

; 430  :     b->voltimestamp = global_timestamp;

	mov	ecx, DWORD PTR _global_timestamp
	mov	DWORD PTR [eax+416], ecx
$LN2@set_body_v:

; 431  : /*
; 432  :   if ( web.representation == STRING)
; 433  :   { facet_id f_id = get_body_facet(b_id));
; 434  :     if ( valid_id(f_id) ) set_facet_area(f_id,v);
; 435  :   }
; 436  : */
; 437  :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN10@set_body_v

; 438  :   { struct gen_quant *q = GEN_QUANT(b->volquant);

	mov	edx, DWORD PTR [eax+404]

; 439  :     q->value = v;

	mov	eax, DWORD PTR _gen_quant_list
	imul	edx, 368				; 00000170H
	fstp	QWORD PTR [edx+eax+152]

; 440  :   }
; 441  : } // end set_body_volume()

	pop	ebp
	ret	0
$LN10@set_body_v:

; 439  :     q->value = v;

	fstp	ST(0)
$LN1@set_body_v:

; 440  :   }
; 441  : } // end set_body_volume()

	pop	ebp
	ret	0
_set_body_volume ENDP
_TEXT	ENDS
PUBLIC	_add_body_volume
EXTRN	_myunlock_element:PROC
EXTRN	_binary_tree_add:PROC
EXTRN	_mylock_element:PROC
EXTRN	_threadflag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _add_body_volume
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_add_body_volume PROC					; COMDAT

; 451  : { /* uses binary tree add */ 

	push	ebp
	mov	ebp, esp
	push	edi

; 452  :   
; 453  :   struct body *b;
; 454  :   if ( !valid_id(b_id) ) return;

	mov	edi, DWORD PTR _b_id$[ebp]
	test	edi, 268435456				; 10000000H
	je	SHORT $LN6@add_body_v

; 455  :   LOCK_ELEMENT(b_id);

	cmp	DWORD PTR _threadflag, 0
	je	SHORT $LN4@add_body_v
	push	edi
	call	_mylock_element
	add	esp, 4
$LN4@add_body_v:

; 456  :   b = bptr(b_id);

	mov	ecx, DWORD PTR _web+348

; 457  :   binary_tree_add(b->volume_addends,v);

	fld	QWORD PTR _v$[ebp]
	mov	eax, edi
	push	esi
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]
	sub	esp, 8
	lea	edx, DWORD PTR [esi+48]
	fstp	QWORD PTR [esp]
	push	edx
	call	_binary_tree_add

; 458  :   b->abstotal += fabs(v); 

	fld	QWORD PTR _v$[ebp]
	fabs
	add	esp, 12					; 0000000cH
	fadd	QWORD PTR [esi+304]
	fstp	QWORD PTR [esi+304]

; 459  :   UNLOCK_ELEMENT(b_id);

	cmp	DWORD PTR _threadflag, 0
	pop	esi
	je	SHORT $LN6@add_body_v
	push	edi
	call	_myunlock_element
	add	esp, 4
$LN6@add_body_v:
	pop	edi

; 460  : } // end add_body_volume()

	pop	ebp
	ret	0
_add_body_volume ENDP
_TEXT	ENDS
PUBLIC	_add_body_volume_plain
; Function compile flags: /Ogtp
;	COMDAT _add_body_volume_plain
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_add_body_volume_plain PROC				; COMDAT

; 473  : { struct body *b;

	push	ebp
	mov	ebp, esp
	push	edi

; 474  :   if ( !valid_id(b_id) ) return;

	mov	edi, DWORD PTR _b_id$[ebp]
	test	edi, 268435456				; 10000000H
	je	$LN1@add_body_v@2

; 475  :   b = bptr(b_id);

	mov	ecx, DWORD PTR _web+348
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH

; 476  :   LOCK_ELEMENT(b_id);

	cmp	DWORD PTR _threadflag, 0
	push	esi
	mov	esi, DWORD PTR [ecx+eax*4]
	je	SHORT $LN5@add_body_v@2
	push	edi
	call	_mylock_element
	add	esp, 4
$LN5@add_body_v@2:

; 477  :   b->volume += v;

	fld	QWORD PTR [esi+40]
	fld	QWORD PTR _v$[ebp]
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [esi+40]

; 478  :   b->abstotal += fabs(v); 

	fabs
	fadd	QWORD PTR [esi+304]
	fstp	QWORD PTR [esi+304]

; 479  :   UNLOCK_ELEMENT(b_id);

	cmp	DWORD PTR _threadflag, 0
	je	SHORT $LN7@add_body_v@2
	push	edi
	call	_myunlock_element
	add	esp, 4
$LN7@add_body_v@2:

; 480  :   b->voltimestamp = global_timestamp;

	mov	edx, DWORD PTR _global_timestamp
	mov	DWORD PTR [esi+416], edx

; 481  : /*
; 482  :   if ( web.representation == STRING)
; 483  :   { facet_id f_id = get_fe_facet(b->fe_id);
; 484  :     if ( valid_id(f_id) ) set_facet_area(f_id,b->volume);
; 485  :   }
; 486  : */
; 487  :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN9@add_body_v@2

; 488  :   { struct gen_quant *q = GEN_QUANT(b->volquant);

	mov	eax, DWORD PTR [esi+404]

; 489  :     q->value = b->volume;

	fld	QWORD PTR [esi+40]
	mov	ecx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	fstp	QWORD PTR [eax+ecx+152]
$LN9@add_body_v@2:
	pop	esi
$LN1@add_body_v@2:
	pop	edi

; 490  :   } 
; 491  : } // end add_body_volume_plain()

	pop	ebp
	ret	0
_add_body_volume_plain ENDP
_TEXT	ENDS
PUBLIC	_add_body_abstotal
; Function compile flags: /Ogtp
;	COMDAT _add_body_abstotal
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_add_body_abstotal PROC					; COMDAT

; 500  : { struct body *b;

	push	ebp
	mov	ebp, esp

; 501  :   if ( !valid_id(b_id) ) return;

	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2@add_body_a

; 502  :   b = bptr(b_id);

	mov	ecx, DWORD PTR _web+348

; 503  :   b->abstotal += fabs(v); 

	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	fabs
	mov	eax, DWORD PTR [ecx+eax*4]
	fadd	QWORD PTR [eax+304]
	fstp	QWORD PTR [eax+304]
$LN2@add_body_a:

; 504  : } // end add_body_abstotal()

	pop	ebp
	ret	0
_add_body_abstotal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@EIPHBNJE@fix?5body?5volume?3?5illegal?5body?5?$CFs@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	_set_body_fixvol
EXTRN	_kb_error:PROC
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
;	COMDAT ??_C@_0CD@EIPHBNJE@fix?5body?5volume?3?5illegal?5body?5?$CFs@
CONST	SEGMENT
??_C@_0CD@EIPHBNJE@fix?5body?5volume?3?5illegal?5body?5?$CFs@ DB 'fix bod'
	DB	'y volume: illegal body %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _set_body_fixvol
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_fixvol PROC					; COMDAT

; 517  : { if ( valid_id(b_id) )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	$LN5@set_body_f@2

; 518  :   { bptr(b_id)->fixvol = (v); 

	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [edx+eax]
	fst	QWORD PTR [ecx+32]

; 519  :     if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN11@set_body_f@2

; 520  :     { struct gen_quant *q = GEN_QUANT(get_body_volquant(b_id));

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [ecx+404]
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list

; 521  :       q->target = v;
; 522  :       if ( !(q->flags & Q_FIXED) )

	mov	ecx, DWORD PTR [eax+136]
	fstp	QWORD PTR [eax+144]
	test	cl, 2
	jne	SHORT $LN3@set_body_f@2

; 523  :       { q->flags &= ~(Q_INFO|Q_ENERGY|Q_CONSERVED);

	and	ecx, -14				; fffffff2H

; 524  :         q->flags |= Q_FIXED;

	or	ecx, 2
	mov	DWORD PTR [eax+136], ecx
$LN3@set_body_f@2:

; 525  :       }
; 526  :       if ( web.pressure_flag )

	cmp	DWORD PTR _web+868, 0
	je	SHORT $LN1@set_body_f@2

; 527  :       { q = GEN_QUANT(get_body_ambquant(b_id));

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [ecx+408]
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list

; 528  :         q->flags &= ~(Q_INFO|Q_FIXED|Q_CONSERVED);

	mov	edx, DWORD PTR [eax+136]
	and	edx, -15				; fffffff1H

; 529  :         q->flags |= Q_ENERGY;

	or	edx, 1
	mov	DWORD PTR [eax+136], edx

; 536  :   }
; 537  : } // end set_body_fixvol()

	pop	ebp
	ret	0
$LN5@set_body_f@2:

; 530  :       }
; 531  :     }
; 532  :   }
; 533  :   else
; 534  :   { sprintf(errmsg,"fix body volume: illegal body %s.\n",ELNAME(b_id));

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0CD@EIPHBNJE@fix?5body?5volume?3?5illegal?5body?5?$CFs@
	push	OFFSET _errmsg
	call	_sprintf

; 535  :     kb_error(1307,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1307					; 0000051bH
	call	_kb_error
	add	esp, 24					; 00000018H

; 536  :   }
; 537  : } // end set_body_fixvol()

	pop	ebp
	ret	0
$LN11@set_body_f@2:

; 535  :     kb_error(1307,errmsg,RECOVERABLE);

	fstp	ST(0)
$LN1@set_body_f@2:

; 536  :   }
; 537  : } // end set_body_fixvol()

	pop	ebp
	ret	0
_set_body_fixvol ENDP
_TEXT	ENDS
PUBLIC	_dup_vertex
EXTRN	_new_element:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT _dup_vertex
_TEXT	SEGMENT
_old_v$ = 8						; size = 4
_dup_vertex PROC					; COMDAT

; 578  : { 

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 579  :   vertex_id v_id;
; 580  :   struct vertex *v_id_p;
; 581  : 
; 582  :   v_id = new_element(VERTEX,NULLID,NULLID);

	push	0
	push	0
	push	0
	call	_new_element

; 583  :   v_id_p = vptr(v_id);

	mov	ecx, DWORD PTR _web+12

; 584  :   memcpy((char *)&(v_id_p->attr),(char *)&(elptr(old_v)->attr),
; 585  :               web.sizes[VERTEX] - ((char*)&(v_id_p->attr)-(char*)v_id_p));

	mov	edx, DWORD PTR _web+560
	mov	esi, eax
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _old_v$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	add	edx, -8					; fffffff8H
	push	edx
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	call	_memcpy
	add	esp, 24					; 00000018H

; 586  :   v_id_p->self_id = v_id;  /* restore new id */

	mov	DWORD PTR [edi+16], esi

; 587  :   v_id_p->e_id = NULLID;

	mov	DWORD PTR [edi+28], 0
	pop	edi

; 588  :   return v_id;

	mov	eax, esi
	pop	esi

; 589  : } // end dup_vertex()

	pop	ebp
	ret	0
_dup_vertex ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	_new_edge
EXTRN	_NULLFACETEDGE:DWORD
;	COMDAT __real@3fe0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\skeleton.c
CONST	ENDS
;	COMDAT _new_edge
_TEXT	SEGMENT
tv579 = -16						; size = 4
_t$ = -12						; size = 4
tv660 = -8						; size = 4
_k$ = -8						; size = 4
_e_id$ = -4						; size = 4
_h$ = 8							; size = 4
_tail_id$ = 8						; size = 4
_head_id$ = 12						; size = 4
_parent$ = 16						; size = 4
_new_edge PROC						; COMDAT

; 602  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 603  :   edge_id e_id;
; 604  :   vertex_id v_id;
; 605  :   REAL *x,*h,*t;
; 606  :   int i,k;
; 607  : 
; 608  :   e_id = new_element(EDGE,parent,NULLID);

	mov	eax, DWORD PTR _parent$[ebp]
	push	0
	push	eax
	push	1
	call	_new_element

; 609  :   set_edge_fe(e_id,NULLFACETEDGE);

	mov	ecx, DWORD PTR _NULLFACETEDGE
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _e_id$[ebp], eax
	test	eax, 134217728				; 08000000H
	je	SHORT $LN16@new_edge
	xor	ecx, 134217728				; 08000000H
$LN16@new_edge:
	mov	edx, DWORD PTR _web+124
	push	ebx
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ebx+edx]
	mov	DWORD PTR [edx+28], ecx
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx

; 610  :   set_edge_color(e_id,DEFAULT_EDGE_COLOR);

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [ebx+ecx]
	push	esi

; 611  :   if ( valid_id(tail_id) && valid_id(head_id) )

	mov	esi, DWORD PTR _tail_id$[ebp]
	xor	ecx, ecx
	mov	WORD PTR [edx+56], cx
	test	esi, 268435456				; 10000000H
	je	$LN4@new_edge
	push	edi
	mov	edi, DWORD PTR _head_id$[ebp]
	test	edi, 268435456				; 10000000H
	je	$LN33@new_edge

; 612  :   { set_edge_tailv(e_id,tail_id);

	push	esi
	push	eax
	call	_set_edge_tailv

; 613  :      set_edge_headv(e_id,head_id);

	mov	edx, DWORD PTR _e_id$[ebp]
	push	edi
	push	edx
	call	_set_edge_headv

; 614  :      if ( (web.modeltype == QUADRATIC) && valid_id(head_id) )

	mov	eax, DWORD PTR _web+628
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jne	$LN12@new_edge

; 615  :      { /* quadratic version; linear interpolation of midpoint */
; 616  :         v_id = new_element(VERTEX,parent,NULLID);

	mov	eax, DWORD PTR _parent$[ebp]
	push	0
	push	eax
	push	0
	call	_new_element

; 617  :         set_edge_midv(e_id,v_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	ebx, eax
	push	ebx
	push	ecx
	call	_set_edge_midv

; 618  :         h = get_coord(head_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax+64]
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+edi*4]

; 619  :         t = get_coord(tail_id);

	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+esi*4]

; 620  :         x = get_coord(v_id);

	and	ebx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+ebx*4]

; 621  :         for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	add	esp, 20					; 00000014H
	add	edi, eax
	add	esi, eax
	add	ebx, eax
	cmp	DWORD PTR _web+616, ecx
	jle	$LN31@new_edge
	fld	QWORD PTR __real@3fe0000000000000
	sub	esi, edi
	mov	eax, edi
	sub	ebx, edi
$LN11@new_edge:

; 622  :           x[i] = (h[i] + t[i])/2.0;

	fld	QWORD PTR [esi+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [ebx+eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN11@new_edge

; 636  :         }
; 637  :      }
; 638  :   }
; 639  :   return e_id;

	mov	eax, DWORD PTR _e_id$[ebp]
	fstp	ST(0)
	pop	edi
	pop	esi
	pop	ebx

; 640  : } // end new_edge()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@new_edge:

; 623  :      }
; 624  :      else if ( (web.modeltype == LAGRANGE) && valid_id(head_id) )

	cmp	eax, 3
	jne	$LN31@new_edge

; 625  :      { /* Lagrange version; linear interpolation of points */
; 626  :         vertex_id *v = get_edge_vertices(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	ebx, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216

; 627  :         h = get_coord(head_id);

	mov	ecx, DWORD PTR _web+104
	add	ebx, DWORD PTR [edx+eax+304]
	mov	eax, DWORD PTR [ecx+eax+64]
	mov	ecx, DWORD PTR _web+12

; 628  :         t = get_coord(tail_id);

	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+esi*4]
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+edi*4]
	add	esi, eax
	mov	DWORD PTR _t$[ebp], esi

; 629  :         for ( k = 1 ; k < web.lagrange_order ; k++ )

	mov	esi, 1
	add	edi, eax
	mov	DWORD PTR _h$[ebp], edi
	mov	DWORD PTR _k$[ebp], esi
	cmp	DWORD PTR _web+632, esi
	jle	$LN31@new_edge
	npad	4
$LL6@new_edge:

; 630  :         { v[k] = new_element(VERTEX,parent,NULLID);

	mov	edx, DWORD PTR _parent$[ebp]
	push	0
	push	edx
	push	0
	call	_new_element

; 631  :           set_attr(v[k],Q_MIDEDGE);

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	mov	DWORD PTR [ebx+esi*4], eax
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	or	DWORD PTR [eax+8], 4194304		; 00400000H
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], ecx

; 632  :           set_vertex_edge(v[k],e_id);

	mov	edx, DWORD PTR [ebx+esi*4]
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR [ecx+28], edx

; 633  :           x = get_coord(v[k]);

	mov	eax, DWORD PTR [ebx+esi*4]
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+eax+64]

; 634  :           for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN5@new_edge
	fild	DWORD PTR _k$[ebp]
	mov	eax, edi
	mov	edi, DWORD PTR _t$[ebp]
	sub	edi, DWORD PTR _h$[ebp]
	sub	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR tv579[ebp], edi
$LN3@new_edge:

; 635  :              x[i] = (k*h[i] + (web.lagrange_order-k)*t[i])/web.lagrange_order;

	mov	edi, DWORD PTR _web+632
	sub	edi, esi
	mov	DWORD PTR tv660[ebp], edi
	fild	DWORD PTR tv660[ebp]
	mov	edi, DWORD PTR tv579[ebp]
	inc	edx
	add	eax, 8
	fmul	QWORD PTR [eax+edi-8]
	fld	ST(1)
	fmul	QWORD PTR [eax-8]
	faddp	ST(1), ST(0)
	fidiv	DWORD PTR _web+632
	fstp	QWORD PTR [eax+ecx-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LN3@new_edge

; 634  :           for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR _h$[ebp]
	fstp	ST(0)
$LN5@new_edge:

; 629  :         for ( k = 1 ; k < web.lagrange_order ; k++ )

	inc	esi
	mov	DWORD PTR _k$[ebp], esi
	cmp	esi, DWORD PTR _web+632
	jl	$LL6@new_edge
$LN31@new_edge:

; 636  :         }
; 637  :      }
; 638  :   }
; 639  :   return e_id;

	mov	eax, DWORD PTR _e_id$[ebp]
$LN33@new_edge:
	pop	edi
$LN4@new_edge:
	pop	esi
	pop	ebx

; 640  : } // end new_edge()

	mov	esp, ebp
	pop	ebp
	ret	0
_new_edge ENDP
_TEXT	ENDS
PUBLIC	_recalc_facet_area
EXTRN	_calc_facet_energy:DWORD
EXTRN	_quantity_attribute:PROC
EXTRN	_default_area_quant_num:DWORD
; Function compile flags: /Ogtp
;	COMDAT _recalc_facet_area
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_recalc_facet_area PROC					; COMDAT

; 685  : {

	push	ebp
	mov	ebp, esp

; 686  :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN3@recalc_fac

; 687  :     quantity_attribute(f_id,default_area_quant_num);

	mov	eax, DWORD PTR _default_area_quant_num
	mov	ecx, DWORD PTR _f_id$[ebp]
	push	eax
	push	ecx
	call	_quantity_attribute
	fstp	ST(0)

; 689  :     (*calc_facet_energy)(f_id,AREA_ONLY);

	add	esp, 8

; 690  : } // end recalc_facet_area()

	pop	ebp
	ret	0
$LN3@recalc_fac:

; 688  :   else if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	jne	SHORT $LN1@recalc_fac

; 689  :     (*calc_facet_energy)(f_id,AREA_ONLY);

	mov	edx, DWORD PTR _f_id$[ebp]
	push	1
	push	edx
	call	DWORD PTR _calc_facet_energy
	add	esp, 8
$LN1@recalc_fac:

; 690  : } // end recalc_facet_area()

	pop	ebp
	ret	0
_recalc_facet_area ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	_new_facet
EXTRN	_opacity_attr:DWORD
;	COMDAT __real@3ff0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\skeleton.c
CONST	ENDS
;	COMDAT _new_facet
_TEXT	SEGMENT
_new_facet PROC						; COMDAT

; 699  : { 

	push	esi

; 700  :   facet_id f_id;
; 701  : 
; 702  :   f_id = new_element(FACET,NULLID,NULLID);

	push	0
	push	0
	push	2
	call	_new_element

; 703  :   set_facet_color(f_id,DEFAULT_FACET_COLOR);
; 704  :   set_facet_density(f_id,1.0);

	fld1
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [ecx+edx]
	mov	esi, 15					; 0000000fH
	mov	WORD PTR [edx+50], si
	mov	edx, DWORD PTR _web+236
	mov	edx, DWORD PTR [ecx+edx]
	mov	WORD PTR [edx+48], si
	mov	edx, DWORD PTR _web+236
	mov	edx, DWORD PTR [ecx+edx]
	fst	QWORD PTR [edx+32]

; 705  :   if ( opacity_attr ) 

	mov	esi, DWORD PTR _opacity_attr
	add	esp, 12					; 0000000cH
	test	esi, esi
	je	SHORT $LN8@new_facet

; 706  :     *(REAL*)(get_extra(f_id,opacity_attr)) = 1.0;

	mov	edx, eax
	imul	esi, 240				; 000000f0H
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	push	edi
	mov	edi, DWORD PTR _web[edx+104]
	mov	edx, DWORD PTR _web[edx+12]
	mov	ecx, DWORD PTR [edx+ecx]
	add	edi, esi
	mov	esi, DWORD PTR _dymem
	mov	esi, DWORD PTR [edi+esi+64]
	pop	edi
	fstp	QWORD PTR [esi+ecx]
	pop	esi

; 707  :   return f_id;
; 708  : }

	ret	0
$LN8@new_facet:

; 705  :   if ( opacity_attr ) 

	fstp	ST(0)
	pop	esi

; 707  :   return f_id;
; 708  : }

	ret	0
_new_facet ENDP
_TEXT	ENDS
PUBLIC	_dup_body
EXTRN	_convert_new_body_to_quantity:PROC
; Function compile flags: /Ogtp
;	COMDAT _dup_body
_TEXT	SEGMENT
_old_b$ = 8						; size = 4
_dup_body PROC						; COMDAT

; 778  : { 

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 779  :   body_id b_id;
; 780  :   struct body *b_id_p;
; 781  : 
; 782  :   b_id = new_element(BODY,NULLID,NULLID);

	push	0
	push	0
	push	3
	call	_new_element

; 783  :   b_id_p = bptr(b_id);
; 784  :   memcpy((char *)&(b_id_p->attr),(char *)&(elptr(old_b)->attr),
; 785  :               web.sizes[BODY] - ((char*)&(b_id_p->attr)-(char*)b_id_p));

	mov	ecx, DWORD PTR _web+572
	mov	edi, eax
	mov	eax, DWORD PTR _web+348
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ebx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR _old_b$[ebp]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	add	ecx, -8					; fffffff8H
	push	ecx
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	add	edx, 8
	push	edx
	lea	eax, DWORD PTR [ebx+8]
	push	eax
	call	_memcpy
	add	esp, 24					; 00000018H

; 786  :   b_id_p->self_id = b_id; /* restore new id */

	mov	DWORD PTR [ebx+16], edi

; 787  :   set_body_facet(b_id,NULLID);

	test	edi, 268435456				; 10000000H
	je	SHORT $LN8@dup_body
	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+400], 0
$LN8@dup_body:

; 788  :   if ( everything_quantities_flag ) 

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN7@dup_body

; 789  :       convert_new_body_to_quantity(b_id);

	push	edi
	call	_convert_new_body_to_quantity
	add	esp, 4
$LN7@dup_body:

; 790  :   web.bodycount++;

	inc	DWORD PTR _web+1500

; 791  :   return b_id;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 792  : } // end dup_body()

	pop	ebp
	ret	0
_dup_body ENDP
_TEXT	ENDS
PUBLIC	_check_edge_vol_methods
EXTRN	_apply_method_num:PROC
EXTRN	_meth_inst_list:DWORD
; Function compile flags: /Ogtp
;	COMDAT _check_edge_vol_methods
_TEXT	SEGMENT
tv481 = -20						; size = 4
_should_be$ = -16					; size = 8
_sign2$89666 = -12					; size = 4
_found$89697 = -8					; size = 4
_sign1$89665 = -8					; size = 4
_fe$ = -4						; size = 4
_e_id$ = 8						; size = 4
_check_edge_vol_methods PROC				; COMDAT

; 878  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 879  :   int *instlist;
; 880  :   int meth_offset; 
; 881  :   struct edge *e_ptr;
; 882  :   facetedge_id start_fe,fe;
; 883  :   int should_be[2];
; 884  :   int should_count = 0;
; 885  :   facet_id f_id,ff_id;
; 886  :   body_id b_id,bb_id;
; 887  :   int i,j;
; 888  : 
; 889  :   start_fe = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	push	ebx
	add	eax, eax
	push	esi
	mov	DWORD PTR tv481[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	push	edi
	xor	edi, edi
	test	eax, eax
	jne	SHORT $LN31@check_edge
	xor	ecx, ecx
	jmp	SHORT $LN32@check_edge
$LN31@check_edge:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN30@check_edge
	xor	eax, 134217728				; 08000000H
$LN30@check_edge:
	mov	ecx, eax
$LN32@check_edge:

; 890  :   if ( !valid_id(start_fe) )

	test	ecx, 268435456				; 10000000H

; 891  :     should_count = 0;
; 892  :   else

	je	$LN14@check_edge

; 893  :   { fe = get_next_facet(start_fe);

	mov	esi, DWORD PTR _web+460
	mov	edx, ecx
	mov	eax, ecx
	shr	edx, 27					; 0000001bH
	mov	ebx, 1
	and	eax, 134217727				; 07ffffffH
	and	edx, ebx
	mov	eax, DWORD PTR [esi+eax*4]
	je	SHORT $LN35@check_edge
	mov	esi, DWORD PTR [eax+36]
	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR _fe$[ebp], esi
	jmp	SHORT $LN34@check_edge
$LN35@check_edge:
	mov	esi, DWORD PTR [eax+40]
	mov	DWORD PTR _fe$[ebp], esi
$LN34@check_edge:

; 894  :     if ( equal_id(fe,start_fe) )

	cmp	esi, ecx
	jne	SHORT $LN25@check_edge

; 895  :     { // valence 1
; 896  :       f_id = get_fe_facet(start_fe);

	mov	esi, DWORD PTR [eax+24]
	test	edx, edx
	je	SHORT $LN38@check_edge
	xor	esi, 134217728				; 08000000H
$LN38@check_edge:

; 897  :       b_id = get_facet_body(f_id);

	push	esi
	call	_get_facet_body

; 898  :       if ( valid_id(b_id) )

	mov	ebx, DWORD PTR _web+348
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN24@check_edge

; 899  :       { should_be[0] = get_body_volmeth(b_id);

	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	edx, DWORD PTR [ecx+412]
	mov	DWORD PTR _should_be$[ebp], edx

; 900  :         should_count = 1;

	mov	edi, 1
$LN24@check_edge:

; 901  :       }
; 902  :       b_id = get_facet_body(inverse_id(f_id));

	xor	esi, 134217728				; 08000000H
	push	esi
	call	_get_facet_body
	add	esp, 4

; 903  :       if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	$LN61@check_edge

; 904  :       { should_be[0] = -get_body_volmeth(b_id);

	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ecx, DWORD PTR [eax+412]
	neg	ecx
	mov	DWORD PTR _should_be$[ebp], ecx

; 905  :         should_count = 1;

	mov	edi, 1

; 906  :       }
; 907  :     }
; 908  :     else // valence 2

	jmp	$LN61@check_edge
$LN25@check_edge:

; 909  :     { int sign1 = 1, sign2 = 1;

	mov	DWORD PTR _sign1$89665[ebp], ebx
	mov	DWORD PTR _sign2$89666[ebp], ebx

; 910  :       f_id = get_fe_facet(start_fe);

	mov	ebx, DWORD PTR [eax+24]
	test	edx, edx
	je	SHORT $LN42@check_edge
	xor	ebx, 134217728				; 08000000H
$LN42@check_edge:

; 911  :       b_id = get_facet_body(f_id);

	push	ebx
	call	_get_facet_body
	mov	esi, eax
	add	esp, 4

; 912  :       if ( !valid_id(b_id) )

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN59@check_edge

; 913  :       { b_id = get_facet_body(inverse_id(f_id));

	xor	ebx, 134217728				; 08000000H
	push	ebx
	call	_get_facet_body
	add	esp, 4
	mov	esi, eax

; 914  :         sign1 = -1;

	mov	DWORD PTR _sign1$89665[ebp], -1
$LN59@check_edge:

; 915  :       }
; 916  :       ff_id = get_fe_facet(fe);

	mov	eax, DWORD PTR _fe$[ebp]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN47@check_edge
	mov	ebx, DWORD PTR _NULLFACET
	jmp	SHORT $LN46@check_edge
$LN47@check_edge:
	mov	ecx, DWORD PTR _web+460
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ebx, DWORD PTR [edx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN46@check_edge
	xor	ebx, 134217728				; 08000000H
$LN46@check_edge:

; 917  :       bb_id = get_facet_body(ff_id);

	push	ebx
	call	_get_facet_body
	add	esp, 4

; 918  :       if ( !valid_id(bb_id) )

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN60@check_edge

; 919  :       { bb_id = get_facet_body(inverse_id(ff_id));

	xor	ebx, 134217728				; 08000000H
	push	ebx
	call	_get_facet_body
	add	esp, 4

; 920  :         sign2 = -1;

	or	ecx, -1
	jmp	SHORT $LN20@check_edge
$LN60@check_edge:
	mov	ecx, DWORD PTR _sign2$89666[ebp]
$LN20@check_edge:

; 921  :       }
; 922  :       if ( valid_id(b_id) && valid_id(bb_id) )

	mov	edx, esi
	shr	edx, 28					; 0000001cH
	and	edx, 1
	je	SHORT $LN66@check_edge
	test	eax, 268435456				; 10000000H
	je	SHORT $LN66@check_edge

; 923  :       { if ( !equal_id(b_id,bb_id) )

	cmp	esi, eax
	je	$LN61@check_edge

; 924  :         { should_be[0] = sign1*get_body_volmeth(b_id);

	mov	edx, DWORD PTR _web+348
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [esi+412]
	imul	esi, DWORD PTR _sign1$89665[ebp]

; 925  :           should_be[1] = sign2*get_body_volmeth(bb_id);

	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+412]
	imul	edx, ecx
	mov	DWORD PTR _should_be$[ebp], esi
	mov	DWORD PTR _should_be$[ebp+4], edx

; 926  :           should_count = 2;

	mov	edi, 2

; 927  :         }

	jmp	SHORT $LN61@check_edge
$LN66@check_edge:

; 928  :       }
; 929  :       else if ( valid_id(b_id) )

	test	edx, edx
	je	SHORT $LN16@check_edge

; 930  :       {  should_be[0] = sign1*get_body_volmeth(b_id);

	mov	eax, DWORD PTR _web+348
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	edx, DWORD PTR [ecx+412]
	imul	edx, DWORD PTR _sign1$89665[ebp]
	mov	DWORD PTR _should_be$[ebp], edx

; 931  :          should_count = 1;

	mov	edi, 1
	jmp	SHORT $LN61@check_edge
$LN16@check_edge:

; 932  :       }
; 933  :       else if ( valid_id(bb_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN14@check_edge

; 934  :       { should_be[0] = sign2*get_body_volmeth(bb_id);

	mov	edx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+412]
	imul	edx, ecx
	mov	DWORD PTR _should_be$[ebp], edx

; 935  :         should_count = 1;

	mov	edi, 1

; 936  :       }
; 937  :       else

	jmp	SHORT $LN61@check_edge
$LN14@check_edge:

; 938  :         should_count = 0;

	xor	edi, edi
$LN61@check_edge:

; 939  :     }
; 940  :   }
; 941  : 
; 942  :   meth_offset = get_meth_offset(EDGE); 
; 943  :   e_ptr = (struct edge *)elptr(e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR tv481[ebp]
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web+5668
	mov	ecx, DWORD PTR [edx+ecx]
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216

; 944  :   instlist = (int*)((char*)e_ptr + meth_offset); 

	mov	edx, DWORD PTR _dymem
	mov	ebx, DWORD PTR [eax+edx+64]

; 945  :  
; 946  :   // see if any unwanted
; 947  :   for ( i = 0 ; i < (int)e_ptr->method_count ; i++ )

	xor	eax, eax
	add	ebx, ecx
	xor	esi, esi
	cmp	ax, WORD PTR [ecx+24]
	jae	SHORT $LN10@check_edge
$LL12@check_edge:

; 948  :   { struct method_instance *mi = METH_INSTANCE(instlist[i]);

	mov	eax, DWORD PTR [ebx+esi*4]
	cdq
	xor	eax, edx
	sub	eax, edx

; 949  :     if ( mi->flags & BODY_INSTANCE )

	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	test	DWORD PTR [eax+edx+140], 16777216	; 01000000H
	je	SHORT $LN11@check_edge

; 950  :     { int found = 0;

	xor	eax, eax
	mov	DWORD PTR _found$89697[ebp], eax

; 951  :       for ( j = 0 ; j < should_count ; j++ )

	cmp	edi, eax
	jle	SHORT $LN58@check_edge
	npad	1
$LL8@check_edge:

; 952  :         if ( should_be[j] == instlist[i] )

	mov	edx, DWORD PTR [ebx+esi*4]
	cmp	DWORD PTR _should_be$[ebp+eax*4], edx
	jne	SHORT $LN7@check_edge

; 953  :         { found = 1;
; 954  :           should_be[j] = should_be[--should_count]; // remove from list

	mov	edx, DWORD PTR _should_be$[ebp+edi*4-4]
	dec	edi
	mov	DWORD PTR _should_be$[ebp+eax*4], edx
	mov	DWORD PTR _found$89697[ebp], 1

; 955  :           j--;

	dec	eax
$LN7@check_edge:

; 951  :       for ( j = 0 ; j < should_count ; j++ )

	inc	eax
	cmp	eax, edi
	jl	SHORT $LL8@check_edge

; 956  :         }
; 957  :       if ( !found ) // remove

	cmp	DWORD PTR _found$89697[ebp], 0
	jne	SHORT $LN11@check_edge
$LN58@check_edge:

; 958  :       { instlist[i] = instlist[--e_ptr->method_count]; 

	mov	eax, 65535				; 0000ffffH
	add	WORD PTR [ecx+24], ax
	movzx	edx, WORD PTR [ecx+24]
	mov	eax, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [ebx+esi*4], eax

; 959  :         i--;

	dec	esi
$LN11@check_edge:

; 945  :  
; 946  :   // see if any unwanted
; 947  :   for ( i = 0 ; i < (int)e_ptr->method_count ; i++ )

	movzx	edx, WORD PTR [ecx+24]
	inc	esi
	cmp	esi, edx
	jl	SHORT $LL12@check_edge
$LN10@check_edge:

; 960  :       }
; 961  :     }
; 962  :   }
; 963  : 
; 964  :   // remaining ones in list need to be added
; 965  :   for ( j = 0 ; j < should_count ; j++ )

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN1@check_edge
$LL65@check_edge:

; 966  :     apply_method_num(e_id,should_be[j]);

	mov	eax, DWORD PTR _should_be$[ebp+esi*4]
	mov	ecx, DWORD PTR _e_id$[ebp]
	push	eax
	push	ecx
	call	_apply_method_num
	inc	esi
	add	esp, 8
	cmp	esi, edi
	jl	SHORT $LL65@check_edge
$LN1@check_edge:
	pop	edi
	pop	esi
	pop	ebx

; 967  : 
; 968  : } // end check_edge_vol_methods()

	mov	esp, ebp
	pop	ebp
	ret	0
_check_edge_vol_methods ENDP
_TEXT	ENDS
PUBLIC	_get_edge_length
EXTRN	_calc_edge:PROC
; Function compile flags: /Ogtp
;	COMDAT _get_edge_length
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_length PROC					; COMDAT

; 978  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 979  :   calc_edge(e_id);

	mov	esi, DWORD PTR _e_id$[ebp]
	push	esi
	call	_calc_edge

; 980  :   return (eptr(e_id)->length);

	mov	eax, DWORD PTR _web+124
	add	esp, 4
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	fld	QWORD PTR [ecx+48]
	pop	esi

; 981  : } // end get_edge_length()

	pop	ebp
	ret	0
_get_edge_length ENDP
_TEXT	ENDS
PUBLIC	_get_facet_pressure
; Function compile flags: /Ogtp
;	COMDAT _get_facet_pressure
_TEXT	SEGMENT
tv84 = -8						; size = 8
_f_id$ = 8						; size = 4
_get_facet_pressure PROC				; COMDAT

; 991  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 992  :   return  (get_body_pressure(get_facet_body(f_id)) - 
; 993  :         get_body_pressure(get_facet_body(facet_inverse(f_id))));

	mov	esi, DWORD PTR _f_id$[ebp]
	push	edi
	push	esi
	call	_get_facet_body
	mov	edi, DWORD PTR _web+348
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN5@get_facet_@3
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [eax+312]
	jmp	SHORT $LN12@get_facet_@3
$LN5@get_facet_@3:
	fldz
$LN12@get_facet_@3:
	xor	esi, 134217728				; 08000000H
	fstp	QWORD PTR tv84[ebp]
	push	esi
	call	_get_facet_body
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN9@get_facet_@3
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [ecx+312]
	pop	edi
	fsubr	QWORD PTR tv84[ebp]
	pop	esi

; 994  : } // end get_facet_pressure()

	mov	esp, ebp
	pop	ebp
	ret	0

; 992  :   return  (get_body_pressure(get_facet_body(f_id)) - 
; 993  :         get_body_pressure(get_facet_body(facet_inverse(f_id))));

$LN9@get_facet_@3:
	fldz
	pop	edi
	fsubr	QWORD PTR tv84[ebp]
	pop	esi

; 994  : } // end get_facet_pressure()

	mov	esp, ebp
	pop	ebp
	ret	0
_get_facet_pressure ENDP
_TEXT	ENDS
PUBLIC	_compare_vertex_attr
EXTRN	_V_BOUNDARY_ATTR:DWORD
; Function compile flags: /Ogtp
;	COMDAT _compare_vertex_attr
_TEXT	SEGMENT
tv261 = -16						; size = 4
_same$ = -12						; size = 4
_con1$ = -8						; size = 4
_con2$ = -4						; size = 4
_va$ = 8						; size = 4
_vb$ = 12						; size = 4
_compare_vertex_attr PROC				; COMDAT

; 1010 : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1011 :   conmap_t * con1,*con2;
; 1012 :   int bdry1,bdry2;
; 1013 :   int same = 0;
; 1014 : 
; 1015 :   con1 = get_v_constraint_map(va);

	mov	edx, DWORD PTR _va$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _dymem
	push	esi
	mov	esi, DWORD PTR _web+12
	push	edi
	mov	edi, DWORD PTR _web+104
	mov	eax, DWORD PTR [edi+ebx+1288]
	mov	DWORD PTR _same$[ebp], 0
	test	eax, eax
	je	SHORT $LN24@compare_ve
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	add	ecx, DWORD PTR [edi+ebx+1264]
	mov	DWORD PTR _con1$[ebp], ecx
	jmp	SHORT $LN25@compare_ve
$LN24@compare_ve:
	mov	DWORD PTR _con1$[ebp], OFFSET _nullcon
$LN25@compare_ve:

; 1016 :   con2 = get_v_constraint_map(vb);

	mov	ecx, DWORD PTR _vb$[ebp]
	test	eax, eax
	je	SHORT $LN26@compare_ve
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	add	eax, DWORD PTR [edi+ebx+1264]
	mov	DWORD PTR _con2$[ebp], eax
	jmp	SHORT $LN27@compare_ve
$LN26@compare_ve:
	mov	DWORD PTR _con2$[ebp], OFFSET _nullcon
$LN27@compare_ve:

; 1017 : 
; 1018 :   bdry1 = get_vertex_boundary_num(va);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN11@compare_ve
	imul	eax, 240				; 000000f0H
	add	eax, edi
	mov	eax, DWORD PTR [eax+ebx+64]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR [eax+edx]

; 1019 :   bdry2 = get_vertex_boundary_num(vb);

	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	eax, DWORD PTR [eax+ecx]

; 1020 : 
; 1021 :   /* check boundaries */
; 1022 :   if ( bdry1 )

	test	edx, edx
	je	SHORT $LN21@compare_ve

; 1023 :   { if ( bdry2 )

	test	eax, eax
	je	SHORT $LN20@compare_ve

; 1024 :     { if ( bdry1 == bdry2 ) 

	xor	ecx, ecx
	cmp	edx, eax
	setne	cl
	pop	edi
	pop	esi
	pop	ebx
	lea	eax, DWORD PTR [ecx-1]
	and	eax, 2

; 1056 : } // end compare_vertex_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@compare_ve:

; 1025 :          return A_EQ_B;
; 1026 :       else return INCOMPARABLE;
; 1027 :     }
; 1028 :     else if ( con2[0] )

	mov	edx, DWORD PTR _con2$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	sbb	eax, eax
	pop	edi
	and	eax, -3					; fffffffdH
	pop	esi
	add	eax, 3
	pop	ebx

; 1056 : } // end compare_vertex_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@compare_ve:

; 1029 :       return INCOMPARABLE;
; 1030 :     else 
; 1031 :       return A_SUPER_B;
; 1032 :   }
; 1033 :   else if ( bdry2 )

	test	eax, eax
	je	SHORT $LN11@compare_ve

; 1034 :   { if ( con1[0] )

	mov	ecx, DWORD PTR _con1$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	pop	edi
	pop	esi
	sete	al
	pop	ebx

; 1056 : } // end compare_vertex_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@compare_ve:

; 1035 :       return INCOMPARABLE;
; 1036 :     else
; 1037 :     return A_SUB_B;
; 1038 :   }
; 1039 :  
; 1040 :   /* check constraints */
; 1041 :   for ( i = 1 ; i <= (int)con2[0] ; i++ )

	mov	eax, DWORD PTR _con2$[ebp]
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR _con1$[ebp]
	mov	edx, 1
	mov	DWORD PTR tv261[ebp], ebx
	cmp	ebx, edx
	jl	SHORT $LN8@compare_ve
	mov	esi, DWORD PTR [edi]
	npad	4
$LL38@compare_ve:

; 1042 :   { for ( j = 1 ; j <= (int)con1[0] ; j++ )

	mov	eax, 1
	cmp	esi, eax
	jl	SHORT $LN9@compare_ve
	mov	ecx, DWORD PTR _con2$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	ecx, 1073741823				; 3fffffffH
$LL7@compare_ve:

; 1043 :       if ( (con1[j]&CONMASK) == (con2[i]&CONMASK) )

	mov	ebx, DWORD PTR [edi+eax*4]
	and	ebx, 1073741823				; 3fffffffH
	cmp	ebx, ecx
	je	SHORT $LN34@compare_ve

; 1042 :   { for ( j = 1 ; j <= (int)con1[0] ; j++ )

	inc	eax
	cmp	eax, esi
	jle	SHORT $LL7@compare_ve

; 1043 :       if ( (con1[j]&CONMASK) == (con2[i]&CONMASK) )

	jmp	SHORT $LN39@compare_ve
$LN34@compare_ve:

; 1044 :       { same++;

	inc	DWORD PTR _same$[ebp]
$LN39@compare_ve:
	mov	ebx, DWORD PTR tv261[ebp]
$LN9@compare_ve:

; 1035 :       return INCOMPARABLE;
; 1036 :     else
; 1037 :     return A_SUB_B;
; 1038 :   }
; 1039 :  
; 1040 :   /* check constraints */
; 1041 :   for ( i = 1 ; i <= (int)con2[0] ; i++ )

	inc	edx
	cmp	edx, ebx
	jle	SHORT $LL38@compare_ve
$LN8@compare_ve:

; 1045 :         break;
; 1046 :       }
; 1047 :   }
; 1048 : 
; 1049 :   if ( (same==(int)con1[0]) && (same==(int)con2[0]) )

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR _same$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN41@compare_ve
	cmp	eax, ebx
	jne	SHORT $LN3@compare_ve

; 1050 :     return A_EQ_B;

	pop	edi
	pop	esi
	mov	eax, 2
	pop	ebx

; 1056 : } // end compare_vertex_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@compare_ve:

; 1051 :   if ( (same==(int)con1[0]) && (same < (int)con2[0]) )

	cmp	eax, ecx
	jne	SHORT $LN41@compare_ve
	cmp	eax, ebx
	jge	SHORT $LN2@compare_ve

; 1052 :     return A_SUB_B;

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 1056 : } // end compare_vertex_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@compare_ve:

; 1053 :   if ( (same < (int)con1[0]) && (same==(int)con2[0]) )

	cmp	eax, ecx
$LN41@compare_ve:
	jge	SHORT $LN1@compare_ve
	cmp	eax, ebx
	jne	SHORT $LN1@compare_ve

; 1054 :     return A_SUPER_B;

	pop	edi
	pop	esi
	mov	eax, 3
	pop	ebx

; 1056 : } // end compare_vertex_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@compare_ve:
	pop	edi
	pop	esi

; 1055 :   return INCOMPARABLE;

	xor	eax, eax
	pop	ebx

; 1056 : } // end compare_vertex_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
_compare_vertex_attr ENDP
_TEXT	ENDS
PUBLIC	_compare_vertex_edge_attr
EXTRN	_E_BOUNDARY_ATTR:DWORD
; Function compile flags: /Ogtp
;	COMDAT _compare_vertex_edge_attr
_TEXT	SEGMENT
tv276 = -16						; size = 4
_same$ = -12						; size = 4
_con1$ = -8						; size = 4
_con2$ = -4						; size = 4
_va$ = 8						; size = 4
_eb$ = 12						; size = 4
_compare_vertex_edge_attr PROC				; COMDAT

; 1071 : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1072 :   conmap_t * con1,*con2;
; 1073 :   int bdry1,bdry2;
; 1074 :   int same = 0;
; 1075 : 
; 1076 :   con1 = get_v_constraint_map(va);

	mov	eax, DWORD PTR _dymem
	push	ebx
	push	esi
	mov	esi, DWORD PTR _va$[ebp]
	push	edi
	mov	edi, DWORD PTR _web+104
	cmp	DWORD PTR [edi+eax+1288], 0
	mov	DWORD PTR _same$[ebp], 0
	je	SHORT $LN24@compare_ve@2
	mov	edx, DWORD PTR _web+12
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	add	ecx, DWORD PTR [edi+eax+1264]
	mov	DWORD PTR _con1$[ebp], ecx
	jmp	SHORT $LN25@compare_ve@2
$LN24@compare_ve@2:
	mov	DWORD PTR _con1$[ebp], OFFSET _nullcon
$LN25@compare_ve@2:

; 1077 :   con2 = get_e_constraint_map(eb);

	mov	ebx, DWORD PTR _web+216
	cmp	DWORD PTR [ebx+eax+1048], 0
	mov	edx, DWORD PTR _eb$[ebp]
	je	SHORT $LN26@compare_ve@2
	mov	ebx, DWORD PTR _web+124
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _web+216
	add	ecx, DWORD PTR [ebx+eax+1024]
	mov	DWORD PTR _con2$[ebp], ecx
	jmp	SHORT $LN27@compare_ve@2
$LN26@compare_ve@2:
	mov	DWORD PTR _con2$[ebp], OFFSET _nullcon
$LN27@compare_ve@2:

; 1078 : 
; 1079 :   bdry1 = get_vertex_boundary_num(va);

	mov	ecx, DWORD PTR _V_BOUNDARY_ATTR
	test	ecx, ecx
	je	SHORT $LN28@compare_ve@2
	imul	ecx, 240				; 000000f0H
	and	esi, 134217727				; 07ffffffH
	add	ecx, edi
	mov	edi, DWORD PTR _web+12
	mov	esi, DWORD PTR [edi+esi*4]
	mov	ecx, DWORD PTR [ecx+eax+64]
	mov	esi, DWORD PTR [esi+ecx]
	jmp	SHORT $LN29@compare_ve@2
$LN28@compare_ve@2:
	xor	esi, esi
$LN29@compare_ve@2:

; 1080 :   bdry2 = get_edge_boundary_num(eb);

	mov	ecx, DWORD PTR _E_BOUNDARY_ATTR
	test	ecx, ecx
	je	SHORT $LN30@compare_ve@2
	mov	edi, DWORD PTR _web+124
	imul	ecx, 240				; 000000f0H
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	add	ecx, ebx
	mov	eax, DWORD PTR [ecx+eax+64]
	mov	eax, DWORD PTR [edx+eax]
	jmp	SHORT $LN31@compare_ve@2
$LN30@compare_ve@2:
	xor	eax, eax
$LN31@compare_ve@2:

; 1081 : 
; 1082 :   /* check boundaries */
; 1083 :   if ( bdry1 )

	test	esi, esi
	je	SHORT $LN21@compare_ve@2

; 1084 :   { if ( bdry2 )

	test	eax, eax
	je	SHORT $LN20@compare_ve@2

; 1085 :     { if ( bdry1 == bdry2 ) 

	xor	ecx, ecx
	cmp	esi, eax
	setne	cl
	pop	edi
	pop	esi
	pop	ebx
	lea	eax, DWORD PTR [ecx-1]
	and	eax, 2

; 1118 : 
; 1119 : } // end compare_vertex_edge_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@compare_ve@2:

; 1086 :          return A_EQ_B;
; 1087 :       else return INCOMPARABLE;
; 1088 :     }
; 1089 :     else if ( con2[0] )

	mov	edx, DWORD PTR _con2$[ebp]
	mov	eax, DWORD PTR [edx]
	neg	eax
	sbb	eax, eax
	pop	edi
	and	eax, -3					; fffffffdH
	pop	esi
	add	eax, 3
	pop	ebx

; 1118 : 
; 1119 : } // end compare_vertex_edge_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@compare_ve@2:

; 1090 :       return INCOMPARABLE;
; 1091 :     else 
; 1092 :       return A_SUPER_B;
; 1093 :   }
; 1094 :   else if ( bdry2 )

	test	eax, eax
	je	SHORT $LN11@compare_ve@2

; 1095 :   { if ( con1[0] )

	mov	ecx, DWORD PTR _con1$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	pop	edi
	pop	esi
	sete	al
	pop	ebx

; 1118 : 
; 1119 : } // end compare_vertex_edge_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@compare_ve@2:

; 1096 :       return INCOMPARABLE;
; 1097 :     else
; 1098 :     return A_SUB_B;
; 1099 :   }
; 1100 :  
; 1101 :   /* check constraints */
; 1102 : 
; 1103 :   for ( i = 1 ; i <= (int)con2[0] ; i++ )

	mov	eax, DWORD PTR _con2$[ebp]
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR _con1$[ebp]
	mov	edx, 1
	mov	DWORD PTR tv276[ebp], ebx
	cmp	ebx, edx
	jl	SHORT $LN8@compare_ve@2
	mov	esi, DWORD PTR [edi]
	npad	2
$LL38@compare_ve@2:

; 1104 :   { for ( j = 1 ; j <= (int)con1[0] ; j++ )

	mov	eax, 1
	cmp	esi, eax
	jl	SHORT $LN9@compare_ve@2
	mov	ecx, DWORD PTR _con2$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	ecx, 1073741823				; 3fffffffH
$LL7@compare_ve@2:

; 1105 :       if ( (con1[j]&CONMASK) == (con2[i]&CONMASK) )

	mov	ebx, DWORD PTR [edi+eax*4]
	and	ebx, 1073741823				; 3fffffffH
	cmp	ebx, ecx
	je	SHORT $LN34@compare_ve@2

; 1104 :   { for ( j = 1 ; j <= (int)con1[0] ; j++ )

	inc	eax
	cmp	eax, esi
	jle	SHORT $LL7@compare_ve@2

; 1105 :       if ( (con1[j]&CONMASK) == (con2[i]&CONMASK) )

	jmp	SHORT $LN39@compare_ve@2
$LN34@compare_ve@2:

; 1106 :       { same++;

	inc	DWORD PTR _same$[ebp]
$LN39@compare_ve@2:
	mov	ebx, DWORD PTR tv276[ebp]
$LN9@compare_ve@2:

; 1096 :       return INCOMPARABLE;
; 1097 :     else
; 1098 :     return A_SUB_B;
; 1099 :   }
; 1100 :  
; 1101 :   /* check constraints */
; 1102 : 
; 1103 :   for ( i = 1 ; i <= (int)con2[0] ; i++ )

	inc	edx
	cmp	edx, ebx
	jle	SHORT $LL38@compare_ve@2
$LN8@compare_ve@2:

; 1107 :         break;
; 1108 :       }
; 1109 :   }
; 1110 : 
; 1111 :   if ( (same==(int)con1[0]) && (same==(int)con2[0]) )

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR _same$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN41@compare_ve@2
	cmp	eax, ebx
	jne	SHORT $LN3@compare_ve@2

; 1112 :     return A_EQ_B;

	pop	edi
	pop	esi
	mov	eax, 2
	pop	ebx

; 1118 : 
; 1119 : } // end compare_vertex_edge_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@compare_ve@2:

; 1113 :   if ( (same==(int)con1[0]) && (same < (int)con2[0]) )

	cmp	eax, ecx
	jne	SHORT $LN41@compare_ve@2
	cmp	eax, ebx
	jge	SHORT $LN2@compare_ve@2

; 1114 :     return A_SUB_B;

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 1118 : 
; 1119 : } // end compare_vertex_edge_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@compare_ve@2:

; 1115 :   if ( (same < (int)con1[0]) && (same==(int)con2[0]) )

	cmp	eax, ecx
$LN41@compare_ve@2:
	jge	SHORT $LN1@compare_ve@2
	cmp	eax, ebx
	jne	SHORT $LN1@compare_ve@2

; 1116 :     return A_SUPER_B;

	pop	edi
	pop	esi
	mov	eax, 3
	pop	ebx

; 1118 : 
; 1119 : } // end compare_vertex_edge_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@compare_ve@2:
	pop	edi
	pop	esi

; 1117 :   return INCOMPARABLE;

	xor	eax, eax
	pop	ebx

; 1118 : 
; 1119 : } // end compare_vertex_edge_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
_compare_vertex_edge_attr ENDP
_TEXT	ENDS
PUBLIC	_compare_edge_attr
; Function compile flags: /Ogtp
;	COMDAT _compare_edge_attr
_TEXT	SEGMENT
_fixb$ = -12						; size = 4
_fixa$ = -8						; size = 4
tv301 = -4						; size = 4
_con2$ = 8						; size = 4
_ea$ = 8						; size = 4
_same$ = 12						; size = 4
_eb$ = 12						; size = 4
_compare_edge_attr PROC					; COMDAT

; 1134 : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1135 :   int fixa = get_eattr(ea) & FIXED;

	mov	ecx, DWORD PTR _ea$[ebp]
	mov	eax, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 64					; 00000040H
	mov	DWORD PTR _fixa$[ebp], edx

; 1136 :   int fixb = get_eattr(eb) & FIXED;

	mov	edx, DWORD PTR _eb$[ebp]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edx+8]
	push	ebx
	push	esi

; 1137 :   conmap_t * con1,*con2;
; 1138 :   int bdry1,bdry2;
; 1139 :   int same = 0;
; 1140 : 
; 1141 :   con1 = get_e_constraint_map(ea);

	mov	esi, DWORD PTR _web+216
	and	eax, 64					; 00000040H
	push	edi
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR _fixb$[ebp], eax
	mov	eax, DWORD PTR [esi+edi+1048]
	mov	DWORD PTR _same$[ebp], 0
	test	eax, eax
	je	SHORT $LN24@compare_ed
	mov	ebx, DWORD PTR [esi+edi+1024]
	add	ebx, ecx
	jmp	SHORT $LN25@compare_ed
$LN24@compare_ed:
	mov	ebx, OFFSET _nullcon
$LN25@compare_ed:

; 1142 :   con2 = get_e_constraint_map(eb);

	test	eax, eax
	je	SHORT $LN26@compare_ed
	mov	eax, DWORD PTR [esi+edi+1024]
	add	eax, edx
	mov	DWORD PTR _con2$[ebp], eax
	jmp	SHORT $LN27@compare_ed
$LN26@compare_ed:
	mov	DWORD PTR _con2$[ebp], OFFSET _nullcon
$LN27@compare_ed:

; 1143 : 
; 1144 :   bdry1 = get_edge_boundary_num(ea);

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN40@compare_ed
	imul	eax, 240				; 000000f0H
	add	eax, esi
	mov	eax, DWORD PTR [eax+edi+64]
	mov	ecx, DWORD PTR [eax+ecx]

; 1145 :   bdry2 = get_edge_boundary_num(eb);

	mov	eax, DWORD PTR [eax+edx]

; 1146 : 
; 1147 :   /* check boundaries */
; 1148 :   if ( bdry1 )

	test	ecx, ecx
	je	SHORT $LN21@compare_ed

; 1149 :   { if ( bdry2 )

	test	eax, eax
	je	SHORT $LN20@compare_ed

; 1150 :     { if ( bdry1 == bdry2 ) 

	xor	edx, edx
	cmp	ecx, eax
	setne	dl
	pop	edi
	pop	esi
	pop	ebx
	lea	eax, DWORD PTR [edx-1]
	and	eax, 2

; 1183 : } // end compare_edge_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@compare_ed:

; 1151 :          return A_EQ_B;
; 1152 :       else return INCOMPARABLE;
; 1153 :     }
; 1154 :     else if ( con2[0] )

	mov	eax, DWORD PTR _con2$[ebp]
	mov	eax, DWORD PTR [eax]
	neg	eax
	sbb	eax, eax
	pop	edi
	and	eax, -3					; fffffffdH
	pop	esi
	add	eax, 3
	pop	ebx

; 1183 : } // end compare_edge_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@compare_ed:

; 1155 :       return INCOMPARABLE;
; 1156 :     else 
; 1157 :       return A_SUPER_B;
; 1158 :   }
; 1159 :   else if ( bdry2 )

	test	eax, eax
	je	SHORT $LN40@compare_ed

; 1160 :   { if ( con1[0] )

	xor	eax, eax
	cmp	DWORD PTR [ebx], eax
	pop	edi
	pop	esi
	sete	al
	pop	ebx

; 1183 : } // end compare_edge_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@compare_ed:

; 1161 :       return INCOMPARABLE;
; 1162 :     else
; 1163 :       return A_SUB_B;
; 1164 :   }
; 1165 :  
; 1166 :   /* check constraints */
; 1167 : 
; 1168 :   for ( i = 1 ; i <= (int)con2[0] ; i++ )

	mov	ecx, DWORD PTR _con2$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, 1
	mov	DWORD PTR tv301[ebp], ecx
	cmp	ecx, edx
	jl	SHORT $LN37@compare_ed
	mov	esi, DWORD PTR [ebx]
$LL41@compare_ed:

; 1169 :   { for ( j = 1 ; j <= (int)con1[0] ; j++ ) 

	mov	eax, 1
	cmp	esi, eax
	jl	SHORT $LN9@compare_ed
	mov	ecx, DWORD PTR _con2$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	ecx, 1073741823				; 3fffffffH
	npad	10
$LL7@compare_ed:

; 1170 :       if ( (con1[j]&CONMASK) == (con2[i]&CONMASK) )

	mov	edi, DWORD PTR [ebx+eax*4]
	and	edi, 1073741823				; 3fffffffH
	cmp	edi, ecx
	je	SHORT $LN34@compare_ed

; 1169 :   { for ( j = 1 ; j <= (int)con1[0] ; j++ ) 

	inc	eax
	cmp	eax, esi
	jle	SHORT $LL7@compare_ed

; 1170 :       if ( (con1[j]&CONMASK) == (con2[i]&CONMASK) )

	jmp	SHORT $LN43@compare_ed
$LN34@compare_ed:

; 1171 :       { same++;

	inc	DWORD PTR _same$[ebp]
$LN43@compare_ed:
	mov	ecx, DWORD PTR tv301[ebp]
$LN9@compare_ed:

; 1161 :       return INCOMPARABLE;
; 1162 :     else
; 1163 :       return A_SUB_B;
; 1164 :   }
; 1165 :  
; 1166 :   /* check constraints */
; 1167 : 
; 1168 :   for ( i = 1 ; i <= (int)con2[0] ; i++ )

	inc	edx
	cmp	edx, ecx
	jle	SHORT $LL41@compare_ed
$LN37@compare_ed:

; 1172 :         break;
; 1173 :       }
; 1174 :   }
; 1175 : 
; 1176 :   if ( (same==(int)con1[0]) && (same==(int)con2[0]) && !fixa && !fixb )

	mov	ebx, DWORD PTR [ebx]
	mov	eax, DWORD PTR _same$[ebp]
	cmp	eax, ebx
	jne	SHORT $LN45@compare_ed
	cmp	eax, ecx
	jne	SHORT $LN38@compare_ed
	cmp	DWORD PTR _fixa$[ebp], 0
	jne	SHORT $LN38@compare_ed
	cmp	DWORD PTR _fixb$[ebp], 0
	jne	SHORT $LN38@compare_ed

; 1177 :     return A_EQ_B;

	pop	edi
	pop	esi
	mov	eax, 2
	pop	ebx

; 1183 : } // end compare_edge_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@compare_ed:

; 1178 :   if ( (same==(int)con1[0]) && (same < (int)con2[0]) && !fixa )

	cmp	eax, ebx
	jne	SHORT $LN45@compare_ed
	cmp	eax, ecx
	jge	SHORT $LN42@compare_ed
	cmp	DWORD PTR _fixa$[ebp], 0
	jne	SHORT $LN42@compare_ed

; 1179 :     return A_SUB_B;

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 1183 : } // end compare_edge_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@compare_ed:

; 1180 :   if ( (same < (int)con1[0]) && (same==(int)con2[0]) && !fixb )

	cmp	eax, ebx
$LN45@compare_ed:
	jge	SHORT $LN1@compare_ed
	cmp	eax, ecx
	jne	SHORT $LN1@compare_ed
	cmp	DWORD PTR _fixb$[ebp], 0
	jne	SHORT $LN1@compare_ed

; 1181 :     return A_SUPER_B;

	pop	edi
	pop	esi
	mov	eax, 3
	pop	ebx

; 1183 : } // end compare_edge_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@compare_ed:
	pop	edi
	pop	esi

; 1182 :   return INCOMPARABLE;

	xor	eax, eax
	pop	ebx

; 1183 : } // end compare_edge_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
_compare_edge_attr ENDP
_TEXT	ENDS
PUBLIC	_compare_edge_facet_attr
EXTRN	_F_BOUNDARY_ATTR:DWORD
; Function compile flags: /Ogtp
;	COMDAT _compare_edge_facet_attr
_TEXT	SEGMENT
_fixb$ = -16						; size = 4
_fixa$ = -12						; size = 4
tv316 = -8						; size = 4
_same$ = -4						; size = 4
_con2$ = 8						; size = 4
_ea$ = 8						; size = 4
_con1$ = 12						; size = 4
_fb$ = 12						; size = 4
_compare_edge_facet_attr PROC				; COMDAT

; 1199 : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1200 :   conmap_t * con1,*con2;
; 1201 :   int fixa = get_eattr(ea) & FIXED;

	mov	eax, DWORD PTR _ea$[ebp]
	mov	ecx, DWORD PTR _web+124

; 1202 :   int fixb = get_fattr(fb) & FIXED;

	mov	edx, DWORD PTR _fb$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 64					; 00000040H
	mov	DWORD PTR _fixa$[ebp], eax
	mov	eax, DWORD PTR _web+236
	push	ebx
	and	edx, 134217727				; 07ffffffH
	push	esi
	mov	esi, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 64					; 00000040H
	push	edi

; 1203 :   int same = 0;
; 1204 :   int bdry1,bdry2;
; 1205 : 
; 1206 :   con1 = get_e_constraint_map(ea);

	mov	edi, DWORD PTR _web+216
	mov	DWORD PTR _fixb$[ebp], eax
	mov	eax, DWORD PTR _dymem
	cmp	DWORD PTR [edi+eax+1048], 0
	mov	DWORD PTR _same$[ebp], 0
	je	SHORT $LN24@compare_ed@2
	mov	edx, DWORD PTR [edi+eax+1024]
	add	edx, ecx
	mov	DWORD PTR _con1$[ebp], edx
	jmp	SHORT $LN25@compare_ed@2
$LN24@compare_ed@2:
	mov	DWORD PTR _con1$[ebp], OFFSET _nullcon
$LN25@compare_ed@2:

; 1207 :   con2 = get_f_constraint_map(fb);

	mov	ebx, DWORD PTR _web+328
	cmp	DWORD PTR [ebx+eax+88], 0
	je	SHORT $LN26@compare_ed@2
	mov	edx, DWORD PTR [ebx+eax+64]
	add	edx, esi
	mov	DWORD PTR _con2$[ebp], edx
	jmp	SHORT $LN27@compare_ed@2
$LN26@compare_ed@2:
	mov	DWORD PTR _con2$[ebp], OFFSET _nullcon
$LN27@compare_ed@2:

; 1208 : 
; 1209 :   bdry1 = get_edge_boundary_num(ea);

	mov	edx, DWORD PTR _E_BOUNDARY_ATTR
	test	edx, edx
	je	SHORT $LN28@compare_ed@2
	imul	edx, 240				; 000000f0H
	add	edx, edi
	mov	edx, DWORD PTR [edx+eax+64]
	mov	ecx, DWORD PTR [ecx+edx]
	jmp	SHORT $LN29@compare_ed@2
$LN28@compare_ed@2:
	xor	ecx, ecx
$LN29@compare_ed@2:

; 1210 :   bdry2 = get_facet_boundary_num(fb);

	mov	edx, DWORD PTR _F_BOUNDARY_ATTR
	test	edx, edx
	je	SHORT $LN30@compare_ed@2
	imul	edx, 240				; 000000f0H
	add	edx, ebx
	mov	eax, DWORD PTR [edx+eax+64]
	mov	esi, DWORD PTR [esi+eax]
	jmp	SHORT $LN31@compare_ed@2
$LN30@compare_ed@2:
	xor	esi, esi
$LN31@compare_ed@2:

; 1211 : 
; 1212 :   /* check boundaries */
; 1213 :   if ( bdry1 )

	test	ecx, ecx
	je	SHORT $LN21@compare_ed@2

; 1214 :   { if ( bdry2 )

	test	esi, esi
	je	SHORT $LN20@compare_ed@2

; 1215 :     { if ( bdry1 == bdry2 ) 

	xor	eax, eax
	cmp	ecx, esi
	setne	al
	pop	edi
	pop	esi
	pop	ebx
	dec	eax
	and	eax, 2

; 1247 : 
; 1248 : } // end compare_edge_facet_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@compare_ed@2:

; 1216 :          return A_EQ_B;
; 1217 :       else return INCOMPARABLE;
; 1218 :     }
; 1219 :     else if ( con2[0] )

	mov	ecx, DWORD PTR _con2$[ebp]
	mov	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	pop	edi
	and	eax, -3					; fffffffdH
	pop	esi
	add	eax, 3
	pop	ebx

; 1247 : 
; 1248 : } // end compare_edge_facet_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@compare_ed@2:

; 1220 :       return INCOMPARABLE;
; 1221 :     else 
; 1222 :       return A_SUPER_B;
; 1223 :   }
; 1224 :   else if ( bdry2 )

	test	esi, esi
	je	SHORT $LN11@compare_ed@2

; 1225 :   { if ( con1[0] )

	mov	edx, DWORD PTR _con1$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx], eax
	pop	edi
	pop	esi
	sete	al
	pop	ebx

; 1247 : 
; 1248 : } // end compare_edge_facet_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@compare_ed@2:

; 1226 :       return INCOMPARABLE;
; 1227 :     else
; 1228 :     return A_SUB_B;
; 1229 :   }
; 1230 :  
; 1231 :   /* check constraints */
; 1232 :   for ( i = 1 ; i <= (int)con2[0] ; i++ )

	mov	eax, DWORD PTR _con2$[ebp]
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR _con1$[ebp]
	mov	edx, 1
	mov	DWORD PTR tv316[ebp], ebx
	cmp	ebx, edx
	jl	SHORT $LN8@compare_ed@2
	mov	esi, DWORD PTR [edi]
$LL40@compare_ed@2:

; 1233 :   { for ( j = 1 ; j <= (int)con1[0] ; j++ )

	mov	eax, 1
	cmp	esi, eax
	jl	SHORT $LN9@compare_ed@2
	mov	ecx, DWORD PTR _con2$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	ecx, 1073741823				; 3fffffffH
	npad	9
$LL7@compare_ed@2:

; 1234 :       if ( (con1[j]&CONMASK) == (con2[i]&CONMASK) )

	mov	ebx, DWORD PTR [edi+eax*4]
	and	ebx, 1073741823				; 3fffffffH
	cmp	ebx, ecx
	je	SHORT $LN34@compare_ed@2

; 1233 :   { for ( j = 1 ; j <= (int)con1[0] ; j++ )

	inc	eax
	cmp	eax, esi
	jle	SHORT $LL7@compare_ed@2

; 1234 :       if ( (con1[j]&CONMASK) == (con2[i]&CONMASK) )

	jmp	SHORT $LN42@compare_ed@2
$LN34@compare_ed@2:

; 1235 :       { same++;

	inc	DWORD PTR _same$[ebp]
$LN42@compare_ed@2:
	mov	ebx, DWORD PTR tv316[ebp]
$LN9@compare_ed@2:

; 1226 :       return INCOMPARABLE;
; 1227 :     else
; 1228 :     return A_SUB_B;
; 1229 :   }
; 1230 :  
; 1231 :   /* check constraints */
; 1232 :   for ( i = 1 ; i <= (int)con2[0] ; i++ )

	inc	edx
	cmp	edx, ebx
	jle	SHORT $LL40@compare_ed@2
$LN8@compare_ed@2:

; 1236 :         break;
; 1237 :       }
; 1238 :   }
; 1239 : 
; 1240 :   if ( (same==(int)con1[0]) && (same==(int)con2[0])&& !fixa && !fixb )

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR _same$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN44@compare_ed@2
	cmp	eax, ebx
	jne	SHORT $LN38@compare_ed@2
	cmp	DWORD PTR _fixa$[ebp], 0
	jne	SHORT $LN38@compare_ed@2
	cmp	DWORD PTR _fixb$[ebp], 0
	jne	SHORT $LN38@compare_ed@2

; 1241 :     return A_EQ_B;

	pop	edi
	pop	esi
	mov	eax, 2
	pop	ebx

; 1247 : 
; 1248 : } // end compare_edge_facet_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@compare_ed@2:

; 1242 :   if ( (same==(int)con1[0]) && (same < (int)con2[0]) && !fixa )

	cmp	eax, ecx
	jne	SHORT $LN44@compare_ed@2
	cmp	eax, ebx
	jge	SHORT $LN41@compare_ed@2
	cmp	DWORD PTR _fixa$[ebp], 0
	jne	SHORT $LN41@compare_ed@2

; 1243 :     return A_SUB_B;

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 1247 : 
; 1248 : } // end compare_edge_facet_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@compare_ed@2:

; 1244 :   if ( (same < (int)con1[0]) && (same==(int)con2[0]) && !fixb )

	cmp	eax, ecx
$LN44@compare_ed@2:
	jge	SHORT $LN1@compare_ed@2
	cmp	eax, ebx
	jne	SHORT $LN1@compare_ed@2
	cmp	DWORD PTR _fixb$[ebp], 0
	jne	SHORT $LN1@compare_ed@2

; 1245 :     return A_SUPER_B;

	pop	edi
	pop	esi
	mov	eax, 3
	pop	ebx

; 1247 : 
; 1248 : } // end compare_edge_facet_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@compare_ed@2:
	pop	edi
	pop	esi

; 1246 :   return INCOMPARABLE;

	xor	eax, eax
	pop	ebx

; 1247 : 
; 1248 : } // end compare_edge_facet_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
_compare_edge_facet_attr ENDP
_TEXT	ENDS
PUBLIC	_equal_constr
; Function compile flags: /Ogtp
;	COMDAT _equal_constr
_TEXT	SEGMENT
_i$ = 8							; size = 4
_id1$ = 8						; size = 4
_id2$ = 12						; size = 4
_equal_constr PROC					; COMDAT

; 1262 : { int i,j;

	push	ebp
	mov	ebp, esp

; 1263 :   conmap_t * con1=NULL,*con2=NULL;
; 1264 : 
; 1265 :   switch ( id_type(id1) )

	mov	ecx, DWORD PTR _id1$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _web+104
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	eax, ecx
	push	edi
	xor	edx, edx
	shr	eax, 29					; 0000001dH
	xor	edi, edi
	sub	eax, edx
	je	SHORT $LN17@equal_cons
	dec	eax
	je	SHORT $LN16@equal_cons
	dec	eax
	jne	SHORT $LN23@equal_cons

; 1274 : 
; 1275 :         case FACET : 
; 1276 :                          con1        = get_f_constraint_map(id1);

	mov	eax, DWORD PTR _web+328
	cmp	DWORD PTR [eax+esi+88], edx
	je	SHORT $LN22@equal_cons
	mov	edi, DWORD PTR _web+236
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+ecx*4]
	add	edi, DWORD PTR [eax+esi+64]

; 1277 :                          break;

	jmp	SHORT $LN23@equal_cons
$LN16@equal_cons:

; 1269 :                          break;
; 1270 : 
; 1271 :         case EDGE  : 
; 1272 :                          con1        = get_e_constraint_map(id1);

	mov	eax, DWORD PTR _web+216
	cmp	DWORD PTR [eax+esi+1048], edx
	je	SHORT $LN22@equal_cons
	mov	edi, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+ecx*4]
	add	edi, DWORD PTR [eax+esi+1024]

; 1273 :                          break;

	jmp	SHORT $LN23@equal_cons
$LN17@equal_cons:

; 1266 :      {
; 1267 :         case VERTEX: 
; 1268 :                          con1        = get_v_constraint_map(id1);

	cmp	DWORD PTR [ebx+esi+1288], edx
	je	SHORT $LN22@equal_cons
	mov	eax, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+ecx*4]
	add	edi, DWORD PTR [ebx+esi+1264]
	jmp	SHORT $LN23@equal_cons
$LN22@equal_cons:
	mov	edi, OFFSET _nullcon
$LN23@equal_cons:

; 1278 :      }
; 1279 : 
; 1280 : 
; 1281 :   switch ( id_type(id2) )

	mov	eax, DWORD PTR _id2$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	sub	ecx, edx
	je	SHORT $LN12@equal_cons
	dec	ecx
	je	SHORT $LN11@equal_cons
	dec	ecx
	jne	SHORT $LN29@equal_cons

; 1290 : 
; 1291 :         case FACET :
; 1292 :                          con2        = get_f_constraint_map(id2);

	mov	ecx, DWORD PTR _web+328
	cmp	DWORD PTR [ecx+esi+88], edx
	je	SHORT $LN28@equal_cons
	mov	edx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	add	edx, DWORD PTR [ecx+esi+64]

; 1293 :                          break;

	jmp	SHORT $LN29@equal_cons
$LN11@equal_cons:

; 1285 :                          break;
; 1286 : 
; 1287 :         case EDGE  :
; 1288 :                          con2        = get_e_constraint_map(id2);

	mov	ecx, DWORD PTR _web+216
	cmp	DWORD PTR [ecx+esi+1048], edx
	je	SHORT $LN28@equal_cons
	mov	edx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	add	edx, DWORD PTR [ecx+esi+1024]

; 1289 :                          break;

	jmp	SHORT $LN29@equal_cons
$LN12@equal_cons:

; 1282 :      {
; 1283 :         case VERTEX: 
; 1284 :                          con2        = get_v_constraint_map(id2);

	cmp	DWORD PTR [ebx+esi+1288], edx
	je	SHORT $LN28@equal_cons
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	add	edx, DWORD PTR [ebx+esi+1264]
	jmp	SHORT $LN29@equal_cons
$LN28@equal_cons:
	mov	edx, OFFSET _nullcon
$LN29@equal_cons:

; 1294 :      }
; 1295 :   if ( con2[0] != con1[0] ) return 0;

	mov	esi, DWORD PTR [edx]
	mov	eax, DWORD PTR [edi]
	cmp	esi, eax
	je	SHORT $LN9@equal_cons
$LN37@equal_cons:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1302 : } // end equal_constr()

	pop	ebp
	ret	0
$LN9@equal_cons:

; 1296 :   for ( i = 1 ; i <= (int)con1[0] ; i++ )

	mov	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	eax, ecx
	jl	SHORT $LN6@equal_cons
	npad	5
$LL8@equal_cons:

; 1297 :   { for ( j = 1 ; j <= (int)con2[0] ; j++ )

	mov	eax, 1
	cmp	esi, eax
	jl	SHORT $LN40@equal_cons
	mov	ecx, DWORD PTR [edi+ecx*4]
	and	ecx, 1073741823				; 3fffffffH
$LL5@equal_cons:

; 1298 :         if ( (con1[i]&CONMASK) == (con2[j]&CONMASK) ) break;

	mov	ebx, DWORD PTR [edx+eax*4]
	and	ebx, 1073741823				; 3fffffffH
	cmp	ecx, ebx
	je	SHORT $LN40@equal_cons

; 1297 :   { for ( j = 1 ; j <= (int)con2[0] ; j++ )

	inc	eax
	cmp	eax, esi
	jle	SHORT $LL5@equal_cons
$LN40@equal_cons:

; 1299 :      if ( j > (int)con2[0] ) return 0;

	cmp	eax, esi
	jg	SHORT $LN37@equal_cons

; 1296 :   for ( i = 1 ; i <= (int)con1[0] ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, DWORD PTR [edi]
	jle	SHORT $LL8@equal_cons
$LN6@equal_cons:
	pop	edi
	pop	esi

; 1300 :   }
; 1301 :   return 1;

	mov	eax, 1
	pop	ebx

; 1302 : } // end equal_constr()

	pop	ebp
	ret	0
_equal_constr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@LOKKOLMO@skeleton?4c?$AA@		; `string'
PUBLIC	_expand_attribute
EXTRN	_parallel_update_flag:BYTE
EXTRN	_temp_free:PROC
EXTRN	_kb_memmove:PROC
EXTRN	_generate_all:PROC
EXTRN	_expand:PROC
EXTRN	_kb_temp_calloc:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0L@LOKKOLMO@skeleton?4c?$AA@
CONST	SEGMENT
??_C@_0L@LOKKOLMO@skeleton?4c?$AA@ DB 'skeleton.c', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _expand_attribute
_TEXT	SEGMENT
tv1277 = -68						; size = 4
_sentinel$90163 = -68					; size = 4
tv1086 = -64						; size = 4
_sentinel$90205 = -64					; size = 4
tv295 = -60						; size = 4
_old$90211 = -60					; size = 4
_old$90172 = -60					; size = 4
tv365 = -56						; size = 4
_chunksize$ = -56					; size = 4
_available$ = -56					; size = 4
tv1291 = -52						; size = 4
tv1193 = -52						; size = 4
tv1100 = -52						; size = 4
tv704 = -48						; size = 4
_dsize$ = -44						; size = 4
tv644 = -40						; size = 4
tv640 = -36						; size = 4
tv1001 = -32						; size = 4
_offset$ = -32						; size = 4
_pointercount$ = -32					; size = 4
_needed$ = -28						; size = 4
_newsize$ = -24						; size = 4
_temp$ = -20						; size = 4
_n$ = -16						; size = 4
_diff$ = -12						; size = 4
_ex$ = -8						; size = 4
_id$ = -4						; size = 4
_e_type$ = 8						; size = 4
_dest$ = 12						; size = 4
_attr_num$ = 12						; size = 4
_newsizes$ = 16						; size = 4
_expand_attribute PROC					; COMDAT

; 1444 : { int newsize;  

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 1445 :   int diff;  /* difference between old and new total sizes */
; 1446 :   struct extra *ex;
; 1447 :   int chunksize,offset,available,needed;
; 1448 :   int pointercount=0;
; 1449 :   char *spot;
; 1450 :   element_id id;
; 1451 :   int k,d,n,dsize,dest,inx,blocksize;
; 1452 :   char *temp=NULL; /* for shuffling higher dim entries */
; 1453 : 
; 1454 :   ex = EXTRAS(e_type) + attr_num;

	mov	eax, DWORD PTR _attr_num$[ebp]
	push	ebx
	imul	eax, 240				; 000000f0H
	push	esi
	push	edi
	mov	edi, DWORD PTR _e_type$[ebp]
	imul	edi, 112				; 00000070H
	mov	ebx, DWORD PTR _web[edi+104]
	add	ebx, eax
	add	ebx, DWORD PTR _dymem
	xor	ecx, ecx

; 1455 : 
; 1456 : #ifdef MPI_EVOLVER
; 1457 :   if ( (this_task == MASTER_TASK) && !mpi_initialization_flag )
; 1458 :   { struct mpi_command message;
; 1459 :     int i;
; 1460 :     message.cmd = mpi_EXPAND_ATTRIBUTE;
; 1461 :     message.i = attr_num;
; 1462 :     message.type = e_type;
; 1463 :     message.count = ex->array_spec.dim;
; 1464 : 	if ( ex->array_spec.dim )
; 1465 :       for (i = 0 ; i < ex->array_spec.dim ; i++ )
; 1466 :         message.data[i] = newsizes[i];
; 1467 : 	else message.data[0] = newsizes[0];
; 1468 :     MPI_Bcast(&message,sizeof(struct mpi_command),MPI_BYTE,MASTER_TASK,
; 1469 :         MPI_COMM_WORLD);
; 1470 :   }
; 1471 : #endif
; 1472 : 
; 1473 :   dsize = ex->array_spec.itemsize;
; 1474 : 
; 1475 :   if ( ex->array_spec.dim == 0 ) newsize = newsizes[0];

	mov	edx, DWORD PTR [ebx+76]
	mov	DWORD PTR tv644[ebp], eax
	mov	eax, DWORD PTR [ebx+84]
	mov	DWORD PTR _pointercount$[ebp], ecx
	mov	DWORD PTR _temp$[ebp], ecx
	mov	DWORD PTR tv640[ebp], edi
	mov	DWORD PTR _ex$[ebp], ebx
	mov	DWORD PTR _dsize$[ebp], eax
	cmp	edx, ecx
	jne	SHORT $LN64@expand_att
	mov	ecx, DWORD PTR _newsizes$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _newsize$[ebp], eax

; 1476 :   else

	jmp	SHORT $LN60@expand_att
$LN64@expand_att:

; 1477 :   { pointercount = 1;
; 1478 :     for ( newsize = 1, k = 0 ; k < ex->array_spec.dim ; k++ )

	xor	eax, eax
	mov	DWORD PTR _pointercount$[ebp], 1
	mov	DWORD PTR _newsize$[ebp], 1
	cmp	edx, ecx
	jle	SHORT $LN60@expand_att
$LL107@expand_att:

; 1479 :     { newsize *= newsizes[k];

	mov	ecx, DWORD PTR _newsizes$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	esi, ecx
	imul	esi, DWORD PTR _newsize$[ebp]
	mov	DWORD PTR _newsize$[ebp], esi

; 1480 :       if ( k < ex->array_spec.dim - 1 )

	lea	esi, DWORD PTR [edx-1]
	cmp	eax, esi
	jge	SHORT $LN61@expand_att

; 1481 :         pointercount *= newsizes[k];

	imul	ecx, DWORD PTR _pointercount$[ebp]
	mov	DWORD PTR _pointercount$[ebp], ecx
$LN61@expand_att:

; 1477 :   { pointercount = 1;
; 1478 :     for ( newsize = 1, k = 0 ; k < ex->array_spec.dim ; k++ )

	inc	eax
	cmp	eax, edx
	jl	SHORT $LL107@expand_att
$LN60@expand_att:

; 1482 :     }
; 1483 :   }
; 1484 :   
; 1485 : 
; 1486 :   if ( (ex->array_spec.dim <= 1) && (newsize == ex->array_spec.datacount) ) 

	cmp	edx, 1
	jg	SHORT $LN58@expand_att
	mov	eax, DWORD PTR _newsize$[ebp]
	cmp	eax, DWORD PTR [ebx+88]
	je	$LN65@expand_att
$LN58@expand_att:

; 1487 :      return;
; 1488 : 
; 1489 :   /* expand or contract space */
; 1490 :   /* see how much extra space is needed */
; 1491 :   if ( attr_num < web.skel[e_type].extra_count-1 )

	mov	ecx, DWORD PTR _web[edi+108]
	dec	ecx
	cmp	DWORD PTR _attr_num$[ebp], ecx
	jge	SHORT $LN57@expand_att

; 1492 :          available = ex[1].offset - ex[0].offset;

	mov	esi, DWORD PTR [ebx+304]
	jmp	SHORT $LN109@expand_att
$LN57@expand_att:

; 1493 :   else available = web.sizes[e_type] - ex->offset;

	mov	eax, DWORD PTR _e_type$[ebp]
	mov	esi, DWORD PTR _web[eax*4+560]
$LN109@expand_att:

; 1494 :   needed = newsize*datatype_size[ex->type]+pointercount*sizeof(REAL*);

	mov	ecx, DWORD PTR [ebx+68]
	mov	eax, DWORD PTR _datatype_size[ecx*4]
	imul	eax, DWORD PTR _newsize$[ebp]
	sub	esi, DWORD PTR [ebx+64]
	mov	ecx, DWORD PTR _pointercount$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _available$[ebp], esi
	mov	DWORD PTR _needed$[ebp], eax

; 1495 :   if ( ex->array_spec.dim >= 2 ) 

	cmp	edx, 2
	jl	SHORT $LN108@expand_att

; 1496 :      temp = (char*)temp_calloc(needed,1);

	push	1496					; 000005d8H
	push	OFFSET ??_C@_0L@LOKKOLMO@skeleton?4c?$AA@
	mov	edx, eax
	push	1
	push	edx
	call	_kb_temp_calloc
	mov	DWORD PTR _temp$[ebp], eax
	mov	eax, DWORD PTR _needed$[ebp]
	add	esp, 16					; 00000010H
$LN108@expand_att:

; 1497 :   if ( needed > available )

	cmp	eax, esi
	jle	$LN110@expand_att

; 1501 :     for ( k = attr_num+1 ; k < web.skel[e_type].extra_count ; k++ )

	mov	ecx, DWORD PTR _attr_num$[ebp]
	mov	esi, eax
	sub	esi, DWORD PTR _available$[ebp]
	mov	eax, DWORD PTR _web[edi+108]
	inc	ecx
	mov	DWORD PTR _diff$[ebp], esi
	mov	DWORD PTR tv704[ebp], ecx
	cmp	ecx, eax
	jge	SHORT $LN51@expand_att

; 1498 :   { /* expand */
; 1499 :     /* check alignment of following fields */
; 1500 :     diff = needed - available;

	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web[edi+104]
	sub	eax, DWORD PTR tv704[ebp]
	lea	ecx, DWORD PTR [ecx+edx+68]
	mov	DWORD PTR tv1001[ebp], ecx
	mov	DWORD PTR tv365[ebp], eax
$LL53@expand_att:

; 1502 :       while ( diff % datatype_size[EXTRAS(e_type)[k].type] )

	mov	edx, DWORD PTR tv1001[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _datatype_size[eax*4]
	mov	eax, esi
	cdq
	idiv	ecx
	test	edx, edx
	je	SHORT $LN52@expand_att
$LL50@expand_att:

; 1503 :         diff++;

	inc	esi
	mov	eax, esi
	cdq
	idiv	ecx
	test	edx, edx
	jne	SHORT $LL50@expand_att
$LN52@expand_att:

; 1501 :     for ( k = attr_num+1 ; k < web.skel[e_type].extra_count ; k++ )

	add	DWORD PTR tv1001[ebp], 240		; 000000f0H
	dec	DWORD PTR tv365[ebp]
	jne	SHORT $LL53@expand_att

; 1503 :         diff++;

	mov	DWORD PTR _diff$[ebp], esi
$LN51@expand_att:

; 1504 :     expand(e_type,web.sizes[e_type] + diff); 

	mov	eax, DWORD PTR _e_type$[ebp]
	mov	ecx, DWORD PTR _web[eax*4+560]
	add	ecx, esi
	push	ecx
	push	eax
	call	_expand

; 1505 :     /* move stuff above */
; 1506 :     if ( attr_num < web.skel[e_type].extra_count-1 )

	mov	edx, DWORD PTR _web[edi+108]
	dec	edx
	add	esp, 8
	cmp	DWORD PTR _attr_num$[ebp], edx
	jge	SHORT $LN48@expand_att

; 1507 :       offset = EXTRAS(e_type)[attr_num+1].offset;

	mov	eax, DWORD PTR _web[edi+104]
	add	eax, DWORD PTR tv644[ebp]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	jmp	SHORT $LN111@expand_att
$LN48@expand_att:

; 1508 :     else offset = web.sizes[e_type] - diff;

	mov	edx, DWORD PTR _e_type$[ebp]
	mov	eax, DWORD PTR _web[edx*4+560]
	sub	eax, esi
$LN111@expand_att:

; 1509 :     chunksize = web.sizes[e_type] - offset - diff;

	mov	ecx, DWORD PTR _e_type$[ebp]
	mov	ecx, DWORD PTR _web[ecx*4+560]
	sub	ecx, eax
	sub	ecx, esi
	mov	DWORD PTR _offset$[ebp], eax
	mov	DWORD PTR _chunksize$[ebp], ecx

; 1510 :     if ( chunksize || ( ex->array_spec.dim >= 2) )

	jne	SHORT $LN45@expand_att
	cmp	DWORD PTR [ebx+76], 2
	jl	$LN96@expand_att
$LN45@expand_att:

; 1511 :     { element_id sentinel;
; 1512 :       id = NULLID; 
; 1513 :       if ( web.skel[e_type].count > 0 ) 

	cmp	DWORD PTR _web[edi+64], 0
	mov	DWORD PTR _id$[ebp], 0
	jle	$LN96@expand_att

; 1514 :         while ( generate_all(e_type,&id,&sentinel) )

	mov	ecx, DWORD PTR _e_type$[ebp]
	lea	edx, DWORD PTR _sentinel$90163[ebp]
	push	edx
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	push	ecx
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN96@expand_att
$LL43@expand_att:

; 1515 :         { 
; 1516 :           spot = (char*)elptr(id) + offset;

	mov	eax, DWORD PTR _id$[ebp]

; 1517 :           kb_memmove(spot + diff,spot,chunksize);

	mov	edi, DWORD PTR _diff$[ebp]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	mov	edx, DWORD PTR _chunksize$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]
	add	esi, DWORD PTR _offset$[ebp]
	push	edx
	lea	eax, DWORD PTR [esi+edi]
	push	esi
	push	eax
	call	_kb_memmove
	add	esp, 12					; 0000000cH

; 1518 :           if ( ex->array_spec.dim >= 2 )

	cmp	DWORD PTR [ebx+76], 2
	jl	$LN41@expand_att

; 1519 :           { /* entry shuffle via temp */
; 1520 :             char *old = (char*)elptr(id) + EXTRAS(e_type)[attr_num].offset;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR tv640[ebp]
	mov	ecx, DWORD PTR _web[ecx+104]
	add	ecx, DWORD PTR tv644[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+64]

; 1521 :             for ( n = 0 ; n < ex->array_spec.datacount ; n++ )

	cmp	DWORD PTR [ebx+88], 0
	mov	DWORD PTR _old$90172[ebp], eax
	mov	DWORD PTR _n$[ebp], 0
	jle	SHORT $LN38@expand_att

; 1519 :           { /* entry shuffle via temp */
; 1520 :             char *old = (char*)elptr(id) + EXTRAS(e_type)[attr_num].offset;

	mov	DWORD PTR tv1100[ebp], eax
$LL40@expand_att:

; 1524 :               for ( d = ex->array_spec.dim-1, dest = 0, blocksize = 1 ; d >= 0 ; d-- )

	mov	esi, DWORD PTR [ebx+76]
	dec	esi
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, 0
	mov	DWORD PTR _dest$[ebp], ecx
	lea	edi, DWORD PTR [ecx+1]
	js	SHORT $LN103@expand_att

; 1522 :             { /* figure out indices and new spot */
; 1523 :               int oldinx = n;

	mov	ecx, DWORD PTR _ex$[ebp]
	lea	ebx, DWORD PTR [ecx+esi*4+96]
	npad	3
$LL37@expand_att:

; 1525 :               { inx = oldinx % ex->array_spec.sizes[d];

	cdq
	idiv	DWORD PTR [ebx]
	mov	DWORD PTR tv1086[ebp], eax

; 1526 :                 if ( inx >= newsizes[d] ) goto skipentry; 

	mov	eax, DWORD PTR _newsizes$[ebp]
	mov	ecx, DWORD PTR [eax+esi*4]
	cmp	edx, ecx
	jge	SHORT $LN101@expand_att

; 1527 :                 dest += blocksize*inx;
; 1528 :                 blocksize *= newsizes[d];
; 1529 :                 oldinx = oldinx/ex->array_spec.sizes[d];

	mov	eax, DWORD PTR tv1086[ebp]
	imul	edx, edi
	imul	edi, ecx
	add	DWORD PTR _dest$[ebp], edx
	sub	ebx, 4
	dec	esi
	jns	SHORT $LL37@expand_att

; 1524 :               for ( d = ex->array_spec.dim-1, dest = 0, blocksize = 1 ; d >= 0 ; d-- )

	mov	ebx, DWORD PTR _ex$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
$LN103@expand_att:

; 1530 :               }
; 1531 :               kb_memmove(temp+dest*dsize,old+n*dsize,dsize);

	mov	eax, DWORD PTR _dsize$[ebp]
	mov	edx, DWORD PTR tv1100[ebp]
	imul	ecx, eax
	add	ecx, DWORD PTR _temp$[ebp]
	push	eax
	push	edx
	push	ecx
	call	_kb_memmove
	add	esp, 12					; 0000000cH
	jmp	SHORT $skipentry$90185
$LN101@expand_att:
	mov	ebx, DWORD PTR _ex$[ebp]
$skipentry$90185:

; 1521 :             for ( n = 0 ; n < ex->array_spec.datacount ; n++ )

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _dsize$[ebp]
	add	DWORD PTR tv1100[ebp], ecx
	inc	eax
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, DWORD PTR [ebx+88]
	jl	SHORT $LL40@expand_att
$LN38@expand_att:

; 1532 : skipentry:    ;
; 1533 :             }
; 1534 :             kb_memmove(old,temp,needed);

	mov	edx, DWORD PTR _needed$[ebp]
	mov	eax, DWORD PTR _temp$[ebp]
	mov	ecx, DWORD PTR _old$90172[ebp]
	push	edx
	push	eax
	push	ecx
	call	_kb_memmove

; 1535 :           }
; 1536 :           else

	jmp	SHORT $LN112@expand_att
$LN41@expand_att:

; 1537 :             memset(spot,0,diff);

	push	edi
	push	0
	push	esi
	call	_memset
$LN112@expand_att:
	mov	ecx, DWORD PTR _e_type$[ebp]
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR _sentinel$90163[ebp]
	push	edx
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	push	ecx
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LL43@expand_att

; 1514 :         while ( generate_all(e_type,&id,&sentinel) )

	mov	edi, DWORD PTR tv640[ebp]
$LN96@expand_att:

; 1538 :         }
; 1539 :     }
; 1540 :     for ( k = attr_num+1 ; k < web.skel[e_type].extra_count ; k++ )

	mov	ecx, DWORD PTR tv704[ebp]
	cmp	ecx, DWORD PTR _web[edi+108]
	jge	$LN104@expand_att
	mov	esi, DWORD PTR tv640[ebp]
	mov	edi, DWORD PTR _diff$[ebp]
	mov	edx, ecx
	imul	edx, 240				; 000000f0H
$LL97@expand_att:

; 1541 :          EXTRAS(e_type)[k].offset += diff;

	mov	eax, DWORD PTR _web[esi+104]
	mov	ebx, DWORD PTR _dymem
	add	eax, edx
	add	DWORD PTR [eax+ebx+64], edi
	lea	eax, DWORD PTR [eax+ebx+64]
	inc	ecx
	add	edx, 240				; 000000f0H
	cmp	ecx, DWORD PTR _web[esi+108]
	jl	SHORT $LL97@expand_att

; 1542 :   }
; 1543 :   else if ( needed < available )

	jmp	$LN113@expand_att
$LN110@expand_att:
	jge	$LN104@expand_att

; 1547 :      for ( k = attr_num+1 ; k < web.skel[e_type].extra_count ; k++ )

	mov	eax, DWORD PTR _attr_num$[ebp]
	sub	esi, DWORD PTR _needed$[ebp]
	inc	eax
	mov	DWORD PTR _diff$[ebp], esi
	mov	DWORD PTR tv704[ebp], eax
	cmp	eax, DWORD PTR _web[edi+108]
	jge	SHORT $LN25@expand_att

; 1544 :   { /* maybe shrink */
; 1545 :      /* check alignment of following fields */
; 1546 :      diff = available - needed;

	mov	edx, DWORD PTR _dymem
	mov	ecx, eax
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web[edi+104]
	lea	ecx, DWORD PTR [ecx+edx+68]
	mov	DWORD PTR tv1193[ebp], ecx
	mov	ecx, DWORD PTR _web[edi+108]
	sub	ecx, eax
	mov	DWORD PTR tv295[ebp], ecx
	npad	4
$LL27@expand_att:

; 1548 :         while ( diff % datatype_size[EXTRAS(e_type)[k].type] )

	mov	edx, DWORD PTR tv1193[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _datatype_size[eax*4]
	mov	eax, esi
	cdq
	idiv	ecx
	test	edx, edx
	je	SHORT $LN26@expand_att
$LL24@expand_att:

; 1549 :           diff--;

	dec	esi
	mov	eax, esi
	cdq
	idiv	ecx
	test	edx, edx
	jne	SHORT $LL24@expand_att
$LN26@expand_att:

; 1547 :      for ( k = attr_num+1 ; k < web.skel[e_type].extra_count ; k++ )

	add	DWORD PTR tv1193[ebp], 240		; 000000f0H
	dec	DWORD PTR tv295[ebp]
	jne	SHORT $LL27@expand_att

; 1549 :           diff--;

	mov	DWORD PTR _diff$[ebp], esi
$LN25@expand_att:

; 1550 :      /* move stuff above */
; 1551 :      if ( attr_num < web.skel[e_type].extra_count-1 )

	mov	eax, DWORD PTR _web[edi+108]
	dec	eax
	cmp	DWORD PTR _attr_num$[ebp], eax
	jge	SHORT $LN22@expand_att

; 1552 :        offset = EXTRAS(e_type)[attr_num+1].offset;

	mov	ecx, DWORD PTR _web[edi+104]
	add	ecx, DWORD PTR tv644[ebp]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+304]
	jmp	SHORT $LN114@expand_att
$LN22@expand_att:

; 1553 :      else offset = web.sizes[e_type];

	mov	eax, DWORD PTR _e_type$[ebp]
	mov	ecx, DWORD PTR _web[eax*4+560]
$LN114@expand_att:

; 1554 :      chunksize = web.sizes[e_type] - offset;

	mov	edx, DWORD PTR _e_type$[ebp]
	mov	eax, DWORD PTR _web[edx*4+560]
	sub	eax, ecx
	mov	DWORD PTR _offset$[ebp], ecx
	mov	DWORD PTR _chunksize$[ebp], eax

; 1555 :      if ( chunksize || (ex->array_spec.dim >= 2) )

	jne	SHORT $LN19@expand_att
	cmp	DWORD PTR [ebx+76], 2
	jl	$LN98@expand_att
$LN19@expand_att:

; 1556 :      { element_id sentinel;
; 1557 :        id = NULLID;
; 1558 :        if ( web.skel[e_type].count > 0 ) 

	cmp	DWORD PTR _web[edi+64], 0
	mov	DWORD PTR _id$[ebp], 0
	jle	$LN98@expand_att

; 1559 :         while ( generate_all(e_type,&id,&sentinel) )

	lea	eax, DWORD PTR _sentinel$90205[ebp]
	push	eax
	lea	ecx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN98@expand_att
	npad	9
$LL17@expand_att:

; 1560 :         {
; 1561 :           if ( ex->array_spec.dim >= 2 )

	cmp	DWORD PTR [ebx+76], 2
	jl	$LN15@expand_att

; 1562 :           { /* entry shuffle via temp */
; 1563 :             char *old = (char*)elptr(id)+EXTRAS(e_type)[attr_num].offset;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _web[edi+104]
	add	ecx, DWORD PTR tv644[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+64]

; 1564 :             for ( n = 0 ; n < ex->array_spec.datacount ; n++ )

	cmp	DWORD PTR [ebx+88], 0
	mov	DWORD PTR _old$90211[ebp], eax
	mov	DWORD PTR _n$[ebp], 0
	jle	$LN12@expand_att

; 1562 :           { /* entry shuffle via temp */
; 1563 :             char *old = (char*)elptr(id)+EXTRAS(e_type)[attr_num].offset;

	mov	DWORD PTR tv1291[ebp], eax
	npad	3
$LL14@expand_att:

; 1567 :               for ( d = ex->array_spec.dim-1, dest = 0, blocksize = 1 ; d >= 0 ; d-- )

	mov	ecx, DWORD PTR _ex$[ebp]
	mov	esi, DWORD PTR [ecx+76]
	dec	esi
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, 0
	mov	DWORD PTR _dest$[ebp], ecx
	lea	edi, DWORD PTR [ecx+1]
	js	SHORT $LN102@expand_att

; 1565 :             { /* figure out indices and new spot */
; 1566 :               int oldinx = n;

	mov	edx, DWORD PTR _ex$[ebp]
	lea	ebx, DWORD PTR [edx+esi*4+96]
	npad	2
$LL11@expand_att:

; 1568 :               { inx = oldinx % ex->array_spec.sizes[d];

	cdq
	idiv	DWORD PTR [ebx]
	mov	DWORD PTR tv1277[ebp], eax

; 1569 :                 if ( inx >= newsizes[d] ) goto skipentry2; 

	mov	eax, DWORD PTR _newsizes$[ebp]
	mov	ecx, DWORD PTR [eax+esi*4]
	cmp	edx, ecx
	jge	SHORT $skipentry2$90224

; 1570 :                 dest += blocksize*inx;
; 1571 :                 blocksize *= newsizes[d];
; 1572 :                 oldinx = oldinx/ex->array_spec.sizes[d];

	mov	eax, DWORD PTR tv1277[ebp]
	imul	edx, edi
	imul	edi, ecx
	add	DWORD PTR _dest$[ebp], edx
	sub	ebx, 4
	dec	esi
	jns	SHORT $LL11@expand_att

; 1567 :               for ( d = ex->array_spec.dim-1, dest = 0, blocksize = 1 ; d >= 0 ; d-- )

	mov	ecx, DWORD PTR _dest$[ebp]
$LN102@expand_att:

; 1573 :               }
; 1574 :               kb_memmove(temp+dest*dsize,old+n*dsize,dsize);

	mov	eax, DWORD PTR _dsize$[ebp]
	mov	edx, DWORD PTR tv1291[ebp]
	imul	ecx, eax
	add	ecx, DWORD PTR _temp$[ebp]
	push	eax
	push	edx
	push	ecx
	call	_kb_memmove
	add	esp, 12					; 0000000cH
$skipentry2$90224:

; 1564 :             for ( n = 0 ; n < ex->array_spec.datacount ; n++ )

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _dsize$[ebp]
	mov	edx, DWORD PTR _ex$[ebp]
	add	DWORD PTR tv1291[ebp], ecx
	inc	eax
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, DWORD PTR [edx+88]
	jl	SHORT $LL14@expand_att
$LN12@expand_att:

; 1575 : skipentry2:    ;
; 1576 :             }
; 1577 :             kb_memmove(old,temp,needed);

	mov	eax, DWORD PTR _needed$[ebp]
	mov	ecx, DWORD PTR _temp$[ebp]
	mov	edx, DWORD PTR _old$90211[ebp]
	push	eax
	push	ecx
	push	edx
	call	_kb_memmove
	mov	ebx, DWORD PTR _ex$[ebp]
	mov	edi, DWORD PTR tv640[ebp]
	mov	esi, DWORD PTR _diff$[ebp]
	add	esp, 12					; 0000000cH
$LN15@expand_att:

; 1578 :           }
; 1579 :           spot = (char*)elptr(id) + offset;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]

; 1580 :           kb_memmove(spot - diff,spot,chunksize);

	mov	ecx, DWORD PTR _chunksize$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, DWORD PTR _offset$[ebp]
	push	ecx
	push	eax
	sub	eax, esi
	push	eax
	call	_kb_memmove
	mov	ecx, DWORD PTR _e_type$[ebp]
	lea	edx, DWORD PTR _sentinel$90205[ebp]
	push	edx
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	push	ecx
	call	_generate_all
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	$LL17@expand_att
$LN98@expand_att:

; 1581 :         }
; 1582 :      }
; 1583 :      for ( k = attr_num+1 ; k < web.skel[e_type].extra_count ; k++ )

	mov	ecx, DWORD PTR tv704[ebp]
	cmp	ecx, DWORD PTR _web[edi+108]
	jge	SHORT $LN5@expand_att
	mov	edi, DWORD PTR _diff$[ebp]
	mov	esi, DWORD PTR tv640[ebp]
	mov	edx, ecx
	imul	edx, 240				; 000000f0H
	npad	4
$LL99@expand_att:

; 1584 :          EXTRAS(e_type)[k].offset -= diff;

	mov	eax, DWORD PTR _web[esi+104]
	mov	ebx, DWORD PTR _dymem
	add	eax, edx
	sub	DWORD PTR [eax+ebx+64], edi
	lea	eax, DWORD PTR [eax+ebx+64]
	inc	ecx
	add	edx, 240				; 000000f0H
	cmp	ecx, DWORD PTR _web[esi+108]
	jl	SHORT $LL99@expand_att
$LN5@expand_att:

; 1585 :      expand(e_type,web.sizes[e_type] - diff); 

	mov	eax, DWORD PTR _e_type$[ebp]
	mov	ecx, DWORD PTR _web[eax*4+560]
	sub	ecx, DWORD PTR _diff$[ebp]
	push	ecx
	push	eax
	call	_expand
	add	esp, 8
$LN113@expand_att:
	mov	ebx, DWORD PTR _ex$[ebp]
$LN104@expand_att:

; 1586 :   }
; 1587 :   if ( ex->array_spec.dim >= 2 ) temp_free(temp);

	cmp	DWORD PTR [ebx+76], 2
	jl	SHORT $LN4@expand_att
	mov	edx, DWORD PTR _temp$[ebp]
	push	edx
	call	_temp_free
	add	esp, 4
$LN4@expand_att:

; 1588 :   ex->array_spec.datacount = newsize;

	mov	eax, DWORD PTR _newsize$[ebp]
	mov	DWORD PTR [ebx+88], eax

; 1589 :   for ( n = 0 ; n < ex->array_spec.dim ; n++ )

	xor	eax, eax
	cmp	DWORD PTR [ebx+76], eax
	jle	SHORT $LN105@expand_att

; 1588 :   ex->array_spec.datacount = newsize;

	mov	edx, DWORD PTR _newsizes$[ebp]
	lea	ecx, DWORD PTR [ebx+96]
$LL3@expand_att:

; 1590 :     ex->array_spec.sizes[n] = newsizes[n];

	mov	esi, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], esi
	inc	eax
	add	ecx, 4
	cmp	eax, DWORD PTR [ebx+76]
	jl	SHORT $LL3@expand_att
$LN105@expand_att:

; 1591 :   parallel_update_flag[e_type] = 1;

	mov	ecx, DWORD PTR _e_type$[ebp]
	mov	DWORD PTR _parallel_update_flag[ecx*4], 1
$LN65@expand_att:
	pop	edi
	pop	esi
	pop	ebx

; 1592 : 
; 1593 : #ifdef MPI_EVOLVER
; 1594 :   mpi_export_voffset = EXTRAS(VERTEX)[web.mpi_export_attr[VERTEX]].offset;
; 1595 :   mpi_export_eoffset = EXTRAS(EDGE)[web.mpi_export_attr[EDGE]].offset;
; 1596 :   mpi_export_foffset = EXTRAS(FACET)[web.mpi_export_attr[FACET]].offset;
; 1597 :   mpi_export_boffset = EXTRAS(BODY)[web.mpi_export_attr[BODY]].offset;
; 1598 :   mpi_export_feoffset =
; 1599 :           EXTRAS(FACETEDGE)[web.mpi_export_attr[FACETEDGE]].offset; 
; 1600 : #endif
; 1601 : } // end expand_attribute()

	mov	esp, ebp
	pop	ebp
	ret	0
_expand_attribute ENDP
_TEXT	ENDS
PUBLIC	_find_attribute
EXTRN	_kb_stricmp:PROC
; Function compile flags: /Ogtp
;	COMDAT _find_attribute
_TEXT	SEGMENT
_etype$ = 8						; size = 4
_name$ = 12						; size = 4
_find_attribute PROC					; COMDAT

; 1615 : { struct extra *ex;

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 1616 :   int n;
; 1617 :   ex = EXTRAS(etype);

	mov	esi, DWORD PTR _etype$[ebp]
	imul	esi, 112				; 00000070H
	push	edi
	mov	edi, DWORD PTR _web[esi+104]
	add	edi, DWORD PTR _dymem

; 1618 :   for ( n = 0 ; n < web.skel[etype].extra_count ; n++,ex++ )

	xor	ebx, ebx
	cmp	ebx, DWORD PTR _web[esi+108]
	jge	SHORT $LN11@find_attri
$LL5@find_attri:

; 1619 :     if ( stricmp(ex->name,name) == 0 ) break;

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	edi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@find_attri

; 1618 :   for ( n = 0 ; n < web.skel[etype].extra_count ; n++,ex++ )

	inc	ebx
	add	edi, 240				; 000000f0H
	cmp	ebx, DWORD PTR _web[esi+108]
	jl	SHORT $LL5@find_attri
$LN9@find_attri:

; 1620 :   if ( n == web.skel[etype].extra_count )

	cmp	ebx, DWORD PTR _web[esi+108]
$LN11@find_attri:
	jne	SHORT $LN1@find_attri

; 1621 :      return -1;

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx

; 1623 : } // end find_attribute()

	pop	ebp
	ret	0
$LN1@find_attri:
	pop	edi
	pop	esi

; 1622 :   return n;

	mov	eax, ebx
	pop	ebx

; 1623 : } // end find_attribute()

	pop	ebp
	ret	0
_find_attribute ENDP
_TEXT	ENDS
PUBLIC	_find_extra
; Function compile flags: /Ogtp
;	COMDAT _find_extra
_TEXT	SEGMENT
_qnum$ = -8						; size = 4
_el_type$ = -4						; size = 4
_name$ = 8						; size = 4
_etype$ = 12						; size = 4
_find_extra PROC					; COMDAT

; 1636 : { int el_type,qnum,n;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 1637 :   struct extra *ex;
; 1638 : 
; 1639 :   for ( el_type = VERTEX, qnum = -1 ; el_type <= FACETEDGE ; el_type++ )

	mov	DWORD PTR _el_type$[ebp], 0
	mov	DWORD PTR _qnum$[ebp], -1
	mov	ebx, OFFSET _web+108
	npad	4
$LL15@find_extra:

; 1640 :   { ex = EXTRAS(el_type);

	mov	esi, DWORD PTR [ebx-4]
	add	esi, DWORD PTR _dymem

; 1641 :     for ( n = 0 ; n < web.skel[el_type].extra_count ; n++,ex++ )

	xor	edi, edi
	cmp	DWORD PTR [ebx], edi
	jle	SHORT $LN6@find_extra
	npad	1
$LL4@find_extra:

; 1642 :       if ( stricmp(ex->name,name) == 0 )

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@find_extra

; 1641 :     for ( n = 0 ; n < web.skel[el_type].extra_count ; n++,ex++ )

	inc	edi
	add	esi, 240				; 000000f0H
	cmp	edi, DWORD PTR [ebx]
	jl	SHORT $LL4@find_extra

; 1642 :       if ( stricmp(ex->name,name) == 0 )

	jmp	SHORT $LN6@find_extra
$LN12@find_extra:

; 1643 :       {*etype = el_type;qnum = n;break;}

	mov	ecx, DWORD PTR _el_type$[ebp]
	mov	edx, DWORD PTR _etype$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR _qnum$[ebp], edi
$LN6@find_extra:

; 1637 :   struct extra *ex;
; 1638 : 
; 1639 :   for ( el_type = VERTEX, qnum = -1 ; el_type <= FACETEDGE ; el_type++ )

	inc	DWORD PTR _el_type$[ebp]
	add	ebx, 112				; 00000070H
	cmp	ebx, OFFSET _web+556
	jle	SHORT $LL15@find_extra

; 1644 :   }
; 1645 :   return qnum;

	mov	eax, DWORD PTR _qnum$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 1646 : } // end find_extra()

	mov	esp, ebp
	pop	ebp
	ret	0
_find_extra ENDP
_TEXT	ENDS
PUBLIC	_set_v_constraint_map
EXTRN	_attach_method_num:PROC
EXTRN	_create_body_constraint_content_method:PROC
; Function compile flags: /Ogtp
;	COMDAT _set_v_constraint_map
_TEXT	SEGMENT
_first_e$90377 = -32					; size = 4
tv803 = -28						; size = 4
_first_fe$90404 = -24					; size = 4
_e_id$90376 = -20					; size = 4
_newmax$90357 = -20					; size = 4
_four$ = -20						; size = 4
_min_rank$90379 = -16					; size = 4
_maxcon$ = -16						; size = 4
_max_rank$90378 = -12					; size = 4
_fe$90405 = -8						; size = 4
_constr$ = -4						; size = 4
_v_id$ = 8						; size = 4
_n$ = 12						; size = 4
_set_v_constraint_map PROC				; COMDAT

; 1734 : { conmap_t *map;

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1735 :   int maxcon = EXTRAS(VERTEX)[V_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	ecx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [ecx+eax+1288]
	push	ebx
	push	esi
	push	edi

; 1736 :   struct constraint *constr;
; 1737 :   int k,j;
; 1738 :   int four = 4;
; 1739 : 
; 1740 :   n &= CONMASK;

	mov	edi, DWORD PTR _n$[ebp]
	and	edi, 1073741823				; 3fffffffH
	mov	DWORD PTR _maxcon$[ebp], edx
	mov	DWORD PTR _four$[ebp], 4
	mov	DWORD PTR _n$[ebp], edi

; 1741 :   if ( maxcon == 0 )

	test	edx, edx
	jne	SHORT $LN32@set_v_cons

; 1742 :      expand_attribute(VERTEX,V_CONSTR_LIST_ATTR,&four);

	lea	eax, DWORD PTR _four$[ebp]
	push	eax
	push	5
	push	edx
	call	_expand_attribute
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	add	esp, 12					; 0000000cH
$LN32@set_v_cons:

; 1743 :   map = get_v_constraint_map(v_id);

	cmp	DWORD PTR [ecx+eax+1288], 0
	je	SHORT $LN35@set_v_cons
	mov	edx, DWORD PTR _v_id$[ebp]
	mov	esi, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+edx*4]
	add	esi, DWORD PTR [ecx+eax+1264]
	jmp	SHORT $LN36@set_v_cons
$LN35@set_v_cons:
	mov	esi, OFFSET _nullcon
$LN36@set_v_cons:
	mov	ecx, DWORD PTR [esi]

; 1744 :   for ( k = 1; k <= (int)*map ; k++ )

	mov	ebx, 1
	cmp	ecx, ebx
	jl	SHORT $LN29@set_v_cons
	mov	eax, edi
	and	eax, 1073741823				; 3fffffffH
	npad	5
$LL31@set_v_cons:

; 1745 :      if ( (map[k] & CONMASK) == ((conmap_t)n & CONMASK) ) return;

	mov	edx, DWORD PTR [esi+ebx*4]
	and	edx, 1073741823				; 3fffffffH
	cmp	edx, eax
	je	$LN12@set_v_cons

; 1744 :   for ( k = 1; k <= (int)*map ; k++ )

	inc	ebx
	cmp	ebx, ecx
	jle	SHORT $LL31@set_v_cons
$LN29@set_v_cons:

; 1746 :   if ( k >= maxcon )

	mov	eax, DWORD PTR _maxcon$[ebp]
	cmp	ebx, eax
	jl	SHORT $LN38@set_v_cons

; 1747 :   { int newmax;
; 1748 :     newmax = maxcon+4;

	add	eax, 4
	mov	DWORD PTR _newmax$90357[ebp], eax

; 1749 :     expand_attribute(VERTEX,V_CONSTR_LIST_ATTR,&newmax);

	lea	eax, DWORD PTR _newmax$90357[ebp]
	push	eax
	push	5
	push	0
	call	_expand_attribute

; 1750 :     map = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [eax+ecx+1288], 0
	je	SHORT $LN37@set_v_cons
	mov	edx, DWORD PTR _v_id$[ebp]
	mov	esi, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+edx*4]
	add	esi, DWORD PTR [eax+ecx+1264]
	jmp	SHORT $LN38@set_v_cons
$LN37@set_v_cons:
	mov	esi, OFFSET _nullcon
$LN38@set_v_cons:

; 1751 :   }  
; 1752 :   constr = get_constraint(n);

	mov	eax, edi
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 1753 :   map[k] = (conmap_t)n; 

	mov	DWORD PTR [esi+ebx*4], edi
	mov	DWORD PTR _constr$[ebp], eax

; 1754 :   if ( !(constr->attr & (NONPOSITIVE|NONNEGATIVE) )) 

	mov	eax, DWORD PTR [eax+32]
	and	eax, 3
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN81@set_v_cons

; 1755 :     map[k] |= CON_HIT_BIT;

	or	edi, -2147483648			; 80000000H
	mov	DWORD PTR [esi+ebx*4], edi
$LN81@set_v_cons:

; 1756 :   map[0]++; /* counter */
; 1757 : 
; 1758 :   set_attr(v_id,CONSTRAINT);

	mov	edi, DWORD PTR _v_id$[ebp]
	mov	edx, DWORD PTR _v_id$[ebp]
	inc	DWORD PTR [esi]
	shr	edi, 29					; 0000001dH
	imul	edi, 112				; 00000070H
	mov	eax, DWORD PTR _web[edi+12]
	mov	ebx, edx
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	lea	edi, DWORD PTR _web[edi+12]
	add	ebx, ebx
	mov	eax, DWORD PTR [ebx+eax]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 1024			; 00000400H
	mov	DWORD PTR [eax+12], ecx

; 1759 :   if ( (constr->attr & CON_ENERGY) && (web.representation == STRING) )

	mov	eax, DWORD PTR _constr$[ebp]
	mov	eax, DWORD PTR [eax+32]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN82@set_v_cons
	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN82@set_v_cons

; 1760 :   { set_attr(v_id, BDRY_ENERGY);

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ebx+ecx]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 512			; 00000200H
	mov	DWORD PTR [eax+12], ecx

; 1761 :      if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN82@set_v_cons

; 1762 :         apply_method_num(v_id,constr->energy_method);

	mov	eax, DWORD PTR _constr$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	push	ecx
	push	edx
	call	_apply_method_num
	add	esp, 8
$LN82@set_v_cons:

; 1763 :   }
; 1764 :   if ( (constr->attr & CON_CONTENT) && (web.representation == STRING) )

	mov	edx, DWORD PTR _constr$[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN12@set_v_cons
	mov	ecx, 1
	cmp	DWORD PTR _web+624, ecx
	jne	$LN12@set_v_cons

; 1765 :   { 
; 1766 :     set_attr(v_id, BDRY_CONTENT);

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [ebx+eax]
	mov	edi, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 4096			; 00001000H
	mov	DWORD PTR [eax+12], edi

; 1767 : 
; 1768 :     if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN12@set_v_cons

; 1769 :     { edge_id e_id,first_e;
; 1770 :       int max_rank,min_rank;
; 1771 :         
; 1772 :       min_rank = MAXINT; max_rank = 0;

	mov	DWORD PTR _min_rank$90379[ebp], 2147483647 ; 7fffffffH
	mov	DWORD PTR _max_rank$90378[ebp], 0

; 1773 :       for ( j = 1 ; j <= (int)map[0] ; j++ )

	cmp	DWORD PTR [esi], ecx
	jl	SHORT $LN19@set_v_cons
	mov	edx, DWORD PTR [esi]
	mov	edi, DWORD PTR _web+652
$LL21@set_v_cons:

; 1774 :       { struct constraint *c;
; 1775 :         if ( !(map[j] & CON_HIT_BIT) ) continue;

	mov	eax, DWORD PTR [esi+ecx*4]
	test	eax, eax
	jns	SHORT $LN20@set_v_cons

; 1776 :         c = get_constraint(map[j]);

	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H

; 1777 :         if ( c->content_rank < min_rank ) min_rank = c->content_rank;

	mov	eax, DWORD PTR [eax+edi+172]
	cmp	eax, DWORD PTR _min_rank$90379[ebp]
	jge	SHORT $LN17@set_v_cons
	mov	DWORD PTR _min_rank$90379[ebp], eax
$LN17@set_v_cons:

; 1778 :         if ( c->content_rank > max_rank ) max_rank = c->content_rank;

	cmp	eax, DWORD PTR _max_rank$90378[ebp]
	jle	SHORT $LN20@set_v_cons
	mov	DWORD PTR _max_rank$90378[ebp], eax
$LN20@set_v_cons:

; 1773 :       for ( j = 1 ; j <= (int)map[0] ; j++ )

	inc	ecx
	cmp	ecx, edx
	jle	SHORT $LL21@set_v_cons
	mov	edx, DWORD PTR _constr$[ebp]
$LN19@set_v_cons:

; 1779 :       }
; 1780 : 
; 1781 :       first_e = e_id = get_vertex_edge(v_id);

	mov	ecx, DWORD PTR _web+12
	mov	eax, DWORD PTR [ebx+ecx]
	mov	ebx, DWORD PTR [eax+28]
	mov	DWORD PTR _e_id$90376[ebp], ebx
	mov	DWORD PTR _first_e$90377[ebp], ebx

; 1782 :       if ( valid_id(e_id) && !(get_eattr(e_id) & NONCONTENT) )

	test	ebx, 268435456				; 10000000H
	je	$LN12@set_v_cons
	mov	esi, DWORD PTR _web+124
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN12@set_v_cons
	mov	ecx, DWORD PTR _dymem
	mov	edi, DWORD PTR _web+328
	jmp	SHORT $LN14@set_v_cons
$LL79@set_v_cons:
	mov	ebx, DWORD PTR _e_id$90376[ebp]
$LN14@set_v_cons:

; 1783 :       do
; 1784 :       { 
; 1785 :        body_id b_id;
; 1786 :        facetedge_id first_fe,fe;
; 1787 :        first_fe = fe = get_edge_fe(e_id);

	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv803[ebp], eax
	mov	eax, DWORD PTR [eax+esi]
	test	eax, eax
	je	SHORT $LN47@set_v_cons
$LN46@set_v_cons:
	mov	eax, DWORD PTR [eax+28]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN45@set_v_cons
	xor	eax, 134217728				; 08000000H
$LN45@set_v_cons:
	mov	DWORD PTR _fe$90405[ebp], eax
$LN47@set_v_cons:
	mov	DWORD PTR _first_fe$90404[ebp], eax

; 1788 :        if ( valid_id(fe) )  do

	test	eax, 268435456				; 10000000H
	je	$LN8@set_v_cons
	jmp	SHORT $LN10@set_v_cons
	npad	4
$LL80@set_v_cons:
	mov	eax, DWORD PTR _fe$90405[ebp]
$LN10@set_v_cons:

; 1789 :        { facet_id f_id = get_fe_facet(fe);

	mov	esi, DWORD PTR _web+460
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN50@set_v_cons
	mov	ebx, DWORD PTR _NULLFACET
	jmp	SHORT $LN49@set_v_cons
$LN50@set_v_cons:
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [esi+ebx*4]
	mov	ebx, DWORD PTR [ebx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN54@set_v_cons
	xor	ebx, 134217728				; 08000000H
$LN49@set_v_cons:

; 1790 :          fe = get_next_facet(fe);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN54@set_v_cons
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN90@set_v_cons
$LN54@set_v_cons:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+40]
$LN90@set_v_cons:
	mov	DWORD PTR _fe$90405[ebp], eax

; 1791 :          if ( !valid_id(f_id) ) continue;

	test	ebx, 268435456				; 10000000H
	je	$LN9@set_v_cons

; 1792 :          b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN60@set_v_cons
	xor	esi, esi
	jmp	SHORT $LN57@set_v_cons
$LN60@set_v_cons:
	mov	esi, DWORD PTR _web+236
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR [edi+ecx+784]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN58@set_v_cons
	mov	esi, DWORD PTR [eax+esi+4]
	jmp	SHORT $LN57@set_v_cons
$LN58@set_v_cons:
	mov	esi, DWORD PTR [eax+esi]
$LN57@set_v_cons:

; 1793 :          
; 1794 :          if ( valid_id(b_id)  && 
; 1795 :            ( (!inverted(f_id) && constr->content_rank >= max_rank) 
; 1796 :                || (inverted(f_id) && constr->content_rank <= min_rank)))

	test	esi, 268435456				; 10000000H
	je	$LN85@set_v_cons
	mov	eax, ebx
	shr	eax, 27					; 0000001bH
	and	eax, 1
	jne	SHORT $LN4@set_v_cons
	mov	edi, DWORD PTR _max_rank$90378[ebp]
	cmp	DWORD PTR [edx+172], edi
	jge	SHORT $LN5@set_v_cons
	mov	edi, DWORD PTR _web+328
$LN4@set_v_cons:
	test	eax, eax
	je	SHORT $LN85@set_v_cons
	mov	eax, DWORD PTR _min_rank$90379[ebp]
	cmp	DWORD PTR [edx+172], eax
	jg	SHORT $LN85@set_v_cons
$LN5@set_v_cons:

; 1797 :          { int methnum;
; 1798 :            methnum = create_body_constraint_content_method(b_id,n);

	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	push	esi
	call	_create_body_constraint_content_method

; 1799 :            attach_method_num(get_body_volquant(b_id),methnum);

	mov	edx, DWORD PTR _web+348
	mov	edi, eax
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR [eax+404]
	push	edi
	push	ecx
	call	_attach_method_num

; 1800 :            apply_method_num(inverse_id(v_id),methnum);

	mov	edx, DWORD PTR _v_id$[ebp]
	xor	edx, 134217728				; 08000000H
	push	edi
	push	edx
	call	_apply_method_num
	mov	ecx, DWORD PTR _dymem
	mov	edi, DWORD PTR _web+328
	mov	edx, DWORD PTR _constr$[ebp]
	add	esp, 24					; 00000018H
$LN85@set_v_cons:

; 1801 :          }
; 1802 : 
; 1803 :          b_id = get_facet_body(inverse_id(f_id));         

	mov	eax, ebx
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN66@set_v_cons
	xor	esi, esi
	jmp	SHORT $LN63@set_v_cons
$LN66@set_v_cons:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN65@set_v_cons
	xor	esi, esi
	jmp	SHORT $LN63@set_v_cons
$LN65@set_v_cons:
	mov	esi, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN64@set_v_cons
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR [edi+ecx+784]
	mov	esi, DWORD PTR [eax+esi+4]
	jmp	SHORT $LN63@set_v_cons
$LN64@set_v_cons:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR [edi+ecx+784]
	mov	esi, DWORD PTR [eax+esi]
$LN63@set_v_cons:

; 1804 :          if ( valid_id(b_id) && 
; 1805 :               ( (!inverted(f_id) && constr->content_rank >= max_rank) 
; 1806 :                || (inverted(f_id) && constr->content_rank <= min_rank)) )

	test	esi, 268435456				; 10000000H
	je	SHORT $LN9@set_v_cons
	shr	ebx, 27					; 0000001bH
	and	ebx, 1
	jne	SHORT $LN1@set_v_cons
	mov	eax, DWORD PTR _max_rank$90378[ebp]
	cmp	DWORD PTR [edx+172], eax
	jge	SHORT $LN2@set_v_cons
$LN1@set_v_cons:
	test	ebx, ebx
	je	SHORT $LN9@set_v_cons
	mov	eax, DWORD PTR _min_rank$90379[ebp]
	cmp	DWORD PTR [edx+172], eax
	jg	SHORT $LN9@set_v_cons
$LN2@set_v_cons:

; 1807 :          { int methnum;
; 1808 :            methnum = create_body_constraint_content_method(b_id,n);

	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	push	esi
	call	_create_body_constraint_content_method

; 1809 :            attach_method_num(get_body_volquant(b_id),methnum);

	mov	edx, DWORD PTR _web+348
	mov	edi, eax
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR [eax+404]
	push	edi
	push	ecx
	call	_attach_method_num

; 1810 :            apply_method_num(v_id,methnum);

	mov	edx, DWORD PTR _v_id$[ebp]
	push	edi
	push	edx
	call	_apply_method_num
	mov	ecx, DWORD PTR _dymem
	mov	edi, DWORD PTR _web+328
	mov	edx, DWORD PTR _constr$[ebp]
	add	esp, 24					; 00000018H
$LN9@set_v_cons:

; 1811 :          }
; 1812 :        } while ( !equal_id(fe,first_fe) );

	mov	eax, DWORD PTR _fe$90405[ebp]
	cmp	eax, DWORD PTR _first_fe$90404[ebp]
	jne	$LL80@set_v_cons
	mov	esi, DWORD PTR _web+124
$LN8@set_v_cons:

; 1813 :        e_id = get_next_tail_edge(e_id);

	mov	eax, DWORD PTR _e_id$90376[ebp]
	mov	ebx, DWORD PTR tv803[ebp]
	mov	ebx, DWORD PTR [ebx+esi]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	eax, DWORD PTR [ebx+eax*4+32]
	mov	DWORD PTR _e_id$90376[ebp], eax

; 1814 :      } while ( !equal_id(first_e,e_id));

	cmp	DWORD PTR _first_e$90377[ebp], eax
	jne	$LL79@set_v_cons
$LN12@set_v_cons:
	pop	edi
	pop	esi
	pop	ebx

; 1815 :    }
; 1816 :   }
; 1817 : } // end set_v_constraint_map()

	mov	esp, ebp
	pop	ebp
	ret	0
_set_v_constraint_map ENDP
_TEXT	ENDS
PUBLIC	_unset_v_constraint_map
; Function compile flags: /Ogtp
;	COMDAT _unset_v_constraint_map
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_n$ = 12						; size = 4
_unset_v_constraint_map PROC				; COMDAT

; 1829 : { conmap_t *map;

	push	ebp
	mov	ebp, esp

; 1830 :   int maxcon = EXTRAS(VERTEX)[V_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	ecx, DWORD PTR _web+104

; 1831 :   int k,j;
; 1832 : 
; 1833 :   n &= CONMASK;

	and	DWORD PTR _n$[ebp], 1073741823		; 3fffffffH
	push	edi
	mov	edi, DWORD PTR _dymem

; 1834 :   if ( maxcon == 0 ) return;

	cmp	DWORD PTR [ecx+edi+1288], 0
	je	$LN2@unset_v_co

; 1835 :   map = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _web+12
	push	ebx
	push	esi
	mov	esi, DWORD PTR _v_id$[ebp]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	eax, DWORD PTR [edx+eax]
	add	eax, DWORD PTR [ecx+edi+1264]

; 1836 :   for ( k = 1; k <= (int)*map ; k++ )

	mov	ecx, 1
	mov	edi, DWORD PTR [eax]
	cmp	edi, ecx
	jl	SHORT $LN33@unset_v_co
$LL32@unset_v_co:

; 1837 :      if ( (map[k] & CONMASK) == (conmap_t)n ) break;

	mov	ebx, DWORD PTR [eax+ecx*4]
	and	ebx, 1073741823				; 3fffffffH
	cmp	ebx, DWORD PTR _n$[ebp]
	je	SHORT $LN33@unset_v_co

; 1836 :   for ( k = 1; k <= (int)*map ; k++ )

	inc	ecx
	cmp	ecx, edi
	jle	SHORT $LL32@unset_v_co
$LN33@unset_v_co:

; 1838 :   if ( k > (int)*map ) return;

	cmp	ecx, edi
	jg	$LN35@unset_v_co

; 1839 :   map[0]--;

	dec	edi
	mov	DWORD PTR [eax], edi

; 1840 :   for ( j = k ; j <= (int)*map ; j++ ) map[j] = map[j+1];

	cmp	ecx, edi
	jg	SHORT $LN7@unset_v_co
$LL9@unset_v_co:
	mov	edi, DWORD PTR [eax+ecx*4+4]
	mov	DWORD PTR [eax+ecx*4], edi
	inc	ecx
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LL9@unset_v_co
$LN7@unset_v_co:

; 1841 :   map[j] = 0;

	mov	DWORD PTR [eax+ecx*4], 0

; 1842 :   if ( map[0] == 0 ) unset_attr(v_id,CONSTRAINT);

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN20@unset_v_co
	mov	ecx, esi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	mov	eax, DWORD PTR [eax+edx]
	mov	ecx, DWORD PTR [eax+12]
	and	DWORD PTR [eax+8], -1025		; fffffbffH
	mov	DWORD PTR [eax+12], ecx
$LN20@unset_v_co:

; 1843 :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN35@unset_v_co

; 1844 :   { // delete energy and content methods
; 1845 :     int i;
; 1846 :     int meth_offset = get_meth_offset(VERTEX);
; 1847 :     struct vertex *vptr = (struct vertex *)elptr(v_id);

	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	eax, DWORD PTR _web[esi+12]
	mov	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR _web+5664

; 1848 :     int *instlist = (int*)((char*)vptr + meth_offset);

	mov	eax, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104

; 1849 :     for ( i = 0 ; i < vptr->method_count ; i++ )

	xor	esi, esi
	mov	edi, DWORD PTR [edx+eax+64]
	xor	edx, edx
	add	edi, ecx
	cmp	dx, WORD PTR [ecx+24]
	jae	SHORT $LN35@unset_v_co
	mov	ebx, DWORD PTR _n$[ebp]
	npad	6
$LL4@unset_v_co:

; 1850 :     { struct method_instance *mi = METH_INSTANCE(abs(instlist[i]));

	mov	eax, DWORD PTR [edi+esi*4]
	cdq
	xor	eax, edx
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 1851 :       if ( mi->connum == n )

	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	cmp	DWORD PTR [eax+edx+216], ebx
	jne	SHORT $LN3@unset_v_co

; 1852 :       { instlist[i] = instlist[--vptr->method_count];

	mov	eax, 65535				; 0000ffffH
	add	WORD PTR [ecx+24], ax
	movzx	edx, WORD PTR [ecx+24]
	mov	eax, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [edi+esi*4], eax

; 1853 :         i--;

	dec	esi
$LN3@unset_v_co:

; 1849 :     for ( i = 0 ; i < vptr->method_count ; i++ )

	movzx	edx, WORD PTR [ecx+24]
	inc	esi
	cmp	esi, edx
	jl	SHORT $LL4@unset_v_co
$LN35@unset_v_co:
	pop	esi
	pop	ebx
$LN2@unset_v_co:
	pop	edi

; 1854 :       }
; 1855 :     }
; 1856 :   }
; 1857 : } // end unset_v_constraint_map()

	pop	ebp
	ret	0
_unset_v_constraint_map ENDP
_TEXT	ENDS
PUBLIC	_unset_v_all_constraints
; Function compile flags: /Ogtp
;	COMDAT _unset_v_all_constraints
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_unset_v_all_constraints PROC				; COMDAT

; 1866 : { conmap_t *map;

	push	ebp
	mov	ebp, esp

; 1867 :   int maxcon = EXTRAS(VERTEX)[V_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem

; 1868 :   int i;
; 1869 : 
; 1870 :   if ( maxcon == 0 ) return;

	cmp	DWORD PTR [ecx+edx+1288], 0
	je	SHORT $LN9@unset_v_al

; 1871 :   map = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _v_id$[ebp]
	push	ebx
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	push	esi
	mov	esi, DWORD PTR _web+12
	add	ebx, ebx
	add	ebx, ebx
	push	edi
	mov	edi, DWORD PTR [ebx+esi]
	add	edi, DWORD PTR [ecx+edx+1264]

; 1872 : 
; 1873 :   for ( i = map[0] ; i >= 1 ; i-- )

	mov	esi, DWORD PTR [edi]
	cmp	esi, 1
	jl	SHORT $LN1@unset_v_al
$LL13@unset_v_al:

; 1874 :     unset_v_constraint_map(v_id,map[i]);

	mov	ecx, DWORD PTR [edi+esi*4]
	push	ecx
	push	eax
	call	_unset_v_constraint_map
	mov	eax, DWORD PTR _v_id$[ebp]
	dec	esi
	add	esp, 8
	cmp	esi, 1
	jge	SHORT $LL13@unset_v_al
$LN1@unset_v_al:

; 1875 : 
; 1876 :   unset_attr(v_id,CONSTRAINT);

	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	mov	ebx, DWORD PTR [edx+ebx]
	mov	eax, DWORD PTR [ebx+12]
	and	DWORD PTR [ebx+8], -1025		; fffffbffH
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+12], eax
	pop	ebx
$LN9@unset_v_al:

; 1877 : 
; 1878 : } // end unset_v_all_constraints()

	pop	ebp
	ret	0
_unset_v_all_constraints ENDP
_TEXT	ENDS
PUBLIC	_v_on_constraint
; Function compile flags: /Ogtp
;	COMDAT _v_on_constraint
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_n$ = 12						; size = 4
_v_on_constraint PROC					; COMDAT

; 1890 : { conmap_t *map;

	push	ebp
	mov	ebp, esp

; 1891 :   int maxcon = EXTRAS(VERTEX)[V_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	push	esi

; 1892 :   int k;
; 1893 : 
; 1894 :   n &= CONMASK;

	mov	esi, DWORD PTR _n$[ebp]
	and	esi, 1073741823				; 3fffffffH

; 1895 :   if ( maxcon == 0 ) return 0;

	cmp	DWORD PTR [ecx+edx+1288], 0
	jne	SHORT $LN5@v_on_const
	xor	eax, eax
	pop	esi

; 1902 : } // end v_on_constraint()

	pop	ebp
	ret	0
$LN5@v_on_const:

; 1896 :   map = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _v_id$[ebp]
	and	eax, 134217727				; 07ffffffH
	push	edi
	mov	edi, DWORD PTR _web+12
	mov	eax, DWORD PTR [edi+eax*4]
	add	eax, DWORD PTR [ecx+edx+1264]

; 1897 :   for ( k = 1; k <= (int)*map ; k++ )

	mov	ecx, 1
	mov	edx, DWORD PTR [eax]
	cmp	edx, ecx
	jl	SHORT $LN2@v_on_const
	npad	4
$LL4@v_on_const:

; 1898 :   { if ( (map[k] & CONMASK) == (conmap_t)n ) 

	mov	edi, DWORD PTR [eax+ecx*4]
	and	edi, 1073741823				; 3fffffffH
	cmp	edi, esi
	je	SHORT $LN11@v_on_const

; 1897 :   for ( k = 1; k <= (int)*map ; k++ )

	inc	ecx
	cmp	ecx, edx
	jle	SHORT $LL4@v_on_const
$LN2@v_on_const:
	pop	edi

; 1900 :   }
; 1901 :   return 0;

	xor	eax, eax
	pop	esi

; 1902 : } // end v_on_constraint()

	pop	ebp
	ret	0
$LN11@v_on_const:
	pop	edi

; 1899 :         return 1;

	mov	eax, 1
	pop	esi

; 1902 : } // end v_on_constraint()

	pop	ebp
	ret	0
_v_on_constraint ENDP
_TEXT	ENDS
PUBLIC	_v_hit_constraint_count
; Function compile flags: /Ogtp
;	COMDAT _v_hit_constraint_count
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_v_hit_constraint_count PROC				; COMDAT

; 1911 : { conmap_t *map;

	push	ebp
	mov	ebp, esp

; 1912 :   int maxcon = EXTRAS(VERTEX)[V_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	edx, DWORD PTR _web+104
	push	esi
	mov	esi, DWORD PTR _dymem

; 1913 :   int count = 0;

	xor	eax, eax

; 1914 :   int k;
; 1915 : 
; 1916 :   if ( maxcon == 0 ) return 0;

	cmp	DWORD PTR [edx+esi+1288], eax
	jne	SHORT $LN5@v_hit_cons
	pop	esi

; 1921 :   }
; 1922 :   return count;
; 1923 : } // end v_hit_constraint_count()

	pop	ebp
	ret	0
$LN5@v_hit_cons:

; 1917 :   map = get_v_constraint_map(v_id);

	mov	ecx, DWORD PTR _v_id$[ebp]
	push	edi
	mov	edi, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	add	ecx, DWORD PTR [edx+esi+1264]

; 1918 :   for ( k = 1; k <= (int)*map ; k++ )

	mov	edx, 1
	mov	esi, DWORD PTR [ecx]
	pop	edi
	cmp	esi, edx
	jl	SHORT $LN6@v_hit_cons
$LL4@v_hit_cons:

; 1919 :   { if ( (map[k] & CON_HIT_BIT) ) 

	test	DWORD PTR [ecx+edx*4], -2147483648	; 80000000H
	je	SHORT $LN3@v_hit_cons

; 1920 :       count++;

	inc	eax
$LN3@v_hit_cons:

; 1918 :   for ( k = 1; k <= (int)*map ; k++ )

	inc	edx
	cmp	edx, esi
	jle	SHORT $LL4@v_hit_cons
$LN6@v_hit_cons:
	pop	esi

; 1921 :   }
; 1922 :   return count;
; 1923 : } // end v_hit_constraint_count()

	pop	ebp
	ret	0
_v_hit_constraint_count ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@HBGBIEEA@Too?5many?5common?5constraints?5for?5@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	_get_v_common_conmap
EXTRN	_elnames:BYTE
;	COMDAT ??_C@_0DF@HBGBIEEA@Too?5many?5common?5constraints?5for?5@
CONST	SEGMENT
??_C@_0DF@HBGBIEEA@Too?5many?5common?5constraints?5for?5@ DB 'Too many co'
	DB	'mmon constraints for vertices %s and %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_v_common_conmap
_TEXT	SEGMENT
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_k$ = 16						; size = 4
_conmap$ = 16						; size = 4
_max$ = 20						; size = 4
_get_v_common_conmap PROC				; COMDAT

; 1937 : { conmap_t *map1 = get_v_constraint_map(v1);

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	cmp	DWORD PTR [eax+ecx+1288], 0
	push	ebx
	push	esi
	push	edi
	je	SHORT $LN8@get_v_comm
	mov	edx, DWORD PTR _v1$[ebp]
	mov	esi, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [esi+edx*4]
	add	ebx, DWORD PTR [eax+ecx+1264]
	jmp	SHORT $LN9@get_v_comm
$LN8@get_v_comm:
	mov	ebx, OFFSET _nullcon
$LN9@get_v_comm:

; 1938 :   unsigned int k;
; 1939 : 
; 1940 :   conmap[0] = 0;

	mov	esi, DWORD PTR _conmap$[ebp]

; 1941 :   for ( k = 1; k <= map1[0] ; k++ )

	mov	edi, 1
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR _k$[ebp], edi
	cmp	DWORD PTR [ebx], edi
	jb	$LN3@get_v_comm
$LL5@get_v_comm:

; 1942 :     if ( v_on_constraint(v2,map1[k]) )

	mov	eax, DWORD PTR [ebx+edi*4]
	mov	ecx, DWORD PTR _v2$[ebp]
	push	eax
	push	ecx
	call	_v_on_constraint
	add	esp, 8
	test	eax, eax
	je	$LN4@get_v_comm

; 1943 :     { if ( conmap[0] >= (unsigned)(max-1) )

	mov	edx, DWORD PTR _max$[ebp]
	dec	edx
	cmp	DWORD PTR [esi], edx
	jb	$LN1@get_v_comm

; 1944 :       { sprintf(errmsg,"Too many common constraints for vertices %s and %s.\n",
; 1945 :           ELNAME(v1),ELNAME2(v2));

	mov	eax, DWORD PTR _v2$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN10@get_v_comm
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	edi, OFFSET _elnames+60
	jmp	SHORT $LN11@get_v_comm
$LN10@get_v_comm:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN11@get_v_comm:
	mov	eax, DWORD PTR _v1$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN12@get_v_comm
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN13@get_v_comm
$LN12@get_v_comm:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN13@get_v_comm:
	push	edi
	push	eax
	push	OFFSET ??_C@_0DF@HBGBIEEA@Too?5many?5common?5constraints?5for?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1946 :         kb_error(5891,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5891					; 00001703H
	call	_kb_error
	mov	edi, DWORD PTR _k$[ebp]
	add	esp, 28					; 0000001cH
$LN1@get_v_comm:

; 1947 :       }
; 1948 :       conmap[++conmap[0]] = map1[k] & (conmap_t)CONMASK;

	inc	DWORD PTR [esi]
	mov	ecx, DWORD PTR [ebx+edi*4]
	mov	eax, DWORD PTR [esi]
	and	ecx, 1073741823				; 3fffffffH
	mov	DWORD PTR [esi+eax*4], ecx
$LN4@get_v_comm:

; 1941 :   for ( k = 1; k <= map1[0] ; k++ )

	inc	edi
	mov	DWORD PTR _k$[ebp], edi
	cmp	edi, DWORD PTR [ebx]
	jbe	$LL5@get_v_comm
$LN3@get_v_comm:
	pop	edi
	pop	esi
	pop	ebx

; 1949 :     }
; 1950 : } // end get_v_common_conmap()

	pop	ebp
	ret	0
_get_v_common_conmap ENDP
_TEXT	ENDS
PUBLIC	_get_v_constraint_status
; Function compile flags: /Ogtp
;	COMDAT _get_v_constraint_status
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_v_constraint_status PROC				; COMDAT

; 1961 : { conmap_t *map;

	push	ebp
	mov	ebp, esp

; 1962 :   int maxcon = EXTRAS(VERTEX)[V_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	push	esi

; 1963 :   int k;
; 1964 : 
; 1965 :   n &= CONMASK;

	mov	esi, DWORD PTR _n$[ebp]
	and	esi, 1073741823				; 3fffffffH

; 1966 :   if ( maxcon == 0 ) return 0;

	cmp	DWORD PTR [ecx+edx+1288], 0
	jne	SHORT $LN5@get_v_cons
	xor	eax, eax
	pop	esi

; 1973 : } // end get_v_constraint_status()

	pop	ebp
	ret	0
$LN5@get_v_cons:

; 1967 :   map = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _v_id$[ebp]
	and	eax, 134217727				; 07ffffffH
	push	edi
	mov	edi, DWORD PTR _web+12
	mov	eax, DWORD PTR [edi+eax*4]
	add	eax, DWORD PTR [ecx+edx+1264]

; 1968 :   for ( k = 1; k <= (int)*map ; k++ )

	mov	ecx, 1
	mov	edx, DWORD PTR [eax]
	cmp	edx, ecx
	jl	SHORT $LN2@get_v_cons
	npad	4
$LL4@get_v_cons:

; 1969 :   { if ( (map[k] & CONMASK) == (conmap_t)n ) 

	mov	edi, DWORD PTR [eax+ecx*4]
	and	edi, 1073741823				; 3fffffffH
	cmp	edi, esi
	je	SHORT $LN11@get_v_cons

; 1968 :   for ( k = 1; k <= (int)*map ; k++ )

	inc	ecx
	cmp	ecx, edx
	jle	SHORT $LL4@get_v_cons
$LN2@get_v_cons:
	pop	edi

; 1971 :   }
; 1972 :   return 0;

	xor	eax, eax
	pop	esi

; 1973 : } // end get_v_constraint_status()

	pop	ebp
	ret	0
$LN11@get_v_cons:

; 1970 :         return (map[k] & CON_HIT_BIT) ? 1 : 0;

	mov	eax, DWORD PTR [eax+ecx*4]
	pop	edi
	shr	eax, 31					; 0000001fH
	pop	esi

; 1973 : } // end get_v_constraint_status()

	pop	ebp
	ret	0
_get_v_constraint_status ENDP
_TEXT	ENDS
PUBLIC	_clear_v_conmap
; Function compile flags: /Ogtp
;	COMDAT _clear_v_conmap
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_clear_v_conmap PROC					; COMDAT

; 1982 : { conmap_t *map = get_v_constraint_map(v_id);

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	cmp	DWORD PTR [ecx+edx+1288], 0
	je	SHORT $LN6@clear_v_co
	mov	eax, DWORD PTR _v_id$[ebp]
	push	esi
	mov	esi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	add	eax, DWORD PTR [ecx+edx+1264]
	pop	esi
	jmp	SHORT $LN7@clear_v_co
$LN6@clear_v_co:
	mov	eax, OFFSET _nullcon
$LN7@clear_v_co:

; 1983 :   unsigned int k;
; 1984 : 
; 1985 :   for ( k = 1 ; k <= map[0] ; k++ )

	mov	ecx, 1
	cmp	DWORD PTR [eax], ecx
	jb	SHORT $LN10@clear_v_co
$LL3@clear_v_co:

; 1986 :     map[k] = 0;

	mov	DWORD PTR [eax+ecx*4], 0
	inc	ecx
	cmp	ecx, DWORD PTR [eax]
	jbe	SHORT $LL3@clear_v_co
$LN10@clear_v_co:

; 1987 :   map[0] = 0;

	mov	DWORD PTR [eax], 0

; 1988 : } // end clear_v_conmap()

	pop	ebp
	ret	0
_clear_v_conmap ENDP
_TEXT	ENDS
PUBLIC	_set_v_constraint_status
; Function compile flags: /Ogtp
;	COMDAT _set_v_constraint_status
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_n$ = 12						; size = 4
_set_v_constraint_status PROC				; COMDAT

; 2000 : { conmap_t *map;

	push	ebp
	mov	ebp, esp

; 2001 :   int maxcon = EXTRAS(VERTEX)[V_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	ecx, DWORD PTR _web+104

; 2002 : 
; 2003 :   int k;
; 2004 :   n &= CONMASK;

	and	DWORD PTR _n$[ebp], 1073741823		; 3fffffffH
	push	edi
	mov	edi, DWORD PTR _dymem

; 2005 :   if ( maxcon == 0 ) return;

	cmp	DWORD PTR [ecx+edi+1288], 0
	je	SHORT $LN2@set_v_cons@2

; 2006 :   map = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _web+12
	push	esi
	mov	esi, DWORD PTR _v_id$[ebp]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	eax, DWORD PTR [edx+eax]
	add	eax, DWORD PTR [ecx+edi+1264]

; 2007 :   for ( k = 1; k <= (int)*map ; k++ )

	mov	ecx, 1
	mov	edi, DWORD PTR [eax]
	cmp	edi, ecx
	jl	SHORT $LN16@set_v_cons@2
	push	ebx
	npad	4
$LL15@set_v_cons@2:

; 2008 :   { if ( (map[k] & CONMASK) == (conmap_t)n ) 

	mov	ebx, DWORD PTR [eax+ecx*4]
	and	ebx, 1073741823				; 3fffffffH
	cmp	ebx, DWORD PTR _n$[ebp]
	je	SHORT $LN13@set_v_cons@2

; 2007 :   for ( k = 1; k <= (int)*map ; k++ )

	inc	ecx
	cmp	ecx, edi
	jle	SHORT $LL15@set_v_cons@2
	pop	ebx
	pop	esi
	pop	edi

; 2011 :       return;
; 2012 :     }
; 2013 :   }
; 2014 : } // end set_v_constraint_status()

	pop	ebp
	ret	0
$LN13@set_v_cons@2:

; 2009 :     { map[k] |= CON_HIT_BIT;

	or	DWORD PTR [eax+ecx*4], -2147483648	; 80000000H

; 2010 :       set_attr(v_id,HIT_WALL);

	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	ecx, DWORD PTR _web[esi+12]
	mov	edx, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [edx+12]
	or	DWORD PTR [edx+8], 8192			; 00002000H
	mov	DWORD PTR [edx+12], eax
	pop	ebx
$LN16@set_v_cons@2:
	pop	esi
$LN2@set_v_cons@2:
	pop	edi

; 2011 :       return;
; 2012 :     }
; 2013 :   }
; 2014 : } // end set_v_constraint_status()

	pop	ebp
	ret	0
_set_v_constraint_status ENDP
_TEXT	ENDS
PUBLIC	_unset_v_constraint_status
; Function compile flags: /Ogtp
;	COMDAT _unset_v_constraint_status
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_n$ = 12						; size = 4
_unset_v_constraint_status PROC				; COMDAT

; 2026 : { conmap_t *map;

	push	ebp
	mov	ebp, esp

; 2027 :   int maxcon = EXTRAS(VERTEX)[V_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	push	esi

; 2028 : 
; 2029 :   int k;
; 2030 :   n &= CONMASK;

	mov	esi, DWORD PTR _n$[ebp]
	and	esi, 1073741823				; 3fffffffH

; 2031 :   if ( maxcon == 0 ) return;

	cmp	DWORD PTR [ecx+edx+1288], 0
	je	SHORT $LN2@unset_v_co@2

; 2032 :   map = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _v_id$[ebp]
	and	eax, 134217727				; 07ffffffH
	push	edi
	mov	edi, DWORD PTR _web+12
	mov	eax, DWORD PTR [edi+eax*4]
	add	eax, DWORD PTR [ecx+edx+1264]

; 2033 :   for ( k = 1; k <= (int)*map ; k++ )

	mov	ecx, 1
	mov	edx, DWORD PTR [eax]
	cmp	edx, ecx
	jl	SHORT $LN13@unset_v_co@2
	npad	9
$LL4@unset_v_co@2:

; 2034 :   { if ( (map[k] & CONMASK) == (conmap_t)n ) 

	mov	edi, DWORD PTR [eax+ecx*4]
	and	edi, 1073741823				; 3fffffffH
	cmp	edi, esi
	je	SHORT $LN11@unset_v_co@2

; 2033 :   for ( k = 1; k <= (int)*map ; k++ )

	inc	ecx
	cmp	ecx, edx
	jle	SHORT $LL4@unset_v_co@2
	pop	edi
	pop	esi

; 2036 :        return;
; 2037 :      }
; 2038 :   }
; 2039 : } // end unset_v_constraint_status()

	pop	ebp
	ret	0
$LN11@unset_v_co@2:

; 2035 :      { map[k] &= ~CON_HIT_BIT;

	and	DWORD PTR [eax+ecx*4], 2147483647	; 7fffffffH
$LN13@unset_v_co@2:
	pop	edi
$LN2@unset_v_co@2:
	pop	esi

; 2036 :        return;
; 2037 :      }
; 2038 :   }
; 2039 : } // end unset_v_constraint_status()

	pop	ebp
	ret	0
_unset_v_constraint_status ENDP
_TEXT	ENDS
PUBLIC	_clear_v_constraint_status
; Function compile flags: /Ogtp
;	COMDAT _clear_v_constraint_status
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_clear_v_constraint_status PROC				; COMDAT

; 2048 : { conmap_t *map;

	push	ebp
	mov	ebp, esp

; 2049 :   int maxcon = EXTRAS(VERTEX)[V_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem

; 2050 :   int k;
; 2051 : 
; 2052 :   if ( maxcon == 0 ) return;

	cmp	DWORD PTR [eax+ecx+1288], 0
	je	SHORT $LN2@clear_v_co@2

; 2053 :   map = get_v_constraint_map(v_id);

	mov	edx, DWORD PTR _v_id$[ebp]
	push	esi
	mov	esi, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	add	edx, DWORD PTR [eax+ecx+1264]

; 2054 :   for ( k = 1; k <= (int)*map ; k++ )

	mov	esi, 1
	cmp	DWORD PTR [edx], esi
	jl	SHORT $LN12@clear_v_co@2
	push	edi
	npad	4
$LL4@clear_v_co@2:

; 2055 :   { struct constraint *con = get_constraint(map[k]);

	mov	ecx, DWORD PTR [edx+esi*4]

; 2056 :     if ( con->attr & (NONPOSITIVE|NONNEGATIVE) )

	mov	edi, DWORD PTR _web+652
	mov	eax, ecx
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	mov	eax, DWORD PTR [eax+edi+32]
	and	eax, 3
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN3@clear_v_co@2

; 2057 :       map[k] &= ~CON_HIT_BIT;

	and	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR [edx+esi*4], ecx
$LN3@clear_v_co@2:

; 2054 :   for ( k = 1; k <= (int)*map ; k++ )

	inc	esi
	cmp	esi, DWORD PTR [edx]
	jle	SHORT $LL4@clear_v_co@2
	pop	edi
$LN12@clear_v_co@2:
	pop	esi
$LN2@clear_v_co@2:

; 2058 :   }
; 2059 : 
; 2060 : } // end clear_v_constraint_status()

	pop	ebp
	ret	0
_clear_v_constraint_status ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_assure_v_constraints
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _assure_v_constraints
_TEXT	SEGMENT
_tmp$ = -100						; size = 4
_tempmap$ = -96						; size = 92
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_assure_v_constraints PROC				; COMDAT

; 2070 : { conmap_t *map;

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2071 :   conmap_t tempmap[MAXCONPER],*tmp=NULL;
; 2072 :   int k;
; 2073 :   unsigned int kk;
; 2074 : 
; 2075 :   map = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	cmp	DWORD PTR [eax+ecx+1288], 0
	push	ebx
	mov	ebx, DWORD PTR _v_id$[ebp]
	push	esi
	push	edi
	mov	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN11@assure_v_c
	mov	esi, DWORD PTR _web+12
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+edx*4]
	add	esi, DWORD PTR [eax+ecx+1264]
	jmp	SHORT $LN12@assure_v_c
$LN11@assure_v_c:
	mov	esi, OFFSET _nullcon
$LN12@assure_v_c:

; 2076 :   if ( map[0] > MAXCONPER )

	mov	eax, DWORD PTR [esi]
	cmp	eax, 23					; 00000017H
	jbe	SHORT $LN8@assure_v_c

; 2077 :     tmp = (conmap_t *)temp_calloc(map[0]+5,sizeof(conmap_t));

	push	2077					; 0000081dH
	push	OFFSET ??_C@_0L@LOKKOLMO@skeleton?4c?$AA@
	add	eax, 5
	push	4
	push	eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tmp$[ebp], eax
$LN8@assure_v_c:

; 2078 :   for ( k = 0; k <= (int)*map ; k++ )

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	js	SHORT $LN7@assure_v_c
	lea	ecx, DWORD PTR [eax+1]
	lea	edi, DWORD PTR _tempmap$[ebp]
	rep movsd
$LN7@assure_v_c:

; 2079 :     tempmap[k] = map[k];
; 2080 :   unset_v_all_constraints(v_id);

	push	ebx
	call	_unset_v_all_constraints

; 2081 :   for ( kk = 1; kk <= tempmap[0] ; kk++ )

	mov	edi, DWORD PTR _tempmap$[ebp]
	mov	esi, 1
	add	esp, 4
	cmp	edi, esi
	jb	SHORT $LN2@assure_v_c
$LL4@assure_v_c:

; 2082 :     set_v_constraint_map(v_id,tempmap[kk]);

	mov	eax, DWORD PTR _tempmap$[ebp+esi*4]
	push	eax
	push	ebx
	call	_set_v_constraint_map
	inc	esi
	add	esp, 8
	cmp	esi, edi
	jbe	SHORT $LL4@assure_v_c
$LN2@assure_v_c:

; 2083 :   if ( tmp )

	mov	eax, DWORD PTR _tmp$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN1@assure_v_c

; 2084 :     temp_free((char*)tmp);

	push	eax
	call	_temp_free
	add	esp, 4
$LN1@assure_v_c:

; 2085 : 
; 2086 : } // end assure_v_constraints()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_assure_v_constraints ENDP
_TEXT	ENDS
PUBLIC	_set_e_constraint_map
; Function compile flags: /Ogtp
;	COMDAT _set_e_constraint_map
_TEXT	SEGMENT
_first_fe$90760 = -20					; size = 4
_newmax$90743 = -20					; size = 4
_four$ = -20						; size = 4
_fe$90759 = -16						; size = 4
_maxcon$ = -16						; size = 4
_constr$ = -12						; size = 4
_min_rank$90761 = -8					; size = 4
_max_rank$90762 = -4					; size = 4
_e_id$ = 8						; size = 4
_n$ = 12						; size = 4
_set_e_constraint_map PROC				; COMDAT

; 2098 : { conmap_t *map;

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2099 :   int maxcon = EXTRAS(EDGE)[E_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	ecx, DWORD PTR _web+216
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [ecx+eax+1048]

; 2100 :   int k;
; 2101 :   struct constraint *constr;
; 2102 :   int four = 4;
; 2103 : 
; 2104 :   n &= CONMASK;

	and	DWORD PTR _n$[ebp], 1073741823		; 3fffffffH
	mov	DWORD PTR _maxcon$[ebp], edx
	mov	DWORD PTR _four$[ebp], 4

; 2105 :   if ( maxcon == 0 )

	test	edx, edx
	jne	SHORT $LN66@set_e_cons

; 2106 :      expand_attribute(EDGE,E_CONSTR_LIST_ATTR,&four);

	lea	eax, DWORD PTR _four$[ebp]
	push	eax
	push	4
	push	1
	call	_expand_attribute
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	add	esp, 12					; 0000000cH
$LN66@set_e_cons:

; 2107 :   map = get_e_constraint_map(e_id);

	cmp	DWORD PTR [ecx+eax+1048], 0
	push	ebx
	mov	ebx, DWORD PTR _e_id$[ebp]
	push	esi
	push	edi
	je	SHORT $LN26@set_e_cons
	mov	esi, DWORD PTR _web+124
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+edx*4]
	add	esi, DWORD PTR [ecx+eax+1024]
	jmp	SHORT $LN27@set_e_cons
$LN26@set_e_cons:
	mov	esi, OFFSET _nullcon
$LN27@set_e_cons:
	mov	eax, DWORD PTR [esi]

; 2108 :   for ( k = 1; k <= (int)*map ; k++ )

	mov	edi, 1
	cmp	eax, edi
	jl	SHORT $LN68@set_e_cons
$LL22@set_e_cons:

; 2109 :      if ( (map[k] & CONMASK) == (conmap_t)n ) return;

	mov	ecx, DWORD PTR [esi+edi*4]
	and	ecx, 1073741823				; 3fffffffH
	cmp	ecx, DWORD PTR _n$[ebp]
	je	$LN5@set_e_cons

; 2108 :   for ( k = 1; k <= (int)*map ; k++ )

	inc	edi
	cmp	edi, eax
	jle	SHORT $LL22@set_e_cons
$LN68@set_e_cons:

; 2110 :   if ( k >= maxcon )

	mov	eax, DWORD PTR _maxcon$[ebp]
	cmp	edi, eax
	jl	SHORT $LN29@set_e_cons

; 2111 :   { int newmax;
; 2112 :     newmax = maxcon+4;
; 2113 :     expand_attribute(EDGE,E_CONSTR_LIST_ATTR,&newmax);

	lea	edx, DWORD PTR _newmax$90743[ebp]
	push	edx
	add	eax, 4
	push	4
	push	1
	mov	DWORD PTR _newmax$90743[ebp], eax
	call	_expand_attribute

; 2114 :     map = get_e_constraint_map(e_id);

	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [eax+ecx+1048], 0
	je	SHORT $LN28@set_e_cons
	mov	esi, DWORD PTR _web+124
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+edx*4]
	add	esi, DWORD PTR [eax+ecx+1024]
	jmp	SHORT $LN29@set_e_cons
$LN28@set_e_cons:
	mov	esi, OFFSET _nullcon
$LN29@set_e_cons:

; 2115 :   } 
; 2116 :   map[k] = (conmap_t)n; 

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR [esi+edi*4], eax

; 2117 :   map[0]++; /* counter */

	inc	DWORD PTR [esi]

; 2118 : 
; 2119 :   set_attr(e_id,CONSTRAINT);

	mov	edi, DWORD PTR _e_id$[ebp]
	shr	ebx, 29					; 0000001dH
	imul	ebx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ebx+12]
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	lea	ebx, DWORD PTR _web[ebx+12]
	add	edi, edi
	mov	eax, DWORD PTR [ecx+edi]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 1024			; 00000400H
	mov	DWORD PTR [eax+12], edx

; 2120 :   constr = get_constraint(n);

	mov	edx, DWORD PTR _n$[ebp]
	and	edx, 1073741823				; 3fffffffH
	imul	edx, 176				; 000000b0H
	add	edx, DWORD PTR _web+652

; 2121 :   if ( constr->attr & CON_ENERGY )

	xor	ecx, ecx
	mov	eax, DWORD PTR [edx+32]
	and	eax, 64					; 00000040H
	or	eax, ecx
	mov	DWORD PTR _constr$[ebp], edx
	je	SHORT $LN16@set_e_cons

; 2122 :   { set_attr(e_id, BDRY_ENERGY);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 512			; 00000200H
	mov	DWORD PTR [eax+12], ecx

; 2123 :     if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN16@set_e_cons

; 2124 :        apply_method_num(positive_id(e_id),constr->energy_method);

	mov	edx, DWORD PTR [edx+168]
	mov	eax, DWORD PTR _e_id$[ebp]
	push	edx
	and	eax, -134217729				; f7ffffffH
	push	eax
	call	_apply_method_num
	mov	edx, DWORD PTR _constr$[ebp]
	add	esp, 8
$LN16@set_e_cons:

; 2125 : /* positive_id() to agree with old way */
; 2126 :   }
; 2127 :   if ( constr->attr & CON_CONTENT )

	mov	eax, DWORD PTR [edx+32]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN5@set_e_cons

; 2128 :   { set_attr(e_id, BDRY_CONTENT);  /* BIG PROBLEM HERE GETTING RIGHT BODY!!! */

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+edi]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 4096			; 00001000H
	mov	DWORD PTR [eax+12], ecx

; 2129 :     if ( everything_quantities_flag )

	xor	eax, eax
	cmp	DWORD PTR _everything_quantities_flag, eax
	je	$LN5@set_e_cons

; 2130 :     { facetedge_id fe,first_fe = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edi, DWORD PTR [edi+ecx]
	cmp	edi, eax
	jne	SHORT $LN37@set_e_cons
	mov	DWORD PTR _first_fe$90760[ebp], eax
	jmp	SHORT $LN38@set_e_cons
$LN37@set_e_cons:
	test	DWORD PTR _e_id$[ebp], 134217728	; 08000000H
	mov	edi, DWORD PTR [edi+28]
	je	SHORT $LN36@set_e_cons
	xor	edi, 134217728				; 08000000H
$LN36@set_e_cons:
	mov	DWORD PTR _first_fe$90760[ebp], edi
$LN38@set_e_cons:

; 2131 :       int min_rank, max_rank,j;
; 2132 : 
; 2133 :       min_rank = MAXINT; max_rank = 0;
; 2134 :       for ( j = 1 ; j <= (int)map[0] ; j++ )

	mov	ecx, 1
	mov	DWORD PTR _min_rank$90761[ebp], 2147483647 ; 7fffffffH
	mov	DWORD PTR _max_rank$90762[ebp], eax
	cmp	DWORD PTR [esi], ecx
	jl	SHORT $LN11@set_e_cons
	mov	ebx, DWORD PTR [esi]
	mov	edi, DWORD PTR _web+652
	npad	1
$LL13@set_e_cons:

; 2135 :       { 
; 2136 :         struct constraint *c = get_constraint(map[j]);

	mov	eax, DWORD PTR [esi+ecx*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H

; 2137 :         if ( c->content_rank < min_rank ) min_rank = c->content_rank;

	mov	eax, DWORD PTR [eax+edi+172]
	cmp	eax, DWORD PTR _min_rank$90761[ebp]
	jge	SHORT $LN10@set_e_cons
	mov	DWORD PTR _min_rank$90761[ebp], eax
$LN10@set_e_cons:

; 2138 :         if ( c->content_rank > max_rank ) max_rank = c->content_rank;

	cmp	eax, DWORD PTR _max_rank$90762[ebp]
	jle	SHORT $LN12@set_e_cons
	mov	DWORD PTR _max_rank$90762[ebp], eax
$LN12@set_e_cons:

; 2131 :       int min_rank, max_rank,j;
; 2132 : 
; 2133 :       min_rank = MAXINT; max_rank = 0;
; 2134 :       for ( j = 1 ; j <= (int)map[0] ; j++ )

	inc	ecx
	cmp	ecx, ebx
	jle	SHORT $LL13@set_e_cons
$LN11@set_e_cons:

; 2139 :       }
; 2140 :       fe = first_fe;

	mov	eax, DWORD PTR _first_fe$90760[ebp]

; 2141 :       if ( valid_id(first_fe) )

	test	eax, 268435456				; 10000000H
	je	$LN5@set_e_cons
	mov	edi, DWORD PTR _dymem
	jmp	SHORT $LN7@set_e_cons
$LL67@set_e_cons:
	mov	eax, DWORD PTR _fe$90759[ebp]
$LN7@set_e_cons:

; 2142 :       do
; 2143 :       { 
; 2144 :         body_id b_id;
; 2145 :         facet_id f_id;
; 2146 :         f_id = get_fe_facet(fe);

	mov	ecx, DWORD PTR _web+460
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN41@set_e_cons
	mov	ebx, DWORD PTR _NULLFACET
	jmp	SHORT $LN40@set_e_cons
$LN41@set_e_cons:
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+esi*4]
	mov	ebx, DWORD PTR [esi+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN45@set_e_cons
	xor	ebx, 134217728				; 08000000H
$LN40@set_e_cons:

; 2147 :         fe = get_next_facet(fe);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN45@set_e_cons
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN71@set_e_cons
$LN45@set_e_cons:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+40]
$LN71@set_e_cons:
	mov	DWORD PTR _fe$90759[ebp], ecx

; 2148 :         if ( !valid_id(f_id) ) continue;

	test	ebx, 268435456				; 10000000H
	je	$LN6@set_e_cons

; 2149 :         if ( get_fattr(f_id) & NONCONTENT ) continue;

	mov	ecx, DWORD PTR _web+236
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 536870912				; 20000000H
	xor	esi, esi
	or	eax, esi
	jne	$LN6@set_e_cons

; 2150 :         b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, esi
	je	SHORT $LN48@set_e_cons
$LN51@set_e_cons:
	mov	eax, DWORD PTR _web+328
	mov	eax, DWORD PTR [eax+edi+784]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN49@set_e_cons
	mov	esi, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN48@set_e_cons
$LN49@set_e_cons:
	mov	esi, DWORD PTR [ecx+eax]
$LN48@set_e_cons:

; 2151 :         if ( valid_id(b_id) && (constr->content_rank >= max_rank))

	test	esi, 268435456				; 10000000H
	je	SHORT $LN2@set_e_cons
	mov	ecx, DWORD PTR _max_rank$90762[ebp]
	cmp	DWORD PTR [edx+172], ecx
	jl	SHORT $LN2@set_e_cons

; 2152 :         { int methnum;
; 2153 :           methnum = create_body_constraint_content_method(b_id,n);

	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	push	esi
	call	_create_body_constraint_content_method
	mov	edi, eax

; 2154 :           attach_method_num(get_body_volquant(b_id),methnum);

	mov	eax, DWORD PTR _web+348
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	edx, DWORD PTR [ecx+404]
	push	edi
	push	edx
	call	_attach_method_num

; 2155 :           apply_method_num(e_id,methnum);

	mov	eax, DWORD PTR _e_id$[ebp]
	push	edi
	push	eax
	call	_apply_method_num
	mov	edi, DWORD PTR _dymem
	mov	edx, DWORD PTR _constr$[ebp]
	add	esp, 24					; 00000018H
$LN2@set_e_cons:

; 2156 :         }
; 2157 :         b_id = get_facet_body(inverse_id(f_id));

	xor	ebx, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	mov	eax, ebx
	jne	SHORT $LN57@set_e_cons
	xor	esi, esi
	jmp	SHORT $LN54@set_e_cons
$LN57@set_e_cons:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN56@set_e_cons
	xor	esi, esi
	jmp	SHORT $LN54@set_e_cons
$LN56@set_e_cons:
	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN55@set_e_cons
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+edi+784]
	mov	esi, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN54@set_e_cons
$LN55@set_e_cons:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+edi+784]
	mov	esi, DWORD PTR [eax+ecx]
$LN54@set_e_cons:

; 2158 :         if ( valid_id(b_id) && (constr->content_rank <= min_rank))

	test	esi, 268435456				; 10000000H
	je	SHORT $LN6@set_e_cons
	mov	eax, DWORD PTR _min_rank$90761[ebp]
	cmp	DWORD PTR [edx+172], eax
	jg	SHORT $LN6@set_e_cons

; 2159 :         { int methnum;
; 2160 :           methnum = create_body_constraint_content_method(b_id,n);

	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	push	esi
	call	_create_body_constraint_content_method

; 2161 :           attach_method_num(get_body_volquant(b_id),methnum);

	mov	edx, DWORD PTR _web+348
	mov	edi, eax
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR [eax+404]
	push	edi
	push	ecx
	call	_attach_method_num

; 2162 :           apply_method_num(inverse_id(e_id),methnum);

	mov	edx, DWORD PTR _e_id$[ebp]
	xor	edx, 134217728				; 08000000H
	push	edi
	push	edx
	call	_apply_method_num
	mov	edi, DWORD PTR _dymem
	mov	edx, DWORD PTR _constr$[ebp]
	add	esp, 24					; 00000018H
$LN6@set_e_cons:

; 2163 :         }
; 2164 :       } while ( !equal_id(fe,first_fe) );

	mov	eax, DWORD PTR _fe$90759[ebp]
	cmp	eax, DWORD PTR _first_fe$90760[ebp]
	jne	$LL67@set_e_cons
$LN5@set_e_cons:
	pop	edi
	pop	esi
	pop	ebx

; 2165 : 
; 2166 :     }
; 2167 :   }
; 2168 : } // end set_e_constraint_map()

	mov	esp, ebp
	pop	ebp
	ret	0
_set_e_constraint_map ENDP
_TEXT	ENDS
PUBLIC	_e_on_constraint
; Function compile flags: /Ogtp
;	COMDAT _e_on_constraint
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_n$ = 12						; size = 4
_e_on_constraint PROC					; COMDAT

; 2179 : { conmap_t *map;

	push	ebp
	mov	ebp, esp

; 2180 :   int maxcon = EXTRAS(EDGE)[E_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	push	esi

; 2181 :   int k;
; 2182 : 
; 2183 :   n &= CONMASK;

	mov	esi, DWORD PTR _n$[ebp]
	and	esi, 1073741823				; 3fffffffH

; 2184 :   if ( maxcon == 0 ) return 0;

	cmp	DWORD PTR [ecx+edx+1048], 0
	jne	SHORT $LN5@e_on_const
	xor	eax, eax
	pop	esi

; 2191 : } // end e_on_constraint()

	pop	ebp
	ret	0
$LN5@e_on_const:

; 2185 :   map = get_e_constraint_map(e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	and	eax, 134217727				; 07ffffffH
	push	edi
	mov	edi, DWORD PTR _web+124
	mov	eax, DWORD PTR [edi+eax*4]
	add	eax, DWORD PTR [ecx+edx+1024]

; 2186 :   for ( k = 1; k <= (int)*map ; k++ )

	mov	ecx, 1
	mov	edx, DWORD PTR [eax]
	cmp	edx, ecx
	jl	SHORT $LN2@e_on_const
	npad	4
$LL4@e_on_const:

; 2187 :   { if ( (map[k] & CONMASK) == (conmap_t)n ) 

	mov	edi, DWORD PTR [eax+ecx*4]
	and	edi, 1073741823				; 3fffffffH
	cmp	edi, esi
	je	SHORT $LN11@e_on_const

; 2186 :   for ( k = 1; k <= (int)*map ; k++ )

	inc	ecx
	cmp	ecx, edx
	jle	SHORT $LL4@e_on_const
$LN2@e_on_const:
	pop	edi

; 2189 :   }
; 2190 :   return 0;

	xor	eax, eax
	pop	esi

; 2191 : } // end e_on_constraint()

	pop	ebp
	ret	0
$LN11@e_on_const:
	pop	edi

; 2188 :         return 1;

	mov	eax, 1
	pop	esi

; 2191 : } // end e_on_constraint()

	pop	ebp
	ret	0
_e_on_constraint ENDP
_TEXT	ENDS
PUBLIC	_unset_e_constraint_map
; Function compile flags: /Ogtp
;	COMDAT _unset_e_constraint_map
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_n$ = 12						; size = 4
_unset_e_constraint_map PROC				; COMDAT

; 2203 : { conmap_t *map;

	push	ebp
	mov	ebp, esp

; 2204 :   int maxcon = EXTRAS(EDGE)[E_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	ecx, DWORD PTR _web+216

; 2205 :   int j,k;
; 2206 : 
; 2207 :   n &= CONMASK;

	and	DWORD PTR _n$[ebp], 1073741823		; 3fffffffH
	push	edi
	mov	edi, DWORD PTR _dymem

; 2208 :   if ( maxcon == 0 ) return;

	cmp	DWORD PTR [ecx+edi+1048], 0
	je	$LN2@unset_e_co

; 2209 :   map = get_e_constraint_map(e_id);

	mov	eax, DWORD PTR _web+124
	push	ebx
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	eax, DWORD PTR [edx+eax]
	add	eax, DWORD PTR [ecx+edi+1024]

; 2210 :   for ( k = 1; k <= (int)*map ; k++ )

	mov	ecx, 1
	mov	edi, DWORD PTR [eax]
	cmp	edi, ecx
	jl	SHORT $LN33@unset_e_co
$LL32@unset_e_co:

; 2211 :     if ( (map[k] & CONMASK) == (conmap_t)n ) break;

	mov	ebx, DWORD PTR [eax+ecx*4]
	and	ebx, 1073741823				; 3fffffffH
	cmp	ebx, DWORD PTR _n$[ebp]
	je	SHORT $LN33@unset_e_co

; 2210 :   for ( k = 1; k <= (int)*map ; k++ )

	inc	ecx
	cmp	ecx, edi
	jle	SHORT $LL32@unset_e_co
$LN33@unset_e_co:

; 2212 :   if ( k > (int)*map ) return;

	cmp	ecx, edi
	jg	$LN35@unset_e_co

; 2213 : 
; 2214 :   map[0]--;

	dec	edi
	mov	DWORD PTR [eax], edi

; 2215 :   for ( j = k ; j <= (int)*map ; j++ ) map[j] = map[j+1];

	cmp	ecx, edi
	jg	SHORT $LN7@unset_e_co
$LL9@unset_e_co:
	mov	edi, DWORD PTR [eax+ecx*4+4]
	mov	DWORD PTR [eax+ecx*4], edi
	inc	ecx
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LL9@unset_e_co
$LN7@unset_e_co:

; 2216 :   map[j] = 0;

	mov	DWORD PTR [eax+ecx*4], 0

; 2217 :   if ( map[0] == 0 ) unset_attr(e_id,CONSTRAINT);

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN20@unset_e_co
	mov	ecx, esi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	mov	eax, DWORD PTR [eax+edx]
	mov	ecx, DWORD PTR [eax+12]
	and	DWORD PTR [eax+8], -1025		; fffffbffH
	mov	DWORD PTR [eax+12], ecx
$LN20@unset_e_co:

; 2218 : 
; 2219 :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN35@unset_e_co

; 2220 :   { 
; 2221 :     // doing low-level deletion here since may be many volume methods
; 2222 :     // associated with constraint, too many to list in constraint structure.
; 2223 :     int meth_offset = get_meth_offset(EDGE);
; 2224 :     int i;
; 2225 :     struct element *eptr = elptr(e_id);

	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	eax, DWORD PTR _web[esi+12]
	mov	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR _web+5668

; 2226 :     int *instlist = (int*)((char*)eptr + meth_offset);

	mov	eax, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+216

; 2227 :     for ( i = 0 ; i < eptr->method_count ; i++ )

	xor	esi, esi
	mov	edi, DWORD PTR [edx+eax+64]
	xor	edx, edx
	add	edi, ecx
	cmp	dx, WORD PTR [ecx+24]
	jae	SHORT $LN35@unset_e_co
	mov	ebx, DWORD PTR _n$[ebp]
	npad	6
$LL4@unset_e_co:

; 2228 :     { struct method_instance *mi;
; 2229 :       mi = METH_INSTANCE(abs(instlist[i]));

	mov	eax, DWORD PTR [edi+esi*4]
	cdq
	xor	eax, edx
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 2230 :       if ( mi->connum == n)

	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	cmp	DWORD PTR [eax+edx+216], ebx
	jne	SHORT $LN3@unset_e_co

; 2231 :       { instlist[i] = instlist[--eptr->method_count];

	mov	eax, 65535				; 0000ffffH
	add	WORD PTR [ecx+24], ax
	movzx	edx, WORD PTR [ecx+24]
	mov	eax, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [edi+esi*4], eax

; 2232 :         i--;

	dec	esi
$LN3@unset_e_co:

; 2227 :     for ( i = 0 ; i < eptr->method_count ; i++ )

	movzx	edx, WORD PTR [ecx+24]
	inc	esi
	cmp	esi, edx
	jl	SHORT $LL4@unset_e_co
$LN35@unset_e_co:
	pop	esi
	pop	ebx
$LN2@unset_e_co:
	pop	edi

; 2233 :       }
; 2234 :     }
; 2235 :   }
; 2236 : 
; 2237 : } // end unset_e_constraint_map()

	pop	ebp
	ret	0
_unset_e_constraint_map ENDP
_TEXT	ENDS
PUBLIC	_unset_e_all_constraints
; Function compile flags: /Ogtp
;	COMDAT _unset_e_all_constraints
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_unset_e_all_constraints PROC				; COMDAT

; 2246 : { conmap_t *map;

	push	ebp
	mov	ebp, esp

; 2247 :   int maxcon = EXTRAS(EDGE)[E_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem

; 2248 :   int i;
; 2249 : 
; 2250 :   if ( maxcon == 0 ) return;

	cmp	DWORD PTR [eax+ecx+1048], 0
	je	SHORT $LN1@unset_e_al

; 2251 :   map = get_e_constraint_map(e_id);

	push	ebx
	mov	ebx, DWORD PTR _e_id$[ebp]
	push	esi
	mov	esi, DWORD PTR _web+124
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	push	edi
	mov	edi, DWORD PTR [esi+edx*4]
	add	edi, DWORD PTR [eax+ecx+1024]

; 2252 : 
; 2253 :   for ( i = map[0] ; i >= 1 ; i-- )

	mov	esi, DWORD PTR [edi]
	cmp	esi, 1
	jl	SHORT $LN11@unset_e_al
	npad	3
$LL3@unset_e_al:

; 2254 :     unset_e_constraint_map(e_id,map[i]);

	mov	eax, DWORD PTR [edi+esi*4]
	push	eax
	push	ebx
	call	_unset_e_constraint_map
	dec	esi
	add	esp, 8
	cmp	esi, 1
	jge	SHORT $LL3@unset_e_al
$LN11@unset_e_al:
	pop	edi
	pop	esi
	pop	ebx
$LN1@unset_e_al:

; 2255 : } // end unset_e_all_constraints()

	pop	ebp
	ret	0
_unset_e_all_constraints ENDP
_TEXT	ENDS
PUBLIC	_set_f_constraint_map
; Function compile flags: /Ogtp
;	COMDAT _set_f_constraint_map
_TEXT	SEGMENT
_newmax$90911 = -4					; size = 4
_four$ = -4						; size = 4
_f_id$ = 8						; size = 4
_n$ = 12						; size = 4
_set_f_constraint_map PROC				; COMDAT

; 2267 : { conmap_t *map;

	push	ebp
	mov	ebp, esp
	push	ecx

; 2268 :   int maxcon = EXTRAS(FACET)[F_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	edx, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem

; 2269 :   int k;
; 2270 :   int four = 4;
; 2271 : 
; 2272 :   n &= CONMASK;  /* get rid of hit bit */

	and	DWORD PTR _n$[ebp], 1073741823		; 3fffffffH
	push	ebx
	mov	ebx, DWORD PTR [edx+ecx+88]
	push	esi
	push	edi
	mov	DWORD PTR _four$[ebp], 4

; 2273 :   if ( maxcon == 0 )

	test	ebx, ebx
	jne	SHORT $LN6@set_f_cons

; 2274 :      expand_attribute(FACET,F_CONSTR_LIST_ATTR,&four);

	lea	eax, DWORD PTR _four$[ebp]
	push	eax
	push	ebx
	push	2
	call	_expand_attribute
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+328
	add	esp, 12					; 0000000cH
$LN6@set_f_cons:

; 2275 :   map = get_f_constraint_map(f_id);

	cmp	DWORD PTR [edx+ecx+88], 0
	mov	edi, DWORD PTR _f_id$[ebp]
	je	SHORT $LN9@set_f_cons
	mov	esi, DWORD PTR _web+236
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	add	eax, DWORD PTR [edx+ecx+64]
	jmp	SHORT $LN10@set_f_cons
$LN9@set_f_cons:
	mov	eax, OFFSET _nullcon
$LN10@set_f_cons:
	mov	ecx, DWORD PTR [eax]

; 2276 :   for ( k = 1; k <= (int)*map ; k++ )

	mov	esi, 1
	cmp	ecx, esi
	jl	SHORT $LN3@set_f_cons
$LL16@set_f_cons:

; 2277 :      if ( (map[k] & CONMASK) == (conmap_t)n ) return;

	mov	edx, DWORD PTR [eax+esi*4]
	and	edx, 1073741823				; 3fffffffH
	cmp	edx, DWORD PTR _n$[ebp]
	je	SHORT $LN7@set_f_cons

; 2276 :   for ( k = 1; k <= (int)*map ; k++ )

	inc	esi
	cmp	esi, ecx
	jle	SHORT $LL16@set_f_cons
$LN3@set_f_cons:

; 2278 :   if ( k >= maxcon )

	cmp	esi, ebx
	jl	SHORT $LN12@set_f_cons

; 2279 :   { int newmax;
; 2280 :     newmax = maxcon+4;
; 2281 :     expand_attribute(FACET,F_CONSTR_LIST_ATTR,&newmax);

	lea	eax, DWORD PTR _newmax$90911[ebp]
	push	eax
	push	0
	add	ebx, 4
	push	2
	mov	DWORD PTR _newmax$90911[ebp], ebx
	call	_expand_attribute

; 2282 :     map = get_f_constraint_map(f_id);

	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [ecx+edx+88], 0
	je	SHORT $LN11@set_f_cons
	mov	eax, DWORD PTR _web+236
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edi*4]
	add	eax, DWORD PTR [ecx+edx+64]

; 2283 :   } 
; 2284 :   map[k] = (conmap_t)n; 

	mov	ecx, DWORD PTR _n$[ebp]
	pop	edi
	mov	DWORD PTR [eax+esi*4], ecx

; 2285 :   map[0]++; /* counter */

	inc	DWORD PTR [eax]
	pop	esi
	pop	ebx

; 2286 : } // end set_f_constraint_map()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@set_f_cons:

; 2282 :     map = get_f_constraint_map(f_id);

	mov	eax, OFFSET _nullcon
$LN12@set_f_cons:

; 2283 :   } 
; 2284 :   map[k] = (conmap_t)n; 

	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+esi*4], ecx

; 2285 :   map[0]++; /* counter */

	inc	DWORD PTR [eax]
$LN7@set_f_cons:
	pop	edi
	pop	esi
	pop	ebx

; 2286 : } // end set_f_constraint_map()

	mov	esp, ebp
	pop	ebp
	ret	0
_set_f_constraint_map ENDP
_TEXT	ENDS
PUBLIC	_f_on_constraint
; Function compile flags: /Ogtp
;	COMDAT _f_on_constraint
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_n$ = 12						; size = 4
_f_on_constraint PROC					; COMDAT

; 2298 : { conmap_t *map;

	push	ebp
	mov	ebp, esp

; 2299 :   int maxcon = EXTRAS(FACET)[F_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	push	esi

; 2300 :   int k;
; 2301 : 
; 2302 :   n &= CONMASK;

	mov	esi, DWORD PTR _n$[ebp]
	and	esi, 1073741823				; 3fffffffH

; 2303 :   if ( maxcon == 0 ) return 0;

	cmp	DWORD PTR [ecx+edx+88], 0
	jne	SHORT $LN5@f_on_const
	xor	eax, eax
	pop	esi

; 2310 : } // end  f_on_constraint()

	pop	ebp
	ret	0
$LN5@f_on_const:

; 2304 :   map = get_f_constraint_map(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	and	eax, 134217727				; 07ffffffH
	push	edi
	mov	edi, DWORD PTR _web+236
	mov	eax, DWORD PTR [edi+eax*4]
	add	eax, DWORD PTR [ecx+edx+64]

; 2305 :   for ( k = 1; k <= (int)*map ; k++ )

	mov	ecx, 1
	mov	edx, DWORD PTR [eax]
	cmp	edx, ecx
	jl	SHORT $LN2@f_on_const
	npad	10
$LL4@f_on_const:

; 2306 :   { if ( (map[k] & CONMASK) == (conmap_t)n ) 

	mov	edi, DWORD PTR [eax+ecx*4]
	and	edi, 1073741823				; 3fffffffH
	cmp	edi, esi
	je	SHORT $LN11@f_on_const

; 2305 :   for ( k = 1; k <= (int)*map ; k++ )

	inc	ecx
	cmp	ecx, edx
	jle	SHORT $LL4@f_on_const
$LN2@f_on_const:
	pop	edi

; 2308 :   }
; 2309 :   return 0;

	xor	eax, eax
	pop	esi

; 2310 : } // end  f_on_constraint()

	pop	ebp
	ret	0
$LN11@f_on_const:
	pop	edi

; 2307 :         return 1;

	mov	eax, 1
	pop	esi

; 2310 : } // end  f_on_constraint()

	pop	ebp
	ret	0
_f_on_constraint ENDP
_TEXT	ENDS
PUBLIC	_unset_f_constraint_map
EXTRN	_unapply_method:PROC
; Function compile flags: /Ogtp
;	COMDAT _unset_f_constraint_map
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_n$ = 12						; size = 4
_unset_f_constraint_map PROC				; COMDAT

; 2322 : { conmap_t *map;

	push	ebp
	mov	ebp, esp

; 2323 :   int maxcon = EXTRAS(FACET)[F_CONSTR_LIST_ATTR].array_spec.datacount;
; 2324 :   int k,j;
; 2325 : 
; 2326 :   n &= CONMASK;

	mov	edx, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _web+328
	push	edi
	mov	edi, DWORD PTR _dymem
	and	edx, 1073741823				; 3fffffffH

; 2327 :   if ( maxcon == 0 ) return;

	cmp	DWORD PTR [ecx+edi+88], 0
	je	$LN1@unset_f_co

; 2328 :   map = get_f_constraint_map(f_id);

	mov	eax, DWORD PTR _web+236
	push	esi
	mov	esi, DWORD PTR _f_id$[ebp]
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+eax]
	add	eax, DWORD PTR [ecx+edi+64]

; 2329 :   for ( k = 1; k <= (int)*map ; k++ )

	mov	ecx, 1
	mov	edi, DWORD PTR [eax]
	cmp	edi, ecx
	jl	SHORT $LN24@unset_f_co
	push	ebx
	npad	6
$LL11@unset_f_co:

; 2330 :      if ( (map[k] & CONMASK) == (conmap_t)n ) break;

	mov	ebx, DWORD PTR [eax+ecx*4]
	and	ebx, 1073741823				; 3fffffffH
	cmp	ebx, edx
	je	SHORT $LN28@unset_f_co

; 2329 :   for ( k = 1; k <= (int)*map ; k++ )

	inc	ecx
	cmp	ecx, edi
	jle	SHORT $LL11@unset_f_co
$LN28@unset_f_co:
	pop	ebx
$LN24@unset_f_co:

; 2331 :   if ( k > (int)*map ) return;

	cmp	ecx, edi
	jg	SHORT $LN27@unset_f_co

; 2332 :   map[0]--;

	dec	edi
	mov	DWORD PTR [eax], edi

; 2333 :   for ( j = k ; j <= (int)*map ; j++ ) map[j] = map[j+1];

	cmp	ecx, edi
	jg	SHORT $LN4@unset_f_co
	npad	2
$LL6@unset_f_co:
	mov	edi, DWORD PTR [eax+ecx*4+4]
	mov	DWORD PTR [eax+ecx*4], edi
	inc	ecx
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LL6@unset_f_co
$LN4@unset_f_co:

; 2334 :   map[j] = 0;

	mov	DWORD PTR [eax+ecx*4], 0

; 2335 :   if ( map[0] == 0 ) unset_attr(f_id,CONSTRAINT);

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN26@unset_f_co
	mov	ecx, DWORD PTR _f_id$[ebp]
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	mov	esi, DWORD PTR [eax+esi]
	mov	ecx, DWORD PTR [esi+12]
	and	DWORD PTR [esi+8], -1025		; fffffbffH
	mov	DWORD PTR [esi+12], ecx
$LN26@unset_f_co:

; 2336 :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN27@unset_f_co

; 2337 :   { struct constraint *con = get_constraint(n);

	and	edx, 1073741823				; 3fffffffH
	imul	edx, 176				; 000000b0H
	add	edx, DWORD PTR _web+652

; 2338 :     if ( con->attr & CON_ENERGY )

	xor	ecx, ecx
	mov	eax, DWORD PTR [edx+32]
	and	eax, 64					; 00000040H
	or	eax, ecx
	je	SHORT $LN27@unset_f_co

; 2339 :        unapply_method(f_id,con->energy_method);

	mov	edx, DWORD PTR [edx+168]
	mov	eax, DWORD PTR _f_id$[ebp]
	push	edx
	push	eax
	call	_unapply_method
	add	esp, 8
$LN27@unset_f_co:
	pop	esi
$LN1@unset_f_co:
	pop	edi

; 2340 :   }
; 2341 : } // end unset_f_constraint_map()

	pop	ebp
	ret	0
_unset_f_constraint_map ENDP
_TEXT	ENDS
PUBLIC	_unset_f_all_constraints
; Function compile flags: /Ogtp
;	COMDAT _unset_f_all_constraints
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_unset_f_all_constraints PROC				; COMDAT

; 2350 : { conmap_t *map;

	push	ebp
	mov	ebp, esp

; 2351 :   int maxcon = EXTRAS(FACET)[F_CONSTR_LIST_ATTR].array_spec.datacount;

	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem

; 2352 :   int i;
; 2353 : 
; 2354 :   if ( maxcon == 0 ) return;

	cmp	DWORD PTR [eax+ecx+88], 0
	je	SHORT $LN1@unset_f_al

; 2355 :   map = get_f_constraint_map(f_id);

	push	ebx
	mov	ebx, DWORD PTR _f_id$[ebp]
	push	esi
	mov	esi, DWORD PTR _web+236
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	push	edi
	mov	edi, DWORD PTR [esi+edx*4]
	add	edi, DWORD PTR [eax+ecx+64]

; 2356 : 
; 2357 :   for ( i = map[0] ; i >= 1 ; i-- )

	mov	esi, DWORD PTR [edi]
	cmp	esi, 1
	jl	SHORT $LN11@unset_f_al
$LL3@unset_f_al:

; 2358 :     unset_f_constraint_map(f_id,map[i]);

	mov	eax, DWORD PTR [edi+esi*4]
	push	eax
	push	ebx
	call	_unset_f_constraint_map
	dec	esi
	add	esp, 8
	cmp	esi, 1
	jge	SHORT $LL3@unset_f_al
$LN11@unset_f_al:
	pop	edi
	pop	esi
	pop	ebx
$LN1@unset_f_al:

; 2359 : } // end unset_f_all_constraints()

	pop	ebp
	ret	0
_unset_f_all_constraints ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@ ; `string'
PUBLIC	??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@	; `string'
PUBLIC	_b_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_set_facet_body
EXTRN	_attach_method:PROC
EXTRN	_find_method_instance:PROC
;	COMDAT ??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@ DB 'body_%d_con_%d_meth'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@
CONST	SEGMENT
??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@ DB 'body_%d_%s_meth', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\skeleton.c
CONST	ENDS
;	COMDAT _set_facet_body
_TEXT	SEGMENT
tv828 = -148						; size = 4
_e_id$89143 = -144					; size = 4
tv869 = -140						; size = 8
tv251 = -140						; size = 8
_inst_num$89180 = -136					; size = 4
tv774 = -132						; size = 4
tv786 = -128						; size = 4
tv472 = -124						; size = 4
_first_fe$89212 = -124					; size = 4
_bb_id$ = -120						; size = 4
_k$89145 = -116						; size = 4
_b_id$GSCopy$ = -112					; size = 4
_first_v$89210 = -108					; size = 4
_fe$89142 = -108					; size = 4
_name$89147 = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_f_id$ = 8						; size = 4
_b_id$ = 12						; size = 4
_set_facet_body PROC					; COMDAT

; 91   : { body_id bb_id;  // the old body

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 92   :   
; 93   :   if ( web.skel[BODY].count == 0 ) return;

	cmp	DWORD PTR _web+400, 0
	push	ebx
	mov	ebx, DWORD PTR _b_id$[ebp]
	push	esi
	mov	esi, DWORD PTR _f_id$[ebp]

; 184  :          for ( k = 1 ; k <= map[0] ; k++ )

	mov	DWORD PTR _b_id$GSCopy$[ebp], ebx
	je	$LN56@set_facet_@2

; 94   :   if ( !valid_id(f_id) ) return;

	test	esi, 268435456				; 10000000H
	je	$LN56@set_facet_@2

; 95   : 
; 96   : #ifdef MPI_EVOLVER
; 97   :   if ( id_task(f_id) != this_task )
; 98   : 	  return; /* imported facets not part of local body chains */
; 99   : #endif
; 100  : 
; 101  :   bb_id = get_facet_body(f_id);

	push	edi
	push	esi
	call	_get_facet_body
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _bb_id$[ebp], edi

; 102  :   if ( equal_id(bb_id,b_id) ) return;

	cmp	edi, ebx
	je	$LN103@set_facet_@2

; 103  : 
; 104  :   /* check if old body of this facet links to this facet */
; 105  :   if ( valid_id(bb_id) )

	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv774[ebp], eax
	je	SHORT $LN101@set_facet_@2

; 106  :   { 
; 107  :     facet_id ff_id = get_body_facet(bb_id);

	push	edi
	call	_get_body_facet
	add	esp, 4

; 108  :     facet_id next_f,prev_f;
; 109  :     
; 110  :     if ( valid_id(ff_id) ) 

	test	eax, 268435456				; 10000000H
	je	SHORT $LN101@set_facet_@2

; 111  :     {
; 112  :       if ( equal_id(f_id,ff_id) )  /* need to give body new link */

	cmp	esi, eax
	jne	SHORT $LN47@set_facet_@2

; 113  :       { 
; 114  :         prev_f = get_prev_body_facet(f_id);

	push	esi
	call	_get_prev_body_facet
	mov	ebx, eax
	add	esp, 4

; 115  :         if ( equal_id(prev_f,f_id) || !valid_id(prev_f) ||
; 116  :          !equal_id(bb_id,get_facet_body(prev_f))  )

	cmp	ebx, esi
	je	SHORT $LN48@set_facet_@2
	test	ebx, 268435456				; 10000000H
	je	SHORT $LN48@set_facet_@2
	push	ebx
	call	_get_facet_body
	add	esp, 4
	cmp	edi, eax
	jne	SHORT $LN48@set_facet_@2

; 118  :         else
; 119  :           set_body_facet(bb_id,prev_f);

	push	ebx
	jmp	SHORT $LN104@set_facet_@2
$LN48@set_facet_@2:

; 117  :             set_body_facet(bb_id,NULLID);

	push	0
$LN104@set_facet_@2:
	push	edi
	call	_set_body_facet
	add	esp, 8
$LN47@set_facet_@2:

; 120  :       }
; 121  :      
; 122  :       /* remove from old body facet list */
; 123  :       next_f = get_next_body_facet(f_id);

	push	esi
	call	_get_next_body_facet

; 124  :       prev_f = get_prev_body_facet(f_id);

	push	esi
	mov	edi, eax
	call	_get_prev_body_facet
	mov	ebx, eax

; 125  :       set_next_body_facet(prev_f,next_f);

	push	edi
	push	ebx
	call	_set_next_body_facet

; 126  :       set_prev_body_facet(next_f,prev_f);

	push	ebx
	push	edi
	call	_set_prev_body_facet
	mov	ebx, DWORD PTR _b_id$GSCopy$[ebp]
	add	esp, 24					; 00000018H
$LN101@set_facet_@2:

; 127  :     }
; 128  :   }
; 129  :  
; 130  :   /* insert in new body list */
; 131  :   if ( valid_id(b_id) )

	mov	eax, ebx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv786[ebp], eax
	je	SHORT $LN44@set_facet_@2

; 132  :   { 
; 133  :     facet_id nextf = get_body_facet(b_id);

	push	ebx
	call	_get_body_facet
	mov	edi, eax
	add	esp, 4

; 134  :     if ( valid_id(nextf) )

	test	edi, 268435456				; 10000000H
	je	SHORT $LN45@set_facet_@2

; 135  :     { facet_id prevf = get_prev_body_facet(nextf);

	push	edi
	call	_get_prev_body_facet

; 136  :       set_next_body_facet(f_id,nextf);

	push	edi
	push	esi
	mov	ebx, eax
	call	_set_next_body_facet

; 137  :       set_prev_body_facet(nextf,f_id);

	push	esi
	push	edi
	call	_set_prev_body_facet

; 138  :       set_next_body_facet(prevf,f_id);

	push	esi
	push	ebx
	call	_set_next_body_facet

; 139  :       set_prev_body_facet(f_id,prevf);

	push	ebx
	push	esi
	call	_set_prev_body_facet
	add	esp, 36					; 00000024H

; 140  :     }
; 141  :     else /* first facet for body */

	jmp	SHORT $LN44@set_facet_@2
$LN45@set_facet_@2:

; 142  :     { 
; 143  :       set_next_body_facet(f_id,f_id);

	push	esi
	push	esi
	call	_set_next_body_facet

; 144  :       set_prev_body_facet(f_id,f_id);

	push	esi
	push	esi
	call	_set_prev_body_facet

; 145  :       set_body_facet(b_id,f_id);

	push	esi
	push	ebx
	call	_set_body_facet
	add	esp, 24					; 00000018H
$LN44@set_facet_@2:

; 146  :     }
; 147  :   }
; 148  : 
; 149  :   if ( inverted(f_id) )  

	mov	ebx, esi
	shr	ebx, 27					; 0000001bH
	and	ebx, 1
	je	SHORT $LN43@set_facet_@2

; 150  :        F_ELID(f_id,F_BODY_LIST_ATTR)[1] = b_id;

	mov	ecx, DWORD PTR _web+236
	mov	edi, DWORD PTR _b_id$GSCopy$[ebp]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	DWORD PTR [edx+eax+4], edi

; 151  :   else  

	jmp	SHORT $LN42@set_facet_@2
$LN43@set_facet_@2:

; 152  :        F_ELID(f_id,F_BODY_LIST_ATTR)[0] = b_id;

	mov	edx, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	edx, DWORD PTR _b_id$GSCopy$[ebp]
	mov	DWORD PTR [eax+ecx], edx
	mov	edi, edx
$LN42@set_facet_@2:

; 153  :  
; 154  :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN99@set_facet_@2

; 155  :   {
; 156  :      if ( web.representation == SOAPFILM )

	mov	eax, DWORD PTR _web+624
	cmp	eax, 2
	jne	$LN40@set_facet_@2

; 157  :      { facetedge_id fe = get_facet_fe(f_id);

	push	esi
	call	_get_facet_fe
	add	esp, 4
	mov	DWORD PTR _fe$89142[ebp], eax

; 158  :        edge_id e_id;
; 159  :        int i;
; 160  :        unsigned int k;
; 161  :        conmap_t *map;
; 162  :        char name[100];
; 163  : 
; 164  :        if ( inverted(f_id) )  /* back facet */

	test	ebx, ebx
	je	SHORT $LN39@set_facet_@2

; 165  :        { 
; 166  :           if ( valid_id(bb_id) ) /* cancel out if already there */

	cmp	DWORD PTR tv774[ebp], 0
	je	SHORT $LN90@set_facet_@2

; 167  :             apply_method_num(inverse_id(f_id),get_body_volmeth(bb_id)); 

	mov	eax, DWORD PTR _bb_id$[ebp]
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+412]
	mov	ecx, esi
	push	eax
	xor	ecx, 134217728				; 08000000H
	push	ecx
	call	_apply_method_num
	add	esp, 8
$LN90@set_facet_@2:

; 168  :           if ( valid_id(b_id) )

	cmp	DWORD PTR tv786[ebp], 0
	je	SHORT $LN91@set_facet_@2

; 169  :             apply_method_num(f_id,get_body_volmeth(b_id)); 

	mov	edx, DWORD PTR _web+348
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+edi*4]
	mov	ecx, DWORD PTR [eax+412]
	push	ecx

; 170  :        }
; 171  :        else /* front facet */

	jmp	SHORT $LN105@set_facet_@2
$LN39@set_facet_@2:

; 172  :        { 
; 173  :           if ( valid_id(bb_id) )

	cmp	DWORD PTR tv774[ebp], 0
	je	SHORT $LN102@set_facet_@2

; 174  :             apply_method_num(inverse_id(f_id),get_body_volmeth(bb_id)); 

	mov	edx, DWORD PTR _bb_id$[ebp]
	mov	eax, DWORD PTR _web+348
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+412]
	mov	eax, esi
	push	edx
	xor	eax, 134217728				; 08000000H
	push	eax
	call	_apply_method_num
	add	esp, 8
$LN102@set_facet_@2:

; 175  :           if ( valid_id(b_id) )

	cmp	DWORD PTR tv786[ebp], 0
	je	SHORT $LN91@set_facet_@2

; 176  :             apply_method_num(f_id,get_body_volmeth(b_id)); 

	mov	ecx, DWORD PTR _web+348
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	eax, DWORD PTR [edx+412]
	push	eax
$LN105@set_facet_@2:
	push	esi
	call	_apply_method_num
	add	esp, 8
$LN91@set_facet_@2:

; 177  :        }
; 178  : 
; 179  :        /* and content integrands on edges */
; 180  :        for ( i = 0 ; i < FACET_EDGES ; i++, fe = get_next_edge(fe))

	mov	edi, DWORD PTR _web+460
	mov	DWORD PTR tv472[ebp], 3
	npad	10
$LL92@set_facet_@2:

; 181  :        { e_id = get_fe_edge(fe);

	mov	eax, DWORD PTR _fe$89142[ebp]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [ecx+edi]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]

; 182  :          if ( !get_eattr(e_id) & BDRY_CONTENT ) continue;

	mov	edx, DWORD PTR _web+124
	mov	DWORD PTR _e_id$89143[ebp], eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+8]
	or	edx, DWORD PTR [eax+12]
	mov	DWORD PTR tv828[ebp], ecx
	jne	SHORT $LN58@set_facet_@2
	mov	edx, 1
	mov	DWORD PTR tv251[ebp+4], 0
	jmp	SHORT $LN59@set_facet_@2
$LN58@set_facet_@2:
	xor	edx, edx
	mov	DWORD PTR tv251[ebp+4], edx
$LN59@set_facet_@2:
	and	edx, 4096				; 00001000H
	xor	esi, esi
	or	edx, esi
	jne	$LN32@set_facet_@2

; 183  :          map = get_e_constraint_map(e_id);

	mov	edx, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	cmp	DWORD PTR [edx+esi+1048], 0
	je	SHORT $LN60@set_facet_@2
	mov	ebx, DWORD PTR [edx+esi+1024]
	add	ebx, eax
	jmp	SHORT $LN61@set_facet_@2
$LN60@set_facet_@2:
	mov	ebx, OFFSET _nullcon
$LN61@set_facet_@2:

; 184  :          for ( k = 1 ; k <= map[0] ; k++ )

	cmp	DWORD PTR [ebx], 1
	mov	DWORD PTR _k$89145[ebp], 1
	jb	$LN32@set_facet_@2
	npad	5
$LL93@set_facet_@2:

; 185  :          { struct constraint *con = get_constraint(map[k]);

	mov	eax, DWORD PTR _k$89145[ebp]
	mov	edx, DWORD PTR [ebx+eax*4]
	and	edx, 1073741823				; 3fffffffH
	mov	esi, edx
	imul	esi, 176				; 000000b0H
	add	esi, DWORD PTR _web+652

; 186  :            int inst_num;
; 187  :            if ( con->attr & CON_CONTENT )

	xor	edi, edi
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR tv869[ebp+4], eax
	mov	eax, ecx
	and	eax, 128				; 00000080H
	or	eax, edi
	je	$LN28@set_facet_@2

; 188  :            { if ( valid_id(bb_id) )

	cmp	DWORD PTR tv774[ebp], edi
	je	$LN25@set_facet_@2

; 189  :              { if ( con->attr & NAMED_THING )
; 190  :                  sprintf(name,"body_%d_%s_meth",ordinal(bb_id)+1,con->name);

	mov	edi, DWORD PTR _bb_id$[ebp]
	and	ecx, 512				; 00000200H
	xor	eax, eax
	and	edi, 134217727				; 07ffffffH
	or	ecx, eax
	je	SHORT $LN24@set_facet_@2
	push	esi
	lea	ecx, DWORD PTR [edi+1]
	push	ecx
	push	OFFSET ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@
	lea	edx, DWORD PTR _name$89147[ebp]
	push	edx

; 191  :                else

	jmp	SHORT $LN106@set_facet_@2
$LN24@set_facet_@2:

; 192  :                  sprintf(name,"body_%d_con_%d_meth",ordinal(bb_id)+1,map[k]&CONMASK);

	push	edx
	lea	eax, DWORD PTR [edi+1]
	push	eax
	push	OFFSET ??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@
	lea	ecx, DWORD PTR _name$89147[ebp]
	push	ecx
$LN106@set_facet_@2:
	call	_sprintf

; 193  :                inst_num = find_method_instance(name);

	lea	edx, DWORD PTR _name$89147[ebp]
	add	esp, 16					; 00000010H
	push	edx
	call	_find_method_instance
	add	esp, 4
	mov	DWORD PTR _inst_num$89180[ebp], eax

; 194  :                if ( inst_num < 0 )

	test	eax, eax
	jns	SHORT $LN22@set_facet_@2

; 195  :                   inst_num = create_body_constraint_content_method(bb_id,map[k]);

	mov	eax, DWORD PTR _k$89145[ebp]
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	edx, DWORD PTR _bb_id$[ebp]
	push	ecx
	push	edx
	call	_create_body_constraint_content_method
	add	esp, 8
	mov	DWORD PTR _inst_num$89180[ebp], eax
$LN22@set_facet_@2:

; 196  :  attach_method(get_body_volquant(bb_id),name);

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+edi*4]
	lea	eax, DWORD PTR _name$89147[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+404]
	push	eax
	call	_attach_method

; 197  :                apply_method_num(inverse_id(e_id),inst_num); /* cancel */

	mov	ecx, DWORD PTR _inst_num$89180[ebp]
	mov	edx, DWORD PTR _e_id$89143[ebp]
	push	ecx
	xor	edx, 134217728				; 08000000H
	push	edx
	call	_apply_method_num
	add	esp, 16					; 00000010H
$LN25@set_facet_@2:

; 198  :              }
; 199  :              if ( valid_id(b_id) )

	cmp	DWORD PTR tv786[ebp], 0
	je	$LN28@set_facet_@2

; 200  :              { if ( con->attr & NAMED_THING ) 

	mov	eax, DWORD PTR [esi+32]

; 201  :                  sprintf(name,"body_%d_%s_meth",ordinal(b_id)+1,con->name);

	mov	edi, DWORD PTR _b_id$GSCopy$[ebp]
	and	eax, 512				; 00000200H
	xor	ecx, ecx
	and	edi, 134217727				; 07ffffffH
	or	eax, ecx
	je	SHORT $LN20@set_facet_@2
	push	esi
	lea	eax, DWORD PTR [edi+1]
	push	eax
	push	OFFSET ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@
	lea	ecx, DWORD PTR _name$89147[ebp]
	push	ecx

; 202  :                else 

	jmp	SHORT $LN107@set_facet_@2
$LN20@set_facet_@2:

; 203  :                  sprintf(name,"body_%d_con_%d_meth",ordinal(b_id)+1,map[k]&CONMASK);

	mov	edx, DWORD PTR _k$89145[ebp]
	mov	eax, DWORD PTR [ebx+edx*4]
	and	eax, 1073741823				; 3fffffffH
	push	eax
	lea	ecx, DWORD PTR [edi+1]
	push	ecx
	push	OFFSET ??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@
	lea	edx, DWORD PTR _name$89147[ebp]
	push	edx
$LN107@set_facet_@2:
	call	_sprintf

; 204  :                inst_num = find_method_instance(name);

	lea	eax, DWORD PTR _name$89147[ebp]
	add	esp, 16					; 00000010H
	push	eax
	call	_find_method_instance
	mov	esi, eax
	add	esp, 4

; 205  :                if ( inst_num < 0 )

	test	esi, esi
	jns	SHORT $LN18@set_facet_@2

; 206  :                   inst_num = create_body_constraint_content_method(b_id,map[k]);

	mov	ecx, DWORD PTR _k$89145[ebp]
	mov	edx, DWORD PTR [ebx+ecx*4]
	mov	eax, DWORD PTR _b_id$GSCopy$[ebp]
	push	edx
	push	eax
	call	_create_body_constraint_content_method
	add	esp, 8
	mov	esi, eax
$LN18@set_facet_@2:

; 207  :  attach_method(get_body_volquant(b_id),name);

	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [edx+edi*4]
	lea	ecx, DWORD PTR _name$89147[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+404]
	push	ecx
	call	_attach_method

; 208  :                apply_method_num(e_id,inst_num);

	mov	edx, DWORD PTR _e_id$89143[ebp]
	push	esi
	push	edx
	call	_apply_method_num
	add	esp, 16					; 00000010H
$LN28@set_facet_@2:

; 184  :          for ( k = 1 ; k <= map[0] ; k++ )

	mov	eax, DWORD PTR _k$89145[ebp]
	inc	eax
	mov	DWORD PTR _k$89145[ebp], eax
	cmp	eax, DWORD PTR [ebx]
	jbe	$LL93@set_facet_@2
	mov	edi, DWORD PTR _web+460
	mov	ecx, DWORD PTR tv828[ebp]
$LN32@set_facet_@2:

; 177  :        }
; 178  : 
; 179  :        /* and content integrands on edges */
; 180  :        for ( i = 0 ; i < FACET_EDGES ; i++, fe = get_next_edge(fe))

	test	DWORD PTR _fe$89142[ebp], 134217728	; 08000000H
	je	SHORT $LN71@set_facet_@2
	mov	eax, DWORD PTR [ecx+edi]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _fe$89142[ebp], eax
	jmp	SHORT $LN89@set_facet_@2
$LN71@set_facet_@2:
	mov	ecx, DWORD PTR [ecx+edi]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _fe$89142[ebp], edx
$LN89@set_facet_@2:
	dec	DWORD PTR tv472[ebp]
	jne	$LL92@set_facet_@2

; 209  :              }
; 210  :            }
; 211  :          }
; 212  :        }
; 213  :      }
; 214  :      else if ( web.representation == STRING )

	jmp	$LN99@set_facet_@2
$LN40@set_facet_@2:
	cmp	eax, 1
	jne	$LN99@set_facet_@2

; 215  :      {
; 216  :        vertex_id first_v = NULLID, last_v = NULLID;
; 217  :        
; 218  :        // Apply body method to edges of face
; 219  :        facetedge_id first_fe = get_facet_fe(f_id);

	push	esi
	call	_get_facet_fe
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _first_fe$89212[ebp], edi

; 220  :        if ( valid_id(first_fe) )

	test	edi, 268435456				; 10000000H
	je	$LN99@set_facet_@2

; 221  :        { edge_id e_id;
; 222  :          if ( inverted(f_id) )
; 223  :          { facetedge_id nextfe=first_fe;
; 224  :            /* go backwards */
; 225  :            first_v = get_fe_headv(first_fe);

	push	edi
	call	_get_fe_edge
	push	eax
	test	ebx, ebx
	je	SHORT $LN14@set_facet_@2
	call	_get_edge_headv
	add	esp, 8
	mov	DWORD PTR _first_v$89210[ebp], eax
	npad	8
$LL13@set_facet_@2:

; 226  :            do
; 227  :            { e_id = get_fe_edge(nextfe);

	mov	eax, DWORD PTR _web+460
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	edx, DWORD PTR [ecx+20]
	mov	ebx, edi
	and	ebx, 134217728				; 08000000H
	xor	edx, ebx

; 228  :              check_edge_vol_methods(e_id);

	push	edx
	call	_check_edge_vol_methods

; 229  :              last_v = get_fe_tailv(nextfe);

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [esi+eax]
	mov	edx, DWORD PTR [ecx+20]
	xor	edx, ebx
	push	edx
	call	_get_edge_tailv

; 230  :              nextfe = get_prev_edge(nextfe);

	push	edi
	mov	esi, eax
	call	_get_prev_edge
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 231  :            } while ( valid_id(nextfe) && !equal_id(nextfe,first_fe) );

	test	edi, 268435456				; 10000000H
	je	SHORT $LN97@set_facet_@2
	cmp	edi, DWORD PTR _first_fe$89212[ebp]
	jne	SHORT $LL13@set_facet_@2

; 232  :            if ( valid_id(nextfe) )
; 233  :            { first_v = last_v = NULLID;
; 234  :            }
; 235  :          }
; 236  :          else /* forward */

	jmp	SHORT $LN4@set_facet_@2
$LN14@set_facet_@2:

; 237  :          { facetedge_id nextfe=first_fe;
; 238  :            /* go forwards */
; 239  :            first_v = get_fe_tailv(first_fe);

	call	_get_edge_tailv
	add	esp, 8
	mov	DWORD PTR _first_v$89210[ebp], eax
$LL7@set_facet_@2:

; 240  :            do
; 241  :            { e_id = get_fe_edge(nextfe);

	mov	eax, DWORD PTR _web+460
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	edx, DWORD PTR [ecx+20]
	mov	ebx, edi
	and	ebx, 134217728				; 08000000H
	xor	edx, ebx

; 242  :              check_edge_vol_methods(e_id);

	push	edx
	call	_check_edge_vol_methods

; 243  :              last_v = get_fe_headv(nextfe);

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [esi+eax]
	mov	edx, DWORD PTR [ecx+20]
	xor	edx, ebx
	push	edx
	call	_get_edge_headv

; 244  :              nextfe = get_next_edge(nextfe);

	push	edi
	mov	esi, eax
	call	_get_next_edge
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 245  :            } while ( valid_id(nextfe) && !equal_id(nextfe,first_fe) );

	test	edi, 268435456				; 10000000H
	je	SHORT $LN97@set_facet_@2
	cmp	edi, DWORD PTR _first_fe$89212[ebp]
	jne	SHORT $LL7@set_facet_@2
$LN4@set_facet_@2:

; 246  :            if ( valid_id(nextfe) )

	test	edi, 268435456				; 10000000H
	je	SHORT $LN97@set_facet_@2

; 247  :            { first_v = last_v = NULLID;

	xor	esi, esi
	mov	DWORD PTR _first_v$89210[ebp], esi
$LN97@set_facet_@2:

; 248  :            }
; 249  :          }
; 250  : 
; 251  :          // Content integrands on endpoints
; 252  :          if ( valid_id(first_v) )

	mov	eax, DWORD PTR _first_v$89210[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2@set_facet_@2

; 253  :            assure_v_constraints(first_v);

	push	eax
	call	_assure_v_constraints
	add	esp, 4
$LN2@set_facet_@2:

; 254  :          if ( valid_id(last_v) )

	test	esi, 268435456				; 10000000H
	je	SHORT $LN99@set_facet_@2

; 255  :            assure_v_constraints(last_v);

	push	esi
	call	_assure_v_constraints
	add	esp, 4
$LN99@set_facet_@2:

; 256  :         
; 257  :        }      
; 258  :      }
; 259  :   }
; 260  :    
; 261  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN103@set_facet_@2:
	pop	edi
$LN56@set_facet_@2:

; 262  : 
; 263  : }  // end set_facet_body()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_set_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_vertex_length_star
; Function compile flags: /Ogtp
;	COMDAT _get_vertex_length_star
_TEXT	SEGMENT
_star$ = -8						; size = 8
_v_id$ = 8						; size = 4
_get_vertex_length_star PROC				; COMDAT

; 298  : { edge_id e_id = get_vertex_edge(v_id);

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	eax, DWORD PTR _v_id$[ebp]

; 299  :   edge_id firste = e_id;
; 300  :   REAL star = 0.0;

	fldz
	mov	ecx, DWORD PTR _web+12
	fst	QWORD PTR _star$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	push	esi
	mov	esi, DWORD PTR [eax+28]

; 301  :   if ( get_vattr(v_id) & (Q_MIDPOINT|Q_MIDEDGE) ) return get_edge_length(e_id);

	mov	eax, DWORD PTR [eax+8]
	and	eax, 4325376				; 00420000H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN5@get_vertex@2
	push	esi
	fstp	ST(0)
	call	_get_edge_length
	add	esp, 4
	pop	esi

; 305  :   return star;
; 306  : } // end get_vertex_length_star()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@get_vertex@2:

; 302  :   if ( !valid_id(e_id) ) return 0.0;

	test	esi, 268435456				; 10000000H
	je	SHORT $LN6@get_vertex@2
	push	edi
	mov	edi, esi
	or	edi, 134217728				; 08000000H
	npad	1
$LL18@get_vertex@2:

; 303  :   do { star += get_edge_length(e_id); e_id = get_next_tail_edge(e_id);}

	push	esi

; 304  :   while ( !equal_element(e_id,firste) );

	fstp	ST(0)
	call	_get_edge_length
	fadd	QWORD PTR _star$[ebp]
	mov	eax, DWORD PTR _web+124
	mov	edx, esi
	shr	edx, 27					; 0000001bH
	fst	QWORD PTR _star$[ebp]
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	and	edx, 1
	mov	esi, DWORD PTR [ecx+edx*4+32]
	mov	edx, esi
	or	edx, 134217728				; 08000000H
	add	esp, 4
	cmp	edx, edi
	jne	SHORT $LL18@get_vertex@2
	pop	edi
$LN6@get_vertex@2:
	pop	esi

; 305  :   return star;
; 306  : } // end get_vertex_length_star()

	mov	esp, ebp
	pop	ebp
	ret	0
_get_vertex_length_star ENDP
_TEXT	ENDS
PUBLIC	_get_vertex_area_star
; Function compile flags: /Ogtp
;	COMDAT _get_vertex_area_star
_TEXT	SEGMENT
_star$ = -8						; size = 8
_v_id$ = 8						; size = 4
_get_vertex_area_star PROC				; COMDAT

; 315  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 316  :   REAL star = 0.0;

	fldz

; 317  : 
; 318  :   if ( web.representation == STRING ) 

	mov	eax, DWORD PTR _web+624
	fstp	QWORD PTR _star$[ebp]
	cmp	eax, 1
	jne	SHORT $LN12@get_vertex@3

; 319  :       return get_vertex_length_star(v_id);

	mov	eax, DWORD PTR _v_id$[ebp]
	push	eax
	call	_get_vertex_length_star
	add	esp, 4

; 345  : } // end get_vertex_area_star()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@get_vertex@3:
	push	ebx
	push	esi
	push	edi

; 320  :   else if ( web.representation == SOAPFILM )

	cmp	eax, 2
	jne	$LN10@get_vertex@3

; 321  :   {
; 322  :      facetedge_id fe_id = get_vertex_first_facet(v_id);

	mov	ecx, DWORD PTR _v_id$[ebp]
	push	ecx
	call	_get_vertex_first_facet
	mov	esi, eax
	add	esp, 4

; 323  :      facetedge_id firstfe = fe_id;
; 324  :      facet_id f_id;
; 325  :      if ( !valid_id(fe_id) ) return 0.0;

	test	esi, 268435456				; 10000000H
	je	$LN25@get_vertex@3
	mov	ebx, esi
	or	ebx, 134217728				; 08000000H
$LL8@get_vertex@3:

; 326  :      do 
; 327  :      { f_id = get_fe_facet(fe_id);

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN16@get_vertex@3
	mov	edi, DWORD PTR _NULLFACET
	jmp	SHORT $LN15@get_vertex@3
$LN16@get_vertex@3:
	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edi, DWORD PTR [ecx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN15@get_vertex@3
	xor	edi, 134217728				; 08000000H
$LN15@get_vertex@3:

; 328  :        star += get_facet_area(f_id); 

	push	edi
	call	_recalc_facet_area
	mov	edx, DWORD PTR _web+236

; 329  :        fe_id = get_next_vertex_facet(v_id,fe_id);

	mov	ecx, DWORD PTR _v_id$[ebp]
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+edi*4]
	fld	QWORD PTR [eax+40]
	push	esi
	fadd	QWORD PTR _star$[ebp]
	push	ecx
	fstp	QWORD PTR _star$[ebp]
	call	_get_next_vertex_facet
	mov	esi, eax

; 330  :      }
; 331  :      while ( !equal_element(fe_id,firstfe) );

	mov	edx, esi
	or	edx, 134217728				; 08000000H
	add	esp, 12					; 0000000cH
	cmp	edx, ebx
	jne	SHORT $LL8@get_vertex@3

; 343  :   } 
; 344  :   return star;

	fld	QWORD PTR _star$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 345  : } // end get_vertex_area_star()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@get_vertex@3:

; 332  :   }
; 333  :   else /* SIMPLEX */
; 334  :   {
; 335  :      facet_id f_id = get_vertex_first_facet(v_id);

	mov	ebx, DWORD PTR _v_id$[ebp]
	push	ebx
	call	_get_vertex_first_facet
	mov	esi, eax
	add	esp, 4

; 336  :      facet_id firstf = f_id;
; 337  :      if ( !valid_id(f_id) ) return 0.0;

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN20@get_vertex@3
$LN25@get_vertex@3:
	fldz
	pop	edi
	pop	esi
	pop	ebx

; 345  : } // end get_vertex_area_star()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@get_vertex@3:

; 336  :      facet_id firstf = f_id;
; 337  :      if ( !valid_id(f_id) ) return 0.0;

	mov	edi, esi
	or	edi, 134217728				; 08000000H
	npad	2
$LL3@get_vertex@3:

; 338  :      do 
; 339  :      { star += get_facet_area(f_id); 

	push	esi
	call	_recalc_facet_area
	mov	ecx, DWORD PTR _web+236
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]

; 340  :        f_id = get_next_vertex_facet(v_id,f_id);

	push	esi
	fadd	QWORD PTR _star$[ebp]
	push	ebx
	fstp	QWORD PTR _star$[ebp]
	call	_get_next_vertex_facet
	mov	esi, eax

; 341  :      }
; 342  :      while ( !equal_element(f_id,firstf) );

	or	eax, 134217728				; 08000000H
	add	esp, 12					; 0000000cH
	cmp	eax, edi
	jne	SHORT $LL3@get_vertex@3

; 343  :   } 
; 344  :   return star;

	fld	QWORD PTR _star$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 345  : } // end get_vertex_area_star()

	mov	esp, ebp
	pop	ebp
	ret	0
_get_vertex_area_star ENDP
_TEXT	ENDS
PUBLIC	_dup_facet
; Function compile flags: /Ogtp
;	COMDAT _dup_facet
_TEXT	SEGMENT
_sign$ = -4						; size = 4
_f_id_p$ = 8						; size = 4
_old_f$ = 8						; size = 4
_dup_facet PROC						; COMDAT

; 717  : { 

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi

; 718  :   facet_id f_id;
; 719  :   struct facet *f_id_p;
; 720  :   body_id b_id,*fb;
; 721  :   int sign = inverted(old_f);

	mov	edi, DWORD PTR _old_f$[ebp]
	mov	eax, edi

; 722  : 
; 723  :   old_f = positive_id(old_f);  /* since new facet id will be positive */
; 724  :   
; 725  :   f_id = new_element(FACET,NULLID,NULLID);

	push	0
	shr	eax, 27					; 0000001bH
	and	eax, 1
	push	0
	push	2
	mov	DWORD PTR _sign$[ebp], eax
	and	edi, -134217729				; f7ffffffH
	call	_new_element

; 726  :   f_id_p = fptr(f_id);
; 727  :   memcpy((char *)&(f_id_p->attr),(char *)&(elptr(old_f)->attr),
; 728  :               web.sizes[FACET] - ((char*)&(f_id_p->attr)-(char*)f_id_p));

	mov	ecx, DWORD PTR _web+568
	mov	edx, edi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	ebx, eax
	mov	eax, DWORD PTR _web+236
	add	ecx, -8					; fffffff8H
	push	ecx
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+eax]
	add	ecx, 8
	mov	DWORD PTR _f_id_p$[ebp], eax
	push	ecx
	add	eax, 8
	push	eax
	call	_memcpy

; 729  :   f_id_p->self_id = f_id; /* restore new id */

	mov	edx, DWORD PTR _f_id_p$[ebp]

; 730  :   set_attr(f_id,NEWELEMENT);

	mov	eax, ebx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	DWORD PTR [edx+16], ebx
	mov	ecx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [ecx+esi]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 4
	add	esp, 24					; 00000018H
	mov	DWORD PTR [eax+12], edx

; 731  : 
; 732  :   /* update body facet lists */
; 733  :   if ( web.skel[BODY].count )

	cmp	DWORD PTR _web+400, 0
	je	$LN10@dup_facet

; 734  :   { fb = F_ELID(f_id,F_BODY_LIST_ATTR);

	mov	eax, DWORD PTR _web+236
	mov	eax, DWORD PTR [esi+eax]
	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+784]

; 735  :     fb[0] = fb[1] = NULLID; /* so set_facet_body works */

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], ecx

; 736  :     fb = F_ELID(f_id,F_NEXT_BFACET_ATTR);

	mov	eax, DWORD PTR _web+236
	mov	esi, DWORD PTR [esi+eax]
	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	add	esi, DWORD PTR [edx+eax+1264]

; 737  :     fb[0] = fb[1] = fb[2] = fb[3] = NULLID;
; 738  :     b_id = get_facet_body(old_f);

	push	edi
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi], ecx
	call	_get_facet_body
	add	esp, 4

; 739  :     if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN2@dup_facet

; 740  :       set_facet_body(f_id,b_id);

	push	eax
	push	ebx
	call	_set_facet_body
	add	esp, 8
$LN2@dup_facet:

; 741  :     b_id = get_facet_body(inverse_id(old_f));

	xor	edi, 134217728				; 08000000H
	push	edi
	call	_get_facet_body
	add	esp, 4

; 742  :     if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN10@dup_facet

; 743  :       set_facet_body(inverse_id(f_id),b_id);

	mov	ecx, ebx
	push	eax
	xor	ecx, 134217728				; 08000000H
	push	ecx
	call	_set_facet_body
	add	esp, 8
$LN10@dup_facet:

; 744  :   }
; 745  : 
; 746  :   return sign ? inverse_id(f_id) : f_id;

	cmp	DWORD PTR _sign$[ebp], 0
	je	SHORT $LN6@dup_facet
	xor	ebx, 134217728				; 08000000H
$LN6@dup_facet:
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 747  : } // end dup_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
_dup_facet ENDP
_TEXT	ENDS
PUBLIC	_new_body
; Function compile flags: /Ogtp
;	COMDAT _new_body
_TEXT	SEGMENT
_four$ = -8						; size = 4
_two$ = -4						; size = 4
_new_body PROC						; COMDAT

; 756  : { int two = 2;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 757  :   int four = 4;
; 758  :   body_id b_id;
; 759  : 
; 760  :   expand_attribute(FACET,F_BODY_LIST_ATTR,&two);

	lea	eax, DWORD PTR _two$[ebp]
	push	eax
	push	3
	push	2
	mov	DWORD PTR _two$[ebp], 2
	mov	DWORD PTR _four$[ebp], 4
	call	_expand_attribute

; 761  :   expand_attribute(FACET,F_NEXT_BFACET_ATTR,&four);

	lea	ecx, DWORD PTR _four$[ebp]
	push	ecx
	push	5
	push	2
	call	_expand_attribute

; 762  :   b_id = new_element(BODY,NULLID,NULLID);

	push	0
	push	0
	push	3
	call	_new_element
	mov	esi, eax
	add	esp, 36					; 00000024H

; 763  :   set_body_facet(b_id,NULLID);

	test	esi, 268435456				; 10000000H
	je	SHORT $LN4@new_body
	mov	eax, DWORD PTR _web+348
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+400], 0
$LN4@new_body:

; 764  :   set_attr(b_id,WANT_CENTEROFMASS);

	mov	edx, esi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [eax+8]
	or	DWORD PTR [eax+12], 2
	mov	DWORD PTR [eax+8], edx

; 765  :   if ( everything_quantities_flag ) 

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN9@new_body

; 766  :       convert_new_body_to_quantity(b_id);

	push	esi
	call	_convert_new_body_to_quantity
	add	esp, 4
$LN9@new_body:

; 767  :   web.bodycount++;

	inc	DWORD PTR _web+1500

; 768  :   return b_id;

	mov	eax, esi
	pop	esi

; 769  : } // end new_body()

	mov	esp, ebp
	pop	ebp
	ret	0
_new_body ENDP
_TEXT	ENDS
PUBLIC	_set_fe_facet
; Function compile flags: /Ogtp
;	COMDAT _set_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_f_id$ = 12						; size = 4
_set_fe_facet PROC					; COMDAT

; 856  : { facet_id oldf = get_fe_facet(fe_id);

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _fe_id$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _web+460
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN7@set_fe_fac
	mov	ebx, DWORD PTR _NULLFACET
	jmp	SHORT $LN8@set_fe_fac
$LN7@set_fe_fac:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [edx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN6@set_fe_fac
	xor	ecx, 134217728				; 08000000H
$LN6@set_fe_fac:
	mov	ebx, ecx
$LN8@set_fe_fac:

; 857  : 
; 858  :   feptr(fe_id)->fe_facet_id = inverted(fe_id) ? inverse_id(f_id) : f_id;

	mov	esi, DWORD PTR _f_id$[ebp]
	mov	edx, esi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN5@set_fe_fac
	xor	edx, 134217728				; 08000000H
$LN5@set_fe_fac:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+edi]
	mov	DWORD PTR [edi+24], edx

; 859  : 
; 860  :   if ( web.representation==STRING && everything_quantities_flag &&
; 861  :         !equal_id(oldf,f_id) )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN1@set_fe_fac
	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN1@set_fe_fac
	cmp	ebx, esi
	je	SHORT $LN1@set_fe_fac

; 862  :   { /* detach old volume quantity and attach new volume quantity */    
; 863  :     edge_id e_id = get_fe_edge(fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ecx+edx]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 864  :     check_edge_vol_methods(e_id);

	push	eax
	call	_check_edge_vol_methods
	add	esp, 4
$LN1@set_fe_fac:
	pop	edi
	pop	esi
	pop	ebx

; 865  :   }
; 866  : } // end set_fe_facet()

	pop	ebp
	ret	0
_set_fe_facet ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DM@HPGENDJ@Attribute?5extra_boundary_param?5s@ ; `string'
PUBLIC	??_C@_0DG@LKNHBPMF@Attribute?5extra_boundary_param?5m@ ; `string'
PUBLIC	??_C@_0BF@CKLEHKEG@extra_boundary_param?$AA@	; `string'
PUBLIC	??_C@_0DG@EADCCJBL@Attribute?5extra_boundary?5should?5@ ; `string'
PUBLIC	??_C@_0DD@JPCAAFOI@Attribute?5extra_boundary?5must?5be@ ; `string'
PUBLIC	??_C@_0P@FKIKICLO@extra_boundary?$AA@		; `string'
PUBLIC	??_C@_0EA@JOGHJOED@Extra?5attribute?5?$CC?$CFs?$CC?5has?5?$CFd?5dime@ ; `string'
PUBLIC	_add_attribute
EXTRN	_extra_bdry_param_attr:DWORD
EXTRN	_extra_bdry_attr:DWORD
EXTRN	_strncpy:PROC
EXTRN	_dy_realloc:PROC
;	COMDAT ??_C@_0DM@HPGENDJ@Attribute?5extra_boundary_param?5s@
CONST	SEGMENT
??_C@_0DM@HPGENDJ@Attribute?5extra_boundary_param?5s@ DB 'Attribute extra'
	DB	'_boundary_param should be vertex attribute.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@LKNHBPMF@Attribute?5extra_boundary_param?5m@
CONST	SEGMENT
??_C@_0DG@LKNHBPMF@Attribute?5extra_boundary_param?5m@ DB 'Attribute extr'
	DB	'a_boundary_param must be of type real.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CKLEHKEG@extra_boundary_param?$AA@
CONST	SEGMENT
??_C@_0BF@CKLEHKEG@extra_boundary_param?$AA@ DB 'extra_boundary_param', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@EADCCJBL@Attribute?5extra_boundary?5should?5@
CONST	SEGMENT
??_C@_0DG@EADCCJBL@Attribute?5extra_boundary?5should?5@ DB 'Attribute ext'
	DB	'ra_boundary should be vertex attribute.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JPCAAFOI@Attribute?5extra_boundary?5must?5be@
CONST	SEGMENT
??_C@_0DD@JPCAAFOI@Attribute?5extra_boundary?5must?5be@ DB 'Attribute ext'
	DB	'ra_boundary must be of type integer.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FKIKICLO@extra_boundary?$AA@
CONST	SEGMENT
??_C@_0P@FKIKICLO@extra_boundary?$AA@ DB 'extra_boundary', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@JOGHJOED@Extra?5attribute?5?$CC?$CFs?$CC?5has?5?$CFd?5dime@
CONST	SEGMENT
??_C@_0EA@JOGHJOED@Extra?5attribute?5?$CC?$CFs?$CC?5has?5?$CFd?5dime@ DB 'E'
	DB	'xtra attribute "%s" has %d dimensions, exceeding limit of %d.'
	DB	0aH, 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _add_attribute
_TEXT	SEGMENT
_oldsize$ = -12						; size = 4
tv321 = -8						; size = 4
_newcount$ = -4						; size = 4
_e_type$ = 8						; size = 4
_name$ = 12						; size = 4
_attr_type$ = 16					; size = 4
_dim$ = 20						; size = 4
_dims$ = 24						; size = 4
_dumpflag$ = 28						; size = 4
_code$ = 32						; size = 4
_mpi_propagate$ = 36					; size = 4
_add_attribute PROC					; COMDAT

; 1324 : { int newsize,newcount=0;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1325 :   struct extra *ex;
; 1326 :   int oldsize;
; 1327 :   int att_inx;
; 1328 : 
; 1329 :   att_inx = find_attribute(e_type,name);

	mov	eax, DWORD PTR _name$[ebp]
	push	esi
	mov	esi, DWORD PTR _e_type$[ebp]
	push	eax
	push	esi
	mov	DWORD PTR _newcount$[ebp], 0
	call	_find_attribute
	add	esp, 8

; 1330 :   if ( att_inx >= 0 )

	test	eax, eax

; 1331 :     return att_inx;

	jns	$LN27@add_attrib

; 1332 : 
; 1333 : #ifdef MPI_EVOLVER
; 1334 :   if ( (this_task == MASTER_TASK) && (mpi_propagate==MPI_PROPAGATE) && !mpi_initialization_flag )
; 1335 :   { struct mpi_command message;
; 1336 :     int i;
; 1337 : 
; 1338 :     if ( code )
; 1339 :     { kb_error(4525,"MPI Evolver doesn't do code attributes yet.\n",
; 1340 :           RECOVERABLE);
; 1341 :     }
; 1342 :     message.cmd = mpi_ADD_ATTRIBUTE;
; 1343 :     strncpy(message.name,name,MPI_NAME_SIZE);
; 1344 :     message.i = attr_type;
; 1345 :     message.type = e_type;
; 1346 :     message.mode = dumpflag;
; 1347 : 	message.size = dims ? 1 : 0; /* just using as indicator */
; 1348 :     message.count = dim;
; 1349 : 	if ( dim )
; 1350 :       for (i = 0 ; i < dim ; i++ )
; 1351 : 		  message.data[i] = dims ? dims[i] : 0;
; 1352 : 	else 
; 1353 : 		message.data[0] = dims ? dims[0] : 0;
; 1354 :     MPI_Bcast(&message,sizeof(struct mpi_command),MPI_BYTE,MASTER_TASK,
; 1355 :         MPI_COMM_WORLD);
; 1356 :   }
; 1357 : #endif
; 1358 : 
; 1359 :   if ( web.skel[e_type].extra_count >= web.skel[e_type].maxextra-1 )

	push	ebx
	mov	ebx, esi
	imul	ebx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ebx+100]
	lea	ecx, DWORD PTR [eax-1]
	push	edi
	mov	DWORD PTR tv321[ebp], ebx
	cmp	DWORD PTR _web[ebx+108], ecx
	jl	SHORT $LN25@add_attrib

; 1360 :   { web.skel[e_type].dy_extras = 
; 1361 :        dy_realloc(web.skel[e_type].dy_extras,
; 1362 :        (web.skel[e_type].maxextra+10),sizeof(struct extra));

	mov	edx, DWORD PTR _web[ebx+104]
	push	240					; 000000f0H
	add	eax, 10					; 0000000aH
	push	eax
	push	edx
	call	_dy_realloc
	add	esp, 12					; 0000000cH

; 1363 :     web.skel[e_type].maxextra += 10;

	add	DWORD PTR _web[ebx+100], 10		; 0000000aH
	mov	DWORD PTR _web[ebx+104], eax
$LN25@add_attrib:

; 1364 :   }
; 1365 : 
; 1366 :   /* expand space */ 
; 1367 :   /* get old used space, minus any padding, and pad to proper size */
; 1368 :   if ( web.skel[e_type].extra_count > 0 )

	mov	ecx, DWORD PTR _web[ebx+108]
	test	ecx, ecx
	jle	SHORT $LN24@add_attrib

; 1369 :   { ex = EXTRAS(e_type) + web.skel[e_type].extra_count-1;

	mov	edx, DWORD PTR _web[ebx+104]
	mov	eax, ecx
	imul	eax, 240				; 000000f0H
	add	edx, eax
	mov	eax, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+eax-240]

; 1370 :     oldsize = ex->offset + ex->array_spec.datacount*datatype_size[ex->type];

	mov	edx, DWORD PTR [eax+68]
	mov	edi, DWORD PTR _datatype_size[edx*4]
	imul	edi, DWORD PTR [eax+88]
	add	edi, DWORD PTR [eax+64]
	jmp	SHORT $LN39@add_attrib
$LN24@add_attrib:

; 1371 :   }
; 1372 :   else oldsize = web.sizes[e_type];

	mov	edi, DWORD PTR _web[esi*4+560]
$LN39@add_attrib:

; 1373 :   if  (oldsize % datatype_size[attr_type])

	mov	eax, DWORD PTR _attr_type$[ebp]
	mov	esi, DWORD PTR _datatype_size[eax*4]
	mov	eax, edi
	cdq
	idiv	esi
	mov	DWORD PTR _oldsize$[ebp], edi
	test	edx, edx
	je	SHORT $LN22@add_attrib

; 1374 :     oldsize += datatype_size[attr_type] - (oldsize % datatype_size[attr_type]);

	sub	esi, edx
	add	edi, esi
	mov	DWORD PTR _oldsize$[ebp], edi
$LN22@add_attrib:

; 1375 : 
; 1376 :   ex = EXTRAS(e_type) + web.skel[e_type].extra_count;

	mov	ebx, DWORD PTR _web[ebx+104]
	imul	ecx, 240				; 000000f0H

; 1377 : 
; 1378 :   if ( dim == 0 ) newcount = dims ? dims[0] : 0;

	mov	esi, DWORD PTR _dim$[ebp]
	add	ebx, ecx
	add	ebx, DWORD PTR _dymem
	xor	ecx, ecx
	cmp	esi, ecx
	jne	SHORT $LN21@add_attrib
	mov	eax, DWORD PTR _dims$[ebp]
	cmp	eax, ecx
	je	SHORT $LN29@add_attrib
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _newcount$[ebp], ecx
	jmp	SHORT $LN13@add_attrib
$LN21@add_attrib:

; 1379 :   else if ( dim > MAXARRAYDIMS )

	cmp	esi, 8
	jle	SHORT $LN19@add_attrib

; 1380 :   { sprintf(errmsg,"Extra attribute \"%s\" has %d dimensions, exceeding limit of %d.\n", name,dim,MAXARRAYDIMS);

	mov	edx, DWORD PTR _name$[ebp]
	push	8
	push	esi
	push	edx
	push	OFFSET ??_C@_0EA@JOGHJOED@Extra?5attribute?5?$CC?$CFs?$CC?5has?5?$CFd?5dime@
	push	OFFSET _errmsg
	call	_sprintf

; 1381 :     kb_error(2510,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2510					; 000009ceH
	call	_kb_error
	add	esp, 32					; 00000020H
	jmp	SHORT $LN33@add_attrib
$LN19@add_attrib:

; 1382 :   }
; 1383 :   else if ( dims == NULL ) newcount = 0;

	cmp	DWORD PTR _dims$[ebp], ecx
	jne	SHORT $LN17@add_attrib
$LN29@add_attrib:
	mov	DWORD PTR _newcount$[ebp], ecx

; 1384 :   else

	jmp	SHORT $LN33@add_attrib
$LN17@add_attrib:

; 1385 :   { int i;
; 1386 :     for ( i = 0, newcount = 1 ; i < dim ; i++ )

	xor	eax, eax
	mov	DWORD PTR _newcount$[ebp], 1
	cmp	esi, ecx
	jle	SHORT $LN36@add_attrib
	lea	edx, DWORD PTR [ebx+96]
	npad	7
$LL35@add_attrib:

; 1387 :     { newcount *= dims[i];

	mov	ecx, DWORD PTR _dims$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	edi, ecx
	imul	edi, DWORD PTR _newcount$[ebp]

; 1388 :       ex->array_spec.sizes[i] = dims[i];

	mov	DWORD PTR [edx], ecx
	inc	eax
	add	edx, 4
	mov	DWORD PTR _newcount$[ebp], edi
	cmp	eax, esi
	jl	SHORT $LL35@add_attrib

; 1385 :   { int i;
; 1386 :     for ( i = 0, newcount = 1 ; i < dim ; i++ )

	mov	edi, DWORD PTR _oldsize$[ebp]
$LN13@add_attrib:

; 1389 :     }
; 1390 :   }
; 1391 :   if ( (newcount > 0) || (oldsize > web.sizes[e_type]) )

	cmp	DWORD PTR _newcount$[ebp], 0
	jg	SHORT $LN36@add_attrib
$LN33@add_attrib:
	mov	edx, DWORD PTR _e_type$[ebp]
	cmp	edi, DWORD PTR _web[edx*4+560]
	jle	SHORT $LN12@add_attrib
$LN36@add_attrib:

; 1392 :   { newsize =  newcount*datatype_size[attr_type];

	mov	eax, DWORD PTR _attr_type$[ebp]
	mov	ecx, DWORD PTR _datatype_size[eax*4]
	imul	ecx, DWORD PTR _newcount$[ebp]

; 1393 :     expand(e_type,oldsize + newsize); 

	mov	edx, DWORD PTR _e_type$[ebp]
	add	ecx, edi
	push	ecx
	push	edx
	call	_expand
	add	esp, 8
$LN12@add_attrib:

; 1394 :   }
; 1395 :   strncpy(ex->name,name,ATTR_NAME_SIZE);

	mov	eax, DWORD PTR _name$[ebp]
	push	63					; 0000003fH
	push	eax
	push	ebx
	call	_strncpy

; 1396 :   ex->type = attr_type;

	mov	eax, DWORD PTR _attr_type$[ebp]

; 1397 :   ex->array_spec.datatype = attr_type;
; 1398 :   ex->array_spec.itemsize = datatype_size[attr_type];
; 1399 :  
; 1400 :   ex->offset = oldsize;
; 1401 :   ex->array_spec.datacount = newcount;

	mov	edx, DWORD PTR _newcount$[ebp]
	mov	DWORD PTR [ebx+68], eax
	mov	DWORD PTR [ebx+80], eax
	mov	ecx, DWORD PTR _datatype_size[eax*4]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx+84], ecx
	mov	DWORD PTR [ebx+64], edi
	mov	DWORD PTR [ebx+88], edx

; 1402 :   ex->array_spec.dim = dim;

	mov	DWORD PTR [ebx+76], esi

; 1403 :   if ( dim > 0 ) ex->flags |= DIMENSIONED_ATTR;

	test	esi, esi
	jle	SHORT $LN10@add_attrib
	or	DWORD PTR [ebx+232], 4
$LN10@add_attrib:

; 1404 :   if ( code ) ex->code = *code;

	mov	esi, DWORD PTR _code$[ebp]
	test	esi, esi
	je	SHORT $LN9@add_attrib
	lea	edi, DWORD PTR [ebx+128]
	mov	ecx, 26					; 0000001aH
	rep movsd
$LN9@add_attrib:

; 1405 :   if ( dumpflag ) ex->flags |= DUMP_ATTR;

	cmp	DWORD PTR _dumpflag$[ebp], 0
	mov	edi, 1
	je	SHORT $LN8@add_attrib
	or	DWORD PTR [ebx+232], edi
$LN8@add_attrib:

; 1406 : 
; 1407 :   if ( stricmp(name,EXTRA_BDRY_NAME) == 0 )

	mov	esi, DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0P@FKIKICLO@extra_boundary?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@add_attrib

; 1408 :   { extra_bdry_attr = web.skel[e_type].extra_count;

	mov	esi, DWORD PTR tv321[ebp]
	mov	eax, DWORD PTR _web[esi+108]
	mov	DWORD PTR _extra_bdry_attr, eax

; 1409 :     if ( ex->type != INTEGER_TYPE )

	cmp	DWORD PTR [ebx+68], 2
	je	SHORT $LN6@add_attrib

; 1410 :       kb_error(2842,"Attribute extra_boundary must be of type integer.\n",
; 1411 :          RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0DD@JPCAAFOI@Attribute?5extra_boundary?5must?5be@
	push	2842					; 00000b1aH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN6@add_attrib:

; 1412 :     if ( e_type != VERTEX )

	cmp	DWORD PTR _e_type$[ebp], 0
	je	SHORT $LN1@add_attrib

; 1413 :       kb_error(2843,"Attribute extra_boundary should be vertex attribute.\n",
; 1414 :          RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0DG@EADCCJBL@Attribute?5extra_boundary?5should?5@
	push	2843					; 00000b1bH
	call	_kb_error

; 1425 :   }
; 1426 :   web.skel[e_type].extra_count++;

	add	DWORD PTR _web[esi+108], edi
	mov	eax, DWORD PTR _web[esi+108]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx

; 1427 :   return web.skel[e_type].extra_count - 1; /* index */

	dec	eax
	pop	esi

; 1428 : } // end add_attribute()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@add_attrib:

; 1415 :   }
; 1416 :   else if ( stricmp(name,EXTRA_BDRY_PARAM_NAME) == 0 )

	push	OFFSET ??_C@_0BF@CKLEHKEG@extra_boundary_param?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN38@add_attrib

; 1417 :   { extra_bdry_param_attr = web.skel[e_type].extra_count;

	mov	ecx, DWORD PTR tv321[ebp]
	mov	edx, DWORD PTR _web[ecx+108]
	mov	DWORD PTR _extra_bdry_param_attr, edx

; 1418 :     if ( ex->type != REAL_TYPE )

	cmp	DWORD PTR [ebx+68], edi
	je	SHORT $LN2@add_attrib

; 1419 :       kb_error(3369,"Attribute extra_boundary_param must be of type real.\n",
; 1420 :          RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0DG@LKNHBPMF@Attribute?5extra_boundary_param?5m@
	push	3369					; 00000d29H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN2@add_attrib:

; 1421 :     if ( e_type != VERTEX )

	cmp	DWORD PTR _e_type$[ebp], 0
	je	SHORT $LN38@add_attrib

; 1422 :       kb_error(2845,
; 1423 :         "Attribute extra_boundary_param should be vertex attribute.\n",
; 1424 :          RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0DM@HPGENDJ@Attribute?5extra_boundary_param?5s@
	push	2845					; 00000b1dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN38@add_attrib:
	mov	esi, DWORD PTR tv321[ebp]
$LN1@add_attrib:

; 1425 :   }
; 1426 :   web.skel[e_type].extra_count++;

	add	DWORD PTR _web[esi+108], edi
	mov	eax, DWORD PTR _web[esi+108]
	pop	edi

; 1427 :   return web.skel[e_type].extra_count - 1; /* index */

	dec	eax
	pop	ebx
$LN27@add_attrib:
	pop	esi

; 1428 : } // end add_attribute()

	mov	esp, ebp
	pop	ebp
	ret	0
_add_attribute ENDP
_TEXT	ENDS
PUBLIC	_set_v_global
; Function compile flags: /Ogtp
;	COMDAT _set_v_global
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_set_v_global PROC					; COMDAT

; 1669 : { int k;

	push	ebp
	mov	ebp, esp
	push	esi

; 1670 :   for ( k = 0 ; k < web.con_global_count ; k++ )

	xor	esi, esi
	cmp	DWORD PTR _web+748, esi
	jle	SHORT $LN1@set_v_glob
	push	edi
	mov	edi, DWORD PTR _v_id$[ebp]
$LL3@set_v_glob:

; 1671 :      set_v_constraint_map(v_id,web.con_global_map[k]);

	mov	eax, DWORD PTR _web[esi*4+656]
	push	eax
	push	edi
	call	_set_v_constraint_map
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR _web+748
	jl	SHORT $LL3@set_v_glob
	pop	edi
$LN1@set_v_glob:
	pop	esi

; 1672 : } // end set_v_global()

	pop	ebp
	ret	0
_set_v_global ENDP
_TEXT	ENDS
PUBLIC	_set_v_conmap
; Function compile flags: /Ogtp
;	COMDAT _set_v_conmap
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_map$ = 12						; size = 4
_set_v_conmap PROC					; COMDAT

; 1684 : { int k, m=(int)map[0];

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _map$[ebp]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	push	esi

; 1685 :   for ( k = 1 ; k <= m ; k++ )

	mov	esi, 1
	push	edi
	mov	edi, DWORD PTR _v_id$[ebp]
	cmp	ebx, esi
	jl	SHORT $LN2@set_v_conm
$LL13@set_v_conm:

; 1686 :     set_v_constraint_map(v_id,map[k]);

	mov	ecx, DWORD PTR _map$[ebp]
	mov	edx, DWORD PTR [ecx+esi*4]
	push	edx
	push	edi
	call	_set_v_constraint_map
	inc	esi
	add	esp, 8
	cmp	esi, ebx
	jle	SHORT $LL13@set_v_conm
$LN2@set_v_conm:

; 1687 :   map = get_v_constraint_map(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	cmp	DWORD PTR [ecx+edx+1288], 0
	je	SHORT $LN7@set_v_conm
	mov	esi, DWORD PTR _web+12
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	add	eax, DWORD PTR [ecx+edx+1264]
	jmp	SHORT $LN8@set_v_conm
$LN7@set_v_conm:
	mov	eax, OFFSET _nullcon
$LN8@set_v_conm:

; 1688 :   if ( map[0] == 0 ) unset_attr(v_id,CONSTRAINT);

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN9@set_v_conm
	mov	ecx, edi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [edi+12]
	and	DWORD PTR [edi+8], -1025		; fffffbffH
	mov	DWORD PTR [edi+12], eax
$LN9@set_v_conm:
	pop	edi
	pop	esi
	pop	ebx

; 1689 : } // end set_v_conmap()

	pop	ebp
	ret	0
_set_v_conmap ENDP
_TEXT	ENDS
PUBLIC	_set_e_conmap
; Function compile flags: /Ogtp
;	COMDAT _set_e_conmap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_map$ = 12						; size = 4
_set_e_conmap PROC					; COMDAT

; 1700 : { int k, m=(int)map[0];

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _map$[ebp]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	push	esi

; 1701 :   for ( k = 1 ; k <= m ; k++ )

	mov	esi, 1
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]
	cmp	ebx, esi
	jl	SHORT $LN2@set_e_conm
$LL13@set_e_conm:

; 1702 :     set_e_constraint_map(e_id,map[k]);

	mov	ecx, DWORD PTR _map$[ebp]
	mov	edx, DWORD PTR [ecx+esi*4]
	push	edx
	push	edi
	call	_set_e_constraint_map
	inc	esi
	add	esp, 8
	cmp	esi, ebx
	jle	SHORT $LL13@set_e_conm
$LN2@set_e_conm:

; 1703 :   map = get_e_constraint_map(e_id);

	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	cmp	DWORD PTR [ecx+edx+1048], 0
	je	SHORT $LN7@set_e_conm
	mov	esi, DWORD PTR _web+124
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	add	eax, DWORD PTR [ecx+edx+1024]
	jmp	SHORT $LN8@set_e_conm
$LN7@set_e_conm:
	mov	eax, OFFSET _nullcon
$LN8@set_e_conm:

; 1704 :   if ( map[0] == 0 ) unset_attr(e_id,CONSTRAINT);

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN9@set_e_conm
	mov	ecx, edi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [edi+12]
	and	DWORD PTR [edi+8], -1025		; fffffbffH
	mov	DWORD PTR [edi+12], eax
$LN9@set_e_conm:
	pop	edi
	pop	esi
	pop	ebx

; 1705 : } // end set_e_conmap()

	pop	ebp
	ret	0
_set_e_conmap ENDP
_TEXT	ENDS
PUBLIC	_set_f_conmap
; Function compile flags: /Ogtp
;	COMDAT _set_f_conmap
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_map$ = 12						; size = 4
_set_f_conmap PROC					; COMDAT

; 1717 : { int k, m=(int)map[0];

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _map$[ebp]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	push	esi

; 1718 :   for ( k = 1 ; k <= m ; k++ )

	mov	esi, 1
	push	edi
	mov	edi, DWORD PTR _f_id$[ebp]
	cmp	ebx, esi
	jl	SHORT $LN2@set_f_conm
$LL13@set_f_conm:

; 1719 :     set_f_constraint_map(f_id,map[k]);

	mov	ecx, DWORD PTR _map$[ebp]
	mov	edx, DWORD PTR [ecx+esi*4]
	push	edx
	push	edi
	call	_set_f_constraint_map
	inc	esi
	add	esp, 8
	cmp	esi, ebx
	jle	SHORT $LL13@set_f_conm
$LN2@set_f_conm:

; 1720 :   map = get_f_constraint_map(f_id);

	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	cmp	DWORD PTR [ecx+edx+88], 0
	je	SHORT $LN7@set_f_conm
	mov	esi, DWORD PTR _web+236
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	add	eax, DWORD PTR [ecx+edx+64]
	jmp	SHORT $LN8@set_f_conm
$LN7@set_f_conm:
	mov	eax, OFFSET _nullcon
$LN8@set_f_conm:

; 1721 :   if ( map[0] == 0 ) unset_attr(f_id,CONSTRAINT);

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN9@set_f_conm
	mov	ecx, edi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [edi+12]
	and	DWORD PTR [edi+8], -1025		; fffffbffH
	mov	DWORD PTR [edi+12], eax
$LN9@set_f_conm:
	pop	edi
	pop	esi
	pop	ebx

; 1722 : } // end set_f_conmap()

	pop	ebp
	ret	0
_set_f_conmap ENDP
_TEXT	ENDS
PUBLIC	_new_vertex
EXTRN	_myfree:PROC
EXTRN	_cg_hvector:DWORD
; Function compile flags: /Ogtp
;	COMDAT _new_vertex
_TEXT	SEGMENT
_x$ = 8							; size = 4
_parent$ = 12						; size = 4
_new_vertex PROC					; COMDAT

; 549  : { 

	push	ebp
	mov	ebp, esp

; 550  :   int i;
; 551  :   vertex_id v_id;
; 552  :   REAL *y;
; 553  : 
; 554  :   v_id = new_element(VERTEX,parent,NULLID);

	mov	eax, DWORD PTR _parent$[ebp]
	push	esi
	push	0
	push	eax
	push	0
	call	_new_element

; 555  :   if ( x )

	mov	edx, DWORD PTR _x$[ebp]
	add	esp, 12					; 0000000cH
	mov	esi, eax
	test	edx, edx
	je	SHORT $LN11@new_vertex

; 556  :   { y = get_coord(v_id);

	mov	eax, DWORD PTR _web+12
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _web+104
	push	ebx
	mov	ebx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+ebx+64]

; 557  :     for ( i = 0 ; i < SDIM ; i++ ) y[i] = x[i];

	xor	ecx, ecx
	pop	ebx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN11@new_vertex
	sub	edx, eax
	npad	5
$LL4@new_vertex:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL4@new_vertex
$LN11@new_vertex:

; 558  :   }
; 559  :   set_vertex_edge(v_id,NULLID);

	mov	edx, DWORD PTR _web+12
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR [ecx+28], 0

; 560  :   set_vertex_facet(v_id,NULLID);

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+edx]

; 561  : 
; 562  :   set_v_global(v_id);

	push	esi
	mov	DWORD PTR [eax+32], 0
	call	_set_v_global

; 563  : 
; 564  :   /* interrupt conjugate gradient */
; 565  :   if ( cg_hvector ) { myfree((char *)cg_hvector); cg_hvector = NULL; }

	mov	eax, DWORD PTR _cg_hvector
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@new_vertex
	push	eax
	call	_myfree
	add	esp, 4
	mov	DWORD PTR _cg_hvector, 0
$LN10@new_vertex:

; 566  : 
; 567  :   return v_id;

	mov	eax, esi
	pop	esi

; 568  : } // end new_vertex()

	pop	ebp
	ret	0
_new_vertex ENDP
_TEXT	ENDS
PUBLIC	_dup_edge
; Function compile flags: /Ogtp
;	COMDAT _dup_edge
_TEXT	SEGMENT
_old_e$ = 8						; size = 4
_dup_edge PROC						; COMDAT

; 649  : { 

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 650  :   edge_id e_id;
; 651  :   struct edge *e_id_p,*old_e_p;
; 652  :   vertex_id newmid; 
; 653  : 
; 654  :   e_id = new_element(EDGE,NULLID,NULLID);

	push	0
	push	0
	push	1
	call	_new_element

; 655  :   e_id_p = eptr(e_id);
; 656  :   old_e_p = eptr(old_e);

	mov	edx, DWORD PTR _old_e$[ebp]

; 657  :   memcpy((char *)&(e_id_p->attr),(char *)&(old_e_p->attr),
; 658  :               web.sizes[EDGE] - ((char*)&(e_id_p->attr)-(char*)e_id_p));

	mov	ecx, DWORD PTR _web+564
	mov	edi, eax
	mov	eax, DWORD PTR _web+124
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ebx, DWORD PTR [esi+eax]
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	add	ecx, -8					; fffffff8H
	push	ecx
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR [ebx+8]
	push	ecx
	call	_memcpy

; 659  :   e_id_p->self_id = e_id; /* restore new id */
; 660  :   e_id_p->next_vedge[0] = NULLID;

	xor	ecx, ecx
	mov	DWORD PTR [ebx+16], edi
	mov	DWORD PTR [ebx+32], ecx

; 661  :   e_id_p->next_vedge[1] = NULLID;

	mov	DWORD PTR [ebx+36], ecx

; 662  :   if ( web.modeltype == QUADRATIC )

	mov	eax, DWORD PTR _web+628
	add	esp, 24					; 00000018H
	cmp	eax, 2
	jne	SHORT $LN7@dup_edge

; 663  :   { newmid = new_vertex(NULL,old_e);

	mov	edx, DWORD PTR _old_e$[ebp]
	push	edx
	push	ecx
	call	_new_vertex
	mov	esi, eax

; 664  :     set_edge_midv(e_id,newmid);

	push	esi
	push	edi
	call	_set_edge_midv

; 665  :     set_attr(newmid,Q_MIDPOINT);

	mov	eax, esi
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	ecx, DWORD PTR _web[esi+12]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+12], edx
	add	esp, 16					; 00000010H
	or	DWORD PTR [ecx+8], 131072		; 00020000H

; 666  :     set_vertex_edge(newmid,e_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+28], edi
	jmp	SHORT $LN15@dup_edge
$LN7@dup_edge:

; 667  :   } 
; 668  :   else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	SHORT $LN15@dup_edge

; 669  :   { int i;
; 670  :     vertex_id *v = get_edge_vertices(e_id);

	mov	eax, DWORD PTR _web+124
	mov	esi, DWORD PTR [esi+eax]
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	add	esi, DWORD PTR [ecx+edx+304]

; 671  :     for ( i = 1 ; i < web.lagrange_order ; i++ )

	mov	ebx, 1
	cmp	DWORD PTR _web+632, ebx
	jle	SHORT $LN15@dup_edge
	npad	6
$LL14@dup_edge:

; 672  :       v[i] = new_vertex(NULL,e_id);

	push	edi
	push	0
	call	_new_vertex
	mov	DWORD PTR [esi+ebx*4], eax
	inc	ebx
	add	esp, 8
	cmp	ebx, DWORD PTR _web+632
	jl	SHORT $LL14@dup_edge
$LN15@dup_edge:

; 673  :   } 
; 674  :   if ( inverted(old_e) ) return inverse_id(e_id);

	test	DWORD PTR _old_e$[ebp], 134217728	; 08000000H
	mov	eax, edi
	je	SHORT $LN8@dup_edge
	xor	eax, 134217728				; 08000000H
$LN8@dup_edge:
	pop	edi
	pop	esi
	pop	ebx

; 675  :   return e_id;
; 676  : } // end dup_edge()

	pop	ebp
	ret	0
_dup_edge ENDP
_TEXT	ENDS
PUBLIC	_new_facetedge
; Function compile flags: /Ogtp
;	COMDAT _new_facetedge
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
tv417 = 12						; size = 4
_e_id$ = 12						; size = 4
_new_facetedge PROC					; COMDAT

; 804  : { 

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 805  :   facetedge_id fe_id;
; 806  :  
; 807  :   fe_id = new_element(FACETEDGE,NULLID,NULLID);

	push	0
	push	0
	push	4
	call	_new_element

; 808  :   set_fe_edge(fe_id,e_id);

	mov	ebx, DWORD PTR _e_id$[ebp]
	mov	edi, eax
	shr	eax, 27					; 0000001bH
	add	esp, 12					; 0000000cH
	and	eax, 1
	mov	ecx, ebx
	mov	DWORD PTR tv417[ebp], eax
	je	SHORT $LN12@new_facete@3
	xor	ecx, 134217728				; 08000000H
$LN12@new_facete@3:
	mov	eax, DWORD PTR _web+460
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+20], ecx
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 809  :   set_fe_facet(fe_id,f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	push	edi
	call	_set_fe_facet

; 810  :   set_prev_edge(fe_id,NULLFACETEDGE);

	mov	ecx, DWORD PTR _NULLFACETEDGE
	push	ecx
	push	edi
	call	_set_prev_edge
	add	esp, 16					; 00000010H

; 811  :   set_next_edge(fe_id,NULLFACETEDGE);

	test	edi, 268435456				; 10000000H
	je	SHORT $LN15@new_facete@3
	cmp	DWORD PTR tv417[ebp], 0
	je	SHORT $LN16@new_facete@3
	mov	edx, DWORD PTR _NULLFACETEDGE
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [esi+eax]
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [ecx+28], edx
	jmp	SHORT $LN15@new_facete@3
$LN16@new_facete@3:
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [esi+edx]
	mov	ecx, DWORD PTR _NULLFACETEDGE
	mov	DWORD PTR [eax+32], ecx
$LN15@new_facete@3:

; 812  :   set_prev_facet(fe_id,NULLFACETEDGE);      

	mov	edx, DWORD PTR _NULLFACETEDGE
	push	edx
	push	edi
	call	_set_prev_facet

; 813  :   set_prev_facet(fe_id,NULLFACETEDGE);

	mov	eax, DWORD PTR _NULLFACETEDGE
	push	eax
	push	edi
	call	_set_prev_facet

; 814  :   #ifndef MPI_EVOLVER
; 815  :   { vertex_id headv,tailv;
; 816  :     tailv = get_edge_tailv(e_id);  

	mov	esi, DWORD PTR _dymem
	mov	edx, ebx
	shr	edx, 27					; 0000001bH
	add	esp, 16					; 00000010H
	and	edx, 1
	je	SHORT $LN21@new_facete@3
	mov	eax, DWORD PTR _web+124
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+esi+304]
	add	eax, ecx
	mov	ecx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN20@new_facete@3
$LN21@new_facete@3:
	mov	ecx, DWORD PTR _web+124
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+esi+304]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
$LN20@new_facete@3:

; 817  :     headv = get_edge_headv(e_id);

	test	edx, edx
	je	SHORT $LN25@new_facete@3
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN24@new_facete@3
$LN25@new_facete@3:
	mov	edx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edx*4]
$LN24@new_facete@3:

; 818  :     if ( !valid_id(get_vertex_edge(tailv)) )

	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, 268435456				; 10000000H
	test	DWORD PTR [ecx+28], edx
	jne	SHORT $LN9@new_facete@3

; 819  :       set_vertex_edge(tailv,e_id);

	mov	DWORD PTR [ecx+28], ebx
$LN9@new_facete@3:

; 820  :     if ( !valid_id(get_vertex_edge(headv)) )

	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	test	DWORD PTR [eax+28], edx
	jne	SHORT $LN8@new_facete@3

; 821  :       set_vertex_edge(headv,e_id);

	mov	DWORD PTR [eax+28], ebx
$LN8@new_facete@3:

; 822  :   }
; 823  :   #endif
; 824  : 
; 825  :   if ( web.representation==STRING && everything_quantities_flag )

	cmp	DWORD PTR _web+624, 1
	jne	$LN30@new_facete@3
	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN30@new_facete@3

; 826  :   { /* attach volume quantities */
; 827  :      body_id b_id;
; 828  :      b_id = get_facet_body(f_id);

	mov	esi, DWORD PTR _f_id$[ebp]
	push	esi
	call	_get_facet_body
	add	esp, 4

; 829  :      if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN31@new_facete@3

; 830  :      { if ( same_sign(f_id,e_id) )

	mov	edx, ebx
	and	edx, 134217728				; 08000000H

; 831  :           apply_method_num(e_id,get_body_volmeth(b_id));

	and	eax, 134217727				; 07ffffffH
	xor	edx, esi
	je	SHORT $LN5@new_facete@3
	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+412]
	push	eax
	push	ebx

; 832  :         else

	jmp	SHORT $LN32@new_facete@3
$LN5@new_facete@3:

; 833  :           apply_method_num(inverse_id(e_id),get_body_volmeth(b_id));

	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+412]
	mov	ecx, ebx
	xor	ecx, 134217728				; 08000000H
	push	edx
	push	ecx
$LN32@new_facete@3:
	call	_apply_method_num
	add	esp, 8
$LN31@new_facete@3:

; 834  :      }
; 835  :      b_id = get_facet_body(inverse_id(f_id));

	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	push	eax
	call	_get_facet_body
	add	esp, 4

; 836  :      if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN30@new_facete@3

; 837  :      { if ( same_sign(f_id,e_id) )
; 838  :           apply_method_num(inverse_id(e_id),get_body_volmeth(b_id));

	mov	edx, DWORD PTR _web+348
	mov	ecx, ebx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	and	ecx, 134217728				; 08000000H
	xor	ecx, esi
	mov	ecx, DWORD PTR [eax+412]
	push	ecx
	je	SHORT $LN2@new_facete@3
	xor	ebx, 134217728				; 08000000H
$LN2@new_facete@3:

; 839  :         else
; 840  :           apply_method_num(e_id,get_body_volmeth(b_id));

	push	ebx
	call	_apply_method_num
	add	esp, 8
$LN30@new_facete@3:

; 841  :      }
; 842  :   }
; 843  :   return fe_id;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 844  : } // end new_facetedge()

	pop	ebp
	ret	0
_new_facetedge ENDP
_TEXT	ENDS
END
