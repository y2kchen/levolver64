; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\VERPOPST.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_autopop_list:DWORD
COMM	_autochop_list:DWORD
_DATA	ENDS
PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_unset_attr
; Function compile flags: /Ogtp
;	COMDAT _unset_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_unset_attr PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 29   :   elptr(id)->attr &= ~attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	not	ecx
	and	DWORD PTR [eax+8], ecx
	not	edx
	and	DWORD PTR [eax+12], edx

; 30   : }

	pop	ebp
	ret	0
_unset_attr ENDP
_TEXT	ENDS
PUBLIC	_get_fe_edge
; Function compile flags: /Ogtp
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _get_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_facet PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp

; 84   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 85   :     return inverse_id(feptr(fe_id)->nextfacet[1]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]
	xor	eax, 134217728				; 08000000H

; 88   : }

	pop	ebp
	ret	0
$LN2@get_prev_f:

; 86   :   else 
; 87   :     return feptr(fe_id)->nextfacet[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]

; 88   : }

	pop	ebp
	ret	0
_get_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_prev_edge
EXTRN	_top_timestamp:DWORD
EXTRN	_global_timestamp:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_edge PROC					; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp

; 103  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_e

; 104  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_e

; 105  :     { invert(fe);
; 106  :       feptr(fe_id)->nextedge[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+32], ecx

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 111  : }

	pop	ebp
	ret	0
$LN2@set_prev_e:

; 107  :     }
; 108  :   else
; 109  :       feptr(fe_id)->nextedge[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_e:

; 111  : }

	pop	ebp
	ret	0
_set_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_set_next_edge
; Function compile flags: /Ogtp
;	COMDAT _set_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_edge PROC					; COMDAT

; 116  : {

	push	ebp
	mov	ebp, esp

; 117  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_e

; 118  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_e

; 119  :     { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 120  :       feptr(fe_id)->nextedge[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+28], ecx

; 124  : }

	pop	ebp
	ret	0
$LN2@set_next_e:

; 121  :     }
; 122  :   else
; 123  :       feptr(fe_id)->nextedge[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN1@set_next_e:

; 124  : }

	pop	ebp
	ret	0
_set_next_edge ENDP
_TEXT	ENDS
PUBLIC	_set_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _set_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_facet PROC					; COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp

; 130  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_f

; 131  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_f

; 132  :   { invert(fe);
; 133  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+40], ecx

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 138  : }

	pop	ebp
	ret	0
$LN2@set_prev_f:

; 134  :   }
; 135  :   else
; 136  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+36], eax

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_f:

; 138  : }

	pop	ebp
	ret	0
_set_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_set_next_facet
; Function compile flags: /Ogtp
;	COMDAT _set_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_facet PROC					; COMDAT

; 143  : {

	push	ebp
	mov	ebp, esp

; 144  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_f

; 145  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_f

; 146  :   { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 147  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+36], ecx

; 151  : }

	pop	ebp
	ret	0
$LN2@set_next_f:

; 148  :   }
; 149  :   else
; 150  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+40], eax
$LN1@set_next_f:

; 151  : }

	pop	ebp
	ret	0
_set_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _set_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_edge_fe PROC					; COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp

; 172  :   if ( inverted(e_id) ) invert(fe);

	mov	eax, DWORD PTR _e_id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN1@set_edge_f
	xor	DWORD PTR _fe$[ebp], 134217728		; 08000000H
$LN1@set_edge_f:

; 173  :   eptr(e_id)->fe_id = fe;

	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 174  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 175  : }

	pop	ebp
	ret	0
_set_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_set_edge_tailv
EXTRN	_insert_vertex_edge:PROC
EXTRN	_remove_vertex_edge:PROC
; Function compile flags: /Ogtp
;	COMDAT _set_edge_tailv
_TEXT	SEGMENT
tv225 = -4						; size = 4
_e_id$ = 8						; size = 4
_v_id$ = 12						; size = 4
_set_edge_tailv PROC					; COMDAT

; 210  : { vertex_id oldv;

	push	ebp
	mov	ebp, esp
	push	ecx

; 211  : 
; 212  :   /* make sure edge not in loop of old vertex */
; 213  :   oldv = get_edge_tailv(e_id);

	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR _web+216
	push	ebx
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	mov	eax, esi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	push	edi
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR tv225[ebp], eax
	je	SHORT $LN7@set_edge_t
	mov	ebx, DWORD PTR _web+636
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	add	eax, DWORD PTR [ecx+edi+304]
	mov	eax, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN6@set_edge_t
$LN7@set_edge_t:
	mov	ebx, DWORD PTR [ecx+edi+304]
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+ebx]
$LN6@set_edge_t:

; 214  :   if ( valid_id(oldv) && !equal_id(oldv,v_id) )

	mov	ebx, DWORD PTR _v_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN10@set_edge_t
	cmp	eax, ebx
	je	SHORT $LN10@set_edge_t

; 215  :     remove_vertex_edge(oldv,e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	eax
	call	_remove_vertex_edge
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	add	esp, 8
$LN10@set_edge_t:

; 216  : 
; 217  :   if ( inverted(e_id) )

	cmp	DWORD PTR tv225[ebp], 0

; 218  :      get_edge_vertices(e_id)[web.headvnum] = v_id;

	mov	edx, DWORD PTR [esi+edx]
	je	SHORT $LN2@set_edge_t
	add	edx, DWORD PTR [ecx+edi+304]
	mov	eax, DWORD PTR _web+636
	mov	DWORD PTR [edx+eax*4], ebx

; 219  :   else

	jmp	SHORT $LN1@set_edge_t
$LN2@set_edge_t:

; 220  :      get_edge_vertices(e_id)[0] = v_id;

	mov	eax, DWORD PTR [ecx+edi+304]
	mov	DWORD PTR [edx+eax], ebx
$LN1@set_edge_t:

; 221  :   insert_vertex_edge(v_id,e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	ebx
	call	_insert_vertex_edge

; 222  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	esp, 8
	pop	edi
	inc	eax
	pop	esi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	ebx

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_set_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_@2
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_@2:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_@2
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_@2:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	_get_vertex_fe
; Function compile flags: /Ogtp
;	COMDAT _get_vertex_fe
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_get_vertex_fe PROC					; COMDAT

; 287  : { facet_id fe;

	push	ebp
	mov	ebp, esp

; 288  :   edge_id start_e, xx_id=vptr(v_id)->e_id;

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 289  :   // might be bare edge, so seek along edge loop
; 290  :   if ( !valid_id(xx_id) ) return NULLID;

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN4@get_vertex
	xor	eax, eax

; 299  : }

	pop	ebp
	ret	0
$LN4@get_vertex:
	push	esi

; 291  :   fe = eptr(xx_id)->fe_id;

	mov	esi, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	push	edi

; 292  :   start_e = xx_id;
; 293  :   while ( !valid_id(fe) )

	test	edx, 268435456				; 10000000H
	jne	SHORT $LN2@get_vertex
	mov	edi, eax
	or	edi, 134217728				; 08000000H
	npad	8
$LL3@get_vertex:

; 294  :   { xx_id = get_next_tail_edge(xx_id);

	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	eax, DWORD PTR [ecx+eax*4+32]

; 295  :     if ( equal_element(xx_id,start_e) ) return NULLID;

	mov	edx, eax
	or	edx, 134217728				; 08000000H
	cmp	edx, edi
	je	SHORT $LN10@get_vertex

; 296  :     fe = eptr(xx_id)->fe_id;

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	test	edx, 268435456				; 10000000H
	je	SHORT $LL3@get_vertex
$LN2@get_vertex:

; 297  :   }
; 298  :   return  same_sign(fe,xx_id);

	and	eax, 134217728				; 08000000H
	pop	edi
	xor	eax, edx
	pop	esi

; 299  : }

	pop	ebp
	ret	0
$LN10@get_vertex:
	pop	edi

; 295  :     if ( equal_element(xx_id,start_e) ) return NULLID;

	xor	eax, eax
	pop	esi

; 299  : }

	pop	ebp
	ret	0
_get_vertex_fe ENDP
_TEXT	ENDS
PUBLIC	_anglecomp
EXTRN	__fltused:DWORD
EXTRN	__CIatan2:PROC
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\verpopst.c
;	COMDAT _anglecomp
_TEXT	SEGMENT
_aa$ = -8						; size = 8
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_anglecomp PROC						; COMDAT

; 234  : { REAL aa = atan2(a->vec[1],a->vec[0]);

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	eax, DWORD PTR _a$[ebp]
	fld	QWORD PTR [eax+16]
	fld	QWORD PTR [eax+8]
	call	__CIatan2
	fstp	QWORD PTR _aa$[ebp]

; 235  :   REAL bb = atan2(b->vec[1],b->vec[0]);

	mov	eax, DWORD PTR _b$[ebp]
	fld	QWORD PTR [eax+16]
	fld	QWORD PTR [eax+8]
	call	__CIatan2

; 236  :   if ( aa < bb ) return -1;

	fld	QWORD PTR _aa$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@anglecomp
	fstp	ST(1)
	or	eax, -1
	fstp	ST(0)

; 239  : } // end anglecomp()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@anglecomp:

; 237  :   if ( aa > bb ) return 1;

	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@anglecomp
	mov	eax, 1

; 239  : } // end anglecomp()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@anglecomp:

; 238  :   return 0;

	xor	eax, eax

; 239  : } // end anglecomp()

	mov	esp, ebp
	pop	ebp
	ret	0
_anglecomp ENDP
_TEXT	ENDS
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3f847ae147ae147b
PUBLIC	__real@3fa999999999999a
PUBLIC	??_C@_0BE@PMHCEJIK@Popping?5vertex?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0FH@KCAIHKEA@Not?5splitting?5vertex?5?$CFs?5since?5th@ ; `string'
PUBLIC	__real@c6293e5939a08cea
PUBLIC	??_C@_0BP@CGONBMGD@verpop?3?5edge?5?$CFs?5length?5zero?4?5?6?$AA@ ; `string'
PUBLIC	??_C@_0DM@FBNJGOHP@new_popverst?$CI?$CJ?3?5Not?5expected?5num@ ; `string'
PUBLIC	??_C@_0CO@GPACBIPK@Internal?5error?3?5Expected?5?$CFd?5edge@ ; `string'
PUBLIC	??_C@_0CI@PDNMCNJG@Pop?5vertex?3?5Invalid?5edge?5at?5vert@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0L@BJPEFIAD@VERPOPST?4C?$AA@		; `string'
PUBLIC	_edges$GSCopy$
PUBLIC	_v_id$GSCopy$
PUBLIC	__real@0000000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_new_popverst
EXTRN	_assure_v_constraints:PROC
EXTRN	_everything_quantities_flag:DWORD
EXTRN	_new_facetedge:PROC
EXTRN	_set_e_constraint_map:PROC
EXTRN	_set_v_constraint_map:PROC
EXTRN	_b_extrapolate:PROC
EXTRN	_unset_v_all_constraints:PROC
EXTRN	_new_edge:PROC
EXTRN	_phase_data:DWORD
EXTRN	_F_PHASE_ATTR:DWORD
EXTRN	_phase_flag:DWORD
EXTRN	_force_project:PROC
EXTRN	_free_element:PROC
EXTRN	_set_fe_facet:PROC
EXTRN	_set_facet_body:PROC
EXTRN	_pop_disjoin_flag:DWORD
EXTRN	_set_facet_fe:PROC
EXTRN	_dup_vertex:PROC
EXTRN	_msg:DWORD
EXTRN	_verbose_flag:DWORD
EXTRN	_temp_free:PROC
EXTRN	_outstring:PROC
EXTRN	_dot:PROC
EXTRN	_get_edge_tail_tangent:PROC
EXTRN	_E_BOUNDARY_ATTR:DWORD
EXTRN	_kb_error:PROC
EXTRN	_errmsg:BYTE
EXTRN	_sprintf:PROC
EXTRN	_elnames:BYTE
EXTRN	_kb_temp_calloc:PROC
EXTRN	_nullcon:QWORD
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	_get_vertex_evalence:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@3fb999999999999a
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3f847ae147ae147b
CONST	SEGMENT
__real@3f847ae147ae147b DQ 03f847ae147ae147br	; 0.01
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT ??_C@_0BE@PMHCEJIK@Popping?5vertex?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0BE@PMHCEJIK@Popping?5vertex?5?$CFs?4?6?$AA@ DB 'Popping vertex %s.'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@KCAIHKEA@Not?5splitting?5vertex?5?$CFs?5since?5th@
CONST	SEGMENT
??_C@_0FH@KCAIHKEA@Not?5splitting?5vertex?5?$CFs?5since?5th@ DB 'Not spli'
	DB	'tting vertex %s since that would create two separate edge cha'
	DB	'ins for facet %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT __real@c6293e5939a08cea
CONST	SEGMENT
__real@c6293e5939a08cea DQ 0c6293e5939a08cear	; -1e+030
CONST	ENDS
;	COMDAT ??_C@_0BP@CGONBMGD@verpop?3?5edge?5?$CFs?5length?5zero?4?5?6?$AA@
CONST	SEGMENT
??_C@_0BP@CGONBMGD@verpop?3?5edge?5?$CFs?5length?5zero?4?5?6?$AA@ DB 'ver'
	DB	'pop: edge %s length zero. ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@FBNJGOHP@new_popverst?$CI?$CJ?3?5Not?5expected?5num@
CONST	SEGMENT
??_C@_0DM@FBNJGOHP@new_popverst?$CI?$CJ?3?5Not?5expected?5num@ DB 'new_po'
	DB	'pverst(): Not expected number of edges around vertex', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GPACBIPK@Internal?5error?3?5Expected?5?$CFd?5edge@
CONST	SEGMENT
??_C@_0CO@GPACBIPK@Internal?5error?3?5Expected?5?$CFd?5edge@ DB 'Internal'
	DB	' error: Expected %d edges; found %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PDNMCNJG@Pop?5vertex?3?5Invalid?5edge?5at?5vert@
CONST	SEGMENT
??_C@_0CI@PDNMCNJG@Pop?5vertex?3?5Invalid?5edge?5at?5vert@ DB 'Pop vertex'
	DB	': Invalid edge at vertex %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BJPEFIAD@VERPOPST?4C?$AA@
CONST	SEGMENT
??_C@_0L@BJPEFIAD@VERPOPST?4C?$AA@ DB 'VERPOPST.C', 00H	; `string'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\verpopst.c
CONST	ENDS
;	COMDAT _new_popverst
_TEXT	SEGMENT
_tempside$89429 = -384					; size = 80
_temp$89353 = -384					; size = 80
_attrv$ = -304						; size = 8
_new_density$ = -296					; size = 8
_attr1$ = -288						; size = 8
_degfree$ = -280					; size = 4
_v_id$GSCopy$ = -276					; size = 4
_side$ = -272						; size = 4
_edges$GSCopy$ = -268					; size = 4
tv8118 = -264						; size = 4
tv7511 = -264						; size = 4
_bottombest$89342 = -264				; size = 4
_besti$ = -260						; size = 4
_bottom$89304 = -260					; size = 4
_new_v$ = -260						; size = 4
tv10203 = -256						; size = 4
tv9937 = -256						; size = 4
tv9532 = -256						; size = 4
tv8096 = -256						; size = 4
_found$89496 = -256					; size = 4
tv8345 = -252						; size = 4
tv7601 = -252						; size = 4
_fe_id$ = -252						; size = 4
_topbest$89341 = -252					; size = 4
tv10507 = -248						; size = 4
tv9501 = -248						; size = 4
tv8249 = -248						; size = 4
tv7919 = -248						; size = 4
tv7460 = -248						; size = 4
tv7436 = -248						; size = 4
tv7405 = -248						; size = 4
tv7204 = -248						; size = 4
$T90678 = -248						; size = 4
$T90521 = -248						; size = 4
_b2$89613 = -248					; size = 4
_e1$ = -248						; size = 4
_first_e$ = -248					; size = 4
tv7104 = -244						; size = 4
_f2$ = -244						; size = 4
_f1$ = -244						; size = 4
_new_e$ = -240						; size = 4
_i$ = -240						; size = 4
tv10948 = -236						; size = 4
tv8368 = -236						; size = 4
tv8231 = -236						; size = 4
tv7765 = -236						; size = 4
tv7108 = -236						; size = 4
_e2$ = -236						; size = 4
_top$89303 = -236					; size = 4
tv10946 = -232						; size = 4
tv10335 = -232						; size = 4
tv10242 = -232						; size = 4
tv10091 = -232						; size = 4
tv9513 = -232						; size = 4
tv8275 = -232						; size = 4
tv8265 = -232						; size = 4
tv8246 = -232						; size = 4
_x$ = -232						; size = 4
_start_fe$89361 = -232					; size = 4
_e_id$ = -232						; size = 4
_fproj$ = -228						; size = 48
_temp$89350 = -180					; size = 80
_temp$89330 = -180					; size = 80
_temp$89319 = -180					; size = 80
_bestmove$ = -148					; size = 48
_f$ = -100						; size = 48
_f_id$89405 = -52					; size = 16
_ffmax$ = -44						; size = 8
_b_id$89406 = -36					; size = 16
_attr2$ = -28						; size = 8
_bottomgap$89338 = -28					; size = 8
_fe_id$89404 = -20					; size = 16
_topgap$89337 = -12					; size = 8
tv8234 = -8						; size = 4
_other_fe$ = -8						; size = 4
_map1$89482 = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_edges$ = 12						; size = 4
_new_popverst PROC					; COMDAT

; 245  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 384				; 00000180H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 246  :   int i,j,m;
; 247  :   int besti;
; 248  :   vertex_id new_v = NULLID;
; 249  :   edge_id new_e;
; 250  :   edge_id e_id,first_e;
; 251  :   edge_id e1,e2; /* edges to be pulled out */
; 252  :   REAL *x;
; 253  :   facet_id f1,f2;
; 254  :   REAL ff,f[MAXCOORD],fproj[MAXCOORD],ffmax;
; 255  :   REAL new_density=0.0;

	fldz
	push	ebx
	push	esi
	fstp	QWORD PTR _new_density$[ebp]
	mov	esi, DWORD PTR _v_id$[ebp]
	push	edi

; 256  :   struct side_t *side;
; 257  :   REAL bestmove[MAXCOORD];
; 258  :   facetedge_id fe_id,new_fe1,new_fe2,other_fe;
; 259  :   ATTR attr1,attr2,attrv;
; 260  :   REAL cosa;
; 261  :   facetedge_id fe;
; 262  :   int degfree; /* degrees of freedom of popping vertex */
; 263  :   struct boundary *vbdry; /* boundary of popping vertex */
; 264  :   conmap_t *vmap,*emap;  /* constraint list of popping vertex */
; 265  : 
; 266  :   /* First, quick checks to rule out most vertices */
; 267  :   edges = get_vertex_evalence(v_id);

	push	esi
	mov	DWORD PTR _v_id$GSCopy$[ebp], esi
	call	_get_vertex_evalence
	mov	DWORD PTR _edges$GSCopy$[ebp], eax

; 268  :   attrv = get_vattr(v_id);

	mov	eax, DWORD PTR _web+12
	and	esi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+esi*4]
	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi+12]

; 269  :   if ( !(attrv&FIXED) && !(attrv&(BOUNDARY|CONSTRAINT)) && (edges <= 3) )

	mov	eax, ecx
	and	eax, 64					; 00000040H
	mov	DWORD PTR tv7104[ebp], esi
	mov	DWORD PTR _attrv$[ebp+4], edx
	xor	edx, edx
	mov	esi, eax
	add	esp, 4
	or	esi, edx
	jne	SHORT $LN999@new_popver
	mov	esi, ecx
	and	esi, 1152				; 00000480H
	xor	ebx, ebx
	or	esi, ebx
	jne	SHORT $LN999@new_popver
	cmp	DWORD PTR _edges$GSCopy$[ebp], 3

; 270  :     return 0;  /* typical interior vertex */

	jle	$LN1140@new_popver
$LN999@new_popver:

; 271  :   if ( edges <= 1 ) return 0;

	cmp	DWORD PTR _edges$GSCopy$[ebp], 1
	jle	$LN1140@new_popver

; 272  : 
; 273  :   /* Now, we have to get more detailed info */
; 274  : 
; 275  :   /* Get degrees of freedom of vertex */
; 276  :   degfree = SDIM;
; 277  :   if ( attrv & FIXED ) degfree = 0;

	or	eax, edx
	mov	esi, DWORD PTR _web+616
	mov	DWORD PTR _degfree$[ebp], esi
	je	SHORT $LN201@new_popver
	mov	DWORD PTR _degfree$[ebp], edx
	jmp	$LN193@new_popver
$LN201@new_popver:

; 278  :   else if ( attrv & BOUNDARY )

	mov	eax, ecx
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN199@new_popver

; 279  :   { vbdry = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN206@new_popver
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	edi, DWORD PTR [edx+edi]
	imul	edi, 136				; 00000088H
	add	edi, DWORD PTR _web+776
	jmp	SHORT $LN207@new_popver
$LN206@new_popver:
	xor	edi, edi
$LN207@new_popver:

; 280  :     if ( (vbdry->attr & NONWALL) )

	mov	eax, DWORD PTR [edi+32]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN193@new_popver

; 281  :       degfree = vbdry->pcount;

	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR _degfree$[ebp], eax

; 282  :   }
; 283  :   else if ( attrv & CONSTRAINT )

	jmp	SHORT $LN193@new_popver
$LN199@new_popver:
	and	ecx, 1024				; 00000400H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN193@new_popver

; 284  :   { vmap = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	cmp	DWORD PTR [eax+ecx+1288], edx
	je	SHORT $LN208@new_popver
	mov	esi, DWORD PTR [eax+ecx+1264]
	add	esi, edi
	jmp	SHORT $LN209@new_popver
$LN208@new_popver:
	mov	esi, OFFSET _nullcon
$LN209@new_popver:
	mov	ebx, DWORD PTR [esi]

; 285  :     for ( i = 1; i <= (int)vmap[0] ; i++ )

	mov	edx, 1
	cmp	ebx, edx
	jl	SHORT $LN193@new_popver
	mov	edi, DWORD PTR _web+652
	npad	13
$LL195@new_popver:

; 286  :      if (!((get_constraint(vmap[i])->attr)&(NONPOSITIVE|NONNEGATIVE|NONWALL)))

	mov	eax, DWORD PTR [esi+edx*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	mov	eax, DWORD PTR [eax+edi+32]
	and	eax, 1027				; 00000403H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN194@new_popver

; 287  :       degfree--;

	dec	DWORD PTR _degfree$[ebp]
$LN194@new_popver:

; 285  :     for ( i = 1; i <= (int)vmap[0] ; i++ )

	inc	edx
	cmp	edx, ebx
	jle	SHORT $LL195@new_popver
$LN193@new_popver:

; 288  :   }
; 289  : 
; 290  :   side = (struct side_t *)temp_calloc(edges+1,sizeof(struct side_t));

	mov	esi, DWORD PTR _edges$GSCopy$[ebp]
	push	290					; 00000122H
	push	OFFSET ??_C@_0L@BJPEFIAD@VERPOPST?4C?$AA@
	lea	ecx, DWORD PTR [esi+1]
	push	80					; 00000050H
	push	ecx
	call	_kb_temp_calloc

; 291  :   
; 292  :   /* get edge vectors */
; 293  :   e_id = first_e = get_vertex_edge(v_id);

	mov	ecx, DWORD PTR tv7104[ebp]
	mov	edx, DWORD PTR _web+12
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [edx+28]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _side$[ebp], eax
	mov	DWORD PTR _first_e$[ebp], ecx
	mov	DWORD PTR _e_id$[ebp], ecx

; 294  :   for ( i = 0 ; i < edges ; i++  )

	mov	DWORD PTR _i$[ebp], 0
	test	esi, esi
	jle	$LN189@new_popver

; 288  :   }
; 289  : 
; 290  :   side = (struct side_t *)temp_calloc(edges+1,sizeof(struct side_t));

	mov	ebx, eax
	add	ebx, 72					; 00000048H
	mov	DWORD PTR tv9937[ebp], ebx
	npad	9
$LL191@new_popver:

; 295  :   { 
; 296  :     if  ( !valid_id(e_id) )

	mov	esi, DWORD PTR _e_id$[ebp]
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN188@new_popver

; 297  :     { sprintf(errmsg,"Pop vertex: Invalid edge at vertex %s.\n",
; 298  :              ELNAME(v_id));

	test	DWORD PTR _v_id$GSCopy$[ebp], 268435456	; 10000000H
	je	SHORT $LN210@new_popver
	mov	eax, DWORD PTR tv7104[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN211@new_popver
$LN210@new_popver:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN211@new_popver:
	push	eax
	push	OFFSET ??_C@_0CI@PDNMCNJG@Pop?5vertex?3?5Invalid?5edge?5at?5vert@
	push	OFFSET _errmsg
	call	_sprintf

; 299  :       kb_error(1382,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1382					; 00000566H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN188@new_popver:

; 300  :     }
; 301  : 
; 302  :     /* Get degrees of freedom of edge */
; 303  :     attr1 = get_eattr(e_id);

	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [ecx+esi]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+8]

; 304  :     side[i].degfree = SDIM;

	mov	eax, DWORD PTR _web+616
	mov	DWORD PTR [ebx], eax

; 305  :     if ( attr1 & FIXED ) side[i].degfree = 0;

	mov	eax, ecx
	mov	DWORD PTR _attr1$[ebp+4], edx
	and	eax, 64					; 00000040H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN187@new_popver
	mov	DWORD PTR [ebx], edx
	jmp	$LN179@new_popver
$LN187@new_popver:

; 306  :     else if ( attr1 & BOUNDARY )

	mov	eax, ecx
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	$LN185@new_popver

; 307  :     { if ( !(get_edge_boundary(e_id)->attr & NONWALL) )

	mov	ecx, DWORD PTR _E_BOUNDARY_ATTR
	mov	edi, DWORD PTR _web+776
	mov	ebx, DWORD PTR _web+216
	test	ecx, ecx
	je	SHORT $LN212@new_popver
	mov	eax, DWORD PTR _dymem
	mov	edx, ecx
	imul	edx, 240				; 000000f0H
	add	edx, ebx
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+esi]
	mov	eax, DWORD PTR [edx+eax]
	imul	eax, 136				; 00000088H
	add	eax, edi
	jmp	SHORT $LN213@new_popver
$LN212@new_popver:
	xor	eax, eax
$LN213@new_popver:
	mov	eax, DWORD PTR [eax+32]
	and	eax, 1024				; 00000400H
	xor	edx, edx
	or	eax, edx
	jne	SHORT $LN1008@new_popver

; 308  :         side[i].degfree = get_edge_boundary(e_id)->pcount;

	test	ecx, ecx
	je	SHORT $LN214@new_popver
	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, ebx
	mov	eax, DWORD PTR [ecx+edx+64]
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [eax+edx]
	imul	eax, 136				; 00000088H
	add	eax, edi
	jmp	SHORT $LN215@new_popver
$LN214@new_popver:
	xor	eax, eax
$LN215@new_popver:
	mov	eax, DWORD PTR [eax+40]
	mov	ecx, DWORD PTR tv9937[ebp]
	mov	DWORD PTR [ecx], eax
$LN1008@new_popver:

; 309  :     }
; 310  :     else if ( attr1 & CONSTRAINT )

	mov	ebx, DWORD PTR tv9937[ebp]
$LN179@new_popver:

; 315  :     }
; 316  : 
; 317  :     side[i].e_id = e_id;

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR [ebx-72], ecx

; 318  :     side[i].fe = get_edge_fe(e_id);

	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+esi]
	test	eax, eax
	jne	$LN265@new_popver
	jmp	$LN264@new_popver
$LN185@new_popver:

; 309  :     }
; 310  :     else if ( attr1 & CONSTRAINT )

	and	ecx, 1024				; 00000400H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN179@new_popver

; 311  :     { emap = get_e_constraint_map(e_id);

	mov	eax, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	cmp	DWORD PTR [eax+edx+1048], 0
	je	SHORT $LN216@new_popver
	mov	ecx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+esi]
	add	ecx, DWORD PTR [eax+edx+1024]
	jmp	SHORT $LN217@new_popver
$LN216@new_popver:
	mov	ecx, OFFSET _nullcon
$LN217@new_popver:

; 312  :       for ( j = 1; j <= (int)emap[0] ; j++ )

	mov	edi, 1
	cmp	DWORD PTR [ecx], edi
	jl	SHORT $LN179@new_popver
	npad	7
$LL181@new_popver:

; 313  :        if (!((get_constraint(emap[j])->attr)&(NONPOSITIVE|NONNEGATIVE|NONWALL)))

	mov	eax, DWORD PTR [ecx+edi*4]
	mov	edx, DWORD PTR _web+652
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	mov	eax, DWORD PTR [eax+edx+32]
	and	eax, 1027				; 00000403H
	xor	edx, edx
	or	eax, edx
	jne	SHORT $LN180@new_popver

; 314  :         side[i].degfree--;

	dec	DWORD PTR [ebx]
$LN180@new_popver:

; 312  :       for ( j = 1; j <= (int)emap[0] ; j++ )

	inc	edi
	cmp	edi, DWORD PTR [ecx]
	jle	SHORT $LL181@new_popver

; 309  :     }
; 310  :     else if ( attr1 & CONSTRAINT )

	jmp	$LN179@new_popver

; 318  :     side[i].fe = get_edge_fe(e_id);

$LN265@new_popver:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN264@new_popver
	xor	eax, 134217728				; 08000000H
$LN264@new_popver:
	mov	DWORD PTR [ebx-68], eax

; 319  :     if ( valid_id(side[i].fe) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN176@new_popver

; 320  :     { f1 = get_fe_facet(side[i].fe);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+24]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	je	SHORT $LN1031@new_popver
	xor	edx, 134217728				; 08000000H
$LN1031@new_popver:

; 321  :       if ( valid_id(f1) && inverted(f1) )

	test	edx, 268435456				; 10000000H
	je	SHORT $LN176@new_popver
	test	edx, 134217728				; 08000000H
	je	SHORT $LN176@new_popver

; 322  :          side[i].fe = get_next_facet(side[i].fe);

	test	eax, eax
	je	SHORT $LN273@new_popver
	mov	eax, DWORD PTR [ecx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN272@new_popver
$LN273@new_popver:
	mov	eax, DWORD PTR [ecx+40]
$LN272@new_popver:
	mov	DWORD PTR [ebx-68], eax
$LN176@new_popver:

; 323  :     }
; 324  :     get_edge_tail_tangent(side[i].e_id,side[i].vec);

	mov	eax, DWORD PTR _e_id$[ebp]
	lea	edi, DWORD PTR [ebx-64]
	push	edi
	push	eax
	call	_get_edge_tail_tangent

; 325  :     side[i].norm = sqrt(SDIM_dot(side[i].vec,side[i].vec));

	mov	ecx, DWORD PTR _web+616
	push	ecx
	push	edi
	push	edi
	call	_dot
	add	esp, 20					; 00000014H
	call	__CIsqrt
	fst	QWORD PTR [ebx-16]

; 326  :     if ( side[i].norm <= 0.0 )

	fldz
	fcompp
	fnstsw	ax
	test	ah, 1
	je	$LN848@new_popver

; 332  :     }
; 333  :     side[i].density = get_edge_density(side[i].e_id);

	mov	edx, DWORD PTR [ebx-72]
	mov	eax, DWORD PTR _web+124

; 334  :     e_id = get_next_tail_edge(e_id);
; 335  :     if ( equal_id(e_id,first_e) && ( i < edges-1 ) )

	mov	edi, DWORD PTR _edges$GSCopy$[ebp]
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	fld	QWORD PTR [ecx+40]
	mov	edx, DWORD PTR _e_id$[ebp]
	fstp	QWORD PTR [ebx-8]
	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [eax+esi]
	mov	esi, DWORD PTR _i$[ebp]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	eax, DWORD PTR [ecx+edx*4+32]
	mov	DWORD PTR _e_id$[ebp], eax
	cmp	eax, DWORD PTR _first_e$[ebp]
	jne	SHORT $LN190@new_popver
	lea	edx, DWORD PTR [edi-1]
	cmp	esi, edx
	jge	SHORT $LN190@new_popver

; 336  :     { sprintf(errmsg,
; 337  :              "Internal error: Expected %d edges; found %d.\n",edges,i+1);

	lea	eax, DWORD PTR [esi+1]
	push	eax
	push	edi
	push	OFFSET ??_C@_0CO@GPACBIPK@Internal?5error?3?5Expected?5?$CFd?5edge@
	push	OFFSET _errmsg
	call	_sprintf

; 338  :       outstring(errmsg);

	push	OFFSET _errmsg
	call	_outstring

; 339  :       kb_error(1384,
; 340  :         "new_popverst(): Not expected number of edges around vertex\n",
; 341  :            RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DM@FBNJGOHP@new_popverst?$CI?$CJ?3?5Not?5expected?5num@
	push	1384					; 00000568H
	call	_kb_error
	add	esp, 32					; 00000020H
$LN190@new_popver:

; 294  :   for ( i = 0 ; i < edges ; i++  )

	inc	esi
	add	ebx, 80					; 00000050H
	mov	DWORD PTR _i$[ebp], esi
	mov	DWORD PTR tv9937[ebp], ebx
	cmp	esi, edi
	jl	$LL191@new_popver

; 486  :         } while ( !equal_id(fe,start_fe) );

	mov	eax, DWORD PTR _side$[ebp]
	mov	esi, DWORD PTR _edges$GSCopy$[ebp]
$LN189@new_popver:

; 342  :     }  
; 343  :   }
; 344  : 
; 345  :   if ( edges==3 )

	cmp	esi, 3
	jne	$LN1027@new_popver

; 346  :     if ( ( (side[0].degfree <= degfree) ? 1:0 ) 
; 347  :         + ( (side[1].degfree <= degfree) ? 1:0 )
; 348  :         + ( (side[2].degfree <= degfree) ? 1:0 ) >= 2 )

	mov	edi, DWORD PTR _degfree$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [eax+232], edi
	setle	dl
	xor	ecx, ecx
	cmp	DWORD PTR [eax+152], edi
	setle	cl
	add	edx, ecx
	xor	ecx, ecx
	cmp	DWORD PTR [eax+72], edi
	setle	cl
	add	edx, ecx
	cmp	edx, 2
	jl	$LN1027@new_popver

; 349  :     {  temp_free((char *)side);

	push	eax
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi

; 350  :        return 0;

	xor	eax, eax
	pop	ebx

; 941  : } // end new_popverst()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN848@new_popver:

; 327  :     { sprintf(errmsg,"verpop: edge %s length zero. \n",
; 328  :         ELNAME(side[i].e_id));

	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _side$[ebp]
	lea	ecx, DWORD PTR [eax+eax*4]
	add	ecx, ecx
	mov	eax, DWORD PTR [esi+ecx*8]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN218@new_popver
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN219@new_popver
$LN218@new_popver:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN219@new_popver:
	push	eax
	push	OFFSET ??_C@_0BP@CGONBMGD@verpop?3?5edge?5?$CFs?5length?5zero?4?5?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 329  :       kb_error(1383,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1383					; 00000567H
	call	_kb_error

; 330  :       temp_free((char *)side);

	push	esi
	call	_temp_free
	add	esp, 28					; 0000001cH
$LN1140@new_popver:

; 331  :       return 0;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 941  : } // end new_popverst()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1027@new_popver:

; 351  :     }
; 352  :         
; 353  :   /* order edges around vertex geometrically */
; 354  :   /*
; 355  :   if ( SDIM == 2 )
; 356  :      qsort((char*)side,edges,sizeof(struct side_t),FCAST anglecomp);
; 357  :   else
; 358  :   */
; 359  :   { /* see if we can use facet info */
; 360  :     facetedge_id fe;
; 361  :     int top,bottom;
; 362  :     int ends = 0;  /* can have at most two ends of facet fan */ 

	xor	edi, edi

; 363  :     for ( i = 0 ; i < edges ; i++ )

	xor	edx, edx
	test	esi, esi
	mov	esi, DWORD PTR _web+460
	jle	$LN1011@new_popver

; 351  :     }
; 352  :         
; 353  :   /* order edges around vertex geometrically */
; 354  :   /*
; 355  :   if ( SDIM == 2 )
; 356  :      qsort((char*)side,edges,sizeof(struct side_t),FCAST anglecomp);
; 357  :   else
; 358  :   */
; 359  :   { /* see if we can use facet info */
; 360  :     facetedge_id fe;
; 361  :     int top,bottom;
; 362  :     int ends = 0;  /* can have at most two ends of facet fan */ 

	add	eax, 4
	mov	DWORD PTR tv7405[ebp], eax
	mov	ebx, eax
	npad	3
$LL1009@new_popver:

; 364  :     { if ( !valid_id(get_fe_facet(side[i].fe)) ) goto order_fail;    

	mov	eax, DWORD PTR [ebx]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN279@new_popver
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN278@new_popver
$LN279@new_popver:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN278@new_popver
	xor	ecx, 134217728				; 08000000H
$LN278@new_popver:
	test	ecx, 268435456				; 10000000H
	je	$order_fail$89311

; 365  :       if ( equal_id(get_next_facet(side[i].fe),side[i].fe) ) ends++;

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN283@new_popver
	mov	ecx, DWORD PTR [ecx+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN282@new_popver
$LN283@new_popver:
	mov	ecx, DWORD PTR [ecx+40]
$LN282@new_popver:
	cmp	ecx, eax
	jne	SHORT $LN170@new_popver
	inc	edi
$LN170@new_popver:

; 363  :     for ( i = 0 ; i < edges ; i++ )

	inc	edx
	add	ebx, 80					; 00000050H
	cmp	edx, DWORD PTR _edges$GSCopy$[ebp]
	jl	SHORT $LL1009@new_popver

; 366  :     }
; 367  :     if ( (ends != 0) && (ends != 2) ) goto order_fail;

	test	edi, edi
	je	$LN1011@new_popver
	cmp	edi, 2
	jne	$order_fail$89311

; 368  :     if ( ends == 2 )
; 369  :     { /* move an end to the first slot */
; 370  :       for ( i = 0 ; i < edges ; i++ )

	mov	edi, DWORD PTR tv7405[ebp]
	mov	ebx, DWORD PTR _edges$GSCopy$[ebp]
	xor	edx, edx
	npad	8
$LL1024@new_popver:

; 371  :       { if ( equal_id(get_next_facet(side[i].fe),side[i].fe) )

	mov	ecx, DWORD PTR [edi]
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN287@new_popver
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN286@new_popver
$LN287@new_popver:
	mov	eax, DWORD PTR [eax+40]
$LN286@new_popver:
	cmp	eax, ecx
	je	SHORT $LN850@new_popver

; 368  :     if ( ends == 2 )
; 369  :     { /* move an end to the first slot */
; 370  :       for ( i = 0 ; i < edges ; i++ )

	inc	edx
	add	edi, 80					; 00000050H
	cmp	edx, ebx
	jl	SHORT $LL1024@new_popver

; 486  :         } while ( !equal_id(fe,start_fe) );

	jmp	SHORT $LN1011@new_popver
$LN850@new_popver:

; 372  :         { struct side_t temp;
; 373  :           if ( i == 0 ) break;

	test	edx, edx
	je	SHORT $LN1011@new_popver

; 374  :           temp = side[0];

	mov	ebx, DWORD PTR _side$[ebp]

; 375  :           side[0] = side[i];

	lea	eax, DWORD PTR [edx+edx*4]
	shl	eax, 4
	mov	ecx, 20					; 00000014H
	mov	esi, ebx
	lea	edi, DWORD PTR _temp$89319[ebp]
	rep movsd
	add	eax, ebx
	mov	ecx, 20					; 00000014H
	mov	esi, eax
	mov	edi, ebx
	rep movsd

; 376  :           side[i] = temp;

	mov	ecx, 20					; 00000014H
	lea	esi, DWORD PTR _temp$89319[ebp]
	mov	edi, eax
	rep movsd
	mov	esi, DWORD PTR _web+460
$LN1011@new_popver:

; 377  :           break;
; 378  :         }
; 379  :       }
; 380  :     }
; 381  :     /* now trace path around facets */
; 382  :     fe = side[0].fe;

	mov	edx, DWORD PTR _side$[ebp]
	mov	eax, DWORD PTR [edx+4]

; 383  :     for ( i = 1 ; i < edges ; i++ )

	mov	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR _edges$GSCopy$[ebp], ecx
	jle	$order_succeed$89333

; 377  :           break;
; 378  :         }
; 379  :       }
; 380  :     }
; 381  :     /* now trace path around facets */
; 382  :     fe = side[0].fe;

	mov	ecx, edx
	add	ecx, 80					; 00000050H
	mov	DWORD PTR tv10091[ebp], ecx
	npad	5
$LL159@new_popver:

; 384  :     { facetedge_id next_fe = inverse_id(get_prev_edge(fe));

	test	eax, 134217728				; 08000000H
	je	SHORT $LN291@new_popver
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN290@new_popver
$LN291@new_popver:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+28]
$LN290@new_popver:

; 385  :       edge_id next_e = get_fe_edge(next_fe);
; 386  :       for ( j = i; j < edges ; j++ )

	mov	edi, DWORD PTR _i$[ebp]
	xor	eax, 134217728				; 08000000H
	mov	ebx, eax
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [esi+eax]
	mov	ecx, ebx
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [edx+20]
	mov	edx, edi
	cmp	edi, DWORD PTR _edges$GSCopy$[ebp]
	jge	SHORT $LN979@new_popver

; 384  :     { facetedge_id next_fe = inverse_id(get_prev_edge(fe));

	mov	esi, DWORD PTR tv10091[ebp]
$LL991@new_popver:

; 387  :         if ( equal_id(side[j].e_id,next_e) )

	cmp	DWORD PTR [esi], ecx
	je	SHORT $LN851@new_popver

; 385  :       edge_id next_e = get_fe_edge(next_fe);
; 386  :       for ( j = i; j < edges ; j++ )

	inc	edx
	add	esi, 80					; 00000050H
	cmp	edx, DWORD PTR _edges$GSCopy$[ebp]
	jl	SHORT $LL991@new_popver

; 486  :         } while ( !equal_id(fe,start_fe) );

	jmp	SHORT $LN979@new_popver
$LN851@new_popver:

; 388  :         { struct side_t temp;
; 389  :           if ( i == j ) break;

	cmp	edi, edx
	je	SHORT $LN979@new_popver

; 390  :           temp = side[j];

	mov	esi, DWORD PTR _side$[ebp]
	lea	ecx, DWORD PTR [edx+edx*4]
	shl	ecx, 4
	add	esi, ecx
	mov	DWORD PTR tv7436[ebp], esi
	mov	ecx, 20					; 00000014H
	lea	edi, DWORD PTR _temp$89330[ebp]
	rep movsd

; 391  :           side[j] = side[i];

	mov	esi, DWORD PTR tv10091[ebp]
	mov	edi, DWORD PTR tv7436[ebp]
	mov	ecx, 20					; 00000014H
	rep movsd

; 392  :           side[i] = temp;

	mov	edi, DWORD PTR tv10091[ebp]
	mov	ecx, 20					; 00000014H
	lea	esi, DWORD PTR _temp$89330[ebp]
	rep movsd
	mov	edi, DWORD PTR _i$[ebp]
$LN979@new_popver:

; 393  :           break;
; 394  :         }
; 395  :       if ( j == edges ) goto order_fail;

	mov	ecx, DWORD PTR _edges$GSCopy$[ebp]

; 486  :         } while ( !equal_id(fe,start_fe) );

	mov	esi, DWORD PTR _web+460
	cmp	edx, ecx
	je	SHORT $order_fail$89311

; 396  :       fe = get_next_facet(next_fe);

	test	ebx, 134217728				; 08000000H
	je	SHORT $LN297@new_popver
	mov	edx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN158@new_popver
$LN297@new_popver:
	mov	eax, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [eax+40]
$LN158@new_popver:

; 383  :     for ( i = 1 ; i < edges ; i++ )

	add	DWORD PTR tv10091[ebp], 80		; 00000050H
	inc	edi
	mov	DWORD PTR _i$[ebp], edi
	cmp	edi, ecx
	jl	$LL159@new_popver

; 486  :         } while ( !equal_id(fe,start_fe) );

	jmp	$order_succeed$89333
$order_fail$89311:

; 397  :     }
; 398  :     goto order_succeed;
; 399  : 
; 400  : order_fail:
; 401  :     /* try geometric ordering by adding closest to existing chain */
; 402  :     /* Leave first where it is, as initial link in chain */
; 403  :     side[edges] = side[0];

	mov	ebx, DWORD PTR _edges$GSCopy$[ebp]
	mov	edx, DWORD PTR _side$[ebp]
	lea	eax, DWORD PTR [ebx+ebx*4]
	shl	eax, 4
	add	eax, edx
	mov	esi, edx
	mov	ecx, 20					; 00000014H
	mov	edi, eax
	add	edx, 8
	rep movsd

; 404  :     top = edges;

	mov	DWORD PTR _top$89303[ebp], ebx

; 405  :     bottom = 0;

	mov	DWORD PTR _bottom$89304[ebp], 0
	mov	DWORD PTR tv10203[ebp], eax
	mov	DWORD PTR tv10242[ebp], edx
	npad	1
$LL955@new_popver:

; 409  :       bottomgap = topgap = -1e30;
; 410  :       for ( i = bottom+1 ; i < top ; i++ )

	mov	esi, DWORD PTR _bottom$89304[ebp]
	fld	QWORD PTR __real@c6293e5939a08cea
	xor	eax, eax
	fst	QWORD PTR _topgap$89337[ebp]
	inc	esi
	fstp	QWORD PTR _bottomgap$89338[ebp]
	mov	DWORD PTR _topbest$89341[ebp], eax
	mov	DWORD PTR _bottombest$89342[ebp], eax
	mov	DWORD PTR tv7460[ebp], esi
	cmp	esi, DWORD PTR _top$89303[ebp]
	jge	$LN953@new_popver

; 407  :     { REAL topgap,bottomgap,topcos,bottomcos;
; 408  :       int topbest=0,bottombest=0;

	mov	edi, DWORD PTR tv10242[ebp]
	sub	edi, -128				; ffffff80H
	jmp	SHORT $LN148@new_popver
	npad	2
$LL1052@new_popver:
	fstp	ST(0)
$LN148@new_popver:

; 411  :       { bottomcos = SDIM_dot(side[i].vec,side[bottom].vec)/
; 412  :                        side[i].norm/side[bottom].norm;

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR tv10242[ebp]
	push	edx
	push	eax
	lea	ebx, DWORD PTR [edi-48]
	push	ebx
	call	_dot
	fdiv	QWORD PTR [edi]
	mov	ecx, DWORD PTR tv10242[ebp]
	add	esp, 12					; 0000000cH
	fdiv	QWORD PTR [ecx+48]

; 413  :         if ( bottomcos > bottomgap )

	fld	QWORD PTR _bottomgap$89338[ebp]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1045@new_popver

; 414  :         { bottomgap = bottomcos; bottombest = i; }

	fstp	QWORD PTR _bottomgap$89338[ebp]
	mov	DWORD PTR _bottombest$89342[ebp], esi
	jmp	SHORT $LN145@new_popver
$LN1045@new_popver:
	fstp	ST(0)
$LN145@new_popver:

; 415  :         topcos = SDIM_dot(side[i].vec,side[top].vec)/
; 416  :                        side[i].norm/side[top].norm;

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR tv10203[ebp]
	push	edx
	add	eax, 8
	push	eax
	push	ebx
	call	_dot
	fdiv	QWORD PTR [edi]
	mov	ecx, DWORD PTR tv10203[ebp]
	add	esp, 12					; 0000000cH
	fdiv	QWORD PTR [ecx+56]

; 417  :         if ( topcos > topgap )

	fld	QWORD PTR _topgap$89337[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1048@new_popver
	fstp	ST(0)

; 418  :         { topgap = topcos; topbest = i; }

	mov	ebx, esi
	fst	QWORD PTR _topgap$89337[ebp]
	mov	DWORD PTR _topbest$89341[ebp], ebx
	jmp	SHORT $LN147@new_popver
$LN1048@new_popver:
	mov	ebx, DWORD PTR _topbest$89341[ebp]
	fstp	ST(1)
$LN147@new_popver:

; 409  :       bottomgap = topgap = -1e30;
; 410  :       for ( i = bottom+1 ; i < top ; i++ )

	mov	ecx, DWORD PTR _top$89303[ebp]
	inc	esi
	add	edi, 80					; 00000050H
	cmp	esi, ecx
	jl	$LL1052@new_popver

; 419  :       }
; 420  :       if ( topgap > bottomgap )

	fcomp	QWORD PTR _bottomgap$89338[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN953@new_popver

; 421  :       { /* add at top */
; 422  :         top--;

	mov	edx, DWORD PTR tv10203[ebp]
	dec	ecx
	sub	edx, 80					; 00000050H
	mov	DWORD PTR _top$89303[ebp], ecx
	mov	DWORD PTR tv10203[ebp], edx

; 423  :         if ( topbest != top )

	cmp	ebx, ecx
	je	$LN954@new_popver

; 424  :         { struct side_t temp = side[top];
; 425  :           side[top] = side[topbest];

	lea	eax, DWORD PTR [ebx+ebx*4]
	shl	eax, 4
	add	eax, DWORD PTR _side$[ebp]
	mov	ecx, 20					; 00000014H
	mov	esi, edx
	lea	edi, DWORD PTR _temp$89350[ebp]
	rep movsd
	mov	ecx, 20					; 00000014H
	mov	esi, eax
	mov	edi, edx
	rep movsd

; 426  :           side[topbest] = temp;

	lea	esi, DWORD PTR _temp$89350[ebp]
	mov	edi, eax

; 427  :         } 
; 428  :       }
; 429  :       else

	jmp	SHORT $LN1115@new_popver
$LN953@new_popver:

; 430  :       { /* add at bottom */
; 431  :         bottom++;

	mov	eax, DWORD PTR tv7460[ebp]

; 432  :         if ( bottombest != bottom )

	mov	edx, DWORD PTR _bottombest$89342[ebp]
	add	DWORD PTR tv10242[ebp], 80		; 00000050H
	mov	DWORD PTR _bottom$89304[ebp], eax
	cmp	edx, eax
	je	SHORT $LN954@new_popver

; 433  :         { struct side_t temp = side[bottom];

	mov	eax, DWORD PTR tv10242[ebp]

; 434  :           side[bottom] = side[bottombest];

	lea	edx, DWORD PTR [edx+edx*4]
	shl	edx, 4
	add	edx, DWORD PTR _side$[ebp]
	mov	ecx, 20					; 00000014H
	lea	esi, DWORD PTR [eax-8]
	lea	edi, DWORD PTR _temp$89353[ebp]
	rep movsd
	mov	ecx, 20					; 00000014H
	mov	esi, edx
	lea	edi, DWORD PTR [eax-8]
	rep movsd

; 435  :           side[bottombest] = temp;

	lea	esi, DWORD PTR _temp$89353[ebp]
	mov	edi, edx
$LN1115@new_popver:
	mov	ecx, 20					; 00000014H
	rep movsd
$LN954@new_popver:

; 406  :     while ( top - bottom > 1 )

	mov	edx, DWORD PTR _top$89303[ebp]
	sub	edx, DWORD PTR _bottom$89304[ebp]
	cmp	edx, 1
	jg	$LL955@new_popver
$order_succeed$89333:

; 436  :         } 
; 437  :       }
; 438  :     }
; 439  : order_succeed: ;
; 440  :   }
; 441  : 
; 442  :   side[edges] = side[0];  /* easy wraparound */

	mov	eax, DWORD PTR _edges$GSCopy$[ebp]
	mov	ebx, DWORD PTR _side$[ebp]
	lea	edi, DWORD PTR [eax+eax*4]
	shl	edi, 4
	add	edi, ebx
	mov	ecx, 20					; 00000014H
	mov	esi, ebx
	rep movsd

; 443  : 
; 444  :   if ( edges == 2 )

	cmp	eax, 2
	jne	$LN135@new_popver

; 445  :   { /* must be constraint or boundary or fixed */
; 446  :     if ( (side[0].degfree <= degfree) || (side[1].degfree <= degfree ) )

	mov	ecx, DWORD PTR [ebx+72]
	mov	esi, DWORD PTR _degfree$[ebp]
	cmp	ecx, esi
	jle	$LN137@new_popver
	mov	eax, DWORD PTR [ebx+152]
	cmp	eax, esi
	jle	$LN137@new_popver

; 449  :     }
; 450  :     if ( (side[0].degfree <= 1 ) && (side[1].degfree <= 1 ) )

	cmp	ecx, 1
	jg	SHORT $LN136@new_popver
	cmp	eax, 1

; 451  :     { temp_free((char *)side);
; 452  :       return 0;

	jle	$LN137@new_popver
$LN136@new_popver:

; 453  :     }
; 454  :     besti = 0;
; 455  :     /* find angle between edges to see which way we want to pop */
; 456  :     cosa = SDIM_dot(side[0].vec,side[1].vec);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR [ebx+88]
	push	ecx
	lea	edx, DWORD PTR [ebx+8]
	push	edx
	call	_dot

; 457  :     e1 = side[0].e_id;

	mov	ecx, DWORD PTR [ebx]

; 458  :     e2 = side[1].e_id;

	mov	eax, DWORD PTR [ebx+80]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _e1$[ebp], ecx
	mov	DWORD PTR _e2$[ebp], eax

; 459  :     if ( (side[0].degfree > degfree) && (side[1].degfree > degfree) &&
; 460  :           (degfree >= 1) && (cosa < 0.0)  )

	cmp	DWORD PTR [ebx+72], esi
	jle	$LN1061@new_popver
	cmp	DWORD PTR [ebx+152], esi
	jle	$LN1061@new_popver
	cmp	esi, 1
	jl	$LN1061@new_popver
	fldz
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN1029@new_popver

; 461  :     { /* split apart along constraint rather than make Y */
; 462  :       facetedge_id start_fe,prev_fe;
; 463  :       facet_id f_id;
; 464  : 
; 465  :       // Check to see we are not splitting edge chain into disjoint parts
; 466  :       fe = start_fe = get_edge_fe(e1);

	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv7511[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	test	eax, eax
	je	SHORT $LN300@new_popver
$LN301@new_popver:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN300@new_popver
	xor	eax, 134217728				; 08000000H
$LN300@new_popver:
	mov	DWORD PTR _start_fe$89361[ebp], eax
	mov	ecx, eax

; 467  :       if ( valid_id(start_fe) )

	test	eax, 268435456				; 10000000H
	je	$LN131@new_popver
	mov	esi, DWORD PTR _web+460
	npad	1
$LL133@new_popver:

; 468  :         do
; 469  :         { prev_fe = get_prev_edge(fe);

	mov	ebx, ecx
	shr	ebx, 27					; 0000001bH
	and	ebx, 1
	je	SHORT $LN305@new_popver
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [esi+eax*4]
	mov	edx, DWORD PTR [edi+32]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN304@new_popver
$LN305@new_popver:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR [edi+28]
$LN304@new_popver:

; 470  :           if ( valid_id(prev_fe) )

	test	edx, 268435456				; 10000000H
	je	SHORT $LN1028@new_popver

; 471  :           { // make sure we have complete loop
; 472  :             facetedge_id ffe = fe;

	mov	eax, ecx

; 473  :             while ( valid_id(ffe) && !equal_id(ffe,prev_fe) )

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN128@new_popver
	npad	1
$LL129@new_popver:
	cmp	eax, edx
	je	SHORT $LN1028@new_popver

; 474  :             { ffe = get_next_edge(ffe);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN309@new_popver
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN308@new_popver
$LN309@new_popver:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+32]
$LN308@new_popver:

; 473  :             while ( valid_id(ffe) && !equal_id(ffe,prev_fe) )

	test	eax, 268435456				; 10000000H
	jne	SHORT $LL129@new_popver
$LN128@new_popver:

; 475  :             };
; 476  :             if ( !equal_id(ffe,prev_fe) )

	cmp	eax, edx
	jne	SHORT $LN853@new_popver
$LN1028@new_popver:

; 483  :             }
; 484  :           }
; 485  :           fe = get_next_facet(fe);

	test	ebx, ebx
	je	SHORT $LN321@new_popver
	mov	ecx, DWORD PTR [edi+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN132@new_popver
$LN321@new_popver:
	mov	ecx, DWORD PTR [edi+40]
$LN132@new_popver:

; 486  :         } while ( !equal_id(fe,start_fe) );

	cmp	ecx, DWORD PTR _start_fe$89361[ebp]
	jne	$LL133@new_popver
$LN131@new_popver:

; 487  : 
; 488  :       if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0

; 489  :       { sprintf(msg,"Popping vertex %s.\n",ELNAME(v_id));

	mov	edi, DWORD PTR _v_id$GSCopy$[ebp]
	je	$LN125@new_popver
	test	edi, 268435456				; 10000000H
	je	$LN224@new_popver
	mov	ecx, DWORD PTR tv7104[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	$LN225@new_popver
$LN853@new_popver:

; 477  :             { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN126@new_popver

; 478  :               { sprintf(msg,"Not splitting vertex %s since that would create two separate edge chains for facet %s\n",
; 479  :                   ELNAME(v_id),ELNAME2(get_fe_facet(fe)));

	mov	eax, DWORD PTR _NULLFACET
	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	SHORT $LN313@new_popver
	mov	edi, eax
	jmp	SHORT $LN312@new_popver
$LN313@new_popver:
	mov	edi, ecx
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [esi+edi*4]
	mov	edi, DWORD PTR [edi+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN312@new_popver
	xor	edi, 134217728				; 08000000H
$LN312@new_popver:
	test	edi, 268435456				; 10000000H
	je	SHORT $LN220@new_popver
	test	edx, edx
	je	SHORT $LN316@new_popver
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+edx*4]
	mov	eax, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN316@new_popver
	xor	eax, 134217728				; 08000000H
$LN316@new_popver:
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+60
	jmp	SHORT $LN221@new_popver
$LN220@new_popver:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN221@new_popver:
	test	DWORD PTR _v_id$GSCopy$[ebp], 268435456	; 10000000H
	je	SHORT $LN222@new_popver
	mov	ecx, DWORD PTR tv7104[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN223@new_popver
$LN222@new_popver:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN223@new_popver:
	mov	edx, DWORD PTR _msg
	push	esi
	push	eax
	push	OFFSET ??_C@_0FH@KCAIHKEA@Not?5splitting?5vertex?5?$CFs?5since?5th@
	push	edx
	call	_sprintf

; 480  :                 outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H
$LN126@new_popver:

; 481  :               }
; 482  :               return 0;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 941  : } // end new_popverst()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN224@new_popver:

; 489  :       { sprintf(msg,"Popping vertex %s.\n",ELNAME(v_id));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN225@new_popver:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BE@PMHCEJIK@Popping?5vertex?5?$CFs?4?6?$AA@
	push	edx
	call	_sprintf

; 490  :         outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
$LN125@new_popver:

; 491  :       }
; 492  :       new_v = dup_vertex(v_id);  /* new vertex in same spot, to be pulled away */

	push	edi
	call	_dup_vertex

; 493  :       attrv = get_vattr(new_v);
; 494  :       remove_vertex_edge(v_id,e2);

	mov	ebx, DWORD PTR _e2$[ebp]
	mov	esi, eax
	push	ebx
	push	edi
	mov	DWORD PTR _new_v$[ebp], esi
	call	_remove_vertex_edge

; 495  :       set_edge_tailv(e2,new_v);

	push	esi
	push	ebx
	call	_set_edge_tailv

; 496  : 
; 497  :       fe = start_fe = get_edge_fe(e1);

	mov	ecx, DWORD PTR tv7511[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [ecx+edx]
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN325@new_popver
	xor	edi, edi
	jmp	SHORT $LN326@new_popver
$LN325@new_popver:
	test	DWORD PTR _e1$[ebp], 134217728		; 08000000H
	mov	eax, DWORD PTR [eax+28]
	je	SHORT $LN324@new_popver
	xor	eax, 134217728				; 08000000H
$LN324@new_popver:
	mov	edi, eax
$LN326@new_popver:

; 498  :       if ( valid_id(start_fe) )

	mov	eax, edi
	shr	eax, 28					; 0000001cH
	mov	ebx, eax
	test	al, 1
	mov	eax, DWORD PTR _web+460
	mov	esi, edi
	je	$LN121@new_popver
	npad	1
$LL123@new_popver:

; 499  :       do 
; 500  :       {
; 501  :         set_prev_edge(fe,NULLID);

	test	bl, 1
	je	SHORT $LN1032@new_popver
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN329@new_popver
	mov	DWORD PTR [edx+32], 134217728		; 08000000H
	jmp	SHORT $LN328@new_popver
$LN329@new_popver:
	mov	DWORD PTR [edx+28], 0
$LN328@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	eax, DWORD PTR _web+460
$LN1032@new_popver:

; 502  :         fe = get_next_facet(fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN334@new_popver
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN333@new_popver
$LN334@new_popver:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [edx+40]
$LN333@new_popver:

; 503  :         f_id = get_fe_facet(fe);

	mov	ebx, esi
	shr	ebx, 28					; 0000001cH
	test	bl, 1
	jne	SHORT $LN338@new_popver
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN337@new_popver
$LN338@new_popver:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN337@new_popver
	xor	ecx, 134217728				; 08000000H
$LN337@new_popver:

; 504  :         if ( !inverted(f_id) )

	test	ecx, 134217728				; 08000000H
	jne	SHORT $LN122@new_popver

; 505  :           set_facet_fe(f_id,fe); // new start of edge chain

	push	esi
	push	ecx
	call	_set_facet_fe
	mov	eax, DWORD PTR _web+460
	add	esp, 8
$LN122@new_popver:

; 506  :       } while ( !equal_id(fe,start_fe) );

	cmp	esi, edi
	jne	$LL123@new_popver
$LN121@new_popver:

; 507  : 
; 508  :       fe = start_fe = get_edge_fe(e2);

	mov	edx, DWORD PTR _e2$[ebp]
	mov	esi, DWORD PTR _web+124
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	test	ecx, ecx
	je	SHORT $LN341@new_popver
$LN342@new_popver:
	mov	ecx, DWORD PTR [ecx+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN341@new_popver
	xor	ecx, 134217728				; 08000000H
$LN341@new_popver:
	mov	DWORD PTR _start_fe$89361[ebp], ecx
	mov	esi, ecx

; 509  :       if ( valid_id(start_fe) )

	shr	ecx, 28					; 0000001cH
	mov	ebx, ecx
	test	cl, 1
	je	$newpop_exit$89402
	mov	edi, 134217728				; 08000000H
	npad	7
$LL118@new_popver:

; 510  :       do 
; 511  :       {
; 512  :         set_prev_edge(fe,NULLID);

	test	bl, 1
	je	SHORT $LN1033@new_popver
	test	esi, edi
	je	SHORT $LN346@new_popver
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [eax+32], edi
	jmp	SHORT $LN345@new_popver
$LN346@new_popver:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx+28], 0
$LN345@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	eax, DWORD PTR _web+460
$LN1033@new_popver:

; 513  :         fe = get_next_facet(fe);

	test	esi, edi
	je	SHORT $LN351@new_popver
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+36]
	xor	esi, edi
	jmp	SHORT $LN350@new_popver
$LN351@new_popver:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [edx+40]
$LN350@new_popver:

; 514  :         f_id = get_fe_facet(fe);

	mov	ebx, esi
	shr	ebx, 28					; 0000001cH
	test	bl, 1
	jne	SHORT $LN355@new_popver
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN354@new_popver
$LN355@new_popver:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+24]
	test	esi, edi
	je	SHORT $LN354@new_popver
	xor	ecx, edi
$LN354@new_popver:

; 515  :         if ( !inverted(f_id) )

	test	ecx, edi
	jne	SHORT $LN117@new_popver

; 516  :           set_facet_fe(f_id,fe); // new start of edge chain

	push	esi
	push	ecx
	call	_set_facet_fe
	mov	eax, DWORD PTR _web+460
	add	esp, 8
$LN117@new_popver:

; 517  :       } while ( !equal_id(fe,start_fe) );

	cmp	esi, DWORD PTR _start_fe$89361[ebp]
	jne	$LL118@new_popver

; 518  : 
; 519  : 
; 520  :       goto newpop_exit;

	jmp	$newpop_exit$89402
$LN137@new_popver:

; 447  :     { temp_free((char *)side);

	push	ebx
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi

; 448  :       return 0;

	xor	eax, eax
	pop	ebx

; 941  : } // end new_popverst()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1061@new_popver:

; 459  :     if ( (side[0].degfree > degfree) && (side[1].degfree > degfree) &&
; 460  :           (degfree >= 1) && (cosa < 0.0)  )

	fstp	ST(0)
$LN1029@new_popver:

; 448  :       return 0;

	mov	eax, DWORD PTR _edges$GSCopy$[ebp]
$LN135@new_popver:

; 521  :     }
; 522  :   }
; 523  : 
; 524  :   if ( pop_disjoin_flag && (edges == 4) )

	cmp	DWORD PTR _pop_disjoin_flag, 0
	je	$LN959@new_popver
	cmp	eax, 4
	jne	$LN959@new_popver

; 536  :       { f_id[i] = b_id[i] = NULLID;

	mov	edi, DWORD PTR _web+460
	mov	DWORD PTR tv10335[ebp], ebx
	xor	esi, esi
$LL113@new_popver:

; 533  :     { /* assume positive facets on bodies */
; 534  :       fe_id[i] = get_edge_fe(side[i].e_id);

	mov	eax, DWORD PTR tv10335[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR _web+124
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+edx*4]
	xor	edx, edx
	cmp	eax, edx
	jne	SHORT $LN359@new_popver
	xor	eax, eax
	jmp	SHORT $LN358@new_popver
$LN359@new_popver:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN358@new_popver
	xor	eax, 134217728				; 08000000H
$LN358@new_popver:
	mov	DWORD PTR _fe_id$89404[ebp+esi], eax

; 535  :       if ( !valid_id(fe_id[i]) )

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN110@new_popver

; 536  :       { f_id[i] = b_id[i] = NULLID;

	mov	DWORD PTR _b_id$89406[ebp+esi], edx
	mov	DWORD PTR _f_id$89405[ebp+esi], edx

; 537  :         continue;

	jmp	$LN112@new_popver
$LN110@new_popver:

; 538  :       }
; 539  :       f_id[i] = get_fe_facet(fe_id[i]);

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [edx+24]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	je	SHORT $LN362@new_popver
	xor	ecx, 134217728				; 08000000H
$LN362@new_popver:
	mov	DWORD PTR _f_id$89405[ebp+esi], ecx

; 540  :       if ( inverted(f_id[i]) )

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN1030@new_popver

; 541  :       { fe_id[i] = get_next_facet(fe_id[i]);

	test	eax, eax
	je	SHORT $LN367@new_popver
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN366@new_popver
$LN367@new_popver:
	mov	eax, DWORD PTR [edx+40]
$LN366@new_popver:
	mov	DWORD PTR _fe_id$89404[ebp+esi], eax

; 542  :         f_id[i] = get_fe_facet(fe_id[i]);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN371@new_popver
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN372@new_popver
$LN371@new_popver:
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+edx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN370@new_popver
	xor	ecx, 134217728				; 08000000H
$LN370@new_popver:
	mov	eax, ecx
$LN372@new_popver:
	mov	DWORD PTR _f_id$89405[ebp+esi], eax

; 543  :         if ( inverted(f_id[i]) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN1030@new_popver

; 544  :         { f_id[i] = b_id[i] = fe_id[i] = NULLID;

	xor	eax, eax
	mov	DWORD PTR _fe_id$89404[ebp+esi], eax
	mov	DWORD PTR _f_id$89405[ebp+esi], eax

; 545  :           continue;

	jmp	SHORT $LN374@new_popver
$LN1030@new_popver:

; 546  :         }
; 547  :       }
; 548  :       b_id[i] = get_facet_body(f_id[i]);

	cmp	DWORD PTR _web+400, 0
	mov	eax, DWORD PTR _f_id$89405[ebp+esi]
	jne	SHORT $LN377@new_popver
	xor	eax, eax
	jmp	SHORT $LN374@new_popver
$LN377@new_popver:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN376@new_popver
	xor	eax, eax
	jmp	SHORT $LN374@new_popver
$LN376@new_popver:
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR _web+328
	test	eax, 134217728				; 08000000H
	je	SHORT $LN375@new_popver
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN374@new_popver
$LN375@new_popver:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	eax, DWORD PTR [eax+ecx]
$LN374@new_popver:
	mov	DWORD PTR _b_id$89406[ebp+esi], eax
$LN112@new_popver:

; 525  :   { /* see if exactly two opposite wedges have same body */
; 526  :     facetedge_id fe_id[4];
; 527  :     facet_id f_id[4];
; 528  :     body_id b_id[4];
; 529  :     int same02,same13;
; 530  :     REAL *xnew,*xold,*x0,*x1,*x2,*x3;
; 531  : 
; 532  :     for ( i = 0 ; i < edges ; i++ )

	add	DWORD PTR tv10335[ebp], 80		; 00000050H

; 536  :       { f_id[i] = b_id[i] = NULLID;

	add	esi, 4
	cmp	esi, 16					; 00000010H
	jl	$LL113@new_popver

; 549  :     }
; 550  :     same02 = equal_id(b_id[0],b_id[2]) && valid_id(b_id[0]);

	mov	eax, DWORD PTR _b_id$89406[ebp]
	cmp	eax, DWORD PTR _b_id$89406[ebp+8]
	jne	SHORT $LN1034@new_popver
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1034@new_popver
	mov	ecx, 1
	jmp	SHORT $LN227@new_popver
$LN1034@new_popver:
	xor	ecx, ecx
$LN227@new_popver:

; 551  :     same13 = equal_id(b_id[1],b_id[3]) && valid_id(b_id[1]);

	mov	eax, DWORD PTR _b_id$89406[ebp+4]
	cmp	eax, DWORD PTR _b_id$89406[ebp+12]
	jne	SHORT $LN228@new_popver
	test	eax, 268435456				; 10000000H
	je	SHORT $LN228@new_popver
	mov	eax, 1
	jmp	SHORT $LN229@new_popver
$LN228@new_popver:
	xor	eax, eax
$LN229@new_popver:

; 552  :     if ( same02 != same13 )

	cmp	ecx, eax
	je	$LN107@new_popver

; 553  :     { /* do the disjoin */
; 554  :       if ( same13 )

	test	eax, eax
	je	$LN943@new_popver

; 555  :       { /* shuffle things so same02 */
; 556  :         element_id temp;
; 557  :         struct side_t tempside = side[0];

	mov	ebx, DWORD PTR _side$[ebp]

; 558  :         side[0] = side[1]; side[1] = side[2]; side[2] = side[3]; 
; 559  :         side[3] = tempside;
; 560  :         temp = fe_id[0]; fe_id[0] = fe_id[1]; fe_id[1] = fe_id[2];
; 561  :         fe_id[2] = fe_id[3]; fe_id[3] = temp;

	mov	edx, DWORD PTR _fe_id$89404[ebp+12]

; 562  :         temp = f_id[0]; f_id[0] = f_id[1]; f_id[1] = f_id[2];

	mov	eax, DWORD PTR _f_id$89405[ebp+4]
	mov	esi, ebx
	mov	ecx, 20					; 00000014H
	lea	edi, DWORD PTR _tempside$89429[ebp]
	rep movsd
	lea	esi, DWORD PTR [ebx+80]
	mov	edi, ebx
	mov	ecx, 20					; 00000014H
	rep movsd
	lea	esi, DWORD PTR [ebx+160]
	lea	edi, DWORD PTR [ebx+80]
	mov	ecx, 20					; 00000014H
	rep movsd
	lea	esi, DWORD PTR [ebx+240]
	lea	edi, DWORD PTR [ebx+160]
	mov	ecx, 20					; 00000014H
	rep movsd
	lea	edi, DWORD PTR [ebx+240]
	mov	ebx, DWORD PTR _fe_id$89404[ebp+4]
	mov	ecx, 20					; 00000014H
	lea	esi, DWORD PTR _tempside$89429[ebp]
	rep movsd

; 563  :         f_id[2] = f_id[3]; f_id[3] = temp;

	mov	ecx, DWORD PTR _f_id$89405[ebp+12]
	mov	DWORD PTR _fe_id$89404[ebp+8], edx

; 564  :         temp = b_id[0]; b_id[0] = b_id[1]; b_id[1] = b_id[2];

	mov	edx, DWORD PTR _b_id$89406[ebp+4]
	mov	DWORD PTR _f_id$89405[ebp], eax

; 565  :         b_id[2] = b_id[3]; b_id[3] = temp;

	mov	eax, DWORD PTR _b_id$89406[ebp+12]
	mov	DWORD PTR _fe_id$89404[ebp], ebx
	mov	DWORD PTR _f_id$89405[ebp+8], ecx
	mov	DWORD PTR _b_id$89406[ebp], edx
	mov	DWORD PTR _b_id$89406[ebp+8], eax
	jmp	SHORT $LN106@new_popver
$LN943@new_popver:
	mov	ebx, DWORD PTR _fe_id$89404[ebp]
$LN106@new_popver:

; 566  :       }
; 567  :       /* now the real action */
; 568  :       new_v = dup_vertex(v_id);  /* new vertex in same spot */

	mov	edi, DWORD PTR _v_id$GSCopy$[ebp]
	push	edi
	call	_dup_vertex

; 569  :       remove_vertex_edge(v_id,side[1].e_id);

	mov	esi, DWORD PTR _side$[ebp]
	mov	ecx, DWORD PTR [esi+80]
	push	ecx
	push	edi
	mov	DWORD PTR _new_v$[ebp], eax
	call	_remove_vertex_edge

; 570  :       set_edge_tailv(side[1].e_id,new_v);

	mov	edx, DWORD PTR _new_v$[ebp]
	mov	eax, DWORD PTR [esi+80]
	push	edx
	push	eax
	call	_set_edge_tailv

; 571  :       remove_vertex_edge(v_id,side[2].e_id);

	mov	ecx, DWORD PTR [esi+160]
	push	ecx
	push	edi
	call	_remove_vertex_edge

; 572  :       set_edge_tailv(side[2].e_id,new_v);

	mov	edx, DWORD PTR _new_v$[ebp]
	mov	eax, DWORD PTR [esi+160]
	push	edx
	push	eax
	call	_set_edge_tailv
	add	esp, 36					; 00000024H

; 573  :       if ( valid_id(f_id[0]) )

	test	DWORD PTR _f_id$89405[ebp], 268435456	; 10000000H
	je	$LN104@new_popver

; 574  :       { /* have to merge facets */
; 575  :         facetedge_id fe_a = fe_id[0];
; 576  :         facetedge_id fe_b = inverse_id(get_prev_edge(fe_a));

	mov	edi, DWORD PTR _web+460
	mov	eax, ebx
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv9501[ebp], eax
	je	SHORT $LN381@new_popver
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR tv9513[ebp], eax
	mov	eax, DWORD PTR [eax+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN380@new_popver
$LN381@new_popver:
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+edx*4]
	mov	DWORD PTR tv9513[ebp], eax
	mov	eax, DWORD PTR [eax+28]
$LN380@new_popver:
	xor	eax, 134217728				; 08000000H
	mov	esi, eax

; 577  :         facetedge_id fe_c = fe_id[2];
; 578  :         facetedge_id fe_d = inverse_id(get_prev_edge(fe_c));

	mov	eax, DWORD PTR _fe_id$89404[ebp+8]
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR tv9532[ebp], ecx
	je	SHORT $LN385@new_popver
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [ecx+32]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN384@new_popver
$LN385@new_popver:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [edx+28]
$LN384@new_popver:
	xor	ecx, 134217728				; 08000000H

; 579  :         set_prev_edge(fe_a,inverse_id(fe_d));

	mov	edx, ecx
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR tv7765[ebp], edx
	test	ebx, 268435456				; 10000000H
	je	SHORT $LN391@new_popver
	cmp	DWORD PTR tv9501[ebp], 0
	mov	edi, DWORD PTR tv9513[ebp]
	je	SHORT $LN389@new_popver
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [edi+32], edx
	jmp	SHORT $LN388@new_popver
$LN389@new_popver:
	mov	DWORD PTR [edi+28], edx
$LN388@new_popver:
	mov	edx, DWORD PTR _global_timestamp
	mov	edi, DWORD PTR _web+460
	inc	edx
	mov	DWORD PTR _global_timestamp, edx
	mov	DWORD PTR _top_timestamp, edx
$LN391@new_popver:

; 580  :         set_prev_edge(fe_b,inverse_id(fe_c));

	mov	edx, DWORD PTR _fe_id$89404[ebp+8]
	xor	edx, 134217728				; 08000000H
	test	esi, 268435456				; 10000000H
	je	SHORT $LN1001@new_popver
	mov	ebx, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN394@new_popver
	xor	edx, 134217728				; 08000000H
	and	ebx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR [edi+32], edx
	jmp	SHORT $LN393@new_popver
$LN394@new_popver:
	and	ebx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR [edi+28], edx
$LN393@new_popver:
	mov	edx, DWORD PTR _global_timestamp
	mov	edi, DWORD PTR _web+460
	mov	ebx, DWORD PTR _fe_id$89404[ebp]
	inc	edx
	mov	DWORD PTR _global_timestamp, edx
	mov	DWORD PTR _top_timestamp, edx
$LN1001@new_popver:

; 581  :         set_prev_edge(fe_c,inverse_id(fe_b));

	mov	edx, DWORD PTR _fe_id$89404[ebp+8]
	xor	esi, 134217728				; 08000000H
	test	edx, 268435456				; 10000000H
	je	SHORT $LN1006@new_popver
	cmp	DWORD PTR tv9532[ebp], 0
	mov	eax, DWORD PTR [edi+eax]
	je	SHORT $LN399@new_popver
	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR [eax+32], esi
	jmp	SHORT $LN398@new_popver
$LN399@new_popver:
	mov	DWORD PTR [eax+28], esi
$LN398@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	mov	edi, DWORD PTR _web+460
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN1006@new_popver:

; 582  :         set_prev_edge(fe_d,inverse_id(fe_a));

	xor	ebx, 134217728				; 08000000H
	mov	eax, ebx
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN406@new_popver
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN404@new_popver
	xor	eax, 134217728				; 08000000H
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [ecx+32], eax
	jmp	SHORT $LN403@new_popver
$LN404@new_popver:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [ecx+28], eax
$LN403@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN406@new_popver:

; 583  :         if ( !equal_id(f_id[0],f_id[2]) )

	mov	eax, DWORD PTR _f_id$89405[ebp]
	cmp	eax, DWORD PTR _f_id$89405[ebp+8]
	je	$LN104@new_popver

; 584  :         { /* merge f_id[2] into f_id[0] */
; 585  :           facetedge_id fe = fe_c;
; 586  :           if ( b_id[2] != b_id[0] )

	mov	ecx, DWORD PTR _b_id$89406[ebp+8]

; 587  :           { set_facet_body(f_id[2],NULLID);

	mov	ebx, DWORD PTR _f_id$89405[ebp+8]
	mov	esi, edx
	cmp	ecx, DWORD PTR _b_id$89406[ebp]
	je	SHORT $LN930@new_popver
	push	0
	push	ebx
	call	_set_facet_body

; 588  :             set_facet_body(f_id[2],b_id[0]);

	mov	edx, DWORD PTR _b_id$89406[ebp]
	push	edx
	push	ebx
	call	_set_facet_body
	add	esp, 16					; 00000010H
$LN930@new_popver:
	mov	edi, DWORD PTR _f_id$89405[ebp]
	npad	2
$LL102@new_popver:

; 589  :           }
; 590  :           do
; 591  :           { set_fe_facet(fe,f_id[0]);

	push	edi
	push	esi
	call	_set_fe_facet

; 592  :             fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN409@new_popver
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN101@new_popver
$LN409@new_popver:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [edx+32]
$LN101@new_popver:

; 593  :           } while ( valid_id(fe) && !equal_element(f_id[0],get_fe_facet(fe)) );

	test	esi, 268435456				; 10000000H
	je	SHORT $LN99@new_popver
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN412@new_popver
	xor	eax, 134217728				; 08000000H
$LN412@new_popver:
	mov	ecx, edi
	or	ecx, 134217728				; 08000000H
	or	eax, 134217728				; 08000000H
	cmp	ecx, eax
	jne	SHORT $LL102@new_popver
$LN99@new_popver:

; 594  :           fe = inverse_id(fe_d);

	mov	esi, DWORD PTR tv7765[ebp]
$LL98@new_popver:

; 595  :           do
; 596  :           { set_fe_facet(fe,f_id[0]);

	push	edi
	push	esi
	call	_set_fe_facet

; 597  :             fe = get_prev_edge(fe);

	mov	eax, DWORD PTR _web+460
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN417@new_popver
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [edx+32]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN97@new_popver
$LN417@new_popver:
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+28]
$LN97@new_popver:

; 598  :           } while ( valid_id(fe) && !equal_element(f_id[0],get_fe_facet(fe)) );

	test	esi, 268435456				; 10000000H
	je	SHORT $LN95@new_popver
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN420@new_popver
	xor	eax, 134217728				; 08000000H
$LN420@new_popver:
	mov	ecx, edi
	or	ecx, 134217728				; 08000000H
	or	eax, 134217728				; 08000000H
	cmp	ecx, eax
	jne	SHORT $LL98@new_popver
$LN95@new_popver:

; 599  :           set_facet_fe(f_id[2],NULLID); // so freeing doesn't wipe body

	push	0
	push	ebx
	call	_set_facet_fe

; 600  :           free_element(f_id[2]);

	push	ebx
	call	_free_element
	add	esp, 12					; 0000000cH
$LN104@new_popver:

; 601  :         } 
; 602  :       }
; 603  :     
; 604  :       /* spread the vertices a bit */
; 605  :       xold = get_coord(v_id);

	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax+64]
	mov	edx, DWORD PTR _web+12

; 606  :       xnew = get_coord(new_v);

	mov	esi, DWORD PTR _new_v$[ebp]
	mov	ecx, DWORD PTR tv7104[ebp]

; 607  :       x0 = side[0].vec;

	mov	edi, DWORD PTR _side$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	esi, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edx+esi*4]
	add	ecx, eax
	add	ebx, eax
	lea	edx, DWORD PTR [edi+8]

; 608  :       x1 = side[1].vec;

	lea	eax, DWORD PTR [edi+88]

; 609  :       x2 = side[2].vec;

	lea	esi, DWORD PTR [edi+168]

; 610  :       x3 = side[3].vec;

	add	edi, 248				; 000000f8H

; 611  :       for ( i = 0 ; i < SDIM ; i++ )

	cmp	DWORD PTR _web+616, 0
	mov	DWORD PTR _i$[ebp], 0
	jle	$newpop_exit$89402
	fld	QWORD PTR __real@3fa999999999999a
	sub	ecx, eax
	sub	edx, eax
	sub	esi, eax
	sub	edi, eax
	sub	ebx, eax
	mov	DWORD PTR tv10507[ebp], ebx
	jmp	SHORT $LN94@new_popver
$LN965@new_popver:
	mov	ebx, DWORD PTR tv10507[ebp]
$LN94@new_popver:

; 612  :       { xold[i] += 0.05*x0[i] - 0.05*x1[i] - 0.05*x2[i] + 0.05*x3[i];

	fld	QWORD PTR [edx+eax]
	add	eax, 8
	fmul	ST(0), ST(1)
	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [esi+eax-8]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [edi+eax-8]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [ecx+eax-8]
	fstp	QWORD PTR [ecx+eax-8]

; 613  :         xnew[i] += -0.05*x0[i] + 0.05*x1[i] + 0.05*x2[i] - 0.05*x3[i];

	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [edx+eax-8]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [esi+eax-8]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+eax-8]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fadd	QWORD PTR [ebx+eax-8]
	fstp	QWORD PTR [ebx+eax-8]
	mov	ebx, DWORD PTR _i$[ebp]
	inc	ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, DWORD PTR _web+616
	jl	SHORT $LN965@new_popver

; 611  :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)

; 614  :       }
; 615  :  
; 616  :       goto newpop_exit;

	jmp	$newpop_exit$89402
$LN959@new_popver:
	mov	ebx, DWORD PTR _web+124
$LN107@new_popver:

; 624  :   besti = -1;
; 625  :   for ( i = 0 ; i < edges ; i++ )

	cmp	DWORD PTR _edges$GSCopy$[ebp], 0
	fld	QWORD PTR __real@3f847ae147ae147b
	fstp	QWORD PTR _ffmax$[ebp]
	mov	DWORD PTR _besti$[ebp], -1
	mov	DWORD PTR _i$[ebp], 0
	jle	$LN895@new_popver

; 617  :     }
; 618  :     /* else fall through and do ordinary wedge splitting */
; 619  :   }
; 620  : 
; 621  :   /* If here, want to do Y pull out */
; 622  :   /* find two edges that pull apart the most */
; 623  :   ffmax = 0.01; /* margin to prevent looping with autopop */

	mov	edx, DWORD PTR _side$[ebp]
	add	edx, 8
	mov	DWORD PTR tv10946[ebp], edx
	mov	DWORD PTR tv10948[ebp], 5
	jmp	SHORT $LN1116@new_popver
	npad	2
$LL1018@new_popver:
	mov	ebx, DWORD PTR _web+124
$LN1116@new_popver:

; 626  :     {
; 627  :       e1 = side[i].e_id;
; 628  :       e2 = side[i+1].e_id;
; 629  : 
; 630  :       /* test to see if this pair is valid */
; 631  :       if ( side[i].degfree < 1 ) continue;

	cmp	DWORD PTR [edx+64], 1
	mov	esi, DWORD PTR _E_BOUNDARY_ATTR
	mov	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx+72]
	jl	$LN90@new_popver

; 632  :       if ( side[i+1].degfree < 1 ) continue;

	cmp	DWORD PTR [edx+144], 1
	jl	$LN90@new_popver

; 633  :       attr1 = get_eattr(e1);

	and	eax, 134217727				; 07ffffffH
	add	eax, eax

; 634  :       attr2 = get_eattr(e2);

	and	ecx, 134217727				; 07ffffffH
	add	eax, eax
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR tv7511[ebp], eax
	mov	eax, DWORD PTR [eax+ebx]
	mov	edx, DWORD PTR [eax+12]
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR tv7601[ebp], ecx
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR _attr1$[ebp+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _attr2$[ebp], edx
	mov	DWORD PTR _attr2$[ebp+4], ebx

; 635  :       if ( get_edge_boundary(e1) != get_edge_boundary(e2) ) 

	test	esi, esi
	je	SHORT $LN980@new_popver
	mov	edx, DWORD PTR _dymem
	imul	esi, 240				; 000000f0H
	add	esi, DWORD PTR _web+216
	mov	ebx, DWORD PTR _web+776
	mov	edx, DWORD PTR [esi+edx+64]
	mov	esi, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR [ecx+edx]
	imul	esi, 136				; 00000088H
	imul	edx, 136				; 00000088H
	add	esi, ebx
	add	edx, ebx
	cmp	esi, edx
	jne	$LN90@new_popver
	mov	edx, DWORD PTR _attr2$[ebp]
$LN980@new_popver:

; 636  :         continue;
; 637  :       if ( (attr1 & CONSTRAINT) || (attr2 & CONSTRAINT) )

	and	edi, 1024				; 00000400H
	xor	esi, esi
	or	edi, esi
	jne	SHORT $LN84@new_popver
	and	edx, 1024				; 00000400H
	or	edx, edi
	je	$LN1003@new_popver
$LN84@new_popver:

; 638  :       { conmap_t *map1 = get_e_constraint_map(e1);

	mov	edx, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+1048]
	test	edx, edx
	je	SHORT $LN234@new_popver
	mov	edi, DWORD PTR _web+216
	mov	ebx, DWORD PTR [edi+esi+1024]
	add	ebx, eax
	jmp	SHORT $LN1117@new_popver
$LN234@new_popver:
	mov	ebx, OFFSET _nullcon
$LN1117@new_popver:
	mov	DWORD PTR _map1$89482[ebp], ebx

; 639  :         conmap_t *map2 = get_e_constraint_map(e2);

	test	edx, edx
	je	SHORT $LN236@new_popver
	mov	eax, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [eax+edx+1024]
	add	edx, ecx
	jmp	SHORT $LN237@new_popver
$LN236@new_popver:
	mov	edx, OFFSET _nullcon
$LN237@new_popver:

; 640  :         conmap_t ii,jj,found;
; 641  :         found = 0;
; 642  :         for ( ii = 1 ; ii <= map1[0] ; ii++ )

	mov	eax, DWORD PTR [ebx]
	mov	esi, 1
	mov	DWORD PTR _found$89496[ebp], 0
	mov	DWORD PTR tv7919[ebp], eax
	cmp	eax, esi
	jb	SHORT $LN81@new_popver
	mov	edi, DWORD PTR [edx]
	npad	3
$LL83@new_popver:

; 643  :         { for ( jj = 1; jj <= map2[0] ; jj++ )

	mov	eax, 1
	cmp	edi, eax
	jb	SHORT $LN82@new_popver
	mov	ecx, DWORD PTR [ebx+esi*4]
	npad	4
$LL80@new_popver:

; 644  :             if ( map1[ii] == map2[jj] ) found++;

	cmp	ecx, DWORD PTR [edx+eax*4]
	jne	SHORT $LN79@new_popver
	inc	DWORD PTR _found$89496[ebp]
	mov	ebx, DWORD PTR _map1$89482[ebp]
$LN79@new_popver:

; 643  :         { for ( jj = 1; jj <= map2[0] ; jj++ )

	inc	eax
	cmp	eax, edi
	jbe	SHORT $LL80@new_popver
$LN82@new_popver:

; 640  :         conmap_t ii,jj,found;
; 641  :         found = 0;
; 642  :         for ( ii = 1 ; ii <= map1[0] ; ii++ )

	inc	esi
	cmp	esi, DWORD PTR tv7919[ebp]
	jbe	SHORT $LL83@new_popver
$LN81@new_popver:

; 645  :         }
; 646  :         if ( (found != map1[0]) && ( found != map2[0]) )

	mov	eax, DWORD PTR tv7919[ebp]
	cmp	DWORD PTR _found$89496[ebp], eax
	je	SHORT $LN1003@new_popver
	mov	ecx, DWORD PTR _found$89496[ebp]
	cmp	ecx, DWORD PTR [edx]
	jne	$LN90@new_popver
$LN1003@new_popver:

; 647  :           continue;
; 648  :       }
; 649  : 
; 650  :       if ( (edges <= 3) && (side[(6-i-i-1)%3].degfree <= degfree) )

	mov	ecx, DWORD PTR _edges$GSCopy$[ebp]

; 651  :       {  
; 652  :         if ((side[i].degfree <= degfree)||(side[i+1].degfree <= degfree) )

	mov	ebx, DWORD PTR tv10946[ebp]
	cmp	ecx, 3
	jg	SHORT $LN1019@new_popver

; 647  :           continue;
; 648  :       }
; 649  : 
; 650  :       if ( (edges <= 3) && (side[(6-i-i-1)%3].degfree <= degfree) )

	mov	eax, DWORD PTR tv10948[ebp]
	cdq
	mov	esi, 3
	idiv	esi
	mov	eax, DWORD PTR _side$[ebp]
	mov	esi, DWORD PTR _degfree$[ebp]
	lea	edx, DWORD PTR [edx+edx*4]
	add	edx, edx
	cmp	DWORD PTR [eax+edx*8+72], esi
	jg	SHORT $LN74@new_popver

; 651  :       {  
; 652  :         if ((side[i].degfree <= degfree)||(side[i+1].degfree <= degfree) )

	cmp	DWORD PTR [ebx+64], esi
	jle	$LN90@new_popver
	cmp	DWORD PTR [ebx+144], esi

; 653  :         continue;   /* fake wall ??? */

	jle	$LN90@new_popver
	jmp	SHORT $LN74@new_popver
$LN1019@new_popver:
	mov	esi, DWORD PTR _degfree$[ebp]
$LN74@new_popver:

; 654  :       }
; 655  : 
; 656  :       /* check to see if better than what we have */
; 657  :       if ( (edges == 3) && ((side[i].degfree <= 1)||(side[i+1].degfree <= 1)) )

	cmp	ecx, 3
	jne	SHORT $LN1035@new_popver
	mov	eax, 1
	cmp	DWORD PTR [ebx+64], eax
	jle	SHORT $LN71@new_popver
	cmp	DWORD PTR [ebx+144], eax
	jg	SHORT $LN1035@new_popver
$LN71@new_popver:

; 658  :       { // one fixed wall, so make sure less than 90 degree angle
; 659  :         if ( dot(side[i].vec,side[i+1].vec,SDIM) < 0 )

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR [ebx+80]
	push	edx
	push	ebx
	call	_dot
	fcomp	QWORD PTR __real@0000000000000000
	add	esp, 12					; 0000000cH
	fnstsw	ax
	test	ah, 5
	jnp	$LN90@new_popver
$LN1035@new_popver:
	mov	edx, DWORD PTR _web+616

; 660  :           continue;
; 661  :       }
; 662  :       for ( m = 0 ; m < SDIM ; m++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN67@new_popver
	lea	ecx, DWORD PTR [ebx+80]
$LL69@new_popver:

; 663  :       { f[m] = (side[i].density*side[i].vec[m]/side[i].norm 
; 664  :                + side[i+1].density*side[i+1].vec[m]/side[i+1].norm);          

	fld	QWORD PTR [ecx-80]
	inc	eax
	fmul	QWORD PTR [ebx+56]
	add	ecx, 8
	fdiv	QWORD PTR [ebx+48]
	fld	QWORD PTR [ecx-8]
	fmul	QWORD PTR [ebx+136]
	fdiv	QWORD PTR [ebx+128]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _f$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LL69@new_popver
$LN67@new_popver:

; 665  :       }
; 666  :       if ( (degfree < SDIM) && 
; 667  :           ((side[i].degfree <= degfree) || (side[i+1].degfree <= degfree)) )

	cmp	esi, edx
	jge	SHORT $LN66@new_popver
	cmp	DWORD PTR [ebx+64], esi
	jle	SHORT $LN65@new_popver
	cmp	DWORD PTR [ebx+144], esi
	jg	SHORT $LN66@new_popver
$LN65@new_popver:

; 668  :       { force_project(f,v_id,fproj);

	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	lea	eax, DWORD PTR _fproj$[ebp]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_force_project

; 669  :         ff = sqrt(SDIM_dot(fproj,fproj));

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _fproj$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	add	esp, 24					; 00000018H
	jmp	SHORT $LN1118@new_popver
$LN66@new_popver:

; 670  :       }
; 671  :       else ff = sqrt(SDIM_dot(f,f));

	push	edx
	lea	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	add	esp, 12					; 0000000cH
$LN1118@new_popver:
	call	__CIsqrt

; 672  :       if ( phase_flag )

	cmp	DWORD PTR _phase_flag, 0
	je	$LN63@new_popver

; 673  :       {
; 674  :         f1 = get_fe_facet(get_prev_facet(side[i].fe));

	mov	eax, DWORD PTR [ebx-4]
	mov	edx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN425@new_popver
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+40]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN424@new_popver
$LN425@new_popver:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+36]
$LN424@new_popver:
	mov	ecx, DWORD PTR _NULLFACET
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN429@new_popver
	mov	edi, ecx
	jmp	SHORT $LN428@new_popver
$LN429@new_popver:
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+esi*4]
	mov	edi, DWORD PTR [esi+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN428@new_popver
	xor	edi, 134217728				; 08000000H
$LN428@new_popver:

; 675  :         f2 = get_fe_facet(side[i+1].fe);

	mov	eax, DWORD PTR [ebx+76]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN432@new_popver
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [edx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN432@new_popver
	xor	ecx, 134217728				; 08000000H
$LN432@new_popver:

; 676  :         new_density = phase_data[get_f_phase(f1)][get_f_phase(f2)];

	mov	eax, DWORD PTR _F_PHASE_ATTR
	mov	esi, DWORD PTR _web+236
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	add	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [eax+88]
	test	edx, edx
	je	SHORT $LN238@new_popver
	test	edi, 268435456				; 10000000H
	je	SHORT $LN238@new_popver
	mov	ebx, DWORD PTR [eax+64]
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [esi+edi*4]
	mov	edi, DWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR tv10946[ebp]
	jmp	SHORT $LN239@new_popver
$LN238@new_popver:
	xor	edi, edi
$LN239@new_popver:
	test	edx, edx
	je	SHORT $LN240@new_popver
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN240@new_popver
	mov	edx, DWORD PTR [eax+64]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	eax, DWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR _phase_data
	mov	edx, DWORD PTR [ecx+edi*4]
	fld	QWORD PTR [edx+eax*8]

; 677  :       }
; 678  :       else /* use minimal density of wedge edges */

	jmp	SHORT $LN1119@new_popver
$LN240@new_popver:

; 676  :         new_density = phase_data[get_f_phase(f1)][get_f_phase(f2)];

	mov	ecx, DWORD PTR _phase_data
	mov	edx, DWORD PTR [ecx+edi*4]
	xor	eax, eax
	fld	QWORD PTR [edx+eax*8]

; 677  :       }
; 678  :       else /* use minimal density of wedge edges */

	jmp	SHORT $LN1119@new_popver
$LN63@new_popver:

; 679  :       { REAL den1,den2;
; 680  :         den1 = get_edge_density(e1);

	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR tv7511[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	fld	QWORD PTR [edx+40]

; 681  :         den2 = get_edge_density(e2);

	mov	ecx, DWORD PTR tv7601[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	fld	QWORD PTR [edx+40]

; 682  :         new_density = (den1 < den2) ? den1 : den2;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1113@new_popver
	fstp	ST(0)
	jmp	SHORT $LN1119@new_popver
$LN1113@new_popver:
	fstp	ST(1)
$LN1119@new_popver:
	fst	QWORD PTR _new_density$[ebp]

; 683  :       }
; 684  :       if ( ff - new_density > ffmax )

	fsubr	ST(0), ST(1)
	fld	QWORD PTR _ffmax$[ebp]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1105@new_popver

; 685  :       { REAL mag;   /* size of new edge */
; 686  :         ffmax = ff - new_density ; besti = i;

	mov	eax, DWORD PTR _i$[ebp]
	fstp	QWORD PTR _ffmax$[ebp]

; 687  :         mag = 0.1*((side[i].norm < side[i+1].norm) ?
; 688  :                 side[i].norm : side[i+1].norm);

	fld	QWORD PTR [ebx+128]
	mov	DWORD PTR _besti$[ebp], eax
	fcomp	QWORD PTR [ebx+48]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN244@new_popver
	fld	QWORD PTR [ebx+48]
	jmp	SHORT $LN245@new_popver
$LN244@new_popver:
	fld	QWORD PTR [ebx+128]
$LN245@new_popver:

; 689  :         for ( m = 0 ; m < SDIM ; m++ )

	mov	ecx, DWORD PTR _web+616
	fmul	QWORD PTR __real@3fb999999999999a
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN1105@new_popver
$LN60@new_popver:

; 690  :            bestmove[m] = mag*f[m]/ff;

	fld	QWORD PTR _f$[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _bestmove$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN60@new_popver
$LN1105@new_popver:

; 689  :         for ( m = 0 ; m < SDIM ; m++ )

	fstp	ST(0)
	fstp	ST(0)
$LN90@new_popver:

; 624  :   besti = -1;
; 625  :   for ( i = 0 ; i < edges ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR tv10946[ebp]
	sub	DWORD PTR tv10948[ebp], 2
	inc	eax
	add	edx, 80					; 00000050H
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR tv10946[ebp], edx
	cmp	eax, DWORD PTR _edges$GSCopy$[ebp]
	jl	$LL1018@new_popver

; 691  :       }
; 692  :     }          
; 693  :   
; 694  :   if ( besti == -1 ) 

	cmp	DWORD PTR _besti$[ebp], -1
	jne	SHORT $LN57@new_popver
$LN895@new_popver:

; 695  :   { temp_free((char *)side);

	mov	ecx, DWORD PTR _side$[ebp]
	push	ecx
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi

; 696  :     return 0;

	xor	eax, eax
	pop	ebx

; 941  : } // end new_popverst()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@new_popver:

; 697  :   }
; 698  :   
; 699  :   if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN56@new_popver

; 700  :   { sprintf(msg,"Popping vertex %s.\n",ELNAME(v_id));

	test	DWORD PTR _v_id$GSCopy$[ebp], 268435456	; 10000000H
	je	SHORT $LN246@new_popver
	mov	edx, DWORD PTR tv7104[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN247@new_popver
$LN246@new_popver:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN247@new_popver:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BE@PMHCEJIK@Popping?5vertex?5?$CFs?4?6?$AA@
	push	eax
	call	_sprintf

; 701  :     outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
$LN56@new_popver:

; 702  :   }
; 703  : 
; 704  :   /* split off edges besti and besti+1 */
; 705  :   e1 = side[besti].e_id;

	mov	eax, DWORD PTR _besti$[ebp]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _side$[ebp]
	shl	edx, 4
	mov	ebx, DWORD PTR [eax+edx]

; 706  :   e2 = side[besti+1].e_id;

	mov	ecx, DWORD PTR [eax+edx+80]
	add	eax, edx

; 707  :   attr1 = get_eattr(e1);

	mov	edx, DWORD PTR _web+124
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	mov	DWORD PTR tv8096[ebp], eax
	mov	DWORD PTR _e2$[ebp], ecx
	add	edi, edi

; 708  :   attr2 = get_eattr(e2);

	and	ecx, 134217727				; 07ffffffH
	add	edi, edi
	mov	eax, DWORD PTR [edi+edx]
	mov	esi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR _attr1$[ebp+4], eax
	mov	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR tv7601[ebp], ecx
	mov	ecx, DWORD PTR [eax+8]

; 709  :   new_v = dup_vertex(v_id);  /* new vertex in same spot, to be pulled out */

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	eax
	mov	DWORD PTR _attr1$[ebp], esi
	mov	DWORD PTR _attr2$[ebp], ecx
	mov	DWORD PTR _attr2$[ebp+4], edx
	call	_dup_vertex

; 710  :   attrv = get_vattr(new_v);

	mov	ecx, DWORD PTR _web+12
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	DWORD PTR _new_v$[ebp], eax
	mov	eax, DWORD PTR [esi+ecx]
	mov	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _attrv$[ebp+4], ecx

; 711  :   /* move new vertex a little ways away to avoid zero edge */
; 712  :   x = get_coord(new_v);

	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR _attrv$[ebp], edx
	mov	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [edx+ecx+64]
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 713  :   for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	add	esp, 4
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN53@new_popver
	mov	eax, DWORD PTR _x$[ebp]
	lea	edx, DWORD PTR _bestmove$[ebp]
	sub	edx, eax
	npad	2
$LL55@new_popver:

; 714  :      x[i] += bestmove[i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL55@new_popver
$LN53@new_popver:

; 715  : 
; 716  :   new_e = new_edge(v_id,new_v,NULLID);

	mov	edx, DWORD PTR _new_v$[ebp]
	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	0
	push	edx
	push	eax
	call	_new_edge

; 717  :   set_edge_color(new_e,BLACK);

	mov	ecx, DWORD PTR _web+124
	mov	DWORD PTR _new_e$[ebp], eax
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]

; 718  :   remove_vertex_edge(v_id,e1);

	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	mov	DWORD PTR tv8118[ebp], eax
	xor	eax, eax
	push	ebx
	push	ecx
	mov	WORD PTR [edx+56], ax
	call	_remove_vertex_edge

; 719  :   set_edge_tailv(e1,new_v);

	mov	edx, DWORD PTR _new_v$[ebp]
	push	edx
	push	ebx
	call	_set_edge_tailv

; 720  :   remove_vertex_edge(v_id,e2);

	mov	ebx, DWORD PTR _e2$[ebp]
	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	ebx
	push	eax
	call	_remove_vertex_edge

; 721  :   set_edge_tailv(e2,new_v);

	mov	ecx, DWORD PTR _new_v$[ebp]
	push	ecx
	push	ebx
	call	_set_edge_tailv

; 722  :   set_edge_density(new_e,new_density);

	fld	QWORD PTR _new_density$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR tv8118[ebp]
	mov	ecx, DWORD PTR [eax+edx]

; 723  :   if ( (attr1 & NONCONTENT) || (attr2 & NONCONTENT) ) 

	mov	eax, DWORD PTR _attr1$[ebp]
	fstp	QWORD PTR [ecx+40]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	add	esp, 44					; 0000002cH
	or	eax, ecx
	jne	SHORT $LN960@new_popver
	mov	eax, DWORD PTR _attr2$[ebp]
	and	eax, 536870912				; 20000000H
	or	eax, ecx
	je	SHORT $LN961@new_popver
$LN960@new_popver:

; 724  :     set_attr(new_e,NONCONTENT);

	mov	edx, DWORD PTR _new_e$[ebp]
	mov	ecx, DWORD PTR tv8118[ebp]
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	eax, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 536870912		; 20000000H
	mov	DWORD PTR [eax+12], edx
$LN961@new_popver:

; 725  :   if ( (attr1 & NO_REFINE) || (attr2 & NO_REFINE) ) 

	mov	eax, DWORD PTR _attr1$[ebp]
	and	eax, 16777216				; 01000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN49@new_popver
	mov	eax, DWORD PTR _attr2$[ebp]
	and	eax, 16777216				; 01000000H
	or	eax, ecx
	je	SHORT $LN438@new_popver
$LN49@new_popver:

; 726  :     set_attr(new_e,NO_REFINE);

	mov	eax, DWORD PTR _new_e$[ebp]
	mov	edx, DWORD PTR tv8118[ebp]
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 16777216		; 01000000H
	mov	DWORD PTR [eax+12], ecx
$LN438@new_popver:

; 727  : 
; 728  :   /* want to be careful here; new vertex and edge should get union of 
; 729  :      properties of the two wedge edges */
; 730  :   unset_attr(new_v,FIXED);

	mov	ecx, DWORD PTR _new_v$[ebp]
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	eax, DWORD PTR [esi+eax]
	and	DWORD PTR [eax+8], -65			; ffffffbfH
	lea	ebx, DWORD PTR _web[edx+12]
	mov	edx, DWORD PTR [eax+12]

; 731  :   unset_v_all_constraints(new_v);

	push	ecx
	mov	DWORD PTR [eax+12], edx
	call	_unset_v_all_constraints

; 732  :   if ( attrv & BOUNDARY )

	mov	eax, DWORD PTR _attrv$[ebp]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	add	esp, 4
	or	eax, ecx
	je	SHORT $LN1012@new_popver

; 733  :   { set_boundary_num(new_v,0);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN248@new_popver
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], 0
$LN248@new_popver:

; 734  :     unset_attr(new_v,BOUNDARY);

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+edx]
	mov	ecx, DWORD PTR [eax+12]
	and	DWORD PTR [eax+8], -129			; ffffff7fH
	mov	DWORD PTR [eax+12], ecx
$LN1012@new_popver:

; 735  :   }
; 736  :   if ( (attr1 & CONSTRAINT) || (attr2 & CONSTRAINT) )

	mov	ecx, DWORD PTR _attr1$[ebp]
	mov	eax, ecx
	and	eax, 1024				; 00000400H
	xor	edx, edx
	or	eax, edx
	jne	$LN1013@new_popver
	mov	edx, DWORD PTR _attr2$[ebp]
	mov	eax, edx
	and	eax, 1024				; 00000400H
	xor	ebx, ebx
	or	eax, ebx
	jne	$LN1013@new_popver

; 747  :     }
; 748  :   }
; 749  :   else if ( ((attr1 & BOUNDARY) || (attr2 & BOUNDARY))
; 750  :        && (get_vattr(v_id) & BOUNDARY) )

	and	ecx, 128				; 00000080H
	mov	eax, ecx
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN37@new_popver
	and	edx, 128				; 00000080H
	mov	eax, edx
	or	eax, ecx
	je	$LN947@new_popver
$LN37@new_popver:
	mov	edx, DWORD PTR tv7104[ebp]
	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv7108[ebp], eax
	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN947@new_popver

; 751  :   { struct boundary *b1 = get_edge_boundary(e1);

	mov	edx, DWORD PTR _E_BOUNDARY_ATTR
	mov	ecx, DWORD PTR _dymem
	test	edx, edx
	je	SHORT $LN254@new_popver
	mov	eax, edx
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	ebx, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR _web+124
	mov	edi, DWORD PTR [edi+eax]
	mov	edi, DWORD PTR [edi+ebx]
	mov	DWORD PTR tv7204[ebp], ebx
	imul	edi, 136				; 00000088H

; 752  :     struct boundary *b2 = get_edge_boundary(e2);

	mov	ebx, DWORD PTR tv7601[ebp]
	mov	eax, DWORD PTR [ebx+eax]
	mov	ebx, DWORD PTR tv7204[ebp]
	mov	ebx, DWORD PTR [eax+ebx]
	add	edi, DWORD PTR _web+776
	imul	ebx, 136				; 00000088H
	add	ebx, DWORD PTR _web+776
	jmp	SHORT $LN1120@new_popver
$LN254@new_popver:

; 751  :   { struct boundary *b1 = get_edge_boundary(e1);

	xor	edi, edi

; 752  :     struct boundary *b2 = get_edge_boundary(e2);

	xor	ebx, ebx
$LN1120@new_popver:

; 753  :     struct boundary *bv = get_boundary(v_id);

	cmp	DWORD PTR _V_BOUNDARY_ATTR, 0
	mov	DWORD PTR _b2$89613[ebp], ebx
	je	SHORT $LN258@new_popver
	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	mov	ebx, DWORD PTR tv7108[ebp]
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR [eax+ebx]
	mov	ebx, DWORD PTR _b2$89613[ebp]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN259@new_popver
$LN258@new_popver:
	xor	eax, eax
$LN259@new_popver:

; 754  :     if ( (b1 == bv) || (b2 == bv) )

	cmp	edi, eax
	je	SHORT $LN35@new_popver
	cmp	ebx, eax
	jne	$LN947@new_popver
$LN35@new_popver:

; 755  :     { set_edge_boundary_num(new_e,bv->num);

	test	edx, edx
	je	SHORT $LN988@new_popver
	mov	edi, DWORD PTR tv8118[ebp]
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [edx+ecx+64]
	mov	edx, DWORD PTR _web+124
	mov	edx, DWORD PTR [edi+edx]
	mov	edi, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx+edx], edi
	mov	ecx, DWORD PTR _dymem
$LN988@new_popver:
	mov	edx, DWORD PTR _V_BOUNDARY_ATTR

; 756  :       set_boundary_num(new_v,bv->num);

	test	edx, edx
	je	SHORT $LN262@new_popver
	mov	edi, DWORD PTR [eax+44]
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [edx+ecx+64]
	mov	edx, DWORD PTR _web+12
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+edx], edi
	mov	ecx, DWORD PTR _dymem
$LN262@new_popver:

; 757  :       b_extrapolate(bv,get_coord(v_id),x,x,get_param(v_id),
; 758  :             get_param(new_v),new_v);

	mov	ebx, DWORD PTR _web+12
	mov	edi, DWORD PTR tv7104[ebp]
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR _new_v$[ebp]
	mov	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+ecx+544]
	push	ebx
	mov	ebx, DWORD PTR _web+12
	mov	esi, DWORD PTR [esi+ebx]
	add	esi, edx
	push	esi
	add	edx, edi
	push	edx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	push	edx
	mov	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [edx+ecx+64]
	add	ecx, edi
	push	ecx
	push	eax
	call	_b_extrapolate
	add	esp, 28					; 0000001cH
	jmp	$LN947@new_popver
$LN1013@new_popver:

; 737  :   { conmap_t *map1 = get_e_constraint_map(e1);

	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [eax+ecx+1048]
	test	edx, edx
	je	SHORT $LN250@new_popver
	mov	esi, DWORD PTR _web+124
	mov	edi, DWORD PTR [edi+esi]
	add	edi, DWORD PTR [eax+ecx+1024]
	jmp	SHORT $LN251@new_popver
$LN250@new_popver:
	mov	edi, OFFSET _nullcon
$LN251@new_popver:

; 738  :     conmap_t *map2 = get_e_constraint_map(e2);

	test	edx, edx
	je	SHORT $LN252@new_popver
	mov	edx, DWORD PTR tv7601[ebp]
	mov	esi, DWORD PTR _web+124
	mov	ebx, DWORD PTR [edx+esi]
	add	ebx, DWORD PTR [eax+ecx+1024]
	jmp	SHORT $LN253@new_popver
$LN252@new_popver:
	mov	ebx, OFFSET _nullcon
$LN253@new_popver:

; 739  :     conmap_t i,j;
; 740  :     for ( i = 1 ; i <= map1[0] ; i++ )

	mov	esi, 1
	cmp	DWORD PTR [edi], esi
	jb	SHORT $LN43@new_popver
	npad	8
$LL45@new_popver:

; 741  :     { set_v_constraint_map(new_v,map1[i]); 

	mov	eax, DWORD PTR [edi+esi*4]
	mov	ecx, DWORD PTR _new_v$[ebp]
	push	eax
	push	ecx
	call	_set_v_constraint_map

; 742  :       set_e_constraint_map(new_e,map1[i]); 

	mov	edx, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR _new_e$[ebp]
	push	edx
	push	eax
	call	_set_e_constraint_map
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR [edi]
	jbe	SHORT $LL45@new_popver
$LN43@new_popver:

; 743  :     }
; 744  :     for ( j = 1 ; j <= map2[0] ; j++ )

	mov	esi, 1
	cmp	DWORD PTR [ebx], esi
	jb	SHORT $LN947@new_popver
	mov	edi, DWORD PTR _new_e$[ebp]
	npad	9
$LL42@new_popver:

; 745  :     { set_v_constraint_map(new_v,map2[j]); 

	mov	ecx, DWORD PTR [ebx+esi*4]
	mov	edx, DWORD PTR _new_v$[ebp]
	push	ecx
	push	edx
	call	_set_v_constraint_map

; 746  :       set_e_constraint_map(new_e,map2[j]); 

	mov	eax, DWORD PTR [ebx+esi*4]
	push	eax
	push	edi
	call	_set_e_constraint_map
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR [ebx]
	jbe	SHORT $LL42@new_popver
$LN947@new_popver:

; 759  :     }
; 760  :   }
; 761  :         
; 762  :   /* take care of facet incidences, assuming plane configuration */
; 763  :   new_fe1 = NULLID;
; 764  :   f1 = get_fe_facet(side[besti].fe);

	mov	ecx, DWORD PTR tv8096[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _web+460
	xor	edi, edi
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN445@new_popver
	mov	edx, DWORD PTR _NULLFACET
	jmp	SHORT $LN444@new_popver
$LN445@new_popver:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [edx+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN444@new_popver
	xor	edx, 134217728				; 08000000H
$LN444@new_popver:
	mov	DWORD PTR _f1$[ebp], edx

; 765  :   if ( valid_id(f1) )

	test	edx, 268435456				; 10000000H
	je	$LN968@new_popver

; 766  :   { /* install new facetedge */
; 767  :     fe_id = side[besti].fe;
; 768  :     fe_id = inverse_id(fe_id);

	xor	ecx, 134217728				; 08000000H

; 769  :     other_fe = get_next_edge(fe_id);

	mov	edx, ecx
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	DWORD PTR _fe_id$[ebp], ecx
	mov	DWORD PTR tv8231[ebp], edx
	je	SHORT $LN449@new_popver
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR tv8234[ebp], ecx
	mov	ecx, DWORD PTR [eax+ecx]
	mov	esi, DWORD PTR [ecx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN448@new_popver
$LN449@new_popver:
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [eax+ecx]
	mov	esi, DWORD PTR [edx+32]
	mov	DWORD PTR tv8234[ebp], ecx
$LN448@new_popver:

; 770  :     if ( valid_id(other_fe) && !equal_element(side[besti+1].e_id,get_fe_edge(other_fe)) )

	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR tv8246[ebp], ecx
	je	$LN967@new_popver
	mov	ebx, esi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [eax+ebx]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR tv8096[ebp]
	mov	ecx, DWORD PTR [ecx+80]
	or	edx, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	ecx, edx
	je	$LN995@new_popver

; 771  :     { new_fe1 = new_facetedge(f1,new_e);

	mov	edx, DWORD PTR _new_e$[ebp]
	mov	eax, DWORD PTR _f1$[ebp]
	push	edx
	push	eax
	call	_new_facetedge
	add	esp, 8

; 772  :       set_edge_fe(new_e,new_fe1);

	test	DWORD PTR _new_e$[ebp], 134217728	; 08000000H
	mov	edi, eax
	je	SHORT $LN454@new_popver
	xor	eax, 134217728				; 08000000H
$LN454@new_popver:
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv8118[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR _global_timestamp
	inc	eax

; 773  :       set_prev_edge(other_fe,inverse_id(new_fe1));

	mov	edx, edi
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	test	esi, 134217728				; 08000000H
	je	SHORT $LN458@new_popver
	mov	ecx, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	eax, edx
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR [ecx+32], eax
	jmp	SHORT $LN457@new_popver
$LN458@new_popver:
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [eax+ebx]
	mov	DWORD PTR [ecx+28], edx
$LN457@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax

; 774  :       set_next_edge(fe_id,inverse_id(new_fe1));

	test	DWORD PTR _fe_id$[ebp], 268435456	; 10000000H
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	je	SHORT $LN993@new_popver
	cmp	DWORD PTR tv8231[ebp], 0
	je	SHORT $LN463@new_popver
	mov	ecx, DWORD PTR _web+460
	mov	ebx, DWORD PTR tv8234[ebp]
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	eax, edx
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN993@new_popver
$LN463@new_popver:
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR tv8234[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [eax+32], edx
$LN993@new_popver:

; 775  :       set_prev_edge(new_fe1,inverse_id(other_fe));

	mov	ecx, edi
	shr	ecx, 28					; 0000001cH
	xor	esi, 134217728				; 08000000H
	and	ecx, 1
	je	SHORT $LN994@new_popver
	mov	ebx, DWORD PTR _web+460
	mov	eax, edi
	test	edi, 134217728				; 08000000H
	je	SHORT $LN468@new_popver
	xor	esi, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [eax+32], esi
	jmp	SHORT $LN467@new_popver
$LN468@new_popver:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [eax+28], esi
$LN467@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN994@new_popver:

; 776  :       set_next_edge(new_fe1,inverse_id(fe_id));

	mov	eax, DWORD PTR _fe_id$[ebp]
	xor	eax, 134217728				; 08000000H
	test	ecx, ecx
	je	$LN948@new_popver
	mov	ebx, DWORD PTR _web+460
	mov	esi, edi
	test	edi, 134217728				; 08000000H
	je	SHORT $LN473@new_popver
	xor	eax, 134217728				; 08000000H
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [esi+28], eax
	jmp	SHORT $LN472@new_popver
$LN473@new_popver:
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [esi+32], eax
$LN472@new_popver:

; 777  :       set_next_facet(new_fe1,new_fe1);

	test	ecx, ecx
	je	SHORT $LN948@new_popver
	mov	esi, DWORD PTR _web+460
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN478@new_popver
	mov	DWORD PTR [eax+36], edx
	jmp	SHORT $LN1036@new_popver
$LN478@new_popver:
	mov	DWORD PTR [eax+40], edi
$LN1036@new_popver:

; 778  :       set_prev_facet(new_fe1,new_fe1);

	test	ecx, ecx
	je	SHORT $LN948@new_popver
	mov	eax, DWORD PTR _web+460
	test	edi, 134217728				; 08000000H
	je	SHORT $LN483@new_popver
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ecx+40], edx
	jmp	SHORT $LN482@new_popver
$LN483@new_popver:
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+36], edi
$LN482@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN948@new_popver:
	mov	eax, DWORD PTR _web+460
$LN995@new_popver:
	mov	ecx, DWORD PTR tv8246[ebp]
$LN967@new_popver:

; 779  :     }
; 780  :     if ( !valid_id(other_fe) )

	test	ecx, ecx
	jne	$LN968@new_popver

; 781  :     { // pulling 2 edges off constraint probably,
; 782  :       // so just extend facet to new edge
; 783  :       new_fe1 = new_facetedge(f1,new_e);

	mov	esi, DWORD PTR _new_e$[ebp]
	mov	edx, DWORD PTR _f1$[ebp]
	push	esi
	push	edx
	call	_new_facetedge
	add	esp, 8
	mov	edi, eax

; 784  :       set_edge_fe(new_e,new_fe1);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN487@new_popver
	xor	eax, 134217728				; 08000000H
$LN487@new_popver:
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv8118[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 785  :       set_next_edge(fe_id,inverse_id(new_fe1));

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	edx, edi
	xor	edx, 134217728				; 08000000H
	test	eax, 268435456				; 10000000H
	je	SHORT $LN996@new_popver
	cmp	DWORD PTR tv8231[ebp], 0
	je	SHORT $LN491@new_popver
	mov	esi, DWORD PTR _web+460
	mov	ebx, DWORD PTR tv8234[ebp]
	mov	esi, DWORD PTR [esi+ebx]
	mov	ecx, edx
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [esi+28], ecx
	jmp	SHORT $LN996@new_popver
$LN491@new_popver:
	mov	ecx, DWORD PTR _web+460
	mov	esi, DWORD PTR tv8234[ebp]
	mov	ecx, DWORD PTR [ecx+esi]
	mov	DWORD PTR [ecx+32], edx
$LN996@new_popver:

; 786  :       set_next_edge(new_fe1,inverse_id(fe_id));

	mov	ecx, edi
	shr	ecx, 28					; 0000001cH
	xor	eax, 134217728				; 08000000H
	and	ecx, 1
	je	SHORT $LN997@new_popver
	mov	ebx, DWORD PTR _web+460
	mov	esi, edi
	test	edi, 134217728				; 08000000H
	je	SHORT $LN496@new_popver
	xor	eax, 134217728				; 08000000H
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [esi+28], eax
	jmp	SHORT $LN997@new_popver
$LN496@new_popver:
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [esi+32], eax
$LN997@new_popver:

; 787  :       set_next_facet(new_fe1,new_fe1);

	test	ecx, ecx
	je	SHORT $LN1041@new_popver
	mov	esi, DWORD PTR _web+460
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN501@new_popver
	mov	DWORD PTR [eax+36], edx
	jmp	SHORT $LN1037@new_popver
$LN501@new_popver:
	mov	DWORD PTR [eax+40], edi
$LN1037@new_popver:

; 788  :       set_prev_facet(new_fe1,new_fe1);

	test	ecx, ecx
	je	SHORT $LN1041@new_popver
	mov	eax, DWORD PTR _web+460
	test	edi, 134217728				; 08000000H
	je	SHORT $LN506@new_popver
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ecx+40], edx
	jmp	SHORT $LN505@new_popver
$LN506@new_popver:
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+36], edi
$LN505@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN1041@new_popver:

; 789  :       if ( !inverted(f1) )

	mov	eax, DWORD PTR _f1$[ebp]
	test	eax, 134217728				; 08000000H
	jne	SHORT $LN949@new_popver

; 790  :         set_facet_fe(f1,new_fe1); // start of chain

	push	edi
	push	eax
	call	_set_facet_fe
	add	esp, 8
$LN949@new_popver:
	mov	eax, DWORD PTR _web+460
$LN968@new_popver:

; 791  :     }
; 792  :   }
; 793  : 
; 794  :   fe_id = get_prev_facet(side[besti].fe);

	mov	edx, DWORD PTR tv8096[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN511@new_popver
	mov	ebx, DWORD PTR [edx+40]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN510@new_popver
$LN511@new_popver:
	mov	ebx, DWORD PTR [edx+36]
$LN510@new_popver:

; 795  :   if ( !equal_id(fe_id,side[besti].fe) )

	cmp	ebx, ecx
	je	$LN25@new_popver

; 796  :   { f1 = get_fe_facet(fe_id);

	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN515@new_popver
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN514@new_popver
$LN515@new_popver:
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+24]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN514@new_popver
	xor	ecx, 134217728				; 08000000H
$LN514@new_popver:
	mov	DWORD PTR _f1$[ebp], ecx

; 797  :     if ( valid_id(f1) )

	test	ecx, 268435456				; 10000000H
	je	$LN25@new_popver

; 798  :     { /* install new facetedge */
; 799  :       fe_id = inverse_id(fe_id);

	xor	ebx, 134217728				; 08000000H

; 800  :       other_fe = get_next_edge(fe_id);

	mov	ecx, ebx
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR tv8231[ebp], ecx
	mov	esi, ebx
	je	SHORT $LN519@new_popver
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [eax+esi]
	mov	ecx, DWORD PTR [ecx+28]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR _other_fe$[ebp], ecx
	jmp	SHORT $LN518@new_popver
$LN519@new_popver:
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [eax+esi]
	mov	ecx, DWORD PTR [edx+32]
	mov	DWORD PTR _other_fe$[ebp], ecx
$LN518@new_popver:

; 801  :       if ( valid_id(other_fe) && !equal_element(side[besti+1].e_id,get_fe_edge(other_fe)) )

	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	DWORD PTR tv8246[ebp], edx
	je	$LN998@new_popver
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv8249[ebp], ecx
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR tv8096[ebp]
	mov	edx, DWORD PTR [edx+80]
	or	ecx, 134217728				; 08000000H
	or	edx, 134217728				; 08000000H
	cmp	edx, ecx
	je	$LN984@new_popver

; 802  :       { 
; 803  :         new_fe1 = new_facetedge(f1,new_e);

	mov	eax, DWORD PTR _new_e$[ebp]
	mov	ecx, DWORD PTR _f1$[ebp]
	push	eax
	push	ecx
	call	_new_facetedge
	add	esp, 8

; 804  :         set_edge_fe(new_e,new_fe1);

	test	DWORD PTR _new_e$[ebp], 134217728	; 08000000H
	mov	edi, eax
	je	SHORT $LN981@new_popver
	xor	eax, 134217728				; 08000000H
$LN981@new_popver:
	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR tv8118[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _global_timestamp
	inc	eax

; 805  :         set_prev_edge(other_fe,inverse_id(new_fe1));

	mov	edx, edi
	xor	edx, 134217728				; 08000000H
	test	DWORD PTR _other_fe$[ebp], 134217728	; 08000000H
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	DWORD PTR tv8265[ebp], edx
	je	SHORT $LN528@new_popver
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR tv8249[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [eax+32], edx
	mov	edx, DWORD PTR tv8265[ebp]
	jmp	SHORT $LN527@new_popver
$LN528@new_popver:
	mov	ecx, DWORD PTR _web+460
	mov	eax, DWORD PTR tv8249[ebp]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	DWORD PTR [ecx+28], edx
$LN527@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 806  :         set_next_edge(fe_id,inverse_id(new_fe1));

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN982@new_popver
	cmp	DWORD PTR tv8231[ebp], 0
	je	SHORT $LN533@new_popver
	mov	ecx, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ecx+esi]
	mov	eax, edx
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN982@new_popver
$LN533@new_popver:
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [eax+esi]
	mov	DWORD PTR [ecx+32], edx
$LN982@new_popver:

; 807  :         set_prev_edge(new_fe1,inverse_id(other_fe));

	mov	eax, DWORD PTR _other_fe$[ebp]
	mov	ecx, edi
	shr	ecx, 28					; 0000001cH
	xor	eax, 134217728				; 08000000H
	and	ecx, 1
	je	SHORT $LN983@new_popver
	mov	esi, DWORD PTR _web+460
	mov	edx, edi
	test	edi, 134217728				; 08000000H
	je	SHORT $LN538@new_popver
	xor	eax, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+32], eax
	jmp	SHORT $LN537@new_popver
$LN538@new_popver:
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+28], eax
$LN537@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	mov	edx, DWORD PTR tv8265[ebp]
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN983@new_popver:

; 808  :         set_next_edge(new_fe1,inverse_id(fe_id));

	xor	ebx, 134217728				; 08000000H
	test	ecx, ecx
	je	$LN950@new_popver
	mov	esi, DWORD PTR _web+460
	mov	eax, edi
	test	edi, 134217728				; 08000000H
	je	SHORT $LN543@new_popver
	xor	ebx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [eax+28], ebx
	jmp	SHORT $LN542@new_popver
$LN543@new_popver:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [eax+32], ebx
$LN542@new_popver:

; 809  :         set_next_facet(new_fe1,new_fe1);

	test	ecx, ecx
	je	$LN950@new_popver
	mov	esi, DWORD PTR _web+460
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN548@new_popver
	mov	DWORD PTR [eax+36], edx
	jmp	SHORT $LN1038@new_popver
$LN548@new_popver:
	mov	DWORD PTR [eax+40], edi
$LN1038@new_popver:

; 810  :         set_prev_facet(new_fe1,new_fe1);

	test	ecx, ecx
	je	$LN950@new_popver
	mov	eax, DWORD PTR _web+460
	test	edi, 134217728				; 08000000H
	je	SHORT $LN553@new_popver
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ecx+40], edx
	jmp	SHORT $LN552@new_popver
$LN553@new_popver:
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+36], edi
$LN552@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	jmp	$LN950@new_popver
$LN984@new_popver:
	mov	edx, DWORD PTR tv8246[ebp]
$LN998@new_popver:

; 811  :       }
; 812  :       else if ( !valid_id(other_fe) )

	test	edx, edx
	jne	$LN25@new_popver

; 813  :       { // just extend facet to new edge; probably pulling 2 off constraint
; 814  :         new_fe1 = new_facetedge(f1,new_e);

	mov	edx, DWORD PTR _new_e$[ebp]
	mov	eax, DWORD PTR _f1$[ebp]
	push	edx
	push	eax
	call	_new_facetedge
	add	esp, 8

; 815  :         set_edge_fe(new_e,new_fe1);

	test	DWORD PTR _new_e$[ebp], 134217728	; 08000000H
	mov	edi, eax
	je	SHORT $LN985@new_popver
	xor	eax, 134217728				; 08000000H
$LN985@new_popver:
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv8118[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR _global_timestamp
	inc	eax

; 816  :         set_next_edge(fe_id,inverse_id(new_fe1));

	mov	ecx, edi
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	test	ebx, 268435456				; 10000000H
	je	SHORT $LN986@new_popver
	cmp	DWORD PTR tv8231[ebp], 0
	je	SHORT $LN561@new_popver
	mov	eax, DWORD PTR _web+460
	mov	eax, DWORD PTR [eax+esi]
	mov	edx, ecx
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [eax+28], edx
	jmp	SHORT $LN986@new_popver
$LN561@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [edx+esi]
	mov	DWORD PTR [eax+32], ecx
$LN986@new_popver:

; 817  :         set_next_edge(new_fe1,inverse_id(fe_id));

	mov	eax, edi
	shr	eax, 28					; 0000001cH
	xor	ebx, 134217728				; 08000000H
	and	eax, 1
	je	SHORT $LN987@new_popver
	mov	esi, DWORD PTR _web+460
	mov	edx, edi
	test	edi, 134217728				; 08000000H
	je	SHORT $LN566@new_popver
	xor	ebx, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+28], ebx
	jmp	SHORT $LN987@new_popver
$LN566@new_popver:
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+32], ebx
$LN987@new_popver:

; 818  :         set_next_facet(new_fe1,new_fe1);

	test	eax, eax
	je	SHORT $LN1042@new_popver
	mov	esi, DWORD PTR _web+460
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN571@new_popver
	mov	DWORD PTR [edx+36], ecx
	jmp	SHORT $LN1039@new_popver
$LN571@new_popver:
	mov	DWORD PTR [edx+40], edi
$LN1039@new_popver:

; 819  :         set_prev_facet(new_fe1,new_fe1);

	test	eax, eax
	je	SHORT $LN1042@new_popver
	mov	edx, DWORD PTR _web+460
	test	edi, 134217728				; 08000000H
	je	SHORT $LN576@new_popver
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+40], ecx
	jmp	SHORT $LN575@new_popver
$LN576@new_popver:
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+36], edi
$LN575@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN1042@new_popver:

; 820  :         if ( !inverted(f1) )

	test	DWORD PTR _f1$[ebp], 134217728		; 08000000H
	jne	SHORT $LN950@new_popver

; 821  :           set_facet_fe(f1,new_fe1); // start of chain

	mov	ecx, DWORD PTR _f1$[ebp]
	push	edi
	push	ecx
	call	_set_facet_fe
	add	esp, 8
$LN950@new_popver:
	mov	eax, DWORD PTR _web+460
$LN25@new_popver:

; 822  : 
; 823  :       }
; 824  : 
; 825  :     }
; 826  :   }
; 827  : 
; 828  :   f2 = get_fe_facet(side[besti+1].fe);

	mov	edx, DWORD PTR tv8096[ebp]
	mov	ecx, DWORD PTR [edx+84]
	mov	DWORD PTR tv8345[ebp], ecx
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN581@new_popver
	mov	edx, DWORD PTR _NULLFACET
	jmp	SHORT $LN580@new_popver
$LN581@new_popver:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [edx+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN580@new_popver
	xor	edx, 134217728				; 08000000H
$LN580@new_popver:
	mov	DWORD PTR _f2$[ebp], edx

; 829  :   if ( valid_id(f2) )

	test	edx, 268435456				; 10000000H
	je	$LN976@new_popver

; 830  :   {
; 831  :     fe_id = side[besti+1].fe;
; 832  :     other_fe = get_prev_edge(fe_id);

	mov	ebx, DWORD PTR tv8345[ebp]
	mov	ecx, ebx
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR tv8231[ebp], ecx
	je	SHORT $LN585@new_popver
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [eax+ebx]
	mov	esi, DWORD PTR [ecx+32]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN1127@new_popver
$LN585@new_popver:
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [eax+ebx]
	mov	esi, DWORD PTR [edx+28]
$LN1127@new_popver:

; 833  :     if ( valid_id(other_fe) && !equal_element(side[besti].e_id,get_fe_edge(other_fe)) )

	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _other_fe$[ebp], esi
	mov	DWORD PTR tv8246[ebp], ecx
	je	$LN23@new_popver
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [eax+esi]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR tv8096[ebp]
	mov	ecx, DWORD PTR [ecx]
	or	edx, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	ecx, edx
	je	$LN992@new_popver

; 834  :     { new_fe2 = new_facetedge(f2,new_e);

	mov	edx, DWORD PTR _new_e$[ebp]
	mov	eax, DWORD PTR _f2$[ebp]
	push	edx
	push	eax
	call	_new_facetedge
	add	esp, 8

; 835  :       set_edge_fe(new_e,new_fe2);

	test	DWORD PTR _new_e$[ebp], 134217728	; 08000000H
	mov	DWORD PTR $T90521[ebp], eax
	je	SHORT $LN590@new_popver
	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR $T90521[ebp], ecx
$LN590@new_popver:
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv8118[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR $T90521[ebp]
	mov	DWORD PTR [ecx+28], edx
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx

; 836  :       set_next_edge(other_fe,new_fe2);

	test	DWORD PTR _other_fe$[ebp], 134217728	; 08000000H
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
	je	SHORT $LN594@new_popver
	mov	edx, DWORD PTR _web+460
	mov	edx, DWORD PTR [edx+esi]
	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [edx+28], ecx
	jmp	SHORT $LN1128@new_popver
$LN594@new_popver:
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [ecx+esi]
	mov	DWORD PTR [edx+32], eax
$LN1128@new_popver:
	mov	edx, DWORD PTR tv8345[ebp]

; 837  :       set_prev_edge(fe_id,new_fe2);

	test	edx, 268435456				; 10000000H
	je	SHORT $LN971@new_popver
	cmp	DWORD PTR tv8231[ebp], 0
	je	SHORT $LN599@new_popver
	mov	esi, DWORD PTR _web+460
	mov	esi, DWORD PTR [esi+ebx]
	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [esi+32], ecx
	jmp	SHORT $LN598@new_popver
$LN599@new_popver:
	mov	ecx, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	DWORD PTR [ecx+28], eax
$LN598@new_popver:
	mov	esi, DWORD PTR _global_timestamp
	inc	esi
	mov	DWORD PTR _global_timestamp, esi
	mov	DWORD PTR _top_timestamp, esi
$LN971@new_popver:

; 838  :       set_next_edge(new_fe2,fe_id);

	mov	ebx, eax
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	mov	DWORD PTR tv8368[ebp], ebx
	je	SHORT $LN1016@new_popver
	mov	esi, DWORD PTR _web+460
	mov	ecx, eax
	test	eax, 134217728				; 08000000H
	je	SHORT $LN604@new_popver
	xor	edx, 134217728				; 08000000H
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [ecx+28], edx
	jmp	SHORT $LN1016@new_popver
$LN604@new_popver:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [ecx+32], edx
$LN1016@new_popver:

; 839  :       set_prev_edge(new_fe2,other_fe);

	test	ebx, ebx
	je	SHORT $LN611@new_popver
	test	eax, 134217728				; 08000000H
	je	SHORT $LN609@new_popver
	mov	ecx, DWORD PTR _other_fe$[ebp]
	mov	esi, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+32], ecx
	jmp	SHORT $LN608@new_popver
$LN609@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _other_fe$[ebp]
	mov	DWORD PTR [ecx+28], edx
$LN608@new_popver:
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
$LN611@new_popver:

; 840  : 
; 841  :       if ( valid_id(new_fe1) )

	test	edi, 268435456				; 10000000H
	je	$LN22@new_popver

; 842  :       { set_prev_facet(new_fe1,new_fe2);

	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, edi
	add	ecx, ecx
	shr	edx, 27					; 0000001bH
	add	ecx, ecx
	and	edx, 1
	je	SHORT $LN614@new_popver
	mov	ebx, DWORD PTR _web+460
	mov	ebx, DWORD PTR [ebx+ecx]
	mov	esi, eax
	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR [ebx+40], esi
	mov	ebx, DWORD PTR tv8368[ebp]
	jmp	SHORT $LN613@new_popver
$LN614@new_popver:
	mov	esi, DWORD PTR _web+460
	mov	esi, DWORD PTR [esi+ecx]
	mov	DWORD PTR [esi+36], eax
$LN613@new_popver:
	mov	esi, DWORD PTR _global_timestamp
	inc	esi
	mov	DWORD PTR _global_timestamp, esi
	mov	DWORD PTR _top_timestamp, esi

; 843  :         set_next_facet(new_fe1,new_fe2);

	test	edx, edx
	je	SHORT $LN619@new_popver
	mov	esi, DWORD PTR _web+460
	mov	ecx, DWORD PTR [esi+ecx]
	mov	edx, eax
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [ecx+36], edx
	jmp	SHORT $LN618@new_popver
$LN619@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [ecx+40], eax
$LN618@new_popver:

; 844  :         set_prev_facet(new_fe2,new_fe1);

	test	ebx, ebx
	je	$LN951@new_popver
	test	eax, 134217728				; 08000000H
	je	SHORT $LN624@new_popver
	mov	esi, DWORD PTR _web+460
	mov	ecx, edi
	xor	ecx, 134217728				; 08000000H
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+40], ecx
	jmp	SHORT $LN623@new_popver
$LN624@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+36], edi
$LN623@new_popver:
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx

; 845  :         set_next_facet(new_fe2,new_fe1);

	test	ebx, ebx
	je	$LN951@new_popver
	test	eax, 134217728				; 08000000H
	je	SHORT $LN629@new_popver
	mov	edx, DWORD PTR _web+460
	mov	ecx, edi
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+36], ecx
	jmp	$LN951@new_popver
$LN629@new_popver:
	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+40], edi

; 846  :       } else

	jmp	$LN951@new_popver
$LN22@new_popver:

; 847  :       { set_next_facet(new_fe2,new_fe2);

	test	ebx, ebx
	je	$LN951@new_popver
	mov	ecx, eax
	test	eax, 134217728				; 08000000H
	je	SHORT $LN634@new_popver
	mov	esi, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+36], ecx
	jmp	SHORT $LN633@new_popver
$LN634@new_popver:
	mov	edx, DWORD PTR _web+460
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+40], eax
$LN633@new_popver:

; 848  :         set_prev_facet(new_fe2,new_fe2);

	test	ebx, ebx
	je	$LN951@new_popver
	test	eax, 134217728				; 08000000H
	je	SHORT $LN639@new_popver
	mov	ecx, DWORD PTR _web+460
	mov	edx, eax
	xor	edx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [eax+40], edx
	jmp	$LN681@new_popver
$LN639@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+36], eax

; 849  :       }

	jmp	$LN681@new_popver
$LN992@new_popver:
	mov	ecx, DWORD PTR tv8246[ebp]
$LN23@new_popver:

; 850  :     }
; 851  :     else if ( !valid_id(other_fe) )

	test	ecx, ecx
	jne	$LN976@new_popver

; 852  :     { // just extend facet to new edge; probably pulling 2 off constraint.
; 853  :       new_fe2 = new_facetedge(f2,new_e);

	mov	edx, DWORD PTR _new_e$[ebp]
	mov	eax, DWORD PTR _f2$[ebp]
	push	edx
	push	eax
	call	_new_facetedge
	add	esp, 8

; 854  :       set_edge_fe(new_e,new_fe2);

	test	DWORD PTR _new_e$[ebp], 134217728	; 08000000H
	mov	esi, eax
	je	SHORT $LN972@new_popver
	xor	eax, 134217728				; 08000000H
$LN972@new_popver:
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv8118[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 855  :       set_prev_edge(fe_id,new_fe2);

	mov	eax, DWORD PTR tv8345[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN973@new_popver
	cmp	DWORD PTR tv8231[ebp], 0
	je	SHORT $LN647@new_popver
	mov	ecx, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [ecx+32], edx
	jmp	SHORT $LN646@new_popver
$LN647@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edx+ebx]
	mov	DWORD PTR [ecx+28], esi
$LN646@new_popver:
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
$LN973@new_popver:

; 856  :       set_next_edge(new_fe2,fe_id);

	mov	ebx, esi
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	mov	DWORD PTR tv8368[ebp], ebx
	je	SHORT $LN974@new_popver
	test	esi, 134217728				; 08000000H
	je	SHORT $LN652@new_popver
	mov	ecx, DWORD PTR _web+460
	xor	eax, 134217728				; 08000000H
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edx+28], eax
	jmp	SHORT $LN974@new_popver
$LN652@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+32], eax
$LN974@new_popver:

; 857  :       if ( !inverted(f2) )

	test	DWORD PTR _f2$[ebp], 134217728		; 08000000H
	jne	SHORT $LN18@new_popver

; 858  :         set_facet_fe(f2,new_fe2);  // is at start of chain

	mov	edx, DWORD PTR _f2$[ebp]
	push	esi
	push	edx
	call	_set_facet_fe
	add	esp, 8
$LN18@new_popver:

; 859  : 
; 860  :       if ( valid_id(new_fe1) )

	test	edi, 268435456				; 10000000H
	je	$LN17@new_popver

; 861  :       { set_prev_facet(new_fe1,new_fe2);

	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, edi
	add	eax, eax
	shr	ecx, 27					; 0000001bH
	add	eax, eax
	and	ecx, 1
	je	SHORT $LN657@new_popver
	mov	ebx, DWORD PTR _web+460
	mov	ebx, DWORD PTR [ebx+eax]
	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [ebx+40], edx
	mov	ebx, DWORD PTR tv8368[ebp]
	jmp	SHORT $LN656@new_popver
$LN657@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [edx+36], esi
$LN656@new_popver:
	mov	edx, DWORD PTR _global_timestamp
	inc	edx
	mov	DWORD PTR _global_timestamp, edx
	mov	DWORD PTR _top_timestamp, edx

; 862  :         set_next_facet(new_fe1,new_fe2);

	test	ecx, ecx
	je	SHORT $LN662@new_popver
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [edx+eax]
	mov	ecx, esi
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+36], ecx
	jmp	SHORT $LN661@new_popver
$LN662@new_popver:
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR [edx+40], esi
$LN661@new_popver:

; 863  :         set_prev_facet(new_fe2,new_fe1);

	test	ebx, ebx
	je	$LN951@new_popver
	test	esi, 134217728				; 08000000H
	je	SHORT $LN667@new_popver
	mov	edx, DWORD PTR _web+460
	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+40], eax
	jmp	SHORT $LN666@new_popver
$LN667@new_popver:
	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+36], edi
$LN666@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 864  :         set_next_facet(new_fe2,new_fe1);

	test	ebx, ebx
	je	$LN951@new_popver
	mov	edx, DWORD PTR _web+460
	test	esi, 134217728				; 08000000H
	je	SHORT $LN672@new_popver
	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [ecx+36], eax
	jmp	$LN951@new_popver
$LN672@new_popver:
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [eax+40], edi

; 865  :       } else

	jmp	$LN951@new_popver
$LN17@new_popver:

; 866  :       { set_next_facet(new_fe2,new_fe2);

	test	ebx, ebx
	je	$LN951@new_popver
	test	esi, 134217728				; 08000000H
	je	SHORT $LN677@new_popver
	mov	eax, DWORD PTR _web+460
	mov	ecx, esi
	xor	ecx, 134217728				; 08000000H
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [edx+36], ecx
	jmp	SHORT $LN1026@new_popver
$LN677@new_popver:
	mov	ecx, DWORD PTR _web+460
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+40], esi
$LN1026@new_popver:

; 867  :         set_prev_facet(new_fe2,new_fe2);

	test	ebx, ebx
	je	SHORT $LN951@new_popver
	mov	ecx, DWORD PTR _web+460
	mov	eax, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN682@new_popver
	xor	eax, 134217728				; 08000000H
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [edx+40], eax
	jmp	SHORT $LN681@new_popver
$LN682@new_popver:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+36], esi
$LN681@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _top_timestamp, eax
	mov	DWORD PTR _global_timestamp, eax
$LN951@new_popver:

; 849  :       }

	mov	eax, DWORD PTR _web+460
$LN976@new_popver:

; 868  :       }
; 869  :     }
; 870  :   }
; 871  :   fe_id = get_next_facet(side[besti+1].fe);

	mov	ecx, DWORD PTR tv8096[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN687@new_popver
	mov	ecx, DWORD PTR [ecx+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN1133@new_popver
$LN687@new_popver:
	mov	ecx, DWORD PTR [ecx+40]
$LN1133@new_popver:
	mov	DWORD PTR _fe_id$[ebp], ecx

; 872  :   if ( !equal_id(fe_id,side[besti+1].fe) )

	cmp	ecx, edx
	je	$LN952@new_popver

; 873  :   {
; 874  :     f2 = get_fe_facet(fe_id);

	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	DWORD PTR tv8275[ebp], edx
	jne	SHORT $LN691@new_popver
	mov	edx, DWORD PTR _NULLFACET
	jmp	SHORT $LN690@new_popver
$LN691@new_popver:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [edx+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN690@new_popver
	xor	edx, 134217728				; 08000000H
$LN690@new_popver:
	mov	DWORD PTR _f2$[ebp], edx

; 875  :     if ( valid_id(f2) )

	test	edx, 268435456				; 10000000H
	je	$LN952@new_popver

; 876  :     {
; 877  :       other_fe = get_prev_edge(fe_id);

	mov	ecx, DWORD PTR _fe_id$[ebp]
	mov	ebx, DWORD PTR _fe_id$[ebp]
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR tv8231[ebp], ecx
	je	SHORT $LN695@new_popver
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [eax+ebx]
	mov	esi, DWORD PTR [ecx+32]
	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR _other_fe$[ebp], esi
	jmp	SHORT $LN694@new_popver
$LN695@new_popver:
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR _other_fe$[ebp], ecx
	mov	esi, ecx
$LN694@new_popver:

; 878  :       if ( valid_id(other_fe) && !equal_element(side[besti].e_id,get_fe_edge(other_fe)) )

	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	je	$LN13@new_popver
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [eax+esi]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR tv8096[ebp]
	mov	edx, DWORD PTR [edx]
	or	eax, 134217728				; 08000000H
	or	edx, 134217728				; 08000000H
	cmp	edx, eax
	je	$LN13@new_popver

; 879  :       { new_fe2 = new_facetedge(f2,new_e);

	mov	eax, DWORD PTR _new_e$[ebp]
	mov	ecx, DWORD PTR _f2$[ebp]
	push	eax
	push	ecx
	call	_new_facetedge
	add	esp, 8

; 880  :         set_edge_fe(new_e,new_fe2);

	test	DWORD PTR _new_e$[ebp], 134217728	; 08000000H
	mov	DWORD PTR $T90678[ebp], eax
	je	SHORT $LN700@new_popver
	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR $T90678[ebp], ecx
$LN700@new_popver:
	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR tv8118[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR $T90678[ebp]
	mov	DWORD PTR [edx+28], ecx
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx

; 881  :         set_next_edge(other_fe,new_fe2);

	mov	ecx, DWORD PTR _other_fe$[ebp]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN704@new_popver
	mov	ecx, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ecx+esi]
	mov	edx, eax
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [ecx+28], edx
	mov	ecx, DWORD PTR _other_fe$[ebp]
	jmp	SHORT $LN703@new_popver
$LN704@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	edx, DWORD PTR [edx+esi]
	mov	DWORD PTR [edx+32], eax
$LN703@new_popver:

; 882  :         set_prev_edge(fe_id,new_fe2);

	cmp	DWORD PTR tv8275[ebp], 0
	je	SHORT $LN711@new_popver
	cmp	DWORD PTR tv8231[ebp], 0
	je	SHORT $LN709@new_popver
	mov	esi, DWORD PTR _web+460
	mov	esi, DWORD PTR [esi+ebx]
	mov	edx, eax
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [esi+32], edx
	jmp	SHORT $LN708@new_popver
$LN709@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	edx, DWORD PTR [edx+ebx]
	mov	DWORD PTR [edx+28], eax
$LN708@new_popver:
	mov	edx, DWORD PTR _global_timestamp
	inc	edx
	mov	DWORD PTR _global_timestamp, edx
	mov	DWORD PTR _top_timestamp, edx
$LN711@new_popver:

; 883  :         set_next_edge(new_fe2,fe_id);

	mov	ebx, eax
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	mov	DWORD PTR tv8368[ebp], ebx
	je	SHORT $LN1015@new_popver
	test	eax, 134217728				; 08000000H
	je	SHORT $LN714@new_popver
	mov	edx, DWORD PTR _fe_id$[ebp]
	mov	ebx, DWORD PTR _web+460
	xor	edx, 134217728				; 08000000H
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	ebx, DWORD PTR tv8368[ebp]
	mov	DWORD PTR [esi+28], edx
	jmp	SHORT $LN1015@new_popver
$LN714@new_popver:
	mov	esi, DWORD PTR _web+460
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR _fe_id$[ebp]
	mov	DWORD PTR [edx+32], esi
$LN1015@new_popver:

; 884  :         set_prev_edge(new_fe2,other_fe);

	test	ebx, ebx
	je	SHORT $LN721@new_popver
	mov	esi, DWORD PTR _web+460
	mov	edx, eax
	test	eax, 134217728				; 08000000H
	je	SHORT $LN719@new_popver
	xor	ecx, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+32], ecx
	jmp	SHORT $LN718@new_popver
$LN719@new_popver:
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+28], ecx
$LN718@new_popver:
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
$LN721@new_popver:

; 885  : 
; 886  :         if ( valid_id(new_fe1) )

	test	edi, 268435456				; 10000000H
	je	$LN12@new_popver

; 887  :         { set_prev_facet(new_fe1,new_fe2);

	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, edi
	add	ecx, ecx
	shr	edx, 27					; 0000001bH
	add	ecx, ecx
	and	edx, 1
	je	SHORT $LN724@new_popver
	mov	ebx, DWORD PTR _web+460
	mov	ebx, DWORD PTR [ebx+ecx]
	mov	esi, eax
	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR [ebx+40], esi
	mov	ebx, DWORD PTR tv8368[ebp]
	jmp	SHORT $LN723@new_popver
$LN724@new_popver:
	mov	esi, DWORD PTR _web+460
	mov	esi, DWORD PTR [esi+ecx]
	mov	DWORD PTR [esi+36], eax
$LN723@new_popver:
	mov	esi, DWORD PTR _global_timestamp
	inc	esi
	mov	DWORD PTR _global_timestamp, esi
	mov	DWORD PTR _top_timestamp, esi

; 888  :           set_next_facet(new_fe1,new_fe2);

	test	edx, edx
	je	SHORT $LN729@new_popver
	mov	esi, DWORD PTR _web+460
	mov	ecx, DWORD PTR [esi+ecx]
	mov	edx, eax
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [ecx+36], edx
	jmp	SHORT $LN728@new_popver
$LN729@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [ecx+40], eax
$LN728@new_popver:

; 889  :           set_prev_facet(new_fe2,new_fe1);

	test	ebx, ebx
	je	$LN952@new_popver
	test	eax, 134217728				; 08000000H
	je	SHORT $LN734@new_popver
	mov	esi, DWORD PTR _web+460
	mov	ecx, edi
	xor	ecx, 134217728				; 08000000H
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+40], ecx
	jmp	SHORT $LN733@new_popver
$LN734@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+36], edi
$LN733@new_popver:
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx

; 890  :           set_next_facet(new_fe2,new_fe1);

	test	ebx, ebx
	je	$LN952@new_popver
	test	eax, 134217728				; 08000000H
	je	SHORT $LN739@new_popver
	mov	edx, DWORD PTR _web+460
	xor	edi, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+36], edi
	jmp	$LN952@new_popver
$LN739@new_popver:
	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+40], edi

; 891  :         } else

	jmp	$LN952@new_popver
$LN12@new_popver:

; 892  :         { set_next_facet(new_fe2,new_fe2);

	test	ebx, ebx
	je	$LN952@new_popver
	mov	ecx, eax
	test	eax, 134217728				; 08000000H
	je	SHORT $LN744@new_popver
	mov	esi, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+36], ecx
	jmp	SHORT $LN743@new_popver
$LN744@new_popver:
	mov	edx, DWORD PTR _web+460
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+40], eax
$LN743@new_popver:

; 893  :           set_prev_facet(new_fe2,new_fe2);

	test	ebx, ebx
	je	$LN952@new_popver
	test	eax, 134217728				; 08000000H
	je	SHORT $LN749@new_popver
	mov	ecx, DWORD PTR _web+460
	mov	edx, eax
	xor	edx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [eax+40], edx
	jmp	$LN791@new_popver
$LN749@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+36], eax

; 894  :         }

	jmp	$LN791@new_popver
$LN13@new_popver:

; 895  :       }
; 896  :       else if ( !valid_id(other_fe) )

	test	ecx, ecx
	jne	$LN952@new_popver

; 897  :       { // just extend facet to new edge; just pulling off constraint
; 898  :         new_fe2 = new_facetedge(f2,new_e);

	mov	edx, DWORD PTR _new_e$[ebp]
	mov	eax, DWORD PTR _f2$[ebp]
	push	edx
	push	eax
	call	_new_facetedge
	add	esp, 8

; 899  :         set_edge_fe(new_e,new_fe2);

	test	DWORD PTR _new_e$[ebp], 134217728	; 08000000H
	mov	esi, eax
	je	SHORT $LN969@new_popver
	xor	eax, 134217728				; 08000000H
$LN969@new_popver:
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv8118[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR _global_timestamp
	inc	eax

; 900  :         set_prev_edge(fe_id,new_fe2);

	cmp	DWORD PTR tv8275[ebp], 0
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	je	SHORT $LN1004@new_popver
	cmp	DWORD PTR tv8231[ebp], 0
	je	SHORT $LN757@new_popver
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [eax+ebx]
	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [ecx+32], edx
	jmp	SHORT $LN756@new_popver
$LN757@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [edx+ebx]
	mov	DWORD PTR [eax+28], esi
$LN756@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN1004@new_popver:

; 901  :         set_next_edge(new_fe2,fe_id);

	mov	ebx, esi
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	mov	DWORD PTR tv8368[ebp], ebx
	je	SHORT $LN970@new_popver
	test	esi, 134217728				; 08000000H
	je	SHORT $LN762@new_popver
	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	edx, DWORD PTR _web+460
	xor	eax, 134217728				; 08000000H
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN970@new_popver
$LN762@new_popver:
	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _fe_id$[ebp]
	mov	DWORD PTR [ecx+32], edx
$LN970@new_popver:

; 902  :         if ( !inverted(f2) )

	test	DWORD PTR _f2$[ebp], 134217728		; 08000000H
	jne	SHORT $LN8@new_popver

; 903  :           set_facet_fe(f2,new_fe2);  // is at start of chain

	mov	eax, DWORD PTR _f2$[ebp]
	push	esi
	push	eax
	call	_set_facet_fe
	add	esp, 8
$LN8@new_popver:

; 904  : 
; 905  :         if ( valid_id(new_fe1) )

	test	edi, 268435456				; 10000000H
	je	$LN7@new_popver

; 906  :         { set_prev_facet(new_fe1,new_fe2);

	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, edi
	add	eax, eax
	shr	ecx, 27					; 0000001bH
	add	eax, eax
	and	ecx, 1
	je	SHORT $LN767@new_popver
	mov	ebx, DWORD PTR _web+460
	mov	ebx, DWORD PTR [ebx+eax]
	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [ebx+40], edx
	mov	ebx, DWORD PTR tv8368[ebp]
	jmp	SHORT $LN766@new_popver
$LN767@new_popver:
	mov	edx, DWORD PTR _web+460
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [edx+36], esi
$LN766@new_popver:
	mov	edx, DWORD PTR _global_timestamp
	inc	edx
	mov	DWORD PTR _global_timestamp, edx
	mov	DWORD PTR _top_timestamp, edx

; 907  :           set_next_facet(new_fe1,new_fe2);

	test	ecx, ecx
	je	SHORT $LN772@new_popver
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [edx+eax]
	mov	ecx, esi
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+36], ecx
	jmp	SHORT $LN771@new_popver
$LN772@new_popver:
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR [edx+40], esi
$LN771@new_popver:

; 908  :           set_prev_facet(new_fe2,new_fe1);

	test	ebx, ebx
	je	$LN952@new_popver
	test	esi, 134217728				; 08000000H
	je	SHORT $LN777@new_popver
	mov	edx, DWORD PTR _web+460
	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+40], eax
	jmp	SHORT $LN776@new_popver
$LN777@new_popver:
	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+36], edi
$LN776@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 909  :           set_next_facet(new_fe2,new_fe1);

	test	ebx, ebx
	je	$LN952@new_popver
	test	esi, 134217728				; 08000000H
	je	SHORT $LN782@new_popver
	mov	edx, DWORD PTR _web+460
	xor	edi, 134217728				; 08000000H
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [eax+36], edi
	jmp	$LN952@new_popver
$LN782@new_popver:
	mov	ecx, DWORD PTR _web+460
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [edx+40], edi

; 910  :         } else

	jmp	$LN952@new_popver
$LN7@new_popver:

; 911  :         { set_next_facet(new_fe2,new_fe2);

	test	ebx, ebx
	je	$LN952@new_popver
	test	esi, 134217728				; 08000000H
	je	SHORT $LN787@new_popver
	mov	edx, DWORD PTR _web+460
	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+36], eax
	jmp	SHORT $LN1040@new_popver
$LN787@new_popver:
	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+40], esi
$LN1040@new_popver:

; 912  :           set_prev_facet(new_fe2,new_fe2);

	test	ebx, ebx
	je	SHORT $LN952@new_popver
	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN792@new_popver
	xor	edx, 134217728				; 08000000H
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+40], edx
	jmp	SHORT $LN791@new_popver
$LN792@new_popver:
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+36], esi
$LN791@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _top_timestamp, eax
	mov	DWORD PTR _global_timestamp, eax
$LN952@new_popver:

; 913  :         }
; 914  :       }
; 915  : 
; 916  :     }
; 917  :   }                
; 918  : 
; 919  :   /* make sure new edge has at least one facetedge structure */
; 920  :   if ( !valid_id(get_edge_fe(new_e)) )

	mov	edx, DWORD PTR tv8118[ebp]
	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [edx+eax]
	test	eax, eax
	je	SHORT $LN796@new_popver
$LN797@new_popver:
	test	DWORD PTR _new_e$[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR [eax+28]
	je	SHORT $LN796@new_popver
	xor	eax, 134217728				; 08000000H
$LN796@new_popver:
	test	eax, 268435456				; 10000000H
	jne	$newpop_exit$89402

; 921  :   { facetedge_id new_fe = new_facetedge(NULLID,new_e);

	mov	esi, DWORD PTR _new_e$[ebp]
	push	esi
	push	0
	call	_new_facetedge
	add	esp, 8

; 922  :     set_edge_fe(new_e,new_fe);

	mov	ecx, eax
	test	esi, 134217728				; 08000000H
	je	SHORT $LN800@new_popver
	xor	ecx, 134217728				; 08000000H
$LN800@new_popver:
	mov	edx, DWORD PTR _web+124
	mov	esi, DWORD PTR tv8118[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [edx+28], ecx
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx

; 923  :     set_next_edge(new_fe,inverse_id(new_fe));

	mov	edx, eax
	mov	ecx, eax
	shr	edx, 28					; 0000001cH
	xor	ecx, 134217728				; 08000000H
	and	edx, 1
	je	SHORT $LN963@new_popver
	test	eax, 134217728				; 08000000H
	je	SHORT $LN804@new_popver
	mov	ebx, DWORD PTR _web+460
	mov	esi, ecx
	xor	esi, 134217728				; 08000000H
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [edi+28], esi
	jmp	SHORT $LN963@new_popver
$LN804@new_popver:
	mov	edi, DWORD PTR _web+460
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	mov	DWORD PTR [esi+32], ecx
$LN963@new_popver:

; 924  :     set_prev_edge(new_fe,inverse_id(new_fe));

	test	edx, edx
	je	$newpop_exit$89402
	test	eax, 134217728				; 08000000H
	je	SHORT $LN809@new_popver
	mov	ebx, DWORD PTR _web+460
	mov	esi, ecx
	xor	esi, 134217728				; 08000000H
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [edi+32], esi
	jmp	SHORT $LN808@new_popver
$LN809@new_popver:
	mov	edi, DWORD PTR _web+460
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	mov	DWORD PTR [esi+28], ecx
$LN808@new_popver:
	mov	esi, DWORD PTR _global_timestamp
	inc	esi
	mov	DWORD PTR _global_timestamp, esi
	mov	DWORD PTR _top_timestamp, esi

; 925  :     set_next_facet(new_fe,new_fe);

	test	edx, edx
	je	SHORT $newpop_exit$89402
	mov	edi, DWORD PTR _web+460
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN814@new_popver
	mov	DWORD PTR [esi+36], ecx
	jmp	SHORT $LN813@new_popver
$LN814@new_popver:
	mov	DWORD PTR [esi+40], eax
$LN813@new_popver:

; 926  :     set_prev_facet(new_fe,new_fe);

	test	edx, edx
	je	SHORT $newpop_exit$89402
	mov	edx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN819@new_popver
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+40], ecx
	jmp	SHORT $LN818@new_popver
$LN819@new_popver:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+36], eax
$LN818@new_popver:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$newpop_exit$89402:

; 927  :   }
; 928  : 
; 929  : newpop_exit:
; 930  :   temp_free((char *)side);

	mov	edx, DWORD PTR _side$[ebp]
	push	edx
	call	_temp_free
	add	esp, 4

; 931  : 
; 932  :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN964@new_popver

; 933  :   { // get all content methods right
; 934  :     if ( valid_id(new_v) )

	mov	eax, DWORD PTR _new_v$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@new_popver

; 935  :       assure_v_constraints(new_v);

	push	eax
	call	_assure_v_constraints
	add	esp, 4
$LN3@new_popver:

; 936  :     assure_v_constraints(v_id);

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	eax
	call	_assure_v_constraints
	add	esp, 4
$LN964@new_popver:

; 937  :   }
; 938  :   if ( (edges > 4) || ((edges > 2) && (degfree < SDIM)) )

	mov	eax, DWORD PTR _edges$GSCopy$[ebp]
	cmp	eax, 4
	jg	SHORT $LN1@new_popver
	cmp	eax, 2
	jle	SHORT $LN2@new_popver
	mov	ecx, DWORD PTR _degfree$[ebp]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN1@new_popver
$LN2@new_popver:
	pop	edi
	pop	esi

; 940  :   return 1;

	mov	eax, 1
	pop	ebx

; 941  : } // end new_popverst()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@new_popver:

; 939  :     return 1 + new_popverst(v_id,edges-1); /* recurse if need */

	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	dec	eax
	push	eax
	push	edx
	call	_new_popverst

; 941  : } // end new_popverst()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	xor	ecx, ebp
	inc	eax
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_new_popverst ENDP
_TEXT	ENDS
PUBLIC	_autopop_init
EXTRN	_autochop_flag:DWORD
EXTRN	_autopop_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _autopop_init
_TEXT	SEGMENT
_autopop_init PROC					; COMDAT

; 957  :   if ( autopop_flag )

	cmp	DWORD PTR _autopop_flag, 0
	je	SHORT $LN2@autopop_in

; 958  :   {
; 959  :     autopop_list = (edge_id *)temp_calloc(web.skel[EDGE].count+web.skel[FACET].count,sizeof(edge_id));

	mov	ecx, DWORD PTR _web+288
	add	ecx, DWORD PTR _web+176
	push	959					; 000003bfH
	push	OFFSET ??_C@_0L@BJPEFIAD@VERPOPST?4C?$AA@
	push	4
	push	ecx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _autopop_list, eax
$LN2@autopop_in:

; 960  :   
; 961  :   }
; 962  :   if ( autochop_flag )

	cmp	DWORD PTR _autochop_flag, 0
	je	SHORT $LN1@autopop_in

; 963  :   {
; 964  :     autochop_list = (edge_id *)temp_calloc(web.skel[EDGE].count,sizeof(edge_id));

	mov	edx, DWORD PTR _web+176
	push	964					; 000003c4H
	push	OFFSET ??_C@_0L@BJPEFIAD@VERPOPST?4C?$AA@
	push	4
	push	edx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _autochop_list, eax
$LN1@autopop_in:

; 965  :   }
; 966  : } /* end autopop_init() */

	ret	0
_autopop_init ENDP
_TEXT	ENDS
PUBLIC	_autopop_cleanup
; Function compile flags: /Ogtp
;	COMDAT _autopop_cleanup
_TEXT	SEGMENT
_autopop_cleanup PROC					; COMDAT

; 975  : { if ( autochop_list )

	mov	eax, DWORD PTR _autochop_list
	test	eax, eax
	je	SHORT $LN2@autopop_cl

; 976  :   { temp_free((char*)autochop_list);

	push	eax
	call	_temp_free
	add	esp, 4

; 977  :     autochop_list = NULL;

	mov	DWORD PTR _autochop_list, 0
$LN2@autopop_cl:

; 978  :   }
; 979  :   if ( autopop_list )

	mov	eax, DWORD PTR _autopop_list
	test	eax, eax
	je	SHORT $LN1@autopop_cl

; 980  :   { temp_free((char*)autopop_list);

	push	eax
	call	_temp_free
	add	esp, 4

; 981  :     autopop_list = NULL;

	mov	DWORD PTR _autopop_list, 0
$LN1@autopop_cl:

; 982  :   }
; 983  : } /* end autopop_cleanup() */

	ret	0
_autopop_cleanup ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fe0a3d70a3d70a4
PUBLIC	__$ArrayPad$
PUBLIC	_autopop_detect
EXTRN	_delete_facet:PROC
EXTRN	_get_edge_side:PROC
EXTRN	_autochop_length:QWORD
EXTRN	_delete_edge:PROC
EXTRN	_immediate_autopop_flag:DWORD
EXTRN	_runge_kutta_flag:DWORD
EXTRN	_autochop_count:DWORD
EXTRN	_autopop_count:DWORD
EXTRN	_autopop_quartic_flag:DWORD
;	COMDAT __real@3fe0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fe0a3d70a3d70a4
CONST	SEGMENT
__real@3fe0a3d70a3d70a4 DQ 03fe0a3d70a3d70a4r	; 0.52
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\verpopst.c
CONST	ENDS
;	COMDAT _autopop_detect
_TEXT	SEGMENT
_velocities$89776 = -328				; size = 12
_s1v$89795 = -316					; size = 8
_s1s2$89793 = -308					; size = 8
_s2s2$89794 = -300					; size = 8
_minlength$ = -292					; size = 8
tv657 = -284						; size = 8
_area$89777 = -284					; size = 8
_perim$89780 = -276					; size = 8
_length$89750 = -276					; size = 8
_s1s1$89792 = -268					; size = 8
tv879 = -264						; size = 4
_area_rate$89778 = -260					; size = 8
tv628 = -256						; size = 4
_i$89774 = -256						; size = 4
_f_id$89764 = -252					; size = 4
tv694 = -248						; size = 4
_headf$89737 = -248					; size = 4
_sides$89775 = -244					; size = 144
_headtan$89749 = -100					; size = 48
_tailtan$89748 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_scale$ = 8						; size = 8
_autopop_detect PROC					; COMDAT

; 1003 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1004 :   edge_id e_id;
; 1005 :   REAL minlength = sqrt(2*scale); /* stability critical length */

	fld	QWORD PTR _scale$[ebp]
	push	ebx
	push	esi
	fadd	ST(0), ST(0)
	push	edi
	call	__CIsqrt
	fstp	QWORD PTR _minlength$[ebp]

; 1006 : 
; 1007 :   if ( autopop_quartic_flag )

	xor	esi, esi
	cmp	DWORD PTR _autopop_quartic_flag, esi
	je	SHORT $LN32@autopop_de

; 1008 :     minlength = 2*sqrt(sqrt(scale));

	fld	QWORD PTR _scale$[ebp]
	call	__CIsqrt
	call	__CIsqrt
	fadd	ST(0), ST(0)
	fstp	QWORD PTR _minlength$[ebp]
$LN32@autopop_de:

; 1009 : 
; 1010 : #ifdef MPI_EVOLVER
; 1011 :   if ( this_task == MASTER_TASK )
; 1012 :   { mpi_autopop_detect(scale);
; 1013 :     return;
; 1014 :   }
; 1015 : #endif
; 1016 : 
; 1017 :   autopop_init();

	call	_autopop_init

; 1018 : 
; 1019 :   autopop_count = 0;
; 1020 :   autochop_count = 0;  
; 1021 :   FOR_ALL_EDGES(e_id)

	mov	edi, DWORD PTR _web+160
	mov	DWORD PTR _autopop_count, esi
	mov	DWORD PTR _autochop_count, esi
	test	edi, 268435456				; 10000000H
	je	$LN73@autopop_de
	mov	ecx, DWORD PTR _web+124
	npad	2
$LL77@autopop_de:
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN30@autopop_de

; 1022 :   {
; 1023 :     vertex_id headv = get_edge_headv(e_id);

	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [esi+ecx]
	mov	eax, edi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv628[ebp], eax
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edx+304]
	je	SHORT $LN40@autopop_de
	add	ecx, eax
	mov	eax, DWORD PTR [ecx]
	jmp	SHORT $LN39@autopop_de
$LN40@autopop_de:
	add	ecx, eax
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [ecx+eax*4]
$LN39@autopop_de:

; 1024 :     REAL *headf = get_velocity(headv);

	mov	ebx, DWORD PTR _web+104
	mov	edx, DWORD PTR [ebx+edx+1024]
	mov	ebx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	add	eax, edx

; 1025 :     vertex_id tailv = get_edge_tailv(e_id);

	cmp	DWORD PTR tv628[ebp], 0
	mov	DWORD PTR _headf$89737[ebp], eax
	je	SHORT $LN44@autopop_de
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN43@autopop_de
$LN44@autopop_de:
	mov	eax, DWORD PTR [ecx]
$LN43@autopop_de:

; 1026 :     REAL *tailf = get_velocity(tailv);
; 1027 :     REAL tailtan[MAXCOORD],headtan[MAXCOORD];
; 1028 :     REAL length,dx;
; 1029 : 
; 1030 :     get_edge_tail_tangent(e_id,tailtan);

	lea	ecx, DWORD PTR _tailtan$89748[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ebx+eax*4]
	push	ecx
	push	edi
	add	ebx, edx
	call	_get_edge_tail_tangent

; 1031 :     get_edge_tail_tangent(inverse_id(e_id),headtan);

	lea	edx, DWORD PTR _headtan$89749[ebp]
	mov	eax, edi
	push	edx
	xor	eax, 134217728				; 08000000H
	push	eax
	call	_get_edge_tail_tangent

; 1032 :     length = sqrt(SDIM_dot(tailtan,tailtan));

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _tailtan$89748[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	add	esp, 28					; 0000001cH
	call	__CIsqrt
	fst	QWORD PTR _length$89750[ebp]

; 1033 :     if ( length > 0.0 )

	fldz
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN25@autopop_de

; 1034 :       dx = -scale*(SDIM_dot(headf,headtan)
; 1035 :                           + SDIM_dot(tailf,tailtan))/length;

	mov	ecx, DWORD PTR _web+616
	fstp	ST(1)
	push	ecx
	fstp	ST(0)
	lea	edx, DWORD PTR _tailtan$89748[ebp]
	push	edx
	push	ebx
	call	_dot
	fstp	QWORD PTR tv657[ebp]
	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR _headf$89737[ebp]
	push	eax
	lea	ecx, DWORD PTR _headtan$89749[ebp]
	push	ecx
	push	edx
	call	_dot
	fadd	QWORD PTR tv657[ebp]
	add	esp, 24					; 00000018H
	fmul	QWORD PTR _scale$[ebp]
	fld	QWORD PTR _length$89750[ebp]
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fchs
$LN25@autopop_de:

; 1036 :     else dx = 0.0;
; 1037 :     if ( autopop_flag && (dx <= 0.0) )

	cmp	DWORD PTR _autopop_flag, 0
	je	SHORT $LN76@autopop_de
	fldz
	fcom	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN86@autopop_de

; 1038 :     { if ( (length < minlength) || 
; 1039 :           (length + dx <= (runge_kutta_flag ? 0.52*length : 0.0)) )

	fld	QWORD PTR _minlength$[ebp]
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN89@autopop_de
	cmp	DWORD PTR _runge_kutta_flag, 0
	je	SHORT $LN36@autopop_de
	fstp	ST(0)
	fld	ST(1)
	fmul	QWORD PTR __real@3fe0a3d70a3d70a4
$LN36@autopop_de:
	fld	ST(1)
	fadd	ST(0), ST(3)
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN76@autopop_de
	jmp	SHORT $LN22@autopop_de
$LN89@autopop_de:
	fstp	ST(0)
$LN22@autopop_de:

; 1040 :       { if ( immediate_autopop_flag )

	cmp	DWORD PTR _immediate_autopop_flag, 0
	je	SHORT $LN21@autopop_de
	fstp	ST(1)

; 1041 :         { int ret = delete_edge(e_id); 

	push	edi
	fstp	ST(0)
	call	_delete_edge
	add	esp, 4

; 1042 :           if ( ret ) free_element(e_id); 

	test	eax, eax
	je	SHORT $LN71@autopop_de
	push	edi
	call	_free_element
	add	esp, 4

; 1043 :           continue; /* next edge */

	jmp	SHORT $LN71@autopop_de
$LN21@autopop_de:

; 1044 :         }
; 1045 :         else /* add to list */
; 1046 :           autopop_list[autopop_count++] = e_id;

	mov	eax, DWORD PTR _autopop_count
	mov	ecx, DWORD PTR _autopop_list
	mov	DWORD PTR [ecx+eax*4], edi
	inc	DWORD PTR _autopop_count
	jmp	SHORT $LN76@autopop_de
$LN86@autopop_de:

; 1036 :     else dx = 0.0;
; 1037 :     if ( autopop_flag && (dx <= 0.0) )

	fstp	ST(0)
$LN76@autopop_de:

; 1047 :       }
; 1048 :     }
; 1049 :     if ( autochop_flag )

	cmp	DWORD PTR _autochop_flag, 0
	je	SHORT $LN99@autopop_de

; 1050 :     if ( length + dx > autochop_length)

	faddp	ST(1), ST(0)
	fcomp	QWORD PTR _autochop_length
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN71@autopop_de

; 1051 :     { /* add to list */
; 1052 :       autochop_list[autochop_count++] = e_id;

	mov	edx, DWORD PTR _autochop_count
	mov	eax, DWORD PTR _autochop_list
	mov	DWORD PTR [eax+edx*4], edi
	inc	DWORD PTR _autochop_count
	jmp	SHORT $LN71@autopop_de
$LN99@autopop_de:

; 1047 :       }
; 1048 :     }
; 1049 :     if ( autochop_flag )

	fstp	ST(1)
	fstp	ST(0)
$LN71@autopop_de:

; 1043 :           continue; /* next edge */

	mov	ecx, DWORD PTR _web+124
$LN30@autopop_de:

; 1018 : 
; 1019 :   autopop_count = 0;
; 1020 :   autochop_count = 0;  
; 1021 :   FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR [esi+ecx]
	mov	edi, DWORD PTR [edx]
	test	edi, 268435456				; 10000000H
	jne	$LL77@autopop_de
$LN73@autopop_de:

; 1053 :     }
; 1054 :   }
; 1055 : 
; 1056 :   if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	jne	$LN13@autopop_de

; 1057 :   { facet_id f_id;
; 1058 : 
; 1059 :     FOR_ALL_FACETS(f_id)

	mov	edi, DWORD PTR _web+272
	mov	edx, edi
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	DWORD PTR _f_id$89764[ebp], edi
	je	$LN13@autopop_de
	jmp	SHORT $LN15@autopop_de
	npad	4
$LL72@autopop_de:
	mov	edi, DWORD PTR _f_id$89764[ebp]
$LN15@autopop_de:
	mov	ebx, DWORD PTR _web+236
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	esi, esi
	or	ecx, esi
	mov	DWORD PTR tv694[ebp], eax
	je	$LN14@autopop_de

; 1060 :     { int i;
; 1061 :       REAL sides[FACET_EDGES][MAXCOORD];
; 1062 :       REAL *velocities[FACET_VERTS];
; 1063 :       REAL area=0.0,area_rate;
; 1064 :       facetedge_id fe;
; 1065 :       REAL perim = 0.0;

	fldz
	fstp	QWORD PTR _perim$89780[ebp]

; 1066 : 
; 1067 :       fe = get_facet_fe(f_id);

	test	edx, edx
	jne	SHORT $LN48@autopop_de
	xor	ebx, ebx
	jmp	SHORT $LN47@autopop_de
$LN48@autopop_de:
	mov	eax, DWORD PTR [eax+ebx]
	mov	ebx, DWORD PTR [eax+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN47@autopop_de
	xor	ebx, 134217728				; 08000000H
$LN47@autopop_de:

; 1068 :       for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _web+460
	lea	ecx, DWORD PTR _sides$89775[ebp]
	mov	DWORD PTR _i$89774[ebp], esi
	mov	DWORD PTR tv879[ebp], ecx
	npad	5
$LL75@autopop_de:

; 1069 :       { e_id = get_fe_edge(fe);

	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+eax]

; 1070 :         get_edge_side(e_id,sides[i]);

	mov	eax, DWORD PTR tv879[ebp]
	mov	esi, ebx
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [edx+20]
	push	eax
	push	esi
	call	_get_edge_side

; 1071 :         velocities[i] = get_velocity(get_edge_tailv(e_id));

	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR _web+216
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN54@autopop_de
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN53@autopop_de
$LN54@autopop_de:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]
$LN53@autopop_de:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+104
	add	eax, DWORD PTR [edx+ecx+1024]
	mov	ecx, DWORD PTR _i$89774[ebp]
	mov	DWORD PTR _velocities$89776[ebp+ecx*4], eax

; 1072 :         fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	mov	edx, DWORD PTR [edi+eax]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN58@autopop_de
	mov	ebx, DWORD PTR [edx+28]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN9@autopop_de
$LN58@autopop_de:
	mov	ebx, DWORD PTR [edx+32]
$LN9@autopop_de:

; 1068 :       for ( i = 0 ; i < FACET_VERTS ; i++ )

	add	DWORD PTR tv879[ebp], 48		; 00000030H
	inc	ecx
	mov	DWORD PTR _i$89774[ebp], ecx
	cmp	ecx, 3
	jl	$LL75@autopop_de

; 1073 :       }
; 1074 : 
; 1075 :       /* get area rate of change */
; 1076 :       area_rate = 0.0;

	fldz

; 1077 :       for ( i = 0 ; i < FACET_VERTS ; i++ )

	xor	esi, esi
	fstp	QWORD PTR _area_rate$89778[ebp]
	jmp	SHORT $LN74@autopop_de
	npad	1
$LL102@autopop_de:
	fstp	ST(0)
$LN74@autopop_de:

; 1078 :       { int ii = (i==0)?2:(i-1);

	mov	ebx, 2
	test	esi, esi
	je	SHORT $LN38@autopop_de
	lea	ebx, DWORD PTR [esi-1]
$LN38@autopop_de:

; 1079 :         REAL s1s1,s1s2,s2s2,s1v,s2v;
; 1080 :         s1s1 = SDIM_dot(sides[i],sides[i]);

	mov	eax, DWORD PTR _web+616
	lea	edi, DWORD PTR [esi+esi*2]
	add	edi, edi
	push	eax
	lea	edi, DWORD PTR _sides$89775[ebp+edi*8]
	push	edi
	push	edi
	call	_dot
	fstp	QWORD PTR _s1s1$89792[ebp]

; 1081 :         s2s2 = SDIM_dot(sides[ii],sides[ii]);

	mov	ecx, DWORD PTR _web+616
	lea	ebx, DWORD PTR [ebx+ebx*2]
	add	ebx, ebx
	push	ecx
	lea	ebx, DWORD PTR _sides$89775[ebp+ebx*8]
	push	ebx
	push	ebx
	call	_dot
	fstp	QWORD PTR _s2s2$89794[ebp]

; 1082 :         s1s2 = -SDIM_dot(sides[i],sides[ii]);

	mov	edx, DWORD PTR _web+616
	push	edx
	push	ebx
	push	edi
	call	_dot
	fchs

; 1083 :         s1v  = SDIM_dot(sides[i],velocities[i]); 

	mov	ecx, DWORD PTR _web+616
	fstp	QWORD PTR _s1s2$89793[ebp]
	mov	eax, DWORD PTR _velocities$89776[ebp+esi*4]
	push	ecx
	push	eax
	push	edi
	call	_dot
	fstp	QWORD PTR _s1v$89795[ebp]

; 1084 :         s2v  = -SDIM_dot(sides[ii],velocities[i]); 
; 1085 :         area = sqrt(s1s1*s2s2 - s1s2*s1s2);

	fld	QWORD PTR _s2s2$89794[ebp]
	add	esp, 48					; 00000030H
	fmul	QWORD PTR _s1s1$89792[ebp]
	fld	QWORD PTR _s1s2$89793[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR _area$89777[ebp]
	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _velocities$89776[ebp+esi*4]
	push	edx
	push	eax
	push	ebx
	call	_dot
	fchs

; 1086 :         area_rate -= (s1v*(s2s2 - s1s2) + s2v*(s1s1 - s1s2))/area;

	fld	QWORD PTR _s1s1$89792[ebp]
	add	esp, 12					; 0000000cH
	fld	ST(0)
	fld	QWORD PTR _s1s2$89793[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(3)
	fmulp	ST(1), ST(0)
	fld	QWORD PTR _s2s2$89794[ebp]
	fsubrp	ST(3), ST(0)
	fxch	ST(2)
	fmul	QWORD PTR _s1v$89795[ebp]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	QWORD PTR _area$89777[ebp]
	fsubr	QWORD PTR _area_rate$89778[ebp]
	fstp	QWORD PTR _area_rate$89778[ebp]

; 1087 :         perim += sqrt(s1s1);

	call	__CIsqrt
	fadd	QWORD PTR _perim$89780[ebp]
	inc	esi
	fst	QWORD PTR _perim$89780[ebp]
	cmp	esi, 3
	jl	$LL102@autopop_de

; 1088 :       }
; 1089 :       if ( (area_rate < 0) && (area + scale*area_rate <= minlength*perim/2) )

	fldz
	fld	QWORD PTR _area_rate$89778[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN105@autopop_de
	fmul	QWORD PTR _scale$[ebp]
	fadd	QWORD PTR _area$89777[ebp]
	fxch	ST(1)
	fmul	QWORD PTR _minlength$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN70@autopop_de

; 1090 :       { if ( immediate_autopop_flag )

	cmp	DWORD PTR _immediate_autopop_flag, 0
	je	SHORT $LN3@autopop_de

; 1091 :           delete_facet(f_id);

	mov	eax, DWORD PTR _f_id$89764[ebp]
	push	eax
	call	_delete_facet
	add	esp, 4
	jmp	SHORT $LN70@autopop_de
$LN3@autopop_de:

; 1092 :         else if ( autopop_flag ) /* add to list */

	cmp	DWORD PTR _autopop_flag, 0
	je	SHORT $LN70@autopop_de

; 1093 :           autopop_list[autopop_count++] = f_id;

	mov	ecx, DWORD PTR _autopop_count
	mov	edx, DWORD PTR _autopop_list
	mov	eax, DWORD PTR _f_id$89764[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	inc	DWORD PTR _autopop_count
	jmp	SHORT $LN70@autopop_de
$LN105@autopop_de:

; 1088 :       }
; 1089 :       if ( (area_rate < 0) && (area + scale*area_rate <= minlength*perim/2) )

	fstp	ST(1)
	fstp	ST(0)
$LN70@autopop_de:

; 1093 :           autopop_list[autopop_count++] = f_id;

	mov	eax, DWORD PTR tv694[ebp]
$LN14@autopop_de:

; 1057 :   { facet_id f_id;
; 1058 : 
; 1059 :     FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR _f_id$89764[ebp], edx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	$LL72@autopop_de
$LN13@autopop_de:

; 1094 :       }
; 1095 :     } /* end facet loop */
; 1096 :   } /* end facet detect */
; 1097 : 
; 1098 : } /* end autopop_detect() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_autopop_detect ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@OPKPKPJD@Autochopped?5?$CFd?5edges?4?6?$AA@ ; `string'
PUBLIC	_autochop_chop
EXTRN	_edge_refine:PROC
EXTRN	_valid_element:PROC
;	COMDAT ??_C@_0BH@OPKPKPJD@Autochopped?5?$CFd?5edges?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@OPKPKPJD@Autochopped?5?$CFd?5edges?4?6?$AA@ DB 'Autochopped %d '
	DB	'edges.', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _autochop_chop
_TEXT	SEGMENT
_autochop_chop PROC					; COMDAT

; 1174 :   int k;
; 1175 : 
; 1176 : #ifdef MPI_EVOLVER
; 1177 :   if ( this_task == MASTER_TASK )
; 1178 :   { mpi_autopop_chop();
; 1179 :     return;
; 1180 :   }
; 1181 : #endif
; 1182 : 
; 1183 :   if ( autochop_list == NULL ) return;

	cmp	DWORD PTR _autochop_list, 0
	je	$LN7@autochop_c

; 1184 : 
; 1185 :   for ( k = 0 ; k < autochop_count ; k++ )

	push	esi
	xor	esi, esi
	cmp	DWORD PTR _autochop_count, esi
	jle	SHORT $LN12@autochop_c
	npad	8
$LL11@autochop_c:

; 1186 :     { /* printf("chopping edge %s\n",ELNAME(autochop_list[k])); */
; 1187 :       if ( !valid_element(autochop_list[k]) )

	mov	eax, DWORD PTR _autochop_list
	mov	ecx, DWORD PTR [eax+esi*4]
	push	ecx
	call	_valid_element
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@autochop_c

; 1188 :          continue;
; 1189 :       edge_refine(autochop_list[k]);      

	mov	edx, DWORD PTR _autochop_list
	mov	eax, DWORD PTR [edx+esi*4]
	push	eax
	call	_edge_refine
	add	esp, 4
$LN4@autochop_c:

; 1184 : 
; 1185 :   for ( k = 0 ; k < autochop_count ; k++ )

	mov	eax, DWORD PTR _autochop_count
	inc	esi
	cmp	esi, eax
	jl	SHORT $LL11@autochop_c

; 1190 :  
; 1191 :     }
; 1192 : 
; 1193 :   if ( autochop_count > 0 )

	test	eax, eax
	jle	SHORT $LN12@autochop_c

; 1194 :      { sprintf(msg,"Autochopped %d edges.\n",autochop_count);

	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BH@OPKPKPJD@Autochopped?5?$CFd?5edges?4?6?$AA@
	push	ecx
	call	_sprintf

; 1195 :        outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN12@autochop_c:

; 1196 :      }
; 1197 : 
; 1198 :   temp_free((char *)autochop_list);

	mov	eax, DWORD PTR _autochop_list
	push	eax
	call	_temp_free
	add	esp, 4

; 1199 :   autochop_list = NULL;

	mov	DWORD PTR _autochop_list, 0

; 1200 :   autochop_count = 0;

	mov	DWORD PTR _autochop_count, 0
	pop	esi
$LN7@autochop_c:

; 1201 : 
; 1202 : } // end autochop_chop()

	ret	0
_autochop_chop ENDP
_TEXT	ENDS
PUBLIC	__real@3eb0c6f7a0b5ed8d
PUBLIC	__real@c000000000000000
PUBLIC	_poponest
EXTRN	_set_e_phase_density:PROC
;	COMDAT __real@3eb0c6f7a0b5ed8d
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-006
CONST	ENDS
;	COMDAT __real@c000000000000000
CONST	SEGMENT
__real@c000000000000000 DQ 0c000000000000000r	; -2
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\verpopst.c
CONST	ENDS
;	COMDAT _poponest
_TEXT	SEGMENT
_maxcos$ = -60						; size = 8
_new_v$ = -56						; size = 4
tv1148 = -52						; size = 4
tv1119 = -48						; size = 4
_first_fe$89121 = -48					; size = 4
tv1190 = -44						; size = 4
tv1189 = -44						; size = 4
tv1238 = -40						; size = 4
tv1208 = -40						; size = 4
tv1092 = -36						; size = 4
tv1861 = -32						; size = 4
tv303 = -32						; size = 4
tv1193 = -28						; size = 4
_new_e$ = -24						; size = 4
tv1137 = -20						; size = 4
tv1682 = -16						; size = 4
tv1196 = -16						; size = 4
_si$ = -12						; size = 4
_sj$ = -8						; size = 4
_side$ = -4						; size = 4
_v_id$ = 8						; size = 4
_edges$ = 12						; size = 4
_poponest PROC						; COMDAT

; 81   : { edge_id e_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi

; 82   :   int i,j;
; 83   :   vertex_id new_v;
; 84   :   edge_id new_e;
; 85   :   facetedge_id fe_id;
; 86   :   REAL cosine,maxcos;
; 87   :   REAL *x;
; 88   :   int si=0,sj=0;
; 89   :   struct side_x { edge_id e_id;    /* which edge */
; 90   :                 REAL vec[MAXCOORD];  /* side vector, from vertex */
; 91   :                 REAL norm;     /* length of side              */
; 92   :               } *side;
; 93   : 
; 94   :   if ( valid_id ( get_vertex_fe(v_id) ) )

	mov	edi, DWORD PTR _v_id$[ebp]
	xor	esi, esi
	push	edi
	mov	DWORD PTR _si$[ebp], esi
	mov	DWORD PTR _sj$[ebp], esi
	call	_get_vertex_fe
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN31@poponest

; 95   :       return new_popverst(v_id,edges);

	mov	eax, DWORD PTR _edges$[ebp]
	push	eax
	push	edi
	call	_new_popverst
	add	esp, 8
	pop	edi
	pop	esi

; 210  : } // end poponest()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@poponest:
	push	ebx

; 96   :  
; 97   :   side = (struct side_x *)temp_calloc(sizeof(struct side_x),edges);

	mov	ebx, DWORD PTR _edges$[ebp]
	push	97					; 00000061H
	push	OFFSET ??_C@_0L@BJPEFIAD@VERPOPST?4C?$AA@
	push	ebx
	push	64					; 00000040H
	call	_kb_temp_calloc

; 98   :   
; 99   :   /* get edge vectors */
; 100  :   e_id = get_vertex_edge(v_id);

	mov	edx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+edx]
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv1092[ebp], edi
	mov	edi, DWORD PTR [ecx+28]
	mov	DWORD PTR _side$[ebp], eax

; 101  :   for ( i = 0 ; i < edges ; i++ )

	cmp	ebx, esi
	jle	SHORT $LN112@poponest

; 96   :  
; 97   :   side = (struct side_x *)temp_calloc(sizeof(struct side_x),edges);

	lea	esi, DWORD PTR [eax+8]
	mov	DWORD PTR tv303[ebp], ebx
$LL30@poponest:

; 102  :   { 
; 103  :     side[i].e_id = e_id;
; 104  :     get_edge_tail_tangent(e_id,side[i].vec);

	push	esi
	push	edi
	mov	DWORD PTR [esi-8], edi
	call	_get_edge_tail_tangent

; 105  :     side[i].norm = sqrt(SDIM_dot(side[i].vec,side[i].vec));

	mov	edx, DWORD PTR _web+616
	push	edx
	push	esi
	push	esi
	call	_dot
	add	esp, 20					; 00000014H
	call	__CIsqrt
	fstp	QWORD PTR [esi+48]

; 106  :     e_id = get_next_tail_edge(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	eax, edi
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edi*4]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	edi, DWORD PTR [edx+eax*4+32]
	add	esi, 64					; 00000040H
	dec	DWORD PTR tv303[ebp]
	jne	SHORT $LL30@poponest
$LN112@poponest:

; 107  :   }
; 108  : 
; 109  :   while ( edges > 3 )

	cmp	ebx, 3
	jle	$LN26@poponest
	mov	eax, ebx
	shl	eax, 6
	add	eax, DWORD PTR _side$[ebp]
	mov	DWORD PTR tv1861[ebp], eax
	npad	4
$LL27@poponest:

; 110  :   {
; 111  :     /* find closest pair of edges */
; 112  :     maxcos = -2.0;

	fld	QWORD PTR __real@c000000000000000

; 113  :     for ( i = 0 ; i < edges ; i++ )

	xor	ebx, ebx
	fstp	QWORD PTR _maxcos$[ebp]
	cmp	DWORD PTR _edges$[ebp], ebx
	jle	SHORT $LN23@poponest

; 110  :   {
; 111  :     /* find closest pair of edges */
; 112  :     maxcos = -2.0;

	mov	eax, DWORD PTR _side$[ebp]
	add	eax, 8
	mov	DWORD PTR tv1682[ebp], eax
	npad	7
$LL144@poponest:

; 114  :     {
; 115  :       for ( j = i+1 ; j < edges ; j++ )

	lea	esi, DWORD PTR [ebx+1]
	mov	DWORD PTR tv1119[ebp], esi
	cmp	esi, DWORD PTR _edges$[ebp]
	jge	SHORT $LN24@poponest
	mov	edi, DWORD PTR tv1682[ebp]
	add	edi, 112				; 00000070H
$LL22@poponest:

; 116  :       {
; 117  :         cosine = SDIM_dot(side[i].vec,side[j].vec)/ side[i].norm/side[j].norm;

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR tv1682[ebp]
	push	ecx
	lea	edx, DWORD PTR [edi-48]
	push	edx
	push	eax
	call	_dot
	mov	ecx, DWORD PTR tv1682[ebp]
	fdiv	QWORD PTR [ecx+48]
	add	esp, 12					; 0000000cH
	fdiv	QWORD PTR [edi]

; 118  :         if ( cosine > maxcos )

	fld	QWORD PTR _maxcos$[ebp]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN147@poponest

; 119  :         { 
; 120  :           /* toss in a little randomness if a choice of ways */
; 121  :           /* but big problem if edges not adjacent! */
; 122  :           /*  if ( (maxcos > -0.5) && (rand() & 0x0100) ) continue; */
; 123  :           maxcos = cosine;

	fstp	QWORD PTR _maxcos$[ebp]

; 124  :           si = i; 

	mov	DWORD PTR _si$[ebp], ebx

; 125  :           sj = j;

	mov	DWORD PTR _sj$[ebp], esi
	jmp	SHORT $LN21@poponest
$LN147@poponest:
	fstp	ST(0)
$LN21@poponest:

; 114  :     {
; 115  :       for ( j = i+1 ; j < edges ; j++ )

	inc	esi
	add	edi, 64					; 00000040H
	cmp	esi, DWORD PTR _edges$[ebp]
	jl	SHORT $LL22@poponest
$LN24@poponest:

; 113  :     for ( i = 0 ; i < edges ; i++ )

	mov	ebx, DWORD PTR tv1119[ebp]
	add	DWORD PTR tv1682[ebp], 64		; 00000040H
	cmp	ebx, DWORD PTR _edges$[ebp]
	jl	SHORT $LL144@poponest
$LN23@poponest:

; 126  :         }
; 127  :       }
; 128  :     }
; 129  : 
; 130  :     /* split off edges si and sj */
; 131  :     new_v = dup_vertex(v_id);  /* new vertex in same spot */

	mov	edi, DWORD PTR _v_id$[ebp]
	push	edi
	call	_dup_vertex
	mov	esi, eax

; 132  :     new_e = new_edge(v_id,new_v,NULLID);

	push	0
	push	esi
	push	edi
	mov	DWORD PTR _new_v$[ebp], esi
	call	_new_edge

; 133  :     set_edge_color(new_e,BLACK);

	mov	edx, DWORD PTR _web+124

; 134  :     remove_vertex_edge(v_id,side[si].e_id);

	mov	ebx, DWORD PTR _si$[ebp]
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	DWORD PTR _new_e$[ebp], eax
	mov	eax, DWORD PTR [edi+edx]
	mov	edx, DWORD PTR _v_id$[ebp]
	xor	ecx, ecx
	shl	ebx, 6
	add	ebx, DWORD PTR _side$[ebp]
	mov	WORD PTR [eax+56], cx
	mov	ecx, DWORD PTR [ebx]
	push	ecx
	push	edx
	mov	DWORD PTR tv1137[ebp], edi
	call	_remove_vertex_edge

; 135  :     set_edge_tailv(side[si].e_id,new_v);

	mov	eax, DWORD PTR [ebx]
	push	esi
	push	eax
	call	_set_edge_tailv

; 136  :     remove_vertex_edge(v_id,side[sj].e_id);

	mov	ebx, DWORD PTR _sj$[ebp]
	mov	ecx, DWORD PTR _v_id$[ebp]
	shl	ebx, 6
	add	ebx, DWORD PTR _side$[ebp]
	mov	eax, DWORD PTR [ebx]
	push	eax
	push	ecx
	call	_remove_vertex_edge

; 137  :     set_edge_tailv(side[sj].e_id,new_v);

	mov	edx, DWORD PTR [ebx]
	push	esi
	push	edx
	call	_set_edge_tailv

; 138  :     if ( get_vattr(v_id) & BOUNDARY )

	mov	ecx, DWORD PTR tv1092[ebp]
	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	add	esp, 48					; 00000030H
	or	eax, ecx
	je	SHORT $LN140@poponest

; 139  :          set_edge_boundary_num(new_e,get_edge_boundary(v_id)->num);

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN140@poponest
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edx, DWORD PTR tv1092[ebp]
	mov	edx, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR [edx+eax]
	mov	ebx, DWORD PTR _web+776
	imul	edx, 136				; 00000088H
	mov	ecx, DWORD PTR [edi+ecx]
	mov	edx, DWORD PTR [edx+ebx+44]
	mov	DWORD PTR [eax+ecx], edx
$LN140@poponest:
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR _si$[ebp]
	npad	5
$LL17@poponest:

; 140  :         
; 141  :     /* take care of facet incidences, assuming plane configuration */
; 142  :     do
; 143  :     { facetedge_id first_fe;
; 144  :       fe_id = first_fe = get_edge_fe(side[si].e_id);

	mov	ecx, DWORD PTR _side$[ebp]
	mov	ebx, DWORD PTR _web+124
	shl	eax, 6
	mov	eax, DWORD PTR [eax+ecx]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	test	ecx, ecx
	jne	SHORT $LN41@poponest
	xor	eax, eax
	mov	DWORD PTR _first_fe$89121[ebp], eax
	jmp	SHORT $LN42@poponest
$LN41@poponest:
	mov	ecx, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN40@poponest
	xor	ecx, 134217728				; 08000000H
$LN40@poponest:
	mov	eax, ecx
	mov	DWORD PTR _first_fe$89121[ebp], ecx
$LN42@poponest:
	mov	ebx, eax

; 145  :       if ( valid_id(fe_id) )

	shr	eax, 28					; 0000001cH
	mov	DWORD PTR tv1189[ebp], eax
	test	al, 1
	je	$LN11@poponest
	mov	eax, DWORD PTR _sj$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _side$[ebp]
	mov	DWORD PTR tv1148[ebp], eax
$LL13@poponest:

; 146  :       do
; 147  :       {
; 148  :         edge_id next_e;
; 149  :         facetedge_id next_fe,new_fe,other_fe;
; 150  :         facet_id f_id;
; 151  :                   
; 152  :         /* see if this facet got split */
; 153  :         next_fe = get_prev_edge(fe_id);

	mov	eax, ebx
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv1193[ebp], eax
	mov	eax, ebx
	je	SHORT $LN45@poponest
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1196[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	mov	edi, DWORD PTR [eax+32]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN44@poponest
$LN45@poponest:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1196[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	mov	edi, DWORD PTR [eax+28]
$LN44@poponest:

; 154  :         next_e = get_fe_edge(next_fe);

	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR tv1208[ebp], ecx
	mov	ecx, DWORD PTR [ecx+edx]
	mov	esi, edi
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [ecx+20]

; 155  :         if ( equal_id(inverse_id(side[sj].e_id),next_e) ) goto loopbottom;

	mov	ecx, DWORD PTR tv1148[ebp]
	mov	ecx, DWORD PTR [ecx]
	xor	ecx, 134217728				; 08000000H
	cmp	ecx, esi
	je	$loopbottom$89133

; 156  :           
; 157  :         /* install new facetedge */
; 158  :         f_id = get_fe_facet(fe_id);

	mov	ecx, DWORD PTR tv1189[ebp]
	and	ecx, 1
	mov	DWORD PTR tv1190[ebp], ecx
	jne	SHORT $LN51@poponest
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN50@poponest
$LN51@poponest:
	cmp	DWORD PTR tv1193[ebp], 0
	mov	eax, DWORD PTR [eax+24]
	je	SHORT $LN50@poponest
	xor	eax, 134217728				; 08000000H
$LN50@poponest:

; 159  :         new_fe = new_facetedge(f_id,new_e);

	mov	edx, DWORD PTR _new_e$[ebp]
	push	edx
	push	eax
	call	_new_facetedge
	add	esp, 8

; 160  :         set_prev_edge(fe_id,new_fe);

	cmp	DWORD PTR tv1190[ebp], 0
	mov	esi, eax
	je	SHORT $LN134@poponest
	cmp	DWORD PTR tv1193[ebp], 0
	je	SHORT $LN55@poponest
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR tv1196[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR [ecx+32], eax
	jmp	SHORT $LN54@poponest
$LN55@poponest:
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR tv1196[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR [ecx+28], esi
$LN54@poponest:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN134@poponest:

; 161  :         set_next_edge(next_fe,new_fe);

	test	edi, 268435456				; 10000000H
	je	SHORT $LN135@poponest
	test	edi, 134217728				; 08000000H
	je	SHORT $LN60@poponest
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR tv1208[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [eax+28], edx
	jmp	SHORT $LN135@poponest
$LN60@poponest:
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR tv1208[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR [eax+32], esi
$LN135@poponest:

; 162  :         set_prev_edge(new_fe,next_fe);

	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv1238[ebp], eax
	je	SHORT $LN136@poponest
	test	esi, 134217728				; 08000000H
	je	SHORT $LN65@poponest
	mov	edx, DWORD PTR _web+460
	xor	edi, 134217728				; 08000000H
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+32], edi
	jmp	SHORT $LN64@poponest
$LN65@poponest:
	mov	ecx, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edx+28], edi
$LN64@poponest:
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
$LN136@poponest:

; 163  :         set_next_edge(new_fe,fe_id);

	test	eax, eax
	je	SHORT $LN69@poponest
	mov	ecx, DWORD PTR _web+460
	mov	eax, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN70@poponest
	xor	ebx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+28], ebx
	jmp	SHORT $LN69@poponest
$LN70@poponest:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+32], ebx
$LN69@poponest:

; 164  :         other_fe = get_edge_fe(new_e);

	mov	edi, DWORD PTR _new_e$[ebp]
	push	edi
	call	_get_edge_fe
	add	esp, 4

; 165  :         if ( valid_id(other_fe) )

	test	eax, 268435456				; 10000000H
	je	$LN9@poponest

; 166  :            {
; 167  :               set_next_facet(new_fe,other_fe);

	mov	ecx, DWORD PTR tv1238[ebp]
	test	ecx, ecx
	je	$LN138@poponest
	test	esi, 134217728				; 08000000H
	je	SHORT $LN75@poponest
	mov	ebx, DWORD PTR _web+460
	mov	edx, eax
	xor	edx, 134217728				; 08000000H
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [edi+36], edx
	jmp	SHORT $LN137@poponest
$LN75@poponest:
	mov	edi, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [edx+40], eax
$LN137@poponest:

; 168  :               set_prev_facet(new_fe,other_fe);

	test	ecx, ecx
	je	SHORT $LN138@poponest
	test	esi, 134217728				; 08000000H
	je	SHORT $LN80@poponest
	mov	edi, DWORD PTR _web+460
	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [edx+40], ecx
	jmp	SHORT $LN79@poponest
$LN80@poponest:
	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+36], eax
$LN79@poponest:
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
$LN138@poponest:

; 169  :               set_prev_facet(other_fe,new_fe);

	mov	ecx, eax
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	shr	ecx, 27					; 0000001bH
	add	eax, eax
	and	ecx, 1
	je	SHORT $LN85@poponest
	mov	edi, DWORD PTR _web+460
	mov	edi, DWORD PTR [eax+edi]
	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [edi+40], edx
	jmp	SHORT $LN84@poponest
$LN85@poponest:
	mov	edx, DWORD PTR _web+460
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [edx+36], esi
$LN84@poponest:
	mov	edx, DWORD PTR _global_timestamp
	inc	edx

; 170  :               set_next_facet(other_fe,new_fe);

	test	ecx, ecx
	mov	ecx, DWORD PTR _web+460
	mov	DWORD PTR _global_timestamp, edx
	mov	DWORD PTR _top_timestamp, edx
	mov	edx, DWORD PTR [eax+ecx]
	je	SHORT $LN90@poponest
	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR [edx+36], esi
	jmp	$LN132@poponest
$LN90@poponest:
	mov	DWORD PTR [edx+40], esi

; 171  :            }
; 172  :         else

	jmp	$LN132@poponest
$LN9@poponest:

; 173  :            {
; 174  :               set_edge_fe(new_e,new_fe);

	mov	eax, esi
	test	edi, 134217728				; 08000000H
	je	SHORT $LN94@poponest
	xor	eax, 134217728				; 08000000H
$LN94@poponest:
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv1137[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 175  :               set_next_facet(new_fe,new_fe);

	mov	eax, DWORD PTR tv1238[ebp]
	test	eax, eax
	je	SHORT $LN132@poponest
	mov	edx, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN98@poponest
	mov	edi, DWORD PTR _web+460
	xor	edx, 134217728				; 08000000H
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [ecx+36], edx
	jmp	SHORT $LN139@poponest
$LN98@poponest:
	mov	ecx, DWORD PTR _web+460
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edx+40], esi
$LN139@poponest:

; 176  :               set_prev_facet(new_fe,new_fe);

	test	eax, eax
	je	SHORT $LN132@poponest
	mov	ecx, DWORD PTR _web+460
	mov	eax, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN103@poponest
	xor	eax, 134217728				; 08000000H
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [edx+40], eax
	jmp	SHORT $LN102@poponest
$LN103@poponest:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+36], esi
$LN102@poponest:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN132@poponest:

; 171  :            }
; 172  :         else

	mov	edx, DWORD PTR _web+460
$loopbottom$89133:

; 177  :            }
; 178  : loopbottom:
; 179  :         fe_id = get_next_facet(fe_id);

	cmp	DWORD PTR tv1193[ebp], 0
	mov	eax, DWORD PTR tv1196[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	je	SHORT $LN108@poponest
	mov	ebx, DWORD PTR [ecx+36]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN12@poponest
$LN108@poponest:
	mov	ebx, DWORD PTR [ecx+40]
$LN12@poponest:

; 180  :       } while ( valid_id(fe_id) && !equal_id(fe_id,first_fe) );

	mov	eax, ebx
	shr	eax, 28					; 0000001cH
	mov	DWORD PTR tv1189[ebp], eax
	test	al, 1
	je	SHORT $LN7@poponest
	cmp	ebx, DWORD PTR _first_fe$89121[ebp]
	jne	$LL13@poponest
$LN7@poponest:
	mov	esi, DWORD PTR _new_v$[ebp]
	mov	edi, DWORD PTR tv1137[ebp]
$LN11@poponest:

; 181  :       /* swap roles of sj and si */         
; 182  :       i = sj; sj = si; si = i;

	mov	eax, DWORD PTR _sj$[ebp]
	mov	ecx, DWORD PTR _si$[ebp]
	mov	DWORD PTR _sj$[ebp], ecx
	mov	DWORD PTR _si$[ebp], eax

; 183  :     }
; 184  :     while ( sj < si ); /* exit when swapped back */

	cmp	ecx, eax
	jl	$LL17@poponest

; 185  : 
; 186  :     /* adjust edge list for another round, if necessary */
; 187  :     /* direction of new edge is average of old two */
; 188  :     /* Also move new vertex a little ways away to avoid zero edge */
; 189  :     edges --;
; 190  :     x = get_coord(new_v);

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	dec	DWORD PTR _edges$[ebp]
	sub	DWORD PTR tv1861[ebp], 64		; 00000040H

; 191  :     for ( i = 0 ; i < SDIM ; i++ )

	mov	ebx, DWORD PTR _side$[ebp]
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+esi*4]
	add	esi, DWORD PTR [eax+ecx+64]
	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN4@poponest
	mov	edx, DWORD PTR _si$[ebp]
	fld	QWORD PTR __real@3eb0c6f7a0b5ed8d
	mov	edi, DWORD PTR _sj$[ebp]
	shl	edx, 6
	shl	edi, 6
	lea	ecx, DWORD PTR [edx+ebx+8]
	lea	edi, DWORD PTR [edi+ebx+8]
$LN142@poponest:

; 192  :     {
; 193  :       side[si].vec[i] = side[si].vec[i]/side[si].norm 
; 194  :                                     + side[sj].vec[i]/side[si].norm;

	fld	QWORD PTR [ecx]
	inc	eax
	fdiv	QWORD PTR [edx+ebx+56]
	add	edi, 8
	add	ecx, 8
	fld	QWORD PTR [edi-8]
	fdiv	QWORD PTR [edx+ebx+56]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [ecx-8]

; 195  :       x[i] += 0.000001 * side[si].vec[i];

	fmul	ST(0), ST(1)
	fadd	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN142@poponest

; 191  :     for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR tv1137[ebp]
	fstp	ST(0)
$LN4@poponest:

; 196  :     }
; 197  :     side[si].norm = sqrt(SDIM_dot(side[si].vec,side[si].vec)); 

	mov	eax, DWORD PTR _si$[ebp]
	mov	ecx, DWORD PTR _web+616
	shl	eax, 6
	add	ebx, eax
	lea	eax, DWORD PTR [ebx+8]
	push	ecx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fstp	QWORD PTR [ebx+56]

; 198  :     side[si].e_id = new_e;
; 199  :     if ( sj < edges ) /* trim top of list */

	mov	eax, DWORD PTR _edges$[ebp]
	mov	edx, DWORD PTR _new_e$[ebp]
	mov	DWORD PTR [ebx], edx
	cmp	DWORD PTR _sj$[ebp], eax
	jge	SHORT $LN3@poponest

; 200  :         side[sj] = side[edges];

	mov	edi, DWORD PTR _sj$[ebp]
	mov	esi, DWORD PTR tv1861[ebp]
	shl	edi, 6
	add	edi, DWORD PTR _side$[ebp]
	mov	ecx, 16					; 00000010H
	rep movsd
	mov	edi, DWORD PTR tv1137[ebp]
$LN3@poponest:

; 201  : 
; 202  :     if ( phase_flag && (web.representation == STRING) )

	cmp	DWORD PTR _phase_flag, 0
	je	SHORT $LN2@poponest
	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN2@poponest

; 203  :        set_e_phase_density(new_e);

	mov	ecx, DWORD PTR _new_e$[ebp]
	push	ecx
	call	_set_e_phase_density
	add	esp, 4

; 204  :     else          

	jmp	SHORT $LN1@poponest
$LN2@poponest:

; 205  :        set_edge_density(new_e,(get_edge_density(side[si].e_id)
; 206  :            + get_edge_density(side[sj].e_id))/2);

	mov	edx, DWORD PTR _sj$[ebp]
	mov	eax, DWORD PTR _side$[ebp]
	shl	edx, 6
	mov	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [ebx]
	fld	QWORD PTR [edx+40]
	mov	edx, DWORD PTR [edi+eax]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	fadd	QWORD PTR [ecx+40]
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [edx+40]
$LN1@poponest:

; 107  :   }
; 108  : 
; 109  :   while ( edges > 3 )

	cmp	DWORD PTR _edges$[ebp], 3
	jg	$LL27@poponest
$LN26@poponest:

; 207  :   }
; 208  :   temp_free((char *)side);

	mov	eax, DWORD PTR _side$[ebp]
	push	eax
	call	_temp_free
	add	esp, 4
	pop	ebx
	pop	edi

; 209  :   return 1;

	mov	eax, 1
	pop	esi

; 210  : } // end poponest()

	mov	esp, ebp
	pop	ebp
	ret	0
_poponest ENDP
_TEXT	ENDS
PUBLIC	_verpop_str
EXTRN	_calc_energy:PROC
EXTRN	_calc_pressure:PROC
EXTRN	_calc_content:PROC
EXTRN	_dissolve_vertex:PROC
; Function compile flags: /Ogtp
;	COMDAT _verpop_str
_TEXT	SEGMENT
_verpop_str PROC					; COMDAT

; 32   : { vertex_id v_id;

	push	ebx
	push	edi

; 33   :   int popcount = 0;
; 34   : 
; 35   :   FOR_ALL_VERTICES(v_id)

	mov	edi, DWORD PTR _web+48
	xor	ebx, ebx
	test	edi, 268435456				; 10000000H
	je	$LN17@verpop_str
	push	esi
	npad	9
$LL20@verpop_str:
	mov	eax, DWORD PTR _web+12
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN10@verpop_str

; 36   :   { int valence = get_vertex_evalence(v_id);

	push	edi
	call	_get_vertex_evalence
	add	esp, 4

; 37   :     if ( valence == 0 ) popcount += dissolve_vertex(v_id);

	test	eax, eax
	jne	SHORT $LN6@verpop_str
	push	edi
	call	_dissolve_vertex
	add	esp, 4
	jmp	SHORT $LN21@verpop_str
$LN6@verpop_str:

; 38   :     else  if ( valence > 3 ) 

	cmp	eax, 3

; 39   :        popcount += poponest(v_id,valence);

	jg	SHORT $LN22@verpop_str

; 40   :     else if ( (valence >= 2) && (get_vattr(v_id) & (CONSTRAINT|BOUNDARY)) )

	cmp	eax, 2
	jl	SHORT $LN10@verpop_str
	mov	ecx, DWORD PTR _web+12
	mov	ecx, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1152				; 00000480H
	xor	edx, edx
	or	ecx, edx
	je	SHORT $LN10@verpop_str
$LN22@verpop_str:

; 41   :        popcount += poponest(v_id,valence);

	push	eax
	push	edi
	call	_poponest
	add	esp, 8
$LN21@verpop_str:
	add	ebx, eax
$LN10@verpop_str:

; 33   :   int popcount = 0;
; 34   : 
; 35   :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [esi+edx]
	mov	edi, DWORD PTR [eax]
	test	edi, 268435456				; 10000000H
	jne	SHORT $LL20@verpop_str

; 42   :   } 
; 43   :   
; 44   :   if ( popcount )

	pop	esi
	test	ebx, ebx
	je	SHORT $LN17@verpop_str

; 45   :   { calc_content(Q_FIXED);

	push	2
	call	_calc_content
	fstp	ST(0)
	add	esp, 4

; 46   :     calc_pressure();

	call	_calc_pressure

; 47   :     calc_energy();

	call	_calc_energy
$LN17@verpop_str:

; 48   :   }
; 49   : 
; 50   :   return popcount;

	pop	edi
	mov	eax, ebx
	pop	ebx

; 51   : } // end verpop_str()

	ret	0
_verpop_str ENDP
_TEXT	ENDS
PUBLIC	_pop_string_vertex
; Function compile flags: /Ogtp
;	COMDAT _pop_string_vertex
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_pop_string_vertex PROC					; COMDAT

; 60   : { int valence = get_vertex_evalence(v_id);

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _v_id$[ebp]
	push	esi
	call	_get_vertex_evalence
	mov	edx, eax
	add	esp, 4

; 61   :   int popcount = 0;

	xor	eax, eax

; 62   :   if ( valence == 0 ) popcount = dissolve_vertex(v_id);

	test	edx, edx
	jne	SHORT $LN5@pop_string
	push	esi
	call	_dissolve_vertex
	add	esp, 4
	pop	esi

; 67   :   return popcount;
; 68   : } // end pop_string_vertex()

	pop	ebp
	ret	0
$LN5@pop_string:

; 63   :   else  if ( valence > 3 ) 

	cmp	edx, 3

; 64   :      popcount = poponest(v_id,valence);

	jg	SHORT $LN10@pop_string

; 65   :   else if ( (valence >= 2) && (get_vattr(v_id) & (CONSTRAINT|BOUNDARY)) )

	cmp	edx, 2
	jl	SHORT $LN1@pop_string
	push	edi
	mov	edi, DWORD PTR _web+12
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+8]
	xor	edi, edi
	and	ecx, 1152				; 00000480H
	or	ecx, edi
	pop	edi
	je	SHORT $LN1@pop_string
$LN10@pop_string:

; 66   :      popcount = poponest(v_id,valence); 

	push	edx
	push	esi
	call	_poponest
	add	esp, 8
$LN1@pop_string:
	pop	esi

; 67   :   return popcount;
; 68   : } // end pop_string_vertex()

	pop	ebp
	ret	0
_pop_string_vertex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@LGKEIHC@Autopopped?5?$CFd?5edges?0?5?$CFd?5vertices@ ; `string'
PUBLIC	_autopop_pop
EXTRN	_free_discards:PROC
EXTRN	_popfilm:PROC
;	COMDAT ??_C@_0CD@LGKEIHC@Autopopped?5?$CFd?5edges?0?5?$CFd?5vertices@
CONST	SEGMENT
??_C@_0CD@LGKEIHC@Autopopped?5?$CFd?5edges?0?5?$CFd?5vertices@ DB 'Autopo'
	DB	'pped %d edges, %d vertices.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _autopop_pop
_TEXT	SEGMENT
_autopop_pop PROC					; COMDAT

; 1110 : {

	push	edi

; 1111 :   int k;
; 1112 :   int popped = 0;

	xor	edi, edi

; 1113 : 
; 1114 : #ifdef MPI_EVOLVER
; 1115 :   if ( this_task == MASTER_TASK )
; 1116 :   { mpi_autopop_pop();
; 1117 :     return;
; 1118 :   }
; 1119 : #endif
; 1120 : 
; 1121 :   if ( autopop_list == NULL ) return;

	cmp	DWORD PTR _autopop_list, edi
	je	$LN13@autopop_po

; 1122 : 
; 1123 : #ifdef MPI_EVOLVER
; 1124 :   if ( this_task != MASTER_TASK )
; 1125 :     mpi_delete_init();
; 1126 : #endif
; 1127 :  
; 1128 :   for ( k = 0 ; k < autopop_count ; k++ )

	push	esi
	xor	esi, esi
	cmp	DWORD PTR _autopop_count, esi
	jle	SHORT $LN9@autopop_po
	npad	6
$LL18@autopop_po:

; 1129 :   { if ( id_type(autopop_list[k]) == EDGE ) 

	mov	eax, DWORD PTR _autopop_list
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	edx, ecx
	and	edx, -536870912				; e0000000H
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN8@autopop_po

; 1130 :     { if ((get_eattr(autopop_list[k])&ALLOCATED) && 
; 1131 :                          delete_edge(autopop_list[k]))

	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN10@autopop_po
	push	ecx
	call	_delete_edge
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@autopop_po

; 1132 :         free_element(autopop_list[k]);

	mov	eax, DWORD PTR _autopop_list
	mov	ecx, DWORD PTR [eax+esi*4]
	push	ecx
	call	_free_element

; 1133 :     }
; 1134 :     else

	jmp	SHORT $LN19@autopop_po
$LN8@autopop_po:

; 1135 :       delete_facet(autopop_list[k]);

	push	ecx
	call	_delete_facet
$LN19@autopop_po:
	add	esp, 4
$LN10@autopop_po:

; 1122 : 
; 1123 : #ifdef MPI_EVOLVER
; 1124 :   if ( this_task != MASTER_TASK )
; 1125 :     mpi_delete_init();
; 1126 : #endif
; 1127 :  
; 1128 :   for ( k = 0 ; k < autopop_count ; k++ )

	inc	esi
	cmp	esi, DWORD PTR _autopop_count
	jl	SHORT $LL18@autopop_po
$LN9@autopop_po:
	pop	esi

; 1136 :   }
; 1137 :   if ( autopop_count )

	cmp	DWORD PTR _autopop_count, edi
	je	SHORT $LN3@autopop_po

; 1138 :   {
; 1139 :     if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN4@autopop_po

; 1140 :       popped = verpop_str();

	call	_verpop_str

; 1141 :     else 

	jmp	SHORT $LN20@autopop_po
$LN4@autopop_po:

; 1142 :       popped = popfilm();

	call	_popfilm
$LN20@autopop_po:
	mov	edi, eax
$LN3@autopop_po:

; 1143 :   }
; 1144 :   
; 1145 :   if ( (autopop_count > 0) || (popped > 0) )

	mov	eax, DWORD PTR _autopop_count
	test	eax, eax
	jg	SHORT $LN1@autopop_po
	test	edi, edi
	jle	SHORT $LN2@autopop_po
$LN1@autopop_po:

; 1146 :   { sprintf(msg,"Autopopped %d edges, %d vertices.\n",autopop_count,popped);

	mov	edx, DWORD PTR _msg
	push	edi
	push	eax
	push	OFFSET ??_C@_0CD@LGKEIHC@Autopopped?5?$CFd?5edges?0?5?$CFd?5vertices@
	push	edx
	call	_sprintf

; 1147 :     outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H
$LN2@autopop_po:

; 1148 :   }
; 1149 : 
; 1150 :   temp_free((char *)autopop_list);

	mov	ecx, DWORD PTR _autopop_list
	push	ecx
	call	_temp_free

; 1151 :   autopop_list = NULL;
; 1152 :   autopop_count = 0;
; 1153 : 
; 1154 : #ifdef MPI_EVOLVER
; 1155 :   if ( this_task != MASTER_TASK )
; 1156 :     mpi_task_delete_wrapup();
; 1157 : #endif
; 1158 : 
; 1159 :   free_discards(DISCARDS_SOME); /* prevents auto pileup */

	push	2
	mov	DWORD PTR _autopop_list, 0
	mov	DWORD PTR _autopop_count, 0
	call	_free_discards
	add	esp, 8
$LN13@autopop_po:
	pop	edi

; 1160 : 
; 1161 : } // end autopop_pop()

	ret	0
_autopop_pop ENDP
_TEXT	ENDS
END
