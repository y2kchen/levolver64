; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\FIXVOL.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@BIDJLEFG@__vgrad_head?$AA@		; `string'
PUBLIC	_vpressures
PUBLIC	_vgev
PUBLIC	_vgef
PUBLIC	_vgrad_attr_name
_DATA	SEGMENT
COMM	_vgrad_attr:DWORD
_DATA	ENDS
_BSS	SEGMENT
_vpressures DD	01H DUP (?)
_fixcount DD	01H DUP (?)
_vgev	DD	01H DUP (?)
_vgef	DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_vgrad_attr_name DD FLAT:??_C@_0N@BIDJLEFG@__vgrad_head?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0N@BIDJLEFG@__vgrad_head?$AA@
CONST	SEGMENT
??_C@_0N@BIDJLEFG@__vgrad_head?$AA@ DB '__vgrad_head', 00H ; `string'
CONST	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_get_body_volume
EXTRN	_web:BYTE
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_body_volume
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volume PROC					; COMDAT

; 308  :     { return    ( valid_id(b_id) ?  bptr(b_id)->volume : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]
	pop	ebp
	ret	0
$LN3@get_body_v:
	fldz
	pop	ebp
	ret	0
_get_body_volume ENDP
_TEXT	ENDS
PUBLIC	_get_body_fixvol
; Function compile flags: /Ogtp
;	COMDAT _get_body_fixvol
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_fixvol PROC					; COMDAT

; 311  :      { return ( valid_id(b_id) ?  bptr(b_id)->fixvol : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+32]
	pop	ebp
	ret	0
$LN3@get_body_f:
	fldz
	pop	ebp
	ret	0
_get_body_fixvol ENDP
_TEXT	ENDS
PUBLIC	_get_body_pressure
; Function compile flags: /Ogtp
;	COMDAT _get_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_pressure PROC					; COMDAT

; 317  :     { return  ( valid_id(b_id) ?    bptr(b_id)->pressure : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_p
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+312]
	pop	ebp
	ret	0
$LN3@get_body_p:
	fldz
	pop	ebp
	ret	0
_get_body_pressure ENDP
_TEXT	ENDS
PUBLIC	_set_body_pressure
; Function compile flags: /Ogtp
;	COMDAT _set_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_pressure PROC					; COMDAT

; 326  :       {         ( valid_id(b_id) ?  bptr(b_id)->pressure = (v) : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@set_body_p
	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+312]
$LN3@set_body_p:
	pop	ebp
	ret	0
_set_body_pressure ENDP
_TEXT	ENDS
PUBLIC	_get_extra
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_extra
_TEXT	SEGMENT
_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_extra PROC						; COMDAT

; 348  : { int type = id_type(id);

	push	ebp
	mov	ebp, esp

; 349  : 
; 350  :   return ( (char*)elptr(id) + EXTRAS(type)[n].offset);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	shr	eax, 29					; 0000001dH
	imul	esi, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, esi
	add	eax, DWORD PTR [edi+ecx+64]
	pop	edi
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_get_extra ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@CPCLBIBP@find_fixed?$CI?$CJ?3?5count?5fixed?5bodies@ ; `string'
PUBLIC	_find_fixed
EXTRN	_fixed_constraint_flag:DWORD
EXTRN	_gen_quant_list:DWORD
EXTRN	_everything_quantities_flag:DWORD
EXTRN	_outstring:PROC
EXTRN	_itdebug:DWORD
_BSS	SEGMENT
_maxquants DD	01H DUP (?)
_gen_quant_start DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DC@CPCLBIBP@find_fixed?$CI?$CJ?3?5count?5fixed?5bodies@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\fixvol.c
CONST	SEGMENT
??_C@_0DC@CPCLBIBP@find_fixed?$CI?$CJ?3?5count?5fixed?5bodies@ DB 'find_f'
	DB	'ixed(): count fixed bodies and constraints', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _find_fixed
_TEXT	SEGMENT
tv268 = -12						; size = 8
_redundant_bi$ = -4					; size = 4
_find_fixed PROC					; COMDAT

; 524  : { int i,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 525  :   struct gen_quant *q;
; 526  :   int redundant_bi = -1; /* for torus_filled */
; 527  :   body_id b_id;
; 528  : 
; 529  :   if ( itdebug ) 

	cmp	DWORD PTR _itdebug, 0
	mov	DWORD PTR _redundant_bi$[ebp], -1
	je	SHORT $LN19@find_fixed

; 530  :       outstring("find_fixed(): count fixed bodies and constraints\n");

	push	OFFSET ??_C@_0DC@CPCLBIBP@find_fixed?$CI?$CJ?3?5count?5fixed?5bodies@
	call	_outstring
	add	esp, 4
$LN19@find_fixed:

; 531  : 
; 532  :   /* figure out which quantities are fixed */
; 533  :   fixcount = 0;

	push	ebx
	xor	ebx, ebx
	push	esi
	push	edi
	mov	DWORD PTR _fixcount, ebx

; 534  :   if ( !everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, ebx
	jne	SHORT $LN15@find_fixed

; 535  :   { MFOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR _web+384
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN15@find_fixed
$LL17@find_fixed:
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	lea	eax, DWORD PTR [ecx+ecx]
	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [edx+12]
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR tv268[ebp+4], ecx
	mov	ecx, esi
	and	ecx, 1
	xor	edi, edi
	or	ecx, edi
	je	SHORT $LN16@find_fixed

; 536  :       { if ( get_battr(b_id) & (FIXEDVOL/*|PRESSURE*/) ) 

	and	esi, 32					; 00000020H
	xor	ecx, ecx
	or	esi, ecx
	je	SHORT $LN12@find_fixed

; 537  :         { if ( web.full_flag && (redundant_bi < 0) )

	cmp	DWORD PTR _web+864, ecx
	je	$LN11@find_fixed
	cmp	DWORD PTR _redundant_bi$[ebp], ecx
	jge	$LN11@find_fixed

; 538  :           { set_body_fixnum(b_id,-1);
; 539  :             redundant_bi = 1;

	mov	DWORD PTR _redundant_bi$[ebp], 1
$LN12@find_fixed:

; 545  :         } 
; 546  :         else set_body_fixnum(b_id,-1);

	mov	DWORD PTR [edx+420], -1
$LN16@find_fixed:

; 535  :   { MFOR_ALL_BODIES(b_id)

	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [eax+edx]
	mov	ecx, DWORD PTR [eax]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL17@find_fixed

; 543  :             fixcount++;

	mov	DWORD PTR _fixcount, ebx
$LN15@find_fixed:

; 547  :       }
; 548  :   }
; 549  : 
; 550  :    for ( i = 0,k=0 ; i < gen_quant_count ; i++ )

	xor	esi, esi
	xor	edi, edi
	cmp	DWORD PTR _web+5528, esi
	jle	SHORT $LN6@find_fixed
	mov	edx, DWORD PTR _gen_quant_list
	xor	ecx, ecx
	npad	8
$LL8@find_fixed:

; 551  :    { q = GEN_QUANT(i);
; 552  :      if ( q->flags & Q_DELETED ) continue;

	mov	eax, DWORD PTR [ecx+edx+136]
	test	eax, 524288				; 00080000H
	jne	SHORT $LN7@find_fixed

; 553  :      if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	test	al, 10					; 0000000aH
	je	SHORT $LN4@find_fixed

; 554  :       { if ( web.full_flag && valid_id(q->b_id) && redundant_bi < 0 )

	cmp	DWORD PTR _web+864, 0
	je	SHORT $LN3@find_fixed
	test	DWORD PTR [ecx+edx+216], 268435456	; 10000000H
	je	SHORT $LN3@find_fixed
	cmp	DWORD PTR _redundant_bi$[ebp], 0
	jge	SHORT $LN3@find_fixed

; 555  :         { q->fixnum = -1; 
; 556  :           redundant_bi = 1;

	mov	DWORD PTR _redundant_bi$[ebp], 1
$LN4@find_fixed:

; 562  :       }
; 563  :       else q->fixnum = -1;

	mov	DWORD PTR [ecx+edx+224], -1
$LN27@find_fixed:
	mov	edx, DWORD PTR _gen_quant_list
$LN7@find_fixed:

; 547  :       }
; 548  :   }
; 549  : 
; 550  :    for ( i = 0,k=0 ; i < gen_quant_count ; i++ )

	inc	esi
	add	ecx, 368				; 00000170H
	cmp	esi, DWORD PTR _web+5528
	jl	SHORT $LL8@find_fixed

; 557  :         }
; 558  :         else
; 559  :         { q->fixnum = fixcount++;

	mov	DWORD PTR _fixcount, ebx
$LN6@find_fixed:

; 564  :    }
; 565  :   gen_quant_start = web.skel[BODY].max_ord + 1;

	mov	eax, DWORD PTR _web+404
	inc	eax
	mov	DWORD PTR _gen_quant_start, eax

; 566  :   maxquants = gen_quant_start + k;

	add	eax, edi
	pop	edi
	mov	DWORD PTR _maxquants, eax
	pop	esi

; 567  :   fixed_constraint_flag = fixcount;

	mov	DWORD PTR _fixed_constraint_flag, ebx

; 568  :   return fixcount;

	mov	eax, ebx
	pop	ebx

; 569  : 
; 570  : } // find_fixed()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@find_fixed:

; 540  :           }
; 541  :           else
; 542  :           { set_body_fixnum(b_id,fixcount);

	mov	DWORD PTR [edx+420], ebx

; 543  :             fixcount++;

	inc	ebx

; 544  :           }

	jmp	$LN16@find_fixed
$LN3@find_fixed:

; 557  :         }
; 558  :         else
; 559  :         { q->fixnum = fixcount++;

	mov	DWORD PTR [ecx+edx+224], ebx
	inc	ebx

; 560  :           k++;

	inc	edi

; 561  :         }

	jmp	SHORT $LN27@find_fixed
_find_fixed ENDP
_TEXT	ENDS
PUBLIC	_vgrad_end
EXTRN	_optparam_congrads:DWORD
EXTRN	_rightside:DWORD
EXTRN	_free_matrix:PROC
EXTRN	_rleftside:DWORD
EXTRN	_free_system:PROC
EXTRN	_sparse_constraints_flag:DWORD
EXTRN	_vgradmax:DWORD
EXTRN	_temp_free:PROC
EXTRN	_vgradlastused:DWORD
EXTRN	_vgradbase:DWORD
EXTRN	_vgradtop:DWORD
EXTRN	_memset:PROC
_BSS	SEGMENT
_LS	DB	0e8H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _vgrad_end
_TEXT	SEGMENT
_vgrad_end PROC						; COMDAT

; 1430 : 
; 1431 :   vgradlastused = vgradtop;

	mov	eax, DWORD PTR _vgradtop
	push	ebx
	push	esi

; 1432 :   for ( block = vgradbase ; block ; block = next )

	mov	esi, DWORD PTR _vgradbase
	xor	ebx, ebx
	mov	DWORD PTR _vgradlastused, eax
	cmp	esi, ebx
	je	SHORT $LN7@vgrad_end
	push	edi
	npad	7
$LL9@vgrad_end:

; 1433 :   { temp_free((char *)block->base);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	_temp_free

; 1434 :     temp_free((char *)block->values);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	_temp_free

; 1435 :     next = block->next;

	mov	edi, DWORD PTR [esi+16]

; 1436 :     temp_free((char *)block);

	push	esi
	call	_temp_free
	add	esp, 12					; 0000000cH
	mov	esi, edi
	cmp	edi, ebx
	jne	SHORT $LL9@vgrad_end
	pop	edi
$LN7@vgrad_end:

; 1437 :   }
; 1438 :   vgradbase = NULL; 

	mov	DWORD PTR _vgradbase, ebx

; 1439 :   
; 1440 :   vgradmax = 0;

	mov	DWORD PTR _vgradmax, ebx

; 1441 :   if ( sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, ebx
	je	SHORT $LN6@vgrad_end

; 1442 :   { free_system(&LS);

	push	OFFSET _LS
	call	_free_system

; 1443 :     memset(&LS,0,sizeof(LS));

	push	232					; 000000e8H
	push	ebx
	push	OFFSET _LS
	call	_memset
	add	esp, 16					; 00000010H

; 1444 :   }
; 1445 :   else

	jmp	SHORT $LN4@vgrad_end
$LN6@vgrad_end:

; 1446 :     if ( rleftside ) free_matrix(rleftside);  rleftside = NULL;

	mov	eax, DWORD PTR _rleftside
	cmp	eax, ebx
	je	SHORT $LN4@vgrad_end
	push	eax
	call	_free_matrix
	add	esp, 4
$LN4@vgrad_end:

; 1447 :   if ( rightside ) temp_free((char *)rightside);  rightside = NULL;

	mov	eax, DWORD PTR _rightside
	mov	DWORD PTR _rleftside, ebx
	cmp	eax, ebx
	je	SHORT $LN3@vgrad_end
	push	eax
	call	_temp_free
	add	esp, 4
$LN3@vgrad_end:

; 1448 :   if ( vpressures ) temp_free((char *)vpressures); vpressures = NULL;

	mov	eax, DWORD PTR _vpressures
	mov	DWORD PTR _rightside, ebx
	cmp	eax, ebx
	je	SHORT $LN2@vgrad_end
	push	eax
	call	_temp_free
	add	esp, 4
$LN2@vgrad_end:

; 1449 :   if ( optparam_congrads ) free_matrix(optparam_congrads);

	mov	eax, DWORD PTR _optparam_congrads
	mov	DWORD PTR _vpressures, ebx
	cmp	eax, ebx
	je	SHORT $LN14@vgrad_end
	push	eax
	call	_free_matrix
	add	esp, 4
$LN14@vgrad_end:

; 1450 :   optparam_congrads = NULL;

	pop	esi
	mov	DWORD PTR _optparam_congrads, ebx
	pop	ebx

; 1451 : 
; 1452 :   #ifdef MPI_EVOLVER
; 1453 :   if ( this_task == 0 )
; 1454 :     mpi_vgrad_end(); 
; 1455 :   #endif
; 1456 : 
; 1457 : } /* end vgrad_end() */

	ret	0
_vgrad_end ENDP
_TEXT	ENDS
PUBLIC	_get_vertex_vgrad
; Function compile flags: /Ogtp
;	COMDAT _get_vertex_vgrad
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_get_vertex_vgrad PROC					; COMDAT

; 1468 : { if ( !vgradbase ) return NULL;

	push	ebp
	mov	ebp, esp
	cmp	DWORD PTR _vgradbase, 0
	jne	SHORT $LN1@get_vertex
	xor	eax, eax

; 1470 : } // end get_vertex_vgrad()

	pop	ebp
	ret	0
$LN1@get_vertex:

; 1469 :   return (volgrad*)VPTR(v_id,vgrad_attr)[0];

	mov	ecx, DWORD PTR _vgrad_attr
	mov	eax, DWORD PTR _v_id$[ebp]
	imul	ecx, 240				; 000000f0H
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	add	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+64]
	mov	eax, DWORD PTR [eax+ecx]

; 1470 : } // end get_vertex_vgrad()

	pop	ebp
	ret	0
_get_vertex_vgrad ENDP
_TEXT	ENDS
PUBLIC	_set_vertex_vgrad
; Function compile flags: /Ogtp
;	COMDAT _set_vertex_vgrad
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_vgptr$ = 12						; size = 4
_set_vertex_vgrad PROC					; COMDAT

; 1483 : {

	push	ebp
	mov	ebp, esp

; 1484 :   VPTR(v_id,vgrad_attr)[0] = (char*)vgptr;

	mov	ecx, DWORD PTR _vgrad_attr
	mov	eax, DWORD PTR _v_id$[ebp]
	imul	ecx, 240				; 000000f0H
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	add	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+64]
	mov	edx, DWORD PTR _vgptr$[ebp]
	mov	DWORD PTR [eax+ecx], edx

; 1485 : } // end set_vertex_vgrad()

	pop	ebp
	ret	0
_set_vertex_vgrad ENDP
_TEXT	ENDS
PUBLIC	??_C@_08KKKHFLBB@FIXVOL?4C?$AA@			; `string'
PUBLIC	_new_vgrad
EXTRN	_myunlock_web:PROC
EXTRN	_one_sided_present:DWORD
EXTRN	_kb_temp_calloc:PROC
EXTRN	_mylock_web:PROC
EXTRN	_threadflag:DWORD
;	COMDAT ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
CONST	SEGMENT
??_C@_08KKKHFLBB@FIXVOL?4C?$AA@ DB 'FIXVOL.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _new_vgrad
_TEXT	SEGMENT
tv315 = -4						; size = 4
_new_vgrad PROC						; COMDAT

; 1498 : { struct volgrad * vg;

	push	ebp
	mov	ebp, esp
	push	ecx

; 1499 :   struct vgradblock *newblock;
; 1500 : 
; 1501 : LOCK_WEB;

	cmp	DWORD PTR _threadflag, 0
	je	SHORT $LN8@new_vgrad
	call	_mylock_web
$LN8@new_vgrad:
	push	esi

; 1502 :   if ( vgradbase->top >= vgradbase->max ) 

	mov	esi, DWORD PTR _vgradbase
	mov	eax, DWORD PTR [esi+12]
	push	edi
	cmp	eax, DWORD PTR [esi+8]
	jl	$LN5@new_vgrad

; 1503 :   { int i,stride;
; 1504 :     /* need new block */
; 1505 :     newblock = (struct vgradblock *)temp_calloc(1,sizeof(struct vgradblock));

	push	1505					; 000005e1H
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	push	20					; 00000014H
	push	1
	call	_kb_temp_calloc
	mov	esi, eax

; 1506 :     newblock->max = vgradtop/3+100;

	mov	eax, 1431655766				; 55555556H
	imul	DWORD PTR _vgradtop

; 1507 :     newblock->base = (volgrad*)temp_calloc(newblock->max,sizeof(volgrad));

	push	1507					; 000005e3H
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	lea	eax, DWORD PTR [edx+ecx+100]
	push	28					; 0000001cH
	push	eax
	mov	DWORD PTR [esi+8], eax
	call	_kb_temp_calloc
	mov	DWORD PTR [esi], eax

; 1508 :     stride = one_sided_present ? 3 : 2;
; 1509 :     newblock->values = (REAL*)temp_calloc(newblock->max,stride*SDIM*sizeof(REAL));

	mov	eax, DWORD PTR _web+616
	xor	edx, edx
	cmp	DWORD PTR _one_sided_present, edx
	mov	ecx, DWORD PTR [esi+8]
	setne	dl
	push	1509					; 000005e5H
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	lea	edi, DWORD PTR [edx+2]
	imul	eax, edi
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	call	_kb_temp_calloc

; 1510 :     for ( i = 0 ; i < newblock->max ; i++ )

	xor	ecx, ecx
	add	esp, 48					; 00000030H
	mov	DWORD PTR [esi+4], eax
	cmp	DWORD PTR [esi+8], ecx
	jle	SHORT $LN2@new_vgrad

; 1503 :   { int i,stride;
; 1504 :     /* need new block */
; 1505 :     newblock = (struct vgradblock *)temp_calloc(1,sizeof(struct vgradblock));

	xor	eax, eax
	mov	DWORD PTR tv315[ebp], 2
	push	ebx
	npad	3
$LL4@new_vgrad:

; 1511 :     { newblock->base[i].grad = newblock->values + stride*i*SDIM;

	mov	edx, DWORD PTR _web+616
	mov	ebx, DWORD PTR [esi+4]
	imul	edx, ecx
	imul	edx, edi
	lea	edx, DWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR [eax+ebx+16], edx

; 1512 :       newblock->base[i].velocity = newblock->values + (stride*i+1)*SDIM;

	mov	edx, DWORD PTR tv315[ebp]
	mov	ebx, DWORD PTR [esi+4]
	dec	edx
	imul	edx, DWORD PTR _web+616
	lea	edx, DWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR [eax+ebx+20], edx

; 1513 :       if ( one_sided_present )

	cmp	DWORD PTR _one_sided_present, 0
	je	SHORT $LN3@new_vgrad

; 1514 :         newblock->base[i].raw_velocity = newblock->values + (stride*i+2)*SDIM;

	mov	edx, DWORD PTR tv315[ebp]
	imul	edx, DWORD PTR _web+616
	mov	ebx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR [eax+ebx+24], edx
$LN3@new_vgrad:

; 1510 :     for ( i = 0 ; i < newblock->max ; i++ )

	add	DWORD PTR tv315[ebp], edi
	inc	ecx
	add	eax, 28					; 0000001cH
	cmp	ecx, DWORD PTR [esi+8]
	jl	SHORT $LL4@new_vgrad
	pop	ebx
$LN2@new_vgrad:

; 1515 :     }
; 1516 :     newblock->top = 0;

	mov	DWORD PTR [esi+12], 0

; 1517 :     newblock->next = vgradbase;

	mov	eax, DWORD PTR _vgradbase
	mov	DWORD PTR [esi+16], eax

; 1518 :     vgradbase = newblock;

	mov	DWORD PTR _vgradbase, esi
$LN5@new_vgrad:

; 1519 :   }
; 1520 : 
; 1521 :   vg = vgradbase->base + vgradbase->top++;

	mov	eax, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	inc	eax
	mov	DWORD PTR [esi+12], eax

; 1522 :   vgradtop++;

	inc	DWORD PTR _vgradtop

; 1523 : UNLOCK_WEB;

	cmp	DWORD PTR _threadflag, 0
	lea	edi, DWORD PTR [edx+ecx*4]
	je	SHORT $LN14@new_vgrad
	call	_myunlock_web
$LN14@new_vgrad:

; 1524 : 
; 1525 :   return vg;

	mov	eax, edi
	pop	edi
	pop	esi

; 1526 : 
; 1527 : }  // end new_vgrad()

	mov	esp, ebp
	pop	ebp
	ret	0
_new_vgrad ENDP
_TEXT	ENDS
PUBLIC	_get_bv_vgrad
; Function compile flags: /Ogtp
;	COMDAT _get_bv_vgrad
_TEXT	SEGMENT
_fixnum$ = 8						; size = 4
_v_id$ = 12						; size = 4
_get_bv_vgrad PROC					; COMDAT

; 1541 : {

	push	ebp
	mov	ebp, esp

; 1542 :   volgrad  *vgptr;
; 1543 : 
; 1544 :   vgptr = get_vertex_vgrad(v_id);

	mov	eax, DWORD PTR _v_id$[ebp]
	push	eax
	call	_get_vertex_vgrad
	add	esp, 4

; 1545 :   while ( vgptr )

	test	eax, eax
	je	SHORT $LN8@get_bv_vgr
	mov	ecx, DWORD PTR _fixnum$[ebp]
$LL4@get_bv_vgr:

; 1546 :     if ( vgptr->fixnum == fixnum ) break;

	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN8@get_bv_vgr

; 1547 :     else vgptr = vgptr->chain;

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jne	SHORT $LL4@get_bv_vgr
$LN8@get_bv_vgr:

; 1548 : 
; 1549 :   return vgptr;    /* null if not found */
; 1550 : 
; 1551 : } // end get_bv_vgrad()

	pop	ebp
	ret	0
_get_bv_vgrad ENDP
_TEXT	ENDS
PUBLIC	_get_bv_new_vgrad
; Function compile flags: /Ogtp
;	COMDAT _get_bv_new_vgrad
_TEXT	SEGMENT
_fixnum$ = 8						; size = 4
_v_id$ = 12						; size = 4
_get_bv_new_vgrad PROC					; COMDAT

; 1565 : {

	push	ebp
	mov	ebp, esp

; 1566 :   volgrad  **ptrptr;  /* pointer to pointer so can update if need be */
; 1567 : 
; 1568 :   ptrptr = (volgrad**)VPTR(v_id,vgrad_attr);

	mov	ecx, DWORD PTR _vgrad_attr
	mov	eax, DWORD PTR _v_id$[ebp]
	imul	ecx, 240				; 000000f0H
	mov	edx, DWORD PTR _web+12
	add	ecx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	push	esi
	mov	esi, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _dymem
	add	esi, DWORD PTR [ecx+eax+64]
	push	edi

; 1569 : 
; 1570 :   while ( *ptrptr )

	cmp	DWORD PTR [esi], 0
	mov	edi, DWORD PTR _fixnum$[ebp]
	je	SHORT $LN3@get_bv_new
	npad	7
$LL4@get_bv_new:

; 1571 :     if ( (*ptrptr)->fixnum == fixnum ) return *ptrptr;

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN5@get_bv_new

; 1572 :     else ptrptr = &(*ptrptr)->chain;

	cmp	DWORD PTR [eax+12], 0
	lea	esi, DWORD PTR [eax+12]
	jne	SHORT $LL4@get_bv_new
$LN3@get_bv_new:

; 1573 : 
; 1574 :   /* need to get new structure */
; 1575 :   *ptrptr = new_vgrad();

	call	_new_vgrad
	mov	DWORD PTR [esi], eax

; 1576 :   (*ptrptr)->fixnum = fixnum;

	mov	DWORD PTR [eax], edi

; 1577 : 
; 1578 :   return *ptrptr;

	mov	eax, DWORD PTR [esi]
$LN5@get_bv_new:
	pop	edi
	pop	esi

; 1579 : 
; 1580 : } // end get_bv_new_vgrad()

	pop	ebp
	ret	0
_get_bv_new_vgrad ENDP
_TEXT	ENDS
PUBLIC	_approx_curv_calc
EXTRN	_kb_dmatrix:PROC
EXTRN	_mobility_mult:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT _approx_curv_calc
_TEXT	SEGMENT
_attr$90393 = -16					; size = 8
_NV$90381 = -8						; size = 4
tv423 = -4						; size = 4
_B$ = -4						; size = 4
_ord$90395 = 8						; size = 4
_mode$ = 8						; size = 4
_approx_curv_calc PROC					; COMDAT

; 1594 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1595 :   int j;
; 1596 :   REAL *B;
; 1597 :   vertex_id v_id;
; 1598 : 
; 1599 :   if ( mode & CALC_FORCE )

	test	BYTE PTR _mode$[ebp], 1
	push	ebx
	push	esi
	push	edi
	je	$LN63@approx_cur

; 1600 :   { B  = (REAL *)temp_calloc(SDIM*(web.skel[VERTEX].max_ord+1),
; 1601 :              sizeof(REAL));  

	mov	eax, DWORD PTR _web+68
	inc	eax
	imul	eax, DWORD PTR _web+616
	push	1601					; 00000641H
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc

; 1602 : 
; 1603 :     /* each coordinate gives a right side */
; 1604 :     FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+48
	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	edx, 1
	mov	DWORD PTR _B$[ebp], eax
	je	$LN62@approx_cur
	mov	ebx, DWORD PTR _web+616
	mov	esi, DWORD PTR _web+12
	npad	8
$LL66@approx_cur:
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN33@approx_cur

; 1605 :       { 
; 1606 :         int vnum = SDIM*loc_ordinal(v_id);

	test	edx, edx
	je	SHORT $LN38@approx_cur
	mov	eax, ecx
	jmp	SHORT $LN39@approx_cur
$LN38@approx_cur:
	or	eax, -1
$LN39@approx_cur:
	imul	eax, ebx
	mov	edx, eax

; 1607 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN33@approx_cur

; 1605 :       { 
; 1606 :         int vnum = SDIM*loc_ordinal(v_id);

	mov	edi, DWORD PTR _B$[ebp]
	lea	edx, DWORD PTR [edi+edx*8]
$LL60@approx_cur:

; 1607 :         for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _dymem
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	edi, DWORD PTR _web+104
	add	esi, DWORD PTR [edi+ebx+784]
	inc	eax

; 1608 :            B[vnum+j] = get_force(v_id)[j];

	fld	QWORD PTR [esi+eax*8-8]
	add	edx, 8
	fstp	QWORD PTR [edx-8]
	mov	ebx, DWORD PTR _web+616
	mov	esi, DWORD PTR _web+12
	cmp	eax, ebx
	jl	SHORT $LL60@approx_cur
$LN33@approx_cur:

; 1602 : 
; 1603 :     /* each coordinate gives a right side */
; 1604 :     FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	SHORT $LL66@approx_cur
$LN62@approx_cur:

; 1609 :       }
; 1610 :     mobility_mult(B);

	mov	edx, DWORD PTR _B$[ebp]
	push	edx
	call	_mobility_mult

; 1611 :     FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	add	esp, 4
	and	ecx, 1
	je	$LN67@approx_cur
	mov	ebx, DWORD PTR _web+616
	npad	10
$LL26@approx_cur:
	mov	edi, eax
	mov	eax, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN25@approx_cur

; 1612 :       { REAL *vel = get_velocity(v_id);

	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR [eax+edx+1024]
	add	edx, esi

; 1613 :         int vnum = SDIM*loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN40@approx_cur
	mov	eax, edi
	jmp	SHORT $LN41@approx_cur
$LN40@approx_cur:
	or	eax, -1
$LN41@approx_cur:
	imul	eax, ebx
	mov	ecx, eax

; 1614 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN25@approx_cur

; 1613 :         int vnum = SDIM*loc_ordinal(v_id);

	mov	esi, DWORD PTR _B$[ebp]
	lea	ecx, DWORD PTR [esi+ecx*8]
	npad	4
$LL21@approx_cur:

; 1615 :           vel[j] = B[vnum+j];

	fld	QWORD PTR [ecx]
	inc	eax
	fstp	QWORD PTR [edx+eax*8-8]
	mov	ebx, DWORD PTR _web+616
	add	ecx, 8
	cmp	eax, ebx
	jl	SHORT $LL21@approx_cur
$LN25@approx_cur:

; 1611 :     FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	eax, DWORD PTR [edx]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	SHORT $LL26@approx_cur
$LN67@approx_cur:

; 1616 :       }
; 1617 : 
; 1618 :      temp_free((char *)B);

	mov	eax, DWORD PTR _B$[ebp]
	push	eax
	call	_temp_free
	add	esp, 4
$LN63@approx_cur:

; 1619 :   }
; 1620 : 
; 1621 :   if ( mode & CALC_VOLGRADS )

	test	BYTE PTR _mode$[ebp], 2
	je	$LN1@approx_cur

; 1622 :   /* constraint gradients */
; 1623 :   { int NV = SDIM*(1+web.skel[VERTEX].max_ord);

	mov	edi, DWORD PTR _web+68

; 1624 :     int bi;
; 1625 : 
; 1626 :     vgef = dmatrix(0,maxquants+1,0,NV);

	mov	ecx, DWORD PTR _maxquants
	inc	edi
	imul	edi, DWORD PTR _web+616
	push	1626					; 0000065aH
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	push	edi
	push	0
	inc	ecx
	push	ecx
	push	0
	mov	DWORD PTR _NV$90381[ebp], edi
	call	_kb_dmatrix

; 1627 :     vgev = dmatrix(0,maxquants+1,0,NV);

	mov	edx, DWORD PTR _maxquants
	push	1627					; 0000065bH
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	push	edi
	push	0
	inc	edx
	push	edx
	push	0
	mov	DWORD PTR _vgef, eax
	call	_kb_dmatrix

; 1628 :     /* load volume gradients */
; 1629 :     FOR_ALL_VERTICES(v_id)

	mov	esi, DWORD PTR _web+48
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	add	esp, 48					; 00000030H
	and	ecx, 1
	mov	DWORD PTR _vgev, eax
	je	$LN15@approx_cur
	npad	7
$LL64@approx_cur:
	mov	edx, DWORD PTR _web+12
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv423[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax+12]
	mov	eax, edx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN16@approx_cur

; 1630 :      {
; 1631 :         volgrad *vgptri;
; 1632 :         ATTR attr = get_vattr(v_id);

	mov	eax, edx
	mov	DWORD PTR _attr$90393[ebp+4], ebx

; 1633 :         int ord = loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN42@approx_cur
	mov	ecx, DWORD PTR tv423[ebp]
	mov	DWORD PTR _ord$90395[ebp], ecx
	jmp	SHORT $LN43@approx_cur
$LN42@approx_cur:
	mov	DWORD PTR _ord$90395[ebp], -1
$LN43@approx_cur:

; 1634 : 
; 1635 :         if ( attr & FIXED ) continue;

	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN16@approx_cur

; 1636 : 
; 1637 :         for ( vgptri=get_vertex_vgrad(v_id); vgptri ; vgptri = vgptri->chain )

	push	esi
	call	_get_vertex_vgrad
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@approx_cur
	npad	6
$LL11@approx_cur:

; 1638 :         { bi = vgptri->fixnum;
; 1639 :           if (valid_id(vgptri->bb_id) && !web.pressure_flag && !everything_quantities_flag )

	mov	ecx, DWORD PTR [eax+8]
	mov	edi, DWORD PTR [eax]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN7@approx_cur
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN7@approx_cur
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN7@approx_cur

; 1640 :             { if ( !(get_battr(vgptri->bb_id)&FIXEDVOL) ) continue;

	mov	edx, DWORD PTR _web+348
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 32					; 00000020H
	xor	edx, edx
	or	ecx, edx
	je	SHORT $LN10@approx_cur
$LN7@approx_cur:

; 1641 :             }
; 1642 :           for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _web+616
	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN10@approx_cur
	mov	edx, DWORD PTR _vgef
	mov	edx, DWORD PTR [edx+edi*4]
	npad	1
$LL6@approx_cur:

; 1643 :             vgef[bi][SDIM*ord+j] = vgptri->grad[j];

	imul	esi, DWORD PTR _ord$90395[ebp]
	mov	edi, DWORD PTR [eax+16]
	add	esi, ecx
	inc	ecx
	fld	QWORD PTR [edi+ecx*8-8]
	fstp	QWORD PTR [edx+esi*8]
	mov	esi, DWORD PTR _web+616
	cmp	ecx, esi
	jl	SHORT $LL6@approx_cur
$LN10@approx_cur:

; 1636 : 
; 1637 :         for ( vgptri=get_vertex_vgrad(v_id); vgptri ; vgptri = vgptri->chain )

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jne	SHORT $LL11@approx_cur
$LN16@approx_cur:

; 1628 :     /* load volume gradients */
; 1629 :     FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR tv423[ebp]
	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	esi, DWORD PTR [edx]
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL64@approx_cur
	mov	edi, DWORD PTR _NV$90381[ebp]
$LN15@approx_cur:

; 1644 :         }
; 1645 :      }
; 1646 : 
; 1647 :       /* convert gradients to vectors */
; 1648 :      for ( bi = 0 ; bi <= maxquants ; bi++ )

	xor	esi, esi
	cmp	DWORD PTR _maxquants, esi
	jl	SHORT $LN1@approx_cur
	add	edi, edi
	add	edi, edi
	add	edi, edi
$LL61@approx_cur:

; 1649 :      { memcpy((char*)vgev[bi],(char*)vgef[bi],NV*sizeof(REAL));

	mov	eax, DWORD PTR _vgef
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	edx, DWORD PTR _vgev
	mov	eax, DWORD PTR [edx+esi*4]
	push	edi
	push	ecx
	push	eax
	call	_memcpy

; 1650 :        mobility_mult(vgev[bi]); /* to vector */

	mov	ecx, DWORD PTR _vgev
	mov	edx, DWORD PTR [ecx+esi*4]
	push	edx
	call	_mobility_mult
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR _maxquants
	jle	SHORT $LL61@approx_cur
$LN1@approx_cur:
	pop	edi
	pop	esi
	pop	ebx

; 1651 :      }
; 1652 : 
; 1653 :   }  
; 1654 : 
; 1655 : } /* end approx_curv_calc() */

	mov	esp, ebp
	pop	ebp
	ret	0
_approx_curv_calc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EL@GFKKJLCK@calc_one_sided_grads?$CI?$CJ?5?9?5adding?5@ ; `string'
PUBLIC	_calc_one_sided_grads
EXTRN	_kb_temp_realloc:PROC
EXTRN	_eval_all:PROC
EXTRN	_realloc:PROC
EXTRN	_nullcon:QWORD
_BSS	SEGMENT
_one_sided_fixcount_list DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0EL@GFKKJLCK@calc_one_sided_grads?$CI?$CJ?5?9?5adding?5@
CONST	SEGMENT
??_C@_0EL@GFKKJLCK@calc_one_sided_grads?$CI?$CJ?5?9?5adding?5@ DB 'calc_o'
	DB	'ne_sided_grads() - adding onesided constraints to constraint '
	DB	'matrix', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _calc_one_sided_grads
_TEXT	SEGMENT
_fval$89313 = -32					; size = 8
tv268 = -24						; size = 8
_x$89314 = -20						; size = 4
_list_alloc$ = -16					; size = 4
tv262 = -12						; size = 4
_list_spot$ = -8					; size = 4
_j$89294 = -4						; size = 4
_calc_one_sided_grads PROC				; COMDAT

; 291  : { vertex_id v_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 292  :   int list_alloc = 2*web.skel[VERTEX].count;

	mov	esi, DWORD PTR _web+64
	add	esi, esi

; 293  :   int list_spot = 0;
; 294  : 
; 295  :   if ( itdebug ) 

	cmp	DWORD PTR _itdebug, 0
	push	edi
	mov	DWORD PTR _list_alloc$[ebp], esi
	mov	DWORD PTR _list_spot$[ebp], 0
	je	SHORT $LN12@calc_one_s

; 296  :     outstring("calc_one_sided_grads() - adding onesided constraints to constraint matrix\n");

	push	OFFSET ??_C@_0EL@GFKKJLCK@calc_one_sided_grads?$CI?$CJ?5?9?5adding?5@
	call	_outstring
	add	esp, 4
$LN12@calc_one_s:

; 297  : 
; 298  :   one_sided_fixcount_list = (struct fixcount_list *)
; 299  :      temp_calloc(list_alloc,sizeof(struct fixcount_list));

	push	299					; 0000012bH
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	push	8
	push	esi
	call	_kb_temp_calloc

; 300  : 
; 301  :   FOR_ALL_VERTICES(v_id)

	mov	edi, DWORD PTR _web+48
	add	esp, 16					; 00000010H
	mov	DWORD PTR _one_sided_fixcount_list, eax
	test	edi, 268435456				; 10000000H
	je	$LN9@calc_one_s
	push	ebx
	npad	3
$LL11@calc_one_s:
	mov	eax, DWORD PTR _web+12
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	esi, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR tv268[ebp+4], eax
	mov	eax, edx
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv262[ebp], ecx
	je	$LN10@calc_one_s

; 302  :   { conmap_t *conmap;
; 303  :     int j;
; 304  :     if ( get_vattr(v_id) & FIXED )

	and	edx, 64					; 00000040H
	xor	eax, eax
	or	edx, eax
	jne	$LN10@calc_one_s

; 305  :        continue;
; 306  :     conmap = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	cmp	DWORD PTR [eax+edx+1288], ebx
	je	SHORT $LN15@calc_one_s
	mov	ebx, DWORD PTR [eax+edx+1264]
	add	ebx, esi
	jmp	SHORT $LN16@calc_one_s
$LN15@calc_one_s:
	mov	ebx, OFFSET _nullcon
$LN16@calc_one_s:

; 307  :     for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, 1
	mov	DWORD PTR _j$89294[ebp], eax
	cmp	DWORD PTR [ebx], eax
	jl	$LN10@calc_one_s
$LL5@calc_one_s:

; 308  :     { struct constraint *thiscon;
; 309  :       thiscon = get_constraint(conmap[j]);

	mov	eax, DWORD PTR [ebx+eax*4]
	mov	esi, eax
	and	esi, 1073741823				; 3fffffffH
	imul	esi, 176				; 000000b0H
	add	esi, DWORD PTR _web+652

; 310  :       if ( (thiscon->attr & (NONNEGATIVE|NONPOSITIVE)) && 
; 311  :          (conmap[j] & CON_HIT_BIT) )

	xor	edx, edx
	mov	ecx, DWORD PTR [esi+32]
	and	ecx, 3
	or	ecx, edx
	je	$LN22@calc_one_s
	test	eax, eax
	jns	$LN22@calc_one_s

; 312  :       { /* need this one */
; 313  :         REAL fval;
; 314  :         REAL *x = get_coord(v_id);

	mov	ecx, DWORD PTR tv262[ebp]
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+64]

; 315  :         volgrad *vgptr;
; 316  : 
; 317  :         if ( list_spot >= list_alloc )

	mov	ecx, DWORD PTR _list_spot$[ebp]
	mov	DWORD PTR _x$89314[ebp], eax
	mov	eax, DWORD PTR _list_alloc$[ebp]
	cmp	ecx, eax
	jl	SHORT $LN21@calc_one_s

; 318  :         { list_alloc *= 2;
; 319  :           one_sided_fixcount_list = (struct fixcount_list *)
; 320  :              realloc((char*)one_sided_fixcount_list,
; 321  :                 list_alloc*sizeof(struct fixcount_list));

	mov	ecx, DWORD PTR _one_sided_fixcount_list
	add	eax, eax
	mov	DWORD PTR _list_alloc$[ebp], eax
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	call	_realloc
	mov	ecx, DWORD PTR _list_spot$[ebp]
	add	esp, 8
	mov	DWORD PTR _one_sided_fixcount_list, eax
	jmp	SHORT $LN1@calc_one_s
$LN21@calc_one_s:
	mov	eax, DWORD PTR _one_sided_fixcount_list
$LN1@calc_one_s:

; 322  :         }
; 323  : 
; 324  :         one_sided_fixcount_list[list_spot].v_id = v_id;
; 325  :         one_sided_fixcount_list[list_spot].connum = conmap[j] & CONMASK;

	mov	edx, DWORD PTR _j$89294[ebp]
	mov	DWORD PTR [eax+ecx*8], edi
	mov	edx, DWORD PTR [ebx+edx*4]
	and	edx, 1073741823				; 3fffffffH
	mov	DWORD PTR [eax+ecx*8+4], edx

; 326  :         list_spot++; 
; 327  :         
; 328  :         vgptr = get_bv_new_vgrad(fixcount,v_id); 

	mov	eax, DWORD PTR _fixcount
	inc	ecx
	push	edi
	push	eax
	mov	DWORD PTR _list_spot$[ebp], ecx
	call	_get_bv_new_vgrad

; 329  :         vgptr->qnum = conmap[j] & CONMASK;

	mov	ecx, DWORD PTR _j$89294[ebp]
	mov	edx, DWORD PTR [ebx+ecx*4]

; 330  :         vgptr->bb_id = v_id;
; 331  :         vgptr->fixnum = fixcount;

	mov	ecx, DWORD PTR _fixcount
	and	edx, 1073741823				; 3fffffffH
	mov	DWORD PTR [eax+4], edx

; 332  :         eval_all(thiscon->formula,x,SDIM,&fval,vgptr->grad,v_id);

	mov	edx, DWORD PTR [eax+16]
	push	edi
	push	edx
	mov	edx, DWORD PTR _x$89314[ebp]
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _web+616
	lea	eax, DWORD PTR _fval$89313[ebp]
	push	eax
	mov	eax, DWORD PTR [esi+40]
	push	ecx
	push	edx
	push	eax
	call	_eval_all
	add	esp, 32					; 00000020H

; 333  :         
; 334  :         fixcount++;

	inc	DWORD PTR _fixcount
$LN22@calc_one_s:
	mov	eax, DWORD PTR _j$89294[ebp]
	mov	ecx, DWORD PTR tv262[ebp]
	inc	eax
	mov	DWORD PTR _j$89294[ebp], eax
	cmp	eax, DWORD PTR [ebx]
	jle	$LL5@calc_one_s
$LN10@calc_one_s:

; 300  : 
; 301  :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [ecx+edx]
	mov	edi, DWORD PTR [eax]
	test	edi, 268435456				; 10000000H
	jne	$LL11@calc_one_s
	pop	ebx
$LN9@calc_one_s:

; 335  :       }
; 336  :     } /* end j loop */
; 337  :   } /* end all vertices */
; 338  : 
; 339  :   /* free extra space */
; 340  :   one_sided_fixcount_list = (struct fixcount_list *)
; 341  :      temp_realloc((char*)one_sided_fixcount_list,
; 342  :         list_spot*sizeof(struct fixcount_list));

	mov	ecx, DWORD PTR _list_spot$[ebp]
	mov	eax, DWORD PTR _one_sided_fixcount_list
	push	342					; 00000156H
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	push	eax
	call	_kb_temp_realloc

; 343  : 
; 344  : 
; 345  :   maxquants = fixcount;

	mov	ecx, DWORD PTR _fixcount
	add	esp, 16					; 00000010H
	pop	edi
	mov	DWORD PTR _one_sided_fixcount_list, eax
	mov	DWORD PTR _maxquants, ecx
	pop	esi

; 346  : 
; 347  : } /* end calc_one_sided_grads() */

	mov	esp, ebp
	pop	ebp
	ret	0
_calc_one_sided_grads ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DO@NDLCEHAN@pressure_forces?$CI?$CJ?3?5adding?5forces@ ; `string'
PUBLIC	_pressure_forces
;	COMDAT ??_C@_0DO@NDLCEHAN@pressure_forces?$CI?$CJ?3?5adding?5forces@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DO@NDLCEHAN@pressure_forces?$CI?$CJ?3?5adding?5forces@ DB 'pressur'
	DB	'e_forces(): adding forces due to prescribed pressure.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\fixvol.c
CONST	ENDS
;	COMDAT _pressure_forces
_TEXT	SEGMENT
tv501 = -12						; size = 8
tv429 = -12						; size = 8
tv423 = -4						; size = 4
_pressure_forces PROC					; COMDAT

; 357  : { vertex_id v_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	edi

; 358  :   int k;
; 359  :   body_id b_id;
; 360  :   volgrad *vgptr;
; 361  :   int to_do = 0;

	xor	edi, edi

; 362  : 
; 363  :   if ( everything_quantities_flag ) return; 

	cmp	DWORD PTR _everything_quantities_flag, edi
	jne	$LN12@pressure_f

; 364  : 
; 365  :   if ( itdebug ) 

	cmp	DWORD PTR _itdebug, edi
	je	SHORT $LN37@pressure_f

; 366  :       outstring("pressure_forces(): adding forces due to prescribed pressure.\n");

	push	OFFSET ??_C@_0DO@NDLCEHAN@pressure_forces?$CI?$CJ?3?5adding?5forces@
	call	_outstring
	add	esp, 4
$LN37@pressure_f:

; 367  : 
; 368  :   if ( web.pressure_flag )

	push	ebx
	push	esi
	cmp	DWORD PTR _web+868, edi
	je	$LN36@pressure_f

; 369  :   {
; 370  :     /* add forces due to dynamic pressure */
; 371  :     FOR_ALL_VERTICES(v_id)

	mov	edi, DWORD PTR _web+48
	test	edi, 268435456				; 10000000H
	je	$LN69@pressure_f
	fldz
$LN35@pressure_f:
	mov	eax, DWORD PTR _web+12
	mov	ebx, edi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv429[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN34@pressure_f

; 372  :     { REAL *f;
; 373  :      
; 374  :       if ( get_vattr(v_id) & FIXED ) continue;

	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	jne	$LN34@pressure_f

; 375  :       f = get_force(v_id);

	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR [eax+ecx+784]

; 376  :       for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	push	edi
	add	esi, edx
	call	_get_vertex_vgrad
	add	esp, 4
	test	eax, eax
	je	SHORT $LN34@pressure_f
$LN29@pressure_f:

; 377  :         {
; 378  :           if ( valid_id(vgptr->bb_id) ) 

	mov	edx, DWORD PTR [eax+8]
	test	edx, 268435456				; 10000000H
	je	SHORT $LN28@pressure_f

; 379  :           if ( (get_battr(vgptr->bb_id) & FIXEDVOL) ) 

	mov	edi, DWORD PTR _web+348
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 32					; 00000020H
	xor	edi, edi
	or	ecx, edi
	je	SHORT $LN28@pressure_f

; 380  :           { REAL p = get_body_pressure(vgptr->bb_id);

	test	edx, 268435456				; 10000000H
	je	SHORT $LN43@pressure_f
	mov	ecx, DWORD PTR _web+348
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	fld	QWORD PTR [edx+312]
	jmp	SHORT $LN44@pressure_f
$LN43@pressure_f:
	fld	ST(0)
$LN44@pressure_f:

; 381  :              for ( k = 0 ; k < SDIM ; k++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN89@pressure_f
$LN24@pressure_f:

; 382  :                 f[k] += (p - web.pressure)*vgptr->grad[k];

	fld	QWORD PTR _web+1536
	mov	edx, DWORD PTR [eax+16]
	fsubr	ST(0), ST(1)
	inc	ecx
	fmul	QWORD PTR [edx+ecx*8-8]
	fadd	QWORD PTR [esi+ecx*8-8]
	fstp	QWORD PTR [esi+ecx*8-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN24@pressure_f
$LN89@pressure_f:

; 381  :              for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
$LN28@pressure_f:

; 376  :       for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jne	SHORT $LN29@pressure_f
$LN34@pressure_f:

; 369  :   {
; 370  :     /* add forces due to dynamic pressure */
; 371  :     FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ebx+eax]
	mov	edi, DWORD PTR [ecx]
	test	edi, 268435456				; 10000000H
	jne	$LN35@pressure_f

; 396  : 
; 397  :   FOR_ALL_VERTICES(v_id)

	pop	esi
	fstp	ST(0)
	pop	ebx
	pop	edi

; 408  :     }
; 409  :   }
; 410  : } /* end pressure_forces() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@pressure_f:

; 383  :           }
; 384  :         }
; 385  :      
; 386  :     }
; 387  :     return;
; 388  :   }
; 389  : 
; 390  :   /* add prescribed pressure forces */
; 391  :   /* first, see if there are any */
; 392  :   FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+384
	test	eax, 268435456				; 10000000H
	je	$LN69@pressure_f
$LL21@pressure_f:
	mov	edx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv501[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN20@pressure_f

; 393  :      if ( get_battr(b_id) & PRESSURE ) to_do = 1;

	and	ecx, 2048				; 00000800H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN20@pressure_f
	lea	edi, DWORD PTR [esi+1]
$LN20@pressure_f:

; 383  :           }
; 384  :         }
; 385  :      
; 386  :     }
; 387  :     return;
; 388  :   }
; 389  : 
; 390  :   /* add prescribed pressure forces */
; 391  :   /* first, see if there are any */
; 392  :   FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL21@pressure_f

; 394  :   
; 395  :   if ( to_do == 0 ) return;

	test	edi, edi
	je	$LN69@pressure_f

; 396  : 
; 397  :   FOR_ALL_VERTICES(v_id)

	mov	edi, DWORD PTR _web+48
	test	edi, 268435456				; 10000000H
	je	$LN69@pressure_f
	fldz
	mov	ebx, DWORD PTR _web+12
$LN14@pressure_f:
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv423[ebp], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv429[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN13@pressure_f

; 398  :   { REAL *f;
; 399  : 
; 400  :     if ( get_vattr(v_id) & FIXED ) continue;

	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	jne	$LN13@pressure_f

; 401  :     f = get_force(v_id);

	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR [eax+ecx+784]

; 402  :     for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	push	edi
	add	esi, edx
	call	_get_vertex_vgrad
	add	esp, 4
	test	eax, eax
	je	$LN13@pressure_f
$LN8@pressure_f:

; 403  :     {
; 404  :       if ( valid_id(vgptr->bb_id) )  /* check for real bodies */

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN7@pressure_f

; 405  :       if ( get_battr(vgptr->bb_id) & PRESSURE )

	mov	edx, DWORD PTR _web+348
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 2048				; 00000800H
	xor	edx, edx
	or	ecx, edx
	je	SHORT $LN7@pressure_f

; 406  :       for ( k = 0 ; k < SDIM ; k++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN7@pressure_f
$LN63@pressure_f:

; 407  :         f[k] += get_body_pressure(vgptr->bb_id)*vgptr->grad[k];

	mov	edx, DWORD PTR [eax+8]
	test	edx, 268435456				; 10000000H
	je	SHORT $LN47@pressure_f
	mov	edi, DWORD PTR _web+348
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	fld	QWORD PTR [edx+312]
	jmp	SHORT $LN48@pressure_f
$LN47@pressure_f:
	fld	ST(0)
$LN48@pressure_f:
	mov	edx, DWORD PTR [eax+16]
	fmul	QWORD PTR [edx+ecx*8]
	inc	ecx
	fadd	QWORD PTR [esi+ecx*8-8]
	fstp	QWORD PTR [esi+ecx*8-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN63@pressure_f
$LN7@pressure_f:

; 402  :     for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jne	SHORT $LN8@pressure_f
	mov	ebx, DWORD PTR _web+12
$LN13@pressure_f:

; 396  : 
; 397  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR tv423[ebp]
	mov	ecx, DWORD PTR [eax+ebx]
	mov	edi, DWORD PTR [ecx]
	test	edi, 268435456				; 10000000H
	jne	$LN14@pressure_f
	fstp	ST(0)
$LN69@pressure_f:
	pop	esi
	pop	ebx
$LN12@pressure_f:
	pop	edi

; 408  :     }
; 409  :   }
; 410  : } /* end pressure_forces() */

	mov	esp, ebp
	pop	ebp
	ret	0
_pressure_forces ENDP
_TEXT	ENDS
PUBLIC	_local_calc_leftside
EXTRN	_sp_hash_search:PROC
EXTRN	_dot:PROC
EXTRN	_approx_curve_flag:DWORD
_BSS	SEGMENT
_degfree DD	01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _local_calc_leftside
_TEXT	SEGMENT
tv235 = -12						; size = 8
tv229 = -4						; size = 4
_local_calc_leftside PROC				; COMDAT

; 708  : { vertex_id v_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 709  :   int bi,bj;
; 710  :   
; 711  :   /* generate  DV^T DV */
; 712  :   if ( !approx_curve_flag )

	cmp	DWORD PTR _approx_curve_flag, 0
	jne	$LN20@local_calc

; 713  :   { FOR_ALL_VERTICES(v_id)

	push	esi
	mov	esi, DWORD PTR _web+48
	test	esi, 268435456				; 10000000H
	je	$LN36@local_calc
	push	ebx
	push	edi
	npad	8
$LL35@local_calc:
	mov	eax, DWORD PTR _web+12
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+eax]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	mov	DWORD PTR tv235[ebp+4], edx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv229[ebp], edi
	je	$LN21@local_calc

; 714  :     {
; 715  :       volgrad *vgptri,*vgptrj;
; 716  :       ATTR attr = get_vattr(v_id);
; 717  : 
; 718  :       if ( attr & FIXED ) continue;

	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	jne	$LN21@local_calc

; 719  : 
; 720  :       for ( vgptri = get_vertex_vgrad(v_id); vgptri ; vgptri = vgptri->chain )

	push	esi
	call	_get_vertex_vgrad
	mov	ebx, eax
	add	esp, 4
	test	ebx, ebx
	je	$LN21@local_calc
	npad	1
$LL16@local_calc:

; 721  :       { REAL tmp;
; 722  :         bi = vgptri->fixnum;

	mov	esi, DWORD PTR [ebx]

; 723  :         if ( (bi < 0) || (bi >= fixcount) ) continue;

	test	esi, esi
	js	$LN15@local_calc
	cmp	esi, DWORD PTR _fixcount
	jge	$LN15@local_calc

; 724  :         degfree++;
; 725  :         tmp = SDIM_dot(vgptri->velocity,vgptri->grad);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ebx+20]
	inc	DWORD PTR _degfree
	push	eax
	push	ecx
	push	edx
	call	_dot
	add	esp, 12					; 0000000cH

; 726  :          
; 727  :  /*      if ( !(attr & HIT_WALL) )    */
; 728  :         { if ( sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, 0
	je	SHORT $LN11@local_calc

; 729  :           { sp_hash_search(&LS,bi,bi,tmp); }

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	esi
	push	esi
	push	OFFSET _LS
	call	_sp_hash_search
	add	esp, 20					; 00000014H

; 730  :           else

	jmp	SHORT $LN10@local_calc
$LN11@local_calc:

; 731  :             rleftside[bi][bi] += tmp;

	mov	eax, DWORD PTR _rleftside
	mov	ecx, DWORD PTR [eax+esi*4]
	fadd	QWORD PTR [ecx+esi*8]
	lea	eax, DWORD PTR [ecx+esi*8]
	fstp	QWORD PTR [eax]
$LN10@local_calc:

; 732  :         }
; 733  :         for ( vgptrj = vgptri->chain ; vgptrj ; vgptrj = vgptrj->chain )

	mov	edi, DWORD PTR [ebx+12]
	test	edi, edi
	je	$LN33@local_calc
	npad	3
$LL9@local_calc:

; 734  :         { tmp = SDIM_dot(vgptri->grad,vgptrj->velocity);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [ebx+16]
	push	edx
	push	eax
	push	ecx
	call	_dot

; 735  :           bj = vgptrj->fixnum;

	mov	eax, DWORD PTR [edi]
	add	esp, 12					; 0000000cH

; 736  :           if ( (bj < 0) || (bj >= fixcount) ) continue;

	test	eax, eax
	js	SHORT $LN45@local_calc
	cmp	eax, DWORD PTR _fixcount
	jge	SHORT $LN45@local_calc

; 737  : /*        if ( !(attr & HIT_WALL) ) */
; 738  :           {
; 739  :             if ( sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, 0
	je	SHORT $LN4@local_calc

; 740  :             { if ( bi < bj ) sp_hash_search(&LS,bi,bj,tmp);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	cmp	esi, eax
	jge	SHORT $LN3@local_calc
	push	eax
	push	esi
	push	OFFSET _LS
	call	_sp_hash_search
	add	esp, 20					; 00000014H
	jmp	SHORT $LN8@local_calc
$LN3@local_calc:

; 741  :               else sp_hash_search(&LS,bj,bi,tmp);

	push	esi
	push	eax
	push	OFFSET _LS
	call	_sp_hash_search
	add	esp, 20					; 00000014H

; 742  :             }
; 743  :             else

	jmp	SHORT $LN8@local_calc
$LN4@local_calc:

; 744  :             { rleftside[bi][bj] += tmp;

	mov	edx, DWORD PTR _rleftside
	mov	ecx, DWORD PTR [edx+esi*4]
	fld	QWORD PTR [ecx+eax*8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [ecx]

; 745  :               rleftside[bj][bi] += tmp;

	mov	edx, DWORD PTR _rleftside
	mov	eax, DWORD PTR [edx+eax*4]
	fadd	QWORD PTR [eax+esi*8]
	lea	eax, DWORD PTR [eax+esi*8]
	fstp	QWORD PTR [eax]
	jmp	SHORT $LN8@local_calc
$LN45@local_calc:

; 736  :           if ( (bj < 0) || (bj >= fixcount) ) continue;

	fstp	ST(0)
$LN8@local_calc:

; 732  :         }
; 733  :         for ( vgptrj = vgptri->chain ; vgptrj ; vgptrj = vgptrj->chain )

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	jne	$LL9@local_calc
$LN33@local_calc:
	mov	edi, DWORD PTR tv229[ebp]
$LN15@local_calc:

; 719  : 
; 720  :       for ( vgptri = get_vertex_vgrad(v_id); vgptri ; vgptri = vgptri->chain )

	mov	ebx, DWORD PTR [ebx+12]
	test	ebx, ebx
	jne	$LL16@local_calc
$LN21@local_calc:

; 713  :   { FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [edi+ecx]
	mov	esi, DWORD PTR [edx]
	test	esi, 268435456				; 10000000H
	jne	$LL35@local_calc
	pop	edi
	pop	ebx
$LN36@local_calc:
	pop	esi
$LN20@local_calc:

; 746  :             }
; 747  :           }
; 748  :         }
; 749  :       }
; 750  :     }
; 751  :   }
; 752  : } // end local_calc_leftside()

	mov	esp, ebp
	pop	ebp
	ret	0
_local_calc_leftside ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@FIGCCHMM@calc_rightside?$CI?$CJ?3?5for?5finding?5La@ ; `string'
PUBLIC	_local_calc_rightside
;	COMDAT ??_C@_0DE@FIGCCHMM@calc_rightside?$CI?$CJ?3?5for?5finding?5La@
CONST	SEGMENT
??_C@_0DE@FIGCCHMM@calc_rightside?$CI?$CJ?3?5for?5finding?5La@ DB 'calc_r'
	DB	'ightside(): for finding Lagrange multipliers', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _local_calc_rightside
_TEXT	SEGMENT
tv355 = -16						; size = 4
_f$89748 = -16						; size = 4
tv358 = -12						; size = 4
tv357 = -12						; size = 4
tv364 = -8						; size = 8
_vgptri$89777 = -4					; size = 4
_local_calc_rightside PROC				; COMDAT

; 854  : { int bi;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 855  :   vertex_id v_id;
; 856  : 
; 857  :   if ( itdebug ) 

	cmp	DWORD PTR _itdebug, 0
	je	SHORT $LN29@local_calc@2

; 858  :     outstring("calc_rightside(): for finding Lagrange multipliers\n");

	push	OFFSET ??_C@_0DE@FIGCCHMM@calc_rightside?$CI?$CJ?3?5for?5finding?5La@
	call	_outstring
	add	esp, 4
$LN29@local_calc@2:

; 859  :   /* generate right side of matrix equation */
; 860  :   if ( !approx_curve_flag )

	cmp	DWORD PTR _approx_curve_flag, 0
	push	ebx
	push	esi
	push	edi
	jne	$LN43@local_calc@2

; 861  :   { FOR_ALL_VERTICES(v_id)

	mov	esi, DWORD PTR _web+48
	test	esi, 268435456				; 10000000H
	je	$LN11@local_calc@2
	mov	ebx, DWORD PTR _web+12
$LL27@local_calc@2:
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv358[ebp], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv364[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN26@local_calc@2

; 862  :     {
; 863  :       volgrad *vgptri;
; 864  :       ATTR attr = get_vattr(v_id);
; 865  :       REAL *f;
; 866  : 
; 867  :       if ( attr & FIXED ) continue;

	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	jne	$LN26@local_calc@2

; 868  :       f = get_velocity(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [ecx+eax+1024]
	add	eax, edx

; 869  : 
; 870  :       for ( vgptri = get_vertex_vgrad(v_id); vgptri ; vgptri = vgptri->chain )

	push	esi
	mov	DWORD PTR _f$89748[ebp], eax
	call	_get_vertex_vgrad
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	$LN26@local_calc@2
$LL21@local_calc@2:

; 871  :       { 
; 872  :         bi = vgptri->fixnum;

	mov	edx, DWORD PTR [edi]

; 873  :         if ( (bi < 0) || (bi >= fixcount) ) continue;

	test	edx, edx
	js	SHORT $LN20@local_calc@2
	cmp	edx, DWORD PTR _fixcount
	jge	SHORT $LN20@local_calc@2

; 874  :         if (valid_id(vgptri->bb_id) && !web.pressure_flag && !everything_quantities_flag )

	mov	eax, DWORD PTR [edi+8]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN15@local_calc@2
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN15@local_calc@2
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN15@local_calc@2

; 875  :         { if ( (id_type(vgptri->bb_id) == BODY) && !(get_battr(vgptri->bb_id)&FIXEDVOL) ) 

	mov	ecx, eax
	and	ecx, -536870912				; e0000000H
	cmp	ecx, 1610612736				; 60000000H
	jne	SHORT $LN15@local_calc@2
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN20@local_calc@2
$LN15@local_calc@2:

; 876  :              continue;
; 877  :         }
; 878  :         rightside[bi] += SDIM_dot(f,vgptri->grad);

	mov	eax, DWORD PTR _rightside
	mov	ecx, DWORD PTR _web+616
	lea	esi, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [edi+16]
	mov	eax, DWORD PTR _f$89748[ebp]
	push	ecx
	push	edx
	push	eax
	call	_dot
	fadd	QWORD PTR [esi]
	add	esp, 12					; 0000000cH
	fstp	QWORD PTR [esi]
$LN20@local_calc@2:

; 869  : 
; 870  :       for ( vgptri = get_vertex_vgrad(v_id); vgptri ; vgptri = vgptri->chain )

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	jne	SHORT $LL21@local_calc@2
	mov	ebx, DWORD PTR _web+12
$LN26@local_calc@2:

; 861  :   { FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR tv358[ebp]
	mov	edx, DWORD PTR [ecx+ebx]
	mov	esi, DWORD PTR [edx]
	test	esi, 268435456				; 10000000H
	jne	$LL27@local_calc@2

; 879  :       }
; 880  :     }
; 881  :   }
; 882  : 
; 883  :   if ( approx_curve_flag )

	cmp	DWORD PTR _approx_curve_flag, 0
	je	$LN11@local_calc@2
	jmp	SHORT $LN42@local_calc@2
$LN43@local_calc@2:
	mov	ebx, DWORD PTR _web+12
$LN42@local_calc@2:

; 884  :   { REAL *f;
; 885  : 
; 886  :     /* calculate right side */
; 887  :     FOR_ALL_VERTICES(v_id)

	mov	esi, DWORD PTR _web+48
	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv355[ebp], eax
	je	$LN11@local_calc@2
	npad	8
$LL44@local_calc@2:
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv357[ebp], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv364[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN12@local_calc@2

; 888  :      {
; 889  :         volgrad *vgptri;
; 890  :         ATTR attr = get_vattr(v_id);
; 891  : 
; 892  :         if ( attr & FIXED ) continue;

	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	jne	$LN12@local_calc@2

; 893  : 
; 894  :         f = get_velocity(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	edi, DWORD PTR [ecx+eax+1024]

; 895  :         for ( vgptri=get_vertex_vgrad(v_id); vgptri ; vgptri = vgptri->chain )

	push	esi
	add	edi, edx
	call	_get_vertex_vgrad
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _vgptri$89777[ebp], eax
	test	esi, esi
	je	$LN12@local_calc@2
	jmp	SHORT $LN7@local_calc@2
	npad	2
$LL45@local_calc@2:
	mov	esi, DWORD PTR _vgptri$89777[ebp]
$LN7@local_calc@2:

; 896  :         {
; 897  :           bi = vgptri->fixnum;

	mov	edx, DWORD PTR [esi]

; 898  :           if ( (bi < 0) || (bi >= fixcount) ) continue;

	test	edx, edx
	js	SHORT $LN6@local_calc@2
	cmp	edx, DWORD PTR _fixcount
	jge	SHORT $LN6@local_calc@2

; 899  :           if (valid_id(vgptri->bb_id) &&!web.pressure_flag &&  !everything_quantities_flag )

	mov	eax, DWORD PTR [esi+8]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@local_calc@2
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN1@local_calc@2
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN1@local_calc@2

; 900  :             { if ( !(get_battr(vgptri->bb_id)&FIXEDVOL) ) continue;

	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN6@local_calc@2
$LN1@local_calc@2:

; 901  :             }
; 902  :           rightside[bi] += SDIM_dot(f,&vgef[bi][SDIM*loc_ordinal(v_id)]);

	cmp	DWORD PTR tv355[ebp], 0
	je	SHORT $LN32@local_calc@2
	mov	eax, DWORD PTR tv357[ebp]
	jmp	SHORT $LN33@local_calc@2
$LN32@local_calc@2:
	or	eax, -1
$LN33@local_calc@2:
	mov	ecx, DWORD PTR _rightside
	lea	esi, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _web+616
	imul	eax, ecx
	push	ecx
	mov	ecx, DWORD PTR _vgef
	mov	edx, DWORD PTR [ecx+edx*4]
	lea	eax, DWORD PTR [edx+eax*8]
	push	eax
	push	edi
	call	_dot
	add	esp, 12					; 0000000cH
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	mov	esi, DWORD PTR _vgptri$89777[ebp]
$LN6@local_calc@2:

; 895  :         for ( vgptri=get_vertex_vgrad(v_id); vgptri ; vgptri = vgptri->chain )

	mov	esi, DWORD PTR [esi+12]
	mov	DWORD PTR _vgptri$89777[ebp], esi
	test	esi, esi
	jne	$LL45@local_calc@2
	mov	ebx, DWORD PTR _web+12
$LN12@local_calc@2:

; 884  :   { REAL *f;
; 885  : 
; 886  :     /* calculate right side */
; 887  :     FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR tv357[ebp]
	mov	edx, DWORD PTR [ebx+ecx*4]
	mov	esi, DWORD PTR [edx]
	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv355[ebp], eax
	jne	$LL44@local_calc@2
$LN11@local_calc@2:
	pop	edi
	pop	esi
	pop	ebx

; 903  :         }
; 904  :       }
; 905  :   }  /* end approx_curve_flag */
; 906  : } // local_calc_rightside()

	mov	esp, ebp
	pop	ebp
	ret	0
_local_calc_rightside ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DK@NBHPKLFK@Vertex?5?$CFs?5hits?5more?5constraints?5@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_one_sided_lagrange_adjust
EXTRN	_constr_proj:PROC
EXTRN	_unset_v_constraint_status:PROC
EXTRN	_one_sided_lagrange_attr:DWORD
EXTRN	_mat_approx_solve:PROC
EXTRN	_mat_mul_tr:PROC
EXTRN	_matvec_mul:PROC
EXTRN	_kb_error:PROC
EXTRN	_errmsg:BYTE
EXTRN	_sprintf:PROC
EXTRN	_elnames:BYTE
EXTRN	_mat2d_setup:PROC
EXTRN	_raw_velocity_attr:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0DK@NBHPKLFK@Vertex?5?$CFs?5hits?5more?5constraints?5@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DK@NBHPKLFK@Vertex?5?$CFs?5hits?5more?5constraints?5@ DB 'Vertex %'
	DB	's hits more constraints than dimension of space.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\fixvol.c
CONST	ENDS
;	COMDAT _one_sided_lagrange_adjust
_TEXT	SEGMENT
_ssqXvS$ = -796						; size = 24
_gradsqXvS$ = -772					; size = 24
_value$ = -748						; size = 8
_con$ = -740						; size = 28
tv591 = -712						; size = 8
_ss$ = -708						; size = 4
_coord$ = -704						; size = 4
_grads$ = -700						; size = 4
_raw_velocity$ = -696					; size = 4
tv448 = -692						; size = 4
_loosened$ = -688					; size = 4
tv844 = -684						; size = 4
_one_sided_count$ = -684				; size = 4
_v_id$GSCopy$ = -680					; size = 4
_gradsxJ$ = -676					; size = 288
_ssxJ$ = -388						; size = 288
_lagmul$ = -100						; size = 48
_perp$89963 = -52					; size = 48
_conlist$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_one_sided_lagrange_adjust PROC				; COMDAT

; 1015 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 796				; 0000031cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _v_id$[ebp]

; 1016 :     REAL *raw_velocity = VREAL(v_id,raw_velocity_attr);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _web+104
	mov	DWORD PTR _v_id$GSCopy$[ebp], eax
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv448[ebp], eax
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _raw_velocity_attr
	imul	ecx, 240				; 000000f0H
	push	ebx
	push	esi
	add	ecx, edx
	push	edi
	mov	edi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edi+64]
	add	ecx, eax

; 1017 :     volgrad *vgptr;
; 1018 :     int bi; /* row number for constraint */
; 1019 : 
; 1020 :      conmap_t * conmap = get_v_constraint_map(v_id);

	xor	esi, esi
	mov	DWORD PTR _raw_velocity$[ebp], ecx
	cmp	DWORD PTR [edx+edi+1288], esi
	je	SHORT $LN35@one_sided_
	mov	edi, DWORD PTR [edx+edi+1264]
	add	edi, eax
	jmp	SHORT $LN36@one_sided_
$LN35@one_sided_:
	mov	edi, OFFSET _nullcon
$LN36@one_sided_:

; 1021 :      int oncount = 0;
; 1022 :      int one_sided_count = 0;
; 1023 :      struct constraint *con[MAXCONHIT];
; 1024 :      int conlist[MAXCONHIT];
; 1025 :      MAT2D(grads,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	edx, DWORD PTR _gradsxJ$[ebp]
	push	edx
	lea	eax, DWORD PTR _gradsqXvS$[ebp]
	push	eax
	mov	DWORD PTR _one_sided_count$[ebp], esi
	call	_mat2d_setup

; 1026 :      MAT2D(ss,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	ecx, DWORD PTR _ssxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ssqXvS$[ebp]
	push	edx
	mov	DWORD PTR _grads$[ebp], eax
	call	_mat2d_setup

; 1027 :      REAL lagmul[MAXCOORD];
; 1028 :      REAL *coord;
; 1029 :      int i,j,k,n;
; 1030 :      REAL value;
; 1031 :      int loosened = 0;
; 1032 : 
; 1033 :      for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	ebx, 1
	add	esp, 32					; 00000020H
	mov	DWORD PTR _ss$[ebp], eax
	mov	DWORD PTR _loosened$[ebp], esi
	cmp	DWORD PTR [edi], ebx
	jl	$LN57@one_sided_
	npad	6
$LL32@one_sided_:

; 1034 :      {
; 1035 :        if ( conmap[j] & CON_HIT_BIT )

	test	DWORD PTR [edi+ebx*4], -2147483648	; 80000000H
	je	$LN31@one_sided_

; 1036 :        { 
; 1037 :          if ( oncount >= web.sdim )

	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LN28@one_sided_

; 1038 :          { sprintf(errmsg,"Vertex %s hits more constraints than dimension of space.\n",
; 1039 :              ELNAME(v_id));

	test	DWORD PTR _v_id$GSCopy$[ebp], 268435456	; 10000000H
	je	SHORT $LN37@one_sided_
	mov	eax, DWORD PTR tv448[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN38@one_sided_
$LN37@one_sided_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN38@one_sided_:
	push	eax
	push	OFFSET ??_C@_0DK@NBHPKLFK@Vertex?5?$CFs?5hits?5more?5constraints?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1040 :            kb_error(5889,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5889					; 00001701H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN28@one_sided_:

; 1041 :          }
; 1042 :          conlist[oncount] = conmap[j] & CONMASK;

	mov	eax, DWORD PTR [edi+ebx*4]
	and	eax, 1073741823				; 3fffffffH
	mov	DWORD PTR _conlist$[ebp+esi*4], eax

; 1043 :          con[oncount] = get_constraint(conmap[j]);

	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 1044 :          if ( con[oncount]->attr & (NONNEGATIVE|NONPOSITIVE) )

	xor	ecx, ecx
	mov	DWORD PTR _con$[ebp+esi*4], eax
	mov	eax, DWORD PTR [eax+32]
	and	eax, 3
	or	eax, ecx
	je	SHORT $LN62@one_sided_

; 1045 :            one_sided_count++;

	inc	DWORD PTR _one_sided_count$[ebp]
$LN62@one_sided_:

; 1046 :          oncount++;

	inc	esi
$LN31@one_sided_:

; 1027 :      REAL lagmul[MAXCOORD];
; 1028 :      REAL *coord;
; 1029 :      int i,j,k,n;
; 1030 :      REAL value;
; 1031 :      int loosened = 0;
; 1032 : 
; 1033 :      for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	inc	ebx
	cmp	ebx, DWORD PTR [edi]
	jle	$LL32@one_sided_

; 1047 :        }
; 1048 :      }
; 1049 :     
; 1050 :      if ( one_sided_count == 0 ) 

	cmp	DWORD PTR _one_sided_count$[ebp], 0
	jne	SHORT $LN26@one_sided_
$LN57@one_sided_:
	pop	edi
	pop	esi

; 1051 :        return 0; /* nothing to do here */

	xor	eax, eax
	pop	ebx

; 1107 :      }
; 1108 : 
; 1109 :   return loosened;
; 1110 : 
; 1111 : } // end one_sided_lagrange_adjust()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@one_sided_:

; 1052 : 
; 1053 :     /* adjust raw velocity for global constraints */
; 1054 :     for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	push	edx
	call	_get_vertex_vgrad
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@one_sided_
	mov	ebx, DWORD PTR _fixcount
	npad	5
$LL25@one_sided_:

; 1055 :     { bi = vgptr->fixnum;

	mov	edx, DWORD PTR [eax]

; 1056 :       if ( (bi < 0) || (bi >= fixcount) ) 

	test	edx, edx
	js	SHORT $LN24@one_sided_
	cmp	edx, ebx
	jge	SHORT $LN24@one_sided_

; 1057 :           continue;  /* bi = -1 for killed one-sided constraints */
; 1058 : 
; 1059 :        for ( k = 0 ; k < SDIM ; k++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN24@one_sided_

; 1043 :          con[oncount] = get_constraint(conmap[j]);

	mov	edi, DWORD PTR _vpressures
	lea	edx, DWORD PTR [edi+edx*8]
	npad	3
$LL20@one_sided_:

; 1060 :          raw_velocity[k] -= vpressures[bi]*vgptr->raw_velocity[k];

	mov	edi, DWORD PTR [eax+24]
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR _raw_velocity$[ebp]
	fmul	QWORD PTR [edx]
	inc	ecx
	fsubr	QWORD PTR [edi+ecx*8-8]
	fstp	QWORD PTR [edi+ecx*8-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL20@one_sided_
$LN24@one_sided_:

; 1052 : 
; 1053 :     /* adjust raw velocity for global constraints */
; 1054 :     for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jne	SHORT $LL25@one_sided_
$LN23@one_sided_:

; 1061 :     }
; 1062 : 
; 1063 :     /* get local constraint gradients */
; 1064 :     coord = get_coord(v_id);

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR tv448[ebp]
	mov	ebx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	ebx, DWORD PTR [edx+eax+64]

; 1065 :     for ( i = 0 ; i < oncount ; i++ )

	xor	edi, edi
	mov	DWORD PTR _coord$[ebp], ebx
	test	esi, esi
	jle	SHORT $LN15@one_sided_
	mov	eax, DWORD PTR _grads$[ebp]
	lea	ecx, DWORD PTR _con$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv844[ebp], eax
	jmp	SHORT $LN17@one_sided_
	npad	11
$LL58@one_sided_:
	mov	eax, DWORD PTR tv844[ebp]
$LN17@one_sided_:

; 1066 :       eval_all(con[i]->formula,coord,SDIM,&value,grads[i],v_id);

	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	push	edx
	lea	eax, DWORD PTR [eax+edi*4]
	mov	ecx, DWORD PTR _con$[ebp+eax]
	mov	eax, DWORD PTR _web+616
	push	ecx
	mov	ecx, DWORD PTR _con$[ebp+edi*4]
	lea	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+40]
	push	eax
	push	ebx
	push	edx
	call	_eval_all
	inc	edi
	add	esp, 24					; 00000018H
	cmp	edi, esi
	jl	SHORT $LL58@one_sided_
$LN15@one_sided_:

; 1067 :     matvec_mul(grads,raw_velocity,lagmul,oncount,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR _raw_velocity$[ebp]
	mov	edi, DWORD PTR _grads$[ebp]
	push	eax
	push	esi
	lea	ecx, DWORD PTR _lagmul$[ebp]
	push	ecx
	push	edx
	push	edi
	call	_matvec_mul

; 1068 :     mat_mul_tr(grads,grads,ss,oncount,SDIM,oncount);

	mov	eax, DWORD PTR _web+616
	mov	ebx, DWORD PTR _ss$[ebp]
	push	esi
	push	eax
	push	esi
	push	ebx
	push	edi
	push	edi
	call	_mat_mul_tr

; 1069 :     mat_approx_solve(ss,oncount,lagmul);

	lea	ecx, DWORD PTR _lagmul$[ebp]
	push	ecx
	push	esi
	push	ebx
	call	_mat_approx_solve
	add	esp, 56					; 00000038H

; 1070 : 
; 1071 :     /* now inspect lagrange multipliers */
; 1072 :      for ( n = 0 ; n < oncount ;  )

	xor	ebx, ebx
	test	esi, esi
	jle	$LN60@one_sided_
	fldz
$LN14@one_sided_:

; 1073 :      {
; 1074 :          if ( one_sided_lagrange_attr >= 0 )

	mov	ecx, DWORD PTR _one_sided_lagrange_attr
	test	ecx, ecx
	js	SHORT $LN59@one_sided_

; 1075 :          { REAL *v = (REAL*)get_extra(v_id,one_sided_lagrange_attr);

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	imul	ecx, 240				; 000000f0H
	mov	edi, DWORD PTR _dymem
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	edx, ecx
	mov	edx, DWORD PTR [edx+edi+64]
	mov	edi, DWORD PTR tv448[ebp]
	add	edx, DWORD PTR [eax+edi*4]

; 1076 :            struct extra *ex = EXTRAS(VERTEX)+one_sided_lagrange_attr;
; 1077 :            int osl_size = ex->array_spec.datacount;

	add	ecx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	edi, DWORD PTR [ecx+eax+88]

; 1078 :            for ( i = 0 ; i < osl_size ; i++ )

	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN59@one_sided_
$LN11@one_sided_:

; 1079 :              if ( v[i] == 0.0 )  

	fld	QWORD PTR [edx+ecx*8]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN49@one_sided_

; 1078 :            for ( i = 0 ; i < osl_size ; i++ )

	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LN11@one_sided_

; 1079 :              if ( v[i] == 0.0 )  

	jmp	SHORT $LN59@one_sided_
$LN49@one_sided_:

; 1080 :              { v[i] = lagmul[n];    /* sign so acts like pressure */  

	fld	QWORD PTR _lagmul$[ebp+ebx*8]
	fstp	QWORD PTR [edx+ecx*8]
$LN59@one_sided_:

; 1081 :                break;
; 1082 :              }
; 1083 :          }
; 1084 : 
; 1085 :          if ( ((con[n]->attr & NONPOSITIVE) && ( lagmul[n] < 0.0 )) ||
; 1086 :               ((con[n]->attr & NONNEGATIVE) && ( lagmul[n] > 0.0 )) )         

	mov	eax, DWORD PTR _con$[ebp+ebx*4]
	mov	edx, DWORD PTR [eax+36]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, ecx
	mov	DWORD PTR tv591[ebp+4], edx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN5@one_sided_
	fcom	QWORD PTR _lagmul$[ebp+ebx*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN80@one_sided_
$LN5@one_sided_:
	and	ecx, 2
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN7@one_sided_
	fcom	QWORD PTR _lagmul$[ebp+ebx*8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN7@one_sided_
$LN80@one_sided_:

; 1087 :            { /* loosen */
; 1088 :              unset_v_constraint_status(v_id,conlist[n]);

	mov	eax, DWORD PTR _conlist$[ebp+ebx*4]
	fstp	ST(0)
	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	push	eax
	push	ecx
	call	_unset_v_constraint_status

; 1089 :              oncount--; /* replace with last in list */
; 1090 :              conlist[n] = conlist[oncount];
; 1091 :              con[n] = con[oncount];
; 1092 :              lagmul[n] = lagmul[oncount];

	fld	QWORD PTR _lagmul$[ebp+esi*8-8]
	mov	edx, DWORD PTR _conlist$[ebp+esi*4-4]
	fstp	QWORD PTR _lagmul$[ebp+ebx*8]
	mov	eax, DWORD PTR _con$[ebp+esi*4-4]

; 1093 :              loosened++;
; 1094 :              continue; /* don't increment n */

	fldz
	dec	esi
	add	esp, 8
	inc	DWORD PTR _loosened$[ebp]
	mov	DWORD PTR _conlist$[ebp+ebx*4], edx
	mov	DWORD PTR _con$[ebp+ebx*4], eax
	jmp	SHORT $LN55@one_sided_
$LN7@one_sided_:

; 1095 :            }
; 1096 :  
; 1097 :          n++;

	inc	ebx
$LN55@one_sided_:

; 1070 : 
; 1071 :     /* now inspect lagrange multipliers */
; 1072 :      for ( n = 0 ; n < oncount ;  )

	cmp	ebx, esi
	jl	$LN14@one_sided_

; 1098 :      }
; 1099 : 
; 1100 :      if ( loosened )

	cmp	DWORD PTR _loosened$[ebp], 0
	fstp	ST(0)
	je	$LN60@one_sided_

; 1101 :      { /* recalculate projected velocity */
; 1102 :        REAL perp[MAXCOORD];
; 1103 :        REAL *velocity = get_velocity(v_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR tv448[ebp]
	mov	edi, DWORD PTR [ecx+edx*4]

; 1104 :        constr_proj(TANGPROJ,oncount,con,coord,raw_velocity,perp,NULL,NO_DETECT,v_id);

	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edi, DWORD PTR [eax+ecx+1024]
	mov	ebx, DWORD PTR _raw_velocity$[ebp]
	mov	ecx, DWORD PTR _coord$[ebp]
	push	edx
	push	0
	push	0
	lea	eax, DWORD PTR _perp$89963[ebp]
	push	eax
	push	ebx
	push	ecx
	lea	edx, DWORD PTR _con$[ebp]
	push	edx
	push	esi
	push	2
	call	_constr_proj

; 1105 :        for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	add	esp, 36					; 00000024H
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN60@one_sided_
	lea	edx, DWORD PTR _perp$89963[ebp]
	mov	ecx, ebx
	sub	ecx, edx
	sub	edi, edx
$LL3@one_sided_:
	lea	edx, DWORD PTR [ecx+eax*8]

; 1106 :           velocity[j] = raw_velocity[j] - perp[j]; 

	fld	QWORD PTR _perp$89963[ebp+edx]
	lea	edx, DWORD PTR [edi+eax*8]
	fsub	QWORD PTR _perp$89963[ebp+eax*8]
	inc	eax
	fstp	QWORD PTR _perp$89963[ebp+edx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL3@one_sided_
$LN60@one_sided_:

; 1107 :      }
; 1108 : 
; 1109 :   return loosened;
; 1110 : 
; 1111 : } // end one_sided_lagrange_adjust()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, DWORD PTR _loosened$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_one_sided_lagrange_adjust ENDP
_TEXT	ENDS
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_one_sided_volume_adjust
EXTRN	_vol_restore:DWORD
; Function compile flags: /Ogtp
;	COMDAT _one_sided_volume_adjust
_TEXT	SEGMENT
_ssqXvS$ = -840						; size = 24
_gradsqXvS$ = -816					; size = 24
_value$ = -792						; size = 8
_con$ = -784						; size = 28
tv653 = -756						; size = 8
tv1198 = -752						; size = 4
tv1011 = -752						; size = 4
_grads$ = -748						; size = 4
_ss$ = -744						; size = 4
_loosened$ = -740					; size = 4
_v_id$GSCopy$ = -736					; size = 4
tv1002 = -732						; size = 4
_one_sided_count$ = -732				; size = 4
_coord$ = -728						; size = 4
_oncount$ = -728					; size = 4
_ssxJ$ = -724						; size = 288
_gradsxJ$ = -436					; size = 288
_lagmul$ = -148						; size = 48
_raw_velocity$ = -100					; size = 48
_perp$90202 = -52					; size = 48
_conlist$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_one_sided_volume_adjust PROC				; COMDAT

; 1282 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 840				; 00000348H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1283 :     REAL raw_velocity[MAXCOORD];
; 1284 :     volgrad *vgptr;
; 1285 :     int bi; /* row number for constraint */
; 1286 : 
; 1287 :      conmap_t * conmap = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _v_id$[ebp]
	push	ebx
	xor	ebx, ebx
	push	esi
	push	edi

; 1329 :          raw_velocity[k] += vol_restore[bi]*vgptr->raw_velocity[k];

	mov	DWORD PTR _v_id$GSCopy$[ebp], edx
	cmp	DWORD PTR [eax+ecx+1288], ebx
	je	SHORT $LN36@one_sided_@2

; 1283 :     REAL raw_velocity[MAXCOORD];
; 1284 :     volgrad *vgptr;
; 1285 :     int bi; /* row number for constraint */
; 1286 : 
; 1287 :      conmap_t * conmap = get_v_constraint_map(v_id);

	mov	esi, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [esi+edx*4]
	add	edi, DWORD PTR [eax+ecx+1264]
	jmp	SHORT $LN37@one_sided_@2
$LN36@one_sided_@2:
	mov	edi, OFFSET _nullcon
$LN37@one_sided_@2:

; 1288 :      int oncount = 0;
; 1289 :      int one_sided_count = 0;
; 1290 :      struct constraint *con[MAXCONHIT];
; 1291 :      int conlist[MAXCONHIT];
; 1292 :      MAT2D(grads,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _gradsxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gradsqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _one_sided_count$[ebp], ebx
	call	_mat2d_setup

; 1293 :      MAT2D(ss,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	edx, DWORD PTR _ssxJ$[ebp]
	mov	DWORD PTR _grads$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _ssqXvS$[ebp]
	push	eax
	call	_mat2d_setup

; 1294 :      REAL lagmul[MAXCOORD];
; 1295 :      REAL *coord;
; 1296 :      int i,j,k,n;
; 1297 :      REAL value;
; 1298 :      int loosened = 0;
; 1299 : 
; 1300 :      for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	esi, 1
	add	esp, 32					; 00000020H
	mov	DWORD PTR _ss$[ebp], eax
	mov	DWORD PTR _loosened$[ebp], ebx
	cmp	DWORD PTR [edi], esi
	jl	$LN4@one_sided_@2
	npad	8
$LL33@one_sided_@2:

; 1301 :      {
; 1302 :        if ( conmap[j] & CON_HIT_BIT )

	test	DWORD PTR [edi+esi*4], -2147483648	; 80000000H
	je	$LN32@one_sided_@2

; 1303 :        { 
; 1304 :          if ( oncount >= web.sdim )

	cmp	ebx, DWORD PTR _web+616
	jl	SHORT $LN29@one_sided_@2

; 1305 :          { sprintf(errmsg,"Vertex %s hits more constraints than dimension of space.\n",
; 1306 :              ELNAME(v_id));

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN38@one_sided_@2
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN39@one_sided_@2
$LN38@one_sided_@2:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN39@one_sided_@2:
	push	eax
	push	OFFSET ??_C@_0DK@NBHPKLFK@Vertex?5?$CFs?5hits?5more?5constraints?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1307 :            kb_error(5890,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5890					; 00001702H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN29@one_sided_@2:

; 1308 :          }
; 1309 :          conlist[oncount] = conmap[j] & CONMASK;

	mov	eax, DWORD PTR [edi+esi*4]
	and	eax, 1073741823				; 3fffffffH
	mov	DWORD PTR _conlist$[ebp+ebx*4], eax

; 1310 :          con[oncount] = get_constraint(conmap[j]);

	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 1311 :          if ( con[oncount]->attr & (NONNEGATIVE|NONPOSITIVE) )

	xor	ecx, ecx
	mov	DWORD PTR _con$[ebp+ebx*4], eax
	mov	eax, DWORD PTR [eax+32]
	and	eax, 3
	or	eax, ecx
	je	SHORT $LN65@one_sided_@2

; 1312 :            one_sided_count++;

	inc	DWORD PTR _one_sided_count$[ebp]
$LN65@one_sided_@2:

; 1313 :          oncount++;

	inc	ebx
$LN32@one_sided_@2:

; 1294 :      REAL lagmul[MAXCOORD];
; 1295 :      REAL *coord;
; 1296 :      int i,j,k,n;
; 1297 :      REAL value;
; 1298 :      int loosened = 0;
; 1299 : 
; 1300 :      for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	inc	esi
	cmp	esi, DWORD PTR [edi]
	jle	$LL33@one_sided_@2

; 1314 :        }
; 1315 :      }
; 1316 :     
; 1317 :      if ( one_sided_count == 0 ) 

	cmp	DWORD PTR _one_sided_count$[ebp], 0
	mov	DWORD PTR _oncount$[ebp], ebx
	je	$LN4@one_sided_@2

; 1318 :        return; /* nothing to do here */
; 1319 : 
; 1320 :     /* form volume adjust net velocity */
; 1321 :     for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	test	ecx, ecx
	jle	SHORT $LN26@one_sided_@2
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	lea	edi, DWORD PTR _raw_velocity$[ebp]
	rep stosd
$LN26@one_sided_@2:

; 1322 :       raw_velocity[i] = 0.0;
; 1323 :     for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	esi, DWORD PTR _v_id$GSCopy$[ebp]
	push	esi
	call	_get_vertex_vgrad
	add	esp, 4
	test	eax, eax
	je	$LN21@one_sided_@2
	mov	edi, DWORD PTR _vol_restore
	npad	1
$LL23@one_sided_@2:

; 1324 :     { bi = vgptr->fixnum;

	mov	esi, DWORD PTR [eax]

; 1325 :       if ( (bi < 0) || (bi >= fixcount) ) 

	test	esi, esi
	js	$LN22@one_sided_@2
	cmp	esi, DWORD PTR _fixcount
	jge	$LN22@one_sided_@2

; 1326 :           continue;  /* bi = -1 for killed one-sided constraints */
; 1327 : 
; 1328 :        for ( k = 0 ; k < SDIM ; k++ )

	xor	edx, edx
	cmp	DWORD PTR _web+616, 4
	jl	$LC58@one_sided_@2

; 1329 :          raw_velocity[k] += vol_restore[bi]*vgptr->raw_velocity[k];

	lea	ebx, DWORD PTR _raw_velocity$[ebp+8]
	mov	ecx, 16					; 00000010H
	sub	ecx, ebx
	mov	DWORD PTR tv1002[ebp], ecx
	mov	ecx, 24					; 00000018H
	sub	ecx, ebx
	mov	DWORD PTR tv1011[ebp], ecx
$LL61@one_sided_@2:
	mov	ebx, DWORD PTR [eax+24]
	fld	QWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR _raw_velocity$[ebp+edx*8+8]
	fmul	QWORD PTR [edi+esi*8]
	add	edx, 4
	fadd	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
	mov	ebx, DWORD PTR [eax+24]
	fld	QWORD PTR [ebx+edx*8-24]
	fmul	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR tv1002[ebp]
	add	edi, ecx
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+24]
	fld	QWORD PTR [edi+ebx]
	mov	edi, DWORD PTR _vol_restore
	fmul	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR tv1011[ebp]
	add	edi, ecx
	fadd	QWORD PTR [ecx+8]
	fstp	QWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [eax+24]
	fld	QWORD PTR [edi+ebx]
	mov	edi, DWORD PTR _vol_restore
	fmul	QWORD PTR [edi+esi*8]
	fadd	QWORD PTR [ecx+16]
	fstp	QWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _web+616
	add	ecx, -3					; fffffffdH
	cmp	edx, ecx
	jl	SHORT $LL61@one_sided_@2
	mov	ebx, DWORD PTR _oncount$[ebp]
$LC58@one_sided_@2:

; 1326 :           continue;  /* bi = -1 for killed one-sided constraints */
; 1327 : 
; 1328 :        for ( k = 0 ; k < SDIM ; k++ )

	cmp	edx, DWORD PTR _web+616
	jge	SHORT $LN22@one_sided_@2
	npad	5
$LC18@one_sided_@2:

; 1329 :          raw_velocity[k] += vol_restore[bi]*vgptr->raw_velocity[k];

	mov	ecx, DWORD PTR [eax+24]
	fld	QWORD PTR [ecx+edx*8]
	inc	edx
	fmul	QWORD PTR [edi+esi*8]
	fadd	QWORD PTR _raw_velocity$[ebp+edx*8-8]
	fstp	QWORD PTR _raw_velocity$[ebp+edx*8-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LC18@one_sided_@2
$LN22@one_sided_@2:

; 1322 :       raw_velocity[i] = 0.0;
; 1323 :     for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jne	$LL23@one_sided_@2
	mov	esi, DWORD PTR _v_id$GSCopy$[ebp]
$LN21@one_sided_@2:

; 1330 :     }
; 1331 : 
; 1332 :     /* get local constraint gradients */
; 1333 :     coord = get_coord(v_id);

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR _dymem
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+104
	add	eax, DWORD PTR [edx+ecx+64]

; 1334 :     for ( i = 0 ; i < oncount ; i++ )

	xor	edi, edi
	mov	DWORD PTR _coord$[ebp], eax
	test	ebx, ebx
	jle	SHORT $LN63@one_sided_@2
	mov	ecx, DWORD PTR _grads$[ebp]
	lea	edx, DWORD PTR _con$[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv1198[ebp], ecx
	jmp	SHORT $LN15@one_sided_@2
	npad	3
$LL60@one_sided_@2:
	mov	ecx, DWORD PTR tv1198[ebp]
	mov	eax, DWORD PTR _coord$[ebp]
$LN15@one_sided_@2:
	lea	ecx, DWORD PTR [ecx+edi*4]

; 1335 :       eval_all(con[i]->formula,coord,SDIM,&value,grads[i],v_id);

	mov	edx, DWORD PTR _con$[ebp+ecx]
	push	esi
	push	edx
	mov	edx, DWORD PTR _web+616
	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	push	edx
	push	eax
	mov	eax, DWORD PTR _con$[ebp+edi*4]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_eval_all
	inc	edi
	add	esp, 24					; 00000018H
	cmp	edi, ebx
	jl	SHORT $LL60@one_sided_@2
$LN63@one_sided_@2:

; 1336 :     matvec_mul(grads,raw_velocity,lagmul,oncount,SDIM);

	mov	edx, DWORD PTR _web+616
	mov	edi, DWORD PTR _grads$[ebp]
	push	edx
	push	ebx
	lea	eax, DWORD PTR _lagmul$[ebp]
	push	eax
	lea	ecx, DWORD PTR _raw_velocity$[ebp]
	push	ecx
	push	edi
	call	_matvec_mul

; 1337 :     mat_mul_tr(grads,grads,ss,oncount,SDIM,oncount);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _ss$[ebp]
	push	ebx
	push	edx
	push	ebx
	push	eax
	push	edi
	push	edi
	call	_mat_mul_tr

; 1338 :     mat_approx_solve(ss,oncount,lagmul);

	mov	edx, DWORD PTR _ss$[ebp]
	lea	ecx, DWORD PTR _lagmul$[ebp]
	push	ecx
	push	ebx
	push	edx
	call	_mat_approx_solve
	add	esp, 56					; 00000038H

; 1339 : 
; 1340 :     /* now inspect lagrange multipliers */
; 1341 :      for ( n = 0 ; n < oncount ;  )

	xor	edi, edi
	test	ebx, ebx
	jle	$LN4@one_sided_@2
	fldz
$LN12@one_sided_@2:

; 1342 :      {
; 1343 :          if ( ((con[n]->attr & NONPOSITIVE) && ( lagmul[n] < 0.0 )) ||
; 1344 :               ((con[n]->attr & NONNEGATIVE) && ( lagmul[n] > 0.0 )) )         

	mov	eax, DWORD PTR _con$[ebp+edi*4]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [eax+36]
	mov	DWORD PTR tv653[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN8@one_sided_@2
	fcom	QWORD PTR _lagmul$[ebp+edi*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN74@one_sided_@2
$LN8@one_sided_@2:
	and	ecx, 2
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN10@one_sided_@2
	fcom	QWORD PTR _lagmul$[ebp+edi*8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN10@one_sided_@2
$LN74@one_sided_@2:

; 1345 :            { /* loosen */
; 1346 :              unset_v_constraint_status(v_id,conlist[n]);

	mov	ecx, DWORD PTR _conlist$[ebp+edi*4]
	fstp	ST(0)
	push	ecx
	push	esi
	call	_unset_v_constraint_status

; 1347 :              oncount--; /* replace with last in list */
; 1348 :              conlist[n] = conlist[oncount];
; 1349 :              con[n] = con[oncount];
; 1350 :              lagmul[n] = lagmul[oncount];

	fld	QWORD PTR _lagmul$[ebp+ebx*8-8]
	mov	edx, DWORD PTR _conlist$[ebp+ebx*4-4]
	fstp	QWORD PTR _lagmul$[ebp+edi*8]
	mov	eax, DWORD PTR _con$[ebp+ebx*4-4]

; 1351 :              loosened++;
; 1352 :              continue; /* don't increment n */

	fldz
	dec	ebx
	add	esp, 8
	inc	DWORD PTR _loosened$[ebp]
	mov	DWORD PTR _conlist$[ebp+edi*4], edx
	mov	DWORD PTR _con$[ebp+edi*4], eax
	jmp	SHORT $LN54@one_sided_@2
$LN10@one_sided_@2:

; 1353 :            }
; 1354 :  
; 1355 :          n++;

	inc	edi
$LN54@one_sided_@2:

; 1339 : 
; 1340 :     /* now inspect lagrange multipliers */
; 1341 :      for ( n = 0 ; n < oncount ;  )

	cmp	edi, ebx
	jl	$LN12@one_sided_@2

; 1356 :      }
; 1357 : 
; 1358 : 
; 1359 :      if ( loosened )

	cmp	DWORD PTR _loosened$[ebp], 0
	fstp	ST(0)
	je	SHORT $LN4@one_sided_@2

; 1360 :      { /* recalculate projected velocity */
; 1361 :        REAL perp[MAXCOORD];
; 1362 :        for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	push	esi
	call	_get_vertex_vgrad
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN4@one_sided_@2
	npad	3
$LL64@one_sided_@2:

; 1363 :        { constr_proj(TANGPROJ,oncount,con,coord,vgptr->raw_velocity,perp,NULL,NO_DETECT,v_id);

	mov	edx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR _coord$[ebp]
	push	esi
	push	0
	push	0
	lea	ecx, DWORD PTR _perp$90202[ebp]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _con$[ebp]
	push	ecx
	push	ebx
	push	2
	call	_constr_proj

; 1364 :          for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	add	esp, 36					; 00000024H
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN5@one_sided_@2
	mov	ecx, DWORD PTR [edi+24]
	lea	edx, DWORD PTR _perp$90202[ebp]
	sub	ecx, edx
	mov	edx, DWORD PTR [edi+20]
	lea	esi, DWORD PTR _perp$90202[ebp]
	sub	edx, esi
$LL3@one_sided_@2:
	lea	esi, DWORD PTR [ecx+eax*8]

; 1365 :           vgptr->velocity[j] = vgptr->raw_velocity[j] - perp[j]; 

	fld	QWORD PTR _perp$90202[ebp+esi]
	lea	esi, DWORD PTR [edx+eax*8]
	fsub	QWORD PTR _perp$90202[ebp+eax*8]
	inc	eax
	fstp	QWORD PTR _perp$90202[ebp+esi]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL3@one_sided_@2

; 1364 :          for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _v_id$GSCopy$[ebp]
$LN5@one_sided_@2:

; 1360 :      { /* recalculate projected velocity */
; 1361 :        REAL perp[MAXCOORD];
; 1362 :        for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	jne	SHORT $LL64@one_sided_@2
$LN4@one_sided_@2:

; 1366 :        }
; 1367 :      }
; 1368 : 
; 1369 : } // end one_sided_volume_adjust()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_one_sided_volume_adjust ENDP
_TEXT	ENDS
PUBLIC	_vgrad_init
EXTRN	_add_attribute:PROC
EXTRN	_find_attribute:PROC
; Function compile flags: /Ogtp
;	COMDAT _vgrad_init
_TEXT	SEGMENT
_one$ = -8						; size = 4
tv392 = -4						; size = 4
_vgrad_init PROC					; COMDAT

; 1383 : { int one = 1;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _one$[ebp], 1

; 1384 :   vertex_id v_id;
; 1385 :   int i;
; 1386 :   int stride;
; 1387 : 
; 1388 :   vgrad_end();  /* take care of any leftovers */

	call	_vgrad_end

; 1389 : 
; 1390 :   /* allocate chain start for each vertex */
; 1391 :   vgrad_attr = find_attribute(VERTEX,vgrad_attr_name);

	mov	eax, DWORD PTR _vgrad_attr_name
	push	eax
	xor	edi, edi
	push	edi
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _vgrad_attr, eax

; 1392 : 
; 1393 :   if ( vgrad_attr < 0 )

	cmp	eax, edi
	jge	SHORT $LN10@vgrad_init

; 1394 :     vgrad_attr = add_attribute(VERTEX,vgrad_attr_name,PTR_TYPE,0,&one,0,NULL,MPI_PROPAGATE);

	mov	edx, DWORD PTR _vgrad_attr_name
	push	1
	push	edi
	push	edi
	lea	ecx, DWORD PTR _one$[ebp]
	push	ecx
	push	edi
	push	12					; 0000000cH
	push	edx
	push	edi
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _vgrad_attr, eax
$LN10@vgrad_init:

; 1395 : 
; 1396 :   MFOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+48
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN7@vgrad_init
	mov	ebx, DWORD PTR _web+12
$LL19@vgrad_init:
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	lea	esi, DWORD PTR [ecx+ecx]
	mov	edx, DWORD PTR [esi+ebx]
	mov	ecx, DWORD PTR [edx+8]
	and	ecx, 1
	xor	edi, edi
	or	ecx, edi
	je	SHORT $LN8@vgrad_init

; 1397 :     VPTR(v_id,vgrad_attr)[0] = NULL;

	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	DWORD PTR [edx+eax], edi
	mov	eax, DWORD PTR _vgrad_attr
	mov	ebx, DWORD PTR _web+12
$LN8@vgrad_init:

; 1395 : 
; 1396 :   MFOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [esi+ebx]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL19@vgrad_init
	xor	edi, edi
$LN7@vgrad_init:

; 1398 : 
; 1399 :   /* allocate initial block of structures, using info from last time
; 1400 :      around, plus a little margin for growth. 
; 1401 :   */
; 1402 :   vgradbase = (struct vgradblock *)temp_calloc(1,sizeof(struct vgradblock));

	push	1402					; 0000057aH
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	push	20					; 00000014H
	push	1
	call	_kb_temp_calloc

; 1403 :   vgradbase->max = vgradlastused ? (vgradlastused + vgradlastused/10) :
; 1404 :                      web.skel[VERTEX].count;

	mov	esi, DWORD PTR _vgradlastused
	add	esp, 16					; 00000010H
	mov	ecx, eax
	mov	DWORD PTR _vgradbase, ecx
	cmp	esi, edi
	je	SHORT $LN13@vgrad_init
	mov	eax, 1717986919				; 66666667H
	imul	esi
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	eax, esi
	jmp	SHORT $LN14@vgrad_init
$LN13@vgrad_init:
	mov	eax, DWORD PTR _web+64
$LN14@vgrad_init:

; 1405 :   vgradbase->base = (volgrad*)temp_calloc(vgradbase->max,sizeof(volgrad));

	push	1405					; 0000057dH
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR _vgradbase
	mov	eax, DWORD PTR [edx+8]
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	push	28					; 0000001cH
	push	eax
	call	_kb_temp_calloc
	mov	ecx, DWORD PTR _vgradbase
	mov	DWORD PTR [ecx], eax

; 1406 :   stride = one_sided_present?3:2;
; 1407 :   vgradbase->values = (REAL*)temp_calloc(vgradbase->max,stride*SDIM*sizeof(REAL));

	mov	eax, DWORD PTR _web+616
	xor	edx, edx
	cmp	DWORD PTR _one_sided_present, edi
	mov	ecx, DWORD PTR _vgradbase
	setne	dl
	push	1407					; 0000057fH
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	lea	esi, DWORD PTR [edx+2]
	mov	edx, DWORD PTR [ecx+8]
	imul	eax, esi
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	edx
	call	_kb_temp_calloc
	mov	ecx, DWORD PTR _vgradbase
	mov	DWORD PTR [ecx+4], eax

; 1408 :   for ( i = 0 ; i < vgradbase->max ; i++ )

	mov	ecx, DWORD PTR _vgradbase
	add	esp, 32					; 00000020H
	xor	edx, edx
	cmp	DWORD PTR [ecx+8], edi
	jle	$LN2@vgrad_init

; 1403 :   vgradbase->max = vgradlastused ? (vgradlastused + vgradlastused/10) :
; 1404 :                      web.skel[VERTEX].count;

	xor	eax, eax
	mov	DWORD PTR tv392[ebp], 2
$LL4@vgrad_init:

; 1409 :   { vgradbase->base[i].grad = vgradbase->values + stride*i*SDIM;

	mov	edi, DWORD PTR _web+616
	mov	ebx, DWORD PTR [ecx+4]
	imul	edi, edx
	mov	ecx, DWORD PTR [ecx]
	imul	edi, esi
	lea	edi, DWORD PTR [ebx+edi*8]
	mov	DWORD PTR [eax+ecx+16], edi

; 1410 :     vgradbase->base[i].velocity = vgradbase->values + (stride*i+1)*SDIM;

	mov	ecx, DWORD PTR tv392[ebp]
	mov	ebx, DWORD PTR _vgradbase
	mov	ebx, DWORD PTR [ebx+4]
	lea	edi, DWORD PTR [ecx-1]
	imul	edi, DWORD PTR _web+616
	lea	edi, DWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR _vgradbase
	mov	ebx, DWORD PTR [ebx]
	mov	DWORD PTR [eax+ebx+20], edi

; 1411 :     if ( one_sided_present )

	cmp	DWORD PTR _one_sided_present, 0
	je	SHORT $LN3@vgrad_init

; 1412 :       vgradbase->base[i].raw_velocity = vgradbase->values + (stride*i+2)*SDIM;

	mov	ebx, DWORD PTR _vgradbase
	mov	ebx, DWORD PTR [ebx+4]
	mov	edi, ecx
	imul	edi, DWORD PTR _web+616
	lea	edi, DWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR _vgradbase
	mov	ebx, DWORD PTR [ebx]
	mov	DWORD PTR [eax+ebx+24], edi
$LN3@vgrad_init:

; 1408 :   for ( i = 0 ; i < vgradbase->max ; i++ )

	add	ecx, esi
	mov	DWORD PTR tv392[ebp], ecx
	mov	ecx, DWORD PTR _vgradbase
	inc	edx
	add	eax, 28					; 0000001cH
	cmp	edx, DWORD PTR [ecx+8]
	jl	SHORT $LL4@vgrad_init
	xor	edi, edi
$LN2@vgrad_init:

; 1413 :   }
; 1414 :   vgradbase->top = 0;

	mov	DWORD PTR [ecx+12], edi

; 1415 :   vgradbase->next = NULL;

	mov	edx, DWORD PTR _vgradbase
	mov	DWORD PTR [edx+16], edi

; 1416 :   vgradtop = 0;

	mov	DWORD PTR _vgradtop, edi

; 1417 :   vgradmax = 0;

	mov	DWORD PTR _vgradmax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1418 :   
; 1419 : } /* end vgrad_init() */

	mov	esp, ebp
	pop	ebp
	ret	0
_vgrad_init ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_local_calc_volgrads
EXTRN	_b_proj:PROC
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	_film_constr_grad:PROC
EXTRN	_string_constr_grad:PROC
EXTRN	_unsave_coords:PROC
EXTRN	_set_body_volume:PROC
EXTRN	_restore_coords:PROC
EXTRN	_calc_content:PROC
EXTRN	_project_all:PROC
EXTRN	_eval:PROC
EXTRN	_localbase:DWORD
EXTRN	_optparam:BYTE
EXTRN	_save_coords:PROC
EXTRN	_optparamcount:DWORD
EXTRN	_calc_quant_grads:PROC
EXTRN	_film_grad:DWORD
EXTRN	_string_grad:DWORD
EXTRN	_simplex_grad_l:PROC
EXTRN	_quantities_only_flag:DWORD
;	COMDAT __real@3fe0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\fixvol.c
CONST	ENDS
;	COMDAT _local_calc_volgrads
_TEXT	SEGMENT
_aqXvS$ = -1236						; size = 24
tv1208 = -1212						; size = 8
tv1395 = -1204						; size = 8
tv1165 = -1204						; size = 8
_dp$89122 = -1204					; size = 8
_a$ = -1196						; size = 4
tv1389 = -1192						; size = 4
_i$ = -1192						; size = 4
_convalues$89091 = -1188				; size = 4
_vgptri$89249 = -1184					; size = 4
_v_id$ = -1184						; size = 4
_g$89123 = -1184					; size = 4
_n$ = -1184						; size = 4
_osaved$89092 = -1180					; size = 840
_axJ$ = -340						; size = 288
_tmp$89268 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_mode$ = 8						; size = 4
_local_calc_volgrads PROC				; COMDAT

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1236				; 000004d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 82   :   body_id bi_id;  /* identifier for body i */
; 83   :   vertex_id v_id;
; 84   :   int i,k,n;
; 85   :   struct boundary *bdry;
; 86   :   int qfixed = 0;
; 87   :   struct gen_quant *gq;
; 88   :   MAT2D(a,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _axJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _aqXvS$[ebp]
	push	ecx
	call	_mat2d_setup

; 89   : 
; 90   :   /* for numbering various types of constraints */
; 91   :   gen_quant_start = web.skel[BODY].max_ord + 1;

	mov	ebx, DWORD PTR _web+404
	inc	ebx
	add	esp, 16					; 00000010H

; 92   :  
; 93   :   /* see if anything needs to be done */
; 94   :   fixed_constraint_flag = 0;
; 95   :   if ( !web.pressure_flag && !everything_quantities_flag )

	cmp	DWORD PTR _web+868, 0
	mov	DWORD PTR _a$[ebp], eax
	mov	DWORD PTR _gen_quant_start, ebx
	mov	DWORD PTR _fixed_constraint_flag, 0
	jne	SHORT $LN116@local_calc@3
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN116@local_calc@3

; 96   :   { FOR_ALL_BODIES(bi_id)

	mov	eax, DWORD PTR _web+384
	test	eax, 268435456				; 10000000H
	je	SHORT $LN116@local_calc@3
	mov	edi, DWORD PTR _web+348
$LL118@local_calc@3:
	and	eax, 134217727				; 07ffffffH
	lea	esi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	mov	DWORD PTR tv1165[ebp+4], edx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN117@local_calc@3

; 97   :      if ( get_battr(bi_id) & (FIXEDVOL|PRESSURE) ) fixed_constraint_flag = 1;

	and	ecx, 2080				; 00000820H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN117@local_calc@3
	mov	DWORD PTR _fixed_constraint_flag, 1
$LN117@local_calc@3:

; 96   :   { FOR_ALL_BODIES(bi_id)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL118@local_calc@3
$LN116@local_calc@3:

; 98   :   }
; 99   :   for ( k = n = 0 ; n < gen_quant_count ; n++ )

	xor	edi, edi
	mov	DWORD PTR _n$[ebp], edi
	cmp	DWORD PTR _web+5528, edi
	jle	SHORT $LN110@local_calc@3
	mov	esi, DWORD PTR _gen_quant_list
	mov	ecx, ebx
	xor	eax, eax
	npad	3
$LL230@local_calc@3:

; 100  :   { gq = GEN_QUANT(n);
; 101  :     if ( gq->flags & Q_DELETED ) continue;

	mov	edx, DWORD PTR [eax+esi+136]
	test	edx, 524288				; 00080000H
	jne	SHORT $LN111@local_calc@3

; 102  :     if ( gq->flags & (Q_FIXED|Q_CONSERVED) )

	test	dl, 10					; 0000000aH
	je	SHORT $LN111@local_calc@3

; 103  :     { if ( !valid_id(gq->b_id) || !web.pressure_flag ) 

	test	DWORD PTR [eax+esi+216], 268435456	; 10000000H
	je	SHORT $LN106@local_calc@3
	cmp	DWORD PTR _web+868, 0

; 106  :       }
; 107  :       else 
; 108  :         if ( web.pressure_flag )
; 109  :           gq->vol_number = gen_quant_start + k++;

	jne	SHORT $LN290@local_calc@3
$LN106@local_calc@3:

; 104  :       { fixed_constraint_flag = 1; qfixed++;

	mov	DWORD PTR _fixed_constraint_flag, 1
$LN290@local_calc@3:

; 105  :         gq->vol_number = gen_quant_start + k++;

	mov	DWORD PTR [eax+esi+220], ecx
	mov	esi, DWORD PTR _gen_quant_list
	inc	edi
	inc	ecx
$LN111@local_calc@3:

; 98   :   }
; 99   :   for ( k = n = 0 ; n < gen_quant_count ; n++ )

	inc	DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _web+5528
	add	eax, 368				; 00000170H
	cmp	DWORD PTR _n$[ebp], edx
	jl	SHORT $LL230@local_calc@3
$LN110@local_calc@3:

; 110  :     }
; 111  :   }
; 112  :   maxquants = gen_quant_start + k;

	add	ebx, edi

; 113  :   if ( !web.pressure_flag && !fixed_constraint_flag && !one_sided_present )

	cmp	DWORD PTR _web+868, 0
	mov	DWORD PTR _maxquants, ebx
	jne	SHORT $LN103@local_calc@3
	cmp	DWORD PTR _fixed_constraint_flag, 0
	jne	SHORT $LN103@local_calc@3
	cmp	DWORD PTR _one_sided_present, 0
	je	$LN13@local_calc@3
$LN103@local_calc@3:

; 114  :     return;
; 115  : 
; 116  :   /* allocate space to hold vertex body volume gradients */
; 117  :   vgrad_init();

	call	_vgrad_init

; 118  : 
; 119  :   /* calculate body volume gradients at all control points 
; 120  :       due to free surfaces */
; 121  :   if ( !quantities_only_flag )

	cmp	DWORD PTR _quantities_only_flag, 0
	jne	SHORT $LN231@local_calc@3

; 122  :   { if ( web.representation == SIMPLEX ) 

	mov	eax, DWORD PTR _web+624
	cmp	eax, 3
	jne	SHORT $LN101@local_calc@3

; 123  :       simplex_grad_l();

	call	_simplex_grad_l
	jmp	SHORT $LN231@local_calc@3
$LN101@local_calc@3:

; 124  :     else if ( web.representation == STRING )

	cmp	eax, 1
	jne	SHORT $LN99@local_calc@3

; 125  :       (*string_grad)();

	call	DWORD PTR _string_grad

; 126  :     else /* web.representation == SOAPFILM */

	jmp	SHORT $LN231@local_calc@3
$LN99@local_calc@3:

; 127  :       (*film_grad)();

	call	DWORD PTR _film_grad
$LN231@local_calc@3:

; 128  :   }
; 129  :   calc_quant_grads(Q_FIXED|Q_CONSERVED);

	push	10					; 0000000aH
	call	_calc_quant_grads
	add	esp, 4

; 130  : 
; 131  :   // calc_one_sided_grads();  /* no, doing one-sided lagranges after others */
; 132  : 
; 133  :   /* calculate optimizing_parameter gradients by finite differences */
; 134  :   if ( (mode == DO_OPTS) && (optparamcount > 0) )

	cmp	DWORD PTR _mode$[ebp], 1
	jne	$LN97@local_calc@3
	cmp	DWORD PTR _optparamcount, 0
	jle	$LN97@local_calc@3

; 135  :   {  REAL **convalues; 
; 136  :      struct oldcoord osaved;
; 137  : 
; 138  :      if ( optparam_congrads ) free_matrix(optparam_congrads);

	mov	eax, DWORD PTR _optparam_congrads
	test	eax, eax
	je	SHORT $LN96@local_calc@3
	push	eax
	call	_free_matrix
	add	esp, 4
$LN96@local_calc@3:

; 139  :      optparam_congrads = dmatrix(0,optparamcount,0,maxquants);

	mov	eax, DWORD PTR _maxquants
	mov	ecx, DWORD PTR _optparamcount
	push	139					; 0000008bH
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	push	eax
	push	0
	push	ecx
	push	0
	call	_kb_dmatrix

; 140  :      convalues = dmatrix(0,maxquants,0,2);

	mov	edx, DWORD PTR _maxquants
	push	140					; 0000008cH
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	push	2
	push	0
	push	edx
	push	0
	mov	DWORD PTR _optparam_congrads, eax
	call	_kb_dmatrix
	mov	edi, eax

; 141  :      osaved.coord = NULL;
; 142  :      save_coords(&osaved,SAVE_SEPARATE);

	lea	eax, DWORD PTR _osaved$89092[ebp]
	push	2
	push	eax
	mov	DWORD PTR _convalues$89091[ebp], edi
	mov	DWORD PTR _osaved$89092[ebp], 0
	call	_save_coords
	add	esp, 56					; 00000038H

; 143  :      /* save values */
; 144  :      if ( !web.pressure_flag && !everything_quantities_flag )

	cmp	DWORD PTR _web+868, 0
	jne	$LN207@local_calc@3
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN207@local_calc@3

; 145  :      { FOR_ALL_BODIES(bi_id)

	mov	edx, DWORD PTR _web+384
	mov	ebx, edx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	je	SHORT $LN207@local_calc@3
	fldz
$LN227@local_calc@3:
	mov	ecx, DWORD PTR _web+348
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR tv1208[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN93@local_calc@3

; 146  :         if ( get_battr(bi_id) & FIXEDVOL ) 

	and	ecx, 32					; 00000020H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN93@local_calc@3

; 147  :           convalues[loc_ordinal(bi_id)][0] = get_body_volume(bi_id);

	test	ebx, ebx
	je	SHORT $LN122@local_calc@3
	fld	QWORD PTR [esi+40]
	mov	eax, edx
	jmp	SHORT $LN159@local_calc@3
$LN122@local_calc@3:
	or	eax, -1
	fld	ST(0)
$LN159@local_calc@3:
	mov	ecx, DWORD PTR _convalues$89091[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [eax]
$LN93@local_calc@3:

; 145  :      { FOR_ALL_BODIES(bi_id)

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [edx]
	mov	ebx, edx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	jne	SHORT $LN227@local_calc@3
	mov	edi, DWORD PTR _convalues$89091[ebp]
	fstp	ST(0)
$LN207@local_calc@3:

; 148  :      }
; 149  :      for ( k = n = 0 ; n < gen_quant_count ; n++ )

	xor	edx, edx
	cmp	DWORD PTR _web+5528, edx
	jle	SHORT $LN86@local_calc@3
	mov	eax, DWORD PTR _gen_quant_list
	add	eax, 136				; 00000088H
	mov	esi, 268435456				; 10000000H
$LL88@local_calc@3:

; 150  :      { gq = GEN_QUANT(n);
; 151  :        if ( gq->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN87@local_calc@3

; 152  :        if ( gq->flags & Q_FIXED )

	test	cl, 2
	je	SHORT $LN87@local_calc@3

; 153  :          if ( !valid_id(gq->b_id) || !web.pressure_flag ) 

	test	DWORD PTR [eax+80], esi
	je	SHORT $LN82@local_calc@3
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN87@local_calc@3
$LN82@local_calc@3:

; 154  :            convalues[gq->vol_number][0] = gq->value;

	mov	ecx, DWORD PTR [eax+84]
	fld	QWORD PTR [eax+16]
	mov	ecx, DWORD PTR [edi+ecx*4]
	fstp	QWORD PTR [ecx]
$LN87@local_calc@3:

; 148  :      }
; 149  :      for ( k = n = 0 ; n < gen_quant_count ; n++ )

	inc	edx
	add	eax, 368				; 00000170H
	cmp	edx, DWORD PTR _web+5528
	jl	SHORT $LL88@local_calc@3
$LN86@local_calc@3:

; 155  :      }
; 156  :      for ( i = 0 ; i < optparamcount ; i++ )

	cmp	DWORD PTR _optparamcount, 0
	mov	DWORD PTR _i$[ebp], 0
	jle	$LN79@local_calc@3
$LL81@local_calc@3:

; 157  :      { REAL dp;
; 158  :        struct global *g = globals(optparam[i].pnum);

	mov	eax, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _optparam[edx*8]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN124@local_calc@3
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN126@local_calc@3
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	shl	esi, 5
	add	esi, DWORD PTR [ecx]
	jmp	SHORT $LN291@local_calc@3
$LN126@local_calc@3:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN124@local_calc@3
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN291@local_calc@3
$LN124@local_calc@3:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax]
$LN291@local_calc@3:

; 159  : 
; 160  :        dp = g->attr.varstuff.delta;

	fld	QWORD PTR [esi+168]

; 161  : 
; 162  :        /* right difference */
; 163  :        g->value.real += dp;
; 164  :        if ( g->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [esi+188]
	fst	QWORD PTR _dp$89122[ebp]
	mov	DWORD PTR _g$89123[ebp], esi
	fadd	QWORD PTR [esi+64]
	fstp	QWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN78@local_calc@3

; 165  :        { struct  global *gg = globals(g->attr.varstuff.on_assign_call);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN130@local_calc@3
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN132@local_calc@3
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _localbase
	shl	eax, 5
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN131@local_calc@3
$LN132@local_calc@3:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN130@local_calc@3
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN131@local_calc@3
$LN130@local_calc@3:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN131@local_calc@3:

; 166  :          eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	add	esp, 16					; 00000010H
$LN78@local_calc@3:

; 167  :        }
; 168  :        project_all(0, TEST_MOVE);

	push	0
	push	0
	call	_project_all

; 169  :        calc_content(Q_FIXED);

	push	2
	call	_calc_content
	fstp	ST(0)
	add	esp, 12					; 0000000cH

; 170  :        /* save values */
; 171  :        if (!web.pressure_flag &&  !everything_quantities_flag )

	cmp	DWORD PTR _web+868, 0
	jne	$LN74@local_calc@3
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN74@local_calc@3

; 172  :        { FOR_ALL_BODIES(bi_id)

	mov	edx, DWORD PTR _web+384
	mov	ebx, edx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	je	SHORT $LN74@local_calc@3
	fldz
$LN218@local_calc@3:
	mov	ecx, DWORD PTR _web+348
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR tv1208[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN75@local_calc@3

; 173  :            if ( get_battr(bi_id) & FIXEDVOL ) 

	and	ecx, 32					; 00000020H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN75@local_calc@3

; 174  :              convalues[loc_ordinal(bi_id)][1] = get_body_volume(bi_id);

	test	ebx, ebx
	je	SHORT $LN136@local_calc@3
	fld	QWORD PTR [esi+40]
	mov	eax, edx
	jmp	SHORT $LN163@local_calc@3
$LN136@local_calc@3:
	or	eax, -1
	fld	ST(0)
$LN163@local_calc@3:
	mov	ecx, DWORD PTR _convalues$89091[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [eax+8]
$LN75@local_calc@3:

; 172  :        { FOR_ALL_BODIES(bi_id)

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [edx]
	mov	ebx, edx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	jne	SHORT $LN218@local_calc@3
	mov	esi, DWORD PTR _g$89123[ebp]
	fstp	ST(0)
$LN74@local_calc@3:

; 175  :        }
; 176  :        for ( k = n = 0 ; n < gen_quant_count ; n++ )

	xor	edx, edx
	cmp	DWORD PTR _web+5528, edx
	jle	SHORT $LN221@local_calc@3
	mov	eax, DWORD PTR _gen_quant_list
	mov	edi, DWORD PTR _convalues$89091[ebp]
	add	eax, 136				; 00000088H
$LL70@local_calc@3:

; 177  :        { gq = GEN_QUANT(n);
; 178  :          if ( gq->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN69@local_calc@3

; 179  :          if ( gq->flags & Q_FIXED )

	test	cl, 2
	je	SHORT $LN69@local_calc@3

; 180  :            if ( !valid_id(gq->b_id) || !web.pressure_flag )

	test	DWORD PTR [eax+80], 268435456		; 10000000H
	je	SHORT $LN64@local_calc@3
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN69@local_calc@3
$LN64@local_calc@3:

; 181  :              convalues[gq->vol_number][1] = gq->value;

	mov	ecx, DWORD PTR [eax+84]
	fld	QWORD PTR [eax+16]
	mov	ecx, DWORD PTR [edi+ecx*4]
	fstp	QWORD PTR [ecx+8]
$LN69@local_calc@3:

; 175  :        }
; 176  :        for ( k = n = 0 ; n < gen_quant_count ; n++ )

	inc	edx
	add	eax, 368				; 00000170H
	cmp	edx, DWORD PTR _web+5528
	jl	SHORT $LL70@local_calc@3
$LN221@local_calc@3:

; 182  :        }
; 183  :        restore_coords(&osaved,SAVE_SEPARATE);  /* also fixes opt params */

	lea	edx, DWORD PTR _osaved$89092[ebp]
	push	2
	push	edx
	call	_restore_coords

; 184  : 
; 185  :       /* left difference */
; 186  :        g->value.real -= dp;

	fld	QWORD PTR [esi+64]
	fsub	QWORD PTR _dp$89122[ebp]

; 187  :        if ( g->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [esi+188]
	add	esp, 8
	fstp	QWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN63@local_calc@3

; 188  :        { struct  global *gg = globals(g->attr.varstuff.on_assign_call);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN138@local_calc@3
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN140@local_calc@3
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _localbase
	shl	eax, 5
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN139@local_calc@3
$LN140@local_calc@3:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN138@local_calc@3
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN139@local_calc@3
$LN138@local_calc@3:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN139@local_calc@3:

; 189  :          eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	add	esp, 16					; 00000010H
$LN63@local_calc@3:

; 190  :        }
; 191  :        project_all(0, TEST_MOVE);

	push	0
	push	0
	call	_project_all
	add	esp, 8

; 192  :        if ( fixed_constraint_flag || web.pressure_flag || web.pressflag )

	cmp	DWORD PTR _fixed_constraint_flag, 0
	jne	SHORT $LN61@local_calc@3
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN61@local_calc@3
	cmp	DWORD PTR _web+844, 0
	je	SHORT $LN206@local_calc@3
$LN61@local_calc@3:

; 193  :          calc_content(Q_FIXED);

	push	2
	call	_calc_content
	fstp	ST(0)
	add	esp, 4

; 194  :        /* save values */
; 195  :        if (!web.pressure_flag &&  !everything_quantities_flag )

	cmp	DWORD PTR _web+868, 0
	jne	$LN57@local_calc@3
$LN206@local_calc@3:
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN57@local_calc@3

; 196  :        { FOR_ALL_BODIES(bi_id)

	mov	edx, DWORD PTR _web+384
	mov	ebx, edx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	je	SHORT $LN57@local_calc@3
	fldz
$LN215@local_calc@3:
	mov	ecx, DWORD PTR _web+348
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR tv1208[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN58@local_calc@3

; 197  :            if ( get_battr(bi_id) & FIXEDVOL ) 

	and	ecx, 32					; 00000020H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN58@local_calc@3

; 198  :              convalues[loc_ordinal(bi_id)][2] = get_body_volume(bi_id);

	test	ebx, ebx
	je	SHORT $LN144@local_calc@3
	fld	QWORD PTR [esi+40]
	mov	eax, edx
	jmp	SHORT $LN167@local_calc@3
$LN144@local_calc@3:
	or	eax, -1
	fld	ST(0)
$LN167@local_calc@3:
	mov	ecx, DWORD PTR _convalues$89091[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [eax+16]
$LN58@local_calc@3:

; 196  :        { FOR_ALL_BODIES(bi_id)

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [edx]
	mov	ebx, edx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	jne	SHORT $LN215@local_calc@3
	fstp	ST(0)
$LN57@local_calc@3:

; 199  :        }
; 200  :        for ( k = n = 0 ; n < gen_quant_count ; n++ )

	xor	edx, edx
	mov	edi, 268435456				; 10000000H
	cmp	DWORD PTR _web+5528, edx
	jle	SHORT $LN51@local_calc@3
	mov	eax, DWORD PTR _gen_quant_list
	mov	esi, DWORD PTR _convalues$89091[ebp]
	add	eax, 136				; 00000088H
$LL53@local_calc@3:

; 201  :        { gq = GEN_QUANT(n);
; 202  :          if ( gq->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN52@local_calc@3

; 203  :          if ( gq->flags & Q_FIXED )

	test	cl, 2
	je	SHORT $LN52@local_calc@3

; 204  :           if ( !valid_id(gq->b_id) || !web.pressure_flag )

	test	DWORD PTR [eax+80], edi
	je	SHORT $LN47@local_calc@3
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN52@local_calc@3
$LN47@local_calc@3:

; 205  :             convalues[gq->vol_number][2] = gq->value;

	mov	ecx, DWORD PTR [eax+84]
	fld	QWORD PTR [eax+16]
	mov	ecx, DWORD PTR [esi+ecx*4]
	fstp	QWORD PTR [ecx+16]
$LN52@local_calc@3:

; 199  :        }
; 200  :        for ( k = n = 0 ; n < gen_quant_count ; n++ )

	inc	edx
	add	eax, 368				; 00000170H
	cmp	edx, DWORD PTR _web+5528
	jl	SHORT $LL53@local_calc@3
$LN51@local_calc@3:

; 206  :        }
; 207  :        restore_coords(&osaved,SAVE_SEPARATE);  /* also fixes opt params */

	lea	edx, DWORD PTR _osaved$89092[ebp]
	push	2
	push	edx
	call	_restore_coords
	add	esp, 8

; 208  :    
; 209  :        /* calculate gradients */
; 210  :        if (!web.pressure_flag &&  !everything_quantities_flag )

	cmp	DWORD PTR _web+868, 0
	jne	$LN210@local_calc@3
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	$LN210@local_calc@3

; 211  :        { FOR_ALL_BODIES(bi_id)

	mov	edx, DWORD PTR _web+384
	mov	esi, edx
	shr	esi, 28					; 0000001cH
	and	esi, 1
	je	$LN210@local_calc@3
	npad	5
$LL45@local_calc@3:
	mov	eax, DWORD PTR _web+348
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv1208[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN44@local_calc@3

; 212  :            if ( get_battr(bi_id) & FIXEDVOL ) 

	and	ecx, 32					; 00000020H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN44@local_calc@3

; 213  :              optparam_congrads[i][loc_ordinal(bi_id)] =
; 214  :                (convalues[loc_ordinal(bi_id)][1] -
; 215  :                   convalues[loc_ordinal(bi_id)][2])/2/dp;

	test	esi, esi
	je	SHORT $LN148@local_calc@3
	mov	esi, edx
	mov	ecx, edx
	mov	eax, edx
	jmp	SHORT $LN147@local_calc@3
$LN148@local_calc@3:
	or	esi, -1
	or	ecx, esi
	or	eax, esi
$LN147@local_calc@3:
	mov	ebx, DWORD PTR _convalues$89091[ebp]
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	ecx, DWORD PTR [ebx+ecx*4]
	fld	QWORD PTR [esi+8]
	fsub	QWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _optparam_congrads
	mov	esi, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _dp$89122[ebp]
	fstp	QWORD PTR [ecx+eax*8]
$LN44@local_calc@3:

; 211  :        { FOR_ALL_BODIES(bi_id)

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx]
	mov	esi, edx
	shr	esi, 28					; 0000001cH
	and	esi, 1
	jne	$LL45@local_calc@3
$LN210@local_calc@3:

; 216  :        }
; 217  :        for ( k = n = 0 ; n < gen_quant_count ; n++ )

	mov	ebx, DWORD PTR _i$[ebp]
	xor	esi, esi
	cmp	DWORD PTR _web+5528, esi
	jle	SHORT $LN80@local_calc@3
	mov	edx, DWORD PTR _gen_quant_list
	fld	QWORD PTR _dp$89122[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	add	edx, 220				; 000000dcH
$LN39@local_calc@3:

; 218  :        { gq = GEN_QUANT(n);
; 219  :          if ( gq->flags & Q_DELETED ) continue;

	mov	eax, DWORD PTR [edx-84]
	test	eax, 524288				; 00080000H
	jne	SHORT $LN38@local_calc@3

; 220  :          if ( gq->flags & Q_FIXED )

	test	al, 2
	je	SHORT $LN38@local_calc@3

; 221  :           if ( !valid_id(gq->b_id) || !web.pressure_flag )

	test	DWORD PTR [edx-4], edi
	je	SHORT $LN33@local_calc@3
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN38@local_calc@3
$LN33@local_calc@3:

; 222  :           { optparam_congrads[i][gq->vol_number] =
; 223  :              (convalues[gq->vol_number][1]-convalues[gq->vol_number][2])/2/dp;

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _convalues$89091[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [ecx+8]
	fsub	QWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _optparam_congrads
	mov	ecx, DWORD PTR [ecx+ebx*4]
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [ecx+eax*8]
$LN38@local_calc@3:

; 216  :        }
; 217  :        for ( k = n = 0 ; n < gen_quant_count ; n++ )

	inc	esi
	add	edx, 368				; 00000170H
	cmp	esi, DWORD PTR _web+5528
	jl	SHORT $LN39@local_calc@3
	fstp	ST(1)
	fstp	ST(0)
$LN80@local_calc@3:

; 155  :      }
; 156  :      for ( i = 0 ; i < optparamcount ; i++ )

	inc	ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, DWORD PTR _optparamcount
	jl	$LL81@local_calc@3
$LN79@local_calc@3:

; 224  :           }
; 225  :        }
; 226  :       }
; 227  :       /* restore values */
; 228  :       if (!web.pressure_flag &&  !everything_quantities_flag )

	cmp	DWORD PTR _web+868, 0
	jne	$LN223@local_calc@3
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	$LN223@local_calc@3

; 229  :       { FOR_ALL_BODIES(bi_id)

	mov	edx, DWORD PTR _web+384
	mov	ebx, edx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	je	SHORT $LN223@local_calc@3
	npad	2
$LL235@local_calc@3:
	mov	eax, DWORD PTR _web+348
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+esi*4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv1208[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN30@local_calc@3

; 230  :           if ( get_battr(bi_id) & FIXEDVOL ) 

	and	ecx, 32					; 00000020H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN30@local_calc@3

; 231  :            set_body_volume(bi_id, convalues[loc_ordinal(bi_id)][0],SETSTAMP);

	test	ebx, ebx
	je	SHORT $LN152@local_calc@3
	mov	eax, esi
	jmp	SHORT $LN153@local_calc@3
$LN152@local_calc@3:
	or	eax, -1
$LN153@local_calc@3:
	mov	ecx, DWORD PTR _convalues$89091[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [eax]
	push	1
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	call	_set_body_volume
	add	esp, 16					; 00000010H
$LN30@local_calc@3:

; 229  :       { FOR_ALL_BODIES(bi_id)

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	edx, DWORD PTR [edx]
	mov	ebx, edx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	jne	SHORT $LL235@local_calc@3
$LN223@local_calc@3:

; 232  :       }
; 233  :       for ( k = n = 0 ; n < gen_quant_count ; n++ )

	xor	esi, esi
	cmp	DWORD PTR _web+5528, esi
	jle	SHORT $LN23@local_calc@3
	mov	ecx, DWORD PTR _gen_quant_list
	mov	edi, DWORD PTR _convalues$89091[ebp]
	xor	eax, eax
	mov	ebx, 268435456				; 10000000H
	npad	7
$LL25@local_calc@3:

; 234  :       { gq = GEN_QUANT(n);
; 235  :         if ( gq->flags & Q_DELETED ) continue;

	mov	edx, DWORD PTR [eax+ecx+136]
	test	edx, 524288				; 00080000H
	jne	SHORT $LN24@local_calc@3

; 236  :         if ( gq->flags & Q_FIXED )

	test	dl, 2
	je	SHORT $LN24@local_calc@3

; 237  :           if ( !valid_id(gq->b_id) || !web.pressure_flag )

	test	DWORD PTR [eax+ecx+216], ebx
	je	SHORT $LN19@local_calc@3
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN24@local_calc@3
$LN19@local_calc@3:

; 238  :             gq->value = convalues[gq->vol_number][2];

	mov	edx, DWORD PTR [eax+ecx+220]
	mov	edx, DWORD PTR [edi+edx*4]
	fld	QWORD PTR [edx+16]
	fstp	QWORD PTR [eax+ecx+152]
	mov	ecx, DWORD PTR _gen_quant_list
$LN24@local_calc@3:

; 232  :       }
; 233  :       for ( k = n = 0 ; n < gen_quant_count ; n++ )

	inc	esi
	add	eax, 368				; 00000170H
	cmp	esi, DWORD PTR _web+5528
	jl	SHORT $LL25@local_calc@3
$LN23@local_calc@3:

; 239  :       }
; 240  :       free_matrix(convalues);

	mov	eax, DWORD PTR _convalues$89091[ebp]
	push	eax
	call	_free_matrix

; 241  :       unsave_coords(&osaved,SAVE_SEPARATE);

	lea	ecx, DWORD PTR _osaved$89092[ebp]
	push	2
	push	ecx
	call	_unsave_coords
	add	esp, 12					; 0000000cH
$LN97@local_calc@3:

; 243  : 
; 244  :   /* add on gradients due to constraint integrals */
; 245  :   if ( !quantities_only_flag )

	cmp	DWORD PTR _quantities_only_flag, 0
	jne	SHORT $LN16@local_calc@3

; 246  :   { if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN17@local_calc@3

; 247  :      { 
; 248  :        string_constr_grad();

	call	_string_constr_grad
$LN17@local_calc@3:

; 249  :        film_constr_grad();  /* for quantities */
; 250  :      }
; 251  :      else /* web.representation == SOAPFILM */
; 252  :      { 
; 253  :        film_constr_grad();

	call	_film_constr_grad
$LN16@local_calc@3:

; 254  :      }
; 255  :   } 
; 256  :   /* project to parameter space for boundary points */
; 257  :   FOR_ALL_VERTICES(v_id)

	mov	ebx, DWORD PTR _web+48
	mov	DWORD PTR _v_id$[ebp], ebx
	test	ebx, 268435456				; 10000000H
	je	$LN13@local_calc@3
	npad	1
$LL224@local_calc@3:
	mov	edx, DWORD PTR _web+12
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv1395[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv1389[ebp], edi
	je	$LN14@local_calc@3

; 258  :   { int pcount;
; 259  :     volgrad *vgptri;
; 260  : 
; 261  :     if ( get_vattr(v_id) & FIXED ) continue;

	mov	eax, ecx
	and	eax, 64					; 00000040H
	or	eax, esi
	jne	$LN14@local_calc@3

; 262  :     if ( !(get_vattr(v_id) & BOUNDARY) ) continue;

	and	ecx, 128				; 00000080H
	or	ecx, eax
	je	$LN14@local_calc@3

; 263  :     bdry = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	mov	ecx, DWORD PTR _web+104
	test	eax, eax
	je	SHORT $LN154@local_calc@3
	mov	esi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, ecx
	mov	eax, DWORD PTR [eax+esi+64]
	mov	eax, DWORD PTR [eax+edx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN155@local_calc@3
$LN154@local_calc@3:
	xor	eax, eax
$LN155@local_calc@3:

; 264  :     pcount = bdry->pcount;

	mov	esi, DWORD PTR [eax+40]

; 265  :     b_proj(bdry,get_param(v_id),a,PARAMPROJ,v_id);

	push	ebx
	mov	ebx, DWORD PTR _a$[ebp]
	push	1
	push	ebx
	mov	ebx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+ebx+544]
	add	ecx, edx
	push	ecx
	push	eax
	call	_b_proj

; 266  :    
; 267  :     vgptri = get_vertex_vgrad(v_id);

	mov	edx, DWORD PTR _v_id$[ebp]
	push	edx
	call	_get_vertex_vgrad
	mov	ebx, eax
	add	esp, 24					; 00000018H
	mov	DWORD PTR _vgptri$89249[ebp], eax

; 268  :     while ( vgptri )

	test	ebx, ebx
	je	$LN14@local_calc@3
	mov	edx, DWORD PTR _web+616
	npad	3
$LL8@local_calc@3:

; 269  :     { REAL tmp[MAXCOORD];
; 270  :       int m;
; 271  :       matvec_mul(a,vgptri->grad,tmp,pcount,SDIM);

	mov	ecx, DWORD PTR [ebx+16]
	push	edx
	mov	edx, DWORD PTR _a$[ebp]
	push	esi
	lea	eax, DWORD PTR _tmp$89268[ebp]
	push	eax
	push	ecx
	push	edx
	call	_matvec_mul
	add	esp, 20					; 00000014H

; 272  :       for ( m = 0 ; m < pcount ; m++ ) vgptri->grad[m] = tmp[m];

	xor	ecx, ecx
	cmp	esi, 4
	jl	SHORT $LC203@local_calc@3

; 242  :   } /* end optimizing parameters */

	mov	edx, DWORD PTR [ebx+16]
	lea	eax, DWORD PTR [edx+16]

; 272  :       for ( m = 0 ; m < pcount ; m++ ) vgptri->grad[m] = tmp[m];

	neg	edx
	lea	ebx, DWORD PTR _tmp$89268[ebp+edx]
	lea	edi, DWORD PTR [esi-3]
	lea	edx, DWORD PTR _tmp$89268[ebp+edx+8]
$LL204@local_calc@3:
	fld	QWORD PTR _tmp$89268[ebp+ecx*8]
	add	ecx, 4
	fstp	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	fld	QWORD PTR _tmp$89268[ebp+ecx*8-24]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [ebx+eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx+eax-32]
	fstp	QWORD PTR [eax-24]
	cmp	ecx, edi
	jl	SHORT $LL204@local_calc@3
	mov	ebx, DWORD PTR _vgptri$89249[ebp]
$LC203@local_calc@3:
	cmp	ecx, esi
	jge	SHORT $LN214@local_calc@3
	mov	edx, DWORD PTR [ebx+16]
	lea	edi, DWORD PTR _tmp$89268[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	sub	edi, edx
	mov	edx, esi
	sub	edx, ecx
$LC6@local_calc@3:
	fld	QWORD PTR [edi+eax]
	add	eax, 8
	dec	edx
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC6@local_calc@3
$LN214@local_calc@3:

; 273  :       for ( m = pcount ; m < SDIM ; m++ )

	mov	edx, DWORD PTR _web+616
	mov	ecx, esi
	cmp	esi, edx
	jge	SHORT $LN1@local_calc@3
	mov	eax, DWORD PTR [ebx+16]
	fldz
	lea	eax, DWORD PTR [eax+esi*8]
$LN3@local_calc@3:

; 274  :            vgptri->grad[m] = 0.0;

	fst	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	inc	ecx
	add	eax, 8
	cmp	ecx, edx
	jl	SHORT $LN3@local_calc@3

; 273  :       for ( m = pcount ; m < SDIM ; m++ )

	fstp	ST(0)
$LN1@local_calc@3:

; 275  :       vgptri = vgptri->chain;

	mov	ebx, DWORD PTR [ebx+12]
	mov	DWORD PTR _vgptri$89249[ebp], ebx
	test	ebx, ebx
	jne	$LL8@local_calc@3

; 268  :     while ( vgptri )

	mov	edi, DWORD PTR tv1389[ebp]
$LN14@local_calc@3:

; 254  :      }
; 255  :   } 
; 256  :   /* project to parameter space for boundary points */
; 257  :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [edi+ecx]
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR _v_id$[ebp], ebx
	test	ebx, 268435456				; 10000000H
	jne	$LL224@local_calc@3
$LN13@local_calc@3:

; 276  :     }
; 277  :   }
; 278  : 
; 279  : } /* end local_calc_volgrads() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_local_calc_volgrads ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_0DE@GHICNFDE@Perhaps?5constraint?5is?5not?5applie@ ; `string'
PUBLIC	??_C@_0EA@CFJIIJGK@Degrees?5of?5freedom?0?5?$CFd?0?5is?5less?5@ ; `string'
PUBLIC	??_C@_0DD@GDOLBPIA@calc_leftside?$CI?$CJ?3?5for?5finding?5Lag@ ; `string'
PUBLIC	_calc_leftside
EXTRN	_LD_factor:PROC
EXTRN	_ysmp_factor:PROC
EXTRN	_mkl_factor:PROC
EXTRN	_ysmp_flag:DWORD
EXTRN	_sp_hash_end:PROC
EXTRN	_hessian_epsilon:QWORD
EXTRN	_sp_hash_init:PROC
_BSS	SEGMENT
_calc_leftside_hash_count DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_0DE@GHICNFDE@Perhaps?5constraint?5is?5not?5applie@
CONST	SEGMENT
??_C@_0DE@GHICNFDE@Perhaps?5constraint?5is?5not?5applie@ DB 'Perhaps cons'
	DB	'traint is not applied to any elements?', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@CFJIIJGK@Degrees?5of?5freedom?0?5?$CFd?0?5is?5less?5@
CONST	SEGMENT
??_C@_0EA@CFJIIJGK@Degrees?5of?5freedom?0?5?$CFd?0?5is?5less?5@ DB 'Degre'
	DB	'es of freedom, %d, is less than number of constraints, %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GDOLBPIA@calc_leftside?$CI?$CJ?3?5for?5finding?5Lag@
CONST	SEGMENT
??_C@_0DD@GDOLBPIA@calc_leftside?$CI?$CJ?3?5for?5finding?5Lag@ DB 'calc_l'
	DB	'eftside(): for finding Lagrange multipliers', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _calc_leftside
_TEXT	SEGMENT
_old_hessian_epsilon$89624 = -32			; size = 8
_volj$89605 = -28					; size = 4
_voli$89597 = -24					; size = 4
tv931 = -20						; size = 4
tv827 = -20						; size = 4
tv981 = -16						; size = 4
tv802 = -16						; size = 4
tv992 = -12						; size = 4
_NV$89573 = -12						; size = 4
tv825 = -8						; size = 4
_j$ = -8						; size = 4
tv829 = -4						; size = 4
_i$ = -4						; size = 4
_calc_leftside PROC					; COMDAT

; 582  : { int i,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx

; 583  :   int bi,bj;
; 584  : 
; 585  :   if ( itdebug ) 

	xor	ebx, ebx
	push	esi
	push	edi
	cmp	DWORD PTR _itdebug, ebx
	je	SHORT $LN47@calc_lefts

; 586  :       outstring("calc_leftside(): for finding Lagrange multipliers\n");

	push	OFFSET ??_C@_0DD@GDOLBPIA@calc_leftside?$CI?$CJ?3?5for?5finding?5Lag@
	call	_outstring
	add	esp, 4
$LN47@calc_lefts:

; 587  : 
; 588  :   degfree = 0;

	mov	DWORD PTR _degfree, ebx

; 589  : 
; 590  :   /* set up matrices for DV^T DV */
; 591  :   if ( sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, ebx
	je	SHORT $LN46@calc_lefts

; 592  :   { memset(&LS,0,sizeof(LS));

	push	232					; 000000e8H
	push	ebx
	push	OFFSET _LS
	call	_memset

; 593  :     sp_hash_init(&LS,calc_leftside_hash_count);

	mov	eax, DWORD PTR _calc_leftside_hash_count
	push	eax
	push	OFFSET _LS
	call	_sp_hash_init
	add	esp, 20					; 00000014H

; 594  :   }
; 595  :   else

	jmp	SHORT $LN45@calc_lefts
$LN46@calc_lefts:

; 596  :   {
; 597  :     rleftside = dmatrix(0,fixcount,0,fixcount);

	mov	eax, DWORD PTR _fixcount
	push	597					; 00000255H
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	push	eax
	push	ebx
	push	eax
	push	ebx
	call	_kb_dmatrix
	add	esp, 24					; 00000018H
	mov	DWORD PTR _rleftside, eax
$LN45@calc_lefts:

; 598  :   }
; 599  : 
; 600  :   #ifdef MPI_EVOLVER
; 601  :   if ( sparse_constraints_flag ) 
; 602  :     kb_error(3381,"Cannot do sparse constraints yet in MPI.\n",RECOVERABLE);
; 603  :   mpi_calc_leftside(fixcount);
; 604  :   #else
; 605  :   local_calc_leftside();

	call	_local_calc_leftside

; 606  :   #endif
; 607  : 
; 608  :   if ( approx_curve_flag )
; 609  :   { int NV = SDIM*(1+web.skel[VERTEX].max_ord);

	mov	eax, DWORD PTR _gen_quant_list
	cmp	DWORD PTR _approx_curve_flag, ebx
	je	$LN44@calc_lefts
	mov	ecx, DWORD PTR _web+68

; 610  : 
; 611  :     /*  dot products */
; 612  :     for ( bi = 0 ; bi <= maxquants ; bi++ )

	mov	edx, DWORD PTR _maxquants
	inc	ecx
	imul	ecx, DWORD PTR _web+616
	mov	DWORD PTR _NV$89573[ebp], ecx
	cmp	edx, ebx
	jl	$LN41@calc_lefts

; 606  :   #endif
; 607  : 
; 608  :   if ( approx_curve_flag )
; 609  :   { int NV = SDIM*(1+web.skel[VERTEX].max_ord);

	mov	DWORD PTR tv825[ebp], ebx
	mov	DWORD PTR tv827[ebp], 1
	mov	DWORD PTR tv829[ebp], ebx
	npad	11
$LL43@calc_lefts:

; 613  :     { int fixi = GEN_QUANT(bi)->fixnum;

	mov	ecx, DWORD PTR tv829[ebp]
	mov	edi, DWORD PTR [ecx+eax+224]

; 614  :       if ( fixi < 0 ) continue;

	test	edi, edi
	js	$LN42@calc_lefts

; 615  :       /* self product */ 
; 616  :       if ( sparse_constraints_flag ) 

	cmp	DWORD PTR _sparse_constraints_flag, 0

; 617  :        { sp_hash_search(&LS,fixi,fixi,dot(vgev[bi],vgef[bi],NV)); 

	mov	edx, DWORD PTR _NV$89573[ebp]
	push	edx
	je	SHORT $LN39@calc_lefts
	mov	ecx, DWORD PTR _vgef
	mov	eax, DWORD PTR tv825[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _vgev
	push	edx
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	call	_dot
	fstp	QWORD PTR [esp+4]
	add	esp, 4
	push	edi
	push	edi
	push	OFFSET _LS
	call	_sp_hash_search
	add	esp, 20					; 00000014H

; 618  :        }
; 619  :       else

	jmp	SHORT $LN38@calc_lefts
$LN39@calc_lefts:

; 620  :          rleftside[fixi][fixi] += dot(vgev[fixi],vgef[fixi],NV); 

	mov	eax, DWORD PTR _rleftside
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _vgef
	mov	edx, DWORD PTR _vgev
	lea	esi, DWORD PTR [ecx+edi*8]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [edx+edi*4]
	push	ecx
	push	eax
	call	_dot
	fadd	QWORD PTR [esi]
	add	esp, 12					; 0000000cH
	fstp	QWORD PTR [esi]
$LN38@calc_lefts:

; 621  :       for ( bj = bi+1 ; bj <= maxquants ; bj++ ) /* other products */

	mov	ebx, DWORD PTR tv827[ebp]
	mov	edx, DWORD PTR _maxquants
	mov	eax, DWORD PTR _gen_quant_list
	cmp	ebx, edx
	jg	$LN42@calc_lefts
	mov	ecx, DWORD PTR tv829[ebp]
	add	ecx, 368				; 00000170H
	mov	DWORD PTR tv802[ebp], ecx
	npad	1
$LL37@calc_lefts:

; 622  :       { int fixj = GEN_QUANT(bj)->fixnum;

	mov	edx, DWORD PTR tv802[ebp]
	mov	esi, DWORD PTR [edx+eax+224]

; 623  :         REAL tmp;
; 624  :         if ( fixj < 0 ) continue;

	test	esi, esi
	js	SHORT $LN36@calc_lefts

; 625  :         tmp = dot(vgev[bi],vgef[bj],NV);

	mov	ecx, DWORD PTR _vgef
	mov	eax, DWORD PTR _NV$89573[ebp]
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR tv825[ebp]
	push	eax
	mov	eax, DWORD PTR _vgev
	push	edx
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	_dot
	add	esp, 12					; 0000000cH

; 626  :          if ( sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, 0
	je	SHORT $LN33@calc_lefts

; 627  :          {  if ( fixi < fixj ) sp_hash_search(&LS,fixi,fixj,tmp);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	cmp	edi, esi
	jge	SHORT $LN32@calc_lefts
	push	esi
	push	edi
	push	OFFSET _LS
	call	_sp_hash_search
	add	esp, 20					; 00000014H
	jmp	SHORT $LN121@calc_lefts
$LN32@calc_lefts:

; 628  :             else sp_hash_search(&LS,fixj,fixi,tmp);

	push	edi
	push	esi
	push	OFFSET _LS
	call	_sp_hash_search
	add	esp, 20					; 00000014H

; 629  :          }
; 630  :          else

	jmp	SHORT $LN121@calc_lefts
$LN33@calc_lefts:

; 631  :          { rleftside[fixi][fixj] += tmp;

	mov	eax, DWORD PTR _rleftside
	mov	ecx, DWORD PTR [eax+edi*4]
	fld	QWORD PTR [ecx+esi*8]
	lea	eax, DWORD PTR [ecx+esi*8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax]

; 632  :            rleftside[fixj][fixi] += tmp;

	mov	edx, DWORD PTR _rleftside
	mov	eax, DWORD PTR [edx+esi*4]
	fadd	QWORD PTR [eax+edi*8]
	lea	eax, DWORD PTR [eax+edi*8]
	fstp	QWORD PTR [eax]
$LN121@calc_lefts:
	mov	eax, DWORD PTR _gen_quant_list
$LN36@calc_lefts:

; 621  :       for ( bj = bi+1 ; bj <= maxquants ; bj++ ) /* other products */

	mov	edx, DWORD PTR _maxquants
	add	DWORD PTR tv802[ebp], 368		; 00000170H
	inc	ebx
	cmp	ebx, edx
	jle	$LL37@calc_lefts
$LN42@calc_lefts:

; 610  : 
; 611  :     /*  dot products */
; 612  :     for ( bi = 0 ; bi <= maxquants ; bi++ )

	mov	ecx, DWORD PTR tv827[ebp]
	add	DWORD PTR tv829[ebp], 368		; 00000170H
	add	DWORD PTR tv825[ebp], 4
	inc	ecx
	mov	DWORD PTR tv827[ebp], ecx
	dec	ecx
	cmp	ecx, edx
	jle	$LL43@calc_lefts
	mov	ecx, DWORD PTR _NV$89573[ebp]
	xor	ebx, ebx
$LN41@calc_lefts:

; 633  :          }
; 634  :        }
; 635  :      }
; 636  :      degfree += NV;

	add	DWORD PTR _degfree, ecx
$LN44@calc_lefts:

; 637  :   }  /* end approx_curve_flag */
; 638  : 
; 639  :   /* variable_parameter contributions */
; 640  :   if ( optparamcount )

	cmp	DWORD PTR _optparamcount, ebx
	je	$LN79@calc_lefts

; 641  :   for ( i = 0 ; i < gen_quant_count ; i++ )

	mov	ecx, DWORD PTR _web+5528
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ecx, ebx
	jle	$LN79@calc_lefts
	mov	DWORD PTR tv992[ebp], ebx
	npad	7
$LL28@calc_lefts:

; 642  :   { struct gen_quant *q = GEN_QUANT(i);
; 643  :     int fixi = q->fixnum;

	mov	edx, DWORD PTR tv992[ebp]

; 644  :     int voli = q->vol_number;
; 645  :     if ( q->flags & Q_DELETED ) continue;

	test	DWORD PTR [edx+eax+136], 524288		; 00080000H
	mov	edi, DWORD PTR [edx+eax+220]
	mov	esi, DWORD PTR [edx+eax+224]
	mov	DWORD PTR _voli$89597[ebp], edi
	jne	$LN27@calc_lefts

; 646  :     if ( fixi < 0 ) continue;

	test	esi, esi
	js	$LN27@calc_lefts

; 647  :     for ( j = 0 ; j < gen_quant_count ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	test	ecx, ecx
	jle	$LN27@calc_lefts
	mov	DWORD PTR tv981[ebp], 0
	npad	13
$LL23@calc_lefts:

; 648  :     { struct gen_quant *qj = GEN_QUANT(j);
; 649  :       int fixj = qj->fixnum;

	mov	edx, DWORD PTR tv981[ebp]

; 650  :       int volj = qj->vol_number;
; 651  :       if ( qj->flags & Q_DELETED ) continue;

	test	DWORD PTR [edx+eax+136], 524288		; 00080000H
	mov	ebx, DWORD PTR [edx+eax+220]
	mov	edi, DWORD PTR [edx+eax+224]
	mov	DWORD PTR _volj$89605[ebp], ebx
	jne	$LN22@calc_lefts

; 652  :       if ( fixj < 0 ) continue;

	test	edi, edi
	js	$LN22@calc_lefts

; 653  :       for ( k = 0 ; k < optparamcount ; k++ )

	xor	ebx, ebx
	cmp	DWORD PTR _optparamcount, ebx
	jle	$LN22@calc_lefts
	mov	DWORD PTR tv931[ebp], OFFSET _optparam
$LL18@calc_lefts:

; 654  :       { REAL tmp = optparam_congrads[k][voli]
; 655  :             *globals(optparam[k].pnum)->attr.varstuff.pscale*optparam_congrads[k][volj];

	mov	ecx, DWORD PTR tv931[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN50@calc_lefts
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN52@calc_lefts
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN51@calc_lefts
$LN52@calc_lefts:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN50@calc_lefts
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN51@calc_lefts
$LN50@calc_lefts:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN51@calc_lefts:

; 656  :         if ( sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, 0
	mov	edx, DWORD PTR _optparam_congrads
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR _voli$89597[ebp]
	fld	QWORD PTR [ecx+edx*8]
	fmul	QWORD PTR [eax+176]
	mov	eax, DWORD PTR _volj$89605[ebp]
	fmul	QWORD PTR [ecx+eax*8]
	je	SHORT $LN15@calc_lefts

; 657  :         {  if ( fixi < fixj ) 

	cmp	esi, edi
	jge	SHORT $LN122@calc_lefts

; 658  :              sp_hash_search(&LS,fixi,fixj,tmp);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	push	esi
	push	OFFSET _LS
	call	_sp_hash_search
	add	esp, 20					; 00000014H
	jmp	SHORT $LN17@calc_lefts
$LN122@calc_lefts:

; 659  :            else if ( fixi == fixj )

	jne	SHORT $LN97@calc_lefts

; 660  :            { sp_hash_search(&LS,fixi,fixi,tmp); }

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	esi
	push	esi
	push	OFFSET _LS
	call	_sp_hash_search
	add	esp, 20					; 00000014H
	jmp	SHORT $LN17@calc_lefts
$LN15@calc_lefts:

; 661  :         }
; 662  :         else rleftside[fixi][fixj] += tmp;

	mov	ecx, DWORD PTR _rleftside
	mov	edx, DWORD PTR [ecx+esi*4]
	fadd	QWORD PTR [edx+edi*8]
	lea	eax, DWORD PTR [edx+edi*8]
	fstp	QWORD PTR [eax]
	jmp	SHORT $LN17@calc_lefts
$LN97@calc_lefts:
	fstp	ST(0)
$LN17@calc_lefts:

; 653  :       for ( k = 0 ; k < optparamcount ; k++ )

	add	DWORD PTR tv931[ebp], 56		; 00000038H
	inc	ebx
	cmp	ebx, DWORD PTR _optparamcount
	jl	$LL18@calc_lefts
	mov	ecx, DWORD PTR _web+5528
	mov	eax, DWORD PTR _gen_quant_list
$LN22@calc_lefts:

; 647  :     for ( j = 0 ; j < gen_quant_count ; j++ )

	mov	edx, DWORD PTR _j$[ebp]
	add	DWORD PTR tv981[ebp], 368		; 00000170H
	inc	edx
	mov	DWORD PTR _j$[ebp], edx
	cmp	edx, ecx
	jl	$LL23@calc_lefts
$LN27@calc_lefts:

; 641  :   for ( i = 0 ; i < gen_quant_count ; i++ )

	mov	edx, DWORD PTR _i$[ebp]
	add	DWORD PTR tv992[ebp], 368		; 00000170H
	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, ecx
	jl	$LL28@calc_lefts
	xor	ebx, ebx
$LN79@calc_lefts:

; 663  :       }
; 664  :     }
; 665  :   }
; 666  :   degfree += optparamcount;

	mov	eax, DWORD PTR _degfree
	add	eax, DWORD PTR _optparamcount

; 667  :   
; 668  :   #ifndef MPI_EVOLVER
; 669  :   if ( degfree < fixcount ) 

	mov	edi, DWORD PTR _fixcount
	mov	DWORD PTR _degfree, eax
	cmp	eax, edi
	jge	SHORT $LN81@calc_lefts

; 670  :   { sprintf(errmsg,
; 671  :        "Degrees of freedom, %d, is less than number of constraints, %d\n",
; 672  :        degfree,fixcount);

	push	edi
	push	eax
	push	OFFSET ??_C@_0EA@CFJIIJGK@Degrees?5of?5freedom?0?5?$CFd?0?5is?5less?5@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 16					; 00000010H

; 673  :     if ( degfree == 0 )

	cmp	DWORD PTR _degfree, ebx
	jne	SHORT $LN9@calc_lefts

; 674  :       strcat(errmsg,"Perhaps constraint is not applied to any elements?\n");

	mov	edi, OFFSET _errmsg
	dec	edi
$LL75@calc_lefts:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL75@calc_lefts
	mov	ecx, 13					; 0000000dH
	mov	esi, OFFSET ??_C@_0DE@GHICNFDE@Perhaps?5constraint?5is?5not?5applie@
	rep movsd
$LN9@calc_lefts:

; 675  :     kb_error(3004,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3004					; 00000bbcH
	call	_kb_error
	mov	edi, DWORD PTR _fixcount
	add	esp, 12					; 0000000cH
$LN81@calc_lefts:

; 676  :   }
; 677  :   #endif
; 678  :   
; 679  :   /* solve for coefficients */
; 680  :   if ( sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, ebx
	je	SHORT $LN8@calc_lefts

; 681  :   { REAL old_hessian_epsilon = hessian_epsilon;

	fld	QWORD PTR _hessian_epsilon

; 682  :     calc_leftside_hash_count = sp_hash_end(&LS,fixcount,fixcount,A_OFF);

	push	1
	push	edi
	fstp	QWORD PTR _old_hessian_epsilon$89624[ebp]
	push	edi
	push	OFFSET _LS
	call	_sp_hash_end

; 683  :     LS.N = fixcount; 
; 684  :     hessian_epsilon = 0.0;

	fldz
	add	esp, 16					; 00000010H
	fstp	QWORD PTR _hessian_epsilon

; 685  :     if ( ysmp_flag == MKL_FACTORING )

	cmp	DWORD PTR _ysmp_flag, 3
	mov	DWORD PTR _calc_leftside_hash_count, eax
	mov	eax, DWORD PTR _fixcount

; 686  :       mkl_factor(&LS,MKL_POS_DEF);

	push	2
	mov	DWORD PTR _LS+4, eax
	push	OFFSET _LS
	jne	SHORT $LN7@calc_lefts
	call	_mkl_factor

; 689  :     hessian_epsilon = old_hessian_epsilon;

	fld	QWORD PTR _old_hessian_epsilon$89624[ebp]

; 695  :     LD_factor(rleftside,fixcount);   

	add	esp, 8
	fstp	QWORD PTR _hessian_epsilon
	pop	edi
	pop	esi
	pop	ebx

; 696  :   }
; 697  : 
; 698  : } /* end calc_leftside() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@calc_lefts:

; 687  :     else
; 688  :       ysmp_factor(&LS,MKL_POS_DEF);  /* since mindeg uses vertex info at the moment */

	call	_ysmp_factor

; 689  :     hessian_epsilon = old_hessian_epsilon;

	fld	QWORD PTR _old_hessian_epsilon$89624[ebp]

; 695  :     LD_factor(rleftside,fixcount);   

	add	esp, 8
	fstp	QWORD PTR _hessian_epsilon
	pop	edi
	pop	esi
	pop	ebx

; 696  :   }
; 697  : 
; 698  : } /* end calc_leftside() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@calc_lefts:

; 690  :   }
; 691  :   else
; 692  :   { for ( k = 0 ; k < fixcount ; k++ )

	fldz
	xor	ecx, ecx
	fld1
	cmp	edi, 4
	jl	SHORT $LC69@calc_lefts
	mov	edx, DWORD PTR _rleftside
	lea	ebx, DWORD PTR [edi-3]
	add	edx, 8
$LN74@calc_lefts:
	mov	eax, DWORD PTR [edx-8]

; 693  :       if ( rleftside[k][k] == 0.0 ) 

	fld	QWORD PTR [eax+ecx*8]
	lea	esi, DWORD PTR [eax+ecx*8]
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN70@calc_lefts

; 694  :         rleftside[k][k] = 1.0; /* for invertibility */

	fst	QWORD PTR [esi]
$LN70@calc_lefts:

; 693  :       if ( rleftside[k][k] == 0.0 ) 

	mov	eax, DWORD PTR [edx-4]
	fld	QWORD PTR [eax+ecx*8+8]
	lea	esi, DWORD PTR [eax+ecx*8+8]
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN71@calc_lefts

; 694  :         rleftside[k][k] = 1.0; /* for invertibility */

	fst	QWORD PTR [esi]
$LN71@calc_lefts:

; 693  :       if ( rleftside[k][k] == 0.0 ) 

	mov	eax, DWORD PTR [edx]
	fld	QWORD PTR [eax+ecx*8+16]
	lea	esi, DWORD PTR [eax+ecx*8+16]
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN72@calc_lefts

; 694  :         rleftside[k][k] = 1.0; /* for invertibility */

	fst	QWORD PTR [esi]
$LN72@calc_lefts:

; 693  :       if ( rleftside[k][k] == 0.0 ) 

	mov	eax, DWORD PTR [edx+4]
	fld	QWORD PTR [eax+ecx*8+24]
	lea	esi, DWORD PTR [eax+ecx*8+24]
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN73@calc_lefts

; 694  :         rleftside[k][k] = 1.0; /* for invertibility */

	fst	QWORD PTR [esi]
$LN73@calc_lefts:
	add	ecx, 4

; 690  :   }
; 691  :   else
; 692  :   { for ( k = 0 ; k < fixcount ; k++ )

	add	edx, 16					; 00000010H
	cmp	ecx, ebx
	jl	SHORT $LN74@calc_lefts
$LC69@calc_lefts:
	cmp	ecx, edi
	jge	SHORT $LN120@calc_lefts
$LC4@calc_lefts:
	mov	edx, DWORD PTR _rleftside
	mov	eax, DWORD PTR [edx+ecx*4]

; 693  :       if ( rleftside[k][k] == 0.0 ) 

	fld	QWORD PTR [eax+ecx*8]
	lea	edx, DWORD PTR [eax+ecx*8]
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@calc_lefts

; 694  :         rleftside[k][k] = 1.0; /* for invertibility */

	fst	QWORD PTR [edx]
$LN3@calc_lefts:
	inc	ecx

; 690  :   }
; 691  :   else
; 692  :   { for ( k = 0 ; k < fixcount ; k++ )

	cmp	ecx, edi
	jl	SHORT $LC4@calc_lefts
$LN120@calc_lefts:

; 695  :     LD_factor(rleftside,fixcount);   

	mov	ecx, DWORD PTR _rleftside
	fstp	ST(1)
	push	edi
	fstp	ST(0)
	push	ecx
	call	_LD_factor
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 696  :   }
; 697  : 
; 698  : } /* end calc_leftside() */

	mov	esp, ebp
	pop	ebp
	ret	0
_calc_leftside ENDP
_TEXT	ENDS
PUBLIC	??_C@_0HA@KMLAAKJ@Constraint?5adjustment?5matrix?5sin@ ; `string'
PUBLIC	__real@7e37e43c8800759c
PUBLIC	__real@fe37e43c8800759c
PUBLIC	??_C@_0CM@HHCGCHKB@calc_lagrange?$CI?$CJ?3?5find?5Lagrange?5m@ ; `string'
PUBLIC	_calc_lagrange
EXTRN	_LD_solve:PROC
EXTRN	_ysmp_solve:PROC
EXTRN	_mkl_solve:PROC
;	COMDAT ??_C@_0HA@KMLAAKJ@Constraint?5adjustment?5matrix?5sin@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0HA@KMLAAKJ@Constraint?5adjustment?5matrix?5sin@ DB 'Constraint adj'
	DB	'ustment matrix singular. ', 0aH, 'More constraints than degre'
	DB	'es of freedom?', 0aH, 'Constraints with no elements?', 00H ; `string'
CONST	ENDS
;	COMDAT __real@7e37e43c8800759c
CONST	SEGMENT
__real@7e37e43c8800759c DQ 07e37e43c8800759cr	; 1e+300
CONST	ENDS
;	COMDAT __real@fe37e43c8800759c
CONST	SEGMENT
__real@fe37e43c8800759c DQ 0fe37e43c8800759cr	; -1e+300
CONST	ENDS
;	COMDAT ??_C@_0CM@HHCGCHKB@calc_lagrange?$CI?$CJ?3?5find?5Lagrange?5m@
CONST	SEGMENT
??_C@_0CM@HHCGCHKB@calc_lagrange?$CI?$CJ?3?5find?5Lagrange?5m@ DB 'calc_l'
	DB	'agrange(): find Lagrange multipliers', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\fixvol.c
CONST	ENDS
;	COMDAT _calc_lagrange
_TEXT	SEGMENT
tv414 = -8						; size = 8
_i$ = -4						; size = 4
_calc_lagrange PROC					; COMDAT

; 763  : { int i,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 764  :   body_id b_id;
; 765  :   struct gen_quant *gq;
; 766  : 
; 767  :   if ( fixcount == 0 ) return;

	cmp	DWORD PTR _fixcount, 0
	je	$LN5@calc_lagra

; 768  : 
; 769  :   if ( itdebug ) 

	cmp	DWORD PTR _itdebug, 0
	je	SHORT $LN35@calc_lagra

; 770  :     outstring("calc_lagrange(): find Lagrange multipliers\n");

	push	OFFSET ??_C@_0CM@HHCGCHKB@calc_lagrange?$CI?$CJ?3?5find?5Lagrange?5m@
	call	_outstring
	add	esp, 4
$LN35@calc_lagra:

; 771  : 
; 772  :   calc_leftside();  /* set up rleftside in factored form */

	push	ebx
	push	esi
	push	edi
	call	_calc_leftside

; 773  : 
; 774  :   rightside = (REAL*)temp_calloc(maxquants,sizeof(REAL));

	mov	eax, DWORD PTR _maxquants
	push	774					; 00000306H
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc

; 775  :   vpressures = (REAL*)temp_calloc(maxquants,sizeof(REAL));

	mov	ecx, DWORD PTR _maxquants
	push	775					; 00000307H
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	push	8
	push	ecx
	mov	DWORD PTR _rightside, eax
	call	_kb_temp_calloc
	add	esp, 32					; 00000020H
	mov	DWORD PTR _vpressures, eax

; 776  : 
; 777  :   #ifdef MPI_EVOLVER
; 778  :   mpi_calc_rightside(maxquants);
; 779  :   #else
; 780  :   local_calc_rightside();

	call	_local_calc_rightside

; 781  :   #endif
; 782  : 
; 783  :   /* optimizing_parameter contributions */
; 784  :   if ( optparamcount )

	mov	edi, DWORD PTR _optparamcount
	test	edi, edi
	je	$LN63@calc_lagra

; 785  :   for ( i = 0 ; i < gen_quant_count ; i++ )

	cmp	DWORD PTR _web+5528, 0
	mov	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN63@calc_lagra
	mov	ebx, DWORD PTR _gen_quant_list
	add	ebx, 220				; 000000dcH
	npad	4
$LL33@calc_lagra:

; 786  :   { struct gen_quant *q = GEN_QUANT(i);
; 787  :     int fixi = q->fixnum;
; 788  :     int voli = q->vol_number;
; 789  :     if ( q->flags & Q_DELETED ) continue;

	test	DWORD PTR [ebx-84], 524288		; 00080000H
	mov	ecx, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR [ebx]
	jne	SHORT $LN32@calc_lagra

; 790  :     if ( fixi < 0 ) continue;

	test	ecx, ecx
	js	SHORT $LN32@calc_lagra

; 791  :     for ( k = 0 ; k < optparamcount ; k++ )

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN32@calc_lagra
	mov	edx, DWORD PTR _rightside
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	ecx, OFFSET _optparam+16
	npad	10
$LL28@calc_lagra:

; 792  :       rightside[fixi] -= optparam_congrads[k][voli]*optparam[k].velocity;

	mov	edi, DWORD PTR _optparam_congrads
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+esi*8]
	inc	eax
	fmul	QWORD PTR [ecx]
	add	ecx, 56					; 00000038H
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edi, DWORD PTR _optparamcount
	cmp	eax, edi
	jl	SHORT $LL28@calc_lagra
$LN32@calc_lagra:

; 785  :   for ( i = 0 ; i < gen_quant_count ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	ebx, 368				; 00000170H
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _web+5528
	jl	SHORT $LL33@calc_lagra
$LN63@calc_lagra:

; 793  :       /* negative since using grad, not force */ 
; 794  :   }
; 795  : 
; 796  :   /* solve for coefficients */
; 797  :   if ( sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, 0
	je	SHORT $LN25@calc_lagra

; 798  :   { if ( ysmp_flag == MKL_FACTORING )

	cmp	DWORD PTR _ysmp_flag, 3

; 799  :       mkl_solve(&LS,rightside,vpressures,MKL_POS_DEF);

	push	2
	jne	SHORT $LN24@calc_lagra
	mov	eax, DWORD PTR _vpressures
	mov	ecx, DWORD PTR _rightside
	push	eax
	push	ecx
	push	OFFSET _LS
	call	_mkl_solve

; 800  :     else

	jmp	SHORT $LN95@calc_lagra
$LN24@calc_lagra:

; 801  :       ysmp_solve(&LS,rightside,vpressures,MKL_POS_DEF);

	mov	edx, DWORD PTR _vpressures
	mov	eax, DWORD PTR _rightside
	push	edx
	push	eax
	push	OFFSET _LS
	call	_ysmp_solve
$LN95@calc_lagra:
	add	esp, 16					; 00000010H

; 802  :     free_system(&LS);

	push	OFFSET _LS
	call	_free_system
	add	esp, 4

; 803  :   }
; 804  :   else  

	jmp	SHORT $LN22@calc_lagra
$LN25@calc_lagra:

; 805  :     LD_solve(rleftside,rightside,vpressures,fixcount);

	mov	ecx, DWORD PTR _fixcount
	mov	edx, DWORD PTR _vpressures
	mov	eax, DWORD PTR _rightside
	push	ecx
	mov	ecx, DWORD PTR _rleftside
	push	edx
	push	eax
	push	ecx
	call	_LD_solve
	add	esp, 16					; 00000010H
$LN22@calc_lagra:

; 806  : 
; 807  :   /* check for singular matrix */
; 808  :   for ( i = 0 ; i < fixcount ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _fixcount, esi
	jle	SHORT $LN61@calc_lagra
	npad	8
$LL21@calc_lagra:

; 809  :   { if ( !is_finite(vpressures[i]) )

	fld	QWORD PTR __real@fe37e43c8800759c
	mov	ecx, DWORD PTR _vpressures
	fcomp	QWORD PTR [ecx+esi*8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN17@calc_lagra
	fld	QWORD PTR __real@7e37e43c8800759c
	fcomp	QWORD PTR [ecx+esi*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN20@calc_lagra
$LN17@calc_lagra:

; 810  :     {
; 811  :       sprintf(errmsg,"Constraint adjustment matrix singular. \nMore constraints than degrees of freedom?\nConstraints with no elements?");

	push	OFFSET ??_C@_0HA@KMLAAKJ@Constraint?5adjustment?5matrix?5sin@
	push	OFFSET _errmsg
	call	_sprintf

; 812  :       kb_error(3005,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3005					; 00000bbdH
	call	_kb_error
	add	esp, 20					; 00000014H
$LN20@calc_lagra:

; 806  : 
; 807  :   /* check for singular matrix */
; 808  :   for ( i = 0 ; i < fixcount ; i++ )

	inc	esi
	cmp	esi, DWORD PTR _fixcount
	jl	SHORT $LL21@calc_lagra
$LN61@calc_lagra:

; 813  :     }
; 814  :   } 
; 815  : 
; 816  :   
; 817  : 
; 818  :   /* install pressures into body structures */
; 819  :   if ( !web.pressure_flag )

	cmp	DWORD PTR _web+868, 0
	jne	$LN66@calc_lagra

; 820  :   { MFOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+384
	mov	edi, eax
	shr	edi, 28					; 0000001cH
	and	edi, 1
	je	$LN66@calc_lagra
	fldz
$LN65@calc_lagra:
	mov	edx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	ebx, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv414[ebp+4], eax
	mov	eax, edx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN14@calc_lagra

; 821  :     { if ( get_battr(b_id) & FIXEDVOL )

	and	edx, 32					; 00000020H
	xor	eax, eax
	or	edx, eax
	je	SHORT $LN14@calc_lagra

; 822  :       { 
; 823  :         if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, eax
	je	SHORT $LN9@calc_lagra

; 824  :         { int fixi;
; 825  :           gq = GEN_QUANT(get_body_volquant(b_id));

	mov	edx, DWORD PTR [ecx+404]

; 826  :           fixi = gq->fixnum;

	mov	eax, DWORD PTR _gen_quant_list
	imul	edx, 368				; 00000170H
	mov	eax, DWORD PTR [edx+eax+224]

; 827  :           set_body_pressure(b_id,(fixi<0)?0.0 : -vpressures[fixi]);

	test	eax, eax
	jns	SHORT $LN39@calc_lagra
	fld	ST(0)
	jmp	SHORT $LN40@calc_lagra
$LN39@calc_lagra:
	mov	edx, DWORD PTR _vpressures
	fld	QWORD PTR [edx+eax*8]
	fchs
$LN40@calc_lagra:
	test	edi, edi
	je	SHORT $LN92@calc_lagra
	fstp	QWORD PTR [ecx+312]

; 828  :         }
; 829  :         else

	jmp	SHORT $LN14@calc_lagra
$LN9@calc_lagra:

; 830  :         { int fixi = get_body_fixnum(b_id);

	mov	eax, DWORD PTR [ecx+420]

; 831  :           set_body_pressure(b_id,(fixi<0)?0.0:-vpressures[fixi]);

	test	eax, eax
	jns	SHORT $LN39@calc_lagra
	fld	ST(0)
	jmp	SHORT $LN40@calc_lagra
$LN92@calc_lagra:
	fstp	ST(0)
$LN14@calc_lagra:

; 820  :   { MFOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx]
	mov	edi, eax
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	$LN65@calc_lagra
	fstp	ST(0)
$LN66@calc_lagra:

; 832  :         }
; 833  :       }
; 834  :     }
; 835  :   }
; 836  :     for ( k = 0 ; k < gen_quant_count ; k++ )

	xor	esi, esi
	cmp	DWORD PTR _web+5528, esi
	jle	SHORT $LN68@calc_lagra
	xor	eax, eax
	mov	edi, 268435456				; 10000000H
	npad	2
$LL67@calc_lagra:

; 837  :     { gq = GEN_QUANT(k);
; 838  :       if ( gq->flags & Q_DELETED ) continue;

	mov	edx, DWORD PTR _gen_quant_list
	mov	ecx, DWORD PTR [eax+edx+136]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN6@calc_lagra

; 839  :       if ( gq->flags & (Q_FIXED|Q_CONSERVED) )

	test	cl, 10					; 0000000aH
	je	SHORT $LN6@calc_lagra

; 840  :         if ( !valid_id(gq->b_id) || !web.pressure_flag )

	test	DWORD PTR [eax+edx+216], edi
	je	SHORT $LN1@calc_lagra
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN6@calc_lagra
$LN1@calc_lagra:

; 841  :           gq->pressure = -vpressures[gq->fixnum];

	mov	ebx, DWORD PTR _vpressures
	mov	ecx, DWORD PTR [eax+edx+224]
	fld	QWORD PTR [ebx+ecx*8]
	fchs
	fstp	QWORD PTR [eax+edx+192]
$LN6@calc_lagra:

; 832  :         }
; 833  :       }
; 834  :     }
; 835  :   }
; 836  :     for ( k = 0 ; k < gen_quant_count ; k++ )

	inc	esi
	add	eax, 368				; 00000170H
	cmp	esi, DWORD PTR _web+5528
	jl	SHORT $LL67@calc_lagra
$LN68@calc_lagra:
	pop	edi
	pop	esi
	pop	ebx
$LN5@calc_lagra:

; 842  :     }
; 843  : 
; 844  : 
; 845  : } /* end calc_lagrange() */

	mov	esp, ebp
	pop	ebp
	ret	0
_calc_lagrange ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@FFKNDHMK@one_sided_lagrange?$AA@	; `string'
PUBLIC	_local_lagrange_adjust
;	COMDAT ??_C@_0BD@FFKNDHMK@one_sided_lagrange?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BD@FFKNDHMK@one_sided_lagrange?$AA@ DB 'one_sided_lagrange', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\fixvol.c
CONST	ENDS
;	COMDAT _local_lagrange_adjust
_TEXT	SEGMENT
tv369 = -24						; size = 4
tv367 = -20						; size = 4
_vgptr$89852 = -20					; size = 4
tv376 = -16						; size = 8
_ord$89853 = -12					; size = 4
_loosened$ = -8						; size = 4
_v_id$ = -4						; size = 4
_local_lagrange_adjust PROC				; COMDAT

; 955  : { vertex_id v_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi

; 956  :   int k;
; 957  :   int loosened = 0;
; 958  :   
; 959  :   one_sided_lagrange_attr = find_attribute(VERTEX,ONE_SIDED_LAGRANGE_ATTR_NAME);

	push	OFFSET ??_C@_0BD@FFKNDHMK@one_sided_lagrange?$AA@
	push	0
	mov	DWORD PTR _loosened$[ebp], 0
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _one_sided_lagrange_attr, eax

; 960  :   /* clear one_sided_lagrange */
; 961  :   if ( one_sided_lagrange_attr >= 0 )

	test	eax, eax
	js	$LN49@local_lagr

; 962  :   { struct extra *ex = EXTRAS(VERTEX)+one_sided_lagrange_attr;
; 963  :     vertex_id v_id;
; 964  :     int i;
; 965  :     int osl_size = ex->array_spec.datacount;
; 966  : 
; 967  :     FOR_ALL_VERTICES(v_id)

	mov	esi, DWORD PTR _web+48
	mov	edx, DWORD PTR _dymem
	mov	ecx, eax
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+104
	mov	ebx, DWORD PTR [ecx+edx+88]
	test	esi, 268435456				; 10000000H
	je	SHORT $LN49@local_lagr
$LL52@local_lagr:
	mov	ecx, DWORD PTR _web+12
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	ecx, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	edi, edi
	or	ecx, edi
	je	SHORT $LN27@local_lagr

; 968  :     { REAL *v = (REAL*)get_extra(v_id,one_sided_lagrange_attr);

	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	edi, DWORD PTR _web[esi+104]
	mov	ecx, eax
	imul	ecx, 240				; 000000f0H
	add	edi, ecx
	mov	ecx, DWORD PTR _web[esi+12]
	mov	esi, DWORD PTR _dymem
	mov	edi, DWORD PTR [edi+esi+64]
	add	edi, DWORD PTR [ecx+edx]

; 969  :       for ( i = 0 ; i < osl_size ; i++ )

	test	ebx, ebx
	jle	SHORT $LN27@local_lagr

; 968  :     { REAL *v = (REAL*)get_extra(v_id,one_sided_lagrange_attr);

	mov	ecx, ebx
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	rep stosd
	mov	eax, DWORD PTR _one_sided_lagrange_attr
$LN27@local_lagr:

; 962  :   { struct extra *ex = EXTRAS(VERTEX)+one_sided_lagrange_attr;
; 963  :     vertex_id v_id;
; 964  :     int i;
; 965  :     int osl_size = ex->array_spec.datacount;
; 966  : 
; 967  :     FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [edx+ecx]
	mov	esi, DWORD PTR [edx]
	test	esi, 268435456				; 10000000H
	jne	SHORT $LL52@local_lagr
$LN49@local_lagr:

; 970  :         v[i] = 0.0;
; 971  :     }
; 972  :   }
; 973  : 
; 974  :   /* subtract multiples of volume gradients from force */
; 975  : 
; 976  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _v_id$[ebp], eax
	mov	DWORD PTR tv367[ebp], ecx
	je	$LN48@local_lagr
	mov	edi, DWORD PTR _web+616
	jmp	SHORT $LN20@local_lagr
	npad	9
$LL51@local_lagr:
	mov	eax, DWORD PTR _v_id$[ebp]
$LN20@local_lagr:
	mov	ebx, eax
	mov	eax, DWORD PTR _web+12
	and	ebx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv376[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv369[ebp], ebx
	je	$LN19@local_lagr

; 977  :   {
; 978  :     volgrad *vgptr;
; 979  :     int ord = loc_ordinal(v_id);

	mov	DWORD PTR _ord$89853[ebp], ebx
	cmp	DWORD PTR tv367[ebp], esi
	jne	SHORT $LN33@local_lagr
	mov	DWORD PTR _ord$89853[ebp], -1
$LN33@local_lagr:

; 980  :     REAL *f;
; 981  :     int bi; /* row number for constraint */
; 982  : 
; 983  :     if ( get_vattr(v_id) & FIXED ) continue;

	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	jne	$LN19@local_lagr

; 984  :     f = get_velocity(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [ecx+eax+1024]

; 985  :     for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	ecx, DWORD PTR _v_id$[ebp]
	push	ecx
	add	esi, edx
	call	_get_vertex_vgrad
	add	esp, 4
	mov	DWORD PTR _vgptr$89852[ebp], eax
	test	eax, eax
	je	$LN12@local_lagr
$LL14@local_lagr:

; 986  :     { bi = vgptr->fixnum;

	mov	ebx, DWORD PTR [eax]

; 987  :       if ( (bi < 0) || (bi >= fixcount) ) 

	test	ebx, ebx
	js	SHORT $LN13@local_lagr
	cmp	ebx, DWORD PTR _fixcount
	jge	SHORT $LN13@local_lagr

; 991  :          for ( k = 0 ; k < SDIM ; k++ )

	xor	ecx, ecx
	cmp	DWORD PTR _approx_curve_flag, ecx
	je	SHORT $LN9@local_lagr
	test	edi, edi
	jle	SHORT $LN13@local_lagr
	mov	edx, DWORD PTR _vgev
	mov	eax, DWORD PTR _vpressures
	mov	edx, DWORD PTR [edx+ebx*4]
	lea	eax, DWORD PTR [eax+ebx*8]
	mov	ebx, DWORD PTR _ord$89853[ebp]
$LL8@local_lagr:

; 992  :             f[k] -= vpressures[bi]*vgev[bi][SDIM*ord +k];

	imul	edi, ebx
	add	edi, ecx
	inc	ecx
	fld	QWORD PTR [edx+edi*8]
	fmul	QWORD PTR [eax]
	fsubr	QWORD PTR [esi+ecx*8-8]
	fstp	QWORD PTR [esi+ecx*8-8]
	mov	edi, DWORD PTR _web+616
	cmp	ecx, edi
	jl	SHORT $LL8@local_lagr

; 993  :       else

	mov	eax, DWORD PTR _vgptr$89852[ebp]
	jmp	SHORT $LN13@local_lagr
$LN9@local_lagr:

; 994  :          for ( k = 0 ; k < SDIM ; k++ )

	test	edi, edi
	jle	SHORT $LN13@local_lagr

; 988  :           continue;  /* bi = -1 for killed one-sided constraints */
; 989  : 
; 990  :       if ( approx_curve_flag )

	mov	edx, DWORD PTR _vpressures
	lea	edx, DWORD PTR [edx+ebx*8]
$LL4@local_lagr:

; 995  :             f[k] -= vpressures[bi]*vgptr->velocity[k];

	mov	edi, DWORD PTR [eax+20]
	fld	QWORD PTR [edi+ecx*8]
	inc	ecx
	fmul	QWORD PTR [edx]
	fsubr	QWORD PTR [esi+ecx*8-8]
	fstp	QWORD PTR [esi+ecx*8-8]
	mov	edi, DWORD PTR _web+616
	cmp	ecx, edi
	jl	SHORT $LL4@local_lagr
$LN13@local_lagr:

; 985  :     for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _vgptr$89852[ebp], eax
	test	eax, eax
	jne	$LL14@local_lagr
	mov	ebx, DWORD PTR tv369[ebp]
$LN12@local_lagr:

; 996  :     }
; 997  : 
; 998  :     if ( one_sided_present )

	cmp	DWORD PTR _one_sided_present, 0
	je	SHORT $LN19@local_lagr

; 999  :       loosened += one_sided_lagrange_adjust(v_id);

	mov	eax, DWORD PTR _v_id$[ebp]
	push	eax
	call	_one_sided_lagrange_adjust
	mov	edi, DWORD PTR _web+616
	add	esp, 4
	add	DWORD PTR _loosened$[ebp], eax
$LN19@local_lagr:

; 970  :         v[i] = 0.0;
; 971  :     }
; 972  :   }
; 973  : 
; 974  :   /* subtract multiples of volume gradients from force */
; 975  : 
; 976  :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _v_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv367[ebp], eax
	jne	$LL51@local_lagr
$LN48@local_lagr:

; 1000 :   }
; 1001 : 
; 1002 :   return loosened;

	mov	eax, DWORD PTR _loosened$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 1003 : } /* end local_lagrange_adjust() */

	mov	esp, ebp
	pop	ebp
	ret	0
_local_lagrange_adjust ENDP
_TEXT	ENDS
PUBLIC	_local_volume_restore
EXTRN	_project_v_constr:PROC
; Function compile flags: /Ogtp
;	COMDAT _local_volume_restore
_TEXT	SEGMENT
tv333 = -48						; size = 8
tv330 = -40						; size = 8
_attr$90071 = -32					; size = 8
tv567 = -24						; size = 4
tv374 = -24						; size = 4
_i$ = -20						; size = 4
_ord$90068 = -20					; size = 4
tv323 = -16						; size = 4
tv327 = -12						; size = 4
_vgptr$90067 = -12					; size = 4
_boundary$90086 = -8					; size = 4
_v_id$ = -4						; size = 4
_stepsize$ = 8						; size = 8
_mode$ = 16						; size = 4
_local_volume_restore PROC				; COMDAT

; 1221 : { vertex_id v_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 1222 :   int bi,i,k;
; 1223 :   
; 1224 :   /* vertices */
; 1225 :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	push	ebx
	mov	ebx, edx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	mov	DWORD PTR _v_id$[ebp], edx
	je	$LN38@local_volu
	fld	QWORD PTR _stepsize$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _web+616
	jmp	SHORT $LN40@local_volu
$LN63@local_volu:
	mov	edx, DWORD PTR _v_id$[ebp]
$LN40@local_volu:
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv330[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv323[ebp], edx
	je	$LN39@local_volu

; 1226 :   { REAL *x;
; 1227 :     volgrad *vgptr;
; 1228 :     int ord = loc_ordinal(v_id);

	mov	DWORD PTR _ord$90068[ebp], edx
	test	ebx, ebx
	jne	SHORT $LN44@local_volu
	mov	DWORD PTR _ord$90068[ebp], -1
$LN44@local_volu:

; 1229 :     ATTR attr = get_vattr(v_id);

	mov	eax, DWORD PTR tv330[ebp+4]
	mov	DWORD PTR _attr$90071[ebp+4], eax

; 1230 : 
; 1231 : 	  if ( (attr & CONSTRAINT) && one_sided_present )

	mov	eax, ecx
	and	eax, 1024				; 00000400H
	xor	esi, esi
	mov	DWORD PTR tv333[ebp], eax
	or	eax, esi
	mov	DWORD PTR _attr$90071[ebp], ecx
	je	SHORT $LN35@local_volu
	cmp	DWORD PTR _one_sided_present, esi
	je	SHORT $LN35@local_volu

; 1232 :       one_sided_volume_adjust(v_id);

	mov	ecx, DWORD PTR _v_id$[ebp]
	fstp	ST(0)
	push	ecx
	call	_one_sided_volume_adjust
	fld	QWORD PTR _stepsize$[ebp]
	mov	edi, DWORD PTR _web+616
	mov	ecx, DWORD PTR _attr$90071[ebp]
	mov	edx, DWORD PTR tv323[ebp]
	add	esp, 4
$LN35@local_volu:

; 1233 : 
; 1234 :     x = get_coord(v_id);

	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR _dymem
	mov	ebx, DWORD PTR [eax+esi+64]

; 1235 :     if ( attr & BOUNDARY )

	mov	eax, ecx
	and	eax, 128				; 00000080H
	xor	esi, esi
	add	ebx, edx
	or	eax, esi
	mov	DWORD PTR tv327[ebp], edx
	je	$LN34@local_volu

; 1236 :     { REAL *p = get_param(v_id);

	mov	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+esi+544]
	add	esi, edx

; 1237 :       struct boundary *boundary = get_boundary(v_id);

	mov	edx, DWORD PTR _V_BOUNDARY_ATTR
	test	edx, edx
	je	SHORT $LN45@local_volu
	imul	edx, 240				; 000000f0H
	add	edx, eax
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR tv327[ebp]
	mov	eax, DWORD PTR [edx+eax]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	mov	DWORD PTR _boundary$90086[ebp], eax
	jmp	SHORT $LN46@local_volu
$LN45@local_volu:
	mov	DWORD PTR _boundary$90086[ebp], 0
	mov	eax, DWORD PTR _boundary$90086[ebp]
$LN46@local_volu:

; 1238 :       if ( !(attr & FIXED) ) 

	and	ecx, 64					; 00000040H
	xor	edx, edx
	or	ecx, edx
	jne	$LN70@local_volu

; 1239 :         for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	ecx, DWORD PTR _v_id$[ebp]
	push	ecx
	call	_get_vertex_vgrad
	add	esp, 4
	mov	DWORD PTR _vgptr$90067[ebp], eax
	test	eax, eax
	je	$LN64@local_volu
$LN32@local_volu:

; 1240 :         { bi = vgptr->fixnum;

	mov	edx, DWORD PTR [eax]

; 1241 :           if ( ( bi < 0 ) || (bi >= fixcount) ) continue;

	test	edx, edx
	js	$LN31@local_volu
	cmp	edx, DWORD PTR _fixcount
	jge	SHORT $LN31@local_volu

; 1242 :           if ( approx_curve_flag )
; 1243 :             for ( k = 0 ; k < SDIM ; k++ )

	xor	ecx, ecx
	cmp	DWORD PTR _approx_curve_flag, ecx
	je	SHORT $LN27@local_volu
	test	edi, edi
	jle	SHORT $LN31@local_volu
	mov	eax, DWORD PTR _vgev
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv374[ebp], eax
	mov	eax, DWORD PTR _vol_restore
	lea	eax, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR tv374[ebp]
$LN26@local_volu:

; 1244 :               p[k] += stepsize*vol_restore[bi]*vgev[bi][SDIM*ord+k];

	imul	edi, DWORD PTR _ord$90068[ebp]
	fld	QWORD PTR [eax]
	fmul	ST(0), ST(1)
	add	edi, ecx
	inc	ecx
	fmul	QWORD PTR [edx+edi*8]
	fadd	QWORD PTR [esi+ecx*8-8]
	fstp	QWORD PTR [esi+ecx*8-8]
	mov	edi, DWORD PTR _web+616
	cmp	ecx, edi
	jl	SHORT $LN26@local_volu

; 1245 :           else

	mov	eax, DWORD PTR _vgptr$90067[ebp]
	jmp	SHORT $LN31@local_volu
$LN27@local_volu:

; 1246 :             for ( k = 0 ; k < boundary->pcount ; k++ )

	mov	edx, DWORD PTR _boundary$90086[ebp]
	cmp	DWORD PTR [edx+40], ecx
	jle	SHORT $LN31@local_volu

; 1237 :       struct boundary *boundary = get_boundary(v_id);

	mov	edi, DWORD PTR _vol_restore
	mov	edx, DWORD PTR [eax]
	lea	edx, DWORD PTR [edi+edx*8]
$LN22@local_volu:

; 1247 :               p[k] += stepsize*vol_restore[bi]*vgptr->velocity[k];

	fld	QWORD PTR [edx]
	mov	edi, DWORD PTR [eax+20]
	fmul	ST(0), ST(1)
	inc	ecx
	fmul	QWORD PTR [edi+ecx*8-8]
	mov	edi, DWORD PTR _boundary$90086[ebp]
	fadd	QWORD PTR [esi+ecx*8-8]
	fstp	QWORD PTR [esi+ecx*8-8]
	cmp	ecx, DWORD PTR [edi+40]
	jl	SHORT $LN22@local_volu

; 1246 :             for ( k = 0 ; k < boundary->pcount ; k++ )

	mov	edi, DWORD PTR _web+616
$LN31@local_volu:

; 1239 :         for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _vgptr$90067[ebp], eax
	test	eax, eax
	jne	$LN32@local_volu
$LN64@local_volu:
	mov	eax, DWORD PTR _boundary$90086[ebp]
$LN70@local_volu:

; 1248 :         }
; 1249 :       for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	edi, edi
	jle	$LN69@local_volu
	fstp	ST(0)
	lea	edi, DWORD PTR [eax+48]
	jmp	SHORT $LN19@local_volu
	npad	5
$LL65@local_volu:
	mov	edi, DWORD PTR tv567[ebp]
$LN19@local_volu:

; 1250 :         x[i] = eval(boundary->coordf[i],p,v_id,NULL);

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR [edi]
	push	0
	push	eax
	push	esi
	push	ecx
	call	_eval
	mov	eax, DWORD PTR _i$[ebp]
	add	edi, 4
	fstp	QWORD PTR [ebx+eax*8]
	inc	eax
	mov	DWORD PTR tv567[ebp], edi
	mov	edi, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, edi
	jl	SHORT $LL65@local_volu

; 1251 : 
; 1252 :     }
; 1253 :     else

	jmp	$LN145@local_volu
$LN34@local_volu:

; 1254 :     { 
; 1255 :       if ( !(attr & FIXED) ) 

	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	jne	$LN66@local_volu

; 1256 :       for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	edx, DWORD PTR _v_id$[ebp]
	push	edx
	call	_get_vertex_vgrad
	add	esp, 4
	mov	DWORD PTR _vgptr$90067[ebp], eax
	test	eax, eax
	je	$LN66@local_volu
$LN14@local_volu:

; 1257 :       { bi = vgptr->fixnum;

	mov	esi, DWORD PTR [eax]

; 1258 :         if ( ( bi < 0 ) || (bi >= fixcount) ) continue;

	test	esi, esi
	js	SHORT $LN13@local_volu
	cmp	esi, DWORD PTR _fixcount
	jge	SHORT $LN13@local_volu

; 1259 :         if ( approx_curve_flag )
; 1260 :           for ( k = 0 ; k < SDIM ; k++ )

	xor	ecx, ecx
	cmp	DWORD PTR _approx_curve_flag, ecx
	je	SHORT $LN9@local_volu
	test	edi, edi
	jle	SHORT $LN13@local_volu
	mov	eax, DWORD PTR _vgev
	mov	edx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _vol_restore
	lea	eax, DWORD PTR [eax+esi*8]
$LN8@local_volu:

; 1261 :              x[k] += stepsize*vol_restore[bi]*vgev[bi][SDIM*ord+k];

	imul	edi, DWORD PTR _ord$90068[ebp]
	fld	QWORD PTR [eax]
	fmul	ST(0), ST(1)
	add	edi, ecx
	inc	ecx
	fmul	QWORD PTR [edx+edi*8]
	fadd	QWORD PTR [ebx+ecx*8-8]
	fstp	QWORD PTR [ebx+ecx*8-8]
	mov	edi, DWORD PTR _web+616
	cmp	ecx, edi
	jl	SHORT $LN8@local_volu

; 1262 :         else

	mov	eax, DWORD PTR _vgptr$90067[ebp]
	jmp	SHORT $LN13@local_volu
$LN9@local_volu:

; 1263 :         { for ( k = 0 ; k < SDIM ; k++ )

	test	edi, edi
	jle	SHORT $LN13@local_volu

; 1237 :       struct boundary *boundary = get_boundary(v_id);

	mov	edx, DWORD PTR _vol_restore
	lea	edx, DWORD PTR [edx+esi*8]
$LN4@local_volu:

; 1264 :              x[k] += stepsize*vol_restore[bi]*vgptr->velocity[k];

	fld	QWORD PTR [edx]
	mov	esi, DWORD PTR [eax+20]
	fmul	ST(0), ST(1)
	inc	ecx
	fmul	QWORD PTR [esi+ecx*8-8]
	fadd	QWORD PTR [ebx+ecx*8-8]
	fstp	QWORD PTR [ebx+ecx*8-8]
	mov	edi, DWORD PTR _web+616
	cmp	ecx, edi
	jl	SHORT $LN4@local_volu
$LN13@local_volu:

; 1256 :       for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _vgptr$90067[ebp], eax
	test	eax, eax
	jne	$LN14@local_volu
$LN66@local_volu:

; 1265 :         }
; 1266 :            
; 1267 :       }
; 1268 :       if ( attr & CONSTRAINT ) project_v_constr(v_id,mode,KEEP_ONESIDEDNESS);

	mov	ecx, DWORD PTR tv333[ebp]
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN69@local_volu
	mov	ecx, DWORD PTR _v_id$[ebp]
	fstp	ST(0)
	push	eax
	mov	eax, DWORD PTR _mode$[ebp]
	push	eax
	push	ecx
	call	_project_v_constr
	mov	edi, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
$LN145@local_volu:
	fld	QWORD PTR _stepsize$[ebp]
$LN69@local_volu:
	mov	edx, DWORD PTR tv323[ebp]
$LN39@local_volu:

; 1222 :   int bi,i,k;
; 1223 :   
; 1224 :   /* vertices */
; 1225 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR _v_id$[ebp], ebx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	jne	$LN63@local_volu
	pop	edi
	fstp	ST(0)
	pop	esi
$LN38@local_volu:
	pop	ebx

; 1269 :     }
; 1270 :   }
; 1271 : } // end local_volume_restore()

	mov	esp, ebp
	pop	ebp
	ret	0
_local_volume_restore ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@BGIGNLKC@Calculating?5volgrads?4?6?$AA@ ; `string'
PUBLIC	_calc_volgrads
;	COMDAT ??_C@_0BH@BGIGNLKC@Calculating?5volgrads?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@BGIGNLKC@Calculating?5volgrads?4?6?$AA@ DB 'Calculating volgrad'
	DB	's.', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _calc_volgrads
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_calc_volgrads PROC					; COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp

; 40   :    if ( itdebug)

	cmp	DWORD PTR _itdebug, 0
	je	SHORT $LN1@calc_volgr

; 41   :     outstring("Calculating volgrads.\n");

	push	OFFSET ??_C@_0BH@BGIGNLKC@Calculating?5volgrads?4?6?$AA@
	call	_outstring
	add	esp, 4
$LN1@calc_volgr:

; 48   :   #endif
; 49   : 
; 50   : #ifdef _DEBUGXXX
; 51   :   if ( itdebug ) /* dump vgrads */
; 52   :   { vertex_id v_id;
; 53   :     FOR_ALL_VERTICES(v_id)
; 54   :     { volgrad  *vgptr;
; 55   : 
; 56   :       vgptr = get_vertex_vgrad(v_id);
; 57   :       while ( vgptr )
; 58   :       { printf("v %3s   b %3s  grad %f %f %f\n",ELNAME(v_id),
; 59   :          ELNAME1(vgptr->bb_id),vgptr->grad[0],vgptr->grad[1],vgptr->grad[2]);
; 60   :         vgptr = vgptr->chain;
; 61   :       }
; 62   :     }
; 63   :   }
; 64   : #endif
; 65   : 
; 66   : } // end calc_volgrads()

	pop	ebp

; 42   :  
; 43   :    
; 44   :   #ifdef MPI_EVOLVER
; 45   :    mpi_calc_volgrads(mode);
; 46   :   #else
; 47   :    local_calc_volgrads(mode);

	jmp	_local_calc_volgrads
_calc_volgrads ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@MPGHADPJ@one_sided_adjust?$CI?$CJ?3?5see?5which?5gr@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_one_sided_adjust
EXTRN	_pressure_set_flag:DWORD
;	COMDAT ??_C@_0EC@MPGHADPJ@one_sided_adjust?$CI?$CJ?3?5see?5which?5gr@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EC@MPGHADPJ@one_sided_adjust?$CI?$CJ?3?5see?5which?5gr@ DB 'one_si'
	DB	'ded_adjust(): see which grads violate 1-sided constraints ', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\fixvol.c
CONST	ENDS
;	COMDAT _one_sided_adjust
_TEXT	SEGMENT
_fval$89456 = -224					; size = 8
_con$89453 = -216					; size = 28
tv995 = -188						; size = 8
tv809 = -188						; size = 8
tv1893 = -184						; size = 4
_f$89445 = -180						; size = 4
_x$89454 = -176						; size = 4
tv784 = -172						; size = 4
_conmap$89446 = -168					; size = 4
tv786 = -164						; size = 4
_v_id$ = -160						; size = 4
tv2327 = -156						; size = 4
tv1884 = -156						; size = 4
_j$ = -156						; size = 4
_oncount$89452 = -152					; size = 4
_ord$89442 = -152					; size = 4
_grad$89457 = -148					; size = 48
_perp$89455 = -100					; size = 48
_vel$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_mode$ = 8						; size = 4
_one_sided_adjust PROC					; COMDAT

; 426  : { vertex_id v_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 427  :   int i,j,k;
; 428  :   REAL vel[MAXCOORD];
; 429  :   int flag;
; 430  : 
; 431  :   /* see if we need to do anything */
; 432  :   if ( !fixed_constraint_flag ) return;

	cmp	DWORD PTR _fixed_constraint_flag, 0
	je	$LN41@one_sided_@3

; 433  :   for ( i = 0, flag = 0 ; i < web.maxcon ; i++ )

	push	edi
	mov	edi, DWORD PTR _web+644
	xor	edx, edx
	test	edi, edi
	jle	$LN106@one_sided_@3
	push	esi
	mov	esi, DWORD PTR _web+652
	npad	8
$LL50@one_sided_@3:

; 434  :     { struct constraint *con = get_constraint(i);

	mov	eax, edx
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H

; 435  :       if ( con->attr & (NONNEGATIVE|NONPOSITIVE) )

	mov	eax, DWORD PTR [eax+esi+32]
	and	eax, 3
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN74@one_sided_@3

; 433  :   for ( i = 0, flag = 0 ; i < web.maxcon ; i++ )

	inc	edx
	cmp	edx, edi
	jl	SHORT $LL50@one_sided_@3
	pop	esi
	pop	edi

; 510  :     }
; 511  :   }
; 512  : }  /* one_sided_adjust() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@one_sided_@3:

; 436  :         { flag = 1;  break; }
; 437  :     }
; 438  :   if ( flag == 0 ) return;
; 439  :   
; 440  :   if ( itdebug ) 

	cmp	DWORD PTR _itdebug, ecx
	je	SHORT $LN45@one_sided_@3

; 441  :       outstring("one_sided_adjust(): see which grads violate 1-sided constraints \n");

	push	OFFSET ??_C@_0EC@MPGHADPJ@one_sided_adjust?$CI?$CJ?3?5see?5which?5gr@
	call	_outstring
	add	esp, 4
$LN45@one_sided_@3:

; 442  : 
; 443  :   if ( !pressure_set_flag ) calc_lagrange(); /* for first time only */

	cmp	DWORD PTR _pressure_set_flag, 0
	jne	SHORT $LN44@one_sided_@3
	call	_calc_lagrange
$LN44@one_sided_@3:

; 444  : 
; 445  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	DWORD PTR _v_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv784[ebp], eax
	je	$LN107@one_sided_@3
	mov	esi, DWORD PTR _web+616
	push	ebx
	mov	ebx, DWORD PTR _vgev
	npad	4
$LL98@one_sided_@3:
	mov	eax, DWORD PTR _v_id$[ebp]
	fldz
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv786[ebp], eax
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN125@one_sided_@3

; 446  :   {
; 447  :     volgrad *vgptr;
; 448  :     int ord = loc_ordinal(v_id);

	cmp	DWORD PTR tv784[ebp], ecx
	mov	ecx, DWORD PTR tv786[ebp]
	mov	DWORD PTR _ord$89442[ebp], ecx
	jne	SHORT $LN55@one_sided_@3
	mov	DWORD PTR _ord$89442[ebp], -1
$LN55@one_sided_@3:

; 449  :     REAL *f;
; 450  :     conmap_t * conmap = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	cmp	DWORD PTR [eax+edx+1288], 0
	je	SHORT $LN56@one_sided_@3
	mov	eax, DWORD PTR [eax+edx+1264]
	mov	edx, DWORD PTR _web+12
	add	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _conmap$89446[ebp], eax
	jmp	SHORT $LN57@one_sided_@3
$LN56@one_sided_@3:
	mov	DWORD PTR _conmap$89446[ebp], OFFSET _nullcon
$LN57@one_sided_@3:

; 451  :     int oncount = 0;
; 452  :     struct constraint *con[MAXCONHIT];
; 453  :     REAL *x;
; 454  :     REAL perp[MAXCOORD];
; 455  :     REAL fval;
; 456  :     REAL grad[MAXCOORD];
; 457  :     REAL fp;
; 458  : 
; 459  :     if ( get_vattr(v_id) & FIXED ) continue;

	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	mov	DWORD PTR tv809[ebp+4], edx
	and	eax, 64					; 00000040H
	xor	edx, edx
	or	eax, edx
	jne	$LN125@one_sided_@3

; 460  :     if ( !(get_vattr(v_id) & CONSTRAINT) ) continue;

	and	ecx, 1024				; 00000400H
	or	ecx, eax
	je	$LN125@one_sided_@3

; 461  :     x = get_coord(v_id);

	mov	ecx, DWORD PTR tv786[ebp]
	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _web+104
	mov	edi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+edi+64]

; 462  : 
; 463  :     f = get_velocity(v_id);

	mov	edx, DWORD PTR [edx+edi+1024]
	add	ecx, eax
	mov	DWORD PTR _x$89454[ebp], ecx
	add	edx, eax

; 464  :     for ( i = 0 ; i < SDIM ; i++ ) vel[i] = f[i];

	xor	ecx, ecx
	mov	DWORD PTR _f$89445[ebp], edx
	cmp	esi, 4
	jl	SHORT $LC86@one_sided_@3
	lea	eax, DWORD PTR [edx+16]
	neg	edx
	lea	edi, DWORD PTR _vel$[ebp+edx]
	lea	edx, DWORD PTR _vel$[ebp+edx+8]
	mov	DWORD PTR tv2327[ebp], edx
$LN105@one_sided_@3:
	fld	QWORD PTR [eax-16]
	mov	edx, DWORD PTR tv2327[ebp]
	fstp	QWORD PTR _vel$[ebp+ecx*8]
	add	ecx, 4
	fld	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR _vel$[ebp+ecx*8-24]
	fld	QWORD PTR [eax-32]
	fstp	QWORD PTR [edi+eax-32]
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [edx+eax-32]
	lea	edx, DWORD PTR [esi-3]
	cmp	ecx, edx
	jl	SHORT $LN105@one_sided_@3
	mov	edx, DWORD PTR _f$89445[ebp]
$LC86@one_sided_@3:
	cmp	ecx, esi
	jge	SHORT $LN85@one_sided_@3
	lea	eax, DWORD PTR _vel$[ebp]
	sub	edx, eax
$LC36@one_sided_@3:
	lea	eax, DWORD PTR [edx+ecx*8]
	fld	QWORD PTR _vel$[ebp+eax]
	inc	ecx
	fstp	QWORD PTR _vel$[ebp+ecx*8-8]
	cmp	ecx, esi
	jl	SHORT $LC36@one_sided_@3
$LN85@one_sided_@3:

; 465  :     for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	ecx, DWORD PTR _v_id$[ebp]
	push	ecx
	call	_get_vertex_vgrad
	add	esp, 4
	test	eax, eax
	je	$LN159@one_sided_@3
$LN33@one_sided_@3:

; 466  :     { REAL p; /* Lagrange multiplier */
; 467  :       if ( valid_id(vgptr->bb_id) )

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN30@one_sided_@3

; 468  :       p = get_body_pressure(vgptr->bb_id);

	mov	edx, DWORD PTR _web+348
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	fld	QWORD PTR [ecx+312]
	jmp	SHORT $LN29@one_sided_@3
$LN30@one_sided_@3:

; 469  :       else  /* for quantities */
; 470  :       p = GEN_QUANT(vgptr->qnum)->pressure;

	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _gen_quant_list
	imul	edx, 368				; 00000170H
	fld	QWORD PTR [edx+ecx+192]
$LN29@one_sided_@3:

; 471  :       if ( approx_curve_flag )

	cmp	DWORD PTR _approx_curve_flag, 0
	je	$LN28@one_sided_@3

; 472  :         for ( k = 0 ; k < SDIM ; k++ )

	xor	ecx, ecx
	cmp	esi, 4
	jl	SHORT $LC89@one_sided_@3
	mov	edx, esi
	imul	edx, DWORD PTR _ord$89442[ebp]
	add	edx, edx
	add	edx, edx
	add	edx, edx
$LN90@one_sided_@3:

; 473  :             vel[k] += p*vgev[vgptr->fixnum][SDIM*ord + k];

	mov	edi, DWORD PTR [eax]
	mov	edi, DWORD PTR [ebx+edi*4]
	fld	QWORD PTR [edi+edx]
	add	ecx, 4
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	fadd	QWORD PTR _vel$[ebp+ecx*8-32]
	fstp	QWORD PTR _vel$[ebp+ecx*8-32]
	mov	edi, DWORD PTR [eax]
	mov	edi, DWORD PTR [ebx+edi*4]
	fld	QWORD PTR [edi+edx-24]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _vel$[ebp+ecx*8-24]
	fstp	QWORD PTR _vel$[ebp+ecx*8-24]
	mov	edi, DWORD PTR [eax]
	mov	edi, DWORD PTR [ebx+edi*4]
	fld	QWORD PTR [edi+edx-16]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _vel$[ebp+ecx*8-16]
	fstp	QWORD PTR _vel$[ebp+ecx*8-16]
	mov	edi, DWORD PTR [eax]
	mov	edi, DWORD PTR [ebx+edi*4]
	fld	QWORD PTR [edi+edx-8]
	lea	edi, DWORD PTR [esi-3]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _vel$[ebp+ecx*8-8]
	fstp	QWORD PTR _vel$[ebp+ecx*8-8]
	cmp	ecx, edi
	jl	SHORT $LN90@one_sided_@3
$LC89@one_sided_@3:

; 472  :         for ( k = 0 ; k < SDIM ; k++ )

	cmp	ecx, esi
	jge	$LN169@one_sided_@3
	mov	edx, esi
	imul	edx, DWORD PTR _ord$89442[ebp]
	add	edx, ecx
	add	edx, edx
	add	edx, edx
	add	edx, edx
$LC27@one_sided_@3:

; 473  :             vel[k] += p*vgev[vgptr->fixnum][SDIM*ord + k];

	mov	edi, DWORD PTR [eax]
	mov	edi, DWORD PTR [ebx+edi*4]
	fld	QWORD PTR [edi+edx]
	inc	ecx
	fmul	ST(0), ST(1)
	add	edx, 8
	fadd	QWORD PTR _vel$[ebp+ecx*8-8]
	fstp	QWORD PTR _vel$[ebp+ecx*8-8]
	cmp	ecx, esi
	jl	SHORT $LC27@one_sided_@3

; 474  :       else

	jmp	$LN169@one_sided_@3
$LN28@one_sided_@3:

; 475  :         for ( k = 0 ; k < SDIM ; k++ )

	xor	edx, edx
	cmp	esi, 4
	jl	SHORT $LN100@one_sided_@3

; 476  :             vel[k] += p*vgptr->velocity[k];

	lea	ecx, DWORD PTR _vel$[ebp+8]
	mov	edi, 16					; 00000010H
	sub	edi, ecx
	mov	ecx, 24					; 00000018H
	lea	ebx, DWORD PTR _vel$[ebp+8]
	sub	ecx, ebx
	mov	DWORD PTR tv1884[ebp], edi
	mov	DWORD PTR tv1893[ebp], ecx
	jmp	SHORT $LN93@one_sided_@3
$LN99@one_sided_@3:
	mov	edi, DWORD PTR tv1884[ebp]

; 475  :         for ( k = 0 ; k < SDIM ; k++ )

$LN93@one_sided_@3:

; 476  :             vel[k] += p*vgptr->velocity[k];

	mov	ebx, DWORD PTR [eax+20]
	fld	QWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR _vel$[ebp+edx*8+8]
	fmul	ST(0), ST(1)
	add	edi, ecx
	add	edx, 4
	fadd	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
	mov	ebx, DWORD PTR [eax+20]
	fld	QWORD PTR [ebx+edx*8-24]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+20]
	fld	QWORD PTR [edi+ebx]
	mov	edi, DWORD PTR tv1893[ebp]
	fmul	ST(0), ST(1)
	add	edi, ecx
	fadd	QWORD PTR [ecx+8]
	fstp	QWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [eax+20]
	fld	QWORD PTR [edi+ebx]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx+16]
	fstp	QWORD PTR [ecx+16]
	lea	ecx, DWORD PTR [esi-3]
	cmp	edx, ecx
	jl	SHORT $LN99@one_sided_@3
	mov	ebx, DWORD PTR _vgev
$LN100@one_sided_@3:

; 475  :         for ( k = 0 ; k < SDIM ; k++ )

	cmp	edx, esi
	jge	SHORT $LN169@one_sided_@3
$LC23@one_sided_@3:

; 476  :             vel[k] += p*vgptr->velocity[k];

	mov	ecx, DWORD PTR [eax+20]
	fld	QWORD PTR [ecx+edx*8]
	inc	edx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _vel$[ebp+edx*8-8]
	fstp	QWORD PTR _vel$[ebp+edx*8-8]
	cmp	edx, esi
	jl	SHORT $LC23@one_sided_@3
$LN169@one_sided_@3:

; 465  :     for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	eax, DWORD PTR [eax+12]

; 475  :         for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
	test	eax, eax
	jne	$LN33@one_sided_@3
$LN159@one_sided_@3:

; 477  :       /* Note: positive signs since pressure is negative of Lagrange multiplier */
; 478  :     }
; 479  : 
; 480  :     for ( j = 1,oncount = 0 ; j <= (int)conmap[0] ; j++ )

	mov	edx, DWORD PTR _conmap$89446[ebp]
	fstp	ST(0)
	cmp	DWORD PTR [edx], 1
	mov	DWORD PTR _j$[ebp], 1
	mov	DWORD PTR _oncount$89452[ebp], 0
	jl	$LN18@one_sided_@3
$LL20@one_sided_@3:

; 481  :     {
; 482  :       if ( conmap[j] & CON_HIT_BIT )

	mov	eax, DWORD PTR _conmap$89446[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	jns	$LN19@one_sided_@3

; 483  :       { struct constraint *cc = get_constraint(conmap[j]);

	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 484  :         if ( cc->attr & (NONNEGATIVE | NONPOSITIVE) )

	xor	ecx, ecx
	mov	edi, eax
	mov	eax, DWORD PTR [edi+32]
	and	eax, 3
	or	eax, ecx
	je	$LN19@one_sided_@3

; 485  :         { /* check for violation */
; 486  :           eval_all(cc->formula,x,SDIM,&fval,grad,v_id);

	mov	edx, DWORD PTR _v_id$[ebp]
	push	edx
	mov	edx, DWORD PTR _x$89454[ebp]
	lea	eax, DWORD PTR _grad$89457[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+40]
	lea	ecx, DWORD PTR _fval$89456[ebp]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	_eval_all

; 487  :           fp = SDIM_dot(vel,grad);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _grad$89457[ebp]
	push	edx
	lea	eax, DWORD PTR _vel$[ebp]
	push	eax
	call	_dot

; 488  :           if ( (cc->attr & NONNEGATIVE) && (fp < 0.0) )

	mov	ecx, DWORD PTR [edi+32]
	mov	edx, DWORD PTR [edi+36]
	mov	eax, ecx
	mov	DWORD PTR tv995[ebp+4], edx
	and	eax, 2
	xor	edx, edx
	add	esp, 36					; 00000024H
	or	eax, edx
	je	SHORT $LN97@one_sided_@3
	fldz
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN97@one_sided_@3

; 489  :             con[oncount++] = cc;

	mov	eax, DWORD PTR _oncount$89452[ebp]
	mov	DWORD PTR _con$89453[ebp+eax*4], edi
	inc	eax
	mov	DWORD PTR _oncount$89452[ebp], eax
$LN176@one_sided_@3:

; 491  :             con[oncount++] = cc;

	fstp	ST(0)
$LN102@one_sided_@3:

; 492  :           if ( oncount > web.sdim )

	mov	esi, DWORD PTR _web+616
	cmp	DWORD PTR _oncount$89452[ebp], esi
	jle	$LN19@one_sided_@3

; 493  :           { sprintf(errmsg,"Vertex %s hits more constraints than dimension of space.\n",
; 494  :               ELNAME(v_id));

	cmp	DWORD PTR tv784[ebp], edx
	je	SHORT $LN58@one_sided_@3
	mov	eax, DWORD PTR tv786[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN59@one_sided_@3
$LN97@one_sided_@3:

; 490  :           else if ( (cc->attr & NONPOSITIVE) && (fp > 0.0) )

	and	ecx, 1
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN176@one_sided_@3
	fldz
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN102@one_sided_@3

; 491  :             con[oncount++] = cc;

	mov	eax, DWORD PTR _oncount$89452[ebp]
	mov	DWORD PTR _con$89453[ebp+eax*4], edi
	inc	eax
	mov	DWORD PTR _oncount$89452[ebp], eax
	jmp	SHORT $LN102@one_sided_@3
$LN58@one_sided_@3:

; 493  :           { sprintf(errmsg,"Vertex %s hits more constraints than dimension of space.\n",
; 494  :               ELNAME(v_id));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN59@one_sided_@3:
	push	eax
	push	OFFSET ??_C@_0DK@NBHPKLFK@Vertex?5?$CFs?5hits?5more?5constraints?5@
	push	OFFSET _errmsg
	call	_sprintf

; 495  :             kb_error(5888,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5888					; 00001700H
	call	_kb_error
	mov	esi, DWORD PTR _web+616
	add	esp, 24					; 00000018H
$LN19@one_sided_@3:

; 477  :       /* Note: positive signs since pressure is negative of Lagrange multiplier */
; 478  :     }
; 479  : 
; 480  :     for ( j = 1,oncount = 0 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _conmap$89446[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [ecx]
	jle	$LL20@one_sided_@3
	mov	ebx, DWORD PTR _vgev
$LN18@one_sided_@3:

; 496  :           }
; 497  :         }
; 498  :       }
; 499  :     }
; 500  :     if ( mode & CALC_VOLGRADS )

	test	BYTE PTR _mode$[ebp], 2
	je	$LN104@one_sided_@3

; 501  :     for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	edx, DWORD PTR _v_id$[ebp]
	push	edx
	call	_get_vertex_vgrad
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN104@one_sided_@3
	mov	ebx, DWORD PTR _v_id$[ebp]
	npad	4
$LL10@one_sided_@3:

; 502  :     { constr_proj(TANGPROJ,oncount,con,x,vgptr->velocity,perp,NULL,NO_DETECT,v_id);

	mov	ecx, DWORD PTR [edi+20]
	mov	edx, DWORD PTR _x$89454[ebp]
	push	ebx
	push	0
	push	0
	lea	eax, DWORD PTR _perp$89455[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _oncount$89452[ebp]
	push	edx
	lea	eax, DWORD PTR _con$89453[ebp]
	push	eax
	push	ecx
	push	2
	call	_constr_proj

; 503  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _web+616
	add	esp, 36					; 00000024H
	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN9@one_sided_@3
	mov	eax, DWORD PTR [edi+20]
	lea	edx, DWORD PTR _perp$89455[ebp]
	sub	edx, eax
$LL7@one_sided_@3:

; 504  :           vgptr->velocity[j] -= perp[j]; 

	fld	QWORD PTR [eax]
	inc	ecx
	fsub	QWORD PTR [edx+eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	esi, DWORD PTR _web+616
	cmp	ecx, esi
	jl	SHORT $LL7@one_sided_@3
$LN9@one_sided_@3:

; 501  :     for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	jne	SHORT $LL10@one_sided_@3
	mov	ebx, DWORD PTR _vgev
$LN104@one_sided_@3:

; 505  :     }
; 506  :     if ( mode & CALC_FORCE )

	test	BYTE PTR _mode$[ebp], 1
	je	SHORT $LN42@one_sided_@3

; 507  :     { constr_proj(TANGPROJ,oncount,con,x,f,perp,NULL,NO_DETECT,v_id);

	mov	edx, DWORD PTR _v_id$[ebp]
	mov	edi, DWORD PTR _f$89445[ebp]
	mov	ecx, DWORD PTR _x$89454[ebp]
	push	edx
	push	0
	push	0
	lea	eax, DWORD PTR _perp$89455[ebp]
	push	eax
	mov	eax, DWORD PTR _oncount$89452[ebp]
	push	edi
	push	ecx
	lea	edx, DWORD PTR _con$89453[ebp]
	push	edx
	push	eax
	push	2
	call	_constr_proj

; 508  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _web+616
	add	esp, 36					; 00000024H
	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN96@one_sided_@3
	lea	edx, DWORD PTR _perp$89455[ebp]
	mov	eax, edi
	sub	edx, edi
$LL3@one_sided_@3:

; 509  :           f[j] -= perp[j]; 

	fld	QWORD PTR [eax]
	inc	ecx
	fsub	QWORD PTR [edx+eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	esi, DWORD PTR _web+616
	cmp	ecx, esi
	jl	SHORT $LL3@one_sided_@3
$LN96@one_sided_@3:

; 508  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _vgev
	jmp	SHORT $LN42@one_sided_@3
$LN125@one_sided_@3:

; 460  :     if ( !(get_vattr(v_id) & CONSTRAINT) ) continue;

	fstp	ST(0)
$LN42@one_sided_@3:

; 444  : 
; 445  :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR tv786[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _v_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv784[ebp], eax
	jne	$LL98@one_sided_@3
	pop	ebx
$LN107@one_sided_@3:
	pop	esi
$LN106@one_sided_@3:
	pop	edi
$LN41@one_sided_@3:

; 510  :     }
; 511  :   }
; 512  : }  /* one_sided_adjust() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_one_sided_adjust ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EG@CBLJNCL@lagrange_adjust?$CI?$CJ?3?5subtract?5mult@ ; `string'
PUBLIC	_lagrange_adjust
;	COMDAT ??_C@_0EG@CBLJNCL@lagrange_adjust?$CI?$CJ?3?5subtract?5mult@
CONST	SEGMENT
??_C@_0EG@CBLJNCL@lagrange_adjust?$CI?$CJ?3?5subtract?5mult@ DB 'lagrange'
	DB	'_adjust(): subtract multiples of volume gradients from force', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _lagrange_adjust
_TEXT	SEGMENT
_k$ = -16						; size = 4
tv365 = -12						; size = 4
tv204 = -12						; size = 4
tv1137 = -8						; size = 4
_i$ = -4						; size = 4
_lagrange_adjust PROC					; COMDAT

; 915  : { int i,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 916  : 
; 917  :   if ( !fixed_constraint_flag ) return;

	cmp	DWORD PTR _fixed_constraint_flag, 0
	je	$LN6@lagrange_a

; 918  : 
; 919  :   if ( itdebug ) 

	cmp	DWORD PTR _itdebug, 0
	je	SHORT $LN10@lagrange_a

; 920  :     outstring("lagrange_adjust(): subtract multiples of volume gradients from force\n");

	push	OFFSET ??_C@_0EG@CBLJNCL@lagrange_adjust?$CI?$CJ?3?5subtract?5mult@
	call	_outstring
	add	esp, 4
$LN10@lagrange_a:

; 921  : 
; 922  :   #ifdef MPI_EVOLVER
; 923  :   mpi_lagrange_adjust(maxquants);
; 924  :   #else
; 925  :   local_lagrange_adjust();

	call	_local_lagrange_adjust

; 926  :   #endif
; 927  : 
; 928  :   /* optimizing parameter adjust */
; 929  :   if ( optparamcount )

	mov	eax, DWORD PTR _optparamcount
	test	eax, eax
	je	$LN6@lagrange_a

; 930  :     for ( i = 0 ; i < optparamcount ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jle	$LN6@lagrange_a
	push	ebx
	push	esi
	mov	edx, OFFSET _optparam
	push	edi
$LL59@lagrange_a:

; 931  :       for ( k = 0 ; k < gen_quant_count ; k++ )

	mov	ecx, DWORD PTR _web+5528
	xor	eax, eax
	cmp	ecx, 4
	jl	$LN56@lagrange_a
	mov	eax, DWORD PTR _gen_quant_list
	add	ecx, -4					; fffffffcH
	shr	ecx, 2
	inc	ecx
	mov	DWORD PTR tv365[ebp], ecx
	add	eax, 588				; 0000024cH
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR tv1137[ebp], eax
	mov	DWORD PTR _k$[ebp], ecx
	npad	1
$LL57@lagrange_a:

; 935  :         if ( q->flags & Q_DELETED ) continue;

	test	DWORD PTR [eax-452], 524288		; 00080000H
	mov	esi, DWORD PTR [eax-364]
	mov	edi, DWORD PTR [eax-368]
	jne	$LN55@lagrange_a

; 936  :         if ( fixi >= 0 )

	test	esi, esi
	js	$LN55@lagrange_a

; 937  :           optparam[i].velocity += vpressures[fixi]*
; 938  :               globals(optparam[i].pnum)->attr.varstuff.pscale*
; 939  :                  optparam_congrads[i][volk];

	mov	eax, DWORD PTR [edx]
	mov	ebx, DWORD PTR _web+5652
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	and	eax, 16777215				; 00ffffffH
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN26@lagrange_a
	lea	eax, DWORD PTR [ebx+eax*4]
	jmp	SHORT $LN60@lagrange_a
$LN26@lagrange_a:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN27@lagrange_a
	mov	ecx, DWORD PTR _localbase
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN29@lagrange_a
$LN27@lagrange_a:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN28@lagrange_a
	mov	ecx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN29@lagrange_a
$LN28@lagrange_a:
	mov	ecx, DWORD PTR _web+5652
	lea	eax, DWORD PTR [ecx+eax*4]
$LN60@lagrange_a:
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx]
$LN29@lagrange_a:
	mov	ecx, DWORD PTR _vpressures
	fld	QWORD PTR [ecx+esi*8]
	mov	ecx, DWORD PTR _optparam_congrads
	fmul	QWORD PTR [eax+176]
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	fmul	QWORD PTR [eax+edi*8]
	mov	eax, DWORD PTR tv1137[ebp]
	fadd	QWORD PTR [edx+16]
	fstp	QWORD PTR [edx+16]
	jmp	SHORT $LN32@lagrange_a
$LN55@lagrange_a:
	mov	ebx, DWORD PTR _web+5652
$LN32@lagrange_a:

; 935  :         if ( q->flags & Q_DELETED ) continue;

	test	DWORD PTR [eax-84], 524288		; 00080000H
	mov	esi, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax]
	jne	$LN58@lagrange_a

; 936  :         if ( fixi >= 0 )

	test	esi, esi
	js	$LN58@lagrange_a

; 937  :           optparam[i].velocity += vpressures[fixi]*
; 938  :               globals(optparam[i].pnum)->attr.varstuff.pscale*
; 939  :                  optparam_congrads[i][volk];

	mov	eax, DWORD PTR [edx]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	and	eax, 16777215				; 00ffffffH
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN33@lagrange_a
	lea	ecx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [ecx+eax]
	jmp	SHORT $LN36@lagrange_a
$LN33@lagrange_a:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN34@lagrange_a
	mov	ecx, DWORD PTR _localbase
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN36@lagrange_a
$LN34@lagrange_a:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN35@lagrange_a
	mov	ecx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN36@lagrange_a
$LN35@lagrange_a:
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN36@lagrange_a:
	mov	ecx, DWORD PTR _vpressures
	fld	QWORD PTR [ecx+esi*8]
	mov	ecx, DWORD PTR _optparam_congrads
	fmul	QWORD PTR [eax+176]
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	fmul	QWORD PTR [eax+edi*8]
	mov	eax, DWORD PTR tv1137[ebp]
	fadd	QWORD PTR [edx+16]
	fstp	QWORD PTR [edx+16]
$LN58@lagrange_a:

; 932  :       { struct gen_quant *q = GEN_QUANT(k);
; 933  :         int fixi = q->fixnum;

	test	DWORD PTR [eax+284], 524288		; 00080000H
	mov	esi, DWORD PTR [eax+372]

; 934  :         int volk = q->vol_number;

	mov	edi, DWORD PTR [eax+368]

; 935  :         if ( q->flags & Q_DELETED ) continue;

	jne	$LN46@lagrange_a

; 936  :         if ( fixi >= 0 )

	test	esi, esi
	js	$LN46@lagrange_a

; 937  :           optparam[i].velocity += vpressures[fixi]*
; 938  :               globals(optparam[i].pnum)->attr.varstuff.pscale*
; 939  :                  optparam_congrads[i][volk];

	mov	eax, DWORD PTR [edx]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	and	eax, 16777215				; 00ffffffH
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN40@lagrange_a
	lea	ecx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [ecx+eax]
	jmp	SHORT $LN43@lagrange_a
$LN40@lagrange_a:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN41@lagrange_a
	mov	ecx, DWORD PTR _localbase
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN43@lagrange_a
$LN41@lagrange_a:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN42@lagrange_a
	mov	ecx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN43@lagrange_a
$LN42@lagrange_a:
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN43@lagrange_a:
	mov	ecx, DWORD PTR _vpressures
	fld	QWORD PTR [ecx+esi*8]
	mov	ecx, DWORD PTR _optparam_congrads
	fmul	QWORD PTR [eax+176]
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	fmul	QWORD PTR [eax+edi*8]
	mov	eax, DWORD PTR tv1137[ebp]
	fadd	QWORD PTR [edx+16]
	fstp	QWORD PTR [edx+16]
$LN46@lagrange_a:

; 932  :       { struct gen_quant *q = GEN_QUANT(k);
; 933  :         int fixi = q->fixnum;

	test	DWORD PTR [eax+652], 524288		; 00080000H
	mov	esi, DWORD PTR [eax+740]

; 934  :         int volk = q->vol_number;

	mov	edi, DWORD PTR [eax+736]

; 935  :         if ( q->flags & Q_DELETED ) continue;

	jne	$LN53@lagrange_a

; 936  :         if ( fixi >= 0 )

	test	esi, esi
	js	$LN53@lagrange_a

; 937  :           optparam[i].velocity += vpressures[fixi]*
; 938  :               globals(optparam[i].pnum)->attr.varstuff.pscale*
; 939  :                  optparam_congrads[i][volk];

	mov	eax, DWORD PTR [edx]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	and	eax, 16777215				; 00ffffffH
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN47@lagrange_a
	lea	ecx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [ecx+eax]
	jmp	SHORT $LN50@lagrange_a
$LN47@lagrange_a:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN48@lagrange_a
	mov	ecx, DWORD PTR _localbase
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN50@lagrange_a
$LN48@lagrange_a:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN49@lagrange_a
	mov	ecx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN50@lagrange_a
$LN49@lagrange_a:
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN50@lagrange_a:
	mov	ecx, DWORD PTR _vpressures
	fld	QWORD PTR [ecx+esi*8]
	mov	ecx, DWORD PTR _optparam_congrads
	fmul	QWORD PTR [eax+176]
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	fmul	QWORD PTR [eax+edi*8]
	mov	eax, DWORD PTR tv1137[ebp]
	fadd	QWORD PTR [edx+16]
	fstp	QWORD PTR [edx+16]
$LN53@lagrange_a:

; 931  :       for ( k = 0 ; k < gen_quant_count ; k++ )

	add	eax, 1472				; 000005c0H
	dec	DWORD PTR tv365[ebp]
	mov	DWORD PTR tv1137[ebp], eax
	jne	$LL57@lagrange_a
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _web+5528
$LN56@lagrange_a:
	cmp	eax, ecx
	jge	$LN7@lagrange_a
	mov	edi, DWORD PTR _gen_quant_list
	mov	esi, eax
	imul	esi, 368				; 00000170H
	sub	ecx, eax
	lea	esi, DWORD PTR [esi+edi+220]
	mov	DWORD PTR tv204[ebp], ecx
	npad	10
$LC5@lagrange_a:

; 935  :         if ( q->flags & Q_DELETED ) continue;

	test	DWORD PTR [esi-84], 524288		; 00080000H
	mov	edi, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [esi]
	jne	$LN4@lagrange_a

; 936  :         if ( fixi >= 0 )

	test	edi, edi
	js	$LN4@lagrange_a

; 937  :           optparam[i].velocity += vpressures[fixi]*
; 938  :               globals(optparam[i].pnum)->attr.varstuff.pscale*
; 939  :                  optparam_congrads[i][volk];

	mov	eax, DWORD PTR [edx]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN14@lagrange_a
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN16@lagrange_a
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN15@lagrange_a
$LN16@lagrange_a:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN14@lagrange_a
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN15@lagrange_a
$LN14@lagrange_a:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx]
$LN15@lagrange_a:
	mov	ecx, DWORD PTR _vpressures
	fld	QWORD PTR [ecx+edi*8]
	mov	ecx, DWORD PTR _i$[ebp]
	fmul	QWORD PTR [eax+176]
	mov	eax, DWORD PTR _optparam_congrads
	mov	eax, DWORD PTR [eax+ecx*4]
	fmul	QWORD PTR [eax+ebx*8]
	fadd	QWORD PTR [edx+16]
	fstp	QWORD PTR [edx+16]
$LN4@lagrange_a:

; 931  :       for ( k = 0 ; k < gen_quant_count ; k++ )

	add	esi, 368				; 00000170H
	dec	DWORD PTR tv204[ebp]
	jne	$LC5@lagrange_a
$LN7@lagrange_a:

; 930  :     for ( i = 0 ; i < optparamcount ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	edx, 56					; 00000038H
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _optparamcount
	jl	$LL59@lagrange_a
	pop	edi
	pop	esi
	pop	ebx
$LN6@lagrange_a:

; 940  :       }
; 941  : 
; 942  : } /* end lagrange_adjust() */

	mov	esp, ebp
	pop	ebp
	ret	0
_lagrange_adjust ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@JFLMCLDN@volume_restore?$CI?$CJ?6?$AA@ ; `string'
PUBLIC	_volume_restore
EXTRN	_partner_move:PROC
EXTRN	_vol_deficit:DWORD
;	COMDAT ??_C@_0BC@JFLMCLDN@volume_restore?$CI?$CJ?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BC@JFLMCLDN@volume_restore?$CI?$CJ?6?$AA@ DB 'volume_restore()', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\fixvol.c
CONST	ENDS
;	COMDAT _volume_restore
_TEXT	SEGMENT
tv430 = -16						; size = 8
_k$ = -12						; size = 4
tv827 = -8						; size = 4
_i$ = -4						; size = 4
_stepsize$ = 8						; size = 8
_mode$ = 16						; size = 4
_volume_restore PROC					; COMDAT

; 1126 : { body_id bi_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1127 :   struct gen_quant *gq;
; 1128 :   int i,k;
; 1129 :   int fixi;
; 1130 : 
; 1131 :   if ( itdebug ) 

	cmp	DWORD PTR _itdebug, 0
	je	SHORT $LN35@volume_res

; 1132 :     outstring("volume_restore()\n");

	push	OFFSET ??_C@_0BC@JFLMCLDN@volume_restore?$CI?$CJ?6?$AA@
	call	_outstring
	add	esp, 4
$LN35@volume_res:

; 1133 : 
; 1134 :   if ( !fixed_constraint_flag ) return;

	cmp	DWORD PTR _fixed_constraint_flag, 0
	je	$LN36@volume_res

; 1135 : 
; 1136 :   vol_deficit = (REAL*)temp_calloc(maxquants,sizeof(REAL));

	mov	eax, DWORD PTR _maxquants
	push	ebx
	push	esi
	push	edi
	push	1136					; 00000470H
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc

; 1137 :   vol_restore = (REAL*)temp_calloc(maxquants,sizeof(REAL));

	mov	ecx, DWORD PTR _maxquants
	push	1137					; 00000471H
	push	OFFSET ??_C@_08KKKHFLBB@FIXVOL?4C?$AA@
	push	8
	push	ecx
	mov	DWORD PTR _vol_deficit, eax
	call	_kb_temp_calloc
	add	esp, 32					; 00000020H

; 1138 : 
; 1139 :   /* gather differences from targets */
; 1140 :   if ( !web.pressure_flag && !everything_quantities_flag )

	cmp	DWORD PTR _web+868, 0
	mov	DWORD PTR _vol_restore, eax
	jne	$LN69@volume_res
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN69@volume_res

; 1141 :   { FOR_ALL_BODIES(bi_id)

	mov	eax, DWORD PTR _web+384
	mov	edi, eax
	shr	edi, 28					; 0000001cH
	and	edi, 1
	je	SHORT $LN69@volume_res
	fldz
$LN67@volume_res:
	mov	edx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	ebx, DWORD PTR [eax+eax]
	mov	edx, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv430[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN31@volume_res

; 1142 :      {
; 1143 :        if ( !(get_battr(bi_id) & FIXEDVOL) ) continue;

	and	ecx, 32					; 00000020H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN31@volume_res

; 1144 :        fixi = get_body_fixnum(bi_id);

	mov	eax, DWORD PTR [edx+420]

; 1145 :        if ( fixi < 0 ) continue;

	test	eax, eax
	js	SHORT $LN31@volume_res

; 1146 :        vol_deficit[fixi] = get_body_fixvol(bi_id) - get_body_volume(bi_id);

	test	edi, edi
	je	SHORT $LN52@volume_res
	fld	QWORD PTR [edx+32]
	fld	QWORD PTR [edx+40]
	jmp	SHORT $LN57@volume_res
$LN52@volume_res:
	fld	ST(0)
	fld	ST(1)
$LN57@volume_res:
	mov	ecx, DWORD PTR _vol_deficit
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+eax*8]
$LN31@volume_res:

; 1141 :   { FOR_ALL_BODIES(bi_id)

	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [eax]
	mov	edi, eax
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	SHORT $LN67@volume_res
	fstp	ST(0)
$LN69@volume_res:

; 1147 :      }
; 1148 :   }
; 1149 :   for ( k = 0 ; k < gen_quant_count ; k++ )

	xor	edx, edx
	mov	esi, 268435456				; 10000000H
	cmp	DWORD PTR _web+5528, edx
	jle	SHORT $LN23@volume_res
	mov	eax, DWORD PTR _gen_quant_list
	add	eax, 136				; 00000088H
$LL25@volume_res:

; 1150 :   { gq = GEN_QUANT(k);
; 1151 :     if ( gq->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN24@volume_res

; 1152 :     if ( !(gq->flags & Q_FIXED) ) continue;

	test	cl, 2
	je	SHORT $LN24@volume_res

; 1153 :     if ( valid_id(gq->b_id) && web.pressure_flag ) continue;

	test	DWORD PTR [eax+80], esi
	je	SHORT $LN20@volume_res
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN24@volume_res
$LN20@volume_res:

; 1154 :     fixi = gq->fixnum;

	mov	ecx, DWORD PTR [eax+88]

; 1155 :     if ( fixi < 0 ) continue;

	test	ecx, ecx
	js	SHORT $LN24@volume_res

; 1156 :     vol_deficit[fixi] = gq->target - gq->value;

	fld	QWORD PTR [eax+8]
	mov	edi, DWORD PTR _vol_deficit
	fsub	QWORD PTR [eax+16]
	fstp	QWORD PTR [edi+ecx*8]
$LN24@volume_res:

; 1147 :      }
; 1148 :   }
; 1149 :   for ( k = 0 ; k < gen_quant_count ; k++ )

	inc	edx
	add	eax, 368				; 00000170H
	cmp	edx, DWORD PTR _web+5528
	jl	SHORT $LL25@volume_res
$LN23@volume_res:

; 1157 :   }
; 1158 : 
; 1159 :   /* solve for volume restoration coefficients */
; 1160 :   if ( sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, 0
	je	SHORT $LN18@volume_res

; 1161 :   { if ( LS.A == NULL ) calc_leftside(); 

	cmp	DWORD PTR _LS+60, 0
	jne	SHORT $LN17@volume_res
	call	_calc_leftside
$LN17@volume_res:

; 1162 :     if ( ysmp_flag == MKL_FACTORING )

	cmp	DWORD PTR _ysmp_flag, 3

; 1163 :       mkl_solve(&LS,vol_deficit,vol_restore,MKL_POS_DEF);

	push	2
	jne	SHORT $LN16@volume_res
	mov	ecx, DWORD PTR _vol_restore
	mov	edx, DWORD PTR _vol_deficit
	push	ecx
	push	edx
	push	OFFSET _LS
	call	_mkl_solve

; 1164 :     else

	jmp	SHORT $LN86@volume_res
$LN16@volume_res:

; 1165 :       ysmp_solve(&LS,vol_deficit,vol_restore,MKL_POS_DEF);

	mov	eax, DWORD PTR _vol_restore
	mov	ecx, DWORD PTR _vol_deficit
	push	eax
	push	ecx
	push	OFFSET _LS
	call	_ysmp_solve
$LN86@volume_res:
	add	esp, 16					; 00000010H

; 1166 :     free_system(&LS);

	push	OFFSET _LS
	call	_free_system
	add	esp, 4

; 1167 :   }
; 1168 :   else

	jmp	SHORT $LN14@volume_res
$LN18@volume_res:

; 1169 :   { if ( rleftside == NULL ) calc_leftside();

	cmp	DWORD PTR _rleftside, 0
	jne	SHORT $LN13@volume_res
	call	_calc_leftside
$LN13@volume_res:

; 1170 :     LD_solve(rleftside,vol_deficit,vol_restore,fixcount);

	mov	edx, DWORD PTR _fixcount
	mov	eax, DWORD PTR _vol_restore
	mov	ecx, DWORD PTR _vol_deficit
	push	edx
	mov	edx, DWORD PTR _rleftside
	push	eax
	push	ecx
	push	edx
	call	_LD_solve
	add	esp, 16					; 00000010H
$LN14@volume_res:

; 1171 :   }
; 1172 :   
; 1173 :   /* subtract multiples of volume gradients from force */
; 1174 :   /* and combine multiples of gradients for restoring motion */
; 1175 : 
; 1176 :   /* set restoring motion */
; 1177 : 
; 1178 :   /* optimizing parameter adjust */
; 1179 :   if ( optparamcount )

	mov	ecx, DWORD PTR _optparamcount
	test	ecx, ecx
	je	$LN9@volume_res

; 1180 :     for ( i = 0 ; i < optparamcount ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jle	$LN9@volume_res
	mov	eax, DWORD PTR _gen_quant_list
	mov	DWORD PTR tv827[ebp], OFFSET _optparam
$LL11@volume_res:

; 1181 :      for ( k = 0 ; k < gen_quant_count ; k++ )

	cmp	DWORD PTR _web+5528, 0
	mov	DWORD PTR _k$[ebp], 0
	jle	$LN10@volume_res
	xor	edi, edi
	npad	8
$LL70@volume_res:

; 1182 :      { struct gen_quant *q = GEN_QUANT(k);
; 1183 :        int fixk = q->fixnum;
; 1184 :        int volk = q->vol_number;
; 1185 :        if ( q->flags & Q_DELETED ) continue;

	test	DWORD PTR [edi+eax+136], 524288		; 00080000H
	mov	edx, DWORD PTR [edi+eax+224]
	mov	esi, DWORD PTR [edi+eax+220]
	jne	$LN7@volume_res

; 1186 :        if ( fixk >= 0 )

	test	edx, edx
	js	$LN7@volume_res

; 1187 :        { struct global *g = globals(optparam[i].pnum);

	mov	eax, DWORD PTR tv827[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN38@volume_res
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN40@volume_res
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN39@volume_res
$LN40@volume_res:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN38@volume_res
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN39@volume_res
$LN38@volume_res:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx]
$LN39@volume_res:

; 1188 :          g->value.real += vol_restore[fixk]
; 1189 :             *g->attr.varstuff.pscale*optparam_congrads[i][volk];

	mov	ecx, DWORD PTR _optparam_congrads
	mov	ebx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ebx, DWORD PTR _vol_restore
	fld	QWORD PTR [ebx+edx*8]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [ecx+esi*8]
	fadd	QWORD PTR [eax+64]
	fstp	QWORD PTR [eax+64]

; 1190 :          if ( g->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [eax+188]
	test	eax, eax
	je	$LN66@volume_res

; 1191 :          { struct  global *gg = globals(g->attr.varstuff.on_assign_call);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN44@volume_res
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN46@volume_res
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN45@volume_res
$LN46@volume_res:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN44@volume_res
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN45@volume_res
$LN44@volume_res:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN45@volume_res:

; 1192 :            eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	add	esp, 16					; 00000010H
$LN66@volume_res:
	mov	eax, DWORD PTR _gen_quant_list
$LN7@volume_res:

; 1181 :      for ( k = 0 ; k < gen_quant_count ; k++ )

	mov	ecx, DWORD PTR _k$[ebp]
	inc	ecx
	add	edi, 368				; 00000170H
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ecx, DWORD PTR _web+5528
	jl	$LL70@volume_res
	mov	ecx, DWORD PTR _optparamcount
$LN10@volume_res:

; 1180 :     for ( i = 0 ; i < optparamcount ; i++ )

	mov	edx, DWORD PTR _i$[ebp]
	add	DWORD PTR tv827[ebp], 56		; 00000038H
	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, ecx
	jl	$LL11@volume_res
$LN9@volume_res:

; 1193 :          }
; 1194 :        }
; 1195 :      }
; 1196 : 
; 1197 :   #ifdef MPI_EVOLVER
; 1198 :   mpi_volume_restore(maxquants,stepsize,mode);
; 1199 :   #else
; 1200 :   local_volume_restore(stepsize,mode);

	mov	edx, DWORD PTR _mode$[ebp]
	fld	QWORD PTR _stepsize$[ebp]
	push	edx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_local_volume_restore
	add	esp, 12					; 0000000cH

; 1201 :   #endif
; 1202 : 
; 1203 :   partner_move();  /* in case doing partners */

	call	_partner_move

; 1204 :   
; 1205 :   if ( vol_deficit ) temp_free((char *)vol_deficit);  vol_deficit = NULL;

	mov	eax, DWORD PTR _vol_deficit
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN2@volume_res
	push	eax
	call	_temp_free
	add	esp, 4
$LN2@volume_res:

; 1206 :   if ( vol_restore ) temp_free((char *)vol_restore);  vol_restore = NULL;

	mov	eax, DWORD PTR _vol_restore
	mov	DWORD PTR _vol_deficit, 0
	test	eax, eax
	je	SHORT $LN1@volume_res
	push	eax
	call	_temp_free
	add	esp, 4
$LN1@volume_res:
	mov	DWORD PTR _vol_restore, 0
$LN36@volume_res:

; 1207 : 
; 1208 : } /* end volume_restore() */

	mov	esp, ebp
	pop	ebp
	ret	0
_volume_restore ENDP
_TEXT	ENDS
END
