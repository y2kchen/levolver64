; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\METHOD1.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_get_fe_facet
EXTRN	_web:BYTE
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_get_edge_wrap
EXTRN	_sym_inverse:DWORD
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_wrap PROC					; COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  :   WRAPTYPE wrap = *EINT(e_id,E_WRAP_ATTR) ;

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+784]
	mov	eax, DWORD PTR [eax+edx]
	pop	esi

; 165  :   return    ( inverted(e_id) ? (*sym_inverse)(wrap) : wrap );

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN4@get_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@get_edge_w:

; 166  : }

	pop	ebp
	ret	0
_get_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_extra
; Function compile flags: /Ogtp
;	COMDAT _get_extra
_TEXT	SEGMENT
_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_extra PROC						; COMDAT

; 348  : { int type = id_type(id);

	push	ebp
	mov	ebp, esp

; 349  : 
; 350  :   return ( (char*)elptr(id) + EXTRAS(type)[n].offset);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	shr	eax, 29					; 0000001dH
	imul	esi, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, esi
	add	eax, DWORD PTR [edi+ecx+64]
	pop	edi
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_get_extra ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_null_length_grad
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\method1.c
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _null_length_grad
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_null_length_grad PROC					; COMDAT

; 24   : { return 0.0;

	fldz

; 25   : }

	ret	0
_null_length_grad ENDP
_TEXT	ENDS
PUBLIC	_null_length_hess
; Function compile flags: /Ogtp
;	COMDAT _null_length_hess
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_null_length_hess PROC					; COMDAT

; 27   : { return 0.0;

	fldz

; 28   : }

	ret	0
_null_length_hess ENDP
_TEXT	ENDS
PUBLIC	_null_area_value
EXTRN	_q_facet_tension_value:PROC
; Function compile flags: /Ogtp
;	COMDAT _null_area_value
_TEXT	SEGMENT
_f_info$ = 8						; size = 4
_null_area_value PROC					; COMDAT

; 34   : { q_facet_tension_value(f_info);

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _f_info$[ebp]
	push	eax
	call	_q_facet_tension_value
	fstp	ST(0)

; 35   :   return 0.0;

	fldz
	add	esp, 4

; 36   : }

	pop	ebp
	ret	0
_null_area_value ENDP
_TEXT	ENDS
PUBLIC	_null_area_grad
; Function compile flags: /Ogtp
;	COMDAT _null_area_grad
_TEXT	SEGMENT
_f_info$ = 8						; size = 4
_null_area_grad PROC					; COMDAT

; 38   : { return 0.0;

	fldz

; 39   : }

	ret	0
_null_area_grad ENDP
_TEXT	ENDS
PUBLIC	_null_area_hess
; Function compile flags: /Ogtp
;	COMDAT _null_area_hess
_TEXT	SEGMENT
_f_info$ = 8						; size = 4
_null_area_hess PROC					; COMDAT

; 41   : { return 0.0;

	fldz

; 42   : }

	ret	0
_null_area_hess ENDP
_TEXT	ENDS
PUBLIC	_vertex_scalar_integral_init
; Function compile flags: /Ogtp
;	COMDAT _vertex_scalar_integral_init
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_vertex_scalar_integral_init PROC			; COMDAT

; 62   : }

	ret	0
_vertex_scalar_integral_init ENDP
_TEXT	ENDS
PUBLIC	_vertex_scalar_integral
EXTRN	_gen_quant_list:DWORD
EXTRN	_eval:PROC
EXTRN	_meth_inst_list:DWORD
; Function compile flags: /Ogtp
;	COMDAT _vertex_scalar_integral
_TEXT	SEGMENT
_area$ = -12						; size = 8
_b_id$89060 = -4					; size = 4
_fe_id$89064 = 8					; size = 4
_v_info$ = 8						; size = 4
_vertex_scalar_integral PROC				; COMDAT

; 73   : { REAL area;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 74   :   struct method_instance *mi = METH_INSTANCE(v_info->method);

	mov	edi, DWORD PTR _v_info$[ebp]
	mov	eax, DWORD PTR [edi+8]

; 75   :   
; 76   :   area = eval(mi->expr[0],v_info->x[0],v_info->id, NULL);

	mov	ecx, DWORD PTR [edi+416]
	cdq
	mov	esi, eax
	mov	eax, DWORD PTR [edi]
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list
	push	0
	mov	edx, DWORD PTR [esi+232]
	push	eax
	push	ecx
	push	edx
	call	_eval
	add	esp, 16					; 00000010H

; 77   : 
; 78   :   if ( mi->flags & DEFAULT_INSTANCE )

	test	DWORD PTR [esi+140], 4194304		; 00400000H
	fstp	QWORD PTR _area$[ebp]
	je	$LN3@vertex_sca

; 79   :   { /* add to facet area */
; 80   :     body_id b_id,bb_id;
; 81   :     edge_id e_id = get_vertex_edge(v_info->id);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [edx+28]

; 82   :     facetedge_id fe_id = get_edge_fe(e_id);

	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	test	eax, eax
	jne	SHORT $LN16@vertex_sca
	xor	edi, edi
	mov	DWORD PTR _fe_id$89064[ebp], edi
	jmp	SHORT $LN17@vertex_sca
$LN16@vertex_sca:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN15@vertex_sca
	xor	eax, 134217728				; 08000000H
$LN15@vertex_sca:
	mov	DWORD PTR _fe_id$89064[ebp], eax
	mov	edi, eax
$LN17@vertex_sca:

; 83   :     facetedge_id fe;
; 84   :     facet_id f_id;
; 85   : 
; 86   :     if ( !valid_id(e_id) || !valid_id(fe_id) )

	test	ecx, 268435456				; 10000000H
	je	$LN6@vertex_sca
	test	edi, 268435456				; 10000000H
	je	$LN6@vertex_sca

; 88   :     b_id = GEN_QUANT(mi->quants[0])->b_id;

	mov	eax, DWORD PTR [esi+152]
	mov	ecx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	mov	edx, DWORD PTR [eax+ecx+216]
	push	ebx

; 89   :     fe = fe_id;

	mov	ebx, DWORD PTR _web+460
	mov	DWORD PTR _b_id$89060[ebp], edx
	npad	3
$LL5@vertex_sca:

; 90   :     do
; 91   :     { f_id = get_fe_facet(fe);

	test	edi, 268435456				; 10000000H
	jne	SHORT $LN20@vertex_sca
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN19@vertex_sca
$LN20@vertex_sca:
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	esi, DWORD PTR [ecx+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN19@vertex_sca
	xor	esi, 134217728				; 08000000H
$LN19@vertex_sca:

; 92   :       bb_id = get_facet_body(f_id);

	push	esi
	call	_get_facet_body
	add	esp, 4

; 93   :       if ( equal_id(b_id,bb_id) )

	cmp	DWORD PTR _b_id$89060[ebp], eax
	jne	SHORT $LN30@vertex_sca

; 94   :          add_facet_area(f_id,-area);

	fld	QWORD PTR _area$[ebp]
	fchs
	test	esi, 134217728				; 08000000H
	je	SHORT $LN12@vertex_sca
	fchs
$LN12@vertex_sca:
	mov	eax, DWORD PTR _web+236
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	fadd	QWORD PTR [eax+40]
	fstp	QWORD PTR [eax+40]
	mov	ebx, DWORD PTR _web+460
$LN30@vertex_sca:

; 95   :       bb_id = get_facet_body(inverse_id(f_id));

	mov	ecx, esi
	xor	ecx, 134217728				; 08000000H
	push	ecx
	call	_get_facet_body
	add	esp, 4

; 96   :       if ( equal_id(b_id,bb_id) )

	cmp	DWORD PTR _b_id$89060[ebp], eax
	jne	SHORT $LN28@vertex_sca

; 97   :          add_facet_area(f_id,-area);

	fld	QWORD PTR _area$[ebp]
	fchs
	test	esi, 134217728				; 08000000H
	je	SHORT $LN14@vertex_sca
	fchs
$LN14@vertex_sca:
	mov	edx, DWORD PTR _web+236
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+esi*4]
	fadd	QWORD PTR [esi+40]
	fstp	QWORD PTR [esi+40]
	mov	ebx, DWORD PTR _web+460
$LN28@vertex_sca:

; 98   :       fe = get_next_facet(fe);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN24@vertex_sca
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+edi*4]
	mov	edi, DWORD PTR [eax+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN4@vertex_sca
$LN24@vertex_sca:
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+edi*4]
	mov	edi, DWORD PTR [ecx+40]
$LN4@vertex_sca:

; 99   :     } while ( !equal_id(fe,fe_id) );

	cmp	edi, DWORD PTR _fe_id$89064[ebp]
	jne	$LL5@vertex_sca
	pop	ebx
$LN3@vertex_sca:

; 100  :   }
; 101  : 
; 102  :   return area;

	fld	QWORD PTR _area$[ebp]
	pop	edi
	pop	esi

; 103  : } // end vertex_scalar_integral()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@vertex_sca:

; 87   :       return 0.0;

	fldz
	pop	edi
	pop	esi

; 103  : } // end vertex_scalar_integral()

	mov	esp, ebp
	pop	ebp
	ret	0
_vertex_scalar_integral ENDP
_TEXT	ENDS
PUBLIC	_vertex_scalar_integral_grad
EXTRN	_eval_all:PROC
; Function compile flags: /Ogtp
;	COMDAT _vertex_scalar_integral_grad
_TEXT	SEGMENT
_value$ = -8						; size = 8
_v_info$ = 8						; size = 4
_vertex_scalar_integral_grad PROC			; COMDAT

; 114  : { REAL value = 0.0;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 115  :   struct method_instance *mi = METH_INSTANCE(v_info->method);
; 116  : 
; 117  :   eval_all(mi->expr[0],v_info->x[0],SDIM,&value,
; 118  :      v_info->grad[0],v_info->id);

	mov	eax, DWORD PTR _v_info$[ebp]
	fldz
	mov	ecx, DWORD PTR [eax]
	fstp	QWORD PTR _value$[ebp]
	mov	edx, DWORD PTR [eax+1336]
	push	ecx
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _web+616
	lea	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	edx, DWORD PTR [eax+416]
	mov	eax, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _meth_inst_list
	push	edx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	mov	edx, DWORD PTR [eax+ecx+232]
	push	edx
	call	_eval_all
	add	esp, 24					; 00000018H

; 119  : 
; 120  :   return value;

	fld	QWORD PTR _value$[ebp]

; 121  : } // end vertex_scalar_integral_grad()

	mov	esp, ebp
	pop	ebp
	ret	0
_vertex_scalar_integral_grad ENDP
_TEXT	ENDS
PUBLIC	_vertex_scalar_integral_hess
EXTRN	_eval_second:PROC
; Function compile flags: /Ogtp
;	COMDAT _vertex_scalar_integral_hess
_TEXT	SEGMENT
_value$ = -8						; size = 8
_v_info$ = 8						; size = 4
_vertex_scalar_integral_hess PROC			; COMDAT

; 132  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 133  :   REAL value = 0.0;
; 134  :   struct method_instance *mi = METH_INSTANCE(v_info->method); 
; 135  : 
; 136  :   eval_second(mi->expr[0],v_info->x[0],SDIM,&value,
; 137  :         v_info->grad[0], v_info->hess[0][0],v_info->id);

	mov	eax, DWORD PTR _v_info$[ebp]
	fldz
	mov	ecx, DWORD PTR [eax]
	fstp	QWORD PTR _value$[ebp]
	mov	edx, DWORD PTR [eax+1340]
	push	ecx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+1336]
	push	edx
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	edx, DWORD PTR _web+616
	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+416]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	mov	eax, DWORD PTR [eax+edx+232]
	push	ecx
	push	eax
	call	_eval_second
	add	esp, 28					; 0000001cH

; 138  :   return value;

	fld	QWORD PTR _value$[ebp]

; 139  : } // end vertex_scalar_integral_hess()

	mov	esp, ebp
	pop	ebp
	ret	0
_vertex_scalar_integral_hess ENDP
_TEXT	ENDS
PUBLIC	_q_edge_tension_init
; Function compile flags: /Ogtp
;	COMDAT _q_edge_tension_init
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_q_edge_tension_init PROC				; COMDAT

; 159  : }

	ret	0
_q_edge_tension_init ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_length_q_value
EXTRN	_binary_tree_add:PROC
EXTRN	_proc_total_area:BYTE
EXTRN	_win_get_thread_data:PROC
EXTRN	_thread_data_key:DWORD
EXTRN	_nprocs:DWORD
EXTRN	_gauss1Dwt:DWORD
EXTRN	_dot:PROC
EXTRN	_gauss1polyd:DWORD
EXTRN	_edge_ctrl:DWORD
EXTRN	_gauss1D_num:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogtp
;	COMDAT _edge_length_q_value
_TEXT	SEGMENT
_mi$ = -76						; size = 4
_k$ = -72						; size = 4
_value$ = -68						; size = 8
tv987 = -60						; size = 4
_e_info$GSCopy$ = -56					; size = 4
_tang$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_length_q_value PROC				; COMDAT

; 290  : { int j,k,m;

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 291  :   REAL value = 0.0;

	fldz
	push	esi
	fld	ST(0)
	push	edi
	fst	QWORD PTR _value$[ebp]
	mov	edi, DWORD PTR _e_info$[ebp]

; 292  :   REAL tang[MAXCOORD];
; 293  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	eax, DWORD PTR [edi+8]
	cdq
	mov	ebx, eax
	xor	ebx, edx
	sub	ebx, edx
	imul	ebx, 2928				; 00000b70H
	add	ebx, DWORD PTR _meth_inst_list

; 294  : 
; 295  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	esi, esi
	mov	DWORD PTR _e_info$GSCopy$[ebp], edi
	mov	DWORD PTR _mi$[ebp], ebx
	cmp	DWORD PTR _gauss1D_num, esi
	jle	$LN31@edge_lengt
	fstp	ST(0)
	jmp	SHORT $LN13@edge_lengt
	npad	5
$LL62@edge_lengt:
	fstp	ST(0)
	fldz
$LN13@edge_lengt:

; 296  :   { for ( j = 0 ; j < SDIM ; j ++ )

	mov	ecx, DWORD PTR _web+616
	xor	eax, eax
	test	ecx, ecx
	jle	$LN35@edge_lengt
	mov	ebx, DWORD PTR _edge_ctrl
$LN29@edge_lengt:

; 298  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	ecx, ecx
	fst	QWORD PTR _tang$[ebp+eax*8]
	cmp	ebx, 4
	jl	$LC23@edge_lengt

; 297  :     { tang[j] = 0.0;

	mov	edx, DWORD PTR _gauss1polyd
	lea	ecx, DWORD PTR [edi+420]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv987[ebp], edi
	add	edi, edi
	add	edx, 8
	add	edi, edi
	mov	DWORD PTR _k$[ebp], edi

; 298  :       for ( k = 0 ; k < edge_ctrl ; k++ )

$LN24@edge_lengt:

; 299  :          tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	edi, DWORD PTR [edx-8]
	fld	QWORD PTR [edi+esi*8]
	mov	ebx, DWORD PTR [ecx-4]
	fmul	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [ecx]
	add	ecx, 16					; 00000010H
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv987[ebp]
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	edi, DWORD PTR [edx-20]
	fld	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR [ecx-12]
	fmul	QWORD PTR [ebx+eax*8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	ebx, DWORD PTR [edx-16]
	fld	QWORD PTR [edi+eax*8]
	fmul	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR [ecx-8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	edi, DWORD PTR [edx-12]
	fld	QWORD PTR [edi+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _tang$[ebp+eax*8]
	jne	SHORT $LN24@edge_lengt

; 297  :     { tang[j] = 0.0;

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ebx, DWORD PTR _edge_ctrl
$LC23@edge_lengt:

; 298  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	cmp	ecx, ebx
	jge	SHORT $LN9@edge_lengt
	lea	edi, DWORD PTR [edi+ecx*4+416]
$LN27@edge_lengt:

; 299  :          tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	edx, DWORD PTR _gauss1polyd
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [edi]
	fld	QWORD PTR [edx+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR _edge_ctrl
	inc	ecx
	add	edi, 4
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fstp	QWORD PTR _tang$[ebp+eax*8]
	cmp	ecx, ebx
	jl	SHORT $LN27@edge_lengt

; 298  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
$LN9@edge_lengt:

; 296  :   { for ( j = 0 ; j < SDIM ; j ++ )

	mov	ecx, DWORD PTR _web+616
	inc	eax
	cmp	eax, ecx
	jl	$LN29@edge_lengt
	mov	ebx, DWORD PTR _mi$[ebp]
$LN35@edge_lengt:

; 300  :     }
; 301  :     value += gauss1Dwt[m]*sqrt(SDIM_dot(tang,tang));

	push	ecx
	fstp	ST(0)
	lea	eax, DWORD PTR _tang$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	mov	edx, DWORD PTR _gauss1Dwt
	fmul	QWORD PTR [edx+esi*8]
	inc	esi
	fadd	QWORD PTR _value$[ebp]
	fst	QWORD PTR _value$[ebp]
	cmp	esi, DWORD PTR _gauss1D_num
	jl	$LL62@edge_lengt

; 294  : 
; 295  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	jmp	SHORT $LN11@edge_lengt
$LN31@edge_lengt:
	fstp	ST(1)
$LN11@edge_lengt:

; 302  :   }
; 303  :   if ( mi->flags & DEFAULT_INSTANCE )

	test	DWORD PTR [ebx+140], 4194304		; 00400000H
	je	SHORT $LN4@edge_lengt

; 304  :   {
; 305  : #ifdef SHARED_MEMORY
; 306  :      if ( nprocs > 1 ) 

	cmp	DWORD PTR _nprocs, 1
	jle	SHORT $LN3@edge_lengt

; 307  :       proc_total_area[GET_THREAD_ID] += value;

	mov	eax, DWORD PTR _thread_data_key
	fstp	ST(0)
	push	eax
	call	_win_get_thread_data
	mov	eax, DWORD PTR [eax]
	fld	QWORD PTR _proc_total_area[eax*8]
	add	esp, 4
	fld	QWORD PTR _value$[ebp]
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _proc_total_area[eax*8]

; 308  :      else

	jmp	SHORT $LN2@edge_lengt
$LN3@edge_lengt:

; 309  : #endif
; 310  :      binary_tree_add(web.total_area_addends,value);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1000
	call	_binary_tree_add
	fld	QWORD PTR _value$[ebp]
	add	esp, 12					; 0000000cH
$LN2@edge_lengt:

; 311  :      set_edge_length(e_info->id,value); 

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	fst	QWORD PTR [eax+48]
$LN4@edge_lengt:

; 312  :   }
; 313  :   if ( mi->flags & USE_DENSITY )

	test	DWORD PTR [ebx+140], 536870912		; 20000000H
	je	SHORT $LN1@edge_lengt

; 314  :       value *= get_edge_density(e_info->id);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	fmul	QWORD PTR [eax+40]
$LN1@edge_lengt:

; 315  :   return value;
; 316  : } // end edge_length_q_value()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_length_q_value ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_length_q_grad
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _edge_length_q_grad
_TEXT	SEGMENT
_density$ = -80						; size = 8
_value$ = -72						; size = 8
_k$ = -64						; size = 4
tv1023 = -60						; size = 4
_e_info$GSCopy$ = -56					; size = 4
_tang$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_length_q_grad PROC				; COMDAT

; 327  : { int m,k,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 328  :   REAL value = 0.0;

	fldz

; 329  :   REAL len,fudge;
; 330  :   REAL tang[MAXCOORD];
; 331  :   REAL density;
; 332  :   struct method_instance *mi = METH_INSTANCE(e_info->method);
; 333  : 
; 334  :   if ( mi->flags & USE_DENSITY )

	mov	ecx, DWORD PTR _meth_inst_list
	push	ebx
	fst	QWORD PTR _value$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [edi+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	test	DWORD PTR [eax+ecx+140], 536870912	; 20000000H

; 345  :           tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	DWORD PTR _e_info$GSCopy$[ebp], edi
	je	SHORT $LN24@edge_lengt@2

; 335  :      density = get_edge_density(e_info->id);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	fld	QWORD PTR [ecx+40]
	jmp	SHORT $LN96@edge_lengt@2
$LN24@edge_lengt@2:

; 336  :   else density = 1.0;

	fld1
$LN96@edge_lengt@2:

; 337  : 
; 338  :   for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _edge_ctrl
	fstp	QWORD PTR _density$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN20@edge_lengt@2
$LN22@edge_lengt@2:

; 339  :      for ( m = 0 ; m < edge_ctrl ; m++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN21@edge_lengt@2
$LN19@edge_lengt@2:

; 340  :         e_info->grad[m][j] = 0.0;

	mov	edx, DWORD PTR [edi+1336]
	mov	edx, DWORD PTR [edx+eax*4]
	fst	QWORD PTR [edx+ecx*8]
	mov	ebx, DWORD PTR _edge_ctrl
	inc	eax
	cmp	eax, ebx
	jl	SHORT $LN19@edge_lengt@2
$LN21@edge_lengt@2:

; 337  : 
; 338  :   for ( j = 0 ; j < SDIM ; j++ )

	inc	ecx
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN22@edge_lengt@2
$LN20@edge_lengt@2:

; 341  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	esi, esi
	cmp	DWORD PTR _gauss1D_num, esi
	jle	$LN95@edge_lengt@2
$LN49@edge_lengt@2:

; 342  :   { for ( j = 0 ; j < SDIM ; j ++ )

	mov	ecx, DWORD PTR _web+616
	xor	eax, eax
	test	ecx, ecx
	jle	$LN81@edge_lengt@2
$LN51@edge_lengt@2:

; 344  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	ecx, ecx
	fst	QWORD PTR _tang$[ebp+eax*8]
	cmp	ebx, 4
	jl	$LC42@edge_lengt@2

; 343  :     { tang[j] = 0.0;

	mov	edx, DWORD PTR _gauss1polyd
	lea	ecx, DWORD PTR [edi+420]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv1023[ebp], edi
	add	edi, edi
	add	edx, 8
	add	edi, edi
	mov	DWORD PTR _k$[ebp], edi

; 344  :       for ( k = 0 ; k < edge_ctrl ; k++ )

$LN43@edge_lengt@2:

; 345  :           tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	edi, DWORD PTR [edx-8]
	fld	QWORD PTR [edi+esi*8]
	mov	ebx, DWORD PTR [ecx-4]
	fmul	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [ecx]
	add	ecx, 16					; 00000010H
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv1023[ebp]
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	edi, DWORD PTR [edx-20]
	fld	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR [ecx-12]
	fmul	QWORD PTR [ebx+eax*8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	ebx, DWORD PTR [edx-16]
	fld	QWORD PTR [edi+eax*8]
	fmul	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR [ecx-8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	edi, DWORD PTR [edx-12]
	fld	QWORD PTR [edi+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _tang$[ebp+eax*8]
	jne	SHORT $LN43@edge_lengt@2

; 343  :     { tang[j] = 0.0;

	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	ebx, DWORD PTR _edge_ctrl
$LC42@edge_lengt@2:

; 344  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	cmp	ecx, ebx
	jge	SHORT $LN12@edge_lengt@2
	lea	edi, DWORD PTR [edi+ecx*4+416]
$LN47@edge_lengt@2:

; 345  :           tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	edx, DWORD PTR _gauss1polyd
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [edi]
	fld	QWORD PTR [edx+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR _edge_ctrl
	inc	ecx
	add	edi, 4
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fstp	QWORD PTR _tang$[ebp+eax*8]
	cmp	ecx, ebx
	jl	SHORT $LN47@edge_lengt@2

; 344  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
$LN12@edge_lengt@2:

; 342  :   { for ( j = 0 ; j < SDIM ; j ++ )

	mov	ecx, DWORD PTR _web+616
	inc	eax
	cmp	eax, ecx
	jl	$LN51@edge_lengt@2
$LN81@edge_lengt@2:

; 346  :     }
; 347  :     len = sqrt(SDIM_dot(tang,tang));

	push	ecx
	fstp	ST(0)
	lea	eax, DWORD PTR _tang$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 348  :     if ( len == 0.0 ) continue;

	fld	ST(0)
	fldz

; 350  :     fudge = density*gauss1Dwt[m]/len;
; 351  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	ebx, DWORD PTR _edge_ctrl
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	SHORT $LN85@edge_lengt@2

; 349  :     value += gauss1Dwt[m]*len;

	mov	eax, DWORD PTR _gauss1Dwt
	fld	QWORD PTR [eax+esi*8]

; 350  :     fudge = density*gauss1Dwt[m]/len;
; 351  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	edx, edx
	fmul	ST(0), ST(2)
	fadd	QWORD PTR _value$[ebp]
	fstp	QWORD PTR _value$[ebp]
	fld	QWORD PTR [eax+esi*8]
	fmul	QWORD PTR _density$[ebp]
	fdivrp	ST(2), ST(0)
	test	ebx, ebx
	jle	SHORT $LN85@edge_lengt@2
$LN50@edge_lengt@2:

; 352  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN5@edge_lengt@2

; 341  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	ecx, DWORD PTR _gauss1polyd
	mov	ecx, DWORD PTR [ecx+edx*4]
	lea	ebx, DWORD PTR [ecx+esi*8]
$LN3@edge_lengt@2:

; 353  :          e_info->grad[k][j] += fudge*tang[j]*gauss1polyd[k][m];

	fld	QWORD PTR _tang$[ebp+eax*8]
	mov	ecx, DWORD PTR [edi+1336]
	mov	ecx, DWORD PTR [ecx+edx*4]
	fmul	ST(0), ST(2)
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	eax
	fmul	QWORD PTR [ebx]
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@edge_lengt@2

; 352  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _edge_ctrl
$LN5@edge_lengt@2:

; 350  :     fudge = density*gauss1Dwt[m]/len;
; 351  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	inc	edx
	cmp	edx, ebx
	jl	SHORT $LN50@edge_lengt@2
$LN85@edge_lengt@2:

; 341  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	esi

; 350  :     fudge = density*gauss1Dwt[m]/len;
; 351  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	fstp	ST(1)
	cmp	esi, DWORD PTR _gauss1D_num
	jl	$LN49@edge_lengt@2
$LN95@edge_lengt@2:

; 354  :   }
; 355  : 
; 356  :   return density*value;
; 357  : } // end edge_length_q_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	fld	QWORD PTR _density$[ebp]
	pop	edi
	fmul	QWORD PTR _value$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_length_q_grad ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_length_q_hess
; Function compile flags: /Ogtp
;	COMDAT _edge_length_q_hess
_TEXT	SEGMENT
_value$ = -88						; size = 8
_density$ = -80						; size = 8
_m$ = -72						; size = 4
_e_info$GSCopy$ = -68					; size = 4
tv294 = -64						; size = 4
_kk$ = -64						; size = 4
tv1585 = -60						; size = 4
tv986 = -60						; size = 4
tv1234 = -56						; size = 4
_k$ = -56						; size = 4
_tang$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_length_q_hess PROC				; COMDAT

; 368  : { int m,j,jj,k,kk;

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 369  :   REAL value = 0.0;

	fldz

; 370  :   REAL len,density,fudge;
; 371  :   REAL sumgrad[2][MAXCOORD];
; 372  :   REAL sumhess[2][2][MAXCOORD][MAXCOORD];
; 373  :   REAL tang[MAXCOORD];
; 374  :   struct method_instance *mi = METH_INSTANCE(e_info->method);
; 375  : 
; 376  :   if ( mi->flags & USE_DENSITY )

	mov	ecx, DWORD PTR _meth_inst_list
	push	ebx
	fst	QWORD PTR _value$[ebp]
	mov	ebx, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [ebx+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	test	DWORD PTR [eax+ecx+140], 536870912	; 20000000H
	push	edi

; 399  :             for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	DWORD PTR _e_info$GSCopy$[ebp], ebx
	je	SHORT $LN30@edge_lengt@3

; 377  :      density = get_edge_density(e_info->id);

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	fld	QWORD PTR [ecx+40]
	jmp	SHORT $LN128@edge_lengt@3
$LN30@edge_lengt@3:

; 378  :   else density = 1.0;

	fld1
$LN128@edge_lengt@3:

; 379  : 
; 380  :   /* derivatives of gaussian sum part */
; 381  :   memset((char*)sumgrad,0,sizeof(sumgrad));
; 382  :   memset((char*)sumhess,0,sizeof(sumhess));
; 383  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	edi, edi
	fstp	QWORD PTR _density$[ebp]
	mov	DWORD PTR _m$[ebp], edi
	cmp	DWORD PTR _gauss1D_num, edi
	jle	$LN70@edge_lengt@3
	mov	ecx, DWORD PTR _web+616
	push	esi
	mov	esi, DWORD PTR _edge_ctrl
$LN63@edge_lengt@3:

; 384  :   { for ( j = 0 ; j < SDIM ; j ++ )

	xor	eax, eax
	test	ecx, ecx
	jle	$LN87@edge_lengt@3
$LN25@edge_lengt@3:

; 386  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	edx, edx
	fst	QWORD PTR _tang$[ebp+eax*8]
	cmp	esi, 4
	jl	$LC54@edge_lengt@3

; 385  :     { tang[j] = 0.0;

	mov	edx, DWORD PTR _gauss1polyd
	add	esi, -4					; fffffffcH
	shr	esi, 2
	inc	esi
	mov	DWORD PTR tv294[ebp], esi
	add	edx, 8
	add	esi, esi
	add	esi, esi
	mov	DWORD PTR tv986[ebp], edx
	lea	edx, DWORD PTR [ebx+420]
	mov	DWORD PTR _k$[ebp], esi

; 386  :       for ( k = 0 ; k < edge_ctrl ; k++ )

$LN55@edge_lengt@3:

; 387  :           tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	esi, DWORD PTR tv986[ebp]
	mov	esi, DWORD PTR [esi-8]
	fld	QWORD PTR [esi+edi*8]
	mov	ebx, DWORD PTR [edx-4]
	fmul	QWORD PTR [ebx+eax*8]
	mov	esi, DWORD PTR tv986[ebp]
	mov	ebx, DWORD PTR [edx]
	add	edx, 16					; 00000010H
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	esi, DWORD PTR [esi-4]
	fld	QWORD PTR [esi+edi*8]
	mov	esi, DWORD PTR [edx-12]
	fmul	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR tv986[ebp]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR tv986[ebp]
	fmul	QWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR [edx-8]
	add	DWORD PTR tv986[ebp], 16		; 00000010H
	dec	DWORD PTR tv294[ebp]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	esi, DWORD PTR [esi+4]
	fld	QWORD PTR [esi+edi*8]
	fmul	QWORD PTR [ebx+eax*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _tang$[ebp+eax*8]
	jne	SHORT $LN55@edge_lengt@3

; 385  :     { tang[j] = 0.0;

	mov	edx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _edge_ctrl
	mov	ebx, DWORD PTR _e_info$GSCopy$[ebp]
$LC54@edge_lengt@3:

; 386  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	cmp	edx, esi
	jge	SHORT $LN24@edge_lengt@3
	lea	esi, DWORD PTR [ebx+edx*4+416]
	mov	DWORD PTR tv1234[ebp], esi
$LN59@edge_lengt@3:

; 387  :           tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	esi, DWORD PTR _gauss1polyd
	mov	esi, DWORD PTR [esi+edx*4]
	mov	ebx, DWORD PTR tv1234[ebp]
	fld	QWORD PTR [esi+edi*8]
	mov	ebx, DWORD PTR [ebx]
	fmul	QWORD PTR [ebx+eax*8]
	mov	esi, DWORD PTR _edge_ctrl
	add	DWORD PTR tv1234[ebp], 4
	inc	edx
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fstp	QWORD PTR _tang$[ebp+eax*8]
	cmp	edx, esi
	jl	SHORT $LN59@edge_lengt@3

; 386  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	ebx, DWORD PTR _e_info$GSCopy$[ebp]
$LN24@edge_lengt@3:

; 384  :   { for ( j = 0 ; j < SDIM ; j ++ )

	inc	eax
	cmp	eax, ecx
	jl	$LN25@edge_lengt@3
$LN87@edge_lengt@3:

; 388  :     }
; 389  :     len = sqrt(SDIM_dot(tang,tang));

	push	ecx
	fstp	ST(0)
	lea	eax, DWORD PTR _tang$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 390  :     if ( len == 0.0 ) continue;

	fld	ST(0)
	fldz

; 392  :     fudge = density*gauss1Dwt[m]/len;
; 393  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	esi, DWORD PTR _edge_ctrl
	mov	ecx, DWORD PTR _web+616
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	$LN89@edge_lengt@3

; 391  :     value += gauss1Dwt[m]*len;

	mov	eax, DWORD PTR _gauss1Dwt
	fld	QWORD PTR [eax+edi*8]

; 392  :     fudge = density*gauss1Dwt[m]/len;
; 393  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	edx, edx
	fmul	ST(0), ST(2)
	fadd	QWORD PTR _value$[ebp]
	fstp	QWORD PTR _value$[ebp]
	fld	QWORD PTR [eax+edi*8]
	fmul	QWORD PTR _density$[ebp]
	fdiv	ST(0), ST(2)
	test	esi, esi
	jle	SHORT $LN16@edge_lengt@3
$LN18@edge_lengt@3:

; 394  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN17@edge_lengt@3

; 379  : 
; 380  :   /* derivatives of gaussian sum part */
; 381  :   memset((char*)sumgrad,0,sizeof(sumgrad));
; 382  :   memset((char*)sumhess,0,sizeof(sumhess));
; 383  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	ecx, DWORD PTR _gauss1polyd
	mov	ecx, DWORD PTR [ecx+edx*4]
	lea	esi, DWORD PTR [ecx+edi*8]
$LN15@edge_lengt@3:

; 395  :          e_info->grad[k][j] += fudge*tang[j]*gauss1polyd[k][m];

	fld	QWORD PTR _tang$[ebp+eax*8]
	mov	ecx, DWORD PTR [ebx+1336]
	mov	ecx, DWORD PTR [ecx+edx*4]
	fmul	ST(0), ST(1)
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	eax
	fmul	QWORD PTR [esi]
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN15@edge_lengt@3

; 394  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _edge_ctrl
$LN17@edge_lengt@3:

; 392  :     fudge = density*gauss1Dwt[m]/len;
; 393  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	inc	edx
	cmp	edx, esi
	jl	SHORT $LN18@edge_lengt@3
$LN16@edge_lengt@3:

; 396  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	DWORD PTR _k$[ebp], 0
	test	esi, esi
	jle	$LN104@edge_lengt@3
$LN61@edge_lengt@3:

; 397  :       for ( kk = 0 ; kk < edge_ctrl ; kk++ )

	xor	ebx, ebx
	mov	DWORD PTR _kk$[ebp], ebx
	test	esi, esi
	jle	$LN11@edge_lengt@3
$LN64@edge_lengt@3:

; 398  :          for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	ecx, ecx
	jle	$LN8@edge_lengt@3
	lea	eax, DWORD PTR _tang$[ebp]
	mov	DWORD PTR tv1585[ebp], eax
$LN62@edge_lengt@3:

; 399  :             for ( jj = 0 ; jj < SDIM ; jj++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN5@edge_lengt@3

; 379  : 
; 380  :   /* derivatives of gaussian sum part */
; 381  :   memset((char*)sumgrad,0,sizeof(sumgrad));
; 382  :   memset((char*)sumhess,0,sizeof(sumhess));
; 383  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	ecx, DWORD PTR _gauss1polyd
	mov	esi, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	lea	esi, DWORD PTR [esi+edi*8]
	lea	edi, DWORD PTR [ecx+edi*8]
$LN58@edge_lengt@3:

; 400  :               e_info->hess[k][kk][j][jj] += fudge*
; 401  :             ( - tang[j]*tang[jj]*gauss1polyd[k][m]*gauss1polyd[kk][m]/len/len
; 402  :             + ((j==jj)? gauss1polyd[k][m]*gauss1polyd[kk][m] : 0.0));

	cmp	edx, eax
	jne	SHORT $LN33@edge_lengt@3
	fld	QWORD PTR [edi]
	fmul	QWORD PTR [esi]
	jmp	SHORT $LN34@edge_lengt@3
$LN33@edge_lengt@3:
	fld	ST(1)
$LN34@edge_lengt@3:

; 399  :             for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	ecx, DWORD PTR _e_info$GSCopy$[ebp]

; 400  :               e_info->hess[k][kk][j][jj] += fudge*
; 401  :             ( - tang[j]*tang[jj]*gauss1polyd[k][m]*gauss1polyd[kk][m]/len/len
; 402  :             + ((j==jj)? gauss1polyd[k][m]*gauss1polyd[kk][m] : 0.0));

	fld	QWORD PTR _tang$[ebp+eax*8]
	mov	ecx, DWORD PTR [ecx+1340]
	mov	ebx, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ebx, DWORD PTR _kk$[ebp]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ebx, DWORD PTR tv1585[ebp]
	fmul	QWORD PTR [ebx]
	mov	ecx, DWORD PTR [ecx+edx*4]
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	eax
	fmul	QWORD PTR [esi]
	fmul	QWORD PTR [edi]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN58@edge_lengt@3

; 399  :             for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	edi, DWORD PTR _m$[ebp]
	mov	ebx, DWORD PTR _kk$[ebp]
$LN5@edge_lengt@3:

; 398  :          for ( j = 0 ; j < SDIM ; j++ )

	add	DWORD PTR tv1585[ebp], 8
	inc	edx
	cmp	edx, ecx
	jl	SHORT $LN62@edge_lengt@3
	mov	esi, DWORD PTR _edge_ctrl
$LN8@edge_lengt@3:

; 397  :       for ( kk = 0 ; kk < edge_ctrl ; kk++ )

	inc	ebx
	mov	DWORD PTR _kk$[ebp], ebx
	cmp	ebx, esi
	jl	$LN64@edge_lengt@3
$LN11@edge_lengt@3:

; 396  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, esi
	jl	$LN61@edge_lengt@3
	mov	ebx, DWORD PTR _e_info$GSCopy$[ebp]
$LN104@edge_lengt@3:
	fstp	ST(2)
$LN89@edge_lengt@3:

; 379  : 
; 380  :   /* derivatives of gaussian sum part */
; 381  :   memset((char*)sumgrad,0,sizeof(sumgrad));
; 382  :   memset((char*)sumhess,0,sizeof(sumhess));
; 383  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	edi

; 396  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	fstp	ST(1)
	mov	DWORD PTR _m$[ebp], edi
	cmp	edi, DWORD PTR _gauss1D_num
	jl	$LN63@edge_lengt@3
	pop	esi
$LN70@edge_lengt@3:

; 403  :   }
; 404  : 
; 405  :   return density*value;
; 406  : } // end edge_length_q_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	fld	QWORD PTR _density$[ebp]
	pop	edi
	fmul	QWORD PTR _value$[ebp]
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_length_q_hess ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_scalar_integral_q
; Function compile flags: /Ogtp
;	COMDAT _edge_scalar_integral_q
_TEXT	SEGMENT
_value$ = -84						; size = 8
_mi$ = -76						; size = 4
tv1303 = -72						; size = 8
_k$ = -68						; size = 4
tv952 = -64						; size = 4
_m$ = -60						; size = 4
_e_info$GSCopy$ = -56					; size = 4
_tang$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_scalar_integral_q PROC				; COMDAT

; 577  : { int j,k,m;

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 578  :   REAL value = 0.0;

	fldz
	push	esi
	fld	ST(0)
	push	edi
	fst	QWORD PTR _value$[ebp]
	mov	edi, DWORD PTR _e_info$[ebp]

; 579  :   REAL tang[MAXCOORD];
; 580  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	eax, DWORD PTR [edi+8]
	cdq
	mov	ebx, eax
	xor	ebx, edx
	sub	ebx, edx
	imul	ebx, 2928				; 00000b70H
	add	ebx, DWORD PTR _meth_inst_list

; 581  : 
; 582  :   for ( m = 0 ; m < gauss1D_num ; m++ ) 

	xor	esi, esi
	mov	DWORD PTR _e_info$GSCopy$[ebp], edi
	mov	DWORD PTR _mi$[ebp], ebx
	mov	DWORD PTR _m$[ebp], esi
	cmp	DWORD PTR _gauss1D_num, esi
	jle	$LN26@edge_scala
	fstp	ST(0)
	jmp	SHORT $LN9@edge_scala
	npad	2
$LL48@edge_scala:
	fstp	ST(0)
	fldz
$LN9@edge_scala:

; 583  :   { for ( j = 0 ; j < SDIM ; j ++ )

	mov	edx, DWORD PTR _web+616
	xor	eax, eax
	test	edx, edx
	jle	$LN30@edge_scala
	mov	ebx, DWORD PTR _edge_ctrl
$LN6@edge_scala:

; 585  :         for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	ecx, ecx
	fst	QWORD PTR _tang$[ebp+eax*8]
	cmp	ebx, 4
	jl	$LC19@edge_scala

; 584  :       { tang[j] = 0.0;

	mov	edx, DWORD PTR _gauss1polyd
	lea	ecx, DWORD PTR [edi+420]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv952[ebp], edi
	add	edi, edi
	add	edx, 8
	add	edi, edi
	mov	DWORD PTR _k$[ebp], edi

; 585  :         for ( k = 0 ; k < edge_ctrl ; k++ )

$LN20@edge_scala:

; 586  :            tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	edi, DWORD PTR [edx-8]
	fld	QWORD PTR [edi+esi*8]
	mov	ebx, DWORD PTR [ecx-4]
	fmul	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [ecx]
	add	ecx, 16					; 00000010H
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv952[ebp]
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	edi, DWORD PTR [edx-20]
	fld	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR [ecx-12]
	fmul	QWORD PTR [ebx+eax*8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	ebx, DWORD PTR [edx-16]
	fld	QWORD PTR [edi+eax*8]
	fmul	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR [ecx-8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	edi, DWORD PTR [edx-12]
	fld	QWORD PTR [edi+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _tang$[ebp+eax*8]
	jne	SHORT $LN20@edge_scala

; 584  :       { tang[j] = 0.0;

	mov	edx, DWORD PTR _web+616
	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	ebx, DWORD PTR _edge_ctrl
$LC19@edge_scala:

; 585  :         for ( k = 0 ; k < edge_ctrl ; k++ )

	cmp	ecx, ebx
	jge	SHORT $LN5@edge_scala
	lea	edi, DWORD PTR [edi+ecx*4+416]
$LN23@edge_scala:

; 586  :            tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	edx, DWORD PTR _gauss1polyd
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [edi]
	fld	QWORD PTR [edx+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR _edge_ctrl
	inc	ecx
	add	edi, 4
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fstp	QWORD PTR _tang$[ebp+eax*8]
	cmp	ecx, ebx
	jl	SHORT $LN23@edge_scala

; 585  :         for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
	mov	edx, DWORD PTR _web+616
$LN5@edge_scala:

; 583  :   { for ( j = 0 ; j < SDIM ; j ++ )

	inc	eax
	cmp	eax, edx
	jl	$LN6@edge_scala
	mov	ebx, DWORD PTR _mi$[ebp]
$LN30@edge_scala:

; 587  :       }
; 588  :     e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	mov	eax, DWORD PTR [edi+1268]
	fstp	ST(0)
	mov	ecx, DWORD PTR [eax+esi*4]
	fild	DWORD PTR _m$[ebp]
	add	edx, edx

; 589  :     value += gauss1Dwt[m]*eval(mi->expr[0],
; 590  :              e_info->gauss_pt[m],e_info->id,NULL)*sqrt(SDIM_dot(tang,tang));

	lea	eax, DWORD PTR _tang$[ebp]
	fstp	QWORD PTR [ecx+edx*8]
	mov	edx, DWORD PTR _web+616
	push	edx
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fstp	QWORD PTR tv1303[ebp]
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+1268]
	mov	ecx, DWORD PTR [eax+esi*4]
	push	0
	push	edx
	mov	edx, DWORD PTR [ebx+232]
	push	ecx
	push	edx
	call	_eval
	mov	eax, DWORD PTR _gauss1Dwt
	fmul	QWORD PTR [eax+esi*8]
	inc	esi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _m$[ebp], esi
	fmul	QWORD PTR tv1303[ebp]
	fadd	QWORD PTR _value$[ebp]
	fst	QWORD PTR _value$[ebp]
	cmp	esi, DWORD PTR _gauss1D_num
	jl	$LL48@edge_scala
	pop	edi
	pop	esi
	pop	ebx

; 591  :   }
; 592  :   return value;
; 593  : } // end edge_scalar_integral_q()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@edge_scala:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(1)
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_scalar_integral_q ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_scalar_integral_q_grad
EXTRN	_gauss1poly:DWORD
; Function compile flags: /Ogtp
;	COMDAT _edge_scalar_integral_q_grad
_TEXT	SEGMENT
_val$ = -140						; size = 8
_value$ = -132						; size = 8
tv1501 = -124						; size = 4
tv539 = -120						; size = 4
_e_info$GSCopy$ = -116					; size = 4
_mi$ = -112						; size = 4
tv1577 = -108						; size = 4
_k$ = -108						; size = 4
tv1027 = -104						; size = 4
tv553 = -104						; size = 4
_m$ = -104						; size = 4
_derivs$ = -100						; size = 48
_tang$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_scalar_integral_q_grad PROC			; COMDAT

; 604  : { int m,k,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 605  :   REAL value = 0.0;

	fldz

; 606  :   REAL len,val;
; 607  :   REAL derivs[MAXCOORD];
; 608  :   REAL tang[MAXCOORD];
; 609  :   struct method_instance *mi = METH_INSTANCE(e_info->method);
; 610  : 
; 611  :   for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	fld	ST(0)
	push	esi
	fst	QWORD PTR _value$[ebp]
	push	edi
	mov	edi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [edi+8]
	cdq
	mov	ebx, eax
	xor	ebx, edx
	sub	ebx, edx
	imul	ebx, 2928				; 00000b70H
	add	ebx, DWORD PTR _meth_inst_list
	xor	edx, edx
	mov	DWORD PTR _e_info$GSCopy$[ebp], edi
	mov	DWORD PTR _mi$[ebp], ebx
	test	ecx, ecx
	jle	SHORT $LN60@edge_scala@2
	mov	esi, DWORD PTR _edge_ctrl
$LN22@edge_scala@2:

; 612  :      for ( m = 0 ; m < edge_ctrl ; m++ )

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN21@edge_scala@2
$LN19@edge_scala@2:

; 613  :         e_info->grad[m][j] = 0.0;

	mov	ecx, DWORD PTR [edi+1336]
	fxch	ST(1)
	mov	ecx, DWORD PTR [ecx+eax*4]
	fst	QWORD PTR [ecx+edx*8]
	mov	esi, DWORD PTR _edge_ctrl
	inc	eax
	fxch	ST(1)
	cmp	eax, esi
	jl	SHORT $LN19@edge_scala@2

; 612  :      for ( m = 0 ; m < edge_ctrl ; m++ )

	mov	ecx, DWORD PTR _web+616
$LN21@edge_scala@2:

; 606  :   REAL len,val;
; 607  :   REAL derivs[MAXCOORD];
; 608  :   REAL tang[MAXCOORD];
; 609  :   struct method_instance *mi = METH_INSTANCE(e_info->method);
; 610  : 
; 611  :   for ( j = 0 ; j < SDIM ; j++ )

	inc	edx
	cmp	edx, ecx
	jl	SHORT $LN22@edge_scala@2
$LN60@edge_scala@2:

; 614  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	esi, esi
	fstp	ST(1)
	mov	DWORD PTR _m$[ebp], esi
	cmp	DWORD PTR _gauss1D_num, esi
	jle	$LN14@edge_scala@2
	fstp	ST(0)
$LN16@edge_scala@2:

; 615  :   { e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	mov	edx, DWORD PTR [edi+1268]
	fild	DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+esi*4]
	add	ecx, ecx
	fstp	QWORD PTR [eax+ecx*8]

; 616  :     eval_all(mi->expr[0],e_info->gauss_pt[m],SDIM,&val,
; 617  :                                                          derivs,e_info->id);

	mov	ecx, DWORD PTR [edi]
	push	ecx
	mov	ecx, DWORD PTR _web+616
	lea	edx, DWORD PTR _derivs$[ebp]
	push	edx
	mov	edx, DWORD PTR [edi+1268]
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+esi*4]
	push	ecx
	mov	ecx, DWORD PTR [ebx+232]
	push	eax
	push	ecx
	call	_eval_all

; 618  :     for ( j = 0 ; j < SDIM ; j ++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 24					; 00000018H
	xor	eax, eax
	test	ecx, ecx
	jle	$LN11@edge_scala@2
	mov	ebx, DWORD PTR _edge_ctrl
	fldz
$LN49@edge_scala@2:

; 620  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	ecx, ecx
	fst	QWORD PTR _tang$[ebp+eax*8]
	cmp	ebx, 4
	jl	$LC40@edge_scala@2

; 619  :     { tang[j] = 0.0;

	mov	edx, DWORD PTR _gauss1polyd
	lea	ecx, DWORD PTR [edi+420]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv1027[ebp], edi
	add	edi, edi
	add	edx, 8
	add	edi, edi
	mov	DWORD PTR _k$[ebp], edi

; 620  :       for ( k = 0 ; k < edge_ctrl ; k++ )

$LN41@edge_scala@2:

; 621  :           tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	edi, DWORD PTR [edx-8]
	fld	QWORD PTR [edi+esi*8]
	mov	ebx, DWORD PTR [ecx-4]
	fmul	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [ecx]
	add	ecx, 16					; 00000010H
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv1027[ebp]
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	edi, DWORD PTR [edx-20]
	fld	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR [ecx-12]
	fmul	QWORD PTR [ebx+eax*8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	ebx, DWORD PTR [edx-16]
	fld	QWORD PTR [edi+eax*8]
	fmul	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR [ecx-8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	edi, DWORD PTR [edx-12]
	fld	QWORD PTR [edi+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _tang$[ebp+eax*8]
	jne	SHORT $LN41@edge_scala@2

; 619  :     { tang[j] = 0.0;

	mov	ebx, DWORD PTR _edge_ctrl
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
$LC40@edge_scala@2:

; 620  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	cmp	ecx, ebx
	jge	SHORT $LN12@edge_scala@2
	lea	edi, DWORD PTR [edi+ecx*4+416]
$LN46@edge_scala@2:

; 621  :           tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	edx, DWORD PTR _gauss1polyd
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [edi]
	fld	QWORD PTR [edx+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR _edge_ctrl
	inc	ecx
	add	edi, 4
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fstp	QWORD PTR _tang$[ebp+eax*8]
	cmp	ecx, ebx
	jl	SHORT $LN46@edge_scala@2

; 620  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
$LN12@edge_scala@2:

; 618  :     for ( j = 0 ; j < SDIM ; j ++ )

	mov	ecx, DWORD PTR _web+616
	inc	eax
	cmp	eax, ecx
	jl	$LN49@edge_scala@2
	mov	ebx, DWORD PTR _mi$[ebp]
	fstp	ST(0)
$LN11@edge_scala@2:

; 622  :     }
; 623  :     len = sqrt(SDIM_dot(tang,tang));

	push	ecx
	lea	eax, DWORD PTR _tang$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 624  :     if ( len == 0.0 ) continue;

	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN82@edge_scala@2

; 625  :     value += gauss1Dwt[m]*val*len;

	mov	edx, DWORD PTR _gauss1Dwt
	fld	QWORD PTR [edx+esi*8]
	lea	eax, DWORD PTR [edx+esi*8]
	fmul	QWORD PTR _val$[ebp]

; 626  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	edx, edx
	mov	DWORD PTR tv539[ebp], eax
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _value$[ebp]
	fstp	QWORD PTR _value$[ebp]
	cmp	DWORD PTR _edge_ctrl, edx
	jle	$LN82@edge_scala@2
	mov	ebx, DWORD PTR _gauss1polyd
	sub	ebx, DWORD PTR _gauss1poly
	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR tv1501[ebp], ebx
$LN6@edge_scala@2:

; 627  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN5@edge_scala@2

; 626  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	ecx, DWORD PTR _gauss1poly
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	ebx, DWORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR [ecx]
	lea	ebx, DWORD PTR [ebx+esi*8]
	lea	ecx, DWORD PTR [ecx+esi*8]
	mov	DWORD PTR tv1577[ebp], ebx
	mov	DWORD PTR tv553[ebp], ecx
$LN43@edge_scala@2:

; 628  :          e_info->grad[k][j] += gauss1Dwt[m]*(gauss1poly[k][m]*derivs[j]*len
; 629  :                                       + val*tang[j]/len*gauss1polyd[k][m]);

	fld	QWORD PTR _tang$[ebp+eax*8]
	mov	ebx, DWORD PTR tv1577[ebp]
	fmul	QWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [edi+1336]
	mov	ecx, DWORD PTR [ecx+edx*4]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fdiv	ST(0), ST(1)
	inc	eax
	fmul	QWORD PTR [ebx]
	fld	QWORD PTR _derivs$[ebp+eax*8-8]
	mov	ebx, DWORD PTR tv553[ebp]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv539[ebp]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fmul	QWORD PTR [ebx]
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN43@edge_scala@2

; 627  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR tv1501[ebp]
$LN5@edge_scala@2:

; 626  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	inc	edx
	cmp	edx, DWORD PTR _edge_ctrl
	jl	SHORT $LN6@edge_scala@2
	mov	ebx, DWORD PTR _mi$[ebp]
	jmp	SHORT $LN93@edge_scala@2
$LN82@edge_scala@2:
	mov	ecx, DWORD PTR _web+616
$LN93@edge_scala@2:

; 614  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	esi

; 626  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	fstp	ST(0)
	mov	DWORD PTR _m$[ebp], esi
	cmp	esi, DWORD PTR _gauss1D_num
	jl	$LN16@edge_scala@2

; 630  :   }
; 631  : 
; 632  :   return value;

	fld	QWORD PTR _value$[ebp]
$LN14@edge_scala@2:

; 633  : } // end edge_scalar_integral_q_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_scalar_integral_q_grad ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_scalar_integral_q_hess
EXTRN	_mat2d_setup:PROC
; Function compile flags: /Ogtp
;	COMDAT _edge_scalar_integral_q_hess
_TEXT	SEGMENT
_secondqXvS$ = -484					; size = 24
tv2040 = -460						; size = 4
tv1793 = -456						; size = 4
tv2192 = -452						; size = 4
tv2045 = -448						; size = 4
_value$ = -444						; size = 8
_val$ = -436						; size = 8
_second$ = -428						; size = 4
tv688 = -424						; size = 4
_mi$ = -420						; size = 4
tv2025 = -416						; size = 4
_m$ = -412						; size = 4
tv2050 = -408						; size = 4
tv702 = -408						; size = 4
tv2177 = -404						; size = 4
_e_info$GSCopy$ = -400					; size = 4
_k$ = -396						; size = 4
tv1636 = -392						; size = 4
tv144 = -392						; size = 4
_kk$ = -392						; size = 4
_secondxJ$ = -388					; size = 288
_derivs$ = -100						; size = 48
_tang$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_scalar_integral_q_hess PROC			; COMDAT

; 644  : { int m,j,jj,k,kk;

	push	ebp
	mov	ebp, esp
	sub	esp, 484				; 000001e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 645  :   REAL value = 0.0;

	fldz
	push	ebx
	push	esi
	fstp	QWORD PTR _value$[ebp]
	mov	esi, DWORD PTR _e_info$[ebp]
	push	edi

; 646  :   REAL len,val;
; 647  :   REAL derivs[MAXCOORD];
; 648  :   REAL sumgrad[2][MAXCOORD];
; 649  :   REAL sumhess[2][2][MAXCOORD][MAXCOORD];
; 650  :   MAT2D(second,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _secondxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _secondqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _e_info$GSCopy$[ebp], esi
	call	_mat2d_setup
	mov	DWORD PTR _second$[ebp], eax

; 651  :   REAL tang[MAXCOORD];
; 652  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	eax, DWORD PTR [esi+8]
	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
	imul	edi, 2928				; 00000b70H
	add	edi, DWORD PTR _meth_inst_list

; 653  : 
; 654  :   /* derivatives of gaussian sum part */
; 655  :   memset((char*)sumgrad,0,sizeof(sumgrad));
; 656  :   memset((char*)sumhess,0,sizeof(sumhess));
; 657  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	ebx, ebx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _mi$[ebp], edi
	mov	DWORD PTR _m$[ebp], ebx
	cmp	DWORD PTR _gauss1D_num, ebx
	jle	$LN54@edge_scala@3
	mov	ecx, DWORD PTR _web+616
	npad	3
$LL28@edge_scala@3:

; 658  :   { e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	mov	edx, DWORD PTR [esi+1268]
	fild	DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+ebx*4]

; 659  :     eval_second(mi->expr[0],e_info->gauss_pt[m],SDIM,&val,
; 660  :                                                     derivs,second,e_info->id);

	mov	edx, DWORD PTR _second$[ebp]
	add	ecx, ecx
	fstp	QWORD PTR [eax+ecx*8]
	mov	ecx, DWORD PTR [esi]
	push	ecx
	push	edx
	mov	edx, DWORD PTR _web+616
	lea	eax, DWORD PTR _derivs$[ebp]
	push	eax
	mov	eax, DWORD PTR [esi+1268]
	lea	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+ebx*4]
	push	edx
	mov	edx, DWORD PTR [edi+232]
	push	ecx
	push	edx
	call	_eval_second

; 661  :     for ( j = 0 ; j < SDIM ; j ++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 28					; 0000001cH
	xor	eax, eax
	test	ecx, ecx
	jle	$LN63@edge_scala@3
	mov	edi, DWORD PTR _edge_ctrl
	fldz
$LN66@edge_scala@3:

; 663  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	ecx, ecx
	fst	QWORD PTR _tang$[ebp+eax*8]
	cmp	edi, 4
	jl	$LN59@edge_scala@3

; 662  :     { tang[j] = 0.0;

	mov	edx, DWORD PTR _gauss1polyd
	lea	ecx, DWORD PTR [esi+420]
	lea	esi, DWORD PTR [edi-4]
	shr	esi, 2
	inc	esi
	mov	DWORD PTR tv144[ebp], esi
	add	esi, esi
	add	edx, 8
	add	esi, esi
	mov	DWORD PTR _k$[ebp], esi

; 663  :       for ( k = 0 ; k < edge_ctrl ; k++ )

$LN53@edge_scala@3:

; 664  :           tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	esi, DWORD PTR [edx-8]
	fld	QWORD PTR [esi+ebx*8]
	mov	edi, DWORD PTR [ecx-4]
	fmul	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR [ecx]
	add	ecx, 16					; 00000010H
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv144[ebp]
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	esi, DWORD PTR [edx-20]
	fld	QWORD PTR [esi+ebx*8]
	mov	esi, DWORD PTR [ecx-12]
	fmul	QWORD PTR [edi+eax*8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	edi, DWORD PTR [edx-16]
	fld	QWORD PTR [esi+eax*8]
	fmul	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR [ecx-8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	esi, DWORD PTR [edx-12]
	fld	QWORD PTR [esi+ebx*8]
	fmul	QWORD PTR [edi+eax*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _tang$[ebp+eax*8]
	jne	SHORT $LN53@edge_scala@3

; 662  :     { tang[j] = 0.0;

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR _edge_ctrl
	mov	esi, DWORD PTR _e_info$GSCopy$[ebp]
$LN59@edge_scala@3:

; 663  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	cmp	ecx, edi
	jge	SHORT $LN24@edge_scala@3
	lea	esi, DWORD PTR [esi+ecx*4+416]
$LN61@edge_scala@3:

; 664  :           tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	edx, DWORD PTR _gauss1polyd
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	edi, DWORD PTR [esi]
	fld	QWORD PTR [edx+ebx*8]
	fmul	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR _edge_ctrl
	inc	ecx
	add	esi, 4
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fstp	QWORD PTR _tang$[ebp+eax*8]
	cmp	ecx, edi
	jl	SHORT $LN61@edge_scala@3

; 663  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	esi, DWORD PTR _e_info$GSCopy$[ebp]
$LN24@edge_scala@3:

; 661  :     for ( j = 0 ; j < SDIM ; j ++ )

	mov	ecx, DWORD PTR _web+616
	inc	eax
	cmp	eax, ecx
	jl	$LN66@edge_scala@3
	mov	edi, DWORD PTR _mi$[ebp]
	fstp	ST(0)
$LN63@edge_scala@3:

; 665  :     }
; 666  :     len = sqrt(SDIM_dot(tang,tang));

	push	ecx
	lea	eax, DWORD PTR _tang$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 667  :     if ( len == 0.0 ) continue;

	fld	ST(0)
	fldz

; 669  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	ecx, DWORD PTR _web+616
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	$LN127@edge_scala@3

; 668  :     value += gauss1Dwt[m]*val*len;

	mov	edx, DWORD PTR _gauss1Dwt
	fld	QWORD PTR _val$[ebp]

; 669  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	edi, DWORD PTR _edge_ctrl
	fld	ST(0)
	fmul	QWORD PTR [edx+ebx*8]
	lea	eax, DWORD PTR [edx+ebx*8]
	xor	edx, edx
	mov	DWORD PTR tv688[ebp], eax
	fmul	ST(0), ST(3)
	fadd	QWORD PTR _value$[ebp]
	fstp	QWORD PTR _value$[ebp]
	test	edi, edi
	jle	$LN16@edge_scala@3
	mov	esi, DWORD PTR _gauss1polyd
	sub	esi, DWORD PTR _gauss1poly
	mov	DWORD PTR tv1636[ebp], esi
$LN18@edge_scala@3:

; 670  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN17@edge_scala@3

; 669  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	ecx, DWORD PTR _gauss1poly
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	esi, DWORD PTR [ecx+esi]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+ebx*8]
	lea	esi, DWORD PTR [esi+ebx*8]
	mov	DWORD PTR tv702[ebp], ecx
$LN55@edge_scala@3:

; 671  :          e_info->grad[k][j] += gauss1Dwt[m]*(gauss1poly[k][m]*derivs[j]*len
; 672  :                                       + val*tang[j]/len*gauss1polyd[k][m]);

	fmul	QWORD PTR _tang$[ebp+eax*8]
	mov	edi, DWORD PTR tv702[ebp]
	mov	ecx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ecx+1336]
	fdiv	ST(0), ST(2)
	mov	ecx, DWORD PTR [ecx+edx*4]
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	eax
	fmul	QWORD PTR [esi]
	fld	QWORD PTR _derivs$[ebp+eax*8-8]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR tv688[ebp]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fmul	QWORD PTR [edi]
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	fld	QWORD PTR _val$[ebp]
	cmp	eax, ecx
	jl	SHORT $LN55@edge_scala@3

; 670  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _edge_ctrl
	mov	esi, DWORD PTR tv1636[ebp]
$LN17@edge_scala@3:

; 669  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	inc	edx
	cmp	edx, edi
	jl	SHORT $LN18@edge_scala@3
	mov	esi, DWORD PTR _e_info$GSCopy$[ebp]
$LN16@edge_scala@3:

; 673  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	DWORD PTR _k$[ebp], 0
	test	edi, edi
	jle	$LN101@edge_scala@3
	mov	eax, DWORD PTR _gauss1polyd
	mov	DWORD PTR tv2177[ebp], eax
$LN12@edge_scala@3:

; 674  :       for ( kk = 0 ; kk < edge_ctrl ; kk++ )

	mov	DWORD PTR _kk$[ebp], 0
	test	edi, edi
	jle	$LN11@edge_scala@3
	mov	edx, DWORD PTR _gauss1poly
	sub	edx, eax
	mov	DWORD PTR tv2025[ebp], eax
	mov	DWORD PTR tv2045[ebp], edx
$LN64@edge_scala@3:

; 675  :          for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	ecx, ecx
	jle	$LN8@edge_scala@3
$LN67@edge_scala@3:

; 676  :             for ( jj = 0 ; jj < SDIM ; jj++ )

	xor	eax, eax
	test	ecx, ecx
	jle	$LN5@edge_scala@3

; 653  : 
; 654  :   /* derivatives of gaussian sum part */
; 655  :   memset((char*)sumgrad,0,sizeof(sumgrad));
; 656  :   memset((char*)sumhess,0,sizeof(sumhess));
; 657  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	ecx, DWORD PTR tv2177[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	lea	edi, DWORD PTR [ecx+ebx*8]
	mov	ecx, DWORD PTR tv2025[ebp]
	mov	edx, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [ecx]
	lea	edx, DWORD PTR [edx+ebx*8]
	mov	DWORD PTR tv2050[ebp], edx
	mov	edx, DWORD PTR tv2177[ebp]
	mov	edx, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+ebx*8]
	mov	DWORD PTR tv2192[ebp], edx
	lea	edx, DWORD PTR [ecx+ebx*8]

; 676  :             for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	ecx, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR tv2040[ebp], edx
	lea	edx, DWORD PTR _derivs$[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv1793[ebp], ecx
$LN3@edge_scala@3:

; 677  :               e_info->hess[k][kk][j][jj] += gauss1Dwt[m]*
; 678  :      ( second[j][jj]*gauss1poly[k][m]*gauss1poly[kk][m]*len
; 679  :      + derivs[j]*gauss1poly[k][m]*tang[jj]*gauss1polyd[kk][m]/len
; 680  :      + derivs[jj]*gauss1poly[kk][m]*tang[j]*gauss1polyd[k][m]/len
; 681  :      - val*tang[j]*tang[jj]*gauss1polyd[k][m]*gauss1polyd[kk][m]/len/len/len
; 682  :      + ((j==jj)? val*gauss1polyd[k][m]*gauss1polyd[kk][m]/len : 0.0));

	cmp	esi, eax
	jne	SHORT $LN31@edge_scala@3
	mov	ecx, DWORD PTR tv2177[ebp]
	mov	edx, DWORD PTR [ecx]
	fld	QWORD PTR [edx+ebx*8]
	mov	ecx, DWORD PTR tv2025[ebp]
	mov	edx, DWORD PTR [ecx]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edx+ebx*8]
	fdiv	ST(0), ST(3)
	jmp	SHORT $LN32@edge_scala@3
$LN31@edge_scala@3:
	fld	ST(1)
$LN32@edge_scala@3:

; 676  :             for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	edx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	edx, DWORD PTR [edx+1340]
	mov	ebx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	ebx, DWORD PTR _kk$[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]

; 677  :               e_info->hess[k][kk][j][jj] += gauss1Dwt[m]*
; 678  :      ( second[j][jj]*gauss1poly[k][m]*gauss1poly[kk][m]*len
; 679  :      + derivs[j]*gauss1poly[k][m]*tang[jj]*gauss1polyd[kk][m]/len
; 680  :      + derivs[jj]*gauss1poly[kk][m]*tang[j]*gauss1polyd[k][m]/len
; 681  :      - val*tang[j]*tang[jj]*gauss1polyd[k][m]*gauss1polyd[kk][m]/len/len/len
; 682  :      + ((j==jj)? val*gauss1polyd[k][m]*gauss1polyd[kk][m]/len : 0.0));

	mov	ebx, DWORD PTR tv1793[ebp]
	lea	ecx, DWORD PTR _derivs$[ebp+eax*8]
	fld	QWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR tv2050[ebp]
	fmul	QWORD PTR [edi]
	mov	edx, DWORD PTR [edx+esi*4]
	lea	edx, DWORD PTR [edx+eax*8]
	inc	eax
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv2040[ebp]
	fmul	ST(0), ST(4)
	fld	QWORD PTR [edi]
	fmul	QWORD PTR _derivs$[ebp+esi*8]
	fmul	QWORD PTR _tang$[ebp+eax*8-8]
	fmul	QWORD PTR [ebx]
	fdiv	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx]
	mov	ecx, DWORD PTR tv2050[ebp]
	fmul	QWORD PTR [ecx]
	mov	ecx, DWORD PTR tv2192[ebp]
	fmul	QWORD PTR _tang$[ebp+esi*8]
	fmul	QWORD PTR [ecx]
	fdiv	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _tang$[ebp+esi*8]
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	fmul	QWORD PTR _tang$[ebp+eax*8-8]
	fmul	QWORD PTR [ecx]
	mov	ecx, DWORD PTR tv688[ebp]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR _m$[ebp]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fsubp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fmul	QWORD PTR [ecx]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	ecx, DWORD PTR _web+616
	fld	QWORD PTR _val$[ebp]
	cmp	eax, ecx
	jl	$LN3@edge_scala@3

; 676  :             for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	edx, DWORD PTR tv2045[ebp]
$LN5@edge_scala@3:

; 675  :          for ( j = 0 ; j < SDIM ; j++ )

	inc	esi
	cmp	esi, ecx
	jl	$LN67@edge_scala@3
	mov	edi, DWORD PTR _edge_ctrl
$LN8@edge_scala@3:

; 674  :       for ( kk = 0 ; kk < edge_ctrl ; kk++ )

	mov	eax, DWORD PTR _kk$[ebp]
	add	DWORD PTR tv2025[ebp], 4
	inc	eax
	mov	DWORD PTR _kk$[ebp], eax
	cmp	eax, edi
	jl	$LN64@edge_scala@3
	mov	eax, DWORD PTR _gauss1polyd
	mov	esi, DWORD PTR _e_info$GSCopy$[ebp]
$LN11@edge_scala@3:

; 673  :     for ( k = 0 ; k < edge_ctrl ; k++ )

	inc	DWORD PTR _k$[ebp]
	add	DWORD PTR tv2177[ebp], 4
	cmp	DWORD PTR _k$[ebp], edi
	jl	$LN12@edge_scala@3
$LN101@edge_scala@3:
	mov	edi, DWORD PTR _mi$[ebp]
	fstp	ST(2)
$LN127@edge_scala@3:
	inc	ebx
	fstp	ST(1)
	fstp	ST(0)
	mov	DWORD PTR _m$[ebp], ebx
	cmp	ebx, DWORD PTR _gauss1D_num
	jl	$LL28@edge_scala@3
$LN54@edge_scala@3:

; 683  :   }
; 684  : 
; 685  :   return value;
; 686  : } // end edge_scalar_integral_q_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fld	QWORD PTR _value$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_scalar_integral_q_hess ENDP
_TEXT	ENDS
PUBLIC	_edge_scalar_integral_lagr
EXTRN	_gauss_lagrange:BYTE
; Function compile flags: /Ogtp
;	COMDAT _edge_scalar_integral_lagr
_TEXT	SEGMENT
tv89 = -20						; size = 8
_value$ = -12						; size = 8
_mi$ = -4						; size = 4
_m$ = 8							; size = 4
_e_info$ = 8						; size = 4
_edge_scalar_integral_lagr PROC				; COMDAT

; 704  : { int m;

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 705  :   REAL value = 0.0;

	fldz
	push	ebx

; 706  :   struct gauss_lag *gl = &gauss_lagrange[1][web.gauss1D_order];

	mov	ebx, DWORD PTR _web+1592
	fst	QWORD PTR _value$[ebp]
	push	esi
	push	edi

; 707  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	edi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [edi+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list
	shl	ebx, 5
	add	ebx, DWORD PTR _gauss_lagrange+4

; 708  : 
; 709  :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	esi, esi
	mov	DWORD PTR _mi$[ebp], eax
	mov	DWORD PTR _m$[ebp], esi
	cmp	DWORD PTR [ebx+4], esi
	jle	SHORT $LN1@edge_scala@4
$LN12@edge_scala@4:

; 710  :   { e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	mov	eax, DWORD PTR [edi+1268]
	fstp	ST(0)
	mov	ecx, DWORD PTR _web+616
	fild	DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [eax+esi*4]
	add	ecx, ecx
	fstp	QWORD PTR [edx+ecx*8]

; 711  :     value += gl->gausswt[m]
; 712  :          *eval(mi->expr[0],e_info->gauss_pt[m],e_info->id,NULL)
; 713  :          *sqrt(SDIM_dot(e_info->sides[m][0],e_info->sides[m][0]));

	mov	eax, DWORD PTR [edi+1276]
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [ecx]
	push	edx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fstp	QWORD PTR tv89[ebp]
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+1268]
	mov	edx, DWORD PTR [ecx+esi*4]
	push	0
	push	eax
	mov	eax, DWORD PTR _mi$[ebp]
	mov	ecx, DWORD PTR [eax+232]
	push	edx
	push	ecx
	call	_eval
	mov	edx, DWORD PTR [ebx+12]
	fmul	QWORD PTR [edx+esi*8]
	inc	esi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _m$[ebp], esi
	fmul	QWORD PTR tv89[ebp]
	fadd	QWORD PTR _value$[ebp]
	fst	QWORD PTR _value$[ebp]
	cmp	esi, DWORD PTR [ebx+4]
	jl	SHORT $LN12@edge_scala@4
$LN1@edge_scala@4:
	pop	edi
	pop	esi
	pop	ebx

; 714  :   }
; 715  :   return value;
; 716  : } // end edge_scalar_integral_lagr()

	mov	esp, ebp
	pop	ebp
	ret	0
_edge_scalar_integral_lagr ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_scalar_integral_lagr_grad
; Function compile flags: /Ogtp
;	COMDAT _edge_scalar_integral_lagr_grad
_TEXT	SEGMENT
_val$ = -88						; size = 8
tv320 = -80						; size = 4
_mi$ = -76						; size = 4
_value$ = -72						; size = 8
tv426 = -64						; size = 4
_e_info$GSCopy$ = -60					; size = 4
_tang$ = -56						; size = 4
_m$ = -56						; size = 4
_derivs$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_scalar_integral_lagr_grad PROC			; COMDAT

; 727  : { int m,k,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 728  :   REAL value = 0.0;

	fldz
	push	ebx
	mov	ebx, DWORD PTR _e_info$[ebp]
	fst	QWORD PTR _value$[ebp]

; 729  :   REAL len,val;
; 730  :   REAL derivs[MAXCOORD];
; 731  :   REAL *tang;
; 732  :   struct gauss_lag *gl = &gauss_lagrange[1][web.gauss1D_order];
; 733  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	eax, DWORD PTR [ebx+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list
	push	esi
	mov	esi, DWORD PTR _web+1592
	shl	esi, 5
	add	esi, DWORD PTR _gauss_lagrange+4
	push	edi

; 734  : 
; 735  :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	edi, edi
	mov	DWORD PTR _e_info$GSCopy$[ebp], ebx
	mov	DWORD PTR _mi$[ebp], eax
	mov	DWORD PTR _m$[ebp], edi
	cmp	DWORD PTR [esi+4], edi
	jle	$LN8@edge_scala@5
	mov	edx, DWORD PTR _web+616
	fstp	ST(0)
	jmp	SHORT $LN10@edge_scala@5
	npad	4
$LL23@edge_scala@5:
	mov	eax, DWORD PTR _mi$[ebp]
$LN10@edge_scala@5:

; 736  :   { e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	mov	ecx, DWORD PTR [ebx+1268]
	fild	DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	add	edx, edx
	fstp	QWORD PTR [ecx+edx*8]

; 737  :     eval_all(mi->expr[0],e_info->gauss_pt[m],SDIM,&val,derivs,e_info->id);

	mov	edx, DWORD PTR [ebx]
	push	edx
	lea	ecx, DWORD PTR _derivs$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _web+616
	lea	edx, DWORD PTR _val$[ebp]
	push	edx
	mov	edx, DWORD PTR [ebx+1268]
	push	ecx
	mov	ecx, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR [eax+232]
	push	ecx
	push	edx
	call	_eval_all

; 738  :     tang = e_info->sides[m][0];

	mov	eax, DWORD PTR [ebx+1276]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [ecx]

; 739  :     len = sqrt(SDIM_dot(tang,tang));

	mov	edx, DWORD PTR _web+616
	push	edx
	push	eax
	push	eax
	mov	DWORD PTR _tang$[ebp], eax
	call	_dot
	add	esp, 36					; 00000024H
	call	__CIsqrt

; 740  :     if ( len == 0.0 ) continue;

	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN31@edge_scala@5

; 741  :     value += gl->gausswt[m]*val*len;

	mov	eax, DWORD PTR [esi+12]
	fld	QWORD PTR [eax+edi*8]

; 742  :     for ( k = 0 ; k < gl->lagpts ; k++ )

	xor	ecx, ecx
	fmul	QWORD PTR _val$[ebp]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _value$[ebp]
	fstp	QWORD PTR _value$[ebp]
	cmp	DWORD PTR [esi+16], ecx
	jle	SHORT $LN31@edge_scala@5
	mov	edx, DWORD PTR _web+616
$LN6@edge_scala@5:

; 743  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN5@edge_scala@5
	mov	edx, DWORD PTR _tang$[ebp]
	lea	ebx, DWORD PTR _derivs$[ebp]
	sub	edx, ebx
	mov	DWORD PTR tv426[ebp], edx
$LN20@edge_scala@5:
	mov	ebx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ebx, DWORD PTR [ebx+1336]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	lea	ebx, DWORD PTR [ebx+eax*8]
	mov	DWORD PTR tv320[ebp], ebx

; 744  :          e_info->grad[k][j] += 
; 745  :           gl->gausswt[m]*(gl->gpoly[m][k]*derivs[j]*len
; 746  :               + val*tang[j]/len*gl->gpolypart[m][0][k]);

	mov	ebx, DWORD PTR tv426[ebp]
	lea	edx, DWORD PTR _derivs$[ebp+eax*8]
	fld	QWORD PTR [ebx+edx]
	mov	ebx, DWORD PTR [esi+24]
	fmul	QWORD PTR _val$[ebp]
	mov	ebx, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR [ebx]
	inc	eax
	fdiv	ST(0), ST(1)
	fmul	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [esi+20]
	mov	ebx, DWORD PTR [ebx+edi*4]
	fld	QWORD PTR [ebx+ecx*8]
	fmul	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+12]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fmul	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR tv320[ebp]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR _web+616
	cmp	eax, edx
	jl	SHORT $LN20@edge_scala@5

; 743  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _e_info$GSCopy$[ebp]
$LN5@edge_scala@5:

; 742  :     for ( k = 0 ; k < gl->lagpts ; k++ )

	inc	ecx
	cmp	ecx, DWORD PTR [esi+16]
	jl	SHORT $LN6@edge_scala@5
	jmp	SHORT $LN42@edge_scala@5
$LN31@edge_scala@5:
	mov	edx, DWORD PTR _web+616
$LN42@edge_scala@5:

; 734  : 
; 735  :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	inc	edi

; 742  :     for ( k = 0 ; k < gl->lagpts ; k++ )

	fstp	ST(0)
	mov	DWORD PTR _m$[ebp], edi
	cmp	edi, DWORD PTR [esi+4]
	jl	$LL23@edge_scala@5

; 747  :   }
; 748  :   return value;

	fld	QWORD PTR _value$[ebp]
$LN8@edge_scala@5:

; 749  : } // end edge_scalar_integral_lagr_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_scalar_integral_lagr_grad ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_scalar_integral_lagr_hess
; Function compile flags: /Ogtp
;	COMDAT _edge_scalar_integral_lagr_hess
_TEXT	SEGMENT
_secondqXvS$ = -436					; size = 24
_gl$ = -412						; size = 4
tv649 = -408						; size = 4
tv1003 = -404						; size = 4
tv1624 = -400						; size = 4
_mi$ = -396						; size = 4
_value$ = -392						; size = 8
_second$ = -384						; size = 4
_val$ = -380						; size = 8
_tang$ = -372						; size = 4
_m$ = -368						; size = 4
_jj$ = -364						; size = 4
_e_info$GSCopy$ = -360					; size = 4
tv1488 = -356						; size = 4
tv766 = -356						; size = 4
tv937 = -352						; size = 4
_j$ = -348						; size = 4
tv1088 = -344						; size = 4
tv544 = -344						; size = 4
_secondxJ$ = -340					; size = 288
_derivs$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_scalar_integral_lagr_hess PROC			; COMDAT

; 760  : { int m,j,jj,k,kk;

	push	ebp
	mov	ebp, esp
	sub	esp, 436				; 000001b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 761  :   REAL value = 0.0;

	fldz
	push	esi
	push	edi
	fstp	QWORD PTR _value$[ebp]
	mov	edi, DWORD PTR _e_info$[ebp]

; 762  :   REAL len,val;
; 763  :   REAL derivs[MAXCOORD];
; 764  :   REAL sumgrad[2][MAXCOORD];
; 765  :   REAL sumhess[2][2][MAXCOORD][MAXCOORD];
; 766  :   MAT2D(second,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _secondxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _secondqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _e_info$GSCopy$[ebp], edi
	call	_mat2d_setup

; 767  :   REAL *tang;
; 768  :   struct gauss_lag *gl = &gauss_lagrange[1][web.gauss1D_order];

	mov	esi, DWORD PTR _web+1592
	mov	DWORD PTR _second$[ebp], eax

; 769  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	eax, DWORD PTR [edi+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list
	shl	esi, 5
	add	esi, DWORD PTR _gauss_lagrange+4

; 770  : 
; 771  :   /* derivatives of gaussian sum part */
; 772  :   memset((char*)sumgrad,0,sizeof(sumgrad));
; 773  :   memset((char*)sumhess,0,sizeof(sumhess));
; 774  :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	edi, edi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl$[ebp], esi
	mov	DWORD PTR _mi$[ebp], eax
	mov	DWORD PTR _m$[ebp], edi
	cmp	DWORD PTR [esi+4], edi
	jle	$LN41@edge_scala@6
	push	ebx
	mov	ebx, DWORD PTR _web+616
	jmp	SHORT $LN22@edge_scala@6
	npad	1
$LL47@edge_scala@6:
	mov	eax, DWORD PTR _mi$[ebp]
$LN22@edge_scala@6:

; 775  :   { e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	mov	ecx, DWORD PTR _e_info$GSCopy$[ebp]
	fild	DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+1268]
	mov	edx, DWORD PTR [edx+edi*4]

; 776  :     eval_second(mi->expr[0],e_info->gauss_pt[m],SDIM,&val,
; 777  :                                                      derivs,second,e_info->id);

	mov	eax, DWORD PTR [eax+232]
	add	ebx, ebx
	fstp	QWORD PTR [edx+ebx*8]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+1268]
	push	edx
	mov	edx, DWORD PTR _second$[ebp]
	push	edx
	lea	edx, DWORD PTR _derivs$[ebp]
	push	edx
	lea	edx, DWORD PTR _val$[ebp]
	push	edx
	mov	edx, DWORD PTR _web+616
	push	edx
	mov	edx, DWORD PTR [ecx+edi*4]
	push	edx
	push	eax
	call	_eval_second

; 778  :     tang = e_info->sides[m][0];

	mov	ecx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	edx, DWORD PTR [ecx+1276]
	mov	eax, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [eax]

; 779  :     len = sqrt(SDIM_dot(tang,tang));

	mov	ecx, DWORD PTR _web+616
	push	ecx
	push	eax
	push	eax
	mov	DWORD PTR _tang$[ebp], eax
	call	_dot
	add	esp, 40					; 00000028H
	call	__CIsqrt

; 780  :     if ( len == 0.0 ) continue;

	fld	ST(0)
	fldz

; 782  :     for ( k = 0 ; k < gl->lagpts ; k++ )

	mov	ebx, DWORD PTR _web+616
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	$LN51@edge_scala@6

; 781  :     value += gl->gausswt[m]*val*len;

	mov	edx, DWORD PTR [esi+12]
	fld	QWORD PTR [edx+edi*8]

; 782  :     for ( k = 0 ; k < gl->lagpts ; k++ )

	xor	ecx, ecx
	fld	QWORD PTR _val$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	fadd	QWORD PTR _value$[ebp]
	fstp	QWORD PTR _value$[ebp]
	cmp	DWORD PTR [esi+16], ecx
	jle	$LN16@edge_scala@6
$LN49@edge_scala@6:

; 783  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN17@edge_scala@6
	mov	edx, DWORD PTR _tang$[ebp]
	lea	ebx, DWORD PTR _derivs$[ebp]
	sub	edx, ebx
	mov	DWORD PTR tv766[ebp], edx
$LN42@edge_scala@6:
	mov	edx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	edx, DWORD PTR [edx+1336]
	mov	edx, DWORD PTR [edx+ecx*4]
	lea	edx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR tv544[ebp], edx

; 784  :          e_info->grad[k][j] += 
; 785  :              gl->gausswt[m]*(gl->gpoly[m][k]*derivs[j]*len
; 786  :                                   + val*tang[j]/len*gl->gpolypart[m][0][k]);

	mov	edx, DWORD PTR tv766[ebp]
	lea	ebx, DWORD PTR _derivs$[ebp+eax*8]
	fmul	QWORD PTR [edx+ebx]
	mov	edx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR [edx]
	fdiv	ST(0), ST(2)
	inc	eax
	fmul	QWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [edx+edi*4]
	fld	QWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR [esi+12]
	fmul	QWORD PTR [ebx]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fmul	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR tv544[ebp]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	ebx, DWORD PTR _web+616
	fld	QWORD PTR _val$[ebp]
	cmp	eax, ebx
	jl	SHORT $LN42@edge_scala@6
$LN17@edge_scala@6:

; 782  :     for ( k = 0 ; k < gl->lagpts ; k++ )

	inc	ecx
	cmp	ecx, DWORD PTR [esi+16]
	jl	SHORT $LN49@edge_scala@6
$LN16@edge_scala@6:

; 787  :     for ( k = 0 ; k < gl->lagpts ; k++ )

	mov	edx, DWORD PTR [esi+16]
	xor	ecx, ecx
	test	edx, edx
	jle	$LN67@edge_scala@6
$LN48@edge_scala@6:

; 788  :       for ( kk = 0 ; kk < gl->lagpts ; kk++ )

	xor	eax, eax
	test	edx, edx
	jle	$LN11@edge_scala@6
$LN9@edge_scala@6:

; 789  :          for ( j = 0 ; j < SDIM ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	test	ebx, ebx
	jle	$LN8@edge_scala@6
	mov	edx, DWORD PTR _tang$[ebp]
	lea	ebx, DWORD PTR _derivs$[ebp]
	sub	ebx, edx
	mov	DWORD PTR tv1488[ebp], ebx
	mov	ebx, DWORD PTR _web+616
	mov	DWORD PTR tv1088[ebp], edx
	jmp	SHORT $LN6@edge_scala@6
$LN46@edge_scala@6:
	mov	edx, DWORD PTR _tang$[ebp]
$LN6@edge_scala@6:

; 790  :             for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	DWORD PTR _jj$[ebp], 0
	test	ebx, ebx
	jle	$LN5@edge_scala@6
	mov	ebx, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv937[ebp], edx
	mov	edx, DWORD PTR _second$[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	lea	ebx, DWORD PTR _derivs$[ebp]
	sub	edx, ebx
	mov	DWORD PTR tv1003[ebp], edx
	mov	edx, DWORD PTR _jj$[ebp]
$LN3@edge_scala@6:

; 791  :               e_info->hess[k][kk][j][jj] += gl->gausswt[m]*
; 792  :      ( second[j][jj]*gl->gpoly[m][k]*gl->gpoly[m][kk]*len
; 793  :      + derivs[j]*gl->gpoly[m][k]*tang[jj]*gl->gpolypart[m][0][kk]/len
; 794  :      + derivs[jj]*gl->gpoly[m][kk]*tang[j]*gl->gpolypart[m][0][k]/len
; 795  :      - val*tang[j]*tang[jj]*gl->gpolypart[m][0][k]*gl->gpolypart[m][0][kk]/len/len/len
; 796  :      + ((j==jj)? val*gl->gpolypart[m][0][k]*gl->gpolypart[m][0][kk]/len : 0.0));

	cmp	DWORD PTR _j$[ebp], edx
	jne	SHORT $LN25@edge_scala@6
	mov	edx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+ecx*8]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edx+eax*8]
	fdiv	ST(0), ST(3)
	jmp	SHORT $LN26@edge_scala@6
$LN25@edge_scala@6:
	fld	ST(1)
$LN26@edge_scala@6:
	mov	edx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	esi, DWORD PTR [esi+24]
	fld	QWORD PTR [edx+ecx*8]
	mov	esi, DWORD PTR [esi+edi*4]
	mov	edi, DWORD PTR tv937[ebp]
	add	edi, DWORD PTR tv1488[ebp]
	mov	ebx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR [esi]
	mov	DWORD PTR tv1624[ebp], edi
	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
	mov	edi, DWORD PTR [edi+1340]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [edi+ebx*4]
	mov	ebx, DWORD PTR _jj$[ebp]
	lea	edi, DWORD PTR [edi+ebx*8]
	mov	ebx, DWORD PTR tv1088[ebp]
	mov	DWORD PTR tv649[ebp], edi
	mov	edi, DWORD PTR tv1488[ebp]
	fmul	QWORD PTR [edi+ebx]
	mov	edi, DWORD PTR tv937[ebp]
	mov	ebx, DWORD PTR tv1003[ebp]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR tv1624[ebp]
	fmul	QWORD PTR [esi+eax*8]
	fdiv	ST(0), ST(4)
	fld	QWORD PTR [ebx+edi]
	fmul	QWORD PTR [edx+ecx*8]
	mov	ebx, DWORD PTR tv937[ebp]
	add	ebx, 8
	mov	DWORD PTR tv937[ebp], ebx
	fmul	QWORD PTR [edx+eax*8]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR tv1088[ebp]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR _m$[ebp]
	fmul	QWORD PTR [edx]
	fmul	QWORD PTR [esi+ecx*8]
	fdiv	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fxch	ST(2)
	fmul	QWORD PTR [edx]
	fmul	QWORD PTR [ebx-8]
	fmul	QWORD PTR [esi+ecx*8]
	fmul	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR _gl$[ebp]
	mov	edx, DWORD PTR [esi+12]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fsubp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fmul	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR tv649[ebp]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR _jj$[ebp]
	mov	ebx, DWORD PTR _web+616
	fld	QWORD PTR _val$[ebp]
	inc	edx
	mov	DWORD PTR _jj$[ebp], edx
	cmp	edx, ebx
	jl	$LN3@edge_scala@6
$LN5@edge_scala@6:

; 789  :          for ( j = 0 ; j < SDIM ; j++ )

	inc	DWORD PTR _j$[ebp]
	add	DWORD PTR tv1088[ebp], 8
	cmp	DWORD PTR _j$[ebp], ebx
	jl	$LN46@edge_scala@6
$LN8@edge_scala@6:

; 788  :       for ( kk = 0 ; kk < gl->lagpts ; kk++ )

	inc	eax
	cmp	eax, DWORD PTR [esi+16]
	jl	$LN9@edge_scala@6
$LN11@edge_scala@6:

; 787  :     for ( k = 0 ; k < gl->lagpts ; k++ )

	mov	edx, DWORD PTR [esi+16]
	inc	ecx
	cmp	ecx, edx
	jl	$LN48@edge_scala@6
$LN67@edge_scala@6:
	fstp	ST(2)
$LN51@edge_scala@6:

; 770  : 
; 771  :   /* derivatives of gaussian sum part */
; 772  :   memset((char*)sumgrad,0,sizeof(sumgrad));
; 773  :   memset((char*)sumhess,0,sizeof(sumhess));
; 774  :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	inc	edi

; 787  :     for ( k = 0 ; k < gl->lagpts ; k++ )

	fstp	ST(1)
	fstp	ST(0)
	mov	DWORD PTR _m$[ebp], edi
	cmp	edi, DWORD PTR [esi+4]
	jl	$LL47@edge_scala@6
	pop	ebx
$LN41@edge_scala@6:

; 797  :   }
; 798  : 
; 799  :   return value;
; 800  : } // end edge_scalar_integral_lagr_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fld	QWORD PTR _value$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_scalar_integral_lagr_hess ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_vector_integral_q
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _edge_vector_integral_q
_TEXT	SEGMENT
_weight$89663 = -96					; size = 8
_sign$ = -88						; size = 8
_value$ = -80						; size = 8
_k$ = -72						; size = 4
_mi$ = -68						; size = 4
_e_info$GSCopy$ = -64					; size = 4
tv1287 = -60						; size = 4
tv981 = -56						; size = 4
_m$ = -56						; size = 4
_tang$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_vector_integral_q PROC				; COMDAT

; 946  : { int m,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 947  :   REAL value=0.0;
; 948  :   REAL tang[MAXCOORD];
; 949  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	ecx, DWORD PTR _web+124
	fldz
	push	ebx
	fst	QWORD PTR _value$[ebp]
	mov	ebx, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [ebx]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	or	eax, ecx
	push	edi

; 958  :           tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	DWORD PTR _e_info$GSCopy$[ebp], ebx
	je	SHORT $LN12@edge_vecto

; 947  :   REAL value=0.0;
; 948  :   REAL tang[MAXCOORD];
; 949  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN43@edge_vecto
$LN12@edge_vecto:
	fld1
$LN43@edge_vecto:

; 950  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	eax, DWORD PTR [ebx+8]
	fstp	QWORD PTR _sign$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 951  : 
; 952  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	edi, edi
	mov	DWORD PTR _mi$[ebp], eax
	mov	DWORD PTR _m$[ebp], edi
	cmp	DWORD PTR _gauss1D_num, ecx
	jle	$LN7@edge_vecto
	mov	ecx, DWORD PTR _web+616
	push	esi
$LN25@edge_vecto:

; 953  :   { REAL weight = sign*gauss1Dwt[m];

	mov	edx, DWORD PTR _gauss1Dwt
	fld	QWORD PTR [edx+edi*8]

; 954  :     e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	mov	edx, DWORD PTR [ebx+1268]
	fmul	QWORD PTR _sign$[ebp]
	mov	edx, DWORD PTR [edx+edi*4]
	add	ecx, ecx

; 955  :      for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	fstp	QWORD PTR _weight$89663[ebp]
	fild	DWORD PTR _m$[ebp]
	fstp	QWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _web+616
	test	ecx, ecx
	jle	$LN8@edge_vecto

; 953  :   { REAL weight = sign*gauss1Dwt[m];

	add	eax, 232				; 000000e8H
	mov	DWORD PTR tv1287[ebp], eax
	npad	1
$LL41@edge_vecto:

; 957  :         for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	edx, DWORD PTR _edge_ctrl
	fstp	ST(0)
	fldz
	xor	eax, eax
	fstp	QWORD PTR _tang$[ebp+esi*8]
	cmp	edx, 4
	jl	SHORT $LC21@edge_vecto

; 956  :      { tang[j] = 0.0;

	mov	ecx, DWORD PTR _gauss1polyd
	add	edx, -4					; fffffffcH
	shr	edx, 2
	inc	edx
	mov	DWORD PTR tv981[ebp], edx
	add	edx, edx
	add	ecx, 8
	add	edx, edx
	lea	eax, DWORD PTR [ebx+420]
	mov	DWORD PTR _k$[ebp], edx

; 957  :         for ( k = 0 ; k < edge_ctrl ; k++ )

$LL22@edge_vecto:

; 958  :           tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	edx, DWORD PTR [eax-4]
	fld	QWORD PTR [edx+esi*8]
	mov	ebx, DWORD PTR [ecx-8]
	fmul	QWORD PTR [ebx+edi*8]
	mov	edx, DWORD PTR [ecx-4]
	mov	ebx, DWORD PTR [eax]
	add	eax, 16					; 00000010H
	fadd	QWORD PTR _tang$[ebp+esi*8]
	add	ecx, 16					; 00000010H
	dec	DWORD PTR tv981[ebp]
	fld	QWORD PTR [edx+edi*8]
	fmul	QWORD PTR [ebx+esi*8]
	mov	edx, DWORD PTR [eax-12]
	mov	ebx, DWORD PTR [ecx-16]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx+esi*8]
	mov	edx, DWORD PTR [eax-8]
	fmul	QWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR [ecx-12]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx+esi*8]
	fmul	QWORD PTR [ebx+edi*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _tang$[ebp+esi*8]
	jne	SHORT $LL22@edge_vecto

; 956  :      { tang[j] = 0.0;

	mov	edx, DWORD PTR _edge_ctrl
	mov	ebx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
$LC21@edge_vecto:

; 957  :         for ( k = 0 ; k < edge_ctrl ; k++ )

	cmp	eax, edx
	jge	SHORT $LN20@edge_vecto
	lea	edx, DWORD PTR [ebx+eax*4+416]
$LL26@edge_vecto:

; 958  :           tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	ecx, DWORD PTR _gauss1polyd
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	ebx, DWORD PTR [edx]
	fld	QWORD PTR [ecx+edi*8]
	fmul	QWORD PTR [ebx+esi*8]
	inc	eax
	add	edx, 4
	fadd	QWORD PTR _tang$[ebp+esi*8]
	fstp	QWORD PTR _tang$[ebp+esi*8]
	cmp	eax, DWORD PTR _edge_ctrl
	jl	SHORT $LL26@edge_vecto

; 957  :         for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	ebx, DWORD PTR _e_info$GSCopy$[ebp]
$LN20@edge_vecto:

; 959  :         value += weight*tang[j]*eval(mi->expr[j],
; 960  :                           e_info->gauss_pt[m],e_info->id,NULL);

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx+1268]
	mov	ecx, DWORD PTR [eax+edi*4]
	push	0
	push	edx
	mov	edx, DWORD PTR tv1287[ebp]
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	eax
	call	_eval
	fld	QWORD PTR _tang$[ebp+esi*8]
	fmul	QWORD PTR _weight$89663[ebp]
	mov	ecx, DWORD PTR _web+616
	add	DWORD PTR tv1287[ebp], 4
	inc	esi
	fmulp	ST(1), ST(0)
	add	esp, 16					; 00000010H
	fadd	QWORD PTR _value$[ebp]
	fst	QWORD PTR _value$[ebp]
	cmp	esi, ecx
	jl	$LL41@edge_vecto

; 955  :      for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _mi$[ebp]
$LN8@edge_vecto:

; 951  : 
; 952  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	edi
	mov	DWORD PTR _m$[ebp], edi
	cmp	edi, DWORD PTR _gauss1D_num
	jl	$LN25@edge_vecto
	pop	esi
$LN7@edge_vecto:

; 961  :      }
; 962  :   }
; 963  :   return value;
; 964  : } // end edge_vector_integral_q()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_vector_integral_q ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_vector_integral_q_grad
; Function compile flags: /Ogtp
;	COMDAT _edge_vector_integral_q_grad
_TEXT	SEGMENT
_weight$89690 = -428					; size = 8
_value$ = -420						; size = 8
_sign$ = -412						; size = 8
_mi$ = -404						; size = 4
_e_info$GSCopy$ = -400					; size = 4
tv246 = -396						; size = 4
_j$ = -396						; size = 4
_m$ = -396						; size = 4
tv1489 = -392						; size = 4
_k$ = -392						; size = 4
_derivs$ = -388						; size = 288
_val$ = -100						; size = 48
_tang$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_vector_integral_q_grad PROC			; COMDAT

; 975  : { int m,j,k,i;

	push	ebp
	mov	ebp, esp
	sub	esp, 428				; 000001acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 976  :   REAL value = 0.0;
; 977  :   REAL val[MAXCOORD];
; 978  :   REAL derivs[MAXCOORD][MAXCOORD];
; 979  :   REAL sum;
; 980  :   REAL tang[MAXCOORD];
; 981  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	ecx, DWORD PTR _web+124
	fldz
	push	esi
	fld	ST(0)
	push	edi
	fst	QWORD PTR _value$[ebp]
	mov	edi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [edi]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	or	eax, ecx

; 990  :            tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	DWORD PTR _e_info$GSCopy$[ebp], edi
	je	SHORT $LN24@edge_vecto@2

; 976  :   REAL value = 0.0;
; 977  :   REAL val[MAXCOORD];
; 978  :   REAL derivs[MAXCOORD][MAXCOORD];
; 979  :   REAL sum;
; 980  :   REAL tang[MAXCOORD];
; 981  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN107@edge_vecto@2
$LN24@edge_vecto@2:
	fld1
$LN107@edge_vecto@2:

; 982  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	eax, DWORD PTR [edi+8]
	fstp	QWORD PTR _sign$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 983  : 
; 984  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	esi, esi
	mov	DWORD PTR _mi$[ebp], eax
	mov	DWORD PTR _m$[ebp], esi
	cmp	DWORD PTR _gauss1D_num, ecx
	jle	$LN61@edge_vecto@2
	mov	edx, DWORD PTR _web+616
	push	ebx
	jmp	SHORT $LN108@edge_vecto@2
	npad	3
$LL105@edge_vecto@2:
	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
$LN108@edge_vecto@2:

; 985  :   { REAL weight = sign*gauss1Dwt[m];

	mov	eax, DWORD PTR _gauss1Dwt
	fstp	ST(0)
	fld	QWORD PTR [eax+esi*8]

; 986  :     e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	mov	ecx, DWORD PTR [edi+1268]
	fmul	QWORD PTR _sign$[ebp]
	mov	eax, DWORD PTR [ecx+esi*4]
	add	edx, edx
	fstp	QWORD PTR _weight$89690[ebp]
	fild	DWORD PTR _m$[ebp]
	fstp	QWORD PTR [eax+edx*8]

; 987  :     for ( j = 0 ; j < SDIM ; j++ ) 

	mov	edx, DWORD PTR _web+616
	xor	eax, eax
	test	edx, edx
	jle	$LN80@edge_vecto@2
	mov	ebx, DWORD PTR _edge_ctrl
$LN18@edge_vecto@2:

; 989  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	ecx, ecx
	fst	QWORD PTR _tang$[ebp+eax*8]
	cmp	ebx, 4
	jl	$LC41@edge_vecto@2

; 988  :     { tang[j] = 0.0;

	mov	edx, DWORD PTR _gauss1polyd
	lea	ecx, DWORD PTR [edi+420]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv246[ebp], edi
	add	edi, edi
	add	edx, 8
	add	edi, edi
	mov	DWORD PTR _k$[ebp], edi

; 989  :       for ( k = 0 ; k < edge_ctrl ; k++ )

$LN42@edge_vecto@2:

; 990  :            tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	ebx, DWORD PTR [edx-8]
	mov	edi, DWORD PTR [ecx-4]
	fld	QWORD PTR [edi+eax*8]
	add	ecx, 16					; 00000010H
	fmul	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR [ecx-16]
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv246[ebp]
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	edi, DWORD PTR [edx-20]
	fld	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR [ecx-12]
	fmul	QWORD PTR [ebx+eax*8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	ebx, DWORD PTR [edx-16]
	fld	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR [ecx-8]
	fmul	QWORD PTR [ebx+esi*8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	ebx, DWORD PTR [edx-12]
	fld	QWORD PTR [edi+eax*8]
	fmul	QWORD PTR [ebx+esi*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _tang$[ebp+eax*8]
	jne	SHORT $LN42@edge_vecto@2

; 988  :     { tang[j] = 0.0;

	mov	ebx, DWORD PTR _edge_ctrl
	mov	edx, DWORD PTR _web+616
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
$LC41@edge_vecto@2:

; 989  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	cmp	ecx, ebx
	jge	SHORT $LN17@edge_vecto@2
	lea	edi, DWORD PTR [edi+ecx*4+416]
$LN50@edge_vecto@2:

; 990  :            tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	edx, DWORD PTR _gauss1polyd
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [edi]
	fld	QWORD PTR [edx+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR _edge_ctrl
	inc	ecx
	add	edi, 4
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fstp	QWORD PTR _tang$[ebp+eax*8]
	cmp	ecx, ebx
	jl	SHORT $LN50@edge_vecto@2

; 989  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	edx, DWORD PTR _web+616
	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
$LN17@edge_vecto@2:

; 987  :     for ( j = 0 ; j < SDIM ; j++ ) 

	inc	eax
	cmp	eax, edx
	jl	$LN18@edge_vecto@2
$LN80@edge_vecto@2:

; 989  :       for ( k = 0 ; k < edge_ctrl ; k++ )

	fstp	ST(0)

; 991  :     }
; 992  :     for ( j = 0 ; j < SDIM ; j++ ) 

	mov	DWORD PTR _j$[ebp], 0
	test	edx, edx
	jle	SHORT $LN10@edge_vecto@2
	mov	ebx, DWORD PTR _mi$[ebp]
	lea	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR tv1489[ebp], eax
	lea	edi, DWORD PTR _derivs$[ebp]
	add	ebx, 232				; 000000e8H
	npad	3
$LL53@edge_vecto@2:

; 993  :       eval_all(mi->expr[j],e_info->gauss_pt[m],SDIM,val+j,
; 994  :                                                    derivs[j],e_info->id);

	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR tv1489[ebp]
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	push	edx
	mov	edx, DWORD PTR [eax+1268]
	mov	eax, DWORD PTR [edx+esi*4]
	push	eax
	push	ecx
	call	_eval_all
	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _web+616
	add	DWORD PTR tv1489[ebp], 8
	inc	eax
	add	esp, 24					; 00000018H
	add	ebx, 4
	add	edi, 48					; 00000030H
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, edx
	jl	SHORT $LL53@edge_vecto@2
$LN10@edge_vecto@2:

; 995  :     value += weight*SDIM_dot(val,tang);

	push	edx
	lea	edx, DWORD PTR _tang$[ebp]
	push	edx
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_dot
	fld	QWORD PTR _weight$89690[ebp]

; 996  :     for ( k = 0 ; k < SDIM ; k++ )

	mov	edx, DWORD PTR _web+616
	fmul	ST(1), ST(0)
	fxch	ST(1)
	xor	edi, edi
	add	esp, 12					; 0000000cH
	fadd	QWORD PTR _value$[ebp]
	mov	DWORD PTR _k$[ebp], edi
	fst	QWORD PTR _value$[ebp]
	test	edx, edx
	jle	$LN82@edge_vecto@2
	fldz
$LN55@edge_vecto@2:

; 997  :     { for ( sum = 0.0, j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	fld	ST(0)
	cmp	edx, 4
	jl	SHORT $LC44@edge_vecto@2

; 996  :     for ( k = 0 ; k < SDIM ; k++ )

	lea	ebx, DWORD PTR [edx-3]
	lea	ecx, DWORD PTR _derivs$[ebp+edi*8+48]
$LN54@edge_vecto@2:

; 998  :         sum += derivs[j][k]*tang[j];

	fld	QWORD PTR _tang$[ebp+eax*8]
	add	eax, 4
	fmul	QWORD PTR [ecx-48]
	add	ecx, 192				; 000000c0H
	faddp	ST(1), ST(0)
	fld	QWORD PTR _tang$[ebp+eax*8-24]
	fmul	QWORD PTR [ecx-192]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _tang$[ebp+eax*8-16]
	fmul	QWORD PTR [ecx-144]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _tang$[ebp+eax*8-8]
	fmul	QWORD PTR [ecx-96]
	faddp	ST(1), ST(0)
	cmp	eax, ebx
	jl	SHORT $LN54@edge_vecto@2
$LC44@edge_vecto@2:

; 997  :     { for ( sum = 0.0, j = 0 ; j < SDIM ; j++ )

	cmp	eax, edx
	jge	SHORT $LN43@edge_vecto@2
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [edi+ecx*2]
	lea	ecx, DWORD PTR _derivs$[ebp+ecx*8]
$LC6@edge_vecto@2:

; 998  :         sum += derivs[j][k]*tang[j];

	fld	QWORD PTR _tang$[ebp+eax*8]
	inc	eax
	fmul	QWORD PTR [ecx]
	add	ecx, 48					; 00000030H
	faddp	ST(1), ST(0)
	cmp	eax, edx
	jl	SHORT $LC6@edge_vecto@2
$LN43@edge_vecto@2:

; 999  :       for ( i = 0 ; i < edge_ctrl ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _edge_ctrl, eax
	jle	SHORT $LN94@edge_vecto@2
	mov	ebx, DWORD PTR _gauss1polyd
	sub	ebx, DWORD PTR _gauss1poly
$LN3@edge_vecto@2:
	mov	edx, DWORD PTR _gauss1poly
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	edx, DWORD PTR [edx+1336]
	mov	edx, DWORD PTR [edx+eax*4]
	lea	edx, DWORD PTR [edx+edi*8]

; 1000 :         e_info->grad[i][k] += 
; 1001 :                   weight*(gauss1polyd[i][m]*val[k] + gauss1poly[i][m]*sum);

	mov	edi, DWORD PTR [ecx+ebx]
	fld	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR _k$[ebp]
	fmul	QWORD PTR _val$[ebp+edi*8]
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [ecx+esi*8]
	inc	eax
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	cmp	eax, DWORD PTR _edge_ctrl
	jl	SHORT $LN3@edge_vecto@2

; 999  :       for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	edx, DWORD PTR _web+616
$LN94@edge_vecto@2:

; 996  :     for ( k = 0 ; k < SDIM ; k++ )

	inc	edi

; 999  :       for ( i = 0 ; i < edge_ctrl ; i++ )

	fstp	ST(0)
	mov	DWORD PTR _k$[ebp], edi
	cmp	edi, edx
	jl	$LN55@edge_vecto@2

; 996  :     for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(2)
	jmp	SHORT $LN20@edge_vecto@2
$LN82@edge_vecto@2:
	fstp	ST(1)
	fldz
	fxch	ST(1)
$LN20@edge_vecto@2:

; 983  : 
; 984  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	esi
	mov	DWORD PTR _m$[ebp], esi
	cmp	esi, DWORD PTR _gauss1D_num
	jl	$LL105@edge_vecto@2
	pop	ebx
$LN61@edge_vecto@2:

; 1002 :     }
; 1003 :   }
; 1004 : 
; 1005 :   return value;
; 1006 : } // end edge_vector_integral_q_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(1)
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_vector_integral_q_grad ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_vector_integral_q_hess
EXTRN	_mat3d_setup:PROC
; Function compile flags: /Ogtp
;	COMDAT _edge_vector_integral_q_hess
_TEXT	SEGMENT
_secondqXvS$ = -2352					; size = 168
_sign$ = -2184						; size = 8
tv3414 = -2176						; size = 4
_weight$89734 = -2172					; size = 8
tv3717 = -2168						; size = 4
_value$ = -2164						; size = 8
tv2430 = -2156						; size = 4
_mi$ = -2152						; size = 4
_ii$ = -2148						; size = 4
_second$ = -2144					; size = 4
tv3540 = -2140						; size = 4
tv1100 = -2136						; size = 4
_m$ = -2136						; size = 4
_e_info$GSCopy$ = -2132					; size = 4
tv3627 = -2128						; size = 4
tv599 = -2128						; size = 4
tv1863 = -2124						; size = 4
_i$ = -2124						; size = 4
tv1865 = -2120						; size = 4
_k$ = -2120						; size = 4
_secondxJ$ = -2116					; size = 1728
_derivs$ = -388						; size = 288
_val$ = -100						; size = 48
_tang$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_vector_integral_q_hess PROC			; COMDAT

; 1017 : { int m,i,j,k,ii,kk;

	push	ebp
	mov	ebp, esp
	sub	esp, 2352				; 00000930H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1018 :   REAL value = 0.0;

	fldz
	push	ebx
	push	esi
	fstp	QWORD PTR _value$[ebp]
	mov	esi, DWORD PTR _e_info$[ebp]

; 1019 :   REAL val[MAXCOORD];
; 1020 :   REAL derivs[MAXCOORD][MAXCOORD];
; 1021 :   REAL sum;
; 1022 :   MAT3D(second,MAXCOORD,MAXCOORD,MAXCOORD);

	push	6
	push	6
	push	6
	lea	eax, DWORD PTR _secondxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _secondqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _e_info$GSCopy$[ebp], esi
	call	_mat3d_setup

; 1023 :   REAL tang[MAXCOORD];
; 1024 :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR _second$[ebp], eax
	mov	eax, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	add	esp, 20					; 00000014H
	or	eax, ecx
	je	SHORT $LN39@edge_vecto@3
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN165@edge_vecto@3
$LN39@edge_vecto@3:
	fld1
$LN165@edge_vecto@3:

; 1025 :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	eax, DWORD PTR [esi+8]
	fstp	QWORD PTR _sign$[ebp]
	cdq
	mov	ebx, eax
	xor	ebx, edx
	sub	ebx, edx
	imul	ebx, 2928				; 00000b70H
	add	ebx, DWORD PTR _meth_inst_list

; 1026 : 
; 1027 :   for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	esi, esi
	mov	DWORD PTR _mi$[ebp], ebx
	mov	DWORD PTR _m$[ebp], esi
	cmp	DWORD PTR _gauss1D_num, ecx
	jle	$LN74@edge_vecto@3
	fldz
	push	edi
	mov	edi, DWORD PTR _web+616
	jmp	SHORT $LN36@edge_vecto@3
$LL164@edge_vecto@3:
	mov	ebx, DWORD PTR _mi$[ebp]
	fstp	ST(0)
$LN36@edge_vecto@3:

; 1028 :   { REAL weight = sign*gauss1Dwt[m];

	mov	ecx, DWORD PTR _gauss1Dwt
	fld	QWORD PTR [ecx+esi*8]

; 1029 :     e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	mov	edx, DWORD PTR _e_info$GSCopy$[ebp]
	fmul	QWORD PTR _sign$[ebp]
	mov	eax, DWORD PTR [edx+1268]
	mov	ecx, DWORD PTR [eax+esi*4]
	add	edi, edi
	fstp	QWORD PTR _weight$89734[ebp]

; 1030 :     for ( j = 0 ; j < SDIM ; j++ ) 

	xor	eax, eax
	fild	DWORD PTR _m$[ebp]
	fstp	QWORD PTR [ecx+edi*8]
	mov	edx, DWORD PTR _web+616
	test	edx, edx
	jle	$LN93@edge_vecto@3
	mov	ebx, DWORD PTR _edge_ctrl
$LN86@edge_vecto@3:

; 1032 :       for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	ecx, ecx
	fst	QWORD PTR _tang$[ebp+eax*8]
	cmp	ebx, 4
	jl	$LN79@edge_vecto@3

; 1031 :     { tang[j] = 0.0;

	mov	edx, DWORD PTR _gauss1polyd
	mov	ecx, DWORD PTR _e_info$GSCopy$[ebp]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv599[ebp], edi
	add	edi, edi
	add	edx, 8
	add	ecx, 420				; 000001a4H
	add	edi, edi
	mov	DWORD PTR _k$[ebp], edi

; 1032 :       for ( k = 0 ; k < edge_ctrl ; k++ )

$LN67@edge_vecto@3:

; 1033 :           tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	ebx, DWORD PTR [edx-8]
	mov	edi, DWORD PTR [ecx-4]
	fld	QWORD PTR [edi+eax*8]
	add	ecx, 16					; 00000010H
	fmul	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR [ecx-16]
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv599[ebp]
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	edi, DWORD PTR [edx-20]
	fld	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR [ecx-12]
	fmul	QWORD PTR [ebx+eax*8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	ebx, DWORD PTR [edx-16]
	fld	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR [ecx-8]
	fmul	QWORD PTR [ebx+esi*8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$[ebp+eax*8]
	mov	ebx, DWORD PTR [edx-12]
	fld	QWORD PTR [edi+eax*8]
	fmul	QWORD PTR [ebx+esi*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _tang$[ebp+eax*8]
	jne	SHORT $LN67@edge_vecto@3

; 1031 :     { tang[j] = 0.0;

	mov	edx, DWORD PTR _web+616
	mov	ecx, DWORD PTR _k$[ebp]
	mov	ebx, DWORD PTR _edge_ctrl
$LN79@edge_vecto@3:

; 1032 :       for ( k = 0 ; k < edge_ctrl ; k++ )

	cmp	ecx, ebx
	jge	SHORT $LN32@edge_vecto@3
	mov	edx, DWORD PTR _e_info$GSCopy$[ebp]
	lea	edi, DWORD PTR [edx+ecx*4+416]
$LN84@edge_vecto@3:

; 1033 :           tang[j] += gauss1polyd[k][m]*e_info->x[k][j];

	mov	edx, DWORD PTR _gauss1polyd
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [edi]
	fld	QWORD PTR [edx+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR _edge_ctrl
	inc	ecx
	add	edi, 4
	fadd	QWORD PTR _tang$[ebp+eax*8]
	fstp	QWORD PTR _tang$[ebp+eax*8]
	cmp	ecx, ebx
	jl	SHORT $LN84@edge_vecto@3

; 1032 :       for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	edx, DWORD PTR _web+616
$LN32@edge_vecto@3:

; 1030 :     for ( j = 0 ; j < SDIM ; j++ ) 

	inc	eax
	cmp	eax, edx
	jl	$LN86@edge_vecto@3
	mov	ebx, DWORD PTR _mi$[ebp]
$LN93@edge_vecto@3:

; 1034 :     }
; 1035 :     for ( j = 0 ; j < SDIM ; j++ ) 

	xor	edi, edi
	fstp	ST(0)
	test	edx, edx
	jle	SHORT $LN25@edge_vecto@3
	lea	eax, DWORD PTR _val$[ebp]
	lea	ecx, DWORD PTR _derivs$[ebp]
	mov	DWORD PTR tv1863[ebp], eax
	mov	DWORD PTR tv1865[ebp], ecx
	add	ebx, 232				; 000000e8H
$LL85@edge_vecto@3:

; 1036 :       eval_second(mi->expr[j],e_info->gauss_pt[m],SDIM,
; 1037 :         val+j, derivs[j],second[j],e_info->id);

	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	push	ecx
	mov	ecx, DWORD PTR tv1865[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv1863[ebp]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	push	edx
	mov	edx, DWORD PTR [eax+1268]
	mov	eax, DWORD PTR [edx+esi*4]
	push	eax
	push	ecx
	call	_eval_second
	mov	edx, DWORD PTR _web+616
	add	DWORD PTR tv1865[ebp], 48		; 00000030H
	add	DWORD PTR tv1863[ebp], 8
	inc	edi
	add	esp, 28					; 0000001cH
	add	ebx, 4
	cmp	edi, edx
	jl	SHORT $LL85@edge_vecto@3
$LN25@edge_vecto@3:

; 1038 :     value += weight*SDIM_dot(val,tang);

	push	edx
	lea	edx, DWORD PTR _tang$[ebp]
	push	edx
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_dot
	fld	QWORD PTR _weight$89734[ebp]

; 1039 :     for ( k = 0 ; k < SDIM ; k++ )

	mov	edi, DWORD PTR _web+616
	fmul	ST(1), ST(0)
	fxch	ST(1)
	xor	edx, edx
	add	esp, 12					; 0000000cH
	fadd	QWORD PTR _value$[ebp]
	mov	DWORD PTR _k$[ebp], edx
	fst	QWORD PTR _value$[ebp]
	fldz
	test	edi, edi
	jle	$LN22@edge_vecto@3
$LN89@edge_vecto@3:

; 1040 :       { for ( sum = 0.0, j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	fld	ST(0)
	cmp	edi, 4
	jl	SHORT $LC69@edge_vecto@3

; 1039 :     for ( k = 0 ; k < SDIM ; k++ )

	lea	ebx, DWORD PTR [edi-3]
	lea	ecx, DWORD PTR _derivs$[ebp+edx*8+48]
$LN88@edge_vecto@3:

; 1041 :              sum += derivs[j][k]*tang[j];

	fld	QWORD PTR _tang$[ebp+eax*8]
	add	eax, 4
	fmul	QWORD PTR [ecx-48]
	add	ecx, 192				; 000000c0H
	faddp	ST(1), ST(0)
	fld	QWORD PTR _tang$[ebp+eax*8-24]
	fmul	QWORD PTR [ecx-192]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _tang$[ebp+eax*8-16]
	fmul	QWORD PTR [ecx-144]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _tang$[ebp+eax*8-8]
	fmul	QWORD PTR [ecx-96]
	faddp	ST(1), ST(0)
	cmp	eax, ebx
	jl	SHORT $LN88@edge_vecto@3
$LC69@edge_vecto@3:

; 1040 :       { for ( sum = 0.0, j = 0 ; j < SDIM ; j++ )

	cmp	eax, edi
	jge	SHORT $LN68@edge_vecto@3
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [edx+ecx*2]
	lea	ecx, DWORD PTR _derivs$[ebp+ecx*8]
$LC21@edge_vecto@3:

; 1041 :              sum += derivs[j][k]*tang[j];

	fld	QWORD PTR _tang$[ebp+eax*8]
	inc	eax
	fmul	QWORD PTR [ecx]
	add	ecx, 48					; 00000030H
	faddp	ST(1), ST(0)
	cmp	eax, edi
	jl	SHORT $LC21@edge_vecto@3
$LN68@edge_vecto@3:

; 1042 :          for ( i = 0 ; i < edge_ctrl ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _edge_ctrl, eax
	jle	SHORT $LN123@edge_vecto@3
	mov	edi, DWORD PTR _gauss1polyd
	sub	edi, DWORD PTR _gauss1poly
$LN18@edge_vecto@3:

; 1039 :     for ( k = 0 ; k < SDIM ; k++ )

	mov	ebx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ebx, DWORD PTR [ebx+1336]
	mov	ebx, DWORD PTR [ebx+eax*4]

; 1042 :          for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	ecx, DWORD PTR _gauss1poly
	lea	edx, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+eax*4]

; 1043 :             e_info->grad[i][k] += 
; 1044 :               weight*(gauss1polyd[i][m]*val[k] + gauss1poly[i][m]*sum);

	mov	ebx, DWORD PTR [ecx+edi]
	fld	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR _val$[ebp+ebx*8]
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [ecx+esi*8]
	inc	eax
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, ebx
	cmp	eax, DWORD PTR _edge_ctrl
	jl	SHORT $LN18@edge_vecto@3

; 1042 :          for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	edi, DWORD PTR _web+616
$LN123@edge_vecto@3:

; 1039 :     for ( k = 0 ; k < SDIM ; k++ )

	inc	edx

; 1042 :          for ( i = 0 ; i < edge_ctrl ; i++ )

	fstp	ST(0)
	mov	DWORD PTR _k$[ebp], edx
	cmp	edx, edi
	jl	$LN89@edge_vecto@3
$LN22@edge_vecto@3:

; 1045 :       }
; 1046 : 
; 1047 :     for ( ii = 0 ; ii < SDIM ; ii++ )

	xor	eax, eax
	mov	DWORD PTR _ii$[ebp], eax
	cmp	edi, eax
	jle	$LN161@edge_vecto@3
	mov	DWORD PTR tv3627[ebp], eax
$LN90@edge_vecto@3:

; 1048 :      for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	mov	DWORD PTR _i$[ebp], edx
	test	edi, edi
	jle	$LN14@edge_vecto@3

; 1045 :       }
; 1046 : 
; 1047 :     for ( ii = 0 ; ii < SDIM ; ii++ )

	lea	ecx, DWORD PTR _derivs$[ebp+eax*8]
	mov	DWORD PTR tv3540[ebp], ecx
$LN82@edge_vecto@3:

; 1049 :       { for ( sum = 0.0, j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	fld	ST(0)
	cmp	edi, 4
	jl	SHORT $LC72@edge_vecto@3
	mov	ebx, DWORD PTR _second$[ebp]
	add	ebx, 8
$LN73@edge_vecto@3:

; 1050 :              sum += second[j][ii][i]*tang[j];

	mov	edi, DWORD PTR [ebx-8]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR [ebx-4]
	fmul	QWORD PTR _tang$[ebp+ecx*8]
	mov	edi, DWORD PTR [edi+eax*4]
	add	ecx, 4
	add	ebx, 16					; 00000010H
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR [ebx-16]
	fmul	QWORD PTR _tang$[ebp+ecx*8-24]
	mov	edi, DWORD PTR [edi+eax*4]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR [ebx-12]
	fmul	QWORD PTR _tang$[ebp+ecx*8-16]
	mov	edi, DWORD PTR [edi+eax*4]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+edx*8]

; 1053 :               e_info->hess[k][kk][i][ii] += weight*
; 1054 :               ( sum*gauss1poly[k][m]*gauss1poly[kk][m]
; 1055 :                  + gauss1polyd[k][m]*derivs[i][ii]*gauss1poly[kk][m]
; 1056 :                  + gauss1polyd[kk][m]*derivs[ii][i]*gauss1poly[k][m]
; 1057 :               );

	mov	edi, DWORD PTR _web+616
	fmul	QWORD PTR _tang$[ebp+ecx*8-8]
	add	edi, -3					; fffffffdH
	faddp	ST(1), ST(0)
	cmp	ecx, edi
	jl	SHORT $LN73@edge_vecto@3

; 1050 :              sum += second[j][ii][i]*tang[j];

	mov	edi, DWORD PTR _web+616
$LC72@edge_vecto@3:

; 1049 :       { for ( sum = 0.0, j = 0 ; j < SDIM ; j++ )

	cmp	ecx, edi
	jge	SHORT $LN71@edge_vecto@3
$LN83@edge_vecto@3:

; 1050 :              sum += second[j][ii][i]*tang[j];

	mov	ebx, DWORD PTR _second$[ebp]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR [ebx+eax*4]
	fld	QWORD PTR [ebx+edx*8]
	inc	ecx
	fmul	QWORD PTR _tang$[ebp+ecx*8-8]
	faddp	ST(1), ST(0)
	cmp	ecx, edi
	jl	SHORT $LN83@edge_vecto@3
$LN71@edge_vecto@3:

; 1051 :          for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	ecx, DWORD PTR _edge_ctrl
	xor	ebx, ebx
	mov	DWORD PTR _k$[ebp], ebx
	test	ecx, ecx
	jle	$LN149@edge_vecto@3
	mov	edi, DWORD PTR _gauss1polyd
	sub	edi, DWORD PTR _gauss1poly
	mov	DWORD PTR tv2430[ebp], edi
$LN6@edge_vecto@3:

; 1052 :             for ( kk = 0 ; kk < edge_ctrl ; kk++ )

	xor	edi, edi
	test	ecx, ecx
	jle	$LN5@edge_vecto@3

; 1026 : 
; 1027 :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	eax, DWORD PTR _gauss1poly
	mov	ecx, DWORD PTR tv2430[ebp]

; 1051 :          for ( k = 0 ; k < edge_ctrl ; k++ )

	lea	eax, DWORD PTR [eax+ebx*4]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [ecx+esi*8]
	mov	DWORD PTR tv3414[ebp], ecx
	mov	ecx, DWORD PTR tv3627[ebp]
	add	ecx, edx
	lea	edx, DWORD PTR _derivs$[ebp+ecx*8]
	lea	ecx, DWORD PTR [eax+esi*8]

; 1052 :             for ( kk = 0 ; kk < edge_ctrl ; kk++ )

	mov	eax, DWORD PTR _gauss1poly
	mov	DWORD PTR tv3717[ebp], edx
	mov	DWORD PTR tv1100[ebp], ecx
$LN3@edge_vecto@3:

; 1053 :               e_info->hess[k][kk][i][ii] += weight*
; 1054 :               ( sum*gauss1poly[k][m]*gauss1poly[kk][m]
; 1055 :                  + gauss1polyd[k][m]*derivs[i][ii]*gauss1poly[kk][m]
; 1056 :                  + gauss1polyd[kk][m]*derivs[ii][i]*gauss1poly[k][m]
; 1057 :               );

	mov	edx, DWORD PTR [eax]
	fld	ST(0)
	lea	ecx, DWORD PTR [edx+esi*8]
	mov	edx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	edx, DWORD PTR [edx+1340]
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	ebx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	ebx, DWORD PTR _ii$[ebp]
	lea	edx, DWORD PTR [edx+ebx*8]
	mov	ebx, DWORD PTR tv1100[ebp]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv3414[ebp]
	inc	edi
	add	eax, 4
	fmul	QWORD PTR [ecx]
	fld	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv3540[ebp]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [ecx]
	mov	ecx, DWORD PTR tv2430[ebp]
	mov	ecx, DWORD PTR [ecx+eax-4]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx+esi*8]
	mov	ecx, DWORD PTR tv3717[ebp]
	fmul	QWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1100[ebp]
	fmul	QWORD PTR [ecx]
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	cmp	edi, DWORD PTR _edge_ctrl
	jl	SHORT $LN3@edge_vecto@3

; 1052 :             for ( kk = 0 ; kk < edge_ctrl ; kk++ )

	mov	eax, DWORD PTR _ii$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _edge_ctrl
$LN5@edge_vecto@3:

; 1051 :          for ( k = 0 ; k < edge_ctrl ; k++ )

	inc	ebx
	mov	DWORD PTR _k$[ebp], ebx
	cmp	ebx, ecx
	jl	$LN6@edge_vecto@3
	mov	edi, DWORD PTR _web+616
$LN149@edge_vecto@3:

; 1048 :      for ( i = 0 ; i < SDIM ; i++ )

	add	DWORD PTR tv3540[ebp], 48		; 00000030H

; 1051 :          for ( k = 0 ; k < edge_ctrl ; k++ )

	fstp	ST(0)
	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, edi
	jl	$LN82@edge_vecto@3
$LN14@edge_vecto@3:

; 1045 :       }
; 1046 : 
; 1047 :     for ( ii = 0 ; ii < SDIM ; ii++ )

	add	DWORD PTR tv3627[ebp], 6
	inc	eax
	mov	DWORD PTR _ii$[ebp], eax
	cmp	eax, edi
	jl	$LN90@edge_vecto@3
$LN161@edge_vecto@3:

; 1026 : 
; 1027 :   for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	esi

; 1051 :          for ( k = 0 ; k < edge_ctrl ; k++ )

	fstp	ST(2)
	mov	DWORD PTR _m$[ebp], esi
	cmp	esi, DWORD PTR _gauss1D_num
	jl	$LL164@edge_vecto@3

; 1026 : 
; 1027 :   for ( m = 0 ; m < gauss1D_num ; m++ )

	pop	edi
	fstp	ST(1)
	pop	esi
	pop	ebx

; 1058 :       }
; 1059 :   }
; 1060 : 
; 1061 :   return value;
; 1062 : } // end edge_vector_integral_q_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@edge_vecto@3:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fld	QWORD PTR _value$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_vector_integral_q_hess ENDP
_TEXT	ENDS
PUBLIC	_q_edge_area_q
EXTRN	_scoeff:BYTE
; Function compile flags: /Ogtp
;	COMDAT _q_edge_area_q
_TEXT	SEGMENT
tv1096 = -8						; size = 4
_i$ = -4						; size = 4
_e_info$ = 8						; size = 4
_q_edge_area_q PROC					; COMDAT

; 1194 : { REAL **x;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1195 :   REAL area;
; 1196 :   int i,j;
; 1197 : 
; 1198 :   x = e_info->x;

	mov	eax, DWORD PTR _e_info$[ebp]

; 1199 : 
; 1200 :   /* main integral over edge */
; 1201 :   area = 0.0;

	fldz
	push	esi

; 1202 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	esi, DWORD PTR _edge_ctrl
	xor	ecx, ecx
	mov	DWORD PTR _i$[ebp], ecx
	test	esi, esi
	jle	$LN4@q_edge_are

; 1195 :   REAL area;
; 1196 :   int i,j;
; 1197 : 
; 1198 :   x = e_info->x;

	push	ebx
	mov	DWORD PTR tv1096[ebp], OFFSET _scoeff+24
	push	edi
$LN17@q_edge_are:

; 1203 :      for ( j = 0 ; j < edge_ctrl ; j++ )

	xor	edi, edi
	cmp	esi, 4
	jl	SHORT $LC14@q_edge_are
	mov	edx, DWORD PTR [eax+ecx*4+416]
	mov	ecx, DWORD PTR tv1096[ebp]
	add	esi, -4					; fffffffcH
	shr	esi, 2
	add	eax, 424				; 000001a8H
	inc	esi
	lea	edi, DWORD PTR [esi*4]
$LN15@q_edge_are:

; 1204 :         { REAL v = scoeff[j][i];
; 1205 :           area += v*x[i][0]*x[j][1];

	fld	QWORD PTR [ecx-24]
	mov	ebx, DWORD PTR [eax-8]
	fmul	QWORD PTR [edx]
	add	eax, 16					; 00000010H
	add	ecx, 96					; 00000060H
	dec	esi
	fmul	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [eax-20]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx]
	fmul	QWORD PTR [ecx-96]
	fmul	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [eax-16]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-72]
	fmul	QWORD PTR [edx]
	fmul	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [eax-12]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-48]
	fmul	QWORD PTR [edx]
	fmul	QWORD PTR [ebx+8]
	faddp	ST(1), ST(0)
	jne	SHORT $LN15@q_edge_are

; 1203 :      for ( j = 0 ; j < edge_ctrl ; j++ )

	mov	esi, DWORD PTR _edge_ctrl
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _e_info$[ebp]
$LC14@q_edge_are:
	cmp	edi, esi
	jge	SHORT $LN5@q_edge_are
	mov	edx, DWORD PTR [eax+ecx*4+416]
	lea	ecx, DWORD PTR [ecx+edi*2]
	add	ecx, edi
	lea	ecx, DWORD PTR _scoeff[ecx*8]
$LC3@q_edge_are:

; 1204 :         { REAL v = scoeff[j][i];
; 1205 :           area += v*x[i][0]*x[j][1];

	fld	QWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+edi*4+416]
	fmul	QWORD PTR [edx]
	inc	edi
	add	ecx, 24					; 00000018H
	fmul	QWORD PTR [ebx+8]
	faddp	ST(1), ST(0)
	cmp	edi, esi
	jl	SHORT $LC3@q_edge_are

; 1203 :      for ( j = 0 ; j < edge_ctrl ; j++ )

	mov	ecx, DWORD PTR _i$[ebp]
$LN5@q_edge_are:

; 1202 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	add	DWORD PTR tv1096[ebp], 8
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, esi
	jl	$LN17@q_edge_are
	pop	edi
	pop	ebx
$LN4@q_edge_are:
	pop	esi

; 1206 :         }
; 1207 : 
; 1208 :   return area;
; 1209 : } // end q_edge_area_q()

	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_area_q ENDP
_TEXT	ENDS
PUBLIC	_q_edge_area_q_grad
; Function compile flags: /Ogtp
;	COMDAT _q_edge_area_q_grad
_TEXT	SEGMENT
tv482 = -28						; size = 4
_g$ = -24						; size = 4
_x$ = -20						; size = 4
tv416 = -16						; size = 4
_j$ = -12						; size = 4
tv467 = -8						; size = 4
_i$ = -4						; size = 4
tv465 = 8						; size = 4
_e_info$ = 8						; size = 4
_q_edge_area_q_grad PROC				; COMDAT

; 1219 : { REAL **x,**g;

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1220 :   REAL area;
; 1221 :   int i,j,k;
; 1222 : 
; 1223 :   x = e_info->x;

	mov	eax, DWORD PTR _e_info$[ebp]

; 1224 :   g = e_info->grad;
; 1225 :   /* gradients */
; 1226 :   for ( k = 0 ; k < edge_ctrl ; k++ )

	fldz
	mov	ecx, DWORD PTR _edge_ctrl
	push	ebx
	push	esi
	lea	ebx, DWORD PTR [eax+416]
	mov	eax, DWORD PTR [eax+1336]
	push	edi
	xor	edi, edi
	mov	DWORD PTR _x$[ebp], ebx
	mov	DWORD PTR _g$[ebp], eax
	test	ecx, ecx
	jle	SHORT $LN10@q_edge_are@2
	mov	esi, DWORD PTR _web+616
$LN12@q_edge_are@2:

; 1227 :      for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN11@q_edge_are@2

; 1224 :   g = e_info->grad;
; 1225 :   /* gradients */
; 1226 :   for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	ecx, DWORD PTR [eax+edi*4]
$LN9@q_edge_are@2:

; 1228 :         g[k][j] = 0.0;

	fst	QWORD PTR [ecx]
	mov	esi, DWORD PTR _web+616
	inc	edx
	add	ecx, 8
	cmp	edx, esi
	jl	SHORT $LN9@q_edge_are@2

; 1227 :      for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _edge_ctrl
$LN11@q_edge_are@2:

; 1224 :   g = e_info->grad;
; 1225 :   /* gradients */
; 1226 :   for ( k = 0 ; k < edge_ctrl ; k++ )

	inc	edi
	cmp	edi, ecx
	jl	SHORT $LN12@q_edge_are@2
$LN10@q_edge_are@2:

; 1229 : 
; 1230 :   /* main integral over edge */
; 1231 :   area = 0.0;
; 1232 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	ecx, ecx
	jle	$LN4@q_edge_are@2
	mov	esi, eax
	mov	edx, ebx
	sub	esi, ebx
	mov	DWORD PTR tv465[ebp], OFFSET _scoeff
	mov	DWORD PTR tv467[ebp], edx
	mov	DWORD PTR tv482[ebp], esi
$LN6@q_edge_are@2:

; 1233 :      for ( j = 0 ; j < edge_ctrl ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	test	ecx, ecx
	jle	SHORT $LN5@q_edge_are@2
	mov	esi, DWORD PTR [esi+edx]
	mov	edi, DWORD PTR [edx]
	mov	edx, DWORD PTR tv465[ebp]
	mov	ecx, ebx
	mov	ebx, DWORD PTR _j$[ebp]
	sub	ecx, eax
	mov	DWORD PTR tv416[ebp], ecx
	jmp	SHORT $LN3@q_edge_are@2
$LN24@q_edge_are@2:
	mov	ecx, DWORD PTR tv416[ebp]
$LN3@q_edge_are@2:

; 1234 :         { REAL v = scoeff[j][i];

	fld	QWORD PTR [edx]

; 1235 :           area += v*x[i][0]*x[j][1];

	mov	ecx, DWORD PTR [ecx+eax]
	fld	QWORD PTR [edi]
	inc	ebx
	fmul	ST(0), ST(1)
	add	edx, 24					; 00000018H
	add	eax, 4
	fmul	QWORD PTR [ecx+8]
	faddp	ST(2), ST(0)

; 1236 :           g[i][0] += v*x[j][1];

	fld	QWORD PTR [ecx+8]

; 1237 :           g[j][1] += v*x[i][0];

	mov	ecx, DWORD PTR [eax-4]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	fmul	QWORD PTR [edi]
	fadd	QWORD PTR [ecx+8]
	fstp	QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _edge_ctrl
	cmp	ebx, ecx
	jl	SHORT $LN24@q_edge_are@2

; 1233 :      for ( j = 0 ; j < edge_ctrl ; j++ )

	mov	ebx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR tv467[ebp]
	mov	esi, DWORD PTR tv482[ebp]
$LN5@q_edge_are@2:

; 1229 : 
; 1230 :   /* main integral over edge */
; 1231 :   area = 0.0;
; 1232 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	inc	DWORD PTR _i$[ebp]
	add	DWORD PTR tv465[ebp], 8
	add	edx, 4
	mov	DWORD PTR tv467[ebp], edx
	cmp	DWORD PTR _i$[ebp], ecx
	jl	SHORT $LN6@q_edge_are@2
$LN4@q_edge_are@2:
	pop	edi
	pop	esi
	pop	ebx

; 1238 :         }
; 1239 : 
; 1240 :   return area;
; 1241 : } // end q_edge_area_q_grad()

	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_area_q_grad ENDP
_TEXT	ENDS
PUBLIC	_q_edge_area_q_hess
; Function compile flags: /Ogtp
;	COMDAT _q_edge_area_q_hess
_TEXT	SEGMENT
_x$ = -36						; size = 4
tv652 = -32						; size = 4
tv459 = -28						; size = 4
tv464 = -24						; size = 4
tv657 = -20						; size = 4
_h$ = -16						; size = 4
tv600 = -12						; size = 4
_g$ = -8						; size = 4
tv453 = -4						; size = 4
_i$ = 8							; size = 4
_e_info$ = 8						; size = 4
_q_edge_area_q_hess PROC				; COMDAT

; 1252 : { REAL **x,**g,****h;

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1253 :   REAL area;
; 1254 :   int i,j;
; 1255 : 
; 1256 :   x = e_info->x;

	mov	eax, DWORD PTR _e_info$[ebp]

; 1257 :   g = e_info->grad;
; 1258 :   h = e_info->hess;
; 1259 : 
; 1260 :   /* main integral over edge */
; 1261 :   area = 0.0;

	fldz
	mov	ecx, DWORD PTR [eax+1336]
	fld	ST(0)
	push	ebx
	mov	ebx, DWORD PTR [eax+1340]
	lea	edx, DWORD PTR [eax+416]

; 1262 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	eax, DWORD PTR _edge_ctrl
	mov	DWORD PTR _x$[ebp], edx
	mov	DWORD PTR _g$[ebp], ecx
	mov	DWORD PTR _h$[ebp], ebx
	mov	DWORD PTR _i$[ebp], 0
	test	eax, eax
	jle	$LN18@q_edge_are@3
	push	esi
	mov	esi, ecx
	sub	esi, edx
	sub	ebx, edx
	push	edi
	mov	edi, edx
	mov	DWORD PTR tv600[ebp], OFFSET _scoeff
	mov	DWORD PTR tv652[ebp], esi
	mov	DWORD PTR tv657[ebp], ebx
$LN15@q_edge_are@3:

; 1263 :      for ( j = 0 ; j < edge_ctrl ; j++ )

	xor	ebx, ebx
	test	eax, eax
	jle	$LN6@q_edge_are@3
	mov	eax, DWORD PTR tv600[ebp]
	sub	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv453[ebp], eax
	mov	eax, DWORD PTR _h$[ebp]
	sub	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv459[ebp], edx
	mov	DWORD PTR tv464[ebp], eax
$LN4@q_edge_are@3:

; 1264 :         { REAL v = scoeff[j][i];

	mov	eax, DWORD PTR tv453[ebp]
	fld	QWORD PTR [eax]

; 1265 :           if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN26@q_edge_are@3

; 1266 :           area += v*x[i][0]*x[j][1];

	mov	edx, DWORD PTR [edx+ecx]
	fld	ST(0)
	mov	eax, DWORD PTR [edi]
	fmul	QWORD PTR [eax]

; 1267 :           g[i][0] += v*x[j][1];

	mov	esi, DWORD PTR [esi+edi]
	fmul	QWORD PTR [edx+8]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edx+8]

; 1268 :           g[j][1] += v*x[i][0];

	mov	edx, DWORD PTR [ecx]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]

; 1269 :           h[i][j][0][1] += v;
; 1270 :           h[j][i][1][0] += v;

	mov	esi, DWORD PTR tv652[ebp]
	fld	ST(0)
	fmul	QWORD PTR [eax]
	fadd	QWORD PTR [edx+8]
	fstp	QWORD PTR [edx+8]
	mov	edx, DWORD PTR tv657[ebp]
	mov	eax, DWORD PTR [edx+edi]
	mov	edx, DWORD PTR [eax+ebx*4]
	fld	ST(0)
	mov	eax, DWORD PTR [edx]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	mov	eax, DWORD PTR tv464[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+4]
	fadd	QWORD PTR [eax]
	mov	edx, DWORD PTR tv459[ebp]
	fstp	QWORD PTR [eax]
	jmp	SHORT $LN3@q_edge_are@3
$LN26@q_edge_are@3:
	fstp	ST(0)
$LN3@q_edge_are@3:

; 1263 :      for ( j = 0 ; j < edge_ctrl ; j++ )

	add	DWORD PTR tv453[ebp], 24		; 00000018H
	inc	ebx
	add	ecx, 4
	cmp	ebx, DWORD PTR _edge_ctrl
	jl	SHORT $LN4@q_edge_are@3
	mov	edx, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR _edge_ctrl
$LN6@q_edge_are@3:

; 1262 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	inc	DWORD PTR _i$[ebp]
	add	DWORD PTR tv600[ebp], 8
	add	edi, 4
	cmp	DWORD PTR _i$[ebp], eax
	jl	$LN15@q_edge_are@3
	pop	edi
	pop	esi
$LN18@q_edge_are@3:
	fstp	ST(1)
	pop	ebx

; 1271 :         }
; 1272 : 
; 1273 :   return area;
; 1274 : } // end q_edge_area_q_hess()

	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_area_q_hess ENDP
_TEXT	ENDS
PUBLIC	_q_edge_area_lagrange
; Function compile flags: /Ogtp
;	COMDAT _q_edge_area_lagrange
_TEXT	SEGMENT
$T92299 = -24						; size = 4
tv1405 = -20						; size = 4
_k$ = -20						; size = 4
_gl$ = -16						; size = 4
tv1118 = -12						; size = 4
tv1509 = -8						; size = 4
_m$ = -4						; size = 4
_e_info$ = 8						; size = 4
_q_edge_area_lagrange PROC				; COMDAT

; 1289 : { REAL **x;

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1290 :   REAL area;
; 1291 :   struct gauss_lag *gl = &gauss_lagrange[web.dimension][web.gauss1D_order];

	mov	eax, DWORD PTR _web+620

; 1292 :   int ctrl = web.skel[EDGE].ctrlpts;
; 1293 :   int m,k;
; 1294 : 
; 1295 :   x = e_info->x;
; 1296 : 
; 1297 :   /* main integral over edge */
; 1298 :   area = 0.0;

	fldz
	push	ebx
	fld	ST(0)
	mov	ebx, DWORD PTR _web+1592
	shl	ebx, 5
	add	ebx, DWORD PTR _gauss_lagrange[eax*4]

; 1299 :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	ecx, ecx
	mov	eax, DWORD PTR [ebx+4]
	push	esi
	mov	esi, DWORD PTR _web+120
	mov	DWORD PTR _gl$[ebp], ebx
	mov	DWORD PTR _m$[ebp], ecx

; 1302 :      { y += gl->gpoly[m][k]*x[k][1];

	mov	DWORD PTR $T92299[ebp], eax
	test	eax, eax
	jle	$LN21@q_edge_are@4

; 1290 :   REAL area;
; 1291 :   struct gauss_lag *gl = &gauss_lagrange[web.dimension][web.gauss1D_order];

	mov	edx, DWORD PTR [ebx+12]
	push	edi
	mov	DWORD PTR tv1509[ebp], edx
$LN18@q_edge_are@4:

; 1300 :   { REAL y,dx;
; 1301 :      for ( y = 0.0, dx = 0.0, k = 0 ; k < ctrl ; k++ )

	xor	eax, eax
	fld	ST(1)
	fld	ST(2)
	cmp	esi, 4
	jl	$LC14@q_edge_are@4
	mov	eax, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e_info$[ebp]
	add	esi, -4					; fffffffcH
	lea	edx, DWORD PTR [ebx+24]

; 1303 :         dx += gl->gpolypart[m][0][k]*x[k][0];

	sub	ebx, edi
	shr	esi, 2
	add	ecx, 424				; 000001a8H
	inc	esi
	lea	eax, DWORD PTR [edi+16]
	lea	edi, DWORD PTR [esi*4]
	mov	DWORD PTR tv1118[ebp], ebx
	mov	DWORD PTR _k$[ebp], edi
$LN15@q_edge_are@4:

; 1302 :      { y += gl->gpoly[m][k]*x[k][1];

	mov	edi, DWORD PTR [ecx-8]
	fld	QWORD PTR [eax-16]
	fmul	QWORD PTR [edi+8]
	mov	ebx, DWORD PTR [ecx-4]

; 1303 :         dx += gl->gpolypart[m][0][k]*x[k][0];

	add	eax, 32					; 00000020H
	add	edx, 32					; 00000020H
	faddp	ST(2), ST(0)
	add	ecx, 16					; 00000010H
	dec	esi
	fld	QWORD PTR [eax-40]
	fmul	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ecx-16]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ecx-12]
	fmul	QWORD PTR [eax-32]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [eax-24]
	fmul	QWORD PTR [ebx+8]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edx-56]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR [ecx-20]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx-48]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR tv1118[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax+edi-32]
	mov	edi, DWORD PTR [ecx-16]
	fmul	QWORD PTR [edi]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx-32]
	fmul	QWORD PTR [ebx]
	faddp	ST(1), ST(0)
	jne	SHORT $LN15@q_edge_are@4

; 1300 :   { REAL y,dx;
; 1301 :      for ( y = 0.0, dx = 0.0, k = 0 ; k < ctrl ; k++ )

	mov	ebx, DWORD PTR _gl$[ebp]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
$LC14@q_edge_are@4:
	mov	esi, DWORD PTR _web+120
	cmp	eax, esi
	jge	SHORT $LN19@q_edge_are@4
	mov	edx, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	esi, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR [edx]
	mov	esi, DWORD PTR [esi+ecx*4]
	sub	esi, edi
	lea	edx, DWORD PTR [edi+eax*8]
	mov	DWORD PTR tv1405[ebp], esi
	jmp	SHORT $LC3@q_edge_are@4
$LN17@q_edge_are@4:
	mov	esi, DWORD PTR tv1405[ebp]
$LC3@q_edge_are@4:

; 1302 :      { y += gl->gpoly[m][k]*x[k][1];

	mov	edi, DWORD PTR _e_info$[ebp]
	fld	QWORD PTR [esi+edx]
	mov	edi, DWORD PTR [edi+eax*4+416]
	fmul	QWORD PTR [edi+8]
	mov	esi, DWORD PTR _web+120
	inc	eax
	add	edx, 8
	faddp	ST(2), ST(0)

; 1303 :         dx += gl->gpolypart[m][0][k]*x[k][0];

	fld	QWORD PTR [edx-8]
	fmul	QWORD PTR [edi]
	faddp	ST(1), ST(0)
	cmp	eax, esi
	jl	SHORT $LN17@q_edge_are@4
$LN19@q_edge_are@4:

; 1304 :      }
; 1305 :      area -= gl->gausswt[m]*y*dx;

	mov	eax, DWORD PTR tv1509[ebp]
	fld	QWORD PTR [eax]
	inc	ecx
	fmulp	ST(2), ST(0)
	add	eax, 8
	mov	DWORD PTR _m$[ebp], ecx
	mov	DWORD PTR tv1509[ebp], eax
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	cmp	ecx, DWORD PTR $T92299[ebp]
	jl	$LN18@q_edge_are@4
	pop	edi
$LN21@q_edge_are@4:
	pop	esi

; 1299 :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	fstp	ST(1)
	pop	ebx

; 1306 :   }
; 1307 :      
; 1308 :   return area;
; 1309 : } // end q_edge_area_lagrange()

	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_area_lagrange ENDP
_TEXT	ENDS
PUBLIC	_q_edge_area_lagrange_grad
; Function compile flags: /Ogtp
;	COMDAT _q_edge_area_lagrange_grad
_TEXT	SEGMENT
tv2075 = -24						; size = 4
_k$ = -24						; size = 4
tv2106 = -20						; size = 4
tv1915 = -20						; size = 4
tv1806 = -16						; size = 4
_g$ = -12						; size = 4
tv533 = -8						; size = 4
_ctrl$ = -4						; size = 4
_e_info$ = 8						; size = 4
_q_edge_area_lagrange_grad PROC				; COMDAT

; 1319 : { REAL **x,**g;

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1320 :   REAL area;
; 1321 :   int m,k;
; 1322 :   struct gauss_lag *gl = &gauss_lagrange[web.dimension][web.gauss1D_order];

	mov	eax, DWORD PTR _web+1592

; 1323 :   int ctrl = web.skel[EDGE].ctrlpts;
; 1324 : 
; 1325 :   x = e_info->x;
; 1326 :   g = e_info->grad;
; 1327 : 
; 1328 :   /* main integral over edge */
; 1329 :   area = 0.0;

	fldz
	mov	ecx, DWORD PTR _web+620
	fld	ST(0)
	mov	edx, DWORD PTR _e_info$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _gauss_lagrange[ecx*4]
	mov	ecx, DWORD PTR [edx+1336]
	mov	DWORD PTR _g$[ebp], ecx
	push	ebx
	mov	ebx, DWORD PTR _web+120

; 1330 :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	ecx, ecx
	mov	DWORD PTR _ctrl$[ebp], ebx
	cmp	DWORD PTR [eax+4], ecx
	jle	$LN30@q_edge_are@5
	push	esi
	push	edi
$LN27@q_edge_are@5:

; 1331 :   { REAL y,dx;
; 1332 :      for ( y = 0.0, dx = 0.0, k = 0 ; k < ctrl ; k++ )

	xor	edx, edx
	fld	ST(1)
	fld	ST(2)
	cmp	ebx, 4
	jl	$LC19@q_edge_are@5
	mov	edx, DWORD PTR [eax+20]
	mov	edi, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [edx]
	mov	esi, DWORD PTR _e_info$[ebp]
	lea	edx, DWORD PTR [ebx+24]

; 1334 :         dx += gl->gpolypart[m][0][k]*x[k][0];

	sub	ebx, edi
	mov	DWORD PTR tv1806[ebp], edx
	lea	edx, DWORD PTR [edi+16]
	mov	edi, DWORD PTR _ctrl$[ebp]
	add	edi, -4					; fffffffcH
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv533[ebp], edi
	add	edi, edi
	add	esi, 424				; 000001a8H
	add	edi, edi
	mov	DWORD PTR _k$[ebp], edi
	mov	edi, DWORD PTR tv1806[ebp]
	mov	DWORD PTR tv1915[ebp], ebx
$LN20@q_edge_are@5:

; 1333 :      { y += gl->gpoly[m][k]*x[k][1];

	mov	ebx, DWORD PTR [esi-8]
	fld	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [esi-4]
	fmul	QWORD PTR [edx-16]

; 1334 :         dx += gl->gpolypart[m][0][k]*x[k][0];

	add	edx, 32					; 00000020H
	add	edi, 32					; 00000020H
	add	esi, 16					; 00000010H
	dec	DWORD PTR tv533[ebp]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [esi-16]
	fmul	QWORD PTR [edx-40]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [esi-12]
	fmul	QWORD PTR [edx-32]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [esi-24]
	fmul	QWORD PTR [edx-24]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edi-56]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [esi-20]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi-48]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv1915[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+edx-32]
	mov	ebx, DWORD PTR [esi-16]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [esi-12]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi-32]
	fmul	QWORD PTR [ebx]
	faddp	ST(1), ST(0)
	jne	SHORT $LN20@q_edge_are@5

; 1331 :   { REAL y,dx;
; 1332 :      for ( y = 0.0, dx = 0.0, k = 0 ; k < ctrl ; k++ )

	mov	ebx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
$LC19@q_edge_are@5:
	cmp	edx, ebx
	jge	SHORT $LN18@q_edge_are@5
	mov	esi, DWORD PTR [eax+24]
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	edi, DWORD PTR [esi]
	lea	esi, DWORD PTR [edi+edx*8]
	mov	DWORD PTR tv2075[ebp], esi
	mov	esi, DWORD PTR [eax+20]
	mov	esi, DWORD PTR [esi+ecx*4]
	sub	esi, edi
	mov	edi, DWORD PTR tv2075[ebp]
	mov	DWORD PTR tv2106[ebp], esi
	jmp	SHORT $LC6@q_edge_are@5
$LN26@q_edge_are@5:
	mov	esi, DWORD PTR tv2106[ebp]
$LC6@q_edge_are@5:

; 1333 :      { y += gl->gpoly[m][k]*x[k][1];

	fld	QWORD PTR [esi+edi]
	mov	esi, DWORD PTR _e_info$[ebp]
	mov	esi, DWORD PTR [esi+edx*4+416]
	fmul	QWORD PTR [esi+8]
	inc	edx
	add	edi, 8
	faddp	ST(2), ST(0)

; 1334 :         dx += gl->gpolypart[m][0][k]*x[k][0];

	fld	QWORD PTR [edi-8]
	fmul	QWORD PTR [esi]
	faddp	ST(1), ST(0)
	cmp	edx, ebx
	jl	SHORT $LN26@q_edge_are@5
$LN18@q_edge_are@5:

; 1335 :      }
; 1336 :      area -= gl->gausswt[m]*y*dx;

	mov	edx, DWORD PTR [eax+12]
	fld	QWORD PTR [edx+ecx*8]

; 1337 :      for ( k = 0 ; k < ctrl ; k++ )

	xor	edx, edx
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(1)
	fsubp	ST(3), ST(0)
	cmp	ebx, 4
	jl	$LC22@q_edge_are@5

; 1335 :      }
; 1336 :      area -= gl->gausswt[m]*y*dx;

	mov	edi, DWORD PTR _g$[ebp]
	add	edi, 8

; 1337 :      for ( k = 0 ; k < ctrl ; k++ )

$LN23@q_edge_are@5:

; 1338 :      { g[k][0] -= gl->gausswt[m]*y*gl->gpolypart[m][0][k];

	mov	ebx, DWORD PTR [eax+12]
	fld	QWORD PTR [ebx+ecx*8]
	mov	esi, DWORD PTR [eax+24]
	mov	esi, DWORD PTR [esi+ecx*4]
	fmul	ST(0), ST(2)
	mov	esi, DWORD PTR [esi]

; 1339 :         g[k][1] -= gl->gausswt[m]*dx*gl->gpoly[m][k];

	add	edx, 4
	fmul	QWORD PTR [esi+edx*8-32]
	mov	esi, DWORD PTR [edi-8]
	add	edi, 16					; 00000010H
	fsubr	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	mov	ebx, DWORD PTR [eax+12]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [eax+20]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+edx*8-32]
	fsubr	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi+8]
	mov	ebx, DWORD PTR [eax+12]
	fld	QWORD PTR [ebx+ecx*8]
	mov	esi, DWORD PTR [eax+24]
	mov	esi, DWORD PTR [esi+ecx*4]
	fmul	ST(0), ST(2)
	mov	esi, DWORD PTR [esi]
	fmul	QWORD PTR [esi+edx*8-24]
	mov	esi, DWORD PTR [edi-20]
	fsubr	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	mov	ebx, DWORD PTR [eax+12]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [eax+20]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+edx*8-24]
	fsubr	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi+8]
	mov	ebx, DWORD PTR [eax+12]
	fld	QWORD PTR [ebx+ecx*8]
	mov	esi, DWORD PTR [eax+24]
	mov	esi, DWORD PTR [esi+ecx*4]
	fmul	ST(0), ST(2)
	mov	esi, DWORD PTR [esi]
	fmul	QWORD PTR [esi+edx*8-16]
	mov	esi, DWORD PTR [edi-16]
	fsubr	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	mov	ebx, DWORD PTR [eax+12]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [eax+20]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+edx*8-16]
	fsubr	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi+8]
	mov	ebx, DWORD PTR [eax+12]
	fld	QWORD PTR [ebx+ecx*8]
	mov	esi, DWORD PTR [eax+24]
	mov	esi, DWORD PTR [esi+ecx*4]
	fmul	ST(0), ST(2)
	mov	esi, DWORD PTR [esi]
	fmul	QWORD PTR [esi+edx*8-8]
	mov	esi, DWORD PTR [edi-12]
	fsubr	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	mov	ebx, DWORD PTR [eax+12]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [eax+20]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+edx*8-8]
	mov	ebx, DWORD PTR _ctrl$[ebp]
	fsubr	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi+8]
	lea	esi, DWORD PTR [ebx-3]
	cmp	edx, esi
	jl	$LN23@q_edge_are@5
$LC22@q_edge_are@5:

; 1337 :      for ( k = 0 ; k < ctrl ; k++ )

	cmp	edx, ebx
	jge	SHORT $LN50@q_edge_are@5
$LN25@q_edge_are@5:

; 1338 :      { g[k][0] -= gl->gausswt[m]*y*gl->gpolypart[m][0][k];

	mov	esi, DWORD PTR _g$[ebp]
	mov	ebx, DWORD PTR [esi+edx*4]
	mov	edi, DWORD PTR [eax+12]
	mov	esi, DWORD PTR [eax+24]
	fld	QWORD PTR [edi+ecx*8]
	mov	esi, DWORD PTR [esi+ecx*4]
	fmul	ST(0), ST(2)
	mov	esi, DWORD PTR [esi]
	inc	edx
	fmul	QWORD PTR [esi+edx*8-8]
	fsubr	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]

; 1339 :         g[k][1] -= gl->gausswt[m]*dx*gl->gpoly[m][k];

	mov	esi, DWORD PTR [eax+12]
	fld	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR [eax+20]
	mov	esi, DWORD PTR [esi+ecx*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [esi+edx*8-8]
	fsubr	QWORD PTR [ebx+8]
	fstp	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR _ctrl$[ebp]
	cmp	edx, ebx
	jl	SHORT $LN25@q_edge_are@5
$LN50@q_edge_are@5:

; 1330 :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	inc	ecx

; 1337 :      for ( k = 0 ; k < ctrl ; k++ )

	fstp	ST(1)
	fstp	ST(0)
	cmp	ecx, DWORD PTR [eax+4]
	jl	$LN27@q_edge_are@5
	pop	edi
	pop	esi
$LN30@q_edge_are@5:

; 1330 :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	fstp	ST(1)
	pop	ebx

; 1340 :      }
; 1341 :   }
; 1342 : 
; 1343 :   return area;
; 1344 : } // end q_edge_area_lagrange_grad()

	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_area_lagrange_grad ENDP
_TEXT	ENDS
PUBLIC	_q_edge_area_lagrange_hess
; Function compile flags: /Ogtp
;	COMDAT _q_edge_area_lagrange_hess
_TEXT	SEGMENT
tv4911 = -36						; size = 4
tv4757 = -36						; size = 4
tv4111 = -36						; size = 4
tv3914 = -36						; size = 4
_h$ = -32						; size = 4
tv4383 = -28						; size = 4
tv3293 = -28						; size = 4
tv3102 = -28						; size = 4
_kk$ = -24						; size = 4
_g$ = -20						; size = 4
_ctrl$ = -16						; size = 4
tv4348 = -12						; size = 4
tv1397 = -12						; size = 4
tv4090 = -8						; size = 4
tv3761 = -8						; size = 4
tv2993 = -8						; size = 4
_k$ = -4						; size = 4
_e_info$ = 8						; size = 4
_q_edge_area_lagrange_hess PROC				; COMDAT

; 1355 : { REAL **x,**g,****h;

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1356 :   REAL area;
; 1357 :   int m,k,kk;
; 1358 :   struct gauss_lag *gl = &gauss_lagrange[web.dimension][web.gauss1D_order];

	mov	eax, DWORD PTR _web+1592

; 1359 :   int ctrl = web.skel[EDGE].ctrlpts;
; 1360 : 
; 1361 :   x = e_info->x;
; 1362 :   g = e_info->grad;
; 1363 :   h = e_info->hess;
; 1364 : 
; 1365 :   /* main integral over edge */
; 1366 :   area = 0.0;

	fldz
	mov	ecx, DWORD PTR _web+620
	fld	ST(0)
	push	ebx
	mov	ebx, DWORD PTR _web+120
	shl	eax, 5
	add	eax, DWORD PTR _gauss_lagrange[ecx*4]
	push	esi
	mov	esi, DWORD PTR _e_info$[ebp]
	mov	ecx, DWORD PTR [esi+1340]
	mov	edx, DWORD PTR [esi+1336]
	mov	DWORD PTR _h$[ebp], ecx

; 1367 :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	ecx, ecx
	mov	DWORD PTR _ctrl$[ebp], ebx
	mov	DWORD PTR _g$[ebp], edx
	cmp	DWORD PTR [eax+4], ecx
	jle	$LN33@q_edge_are@6
	push	edi
	jmp	SHORT $LN12@q_edge_are@6
$LN31@q_edge_are@6:
	mov	esi, DWORD PTR _e_info$[ebp]
$LN12@q_edge_are@6:

; 1368 :   { REAL y,dx;
; 1369 :      for ( y = 0.0, dx = 0.0, k = 0 ; k < ctrl ; k++ )

	xor	edx, edx
	fld	ST(1)
	fld	ST(2)
	mov	DWORD PTR _k$[ebp], edx
	cmp	ebx, 4
	jl	$LC24@q_edge_are@6
	mov	edx, DWORD PTR [eax+20]
	mov	edi, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [edx]
	lea	edx, DWORD PTR [ebx+24]

; 1371 :         dx += gl->gpolypart[m][0][k]*x[k][0];

	sub	ebx, edi
	mov	DWORD PTR tv3102[ebp], ebx
	mov	ebx, DWORD PTR _ctrl$[ebp]
	mov	DWORD PTR tv2993[ebp], edx
	lea	edx, DWORD PTR [edi+16]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv1397[ebp], edi
	add	edi, edi
	add	esi, 424				; 000001a8H
	add	edi, edi
	mov	DWORD PTR _k$[ebp], edi
$LN25@q_edge_are@6:

; 1370 :      { y += gl->gpoly[m][k]*x[k][1];

	mov	edi, DWORD PTR [esi-8]
	fld	QWORD PTR [edx-16]
	fmul	QWORD PTR [edi+8]
	mov	edi, DWORD PTR [esi-4]

; 1371 :         dx += gl->gpolypart[m][0][k]*x[k][0];

	add	edx, 32					; 00000020H
	add	esi, 16					; 00000010H
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edx-40]
	fmul	QWORD PTR [edi+8]
	mov	edi, DWORD PTR [esi-16]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edi+8]
	mov	edi, DWORD PTR [esi-12]
	fmul	QWORD PTR [edx-32]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edx-24]
	fmul	QWORD PTR [edi+8]
	mov	edi, DWORD PTR tv2993[ebp]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edi-24]
	mov	edi, DWORD PTR [esi-24]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR tv2993[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi-16]
	mov	edi, DWORD PTR [esi-20]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR tv3102[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx+edi-32]
	mov	edi, DWORD PTR [esi-16]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR tv2993[ebp]
	add	DWORD PTR tv2993[ebp], 32		; 00000020H
	dec	DWORD PTR tv1397[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi]
	mov	edi, DWORD PTR [esi-12]
	fmul	QWORD PTR [edi]
	faddp	ST(1), ST(0)
	jne	SHORT $LN25@q_edge_are@6

; 1368 :   { REAL y,dx;
; 1369 :      for ( y = 0.0, dx = 0.0, k = 0 ; k < ctrl ; k++ )

	mov	edx, DWORD PTR _k$[ebp]
$LC24@q_edge_are@6:
	cmp	edx, ebx
	jge	SHORT $LN23@q_edge_are@6
	mov	esi, DWORD PTR [eax+24]
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR [esi]
	mov	edi, DWORD PTR [eax+20]
	mov	edi, DWORD PTR [edi+ecx*4]
	sub	edi, esi
	lea	edx, DWORD PTR [esi+edx*8]
	mov	esi, DWORD PTR _k$[ebp]
	mov	DWORD PTR tv3293[ebp], edi
$LC9@q_edge_are@6:

; 1370 :      { y += gl->gpoly[m][k]*x[k][1];

	mov	edi, DWORD PTR _e_info$[ebp]
	mov	esi, DWORD PTR [edi+esi*4+416]
	mov	edi, DWORD PTR tv3293[ebp]
	fld	QWORD PTR [edi+edx]
	add	edx, 8
	fmul	QWORD PTR [esi+8]
	faddp	ST(2), ST(0)

; 1371 :         dx += gl->gpolypart[m][0][k]*x[k][0];

	fld	QWORD PTR [edx-8]
	fmul	QWORD PTR [esi]
	mov	esi, DWORD PTR _k$[ebp]
	inc	esi
	mov	DWORD PTR _k$[ebp], esi
	faddp	ST(1), ST(0)
	cmp	esi, ebx
	jl	SHORT $LC9@q_edge_are@6
$LN23@q_edge_are@6:

; 1372 :      }
; 1373 :      area -= gl->gausswt[m]*y*dx;

	mov	edx, DWORD PTR [eax+12]
	fld	QWORD PTR [edx+ecx*8]

; 1374 :      for ( k = 0 ; k < ctrl ; k++ )

	xor	edi, edi
	fmul	ST(0), ST(2)
	mov	DWORD PTR _k$[ebp], edi
	fmul	ST(0), ST(1)
	fsubp	ST(3), ST(0)
	test	ebx, ebx
	jle	$LN60@q_edge_are@6

; 1372 :      }
; 1373 :      area -= gl->gausswt[m]*y*dx;

	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv4348[ebp], edx

; 1374 :      for ( k = 0 ; k < ctrl ; k++ )

	mov	edx, DWORD PTR _h$[ebp]
	sub	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv4383[ebp], edx
$LN6@q_edge_are@6:

; 1375 :      { g[k][0] -= gl->gausswt[m]*y*gl->gpolypart[m][0][k];

	mov	esi, DWORD PTR [eax+12]
	fld	QWORD PTR [esi+ecx*8]
	mov	edx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [edx+ecx*4]
	fmul	ST(0), ST(2)
	mov	edx, DWORD PTR [edx]
	fmul	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR tv4348[ebp]
	mov	edx, DWORD PTR [edx]
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]

; 1376 :         g[k][1] -= gl->gausswt[m]*dx*gl->gpoly[m][k];

	mov	esi, DWORD PTR [eax+12]
	fld	QWORD PTR [esi+ecx*8]
	mov	edx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [edx+ecx*4]
	fmul	ST(0), ST(1)
	mov	esi, DWORD PTR tv4348[ebp]
	fmul	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR [esi]
	fsubr	QWORD PTR [edx+8]
	fstp	QWORD PTR [edx+8]

; 1377 :         for ( kk = 0 ; kk < ctrl ; kk++ )

	xor	edx, edx
	mov	DWORD PTR _kk$[ebp], edx
	cmp	ebx, 4
	jl	$LN30@q_edge_are@6

; 1375 :      { g[k][0] -= gl->gausswt[m]*y*gl->gpolypart[m][0][k];

	mov	edi, DWORD PTR tv4383[ebp]
	mov	esi, DWORD PTR [edi+esi]
	add	esi, 8
	mov	DWORD PTR tv3761[ebp], esi

; 1377 :         for ( kk = 0 ; kk < ctrl ; kk++ )

$LN28@q_edge_are@6:

; 1378 :         { h[k][kk][0][1] -= gl->gausswt[m]*gl->gpoly[m][kk]*gl->gpolypart[m][0][k];

	mov	edi, DWORD PTR [esi-8]
	mov	edi, DWORD PTR [edi]
	mov	DWORD PTR tv4757[ebp], edi
	mov	edi, DWORD PTR [eax+20]
	mov	edi, DWORD PTR [edi+ecx*4]
	fld	QWORD PTR [edi+edx*8]
	mov	ebx, DWORD PTR [eax+12]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	edi, DWORD PTR [eax+24]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [edi]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR tv4757[ebp]
	fsubr	QWORD PTR [edi+8]
	fstp	QWORD PTR [edi+8]

; 1379 :           h[k][kk][1][0] -= gl->gausswt[m]*gl->gpolypart[m][0][kk]*gl->gpoly[m][k];

	mov	edi, DWORD PTR [esi-8]
	mov	edi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [eax+12]
	mov	DWORD PTR tv3914[ebp], edi
	mov	edi, DWORD PTR [eax+24]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR [eax+20]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	ebx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR [esi-4]
	fmul	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR tv3914[ebp]
	mov	esi, DWORD PTR [esi]
	fsubr	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [eax+20]
	mov	edi, DWORD PTR [edi+ecx*4]
	fld	QWORD PTR [edi+edx*8+8]
	mov	ebx, DWORD PTR [eax+12]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	edi, DWORD PTR [eax+24]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [edi]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [edi+ebx*8]
	fsubr	QWORD PTR [esi+8]
	mov	esi, DWORD PTR tv3761[ebp]
	mov	esi, DWORD PTR [esi-4]
	mov	edi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	fstp	QWORD PTR [edi+8]
	mov	edi, DWORD PTR [eax+24]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+edx*8+8]
	mov	ebx, DWORD PTR [eax+12]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	edi, DWORD PTR [eax+20]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR tv3761[ebp]
	lea	edx, DWORD PTR [edx*8+24]
	fsubr	QWORD PTR [esi]
	mov	esi, DWORD PTR [edi-4]
	mov	esi, DWORD PTR [esi+4]
	fstp	QWORD PTR [esi]
	mov	esi, DWORD PTR [edi]
	mov	edi, DWORD PTR [eax+20]
	mov	edi, DWORD PTR [edi+ecx*4]
	fld	QWORD PTR [edi+edx-8]
	mov	ebx, DWORD PTR [eax+12]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	edi, DWORD PTR [eax+24]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [edi]
	mov	ebx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR [esi]
	fmul	QWORD PTR [edi+ebx*8]
	fsubr	QWORD PTR [esi+8]
	mov	esi, DWORD PTR tv3761[ebp]
	mov	esi, DWORD PTR [esi]

; 1378 :         { h[k][kk][0][1] -= gl->gausswt[m]*gl->gpoly[m][kk]*gl->gpolypart[m][0][k];

	mov	edi, DWORD PTR [esi]
	fstp	QWORD PTR [edi+8]

; 1379 :           h[k][kk][1][0] -= gl->gausswt[m]*gl->gpolypart[m][0][kk]*gl->gpoly[m][k];

	mov	edi, DWORD PTR [eax+24]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+edx-8]
	mov	ebx, DWORD PTR [eax+12]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [eax+20]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR tv3761[ebp]
	fsubr	QWORD PTR [esi]
	mov	esi, DWORD PTR [edi]
	mov	esi, DWORD PTR [esi+4]
	fstp	QWORD PTR [esi]
	mov	esi, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [eax+20]
	mov	edi, DWORD PTR [edi+ecx*4]
	fld	QWORD PTR [edi+edx]
	mov	ebx, DWORD PTR [eax+12]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	edi, DWORD PTR [eax+24]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [edi]
	mov	esi, DWORD PTR [esi]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [edi+ebx*8]
	fsubr	QWORD PTR [esi+8]
	mov	esi, DWORD PTR tv3761[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	fstp	QWORD PTR [edi+8]
	mov	edi, DWORD PTR [eax+24]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+edx]
	mov	ebx, DWORD PTR [eax+12]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	edx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	edi, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [edx+edi*8]
	mov	ebx, DWORD PTR _ctrl$[ebp]
	add	ebx, -3					; fffffffdH
	fsubr	QWORD PTR [esi]
	mov	esi, DWORD PTR tv3761[ebp]
	mov	edx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edx+4]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR _kk$[ebp]
	add	edx, 4
	add	esi, 16					; 00000010H
	mov	DWORD PTR _kk$[ebp], edx
	mov	DWORD PTR tv3761[ebp], esi
	cmp	edx, ebx
	jl	$LN28@q_edge_are@6
	mov	ebx, DWORD PTR _ctrl$[ebp]
$LN30@q_edge_are@6:

; 1377 :         for ( kk = 0 ; kk < ctrl ; kk++ )

	cmp	edx, ebx
	jge	SHORT $LN5@q_edge_are@6
	mov	esi, DWORD PTR tv4383[ebp]
	mov	ebx, DWORD PTR tv4348[ebp]
	mov	esi, DWORD PTR [esi+ebx]
	lea	esi, DWORD PTR [esi+edx*4]
	mov	DWORD PTR tv4090[ebp], esi
$LC3@q_edge_are@6:

; 1378 :         { h[k][kk][0][1] -= gl->gausswt[m]*gl->gpoly[m][kk]*gl->gpolypart[m][0][k];

	mov	esi, DWORD PTR tv4090[ebp]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi]
	mov	ebx, DWORD PTR [eax+12]
	mov	DWORD PTR tv4911[ebp], esi
	mov	esi, DWORD PTR [eax+20]
	mov	esi, DWORD PTR [esi+ecx*4]
	fld	QWORD PTR [esi+edx*8]
	mov	esi, DWORD PTR [eax+24]
	mov	esi, DWORD PTR [esi+ecx*4]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	esi, DWORD PTR [esi]
	inc	edx
	fmul	QWORD PTR [esi+edi*8]
	mov	esi, DWORD PTR tv4911[ebp]
	fsubr	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi+8]

; 1379 :           h[k][kk][1][0] -= gl->gausswt[m]*gl->gpolypart[m][0][kk]*gl->gpoly[m][k];

	mov	esi, DWORD PTR tv4090[ebp]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [eax+12]
	add	DWORD PTR tv4090[ebp], 4
	mov	DWORD PTR tv4111[ebp], esi
	mov	esi, DWORD PTR [eax+24]
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR [esi]
	fld	QWORD PTR [esi+edx*8-8]
	mov	esi, DWORD PTR [eax+20]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	ebx, DWORD PTR _ctrl$[ebp]
	fmul	QWORD PTR [esi+edi*8]
	mov	esi, DWORD PTR tv4111[ebp]
	fsubr	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	cmp	edx, ebx
	jl	SHORT $LC3@q_edge_are@6
$LN5@q_edge_are@6:

; 1374 :      for ( k = 0 ; k < ctrl ; k++ )

	add	DWORD PTR tv4348[ebp], 4
	inc	edi
	mov	DWORD PTR _k$[ebp], edi
	cmp	edi, ebx
	jl	$LN6@q_edge_are@6
$LN60@q_edge_are@6:

; 1367 :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	inc	ecx

; 1377 :         for ( kk = 0 ; kk < ctrl ; kk++ )

	fstp	ST(1)
	fstp	ST(0)
	cmp	ecx, DWORD PTR [eax+4]
	jl	$LN31@q_edge_are@6
	pop	edi
$LN33@q_edge_are@6:
	pop	esi

; 1367 :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	fstp	ST(1)
	pop	ebx

; 1380 :         }
; 1381 :      }
; 1382 :   }
; 1383 : 
; 1384 :   return area;
; 1385 : } // end q_edge_area_lagrange_hess()

	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_area_lagrange_hess ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_q_edge_torus_area_q
EXTRN	_mat_mul_tr:PROC
; Function compile flags: /Ogtp
;	COMDAT _q_edge_torus_area_q
_TEXT	SEGMENT
_uqXvS$ = -180						; size = 12
_e_info$GSCopy$ = -168					; size = 4
tv958 = -164						; size = 4
_area$ = -160						; size = 8
tv903 = -156						; size = 4
tv132 = -156						; size = 4
tv620 = -152						; size = 4
_uxJ$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_q_edge_torus_area_q PROC				; COMDAT

; 1543 : { REAL **x;

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _e_info$[ebp]
	push	esi
	push	edi

; 1544 :   REAL area;
; 1545 :   REAL **dx = web.inverse_periods;

	mov	edi, DWORD PTR _web+1612

; 1546 :   MAT2D(u,EDGE_CTRL,MAXCOORD); /* affine coordinates of vertices */

	push	6
	push	3
	lea	eax, DWORD PTR _uxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _uqXvS$[ebp]
	push	ecx

; 1557 :     for ( j = 0 ; j < edge_ctrl ; j++ )

	mov	DWORD PTR _e_info$GSCopy$[ebp], ebx
	call	_mat2d_setup
	mov	edx, DWORD PTR _edge_ctrl
	mov	esi, eax
	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	push	edx
	push	esi
	lea	eax, DWORD PTR [ebx+416]
	push	edi
	push	eax
	call	_mat_mul_tr
	fldz
	mov	edx, DWORD PTR _edge_ctrl
	fld	ST(0)
	xor	edi, edi
	fst	QWORD PTR _area$[ebp]
	add	esp, 40					; 00000028H
	cmp	edx, edi
	jle	$LN30@q_edge_tor

; 1547 :   int i,j;
; 1548 :   int wrap;
; 1549 : 
; 1550 :   x = e_info->x;
; 1551 : 
; 1552 :   /* get affine coordinates of vertices */
; 1553 :   mat_mul_tr(x,dx,u,edge_ctrl,SDIM,SDIM);
; 1554 :   /* main integral over edge */
; 1555 :   area = 0.0;
; 1556 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	DWORD PTR tv903[ebp], edi
	mov	DWORD PTR tv958[ebp], OFFSET _scoeff+8
$LN28@q_edge_tor:

; 1557 :     for ( j = 0 ; j < edge_ctrl ; j++ )

	xor	ebx, ebx
	cmp	edx, 4
	jl	$LC21@q_edge_tor
	mov	eax, DWORD PTR tv958[ebp]
	add	edx, -4					; fffffffcH
	shr	edx, 2
	inc	edx
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR tv620[ebp], eax
	lea	ebx, DWORD PTR [edx*4]
$LN27@q_edge_tor:

; 1558 :     { REAL v = scoeff[i][j];

	mov	eax, DWORD PTR tv620[ebp]
	fld	QWORD PTR [eax-8]

; 1559 :       if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN38@q_edge_tor

; 1560 :       area += v*u[i][1]*u[j][0];

	mov	eax, DWORD PTR [esi+edi*4]
	fmul	QWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx-8]
	fmul	QWORD PTR [eax]
	faddp	ST(1), ST(0)
	jmp	SHORT $LN22@q_edge_tor
$LN38@q_edge_tor:
	fstp	ST(0)
$LN22@q_edge_tor:

; 1558 :     { REAL v = scoeff[i][j];

	mov	eax, DWORD PTR tv620[ebp]
	fld	QWORD PTR [eax]

; 1559 :       if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN41@q_edge_tor

; 1560 :       area += v*u[i][1]*u[j][0];

	mov	eax, DWORD PTR [esi+edi*4]
	fmul	QWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx-4]
	fmul	QWORD PTR [eax]
	faddp	ST(1), ST(0)
	jmp	SHORT $LN23@q_edge_tor
$LN41@q_edge_tor:
	fstp	ST(0)
$LN23@q_edge_tor:

; 1558 :     { REAL v = scoeff[i][j];

	mov	eax, DWORD PTR tv620[ebp]
	fld	QWORD PTR [eax+8]

; 1559 :       if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN44@q_edge_tor

; 1560 :       area += v*u[i][1]*u[j][0];

	mov	eax, DWORD PTR [esi+edi*4]
	fmul	QWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx]
	fmul	QWORD PTR [eax]
	faddp	ST(1), ST(0)
	jmp	SHORT $LN24@q_edge_tor
$LN44@q_edge_tor:
	fstp	ST(0)
$LN24@q_edge_tor:

; 1558 :     { REAL v = scoeff[i][j];

	mov	eax, DWORD PTR tv620[ebp]
	fld	QWORD PTR [eax+16]

; 1559 :       if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN47@q_edge_tor

; 1560 :       area += v*u[i][1]*u[j][0];

	mov	eax, DWORD PTR [esi+edi*4]
	fmul	QWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+4]
	fmul	QWORD PTR [eax]
	faddp	ST(1), ST(0)
	jmp	SHORT $LN25@q_edge_tor
$LN47@q_edge_tor:
	fstp	ST(0)
$LN25@q_edge_tor:

; 1557 :     for ( j = 0 ; j < edge_ctrl ; j++ )

	add	DWORD PTR tv620[ebp], 32		; 00000020H
	add	ecx, 16					; 00000010H
	dec	edx
	jne	$LN27@q_edge_tor
	mov	edx, DWORD PTR _edge_ctrl
$LC21@q_edge_tor:
	cmp	ebx, edx
	jge	SHORT $LN6@q_edge_tor
	mov	ecx, DWORD PTR tv903[ebp]
	add	ecx, ebx
	lea	ecx, DWORD PTR _scoeff[ecx*8]
$LC4@q_edge_tor:

; 1558 :     { REAL v = scoeff[i][j];

	fld	QWORD PTR [ecx]

; 1559 :       if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN56@q_edge_tor

; 1560 :       area += v*u[i][1]*u[j][0];

	mov	edx, DWORD PTR [esi+edi*4]
	fmul	QWORD PTR [edx+8]
	mov	eax, DWORD PTR [esi+ebx*4]
	fmul	QWORD PTR [eax]
	faddp	ST(1), ST(0)
	jmp	SHORT $LN3@q_edge_tor
$LN56@q_edge_tor:
	fstp	ST(0)
$LN3@q_edge_tor:
	inc	ebx

; 1557 :     for ( j = 0 ; j < edge_ctrl ; j++ )

	add	ecx, 8
	cmp	ebx, DWORD PTR _edge_ctrl
	jl	SHORT $LC4@q_edge_tor
	mov	edx, DWORD PTR _edge_ctrl
$LN6@q_edge_tor:

; 1547 :   int i,j;
; 1548 :   int wrap;
; 1549 : 
; 1550 :   x = e_info->x;
; 1551 : 
; 1552 :   /* get affine coordinates of vertices */
; 1553 :   mat_mul_tr(x,dx,u,edge_ctrl,SDIM,SDIM);
; 1554 :   /* main integral over edge */
; 1555 :   area = 0.0;
; 1556 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	add	DWORD PTR tv958[ebp], 24		; 00000018H
	add	DWORD PTR tv903[ebp], 3
	inc	edi
	cmp	edi, edx
	jl	$LN28@q_edge_tor
	mov	ebx, DWORD PTR _e_info$GSCopy$[ebp]
	fstp	ST(1)

; 1560 :       area += v*u[i][1]*u[j][0];

	fst	QWORD PTR _area$[ebp]
	jmp	SHORT $LN5@q_edge_tor
$LN30@q_edge_tor:

; 1547 :   int i,j;
; 1548 :   int wrap;
; 1549 : 
; 1550 :   x = e_info->x;
; 1551 : 
; 1552 :   /* get affine coordinates of vertices */
; 1553 :   mat_mul_tr(x,dx,u,edge_ctrl,SDIM,SDIM);
; 1554 :   /* main integral over edge */
; 1555 :   area = 0.0;
; 1556 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	fstp	ST(1)
$LN5@q_edge_tor:

; 1561 :     }
; 1562 : 
; 1563 :   /* wrap correction */
; 1564 :   wrap = (get_edge_wrap(e_info->id)>>TWRAPBITS) & WRAPMASK;

	mov	ebx, DWORD PTR [ebx]
	mov	edx, DWORD PTR _web+124
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	eax, DWORD PTR [eax+ecx]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN14@q_edge_tor
	push	eax
	fstp	ST(0)
	call	DWORD PTR _sym_inverse
	fld	QWORD PTR _area$[ebp]
	add	esp, 4
$LN14@q_edge_tor:
	sar	eax, 6
	and	eax, 31					; 0000001fH

; 1565 :   area += WRAPNUM(wrap)*u[2][0];

	cmp	eax, 16					; 00000010H
	jle	SHORT $LN10@q_edge_tor
	add	eax, -32				; ffffffe0H
$LN10@q_edge_tor:
	mov	edx, DWORD PTR [esi+8]

; 1566 : 
; 1567 :   return area*web.torusv;
; 1568 : } // end q_edge_torus_area_q()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	DWORD PTR tv132[ebp], eax
	fild	DWORD PTR tv132[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	fmul	QWORD PTR [edx]
	pop	ebx
	faddp	ST(1), ST(0)
	fmul	QWORD PTR _web+1600
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_torus_area_q ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_q_edge_torus_area_q_grad
EXTRN	_mat_mult:PROC
; Function compile flags: /Ogtp
;	COMDAT _q_edge_torus_area_q_grad
_TEXT	SEGMENT
_uqXvS$ = -356						; size = 12
_gqXvS$ = -344						; size = 12
_u$ = -332						; size = 4
_dx$ = -328						; size = 4
_area$ = -324						; size = 8
tv644 = -320						; size = 4
tv614 = -316						; size = 4
_g$ = -312						; size = 4
_j$ = -308						; size = 4
tv536 = -304						; size = 4
_e_info$GSCopy$ = -300					; size = 4
_wrapnum$ = -296					; size = 4
_i$ = -296						; size = 4
_uxJ$ = -292						; size = 144
_gxJ$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_q_edge_torus_area_q_grad PROC				; COMDAT

; 1578 : { REAL **x;

	push	ebp
	mov	ebp, esp
	sub	esp, 356				; 00000164H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1579 :   REAL area;
; 1580 :   REAL **dx = web.inverse_periods;
; 1581 :   MAT2D(u,EDGE_CTRL,MAXCOORD); /* affine coordinates of vertices */
; 1582 :   MAT2D(g,EDGE_CTRL,MAXCOORD);
; 1583 :   int i,j,k;
; 1584 :   int wrap,wrapnum;
; 1585 : 
; 1586 :   x = e_info->x;
; 1587 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	eax, DWORD PTR _e_info$[ebp]
	mov	ecx, DWORD PTR _web+1612
	push	ebx
	push	esi
	push	edi
	push	6
	push	3
	lea	edx, DWORD PTR _uxJ$[ebp]
	mov	DWORD PTR _e_info$GSCopy$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _uqXvS$[ebp]
	push	eax
	mov	DWORD PTR _dx$[ebp], ecx
	call	_mat2d_setup
	push	6
	push	3
	lea	ecx, DWORD PTR _gxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _gqXvS$[ebp]
	mov	ebx, eax
	push	edx
	mov	DWORD PTR _u$[ebp], ebx
	call	_mat2d_setup
	fldz
	mov	edx, DWORD PTR _web+616
	mov	esi, eax
	mov	eax, DWORD PTR _edge_ctrl
	add	esp, 32					; 00000020H
	xor	edi, edi
	mov	DWORD PTR _g$[ebp], esi
	test	eax, eax
	jle	SHORT $LN44@q_edge_tor@2
$LN19@q_edge_tor@2:

; 1588 :      for ( j = 0 ; j < SDIM ; j++ ) g[i][j] = 0.0;

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN18@q_edge_tor@2

; 1579 :   REAL area;
; 1580 :   REAL **dx = web.inverse_periods;
; 1581 :   MAT2D(u,EDGE_CTRL,MAXCOORD); /* affine coordinates of vertices */
; 1582 :   MAT2D(g,EDGE_CTRL,MAXCOORD);
; 1583 :   int i,j,k;
; 1584 :   int wrap,wrapnum;
; 1585 : 
; 1586 :   x = e_info->x;
; 1587 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	eax, DWORD PTR [esi+edi*4]
$LN16@q_edge_tor@2:

; 1588 :      for ( j = 0 ; j < SDIM ; j++ ) g[i][j] = 0.0;

	fst	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	inc	ecx
	add	eax, 8
	cmp	ecx, edx
	jl	SHORT $LN16@q_edge_tor@2
	mov	eax, DWORD PTR _edge_ctrl
$LN18@q_edge_tor@2:

; 1579 :   REAL area;
; 1580 :   REAL **dx = web.inverse_periods;
; 1581 :   MAT2D(u,EDGE_CTRL,MAXCOORD); /* affine coordinates of vertices */
; 1582 :   MAT2D(g,EDGE_CTRL,MAXCOORD);
; 1583 :   int i,j,k;
; 1584 :   int wrap,wrapnum;
; 1585 : 
; 1586 :   x = e_info->x;
; 1587 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	inc	edi
	cmp	edi, eax
	jl	SHORT $LN19@q_edge_tor@2
$LN44@q_edge_tor@2:

; 1589 : 
; 1590 :   /* get affine coordinates of vertices */
; 1591 :   mat_mul_tr(x,dx,u,edge_ctrl,SDIM,SDIM);

	push	edx
	fstp	ST(0)
	push	edx
	push	eax
	mov	eax, DWORD PTR _dx$[ebp]
	push	ebx
	push	eax
	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	add	eax, 416				; 000001a0H
	push	eax
	call	_mat_mul_tr

; 1592 :   /* main integral over edge */
; 1593 :   area = 0.0;

	fldz

; 1594 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	edx, DWORD PTR _edge_ctrl
	fld	ST(0)
	add	esp, 24					; 00000018H
	fst	QWORD PTR _area$[ebp]
	mov	DWORD PTR _i$[ebp], 0
	test	edx, edx
	jle	$LN56@q_edge_tor@2
	sub	esi, ebx
	mov	edi, ebx
	mov	DWORD PTR tv614[ebp], OFFSET _scoeff
	mov	DWORD PTR tv644[ebp], esi
$LN42@q_edge_tor@2:

; 1595 :     for ( j = 0 ; j < edge_ctrl ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	test	edx, edx
	jle	SHORT $LN12@q_edge_tor@2
	mov	ecx, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR tv614[ebp]
	mov	DWORD PTR tv536[ebp], eax
	sub	ebx, ecx
$LN10@q_edge_tor@2:

; 1596 :     { REAL v = scoeff[j][i];

	mov	eax, DWORD PTR tv536[ebp]
	fld	QWORD PTR [eax]

; 1597 :       if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN64@q_edge_tor@2

; 1598 :       area += v*u[i][0]*u[j][1];

	mov	eax, DWORD PTR [edi]
	fld	QWORD PTR [eax]
	mov	edx, DWORD PTR [ebx+ecx]

; 1599 :       g[i][0] += v*u[j][1];

	mov	esi, DWORD PTR [esi+edi]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edx+8]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edx+8]

; 1600 :       g[j][1] += v*u[i][0];

	mov	edx, DWORD PTR [ecx]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	mov	esi, DWORD PTR tv644[ebp]
	fmul	QWORD PTR [eax]
	fadd	QWORD PTR [edx+8]
	fstp	QWORD PTR [edx+8]
	mov	edx, DWORD PTR _edge_ctrl
	jmp	SHORT $LN9@q_edge_tor@2
$LN64@q_edge_tor@2:
	fstp	ST(0)
$LN9@q_edge_tor@2:

; 1595 :     for ( j = 0 ; j < edge_ctrl ; j++ )

	inc	DWORD PTR _j$[ebp]
	add	DWORD PTR tv536[ebp], 24		; 00000018H
	add	ecx, 4
	cmp	DWORD PTR _j$[ebp], edx
	jl	SHORT $LN10@q_edge_tor@2
	mov	ebx, DWORD PTR _u$[ebp]
$LN12@q_edge_tor@2:

; 1594 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv614[ebp], 8
	inc	eax
	add	edi, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, edx
	jl	$LN42@q_edge_tor@2
	mov	esi, DWORD PTR _g$[ebp]
	fstp	ST(1)

; 1598 :       area += v*u[i][0]*u[j][1];

	fst	QWORD PTR _area$[ebp]
	jmp	SHORT $LN11@q_edge_tor@2
$LN56@q_edge_tor@2:

; 1594 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	fstp	ST(1)
$LN11@q_edge_tor@2:

; 1601 :     }
; 1602 : 
; 1603 :   /* wrap correction */
; 1604 :   wrap = (get_edge_wrap(e_info->id)>>TWRAPBITS) & WRAPMASK;

	mov	ecx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edi+784]
	mov	eax, DWORD PTR [edx+eax]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN26@q_edge_tor@2
	push	eax
	fstp	ST(0)
	call	DWORD PTR _sym_inverse
	fld	QWORD PTR _area$[ebp]
	add	esp, 4
$LN26@q_edge_tor@2:
	sar	eax, 6
	and	eax, 31					; 0000001fH

; 1605 :   wrapnum = WRAPNUM(wrap);

	cmp	eax, 16					; 00000010H
	jle	SHORT $LN22@q_edge_tor@2
	add	eax, -32				; ffffffe0H
$LN22@q_edge_tor@2:

; 1606 :   area += wrapnum*u[2][0]; 

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR _wrapnum$[ebp], eax
	fild	DWORD PTR _wrapnum$[ebp]

; 1607 :   g[2][0] += wrapnum;

	mov	eax, DWORD PTR [esi+8]
	fld	QWORD PTR [ecx]

; 1608 : 
; 1609 :   for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	edi, edi
	fmul	ST(0), ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _area$[ebp]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR _edge_ctrl
	mov	edx, DWORD PTR _web+616
	test	eax, eax
	jle	SHORT $LN4@q_edge_tor@2
	npad	3
$LL6@q_edge_tor@2:

; 1610 :      for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN5@q_edge_tor@2

; 1608 : 
; 1609 :   for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	eax, DWORD PTR [esi+edi*4]
	npad	7
$LL3@q_edge_tor@2:

; 1611 :         g[k][j] *= web.torusv;

	fld	QWORD PTR [eax]
	inc	ecx
	fmul	QWORD PTR _web+1600
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jl	SHORT $LL3@q_edge_tor@2

; 1610 :      for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _edge_ctrl
$LN5@q_edge_tor@2:

; 1608 : 
; 1609 :   for ( k = 0 ; k < edge_ctrl ; k++ )

	inc	edi
	cmp	edi, eax
	jl	SHORT $LL6@q_edge_tor@2
$LN4@q_edge_tor@2:

; 1612 :   mat_mult(g,dx,e_info->grad,edge_ctrl,SDIM,SDIM);

	mov	ecx, DWORD PTR _dx$[ebp]
	push	edx
	push	edx
	mov	edx, DWORD PTR _e_info$GSCopy$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+1336]
	push	eax
	push	ecx
	push	esi
	call	_mat_mult

; 1613 : 
; 1614 :   return area*web.torusv;

	fld	QWORD PTR _web+1600

; 1615 : } // end q_edge_torus_area_q_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fmul	QWORD PTR _area$[ebp]
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_torus_area_q_grad ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_q_edge_torus_area_q_hess
EXTRN	_tr_mat_mul:PROC
; Function compile flags: /Ogtp
;	COMDAT _q_edge_torus_area_q_hess
_TEXT	SEGMENT
_temphqXvS$ = -736					; size = 24
_gqXvS$ = -712						; size = 16
_uqXvS$ = -696						; size = 12
tv722 = -684						; size = 4
tv717 = -680						; size = 4
tv915 = -676						; size = 4
_temph$ = -672						; size = 4
_area$ = -668						; size = 8
tv910 = -664						; size = 4
_g$ = -660						; size = 4
_dx$ = -656						; size = 4
_i$ = -652						; size = 4
tv711 = -648						; size = 4
tv858 = -644						; size = 4
_h$ = -640						; size = 4
_e_info$GSCopy$ = -636					; size = 4
_wrapnum$ = -632					; size = 4
_u$ = -632						; size = 4
_temphxJ$ = -628					; size = 288
_gxJ$ = -340						; size = 192
_uxJ$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_q_edge_torus_area_q_hess PROC				; COMDAT

; 1626 : { REAL **x;

	push	ebp
	mov	ebp, esp
	sub	esp, 736				; 000002e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1627 :   REAL area;
; 1628 :   REAL **dx = web.inverse_periods;

	mov	eax, DWORD PTR _web+1612
	push	ebx
	push	esi
	mov	esi, DWORD PTR _e_info$[ebp]
	push	edi

; 1629 :   MAT2D(u,EDGE_CTRL,MAXCOORD); /* affine coordinates of vertices */

	push	6
	push	3
	lea	ecx, DWORD PTR _uxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _uqXvS$[ebp]
	push	edx
	mov	DWORD PTR _e_info$GSCopy$[ebp], esi
	mov	DWORD PTR _dx$[ebp], eax
	call	_mat2d_setup

; 1630 :   MAT2D(g,EDGE_CTRL+1,MAXCOORD);

	push	6
	mov	edi, eax
	push	4
	lea	eax, DWORD PTR _gxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _u$[ebp], edi
	call	_mat2d_setup

; 1631 :   REAL ****h;
; 1632 :   MAT2D(temph,MAXCOORD,MAXCOORD);

	push	6
	mov	ebx, eax
	push	6
	lea	edx, DWORD PTR _temphxJ$[ebp]
	push	edx
	lea	eax, DWORD PTR _temphqXvS$[ebp]
	push	eax
	mov	DWORD PTR _g$[ebp], ebx
	call	_mat2d_setup

; 1633 :   int i,ii,j,k;
; 1634 :   int wrap,wrapnum;
; 1635 : 
; 1636 :   x = e_info->x;
; 1637 :   h = e_info->hess;
; 1638 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	fldz
	mov	ecx, DWORD PTR [esi+1340]
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR _temph$[ebp], eax
	mov	eax, DWORD PTR _edge_ctrl
	add	esp, 48					; 00000030H
	xor	esi, esi
	mov	DWORD PTR _h$[ebp], ecx
	test	eax, eax
	jle	SHORT $LN55@q_edge_tor@3
$LN25@q_edge_tor@3:

; 1639 :      for ( j = 0 ; j < SDIM ; j++ ) g[i][j] = 0.0;

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN24@q_edge_tor@3

; 1633 :   int i,ii,j,k;
; 1634 :   int wrap,wrapnum;
; 1635 : 
; 1636 :   x = e_info->x;
; 1637 :   h = e_info->hess;
; 1638 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	eax, DWORD PTR [ebx+esi*4]
$LN22@q_edge_tor@3:

; 1639 :      for ( j = 0 ; j < SDIM ; j++ ) g[i][j] = 0.0;

	fst	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	inc	ecx
	add	eax, 8
	cmp	ecx, edx
	jl	SHORT $LN22@q_edge_tor@3
	mov	eax, DWORD PTR _edge_ctrl
$LN24@q_edge_tor@3:

; 1633 :   int i,ii,j,k;
; 1634 :   int wrap,wrapnum;
; 1635 : 
; 1636 :   x = e_info->x;
; 1637 :   h = e_info->hess;
; 1638 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	inc	esi
	cmp	esi, eax
	jl	SHORT $LN25@q_edge_tor@3
$LN55@q_edge_tor@3:

; 1640 : 
; 1641 :   /* get affine coordinates of vertices */
; 1642 :   mat_mul_tr(x,dx,u,edge_ctrl,SDIM,SDIM);

	push	edx
	fstp	ST(0)
	push	edx
	mov	edx, DWORD PTR _dx$[ebp]
	push	eax
	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	push	edi
	push	edx
	add	eax, 416				; 000001a0H
	push	eax
	call	_mat_mul_tr

; 1643 :   /* main integral over edge */
; 1644 :   area = 0.0;

	fldz

; 1645 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	eax, DWORD PTR _edge_ctrl
	fld	ST(0)
	add	esp, 24					; 00000018H
	fst	QWORD PTR _area$[ebp]
	mov	DWORD PTR _i$[ebp], 0
	test	eax, eax
	jle	$LN67@q_edge_tor@3
	mov	ecx, DWORD PTR _h$[ebp]
	mov	esi, ebx
	sub	esi, edi
	sub	ecx, edi
	mov	DWORD PTR tv858[ebp], OFFSET _scoeff
	mov	DWORD PTR tv910[ebp], esi
	mov	DWORD PTR tv915[ebp], ecx
$LN53@q_edge_tor@3:

; 1646 :      for ( j = 0 ; j < edge_ctrl ; j++ )

	xor	ebx, ebx
	test	eax, eax
	jle	$LN18@q_edge_tor@3
	mov	eax, DWORD PTR tv858[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR _u$[ebp]
	mov	DWORD PTR tv711[ebp], eax
	mov	eax, DWORD PTR _h$[ebp]
	sub	edx, ecx
	sub	eax, ecx
	mov	DWORD PTR tv717[ebp], edx
	mov	DWORD PTR tv722[ebp], eax
$LN16@q_edge_tor@3:

; 1647 :         { REAL v = scoeff[j][i];

	mov	eax, DWORD PTR tv711[ebp]
	fld	QWORD PTR [eax]

; 1648 :           if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN75@q_edge_tor@3

; 1649 :           area += v*u[i][0]*u[j][1];

	mov	eax, DWORD PTR [edi]
	fld	QWORD PTR [eax]
	mov	edx, DWORD PTR [edx+ecx]

; 1650 :           g[i][0] += v*u[j][1];

	mov	esi, DWORD PTR [esi+edi]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edx+8]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edx+8]

; 1651 :           g[j][1] += v*u[i][0];

	mov	edx, DWORD PTR [ecx]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]

; 1652 :           h[i][j][0][1] += v*web.torusv;
; 1653 :           h[j][i][1][0] += v*web.torusv;

	mov	esi, DWORD PTR tv910[ebp]
	fld	QWORD PTR [eax]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [edx+8]
	fstp	QWORD PTR [edx+8]
	mov	edx, DWORD PTR tv915[ebp]
	mov	eax, DWORD PTR [edx+edi]
	fld	QWORD PTR _web+1600
	mov	edx, DWORD PTR [eax+ebx*4]
	fmul	ST(0), ST(1)
	mov	eax, DWORD PTR [edx]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	mov	eax, DWORD PTR tv722[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _i$[ebp]
	fmul	QWORD PTR _web+1600
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+4]
	fadd	QWORD PTR [eax]
	mov	edx, DWORD PTR tv717[ebp]
	fstp	QWORD PTR [eax]
	jmp	SHORT $LN15@q_edge_tor@3
$LN75@q_edge_tor@3:
	fstp	ST(0)
$LN15@q_edge_tor@3:

; 1646 :      for ( j = 0 ; j < edge_ctrl ; j++ )

	add	DWORD PTR tv711[ebp], 24		; 00000018H
	inc	ebx
	add	ecx, 4
	cmp	ebx, DWORD PTR _edge_ctrl
	jl	$LN16@q_edge_tor@3
	mov	eax, DWORD PTR _edge_ctrl
$LN18@q_edge_tor@3:

; 1645 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	add	DWORD PTR tv858[ebp], 8
	inc	ecx
	add	edi, 4
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, eax
	jl	$LN53@q_edge_tor@3
	mov	ebx, DWORD PTR _g$[ebp]
	fstp	ST(1)
	mov	edi, DWORD PTR _u$[ebp]

; 1649 :           area += v*u[i][0]*u[j][1];

	fst	QWORD PTR _area$[ebp]
	jmp	SHORT $LN17@q_edge_tor@3
$LN67@q_edge_tor@3:

; 1645 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	fstp	ST(1)
$LN17@q_edge_tor@3:

; 1654 :         }
; 1655 : 
; 1656 :   /* wrap correction */
; 1657 :   wrap = (get_edge_wrap(e_info->id)>>TWRAPBITS) & WRAPMASK;

	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _web+124
	mov	esi, DWORD PTR _dymem
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+esi+784]
	mov	eax, DWORD PTR [edx+eax]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN32@q_edge_tor@3
	push	eax
	fstp	ST(0)
	call	DWORD PTR _sym_inverse
	fld	QWORD PTR _area$[ebp]
	add	esp, 4
$LN32@q_edge_tor@3:
	sar	eax, 6
	and	eax, 31					; 0000001fH

; 1658 :   wrapnum = WRAPNUM(wrap);

	cmp	eax, 16					; 00000010H
	jle	SHORT $LN28@q_edge_tor@3
	add	eax, -32				; ffffffe0H
$LN28@q_edge_tor@3:

; 1659 :   area += wrapnum*u[2][0]; 

	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR _wrapnum$[ebp], eax
	fild	DWORD PTR _wrapnum$[ebp]

; 1660 :   g[2][0] += wrapnum; 

	mov	eax, DWORD PTR [ebx+8]
	fld	QWORD PTR [ecx]

; 1661 : 
; 1662 :   for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	esi, esi
	fmul	ST(0), ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _area$[ebp]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR _edge_ctrl
	mov	edx, DWORD PTR _web+616
	test	eax, eax
	jle	SHORT $LN10@q_edge_tor@3
	npad	7
$LL12@q_edge_tor@3:

; 1663 :      for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN11@q_edge_tor@3

; 1661 : 
; 1662 :   for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	eax, DWORD PTR [ebx+esi*4]
	npad	7
$LL9@q_edge_tor@3:

; 1664 :         g[k][j] *= web.torusv;

	fld	QWORD PTR [eax]
	inc	ecx
	fmul	QWORD PTR _web+1600
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jl	SHORT $LL9@q_edge_tor@3

; 1663 :      for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _edge_ctrl
$LN11@q_edge_tor@3:

; 1661 : 
; 1662 :   for ( k = 0 ; k < edge_ctrl ; k++ )

	inc	esi
	cmp	esi, eax
	jl	SHORT $LL12@q_edge_tor@3
$LN10@q_edge_tor@3:

; 1665 : 
; 1666 :   /* form pullback */
; 1667 :   mat_mult(g,dx,e_info->grad,edge_ctrl,SDIM,SDIM);

	mov	ecx, DWORD PTR _dx$[ebp]
	push	edx
	push	edx
	mov	edx, DWORD PTR _e_info$GSCopy$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+1336]
	push	eax
	push	ecx
	push	ebx
	call	_mat_mult

; 1668 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	eax, DWORD PTR _edge_ctrl
	add	esp, 24					; 00000018H
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN4@q_edge_tor@3
	npad	2
$LL52@q_edge_tor@3:

; 1669 :     for ( ii = 0 ; ii < edge_ctrl ; ii++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN5@q_edge_tor@3
	npad	10
$LL3@q_edge_tor@3:

; 1670 :     { mat_mult(h[i][ii],dx,temph,SDIM,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR _temph$[ebp]
	mov	ebx, DWORD PTR _dx$[ebp]
	push	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR [eax+edi*4]
	push	edx
	mov	edx, DWORD PTR [ecx+esi*4]
	push	ebx
	push	edx
	call	_mat_mult

; 1671 :       tr_mat_mul(dx,temph,e_info->hess[i][ii],SDIM,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax+1340]
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR _temph$[ebp]
	push	eax
	push	ecx
	push	ebx
	call	_tr_mat_mul
	mov	eax, DWORD PTR _edge_ctrl
	inc	esi
	add	esp, 48					; 00000030H
	cmp	esi, eax
	jl	SHORT $LL3@q_edge_tor@3
$LN5@q_edge_tor@3:

; 1668 :   for ( i = 0 ; i < edge_ctrl ; i++ )

	inc	edi
	cmp	edi, eax
	jl	SHORT $LL52@q_edge_tor@3
$LN4@q_edge_tor@3:

; 1672 :     }
; 1673 :   return area*web.torusv;
; 1674 : } // end q_edge_torus_area_q_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fld	QWORD PTR _web+1600
	fmul	QWORD PTR _area$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_torus_area_q_hess ENDP
_TEXT	ENDS
PUBLIC	_q_edge_torus_area_lagrange
; Function compile flags: /Ogtp
;	COMDAT _q_edge_torus_area_lagrange
_TEXT	SEGMENT
$T92639 = -36						; size = 4
_area$ = -32						; size = 8
_k$ = -28						; size = 4
_gl$ = -24						; size = 4
tv1229 = -20						; size = 4
tv1588 = -16						; size = 4
_m$ = -12						; size = 4
_u$ = -8						; size = 4
_ctrl$ = -4						; size = 4
tv148 = 8						; size = 4
_e_info$ = 8						; size = 4
_q_edge_torus_area_lagrange PROC			; COMDAT

; 1689 : { REAL **x;

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1690 :   REAL area;
; 1691 :   struct gauss_lag *gl = &gauss_lagrange[web.dimension][web.gauss1D_order];

	mov	eax, DWORD PTR _web+620

; 1692 :   int ctrl = web.skel[EDGE].ctrlpts;
; 1693 :   int m,k;
; 1694 :   REAL **u = e_info->u;

	mov	ecx, DWORD PTR _e_info$[ebp]
	mov	edx, DWORD PTR [ecx+1220]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _web+120
	push	edi
	mov	edi, DWORD PTR _web+1592
	shl	edi, 5
	add	edi, DWORD PTR _gauss_lagrange[eax*4]

; 1695 :   int wrap;
; 1696 : 
; 1697 :   x = e_info->x;
; 1698 :   /* get affine coordinates of vertices */
; 1699 :   mat_mul_tr(x,web.inverse_periods,u,ctrl,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	push	esi
	push	edx
	mov	DWORD PTR _u$[ebp], edx
	mov	edx, DWORD PTR _web+1612
	push	edx
	add	ecx, 416				; 000001a0H
	push	ecx
	mov	DWORD PTR _gl$[ebp], edi
	mov	DWORD PTR _ctrl$[ebp], esi
	call	_mat_mul_tr

; 1700 : 
; 1701 :   /* main integral over edge */
; 1702 :   area = 0.0;

	fldz
	mov	eax, DWORD PTR [edi+4]
	fld	ST(0)

; 1703 :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	ebx, ebx
	fst	QWORD PTR _area$[ebp]
	add	esp, 24					; 00000018H
	mov	DWORD PTR _m$[ebp], ebx

; 1706 :      { y += gl->gpoly[m][k]*u[k][1];

	mov	DWORD PTR $T92639[ebp], eax
	test	eax, eax
	jle	$LN25@q_edge_tor@4

; 1690 :   REAL area;
; 1691 :   struct gauss_lag *gl = &gauss_lagrange[web.dimension][web.gauss1D_order];

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR tv1588[ebp], eax
$LN22@q_edge_tor@4:

; 1704 :   { REAL y,dx;
; 1705 :      for ( y = 0.0, dx = 0.0, k = 0 ; k < ctrl ; k++ )

	xor	eax, eax
	fld	ST(1)
	fld	ST(2)
	cmp	esi, 4
	jl	$LC20@q_edge_tor@4
	mov	edx, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	esi, DWORD PTR [ecx+ebx*4]
	mov	edi, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	lea	eax, DWORD PTR [esi+16]
	lea	edx, DWORD PTR [edi+24]

; 1707 :         dx += gl->gpolypart[m][0][k]*u[k][0];

	sub	edi, esi
	mov	esi, DWORD PTR _ctrl$[ebp]
	add	esi, -4					; fffffffcH
	shr	esi, 2
	add	ecx, 8
	inc	esi
	mov	DWORD PTR tv1229[ebp], edi
	lea	edi, DWORD PTR [esi*4]
	mov	DWORD PTR _k$[ebp], edi
$LN21@q_edge_tor@4:

; 1706 :      { y += gl->gpoly[m][k]*u[k][1];

	mov	edi, DWORD PTR [ecx-8]
	fld	QWORD PTR [edi+8]
	mov	ebx, DWORD PTR [ecx-4]
	fmul	QWORD PTR [eax-16]

; 1707 :         dx += gl->gpolypart[m][0][k]*u[k][0];

	add	eax, 32					; 00000020H
	add	edx, 32					; 00000020H
	add	ecx, 16					; 00000010H
	dec	esi
	faddp	ST(2), ST(0)
	fld	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ecx-16]
	fmul	QWORD PTR [eax-40]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ecx-12]
	fmul	QWORD PTR [eax-32]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [ebx+8]
	fmul	QWORD PTR [eax-24]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edx-56]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR [ecx-20]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx-48]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR tv1229[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR [ecx-16]
	fmul	QWORD PTR [edi]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx-32]
	fmul	QWORD PTR [ebx]
	faddp	ST(1), ST(0)
	jne	SHORT $LN21@q_edge_tor@4

; 1704 :   { REAL y,dx;
; 1705 :      for ( y = 0.0, dx = 0.0, k = 0 ; k < ctrl ; k++ )

	mov	edi, DWORD PTR _gl$[ebp]
	mov	ebx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _ctrl$[ebp]
$LC20@q_edge_tor@4:
	cmp	eax, esi
	jge	SHORT $LN23@q_edge_tor@4
	mov	ecx, DWORD PTR [edi+24]
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	esi, DWORD PTR [edi+20]
	mov	edx, DWORD PTR [edx]
	mov	esi, DWORD PTR [esi+ebx*4]
	lea	ecx, DWORD PTR [edx+eax*8]
	sub	esi, edx
$LC3@q_edge_tor@4:

; 1706 :      { y += gl->gpoly[m][k]*u[k][1];

	mov	edx, DWORD PTR _u$[ebp]
	fld	QWORD PTR [esi+ecx]
	mov	edx, DWORD PTR [edx+eax*4]
	fmul	QWORD PTR [edx+8]
	inc	eax
	add	ecx, 8
	faddp	ST(2), ST(0)

; 1707 :         dx += gl->gpolypart[m][0][k]*u[k][0];

	fld	QWORD PTR [ecx-8]
	fmul	QWORD PTR [edx]
	faddp	ST(1), ST(0)
	cmp	eax, DWORD PTR _ctrl$[ebp]
	jl	SHORT $LC3@q_edge_tor@4

; 1704 :   { REAL y,dx;
; 1705 :      for ( y = 0.0, dx = 0.0, k = 0 ; k < ctrl ; k++ )

	mov	esi, DWORD PTR _ctrl$[ebp]
$LN23@q_edge_tor@4:

; 1708 :      }
; 1709 :      area -= gl->gausswt[m]*y*dx;

	mov	eax, DWORD PTR tv1588[ebp]
	fxch	ST(1)
	fmul	QWORD PTR [eax]
	inc	ebx
	add	eax, 8
	mov	DWORD PTR _m$[ebp], ebx
	fmulp	ST(1), ST(0)
	mov	DWORD PTR tv1588[ebp], eax
	fsubp	ST(1), ST(0)
	cmp	ebx, DWORD PTR $T92639[ebp]
	jl	$LN22@q_edge_tor@4
	fstp	ST(1)
	fst	QWORD PTR _area$[ebp]
	jmp	SHORT $LN4@q_edge_tor@4
$LN25@q_edge_tor@4:
	fstp	ST(1)
$LN4@q_edge_tor@4:

; 1710 :   }
; 1711 :      
; 1712 :   /* wrap correction */
; 1713 :   wrap = (get_edge_wrap(e_info->id)>>TWRAPBITS) & WRAPMASK;

	mov	eax, DWORD PTR _e_info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edi+784]
	mov	eax, DWORD PTR [edx+eax]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN13@q_edge_tor@4
	push	eax
	fstp	ST(0)
	call	DWORD PTR _sym_inverse
	fld	QWORD PTR _area$[ebp]
	add	esp, 4
$LN13@q_edge_tor@4:
	sar	eax, 6
	and	eax, 31					; 0000001fH

; 1714 :   area += WRAPNUM(wrap)*u[ctrl-1][0];

	cmp	eax, 16					; 00000010H
	jle	SHORT $LN9@q_edge_tor@4
	add	eax, -32				; ffffffe0H
$LN9@q_edge_tor@4:
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR tv148[ebp], eax

; 1715 : 
; 1716 :   return area * web.torusv;

	fild	DWORD PTR tv148[ebp]
	pop	edi
	pop	esi
	pop	ebx
	fmul	QWORD PTR [edx]
	faddp	ST(1), ST(0)
	fmul	QWORD PTR _web+1600

; 1717 : } // end q_edge_torus_area_lagrange()

	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_torus_area_lagrange ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_q_edge_torus_area_lagrange_grad
EXTRN	__chkstk:PROC
; Function compile flags: /Ogtp
;	COMDAT _q_edge_torus_area_lagrange_grad
_TEXT	SEGMENT
_gqXvS$ = -5240						; size = 400
tv2021 = -4840						; size = 4
_e_info$GSCopy$ = -4836					; size = 4
tv2321 = -4832						; size = 4
tv2130 = -4832						; size = 4
_ctrl$ = -4828						; size = 4
_area$ = -4824						; size = 8
tv2290 = -4820						; size = 4
_k$ = -4820						; size = 4
_u$ = -4816						; size = 4
_g$ = -4812						; size = 4
tv653 = -4808						; size = 4
_wrapnum$ = -4808					; size = 4
_gxJ$ = -4804						; size = 4800
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_q_edge_torus_area_lagrange_grad PROC			; COMDAT

; 1727 : { REAL **x;

	push	ebp
	mov	ebp, esp
	mov	eax, 5240				; 00001478H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _e_info$[ebp]

; 1728 :   REAL area;
; 1729 :   int m,j,k,i;
; 1730 :   struct gauss_lag *gl = &gauss_lagrange[web.dimension][web.gauss1D_order];

	mov	ecx, DWORD PTR _web+620

; 1731 :   int ctrl = web.skel[EDGE].ctrlpts;
; 1732 :   REAL **u = e_info->u;

	mov	edx, DWORD PTR [eax+1220]
	push	ebx
	mov	ebx, DWORD PTR _web+120
	push	esi
	mov	esi, DWORD PTR _web+1592
	push	edi

; 1733 :   int wrap,wrapnum;
; 1734 :   MAT2D(g,MAXVCOUNT,MAXCOORD);

	push	6
	mov	DWORD PTR _e_info$GSCopy$[ebp], eax
	shl	esi, 5
	add	esi, DWORD PTR _gauss_lagrange[ecx*4]
	push	100					; 00000064H
	lea	eax, DWORD PTR _gxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _ctrl$[ebp], ebx
	mov	DWORD PTR _u$[ebp], edx
	call	_mat2d_setup

; 1735 : 
; 1736 :   x = e_info->x;
; 1737 :   for ( i = 0 ; i < ctrl ; i++ )

	fldz
	mov	edx, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	xor	edi, edi
	mov	DWORD PTR _g$[ebp], eax
	test	ebx, ebx
	jle	SHORT $LN58@q_edge_tor@5
$LN54@q_edge_tor@5:

; 1738 :      for ( j = 0 ; j < SDIM ; j++ ) g[i][j] = 0.0;

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN20@q_edge_tor@5

; 1735 : 
; 1736 :   x = e_info->x;
; 1737 :   for ( i = 0 ; i < ctrl ; i++ )

	mov	edx, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR [edx+edi*4]
$LN18@q_edge_tor@5:

; 1738 :      for ( j = 0 ; j < SDIM ; j++ ) g[i][j] = 0.0;

	fst	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	inc	ecx
	add	eax, 8
	cmp	ecx, edx
	jl	SHORT $LN18@q_edge_tor@5
$LN20@q_edge_tor@5:

; 1735 : 
; 1736 :   x = e_info->x;
; 1737 :   for ( i = 0 ; i < ctrl ; i++ )

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LN54@q_edge_tor@5
$LN58@q_edge_tor@5:

; 1739 : 
; 1740 :   /* get affine coordinates of vertices */
; 1741 :   mat_mul_tr(x,web.inverse_periods,u,edge_ctrl,SDIM,SDIM);

	mov	eax, DWORD PTR _edge_ctrl
	fstp	ST(0)
	mov	ecx, DWORD PTR _u$[ebp]
	push	edx
	push	edx
	mov	edx, DWORD PTR _web+1612
	push	eax
	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	push	ecx
	push	edx
	add	eax, 416				; 000001a0H
	push	eax
	call	_mat_mul_tr

; 1742 : 
; 1743 :   /* main integral over edge */
; 1744 :   area = 0.0;

	fldz

; 1745 :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	eax, eax
	fld	ST(0)
	add	esp, 24					; 00000018H
	fst	QWORD PTR _area$[ebp]
	cmp	DWORD PTR [esi+4], eax
	jle	$LN67@q_edge_tor@5
$LN55@q_edge_tor@5:

; 1746 :   { REAL y,dx;
; 1747 :      for ( y = 0.0, dx = 0.0, k = 0 ; k < ctrl ; k++ )

	xor	ecx, ecx
	fld	ST(1)
	fld	ST(2)
	cmp	ebx, 4
	jl	$LC45@q_edge_tor@5
	mov	ecx, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	ebx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [edi+16]
	lea	edx, DWORD PTR [ebx+24]

; 1749 :         dx += gl->gpolypart[m][0][k]*u[k][0];

	sub	ebx, edi
	mov	edi, DWORD PTR _ctrl$[ebp]
	add	edi, -4					; fffffffcH
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv2021[ebp], edx
	mov	edx, DWORD PTR _u$[ebp]
	mov	DWORD PTR tv653[ebp], edi
	add	edi, edi
	add	edx, 8
	add	edi, edi
	mov	DWORD PTR _k$[ebp], edi
	mov	edi, DWORD PTR tv2021[ebp]
	mov	DWORD PTR tv2130[ebp], ebx
$LN46@q_edge_tor@5:

; 1748 :      { y += gl->gpoly[m][k]*u[k][1];

	mov	ebx, DWORD PTR [edx-8]
	fld	QWORD PTR [ecx-16]
	fmul	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [edx-4]

; 1749 :         dx += gl->gpolypart[m][0][k]*u[k][0];

	add	ecx, 32					; 00000020H
	add	edi, 32					; 00000020H
	faddp	ST(2), ST(0)
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv653[ebp]
	fld	QWORD PTR [ecx-40]
	fmul	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [edx-16]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [edx-12]
	fmul	QWORD PTR [ecx-32]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [ecx-24]
	fmul	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [edx-24]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edi-56]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [edx-20]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi-48]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv2130[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx+ebx-32]
	mov	ebx, DWORD PTR [edx-16]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [edx-12]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi-32]
	fmul	QWORD PTR [ebx]
	faddp	ST(1), ST(0)
	jne	SHORT $LN46@q_edge_tor@5

; 1746 :   { REAL y,dx;
; 1747 :      for ( y = 0.0, dx = 0.0, k = 0 ; k < ctrl ; k++ )

	mov	ebx, DWORD PTR _ctrl$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
$LC45@q_edge_tor@5:
	cmp	ecx, ebx
	jge	SHORT $LN53@q_edge_tor@5
	mov	edx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [edx]
	lea	edx, DWORD PTR [edi+ecx*8]
	mov	DWORD PTR tv2290[ebp], edx
	mov	edx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [edx+eax*4]
	sub	edx, edi
	mov	edi, DWORD PTR tv2290[ebp]
	mov	DWORD PTR tv2321[ebp], edx
	jmp	SHORT $LC12@q_edge_tor@5
$LN52@q_edge_tor@5:
	mov	edx, DWORD PTR tv2321[ebp]
$LC12@q_edge_tor@5:

; 1748 :      { y += gl->gpoly[m][k]*u[k][1];

	fld	QWORD PTR [edx+edi]
	mov	edx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	fmul	QWORD PTR [edx+8]
	inc	ecx
	add	edi, 8
	faddp	ST(2), ST(0)

; 1749 :         dx += gl->gpolypart[m][0][k]*u[k][0];

	fld	QWORD PTR [edi-8]
	fmul	QWORD PTR [edx]
	faddp	ST(1), ST(0)
	cmp	ecx, ebx
	jl	SHORT $LN52@q_edge_tor@5
$LN53@q_edge_tor@5:

; 1750 :      }
; 1751 :      area -= gl->gausswt[m]*y*dx;

	mov	ecx, DWORD PTR [esi+12]
	fld	QWORD PTR [ecx+eax*8]

; 1752 : 
; 1753 :      for ( k = 0 ; k < ctrl ; k++ )

	xor	ecx, ecx
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(1)
	fsubp	ST(3), ST(0)
	cmp	ebx, 4
	jl	$LC48@q_edge_tor@5

; 1750 :      }
; 1751 :      area -= gl->gausswt[m]*y*dx;

	mov	edx, DWORD PTR _g$[ebp]
	add	edx, 8

; 1752 : 
; 1753 :      for ( k = 0 ; k < ctrl ; k++ )

$LN49@q_edge_tor@5:

; 1754 :      { g[k][0] -= gl->gausswt[m]*y*gl->gpolypart[m][0][k];

	mov	ebx, DWORD PTR [esi+12]
	fld	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [edi+eax*4]
	fmul	ST(0), ST(2)
	mov	edi, DWORD PTR [edi]

; 1755 :         g[k][1] -= gl->gausswt[m]*dx*gl->gpoly[m][k];

	add	ecx, 4
	fmul	QWORD PTR [edi+ecx*8-32]
	mov	edi, DWORD PTR [edx-8]
	add	edx, 16					; 00000010H
	fsubr	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	mov	ebx, DWORD PTR [esi+12]
	fld	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [edi+eax*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edi+ecx*8-32]
	mov	edi, DWORD PTR [edx-24]
	fsubr	QWORD PTR [edi+8]
	fstp	QWORD PTR [edi+8]
	mov	ebx, DWORD PTR [esi+12]
	fld	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [edi+eax*4]
	fmul	ST(0), ST(2)
	mov	edi, DWORD PTR [edi]
	fmul	QWORD PTR [edi+ecx*8-24]
	mov	edi, DWORD PTR [edx-20]
	fsubr	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	mov	ebx, DWORD PTR [esi+12]
	fld	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [edi+eax*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edi+ecx*8-24]
	mov	edi, DWORD PTR [edx-20]
	fsubr	QWORD PTR [edi+8]
	fstp	QWORD PTR [edi+8]
	mov	ebx, DWORD PTR [esi+12]
	fld	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [edi+eax*4]
	fmul	ST(0), ST(2)
	mov	edi, DWORD PTR [edi]
	fmul	QWORD PTR [edi+ecx*8-16]
	mov	edi, DWORD PTR [edx-16]
	fsubr	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	mov	ebx, DWORD PTR [esi+12]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [esi+20]
	mov	ebx, DWORD PTR [ebx+eax*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+ecx*8-16]
	fsubr	QWORD PTR [edi+8]
	fstp	QWORD PTR [edi+8]
	mov	ebx, DWORD PTR [esi+12]
	fld	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [edi+eax*4]
	fmul	ST(0), ST(2)
	mov	edi, DWORD PTR [edi]
	fmul	QWORD PTR [edi+ecx*8-8]
	mov	edi, DWORD PTR [edx-12]
	fsubr	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	mov	ebx, DWORD PTR [esi+12]
	fld	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [edi+eax*4]
	fmul	ST(0), ST(1)
	mov	ebx, DWORD PTR _ctrl$[ebp]
	fmul	QWORD PTR [edi+ecx*8-8]
	mov	edi, DWORD PTR [edx-12]
	fsubr	QWORD PTR [edi+8]
	fstp	QWORD PTR [edi+8]
	lea	edi, DWORD PTR [ebx-3]
	cmp	ecx, edi
	jl	$LN49@q_edge_tor@5
$LC48@q_edge_tor@5:

; 1752 : 
; 1753 :      for ( k = 0 ; k < ctrl ; k++ )

	cmp	ecx, ebx
	jge	SHORT $LN86@q_edge_tor@5
$LC9@q_edge_tor@5:

; 1754 :      { g[k][0] -= gl->gausswt[m]*y*gl->gpolypart[m][0][k];

	mov	edi, DWORD PTR [esi+12]
	fld	QWORD PTR [edi+eax*8]
	mov	edx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [edx+eax*4]
	fmul	ST(0), ST(2)
	mov	edx, DWORD PTR [edx]
	inc	ecx
	fmul	QWORD PTR [edx+ecx*8-8]
	mov	edx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4-4]
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]

; 1755 :         g[k][1] -= gl->gausswt[m]*dx*gl->gpoly[m][k];

	mov	edi, DWORD PTR [esi+12]
	fld	QWORD PTR [edi+eax*8]
	mov	edx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [edx+eax*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edx+ecx*8-8]
	mov	edx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4-4]
	fsubr	QWORD PTR [edx+8]
	fstp	QWORD PTR [edx+8]
	cmp	ecx, ebx
	jl	SHORT $LC9@q_edge_tor@5
$LN86@q_edge_tor@5:

; 1745 :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	inc	eax

; 1752 : 
; 1753 :      for ( k = 0 ; k < ctrl ; k++ )

	fstp	ST(1)
	fstp	ST(0)
	cmp	eax, DWORD PTR [esi+4]
	jl	$LN55@q_edge_tor@5

; 1750 :      }
; 1751 :      area -= gl->gausswt[m]*y*dx;

	fstp	ST(1)
	fst	QWORD PTR _area$[ebp]
	jmp	SHORT $LN13@q_edge_tor@5
$LN67@q_edge_tor@5:
	fstp	ST(1)
$LN13@q_edge_tor@5:

; 1756 :      }
; 1757 :   }
; 1758 : 
; 1759 :   /* wrap correction */
; 1760 :   wrap = (get_edge_wrap(e_info->id)>>TWRAPBITS) & WRAPMASK;

	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _web+124
	mov	esi, DWORD PTR _dymem
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+esi+784]
	mov	eax, DWORD PTR [edx+eax]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN28@q_edge_tor@5
	push	eax
	fstp	ST(0)
	call	DWORD PTR _sym_inverse
	fld	QWORD PTR _area$[ebp]
	add	esp, 4
$LN28@q_edge_tor@5:
	sar	eax, 6
	and	eax, 31					; 0000001fH

; 1761 :   wrapnum = WRAPNUM(wrap);

	cmp	eax, 16					; 00000010H
	jle	SHORT $LN24@q_edge_tor@5
	add	eax, -32				; ffffffe0H
$LN24@q_edge_tor@5:

; 1762 :   area += wrapnum*u[ctrl-1][0]; 

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx+ebx*4-4]

; 1763 :   g[ctrl-1][0] += wrapnum;

	mov	edi, DWORD PTR _g$[ebp]
	mov	DWORD PTR _wrapnum$[ebp], eax
	fild	DWORD PTR _wrapnum$[ebp]
	mov	eax, DWORD PTR [edi+ebx*4-4]
	fld	QWORD PTR [edx]

; 1764 : 
; 1765 :   for ( k = 0 ; k < ctrl ; k++ )

	xor	esi, esi
	fmul	ST(0), ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _area$[ebp]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	test	ebx, ebx
	jle	SHORT $LN4@q_edge_tor@5
$LL56@q_edge_tor@5:

; 1766 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN5@q_edge_tor@5

; 1764 : 
; 1765 :   for ( k = 0 ; k < ctrl ; k++ )

	mov	eax, DWORD PTR [edi+esi*4]
	npad	7
$LL3@q_edge_tor@5:

; 1767 :       g[k][j] *= web.torusv;

	fld	QWORD PTR _web+1600
	inc	ecx
	fmul	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jl	SHORT $LL3@q_edge_tor@5
$LN5@q_edge_tor@5:

; 1764 : 
; 1765 :   for ( k = 0 ; k < ctrl ; k++ )

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL56@q_edge_tor@5
$LN4@q_edge_tor@5:

; 1768 :   mat_mult(g,web.inverse_periods,e_info->grad,ctrl,SDIM,SDIM);

	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax+1336]
	push	edx
	push	edx
	mov	edx, DWORD PTR _web+1612
	push	ebx
	push	ecx
	push	edx
	push	edi
	call	_mat_mult

; 1769 :   return area*web.torusv;

	fld	QWORD PTR _web+1600

; 1770 : } // end q_edge_torus_area_lagrange_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fmul	QWORD PTR _area$[ebp]
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_torus_area_lagrange_grad ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_q_edge_torus_area_lagrange_hess
; Function compile flags: /Ogtp
;	COMDAT _q_edge_torus_area_lagrange_hess
_TEXT	SEGMENT
_gqXvS$ = -5568						; size = 400
_temphqXvS$ = -5168					; size = 24
_h$ = -5144						; size = 4
_temph$ = -5140						; size = 4
_kk$ = -5136						; size = 4
_u$ = -5132						; size = 4
_ctrl$ = -5128						; size = 4
_e_info$GSCopy$ = -5124					; size = 4
_g$ = -5120						; size = 4
_area$ = -5116						; size = 8
tv5132 = -5112						; size = 4
tv5084 = -5112						; size = 4
tv4375 = -5112						; size = 4
tv4178 = -5112						; size = 4
tv4612 = -5108						; size = 4
tv1561 = -5108						; size = 4
tv4647 = -5104						; size = 4
tv3557 = -5104						; size = 4
tv3366 = -5104						; size = 4
_wrapnum$ = -5104					; size = 4
_k$ = -5100						; size = 4
tv4354 = -5096						; size = 4
tv4025 = -5096						; size = 4
tv3257 = -5096						; size = 4
_gxJ$ = -5092						; size = 4800
_temphxJ$ = -292					; size = 288
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_q_edge_torus_area_lagrange_hess PROC			; COMDAT

; 1781 : { REAL **x,****h;

	push	ebp
	mov	ebp, esp
	mov	eax, 5568				; 000015c0H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1782 :   REAL area;
; 1783 :   int i,ii,j;
; 1784 :   int m,k,kk;
; 1785 :   struct gauss_lag *gl = &gauss_lagrange[web.dimension][web.gauss1D_order];

	mov	eax, DWORD PTR _web+620
	push	ebx

; 1786 :   int ctrl = web.skel[EDGE].ctrlpts;

	mov	ebx, DWORD PTR _web+120
	push	esi
	mov	esi, DWORD PTR _web+1592
	push	edi
	mov	edi, DWORD PTR _e_info$[ebp]

; 1787 :   REAL **u = e_info->u;

	mov	ecx, DWORD PTR [edi+1220]

; 1788 :   int wrap,wrapnum;
; 1789 :   MAT2D(temph,MAXCOORD,MAXCOORD);

	push	6
	shl	esi, 5
	add	esi, DWORD PTR _gauss_lagrange[eax*4]
	push	6
	lea	edx, DWORD PTR _temphxJ$[ebp]
	push	edx
	lea	eax, DWORD PTR _temphqXvS$[ebp]
	push	eax
	mov	DWORD PTR _e_info$GSCopy$[ebp], edi
	mov	DWORD PTR _ctrl$[ebp], ebx
	mov	DWORD PTR _u$[ebp], ecx
	call	_mat2d_setup

; 1790 :   MAT2D(g,MAXVCOUNT,MAXCOORD);

	push	6
	push	100					; 00000064H
	lea	ecx, DWORD PTR _gxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _gqXvS$[ebp]
	push	edx
	mov	DWORD PTR _temph$[ebp], eax
	call	_mat2d_setup

; 1791 : 
; 1792 :   x = e_info->x;
; 1793 :   h = e_info->hess;
; 1794 :   for ( i = 0 ; i < ctrl ; i++ )

	fldz
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR _g$[ebp], eax
	mov	eax, DWORD PTR [edi+1340]
	add	esp, 32					; 00000020H
	xor	edi, edi
	mov	DWORD PTR _h$[ebp], eax
	test	ebx, ebx
	jle	SHORT $LN75@q_edge_tor@6
$LN70@q_edge_tor@6:

; 1795 :      for ( j = 0 ; j < SDIM ; j++ ) g[i][j] = 0.0;

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN29@q_edge_tor@6

; 1791 : 
; 1792 :   x = e_info->x;
; 1793 :   h = e_info->hess;
; 1794 :   for ( i = 0 ; i < ctrl ; i++ )

	mov	edx, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR [edx+edi*4]
$LN27@q_edge_tor@6:

; 1795 :      for ( j = 0 ; j < SDIM ; j++ ) g[i][j] = 0.0;

	fst	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	inc	ecx
	add	eax, 8
	cmp	ecx, edx
	jl	SHORT $LN27@q_edge_tor@6
$LN29@q_edge_tor@6:

; 1791 : 
; 1792 :   x = e_info->x;
; 1793 :   h = e_info->hess;
; 1794 :   for ( i = 0 ; i < ctrl ; i++ )

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LN70@q_edge_tor@6
$LN75@q_edge_tor@6:

; 1796 : 
; 1797 :   /* get affine coordinates of vertices */
; 1798 :   mat_mul_tr(x,web.inverse_periods,u,edge_ctrl,SDIM,SDIM);

	mov	eax, DWORD PTR _edge_ctrl
	fstp	ST(0)
	mov	ecx, DWORD PTR _u$[ebp]
	push	edx
	push	edx
	mov	edx, DWORD PTR _web+1612
	push	eax
	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	push	ecx
	push	edx
	add	eax, 416				; 000001a0H
	push	eax
	call	_mat_mul_tr

; 1799 : 
; 1800 :   /* main integral over edge */
; 1801 :   area = 0.0;

	fldz

; 1802 :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	eax, eax
	fld	ST(0)
	add	esp, 24					; 00000018H
	fst	QWORD PTR _area$[ebp]
	cmp	DWORD PTR [esi+4], eax
	jle	$LN84@q_edge_tor@6
$LN67@q_edge_tor@6:

; 1803 :   { REAL y,dx;
; 1804 :      for ( y = 0.0, dx = 0.0, k = 0 ; k < ctrl ; k++ )

	xor	ecx, ecx
	fld	ST(1)
	fld	ST(2)
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ebx, 4
	jl	$LC60@q_edge_tor@6
	mov	ecx, DWORD PTR [esi+20]
	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [ecx]
	lea	edx, DWORD PTR [edi+24]

; 1806 :         dx += gl->gpolypart[m][0][k]*u[k][0];

	sub	edi, ebx
	mov	DWORD PTR tv3366[ebp], edi
	lea	ecx, DWORD PTR [ebx+16]
	mov	ebx, DWORD PTR _ctrl$[ebp]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv3257[ebp], edx
	mov	edx, DWORD PTR _u$[ebp]
	mov	DWORD PTR tv1561[ebp], edi
	add	edi, edi
	add	edx, 8
	add	edi, edi
	mov	DWORD PTR _k$[ebp], edi
$LN61@q_edge_tor@6:

; 1805 :      { y += gl->gpoly[m][k]*u[k][1];

	mov	edi, DWORD PTR [edx-8]
	fld	QWORD PTR [edi+8]
	mov	edi, DWORD PTR [edx-4]
	fmul	QWORD PTR [ecx-16]

; 1806 :         dx += gl->gpolypart[m][0][k]*u[k][0];

	add	ecx, 32					; 00000020H
	add	edx, 16					; 00000010H
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edi+8]
	mov	edi, DWORD PTR [edx-16]
	fmul	QWORD PTR [ecx-40]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edi+8]
	mov	edi, DWORD PTR [edx-12]
	fmul	QWORD PTR [ecx-32]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edi+8]
	mov	edi, DWORD PTR tv3257[ebp]
	fmul	QWORD PTR [ecx-24]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edi-24]
	mov	edi, DWORD PTR [edx-24]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR tv3257[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi-16]
	mov	edi, DWORD PTR [edx-20]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR tv3366[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+ecx-32]
	mov	edi, DWORD PTR [edx-16]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR tv3257[ebp]
	add	DWORD PTR tv3257[ebp], 32		; 00000020H
	dec	DWORD PTR tv1561[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi]
	mov	edi, DWORD PTR [edx-12]
	fmul	QWORD PTR [edi]
	faddp	ST(1), ST(0)
	jne	$LN61@q_edge_tor@6

; 1803 :   { REAL y,dx;
; 1804 :      for ( y = 0.0, dx = 0.0, k = 0 ; k < ctrl ; k++ )

	mov	ecx, DWORD PTR _k$[ebp]
$LC60@q_edge_tor@6:
	cmp	ecx, ebx
	jge	SHORT $LN59@q_edge_tor@6
	mov	edx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [edx]
	mov	edi, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [edi+eax*4]
	sub	edi, edx
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR tv3557[ebp], edi
$LC21@q_edge_tor@6:

; 1805 :      { y += gl->gpoly[m][k]*u[k][1];

	mov	edi, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR tv3557[ebp]
	fld	QWORD PTR [edi+ecx]
	add	ecx, 8
	fmul	QWORD PTR [edx+8]
	faddp	ST(2), ST(0)

; 1806 :         dx += gl->gpolypart[m][0][k]*u[k][0];

	fld	QWORD PTR [ecx-8]
	fmul	QWORD PTR [edx]
	mov	edx, DWORD PTR _k$[ebp]
	inc	edx
	mov	DWORD PTR _k$[ebp], edx
	faddp	ST(1), ST(0)
	cmp	edx, ebx
	jl	SHORT $LC21@q_edge_tor@6
$LN59@q_edge_tor@6:

; 1807 :      }
; 1808 :      area -= gl->gausswt[m]*y*dx;

	mov	ecx, DWORD PTR [esi+12]
	fld	QWORD PTR [ecx+eax*8]

; 1809 :      for ( k = 0 ; k < ctrl ; k++ )

	xor	edi, edi
	fmul	ST(0), ST(2)
	mov	DWORD PTR _k$[ebp], edi
	fmul	ST(0), ST(1)
	fsubp	ST(3), ST(0)
	test	ebx, ebx
	jle	$LN110@q_edge_tor@6
	mov	edx, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv4612[ebp], edx
	mov	DWORD PTR tv4647[ebp], ecx
$LN18@q_edge_tor@6:

; 1810 :      { g[k][0] -= gl->gausswt[m]*y*gl->gpolypart[m][0][k];

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [esi+12]
	fld	QWORD PTR [edx+eax*8]
	fmul	ST(0), ST(2)
	fmul	QWORD PTR [ecx+edi*8]
	mov	ecx, DWORD PTR tv4612[ebp]
	mov	ecx, DWORD PTR [ecx]
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]

; 1811 :         g[k][1] -= gl->gausswt[m]*dx*gl->gpoly[m][k];

	mov	edx, DWORD PTR [esi+12]
	fld	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [edx+eax*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edx+edi*8]
	fsubr	QWORD PTR [ecx+8]
	fstp	QWORD PTR [ecx+8]

; 1812 :         for ( kk = 0 ; kk < ctrl ; kk++ )

	xor	ecx, ecx
	mov	DWORD PTR _kk$[ebp], ecx
	cmp	ebx, 4
	jl	$LN68@q_edge_tor@6

; 1810 :      { g[k][0] -= gl->gausswt[m]*y*gl->gpolypart[m][0][k];

	mov	edx, DWORD PTR tv4647[ebp]
	mov	edi, DWORD PTR tv4612[ebp]
	mov	edx, DWORD PTR [edx+edi]
	add	edx, 8
	mov	DWORD PTR tv4025[ebp], edx

; 1812 :         for ( kk = 0 ; kk < ctrl ; kk++ )

$LN64@q_edge_tor@6:

; 1813 :         { h[k][kk][0][1] -= gl->gausswt[m]*gl->gpoly[m][kk]*gl->gpolypart[m][0][k];

	mov	edi, DWORD PTR [edx-8]
	mov	edi, DWORD PTR [edi]
	mov	DWORD PTR tv5084[ebp], edi
	mov	edi, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+ecx*8]
	mov	ebx, DWORD PTR [esi+12]
	fmul	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [edi]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR tv5084[ebp]
	fsubr	QWORD PTR [edi+8]
	fstp	QWORD PTR [edi+8]

; 1814 :           h[k][kk][1][0] -= gl->gausswt[m]*gl->gpolypart[m][0][kk]*gl->gpoly[m][k];

	mov	edi, DWORD PTR [edx-8]
	mov	edi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [esi+12]
	mov	DWORD PTR tv4178[ebp], edi
	mov	edi, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR [esi+20]
	fmul	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	ebx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR [edx-4]
	fmul	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR tv4178[ebp]
	mov	edx, DWORD PTR [edx]
	fsubr	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+ecx*8+8]
	mov	ebx, DWORD PTR [esi+12]
	fmul	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [edi]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [edi+ebx*8]
	fsubr	QWORD PTR [edx+8]
	mov	edx, DWORD PTR tv4025[ebp]
	mov	edx, DWORD PTR [edx-4]
	mov	edi, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	fstp	QWORD PTR [edi+8]
	mov	edi, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+ecx*8+8]
	mov	ebx, DWORD PTR [esi+12]
	fmul	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR tv4025[ebp]
	lea	ecx, DWORD PTR [ecx*8+24]
	fsubr	QWORD PTR [edx]
	mov	edx, DWORD PTR [edi-4]
	mov	edx, DWORD PTR [edx+4]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [edi]
	mov	edi, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+ecx-8]
	mov	ebx, DWORD PTR [esi+12]
	fmul	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [edi]
	mov	ebx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR [edx]
	fmul	QWORD PTR [edi+ebx*8]
	fsubr	QWORD PTR [edx+8]
	mov	edx, DWORD PTR tv4025[ebp]
	mov	edx, DWORD PTR [edx]

; 1813 :         { h[k][kk][0][1] -= gl->gausswt[m]*gl->gpoly[m][kk]*gl->gpolypart[m][0][k];

	mov	edi, DWORD PTR [edx]
	fstp	QWORD PTR [edi+8]

; 1814 :           h[k][kk][1][0] -= gl->gausswt[m]*gl->gpolypart[m][0][kk]*gl->gpoly[m][k];

	mov	edi, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+ecx-8]
	mov	ebx, DWORD PTR [esi+12]
	fmul	QWORD PTR [ebx+eax*8]
	mov	edx, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR tv4025[ebp]
	fsubr	QWORD PTR [edx]
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+4]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+ecx]
	mov	ebx, DWORD PTR [esi+12]
	fmul	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [edi+ebx*8]
	fsubr	QWORD PTR [edx+8]
	mov	edx, DWORD PTR tv4025[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	fstp	QWORD PTR [edi+8]
	mov	edi, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+ecx]
	mov	ebx, DWORD PTR [esi+12]
	fmul	QWORD PTR [ebx+eax*8]
	mov	ecx, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	edi, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [ecx+edi*8]

; 1831 :   for ( i = 0 ; i < ctrl ; i++ )

	mov	ebx, DWORD PTR _ctrl$[ebp]
	add	ebx, -3					; fffffffdH
	fsubr	QWORD PTR [edx]
	mov	edx, DWORD PTR tv4025[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+4]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _kk$[ebp]
	add	ecx, 4
	add	edx, 16					; 00000010H
	mov	DWORD PTR _kk$[ebp], ecx
	mov	DWORD PTR tv4025[ebp], edx
	cmp	ecx, ebx
	jl	$LN64@q_edge_tor@6

; 1814 :           h[k][kk][1][0] -= gl->gausswt[m]*gl->gpolypart[m][0][kk]*gl->gpoly[m][k];

	mov	ebx, DWORD PTR _ctrl$[ebp]
$LN68@q_edge_tor@6:

; 1812 :         for ( kk = 0 ; kk < ctrl ; kk++ )

	cmp	ecx, ebx
	jge	$LN17@q_edge_tor@6
	mov	edx, DWORD PTR tv4647[ebp]
	mov	ebx, DWORD PTR tv4612[ebp]
	mov	edx, DWORD PTR [edx+ebx]
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv4354[ebp], edx
$LC15@q_edge_tor@6:

; 1813 :         { h[k][kk][0][1] -= gl->gausswt[m]*gl->gpoly[m][kk]*gl->gpolypart[m][0][k];

	mov	edx, DWORD PTR tv4354[ebp]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+12]
	mov	DWORD PTR tv5132[ebp], edx
	mov	edx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [edx+eax*4]
	fld	QWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [edx+eax*4]
	fmul	QWORD PTR [ebx+eax*8]
	mov	edx, DWORD PTR [edx]
	inc	ecx
	fmul	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR tv5132[ebp]
	fsubr	QWORD PTR [edx+8]
	fstp	QWORD PTR [edx+8]

; 1814 :           h[k][kk][1][0] -= gl->gausswt[m]*gl->gpolypart[m][0][kk]*gl->gpoly[m][k];

	mov	edx, DWORD PTR tv4354[ebp]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [esi+12]
	add	DWORD PTR tv4354[ebp], 4
	mov	DWORD PTR tv4375[ebp], edx
	mov	edx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+ecx*8-8]
	mov	edx, DWORD PTR [esi+20]
	fmul	QWORD PTR [ebx+eax*8]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	ebx, DWORD PTR _ctrl$[ebp]
	fmul	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR tv4375[ebp]
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	cmp	ecx, ebx
	jl	SHORT $LC15@q_edge_tor@6
$LN17@q_edge_tor@6:

; 1809 :      for ( k = 0 ; k < ctrl ; k++ )

	add	DWORD PTR tv4612[ebp], 4
	inc	edi
	mov	DWORD PTR _k$[ebp], edi
	cmp	edi, ebx
	jl	$LN18@q_edge_tor@6
$LN110@q_edge_tor@6:

; 1802 :   for ( m = 0 ; m < gl->gnumpts ; m++ )

	inc	eax

; 1812 :         for ( kk = 0 ; kk < ctrl ; kk++ )

	fstp	ST(1)
	fstp	ST(0)
	cmp	eax, DWORD PTR [esi+4]
	jl	$LN67@q_edge_tor@6

; 1807 :      }
; 1808 :      area -= gl->gausswt[m]*y*dx;

	fstp	ST(1)
	fst	QWORD PTR _area$[ebp]
	jmp	SHORT $LN22@q_edge_tor@6
$LN84@q_edge_tor@6:
	fstp	ST(1)
$LN22@q_edge_tor@6:

; 1815 :         }
; 1816 :      }
; 1817 :   }
; 1818 : 
; 1819 :   /* wrap correction */
; 1820 :   wrap = (get_edge_wrap(e_info->id)>>TWRAPBITS) & WRAPMASK;

	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _web+124
	mov	esi, DWORD PTR _dymem
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+esi+784]
	mov	eax, DWORD PTR [edx+eax]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN37@q_edge_tor@6
	push	eax
	fstp	ST(0)
	call	DWORD PTR _sym_inverse
	fld	QWORD PTR _area$[ebp]
	add	esp, 4
$LN37@q_edge_tor@6:
	sar	eax, 6
	and	eax, 31					; 0000001fH

; 1821 :   wrapnum = WRAPNUM(wrap);

	cmp	eax, 16					; 00000010H
	jle	SHORT $LN33@q_edge_tor@6
	add	eax, -32				; ffffffe0H
$LN33@q_edge_tor@6:

; 1822 :   area += wrapnum*u[ctrl-1][0]; 

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx+ebx*4-4]

; 1823 :   g[ctrl-1][0] += wrapnum;

	mov	edi, DWORD PTR _g$[ebp]
	mov	DWORD PTR _wrapnum$[ebp], eax
	fild	DWORD PTR _wrapnum$[ebp]
	mov	eax, DWORD PTR [edi+ebx*4-4]
	fld	QWORD PTR [edx]

; 1824 : 
; 1825 :   for ( k = 0 ; k < ctrl ; k++ )

	xor	esi, esi
	fmul	ST(0), ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _area$[ebp]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	test	ebx, ebx
	jle	SHORT $LN10@q_edge_tor@6
	npad	2
$LL73@q_edge_tor@6:

; 1826 :      for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN11@q_edge_tor@6

; 1824 : 
; 1825 :   for ( k = 0 ; k < ctrl ; k++ )

	mov	eax, DWORD PTR [edi+esi*4]
	npad	7
$LL9@q_edge_tor@6:

; 1827 :         g[k][j] *= web.torusv;

	fld	QWORD PTR [eax]
	inc	ecx
	fmul	QWORD PTR _web+1600
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jl	SHORT $LL9@q_edge_tor@6
$LN11@q_edge_tor@6:

; 1824 : 
; 1825 :   for ( k = 0 ; k < ctrl ; k++ )

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL73@q_edge_tor@6
$LN10@q_edge_tor@6:

; 1828 : 
; 1829 :   /* form pullback */
; 1830 :   mat_mult(g,web.inverse_periods,e_info->grad,ctrl,SDIM,SDIM);

	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax+1336]
	push	edx
	push	edx
	mov	edx, DWORD PTR _web+1612
	push	ebx
	push	ecx
	push	edx
	push	edi
	call	_mat_mult
	add	esp, 24					; 00000018H

; 1831 :   for ( i = 0 ; i < ctrl ; i++ )

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN4@q_edge_tor@6
	npad	12
$LL69@q_edge_tor@6:

; 1832 :      for ( ii = 0 ; ii < ctrl ; ii++ )

	xor	esi, esi
$LL3@q_edge_tor@6:

; 1833 :         { mat_mult(h[i][ii],web.inverse_periods,temph,SDIM,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _web+1612
	mov	edx, DWORD PTR _h$[ebp]
	push	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR _temph$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+edi*4]
	push	ecx
	mov	ecx, DWORD PTR [eax+esi*4]
	push	ecx
	call	_mat_mult

; 1834 :           tr_mat_mul(web.inverse_periods,temph,e_info->hess[i][ii],SDIM,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR _e_info$GSCopy$[ebp]
	push	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR [edx+1340]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR _temph$[ebp]
	mov	ecx, DWORD PTR _web+1612
	push	edx
	push	eax
	push	ecx
	call	_tr_mat_mul
	inc	esi
	add	esp, 48					; 00000030H
	cmp	esi, ebx
	jl	SHORT $LL3@q_edge_tor@6

; 1831 :   for ( i = 0 ; i < ctrl ; i++ )

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL69@q_edge_tor@6
$LN4@q_edge_tor@6:

; 1835 :         }
; 1836 :   return area*web.torusv;
; 1837 : } // end q_edge_torus_area_lagrange_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fld	QWORD PTR _web+1600
	fmul	QWORD PTR _area$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_torus_area_lagrange_hess ENDP
_TEXT	ENDS
PUBLIC	__real@4002666666666666
PUBLIC	??_C@_0N@OEGEGEAC@hooke_length?$AA@		; `string'
PUBLIC	__real@4000000000000000
PUBLIC	??_C@_0M@GPKJFBFK@hooke_power?$AA@		; `string'
PUBLIC	??_C@_0CF@NFPBEIHL@hooke_energy?5only?5for?5LINEAR?5mod@ ; `string'
PUBLIC	_hooke_energy_init
EXTRN	_localbase:DWORD
EXTRN	_add_global:PROC
EXTRN	_lookup_global:PROC
EXTRN	_kb_error:PROC
_BSS	SEGMENT
_hooke_length DQ 01H DUP (?)
_length_param DD 01H DUP (?)
	ALIGN	8

_hooke_power DQ	01H DUP (?)
_exponent_param DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@4002666666666666
CONST	SEGMENT
__real@4002666666666666 DQ 04002666666666666r	; 2.3
CONST	ENDS
;	COMDAT ??_C@_0N@OEGEGEAC@hooke_length?$AA@
CONST	SEGMENT
??_C@_0N@OEGEGEAC@hooke_length?$AA@ DB 'hooke_length', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT ??_C@_0M@GPKJFBFK@hooke_power?$AA@
CONST	SEGMENT
??_C@_0M@GPKJFBFK@hooke_power?$AA@ DB 'hooke_power', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NFPBEIHL@hooke_energy?5only?5for?5LINEAR?5mod@
CONST	SEGMENT
??_C@_0CF@NFPBEIHL@hooke_energy?5only?5for?5LINEAR?5mod@ DB 'hooke_energy'
	DB	' only for LINEAR model.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _hooke_energy_init
_TEXT	SEGMENT
tv382 = -4						; size = 4
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_hooke_energy_init PROC					; COMDAT

; 1867 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 1868 :   if ( web.modeltype != LINEAR )

	mov	ebx, 1
	push	esi
	push	edi
	cmp	DWORD PTR _web+628, ebx
	je	SHORT $LN5@hooke_ener

; 1869 :      kb_error(1766,"hooke_energy only for LINEAR model.\n",RECOVERABLE);

	push	ebx
	push	OFFSET ??_C@_0CF@NFPBEIHL@hooke_energy?5only?5for?5LINEAR?5mod@
	push	1766					; 000006e6H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN5@hooke_ener:

; 1870 : 
; 1871 : 
; 1872 :   exponent_param = lookup_global(POWER_NAME);

	push	OFFSET ??_C@_0M@GPKJFBFK@hooke_power?$AA@
	call	_lookup_global
	add	esp, 4
	mov	DWORD PTR _exponent_param, eax

; 1873 :   if ( exponent_param < 0 ) /* missing, so add */

	test	eax, eax
	jns	$LN50@hooke_ener

; 1874 :   { exponent_param = add_global(POWER_NAME);

	push	OFFSET ??_C@_0M@GPKJFBFK@hooke_power?$AA@
	call	_add_global

; 1875 :     globals(exponent_param)->value.real = 2.0;  /* default */

	mov	esi, eax
	and	esi, -16777216				; ff000000H
	add	esp, 4
	mov	DWORD PTR _exponent_param, eax
	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN8@hooke_ener
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN10@hooke_ener
	mov	edi, DWORD PTR _localbase
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	mov	edx, ecx
	imul	edx, 224				; 000000e0H
	add	edx, DWORD PTR [edi]
	jmp	SHORT $LN9@hooke_ener
$LN10@hooke_ener:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN8@hooke_ener
	mov	edx, DWORD PTR _web+5656
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN9@hooke_ener
$LN8@hooke_ener:
	mov	edx, DWORD PTR _web+5652
	mov	edi, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [edx+edi]
$LN9@hooke_ener:
	fld	QWORD PTR __real@4000000000000000
	fstp	QWORD PTR [edx+64]

; 1876 :     globals(exponent_param)->flags |=  ORDINARY_PARAM;

	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN14@hooke_ener
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN16@hooke_ener
	mov	edx, DWORD PTR _localbase
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN15@hooke_ener
$LN16@hooke_ener:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN14@hooke_ener
	mov	edx, DWORD PTR _web+5656
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN15@hooke_ener
$LN14@hooke_ener:
	mov	edx, DWORD PTR _web+5652
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
$LN15@hooke_ener:
	or	DWORD PTR [ecx+192], ebx
$LN50@hooke_ener:

; 1877 :   }
; 1878 :   hooke_power =  globals(exponent_param)->value.real; 

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN20@hooke_ener
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN22@hooke_ener
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN21@hooke_ener
$LN22@hooke_ener:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN20@hooke_ener
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN21@hooke_ener
$LN20@hooke_ener:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN21@hooke_ener:
	fld	QWORD PTR [eax+64]

; 1879 :   length_param = lookup_global(LENGTH_NAME);

	push	OFFSET ??_C@_0N@OEGEGEAC@hooke_length?$AA@
	fstp	QWORD PTR _hooke_power
	call	_lookup_global
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _length_param, edi

; 1880 :   if ( length_param < 0 ) /* missing, so add */

	test	edi, edi
	jns	$LN51@hooke_ener

; 1881 :   { length_param = add_global(LENGTH_NAME);

	push	OFFSET ??_C@_0N@OEGEGEAC@hooke_length?$AA@
	call	_add_global
	add	esp, 4
	mov	edi, eax
	mov	DWORD PTR _length_param, edi

; 1882 :     if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, ebx
	jne	$LN2@hooke_ener

; 1883 :        globals(length_param)->value.real 
; 1884 :           = web.total_area/web.skel[EDGE].count; /* default */

	mov	ecx, edi
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN26@hooke_ener
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN28@hooke_ener
	fild	DWORD PTR _web+176
	mov	edx, DWORD PTR _localbase
	mov	esi, edi
	and	esi, 16777215				; 00ffffffH
	fdivr	QWORD PTR _web+992
	mov	eax, esi
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	fstp	QWORD PTR [eax+64]

; 1885 :     else globals(length_param)->value.real 

	jmp	$LN1@hooke_ener
$LN28@hooke_ener:

; 1883 :        globals(length_param)->value.real 
; 1884 :           = web.total_area/web.skel[EDGE].count; /* default */

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN26@hooke_ener
	fild	DWORD PTR _web+176
	mov	eax, DWORD PTR _web+5656
	mov	esi, edi
	and	esi, 16777215				; 00ffffffH
	fdivr	QWORD PTR _web+992
	mov	eax, DWORD PTR [eax+esi*4]
	fstp	QWORD PTR [eax+64]

; 1885 :     else globals(length_param)->value.real 

	jmp	$LN1@hooke_ener
$LN26@hooke_ener:

; 1883 :        globals(length_param)->value.real 
; 1884 :           = web.total_area/web.skel[EDGE].count; /* default */

	fild	DWORD PTR _web+176
	mov	edx, DWORD PTR _web+5652
	mov	esi, edi
	and	esi, 16777215				; 00ffffffH
	fdivr	QWORD PTR _web+992
	lea	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx]
	fstp	QWORD PTR [eax+64]

; 1885 :     else globals(length_param)->value.real 

	jmp	$LN1@hooke_ener
$LN2@hooke_ener:

; 1886 :           = sqrt(2.3*web.total_area/web.skel[FACET].count); /* default */

	mov	eax, edi
	and	eax, -16777216				; ff000000H
	mov	esi, edi
	and	esi, 16777215				; 00ffffffH
	mov	DWORD PTR tv382[ebp], eax
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN36@hooke_ener
	mov	eax, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	ebx, DWORD PTR [ecx+edx]
	jmp	SHORT $LN33@hooke_ener
$LN36@hooke_ener:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN34@hooke_ener
	mov	eax, DWORD PTR _localbase
	mov	ebx, esi
	imul	ebx, 224				; 000000e0H
	add	ebx, DWORD PTR [eax]
	jmp	SHORT $LN33@hooke_ener
$LN34@hooke_ener:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN32@hooke_ener
	mov	ecx, DWORD PTR _web+5656
	mov	ebx, DWORD PTR [ecx+esi*4]
	jmp	SHORT $LN33@hooke_ener
$LN32@hooke_ener:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+esi*4]
	mov	ebx, DWORD PTR [eax+ecx]
$LN33@hooke_ener:
	fld	QWORD PTR _web+992
	fmul	QWORD PTR __real@4002666666666666
	fidiv	DWORD PTR _web+288
	call	__CIsqrt
	fstp	QWORD PTR [ebx+64]
	mov	ecx, DWORD PTR tv382[ebp]
	mov	ebx, 1
$LN1@hooke_ener:

; 1887 :     globals(length_param)->flags |=  ORDINARY_PARAM;

	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN42@hooke_ener
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [eax+ecx]
	jmp	SHORT $LN39@hooke_ener
$LN42@hooke_ener:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN40@hooke_ener
	mov	edx, DWORD PTR _localbase
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [edx]
	jmp	SHORT $LN39@hooke_ener
$LN40@hooke_ener:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN38@hooke_ener
	mov	eax, DWORD PTR _web+5656
	mov	esi, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN39@hooke_ener
$LN38@hooke_ener:
	mov	ecx, DWORD PTR _web+5652
	mov	eax, DWORD PTR _dymem
	lea	edx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [edx+eax]
$LN39@hooke_ener:
	or	DWORD PTR [esi+192], ebx
$LN51@hooke_ener:

; 1888 :   }
; 1889 :   hooke_length =  globals(length_param)->value.real; 

	mov	eax, edi
	and	eax, -16777216				; ff000000H
	and	edi, 16777215				; 00ffffffH
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN48@hooke_ener
	mov	ecx, DWORD PTR _web+5652
	mov	eax, DWORD PTR _dymem
	lea	edx, DWORD PTR [ecx+edi*4]
	mov	eax, DWORD PTR [edx+eax]
	fld	QWORD PTR [eax+64]
	pop	edi
	pop	esi
	fstp	QWORD PTR _hooke_length
	pop	ebx

; 1890 : } // end hooke_energy_init()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@hooke_ener:

; 1888 :   }
; 1889 :   hooke_length =  globals(length_param)->value.real; 

	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN46@hooke_ener
	mov	ecx, DWORD PTR _localbase
	imul	edi, 224				; 000000e0H
	add	edi, DWORD PTR [ecx]
	fld	QWORD PTR [edi+64]
	pop	edi
	pop	esi
	fstp	QWORD PTR _hooke_length
	pop	ebx

; 1890 : } // end hooke_energy_init()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@hooke_ener:

; 1888 :   }
; 1889 :   hooke_length =  globals(length_param)->value.real; 

	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN44@hooke_ener
	mov	edx, DWORD PTR _web+5656
	mov	edi, DWORD PTR [edx+edi*4]
	fld	QWORD PTR [edi+64]
	pop	edi
	pop	esi
	fstp	QWORD PTR _hooke_length
	pop	ebx

; 1890 : } // end hooke_energy_init()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@hooke_ener:

; 1888 :   }
; 1889 :   hooke_length =  globals(length_param)->value.real; 

	mov	eax, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [ecx+edx]
	fld	QWORD PTR [eax+64]
	pop	edi
	pop	esi
	fstp	QWORD PTR _hooke_length
	pop	ebx

; 1890 : } // end hooke_energy_init()

	mov	esp, ebp
	pop	ebp
	ret	0
_hooke_energy_init ENDP
_TEXT	ENDS
PUBLIC	_hooke_energy
EXTRN	__CIpow:PROC
EXTRN	__CIlog:PROC
; Function compile flags: /Ogtp
;	COMDAT _hooke_energy
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_hooke_energy PROC					; COMDAT

; 1901 : {

	push	ebp
	mov	ebp, esp

; 1902 :   REAL d,diff;
; 1903 : 
; 1904 :   d = sqrt(SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]));

	mov	eax, DWORD PTR _e_info$[ebp]
	mov	ecx, DWORD PTR [eax+1276]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 1905 :   diff = fabs(d - hooke_length);

	fsub	QWORD PTR _hooke_length
	fabs

; 1906 :   if ( hooke_power == 0.0 ) return -log(diff);

	fld	QWORD PTR _hooke_power
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@hooke_ener@2
	fstp	ST(0)
	call	__CIlog
	fchs

; 1908 : } // end hooke_energy()

	pop	ebp
	ret	0
$LN1@hooke_ener@2:
	pop	ebp

; 1907 :   return pow(diff,hooke_power);

	jmp	__CIpow
_hooke_energy ENDP
_TEXT	ENDS
PUBLIC	_hooke_energy_gradient
; Function compile flags: /Ogtp
;	COMDAT _hooke_energy_gradient
_TEXT	SEGMENT
_d$ = -16						; size = 8
_diff$ = -8						; size = 8
_e_info$ = 8						; size = 4
_hooke_energy_gradient PROC				; COMDAT

; 1921 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1922 :   REAL d,diff,coeff;
; 1923 :   REAL energy;
; 1924 :   int j;
; 1925 : 
; 1926 :   d = sqrt(SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]));

	mov	edx, DWORD PTR _web+616
	push	edi
	mov	edi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [edi+1276]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	push	edx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fst	QWORD PTR _d$[ebp]

; 1927 :   diff = d - hooke_length;

	fsub	QWORD PTR _hooke_length
	fst	QWORD PTR _diff$[ebp]

; 1928 :   if ( diff == 0.0 ) return 0.0;

	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@hooke_ener@3
	fstp	ST(1)
	pop	edi

; 1941 :      }
; 1942 :   return energy;
; 1943 : } // end hooke_energy_gradient()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@hooke_ener@3:

; 1929 :   if ( hooke_power == 0.0 )

	fld	QWORD PTR _hooke_power
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@hooke_ener@3
	fstp	ST(0)

; 1930 :   { energy = -log(fabs(diff));

	fabs
	call	__CIlog
	fchs

; 1931 :      coeff = -1/diff/d;

	fld	QWORD PTR __real@bff0000000000000

; 1932 :   }
; 1933 :   else

	jmp	SHORT $LN24@hooke_ener@3
$LN5@hooke_ener@3:

; 1934 :   { energy =  pow(fabs(diff),hooke_power);

	fxch	ST(1)
	fabs
	fxch	ST(1)
	call	__CIpow

; 1935 :      coeff = hooke_power*energy/diff/d;

	fld	QWORD PTR _hooke_power
	fmul	ST(0), ST(1)
$LN24@hooke_ener@3:
	fdiv	QWORD PTR _diff$[ebp]

; 1936 :   }
; 1937 :   for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	fdiv	QWORD PTR _d$[ebp]
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN19@hooke_ener@3
	mov	eax, DWORD PTR [edi+1276]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR [edi+1336]
	mov	edx, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	sub	edx, eax
	sub	esi, eax
$LN3@hooke_ener@3:

; 1938 :      {
; 1939 :         e_info->grad[0][j] = -coeff*e_info->sides[0][0][j];

	fld	QWORD PTR [eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fchs
	fstp	QWORD PTR [edx+eax-8]

; 1940 :         e_info->grad[1][j] = coeff*e_info->sides[0][0][j];

	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi+eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN3@hooke_ener@3
	pop	esi
$LN19@hooke_ener@3:

; 1936 :   }
; 1937 :   for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
	pop	edi

; 1941 :      }
; 1942 :   return energy;
; 1943 : } // end hooke_energy_gradient()

	mov	esp, ebp
	pop	ebp
	ret	0
_hooke_energy_gradient ENDP
_TEXT	ENDS
PUBLIC	_hooke_energy_hessian
; Function compile flags: /Ogtp
;	COMDAT _hooke_energy_hessian
_TEXT	SEGMENT
tv709 = -64						; size = 8
_energy$ = -56						; size = 8
_diff$ = -48						; size = 8
tv1641 = -44						; size = 4
tv1245 = -44						; size = 4
_d$ = -40						; size = 8
tv1646 = -36						; size = 4
tv1009 = -36						; size = 4
_ehess$ = -32						; size = 8
tv761 = -28						; size = 4
tv655 = -28						; size = 4
tv1400 = -24						; size = 4
tv1255 = -24						; size = 4
tv1636 = -20						; size = 4
tv1250 = -20						; size = 4
_h$ = -16						; size = 4
tv1536 = -12						; size = 4
tv1145 = -12						; size = 4
tv624 = -8						; size = 4
_jj$ = -4						; size = 4
_e_info$ = 8						; size = 4
_hooke_energy_hessian PROC				; COMDAT

; 1957 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 1958 :   REAL d,diff,coeff,egrad,ehess;
; 1959 :   REAL energy;
; 1960 :   int j,jj; 
; 1961 :   REAL ****h = e_info->hess;
; 1962 : 
; 1963 :   d = sqrt(SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]));

	mov	edx, DWORD PTR _web+616
	push	ebx
	mov	ebx, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [ebx+1276]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [ebx+1340]
	push	edx
	push	eax
	push	eax
	mov	DWORD PTR _h$[ebp], edi
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fst	QWORD PTR _d$[ebp]

; 1964 :   if ( d == 0.0 )

	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@hooke_ener@4
	pop	edi
	fstp	ST(1)
	pop	ebx

; 2029 : } // end hooke_energy_hessian()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@hooke_ener@4:

; 1965 :     return 0.0;
; 1966 :   diff = d - hooke_length;

	fld	ST(1)
	push	esi
	fsub	QWORD PTR _hooke_length
	fst	QWORD PTR _diff$[ebp]

; 1967 :   if ( diff == 0.0 )

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	fld1
	test	ah, 68					; 00000044H
	jp	SHORT $LN48@hooke_ener@4

; 1968 :   { energy = 0.0;

	fxch	ST(2)
	fst	QWORD PTR _energy$[ebp]

; 1969 :     egrad = hooke_power == 1 ? 1.0 : 0.0;

	fld	QWORD PTR _hooke_power
	fld	ST(0)
	fld	ST(4)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN26@hooke_ener@4
	fld	ST(3)
	jmp	SHORT $LN27@hooke_ener@4
$LN26@hooke_ener@4:
	fld	ST(1)
$LN27@hooke_ener@4:

; 1970 :     ehess = hooke_power == 2 ? 1.0 : 0.0;

	fld	ST(1)
	fld	QWORD PTR __real@4000000000000000
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN28@hooke_ener@4
	fxch	ST(4)
	fst	QWORD PTR _ehess$[ebp]
	jmp	$LN21@hooke_ener@4
$LN28@hooke_ener@4:
	fxch	ST(2)
	fst	QWORD PTR _ehess$[ebp]

; 1971 :   }
; 1972 :   else

	fxch	ST(2)
	fxch	ST(4)
	jmp	$LN21@hooke_ener@4
$LN48@hooke_ener@4:

; 1967 :   if ( diff == 0.0 )

	fstp	ST(3)
	fstp	ST(2)

; 1973 :   {
; 1974 :     if ( hooke_power == 0.0 )

	fld	QWORD PTR _hooke_power
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@hooke_ener@4
	fstp	ST(0)

; 1975 :     { energy = -log(fabs(diff));

	fabs
	call	__CIlog
	fchs
	fst	QWORD PTR _energy$[ebp]

; 1976 :       coeff = -1/diff/d;

	fld	QWORD PTR __real@bff0000000000000
	fld	QWORD PTR _diff$[ebp]
	fdiv	ST(1), ST(0)
	fld	QWORD PTR _d$[ebp]
	fdiv	ST(2), ST(0)

; 1977 :     }
; 1978 :     else

	fld	QWORD PTR _hooke_power
	jmp	SHORT $LN19@hooke_ener@4
$LN20@hooke_ener@4:

; 1979 :     { energy =  pow(fabs(diff),hooke_power);

	fxch	ST(1)
	fabs
	fxch	ST(1)
	call	__CIpow
	fst	QWORD PTR _energy$[ebp]

; 1980 :       coeff = hooke_power*energy/diff/d;

	fld	QWORD PTR _hooke_power
	fld	ST(0)
	fmul	ST(0), ST(2)
	fld	QWORD PTR _diff$[ebp]
	fdiv	ST(1), ST(0)
	fld	QWORD PTR _d$[ebp]
	fdiv	ST(2), ST(0)
	fxch	ST(2)
	fxch	ST(3)
	fxch	ST(1)
	fxch	ST(2)
	fxch	ST(1)
$LN19@hooke_ener@4:

; 1981 :     }
; 1982 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN100@hooke_ener@4
	mov	eax, DWORD PTR [ebx+1276]
	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [ebx+1336]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	sub	edx, eax
	sub	esi, eax
$LN18@hooke_ener@4:

; 1983 :     {
; 1984 :        e_info->grad[0][j] = -coeff*e_info->sides[0][0][j];

	fld	QWORD PTR [eax]
	inc	ecx
	fmul	ST(0), ST(4)
	add	eax, 8
	fchs
	fstp	QWORD PTR [edx+eax-8]

; 1985 :        e_info->grad[1][j] = coeff*e_info->sides[0][0][j];

	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(4)
	fstp	QWORD PTR [esi+eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN18@hooke_ener@4
$LN100@hooke_ener@4:

; 1981 :     }
; 1982 :     for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(3)

; 1986 :     }
; 1987 :     egrad = energy/diff;

	fxch	ST(3)
	fdiv	ST(0), ST(1)
	fld	ST(0)

; 1988 :     ehess = energy/diff/diff;

	fxch	ST(1)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _ehess$[ebp]
	fld1
	fldz
	fxch	ST(2)
	fxch	ST(4)
	fxch	ST(1)
$LN21@hooke_ener@4:

; 1989 :   }
; 1990 : 
; 1991 :   if ( hooke_power == 0.0 )

	fld	ST(1)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN59@hooke_ener@4
	fstp	ST(1)
	fstp	ST(3)

; 1992 :   {  if ( diff )

	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN62@hooke_ener@4

; 1993 :      for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	$LN62@hooke_ener@4
	fld	QWORD PTR __real@bff0000000000000
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx]
	fdiv	ST(0), ST(1)
	mov	edi, DWORD PTR [edi]
	mov	esi, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi]
	sub	esi, eax
	sub	ebx, eax
	sub	edx, eax
	mov	DWORD PTR tv624[ebp], edi
	mov	DWORD PTR tv1145[ebp], eax
	mov	DWORD PTR tv1245[ebp], esi
	mov	DWORD PTR tv1250[ebp], ebx
	mov	DWORD PTR tv1255[ebp], edx
	fdiv	ST(0), ST(3)
	jmp	SHORT $LN13@hooke_ener@4
$LN43@hooke_ener@4:
	mov	ebx, DWORD PTR tv1250[ebp]
$LN13@hooke_ener@4:
	mov	edx, DWORD PTR [esi+eax]

; 1994 :      { REAL f;
; 1995 :         f = -1/diff/d;

	fld	ST(0)

; 1996 :         h[1][1][j][j] += f;

	fld	ST(0)
	lea	edx, DWORD PTR [edx+ecx*8]
	fadd	QWORD PTR [edx]

; 1997 :         h[1][0][j][j] -= f;
; 1998 :         h[0][1][j][j] -= f;
; 1999 :         h[0][0][j][j] += f;
; 2000 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	DWORD PTR _jj$[ebp], 0
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [eax]
	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+eax]
	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR tv1255[ebp]
	mov	edx, DWORD PTR [edx+eax]
	fadd	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx]
	mov	ebx, DWORD PTR _web+616
	test	ebx, ebx
	jle	$LN12@hooke_ener@4
	mov	eax, DWORD PTR _e_info$[ebp]
	fld	ST(2)
	mov	edx, DWORD PTR [eax+1276]
	fdiv	ST(0), ST(2)
	mov	eax, DWORD PTR [edx]
	mov	ebx, DWORD PTR [eax]
	mov	edx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	esi, ebx
	sub	esi, eax
	mov	DWORD PTR tv1009[ebp], esi
	mov	esi, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi]
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	edi, DWORD PTR [edi+ecx*4]
	sub	edx, eax
	sub	esi, eax
	mov	DWORD PTR tv655[ebp], ebx
	sub	edi, eax
	fld	ST(3)
	fdiv	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(2)
	jmp	SHORT $LN10@hooke_ener@4
$LN42@hooke_ener@4:
	mov	ebx, DWORD PTR tv655[ebp]
$LN10@hooke_ener@4:

; 2001 :         { f = (1/diff + 1/d)/diff*e_info->sides[0][0][j]*e_info->sides[0][0][jj]/d/d;

	fld	ST(0)
	inc	DWORD PTR _jj$[ebp]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR tv1009[ebp]
	add	eax, 8
	fmul	QWORD PTR [ebx+eax-8]
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(5)

; 2002 :           h[1][1][j][jj] += f;

	fld	QWORD PTR [eax-8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]

; 2003 :           h[1][0][j][jj] -= f;

	fld	QWORD PTR [edx+eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx+eax-8]

; 2004 :           h[0][1][j][jj] -= f;

	fld	QWORD PTR [esi+eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [esi+eax-8]

; 2005 :           h[0][0][j][jj] += f;

	fadd	QWORD PTR [eax+edi-8]
	fstp	QWORD PTR [eax+edi-8]
	mov	ebx, DWORD PTR _web+616
	cmp	DWORD PTR _jj$[ebp], ebx
	jl	SHORT $LN42@hooke_ener@4

; 1997 :         h[1][0][j][j] -= f;
; 1998 :         h[0][1][j][j] -= f;
; 1999 :         h[0][0][j][j] += f;
; 2000 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	edi, DWORD PTR tv624[ebp]
	fstp	ST(0)
	mov	esi, DWORD PTR tv1245[ebp]
	mov	eax, DWORD PTR tv1145[ebp]
$LN12@hooke_ener@4:

; 1993 :      for ( j = 0 ; j < SDIM ; j++ )

	inc	ecx
	add	eax, 4
	mov	DWORD PTR tv1145[ebp], eax
	cmp	ecx, ebx
	jl	$LN43@hooke_ener@4
	fstp	ST(3)
	pop	esi
	fstp	ST(0)
	pop	edi
	fstp	ST(1)
	pop	ebx

; 2015 :         h[1][0][j][j] -= f;
; 2016 :         h[0][1][j][j] -= f;
; 2017 :         h[0][0][j][j] += f;
; 2018 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	fstp	ST(0)

; 2025 :         }
; 2026 :      }
; 2027 :   } 
; 2028 :   return energy;

	fld	QWORD PTR _energy$[ebp]

; 2029 : } // end hooke_energy_hessian()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@hooke_ener@4:

; 2006 :         }
; 2007 :      }
; 2008 :   }
; 2009 :   else
; 2010 :   {
; 2011 :      for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	fstp	ST(2)
	fstp	ST(2)
	cmp	DWORD PTR _web+616, ecx
	jle	$LN79@hooke_ener@4
	fld	ST(1)
	mov	edx, DWORD PTR [edi+4]
	fmul	ST(0), ST(3)
	mov	eax, DWORD PTR [edx]
	mov	edi, DWORD PTR [edi]
	mov	esi, DWORD PTR [edx+4]
	fdiv	ST(0), ST(4)
	mov	ebx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi]
	sub	esi, eax
	sub	ebx, eax
	sub	edx, eax
	mov	DWORD PTR tv624[ebp], edi
	mov	DWORD PTR tv1536[ebp], eax
	mov	DWORD PTR tv1636[ebp], esi
	mov	DWORD PTR tv1641[ebp], ebx
	mov	DWORD PTR tv1646[ebp], edx
	fstp	QWORD PTR tv709[ebp]
	fld	QWORD PTR _ehess$[ebp]
	jmp	SHORT $LN6@hooke_ener@4
$LN40@hooke_ener@4:
	mov	ebx, DWORD PTR tv1641[ebp]
$LN6@hooke_ener@4:
	mov	edx, DWORD PTR [esi+eax]

; 2012 :      { REAL f;
; 2013 :         f = hooke_power*egrad/d;

	fld	QWORD PTR tv709[ebp]

; 2014 :         h[1][1][j][j] += f;

	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fadd	ST(0), ST(1)

; 2015 :         h[1][0][j][j] -= f;
; 2016 :         h[0][1][j][j] -= f;
; 2017 :         h[0][0][j][j] += f;
; 2018 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	DWORD PTR _jj$[ebp], 0
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [eax]
	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+eax]
	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR tv1646[ebp]
	mov	edx, DWORD PTR [edx+eax]
	fadd	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx]
	mov	ebx, DWORD PTR _web+616
	test	ebx, ebx
	jle	$LN5@hooke_ener@4
	mov	eax, DWORD PTR _e_info$[ebp]
	fld	ST(2)
	fsub	ST(0), ST(2)
	mov	edx, DWORD PTR [eax+1276]
	mov	eax, DWORD PTR [edx]
	mov	ebx, DWORD PTR [eax]
	fmul	ST(0), ST(1)
	mov	edx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR [edx+4]
	fld	ST(4)
	mov	eax, DWORD PTR [edx+4]
	fdiv	ST(0), ST(6)
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	esi, ebx
	sub	esi, eax
	mov	DWORD PTR tv1400[ebp], esi
	mov	esi, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi]
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	edi, DWORD PTR [edi+ecx*4]
	sub	edx, eax
	sub	esi, eax
	mov	DWORD PTR tv761[ebp], ebx
	sub	edi, eax
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(3)
	jmp	SHORT $LN3@hooke_ener@4
$LN41@hooke_ener@4:
	mov	ebx, DWORD PTR tv761[ebp]
$LN3@hooke_ener@4:

; 2019 :         { f = hooke_power*(ehess*(hooke_power-1) - egrad/d)
; 2020 :                      *e_info->sides[0][0][j]*e_info->sides[0][0][jj]/d/d;

	fld	ST(0)
	inc	DWORD PTR _jj$[ebp]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR tv1400[ebp]
	add	eax, 8
	fmul	QWORD PTR [ebx+eax-8]
	fdiv	ST(0), ST(6)
	fdiv	ST(0), ST(6)

; 2021 :           h[1][1][j][jj] += f;

	fld	QWORD PTR [eax-8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]

; 2022 :           h[1][0][j][jj] -= f;

	fld	QWORD PTR [edx+eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx+eax-8]

; 2023 :           h[0][1][j][jj] -= f;

	fld	QWORD PTR [esi+eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [esi+eax-8]

; 2024 :           h[0][0][j][jj] += f;

	fadd	QWORD PTR [edi+eax-8]
	fstp	QWORD PTR [edi+eax-8]
	mov	ebx, DWORD PTR _web+616
	cmp	DWORD PTR _jj$[ebp], ebx
	jl	SHORT $LN41@hooke_ener@4

; 2015 :         h[1][0][j][j] -= f;
; 2016 :         h[0][1][j][j] -= f;
; 2017 :         h[0][0][j][j] += f;
; 2018 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	eax, DWORD PTR tv1536[ebp]
	fstp	ST(0)
	mov	esi, DWORD PTR tv1636[ebp]
	mov	edi, DWORD PTR tv624[ebp]
$LN5@hooke_ener@4:

; 2006 :         }
; 2007 :      }
; 2008 :   }
; 2009 :   else
; 2010 :   {
; 2011 :      for ( j = 0 ; j < SDIM ; j++ )

	inc	ecx
	add	eax, 4
	mov	DWORD PTR tv1536[ebp], eax
	cmp	ecx, ebx
	jl	$LN40@hooke_ener@4

; 2015 :         h[1][0][j][j] -= f;
; 2016 :         h[0][1][j][j] -= f;
; 2017 :         h[0][0][j][j] += f;
; 2018 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	fstp	ST(4)
	pop	esi
	fstp	ST(1)
	pop	edi
	fstp	ST(1)
	pop	ebx
	fstp	ST(0)
	fstp	ST(0)

; 2025 :         }
; 2026 :      }
; 2027 :   } 
; 2028 :   return energy;

	fld	QWORD PTR _energy$[ebp]

; 2029 : } // end hooke_energy_hessian()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@hooke_ener@4:

; 2006 :         }
; 2007 :      }
; 2008 :   }
; 2009 :   else
; 2010 :   {
; 2011 :      for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(2)
	pop	esi
	fstp	ST(1)
	pop	edi

; 2015 :         h[1][0][j][j] -= f;
; 2016 :         h[0][1][j][j] -= f;
; 2017 :         h[0][0][j][j] += f;
; 2018 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	fstp	ST(0)
	pop	ebx

; 2025 :         }
; 2026 :      }
; 2027 :   } 
; 2028 :   return energy;

	fld	QWORD PTR _energy$[ebp]

; 2029 : } // end hooke_energy_hessian()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN79@hooke_ener@4:

; 2006 :         }
; 2007 :      }
; 2008 :   }
; 2009 :   else
; 2010 :   {
; 2011 :      for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(3)
	pop	esi
	fstp	ST(0)
	pop	edi

; 2015 :         h[1][0][j][j] -= f;
; 2016 :         h[0][1][j][j] -= f;
; 2017 :         h[0][0][j][j] += f;
; 2018 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	fstp	ST(0)
	pop	ebx
	fstp	ST(0)

; 2025 :         }
; 2026 :      }
; 2027 :   } 
; 2028 :   return energy;

	fld	QWORD PTR _energy$[ebp]

; 2029 : } // end hooke_energy_hessian()

	mov	esp, ebp
	pop	ebp
	ret	0
_hooke_energy_hessian ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@MNDOBNJJ@hooke_size?$AA@		; `string'
PUBLIC	??_C@_0N@KFKKLADM@hooke2_power?$AA@		; `string'
PUBLIC	??_C@_0CG@MFOKNBMP@hooke2_energy?5only?5for?5LINEAR?5mo@ ; `string'
PUBLIC	_hooke2_energy_init
EXTRN	_get_edge_length:PROC
EXTRN	_calc_edge:PROC
EXTRN	_add_attribute:PROC
EXTRN	_find_attribute:PROC
_BSS	SEGMENT
_hooke2_attr DD	01H DUP (?)
_hooke2_power DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0L@MNDOBNJJ@hooke_size?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0L@MNDOBNJJ@hooke_size?$AA@ DB 'hooke_size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KFKKLADM@hooke2_power?$AA@
CONST	SEGMENT
??_C@_0N@KFKKLADM@hooke2_power?$AA@ DB 'hooke2_power', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MFOKNBMP@hooke2_energy?5only?5for?5LINEAR?5mo@
CONST	SEGMENT
??_C@_0CG@MFOKNBMP@hooke2_energy?5only?5for?5LINEAR?5mo@ DB 'hooke2_energ'
	DB	'y only for LINEAR model.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\method1.c
CONST	ENDS
;	COMDAT _hooke2_energy_init
_TEXT	SEGMENT
_one$90348 = -4						; size = 4
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_hooke2_energy_init PROC				; COMDAT

; 2059 : { edge_id e_id;

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi

; 2060 : 
; 2061 :   if ( web.modeltype != LINEAR )

	mov	edi, 1
	cmp	DWORD PTR _web+628, edi
	je	SHORT $LN8@hooke2_ene

; 2062 :      kb_error(1451,"hooke2_energy only for LINEAR model.\n",RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0CG@MFOKNBMP@hooke2_energy?5only?5for?5LINEAR?5mo@
	push	1451					; 000005abH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN8@hooke2_ene:

; 2063 : 
; 2064 : 
; 2065 :   exponent_param = lookup_global(POWER2_NAME);

	push	OFFSET ??_C@_0N@KFKKLADM@hooke2_power?$AA@
	call	_lookup_global
	add	esp, 4
	mov	DWORD PTR _exponent_param, eax

; 2066 :   if ( exponent_param < 0 ) /* missing, so add */

	test	eax, eax
	jns	$LN33@hooke2_ene

; 2067 :   { exponent_param = add_global(POWER2_NAME);

	push	OFFSET ??_C@_0N@KFKKLADM@hooke2_power?$AA@
	call	_add_global

; 2068 :     globals(exponent_param)->value.real = 2.0;  /* default */

	mov	esi, eax
	and	esi, -16777216				; ff000000H
	add	esp, 4
	mov	DWORD PTR _exponent_param, eax
	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN11@hooke2_ene
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN13@hooke2_ene
	mov	ebx, DWORD PTR _localbase
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	mov	edx, ecx
	imul	edx, 224				; 000000e0H
	add	edx, DWORD PTR [ebx]
	jmp	SHORT $LN12@hooke2_ene
$LN13@hooke2_ene:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN11@hooke2_ene
	mov	edx, DWORD PTR _web+5656
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN12@hooke2_ene
$LN11@hooke2_ene:
	mov	edx, DWORD PTR _web+5652
	mov	ebx, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [edx+ebx]
$LN12@hooke2_ene:
	fld	QWORD PTR __real@4000000000000000
	fstp	QWORD PTR [edx+64]

; 2069 :     globals(exponent_param)->flags |=  ORDINARY_PARAM;

	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN17@hooke2_ene
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN19@hooke2_ene
	mov	edx, DWORD PTR _localbase
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN18@hooke2_ene
$LN19@hooke2_ene:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN17@hooke2_ene
	mov	edx, DWORD PTR _web+5656
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN18@hooke2_ene
$LN17@hooke2_ene:
	mov	edx, DWORD PTR _web+5652
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
$LN18@hooke2_ene:
	or	DWORD PTR [ecx+192], edi
$LN33@hooke2_ene:

; 2070 :   }
; 2071 :   hooke2_power =  globals(exponent_param)->value.real; 

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN23@hooke2_ene
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN25@hooke2_ene
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN24@hooke2_ene
$LN25@hooke2_ene:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN23@hooke2_ene
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN24@hooke2_ene
$LN23@hooke2_ene:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN24@hooke2_ene:
	fld	QWORD PTR [eax+64]

; 2072 : 
; 2073 :   /* extra edge atribute */
; 2074 :   hooke2_attr = find_attribute(EDGE,HOOKE2_ATTR_NAME);

	push	OFFSET ??_C@_0L@MNDOBNJJ@hooke_size?$AA@
	push	edi
	fstp	QWORD PTR _hooke2_power
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _hooke2_attr, eax

; 2075 :   if ( hooke2_attr < 0 ) /* not found */

	test	eax, eax
	jns	$LN3@hooke2_ene

; 2076 :   { int one = 1;
; 2077 :     hooke2_attr = add_attribute(EDGE,HOOKE2_ATTR_NAME,REAL_TYPE,0,&one /*dim*/,
; 2078 :           DUMP_ATTR,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	edi
	lea	ecx, DWORD PTR _one$90348[ebp]
	push	ecx
	push	0
	push	edi
	push	OFFSET ??_C@_0L@MNDOBNJJ@hooke_size?$AA@
	push	edi
	mov	DWORD PTR _one$90348[ebp], edi
	call	_add_attribute

; 2079 :      FOR_ALL_EDGES(e_id)  /* initialize to current length */

	mov	edi, DWORD PTR _web+160
	add	esp, 32					; 00000020H
	mov	DWORD PTR _hooke2_attr, eax
	test	edi, 268435456				; 10000000H
	je	SHORT $LN3@hooke2_ene
	mov	edx, DWORD PTR _web+124
$LL34@hooke2_ene:
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN4@hooke2_ene

; 2080 :      { calc_edge(e_id);

	push	edi
	call	_calc_edge

; 2081 :         *((REAL*)(get_extra(e_id,hooke2_attr))) = get_edge_length(e_id);

	mov	edx, DWORD PTR _hooke2_attr
	mov	eax, edi
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+104]
	add	ecx, edx
	mov	edx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ecx+eax+64]
	add	ebx, DWORD PTR [edx+esi]
	push	edi
	call	_get_edge_length
	add	esp, 8
	fstp	QWORD PTR [ebx]
	mov	edx, DWORD PTR _web+124
$LN4@hooke2_ene:

; 2079 :      FOR_ALL_EDGES(e_id)  /* initialize to current length */

	mov	ecx, DWORD PTR [esi+edx]
	mov	edi, DWORD PTR [ecx]
	test	edi, 268435456				; 10000000H
	jne	SHORT $LL34@hooke2_ene
$LN3@hooke2_ene:
	pop	edi
	pop	esi
	pop	ebx

; 2082 :      }
; 2083 :   }
; 2084 : } // end hooke2_energy_init()

	mov	esp, ebp
	pop	ebp
	ret	0
_hooke2_energy_init ENDP
_TEXT	ENDS
PUBLIC	_hooke2_energy
; Function compile flags: /Ogtp
;	COMDAT _hooke2_energy
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_hooke2_energy PROC					; COMDAT

; 2095 : {

	push	ebp
	mov	ebp, esp

; 2096 :   REAL d,diff;
; 2097 : 
; 2098 :   d = sqrt(SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]));

	mov	edx, DWORD PTR _web+616
	push	esi
	mov	esi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	push	edx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 2099 :   diff = fabs(d - *((REAL*)get_extra(e_info->id,hooke2_attr)));

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _hooke2_attr
	mov	eax, ecx
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	esi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	esi, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [esi+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	pop	esi
	fsub	QWORD PTR [edx+eax]
	fabs

; 2100 :   if ( hooke2_power == 0.0 ) return -log(diff);

	fld	QWORD PTR _hooke2_power
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@hooke2_ene@2
	fstp	ST(0)
	call	__CIlog
	fchs

; 2102 : } // end hooke2_energy()

	pop	ebp
	ret	0
$LN1@hooke2_ene@2:
	pop	ebp

; 2101 :   return pow(diff,hooke2_power);

	jmp	__CIpow
_hooke2_energy ENDP
_TEXT	ENDS
PUBLIC	_hooke2_energy_gradient
; Function compile flags: /Ogtp
;	COMDAT _hooke2_energy_gradient
_TEXT	SEGMENT
_d$ = -16						; size = 8
_diff$ = -8						; size = 8
_e_info$ = 8						; size = 4
_hooke2_energy_gradient PROC				; COMDAT

; 2115 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2116 :   REAL d,diff,coeff;
; 2117 :   REAL energy;
; 2118 :   int j;
; 2119 : 
; 2120 :   d = sqrt(SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]));

	mov	edx, DWORD PTR _web+616
	push	esi
	mov	esi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	push	edi
	push	edx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fst	QWORD PTR _d$[ebp]

; 2121 :   diff = (d - *((REAL*)get_extra(e_info->id,hooke2_attr)));

	mov	ecx, DWORD PTR [esi]
	mov	edi, DWORD PTR _hooke2_attr
	mov	eax, ecx
	imul	edi, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	add	eax, edi
	mov	eax, DWORD PTR [eax+edx+64]
	fsub	QWORD PTR [ecx+eax]
	fst	QWORD PTR _diff$[ebp]

; 2122 :   if ( diff == 0.0 ) return 0.0;

	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@hooke2_ene@3
	pop	edi
	fstp	ST(1)
	pop	esi

; 2135 :   }
; 2136 :   return energy;
; 2137 : } // end hooke2_energy_gradient()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@hooke2_ene@3:

; 2123 :   if ( hooke2_power == 0.0 )

	fld	QWORD PTR _hooke2_power
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@hooke2_ene@3
	fstp	ST(0)

; 2124 :   { energy = -log(fabs(diff));

	fabs
	call	__CIlog
	fchs

; 2125 :     coeff = -1/diff/d;

	fld	QWORD PTR __real@bff0000000000000

; 2126 :   }
; 2127 :   else

	jmp	SHORT $LN23@hooke2_ene@3
$LN5@hooke2_ene@3:

; 2128 :   { energy =  pow(fabs(diff),hooke2_power);

	fxch	ST(1)
	fabs
	fxch	ST(1)
	call	__CIpow

; 2129 :     coeff = hooke2_power*energy/diff/d;

	fld	QWORD PTR _hooke2_power
	fmul	ST(0), ST(1)
$LN23@hooke2_ene@3:
	fdiv	QWORD PTR _diff$[ebp]

; 2130 :   }
; 2131 :   for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	fdiv	QWORD PTR _d$[ebp]
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN22@hooke2_ene@3
$LN3@hooke2_ene@3:

; 2132 :   {
; 2133 :      e_info->grad[0][j] = -coeff*e_info->sides[0][0][j];

	mov	ecx, DWORD PTR [esi+1276]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	fld	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR [esi+1336]
	mov	ecx, DWORD PTR [edx]
	fmul	ST(0), ST(1)
	inc	eax
	fchs
	fstp	QWORD PTR [ecx+eax*8-8]

; 2134 :      e_info->grad[1][j] = coeff*e_info->sides[0][0][j];

	mov	edx, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx]
	fld	QWORD PTR [edx+eax*8-8]
	mov	ecx, DWORD PTR [esi+1336]
	mov	edx, DWORD PTR [ecx+4]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@hooke2_ene@3
$LN22@hooke2_ene@3:
	pop	edi

; 2130 :   }
; 2131 :   for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
	pop	esi

; 2135 :   }
; 2136 :   return energy;
; 2137 : } // end hooke2_energy_gradient()

	mov	esp, ebp
	pop	ebp
	ret	0
_hooke2_energy_gradient ENDP
_TEXT	ENDS
PUBLIC	_hooke2_energy_hessian
; Function compile flags: /Ogtp
;	COMDAT _hooke2_energy_hessian
_TEXT	SEGMENT
tv766 = -52						; size = 8
_energy$ = -44						; size = 8
_diff$ = -36						; size = 8
tv1624 = -32						; size = 4
tv1250 = -32						; size = 4
_ehess$ = -28						; size = 8
_d$ = -28						; size = 8
tv1405 = -24						; size = 4
tv1255 = -24						; size = 4
tv1619 = -20						; size = 4
tv1041 = -20						; size = 4
tv1614 = -16						; size = 4
tv1260 = -16						; size = 4
_h$ = -12						; size = 4
tv1531 = -8						; size = 4
tv1167 = -8						; size = 4
tv681 = -4						; size = 4
_e_info$ = 8						; size = 4
_hooke2_energy_hessian PROC				; COMDAT

; 2149 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2150 :   REAL d,diff,coeff,egrad,ehess;
; 2151 :   REAL energy;
; 2152 :   int j,jj;
; 2153 :   REAL ****h = e_info->hess;
; 2154 : 
; 2155 :   d = sqrt(SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]));

	mov	edx, DWORD PTR _web+616
	push	esi
	mov	esi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [esi+1340]
	push	edx
	push	eax
	push	eax
	mov	DWORD PTR _h$[ebp], edi
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fst	QWORD PTR _d$[ebp]

; 2156 :   if ( d == 0.0 )

	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@hooke2_ene@4
	pop	edi
	fstp	ST(1)
	pop	esi

; 2221 : } // end hooke2_energy_hessian()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@hooke2_ene@4:

; 2157 :     return 0.0;
; 2158 :   diff = (d - *((REAL*)get_extra(e_info->id,hooke2_attr)));

	mov	ecx, DWORD PTR [esi]
	fld	ST(1)
	mov	edx, DWORD PTR _hooke2_attr
	mov	eax, ecx
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	push	ebx
	mov	ebx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	ebx, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [ebx+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	fsub	QWORD PTR [edx+eax]
	fst	QWORD PTR _diff$[ebp]

; 2159 :   if ( diff == 0.0 ) 

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	fld1
	test	ah, 68					; 00000044H
	jp	SHORT $LN48@hooke2_ene@4

; 2160 :   { energy = 0.0;

	fxch	ST(2)
	fst	QWORD PTR _energy$[ebp]

; 2161 :     egrad = hooke2_power == 1 ? 1 : 0.0;

	fld	QWORD PTR _hooke2_power
	fld	ST(0)
	fld	ST(4)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN26@hooke2_ene@4
	fld	ST(3)
	jmp	SHORT $LN27@hooke2_ene@4
$LN26@hooke2_ene@4:
	fld	ST(1)
$LN27@hooke2_ene@4:

; 2162 :     ehess = hooke2_power == 2 ? 1 : 0.0;

	fld	ST(1)
	fld	QWORD PTR __real@4000000000000000
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN28@hooke2_ene@4
	fxch	ST(4)
	fst	QWORD PTR _ehess$[ebp]
	jmp	$LN21@hooke2_ene@4
$LN28@hooke2_ene@4:
	fxch	ST(2)
	fst	QWORD PTR _ehess$[ebp]

; 2163 :   }
; 2164 :   else

	fxch	ST(2)
	fxch	ST(4)
	jmp	$LN21@hooke2_ene@4
$LN48@hooke2_ene@4:

; 2159 :   if ( diff == 0.0 ) 

	fstp	ST(3)
	fstp	ST(2)

; 2165 :   {
; 2166 :     if ( hooke2_power == 0.0 )

	fld	QWORD PTR _hooke2_power
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@hooke2_ene@4
	fstp	ST(0)

; 2167 :     { energy = -log(fabs(diff));

	fabs
	call	__CIlog
	fchs
	fst	QWORD PTR _energy$[ebp]

; 2168 :       coeff = -1/diff/d;

	fld	QWORD PTR __real@bff0000000000000
	fld	QWORD PTR _diff$[ebp]
	fdiv	ST(1), ST(0)
	fld	QWORD PTR _d$[ebp]
	fdiv	ST(2), ST(0)

; 2169 :     }
; 2170 :     else

	fld	QWORD PTR _hooke2_power
	jmp	SHORT $LN19@hooke2_ene@4
$LN20@hooke2_ene@4:

; 2171 :     { energy = pow(fabs(diff),hooke2_power);

	fxch	ST(1)
	fabs
	fxch	ST(1)
	call	__CIpow
	fst	QWORD PTR _energy$[ebp]

; 2172 :       coeff = hooke2_power*energy/diff/d;

	fld	QWORD PTR _hooke2_power
	fld	ST(0)
	fmul	ST(0), ST(2)
	fld	QWORD PTR _diff$[ebp]
	fdiv	ST(1), ST(0)
	fld	QWORD PTR _d$[ebp]
	fdiv	ST(2), ST(0)
	fxch	ST(2)
	fxch	ST(3)
	fxch	ST(1)
	fxch	ST(2)
	fxch	ST(1)
$LN19@hooke2_ene@4:

; 2173 :     }
; 2174 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN96@hooke2_ene@4
$LN18@hooke2_ene@4:

; 2175 :     {
; 2176 :       e_info->grad[0][j] = -coeff*e_info->sides[0][0][j];

	mov	ecx, DWORD PTR [esi+1276]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	fld	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR [esi+1336]
	mov	ecx, DWORD PTR [edx]
	fmul	ST(0), ST(4)
	inc	eax
	fchs
	fstp	QWORD PTR [ecx+eax*8-8]

; 2177 :       e_info->grad[1][j] = coeff*e_info->sides[0][0][j];

	mov	edx, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx]
	fld	QWORD PTR [edx+eax*8-8]
	mov	ecx, DWORD PTR [esi+1336]
	mov	edx, DWORD PTR [ecx+4]
	fmul	ST(0), ST(4)
	fstp	QWORD PTR [edx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN18@hooke2_ene@4
$LN96@hooke2_ene@4:

; 2173 :     }
; 2174 :     for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(3)

; 2178 :     }
; 2179 :     egrad = energy/diff;

	fxch	ST(3)
	fdiv	ST(0), ST(1)
	fld	ST(0)

; 2180 :     ehess = energy/diff/diff;

	fxch	ST(1)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _ehess$[ebp]
	fld1
	fldz
	fxch	ST(2)
	fxch	ST(4)
	fxch	ST(1)
$LN21@hooke2_ene@4:

; 2181 :   }
; 2182 :   
; 2183 :   if ( hooke2_power == 0.0 )

	fld	ST(1)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN59@hooke2_ene@4
	fstp	ST(1)
	fstp	ST(3)

; 2184 :   {  if ( diff )

	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN62@hooke2_ene@4

; 2185 :      for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	$LN62@hooke2_ene@4
	fld	QWORD PTR __real@bff0000000000000
	mov	esi, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	fdiv	ST(0), ST(1)
	mov	eax, DWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR tv681[ebp], esi
	mov	esi, DWORD PTR [esi]
	sub	edi, eax
	sub	ebx, eax
	sub	esi, eax
	mov	DWORD PTR tv1167[ebp], eax
	mov	DWORD PTR tv1250[ebp], edi
	mov	DWORD PTR tv1255[ebp], ebx
	mov	DWORD PTR tv1260[ebp], esi
	fdiv	ST(0), ST(3)
	jmp	SHORT $LN13@hooke2_ene@4
$LN43@hooke2_ene@4:
	mov	esi, DWORD PTR tv1260[ebp]
$LN13@hooke2_ene@4:
	mov	edx, DWORD PTR [edi+eax]

; 2186 :      { REAL f;
; 2187 :         f = -1/diff/d;

	fld	ST(0)

; 2188 :         h[1][1][j][j] += f;

	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [eax]

; 2189 :         h[1][0][j][j] -= f;

	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+eax]

; 2190 :         h[0][1][j][j] -= f;

	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+eax]
	lea	edx, DWORD PTR [edx+ecx*8]

; 2191 :         h[0][0][j][j] += f;

	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]

; 2192 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	esi, DWORD PTR _web+616
	xor	edx, edx
	test	esi, esi
	jle	$LN12@hooke2_ene@4
	mov	eax, DWORD PTR _h$[ebp]
	fld	ST(2)
	mov	esi, DWORD PTR [eax+4]
	fdiv	ST(0), ST(2)
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR tv681[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR tv681[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+ecx*4]
	sub	edi, eax
	sub	ebx, eax
	sub	esi, eax
	mov	DWORD PTR tv1041[ebp], esi
	fld	ST(3)
	fdiv	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(2)
$LN10@hooke2_ene@4:

; 2193 :         { f = (1/diff + 1/d)/diff*e_info->sides[0][0][j]*e_info->sides[0][0][jj]/d/d;

	mov	esi, DWORD PTR _e_info$[ebp]
	mov	esi, DWORD PTR [esi+1276]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi]
	fld	QWORD PTR [esi+ecx*8]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fmul	QWORD PTR [esi+edx*8-8]

; 2194 :           h[1][1][j][jj] += f;
; 2195 :           h[1][0][j][jj] -= f;
; 2196 :           h[0][1][j][jj] -= f;
; 2197 :           h[0][0][j][jj] += f;

	mov	esi, DWORD PTR tv1041[ebp]
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(5)
	fld	QWORD PTR [eax+edi-8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax+edi-8]
	fld	QWORD PTR [eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	fld	QWORD PTR [eax+ebx-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax+ebx-8]
	fadd	QWORD PTR [eax+esi-8]
	fstp	QWORD PTR [eax+esi-8]
	mov	esi, DWORD PTR _web+616
	cmp	edx, esi
	jl	SHORT $LN10@hooke2_ene@4

; 2192 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	ebx, DWORD PTR tv1255[ebp]
	fstp	ST(0)
	mov	edi, DWORD PTR tv1250[ebp]
	mov	eax, DWORD PTR tv1167[ebp]
$LN12@hooke2_ene@4:

; 2185 :      for ( j = 0 ; j < SDIM ; j++ )

	inc	ecx
	add	eax, 4
	mov	DWORD PTR tv1167[ebp], eax
	cmp	ecx, esi
	jl	$LN43@hooke2_ene@4
	fstp	ST(3)
	pop	ebx
	fstp	ST(0)
	pop	edi
	fstp	ST(1)
	pop	esi

; 2210 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	fstp	ST(0)

; 2217 :         }
; 2218 :      }
; 2219 :   } 
; 2220 :   return energy;

	fld	QWORD PTR _energy$[ebp]

; 2221 : } // end hooke2_energy_hessian()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@hooke2_ene@4:

; 2198 :         }
; 2199 :      }
; 2200 :   }
; 2201 :   else
; 2202 :   {
; 2203 :      for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	fstp	ST(2)
	fstp	ST(2)
	cmp	DWORD PTR _web+616, ecx
	jle	$LN78@hooke2_ene@4
	fld	ST(1)
	mov	esi, DWORD PTR [edi]
	fmul	ST(0), ST(3)
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+4]
	fdiv	ST(0), ST(4)
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR tv681[ebp], esi
	mov	esi, DWORD PTR [esi]
	sub	edi, eax
	sub	ebx, eax
	sub	esi, eax
	mov	DWORD PTR tv1531[ebp], eax
	mov	DWORD PTR tv1614[ebp], edi
	mov	DWORD PTR tv1619[ebp], ebx
	mov	DWORD PTR tv1624[ebp], esi
	fstp	QWORD PTR tv766[ebp]
	fld	QWORD PTR _ehess$[ebp]
	jmp	SHORT $LN6@hooke2_ene@4
$LN42@hooke2_ene@4:
	mov	esi, DWORD PTR tv1624[ebp]
$LN6@hooke2_ene@4:
	mov	edx, DWORD PTR [edi+eax]

; 2204 :      { REAL f;
; 2205 :         f = hooke2_power*egrad/d;

	fld	QWORD PTR tv766[ebp]

; 2206 :         h[1][1][j][j] += f;

	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [eax]

; 2207 :         h[1][0][j][j] -= f;

	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+eax]

; 2208 :         h[0][1][j][j] -= f;

	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+eax]
	lea	edx, DWORD PTR [edx+ecx*8]

; 2209 :         h[0][0][j][j] += f;

	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]

; 2210 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	esi, DWORD PTR _web+616
	xor	edx, edx
	test	esi, esi
	jle	$LN5@hooke2_ene@4
	mov	eax, DWORD PTR _h$[ebp]
	fld	ST(2)
	fsub	ST(0), ST(2)
	mov	esi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi+ecx*4]
	fmul	ST(0), ST(1)
	fld	ST(4)
	mov	esi, DWORD PTR tv681[ebp]
	mov	esi, DWORD PTR [esi+4]
	fdiv	ST(0), ST(6)
	mov	ebx, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR tv681[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+ecx*4]
	sub	edi, eax
	sub	ebx, eax
	sub	esi, eax
	mov	DWORD PTR tv1405[ebp], esi
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(3)
$LN3@hooke2_ene@4:

; 2211 :         { f = hooke2_power*(ehess*(hooke2_power-1) - egrad/d)
; 2212 :                      *e_info->sides[0][0][j]*e_info->sides[0][0][jj]/d/d;

	mov	esi, DWORD PTR _e_info$[ebp]
	mov	esi, DWORD PTR [esi+1276]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi]
	fld	QWORD PTR [esi+ecx*8]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fmul	QWORD PTR [esi+edx*8-8]

; 2213 :           h[1][1][j][jj] += f;
; 2214 :           h[1][0][j][jj] -= f;
; 2215 :           h[0][1][j][jj] -= f;
; 2216 :           h[0][0][j][jj] += f;

	mov	esi, DWORD PTR tv1405[ebp]
	fdiv	ST(0), ST(6)
	fdiv	ST(0), ST(6)
	fld	QWORD PTR [edi+eax-8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [edi+eax-8]
	fld	QWORD PTR [eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	fld	QWORD PTR [ebx+eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [ebx+eax-8]
	fadd	QWORD PTR [esi+eax-8]
	fstp	QWORD PTR [esi+eax-8]
	mov	esi, DWORD PTR _web+616
	cmp	edx, esi
	jl	SHORT $LN3@hooke2_ene@4

; 2210 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	ebx, DWORD PTR tv1619[ebp]
	fstp	ST(0)
	mov	edi, DWORD PTR tv1614[ebp]
	mov	eax, DWORD PTR tv1531[ebp]
$LN5@hooke2_ene@4:

; 2198 :         }
; 2199 :      }
; 2200 :   }
; 2201 :   else
; 2202 :   {
; 2203 :      for ( j = 0 ; j < SDIM ; j++ )

	inc	ecx
	add	eax, 4
	mov	DWORD PTR tv1531[ebp], eax
	cmp	ecx, esi
	jl	$LN42@hooke2_ene@4

; 2210 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	fstp	ST(4)
	pop	ebx
	fstp	ST(1)
	pop	edi
	fstp	ST(1)
	pop	esi
	fstp	ST(0)
	fstp	ST(0)

; 2217 :         }
; 2218 :      }
; 2219 :   } 
; 2220 :   return energy;

	fld	QWORD PTR _energy$[ebp]

; 2221 : } // end hooke2_energy_hessian()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@hooke2_ene@4:

; 2198 :         }
; 2199 :      }
; 2200 :   }
; 2201 :   else
; 2202 :   {
; 2203 :      for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(2)
	pop	ebx
	fstp	ST(1)
	pop	edi

; 2210 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	fstp	ST(0)
	pop	esi

; 2217 :         }
; 2218 :      }
; 2219 :   } 
; 2220 :   return energy;

	fld	QWORD PTR _energy$[ebp]

; 2221 : } // end hooke2_energy_hessian()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN78@hooke2_ene@4:

; 2198 :         }
; 2199 :      }
; 2200 :   }
; 2201 :   else
; 2202 :   {
; 2203 :      for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(3)
	pop	ebx
	fstp	ST(0)
	pop	edi

; 2210 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	fstp	ST(0)
	pop	esi
	fstp	ST(0)

; 2217 :         }
; 2218 :      }
; 2219 :   } 
; 2220 :   return energy;

	fld	QWORD PTR _energy$[ebp]

; 2221 : } // end hooke2_energy_hessian()

	mov	esp, ebp
	pop	ebp
	ret	0
_hooke2_energy_hessian ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@GMHFOLLJ@frickenhaus_flag?$AA@	; `string'
PUBLIC	??_C@_0N@GJAALAKC@hooke3_power?$AA@		; `string'
PUBLIC	??_C@_0CG@PDBIEBDM@hooke3_energy?5only?5for?5LINEAR?5mo@ ; `string'
PUBLIC	_hooke3_energy_init
_BSS	SEGMENT
_frickenhaus_flag DD 01H DUP (?)
_hooke3_attr DD	01H DUP (?)
_hooke3_power DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BB@GMHFOLLJ@frickenhaus_flag?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BB@GMHFOLLJ@frickenhaus_flag?$AA@ DB 'frickenhaus_flag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GJAALAKC@hooke3_power?$AA@
CONST	SEGMENT
??_C@_0N@GJAALAKC@hooke3_power?$AA@ DB 'hooke3_power', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PDBIEBDM@hooke3_energy?5only?5for?5LINEAR?5mo@
CONST	SEGMENT
??_C@_0CG@PDBIEBDM@hooke3_energy?5only?5for?5LINEAR?5mo@ DB 'hooke3_energ'
	DB	'y only for LINEAR model.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\method1.c
CONST	ENDS
;	COMDAT _hooke3_energy_init
_TEXT	SEGMENT
_one$90441 = -4						; size = 4
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_hooke3_energy_init PROC				; COMDAT

; 2252 : { edge_id e_id;

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 2253 :   int n;
; 2254 : 
; 2255 :   if ( web.modeltype != LINEAR )

	mov	ebx, 1
	cmp	DWORD PTR _web+628, ebx
	je	SHORT $LN10@hooke3_ene

; 2256 :      kb_error(1767,"hooke3_energy only for LINEAR model.\n",RECOVERABLE);

	push	ebx
	push	OFFSET ??_C@_0CG@PDBIEBDM@hooke3_energy?5only?5for?5LINEAR?5mo@
	push	1767					; 000006e7H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN10@hooke3_ene:

; 2257 : 
; 2258 :   exponent_param = lookup_global(POWER3_NAME);

	push	esi
	push	edi
	push	OFFSET ??_C@_0N@GJAALAKC@hooke3_power?$AA@
	call	_lookup_global
	add	esp, 4
	mov	DWORD PTR _exponent_param, eax

; 2259 :   if ( exponent_param < 0 ) /* missing, so add */

	test	eax, eax
	jns	$LN41@hooke3_ene

; 2260 :   { exponent_param = add_global(POWER3_NAME);

	push	OFFSET ??_C@_0N@GJAALAKC@hooke3_power?$AA@
	call	_add_global

; 2261 :     globals(exponent_param)->value.real = 2.0;  /* default */

	mov	esi, eax
	and	esi, -16777216				; ff000000H
	add	esp, 4
	mov	DWORD PTR _exponent_param, eax
	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN13@hooke3_ene
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN15@hooke3_ene
	mov	edi, DWORD PTR _localbase
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	mov	edx, ecx
	imul	edx, 224				; 000000e0H
	add	edx, DWORD PTR [edi]
	jmp	SHORT $LN14@hooke3_ene
$LN15@hooke3_ene:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN13@hooke3_ene
	mov	edx, DWORD PTR _web+5656
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN14@hooke3_ene
$LN13@hooke3_ene:
	mov	edx, DWORD PTR _web+5652
	mov	edi, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [edx+edi]
$LN14@hooke3_ene:
	fld	QWORD PTR __real@4000000000000000
	fstp	QWORD PTR [edx+64]

; 2262 :     globals(exponent_param)->flags |=  ORDINARY_PARAM;

	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN19@hooke3_ene
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN21@hooke3_ene
	mov	edx, DWORD PTR _localbase
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN20@hooke3_ene
$LN21@hooke3_ene:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN19@hooke3_ene
	mov	edx, DWORD PTR _web+5656
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN20@hooke3_ene
$LN19@hooke3_ene:
	mov	edx, DWORD PTR _web+5652
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
$LN20@hooke3_ene:
	or	DWORD PTR [ecx+192], ebx
$LN41@hooke3_ene:

; 2263 :   }
; 2264 :   hooke3_power =  globals(exponent_param)->value.real; 

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN25@hooke3_ene
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN27@hooke3_ene
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN26@hooke3_ene
$LN27@hooke3_ene:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN25@hooke3_ene
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN26@hooke3_ene
$LN25@hooke3_ene:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN26@hooke3_ene:
	fld	QWORD PTR [eax+64]

; 2265 : 
; 2266 :   /* extra edge atribute */
; 2267 :   hooke3_attr = find_attribute(EDGE,HOOKE3_ATTR_NAME);

	push	OFFSET ??_C@_0L@MNDOBNJJ@hooke_size?$AA@
	push	ebx
	fstp	QWORD PTR _hooke3_power
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _hooke3_attr, eax

; 2268 :   if ( hooke3_attr < 0 ) /* not found */

	test	eax, eax
	jns	$LN42@hooke3_ene

; 2269 :   { int one = 1;
; 2270 :     hooke3_attr = add_attribute(EDGE,HOOKE3_ATTR_NAME,REAL_TYPE,0,&one /*dim*/,
; 2271 :           DUMP_ATTR,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	ebx
	lea	ecx, DWORD PTR _one$90441[ebp]
	push	ecx
	push	0
	push	ebx
	push	OFFSET ??_C@_0L@MNDOBNJJ@hooke_size?$AA@
	push	ebx
	mov	DWORD PTR _one$90441[ebp], ebx
	call	_add_attribute

; 2272 :      FOR_ALL_EDGES(e_id)  /* initialize to current length */

	mov	edi, DWORD PTR _web+160
	add	esp, 32					; 00000020H
	mov	DWORD PTR _hooke3_attr, eax
	test	edi, 268435456				; 10000000H
	je	SHORT $LN42@hooke3_ene
	mov	edx, DWORD PTR _web+124
$LL7@hooke3_ene:
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, ebx
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN6@hooke3_ene

; 2273 :      { calc_edge(e_id);

	push	edi
	call	_calc_edge

; 2274 :         *((REAL*)(get_extra(e_id,hooke3_attr))) = get_edge_length(e_id);

	mov	edx, DWORD PTR _hooke3_attr
	mov	eax, edi
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+104]
	add	ecx, edx
	mov	edx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ecx+eax+64]
	add	ebx, DWORD PTR [edx+esi]
	push	edi
	call	_get_edge_length
	add	esp, 8
	fstp	QWORD PTR [ebx]
	mov	edx, DWORD PTR _web+124
	mov	ebx, 1
$LN6@hooke3_ene:

; 2272 :      FOR_ALL_EDGES(e_id)  /* initialize to current length */

	mov	ecx, DWORD PTR [esi+edx]
	mov	edi, DWORD PTR [ecx]
	test	edi, 268435456				; 10000000H
	jne	SHORT $LL7@hooke3_ene
$LN42@hooke3_ene:

; 2275 :      }
; 2276 :   }
; 2277 : 
; 2278 :   n = lookup_global("frickenhaus_flag");

	push	OFFSET ??_C@_0BB@GMHFOLLJ@frickenhaus_flag?$AA@
	call	_lookup_global
	add	esp, 4
	pop	edi
	pop	esi

; 2279 :   if ( (n >= 0) && (globals(n)->value.real != 0.0) ) frickenhaus_flag = 1;

	test	eax, eax
	js	SHORT $LN2@hooke3_ene
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN31@hooke3_ene
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN33@hooke3_ene
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN32@hooke3_ene
$LN33@hooke3_ene:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN31@hooke3_ene
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN32@hooke3_ene
$LN31@hooke3_ene:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN32@hooke3_ene:
	fld	QWORD PTR [eax+64]
	mov	DWORD PTR _frickenhaus_flag, ebx
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@hooke3_ene
$LN2@hooke3_ene:

; 2280 :   else frickenhaus_flag = 0;

	mov	DWORD PTR _frickenhaus_flag, 0
$LN1@hooke3_ene:
	pop	ebx

; 2281 : } // end hooke3_energy_init()

	mov	esp, ebp
	pop	ebp
	ret	0
_hooke3_energy_init ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	??_C@_0BG@NNGIDFGC@Edge?5?$CFs?5has?5?$CFs?5zero?4?6?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	_hooke3_energy
EXTRN	_errmsg:BYTE
EXTRN	_sprintf:PROC
EXTRN	_elnames:BYTE
;	COMDAT __real@3fe0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT ??_C@_0BG@NNGIDFGC@Edge?5?$CFs?5has?5?$CFs?5zero?4?6?$AA@
CONST	SEGMENT
??_C@_0BG@NNGIDFGC@Edge?5?$CFs?5has?5?$CFs?5zero?4?6?$AA@ DB 'Edge %s has'
	DB	' %s zero.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\method1.c
CONST	ENDS
;	COMDAT _hooke3_energy
_TEXT	SEGMENT
_length$ = -8						; size = 8
_e_info$ = 8						; size = 4
_hooke3_energy PROC					; COMDAT

; 2292 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2293 :   REAL d,diff,length;
; 2294 : 
; 2295 :   length = *((REAL*)get_extra(e_info->id,hooke3_attr));

	mov	edx, DWORD PTR _hooke3_attr
	push	ebx
	imul	edx, 240				; 000000f0H
	mov	ebx, DWORD PTR _dymem
	push	esi
	mov	esi, DWORD PTR _e_info$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	edi, edx
	mov	edi, DWORD PTR [edi+ebx+64]
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	fld	QWORD PTR [edi+edx]
	fst	QWORD PTR _length$[ebp]

; 2296 :   if ( length == 0.0 )

	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@hooke3_ene@2

; 2297 :   { sprintf(errmsg,"Edge %s has %s zero.\n",ELNAME(e_info->id),
; 2298 :         HOOKE3_ATTR_NAME);

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN6@hooke3_ene@2
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN7@hooke3_ene@2
$LN6@hooke3_ene@2:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN7@hooke3_ene@2:
	push	OFFSET ??_C@_0L@MNDOBNJJ@hooke_size?$AA@
	push	eax
	push	OFFSET ??_C@_0BG@NNGIDFGC@Edge?5?$CFs?5has?5?$CFs?5zero?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 2299 :      kb_error(2143,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2143					; 0000085fH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN3@hooke3_ene@2:

; 2300 :   }
; 2301 :   d = sqrt(SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]));

	mov	eax, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [ecx]
	push	edx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 2302 :   if ( frickenhaus_flag && (d < length) ) return 0.0;

	cmp	DWORD PTR _frickenhaus_flag, 0
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN10@hooke3_ene@2
	fld	QWORD PTR _length$[ebp]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN10@hooke3_ene@2
	fstp	ST(0)
	fldz

; 2306 : } // hooke3_energy()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@hooke3_ene@2:

; 2303 :   diff = fabs(d - length);

	fsub	QWORD PTR _length$[ebp]
	fabs

; 2304 :   if ( hooke3_power == 0.0 ) return -log(diff);

	fld	QWORD PTR _hooke3_power
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@hooke3_ene@2
	fstp	ST(0)
	call	__CIlog
	fchs

; 2306 : } // hooke3_energy()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@hooke3_ene@2:

; 2305 :   return 0.5*pow(diff,hooke3_power)/length;

	call	__CIpow
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _length$[ebp]

; 2306 : } // hooke3_energy()

	mov	esp, ebp
	pop	ebp
	ret	0
_hooke3_energy ENDP
_TEXT	ENDS
PUBLIC	_hooke3_energy_gradient
; Function compile flags: /Ogtp
;	COMDAT _hooke3_energy_gradient
_TEXT	SEGMENT
_d$ = -24						; size = 8
_diff$ = -16						; size = 8
_length$ = -8						; size = 8
_e_info$ = 8						; size = 4
_hooke3_energy_gradient PROC				; COMDAT

; 2319 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi

; 2320 :   REAL d,diff,coeff;
; 2321 :   REAL energy;
; 2322 :   int j;
; 2323 :   REAL length;
; 2324 : 
; 2325 :   length = *((REAL*)get_extra(e_info->id,hooke3_attr));

	mov	esi, DWORD PTR _e_info$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	push	edi
	mov	edi, DWORD PTR _hooke3_attr
	imul	edi, 240				; 000000f0H
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	add	eax, edi
	mov	eax, DWORD PTR [eax+edx+64]
	fld	QWORD PTR [ecx+eax]

; 2326 :   d = sqrt(SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]));

	mov	ecx, DWORD PTR [esi+1276]
	mov	edx, DWORD PTR [ecx]
	fstp	QWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fst	QWORD PTR _d$[ebp]

; 2327 :   if ( frickenhaus_flag && (d < length) ) return 0.0;

	cmp	DWORD PTR _frickenhaus_flag, 0
	je	SHORT $LN14@hooke3_ene@3
	fld	QWORD PTR _length$[ebp]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN14@hooke3_ene@3
	pop	edi
	fstp	ST(0)
	fldz
	pop	esi

; 2342 :   }
; 2343 :   return energy;
; 2344 : } // end hooke3_energy_gradient()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@hooke3_ene@3:

; 2328 :   diff = (d - length);

	fsub	QWORD PTR _length$[ebp]
	fst	QWORD PTR _diff$[ebp]

; 2329 :   if ( diff == 0.0 ) return 0.0;

	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@hooke3_ene@3
	pop	edi
	fstp	ST(1)
	pop	esi

; 2342 :   }
; 2343 :   return energy;
; 2344 : } // end hooke3_energy_gradient()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@hooke3_ene@3:

; 2330 :   if ( hooke3_power == 0.0 )

	fld	QWORD PTR _hooke3_power
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@hooke3_ene@3
	fstp	ST(0)

; 2331 :   { energy = -log(fabs(diff));

	fabs
	call	__CIlog
	fchs

; 2332 :     coeff = -1/diff/d;

	fld	QWORD PTR __real@bff0000000000000

; 2333 :   }
; 2334 :   else

	jmp	SHORT $LN30@hooke3_ene@3
$LN5@hooke3_ene@3:

; 2335 :   { energy = 0.5*pow(fabs(diff),hooke3_power)/length;

	fxch	ST(1)
	fabs
	fxch	ST(1)
	call	__CIpow
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _length$[ebp]

; 2336 :     coeff  = hooke3_power*energy/diff/d;

	fld	QWORD PTR _hooke3_power
	fmul	ST(0), ST(1)
$LN30@hooke3_ene@3:
	fdiv	QWORD PTR _diff$[ebp]

; 2337 :   }
; 2338 :   for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	fdiv	QWORD PTR _d$[ebp]
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN29@hooke3_ene@3
$LN3@hooke3_ene@3:

; 2339 :   {
; 2340 :      e_info->grad[0][j] = -coeff*e_info->sides[0][0][j];

	mov	edx, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx]
	fld	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR [esi+1336]
	mov	edx, DWORD PTR [ecx]
	fmul	ST(0), ST(1)
	inc	eax
	fchs
	fstp	QWORD PTR [edx+eax*8-8]

; 2341 :      e_info->grad[1][j] = coeff*e_info->sides[0][0][j];

	mov	ecx, DWORD PTR [esi+1276]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	fld	QWORD PTR [ecx+eax*8-8]
	mov	edx, DWORD PTR [esi+1336]
	mov	ecx, DWORD PTR [edx+4]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [ecx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@hooke3_ene@3
$LN29@hooke3_ene@3:
	pop	edi

; 2337 :   }
; 2338 :   for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
	pop	esi

; 2342 :   }
; 2343 :   return energy;
; 2344 : } // end hooke3_energy_gradient()

	mov	esp, ebp
	pop	ebp
	ret	0
_hooke3_energy_gradient ENDP
_TEXT	ENDS
PUBLIC	_hooke3_energy_hessian
; Function compile flags: /Ogtp
;	COMDAT _hooke3_energy_hessian
_TEXT	SEGMENT
tv772 = -56						; size = 8
_energy$ = -48						; size = 8
_length$ = -40						; size = 8
tv1635 = -36						; size = 4
tv1261 = -36						; size = 4
_ehess$ = -32						; size = 8
_diff$ = -32						; size = 8
tv1416 = -28						; size = 4
tv1266 = -28						; size = 4
_d$ = -24						; size = 8
tv1630 = -20						; size = 4
tv1052 = -20						; size = 4
tv1625 = -16						; size = 4
tv1271 = -16						; size = 4
_h$ = -12						; size = 4
tv1542 = -8						; size = 4
tv1178 = -8						; size = 4
tv687 = -4						; size = 4
tv90 = -4						; size = 4
tv87 = -4						; size = 4
_e_info$ = 8						; size = 4
_hooke3_energy_hessian PROC				; COMDAT

; 2356 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 2357 :   REAL d,diff,coeff,egrad,ehess;
; 2358 :   REAL energy;
; 2359 :   int j,jj;
; 2360 :   REAL ****h = e_info->hess;
; 2361 :   REAL length;
; 2362 : 
; 2363 :   length = *((REAL*)get_extra(e_info->id,hooke3_attr));

	mov	edx, DWORD PTR _hooke3_attr
	push	ebx
	imul	edx, 240				; 000000f0H
	push	esi
	mov	esi, DWORD PTR _e_info$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ebx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	ebx, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [ebx+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]

; 2364 :   d = sqrt(SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]));

	mov	ecx, DWORD PTR [esi+1276]
	push	edi
	fld	QWORD PTR [edx+eax]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	fstp	QWORD PTR _length$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edi, DWORD PTR [esi+1340]
	push	ecx
	push	eax
	push	eax
	mov	DWORD PTR _h$[ebp], edi
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fst	QWORD PTR _d$[ebp]

; 2365 :   if ( d == 0 ) 

	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN24@hooke3_ene@4
$LN107@hooke3_ene@4:
	pop	edi
	fstp	ST(1)
	pop	esi
	pop	ebx

; 2432 : } // end hooke3_energy_hessian()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@hooke3_ene@4:

; 2366 :     return 0.0;
; 2367 :   if ( frickenhaus_flag && (d < length) ) 

	xor	ebx, ebx
	cmp	DWORD PTR _frickenhaus_flag, ebx
	je	SHORT $LN43@hooke3_ene@4
	fld	QWORD PTR _length$[ebp]
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H

; 2368 :     return 0.0;

	je	SHORT $LN107@hooke3_ene@4
$LN43@hooke3_ene@4:

; 2369 :   diff = (d - length);

	fld	ST(1)
	fsub	QWORD PTR _length$[ebp]
	fst	QWORD PTR _diff$[ebp]

; 2370 :   if ( diff == 0.0 ) 

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	fld1
	test	ah, 68					; 00000044H
	jp	SHORT $LN55@hooke3_ene@4

; 2371 :   { energy = 0.0;

	fxch	ST(2)

; 2372 :     egrad = hooke3_power == 1 ? 1 : 0;

	mov	DWORD PTR tv87[ebp], 1
	fst	QWORD PTR _energy$[ebp]
	fld	QWORD PTR _hooke3_power
	fld	ST(0)
	fld	ST(4)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN28@hooke3_ene@4
	mov	DWORD PTR tv87[ebp], ebx
$LN28@hooke3_ene@4:
	fild	DWORD PTR tv87[ebp]

; 2373 :     ehess = hooke3_power == 2 ? 1 : 0;

	mov	DWORD PTR tv90[ebp], 1
	fld	ST(1)
	fld	QWORD PTR __real@4000000000000000
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN30@hooke3_ene@4
	mov	DWORD PTR tv90[ebp], ebx
$LN30@hooke3_ene@4:
	fild	DWORD PTR tv90[ebp]

; 2374 :   }
; 2375 :   else

	mov	edx, DWORD PTR _web+616
	fstp	QWORD PTR _ehess$[ebp]
	jmp	$LN21@hooke3_ene@4
$LN55@hooke3_ene@4:

; 2370 :   if ( diff == 0.0 ) 

	fstp	ST(3)
	fstp	ST(2)

; 2376 :   {
; 2377 :     if ( hooke3_power == 0.0 )

	fld	QWORD PTR _hooke3_power
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@hooke3_ene@4
	fstp	ST(0)

; 2378 :     { energy = -log(fabs(diff));

	fabs
	call	__CIlog
	fchs
	fst	QWORD PTR _energy$[ebp]

; 2379 :       coeff = -1/diff/d;

	fld	QWORD PTR __real@bff0000000000000
	fld	QWORD PTR _diff$[ebp]
	fdiv	ST(1), ST(0)
	fld	QWORD PTR _d$[ebp]
	fdiv	ST(2), ST(0)

; 2380 :     }
; 2381 :     else

	fld	QWORD PTR _hooke3_power
	jmp	SHORT $LN19@hooke3_ene@4
$LN20@hooke3_ene@4:

; 2382 :     { energy = 0.5*pow(fabs(diff),hooke3_power)/length;

	fxch	ST(1)
	fabs
	fxch	ST(1)
	call	__CIpow
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _length$[ebp]
	fst	QWORD PTR _energy$[ebp]

; 2383 :       coeff  = hooke3_power*energy/diff/d;

	fld	QWORD PTR _hooke3_power
	fld	ST(0)
	fmul	ST(0), ST(2)
	fld	QWORD PTR _diff$[ebp]
	fdiv	ST(1), ST(0)
	fld	QWORD PTR _d$[ebp]
	fdiv	ST(2), ST(0)
	fxch	ST(2)
	fxch	ST(3)
	fxch	ST(1)
	fxch	ST(2)
	fxch	ST(1)
$LN19@hooke3_ene@4:

; 2384 :     }
; 2385 :     for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR _web+616
	xor	eax, eax
	cmp	edx, ebx
	jle	SHORT $LN103@hooke3_ene@4
$LN18@hooke3_ene@4:

; 2386 :     {
; 2387 :       e_info->grad[0][j] = -coeff*e_info->sides[0][0][j];

	mov	edx, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx]
	fld	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR [esi+1336]
	mov	edx, DWORD PTR [ecx]
	fmul	ST(0), ST(4)
	inc	eax
	fchs
	fstp	QWORD PTR [edx+eax*8-8]

; 2388 :       e_info->grad[1][j] = coeff*e_info->sides[0][0][j];

	mov	ecx, DWORD PTR [esi+1276]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	fld	QWORD PTR [ecx+eax*8-8]
	mov	edx, DWORD PTR [esi+1336]
	mov	ecx, DWORD PTR [edx+4]
	fmul	ST(0), ST(4)
	fstp	QWORD PTR [ecx+eax*8-8]
	mov	edx, DWORD PTR _web+616
	cmp	eax, edx
	jl	SHORT $LN18@hooke3_ene@4
$LN103@hooke3_ene@4:

; 2384 :     }
; 2385 :     for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(3)

; 2389 :     }
; 2390 :     egrad = energy/diff;

	fxch	ST(3)
	fdiv	ST(0), ST(1)
	fld	ST(0)

; 2391 :     ehess = energy/diff/diff;

	fxch	ST(1)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _ehess$[ebp]
	fldz
	fld1
	fxch	ST(4)
	fxch	ST(1)
	fxch	ST(2)
$LN21@hooke3_ene@4:

; 2392 :   }
; 2393 :   
; 2394 :   if ( hooke3_power == 0.0 )

	fld	ST(1)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN67@hooke3_ene@4
	fstp	ST(1)
	fstp	ST(0)

; 2395 :   {  if ( diff )

	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN70@hooke3_ene@4

; 2396 :      for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	edx, ebx
	jle	$LN70@hooke3_ene@4
	fld	QWORD PTR __real@bff0000000000000
	mov	esi, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	fdiv	ST(0), ST(1)
	mov	eax, DWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR tv687[ebp], esi
	mov	esi, DWORD PTR [esi]
	sub	edi, eax
	sub	ebx, eax
	sub	esi, eax
	mov	DWORD PTR tv1178[ebp], eax
	mov	DWORD PTR tv1261[ebp], edi
	mov	DWORD PTR tv1266[ebp], ebx
	mov	DWORD PTR tv1271[ebp], esi
	fdiv	ST(0), ST(3)
	jmp	SHORT $LN13@hooke3_ene@4
$LN45@hooke3_ene@4:
	mov	esi, DWORD PTR tv1271[ebp]
$LN13@hooke3_ene@4:
	mov	edx, DWORD PTR [edi+eax]

; 2397 :      { REAL f;
; 2398 :         f = -1/diff/d;

	fld	ST(0)

; 2399 :         h[1][1][j][j] += f;

	fld	ST(0)
	lea	edx, DWORD PTR [edx+ecx*8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [eax]

; 2400 :         h[1][0][j][j] -= f;

	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+eax]

; 2401 :         h[0][1][j][j] -= f;

	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+eax]
	lea	edx, DWORD PTR [edx+ecx*8]

; 2402 :         h[0][0][j][j] += f;

	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]

; 2403 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	esi, DWORD PTR _web+616
	xor	edx, edx
	test	esi, esi
	jle	$LN12@hooke3_ene@4
	mov	eax, DWORD PTR _h$[ebp]
	fld	ST(2)
	mov	esi, DWORD PTR [eax+4]
	fdiv	ST(0), ST(2)
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR tv687[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR tv687[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+ecx*4]
	sub	edi, eax
	sub	ebx, eax
	sub	esi, eax
	mov	DWORD PTR tv1052[ebp], esi
	fld	ST(3)
	fdiv	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(2)
$LN10@hooke3_ene@4:

; 2404 :         { f = (1/diff + 1/d)/diff*e_info->sides[0][0][j]*e_info->sides[0][0][jj]/d/d;

	mov	esi, DWORD PTR _e_info$[ebp]
	mov	esi, DWORD PTR [esi+1276]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi]
	fld	QWORD PTR [esi+ecx*8]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fmul	QWORD PTR [esi+edx*8-8]

; 2405 :           h[1][1][j][jj] += f;
; 2406 :           h[1][0][j][jj] -= f;
; 2407 :           h[0][1][j][jj] -= f;
; 2408 :           h[0][0][j][jj] += f;

	mov	esi, DWORD PTR tv1052[ebp]
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(5)
	fld	QWORD PTR [eax+edi-8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax+edi-8]
	fld	QWORD PTR [eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	fld	QWORD PTR [eax+ebx-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax+ebx-8]
	fadd	QWORD PTR [eax+esi-8]
	fstp	QWORD PTR [eax+esi-8]
	mov	esi, DWORD PTR _web+616
	cmp	edx, esi
	jl	SHORT $LN10@hooke3_ene@4

; 2403 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	ebx, DWORD PTR tv1266[ebp]
	fstp	ST(0)
	mov	edi, DWORD PTR tv1261[ebp]
	mov	eax, DWORD PTR tv1178[ebp]
$LN12@hooke3_ene@4:

; 2396 :      for ( j = 0 ; j < SDIM ; j++ )

	inc	ecx
	add	eax, 4
	mov	DWORD PTR tv1178[ebp], eax
	cmp	ecx, esi
	jl	$LN45@hooke3_ene@4
	fstp	ST(3)
	pop	edi
	fstp	ST(0)
	pop	esi
	fstp	ST(1)
	pop	ebx

; 2421 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	fstp	ST(0)

; 2428 :         }
; 2429 :      }
; 2430 :   } 
; 2431 :   return energy;

	fld	QWORD PTR _energy$[ebp]

; 2432 : } // end hooke3_energy_hessian()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN67@hooke3_ene@4:

; 2392 :   }
; 2393 :   
; 2394 :   if ( hooke3_power == 0.0 )

	fstp	ST(3)

; 2409 :         }
; 2410 :      }
; 2411 :   }
; 2412 :   else
; 2413 :   {
; 2414 :      for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	fstp	ST(1)
	cmp	edx, ebx
	jle	$LN86@hooke3_ene@4
	fld	ST(0)
	mov	esi, DWORD PTR [edi]
	fmul	ST(0), ST(2)
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+4]
	fdiv	ST(0), ST(4)
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR tv687[ebp], esi
	mov	esi, DWORD PTR [esi]
	sub	edi, eax
	sub	ebx, eax
	sub	esi, eax
	mov	DWORD PTR tv1542[ebp], eax
	mov	DWORD PTR tv1625[ebp], edi
	mov	DWORD PTR tv1630[ebp], ebx
	mov	DWORD PTR tv1635[ebp], esi
	fstp	QWORD PTR tv772[ebp]
	fld	QWORD PTR _ehess$[ebp]
	jmp	SHORT $LN6@hooke3_ene@4
$LN44@hooke3_ene@4:
	mov	esi, DWORD PTR tv1635[ebp]
$LN6@hooke3_ene@4:

; 2415 :      { REAL f;
; 2416 :         f = hooke3_power*egrad/d;

	fld	QWORD PTR tv772[ebp]
	mov	edx, DWORD PTR [edi+eax]

; 2417 :         h[1][1][j][j] += f;

	fld	ST(0)
	lea	edx, DWORD PTR [edx+ecx*8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [eax]

; 2418 :         h[1][0][j][j] -= f;

	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+eax]

; 2419 :         h[0][1][j][j] -= f;

	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+eax]
	lea	edx, DWORD PTR [edx+ecx*8]

; 2420 :         h[0][0][j][j] += f;

	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]

; 2421 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	esi, DWORD PTR _web+616
	xor	edx, edx
	test	esi, esi
	jle	$LN5@hooke3_ene@4
	fld	ST(1)
	mov	eax, DWORD PTR _h$[ebp]
	fsub	ST(0), ST(4)
	mov	esi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi+ecx*4]
	fmul	ST(0), ST(1)
	fld	ST(3)
	mov	esi, DWORD PTR tv687[ebp]
	mov	esi, DWORD PTR [esi+4]
	fdiv	ST(0), ST(6)
	mov	ebx, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR tv687[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+ecx*4]
	sub	edi, eax
	sub	ebx, eax
	sub	esi, eax
	mov	DWORD PTR tv1416[ebp], esi
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
$LN3@hooke3_ene@4:

; 2422 :         { f = hooke3_power*(ehess*(hooke3_power-1) - egrad/d)
; 2423 :                      *e_info->sides[0][0][j]*e_info->sides[0][0][jj]/d/d;

	mov	esi, DWORD PTR _e_info$[ebp]
	mov	esi, DWORD PTR [esi+1276]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi]
	fld	QWORD PTR [esi+ecx*8]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fmul	QWORD PTR [esi+edx*8-8]

; 2424 :           h[1][1][j][jj] += f;
; 2425 :           h[1][0][j][jj] -= f;
; 2426 :           h[0][1][j][jj] -= f;
; 2427 :           h[0][0][j][jj] += f;

	mov	esi, DWORD PTR tv1416[ebp]
	fdiv	ST(0), ST(6)
	fdiv	ST(0), ST(6)
	fld	QWORD PTR [edi+eax-8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [edi+eax-8]
	fld	QWORD PTR [eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	fld	QWORD PTR [ebx+eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [ebx+eax-8]
	fadd	QWORD PTR [esi+eax-8]
	fstp	QWORD PTR [esi+eax-8]
	mov	esi, DWORD PTR _web+616
	cmp	edx, esi
	jl	SHORT $LN3@hooke3_ene@4

; 2421 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	ebx, DWORD PTR tv1630[ebp]
	fstp	ST(0)
	mov	edi, DWORD PTR tv1625[ebp]
	mov	eax, DWORD PTR tv1542[ebp]
$LN5@hooke3_ene@4:

; 2409 :         }
; 2410 :      }
; 2411 :   }
; 2412 :   else
; 2413 :   {
; 2414 :      for ( j = 0 ; j < SDIM ; j++ )

	inc	ecx
	add	eax, 4
	mov	DWORD PTR tv1542[ebp], eax
	cmp	ecx, esi
	jl	$LN44@hooke3_ene@4

; 2421 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	fstp	ST(4)
	pop	edi
	fstp	ST(0)
	pop	esi
	fstp	ST(0)
	pop	ebx
	fstp	ST(0)
	fstp	ST(0)

; 2428 :         }
; 2429 :      }
; 2430 :   } 
; 2431 :   return energy;

	fld	QWORD PTR _energy$[ebp]

; 2432 : } // end hooke3_energy_hessian()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN86@hooke3_ene@4:

; 2409 :         }
; 2410 :      }
; 2411 :   }
; 2412 :   else
; 2413 :   {
; 2414 :      for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(3)
$LN70@hooke3_ene@4:
	fstp	ST(2)
	pop	edi
	fstp	ST(1)
	pop	esi

; 2421 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	fstp	ST(0)
	pop	ebx

; 2428 :         }
; 2429 :      }
; 2430 :   } 
; 2431 :   return energy;

	fld	QWORD PTR _energy$[ebp]

; 2432 : } // end hooke3_energy_hessian()

	mov	esp, ebp
	pop	ebp
	ret	0
_hooke3_energy_hessian ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@KBAMACPO@circular_arc_length?5method?5needs@ ; `string'
PUBLIC	_circular_arc_length_init
EXTRN	_circular_arc_flag:DWORD
;	COMDAT ??_C@_0DN@KBAMACPO@circular_arc_length?5method?5needs@
CONST	SEGMENT
??_C@_0DN@KBAMACPO@circular_arc_length?5method?5needs@ DB 'circular_arc_l'
	DB	'ength method needs LINEAR or QUADRATIC model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _circular_arc_length_init
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_circular_arc_length_init PROC				; COMDAT

; 2475 :   if ( (web.modeltype == LAGRANGE) && (web.lagrange_order >= 2) )

	cmp	DWORD PTR _web+628, 3
	jne	SHORT $LN5@circular_a
	cmp	DWORD PTR _web+632, 2
	jl	SHORT $LN5@circular_a

; 2476 :     kb_error(3371,"circular_arc_length method needs LINEAR or QUADRATIC model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DN@KBAMACPO@circular_arc_length?5method?5needs@
	push	3371					; 00000d2bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN5@circular_a:

; 2477 :   circular_arc_flag = 1;

	mov	DWORD PTR _circular_arc_flag, 1

; 2478 : } // end circular_arc_length_init()

	ret	0
_circular_arc_length_init ENDP
_TEXT	ENDS
PUBLIC	_circ_debug
EXTRN	__CIatan2:PROC
; Function compile flags: /Ogtp
;	COMDAT _circ_debug
_TEXT	SEGMENT
_denom2$ = -16						; size = 8
_denom1$ = -8						; size = 8
_dx1$ = 8						; size = 8
_dx2$ = 16						; size = 8
_dy1$ = 24						; size = 8
_dy2$ = 32						; size = 8
_chord$ = 40						; size = 4
_sinth$ = 44						; size = 4
_costh$ = 48						; size = 4
_angle$ = 52						; size = 4
_circ_debug PROC					; COMDAT

; 2497 : { REAL denom1,denom2;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2498 :   denom1 = sqrt(dx1*dx1+dy1*dy1);

	fld	QWORD PTR _dx1$[ebp]
	fmul	ST(0), ST(0)
	fld	QWORD PTR _dy1$[ebp]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR _denom1$[ebp]

; 2499 :   denom2 = sqrt(dx2*dx2+dy2*dy2);

	fld	QWORD PTR _dx2$[ebp]
	fmul	ST(0), ST(0)
	fld	QWORD PTR _dy2$[ebp]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fst	QWORD PTR _denom2$[ebp]

; 2500 :   if (denom1*denom2 == 0.0) return;

	fmul	QWORD PTR _denom1$[ebp]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@circ_debug

; 2501 :   *chord = sqrt((dx1+dx2)*(dx1+dx2)+(dy1+dy2)*(dy1+dy2));

	fld	QWORD PTR _dx1$[ebp]
	fadd	QWORD PTR _dx2$[ebp]
	fld	QWORD PTR _dy1$[ebp]
	fadd	QWORD PTR _dy2$[ebp]
	fmul	ST(0), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	mov	eax, DWORD PTR _chord$[ebp]
	fstp	QWORD PTR [eax]

; 2502 :   *sinth = (dx1*dy2 - dy1*dx2)/denom1/denom2;

	mov	eax, DWORD PTR _sinth$[ebp]
	fld	QWORD PTR _dx1$[ebp]

; 2503 :   *costh = (dx1*dx2 + dy1*dy2)/denom1/denom2;

	mov	ecx, DWORD PTR _costh$[ebp]
	fld	ST(0)
	fld	QWORD PTR _dy2$[ebp]
	fmul	ST(1), ST(0)
	fld	QWORD PTR _dx2$[ebp]
	fld	ST(0)
	fld	QWORD PTR _dy1$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(4)
	fsubrp	ST(1), ST(0)
	fld	QWORD PTR _denom1$[ebp]
	fdiv	ST(1), ST(0)
	fld	QWORD PTR _denom2$[ebp]
	fdiv	ST(2), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR [eax]
	fxch	ST(5)
	fmulp	ST(2), ST(0)
	fxch	ST(3)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fdivrp	ST(2), ST(0)
	fdivp	ST(1), ST(0)
	fst	QWORD PTR [ecx]

; 2504 :   *angle = atan2(*sinth,*costh);

	fld	QWORD PTR [eax]
	fxch	ST(1)
	call	__CIatan2
	mov	edx, DWORD PTR _angle$[ebp]
	fstp	QWORD PTR [edx]
$LN2@circ_debug:

; 2505 : } // end circ_debug()

	mov	esp, ebp
	pop	ebp
	ret	0
_circ_debug ENDP
_TEXT	ENDS
PUBLIC	_circular_arc_aux
; Function compile flags: /Ogtp
;	COMDAT _circular_arc_aux
_TEXT	SEGMENT
_sinth$ = -136						; size = 8
tv4696 = -128						; size = 8
tv4712 = -120						; size = 8
tv5393 = -112						; size = 8
tv4710 = -112						; size = 8
tv4995 = -104						; size = 8
tv4866 = -104						; size = 8
tv5003 = -96						; size = 8
tv4679 = -96						; size = 8
tv4946 = -88						; size = 8
tv4676 = -88						; size = 8
tv4699 = -80						; size = 8
tv4709 = -72						; size = 8
tv4651 = -72						; size = 8
tv4745 = -64						; size = 8
tv4720 = -64						; size = 8
tv4654 = -64						; size = 8
tv4704 = -56						; size = 8
tv8731 = -52						; size = 4
tv4736 = -48						; size = 8
_denom2$ = -48						; size = 8
tv4957 = -40						; size = 8
tv4751 = -40						; size = 8
tv8707 = -36						; size = 4
_jj$ = -36						; size = 4
tv5391 = -32						; size = 8
tv5064 = -32						; size = 8
tv4920 = -32						; size = 8
tv4876 = -32						; size = 8
tv4718 = -24						; size = 8
_denom1$ = -24						; size = 8
tv4956 = -16						; size = 8
_chord$ = -16						; size = 8
tv8702 = -12						; size = 4
tv7387 = -12						; size = 4
_costh$ = -8						; size = 8
tv4927 = 8						; size = 8
tv4738 = 8						; size = 8
tv4700 = 8						; size = 8
_dx1$ = 8						; size = 8
tv8760 = 12						; size = 4
tv7416 = 12						; size = 4
_ii$ = 12						; size = 4
tv4937 = 16						; size = 8
tv4741 = 16						; size = 8
tv4705 = 16						; size = 8
_dy1$ = 16						; size = 8
tv4487 = 20						; size = 4
tv480 = 20						; size = 4
_j$ = 20						; size = 4
tv5068 = 24						; size = 8
tv4993 = 24						; size = 8
tv4980 = 24						; size = 8
tv4922 = 24						; size = 8
tv4747 = 24						; size = 8
tv4714 = 24						; size = 8
_dx2$ = 24						; size = 8
tv8908 = 28						; size = 4
tv7515 = 28						; size = 4
tv7425 = 28						; size = 4
tv7293 = 28						; size = 4
tv5409 = 28						; size = 4
tv524 = 28						; size = 4
_dy2$ = 32						; size = 8
tv8592 = 36						; size = 4
_chordptr$ = 40						; size = 4
_dchord$ = 44						; size = 4
_ddchord$ = 48						; size = 4
_sinthptr$ = 52						; size = 4
_dsinth$ = 56						; size = 4
_ddsinth$ = 60						; size = 4
_costhptr$ = 64						; size = 4
_dcosth$ = 68						; size = 4
_ddcosth$ = 72						; size = 4
_angleptr$ = 76						; size = 4
_dangle$ = 80						; size = 4
_ddangle$ = 84						; size = 4
_mode$ = 88						; size = 4
_circular_arc_aux PROC					; COMDAT

; 2515 : { REAL chord,sinth,costh,angle;

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H

; 2516 :   REAL denom1,denom2;
; 2517 :   int i,j,ii,jj;
; 2518 : 
; 2519 :   denom1 = sqrt(dx1*dx1+dy1*dy1);

	fld	QWORD PTR _dx1$[ebp]
	fmul	ST(0), ST(0)
	fld	QWORD PTR _dy1$[ebp]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR _denom1$[ebp]

; 2520 :   denom2 = sqrt(dx2*dx2+dy2*dy2);

	fld	QWORD PTR _dx2$[ebp]
	fmul	ST(0), ST(0)
	fld	QWORD PTR _dy2$[ebp]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fst	QWORD PTR _denom2$[ebp]

; 2521 :   if (denom1*denom2 == 0.0) {*chordptr = 0.0; return ;}

	fmul	QWORD PTR _denom1$[ebp]
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN367@circular_a@2
	mov	eax, DWORD PTR _chordptr$[ebp]
	fstp	QWORD PTR [eax]

; 2697 : 
; 2698 : 
; 2699 : #ifdef XXX
; 2700 : /* debugging */
; 2701 : { REAL dx[2][2];
; 2702 :   REAL ch[4],si[4],co[4],an[4];
; 2703 :   REAL delta = 1e-4;
; 2704 :   dx[0][0] = dx1;
; 2705 :   dx[0][1] = dy1;
; 2706 :   dx[1][0] = dx2;
; 2707 :   dx[1][1] = dy2;
; 2708 : 
; 2709 : /* check numerically */
; 2710 :   
; 2711 : 
; 2712 :   for ( i = 0 ; i < 2; i++ )
; 2713 :    for ( j = 0 ; j < 2; j++ )
; 2714 :     for ( ii = 0 ; ii < 2 ; ii ++ )
; 2715 :      for ( jj = 0 ; jj < 2 ; jj ++ )
; 2716 :      { dx[i][j] += delta;
; 2717 :        dx[ii][jj] += delta;
; 2718 :        circ_debug(dx[0][0],dx[0][1],dx[1][0],dx[1][1],&ch[0],&si[0],
; 2719 :          &co[0],&an[0]);
; 2720 :        dx[i][j] -= 2*delta;
; 2721 :        circ_debug(dx[0][0],dx[0][1],dx[1][0],dx[1][1],&ch[1],&si[1],
; 2722 :          &co[1],&an[1]);
; 2723 :        dx[ii][jj] -= 2*delta;
; 2724 :        circ_debug(dx[0][0],dx[0][1],dx[1][0],dx[1][1],&ch[3],&si[3],
; 2725 :          &co[3],&an[3]);
; 2726 :        dx[i][j] += 2*delta;
; 2727 :        circ_debug(dx[0][0],dx[0][1],dx[1][0],dx[1][1],&ch[2],&si[2],
; 2728 :          &co[2],&an[2]);
; 2729 :        dx[ii][jj] += 2*delta;
; 2730 : 
; 2731 :        printf("ddchord[%d][%d][%d][%d]: %18.15f %18.15f\n",2*i,j,2*ii,jj,
; 2732 :           (ch[0]-ch[1]-ch[2]+ch[3])/delta/delta/4,ddchord[2*i][j][2*ii][jj]);
; 2733 :        printf("ddsinth[%d][%d][%d][%d]: %18.15f %18.15f\n",2*i,j,2*ii,jj,
; 2734 :           (si[0]-si[1]-si[2]+si[3])/delta/delta/4,ddsinth[2*i][j][2*ii][jj]);
; 2735 :        printf("ddcosth[%d][%d][%d][%d]: %18.15f %18.15f\n",2*i,j,2*ii,jj,
; 2736 :           (co[0]-co[1]-co[2]+co[3])/delta/delta/4,ddcosth[2*i][j][2*ii][jj]);
; 2737 :        printf("ddangle[%d][%d][%d][%d]: %18.15f %18.15f\n",2*i,j,2*ii,jj,
; 2738 :           (an[0]-an[1]-an[2]+an[3])/delta/delta/4,ddangle[2*i][j][2*ii][jj]);
; 2739 :      }
; 2740 : }
; 2741 : #endif
; 2742 : 
; 2743 :    return;
; 2744 : } // end void circular_arc_aux()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN367@circular_a@2:

; 2521 :   if (denom1*denom2 == 0.0) {*chordptr = 0.0; return ;}

	fstp	ST(0)

; 2522 :   *chordptr = chord = sqrt((dx1+dx2)*(dx1+dx2)+(dy1+dy2)*(dy1+dy2));

	fld	QWORD PTR _dx1$[ebp]
	fadd	QWORD PTR _dx2$[ebp]
	fst	QWORD PTR tv4651[ebp]
	fld	QWORD PTR _dy1$[ebp]
	fadd	QWORD PTR _dy2$[ebp]
	fst	QWORD PTR tv4654[ebp]
	fmul	ST(0), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fst	QWORD PTR _chord$[ebp]
	mov	ecx, DWORD PTR _chordptr$[ebp]
	fstp	QWORD PTR [ecx]

; 2523 :   *sinthptr = sinth = (dx1*dy2 - dy1*dx2)/denom1/denom2;

	mov	edx, DWORD PTR _sinthptr$[ebp]
	fld	QWORD PTR _dx1$[ebp]

; 2524 :   *costhptr = costh = (dx1*dx2 + dy1*dy2)/denom1/denom2;

	mov	eax, DWORD PTR _costhptr$[ebp]
	fld	ST(0)
	fld	QWORD PTR _dy2$[ebp]
	fmul	ST(1), ST(0)
	fld	QWORD PTR _dy1$[ebp]
	fld	ST(0)
	fld	QWORD PTR _dx2$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(4)
	fsubrp	ST(1), ST(0)
	fld	QWORD PTR _denom1$[ebp]
	fdiv	ST(1), ST(0)
	fld	QWORD PTR _denom2$[ebp]
	fdiv	ST(2), ST(0)
	fxch	ST(2)
	fst	QWORD PTR _sinth$[ebp]
	fst	QWORD PTR [edx]
	fxch	ST(6)
	fmulp	ST(5), ST(0)
	fxch	ST(2)
	fmulp	ST(3), ST(0)
	fxch	ST(3)
	faddp	ST(2), ST(0)
	fdivp	ST(1), ST(0)
	fdivrp	ST(1), ST(0)
	fst	QWORD PTR _costh$[ebp]
	fst	QWORD PTR [eax]

; 2525 :   angle = atan2(sinth,costh);

	call	__CIatan2

; 2526 :   *angleptr = angle;
; 2527 : 
; 2528 :   if ( mode == METHOD_VALUE ) return;

	mov	edx, DWORD PTR _mode$[ebp]
	mov	ecx, DWORD PTR _angleptr$[ebp]
	fstp	QWORD PTR [ecx]
	cmp	edx, 1767				; 000006e7H
	je	$LN10@circular_a@2

; 2529 : 
; 2530 :   dchord[0][0] = -(dx1+dx2)/chord;

	fld	QWORD PTR tv4651[ebp]
	mov	ecx, DWORD PTR _dchord$[ebp]
	fld	QWORD PTR _chord$[ebp]
	push	ebx
	fdiv	ST(1), ST(0)

; 2531 :   dchord[0][1] = -(dy1+dy2)/chord;
; 2532 :   dchord[1][0] = 0.0;
; 2533 :   dchord[1][1] = 0.0;
; 2534 :   dchord[2][0] = -dchord[0][0];
; 2535 :   dchord[2][1] = -dchord[0][1];
; 2536 :   dsinth[0][0] = -dy2/denom1/denom2 + sinth/denom1/denom1*dx1;

	mov	ebx, DWORD PTR _dsinth$[ebp]
	push	edi
	fxch	ST(1)
	fst	QWORD PTR tv4676[ebp]
	fchs
	fst	QWORD PTR [ecx]
	fld	QWORD PTR tv4654[ebp]
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR tv4679[ebp]
	fchs
	fst	QWORD PTR [ecx+8]
	fldz
	fst	QWORD PTR [ecx+16]
	fstp	QWORD PTR [ecx+24]
	fxch	ST(1)
	fchs
	fstp	QWORD PTR [ecx+32]
	fchs
	fstp	QWORD PTR [ecx+40]
	fld	QWORD PTR _sinth$[ebp]
	fld	ST(0)
	fld	QWORD PTR _denom1$[ebp]
	fdiv	ST(1), ST(0)
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fst	QWORD PTR tv4696[ebp]
	fld	QWORD PTR _dy2$[ebp]
	fdiv	ST(0), ST(2)
	fld	QWORD PTR _denom2$[ebp]
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fst	QWORD PTR tv4699[ebp]
	fld	ST(2)
	fld	QWORD PTR _dx1$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR tv4700[ebp]
	fstp	QWORD PTR [ebx]

; 2537 :   dsinth[0][1] =  dx2/denom1/denom2 + sinth/denom1/denom1*dy1;

	fld	QWORD PTR _dx2$[ebp]
	fld	ST(0)
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(3)
	fst	QWORD PTR tv4704[ebp]
	fld	QWORD PTR _dy1$[ebp]
	fmul	ST(5), ST(0)
	fxch	ST(5)
	faddp	ST(1), ST(0)
	fst	QWORD PTR tv4705[ebp]
	fstp	QWORD PTR [ebx+8]

; 2538 :   dsinth[2][0] = -dy1/denom1/denom2 - sinth/denom2/denom2*dx2;

	fld	ST(3)
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(3)
	fst	QWORD PTR tv4709[ebp]
	fchs
	fst	QWORD PTR tv4710[ebp]
	fld	ST(6)
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fst	QWORD PTR tv4712[ebp]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fst	QWORD PTR tv4714[ebp]
	fstp	QWORD PTR [ebx+32]

; 2539 :   dsinth[2][1] =  dx1/denom1/denom2 - sinth/denom2/denom2*dy2;

	fld	ST(1)
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(3)
	fstp	QWORD PTR tv4718[ebp]
	fld	QWORD PTR tv4712[ebp]
	fmul	QWORD PTR _dy2$[ebp]
	fsubr	QWORD PTR tv4718[ebp]
	fst	QWORD PTR tv4720[ebp]
	fstp	QWORD PTR [ebx+40]

; 2540 :   dsinth[1][0] = -dsinth[0][0]-dsinth[2][0];

	fld	QWORD PTR tv4700[ebp]
	fchs

; 2541 :   dsinth[1][1] = -dsinth[0][1]-dsinth[2][1];
; 2542 :   dcosth[0][0] = -dx2/denom1/denom2 + costh/denom1/denom1*dx1;

	mov	edi, DWORD PTR _dcosth$[ebp]
	fsub	QWORD PTR tv4714[ebp]

; 2543 :   dcosth[0][1] = -dy2/denom1/denom2 + costh/denom1/denom1*dy1;
; 2544 :   dcosth[2][0] =  dx1/denom1/denom2 - costh/denom2/denom2*dx2;
; 2545 :   dcosth[2][1] =  dy1/denom1/denom2 - costh/denom2/denom2*dy2;
; 2546 :   dcosth[1][0] = -dcosth[0][0]-dcosth[2][0];
; 2547 :   dcosth[1][1] = -dcosth[0][1]-dcosth[2][1];
; 2548 :   for ( i = 0 ; i < 3 ; i++ )
; 2549 :    for ( j = 0 ; j < 2 ; j++ )
; 2550 :      dangle[i][j] = dsinth[i][j]*costh - dcosth[i][j]*sinth;

	mov	eax, DWORD PTR _dangle$[ebp]
	fstp	QWORD PTR [ebx+16]
	fld	QWORD PTR tv4705[ebp]
	fchs
	fsub	QWORD PTR tv4720[ebp]
	fstp	QWORD PTR [ebx+24]
	fld	QWORD PTR _costh$[ebp]
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(5)
	fst	QWORD PTR tv4736[ebp]
	fmul	ST(0), ST(2)
	fsub	QWORD PTR tv4704[ebp]
	fst	QWORD PTR tv4738[ebp]
	fstp	QWORD PTR [edi]
	fld	QWORD PTR tv4736[ebp]
	fmul	ST(0), ST(4)
	fsub	QWORD PTR tv4699[ebp]
	fst	QWORD PTR tv4741[ebp]
	fstp	QWORD PTR [edi+8]
	fld	QWORD PTR _costh$[ebp]
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(3)
	fst	QWORD PTR tv4745[ebp]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR tv4718[ebp]
	fst	QWORD PTR tv4747[ebp]
	fstp	QWORD PTR [edi+32]
	fld	QWORD PTR tv4745[ebp]
	fmul	QWORD PTR _dy2$[ebp]
	fsubr	QWORD PTR tv4709[ebp]
	fst	QWORD PTR tv4751[ebp]
	fstp	QWORD PTR [edi+40]
	fld	QWORD PTR tv4738[ebp]
	fchs
	fsub	QWORD PTR tv4747[ebp]
	fstp	QWORD PTR [edi+16]
	fld	QWORD PTR tv4741[ebp]
	fchs
	fsub	QWORD PTR tv4751[ebp]
	fstp	QWORD PTR [edi+24]
	fld	QWORD PTR [ebx]
	fmul	QWORD PTR _costh$[ebp]
	fld	QWORD PTR [edi]
	fmul	ST(0), ST(7)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax]
	fld	QWORD PTR [ebx+8]
	fmul	QWORD PTR _costh$[ebp]
	fld	QWORD PTR [edi+8]
	fmul	ST(0), ST(7)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax+8]
	fld	QWORD PTR [ebx+16]
	fmul	QWORD PTR _costh$[ebp]
	fld	QWORD PTR [edi+16]
	fmul	ST(0), ST(7)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax+16]
	fld	QWORD PTR [ebx+24]
	fmul	QWORD PTR _costh$[ebp]
	fld	ST(6)
	fmul	QWORD PTR [edi+24]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax+24]
	fld	QWORD PTR [ebx+32]
	fmul	QWORD PTR _costh$[ebp]
	fld	ST(6)
	fmul	QWORD PTR [edi+32]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax+32]
	fld	QWORD PTR [ebx+40]
	fmul	QWORD PTR _costh$[ebp]
	fld	ST(6)
	fmul	QWORD PTR [edi+40]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax+40]

; 2551 : 
; 2552 :   if ( mode == METHOD_GRADIENT ) return;

	cmp	edx, 4321				; 000010e1H
	je	$LN370@circular_a@2

; 2553 : 
; 2554 :   for ( i = 0 ; i < 3 ; i++ )

	mov	edx, DWORD PTR _web+616
	fldz
	mov	DWORD PTR tv7293[ebp], 0
	push	esi
$LN360@circular_a@2:

; 2555 :    for ( ii = 0 ; ii < 3; ii++ )

	xor	eax, eax
	mov	DWORD PTR _ii$[ebp], eax
$LN84@circular_a@2:

; 2556 :     for ( j = 0 ; j < SDIM  ; j++ )

	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN83@circular_a@2
$LN81@circular_a@2:

; 2557 :      for ( jj = 0 ; jj < SDIM  ; jj++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN80@circular_a@2
	mov	edx, DWORD PTR tv7293[ebp]
	add	edx, esi
	lea	eax, DWORD PTR [eax+edx*2]
	add	eax, edx
	shl	eax, 4
	add	eax, DWORD PTR _ddchord$[ebp]
$LN78@circular_a@2:

; 2558 :       ddchord[i][j][ii][jj] = 0.0;

	fst	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	inc	ecx
	add	eax, 8
	cmp	ecx, edx
	jl	SHORT $LN78@circular_a@2

; 2557 :      for ( jj = 0 ; jj < SDIM  ; jj++ )

	mov	eax, DWORD PTR _ii$[ebp]
$LN80@circular_a@2:

; 2556 :     for ( j = 0 ; j < SDIM  ; j++ )

	inc	esi
	cmp	esi, edx
	jl	SHORT $LN81@circular_a@2
	mov	ecx, DWORD PTR _dchord$[ebp]
$LN83@circular_a@2:

; 2555 :    for ( ii = 0 ; ii < 3; ii++ )

	inc	eax
	mov	DWORD PTR _ii$[ebp], eax
	cmp	eax, 3
	jl	SHORT $LN84@circular_a@2

; 2553 : 
; 2554 :   for ( i = 0 ; i < 3 ; i++ )

	mov	eax, DWORD PTR tv7293[ebp]
	add	eax, 2
	mov	DWORD PTR tv7293[ebp], eax
	cmp	eax, 6
	jl	SHORT $LN360@circular_a@2

; 2559 : 
; 2560 :   for ( ii = 0 ; ii < 3; ii++ )

	mov	esi, DWORD PTR _ddchord$[ebp]
	fstp	ST(0)
	fld	QWORD PTR _chord$[ebp]
	mov	DWORD PTR tv7416[ebp], ecx
	lea	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR tv7425[ebp], ecx
	mov	DWORD PTR tv4487[ebp], 3
$LN362@circular_a@2:

; 2561 :     for ( jj = 0 ; jj < SDIM  ; jj++ )

	mov	DWORD PTR _jj$[ebp], 0
	test	edx, edx
	jle	SHORT $LN74@circular_a@2
	fld	QWORD PTR tv4676[ebp]
	mov	eax, DWORD PTR tv7416[ebp]
	fdiv	ST(0), ST(1)
	mov	edx, esi
	sub	edx, DWORD PTR _dchord$[ebp]
	mov	esi, DWORD PTR _jj$[ebp]
	mov	DWORD PTR tv7387[ebp], edx
	fstp	QWORD PTR tv4866[ebp]
	fld	QWORD PTR tv4679[ebp]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR tv4876[ebp]
	jmp	SHORT $LN72@circular_a@2
$LN357@circular_a@2:
	mov	edx, DWORD PTR tv7387[ebp]
$LN72@circular_a@2:

; 2562 :     { ddchord[0][0][ii][jj] = (dx1+dx2)/chord/chord*dchord[ii][jj];

	fld	QWORD PTR tv4866[ebp]
	inc	esi
	fmul	QWORD PTR [eax]
	add	eax, 8
	add	ecx, 8
	fstp	QWORD PTR [edx+eax-8]

; 2563 :       ddchord[0][1][ii][jj] = (dy1+dy2)/chord/chord*dchord[ii][jj];

	fld	QWORD PTR tv4876[ebp]
	fmul	QWORD PTR [eax-8]
	fstp	QWORD PTR [ecx-8]
	mov	edx, DWORD PTR _web+616
	cmp	esi, edx
	jl	SHORT $LN357@circular_a@2

; 2561 :     for ( jj = 0 ; jj < SDIM  ; jj++ )

	mov	esi, DWORD PTR _ddchord$[ebp]
$LN74@circular_a@2:

; 2559 : 
; 2560 :   for ( ii = 0 ; ii < 3; ii++ )

	mov	ecx, DWORD PTR tv7425[ebp]
	add	DWORD PTR tv7416[ebp], 16		; 00000010H
	add	ecx, 16					; 00000010H
	dec	DWORD PTR tv4487[ebp]
	mov	DWORD PTR tv7425[ebp], ecx
	jne	SHORT $LN362@circular_a@2

; 2564 :     }
; 2565 :   ddchord[0][0][0][0] +=  1/chord;

	fld1

; 2566 :   ddchord[0][0][2][0] += -1/chord;
; 2567 :   ddchord[0][1][0][1] +=  1/chord;
; 2568 :   ddchord[0][1][2][1] += -1/chord;
; 2569 :   for ( j = 0 ; j < SDIM  ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	fdivrp	ST(1), ST(0)
	fld	ST(0)
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	fld	QWORD PTR [esi+32]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [esi+32]
	fld	ST(0)
	fadd	QWORD PTR [esi+56]
	fstp	QWORD PTR [esi+56]
	fsubr	QWORD PTR [esi+88]
	fstp	QWORD PTR [esi+88]
	mov	edx, DWORD PTR _web+616
	test	edx, edx
	jle	SHORT $LN67@circular_a@2

; 2564 :     }
; 2565 :   ddchord[0][0][0][0] +=  1/chord;

	mov	DWORD PTR tv7515[ebp], 12		; 0000000cH
$LN361@circular_a@2:

; 2570 :    for ( ii = 0 ; ii < 3; ii++ )

	xor	eax, eax
	mov	DWORD PTR _ii$[ebp], eax
$LN66@circular_a@2:

; 2571 :     for ( jj = 0 ; jj < SDIM  ; jj++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN65@circular_a@2
	add	eax, DWORD PTR tv7515[ebp]
	shl	eax, 4
	add	eax, esi
$LN63@circular_a@2:

; 2572 :       ddchord[2][j][ii][jj] = -ddchord[0][j][ii][jj];

	fld	QWORD PTR [eax-192]
	inc	ecx
	fchs
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jl	SHORT $LN63@circular_a@2

; 2571 :     for ( jj = 0 ; jj < SDIM  ; jj++ )

	mov	eax, DWORD PTR _ii$[ebp]
$LN65@circular_a@2:

; 2570 :    for ( ii = 0 ; ii < 3; ii++ )

	inc	eax
	mov	DWORD PTR _ii$[ebp], eax
	cmp	eax, 3
	jl	SHORT $LN66@circular_a@2

; 2566 :   ddchord[0][0][2][0] += -1/chord;
; 2567 :   ddchord[0][1][0][1] +=  1/chord;
; 2568 :   ddchord[0][1][2][1] += -1/chord;
; 2569 :   for ( j = 0 ; j < SDIM  ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	add	DWORD PTR tv7515[ebp], 3
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, edx
	jl	SHORT $LN361@circular_a@2
$LN67@circular_a@2:

; 2573 :     
; 2574 : 
; 2575 :   /* dsinth[0][0] = -dy2/denom1/denom2 + sinth/denom1/denom1*dx1; */
; 2576 :   ddsinth[0][0][0][0] =
; 2577 :    -(-dy2/denom1/denom2 + 2*sinth/denom1/denom1*dx1)/denom1*(-dx1)/denom1
; 2578 :    + dsinth[0][0]/denom1/denom1*dx1
; 2579 :     - sinth/denom1/denom1;

	fxch	ST(5)
	mov	ecx, DWORD PTR _ddsinth$[ebp]
	fadd	ST(0), ST(0)

; 2580 :   ddsinth[0][0][0][1] =
; 2581 :    -(-dy2/denom1/denom2 + 2*sinth/denom1/denom1*dx1)/denom1*(-dy1)/denom1
; 2582 :    + dsinth[0][1]/denom1/denom1*dx1;
; 2583 :   ddsinth[0][0][2][0] = dy2/denom1/denom2/denom2*dx2/denom2
; 2584 :      + dsinth[2][0]/denom1/denom1*dx1;

	lea	edx, DWORD PTR [ecx+32]
	fst	QWORD PTR tv4920[ebp]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fst	QWORD PTR tv4922[ebp]
	fmul	ST(0), ST(1)
	fsub	QWORD PTR tv4699[ebp]
	fdiv	ST(0), ST(4)
	fld	ST(1)
	fchs
	fst	QWORD PTR tv4927[ebp]
	fld	QWORD PTR [ebx]
	fdiv	ST(0), ST(6)
	fdiv	ST(0), ST(6)
	fmul	ST(0), ST(3)
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fdiv	ST(0), ST(6)
	fsubp	ST(1), ST(0)
	fsub	QWORD PTR tv4696[ebp]
	fstp	QWORD PTR [ecx]
	fld	ST(3)
	fchs
	fst	QWORD PTR tv4937[ebp]
	fld	QWORD PTR [ebx+8]
	fdiv	ST(0), ST(6)
	fdiv	ST(0), ST(6)
	fmul	ST(0), ST(3)
	fxch	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+8]
	fld	QWORD PTR tv4699[ebp]
	fdiv	ST(0), ST(2)
	fld	ST(0)
	fmul	ST(0), ST(6)
	fdiv	ST(0), ST(3)
	fst	QWORD PTR tv4946[ebp]
	fld	QWORD PTR [ebx+32]
	fdiv	ST(0), ST(6)
	fdiv	ST(0), ST(6)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx]

; 2585 :   ddsinth[0][0][2][1] = -1/denom1/denom2 + dy2/denom1/denom2/denom2*dy2/denom2
; 2586 :    + dsinth[2][1]/denom1/denom1*dx1;

	fld1
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(3)
	fst	QWORD PTR tv4956[ebp]
	fxch	ST(1)
	fmul	QWORD PTR _dy2$[ebp]
	fdiv	ST(0), ST(3)
	fsubrp	ST(1), ST(0)
	fst	QWORD PTR tv4957[ebp]
	fld	QWORD PTR [ebx+40]
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(5)
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+40]

; 2587 :   ddsinth[0][0][1][0] = -ddsinth[0][0][0][0] - ddsinth[0][0][2][0];

	fld	QWORD PTR [ecx]
	fchs
	fsub	QWORD PTR [edx]
	fstp	QWORD PTR [ecx+16]

; 2588 :   ddsinth[0][0][1][1] = -ddsinth[0][0][0][1] - ddsinth[0][0][2][1];

	fld	QWORD PTR [ecx+8]
	fchs
	fsub	QWORD PTR [ecx+40]
	fstp	QWORD PTR [ecx+24]

; 2589 : 
; 2590 :   /* dsinth[0][1] =  dx2/denom1/denom2 + sinth/denom1/denom1*dy1; */
; 2591 :   ddsinth[0][1][0][0] =
; 2592 :          -(dx2/denom1/denom2 + 2*sinth/denom1/denom1*dy1)/denom1*(-dx1)/denom1
; 2593 :         + dsinth[0][0]/denom1/denom1*dy1;

	fld	QWORD PTR tv4922[ebp]
	fmul	ST(0), ST(3)
	fadd	QWORD PTR tv4704[ebp]
	fdiv	ST(0), ST(4)
	fst	QWORD PTR tv4980[ebp]
	fld	QWORD PTR [ebx]
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(5)
	fmul	ST(0), ST(4)
	fxch	ST(1)
	fmul	QWORD PTR tv4927[ebp]
	fdiv	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+48]

; 2594 :   ddsinth[0][1][0][1] =
; 2595 :          -(dx2/denom1/denom2 + 2*sinth/denom1/denom1*dy1)/denom1*(-dy1)/denom1
; 2596 :         + dsinth[0][1]/denom1/denom1*dy1 -sinth/denom1/denom1;

	fld	QWORD PTR [ebx+8]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fmul	ST(0), ST(3)
	fld	QWORD PTR tv4980[ebp]
	fmul	QWORD PTR tv4937[ebp]
	fdiv	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fsub	QWORD PTR tv4696[ebp]
	fstp	QWORD PTR [ecx+56]

; 2597 :   ddsinth[0][1][2][0] = 1/denom1/denom2 - dx2/denom1/denom2/denom2*dx2/denom2
; 2598 :           + dsinth[2][0]/denom1/denom1*dy1;

	fld	QWORD PTR tv4704[ebp]
	fdiv	ST(0), ST(2)
	fst	QWORD PTR tv4993[ebp]
	fmul	ST(0), ST(5)
	fdiv	ST(0), ST(2)
	fst	QWORD PTR tv4995[ebp]
	fld	QWORD PTR [ebx+32]
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(5)
	fmul	ST(0), ST(4)
	fld	QWORD PTR tv4956[ebp]
	fsubrp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+80]

; 2599 :   ddsinth[0][1][2][1] = -dx2/denom1/denom2/denom2*dy2/denom2
; 2600 :           + dsinth[2][1]/denom1/denom1*dy1;

	fld	QWORD PTR tv4993[ebp]
	fld	QWORD PTR _dy2$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(3)
	fst	QWORD PTR tv5003[ebp]
	fld	QWORD PTR [ebx+40]
	fdiv	ST(0), ST(6)
	fdiv	ST(0), ST(6)
	fmul	ST(0), ST(5)
	fsubrp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+88]

; 2601 :   ddsinth[0][1][1][0] = -ddsinth[0][1][0][0] - ddsinth[0][1][2][0];

	fld	QWORD PTR [ecx+48]
	fchs
	fsub	QWORD PTR [ecx+80]
	fstp	QWORD PTR [ecx+64]

; 2602 :   ddsinth[0][1][1][1] = -ddsinth[0][1][0][1] - ddsinth[0][1][2][1];

	fld	QWORD PTR [ecx+56]
	fchs
	fsub	QWORD PTR [ecx+88]
	fstp	QWORD PTR [ecx+72]

; 2603 : 
; 2604 : 
; 2605 :   for ( j = 0 ; j < 2 ; j++ )
; 2606 :     for ( jj = 0 ; jj < 2 ; jj++ )
; 2607 :       ddsinth[2][j][0][jj] = ddsinth[0][jj][2][j];

	fld	QWORD PTR [edx]
	fstp	QWORD PTR [ecx+192]
	fld	QWORD PTR [ecx+80]
	fstp	QWORD PTR [ecx+200]
	fld	QWORD PTR [ecx+40]
	fstp	QWORD PTR [ecx+240]
	fld	QWORD PTR [ecx+88]
	fstp	QWORD PTR [ecx+248]

; 2608 :   /* dsinth[2][0] = -dy1/denom1/denom2 - sinth/denom2/denom2*dx2; */
; 2609 :   ddsinth[2][0][2][0] =
; 2610 :     -(-dy1/denom1/denom2 - 2*sinth/denom2/denom2*dx2)/denom2*dx2/denom2
; 2611 :           - dsinth[2][0]/denom2/denom2*dx2
; 2612 :           - sinth/denom2/denom2;

	fld	QWORD PTR tv4920[ebp]
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(3)
	fst	QWORD PTR tv5064[ebp]
	fmul	ST(0), ST(6)
	fsubr	QWORD PTR tv4710[ebp]
	fdiv	ST(0), ST(3)
	fst	QWORD PTR tv5068[ebp]
	fmul	ST(0), ST(6)
	fdiv	ST(0), ST(3)
	fchs
	fld	QWORD PTR [ebx+32]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fmul	ST(0), ST(7)
	fsubp	ST(1), ST(0)
	fsub	QWORD PTR tv4712[ebp]
	fstp	QWORD PTR [ecx+224]

; 2613 :   ddsinth[2][0][2][1] = 
; 2614 :     -(-dy1/denom1/denom2 - 2*sinth/denom2/denom2*dx2)/denom2*dy2/denom2
; 2615 :           - dsinth[2][1]/denom2/denom2*dx2;

	fld	QWORD PTR tv5068[ebp]
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(3)
	fchs
	fld	QWORD PTR [ebx+40]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fmul	ST(0), ST(7)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+232]

; 2616 :   for ( jj = 0  ; jj < 2 ; jj++ )
; 2617 :    ddsinth[2][0][1][jj] = -ddsinth[2][0][0][jj]-ddsinth[2][0][2][jj];

	fld	QWORD PTR [ecx+192]
	fchs
	fsub	QWORD PTR [ecx+224]
	fstp	QWORD PTR [ecx+208]
	fld	QWORD PTR [ecx+200]
	fchs
	fsub	QWORD PTR [ecx+232]
	fstp	QWORD PTR [ecx+216]

; 2618 : 
; 2619 :   ddsinth[2][1][2][0] = ddsinth[2][0][2][1];

	fld	QWORD PTR [ecx+232]
	fstp	QWORD PTR [ecx+272]

; 2620 :   ddsinth[2][1][2][1] =
; 2621 :     -(dx1/denom1/denom2 - 2*sinth/denom2/denom2*dy2)/denom2*dy2/denom2
; 2622 :     - dsinth[2][1]/denom2/denom2*dy2
; 2623 :     - sinth/denom2/denom2;

	fld	QWORD PTR tv5064[ebp]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR tv4718[ebp]
	fdiv	ST(0), ST(3)
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(3)
	fchs
	fld	QWORD PTR [ebx+40]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	fsub	QWORD PTR tv4712[ebp]
	fstp	QWORD PTR [ecx+280]

; 2624 :   for ( jj = 0  ; jj < 2 ; jj++ )
; 2625 :    ddsinth[2][1][1][jj] = -ddsinth[2][1][0][jj]-ddsinth[2][1][2][jj];

	fld	QWORD PTR [ecx+240]
	fchs
	fsub	QWORD PTR [ecx+272]
	fstp	QWORD PTR [ecx+256]
	fld	QWORD PTR [ecx+248]
	fchs
	fsub	QWORD PTR [ecx+280]
	fstp	QWORD PTR [ecx+264]

; 2626 : 
; 2627 :   for ( j = 0 ; j < 2 ; j++ )
; 2628 :    for ( ii = 0 ; ii < 3 ; ii++ )
; 2629 :     for ( jj = 0 ; jj < 2 ; jj++ )
; 2630 :       ddsinth[1][j][ii][jj] = -ddsinth[0][j][ii][jj]-ddsinth[2][j][ii][jj];

	fld	QWORD PTR [ecx]
	fchs
	fsub	QWORD PTR [ecx+192]
	fstp	QWORD PTR [ecx+96]
	fld	QWORD PTR [ecx+8]
	fchs
	fsub	QWORD PTR [ecx+200]
	fstp	QWORD PTR [ecx+104]
	fld	QWORD PTR [ecx+16]
	fchs
	fsub	QWORD PTR [ecx+208]
	fstp	QWORD PTR [ecx+112]
	fld	QWORD PTR [ecx+24]
	fchs
	fsub	QWORD PTR [ecx+216]
	fstp	QWORD PTR [ecx+120]
	fld	QWORD PTR [edx]
	fchs
	fsub	QWORD PTR [ecx+224]
	fstp	QWORD PTR [ecx+128]
	fld	QWORD PTR [ecx+40]
	fchs
	fsub	QWORD PTR [ecx+232]
	fstp	QWORD PTR [ecx+136]
	fld	QWORD PTR [ecx+48]
	fchs
	fsub	QWORD PTR [ecx+240]
	fstp	QWORD PTR [ecx+144]
	fld	QWORD PTR [ecx+56]
	fchs
	fsub	QWORD PTR [ecx+248]
	fstp	QWORD PTR [ecx+152]
	fld	QWORD PTR [ecx+64]
	fchs
	fsub	QWORD PTR [ecx+256]
	fstp	QWORD PTR [ecx+160]
	fld	QWORD PTR [ecx+72]
	fchs
	fsub	QWORD PTR [ecx+264]
	fstp	QWORD PTR [ecx+168]
	fld	QWORD PTR [ecx+80]
	fchs
	fsub	QWORD PTR [ecx+272]
	fstp	QWORD PTR [ecx+176]
	fld	QWORD PTR [ecx+88]
	fchs

; 2631 : 
; 2632 :   /* dcosth[0][0] = -dx2/denom1/denom2 + costh/denom1/denom1*dx1; */
; 2633 :   ddcosth[0][0][0][0] = 
; 2634 :     -(-dx2/denom1/denom2 + 2*costh/denom1/denom1*dx1)/denom1*(-dx1)/denom1
; 2635 :      + dcosth[0][0]/denom1/denom1*dx1
; 2636 :      - costh/denom1/denom1; 

	mov	eax, DWORD PTR _ddcosth$[ebp]
	fsub	QWORD PTR [ecx+280]

; 2637 :   ddcosth[0][0][0][1] = 
; 2638 :     -(-dx2/denom1/denom2 + 2*costh/denom1/denom1*dx1)/denom1*(-dy1)/denom1
; 2639 :      + dcosth[0][1]/denom1/denom1*dx1;

	lea	esi, DWORD PTR [eax+8]
	mov	DWORD PTR tv5409[ebp], esi
	fstp	QWORD PTR [ecx+184]
	fld	QWORD PTR _costh$[ebp]
	fadd	ST(0), ST(0)
	fst	QWORD PTR tv5391[ebp]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fst	QWORD PTR tv5393[ebp]
	fmul	ST(0), ST(1)
	fsub	QWORD PTR tv4704[ebp]
	fdiv	ST(0), ST(4)
	fld	QWORD PTR [edi]
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(5)
	fmul	ST(0), ST(2)
	fld	QWORD PTR tv4927[ebp]
	fmul	ST(0), ST(2)
	fdiv	ST(0), ST(6)
	fsubp	ST(1), ST(0)
	fsub	QWORD PTR tv4736[ebp]
	fstp	QWORD PTR [eax]
	fld	QWORD PTR [edi+8]
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(5)
	fmul	ST(0), ST(2)
	fld	QWORD PTR tv4937[ebp]
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [esi]

; 2640 :   ddcosth[0][0][2][0] = -1/denom1/denom2 + dx2/denom1/denom2/denom2*dx2/denom2
; 2641 :       + dcosth[2][0]/denom1/denom1*dx1;

	fld	QWORD PTR [edi+32]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fmul	ST(0), ST(1)
	fld	QWORD PTR tv4995[ebp]
	fsub	QWORD PTR tv4956[ebp]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax+32]

; 2642 :   ddcosth[0][0][2][1] =  dx2/denom1/denom2/denom2*dy2/denom2
; 2643 :       + dcosth[2][1]/denom1/denom1*dx1;

	fld	QWORD PTR [edi+40]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR tv5003[ebp]
	fstp	QWORD PTR [eax+40]

; 2644 :   for ( jj = 0 ; jj < 2 ; jj++ )
; 2645 :     ddcosth[0][0][1][jj] = -ddcosth[0][0][0][jj]-ddcosth[0][0][2][jj];

	fld	QWORD PTR [eax]
	fchs
	fsub	QWORD PTR [eax+32]
	fstp	QWORD PTR [eax+16]
	fld	QWORD PTR [esi]
	fchs
	fsub	QWORD PTR [eax+40]
	fstp	QWORD PTR [eax+24]

; 2646 : 
; 2647 :   /* dcosth[0][1] = -dy2/denom1/denom2 + costh/denom1/denom1*dy1; */
; 2648 :   ddcosth[0][1][0][0] = 
; 2649 :     -(-dy2/denom1/denom2 + 2*costh/denom1/denom1*dy1)/denom1*(-dx1)/denom1
; 2650 :      + dcosth[0][0]/denom1/denom1*dy1;

	fld	QWORD PTR tv5393[ebp]
	fmul	ST(0), ST(2)
	fsub	QWORD PTR tv4699[ebp]
	fdiv	ST(0), ST(3)
	fld	QWORD PTR [edi]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fmul	ST(0), ST(3)
	fld	QWORD PTR tv4927[ebp]
	fmul	ST(0), ST(2)
	fdiv	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax+48]

; 2651 :   ddcosth[0][1][0][1] = 
; 2652 :     -(-dy2/denom1/denom2 + 2*costh/denom1/denom1*dy1)/denom1*(-dy1)/denom1
; 2653 :      + dcosth[0][1]/denom1/denom1*dy1
; 2654 :      - costh/denom1/denom1; 

	fld	QWORD PTR [edi+8]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fmul	ST(0), ST(3)
	fld	QWORD PTR tv4937[ebp]
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(4)
	fsubp	ST(1), ST(0)
	fsub	QWORD PTR tv4736[ebp]
	fstp	QWORD PTR [eax+56]

; 2655 :   ddcosth[0][1][2][0] = dy2/denom1/denom2/denom2*dx2/denom2
; 2656 :       + dcosth[2][0]/denom1/denom1*dy1;

	fld	QWORD PTR [edi+32]
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(3)
	fmul	ST(0), ST(2)
	fadd	QWORD PTR tv4946[ebp]
	fstp	QWORD PTR [eax+80]

; 2657 :   ddcosth[0][1][2][1] =  -1/denom1/denom2+dy2/denom1/denom2/denom2*dy2/denom2
; 2658 :       + dcosth[2][1]/denom1/denom1*dy1;

	fld	QWORD PTR [edi+40]
	fdiv	ST(0), ST(3)
	fdivrp	ST(3), ST(0)
	fxch	ST(2)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR tv4957[ebp]
	fstp	QWORD PTR [eax+88]

; 2659 :   for ( jj = 0 ; jj < 2 ; jj++ )
; 2660 :     ddcosth[0][1][1][jj] = -ddcosth[0][1][0][jj]-ddcosth[0][1][2][jj];

	fld	QWORD PTR [eax+48]
	fchs
	fsub	QWORD PTR [eax+80]
	fstp	QWORD PTR [eax+64]
	fld	QWORD PTR [eax+56]
	fchs
	fsub	QWORD PTR [eax+88]
	fstp	QWORD PTR [eax+72]

; 2661 : 
; 2662 :   for ( j = 0 ; j < 2 ; j++ )
; 2663 :     for ( jj = 0 ; jj < 2 ; jj++ )
; 2664 :       ddcosth[2][j][0][jj] = ddcosth[0][jj][2][j];

	fld	QWORD PTR [eax+32]
	fstp	QWORD PTR [eax+192]
	fld	QWORD PTR [eax+80]
	fstp	QWORD PTR [eax+200]
	fld	QWORD PTR [eax+40]
	fstp	QWORD PTR [eax+240]
	fld	QWORD PTR [eax+88]
	fstp	QWORD PTR [eax+248]

; 2665 :   /* dcosth[2][0] =  dx1/denom1/denom2 - costh/denom2/denom2*dx2; */
; 2666 :   ddcosth[2][0][2][0] = 
; 2667 :      -(dx1/denom1/denom2 - 2*costh/denom2/denom2*dx2)/denom2*dx2/denom2
; 2668 :      - dcosth[2][0]/denom2/denom2*dx2
; 2669 :      - costh/denom2/denom2;

	fld	QWORD PTR tv5391[ebp]
	fdiv	ST(0), ST(1)
	fdiv	ST(0), ST(1)
	fld	ST(0)
	fmul	ST(0), ST(3)
	fsubr	QWORD PTR tv4718[ebp]
	fdiv	ST(0), ST(2)
	fld	ST(0)
	fmul	ST(0), ST(4)
	fdiv	ST(0), ST(3)
	fchs
	fld	QWORD PTR [edi+32]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR tv4745[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [eax+224]

; 2670 :   ddcosth[2][0][2][1] =  
; 2671 :      -(dx1/denom1/denom2 - 2*costh/denom2/denom2*dx2)/denom2*dy2/denom2
; 2672 :      - dcosth[2][1]/denom2/denom2*dx2;

	fld	QWORD PTR _dy2$[ebp]
	fmul	ST(2), ST(0)
	fxch	ST(2)
	fdiv	ST(0), ST(4)
	fchs
	fld	QWORD PTR [edi+40]
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(5)
	fmulp	ST(6), ST(0)
	fsubrp	ST(5), ST(0)
	fxch	ST(4)
	fstp	QWORD PTR [eax+232]

; 2673 :   for ( jj = 0  ; jj < 2 ; jj++ )
; 2674 :    ddcosth[2][0][1][jj] = -ddcosth[2][0][0][jj]-ddcosth[2][0][2][jj];

	fld	QWORD PTR [eax+192]
	fchs
	fsub	QWORD PTR [eax+224]
	fstp	QWORD PTR [eax+208]
	fld	QWORD PTR [eax+200]
	fchs
	fsub	QWORD PTR [eax+232]
	fstp	QWORD PTR [eax+216]

; 2675 : 
; 2676 :   /* dcosth[2][1] =  dy1/denom1/denom2 - costh/denom2/denom2*dy2; */
; 2677 :   ddcosth[2][1][2][0] = ddcosth[2][0][2][1];

	fld	QWORD PTR [eax+232]
	fstp	QWORD PTR [eax+272]

; 2678 :   ddcosth[2][1][2][1] = 
; 2679 :      -(dy1/denom1/denom2 -2*costh/denom2/denom2*dy2)/denom2*dy2/denom2
; 2680 :      - dcosth[2][1]/denom2/denom2*dy2
; 2681 :      - costh/denom2/denom2;

	fmul	ST(1), ST(0)
	fld	QWORD PTR tv4709[ebp]
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(2)
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(2)
	fchs
	fld	QWORD PTR [edi+40]
	fdiv	ST(0), ST(3)
	fdivrp	ST(3), ST(0)
	mov	DWORD PTR tv480[ebp], 3
	fxch	ST(2)
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	fsubrp	ST(1), ST(0)
	fstp	QWORD PTR [eax+280]

; 2682 :   for ( jj = 0  ; jj < 2 ; jj++ )
; 2683 :    ddcosth[2][1][1][jj] = -ddcosth[2][1][0][jj]-ddcosth[2][1][2][jj];

	fld	QWORD PTR [eax+240]
	fchs
	fsub	QWORD PTR [eax+272]
	fstp	QWORD PTR [eax+256]
	fld	QWORD PTR [eax+248]
	fchs
	fsub	QWORD PTR [eax+280]
	fstp	QWORD PTR [eax+264]

; 2684 : 
; 2685 :   for ( j = 0 ; j < 2 ; j++ )
; 2686 :    for ( ii = 0 ; ii < 3 ; ii++ )
; 2687 :     for ( jj = 0 ; jj < 2 ; jj++ )
; 2688 :       ddcosth[1][j][ii][jj] = -ddcosth[0][j][ii][jj]-ddcosth[2][j][ii][jj];

	fld	QWORD PTR [eax]
	fchs
	fsub	QWORD PTR [eax+192]
	fstp	QWORD PTR [eax+96]
	fld	QWORD PTR [esi]
	mov	esi, ecx
	fchs
	sub	esi, eax
	fsub	QWORD PTR [eax+200]
	mov	DWORD PTR tv8702[ebp], esi
	mov	esi, DWORD PTR _ddangle$[ebp]
	sub	esi, eax
	fstp	QWORD PTR [eax+104]
	mov	DWORD PTR tv8707[ebp], esi
	fld	QWORD PTR [eax+16]
	mov	esi, DWORD PTR _ddangle$[ebp]
	fchs
	sub	ecx, esi
	fsub	QWORD PTR [eax+208]
	mov	DWORD PTR tv8731[ebp], ecx
	mov	ecx, DWORD PTR tv5409[ebp]
	mov	DWORD PTR tv8908[ebp], ecx
	fstp	QWORD PTR [eax+112]
	mov	ecx, edx
	fld	QWORD PTR [eax+24]
	fchs
	fsub	QWORD PTR [eax+216]
	fstp	QWORD PTR [eax+120]
	fld	QWORD PTR [eax+32]
	fchs
	fsub	QWORD PTR [eax+224]
	fstp	QWORD PTR [eax+128]
	fld	QWORD PTR [eax+40]
	fchs
	fsub	QWORD PTR [eax+232]
	fstp	QWORD PTR [eax+136]
	fld	QWORD PTR [eax+48]
	fchs
	fsub	QWORD PTR [eax+240]
	fstp	QWORD PTR [eax+144]
	fld	QWORD PTR [eax+56]
	fchs
	fsub	QWORD PTR [eax+248]
	fstp	QWORD PTR [eax+152]
	fld	QWORD PTR [eax+64]
	fchs
	fsub	QWORD PTR [eax+256]
	fstp	QWORD PTR [eax+160]
	fld	QWORD PTR [eax+72]
	fchs
	fsub	QWORD PTR [eax+264]
	fstp	QWORD PTR [eax+168]
	fld	QWORD PTR [eax+80]
	fchs
	fsub	QWORD PTR [eax+272]
	fstp	QWORD PTR [eax+176]
	fld	QWORD PTR [eax+88]
	fchs
	fsub	QWORD PTR [eax+280]
	fstp	QWORD PTR [eax+184]
	mov	eax, ebx
	fld	QWORD PTR _sinth$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv8760[ebp], eax
	mov	eax, edi
	add	esi, 16					; 00000010H

; 2573 :     
; 2574 : 
; 2575 :   /* dsinth[0][0] = -dy2/denom1/denom2 + sinth/denom1/denom1*dx1; */
; 2576 :   ddsinth[0][0][0][0] =
; 2577 :    -(-dy2/denom1/denom2 + 2*sinth/denom1/denom1*dx1)/denom1*(-dx1)/denom1
; 2578 :    + dsinth[0][0]/denom1/denom1*dx1
; 2579 :     - sinth/denom1/denom1;

	fld	QWORD PTR _costh$[ebp]
$LN12@circular_a@2:

; 2691 :    for ( j = 0 ; j < 2 ; j++ )

	mov	edx, DWORD PTR tv8908[ebp]
	mov	DWORD PTR tv8592[ebp], ecx
	mov	DWORD PTR tv524[ebp], 2
$LN9@circular_a@2:

; 2692 :     for ( ii = 0 ; ii < 3; ii++ )
; 2693 :      for ( jj = 0 ; jj < 2  ; jj++ )
; 2694 :        ddangle[i][j][ii][jj] = 
; 2695 :           ddsinth[i][j][ii][jj]*costh - ddcosth[i][j][ii][jj]*sinth
; 2696 :         + dsinth[i][j]*dcosth[ii][jj] - dcosth[i][j]*dsinth[ii][jj];

	mov	ecx, DWORD PTR tv8592[ebp]
	fld	QWORD PTR [ecx-32]
	mov	ecx, DWORD PTR tv8760[ebp]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [edx-8]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [edi]
	fmul	QWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR tv8702[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax]
	fmul	QWORD PTR [ebx]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [esi-16]
	fld	QWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR tv8760[ebp]
	fmul	ST(0), ST(1)
	fld	ST(2)
	fmul	QWORD PTR [edx]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [edi+8]
	fmul	QWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR tv8707[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+8]
	fmul	QWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR tv8731[ebp]
	fld	QWORD PTR [ecx+esi]
	mov	ecx, DWORD PTR tv8760[ebp]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [edx+8]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [edi+16]
	fmul	QWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR tv8592[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+16]
	fmul	QWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [esi]
	fld	QWORD PTR [ecx-8]
	mov	ecx, DWORD PTR tv8760[ebp]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [edx+16]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR tv8592[ebp]
	fmul	QWORD PTR [edi+24]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+24]
	fmul	QWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [esi+8]
	fld	ST(0)
	fmul	QWORD PTR [ecx]
	mov	ecx, DWORD PTR tv8760[ebp]
	fld	QWORD PTR [edx+24]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR tv8592[ebp]
	fmul	QWORD PTR [edi+32]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+32]
	fmul	QWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [esi+16]
	fld	QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR tv8760[ebp]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [edx+32]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [eax+ecx]
	fmul	QWORD PTR [edi+40]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+40]
	add	DWORD PTR tv8592[ebp], 48		; 00000030H
	fmul	QWORD PTR [eax]
	add	eax, 8
	add	edx, 48					; 00000030H
	add	esi, 48					; 00000030H
	dec	DWORD PTR tv524[ebp]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [esi-24]
	jne	$LN9@circular_a@2

; 2689 : 
; 2690 :   for ( i = 0 ; i < 3 ; i++ )

	dec	DWORD PTR tv480[ebp]
	mov	ecx, DWORD PTR tv8592[ebp]
	mov	DWORD PTR tv8908[ebp], edx
	jne	$LN12@circular_a@2
	pop	esi
	fstp	ST(1)
	pop	edi
	fstp	ST(0)
	pop	ebx

; 2697 : 
; 2698 : 
; 2699 : #ifdef XXX
; 2700 : /* debugging */
; 2701 : { REAL dx[2][2];
; 2702 :   REAL ch[4],si[4],co[4],an[4];
; 2703 :   REAL delta = 1e-4;
; 2704 :   dx[0][0] = dx1;
; 2705 :   dx[0][1] = dy1;
; 2706 :   dx[1][0] = dx2;
; 2707 :   dx[1][1] = dy2;
; 2708 : 
; 2709 : /* check numerically */
; 2710 :   
; 2711 : 
; 2712 :   for ( i = 0 ; i < 2; i++ )
; 2713 :    for ( j = 0 ; j < 2; j++ )
; 2714 :     for ( ii = 0 ; ii < 2 ; ii ++ )
; 2715 :      for ( jj = 0 ; jj < 2 ; jj ++ )
; 2716 :      { dx[i][j] += delta;
; 2717 :        dx[ii][jj] += delta;
; 2718 :        circ_debug(dx[0][0],dx[0][1],dx[1][0],dx[1][1],&ch[0],&si[0],
; 2719 :          &co[0],&an[0]);
; 2720 :        dx[i][j] -= 2*delta;
; 2721 :        circ_debug(dx[0][0],dx[0][1],dx[1][0],dx[1][1],&ch[1],&si[1],
; 2722 :          &co[1],&an[1]);
; 2723 :        dx[ii][jj] -= 2*delta;
; 2724 :        circ_debug(dx[0][0],dx[0][1],dx[1][0],dx[1][1],&ch[3],&si[3],
; 2725 :          &co[3],&an[3]);
; 2726 :        dx[i][j] += 2*delta;
; 2727 :        circ_debug(dx[0][0],dx[0][1],dx[1][0],dx[1][1],&ch[2],&si[2],
; 2728 :          &co[2],&an[2]);
; 2729 :        dx[ii][jj] += 2*delta;
; 2730 : 
; 2731 :        printf("ddchord[%d][%d][%d][%d]: %18.15f %18.15f\n",2*i,j,2*ii,jj,
; 2732 :           (ch[0]-ch[1]-ch[2]+ch[3])/delta/delta/4,ddchord[2*i][j][2*ii][jj]);
; 2733 :        printf("ddsinth[%d][%d][%d][%d]: %18.15f %18.15f\n",2*i,j,2*ii,jj,
; 2734 :           (si[0]-si[1]-si[2]+si[3])/delta/delta/4,ddsinth[2*i][j][2*ii][jj]);
; 2735 :        printf("ddcosth[%d][%d][%d][%d]: %18.15f %18.15f\n",2*i,j,2*ii,jj,
; 2736 :           (co[0]-co[1]-co[2]+co[3])/delta/delta/4,ddcosth[2*i][j][2*ii][jj]);
; 2737 :        printf("ddangle[%d][%d][%d][%d]: %18.15f %18.15f\n",2*i,j,2*ii,jj,
; 2738 :           (an[0]-an[1]-an[2]+an[3])/delta/delta/4,ddangle[2*i][j][2*ii][jj]);
; 2739 :      }
; 2740 : }
; 2741 : #endif
; 2742 : 
; 2743 :    return;
; 2744 : } // end void circular_arc_aux()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN370@circular_a@2:

; 2551 : 
; 2552 :   if ( mode == METHOD_GRADIENT ) return;

	fstp	ST(4)
	pop	edi
	fstp	ST(1)
	pop	ebx
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)
$LN10@circular_a@2:

; 2697 : 
; 2698 : 
; 2699 : #ifdef XXX
; 2700 : /* debugging */
; 2701 : { REAL dx[2][2];
; 2702 :   REAL ch[4],si[4],co[4],an[4];
; 2703 :   REAL delta = 1e-4;
; 2704 :   dx[0][0] = dx1;
; 2705 :   dx[0][1] = dy1;
; 2706 :   dx[1][0] = dx2;
; 2707 :   dx[1][1] = dy2;
; 2708 : 
; 2709 : /* check numerically */
; 2710 :   
; 2711 : 
; 2712 :   for ( i = 0 ; i < 2; i++ )
; 2713 :    for ( j = 0 ; j < 2; j++ )
; 2714 :     for ( ii = 0 ; ii < 2 ; ii ++ )
; 2715 :      for ( jj = 0 ; jj < 2 ; jj ++ )
; 2716 :      { dx[i][j] += delta;
; 2717 :        dx[ii][jj] += delta;
; 2718 :        circ_debug(dx[0][0],dx[0][1],dx[1][0],dx[1][1],&ch[0],&si[0],
; 2719 :          &co[0],&an[0]);
; 2720 :        dx[i][j] -= 2*delta;
; 2721 :        circ_debug(dx[0][0],dx[0][1],dx[1][0],dx[1][1],&ch[1],&si[1],
; 2722 :          &co[1],&an[1]);
; 2723 :        dx[ii][jj] -= 2*delta;
; 2724 :        circ_debug(dx[0][0],dx[0][1],dx[1][0],dx[1][1],&ch[3],&si[3],
; 2725 :          &co[3],&an[3]);
; 2726 :        dx[i][j] += 2*delta;
; 2727 :        circ_debug(dx[0][0],dx[0][1],dx[1][0],dx[1][1],&ch[2],&si[2],
; 2728 :          &co[2],&an[2]);
; 2729 :        dx[ii][jj] += 2*delta;
; 2730 : 
; 2731 :        printf("ddchord[%d][%d][%d][%d]: %18.15f %18.15f\n",2*i,j,2*ii,jj,
; 2732 :           (ch[0]-ch[1]-ch[2]+ch[3])/delta/delta/4,ddchord[2*i][j][2*ii][jj]);
; 2733 :        printf("ddsinth[%d][%d][%d][%d]: %18.15f %18.15f\n",2*i,j,2*ii,jj,
; 2734 :           (si[0]-si[1]-si[2]+si[3])/delta/delta/4,ddsinth[2*i][j][2*ii][jj]);
; 2735 :        printf("ddcosth[%d][%d][%d][%d]: %18.15f %18.15f\n",2*i,j,2*ii,jj,
; 2736 :           (co[0]-co[1]-co[2]+co[3])/delta/delta/4,ddcosth[2*i][j][2*ii][jj]);
; 2737 :        printf("ddangle[%d][%d][%d][%d]: %18.15f %18.15f\n",2*i,j,2*ii,jj,
; 2738 :           (an[0]-an[1]-an[2]+an[3])/delta/delta/4,ddangle[2*i][j][2*ii][jj]);
; 2739 :      }
; 2740 : }
; 2741 : #endif
; 2742 : 
; 2743 :    return;
; 2744 : } // end void circular_arc_aux()

	mov	esp, ebp
	pop	ebp
	ret	0
_circular_arc_aux ENDP
_TEXT	ENDS
PUBLIC	_cirf
EXTRN	__CIsin:PROC
; Function compile flags: /Ogtp
;	COMDAT _cirf
_TEXT	SEGMENT
_th$ = 8						; size = 8
_cirf	PROC						; COMDAT

; 2801 : { if ( th == 0.0 ) return 1.0;

	push	ebp
	mov	ebp, esp
	fld	QWORD PTR _th$[ebp]
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@cirf
	fstp	ST(0)
	fld1

; 2803 : }

	pop	ebp
	ret	0
$LN1@cirf:

; 2802 :   return th/sin(th);

	call	__CIsin
	fdivr	QWORD PTR _th$[ebp]

; 2803 : }

	pop	ebp
	ret	0
_cirf	ENDP
_TEXT	ENDS
PUBLIC	__real@3fd5555555555555
PUBLIC	__real@3fb3e93e93e93e94
PUBLIC	__real@3f89319319319319
PUBLIC	__real@3f5b85fca40e852d
PUBLIC	__real@4114e20000000000
PUBLIC	__real@4052400000000000
PUBLIC	__real@3fb999999999999a
PUBLIC	_cirfp
EXTRN	__CIcos:PROC
;	COMDAT __real@3fd5555555555555
CONST	SEGMENT
__real@3fd5555555555555 DQ 03fd5555555555555r	; 0.333333
CONST	ENDS
;	COMDAT __real@3fb3e93e93e93e94
CONST	SEGMENT
__real@3fb3e93e93e93e94 DQ 03fb3e93e93e93e94r	; 0.0777778
CONST	ENDS
;	COMDAT __real@3f89319319319319
CONST	SEGMENT
__real@3f89319319319319 DQ 03f89319319319319r	; 0.0123016
CONST	ENDS
;	COMDAT __real@3f5b85fca40e852d
CONST	SEGMENT
__real@3f5b85fca40e852d DQ 03f5b85fca40e852dr	; 0.00167989
CONST	ENDS
;	COMDAT __real@4114e20000000000
CONST	SEGMENT
__real@4114e20000000000 DQ 04114e20000000000r	; 342144
CONST	ENDS
;	COMDAT __real@4052400000000000
CONST	SEGMENT
__real@4052400000000000 DQ 04052400000000000r	; 73
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _cirfp
_TEXT	SEGMENT
tv177 = -8						; size = 8
_th$ = 8						; size = 8
_cirfp	PROC						; COMDAT

; 2807 : { if ( fabs(th) < .1 )

	push	ebp
	mov	ebp, esp
	fld	QWORD PTR _th$[ebp]
	sub	esp, 8
	fld	ST(0)
	fabs
	fcomp	QWORD PTR __real@3fb999999999999a
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@cirfp

; 2808 :    return th*(1./3 + th*th*(7./90 + th*th*(31./2520
; 2809 :        + th*th*(127./75600 + th*th*73./342144))));

	fld	ST(0)
	fmul	ST(0), ST(1)
	fld	QWORD PTR __real@4052400000000000
	fmul	ST(0), ST(1)
	fdiv	QWORD PTR __real@4114e20000000000
	fadd	QWORD PTR __real@3f5b85fca40e852d
	fmul	ST(0), ST(1)
	fadd	QWORD PTR __real@3f89319319319319
	fmul	ST(0), ST(1)
	fadd	QWORD PTR __real@3fb3e93e93e93e94
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR __real@3fd5555555555555
	fmulp	ST(1), ST(0)

; 2811 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@cirfp:

; 2810 :   return (sin(th)-th*cos(th))/sin(th)/sin(th);

	call	__CIsin
	fstp	QWORD PTR tv177[ebp]
	fld	QWORD PTR _th$[ebp]
	call	__CIcos
	fmul	QWORD PTR _th$[ebp]
	fld	QWORD PTR tv177[ebp]
	fld	ST(0)
	fsubrp	ST(2), ST(0)
	fdiv	ST(1), ST(0)
	fdivp	ST(1), ST(0)

; 2811 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_cirfp	ENDP
_TEXT	ENDS
PUBLIC	__real@3fcdddddddddddde
PUBLIC	__real@3faf7df7df7df7df
PUBLIC	__real@3f88153d0f8cb487
PUBLIC	__real@40e2900000000000
PUBLIC	_cirfpp
;	COMDAT __real@3fcdddddddddddde
CONST	SEGMENT
__real@3fcdddddddddddde DQ 03fcdddddddddddder	; 0.233333
CONST	ENDS
;	COMDAT __real@3faf7df7df7df7df
CONST	SEGMENT
__real@3faf7df7df7df7df DQ 03faf7df7df7df7dfr	; 0.0615079
CONST	ENDS
;	COMDAT __real@3f88153d0f8cb487
CONST	SEGMENT
__real@3f88153d0f8cb487 DQ 03f88153d0f8cb487r	; 0.0117593
CONST	ENDS
;	COMDAT __real@40e2900000000000
CONST	SEGMENT
__real@40e2900000000000 DQ 040e2900000000000r	; 38016
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _cirfpp
_TEXT	SEGMENT
_s$ = -8						; size = 8
_th$ = 8						; size = 8
_cirfpp	PROC						; COMDAT

; 2815 : { REAL s,c;

	push	ebp
	mov	ebp, esp

; 2816 :   if ( fabs(th) < .1 )

	fld	QWORD PTR _th$[ebp]
	sub	esp, 8
	fld	ST(0)
	fabs
	fcomp	QWORD PTR __real@3fb999999999999a
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@cirfpp

; 2817 :    return (1./3 + th*th*(7./30 + th*th*(31./504
; 2818 :        + th*th*(127./10800 + th*th*73./38016))));

	fmul	ST(0), ST(0)
	fld	QWORD PTR __real@4052400000000000
	fmul	ST(0), ST(1)
	fdiv	QWORD PTR __real@40e2900000000000
	fadd	QWORD PTR __real@3f88153d0f8cb487
	fmul	ST(0), ST(1)
	fadd	QWORD PTR __real@3faf7df7df7df7df
	fmul	ST(0), ST(1)
	fadd	QWORD PTR __real@3fcdddddddddddde
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR __real@3fd5555555555555

; 2821 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@cirfpp:

; 2819 :   s = sin(th); c = cos(th);

	call	__CIsin
	fstp	QWORD PTR _s$[ebp]
	fld	QWORD PTR _th$[ebp]
	call	__CIcos

; 2820 :   return (-2*c/s + th*c*c/s/s + th/s/s)/s;

	fld	ST(0)
	fld	QWORD PTR _th$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fld	QWORD PTR _s$[ebp]
	fdiv	ST(1), ST(0)
	fdiv	ST(1), ST(0)
	fxch	ST(3)
	fadd	ST(0), ST(0)
	fdiv	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fdivrp	ST(1), ST(0)

; 2821 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_cirfpp	ENDP
_TEXT	ENDS
PUBLIC	__real@3fe5555555555555
PUBLIC	__real@3fb6c16c16c16c17
PUBLIC	__real@3f8a01a01a01a01a
PUBLIC	__real@3f5bbd779334ef0b
PUBLIC	__real@40d245c000000000
PUBLIC	__real@4010000000000000
PUBLIC	_caf
;	COMDAT __real@3fe5555555555555
CONST	SEGMENT
__real@3fe5555555555555 DQ 03fe5555555555555r	; 0.666667
CONST	ENDS
;	COMDAT __real@3fb6c16c16c16c17
CONST	SEGMENT
__real@3fb6c16c16c16c17 DQ 03fb6c16c16c16c17r	; 0.0888889
CONST	ENDS
;	COMDAT __real@3f8a01a01a01a01a
CONST	SEGMENT
__real@3f8a01a01a01a01a DQ 03f8a01a01a01a01ar	; 0.0126984
CONST	ENDS
;	COMDAT __real@3f5bbd779334ef0b
CONST	SEGMENT
__real@3f5bbd779334ef0b DQ 03f5bbd779334ef0br	; 0.00169312
CONST	ENDS
;	COMDAT __real@40d245c000000000
CONST	SEGMENT
__real@40d245c000000000 DQ 040d245c000000000r	; 18711
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _caf
_TEXT	SEGMENT
tv162 = -8						; size = 8
_th$ = 8						; size = 8
_caf	PROC						; COMDAT

; 2979 : { if ( fabs(th) > .1 )

	push	ebp
	mov	ebp, esp
	fld	QWORD PTR _th$[ebp]
	sub	esp, 8
	fld	ST(0)
	fabs
	fcomp	QWORD PTR __real@3fb999999999999a
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@caf

; 2980 :     return (th - sin(th)*cos(th))/sin(th)/sin(th);

	call	__CIsin
	fstp	QWORD PTR tv162[ebp]
	fld	QWORD PTR _th$[ebp]
	call	__CIcos
	fld	QWORD PTR tv162[ebp]
	fmul	ST(1), ST(0)
	fld	QWORD PTR _th$[ebp]
	fsubrp	ST(2), ST(0)
	fdiv	ST(1), ST(0)
	fdivp	ST(1), ST(0)

; 2983 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@caf:

; 2981 :   return th*(2./3 + th*th*(4./45 + th*th*(4./315 + th*th*(8./4725 
; 2982 :    + th*th*4./18711))));

	fld	ST(0)
	fmul	ST(0), ST(1)
	fld	QWORD PTR __real@4010000000000000
	fmul	ST(0), ST(1)
	fdiv	QWORD PTR __real@40d245c000000000
	fadd	QWORD PTR __real@3f5bbd779334ef0b
	fmul	ST(0), ST(1)
	fadd	QWORD PTR __real@3f8a01a01a01a01a
	fmul	ST(0), ST(1)
	fadd	QWORD PTR __real@3fb6c16c16c16c17
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR __real@3fe5555555555555
	fmulp	ST(1), ST(0)

; 2983 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_caf	ENDP
_TEXT	ENDS
PUBLIC	__real@3fd1111111111111
PUBLIC	__real@3fb0410410410410
PUBLIC	__real@3f8845c8a0ce5129
PUBLIC	__real@40a03e0000000000
PUBLIC	_cafp
;	COMDAT __real@3fd1111111111111
CONST	SEGMENT
__real@3fd1111111111111 DQ 03fd1111111111111r	; 0.266667
CONST	ENDS
;	COMDAT __real@3fb0410410410410
CONST	SEGMENT
__real@3fb0410410410410 DQ 03fb0410410410410r	; 0.0634921
CONST	ENDS
;	COMDAT __real@3f8845c8a0ce5129
CONST	SEGMENT
__real@3f8845c8a0ce5129 DQ 03f8845c8a0ce5129r	; 0.0118519
CONST	ENDS
;	COMDAT __real@40a03e0000000000
CONST	SEGMENT
__real@40a03e0000000000 DQ 040a03e0000000000r	; 2079
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _cafp
_TEXT	SEGMENT
tv162 = -8						; size = 8
_th$ = 8						; size = 8
_cafp	PROC						; COMDAT

; 2987 : { if ( fabs(th) > .1 )

	push	ebp
	mov	ebp, esp
	fld	QWORD PTR _th$[ebp]
	sub	esp, 8
	fld	ST(0)
	fabs
	fcomp	QWORD PTR __real@3fb999999999999a
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@cafp

; 2988 :    return  2*(sin(th) - th*cos(th))/sin(th)/sin(th)/sin(th);

	call	__CIsin
	fstp	QWORD PTR tv162[ebp]
	fld	QWORD PTR _th$[ebp]
	call	__CIcos
	fmul	QWORD PTR _th$[ebp]
	fld	QWORD PTR tv162[ebp]
	fld	ST(0)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fadd	ST(0), ST(0)
	fdiv	ST(0), ST(1)
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)

; 2990 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@cafp:

; 2989 :   return 2./3 + th*th*(4./15 + th*th*(4./63 + th*th*(8./675 + th*th*4./2079)));

	fmul	ST(0), ST(0)
	fld	QWORD PTR __real@4010000000000000
	fmul	ST(0), ST(1)
	fdiv	QWORD PTR __real@40a03e0000000000
	fadd	QWORD PTR __real@3f8845c8a0ce5129
	fmul	ST(0), ST(1)
	fadd	QWORD PTR __real@3fb0410410410410
	fmul	ST(0), ST(1)
	fadd	QWORD PTR __real@3fd1111111111111
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR __real@3fe5555555555555

; 2990 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_cafp	ENDP
_TEXT	ENDS
PUBLIC	__real@3fe1111111111111
PUBLIC	__real@3fd0410410410410
PUBLIC	__real@3fb23456789abcdf
PUBLIC	__real@4040000000000000
PUBLIC	__real@4018000000000000
PUBLIC	_cafpp
;	COMDAT __real@3fe1111111111111
CONST	SEGMENT
__real@3fe1111111111111 DQ 03fe1111111111111r	; 0.533333
CONST	ENDS
;	COMDAT __real@3fd0410410410410
CONST	SEGMENT
__real@3fd0410410410410 DQ 03fd0410410410410r	; 0.253968
CONST	ENDS
;	COMDAT __real@3fb23456789abcdf
CONST	SEGMENT
__real@3fb23456789abcdf DQ 03fb23456789abcdfr	; 0.0711111
CONST	ENDS
;	COMDAT __real@4040000000000000
CONST	SEGMENT
__real@4040000000000000 DQ 04040000000000000r	; 32
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _cafpp
_TEXT	SEGMENT
_s$90909 = -8						; size = 8
_th$ = 8						; size = 8
_cafpp	PROC						; COMDAT

; 2994 : { if ( fabs(th) > .1 )

	push	ebp
	mov	ebp, esp
	fld	QWORD PTR _th$[ebp]
	sub	esp, 8
	fld	ST(0)
	fabs
	fcomp	QWORD PTR __real@3fb999999999999a
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@cafpp

; 2995 :   { REAL s = sin(th), c = cos(th);

	call	__CIsin
	fstp	QWORD PTR _s$90909[ebp]
	fld	QWORD PTR _th$[ebp]
	call	__CIcos

; 2996 :     return (4*th + 2*th*(c*c-s*s) - 6*s*c)/s/s/s/s;

	fld	ST(0)
	fmul	ST(0), ST(1)
	fld	QWORD PTR _s$90909[ebp]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fld	QWORD PTR _th$[ebp]
	fld	ST(0)
	fadd	ST(0), ST(1)
	fmulp	ST(3), ST(0)
	fmul	QWORD PTR __real@4010000000000000
	faddp	ST(2), ST(0)
	fld	QWORD PTR __real@4018000000000000
	fmul	ST(0), ST(1)
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	fsubrp	ST(2), ST(0)
	fdiv	ST(1), ST(0)
	fdiv	ST(1), ST(0)
	fdiv	ST(1), ST(0)
	fdivp	ST(1), ST(0)

; 2999 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@cafpp:

; 2997 :   }
; 2998 :   return th*(8./15 + th*th*(16./63 + th*th*(16./225 + th*th*32./2079)));

	fld	ST(0)
	fmul	ST(0), ST(1)
	fld	QWORD PTR __real@4040000000000000
	fmul	ST(0), ST(1)
	fdiv	QWORD PTR __real@40a03e0000000000
	fadd	QWORD PTR __real@3fb23456789abcdf
	fmul	ST(0), ST(1)
	fadd	QWORD PTR __real@3fd0410410410410
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR __real@3fe1111111111111
	fmulp	ST(1), ST(0)

; 2999 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_cafpp	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@LJGINCKC@circular_arc_area?5method?5needs?5L@ ; `string'
PUBLIC	_circular_arc_area_init
;	COMDAT ??_C@_0DL@LJGINCKC@circular_arc_area?5method?5needs?5L@
CONST	SEGMENT
??_C@_0DL@LJGINCKC@circular_arc_area?5method?5needs?5L@ DB 'circular_arc_'
	DB	'area method needs LINEAR or QUADRATIC model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _circular_arc_area_init
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_circular_arc_area_init PROC				; COMDAT

; 3011 :   if ( (web.modeltype == LAGRANGE) && (web.lagrange_order >= 2) )

	cmp	DWORD PTR _web+628, 3
	jne	SHORT $LN1@circular_a@3
	cmp	DWORD PTR _web+632, 2
	jl	SHORT $LN1@circular_a@3

; 3012 :     kb_error(2860,"circular_arc_area method needs LINEAR or QUADRATIC model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DL@LJGINCKC@circular_arc_area?5method?5needs?5L@
	push	2860					; 00000b2cH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@circular_a@3:

; 3013 : }

	ret	0
_circular_arc_area_init ENDP
_TEXT	ENDS
PUBLIC	__real@c000000000000000
PUBLIC	__real@bfe0000000000000
PUBLIC	_spherical_arc_length_all
EXTRN	__CIasin:PROC
;	COMDAT __real@c000000000000000
CONST	SEGMENT
__real@c000000000000000 DQ 0c000000000000000r	; -2
CONST	ENDS
;	COMDAT __real@bfe0000000000000
CONST	SEGMENT
__real@bfe0000000000000 DQ 0bfe0000000000000r	; -0.5
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _spherical_arc_length_all
_TEXT	SEGMENT
tv604 = -48						; size = 8
tv366 = -48						; size = 8
tv352 = -40						; size = 8
_c$ = -32						; size = 8
_density$ = -24						; size = 8
_value$ = -16						; size = 8
_radius$ = -8						; size = 8
_e_info$ = 8						; size = 4
_mode$ = 12						; size = 4
_spherical_arc_length_all PROC				; COMDAT

; 3268 : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 3269 :   REAL density = 1.0;
; 3270 :   REAL radius = sqrt(SDIM_dot(e_info->x[0],e_info->x[0]));

	mov	ecx, DWORD PTR _web+616
	fld1
	push	ebx
	fstp	QWORD PTR _density$[ebp]
	mov	ebx, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [ebx+416]
	push	esi
	push	edi
	push	ecx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fstp	QWORD PTR _radius$[ebp]

; 3271 :   REAL c,value;
; 3272 :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	eax, DWORD PTR [ebx+8]
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list

; 3273 : 
; 3274 :   /* Linear mode only for now */
; 3275 : 
; 3276 :   if ( mi->flags & USE_DENSITY )

	test	DWORD PTR [esi+140], 536870912		; 20000000H
	je	SHORT $LN15@spherical_

; 3277 :     density = get_edge_density(e_info->id);

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	fld	QWORD PTR [ecx+40]
	fstp	QWORD PTR _density$[ebp]
$LN15@spherical_:

; 3278 : 
; 3279 :   c = SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]);

	mov	edx, DWORD PTR [ebx+1276]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [eax]
	push	ecx
	push	eax
	push	eax
	call	_dot
	fst	QWORD PTR _c$[ebp]
	add	esp, 12					; 0000000cH

; 3280 :   value = 2*radius*asin(sqrt(c)/2/radius);

	call	__CIsqrt
	fst	QWORD PTR tv352[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _radius$[ebp]
	call	__CIasin
	fld	QWORD PTR _radius$[ebp]

; 3281 :   
; 3282 : 
; 3283 :   if ( mode == METHOD_VALUE )

	mov	edi, DWORD PTR _mode$[ebp]
	fld	ST(0)
	fadd	ST(0), ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _value$[ebp]
	cmp	edi, 1767				; 000006e7H
	jne	SHORT $LN13@spherical_

; 3284 :     if ( mi->flags & DEFAULT_INSTANCE )

	test	DWORD PTR [esi+140], 4194304		; 00400000H
	je	SHORT $LN13@spherical_
	fstp	ST(1)

; 3285 :     { binary_tree_add(web.total_area_addends,value);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1000
	call	_binary_tree_add

; 3286 :       set_edge_length(e_info->id,value); 

	fld	QWORD PTR _value$[ebp]
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR _web+124
	add	esp, 12					; 0000000cH
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	fst	QWORD PTR [ecx+48]
	fld	QWORD PTR _radius$[ebp]
	fxch	ST(1)
$LN13@spherical_:

; 3287 :     }
; 3288 : 
; 3289 :   value *= density;

	fld	QWORD PTR _density$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _value$[ebp]

; 3290 :   if ( mode == METHOD_VALUE ) return value;

	cmp	edi, 1767				; 000006e7H
	jne	SHORT $LN33@spherical_
	pop	edi
	fstp	ST(1)
	pop	esi
	fstp	ST(1)
	pop	ebx

; 3323 : } /* end spherical_arc_length_all */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@spherical_:

; 3291 : 
; 3292 :   /* gradient */
; 3293 :   for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	fstp	ST(0)
	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN36@spherical_

; 3294 :   { REAL g =
; 3295 :       density*2*radius/sqrt(4*radius*radius - c)/sqrt(c)*
; 3296 :             e_info->sides[0][0][i];

	fadd	ST(0), ST(0)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR tv604[ebp]
	fld	QWORD PTR __real@4010000000000000
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fsub	QWORD PTR _c$[ebp]
	call	__CIsqrt
	fdivr	QWORD PTR tv604[ebp]
	fdiv	QWORD PTR tv352[ebp]
$LN11@spherical_:
	mov	edx, DWORD PTR [ebx+1276]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	fld	QWORD PTR [ecx+esi*8]

; 3297 :     e_info->grad[0][i] = -g;

	mov	edx, DWORD PTR [ebx+1336]
	mov	eax, DWORD PTR [edx]
	fmul	ST(0), ST(1)
	inc	esi
	fld	ST(0)
	fchs
	fstp	QWORD PTR [eax+esi*8-8]

; 3298 :     e_info->grad[1][i] =  g;

	mov	ecx, DWORD PTR [ebx+1336]
	mov	edx, DWORD PTR [ecx+4]
	fstp	QWORD PTR [edx+esi*8-8]
	mov	eax, DWORD PTR _web+616
	cmp	esi, eax
	jl	SHORT $LN11@spherical_

; 3291 : 
; 3292 :   /* gradient */
; 3293 :   for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
	fld	QWORD PTR _radius$[ebp]
	jmp	SHORT $LN9@spherical_
$LN36@spherical_:
	fstp	ST(0)
$LN9@spherical_:

; 3299 :   }
; 3300 :  
; 3301 :   if ( mode == METHOD_GRADIENT ) return value;

	cmp	edi, 4321				; 000010e1H
	je	$LN54@spherical_

; 3302 : 
; 3303 :   /* hessian */
; 3304 :   for ( i = 0 ; i < SDIM ; i++ )

	xor	edi, edi
	test	eax, eax
	jle	$LN54@spherical_
$LN25@spherical_:

; 3305 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	eax, eax
	jle	$LN6@spherical_
	fld	QWORD PTR __real@4010000000000000
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fsub	QWORD PTR _c$[ebp]
	call	__CIsqrt

; 3306 :     { REAL h,d;
; 3307 :       d = sqrt(4*radius*radius - c);
; 3308 :       h = (-.5)/d/d/d*(-2*e_info->sides[0][0][j])/sqrt(c)* 
; 3309 :             e_info->sides[0][0][i]
; 3310 :        +  1/sqrt(4*radius*radius - c)*(-.5)/sqrt(c)
; 3311 :              /sqrt(c)/sqrt(c)*2*e_info->sides[0][0][j]*
; 3312 :             e_info->sides[0][0][i];

	fld	QWORD PTR __real@bfe0000000000000
	fdiv	ST(0), ST(1)
	fld	QWORD PTR tv352[ebp]
	fdiv	ST(1), ST(0)
	fdiv	ST(1), ST(0)
	fdiv	ST(1), ST(0)
	fld	QWORD PTR __real@4000000000000000
	fmul	ST(2), ST(0)
	fmul	QWORD PTR _density$[ebp]
	fld	QWORD PTR _radius$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv366[ebp]
	fld	QWORD PTR __real@c000000000000000
$LN24@spherical_:
	mov	eax, DWORD PTR [ebx+1276]
	fld	ST(4)
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	fld	QWORD PTR [eax+esi*8]
	mov	edx, DWORD PTR [ebx+1276]
	fmul	ST(0), ST(5)
	mov	ecx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	fmul	QWORD PTR [eax+edi*8]
	fld	QWORD PTR __real@3fe0000000000000
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(2)
	fdivrp	ST(2), ST(0)
	fld	QWORD PTR [ecx+esi*8]
	fmul	ST(0), ST(3)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(4)
	fmul	QWORD PTR [ecx+edi*8]
	fsubp	ST(1), ST(0)

; 3313 :       if ( i == j ) 

	cmp	edi, esi
	jne	SHORT $LN1@spherical_

; 3314 :         h +=  1/sqrt(4*radius*radius - c)/sqrt(c);

	fld1
	fdiv	ST(0), ST(6)
	fdiv	ST(0), ST(4)
	faddp	ST(1), ST(0)
$LN1@spherical_:

; 3315 :       h *= density*2*radius;
; 3316 :       e_info->hess[0][0][i][j] =  h;

	mov	edx, DWORD PTR [ebx+1340]
	fmul	QWORD PTR tv366[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edi*4]
	fst	QWORD PTR [edx+esi*8]

; 3317 :       e_info->hess[1][0][i][j] = -h;

	mov	eax, DWORD PTR [ebx+1340]
	mov	ecx, DWORD PTR [eax+4]
	fld	ST(0)
	mov	edx, DWORD PTR [ecx]
	fchs
	mov	eax, DWORD PTR [edx+edi*4]
	fst	QWORD PTR [eax+esi*8]

; 3318 :       e_info->hess[0][1][i][j] = -h;

	mov	ecx, DWORD PTR [ebx+1340]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+edi*4]
	fstp	QWORD PTR [ecx+esi*8]

; 3319 :       e_info->hess[1][1][i][j] =  h;

	mov	edx, DWORD PTR [ebx+1340]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edi*4]
	fstp	QWORD PTR [edx+esi*8]
	mov	eax, DWORD PTR _web+616
	inc	esi
	cmp	esi, eax
	jl	$LN24@spherical_

; 3305 :     for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(2)
	fstp	ST(3)
	fstp	ST(1)
	fstp	ST(0)
$LN6@spherical_:

; 3302 : 
; 3303 :   /* hessian */
; 3304 :   for ( i = 0 ; i < SDIM ; i++ )

	inc	edi
	cmp	edi, eax
	jl	$LN25@spherical_
$LN54@spherical_:
	pop	edi

; 3305 :     for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)

; 3320 :     }  
; 3321 :  
; 3322 :   return value;

	fld	QWORD PTR _value$[ebp]
	pop	esi
	pop	ebx

; 3323 : } /* end spherical_arc_length_all */

	mov	esp, ebp
	pop	ebp
	ret	0
_spherical_arc_length_all ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@NKLBFKAG@spherical_arc_area?5only?5in?5LINEA@ ; `string'
PUBLIC	_spherical_arc_area_init
;	COMDAT ??_C@_0CJ@NKLBFKAG@spherical_arc_area?5only?5in?5LINEA@
CONST	SEGMENT
??_C@_0CJ@NKLBFKAG@spherical_arc_area?5only?5in?5LINEA@ DB 'spherical_arc'
	DB	'_area only in LINEAR mode.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _spherical_arc_area_init
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_spherical_arc_area_init PROC				; COMDAT

; 3361 :   if ( web.modeltype != LINEAR )

	cmp	DWORD PTR _web+628, 1
	je	SHORT $LN1@spherical_@2

; 3362 :     kb_error(3944,"spherical_arc_area only in LINEAR mode.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CJ@NKLBFKAG@spherical_arc_area?5only?5in?5LINEA@
	push	3944					; 00000f68H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@spherical_@2:

; 3363 : }

	ret	0
_spherical_arc_area_init ENDP
_TEXT	ENDS
PUBLIC	__real@3fd0000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_spherical_arc_area_all
EXTRN	_memset:PROC
EXTRN	__CItan:PROC
EXTRN	__CIatan:PROC
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _spherical_arc_area_all
_TEXT	SEGMENT
_denom$ = -800						; size = 16
tv3606 = -784						; size = 8
tv3612 = -776						; size = 8
tv3542 = -768						; size = 8
tv3608 = -760						; size = 8
tv3736 = -752						; size = 8
tv3505 = -744						; size = 8
tv1725 = -736						; size = 8
tv3729 = -732						; size = 4
_rad$ = -728						; size = 8
tv288 = -724						; size = 4
_area$ = -720						; size = 8
_ang1$ = -720						; size = 8
_ang2$ = -712						; size = 8
tv3727 = -708						; size = 4
tv3386 = -704						; size = 4
tv1636 = -700						; size = 8
tv3725 = -696						; size = 4
tv3388 = -692						; size = 4
tv3470 = -688						; size = 4
tv2762 = -684						; size = 4
tv1799 = -680						; size = 8
tv1747 = -680						; size = 8
tv3464 = -676						; size = 4
tv3528 = -672						; size = 4
_denom12$ = -668					; size = 8
_ang12$ = -668						; size = 8
_ss12$ = -668						; size = 8
tv3706 = -664						; size = 4
tv245 = -664						; size = 4
tv3593 = -660						; size = 8
tv3591 = -660						; size = 8
tv3589 = -660						; size = 8
tv2006 = -660						; size = 8
tv1759 = -660						; size = 8
_ss2$ = -660						; size = 8
_dlegnorm$ = -652					; size = 288
_ddenom$ = -364						; size = 96
_dndx$ = -268						; size = 144
_ddenom12$ = -124					; size = 48
_legnorm$ = -76						; size = 48
_normal$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_mode$ = 12						; size = 4
_pole$ = 16						; size = 4
_spherical_arc_area_all PROC				; COMDAT

; 3369 : { int i,j,ii,jj;

	push	ebp
	mov	ebp, esp
	sub	esp, 800				; 00000320H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3370 :   REAL area;
; 3371 :   REAL *x[2];
; 3372 :   REAL rad = pole*sqrt(SDIM_dot(e_info->x[0],e_info->x[0]));

	mov	ecx, DWORD PTR _web+616
	fild	DWORD PTR _pole$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [ebx+416]
	fstp	QWORD PTR tv1636[ebp]
	push	esi
	push	edi
	push	ecx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fmul	QWORD PTR tv1636[ebp]

; 3373 :   REAL normal[3],dndx[3][2][3]; /* normal component derivatives */
; 3374 :   REAL ss1,ss2,ss12;
; 3375 :   REAL legnorm[2][3],dlegnorm[2][3][2][3];
; 3376 :   REAL ang1,ang2,ang12;
; 3377 :   REAL denom[2],denom12;
; 3378 :   REAL ddenom[2][2][3],ddenom12[2][3];
; 3379 : 
; 3380 :   x[0] = e_info->x[0];
; 3381 :   x[1] = e_info->x[1];

	mov	edi, DWORD PTR [ebx+420]
	mov	esi, DWORD PTR [ebx+416]
	fst	QWORD PTR _rad$[ebp]

; 3382 : 
; 3383 :   /* area from pole */
; 3384 : 
; 3385 :   normal[0] = x[0][1]*x[1][2] - x[0][2]*x[1][1];

	fld	QWORD PTR [edi+16]
	fmul	QWORD PTR [esi+8]
	fld	QWORD PTR [edi+8]
	fmul	QWORD PTR [esi+16]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _normal$[ebp]

; 3386 :   normal[1] = x[0][2]*x[1][0] - x[0][0]*x[1][2];

	fld	QWORD PTR [esi+16]
	fmul	QWORD PTR [edi]
	fld	QWORD PTR [esi]
	fmul	QWORD PTR [edi+16]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _normal$[ebp+8]

; 3387 :   normal[2] = x[0][0]*x[1][1] - x[0][1]*x[1][0];

	fld	QWORD PTR [esi]
	fmul	QWORD PTR [edi+8]
	fld	QWORD PTR [esi+8]
	fmul	QWORD PTR [edi]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _normal$[ebp+16]

; 3388 :  
; 3389 :   /* L'Huilier's formula, nonsingular for degenerate triangles */
; 3390 :   ss1 = (x[0][0]*x[0][0] + x[0][1]*x[0][1] + (x[0][2]-rad)*(x[0][2]-rad))/
; 3391 :              rad/rad/4;

	fld	QWORD PTR [esi+8]
	fld	QWORD PTR [esi]
	fld	QWORD PTR [esi+16]
	fsub	ST(0), ST(3)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fld	ST(2)
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(1)
	fdiv	ST(0), ST(1)
	fld	QWORD PTR __real@3fd0000000000000
	fmul	ST(1), ST(0)

; 3392 :   ss2 = (x[1][0]*x[1][0] + x[1][1]*x[1][1] + (x[1][2]-rad)*(x[1][2]-rad))/
; 3393 :              rad/rad/4;

	fld	QWORD PTR [edi+16]
	fsub	ST(0), ST(3)
	fld	QWORD PTR [edi+8]
	fld	QWORD PTR [edi]
	fmul	ST(0), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(3)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _ss2$[ebp]

; 3394 :   ss12 = ((x[1][0]-x[0][0])*(x[1][0]-x[0][0]) 
; 3395 :         + (x[1][1]-x[0][1])*(x[1][1]-x[0][1]) 
; 3396 :         + (x[1][2]-x[0][2])*(x[1][2]-x[0][2]))/rad/rad/4;

	fld	QWORD PTR [edi+8]
	fsub	QWORD PTR [esi+8]
	fld	QWORD PTR [edi]
	fsub	QWORD PTR [esi]
	fld	QWORD PTR [edi+16]
	fsub	QWORD PTR [esi+16]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fld	ST(2)
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(3)
	fdivrp	ST(3), ST(0)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _ss12$[ebp]

; 3397 :   ang1 = atan(sqrt(ss1/(1-ss1)));

	fld1
	fsub	ST(0), ST(1)
	fdivp	ST(1), ST(0)
	call	__CIsqrt
	call	__CIatan
	fstp	QWORD PTR _ang1$[ebp]

; 3398 :   ang2 = atan(sqrt(ss2/(1-ss2)));

	fld1
	fld	QWORD PTR _ss2$[ebp]
	fsub	ST(1), ST(0)
	fdivrp	ST(1), ST(0)
	call	__CIsqrt
	call	__CIatan
	fstp	QWORD PTR _ang2$[ebp]

; 3399 :   ang12 = atan(sqrt(ss12/(1-ss12)));

	fld1
	fld	QWORD PTR _ss12$[ebp]
	fsub	ST(1), ST(0)
	fdivrp	ST(1), ST(0)
	call	__CIsqrt
	call	__CIatan
	fst	QWORD PTR _ang12$[ebp]

; 3400 :   area = 4*atan(sqrt(fabs(tan((ang1+ang2+ang12)/2)*tan((-ang1+ang2+ang12)/2)*
; 3401 :                      tan((ang1-ang2+ang12)/2)*tan((ang1+ang2-ang12)/2))));

	fld	QWORD PTR _ang2$[ebp]
	fld	ST(0)
	fld	QWORD PTR _ang1$[ebp]
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv1725[ebp]

; 3402 :                      /* need fabs here in case of slightly negative values */
; 3403 :   area *= rad*rad;

	fld	QWORD PTR _rad$[ebp]
	fmul	ST(0), ST(0)
	fstp	QWORD PTR tv1747[ebp]
	fsubp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fe0000000000000
	call	__CItan
	fstp	QWORD PTR tv3589[ebp]
	fld	QWORD PTR tv1725[ebp]
	fadd	QWORD PTR _ang12$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	call	__CItan
	fmul	QWORD PTR tv3589[ebp]
	fstp	QWORD PTR tv3591[ebp]
	fld	QWORD PTR _ang1$[ebp]
	fsub	QWORD PTR _ang2$[ebp]
	fadd	QWORD PTR _ang12$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	call	__CItan
	fmul	QWORD PTR tv3591[ebp]
	fstp	QWORD PTR tv3593[ebp]
	fld	QWORD PTR tv1725[ebp]
	fsub	QWORD PTR _ang12$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	call	__CItan
	fmul	QWORD PTR tv3593[ebp]
	fabs
	call	__CIsqrt
	call	__CIatan
	fmul	QWORD PTR __real@4010000000000000
	fmul	QWORD PTR tv1747[ebp]
	fst	QWORD PTR _area$[ebp]

; 3404 : /*printf("%20.15f %20.15f %20.15f\n",ang1,ang2,ang12);*/
; 3405 :   if ( (normal[2] > 0.0 && pole==SOUTH) || (normal[2] < 0.0 && pole==NORTH) ) 

	fldz
	fld	QWORD PTR _normal$[ebp+16]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN114@spherical_@3
	cmp	DWORD PTR _pole$[ebp], -1
	je	SHORT $LN118@spherical_@3
$LN114@spherical_@3:
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN32@spherical_@3
	cmp	DWORD PTR _pole$[ebp], 1
	jne	SHORT $LN32@spherical_@3
	jmp	SHORT $LN31@spherical_@3
$LN118@spherical_@3:
	fstp	ST(0)
	fstp	ST(0)
$LN31@spherical_@3:

; 3406 :     area = -area;

	fchs
	fst	QWORD PTR _area$[ebp]
$LN32@spherical_@3:

; 3407 :    
; 3408 :      
; 3409 :   if ( mode == METHOD_VALUE ) return area;

	cmp	DWORD PTR _mode$[ebp], 1767		; 000006e7H
	je	$LN33@spherical_@3

; 3410 : 
; 3411 :   /* Gradient follows geometric derivation of strip widths,
; 3412 :      rather than blindly differentiating value expression.
; 3413 :      Get nice expression for gradient on a side from A to B:
; 3414 :              (A x B)*R/(R^2 + A.B)
; 3415 :      which is nonsingular for small edges.
; 3416 :   */
; 3417 : 
; 3418 :   memset(legnorm,0,sizeof(legnorm));

	push	48					; 00000030H
	fstp	ST(0)
	lea	edx, DWORD PTR _legnorm$[ebp]
	push	0
	push	edx
	call	_memset

; 3419 :   legnorm[0][0] =  pole*x[0][1];

	fld	QWORD PTR tv1636[ebp]
	fld	ST(0)

; 3420 :   legnorm[0][1] = -pole*x[0][0];

	mov	eax, DWORD PTR _pole$[ebp]
	fmul	QWORD PTR [esi+8]
	add	esp, 12					; 0000000cH
	neg	eax
	mov	DWORD PTR tv3706[ebp], eax
	fst	QWORD PTR _legnorm$[ebp]

; 3421 :   legnorm[1][0] = -pole*x[1][1];
; 3422 :   legnorm[1][1] =  pole*x[1][0];
; 3423 :   denom[0] = rad*rad + rad*x[0][2];
; 3424 :   denom[1] = rad*rad + rad*x[1][2];
; 3425 :   denom12  = rad*rad + x[0][0]*x[1][0] + x[0][1]*x[1][1] + x[0][2]*x[1][2];
; 3426 :   for ( i = 0 ; i < 2 ; i++ )
; 3427 :     for ( j = 0 ; j < 3 ; j++ )
; 3428 :       e_info->grad[i][j] = 
; 3429 :              pole*rad*(legnorm[i][j]/denom[i] - normal[j]/denom12);

	mov	ecx, DWORD PTR [ebx+1336]
	fild	DWORD PTR tv3706[ebp]
	mov	eax, DWORD PTR [ecx]
	fst	QWORD PTR tv1759[ebp]
	fld	QWORD PTR [esi]
	fmul	ST(0), ST(1)
	fst	QWORD PTR _legnorm$[ebp+8]
	fxch	ST(1)
	fmul	QWORD PTR [edi+8]
	fstp	QWORD PTR _legnorm$[ebp+24]
	fld	ST(2)
	fmul	QWORD PTR [edi]
	fstp	QWORD PTR _legnorm$[ebp+32]
	fld	QWORD PTR [esi+16]
	fld	QWORD PTR _rad$[ebp]
	fmul	ST(1), ST(0)
	fld	QWORD PTR tv1747[ebp]
	fadd	ST(2), ST(0)
	fxch	ST(2)
	fst	QWORD PTR _denom$[ebp]
	fld	QWORD PTR [edi+16]
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(3)
	fst	QWORD PTR _denom$[ebp+8]
	fld	QWORD PTR [esi]
	fmul	QWORD PTR [edi]
	faddp	ST(4), ST(0)
	fld	QWORD PTR [edi+8]
	fmul	QWORD PTR [esi+8]
	faddp	ST(4), ST(0)
	fld	QWORD PTR [edi+16]
	fmul	QWORD PTR [esi+16]
	faddp	ST(4), ST(0)
	fxch	ST(3)
	fst	QWORD PTR _denom12$[ebp]
	fld	QWORD PTR _normal$[ebp]
	fdiv	ST(0), ST(1)
	fxch	ST(7)
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	fst	QWORD PTR tv1799[ebp]
	fxch	ST(5)
	fdiv	ST(0), ST(1)
	fsub	ST(0), ST(6)
	fmul	ST(0), ST(5)
	fstp	QWORD PTR [eax]
	fld	QWORD PTR _normal$[ebp+8]
	fdiv	ST(0), ST(2)
	fxch	ST(4)
	fdiv	ST(0), ST(1)
	fsub	ST(0), ST(4)
	fmul	ST(0), ST(5)
	fstp	QWORD PTR [eax+8]
	fld	QWORD PTR _normal$[ebp+16]
	fdivrp	ST(2), ST(0)
	fdivr	QWORD PTR _legnorm$[ebp+16]
	fsub	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fstp	QWORD PTR [eax+16]
	mov	eax, DWORD PTR [ecx+4]
	fld	QWORD PTR _legnorm$[ebp+24]
	fdiv	ST(0), ST(2)
	fsubrp	ST(5), ST(0)
	fxch	ST(4)
	fmul	ST(0), ST(3)
	fstp	QWORD PTR [eax]
	fld	QWORD PTR _legnorm$[ebp+32]

; 3430 : 
; 3431 :   if ( mode == METHOD_GRADIENT ) return area;

	cmp	DWORD PTR _mode$[ebp], 4321		; 000010e1H
	fdiv	ST(0), ST(1)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [eax+8]
	fdivr	QWORD PTR _legnorm$[ebp+40]
	fsubrp	ST(2), ST(0)
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR [eax+16]
	je	$LN138@spherical_@3

; 3432 : 
; 3433 :   /* gradient of normal */
; 3434 :   memset(dndx,0,sizeof(dndx));

	push	144					; 00000090H
	lea	eax, DWORD PTR _dndx$[ebp]
	push	0
	push	eax
	call	_memset

; 3435 :   /* i = normal component, j = vertex number, k = vertex coord */
; 3436 :   for ( i = 0 ; i < 3 ; i++ )
; 3437 :   { int ii = i >= 2 ? i-2 : i+1;
; 3438 :     int iii = i >= 1 ? i-1 : i+2;
; 3439 : 
; 3440 :     dndx[i][0][ii] = x[1][iii];

	fld	QWORD PTR [edi+16]
	fstp	QWORD PTR _dndx$[ebp+8]

; 3441 :     dndx[i][0][iii] = -x[1][ii];
; 3442 :     dndx[i][1][iii] = x[0][ii];
; 3443 :     dndx[i][1][ii] = -x[0][iii];
; 3444 :   }
; 3445 : 
; 3446 :   memset(ddenom,0,sizeof(ddenom));

	push	96					; 00000060H
	fld	QWORD PTR [edi+8]
	lea	ecx, DWORD PTR _ddenom$[ebp]
	fchs
	push	0
	fstp	QWORD PTR _dndx$[ebp+16]
	push	ecx
	fld	QWORD PTR [esi+8]
	fstp	QWORD PTR _dndx$[ebp+40]
	fld	QWORD PTR [esi+16]
	fchs
	fstp	QWORD PTR _dndx$[ebp+32]
	fld	QWORD PTR [edi]
	fstp	QWORD PTR _dndx$[ebp+64]
	fld	QWORD PTR [edi+16]
	fchs
	fstp	QWORD PTR _dndx$[ebp+48]
	fld	QWORD PTR [esi+16]
	fstp	QWORD PTR _dndx$[ebp+72]
	fld	QWORD PTR [esi]
	fchs
	fstp	QWORD PTR _dndx$[ebp+88]
	fld	QWORD PTR [edi+8]
	fstp	QWORD PTR _dndx$[ebp+96]
	fld	QWORD PTR [edi]
	fchs
	fstp	QWORD PTR _dndx$[ebp+104]
	fld	QWORD PTR [esi]
	fstp	QWORD PTR _dndx$[ebp+128]
	fld	QWORD PTR [esi+8]
	fchs
	fstp	QWORD PTR _dndx$[ebp+120]
	call	_memset

; 3447 :   ddenom[0][0][2] = rad;

	fld	QWORD PTR _rad$[ebp]

; 3448 :   ddenom[1][1][2] = rad;
; 3449 : 
; 3450 :   for ( i = 0 ; i < 2 ; i++ )
; 3451 :     for ( j = 0 ; j < 3 ; j++ )
; 3452 :       ddenom12[i][j] = x[1-i][j];
; 3453 : 
; 3454 :   memset(dlegnorm,0,sizeof(dlegnorm));

	push	288					; 00000120H
	fst	QWORD PTR _ddenom$[ebp+16]
	lea	edx, DWORD PTR _dlegnorm$[ebp]
	fstp	QWORD PTR _ddenom$[ebp+88]
	push	0
	fld	QWORD PTR [edi]
	push	edx
	fstp	QWORD PTR _ddenom12$[ebp]
	fld	QWORD PTR [edi+8]
	fstp	QWORD PTR _ddenom12$[ebp+8]
	fld	QWORD PTR [edi+16]
	fstp	QWORD PTR _ddenom12$[ebp+16]
	fld	QWORD PTR [esi]
	fstp	QWORD PTR _ddenom12$[ebp+24]
	fld	QWORD PTR [esi+8]
	fstp	QWORD PTR _ddenom12$[ebp+32]
	fld	QWORD PTR [esi+16]
	fstp	QWORD PTR _ddenom12$[ebp+40]
	call	_memset

; 3455 :   dlegnorm[0][0][0][1] = -pole;

	fld	QWORD PTR tv1759[ebp]
	lea	eax, DWORD PTR _dlegnorm$[ebp+8]
	fst	QWORD PTR _dlegnorm$[ebp+8]
	lea	edx, DWORD PTR _legnorm$[ebp]

; 3456 :   dlegnorm[0][1][0][0] = pole;

	fld	QWORD PTR tv1636[ebp]
	mov	DWORD PTR tv3725[ebp], eax
	fst	QWORD PTR _dlegnorm$[ebp+48]
	mov	eax, DWORD PTR [ebx+1340]

; 3457 :   dlegnorm[1][0][1][1] = pole;

	fstp	QWORD PTR _dlegnorm$[ebp+176]
	mov	DWORD PTR tv3727[ebp], edx
	add	esp, 36					; 00000024H

; 3458 :   dlegnorm[1][1][1][0] = -pole;

	fstp	QWORD PTR _dlegnorm$[ebp+216]
	lea	ecx, DWORD PTR _ddenom$[ebp+8]
	fld	QWORD PTR __real@bff0000000000000
	mov	DWORD PTR tv3729[ebp], eax
	fld	QWORD PTR _denom12$[ebp]
	lea	edx, DWORD PTR _denom$[ebp]
	fdiv	ST(1), ST(0)
	mov	DWORD PTR tv245[ebp], 2
	fxch	ST(1)
	fst	QWORD PTR tv2006[ebp]

; 3432 : 
; 3433 :   /* gradient of normal */
; 3434 :   memset(dndx,0,sizeof(dndx));

	fld	QWORD PTR tv1799[ebp]
	jmp	SHORT $LN12@spherical_@3
$LN111@spherical_@3:
	fld	QWORD PTR tv2006[ebp]
	fxch	ST(1)
$LN12@spherical_@3:
	fld	QWORD PTR __real@bff0000000000000

; 3463 :    for ( ii = 0 ; ii < 2 ; ii++ )

	lea	eax, DWORD PTR _dndx$[ebp+8]
	fdiv	QWORD PTR [edx]
	mov	DWORD PTR tv3386[ebp], eax
	mov	eax, DWORD PTR tv3729[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv3388[ebp], eax
	mov	eax, DWORD PTR tv3725[ebp]
	mov	DWORD PTR tv3464[ebp], eax
	lea	eax, DWORD PTR _ddenom12$[ebp+8]
	mov	DWORD PTR tv3470[ebp], eax
	mov	DWORD PTR tv3528[ebp], ecx
	mov	DWORD PTR tv288[ebp], 2
	fst	QWORD PTR tv3736[ebp]
	jmp	SHORT $LN9@spherical_@3
$LN112@spherical_@3:
	fld	QWORD PTR tv3736[ebp]
	mov	eax, DWORD PTR tv3470[ebp]
	fld	QWORD PTR tv2006[ebp]
	fxch	ST(2)
	fxch	ST(1)
$LN9@spherical_@3:

; 3464 :     for ( j = 0 ; j < 3 ; j++ )

	fld	QWORD PTR [ecx-8]
	mov	ebx, DWORD PTR tv3727[ebp]
	fmul	ST(0), ST(1)
	xor	edi, edi
	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(4)
	fstp	QWORD PTR tv3606[ebp]
	fld	ST(1)
	fmul	QWORD PTR [ecx]
	fstp	QWORD PTR tv3542[ebp]
	fld	ST(3)
	fmul	QWORD PTR [eax]
	fstp	QWORD PTR tv3505[ebp]
	fld	QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR tv3388[ebp]
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv3608[ebp]
	fld	QWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv3386[ebp]
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	mov	DWORD PTR tv2762[ebp], eax
	mov	eax, DWORD PTR tv3464[ebp]
	fstp	QWORD PTR tv3612[ebp]
$LN113@spherical_@3:

; 3465 :      for ( jj = 0 ; jj < 3; jj++ )
; 3466 :      { e_info->hess[i][ii][j][jj] =
; 3467 :              pole*rad*(
; 3468 :     dlegnorm[i][j][ii][jj]/denom[i] - dndx[j][ii][jj]/denom12
; 3469 :     + legnorm[i][j]/denom[i]*(-1/denom[i]*ddenom[i][ii][jj]) 
; 3470 :        - normal[j]/denom12*(-1/denom12*ddenom12[ii][jj])
; 3471 :          );

	fld	QWORD PTR [ebx]
	mov	esi, DWORD PTR tv2762[ebp]
	fdiv	QWORD PTR [edx]
	mov	esi, DWORD PTR [esi]
	add	DWORD PTR tv2762[ebp], 4
	inc	edi
	add	eax, 48					; 00000030H
	add	ecx, 48					; 00000030H
	add	ebx, 8
	fld	QWORD PTR _normal$[ebp+edi*8-8]
	fdiv	ST(0), ST(4)
	fld	QWORD PTR [eax-56]
	fdiv	QWORD PTR [edx]
	fld	QWORD PTR [ecx-56]
	fdiv	ST(0), ST(6)
	fsubp	ST(1), ST(0)
	fld	ST(2)
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	QWORD PTR tv3606[ebp]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(3)
	fstp	QWORD PTR [esi]
	fld	QWORD PTR [eax-48]
	fdiv	QWORD PTR [edx]
	fld	QWORD PTR [ecx-48]
	fdiv	ST(0), ST(6)
	fsubp	ST(1), ST(0)
	fld	ST(2)
	fmul	QWORD PTR tv3542[ebp]
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	QWORD PTR tv3505[ebp]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(3)
	fstp	QWORD PTR [esi+8]
	fld	QWORD PTR [eax-40]
	fdiv	QWORD PTR [edx]
	fld	QWORD PTR [ecx-40]
	fdiv	ST(0), ST(6)
	fsubp	ST(1), ST(0)
	fxch	ST(2)
	fmul	QWORD PTR tv3608[ebp]
	faddp	ST(2), ST(0)
	fmul	QWORD PTR tv3612[ebp]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi+16]
	cmp	edi, 3
	jl	$LN113@spherical_@3

; 3464 :     for ( j = 0 ; j < 3 ; j++ )

	add	DWORD PTR tv3388[ebp], 4
	fstp	ST(1)
	mov	eax, 24					; 00000018H
	add	DWORD PTR tv3528[ebp], eax
	add	DWORD PTR tv3470[ebp], eax
	add	DWORD PTR tv3386[ebp], eax
	add	DWORD PTR tv3464[ebp], eax
	dec	DWORD PTR tv288[ebp]
	mov	ecx, DWORD PTR tv3528[ebp]
	jne	$LN112@spherical_@3

; 3459 : 
; 3460 : 
; 3461 :     /* Hessian */
; 3462 :   for ( i = 0 ; i < 2 ; i++ )

	add	DWORD PTR tv3729[ebp], 4
	add	DWORD PTR tv3727[ebp], eax
	add	DWORD PTR tv3725[ebp], 144		; 00000090H
	add	edx, 8
	dec	DWORD PTR tv245[ebp]
	jne	$LN111@spherical_@3
	fstp	ST(1)
	fstp	ST(0)
$LN138@spherical_@3:

; 3472 :      }
; 3473 : 
; 3474 :   return area;

	fld	QWORD PTR _area$[ebp]
$LN33@spherical_@3:

; 3475 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_spherical_arc_area_all ENDP
_TEXT	ENDS
PUBLIC	_spherical_arc_area_n_value
; Function compile flags: /Ogtp
;	COMDAT _spherical_arc_area_n_value
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_spherical_arc_area_n_value PROC			; COMDAT

; 3480 : { if ( web.modeltype != LINEAR )

	push	ebp
	mov	ebp, esp
	cmp	DWORD PTR _web+628, 1
	je	SHORT $LN1@spherical_@4

; 3481 :        return 0;

	fldz

; 3483 : }

	pop	ebp
	ret	0
$LN1@spherical_@4:

; 3482 :   return spherical_arc_area_all(e_info,METHOD_VALUE,NORTH);

	mov	eax, DWORD PTR _e_info$[ebp]
	push	1
	push	1767					; 000006e7H
	push	eax
	call	_spherical_arc_area_all
	add	esp, 12					; 0000000cH

; 3483 : }

	pop	ebp
	ret	0
_spherical_arc_area_n_value ENDP
_TEXT	ENDS
PUBLIC	_spherical_arc_area_n_grad
; Function compile flags: /Ogtp
;	COMDAT _spherical_arc_area_n_grad
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_spherical_arc_area_n_grad PROC				; COMDAT

; 3487 : { if ( web.modeltype != LINEAR )

	push	ebp
	mov	ebp, esp
	cmp	DWORD PTR _web+628, 1
	je	SHORT $LN1@spherical_@5

; 3488 :        return 0;

	fldz

; 3490 : }

	pop	ebp
	ret	0
$LN1@spherical_@5:

; 3489 :   return spherical_arc_area_all(e_info,METHOD_GRADIENT,NORTH);

	mov	eax, DWORD PTR _e_info$[ebp]
	push	1
	push	4321					; 000010e1H
	push	eax
	call	_spherical_arc_area_all
	add	esp, 12					; 0000000cH

; 3490 : }

	pop	ebp
	ret	0
_spherical_arc_area_n_grad ENDP
_TEXT	ENDS
PUBLIC	_spherical_arc_area_n_hess
; Function compile flags: /Ogtp
;	COMDAT _spherical_arc_area_n_hess
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_spherical_arc_area_n_hess PROC				; COMDAT

; 3494 : { if ( web.modeltype != LINEAR )

	push	ebp
	mov	ebp, esp
	cmp	DWORD PTR _web+628, 1
	je	SHORT $LN1@spherical_@6

; 3495 :        return 0;

	fldz

; 3497 : }

	pop	ebp
	ret	0
$LN1@spherical_@6:

; 3496 :   return spherical_arc_area_all(e_info,METHOD_HESSIAN,NORTH);

	mov	eax, DWORD PTR _e_info$[ebp]
	push	1
	push	8763					; 0000223bH
	push	eax
	call	_spherical_arc_area_all
	add	esp, 12					; 0000000cH

; 3497 : }

	pop	ebp
	ret	0
_spherical_arc_area_n_hess ENDP
_TEXT	ENDS
PUBLIC	_spherical_arc_area_s_value
; Function compile flags: /Ogtp
;	COMDAT _spherical_arc_area_s_value
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_spherical_arc_area_s_value PROC			; COMDAT

; 3502 : { if ( web.modeltype != LINEAR )

	push	ebp
	mov	ebp, esp
	cmp	DWORD PTR _web+628, 1
	je	SHORT $LN1@spherical_@7

; 3503 :        return 0;

	fldz

; 3505 : }

	pop	ebp
	ret	0
$LN1@spherical_@7:

; 3504 :   return spherical_arc_area_all(e_info,METHOD_VALUE,SOUTH);

	mov	eax, DWORD PTR _e_info$[ebp]
	push	-1
	push	1767					; 000006e7H
	push	eax
	call	_spherical_arc_area_all
	add	esp, 12					; 0000000cH

; 3505 : }

	pop	ebp
	ret	0
_spherical_arc_area_s_value ENDP
_TEXT	ENDS
PUBLIC	_spherical_arc_area_s_grad
; Function compile flags: /Ogtp
;	COMDAT _spherical_arc_area_s_grad
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_spherical_arc_area_s_grad PROC				; COMDAT

; 3509 : { if ( web.modeltype != LINEAR )

	push	ebp
	mov	ebp, esp
	cmp	DWORD PTR _web+628, 1
	je	SHORT $LN1@spherical_@8

; 3510 :        return 0;

	fldz

; 3512 : }

	pop	ebp
	ret	0
$LN1@spherical_@8:

; 3511 :   return spherical_arc_area_all(e_info,METHOD_GRADIENT,SOUTH);

	mov	eax, DWORD PTR _e_info$[ebp]
	push	-1
	push	4321					; 000010e1H
	push	eax
	call	_spherical_arc_area_all
	add	esp, 12					; 0000000cH

; 3512 : }

	pop	ebp
	ret	0
_spherical_arc_area_s_grad ENDP
_TEXT	ENDS
PUBLIC	_spherical_arc_area_s_hess
; Function compile flags: /Ogtp
;	COMDAT _spherical_arc_area_s_hess
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_spherical_arc_area_s_hess PROC				; COMDAT

; 3516 : { if ( web.modeltype != LINEAR )

	push	ebp
	mov	ebp, esp
	cmp	DWORD PTR _web+628, 1
	je	SHORT $LN1@spherical_@9

; 3517 :        return 0;

	fldz

; 3519 : }

	pop	ebp
	ret	0
$LN1@spherical_@9:

; 3518 :   return spherical_arc_area_all(e_info,METHOD_HESSIAN,SOUTH);

	mov	eax, DWORD PTR _e_info$[ebp]
	push	-1
	push	8763					; 0000223bH
	push	eax
	call	_spherical_arc_area_all
	add	esp, 12					; 0000000cH

; 3519 : }

	pop	ebp
	ret	0
_spherical_arc_area_s_hess ENDP
_TEXT	ENDS
PUBLIC	_q_edge_tension_value
EXTRN	_lagrange_edge_tension_value:PROC
; Function compile flags: /Ogtp
;	COMDAT _q_edge_tension_value
_TEXT	SEGMENT
_energy$ = -8						; size = 8
_e_info$ = 8						; size = 4
_q_edge_tension_value PROC				; COMDAT

; 169  : { REAL energy;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi

; 170  :   struct method_instance *mi = METH_INSTANCE(e_info->method); 

	mov	edi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [edi+8]
	cdq
	mov	esi, eax

; 171  : 
; 172  :   if ( web.modeltype == QUADRATIC ) return edge_length_q_value(e_info);

	mov	eax, DWORD PTR _web+628
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list
	cmp	eax, 2
	jne	SHORT $LN6@q_edge_ten
	push	edi
	call	_edge_length_q_value
	add	esp, 4
	pop	edi
	pop	esi

; 190  :     
; 191  :   return energy; 
; 192  : } // end q_edge_tension_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@q_edge_ten:

; 173  :   if ( web.modeltype == LAGRANGE ) 

	cmp	eax, 3
	jne	SHORT $LN5@q_edge_ten

; 174  :       return lagrange_edge_tension_value(e_info);

	push	edi
	call	_lagrange_edge_tension_value
	add	esp, 4
	pop	edi
	pop	esi

; 190  :     
; 191  :   return energy; 
; 192  : } // end q_edge_tension_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@q_edge_ten:

; 175  :   energy = sqrt(SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]));

	mov	eax, DWORD PTR [edi+1276]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [ecx]
	push	edx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fst	QWORD PTR _energy$[ebp]

; 176  : 
; 177  :   if ( mi->flags & DEFAULT_INSTANCE )

	test	DWORD PTR [esi+140], 4194304		; 00400000H
	je	SHORT $LN4@q_edge_ten

; 178  :   { 
; 179  : #ifdef SHARED_MEMORY
; 180  :      if ( nprocs > 1 ) 

	cmp	DWORD PTR _nprocs, 1
	jle	SHORT $LN3@q_edge_ten

; 181  :       proc_total_area[GET_THREAD_ID] += energy;

	mov	eax, DWORD PTR _thread_data_key
	fstp	ST(0)
	push	eax
	call	_win_get_thread_data
	mov	eax, DWORD PTR [eax]
	fld	QWORD PTR _proc_total_area[eax*8]
	add	esp, 4
	fld	QWORD PTR _energy$[ebp]
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _proc_total_area[eax*8]

; 182  :      else

	jmp	SHORT $LN2@q_edge_ten
$LN3@q_edge_ten:

; 183  : #endif
; 184  :      binary_tree_add(web.total_area_addends,energy);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1000
	call	_binary_tree_add
	fld	QWORD PTR _energy$[ebp]
	add	esp, 12					; 0000000cH
$LN2@q_edge_ten:

; 185  :      set_edge_length(e_info->id,energy);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	fst	QWORD PTR [eax+48]
$LN4@q_edge_ten:

; 186  :   }
; 187  :   
; 188  :   if ( mi->flags & USE_DENSITY )

	test	DWORD PTR [esi+140], 536870912		; 20000000H
	je	SHORT $LN7@q_edge_ten

; 189  :     energy *= get_edge_density(e_info->id);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	fmul	QWORD PTR [eax+40]
$LN7@q_edge_ten:
	pop	edi
	pop	esi

; 190  :     
; 191  :   return energy; 
; 192  : } // end q_edge_tension_value()

	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_tension_value ENDP
_TEXT	ENDS
PUBLIC	_q_edge_tension_gradient
EXTRN	_lagrange_edge_tension_grad:PROC
; Function compile flags: /Ogtp
;	COMDAT _q_edge_tension_gradient
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_q_edge_tension_gradient PROC				; COMDAT

; 203  : { REAL energy;

	push	ebp
	mov	ebp, esp
	push	esi

; 204  :   REAL fudge;
; 205  :   int j;
; 206  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	esi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [esi+8]
	push	edi
	cdq
	mov	edi, eax

; 207  : 
; 208  :   if ( web.modeltype == QUADRATIC ) 

	mov	eax, DWORD PTR _web+628
	xor	edi, edx
	sub	edi, edx
	imul	edi, 2928				; 00000b70H
	add	edi, DWORD PTR _meth_inst_list
	cmp	eax, 2
	jne	SHORT $LN6@q_edge_ten@2

; 209  :      return edge_length_q_grad(e_info);

	push	esi
	call	_edge_length_q_grad
	add	esp, 4
	pop	edi
	pop	esi

; 221  :      }
; 222  :   return energy;
; 223  : } // end q_edge_tension_gradient()

	pop	ebp
	ret	0
$LN6@q_edge_ten@2:

; 210  :   if ( web.modeltype == LAGRANGE ) 

	cmp	eax, 3
	jne	SHORT $LN5@q_edge_ten@2

; 211  :       return lagrange_edge_tension_grad(e_info);

	push	esi
	call	_lagrange_edge_tension_grad
	add	esp, 4
	pop	edi
	pop	esi

; 221  :      }
; 222  :   return energy;
; 223  : } // end q_edge_tension_gradient()

	pop	ebp
	ret	0
$LN5@q_edge_ten@2:

; 212  :   energy = sqrt(SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]));

	mov	eax, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [ecx]
	push	edx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 213  :   fudge = 1/energy;

	fld1

; 214  :   if ( mi->flags & USE_DENSITY )

	test	DWORD PTR [edi+140], 536870912		; 20000000H
	fdiv	ST(0), ST(1)
	je	SHORT $LN4@q_edge_ten@2

; 215  :   {  REAL density = get_edge_density(e_info->id);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]

; 216  :      energy *= density; fudge *= density;

	fld	ST(0)
	fmulp	ST(3), ST(0)
	fmulp	ST(1), ST(0)
$LN4@q_edge_ten@2:

; 217  :   }
; 218  :   for ( j = 0 ; j < SDIM ; j++ ) 

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN16@q_edge_ten@2
$LN3@q_edge_ten@2:

; 219  :      { e_info->grad[0][j] = -e_info->sides[0][0][j]*fudge;

	mov	ecx, DWORD PTR [esi+1276]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	fld	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR [esi+1336]
	mov	ecx, DWORD PTR [edx]
	fmul	ST(0), ST(1)
	inc	eax
	fchs
	fstp	QWORD PTR [ecx+eax*8-8]

; 220  :        e_info->grad[1][j] =  e_info->sides[0][0][j]*fudge;

	mov	edx, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx]
	fld	QWORD PTR [edx+eax*8-8]
	mov	ecx, DWORD PTR [esi+1336]
	mov	edx, DWORD PTR [ecx+4]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@q_edge_ten@2
$LN16@q_edge_ten@2:
	pop	edi

; 217  :   }
; 218  :   for ( j = 0 ; j < SDIM ; j++ ) 

	fstp	ST(0)
	pop	esi

; 221  :      }
; 222  :   return energy;
; 223  : } // end q_edge_tension_gradient()

	pop	ebp
	ret	0
_q_edge_tension_gradient ENDP
_TEXT	ENDS
PUBLIC	_q_edge_tension_hessian
EXTRN	_lagrange_edge_tension_hess:PROC
; Function compile flags: /Ogtp
;	COMDAT _q_edge_tension_hessian
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_q_edge_tension_hessian PROC				; COMDAT

; 236  : { REAL energy;

	push	ebp
	mov	ebp, esp
	push	esi

; 237  :   int i,j;
; 238  :   REAL e1,e3,ss;
; 239  :   REAL fudge,len;
; 240  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	esi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [esi+8]
	push	edi
	cdq
	mov	edi, eax

; 241  : 
; 242  :   if ( web.modeltype == QUADRATIC ) return edge_length_q_hess(e_info);

	mov	eax, DWORD PTR _web+628
	xor	edi, edx
	sub	edi, edx
	imul	edi, 2928				; 00000b70H
	add	edi, DWORD PTR _meth_inst_list
	cmp	eax, 2
	jne	SHORT $LN15@q_edge_ten@3
	push	esi
	call	_edge_length_q_hess
	add	esp, 4
	pop	edi
	pop	esi

; 270  :     }
; 271  :   return energy;
; 272  : } // end q_edge_tension_hessian()

	pop	ebp
	ret	0
$LN15@q_edge_ten@3:

; 243  :   if ( web.modeltype == LAGRANGE )  return lagrange_edge_tension_hess(e_info);

	cmp	eax, 3
	jne	SHORT $LN14@q_edge_ten@3
	push	esi
	call	_lagrange_edge_tension_hess
	add	esp, 4
	pop	edi
	pop	esi

; 270  :     }
; 271  :   return energy;
; 272  : } // end q_edge_tension_hessian()

	pop	ebp
	ret	0
$LN14@q_edge_ten@3:

; 244  : 
; 245  :   energy = len = sqrt(SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]));

	mov	eax, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [ecx]
	push	edx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fld	ST(0)

; 246  :   fudge = 1/len;
; 247  :   if ( mi->flags & USE_DENSITY )

	test	DWORD PTR [edi+140], 536870912		; 20000000H
	fld1
	fdiv	ST(0), ST(2)
	je	SHORT $LN13@q_edge_ten@3

; 248  :   {  REAL density = get_edge_density(e_info->id);

	mov	eax, DWORD PTR [esi]

; 249  :      energy *= density; fudge *= density;

	fstp	ST(1)
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]
	fld	ST(0)
	fmul	ST(0), ST(3)
	fxch	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
$LN13@q_edge_ten@3:

; 250  :   }
; 251  :   for ( j = 0 ; j < SDIM ; j++ ) 

	mov	edx, DWORD PTR _web+616
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN10@q_edge_ten@3
$LN12@q_edge_ten@3:

; 252  :      { e_info->grad[0][j] = -e_info->sides[0][0][j]*fudge;

	mov	ecx, DWORD PTR [esi+1276]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	fld	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR [esi+1336]
	mov	ecx, DWORD PTR [edx]
	fmul	ST(0), ST(1)
	inc	eax
	fchs
	fstp	QWORD PTR [ecx+eax*8-8]

; 253  :        e_info->grad[1][j] =  e_info->sides[0][0][j]*fudge;

	mov	edx, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx]
	fld	QWORD PTR [edx+eax*8-8]
	mov	ecx, DWORD PTR [esi+1336]
	mov	edx, DWORD PTR [ecx+4]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx+eax*8-8]
	mov	edx, DWORD PTR _web+616
	cmp	eax, edx
	jl	SHORT $LN12@q_edge_ten@3
$LN10@q_edge_ten@3:

; 254  :      }
; 255  :   e3 = fudge/(len*len);

	fld	ST(2)

; 256  :   e1 = fudge;
; 257  :   for ( i = 0 ; i < SDIM ; i++ ) 

	xor	ecx, ecx
	fmulp	ST(3), ST(0)
	fld	ST(0)
	fdivrp	ST(3), ST(0)
	test	edx, edx
	jle	SHORT $LN36@q_edge_ten@3
$LN9@q_edge_ten@3:

; 258  :     for ( j = 0 ; j < SDIM ; j++ ) 

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN8@q_edge_ten@3
$LN6@q_edge_ten@3:

; 259  :     { ss = e_info->sides[0][0][i]*e_info->sides[0][0][j]*e3;

	mov	edx, DWORD PTR [esi+1276]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+ecx*8]
	inc	eax
	fmul	QWORD PTR [edx+eax*8-8]

; 260  :       e_info->hess[0][0][i][j] = -ss;

	mov	edx, DWORD PTR [esi+1340]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+ecx*4]
	fmul	ST(0), ST(3)
	fld	ST(0)
	fchs
	fst	QWORD PTR [edx+eax*8-8]

; 261  :       e_info->hess[1][1][i][j] = -ss;

	mov	edx, DWORD PTR [esi+1340]
	mov	edx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [edx+ecx*4]
	fstp	QWORD PTR [edx+eax*8-8]

; 262  :       e_info->hess[0][1][i][j] =  ss;

	mov	edx, DWORD PTR [esi+1340]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [edx+ecx*4]
	fst	QWORD PTR [edx+eax*8-8]

; 263  :       e_info->hess[1][0][i][j] =  ss;

	mov	edx, DWORD PTR [esi+1340]
	mov	edx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+ecx*4]
	fstp	QWORD PTR [edx+eax*8-8]
	mov	edx, DWORD PTR _web+616
	cmp	eax, edx
	jl	SHORT $LN6@q_edge_ten@3
$LN8@q_edge_ten@3:

; 256  :   e1 = fudge;
; 257  :   for ( i = 0 ; i < SDIM ; i++ ) 

	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LN9@q_edge_ten@3
$LN36@q_edge_ten@3:

; 264  :     }
; 265  :   for ( i = 0 ; i < SDIM ; i++ ) 

	xor	eax, eax
	fstp	ST(2)
	test	edx, edx
	jle	SHORT $LN39@q_edge_ten@3
$LN3@q_edge_ten@3:

; 266  :     { e_info->hess[0][0][i][i] += e1;

	mov	ecx, DWORD PTR [esi+1340]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+eax*8]
	lea	ecx, DWORD PTR [edx+eax*8]
	fadd	ST(0), ST(2)
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+1340]
	mov	edx, DWORD PTR [ecx+4]

; 267  :       e_info->hess[1][1][i][i] += e1;

	fld	ST(1)
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	fadd	QWORD PTR [edx+eax*8]
	lea	ecx, DWORD PTR [edx+eax*8]
	fstp	QWORD PTR [ecx]

; 268  :       e_info->hess[0][1][i][i] -= e1; 

	mov	ecx, DWORD PTR [esi+1340]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+eax*8]
	lea	ecx, DWORD PTR [edx+eax*8]
	fsub	ST(0), ST(2)
	fstp	QWORD PTR [ecx]

; 269  :       e_info->hess[1][0][i][i] -= e1;

	mov	ecx, DWORD PTR [esi+1340]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+eax*8]
	lea	ecx, DWORD PTR [edx+eax*8]
	fsub	ST(0), ST(2)
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@q_edge_ten@3
$LN39@q_edge_ten@3:
	pop	edi

; 264  :     }
; 265  :   for ( i = 0 ; i < SDIM ; i++ ) 

	fstp	ST(1)
	pop	esi

; 270  :     }
; 271  :   return energy;
; 272  : } // end q_edge_tension_hessian()

	pop	ebp
	ret	0
_q_edge_tension_hessian ENDP
_TEXT	ENDS
PUBLIC	_edge_scalar_integral
; Function compile flags: /Ogtp
;	COMDAT _edge_scalar_integral
_TEXT	SEGMENT
_value$ = -8						; size = 8
_m$ = 8							; size = 4
_e_info$ = 8						; size = 4
_edge_scalar_integral PROC				; COMDAT

; 424  : { int m;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 425  :   REAL value = 0.0;

	fldz
	push	ebx
	push	edi
	fstp	QWORD PTR _value$[ebp]

; 426  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	edi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [edi+8]
	cdq
	mov	ebx, eax

; 427  : 
; 428  :   if ( web.modeltype == QUADRATIC ) return edge_scalar_integral_q(e_info);

	mov	eax, DWORD PTR _web+628
	xor	ebx, edx
	sub	ebx, edx
	imul	ebx, 2928				; 00000b70H
	add	ebx, DWORD PTR _meth_inst_list
	cmp	eax, 2
	jne	SHORT $LN5@edge_scala@7
	push	edi
	call	_edge_scalar_integral_q
	add	esp, 4
	pop	edi
	pop	ebx

; 437  :   return value;
; 438  : } // end edge_scalar_integral()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@edge_scala@7:

; 429  :   if ( web.modeltype == LAGRANGE ) return edge_scalar_integral_lagr(e_info);

	cmp	eax, 3
	jne	SHORT $LN4@edge_scala@7
	push	edi
	call	_edge_scalar_integral_lagr
	add	esp, 4
	pop	edi
	pop	ebx

; 437  :   return value;
; 438  : } // end edge_scalar_integral()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@edge_scala@7:
	push	esi

; 430  : 
; 431  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	esi, esi
	mov	DWORD PTR _m$[ebp], esi
	cmp	DWORD PTR _gauss1D_num, esi
	jle	SHORT $LN1@edge_scala@7
$LL10@edge_scala@7:

; 432  :   { e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	mov	eax, DWORD PTR [edi+1268]
	fild	DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [eax+esi*4]
	add	ecx, ecx
	fstp	QWORD PTR [edx+ecx*8]

; 433  :     value += gauss1Dwt[m]*eval(mi->expr[0],
; 434  :               e_info->gauss_pt[m], e_info->id,NULL);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+1268]
	mov	edx, DWORD PTR [ecx+esi*4]
	push	0
	push	eax
	mov	eax, DWORD PTR [ebx+232]
	push	edx
	push	eax
	call	_eval
	mov	ecx, DWORD PTR _gauss1Dwt
	fmul	QWORD PTR [ecx+esi*8]
	inc	esi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _m$[ebp], esi
	fadd	QWORD PTR _value$[ebp]
	fstp	QWORD PTR _value$[ebp]
	cmp	esi, DWORD PTR _gauss1D_num
	jl	SHORT $LL10@edge_scala@7
$LN1@edge_scala@7:

; 435  :   }
; 436  :   value *= sqrt(SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]));

	mov	edx, DWORD PTR [edi+1276]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [eax]
	push	ecx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fmul	QWORD PTR _value$[ebp]
	pop	esi
	pop	edi
	pop	ebx

; 437  :   return value;
; 438  : } // end edge_scalar_integral()

	mov	esp, ebp
	pop	ebp
	ret	0
_edge_scalar_integral ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_edge_scalar_integral_grad
; Function compile flags: /Ogtp
;	COMDAT _edge_scalar_integral_grad
_TEXT	SEGMENT
_val$ = -88						; size = 8
_len$ = -80						; size = 8
tv401 = -72						; size = 4
_mi$ = -68						; size = 4
_value$ = -64						; size = 8
tv379 = -56						; size = 4
_m$ = -56						; size = 4
_derivs$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_scalar_integral_grad PROC				; COMDAT

; 449  : { int m,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 450  :   REAL value = 0.0;

	fldz
	push	esi
	fst	QWORD PTR _value$[ebp]
	mov	esi, DWORD PTR _e_info$[ebp]

; 451  :   REAL len,val;
; 452  :   REAL derivs[MAXCOORD];
; 453  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	eax, DWORD PTR [esi+8]
	cdq
	mov	ebx, eax

; 454  : 
; 455  :   if ( web.modeltype == QUADRATIC ) return edge_scalar_integral_q_grad(e_info);

	mov	eax, DWORD PTR _web+628
	xor	ebx, edx
	sub	ebx, edx
	imul	ebx, 2928				; 00000b70H
	add	ebx, DWORD PTR _meth_inst_list
	mov	DWORD PTR _mi$[ebp], ebx
	cmp	eax, 2
	jne	SHORT $LN17@edge_scala@8
	push	esi
	fstp	ST(0)
	call	_edge_scalar_integral_q_grad
	add	esp, 4
	pop	esi
	pop	ebx

; 474  :   }
; 475  : 
; 476  :   return len*value;
; 477  : } // end edge_scalar_integral_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@edge_scala@8:

; 456  :   if ( web.modeltype == LAGRANGE ) return edge_scalar_integral_lagr_grad(e_info);

	cmp	eax, 3
	jne	SHORT $LN16@edge_scala@8
	push	esi
	fstp	ST(0)
	call	_edge_scalar_integral_lagr_grad
	add	esp, 4
	pop	esi
	pop	ebx

; 474  :   }
; 475  : 
; 476  :   return len*value;
; 477  : } // end edge_scalar_integral_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@edge_scala@8:

; 457  : 
; 458  :   for ( j = 0 ; j < SDIM ; j++ ) 

	mov	ecx, DWORD PTR _web+616
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN44@edge_scala@8
$LN15@edge_scala@8:

; 459  :      for ( m = 0 ; m < 2 ; m++ )
; 460  :         e_info->grad[m][j] = 0.0;

	mov	ecx, DWORD PTR [esi+1336]
	mov	edx, DWORD PTR [ecx]
	fst	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR [esi+1336]
	mov	edx, DWORD PTR [ecx+4]
	fst	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _web+616
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LN15@edge_scala@8
$LN44@edge_scala@8:

; 461  :   len = sqrt(SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]));

	mov	eax, DWORD PTR [esi+1276]
	fstp	ST(0)
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx]
	push	edi
	push	ecx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fst	QWORD PTR _len$[ebp]

; 462  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	ecx, DWORD PTR _web+616
	xor	edi, edi
	mov	DWORD PTR _m$[ebp], edi
	cmp	DWORD PTR _gauss1D_num, edi
	jg	SHORT $LN62@edge_scala@8
	fld	QWORD PTR _value$[ebp]
	jmp	$LN7@edge_scala@8
$LL59@edge_scala@8:
	fstp	ST(0)
$LN62@edge_scala@8:

; 463  :   { e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	mov	eax, DWORD PTR [esi+1268]
	fstp	ST(0)
	mov	edx, DWORD PTR [eax+edi*4]
	fild	DWORD PTR _m$[ebp]
	add	ecx, ecx
	fstp	QWORD PTR [edx+ecx*8]

; 464  :     eval_all(mi->expr[0],e_info->gauss_pt[m],SDIM,&val,derivs,e_info->id);

	mov	eax, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR _web+616
	lea	ecx, DWORD PTR _derivs$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [esi+1268]
	lea	edx, DWORD PTR _val$[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+edi*4]
	push	eax
	mov	eax, DWORD PTR [ebx+232]
	push	edx
	push	eax
	call	_eval_all

; 465  :     value += gauss1Dwt[m]*val;

	fld	QWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _gauss1Dwt
	fmul	QWORD PTR [ecx+edi*8]
	lea	edx, DWORD PTR [ecx+edi*8]

; 466  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 24					; 00000018H
	fadd	QWORD PTR _value$[ebp]
	xor	eax, eax
	fst	QWORD PTR _value$[ebp]
	fld	QWORD PTR _len$[ebp]
	test	ecx, ecx
	jle	SHORT $LN8@edge_scala@8

; 462  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	ecx, DWORD PTR _gauss1poly
	mov	ebx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ebx, DWORD PTR [ebx+edi*8]
	lea	ecx, DWORD PTR [ecx+edi*8]
	mov	DWORD PTR tv379[ebp], ebx
	mov	DWORD PTR tv401[ebp], ecx
$LN35@edge_scala@8:

; 467  :     { e_info->grad[0][j] += gauss1Dwt[m]*gauss1poly[0][m]*derivs[j]*len;

	mov	ebx, DWORD PTR tv379[ebp]
	fld	QWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+1336]
	fmul	QWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]

; 468  :       e_info->grad[1][j] += gauss1Dwt[m]*gauss1poly[1][m]*derivs[j]*len;

	mov	ebx, DWORD PTR tv401[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fmul	QWORD PTR _derivs$[ebp+eax*8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+1336]
	fld	QWORD PTR [ebx]
	mov	ecx, DWORD PTR [ecx+4]
	fmul	QWORD PTR [edx]
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	eax
	fmul	QWORD PTR _derivs$[ebp+eax*8-8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN35@edge_scala@8

; 466  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _mi$[ebp]
$LN8@edge_scala@8:

; 462  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	edi
	mov	DWORD PTR _m$[ebp], edi
	cmp	edi, DWORD PTR _gauss1D_num
	jl	$LL59@edge_scala@8
	fxch	ST(1)
$LN7@edge_scala@8:

; 469  :     }
; 470  :   }
; 471  :   for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	pop	edi
	test	ecx, ecx
	jle	SHORT $LN1@edge_scala@8
$LN3@edge_scala@8:

; 472  :   { e_info->grad[0][j] -= value*e_info->sides[0][0][j]/len;

	mov	edx, DWORD PTR [esi+1336]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [esi+1276]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+eax*8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(2)
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+1336]
	mov	edx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [edx+eax*8]

; 473  :     e_info->grad[1][j] += value*e_info->sides[0][0][j]/len;

	mov	edx, DWORD PTR [esi+1276]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(2)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@edge_scala@8
$LN1@edge_scala@8:

; 474  :   }
; 475  : 
; 476  :   return len*value;
; 477  : } // end edge_scalar_integral_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fmulp	ST(1), ST(0)
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_scalar_integral_grad ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_edge_scalar_integral_hess
; Function compile flags: /Ogtp
;	COMDAT _edge_scalar_integral_hess
_TEXT	SEGMENT
_secondqXvS$ = -2900					; size = 24
_len$ = -2876						; size = 8
tv4573 = -2868						; size = 4
_mi$ = -2868						; size = 4
_sum$ = -2864						; size = 8
tv4669 = -2860						; size = 4
tv4593 = -2860						; size = 4
_val$ = -2856						; size = 8
tv5492 = -2848						; size = 4
tv4585 = -2848						; size = 4
_second$ = -2848					; size = 4
tv5573 = -2844						; size = 4
tv4581 = -2844						; size = 4
_j$ = -2844						; size = 4
_m$ = -2844						; size = 4
tv4694 = -2840						; size = 4
tv4589 = -2840						; size = 4
tv4250 = -2840						; size = 4
tv2936 = -2840						; size = 4
_secondxJ$ = -2836					; size = 288
_sumhess$ = -2548					; size = 1152
_lenhess$ = -1396					; size = 1152
_lengrad$ = -244					; size = 96
_derivs$ = -148						; size = 48
_sumgrad$ = -100					; size = 96
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_scalar_integral_hess PROC				; COMDAT

; 488  : { int m,j,k,i;

	push	ebp
	mov	ebp, esp
	sub	esp, 2900				; 00000b54H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	edi
	mov	edi, DWORD PTR _e_info$[ebp]

; 489  :   REAL value = 0.0;
; 490  :   REAL len,sum,val;
; 491  :   REAL derivs[MAXCOORD];
; 492  :   REAL lengrad[2][MAXCOORD],sumgrad[2][MAXCOORD];
; 493  :   REAL lenhess[2][2][MAXCOORD][MAXCOORD],sumhess[2][2][MAXCOORD][MAXCOORD];
; 494  :   MAT2D(second,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _secondxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _secondqXvS$[ebp]
	push	ecx
	call	_mat2d_setup
	mov	DWORD PTR _second$[ebp], eax

; 495  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	eax, DWORD PTR [edi+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list
	add	esp, 16					; 00000010H
	mov	DWORD PTR _mi$[ebp], eax

; 496  : 
; 497  :   if ( web.modeltype == QUADRATIC ) return edge_scalar_integral_q_hess(e_info);

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	SHORT $LN43@edge_scala@9
	push	edi
	call	_edge_scalar_integral_q_hess
	add	esp, 4
	pop	edi

; 558  :   return value;
; 559  : } // end edge_scalar_integral_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@edge_scala@9:

; 498  :   if ( web.modeltype == LAGRANGE ) return edge_scalar_integral_lagr_hess(e_info);

	cmp	eax, 3
	jne	SHORT $LN42@edge_scala@9
	push	edi
	call	_edge_scalar_integral_lagr_hess
	add	esp, 4
	pop	edi

; 558  :   return value;
; 559  : } // end edge_scalar_integral_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@edge_scala@9:

; 499  : 
; 500  :   len = SDIM_dot(e_info->sides[0][0],e_info->sides[0][0]);

	mov	edx, DWORD PTR [edi+1276]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [eax]
	push	ecx
	push	eax
	push	eax
	call	_dot

; 501  :   if ( len <= 0.0 )

	fldz
	fcom	ST(1)
	add	esp, 12					; 0000000cH
	fnstsw	ax
	test	ah, 1

; 502  :   { 
; 503  :      return 0.0;

	je	$LN179@edge_scala@9

; 501  :   if ( len <= 0.0 )

	push	ebx
	fstp	ST(0)
	push	esi

; 504  :   }
; 505  :   len = sqrt(len);

	call	__CIsqrt
	fstp	QWORD PTR _len$[ebp]

; 506  : 
; 507  :   /* derivatives of gaussian sum part */
; 508  :   sum = 0.0;

	fldz

; 509  :   memset((char*)sumgrad,0,sizeof(sumgrad));

	push	96					; 00000060H
	lea	edx, DWORD PTR _sumgrad$[ebp]
	fstp	QWORD PTR _sum$[ebp]
	push	0
	push	edx
	call	_memset

; 510  :   memset((char*)sumhess,0,sizeof(sumhess));

	push	1152					; 00000480H
	lea	eax, DWORD PTR _sumhess$[ebp]
	push	0
	push	eax
	call	_memset

; 511  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	esi, DWORD PTR _web+616
	xor	ebx, ebx
	add	esp, 24					; 00000018H
	mov	DWORD PTR _m$[ebp], ebx
	cmp	DWORD PTR _gauss1D_num, ebx
	jg	$LN40@edge_scala@9
	fld	QWORD PTR _sum$[ebp]
$LN38@edge_scala@9:

; 536  :     lengrad[1][j] = e_info->sides[0][0][j]/len;

	fld	QWORD PTR _len$[ebp]
	xor	ecx, ecx
	cmp	esi, 4
	jl	$LC76@edge_scala@9
	mov	eax, DWORD PTR [edi+1276]
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	lea	ebx, DWORD PTR _lengrad$[ebp+32]
	sub	ebx, edx
	mov	DWORD PTR tv4573[ebp], ebx
	lea	ebx, DWORD PTR _lengrad$[ebp+40]
	sub	ebx, edx
	mov	DWORD PTR tv4581[ebp], ebx
	lea	ebx, DWORD PTR _lengrad$[ebp]
	sub	ebx, edx
	mov	DWORD PTR tv4585[ebp], ebx
	lea	ebx, DWORD PTR _lengrad$[ebp+48]
	sub	ebx, edx
	mov	DWORD PTR tv4589[ebp], ebx
	lea	ebx, DWORD PTR _lengrad$[ebp+8]
	sub	ebx, edx
	mov	DWORD PTR tv4593[ebp], ebx
	lea	ebx, DWORD PTR _lengrad$[ebp+56]
	lea	eax, DWORD PTR [edx+16]
	sub	ebx, edx
$LN77@edge_scala@9:
	fld	QWORD PTR [eax-16]
	mov	edx, DWORD PTR tv4573[ebp]
	fdiv	ST(0), ST(1)
	add	ecx, 4
	add	eax, 32					; 00000020H
	fld	ST(0)
	fchs
	fstp	QWORD PTR _lengrad$[ebp+ecx*8-32]
	fstp	QWORD PTR [edx+eax-32]
	mov	edx, DWORD PTR tv4581[ebp]
	fld	QWORD PTR [eax-40]
	fdiv	ST(0), ST(1)
	fld	ST(0)
	fchs
	fstp	QWORD PTR _lengrad$[ebp+ecx*8-24]
	fstp	QWORD PTR [edx+eax-32]
	mov	edx, DWORD PTR tv4585[ebp]
	fld	QWORD PTR [eax-32]
	fdiv	ST(0), ST(1)
	fld	ST(0)
	fchs
	fstp	QWORD PTR [edx+eax-32]
	mov	edx, DWORD PTR tv4589[ebp]
	fstp	QWORD PTR [edx+eax-32]
	mov	edx, DWORD PTR tv4593[ebp]
	fld	QWORD PTR [eax-24]
	fdiv	ST(0), ST(1)
	fld	ST(0)
	fchs
	fstp	QWORD PTR [edx+eax-32]
	lea	edx, DWORD PTR [esi-3]
	fstp	QWORD PTR [ebx+eax-32]
	cmp	ecx, edx
	jl	SHORT $LN77@edge_scala@9
$LC76@edge_scala@9:

; 530  :       }
; 531  :   }
; 532  : 
; 533  :   /* derivatives of length part */
; 534  :   for ( j = 0 ; j < SDIM ; j++ )

	cmp	ecx, esi
	jge	SHORT $LN75@edge_scala@9
	mov	eax, DWORD PTR [edi+1276]
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	lea	ebx, DWORD PTR _lengrad$[ebp]
	sub	ebx, edx
	mov	DWORD PTR tv4669[ebp], ebx
	lea	eax, DWORD PTR [edx+ecx*8]
	lea	ebx, DWORD PTR _lengrad$[ebp+48]
	sub	ebx, edx
	mov	edx, esi
	sub	edx, ecx
	mov	ecx, DWORD PTR tv4669[ebp]
$LC28@edge_scala@9:

; 535  :   { lengrad[0][j] = -e_info->sides[0][0][j]/len;

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	edx
	fdiv	ST(0), ST(1)
	fld	ST(0)
	fchs
	fstp	QWORD PTR [ecx+eax-8]

; 536  :     lengrad[1][j] = e_info->sides[0][0][j]/len;

	fstp	QWORD PTR [ebx+eax-8]
	jne	SHORT $LC28@edge_scala@9
$LN75@edge_scala@9:

; 537  :   }
; 538  :   for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	esi, esi
	jle	$LN23@edge_scala@9
	fld1
	lea	eax, DWORD PTR _lenhess$[ebp]
	mov	DWORD PTR tv5492[ebp], edx
	mov	DWORD PTR tv5573[ebp], eax
$LN105@edge_scala@9:

; 539  :     for ( k = 0 ; k < SDIM ; k++ )

	xor	ecx, ecx
	cmp	esi, 4
	jl	$LC79@edge_scala@9
	mov	DWORD PTR tv4694[ebp], 2
$LN84@edge_scala@9:

; 540  :       { val = -e_info->sides[0][0][j]*e_info->sides[0][0][k]/len/len/len;

	mov	ebx, DWORD PTR [edi+1276]
	mov	ebx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+ecx*8]
	fmul	QWORD PTR [ebx+edx*8]
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(2)
	fchs
	fst	QWORD PTR _val$[ebp]

; 541  :         if ( j == k ) val += 1/len;

	cmp	edx, ecx
	jne	SHORT $LN80@edge_scala@9
	fld	ST(1)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _val$[ebp]
$LN80@edge_scala@9:

; 542  :         lenhess[0][0][j][k] = lenhess[1][1][j][k] = val;

	mov	ebx, DWORD PTR [edi+1276]
	fst	QWORD PTR [eax+864]
	mov	ebx, DWORD PTR [ebx]
	fst	QWORD PTR [eax]
	mov	ebx, DWORD PTR [ebx]

; 543  :         lenhess[0][1][j][k] = lenhess[1][0][j][k] = -val;

	fchs
	fst	QWORD PTR [eax+576]
	fstp	QWORD PTR [eax+288]
	fld	QWORD PTR [ebx+ecx*8+8]
	fmul	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR tv4694[ebp]
	dec	ebx
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(2)
	fchs
	fst	QWORD PTR _val$[ebp]
	cmp	edx, ebx
	jne	SHORT $LN81@edge_scala@9

; 541  :         if ( j == k ) val += 1/len;

	fld	ST(1)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _val$[ebp]
$LN81@edge_scala@9:

; 542  :         lenhess[0][0][j][k] = lenhess[1][1][j][k] = val;

	mov	ebx, DWORD PTR [edi+1276]
	fst	QWORD PTR [eax+872]
	mov	ebx, DWORD PTR [ebx]
	fst	QWORD PTR [eax+8]
	mov	ebx, DWORD PTR [ebx]

; 543  :         lenhess[0][1][j][k] = lenhess[1][0][j][k] = -val;

	fchs
	fst	QWORD PTR [eax+584]
	fstp	QWORD PTR [eax+296]
	fld	QWORD PTR [ebx+ecx*8+16]
	fmul	QWORD PTR [ebx+edx*8]
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(2)
	fchs
	fst	QWORD PTR _val$[ebp]
	cmp	edx, DWORD PTR tv4694[ebp]
	jne	SHORT $LN82@edge_scala@9

; 541  :         if ( j == k ) val += 1/len;

	fld	ST(1)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _val$[ebp]
$LN82@edge_scala@9:

; 542  :         lenhess[0][0][j][k] = lenhess[1][1][j][k] = val;

	mov	ebx, DWORD PTR [edi+1276]
	fst	QWORD PTR [eax+880]
	mov	ebx, DWORD PTR [ebx]
	fst	QWORD PTR [eax+16]
	mov	ebx, DWORD PTR [ebx]

; 543  :         lenhess[0][1][j][k] = lenhess[1][0][j][k] = -val;

	fchs
	fst	QWORD PTR [eax+592]
	fstp	QWORD PTR [eax+304]
	fld	QWORD PTR [ebx+edx*8]
	fmul	QWORD PTR [ebx+ecx*8+24]
	mov	ebx, DWORD PTR tv4694[ebp]
	inc	ebx
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(2)
	fchs
	fst	QWORD PTR _val$[ebp]
	cmp	edx, ebx
	jne	SHORT $LN83@edge_scala@9

; 541  :         if ( j == k ) val += 1/len;

	fld	ST(1)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _val$[ebp]
$LN83@edge_scala@9:

; 543  :         lenhess[0][1][j][k] = lenhess[1][0][j][k] = -val;

	add	DWORD PTR tv4694[ebp], 4
	fst	QWORD PTR [eax+888]
	fst	QWORD PTR [eax+24]
	add	ecx, 4
	fchs
	lea	ebx, DWORD PTR [esi-3]
	fst	QWORD PTR [eax+600]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax+280]
	cmp	ecx, ebx
	jl	$LN84@edge_scala@9
$LC79@edge_scala@9:

; 539  :     for ( k = 0 ; k < SDIM ; k++ )

	cmp	ecx, esi
	jge	SHORT $LN24@edge_scala@9
	mov	eax, DWORD PTR tv5492[ebp]
	add	eax, ecx
	lea	eax, DWORD PTR _lenhess$[ebp+eax*8]
$LC22@edge_scala@9:

; 540  :       { val = -e_info->sides[0][0][j]*e_info->sides[0][0][k]/len/len/len;

	mov	ebx, DWORD PTR [edi+1276]
	mov	ebx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+ecx*8]
	fmul	QWORD PTR [ebx+edx*8]
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(2)
	fchs
	fst	QWORD PTR _val$[ebp]

; 541  :         if ( j == k ) val += 1/len;

	cmp	edx, ecx
	jne	SHORT $LN19@edge_scala@9
	fld	ST(1)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _val$[ebp]
$LN19@edge_scala@9:

; 542  :         lenhess[0][0][j][k] = lenhess[1][1][j][k] = val;

	fst	QWORD PTR [eax+864]
	inc	ecx
	fst	QWORD PTR [eax]
	add	eax, 8

; 543  :         lenhess[0][1][j][k] = lenhess[1][0][j][k] = -val;

	fchs
	fst	QWORD PTR [eax+568]
	fstp	QWORD PTR [eax+280]
	cmp	ecx, esi
	jl	SHORT $LC22@edge_scala@9
$LN24@edge_scala@9:

; 537  :   }
; 538  :   for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR tv5573[ebp]
	add	DWORD PTR tv5492[ebp], 6
	inc	edx
	add	eax, 48					; 00000030H
	mov	DWORD PTR tv5573[ebp], eax
	cmp	edx, esi
	jl	$LN105@edge_scala@9

; 539  :     for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
$LN23@edge_scala@9:

; 544  :       }
; 545  : 
; 546  :   /* final values */
; 547  :   value = len*sum;

	fld	ST(1)

; 548  :   for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	fmul	ST(0), ST(1)
	test	esi, esi
	jle	SHORT $LN16@edge_scala@9
$LN18@edge_scala@9:

; 549  :     for ( m = 0 ; m < 2 ; m++ )
; 550  :       e_info->grad[m][j] = lengrad[m][j]*sum + len*sumgrad[m][j];

	fld	QWORD PTR _lengrad$[ebp+eax*8]
	mov	ecx, DWORD PTR [edi+1336]
	mov	edx, DWORD PTR [ecx]
	fmul	ST(0), ST(3)
	fld	QWORD PTR _sumgrad$[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx+eax*8-8]
	mov	ecx, DWORD PTR [edi+1336]
	fld	QWORD PTR _lengrad$[ebp+eax*8+40]
	mov	edx, DWORD PTR [ecx+4]
	fmul	ST(0), ST(3)
	fld	QWORD PTR _sumgrad$[ebp+eax*8+40]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx+eax*8-8]
	mov	esi, DWORD PTR _web+616
	cmp	eax, esi
	jl	SHORT $LN18@edge_scala@9
$LN16@edge_scala@9:

; 551  :   for ( j = 0 ; j < SDIM ; j++ ) 

	xor	edx, edx
	test	esi, esi
	jle	$LN178@edge_scala@9
	xor	ecx, ecx
$LN12@edge_scala@9:

; 552  :     for ( k = 0 ; k < SDIM ; k++ ) 

	xor	eax, eax
	test	esi, esi
	jle	$LN11@edge_scala@9
$LN9@edge_scala@9:
	lea	esi, DWORD PTR [ecx+eax*8]

; 553  :      for ( m = 0 ; m < 2 ; m++ )
; 554  :       for ( i = 0 ; i < 2 ; i++ )
; 555  :          e_info->hess[m][i][j][k] = lenhess[m][i][j][k]*sum
; 556  :             + lengrad[m][j]*sumgrad[i][k] + sumgrad[m][j]*lengrad[i][k]
; 557  :             + len*sumhess[m][i][j][k];

	fld	QWORD PTR _lenhess$[ebp+esi]
	lea	esi, DWORD PTR [ecx+eax*8]
	fmul	ST(0), ST(3)
	fld	QWORD PTR _sumgrad$[ebp+eax*8]
	fmul	QWORD PTR _lengrad$[ebp+edx*8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _sumgrad$[ebp+edx*8]
	fmul	QWORD PTR _lengrad$[ebp+eax*8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _sumhess$[ebp+esi]
	mov	esi, DWORD PTR [edi+1340]
	mov	esi, DWORD PTR [esi]
	fmul	ST(0), ST(3)
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+edx*4]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+eax*8]
	lea	esi, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR _lenhess$[ebp+esi+288]
	lea	esi, DWORD PTR [ecx+eax*8]
	fmul	ST(0), ST(3)
	fld	QWORD PTR _sumgrad$[ebp+eax*8+48]
	fmul	QWORD PTR _lengrad$[ebp+edx*8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _sumgrad$[ebp+edx*8]
	fmul	QWORD PTR _lengrad$[ebp+eax*8+48]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _sumhess$[ebp+esi+288]
	mov	esi, DWORD PTR [edi+1340]
	mov	esi, DWORD PTR [esi]
	fmul	ST(0), ST(3)
	mov	esi, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi+edx*4]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+eax*8]
	lea	esi, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR _lenhess$[ebp+esi+576]
	lea	esi, DWORD PTR [ecx+eax*8]
	fmul	ST(0), ST(3)
	fld	QWORD PTR _sumgrad$[ebp+eax*8]
	fmul	QWORD PTR _lengrad$[ebp+edx*8+48]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _sumgrad$[ebp+edx*8+48]
	fmul	QWORD PTR _lengrad$[ebp+eax*8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _sumhess$[ebp+esi+576]
	mov	esi, DWORD PTR [edi+1340]
	mov	esi, DWORD PTR [esi+4]
	fmul	ST(0), ST(3)
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+edx*4]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+eax*8]
	lea	esi, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR _lenhess$[ebp+esi+864]
	lea	esi, DWORD PTR [ecx+eax*8]
	fmul	ST(0), ST(3)
	inc	eax
	fld	QWORD PTR _lengrad$[ebp+edx*8+48]
	fmul	QWORD PTR _sumgrad$[ebp+eax*8+40]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _sumgrad$[ebp+edx*8+48]
	fmul	QWORD PTR _lengrad$[ebp+eax*8+40]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _sumhess$[ebp+esi+864]
	mov	esi, DWORD PTR [edi+1340]
	mov	esi, DWORD PTR [esi+4]
	fmul	ST(0), ST(3)
	mov	esi, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi+edx*4]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+eax*8-8]
	mov	esi, DWORD PTR _web+616
	cmp	eax, esi
	jl	$LN9@edge_scala@9
$LN11@edge_scala@9:

; 551  :   for ( j = 0 ; j < SDIM ; j++ ) 

	inc	edx
	add	ecx, 48					; 00000030H
	cmp	edx, esi
	jl	$LN12@edge_scala@9
$LN178@edge_scala@9:
	pop	esi

; 552  :     for ( k = 0 ; k < SDIM ; k++ ) 

	fstp	ST(1)
	pop	ebx
$LN179@edge_scala@9:

; 558  :   return value;
; 559  : } // end edge_scalar_integral_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(1)
	xor	ecx, ebp
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	6
$LL128@edge_scala@9:

; 511  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	fstp	ST(0)
$LN40@edge_scala@9:

; 512  :   { e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	mov	ecx, DWORD PTR [edi+1268]
	fild	DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+ebx*4]

; 513  :     eval_second(mi->expr[0],e_info->gauss_pt[m],SDIM,&val,
; 514  :                                                  derivs,second,e_info->id);

	mov	ecx, DWORD PTR _second$[ebp]
	add	esi, esi
	fstp	QWORD PTR [edx+esi*8]
	mov	eax, DWORD PTR [edi]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _web+616
	lea	edx, DWORD PTR _derivs$[ebp]
	push	edx
	mov	edx, DWORD PTR [edi+1268]
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+ebx*4]
	push	ecx
	mov	ecx, DWORD PTR _mi$[ebp]
	mov	edx, DWORD PTR [ecx+232]
	push	eax
	push	edx
	call	_eval_second
	mov	edx, DWORD PTR _gauss1Dwt

; 515  :     sum += gauss1Dwt[m]*val;

	fld	QWORD PTR [edx+ebx*8]

; 516  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _web+616
	fmul	QWORD PTR _val$[ebp]
	add	esp, 28					; 0000001cH
	xor	eax, eax
	fadd	QWORD PTR _sum$[ebp]
	fst	QWORD PTR _sum$[ebp]
	cmp	esi, 4
	jl	$LC73@edge_scala@9

; 518  :       sumgrad[1][j] += gauss1Dwt[m]*gauss1poly[1][m]*derivs[j];

	mov	ecx, DWORD PTR _gauss1poly
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [ecx+ebx*8]
	mov	ecx, DWORD PTR _gauss1poly
	mov	ecx, DWORD PTR [ecx+4]
	fmul	QWORD PTR [edx+ebx*8]
	fld	QWORD PTR [ecx+ebx*8]
	lea	ecx, DWORD PTR [esi-3]
	fmul	QWORD PTR [edx+ebx*8]
$LN74@edge_scala@9:
	fld	ST(1)
	add	eax, 4
	fmul	QWORD PTR _derivs$[ebp+eax*8-32]
	fadd	QWORD PTR _sumgrad$[ebp+eax*8-32]
	fstp	QWORD PTR _sumgrad$[ebp+eax*8-32]
	fld	ST(0)
	fmul	QWORD PTR _derivs$[ebp+eax*8-32]
	fadd	QWORD PTR _sumgrad$[ebp+eax*8+16]
	fstp	QWORD PTR _sumgrad$[ebp+eax*8+16]
	fld	ST(1)
	fmul	QWORD PTR _derivs$[ebp+eax*8-24]
	fadd	QWORD PTR _sumgrad$[ebp+eax*8-24]
	fstp	QWORD PTR _sumgrad$[ebp+eax*8-24]
	fld	ST(0)
	fmul	QWORD PTR _derivs$[ebp+eax*8-24]
	fadd	QWORD PTR _sumgrad$[ebp+eax*8+24]
	fstp	QWORD PTR _sumgrad$[ebp+eax*8+24]
	fld	ST(1)
	fmul	QWORD PTR _derivs$[ebp+eax*8-16]
	fadd	QWORD PTR _sumgrad$[ebp+eax*8-16]
	fstp	QWORD PTR _sumgrad$[ebp+eax*8-16]
	fld	ST(0)
	fmul	QWORD PTR _derivs$[ebp+eax*8-16]
	fadd	QWORD PTR _sumgrad$[ebp+eax*8+32]
	fstp	QWORD PTR _sumgrad$[ebp+eax*8+32]
	fld	ST(1)
	fmul	QWORD PTR _derivs$[ebp+eax*8-8]
	fadd	QWORD PTR _sumgrad$[ebp+eax*8-8]
	fstp	QWORD PTR _sumgrad$[ebp+eax*8-8]
	fld	ST(0)
	fmul	QWORD PTR _derivs$[ebp+eax*8-8]
	fadd	QWORD PTR _sumgrad$[ebp+eax*8+40]
	fstp	QWORD PTR _sumgrad$[ebp+eax*8+40]
	cmp	eax, ecx
	jl	$LN74@edge_scala@9

; 516  :     for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(1)
	fstp	ST(0)
$LC73@edge_scala@9:
	cmp	eax, esi
	jge	SHORT $LN72@edge_scala@9
	mov	ecx, DWORD PTR _gauss1poly
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [ecx+ebx*8]
	mov	ecx, DWORD PTR _gauss1poly
	fmul	QWORD PTR [edx+ebx*8]
	mov	ecx, DWORD PTR [ecx+4]
	fld	QWORD PTR [ecx+ebx*8]
	fmul	QWORD PTR [edx+ebx*8]
$LC37@edge_scala@9:

; 517  :     { sumgrad[0][j] += gauss1Dwt[m]*gauss1poly[0][m]*derivs[j];

	fld	ST(1)
	inc	eax
	fmul	QWORD PTR _derivs$[ebp+eax*8-8]
	fadd	QWORD PTR _sumgrad$[ebp+eax*8-8]
	fstp	QWORD PTR _sumgrad$[ebp+eax*8-8]

; 518  :       sumgrad[1][j] += gauss1Dwt[m]*gauss1poly[1][m]*derivs[j];

	fld	ST(0)
	fmul	QWORD PTR _derivs$[ebp+eax*8-8]
	fadd	QWORD PTR _sumgrad$[ebp+eax*8+40]
	fstp	QWORD PTR _sumgrad$[ebp+eax*8+40]
	cmp	eax, esi
	jl	SHORT $LC37@edge_scala@9

; 516  :     for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(1)
	fstp	ST(0)
$LN72@edge_scala@9:

; 519  :     }
; 520  :     for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	mov	DWORD PTR _j$[ebp], eax
	test	esi, esi
	jle	$LN39@edge_scala@9

; 511  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	ecx, DWORD PTR _gauss1poly
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [ecx+ebx*8]
	lea	ecx, DWORD PTR [ecx+ebx*8]
	fmul	QWORD PTR [edx+ebx*8]
	mov	edx, DWORD PTR _gauss1poly
	mov	edx, DWORD PTR [edx+4]
	lea	edx, DWORD PTR [edx+ebx*8]
	fld	ST(0)
	mov	DWORD PTR tv2936[ebp], edx
	fmul	QWORD PTR [ecx]
	fxch	ST(1)
	fmul	QWORD PTR [edx]
	mov	edx, DWORD PTR _gauss1Dwt
	fld	QWORD PTR [edx+ebx*8]
	mov	edx, DWORD PTR tv2936[ebp]
	fmul	QWORD PTR [edx]
	fld	ST(0)
	fmul	QWORD PTR [ecx]

; 519  :     }
; 520  :     for ( j = 0 ; j < SDIM ; j++ )

	lea	ecx, DWORD PTR _sumhess$[ebp+288]
	fxch	ST(1)
	mov	DWORD PTR tv4250[ebp], ecx
	fmul	QWORD PTR [edx]
$LN34@edge_scala@9:
	mov	edx, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]

; 521  :       for ( k = 0 ; k < SDIM ; k++ )

	mov	eax, DWORD PTR tv4250[ebp]
	mov	edx, esi
$LN31@edge_scala@9:

; 522  :       { sumhess[0][0][j][k] += gauss1Dwt[m]*gauss1poly[0][m]*gauss1poly[0][m]
; 523  :                                               *second[j][k];

	fld	ST(3)
	add	ecx, 8
	fmul	QWORD PTR [ecx-8]
	add	eax, 8
	dec	edx
	fadd	QWORD PTR [eax-296]
	fstp	QWORD PTR [eax-296]

; 524  :         sumhess[0][1][j][k] += gauss1Dwt[m]*gauss1poly[0][m]*gauss1poly[1][m]
; 525  :                                               *second[j][k];

	fld	ST(2)
	fmul	QWORD PTR [ecx-8]
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]

; 526  :         sumhess[1][0][j][k] += gauss1Dwt[m]*gauss1poly[1][m]*gauss1poly[0][m]
; 527  :                                               *second[j][k];

	fld	ST(1)
	fmul	QWORD PTR [ecx-8]
	fadd	QWORD PTR [eax+280]
	fstp	QWORD PTR [eax+280]

; 528  :         sumhess[1][1][j][k] += gauss1Dwt[m]*gauss1poly[1][m]*gauss1poly[1][m]
; 529  :                                               *second[j][k];

	fld	ST(0)
	fmul	QWORD PTR [ecx-8]
	fadd	QWORD PTR [eax+568]
	fstp	QWORD PTR [eax+568]
	jne	SHORT $LN31@edge_scala@9

; 519  :     }
; 520  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	add	DWORD PTR tv4250[ebp], 48		; 00000030H
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, esi
	jl	SHORT $LN34@edge_scala@9

; 521  :       for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(3)
	fstp	ST(1)
	fstp	ST(0)
	fstp	ST(0)
$LN39@edge_scala@9:

; 511  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	ebx
	mov	DWORD PTR _m$[ebp], ebx
	cmp	ebx, DWORD PTR _gauss1D_num
	jl	$LL128@edge_scala@9
	jmp	$LN38@edge_scala@9
_edge_scalar_integral_hess ENDP
_TEXT	ENDS
PUBLIC	_edge_vector_integral
EXTRN	_edge_vector_integral_lagrange:PROC
; Function compile flags: /Ogtp
;	COMDAT _edge_vector_integral
_TEXT	SEGMENT
_value$ = -12						; size = 8
_mi$ = -4						; size = 4
tv310 = 8						; size = 4
_m$ = 8							; size = 4
_e_info$ = 8						; size = 4
_edge_vector_integral PROC				; COMDAT

; 818  : { int m,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 819  :   REAL value=0.0;

	fldz

; 820  :   struct method_instance *mi = METH_INSTANCE(e_info->method);
; 821  : 
; 822  :   if ( web.modeltype == QUADRATIC ) return edge_vector_integral_q(e_info);

	mov	ecx, DWORD PTR _web+628
	push	esi
	fst	QWORD PTR _value$[ebp]
	mov	esi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [esi+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list
	mov	DWORD PTR _mi$[ebp], eax
	cmp	ecx, 2
	jne	SHORT $LN8@edge_vecto@4
	push	esi
	fstp	ST(0)
	call	_edge_vector_integral_q
	add	esp, 4
	pop	esi

; 833  : } // end edge_vector_integral()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@edge_vecto@4:

; 823  :   if ( web.modeltype == LAGRANGE ) return edge_vector_integral_lagrange(e_info);

	cmp	ecx, 3
	jne	SHORT $LN7@edge_vecto@4
	push	esi
	fstp	ST(0)
	call	_edge_vector_integral_lagrange
	add	esp, 4
	pop	esi

; 833  : } // end edge_vector_integral()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@edge_vecto@4:
	push	ebx

; 824  :   for (  m = 0 ; m < gauss1D_num ; m++ )

	xor	ebx, ebx
	mov	DWORD PTR _m$[ebp], ebx
	cmp	DWORD PTR _gauss1D_num, ebx
	jle	$LN4@edge_vecto@4
	mov	ecx, DWORD PTR _web+616
	push	edi
$LN18@edge_vecto@4:

; 825  :   { e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	mov	edx, DWORD PTR [esi+1268]
	fild	DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	add	ecx, ecx
	fstp	QWORD PTR [edx+ecx*8]

; 826  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	xor	edi, edi
	test	ecx, ecx
	jle	SHORT $LN5@edge_vecto@4

; 825  :   { e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	add	eax, 232				; 000000e8H
	mov	DWORD PTR tv310[ebp], eax
$LL39@edge_vecto@4:

; 827  :     { REAL green;
; 828  :       green = gauss1Dwt[m]*eval(mi->expr[j],e_info->gauss_pt[m],e_info->id,NULL);

	mov	eax, DWORD PTR [esi]
	fstp	ST(0)
	mov	ecx, DWORD PTR [esi+1268]
	mov	edx, DWORD PTR [ecx+ebx*4]
	push	0
	push	eax
	mov	eax, DWORD PTR tv310[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	ecx
	call	_eval
	mov	edx, DWORD PTR _gauss1Dwt
	fmul	QWORD PTR [edx+ebx*8]

; 829  :       value += e_info->sides[0][0][j]*green;

	mov	eax, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	fmul	QWORD PTR [edx+edi*8]
	mov	ecx, DWORD PTR _web+616
	add	DWORD PTR tv310[ebp], 4
	inc	edi
	fadd	QWORD PTR _value$[ebp]
	add	esp, 16					; 00000010H
	fst	QWORD PTR _value$[ebp]
	cmp	edi, ecx
	jl	SHORT $LL39@edge_vecto@4

; 826  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _mi$[ebp]
$LN5@edge_vecto@4:

; 824  :   for (  m = 0 ; m < gauss1D_num ; m++ )

	inc	ebx
	mov	DWORD PTR _m$[ebp], ebx
	cmp	ebx, DWORD PTR _gauss1D_num
	jl	SHORT $LN18@edge_vecto@4
	pop	edi
$LN4@edge_vecto@4:

; 830  :     }
; 831  :   }  
; 832  :   return (get_eattr(e_info->id) & NEGBOUNDARY) ? -value : value;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	or	eax, ecx
	pop	ebx
	je	SHORT $LN9@edge_vecto@4
	fchs
$LN9@edge_vecto@4:
	pop	esi

; 833  : } // end edge_vector_integral()

	mov	esp, ebp
	pop	ebp
	ret	0
_edge_vector_integral ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_edge_vector_integral_grad
EXTRN	_edge_vector_integral_lagrange_grad:PROC
; Function compile flags: /Ogtp
;	COMDAT _edge_vector_integral_grad
_TEXT	SEGMENT
_weight$89595 = -384					; size = 8
_value$ = -376						; size = 8
_sign$ = -368						; size = 8
_mi$ = -360						; size = 4
tv525 = -356						; size = 4
tv634 = -352						; size = 4
tv503 = -352						; size = 4
_m$ = -348						; size = 4
tv632 = -344						; size = 4
_k$ = -344						; size = 4
_derivs$ = -340						; size = 288
_val$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_vector_integral_grad PROC				; COMDAT

; 844  : { int m,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 384				; 00000180H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 845  :   REAL value = 0.0;
; 846  :   REAL val[MAXCOORD];
; 847  :   REAL derivs[MAXCOORD][MAXCOORD];
; 848  :   REAL sum;
; 849  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	ecx, DWORD PTR _web+124
	fldz
	push	ebx
	fld	ST(0)
	push	edi
	fst	QWORD PTR _value$[ebp]
	mov	edi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [edi]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN23@edge_vecto@5
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN80@edge_vecto@5
$LN23@edge_vecto@5:
	fld1
$LN80@edge_vecto@5:

; 850  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	eax, DWORD PTR [edi+8]
	fstp	QWORD PTR _sign$[ebp]
	cdq
	mov	ebx, eax

; 851  : 
; 852  :   if ( web.modeltype == QUADRATIC ) return edge_vector_integral_q_grad(e_info);

	mov	eax, DWORD PTR _web+628
	xor	ebx, edx
	sub	ebx, edx
	imul	ebx, 2928				; 00000b70H
	add	ebx, DWORD PTR _meth_inst_list
	mov	DWORD PTR _mi$[ebp], ebx
	cmp	eax, 2
	jne	SHORT $LN20@edge_vecto@5
	fstp	ST(1)
	push	edi
	fstp	ST(0)
	call	_edge_vector_integral_q_grad
	add	esp, 4
	pop	edi
	pop	ebx

; 870  :     }
; 871  :   }
; 872  : 
; 873  :   return sign*value;
; 874  : } // end edge_vector_integral_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@edge_vecto@5:

; 853  :   if ( web.modeltype == LAGRANGE ) 

	cmp	eax, 3
	jne	SHORT $LN19@edge_vecto@5
	fstp	ST(1)

; 854  :      return edge_vector_integral_lagrange_grad(e_info);

	push	edi
	fstp	ST(0)
	call	_edge_vector_integral_lagrange_grad
	add	esp, 4
	pop	edi
	pop	ebx

; 870  :     }
; 871  :   }
; 872  : 
; 873  :   return sign*value;
; 874  : } // end edge_vector_integral_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@edge_vecto@5:
	push	esi

; 855  :   for ( k = 0 ; k < 2 ; k++ )

	mov	esi, DWORD PTR _web+616
	xor	ecx, ecx
$LN18@edge_vecto@5:

; 856  :      for ( j = 0 ; j < SDIM ; j++ ) 

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN17@edge_vecto@5
$LN57@edge_vecto@5:

; 857  :         e_info->grad[k][j] = 0.0;

	mov	edx, DWORD PTR [edi+1336]
	fxch	ST(1)
	mov	edx, DWORD PTR [ecx+edx]
	fst	QWORD PTR [edx+eax*8]
	mov	esi, DWORD PTR _web+616
	inc	eax
	fxch	ST(1)
	cmp	eax, esi
	jl	SHORT $LN57@edge_vecto@5
$LN17@edge_vecto@5:

; 855  :   for ( k = 0 ; k < 2 ; k++ )

	add	ecx, 4
	cmp	ecx, 8
	jl	SHORT $LN18@edge_vecto@5

; 858  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	ecx, ecx
	fstp	ST(1)
	mov	DWORD PTR _m$[ebp], ecx
	cmp	DWORD PTR _gauss1D_num, ecx
	jle	$LN10@edge_vecto@5
	jmp	SHORT $LN81@edge_vecto@5
	npad	1
$LL79@edge_vecto@5:
	mov	ecx, DWORD PTR _m$[ebp]
	mov	ebx, DWORD PTR _mi$[ebp]
$LN81@edge_vecto@5:

; 859  :   { REAL weight = sign*gauss1Dwt[m];

	mov	eax, DWORD PTR _gauss1Dwt

; 865  :     for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
	fld	QWORD PTR [eax+ecx*8]
	mov	edx, DWORD PTR [edi+1268]
	fmul	QWORD PTR _sign$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	add	esi, esi
	fstp	QWORD PTR _weight$89595[ebp]
	fild	DWORD PTR _m$[ebp]
	fstp	QWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR _web+616
	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN7@edge_vecto@5

; 859  :   { REAL weight = sign*gauss1Dwt[m];

	lea	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR tv632[ebp], edx
	lea	edx, DWORD PTR _derivs$[ebp]
	mov	DWORD PTR tv634[ebp], edx
	add	ebx, 232				; 000000e8H
	jmp	SHORT $LN9@edge_vecto@5
	npad	2
$LL42@edge_vecto@5:
	mov	ecx, DWORD PTR _m$[ebp]
$LN9@edge_vecto@5:

; 860  :     e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */
; 861  :     for ( j = 0 ; j < SDIM ; j++ ) 
; 862  :       eval_all(mi->expr[j],e_info->gauss_pt[m],SDIM,
; 863  :         val+j, derivs[j],e_info->id);

	mov	edx, DWORD PTR [edi]
	push	edx
	mov	edx, DWORD PTR tv634[ebp]
	push	edx
	mov	edx, DWORD PTR tv632[ebp]
	push	edx
	mov	edx, DWORD PTR [ebx]
	push	eax
	mov	eax, DWORD PTR [edi+1268]
	mov	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	push	edx
	call	_eval_all
	mov	eax, DWORD PTR _web+616
	add	DWORD PTR tv634[ebp], 48		; 00000030H
	add	DWORD PTR tv632[ebp], 8
	inc	esi
	add	esp, 24					; 00000018H
	add	ebx, 4
	cmp	esi, eax
	jl	SHORT $LL42@edge_vecto@5
$LN7@edge_vecto@5:

; 864  :     value += gauss1Dwt[m]*SDIM_dot(val,e_info->sides[0][0]);

	push	eax
	mov	eax, DWORD PTR [edi+1276]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_dot
	mov	ecx, DWORD PTR _gauss1Dwt
	mov	eax, DWORD PTR _m$[ebp]
	fmul	QWORD PTR [ecx+eax*8]

; 865  :     for ( k = 0 ; k < SDIM ; k++ )

	mov	esi, DWORD PTR _web+616
	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	fadd	QWORD PTR _value$[ebp]
	mov	DWORD PTR _k$[ebp], ecx
	fst	QWORD PTR _value$[ebp]
	test	esi, esi
	jle	$LN11@edge_vecto@5

; 858  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	edx, DWORD PTR _gauss1poly
	fldz
	mov	ebx, DWORD PTR [edx]
	fld	QWORD PTR _weight$89595[ebp]
	mov	edx, DWORD PTR [edx+4]
	lea	ebx, DWORD PTR [ebx+eax*8]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	DWORD PTR tv503[ebp], ebx
	mov	DWORD PTR tv525[ebp], eax
$LN41@edge_vecto@5:

; 866  :     { for ( sum = 0.0, j = 0 ; j < SDIM ; j++ )

	xor	ebx, ebx
	fld	ST(1)
	cmp	esi, 4
	jl	SHORT $LC38@edge_vecto@5
	mov	edx, DWORD PTR [edi+1276]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax]
	lea	edx, DWORD PTR [esi-4]
	shr	edx, 2
	add	eax, 16					; 00000010H
	inc	edx
	lea	ecx, DWORD PTR _derivs$[ebp+ecx*8+48]
	lea	ebx, DWORD PTR [edx*4]
$LN39@edge_vecto@5:

; 867  :         sum += derivs[j][k]*e_info->sides[0][0][j];

	fld	QWORD PTR [ecx-48]
	add	eax, 32					; 00000020H
	fmul	QWORD PTR [eax-48]
	add	ecx, 192				; 000000c0H
	dec	edx
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax-40]
	fmul	QWORD PTR [ecx-192]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-144]
	fmul	QWORD PTR [eax-32]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-96]
	fmul	QWORD PTR [eax-24]
	faddp	ST(1), ST(0)
	jne	SHORT $LN39@edge_vecto@5

; 866  :     { for ( sum = 0.0, j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _k$[ebp]
$LC38@edge_vecto@5:
	cmp	ebx, esi
	jge	SHORT $LN37@edge_vecto@5
	mov	edx, DWORD PTR [edi+1276]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [edx+ebx*8]
	lea	edx, DWORD PTR [ebx+ebx*2]
	lea	edx, DWORD PTR [ecx+edx*2]
	lea	edx, DWORD PTR _derivs$[ebp+edx*8]
	sub	esi, ebx
$LC3@edge_vecto@5:

; 867  :         sum += derivs[j][k]*e_info->sides[0][0][j];

	fld	QWORD PTR [edx]
	add	eax, 8
	fmul	QWORD PTR [eax-8]
	add	edx, 48					; 00000030H
	dec	esi
	faddp	ST(1), ST(0)
	jne	SHORT $LC3@edge_vecto@5
$LN37@edge_vecto@5:

; 868  :       e_info->grad[0][k] += weight*(-val[k] + gauss1poly[0][m]*sum);

	mov	eax, DWORD PTR [edi+1336]
	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR tv503[ebp]
	fld	QWORD PTR [edx]
	fmul	ST(0), ST(1)
	fsub	QWORD PTR _val$[ebp+ecx*8]
	fmul	ST(0), ST(2)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR [edi+1336]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx+ecx*8]

; 869  :       e_info->grad[1][k] += weight*(val[k] + gauss1poly[1][m]*sum);

	mov	edx, DWORD PTR tv525[ebp]
	fmul	QWORD PTR [edx]
	inc	ecx
	mov	DWORD PTR _k$[ebp], ecx
	fadd	QWORD PTR _val$[ebp+ecx*8-8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	esi, DWORD PTR _web+616
	cmp	ecx, esi
	jl	$LN41@edge_vecto@5

; 865  :     for ( k = 0 ; k < SDIM ; k++ )

	mov	eax, DWORD PTR _m$[ebp]
	fstp	ST(0)
	fstp	ST(0)
$LN11@edge_vecto@5:

; 858  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	eax
	mov	DWORD PTR _m$[ebp], eax
	cmp	eax, DWORD PTR _gauss1D_num
	jl	$LL79@edge_vecto@5
$LN10@edge_vecto@5:

; 870  :     }
; 871  :   }
; 872  : 
; 873  :   return sign*value;
; 874  : } // end edge_vector_integral_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fmul	QWORD PTR _sign$[ebp]
	pop	esi
	pop	edi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_vector_integral_grad ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_edge_vector_integral_hess
EXTRN	_edge_vector_integral_lagrange_hess:PROC
; Function compile flags: /Ogtp
;	COMDAT _edge_vector_integral_hess
_TEXT	SEGMENT
_secondqXvS$ = -2300					; size = 168
_sign$ = -2132						; size = 8
_value$ = -2124						; size = 8
_weight$89629 = -2116					; size = 8
tv971 = -2112						; size = 4
_mi$ = -2108						; size = 4
tv847 = -2104						; size = 4
_second$ = -2100					; size = 4
tv2688 = -2096						; size = 4
tv2686 = -2092						; size = 4
_k$ = -2092						; size = 4
tv1026 = -2088						; size = 4
tv1008 = -2088						; size = 4
tv990 = -2088						; size = 4
_j$ = -2088						; size = 4
_m$ = -2084						; size = 4
tv2104 = -2080						; size = 4
tv870 = -2080						; size = 4
tv548 = -2080						; size = 4
tv2444 = -2076						; size = 4
tv1113 = -2076						; size = 4
tv2378 = -2072						; size = 4
tv1111 = -2072						; size = 4
_secondxJ$ = -2068					; size = 1728
_derivs$ = -340						; size = 288
_val$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_edge_vector_integral_hess PROC				; COMDAT

; 885  : { int m,i,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 2300				; 000008fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 886  :   REAL value = 0.0;

	fldz
	push	esi
	push	edi
	fstp	QWORD PTR _value$[ebp]
	mov	edi, DWORD PTR _e_info$[ebp]

; 887  :   REAL val[MAXCOORD];
; 888  :   REAL derivs[MAXCOORD][MAXCOORD];
; 889  :   REAL sum;
; 890  :   MAT3D(second,MAXCOORD,MAXCOORD,MAXCOORD);

	push	6
	push	6
	push	6
	lea	eax, DWORD PTR _secondxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _secondqXvS$[ebp]
	push	ecx
	call	_mat3d_setup

; 891  :   REAL sign = (get_eattr(e_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR _second$[ebp], eax
	mov	eax, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	add	esp, 20					; 00000014H
	or	eax, ecx
	je	SHORT $LN26@edge_vecto@6
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN91@edge_vecto@6
$LN26@edge_vecto@6:
	fld1
$LN91@edge_vecto@6:

; 892  :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	eax, DWORD PTR [edi+8]
	fstp	QWORD PTR _sign$[ebp]
	cdq
	mov	esi, eax

; 893  : 
; 894  :   if ( web.modeltype == QUADRATIC ) return edge_vector_integral_q_hess(e_info);

	mov	eax, DWORD PTR _web+628
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list
	mov	DWORD PTR _mi$[ebp], esi
	cmp	eax, 2
	jne	SHORT $LN23@edge_vecto@6
	push	edi
	call	_edge_vector_integral_q_hess
	add	esp, 4
	pop	edi
	pop	esi

; 924  :      }
; 925  :   }
; 926  : 
; 927  :   return value;
; 928  : } // end edge_vector_integral_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@edge_vecto@6:

; 895  :   if ( web.modeltype == LAGRANGE ) 

	cmp	eax, 3
	jne	SHORT $LN22@edge_vecto@6

; 896  :      return edge_vector_integral_lagrange_hess(e_info);

	push	edi
	call	_edge_vector_integral_lagrange_hess
	add	esp, 4
	pop	edi
	pop	esi

; 924  :      }
; 925  :   }
; 926  : 
; 927  :   return value;
; 928  : } // end edge_vector_integral_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@edge_vecto@6:

; 897  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	ecx, ecx
	mov	DWORD PTR _m$[ebp], ecx
	cmp	DWORD PTR _gauss1D_num, ecx
	jle	$LN50@edge_vecto@6
	push	ebx
	mov	ebx, DWORD PTR _web+616
	jmp	SHORT $LN21@edge_vecto@6
	npad	6
$LL48@edge_vecto@6:
	mov	ecx, DWORD PTR _m$[ebp]
	mov	esi, DWORD PTR _mi$[ebp]
$LN21@edge_vecto@6:

; 898  :   { REAL weight = sign*gauss1Dwt[m];

	mov	edx, DWORD PTR _gauss1Dwt
	fld	QWORD PTR [edx+ecx*8]

; 899  :     e_info->gauss_pt[m][2*SDIM] = m; /* kludge for attr interpolation. */

	mov	eax, DWORD PTR [edi+1268]
	fmul	QWORD PTR _sign$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	add	ebx, ebx
	fstp	QWORD PTR _weight$89629[ebp]
	fild	DWORD PTR _m$[ebp]
	fstp	QWORD PTR [edx+ebx*8]

; 900  :     for ( j = 0 ; j < SDIM ; j++ ) 

	mov	eax, DWORD PTR _web+616
	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN16@edge_vecto@6

; 898  :   { REAL weight = sign*gauss1Dwt[m];

	lea	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR tv1111[ebp], edx
	lea	edx, DWORD PTR _derivs$[ebp]
	mov	DWORD PTR tv1113[ebp], edx
	add	esi, 232				; 000000e8H
	jmp	SHORT $LN18@edge_vecto@6
	npad	3
$LL53@edge_vecto@6:
	mov	ecx, DWORD PTR _m$[ebp]
$LN18@edge_vecto@6:

; 901  :       eval_second(mi->expr[j],e_info->gauss_pt[m],SDIM,val+j,
; 902  :                                               derivs[j],second[j],e_info->id);

	mov	edx, DWORD PTR [edi]
	push	edx
	mov	edx, DWORD PTR _second$[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	push	edx
	mov	edx, DWORD PTR tv1113[ebp]
	push	edx
	mov	edx, DWORD PTR tv1111[ebp]
	push	edx
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edi+1268]
	mov	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	push	edx
	call	_eval_second
	mov	eax, DWORD PTR _web+616
	add	DWORD PTR tv1113[ebp], 48		; 00000030H
	add	DWORD PTR tv1111[ebp], 8
	inc	ebx
	add	esp, 28					; 0000001cH
	add	esi, 4
	cmp	ebx, eax
	jl	SHORT $LL53@edge_vecto@6
$LN16@edge_vecto@6:

; 903  :     value += weight*SDIM_dot(val,e_info->sides[0][0]);

	push	eax
	mov	eax, DWORD PTR [edi+1276]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_dot
	fld	QWORD PTR _weight$89629[ebp]

; 904  :     for ( k = 0 ; k < SDIM ; k++ )

	mov	ebx, DWORD PTR _web+616
	fmul	ST(1), ST(0)
	fxch	ST(1)
	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	fadd	QWORD PTR _value$[ebp]
	mov	DWORD PTR _k$[ebp], ecx
	fstp	QWORD PTR _value$[ebp]
	fldz
	test	ebx, ebx
	jle	$LN13@edge_vecto@6

; 897  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	edx, DWORD PTR _gauss1poly
	mov	esi, DWORD PTR [edx]
	mov	eax, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [edx+4]
	lea	esi, DWORD PTR [esi+eax*8]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	DWORD PTR tv847[ebp], esi
	mov	DWORD PTR tv870[ebp], eax
$LN51@edge_vecto@6:

; 905  :     { for ( sum = 0.0, j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	fld	ST(0)
	cmp	ebx, 4
	jl	SHORT $LC43@edge_vecto@6
	mov	edx, DWORD PTR [edi+1276]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax]
	lea	edx, DWORD PTR [ebx-4]
	shr	edx, 2
	add	eax, 16					; 00000010H
	inc	edx
	lea	ecx, DWORD PTR _derivs$[ebp+ecx*8+48]
	lea	esi, DWORD PTR [edx*4]
$LN44@edge_vecto@6:

; 906  :           sum += derivs[j][k]*e_info->sides[0][0][j];

	fld	QWORD PTR [ecx-48]
	add	eax, 32					; 00000020H
	fmul	QWORD PTR [eax-48]
	add	ecx, 192				; 000000c0H
	dec	edx
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax-40]
	fmul	QWORD PTR [ecx-192]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-144]
	fmul	QWORD PTR [eax-32]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-96]
	fmul	QWORD PTR [eax-24]
	faddp	ST(1), ST(0)
	jne	SHORT $LN44@edge_vecto@6

; 905  :     { for ( sum = 0.0, j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _k$[ebp]
$LC43@edge_vecto@6:
	cmp	esi, ebx
	jge	SHORT $LN42@edge_vecto@6
	mov	edx, DWORD PTR [edi+1276]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [edx+esi*8]
	lea	edx, DWORD PTR [esi+esi*2]
	lea	edx, DWORD PTR [ecx+edx*2]
	lea	edx, DWORD PTR _derivs$[ebp+edx*8]
	sub	ebx, esi
$LC12@edge_vecto@6:

; 906  :           sum += derivs[j][k]*e_info->sides[0][0][j];

	fld	QWORD PTR [eax]
	add	eax, 8
	fmul	QWORD PTR [edx]
	add	edx, 48					; 00000030H
	dec	ebx
	faddp	ST(1), ST(0)
	jne	SHORT $LC12@edge_vecto@6
$LN42@edge_vecto@6:

; 907  :       e_info->grad[0][k] += weight*(-val[k] + gauss1poly[0][m]*sum);

	mov	eax, DWORD PTR [edi+1336]
	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR tv847[ebp]
	fld	QWORD PTR [edx]
	fmul	ST(0), ST(1)
	fsub	QWORD PTR _val$[ebp+ecx*8]
	fmul	ST(0), ST(3)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR [edi+1336]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx+ecx*8]

; 908  :       e_info->grad[1][k] += weight*(val[k] + gauss1poly[1][m]*sum);

	mov	edx, DWORD PTR tv870[ebp]
	fmul	QWORD PTR [edx]
	inc	ecx
	mov	DWORD PTR _k$[ebp], ecx
	fadd	QWORD PTR _val$[ebp+ecx*8-8]
	fmul	ST(0), ST(2)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	ebx, DWORD PTR _web+616
	cmp	ecx, ebx
	jl	$LN51@edge_vecto@6
$LN13@edge_vecto@6:

; 909  :     }
; 910  :     for ( k = 0 ; k < SDIM ; k++ )

	xor	ecx, ecx
	test	ebx, ebx
	jle	$LN90@edge_vecto@6
	lea	eax, DWORD PTR _derivs$[ebp]
	mov	edx, eax
	mov	DWORD PTR tv2686[ebp], eax
	mov	DWORD PTR tv2688[ebp], edx
$LN54@edge_vecto@6:

; 911  :      for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	test	ebx, ebx
	jle	$LN8@edge_vecto@6

; 897  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	esi, DWORD PTR _gauss1poly
	mov	edx, DWORD PTR [esi]
	mov	ebx, DWORD PTR _m$[ebp]
	mov	esi, DWORD PTR [esi+4]
	lea	esi, DWORD PTR [esi+ebx*8]
	mov	DWORD PTR tv971[ebp], esi

; 911  :      for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR tv2688[ebp]
	lea	edx, DWORD PTR [edx+ebx*8]
	mov	ebx, DWORD PTR _web+616
	mov	DWORD PTR tv2378[ebp], esi
	mov	esi, DWORD PTR tv2686[ebp]
	mov	DWORD PTR tv847[ebp], edx
	mov	DWORD PTR tv2444[ebp], esi
$LN6@edge_vecto@6:

; 912  :      { for ( sum = 0.0, j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	fld	ST(0)
	cmp	ebx, 4
	jl	$LC46@edge_vecto@6
	mov	edx, DWORD PTR [edi+1276]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx]
	mov	esi, DWORD PTR _second$[ebp]
	add	ebx, -4					; fffffffcH
	shr	ebx, 2
	inc	ebx
	mov	DWORD PTR tv548[ebp], ebx
	add	ebx, ebx
	add	edx, 16					; 00000010H
	add	esi, 8
	add	ebx, ebx
	mov	DWORD PTR _j$[ebp], ebx
$LN47@edge_vecto@6:

; 913  :          sum += second[j][k][i]*e_info->sides[0][0][j];

	mov	ebx, DWORD PTR [esi-8]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [esi-4]
	fmul	QWORD PTR [edx-16]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	add	esi, 16					; 00000010H
	add	edx, 32					; 00000020H
	dec	DWORD PTR tv548[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [esi-16]
	fmul	QWORD PTR [edx-40]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [esi-12]
	fmul	QWORD PTR [edx-32]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+eax*8]
	fmul	QWORD PTR [edx-24]
	faddp	ST(1), ST(0)
	jne	SHORT $LN47@edge_vecto@6

; 912  :      { for ( sum = 0.0, j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR tv847[ebp]
	mov	ebx, DWORD PTR _web+616
$LC46@edge_vecto@6:
	cmp	esi, ebx
	jge	SHORT $LN45@edge_vecto@6
	mov	ebx, DWORD PTR [edi+1276]
	mov	ebx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx]
	lea	ebx, DWORD PTR [ebx+esi*8]
	mov	DWORD PTR tv2104[ebp], ebx
$LC3@edge_vecto@6:

; 913  :          sum += second[j][k][i]*e_info->sides[0][0][j];

	mov	ebx, DWORD PTR _second$[ebp]
	mov	ebx, DWORD PTR [ebx+esi*4]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR tv2104[ebp]
	fmul	QWORD PTR [ebx]
	inc	esi
	add	ebx, 8
	mov	DWORD PTR tv2104[ebp], ebx
	faddp	ST(1), ST(0)
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LC3@edge_vecto@6
$LN45@edge_vecto@6:

; 914  :        e_info->hess[0][0][k][i] += weight*gauss1poly[0][m]
; 915  :             *(gauss1poly[0][m]*sum - derivs[k][i] - derivs[i][k]);

	fld	QWORD PTR [edx]
	mov	ebx, DWORD PTR tv2378[ebp]
	fmul	ST(0), ST(1)
	mov	esi, DWORD PTR [edi+1340]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi]
	fsub	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv2444[ebp]
	mov	esi, DWORD PTR [esi+ecx*4]
	lea	esi, DWORD PTR [esi+eax*8]
	fsub	QWORD PTR [ebx]

; 916  :        e_info->hess[0][1][k][i] += weight
; 917  :             *(gauss1poly[0][m]*gauss1poly[1][m]*sum 
; 918  :             - gauss1poly[1][m]*derivs[k][i] + gauss1poly[0][m]*derivs[i][k]);

	mov	ebx, DWORD PTR tv2378[ebp]
	fld	QWORD PTR [edx]
	fmul	ST(0), ST(4)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	mov	esi, DWORD PTR [edi+1340]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi+ecx*4]
	lea	esi, DWORD PTR [esi+eax*8]
	mov	DWORD PTR tv990[ebp], esi
	mov	esi, DWORD PTR tv971[ebp]
	fld	QWORD PTR [esi]
	fmul	QWORD PTR [edx]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [esi]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv2444[ebp]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [edx]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv990[ebp]
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(3)
	fadd	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]

; 919  :        e_info->hess[1][0][k][i] += weight
; 920  :             *(gauss1poly[0][m]*gauss1poly[1][m]*sum 
; 921  :             + gauss1poly[0][m]*derivs[k][i] - gauss1poly[1][m]*derivs[i][k]);

	mov	ebx, DWORD PTR [edi+1340]
	mov	ebx, DWORD PTR [ebx+4]
	fld	QWORD PTR [esi]
	fmul	QWORD PTR [edx]
	mov	ebx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	lea	ebx, DWORD PTR [ebx+eax*8]
	fmul	ST(0), ST(1)
	mov	DWORD PTR tv1008[ebp], ebx
	fld	QWORD PTR [edx]
	mov	ebx, DWORD PTR tv2378[ebp]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv2444[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv1008[ebp]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(3)
	fadd	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [edi+1340]
	mov	ebx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx+4]

; 922  :        e_info->hess[1][1][k][i] += weight*gauss1poly[1][m]
; 923  :             *(gauss1poly[1][m]*sum + derivs[k][i] + derivs[i][k]);

	fmul	QWORD PTR [esi]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	lea	ebx, DWORD PTR [ebx+eax*8]
	mov	DWORD PTR tv1026[ebp], ebx
	mov	ebx, DWORD PTR tv2378[ebp]
	fadd	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv2444[ebp]
	add	ebx, 48					; 00000030H
	inc	eax
	fadd	QWORD PTR [ebx-48]
	add	DWORD PTR tv2378[ebp], 8
	fld	QWORD PTR [esi]
	mov	esi, DWORD PTR tv1026[ebp]
	fmul	ST(0), ST(3)
	mov	DWORD PTR tv2444[ebp], ebx
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	mov	ebx, DWORD PTR _web+616

; 911  :      for ( i = 0 ; i < SDIM ; i++ )

	cmp	eax, ebx
	jl	$LN6@edge_vecto@6
$LN8@edge_vecto@6:

; 909  :     }
; 910  :     for ( k = 0 ; k < SDIM ; k++ )

	add	DWORD PTR tv2688[ebp], 48		; 00000030H
	add	DWORD PTR tv2686[ebp], 8
	inc	ecx
	cmp	ecx, ebx
	jl	$LN54@edge_vecto@6
$LN90@edge_vecto@6:

; 897  :   for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	eax, DWORD PTR _m$[ebp]

; 911  :      for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(1)
	inc	eax
	fstp	ST(0)
	mov	DWORD PTR _m$[ebp], eax
	cmp	eax, DWORD PTR _gauss1D_num
	jl	$LL48@edge_vecto@6
	pop	ebx
$LN50@edge_vecto@6:

; 924  :      }
; 925  :   }
; 926  : 
; 927  :   return value;
; 928  : } // end edge_vector_integral_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fld	QWORD PTR _value$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_vector_integral_hess ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@KODKMINH@Need?5torus?5model?5to?5use?5edge_tor@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_q_edge_torus_area
;	COMDAT ??_C@_0DB@KODKMINH@Need?5torus?5model?5to?5use?5edge_tor@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DB@KODKMINH@Need?5torus?5model?5to?5use?5edge_tor@ DB 'Need torus '
	DB	'model to use edge_torus_area method.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\method1.c
CONST	ENDS
;	COMDAT _q_edge_torus_area
_TEXT	SEGMENT
_uqXvS$ = -120						; size = 8
_area$ = -112						; size = 8
tv136 = -104						; size = 4
_uxJ$ = -100						; size = 96
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_q_edge_torus_area PROC					; COMDAT

; 1400 : { REAL **x;

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 1401 :   REAL area;
; 1402 :   REAL **dx = web.inverse_periods;

	mov	ebx, DWORD PTR _web+1612
	push	esi
	push	edi
	mov	edi, DWORD PTR _e_info$[ebp]

; 1403 :   MAT2D(u,EDGE_VERTS,MAXCOORD); /* affine coordinates of vertices */

	push	6
	push	2
	lea	eax, DWORD PTR _uxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _uqXvS$[ebp]
	push	ecx
	call	_mat2d_setup
	add	esp, 16					; 00000010H
	mov	esi, eax

; 1404 :   int wrap;
; 1405 : 
; 1406 :   if ( !dx )

	test	ebx, ebx
	jne	SHORT $LN3@q_edge_tor@7

; 1407 :      kb_error(2142,"Need torus model to use edge_torus_area method.\n",
; 1408 :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DB@KODKMINH@Need?5torus?5model?5to?5use?5edge_tor@
	push	2142					; 0000085eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN3@q_edge_tor@7:

; 1409 :   if ( web.modeltype == QUADRATIC ) return q_edge_torus_area_q(e_info);

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	SHORT $LN2@q_edge_tor@7
	push	edi
	call	_q_edge_torus_area_q
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1423 : 
; 1424 :   return area*web.torusv;
; 1425 : } // end q_edge_torus_area()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@q_edge_tor@7:

; 1410 :   if ( web.modeltype == LAGRANGE ) 

	cmp	eax, 3
	jne	SHORT $LN1@q_edge_tor@7

; 1411 :      return q_edge_torus_area_lagrange(e_info);

	push	edi
	call	_q_edge_torus_area_lagrange
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1423 : 
; 1424 :   return area*web.torusv;
; 1425 : } // end q_edge_torus_area()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@q_edge_tor@7:

; 1412 : 
; 1413 :   x = e_info->x;
; 1414 : 
; 1415 :   /* get affine coordinates of vertices */
; 1416 :   mat_mul_tr(x,dx,u,EDGE_VERTS,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	push	2
	push	esi
	lea	edx, DWORD PTR [edi+416]
	push	ebx
	push	edx
	call	_mat_mul_tr

; 1417 :   /* main integral over edge */
; 1418 :   area = (u[0][1]+u[1][1])*(u[0][0] - u[1][0])/2;

	mov	ecx, DWORD PTR [esi+4]
	fld	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR [esi]
	fadd	QWORD PTR [eax+8]

; 1419 : 
; 1420 :   /* wrap correction */
; 1421 :   wrap = (get_edge_wrap(e_info->id)>>TWRAPBITS) & WRAPMASK;

	mov	edx, DWORD PTR _web+124
	fld	QWORD PTR [eax]
	mov	eax, DWORD PTR [edi]
	fsub	QWORD PTR [ecx]
	mov	edi, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	fmulp	ST(1), ST(0)
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+edi+784]
	fmul	QWORD PTR __real@3fe0000000000000
	mov	ecx, DWORD PTR [ecx+edx]
	add	esp, 24					; 00000018H
	fstp	QWORD PTR _area$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN10@q_edge_tor@7
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN11@q_edge_tor@7
$LN10@q_edge_tor@7:
	mov	eax, ecx
$LN11@q_edge_tor@7:
	sar	eax, 6
	and	eax, 31					; 0000001fH

; 1422 :   area += WRAPNUM(wrap)*u[1][0];

	cmp	eax, 16					; 00000010H
	jle	SHORT $LN6@q_edge_tor@7
	add	eax, -32				; ffffffe0H
$LN6@q_edge_tor@7:

; 1423 : 
; 1424 :   return area*web.torusv;
; 1425 : } // end q_edge_torus_area()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	DWORD PTR tv136[ebp], eax
	fild	DWORD PTR tv136[ebp]
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	pop	esi
	fmul	QWORD PTR [eax]
	xor	ecx, ebp
	pop	ebx
	fadd	QWORD PTR _area$[ebp]
	fmul	QWORD PTR _web+1600
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_torus_area ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_q_edge_torus_area_grad
; Function compile flags: /Ogtp
;	COMDAT _q_edge_torus_area_grad
_TEXT	SEGMENT
_gqXvS$ = -232						; size = 8
_uqXvS$ = -224						; size = 8
_area$ = -216						; size = 8
_e_info$GSCopy$ = -208					; size = 4
_wrapnum$ = -204					; size = 4
_dx$ = -200						; size = 4
_gxJ$ = -196						; size = 96
_uxJ$ = -100						; size = 96
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_q_edge_torus_area_grad PROC				; COMDAT

; 1435 : { REAL **x;

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1436 :   REAL area;
; 1437 :   REAL **dx = web.inverse_periods;

	mov	eax, DWORD PTR _web+1612
	push	ebx
	mov	ebx, DWORD PTR _e_info$[ebp]
	push	esi
	push	edi

; 1438 :   MAT2D(u,EDGE_VERTS,MAXCOORD); /* affine coordinates of vertices */

	push	6
	push	2
	lea	ecx, DWORD PTR _uxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _uqXvS$[ebp]
	push	edx
	mov	DWORD PTR _e_info$GSCopy$[ebp], ebx
	mov	DWORD PTR _dx$[ebp], eax
	call	_mat2d_setup

; 1439 :   MAT2D(g,EDGE_VERTS,MAXCOORD);

	push	6
	mov	esi, eax
	push	2
	lea	eax, DWORD PTR _gxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gqXvS$[ebp]
	push	ecx
	call	_mat2d_setup
	mov	edi, eax

; 1440 :   int wrap,wrapnum;
; 1441 : 
; 1442 :   if ( web.modeltype == QUADRATIC ) return q_edge_torus_area_q_grad(e_info);

	mov	eax, DWORD PTR _web+628
	add	esp, 32					; 00000020H
	cmp	eax, 2
	jne	SHORT $LN2@q_edge_tor@8
	push	ebx
	call	_q_edge_torus_area_q_grad
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1465 : } // end q_edge_torus_area_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@q_edge_tor@8:

; 1443 :   if ( web.modeltype == LAGRANGE ) 

	cmp	eax, 3
	jne	SHORT $LN1@q_edge_tor@8

; 1444 :      return q_edge_torus_area_lagrange_grad(e_info);

	push	ebx
	call	_q_edge_torus_area_lagrange_grad
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1465 : } // end q_edge_torus_area_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@q_edge_tor@8:

; 1445 : 
; 1446 :   x = e_info->x;
; 1447 : 
; 1448 :   /* get affine coordinates of vertices */
; 1449 :   mat_mul_tr(x,dx,u,EDGE_VERTS,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR _dx$[ebp]
	push	eax
	push	eax
	push	2
	push	esi
	push	edx
	add	ebx, 416				; 000001a0H
	push	ebx
	call	_mat_mul_tr

; 1450 :   /* main integral over edge */
; 1451 :   area = (u[0][1]+u[1][1])*(u[0][0] - u[1][0])/2;

	mov	ecx, DWORD PTR [esi+4]
	fld	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR [esi]
	fadd	QWORD PTR [eax+8]
	add	esp, 24					; 00000018H
	fld	QWORD PTR [eax]

; 1452 :   g[0][0] = (u[1][1] + u[0][1])/2*web.torusv;

	mov	eax, DWORD PTR [edi]
	fsub	QWORD PTR [ecx]

; 1453 :   g[1][0] = -(u[1][1] + u[0][1])/2*web.torusv;

	mov	ecx, DWORD PTR [edi+4]
	fmul	ST(0), ST(1)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _area$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR _web+1600
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR [esi]
	fld	QWORD PTR [edx+8]
	mov	ebx, DWORD PTR [esi+4]
	fadd	QWORD PTR [ebx+8]
	fmul	QWORD PTR __real@bfe0000000000000
	fmul	QWORD PTR _web+1600
	fstp	QWORD PTR [ecx]

; 1454 :   g[0][1] = (u[0][0] - u[1][0])/2*web.torusv;

	mov	edx, DWORD PTR [esi]
	fld	QWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+4]
	fsub	QWORD PTR [ebx]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR _web+1600
	fstp	QWORD PTR [eax+8]

; 1455 :   g[1][1] = (u[0][0] - u[1][0])/2*web.torusv;

	mov	eax, DWORD PTR [esi]
	fld	QWORD PTR [eax]
	mov	edx, DWORD PTR [esi+4]
	fsub	QWORD PTR [edx]

; 1456 : 
; 1457 :   /* wrap correction */
; 1458 :   wrap = (get_edge_wrap(e_info->id)>>TWRAPBITS) & WRAPMASK;

	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR _web+1600
	fstp	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax]
	mov	edx, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ebx+784]
	mov	ecx, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN9@q_edge_tor@8
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN10@q_edge_tor@8
$LN9@q_edge_tor@8:
	mov	eax, ecx
$LN10@q_edge_tor@8:
	sar	eax, 6
	and	eax, 31					; 0000001fH

; 1459 :   wrapnum = WRAPNUM(wrap);

	cmp	eax, 16					; 00000010H
	jle	SHORT $LN5@q_edge_tor@8
	add	eax, -32				; ffffffe0H
$LN5@q_edge_tor@8:
	mov	DWORD PTR _wrapnum$[ebp], eax

; 1460 :   area += wrapnum*u[1][0]; 

	mov	eax, DWORD PTR [esi+4]
	fild	DWORD PTR _wrapnum$[ebp]
	fld	QWORD PTR [eax]

; 1461 :   g[1][0] += wrapnum*web.torusv; 

	mov	eax, DWORD PTR [edi+4]

; 1462 : 
; 1463 :   mat_mult(g,dx,e_info->grad,EDGE_VERTS,SDIM,SDIM);

	mov	ecx, DWORD PTR _e_info$GSCopy$[ebp]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _area$[ebp]
	fstp	QWORD PTR _area$[ebp]
	fmul	QWORD PTR _web+1600
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR [ecx+1336]
	push	eax
	push	eax
	mov	eax, DWORD PTR _dx$[ebp]
	push	2
	push	edx
	push	eax
	push	edi
	call	_mat_mult

; 1464 :   return area*web.torusv;

	fld	QWORD PTR _web+1600

; 1465 : } // end q_edge_torus_area_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fmul	QWORD PTR _area$[ebp]
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_torus_area_grad ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_q_edge_torus_area_hess
EXTRN	_mat4d_setup:PROC
; Function compile flags: /Ogtp
;	COMDAT _q_edge_torus_area_hess
_TEXT	SEGMENT
_hqXvS$ = -1832						; size = 120
_temphqXvS$ = -1712					; size = 24
_uqXvS$ = -1688						; size = 8
_gqXvS$ = -1680						; size = 8
_h$ = -1672						; size = 4
_area$ = -1668						; size = 8
_x$ = -1664						; size = 4
_dx$ = -1660						; size = 4
_g$ = -1656						; size = 4
_e_info$GSCopy$ = -1652					; size = 4
_temph$ = -1648						; size = 4
_i$ = -1644						; size = 4
tv686 = -1640						; size = 4
_wrapnum$ = -1640					; size = 4
_hxJ$ = -1636						; size = 1152
_temphxJ$ = -484					; size = 288
_gxJ$ = -196						; size = 96
_uxJ$ = -100						; size = 96
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_q_edge_torus_area_hess PROC				; COMDAT

; 1476 : { REAL **x;

	push	ebp
	mov	ebp, esp
	sub	esp, 1832				; 00000728H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1477 :   REAL area;
; 1478 :   REAL **dx = web.inverse_periods;

	mov	eax, DWORD PTR _web+1612
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _e_info$[ebp]

; 1479 :   MAT2D(u,EDGE_VERTS,MAXCOORD); /* affine coordinates of vertices */

	push	6
	push	2
	lea	ecx, DWORD PTR _uxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _uqXvS$[ebp]
	push	edx
	mov	DWORD PTR _e_info$GSCopy$[ebp], edi
	mov	DWORD PTR _dx$[ebp], eax
	call	_mat2d_setup

; 1480 :   MAT2D(g,EDGE_VERTS,MAXCOORD);

	push	6
	mov	esi, eax
	push	2
	lea	eax, DWORD PTR _gxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gqXvS$[ebp]
	push	ecx
	call	_mat2d_setup

; 1481 :   MAT4D(h,EDGE_VERTS,EDGE_VERTS,MAXCOORD,MAXCOORD);

	push	6
	push	6
	push	2
	push	2
	lea	edx, DWORD PTR _hxJ$[ebp]
	mov	DWORD PTR _g$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _hqXvS$[ebp]
	push	eax
	call	_mat4d_setup

; 1482 :   MAT2D(temph,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	ecx, DWORD PTR _temphxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temphqXvS$[ebp]
	mov	ebx, eax
	push	edx
	mov	DWORD PTR _h$[ebp], ebx
	call	_mat2d_setup
	mov	DWORD PTR _temph$[ebp], eax

; 1483 :   int i,ii,j,jj,wrap,wrapnum;
; 1484 : 
; 1485 :   if ( web.modeltype == QUADRATIC ) return q_edge_torus_area_q_hess(e_info);

	mov	eax, DWORD PTR _web+628
	add	esp, 72					; 00000048H
	cmp	eax, 2
	jne	SHORT $LN20@q_edge_tor@9
	push	edi
	call	_q_edge_torus_area_q_hess
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1525 :     }
; 1526 : 
; 1527 :   return area*web.torusv;
; 1528 : } // end q_edge_torus_area_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@q_edge_tor@9:

; 1486 :   if ( web.modeltype == LAGRANGE )  

	cmp	eax, 3
	jne	SHORT $LN19@q_edge_tor@9

; 1487 :      return q_edge_torus_area_lagrange_hess(e_info);

	push	edi
	call	_q_edge_torus_area_lagrange_hess
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1525 :     }
; 1526 : 
; 1527 :   return area*web.torusv;
; 1528 : } // end q_edge_torus_area_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@q_edge_tor@9:

; 1488 : 
; 1489 :   x = e_info->x;
; 1490 :   for ( i = 0 ; i < EDGE_VERTS ; i++ )

	fldz
	mov	ecx, DWORD PTR _web+616
	add	edi, 416				; 000001a0H
	mov	DWORD PTR _x$[ebp], edi
	mov	DWORD PTR _i$[ebp], 0
$LN43@q_edge_tor@9:

; 1491 :      for ( ii = 0 ; ii < EDGE_VERTS ; ii++ )

	xor	eax, eax
	mov	DWORD PTR tv686[ebp], eax
$LN44@q_edge_tor@9:

; 1492 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	test	ecx, ecx
	jle	SHORT $LN14@q_edge_tor@9
$LN12@q_edge_tor@9:

; 1493 :             for ( jj = 0 ; jj < SDIM ; jj++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN11@q_edge_tor@9
	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	eax, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [eax+edi*4]
$LN9@q_edge_tor@9:

; 1494 :               h[i][ii][j][jj] = 0.0;

	fst	QWORD PTR [eax]
	mov	ecx, DWORD PTR _web+616
	inc	edx
	add	eax, 8
	cmp	edx, ecx
	jl	SHORT $LN9@q_edge_tor@9

; 1493 :             for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	eax, DWORD PTR tv686[ebp]
$LN11@q_edge_tor@9:

; 1492 :         for ( j = 0 ; j < SDIM ; j++ )

	inc	edi
	cmp	edi, ecx
	jl	SHORT $LN12@q_edge_tor@9
$LN14@q_edge_tor@9:

; 1491 :      for ( ii = 0 ; ii < EDGE_VERTS ; ii++ )

	add	eax, 4
	mov	DWORD PTR tv686[ebp], eax
	cmp	eax, 8
	jl	SHORT $LN44@q_edge_tor@9

; 1488 : 
; 1489 :   x = e_info->x;
; 1490 :   for ( i = 0 ; i < EDGE_VERTS ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, 2
	jl	SHORT $LN43@q_edge_tor@9

; 1495 : 
; 1496 :   /* get affine coordinates of vertices */
; 1497 :   mat_mul_tr(x,dx,u,EDGE_VERTS,SDIM,SDIM);

	mov	edx, DWORD PTR _x$[ebp]
	fstp	ST(0)
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR _dx$[ebp]
	push	2
	push	esi
	push	ecx
	push	edx
	call	_mat_mul_tr

; 1498 :   /* main integral over edge */
; 1499 :   area = (u[0][1]+u[1][1])*(u[0][0] - u[1][0])/2;

	mov	ecx, DWORD PTR [esi]
	fld	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR [esi+4]
	fadd	QWORD PTR [eax+8]
	add	esp, 24					; 00000018H
	fld	QWORD PTR [ecx]

; 1500 :   g[0][0] = (u[1][1] + u[0][1])/2*web.torusv;

	mov	ecx, DWORD PTR _g$[ebp]
	fsub	QWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]

; 1501 :   g[1][0] = -(u[1][1] + u[0][1])/2*web.torusv;

	mov	ecx, DWORD PTR [ecx+4]
	fmul	ST(0), ST(1)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _area$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR _web+1600
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR [esi+4]
	fld	QWORD PTR [edx+8]
	mov	edi, DWORD PTR [esi]
	fadd	QWORD PTR [edi+8]
	fmul	QWORD PTR __real@bfe0000000000000
	fmul	QWORD PTR _web+1600
	fstp	QWORD PTR [ecx]

; 1502 :   g[0][1] = (u[0][0] - u[1][0])/2*web.torusv;

	mov	edx, DWORD PTR [esi]
	fld	QWORD PTR [edx]
	mov	edi, DWORD PTR [esi+4]
	fsub	QWORD PTR [edi]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR _web+1600
	fstp	QWORD PTR [eax+8]

; 1503 :   g[1][1] = (u[0][0] - u[1][0])/2*web.torusv;

	mov	eax, DWORD PTR [esi]
	fld	QWORD PTR [eax]
	mov	edx, DWORD PTR [esi+4]
	fsub	QWORD PTR [edx]

; 1504 :   h[0][1][0][1] += 0.5*web.torusv;

	mov	eax, DWORD PTR [ebx]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR _web+1600
	fstp	QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [eax+4]
	fld	QWORD PTR _web+1600
	mov	edx, DWORD PTR [ecx]

; 1505 :   h[0][0][0][1] += 0.5*web.torusv;

	mov	eax, DWORD PTR [eax]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [edx+8]
	fstp	QWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	fld	QWORD PTR _web+1600

; 1506 :   h[1][1][0][1] -= 0.5*web.torusv;
; 1507 :   h[1][0][0][1] -= 0.5*web.torusv;
; 1508 :   h[0][0][1][0] += 0.5*web.torusv;

	mov	eax, DWORD PTR [eax+4]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [edx+8]
	fstp	QWORD PTR [edx+8]
	mov	edx, DWORD PTR [ebx+4]
	fld	QWORD PTR _web+1600
	mov	edi, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [edi]
	fmul	ST(0), ST(1)
	mov	edx, DWORD PTR [edx]
	fsubr	QWORD PTR [ebx+8]
	fstp	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [edx]
	fld	QWORD PTR _web+1600
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [ebx+8]
	fstp	QWORD PTR [ebx+8]
	fld	QWORD PTR _web+1600
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 1509 :   h[0][1][1][0] -= 0.5*web.torusv;

	fld	QWORD PTR _web+1600
	mov	ecx, DWORD PTR [ecx+4]

; 1510 :   h[1][0][1][0] += 0.5*web.torusv;

	mov	edx, DWORD PTR [edx+4]
	fmul	ST(0), ST(1)

; 1511 :   h[1][1][1][0] -= 0.5*web.torusv;

	mov	edi, DWORD PTR [edi+4]
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	fld	QWORD PTR _web+1600
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	fmul	QWORD PTR _web+1600
	fsubr	QWORD PTR [edi]
	fstp	QWORD PTR [edi]

; 1512 : 
; 1513 :   /* wrap correction */
; 1514 :   wrap = (get_edge_wrap(e_info->id)>>TWRAPBITS) & WRAPMASK;

	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ebx+784]
	mov	ecx, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN27@q_edge_tor@9
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN28@q_edge_tor@9
$LN27@q_edge_tor@9:
	mov	eax, ecx
$LN28@q_edge_tor@9:
	sar	eax, 6
	and	eax, 31					; 0000001fH

; 1515 :   wrapnum = WRAPNUM(wrap);

	cmp	eax, 16					; 00000010H
	jle	SHORT $LN23@q_edge_tor@9
	add	eax, -32				; ffffffe0H
$LN23@q_edge_tor@9:

; 1516 :   area += wrapnum*u[1][0]; 
; 1517 :   g[1][0] += wrapnum*web.torusv; 

	mov	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR _wrapnum$[ebp], eax
	mov	eax, DWORD PTR [esi+4]
	fild	DWORD PTR _wrapnum$[ebp]
	fld	QWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]

; 1518 : 
; 1519 :   /* form pullback */
; 1520 :   mat_mult(g,dx,e_info->grad,EDGE_VERTS,SDIM,SDIM);

	mov	ebx, DWORD PTR _dx$[ebp]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _area$[ebp]
	fstp	QWORD PTR _area$[ebp]
	fmul	QWORD PTR _web+1600
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR [edi+1336]
	push	eax
	push	eax
	push	2
	push	edx
	push	ebx
	push	ecx
	call	_mat_mult
	add	esp, 24					; 00000018H
	xor	edi, edi
	npad	12
$LL41@q_edge_tor@9:

; 1522 :     for ( ii = 0 ; ii < EDGE_VERTS ; ii++ )

	xor	esi, esi
$LL3@q_edge_tor@9:

; 1523 :     { mat_mult(h[i][ii],dx,temph,SDIM,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR [edi+ecx]
	push	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR _temph$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+esi]
	push	ebx
	push	eax
	call	_mat_mult

; 1524 :       tr_mat_mul(dx,temph,e_info->hess[i][ii],SDIM,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	edx, DWORD PTR [ecx+1340]
	push	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR [edi+edx]
	mov	ecx, DWORD PTR [eax+esi]
	mov	edx, DWORD PTR _temph$[ebp]
	push	ecx
	push	edx
	push	ebx
	call	_tr_mat_mul
	add	esi, 4
	add	esp, 48					; 00000030H
	cmp	esi, 8
	jl	SHORT $LL3@q_edge_tor@9

; 1521 :   for ( i = 0 ; i < EDGE_VERTS ; i++ )

	add	edi, 4
	cmp	edi, 8
	jl	SHORT $LL41@q_edge_tor@9

; 1525 :     }
; 1526 : 
; 1527 :   return area*web.torusv;
; 1528 : } // end q_edge_torus_area_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fld	QWORD PTR _web+1600
	fmul	QWORD PTR _area$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_torus_area_hess ENDP
_TEXT	ENDS
PUBLIC	_circular_arc_length_value
EXTRN	_b_extrapolate:PROC
EXTRN	_V_BOUNDARY_ATTR:DWORD
; Function compile flags: /Ogtp
;	COMDAT _circular_arc_length_value
_TEXT	SEGMENT
_dx1$ = -76						; size = 8
_dx2$ = -68						; size = 8
_costh$ = -60						; size = 8
_dy1$ = -52						; size = 8
_dy2$ = -44						; size = 8
_angle$ = -36						; size = 8
_sinth$ = -28						; size = 8
_density$ = -20						; size = 8
_chord$ = -12						; size = 8
_value$ = -12						; size = 8
_mi$ = -4						; size = 4
_v_id$90771 = 8						; size = 4
_e_info$ = 8						; size = 4
_circular_arc_length_value PROC				; COMDAT

; 2755 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx

; 2756 :   REAL value = 0.0;
; 2757 :   REAL dx1,dx2,dy1,dy2,sinth,costh,chord,angle;
; 2758 :   REAL density = 1.0;

	fld1
	push	esi
	fstp	QWORD PTR _density$[ebp]

; 2759 :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	esi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [esi+8]
	cdq
	mov	ebx, eax
	xor	ebx, edx
	sub	ebx, edx
	imul	ebx, 2928				; 00000b70H
	add	ebx, DWORD PTR _meth_inst_list

; 2760 : 
; 2761 :   if ( web.modeltype != QUADRATIC ) 

	cmp	DWORD PTR _web+628, 2
	mov	DWORD PTR _mi$[ebp], ebx
	je	SHORT $LN7@circular_a@4

; 2762 :        return q_edge_tension_value(e_info);

	push	esi
	call	_q_edge_tension_value
	add	esp, 4
	pop	esi
	pop	ebx

; 2797 :   return value;
; 2798 : } // end circular_arc_length_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@circular_a@4:

; 2763 : 
; 2764 :   if ( mi->flags & USE_DENSITY )

	test	DWORD PTR [ebx+140], 536870912		; 20000000H
	je	SHORT $LN12@circular_a@4

; 2765 :       density = get_edge_density(e_info->id);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]
	fstp	QWORD PTR _density$[ebp]
$LN12@circular_a@4:

; 2766 : 
; 2767 :   dx1 = e_info->x[1][0] - e_info->x[0][0];

	mov	eax, DWORD PTR [esi+420]
	mov	ecx, DWORD PTR [esi+416]
	fld	QWORD PTR [eax]
	fsub	QWORD PTR [ecx]

; 2768 :   dy1 = e_info->x[1][1] - e_info->x[0][1];
; 2769 :   dx2 = e_info->x[2][0] - e_info->x[1][0];
; 2770 :   dy2 = e_info->x[2][1] - e_info->x[1][1];
; 2771 :   circular_arc_aux(dx1,dy1,dx2,dy2,&chord,NULL,NULL,&sinth,NULL,
; 2772 :     NULL,&costh,NULL,NULL,&angle,NULL,NULL,METHOD_VALUE);

	push	1767					; 000006e7H
	push	0
	push	0
	fst	QWORD PTR _dx1$[ebp]
	lea	edx, DWORD PTR _sinth$[ebp]
	fld	QWORD PTR [eax+8]
	fsub	QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [esi+424]
	fst	QWORD PTR _dy1$[ebp]
	fld	QWORD PTR [ecx]
	fsub	QWORD PTR [eax]
	fst	QWORD PTR _dx2$[ebp]
	fld	QWORD PTR [ecx+8]
	lea	ecx, DWORD PTR _costh$[ebp]
	fsub	QWORD PTR [eax+8]
	lea	eax, DWORD PTR _angle$[ebp]
	push	eax
	push	0
	push	0
	fst	QWORD PTR _dy2$[ebp]
	push	ecx
	push	0
	push	0
	push	edx
	push	0
	push	0
	lea	eax, DWORD PTR _chord$[ebp]
	push	eax
	sub	esp, 32					; 00000020H
	fstp	QWORD PTR [esp+24]
	fstp	QWORD PTR [esp+16]
	fstp	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	call	_circular_arc_aux

; 2773 : 
; 2774 :   
; 2775 :   if ( chord == 0.0 ) return 0.0;

	fld	QWORD PTR _chord$[ebp]
	add	esp, 84					; 00000054H
	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@circular_a@4
	pop	esi
	fstp	ST(1)
	pop	ebx

; 2797 :   return value;
; 2798 : } // end circular_arc_length_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@circular_a@4:

; 2776 :   if ( sinth == 0.0 ) value = chord;

	fld	QWORD PTR _sinth$[ebp]
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@circular_a@4
	fstp	ST(0)
	fst	QWORD PTR _value$[ebp]

; 2777 :   else 

	jmp	$LN13@circular_a@4
$LN4@circular_a@4:

; 2778 :   { vertex_id v_id = e_info->v[1];
; 2779 :     value = angle*chord/sinth;

	fxch	ST(1)

; 2780 :     /* fix up midpoint to center of arc */
; 2781 :     e_info->x[1][0] = e_info->x[0][0]+(dx1+dx2)/2+(dy1+dy2)/2*sinth/(1+costh);

	mov	ecx, DWORD PTR [esi+416]
	fmul	QWORD PTR _angle$[ebp]
	mov	eax, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi+420]
	mov	DWORD PTR _v_id$90771[ebp], eax
	fdiv	ST(0), ST(1)

; 2782 :     e_info->x[1][1] = e_info->x[0][1]+(dy1+dy2)/2-(dx1+dx2)/2*sinth/(1+costh);
; 2783 :  
; 2784 :     if (get_vattr(v_id) & BOUNDARY )

	and	eax, 134217727				; 07ffffffH
	push	edi
	xor	edi, edi
	fst	QWORD PTR _value$[ebp]
	fld	QWORD PTR _dy2$[ebp]
	fadd	QWORD PTR _dy1$[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fld	QWORD PTR _costh$[ebp]
	fadd	QWORD PTR __real@3ff0000000000000
	fld	QWORD PTR _dx2$[ebp]
	fadd	QWORD PTR _dx1$[ebp]
	fmulp	ST(2), ST(0)
	fld	ST(2)
	fmul	ST(0), ST(5)
	fdiv	ST(0), ST(1)
	fld	QWORD PTR [ecx]
	fadd	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx]
	mov	ecx, DWORD PTR [esi+416]
	fld	QWORD PTR [ecx+8]
	mov	edx, DWORD PTR [esi+420]
	faddp	ST(3), ST(0)
	fxch	ST(1)
	fmulp	ST(4), ST(0)
	fdivp	ST(3), ST(0)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [edx+8]
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 128				; 00000080H
	or	eax, edi
	je	SHORT $LN14@circular_a@4

; 2785 :     { /* update boundary parameter to agree with coordinates */
; 2786 :       b_extrapolate(get_boundary(v_id),get_coord(v_id),e_info->x[1],
; 2787 :          get_coord(v_id),get_param(v_id), get_param(v_id),v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	fstp	ST(0)
	mov	edi, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
	test	eax, eax
	je	SHORT $LN10@circular_a@4
	imul	eax, 240				; 000000f0H
	add	eax, edi
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	eax, DWORD PTR [eax+edx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN11@circular_a@4
$LN10@circular_a@4:
	xor	eax, eax
$LN11@circular_a@4:
	mov	ecx, edx
	mov	edx, DWORD PTR [edi+ebx+544]
	mov	edi, DWORD PTR [edi+ebx+64]
	add	edx, ecx
	add	ecx, edi
	mov	edi, DWORD PTR _v_id$90771[ebp]
	push	edi
	push	edx
	push	edx
	mov	edx, DWORD PTR [esi+420]
	push	ecx
	push	edx
	push	ecx
	push	eax
	call	_b_extrapolate
	fld	QWORD PTR _value$[ebp]
	mov	ebx, DWORD PTR _mi$[ebp]
	add	esp, 28					; 0000001cH
$LN14@circular_a@4:
	pop	edi
$LN13@circular_a@4:

; 2788 :     }
; 2789 :   }
; 2790 : 
; 2791 :   if ( mi->flags & DEFAULT_INSTANCE )

	test	DWORD PTR [ebx+140], 4194304		; 00400000H
	je	SHORT $LN1@circular_a@4

; 2792 :   { binary_tree_add(web.total_area_addends,value);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1000
	call	_binary_tree_add

; 2793 :     set_edge_length(e_info->id,value); 

	fld	QWORD PTR _value$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _web+124
	add	esp, 12					; 0000000cH
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fst	QWORD PTR [edx+48]
$LN1@circular_a@4:

; 2794 :   }
; 2795 : 
; 2796 :   value *= density;

	fmul	QWORD PTR _density$[ebp]
	pop	esi
	pop	ebx

; 2797 :   return value;
; 2798 : } // end circular_arc_length_value()

	mov	esp, ebp
	pop	ebp
	ret	0
_circular_arc_length_value ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_circular_arc_length_all
; Function compile flags: /Ogtp
;	COMDAT _circular_arc_length_all
_TEXT	SEGMENT
tv1284 = -1424						; size = 8
_costh$ = -1424						; size = 8
tv411 = -1416						; size = 8
_sinth$ = -1416						; size = 8
tv403 = -1408						; size = 8
_density$ = -1400					; size = 8
_angle$ = -1392						; size = 8
_chord$ = -1384						; size = 8
_value$ = -1376						; size = 8
_j$ = -1368						; size = 4
_e_info$GSCopy$ = -1364					; size = 4
tv1239 = -1360						; size = 4
tv1237 = -1356						; size = 4
_ii$ = -1352						; size = 4
_ddcosth$ = -1348					; size = 288
_ddsinth$ = -1060					; size = 288
_ddchord$ = -772					; size = 288
_ddangle$ = -484					; size = 288
_dcosth$ = -196						; size = 48
_dsinth$ = -148						; size = 48
_dchord$ = -100						; size = 48
_dangle$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_mode$ = 12						; size = 4
_circular_arc_length_all PROC				; COMDAT

; 2837 : { int i,j,ii,jj;

	push	ebp
	mov	ebp, esp
	sub	esp, 1424				; 00000590H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, DWORD PTR _e_info$[ebp]

; 2838 :   REAL angle,value = 0.0;
; 2839 :   REAL dx1,dx2,dy1,dy2,sinth,costh,chord;
; 2840 :   REAL dchord[3][2];
; 2841 :   REAL dsinth[3][2];
; 2842 :   REAL dcosth[3][2];
; 2843 :   REAL dangle[3][2];
; 2844 :   REAL ddchord[3][2][3][2];
; 2845 :   REAL ddsinth[3][2][3][2];
; 2846 :   REAL ddcosth[3][2][3][2];
; 2847 :   REAL ddangle[3][2][3][2];
; 2848 :   REAL density = 1.0;

	fld1

; 2849 :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	eax, DWORD PTR [ecx+8]
	fstp	QWORD PTR _density$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2850 : 
; 2851 :   if ( web.modeltype != QUADRATIC )

	cmp	DWORD PTR _web+628, 2

; 2884 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	DWORD PTR _e_info$GSCopy$[ebp], ecx
	je	SHORT $LN25@circular_a@5

; 2852 :        return q_edge_tension_gradient(e_info);

	push	ecx
	call	_q_edge_tension_gradient
	add	esp, 4

; 2893 : } /* end circular_arc_length_all */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@circular_a@5:
	push	edi

; 2853 : 
; 2854 :   if ( mi->flags & USE_DENSITY )

	mov	edi, DWORD PTR [eax+140]
	test	edi, 536870912				; 20000000H
	je	SHORT $LN24@circular_a@5

; 2855 :       density = get_edge_density(e_info->id);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	fld	QWORD PTR [eax+40]
	fstp	QWORD PTR _density$[ebp]
$LN24@circular_a@5:

; 2856 : 
; 2857 :   dx1 = e_info->x[1][0] - e_info->x[0][0];
; 2858 :   dy1 = e_info->x[1][1] - e_info->x[0][1];
; 2859 :   dx2 = e_info->x[2][0] - e_info->x[1][0];
; 2860 :   dy2 = e_info->x[2][1] - e_info->x[1][1];
; 2861 :   circular_arc_aux(dx1,dy1,dx2,dy2,&chord,dchord,ddchord,&sinth,dsinth,
; 2862 :   ddsinth,&costh,dcosth,ddcosth,&angle,dangle,ddangle,mode);

	push	ebx
	push	esi
	mov	esi, DWORD PTR _mode$[ebp]
	push	esi
	mov	edx, DWORD PTR [ecx+424]
	mov	eax, DWORD PTR [ecx+420]
	fld	QWORD PTR [edx+8]
	fsub	QWORD PTR [eax+8]
	lea	ebx, DWORD PTR _ddangle$[ebp]
	push	ebx
	lea	ebx, DWORD PTR _dangle$[ebp]
	push	ebx
	lea	ebx, DWORD PTR _angle$[ebp]
	push	ebx
	lea	ebx, DWORD PTR _ddcosth$[ebp]
	push	ebx
	lea	ebx, DWORD PTR _dcosth$[ebp]
	push	ebx
	mov	ecx, DWORD PTR [ecx+416]
	lea	ebx, DWORD PTR _costh$[ebp]
	push	ebx
	lea	ebx, DWORD PTR _ddsinth$[ebp]
	push	ebx
	lea	ebx, DWORD PTR _dsinth$[ebp]
	push	ebx
	lea	ebx, DWORD PTR _sinth$[ebp]
	push	ebx
	lea	ebx, DWORD PTR _ddchord$[ebp]
	push	ebx
	lea	ebx, DWORD PTR _dchord$[ebp]
	push	ebx
	lea	ebx, DWORD PTR _chord$[ebp]
	push	ebx
	sub	esp, 32					; 00000020H
	fstp	QWORD PTR [esp+24]
	fld	QWORD PTR [edx]
	fsub	QWORD PTR [eax]
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR [eax+8]
	fsub	QWORD PTR [ecx+8]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [eax]
	fsub	QWORD PTR [ecx]
	fstp	QWORD PTR [esp]
	call	_circular_arc_aux

; 2863 : 
; 2864 :   if (chord == 0.0) return 0.0;

	fld	QWORD PTR _chord$[ebp]
	add	esp, 84					; 00000054H
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	$LN44@circular_a@5
	fstp	ST(0)

; 2865 :   value = chord*cirf(angle);

	sub	esp, 8
	fld	QWORD PTR _angle$[ebp]
	fstp	QWORD PTR [esp]
	call	_cirf
	fst	QWORD PTR tv403[ebp]
	add	esp, 8
	fmul	QWORD PTR _chord$[ebp]
	fst	QWORD PTR _value$[ebp]

; 2866 : 
; 2867 :   if ( mode == METHOD_VALUE )

	cmp	esi, 1767				; 000006e7H
	jne	SHORT $LN21@circular_a@5

; 2868 :    if ( mi->flags & DEFAULT_INSTANCE )

	test	edi, 4194304				; 00400000H
	je	SHORT $LN21@circular_a@5

; 2869 :      binary_tree_add(web.total_area_addends,value);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1000
	call	_binary_tree_add
	fld	QWORD PTR _value$[ebp]
	add	esp, 12					; 0000000cH
$LN21@circular_a@5:

; 2870 : 
; 2871 :   value *= density;

	fmul	QWORD PTR _density$[ebp]
	fst	QWORD PTR _value$[ebp]

; 2872 :   if ( mode == METHOD_VALUE ) return value;

	cmp	esi, 1767				; 000006e7H
	je	$LN44@circular_a@5

; 2873 : 
; 2874 :   for ( i = 0 ; i < 3 ; i++ )

	mov	ecx, DWORD PTR _web+616
	fstp	ST(0)
	xor	ebx, ebx
	xor	edi, edi
$LL42@circular_a@5:

; 2875 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN18@circular_a@5

; 2876 :       e_info->grad[i][j] = density*(dchord[i][j]*cirf(angle)
; 2877 :           + chord*cirfp(angle)*dangle[i][j]);

	fld	QWORD PTR _angle$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_cirfp
	fmul	QWORD PTR _chord$[ebp]
	add	esp, 8
	fld	QWORD PTR tv403[ebp]
	fld	QWORD PTR _density$[ebp]
$LN16@circular_a@5:
	mov	eax, DWORD PTR _e_info$GSCopy$[ebp]
	lea	ecx, DWORD PTR [edi+esi*8]
	fld	QWORD PTR _dangle$[ebp+ecx]
	mov	ecx, DWORD PTR [eax+1336]
	fmul	ST(0), ST(3)
	lea	edx, DWORD PTR [edi+esi*8]
	fld	QWORD PTR _dchord$[ebp+edx]
	mov	edx, DWORD PTR [ecx+ebx]
	fmul	ST(0), ST(3)
	inc	esi
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx+esi*8-8]
	mov	ecx, DWORD PTR _web+616
	cmp	esi, ecx
	jl	SHORT $LN16@circular_a@5

; 2875 :     for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(0)
$LN18@circular_a@5:

; 2873 : 
; 2874 :   for ( i = 0 ; i < 3 ; i++ )

	add	edi, 16					; 00000010H
	add	ebx, 4
	cmp	edi, 48					; 00000030H
	jl	SHORT $LL42@circular_a@5

; 2878 :  
; 2879 :   if ( mode == METHOD_GRADIENT ) return value;

	cmp	DWORD PTR _mode$[ebp], 4321		; 000010e1H
	je	$LN61@circular_a@5

; 2880 : 
; 2881 :   for ( i = 0 ; i < 3 ; i++ )

	xor	eax, eax
	mov	DWORD PTR tv1237[ebp], eax
	mov	DWORD PTR tv1239[ebp], eax
	npad	2
$LL41@circular_a@5:

; 2882 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	ebx, ebx
	mov	DWORD PTR _j$[ebp], ebx
	test	ecx, ecx
	jle	$LN11@circular_a@5
$LL40@circular_a@5:

; 2883 :       for ( ii = 0 ; ii < 3 ; ii++ )

	xor	edi, edi
	mov	DWORD PTR _ii$[ebp], edi
	npad	8
$LL6@circular_a@5:

; 2884 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	xor	esi, esi
	test	ecx, ecx
	jle	$LN5@circular_a@5

; 2885 :           e_info->hess[i][ii][j][jj] =  density*(
; 2886 :               ddchord[i][j][ii][jj]*cirf(angle)
; 2887 :                 + dchord[i][j]*cirfp(angle)*dangle[ii][jj]
; 2888 :           + dchord[ii][jj]*cirfp(angle)*dangle[i][j]
; 2889 :           + chord*cirfpp(angle)*dangle[ii][jj]*dangle[i][j]
; 2890 :           + chord*cirfp(angle)*ddangle[i][j][ii][jj]);

	fld	QWORD PTR _angle$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_cirfp
	add	ebx, DWORD PTR tv1237[ebp]
	fst	QWORD PTR tv411[ebp]
	fmul	QWORD PTR _dchord$[ebp+ebx*8]
	fstp	QWORD PTR tv1284[ebp]
	fld	QWORD PTR _angle$[ebp]
	fstp	QWORD PTR [esp]
	call	_cirfpp
	fld	QWORD PTR _chord$[ebp]
	mov	ecx, DWORD PTR _ii$[ebp]
	fmul	ST(1), ST(0)
	lea	eax, DWORD PTR [ecx+ebx*2]
	fld	QWORD PTR tv411[ebp]
	add	eax, ebx
	fld	ST(0)
	add	esp, 8
	fmulp	ST(2), ST(0)
	lea	edx, DWORD PTR _dangle$[ebp+ebx*8]
	fld	QWORD PTR tv403[ebp]
	shl	eax, 4
	fld	QWORD PTR _density$[ebp]
	fld	QWORD PTR tv1284[ebp]
$LN3@circular_a@5:
	lea	ebx, DWORD PTR [eax+esi*8]
	fld	QWORD PTR _ddchord$[ebp+ebx]
	lea	ecx, DWORD PTR [edi+esi*8]
	fmul	ST(0), ST(3)
	lea	ecx, DWORD PTR _dangle$[ebp+ecx]
	fld	ST(1)
	lea	ebx, DWORD PTR [edi+esi*8]
	fmul	QWORD PTR [ecx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _dchord$[ebp+ebx]
	mov	ebx, DWORD PTR tv1239[ebp]
	fmul	ST(0), ST(5)
	fmul	QWORD PTR [edx]
	faddp	ST(1), ST(0)
	fld	ST(6)
	fmul	QWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+esi*8]
	inc	esi
	fmul	QWORD PTR [edx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _ddangle$[ebp+ecx]
	mov	ecx, DWORD PTR _e_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ecx+1340]
	fmul	ST(0), ST(6)
	mov	ecx, DWORD PTR [ebx+ecx]
	mov	ebx, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	faddp	ST(1), ST(0)
	mov	ebx, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [ecx+esi*8-8]
	mov	ecx, DWORD PTR _web+616
	cmp	esi, ecx
	jl	SHORT $LN3@circular_a@5

; 2884 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	fstp	ST(3)
	fstp	ST(4)
	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)
$LN5@circular_a@5:

; 2883 :       for ( ii = 0 ; ii < 3 ; ii++ )

	inc	DWORD PTR _ii$[ebp]
	add	edi, 16					; 00000010H
	cmp	edi, 48					; 00000030H
	jl	$LL6@circular_a@5

; 2882 :     for ( j = 0 ; j < SDIM ; j++ )

	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, ecx
	jl	$LL40@circular_a@5
$LN11@circular_a@5:

; 2880 : 
; 2881 :   for ( i = 0 ; i < 3 ; i++ )

	mov	eax, DWORD PTR tv1239[ebp]
	add	DWORD PTR tv1237[ebp], 2
	add	eax, 4
	mov	DWORD PTR tv1239[ebp], eax
	cmp	eax, 12					; 0000000cH
	jl	$LL41@circular_a@5
$LN61@circular_a@5:

; 2891 :  
; 2892 :   return value;

	fld	QWORD PTR _value$[ebp]
$LN44@circular_a@5:

; 2893 : } /* end circular_arc_length_all */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	pop	ebx
	xor	ecx, ebp
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_circular_arc_length_all ENDP
_TEXT	ENDS
PUBLIC	_circular_arc_length_grad
; Function compile flags: /Ogtp
;	COMDAT _circular_arc_length_grad
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_circular_arc_length_grad PROC				; COMDAT

; 2896 : { if ( web.modeltype != QUADRATIC )

	push	ebp
	mov	ebp, esp
	cmp	DWORD PTR _web+628, 2
	je	SHORT $LN1@circular_a@6

; 2899 : } // end circular_arc_length_grad()

	pop	ebp

; 2897 :        return q_edge_tension_gradient(e_info);

	jmp	_q_edge_tension_gradient
$LN1@circular_a@6:

; 2898 :   return circular_arc_length_all(e_info,METHOD_GRADIENT);

	mov	ecx, DWORD PTR _e_info$[ebp]
	push	4321					; 000010e1H
	push	ecx
	call	_circular_arc_length_all
	add	esp, 8

; 2899 : } // end circular_arc_length_grad()

	pop	ebp
	ret	0
_circular_arc_length_grad ENDP
_TEXT	ENDS
PUBLIC	_circular_arc_length_hess
; Function compile flags: /Ogtp
;	COMDAT _circular_arc_length_hess
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_circular_arc_length_hess PROC				; COMDAT

; 2902 : { if ( web.modeltype != QUADRATIC )

	push	ebp
	mov	ebp, esp
	cmp	DWORD PTR _web+628, 2
	je	SHORT $LN1@circular_a@7

; 2905 : } // end circular_arc_length_hess()

	pop	ebp

; 2903 :        return q_edge_tension_hessian(e_info);

	jmp	_q_edge_tension_hessian
$LN1@circular_a@7:

; 2904 :   return circular_arc_length_all(e_info,METHOD_HESSIAN);

	mov	ecx, DWORD PTR _e_info$[ebp]
	push	8763					; 0000223bH
	push	ecx
	call	_circular_arc_length_all
	add	esp, 8

; 2905 : } // end circular_arc_length_hess()

	pop	ebp
	ret	0
_circular_arc_length_hess ENDP
_TEXT	ENDS
PUBLIC	_edge_symmetric_area_all
; Function compile flags: /Ogtp
;	COMDAT _edge_symmetric_area_all
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_mode$ = 12						; size = 4
_edge_symmetric_area_all PROC				; COMDAT

; 2923 : { REAL **x,**g,****h;

	push	ebp
	mov	ebp, esp

; 2924 :   REAL area;
; 2925 : 
; 2926 :   if ( web.torus_flag ) return q_edge_torus_area_hess(e_info);

	cmp	DWORD PTR _web+860, 0
	je	SHORT $LN5@edge_symme
	mov	eax, DWORD PTR _e_info$[ebp]
	push	eax
	call	_q_edge_torus_area_hess
	add	esp, 4

; 2948 : 
; 2949 :   return area;
; 2950 : }

	pop	ebp
	ret	0
$LN5@edge_symme:

; 2927 :   if ( web.modeltype == QUADRATIC ) return q_edge_area_q_hess(e_info);

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	SHORT $LN4@edge_symme
	mov	ecx, DWORD PTR _e_info$[ebp]
	push	ecx
	call	_q_edge_area_q_hess
	add	esp, 4

; 2948 : 
; 2949 :   return area;
; 2950 : }

	pop	ebp
	ret	0
$LN4@edge_symme:

; 2928 :   if ( web.modeltype == LAGRANGE )  return q_edge_area_lagrange_hess(e_info);

	cmp	eax, 3
	jne	SHORT $LN3@edge_symme
	mov	edx, DWORD PTR _e_info$[ebp]
	push	edx
	call	_q_edge_area_lagrange_hess
	add	esp, 4

; 2948 : 
; 2949 :   return area;
; 2950 : }

	pop	ebp
	ret	0
$LN3@edge_symme:

; 2929 : 
; 2930 :   x = e_info->x;

	mov	ecx, DWORD PTR _e_info$[ebp]

; 2931 :   g = e_info->grad;
; 2932 :   h = e_info->hess;
; 2933 : 
; 2934 :   /* main integral over edge */
; 2935 :   area = (x[0][0]*x[1][1] - x[0][1]*x[1][0])/2;

	mov	edx, DWORD PTR [ecx+420]
	mov	eax, DWORD PTR [ecx+416]
	fld	QWORD PTR [edx+8]
	fmul	QWORD PTR [eax]
	push	ebx
	fld	QWORD PTR [eax+8]

; 2936 :   if ( mode == METHOD_VALUE ) return area;

	mov	ebx, DWORD PTR _mode$[ebp]
	fmul	QWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR [ecx+1336]
	push	edi
	mov	edi, DWORD PTR [ecx+1340]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	cmp	ebx, 1767				; 000006e7H
	je	SHORT $LN17@edge_symme

; 2937 : 
; 2938 :   g[0][0] = x[1][1]/2;

	mov	ecx, edx
	fld	QWORD PTR [ecx+8]
	mov	edx, DWORD PTR [esi]

; 2939 :   g[1][0] = -x[0][1]/2;

	mov	esi, DWORD PTR [esi+4]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	fld	QWORD PTR [eax+8]
	fld	QWORD PTR __real@bfe0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [esi]

; 2940 :   g[0][1] = -x[1][0]/2;

	fmul	QWORD PTR [ecx]
	fstp	QWORD PTR [edx+8]

; 2941 :   g[1][1] = x[0][0]/2;

	fld	QWORD PTR [eax]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi+8]

; 2942 :   if ( mode == METHOD_GRADIENT ) return area;

	cmp	ebx, 4321				; 000010e1H
	jne	SHORT $LN1@edge_symme
$LN17@edge_symme:
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx

; 2948 : 
; 2949 :   return area;
; 2950 : }

	pop	ebp
	ret	0
$LN1@edge_symme:

; 2943 : 
; 2944 :   h[0][1][0][1] += 0.5;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	fld	QWORD PTR [ecx+8]

; 2945 :   h[1][0][0][1] -= 0.5;
; 2946 :   h[0][1][1][0] -= 0.5;

	mov	eax, DWORD PTR [eax+4]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	fld	QWORD PTR [edx+8]

; 2947 :   h[1][0][1][0] += 0.5;

	mov	ecx, DWORD PTR [ecx+4]
	fsub	ST(0), ST(1)
	pop	edi
	pop	esi
	pop	ebx
	fstp	QWORD PTR [edx+8]
	fld	QWORD PTR [eax]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax]
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]

; 2948 : 
; 2949 :   return area;
; 2950 : }

	pop	ebp
	ret	0
_edge_symmetric_area_all ENDP
_TEXT	ENDS
PUBLIC	_spherical_arc_length_value
; Function compile flags: /Ogtp
;	COMDAT _spherical_arc_length_value
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_spherical_arc_length_value PROC			; COMDAT

; 3327 : { if ( web.modeltype != LINEAR )

	push	ebp
	mov	ebp, esp
	cmp	DWORD PTR _web+628, 1
	je	SHORT $LN1@spherical_@10

; 3330 : }

	pop	ebp

; 3328 :        return q_edge_tension_gradient(e_info);

	jmp	_q_edge_tension_gradient
$LN1@spherical_@10:

; 3329 :   return spherical_arc_length_all(e_info,METHOD_VALUE);

	mov	ecx, DWORD PTR _e_info$[ebp]
	push	1767					; 000006e7H
	push	ecx
	call	_spherical_arc_length_all
	add	esp, 8

; 3330 : }

	pop	ebp
	ret	0
_spherical_arc_length_value ENDP
_TEXT	ENDS
PUBLIC	_spherical_arc_length_grad
; Function compile flags: /Ogtp
;	COMDAT _spherical_arc_length_grad
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_spherical_arc_length_grad PROC				; COMDAT

; 3334 : { if ( web.modeltype != LINEAR )

	push	ebp
	mov	ebp, esp
	cmp	DWORD PTR _web+628, 1
	je	SHORT $LN1@spherical_@11

; 3337 : }

	pop	ebp

; 3335 :        return q_edge_tension_gradient(e_info);

	jmp	_q_edge_tension_gradient
$LN1@spherical_@11:

; 3336 :   return spherical_arc_length_all(e_info,METHOD_GRADIENT);

	mov	ecx, DWORD PTR _e_info$[ebp]
	push	4321					; 000010e1H
	push	ecx
	call	_spherical_arc_length_all
	add	esp, 8

; 3337 : }

	pop	ebp
	ret	0
_spherical_arc_length_grad ENDP
_TEXT	ENDS
PUBLIC	_spherical_arc_length_hess
; Function compile flags: /Ogtp
;	COMDAT _spherical_arc_length_hess
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_spherical_arc_length_hess PROC				; COMDAT

; 3341 : { if ( web.modeltype != LINEAR )

	push	ebp
	mov	ebp, esp
	cmp	DWORD PTR _web+628, 1
	je	SHORT $LN1@spherical_@12

; 3344 : }

	pop	ebp

; 3342 :        return q_edge_tension_hessian(e_info);

	jmp	_q_edge_tension_hessian
$LN1@spherical_@12:

; 3343 :   return spherical_arc_length_all(e_info,METHOD_HESSIAN);

	mov	ecx, DWORD PTR _e_info$[ebp]
	push	8763					; 0000223bH
	push	ecx
	call	_spherical_arc_length_all
	add	esp, 8

; 3344 : }

	pop	ebp
	ret	0
_spherical_arc_length_hess ENDP
_TEXT	ENDS
PUBLIC	_null_length_value
; Function compile flags: /Ogtp
;	COMDAT _null_length_value
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_null_length_value PROC					; COMDAT

; 20   : { q_edge_tension_value(e_info);

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_info$[ebp]
	push	eax
	call	_q_edge_tension_value
	fstp	ST(0)

; 21   :   return 0.0;

	fldz
	add	esp, 4

; 22   : }

	pop	ebp
	ret	0
_null_length_value ENDP
_TEXT	ENDS
PUBLIC	_q_edge_area
; Function compile flags: /Ogtp
;	COMDAT _q_edge_area
_TEXT	SEGMENT
_fe_id$89783 = -8					; size = 4
_b_id$89781 = -4					; size = 4
_fe$89784 = 8						; size = 4
_e_info$ = 8						; size = 4
_q_edge_area PROC					; COMDAT

; 1078 : { REAL **x;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 1079 :   REAL area;
; 1080 :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	esi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [esi+8]
	push	edi
	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
	imul	edi, 2928				; 00000b70H
	add	edi, DWORD PTR _meth_inst_list

; 1081 : 
; 1082 :   if ( web.torus_flag ) area = q_edge_torus_area(e_info);

	cmp	DWORD PTR _web+860, 0
	je	SHORT $LN12@q_edge_are@7
	push	esi
	call	_q_edge_torus_area
	add	esp, 4
	jmp	SHORT $LN7@q_edge_are@7
$LN12@q_edge_are@7:

; 1083 :   else if ( web.modeltype == QUADRATIC ) area = q_edge_area_q(e_info);

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	SHORT $LN10@q_edge_are@7
	push	esi
	call	_q_edge_area_q
	add	esp, 4
	jmp	SHORT $LN7@q_edge_are@7
$LN10@q_edge_are@7:

; 1084 :   else if ( web.modeltype == LAGRANGE )  area = q_edge_area_lagrange(e_info);

	cmp	eax, 3
	jne	SHORT $LN8@q_edge_are@7
	push	esi
	call	_q_edge_area_lagrange
	add	esp, 4

; 1085 :   else 

	jmp	SHORT $LN7@q_edge_are@7
$LN8@q_edge_are@7:

; 1086 :   { x = e_info->x;
; 1087 : 
; 1088 :     /* main integral over edge */
; 1089 :     area = (x[0][1]+x[1][1])*(x[0][0] - x[1][0])/2;

	mov	ecx, DWORD PTR [esi+420]
	mov	eax, DWORD PTR [esi+416]
	fld	QWORD PTR [ecx+8]
	fadd	QWORD PTR [eax+8]
	fld	QWORD PTR [eax]
	fsub	QWORD PTR [ecx]
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fe0000000000000
$LN7@q_edge_are@7:

; 1090 :   }
; 1091 : 
; 1092 :   if ( mi->flags & DEFAULT_INSTANCE )

	test	DWORD PTR [edi+140], 4194304		; 00400000H
	je	$LN3@q_edge_are@7

; 1093 :   { /* add to facet area */
; 1094 :     body_id b_id,bb_id;
; 1095 :     facetedge_id fe_id = get_edge_fe(e_info->id);

	mov	esi, DWORD PTR [esi]
	mov	ecx, DWORD PTR _web+124
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN19@q_edge_are@7
$LN20@q_edge_are@7:
	mov	eax, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN19@q_edge_are@7
	xor	eax, 134217728				; 08000000H
$LN19@q_edge_are@7:

; 1096 :     facetedge_id fe;
; 1097 :     facet_id f_id;
; 1098 : 
; 1099 :     b_id = GEN_QUANT(mi->quants[0])->b_id;

	mov	edx, DWORD PTR [edi+152]
	mov	ecx, DWORD PTR _gen_quant_list
	imul	edx, 368				; 00000170H
	mov	edx, DWORD PTR [edx+ecx+216]

; 1100 :     fe = fe_id;

	mov	ecx, DWORD PTR _web+460
	mov	esi, DWORD PTR _web+328
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR _b_id$89781[ebp], edx
	mov	edx, DWORD PTR _web+236
	mov	DWORD PTR _fe_id$89783[ebp], eax
	mov	DWORD PTR _fe$89784[ebp], eax
	push	ebx
$LN5@q_edge_are@7:

; 1101 :     do
; 1102 :     { f_id = get_fe_facet(fe);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN24@q_edge_are@7
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN23@q_edge_are@7
$LN24@q_edge_are@7:
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN23@q_edge_are@7
	xor	ecx, 134217728				; 08000000H
$LN23@q_edge_are@7:

; 1103 :       bb_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN30@q_edge_are@7
	xor	eax, eax
	jmp	SHORT $LN27@q_edge_are@7
$LN30@q_edge_are@7:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN29@q_edge_are@7
	xor	eax, eax
	jmp	SHORT $LN27@q_edge_are@7
$LN29@q_edge_are@7:
	mov	ebx, DWORD PTR [esi+edi+784]
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN28@q_edge_are@7
	mov	eax, DWORD PTR [eax+ebx+4]
	jmp	SHORT $LN27@q_edge_are@7
$LN28@q_edge_are@7:
	mov	eax, DWORD PTR [eax+ebx]
$LN27@q_edge_are@7:

; 1104 :       if ( equal_id(b_id,bb_id) )

	cmp	DWORD PTR _b_id$89781[ebp], eax
	jne	SHORT $LN46@q_edge_are@7

; 1105 :          add_facet_area(f_id,area);

	fld	ST(0)
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN16@q_edge_are@7
	fchs
$LN16@q_edge_are@7:
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	fadd	QWORD PTR [eax+40]
	fstp	QWORD PTR [eax+40]
	mov	esi, DWORD PTR _web+328
	mov	edx, DWORD PTR _web+236
	mov	edi, DWORD PTR _dymem
$LN46@q_edge_are@7:

; 1106 :       bb_id = get_facet_body(inverse_id(f_id));

	mov	eax, ecx
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN36@q_edge_are@7
	xor	eax, eax
	jmp	SHORT $LN33@q_edge_are@7
$LN36@q_edge_are@7:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN35@q_edge_are@7
	xor	eax, eax
	jmp	SHORT $LN33@q_edge_are@7
$LN35@q_edge_are@7:
	mov	ebx, DWORD PTR [esi+edi+784]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN34@q_edge_are@7
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ebx+4]
	jmp	SHORT $LN33@q_edge_are@7
$LN34@q_edge_are@7:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ebx]
$LN33@q_edge_are@7:

; 1107 :       if ( equal_id(b_id,bb_id) )

	cmp	DWORD PTR _b_id$89781[ebp], eax
	jne	SHORT $LN47@q_edge_are@7

; 1108 :          add_facet_area(f_id,area);

	fld	ST(0)
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN18@q_edge_are@7
	fchs
$LN18@q_edge_are@7:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	fadd	QWORD PTR [ecx+40]
	fstp	QWORD PTR [ecx+40]
	mov	esi, DWORD PTR _web+328
	mov	edx, DWORD PTR _web+236
	mov	edi, DWORD PTR _dymem
$LN47@q_edge_are@7:

; 1109 :       fe = get_next_facet(fe);

	mov	eax, DWORD PTR _fe$89784[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN40@q_edge_are@7
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN108@q_edge_are@7
$LN40@q_edge_are@7:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+40]
$LN108@q_edge_are@7:
	mov	DWORD PTR _fe$89784[ebp], eax

; 1110 :     } while ( !equal_id(fe,fe_id) );

	cmp	eax, DWORD PTR _fe_id$89783[ebp]
	jne	$LN5@q_edge_are@7
	pop	ebx
$LN3@q_edge_are@7:
	pop	edi
	pop	esi

; 1111 :   }
; 1112 : 
; 1113 :   return area;
; 1114 : } // end q_edge_area()

	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_area ENDP
_TEXT	ENDS
PUBLIC	_q_edge_area_grad
; Function compile flags: /Ogtp
;	COMDAT _q_edge_area_grad
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_q_edge_area_grad PROC					; COMDAT

; 1124 : { REAL **x,**g;

	push	ebp
	mov	ebp, esp

; 1125 :   REAL area;
; 1126 : 
; 1127 :   if ( web.torus_flag ) return q_edge_torus_area_grad(e_info);

	cmp	DWORD PTR _web+860, 0
	je	SHORT $LN3@q_edge_are@8

; 1140 :   return area;
; 1141 : } // end q_edge_area_grad()

	pop	ebp

; 1125 :   REAL area;
; 1126 : 
; 1127 :   if ( web.torus_flag ) return q_edge_torus_area_grad(e_info);

	jmp	_q_edge_torus_area_grad
$LN3@q_edge_are@8:

; 1128 :   if ( web.modeltype == QUADRATIC ) return q_edge_area_q_grad(e_info);

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	SHORT $LN2@q_edge_are@8

; 1140 :   return area;
; 1141 : } // end q_edge_area_grad()

	pop	ebp

; 1128 :   if ( web.modeltype == QUADRATIC ) return q_edge_area_q_grad(e_info);

	jmp	_q_edge_area_q_grad
$LN2@q_edge_are@8:

; 1129 :   if ( web.modeltype == LAGRANGE ) return q_edge_area_lagrange_grad(e_info);

	cmp	eax, 3
	jne	SHORT $LN1@q_edge_are@8

; 1140 :   return area;
; 1141 : } // end q_edge_area_grad()

	pop	ebp

; 1129 :   if ( web.modeltype == LAGRANGE ) return q_edge_area_lagrange_grad(e_info);

	jmp	_q_edge_area_lagrange_grad
$LN1@q_edge_are@8:

; 1130 : 
; 1131 :   x = e_info->x;

	mov	ecx, DWORD PTR _e_info$[ebp]

; 1132 :   g = e_info->grad;

	mov	edx, DWORD PTR [ecx+1336]

; 1133 : 
; 1134 :   /* main integral over edge */
; 1135 :   area = (x[0][1]+x[1][1])*(x[0][0] - x[1][0])/2;

	mov	eax, DWORD PTR [ecx+420]
	mov	ecx, DWORD PTR [ecx+416]
	fld	QWORD PTR [eax+8]
	fadd	QWORD PTR [ecx+8]
	push	esi
	fld	QWORD PTR [ecx]

; 1136 :   g[0][0] = (x[1][1] + x[0][1])/2;

	mov	esi, DWORD PTR [edx]
	fsub	QWORD PTR [eax]

; 1137 :   g[1][0] = -(x[1][1] + x[0][1])/2;

	mov	edx, DWORD PTR [edx+4]
	fmul	ST(0), ST(1)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fmul	ST(2), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR [esi]
	fld	QWORD PTR [eax+8]
	fadd	QWORD PTR [ecx+8]
	fmul	QWORD PTR __real@bfe0000000000000
	fstp	QWORD PTR [edx]

; 1138 :   g[0][1] = (x[0][0] - x[1][0])/2;

	fld	QWORD PTR [ecx]
	fsub	QWORD PTR [eax]
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [esi+8]
	pop	esi

; 1139 :   g[1][1] = (x[0][0] - x[1][0])/2;

	fld	QWORD PTR [ecx]
	fsub	QWORD PTR [eax]
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [edx+8]

; 1140 :   return area;
; 1141 : } // end q_edge_area_grad()

	pop	ebp
	ret	0
_q_edge_area_grad ENDP
_TEXT	ENDS
PUBLIC	_q_edge_area_hess
; Function compile flags: /Ogtp
;	COMDAT _q_edge_area_hess
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_q_edge_area_hess PROC					; COMDAT

; 1152 : { REAL **x,**g,****h;

	push	ebp
	mov	ebp, esp

; 1153 :   REAL area;
; 1154 : 
; 1155 :   if ( web.torus_flag ) return q_edge_torus_area_hess(e_info);

	cmp	DWORD PTR _web+860, 0
	je	SHORT $LN3@q_edge_are@9

; 1177 : 
; 1178 :   return area;
; 1179 : } // end q_edge_area_hess()

	pop	ebp

; 1153 :   REAL area;
; 1154 : 
; 1155 :   if ( web.torus_flag ) return q_edge_torus_area_hess(e_info);

	jmp	_q_edge_torus_area_hess
$LN3@q_edge_are@9:

; 1156 :   if ( web.modeltype == QUADRATIC ) return q_edge_area_q_hess(e_info);

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	SHORT $LN2@q_edge_are@9

; 1177 : 
; 1178 :   return area;
; 1179 : } // end q_edge_area_hess()

	pop	ebp

; 1156 :   if ( web.modeltype == QUADRATIC ) return q_edge_area_q_hess(e_info);

	jmp	_q_edge_area_q_hess
$LN2@q_edge_are@9:

; 1157 :   if ( web.modeltype == LAGRANGE )  return q_edge_area_lagrange_hess(e_info);

	cmp	eax, 3
	jne	SHORT $LN1@q_edge_are@9

; 1177 : 
; 1178 :   return area;
; 1179 : } // end q_edge_area_hess()

	pop	ebp

; 1157 :   if ( web.modeltype == LAGRANGE )  return q_edge_area_lagrange_hess(e_info);

	jmp	_q_edge_area_lagrange_hess
$LN1@q_edge_are@9:

; 1158 : 
; 1159 :   x = e_info->x;

	mov	ecx, DWORD PTR _e_info$[ebp]

; 1160 :   g = e_info->grad;

	mov	edx, DWORD PTR [ecx+1336]

; 1161 :   h = e_info->hess;
; 1162 : 
; 1163 :   /* main integral over edge */
; 1164 :   area = (x[0][1]+x[1][1])*(x[0][0] - x[1][0])/2;

	mov	eax, DWORD PTR [ecx+420]
	fld	QWORD PTR [eax+8]
	push	esi
	mov	esi, DWORD PTR [ecx+1340]
	mov	ecx, DWORD PTR [ecx+416]
	fadd	QWORD PTR [ecx+8]
	push	edi
	fld	QWORD PTR [ecx]

; 1165 :   g[0][0] = (x[1][1] + x[0][1])/2;

	mov	edi, DWORD PTR [edx]
	fsub	QWORD PTR [eax]

; 1166 :   g[1][0] = -(x[1][1] + x[0][1])/2;

	mov	edx, DWORD PTR [edx+4]
	fmul	ST(0), ST(1)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fmul	ST(2), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR [edi]
	fld	QWORD PTR [eax+8]
	fadd	QWORD PTR [ecx+8]
	fmul	QWORD PTR __real@bfe0000000000000
	fstp	QWORD PTR [edx]

; 1167 :   g[0][1] = (x[0][0] - x[1][0])/2;

	fld	QWORD PTR [ecx]
	fsub	QWORD PTR [eax]
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [edi+8]

; 1168 :   g[1][1] = (x[0][0] - x[1][0])/2;

	fld	QWORD PTR [ecx]
	fsub	QWORD PTR [eax]

; 1169 :   h[0][1][0][1] += 0.5;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]

; 1170 :   h[0][0][0][1] += 0.5;

	mov	eax, DWORD PTR [eax]
	fmul	ST(0), ST(2)

; 1171 :   h[1][1][0][1] -= 0.5;

	mov	esi, DWORD PTR [esi+4]
	fstp	QWORD PTR [edx+8]
	mov	edx, DWORD PTR [ecx]
	fld	QWORD PTR [edx+8]

; 1172 :   h[1][0][0][1] -= 0.5;
; 1173 :   h[0][0][1][0] += 0.5;
; 1174 :   h[0][1][1][0] -= 0.5;

	mov	ecx, DWORD PTR [ecx+4]
	fadd	ST(0), ST(2)
	fstp	QWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	fld	QWORD PTR [edx+8]
	mov	eax, DWORD PTR [eax+4]
	fadd	ST(0), ST(2)
	fstp	QWORD PTR [edx+8]
	mov	edx, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [edx]
	fld	QWORD PTR [edi+8]
	mov	esi, DWORD PTR [esi]
	fsub	ST(0), ST(2)

; 1175 :   h[1][0][1][0] += 0.5;
; 1176 :   h[1][1][1][0] -= 0.5;

	mov	edx, DWORD PTR [edx+4]
	fstp	QWORD PTR [edi+8]
	mov	edi, DWORD PTR [esi]
	fld	QWORD PTR [edi+8]
	mov	esi, DWORD PTR [esi+4]
	fsub	ST(0), ST(2)
	fstp	QWORD PTR [edi+8]
	pop	edi
	fld	QWORD PTR [eax]
	fadd	ST(0), ST(2)
	fstp	QWORD PTR [eax]
	fld	QWORD PTR [ecx]
	fsub	ST(0), ST(2)
	fstp	QWORD PTR [ecx]
	fld	QWORD PTR [esi]
	fadd	ST(0), ST(2)
	fstp	QWORD PTR [esi]
	pop	esi
	fld	QWORD PTR [edx]
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [edx]

; 1177 : 
; 1178 :   return area;
; 1179 : } // end q_edge_area_hess()

	pop	ebp
	ret	0
_q_edge_area_hess ENDP
_TEXT	ENDS
PUBLIC	_e_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_circular_arc_area_all
; Function compile flags: /Ogtp
;	COMDAT _circular_arc_area_all
_TEXT	SEGMENT
_uqXvS$ = -4176						; size = 12
_gqXvS$90956 = -4164					; size = 12
tv1317 = -4160						; size = 8
_costh$ = -4160						; size = 8
tv1316 = -4152						; size = 8
_dx1$ = -4152						; size = 8
_value$ = -4144						; size = 8
tv1106 = -4136						; size = 8
_sinth$ = -4136						; size = 8
tv1593 = -4128						; size = 8
tv1108 = -4128						; size = 8
_e_info$GSCopy$ = -4120					; size = 4
_angle$ = -4116						; size = 8
tv2740 = -4112						; size = 4
_chord$ = -4108						; size = 8
tv2785 = -4104						; size = 4
_dx2$ = -4100						; size = 8
tv2420 = -4096						; size = 4
_h$90978 = -4096					; size = 4
tv2843 = -4092						; size = 4
_i$ = -4092						; size = 4
_wrap$ = -4092						; size = 4
tv2975 = -4088						; size = 4
tv283 = -4088						; size = 4
tv184 = -4088						; size = 4
_temph$90974 = -4088					; size = 4
_hxJ$90977 = -4084					; size = 2592
_ddchord$ = -1492					; size = 288
_uxJ$ = -1204						; size = 144
_temphxJ$90973 = -1060					; size = 288
_ddsinth$ = -1060					; size = 288
_ddangle$ = -772					; size = 288
_ddcosth$ = -484					; size = 288
_hqXvS$90976 = -460					; size = 264
_gxJ$90957 = -340					; size = 144
_dsinth$ = -196						; size = 48
_dcosth$ = -148						; size = 48
_temphqXvS$90972 = -124					; size = 24
_dchord$ = -100						; size = 48
_dangle$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_info$ = 8						; size = 4
_mode$ = 12						; size = 4
_circular_arc_area_all PROC				; COMDAT

; 3025 : { int i,j,ii,jj;

	push	ebp
	mov	ebp, esp
	mov	eax, 4176				; 00001050H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	edi, DWORD PTR _e_info$[ebp]

; 3026 :   REAL value = 0.0;
; 3027 :   REAL dx1,dx2,dy1,dy2,sinth,chord,costh,angle;
; 3028 :   REAL dsinth[3][2],dchord[3][2],dangle[3][2],dcosth[3][2];
; 3029 :   REAL ddsinth[3][2][3][2],ddchord[3][2][3][2],ddangle[3][2][3][2];
; 3030 :   REAL ddcosth[3][2][3][2];
; 3031 :   int wrap=0;
; 3032 :   MAT2D(u,EDGE_CTRL,MAXCOORD); /* affine coordinates of vertices */

	push	6
	push	3
	lea	eax, DWORD PTR _uxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _uqXvS$[ebp]
	push	ecx

; 3151 :      for ( jj = 0 ; jj < 2 ; jj++ )

	mov	DWORD PTR _e_info$GSCopy$[ebp], edi
	mov	DWORD PTR _wrap$[ebp], 0
	call	_mat2d_setup
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _web+628, 2
	mov	esi, eax
	je	SHORT $LN54@circular_a@8

; 3033 : 
; 3034 :   if ( web.modeltype != QUADRATIC )
; 3035 :        return q_edge_area_grad(e_info);

	push	edi
	call	_q_edge_area_grad
	add	esp, 4
	pop	edi
	pop	esi

; 3161 : } /* end circular_arc_area_all() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@circular_a@8:

; 3036 : 
; 3037 :   dx1 = e_info->x[1][0] - e_info->x[0][0];

	mov	eax, DWORD PTR [edi+420]
	mov	ecx, DWORD PTR [edi+416]
	fld	QWORD PTR [eax]
	fsub	QWORD PTR [ecx]

; 3038 :   dy1 = e_info->x[1][1] - e_info->x[0][1];
; 3039 :   dx2 = e_info->x[2][0] - e_info->x[1][0];

	mov	edx, DWORD PTR [edi+424]
	push	ebx
	lea	ebx, DWORD PTR [edi+416]
	fst	QWORD PTR _dx1$[ebp]
	fld	QWORD PTR [edx]

; 3040 :   dy2 = e_info->x[2][1] - e_info->x[1][1];
; 3041 :   circular_arc_aux(dx1,dy1,dx2,dy2,&chord,dchord,ddchord,&sinth,dsinth,
; 3042 :     ddsinth,&costh,dcosth,ddcosth,&angle,dangle,ddangle,mode);

	mov	edx, DWORD PTR _mode$[ebp]
	push	edx
	fsub	QWORD PTR [eax]
	lea	edx, DWORD PTR _ddangle$[ebp]
	push	edx
	lea	edx, DWORD PTR _dangle$[ebp]
	fst	QWORD PTR _dx2$[ebp]
	push	edx
	lea	edx, DWORD PTR _angle$[ebp]
	push	edx
	lea	edx, DWORD PTR _ddcosth$[ebp]
	push	edx
	lea	edx, DWORD PTR _dcosth$[ebp]
	push	edx
	lea	edx, DWORD PTR _costh$[ebp]
	push	edx
	lea	edx, DWORD PTR _ddsinth$[ebp]
	push	edx
	lea	edx, DWORD PTR _dsinth$[ebp]
	push	edx
	lea	edx, DWORD PTR _sinth$[ebp]
	push	edx
	lea	edx, DWORD PTR _ddchord$[ebp]
	push	edx
	lea	edx, DWORD PTR _dchord$[ebp]
	push	edx
	lea	edx, DWORD PTR _chord$[ebp]
	push	edx
	mov	edx, DWORD PTR [edi+424]
	fld	QWORD PTR [edx+8]
	sub	esp, 32					; 00000020H
	fsub	QWORD PTR [eax+8]
	fstp	QWORD PTR [esp+24]
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR [eax+8]
	fsub	QWORD PTR [ecx+8]
	fstp	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	call	_circular_arc_aux

; 3043 : 
; 3044 :   if (chord == 0.0) return 0.0;

	fld	QWORD PTR _chord$[ebp]
	add	esp, 84					; 00000054H
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	$LN98@circular_a@8

; 3045 : 
; 3046 :   if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	fstp	ST(0)
	je	$LN52@circular_a@8

; 3047 :   { wrap = (get_edge_wrap(e_info->id)>>TWRAPBITS) & WRAPMASK;

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	test	DWORD PTR [edi], 134217728		; 08000000H
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]
	je	SHORT $LN63@circular_a@8
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN63@circular_a@8:

; 3048 :     /* get affine coordinates of vertices */
; 3049 :     mat_mul_tr(e_info->x,web.inverse_periods,u,edge_ctrl,SDIM,SDIM);

	mov	ecx, DWORD PTR _edge_ctrl
	mov	edx, DWORD PTR _web+1612
	sar	eax, 6
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _wrap$[ebp], eax
	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	push	ecx
	push	esi
	push	edx
	push	ebx
	call	_mat_mul_tr

; 3050 :     value = chord*chord/4*caf(angle)
; 3051 :              + web.torusv*(u[0][1]+u[2][1])*(u[0][0] - u[2][0])/2;

	fld	QWORD PTR _angle$[ebp]
	add	esp, 16					; 00000010H
	fstp	QWORD PTR [esp]
	call	_caf
	mov	ecx, DWORD PTR [esi]
	fst	QWORD PTR tv1106[ebp]
	fld	QWORD PTR _chord$[ebp]
	mov	eax, DWORD PTR [esi+8]
	fmul	ST(0), ST(0)
	add	esp, 8
	fmul	QWORD PTR __real@3fd0000000000000
	fst	QWORD PTR tv1108[ebp]
	fld	QWORD PTR [ecx+8]
	fadd	QWORD PTR [eax+8]
	fld	QWORD PTR _web+1600
	fmul	ST(1), ST(0)
	fld	QWORD PTR [ecx]
	fsub	QWORD PTR [eax]

; 3052 :     if ( wrap )

	mov	eax, DWORD PTR _wrap$[ebp]
	fmulp	ST(2), ST(0)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(2), ST(0)
	fxch	ST(3)
	fmulp	ST(4), ST(0)
	fxch	ST(1)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fst	QWORD PTR _value$[ebp]
	test	eax, eax
	je	$LN103@circular_a@8

; 3053 :     { /* wrap correction */
; 3054 :       value += WRAPNUM(wrap)*u[2][0]*web.torusv;

	cmp	eax, 16					; 00000010H
	jle	SHORT $LN57@circular_a@8
	add	eax, -32				; ffffffe0H
$LN57@circular_a@8:
	mov	DWORD PTR tv184[ebp], eax
	fild	DWORD PTR tv184[ebp]
	mov	eax, DWORD PTR [esi+8]
	fmul	QWORD PTR [eax]
$LN171@circular_a@8:

; 3056 :   }
; 3057 :   else if ( web.symmetric_content )
; 3058 :   { value = chord*chord/4*caf(angle)
; 3059 :       + (e_info->x[0][0]*e_info->x[2][1]-e_info->x[0][1]*e_info->x[2][0])/2;

	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fxch	ST(1)
$LN167@circular_a@8:

; 3062 :   { value = chord*chord/4*caf(angle)
; 3063 :             - (dx1+dx2)*(e_info->x[2][1]+e_info->x[0][1])/2;

	fst	QWORD PTR _value$[ebp]
	fxch	ST(1)
$LN89@circular_a@8:

; 3064 :   }
; 3065 : 
; 3066 : 
; 3067 :   if ( mode == METHOD_VALUE ) return value;

	cmp	DWORD PTR _mode$[ebp], 1767		; 000006e7H
	jne	$LN111@circular_a@8
	pop	ebx
	fstp	ST(0)
	pop	edi
	pop	esi

; 3161 : } /* end circular_arc_area_all() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@circular_a@8:

; 3056 :   }
; 3057 :   else if ( web.symmetric_content )
; 3058 :   { value = chord*chord/4*caf(angle)
; 3059 :       + (e_info->x[0][0]*e_info->x[2][1]-e_info->x[0][1]*e_info->x[2][0])/2;

	fld	QWORD PTR _angle$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_caf
	mov	ecx, DWORD PTR [ebx]
	fst	QWORD PTR tv1106[ebp]
	fld	QWORD PTR _chord$[ebp]
	add	esp, 8
	cmp	DWORD PTR _web+808, 0
	fmul	ST(0), ST(0)
	fmul	QWORD PTR __real@3fd0000000000000
	fst	QWORD PTR tv1108[ebp]
	je	SHORT $LN49@circular_a@8
	mov	eax, DWORD PTR [edi+424]
	fld	QWORD PTR [eax+8]
	fmul	QWORD PTR [ecx]
	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(2)

; 3060 :   }
; 3061 :   else

	jmp	$LN171@circular_a@8
$LN49@circular_a@8:

; 3062 :   { value = chord*chord/4*caf(angle)
; 3063 :             - (dx1+dx2)*(e_info->x[2][1]+e_info->x[0][1])/2;

	mov	edx, DWORD PTR [edi+424]
	fmulp	ST(1), ST(0)
	fld	QWORD PTR [ecx+8]
	fadd	QWORD PTR [edx+8]
	fld	QWORD PTR _dx2$[ebp]
	fadd	QWORD PTR _dx1$[ebp]
	fmulp	ST(1), ST(0)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(2)
	fsubrp	ST(1), ST(0)
	jmp	$LN167@circular_a@8
$LN103@circular_a@8:
	fstp	ST(2)

; 3055 :     }

	jmp	$LN89@circular_a@8
$LN111@circular_a@8:

; 3068 : 
; 3069 :   /* Gradient */
; 3070 : 
; 3071 :   /* parallelogram gradient */
; 3072 :   if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	fstp	ST(1)
	je	$LN46@circular_a@8

; 3073 :   { MAT2D(g,EDGE_CTRL,MAXCOORD);

	push	6
	fstp	ST(0)
	push	3
	lea	eax, DWORD PTR _gxJ$90957[ebp]
	push	eax
	lea	ecx, DWORD PTR _gqXvS$90956[ebp]
	push	ecx
	call	_mat2d_setup

; 3074 :     g[0][0] = (u[2][1] + u[0][1])/2*web.torusv;

	mov	edx, DWORD PTR [esi]
	fld	QWORD PTR [edx+8]
	mov	ebx, DWORD PTR [esi+8]
	fadd	QWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [eax]
	fld	QWORD PTR __real@3fe0000000000000
	add	esp, 16					; 00000010H
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR _web+1600
	fstp	QWORD PTR [ecx]

; 3075 :     g[2][0] = -(u[2][1] + u[0][1])/2*web.torusv;

	mov	edx, DWORD PTR [esi]
	fld	QWORD PTR [edx+8]
	mov	ebx, DWORD PTR [esi+8]
	fadd	QWORD PTR [ebx+8]
	mov	edx, DWORD PTR [eax+8]
	fmul	QWORD PTR __real@bfe0000000000000
	fmul	QWORD PTR _web+1600
	fstp	QWORD PTR [edx]

; 3076 :     g[0][1] = (u[0][0] - u[2][0])/2*web.torusv;

	mov	edx, DWORD PTR [esi]
	fld	QWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+8]
	fsub	QWORD PTR [ebx]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR _web+1600
	fstp	QWORD PTR [ecx+8]

; 3077 :     g[2][1] = (u[0][0] - u[2][0])/2*web.torusv;

	mov	ecx, DWORD PTR [esi]
	fld	QWORD PTR [ecx]
	mov	edx, DWORD PTR [esi+8]
	fsub	QWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+8]
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR _web+1600
	fstp	QWORD PTR [ecx+8]

; 3078 :     g[1][0] = g[1][1] = 0.0;

	mov	ecx, DWORD PTR [eax+4]
	fldz
	fst	QWORD PTR [ecx+8]
	fstp	QWORD PTR [ecx]

; 3079 :     if ( wrap )

	mov	ecx, DWORD PTR _wrap$[ebp]
	test	ecx, ecx
	je	SHORT $LN45@circular_a@8

; 3080 :       g[2][0] += WRAPNUM(wrap)*web.torusv;

	cmp	ecx, 16					; 00000010H
	jle	SHORT $LN59@circular_a@8
	add	ecx, -32				; ffffffe0H
$LN59@circular_a@8:
	mov	DWORD PTR tv283[ebp], ecx
	fild	DWORD PTR tv283[ebp]
	mov	ecx, DWORD PTR [eax+8]
	fmul	QWORD PTR _web+1600
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
$LN45@circular_a@8:

; 3081 :     mat_mult(g,web.inverse_periods,e_info->grad,edge_ctrl,SDIM,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [edi+1336]
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR _edge_ctrl
	push	ecx
	mov	ecx, DWORD PTR _web+1612
	push	edx
	push	ecx
	push	eax
	call	_mat_mult
	add	esp, 24					; 00000018H
	jmp	$LN42@circular_a@8
$LN46@circular_a@8:

; 3082 :   }
; 3083 :   else if ( web.symmetric_content )

	cmp	DWORD PTR _web+808, 0

; 3084 :   { e_info->grad[2][1] +=  e_info->x[0][0]/2;

	mov	edx, DWORD PTR [edi+1336]
	mov	eax, DWORD PTR [edx+8]
	je	SHORT $LN43@circular_a@8
	mov	ecx, DWORD PTR [ebx]
	fld	QWORD PTR [ecx]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]

; 3085 :     e_info->grad[0][1] -=  e_info->x[2][0]/2;

	mov	ecx, DWORD PTR [edi+424]
	fld	QWORD PTR [ecx]
	mov	edx, DWORD PTR [edi+1336]
	mov	eax, DWORD PTR [edx]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]

; 3086 :     e_info->grad[0][0] +=  e_info->x[2][1]/2;

	mov	ecx, DWORD PTR [edi+424]
	fld	QWORD PTR [ecx+8]
	mov	edx, DWORD PTR [edi+1336]
	mov	eax, DWORD PTR [edx]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 3087 :     e_info->grad[2][0] -=  e_info->x[0][1]/2;

	mov	edx, DWORD PTR [edi+1336]
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+8]
	fmul	QWORD PTR [ecx+8]

; 3088 :   }
; 3089 :   else

	jmp	SHORT $LN168@circular_a@8
$LN43@circular_a@8:

; 3090 :   { e_info->grad[2][1] -= (dx1+dx2)/2;

	fld	QWORD PTR _dx2$[ebp]
	fadd	QWORD PTR _dx1$[ebp]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [eax+8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax+8]

; 3091 :     e_info->grad[0][1] -= (dx1+dx2)/2;

	mov	eax, DWORD PTR [edi+1336]
	mov	eax, DWORD PTR [eax]
	fsubr	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]

; 3092 :     e_info->grad[0][0] -= -(e_info->x[2][1]+e_info->x[0][1])/2;

	mov	ecx, DWORD PTR [edi+1336]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	fld	QWORD PTR [edx+8]
	mov	ecx, DWORD PTR [edi+424]
	fadd	QWORD PTR [ecx+8]
	fmul	QWORD PTR __real@bfe0000000000000
	fsubr	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 3093 :     e_info->grad[2][0] -=  (e_info->x[2][1]+e_info->x[0][1])/2;

	mov	edx, DWORD PTR [edi+1336]
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+8]
	fld	QWORD PTR [ecx+8]
	mov	edx, DWORD PTR [edi+424]
	fadd	QWORD PTR [edx+8]
	fmulp	ST(1), ST(0)
$LN168@circular_a@8:
	fsubr	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
$LN42@circular_a@8:

; 3098 :      e_info->grad[i][j] += chord*dchord[i][j]/2*caf(angle)
; 3099 :                            + chord*chord/4*cafp(angle)*dangle[i][j];

	fld	QWORD PTR _angle$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_cafp
	fst	QWORD PTR tv1316[ebp]
	add	esp, 8
	fmul	QWORD PTR tv1108[ebp]
	xor	esi, esi
	xor	edx, edx
	fst	QWORD PTR tv1317[ebp]
	fld	QWORD PTR tv1106[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	fld	QWORD PTR _chord$[ebp]
$LN95@circular_a@8:

; 3097 :    for ( j = 0 ; j < 2 ; j++ )

	xor	eax, eax
$LN38@circular_a@8:

; 3098 :      e_info->grad[i][j] += chord*dchord[i][j]/2*caf(angle)
; 3099 :                            + chord*chord/4*cafp(angle)*dangle[i][j];

	mov	ecx, DWORD PTR [edi+1336]
	mov	ecx, DWORD PTR [esi+ecx]
	lea	ebx, DWORD PTR [edx+eax]
	fld	QWORD PTR _dchord$[ebp+ebx]
	lea	ebx, DWORD PTR [edx+eax]
	fmul	ST(0), ST(1)
	add	eax, 8
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(3)
	fld	QWORD PTR _dangle$[ebp+ebx]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [ecx+eax-8]
	fstp	QWORD PTR [ecx+eax-8]
	cmp	eax, 16					; 00000010H
	jl	SHORT $LN38@circular_a@8

; 3094 :   }
; 3095 :   /* lune gradient */
; 3096 :   for ( i = 0 ; i < 3 ; i++ )

	add	edx, 16					; 00000010H
	add	esi, 4
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN95@circular_a@8

; 3100 : 
; 3101 : 
; 3102 :   if ( mode == METHOD_GRADIENT ) return value;

	cmp	DWORD PTR _mode$[ebp], 4321		; 000010e1H
	fstp	ST(3)
	fstp	ST(1)
	fstp	ST(1)
	je	$LN169@circular_a@8

; 3103 : 
; 3104 :   /* Hessian */
; 3105 : 
; 3106 :   /* parallelogram hessian */
; 3107 :   if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	je	$LN34@circular_a@8

; 3108 :   { MAT2D(temph,MAXCOORD,MAXCOORD);

	push	6
	fstp	ST(0)
	push	6
	lea	edx, DWORD PTR _temphxJ$90973[ebp]
	push	edx
	lea	eax, DWORD PTR _temphqXvS$90972[ebp]
	push	eax
	call	_mat2d_setup

; 3109 :     MAT4D(h,EDGE_CTRL,EDGE_CTRL,MAXCOORD,MAXCOORD);

	push	6
	push	6
	push	3
	push	3
	lea	ecx, DWORD PTR _hxJ$90977[ebp]
	push	ecx
	lea	edx, DWORD PTR _hqXvS$90976[ebp]
	push	edx
	mov	DWORD PTR _temph$90974[ebp], eax
	call	_mat4d_setup

; 3110 :     for ( i = 0 ; i < EDGE_CTRL ; i++ )

	fldz
	mov	edx, DWORD PTR _web+616
	add	esp, 40					; 00000028H
	mov	DWORD PTR _h$90978[ebp], eax
	mov	DWORD PTR _i$[ebp], 0
$LN96@circular_a@8:

; 3111 :      for ( ii = 0 ; ii < EDGE_CTRL ; ii++ )

	xor	ebx, ebx
$LN97@circular_a@8:

; 3112 :        for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN29@circular_a@8
$LN27@circular_a@8:

; 3113 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN26@circular_a@8
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [eax+ebx]
	mov	eax, DWORD PTR [edx+esi*4]
$LN24@circular_a@8:

; 3114 :           h[i][ii][j][jj] = 0.0;

	fst	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	inc	ecx
	add	eax, 8
	cmp	ecx, edx
	jl	SHORT $LN24@circular_a@8

; 3113 :         for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	eax, DWORD PTR _h$90978[ebp]
$LN26@circular_a@8:

; 3112 :        for ( j = 0 ; j < SDIM ; j++ )

	inc	esi
	cmp	esi, edx
	jl	SHORT $LN27@circular_a@8
$LN29@circular_a@8:

; 3111 :      for ( ii = 0 ; ii < EDGE_CTRL ; ii++ )

	add	ebx, 4
	cmp	ebx, 12					; 0000000cH
	jl	SHORT $LN97@circular_a@8

; 3110 :     for ( i = 0 ; i < EDGE_CTRL ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, 3
	jl	SHORT $LN96@circular_a@8

; 3115 :     h[0][2][0][1] = 0.5*web.torusv;

	mov	eax, DWORD PTR [eax]
	fstp	ST(0)
	fld	QWORD PTR _web+1600
	mov	ecx, DWORD PTR [eax+8]
	fld	QWORD PTR __real@3fe0000000000000
	mov	edx, DWORD PTR [ecx]

; 3116 :     h[0][0][0][1] = 0.5*web.torusv;

	mov	eax, DWORD PTR [eax]
	fmul	ST(1), ST(0)
	fxch	ST(1)

; 3117 :     h[2][2][0][1] = -0.5*web.torusv;
; 3118 :     h[2][0][0][1] = -0.5*web.torusv;
; 3119 :     h[0][0][1][0] = 0.5*web.torusv;
; 3120 :     h[0][2][1][0] = -0.5*web.torusv;

	mov	ecx, DWORD PTR [ecx+4]
	fstp	QWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	fld	QWORD PTR _web+1600
	mov	eax, DWORD PTR [eax+4]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx+8]
	mov	edx, DWORD PTR _h$90978[ebp]
	fld	QWORD PTR _web+1600
	mov	edx, DWORD PTR [edx+8]
	mov	esi, DWORD PTR [edx+8]
	fld	QWORD PTR __real@bfe0000000000000
	mov	ebx, DWORD PTR [esi]
	fmul	ST(1), ST(0)
	mov	edx, DWORD PTR [edx]
	fxch	ST(1)
	fstp	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [edx]
	fld	QWORD PTR _web+1600

; 3121 :     h[2][0][1][0] = 0.5*web.torusv;

	mov	edx, DWORD PTR [edx+4]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [ebx+8]
	xor	ebx, ebx
	fld	QWORD PTR _web+1600
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [eax]

; 3122 :     h[2][2][1][0] = -0.5*web.torusv;

	mov	eax, DWORD PTR [esi+4]
	fld	QWORD PTR _web+1600
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [ecx]
	fld	QWORD PTR _web+1600
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [edx]
	fmul	QWORD PTR _web+1600
	fstp	QWORD PTR [eax]
	npad	4
$LL94@circular_a@8:

; 3125 :       for ( ii = 0 ; ii < EDGE_CTRL ; ii ++ )

	xor	esi, esi
$LL18@circular_a@8:

; 3126 :       { mat_mult(h[i][ii],web.inverse_periods,temph,SDIM,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _temph$90974[ebp]
	mov	edx, DWORD PTR _web+1612
	push	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR _h$90978[ebp]
	push	ecx
	mov	ecx, DWORD PTR [ebx+eax]
	push	edx
	mov	edx, DWORD PTR [esi+ecx]
	push	edx
	call	_mat_mult

; 3127 :         tr_mat_mul(web.inverse_periods,temph,e_info->hess[i][ii],SDIM,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR [edi+1340]
	mov	ecx, DWORD PTR [ebx+eax]
	mov	edx, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR _temph$90974[ebp]
	mov	ecx, DWORD PTR _web+1612
	push	edx
	push	eax
	push	ecx
	call	_tr_mat_mul
	add	esi, 4
	add	esp, 48					; 00000030H
	cmp	esi, 12					; 0000000cH
	jl	SHORT $LL18@circular_a@8

; 3123 :     /* form pullback */
; 3124 :     for ( i = 0 ; i < EDGE_CTRL ; i++ )

	add	ebx, 4
	cmp	ebx, 12					; 0000000cH
	jl	SHORT $LL94@circular_a@8

; 3128 :       }
; 3129 :   }
; 3130 :   else if ( web.symmetric_content )

	jmp	$LN13@circular_a@8
$LN34@circular_a@8:

; 3131 :   { e_info->hess[2][0][1][0] +=  1./2;

	mov	edx, DWORD PTR [edi+1340]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	fld	QWORD PTR [eax]
	cmp	DWORD PTR _web+808, 0
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax]

; 3132 :     e_info->hess[0][2][1][0] -=  1./2;

	mov	edx, DWORD PTR [edi+1340]
	je	SHORT $LN14@circular_a@8
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+4]
	fld	QWORD PTR [eax]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax]

; 3133 :     e_info->hess[0][2][0][1] +=  1./2;

	mov	edx, DWORD PTR [edi+1340]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx]
	fld	QWORD PTR [eax+8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax+8]

; 3134 :     e_info->hess[2][0][0][1] -=  1./2;

	mov	edx, DWORD PTR [edi+1340]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax]

; 3135 :   }
; 3136 :   else

	jmp	$LN170@circular_a@8
$LN14@circular_a@8:

; 3137 :   { e_info->hess[2][0][1][0] += 1./2;
; 3138 :     e_info->hess[2][2][1][0] -= 1./2;

	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+4]
	fld	QWORD PTR [eax]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax]

; 3139 :     e_info->hess[0][0][1][0] += 1./2;

	mov	edx, DWORD PTR [edi+1340]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	fld	QWORD PTR [eax]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax]

; 3140 :     e_info->hess[0][2][1][0] -= 1./2;

	mov	edx, DWORD PTR [edi+1340]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+4]
	fld	QWORD PTR [eax]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax]

; 3141 :     e_info->hess[0][0][0][1] += 1./2;

	mov	edx, DWORD PTR [edi+1340]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	fld	QWORD PTR [eax+8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax+8]

; 3142 :     e_info->hess[0][2][0][1] += 1./2;

	mov	edx, DWORD PTR [edi+1340]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx]
	fld	QWORD PTR [eax+8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax+8]

; 3143 :     e_info->hess[2][0][0][1] -= 1./2;

	mov	edx, DWORD PTR [edi+1340]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	fld	QWORD PTR [eax+8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax+8]

; 3144 :     e_info->hess[2][2][0][1] -= 1./2;

	mov	edx, DWORD PTR [edi+1340]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
$LN170@circular_a@8:
	mov	eax, DWORD PTR [ecx]
	fsubr	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
$LN13@circular_a@8:

; 3152 :        e_info->hess[i][ii][j][jj] += 
; 3153 :            dchord[ii][jj]*dchord[i][j]/2*caf(angle)
; 3154 :          + chord*ddchord[i][j][ii][jj]/2*caf(angle)
; 3155 :          + chord*dchord[i][j]/2*cafp(angle)*dangle[ii][jj]
; 3156 :          + 2*dchord[ii][jj]*chord/4*cafp(angle)*dangle[i][j]
; 3157 :          + chord*chord/4*cafpp(angle)*dangle[ii][jj]*dangle[i][j]
; 3158 :          + chord*chord/4*cafp(angle)*ddangle[i][j][ii][jj];

	fld	QWORD PTR _angle$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_cafpp
	fmul	QWORD PTR tv1108[ebp]
	xor	ebx, ebx
	xor	edx, edx
	xor	ecx, ecx
	fstp	QWORD PTR tv1593[ebp]
	add	esp, 8
	fld	QWORD PTR tv1316[ebp]
	mov	DWORD PTR tv2975[ebp], edx
	fld	QWORD PTR tv1106[ebp]
	mov	DWORD PTR tv2740[ebp], ebx
	fld	QWORD PTR __real@3fe0000000000000
	mov	DWORD PTR tv2843[ebp], edx
	fld	QWORD PTR _chord$[ebp]
	mov	DWORD PTR tv2785[ebp], ebx
	fld	ST(0)
	mov	DWORD PTR tv2420[ebp], ecx
	fmul	QWORD PTR _dchord$[ebp+ebx]
	xor	eax, eax
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(4)
	jmp	SHORT $LN3@circular_a@8
$LN90@circular_a@8:

; 3145 :   }
; 3146 : 
; 3147 :   /* chord hessian */
; 3148 :   for ( i = 0 ; i < 3 ; i++ )

	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]

; 3149 :    for ( j = 0 ; j < 2 ; j++ )

	fld	ST(0)
	fmul	QWORD PTR _dchord$[ebp+ebx]

; 3150 :     for ( ii = 0 ; ii < 3 ; ii++ )

	xor	ecx, ecx
	mov	DWORD PTR tv2740[ebp], 0
	mov	DWORD PTR tv2843[ebp], edx
	fmul	ST(0), ST(2)
	mov	DWORD PTR tv2785[ebp], ebx
	mov	DWORD PTR tv2420[ebp], ecx

; 3151 :      for ( jj = 0 ; jj < 2 ; jj++ )

	xor	eax, eax
	fmul	ST(0), ST(4)
	jmp	SHORT $LN3@circular_a@8
$LN91@circular_a@8:

; 3149 :    for ( j = 0 ; j < 2 ; j++ )

	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
	fld	ST(0)
	fmul	QWORD PTR _dchord$[ebp+ebx]

; 3150 :     for ( ii = 0 ; ii < 3 ; ii++ )

	xor	ecx, ecx
	mov	DWORD PTR tv2420[ebp], ecx

; 3151 :      for ( jj = 0 ; jj < 2 ; jj++ )

	xor	eax, eax
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(4)
	jmp	SHORT $LN3@circular_a@8
$LN92@circular_a@8:

; 3150 :     for ( ii = 0 ; ii < 3 ; ii++ )

	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]

; 3151 :      for ( jj = 0 ; jj < 2 ; jj++ )

	xor	eax, eax
	jmp	SHORT $LN3@circular_a@8
$LN93@circular_a@8:
	mov	edi, DWORD PTR _e_info$GSCopy$[ebp]
$LN3@circular_a@8:

; 3152 :        e_info->hess[i][ii][j][jj] += 
; 3153 :            dchord[ii][jj]*dchord[i][j]/2*caf(angle)
; 3154 :          + chord*ddchord[i][j][ii][jj]/2*caf(angle)
; 3155 :          + chord*dchord[i][j]/2*cafp(angle)*dangle[ii][jj]
; 3156 :          + 2*dchord[ii][jj]*chord/4*cafp(angle)*dangle[i][j]
; 3157 :          + chord*chord/4*cafpp(angle)*dangle[ii][jj]*dangle[i][j]
; 3158 :          + chord*chord/4*cafp(angle)*ddangle[i][j][ii][jj];

	mov	edi, DWORD PTR [edi+1340]
	mov	ebx, DWORD PTR tv2975[ebp]
	mov	edi, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR tv2420[ebp]
	mov	edi, DWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR tv2740[ebp]
	mov	edi, DWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR tv2843[ebp]
	add	ebx, ecx
	add	ebx, eax
	fld	QWORD PTR _ddchord$[ebp+ebx]
	mov	ebx, DWORD PTR tv2785[ebp]
	fmul	ST(0), ST(2)
	lea	edx, DWORD PTR [ecx+eax]
	lea	edx, DWORD PTR _dchord$[ebp+edx]
	lea	esi, DWORD PTR [ecx+eax]
	fmul	ST(0), ST(3)
	lea	esi, DWORD PTR _dangle$[ebp+esi]
	fmul	ST(0), ST(4)
	fld	QWORD PTR [edx]
	fmul	QWORD PTR _dchord$[ebp+ebx]
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	QWORD PTR [esi]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx]
	mov	edx, DWORD PTR tv2843[ebp]
	fadd	ST(0), ST(0)
	fmul	ST(0), ST(3)
	fmul	QWORD PTR __real@3fd0000000000000
	fmul	ST(0), ST(6)
	fmul	QWORD PTR _dangle$[ebp+ebx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR tv1593[ebp]
	fmul	QWORD PTR [esi]
	lea	esi, DWORD PTR [edx+ecx]
	add	esi, eax
	add	eax, 8
	fmul	QWORD PTR _dangle$[ebp+ebx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _ddangle$[ebp+esi]
	fmul	QWORD PTR tv1317[ebp]
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [edi+eax-8]
	fstp	QWORD PTR [edi+eax-8]
	cmp	eax, 16					; 00000010H
	jl	$LN93@circular_a@8

; 3150 :     for ( ii = 0 ; ii < 3 ; ii++ )

	add	DWORD PTR tv2420[ebp], 4
	add	ecx, 16					; 00000010H
	cmp	ecx, 48					; 00000030H
	jl	$LN92@circular_a@8
	mov	eax, DWORD PTR tv2740[ebp]
	fstp	ST(0)
	add	eax, 4
	add	ebx, 8
	add	edx, 48					; 00000030H
	mov	DWORD PTR tv2785[ebp], ebx
	mov	DWORD PTR tv2843[ebp], edx
	mov	DWORD PTR tv2740[ebp], eax
	cmp	eax, 8
	jl	$LN91@circular_a@8

; 3145 :   }
; 3146 : 
; 3147 :   /* chord hessian */
; 3148 :   for ( i = 0 ; i < 3 ; i++ )

	mov	eax, DWORD PTR tv2975[ebp]
	add	eax, 4
	mov	DWORD PTR tv2975[ebp], eax
	cmp	eax, 12					; 0000000cH
	jl	$LN90@circular_a@8
	fstp	ST(1)
	fstp	ST(0)
	fstp	ST(0)
$LN169@circular_a@8:
	fstp	ST(0)

; 3159 : 
; 3160 :   return value; 

	fld	QWORD PTR _value$[ebp]
$LN98@circular_a@8:

; 3161 : } /* end circular_arc_area_all() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	ebx
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_circular_arc_area_all ENDP
_TEXT	ENDS
PUBLIC	_circular_arc_area_value
; Function compile flags: /Ogtp
;	COMDAT _circular_arc_area_value
_TEXT	SEGMENT
_fe_id$91025 = -8					; size = 4
_b_id$91023 = -4					; size = 4
_fe$91026 = 8						; size = 4
_e_info$ = 8						; size = 4
_circular_arc_area_value PROC				; COMDAT

; 3175 : { REAL area;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi

; 3176 :   struct method_instance *mi = METH_INSTANCE(e_info->method);

	mov	edi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [edi+8]
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list

; 3177 : 
; 3178 :   if ( web.modeltype != QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	je	SHORT $LN10@circular_a@9

; 3179 :   { if ( web.symmetric_content )

	cmp	DWORD PTR _web+808, 0
	je	SHORT $LN9@circular_a@9

; 3180 :       area = edge_symmetric_area_all(e_info,METHOD_VALUE);

	push	1767					; 000006e7H
	push	edi
	call	_edge_symmetric_area_all

; 3183 :   }
; 3184 :   else

	jmp	SHORT $LN105@circular_a@9
$LN9@circular_a@9:

; 3181 :     else
; 3182 :       return q_edge_area(e_info);  /* does own facet area */

	push	edi
	call	_q_edge_area
	add	esp, 4
	pop	edi
	pop	esi

; 3206 :   }
; 3207 :   return area;
; 3208 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@circular_a@9:

; 3185 :     area = circular_arc_area_all(e_info,METHOD_VALUE);

	push	1767					; 000006e7H
	push	edi
	call	_circular_arc_area_all
$LN105@circular_a@9:
	add	esp, 8

; 3186 : 
; 3187 :   if ( mi->flags & DEFAULT_INSTANCE )

	test	DWORD PTR [esi+140], 4194304		; 00400000H
	je	$LN11@circular_a@9

; 3188 :   { /* add to facet area */
; 3189 :     body_id b_id,bb_id;
; 3190 :     facetedge_id fe_id = get_edge_fe(e_info->id);

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	test	ecx, ecx
	je	SHORT $LN17@circular_a@9
$LN18@circular_a@9:
	mov	ecx, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN17@circular_a@9
	xor	ecx, 134217728				; 08000000H
$LN17@circular_a@9:

; 3191 :     facetedge_id fe;
; 3192 :     facet_id f_id;
; 3193 : 
; 3194 :     b_id = GEN_QUANT(mi->quants[0])->b_id;

	mov	eax, DWORD PTR [esi+152]
	mov	edx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	mov	eax, DWORD PTR [eax+edx+216]

; 3195 :     fe = fe_id;

	mov	esi, DWORD PTR _web+328
	mov	edx, DWORD PTR _web+236
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR _b_id$91023[ebp], eax
	mov	eax, ecx
	mov	DWORD PTR _fe_id$91025[ebp], ecx
	mov	ecx, DWORD PTR _web+460
	mov	DWORD PTR _fe$91026[ebp], eax
	push	ebx
$LN5@circular_a@9:

; 3196 :     do
; 3197 :     { f_id = get_fe_facet(fe);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN22@circular_a@9
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN21@circular_a@9
$LN22@circular_a@9:
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN21@circular_a@9
	xor	ecx, 134217728				; 08000000H
$LN21@circular_a@9:

; 3198 :       bb_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN28@circular_a@9
	xor	eax, eax
	jmp	SHORT $LN25@circular_a@9
$LN28@circular_a@9:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN27@circular_a@9
	xor	eax, eax
	jmp	SHORT $LN25@circular_a@9
$LN27@circular_a@9:
	mov	ebx, DWORD PTR [esi+edi+784]
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN26@circular_a@9
	mov	eax, DWORD PTR [eax+ebx+4]
	jmp	SHORT $LN25@circular_a@9
$LN26@circular_a@9:
	mov	eax, DWORD PTR [eax+ebx]
$LN25@circular_a@9:

; 3199 :       if ( equal_id(b_id,bb_id) )

	cmp	DWORD PTR _b_id$91023[ebp], eax
	jne	SHORT $LN43@circular_a@9

; 3200 :          add_facet_area(f_id,area);

	fld	ST(0)
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN14@circular_a@9
	fchs
$LN14@circular_a@9:
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	fadd	QWORD PTR [eax+40]
	fstp	QWORD PTR [eax+40]
	mov	esi, DWORD PTR _web+328
	mov	edx, DWORD PTR _web+236
	mov	edi, DWORD PTR _dymem
$LN43@circular_a@9:

; 3201 :       bb_id = get_facet_body(inverse_id(f_id));

	mov	eax, ecx
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN34@circular_a@9
	xor	eax, eax
	jmp	SHORT $LN31@circular_a@9
$LN34@circular_a@9:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN33@circular_a@9
	xor	eax, eax
	jmp	SHORT $LN31@circular_a@9
$LN33@circular_a@9:
	mov	ebx, DWORD PTR [esi+edi+784]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN32@circular_a@9
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ebx+4]
	jmp	SHORT $LN31@circular_a@9
$LN32@circular_a@9:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ebx]
$LN31@circular_a@9:

; 3202 :       if ( equal_id(b_id,bb_id) )

	cmp	DWORD PTR _b_id$91023[ebp], eax
	jne	SHORT $LN44@circular_a@9

; 3203 :          add_facet_area(f_id,area);

	fld	ST(0)
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN16@circular_a@9
	fchs
$LN16@circular_a@9:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	fadd	QWORD PTR [ecx+40]
	fstp	QWORD PTR [ecx+40]
	mov	esi, DWORD PTR _web+328
	mov	edx, DWORD PTR _web+236
	mov	edi, DWORD PTR _dymem
$LN44@circular_a@9:

; 3204 :       fe = get_next_facet(fe);

	mov	eax, DWORD PTR _fe$91026[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN38@circular_a@9
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN106@circular_a@9
$LN38@circular_a@9:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+40]
$LN106@circular_a@9:
	mov	DWORD PTR _fe$91026[ebp], eax

; 3205 :     } while ( !equal_id(fe,fe_id) );

	cmp	eax, DWORD PTR _fe_id$91025[ebp]
	jne	$LN5@circular_a@9
	pop	ebx
$LN11@circular_a@9:
	pop	edi
	pop	esi

; 3206 :   }
; 3207 :   return area;
; 3208 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_circular_arc_area_value ENDP
_TEXT	ENDS
PUBLIC	_circular_arc_area_grad
; Function compile flags: /Ogtp
;	COMDAT _circular_arc_area_grad
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_circular_arc_area_grad PROC				; COMDAT

; 3219 : {

	push	ebp
	mov	ebp, esp

; 3220 :   if ( web.modeltype != QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	je	SHORT $LN1@circular_a@10

; 3221 :   { if ( web.symmetric_content )

	cmp	DWORD PTR _web+808, 0
	je	SHORT $LN2@circular_a@10

; 3222 :       return edge_symmetric_area_all(e_info,METHOD_GRADIENT);

	mov	eax, DWORD PTR _e_info$[ebp]
	push	4321					; 000010e1H
	push	eax
	call	_edge_symmetric_area_all

; 3225 :   }
; 3226 : 
; 3227 :   return circular_arc_area_all(e_info,METHOD_GRADIENT);

	add	esp, 8

; 3228 : }

	pop	ebp
	ret	0
$LN2@circular_a@10:
	pop	ebp

; 3223 :     else
; 3224 :        return q_edge_area_grad(e_info);

	jmp	_q_edge_area_grad
$LN1@circular_a@10:

; 3225 :   }
; 3226 : 
; 3227 :   return circular_arc_area_all(e_info,METHOD_GRADIENT);

	mov	edx, DWORD PTR _e_info$[ebp]
	push	4321					; 000010e1H
	push	edx
	call	_circular_arc_area_all
	add	esp, 8

; 3228 : }

	pop	ebp
	ret	0
_circular_arc_area_grad ENDP
_TEXT	ENDS
PUBLIC	_circular_arc_area_hess
; Function compile flags: /Ogtp
;	COMDAT _circular_arc_area_hess
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_circular_arc_area_hess PROC				; COMDAT

; 3239 : {

	push	ebp
	mov	ebp, esp

; 3240 :   if ( web.modeltype != QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	je	SHORT $LN1@circular_a@11

; 3241 :   { if ( web.symmetric_content )

	cmp	DWORD PTR _web+808, 0
	je	SHORT $LN2@circular_a@11

; 3242 :       return edge_symmetric_area_all(e_info,METHOD_HESSIAN);

	mov	eax, DWORD PTR _e_info$[ebp]
	push	8763					; 0000223bH
	push	eax
	call	_edge_symmetric_area_all

; 3245 :   }
; 3246 : 
; 3247 :   return circular_arc_area_all(e_info,METHOD_HESSIAN);

	add	esp, 8

; 3248 : }

	pop	ebp
	ret	0
$LN2@circular_a@11:
	pop	ebp

; 3243 :     else
; 3244 :        return q_edge_area_hess(e_info);

	jmp	_q_edge_area_hess
$LN1@circular_a@11:

; 3245 :   }
; 3246 : 
; 3247 :   return circular_arc_area_all(e_info,METHOD_HESSIAN);

	mov	edx, DWORD PTR _e_info$[ebp]
	push	8763					; 0000223bH
	push	edx
	call	_circular_arc_area_all
	add	esp, 8

; 3248 : }

	pop	ebp
	ret	0
_circular_arc_area_hess ENDP
_TEXT	ENDS
END
