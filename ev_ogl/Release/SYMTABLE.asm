; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\SYMTABLE.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_hash_used:DWORD
COMM	_local_nest_depth:DWORD
COMM	_symtable:BYTE:03840H
COMM	_hash_list:DWORD
COMM	_symtop:DWORD
COMM	_local_scope_bases:DWORD:064H
COMM	_hash_alloc:DWORD
COMM	_bucket_alloc:DWORD
COMM	_symsave:DWORD:03e8H
COMM	_localbase:DWORD
COMM	_bucket_free_head:DWORD
COMM	_symdepth:DWORD
COMM	_bucket_list:DWORD
_DATA	ENDS
PUBLIC	??_C@_0BJ@GOJDMAKG@Scopes?5nested?5too?5deep?4?6?$AA@ ; `string'
PUBLIC	_begin_scope
EXTRN	_kb_error:PROC
;	COMDAT ??_C@_0BJ@GOJDMAKG@Scopes?5nested?5too?5deep?4?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\symtable.c
CONST	SEGMENT
??_C@_0BJ@GOJDMAKG@Scopes?5nested?5too?5deep?4?6?$AA@ DB 'Scopes nested t'
	DB	'oo deep.', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _begin_scope
_TEXT	SEGMENT
_begin_scope PROC					; COMDAT

; 33   :   if ( symdepth >= MAXSYMDEPTH - 1 )

	mov	eax, DWORD PTR _symdepth
	cmp	eax, 999				; 000003e7H
	jl	SHORT $LN1@begin_scop

; 34   :      kb_error(1666,"Scopes nested too deep.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BJ@GOJDMAKG@Scopes?5nested?5too?5deep?4?6?$AA@
	push	1666					; 00000682H
	call	_kb_error
	mov	eax, DWORD PTR _symdepth
	add	esp, 12					; 0000000cH
$LN1@begin_scop:

; 35   : 
; 36   :   symsave[symdepth++] = symtop;

	mov	ecx, DWORD PTR _symtop
	mov	DWORD PTR _symsave[eax*4], ecx
	inc	eax
	mov	DWORD PTR _symdepth, eax

; 37   :   return symdepth;
; 38   : } // end begin_scope()

	ret	0
_begin_scope ENDP
_TEXT	ENDS
PUBLIC	_end_scope
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT _end_scope
_TEXT	SEGMENT
_end_scope PROC						; COMDAT

; 50   :   if ( symdepth >= 1 ) /* clear stack */

	mov	eax, DWORD PTR _symdepth
	mov	ecx, DWORD PTR _symtop
	cmp	eax, 1
	jl	SHORT $LN1@end_scope

; 51   :       symtop = symsave[--symdepth];

	dec	eax
	mov	DWORD PTR _symdepth, eax
	mov	eax, DWORD PTR _symsave[eax*4]
	mov	DWORD PTR _symtop, eax

; 52   :   if ( oldsymtop > symtop )

	cmp	ecx, eax
	jle	SHORT $LN1@end_scope

; 53   :      memset((char*)(symtable+symtop),0,(oldsymtop-symtop)*sizeof(struct sym));

	sub	ecx, eax
	lea	ecx, DWORD PTR [ecx+ecx*8]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	lea	edx, DWORD PTR [eax+eax*8]
	lea	eax, DWORD PTR _symtable[edx*8]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@end_scope:

; 54   : } // end end_scope()

	ret	0
_end_scope ENDP
_TEXT	ENDS
PUBLIC	_set_scope
; Function compile flags: /Ogtp
;	COMDAT _set_scope
_TEXT	SEGMENT
_depth$ = 8						; size = 4
_set_scope PROC						; COMDAT

; 64   : { int oldsymtop = symtop;

	push	ebp
	mov	ebp, esp

; 65   :   symdepth = depth-1;

	mov	eax, DWORD PTR _depth$[ebp]
	mov	ecx, DWORD PTR _symtop
	dec	eax
	mov	DWORD PTR _symdepth, eax

; 66   :   if ( symdepth > 0 )

	test	eax, eax
	jle	SHORT $LN3@set_scope

; 67   :     symtop = symsave[symdepth-1];

	mov	eax, DWORD PTR _symsave[eax*4-4]
	jmp	SHORT $LN6@set_scope
$LN3@set_scope:

; 68   :   else symtop = 0;

	xor	eax, eax
$LN6@set_scope:
	mov	DWORD PTR _symtop, eax

; 69   :   if ( oldsymtop > symtop )

	cmp	ecx, eax
	jle	SHORT $LN1@set_scope

; 70   :      memset((char*)(symtable+symtop),0,(oldsymtop-symtop)*sizeof(struct sym));

	sub	ecx, eax
	lea	ecx, DWORD PTR [ecx+ecx*8]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	lea	edx, DWORD PTR [eax+eax*8]
	lea	eax, DWORD PTR _symtable[edx*8]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@set_scope:

; 71   : } // end set_scope()

	pop	ebp
	ret	0
_set_scope ENDP
_TEXT	ENDS
PUBLIC	_clear_symtable
; Function compile flags: /Ogtp
;	COMDAT _clear_symtable
_TEXT	SEGMENT
_clear_symtable PROC					; COMDAT

; 84   :   symdepth = 0;

	xor	eax, eax

; 85   :   symtop = 0;
; 86   :   memset((char*)symtable,0,SYMMAX*sizeof(struct sym));

	push	14400					; 00003840H
	push	eax
	push	OFFSET _symtable
	mov	DWORD PTR _symdepth, eax
	mov	DWORD PTR _symtop, eax
	call	_memset
	add	esp, 12					; 0000000cH

; 87   : } // end clear_symtable()

	ret	0
_clear_symtable ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@NBLNPJNB@Internal?5error?3?5Symbol?5table?5ove@ ; `string'
PUBLIC	??_C@_0BP@EPFPBOGC@Duplicate?5name?5?8?$CFs?8?5in?5scope?4?6?$AA@ ; `string'
PUBLIC	_symbol_add
EXTRN	_strncpy:PROC
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
EXTRN	_strncmp:PROC
;	COMDAT ??_C@_0CI@NBLNPJNB@Internal?5error?3?5Symbol?5table?5ove@
CONST	SEGMENT
??_C@_0CI@NBLNPJNB@Internal?5error?3?5Symbol?5table?5ove@ DB 'Internal er'
	DB	'ror: Symbol table overflow.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EPFPBOGC@Duplicate?5name?5?8?$CFs?8?5in?5scope?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@EPFPBOGC@Duplicate?5name?5?8?$CFs?8?5in?5scope?4?6?$AA@ DB 'Dup'
	DB	'licate name ''%s'' in scope.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _symbol_add
_TEXT	SEGMENT
_name$ = 8						; size = 4
_type$ = 12						; size = 4
_symbol_add PROC					; COMDAT

; 98   : { int i;

	push	ebp
	mov	ebp, esp

; 99   : 
; 100  :   /* check for duplication in scope */
; 101  :   for ( i = symsave[symdepth-1] ; i < symtop ; i++ )

	mov	eax, DWORD PTR _symdepth
	push	esi
	mov	esi, DWORD PTR _symsave[eax*4-4]
	mov	eax, DWORD PTR _symtop
	push	edi
	mov	edi, DWORD PTR _name$[ebp]
	cmp	esi, eax
	jge	SHORT $LN3@symbol_add
	push	ebx
	lea	ebx, DWORD PTR [esi+esi*8]
	lea	ebx, DWORD PTR _symtable[ebx*8]
$LL5@symbol_add:

; 102  :      if ( strncmp(symtable[i].name,name,SYMNAMESIZE) == 0 )

	push	63					; 0000003fH
	push	edi
	push	ebx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@symbol_add

; 103  :      { sprintf(errmsg,"Duplicate name '%s' in scope.\n",name);

	push	edi
	push	OFFSET ??_C@_0BP@EPFPBOGC@Duplicate?5name?5?8?$CFs?8?5in?5scope?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 104  :         kb_error(1667,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1667					; 00000683H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN4@symbol_add:

; 99   : 
; 100  :   /* check for duplication in scope */
; 101  :   for ( i = symsave[symdepth-1] ; i < symtop ; i++ )

	mov	eax, DWORD PTR _symtop
	inc	esi
	add	ebx, 72					; 00000048H
	cmp	esi, eax
	jl	SHORT $LL5@symbol_add
	pop	ebx
$LN3@symbol_add:

; 105  :      }
; 106  :      
; 107  :   if ( symtop >= SYMMAX )

	cmp	eax, 200				; 000000c8H
	jl	SHORT $LN10@symbol_add

; 108  :      kb_error(1668,"Internal error: Symbol table overflow.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CI@NBLNPJNB@Internal?5error?3?5Symbol?5table?5ove@
	push	1668					; 00000684H
	call	_kb_error
	mov	eax, DWORD PTR _symtop
	add	esp, 12					; 0000000cH
$LN10@symbol_add:

; 109  : 
; 110  :   strncpy(symtable[symtop].name,name,SYMNAMESIZE);

	push	63					; 0000003fH
	lea	ecx, DWORD PTR [eax+eax*8]
	lea	edx, DWORD PTR _symtable[ecx*8]
	push	edi
	push	edx
	call	_strncpy

; 111  :   symtable[symtop].type = type;

	mov	ecx, DWORD PTR _symtop
	mov	edx, DWORD PTR _type$[ebp]
	lea	eax, DWORD PTR [ecx+ecx*8]
	add	eax, eax
	add	eax, eax
	add	esp, 12					; 0000000cH
	add	eax, eax

; 112  :   return symtable + symtop++;

	inc	ecx
	pop	edi
	mov	DWORD PTR _symtable[eax+64], edx
	lea	eax, DWORD PTR _symtable[eax]
	mov	DWORD PTR _symtop, ecx
	pop	esi

; 113  : } // end symbol_add()

	pop	ebp
	ret	0
_symbol_add ENDP
_TEXT	ENDS
PUBLIC	_symbol_lookup
; Function compile flags: /Ogtp
;	COMDAT _symbol_lookup
_TEXT	SEGMENT
_name$ = 8						; size = 4
_symbol_lookup PROC					; COMDAT

; 124  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 125  :   int i;
; 126  : 
; 127  :   for ( i = symtop-1 ; i >= 0 ; i-- )

	mov	esi, DWORD PTR _symtop
	dec	esi
	push	edi
	js	SHORT $LN2@symbol_loo
	mov	ebx, DWORD PTR _name$[ebp]
	lea	edi, DWORD PTR [esi+esi*8]
	lea	edi, DWORD PTR _symtable[edi*8]
	npad	4
$LL4@symbol_loo:

; 128  :      if ( strncmp(symtable[i].name,name,SYMNAMESIZE) == 0 )

	push	63					; 0000003fH
	push	ebx
	push	edi
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@symbol_loo

; 125  :   int i;
; 126  : 
; 127  :   for ( i = symtop-1 ; i >= 0 ; i-- )

	sub	edi, 72					; 00000048H
	dec	esi
	jns	SHORT $LL4@symbol_loo
$LN2@symbol_loo:
	pop	edi
	pop	esi

; 130  : 
; 131  :   return NULL; /* failure */

	xor	eax, eax
	pop	ebx

; 132  : } // end symbol_lookup()

	pop	ebp
	ret	0
$LN8@symbol_loo:
	pop	edi

; 129  :         return symtable + i;  /* success */

	lea	eax, DWORD PTR [esi+esi*8]
	pop	esi
	lea	eax, DWORD PTR _symtable[eax*8]
	pop	ebx

; 132  : } // end symbol_lookup()

	pop	ebp
	ret	0
_symbol_lookup ENDP
_TEXT	ENDS
PUBLIC	_global_hash
EXTRN	_kb_lower_array:BYTE
; Function compile flags: /Ogtp
;	COMDAT _global_hash
_TEXT	SEGMENT
_name$ = 8						; size = 4
_global_hash PROC					; COMDAT

; 163  : { hash_t hashval = 0;  

	push	ebp
	mov	ebp, esp
	push	esi

; 164  :   size_t len = strlen(name);

	mov	esi, DWORD PTR _name$[ebp]
	mov	ecx, esi
	push	edi
	xor	eax, eax
	lea	edi, DWORD PTR [ecx+1]
	npad	1
$LL8@global_has:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL8@global_has
	sub	ecx, edi

; 165  :   size_t i;
; 166  :  
; 167  :   for ( i = 0; i < len ; i++ )

	mov	edx, eax
	je	SHORT $LN1@global_has
	npad	3
$LL3@global_has:

; 168  :     hashval = (hashval + tolower(name[i])) * HASHSTRIDE;

	movsx	edi, BYTE PTR [edx+esi]
	movsx	edi, BYTE PTR _kb_lower_array[edi]
	add	eax, edi
	inc	edx
	imul	eax, 9699691				; 0094016bH
	cmp	edx, ecx
	jb	SHORT $LL3@global_has
$LN1@global_has:
	pop	edi
	pop	esi

; 169  :   return hashval;
; 170  : } // end global_hash()

	pop	ebp
	ret	0
_global_hash ENDP
_TEXT	ENDS
PUBLIC	_insert_hash_entry
PUBLIC	??_C@_0L@LGDGPOBJ@SYMTABLE?4C?$AA@		; `string'
PUBLIC	_expand_global_hash
EXTRN	_myfree:PROC
EXTRN	_kb_calloc:PROC
;	COMDAT ??_C@_0L@LGDGPOBJ@SYMTABLE?4C?$AA@
CONST	SEGMENT
??_C@_0L@LGDGPOBJ@SYMTABLE?4C?$AA@ DB 'SYMTABLE.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _expand_global_hash
_TEXT	SEGMENT
_old_hash_list$ = -12					; size = 4
_old_bucket_list$ = -8					; size = 4
_old_hash_alloc$ = -4					; size = 4
_expand_global_hash PROC				; COMDAT

; 223  : { int old_hash_alloc, old_bucket_alloc;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 224  :   struct hash_entry_t *old_hash_list, *old_bucket_list;
; 225  :   int i;
; 226  : 
; 227  :   old_hash_alloc = hash_alloc;

	mov	eax, DWORD PTR _hash_alloc

; 228  :   old_bucket_alloc = bucket_alloc;
; 229  :   old_hash_list = hash_list;
; 230  :   old_bucket_list = bucket_list;

	mov	ecx, DWORD PTR _bucket_list
	push	ebx
	mov	ebx, DWORD PTR _bucket_alloc
	push	esi
	mov	esi, DWORD PTR _hash_list
	push	edi
	mov	edi, eax
	mov	DWORD PTR _old_hash_alloc$[ebp], edi
	mov	DWORD PTR _old_hash_list$[ebp], esi
	mov	DWORD PTR _old_bucket_list$[ebp], ecx

; 231  : 
; 232  :   if ( hash_alloc == 0 )

	test	eax, eax
	jne	SHORT $LN14@expand_glo

; 233  :     hash_alloc = 1000;

	mov	eax, 1000				; 000003e8H

; 234  :   else

	jmp	SHORT $LN24@expand_glo
$LN14@expand_glo:

; 235  :   { 
; 236  :     hash_alloc *= 2;

	add	eax, eax
$LN24@expand_glo:

; 237  :   }
; 238  : 
; 239  :   hash_list = (struct hash_entry_t *)mycalloc(hash_alloc,sizeof(struct hash_entry_t));

	push	239					; 000000efH
	push	OFFSET ??_C@_0L@LGDGPOBJ@SYMTABLE?4C?$AA@
	push	12					; 0000000cH
	push	eax
	mov	DWORD PTR _hash_alloc, eax
	call	_kb_calloc

; 240  :   bucket_alloc = hash_alloc;
; 241  :   bucket_list = (struct hash_entry_t *)mycalloc(bucket_alloc,sizeof(struct hash_entry_t));

	push	241					; 000000f1H
	push	OFFSET ??_C@_0L@LGDGPOBJ@SYMTABLE?4C?$AA@
	mov	DWORD PTR _hash_list, eax
	mov	eax, DWORD PTR _hash_alloc
	push	12					; 0000000cH
	push	eax
	mov	DWORD PTR _bucket_alloc, eax
	call	_kb_calloc

; 242  : 
; 243  :   hash_used = 0;
; 244  :   bucket_free_head = 1;  // not using index 0, so 0 denotes no "next"
; 245  : 
; 246  :   // set up bucket free list
; 247  :   for ( i = 1 ; i < bucket_alloc-1 ; i++ )

	mov	edx, DWORD PTR _bucket_alloc
	mov	DWORD PTR _bucket_list, eax
	mov	eax, 1
	dec	edx
	add	esp, 32					; 00000020H
	mov	DWORD PTR _hash_used, 0
	mov	DWORD PTR _bucket_free_head, eax
	cmp	edx, eax
	jle	SHORT $LN10@expand_glo

; 237  :   }
; 238  : 
; 239  :   hash_list = (struct hash_entry_t *)mycalloc(hash_alloc,sizeof(struct hash_entry_t));

	mov	ecx, 12					; 0000000cH
	npad	4
$LL23@expand_glo:

; 248  :     bucket_list[i].next = i+1;

	mov	edx, DWORD PTR _bucket_list
	inc	eax
	mov	DWORD PTR [ecx+edx+8], eax
	mov	edx, DWORD PTR _bucket_alloc
	dec	edx
	add	ecx, 12					; 0000000cH
	cmp	eax, edx
	jl	SHORT $LL23@expand_glo
$LN10@expand_glo:

; 249  : 
; 250  :   // copy over hashes
; 251  :   for ( i = 0 ; i < old_hash_alloc ; i++ )

	test	edi, edi
	jle	SHORT $LN7@expand_glo
	npad	3
$LL9@expand_glo:

; 252  :     if ( old_hash_list[i].key )

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN8@expand_glo

; 253  :       insert_hash_entry(old_hash_list[i].hashval,old_hash_list[i].key);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	ecx
	call	_insert_hash_entry
	add	esp, 8
$LN8@expand_glo:

; 249  : 
; 250  :   // copy over hashes
; 251  :   for ( i = 0 ; i < old_hash_alloc ; i++ )

	add	esi, 12					; 0000000cH
	dec	edi
	jne	SHORT $LL9@expand_glo
	mov	edi, DWORD PTR _old_hash_alloc$[ebp]
$LN7@expand_glo:

; 254  :   for ( i = 0 ; i < old_bucket_alloc ; i++ )

	test	ebx, ebx
	jle	SHORT $LN3@expand_glo
	mov	esi, DWORD PTR _old_bucket_list$[ebp]
	mov	edi, ebx
$LL5@expand_glo:

; 255  :     if ( old_bucket_list[i].key )

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN4@expand_glo

; 256  :       insert_hash_entry(old_bucket_list[i].hashval,old_bucket_list[i].key);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	push	edx
	push	eax
	call	_insert_hash_entry
	add	esp, 8
$LN4@expand_glo:

; 254  :   for ( i = 0 ; i < old_bucket_alloc ; i++ )

	add	esi, 12					; 0000000cH
	dec	edi
	jne	SHORT $LL5@expand_glo
	mov	edi, DWORD PTR _old_hash_alloc$[ebp]
$LN3@expand_glo:

; 257  : 
; 258  :   if ( old_hash_alloc )

	test	edi, edi
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN1@expand_glo

; 259  :   {
; 260  :     myfree((char*)old_hash_list);

	mov	ecx, DWORD PTR _old_hash_list$[ebp]
	push	ecx
	call	_myfree

; 261  :     myfree((char*)old_bucket_list);

	mov	edx, DWORD PTR _old_bucket_list$[ebp]
	push	edx
	call	_myfree
	add	esp, 8
$LN1@expand_glo:

; 262  :   }
; 263  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_expand_global_hash ENDP
_TEXT	ENDS
PUBLIC	_hash_delete
; Function compile flags: /Ogtp
;	COMDAT _hash_delete
_TEXT	SEGMENT
_entry$ = 8						; size = 4
_prev_entry$ = 12					; size = 4
_hash_delete PROC					; COMDAT

; 272  : {

	push	ebp
	mov	ebp, esp

; 273  :   if ( prev_entry )

	mov	ecx, DWORD PTR _prev_entry$[ebp]
	push	edi
	xor	edi, edi
	cmp	ecx, edi
	je	SHORT $LN4@hash_delet

; 274  :   { // in bucket_list
; 275  :     entry->key = 0;

	mov	eax, DWORD PTR _entry$[ebp]

; 276  :     entry->hashval = 0;
; 277  :     prev_entry->next = entry->next;

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx+8], edx

; 278  :     entry->next = bucket_free_head;

	mov	ecx, DWORD PTR _bucket_free_head
	mov	DWORD PTR [eax+8], ecx

; 279  :     bucket_free_head = entry - bucket_list;

	sub	eax, DWORD PTR _bucket_list
	pop	edi
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 295  :     }
; 296  :   }
; 297  :   hash_used--;

	dec	DWORD PTR _hash_used
	mov	DWORD PTR _bucket_free_head, eax

; 298  : }

	pop	ebp
	ret	0
$LN4@hash_delet:

; 280  :   }
; 281  :   else
; 282  :   { // in main list
; 283  :     if ( entry->next )

	mov	ecx, DWORD PTR _entry$[ebp]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	cmp	esi, edi
	je	SHORT $LN2@hash_delet

; 284  :     { int next = entry->next;
; 285  :       *entry = bucket_list[next];

	mov	edx, DWORD PTR _bucket_list
	lea	eax, DWORD PTR [esi+esi*2]
	push	ebx
	add	eax, eax
	add	eax, eax
	mov	ebx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx], ebx
	mov	ebx, DWORD PTR [edx+eax+4]
	mov	DWORD PTR [ecx+4], ebx
	mov	edx, DWORD PTR [edx+eax+8]
	mov	DWORD PTR [ecx+8], edx

; 286  :       bucket_list[next].next = bucket_free_head;

	mov	edx, DWORD PTR _bucket_free_head
	mov	ecx, DWORD PTR _bucket_list
	mov	DWORD PTR [eax+ecx+8], edx

; 287  :       bucket_list[next].key = 0;

	mov	ecx, DWORD PTR _bucket_list
	mov	DWORD PTR [eax+ecx], edi

; 288  :       bucket_list[next].hashval = 0;

	mov	edx, DWORD PTR _bucket_list
	mov	DWORD PTR [eax+edx+4], edi

; 295  :     }
; 296  :   }
; 297  :   hash_used--;

	dec	DWORD PTR _hash_used
	pop	ebx
	mov	DWORD PTR _bucket_free_head, esi
	pop	esi
	pop	edi

; 298  : }

	pop	ebp
	ret	0
$LN2@hash_delet:

; 289  :       bucket_free_head = next;
; 290  :     }
; 291  :     else
; 292  :     { entry->key = 0;

	mov	DWORD PTR [ecx], edi

; 293  :       entry->next = 0;

	mov	DWORD PTR [ecx+8], edi

; 294  :       entry->hashval = 0;

	mov	DWORD PTR [ecx+4], edi

; 295  :     }
; 296  :   }
; 297  :   hash_used--;

	dec	DWORD PTR _hash_used
	pop	esi
	pop	edi

; 298  : }

	pop	ebp
	ret	0
_hash_delete ENDP
_TEXT	ENDS
PUBLIC	_clear_globals
; Function compile flags: /Ogtp
;	COMDAT _clear_globals
_TEXT	SEGMENT
_clear_globals PROC					; COMDAT

; 406  :   hash_list = NULL;   // main list

	xor	eax, eax
	mov	DWORD PTR _hash_list, eax

; 407  :   bucket_list = NULL;  // overflow list

	mov	DWORD PTR _bucket_list, eax

; 408  :   hash_alloc = 0;  // hash_list allocated size

	mov	DWORD PTR _hash_alloc, eax

; 409  :   bucket_alloc = 0;  // bucket_list size

	mov	DWORD PTR _bucket_alloc, eax

; 410  :   hash_used = 0;     // total entries in both lists

	mov	DWORD PTR _hash_used, eax

; 411  :   bucket_free_head = 0;  // start of bucket free list

	mov	DWORD PTR _bucket_free_head, eax

; 412  : 
; 413  : } // end clear_globals()

	ret	0
_clear_globals ENDP
_TEXT	ENDS
PUBLIC	_init_local_scope
EXTRN	_calloc:PROC
; Function compile flags: /Ogtp
;	COMDAT _init_local_scope
_TEXT	SEGMENT
_iid$ = 8						; size = 4
_permmode$ = 12						; size = 4
_init_local_scope PROC					; COMDAT

; 640  : {

	push	ebp
	mov	ebp, esp

; 641  :   struct locallist_t *scope_locals;
; 642  :     
; 643  :   scope_locals = (permmode == PERMGLOBAL ) ?
; 644  :        (struct locallist_t *)calloc(1,sizeof(struct locallist_t)) :
; 645  :        (struct locallist_t *)mycalloc(1,sizeof(struct locallist_t)) ;

	cmp	DWORD PTR _permmode$[ebp], 536870912	; 20000000H
	push	esi
	jne	SHORT $LN5@init_local
	push	24					; 00000018H
	push	1
	call	_calloc
	mov	esi, eax
	add	esp, 8

; 647  :       scope_locals->flags |= LL_PERMANENT;

	or	DWORD PTR [esi+20], 2
$LN2@init_local:

; 648  : 
; 649  :   if ( local_nest_depth < 0 ) 

	mov	eax, DWORD PTR _local_nest_depth
	test	eax, eax
	jns	SHORT $LN1@init_local

; 650  :      local_nest_depth = 0;

	xor	eax, eax
$LN1@init_local:

; 651  :   local_scope_bases[local_nest_depth] = scope_locals;

	mov	DWORD PTR _local_scope_bases[eax*4], esi

; 652  :   local_nest_depth++;

	inc	eax
	mov	DWORD PTR _local_nest_depth, eax

; 653  :   
; 654  :   scope_locals->maxlist = 8;
; 655  :   scope_locals->list = (scope_locals->flags & LL_PERMANENT ) ?
; 656  :       (struct localvar_t*)calloc(scope_locals->maxlist,
; 657  :                                  sizeof(struct localvar_t)) :
; 658  :       (struct localvar_t*)mycalloc(scope_locals->maxlist,
; 659  :                                  sizeof(struct localvar_t)) ;

	test	BYTE PTR [esi+20], 2
	mov	DWORD PTR [esi+4], 8
	je	SHORT $LN7@init_local
	push	224					; 000000e0H
	push	8
	call	_calloc
	add	esp, 8
	jmp	SHORT $LN8@init_local
$LN5@init_local:

; 641  :   struct locallist_t *scope_locals;
; 642  :     
; 643  :   scope_locals = (permmode == PERMGLOBAL ) ?
; 644  :        (struct locallist_t *)calloc(1,sizeof(struct locallist_t)) :
; 645  :        (struct locallist_t *)mycalloc(1,sizeof(struct locallist_t)) ;

	push	645					; 00000285H
	push	OFFSET ??_C@_0L@LGDGPOBJ@SYMTABLE?4C?$AA@
	push	24					; 00000018H
	push	1
	call	_kb_calloc
	add	esp, 16					; 00000010H
	mov	esi, eax

; 646  :   if ( permmode == PERMGLOBAL ) 

	jmp	SHORT $LN2@init_local
$LN7@init_local:

; 653  :   
; 654  :   scope_locals->maxlist = 8;
; 655  :   scope_locals->list = (scope_locals->flags & LL_PERMANENT ) ?
; 656  :       (struct localvar_t*)calloc(scope_locals->maxlist,
; 657  :                                  sizeof(struct localvar_t)) :
; 658  :       (struct localvar_t*)mycalloc(scope_locals->maxlist,
; 659  :                                  sizeof(struct localvar_t)) ;

	push	659					; 00000293H
	push	OFFSET ??_C@_0L@LGDGPOBJ@SYMTABLE?4C?$AA@
	push	224					; 000000e0H
	push	8
	call	_kb_calloc
	add	esp, 16					; 00000010H
$LN8@init_local:
	mov	DWORD PTR [esi], eax

; 660  :   localbase = scope_locals;

	mov	DWORD PTR _localbase, esi

; 661  :   scope_locals->list[0].prev = -1;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+208], -1
	pop	esi

; 662  : 
; 663  : } // end init_local_scope()

	pop	ebp
	ret	0
_init_local_scope ENDP
_TEXT	ENDS
PUBLIC	_exit_local_scope
; Function compile flags: /Ogtp
;	COMDAT _exit_local_scope
_TEXT	SEGMENT
_exit_local_scope PROC					; COMDAT

; 677  :   struct locallist_t *locals;
; 678  :   
; 679  :   local_nest_depth--;

	mov	eax, DWORD PTR _local_nest_depth
	dec	eax
	push	esi

; 680  : 
; 681  :   locals = local_scope_bases[local_nest_depth];

	mov	esi, DWORD PTR _local_scope_bases[eax*4]
	mov	DWORD PTR _local_nest_depth, eax

; 682  :   if ( locals && !(locals->flags & LL_IN_USE) )

	test	esi, esi
	je	SHORT $LN3@exit_local
	test	BYTE PTR [esi+20], 4
	jne	SHORT $LN3@exit_local

; 683  :   { myfree((char*)(locals->list));

	mov	eax, DWORD PTR [esi]
	push	eax
	call	_myfree

; 684  :     myfree((char*)locals);

	push	esi
	call	_myfree
	mov	eax, DWORD PTR _local_nest_depth
	add	esp, 8
$LN3@exit_local:

; 685  :   }
; 686  :   local_scope_bases[local_nest_depth] = NULL;

	mov	DWORD PTR _local_scope_bases[eax*4], 0
	pop	esi

; 687  :   if ( local_nest_depth > 0 )

	test	eax, eax
	jle	SHORT $LN2@exit_local

; 688  :     localbase = local_scope_bases[local_nest_depth-1];

	mov	ecx, DWORD PTR _local_scope_bases[eax*4-4]
	mov	DWORD PTR _localbase, ecx

; 690  : } // end exit_local_scope()

	ret	0
$LN2@exit_local:

; 689  :   else localbase = NULL;

	mov	DWORD PTR _localbase, 0

; 690  : } // end exit_local_scope()

	ret	0
_exit_local_scope ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@OLEAKPBH@INTERNAL?5ERROR?3?5local_scope?5not?5@ ; `string'
PUBLIC	_begin_local_scope
;	COMDAT ??_C@_0CO@OLEAKPBH@INTERNAL?5ERROR?3?5local_scope?5not?5@
CONST	SEGMENT
??_C@_0CO@OLEAKPBH@INTERNAL?5ERROR?3?5local_scope?5not?5@ DB 'INTERNAL ER'
	DB	'ROR: local_scope not initialized.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _begin_local_scope
_TEXT	SEGMENT
_begin_local_scope PROC					; COMDAT

; 701  :  
; 702  :   if ( local_nest_depth == 0 )

	cmp	DWORD PTR _local_nest_depth, 0
	jne	SHORT $LN1@begin_loca

; 703  :   { /* coming in from unnamed command */
; 704  :     /*init_local_scope(0); */
; 705  :     kb_error(3501,"INTERNAL ERROR: local_scope not initialized.\n",
; 706  :        RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CO@OLEAKPBH@INTERNAL?5ERROR?3?5local_scope?5not?5@
	push	3501					; 00000dadH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@begin_loca:

; 707  :   }
; 708  :     
; 709  :   locals = local_scope_bases[local_nest_depth-1]; 

	mov	eax, DWORD PTR _local_nest_depth
	mov	eax, DWORD PTR _local_scope_bases[eax*4-4]

; 710  :   locals->list[locals->count].scope_depth++;

	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, 224				; 000000e0H
	inc	DWORD PTR [ecx+edx+212]

; 711  :   locals->scope_depth++;

	inc	DWORD PTR [eax+16]
	lea	ecx, DWORD PTR [ecx+edx+212]

; 712  : } // end begin_local_scope()

	ret	0
_begin_local_scope ENDP
_TEXT	ENDS
PUBLIC	_end_local_scope
; Function compile flags: /Ogtp
;	COMDAT _end_local_scope
_TEXT	SEGMENT
_end_local_scope PROC					; COMDAT

; 723  :   int n;
; 724  :   
; 725  :   locals = local_scope_bases[local_nest_depth-1]; 

	mov	eax, DWORD PTR _local_nest_depth
	mov	edx, DWORD PTR _local_scope_bases[eax*4-4]

; 726  :   if ( !locals ) return;

	test	edx, edx
	je	SHORT $LN5@end_local_

; 727  :   
; 728  :   if ( locals->list )

	push	esi
	mov	esi, DWORD PTR [edx]
	test	esi, esi
	je	SHORT $LN9@end_local_

; 729  :   {  
; 730  :     n = locals->list[locals->count].prev;

	mov	ecx, DWORD PTR [edx+8]
	imul	ecx, 224				; 000000e0H
	mov	eax, DWORD PTR [ecx+esi+208]
	push	ebx
	lea	ebx, DWORD PTR [ecx+esi+208]

; 731  :   
; 732  :     while ( (n >= 0) && (locals->list[n].scope_depth == locals->scope_depth) )

	test	eax, eax
	js	SHORT $LN1@end_local_
	push	edi
	mov	edi, DWORD PTR [edx+16]
	npad	9
$LL2@end_local_:
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	cmp	DWORD PTR [ecx+esi+212], edi
	jne	SHORT $LN10@end_local_

; 733  :       n = locals->list[n].prev;

	mov	eax, DWORD PTR [ecx+esi+208]
	test	eax, eax
	jns	SHORT $LL2@end_local_
$LN10@end_local_:
	pop	edi
$LN1@end_local_:

; 734  : 
; 735  :     locals->list[locals->count].prev = n;

	mov	DWORD PTR [ebx], eax

; 736  :     locals->list[locals->count].scope_depth--;

	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [edx]
	imul	eax, 224				; 000000e0H
	dec	DWORD PTR [eax+ecx+212]
	lea	eax, DWORD PTR [eax+ecx+212]
	pop	ebx
$LN9@end_local_:

; 737  :   }
; 738  :   locals->scope_depth--;

	dec	DWORD PTR [edx+16]
	pop	esi
$LN5@end_local_:

; 739  : } // end end_local_scope()

	ret	0
_end_local_scope ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@LKFLMJAN@Local?5variable?5?$CFs?5already?5declar@ ; `string'
PUBLIC	_add_local_var
EXTRN	_KB_realloc:PROC
EXTRN	_realloc:PROC
;	COMDAT ??_C@_0DG@LKFLMJAN@Local?5variable?5?$CFs?5already?5declar@
CONST	SEGMENT
??_C@_0DG@LKFLMJAN@Local?5variable?5?$CFs?5already?5declar@ DB 'Local var'
	DB	'iable %s already declared in current block.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _add_local_var
_TEXT	SEGMENT
_depth$ = -4						; size = 4
_name$ = 8						; size = 4
_size$ = 12						; size = 4
_add_local_var PROC					; COMDAT

; 752  : { int n;

	push	ebp
	mov	ebp, esp
	push	ecx

; 753  :   struct localvar_t *v;
; 754  :   int depth;
; 755  :   struct locallist_t *locals;
; 756  :   int retval;
; 757  :   
; 758  :   locals = local_scope_bases[local_nest_depth-1]; 

	mov	eax, DWORD PTR _local_nest_depth
	push	esi
	push	edi
	mov	edi, DWORD PTR _local_scope_bases[eax*4-4]

; 759  :    
; 760  :   depth = locals->scope_depth;
; 761  : 
; 762  :   v = locals->list + locals->count;

	mov	esi, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi]
	imul	esi, 224				; 000000e0H
	mov	ecx, DWORD PTR [edi+16]
	add	esi, eax

; 763  : 
; 764  :   if ( name )

	cmp	DWORD PTR _name$[ebp], 0
	mov	DWORD PTR _depth$[ebp], ecx
	je	$LN6@add_local_

; 765  :   { /* search for duplicate in current scope */
; 766  :     for ( n = v->prev ; (n >= 0) && (locals->list[n].scope_depth == depth) ; 
; 767  :           n = locals->list[n].prev )

	mov	ecx, DWORD PTR [esi+208]
	test	ecx, ecx
	js	$LN18@add_local_
	push	ebx
	npad	2
$LL17@add_local_:
	mov	edx, DWORD PTR _depth$[ebp]
	mov	ebx, ecx
	imul	ebx, 224				; 000000e0H
	cmp	DWORD PTR [ebx+eax+212], edx
	lea	ecx, DWORD PTR [ebx+eax]
	jne	SHORT $LN19@add_local_

; 768  :       if ( strcmp(name,locals->list[n].g.name) == 0 )

	mov	eax, DWORD PTR _name$[ebp]
	npad	6
$LL13@add_local_:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN14@add_local_
	test	dl, dl
	je	SHORT $LN15@add_local_
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN14@add_local_
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL13@add_local_
$LN15@add_local_:
	xor	eax, eax
	jmp	SHORT $LN16@add_local_
$LN14@add_local_:
	sbb	eax, eax
	sbb	eax, -1
$LN16@add_local_:
	test	eax, eax
	jne	SHORT $LN4@add_local_

; 769  :       { sprintf(errmsg,"Local variable %s already declared in current block.\n",
; 770  :            name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DG@LKFLMJAN@Local?5variable?5?$CFs?5already?5declar@
	push	OFFSET _errmsg
	call	_sprintf

; 771  :         kb_error(2613,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2613					; 00000a35H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN4@add_local_:

; 765  :   { /* search for duplicate in current scope */
; 766  :     for ( n = v->prev ; (n >= 0) && (locals->list[n].scope_depth == depth) ; 
; 767  :           n = locals->list[n].prev )

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ebx+eax+208]
	test	ecx, ecx
	jns	SHORT $LL17@add_local_
$LN19@add_local_:
	pop	ebx
$LN18@add_local_:

; 772  :       }
; 773  :  
; 774  :     /* add to list */
; 775  :     strncpy(v->g.name,name,GLOBAL_NAME_SIZE);

	mov	ecx, DWORD PTR _name$[ebp]
	push	63					; 0000003fH
	push	ecx
	push	esi
	call	_strncpy
	add	esp, 12					; 0000000cH

; 776  :     v->g.flags |= GLOB_USED | GLOB_LOCALVAR;

	or	DWORD PTR [esi+192], 524320		; 00080020H

; 777  :     v->offset = v->g.value.offset = locals->totalsize;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+64], eax
	mov	DWORD PTR [esi+216], eax
$LN6@add_local_:

; 778  :   }
; 779  :   
; 780  :   /* extend list, if necessary */
; 781  :   if ( locals->count >= locals->maxlist-1 )

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [eax-1]
	cmp	DWORD PTR [edi+8], edx
	jl	SHORT $LN1@add_local_

; 782  :   { locals->list = (locals->flags & LL_PERMANENT) ?
; 783  :      (struct localvar_t*)realloc((char*)locals->list,
; 784  :       locals->maxlist*2*sizeof(struct localvar_t))  :
; 785  :     (struct localvar_t*)kb_realloc((char*)locals->list,
; 786  :       locals->maxlist*2*sizeof(struct localvar_t));

	imul	eax, 448				; 000001c0H
	test	BYTE PTR [edi+20], 2
	je	SHORT $LN9@add_local_
	push	eax
	mov	eax, DWORD PTR [edi]
	push	eax
	call	_realloc
	add	esp, 8
	jmp	SHORT $LN10@add_local_
$LN9@add_local_:
	mov	ecx, DWORD PTR [edi]
	push	786					; 00000312H
	push	OFFSET ??_C@_0L@LGDGPOBJ@SYMTABLE?4C?$AA@
	push	eax
	push	ecx
	call	_KB_realloc
	add	esp, 16					; 00000010H
$LN10@add_local_:

; 787  :     locals->maxlist*=2;
; 788  :     v = locals->list + locals->count;   /* reset dangling pointer */

	mov	esi, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi+4]
	imul	esi, 224				; 000000e0H
	add	edx, edx
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], edx
	add	esi, eax
$LN1@add_local_:

; 789  :   }
; 790  :   v->size = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [esi+220], eax

; 791  :   v->offset = locals->totalsize;

	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+216], ecx

; 792  : 
; 793  :   /* move counter up */ 
; 794  :   v[1].prev = locals->count;

	mov	edx, DWORD PTR [edi+8]

; 795  :   v[1].scope_depth = v->scope_depth;

	mov	ecx, DWORD PTR [esi+212]
	mov	DWORD PTR [esi+432], edx

; 796  :   locals->totalsize = v->offset + size;

	mov	edx, DWORD PTR [esi+216]
	mov	DWORD PTR [esi+436], ecx

; 797  :   retval = locals->count | LOCALVAR;

	mov	ecx, DWORD PTR [edi+8]
	add	edx, eax
	mov	eax, ecx
	or	eax, 805306368				; 30000000H

; 798  :   locals->count++;

	inc	ecx
	mov	DWORD PTR [edi+12], edx
	mov	DWORD PTR [edi+8], ecx
	pop	edi
	pop	esi

; 799  :  
; 800  :   return retval;
; 801  : } /* end add_local_var */

	mov	esp, ebp
	pop	ebp
	ret	0
_add_local_var ENDP
_TEXT	ENDS
PUBLIC	_lookup_local_var
; Function compile flags: /Ogtp
;	COMDAT _lookup_local_var
_TEXT	SEGMENT
_name$ = 8						; size = 4
_lookup_local_var PROC					; COMDAT

; 812  : { int n;

	push	ebp
	mov	ebp, esp

; 813  :   struct localvar_t *v;
; 814  :   struct locallist_t *locals;
; 815  :    
; 816  :   if ( local_nest_depth <= 0 ) return 0; 

	mov	eax, DWORD PTR _local_nest_depth
	test	eax, eax
	jg	SHORT $LN6@lookup_loc
	xor	eax, eax

; 829  : } // end lookup_local_var()

	pop	ebp
	ret	0
$LN6@lookup_loc:

; 817  :   locals = local_scope_bases[local_nest_depth-1]; 

	mov	eax, DWORD PTR _local_scope_bases[eax*4-4]
	push	edi

; 818  :   if ( locals->list == NULL ) return 0;

	mov	edi, DWORD PTR [eax]
	test	edi, edi
	jne	SHORT $LN5@lookup_loc
	xor	eax, eax
	pop	edi

; 829  : } // end lookup_local_var()

	pop	ebp
	ret	0
$LN5@lookup_loc:

; 819  :   
; 820  :   v = locals->list + locals->count;

	mov	eax, DWORD PTR [eax+8]
	imul	eax, 224				; 000000e0H

; 821  : 
; 822  :   /* search for duplicate in current scope */
; 823  :   for ( n = v->prev ; n >= 0 ; n = ( n ? locals->list[n].prev : -1) )

	mov	eax, DWORD PTR [eax+edi+208]
	push	ebx
	push	esi
	test	eax, eax
	js	SHORT $LN2@lookup_loc
	npad	7
$LL4@lookup_loc:

; 824  :     if ( strcmp(name,locals->list[n].g.name) == 0 )

	mov	ecx, DWORD PTR _name$[ebp]
	mov	esi, eax
	imul	esi, 224				; 000000e0H
	add	esi, edi
	mov	edx, esi
	npad	1
$LL15@lookup_loc:
	mov	bl, BYTE PTR [ecx]
	cmp	bl, BYTE PTR [edx]
	jne	SHORT $LN16@lookup_loc
	test	bl, bl
	je	SHORT $LN17@lookup_loc
	mov	bl, BYTE PTR [ecx+1]
	cmp	bl, BYTE PTR [edx+1]
	jne	SHORT $LN16@lookup_loc
	add	ecx, 2
	add	edx, 2
	test	bl, bl
	jne	SHORT $LL15@lookup_loc
$LN17@lookup_loc:
	xor	ecx, ecx
	jmp	SHORT $LN18@lookup_loc
$LN16@lookup_loc:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN18@lookup_loc:
	test	ecx, ecx
	je	SHORT $LN12@lookup_loc

; 821  : 
; 822  :   /* search for duplicate in current scope */
; 823  :   for ( n = v->prev ; n >= 0 ; n = ( n ? locals->list[n].prev : -1) )

	test	eax, eax
	je	SHORT $LN2@lookup_loc
	mov	eax, DWORD PTR [esi+208]
	test	eax, eax
	jns	SHORT $LL4@lookup_loc
$LN2@lookup_loc:
	pop	esi
	pop	ebx

; 826  :     }
; 827  : 
; 828  :   return 0; /* not found */

	xor	eax, eax
	pop	edi

; 829  : } // end lookup_local_var()

	pop	ebp
	ret	0
$LN12@lookup_loc:
	pop	esi
	pop	ebx

; 825  :     { return LOCALVAR | n;

	or	eax, 805306368				; 30000000H
	pop	edi

; 829  : } // end lookup_local_var()

	pop	ebp
	ret	0
_lookup_local_var ENDP
_TEXT	ENDS
PUBLIC	_locals_copy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT _locals_copy
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_locals_copy PROC					; COMDAT

; 842  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 843  :   if ( *dest )

	mov	edi, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN4@locals_cop

; 844  :   { /* have old structure */
; 845  :     myfree((char*)(*dest)->list);

	mov	eax, DWORD PTR [eax]
	push	eax
	call	_myfree
	add	esp, 4

; 846  :   }
; 847  :   else

	jmp	SHORT $LN3@locals_cop
$LN4@locals_cop:

; 848  :     *dest = (struct locallist_t *)mycalloc(1,sizeof(struct locallist_t));

	push	848					; 00000350H
	push	OFFSET ??_C@_0L@LGDGPOBJ@SYMTABLE?4C?$AA@
	push	24					; 00000018H
	push	1
	call	_kb_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi], eax
$LN3@locals_cop:

; 849  :   if ( src )

	mov	esi, DWORD PTR _src$[ebp]
	test	esi, esi
	je	SHORT $LN2@locals_cop

; 850  :   {
; 851  :     **dest = *src;

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [esi+20]

; 852  :     (*dest)->list = (struct localvar_t *)mycalloc(src->count,
; 853  :                        sizeof(struct localvar_t));

	push	853					; 00000355H
	push	OFFSET ??_C@_0L@LGDGPOBJ@SYMTABLE?4C?$AA@
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR [esi+8]
	push	224					; 000000e0H
	push	eax
	call	_kb_calloc
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax

; 854  :     memcpy((*dest)->list,src->list,src->count*sizeof(struct localvar_t));

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi]
	imul	edx, 224				; 000000e0H
	mov	ecx, DWORD PTR [edi]
	push	edx
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edx
	call	_memcpy
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi

; 858  : } // end locals_copy()

	pop	ebp
	ret	0
$LN2@locals_cop:

; 855  :   }
; 856  :   else 
; 857  :     memset((char*)(*dest),0,sizeof(struct locallist_t));

	mov	ecx, DWORD PTR [edi]
	xor	eax, eax
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	pop	edi
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax
	pop	esi

; 858  : } // end locals_copy()

	pop	ebp
	ret	0
_locals_copy ENDP
_TEXT	ENDS
PUBLIC	_locals_copy_perm
EXTRN	_free:PROC
; Function compile flags: /Ogtp
;	COMDAT _locals_copy_perm
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_locals_copy_perm PROC					; COMDAT

; 871  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 872  :   if ( *dest )

	mov	edi, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN4@locals_cop@2

; 873  :   { /* have old structure */
; 874  :     free((char*)(*dest)->list);

	mov	eax, DWORD PTR [eax]
	push	eax
	call	_free
	add	esp, 4

; 875  :   }
; 876  :   else

	jmp	SHORT $LN3@locals_cop@2
$LN4@locals_cop@2:

; 877  :     *dest = (struct locallist_t *)calloc(1,sizeof(struct locallist_t));

	push	24					; 00000018H
	push	1
	call	_calloc
	add	esp, 8
	mov	DWORD PTR [edi], eax
$LN3@locals_cop@2:

; 878  :   if ( src )

	mov	esi, DWORD PTR _src$[ebp]
	test	esi, esi
	je	SHORT $LN2@locals_cop@2

; 879  :   {
; 880  :     **dest = *src;

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+20], edx

; 881  :     (*dest)->list = (struct localvar_t *)calloc(src->count,
; 882  :                        sizeof(struct localvar_t));

	mov	eax, DWORD PTR [esi+8]
	push	224					; 000000e0H
	push	eax
	call	_calloc
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax

; 883  :     memcpy((*dest)->list,src->list,src->count*sizeof(struct localvar_t));

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi]
	imul	edx, 224				; 000000e0H
	mov	ecx, DWORD PTR [edi]
	push	edx
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edx
	call	_memcpy
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi

; 887  : } // end locals_copy_perm()

	pop	ebp
	ret	0
$LN2@locals_cop@2:

; 884  :   }
; 885  :   else 
; 886  :     memset((char*)(*dest),0,sizeof(struct locallist_t));

	mov	ecx, DWORD PTR [edi]
	xor	eax, eax
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	pop	edi
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax
	pop	esi

; 887  : } // end locals_copy_perm()

	pop	ebp
	ret	0
_locals_copy_perm ENDP
_TEXT	ENDS
PUBLIC	_allocate_transform_colors
EXTRN	_dymem:DWORD
EXTRN	_web:BYTE
EXTRN	_view_transform_swap_colors_global:DWORD
EXTRN	_transform_colors:DWORD
; Function compile flags: /Ogtp
;	COMDAT _allocate_transform_colors
_TEXT	SEGMENT
_count$ = 8						; size = 4
_allocate_transform_colors PROC				; COMDAT

; 1101 : { struct global *g;

	push	ebp
	mov	ebp, esp

; 1102 : 
; 1103 :   if ( transform_colors ) myfree((char*)transform_colors);

	mov	eax, DWORD PTR _transform_colors
	test	eax, eax
	je	SHORT $LN2@allocate_t
	push	eax
	call	_myfree
	add	esp, 4
$LN2@allocate_t:

; 1104 :   if ( count )

	push	esi
	mov	esi, DWORD PTR _count$[ebp]
	test	esi, esi
	je	SHORT $LN1@allocate_t

; 1105 :     transform_colors = (int*)mycalloc(count,sizeof(int));

	push	1105					; 00000451H
	push	OFFSET ??_C@_0L@LGDGPOBJ@SYMTABLE?4C?$AA@
	push	4
	push	esi
	call	_kb_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _transform_colors, eax
$LN1@allocate_t:

; 1106 :   g = globals(view_transform_swap_colors_global);

	mov	eax, DWORD PTR _view_transform_swap_colors_global
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN5@allocate_t
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN7@allocate_t
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN6@allocate_t
$LN7@allocate_t:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN5@allocate_t
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN6@allocate_t
$LN5@allocate_t:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN6@allocate_t:

; 1107 :   g->attr.arrayptr->sizes[0] = count;

	mov	ecx, DWORD PTR [eax+168]
	mov	DWORD PTR [ecx+24], esi

; 1108 :   g->attr.arrayptr->datacount = count;

	mov	edx, DWORD PTR [eax+168]
	mov	DWORD PTR [edx+16], esi

; 1109 :   g->attr.arrayptr->datastart = count ?
; 1110 :         ((char*)transform_colors - (char*)(g->attr.arrayptr)) : 0;

	test	esi, esi
	pop	esi
	je	SHORT $LN11@allocate_t
	mov	ecx, DWORD PTR _transform_colors
	sub	ecx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR [eax+168]
	mov	DWORD PTR [eax+20], ecx

; 1111 : } // end allocate_transform_colors()

	pop	ebp
	ret	0
$LN11@allocate_t:

; 1109 :   g->attr.arrayptr->datastart = count ?
; 1110 :         ((char*)transform_colors - (char*)(g->attr.arrayptr)) : 0;

	mov	edx, DWORD PTR [eax+168]
	xor	ecx, ecx
	mov	DWORD PTR [edx+20], ecx

; 1111 : } // end allocate_transform_colors()

	pop	ebp
	ret	0
_allocate_transform_colors ENDP
_TEXT	ENDS
PUBLIC	_set_view_transforms_global
EXTRN	_view_transforms_global:DWORD
EXTRN	_matrix3_reorder:PROC
EXTRN	_transform_count:DWORD
EXTRN	_view_transforms:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_view_transforms_global
_TEXT	SEGMENT
_set_view_transforms_global PROC			; COMDAT

; 1121 : 
; 1122 :   /* need to reorder, since graphgen can leave it in a mess */
; 1123 :   view_transforms = matrix3_reorder(view_transforms,transform_count,SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _view_transforms
	inc	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR _transform_count
	push	eax
	push	ecx
	call	_matrix3_reorder
	mov	DWORD PTR _view_transforms, eax

; 1124 :   g = globals(view_transforms_global); 

	mov	eax, DWORD PTR _view_transforms_global
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 16					; 00000010H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN3@set_view_t
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN5@set_view_t
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN4@set_view_t
$LN5@set_view_t:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN3@set_view_t
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN4@set_view_t
$LN3@set_view_t:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN4@set_view_t:

; 1125 :   g->attr.arrayptr->sizes[0] = transform_count;

	mov	edx, DWORD PTR [eax+168]
	mov	ecx, DWORD PTR _transform_count
	mov	DWORD PTR [edx+24], ecx

; 1126 :   g->attr.arrayptr->sizes[1] = SDIM+1;

	mov	edx, DWORD PTR _web+616
	mov	ecx, DWORD PTR [eax+168]
	inc	edx
	mov	DWORD PTR [ecx+28], edx

; 1127 :   g->attr.arrayptr->sizes[2] = SDIM+1;

	mov	edx, DWORD PTR _web+616
	mov	ecx, DWORD PTR [eax+168]
	inc	edx
	mov	DWORD PTR [ecx+32], edx

; 1128 :   g->attr.arrayptr->datacount = transform_count*(SDIM+1)*(SDIM+1);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [eax+168]
	inc	ecx
	imul	ecx, ecx
	imul	ecx, DWORD PTR _transform_count
	mov	DWORD PTR [edx+16], ecx

; 1129 :   g->attr.arrayptr->datastart = transform_count ?
; 1130 :         (char*)view_transforms[0][0] - (char*)(g->attr.arrayptr) : 0;

	cmp	DWORD PTR _transform_count, 0
	je	SHORT $LN9@set_view_t
	mov	ecx, DWORD PTR _view_transforms
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR [eax+168]
	mov	DWORD PTR [eax+20], ecx

; 1131 : } // end set_view_transforms_global()

	ret	0
$LN9@set_view_t:

; 1129 :   g->attr.arrayptr->datastart = transform_count ?
; 1130 :         (char*)view_transforms[0][0] - (char*)(g->attr.arrayptr) : 0;

	mov	edx, DWORD PTR [eax+168]
	xor	ecx, ecx
	mov	DWORD PTR [edx+20], ecx

; 1131 : } // end set_view_transforms_global()

	ret	0
_set_view_transforms_global ENDP
_TEXT	ENDS
PUBLIC	_set_view_transform_generators_global
EXTRN	_transform_gen_swap:DWORD
EXTRN	_transform_gen_swap_colors_global:DWORD
EXTRN	_view_transform_gens:DWORD
EXTRN	_transform_gen_count:DWORD
EXTRN	_view_transform_generators_global:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_view_transform_generators_global
_TEXT	SEGMENT
_set_view_transform_generators_global PROC		; COMDAT

; 1141 : 
; 1142 :   g = globals(view_transform_generators_global); 

	mov	eax, DWORD PTR _view_transform_generators_global
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN3@set_view_t@2
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN5@set_view_t@2
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN4@set_view_t@2
$LN5@set_view_t@2:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN3@set_view_t@2
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN4@set_view_t@2
$LN3@set_view_t@2:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN4@set_view_t@2:

; 1143 :   g->attr.arrayptr->sizes[0] = transform_gen_count;

	mov	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _transform_gen_count
	mov	DWORD PTR [ecx+24], edx

; 1144 :   g->attr.arrayptr->sizes[1] = SDIM+1;

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [eax+168]
	inc	ecx
	mov	DWORD PTR [edx+28], ecx

; 1145 :   g->attr.arrayptr->sizes[2] = SDIM+1;

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [eax+168]
	inc	ecx
	mov	DWORD PTR [edx+32], ecx

; 1146 :   g->attr.arrayptr->datacount = transform_gen_count*(SDIM+1)*(SDIM+1);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [eax+168]
	inc	ecx
	imul	ecx, ecx
	imul	ecx, DWORD PTR _transform_gen_count
	mov	DWORD PTR [edx+16], ecx

; 1147 :   g->attr.arrayptr->datastart = transform_gen_count ?
; 1148 :         (char*)view_transform_gens[0][0] - (char*)(g->attr.arrayptr) : 0;

	cmp	DWORD PTR _transform_gen_count, 0
	je	SHORT $LN9@set_view_t@2
	mov	ecx, DWORD PTR _view_transform_gens
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, DWORD PTR [eax+168]
	jmp	SHORT $LN10@set_view_t@2
$LN9@set_view_t@2:
	xor	ecx, ecx
$LN10@set_view_t@2:
	mov	eax, DWORD PTR [eax+168]
	mov	DWORD PTR [eax+20], ecx

; 1149 : 
; 1150 :   g = globals(transform_gen_swap_colors_global); 

	mov	eax, DWORD PTR _transform_gen_swap_colors_global
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN11@set_view_t@2
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN13@set_view_t@2
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN12@set_view_t@2
$LN13@set_view_t@2:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN11@set_view_t@2
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN12@set_view_t@2
$LN11@set_view_t@2:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN12@set_view_t@2:

; 1151 :   g->attr.arrayptr->sizes[0] = transform_gen_count;

	mov	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _transform_gen_count
	mov	DWORD PTR [ecx+24], edx

; 1152 :   g->attr.arrayptr->datacount = transform_gen_count;

	mov	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _transform_gen_count
	mov	DWORD PTR [ecx+16], edx

; 1153 :   g->attr.arrayptr->datastart = transform_gen_count ?
; 1154 :         (char*)transform_gen_swap - (char*)(g->attr.arrayptr) : 0;

	cmp	DWORD PTR _transform_gen_count, 0
	je	SHORT $LN17@set_view_t@2
	mov	ecx, DWORD PTR _transform_gen_swap
	sub	ecx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR [eax+168]
	mov	DWORD PTR [eax+20], ecx

; 1155 : 
; 1156 : } // end set_view_transform_generators_global()

	ret	0
$LN17@set_view_t@2:

; 1153 :   g->attr.arrayptr->datastart = transform_gen_count ?
; 1154 :         (char*)transform_gen_swap - (char*)(g->attr.arrayptr) : 0;

	mov	edx, DWORD PTR [eax+168]
	xor	ecx, ecx
	mov	DWORD PTR [edx+20], ecx

; 1155 : 
; 1156 : } // end set_view_transform_generators_global()

	ret	0
_set_view_transform_generators_global ENDP
_TEXT	ENDS
PUBLIC	_set_torus_periods_global
EXTRN	_torus_periods_global:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_torus_periods_global
_TEXT	SEGMENT
_set_torus_periods_global PROC				; COMDAT

; 1167 : 
; 1168 :   g = globals(torus_periods_global);

	mov	eax, DWORD PTR _torus_periods_global
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN3@set_torus_
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN5@set_torus_
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN4@set_torus_
$LN5@set_torus_:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN3@set_torus_
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN4@set_torus_
$LN3@set_torus_:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN4@set_torus_:

; 1169 :   g->attr.arrayptr->sizes[0] = SDIM;

	mov	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR [ecx+24], edx

; 1170 :   g->attr.arrayptr->sizes[1] = SDIM;

	mov	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR [ecx+28], edx

; 1171 :   g->attr.arrayptr->datacount = SDIM*SDIM;

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [eax+168]
	imul	ecx, ecx
	mov	DWORD PTR [edx+16], ecx

; 1172 :   g->attr.arrayptr->datastart = 
; 1173 :         (char*)&web.torus_period[0][0] - (char*)(g->attr.arrayptr);

	mov	ecx, DWORD PTR _web+1608
	mov	eax, DWORD PTR [eax+168]
	mov	edx, DWORD PTR [ecx]
	sub	edx, eax
	mov	DWORD PTR [eax+20], edx

; 1174 : } // end set_torus_periods_global()

	ret	0
_set_torus_periods_global ENDP
_TEXT	ENDS
PUBLIC	_set_inverse_periods_global
EXTRN	_inverse_periods_global:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_inverse_periods_global
_TEXT	SEGMENT
_set_inverse_periods_global PROC			; COMDAT

; 1185 : 
; 1186 :   g = globals(inverse_periods_global);

	mov	eax, DWORD PTR _inverse_periods_global
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN3@set_invers
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN5@set_invers
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN4@set_invers
$LN5@set_invers:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN3@set_invers
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN4@set_invers
$LN3@set_invers:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN4@set_invers:

; 1187 :   g->attr.arrayptr->sizes[0] = SDIM;

	mov	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR [ecx+24], edx

; 1188 :   g->attr.arrayptr->sizes[1] = SDIM;

	mov	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR [ecx+28], edx

; 1189 :   g->attr.arrayptr->datacount = SDIM*SDIM;

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [eax+168]
	imul	ecx, ecx
	mov	DWORD PTR [edx+16], ecx

; 1190 :   g->attr.arrayptr->datastart = 
; 1191 :         (char*)&web.inverse_periods_tr[0][0] - (char*)(g->attr.arrayptr);

	mov	ecx, DWORD PTR _web+1616
	mov	eax, DWORD PTR [eax+168]
	mov	edx, DWORD PTR [ecx]
	sub	edx, eax
	mov	DWORD PTR [eax+20], edx

; 1192 : } // end set_inverse_periods_global()

	ret	0
_set_inverse_periods_global ENDP
_TEXT	ENDS
PUBLIC	_set_view_matrix_global
EXTRN	_view:DWORD
EXTRN	_view_matrix_global:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_view_matrix_global
_TEXT	SEGMENT
_set_view_matrix_global PROC				; COMDAT

; 1203 : 
; 1204 :   g = globals(view_matrix_global);

	mov	eax, DWORD PTR _view_matrix_global
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN3@set_view_m
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN5@set_view_m
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN4@set_view_m
$LN5@set_view_m:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN3@set_view_m
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN4@set_view_m
$LN3@set_view_m:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN4@set_view_m:

; 1205 :   g->attr.arrayptr->sizes[0] = SDIM+1;

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [eax+168]
	inc	ecx
	mov	DWORD PTR [edx+24], ecx

; 1206 :   g->attr.arrayptr->sizes[1] = SDIM+1;

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [eax+168]
	inc	ecx
	mov	DWORD PTR [edx+28], ecx

; 1207 :   g->attr.arrayptr->datacount = (SDIM+1)*(SDIM+1);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [eax+168]
	inc	ecx
	imul	ecx, ecx
	mov	DWORD PTR [edx+16], ecx

; 1208 :   g->attr.arrayptr->datastart = 
; 1209 :         (char*)&view[0][0] - (char*)(g->attr.arrayptr);

	mov	ecx, DWORD PTR _view
	mov	eax, DWORD PTR [eax+168]
	mov	edx, DWORD PTR [ecx]
	sub	edx, eax
	mov	DWORD PTR [eax+20], edx

; 1210 : } // end set_view_matrix_global()

	ret	0
_set_view_matrix_global ENDP
_TEXT	ENDS
PUBLIC	_set_eigenvalue_list_global
EXTRN	_eigenvalues_list_global:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_eigenvalue_list_global
_TEXT	SEGMENT
_evalues$ = 8						; size = 4
_count$ = 12						; size = 4
_set_eigenvalue_list_global PROC			; COMDAT

; 1223 : { struct global *g;

	push	ebp
	mov	ebp, esp

; 1224 : 
; 1225 :   g = globals(eigenvalues_list_global);

	mov	eax, DWORD PTR _eigenvalues_list_global
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN3@set_eigenv
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN5@set_eigenv
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN4@set_eigenv
$LN5@set_eigenv:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN3@set_eigenv
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN4@set_eigenv
$LN3@set_eigenv:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN4@set_eigenv:

; 1226 :   g->attr.arrayptr->sizes[0] = count;

	mov	edx, DWORD PTR [eax+168]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 1227 :   g->attr.arrayptr->datacount = count;

	mov	edx, DWORD PTR [eax+168]
	mov	DWORD PTR [edx+16], ecx

; 1228 :   g->attr.arrayptr->datastart = 
; 1229 :         (char*)evalues - (char*)(g->attr.arrayptr);

	mov	eax, DWORD PTR [eax+168]
	mov	ecx, DWORD PTR _evalues$[ebp]
	sub	ecx, eax
	mov	DWORD PTR [eax+20], ecx

; 1230 : } // end set_eigenvalue_list_global()

	pop	ebp
	ret	0
_set_eigenvalue_list_global ENDP
_TEXT	ENDS
PUBLIC	_get_name_arrayptr
; Function compile flags: /Ogtp
;	COMDAT _get_name_arrayptr
_TEXT	SEGMENT
_name_id$ = 8						; size = 4
_newstack$ = 12						; size = 4
_localbase$ = 16					; size = 4
_get_name_arrayptr PROC					; COMDAT

; 1245 : {

	push	ebp
	mov	ebp, esp

; 1246 :   if ( (name_id & GTYPEMASK) == ATTRIBNAME )

	mov	eax, DWORD PTR _name_id$[ebp]
	mov	ecx, eax
	and	ecx, -268435456				; f0000000H
	cmp	ecx, 1073741824				; 40000000H
	jne	SHORT $LN4@get_name_a

; 1247 :   { struct extra *ex = EXTRAS(name_eltype(name_id)) + (name_id & GLOBMASK);
; 1248 :     return &(ex->array_spec);

	mov	edx, eax
	sar	edx, 24					; 00000018H
	and	edx, 15					; 0000000fH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+104]
	mov	edx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	imul	eax, 240				; 000000f0H
	add	ecx, eax
	lea	eax, DWORD PTR [ecx+edx+72]

; 1258 :   }
; 1259 : 
; 1260 :   return NULL; /* just to keep some compilers happy */
; 1261 : } // end get_name_arrayptr()

	pop	ebp
	ret	0
$LN4@get_name_a:

; 1249 :   }
; 1250 :   else /* regular global */
; 1251 :   { struct global *g;
; 1252 :     g = globals(name_id);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN7@get_name_a
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN9@get_name_a
	mov	ecx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN8@get_name_a
$LN9@get_name_a:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN7@get_name_a
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN8@get_name_a
$LN7@get_name_a:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN8@get_name_a:

; 1253 :  
; 1254 :     if ( newstack && ((g->flags & (GLOB_LOCALVAR|FIXED_SIZE_ARRAY))==GLOB_LOCALVAR) )

	mov	ecx, DWORD PTR _newstack$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@get_name_a
	mov	edx, DWORD PTR [eax+192]
	and	edx, 268959744				; 10080000H
	cmp	edx, 524288				; 00080000H
	jne	SHORT $LN2@get_name_a

; 1255 :        return *(struct array **)(newstack+g->value.offset);

	mov	eax, DWORD PTR [eax+64]
	mov	eax, DWORD PTR [ecx+eax*8]

; 1258 :   }
; 1259 : 
; 1260 :   return NULL; /* just to keep some compilers happy */
; 1261 : } // end get_name_arrayptr()

	pop	ebp
	ret	0
$LN2@get_name_a:

; 1256 :     else
; 1257 :        return g->attr.arrayptr;

	mov	eax, DWORD PTR [eax+168]

; 1258 :   }
; 1259 : 
; 1260 :   return NULL; /* just to keep some compilers happy */
; 1261 : } // end get_name_arrayptr()

	pop	ebp
	ret	0
_get_name_arrayptr ENDP
_TEXT	ENDS
PUBLIC	_get_name_name
; Function compile flags: /Ogtp
;	COMDAT _get_name_name
_TEXT	SEGMENT
_name_id$ = 8						; size = 4
_localbase$ = 12					; size = 4
_get_name_name PROC					; COMDAT

; 1271 : {

	push	ebp
	mov	ebp, esp

; 1272 :   if ( (name_id & GTYPEMASK) == ATTRIBNAME )

	mov	ecx, DWORD PTR _name_id$[ebp]
	mov	eax, ecx
	and	eax, -268435456				; f0000000H
	cmp	eax, 1073741824				; 40000000H
	jne	SHORT $LN2@get_name_n

; 1273 :   { struct extra *ex = EXTRAS(name_eltype(name_id)) + (name_id & GLOBMASK);
; 1274 :     return ex->name;

	mov	edx, ecx
	sar	edx, 24					; 00000018H
	and	edx, 15					; 0000000fH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+104]
	and	ecx, 16777215				; 00ffffffH
	imul	ecx, 240				; 000000f0H
	add	eax, ecx
	add	eax, DWORD PTR _dymem

; 1279 :     return g->name;
; 1280 :   }
; 1281 : 
; 1282 :   return NULL;  /* just to keep some compilers happy */
; 1283 : } // end get_name_name()

	pop	ebp
	ret	0
$LN2@get_name_n:

; 1275 :   }
; 1276 :   else /* regular global */
; 1277 :   { struct global *g;
; 1278 :     g = globals(name_id);

	mov	eax, ecx
	and	eax, -16777216				; ff000000H
	cmp	eax, 268435456				; 10000000H
	je	SHORT $LN5@get_name_n
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN7@get_name_n
	mov	eax, DWORD PTR _localbase$[ebp]
	and	ecx, 16777215				; 00ffffffH
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [eax]
	mov	eax, ecx

; 1279 :     return g->name;
; 1280 :   }
; 1281 : 
; 1282 :   return NULL;  /* just to keep some compilers happy */
; 1283 : } // end get_name_name()

	pop	ebp
	ret	0
$LN7@get_name_n:

; 1275 :   }
; 1276 :   else /* regular global */
; 1277 :   { struct global *g;
; 1278 :     g = globals(name_id);

	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN5@get_name_n
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]

; 1279 :     return g->name;
; 1280 :   }
; 1281 : 
; 1282 :   return NULL;  /* just to keep some compilers happy */
; 1283 : } // end get_name_name()

	pop	ebp
	ret	0
$LN5@get_name_n:

; 1275 :   }
; 1276 :   else /* regular global */
; 1277 :   { struct global *g;
; 1278 :     g = globals(name_id);

	mov	eax, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [ecx+edx]

; 1279 :     return g->name;
; 1280 :   }
; 1281 : 
; 1282 :   return NULL;  /* just to keep some compilers happy */
; 1283 : } // end get_name_name()

	pop	ebp
	ret	0
_get_name_name ENDP
_TEXT	ENDS
PUBLIC	_get_name_dim
; Function compile flags: /Ogtp
;	COMDAT _get_name_dim
_TEXT	SEGMENT
_name_id$ = 8						; size = 4
_localbase$ = 12					; size = 4
_get_name_dim PROC					; COMDAT

; 1293 : {

	push	ebp
	mov	ebp, esp

; 1294 :   if ( (name_id & GTYPEMASK) == ATTRIBNAME )

	mov	eax, DWORD PTR _name_id$[ebp]
	mov	ecx, eax
	and	ecx, -268435456				; f0000000H
	cmp	ecx, 1073741824				; 40000000H
	jne	SHORT $LN2@get_name_d

; 1295 :   { struct extra *ex = EXTRAS(name_eltype(name_id)) + (name_id & GLOBMASK);
; 1296 :     return ex->array_spec.dim;

	mov	ecx, DWORD PTR _dymem
	mov	edx, eax
	sar	edx, 24					; 00000018H
	and	eax, 16777215				; 00ffffffH
	and	edx, 15					; 0000000fH
	imul	eax, 240				; 000000f0H
	imul	edx, 112				; 00000070H
	add	eax, DWORD PTR _web[edx+104]
	mov	eax, DWORD PTR [eax+ecx+76]

; 1302 :   }
; 1303 : 
; 1304 :   return 0;  /* just to keep some compilers happy */
; 1305 : } // end get_name_dim()

	pop	ebp
	ret	0
$LN2@get_name_d:

; 1297 :   }
; 1298 :   else /* regular global */
; 1299 :   { struct global *g;
; 1300 :     g = globals(name_id);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN5@get_name_d
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN7@get_name_d
	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]

; 1301 :     return g->attr.arrayptr->dim;

	mov	edx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR [edx+4]

; 1302 :   }
; 1303 : 
; 1304 :   return 0;  /* just to keep some compilers happy */
; 1305 : } // end get_name_dim()

	pop	ebp
	ret	0
$LN7@get_name_d:

; 1297 :   }
; 1298 :   else /* regular global */
; 1299 :   { struct global *g;
; 1300 :     g = globals(name_id);

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN5@get_name_d
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]

; 1301 :     return g->attr.arrayptr->dim;

	mov	edx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR [edx+4]

; 1302 :   }
; 1303 : 
; 1304 :   return 0;  /* just to keep some compilers happy */
; 1305 : } // end get_name_dim()

	pop	ebp
	ret	0
$LN5@get_name_d:

; 1297 :   }
; 1298 :   else /* regular global */
; 1299 :   { struct global *g;
; 1300 :     g = globals(name_id);

	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]

; 1301 :     return g->attr.arrayptr->dim;

	mov	edx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR [edx+4]

; 1302 :   }
; 1303 : 
; 1304 :   return 0;  /* just to keep some compilers happy */
; 1305 : } // end get_name_dim()

	pop	ebp
	ret	0
_get_name_dim ENDP
_TEXT	ENDS
PUBLIC	_get_name_datatype
; Function compile flags: /Ogtp
;	COMDAT _get_name_datatype
_TEXT	SEGMENT
_name_id$ = 8						; size = 4
_localbase$ = 12					; size = 4
_get_name_datatype PROC					; COMDAT

; 1315 : {

	push	ebp
	mov	ebp, esp

; 1316 :   if ( (name_id & GTYPEMASK) == ATTRIBNAME )

	mov	eax, DWORD PTR _name_id$[ebp]
	mov	ecx, eax
	and	ecx, -268435456				; f0000000H
	cmp	ecx, 1073741824				; 40000000H
	jne	SHORT $LN2@get_name_d@2

; 1317 :   { struct extra *ex = EXTRAS(name_eltype(name_id)) + (name_id & GLOBMASK);
; 1318 :     return ex->array_spec.datatype;

	mov	ecx, DWORD PTR _dymem
	mov	edx, eax
	sar	edx, 24					; 00000018H
	and	eax, 16777215				; 00ffffffH
	and	edx, 15					; 0000000fH
	imul	eax, 240				; 000000f0H
	imul	edx, 112				; 00000070H
	add	eax, DWORD PTR _web[edx+104]
	mov	eax, DWORD PTR [eax+ecx+80]

; 1324 :   }
; 1325 : 
; 1326 :   return 0; /* just to keep some compilers happy */
; 1327 : } // end get_name_datatype()

	pop	ebp
	ret	0
$LN2@get_name_d@2:

; 1319 :   }
; 1320 :   else /* regular global */
; 1321 :   { struct global *g;
; 1322 :     g = globals(name_id);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN5@get_name_d@2
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN7@get_name_d@2
	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]

; 1323 :     return g->type;

	mov	eax, DWORD PTR [eax+200]

; 1324 :   }
; 1325 : 
; 1326 :   return 0; /* just to keep some compilers happy */
; 1327 : } // end get_name_datatype()

	pop	ebp
	ret	0
$LN7@get_name_d@2:

; 1319 :   }
; 1320 :   else /* regular global */
; 1321 :   { struct global *g;
; 1322 :     g = globals(name_id);

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN5@get_name_d@2
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]

; 1323 :     return g->type;

	mov	eax, DWORD PTR [eax+200]

; 1324 :   }
; 1325 : 
; 1326 :   return 0; /* just to keep some compilers happy */
; 1327 : } // end get_name_datatype()

	pop	ebp
	ret	0
$LN5@get_name_d@2:

; 1319 :   }
; 1320 :   else /* regular global */
; 1321 :   { struct global *g;
; 1322 :     g = globals(name_id);

	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]

; 1323 :     return g->type;

	mov	eax, DWORD PTR [eax+200]

; 1324 :   }
; 1325 : 
; 1326 :   return 0; /* just to keep some compilers happy */
; 1327 : } // end get_name_datatype()

	pop	ebp
	ret	0
_get_name_datatype ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _insert_hash_entry
_TEXT	SEGMENT
_hashval$ = 8						; size = 4
_key$ = 12						; size = 4
_insert_hash_entry PROC					; COMDAT

; 191  : { int spot;

	push	ebp
	mov	ebp, esp

; 192  : 
; 193  :   if ( hash_used >= hash_alloc )

	mov	eax, DWORD PTR _hash_used
	cmp	eax, DWORD PTR _hash_alloc
	jl	SHORT $LN3@insert_has

; 194  :     expand_global_hash();

	call	_expand_global_hash
$LN3@insert_has:
	push	esi

; 195  : 
; 196  :   spot = hashval % (unsigned int)hash_alloc;

	mov	esi, DWORD PTR _hashval$[ebp]
	xor	edx, edx
	mov	eax, esi
	div	DWORD PTR _hash_alloc

; 197  :   if ( hash_list[spot].key )

	lea	ecx, DWORD PTR [edx+edx*2]
	mov	edx, DWORD PTR _hash_list
	add	ecx, ecx
	add	ecx, ecx
	cmp	DWORD PTR [ecx+edx], 0
	je	SHORT $LN2@insert_has

; 198  :   { // to the bucket list
; 199  :     int bucket_spot = bucket_free_head;

	mov	eax, DWORD PTR _bucket_free_head
	push	ebx

; 200  :     bucket_free_head = bucket_list[bucket_free_head].next;

	mov	ebx, DWORD PTR _bucket_list
	push	edi
	mov	edi, eax
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	mov	ebx, DWORD PTR [eax+ebx+8]
	mov	DWORD PTR _bucket_free_head, ebx

; 201  :     bucket_list[bucket_spot].next = hash_list[spot].next;

	mov	edx, DWORD PTR [ecx+edx+8]
	mov	ebx, DWORD PTR _bucket_list
	mov	DWORD PTR [eax+ebx+8], edx

; 202  :     bucket_list[bucket_spot].key = key;

	mov	edx, DWORD PTR _bucket_list
	mov	ebx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [eax+edx], ebx

; 203  :     bucket_list[bucket_spot].hashval = hashval;

	mov	edx, DWORD PTR _bucket_list
	mov	DWORD PTR [eax+edx+4], esi

; 204  :     hash_list[spot].next = bucket_spot;

	mov	eax, DWORD PTR _hash_list
	mov	DWORD PTR [ecx+eax+8], edi

; 209  :   }
; 210  :   hash_used++;

	inc	DWORD PTR _hash_used
	pop	edi
	pop	ebx
	pop	esi

; 211  : 
; 212  : } // end insert_hash_entry()

	pop	ebp
	ret	0
$LN2@insert_has:

; 205  :   }
; 206  :   else
; 207  :   { hash_list[spot].key = key;

	mov	eax, DWORD PTR _key$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 208  :     hash_list[spot].hashval = hashval;

	mov	edx, DWORD PTR _hash_list
	mov	DWORD PTR [ecx+edx+4], esi

; 209  :   }
; 210  :   hash_used++;

	inc	DWORD PTR _hash_used
	pop	esi

; 211  : 
; 212  : } // end insert_hash_entry()

	pop	ebp
	ret	0
_insert_hash_entry ENDP
_TEXT	ENDS
PUBLIC	_lookup_global_hash
EXTRN	_kb_stricmp:PROC
EXTRN	_gen_quant_list:DWORD
EXTRN	_meth_inst_list:DWORD
; Function compile flags: /Ogtp
;	COMDAT _lookup_global_hash
_TEXT	SEGMENT
_name$ = 8						; size = 4
_hashval$ = 12						; size = 4
_inx$ = 12						; size = 4
_key$ = 16						; size = 4
_type$ = 16						; size = 4
_addflag$ = 20						; size = 4
_lookup_global_hash PROC				; COMDAT

; 317  : { hash_t hashval;

	push	ebp
	mov	ebp, esp
	push	ebx

; 318  :   int spot;
; 319  :   struct hash_entry_t *entry,*prev_entry;
; 320  :   int key = type | inx;

	mov	ebx, DWORD PTR _inx$[ebp]
	or	ebx, DWORD PTR _type$[ebp]
	push	edi

; 321  : 
; 322  :   hashval = global_hash(name);

	mov	edi, DWORD PTR _name$[ebp]
	push	edi
	mov	DWORD PTR _key$[ebp], ebx
	call	_global_hash

; 323  : 
; 324  :   if ( hash_alloc == 0 )

	mov	ecx, DWORD PTR _hash_alloc
	add	esp, 4
	mov	DWORD PTR _hashval$[ebp], eax
	test	ecx, ecx
	jne	SHORT $LN24@lookup_glo

; 325  :   { if ( addflag == HASH_ADD )

	cmp	DWORD PTR _addflag$[ebp], 1
	jne	SHORT $LN23@lookup_glo

; 326  :       insert_hash_entry(hashval,key);

	push	ebx
	push	eax
	call	_insert_hash_entry
	add	esp, 8
$LN23@lookup_glo:

; 327  :     return 0;

	pop	edi
	xor	eax, eax
	pop	ebx

; 394  : 
; 395  : } // end lookup_global_hash

	pop	ebp
	ret	0
$LN24@lookup_glo:

; 328  :   }
; 329  : 
; 330  :   spot = hashval % (unsigned int)hash_alloc;

	xor	edx, edx
	div	ecx

; 331  :   entry = hash_list + spot;

	mov	ecx, DWORD PTR _hash_list
	push	esi
	lea	eax, DWORD PTR [edx+edx*2]

; 332  :   if ( entry->hashval == 0 )

	cmp	DWORD PTR [ecx+eax*4+4], 0
	lea	esi, DWORD PTR [ecx+eax*4]
	jne	SHORT $LN22@lookup_glo

; 333  :     { // empty slot
; 334  :        if ( addflag == HASH_ADD )

	cmp	DWORD PTR _addflag$[ebp], 1
	jne	$LN1@lookup_glo

; 335  :          insert_hash_entry(hashval,key);

	mov	edx, DWORD PTR _hashval$[ebp]
	push	ebx
	push	edx

; 386  :          insert_hash_entry(hashval,key);

	call	_insert_hash_entry
	add	esp, 8
	pop	esi
	pop	edi

; 387  :       return 0;

	xor	eax, eax
	pop	ebx

; 394  : 
; 395  : } // end lookup_global_hash

	pop	ebp
	ret	0
$LN22@lookup_glo:

; 336  :        return 0;
; 337  :     }
; 338  : 
; 339  :   prev_entry = NULL;

	xor	ebx, ebx
	npad	11
$LL20@lookup_glo:

; 340  :   for (;;)
; 341  :   { 
; 342  :     if ( entry->hashval == hashval )

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR _hashval$[ebp]
	jne	$LN11@lookup_glo

; 343  :       switch   ( entry->key & NAMETYPEMASK )

	mov	eax, DWORD PTR [esi]
	mov	ecx, eax
	and	ecx, -536870912				; e0000000H
	cmp	ecx, 1610612736				; 60000000H
	ja	$LN33@lookup_glo
	je	$LN9@lookup_glo
	cmp	ecx, 536870912				; 20000000H
	je	SHORT $LN15@lookup_glo
	cmp	ecx, 1073741824				; 40000000H
	jne	$LN11@lookup_glo

; 368  : 
; 369  :       case METHODNAME:
; 370  :         if ( stricmp(name,METH_INSTANCE(entry->key & INDEXMASK)->name) == 0 )

	and	eax, 536870911				; 1fffffffH
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list
	push	eax

; 371  :         { if ( addflag == HASH_DELETE ) 
; 372  :              hash_delete(entry,prev_entry);
; 373  :           return entry->key;  
; 374  :         }
; 375  :         break;

	jmp	$LN44@lookup_glo
$LN15@lookup_glo:

; 344  :       { 
; 345  :         case VARIABLENAME:
; 346  :         if ( stricmp(name,globals((entry->key & INDEXMASK)|EPHGLOBAL)->name) == 0 )

	mov	ecx, eax
	and	ecx, 251658240				; 0f000000H
	or	ecx, 268435456				; 10000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN27@lookup_glo
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN29@lookup_glo
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	push	eax

; 347  :         { if ( addflag == HASH_DELETE )
; 348  :             hash_delete(entry,prev_entry);
; 349  :           return entry->key;       
; 350  :         }
; 351  :         break;

	jmp	SHORT $LN44@lookup_glo
$LN29@lookup_glo:

; 344  :       { 
; 345  :         case VARIABLENAME:
; 346  :         if ( stricmp(name,globals((entry->key & INDEXMASK)|EPHGLOBAL)->name) == 0 )

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN27@lookup_glo
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	push	eax

; 347  :         { if ( addflag == HASH_DELETE )
; 348  :             hash_delete(entry,prev_entry);
; 349  :           return entry->key;       
; 350  :         }
; 351  :         break;

	jmp	SHORT $LN44@lookup_glo
$LN27@lookup_glo:

; 344  :       { 
; 345  :         case VARIABLENAME:
; 346  :         if ( stricmp(name,globals((entry->key & INDEXMASK)|EPHGLOBAL)->name) == 0 )

	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
	push	eax

; 347  :         { if ( addflag == HASH_DELETE )
; 348  :             hash_delete(entry,prev_entry);
; 349  :           return entry->key;       
; 350  :         }
; 351  :         break;

	jmp	SHORT $LN44@lookup_glo
$LN9@lookup_glo:

; 358  :         }
; 359  :         break;
; 360  : 
; 361  :       case QUANTITYNAME:
; 362  :         if ( stricmp(name,GEN_QUANT(entry->key & INDEXMASK)->name) == 0 )

	and	eax, 536870911				; 1fffffffH
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list
	push	eax

; 363  :         { if ( addflag == HASH_DELETE )
; 364  :              hash_delete(entry,prev_entry);
; 365  :           return entry->key;  
; 366  :         }
; 367  :         break;

	jmp	SHORT $LN44@lookup_glo
$LN33@lookup_glo:

; 343  :       switch   ( entry->key & NAMETYPEMASK )

	cmp	ecx, -2147483648			; 80000000H

; 376  : 
; 377  :       default:  
; 378  : 
; 379  :        break;

	jne	SHORT $LN11@lookup_glo

; 352  :       
; 353  :       case PERM_NAME:
; 354  :         if ( stricmp(name,perm_globals((entry->key & INDEXMASK)|PERMGLOBAL)->name) == 0 )

	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
$LN44@lookup_glo:
	push	edi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN39@lookup_glo
$LN11@lookup_glo:

; 380  :           
; 381  :       } // end switch
; 382  : 
; 383  :     // see if we need to keep going
; 384  :     if ( entry->next == 0 ) // empty slot

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN40@lookup_glo

; 388  :     }
; 389  :     /* have to keep searching */
; 390  :     prev_entry = entry;
; 391  :     entry = bucket_list + entry->next;

	mov	ecx, DWORD PTR _bucket_list
	lea	eax, DWORD PTR [eax+eax*2]
	mov	ebx, esi
	lea	esi, DWORD PTR [ecx+eax*4]

; 392  : 
; 393  :   } // end for

	jmp	$LL20@lookup_glo
$LN39@lookup_glo:

; 355  :         { if ( addflag == HASH_DELETE )

	cmp	DWORD PTR _addflag$[ebp], 2
	jne	SHORT $LN10@lookup_glo

; 356  :              hash_delete(entry,prev_entry);

	push	ebx
	push	esi
	call	_hash_delete
	add	esp, 8
$LN10@lookup_glo:

; 357  :           return entry->key;  

	mov	eax, DWORD PTR [esi]
	pop	esi
	pop	edi
	pop	ebx

; 394  : 
; 395  : } // end lookup_global_hash

	pop	ebp
	ret	0
$LN40@lookup_glo:

; 385  :     { if ( addflag == HASH_ADD )

	cmp	DWORD PTR _addflag$[ebp], 1
	jne	SHORT $LN1@lookup_glo

; 386  :          insert_hash_entry(hashval,key);

	mov	edx, DWORD PTR _key$[ebp]
	mov	eax, DWORD PTR _hashval$[ebp]
	push	edx
	push	eax
	call	_insert_hash_entry
	add	esp, 8
$LN1@lookup_glo:

; 387  :       return 0;

	pop	esi
	pop	edi
	xor	eax, eax
	pop	ebx

; 394  : 
; 395  : } // end lookup_global_hash

	pop	ebp
	ret	0
_lookup_global_hash ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@FIDGPEE@The?5name?5?$CC?$CFs?$CC?5is?5already?5in?5use?$CF@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BL@BLGEHEPG@?5as?5a?5method?5instance?5name?$AA@ ; `string'
PUBLIC	??_C@_0BF@LPCFHCF@?5as?5a?5permanent?5name?$AA@	; `string'
PUBLIC	??_C@_0BE@IBMOPENK@?5as?5a?5quantity?5name?$AA@	; `string'
PUBLIC	??_C@_0CB@KCJGMFDD@Name?5too?5long?4?5Truncated?5to?5?$CFs?4?6@ ; `string'
PUBLIC	_add_global
EXTRN	_dy_realloc:PROC
EXTRN	_Globals:DWORD
EXTRN	_dy_calloc:PROC
;	COMDAT ??_C@_0CE@FIDGPEE@The?5name?5?$CC?$CFs?$CC?5is?5already?5in?5use?$CF@
CONST	SEGMENT
??_C@_0CE@FIDGPEE@The?5name?5?$CC?$CFs?$CC?5is?5already?5in?5use?$CF@ DB 'T'
	DB	'he name "%s" is already in use%s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BLGEHEPG@?5as?5a?5method?5instance?5name?$AA@
CONST	SEGMENT
??_C@_0BL@BLGEHEPG@?5as?5a?5method?5instance?5name?$AA@ DB ' as a method '
	DB	'instance name', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LPCFHCF@?5as?5a?5permanent?5name?$AA@
CONST	SEGMENT
??_C@_0BF@LPCFHCF@?5as?5a?5permanent?5name?$AA@ DB ' as a permanent name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IBMOPENK@?5as?5a?5quantity?5name?$AA@
CONST	SEGMENT
??_C@_0BE@IBMOPENK@?5as?5a?5quantity?5name?$AA@ DB ' as a quantity name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KCJGMFDD@Name?5too?5long?4?5Truncated?5to?5?$CFs?4?6@
CONST	SEGMENT
??_C@_0CB@KCJGMFDD@Name?5too?5long?4?5Truncated?5to?5?$CFs?4?6@ DB 'Name '
	DB	'too long. Truncated to %s.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _add_global
_TEXT	SEGMENT
_slot$ = -4						; size = 4
_name$ = 8						; size = 4
_add_global PROC					; COMDAT

; 425  : { 

	push	ebp
	mov	ebp, esp
	push	ecx

; 426  :   int slot;
; 427  :   int inx;   /* index in global table */
; 428  :   struct global *g;
; 429  :   ident_t iid;
; 430  : 
; 431  :   if ( web.maxglobals == 0 ) /* very first initialization */

	cmp	DWORD PTR _web+5544, 0
	jne	SHORT $LN5@add_global

; 432  :   { web.maxglobals = 100;
; 433  :     dy_globals = dy_calloc(web.maxglobals,sizeof(struct global*));

	push	4
	push	100					; 00000064H
	mov	DWORD PTR _web+5544, 100		; 00000064H
	call	_dy_calloc

; 434  :     Globals = (struct global **)(dymem + dy_globals); 

	mov	ecx, DWORD PTR _dymem
	add	esp, 8
	add	ecx, eax
	mov	DWORD PTR _web+5652, eax
	mov	DWORD PTR _Globals, ecx
$LN5@add_global:

; 435  :   }
; 436  : 
; 437  :   slot = web.global_count;

	push	ebx
	push	esi
	mov	esi, DWORD PTR _web+5540

; 438  :   iid = slot | EPHGLOBAL;
; 439  :   Globals[slot] = (struct global*)mycalloc(1,sizeof(struct global));

	push	439					; 000001b7H
	push	OFFSET ??_C@_0L@LGDGPOBJ@SYMTABLE?4C?$AA@
	push	208					; 000000d0H
	mov	ebx, esi
	push	1
	mov	DWORD PTR _slot$[ebp], esi
	or	ebx, 268435456				; 10000000H
	call	_kb_calloc
	mov	edx, DWORD PTR _Globals
	mov	DWORD PTR [edx+esi*4], eax

; 440  :   g = globals(iid);

	mov	eax, ebx
	and	eax, -16777216				; ff000000H
	add	esp, 16					; 00000010H
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN12@add_global
	mov	ecx, DWORD PTR _dymem
	mov	eax, ebx
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+5652
	mov	esi, DWORD PTR [edx+eax]
	jmp	SHORT $LN9@add_global
$LN12@add_global:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN10@add_global
	mov	ecx, DWORD PTR _localbase
	mov	esi, ebx
	and	esi, 16777215				; 00ffffffH
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [ecx]
	jmp	SHORT $LN9@add_global
$LN10@add_global:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN8@add_global
	mov	eax, DWORD PTR _web+5656
	mov	edx, ebx
	and	edx, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN9@add_global
$LN8@add_global:
	mov	edx, DWORD PTR _dymem
	mov	ecx, ebx
	and	ecx, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+5652
	mov	esi, DWORD PTR [eax+ecx]
$LN9@add_global:

; 441  :   memset((char*)g,0,sizeof(struct global));

	push	edi
	push	208					; 000000d0H
	push	0
	push	esi
	call	_memset

; 442  :   strncpy(g->name,name,GLOBAL_NAME_SIZE);

	mov	edi, DWORD PTR _name$[ebp]
	push	63					; 0000003fH
	push	edi
	push	esi
	call	_strncpy

; 443  :   g->flags |= GLOB_USED;
; 444  :   
; 445  :   if ( strlen(name) > GLOBAL_NAME_SIZE )

	mov	eax, edi
	add	esp, 24					; 00000018H
	or	DWORD PTR [esi+192], 32			; 00000020H
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL20@add_global:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL20@add_global
	sub	eax, edx
	cmp	eax, 63					; 0000003fH
	jbe	SHORT $LN4@add_global

; 446  :   { name[GLOBAL_NAME_SIZE] = 0;
; 447  :     sprintf(errmsg,"Name too long. Truncated to %s.\n",name);

	push	edi
	push	OFFSET ??_C@_0CB@KCJGMFDD@Name?5too?5long?4?5Truncated?5to?5?$CFs?4?6@
	push	OFFSET _errmsg
	mov	BYTE PTR [edi+63], cl
	call	_sprintf

; 448  :     kb_error(1669,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1669					; 00000685H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN4@add_global:

; 449  :   }
; 450  : 
; 451  :   /* see if already existed */
; 452  :   inx = lookup_global_hash(name,slot,VARIABLENAME,HASH_ADD);

	mov	edx, DWORD PTR _slot$[ebp]
	push	1
	push	536870912				; 20000000H
	push	edx
	push	edi
	call	_lookup_global_hash
	add	esp, 16					; 00000010H

; 453  :   if ( inx ) /* already there */

	test	eax, eax
	je	SHORT $LN3@add_global

; 454  :   { sprintf(errmsg,"The name \"%s\" is already in use%s.\n",name,
; 455  :       (inx&NAMETYPEMASK)==QUANTITYNAME ? " as a quantity name" :  
; 456  :       (inx&NAMETYPEMASK)==PERM_NAME ? " as a permanent name" :  
; 457  :       (inx&NAMETYPEMASK)==METHODNAME ? " as a method instance name" : "");

	and	eax, -536870912				; e0000000H
	cmp	eax, 1610612736				; 60000000H
	jne	SHORT $LN18@add_global
	mov	eax, OFFSET ??_C@_0BE@IBMOPENK@?5as?5a?5quantity?5name?$AA@
	jmp	SHORT $LN15@add_global
$LN18@add_global:
	cmp	eax, -2147483648			; 80000000H
	jne	SHORT $LN16@add_global
	mov	eax, OFFSET ??_C@_0BF@LPCFHCF@?5as?5a?5permanent?5name?$AA@
	jmp	SHORT $LN15@add_global
$LN16@add_global:
	cmp	eax, 1073741824				; 40000000H
	mov	eax, OFFSET ??_C@_0BL@BLGEHEPG@?5as?5a?5method?5instance?5name?$AA@
	je	SHORT $LN15@add_global
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN15@add_global:
	push	eax
	push	edi
	push	OFFSET ??_C@_0CE@FIDGPEE@The?5name?5?$CC?$CFs?$CC?5is?5already?5in?5use?$CF@
	push	OFFSET _errmsg
	call	_sprintf

; 458  :     kb_error(2554,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2554					; 000009faH
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN2@add_global
$LN3@add_global:

; 459  :   }
; 460  :   else web.global_count++;

	inc	DWORD PTR _web+5540
$LN2@add_global:

; 461  : 
; 462  :   /* see if we want to expand */
; 463  :   if ( web.global_count == web.maxglobals )

	mov	eax, DWORD PTR _web+5544
	pop	edi
	cmp	DWORD PTR _web+5540, eax
	jne	SHORT $LN21@add_global

; 464  :   { 
; 465  :      web.maxglobals *= 2;

	add	eax, eax

; 466  :      dy_globals = dy_realloc(dy_globals,web.maxglobals,sizeof(struct global *));

	push	4
	push	eax
	mov	DWORD PTR _web+5544, eax
	mov	eax, DWORD PTR _web+5652
	push	eax
	call	_dy_realloc

; 467  :      Globals = (struct global **)(dymem + dy_globals);

	mov	ecx, DWORD PTR _dymem
	add	esp, 12					; 0000000cH
	add	ecx, eax
	mov	DWORD PTR _web+5652, eax
	mov	DWORD PTR _Globals, ecx
$LN21@add_global:

; 468  :   }
; 469  : 
; 470  :   return iid; 

	pop	esi
	mov	eax, ebx
	pop	ebx

; 471  : } // end add_global()

	mov	esp, ebp
	pop	ebp
	ret	0
_add_global ENDP
_TEXT	ENDS
PUBLIC	_lookup_global
; Function compile flags: /Ogtp
;	COMDAT _lookup_global
_TEXT	SEGMENT
_name$ = 8						; size = 4
_lookup_global PROC					; COMDAT

; 484  : { 

	push	ebp
	mov	ebp, esp

; 485  :   int inx;
; 486  : 
; 487  :   if ( web.global_count == 0 ) return -1;

	cmp	DWORD PTR _web+5540, 0
	je	SHORT $LN1@lookup_glo@2

; 488  : 
; 489  :   /* search for name */
; 490  :   inx = lookup_global_hash(name,0,VARIABLENAME,HASH_LOOK);

	mov	eax, DWORD PTR _name$[ebp]
	push	0
	push	536870912				; 20000000H
	push	0
	push	eax
	call	_lookup_global_hash
	add	esp, 16					; 00000010H

; 491  :   if ( inx == 0 ) 

	test	eax, eax

; 492  :     return -1;

	je	SHORT $LN1@lookup_glo@2

; 493  :   if ( (inx & NAMETYPEMASK) == VARIABLENAME )

	mov	ecx, eax
	and	ecx, -536870912				; e0000000H
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN1@lookup_glo@2

; 494  :     return (inx & INDEXMASK) | EPHGLOBAL;

	and	eax, 268435455				; 0fffffffH
	or	eax, 268435456				; 10000000H

; 496  : } // end lookup_global()

	pop	ebp
	ret	0
$LN1@lookup_glo@2:

; 495  :   return -1;

	or	eax, -1

; 496  : } // end lookup_global()

	pop	ebp
	ret	0
_lookup_global ENDP
_TEXT	ENDS
PUBLIC	_rewind_globals
; Function compile flags: /Ogtp
;	COMDAT _rewind_globals
_TEXT	SEGMENT
_rewind_spot$ = 8					; size = 4
_rewind_globals PROC					; COMDAT

; 506  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 507  :   int k;
; 508  :   /* unhash in reverse order of adding */
; 509  :   for ( k = web.global_count-1 ; k >= rewind_spot ; k-- )

	mov	esi, DWORD PTR _web+5540
	push	edi
	mov	edi, DWORD PTR _rewind_spot$[ebp]
	dec	esi
	cmp	esi, edi
	jl	$LN14@rewind_glo
	npad	9
$LL3@rewind_glo:

; 510  :     lookup_global_hash(globals(k)->name,0,0,HASH_DELETE);

	mov	eax, esi
	and	eax, -16777216				; ff000000H
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN10@rewind_glo
	mov	ecx, DWORD PTR _web+5652
	mov	eax, esi
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
	jmp	SHORT $LN7@rewind_glo
$LN10@rewind_glo:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN8@rewind_glo
	mov	ecx, DWORD PTR _localbase
	mov	eax, esi
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN7@rewind_glo
$LN8@rewind_glo:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN6@rewind_glo
	mov	eax, DWORD PTR _web+5656
	mov	edx, esi
	and	edx, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN7@rewind_glo
$LN6@rewind_glo:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx]
$LN7@rewind_glo:
	push	2
	push	0
	push	0
	push	eax
	call	_lookup_global_hash
	dec	esi
	add	esp, 16					; 00000010H
	cmp	esi, edi
	jge	$LL3@rewind_glo
$LN14@rewind_glo:

; 511  :   web.global_count = rewind_spot;

	mov	DWORD PTR _web+5540, edi
	pop	edi
	pop	esi

; 512  : } // end rewind_globals()

	pop	ebp
	ret	0
_rewind_globals ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@IOPCLAIM@?5as?5a?5variable?5name?$AA@	; `string'
PUBLIC	_add_perm_global
EXTRN	_perm_Globals:DWORD
;	COMDAT ??_C@_0BE@IOPCLAIM@?5as?5a?5variable?5name?$AA@
CONST	SEGMENT
??_C@_0BE@IOPCLAIM@?5as?5a?5variable?5name?$AA@ DB ' as a variable name', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _add_perm_global
_TEXT	SEGMENT
_name$ = 8						; size = 4
_add_perm_global PROC					; COMDAT

; 532  : { 

	push	ebp
	mov	ebp, esp

; 533  :   int slot;
; 534  :   int inx;   /* index in global table */
; 535  : 
; 536  :   if ( web.max_perm_globals == 0 ) /* very first initialization */

	cmp	DWORD PTR _web+5552, 0
	jne	SHORT $LN15@add_perm_g

; 537  :   { web.max_perm_globals = 100;
; 538  :     dy_perm_globals = calloc(web.max_perm_globals,sizeof(struct global*));

	push	4
	push	100					; 00000064H
	mov	DWORD PTR _web+5552, 100		; 00000064H
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _web+5656, eax

; 539  :     perm_Globals = dy_perm_globals;  

	mov	DWORD PTR _perm_Globals, eax
$LN15@add_perm_g:

; 540  :   }
; 541  : 
; 542  :   slot = web.perm_global_count;

	push	ebx
	mov	ebx, DWORD PTR _web+5548
	push	esi
	push	edi

; 543  :   perm_Globals[slot] = calloc(1,sizeof(struct global));

	push	208					; 000000d0H
	push	1
	call	_calloc
	mov	ecx, DWORD PTR _perm_Globals

; 544  :   strncpy(perm_globals(slot)->name,name,GLOBAL_NAME_SIZE);

	mov	edi, DWORD PTR _name$[ebp]
	mov	esi, ebx
	and	esi, 16777215				; 00ffffffH
	mov	DWORD PTR [ecx+ebx*4], eax
	mov	edx, DWORD PTR _web+5656
	add	esi, esi
	push	63					; 0000003fH
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	push	edi
	push	eax
	call	_strncpy

; 545  :   perm_globals(slot)->flags |= GLOB_USED|PERMANENT;

	mov	ecx, DWORD PTR _web+5656
	mov	esi, DWORD PTR [esi+ecx]

; 546  :   
; 547  :   if ( strlen(name) > GLOBAL_NAME_SIZE )

	mov	eax, edi
	add	esp, 20					; 00000014H
	or	DWORD PTR [esi+192], 48			; 00000030H
	lea	edx, DWORD PTR [eax+1]
$LL14@add_perm_g:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL14@add_perm_g
	sub	eax, edx
	cmp	eax, 63					; 0000003fH
	jbe	SHORT $LN4@add_perm_g

; 548  :   { name[GLOBAL_NAME_SIZE] = 0; 
; 549  :     sprintf(errmsg,"Name too long. Truncated to %s.\n",name);

	push	edi
	push	OFFSET ??_C@_0CB@KCJGMFDD@Name?5too?5long?4?5Truncated?5to?5?$CFs?4?6@
	push	OFFSET _errmsg
	mov	BYTE PTR [edi+63], cl
	call	_sprintf

; 550  :     kb_error(2584,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2584					; 00000a18H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN4@add_perm_g:

; 551  :   }
; 552  : 
; 553  :   /* see if already existed */
; 554  :   inx = lookup_global_hash(name,slot,PERM_NAME,HASH_ADD);

	push	1
	push	-2147483648				; 80000000H
	push	ebx
	push	edi
	call	_lookup_global_hash
	add	esp, 16					; 00000010H

; 555  :   if ( inx ) /* already there */

	test	eax, eax
	je	SHORT $LN3@add_perm_g

; 556  :   { sprintf(errmsg,"The name \"%s\" is already in use%s.\n",name,
; 557  :       (inx&NAMETYPEMASK)==QUANTITYNAME ? " as a quantity name" :  
; 558  :       (inx&NAMETYPEMASK)==VARIABLENAME ? " as a variable name" :  
; 559  :       (inx&NAMETYPEMASK)==METHODNAME ? " as a method instance name" : "");

	and	eax, -536870912				; e0000000H
	cmp	eax, 1610612736				; 60000000H
	jne	SHORT $LN12@add_perm_g
	mov	eax, OFFSET ??_C@_0BE@IBMOPENK@?5as?5a?5quantity?5name?$AA@
	jmp	SHORT $LN9@add_perm_g
$LN12@add_perm_g:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN10@add_perm_g
	mov	eax, OFFSET ??_C@_0BE@IOPCLAIM@?5as?5a?5variable?5name?$AA@
	jmp	SHORT $LN9@add_perm_g
$LN10@add_perm_g:
	cmp	eax, 1073741824				; 40000000H
	mov	eax, OFFSET ??_C@_0BL@BLGEHEPG@?5as?5a?5method?5instance?5name?$AA@
	je	SHORT $LN9@add_perm_g
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN9@add_perm_g:
	push	eax
	push	edi
	push	OFFSET ??_C@_0CE@FIDGPEE@The?5name?5?$CC?$CFs?$CC?5is?5already?5in?5use?$CF@
	push	OFFSET _errmsg
	call	_sprintf

; 560  :     kb_error(2576,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2576					; 00000a10H
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN2@add_perm_g
$LN3@add_perm_g:

; 561  :   }
; 562  :   else web.perm_global_count++;

	inc	DWORD PTR _web+5548
$LN2@add_perm_g:

; 563  : 
; 564  :   /* see if we want to expand */
; 565  :   if ( web.perm_global_count == web.max_perm_globals )

	mov	eax, DWORD PTR _web+5552
	cmp	DWORD PTR _web+5548, eax
	jne	SHORT $LN1@add_perm_g

; 566  :   { 
; 567  :      web.max_perm_globals *= 2;

	add	eax, eax

; 568  :      dy_perm_globals = 
; 569  :         realloc(dy_perm_globals,web.max_perm_globals*sizeof(struct global*));

	lea	edx, DWORD PTR [eax*4]
	mov	DWORD PTR _web+5552, eax
	mov	eax, DWORD PTR _web+5656
	push	edx
	push	eax
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _web+5656, eax

; 570  :      perm_Globals = dy_perm_globals;  /* handy for debugging */

	mov	DWORD PTR _perm_Globals, eax
$LN1@add_perm_g:

; 571  :   }
; 572  : 
; 573  :   return slot | PERMGLOBAL;

	pop	edi
	mov	eax, ebx
	pop	esi
	or	eax, 536870912				; 20000000H
	pop	ebx

; 574  : } // end add_perm_global()

	pop	ebp
	ret	0
_add_perm_global ENDP
_TEXT	ENDS
PUBLIC	_lookup_perm_global
; Function compile flags: /Ogtp
;	COMDAT _lookup_perm_global
_TEXT	SEGMENT
_name$ = 8						; size = 4
_lookup_perm_global PROC				; COMDAT

; 587  : { 

	push	ebp
	mov	ebp, esp

; 588  :   int inx;
; 589  : 
; 590  :   if ( web.perm_global_count == 0 ) return -1;

	cmp	DWORD PTR _web+5548, 0
	je	SHORT $LN1@lookup_per

; 591  : 
; 592  :   /* search for name */
; 593  :   inx = lookup_global_hash(name,0,PERM_NAME,HASH_LOOK);

	mov	eax, DWORD PTR _name$[ebp]
	push	0
	push	-2147483648				; 80000000H
	push	0
	push	eax
	call	_lookup_global_hash
	add	esp, 16					; 00000010H

; 594  :   if ( inx == 0 ) 

	test	eax, eax

; 595  :     return -1;

	je	SHORT $LN1@lookup_per

; 596  :   if ( (inx & NAMETYPEMASK) == PERM_NAME )

	mov	ecx, eax
	and	ecx, -536870912				; e0000000H
	cmp	ecx, -2147483648			; 80000000H
	jne	SHORT $LN1@lookup_per

; 597  :     return (inx & INDEXMASK) | PERMGLOBAL;

	and	eax, 536870911				; 1fffffffH
	or	eax, 536870912				; 20000000H

; 599  : } // end lookup_perm_global()

	pop	ebp
	ret	0
$LN1@lookup_per:

; 598  :   return -1;

	or	eax, -1

; 599  : } // end lookup_perm_global()

	pop	ebp
	ret	0
_lookup_perm_global ENDP
_TEXT	ENDS
PUBLIC	_perm_rewind_globals
; Function compile flags: /Ogtp
;	COMDAT _perm_rewind_globals
_TEXT	SEGMENT
_perm_rewind_spot$ = 8					; size = 4
_perm_rewind_globals PROC				; COMDAT

; 610  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 611  :   int k;
; 612  :   /* unhash in reverse order of adding */
; 613  :   for ( k = web.perm_global_count-1 ; k >= perm_rewind_spot ; k-- )

	mov	esi, DWORD PTR _web+5548
	push	edi
	mov	edi, DWORD PTR _perm_rewind_spot$[ebp]
	dec	esi
	cmp	esi, edi
	jl	SHORT $LN8@perm_rewin
$LL3@perm_rewin:

; 614  :     lookup_global_hash(perm_globals(k)->name,0,0,HASH_DELETE);

	mov	ecx, DWORD PTR _web+5656
	push	2
	mov	eax, esi
	push	0
	and	eax, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	push	0
	push	edx
	call	_lookup_global_hash
	dec	esi
	add	esp, 16					; 00000010H
	cmp	esi, edi
	jge	SHORT $LL3@perm_rewin
$LN8@perm_rewin:

; 615  :   web.perm_global_count = perm_rewind_spot;

	mov	DWORD PTR _web+5548, edi
	pop	edi
	pop	esi

; 616  : } // end perm_rewind_globals()

	pop	ebp
	ret	0
_perm_rewind_globals ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@FIDGGDBJ@graphics_title3?$AA@		; `string'
PUBLIC	??_C@_0BA@EBCNFCFI@graphics_title2?$AA@		; `string'
PUBLIC	??_C@_0P@OBPPGJCL@graphics_title?$AA@		; `string'
PUBLIC	??_C@_0O@DPHOHCAP@console_title?$AA@		; `string'
PUBLIC	??_C@_0L@PJJPIEAP@clip_coeff?$AA@		; `string'
PUBLIC	??_C@_0M@GOLNCKNL@slice_coeff?$AA@		; `string'
PUBLIC	??_C@_0M@PJNBDDKM@eigenvalues?$AA@		; `string'
PUBLIC	??_C@_0BB@JDIKHPII@estimated_change?$AA@	; `string'
PUBLIC	??_C@_0BA@ODEJHEGJ@inverse_periods?$AA@		; `string'
PUBLIC	??_C@_0O@IMAKABFD@torus_periods?$AA@		; `string'
PUBLIC	??_C@_0M@PIDOJOI@view_matrix?$AA@		; `string'
PUBLIC	??_C@_0BA@IFLDONLI@view_transforms?$AA@		; `string'
PUBLIC	??_C@_0BK@FOGJPBBC@transform_gen_swap_colors?$AA@ ; `string'
PUBLIC	??_C@_0BK@PJALNND@view_transform_generators?$AA@ ; `string'
PUBLIC	??_C@_0BN@GAIMDEHC@view_transforms_unique_point?$AA@ ; `string'
PUBLIC	??_C@_0BL@INPDMFIP@view_transform_swap_colors?$AA@ ; `string'
PUBLIC	_initialize_perm_globals
EXTRN	_graphics_title3:BYTE
EXTRN	_graphics_title3_global:DWORD
EXTRN	_graphics_title2:BYTE
EXTRN	_graphics_title2_global:DWORD
EXTRN	_graphics_title:BYTE
EXTRN	_graphics_title_global:DWORD
EXTRN	_console_title:BYTE
EXTRN	_console_title_global:DWORD
EXTRN	_clip_coeff:BYTE
EXTRN	_clip_coeff_global:DWORD
EXTRN	_slice_coeff:BYTE
EXTRN	_slice_coeff_global:DWORD
EXTRN	_estimated_change:QWORD
EXTRN	_view_transforms_unique_point:DWORD
EXTRN	_view_transforms_unique_point_global:DWORD
;	COMDAT ??_C@_0BA@FIDGGDBJ@graphics_title3?$AA@
CONST	SEGMENT
??_C@_0BA@FIDGGDBJ@graphics_title3?$AA@ DB 'graphics_title3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EBCNFCFI@graphics_title2?$AA@
CONST	SEGMENT
??_C@_0BA@EBCNFCFI@graphics_title2?$AA@ DB 'graphics_title2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OBPPGJCL@graphics_title?$AA@
CONST	SEGMENT
??_C@_0P@OBPPGJCL@graphics_title?$AA@ DB 'graphics_title', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DPHOHCAP@console_title?$AA@
CONST	SEGMENT
??_C@_0O@DPHOHCAP@console_title?$AA@ DB 'console_title', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PJJPIEAP@clip_coeff?$AA@
CONST	SEGMENT
??_C@_0L@PJJPIEAP@clip_coeff?$AA@ DB 'clip_coeff', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GOLNCKNL@slice_coeff?$AA@
CONST	SEGMENT
??_C@_0M@GOLNCKNL@slice_coeff?$AA@ DB 'slice_coeff', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PJNBDDKM@eigenvalues?$AA@
CONST	SEGMENT
??_C@_0M@PJNBDDKM@eigenvalues?$AA@ DB 'eigenvalues', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JDIKHPII@estimated_change?$AA@
CONST	SEGMENT
??_C@_0BB@JDIKHPII@estimated_change?$AA@ DB 'estimated_change', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ODEJHEGJ@inverse_periods?$AA@
CONST	SEGMENT
??_C@_0BA@ODEJHEGJ@inverse_periods?$AA@ DB 'inverse_periods', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IMAKABFD@torus_periods?$AA@
CONST	SEGMENT
??_C@_0O@IMAKABFD@torus_periods?$AA@ DB 'torus_periods', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PIDOJOI@view_matrix?$AA@
CONST	SEGMENT
??_C@_0M@PIDOJOI@view_matrix?$AA@ DB 'view_matrix', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IFLDONLI@view_transforms?$AA@
CONST	SEGMENT
??_C@_0BA@IFLDONLI@view_transforms?$AA@ DB 'view_transforms', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FOGJPBBC@transform_gen_swap_colors?$AA@
CONST	SEGMENT
??_C@_0BK@FOGJPBBC@transform_gen_swap_colors?$AA@ DB 'transform_gen_swap_'
	DB	'colors', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PJALNND@view_transform_generators?$AA@
CONST	SEGMENT
??_C@_0BK@PJALNND@view_transform_generators?$AA@ DB 'view_transform_gener'
	DB	'ators', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GAIMDEHC@view_transforms_unique_point?$AA@
CONST	SEGMENT
??_C@_0BN@GAIMDEHC@view_transforms_unique_point?$AA@ DB 'view_transforms_'
	DB	'unique_point', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@INPDMFIP@view_transform_swap_colors?$AA@
CONST	SEGMENT
??_C@_0BL@INPDMFIP@view_transform_swap_colors?$AA@ DB 'view_transform_swa'
	DB	'p_colors', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _initialize_perm_globals
_TEXT	SEGMENT
_initialize_perm_globals PROC				; COMDAT

; 898  : { int k;

	push	esi
	push	edi

; 899  :   struct global *g;
; 900  : 
; 901  : 
; 902  :   k = add_perm_global("view_transform_swap_colors");

	push	OFFSET ??_C@_0BL@INPDMFIP@view_transform_swap_colors?$AA@
	call	_add_perm_global

; 903  :   view_transform_swap_colors_global = k;
; 904  :   g = globals(k);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 4
	mov	DWORD PTR _view_transform_swap_colors_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN4@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN6@initialize
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	mov	esi, eax
	jmp	SHORT $LN5@initialize
$LN6@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN4@initialize
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN5@initialize
$LN4@initialize:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax]
$LN5@initialize:

; 905  :   g->attr.arrayptr = 
; 906  :      (struct array*)calloc(sizeof(struct array)+1*sizeof(int),1); 

	push	ebx
	mov	ebx, 1
	push	ebx
	push	60					; 0000003cH
	call	_calloc
	mov	DWORD PTR [esi+168], eax

; 907  :   g->attr.arrayptr->dim = 1;

	mov	DWORD PTR [eax+4], ebx

; 908  :   g->attr.arrayptr->itemsize = sizeof(int);

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+12], 4

; 909  :   g->attr.arrayptr->datatype = INTEGER_TYPE;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+8], 2

; 910  :   g->attr.arrayptr->datacount = 0;

	mov	eax, DWORD PTR [esi+168]
	xor	edi, edi
	mov	DWORD PTR [eax+16], edi

; 911  :   g->attr.arrayptr->sizes[0] = 0;

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+24], edi

; 912  :   g->attr.arrayptr->datastart = 0; 

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+20], edi

; 913  :   g->flags = INTERNAL_NAME|PERMANENT|ARRAY_PARAM;
; 914  : 
; 915  :   k = add_perm_global("view_transforms_unique_point");

	push	OFFSET ??_C@_0BN@GAIMDEHC@view_transforms_unique_point?$AA@
	mov	DWORD PTR [esi+192], 4196368		; 00400810H
	call	_add_perm_global

; 916  :   view_transforms_unique_point_global = k;
; 917  :   g = globals(k);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _view_transforms_unique_point_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN10@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN12@initialize
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	mov	esi, eax
	jmp	SHORT $LN11@initialize
$LN12@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN10@initialize
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN11@initialize
$LN10@initialize:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax]
$LN11@initialize:

; 918  :   g->attr.arrayptr = 
; 919  :      (struct array*)calloc(sizeof(struct array)+MAXCOORD*sizeof(REAL),1); 

	push	ebx
	push	104					; 00000068H
	call	_calloc
	mov	DWORD PTR [esi+168], eax

; 920  :   g->attr.arrayptr->dim = 1;

	mov	DWORD PTR [eax+4], ebx

; 921  :   g->attr.arrayptr->itemsize = sizeof(REAL);

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+12], 8

; 922  :   g->attr.arrayptr->datatype = REAL_TYPE;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+8], ebx

; 923  :   g->attr.arrayptr->datacount = MAXCOORD;

	mov	ecx, DWORD PTR [esi+168]
	mov	eax, 6
	mov	DWORD PTR [ecx+16], eax

; 924  :   g->attr.arrayptr->sizes[0] = MAXCOORD;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+24], eax

; 925  :   g->attr.arrayptr->datastart = sizeof(struct array); 

	mov	eax, DWORD PTR [esi+168]
	mov	DWORD PTR [eax+20], 56			; 00000038H

; 926  :   g->flags = INTERNAL_NAME|PERMANENT|ARRAY_PARAM;
; 927  :   view_transforms_unique_point = (REAL*)(g->attr.arrayptr + 1);

	mov	ecx, DWORD PTR [esi+168]
	add	ecx, 56					; 00000038H
	mov	DWORD PTR [esi+192], 4196368		; 00400810H

; 928  : 
; 929  :   k = add_perm_global("view_transform_generators");

	push	OFFSET ??_C@_0BK@PJALNND@view_transform_generators?$AA@
	mov	DWORD PTR _view_transforms_unique_point, ecx
	call	_add_perm_global

; 930  :   view_transform_generators_global = k;
; 931  :   g = globals(k);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _view_transform_generators_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN16@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN18@initialize
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	mov	esi, eax
	jmp	SHORT $LN17@initialize
$LN18@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN16@initialize
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN17@initialize
$LN16@initialize:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR [eax+ecx]
$LN17@initialize:

; 932  :   g->attr.arrayptr = 
; 933  :      (struct array*)calloc(sizeof(struct array)+3*sizeof(int),1); 

	push	ebx
	push	68					; 00000044H
	call	_calloc
	mov	DWORD PTR [esi+168], eax

; 934  :   g->attr.arrayptr->dim = 3;

	mov	DWORD PTR [eax+4], 3

; 935  :   g->attr.arrayptr->itemsize = sizeof(REAL);

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+12], 8

; 936  :   g->attr.arrayptr->datatype = REAL_TYPE;

	mov	eax, DWORD PTR [esi+168]
	mov	DWORD PTR [eax+8], ebx

; 937  :   g->attr.arrayptr->datacount = 0;

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+16], edi

; 938  :   g->attr.arrayptr->sizes[0] = 0;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+24], edi

; 939  :   g->attr.arrayptr->sizes[1] = 0;

	mov	eax, DWORD PTR [esi+168]
	mov	DWORD PTR [eax+28], edi

; 940  :   g->attr.arrayptr->sizes[2] = 0;

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+32], edi

; 941  :   g->attr.arrayptr->datastart = 0; 

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+20], edi

; 942  :   g->flags = INTERNAL_NAME|PERMANENT|ARRAY_PARAM|READONLY;
; 943  : 
; 944  :   k = add_perm_global("transform_gen_swap_colors");

	push	OFFSET ??_C@_0BK@FOGJPBBC@transform_gen_swap_colors?$AA@
	mov	DWORD PTR [esi+192], 12584976		; 00c00810H
	call	_add_perm_global

; 945  :   transform_gen_swap_colors_global = k;
; 946  :   g = globals(k);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _transform_gen_swap_colors_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN22@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN24@initialize
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	mov	esi, eax
	jmp	SHORT $LN23@initialize
$LN24@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN22@initialize
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN23@initialize
$LN22@initialize:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax]
$LN23@initialize:

; 947  :   g->attr.arrayptr = 
; 948  :      (struct array*)calloc(sizeof(struct array)+1*sizeof(int),1); 

	push	ebx
	push	60					; 0000003cH
	call	_calloc
	mov	DWORD PTR [esi+168], eax

; 949  :   g->attr.arrayptr->dim = 1;

	mov	DWORD PTR [eax+4], ebx

; 950  :   g->attr.arrayptr->itemsize = sizeof(int);

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+12], 4

; 951  :   g->attr.arrayptr->datatype = INTEGER_TYPE;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+8], 2

; 952  :   g->attr.arrayptr->datacount = 0;

	mov	eax, DWORD PTR [esi+168]
	mov	DWORD PTR [eax+16], edi

; 953  :   g->attr.arrayptr->sizes[0] = 0;

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+24], edi

; 954  :   g->attr.arrayptr->datastart = 0; 

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+20], edi

; 955  :   g->flags = INTERNAL_NAME|PERMANENT|ARRAY_PARAM;
; 956  : 
; 957  :   k = add_perm_global("view_transforms");

	push	OFFSET ??_C@_0BA@IFLDONLI@view_transforms?$AA@
	mov	DWORD PTR [esi+192], 4196368		; 00400810H
	call	_add_perm_global

; 958  :   view_transforms_global = k;
; 959  :   g = globals(k);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _view_transforms_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN28@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN30@initialize
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	mov	esi, eax
	jmp	SHORT $LN29@initialize
$LN30@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN28@initialize
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN29@initialize
$LN28@initialize:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax]
$LN29@initialize:

; 960  :   g->attr.arrayptr = 
; 961  :      (struct array*)calloc(sizeof(struct array)+3*sizeof(int),1); 

	push	ebx
	push	68					; 00000044H
	call	_calloc
	mov	DWORD PTR [esi+168], eax

; 962  :   g->attr.arrayptr->dim = 3;

	mov	DWORD PTR [eax+4], 3

; 963  :   g->attr.arrayptr->itemsize = sizeof(REAL);

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+12], 8

; 964  :   g->attr.arrayptr->datatype = REAL_TYPE;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+8], ebx

; 965  :   g->attr.arrayptr->datacount = 0;

	mov	eax, DWORD PTR [esi+168]
	mov	DWORD PTR [eax+16], edi

; 966  :   g->attr.arrayptr->sizes[0] = 0;

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+24], edi

; 967  :   g->attr.arrayptr->sizes[1] = 0;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+28], edi

; 968  :   g->attr.arrayptr->sizes[2] = 0;

	mov	eax, DWORD PTR [esi+168]
	mov	DWORD PTR [eax+32], edi

; 969  :   g->attr.arrayptr->datastart = 0; 

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+20], edi

; 970  :   g->flags = INTERNAL_NAME|PERMANENT|ARRAY_PARAM|READONLY;
; 971  : 
; 972  :   k = add_perm_global("view_matrix");

	push	OFFSET ??_C@_0M@PIDOJOI@view_matrix?$AA@
	mov	DWORD PTR [esi+192], 12584976		; 00c00810H
	call	_add_perm_global

; 973  :   view_matrix_global = k;
; 974  :   g = globals(k);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _view_matrix_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN34@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN36@initialize
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	mov	esi, eax
	jmp	SHORT $LN35@initialize
$LN36@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN34@initialize
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN35@initialize
$LN34@initialize:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR [eax+ecx]
$LN35@initialize:

; 975  :   g->attr.arrayptr = 
; 976  :      (struct array*)calloc(sizeof(struct array)+2*sizeof(int),1); 

	push	ebx
	push	64					; 00000040H
	call	_calloc
	mov	DWORD PTR [esi+168], eax

; 977  :   g->attr.arrayptr->dim = 2;

	mov	DWORD PTR [eax+4], 2

; 978  :   g->attr.arrayptr->itemsize = sizeof(REAL);

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+12], 8

; 979  :   g->attr.arrayptr->datatype = REAL_TYPE;

	mov	eax, DWORD PTR [esi+168]
	mov	DWORD PTR [eax+8], ebx

; 980  :   g->attr.arrayptr->datacount = 0;

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+16], edi

; 981  :   g->attr.arrayptr->sizes[0] = 0;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+24], edi

; 982  :   g->attr.arrayptr->sizes[1] = 0;

	mov	eax, DWORD PTR [esi+168]
	mov	DWORD PTR [eax+28], edi

; 983  :   g->attr.arrayptr->sizes[2] = 0;

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+32], edi

; 984  :   g->attr.arrayptr->datastart = 0; 

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+20], edi

; 985  :   g->flags = INTERNAL_NAME|PERMANENT|ARRAY_PARAM|ALWAYS_RECALC|DONT_RESIZE;
; 986  : 
; 987  :   k = add_perm_global("torus_periods");

	push	OFFSET ??_C@_0O@IMAKABFD@torus_periods?$AA@
	mov	DWORD PTR [esi+192], 1212155920		; 48400810H
	call	_add_perm_global

; 988  :   torus_periods_global = k;
; 989  :   g = globals(torus_periods_global);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _torus_periods_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN40@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN42@initialize
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	mov	esi, eax
	jmp	SHORT $LN41@initialize
$LN42@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN40@initialize
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN41@initialize
$LN40@initialize:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax]
$LN41@initialize:

; 990  :   g->attr.arrayptr = 
; 991  :      (struct array*)calloc(sizeof(struct array)+2*sizeof(int),1); 

	push	ebx
	push	64					; 00000040H
	call	_calloc
	mov	DWORD PTR [esi+168], eax

; 992  :   g->attr.arrayptr->dim = 2;

	mov	DWORD PTR [eax+4], 2

; 993  :   g->attr.arrayptr->itemsize = sizeof(REAL);

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+12], 8

; 994  :   g->attr.arrayptr->datatype = REAL_TYPE;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+8], ebx

; 995  :   g->attr.arrayptr->sizes[0] = 0;

	mov	eax, DWORD PTR [esi+168]
	mov	DWORD PTR [eax+24], edi

; 996  :   g->attr.arrayptr->sizes[1] = 0;

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+28], edi

; 997  :   g->attr.arrayptr->datacount = 0;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+16], edi

; 998  :   g->flags = INTERNAL_NAME|PERMANENT|ARRAY_PARAM|READONLY|ALWAYS_RECALC;
; 999  : 
; 1000 :   k = add_perm_global("inverse_periods");

	push	OFFSET ??_C@_0BA@ODEJHEGJ@inverse_periods?$AA@
	mov	DWORD PTR [esi+192], 146802704		; 08c00810H
	call	_add_perm_global

; 1001 :   inverse_periods_global = k;
; 1002 :   g = globals(k);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _inverse_periods_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN46@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN48@initialize
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	mov	esi, eax
	jmp	SHORT $LN47@initialize
$LN48@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN46@initialize
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN47@initialize
$LN46@initialize:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax]
$LN47@initialize:

; 1003 :   g->attr.arrayptr = 
; 1004 :      (struct array*)calloc(sizeof(struct array)+2*sizeof(int),1); 

	push	ebx
	push	64					; 00000040H
	call	_calloc
	mov	DWORD PTR [esi+168], eax

; 1005 :   g->attr.arrayptr->dim = 2;

	mov	DWORD PTR [eax+4], 2

; 1006 :   g->attr.arrayptr->itemsize = sizeof(REAL);

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+12], 8

; 1007 :   g->attr.arrayptr->datatype = REAL_TYPE;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+8], ebx

; 1008 :   g->attr.arrayptr->datacount = 0;

	mov	eax, DWORD PTR [esi+168]
	mov	DWORD PTR [eax+16], edi

; 1009 :   g->attr.arrayptr->sizes[0] = 0;

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+24], edi

; 1010 :   g->attr.arrayptr->sizes[1] = 0;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+28], edi

; 1011 :   g->attr.arrayptr->sizes[2] = 0;

	mov	eax, DWORD PTR [esi+168]
	mov	DWORD PTR [eax+32], edi

; 1012 :   g->attr.arrayptr->datastart = 0; 

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+20], edi

; 1013 :   g->flags = INTERNAL_NAME|PERMANENT|ARRAY_PARAM|READONLY;
; 1014 : 
; 1015 :   k = add_perm_global("estimated_change");

	push	OFFSET ??_C@_0BB@JDIKHPII@estimated_change?$AA@
	mov	DWORD PTR [esi+192], 12584976		; 00c00810H
	call	_add_perm_global

; 1016 :   g = globals(k);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 12					; 0000000cH
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN52@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN54@initialize
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN53@initialize
$LN54@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN52@initialize
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN53@initialize
$LN52@initialize:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN53@initialize:

; 1017 :   g->value.dataptr = &estimated_change;
; 1018 :   g->flags = INTERNAL_NAME|PERMANENT|REALVAL|READONLY;
; 1019 : 
; 1020 :   k = add_perm_global("eigenvalues");

	push	OFFSET ??_C@_0M@PJNBDDKM@eigenvalues?$AA@
	mov	DWORD PTR [eax+64], OFFSET _estimated_change
	mov	DWORD PTR [eax+192], 46137360		; 02c00010H
	call	_add_perm_global

; 1021 :   eigenvalues_list_global = k;
; 1022 :   g = globals(eigenvalues_list_global);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 4
	mov	DWORD PTR _eigenvalues_list_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN58@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN60@initialize
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	mov	esi, eax
	jmp	SHORT $LN59@initialize
$LN60@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN58@initialize
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN59@initialize
$LN58@initialize:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR [eax+ecx]
$LN59@initialize:

; 1023 :   g->attr.arrayptr = 
; 1024 :      (struct array*)calloc(sizeof(struct array)+1*sizeof(int),1); 

	push	ebx
	push	60					; 0000003cH
	call	_calloc
	mov	DWORD PTR [esi+168], eax

; 1025 :   g->attr.arrayptr->dim = 1;

	mov	DWORD PTR [eax+4], ebx

; 1026 :   g->attr.arrayptr->itemsize = sizeof(REAL);

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+12], 8

; 1027 :   g->attr.arrayptr->datatype = REAL_TYPE;

	mov	eax, DWORD PTR [esi+168]
	mov	DWORD PTR [eax+8], ebx

; 1028 :   g->attr.arrayptr->sizes[0] = 0;

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+24], edi

; 1029 :   g->attr.arrayptr->datacount = 0;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+16], edi

; 1030 :   g->flags = INTERNAL_NAME|PERMANENT|ARRAY_PARAM|READONLY;
; 1031 : 
; 1032 :   k = add_perm_global("slice_coeff");

	push	OFFSET ??_C@_0M@GOLNCKNL@slice_coeff?$AA@
	mov	DWORD PTR [esi+192], 12584976		; 00c00810H
	call	_add_perm_global

; 1033 :   slice_coeff_global = k;
; 1034 :   g = globals(k);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _slice_coeff_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN64@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN66@initialize
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	mov	esi, eax
	jmp	SHORT $LN65@initialize
$LN66@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN64@initialize
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN65@initialize
$LN64@initialize:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax]
$LN65@initialize:

; 1035 :   g->attr.arrayptr = 
; 1036 :      (struct array*)calloc(sizeof(struct array)+1*sizeof(int),1); 

	push	ebx
	push	60					; 0000003cH
	call	_calloc
	mov	DWORD PTR [esi+168], eax

; 1037 :   g->attr.arrayptr->dim = 1;

	mov	DWORD PTR [eax+4], ebx

; 1038 :   g->attr.arrayptr->itemsize = sizeof(REAL);

	mov	ecx, DWORD PTR [esi+168]
	mov	eax, 8
	mov	DWORD PTR [ecx+12], eax

; 1039 :   g->attr.arrayptr->datatype = REAL_TYPE;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+8], ebx

; 1040 :   g->attr.arrayptr->datacount = MAXCOORD+2;

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+16], eax

; 1041 :   g->attr.arrayptr->sizes[0] = MAXCOORD+2;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+24], eax

; 1042 :   g->attr.arrayptr->datastart = (char*)slice_coeff-(char*)(g->attr.arrayptr); 

	mov	eax, DWORD PTR [esi+168]
	mov	ecx, OFFSET _slice_coeff
	sub	ecx, eax
	mov	DWORD PTR [eax+20], ecx

; 1043 :   g->flags = PERMANENT|ARRAY_PARAM|RECALC_PARAMETER|ALWAYS_RECALC;

	mov	ebx, 134219800				; 08000818H

; 1044 : 
; 1045 : 
; 1046 :   k = add_perm_global("clip_coeff");

	push	OFFSET ??_C@_0L@PJJPIEAP@clip_coeff?$AA@
	mov	DWORD PTR [esi+192], ebx
	call	_add_perm_global

; 1047 :   clip_coeff_global = k;
; 1048 :   g = globals(k);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _clip_coeff_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN70@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN72@initialize
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	mov	esi, eax
	jmp	SHORT $LN71@initialize
$LN72@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN70@initialize
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN71@initialize
$LN70@initialize:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR [eax+ecx]
$LN71@initialize:

; 1049 :   g->attr.arrayptr = 
; 1050 :      (struct array*)calloc(sizeof(struct array)+1*sizeof(int),1); 

	push	1
	push	60					; 0000003cH
	call	_calloc
	mov	DWORD PTR [esi+168], eax

; 1051 :   g->attr.arrayptr->dim = 2;

	mov	DWORD PTR [eax+4], 2

; 1052 :   g->attr.arrayptr->itemsize = sizeof(REAL);

	mov	edx, DWORD PTR [esi+168]
	mov	eax, 8
	mov	DWORD PTR [edx+12], eax

; 1053 :   g->attr.arrayptr->datatype = REAL_TYPE;

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+8], 1

; 1054 :   g->attr.arrayptr->datacount = MAXCLIPS*(MAXCOORD+2);

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+16], 80			; 00000050H

; 1055 :   g->attr.arrayptr->sizes[0] = MAXCLIPS;

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+24], 10			; 0000000aH

; 1056 :   g->attr.arrayptr->sizes[1] = MAXCOORD+2;

	mov	edx, DWORD PTR [esi+168]
	mov	DWORD PTR [edx+28], eax

; 1057 :   g->attr.arrayptr->datastart = (char*)clip_coeff-(char*)(g->attr.arrayptr); 

	mov	eax, DWORD PTR [esi+168]
	mov	ecx, OFFSET _clip_coeff
	sub	ecx, eax
	mov	DWORD PTR [eax+20], ecx
	add	esp, 8

; 1058 :   g->flags = PERMANENT|ARRAY_PARAM|RECALC_PARAMETER|ALWAYS_RECALC;

	mov	DWORD PTR [esi+192], ebx
	pop	ebx

; 1059 : 
; 1060 :   if ( console_title_global == 0 )

	cmp	DWORD PTR _console_title_global, edi
	jne	$LN1@initialize

; 1061 :   {
; 1062 :     k = add_perm_global("console_title");  // not permanent, so can be assigned to naturally

	push	OFFSET ??_C@_0O@DPHOHCAP@console_title?$AA@
	call	_add_perm_global

; 1063 :     console_title_global = k;
; 1064 :     g = globals(k);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 4
	mov	DWORD PTR _console_title_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN76@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN78@initialize
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN77@initialize
$LN78@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN76@initialize
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN77@initialize
$LN76@initialize:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN77@initialize:

; 1065 :     g->value.string = console_title;
; 1066 :     g->type = STRING_TYPE;

	mov	edi, 11					; 0000000bH

; 1067 :     g->flags = INTERNAL_NAME|STRINGVAL;

	mov	esi, 4202496				; 00402000H

; 1068 : 
; 1069 :     k = add_perm_global("graphics_title");  // not permanent, so can be assigned to naturally

	push	OFFSET ??_C@_0P@OBPPGJCL@graphics_title?$AA@
	mov	DWORD PTR [eax+64], OFFSET _console_title
	mov	DWORD PTR [eax+200], edi
	mov	DWORD PTR [eax+192], esi
	call	_add_perm_global

; 1070 :     graphics_title_global = k;
; 1071 :     g = globals(k);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 4
	mov	DWORD PTR _graphics_title_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN82@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN84@initialize
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN83@initialize
$LN84@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN82@initialize
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN83@initialize
$LN82@initialize:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN83@initialize:

; 1072 :     g->value.string = graphics_title;
; 1073 :     g->type = STRING_TYPE;
; 1074 :     g->flags = INTERNAL_NAME|STRINGVAL;
; 1075 : 
; 1076 :     k = add_perm_global("graphics_title2");  // not permanent, so can be assigned to naturally

	push	OFFSET ??_C@_0BA@EBCNFCFI@graphics_title2?$AA@
	mov	DWORD PTR [eax+64], OFFSET _graphics_title
	mov	DWORD PTR [eax+200], edi
	mov	DWORD PTR [eax+192], esi
	call	_add_perm_global

; 1077 :     graphics_title2_global = k;
; 1078 :     g = globals(k);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 4
	mov	DWORD PTR _graphics_title2_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN88@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN90@initialize
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN89@initialize
$LN90@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN88@initialize
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN89@initialize
$LN88@initialize:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN89@initialize:

; 1079 :     g->value.string = graphics_title2;
; 1080 :     g->type = STRING_TYPE;
; 1081 :     g->flags = INTERNAL_NAME|STRINGVAL;
; 1082 : 
; 1083 :     k = add_perm_global("graphics_title3");  // not permanent, so can be assigned to naturally

	push	OFFSET ??_C@_0BA@FIDGGDBJ@graphics_title3?$AA@
	mov	DWORD PTR [eax+64], OFFSET _graphics_title2
	mov	DWORD PTR [eax+200], edi
	mov	DWORD PTR [eax+192], esi
	call	_add_perm_global

; 1084 :     graphics_title3_global = k;
; 1085 :     g = globals(k);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 4
	mov	DWORD PTR _graphics_title3_global, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN94@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN96@initialize
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN95@initialize
$LN96@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN94@initialize
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN95@initialize
$LN94@initialize:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN95@initialize:

; 1086 :     g->value.string = graphics_title3;

	mov	DWORD PTR [eax+64], OFFSET _graphics_title3

; 1087 :     g->type = STRING_TYPE;

	mov	DWORD PTR [eax+200], edi

; 1088 :     g->flags = INTERNAL_NAME|STRINGVAL;

	mov	DWORD PTR [eax+192], esi
$LN1@initialize:

; 1089 :   }
; 1090 : 
; 1091 : } // end initialize_perm_globals()

	pop	edi
	pop	esi
	ret	0
_initialize_perm_globals ENDP
_TEXT	ENDS
END
