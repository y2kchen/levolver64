; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\TEIX.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_lambda_list:DWORD
COMM	_lambda_heads:DWORD:064H
COMM	_lambdamax:DWORD
COMM	_tgverts:DWORD
COMM	_lmc_mc_attr:DWORD
COMM	_lambda_count:DWORD
COMM	_lmc_mobility_attr:DWORD
_DATA	ENDS
_BSS	SEGMENT
_unmark	DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_omega	DQ	03fd0000000000000r		; 0.25
_coarse_mark DD	01H
_fine_mark DD	02H
_DATA	ENDS
PUBLIC	_get_fe_edge
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	_get_extra
; Function compile flags: /Ogtp
;	COMDAT _get_extra
_TEXT	SEGMENT
_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_extra PROC						; COMDAT

; 348  : { int type = id_type(id);

	push	ebp
	mov	ebp, esp

; 349  : 
; 350  :   return ( (char*)elptr(id) + EXTRAS(type)[n].offset);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	shr	eax, 29					; 0000001dH
	imul	esi, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, esi
	add	eax, DWORD PTR [edi+ecx+64]
	pop	edi
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_get_extra ENDP
_TEXT	ENDS
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	??_C@_06FIEBBMKD@TEIX?4C?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_curvature_forces_init
EXTRN	_cross_prod:PROC
EXTRN	_dot:PROC
EXTRN	_get_edge_side:PROC
EXTRN	_kb_calloc:PROC
EXTRN	_myfree:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIacos:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT ??_C@_06FIEBBMKD@TEIX?4C?$AA@
CONST	SEGMENT
??_C@_06FIEBBMKD@TEIX?4C?$AA@ DB 'TEIX.C', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\teix.c
CONST	ENDS
;	COMDAT _curvature_forces_init
_TEXT	SEGMENT
tv1492 = -296						; size = 8
tv703 = -288						; size = 8
_area$ = -280						; size = 8
tv582 = -272						; size = 4
tv1061 = -268						; size = 4
tv949 = -268						; size = 4
tv1402 = -264						; size = 4
tv492 = -264						; size = 4
_i$ = -264						; size = 4
tv1115 = -260						; size = 4
_fixcount$ = -260					; size = 4
_normal$ = -256						; size = 48
_side$ = -208						; size = 144
_st$ = -64						; size = 24
_ss$ = -40						; size = 24
_v$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_curvature_forces_init PROC				; COMDAT

; 34   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 35   :   vertex_id v[3];
; 36   :   edge_id e_id;
; 37   :   facet_id f_id;
; 38   :   facetedge_id fe;
; 39   :   int fixcount;
; 40   :   int i,j;
; 41   :   REAL area;
; 42   :   REAL side[3][MAXCOORD];
; 43   :   REAL ss[3];
; 44   :   REAL st[3];
; 45   :   REAL angle;
; 46   :   REAL c;
; 47   :   struct teix_gvert  *gv,*vc[3];
; 48   :   REAL normal[MAXCOORD];
; 49   : 
; 50   :   if ( tgverts ) myfree((char*)tgverts);

	mov	eax, DWORD PTR _tgverts
	test	eax, eax
	je	SHORT $LN27@curvature_
	push	eax
	call	_myfree
	add	esp, 4
$LN27@curvature_:

; 51   :   tgverts = (struct teix_gvert*)mycalloc(web.skel[VERTEX].max_ord+1,
; 52   :                                             sizeof(struct teix_gvert));

	mov	eax, DWORD PTR _web+68
	push	esi
	push	52					; 00000034H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	inc	eax
	push	120					; 00000078H
	push	eax
	call	_kb_calloc

; 53   : 
; 54   :   /* accumulate angles and stuff around vertices */
; 55   :   FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	mov	esi, edx
	shr	esi, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	esi, 1
	mov	DWORD PTR _tgverts, eax
	je	$LN24@curvature_
	push	ebx
	push	edi
	npad	7
$LL26@curvature_:
	mov	eax, DWORD PTR _web+236
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv582[ebp], ecx
	je	$LN25@curvature_

; 56   :   { fe = get_facet_fe(f_id);

	xor	eax, eax
	cmp	esi, eax
	je	SHORT $LN36@curvature_
$LN35@curvature_:
	mov	edi, DWORD PTR [edi+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN34@curvature_
	xor	edi, 134217728				; 08000000H
$LN34@curvature_:
	mov	ebx, edi
$LN36@curvature_:

; 57   :     fixcount = 0;

	lea	ecx, DWORD PTR _side$[ebp]
	mov	DWORD PTR _fixcount$[ebp], eax

; 58   :     for ( i = 0; i < FACET_VERTS ; i++,fe=get_next_edge(fe) )

	mov	DWORD PTR _i$[ebp], eax
	mov	eax, DWORD PTR _web+460
	mov	DWORD PTR tv949[ebp], ecx
$LL74@curvature_:

; 59   :     { e_id = get_fe_edge(fe);

	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+eax]

; 60   :       get_edge_side(e_id,side[i]);

	mov	eax, DWORD PTR tv949[ebp]
	mov	esi, ebx
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [edx+20]
	push	eax
	push	esi
	call	_get_edge_side

; 61   :       v[i] = get_edge_tailv(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR _web+216
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN45@curvature_
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN44@curvature_
$LN45@curvature_:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]
$LN44@curvature_:
	mov	edx, DWORD PTR _i$[ebp]

; 62   :       if ( get_vattr(v[i]) & (FIXED|BOUNDARY) ) fixcount++;

	mov	ecx, DWORD PTR _web+12
	mov	DWORD PTR _v$[ebp+edx*4], eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 192				; 000000c0H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN20@curvature_
	inc	DWORD PTR _fixcount$[ebp]
$LN20@curvature_:

; 58   :     for ( i = 0; i < FACET_VERTS ; i++,fe=get_next_edge(fe) )

	add	DWORD PTR tv949[ebp], 48		; 00000030H
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edi+eax]
	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN39@curvature_
	mov	ebx, DWORD PTR [ecx+28]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN55@curvature_
$LN39@curvature_:
	mov	ebx, DWORD PTR [ecx+32]
$LN55@curvature_:
	cmp	edx, 3
	jl	$LL74@curvature_

; 63   :     }
; 64   :     for ( i = 0 ; i < FACET_VERTS ; i++ )

	xor	esi, esi
	lea	edi, DWORD PTR _side$[ebp]
	npad	1
$LL17@curvature_:

; 65   :     { ss[i] = SDIM_dot(side[i],side[i]);

	mov	edx, DWORD PTR _web+616
	push	edx
	push	edi
	push	edi
	call	_dot
	fstp	QWORD PTR _ss$[ebp+esi*8]

; 66   :       st[i] = SDIM_dot(side[i],side[(i+2)%3]);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	eax, DWORD PTR [esi+2]
	cdq
	mov	ecx, 3
	idiv	ecx
	lea	edx, DWORD PTR [edx+edx*2]
	add	edx, edx
	lea	eax, DWORD PTR _side$[ebp+edx*8]
	push	eax
	push	edi
	call	_dot
	fstp	QWORD PTR _st$[ebp+esi*8]
	inc	esi
	add	esp, 24					; 00000018H
	add	edi, 48					; 00000030H
	cmp	esi, 3
	jl	SHORT $LL17@curvature_

; 67   :     }
; 68   :     area = 0.5*sqrt(ss[0]*ss[1]-st[1]*st[1]);

	fld	QWORD PTR _ss$[ebp+8]
	fmul	QWORD PTR _ss$[ebp]
	fld	QWORD PTR _st$[ebp+8]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)
	call	__CIsqrt
	fmul	QWORD PTR __real@3fe0000000000000

; 69   :     cross_prod(side[0],side[1],normal);

	lea	ecx, DWORD PTR _normal$[ebp]
	push	ecx
	lea	edx, DWORD PTR _side$[ebp+48]
	fstp	QWORD PTR _area$[ebp]
	push	edx
	lea	eax, DWORD PTR _side$[ebp]
	push	eax
	call	_cross_prod
	fld	QWORD PTR _area$[ebp]
	fld	QWORD PTR __real@4008000000000000
	mov	ecx, 3
	fdivr	ST(0), ST(1)
	sub	ecx, DWORD PTR _fixcount$[ebp]
	lea	edx, DWORD PTR _v$[ebp]

; 84   :     }
; 85   : 
; 86   :     /* for mean curvature */
; 87   : 
; 88   :     for ( i = 0 ; i < FACET_VERTS ; i++ )
; 89   :       vc[i] = tgverts + loc_ordinal(v[i]);

	mov	DWORD PTR tv1402[ebp], ecx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1061[ebp], 2
	mov	DWORD PTR tv1115[ebp], edx
	xor	ebx, ebx
	fstp	QWORD PTR tv703[ebp]
	fild	DWORD PTR tv1402[ebp]
	mov	DWORD PTR tv492[ebp], 3
	fdivr	ST(0), ST(1)
	fstp	QWORD PTR tv1492[ebp]
$LN77@curvature_:

; 71   :     { REAL dd = ss[i]*ss[(i+2)%3];

	mov	eax, DWORD PTR tv1061[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	fld	QWORD PTR _ss$[ebp+edx*8]

; 72   :       gv = tgverts + loc_ordinal(v[i]);

	mov	edx, DWORD PTR tv1115[ebp]
	fmul	QWORD PTR _ss$[ebp+ebx]
	mov	eax, DWORD PTR [edx]
	fld	ST(0)
	test	eax, 268435456				; 10000000H
	je	SHORT $LN30@curvature_
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN31@curvature_
$LN30@curvature_:
	or	eax, -1
$LN31@curvature_:

; 73   :       if ( dd > 0.0 )

	fldz
	mov	edx, DWORD PTR _tgverts
	mov	ecx, eax
	fcompp
	shl	ecx, 4
	sub	ecx, eax
	lea	esi, DWORD PTR [edx+ecx*8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN84@curvature_

; 76   :         { angle = acos(c);
; 77   :           gv->angle += angle;

	fstp	ST(1)
	call	__CIsqrt
	fdivr	QWORD PTR _st$[ebp+ebx]
	fchs
	fld	ST(0)
	fabs
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN87@curvature_
	call	__CIacos
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	fld	QWORD PTR _area$[ebp]
	jmp	SHORT $LN10@curvature_
$LN87@curvature_:

; 74   :       { c = -st[i]/sqrt(ss[i]*ss[(i+2)%3]);
; 75   :         if ( fabs(c) <= 1.0 )

	fstp	ST(0)

; 76   :         { angle = acos(c);
; 77   :           gv->angle += angle;

	fld	QWORD PTR _area$[ebp]
	jmp	SHORT $LN10@curvature_
$LN84@curvature_:
	fstp	ST(0)
$LN10@curvature_:

; 78   :         }
; 79   :       } 
; 80   :       gv->area  += area/3;

	fld	QWORD PTR tv703[ebp]

; 81   :       gv->star_area  += area/(3-fixcount);
; 82   :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	fadd	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi+8]
	fld	QWORD PTR tv1492[ebp]
	fadd	QWORD PTR [esi+16]
	fstp	QWORD PTR [esi+16]
	mov	edi, DWORD PTR _web+616
	test	edi, edi
	jle	SHORT $LN13@curvature_

; 78   :         }
; 79   :       } 
; 80   :       gv->area  += area/3;

	lea	ecx, DWORD PTR [esi+24]
$LN9@curvature_:

; 83   :       gv->normal[j] += normal[j];

	fld	QWORD PTR _normal$[ebp+eax*8]
	inc	eax
	fadd	QWORD PTR [ecx]
	add	ecx, 8
	fstp	QWORD PTR [ecx-8]
	mov	edi, DWORD PTR _web+616
	cmp	eax, edi
	jl	SHORT $LN9@curvature_
$LN13@curvature_:

; 70   :     for ( i = 0 ; i < FACET_VERTS ; i++ )

	add	DWORD PTR tv1115[ebp], 4
	mov	eax, 1
	add	DWORD PTR tv1061[ebp], eax
	add	ebx, 8
	sub	DWORD PTR tv492[ebp], eax
	jne	$LN77@curvature_

; 84   :     }
; 85   : 
; 86   :     /* for mean curvature */
; 87   : 
; 88   :     for ( i = 0 ; i < FACET_VERTS ; i++ )
; 89   :       vc[i] = tgverts + loc_ordinal(v[i]);

	mov	eax, DWORD PTR _v$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN32@curvature_
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN33@curvature_
$LN32@curvature_:
	or	eax, -1
$LN33@curvature_:
	mov	ecx, DWORD PTR _tgverts
	mov	edx, eax
	shl	edx, 4
	sub	edx, eax
	mov	eax, DWORD PTR _v$[ebp+4]
	lea	edx, DWORD PTR [ecx+edx*8]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN67@curvature_
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN68@curvature_
$LN67@curvature_:
	or	eax, -1
$LN68@curvature_:
	mov	esi, eax
	shl	esi, 4
	sub	esi, eax
	mov	eax, DWORD PTR _v$[ebp+8]
	lea	ebx, DWORD PTR [ecx+esi*8]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN70@curvature_
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN71@curvature_
$LN70@curvature_:
	or	eax, -1
$LN71@curvature_:
	mov	esi, eax
	shl	esi, 4
	sub	esi, eax
	lea	esi, DWORD PTR [ecx+esi*8]

; 90   : 
; 91   :     for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	test	edi, edi
	jle	$LN108@curvature_
	fld	QWORD PTR _ss$[ebp+16]
	lea	edi, DWORD PTR _side$[ebp+24]
	fld	QWORD PTR _st$[ebp+16]
	sub	edx, ebx
	fld	QWORD PTR _st$[ebp]
	sub	esi, ebx
	fld	QWORD PTR __real@3fd0000000000000
	lea	eax, DWORD PTR [ebx+72]
	fld	QWORD PTR _ss$[ebp+8]
	sub	edi, ebx
$LN3@curvature_:

; 92   :     { 
; 93   :        vc[0]->force[i] += (ss[1]*side[2][i]-st[2]*side[1][i])/4/area;

	fld	QWORD PTR [edi+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fld	QWORD PTR _side$[ebp+ecx*8+40]
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fdiv	ST(0), ST(6)
	fadd	QWORD PTR [edx+eax-8]
	fstp	QWORD PTR [edx+eax-8]

; 94   :        vc[1]->force[i] += (ss[2]*side[0][i]-st[0]*side[2][i])/4/area;

	fld	ST(4)
	fmul	QWORD PTR _side$[ebp+ecx*8-8]
	fld	QWORD PTR [edi+eax-8]
	fmul	ST(0), ST(4)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fdiv	ST(0), ST(6)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]

; 95   :        vc[2]->force[i] += (ss[0]*side[1][i]-st[1]*side[0][i])/4/area;

	fld	QWORD PTR _side$[ebp+ecx*8+40]
	fmul	QWORD PTR _ss$[ebp]
	fld	QWORD PTR _st$[ebp+8]
	fmul	QWORD PTR _side$[ebp+ecx*8-8]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fdiv	ST(0), ST(6)
	fadd	QWORD PTR [esi+eax-8]
	fstp	QWORD PTR [esi+eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN3@curvature_

; 90   : 
; 91   :     for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(5)
	fstp	ST(0)
	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(0)
$LN108@curvature_:
	mov	ecx, DWORD PTR tv582[ebp]
	fstp	ST(0)
$LN25@curvature_:

; 53   : 
; 54   :   /* accumulate angles and stuff around vertices */
; 55   :   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx]
	mov	esi, edx
	shr	esi, 28					; 0000001cH
	and	esi, 1
	jne	$LL26@curvature_
	pop	edi
	pop	ebx
$LN24@curvature_:

; 96   :     }
; 97   :   }
; 98   : } // end curvature_forces_init()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_curvature_forces_init ENDP
_TEXT	ENDS
PUBLIC	_curvature_forces_energy
; Function compile flags: /Ogtp
;	COMDAT _curvature_forces_energy
_TEXT	SEGMENT
_v_info$ = 8						; size = 4
_curvature_forces_energy PROC				; COMDAT

; 107  : { return 0.0; /* fake it */

	fldz

; 108  : }

	ret	0
_curvature_forces_energy ENDP
_TEXT	ENDS
PUBLIC	__real@401921fb54442d18
PUBLIC	_curvature_forces
EXTRN	__CIexp:PROC
;	COMDAT __real@401921fb54442d18
CONST	SEGMENT
__real@401921fb54442d18 DQ 0401921fb54442d18r	; 6.28319
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _curvature_forces
_TEXT	SEGMENT
_K$ = -8						; size = 8
_v_info$ = 8						; size = 4
_curvature_forces PROC					; COMDAT

; 117  : { REAL K; /* gauss curvature of vertex */

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 118  :   REAL H; /* mean curvature of vertex, average of sectional curvatures */
; 119  :   struct teix_gvert *vg = tgverts + loc_ordinal(v_info->id);

	mov	ebx, DWORD PTR _v_info$[ebp]
	mov	eax, DWORD PTR [ebx]
	push	edi
	test	eax, 268435456				; 10000000H
	je	SHORT $LN10@curvature_@2
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN11@curvature_@2
$LN10@curvature_@2:
	or	ecx, -1
$LN11@curvature_@2:
	mov	edx, ecx
	shl	edx, 4
	sub	edx, ecx
	mov	ecx, DWORD PTR _tgverts

; 120  :   REAL norm;
; 121  :   REAL f; /* function of H and K */
; 122  :   int i;
; 123  : 
; 124  :   if ( get_vattr(v_info->id) & (FIXED|BOUNDARY) ) return 0.0;

	and	eax, 134217727				; 07ffffffH
	lea	edi, DWORD PTR [ecx+edx*8]
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 192				; 000000c0H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN27@curvature_@2

; 125  : 
; 126  :   /* normalize normal */
; 127  :   norm = sqrt(SDIM_dot(vg->normal,vg->normal));

	mov	eax, DWORD PTR _web+616
	push	esi
	push	eax
	lea	esi, DWORD PTR [edi+24]
	push	esi
	push	esi
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 128  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN22@curvature_@2

; 125  : 
; 126  :   /* normalize normal */
; 127  :   norm = sqrt(SDIM_dot(vg->normal,vg->normal));

	mov	eax, esi
$LN6@curvature_@2:

; 129  :      vg->normal[i] /= norm;

	fld	QWORD PTR [eax]
	inc	ecx
	fdiv	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jl	SHORT $LN6@curvature_@2
$LN22@curvature_@2:

; 128  :   for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)

; 130  : 
; 131  :   K = (2*M_PI - vg->angle)/vg->area;
; 132  : 
; 133  :   H = SDIM_dot(vg->force,vg->normal)/2/vg->area;

	push	edx
	fld	QWORD PTR __real@401921fb54442d18
	lea	ecx, DWORD PTR [edi+72]
	fsub	QWORD PTR [edi]
	push	esi
	push	ecx
	fdiv	QWORD PTR [edi+8]
	fstp	QWORD PTR _K$[ebp]
	call	_dot
	fmul	QWORD PTR __real@3fe0000000000000
	add	esp, 12					; 0000000cH
	fdiv	QWORD PTR [edi+8]

; 134  : 
; 135  :   /* fix here for function of H and K */
; 136  :   f =  (H>0.0) ? exp(K) : -exp(K);    /* to detect misorientation */

	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	fld	QWORD PTR _K$[ebp]
	test	ah, 65					; 00000041H
	jne	SHORT $LN12@curvature_@2
	call	__CIexp
	jmp	SHORT $LN13@curvature_@2
$LN12@curvature_@2:
	call	__CIexp
	fchs
$LN13@curvature_@2:

; 137  :   /* end of fixing */
; 138  : 
; 139  :   /* force as multiple of normal */
; 140  :   for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN26@curvature_@2
$LN3@curvature_@2:

; 141  :      v_info->grad[0][i] = -f*vg->normal[i];

	fld	QWORD PTR [esi+eax*8]
	mov	edx, DWORD PTR [ebx+1336]
	mov	ecx, DWORD PTR [edx]
	fmul	ST(0), ST(1)
	inc	eax
	fchs
	fstp	QWORD PTR [ecx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@curvature_@2
$LN26@curvature_@2:

; 137  :   /* end of fixing */
; 138  : 
; 139  :   /* force as multiple of normal */
; 140  :   for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
	pop	esi
$LN27@curvature_@2:

; 142  :  
; 143  :   return 0.0;  /* fake energy */

	fldz
	pop	edi
	pop	ebx

; 144  : } // end curvature_forces()

	mov	esp, ebp
	pop	ebp
	ret	0
_curvature_forces ENDP
_TEXT	ENDS
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_vertex_mean_curvature
EXTRN	_calc_vertex_normal:PROC
EXTRN	_force_project:PROC
EXTRN	_get_next_vertex_facet:PROC
EXTRN	_get_vertex_first_facet:PROC
; Function compile flags: /Ogtp
;	COMDAT _vertex_mean_curvature
_TEXT	SEGMENT
_s11$89156 = -280					; size = 8
tv928 = -272						; size = 4
_v_id$GSCopy$ = -268					; size = 4
_s12$89157 = -264					; size = 8
_fe_id$89148 = -256					; size = 4
_s22$89158 = -252					; size = 8
_area$ = -252						; size = 8
_projf$ = -244						; size = 48
_vnorm$ = -196						; size = 48
_s2$ = -148						; size = 48
_s1$ = -100						; size = 48
_force$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_vertex_mean_curvature PROC				; COMDAT

; 155  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 156  :   REAL meanc = 0.0;
; 157  :   REAL force[MAXCOORD],projf[MAXCOORD];
; 158  :   REAL area = 0.0,farea;
; 159  :   REAL s1[MAXCOORD],s2[MAXCOORD];
; 160  :   REAL vnorm[MAXCOORD];
; 161  :   int i;
; 162  : 
; 163  :   for ( i = 0 ; i < MAXCOORD ; i++ ) 
; 164  :     force[i] = 0.0;

	fldz

; 165  : 
; 166  :   if ( web.representation == STRING )

	mov	eax, DWORD PTR _web+624
	push	ebx
	fst	QWORD PTR _force$[ebp]
	mov	ebx, DWORD PTR _v_id$[ebp]
	fst	QWORD PTR _force$[ebp+8]
	fst	QWORD PTR _force$[ebp+16]
	push	esi
	fst	QWORD PTR _force$[ebp+24]
	push	edi
	fst	QWORD PTR _force$[ebp+32]

; 194  :         fe = get_next_edge(fe);

	mov	DWORD PTR _v_id$GSCopy$[ebp], ebx
	fst	QWORD PTR _force$[ebp+40]
	cmp	eax, 1
	jne	$LN90@vertex_mea

; 167  :   { edge_id start_e, e_id;
; 168  :     REAL len;
; 169  : 
; 170  :     e_id = start_e = get_vertex_edge(v_id);

	mov	ecx, DWORD PTR _web+12
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	esi, DWORD PTR [edx+28]

; 171  :     if ( !valid_id(e_id) ) return 0.0;

	test	esi, 268435456				; 10000000H
	je	$LN27@vertex_mea
	mov	edi, esi
	fstp	ST(0)
	or	edi, 134217728				; 08000000H
	npad	6
$LL21@vertex_mea:

; 172  :     do 
; 173  :     {
; 174  :       REAL s11;
; 175  :       get_edge_side(e_id,s1); 

	lea	eax, DWORD PTR _s1$[ebp]
	push	eax
	push	esi
	call	_get_edge_side

; 176  :       s11 = dot(s1,s1,SDIM);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _s1$[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	add	esp, 20					; 00000014H

; 177  :       len = sqrt(s11);

	call	__CIsqrt

; 178  :       for ( i = 0 ; i < SDIM ; i++ ) 

	mov	edx, DWORD PTR _web+616
	xor	eax, eax
	cmp	edx, 4
	jl	SHORT $LN85@vertex_mea
	fld1
	lea	ecx, DWORD PTR [edx-3]
	fdiv	ST(0), ST(1)
$LN67@vertex_mea:

; 179  :         force[i] += 1/len*s1[i];

	fld	QWORD PTR _s1$[ebp+eax*8]
	add	eax, 4
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _force$[ebp+eax*8-32]
	fstp	QWORD PTR _force$[ebp+eax*8-32]
	fld	QWORD PTR _s1$[ebp+eax*8-24]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _force$[ebp+eax*8-24]
	fstp	QWORD PTR _force$[ebp+eax*8-24]
	fld	QWORD PTR _s1$[ebp+eax*8-16]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _force$[ebp+eax*8-16]
	fstp	QWORD PTR _force$[ebp+eax*8-16]
	fld	QWORD PTR _s1$[ebp+eax*8-8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _force$[ebp+eax*8-8]
	fstp	QWORD PTR _force$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN67@vertex_mea

; 178  :       for ( i = 0 ; i < SDIM ; i++ ) 

	fstp	ST(0)
$LN85@vertex_mea:
	cmp	eax, edx
	jge	SHORT $LN104@vertex_mea
	fld1
	fdivrp	ST(1), ST(0)
$LC18@vertex_mea:

; 179  :         force[i] += 1/len*s1[i];

	fld	QWORD PTR _s1$[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _force$[ebp+eax*8-8]
	fstp	QWORD PTR _force$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC18@vertex_mea
$LN104@vertex_mea:

; 180  :       e_id = get_next_tail_edge(e_id);

	mov	edx, DWORD PTR _web+124
	fstp	ST(0)
	mov	ecx, esi
	shr	ecx, 27					; 0000001bH
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	and	ecx, 1
	mov	esi, DWORD PTR [eax+ecx*4+32]

; 181  :     } while ( !equal_element(start_e,e_id) );

	mov	ecx, esi
	or	ecx, 134217728				; 08000000H
	cmp	edi, ecx
	jne	$LL21@vertex_mea

; 182  : 
; 183  :     force_project(force,v_id,projf);

	jmp	$LN122@vertex_mea
$LN90@vertex_mea:

; 165  : 
; 166  :   if ( web.representation == STRING )

	fstp	ST(0)

; 184  :   }
; 185  :   else if ( web.representation == SOAPFILM )

	cmp	eax, 2
	jne	$LN88@vertex_mea

; 186  :   { facetedge_id fe_id,start_fe;
; 187  :     fe_id = start_fe = get_vertex_first_facet(v_id); /* really returns fe */

	push	ebx
	call	_get_vertex_first_facet
	add	esp, 4
	mov	DWORD PTR _fe_id$89148[ebp], eax

; 188  :     if ( !valid_id(fe_id) ) return 0.0;

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN81@vertex_mea
	fldz
	pop	edi
	pop	esi
	pop	ebx

; 215  : 
; 216  :   return meanc;
; 217  : } /* end vertex_mean_curvature */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN81@vertex_mea:

; 188  :     if ( !valid_id(fe_id) ) return 0.0;

	mov	ecx, eax
	or	ecx, 134217728				; 08000000H
	mov	DWORD PTR tv928[ebp], ecx
	npad	7
$LL12@vertex_mea:

; 189  :     do 
; 190  :     { facetedge_id fe;
; 191  :       REAL s11,s12,s22;
; 192  :       fe = fe_id;

	mov	edx, DWORD PTR _web+216
	mov	edi, DWORD PTR _web+124
	mov	esi, eax
	npad	2
$LL9@vertex_mea:

; 193  :       while ( !equal_id(v_id,get_fe_headv(fe)) )

	mov	eax, DWORD PTR _web+460
	mov	ebx, DWORD PTR _dymem
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN34@vertex_mea
	mov	ebx, DWORD PTR [edx+ebx+304]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+ebx]
	jmp	SHORT $LN33@vertex_mea
$LN34@vertex_mea:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	add	eax, DWORD PTR [edx+ebx+304]
	mov	ebx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ebx*4]
$LN33@vertex_mea:
	mov	ebx, DWORD PTR _v_id$GSCopy$[ebp]
	cmp	ebx, eax
	je	SHORT $LN8@vertex_mea

; 194  :         fe = get_next_edge(fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN38@vertex_mea
	mov	esi, DWORD PTR [ecx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LL9@vertex_mea
$LN38@vertex_mea:
	mov	esi, DWORD PTR [ecx+32]
	jmp	SHORT $LL9@vertex_mea
$LN8@vertex_mea:

; 195  :       get_edge_side(get_fe_edge(fe),s1); 

	mov	edx, DWORD PTR _web+460
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	lea	ecx, DWORD PTR _s1$[ebp]
	push	ecx
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+edx]
	mov	ecx, esi
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_get_edge_side

; 196  :       get_edge_side(get_fe_edge(get_prev_edge(fe)),s2); 

	mov	ecx, DWORD PTR _web+460
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN44@vertex_mea
	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN43@vertex_mea
$LN44@vertex_mea:
	mov	eax, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [eax+28]
$LN43@vertex_mea:
	lea	edx, DWORD PTR _s2$[ebp]
	push	edx
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	push	eax
	call	_get_edge_side

; 197  :       s11 = dot(s1,s1,SDIM);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _s1$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fstp	QWORD PTR _s11$89156[ebp]

; 198  :       s12 = dot(s1,s2,SDIM);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _s2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s1$[ebp]
	push	ecx
	call	_dot
	fstp	QWORD PTR _s12$89157[ebp]

; 199  :       s22 = dot(s2,s2,SDIM);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _s2$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fst	QWORD PTR _s22$89158[ebp]

; 200  :       farea = sqrt(s11*s22-s12*s12);

	fmul	QWORD PTR _s11$89156[ebp]
	add	esp, 44					; 0000002cH
	fld	QWORD PTR _s12$89157[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)
	call	__CIsqrt

; 201  :       for ( i = 0 ; i < SDIM ; i++ ) 

	mov	edx, DWORD PTR _web+616
	xor	eax, eax
	cmp	edx, 4
	jl	$LN86@vertex_mea
	fld1
	lea	ecx, DWORD PTR [edx-3]
	fdiv	ST(0), ST(1)
	fld	QWORD PTR _s22$89158[ebp]
	fld	QWORD PTR _s12$89157[ebp]
	fld	QWORD PTR __real@3fe0000000000000
$LN70@vertex_mea:

; 202  :         force[i] += 1/farea*(s1[i]*s22 - s12*s2[i])/2;

	fld	QWORD PTR _s1$[ebp+eax*8]
	add	eax, 4
	fmul	ST(0), ST(3)
	fld	QWORD PTR _s2$[ebp+eax*8-32]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _force$[ebp+eax*8-32]
	fstp	QWORD PTR _force$[ebp+eax*8-32]
	fld	QWORD PTR _s1$[ebp+eax*8-24]
	fmul	ST(0), ST(3)
	fld	QWORD PTR _s2$[ebp+eax*8-24]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _force$[ebp+eax*8-24]
	fstp	QWORD PTR _force$[ebp+eax*8-24]
	fld	QWORD PTR _s1$[ebp+eax*8-16]
	fmul	ST(0), ST(3)
	fld	QWORD PTR _s2$[ebp+eax*8-16]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _force$[ebp+eax*8-16]
	fstp	QWORD PTR _force$[ebp+eax*8-16]
	fld	QWORD PTR _s1$[ebp+eax*8-8]
	fmul	ST(0), ST(3)
	fld	QWORD PTR _s2$[ebp+eax*8-8]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _force$[ebp+eax*8-8]
	fstp	QWORD PTR _force$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN70@vertex_mea
	fstp	ST(3)
	jmp	SHORT $LC69@vertex_mea
$LN86@vertex_mea:
	fld	QWORD PTR _s22$89158[ebp]
	fld	QWORD PTR _s12$89157[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	fxch	ST(2)
	fxch	ST(1)
$LC69@vertex_mea:

; 201  :       for ( i = 0 ; i < SDIM ; i++ ) 

	cmp	eax, edx
	jge	SHORT $LN116@vertex_mea
	fld1
	fdivrp	ST(4), ST(0)
$LC7@vertex_mea:

; 202  :         force[i] += 1/farea*(s1[i]*s22 - s12*s2[i])/2;

	fld	QWORD PTR _s1$[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(2)
	fld	QWORD PTR _s2$[ebp+eax*8-8]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(3)
	fadd	QWORD PTR _force$[ebp+eax*8-8]
	fstp	QWORD PTR _force$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC7@vertex_mea
$LN116@vertex_mea:

; 203  :       fe_id = get_next_vertex_facet(v_id,fe_id);

	mov	edx, DWORD PTR _fe_id$89148[ebp]
	fstp	ST(0)
	fstp	ST(0)
	push	edx
	fstp	ST(0)
	push	ebx
	fstp	ST(0)
	call	_get_next_vertex_facet

; 204  :     } while ( !equal_element(start_fe,fe_id) );

	mov	ecx, eax
	or	ecx, 134217728				; 08000000H
	add	esp, 8
	mov	DWORD PTR _fe_id$89148[ebp], eax
	cmp	DWORD PTR tv928[ebp], ecx
	jne	$LL12@vertex_mea
$LN122@vertex_mea:

; 205  : 
; 206  :     force_project(force,v_id,projf);

	lea	edx, DWORD PTR _projf$[ebp]
	push	edx
	lea	eax, DWORD PTR _force$[ebp]
	push	ebx
	push	eax
	call	_force_project
	add	esp, 12					; 0000000cH
$LN88@vertex_mea:

; 207  :   }
; 208  :   
; 209  :   area = calc_vertex_normal(v_id,NULLID,vnorm); /* norm comes back unit */

	lea	ecx, DWORD PTR _vnorm$[ebp]
	push	ecx
	push	0
	push	ebx
	call	_calc_vertex_normal
	fst	QWORD PTR _area$[ebp]

; 210  :   if ( area == 0.0 ) meanc = 0.0;

	fldz
	add	esp, 12					; 0000000cH
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	SHORT $LN27@vertex_mea

; 211  :   else if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	fstp	ST(0)

; 212  :     meanc = dot(force,vnorm,SDIM)/area*3/2.0;

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _vnorm$[ebp]
	lea	ecx, DWORD PTR _force$[ebp]
	push	eax
	push	ecx
	jne	SHORT $LN2@vertex_mea
	call	_dot
	fdiv	QWORD PTR _area$[ebp]

; 213  :   else
; 214  :     meanc = dot(force,vnorm,SDIM)/area*2;

	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	fmul	QWORD PTR __real@4008000000000000
	fmul	QWORD PTR __real@3fe0000000000000

; 215  : 
; 216  :   return meanc;
; 217  : } /* end vertex_mean_curvature */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@vertex_mea:

; 213  :   else
; 214  :     meanc = dot(force,vnorm,SDIM)/area*2;

	call	_dot
	fdiv	QWORD PTR _area$[ebp]
	add	esp, 12					; 0000000cH
	fadd	ST(0), ST(0)
$LN27@vertex_mea:

; 215  : 
; 216  :   return meanc;
; 217  : } /* end vertex_mean_curvature */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_vertex_mean_curvature ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@GFFPDDMA@Internal?5error?3?5sd_vertex_mean_c@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_sd_vertex_mean_curvature
EXTRN	_vertex_total_vol_grad:PROC
EXTRN	_kb_error:PROC
EXTRN	_errmsg:BYTE
EXTRN	_sprintf:PROC
EXTRN	_elnames:BYTE
;	COMDAT ??_C@_0DI@GFFPDDMA@Internal?5error?3?5sd_vertex_mean_c@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DI@GFFPDDMA@Internal?5error?3?5sd_vertex_mean_c@ DB 'Internal erro'
	DB	'r: sd_vertex_mean_curvature at vertex %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\teix.c
CONST	ENDS
;	COMDAT _sd_vertex_mean_curvature
_TEXT	SEGMENT
_s11$89211 = -292					; size = 8
_s22$89213 = -284					; size = 8
_tension$89195 = -276					; size = 8
tv990 = -272						; size = 4
_fe_id$89203 = -268					; size = 4
_tension$89214 = -264					; size = 8
_area$ = -264						; size = 8
_s12$89212 = -256					; size = 8
_i$ = -252						; size = 4
_v_id$GSCopy$ = -248					; size = 4
_projf$ = -244						; size = 48
_vnorm$ = -196						; size = 48
_s2$ = -148						; size = 48
_s1$ = -100						; size = 48
_force$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_sd_vertex_mean_curvature PROC				; COMDAT

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 232  :   REAL meanc = 0.0;
; 233  :   REAL force[MAXCOORD],projf[MAXCOORD];
; 234  :   REAL area = 0.0,farea;
; 235  :   REAL s1[MAXCOORD],s2[MAXCOORD];
; 236  :   REAL vnorm[MAXCOORD];
; 237  :   int i;
; 238  : 
; 239  :   for ( i = 0 ; i < MAXCOORD ; i++ ) 
; 240  :     force[i] = 0.0;

	fldz

; 241  : 
; 242  :   if ( web.representation == STRING )

	mov	eax, DWORD PTR _web+624
	mov	ecx, DWORD PTR _v_id$[ebp]
	fst	QWORD PTR _force$[ebp]
	push	ebx
	fst	QWORD PTR _force$[ebp+8]
	fst	QWORD PTR _force$[ebp+16]
	push	esi
	fst	QWORD PTR _force$[ebp+24]
	push	edi
	fst	QWORD PTR _force$[ebp+32]

; 270  :       fe = fe_id;
; 271  :       for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	DWORD PTR _v_id$GSCopy$[ebp], ecx
	fst	QWORD PTR _force$[ebp+40]
	cmp	eax, 1
	jne	$LN104@sd_vertex_

; 243  :   { edge_id start_e, e_id;
; 244  :     REAL len;
; 245  : 
; 246  :     e_id = start_e = get_vertex_edge(v_id);

	mov	eax, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	edi, DWORD PTR [ecx+28]

; 247  :     if ( !valid_id(e_id) ) return 0.0;

	test	edi, 268435456				; 10000000H
	je	$LN30@sd_vertex_
	mov	eax, DWORD PTR _web+124
	fstp	ST(0)
	mov	ebx, edi
	or	ebx, 134217728				; 08000000H
	npad	3
$LL24@sd_vertex_:

; 248  :     do 
; 249  :     { REAL tension = get_edge_density(e_id);

	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+eax]
	fld	QWORD PTR [edx+40]

; 250  :       REAL s11;
; 251  :       get_edge_side(e_id,s1); 

	lea	eax, DWORD PTR _s1$[ebp]
	push	eax
	fstp	QWORD PTR _tension$89195[ebp]
	push	edi
	call	_get_edge_side

; 252  :       s11 = dot(s1,s1,SDIM);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _s1$[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	add	esp, 20					; 00000014H

; 253  :       len = sqrt(s11);

	call	__CIsqrt

; 254  :       for ( i = 0 ; i < SDIM ; i++ ) 

	mov	edx, DWORD PTR _web+616
	xor	eax, eax
	cmp	edx, 4
	jl	SHORT $LN96@sd_vertex_
	fld	QWORD PTR _tension$89195[ebp]
	lea	ecx, DWORD PTR [edx-3]
	fdiv	ST(0), ST(1)
$LN78@sd_vertex_:

; 255  :         force[i] -= tension/len*s1[i];

	fld	QWORD PTR _s1$[ebp+eax*8]
	add	eax, 4
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR _force$[ebp+eax*8-32]
	fstp	QWORD PTR _force$[ebp+eax*8-32]
	fld	QWORD PTR _s1$[ebp+eax*8-24]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR _force$[ebp+eax*8-24]
	fstp	QWORD PTR _force$[ebp+eax*8-24]
	fld	QWORD PTR _s1$[ebp+eax*8-16]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR _force$[ebp+eax*8-16]
	fstp	QWORD PTR _force$[ebp+eax*8-16]
	fld	QWORD PTR _s1$[ebp+eax*8-8]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR _force$[ebp+eax*8-8]
	fstp	QWORD PTR _force$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN78@sd_vertex_

; 254  :       for ( i = 0 ; i < SDIM ; i++ ) 

	fstp	ST(0)
$LN96@sd_vertex_:
	cmp	eax, edx
	jge	SHORT $LN118@sd_vertex_
	fdivr	QWORD PTR _tension$89195[ebp]
$LC21@sd_vertex_:

; 255  :         force[i] -= tension/len*s1[i];

	fld	QWORD PTR _s1$[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR _force$[ebp+eax*8-8]
	fstp	QWORD PTR _force$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC21@sd_vertex_
$LN118@sd_vertex_:

; 256  :       e_id = get_next_tail_edge(e_id);

	mov	eax, DWORD PTR _web+124
	fstp	ST(0)
	mov	ecx, DWORD PTR [esi+eax]
	shr	edi, 27					; 0000001bH
	and	edi, 1
	mov	edi, DWORD PTR [ecx+edi*4+32]

; 257  :     } while ( !equal_element(start_e,e_id) );

	mov	edx, edi
	or	edx, 134217728				; 08000000H
	cmp	ebx, edx
	jne	$LL24@sd_vertex_

; 258  : 
; 259  :     force_project(force,v_id,projf);

	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	lea	eax, DWORD PTR _projf$[ebp]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _force$[ebp]
	push	edx
	call	_force_project
	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	jmp	$LN136@sd_vertex_
$LN104@sd_vertex_:

; 241  : 
; 242  :   if ( web.representation == STRING )

	fstp	ST(0)

; 260  :   }
; 261  :   else if ( web.representation == SOAPFILM )

	cmp	eax, 2
	jne	$LN17@sd_vertex_

; 262  :   { facetedge_id fe_id,start_fe;
; 263  : 
; 264  :     fe_id = start_fe = get_vertex_first_facet(v_id);

	push	ecx
	call	_get_vertex_first_facet
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _fe_id$89203[ebp], esi

; 265  :     if ( !valid_id(fe_id) ) return 0.0;

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN92@sd_vertex_
	fldz
	pop	edi
	pop	esi
	pop	ebx

; 301  : 
; 302  :   return meanc;
; 303  : } /* end sd_vertex_mean_curvature() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN92@sd_vertex_:
	or	eax, 134217728				; 08000000H

; 262  :   { facetedge_id fe_id,start_fe;
; 263  : 
; 264  :     fe_id = start_fe = get_vertex_first_facet(v_id);

	mov	DWORD PTR tv990[ebp], eax
	npad	5
$LL15@sd_vertex_:

; 266  :     do 
; 267  :     { facetedge_id fe;
; 268  :       REAL s11,s12,s22;
; 269  :       REAL tension = get_facet_density(get_fe_facet(fe_id));

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN37@sd_vertex_
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN36@sd_vertex_
$LN37@sd_vertex_:
	mov	ecx, DWORD PTR _web+460
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN36@sd_vertex_
	xor	eax, 134217728				; 08000000H
$LN36@sd_vertex_:
	mov	ecx, DWORD PTR _web+236

; 270  :       fe = fe_id;
; 271  :       for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	edi, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+32]
	mov	edx, DWORD PTR _web+216
	fstp	QWORD PTR _tension$89214[ebp]
	mov	DWORD PTR _i$[ebp], 0
	npad	4
$LL98@sd_vertex_:

; 272  :       { if ( equal_id(v_id,get_fe_headv(fe)) )

	mov	ecx, DWORD PTR _web+460
	mov	ebx, DWORD PTR _dymem
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN43@sd_vertex_
	mov	ebx, DWORD PTR [edx+ebx+304]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+ebx]
	jmp	SHORT $LN42@sd_vertex_
$LN43@sd_vertex_:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	add	eax, DWORD PTR [edx+ebx+304]
	mov	ebx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ebx*4]
$LN42@sd_vertex_:
	mov	ebx, DWORD PTR _v_id$GSCopy$[ebp]
	cmp	ebx, eax
	je	SHORT $LN99@sd_vertex_

; 273  :           break;
; 274  :         fe = get_next_edge(fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN47@sd_vertex_
	mov	esi, DWORD PTR [ecx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN11@sd_vertex_
$LN47@sd_vertex_:
	mov	esi, DWORD PTR [ecx+32]
$LN11@sd_vertex_:

; 270  :       fe = fe_id;
; 271  :       for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, 3
	jl	$LL98@sd_vertex_
$LN99@sd_vertex_:

; 275  :       }
; 276  :       if ( i == FACET_VERTS )

	cmp	DWORD PTR _i$[ebp], 3
	jne	SHORT $LN100@sd_vertex_

; 277  :       { sprintf(errmsg,"Internal error: sd_vertex_mean_curvature at vertex %s.\n",
; 278  :           ELNAME(v_id));

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN32@sd_vertex_
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN33@sd_vertex_
$LN32@sd_vertex_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN33@sd_vertex_:
	push	eax
	push	OFFSET ??_C@_0DI@GFFPDDMA@Internal?5error?3?5sd_vertex_mean_c@
	push	OFFSET _errmsg
	call	_sprintf

; 279  :         kb_error(3745,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3745					; 00000ea1H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN100@sd_vertex_:

; 280  :       }
; 281  :       get_edge_side(get_fe_edge(fe),s1); 

	mov	eax, DWORD PTR _web+460
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	lea	edx, DWORD PTR _s1$[ebp]
	push	edx
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+eax]
	mov	edx, esi
	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR [ecx+20]
	push	edx
	call	_get_edge_side

; 282  :       get_edge_side(get_fe_edge(get_prev_edge(fe)),s2); 

	mov	ecx, DWORD PTR _web+460
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN53@sd_vertex_
	mov	eax, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [eax+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN52@sd_vertex_
$LN53@sd_vertex_:
	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edx+28]
$LN52@sd_vertex_:
	lea	edx, DWORD PTR _s2$[ebp]
	push	edx
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	push	eax
	call	_get_edge_side

; 283  :       s11 = dot(s1,s1,SDIM);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _s1$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fstp	QWORD PTR _s11$89211[ebp]

; 284  :       s12 = dot(s1,s2,SDIM);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _s2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s1$[ebp]
	push	ecx
	call	_dot
	fstp	QWORD PTR _s12$89212[ebp]

; 285  :       s22 = dot(s2,s2,SDIM);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _s2$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fst	QWORD PTR _s22$89213[ebp]

; 286  :       farea = sqrt(s11*s22-s12*s12);

	fmul	QWORD PTR _s11$89211[ebp]
	add	esp, 44					; 0000002cH
	fld	QWORD PTR _s12$89212[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)
	call	__CIsqrt

; 287  :       for ( i = 0 ; i < SDIM ; i++ ) 

	mov	edx, DWORD PTR _web+616
	xor	eax, eax
	cmp	edx, 4
	jl	$LN97@sd_vertex_
	fld	QWORD PTR _tension$89214[ebp]
	lea	ecx, DWORD PTR [edx-3]
	fdiv	ST(0), ST(1)
	fld	QWORD PTR _s22$89213[ebp]
	fld	QWORD PTR _s12$89212[ebp]
	fld	QWORD PTR __real@3fe0000000000000
$LN81@sd_vertex_:

; 288  :         force[i] += tension/farea*(s1[i]*s22 - s12*s2[i])/2;

	fld	QWORD PTR _s1$[ebp+eax*8]
	add	eax, 4
	fmul	ST(0), ST(3)
	fld	QWORD PTR _s2$[ebp+eax*8-32]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _force$[ebp+eax*8-32]
	fstp	QWORD PTR _force$[ebp+eax*8-32]
	fld	QWORD PTR _s1$[ebp+eax*8-24]
	fmul	ST(0), ST(3)
	fld	QWORD PTR _s2$[ebp+eax*8-24]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _force$[ebp+eax*8-24]
	fstp	QWORD PTR _force$[ebp+eax*8-24]
	fld	QWORD PTR _s1$[ebp+eax*8-16]
	fmul	ST(0), ST(3)
	fld	QWORD PTR _s2$[ebp+eax*8-16]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _force$[ebp+eax*8-16]
	fstp	QWORD PTR _force$[ebp+eax*8-16]
	fld	QWORD PTR _s1$[ebp+eax*8-8]
	fmul	ST(0), ST(3)
	fld	QWORD PTR _s2$[ebp+eax*8-8]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _force$[ebp+eax*8-8]
	fstp	QWORD PTR _force$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN81@sd_vertex_
	fstp	ST(3)
	jmp	SHORT $LC80@sd_vertex_
$LN97@sd_vertex_:
	fld	QWORD PTR _s22$89213[ebp]
	fld	QWORD PTR _s12$89212[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	fxch	ST(2)
	fxch	ST(1)
$LC80@sd_vertex_:

; 287  :       for ( i = 0 ; i < SDIM ; i++ ) 

	cmp	eax, edx
	jge	SHORT $LN130@sd_vertex_
	fld	QWORD PTR _tension$89214[ebp]
	fdivrp	ST(4), ST(0)
$LC7@sd_vertex_:

; 288  :         force[i] += tension/farea*(s1[i]*s22 - s12*s2[i])/2;

	fld	QWORD PTR _s1$[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(2)
	fld	QWORD PTR _s2$[ebp+eax*8-8]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(3)
	fadd	QWORD PTR _force$[ebp+eax*8-8]
	fstp	QWORD PTR _force$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC7@sd_vertex_
$LN130@sd_vertex_:

; 289  :       fe_id = get_next_vertex_facet(v_id,fe_id);

	mov	edx, DWORD PTR _fe_id$89203[ebp]
	fstp	ST(0)
	fstp	ST(0)
	push	edx
	fstp	ST(0)
	push	ebx
	fstp	ST(0)
	call	_get_next_vertex_facet
	mov	esi, eax

; 290  :     } while ( !equal_element(start_fe,fe_id) );

	or	eax, 134217728				; 08000000H
	add	esp, 8
	mov	DWORD PTR _fe_id$89203[ebp], esi
	cmp	DWORD PTR tv990[ebp], eax
	jne	$LL15@sd_vertex_

; 291  : 
; 292  :     force_project(force,v_id,projf);

	lea	ecx, DWORD PTR _projf$[ebp]
	push	ecx
	lea	edx, DWORD PTR _force$[ebp]
	push	ebx
	push	edx
	call	_force_project
	mov	ecx, ebx
$LN136@sd_vertex_:
	add	esp, 12					; 0000000cH
$LN17@sd_vertex_:

; 293  :   }
; 294  :   
; 295  :   area = vertex_total_vol_grad(v_id,vnorm); /* norm comes back unit */

	lea	eax, DWORD PTR _vnorm$[ebp]
	push	eax
	push	ecx
	call	_vertex_total_vol_grad
	fst	QWORD PTR _area$[ebp]

; 296  :   if ( area == 0.0 ) meanc = 0.0;

	fldz
	add	esp, 8
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	SHORT $LN30@sd_vertex_

; 297  :   else if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	fstp	ST(0)

; 298  :     meanc = dot(force,vnorm,SDIM)/area*3/2.0;

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _vnorm$[ebp]
	lea	eax, DWORD PTR _force$[ebp]
	push	edx
	push	eax
	jne	SHORT $LN2@sd_vertex_
	call	_dot
	fdiv	QWORD PTR _area$[ebp]

; 299  :   else
; 300  :     meanc = dot(force,vnorm,SDIM)/area*2;

	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	fmul	QWORD PTR __real@4008000000000000
	fmul	QWORD PTR __real@3fe0000000000000

; 301  : 
; 302  :   return meanc;
; 303  : } /* end sd_vertex_mean_curvature() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@sd_vertex_:

; 299  :   else
; 300  :     meanc = dot(force,vnorm,SDIM)/area*2;

	call	_dot
	fdiv	QWORD PTR _area$[ebp]
	add	esp, 12					; 0000000cH
	fadd	ST(0), ST(0)
$LN30@sd_vertex_:

; 301  : 
; 302  :   return meanc;
; 303  : } /* end sd_vertex_mean_curvature() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_sd_vertex_mean_curvature ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@HDMKGNIO@lmc_mobility?$AA@		; `string'
PUBLIC	??_C@_0BD@KONNPILH@lmc_mean_curvature?$AA@	; `string'
PUBLIC	??_C@_0EF@IBDNCABI@Can?5do?5laplacian_mean_curvature?5@ ; `string'
PUBLIC	_laplacian_mean_curvature_init
EXTRN	_find_attribute:PROC
EXTRN	_add_attribute:PROC
;	COMDAT ??_C@_0N@HDMKGNIO@lmc_mobility?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0N@HDMKGNIO@lmc_mobility?$AA@ DB 'lmc_mobility', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KONNPILH@lmc_mean_curvature?$AA@
CONST	SEGMENT
??_C@_0BD@KONNPILH@lmc_mean_curvature?$AA@ DB 'lmc_mean_curvature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@IBDNCABI@Can?5do?5laplacian_mean_curvature?5@
CONST	SEGMENT
??_C@_0EF@IBDNCABI@Can?5do?5laplacian_mean_curvature?5@ DB 'Can do laplac'
	DB	'ian_mean_curvature only in STRING and SOAPFILM models.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\teix.c
CONST	ENDS
;	COMDAT _laplacian_mean_curvature_init
_TEXT	SEGMENT
_one$ = -4						; size = 4
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_laplacian_mean_curvature_init PROC			; COMDAT

; 342  : { int one = 1;

	push	ebp
	mov	ebp, esp
	push	ecx

; 343  :   vertex_id v_id;
; 344  : 
; 345  :   if ( (web.representation != STRING)  && (web.representation != SOAPFILM) )

	mov	eax, DWORD PTR _web+624
	mov	DWORD PTR _one$[ebp], 1
	cmp	eax, 1
	je	SHORT $LN21@laplacian_
	cmp	eax, 2
	je	SHORT $LN21@laplacian_

; 346  :     kb_error(4085,"Can do laplacian_mean_curvature only in STRING and SOAPFILM models.\n",
; 347  :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EF@IBDNCABI@Can?5do?5laplacian_mean_curvature?5@
	push	4085					; 00000ff5H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN21@laplacian_:

; 348  : 
; 349  :   if ( lmc_mc_attr < 0 )

	cmp	DWORD PTR _lmc_mc_attr, 0
	jge	SHORT $LN20@laplacian_

; 350  :     lmc_mc_attr = add_attribute(VERTEX,LMC_MC_ATTR_NAME,REAL_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _one$[ebp]
	push	eax
	push	0
	push	1
	push	OFFSET ??_C@_0BD@KONNPILH@lmc_mean_curvature?$AA@
	push	0
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _lmc_mc_attr, eax
$LN20@laplacian_:

; 351  : 
; 352  : 
; 353  :   /* create mobility attribute, if user didn't */
; 354  :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	push	esi
	push	edi

; 355  :   { edge_id e_id;
; 356  :     lmc_mobility_attr = find_attribute(EDGE,LMC_MOBILITY_ATTR_NAME);

	push	OFFSET ??_C@_0N@HDMKGNIO@lmc_mobility?$AA@
	jne	$LN19@laplacian_
	push	1
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _lmc_mobility_attr, eax

; 357  :     if ( lmc_mobility_attr < 0 )

	test	eax, eax
	jns	$LN38@laplacian_

; 358  :     { lmc_mobility_attr = add_attribute(EDGE,LMC_MOBILITY_ATTR_NAME,REAL_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _one$[ebp]
	push	ecx
	push	0
	push	1
	push	OFFSET ??_C@_0N@HDMKGNIO@lmc_mobility?$AA@
	push	1
	call	_add_attribute

; 359  :       FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	add	esp, 32					; 00000020H
	mov	DWORD PTR _lmc_mobility_attr, eax
	test	edx, 268435456				; 10000000H
	je	$LN38@laplacian_
	fld1
	mov	edi, DWORD PTR _web+124
$LN36@laplacian_:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	esi, esi
	or	ecx, esi
	je	SHORT $LN16@laplacian_

; 360  :          *(REAL*)get_extra(e_id,lmc_mobility_attr) = 1.0;

	mov	ecx, DWORD PTR _lmc_mobility_attr
	shr	edx, 29					; 0000001dH
	imul	ecx, 240				; 000000f0H
	imul	edx, 112				; 00000070H
	mov	esi, DWORD PTR _web[edx+104]
	mov	edx, DWORD PTR _web[edx+12]
	mov	edx, DWORD PTR [edx+eax]
	add	esi, ecx
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [esi+ecx+64]
	fst	QWORD PTR [ecx+edx]
	mov	edi, DWORD PTR _web+124
$LN16@laplacian_:

; 359  :       FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LN36@laplacian_

; 361  :     }
; 362  :    }
; 363  :    else

	jmp	$LN50@laplacian_
$LN19@laplacian_:

; 364  :    { facet_id f_id;
; 365  :      lmc_mobility_attr = find_attribute(FACET,LMC_MOBILITY_ATTR_NAME);

	push	2
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _lmc_mobility_attr, eax

; 366  :     if ( lmc_mobility_attr < 0 )

	test	eax, eax
	jns	$LN38@laplacian_

; 367  :     { lmc_mobility_attr = add_attribute(FACET,LMC_MOBILITY_ATTR_NAME,REAL_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _one$[ebp]
	push	ecx
	push	0
	push	1
	push	OFFSET ??_C@_0N@HDMKGNIO@lmc_mobility?$AA@
	push	2
	call	_add_attribute

; 368  :       FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	add	esp, 32					; 00000020H
	mov	DWORD PTR _lmc_mobility_attr, eax
	test	edx, 268435456				; 10000000H
	je	SHORT $LN38@laplacian_
	fld1
	mov	edi, DWORD PTR _web+236
$LN37@laplacian_:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	esi, esi
	or	ecx, esi
	je	SHORT $LN9@laplacian_

; 369  :          *(REAL*)get_extra(f_id,lmc_mobility_attr) = 1.0;

	mov	ecx, DWORD PTR _lmc_mobility_attr
	shr	edx, 29					; 0000001dH
	imul	ecx, 240				; 000000f0H
	imul	edx, 112				; 00000070H
	mov	esi, DWORD PTR _web[edx+104]
	mov	edx, DWORD PTR _web[edx+12]
	mov	edx, DWORD PTR [edx+eax]
	add	esi, ecx
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [esi+ecx+64]
	fst	QWORD PTR [ecx+edx]
	mov	edi, DWORD PTR _web+236
$LN9@laplacian_:

; 368  :       FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LN37@laplacian_
$LN50@laplacian_:
	fstp	ST(0)
$LN38@laplacian_:

; 370  :     }
; 371  : 
; 372  :   }
; 373  : 
; 374  :   /* mean curvatures at vertices */
; 375  :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+48
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN3@laplacian_
	mov	edi, DWORD PTR _web+12
$LL5@laplacian_:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN4@laplacian_

; 376  :     *(REAL*)get_extra(v_id,lmc_mc_attr) = sd_vertex_mean_curvature(v_id);

	mov	edx, DWORD PTR _lmc_mc_attr
	mov	eax, ecx
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	edi, edx
	mov	edx, DWORD PTR _dymem
	mov	edi, DWORD PTR [edi+edx+64]
	add	edi, DWORD PTR [eax+esi]
	push	ecx
	call	_sd_vertex_mean_curvature
	add	esp, 4
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR _web+12
$LN4@laplacian_:

; 370  :     }
; 371  : 
; 372  :   }
; 373  : 
; 374  :   /* mean curvatures at vertices */
; 375  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [esi+edi]
	mov	ecx, DWORD PTR [eax]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL5@laplacian_
$LN3@laplacian_:
	pop	edi
	pop	esi

; 377  : } // end laplacian_mean_curvature_init()

	mov	esp, ebp
	pop	ebp
	ret	0
_laplacian_mean_curvature_init ENDP
_TEXT	ENDS
PUBLIC	__real@4018000000000000
PUBLIC	_v_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_laplacian_mean_curvature_value
;	COMDAT __real@4018000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\teix.c
CONST	ENDS
;	COMDAT _laplacian_mean_curvature_value
_TEXT	SEGMENT
_s12$89321 = -156					; size = 8
_h1$89303 = -148					; size = 8
_h2$89305 = -140					; size = 8
_h$89304 = -132						; size = 8
tv828 = -124						; size = 8
_s11$89320 = -124					; size = 8
_energy$ = -116						; size = 8
tv752 = -108						; size = 4
_start_fe$89314 = -108					; size = 4
_v_info$GSCopy$ = -104					; size = 4
_start_e$89292 = -104					; size = 4
_side1$89306 = -100					; size = 48
_side2$89307 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_v_info$ = 8						; size = 4
_laplacian_mean_curvature_value PROC			; COMDAT

; 386  : { REAL energy = 0.0;

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	fldz

; 387  :  
; 388  :   /* Try integral of square gradient of mean curvature as energy,
; 389  :      even though it is not exact. */
; 390  : 
; 391  :   if ( web.representation == STRING )

	mov	eax, DWORD PTR _web+624
	push	ebx
	fst	QWORD PTR _energy$[ebp]
	push	esi
	mov	esi, DWORD PTR _v_info$[ebp]
	push	edi

; 445  :       }
; 446  :       fe = get_next_vertex_facet(v_info->v[0],fe);

	mov	DWORD PTR _v_info$GSCopy$[ebp], esi
	cmp	eax, 1
	jne	$LN6@laplacian_@2

; 392  :   {
; 393  :     REAL h1,h;
; 394  :     edge_id e_id,start_e;
; 395  : 
; 396  :     h = *(REAL*)get_extra(v_info->v[0],lmc_mc_attr);

	mov	ecx, DWORD PTR [esi+16]
	mov	esi, DWORD PTR _lmc_mc_attr
	mov	eax, ecx
	imul	esi, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edi, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR _dymem
	add	eax, esi
	mov	eax, DWORD PTR [eax+edx+64]

; 397  :     e_id = start_e = get_vertex_edge(v_info->v[0]);

	and	ecx, 134217727				; 07ffffffH
	fld	QWORD PTR [edi+eax]
	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+ecx*4]
	fld	QWORD PTR __real@3fe0000000000000
	mov	eax, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	DWORD PTR _start_e$89292[ebp], eax

; 404  :       h1 = *(REAL*)get_extra(v1,lmc_mc_attr);

	mov	DWORD PTR tv752[ebp], ecx
	jmp	SHORT $LN8@laplacian_@2
$LN51@laplacian_@2:

; 397  :     e_id = start_e = get_vertex_edge(v_info->v[0]);

	mov	ecx, DWORD PTR tv752[ebp]
$LN8@laplacian_@2:

; 398  :     do
; 399  :     { REAL len1;
; 400  :       vertex_id v1;
; 401  : 
; 402  :       len1 = eptr(e_id)->length; // since get_edge_length(e_id) causes recursion in calc_quants;

	mov	edi, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	fld	QWORD PTR [edx+48]

; 403  :       v1 = get_edge_headv(e_id);

	shr	eax, 27					; 0000001bH
	mov	edi, eax
	and	edi, 1
	jne	SHORT $LN67@laplacian_@2
	mov	eax, DWORD PTR _web+636
	lea	ecx, DWORD PTR [ecx+eax*4]
$LN67@laplacian_@2:
	mov	ecx, DWORD PTR [ecx+edx]

; 404  :       h1 = *(REAL*)get_extra(v1,lmc_mc_attr);

	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ebx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _dymem
	add	eax, esi
	mov	eax, DWORD PTR [eax+ebx+64]
	fld	QWORD PTR [ecx+eax]

; 405  :       energy += (h-h1)*(h-h1)/len1/2;  /* /2 since double counting */
; 406  :       e_id = get_next_tail_edge(e_id);

	mov	eax, DWORD PTR [edx+edi*4+32]
	fsubr	ST(0), ST(3)
	fmul	ST(0), ST(0)
	fdivrp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	faddp	ST(3), ST(0)

; 407  :     } while ( !equal_id(e_id,start_e) );

	cmp	eax, DWORD PTR _start_e$89292[ebp]
	jne	SHORT $LN51@laplacian_@2
	pop	edi
	fstp	ST(1)
	pop	esi
	fstp	ST(0)
	pop	ebx

; 452  : } // end laplacian_mean_curvature_value()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@laplacian_@2:

; 408  :   }
; 409  : 
; 410  :   if ( web.representation == SOAPFILM )

	cmp	eax, 2
	jne	$LN2@laplacian_@2

; 411  :   { 
; 412  :     REAL h1,h,h2;
; 413  :     REAL side1[MAXCOORD],side2[MAXCOORD];
; 414  :     edge_id edge1,edge2;
; 415  :     vertex_id v1,v2;
; 416  :     facet_id f_id;
; 417  :     facetedge_id fe,start_fe;
; 418  :     REAL mobility;
; 419  :    
; 420  :     h = *(REAL*)get_extra(v_info->v[0],lmc_mc_attr);

	mov	ecx, DWORD PTR [esi+16]
	fstp	ST(0)
	mov	edx, DWORD PTR _lmc_mc_attr
	mov	ebx, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	edi, edx
	mov	edi, DWORD PTR [edi+ebx+64]
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]

; 421  : 
; 422  :     fe = start_fe = get_vertex_first_facet(v_info->v[0]);

	push	ecx
	fld	QWORD PTR [edi+edx]
	fstp	QWORD PTR _h$89304[ebp]
	call	_get_vertex_first_facet
	add	esp, 4
	mov	DWORD PTR _start_fe$89314[ebp], eax
	mov	ebx, eax
	npad	12
$LL4@laplacian_@2:

; 423  :     do
; 424  :     { REAL s11,s12,s22,det;
; 425  : 
; 426  :       f_id = get_fe_facet(fe);

	mov	ecx, DWORD PTR _web+460
	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN25@laplacian_@2
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN24@laplacian_@2
$LN25@laplacian_@2:
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+24]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN24@laplacian_@2
	xor	eax, 134217728				; 08000000H
$LN24@laplacian_@2:

; 427  :       mobility = *(REAL*)get_f_extra(f_id,lmc_mobility_attr);

	mov	edx, DWORD PTR _lmc_mobility_attr

; 428  :       if ( mobility != 0.0 )

	mov	edi, DWORD PTR _web+236
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+edi+64]
	fld	QWORD PTR [eax+edx]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN52@laplacian_@2

; 429  :       {
; 430  :         edge1 = get_fe_edge(fe);

	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ecx]
	mov	esi, ebx
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [eax+20]

; 431  :         get_edge_side(edge1,side1);

	lea	ecx, DWORD PTR _side1$89306[ebp]
	push	ecx
	push	esi
	call	_get_edge_side

; 432  :         v1 = get_edge_headv(edge1);

	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR _web+216
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN31@laplacian_@2
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	ecx, DWORD PTR [eax+ecx]
	jmp	SHORT $LN30@laplacian_@2
$LN31@laplacian_@2:
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+304]
	mov	ecx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [eax+ecx*4]
$LN30@laplacian_@2:

; 433  :         h1 = *(REAL*)get_extra(v1,lmc_mc_attr);

	mov	edx, DWORD PTR _lmc_mc_attr
	mov	eax, ecx
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	esi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	esi, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [esi+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]

; 434  :         edge2 = get_fe_edge(inverse_id(get_prev_edge(fe)));

	mov	ecx, DWORD PTR _web+460
	fld	QWORD PTR [edx+eax]
	fstp	QWORD PTR _h1$89303[ebp]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN37@laplacian_@2
	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN36@laplacian_@2
$LN37@laplacian_@2:
	mov	eax, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [eax+28]
$LN36@laplacian_@2:
	xor	eax, 134217728				; 08000000H
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 435  :         get_edge_side(edge2,side2);

	lea	edx, DWORD PTR _side2$89307[ebp]
	mov	esi, eax
	push	edx
	push	esi
	call	_get_edge_side

; 436  :         v2 = get_edge_headv(edge2);

	mov	edx, DWORD PTR _dymem
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN43@laplacian_@2
	mov	eax, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edx+304]
	mov	ecx, DWORD PTR [ecx+eax]
	jmp	SHORT $LN42@laplacian_@2
$LN43@laplacian_@2:
	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _web+216
	add	eax, DWORD PTR [ecx+edx+304]
	mov	ecx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [eax+ecx*4]
$LN42@laplacian_@2:

; 437  :         h2 = *(REAL*)get_extra(v2,lmc_mc_attr);

	mov	edi, DWORD PTR _lmc_mc_attr
	mov	eax, ecx
	imul	edi, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	esi, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	add	eax, edi
	mov	edx, DWORD PTR [eax+edx+64]

; 438  : 
; 439  : 
; 440  :         s11 = SDIM_dot(side1,side1);

	mov	eax, DWORD PTR _web+616
	push	eax
	fld	QWORD PTR [ecx+edx]
	lea	ecx, DWORD PTR _side1$89306[ebp]
	push	ecx
	fstp	QWORD PTR _h2$89305[ebp]
	mov	edx, ecx
	push	edx
	call	_dot

; 441  :         s12 = SDIM_dot(side1,side2);

	mov	eax, DWORD PTR _web+616
	push	eax
	fstp	QWORD PTR _s11$89320[ebp]
	lea	ecx, DWORD PTR _side2$89307[ebp]
	push	ecx
	lea	edx, DWORD PTR _side1$89306[ebp]
	push	edx
	call	_dot

; 442  :         s22 = SDIM_dot(side2,side2);

	mov	eax, DWORD PTR _web+616
	fstp	QWORD PTR _s12$89321[ebp]
	push	eax
	lea	ecx, DWORD PTR _side2$89307[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot

; 443  :         det = sqrt(s11*s22 - s12*s12);
; 444  :         energy += ((h1-h)*(h1-h)*s22 - 2*(h1-h)*(h2-h)*s12 + (h2-h)*(h2-h)*s11)/det/6;

	fld	QWORD PTR _h1$89303[ebp]
	fld	QWORD PTR _h$89304[ebp]
	add	esp, 36					; 00000024H
	fsub	ST(1), ST(0)
	fld	ST(1)
	fld	QWORD PTR _h2$89305[ebp]
	fsubrp	ST(2), ST(0)
	fld	ST(1)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(4)
	fxch	ST(3)
	fadd	ST(0), ST(0)
	fmulp	ST(2), ST(0)
	fld	QWORD PTR _s12$89321[ebp]
	fmul	ST(2), ST(0)
	fxch	ST(3)
	fsubrp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	fld	QWORD PTR _s11$89320[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(2)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR tv828[ebp]
	fmulp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)
	call	__CIsqrt
	fdivr	QWORD PTR tv828[ebp]
	mov	esi, DWORD PTR _v_info$GSCopy$[ebp]
	fdiv	QWORD PTR __real@4018000000000000
	fadd	QWORD PTR _energy$[ebp]
	fstp	QWORD PTR _energy$[ebp]
$LN52@laplacian_@2:

; 445  :       }
; 446  :       fe = get_next_vertex_facet(v_info->v[0],fe);

	mov	eax, DWORD PTR [esi+16]
	push	ebx
	push	eax
	call	_get_next_vertex_facet
	mov	ebx, eax
	add	esp, 8

; 447  :     } while ( !equal_id(fe,start_fe) );

	cmp	ebx, DWORD PTR _start_fe$89314[ebp]
	jne	$LL4@laplacian_@2

; 448  : 
; 449  :   } /* end soapfilm */
; 450  : 
; 451  :   return energy;

	fld	QWORD PTR _energy$[ebp]
$LN2@laplacian_@2:

; 452  : } // end laplacian_mean_curvature_value()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_laplacian_mean_curvature_value ENDP
_TEXT	ENDS
PUBLIC	_v_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_laplacian_mean_curvature_grad
; Function compile flags: /Ogtp
;	COMDAT _laplacian_mean_curvature_grad
_TEXT	SEGMENT
_h$89365 = -220						; size = 8
_vgradmag$89363 = -212					; size = 8
_h2$89366 = -204					; size = 8
_s11$89384 = -196					; size = 8
_h1$89364 = -188					; size = 8
_s12$89385 = -180					; size = 8
tv691 = -176						; size = 4
tv845 = -172						; size = 8
_mobility$89378 = -172					; size = 8
_v_info$GSCopy$ = -164					; size = 4
_flux$89370 = -160					; size = 8
tv730 = -156						; size = 4
_start_fe$89377 = -152					; size = 4
_start_e$89346 = -152					; size = 4
_side1$89368 = -148					; size = 48
_side2$89369 = -100					; size = 48
_normal$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_info$ = 8						; size = 4
_laplacian_mean_curvature_grad PROC			; COMDAT

; 461  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 462  :   int i;
; 463  :   REAL normal[MAXCOORD];
; 464  : 
; 465  :   if ( web.representation == STRING )

	mov	eax, DWORD PTR _web+624
	push	ebx
	push	esi
	mov	esi, DWORD PTR _v_info$[ebp]
	push	edi

; 548  :       }
; 549  :       fe = get_next_vertex_facet(v_info->v[0],fe);

	mov	DWORD PTR _v_info$GSCopy$[ebp], esi
	cmp	eax, 1
	jne	$LN17@laplacian_@3

; 466  :   {
; 467  :     /* compute Laplacian and multiply by normal */
; 468  :     REAL len1;
; 469  :     vertex_id v1;
; 470  :     REAL h1,h;
; 471  :     REAL lap = 0;
; 472  :     REAL flux; /* into vertex star */
; 473  :     REAL vgradmag;
; 474  :     REAL mobility;
; 475  :     edge_id e_id,start_e;
; 476  : 
; 477  :     vgradmag = vertex_total_vol_grad(v_info->v[0],normal);

	mov	ecx, DWORD PTR [esi+16]
	lea	eax, DWORD PTR _normal$[ebp]
	push	eax
	push	ecx
	call	_vertex_total_vol_grad

; 478  :     if ( vgradmag == 0 )

	fld	ST(0)
	fldz
	add	esp, 8
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H

; 479  :        return 0.0; /* internal vertex probably */

	jnp	$LN72@laplacian_@3

; 480  : 
; 481  :     h = *(REAL*)get_extra(v_info->v[0],lmc_mc_attr);

	mov	ecx, DWORD PTR [esi+16]
	mov	esi, DWORD PTR _lmc_mc_attr

; 482  :     e_id = start_e = get_vertex_edge(v_info->v[0]);
; 483  :     flux = 0.0;

	mov	ebx, DWORD PTR _lmc_mobility_attr
	imul	esi, 240				; 000000f0H
	mov	eax, ecx
	imul	ebx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edi, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR _dymem
	add	eax, esi
	mov	eax, DWORD PTR [eax+edx+64]
	and	ecx, 134217727				; 07ffffffH
	fld	QWORD PTR [edi+eax]
	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+ecx*4]
	fld	ST(1)
	mov	eax, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR _web+216
	mov	edi, DWORD PTR [ecx+edx+304]
	add	ebx, ecx
	mov	edx, DWORD PTR [ebx+edx+64]
	mov	DWORD PTR _start_e$89346[ebp], eax

; 488  :       h1 = *(REAL*)get_extra(v1,lmc_mc_attr);

	mov	DWORD PTR tv691[ebp], edi
	mov	DWORD PTR tv730[ebp], edx
	jmp	SHORT $LN15@laplacian_@3
$LN55@laplacian_@3:

; 482  :     e_id = start_e = get_vertex_edge(v_info->v[0]);
; 483  :     flux = 0.0;

	mov	edi, DWORD PTR tv691[ebp]
$LN15@laplacian_@3:

; 484  :     do
; 485  :     {
; 486  :       len1 = eptr(e_id)->length; // get_edge_length(e_id);

	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH

; 487  :       v1 = get_edge_headv(e_id);

	shr	eax, 27					; 0000001bH
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [edx]
	fld	QWORD PTR [ecx+48]
	mov	ebx, eax
	and	ebx, 1
	je	SHORT $LN23@laplacian_@3
	mov	ecx, DWORD PTR [edi+ecx]
	jmp	SHORT $LN22@laplacian_@3
$LN23@laplacian_@3:
	mov	eax, DWORD PTR _web+636
	lea	eax, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [eax+ecx]
$LN22@laplacian_@3:

; 489  :       mobility = *(REAL*)get_e_extra(e_id,lmc_mobility_attr);

	mov	edx, DWORD PTR [edx]

; 490  :       flux += mobility*(h-h1)/len1;

	fld	ST(2)
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edi, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _dymem
	add	eax, esi
	mov	eax, DWORD PTR [eax+edi+64]
	fsub	QWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR tv730[ebp]

; 491  :       e_id = get_next_tail_edge(e_id);

	mov	eax, DWORD PTR [edx+ebx*4+32]
	fmul	QWORD PTR [ecx+edx]
	fdivrp	ST(1), ST(0)
	faddp	ST(1), ST(0)

; 492  :     } while ( !equal_id(e_id,start_e) );

	cmp	eax, DWORD PTR _start_e$89346[ebp]
	jne	SHORT $LN55@laplacian_@3

; 493  : 
; 494  :     /* now multiply by normal */
; 495  :     lap = flux/vgradmag;
; 496  :     for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	fstp	ST(1)
	fdivrp	ST(2), ST(0)
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN72@laplacian_@3
	mov	ecx, DWORD PTR _v_info$GSCopy$[ebp]
$LN12@laplacian_@3:

; 497  :        v_info->grad[0][i] = lap*normal[i];

	fld	QWORD PTR _normal$[ebp+eax*8]
	mov	edx, DWORD PTR [ecx+1336]
	mov	edx, DWORD PTR [edx]
	fmul	ST(0), ST(2)
	inc	eax
	fstp	QWORD PTR [edx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN12@laplacian_@3
$LN72@laplacian_@3:
	pop	edi

; 493  : 
; 494  :     /* now multiply by normal */
; 495  :     lap = flux/vgradmag;
; 496  :     for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(1)
	pop	esi
	pop	ebx

; 560  : } /* end laplacian_mean_curvature_grad() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@laplacian_@3:

; 498  :    
; 499  :     return 0;
; 500  :   }
; 501  : 
; 502  :   /* Just soapfilm gets here */
; 503  : 
; 504  :   if ( web.representation == SOAPFILM )

	cmp	eax, 2
	jne	$LN54@laplacian_@3

; 505  :   { REAL vgradmag;
; 506  :     REAL h1,h,h2;
; 507  :     REAL lap;
; 508  :     REAL side1[MAXCOORD],side2[MAXCOORD];
; 509  :     REAL flux;
; 510  :     edge_id edge1,edge2;
; 511  :     vertex_id v1,v2;
; 512  :     facet_id f_id;
; 513  :     facetedge_id fe,start_fe;
; 514  :     REAL mobility;
; 515  :    
; 516  :     vgradmag = vertex_total_vol_grad(v_info->v[0],normal)/3;

	mov	ecx, DWORD PTR [esi+16]
	lea	eax, DWORD PTR _normal$[ebp]
	push	eax
	push	ecx
	call	_vertex_total_vol_grad
	fdiv	QWORD PTR __real@4008000000000000
	add	esp, 8
	fst	QWORD PTR _vgradmag$89363[ebp]

; 517  :     if ( vgradmag == 0.0 )

	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H

; 518  :         return 0.0; /* internal vertex, probably */

	jnp	$LN18@laplacian_@3

; 519  : 
; 520  :     /* compute Laplacian and multiply by normal */
; 521  :      
; 522  :     h = *(REAL*)get_extra(v_info->v[0],lmc_mc_attr);

	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR _lmc_mc_attr
	mov	ebx, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	edi, edx
	mov	edi, DWORD PTR [edi+ebx+64]
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]

; 523  : 
; 524  :     flux = 0.0;
; 525  :     fe = start_fe = get_vertex_first_facet(v_info->v[0]);

	push	ecx
	fld	QWORD PTR [edi+edx]
	fstp	QWORD PTR _h$89365[ebp]
	fstp	QWORD PTR _flux$89370[ebp]
	call	_get_vertex_first_facet
	add	esp, 4
	mov	DWORD PTR _start_fe$89377[ebp], eax
	mov	ebx, eax
	npad	8
$LL7@laplacian_@3:

; 526  :     do
; 527  :     { REAL s11,s12,s22,det;
; 528  : 
; 529  :       f_id = get_fe_facet(fe);

	mov	ecx, DWORD PTR _web+460
	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN33@laplacian_@3
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN32@laplacian_@3
$LN33@laplacian_@3:
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+24]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN32@laplacian_@3
	xor	eax, 134217728				; 08000000H
$LN32@laplacian_@3:

; 530  :       mobility = *(REAL*)get_f_extra(f_id,lmc_mobility_attr);

	mov	edx, DWORD PTR _lmc_mobility_attr
	mov	edi, DWORD PTR _web+236
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+edi+64]
	fld	QWORD PTR [eax+edx]
	fst	QWORD PTR _mobility$89378[ebp]

; 531  :       if ( mobility != 0.0 )

	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN56@laplacian_@3

; 532  :       {
; 533  :         edge1 = get_fe_edge(fe);

	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ecx]
	mov	esi, ebx
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [eax+20]

; 534  :         get_edge_side(edge1,side1);

	lea	ecx, DWORD PTR _side1$89368[ebp]
	push	ecx
	push	esi
	call	_get_edge_side

; 535  :         v1 = get_edge_headv(edge1);

	push	esi
	call	_get_edge_headv

; 536  :         h1 = *(REAL*)get_extra(v1,lmc_mc_attr);

	mov	edx, DWORD PTR _lmc_mc_attr
	mov	ecx, eax
	imul	edx, 240				; 000000f0H
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	esi, DWORD PTR _web[ecx+104]
	mov	ecx, DWORD PTR _web[ecx+12]
	add	esi, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [esi+edx+64]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]

; 537  :         edge2 = get_fe_edge(inverse_id(get_prev_edge(fe)));

	mov	ecx, DWORD PTR _web+460
	add	esp, 12					; 0000000cH
	fld	QWORD PTR [edx+eax]
	fstp	QWORD PTR _h1$89364[ebp]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN41@laplacian_@3
	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN40@laplacian_@3
$LN41@laplacian_@3:
	mov	eax, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [eax+28]
$LN40@laplacian_@3:
	xor	eax, 134217728				; 08000000H
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 538  :         get_edge_side(edge2,side2);

	lea	edx, DWORD PTR _side2$89369[ebp]
	mov	esi, eax
	push	edx
	push	esi
	call	_get_edge_side

; 539  :         v2 = get_edge_headv(edge2);

	push	esi
	call	_get_edge_headv

; 540  :         h2 = *(REAL*)get_extra(v2,lmc_mc_attr);

	mov	edx, DWORD PTR _lmc_mc_attr
	mov	ecx, eax
	imul	edx, 240				; 000000f0H
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	esi, DWORD PTR _web[ecx+104]
	mov	ecx, DWORD PTR _web[ecx+12]
	add	esi, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [esi+edx+64]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]

; 541  : 
; 542  : 
; 543  :         s11 = SDIM_dot(side1,side1);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	fld	QWORD PTR [edx+eax]
	lea	edx, DWORD PTR _side1$89368[ebp]
	push	edx
	fstp	QWORD PTR _h2$89366[ebp]
	mov	eax, edx
	push	eax
	call	_dot

; 544  :         s12 = SDIM_dot(side1,side2);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	fstp	QWORD PTR _s11$89384[ebp]
	lea	edx, DWORD PTR _side2$89369[ebp]
	push	edx
	lea	eax, DWORD PTR _side1$89368[ebp]
	push	eax
	call	_dot

; 545  :         s22 = SDIM_dot(side2,side2);

	mov	ecx, DWORD PTR _web+616
	fstp	QWORD PTR _s12$89385[ebp]
	push	ecx
	lea	edx, DWORD PTR _side2$89369[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot

; 546  :         det = sqrt(s11*s22 - s12*s12);
; 547  :         flux += mobility*((s11-2*s12+s22)*h + (s12-s22)*h1 + (s12-s11)*h2)/det;

	fld	QWORD PTR _s12$89385[ebp]
	fld	ST(0)
	add	esp, 48					; 00000030H
	fadd	ST(0), ST(1)
	fld	QWORD PTR _s11$89384[ebp]
	fld	ST(0)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fadd	ST(0), ST(3)
	fmul	QWORD PTR _h$89365[ebp]
	fld	ST(2)
	fsub	ST(0), ST(4)
	fmul	QWORD PTR _h1$89364[ebp]
	faddp	ST(1), ST(0)
	fld	ST(2)
	fsub	ST(0), ST(2)
	fmul	QWORD PTR _h2$89366[ebp]
	faddp	ST(1), ST(0)
	fmul	QWORD PTR _mobility$89378[ebp]
	fstp	QWORD PTR tv845[ebp]
	fmulp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)
	call	__CIsqrt
	fdivr	QWORD PTR tv845[ebp]
	mov	esi, DWORD PTR _v_info$GSCopy$[ebp]
	fadd	QWORD PTR _flux$89370[ebp]
	fstp	QWORD PTR _flux$89370[ebp]
$LN56@laplacian_@3:

; 548  :       }
; 549  :       fe = get_next_vertex_facet(v_info->v[0],fe);

	mov	ecx, DWORD PTR [esi+16]
	push	ebx
	push	ecx
	call	_get_next_vertex_facet
	mov	ebx, eax
	add	esp, 8

; 550  :     } while ( !equal_id(fe,start_fe) );

	cmp	ebx, DWORD PTR _start_fe$89377[ebp]
	jne	$LL7@laplacian_@3

; 551  :     lap = flux/vgradmag/2;

	fld	QWORD PTR _flux$89370[ebp]

; 552  : 
; 553  :     /* now multiply by unit normal */
; 554  :     for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	fdiv	QWORD PTR _vgradmag$89363[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN78@laplacian_@3
$LN3@laplacian_@3:

; 555  :       v_info->grad[0][i] = lap*normal[i];

	fld	QWORD PTR _normal$[ebp+eax*8]
	mov	edx, DWORD PTR [esi+1336]
	mov	ecx, DWORD PTR [edx]
	fmul	ST(0), ST(1)
	inc	eax
	fstp	QWORD PTR [ecx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@laplacian_@3
$LN78@laplacian_@3:

; 552  : 
; 553  :     /* now multiply by unit normal */
; 554  :     for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN54@laplacian_@3:

; 556  :     
; 557  :   } /* end soapfilm */
; 558  : 
; 559  :   return 0.0;

	fldz
$LN18@laplacian_@3:

; 560  : } /* end laplacian_mean_curvature_grad() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_laplacian_mean_curvature_grad ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_03EBJOKFHF@?5?$CFd?$AA@			; `string'
PUBLIC	??_C@_0N@MOJLAPAB@?5Lambda?5?$CFd?3?5?$AA@	; `string'
PUBLIC	_print_lambda_lists
EXTRN	_printf:PROC
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EBJOKFHF@?5?$CFd?$AA@
CONST	SEGMENT
??_C@_03EBJOKFHF@?5?$CFd?$AA@ DB ' %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOJLAPAB@?5Lambda?5?$CFd?3?5?$AA@
CONST	SEGMENT
??_C@_0N@MOJLAPAB@?5Lambda?5?$CFd?3?5?$AA@ DB ' Lambda %d: ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _print_lambda_lists
_TEXT	SEGMENT
_print_lambda_lists PROC				; COMDAT

; 619  : { int n;

	push	esi
	push	edi

; 620  :   struct lambda_s *p;
; 621  :   
; 622  :   for ( n = 0 ; n < LAMBDAMAX ; n++ )

	xor	edi, edi
$LL7@print_lamb:

; 623  :     if ( lambda_heads[n] )

	cmp	DWORD PTR _lambda_heads[edi*4], 0
	je	SHORT $LN6@print_lamb

; 624  :      { printf(" Lambda %d: ",n);

	push	edi
	push	OFFSET ??_C@_0N@MOJLAPAB@?5Lambda?5?$CFd?3?5?$AA@
	call	_printf

; 625  :        for ( p = lambda_heads[n] ; p ; p = p->next )

	mov	esi, DWORD PTR _lambda_heads[edi*4]
	add	esp, 8
	test	esi, esi
	je	SHORT $LN1@print_lamb
	npad	9
$LL3@print_lamb:

; 626  :          printf(" %d",(int)(p-lambda_list));

	mov	ecx, esi
	sub	ecx, DWORD PTR _lambda_list
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	OFFSET ??_C@_03EBJOKFHF@?5?$CFd?$AA@
	call	_printf
	mov	esi, DWORD PTR [esi+4]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL3@print_lamb
$LN1@print_lamb:

; 627  :        printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	add	esp, 4
$LN6@print_lamb:

; 620  :   struct lambda_s *p;
; 621  :   
; 622  :   for ( n = 0 ; n < LAMBDAMAX ; n++ )

	inc	edi
	cmp	edi, 100				; 00000064H
	jl	SHORT $LL7@print_lamb

; 628  :     }
; 629  : } // end print_lambda_lists()

	pop	edi
	pop	esi
	ret	0
_print_lambda_lists ENDP
_TEXT	ENDS
PUBLIC	_lambda_init
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT _lambda_init
_TEXT	SEGMENT
_lambda_init PROC					; COMDAT

; 633  :   lambdamax = -1;
; 634  :   memset(lambda_heads,0,sizeof(lambda_heads));  

	push	400					; 00000190H
	push	0
	push	OFFSET _lambda_heads
	mov	DWORD PTR _lambda_count, 0
	mov	DWORD PTR _lambdamax, -1
	call	_memset
	add	esp, 12					; 0000000cH

; 635  : }

	ret	0
_lambda_init ENDP
_TEXT	ENDS
PUBLIC	_lambda_insert
; Function compile flags: /Ogtp
;	COMDAT _lambda_insert
_TEXT	SEGMENT
_n$ = 8							; size = 4
_value$ = 12						; size = 4
_lambda_insert PROC					; COMDAT

; 641  : { if ( value >= LAMBDAMAX )

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _value$[ebp]
	cmp	ecx, 100				; 00000064H
	jl	SHORT $LN3@lambda_ins

; 642  :    value = LAMBDAMAX-1;

	mov	ecx, 99					; 00000063H
$LN3@lambda_ins:

; 643  :   lambda_list[n].value = value;

	mov	eax, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _lambda_list
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR [eax+edx+8], ecx

; 644  :   lambda_list[n].prev = NULL;

	mov	edx, DWORD PTR _lambda_list
	mov	DWORD PTR [eax+edx], 0

; 645  :   lambda_list[n].next = lambda_heads[value];

	mov	edx, DWORD PTR _lambda_heads[ecx*4]
	push	esi
	mov	esi, DWORD PTR _lambda_list
	mov	DWORD PTR [eax+esi+4], edx

; 646  :   if ( lambda_heads[value] )

	mov	edx, DWORD PTR _lambda_heads[ecx*4]
	test	edx, edx
	je	SHORT $LN2@lambda_ins

; 647  :      lambda_heads[value]->prev = lambda_list + n;

	mov	esi, DWORD PTR _lambda_list
	add	esi, eax
	mov	DWORD PTR [edx], esi
$LN2@lambda_ins:

; 648  :   lambda_heads[value] = lambda_list + n;

	add	eax, DWORD PTR _lambda_list

; 651  :   lambda_count++;

	inc	DWORD PTR _lambda_count
	mov	DWORD PTR _lambda_heads[ecx*4], eax
	pop	esi
	cmp	ecx, DWORD PTR _lambdamax
	jle	SHORT $LN1@lambda_ins

; 649  :   if ( value > lambdamax )
; 650  :      lambdamax = value;  

	mov	DWORD PTR _lambdamax, ecx
$LN1@lambda_ins:

; 652  :   
; 653  : }

	pop	ebp
	ret	0
_lambda_insert ENDP
_TEXT	ENDS
PUBLIC	_lambda_delete
; Function compile flags: /Ogtp
;	COMDAT _lambda_delete
_TEXT	SEGMENT
_spot$ = 8						; size = 4
_lambda_delete PROC					; COMDAT

; 656  : { int value = lambda_list[spot].value;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _spot$[ebp]
	mov	ecx, DWORD PTR _lambda_list
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax

; 657  :   if ( lambda_list[spot].prev )

	cmp	DWORD PTR [eax+ecx], 0
	push	esi
	mov	esi, DWORD PTR [eax+ecx+8]
	je	SHORT $LN7@lambda_del

; 658  :     lambda_list[spot].prev->next = lambda_list[spot].next;

	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR [edx+4], ecx

; 659  :   else

	mov	ecx, DWORD PTR _lambda_list
	jmp	SHORT $LN2@lambda_del
$LN7@lambda_del:

; 660  :   { lambda_heads[value] = lambda_list[spot].next;

	mov	edx, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR _lambda_heads[esi*4], edx

; 661  :     if ( (lambda_heads[value] == NULL) && (value == lambdamax) )

	test	edx, edx
	jne	SHORT $LN2@lambda_del
	mov	edx, DWORD PTR _lambdamax
	cmp	esi, edx
	jne	SHORT $LN2@lambda_del

; 662  :     { /* reset lambdamax */
; 663  :       for ( ; (lambdamax >= 0) && (lambda_heads[lambdamax] == NULL) ; lambdamax-- ) ;

	test	edx, edx
	js	SHORT $LN2@lambda_del
	npad	3
$LL4@lambda_del:
	cmp	DWORD PTR _lambda_heads[edx*4], 0
	jne	SHORT $LN13@lambda_del
	dec	edx
	jns	SHORT $LL4@lambda_del
$LN13@lambda_del:
	mov	DWORD PTR _lambdamax, edx
$LN2@lambda_del:

; 664  :     }
; 665  :   }
; 666  :   if ( lambda_list[spot].next )

	mov	edx, DWORD PTR [eax+ecx+4]
	pop	esi
	test	edx, edx
	je	SHORT $LN12@lambda_del

; 667  :     lambda_list[spot].next->prev = lambda_list[spot].prev;

	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx], eax
$LN12@lambda_del:

; 668  :   lambda_count--;

	dec	DWORD PTR _lambda_count

; 669  :   
; 670  : }

	pop	ebp
	ret	0
_lambda_delete ENDP
_TEXT	ENDS
PUBLIC	_increment_lambda
; Function compile flags: /Ogtp
;	COMDAT _increment_lambda
_TEXT	SEGMENT
_spot$ = 8						; size = 4
_increment_lambda PROC					; COMDAT

; 673  : { lambda_delete(spot);

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _spot$[ebp]
	push	esi
	call	_lambda_delete

; 674  :   lambda_list[spot].value++;

	mov	ecx, DWORD PTR _lambda_list
	lea	eax, DWORD PTR [esi+esi*2]
	add	eax, eax
	add	eax, eax
	inc	DWORD PTR [eax+ecx+8]

; 675  :   lambda_insert(spot,lambda_list[spot].value);

	mov	ecx, DWORD PTR _lambda_list
	mov	edx, DWORD PTR [eax+ecx+8]
	push	edx
	push	esi
	call	_lambda_insert
	add	esp, 12					; 0000000cH
	pop	esi

; 676  :    
; 677  : }

	pop	ebp
	ret	0
_increment_lambda ENDP
_TEXT	ENDS
PUBLIC	_decrement_lambda
; Function compile flags: /Ogtp
;	COMDAT _decrement_lambda
_TEXT	SEGMENT
_spot$ = 8						; size = 4
_decrement_lambda PROC					; COMDAT

; 680  : { lambda_delete(spot);

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _spot$[ebp]
	push	esi
	call	_lambda_delete

; 681  :   lambda_list[spot].value++;

	mov	ecx, DWORD PTR _lambda_list
	lea	eax, DWORD PTR [esi+esi*2]
	add	eax, eax
	add	eax, eax
	inc	DWORD PTR [eax+ecx+8]

; 682  :   lambda_insert(spot,lambda_list[spot].value);

	mov	ecx, DWORD PTR _lambda_list
	mov	edx, DWORD PTR [eax+ecx+8]
	push	edx
	push	esi
	call	_lambda_insert
	add	esp, 12					; 0000000cH
	pop	esi

; 683  :  
; 684  : }

	pop	ebp
	ret	0
_decrement_lambda ENDP
_TEXT	ENDS
PUBLIC	_get_highest_lambda
; Function compile flags: /Ogtp
;	COMDAT _get_highest_lambda
_TEXT	SEGMENT
_get_highest_lambda PROC				; COMDAT

; 688  : 
; 689  :   int ret = (int)(lambda_heads[lambdamax] - lambda_list);

	mov	eax, DWORD PTR _lambdamax
	mov	ecx, DWORD PTR _lambda_heads[eax*4]
	sub	ecx, DWORD PTR _lambda_list
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	push	esi
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 690  : 
; 691  :   lambda_delete(ret);

	push	esi
	call	_lambda_delete
	add	esp, 4

; 692  :   return ret;

	mov	eax, esi
	pop	esi

; 693  : }

	ret	0
_get_highest_lambda ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@FDFMJACF@?5?5?5Fine?5mark?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@LPIBLONB@Coarse?5mark?5?$CFd?6?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_choose_coarse_points
EXTRN	_temp_free:PROC
EXTRN	_kb_temp_calloc:PROC
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_0BB@FDFMJACF@?5?5?5Fine?5mark?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BB@FDFMJACF@?5?5?5Fine?5mark?5?$CFd?6?$AA@ DB '   Fine mark %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LPIBLONB@Coarse?5mark?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BA@LPIBLONB@Coarse?5mark?5?$CFd?6?$AA@ DB 'Coarse mark %d', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _choose_coarse_points
_TEXT	SEGMENT
_wnbr_starts$ = -8072					; size = 4
_wnbr_lists$ = -8068					; size = 4
_nbr_count$ = -8064					; size = 4
_stnbr_lists$ = -8060					; size = 4
_c_nbr_count$89606 = -8056				; size = 4
tv1766 = -8052						; size = 4
tv1551 = -8052						; size = 4
_ctwiddle$89603 = -8052					; size = 4
_n$ = -8048						; size = 4
_stnbr_starts$ = -8044					; size = 4
tv1555 = -8040						; size = 4
tv999 = -8040						; size = 4
_nn$89621 = -8040					; size = 4
tv1771 = -8036						; size = 4
tv1543 = -8036						; size = 4
_meet_flag$89620 = -8036				; size = 4
tv1776 = -8032						; size = 4
_ctwiddle_count$89602 = -8032				; size = 4
_amaxes$ = -8028					; size = 4
_stnbr_counts$ = -8024					; size = 4
tv1424 = -8020						; size = 4
_wnbr_counts$ = -8020					; size = 4
_sfcount$89601 = -8016					; size = 4
_i$ = -8016						; size = 4
_fine$ = -8012						; size = 4
_j$ = -8008						; size = 4
_c_nbrs$89604 = -8004					; size = 4000
_strong_fnbrs$89605 = -4004				; size = 4000
__$ArrayPad$ = -4					; size = 4
_mg$ = 8						; size = 4
_choose_coarse_points PROC				; COMDAT

; 752  : { REAL *amaxes; /* maximum matrix values on row */ 

	push	ebp
	mov	ebp, esp
	mov	eax, 8072				; 00001f88H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _mg$[ebp]
	push	edi

; 753  :   int *nbr_count;  /* number of neighbors of each fine variable */
; 754  :   int n,i,j;
; 755  :   struct linsys *fine = mg->fine;

	mov	edi, DWORD PTR [esi]

; 756  :   int cspot;
; 757  :   int *stnbr_starts,*stnbr_counts,*stnbr_lists;
; 758  :   int *wnbr_starts,*wnbr_counts,*wnbr_lists;
; 759  : 
; 760  :   /* Coarse point choice, stage 1 (algorithm A1 on p. 102) */
; 761  : 
; 762  :   mg->marks = (int*)temp_calloc(fine->N,sizeof(int));

	mov	eax, DWORD PTR [edi+4]
	push	762					; 000002faH
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	4
	push	eax
	mov	DWORD PTR _fine$[ebp], edi
	call	_kb_temp_calloc

; 763  : 
; 764  :   /* Get maximum magnitudes in rows, so can find "strong" neighbors */
; 765  :   /* And count neighbors, while we're at it */
; 766  :   amaxes = (REAL*)temp_calloc(fine->N,sizeof(REAL));

	push	766					; 000002feH
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	mov	DWORD PTR [esi+8], eax
	mov	ecx, DWORD PTR [edi+4]
	push	8
	push	ecx
	call	_kb_temp_calloc

; 767  :   nbr_count = (int*)temp_calloc(fine->N,sizeof(int));

	mov	edx, DWORD PTR [edi+4]
	push	767					; 000002ffH
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	4
	push	edx
	mov	DWORD PTR _amaxes$[ebp], eax
	call	_kb_temp_calloc

; 768  :   for ( n = 0 ; n < fine->N ; n++ )

	xor	ebx, ebx
	add	esp, 48					; 00000030H
	mov	DWORD PTR _nbr_count$[ebp], eax
	cmp	DWORD PTR [edi+4], ebx
	jle	$LN65@choose_coa
	mov	ecx, DWORD PTR _amaxes$[ebp]
	mov	DWORD PTR tv1424[ebp], ecx
	npad	3
$LL67@choose_coa:
	mov	eax, DWORD PTR [edi+52]

; 769  :     for ( j = fine->IA[n]-A_OFF+1 ; j < fine->IA[n+1]-A_OFF ; j++ )

	mov	edx, DWORD PTR [eax+ebx*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+4]
	dec	eax
	cmp	edx, eax
	jge	SHORT $LN66@choose_coa
$LL64@choose_coa:

; 770  :     { double mag = fabs(fine->A[j]);

	mov	eax, DWORD PTR [edi+60]
	fld	QWORD PTR [eax+edx*8]
	fabs

; 771  :       int jvar;
; 772  :       if ( mag > amaxes[n] )

	fcom	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN61@choose_coa

; 773  :         amaxes[n] = mag;

	fst	QWORD PTR [ecx]
$LN61@choose_coa:

; 774  :       jvar = fine->JA[j] - A_OFF; 

	mov	ecx, DWORD PTR [edi+56]

; 775  :       if ( mag > amaxes[jvar] )

	mov	eax, DWORD PTR _amaxes$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	fcom	QWORD PTR [eax+ecx*8-8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN152@choose_coa

; 776  :         amaxes[jvar] = mag;

	mov	eax, DWORD PTR _amaxes$[ebp]
	fstp	QWORD PTR [eax+ecx*8-8]
	jmp	SHORT $LN60@choose_coa
$LN152@choose_coa:
	fstp	ST(0)
$LN60@choose_coa:

; 777  :       nbr_count[n]++;

	mov	eax, DWORD PTR _nbr_count$[ebp]
	inc	DWORD PTR [eax+ebx*4]

; 778  :       nbr_count[jvar]++;

	inc	DWORD PTR [eax+ecx*4-4]
	mov	ecx, DWORD PTR [edi+52]
	mov	eax, DWORD PTR [ecx+ebx*4+4]
	mov	ecx, DWORD PTR tv1424[ebp]
	inc	edx
	dec	eax
	cmp	edx, eax
	jl	SHORT $LL64@choose_coa
$LN66@choose_coa:

; 768  :   for ( n = 0 ; n < fine->N ; n++ )

	inc	ebx
	add	ecx, 8
	mov	DWORD PTR tv1424[ebp], ecx
	cmp	ebx, DWORD PTR [edi+4]
	jl	SHORT $LL67@choose_coa
$LN65@choose_coa:

; 779  :     }
; 780  : 
; 781  :   /* "Strong" cutoff is taken to be 0.25 of max */
; 782  :   for ( n = 0 ; n < fine->N ; n++ )

	xor	eax, eax
	cmp	DWORD PTR [edi+4], eax
	jle	SHORT $LN57@choose_coa
	fld	QWORD PTR _omega
	mov	ecx, DWORD PTR _amaxes$[ebp]
$LN59@choose_coa:

; 783  :     amaxes[n] *= omega;

	fld	QWORD PTR [ecx+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [ecx+eax*8-8]
	cmp	eax, DWORD PTR [edi+4]
	jl	SHORT $LN59@choose_coa

; 779  :     }
; 780  : 
; 781  :   /* "Strong" cutoff is taken to be 0.25 of max */
; 782  :   for ( n = 0 ; n < fine->N ; n++ )

	fstp	ST(0)
$LN57@choose_coa:

; 784  : 
; 785  :   /* Record strong neighbors, and reciprocal strong neighbors */
; 786  :   /* and weakly connected neighbors, for later */
; 787  :   mg->snbr_starts = (int*)temp_calloc(fine->N+1,sizeof(int));

	mov	ecx, DWORD PTR [edi+4]
	push	787					; 00000313H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	inc	ecx
	push	4
	push	ecx
	call	_kb_temp_calloc

; 788  :   mg->snbr_counts = (int*)temp_calloc(fine->N,sizeof(int));

	push	788					; 00000314H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	mov	DWORD PTR [esi+48], eax
	mov	edx, DWORD PTR [edi+4]
	push	4
	push	edx
	call	_kb_temp_calloc
	mov	DWORD PTR [esi+52], eax

; 789  :   mg->snbr_lists = (int*)temp_calloc(2*fine->IA[fine->N],sizeof(int));

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+52]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	789					; 00000315H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	add	edx, edx
	push	4
	push	edx
	call	_kb_temp_calloc

; 790  : 
; 791  :   stnbr_starts = (int*)temp_calloc(fine->N+1,sizeof(int));

	push	791					; 00000317H
	mov	DWORD PTR [esi+56], eax
	mov	eax, DWORD PTR [edi+4]
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	inc	eax
	push	4
	push	eax
	call	_kb_temp_calloc

; 792  :   stnbr_counts = (int*)temp_calloc(fine->N,sizeof(int));

	mov	ecx, DWORD PTR [edi+4]
	add	esp, 64					; 00000040H
	push	792					; 00000318H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	4
	push	ecx
	mov	DWORD PTR _stnbr_starts$[ebp], eax
	call	_kb_temp_calloc

; 793  :   stnbr_lists = (int*)temp_calloc(2*fine->IA[fine->N],sizeof(int));

	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR _stnbr_counts$[ebp], eax
	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	793					; 00000319H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	add	ecx, ecx
	push	4
	push	ecx
	call	_kb_temp_calloc

; 794  : 
; 795  :   wnbr_starts = (int*)temp_calloc(fine->N+1,sizeof(int));

	mov	edx, DWORD PTR [edi+4]
	push	795					; 0000031bH
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	inc	edx
	push	4
	push	edx
	mov	DWORD PTR _stnbr_lists$[ebp], eax
	call	_kb_temp_calloc

; 796  :   wnbr_counts = (int*)temp_calloc(fine->N,sizeof(int));

	push	796					; 0000031cH
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+4]
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	4
	push	eax
	mov	DWORD PTR _wnbr_starts$[ebp], ebx
	call	_kb_temp_calloc

; 797  :   wnbr_lists = (int*)temp_calloc(2*fine->IA[fine->N],sizeof(int));

	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi+52]
	add	esp, 64					; 00000040H
	push	797					; 0000031dH
	mov	DWORD PTR _wnbr_counts$[ebp], eax
	mov	eax, DWORD PTR [edx+ecx*4]
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	add	eax, eax
	push	4
	push	eax
	call	_kb_temp_calloc

; 798  :   mg->wnbr_asums = (REAL*)temp_calloc(fine->N,sizeof(REAL));

	push	798					; 0000031eH
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	mov	DWORD PTR _wnbr_lists$[ebp], eax
	push	8
	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	call	_kb_temp_calloc
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+60], eax

; 799  : 
; 800  :   for ( n = 0 ; n < fine->N ; n++ )

	cmp	DWORD PTR [edi+4], 0
	mov	DWORD PTR _n$[ebp], 0
	jle	$LN54@choose_coa
	mov	edx, DWORD PTR _stnbr_starts$[ebp]
	mov	eax, DWORD PTR _nbr_count$[ebp]
	sub	edx, ebx
	mov	DWORD PTR tv1543[ebp], edx
	mov	edx, -4					; fffffffcH
	sub	edx, ebx
	mov	DWORD PTR tv1551[ebp], edx
	mov	edx, DWORD PTR _stnbr_starts$[ebp]
	sub	edx, eax
	lea	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR tv1555[ebp], edx
	npad	6
$LL132@choose_coa:

; 801  :   { mg->snbr_starts[n+1] = mg->snbr_starts[n] + nbr_count[n];

	mov	edx, DWORD PTR [esi+48]
	add	edx, DWORD PTR tv1551[ebp]
	add	eax, 4
	mov	ebx, DWORD PTR [edx+ecx]
	add	ebx, DWORD PTR [eax-4]
	add	ecx, 4
	mov	DWORD PTR [edx+ecx], ebx

; 802  :     stnbr_starts[n+1] = stnbr_starts[n] + nbr_count[n];

	mov	edx, DWORD PTR tv1555[ebp]
	mov	edx, DWORD PTR [edx+eax-4]
	add	edx, DWORD PTR [eax-4]
	mov	ebx, DWORD PTR tv1543[ebp]
	mov	DWORD PTR [ebx+ecx-4], edx

; 803  :     wnbr_starts[n+1] = wnbr_starts[n] + nbr_count[n];

	mov	edx, DWORD PTR [ecx-8]
	add	edx, DWORD PTR [eax-4]
	mov	DWORD PTR [ecx-4], edx
	mov	edx, DWORD PTR _n$[ebp]
	inc	edx
	mov	DWORD PTR _n$[ebp], edx
	cmp	edx, DWORD PTR [edi+4]
	jl	SHORT $LL132@choose_coa
$LN54@choose_coa:

; 804  :   }
; 805  :   for ( n = 0 ; n < fine->N ; n++ )

	xor	edx, edx
	cmp	DWORD PTR [edi+4], edx
	jle	$LN51@choose_coa
	mov	edi, DWORD PTR _wnbr_counts$[ebp]
	mov	eax, DWORD PTR _wnbr_starts$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv1766[ebp], eax
	mov	eax, DWORD PTR _stnbr_starts$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv1771[ebp], eax
	mov	eax, DWORD PTR _stnbr_counts$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv1776[ebp], eax
	npad	11
$LL53@choose_coa:
	mov	eax, DWORD PTR _fine$[ebp]
	mov	ecx, DWORD PTR [eax+52]

; 806  :    for ( j = fine->IA[n]-A_OFF+1 ; j < fine->IA[n+1]-A_OFF ; j++ )

	mov	eax, DWORD PTR [ecx+edx*4]
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [ecx+4]
	dec	ecx
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, ecx
	jge	$LN52@choose_coa
$LL50@choose_coa:

; 807  :    { double mag = fabs(fine->A[j]);

	mov	ecx, DWORD PTR _fine$[ebp]
	mov	ebx, DWORD PTR [ecx+60]
	fld	QWORD PTR [ebx+eax*8]

; 808  :      int jvar = fine->JA[j] - A_OFF; 

	mov	ecx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [ecx+eax*4]
	fabs

; 809  :      if ( mag > amaxes[n] )

	mov	eax, DWORD PTR _amaxes$[ebp]
	fcom	QWORD PTR [eax+edx*8]
	dec	ecx
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN47@choose_coa

; 810  :      { /* strong nbr */
; 811  :        mg->snbr_lists[mg->snbr_starts[n] + mg->snbr_counts[n]++] = jvar;

	mov	eax, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	ebx, DWORD PTR [esi+48]
	add	eax, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR [esi+56]
	mov	DWORD PTR [ebx+eax*4], ecx
	mov	eax, DWORD PTR [esi+52]
	inc	DWORD PTR [eax+edx*4]

; 812  :        stnbr_lists[stnbr_starts[jvar] + stnbr_counts[jvar]++] = n;

	mov	ebx, DWORD PTR _stnbr_counts$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _stnbr_starts$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	add	eax, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _stnbr_lists$[ebp]
	mov	DWORD PTR [ebx+eax*4], edx
	mov	eax, DWORD PTR _stnbr_counts$[ebp]
	inc	DWORD PTR [eax+ecx*4]

; 813  :      }
; 814  :      else /* weak neighbor */

	jmp	SHORT $LN46@choose_coa
$LN47@choose_coa:

; 815  :      { wnbr_lists[wnbr_starts[n] + wnbr_counts[n]++] = jvar;

	mov	eax, DWORD PTR tv1766[ebp]
	mov	eax, DWORD PTR [eax+edi]
	add	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR _wnbr_lists$[ebp]
	mov	DWORD PTR [ebx+eax*4], ecx
	inc	DWORD PTR [edi]
	mov	eax, DWORD PTR [esi+60]

; 816  :        mg->wnbr_asums[n] += fine->A[j];

	mov	ebx, DWORD PTR _j$[ebp]
	lea	eax, DWORD PTR [eax+edx*8]
	mov	DWORD PTR tv999[ebp], eax
	mov	eax, DWORD PTR _fine$[ebp]
	mov	eax, DWORD PTR [eax+60]
	fld	QWORD PTR [eax+ebx*8]
	mov	eax, DWORD PTR tv999[ebp]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
$LN46@choose_coa:

; 817  :      }
; 818  : 
; 819  :      if ( mag > amaxes[jvar] )

	mov	eax, DWORD PTR _amaxes$[ebp]
	fcomp	QWORD PTR [eax+ecx*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN45@choose_coa

; 820  :      { /* strong nbr */
; 821  :        mg->snbr_lists[mg->snbr_starts[jvar] + mg->snbr_counts[jvar]++] = n;

	mov	eax, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ebx, DWORD PTR [esi+48]
	add	eax, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR [esi+56]
	mov	DWORD PTR [ebx+eax*4], edx
	mov	eax, DWORD PTR [esi+52]
	inc	DWORD PTR [eax+ecx*4]

; 822  :        stnbr_lists[stnbr_starts[n] + stnbr_counts[n]++] = jvar;

	mov	ebx, DWORD PTR tv1776[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR tv1771[ebp]
	mov	eax, DWORD PTR [eax+edi]
	add	eax, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR _stnbr_lists$[ebp]
	mov	DWORD PTR [ebx+eax*4], ecx
	mov	eax, DWORD PTR tv1776[ebp]
	inc	DWORD PTR [eax+edi]

; 823  :      }
; 824  :      else /* weak neighbor */

	mov	eax, DWORD PTR _j$[ebp]
	jmp	SHORT $LN49@choose_coa
$LN45@choose_coa:

; 825  :      { wnbr_lists[wnbr_starts[jvar] + wnbr_counts[jvar]++] = n;

	mov	eax, DWORD PTR _wnbr_starts$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ebx, DWORD PTR _wnbr_counts$[ebp]
	add	eax, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _wnbr_lists$[ebp]
	mov	DWORD PTR [ebx+eax*4], edx
	mov	eax, DWORD PTR _wnbr_counts$[ebp]
	inc	DWORD PTR [eax+ecx*4]

; 826  :        mg->wnbr_asums[jvar] += fine->A[j];

	mov	eax, DWORD PTR [esi+60]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _fine$[ebp]
	mov	ebx, DWORD PTR [eax+60]
	mov	eax, DWORD PTR _j$[ebp]
	fld	QWORD PTR [ebx+eax*8]
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
$LN49@choose_coa:

; 806  :    for ( j = fine->IA[n]-A_OFF+1 ; j < fine->IA[n+1]-A_OFF ; j++ )

	mov	ecx, DWORD PTR _fine$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	mov	ecx, DWORD PTR [ecx+edx*4+4]
	inc	eax
	dec	ecx
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, ecx
	jl	$LL50@choose_coa
$LN52@choose_coa:

; 804  :   }
; 805  :   for ( n = 0 ; n < fine->N ; n++ )

	mov	eax, DWORD PTR _fine$[ebp]
	inc	edx
	add	edi, 4
	cmp	edx, DWORD PTR [eax+4]
	jl	$LL53@choose_coa
$LN51@choose_coa:

; 827  :      }
; 828  :    }
; 829  : 
; 830  :   /* set up lambdas in heap so can track max lambda */
; 831  :   lambda_list = (struct lambda_s *)temp_calloc(fine->N,sizeof(struct lambda_s));

	mov	ebx, DWORD PTR _fine$[ebp]
	mov	ecx, DWORD PTR [ebx+4]
	push	831					; 0000033fH
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	12					; 0000000cH
	push	ecx
	call	_kb_temp_calloc

; 832  :   for ( n = 0 ; n < fine->N ; n++ )

	xor	edi, edi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lambda_list, eax
	cmp	DWORD PTR [ebx+4], edi
	jle	SHORT $LN130@choose_coa
$LL43@choose_coa:

; 833  :     lambda_insert(n,stnbr_counts[n]);

	mov	edx, DWORD PTR _stnbr_counts$[ebp]
	mov	eax, DWORD PTR [edx+edi*4]
	push	eax
	push	edi
	call	_lambda_insert
	inc	edi
	add	esp, 8
	cmp	edi, DWORD PTR [ebx+4]
	jl	SHORT $LL43@choose_coa
$LN130@choose_coa:

; 834  :   
; 835  :    
; 836  :   /* iterate marking coarse points */
; 837  :   while ( lambda_count > 0 )

	cmp	DWORD PTR _lambda_count, 0
	jle	$LN39@choose_coa
	npad	4
$LL40@choose_coa:

; 838  :   { int k;
; 839  :      /* remove from unmarked list and mark as coarse */ 
; 840  :      i = get_highest_lambda();

	call	_get_highest_lambda

; 841  : 
; 842  :      mg->marks[i] = coarse_mark;

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _coarse_mark
	mov	edi, eax

; 843  :      mg->coarse_count++;
; 844  :      
; 845  : printf("Coarse mark %d\n",i);

	push	edi
	mov	DWORD PTR [ecx+edi*4], edx
	inc	DWORD PTR [esi+12]
	push	OFFSET ??_C@_0BA@LPIBLONB@Coarse?5mark?5?$CFd?6?$AA@
	mov	DWORD PTR _i$[ebp], edi
	call	_printf

; 846  : 
; 847  :      /* mark fine neighbors */
; 848  :      for ( j = 0 ; j < stnbr_counts[i] ; j++ )

	mov	eax, DWORD PTR _stnbr_counts$[ebp]
	add	esp, 8
	cmp	DWORD PTR [eax+edi*4], 0
	mov	DWORD PTR _j$[ebp], 0
	jle	$LN129@choose_coa
	npad	12
$LL38@choose_coa:

; 849  :      { int nbr = stnbr_lists[stnbr_starts[i] + j];

	mov	ecx, DWORD PTR _stnbr_starts$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _stnbr_lists$[ebp]
	mov	edi, DWORD PTR [ecx+eax*4]

; 850  :        if ( mg->marks[nbr] != unmark )

	mov	edx, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _unmark
	cmp	DWORD PTR [edx+edi*4], ecx
	lea	eax, DWORD PTR [edx+edi*4]
	jne	SHORT $LN37@choose_coa

; 851  :            continue;
; 852  :        mg->marks[nbr] = fine_mark;

	mov	edx, DWORD PTR _fine_mark

; 853  : printf("   Fine mark %d\n",nbr);

	push	edi
	push	OFFSET ??_C@_0BB@FDFMJACF@?5?5?5Fine?5mark?5?$CFd?6?$AA@
	mov	DWORD PTR [eax], edx
	call	_printf

; 854  :        lambda_delete(nbr);

	push	edi
	call	_lambda_delete

; 855  :        for ( k = 0 ; k < mg->snbr_counts[nbr] ; k++ )

	mov	eax, DWORD PTR [esi+52]
	xor	ebx, ebx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [eax+edi*4], ebx
	jle	SHORT $LN37@choose_coa
$LL34@choose_coa:

; 856  :        { int nbrnbr = mg->snbr_lists[mg->snbr_starts[nbr] + k];

	mov	ecx, DWORD PTR [esi+48]
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	eax, DWORD PTR [esi+56]

; 857  :          if ( mg->marks[nbrnbr] != unmark )

	mov	ecx, DWORD PTR [esi+8]
	add	edx, ebx
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+eax*4]
	cmp	edx, DWORD PTR _unmark
	jne	SHORT $LN33@choose_coa

; 858  :            continue;
; 859  :          increment_lambda(nbrnbr);

	push	eax
	call	_increment_lambda
	add	esp, 4
$LN33@choose_coa:

; 855  :        for ( k = 0 ; k < mg->snbr_counts[nbr] ; k++ )

	mov	eax, DWORD PTR [esi+52]
	inc	ebx
	cmp	ebx, DWORD PTR [eax+edi*4]
	jl	SHORT $LL34@choose_coa
$LN37@choose_coa:

; 846  : 
; 847  :      /* mark fine neighbors */
; 848  :      for ( j = 0 ; j < stnbr_counts[i] ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _stnbr_counts$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [ecx+edx*4]
	jl	$LL38@choose_coa
	mov	edi, edx
$LN129@choose_coa:

; 860  :        }
; 861  :      } 
; 862  :      for ( j = 0 ; j < mg->snbr_counts[i] ; j++ )

	mov	eax, DWORD PTR [esi+52]
	xor	ebx, ebx
	cmp	DWORD PTR [eax+edi*4], ebx
	jle	SHORT $LN28@choose_coa
$LL30@choose_coa:

; 863  :      { int nbr = mg->snbr_lists[mg->snbr_starts[i] + j];

	mov	ecx, DWORD PTR [esi+48]
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	eax, DWORD PTR [esi+56]

; 864  :        if ( mg->marks[nbr] != unmark )

	mov	ecx, DWORD PTR [esi+8]
	add	edx, ebx
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+eax*4]
	cmp	edx, DWORD PTR _unmark
	jne	SHORT $LN29@choose_coa

; 865  :           continue;
; 866  :        decrement_lambda(nbr);

	push	eax
	call	_decrement_lambda
	add	esp, 4
$LN29@choose_coa:

; 860  :        }
; 861  :      } 
; 862  :      for ( j = 0 ; j < mg->snbr_counts[i] ; j++ )

	mov	eax, DWORD PTR [esi+52]
	inc	ebx
	cmp	ebx, DWORD PTR [eax+edi*4]
	jl	SHORT $LL30@choose_coa
$LN28@choose_coa:

; 834  :   
; 835  :    
; 836  :   /* iterate marking coarse points */
; 837  :   while ( lambda_count > 0 )

	cmp	DWORD PTR _lambda_count, 0
	jg	$LL40@choose_coa
$LN39@choose_coa:

; 867  :      }
; 868  :   }
; 869  : 
; 870  :   /* Finalize choice of coarse points */
; 871  :   /* (algorithm A3, p. 102; weight calculation separate) */
; 872  :   for ( n = 0 ; n < fine->N ; n++ )

	mov	edx, DWORD PTR _fine$[ebp]
	xor	ecx, ecx
	xor	edi, edi
	mov	DWORD PTR _n$[ebp], edi
	cmp	DWORD PTR [edx+4], ecx
	jle	$LN131@choose_coa
	npad	11
$LL26@choose_coa:

; 873  :   { int sfcount; /* number of strong fine neigbors, not coarse */
; 874  :     int ctwiddle_count;
; 875  :     int ctwiddle=0; /* candidate coarse variable */
; 876  :     int c_nbrs[1000];
; 877  :     int strong_fnbrs[1000];
; 878  :     int c_nbr_count;
; 879  :     int k;
; 880  : 
; 881  : 
; 882  :     if ( mg->marks[n] != fine_mark ) 

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [edx+edi*4]
	mov	DWORD PTR _ctwiddle$89603[ebp], ecx
	cmp	eax, DWORD PTR _fine_mark
	jne	$LN25@choose_coa

; 887  :     sfcount = 0;
; 888  :     c_nbr_count = 0;
; 889  :     for ( k = 0 ; k < mg->snbr_counts[n] ; k++ )

	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR _ctwiddle_count$89602[ebp], ecx
	mov	DWORD PTR _sfcount$89601[ebp], ecx
	mov	DWORD PTR _c_nbr_count$89606[ebp], ecx
	cmp	DWORD PTR [eax+edi*4], ecx
	jle	SHORT $step4$89615

; 883  :       continue;
; 884  : 
; 885  :     /* A3.3: set C_i = S_i intersect C, Ds_i = S_i - C_i */
; 886  :     ctwiddle_count = 0;

	mov	ecx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [esi+56]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [esi+52]
	mov	edi, DWORD PTR [eax+edi*4]
$LL137@choose_coa:

; 890  :     { int snbr = mg->snbr_lists[mg->snbr_starts[n] + k];

	mov	eax, DWORD PTR [ecx]

; 891  :       if ( mg->marks[snbr] == coarse_mark )

	mov	ebx, DWORD PTR _coarse_mark
	cmp	DWORD PTR [edx+eax*4], ebx
	jne	SHORT $LN19@choose_coa

; 892  :       { c_nbrs[c_nbr_count++] = snbr;

	mov	ebx, DWORD PTR _c_nbr_count$89606[ebp]
	mov	DWORD PTR _c_nbrs$89604[ebp+ebx*4], eax
	inc	ebx
	mov	DWORD PTR _c_nbr_count$89606[ebp], ebx

; 893  :       }
; 894  :       else

	jmp	SHORT $LN21@choose_coa
$LN19@choose_coa:

; 895  :       { strong_fnbrs[sfcount++] = snbr;  /* Ds_i */

	mov	ebx, DWORD PTR _sfcount$89601[ebp]
	mov	DWORD PTR _strong_fnbrs$89605[ebp+ebx*4], eax
	inc	ebx
	mov	DWORD PTR _sfcount$89601[ebp], ebx
$LN21@choose_coa:

; 887  :     sfcount = 0;
; 888  :     c_nbr_count = 0;
; 889  :     for ( k = 0 ; k < mg->snbr_counts[n] ; k++ )

	add	ecx, 4
	dec	edi
	jne	SHORT $LL137@choose_coa
$step4$89615:

; 896  :       }
; 897  :     }
; 898  : 
; 899  : step4:
; 900  :     /* A3.5  */
; 901  :     for ( j = 0 ; j < sfcount ; j++ )

	xor	eax, eax
$LN160@choose_coa:
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _sfcount$89601[ebp]
	jge	$LN139@choose_coa

; 902  :     { /* A3.6 test S_j intersect C_i */
; 903  :       int jnbr = strong_fnbrs[j];

	mov	edx, DWORD PTR _strong_fnbrs$89605[ebp+eax*4]

; 904  :       int meet_flag = 0;

	xor	ecx, ecx

; 905  :       int nn,jj;
; 906  :       
; 907  :       for ( nn = 0 ; (meet_flag == 0) && (nn < c_nbr_count) ; nn++ )

	xor	ebx, ebx
	mov	DWORD PTR _meet_flag$89620[ebp], ecx
	mov	DWORD PTR _nn$89621[ebp], ebx
	npad	4
$LL145@choose_coa:
	cmp	ebx, DWORD PTR _c_nbr_count$89606[ebp]
	jge	SHORT $LN12@choose_coa

; 908  :         for ( jj = 0 ; jj < mg->snbr_counts[jnbr] ; jj++ )

	mov	edi, DWORD PTR [esi+52]
	xor	eax, eax
	cmp	DWORD PTR [edi+edx*4], eax
	jle	SHORT $LN13@choose_coa
	mov	ecx, DWORD PTR [esi+48]
	mov	edi, DWORD PTR _c_nbrs$89604[ebp+ebx*4]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	ebx, DWORD PTR [esi+56]
	lea	ecx, DWORD PTR [ebx+ecx*4]
$LL146@choose_coa:

; 909  :           if ( c_nbrs[nn] == mg->snbr_lists[mg->snbr_starts[jnbr]+jj] )

	cmp	edi, DWORD PTR [ecx]
	je	SHORT $LN89@choose_coa

; 908  :         for ( jj = 0 ; jj < mg->snbr_counts[jnbr] ; jj++ )

	mov	ebx, DWORD PTR [esi+52]
	inc	eax
	add	ecx, 4
	cmp	eax, DWORD PTR [ebx+edx*4]
	jl	SHORT $LL146@choose_coa

; 915  :       { /* step 7 */
; 916  :         if ( ctwiddle_count )  /* punt, and make it coarse */

	mov	ecx, DWORD PTR _meet_flag$89620[ebp]
	jmp	SHORT $LN13@choose_coa
$LN89@choose_coa:

; 910  :           { meet_flag = 1; 

	mov	ecx, 1
	mov	DWORD PTR _meet_flag$89620[ebp], ecx
$LN13@choose_coa:

; 905  :       int nn,jj;
; 906  :       
; 907  :       for ( nn = 0 ; (meet_flag == 0) && (nn < c_nbr_count) ; nn++ )

	mov	ebx, DWORD PTR _nn$89621[ebp]
	inc	ebx
	mov	DWORD PTR _nn$89621[ebp], ebx
	test	ecx, ecx
	je	SHORT $LL145@choose_coa

; 896  :       }
; 897  :     }
; 898  : 
; 899  : step4:
; 900  :     /* A3.5  */
; 901  :     for ( j = 0 ; j < sfcount ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	jmp	$LN160@choose_coa
$LN12@choose_coa:

; 911  :             break;
; 912  :           }
; 913  : 
; 914  :       if ( meet_flag == 0 )

	test	ecx, ecx
	je	SHORT $LN90@choose_coa

; 896  :       }
; 897  :     }
; 898  : 
; 899  : step4:
; 900  :     /* A3.5  */
; 901  :     for ( j = 0 ; j < sfcount ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	jmp	$LN160@choose_coa
$LN90@choose_coa:

; 915  :       { /* step 7 */
; 916  :         if ( ctwiddle_count )  /* punt, and make it coarse */

	cmp	DWORD PTR _ctwiddle_count$89602[ebp], 0
	jne	SHORT $LN91@choose_coa

; 919  :           break;
; 920  :         }
; 921  :         ctwiddle = jnbr;
; 922  :         ctwiddle_count = 1;
; 923  :         c_nbrs[c_nbr_count++] = jnbr;

	mov	eax, DWORD PTR _c_nbr_count$89606[ebp]
	mov	DWORD PTR _c_nbrs$89604[ebp+eax*4], edx
	inc	eax
	mov	DWORD PTR _c_nbr_count$89606[ebp], eax

; 924  :         strong_fnbrs[j] = strong_fnbrs[--sfcount];

	mov	eax, DWORD PTR _sfcount$89601[ebp]
	dec	eax
	mov	DWORD PTR _ctwiddle$89603[ebp], edx
	mov	edx, DWORD PTR _strong_fnbrs$89605[ebp+eax*4]
	mov	DWORD PTR _sfcount$89601[ebp], eax
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _ctwiddle_count$89602[ebp], 1
	mov	DWORD PTR _strong_fnbrs$89605[ebp+eax*4], edx
	jmp	$step4$89615
$LN91@choose_coa:

; 917  :         { mg->marks[n] = coarse_mark;

	mov	eax, DWORD PTR [esi+8]
	mov	edi, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _coarse_mark
	mov	DWORD PTR [eax+edi*4], ecx

; 918  :           mg->coarse_count++;

	inc	DWORD PTR [esi+12]
	jmp	SHORT $LN15@choose_coa
$LN139@choose_coa:
	mov	edi, DWORD PTR _n$[ebp]
$LN15@choose_coa:

; 925  :         goto step4;  /* try again */
; 926  :       }
; 927  : 
; 928  :     } /* end step A3.5 */
; 929  :      
; 930  :     /* step A3.9 */
; 931  :     if ( ctwiddle_count )

	xor	ecx, ecx
	cmp	DWORD PTR _ctwiddle_count$89602[ebp], ecx
	je	SHORT $LN25@choose_coa

; 932  :     {  mg->marks[ctwiddle] = coarse_mark;

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _ctwiddle$89603[ebp]
	mov	ebx, DWORD PTR _coarse_mark
	mov	DWORD PTR [edx+eax*4], ebx

; 933  :        mg->coarse_count++;

	inc	DWORD PTR [esi+12]
$LN25@choose_coa:

; 867  :      }
; 868  :   }
; 869  : 
; 870  :   /* Finalize choice of coarse points */
; 871  :   /* (algorithm A3, p. 102; weight calculation separate) */
; 872  :   for ( n = 0 ; n < fine->N ; n++ )

	mov	edx, DWORD PTR _fine$[ebp]
	inc	edi
	mov	DWORD PTR _n$[ebp], edi
	cmp	edi, DWORD PTR [edx+4]
	jl	$LL26@choose_coa
$LN131@choose_coa:

; 934  :     }
; 935  :   }   /* end step A3.2 */
; 936  : 
; 937  :   /* coarse system aliases of coarse variables */
; 938  :   mg->coarse = (struct linsys *)temp_calloc(1,sizeof(struct linsys));

	push	938					; 000003aaH
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	232					; 000000e8H
	push	1
	call	_kb_temp_calloc

; 939  :   mg->fine_to_coarse = (int*)temp_calloc(fine->N,sizeof(int));

	mov	edi, DWORD PTR _fine$[ebp]
	push	939					; 000003abH
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edi+4]
	push	4
	push	eax
	call	_kb_temp_calloc

; 940  :   mg->coarse_to_fine = (int*)temp_calloc(mg->coarse_count,sizeof(int));

	mov	ecx, DWORD PTR [esi+12]
	push	940					; 000003acH
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	4
	push	ecx
	mov	DWORD PTR [esi+16], eax
	call	_kb_temp_calloc
	mov	DWORD PTR [esi+20], eax

; 941  :   for ( n = 0, cspot = 0 ; n < fine->N ; n++ )

	xor	eax, eax
	add	esp, 48					; 00000030H
	xor	ecx, ecx
	cmp	DWORD PTR [edi+4], eax
	jle	SHORT $LN2@choose_coa
	mov	edx, DWORD PTR _coarse_mark
	npad	5
$LL147@choose_coa:

; 942  :     if ( mg->marks[n] == coarse_mark )

	mov	ebx, DWORD PTR [esi+8]
	cmp	DWORD PTR [ebx+eax*4], edx
	jne	SHORT $LN3@choose_coa

; 943  :     { mg->fine_to_coarse[n] = cspot;

	mov	ebx, DWORD PTR [esi+16]
	mov	DWORD PTR [ebx+eax*4], ecx

; 944  :       mg->coarse_to_fine[cspot] = n;

	mov	ebx, DWORD PTR [esi+20]
	mov	DWORD PTR [ebx+ecx*4], eax

; 945  :       cspot++;

	inc	ecx
$LN3@choose_coa:

; 941  :   for ( n = 0, cspot = 0 ; n < fine->N ; n++ )

	inc	eax
	cmp	eax, DWORD PTR [edi+4]
	jl	SHORT $LL147@choose_coa
$LN2@choose_coa:

; 946  :     }
; 947  : 
; 948  : 
; 949  :   temp_free((char*)nbr_count);

	mov	edx, DWORD PTR _nbr_count$[ebp]
	push	edx
	call	_temp_free

; 950  :   temp_free((char*)amaxes);

	mov	eax, DWORD PTR _amaxes$[ebp]
	push	eax
	call	_temp_free

; 951  : 
; 952  :   temp_free((char*)stnbr_starts);

	mov	ecx, DWORD PTR _stnbr_starts$[ebp]
	push	ecx
	call	_temp_free

; 953  :   temp_free((char*)stnbr_counts);

	mov	edx, DWORD PTR _stnbr_counts$[ebp]
	push	edx
	call	_temp_free

; 954  :   temp_free((char*)stnbr_lists);

	mov	eax, DWORD PTR _stnbr_lists$[ebp]
	push	eax
	call	_temp_free

; 955  :   temp_free((char*)wnbr_starts);

	mov	ecx, DWORD PTR _wnbr_starts$[ebp]
	push	ecx
	call	_temp_free

; 956  :   temp_free((char*)wnbr_counts);

	mov	edx, DWORD PTR _wnbr_counts$[ebp]
	push	edx
	call	_temp_free

; 957  :   temp_free((char*)wnbr_lists);

	mov	eax, DWORD PTR _wnbr_lists$[ebp]
	push	eax
	call	_temp_free

; 958  : 
; 959  : } /* end choose_coarse_points() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_choose_coarse_points ENDP
_TEXT	ENDS
PUBLIC	_get_a
; Function compile flags: /Ogtp
;	COMDAT _get_a
_TEXT	SEGMENT
_S$ = 8							; size = 4
_row$ = 12						; size = 4
_col$ = 16						; size = 4
_get_a	PROC						; COMDAT

; 972  : { int kk;

	push	ebp
	mov	ebp, esp

; 973  : 
; 974  :   /* get into upper diagonal */
; 975  :   if ( row > col )

	mov	eax, DWORD PTR _row$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _col$[ebp]
	cmp	eax, edi
	jle	SHORT $LN5@get_a

; 976  :   { int temp = row;

	mov	ecx, eax

; 977  :     row = col;

	mov	eax, edi

; 978  :     col = temp;

	mov	edi, ecx
$LN5@get_a:

; 979  :   }
; 980  : 
; 981  :   for ( kk = S->IA[row]-A_OFF+1 ; kk < S->IA[row+1]-A_OFF ; kk++ )

	mov	esi, DWORD PTR _S$[ebp]
	mov	ecx, DWORD PTR [esi+52]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	dec	ecx
	cmp	eax, ecx
	jge	SHORT $LN2@get_a
	mov	edx, DWORD PTR [esi+56]
	lea	edx, DWORD PTR [edx+eax*4]
	npad	2
$LL4@get_a:

; 982  :    if ( S->JA[kk] == col )

	cmp	DWORD PTR [edx], edi
	je	SHORT $LN9@get_a

; 979  :   }
; 980  : 
; 981  :   for ( kk = S->IA[row]-A_OFF+1 ; kk < S->IA[row+1]-A_OFF ; kk++ )

	inc	eax
	add	edx, 4
	cmp	eax, ecx
	jl	SHORT $LL4@get_a
$LN2@get_a:

; 984  : 
; 985  :   return 0.0;

	fldz
	pop	edi
	pop	esi

; 986  : } /* end get_a() */

	pop	ebp
	ret	0
$LN9@get_a:

; 983  :      return S->A[kk];

	mov	ecx, DWORD PTR [esi+60]
	fld	QWORD PTR [ecx+eax*8]
	pop	edi
	pop	esi

; 986  : } /* end get_a() */

	pop	ebp
	ret	0
_get_a	ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_interpolation_weights
EXTRN	_kb_temp_realloc:PROC
; Function compile flags: /Ogtp
;	COMDAT _interpolation_weights
_TEXT	SEGMENT
_d_i$89687 = -12060					; size = 8
_denom$89709 = -12052					; size = 8
_interp_alloc$ = -12044					; size = 4
tv1380 = -12040						; size = 8
tv430 = -12036						; size = 4
tv354 = -12036						; size = 4
_n$ = -12032						; size = 4
_sfcount$89683 = -12028					; size = 4
tv582 = -12024						; size = 4
tv769 = -12020						; size = 4
_j$89686 = -12020					; size = 4
_c_spot$ = -12016					; size = 4
_fine$ = -12012						; size = 4
tv834 = -12008						; size = 4
tv771 = -12008						; size = 4
_k$89684 = -12008					; size = 4
_strong_fnbrs$89682 = -12004				; size = 4000
_d$89688 = -8004					; size = 8000
__$ArrayPad$ = -4					; size = 4
_mg$ = 8						; size = 4
_interpolation_weights PROC				; COMDAT

; 997  : { struct linsys *fine = mg->fine;

	push	ebp
	mov	ebp, esp
	mov	eax, 12060				; 00002f1cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _mg$[ebp]
	mov	ebx, DWORD PTR [edi]

; 998  :   int c_spot; /* current place in interpolation long lists */
; 999  :   int n; /* index of fine variables */
; 1000 :   int interp_alloc; /* how many entries allocated */
; 1001 : 
; 1002 :   /* Interpolation weights (algorithm A3, p. 102) */
; 1003 : 
; 1004 :   interp_alloc = 2*fine->IA[fine->N];

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx+52]
	mov	esi, DWORD PTR [ecx+eax*4]

; 1005 :   mg->interp_JA = (int*)temp_calloc(interp_alloc,sizeof(int));

	push	1005					; 000003edH
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	add	esi, esi
	push	4
	push	esi
	mov	DWORD PTR _fine$[ebp], ebx
	mov	DWORD PTR _interp_alloc$[ebp], esi
	call	_kb_temp_calloc

; 1006 :   mg->interp_IA = (int*)temp_calloc(fine->N+1,sizeof(int));

	push	1006					; 000003eeH
	mov	DWORD PTR [edi+28], eax
	mov	edx, DWORD PTR [ebx+4]
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	inc	edx
	push	4
	push	edx
	call	_kb_temp_calloc

; 1007 :   mg->interp_A  = (REAL*)temp_calloc(interp_alloc,sizeof(int));

	push	1007					; 000003efH
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	4
	push	esi
	mov	DWORD PTR [edi+24], eax
	call	_kb_temp_calloc
	mov	DWORD PTR [edi+32], eax

; 1008 : 
; 1009 :   c_spot = 0;
; 1010 : 
; 1011 :   for ( n = 0 ; n < fine->N ; n++ )

	mov	eax, DWORD PTR _fine$[ebp]
	mov	eax, DWORD PTR [eax+4]
	xor	esi, esi
	xor	ebx, ebx
	add	esp, 48					; 00000030H
	mov	DWORD PTR _c_spot$[ebp], esi
	mov	DWORD PTR _n$[ebp], ebx
	test	eax, eax
	jle	$LN23@interpolat
	npad	3
$LL25@interpolat:

; 1012 :   { int strong_fnbrs[1000];
; 1013 :     int sfcount; /* of strong_fnbrs */
; 1014 :     int k,kk,j;
; 1015 :     REAL d_i; /* diagonal entry for this variable */
; 1016 :     REAL d[1000]; /* for nbrs */
; 1017 :     
; 1018 :     if ( c_spot + fine->N >= interp_alloc )

	lea	ecx, DWORD PTR [eax+esi]
	mov	eax, DWORD PTR _interp_alloc$[ebp]
	cmp	ecx, eax
	jl	SHORT $LN22@interpolat

; 1019 :     { /* need more room */
; 1020 :       interp_alloc *= 2;

	add	eax, eax

; 1021 :       mg->interp_JA = (int*)temp_realloc((char*)(mg->interp_JA),
; 1022 :                                  interp_alloc*sizeof(int));

	push	1022					; 000003feH
	lea	edx, DWORD PTR [eax*4]
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	mov	DWORD PTR _interp_alloc$[ebp], eax
	mov	eax, DWORD PTR [edi+28]
	push	edx
	push	eax
	call	_kb_temp_realloc

; 1023 :       mg->interp_A  = (REAL*)temp_realloc((char*)(mg->interp_A),
; 1024 :                                  interp_alloc*sizeof(REAL));

	mov	ecx, DWORD PTR _interp_alloc$[ebp]
	push	1024					; 00000400H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	lea	edx, DWORD PTR [ecx*8]
	mov	DWORD PTR [edi+28], eax
	mov	eax, DWORD PTR [edi+32]
	push	edx
	push	eax
	call	_kb_temp_realloc
	add	esp, 32					; 00000020H
	mov	DWORD PTR [edi+32], eax
$LN22@interpolat:

; 1025 :     }
; 1026 : 
; 1027 :     mg->interp_IA[n] = c_spot; 

	mov	ecx, DWORD PTR [edi+24]

; 1028 :  
; 1029 :     if ( mg->marks[n] == coarse_mark ) 

	mov	edx, DWORD PTR _coarse_mark
	mov	DWORD PTR [ecx+ebx*4], esi
	mov	eax, DWORD PTR [edi+8]
	cmp	DWORD PTR [eax+ebx*4], edx
	jne	SHORT $LN21@interpolat

; 1030 :     { /* interpolate just on self */
; 1031 :       mg->interp_A[c_spot] = 1.0; 

	mov	ecx, DWORD PTR [edi+32]
	fld1

; 1032 :       mg->interp_JA[c_spot] = n;

	mov	edx, DWORD PTR [edi+28]
	fstp	QWORD PTR [ecx+esi*8]
	mov	DWORD PTR [edx+esi*4], ebx

; 1033 :       continue;

	jmp	$LN24@interpolat
$LN21@interpolat:

; 1034 :     }
; 1035 : 
; 1036 :     /* A3.3: set C_i = S_i intersect C */
; 1037 :     sfcount = 0;
; 1038 :     for ( k = 0 ; k < mg->snbr_counts[n] ; k++ )

	mov	ecx, DWORD PTR [edi+52]
	xor	eax, eax
	mov	DWORD PTR _sfcount$89683[ebp], eax
	mov	DWORD PTR _k$89684[ebp], eax
	cmp	DWORD PTR [ecx+ebx*4], eax
	jle	SHORT $LN48@interpolat
$LL20@interpolat:

; 1039 :     { int snbr = mg->snbr_lists[mg->snbr_starts[n] + k];

	mov	ecx, DWORD PTR [edi+48]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	add	ecx, eax
	mov	eax, DWORD PTR [edi+56]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1040 :       if ( mg->marks[snbr] == coarse_mark )

	mov	ecx, DWORD PTR [edi+8]
	cmp	DWORD PTR [ecx+eax*4], edx
	jne	SHORT $LN17@interpolat

; 1041 :         mg->interp_JA[c_spot++] = snbr; /* add to coarse nbr list */

	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR [ecx+esi*4], eax
	inc	esi

; 1042 :       else

	jmp	SHORT $LN19@interpolat
$LN17@interpolat:

; 1043 :         strong_fnbrs[sfcount++] = snbr;  /* Ds_i */

	mov	ecx, DWORD PTR _sfcount$89683[ebp]
	mov	DWORD PTR _strong_fnbrs$89682[ebp+ecx*4], eax
	inc	ecx
	mov	DWORD PTR _sfcount$89683[ebp], ecx
$LN19@interpolat:

; 1034 :     }
; 1035 : 
; 1036 :     /* A3.3: set C_i = S_i intersect C */
; 1037 :     sfcount = 0;
; 1038 :     for ( k = 0 ; k < mg->snbr_counts[n] ; k++ )

	mov	eax, DWORD PTR _k$89684[ebp]
	mov	ecx, DWORD PTR [edi+52]
	inc	eax
	mov	DWORD PTR _k$89684[ebp], eax
	cmp	eax, DWORD PTR [ecx+ebx*4]
	jl	SHORT $LL20@interpolat

; 1041 :         mg->interp_JA[c_spot++] = snbr; /* add to coarse nbr list */

	mov	DWORD PTR _c_spot$[ebp], esi
$LN48@interpolat:

; 1044 :     }
; 1045 : 
; 1046 :     /* A3.4, d_i = a_ii + sum weak */
; 1047 :     d_i = fine->A[fine->IA[n]-A_OFF] + mg->wnbr_asums[n];

	mov	eax, DWORD PTR _fine$[ebp]
	mov	edx, DWORD PTR [eax+52]
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [eax+60]
	mov	eax, DWORD PTR [edi+60]
	fld	QWORD PTR [edx+ecx*8-8]
	fadd	QWORD PTR [eax+ebx*8]

; 1048 :     for ( k = mg->interp_IA[n], kk=0 ; k < c_spot ; k++,kk++ )

	mov	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR tv582[ebp], eax
	fst	QWORD PTR _d_i$89687[ebp]
	cmp	eax, esi
	jge	SHORT $LN13@interpolat
	mov	ecx, DWORD PTR [edi+28]
	fstp	ST(0)
	lea	edx, DWORD PTR _d$89688[ebp]
	mov	DWORD PTR tv769[ebp], edx
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, esi
	sub	ecx, eax
	mov	DWORD PTR tv771[ebp], edx
	mov	DWORD PTR tv430[ebp], ecx
	npad	8
$LL47@interpolat:

; 1049 :       d[kk] = get_a(fine,n,mg->interp_JA[k]);

	mov	eax, DWORD PTR tv771[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _fine$[ebp]
	push	ecx
	push	ebx
	push	edx
	call	_get_a
	mov	eax, DWORD PTR tv769[ebp]
	add	DWORD PTR tv771[ebp], 4
	fstp	QWORD PTR [eax]
	add	eax, 8
	add	esp, 12					; 0000000cH
	dec	DWORD PTR tv430[ebp]
	mov	DWORD PTR tv769[ebp], eax
	jne	SHORT $LL47@interpolat

; 1048 :     for ( k = mg->interp_IA[n], kk=0 ; k < c_spot ; k++,kk++ )

	fld	QWORD PTR _d_i$89687[ebp]
	mov	eax, DWORD PTR tv582[ebp]
$LN13@interpolat:

; 1050 : 
; 1051 : 
; 1052 : 
; 1053 :     /* A3.5  */
; 1054 :     for ( j = 0 ; j < sfcount ; j++ )

	xor	ecx, ecx
	mov	DWORD PTR _j$89686[ebp], ecx
	cmp	DWORD PTR _sfcount$89683[ebp], ecx
	jle	$LN10@interpolat
$LN12@interpolat:

; 1055 :     { REAL denom;
; 1056 :       int jnbr = strong_fnbrs[j];
; 1057 : 
; 1058 :       /* step 8 */
; 1059 :       /* denominator */
; 1060 :       for ( k = mg->interp_IA[n], denom = 0 ; k < c_spot ; k++ )

	fldz
	mov	ebx, DWORD PTR _strong_fnbrs$89682[ebp+ecx*4]
	fstp	QWORD PTR _denom$89709[ebp]
	cmp	eax, esi
	jge	SHORT $LN7@interpolat
	mov	ecx, DWORD PTR [edi+28]
	fstp	ST(0)
	lea	esi, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _c_spot$[ebp]
	sub	eax, DWORD PTR tv582[ebp]
	mov	DWORD PTR tv354[ebp], eax
$LL9@interpolat:

; 1061 :         denom += get_a(fine,jnbr,mg->interp_JA[k]);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _fine$[ebp]
	push	edx
	push	ebx
	push	eax
	call	_get_a
	fadd	QWORD PTR _denom$89709[ebp]
	add	esp, 12					; 0000000cH
	add	esi, 4
	dec	DWORD PTR tv354[ebp]
	fstp	QWORD PTR _denom$89709[ebp]
	jne	SHORT $LL9@interpolat

; 1055 :     { REAL denom;
; 1056 :       int jnbr = strong_fnbrs[j];
; 1057 : 
; 1058 :       /* step 8 */
; 1059 :       /* denominator */
; 1060 :       for ( k = mg->interp_IA[n], denom = 0 ; k < c_spot ; k++ )

	fld	QWORD PTR _d_i$89687[ebp]
	mov	eax, DWORD PTR tv582[ebp]
$LN7@interpolat:

; 1062 :       /* dk's */ 
; 1063 :       for ( k = mg->interp_IA[n] ; k < c_spot ; k++ )

	mov	esi, eax
	cmp	esi, DWORD PTR _c_spot$[ebp]
	jge	SHORT $LN11@interpolat
	mov	ecx, DWORD PTR [edi+28]
	fstp	ST(0)
	lea	edx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR tv834[ebp], edx
	npad	12
$LL6@interpolat:

; 1064 :         d[k] += get_a(fine,n,jnbr)*get_a(fine,jnbr,mg->interp_JA[k])/denom;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _fine$[ebp]
	push	ebx
	push	eax
	push	ecx
	call	_get_a
	fstp	QWORD PTR tv1380[ebp]
	mov	edx, DWORD PTR tv834[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _fine$[ebp]
	push	eax
	push	ebx
	push	ecx
	call	_get_a
	fmul	QWORD PTR tv1380[ebp]
	add	DWORD PTR tv834[ebp], 4
	inc	esi
	fdiv	QWORD PTR _denom$89709[ebp]
	add	esp, 24					; 00000018H
	fadd	QWORD PTR _d$89688[ebp+esi*8-8]
	fstp	QWORD PTR _d$89688[ebp+esi*8-8]
	cmp	esi, DWORD PTR _c_spot$[ebp]
	jl	SHORT $LL6@interpolat

; 1062 :       /* dk's */ 
; 1063 :       for ( k = mg->interp_IA[n] ; k < c_spot ; k++ )

	fld	QWORD PTR _d_i$89687[ebp]
$LN11@interpolat:

; 1050 : 
; 1051 : 
; 1052 : 
; 1053 :     /* A3.5  */
; 1054 :     for ( j = 0 ; j < sfcount ; j++ )

	mov	ecx, DWORD PTR _j$89686[ebp]
	mov	esi, DWORD PTR _c_spot$[ebp]
	mov	eax, DWORD PTR tv582[ebp]
	inc	ecx
	mov	DWORD PTR _j$89686[ebp], ecx
	cmp	ecx, DWORD PTR _sfcount$89683[ebp]
	jl	$LN12@interpolat
$LN10@interpolat:

; 1065 :     } /* end step A3.5 */
; 1066 :      
; 1067 :     /* step A3.9 */
; 1068 :     for ( k = mg->interp_IA[n], kk=0 ; k < c_spot ; k++,kk++ )

	mov	ebx, eax
	xor	ecx, ecx
	cmp	ebx, esi
	jge	$LN73@interpolat
	mov	edx, esi
	sub	edx, ebx
	cmp	edx, 4
	jl	SHORT $LC43@interpolat

; 1069 :       mg->interp_A[k] = -d[kk]/d_i;

	mov	eax, DWORD PTR [edi+32]
	mov	edx, esi
	sub	edx, ebx
	sub	edx, 4
	shr	edx, 2
	inc	edx
	lea	eax, DWORD PTR [eax+ebx*8+16]
	lea	ebx, DWORD PTR [ebx+edx*4]
$LN44@interpolat:
	fld	QWORD PTR _d$89688[ebp+ecx*8]
	add	ecx, 4
	fdiv	ST(0), ST(1)
	add	eax, 32					; 00000020H
	dec	edx
	fchs
	fstp	QWORD PTR [eax-48]
	fld	QWORD PTR _d$89688[ebp+ecx*8-24]
	fdiv	ST(0), ST(1)
	fchs
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR _d$89688[ebp+ecx*8-16]
	fdiv	ST(0), ST(1)
	fchs
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR _d$89688[ebp+ecx*8-8]
	fdiv	ST(0), ST(1)
	fchs
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN44@interpolat
$LC43@interpolat:

; 1065 :     } /* end step A3.5 */
; 1066 :      
; 1067 :     /* step A3.9 */
; 1068 :     for ( k = mg->interp_IA[n], kk=0 ; k < c_spot ; k++,kk++ )

	cmp	ebx, esi
	jge	SHORT $LN73@interpolat
	mov	edx, DWORD PTR [edi+32]
	mov	eax, esi
	lea	edx, DWORD PTR [edx+ebx*8]
	lea	ecx, DWORD PTR _d$89688[ebp+ecx*8]
	sub	eax, ebx
$LC3@interpolat:

; 1069 :       mg->interp_A[k] = -d[kk]/d_i;

	fld	QWORD PTR [ecx]
	add	ecx, 8
	fdiv	ST(0), ST(1)
	add	edx, 8
	dec	eax
	fchs
	fstp	QWORD PTR [edx-8]
	jne	SHORT $LC3@interpolat
$LN73@interpolat:

; 1065 :     } /* end step A3.5 */
; 1066 :      
; 1067 :     /* step A3.9 */
; 1068 :     for ( k = mg->interp_IA[n], kk=0 ; k < c_spot ; k++,kk++ )

	mov	ebx, DWORD PTR _n$[ebp]
	fstp	ST(0)
$LN24@interpolat:

; 1008 : 
; 1009 :   c_spot = 0;
; 1010 : 
; 1011 :   for ( n = 0 ; n < fine->N ; n++ )

	mov	eax, DWORD PTR _fine$[ebp]
	mov	eax, DWORD PTR [eax+4]
	inc	ebx
	mov	DWORD PTR _n$[ebp], ebx
	cmp	ebx, eax
	jl	$LL25@interpolat
$LN23@interpolat:

; 1070 : 
; 1071 :   }   /* end step A3.2 */
; 1072 : 
; 1073 :   mg->interp_IA[n] = c_spot;  

	mov	ecx, DWORD PTR [edi+24]

; 1074 : 
; 1075 :   /* free unneeded space */
; 1076 :   interp_alloc = c_spot;
; 1077 :   mg->interp_JA = (int*)temp_realloc((char*)(mg->interp_JA),
; 1078 :                                  interp_alloc*sizeof(int));

	push	1078					; 00000436H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	lea	edx, DWORD PTR [esi*4]
	mov	DWORD PTR [ecx+ebx*4], esi
	mov	eax, DWORD PTR [edi+28]
	push	edx
	push	eax
	call	_kb_temp_realloc

; 1079 :   mg->interp_A  = (REAL*)temp_realloc((char*)(mg->interp_A),
; 1080 :                                  interp_alloc*sizeof(REAL));

	mov	edx, DWORD PTR [edi+32]
	push	1080					; 00000438H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	lea	ecx, DWORD PTR [esi*8]
	push	ecx
	push	edx
	mov	DWORD PTR [edi+28], eax
	call	_kb_temp_realloc

; 1081 : } /* end interpolation_weights() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 32					; 00000020H
	mov	DWORD PTR [edi+32], eax
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_interpolation_weights ENDP
_TEXT	ENDS
PUBLIC	_interpolation_transpose
; Function compile flags: /Ogtp
;	COMDAT _interpolation_transpose
_TEXT	SEGMENT
_spot$89757 = -8					; size = 4
_k$ = -4						; size = 4
_j$ = 8							; size = 4
_mg$ = 8						; size = 4
_interpolation_transpose PROC				; COMDAT

; 1090 : { int k,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi

; 1091 : 
; 1092 :   /* transpose of interpolation matrix, i.e. store fine row adjacent,
; 1093 :      and index starts by coarse number */
; 1094 : 
; 1095 :   int *interp_tr_counts = (int*)temp_calloc(mg->coarse_count,sizeof(int));

	mov	esi, DWORD PTR _mg$[ebp]
	mov	eax, DWORD PTR [esi+12]
	push	edi
	push	1095					; 00000447H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	4
	push	eax
	call	_kb_temp_calloc

; 1096 :   for ( k = 0 ; k < mg->fine->N ; k++ )

	mov	ecx, DWORD PTR [esi]
	xor	edx, edx
	add	esp, 16					; 00000010H
	mov	edi, eax
	cmp	DWORD PTR [ecx+4], edx
	jle	SHORT $LN13@interpolat@2
	npad	1
$LL15@interpolat@2:
	mov	eax, DWORD PTR [esi+24]
	lea	ecx, DWORD PTR [eax+edx*4]

; 1097 :     for ( j = mg->interp_IA[k] ; j < mg->interp_IA[k+1] ; j++ )

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	jge	SHORT $LN14@interpolat@2
	npad	3
$LL12@interpolat@2:

; 1098 :     { int cnum = mg->fine_to_coarse[mg->interp_JA[j]];

	mov	ecx, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	ebx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [ebx+ecx*4]

; 1099 :       interp_tr_counts[cnum]++;

	inc	DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [esi+24]
	inc	eax
	cmp	eax, DWORD PTR [ecx+edx*4+4]
	jl	SHORT $LL12@interpolat@2
$LN14@interpolat@2:

; 1096 :   for ( k = 0 ; k < mg->fine->N ; k++ )

	mov	eax, DWORD PTR [esi]
	inc	edx
	cmp	edx, DWORD PTR [eax+4]
	jl	SHORT $LL15@interpolat@2
$LN13@interpolat@2:

; 1100 :     }
; 1101 :     
; 1102 :   mg->interp_tr_IA = (int*)temp_calloc(mg->coarse_count+1,sizeof(int));

	mov	ecx, DWORD PTR [esi+12]
	push	1102					; 0000044eH
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	inc	ecx
	push	4
	push	ecx
	call	_kb_temp_calloc
	mov	DWORD PTR [esi+36], eax

; 1103 :   for ( k = 0 ; k < mg->coarse_count ; k++ )

	xor	eax, eax
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [esi+12], eax
	jle	SHORT $LN7@interpolat@2
$LL9@interpolat@2:
	mov	edx, DWORD PTR [esi+36]
	lea	ecx, DWORD PTR [edx+eax*4]

; 1104 :   { mg->interp_tr_IA[k+1] = mg->interp_tr_IA[k] +
; 1105 :             interp_tr_counts[k];

	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR [edi+eax*4]
	inc	eax
	mov	DWORD PTR [ecx+4], edx

; 1106 :     interp_tr_counts[k] = 0;

	mov	DWORD PTR [edi+eax*4-4], 0
	cmp	eax, DWORD PTR [esi+12]
	jl	SHORT $LL9@interpolat@2
$LN7@interpolat@2:

; 1107 :   }
; 1108 :   
; 1109 :   mg->interp_tr_A = (REAL*)temp_calloc(mg->interp_tr_IA[mg->coarse_count],
; 1110 :       sizeof(REAL));

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	1110					; 00000456H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	8
	push	edx
	call	_kb_temp_calloc

; 1111 :   mg->interp_tr_JA = (int*)temp_calloc(mg->interp_tr_IA[mg->coarse_count],
; 1112 :       sizeof(int));

	mov	ecx, DWORD PTR [esi+36]
	push	1112					; 00000458H
	mov	DWORD PTR [esi+44], eax
	mov	eax, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	4
	push	edx
	call	_kb_temp_calloc
	mov	DWORD PTR [esi+40], eax

; 1113 :      
; 1114 :   for ( k = 0 ; k < mg->fine->N ; k++ )

	mov	eax, DWORD PTR [esi]
	xor	edx, edx
	add	esp, 32					; 00000020H
	mov	DWORD PTR _k$[ebp], edx
	cmp	DWORD PTR [eax+4], edx
	jle	SHORT $LN4@interpolat@2
	npad	5
$LL6@interpolat@2:
	mov	ecx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [ecx+edx*4]

; 1115 :     for ( j = mg->interp_IA[k] ; j < mg->interp_IA[k+1] ; j++ )

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN5@interpolat@2
$LL3@interpolat@2:

; 1116 :     { int cnum = mg->fine_to_coarse[mg->interp_JA[j]];

	mov	edx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [edx+eax*4]

; 1117 :       int spot =  mg->interp_tr_IA[cnum] + interp_tr_counts[cnum] ;

	mov	edx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [edx+eax*4]
	add	edx, DWORD PTR [edi+eax*4]

; 1118 :       mg->interp_tr_A[spot] = mg->interp_A[j];

	mov	ebx, DWORD PTR [esi+44]
	mov	DWORD PTR _spot$89757[ebp], edx
	mov	edx, DWORD PTR [esi+32]
	fld	QWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _spot$89757[ebp]

; 1119 :       mg->interp_tr_JA[spot] = k;

	mov	edx, DWORD PTR _k$[ebp]
	fstp	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [esi+40]
	mov	DWORD PTR [ebx+ecx*4], edx
	mov	ecx, DWORD PTR _j$[ebp]

; 1120 :       interp_tr_counts[cnum]++;

	inc	DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi+24]
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+edx*4+4]
	jl	SHORT $LL3@interpolat@2
$LN5@interpolat@2:

; 1113 :      
; 1114 :   for ( k = 0 ; k < mg->fine->N ; k++ )

	mov	ecx, DWORD PTR [esi]
	inc	edx
	mov	DWORD PTR _k$[ebp], edx
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LL6@interpolat@2
$LN4@interpolat@2:
	pop	edi
	pop	esi
	pop	ebx

; 1121 :     }
; 1122 : 
; 1123 : } /* end interpolation_transpose() */

	mov	esp, ebp
	pop	ebp
	ret	0
_interpolation_transpose ENDP
_TEXT	ENDS
PUBLIC	__real@4000000000000000
PUBLIC	_coarse_matrix
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _coarse_matrix
_TEXT	SEGMENT
tv2285 = -64						; size = 4
_c_base$ = -64						; size = 4
_temp_base$89788 = -64					; size = 4
tv4241 = -60						; size = 4
tv2289 = -60						; size = 4
_ck$89846 = -60						; size = 4
_fn$89831 = -60						; size = 4
_jk$89795 = -60						; size = 4
_aval$89796 = -56					; size = 8
_ispot$89886 = -52					; size = 4
_m$89833 = -52						; size = 4
_kk$ = -52						; size = 4
tv2067 = -48						; size = 4
_row$89876 = -48					; size = 4
_ck$89808 = -48						; size = 4
_new_upper$ = -44					; size = 4
_temp_A_alloc$ = -44					; size = 4
tv3751 = -40						; size = 4
_spot$ = -40						; size = 4
_c_top$ = -40						; size = 4
_nk$ = -40						; size = 4
_col$89877 = -36					; size = 4
_k$ = -36						; size = 4
_temp_top$ = -36					; size = 4
_coarse_alloc$ = -32					; size = 4
_m$89792 = -32						; size = 4
tv3498 = -28						; size = 4
tv3150 = -28						; size = 4
_j$ = -28						; size = 4
tv3152 = -24						; size = 4
_temp_counts$ = -20					; size = 4
tv3057 = -16						; size = 4
_temp_IA$ = -12						; size = 4
_temp_A$ = -8						; size = 4
_temp_JA$ = -4						; size = 4
_n$ = 8							; size = 4
_mg$ = 8						; size = 4
_coarse_matrix PROC					; COMDAT

; 1134 : { int n,nk,kk,k,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi

; 1135 :   int temp_top;
; 1136 :   int *temp_IA,*temp_JA;
; 1137 :   REAL *temp_A;
; 1138 :   int *temp_counts;
; 1139 :   int temp_A_alloc;
; 1140 :   int c_base,c_top;
; 1141 :   int *new_upper;
; 1142 :   int spot;
; 1143 :   int coarse_alloc;
; 1144 :   
; 1145 :   /* Now assemble the coarse system */
; 1146 : 
; 1147 :   /* project the A matrix, A_c = Interp^tr A_f Interp */
; 1148 :   /* Doing half of diagonal, to take advantage of symmetry */
; 1149 :   /* First, A_f Interp */
; 1150 :   /* using row-wise interp to avoid quadratic time */
; 1151 : 
; 1152 :   temp_IA = (int*)temp_calloc(mg->fine->N+1,sizeof(int));

	mov	esi, DWORD PTR _mg$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	push	1152					; 00000480H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	inc	ecx
	push	4
	push	ecx
	call	_kb_temp_calloc

; 1153 :   temp_counts = (int*)temp_calloc(mg->fine->N,sizeof(int));

	mov	edx, DWORD PTR [esi]
	push	1153					; 00000481H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	mov	DWORD PTR _temp_IA$[ebp], eax
	mov	eax, DWORD PTR [edx+4]
	push	4
	push	eax
	call	_kb_temp_calloc
	mov	DWORD PTR _temp_counts$[ebp], eax

; 1154 :   temp_A_alloc = mg->fine->IA[mg->fine->N];

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+52]
	mov	edi, DWORD PTR [edx+ecx*4]

; 1155 :   temp_A = (REAL*)temp_calloc(temp_A_alloc,sizeof(REAL));

	push	1155					; 00000483H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	8
	push	edi
	mov	DWORD PTR _temp_A_alloc$[ebp], edi
	call	_kb_temp_calloc

; 1156 :   temp_JA = (int*)temp_calloc(temp_A_alloc,sizeof(int));

	push	1156					; 00000484H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	4
	push	edi
	mov	DWORD PTR _temp_A$[ebp], eax
	call	_kb_temp_calloc

; 1157 :  
; 1158 :   mg->coarse->N = mg->coarse_count;  

	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _temp_JA$[ebp], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx

; 1159 :   
; 1160 :   for ( n = 0 , temp_top = 0; n < mg->fine->N ; n++ )

	mov	edx, DWORD PTR [esi]
	xor	edi, edi
	add	esp, 64					; 00000040H
	mov	DWORD PTR _n$[ebp], edi
	mov	DWORD PTR _temp_top$[ebp], edi
	cmp	DWORD PTR [edx+4], edi
	jle	$LN78@coarse_mat
	npad	8
$LL80@coarse_mat:

; 1161 :   { int temp_base = temp_top;
; 1162 :   
; 1163 :      
; 1164 :     temp_IA[n] = temp_base;

	mov	eax, DWORD PTR _temp_IA$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+ecx*4], edi

; 1165 :     for ( nk = mg->fine->IA[n]-A_OFF ; nk < mg->fine->IA[n+1]-A_OFF ; nk++ )

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+52]
	mov	ebx, DWORD PTR [edx+ecx*4+4]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx]
	dec	edx
	dec	ebx
	mov	DWORD PTR _temp_base$89788[ebp], edi
	mov	DWORD PTR _nk$[ebp], edx
	cmp	edx, ebx
	jge	$LN79@coarse_mat
$LL77@coarse_mat:

; 1166 :     { int m,mm;
; 1167 :       int m_spot;
; 1168 :       int jk = mg->fine->JA[nk]-A_OFF;

	mov	edx, DWORD PTR _nk$[ebp]
	mov	ebx, DWORD PTR [eax+56]

; 1169 :       REAL aval = mg->fine->A[nk];
; 1170 :       if ( nk == mg->fine->IA[n]-A_OFF ) /* diagonal */

	mov	ecx, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [ebx+edx*4]
	mov	eax, DWORD PTR [eax+60]
	fld	QWORD PTR [eax+edx*8]
	dec	ebx
	dec	ecx
	fst	QWORD PTR _aval$89796[ebp]
	mov	DWORD PTR _jk$89795[ebp], ebx
	cmp	edx, ecx
	jne	SHORT $LN74@coarse_mat

; 1171 :         aval /= 2;

	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR _aval$89796[ebp]
$LN74@coarse_mat:

; 1172 :       m_spot = temp_base;
; 1173 :       
; 1174 :       if ( temp_top + mg->coarse->N > temp_A_alloc )

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _temp_A_alloc$[ebp]
	add	ecx, edi
	cmp	ecx, eax
	jle	SHORT $LN73@coarse_mat

; 1175 :       { temp_A_alloc *= 2;

	lea	ebx, DWORD PTR [eax+eax]
	fstp	ST(0)

; 1176 :         temp_A = (REAL*)temp_realloc((char*)temp_A,temp_A_alloc*sizeof(REAL));

	mov	eax, DWORD PTR _temp_A$[ebp]
	push	1176					; 00000498H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	lea	edx, DWORD PTR [ebx*8]
	push	edx
	push	eax
	mov	DWORD PTR _temp_A_alloc$[ebp], ebx
	call	_kb_temp_realloc

; 1177 :         temp_JA = (int*)temp_realloc((char*)temp_JA,temp_A_alloc*sizeof(int));

	mov	edx, DWORD PTR _temp_JA$[ebp]
	push	1177					; 00000499H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	lea	ecx, DWORD PTR [ebx*4]
	push	ecx
	push	edx
	mov	DWORD PTR _temp_A$[ebp], eax
	call	_kb_temp_realloc
	fld	QWORD PTR _aval$89796[ebp]
	mov	ebx, DWORD PTR _jk$89795[ebp]
	add	esp, 32					; 00000020H
	mov	DWORD PTR _temp_JA$[ebp], eax
$LN73@coarse_mat:

; 1178 :       }
; 1179 :       
; 1180 :       for ( kk = mg->interp_IA[jk] ; kk < mg->interp_IA[jk+1] ; kk++ )

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [eax+ebx*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _kk$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+4]
	jge	$LN192@coarse_mat
	mov	eax, DWORD PTR _temp_JA$[ebp]
	lea	edx, DWORD PTR [edi-1]
	mov	DWORD PTR tv3057[ebp], edx
	lea	edx, DWORD PTR [eax+edi*4-8]
	mov	eax, DWORD PTR _temp_A$[ebp]
	mov	DWORD PTR tv3150[ebp], edx
	lea	edx, DWORD PTR [eax+edi*8-16]
	mov	DWORD PTR tv3152[ebp], edx
	mov	edx, DWORD PTR _temp_JA$[ebp]
$LN72@coarse_mat:

; 1181 :       { int ck = mg->interp_JA[kk];
; 1182 :         REAL prod = aval*mg->interp_A[kk];

	mov	ebx, DWORD PTR [esi+32]
	fld	QWORD PTR [ebx+ecx*8]
	mov	eax, DWORD PTR [esi+28]

; 1183 :         /* linear search up, since we expect relatively few entries */
; 1184 :         for ( m = m_spot ; m < temp_top ; m++ )

	mov	ebx, DWORD PTR _temp_base$89788[ebp]
	fmul	ST(0), ST(1)
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _ck$89808[ebp], eax
	cmp	ebx, edi
	jge	$LN256@coarse_mat
$LN69@coarse_mat:

; 1185 :         { if ( ck == temp_JA[m] )

	mov	ecx, DWORD PTR [edx+ebx*4]
	cmp	eax, ecx
	je	SHORT $LN104@coarse_mat

; 1188 :           }
; 1189 :           if ( ck > temp_JA[m] )

	jle	SHORT $LN65@coarse_mat

; 1183 :         /* linear search up, since we expect relatively few entries */
; 1184 :         for ( m = m_spot ; m < temp_top ; m++ )

	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LN69@coarse_mat

; 1300 :       { int ispot = temp_IA[row] + i;
; 1301 :         if ( col == temp_JA[ispot] )

	jmp	$LN67@coarse_mat
$LN104@coarse_mat:

; 1186 :           { temp_A[m] += prod;

	mov	ecx, DWORD PTR _temp_A$[ebp]
	fld	QWORD PTR [ecx+ebx*8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [ecx+ebx*8]

; 1187 :             break;

	jmp	$LN67@coarse_mat
$LN65@coarse_mat:

; 1190 :             continue;
; 1191 :           /* have to make room */
; 1192 :           for ( mm = temp_top-1 ; mm >= m ; mm-- )

	mov	edx, DWORD PTR tv3057[ebp]
	mov	DWORD PTR _m$89792[ebp], ebx
	cmp	edx, ebx
	jl	$LN138@coarse_mat
	mov	ecx, edx
	sub	ecx, ebx
	inc	ecx
	cmp	ecx, 4
	jl	SHORT $LN137@coarse_mat
	mov	ecx, DWORD PTR tv3152[ebp]
	mov	eax, DWORD PTR tv3150[ebp]
	mov	edi, edx
	sub	edi, ebx
	sub	edi, 3
	shr	edi, 2
	inc	edi
	lea	ebx, DWORD PTR [edi*4]
	sub	edx, ebx
$LN130@coarse_mat:

; 1193 :           { temp_JA[mm+1] = temp_JA[mm];

	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], ebx

; 1194 :             temp_A[mm+1] = temp_A[mm];

	fld	QWORD PTR [ecx+8]
	fstp	QWORD PTR [ecx+16]
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ebx
	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [eax-4]
	mov	DWORD PTR [eax], ebx
	fld	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax-8]
	mov	DWORD PTR [eax-4], ebx
	fld	QWORD PTR [ecx-16]
	fstp	QWORD PTR [ecx-8]
	sub	eax, 16					; 00000010H
	sub	ecx, 32					; 00000020H
	dec	edi
	jne	SHORT $LN130@coarse_mat

; 1190 :             continue;
; 1191 :           /* have to make room */
; 1192 :           for ( mm = temp_top-1 ; mm >= m ; mm-- )

	mov	ebx, DWORD PTR _m$89792[ebp]
	mov	eax, DWORD PTR _ck$89808[ebp]
	mov	edi, DWORD PTR _temp_top$[ebp]
$LN137@coarse_mat:
	mov	ecx, DWORD PTR _temp_JA$[ebp]
	cmp	edx, ebx
	jl	SHORT $LN138@coarse_mat
$LC64@coarse_mat:

; 1193 :           { temp_JA[mm+1] = temp_JA[mm];

	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+edx*4+4], eax

; 1194 :             temp_A[mm+1] = temp_A[mm];

	mov	eax, DWORD PTR _temp_A$[ebp]
	fld	QWORD PTR [eax+edx*8]
	dec	edx
	fstp	QWORD PTR [eax+edx*8+16]
	cmp	edx, ebx
	jge	SHORT $LC64@coarse_mat

; 1190 :             continue;
; 1191 :           /* have to make room */
; 1192 :           for ( mm = temp_top-1 ; mm >= m ; mm-- )

	mov	eax, DWORD PTR _ck$89808[ebp]
$LN138@coarse_mat:

; 1195 :           }
; 1196 :           temp_A[m] = prod;

	mov	ecx, DWORD PTR _temp_A$[ebp]

; 1197 :           temp_JA[m] = ck;

	mov	edx, DWORD PTR _temp_JA$[ebp]
	fst	QWORD PTR [ecx+ebx*8]

; 1198 :           temp_top++;

	inc	DWORD PTR tv3057[ebp]
	add	DWORD PTR tv3152[ebp], 8
	inc	edi
	add	DWORD PTR tv3150[ebp], 4
	mov	DWORD PTR [edx+ebx*4], eax
	mov	DWORD PTR _temp_top$[ebp], edi
$LN67@coarse_mat:

; 1199 :           break;
; 1200 :         }
; 1201 :         if ( m == temp_top )

	cmp	ebx, edi
$LN256@coarse_mat:
	jne	SHORT $LN190@coarse_mat

; 1202 :         { /* new one on top */
; 1203 :           temp_JA[temp_top] = ck;
; 1204 :           temp_A[temp_top] = prod;
; 1205 :           temp_top++;

	inc	DWORD PTR tv3057[ebp]
	add	DWORD PTR tv3152[ebp], 8
	mov	DWORD PTR [edx+edi*4], eax
	mov	eax, DWORD PTR _temp_A$[ebp]
	fstp	QWORD PTR [eax+edi*8]
	inc	edi
	add	DWORD PTR tv3150[ebp], 4
	mov	DWORD PTR _temp_top$[ebp], edi
	jmp	SHORT $LN71@coarse_mat
$LN190@coarse_mat:
	fstp	ST(0)
$LN71@coarse_mat:

; 1178 :       }
; 1179 :       
; 1180 :       for ( kk = mg->interp_IA[jk] ; kk < mg->interp_IA[jk+1] ; kk++ )

	mov	ecx, DWORD PTR _kk$[ebp]
	mov	eax, DWORD PTR [esi+24]
	mov	ebx, DWORD PTR _jk$89795[ebp]
	inc	ecx
	mov	DWORD PTR _kk$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+ebx*4+4]
	jl	$LN72@coarse_mat
$LN192@coarse_mat:

; 1165 :     for ( nk = mg->fine->IA[n]-A_OFF ; nk < mg->fine->IA[n+1]-A_OFF ; nk++ )

	mov	eax, DWORD PTR [esi]

; 1202 :         { /* new one on top */
; 1203 :           temp_JA[temp_top] = ck;
; 1204 :           temp_A[temp_top] = prod;
; 1205 :           temp_top++;

	fstp	ST(0)
	mov	ebx, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _nk$[ebp]
	lea	ecx, DWORD PTR [ecx+ebx*4]
	mov	ebx, DWORD PTR [ecx+4]
	inc	edx
	dec	ebx
	mov	DWORD PTR _nk$[ebp], edx
	cmp	edx, ebx
	jl	$LL77@coarse_mat
$LN79@coarse_mat:

; 1159 :   
; 1160 :   for ( n = 0 , temp_top = 0; n < mg->fine->N ; n++ )

	mov	eax, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [esi]
	inc	eax
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, DWORD PTR [edx+4]
	jl	$LL80@coarse_mat
$LN78@coarse_mat:

; 1206 :         }
; 1207 :       }
; 1208 :           
; 1209 :     }
; 1210 :   }
; 1211 :   temp_IA[mg->fine->N] = temp_top;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _temp_IA$[ebp]

; 1212 :  
; 1213 : 
; 1214 :   /* next, Interp^Tr * temp */
; 1215 :   /* using transposed version of interp */
; 1216 :   c_base = 0;
; 1217 :   c_top = 0;
; 1218 : 
; 1219 :   mg->coarse->IA = (int*)temp_calloc(mg->coarse_count+1,sizeof(int));

	push	1219					; 000004c3H
	mov	DWORD PTR [edx+ecx*4], edi
	mov	eax, DWORD PTR [esi+12]
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	inc	eax
	push	4
	xor	ebx, ebx
	push	eax
	mov	DWORD PTR _c_top$[ebp], ebx
	call	_kb_temp_calloc
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+52], eax

; 1220 :   coarse_alloc = temp_IA[mg->fine->N];

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _temp_IA$[ebp]
	mov	edi, DWORD PTR [ecx+eax*4]

; 1221 :   mg->coarse->JA = (int*)temp_calloc(coarse_alloc,sizeof(int));

	push	1221					; 000004c5H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	4
	push	edi
	mov	DWORD PTR _coarse_alloc$[ebp], edi
	call	_kb_temp_calloc
	mov	edx, DWORD PTR [esi+4]

; 1222 :   mg->coarse->A = (REAL*)temp_calloc(coarse_alloc,sizeof(REAL));

	push	1222					; 000004c6H
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	8
	push	edi
	mov	DWORD PTR [edx+56], eax
	call	_kb_temp_calloc
	mov	ecx, DWORD PTR [esi+4]
	add	esp, 48					; 00000030H
	mov	DWORD PTR [ecx+60], eax

; 1223 :   for ( k = 0 ; k < mg->coarse_count ; k++ )

	mov	DWORD PTR _k$[ebp], ebx
	cmp	DWORD PTR [esi+12], ebx
	jle	$LN58@coarse_mat
$LL60@coarse_mat:

; 1224 :   { mg->coarse->IA[k] = c_base = c_top;

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx+52]
	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [eax+edx*4], ebx
	mov	ecx, DWORD PTR [esi+36]
	lea	eax, DWORD PTR [ecx+edx*4]

; 1225 :     for ( n = mg->interp_tr_IA[k] ; n < mg->interp_tr_IA[k+1] ; n++ )

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _c_base$[ebp], ebx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+4]
	jge	$LN59@coarse_mat
	npad	6
$LL152@coarse_mat:

; 1226 :     { int fn = mg->interp_tr_JA[n];

	mov	edx, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [edx+ecx*4]

; 1227 :       int j_spot = c_base;
; 1228 :       int m,mm;
; 1229 :       if ( c_top + mg->coarse->N >= coarse_alloc )

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR _c_base$[ebp]
	add	edx, ebx
	mov	DWORD PTR _fn$89831[ebp], eax
	cmp	edx, DWORD PTR _coarse_alloc$[ebp]
	jl	SHORT $LN150@coarse_mat

; 1230 :       { /* need more room */
; 1231 :         coarse_alloc *= 2;

	mov	eax, DWORD PTR _coarse_alloc$[ebp]
	add	eax, eax

; 1232 :         mg->coarse->JA = (int*)temp_realloc((char*)(mg->coarse->JA),
; 1233 :                                         coarse_alloc*sizeof(int));

	push	1233					; 000004d1H
	lea	edx, DWORD PTR [eax*4]
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	mov	DWORD PTR _coarse_alloc$[ebp], eax
	mov	eax, DWORD PTR [ecx+56]
	push	edx
	push	eax
	call	_kb_temp_realloc
	mov	ecx, DWORD PTR [esi+4]

; 1234 :         mg->coarse->A = (REAL*)temp_realloc((char*)(mg->coarse->A),
; 1235 :                                         coarse_alloc*sizeof(REAL));

	mov	edx, DWORD PTR _coarse_alloc$[ebp]
	mov	DWORD PTR [ecx+56], eax
	mov	ecx, DWORD PTR [esi+4]
	push	1235					; 000004d3H
	lea	eax, DWORD PTR [edx*8]
	mov	edx, DWORD PTR [ecx+60]
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	eax
	push	edx
	call	_kb_temp_realloc
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+60], eax
	mov	eax, DWORD PTR _fn$89831[ebp]
	add	esp, 32					; 00000020H
$LN150@coarse_mat:

; 1236 :       }
; 1237 :       for ( m = temp_IA[fn] ; m < temp_IA[fn+1] ; m++ )

	mov	edx, DWORD PTR _temp_IA$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [edx+eax*4+4]
	mov	DWORD PTR _m$89833[ebp], ecx
	mov	DWORD PTR tv2067[ebp], eax
	cmp	ecx, DWORD PTR [eax]
	jge	$LN56@coarse_mat
	lea	edx, DWORD PTR [ebx-1]
	mov	DWORD PTR tv3498[ebp], edx
	npad	3
$LL53@coarse_mat:

; 1238 :       { REAL prod = mg->interp_tr_A[n]*temp_A[m];

	mov	eax, DWORD PTR [esi+44]
	mov	edx, DWORD PTR _n$[ebp]
	fld	QWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR _temp_A$[ebp]

; 1239 :         int ck = temp_JA[m];

	mov	edx, DWORD PTR _temp_JA$[ebp]
	fmul	QWORD PTR [eax+ecx*8]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _ck$89846[ebp], ecx

; 1240 :         /* linear search up */
; 1241 :         for ( ; j_spot < c_top ; j_spot++ )

	cmp	edi, ebx
	jge	$LN257@coarse_mat

; 1238 :       { REAL prod = mg->interp_tr_A[n]*temp_A[m];

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax+56]
	lea	eax, DWORD PTR [edx+edi*4]
$LN50@coarse_mat:

; 1242 :         { if ( ck == mg->coarse->JA[j_spot] )

	mov	edx, DWORD PTR [eax]
	cmp	ecx, edx
	je	SHORT $LN105@coarse_mat

; 1245 :           }
; 1246 :           if ( ck > mg->coarse->JA[j_spot] )

	jle	SHORT $LN46@coarse_mat

; 1240 :         /* linear search up */
; 1241 :         for ( ; j_spot < c_top ; j_spot++ )

	inc	edi
	add	eax, 4
	cmp	edi, ebx
	jl	SHORT $LN50@coarse_mat

; 1300 :       { int ispot = temp_IA[row] + i;
; 1301 :         if ( col == temp_JA[ispot] )

	jmp	$LN153@coarse_mat
$LN105@coarse_mat:

; 1243 :           { mg->coarse->A[j_spot] += prod;

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax+60]
	fld	QWORD PTR [edx+edi*8]
	lea	eax, DWORD PTR [edx+edi*8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax]

; 1244 :             break;

	jmp	$LN153@coarse_mat
$LN46@coarse_mat:

; 1247 :              continue;
; 1248 :           /* have to make room */
; 1249 :           for ( mm = c_top-1 ; mm >= j_spot ; mm-- )

	mov	eax, DWORD PTR tv3498[ebp]
	cmp	eax, edi
	jl	$LN144@coarse_mat
	mov	edx, eax
	sub	edx, edi
	inc	edx
	cmp	edx, 4
	jl	$LN143@coarse_mat
	lea	edx, DWORD PTR [edi+3]
$LN133@coarse_mat:

; 1251 :             mg->coarse->A[mm+1] = mg->coarse->A[mm];

	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+56]
	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+eax*4+4], ebx
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+60]
	fld	QWORD PTR [ecx+eax*8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fstp	QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+56]
	mov	ebx, DWORD PTR [ecx+eax*4-4]
	mov	DWORD PTR [ecx+eax*4], ebx
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+60]
	fld	QWORD PTR [ecx+eax*8-8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+56]
	mov	ebx, DWORD PTR [ecx+eax*4-8]
	mov	DWORD PTR [ecx+eax*4-4], ebx
	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+60]
	fld	QWORD PTR [ecx+eax*8-16]
	sub	eax, 4
	fstp	QWORD PTR [ecx+eax*8+24]
	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+56]
	mov	ebx, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR [ecx+eax*4+8], ebx
	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+60]
	fld	QWORD PTR [ecx+eax*8+8]
	fstp	QWORD PTR [ecx+eax*8+16]
	cmp	eax, edx
	jge	SHORT $LN133@coarse_mat
	mov	ecx, DWORD PTR _ck$89846[ebp]
	mov	ebx, DWORD PTR _c_top$[ebp]
$LN143@coarse_mat:

; 1247 :              continue;
; 1248 :           /* have to make room */
; 1249 :           for ( mm = c_top-1 ; mm >= j_spot ; mm-- )

	cmp	eax, edi
	jl	SHORT $LN144@coarse_mat
$LC45@coarse_mat:
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [edx+56]

; 1250 :           { mg->coarse->JA[mm+1] = mg->coarse->JA[mm];

	mov	edx, DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+60]

; 1251 :             mg->coarse->A[mm+1] = mg->coarse->A[mm];

	fld	QWORD PTR [edx+eax*8]
	lea	ecx, DWORD PTR [edx+eax*8]
	dec	eax
	fstp	QWORD PTR [ecx+8]
	cmp	eax, edi
	jge	SHORT $LC45@coarse_mat

; 1247 :              continue;
; 1248 :           /* have to make room */
; 1249 :           for ( mm = c_top-1 ; mm >= j_spot ; mm-- )

	mov	ecx, DWORD PTR _ck$89846[ebp]
$LN144@coarse_mat:

; 1252 :           }
; 1253 :           mg->coarse->JA[j_spot] = ck;

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax+56]
	mov	DWORD PTR [edx+edi*4], ecx

; 1254 :           mg->coarse->A[j_spot] = prod;

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax+60]

; 1255 :           c_top++;

	inc	ebx
	fst	QWORD PTR [edx+edi*8]
	inc	DWORD PTR tv3498[ebp]
	mov	DWORD PTR _c_top$[ebp], ebx
$LN153@coarse_mat:

; 1256 :           break;
; 1257 :         }
; 1258 :         if ( j_spot == c_top )

	cmp	edi, ebx
$LN257@coarse_mat:
	jne	SHORT $LN218@coarse_mat

; 1259 :         { /* new one on top */
; 1260 :           mg->coarse->JA[c_top] = ck;

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax+56]
	mov	DWORD PTR [edx+ebx*4], ecx

; 1261 :           mg->coarse->A[c_top] = prod;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+60]
	fstp	QWORD PTR [ecx+ebx*8]

; 1262 :           c_top++;

	inc	ebx
	inc	DWORD PTR tv3498[ebp]
	mov	DWORD PTR _c_top$[ebp], ebx
	jmp	SHORT $LN52@coarse_mat
$LN218@coarse_mat:
	fstp	ST(0)
$LN52@coarse_mat:

; 1236 :       }
; 1237 :       for ( m = temp_IA[fn] ; m < temp_IA[fn+1] ; m++ )

	mov	ecx, DWORD PTR _m$89833[ebp]
	mov	edx, DWORD PTR tv2067[ebp]
	inc	ecx
	mov	DWORD PTR _m$89833[ebp], ecx
	cmp	ecx, DWORD PTR [edx]
	jl	$LL53@coarse_mat
$LN56@coarse_mat:

; 1225 :     for ( n = mg->interp_tr_IA[k] ; n < mg->interp_tr_IA[k+1] ; n++ )

	mov	ecx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [esi+36]
	mov	edx, DWORD PTR _k$[ebp]
	inc	ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+edx*4+4]
	jl	$LL152@coarse_mat
$LN59@coarse_mat:

; 1223 :   for ( k = 0 ; k < mg->coarse_count ; k++ )

	inc	edx
	mov	DWORD PTR _k$[ebp], edx
	cmp	edx, DWORD PTR [esi+12]
	jl	$LL60@coarse_mat
$LN58@coarse_mat:

; 1263 :         }
; 1264 :       }
; 1265 :     }
; 1266 :   }
; 1267 :   mg->coarse->IA[mg->coarse_count] = c_top;

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+ecx*4], ebx

; 1268 :   mg->coarse->N = mg->coarse_count;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]

; 1269 :   /* now sum with transpose and keep just upper triangle */
; 1270 :   /* count how many new upper spots might be needed */
; 1271 :   new_upper = (int*)temp_calloc(mg->coarse->N,sizeof(int));

	push	1271					; 000004f7H
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	4
	push	ecx
	call	_kb_temp_calloc

; 1272 :   for ( n = 0 ; n < mg->coarse->N ; n++ )

	mov	ecx, DWORD PTR [esi+4]
	xor	edi, edi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _new_upper$[ebp], eax
	cmp	DWORD PTR [ecx+4], edi
	jle	SHORT $LN139@coarse_mat
	npad	7
$LL41@coarse_mat:
	mov	edx, DWORD PTR [ecx+52]
	lea	ebx, DWORD PTR [edx+edi*4]

; 1273 :   { for ( j = mg->coarse->IA[n] ; j < mg->coarse->IA[n+1] ; j++ )

	mov	edx, DWORD PTR [ebx]
	cmp	edx, DWORD PTR [ebx+4]
	jge	SHORT $LN40@coarse_mat
	npad	3
$LL38@coarse_mat:

; 1274 :       if ( mg->coarse->JA[j] < n )

	mov	ecx, DWORD PTR [ecx+56]
	cmp	DWORD PTR [ecx+edx*4], edi
	jge	SHORT $LN35@coarse_mat

; 1275 :          new_upper[mg->coarse->JA[j]]++;

	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+56]
	mov	ecx, DWORD PTR [ecx+edx*4]
	inc	DWORD PTR [eax+ecx*4]
	lea	ecx, DWORD PTR [eax+ecx*4]

; 1276 :       else

	jmp	SHORT $LN37@coarse_mat
$LN35@coarse_mat:

; 1277 :          new_upper[n]++;

	inc	DWORD PTR [eax+edi*4]
$LN37@coarse_mat:

; 1273 :   { for ( j = mg->coarse->IA[n] ; j < mg->coarse->IA[n+1] ; j++ )

	mov	ecx, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [ecx+52]
	inc	edx
	cmp	edx, DWORD PTR [ebx+edi*4+4]
	jl	SHORT $LL38@coarse_mat
$LN40@coarse_mat:

; 1272 :   for ( n = 0 ; n < mg->coarse->N ; n++ )

	mov	ecx, DWORD PTR [esi+4]
	inc	edi
	cmp	edi, DWORD PTR [ecx+4]
	jl	SHORT $LL41@coarse_mat
$LN139@coarse_mat:

; 1278 :   }
; 1279 :    
; 1280 :   for ( n = 0 ; n < mg->coarse->N ; n++ )

	mov	ecx, DWORD PTR [esi+4]
	xor	edx, edx
	cmp	DWORD PTR [ecx+4], edx
	jle	SHORT $LN140@coarse_mat
	mov	ecx, DWORD PTR _temp_IA$[ebp]
	sub	eax, ecx
$LL33@coarse_mat:

; 1281 :     temp_IA[n+1] = temp_IA[n] + new_upper[n];

	mov	edi, DWORD PTR [eax+ecx]
	add	edi, DWORD PTR [ecx]
	inc	edx
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [esi+4]
	add	ecx, 4
	cmp	edx, DWORD PTR [edi+4]
	jl	SHORT $LL33@coarse_mat
$LN140@coarse_mat:

; 1282 :   for ( n = 0 ; n < mg->coarse->N ; n++ )

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax+4], 0
	mov	DWORD PTR _n$[ebp], 0
	jle	$LN142@coarse_mat
	fld	QWORD PTR __real@4000000000000000
$LN30@coarse_mat:
	mov	edx, DWORD PTR [eax+52]
	mov	ecx, DWORD PTR _n$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4]

; 1283 :     for ( j = mg->coarse->IA[n] ; j < mg->coarse->IA[n+1] ; j++ )

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _j$[ebp], edx
	cmp	edx, DWORD PTR [ecx+4]
	jge	$LN29@coarse_mat
$LN27@coarse_mat:

; 1284 :     { REAL val = mg->coarse->A[j];

	mov	ecx, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _j$[ebp]
	fld	QWORD PTR [edi+edx*8]

; 1285 :       int row,col;
; 1286 :       int i,m;
; 1287 :       if ( mg->coarse->JA[j] < n )

	mov	ecx, DWORD PTR [ecx+56]
	mov	edi, DWORD PTR _n$[ebp]
	cmp	DWORD PTR [ecx+edx*4], edi
	jge	SHORT $LN24@coarse_mat

; 1288 :       { /* add to transpose spot */
; 1289 :         row = mg->coarse->JA[j];

	mov	edx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR _j$[ebp]
	mov	edi, DWORD PTR [edx+eax*4]

; 1290 :         col = n;

	mov	ebx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _row$89876[ebp], edi
	mov	DWORD PTR _col$89877[ebp], ebx

; 1291 :       }
; 1292 :       else 

	jmp	SHORT $LN22@coarse_mat
$LN24@coarse_mat:

; 1293 :       { row = n;
; 1294 :         col = mg->coarse->JA[j];

	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _j$[ebp]
	mov	edi, DWORD PTR _n$[ebp]
	mov	ebx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _row$89876[ebp], edi
	mov	DWORD PTR _col$89877[ebp], ebx

; 1295 :         if ( row == col )

	cmp	edi, ebx
	jne	SHORT $LN22@coarse_mat

; 1296 :           val *= 2;

	fmul	ST(0), ST(1)
$LN22@coarse_mat:

; 1297 :       }
; 1298 :       /* now bubble up */
; 1299 :       for ( i = 0 ; i < temp_counts[row] ; i++ )

	mov	eax, DWORD PTR _temp_counts$[ebp]
	mov	eax, DWORD PTR [eax+edi*4]
	xor	ecx, ecx
	mov	DWORD PTR tv2285[ebp], eax
	test	eax, eax
	jle	SHORT $LN228@coarse_mat
	mov	edx, DWORD PTR _temp_IA$[ebp]
	mov	eax, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR _temp_JA$[ebp]
	lea	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv2289[ebp], eax
	mov	DWORD PTR tv3751[ebp], edx
	jmp	SHORT $LN21@coarse_mat
$LN146@coarse_mat:
	mov	eax, DWORD PTR tv2289[ebp]
$LN21@coarse_mat:

; 1300 :       { int ispot = temp_IA[row] + i;
; 1301 :         if ( col == temp_JA[ispot] )

	mov	edx, DWORD PTR tv3751[ebp]
	mov	edx, DWORD PTR [edx]
	add	eax, ecx
	mov	DWORD PTR _ispot$89886[ebp], eax
	cmp	ebx, edx
	je	$LN106@coarse_mat

; 1304 :         }
; 1305 :         if ( col > temp_JA[ispot] )

	jle	$LN17@coarse_mat

; 1297 :       }
; 1298 :       /* now bubble up */
; 1299 :       for ( i = 0 ; i < temp_counts[row] ; i++ )

	mov	eax, DWORD PTR _temp_counts$[ebp]
	add	DWORD PTR tv3751[ebp], 4
	inc	ecx
	cmp	ecx, DWORD PTR [eax+edi*4]
	jl	SHORT $LN146@coarse_mat
$LN228@coarse_mat:

; 1314 :         temp_A[ispot] = val;

	fstp	ST(0)
$LN26@coarse_mat:

; 1283 :     for ( j = mg->coarse->IA[n] ; j < mg->coarse->IA[n+1] ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax+52]
	mov	edi, DWORD PTR _n$[ebp]
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR [edx+edi*4+4]
	jl	$LN27@coarse_mat
$LN29@coarse_mat:

; 1282 :   for ( n = 0 ; n < mg->coarse->N ; n++ )

	mov	ecx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [esi+4]
	inc	ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+4]
	jl	$LN30@coarse_mat
	fstp	ST(0)
$LN142@coarse_mat:

; 1315 :         break;
; 1316 :       }
; 1317 :     }
; 1318 :  
; 1319 :   /* now compact back for final system */
; 1320 :   spot = 0;
; 1321 :   for ( n = 0 ; n < mg->coarse->N ; n++ )

	mov	eax, DWORD PTR [esi+4]
	xor	edx, edx
	xor	edi, edi
	mov	DWORD PTR _spot$[ebp], edx
	mov	DWORD PTR _n$[ebp], edi
	cmp	DWORD PTR [eax+4], edx
	jle	SHORT $LN11@coarse_mat
	mov	ecx, DWORD PTR _temp_counts$[ebp]
	mov	ebx, DWORD PTR _temp_IA$[ebp]
	sub	ebx, ecx
	mov	DWORD PTR tv4241[ebp], ebx
$LL13@coarse_mat:

; 1322 :   { mg->coarse->IA[n] = spot;

	mov	eax, DWORD PTR [eax+52]
	mov	DWORD PTR [eax+edi*4], edx

; 1323 :     for ( k = 0 ; k < temp_counts[n] ; k++ )

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	jle	SHORT $LN12@coarse_mat
	npad	2
$LL145@coarse_mat:

; 1324 :     { mg->coarse->JA[spot] = temp_JA[temp_IA[n]+k];

	mov	edx, DWORD PTR tv4241[ebp]
	mov	edx, DWORD PTR [edx+ecx]
	mov	edi, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR _temp_JA$[ebp]
	mov	edi, DWORD PTR [edi+56]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _spot$[ebp]
	mov	DWORD PTR [edi+ebx*4], edx

; 1325 :       mg->coarse->A[spot] = temp_A[temp_IA[n]+k];

	mov	edx, DWORD PTR tv4241[ebp]
	mov	edx, DWORD PTR [edx+ecx]
	mov	edi, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR _temp_A$[ebp]
	mov	edi, DWORD PTR [edi+60]
	add	edx, eax
	fld	QWORD PTR [ebx+edx*8]
	mov	edx, DWORD PTR _spot$[ebp]
	fstp	QWORD PTR [edi+edx*8]

; 1326 :       spot++;

	inc	edx
	inc	eax
	mov	DWORD PTR _spot$[ebp], edx
	cmp	eax, DWORD PTR [ecx]
	jl	SHORT $LL145@coarse_mat

; 1323 :     for ( k = 0 ; k < temp_counts[n] ; k++ )

	mov	edi, DWORD PTR _n$[ebp]
$LN12@coarse_mat:

; 1315 :         break;
; 1316 :       }
; 1317 :     }
; 1318 :  
; 1319 :   /* now compact back for final system */
; 1320 :   spot = 0;
; 1321 :   for ( n = 0 ; n < mg->coarse->N ; n++ )

	mov	eax, DWORD PTR [esi+4]
	inc	edi
	add	ecx, 4
	mov	DWORD PTR _n$[ebp], edi
	cmp	edi, DWORD PTR [eax+4]
	jl	SHORT $LL13@coarse_mat
$LN11@coarse_mat:

; 1327 :     }
; 1328 :   }
; 1329 :   mg->coarse->IA[mg->coarse->N] = spot;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+52]
	mov	DWORD PTR [eax+ecx*4], edx

; 1330 :    
; 1331 :   /* Fortran offset */
; 1332 :   if ( A_OFF )
; 1333 :   { int jtop = mg->coarse->IA[mg->coarse->N];

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [edx+ecx*4]

; 1334 :     for ( n = 0 ; n < mg->coarse->N ; n++ )

	mov	ecx, DWORD PTR [esi+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+4], eax
	jle	SHORT $LN4@coarse_mat
$LL6@coarse_mat:
	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+52]

; 1335 :       mg->coarse->IA[n] += A_OFF;

	inc	DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [esi+4]
	inc	eax
	cmp	eax, DWORD PTR [ecx+4]
	jl	SHORT $LL6@coarse_mat
$LN4@coarse_mat:

; 1336 :     for ( n = 0 ; n < jtop ; n++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN1@coarse_mat
	npad	4
$LL3@coarse_mat:
	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+56]

; 1337 :       mg->coarse->JA[n] += A_OFF;

	inc	DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL3@coarse_mat
$LN1@coarse_mat:

; 1338 :   }
; 1339 : 
; 1340 :  
; 1341 :   /* free unneeded memory */
; 1342 :   mg->coarse->JA = (int*)temp_realloc((char*)(mg->coarse->JA),
; 1343 :             mg->coarse->IA[mg->coarse->N]*sizeof(int));

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [eax+56]
	push	1343					; 0000053fH
	add	edx, edx
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	add	edx, edx
	push	edx
	push	eax
	call	_kb_temp_realloc
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+56], eax

; 1344 :   mg->coarse->A = (REAL*)temp_realloc((char*)(mg->coarse->A),
; 1345 :             mg->coarse->IA[mg->coarse->N]*sizeof(REAL));

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [eax+60]
	add	edx, edx
	push	1345					; 00000541H
	add	edx, edx
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	add	edx, edx
	push	edx
	push	eax
	call	_kb_temp_realloc

; 1346 :        
; 1347 : 
; 1348 :   temp_free((char*)temp_IA);

	mov	edx, DWORD PTR _temp_IA$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	mov	DWORD PTR [ecx+60], eax
	call	_temp_free

; 1349 :   temp_free((char*)temp_JA);

	mov	eax, DWORD PTR _temp_JA$[ebp]
	push	eax
	call	_temp_free

; 1350 :   temp_free((char*)temp_A);

	mov	ecx, DWORD PTR _temp_A$[ebp]
	push	ecx
	call	_temp_free

; 1351 :   temp_free((char*)temp_counts);

	mov	edx, DWORD PTR _temp_counts$[ebp]
	push	edx
	call	_temp_free

; 1352 :   temp_free((char*)new_upper);

	mov	eax, DWORD PTR _new_upper$[ebp]
	push	eax
	call	_temp_free
	add	esp, 52					; 00000034H
	pop	edi
	pop	esi
	pop	ebx

; 1353 :   
; 1354 : } /* end coarse_matrix() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN106@coarse_mat:

; 1302 :         { temp_A[ispot] += val;

	mov	ecx, DWORD PTR _temp_A$[ebp]
	fadd	QWORD PTR [ecx+eax*8]
	fstp	QWORD PTR [ecx+eax*8]

; 1303 :           break;

	jmp	$LN26@coarse_mat
$LN17@coarse_mat:

; 1306 :           continue;
; 1307 :         /* have to insert new one */
; 1308 :         for ( m = temp_IA[row] + temp_counts[row]-1 ; m > ispot ; m-- )

	mov	ecx, DWORD PTR tv2289[ebp]
	mov	edx, DWORD PTR tv2285[ebp]
	lea	edx, DWORD PTR [ecx+edx-1]
	cmp	edx, eax
	jle	$LN147@coarse_mat
	mov	ecx, edx
	sub	ecx, eax
	cmp	ecx, 4
	jl	SHORT $LN141@coarse_mat

; 1310 :           temp_A[m+1] = temp_A[m];

	mov	eax, DWORD PTR _temp_A$[ebp]
	mov	edi, edx
	sub	edi, DWORD PTR _ispot$89886[ebp]
	lea	ecx, DWORD PTR [eax+edx*8-8]
	mov	eax, DWORD PTR _temp_JA$[ebp]
	sub	edi, 4
	shr	edi, 2
	inc	edi
	mov	ebx, edi
	neg	ebx
	lea	eax, DWORD PTR [eax+edx*4-4]
	lea	edx, DWORD PTR [edx+ebx*4]
$LN136@coarse_mat:

; 1309 :         { temp_JA[m+1] = temp_JA[m];

	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], ebx

; 1310 :           temp_A[m+1] = temp_A[m];

	fld	QWORD PTR [ecx+8]
	fstp	QWORD PTR [ecx+16]
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ebx
	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [eax-4]
	mov	DWORD PTR [eax], ebx
	fld	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax-8]
	mov	DWORD PTR [eax-4], ebx
	fld	QWORD PTR [ecx-16]
	fstp	QWORD PTR [ecx-8]
	sub	eax, 16					; 00000010H
	sub	ecx, 32					; 00000020H
	dec	edi
	jne	SHORT $LN136@coarse_mat
	mov	eax, DWORD PTR _ispot$89886[ebp]
	mov	edi, DWORD PTR _row$89876[ebp]
	mov	ebx, DWORD PTR _col$89877[ebp]
$LN141@coarse_mat:
	mov	ecx, DWORD PTR _temp_JA$[ebp]
	cmp	edx, eax
	jle	SHORT $LN147@coarse_mat
$LC16@coarse_mat:

; 1309 :         { temp_JA[m+1] = temp_JA[m];

	mov	ebx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+edx*4+4], ebx

; 1310 :           temp_A[m+1] = temp_A[m];

	mov	ebx, DWORD PTR _temp_A$[ebp]
	fld	QWORD PTR [ebx+edx*8]
	dec	edx
	fstp	QWORD PTR [ebx+edx*8+16]
	cmp	edx, eax
	jg	SHORT $LC16@coarse_mat

; 1306 :           continue;
; 1307 :         /* have to insert new one */
; 1308 :         for ( m = temp_IA[row] + temp_counts[row]-1 ; m > ispot ; m-- )

	mov	ebx, DWORD PTR _col$89877[ebp]
$LN147@coarse_mat:

; 1311 :         }
; 1312 :         temp_counts[row]++;

	mov	ecx, DWORD PTR _temp_counts$[ebp]
	inc	DWORD PTR [ecx+edi*4]

; 1313 :         temp_JA[ispot] = col;

	mov	ecx, DWORD PTR _temp_JA$[ebp]

; 1314 :         temp_A[ispot] = val;

	mov	edx, DWORD PTR _temp_A$[ebp]
	mov	DWORD PTR [ecx+eax*4], ebx
	fstp	QWORD PTR [edx+eax*8]
	jmp	$LN26@coarse_mat
_coarse_matrix ENDP
_TEXT	ENDS
PUBLIC	_multigrid_cleanup
EXTRN	_free_system:PROC
; Function compile flags: /Ogtp
;	COMDAT _multigrid_cleanup
_TEXT	SEGMENT
_mgp$ = 8						; size = 4
_multigrid_cleanup PROC					; COMDAT

; 1365 : { struct multigrid_s *mg = *mgp;

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, DWORD PTR _mgp$[ebp]
	mov	esi, DWORD PTR [edi]

; 1366 : 
; 1367 :    free_system(mg->coarse);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	_free_system

; 1368 :    temp_free((char*)mg->marks); 

	mov	ecx, DWORD PTR [esi+8]
	push	ecx
	call	_temp_free

; 1369 :    temp_free((char*)mg->fine_to_coarse);

	mov	edx, DWORD PTR [esi+16]
	push	edx
	call	_temp_free

; 1370 :    temp_free((char*)mg->coarse_to_fine); 

	mov	eax, DWORD PTR [esi+20]
	push	eax
	call	_temp_free

; 1371 :    temp_free((char*)mg->interp_IA);

	mov	ecx, DWORD PTR [esi+24]
	push	ecx
	call	_temp_free

; 1372 :    temp_free((char*)mg->interp_JA);

	mov	edx, DWORD PTR [esi+28]
	push	edx
	call	_temp_free

; 1373 :    temp_free((char*)mg->interp_A);

	mov	eax, DWORD PTR [esi+32]
	push	eax
	call	_temp_free

; 1374 :    temp_free((char*)mg->interp_tr_IA);

	mov	ecx, DWORD PTR [esi+36]
	push	ecx
	call	_temp_free

; 1375 :    temp_free((char*)mg->interp_tr_JA);

	mov	edx, DWORD PTR [esi+40]
	push	edx
	call	_temp_free

; 1376 :    temp_free((char*)mg->interp_tr_A);

	mov	eax, DWORD PTR [esi+44]
	push	eax
	call	_temp_free

; 1377 :    temp_free((char*)mg->snbr_starts);

	mov	ecx, DWORD PTR [esi+48]
	push	ecx
	call	_temp_free

; 1378 :    temp_free((char*)mg->snbr_counts);

	mov	edx, DWORD PTR [esi+52]
	push	edx
	call	_temp_free

; 1379 :    temp_free((char*)mg->snbr_lists);

	mov	eax, DWORD PTR [esi+56]
	push	eax
	call	_temp_free

; 1380 :    temp_free((char*)mg->wnbr_asums); /* sums of weak neighbor coefficients */

	mov	ecx, DWORD PTR [esi+60]
	push	ecx
	call	_temp_free

; 1381 : 
; 1382 :   temp_free((char*)mg);

	push	esi
	call	_temp_free
	add	esp, 60					; 0000003cH

; 1383 :   *mgp = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 1384 : }

	pop	ebp
	ret	0
_multigrid_cleanup ENDP
_TEXT	ENDS
PUBLIC	_init_multigrid
; Function compile flags: /Ogtp
;	COMDAT _init_multigrid
_TEXT	SEGMENT
_fine$ = 8						; size = 4
_init_multigrid PROC					; COMDAT

; 710  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 711  :   /* Select coarse points by going through fine points in order,
; 712  :      and taking point as coarse point unless it has been marked
; 713  :      as a neighbor of a previously selected coarse point.
; 714  :   */
; 715  : 
; 716  :   struct multigrid_s *mg = (struct multigrid_s *)temp_calloc(1, 
; 717  :                                         sizeof(struct multigrid_s));

	push	717					; 000002cdH
	push	OFFSET ??_C@_06FIEBBMKD@TEIX?4C?$AA@
	push	64					; 00000040H
	push	1
	call	_kb_temp_calloc
	mov	esi, eax

; 718  : 
; 719  :   mg->fine = fine;

	mov	eax, DWORD PTR _fine$[ebp]
	mov	DWORD PTR [esi], eax

; 720  : 
; 721  :   /* Following algebraic multigrid method of Ruge & Stuben in
; 722  :      Multigrid Methods (1987) ed. McCormick, chapter 4 
; 723  :    */
; 724  : 
; 725  :   lambda_init();

	call	_lambda_init

; 726  : 
; 727  :   choose_coarse_points(mg);

	push	esi
	call	_choose_coarse_points

; 728  : 
; 729  :   interpolation_weights(mg);

	push	esi
	call	_interpolation_weights

; 730  : 
; 731  :   interpolation_transpose(mg);

	push	esi
	call	_interpolation_transpose

; 732  : 
; 733  :   coarse_matrix(mg);

	push	esi
	call	_coarse_matrix
	add	esp, 32					; 00000020H

; 734  :  
; 735  :   return mg;

	mov	eax, esi
	pop	esi

; 736  : 
; 737  : } /* end init_multigrid */

	pop	ebp
	ret	0
_init_multigrid ENDP
_TEXT	ENDS
PUBLIC	_do_multigrid
; Function compile flags: /Ogtp
;	COMDAT _do_multigrid
_TEXT	SEGMENT
_mg$ = -4						; size = 4
_S$ = 8							; size = 4
_do_multigrid PROC					; COMDAT

; 602  : { struct multigrid_s *mg;

	push	ebp
	mov	ebp, esp
	push	ecx

; 603  :   mg = init_multigrid(S);

	mov	eax, DWORD PTR _S$[ebp]
	push	eax
	call	_init_multigrid

; 604  :   multigrid_cleanup(&mg);

	lea	ecx, DWORD PTR _mg$[ebp]
	push	ecx
	mov	DWORD PTR _mg$[ebp], eax
	call	_multigrid_cleanup
	add	esp, 8

; 605  : } // end do_multigrid()

	mov	esp, ebp
	pop	ebp
	ret	0
_do_multigrid ENDP
_TEXT	ENDS
END
