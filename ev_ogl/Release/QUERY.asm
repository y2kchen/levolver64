; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\QUERY.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_commandverb:DWORD
_DATA	ENDS
PUBLIC	??_C@_0CL@IKGCHIJG@Command?5too?5long?5to?5save?5in?5hist@ ; `string'
PUBLIC	??_C@_07DAHICFKO@QUERY?4C?$AA@			; `string'
PUBLIC	_new_history
EXTRN	_history_number:DWORD
EXTRN	_kb_memmove:PROC
EXTRN	_kb_error:PROC
EXTRN	_history_count:DWORD
EXTRN	_history_offsets:BYTE
EXTRN	_list_calloc:PROC
EXTRN	_history_space:DWORD
;	COMDAT ??_C@_0CL@IKGCHIJG@Command?5too?5long?5to?5save?5in?5hist@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\query.c
CONST	SEGMENT
??_C@_0CL@IKGCHIJG@Command?5too?5long?5to?5save?5in?5hist@ DB 'Command to'
	DB	'o long to save in history list.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DAHICFKO@QUERY?4C?$AA@
CONST	SEGMENT
??_C@_07DAHICFKO@QUERY?4C?$AA@ DB 'QUERY.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _new_history
_TEXT	SEGMENT
_text$ = 8						; size = 4
_new_history PROC					; COMDAT

; 37   : { size_t length;

	push	ebp
	mov	ebp, esp

; 38   :   int k;
; 39   : 
; 40   :   if ( history_space == NULL )

	mov	edx, DWORD PTR _history_space
	push	esi
	push	edi
	test	edx, edx
	jne	SHORT $LN10@new_histor

; 41   :   { history_space = my_list_calloc(HISTORYSPACE,1,ETERNAL_BLOCK);

	push	41					; 00000029H
	push	OFFSET ??_C@_07DAHICFKO@QUERY?4C?$AA@
	push	60138					; 0000eaeaH
	push	1
	push	8000					; 00001f40H
	call	_list_calloc
	mov	edx, eax
	add	esp, 20					; 00000014H

; 42   :     for ( k = 0 ; k < MAXHISTORY ; k++ ) history_offsets[k] = -1; /* empty */

	mov	ecx, 100				; 00000064H
	or	eax, -1
	mov	edi, OFFSET _history_offsets
	mov	DWORD PTR _history_space, edx
	rep stosd

; 43   :     history_count = 0;

	mov	DWORD PTR _history_count, 0
$LN10@new_histor:

; 44   :   }
; 45   :   length = strlen(text)+1;

	mov	edi, DWORD PTR _text$[ebp]
	mov	eax, edi
	lea	esi, DWORD PTR [eax+1]
$LL19@new_histor:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL19@new_histor
	sub	eax, esi
	lea	esi, DWORD PTR [eax+1]

; 46   :   if ( length >= HISTORYSPACE-5 ) 

	cmp	esi, 7995				; 00001f3bH
	jb	SHORT $LN6@new_histor

; 47   :   { kb_error(1585,"Command too long to save in history list.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CL@IKGCHIJG@Command?5too?5long?5to?5save?5in?5hist@
	push	1585					; 00000631H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 61   : } // end new_history()

	pop	ebp
	ret	0
$LN6@new_histor:

; 48   :     return;
; 49   :   }
; 50   :   kb_memmove(history_space+length,history_space,HISTORYSPACE-length);

	mov	eax, 8000				; 00001f40H
	sub	eax, esi
	push	eax
	push	edx
	add	edx, esi
	push	edx
	call	_kb_memmove

; 51   :   for ( k = history_count-1 ; k >= 0 ; k-- )

	mov	edx, DWORD PTR _history_count
	lea	eax, DWORD PTR [edx-1]
	add	esp, 12					; 0000000cH
	test	eax, eax
	js	SHORT $LN3@new_histor
$LL5@new_histor:

; 52   :   { /* adjust pointers in history list */
; 53   :     history_offsets[k+1] = history_offsets[k] + (int)length;

	mov	ecx, DWORD PTR _history_offsets[eax*4]
	add	ecx, esi
	mov	DWORD PTR _history_offsets[eax*4+4], ecx

; 54   :     if ( history_offsets[k+1] >= HISTORYSPACE )

	cmp	ecx, 8000				; 00001f40H
	jl	SHORT $LN4@new_histor

; 55   :        { history_offsets[k+1] = -1; history_count--; }

	mov	DWORD PTR _history_offsets[eax*4+4], -1
	dec	edx
$LN4@new_histor:

; 51   :   for ( k = history_count-1 ; k >= 0 ; k-- )

	dec	eax
	jns	SHORT $LL5@new_histor

; 55   :        { history_offsets[k+1] = -1; history_count--; }

	mov	DWORD PTR _history_count, edx
$LN3@new_histor:

; 56   :   }
; 57   :   strcpy(history_space,text);

	mov	edx, DWORD PTR _history_space
	mov	ecx, edi
$LL13@new_histor:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL13@new_histor

; 58   :   history_offsets[0] = 0;
; 59   :   if ( history_count < MAXHISTORY-1 ) history_count++;

	cmp	DWORD PTR _history_count, 99		; 00000063H
	mov	DWORD PTR _history_offsets, 0
	jge	SHORT $LN21@new_histor
	inc	DWORD PTR _history_count
$LN21@new_histor:

; 60   :   history_number++;

	inc	DWORD PTR _history_number
	pop	edi
	pop	esi

; 61   : } // end new_history()

	pop	ebp
	ret	0
_new_history ENDP
_TEXT	ENDS
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	_catfulltext
EXTRN	_strncpy:PROC
EXTRN	_fulltext:BYTE
EXTRN	_fulltextsize:DWORD
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _catfulltext
_TEXT	SEGMENT
_stuff$ = 8						; size = 4
_catfulltext PROC					; COMDAT

; 122  : {

	push	ebp
	mov	ebp, esp

; 123  :   if ( fulltextsize > MAXCMDSIZE-3 ) return; /* too long */

	mov	edx, DWORD PTR _fulltextsize
	cmp	edx, 1997				; 000007cdH
	ja	$LN4@catfulltex

; 124  :   if ( fulltextsize > 0 ) 

	test	edx, edx
	je	SHORT $LN2@catfulltex

; 125  :      { strcat(fulltext,"  "); /* indentation */

	mov	eax, OFFSET _fulltext
	dec	eax
	npad	1
$LL6@catfulltex:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL6@catfulltex
	mov	cx, WORD PTR ??_C@_02KNHHEEKP@?5?5?$AA@
	mov	WORD PTR [eax], cx
	mov	cl, BYTE PTR ??_C@_02KNHHEEKP@?5?5?$AA@+2

; 126  :         fulltextsize += 2;

	add	edx, 2
	mov	BYTE PTR [eax+2], cl
	mov	DWORD PTR _fulltextsize, edx
$LN2@catfulltex:

; 127  :      }
; 128  :   strncpy(fulltext+fulltextsize,stuff,MAXCMDSIZE-fulltextsize);

	mov	ecx, DWORD PTR _stuff$[ebp]
	mov	eax, 2000				; 000007d0H
	sub	eax, edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR _fulltext[edx]
	push	edx
	call	_strncpy

; 129  :   fulltextsize = strlen(fulltext);

	mov	eax, OFFSET _fulltext
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL7@catfulltex:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL7@catfulltex
	sub	eax, edx

; 130  :   if ( fulltext[fulltextsize-1] != '\n' ) fulltext[fulltextsize++] = '\n';

	mov	cl, 10					; 0000000aH
	mov	DWORD PTR _fulltextsize, eax
	cmp	BYTE PTR _fulltext[eax-1], cl
	je	SHORT $LN1@catfulltex
	mov	BYTE PTR _fulltext[eax], cl
	inc	eax
	mov	DWORD PTR _fulltextsize, eax
$LN1@catfulltex:

; 131  :   fulltext[fulltextsize] = '\0';

	mov	BYTE PTR _fulltext[eax], 0
$LN4@catfulltex:

; 132  : 
; 133  : } // end catfulltext()

	pop	ebp
	ret	0
_catfulltext ENDP
_TEXT	ENDS
PUBLIC	_stack_usage
; Function compile flags: /Ogtp
;	COMDAT _stack_usage
_TEXT	SEGMENT
_ex$ = 8						; size = 4
_stack_usage PROC					; COMDAT

; 284  : { int usage = 0;

	push	ebp
	mov	ebp, esp
	push	esi

; 285  :   struct treenode *node ;
; 286  : #ifdef _DEBUG
; 287  :   int didwarn = 0;
; 288  : #endif
; 289  :   
; 290  :   ex->stack_max = 0;

	mov	esi, DWORD PTR _ex$[ebp]

; 291  :   for ( node = ex->start+1 ; node->type != FINISHED_NODE ; node++ )

	mov	eax, DWORD PTR [esi]
	xor	edx, edx
	add	eax, 168				; 000000a8H
	xor	ecx, ecx
	mov	DWORD PTR [esi+16], edx
	cmp	DWORD PTR [eax], 10386			; 00002892H
	je	SHORT $LN2@stack_usag
	npad	3
$LL4@stack_usag:

; 292  :   { usage += node->stack_delta;

	add	ecx, DWORD PTR [eax+156]

; 293  :     if ( usage > ex->stack_max ) ex->stack_max = usage;

	cmp	ecx, edx
	jle	SHORT $LN3@stack_usag
	mov	edx, ecx
	mov	DWORD PTR [esi+16], ecx
$LN3@stack_usag:

; 291  :   for ( node = ex->start+1 ; node->type != FINISHED_NODE ; node++ )

	add	eax, 168				; 000000a8H
	cmp	DWORD PTR [eax], 10386			; 00002892H
	jne	SHORT $LL4@stack_usag
$LN2@stack_usag:
	pop	esi

; 294  : #ifdef _DEBUG
; 295  :     if ( (usage < 0) && (!didwarn) ) 
; 296  :     { sprintf(errmsg,"Internal error: stack usage negative, %d, node type %d.\n",
; 297  :         usage,node->type);
; 298  :       sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 299  :          file_names[node->file_no],node->line_no);
; 300  :       kb_error(2670,errmsg,WARNING);
; 301  :       didwarn = 1;
; 302  :     }     
; 303  :     node->stack_spot = usage;
; 304  : #endif
; 305  :   }
; 306  : } // end stack_usage()

	pop	ebp
	ret	0
_stack_usage ENDP
_TEXT	ENDS
PUBLIC	_mark_element_loops
; Function compile flags: /Ogtp
;	COMDAT _mark_element_loops
_TEXT	SEGMENT
_root$ = 8						; size = 4
_mark$ = 12						; size = 4
_mark_element_loops PROC				; COMDAT

; 321  : { if ( mark ) 

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _root$[ebp]
	push	edi
	mov	edi, DWORD PTR _mark$[ebp]
	npad	5
$LL7@mark_eleme:
	test	edi, edi
	je	SHORT $LN4@mark_eleme

; 322  :     root->flags |= IN_ELEMENT_LOOP;

	or	DWORD PTR [esi+24], 2048		; 00000800H
	jmp	SHORT $LN3@mark_eleme
$LN4@mark_eleme:

; 323  :   else mark = root->flags & IN_ELEMENT_LOOP;

	mov	edi, DWORD PTR [esi+24]
	and	edi, 2048				; 00000800H
$LN3@mark_eleme:

; 324  : 
; 325  :   if ( root->left )

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN2@mark_eleme

; 326  :     mark_element_loops(root+root->left,mark);

	imul	eax, 168				; 000000a8H
	add	eax, esi
	push	edi
	push	eax
	call	_mark_element_loops
	add	esp, 8
$LN2@mark_eleme:

; 327  :   if ( root->right )

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN1@mark_eleme

; 328  :     mark_element_loops(root+root->right,mark);

	imul	eax, 168				; 000000a8H
	add	esi, eax
	jmp	SHORT $LL7@mark_eleme
$LN1@mark_eleme:
	pop	edi
	pop	esi

; 329  : } // end mark_element_loops()

	pop	ebp
	ret	0
_mark_element_loops ENDP
_TEXT	ENDS
PUBLIC	_commaize
EXTRN	_isdigit:PROC
; Function compile flags: /Ogtp
;	COMDAT _commaize
_TEXT	SEGMENT
tv236 = -8						; size = 4
_k$ = -4						; size = 4
_s$ = 8							; size = 4
_commaize PROC						; COMDAT

; 339  : { int n,k,groups,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 340  :   
; 341  :   k = (int)strlen(s);

	mov	ebx, DWORD PTR _s$[ebp]
	push	edi
	mov	edi, ebx
	lea	ecx, DWORD PTR [edi+1]
$LL28@commaize:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL28@commaize
	sub	edi, ecx

; 342  :   
; 343  :   while ( k > 0 )

	test	edi, edi
	jle	$LN24@commaize
	push	esi
$LL15@commaize:

; 344  :   {
; 345  :     /* find last digit */
; 346  :     for ( n = k; n > 0 ; n-- )

	mov	esi, edi
	test	edi, edi
	jle	SHORT $LN22@commaize
	npad	8
$LL13@commaize:

; 347  :       if ( isdigit(s[n]) ) break;

	movsx	eax, BYTE PTR [esi+ebx]
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN22@commaize

; 344  :   {
; 345  :     /* find last digit */
; 346  :     for ( n = k; n > 0 ; n-- )

	dec	esi
	test	esi, esi
	jg	SHORT $LL13@commaize
$LN22@commaize:

; 348  :     if ( !isdigit(s[n]) ) return;

	movsx	ecx, BYTE PTR [esi+ebx]
	push	ecx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN32@commaize

; 349  :     /* find first digit */
; 350  :     for ( k = n-1 ; k > 0 ; k-- )

	lea	edi, DWORD PTR [esi-1]
	mov	DWORD PTR _k$[ebp], edi
	test	edi, edi
	jle	SHORT $LN23@commaize
$LL8@commaize:

; 351  :       if ( !isdigit(s[k]) ) break;

	movsx	edx, BYTE PTR [edi+ebx]
	push	edx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN31@commaize

; 349  :     /* find first digit */
; 350  :     for ( k = n-1 ; k > 0 ; k-- )

	dec	edi
	test	edi, edi
	jg	SHORT $LL8@commaize
$LN31@commaize:
	mov	DWORD PTR _k$[ebp], edi
$LN23@commaize:

; 352  :     groups = (n-k-1)/3;

	mov	ecx, esi
	sub	ecx, edi
	dec	ecx
	mov	eax, 1431655766				; 55555556H
	imul	ecx
	mov	eax, edx
	shr	eax, 31					; 0000001fH

; 353  :     for ( j = k+1 ; j < n ; j++ )

	lea	ecx, DWORD PTR [edi+1]
	add	eax, edx
	cmp	ecx, esi
	jge	SHORT $LN2@commaize
$LL4@commaize:

; 354  :     { s[j-groups] = s[j];

	mov	edx, ecx
	sub	edx, eax
	mov	DWORD PTR tv236[ebp], ecx
	mov	cl, BYTE PTR [ecx+ebx]
	mov	BYTE PTR [edx+ebx], cl

; 355  :       if ( ((n-j+groups) % 4) == 0  )

	mov	ecx, DWORD PTR tv236[ebp]
	mov	edx, eax
	sub	edx, ecx
	add	edx, esi
	and	edx, -2147483645			; 80000003H
	jns	SHORT $LN33@commaize
	dec	edx
	or	edx, -4					; fffffffcH
	inc	edx
$LN33@commaize:
	jne	SHORT $LN3@commaize

; 356  :       { groups--;

	dec	eax

; 357  :         s[j-groups] = ',';

	mov	edx, ecx
	sub	edx, eax
	mov	BYTE PTR [edx+ebx], 44			; 0000002cH
$LN3@commaize:

; 353  :     for ( j = k+1 ; j < n ; j++ )

	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LL4@commaize
	mov	edi, DWORD PTR _k$[ebp]
$LN2@commaize:

; 342  :   
; 343  :   while ( k > 0 )

	test	edi, edi
	jg	$LL15@commaize
$LN32@commaize:
	pop	esi
$LN24@commaize:
	pop	edi
	pop	ebx

; 358  :       }
; 359  :     }
; 360  :   }
; 361  : } // end commaize()

	mov	esp, ebp
	pop	ebp
	ret	0
_commaize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DM@KGCNFMDL@Evaluation?5profiling?5not?5enabled@ ; `string'
PUBLIC	_print_profiling
EXTRN	_outstring:PROC
;	COMDAT ??_C@_0DM@KGCNFMDL@Evaluation?5profiling?5not?5enabled@
CONST	SEGMENT
??_C@_0DM@KGCNFMDL@Evaluation?5profiling?5not?5enabled@ DB 'Evaluation pr'
	DB	'ofiling not enabled; compile with PROF_EVALS.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _print_profiling
_TEXT	SEGMENT
_print_profiling PROC					; COMDAT

; 373  :   #ifdef PROF_EVALS
; 374  :   int i,k;
; 375  :   int do_flag = 0;
; 376  : 
; 377  :   outstring("\nExclusive profiling counts (i.e. not including children): \n");
; 378  :   outstring("                                  Name               Calls            CPU Cycles\n");
; 379  :   for ( i = 0 ; i < web.global_count ; i++ )
; 380  :   { struct global *g = globals(i);
; 381  :     if ( g->flags & (FUNCTION_NAME|PROCEDURE_NAME|SUBROUTINE) )
; 382  :     { if (g->value.proc.elapsed_time < 0.0 || g->value.proc.elapsed_time > 1e14 )
; 383  :        sprintf(msg,"  %36s     %15d  -- interrupted timing --\n",g->name,
; 384  :         g->value.proc.call_count);
; 385  :       else sprintf(msg,"  %36s     %15d  %20.f\n",g->name,
; 386  :         g->value.proc.call_count,g->value.proc.elapsed_time);
; 387  :       commaize(msg); 
; 388  :       outstring(msg);
; 389  :     }
; 390  :   }
; 391  : 
; 392  :   for ( i = 0, do_flag = 0; i < NUMELEMENTS ; i++ )
; 393  : 	if ( show_expr_table[i].root )
; 394  : 		do_flag = 1;
; 395  :   if ( do_flag )
; 396  :   {
; 397  :     outstring("\nElement show expressions:\n");
; 398  :     outstring("                   Element            CPU Cycles\n");
; 399  :     for ( i = 0 ; i < NUMELEMENTS ; i++ )
; 400  :     { sprintf(msg,"  %30s %15.f\n",typenames[i],show_expr_table[i].elapsed_time);
; 401  :       commaize(msg);
; 402  :       outstring(msg);
; 403  :     }
; 404  :   }
; 405  : 
; 406  :   for ( i = LOW_INST, do_flag = 0 ; i < meth_inst_count ; i++ )
; 407  :   { if ( METH_INSTANCE(i)->flags & Q_DELETED ) continue;
; 408  : 	if ( METH_INSTANCE(i)->expr[0] )
; 409  : 		  do_flag = 1;
; 410  :   }
; 411  : 
; 412  :   if ( do_flag )
; 413  :   {
; 414  :     outstring("\nMethod instance expressions:\n");
; 415  :     outstring("                     Method instance                CPU Cycles\n");
; 416  :     for ( i = LOW_INST; i < meth_inst_count ; i++ )
; 417  :     { REAL total_time = 0.0;
; 418  :       struct method_instance *mi = METH_INSTANCE(i);
; 419  :       if ( mi->flags & Q_DELETED ) continue;
; 420  : 	  for ( k = 0 ; k < MAXMEXPR ; k++ )
; 421  : 		if ( mi->expr[k] )
; 422  : 			total_time += mi->expr[k]->elapsed_time;
; 423  : 		else break;
; 424  :       sprintf(msg,"  %40s     %15.f\n",mi->name,total_time);
; 425  : 	  commaize(msg);
; 426  : 	  outstring(msg);
; 427  :     }
; 428  :   }
; 429  : 
; 430  :   for ( i = 0, do_flag = 0 ; i < web.bdrymax ; i++ )
; 431  : 	  if ( web.boundaries[i].coordf[0] )
; 432  : 		  do_flag = 1;
; 433  :   if ( do_flag )
; 434  :   { 
; 435  :     outstring("\nBoundary expressions:\n");
; 436  :     outstring("                    Boundary     Formula Cycles      Energy Cycles     Content Cycles\n");
; 437  :     for ( i = 0 ; i < web.bdrymax ; i++ )
; 438  :     { REAL coord_time = 0.0;
; 439  :       REAL energy_time = 0.0;
; 440  :       REAL content_time = 0.0;
; 441  :       struct boundary *b = web.boundaries + i;
; 442  : 
; 443  : 	  if ( !b->coordf[0] )
; 444  : 		continue;
; 445  : 	  for ( k = 0 ; k < SDIM ; k++ )
; 446  : 	  { if ( b->coordf[k] )
; 447  : 			coord_time += b->coordf[k]->elapsed_time;
; 448  : 	    if ( b->envect[k] )
; 449  : 			energy_time += b->envect[k]->elapsed_time;
; 450  : 	    if ( b->convect[k] )
; 451  : 			content_time += b->convect[k]->elapsed_time;
; 452  : 	  }	
; 453  :       sprintf(msg,"%30s    %15.f    %15.f    %15.f\n",b->name,coord_time,energy_time,content_time);
; 454  : 	  commaize(msg);
; 455  : 	  outstring(msg);
; 456  :     }
; 457  :   }
; 458  : 
; 459  :   for ( i = 0, do_flag = 0 ; i < web.maxcon ; i++ )
; 460  : 	  if ( get_constraint(i)->formula )
; 461  : 		  do_flag = 1;
; 462  :   if ( do_flag )
; 463  :   {
; 464  :     outstring("\nConstraint expressions\n");
; 465  :     outstring("                    Constraint     Formula Cycles      Energy Cycles     Content Cycles\n");
; 466  :     for ( i = 0 ; i < web.maxcon ; i++ )
; 467  :     { struct constraint *con = get_constraint(i);
; 468  :       REAL coord_time = 0.0;
; 469  :       REAL energy_time = 0.0;
; 470  : 	  REAL content_time = 0.0;
; 471  :     
; 472  : 	  if ( !con->formula ) 
; 473  : 		continue;
; 474  : 	  for ( k = 0 ; k < SDIM ; k++ )
; 475  : 	  { if ( con->formula )
; 476  : 			coord_time += con->formula->elapsed_time;
; 477  : 	    if ( con->envect[k] )
; 478  : 			energy_time += con->envect[k]->elapsed_time;
; 479  : 	    if ( con->convect[k] )
; 480  : 			content_time += con->convect[k]->elapsed_time;
; 481  : 	  }	
; 482  :       sprintf(msg,"%30s    %15.f    %15.f    %15.f\n",con->name,coord_time,energy_time,content_time);
; 483  : 	  commaize(msg);
; 484  : 	  outstring(msg);
; 485  :     }
; 486  :   }
; 487  :   #else
; 488  :   outstring("Evaluation profiling not enabled; compile with PROF_EVALS.\n");

	push	OFFSET ??_C@_0DM@KGCNFMDL@Evaluation?5profiling?5not?5enabled@
	call	_outstring
	pop	ecx

; 489  :   #endif
; 490  : } // end print_profiling()

	ret	0
_print_profiling ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_reset_profiling
EXTRN	_meth_inst_list:DWORD
EXTRN	_show_expr_table:BYTE
EXTRN	_localbase:DWORD
EXTRN	_dymem:DWORD
EXTRN	_web:BYTE
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _reset_profiling
_TEXT	SEGMENT
_reset_profiling PROC					; COMDAT

; 502  :   for ( i = 0 ; i < web.global_count ; i++ )

	fldz
	push	esi
	xor	esi, esi
	push	edi
	cmp	DWORD PTR _web+5540, esi
	jle	$LN28@reset_prof
	mov	edi, DWORD PTR _web+5652
	push	ebx
	mov	ebx, DWORD PTR _dymem
$LN30@reset_prof:

; 503  :   {
; 504  :     if ( globals(i)->flags & (FUNCTION_NAME|PROCEDURE_NAME|SUBROUTINE) )

	mov	edx, esi
	and	edx, -16777216				; ff000000H
	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN33@reset_prof
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN35@reset_prof
	mov	ebx, DWORD PTR _localbase
	mov	eax, esi
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR _dymem
	jmp	SHORT $LN34@reset_prof
$LN35@reset_prof:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN33@reset_prof
	mov	ecx, DWORD PTR _web+5656
	mov	eax, esi
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN34@reset_prof
$LN33@reset_prof:
	mov	eax, esi
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [ecx+ebx]
$LN34@reset_prof:
	test	DWORD PTR [ecx+192], 3145732		; 00300004H
	je	$LN29@reset_prof

; 505  :     { globals(i)->value.proc.elapsed_time = 0.0;

	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN39@reset_prof
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN41@reset_prof
	mov	edi, DWORD PTR _localbase
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edi]
	jmp	SHORT $LN40@reset_prof
$LN41@reset_prof:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN39@reset_prof
	mov	ecx, DWORD PTR _web+5656
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN40@reset_prof
$LN39@reset_prof:
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [ecx+ebx]
$LN40@reset_prof:
	fst	QWORD PTR [ecx+152]

; 506  :       globals(i)->value.proc.call_count = 0;

	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN45@reset_prof
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN47@reset_prof
	mov	edx, DWORD PTR _localbase
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN46@reset_prof
$LN47@reset_prof:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN45@reset_prof
	mov	ecx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN46@reset_prof
$LN45@reset_prof:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN46@reset_prof:
	mov	DWORD PTR [eax+160], 0
	mov	edi, DWORD PTR _web+5652
	mov	ebx, DWORD PTR _dymem
$LN29@reset_prof:

; 502  :   for ( i = 0 ; i < web.global_count ; i++ )

	inc	esi
	cmp	esi, DWORD PTR _web+5540
	jl	$LN30@reset_prof
	pop	ebx
$LN28@reset_prof:

; 507  :     }
; 508  :   }
; 509  :  
; 510  :     for ( i = 0 ; i < NUMELEMENTS ; i++ )
; 511  :     { show_expr_table[i].elapsed_time = 0.0;

	fst	QWORD PTR _show_expr_table+88

; 512  :     }
; 513  :   
; 514  :     for ( i = LOW_INST; i < meth_inst_count ; i++ )

	mov	esi, 1
	fst	QWORD PTR _show_expr_table+192
	fst	QWORD PTR _show_expr_table+296
	fst	QWORD PTR _show_expr_table+400
	fst	QWORD PTR _show_expr_table+504
	cmp	DWORD PTR _web+5560, esi
	jle	$LN21@reset_prof
	mov	edi, 524288				; 00080000H
$LN23@reset_prof:

; 515  :     { 
; 516  :       struct method_instance *mi = METH_INSTANCE(i);

	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 517  :       if ( mi->flags & Q_DELETED ) continue;

	test	DWORD PTR [eax+140], edi
	jne	SHORT $LN22@reset_prof

; 518  : 	  for ( k = 0 ; k < MAXMEXPR ; k++ )

	xor	edx, edx
	add	eax, 236				; 000000ecH
$LN19@reset_prof:

; 519  : 		if ( mi->expr[k] )

	mov	ecx, DWORD PTR [eax-4]
	test	ecx, ecx
	je	SHORT $LN22@reset_prof

; 520  : 			mi->expr[k]->elapsed_time = 0.0;

	fst	QWORD PTR [ecx+88]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN22@reset_prof
	fst	QWORD PTR [ecx+88]
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN22@reset_prof
	fst	QWORD PTR [ecx+88]
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN22@reset_prof
	fst	QWORD PTR [ecx+88]
	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN22@reset_prof
	fst	QWORD PTR [ecx+88]
	mov	ecx, DWORD PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN22@reset_prof
	fst	QWORD PTR [ecx+88]
	mov	ecx, DWORD PTR [eax+20]
	test	ecx, ecx
	je	SHORT $LN22@reset_prof
	fst	QWORD PTR [ecx+88]
	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN22@reset_prof
	fst	QWORD PTR [ecx+88]
	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN22@reset_prof
	add	edx, 9
	fst	QWORD PTR [ecx+88]
	add	eax, 36					; 00000024H
	cmp	edx, 18					; 00000012H
	jl	SHORT $LN19@reset_prof
$LN22@reset_prof:

; 512  :     }
; 513  :   
; 514  :     for ( i = LOW_INST; i < meth_inst_count ; i++ )

	inc	esi
	cmp	esi, DWORD PTR _web+5560
	jl	$LN23@reset_prof
$LN21@reset_prof:

; 521  : 		else break;
; 522  :     }
; 523  :   
; 524  :     for ( i = 0 ; i < web.bdrymax ; i++ )

	mov	esi, DWORD PTR _web+616
	xor	edi, edi
	cmp	DWORD PTR _web+768, edi
	jle	SHORT $LN12@reset_prof
	mov	eax, DWORD PTR _web+776
	xor	edx, edx
$LN84@reset_prof:

; 525  :     { 
; 526  :       struct boundary *b = web.boundaries + i;
; 527  : 
; 528  : 	  if ( !b->coordf[0] )

	cmp	DWORD PTR [edx+eax+48], 0
	je	SHORT $LN13@reset_prof

; 529  : 		continue;
; 530  : 	  for ( k = 0 ; k < SDIM ; k++ )

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN13@reset_prof
	lea	eax, DWORD PTR [edx+eax+72]
$LN10@reset_prof:

; 531  : 	  { b->coordf[k]->elapsed_time = 0.0;

	mov	esi, DWORD PTR [eax-24]
	fst	QWORD PTR [esi+88]

; 532  : 	    b->envect[k]->elapsed_time = 0.0;

	mov	esi, DWORD PTR [eax]
	fst	QWORD PTR [esi+88]

; 533  : 	    b->convect[k]->elapsed_time = 0.0;

	mov	esi, DWORD PTR [eax+24]
	fst	QWORD PTR [esi+88]
	mov	esi, DWORD PTR _web+616
	inc	ecx
	add	eax, 4
	cmp	ecx, esi
	jl	SHORT $LN10@reset_prof

; 529  : 		continue;
; 530  : 	  for ( k = 0 ; k < SDIM ; k++ )

	mov	eax, DWORD PTR _web+776
$LN13@reset_prof:

; 521  : 		else break;
; 522  :     }
; 523  :   
; 524  :     for ( i = 0 ; i < web.bdrymax ; i++ )

	inc	edi
	add	edx, 136				; 00000088H
	cmp	edi, DWORD PTR _web+768
	jl	SHORT $LN84@reset_prof
$LN12@reset_prof:

; 534  : 	  }	
; 535  :       
; 536  :     }
; 537  :   
; 538  : 
; 539  :   
; 540  :     for ( i = 0 ; i < web.maxcon ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _web+644, edi
	jle	SHORT $LN174@reset_prof
$LN85@reset_prof:

; 541  :     { struct constraint *con = get_constraint(i);

	mov	eax, edi
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 542  : 	  if ( !con->formula ) 

	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN6@reset_prof

; 543  : 		continue;
; 544  : 	  for ( k = 0 ; k < SDIM ; k++ )

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN6@reset_prof
	lea	ecx, DWORD PTR [eax+108]
$LN3@reset_prof:

; 545  : 	  { con->formula->elapsed_time = 0.0;

	mov	esi, DWORD PTR [eax+40]
	fst	QWORD PTR [esi+88]

; 546  : 	    con->envect[k]->elapsed_time = 0.0;

	mov	esi, DWORD PTR [ecx-60]
	fst	QWORD PTR [esi+88]

; 547  : 	    con->convect[k]->elapsed_time = 0.0;

	mov	esi, DWORD PTR [ecx]
	fst	QWORD PTR [esi+88]
	mov	esi, DWORD PTR _web+616
	inc	edx
	add	ecx, 4
	cmp	edx, esi
	jl	SHORT $LN3@reset_prof
$LN6@reset_prof:

; 534  : 	  }	
; 535  :       
; 536  :     }
; 537  :   
; 538  : 
; 539  :   
; 540  :     for ( i = 0 ; i < web.maxcon ; i++ )

	inc	edi
	cmp	edi, DWORD PTR _web+644
	jl	SHORT $LN85@reset_prof
$LN174@reset_prof:
	pop	edi

; 543  : 		continue;
; 544  : 	  for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
	pop	esi

; 548  : 	  }	
; 549  :     }
; 550  :   
; 551  : } // end reset_profiling()

	ret	0
_reset_profiling ENDP
_TEXT	ENDS
PUBLIC	_mark_recalc_expr
; Function compile flags: /Ogtp
;	COMDAT _mark_recalc_expr
_TEXT	SEGMENT
_ex$ = 8						; size = 4
_mark_recalc_expr PROC					; COMDAT

; 641  : { int count = 0 ;

	push	ebp
	mov	ebp, esp

; 642  :   struct treenode *node;
; 643  : 
; 644  :   if ( ex == NULL ) return 0;

	mov	edx, DWORD PTR _ex$[ebp]
	xor	eax, eax
	test	edx, edx
	jne	SHORT $LN8@mark_recal
$LN20@mark_recal:
	xor	eax, eax

; 657  :     }
; 658  : 
; 659  :   return count;
; 660  : } /* end mark_recalc_expr() */

	pop	ebp
	ret	0
$LN8@mark_recal:

; 645  :   if ( ex->start == NULL ) return 0;

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $LN20@mark_recal

; 646  : 
; 647  :   for ( node = ex->start ; node != ex->root ; node ++  )

	push	ebx
	mov	ebx, ecx
	cmp	ebx, DWORD PTR [edx+4]
	je	$LN4@mark_recal
	push	esi
	mov	esi, DWORD PTR _dymem
	push	edi
	mov	edi, DWORD PTR _web+5652
$LL6@mark_recal:

; 648  :     if ( node->type == PUSHGLOBAL_NODE )

	cmp	DWORD PTR [ebx], 10102			; 00002776H
	jne	SHORT $LN5@mark_recal

; 649  :     { struct global *g;
; 650  :       if ( (node->op1.name_id &(~GLOBMASK))==LOCALVAR )

	mov	ecx, DWORD PTR [ebx+32]
	mov	edx, ecx
	and	edx, -16777216				; ff000000H
	cmp	edx, 805306368				; 30000000H
	je	SHORT $LN5@mark_recal

; 651  :          continue; 
; 652  :       g = globals(node->op1.name_id);

	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN11@mark_recal
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN11@mark_recal
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN12@mark_recal
$LN11@mark_recal:
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+esi]
$LN12@mark_recal:

; 653  :       if ( g->flags & RECALC_PARAMETER )

	mov	edx, DWORD PTR [ecx+192]
	test	dl, 8
	jne	SHORT $LN5@mark_recal

; 654  :          continue;
; 655  :       g->flags |= RECALC_PARAMETER;

	or	edx, 8
	mov	DWORD PTR [ecx+192], edx

; 656  :       count ++;

	mov	esi, DWORD PTR _dymem
	mov	edi, DWORD PTR _web+5652
	inc	eax
$LN5@mark_recal:

; 646  : 
; 647  :   for ( node = ex->start ; node != ex->root ; node ++  )

	mov	edx, DWORD PTR _ex$[ebp]
	add	ebx, 168				; 000000a8H
	cmp	ebx, DWORD PTR [edx+4]
	jne	SHORT $LL6@mark_recal
	pop	edi
	pop	esi
$LN4@mark_recal:
	pop	ebx

; 657  :     }
; 658  : 
; 659  :   return count;
; 660  : } /* end mark_recalc_expr() */

	pop	ebp
	ret	0
_mark_recalc_expr ENDP
_TEXT	ENDS
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0BC@MDKLNFIF@Illegal?5command?4?6?$AA@	; `string'
PUBLIC	??_C@_07KMMNMMFF@command?$AA@			; `string'
PUBLIC	_text$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_command
EXTRN	_permlist:DWORD
EXTRN	_free_expr:PROC
EXTRN	_eval:PROC
EXTRN	_eval_stack_trace_spot:DWORD
EXTRN	_subshell_depth:DWORD
EXTRN	_exit_flag:DWORD
EXTRN	_calc_quant_flag:DWORD
EXTRN	_aggregate_depth:DWORD
EXTRN	_fprintf:PROC
EXTRN	_logfd:DWORD
EXTRN	_function_kludge_flag:DWORD
EXTRN	_exit_local_scope:PROC
EXTRN	_yybegin:PROC
EXTRN	_init_local_scope:PROC
EXTRN	_old_perm_global_count:DWORD
EXTRN	_old_global_count:DWORD
EXTRN	_verb_flag:DWORD
EXTRN	_local_nest_depth:DWORD
EXTRN	_local_scope_bases:BYTE
EXTRN	_myfree:PROC
EXTRN	_set_scope:PROC
EXTRN	_cmdbuf:BYTE
EXTRN	_begin_scope:PROC
EXTRN	_cmdptr:DWORD
EXTRN	_lists_flag:DWORD
EXTRN	_parse_error_flag:DWORD
EXTRN	_loopdepth:DWORD
EXTRN	_kb_calloc:PROC
EXTRN	_listtop:DWORD
EXTRN	_list:DWORD
EXTRN	_listmax:DWORD
EXTRN	_sprintf:PROC
EXTRN	_brace_depth:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__setjmp3:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MDKLNFIF@Illegal?5command?4?6?$AA@
CONST	SEGMENT
??_C@_0BC@MDKLNFIF@Illegal?5command?4?6?$AA@ DB 'Illegal command.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KMMNMMFF@command?$AA@
CONST	SEGMENT
??_C@_07KMMNMMFF@command?$AA@ DB 'command', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _command
_TEXT	SEGMENT
_old_list$ = -132					; size = 4
_old_listmax$ = -128					; size = 4
_old_brace_depth$ = -124				; size = 4
_old_listtop$ = -120					; size = 4
_text$GSCopy$ = -116					; size = 4
_old_scope$ = -112					; size = 4
_qnode$ = -108						; size = 104
__$ArrayPad$ = -4					; size = 4
_text$ = 8						; size = 4
_mode$ = 12						; size = 4
_command PROC						; COMDAT

; 149  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 150  :   struct expnode qnode;  /* for query expression */
; 151  :   int retval = 0;
; 152  :   int old_scope;
; 153  :   struct treenode *old_list;
; 154  :   int old_listtop, old_listmax;
; 155  :   int old_brace_depth = brace_depth;

	mov	eax, DWORD PTR _brace_depth
	push	ebx
	push	esi
	mov	esi, DWORD PTR _text$[ebp]
	push	edi

; 156  : 
; 157  :   memset(&qnode,0,sizeof(struct expnode));

	push	104					; 00000068H
	xor	ebx, ebx
	lea	ecx, DWORD PTR _qnode$[ebp]
	push	ebx
	push	ecx
	mov	DWORD PTR _text$GSCopy$[ebp], esi
	mov	DWORD PTR _old_brace_depth$[ebp], eax
	call	_memset

; 158  :   sprintf(qnode.name,"command");

	lea	edx, DWORD PTR _qnode$[ebp+20]
	push	OFFSET ??_C@_07KMMNMMFF@command?$AA@
	push	edx
	call	_sprintf

; 159  :  
; 160  :   old_listmax = listmax;

	mov	eax, DWORD PTR _listmax

; 161  :   old_list = list; old_listtop = listtop; /* for nested parsing */

	mov	ecx, DWORD PTR _list
	mov	edx, DWORD PTR _listtop

; 162  :   listmax = 30;
; 163  :   list = (struct treenode *)mycalloc(listmax,sizeof(struct treenode));

	push	163					; 000000a3H
	push	OFFSET ??_C@_07DAHICFKO@QUERY?4C?$AA@
	push	168					; 000000a8H
	push	30					; 0000001eH
	mov	DWORD PTR _old_listmax$[ebp], eax
	mov	DWORD PTR _old_list$[ebp], ecx
	mov	DWORD PTR _old_listtop$[ebp], edx
	mov	DWORD PTR _listmax, 30			; 0000001eH
	call	_kb_calloc
	mov	DWORD PTR _list, eax

; 164  :   list[1].type = SETUP_FRAME_NODE;

	mov	DWORD PTR [eax+168], 10001		; 00002711H

; 165  :   listtop = 2;

	mov	DWORD PTR _listtop, 2

; 166  :   loopdepth = 0;

	mov	DWORD PTR _loopdepth, ebx

; 167  :   parse_error_flag = 0;

	mov	DWORD PTR _parse_error_flag, ebx

; 168  :   lists_flag = 0;

	mov	DWORD PTR _lists_flag, ebx

; 169  :   cmdptr = text;

	mov	DWORD PTR _cmdptr, esi

; 170  :   old_scope = begin_scope();

	call	_begin_scope

; 171  : 
; 172  : 
; 173  : #ifdef __cplusplus
; 174  :   try
; 175  :   {
; 176  : #else
; 177  :   if ( setjmp(cmdbuf) )

	push	ebx
	push	OFFSET _cmdbuf
	mov	DWORD PTR _old_scope$[ebp], eax
	call	__setjmp3
	add	esp, 44					; 0000002cH
	test	eax, eax
	je	SHORT $LN13@command

; 178  :   { set_scope(old_scope);  

	mov	eax, DWORD PTR _old_scope$[ebp]
	push	eax
	call	_set_scope

; 179  :     cmdptr = NULL;  
; 180  :     myfree((char *)list); 

	mov	ecx, DWORD PTR _list
	push	ecx
	mov	DWORD PTR _cmdptr, ebx
	call	_myfree

; 181  :     list = NULL;
; 182  :     memset(local_scope_bases,0,sizeof(local_scope_bases));

	push	400					; 00000190H
	push	ebx
	push	OFFSET _local_scope_bases
	mov	DWORD PTR _list, ebx
	call	_memset
	add	esp, 20					; 00000014H

; 183  : 	local_nest_depth = 0;

	mov	DWORD PTR _local_nest_depth, ebx

; 208  :     return 0;  

	xor	eax, eax

; 260  : 
; 261  : #ifdef __cplusplus
; 262  :   }
; 263  :   catch(cmd_excep c)
; 264  :   { set_scope(old_scope);  
; 265  :     cmdptr = NULL;  
; 266  :     myfree((char *)list); 
; 267  :     list = NULL;
; 268  :     memset(local_scope_bases,0,sizeof(local_scope_bases));
; 269  : 	local_nest_depth = 0;
; 270  :     return 0; 
; 271  :   }
; 272  : #endif
; 273  : } // end command()

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@command:

; 184  :     return 0; 
; 185  :   }
; 186  : #endif
; 187  : 
; 188  :   verb_flag = 1; /* tell lex we need a verb first */
; 189  :   old_global_count = web.global_count; /* for error recovery */

	mov	edx, DWORD PTR _web+5540

; 190  :   old_perm_global_count = web.perm_global_count; /* for error recovery */

	mov	eax, DWORD PTR _web+5548

; 191  :   /* local_nest_depth = 0; */
; 192  :   init_local_scope(0,0);

	push	ebx
	push	ebx
	mov	DWORD PTR _verb_flag, 1
	mov	DWORD PTR _old_global_count, edx
	mov	DWORD PTR _old_perm_global_count, eax
	call	_init_local_scope

; 193  :   fulltextsize = 0; 
; 194  :   catfulltext(text);

	mov	ecx, DWORD PTR _text$GSCopy$[ebp]
	push	ecx
	mov	DWORD PTR _fulltextsize, ebx
	call	_catfulltext
	add	esp, 12					; 0000000cH

; 195  : 
; 196  :   retval = yybegin();  /* 0 for accept, 1 for error */

	call	_yybegin
	mov	esi, eax

; 197  :   qnode.locals = localbase;

	mov	eax, DWORD PTR _localbase
	mov	DWORD PTR _qnode$[ebp+8], eax

; 198  :   if ( localbase )

	cmp	eax, ebx
	je	SHORT $LN12@command

; 199  :     qnode.locals->flags |= LL_IN_USE;

	or	DWORD PTR [eax+20], 4
$LN12@command:

; 200  :   exit_local_scope();

	call	_exit_local_scope

; 201  : 
; 202  :   cmdptr = NULL;

	mov	DWORD PTR _cmdptr, ebx

; 203  : 
; 204  :   if ( (retval == 1) || (parse_error_flag) )

	cmp	esi, 1
	je	$LN10@command
	cmp	DWORD PTR _parse_error_flag, ebx
	jne	$LN10@command

; 209  :   }
; 210  : 
; 211  :   qnode.start=list;
; 212  :   qnode.root = list + listtop - 1;

	mov	eax, DWORD PTR _listtop
	mov	edi, DWORD PTR _list
	mov	edx, eax
	imul	edx, 168				; 000000a8H
	lea	ecx, DWORD PTR [edx+edi-168]
	mov	DWORD PTR _qnode$[ebp], edi
	mov	DWORD PTR _qnode$[ebp+4], ecx

; 213  :   if ( qnode.root->type == SETUP_FRAME_NODE ) /* empty command */

	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, 10001				; 00002711H
	jne	SHORT $LN8@command

; 214  :   { retval = 0;

	xor	esi, esi

; 215  :     goto command_exit;

	lea	edi, DWORD PTR [esi+1]
	jmp	$command_exit$89449
$LN8@command:

; 216  :   }
; 217  :   if ( qnode.root->type != CMDLIST_NODE )  /* expression or something */

	cmp	ecx, 10028				; 0000272cH
	je	SHORT $LN7@command

; 218  :      kb_error(1589,"Illegal command.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BC@MDKLNFIF@Illegal?5command?4?6?$AA@
	push	1589					; 00000635H
	call	_kb_error
	mov	edi, DWORD PTR _list
	mov	eax, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN7@command:

; 219  :   
; 220  : 
; 221  :   list[0] = list[listtop-1];  /* root also in first spot */

	imul	eax, 168				; 000000a8H
	lea	esi, DWORD PTR [eax+edi-168]
	mov	ecx, 42					; 0000002aH
	rep movsd

; 222  :   if ( list[0].left ) list[0].left += listtop - 1;

	mov	eax, DWORD PTR _list
	cmp	DWORD PTR [eax+4], ebx
	je	SHORT $LN6@command
	mov	ecx, DWORD PTR _listtop
	dec	ecx
	add	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _list
$LN6@command:

; 223  :   if ( list[0].right ) list[0].right += listtop - 1;

	cmp	DWORD PTR [eax+8], ebx
	je	SHORT $LN5@command
	mov	edx, DWORD PTR _listtop
	dec	edx
	add	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _list
$LN5@command:

; 224  : 
; 225  :   /* put DONE marker after root */
; 226  :   list[listtop++].type = FINISHED_NODE;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H

; 227  : 
; 228  :   /* figure stack usage */
; 229  :   stack_usage(&qnode);

	lea	edx, DWORD PTR _qnode$[ebp]
	mov	DWORD PTR [ecx+eax], 10386		; 00002892H
	mov	edi, 1
	add	DWORD PTR _listtop, edi
	push	edx
	call	_stack_usage
	add	esp, 4

; 230  : 
; 231  :   /* set element loop flag bit in nodes */
; 232  :   if ( !function_kludge_flag )

	cmp	DWORD PTR _function_kludge_flag, ebx
	jne	SHORT $LN4@command

; 233  :     mark_element_loops(&list[0],0);

	mov	eax, DWORD PTR _list
	push	ebx
	push	eax
	call	_mark_element_loops
	add	esp, 8
$LN4@command:

; 234  : 
; 235  :   if ( logfd ) 

	mov	eax, DWORD PTR _logfd
	cmp	eax, ebx
	je	SHORT $LN3@command

; 236  :   fprintf(logfd,"%s\n",text);

	mov	ecx, DWORD PTR _text$GSCopy$[ebp]
	push	ecx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN3@command:

; 237  : 
; 238  :   /* add to history list */
; 239  :   if ( mode == ADD_TO_HISTORY ) 

	cmp	DWORD PTR _mode$[ebp], edi
	jne	SHORT $LN2@command

; 240  :     new_history(fulltext);

	push	OFFSET _fulltext
	call	_new_history
	add	esp, 4
$LN2@command:

; 241  : 
; 242  :   /* initialize current element to NULLID */
; 243  :   aggregate_depth = 0; calc_quant_flag = 0;

	mov	DWORD PTR _aggregate_depth, ebx
	mov	DWORD PTR _calc_quant_flag, ebx

; 244  :   exit_flag = 0;

	mov	DWORD PTR _exit_flag, ebx

; 245  :   if ( subshell_depth == 0 ) 

	cmp	DWORD PTR _subshell_depth, ebx
	jne	SHORT $LN1@command

; 246  :     eval_stack_trace_spot = 0;

	mov	DWORD PTR _eval_stack_trace_spot, ebx
$LN1@command:

; 247  :   eval(&qnode,NULL,NULLID,NULL);

	push	ebx
	push	ebx
	lea	edx, DWORD PTR _qnode$[ebp]
	push	ebx
	push	edx
	call	_eval
	fstp	ST(0)

; 248  :   retval = exit_flag ? END_COMMANDS : 1;

	mov	esi, DWORD PTR _exit_flag
	add	esp, 16					; 00000010H
	neg	esi
	sbb	esi, esi
	and	esi, 1234551233				; 4995c1c1H
	add	esi, edi

; 249  :   exit_flag = 0;

	mov	DWORD PTR _exit_flag, ebx
$command_exit$89449:

; 250  : 
; 251  : command_exit:
; 252  :   qnode.flag = USERCOPY; /* so free_expr will work */
; 253  :   free_expr(&qnode); 

	lea	eax, DWORD PTR _qnode$[ebp]
	push	eax
	mov	DWORD PTR _qnode$[ebp+12], edi
	call	_free_expr

; 254  :   list = NULL;
; 255  :   set_scope(old_scope);

	mov	ecx, DWORD PTR _old_scope$[ebp]
	push	ecx
	mov	DWORD PTR _list, ebx
	call	_set_scope

; 256  :   list = old_list; listtop = old_listtop; /* for nested parsing */

	mov	edx, DWORD PTR _old_list$[ebp]
	mov	eax, DWORD PTR _old_listtop$[ebp]

; 257  :   listmax = old_listmax;

	mov	ecx, DWORD PTR _old_listmax$[ebp]
	mov	DWORD PTR _list, edx

; 258  :   brace_depth = old_brace_depth;

	mov	edx, DWORD PTR _old_brace_depth$[ebp]
	mov	DWORD PTR _listtop, eax
	add	esp, 8
	mov	DWORD PTR _listmax, ecx
	mov	DWORD PTR _brace_depth, edx

; 259  :   return retval;

	mov	eax, esi

; 260  : 
; 261  : #ifdef __cplusplus
; 262  :   }
; 263  :   catch(cmd_excep c)
; 264  :   { set_scope(old_scope);  
; 265  :     cmdptr = NULL;  
; 266  :     myfree((char *)list); 
; 267  :     list = NULL;
; 268  :     memset(local_scope_bases,0,sizeof(local_scope_bases));
; 269  : 	local_nest_depth = 0;
; 270  :     return 0; 
; 271  :   }
; 272  : #endif
; 273  : } // end command()

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@command:

; 205  :   { myfree((char *)list); 

	mov	eax, DWORD PTR _list
	push	eax
	call	_myfree

; 206  :     if ( list == permlist ) permlist = NULL;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	cmp	ecx, DWORD PTR _permlist
	jne	SHORT $LN9@command
	mov	DWORD PTR _permlist, ebx
$LN9@command:

; 207  :     list = NULL; set_scope(old_scope); 

	mov	edx, DWORD PTR _old_scope$[ebp]
	push	edx
	mov	DWORD PTR _list, ebx
	call	_set_scope

; 260  : 
; 261  : #ifdef __cplusplus
; 262  :   }
; 263  :   catch(cmd_excep c)
; 264  :   { set_scope(old_scope);  
; 265  :     cmdptr = NULL;  
; 266  :     myfree((char *)list); 
; 267  :     list = NULL;
; 268  :     memset(local_scope_bases,0,sizeof(local_scope_bases));
; 269  : 	local_nest_depth = 0;
; 270  :     return 0; 
; 271  :   }
; 272  : #endif
; 273  : } // end command()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 4
	pop	edi
	pop	esi
	xor	ecx, ebp
	xor	eax, eax
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_command ENDP
_TEXT	ENDS
PUBLIC	_mark_recalc_params
EXTRN	_gen_quant_list:DWORD
EXTRN	_show_expr:BYTE
EXTRN	_mobility_tensor_flag:DWORD
EXTRN	_mobility_formula:BYTE
EXTRN	_mobility_flag:DWORD
EXTRN	_torus_display_period_expr:BYTE
EXTRN	_torus_period_expr:BYTE
; Function compile flags: /Ogtp
;	COMDAT _mark_recalc_params
_TEXT	SEGMENT
tv433 = -16						; size = 8
tv406 = -16						; size = 8
_k$ = -12						; size = 4
tv956 = -8						; size = 4
tv994 = -4						; size = 4
tv637 = -4						; size = 4
tv603 = -4						; size = 4
tv568 = -4						; size = 4
_i$ = -4						; size = 4
_mark_recalc_params PROC				; COMDAT

; 562  : {

	push	ebp
	mov	ebp, esp

; 563  :   int n,i,k,j;
; 564  : 
; 565  :   /* Clear old recalc flags */
; 566  :   for ( n = 0 ; n < web.global_count ; n++ )

	xor	edx, edx
	sub	esp, 16					; 00000010H
	cmp	DWORD PTR _web+5540, edx
	jle	$LN56@mark_recal@2
$LL58@mark_recal@2:

; 567  :   { struct global *g = globals(n);

	mov	eax, edx
	and	eax, -16777216				; ff000000H
	cmp	eax, 268435456				; 10000000H
	je	SHORT $LN61@mark_recal@2
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN63@mark_recal@2
	mov	ecx, DWORD PTR _localbase
	mov	eax, edx
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN62@mark_recal@2
$LN63@mark_recal@2:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN61@mark_recal@2
	mov	ecx, DWORD PTR _web+5656
	mov	eax, edx
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN62@mark_recal@2
$LN61@mark_recal@2:
	mov	ecx, DWORD PTR _web+5652
	mov	eax, edx
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx]
$LN62@mark_recal@2:

; 568  :     if ( g->flags & ALWAYS_RECALC )

	mov	ecx, DWORD PTR [eax+192]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN55@mark_recal@2

; 569  :       g->flags |= RECALC_PARAMETER;

	or	ecx, 8

; 570  :     else

	jmp	SHORT $LN104@mark_recal@2
$LN55@mark_recal@2:

; 571  :       g->flags &= ~RECALC_PARAMETER;

	and	ecx, -9					; fffffff7H
$LN104@mark_recal@2:

; 563  :   int n,i,k,j;
; 564  : 
; 565  :   /* Clear old recalc flags */
; 566  :   for ( n = 0 ; n < web.global_count ; n++ )

	inc	edx

; 571  :       g->flags &= ~RECALC_PARAMETER;

	mov	DWORD PTR [eax+192], ecx
	cmp	edx, DWORD PTR _web+5540
	jl	$LL58@mark_recal@2
$LN56@mark_recal@2:

; 572  :   }
; 573  : 
; 574  :   /* Go through all expressions attached to various things. */
; 575  :   if ( torus_period_expr[0][0].root )

	cmp	DWORD PTR _torus_period_expr+4, 0

; 576  :    for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	push	ebx
	push	esi
	push	edi
	je	SHORT $LN50@mark_recal@2
	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN50@mark_recal@2
	xor	esi, esi
	mov	DWORD PTR tv568[ebp], esi
$LL102@mark_recal@2:

; 577  :      for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN51@mark_recal@2
	npad	3
$LL49@mark_recal@2:

; 578  :      { mark_recalc_expr(&torus_period_expr[i][j]);

	lea	edx, DWORD PTR _torus_period_expr[esi]
	push	edx
	call	_mark_recalc_expr

; 579  :        mark_recalc_expr(&torus_display_period_expr[i][j]);

	lea	eax, DWORD PTR _torus_display_period_expr[esi]
	push	eax
	call	_mark_recalc_expr
	mov	eax, DWORD PTR _web+616
	inc	edi
	add	esp, 8
	add	esi, 104				; 00000068H
	cmp	edi, eax
	jl	SHORT $LL49@mark_recal@2
$LN51@mark_recal@2:

; 576  :    for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR tv568[ebp]
	inc	ebx
	add	esi, 624				; 00000270H
	mov	DWORD PTR tv568[ebp], esi
	cmp	ebx, eax
	jl	SHORT $LL102@mark_recal@2
$LN50@mark_recal@2:

; 580  :      }
; 581  :   if ( mobility_flag ) mark_recalc_expr(&mobility_formula);

	cmp	DWORD PTR _mobility_flag, 0
	je	SHORT $LN46@mark_recal@2
	push	OFFSET _mobility_formula
	call	_mark_recalc_expr
	mov	eax, DWORD PTR _web+616
	add	esp, 4
$LN46@mark_recal@2:

; 582  :   if ( mobility_tensor_flag )

	cmp	DWORD PTR _mobility_tensor_flag, 0
	je	SHORT $LN42@mark_recal@2

; 583  :    for ( i = 0 ; i < SDIM ; i++ )

	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN42@mark_recal@2
	mov	edi, OFFSET _torus_period_expr
	mov	DWORD PTR tv603[ebp], edi
	npad	5
$LL100@mark_recal@2:

; 584  :     for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN43@mark_recal@2
$LL41@mark_recal@2:

; 585  :       mark_recalc_expr(&torus_period_expr[i][j]);

	push	edi
	call	_mark_recalc_expr
	mov	eax, DWORD PTR _web+616
	inc	esi
	add	esp, 4
	add	edi, 104				; 00000068H
	cmp	esi, eax
	jl	SHORT $LL41@mark_recal@2
$LN43@mark_recal@2:

; 583  :    for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR tv603[ebp]
	inc	ebx
	add	edi, 624				; 00000270H
	mov	DWORD PTR tv603[ebp], edi
	cmp	ebx, eax
	jl	SHORT $LL100@mark_recal@2
$LN42@mark_recal@2:

; 586  :   if ( web.metric_flag )

	cmp	DWORD PTR _web+1676, 0
	je	SHORT $LN35@mark_recal@2

; 587  :    for ( i = 0 ; i < SDIM ; i++ )

	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN35@mark_recal@2
	mov	edi, OFFSET _web+1688
	mov	DWORD PTR tv637[ebp], edi
$LL101@mark_recal@2:

; 588  :     for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN36@mark_recal@2
	npad	6
$LL34@mark_recal@2:

; 589  :       mark_recalc_expr(&web.metric[i][j]);

	push	edi
	call	_mark_recalc_expr
	mov	eax, DWORD PTR _web+616
	inc	esi
	add	esp, 4
	add	edi, 104				; 00000068H
	cmp	esi, eax
	jl	SHORT $LL34@mark_recal@2
$LN36@mark_recal@2:

; 587  :    for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR tv637[ebp]
	inc	ebx
	add	edi, 624				; 00000270H
	mov	DWORD PTR tv637[ebp], edi
	cmp	ebx, eax
	jl	SHORT $LL101@mark_recal@2
$LN35@mark_recal@2:

; 590  :   for ( i = 0 ; i < NUMELEMENTS ; i++ )

	mov	esi, OFFSET _show_expr
	npad	4
$LL31@mark_recal@2:

; 591  :     mark_recalc_expr(show_expr[i]);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	_mark_recalc_expr
	add	esi, 4
	add	esp, 4
	cmp	esi, OFFSET _show_expr+20
	jl	SHORT $LL31@mark_recal@2

; 592  :   for ( i = 0 ; i < web.bdrymax ; i++ )

	xor	ebx, ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	DWORD PTR _web+768, ebx
	jle	$LN26@mark_recal@2
	mov	esi, DWORD PTR _web+776
	npad	3
$LL28@mark_recal@2:

; 593  :   { struct boundary *b = web.boundaries + i;
; 594  :     if ( !(b->attr & IN_USE) ) continue;

	mov	ecx, DWORD PTR [ebx+esi+32]
	mov	edx, DWORD PTR [ebx+esi+36]
	mov	eax, ecx
	mov	DWORD PTR tv406[ebp+4], edx
	and	eax, 32					; 00000020H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN27@mark_recal@2

; 595  :     if ( b->attr & CON_ENERGY )

	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN27@mark_recal@2

; 596  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN27@mark_recal@2
	lea	esi, DWORD PTR [ebx+esi+72]
	npad	3
$LL23@mark_recal@2:

; 597  :       { mark_recalc_expr(b->coordf[j]);

	mov	eax, DWORD PTR [esi-24]
	push	eax
	call	_mark_recalc_expr

; 598  :         mark_recalc_expr(b->envect[j]);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	_mark_recalc_expr

; 599  :         mark_recalc_expr(b->convect[j]);

	mov	edx, DWORD PTR [esi+24]
	push	edx
	call	_mark_recalc_expr
	inc	edi
	add	esp, 12					; 0000000cH
	add	esi, 4
	cmp	edi, DWORD PTR _web+616
	jl	SHORT $LL23@mark_recal@2

; 596  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _web+776
$LN27@mark_recal@2:

; 592  :   for ( i = 0 ; i < web.bdrymax ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	ebx, 136				; 00000088H
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _web+768
	jl	SHORT $LL28@mark_recal@2
$LN26@mark_recal@2:

; 600  :       }
; 601  :   }
; 602  :   for ( i = 0 ; i < web.maxcon ; i++ )

	xor	ebx, ebx
	cmp	DWORD PTR _web+644, ebx
	jle	$LN18@mark_recal@2
$LL103@mark_recal@2:

; 603  :   { struct constraint *con = get_constraint(i);

	mov	esi, ebx
	and	esi, 1073741823				; 3fffffffH
	imul	esi, 176				; 000000b0H
	add	esi, DWORD PTR _web+652

; 604  :     if ( !(con->attr & IN_USE) ) continue;

	xor	edx, edx
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR tv433[ebp+4], eax
	mov	eax, ecx
	and	eax, 32					; 00000020H
	or	eax, edx
	je	SHORT $LN19@mark_recal@2

; 605  :     if ( con->attr & CON_ENERGY )

	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN19@mark_recal@2

; 606  :     { mark_recalc_expr(con->formula);

	mov	ecx, DWORD PTR [esi+40]
	push	ecx
	call	_mark_recalc_expr

; 607  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	add	esp, 4
	cmp	DWORD PTR _web+616, edi
	jle	SHORT $LN19@mark_recal@2

; 606  :     { mark_recalc_expr(con->formula);

	add	esi, 108				; 0000006cH
	npad	4
$LL15@mark_recal@2:

; 608  :       { mark_recalc_expr(con->envect[j]);

	mov	edx, DWORD PTR [esi-60]
	push	edx
	call	_mark_recalc_expr

; 609  :         mark_recalc_expr(con->convect[j]);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	_mark_recalc_expr
	inc	edi
	add	esp, 8
	add	esi, 4
	cmp	edi, DWORD PTR _web+616
	jl	SHORT $LL15@mark_recal@2
$LN19@mark_recal@2:

; 600  :       }
; 601  :   }
; 602  :   for ( i = 0 ; i < web.maxcon ; i++ )

	inc	ebx
	cmp	ebx, DWORD PTR _web+644
	jl	SHORT $LL103@mark_recal@2
$LN18@mark_recal@2:

; 610  :       }
; 611  :     }
; 612  :  }
; 613  : 
; 614  :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
	cmp	DWORD PTR _web+5560, ecx
	jle	$LN10@mark_recal@2
	npad	3
$LL12@mark_recal@2:

; 615  :   { struct method_instance * mi = METH_INSTANCE(k); /* since some init may move things */

	mov	eax, ecx
	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
	imul	edi, 2928				; 00000b70H
	add	edi, DWORD PTR _meth_inst_list

; 616  :     struct gen_quant *q;
; 617  :     if ( mi->flags & Q_DELETED ) continue;

	test	DWORD PTR [edi+140], 524288		; 00080000H
	jne	SHORT $LN11@mark_recal@2

; 618  :     for ( j = 0 ; j < MMAXQUANTS ; j++ )

	lea	ecx, DWORD PTR [edi+152]
	mov	DWORD PTR tv994[ebp], ecx
	mov	DWORD PTR tv956[ebp], 8
$LL8@mark_recal@2:

; 619  :     {
; 620  :       if ( mi->quants[j] == -1 ) 

	mov	edx, DWORD PTR tv994[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, -1
	je	SHORT $LN7@mark_recal@2

; 621  :        continue;
; 622  :       q = GEN_QUANT(mi->quants[j]);
; 623  :       if ( !(q->flags & Q_ENERGY) ) continue;

	mov	ecx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	test	BYTE PTR [eax+ecx+136], 1
	je	SHORT $LN7@mark_recal@2

; 624  :       for ( i = 0 ; i < MAXMEXPR ; i++ )

	lea	esi, DWORD PTR [edi+232]
	mov	ebx, 18					; 00000012H
	npad	4
$LL3@mark_recal@2:

; 625  :         mark_recalc_expr(mi->expr[i]);

	mov	edx, DWORD PTR [esi]
	push	edx
	call	_mark_recalc_expr
	add	esp, 4
	add	esi, 4
	dec	ebx
	jne	SHORT $LL3@mark_recal@2
$LN7@mark_recal@2:

; 618  :     for ( j = 0 ; j < MMAXQUANTS ; j++ )

	add	DWORD PTR tv994[ebp], 4
	dec	DWORD PTR tv956[ebp]
	jne	SHORT $LL8@mark_recal@2
	mov	ecx, DWORD PTR _k$[ebp]
$LN11@mark_recal@2:

; 610  :       }
; 611  :     }
; 612  :  }
; 613  : 
; 614  :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ecx, DWORD PTR _web+5560
	jl	$LL12@mark_recal@2
$LN10@mark_recal@2:
	pop	edi
	pop	esi
	pop	ebx

; 626  :     }
; 627  :   }
; 628  :  
; 629  : } /* end mark_recalc_params() */

	mov	esp, ebp
	pop	ebp
	ret	0
_mark_recalc_params ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0BP@JHNKFOKN@Command?5not?5found?5in?5history?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@FPMEKCKH@Command?5not?5in?5history?5list?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@NNBDBJCB@History?5list?5is?5empty?4?6?$AA@ ; `string'
PUBLIC	_old_history
EXTRN	_strncmp:PROC
EXTRN	_atoi:PROC
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JHNKFOKN@Command?5not?5found?5in?5history?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@JHNKFOKN@Command?5not?5found?5in?5history?4?6?$AA@ DB 'Command '
	DB	'not found in history.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FPMEKCKH@Command?5not?5in?5history?5list?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@FPMEKCKH@Command?5not?5in?5history?5list?4?6?$AA@ DB 'Command n'
	DB	'ot in history list.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NNBDBJCB@History?5list?5is?5empty?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@NNBDBJCB@History?5list?5is?5empty?4?6?$AA@ DB 'History list is '
	DB	'empty.', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _old_history
_TEXT	SEGMENT
_k$ = 8							; size = 4
_text$ = 8						; size = 4
_old_history PROC					; COMDAT

; 72   : { char *h;

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 73   :   int k;
; 74   :   int hnum;
; 75   :   int  retval = 0;
; 76   : 
; 77   :   if ( history_space == NULL )

	xor	esi, esi
	push	edi
	cmp	DWORD PTR _history_space, esi
	jne	SHORT $LN28@old_histor

; 78   :     { history_space = my_list_calloc(HISTORYSPACE,1,ETERNAL_BLOCK);

	push	78					; 0000004eH
	push	OFFSET ??_C@_07DAHICFKO@QUERY?4C?$AA@
	push	60138					; 0000eaeaH
	push	1
	push	8000					; 00001f40H
	call	_list_calloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _history_space, eax

; 79   :       for ( k = 0 ; k < MAXHISTORY ; k++ ) history_offsets[k] = -1; /* empty */

	mov	ecx, 100				; 00000064H
	or	eax, -1
	mov	edi, OFFSET _history_offsets
	rep stosd

; 80   :       history_count = 0;

	mov	DWORD PTR _history_count, esi
$LN28@old_histor:

; 81   :     }
; 82   : 
; 83   :   if (text[1] == '!' ) 

	mov	ebx, DWORD PTR _text$[ebp]
	mov	al, BYTE PTR [ebx+1]
	inc	ebx
	cmp	al, 33					; 00000021H
	jne	SHORT $LN13@old_histor

; 84   :     {
; 85   :       if ( history_count > 0 ) 

	cmp	DWORD PTR _history_count, esi
	jle	SHORT $LN12@old_histor

; 86   :       { k = 0; goto do_old;

	mov	DWORD PTR _k$[ebp], esi
	jmp	$do_old$89397
$LN12@old_histor:

; 87   :       }
; 88   :       else { kb_error(1586,"History list is empty.\n",WARNING); return retval; }

	push	2
	push	OFFSET ??_C@_0BI@NNBDBJCB@History?5list?5is?5empty?4?6?$AA@
	push	1586					; 00000632H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 111  :   return retval;
; 112  : } // end old_history()

	pop	ebp
	ret	0
$LN13@old_histor:

; 89   : 
; 90   :     }
; 91   :   else if ( isdigit(text[1]) )

	movsx	eax, al
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@old_histor

; 92   :      { hnum = atoi(text+1);

	push	ebx
	call	_atoi

; 93   :        k = history_number - hnum;

	mov	ecx, DWORD PTR _history_number
	add	esp, 4
	sub	ecx, eax
	mov	DWORD PTR _k$[ebp], ecx

; 94   :        if ( (k >= 0) && (k < history_count) )

	js	SHORT $LN8@old_histor
	cmp	ecx, DWORD PTR _history_count
	jl	$do_old$89397
$LN8@old_histor:

; 95   :           goto do_old;
; 96   :        else kb_error(1587,"Command not in history list.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BO@FPMEKCKH@Command?5not?5in?5history?5list?4?6?$AA@
	push	1587					; 00000633H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 97   :      }
; 98   :   else for ( k = 0 ; k < history_count ; k++ )

	jmp	SHORT $LN30@old_histor
$LN9@old_histor:
	mov	DWORD PTR _k$[ebp], esi
	cmp	DWORD PTR _history_count, esi
	jle	SHORT $LN30@old_histor
	npad	2
$LL5@old_histor:

; 99   :      { h = history_space+history_offsets[k]; 

	mov	ecx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _history_offsets[ecx*4]
	add	esi, DWORD PTR _history_space

; 100  :        if ( strlen(h) < strlen(text+1) ) continue; /* prevent compare overrun */

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$LL25@old_histor:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL25@old_histor
	mov	ecx, ebx
	sub	eax, edx
	lea	edi, DWORD PTR [ecx+1]
$LL26@old_histor:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL26@old_histor
	sub	ecx, edi
	cmp	eax, ecx
	jb	SHORT $LN4@old_histor

; 101  :        if ( strncmp(h,text+1,strlen(text+1)) == 0 )

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL27@old_histor:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL27@old_histor
	sub	eax, edx
	push	eax
	push	ebx
	push	esi
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $do_old$89397
$LN4@old_histor:

; 97   :      }
; 98   :   else for ( k = 0 ; k < history_count ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _history_count
	jl	SHORT $LL5@old_histor
$LN30@old_histor:

; 102  :           goto do_old;
; 103  :      }
; 104  :   kb_error(1588,"Command not found in history.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BP@JHNKFOKN@Command?5not?5found?5in?5history?4?6?$AA@
	push	1588					; 00000634H
	call	_kb_error
	add	esp, 12					; 0000000cH
$do_old$89397:

; 105  : 
; 106  : 
; 107  : do_old:
; 108  :   h = history_space + history_offsets[k];

	mov	edx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _history_offsets[edx*4]
	add	esi, DWORD PTR _history_space

; 109  :   outstring(h);outstring("\n");

	push	esi
	call	_outstring
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring

; 110  :   retval = command(h,ADD_TO_HISTORY);  /* reinserts fulltext copy in history list */

	push	1
	push	esi
	call	_command
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 111  :   return retval;
; 112  : } // end old_history()

	pop	ebp
	ret	0
_old_history ENDP
_TEXT	ENDS
END
