; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\STORAGE.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BE@HJDEGBFN@facetedge_order_key?$AA@	; `string'
PUBLIC	??_C@_0P@FHMLCHPB@body_order_key?$AA@		; `string'
PUBLIC	??_C@_0BA@HOMCKIBP@facet_order_key?$AA@		; `string'
PUBLIC	??_C@_0P@DHCKNPLF@edge_order_key?$AA@		; `string'
PUBLIC	??_C@_0BB@OCLEPBGF@vertex_order_key?$AA@	; `string'
PUBLIC	_NULLVERTEX
PUBLIC	_NULLEDGE
PUBLIC	_NULLFACET
PUBLIC	_NULLBODY
PUBLIC	_NULLFACETEDGE
_DATA	SEGMENT
COMM	_bibase:DWORD
COMM	_blockcount:DWORD:05H
COMM	_vibase:DWORD
COMM	_web:BYTE:01648H
COMM	_feibase:DWORD
COMM	_eibase:DWORD
COMM	_elements_predicted:DWORD:05H
COMM	_blockmax:DWORD:05H
COMM	_blocklist:DWORD:05H
COMM	_fibase:DWORD
COMM	_sparse_ibase_flag:DWORD
_DATA	ENDS
_BSS	SEGMENT
_NULLVERTEX DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BE@HJDEGBFN@facetedge_order_key?$AA@
CONST	SEGMENT
??_C@_0BE@HJDEGBFN@facetedge_order_key?$AA@ DB 'facetedge_order_key', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FHMLCHPB@body_order_key?$AA@
CONST	SEGMENT
??_C@_0P@FHMLCHPB@body_order_key?$AA@ DB 'body_order_key', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HOMCKIBP@facet_order_key?$AA@
CONST	SEGMENT
??_C@_0BA@HOMCKIBP@facet_order_key?$AA@ DB 'facet_order_key', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DHCKNPLF@edge_order_key?$AA@
CONST	SEGMENT
??_C@_0P@DHCKNPLF@edge_order_key?$AA@ DB 'edge_order_key', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OCLEPBGF@vertex_order_key?$AA@
CONST	SEGMENT
??_C@_0BB@OCLEPBGF@vertex_order_key?$AA@ DB 'vertex_order_key', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_NULLEDGE DD	020000000H
_NULLFACET DD	040000000H
_NULLBODY DD	060000000H
_NULLFACETEDGE DD 080000000H
_keynames DD	FLAT:??_C@_0BB@OCLEPBGF@vertex_order_key?$AA@
	DD	FLAT:??_C@_0P@DHCKNPLF@edge_order_key?$AA@
	DD	FLAT:??_C@_0BA@HOMCKIBP@facet_order_key?$AA@
	DD	FLAT:??_C@_0P@FHMLCHPB@body_order_key?$AA@
	DD	FLAT:??_C@_0BE@HJDEGBFN@facetedge_order_key?$AA@
_DATA	ENDS
PUBLIC	_get_fe_edge
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_extra_ptr
; Function compile flags: /Ogtp
;	COMDAT _get_extra_ptr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_ext$ = 12						; size = 4
_get_extra_ptr PROC					; COMDAT

; 363  : { 

	push	ebp
	mov	ebp, esp

; 364  :   return ( (char*)elptr(id) + ext->offset);

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _ext$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, DWORD PTR [ecx+64]

; 365  : }

	pop	ebp
	ret	0
_get_extra_ptr ENDP
_TEXT	ENDS
PUBLIC	_get_meth_offset
; Function compile flags: /Ogtp
;	COMDAT _get_meth_offset
_TEXT	SEGMENT
_type$ = 8						; size = 4
_get_meth_offset PROC					; COMDAT

; 376  : { int meth_offset;

	push	ebp
	mov	ebp, esp

; 377  :   meth_offset = EXTRAS(type)[web.meth_attr[type]].offset; 

	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR _web[eax*4+5664]
	imul	eax, 112				; 00000070H

; 378  :   return meth_offset;

	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR [ecx+edx+64]

; 379  : }

	pop	ebp
	ret	0
_get_meth_offset ENDP
_TEXT	ENDS
PUBLIC	_oid
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\storage.c
;	COMDAT _oid
_TEXT	SEGMENT
_id$ = 8						; size = 4
_oid	PROC						; COMDAT

; 61   : { return inverted(id) ? -(ordinal(id)+1) : (ordinal(id) +1) ;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN7@oid
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@oid
	and	eax, 134217727				; 07ffffffH
	mov	ecx, eax
	or	eax, -1
	sub	eax, ecx

; 62   : }

	pop	ebp
	ret	0
$LN3@oid:

; 61   : { return inverted(id) ? -(ordinal(id)+1) : (ordinal(id) +1) ;

	or	ecx, -1
	or	eax, ecx
	sub	eax, ecx

; 62   : }

	pop	ebp
	ret	0
$LN7@oid:

; 61   : { return inverted(id) ? -(ordinal(id)+1) : (ordinal(id) +1) ;

	test	eax, 268435456				; 10000000H
	je	SHORT $LN5@oid
	and	eax, 134217727				; 07ffffffH
	inc	eax

; 62   : }

	pop	ebp
	ret	0
$LN5@oid:

; 61   : { return inverted(id) ? -(ordinal(id)+1) : (ordinal(id) +1) ;

	or	eax, -1
	inc	eax

; 62   : }

	pop	ebp
	ret	0
_oid	ENDP
_TEXT	ENDS
PUBLIC	_Vptr
; Function compile flags: /Ogtp
;	COMDAT _Vptr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_Vptr	PROC						; COMDAT

; 71   : struct vertex * Vptr(id) vertex_id id; { return vptr(id); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	0
_Vptr	ENDP
_TEXT	ENDS
PUBLIC	_Eptr
; Function compile flags: /Ogtp
;	COMDAT _Eptr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_Eptr	PROC						; COMDAT

; 72   : struct edge * Eptr(id) edge_id id; { return eptr(id); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	0
_Eptr	ENDP
_TEXT	ENDS
PUBLIC	_Fptr
; Function compile flags: /Ogtp
;	COMDAT _Fptr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_Fptr	PROC						; COMDAT

; 73   : struct facet * Fptr(id) facet_id id; { return fptr(id); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	0
_Fptr	ENDP
_TEXT	ENDS
PUBLIC	_Bptr
; Function compile flags: /Ogtp
;	COMDAT _Bptr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_Bptr	PROC						; COMDAT

; 74   : struct body * Bptr(id) body_id id; { return bptr(id); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	0
_Bptr	ENDP
_TEXT	ENDS
PUBLIC	_Feptr
; Function compile flags: /Ogtp
;	COMDAT _Feptr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_Feptr	PROC						; COMDAT

; 75   : struct facetedge * Feptr(id) facetedge_id id; { return feptr(id); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	0
_Feptr	ENDP
_TEXT	ENDS
PUBLIC	??_C@_09EOIFBANE@STORAGE?4C?$AA@		; `string'
PUBLIC	_expand
EXTRN	_parallel_update_flag:BYTE
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	_myfree:PROC
EXTRN	_kb_calloc:PROC
EXTRN	__imp__MsgWaitForMultipleObjects@20:PROC
EXTRN	_graphmutex:DWORD
EXTRN	_locking_thread:DWORD
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_09EOIFBANE@STORAGE?4C?$AA@
CONST	SEGMENT
??_C@_09EOIFBANE@STORAGE?4C?$AA@ DB 'STORAGE.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _expand
_TEXT	SEGMENT
tv228 = -32						; size = 4
_newblock$ = -28					; size = 4
tv227 = -24						; size = 4
_did_graphlock_here$89091 = -20				; size = 4
_n$ = -16						; size = 4
_copysize$ = -12					; size = 4
tv333 = -8						; size = 4
_newptr$ = -4						; size = 4
_type$ = 8						; size = 4
_newsize$ = 12						; size = 4
_expand	PROC						; COMDAT

; 88   : { char *newblock,*oldblock;

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 89   :   int oldsize = web.sizes[type];

	mov	esi, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR _web[esi*4+560]
	push	edi

; 90   :   int count = web.skel[type].maxcount;
; 91   :   int i,n;                                   
; 92   :   char *newptr,*oldptr;
; 93   :   int copysize;
; 94   : 
; 95   :   /* round up newsize to alignment for doubles */
; 96   :   newsize = ((newsize+sizeof(REAL)-1)/sizeof(REAL))*sizeof(REAL);

	mov	edi, DWORD PTR _newsize$[ebp]
	add	edi, 7
	mov	eax, esi
	imul	eax, 112				; 00000070H
	shr	edi, 3
	add	edi, edi
	add	edi, edi
	add	edi, edi
	mov	DWORD PTR tv228[ebp], eax
	mov	eax, DWORD PTR _web[eax+20]
	mov	DWORD PTR tv227[ebp], ecx
	mov	DWORD PTR _newsize$[ebp], edi

; 97   :   if ( newsize == web.sizes[type] ) return; /* don't have to expand */

	cmp	edi, ecx
	je	$LN15@expand

; 98   :   web.sizes[type] = newsize;

	mov	DWORD PTR _web[esi*4+560], edi

; 99   :   if ( count == 0 ) return; /* don't have to reallocate space */

	test	eax, eax
	je	$LN15@expand

; 100  :   copysize = (newsize < oldsize) ? newsize : oldsize;

	mov	DWORD PTR _copysize$[ebp], edi
	cmp	edi, ecx
	jl	SHORT $LN18@expand
	mov	DWORD PTR _copysize$[ebp], ecx
$LN18@expand:
	push	ebx

; 101  : 
; 102  :   ENTER_GRAPH_MUTEX;

	mov	ebx, DWORD PTR __imp__GetCurrentThreadId@0
	call	ebx
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN12@expand
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	ebx
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89091[ebp], 1
	jmp	SHORT $LN11@expand
$LN12@expand:
	mov	DWORD PTR _did_graphlock_here$89091[ebp], 0
$LN11@expand:

; 103  :   /* Don't mess with structures while graph thread using them */
; 104  : 
; 105  : #ifdef HASH_ID
; 106  :   web.skel[type].freehead = NULL;
; 107  : #endif
; 108  : 
; 109  :   for ( n = 0 ; n < blockcount[type] ; n++ )

	xor	eax, eax
	mov	DWORD PTR _n$[ebp], eax
	cmp	DWORD PTR _blockcount[esi*4], eax
	jle	$LN8@expand
	mov	DWORD PTR tv333[ebp], eax
	jmp	SHORT $LN10@expand
	npad	5
$LL27@expand:
	mov	edi, DWORD PTR _newsize$[ebp]
$LN10@expand:

; 110  :   { INDIRECT_TYPE *iptr;
; 111  :      char *spot;
; 112  :      struct blocklist_struct *b = blocklist[type] + n;

	mov	esi, DWORD PTR _blocklist[esi*4]
	add	esi, DWORD PTR tv333[ebp]

; 113  : 
; 114  :      newblock = mycalloc(b->count,newsize);

	push	114					; 00000072H
	mov	eax, DWORD PTR [esi+8]
	push	OFFSET ??_C@_09EOIFBANE@STORAGE?4C?$AA@
	push	edi
	push	eax
	call	_kb_calloc

; 115  :      for ( i = 0, oldptr = (char*)(b->blockptr), newptr = newblock; 
; 116  :              i < b->count ; i++, oldptr += oldsize, newptr += newsize )

	mov	ebx, DWORD PTR [esi]
	xor	edi, edi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _newblock$[ebp], eax
	mov	DWORD PTR _newptr$[ebp], eax
	cmp	DWORD PTR [esi+8], edi
	jle	SHORT $LN5@expand
$LL28@expand:

; 117  :      { memcpy(newptr,oldptr,copysize);

	mov	ecx, DWORD PTR _copysize$[ebp]
	mov	edx, DWORD PTR _newptr$[ebp]
	push	ecx
	push	ebx
	push	edx
	call	_memcpy
	mov	eax, DWORD PTR _newsize$[ebp]
	add	ebx, DWORD PTR tv227[ebp]
	add	DWORD PTR _newptr$[ebp], eax
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR [esi+8]
	jl	SHORT $LL28@expand

; 115  :      for ( i = 0, oldptr = (char*)(b->blockptr), newptr = newblock; 
; 116  :              i < b->count ; i++, oldptr += oldsize, newptr += newsize )

	mov	eax, DWORD PTR _newblock$[ebp]
$LN5@expand:

; 118  :        #ifdef MPI_EVOLVER
; 119  :        { element_id id =  ((struct element*)oldptr)->self_id;
; 120  :          if ( id_task(id) != this_task )
; 121  :          { /* update pointer in remote_elements */
; 122  :            remote_elements[type].ibase[id_task(id)][ordinal(id)] = 
; 123  :                (struct element *)newptr;   
; 124  :           }
; 125  :        }
; 126  :        #endif
; 127  :      }
; 128  :      oldblock = (char*)b->blockptr;

	mov	edi, DWORD PTR [esi]

; 129  :      b->blockptr = (struct element*)newblock;
; 130  :      /* update indirect pointers */
; 131  :      /* keeping in mind structures not necessarily in id order 
; 132  :         due to reorder command */
; 133  :      for ( i=0,spot=newblock, iptr=web.skel[type].ibase+b->start_ord ; 
; 134  :                 i<b->count ; i++,spot+=newsize,iptr++ )

	xor	edx, edx
	mov	DWORD PTR [esi], eax
	cmp	DWORD PTR [esi+8], edx
	jle	SHORT $LN2@expand
	npad	2
$LL4@expand:

; 135  :      {  
; 136  : #ifdef MPI_EVOLVER
; 137  :          element_id id = ((struct element *)spot)->local_id;
; 138  : #else
; 139  :          element_id id = ((struct element *)spot)->self_id;

	mov	ecx, DWORD PTR [eax+16]

; 140  : #endif
; 141  : 
; 142  : #ifdef HASH_ID
; 143  :       { struct element *el_ptr;
; 144  :         el_ptr = (struct element *)spot;
; 145  :         if ( el_ptr->self_id ) /* replace in hash table */
; 146  :           elhash_replace(id,el_ptr);
; 147  :         else /* add to freelist */
; 148  :         { *(struct element **)&(el_ptr->forechain) = web.skel[type].freehead;
; 149  :           web.skel[type].freehead = el_ptr;
; 150  :         }
; 151  :       }
; 152  : #else
; 153  :         web.skel[type].ibase[ordinal(id)] = (struct element *)spot;

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN19@expand
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN20@expand
$LN19@expand:
	or	ecx, -1
$LN20@expand:
	mov	ebx, DWORD PTR tv228[ebp]
	mov	ebx, DWORD PTR _web[ebx+12]
	mov	DWORD PTR [ebx+ecx*4], eax
	add	eax, DWORD PTR _newsize$[ebp]
	inc	edx
	cmp	edx, DWORD PTR [esi+8]
	jl	SHORT $LL4@expand
$LN2@expand:

; 154  : #endif
; 155  :      }
; 156  :      myfree(oldblock);

	push	edi
	call	_myfree
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	add	DWORD PTR tv333[ebp], 12		; 0000000cH
	inc	eax
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax
	mov	esi, ecx
	cmp	eax, DWORD PTR _blockcount[ecx*4]
	jl	$LL27@expand
$LN8@expand:

; 157  :   }
; 158  : 
; 159  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89091[ebp], 0
	pop	ebx
	je	SHORT $LN1@expand
	mov	edx, DWORD PTR _graphmutex
	push	edx
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@expand:

; 160  : 
; 161  :   parallel_update_flag[type] = 1;

	mov	DWORD PTR _parallel_update_flag[esi*4], 1
$LN15@expand:
	pop	edi
	pop	esi

; 162  : } // end expand()

	mov	esp, ebp
	pop	ebp
	ret	0
_expand	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@CLJHJEIK@INTERNAL?5ERROR?5extend?$CI?$CJ?3?5no?5spar@ ; `string'
PUBLIC	??_C@_0DI@JAGENGAO@Trying?5to?5allocate?5more?5?$CFs?5than?5@ ; `string'
PUBLIC	??_C@_0CI@LGILGCEO@Internal?5error?3?5bad?5mode?5for?5ext@ ; `string'
PUBLIC	_extend
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
EXTRN	_typenames:BYTE
EXTRN	_kb_error:PROC
EXTRN	_KB_realloc:PROC
;	COMDAT ??_C@_0CK@CLJHJEIK@INTERNAL?5ERROR?5extend?$CI?$CJ?3?5no?5spar@
CONST	SEGMENT
??_C@_0CK@CLJHJEIK@INTERNAL?5ERROR?5extend?$CI?$CJ?3?5no?5spar@ DB 'INTER'
	DB	'NAL ERROR extend(): no sparse spots', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@JAGENGAO@Trying?5to?5allocate?5more?5?$CFs?5than?5@
CONST	SEGMENT
??_C@_0DI@JAGENGAO@Trying?5to?5allocate?5more?5?$CFs?5than?5@ DB 'Trying '
	DB	'to allocate more %s than ID format allows, %lld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LGILGCEO@Internal?5error?3?5bad?5mode?5for?5ext@
CONST	SEGMENT
??_C@_0CI@LGILGCEO@Internal?5error?3?5bad?5mode?5for?5ext@ DB 'Internal e'
	DB	'rror: bad mode for extend().', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _extend
_TEXT	SEGMENT
tv535 = -24						; size = 4
_newblock$ = -20					; size = 4
tv473 = -16						; size = 4
tv563 = -12						; size = 4
_oldnum$ = -12						; size = 4
_did_graphlock_here$89133 = -8				; size = 4
_number$ = -4						; size = 4
_backid$ = 8						; size = 4
_type$ = 8						; size = 4
_k$ = 12						; size = 4
_mode$ = 12						; size = 4
_extend	PROC						; COMDAT

; 175  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi

; 176  : #ifdef HASH_ID
; 177  :   elhash_extend(type,mode);
; 178  : #else
; 179  :   size_t number=0;  /* of new items to allocate */
; 180  :   char *newblock;
; 181  :   INDIRECT_TYPE *newiblock;
; 182  :   element_id id,backid;
; 183  :   struct element *newptr = NULL;
; 184  :   size_t k;
; 185  :   size_t allocsize;
; 186  :   size_t  oldnum = web.skel[type].maxcount;

	mov	edi, DWORD PTR _type$[ebp]
	mov	esi, edi
	imul	esi, 112				; 00000070H
	mov	eax, DWORD PTR _web[esi+20]
	xor	ebx, ebx
	mov	DWORD PTR _number$[ebp], ebx
	mov	DWORD PTR _oldnum$[ebp], eax

; 187  :   size_t  newnum=0;
; 188  :   int neword;
; 189  : 
; 190  : 
; 191  :   ENTER_GRAPH_MUTEX;

	call	DWORD PTR __imp__GetCurrentThreadId@0
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN54@extend
	push	ebx
	push	100000					; 000186a0H
	push	ebx
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89133[ebp], 1
	jmp	SHORT $LN53@extend
$LN54@extend:
	mov	DWORD PTR _did_graphlock_here$89133[ebp], ebx
$LN53@extend:

; 192  :   /* Don't mess with structures while graph thread using them */
; 193  : 
; 194  :   if ( blockcount[type] >= blockmax[type] )

	mov	eax, DWORD PTR _blockcount[edi*4]
	cmp	eax, DWORD PTR _blockmax[edi*4]
	jl	SHORT $LN73@extend

; 195  :   { blocklist[type] = (struct blocklist_struct*)
; 196  :       kb_realloc((char*)(blocklist[type]),
; 197  :          (blockcount[type]+BATCHSIZE)*sizeof(struct blocklist_struct));

	mov	edx, DWORD PTR _blocklist[edi*4]
	lea	ecx, DWORD PTR [eax+eax*2+3000]
	push	197					; 000000c5H
	add	ecx, ecx
	push	OFFSET ??_C@_09EOIFBANE@STORAGE?4C?$AA@
	add	ecx, ecx
	push	ecx
	push	edx
	call	_KB_realloc
	add	esp, 16					; 00000010H

; 198  :      blockmax[type] += BATCHSIZE;

	add	DWORD PTR _blockmax[edi*4], 1000	; 000003e8H
	mov	DWORD PTR _blocklist[edi*4], eax
$LN73@extend:

; 199  :   }
; 200  :   if ( mode == EXTEND_BATCH )

	mov	eax, DWORD PTR _mode$[ebp]
	cmp	eax, 1
	jne	SHORT $LN51@extend

; 201  :   {   
; 202  :     if ( web.skel[type].maxcount==0 && elements_predicted[type] )

	cmp	DWORD PTR _web[esi+20], ebx
	jne	SHORT $LN50@extend
	mov	eax, DWORD PTR _elements_predicted[edi*4]
	test	eax, eax

; 203  :     { 
; 204  :       number = elements_predicted[type];
; 205  :     }
; 206  :     else

	jne	SHORT $LN77@extend
$LN50@extend:

; 207  :     { /* calculate number of structures to fit in block size just under 2^n */
; 208  :       allocsize = BATCHSIZE*web.sizes[type];

	mov	ebx, DWORD PTR _web[edi*4+560]
	mov	eax, ebx
	imul	eax, 1000				; 000003e8H

; 209  :       k = 0x100 ; while ( k < allocsize ) k <<= 1 ;

	mov	ecx, 256				; 00000100H
	cmp	eax, ecx
	jbe	SHORT $LN47@extend
$LL48@extend:
	add	ecx, ecx
	cmp	ecx, eax
	jb	SHORT $LL48@extend
$LN47@extend:

; 210  :       number = (k-16)/web.sizes[type]; /* maybe room for block header */

	lea	eax, DWORD PTR [ecx-16]
	xor	edx, edx
	div	ebx
$LN77@extend:

; 211  :     }
; 212  :     newnum = web.skel[type].maxcount + number;

	mov	ebx, DWORD PTR _web[esi+20]
	mov	DWORD PTR _number$[ebp], eax
	add	ebx, eax
	jmp	SHORT $LN42@extend
$LN51@extend:

; 213  :   }
; 214  :   else if ( mode == EXTEND_FOR_REFINE ) 

	cmp	eax, 2
	jne	SHORT $LN45@extend

; 215  :   { /* increase by 2^surface_dimension factor */
; 216  :     if ( type == BODY ) goto extend_exit;   /* don't need more bodies */

	cmp	edi, 3
	je	$extend_exit$89149

; 217  :     newnum = web.skel[type].count*(1<<web.dimension) + 100;

	mov	ecx, DWORD PTR _web+620

; 218  :     if ( newnum <= (size_t)web.skel[type].maxcount ) { goto extend_exit; }/* don't need any more */

	mov	eax, DWORD PTR _web[esi+20]
	mov	ebx, 1
	shl	ebx, cl
	imul	ebx, DWORD PTR _web[esi+64]
	add	ebx, 100				; 00000064H
	cmp	ebx, eax
	jbe	$extend_exit$89149

; 219  :     number = newnum - web.skel[type].maxcount;

	mov	ecx, ebx
	sub	ecx, eax
	mov	DWORD PTR _number$[ebp], ecx
	jmp	SHORT $LN42@extend
$LN45@extend:

; 220  :   }
; 221  :   else kb_error(2474,"Internal error: bad mode for extend().\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CI@LGILGCEO@Internal?5error?3?5bad?5mode?5for?5ext@
	push	2474					; 000009aaH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN42@extend:

; 222  :   
; 223  :   if ( (web.skel[type].maxcount + number) > OFFSETMASK )

	mov	ecx, DWORD PTR _web[esi+20]
	add	ecx, DWORD PTR _number$[ebp]
	cmp	ecx, 134217727				; 07ffffffH
	jbe	SHORT $LN41@extend

; 224  :   { sprintf(errmsg, "Trying to allocate more %s than ID format allows, %lld\n",
; 225  :           typenames[type],(long long int)OFFSETMASK);

	mov	edx, DWORD PTR _typenames[edi*4]
	push	0
	push	134217727				; 07ffffffH
	push	edx
	push	OFFSET ??_C@_0DI@JAGENGAO@Trying?5to?5allocate?5more?5?$CFs?5than?5@
	push	OFFSET _errmsg
	call	_sprintf

; 226  :     kb_error(3712,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3712					; 00000e80H
	call	_kb_error
	add	esp, 32					; 00000020H
$LN41@extend:

; 227  :   }
; 228  : 
; 229  :   newblock = mycalloc(number,web.sizes[type]);

	mov	ecx, DWORD PTR _number$[ebp]
	lea	eax, DWORD PTR _web[edi*4+560]
	push	229					; 000000e5H
	mov	DWORD PTR tv473[ebp], eax
	mov	eax, DWORD PTR [eax]
	push	OFFSET ??_C@_09EOIFBANE@STORAGE?4C?$AA@
	push	eax
	push	ecx
	call	_kb_calloc
	mov	ecx, eax

; 230  :   blocklist[type][blockcount[type]].start_ord = oldnum ;

	mov	eax, DWORD PTR _blockcount[edi*4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _blocklist[edi*4]
	mov	edi, DWORD PTR _oldnum$[ebp]
	mov	DWORD PTR [eax+edx*4+4], edi

; 231  :   blocklist[type][blockcount[type]].count = number ;

	mov	edx, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR _blockcount[edx*4]
	mov	edx, DWORD PTR _blocklist[edx*4]
	mov	edi, DWORD PTR _number$[ebp]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [edx+eax*4+8], edi

; 232  :   blocklist[type][blockcount[type]++].blockptr = (struct element *)newblock;

	mov	edi, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR _blockcount[edi*4]
	mov	edx, DWORD PTR _blocklist[edi*4]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [edx+eax*4], ecx
	inc	DWORD PTR _blockcount[edi*4]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _newblock$[ebp], ecx

; 233  : 
; 234  :   while ( newnum >= (size_t)web.skel[type].ialloc )

	cmp	ebx, DWORD PTR _web[esi+16]
	jb	$LN75@extend
$LL40@extend:

; 235  :   {
; 236  :     if ( web.skel[type].ibase == NULL )

	mov	eax, DWORD PTR _web[esi+12]
	test	eax, eax
	jne	SHORT $LN38@extend

; 237  :     { newiblock = (INDIRECT_TYPE*)mycalloc(number,sizeof(INDIRECT_TYPE));

	mov	eax, DWORD PTR _number$[ebp]
	push	237					; 000000edH
	push	OFFSET ??_C@_09EOIFBANE@STORAGE?4C?$AA@
	push	4
	push	eax
	call	_kb_calloc

; 238  :       web.skel[type].ialloc = number;

	mov	ecx, DWORD PTR _number$[ebp]
	mov	DWORD PTR _web[esi+16], ecx

; 239  :     }
; 240  :     else

	jmp	SHORT $LN78@extend
$LN38@extend:

; 241  :     { int allocnum = web.skel[type].ialloc < 100 ? 100 : 2*web.skel[type].ialloc;

	mov	ecx, DWORD PTR _web[esi+16]
	mov	edi, 100				; 00000064H
	cmp	ecx, 100				; 00000064H
	jl	SHORT $LN58@extend
	lea	edi, DWORD PTR [ecx+ecx]
$LN58@extend:

; 242  :       newiblock = (INDIRECT_TYPE*)kb_realloc((char*)(web.skel[type].ibase),
; 243  :         allocnum*sizeof(INDIRECT_TYPE));

	push	243					; 000000f3H
	push	OFFSET ??_C@_09EOIFBANE@STORAGE?4C?$AA@
	lea	edx, DWORD PTR [edi*4]
	push	edx
	push	eax
	call	_KB_realloc

; 244  :       web.skel[type].ialloc = allocnum;

	mov	DWORD PTR _web[esi+16], edi
	mov	edi, DWORD PTR _type$[ebp]
$LN78@extend:

; 245  :     }
; 246  :     web.skel[type].ibase = newiblock;

	add	esp, 16					; 00000010H
	mov	DWORD PTR _web[esi+12], eax

; 247  :     switch(type)

	cmp	edi, 4
	ja	SHORT $LN35@extend
	jmp	DWORD PTR $LN81@extend[edi*4]
$LN34@extend:

; 248  :     {    case VERTEX: vibase = newiblock; break;

	mov	DWORD PTR _vibase, eax
	jmp	SHORT $LN35@extend
$LN33@extend:

; 249  :          case EDGE:    eibase = newiblock; break;

	mov	DWORD PTR _eibase, eax
	jmp	SHORT $LN35@extend
$LN32@extend:

; 250  :          case FACET:  fibase = newiblock; break;

	mov	DWORD PTR _fibase, eax
	jmp	SHORT $LN35@extend
$LN31@extend:

; 251  :          case BODY:    bibase = newiblock; break;

	mov	DWORD PTR _bibase, eax
	jmp	SHORT $LN35@extend
$LN30@extend:

; 252  :          case FACETEDGE: feibase = newiblock; break;

	mov	DWORD PTR _feibase, eax
$LN35@extend:

; 233  : 
; 234  :   while ( newnum >= (size_t)web.skel[type].ialloc )

	cmp	ebx, DWORD PTR _web[esi+16]
	jae	$LL40@extend
$LN75@extend:

; 253  :     }
; 254  :   }
; 255  : 
; 256  :   /* add to end of freelist */
; 257  : 
; 258  :   /* find first empty slot */
; 259  :   if ( sparse_ibase_flag )

	cmp	DWORD PTR _sparse_ibase_flag, 0
	je	SHORT $LN29@extend

; 260  :   { int restart_flag = 0;  // whether sparse_spot looped around

	xor	ebx, ebx
$LL28@extend:

; 261  :     for ( ;; )
; 262  :     {
; 263  :       for ( neword = web.skel[type].sparse_spot ; 
; 264  :              neword < web.skel[type].ialloc ; neword++ )

	mov	eax, DWORD PTR _web[esi+36]
	mov	edx, DWORD PTR _web[esi+16]
	cmp	eax, edx
	jge	SHORT $LN79@extend
	mov	ecx, DWORD PTR _web[esi+12]
	lea	ecx, DWORD PTR [ecx+eax*4]
	npad	7
$LL26@extend:

; 265  :          if ( web.skel[type].ibase[neword] == NULL )

	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN66@extend

; 261  :     for ( ;; )
; 262  :     {
; 263  :       for ( neword = web.skel[type].sparse_spot ; 
; 264  :              neword < web.skel[type].ialloc ; neword++ )

	inc	eax
	add	ecx, 4
	cmp	eax, edx
	jl	SHORT $LL26@extend

; 314  :             if ( web.skel[type].ibase[neword] == NULL )

	jmp	SHORT $LN24@extend
$LN66@extend:

; 266  :          { 
; 267  :            web.skel[type].sparse_spot = neword;

	mov	DWORD PTR _web[esi+36], eax
$LN24@extend:

; 268  :            break;
; 269  :          }
; 270  :        if ( neword == web.skel[type].ialloc )

	cmp	eax, edx
$LN79@extend:
	jne	SHORT $LN19@extend

; 271  :        { if ( restart_flag >= 1)

	cmp	ebx, 1
	jl	SHORT $LN21@extend

; 272  :               kb_error(5693,"INTERNAL ERROR extend(): no sparse spots\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CK@CLJHJEIK@INTERNAL?5ERROR?5extend?$CI?$CJ?3?5no?5spar@
	push	5693					; 0000163dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN21@extend:

; 273  :          restart_flag += 1;

	inc	ebx

; 274  :          web.skel[type].sparse_spot = 0;

	mov	DWORD PTR _web[esi+36], 0

; 275  :          continue;

	jmp	SHORT $LL28@extend
$LN29@extend:

; 276  :        }
; 277  :        else
; 278  :          break;
; 279  :     }
; 280  :   }
; 281  :   else /* dense ibase */
; 282  :     neword = web.skel[type].maxcount;

	mov	eax, DWORD PTR _web[esi+20]
$LN19@extend:

; 283  : 
; 284  :   id = ((element_id)type << TYPESHIFT) | VALIDMASK | neword; 
; 285  : #ifdef MPI_EVOLVER
; 286  :   id |= (element_id)this_task << TASK_ID_SHIFT;  
; 287  : #endif
; 288  : 
; 289  :   if ( valid_id(web.skel[type].freelast) )

	mov	edx, DWORD PTR _web[esi+32]
	mov	ebx, edi
	shl	ebx, 29					; 0000001dH
	mov	ecx, ebx
	or	ecx, eax
	or	ecx, 268435456				; 10000000H
	mov	DWORD PTR tv535[ebp], ebx
	test	edx, 268435456				; 10000000H
	je	SHORT $LN18@extend

; 290  :   { backid = web.skel[type].freelast;
; 291  :     elptr(backid)->forechain = id;

	mov	edi, edx
	shr	edi, 29					; 0000001dH
	imul	edi, 112				; 00000070H
	mov	edi, DWORD PTR _web[edi+12]
	mov	DWORD PTR _backid$[ebp], edx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [edx], ecx

; 292  :   }
; 293  :   else

	jmp	SHORT $LN17@extend
$LN18@extend:

; 294  :   { backid = NULLID;

	mov	DWORD PTR _backid$[ebp], 0

; 295  :     web.skel[type].free = id;

	mov	DWORD PTR _web[esi+28], ecx
$LN17@extend:

; 296  :   }
; 297  : 
; 298  :   for ( k = 0 ; k < number ; k++ )

	mov	edi, DWORD PTR _number$[ebp]
	xor	edx, edx
	mov	DWORD PTR _k$[ebp], edx
	test	edi, edi
	je	$LN14@extend

; 345  :   web.skel[type].maxcount += number;

	dec	edi
	mov	DWORD PTR tv563[ebp], edi
$LL74@extend:

; 299  :   { newptr = (struct element *)(newblock + k*web.sizes[type]); 

	mov	edi, DWORD PTR tv473[ebp]
	mov	edi, DWORD PTR [edi]
	imul	edi, edx
	add	edi, DWORD PTR _newblock$[ebp]

; 300  :     web.skel[type].ibase[neword] = newptr;

	mov	edx, DWORD PTR _web[esi+12]
	mov	DWORD PTR [edx+eax*4], edi

; 301  :     newptr->self_id = id;
; 302  :     #ifdef MPI_EVOLVER
; 303  :       newptr->local_id = id;
; 304  :     #endif
; 305  : 
; 306  :     if ( k < number-1 )

	mov	edx, DWORD PTR tv563[ebp]
	mov	DWORD PTR [edi+16], ecx
	cmp	DWORD PTR _k$[ebp], edx
	jae	$LN72@extend

; 307  :     {
; 308  :       if ( sparse_ibase_flag )

	cmp	DWORD PTR _sparse_ibase_flag, 0
	je	SHORT $LN12@extend

; 309  :       { int restart_flag = 0;  // whether sparse_spot looped around

	xor	ebx, ebx
$LL11@extend:

; 310  :         for (;;)
; 311  :         {
; 312  :           for ( neword = web.skel[type].sparse_spot ; 
; 313  :                    neword < web.skel[type].ialloc ; neword++ )

	mov	eax, DWORD PTR _web[esi+36]
	mov	edx, DWORD PTR _web[esi+16]
	cmp	eax, edx
	jge	SHORT $LN80@extend
	mov	ecx, DWORD PTR _web[esi+12]
	lea	ecx, DWORD PTR [ecx+eax*4]
	npad	5
$LL9@extend:

; 314  :             if ( web.skel[type].ibase[neword] == NULL )

	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN67@extend

; 310  :         for (;;)
; 311  :         {
; 312  :           for ( neword = web.skel[type].sparse_spot ; 
; 313  :                    neword < web.skel[type].ialloc ; neword++ )

	inc	eax
	add	ecx, 4
	cmp	eax, edx
	jl	SHORT $LL9@extend

; 314  :             if ( web.skel[type].ibase[neword] == NULL )

	jmp	SHORT $LN7@extend
$LN67@extend:

; 315  :             { 
; 316  :               web.skel[type].sparse_spot = neword;

	mov	DWORD PTR _web[esi+36], eax
$LN7@extend:

; 317  :               break;
; 318  :             }
; 319  :           if ( neword == web.skel[type].ialloc )

	cmp	eax, edx
$LN80@extend:
	jne	SHORT $LN76@extend

; 320  :           { if ( restart_flag >= 1)

	cmp	ebx, 1
	jl	SHORT $LN4@extend

; 321  :               kb_error(5692,"INTERNAL ERROR extend(): no sparse spots\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CK@CLJHJEIK@INTERNAL?5ERROR?5extend?$CI?$CJ?3?5no?5spar@
	push	5692					; 0000163cH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN4@extend:

; 322  :             restart_flag += 1;

	inc	ebx

; 323  :             web.skel[type].sparse_spot = 0;

	mov	DWORD PTR _web[esi+36], 0

; 324  :             continue;

	jmp	SHORT $LL11@extend
$LN12@extend:

; 325  :           }
; 326  :           else
; 327  :             break;
; 328  :         }
; 329  :       }
; 330  :       else 
; 331  :         neword++;

	inc	eax
	jmp	SHORT $LN2@extend
$LN76@extend:
	mov	ebx, DWORD PTR tv535[ebp]
$LN2@extend:

; 332  :       id = ((element_id)type << TYPESHIFT) | VALIDMASK | neword; 

	mov	ecx, ebx
	or	ecx, eax
	or	ecx, 268435456				; 10000000H

; 333  : #ifdef MPI_EVOLVER
; 334  :       id |= (element_id)this_task << TASK_ID_SHIFT;  
; 335  : #endif
; 336  : 
; 337  :       newptr->forechain = id;

	mov	DWORD PTR [edi], ecx
$LN72@extend:

; 338  :     }
; 339  :     newptr->backchain = backid;

	mov	edx, DWORD PTR _backid$[ebp]
	mov	DWORD PTR [edi+4], edx

; 340  :     backid = newptr->self_id;

	mov	edx, DWORD PTR [edi+16]
	mov	DWORD PTR _backid$[ebp], edx
	mov	edx, DWORD PTR _k$[ebp]
	inc	edx
	mov	DWORD PTR _k$[ebp], edx
	cmp	edx, DWORD PTR _number$[ebp]
	jb	$LL74@extend

; 296  :   }
; 297  : 
; 298  :   for ( k = 0 ; k < number ; k++ )

	mov	edi, DWORD PTR _number$[ebp]
$LN14@extend:

; 341  : 
; 342  :   }
; 343  : 
; 344  :   web.skel[type].freelast = backid;

	mov	eax, DWORD PTR _backid$[ebp]

; 345  :   web.skel[type].maxcount += number;

	add	DWORD PTR _web[esi+20], edi
	mov	DWORD PTR _web[esi+32], eax
$extend_exit$89149:

; 346  :   
; 347  : extend_exit:
; 348  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89133[ebp], 0
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN1@extend
	mov	ecx, DWORD PTR _graphmutex
	push	ecx
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@extend:

; 349  :   
; 350  : /* end ifdef HASH_ID */
; 351  : #endif
; 352  : 
; 353  : } // end extend()

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN81@extend:
	DD	$LN34@extend
	DD	$LN33@extend
	DD	$LN32@extend
	DD	$LN31@extend
	DD	$LN30@extend
_extend	ENDP
_TEXT	ENDS
PUBLIC	_free_element_lists
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT _free_element_lists
_TEXT	SEGMENT
_i$ = -8						; size = 4
tv272 = -4						; size = 4
_free_element_lists PROC				; COMDAT

; 361  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 367  :     web.skel[type].alloc = 0;

	xor	ebx, ebx
	mov	esi, OFFSET _web+64
	xor	edi, edi
$LL6@free_eleme:

; 362  :   int type,i;
; 363  :   for ( type = VERTEX ; type <= FACETEDGE ; type++ )
; 364  :   { for ( i = 0 ; i < blockcount[type] ; i++ )

	mov	DWORD PTR _i$[ebp], ebx
	cmp	DWORD PTR _blockcount[edi], ebx
	jle	SHORT $LN1@free_eleme
	mov	DWORD PTR tv272[ebp], ebx
$LL13@free_eleme:

; 365  :       myfree((char*)blocklist[type][i].blockptr);

	mov	eax, DWORD PTR _blocklist[edi]
	mov	ecx, DWORD PTR tv272[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	_myfree
	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv272[ebp], 12		; 0000000cH
	inc	eax
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _blockcount[edi]
	jl	SHORT $LL13@free_eleme
$LN1@free_eleme:

; 366  :     myfree((char*)web.skel[type].ibase);

	mov	eax, DWORD PTR [esi-52]
	push	eax
	call	_myfree

; 368  :     web.skel[type].count = 0;
; 369  :     web.skel[type].maxcount = 0;
; 370  :     web.skel[type].ibase = NULL;
; 371  :     web.skel[type].ialloc = 0;
; 372  :     web.skel[type].discard = 0;
; 373  :     web.skel[type].discard_count = 0;
; 374  :     web.skel[type].free = 0;
; 375  :     web.skel[type].freelast = 0;
; 376  :     web.skel[type].free_spot = 0;
; 377  :     web.skel[type].freehead = NULL;
; 378  :     web.skel[type].sparse_spot = 0;
; 379  :     web.skel[type].used = NULLID;
; 380  :     web.skel[type].last = NULLID;
; 381  :     web.skel[type].max_ord = 0;
; 382  :     memset(blocklist[type],0,blockmax[type]*sizeof(struct blocklist_struct));

	mov	eax, DWORD PTR _blockmax[edi]
	mov	edx, DWORD PTR _blocklist[edi]
	lea	ecx, DWORD PTR [eax+eax*2]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	ebx
	push	edx
	mov	DWORD PTR [esi-40], ebx
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi-44], ebx
	mov	DWORD PTR [esi-52], ebx
	mov	DWORD PTR [esi-48], ebx
	mov	DWORD PTR [esi-8], ebx
	mov	DWORD PTR [esi-4], ebx
	mov	DWORD PTR [esi-36], ebx
	mov	DWORD PTR [esi-32], ebx
	mov	DWORD PTR [esi-20], ebx
	mov	DWORD PTR [esi-24], ebx
	mov	DWORD PTR [esi-28], ebx
	mov	DWORD PTR [esi-16], ebx
	mov	DWORD PTR [esi-12], ebx
	mov	DWORD PTR [esi+4], ebx
	call	_memset

; 383  :     blockcount[type] = 0;

	mov	DWORD PTR _blockcount[edi], ebx
	add	esi, 112				; 00000070H
	add	esp, 16					; 00000010H
	add	edi, 4
	cmp	esi, OFFSET _web+512
	jle	$LL6@free_eleme
	pop	edi
	pop	esi
	pop	ebx

; 384  :   }
; 385  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_free_element_lists ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DO@JBAEKPDL@Internal?5error?3?5Trying?5to?5unfree@ ; `string'
PUBLIC	??_C@_0DE@GBNGIBJM@Internal?5error?3?5Trying?5to?5unfree@ ; `string'
PUBLIC	_unfree_element
;	COMDAT ??_C@_0DO@JBAEKPDL@Internal?5error?3?5Trying?5to?5unfree@
CONST	SEGMENT
??_C@_0DO@JBAEKPDL@Internal?5error?3?5Trying?5to?5unfree@ DB 'Internal er'
	DB	'ror: Trying to unfree allocated element id %08lX ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@GBNGIBJM@Internal?5error?3?5Trying?5to?5unfree@
CONST	SEGMENT
??_C@_0DE@GBNGIBJM@Internal?5error?3?5Trying?5to?5unfree@ DB 'Internal er'
	DB	'ror: Trying to unfree invalid id %08lX ', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _unfree_element
_TEXT	SEGMENT
_id$ = 8						; size = 4
_unfree_element PROC					; COMDAT

; 669  : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 670  :   struct element *ptr;
; 671  :   int type = id_type(id);

	mov	ebx, DWORD PTR _id$[ebp]
	push	esi
	mov	esi, ebx
	shr	esi, 29					; 0000001dH
	push	edi

; 672  : 
; 673  :   if ( !valid_id(id) )

	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN2@unfree_ele

; 674  :   { sprintf(errmsg,"Internal error: Trying to unfree invalid id %08lX \n",
; 675  :         (unsigned long)id);

	push	ebx
	push	OFFSET ??_C@_0DE@GBNGIBJM@Internal?5error?3?5Trying?5to?5unfree@
	push	OFFSET _errmsg
	call	_sprintf

; 676  :     kb_error(1314,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1314					; 00000522H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN2@unfree_ele:

; 677  :   }
; 678  :     
; 679  :   ptr = elptr(id);

	imul	esi, 112				; 00000070H
	mov	ecx, DWORD PTR _web[esi+12]
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]

; 680  :   if ( ptr->attr & ALLOCATED )

	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN1@unfree_ele

; 681  :   { sprintf(errmsg,
; 682  :      "Internal error: Trying to unfree allocated element id %08lX \n",
; 683  :           (unsigned long)id);

	push	ebx
	push	OFFSET ??_C@_0DO@JBAEKPDL@Internal?5error?3?5Trying?5to?5unfree@
	push	OFFSET _errmsg
	call	_sprintf

; 684  :     kb_error(1315,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1315					; 00000523H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN1@unfree_ele:

; 685  :   }
; 686  :   ptr->attr |= ALLOCATED;

	mov	edx, DWORD PTR [edi+12]
	mov	eax, 1
	or	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], edx

; 687  : 
; 688  :   #ifdef MPI_EVOLVER
; 689  :   if ( id_task(id) != this_task )
; 690  :     mpi_unfree_element(id,ptr);
; 691  :   #endif
; 692  : 
; 693  :   web.skel[type].discard_count--;

	dec	DWORD PTR _web[esi+60]

; 694  : 
; 695  :   web.skel[type].count++;  

	add	DWORD PTR _web[esi+64], eax
	pop	edi
	pop	esi
	pop	ebx

; 696  : } // end unfree_element()

	pop	ebp
	ret	0
_unfree_element ENDP
_TEXT	ENDS
PUBLIC	_get_ordinal_id
; Function compile flags: /Ogtp
;	COMDAT _get_ordinal_id
_TEXT	SEGMENT
_type$ = 8						; size = 4
_ord$ = 12						; size = 4
_get_ordinal_id PROC					; COMDAT

; 709  : { element_id id;

	push	ebp
	mov	ebp, esp

; 710  :   struct element *ep;
; 711  : 
; 712  :   if ( (type < 0) || (type > NUMELEMENTS) ) return NULLID;

	mov	ecx, DWORD PTR _type$[ebp]
	cmp	ecx, 5
	ja	SHORT $LN5@get_ordina

; 713  :   if ( abs(ord) > web.skel[type].max_ord ) return NULLID;

	push	esi
	mov	esi, DWORD PTR _ord$[ebp]
	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, ecx
	imul	edx, 112				; 00000070H
	cmp	eax, DWORD PTR _web[edx+68]
	jg	SHORT $LN10@get_ordina

; 714  :   id = ((element_id)type << TYPESHIFT) | VALIDMASK | abs(ord);

	shl	ecx, 29					; 0000001dH
	or	eax, ecx
	or	eax, 268435456				; 10000000H

; 715  :   if ( ord < 0 ) invert(id);

	test	esi, esi
	jns	SHORT $LN3@get_ordina
	xor	eax, 134217728				; 08000000H
$LN3@get_ordina:

; 716  : 
; 717  : #ifdef MPI_EVOLVER
; 718  :   id |= (element_id)this_task << TASK_ID_SHIFT;
; 719  : #endif
; 720  :   ep = elptr(id);

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ecx+12]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]

; 721  :   if ( ep == NULL ) return NULLID;

	test	ecx, ecx
	je	SHORT $LN10@get_ordina

; 722  :   if ( ep->attr & ALLOCATED ) return id;

	mov	edx, DWORD PTR [ecx+8]
	and	edx, 1
	xor	ecx, ecx
	or	edx, ecx
	jne	SHORT $LN9@get_ordina
$LN10@get_ordina:

; 723  :   return NULLID;

	xor	eax, eax
$LN9@get_ordina:
	pop	esi

; 724  : }

	pop	ebp
	ret	0
$LN5@get_ordina:

; 710  :   struct element *ep;
; 711  : 
; 712  :   if ( (type < 0) || (type > NUMELEMENTS) ) return NULLID;

	xor	eax, eax

; 724  : }

	pop	ebp
	ret	0
_get_ordinal_id ENDP
_TEXT	ENDS
PUBLIC	_get_full_id
; Function compile flags: /Ogtp
;	COMDAT _get_full_id
_TEXT	SEGMENT
_type$ = 8						; size = 4
_partid$ = 12						; size = 4
_get_full_id PROC					; COMDAT

; 737  : { element_id id;

	push	ebp
	mov	ebp, esp

; 738  :   struct element *ep;
; 739  : #ifdef MPI_EVOLVER
; 740  :   int task = id_task(partid);
; 741  : #endif
; 742  :   int ord = (int)(partid & OFFSETMASK);
; 743  : 
; 744  :   if ( partid == NULLID ) 

	mov	ecx, DWORD PTR _partid$[ebp]
	test	ecx, ecx

; 745  :     return NULLID;

	je	SHORT $LN4@get_full_i

; 746  : 
; 747  :   if ( (type < 0) || (type > NUMELEMENTS) ) return NULLID;

	mov	eax, DWORD PTR _type$[ebp]
	cmp	eax, 5
	ja	SHORT $LN4@get_full_i

; 748  : #ifdef MPI_EVOLVER
; 749  :   if ( task == this_task )
; 750  : #endif
; 751  :     if ( ord > web.skel[type].max_ord ) return NULLID;

	mov	edx, eax
	imul	edx, 112				; 00000070H
	push	esi
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	cmp	esi, DWORD PTR _web[edx+68]
	pop	esi
	jg	SHORT $LN4@get_full_i

; 752  :   #ifdef MPI_EVOLVER
; 753  :   if ( task >= mpi_nprocs )
; 754  : 	return NULLID;
; 755  :   #endif
; 756  :   id = partid | ((element_id)type << TYPESHIFT);

	shl	eax, 29					; 0000001dH
	or	eax, ecx

; 757  : 
; 758  :   ep = elptr(id|VALIDMASK);

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ecx+12]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]

; 759  :   if ( ep == NULL ) return NULLID;

	test	ecx, ecx
	je	SHORT $LN4@get_full_i

; 760  :   if ( ep->attr & ALLOCATED ) return id|VALIDMASK;

	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	edx, edx
	or	ecx, edx
	je	SHORT $LN4@get_full_i
	or	eax, 268435456				; 10000000H

; 761  :   return NULLID;
; 762  : }

	pop	ebp
	ret	0
$LN4@get_full_i:

; 746  : 
; 747  :   if ( (type < 0) || (type > NUMELEMENTS) ) return NULLID;

	xor	eax, eax

; 761  :   return NULLID;
; 762  : }

	pop	ebp
	ret	0
_get_full_id ENDP
_TEXT	ENDS
PUBLIC	_generate_all
; Function compile flags: /Ogtp
;	COMDAT _generate_all
_TEXT	SEGMENT
_type$ = 8						; size = 4
_idptr$ = 12						; size = 4
_sentinel$ = 16						; size = 4
_generate_all PROC					; COMDAT

; 779  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 780  :   struct element *ptr;
; 781  : 
; 782  :   if ( !valid_id(*idptr) ) /* first time */

	mov	esi, DWORD PTR _idptr$[ebp]
	mov	eax, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR _sentinel$[ebp]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN6@generate_a

; 783  :   { *idptr = web.skel[type].used;

	mov	eax, DWORD PTR _type$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+48]
	mov	DWORD PTR [esi], ecx

; 784  :     *sentinel = web.skel[type].last;   /* may be a discard */

	mov	edx, DWORD PTR _web[eax+52]
	mov	DWORD PTR [edi], edx

; 785  :     if ( !valid_id(*idptr) ) return 0;

	mov	eax, DWORD PTR [esi]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN7@generate_a
$LN12@generate_a:
	pop	edi
	xor	eax, eax
	pop	esi

; 809  : } // end generate_all()

	pop	ebp
	ret	0
$LN7@generate_a:

; 786  :     ptr = elptr(*idptr);

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H

; 787  :     if ( (ptr->attr & ALLOCATED)
; 788  :     #ifdef MPI_EVOLVER
; 789  :      && (id_task(ptr->self_id) == this_task)
; 790  :     #endif
; 791  :      )

	mov	ecx, DWORD PTR _web[ecx+12]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	edx, edx
	or	ecx, edx

; 792  :       return 1;

	jne	SHORT $LN13@generate_a
$LN6@generate_a:

; 793  :   }
; 794  :    
; 795  :     ptr = elptr(*idptr);

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
$LL5@generate_a:

; 796  :     do
; 797  :       { if ( equal_id(*idptr,*sentinel) ) return 0;

	mov	edx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [edi]
	je	SHORT $LN12@generate_a

; 798  :       *idptr = ptr->forechain;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax

; 799  :       if ( !valid_id(*idptr) ) return 0;

	test	eax, 268435456				; 10000000H
	je	SHORT $LN12@generate_a

; 800  :       ptr = elptr(*idptr);

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]

; 801  :     }
; 802  :     while ( !(ptr->attr & ALLOCATED)
; 803  :     #ifdef MPI_EVOLVER
; 804  :      || (id_task(ptr->self_id) != this_task)
; 805  :     #endif
; 806  :      );

	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LL5@generate_a
$LN13@generate_a:
	pop	edi

; 807  : 
; 808  :   return 1;

	mov	eax, 1
	pop	esi

; 809  : } // end generate_all()

	pop	ebp
	ret	0
_generate_all ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@LBMFAHHF@Physical?5memory?5size?3?5?$CF4?42f?5GB?5?5@ ; `string'
PUBLIC	??_C@_0BF@FHGNIJLD@Heap?5size?3?5?$CF4?42f?5MB?6?$AA@ ; `string'
PUBLIC	__real@3f50000000000000
PUBLIC	__real@41f0000000000000
PUBLIC	??_C@_0O@FIMOFDAK@Heap?5top?3?5?$CFp?6?$AA@	; `string'
PUBLIC	??_C@_0DH@KGNONAHO@?5?5blocks?5free?3?5?$CF6d?5?5?5?5memory?5fre@ ; `string'
PUBLIC	??_C@_0DJ@JIJDIJPC@blocks?5in?5use?3?5?$CF6d?5?5?5?5memory?5in?5@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0CE@BHBJDFNE@?6?5Heapwalk?5ended?5unsuccessfully?$CB@ ; `string'
PUBLIC	??_C@_0DC@LMNNJEJE@Internal?5error?3?5Corrupt?5heap?$CB?5Me@ ; `string'
PUBLIC	??_C@_0DF@IEDKPFGG@?5?5instance?5size?3?5?$CF4d?5bytes?$DL?5?5num@ ; `string'
PUBLIC	??_C@_0DF@BDIPBEJK@?5?5quantity?5size?3?5?$CF4u?5bytes?$DL?5?5num@ ; `string'
PUBLIC	??_C@_0DD@EODDMNLJ@?$CF10?410s?5size?3?5?$CF4d?5bytes?$DL?5?5number@ ; `string'
PUBLIC	??_C@_0CD@MEPIDDPN@Element?5memory?3?5?$CFlu?5KB?0?5or?5?$CFlu?5M@ ; `string'
PUBLIC	??_C@_0EG@BJNOKABH@Vertices?3?5?$CFld?5?5Edges?3?5?$CFld?5?5Facet@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_memory_report
EXTRN	_dy_check:PROC
EXTRN	_mem_list_summary:PROC
EXTRN	__imp__GlobalMemoryStatusEx@4:PROC
EXTRN	__heapwalk:PROC
EXTRN	__heapchk:PROC
EXTRN	_meth_inst_list_max:DWORD
EXTRN	_gen_quant_list_max:DWORD
EXTRN	_verbose_flag:DWORD
EXTRN	_outstring:PROC
EXTRN	_msg:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0DL@LBMFAHHF@Physical?5memory?5size?3?5?$CF4?42f?5GB?5?5@
CONST	SEGMENT
??_C@_0DL@LBMFAHHF@Physical?5memory?5size?3?5?$CF4?42f?5GB?5?5@ DB 'Physi'
	DB	'cal memory size: %4.2f GB   Virtual memory top: %llX', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FHGNIJLD@Heap?5size?3?5?$CF4?42f?5MB?6?$AA@
CONST	SEGMENT
??_C@_0BF@FHGNIJLD@Heap?5size?3?5?$CF4?42f?5MB?6?$AA@ DB 'Heap size: %4.2'
	DB	'f MB', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@3f50000000000000
CONST	SEGMENT
__real@3f50000000000000 DQ 03f50000000000000r	; 0.000976563
CONST	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
CONST	ENDS
;	COMDAT ??_C@_0O@FIMOFDAK@Heap?5top?3?5?$CFp?6?$AA@
CONST	SEGMENT
??_C@_0O@FIMOFDAK@Heap?5top?3?5?$CFp?6?$AA@ DB 'Heap top: %p', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@KGNONAHO@?5?5blocks?5free?3?5?$CF6d?5?5?5?5memory?5fre@
CONST	SEGMENT
??_C@_0DH@KGNONAHO@?5?5blocks?5free?3?5?$CF6d?5?5?5?5memory?5fre@ DB '  b'
	DB	'locks free: %6d    memory free: %Iu KB, or %Iu MB ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@JIJDIJPC@blocks?5in?5use?3?5?$CF6d?5?5?5?5memory?5in?5@
CONST	SEGMENT
??_C@_0DJ@JIJDIJPC@blocks?5in?5use?3?5?$CF6d?5?5?5?5memory?5in?5@ DB 'blo'
	DB	'cks in use: %6d    memory in use: %Iu KB, or %Iu MB ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BHBJDFNE@?6?5Heapwalk?5ended?5unsuccessfully?$CB@
CONST	SEGMENT
??_C@_0CE@BHBJDFNE@?6?5Heapwalk?5ended?5unsuccessfully?$CB@ DB 0aH, ' Hea'
	DB	'pwalk ended unsuccessfully!!', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LMNNJEJE@Internal?5error?3?5Corrupt?5heap?$CB?5Me@
CONST	SEGMENT
??_C@_0DC@LMNNJEJE@Internal?5error?3?5Corrupt?5heap?$CB?5Me@ DB 'Internal'
	DB	' error: Corrupt heap! Memory is trashed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@IEDKPFGG@?5?5instance?5size?3?5?$CF4d?5bytes?$DL?5?5num@
CONST	SEGMENT
??_C@_0DF@IEDKPFGG@?5?5instance?5size?3?5?$CF4d?5bytes?$DL?5?5num@ DB '  '
	DB	'instance size: %4d bytes;  number allocated: %10d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BDIPBEJK@?5?5quantity?5size?3?5?$CF4u?5bytes?$DL?5?5num@
CONST	SEGMENT
??_C@_0DF@BDIPBEJK@?5?5quantity?5size?3?5?$CF4u?5bytes?$DL?5?5num@ DB '  '
	DB	'quantity size: %4u bytes;  number allocated: %10d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EODDMNLJ@?$CF10?410s?5size?3?5?$CF4d?5bytes?$DL?5?5number@
CONST	SEGMENT
??_C@_0DD@EODDMNLJ@?$CF10?410s?5size?3?5?$CF4d?5bytes?$DL?5?5number@ DB '%'
	DB	'10.10s size: %4d bytes;  number allocated: %10ld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MEPIDDPN@Element?5memory?3?5?$CFlu?5KB?0?5or?5?$CFlu?5M@
CONST	SEGMENT
??_C@_0CD@MEPIDDPN@Element?5memory?3?5?$CFlu?5KB?0?5or?5?$CFlu?5M@ DB 'El'
	DB	'ement memory: %lu KB, or %lu MB', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@BJNOKABH@Vertices?3?5?$CFld?5?5Edges?3?5?$CFld?5?5Facet@
CONST	SEGMENT
??_C@_0EG@BJNOKABH@Vertices?3?5?$CFld?5?5Edges?3?5?$CFld?5?5Facet@ DB 'Ve'
	DB	'rtices: %ld  Edges: %ld  Facets: %ld  Bodies: %ld  Facetedges'
	DB	': %ld', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _memory_report
_TEXT	SEGMENT
_hinfo$89545 = -96					; size = 12
_b_use$89546 = -84					; size = 4
_b_free$89547 = -80					; size = 4
tv491 = -76						; size = 8
tv488 = -76						; size = 8
tv499 = -72						; size = 4
_heapstart$89552 = -72					; size = 4
_memstat$89554 = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_memory_report PROC					; COMDAT

; 818  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 819  :     size_t mem;
; 820  :     int k;
; 821  : 
; 822  :     #ifdef MPI_EVOLVER
; 823  :     if ( this_task == 0 )
; 824  :     { mpi_count_report();
; 825  :       return;
; 826  :     }
; 827  :     else
; 828  :     #endif
; 829  :     {
; 830  :       mem = 0;
; 831  :       for ( k = 0 ; k < NUMELEMENTS ; k++ )
; 832  :         mem += (size_t)web.skel[k].count*web.sizes[k];

	mov	eax, DWORD PTR _web+64
	mov	ecx, DWORD PTR _web+176
	mov	edx, DWORD PTR _web+564
	push	ebx
	imul	edx, ecx
	push	esi
	mov	esi, DWORD PTR _web+560
	mov	ebx, DWORD PTR _web+572
	imul	esi, eax
	push	edi
	mov	edi, DWORD PTR _web+568
	add	esi, edx
	mov	edx, DWORD PTR _web+288
	imul	edi, edx
	add	esi, edi
	mov	edi, DWORD PTR _web+400
	imul	ebx, edi
	add	esi, ebx
	mov	ebx, DWORD PTR _web+576
	imul	ebx, DWORD PTR _web+512
	add	esi, ebx

; 833  : 
; 834  :       sprintf(msg,
; 835  :         "Vertices: %ld  Edges: %ld  Facets: %ld  Bodies: %ld  Facetedges: %ld\n",
; 836  :                 web.skel[0].count,web.skel[1].count,web.skel[2].count,
; 837  :                 web.skel[3].count,web.skel[4].count);

	mov	ebx, DWORD PTR _web+512
	push	ebx
	push	edi
	push	edx
	push	ecx
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0EG@BJNOKABH@Vertices?3?5?$CFld?5?5Edges?3?5?$CFld?5?5Facet@
	push	eax
	call	_sprintf

; 838  :       outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring

; 839  :       sprintf(msg, "Element memory: %lu KB, or %lu MB\n",
; 840  :            (unsigned long)(mem>>10),(unsigned long)(mem>>20));

	mov	eax, DWORD PTR _msg
	mov	edx, esi
	shr	edx, 20					; 00000014H
	push	edx
	shr	esi, 10					; 0000000aH
	push	esi
	push	OFFSET ??_C@_0CD@MEPIDDPN@Element?5memory?3?5?$CFlu?5KB?0?5or?5?$CFlu?5M@
	push	eax
	call	_sprintf

; 841  :       outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring

; 842  :     }
; 843  : 
; 844  :     if ( verbose_flag )

	xor	ebx, ebx
	add	esp, 52					; 00000034H
	cmp	DWORD PTR _verbose_flag, ebx
	je	$LN14@memory_rep

; 845  :     { /* report element sizes */
; 846  :       for ( k = 0 ; k < NUMELEMENTS ; k++ )

	mov	esi, OFFSET _web+20
	xor	edi, edi
	npad	8
$LL13@memory_rep:

; 847  :       { sprintf(msg,"%10.10s size: %4d bytes;  number allocated: %10ld\n",
; 848  :           typenames[k],web.sizes[k],web.skel[k].maxcount);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _web[edi+560]
	mov	ecx, DWORD PTR _typenames[edi]
	push	edx
	mov	edx, DWORD PTR _msg
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DD@EODDMNLJ@?$CF10?410s?5size?3?5?$CF4d?5bytes?$DL?5?5number@
	push	edx
	call	_sprintf

; 849  :         outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esi, 112				; 00000070H
	add	esp, 24					; 00000018H
	add	edi, 4
	cmp	esi, OFFSET _web+580
	jl	SHORT $LL13@memory_rep

; 850  :       }
; 851  :       sprintf(msg,"  quantity size: %4u bytes;  number allocated: %10d\n",
; 852  :           (unsigned int)sizeof(struct gen_quant),gen_quant_list_max);

	mov	ecx, DWORD PTR _gen_quant_list_max
	mov	edx, DWORD PTR _msg
	push	ecx
	push	368					; 00000170H
	push	OFFSET ??_C@_0DF@BDIPBEJK@?5?5quantity?5size?3?5?$CF4u?5bytes?$DL?5?5num@
	push	edx
	call	_sprintf

; 853  :       outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 854  :       sprintf(msg,"  instance size: %4d bytes;  number allocated: %10d\n",
; 855  :           (int)sizeof(struct method_instance),meth_inst_list_max);

	mov	ecx, DWORD PTR _meth_inst_list_max
	mov	edx, DWORD PTR _msg
	push	ecx
	push	2928					; 00000b70H
	push	OFFSET ??_C@_0DF@IEDKPFGG@?5?5instance?5size?3?5?$CF4d?5bytes?$DL?5?5num@
	push	edx
	call	_sprintf

; 856  :       outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 40					; 00000028H
$LN14@memory_rep:

; 857  :     }
; 858  : 
; 859  : #if defined(_WIN32) && defined(_HEAPOK)
; 860  : #ifndef _HEAPINFO
; 861  : #define _HEAPINFO _heapinfo
; 862  : #endif
; 863  : 
; 864  :     if ( _heapchk() != _HEAPOK )

	call	__heapchk
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN10@memory_rep

; 865  :       kb_error(1317,"Internal error: Corrupt heap! Memory is trashed.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0DC@LMNNJEJE@Internal?5error?3?5Corrupt?5heap?$CB?5Me@
	push	1317					; 00000525H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	$LN8@memory_rep
$LN10@memory_rep:

; 866  :     else if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, ebx
	je	$LN8@memory_rep

; 867  :     { struct _HEAPINFO hinfo;
; 868  :       int b_use=0,b_free=0;
; 869  :       size_t mem_use=0,mem_free=0;
; 870  :       char * heaptop = NULL; 
; 871  :       char * heapstart = NULL;

	xor	eax, eax

; 872  :       MEMORYSTATUSEX memstat;
; 873  :       int retval;
; 874  : 
; 875  :       hinfo._pentry = NULL;
; 876  :       while ( (retval = _heapwalk(&hinfo)) == _HEAPOK )

	lea	ecx, DWORD PTR _hinfo$89545[ebp]
	push	ecx
	mov	DWORD PTR _b_use$89546[ebp], ebx
	mov	DWORD PTR _b_free$89547[ebp], ebx
	xor	edi, edi
	xor	esi, esi
	mov	DWORD PTR _heapstart$89552[ebp], eax
	mov	DWORD PTR _hinfo$89545[ebp], eax
	call	__heapwalk
	add	esp, 4
	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN6@memory_rep
$LL7@memory_rep:

; 877  :       {   if ( heapstart == NULL )

	cmp	DWORD PTR _heapstart$89552[ebp], 0
	mov	ecx, DWORD PTR _hinfo$89545[ebp]
	jne	SHORT $LN5@memory_rep

; 878  :              heapstart = (char*)hinfo._pentry; 

	mov	DWORD PTR _heapstart$89552[ebp], ecx
$LN5@memory_rep:

; 879  :  
; 880  : #ifdef HEAPLIST
; 881  :          sprintf(errmsg,"%p %10ld %s end %p\n",hinfo._pentry,hinfo._size,
; 882  :              hinfo._useflag ? "used " : "free ",
; 883  :                   (char*)hinfo._pentry+hinfo._size);
; 884  :           outstring(errmsg);
; 885  : #endif
; 886  :        if (hinfo._useflag)

	cmp	DWORD PTR _hinfo$89545[ebp+8], 0

; 887  :         {   
; 888  :           b_use++; mem_use+= hinfo._size;

	mov	eax, DWORD PTR _hinfo$89545[ebp+4]
	je	SHORT $LN4@memory_rep
	inc	DWORD PTR _b_use$89546[ebp]
	add	ebx, eax
	jmp	SHORT $LN3@memory_rep
$LN4@memory_rep:

; 889  :         }
; 890  :         else { b_free++; mem_free += hinfo._size; }

	inc	DWORD PTR _b_free$89547[ebp]
	add	edi, eax
$LN3@memory_rep:

; 891  :         if ( (char*)hinfo._pentry + hinfo._size > heaptop )

	add	eax, ecx
	cmp	eax, esi
	jbe	SHORT $LN2@memory_rep

; 892  :           heaptop = (char*)hinfo._pentry + hinfo._size;

	mov	esi, eax
$LN2@memory_rep:

; 872  :       MEMORYSTATUSEX memstat;
; 873  :       int retval;
; 874  : 
; 875  :       hinfo._pentry = NULL;
; 876  :       while ( (retval = _heapwalk(&hinfo)) == _HEAPOK )

	lea	edx, DWORD PTR _hinfo$89545[ebp]
	push	edx
	call	__heapwalk
	add	esp, 4
	cmp	eax, -2					; fffffffeH
	je	SHORT $LL7@memory_rep
$LN6@memory_rep:

; 893  :       }
; 894  :       if ( retval != _HEAPEND )

	cmp	eax, -5					; fffffffbH
	je	SHORT $LN1@memory_rep

; 895  :       { sprintf(msg,"\n Heapwalk ended unsuccessfully!!\n\n");

	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0CE@BHBJDFNE@?6?5Heapwalk?5ended?5unsuccessfully?$CB@
	push	eax
	call	_sprintf

; 896  :         outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 12					; 0000000cH
$LN1@memory_rep:

; 897  :       }
; 898  :       outstring("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring

; 899  :       sprintf(errmsg,"blocks in use: %6d    memory in use: %Iu KB, or %Iu MB \n",
; 900  :                     b_use,mem_use>>10,mem_use>>20);

	mov	eax, DWORD PTR _b_use$89546[ebp]
	mov	edx, ebx
	shr	edx, 20					; 00000014H
	push	edx
	shr	ebx, 10					; 0000000aH
	push	ebx
	push	eax
	push	OFFSET ??_C@_0DJ@JIJDIJPC@blocks?5in?5use?3?5?$CF6d?5?5?5?5memory?5in?5@
	push	OFFSET _errmsg
	call	_sprintf

; 901  :       outstring(errmsg);

	push	OFFSET _errmsg
	call	_outstring

; 902  :       sprintf(errmsg,"  blocks free: %6d    memory free: %Iu KB, or %Iu MB \n",
; 903  :                  b_free,mem_free>>10,mem_free>>20);

	mov	edx, DWORD PTR _b_free$89547[ebp]
	mov	ecx, edi
	shr	ecx, 20					; 00000014H
	push	ecx
	shr	edi, 10					; 0000000aH
	push	edi
	push	edx
	push	OFFSET ??_C@_0DH@KGNONAHO@?5?5blocks?5free?3?5?$CF6d?5?5?5?5memory?5fre@
	push	OFFSET _errmsg
	call	_sprintf

; 904  :       outstring(errmsg);

	push	OFFSET _errmsg
	call	_outstring

; 905  :       sprintf(errmsg,"Heap top: %p\n",heaptop);

	push	esi
	push	OFFSET ??_C@_0O@FIMOFDAK@Heap?5top?3?5?$CFp?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 64					; 00000040H

; 906  :       outstring(errmsg);

	push	OFFSET _errmsg
	call	_outstring

; 907  :       sprintf(errmsg,"Heap size: %4.2f MB\n",
; 908  :              ((size_t )(heaptop-heapstart))/1024./1024.);

	sub	esi, DWORD PTR _heapstart$89552[ebp]
	mov	DWORD PTR tv499[ebp], esi
	fild	DWORD PTR tv499[ebp]
	jns	SHORT $LN31@memory_rep
	fadd	QWORD PTR __real@41f0000000000000
$LN31@memory_rep:
	fld	QWORD PTR __real@3f50000000000000
	push	ecx
	fmul	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BF@FHGNIJLD@Heap?5size?3?5?$CF4?42f?5MB?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 909  :       outstring(errmsg);

	push	OFFSET _errmsg
	call	_outstring
	add	esp, 20					; 00000014H

; 910  : 
; 911  :       memstat.dwLength = sizeof(memstat);
; 912  :       GlobalMemoryStatusEx(&memstat);

	lea	eax, DWORD PTR _memstat$89554[ebp]
	push	eax
	mov	DWORD PTR _memstat$89554[ebp], 64	; 00000040H
	call	DWORD PTR __imp__GlobalMemoryStatusEx@4

; 913  :       sprintf(errmsg,"Physical memory size: %4.2f GB   Virtual memory top: %llX\n",
; 914  :            (double)memstat.ullTotalPhys/1024/1024/1024,memstat.ullTotalVirtual);

	mov	ecx, DWORD PTR _memstat$89554[ebp+44]
	mov	eax, DWORD PTR _memstat$89554[ebp+12]
	push	ecx
	mov	ecx, DWORD PTR _memstat$89554[ebp+8]
	mov	edx, DWORD PTR _memstat$89554[ebp+40]
	mov	DWORD PTR tv491[ebp], ecx
	mov	ecx, eax
	and	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR tv491[ebp+4], eax
	fild	QWORD PTR tv491[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	DWORD PTR tv488[ebp+4], ecx
	mov	DWORD PTR tv488[ebp], 0
	fild	QWORD PTR tv488[ebp]
	push	edx
	sub	esp, 8
	fchs
	faddp	ST(1), ST(0)
	fld	QWORD PTR __real@3f50000000000000
	fmul	ST(1), ST(0)
	fmul	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0DL@LBMFAHHF@Physical?5memory?5size?3?5?$CF4?42f?5GB?5?5@
	push	OFFSET _errmsg
	call	_sprintf

; 915  :       outstring(errmsg);

	push	OFFSET _errmsg
	call	_outstring
	add	esp, 28					; 0000001cH
$LN8@memory_rep:

; 916  :     }
; 917  : #endif
; 918  : 
; 919  : #if defined(_UNISTD_H)
; 920  :   if ( verbose_flag )
; 921  :   { /* do this only on unix systems with unistd.h */
; 922  :     sprintf(msg,"\nTotal data memory arena %Lu\n",
; 923  :       (unsigned long long)((char*)sbrk(0)-(char*)&evolver_version));
; 924  :     outstring(msg); 
; 925  :   }
; 926  : #endif
; 927  : 
; 928  : #if defined(M_MXFAST) && defined(IRIS)
; 929  :   if ( verbose_flag ) 
; 930  :      { char *ptr;
; 931  :         struct mallinfo m;
; 932  :         /* using libmalloc.a for debugging */
; 933  :         ptr = malloc(10);
; 934  :         if ( ptr == NULL )
; 935  :           erroutstring("Bad heap.\n");
; 936  :         else myfree(ptr);
; 937  :         m = mallinfo();
; 938  :         sprintf(msg,"Arena %d     Ordblocks: %d    Orduse: %d     Ordfree: %d\n",
; 939  :             m.arena,m.ordblks,m.uordblks,m.fordblks);
; 940  :         outstring(msg);
; 941  :         sprintf(msg,"Small blocks: %d Small use: %d Small free: %d\n",
; 942  :             m.smblks,m.usmblks,m.fsmblks);
; 943  :         outstring(msg);
; 944  : }
; 945  : #endif
; 946  : 
; 947  : #if defined(SUNXX)
; 948  :     if ( memdebug )
; 949  :       if ( malloc_verify() != 1 )
; 950  :          kb_error(1318,"Internal error: Malloc_verify() failed.\n.",RECOVERABLE);
; 951  : 
; 952  : #endif
; 953  : 
; 954  :   mem_list_summary();

	call	_mem_list_summary

; 955  :   dy_check();

	call	_dy_check

; 956  : } // end memory_report()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_memory_report ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@GOIIFGMH@b_method_list?$AA@		; `string'
PUBLIC	??_C@_0O@HHCENJNM@f_method_list?$AA@		; `string'
PUBLIC	??_C@_0O@BKJMJBPC@f_next_bfacet?$AA@		; `string'
PUBLIC	??_C@_0O@IJANCJCP@f_next_vfacet?$AA@		; `string'
PUBLIC	??_C@_0M@CJEKIKAH@f_body_list?$AA@		; `string'
PUBLIC	??_C@_0N@NKPDEDNN@facet_normal?$AA@		; `string'
PUBLIC	??_C@_0L@GDEPDLNH@f_vertices?$AA@		; `string'
PUBLIC	??_C@_0BC@NDPAEDHG@f_constraint_list?$AA@	; `string'
PUBLIC	??_C@_0O@LEFPMAH@e_method_list?$AA@		; `string'
PUBLIC	??_C@_0BC@DJHGJOBE@e_constraint_list?$AA@	; `string'
PUBLIC	??_C@_0M@BPKEPMMK@e_wrap_list?$AA@		; `string'
PUBLIC	??_C@_0M@MONDCLHN@edge_vector?$AA@		; `string'
PUBLIC	??_C@_0L@PKKNFNNG@e_vertices?$AA@		; `string'
PUBLIC	??_C@_07HAFFKDBK@density?$AA@			; `string'
PUBLIC	??_C@_0BE@OFMABGFE@constraint?$FL?$FN?4normal?$AA@ ; `string'
PUBLIC	??_C@_0O@LBCEPFPF@vertex_normal?$AA@		; `string'
PUBLIC	??_C@_0O@BBJGOFLA@v_method_list?$AA@		; `string'
PUBLIC	??_C@_0BC@PNFDBPGO@v_constraint_list?$AA@	; `string'
PUBLIC	??_C@_0L@FBEPDDNP@v_velocity?$AA@		; `string'
PUBLIC	??_C@_07HDJNKPII@v_force?$AA@			; `string'
PUBLIC	??_C@_01JBBJJEPG@p?$AA@				; `string'
PUBLIC	??_C@_06NCFJEHJH@v_oldx?$AA@			; `string'
PUBLIC	??_C@_03MNNDKFGE@__x?$AA@			; `string'
PUBLIC	_reset_skeleton
EXTRN	_F_PHASE_ATTR:DWORD
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	_E_BOUNDARY_ATTR:DWORD
EXTRN	_F_BOUNDARY_ATTR:DWORD
EXTRN	_B_PHASE_ATTR:DWORD
EXTRN	_add_attribute:PROC
EXTRN	_gauss1Dwt:DWORD
EXTRN	_gauss1Dpt:DWORD
;	COMDAT ??_C@_0O@GOIIFGMH@b_method_list?$AA@
CONST	SEGMENT
??_C@_0O@GOIIFGMH@b_method_list?$AA@ DB 'b_method_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HHCENJNM@f_method_list?$AA@
CONST	SEGMENT
??_C@_0O@HHCENJNM@f_method_list?$AA@ DB 'f_method_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BKJMJBPC@f_next_bfacet?$AA@
CONST	SEGMENT
??_C@_0O@BKJMJBPC@f_next_bfacet?$AA@ DB 'f_next_bfacet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IJANCJCP@f_next_vfacet?$AA@
CONST	SEGMENT
??_C@_0O@IJANCJCP@f_next_vfacet?$AA@ DB 'f_next_vfacet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CJEKIKAH@f_body_list?$AA@
CONST	SEGMENT
??_C@_0M@CJEKIKAH@f_body_list?$AA@ DB 'f_body_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NKPDEDNN@facet_normal?$AA@
CONST	SEGMENT
??_C@_0N@NKPDEDNN@facet_normal?$AA@ DB 'facet_normal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GDEPDLNH@f_vertices?$AA@
CONST	SEGMENT
??_C@_0L@GDEPDLNH@f_vertices?$AA@ DB 'f_vertices', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NDPAEDHG@f_constraint_list?$AA@
CONST	SEGMENT
??_C@_0BC@NDPAEDHG@f_constraint_list?$AA@ DB 'f_constraint_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LEFPMAH@e_method_list?$AA@
CONST	SEGMENT
??_C@_0O@LEFPMAH@e_method_list?$AA@ DB 'e_method_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DJHGJOBE@e_constraint_list?$AA@
CONST	SEGMENT
??_C@_0BC@DJHGJOBE@e_constraint_list?$AA@ DB 'e_constraint_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BPKEPMMK@e_wrap_list?$AA@
CONST	SEGMENT
??_C@_0M@BPKEPMMK@e_wrap_list?$AA@ DB 'e_wrap_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MONDCLHN@edge_vector?$AA@
CONST	SEGMENT
??_C@_0M@MONDCLHN@edge_vector?$AA@ DB 'edge_vector', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PKKNFNNG@e_vertices?$AA@
CONST	SEGMENT
??_C@_0L@PKKNFNNG@e_vertices?$AA@ DB 'e_vertices', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HAFFKDBK@density?$AA@
CONST	SEGMENT
??_C@_07HAFFKDBK@density?$AA@ DB 'density', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OFMABGFE@constraint?$FL?$FN?4normal?$AA@
CONST	SEGMENT
??_C@_0BE@OFMABGFE@constraint?$FL?$FN?4normal?$AA@ DB 'constraint[].norma'
	DB	'l', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LBCEPFPF@vertex_normal?$AA@
CONST	SEGMENT
??_C@_0O@LBCEPFPF@vertex_normal?$AA@ DB 'vertex_normal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BBJGOFLA@v_method_list?$AA@
CONST	SEGMENT
??_C@_0O@BBJGOFLA@v_method_list?$AA@ DB 'v_method_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PNFDBPGO@v_constraint_list?$AA@
CONST	SEGMENT
??_C@_0BC@PNFDBPGO@v_constraint_list?$AA@ DB 'v_constraint_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FBEPDDNP@v_velocity?$AA@
CONST	SEGMENT
??_C@_0L@FBEPDDNP@v_velocity?$AA@ DB 'v_velocity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HDJNKPII@v_force?$AA@
CONST	SEGMENT
??_C@_07HDJNKPII@v_force?$AA@ DB 'v_force', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JBBJJEPG@p?$AA@
CONST	SEGMENT
??_C@_01JBBJJEPG@p?$AA@ DB 'p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NCFJEHJH@v_oldx?$AA@
CONST	SEGMENT
??_C@_06NCFJEHJH@v_oldx?$AA@ DB 'v_oldx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MNNDKFGE@__x?$AA@
CONST	SEGMENT
??_C@_03MNNDKFGE@__x?$AA@ DB '__x', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _reset_skeleton
_TEXT	SEGMENT
_three$ = -12						; size = 4
_perm$ = -8						; size = 4
_maxperm$ = -4						; size = 4
_reset_skeleton PROC					; COMDAT

; 969  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 970  :   int i;
; 971  :   int three = FACET_VERTS;
; 972  :   int permcount = web.perm_global_count;
; 973  :   int maxperm   = web.max_perm_globals;

	mov	eax, DWORD PTR _web+5552

; 974  :   struct global **perm = dy_perm_globals;

	mov	ecx, DWORD PTR _web+5656
	push	ebx
	push	esi

; 975  : 
; 976  :   ENTER_GRAPH_MUTEX

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	push	edi
	mov	edi, DWORD PTR _web+5548
	mov	DWORD PTR _three$[ebp], 3
	mov	DWORD PTR _maxperm$[ebp], eax
	mov	DWORD PTR _perm$[ebp], ecx
	call	esi
	xor	ebx, ebx
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN6@reset_skel
	push	ebx
	push	100000					; 000186a0H
	push	ebx
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	lea	esi, DWORD PTR [ebx+1]
	jmp	SHORT $LN5@reset_skel
$LN6@reset_skel:
	xor	esi, esi
$LN5@reset_skel:

; 977  : 
; 978  :   gauss1Dpt = NULL; 
; 979  :   gauss1Dwt = NULL;
; 980  : 
; 981  :   memset((char *)&web,0,sizeof(web));  /* total clean out */

	push	5704					; 00001648H
	push	ebx
	push	OFFSET _web
	mov	DWORD PTR _gauss1Dpt, ebx
	mov	DWORD PTR _gauss1Dwt, ebx
	call	_memset

; 982  :   
; 983  :   web.perm_global_count = permcount;
; 984  :   web.max_perm_globals = maxperm;
; 985  :   dy_perm_globals = perm;

	mov	eax, DWORD PTR _perm$[ebp]
	mov	edx, DWORD PTR _maxperm$[ebp]
	mov	DWORD PTR _web+5656, eax

; 986  : 
; 987  :   web.sizes[VERTEX] = sizeof(struct vertex);
; 988  :   web.sizes[EDGE] = sizeof(struct edge);
; 989  :   web.sizes[FACET] = sizeof(struct facet);
; 990  :   web.sizes[BODY] = sizeof(struct body);

	mov	eax, 424				; 000001a8H
	mov	DWORD PTR _web+5548, edi
	mov	DWORD PTR _web+5552, edx
	mov	edi, 40					; 00000028H
	mov	edx, 64					; 00000040H
	mov	ecx, 56					; 00000038H
	mov	DWORD PTR _web+572, eax

; 991  :   web.sizes[FACETEDGE] = sizeof(struct facetedge);
; 992  :   web.usedsizes[VERTEX] = sizeof(struct vertex);
; 993  :   web.usedsizes[EDGE] = sizeof(struct edge);
; 994  :   web.usedsizes[FACET] = sizeof(struct facet);
; 995  :   web.usedsizes[BODY] = sizeof(struct body);

	mov	DWORD PTR _web+592, eax

; 996  :   web.usedsizes[FACETEDGE] = sizeof(struct facetedge);
; 997  : 
; 998  :   for ( i = 0 ; i < NUMELEMENTS ; i++ ) 
; 999  :   { web.skel[i].max_ord = -1;

	or	eax, -1
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _web+560, edi
	mov	DWORD PTR _web+564, edx
	mov	DWORD PTR _web+568, ecx
	mov	DWORD PTR _web+576, 48			; 00000030H
	mov	DWORD PTR _web+580, edi
	mov	DWORD PTR _web+584, edx
	mov	DWORD PTR _web+588, ecx
	mov	DWORD PTR _web+596, 48			; 00000030H
	mov	DWORD PTR _web+68, eax

; 1000 :     blocklist[i] = NULL;

	mov	DWORD PTR _blocklist, ebx

; 1001 :     blockmax[i] = blockcount[i] = 0;

	mov	DWORD PTR _blockcount, ebx
	mov	DWORD PTR _blockmax, ebx
	mov	DWORD PTR _web+180, eax
	mov	DWORD PTR _blocklist+4, ebx
	mov	DWORD PTR _blockcount+4, ebx
	mov	DWORD PTR _blockmax+4, ebx
	mov	DWORD PTR _web+292, eax
	mov	DWORD PTR _blocklist+8, ebx
	mov	DWORD PTR _blockcount+8, ebx
	mov	DWORD PTR _blockmax+8, ebx
	mov	DWORD PTR _web+404, eax
	mov	DWORD PTR _blocklist+12, ebx
	mov	DWORD PTR _blockcount+12, ebx
	mov	DWORD PTR _blockmax+12, ebx
	mov	DWORD PTR _web+516, eax
	mov	DWORD PTR _blocklist+16, ebx
	mov	DWORD PTR _blockcount+16, ebx
	mov	DWORD PTR _blockmax+16, ebx

; 1002 :   }
; 1003 :   vibase = NULL;

	mov	DWORD PTR _vibase, ebx

; 1004 :   eibase = NULL;

	mov	DWORD PTR _eibase, ebx

; 1005 :   fibase = NULL;

	mov	DWORD PTR _fibase, ebx

; 1006 :   bibase = NULL;

	mov	DWORD PTR _bibase, ebx

; 1007 :   feibase = NULL;

	mov	DWORD PTR _feibase, ebx

; 1008 : 
; 1009 :   web.skel[EDGE].dimension = 1;

	mov	DWORD PTR _web+116, 1

; 1010 :   web.skel[FACET].dimension = 2;

	mov	DWORD PTR _web+228, 2

; 1011 :   web.skel[BODY].dimension = 3;

	mov	DWORD PTR _web+340, 3

; 1012 : 
; 1013 :   LEAVE_GRAPH_MUTEX 

	cmp	esi, ebx
	je	SHORT $LN1@reset_skel
	mov	ecx, DWORD PTR _graphmutex
	push	ecx
	mov	DWORD PTR _locking_thread, ebx
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@reset_skel:

; 1014 : 
; 1015 :   /* set up permanent attributes, empty to start with */
; 1016 :   /* have REAL attributes first, so can align on 8-byte */
; 1017 :   /* Be sure the order given here is same as order in skeleton.h */
; 1018 :   /* following each element structure definition. */
; 1019 :   /* vertex */
; 1020 : 
; 1021 : 
; 1022 :   add_attribute(VERTEX,"__x",REAL_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	1
	push	OFFSET ??_C@_03MNNDKFGE@__x?$AA@
	push	ebx
	call	_add_attribute

; 1023 :   EXTRAS(VERTEX)[V_COORD_ATTR].flags |= RECALC_ATTR;

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem

; 1024 :   EXTRAS(VERTEX)[V_COORD_ATTR].array_spec.flags |= FIXED_SIZE_ARRAY;
; 1025 : 
; 1026 :   add_attribute(VERTEX,"v_oldx",REAL_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	1
	mov	esi, 8
	or	DWORD PTR [eax+ecx+232], esi
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	push	OFFSET ??_C@_06NCFJEHJH@v_oldx?$AA@
	mov	edi, 268435456				; 10000000H
	or	DWORD PTR [eax+ecx+72], edi
	push	ebx
	call	_add_attribute

; 1027 :   EXTRAS(VERTEX)[V_OLDCOORD_ATTR].array_spec.flags |= FIXED_SIZE_ARRAY;

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+312], edi
	add	esp, 64					; 00000040H

; 1028 : 
; 1029 :   add_attribute(VERTEX,"p",REAL_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	1
	push	OFFSET ??_C@_01JBBJJEPG@p?$AA@
	push	ebx
	call	_add_attribute

; 1030 :   EXTRAS(VERTEX)[V_PARAM_ATTR].flags |= RECALC_ATTR;

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+712], esi

; 1031 :   EXTRAS(VERTEX)[V_PARAM_ATTR].array_spec.flags |= FIXED_SIZE_ARRAY;

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+552], edi

; 1032 : 
; 1033 :   add_attribute(VERTEX,"v_force",REAL_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	1
	push	OFFSET ??_C@_07HDJNKPII@v_force?$AA@
	push	ebx
	call	_add_attribute

; 1034 :   EXTRAS(VERTEX)[V_FORCE_ATTR].flags |= READ_ONLY_ATTR;

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	esp, 64					; 00000040H

; 1035 :   EXTRAS(VERTEX)[V_FORCE_ATTR].array_spec.flags |= FIXED_SIZE_ARRAY;
; 1036 : 
; 1037 :   add_attribute(VERTEX,"v_velocity",REAL_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	1
	mov	esi, 16					; 00000010H
	or	DWORD PTR [eax+ecx+952], esi
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+792], edi
	push	OFFSET ??_C@_0L@FBEPDDNP@v_velocity?$AA@
	push	ebx
	call	_add_attribute

; 1038 :   EXTRAS(VERTEX)[V_VELOCITY_ATTR].flags |= READ_ONLY_ATTR;

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+1192], esi

; 1039 :   EXTRAS(VERTEX)[V_VELOCITY_ATTR].array_spec.flags |= FIXED_SIZE_ARRAY;

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+1032], edi

; 1040 : 
; 1041 :   add_attribute(VERTEX,"v_constraint_list",INTEGER_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	2
	push	OFFSET ??_C@_0BC@PNFDBPGO@v_constraint_list?$AA@
	push	ebx
	call	_add_attribute

; 1042 :   EXTRAS(VERTEX)[V_CONSTR_LIST_ATTR].flags |= READ_ONLY_ATTR;

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+1432], esi
	add	esp, 64					; 00000040H

; 1043 : 
; 1044 :   web.meth_attr[VERTEX] = 
; 1045 :         add_attribute(VERTEX,"v_method_list",INTEGER_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	2
	push	OFFSET ??_C@_0O@BBJGOFLA@v_method_list?$AA@
	push	ebx
	call	_add_attribute

; 1046 :   EXTRAS(VERTEX)[web.meth_attr[VERTEX]].flags |= READ_ONLY_ATTR;

	mov	edx, DWORD PTR _dymem
	mov	DWORD PTR _web+5664, eax
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	or	DWORD PTR [eax+edx+232], esi

; 1047 : 
; 1048 :   add_attribute(VERTEX,"vertex_normal",REAL_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	1
	lea	eax, DWORD PTR [eax+edx+232]
	push	OFFSET ??_C@_0O@LBCEPFPF@vertex_normal?$AA@
	push	ebx
	call	_add_attribute

; 1049 :   EXTRAS(VERTEX)[V_NORMAL_ATTR].flags |= READ_ONLY_ATTR|VIRTUAL_ATTR;

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+1912], 48		; 00000030H

; 1050 :   EXTRAS(VERTEX)[V_NORMAL_ATTR].array_spec.flags |= FIXED_SIZE_ARRAY;

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+1752], edi
	add	esp, 64					; 00000040H

; 1051 : 
; 1052 :   add_attribute(VERTEX,"constraint[].normal",REAL_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	1
	push	OFFSET ??_C@_0BE@OFMABGFE@constraint?$FL?$FN?4normal?$AA@
	push	ebx
	call	_add_attribute

; 1053 :   EXTRAS(VERTEX)[V_CONSTRAINT_NORMAL_ATTR].flags |= READ_ONLY_ATTR|VIRTUAL_ATTR;

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+2152], 48		; 00000030H

; 1054 :   EXTRAS(VERTEX)[V_CONSTRAINT_NORMAL_ATTR].array_spec.flags |= FIXED_SIZE_ARRAY;

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+1992], edi

; 1055 : 
; 1056 :   /* edge */
; 1057 :   add_attribute(EDGE,"density",REAL_TYPE,0,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	OFFSET ??_C@_07HAFFKDBK@density?$AA@
	push	1
	call	_add_attribute
	add	esp, 64					; 00000040H

; 1058 :   add_attribute(EDGE,"e_vertices",ELEMENTID_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	18					; 00000012H
	push	OFFSET ??_C@_0L@PKKNFNNG@e_vertices?$AA@
	push	1
	call	_add_attribute

; 1059 :   EXTRAS(EDGE)[E_VERTICES_ATTR].flags |= READ_ONLY_ATTR;

	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+472], esi

; 1060 : 
; 1061 :   add_attribute(EDGE,"edge_vector",REAL_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);/*dummy*/

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	1
	push	OFFSET ??_C@_0M@MONDCLHN@edge_vector?$AA@
	push	1
	call	_add_attribute

; 1062 :   EXTRAS(EDGE)[E_VECTOR_ATTR].flags |= READ_ONLY_ATTR|VIRTUAL_ATTR;

	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+712], 48		; 00000030H

; 1063 :   EXTRAS(EDGE)[E_VECTOR_ATTR].array_spec.flags |= FIXED_SIZE_ARRAY;

	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+552], edi
	add	esp, 64					; 00000040H

; 1064 : 
; 1065 :   add_attribute(EDGE,"e_wrap_list",INTEGER_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	2
	push	OFFSET ??_C@_0M@BPKEPMMK@e_wrap_list?$AA@
	push	1
	call	_add_attribute

; 1066 :   EXTRAS(EDGE)[E_WRAP_ATTR].array_spec.flags |= FIXED_SIZE_ARRAY;

	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+792], edi

; 1067 : 
; 1068 :   add_attribute(EDGE,"e_constraint_list",INTEGER_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	2
	push	OFFSET ??_C@_0BC@DJHGJOBE@e_constraint_list?$AA@
	push	1
	call	_add_attribute

; 1069 :   EXTRAS(EDGE)[E_CONSTR_LIST_ATTR].flags |= READ_ONLY_ATTR;

	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+1192], esi
	add	esp, 64					; 00000040H

; 1070 : 
; 1071 :   web.meth_attr[EDGE] = 
; 1072 :         add_attribute(EDGE,"e_method_list",INTEGER_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	2
	push	OFFSET ??_C@_0O@LEFPMAH@e_method_list?$AA@
	push	1
	call	_add_attribute

; 1073 :   EXTRAS(EDGE)[web.meth_attr[EDGE]].flags |= READ_ONLY_ATTR;

	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR _web+5668, eax
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	or	DWORD PTR [eax+ecx+232], esi

; 1074 : 
; 1075 :   /* facet */
; 1076 :   add_attribute(FACET,"f_constraint_list",INTEGER_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	2
	lea	eax, DWORD PTR [eax+ecx+232]
	push	OFFSET ??_C@_0BC@NDPAEDHG@f_constraint_list?$AA@
	push	2
	call	_add_attribute

; 1077 :   EXTRAS(FACET)[F_CONSTR_LIST_ATTR].flags |= READ_ONLY_ATTR;

	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+232], esi
	add	esp, 64					; 00000040H

; 1078 : 
; 1079 :   add_attribute(FACET,"f_vertices",ELEMENTID_TYPE,1,&three,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	lea	edx, DWORD PTR _three$[ebp]
	push	edx
	push	1
	push	18					; 00000012H
	push	OFFSET ??_C@_0L@GDEPDLNH@f_vertices?$AA@
	push	2
	call	_add_attribute

; 1080 :   EXTRAS(FACET)[F_VERTICES_ATTR].flags |= READ_ONLY_ATTR;

	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+472], esi

; 1081 : 
; 1082 :   add_attribute(FACET,"facet_normal",REAL_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	1
	push	OFFSET ??_C@_0N@NKPDEDNN@facet_normal?$AA@
	push	2
	call	_add_attribute

; 1083 :   EXTRAS(FACET)[F_NORMAL_ATTR].flags |= READ_ONLY_ATTR|VIRTUAL_ATTR;

	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+712], 48		; 00000030H

; 1084 :   EXTRAS(FACET)[F_NORMAL_ATTR].array_spec.flags |= FIXED_SIZE_ARRAY;

	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+552], edi
	add	esp, 64					; 00000040H

; 1085 : 
; 1086 :   add_attribute(FACET,"f_body_list",ELEMENTID_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	18					; 00000012H
	push	OFFSET ??_C@_0M@CJEKIKAH@f_body_list?$AA@
	push	2
	call	_add_attribute

; 1087 :   EXTRAS(FACET)[F_BODY_LIST_ATTR].flags |= READ_ONLY_ATTR;

	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+952], esi

; 1088 : 
; 1089 :   add_attribute(FACET,"f_next_vfacet",ELEMENTID_TYPE,0,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	18					; 00000012H
	push	OFFSET ??_C@_0O@IJANCJCP@f_next_vfacet?$AA@
	push	2
	call	_add_attribute

; 1090 :   EXTRAS(FACET)[F_NEXT_VFACET_ATTR].flags |= READ_ONLY_ATTR;

	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+1192], esi
	add	esp, 64					; 00000040H

; 1091 : 
; 1092 :   add_attribute(FACET,"f_next_bfacet",ELEMENTID_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	18					; 00000012H
	push	OFFSET ??_C@_0O@BKJMJBPC@f_next_bfacet?$AA@
	push	2
	call	_add_attribute

; 1093 :   EXTRAS(FACET)[F_NEXT_BFACET_ATTR].flags |= READ_ONLY_ATTR;

	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	or	DWORD PTR [eax+ecx+1432], esi

; 1094 : 
; 1095 :   web.meth_attr[FACET] = 
; 1096 :         add_attribute(FACET,"f_method_list",INTEGER_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	2
	push	OFFSET ??_C@_0O@HHCENJNM@f_method_list?$AA@
	push	2
	call	_add_attribute

; 1097 :   EXTRAS(FACET)[web.meth_attr[FACET]].flags |= READ_ONLY_ATTR;

	mov	ecx, DWORD PTR _dymem
	add	esp, 64					; 00000040H
	mov	DWORD PTR _web+5672, eax
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	or	DWORD PTR [eax+ecx+232], esi

; 1098 : 
; 1099 : 
; 1100 :   /* body */
; 1101 :   web.meth_attr[BODY] = 
; 1102 :         add_attribute(BODY,"b_method_list",INTEGER_TYPE,1,NULL,0,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	1
	push	2
	lea	eax, DWORD PTR [eax+ecx+232]
	push	OFFSET ??_C@_0O@GOIIFGMH@b_method_list?$AA@
	push	3
	call	_add_attribute

; 1103 :   EXTRAS(BODY)[web.meth_attr[BODY]].flags |= READ_ONLY_ATTR;

	mov	edx, DWORD PTR _dymem
	mov	DWORD PTR _web+5676, eax
	imul	eax, 240				; 000000f0H
	add	esp, 32					; 00000020H
	add	eax, DWORD PTR _web+440
	lea	eax, DWORD PTR [eax+edx+232]
	or	DWORD PTR [eax], esi
	pop	edi
	pop	esi

; 1104 :  
; 1105 : 
; 1106 :   F_PHASE_ATTR = V_BOUNDARY_ATTR = E_BOUNDARY_ATTR = 
; 1107 :     F_BOUNDARY_ATTR = B_PHASE_ATTR = 0;

	mov	DWORD PTR _B_PHASE_ATTR, ebx
	mov	DWORD PTR _F_BOUNDARY_ATTR, ebx
	mov	DWORD PTR _E_BOUNDARY_ATTR, ebx
	mov	DWORD PTR _V_BOUNDARY_ATTR, ebx
	mov	DWORD PTR _F_PHASE_ATTR, ebx
	pop	ebx

; 1108 : 
; 1109 : #ifdef MPI_EVOLVER
; 1110 :   { int m = MPI_EXPORT_MAX;
; 1111 :     web.mpi_export_attr[VERTEX] = 
; 1112 :         add_attribute(VERTEX,"__mpi_export_v",USHORT_TYPE,1,&m,0,NULL,MPI_NO_PROPAGATE);
; 1113 :     web.mpi_export_attr[EDGE] = 
; 1114 :         add_attribute(EDGE,"__mpi_export_e",USHORT_TYPE,1,&m,0,NULL,MPI_NO_PROPAGATE);
; 1115 :     web.mpi_export_attr[FACET] = 
; 1116 :         add_attribute(FACET,"__mpi_export_f",USHORT_TYPE,1,&m,0,NULL,MPI_NO_PROPAGATE);
; 1117 :     web.mpi_export_attr[BODY] = 
; 1118 :         add_attribute(BODY,"__mpi_export_b",USHORT_TYPE,1,&m,0,NULL,MPI_NO_PROPAGATE);
; 1119 :     web.mpi_export_attr[FACETEDGE] = 
; 1120 :         add_attribute(FACETEDGE,"__mpi_export_fe",USHORT_TYPE,1,&m,0,NULL,MPI_NO_PROPAGATE);
; 1121 :     mpi_export_voffset = EXTRAS(VERTEX)[web.mpi_export_attr[VERTEX]].offset;
; 1122 :     mpi_export_eoffset = EXTRAS(EDGE)[web.mpi_export_attr[EDGE]].offset;
; 1123 :     mpi_export_foffset = EXTRAS(FACET)[web.mpi_export_attr[FACET]].offset;
; 1124 :     mpi_export_boffset = EXTRAS(BODY)[web.mpi_export_attr[BODY]].offset;
; 1125 :     mpi_export_feoffset = EXTRAS(FACETEDGE)[web.mpi_export_attr[FACETEDGE]].offset;
; 1126 :   }
; 1127 : #endif
; 1128 :   
; 1129 : } // end reset_skeleton()

	mov	esp, ebp
	pop	ebp
	ret	0
_reset_skeleton ENDP
_TEXT	ENDS
PUBLIC	_free_discards
; Function compile flags: /Ogtp
;	COMDAT _free_discards
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_free_discards PROC					; COMDAT

; 1139 : { int type;

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 1140 : 
; 1141 :   for ( type = 0 ; type < NUMELEMENTS ; type++ )

	mov	edi, OFFSET _web+28
	npad	5
$LL13@free_disca:

; 1142 :   { element_id id,next_id;
; 1143 :     int small_potatoes = (mode==DISCARDS_ALL) ? 0 : web.skel[type].count/10; 

	cmp	DWORD PTR _mode$[ebp], 1
	jne	SHORT $LN16@free_disca
	xor	eax, eax
	jmp	SHORT $LN17@free_disca
$LN16@free_disca:
	mov	eax, 1717986919				; 66666667H
	imul	DWORD PTR [edi+36]
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$LN17@free_disca:

; 1144 :     if ( web.skel[type].discard_count <= small_potatoes )

	cmp	DWORD PTR [edi+32], eax
	jle	$LN12@free_disca

; 1145 :        continue; /* don't bother with small potatoes */
; 1146 :     id = web.skel[type].used;

	mov	edx, DWORD PTR [edi+20]

; 1147 :     while ( valid_id(id) )

	test	edx, 268435456				; 10000000H
	je	$LN8@free_disca
$LL9@free_disca:

; 1148 :     { struct element *ptr = elptr(id);

	mov	eax, edx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	eax, DWORD PTR _web[eax+12]
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]

; 1149 :       next_id = ptr->forechain;
; 1150 :       if ( !(ptr->attr & ALLOCATED) )

	mov	eax, DWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [ecx]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	jne	$LN23@free_disca

; 1151 :       { /* move to free list */
; 1152 : #ifdef MPI_EVOLVER
; 1153 :         element_id loc_id = ptr->local_id;
; 1154 : #else
; 1155 :         element_id loc_id = id;
; 1156 : #endif
; 1157 :         if ( valid_id(ptr->forechain) )

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN6@free_disca

; 1158 :           elptr(ptr->forechain)->backchain = ptr->backchain;

	mov	eax, ebx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	eax, DWORD PTR _web[eax+12]
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	jmp	SHORT $LN5@free_disca
$LN6@free_disca:

; 1159 :         else web.skel[type].last = ptr->backchain;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+24], eax
$LN5@free_disca:

; 1160 :         if ( valid_id(ptr->backchain) )

	mov	eax, DWORD PTR [ecx+4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@free_disca

; 1161 :           elptr(ptr->backchain)->forechain = ptr->forechain;

	mov	esi, eax
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	esi, DWORD PTR _web[esi+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN3@free_disca
$LN4@free_disca:

; 1162 :         else web.skel[type].used = ptr->forechain;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+20], eax
$LN3@free_disca:

; 1163 : 
; 1164 : #ifdef HASH_ID
; 1165 :         *(struct element **)&(ptr->forechain) = web.skel[type].freehead; 
; 1166 :         web.skel[type].freehead = ptr;
; 1167 :         elhash_delete(id);
; 1168 :         ptr->self_id = NULLID;
; 1169 :         web.skel[type].alloc--;
; 1170 : #else
; 1171 :         if ( valid_id(web.skel[type].free) )

	mov	eax, DWORD PTR [edi]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2@free_disca

; 1172 :           elptr(web.skel[type].free)->backchain = loc_id;

	mov	esi, eax
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	esi, DWORD PTR _web[esi+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [eax+4], edx

; 1173 :         else

	jmp	SHORT $LN1@free_disca
$LN2@free_disca:

; 1174 :           web.skel[type].freelast = loc_id;

	mov	DWORD PTR [edi+4], edx
$LN1@free_disca:

; 1175 : 
; 1176 :         ptr->forechain = web.skel[type].free;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax

; 1177 :         ptr->backchain = NULLID;

	mov	DWORD PTR [ecx+4], 0

; 1178 :         web.skel[type].free = loc_id;

	mov	DWORD PTR [edi], edx
$LN23@free_disca:

; 1179 : #endif
; 1180 :       }
; 1181 :       id = next_id;

	mov	edx, ebx
	test	ebx, 268435456				; 10000000H
	jne	$LL9@free_disca
$LN8@free_disca:

; 1182 :     }
; 1183 :     web.skel[type].discard_count = 0;

	mov	DWORD PTR [edi+32], 0
$LN12@free_disca:

; 1140 : 
; 1141 :   for ( type = 0 ; type < NUMELEMENTS ; type++ )

	add	edi, 112				; 00000070H
	cmp	edi, OFFSET _web+588
	jl	$LL13@free_disca
	pop	edi
	pop	esi
	pop	ebx

; 1184 :   }
; 1185 : 
; 1186 : } // end free_discards()

	pop	ebp
	ret	0
_free_discards ENDP
_TEXT	ENDS
PUBLIC	_esort
_BSS	SEGMENT
_key_offset DD	01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _esort
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_esort	PROC						; COMDAT

; 1305 : { if ( *(REAL*)(a+key_offset) < *(REAL*)(b+key_offset) ) return -1;

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _key_offset
	mov	edx, DWORD PTR _a$[ebp]
	push	esi
	mov	esi, DWORD PTR _b$[ebp]
	fld	QWORD PTR [ecx+esi]
	fcomp	QWORD PTR [ecx+edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@esort
	or	eax, -1
	pop	esi

; 1308 : }

	pop	ebp
	ret	0
$LN2@esort:

; 1306 :   if ( *(REAL*)(a+key_offset) > *(REAL*)(b+key_offset) ) return  1;

	fld	QWORD PTR [ecx+esi]
	fcomp	QWORD PTR [ecx+edx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@esort
	mov	eax, 1
	pop	esi

; 1308 : }

	pop	ebp
	ret	0
$LN1@esort:

; 1307 :   return 0;

	xor	eax, eax
	pop	esi

; 1308 : }

	pop	ebp
	ret	0
_esort	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@FOEAGPAN@reorder_storage?3?5?$CFs?5attribute?5no@ ; `string'
PUBLIC	_reorder_storage
EXTRN	_top_timestamp:DWORD
EXTRN	_global_timestamp:DWORD
EXTRN	_qsort:PROC
EXTRN	_kb_stricmp:PROC
;	COMDAT ??_C@_0CM@FOEAGPAN@reorder_storage?3?5?$CFs?5attribute?5no@
CONST	SEGMENT
??_C@_0CM@FOEAGPAN@reorder_storage?3?5?$CFs?5attribute?5no@ DB 'reorder_s'
	DB	'torage: %s attribute not defined.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _reorder_storage
_TEXT	SEGMENT
_newblock$ = -24					; size = 20
tv1537 = -4						; size = 4
tv1429 = -4						; size = 4
tv1371 = -4						; size = 4
_reorder_storage PROC					; COMDAT

; 1311 : { struct element *newblock[NUMELEMENTS];

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi

; 1312 :   int i,j,n;
; 1313 : 
; 1314 :   free_discards(DISCARDS_ALL);

	push	1
	call	_free_discards
	add	esp, 4
	mov	esi, OFFSET _web+20

; 1315 : 
; 1316 :   /* allocate single-block space for each type  */
; 1317 :   for ( n = 0 ; n < NUMELEMENTS ; n++ )

	xor	ebx, ebx
	npad	6
$LL43@reorder_st:

; 1318 :     newblock[n] = (struct element *)mycalloc(web.skel[n].maxcount+1,
; 1319 :                           web.sizes[n]);

	mov	eax, DWORD PTR _web[ebx+560]
	mov	ecx, DWORD PTR [esi]
	push	1319					; 00000527H
	push	OFFSET ??_C@_09EOIFBANE@STORAGE?4C?$AA@
	push	eax
	inc	ecx
	push	ecx
	call	_kb_calloc
	mov	DWORD PTR _newblock$[ebp+ebx], eax
	add	esi, 112				; 00000070H
	add	esp, 16					; 00000010H
	add	ebx, 4
	cmp	esi, OFFSET _web+580
	jl	SHORT $LL43@reorder_st

; 1320 :   
; 1321 :   /* copy element structures. */
; 1322 :   for ( n = 0 ; n < NUMELEMENTS ; n++ )

	mov	ecx, OFFSET _web+28
	mov	DWORD PTR tv1371[ebp], ecx
	xor	ebx, ebx
	npad	7
$LL40@reorder_st:

; 1323 :   { element_id id = web.skel[n].used;

	mov	eax, DWORD PTR [ecx+20]

; 1324 :     char *spot = (char*)(newblock[n]);

	mov	esi, DWORD PTR _newblock$[ebp+ebx]

; 1325 :     while ( valid_id(id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN36@reorder_st

; 1330 :     }
; 1331 :     #ifndef HASH_ID
; 1332 :     /* free list at end */
; 1333 :     id = web.skel[n].free;

	mov	ecx, DWORD PTR _web[ebx+560]
$LL37@reorder_st:

; 1326 :     { struct element *ep = elptr(id);

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+eax*4]

; 1327 :       memcpy(spot,(char*)ep,web.sizes[n]);

	push	ecx
	push	edi
	push	esi
	call	_memcpy

; 1328 :       id = ep->forechain;
; 1329 :       spot += web.sizes[n];

	mov	ecx, DWORD PTR _web[ebx+560]
	mov	eax, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	add	esi, ecx
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL37@reorder_st

; 1325 :     while ( valid_id(id) )

	mov	ecx, DWORD PTR tv1371[ebp]
$LN36@reorder_st:

; 1330 :     }
; 1331 :     #ifndef HASH_ID
; 1332 :     /* free list at end */
; 1333 :     id = web.skel[n].free;

	mov	eax, DWORD PTR [ecx]

; 1334 :     while ( valid_id(id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN39@reorder_st

; 1320 :   
; 1321 :   /* copy element structures. */
; 1322 :   for ( n = 0 ; n < NUMELEMENTS ; n++ )

	mov	ecx, DWORD PTR _web[ebx+560]
$LL35@reorder_st:

; 1335 :     { struct element *ep = elptr(id);

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+eax*4]

; 1336 :       memcpy(spot,(char*)ep,web.sizes[n]);

	push	ecx
	push	edi
	push	esi
	call	_memcpy

; 1337 :       id = ep->forechain;
; 1338 :       spot += web.sizes[n];

	mov	ecx, DWORD PTR _web[ebx+560]
	mov	eax, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	add	esi, ecx
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL35@reorder_st

; 1334 :     while ( valid_id(id) )

	mov	ecx, DWORD PTR tv1371[ebp]
$LN39@reorder_st:

; 1320 :   
; 1321 :   /* copy element structures. */
; 1322 :   for ( n = 0 ; n < NUMELEMENTS ; n++ )

	add	ecx, 112				; 00000070H
	add	ebx, 4
	mov	DWORD PTR tv1371[ebp], ecx
	cmp	ecx, OFFSET _web+588
	jl	$LL40@reorder_st

; 1339 :     }
; 1340 :     #endif
; 1341 :   }
; 1342 : 
; 1343 :   /* sort elements in use */
; 1344 :   for ( i = 0 ; i < NUMELEMENTS ; i++ )

	mov	ebx, OFFSET _web+108
	mov	DWORD PTR tv1429[ebp], 0
	npad	2
$LL98@reorder_st:

; 1345 :   { struct extra *ex;
; 1346 :     int k;
; 1347 :      
; 1348 :     if ( web.skel[i].count == 0 ) continue;

	cmp	DWORD PTR [ebx-44], 0
	je	$LN32@reorder_st

; 1349 :     key_offset = -1; /* sentinel value */
; 1350 :     for ( k = 0, ex = EXTRAS(i) ; k < web.skel[i].extra_count ; k++ , ex++ )

	mov	esi, DWORD PTR [ebx-4]
	add	esi, DWORD PTR _dymem
	xor	edi, edi
	mov	DWORD PTR _key_offset, -1
	cmp	DWORD PTR [ebx], edi
	jle	SHORT $LN90@reorder_st
$LL93@reorder_st:

; 1351 :       if ( stricmp(keynames[i], ex->name) == 0 )

	mov	eax, DWORD PTR tv1429[ebp]
	mov	ecx, DWORD PTR _keynames[eax]
	push	esi
	push	ecx
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN65@reorder_st

; 1349 :     key_offset = -1; /* sentinel value */
; 1350 :     for ( k = 0, ex = EXTRAS(i) ; k < web.skel[i].extra_count ; k++ , ex++ )

	inc	edi
	add	esi, 240				; 000000f0H
	cmp	edi, DWORD PTR [ebx]
	jl	SHORT $LL93@reorder_st

; 1351 :       if ( stricmp(keynames[i], ex->name) == 0 )

	jmp	SHORT $LN27@reorder_st
$LN65@reorder_st:

; 1352 :       { key_offset = ex->offset;

	mov	edx, DWORD PTR [esi+64]
	mov	DWORD PTR _key_offset, edx
$LN27@reorder_st:

; 1353 :         break;
; 1354 :       }
; 1355 :     if ( key_offset < 0 )

	cmp	DWORD PTR _key_offset, 0
	jge	SHORT $LN94@reorder_st
$LN90@reorder_st:

; 1356 :     { for ( n = 0 ; n < NUMELEMENTS ; n++ ) myfree((char*)newblock[n]);

	xor	esi, esi
	npad	5
$LL24@reorder_st:
	mov	eax, DWORD PTR _newblock$[ebp+esi*4]
	push	eax
	call	_myfree
	inc	esi
	add	esp, 4
	cmp	esi, 5
	jl	SHORT $LL24@reorder_st

; 1357 :       sprintf(errmsg,"reorder_storage: %s attribute not defined.\n",keynames[i]);

	mov	esi, DWORD PTR tv1429[ebp]
	mov	ecx, DWORD PTR _keynames[esi]
	push	ecx
	push	OFFSET ??_C@_0CM@FOEAGPAN@reorder_storage?3?5?$CFs?5attribute?5no@
	push	OFFSET _errmsg
	call	_sprintf

; 1358 :       kb_error(2188,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2188					; 0000088cH
	call	_kb_error
	add	esp, 24					; 00000018H
	jmp	SHORT $LN25@reorder_st
$LN94@reorder_st:
	mov	esi, DWORD PTR tv1429[ebp]
$LN25@reorder_st:

; 1359 :     }
; 1360 :     qsort((char*)newblock[i],web.skel[i].count,web.sizes[i],FCAST esort);

	mov	edx, DWORD PTR _web[esi+560]
	mov	eax, DWORD PTR [ebx-44]
	mov	ecx, DWORD PTR _newblock$[ebp+esi]
	push	OFFSET _esort
	push	edx
	push	eax
	push	ecx
	call	_qsort
	add	esp, 16					; 00000010H
$LN32@reorder_st:

; 1339 :     }
; 1340 :     #endif
; 1341 :   }
; 1342 : 
; 1343 :   /* sort elements in use */
; 1344 :   for ( i = 0 ; i < NUMELEMENTS ; i++ )

	add	DWORD PTR tv1429[ebp], 4
	add	ebx, 112				; 00000070H
	cmp	ebx, OFFSET _web+668
	jl	$LL98@reorder_st

; 1361 :   }
; 1362 : 
; 1363 :   /* reset ibase array of pointers and list links */
; 1364 :   for ( i = 0 ; i < NUMELEMENTS ; i++ )

	xor	edi, edi
	mov	ecx, OFFSET _web+64
	mov	DWORD PTR tv1537[ebp], edi
	npad	1
$LL21@reorder_st:

; 1365 :   { struct element *ep,*nextep;
; 1366 :     int k;
; 1367 : 
; 1368 :     if  ( web.skel[i].maxcount == 0 ) continue;

	xor	ebx, ebx
	cmp	DWORD PTR [ecx-44], ebx
	je	$LN20@reorder_st

; 1369 :     
; 1370 :     if ( web.skel[i].count )

	cmp	DWORD PTR [ecx], ebx
	je	$LN92@reorder_st

; 1371 :     {
; 1372 :       web.skel[i].used = newblock[i]->self_id;

	mov	eax, DWORD PTR _newblock$[ebp+edi]
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx-16], edx

; 1373 :       newblock[i]->backchain = NULLID;

	mov	DWORD PTR [eax+4], ebx

; 1374 :       for ( k = 0, ep = newblock[i] ; k < web.skel[i].count-1 ; k++ )

	mov	edx, DWORD PTR [ecx]
	dec	edx
	test	edx, edx
	jle	SHORT $LN14@reorder_st
	npad	9
$LL16@reorder_st:

; 1375 :       { nextep = (struct element *)((char*)ep + web.sizes[i]);

	mov	edx, DWORD PTR _web[edi+560]

; 1376 :         ep->forechain = nextep->self_id;

	mov	esi, DWORD PTR [edx+eax+16]
	add	edx, eax
	mov	DWORD PTR [eax], esi

; 1377 :         nextep->backchain = ep->self_id;

	mov	esi, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+4], esi

; 1378 :         web.skel[i].ibase[ordinal(ep->self_id)] = ep;

	mov	esi, DWORD PTR [eax+16]
	test	esi, 268435456				; 10000000H
	je	SHORT $LN46@reorder_st
	and	esi, 134217727				; 07ffffffH
	jmp	SHORT $LN47@reorder_st
$LN46@reorder_st:
	or	esi, -1
$LN47@reorder_st:
	mov	edi, DWORD PTR [ecx-52]
	mov	DWORD PTR [edi+esi*4], eax
	mov	edi, DWORD PTR tv1537[ebp]

; 1379 :         ep = nextep;

	mov	eax, edx
	mov	edx, DWORD PTR [ecx]
	inc	ebx
	dec	edx
	cmp	ebx, edx
	jl	SHORT $LL16@reorder_st
$LN14@reorder_st:

; 1380 :       }
; 1381 :       web.skel[i].ibase[ordinal(ep->self_id)] = ep;

	mov	edx, DWORD PTR [eax+16]
	test	edx, 268435456				; 10000000H
	je	SHORT $LN48@reorder_st
	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN49@reorder_st
$LN48@reorder_st:
	or	edx, -1
$LN49@reorder_st:
	mov	esi, DWORD PTR [ecx-52]
	mov	DWORD PTR [esi+edx*4], eax

; 1382 :       ep->forechain = NULLID;

	mov	DWORD PTR [eax], 0

; 1383 :       web.skel[i].last = ep->self_id;

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx-12], eax
$LN92@reorder_st:

; 1384 :     }
; 1385 :     /* and free list */
; 1386 :     for (  k = web.skel[i].count ; k < web.skel[i].maxcount ; k++ )

	mov	esi, DWORD PTR [ecx]
	cmp	esi, DWORD PTR [ecx-44]
	jge	SHORT $LN20@reorder_st
	npad	4
$LL96@reorder_st:

; 1387 :     { ep = (struct element *)((char*)(newblock[i]) + k*web.sizes[i]);

	mov	eax, DWORD PTR _web[edi+560]
	imul	eax, esi
	add	eax, DWORD PTR _newblock$[ebp+edi]

; 1388 :       web.skel[i].ibase[ordinal(ep->self_id)] = ep;

	mov	edx, DWORD PTR [eax+16]
	test	edx, 268435456				; 10000000H
	je	SHORT $LN50@reorder_st
	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN51@reorder_st
$LN50@reorder_st:
	or	edx, -1
$LN51@reorder_st:
	mov	ebx, DWORD PTR [ecx-52]
	inc	esi
	mov	DWORD PTR [ebx+edx*4], eax
	cmp	esi, DWORD PTR [ecx-44]
	jl	SHORT $LL96@reorder_st
$LN20@reorder_st:

; 1361 :   }
; 1362 : 
; 1363 :   /* reset ibase array of pointers and list links */
; 1364 :   for ( i = 0 ; i < NUMELEMENTS ; i++ )

	add	edi, 4
	add	ecx, 112				; 00000070H
	mov	DWORD PTR tv1537[ebp], edi
	cmp	ecx, OFFSET _web+624
	jl	$LL21@reorder_st

; 1396 :     blockmax[i] = blockcount[i] = 0;

	xor	edi, edi
	xor	esi, esi
	npad	8
$LL10@reorder_st:

; 1389 :     }
; 1390 :   }
; 1391 : 
; 1392 :   /* free old storage */
; 1393 :   for ( i = 0 ; i < NUMELEMENTS ; i++ )
; 1394 :   { for ( j = 0 ; j < blockcount[i] ; j++ )

	xor	ebx, ebx
	cmp	DWORD PTR _blockcount[esi], edi
	jle	SHORT $LN5@reorder_st
	npad	6
$LL7@reorder_st:

; 1395 :           myfree((char *)blocklist[i][j].blockptr);

	mov	ecx, DWORD PTR _blocklist[esi]
	mov	edx, DWORD PTR [edi+ecx]
	push	edx
	call	_myfree
	inc	ebx
	add	esp, 4
	add	edi, 12					; 0000000cH
	cmp	ebx, DWORD PTR _blockcount[esi]
	jl	SHORT $LL7@reorder_st
$LN5@reorder_st:

; 1396 :     blockmax[i] = blockcount[i] = 0;

	xor	edi, edi
	mov	DWORD PTR _blockcount[esi], edi
	mov	DWORD PTR _blockmax[esi], edi
	add	esi, 4
	cmp	esi, 20					; 00000014H
	jl	SHORT $LL10@reorder_st

; 1397 :   }
; 1398 : 
; 1399 :   /* establish new */
; 1400 :   for ( i = 0 ; i < NUMELEMENTS ; i++ )
; 1401 :   { if ( web.skel[i].count == 0 ) continue;

	cmp	DWORD PTR _web+64, edi
	je	SHORT $LN97@reorder_st

; 1402 :     blocklist[i][0].blockptr = newblock[i];

	mov	eax, DWORD PTR _blocklist
	mov	ecx, DWORD PTR _newblock$[ebp]
	mov	DWORD PTR [eax], ecx

; 1403 :     blocklist[i][0].count = web.skel[i].maxcount;

	mov	edx, DWORD PTR _web+20
	mov	eax, DWORD PTR _blocklist

; 1404 :     blockmax[i] = blockcount[i] = 1;

	mov	ecx, 1
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR _blockcount, ecx
	mov	DWORD PTR _blockmax, ecx
	jmp	SHORT $LN3@reorder_st
$LN97@reorder_st:
	mov	ecx, 1
$LN3@reorder_st:

; 1397 :   }
; 1398 : 
; 1399 :   /* establish new */
; 1400 :   for ( i = 0 ; i < NUMELEMENTS ; i++ )
; 1401 :   { if ( web.skel[i].count == 0 ) continue;

	cmp	DWORD PTR _web+176, edi
	je	SHORT $LN83@reorder_st

; 1402 :     blocklist[i][0].blockptr = newblock[i];

	mov	edx, DWORD PTR _blocklist+4
	mov	eax, DWORD PTR _newblock$[ebp+4]
	mov	DWORD PTR [edx], eax

; 1403 :     blocklist[i][0].count = web.skel[i].maxcount;

	mov	edx, DWORD PTR _web+132
	mov	eax, DWORD PTR _blocklist+4
	mov	DWORD PTR [eax+8], edx

; 1404 :     blockmax[i] = blockcount[i] = 1;

	mov	DWORD PTR _blockcount+4, ecx
	mov	DWORD PTR _blockmax+4, ecx
$LN83@reorder_st:

; 1397 :   }
; 1398 : 
; 1399 :   /* establish new */
; 1400 :   for ( i = 0 ; i < NUMELEMENTS ; i++ )
; 1401 :   { if ( web.skel[i].count == 0 ) continue;

	cmp	DWORD PTR _web+288, edi
	je	SHORT $LN85@reorder_st

; 1402 :     blocklist[i][0].blockptr = newblock[i];

	mov	edx, DWORD PTR _blocklist+8
	mov	eax, DWORD PTR _newblock$[ebp+8]
	mov	DWORD PTR [edx], eax

; 1403 :     blocklist[i][0].count = web.skel[i].maxcount;

	mov	edx, DWORD PTR _web+244
	mov	eax, DWORD PTR _blocklist+8
	mov	DWORD PTR [eax+8], edx

; 1404 :     blockmax[i] = blockcount[i] = 1;

	mov	DWORD PTR _blockcount+8, ecx
	mov	DWORD PTR _blockmax+8, ecx
$LN85@reorder_st:

; 1397 :   }
; 1398 : 
; 1399 :   /* establish new */
; 1400 :   for ( i = 0 ; i < NUMELEMENTS ; i++ )
; 1401 :   { if ( web.skel[i].count == 0 ) continue;

	cmp	DWORD PTR _web+400, edi
	je	SHORT $LN87@reorder_st

; 1402 :     blocklist[i][0].blockptr = newblock[i];

	mov	edx, DWORD PTR _blocklist+12
	mov	eax, DWORD PTR _newblock$[ebp+12]
	mov	DWORD PTR [edx], eax

; 1403 :     blocklist[i][0].count = web.skel[i].maxcount;

	mov	edx, DWORD PTR _web+356
	mov	eax, DWORD PTR _blocklist+12
	mov	DWORD PTR [eax+8], edx

; 1404 :     blockmax[i] = blockcount[i] = 1;

	mov	DWORD PTR _blockcount+12, ecx
	mov	DWORD PTR _blockmax+12, ecx
$LN87@reorder_st:

; 1397 :   }
; 1398 : 
; 1399 :   /* establish new */
; 1400 :   for ( i = 0 ; i < NUMELEMENTS ; i++ )
; 1401 :   { if ( web.skel[i].count == 0 ) continue;

	cmp	DWORD PTR _web+512, edi
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN91@reorder_st

; 1402 :     blocklist[i][0].blockptr = newblock[i];

	mov	edx, DWORD PTR _blocklist+16
	mov	eax, DWORD PTR _newblock$[ebp+16]
	mov	DWORD PTR [edx], eax

; 1403 :     blocklist[i][0].count = web.skel[i].maxcount;

	mov	edx, DWORD PTR _web+468
	mov	eax, DWORD PTR _blocklist+16
	mov	DWORD PTR [eax+8], edx

; 1404 :     blockmax[i] = blockcount[i] = 1;

	mov	DWORD PTR _blockcount+16, ecx
	mov	DWORD PTR _blockmax+16, ecx
$LN91@reorder_st:

; 1405 :   }
; 1406 : 
; 1407 :   global_timestamp++;

	mov	eax, DWORD PTR _global_timestamp
	add	eax, ecx

; 1408 :   top_timestamp = global_timestamp;

	mov	DWORD PTR _top_timestamp, eax
	mov	DWORD PTR _global_timestamp, eax

; 1409 : } // end reorder_storage()

	mov	esp, ebp
	pop	ebp
	ret	0
_reorder_storage ENDP
_TEXT	ENDS
PUBLIC	??_C@_09BNMFOCDE@body_?$CFd?$CFs?$AA@		; `string'
PUBLIC	??_C@_05MCCEGCIB@body_?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_renumber_all
EXTRN	_meth_inst_list:DWORD
EXTRN	_strchr:PROC
EXTRN	_atoi:PROC
EXTRN	_strncmp:PROC
EXTRN	_gen_quant_list:DWORD
EXTRN	_everything_quantities_flag:DWORD
EXTRN	_pickfnum:DWORD
EXTRN	_pickenum:DWORD
EXTRN	_pickvnum:DWORD
;	COMDAT ??_C@_09BNMFOCDE@body_?$CFd?$CFs?$AA@
CONST	SEGMENT
??_C@_09BNMFOCDE@body_?$CFd?$CFs?$AA@ DB 'body_%d%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MCCEGCIB@body_?$AA@
CONST	SEGMENT
??_C@_05MCCEGCIB@body_?$AA@ DB 'body_', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _renumber_all
_TEXT	SEGMENT
_newibase$ = -164					; size = 20
_dimc$ = -144						; size = 4
_offb$ = -140						; size = 4
_offc$ = -136						; size = 4
tv1623 = -132						; size = 4
_offa$ = -128						; size = 4
_did_graphlock_here$89927 = -124			; size = 4
_dima$ = -120						; size = 4
tv3272 = -116						; size = 4
_dimb$ = -116						; size = 4
tv3421 = -112						; size = 4
tv3092 = -112						; size = 4
_off$ = -112						; size = 4
tv3471 = -108						; size = 4
tv3419 = -108						; size = 4
tv3090 = -108						; size = 4
_dim$ = -108						; size = 4
_newname$90133 = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_renumber_all PROC					; COMDAT

; 1420 : { int type;

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1421 :   struct element *ep=NULL;
; 1422 :   element_id id;
; 1423 :   int k;
; 1424 :   int dim,off,dima,offa,dimb,offb,dimc,offc;
; 1425 :   struct element **newibase[NUMELEMENTS];
; 1426 : 
; 1427 :   free_discards(DISCARDS_ALL);

	push	1
	call	_free_discards
	add	esp, 4
	lea	edi, DWORD PTR _newibase$[ebp]
	mov	esi, OFFSET _web+16
	npad	6
$LL99@renumber_a:

; 1428 : 
; 1429 :   for ( type = VERTEX ; type <= FACETEDGE ; type++ )
; 1430 :      newibase[type] = 
; 1431 :          (struct element **)mycalloc(web.skel[type].ialloc,
; 1432 :                   sizeof(element_id *)); 

	mov	eax, DWORD PTR [esi]
	push	1432					; 00000598H
	push	OFFSET ??_C@_09EOIFBANE@STORAGE?4C?$AA@
	push	4
	push	eax
	call	_kb_calloc
	mov	DWORD PTR [edi], eax
	add	esi, 112				; 00000070H
	add	esp, 16					; 00000010H
	add	edi, 4
	cmp	esi, OFFSET _web+464
	jle	SHORT $LL99@renumber_a

; 1433 :  
; 1434 :   ENTER_GRAPH_MUTEX

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN96@renumber_a
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89927[ebp], 1
	jmp	SHORT $LN95@renumber_a
$LN96@renumber_a:
	mov	DWORD PTR _did_graphlock_here$89927[ebp], 0
$LN95@renumber_a:

; 1435 : 
; 1436 :   for ( type = VERTEX ; type <= FACETEDGE ; type++ )

	mov	edx, OFFSET _web+48
	npad	7
$LL94@renumber_a:

; 1437 :   { element_id count;
; 1438 : 
; 1439 :     /* reset self-id of used elements  */
; 1440 :     count = 0;
; 1441 :     id = web.skel[type].used;

	mov	eax, DWORD PTR [edx]
	xor	ecx, ecx

; 1442 :     while ( valid_id(id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN93@renumber_a
	npad	5
$LL91@renumber_a:

; 1443 :     { ep = elptr(id);

	mov	esi, eax
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	esi, DWORD PTR _web[esi+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]

; 1444 :       ep->self_id = (ep->self_id & (~OFFSETMASK)) | count;

	mov	esi, DWORD PTR [eax+16]
	and	esi, -134217728				; f8000000H
	or	esi, ecx
	mov	DWORD PTR [eax+16], esi

; 1445 :       count++;
; 1446 :       id = ep->forechain;

	mov	eax, DWORD PTR [eax]
	inc	ecx
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL91@renumber_a
$LN93@renumber_a:

; 1435 : 
; 1436 :   for ( type = VERTEX ; type <= FACETEDGE ; type++ )

	add	edx, 112				; 00000070H
	cmp	edx, OFFSET _web+496
	jle	SHORT $LL94@renumber_a

; 1447 :     }
; 1448 : 
; 1449 :   }
; 1450 :  /* reset mutual links within structures */
; 1451 :   FOR_ALL_FACETEDGES(id)

	mov	eax, DWORD PTR _web+496
	test	eax, 268435456				; 10000000H
	je	$LN87@renumber_a
	mov	esi, DWORD PTR _web+460
	npad	1
$LL89@renumber_a:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR [edi+esi]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	xor	edx, edx
	or	ecx, edx
	je	$LN88@renumber_a

; 1452 :   { struct facetedge *ep = feptr(id);
; 1453 :     ep->fe_edge_id = copy_sign(elptr(ep->fe_edge_id)->self_id,ep->fe_edge_id);

	mov	ecx, DWORD PTR [eax+20]
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [edx+16]
	mov	esi, ecx
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	esi, DWORD PTR _web[esi+12]
	xor	edx, ecx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR [ecx+16]

; 1454 :     ep->fe_facet_id = valid_id(ep->fe_facet_id) ? 
; 1455 : 		copy_sign(elptr(ep->fe_facet_id)->self_id,ep->fe_facet_id) : ep->fe_facet_id;

	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+20], edx
	mov	edx, ecx
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN103@renumber_a
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [edx+16]
	mov	esi, ecx
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	esi, DWORD PTR _web[esi+12]
	xor	edx, ecx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR [ecx+16]
$LN103@renumber_a:
	mov	DWORD PTR [eax+24], edx

; 1456 :     ep->nextedge[0] = copy_sign(elptr(ep->nextedge[0])->self_id,ep->nextedge[0]);

	mov	ecx, DWORD PTR [eax+28]
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [edx+16]
	xor	edx, ecx
	mov	esi, ecx
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	esi, DWORD PTR _web[esi+12]
	and	edx, 134217728				; 08000000H
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	xor	edx, DWORD PTR [ecx+16]

; 1457 :     ep->nextedge[1] = copy_sign(elptr(ep->nextedge[1])->self_id,ep->nextedge[1]);

	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [eax+28], edx
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [edx+16]
	xor	edx, ecx
	mov	esi, ecx
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	esi, DWORD PTR _web[esi+12]
	and	edx, 134217728				; 08000000H
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	xor	edx, DWORD PTR [ecx+16]

; 1458 :     ep->nextfacet[0] = copy_sign(elptr(ep->nextfacet[0])->self_id,ep->nextfacet[0]);

	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [eax+32], edx
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [edx+16]
	mov	esi, ecx
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	esi, DWORD PTR _web[esi+12]
	xor	edx, ecx
	and	edx, 134217728				; 08000000H
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	xor	edx, DWORD PTR [ecx+16]

; 1459 :     ep->nextfacet[1] = copy_sign(elptr(ep->nextfacet[1])->self_id,ep->nextfacet[1]);

	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [eax+36], edx
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [edx+16]
	mov	esi, ecx
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	esi, DWORD PTR _web[esi+12]
	xor	edx, ecx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+40], edx
	mov	esi, DWORD PTR _web+460
$LN88@renumber_a:

; 1447 :     }
; 1448 : 
; 1449 :   }
; 1450 :  /* reset mutual links within structures */
; 1451 :   FOR_ALL_FACETEDGES(id)

	mov	edx, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	$LL89@renumber_a
$LN87@renumber_a:

; 1460 :   }
; 1461 : 
; 1462 :   FOR_ALL_VERTICES(id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	SHORT $LN82@renumber_a
	mov	edi, DWORD PTR _web+12
$LL84@renumber_a:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edx, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [edx+edi]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN83@renumber_a

; 1463 :   { struct vertex *ep = vptr(id);
; 1464 :     ep->e_id = copy_sign(elptr(ep->e_id)->self_id,ep->e_id);

	mov	eax, DWORD PTR [ecx+28]
	mov	esi, eax
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	esi, DWORD PTR _web[esi+12]
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+edi*4]
	mov	esi, DWORD PTR [esi+16]
	mov	edi, eax
	shr	edi, 29					; 0000001dH
	imul	edi, 112				; 00000070H
	mov	edi, DWORD PTR _web[edi+12]
	xor	esi, eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+28], esi
	mov	edi, DWORD PTR _web+12
$LN83@renumber_a:

; 1460 :   }
; 1461 : 
; 1462 :   FOR_ALL_VERTICES(id)

	mov	ecx, DWORD PTR [edx+edi]
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL84@renumber_a
$LN82@renumber_a:

; 1465 :   }
; 1466 : 
; 1467 :   off = EXTRAS(EDGE)[E_VERTICES_ATTR].offset;  /* endpoints */

	mov	ecx, DWORD PTR _web+216
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [ecx+eax+304]

; 1468 :   dim = EXTRAS(EDGE)[E_VERTICES_ATTR].array_spec.datacount;  

	mov	esi, DWORD PTR [ecx+eax+328]

; 1469 :   FOR_ALL_EDGES(id)    

	mov	ecx, DWORD PTR _web+160
	push	ebx
	mov	DWORD PTR _off$[ebp], edx
	test	ecx, 268435456				; 10000000H
	je	$LN77@renumber_a
$LL171@renumber_a:
	mov	eax, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	lea	edi, DWORD PTR [ecx+ecx]
	mov	eax, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	xor	edx, edx
	or	ecx, edx
	je	$LN78@renumber_a

; 1470 :   { struct edge *ep = eptr(id);
; 1471 :     vertex_id *vp;
; 1472 :     ep->fe_id = copy_sign(elptr(ep->fe_id)->self_id,ep->fe_id);

	mov	ecx, DWORD PTR [eax+28]
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	ebx, ecx
	and	ebx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [edx+16]
	xor	edx, ecx
	mov	ebx, ecx
	shr	ebx, 29					; 0000001dH
	imul	ebx, 112				; 00000070H
	mov	ebx, DWORD PTR _web[ebx+12]
	and	edx, 134217728				; 08000000H
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	xor	edx, DWORD PTR [ecx+16]

; 1473 :     ep->next_vedge[0] = copy_sign(elptr(ep->next_vedge[0])->self_id,
; 1474 :       ep->next_vedge[0]);

	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [eax+28], edx
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	ebx, ecx
	and	ebx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [edx+16]
	mov	ebx, ecx
	shr	ebx, 29					; 0000001dH
	xor	edx, ecx
	imul	ebx, 112				; 00000070H
	mov	ebx, DWORD PTR _web[ebx+12]
	and	edx, 134217728				; 08000000H
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	xor	edx, DWORD PTR [ecx+16]

; 1475 :     ep->next_vedge[1] = copy_sign(elptr(ep->next_vedge[1])->self_id,
; 1476 :       ep->next_vedge[1]);

	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [eax+32], edx
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	ebx, ecx
	and	ebx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [edx+16]
	mov	ebx, ecx
	shr	ebx, 29					; 0000001dH
	imul	ebx, 112				; 00000070H
	mov	ebx, DWORD PTR _web[ebx+12]
	xor	edx, ecx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR [ecx+16]

; 1477 :     vp = (vertex_id*)((char*)ep + off);
; 1478 :     for ( k = 0 ; k < dim ; k++ )

	xor	ecx, ecx
	mov	DWORD PTR [eax+36], edx
	add	eax, DWORD PTR _off$[ebp]
	test	esi, esi
	jle	SHORT $LN78@renumber_a
	npad	6
$LL74@renumber_a:

; 1479 :       vp[k] = vptr(vp[k])->self_id;

	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ebx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+ecx*4], edx
	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LL74@renumber_a
$LN78@renumber_a:

; 1469 :   FOR_ALL_EDGES(id)    

	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, 268435456				; 10000000H
	jne	$LL171@renumber_a
	mov	eax, DWORD PTR _dymem
$LN77@renumber_a:

; 1480 :   }
; 1481 : 
; 1482 :   off = EXTRAS(FACET)[F_VERTICES_ATTR].offset;  /* endpoints */

	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR [ecx+eax+304]
	mov	DWORD PTR _off$[ebp], edx

; 1483 :   dim = EXTRAS(FACET)[F_VERTICES_ATTR].array_spec.datacount;  

	mov	edx, DWORD PTR [ecx+eax+328]
	mov	DWORD PTR _dim$[ebp], edx

; 1484 :   offa = EXTRAS(FACET)[F_BODY_LIST_ATTR].offset;  /* bodies */

	mov	edx, DWORD PTR [ecx+eax+784]
	mov	DWORD PTR _offa$[ebp], edx

; 1485 :   dima = EXTRAS(FACET)[F_BODY_LIST_ATTR].array_spec.datacount;  

	mov	edx, DWORD PTR [ecx+eax+808]
	mov	DWORD PTR _dima$[ebp], edx

; 1486 :   offb = EXTRAS(FACET)[F_NEXT_VFACET_ATTR].offset;  /* links */

	mov	edx, DWORD PTR [ecx+eax+1024]
	mov	DWORD PTR _offb$[ebp], edx

; 1487 :   dimb = EXTRAS(FACET)[F_NEXT_VFACET_ATTR].array_spec.datacount;  

	mov	edx, DWORD PTR [ecx+eax+1048]
	mov	DWORD PTR _dimb$[ebp], edx

; 1488 :   offc = EXTRAS(FACET)[F_NEXT_BFACET_ATTR].offset;  /* links */

	mov	edx, DWORD PTR [ecx+eax+1264]

; 1489 :   dimc = EXTRAS(FACET)[F_NEXT_BFACET_ATTR].array_spec.datacount;  

	mov	eax, DWORD PTR [ecx+eax+1288]
	mov	DWORD PTR _dimc$[ebp], eax

; 1490 :   FOR_ALL_FACETS(id)  

	mov	eax, DWORD PTR _web+272
	mov	DWORD PTR _offc$[ebp], edx
	test	eax, 268435456				; 10000000H
	je	$LN177@renumber_a
	npad	9
$LL170@renumber_a:
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	esi, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv1623[ebp], eax
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN70@renumber_a

; 1491 :   { struct facet *ep = fptr(id);
; 1492 :     element_id *p;
; 1493 :     ep->fe_id = copy_sign(elptr(ep->fe_id)->self_id,ep->fe_id);

	mov	eax, DWORD PTR [esi+28]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ecx+12]
	xor	edx, eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]

; 1494 :     p = (element_id*)((char*)ep + off);

	mov	ecx, DWORD PTR _off$[ebp]
	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR [eax+16]
	lea	edi, DWORD PTR [esi+ecx]
	mov	DWORD PTR [esi+28], edx

; 1495 :     for ( k = 0 ; k < dim ; k++ )

	xor	edx, edx
	cmp	DWORD PTR _dim$[ebp], edx
	jle	SHORT $LN64@renumber_a
	npad	8
$LL172@renumber_a:

; 1496 :       if ( valid_id(p[k]) )

	mov	eax, DWORD PTR [edi+edx*4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN65@renumber_a

; 1497 :          p[k] = copy_sign(elptr(p[k])->self_id,p[k]);

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ecx+12]
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [ecx+16]
	mov	ebx, eax
	shr	ebx, 29					; 0000001dH
	imul	ebx, 112				; 00000070H
	mov	ebx, DWORD PTR _web[ebx+12]
	xor	ecx, eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edi+edx*4], ecx
$LN65@renumber_a:

; 1495 :     for ( k = 0 ; k < dim ; k++ )

	inc	edx
	cmp	edx, DWORD PTR _dim$[ebp]
	jl	SHORT $LL172@renumber_a
$LN64@renumber_a:

; 1498 :     p = (element_id*)((char*)ep + offa);

	mov	ecx, DWORD PTR _offa$[ebp]

; 1499 :     for ( k = 0 ; k < dima ; k++ )

	xor	edx, edx
	add	ecx, esi
	cmp	DWORD PTR _dima$[ebp], edx
	jle	SHORT $LN60@renumber_a
	npad	4
$LL173@renumber_a:

; 1500 :       if ( valid_id(p[k]) )

	mov	eax, DWORD PTR [ecx+edx*4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN61@renumber_a

; 1501 :          p[k] = copy_sign(elptr(p[k])->self_id,p[k]);

	mov	edi, eax
	shr	edi, 29					; 0000001dH
	imul	edi, 112				; 00000070H
	mov	edi, DWORD PTR _web[edi+12]
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+ebx*4]
	mov	edi, DWORD PTR [edi+16]
	mov	ebx, eax
	shr	ebx, 29					; 0000001dH
	imul	ebx, 112				; 00000070H
	mov	ebx, DWORD PTR _web[ebx+12]
	xor	edi, eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	and	edi, 134217728				; 08000000H
	xor	edi, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+edx*4], edi
$LN61@renumber_a:

; 1499 :     for ( k = 0 ; k < dima ; k++ )

	inc	edx
	cmp	edx, DWORD PTR _dima$[ebp]
	jl	SHORT $LL173@renumber_a
$LN60@renumber_a:

; 1502 :     p = (element_id*)((char*)ep + offb);

	mov	ecx, DWORD PTR _offb$[ebp]

; 1503 :     for ( k = 0 ; k < dimb ; k++ )

	xor	edx, edx
	lea	edi, DWORD PTR [esi+ecx]
	cmp	DWORD PTR _dimb$[ebp], edx
	jle	SHORT $LN56@renumber_a
$LL174@renumber_a:

; 1504 :       if ( valid_id(p[k]) )

	mov	eax, DWORD PTR [edi+edx*4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN57@renumber_a

; 1505 :          p[k] = copy_sign(elptr(p[k])->self_id,p[k]);

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ecx+12]
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [ecx+16]
	mov	ebx, eax
	shr	ebx, 29					; 0000001dH
	imul	ebx, 112				; 00000070H
	mov	ebx, DWORD PTR _web[ebx+12]
	xor	ecx, eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edi+edx*4], ecx
$LN57@renumber_a:

; 1503 :     for ( k = 0 ; k < dimb ; k++ )

	inc	edx
	cmp	edx, DWORD PTR _dimb$[ebp]
	jl	SHORT $LL174@renumber_a
$LN56@renumber_a:

; 1506 :     p = (element_id*)((char*)ep + offc);
; 1507 :     for ( k = 0 ; k < dimc ; k++ )

	mov	ecx, DWORD PTR _dimc$[ebp]
	add	esi, DWORD PTR _offc$[ebp]
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN70@renumber_a
$LL175@renumber_a:

; 1508 :       if ( valid_id(p[k]) )

	mov	eax, DWORD PTR [esi+edx*4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN53@renumber_a

; 1509 :          p[k] = copy_sign(elptr(p[k])->self_id,p[k]);

	mov	edi, eax
	shr	edi, 29					; 0000001dH
	imul	edi, 112				; 00000070H
	mov	edi, DWORD PTR _web[edi+12]
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+ebx*4]
	mov	edi, DWORD PTR [edi+16]
	mov	ebx, eax
	shr	ebx, 29					; 0000001dH
	imul	ebx, 112				; 00000070H
	mov	ebx, DWORD PTR _web[ebx+12]
	xor	edi, eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	and	edi, 134217728				; 08000000H
	xor	edi, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+edx*4], edi
$LN53@renumber_a:

; 1506 :     p = (element_id*)((char*)ep + offc);
; 1507 :     for ( k = 0 ; k < dimc ; k++ )

	inc	edx
	cmp	edx, ecx
	jl	SHORT $LL175@renumber_a
$LN70@renumber_a:

; 1490 :   FOR_ALL_FACETS(id)  

	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR tv1623[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL170@renumber_a
$LN177@renumber_a:

; 1510 :   }
; 1511 : 
; 1512 :   FOR_ALL_BODIES(id)    

	mov	eax, DWORD PTR _web+384
	test	eax, 268435456				; 10000000H
	je	$LN48@renumber_a
	mov	edi, DWORD PTR _web+348
$LL50@renumber_a:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edx, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [edx+edi]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN49@renumber_a

; 1513 :   { struct body * ep = bptr(id);
; 1514 :     if ( valid_id(ep->f_id) )

	mov	eax, DWORD PTR [ecx+400]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN49@renumber_a

; 1515 :       ep->f_id = copy_sign(elptr(ep->f_id)->self_id,ep->f_id);

	mov	esi, eax
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	esi, DWORD PTR _web[esi+12]
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+edi*4]
	mov	esi, DWORD PTR [esi+16]
	mov	edi, eax
	shr	edi, 29					; 0000001dH
	imul	edi, 112				; 00000070H
	mov	edi, DWORD PTR _web[edi+12]
	xor	esi, eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+400], esi
	mov	edi, DWORD PTR _web+348
$LN49@renumber_a:

; 1510 :   }
; 1511 : 
; 1512 :   FOR_ALL_BODIES(id)    

	mov	ecx, DWORD PTR [edx+edi]
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL50@renumber_a
$LN48@renumber_a:

; 1516 :   }
; 1517 : 
; 1518 :   /* now new pointers in newibase */
; 1519 :   for ( type = VERTEX ; type <= FACETEDGE ; type++ )

	lea	edx, DWORD PTR _newibase$[ebp]
	mov	DWORD PTR tv3090[ebp], edx
	mov	DWORD PTR tv3092[ebp], OFFSET _web+48
	npad	2
$LL44@renumber_a:

; 1520 :   { int count = 0;
; 1521 :     if ( web.skel[type].count == 0 ) continue; 

	mov	eax, DWORD PTR tv3092[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN43@renumber_a

; 1522 :     FOR_ALL_ELEMENTS(type,id)

	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN43@renumber_a
	xor	ebx, ebx
$LL40@renumber_a:
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	lea	esi, DWORD PTR _web[edx+12]
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [edx+8]
	and	ecx, 1
	xor	edi, edi
	or	ecx, edi
	je	SHORT $LN39@renumber_a

; 1523 :       newibase[type][count++] = elptr(id);

	mov	ecx, DWORD PTR tv3090[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [ebx+ecx], edx
	add	ebx, 4
$LN39@renumber_a:

; 1522 :     FOR_ALL_ELEMENTS(type,id)

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL40@renumber_a
$LN43@renumber_a:

; 1516 :   }
; 1517 : 
; 1518 :   /* now new pointers in newibase */
; 1519 :   for ( type = VERTEX ; type <= FACETEDGE ; type++ )

	mov	eax, DWORD PTR tv3092[ebp]
	add	DWORD PTR tv3090[ebp], 4
	add	eax, 112				; 00000070H
	mov	DWORD PTR tv3092[ebp], eax
	cmp	eax, OFFSET _web+496
	jle	SHORT $LL44@renumber_a

; 1524 :   } 
; 1525 : 
; 1526 : 
; 1527 :   /* fix up links */
; 1528 :   for ( type = VERTEX ; type <= FACETEDGE ; type++ )

	lea	esi, DWORD PTR _newibase$[ebp]
	mov	DWORD PTR tv3272[ebp], esi
	mov	edx, OFFSET _web+64
	xor	ecx, ecx
	npad	1
$LL35@renumber_a:

; 1529 :   { if ( web.skel[type].count == 0 ) continue;

	mov	eax, DWORD PTR [edx]
	cmp	eax, ecx
	je	SHORT $LN34@renumber_a

; 1530 :     if ( web.skel[type].count == 1 )

	cmp	eax, 1
	jne	SHORT $LN31@renumber_a

; 1531 :     { newibase[type][0]->forechain = NULLID;

	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edi], ecx

; 1532 :       newibase[type][0]->backchain = NULLID;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx

; 1533 :       continue;

	jmp	SHORT $LN34@renumber_a
$LN31@renumber_a:

; 1534 :     }
; 1535 :     newibase[type][0]->forechain = newibase[type][0]->self_id+1;

	mov	edi, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+16]
	inc	ebx
	mov	DWORD PTR [eax], ebx

; 1536 :     newibase[type][0]->backchain = NULLID;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+4], ecx

; 1537 :     for ( k = 1 ; k < web.skel[type].count-1; k++ )

	mov	ecx, DWORD PTR [edx]
	mov	eax, 1
	dec	ecx
	cmp	ecx, eax
	jle	SHORT $LN166@renumber_a

; 1534 :     }
; 1535 :     newibase[type][0]->forechain = newibase[type][0]->self_id+1;

	lea	ecx, DWORD PTR [edi+4]
$LL30@renumber_a:

; 1538 :     {
; 1539 :       newibase[type][k]->forechain = newibase[type][k]->self_id+1;

	mov	esi, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [esi+16]
	inc	ebx
	mov	DWORD PTR [esi], ebx

; 1540 :       newibase[type][k]->backchain = newibase[type][k]->self_id-1;

	mov	esi, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [esi+16]
	dec	ebx
	mov	DWORD PTR [esi+4], ebx
	mov	esi, DWORD PTR [edx]
	inc	eax
	dec	esi
	add	ecx, 4
	cmp	eax, esi
	jl	SHORT $LL30@renumber_a

; 1537 :     for ( k = 1 ; k < web.skel[type].count-1; k++ )

	mov	esi, DWORD PTR tv3272[ebp]
$LN166@renumber_a:

; 1541 :     }
; 1542 :     newibase[type][k]->forechain = NULLID;

	mov	ecx, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [ecx], 0

; 1543 :     newibase[type][k]->backchain = newibase[type][k]->self_id - 1;

	mov	ecx, DWORD PTR [edi+eax*4]
	mov	ebx, DWORD PTR [ecx+16]
	dec	ebx
	mov	DWORD PTR [ecx+4], ebx

; 1544 :     web.skel[type].used = newibase[type][0]->self_id;

	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx-16], ecx

; 1545 :     web.skel[type].last = newibase[type][k]->self_id;

	mov	eax, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx-12], ecx
	xor	ecx, ecx
$LN34@renumber_a:

; 1524 :   } 
; 1525 : 
; 1526 : 
; 1527 :   /* fix up links */
; 1528 :   for ( type = VERTEX ; type <= FACETEDGE ; type++ )

	add	esi, 4
	add	edx, 112				; 00000070H
	mov	DWORD PTR tv3272[ebp], esi
	cmp	edx, OFFSET _web+512
	jle	$LL35@renumber_a

; 1546 :   }
; 1547 : 
; 1548 :   #ifndef HASH_ID
; 1549 :   /* fix up freelists */
; 1550 :   for ( type = VERTEX ; type <= FACETEDGE ; type++ )

	lea	edx, DWORD PTR _newibase$[ebp]
	mov	eax, OFFSET _web+28
	mov	DWORD PTR tv3419[ebp], edx
	mov	DWORD PTR tv3421[ebp], eax
$LL27@renumber_a:

; 1551 :   { int count;
; 1552 :     element_id backid = NULLID,newid;
; 1553 : 
; 1554 :     count = web.skel[type].count;
; 1555 :     id = web.skel[type].free;

	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+36]
	xor	ecx, ecx

; 1556 :     if ( !valid_id(id) ) continue;

	test	edx, 268435456				; 10000000H
	je	SHORT $LN26@renumber_a

; 1557 :     newid = (id & (~OFFSETMASK)) | count;
; 1558 :     web.skel[type].free = newid;

	mov	eax, DWORD PTR tv3421[ebp]
	mov	esi, edx
	and	esi, -134217728				; f8000000H
	or	esi, edi
	mov	DWORD PTR [eax], esi
	mov	eax, DWORD PTR tv3419[ebp]
	mov	eax, DWORD PTR [eax]
	lea	ebx, DWORD PTR [eax+edi*4]
$LL23@renumber_a:

; 1559 : 
; 1560 :     while ( valid_id(id) )
; 1561 :     { ep = elptr(id);

	mov	eax, edx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	eax, DWORD PTR _web[eax+12]
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]

; 1562 :       id = ep->forechain;

	mov	edx, DWORD PTR [eax]

; 1563 :       ep->forechain = ++newid;

	inc	esi

; 1564 :       ep->backchain = backid;

	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], esi

; 1565 :       newibase[type][count] = ep;

	mov	DWORD PTR [ebx], eax

; 1566 :       ep->self_id = (ep->self_id & (~OFFSETMASK)) | count;

	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -134217728				; f8000000H
	or	ecx, edi

; 1567 :       backid = ep->self_id;
; 1568 :       count++;

	inc	edi
	add	ebx, 4
	mov	DWORD PTR [eax+16], ecx
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL23@renumber_a

; 1569 :     } 
; 1570 :     ep->forechain = NULLID;
; 1571 :     web.skel[type].freelast = backid;

	mov	edx, DWORD PTR tv3421[ebp]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [edx+4], ecx
	mov	eax, edx
$LN26@renumber_a:

; 1546 :   }
; 1547 : 
; 1548 :   #ifndef HASH_ID
; 1549 :   /* fix up freelists */
; 1550 :   for ( type = VERTEX ; type <= FACETEDGE ; type++ )

	add	DWORD PTR tv3419[ebp], 4
	add	eax, 112				; 00000070H
	mov	DWORD PTR tv3421[ebp], eax
	cmp	eax, OFFSET _web+476
	jle	SHORT $LL27@renumber_a

; 1572 :   }
; 1573 :   #endif
; 1574 : 
; 1575 :   /* miscellaneous elements */
; 1576 :   if ( valid_id(web.zoom_v) ) web.zoom_v = vptr(web.zoom_v)->self_id;

	mov	eax, DWORD PTR _web+976
	test	eax, 268435456				; 10000000H
	je	SHORT $LN167@renumber_a
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _web+976, eax
$LN167@renumber_a:

; 1577 :   if ( pickvnum ) pickvnum = loc_ordinal(vibase[pickvnum-1]->self_id)+1;

	mov	eax, DWORD PTR _pickvnum
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $LN176@renumber_a
	mov	ecx, DWORD PTR _vibase
	mov	edx, DWORD PTR [ecx+eax*4-4]
	mov	eax, DWORD PTR [edx+16]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN104@renumber_a
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN105@renumber_a
$LN104@renumber_a:
	or	eax, -1
$LN105@renumber_a:
	inc	eax
	mov	DWORD PTR _pickvnum, eax
$LN176@renumber_a:

; 1578 :   if ( pickenum ) pickenum = loc_ordinal(eibase[pickenum-1]->self_id)+1;

	mov	eax, DWORD PTR _pickenum
	cmp	eax, ebx
	je	SHORT $LN178@renumber_a
	mov	ecx, DWORD PTR _eibase
	mov	edx, DWORD PTR [ecx+eax*4-4]
	mov	eax, DWORD PTR [edx+16]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN106@renumber_a
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN107@renumber_a
$LN106@renumber_a:
	or	eax, -1
$LN107@renumber_a:
	inc	eax
	mov	DWORD PTR _pickenum, eax
$LN178@renumber_a:

; 1579 :   if ( pickfnum ) pickfnum = loc_ordinal(fibase[pickfnum-1]->self_id)+1;

	mov	eax, DWORD PTR _pickfnum
	cmp	eax, ebx
	je	SHORT $LN18@renumber_a
	mov	ecx, DWORD PTR _fibase
	mov	edx, DWORD PTR [ecx+eax*4-4]
	mov	eax, DWORD PTR [edx+16]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN108@renumber_a
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN109@renumber_a
$LN108@renumber_a:
	or	eax, -1
$LN109@renumber_a:
	inc	eax
	mov	DWORD PTR _pickfnum, eax
$LN18@renumber_a:

; 1580 : 
; 1581 :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, ebx
	je	$LN169@renumber_a

; 1582 :   { /* fix up names of body quantities and instances */
; 1583 :     int k,oldbnum,newbnum;
; 1584 :     char *nametail;
; 1585 :     char newname[100];
; 1586 :     /* named quantities */
; 1587 :     for (  k = 0 ; k < gen_quant_count ; k++ )

	cmp	DWORD PTR _web+5528, ebx
	jle	$LN168@renumber_a
	mov	DWORD PTR tv3471[ebp], ebx
	npad	9
$LL16@renumber_a:

; 1588 :     { struct gen_quant *q = GEN_QUANT(k);

	mov	esi, DWORD PTR tv3471[ebp]
	add	esi, DWORD PTR _gen_quant_list

; 1589 :       if ( q->flags & Q_DELETED ) continue;

	mov	eax, DWORD PTR [esi+136]
	test	eax, 524288				; 00080000H
	jne	SHORT $LN15@renumber_a

; 1590 :       if ( !(q->flags & DEFAULT_QUANTITY) ) continue;

	test	eax, 8192				; 00002000H
	je	SHORT $LN15@renumber_a

; 1591 :       if ( strncmp(q->name,"body_",5) != 0 ) continue;

	push	5
	push	OFFSET ??_C@_05MCCEGCIB@body_?$AA@
	push	esi
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@renumber_a

; 1592 :       oldbnum = atoi(q->name+5);

	lea	edx, DWORD PTR [esi+5]
	push	edx
	call	_atoi

; 1593 :       newbnum = loc_ordinal(bibase[oldbnum-1]->self_id)+1;

	mov	ecx, DWORD PTR _bibase
	mov	edx, DWORD PTR [ecx+eax*4-4]
	mov	eax, DWORD PTR [edx+16]
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN110@renumber_a
	and	eax, 134217727				; 07ffffffH
	mov	edi, eax
	jmp	SHORT $LN111@renumber_a
$LN110@renumber_a:
	or	edi, -1
$LN111@renumber_a:

; 1594 :       nametail = strchr(q->name+6,'_');

	lea	eax, DWORD PTR [esi+6]
	push	95					; 0000005fH
	push	eax
	call	_strchr

; 1595 :       sprintf(newname,"body_%d%s",newbnum,nametail);

	push	eax
	inc	edi
	push	edi
	lea	ecx, DWORD PTR _newname$90133[ebp]
	push	OFFSET ??_C@_09BNMFOCDE@body_?$CFd?$CFs?$AA@
	push	ecx
	call	_sprintf

; 1596 :       strcpy(q->name,newname);

	lea	eax, DWORD PTR _newname$90133[ebp]
	mov	edx, eax
	add	esp, 24					; 00000018H
	sub	esi, edx
$LL112@renumber_a:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [eax+esi], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL112@renumber_a
$LN15@renumber_a:

; 1582 :   { /* fix up names of body quantities and instances */
; 1583 :     int k,oldbnum,newbnum;
; 1584 :     char *nametail;
; 1585 :     char newname[100];
; 1586 :     /* named quantities */
; 1587 :     for (  k = 0 ; k < gen_quant_count ; k++ )

	add	DWORD PTR tv3471[ebp], 368		; 00000170H
	inc	ebx
	cmp	ebx, DWORD PTR _web+5528
	jl	$LL16@renumber_a
$LN168@renumber_a:

; 1597 :     }
; 1598 :     for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	ebx, 1
	cmp	DWORD PTR _web+5560, ebx
	jle	$LN169@renumber_a
$LL10@renumber_a:

; 1599 :     { struct method_instance *mi = METH_INSTANCE(k);

	mov	eax, ebx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list

; 1600 :       if ( mi->flags & Q_DELETED ) continue;

	mov	eax, DWORD PTR [esi+140]
	test	eax, 524288				; 00080000H
	jne	$LN9@renumber_a

; 1601 :       if ( !(mi->flags & DEFAULT_INSTANCE) ) continue;

	test	eax, 4194304				; 00400000H
	je	SHORT $LN9@renumber_a

; 1602 :       if ( strncmp(mi->name,"body_",5) != 0 ) continue;

	push	5
	push	OFFSET ??_C@_05MCCEGCIB@body_?$AA@
	push	esi
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@renumber_a

; 1603 :       oldbnum = atoi(mi->name+5);

	lea	eax, DWORD PTR [esi+5]
	push	eax
	call	_atoi

; 1604 :       newbnum = loc_ordinal(bibase[oldbnum-1]->self_id)+1;

	mov	ecx, DWORD PTR _bibase
	mov	edx, DWORD PTR [ecx+eax*4-4]
	mov	eax, DWORD PTR [edx+16]
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN113@renumber_a
	and	eax, 134217727				; 07ffffffH
	mov	edi, eax
	jmp	SHORT $LN114@renumber_a
$LN113@renumber_a:
	or	edi, -1
$LN114@renumber_a:

; 1605 :       nametail = strchr(mi->name+6,'_');

	lea	eax, DWORD PTR [esi+6]
	push	95					; 0000005fH
	push	eax
	call	_strchr

; 1606 :       sprintf(newname,"body_%d%s",newbnum,nametail);

	push	eax
	inc	edi
	push	edi
	lea	ecx, DWORD PTR _newname$90133[ebp]
	push	OFFSET ??_C@_09BNMFOCDE@body_?$CFd?$CFs?$AA@
	push	ecx
	call	_sprintf

; 1607 :       strcpy(mi->name,newname);

	lea	eax, DWORD PTR _newname$90133[ebp]
	mov	edx, eax
	add	esp, 24					; 00000018H
	sub	esi, edx
$LL115@renumber_a:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [esi+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL115@renumber_a
$LN9@renumber_a:

; 1597 :     }
; 1598 :     for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	ebx
	cmp	ebx, DWORD PTR _web+5560
	jl	$LL10@renumber_a
$LN169@renumber_a:

; 1608 :     }
; 1609 :   }
; 1610 : 
; 1611 :   /* swap ibase to new */
; 1612 :   for ( type = VERTEX ; type <= FACETEDGE ; type++ )

	mov	esi, OFFSET _web+12
	lea	edi, DWORD PTR _newibase$[ebp]
	pop	ebx
$LL4@renumber_a:

; 1613 :   { myfree((char*)(web.skel[type].ibase));

	mov	eax, DWORD PTR [esi]
	push	eax
	call	_myfree

; 1614 :     web.skel[type].ibase = newibase[type];

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx
	add	esi, 112				; 00000070H
	add	esp, 4
	add	edi, 4
	cmp	esi, OFFSET _web+460
	jle	SHORT $LL4@renumber_a

; 1615 :   }
; 1616 :   vibase = web.skel[VERTEX].ibase;
; 1617 :   eibase = web.skel[EDGE].ibase;

	mov	eax, DWORD PTR _web+124
	mov	edx, DWORD PTR _web+12

; 1618 :   fibase = web.skel[FACET].ibase;

	mov	ecx, DWORD PTR _web+236
	mov	DWORD PTR _eibase, eax

; 1619 :   bibase = web.skel[BODY].ibase;
; 1620 :   feibase = web.skel[FACETEDGE].ibase;

	mov	eax, DWORD PTR _web+460
	mov	DWORD PTR _feibase, eax

; 1621 : 
; 1622 :   global_timestamp++;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax

; 1623 :   top_timestamp = global_timestamp;
; 1624 :   
; 1625 :   LEAVE_GRAPH_MUTEX

	cmp	DWORD PTR _did_graphlock_here$89927[ebp], 0
	mov	DWORD PTR _vibase, edx
	mov	edx, DWORD PTR _web+348
	pop	edi
	mov	DWORD PTR _fibase, ecx
	mov	DWORD PTR _bibase, edx
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	esi
	je	SHORT $LN1@renumber_a
	mov	ecx, DWORD PTR _graphmutex
	push	ecx
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@renumber_a:

; 1626 : } // end renumber_all()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_renumber_all ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_0DL@EADIIDCI@get_extra_attribute_value?$CI?$CJ?5tryi@ ; `string'
PUBLIC	??_C@_0CK@KHADEJE@Attribute?5?$CFs?5index?5zero?5or?5negat@ ; `string'
PUBLIC	??_C@_0DA@PFFFPJEC@Attribute?5?$CFs?5total?5index?5is?5?$CFd?$DL?5@ ; `string'
PUBLIC	_get_extra_attrib_value
;	COMDAT __real@0000000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0DL@EADIIDCI@get_extra_attribute_value?$CI?$CJ?5tryi@
CONST	SEGMENT
??_C@_0DL@EADIIDCI@get_extra_attribute_value?$CI?$CJ?5tryi@ DB 'get_extra'
	DB	'_attribute_value() trying to get nonumeric type.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KHADEJE@Attribute?5?$CFs?5index?5zero?5or?5negat@
CONST	SEGMENT
??_C@_0CK@KHADEJE@Attribute?5?$CFs?5index?5zero?5or?5negat@ DB 'Attribute'
	DB	' %s index zero or negative: %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PFFFPJEC@Attribute?5?$CFs?5total?5index?5is?5?$CFd?$DL?5@
CONST	SEGMENT
??_C@_0DA@PFFFPJEC@Attribute?5?$CFs?5total?5index?5is?5?$CFd?$DL?5@ DB 'A'
	DB	'ttribute %s total index is %d; maximum is %d.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\storage.c
CONST	ENDS
;	COMDAT _get_extra_attrib_value
_TEXT	SEGMENT
_id$ = 8						; size = 4
tv366 = 12						; size = 4
tv359 = 12						; size = 4
tv356 = 12						; size = 4
tv317 = 12						; size = 4
tv312 = 12						; size = 4
tv195 = 12						; size = 4
tv69 = 12						; size = 4
_ext$ = 12						; size = 4
_inx$ = 16						; size = 4
_get_extra_attrib_value PROC				; COMDAT

; 1721 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 1722 :   if ( inx >= ext->array_spec.datacount )

	mov	esi, DWORD PTR _ext$[ebp]
	mov	eax, DWORD PTR [esi+88]
	push	edi
	mov	edi, DWORD PTR _inx$[ebp]
	cmp	edi, eax
	jl	SHORT $LN15@get_extra_

; 1723 :   { sprintf(errmsg,"Attribute %s total index is %d; maximum is %d.\n",
; 1724 :        ext->name,inx+1,ext->array_spec.datacount);

	push	eax
	lea	eax, DWORD PTR [edi+1]
	push	eax
	push	esi
	push	OFFSET ??_C@_0DA@PFFFPJEC@Attribute?5?$CFs?5total?5index?5is?5?$CFd?$DL?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1725 :     kb_error(1151,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1151					; 0000047fH
	call	_kb_error
	add	esp, 32					; 00000020H
$LN15@get_extra_:

; 1726 :   }
; 1727 :   if ( inx < 0 )

	test	edi, edi
	jns	SHORT $LN14@get_extra_

; 1728 :   { sprintf(errmsg,"Attribute %s index zero or negative: %d.\n",
; 1729 :     ext->name,inx+1);

	lea	ecx, DWORD PTR [edi+1]
	push	ecx
	push	esi
	push	OFFSET ??_C@_0CK@KHADEJE@Attribute?5?$CFs?5index?5zero?5or?5negat@
	push	OFFSET _errmsg
	call	_sprintf

; 1730 :   kb_error(2523,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2523					; 000009dbH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN14@get_extra_:

; 1731 :   }
; 1732 : 
; 1733 :   switch ( ext->type )

	mov	eax, DWORD PTR [esi+68]
	dec	eax
	cmp	eax, 11					; 0000000bH
	ja	$LN1@get_extra_
	jmp	DWORD PTR $LN41@get_extra_[eax*4]
$LN11@get_extra_:

; 1734 :   { case REAL_TYPE: return ((REAL*)get_extra_ptr(id,ext))[inx];

	mov	eax, DWORD PTR _id$[ebp]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	add	edx, DWORD PTR [esi+64]
	fld	QWORD PTR [edx+edi*8]
	pop	edi
	pop	esi

; 1757 : } // end get_extra_attrib_value()

	pop	ebp
	ret	0
$LN10@get_extra_:

; 1735 :     case INTEGER_TYPE: return (REAL)(((int*)get_extra_ptr(id,ext))[inx]);

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, DWORD PTR [esi+64]
	fild	DWORD PTR [eax+edi*4]
	pop	edi
	pop	esi

; 1757 : } // end get_extra_attrib_value()

	pop	ebp
	ret	0
$LN9@get_extra_:

; 1736 :     case UINT_TYPE: return (REAL)(((unsigned int*)get_extra_ptr(id,ext))[inx]);

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, DWORD PTR [esi+64]
	mov	ecx, DWORD PTR [eax+edi*4]
	fild	DWORD PTR [eax+edi*4]
	test	ecx, ecx
	jns	$LN16@get_extra_
	fadd	QWORD PTR __real@41f0000000000000
	pop	edi
	pop	esi

; 1757 : } // end get_extra_attrib_value()

	pop	ebp
	ret	0
$LN8@get_extra_:

; 1737 :     case UCHAR_TYPE: 
; 1738 :       return (REAL)(((unsigned char*)get_extra_ptr(id,ext))[inx]);

	mov	eax, DWORD PTR _id$[ebp]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	add	edx, DWORD PTR [esi+64]
	movzx	eax, BYTE PTR [edx+edi]
	mov	DWORD PTR tv359[ebp], eax
	pop	edi
	pop	esi
	fild	DWORD PTR tv359[ebp]

; 1757 : } // end get_extra_attrib_value()

	pop	ebp
	ret	0
$LN7@get_extra_:

; 1739 :     case CHAR_TYPE: 
; 1740 :       return (REAL)(((char*)get_extra_ptr(id,ext))[inx]);

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, DWORD PTR [esi+64]
	movsx	ecx, BYTE PTR [eax+edi]
	mov	DWORD PTR tv195[ebp], ecx
	pop	edi
	pop	esi
	fild	DWORD PTR tv195[ebp]

; 1757 : } // end get_extra_attrib_value()

	pop	ebp
	ret	0
$LN6@get_extra_:

; 1741 :     case USHORT_TYPE: 
; 1742 :       return (REAL)(((unsigned short int*)get_extra_ptr(id,ext))[inx]);

	mov	eax, DWORD PTR _id$[ebp]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	add	edx, DWORD PTR [esi+64]
	movzx	eax, WORD PTR [edx+edi*2]
	mov	DWORD PTR tv366[ebp], eax
	pop	edi
	pop	esi
	fild	DWORD PTR tv366[ebp]

; 1757 : } // end get_extra_attrib_value()

	pop	ebp
	ret	0
$LN5@get_extra_:

; 1743 :     case SHORT_TYPE: 
; 1744 :       return (REAL)(((short int*)get_extra_ptr(id,ext))[inx]);

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, DWORD PTR [esi+64]
	movsx	ecx, WORD PTR [eax+edi*2]
	mov	DWORD PTR tv69[ebp], ecx
	pop	edi
	pop	esi
	fild	DWORD PTR tv69[ebp]

; 1757 : } // end get_extra_attrib_value()

	pop	ebp
	ret	0
$LN4@get_extra_:

; 1745 :     case ULONG_TYPE: 
; 1746 :       return (REAL)(((unsigned long int*)get_extra_ptr(id,ext))[inx]);

	mov	eax, DWORD PTR _id$[ebp]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	add	edx, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [edx+edi*4]
	fild	DWORD PTR [edx+edi*4]
	test	eax, eax
	jns	SHORT $LN16@get_extra_
	fadd	QWORD PTR __real@41f0000000000000
	pop	edi
	pop	esi

; 1757 : } // end get_extra_attrib_value()

	pop	ebp
	ret	0
$LN1@get_extra_:

; 1747 :     case LONG_TYPE: 
; 1748 :       return (REAL)(((long int*)get_extra_ptr(id,ext))[inx]);
; 1749 :     case PTR_TYPE: 
; 1750 :       return (REAL)(unsigned long int)(((char**)get_extra_ptr(id,ext))[inx]);
; 1751 :     default: kb_error(3101,
; 1752 :       "get_extra_attribute_value() trying to get nonumeric type.\n",
; 1753 :            RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DL@EADIIDCI@get_extra_attribute_value?$CI?$CJ?5tryi@
	push	3101					; 00000c1dH
	call	_kb_error

; 1754 :      break;
; 1755 :   }
; 1756 :   return 0.0;  /* shouldn't get here. */

	fldz
	add	esp, 12					; 0000000cH
$LN16@get_extra_:
	pop	edi
	pop	esi

; 1757 : } // end get_extra_attrib_value()

	pop	ebp
	ret	0
	npad	1
$LN41@get_extra_:
	DD	$LN11@get_extra_
	DD	$LN10@get_extra_
	DD	$LN4@get_extra_
	DD	$LN8@get_extra_
	DD	$LN6@get_extra_
	DD	$LN9@get_extra_
	DD	$LN10@get_extra_
	DD	$LN7@get_extra_
	DD	$LN5@get_extra_
	DD	$LN1@get_extra_
	DD	$LN1@get_extra_
	DD	$LN9@get_extra_
_get_extra_attrib_value ENDP
_TEXT	ENDS
PUBLIC	_int32hash
; Function compile flags: /Ogtp
;	COMDAT _int32hash
_TEXT	SEGMENT
_key$ = 8						; size = 4
_int32hash PROC						; COMDAT

; 1777 : {

	push	ebp
	mov	ebp, esp

; 1778 :   key += ~(key << 15);

	mov	ecx, DWORD PTR _key$[ebp]
	mov	eax, ecx
	shl	eax, 15					; 0000000fH
	not	eax
	add	ecx, eax

; 1779 :   key ^=  (key >> 10);

	mov	eax, ecx
	shr	eax, 10					; 0000000aH
	xor	eax, ecx

; 1780 :   key +=  (key << 3);

	lea	ecx, DWORD PTR [eax+eax*8]

; 1781 :   key ^=  (key >> 6);

	mov	edx, ecx
	shr	edx, 6
	xor	ecx, edx

; 1782 :   key += ~(key << 11);

	mov	eax, ecx
	shl	eax, 11					; 0000000bH
	not	eax
	add	ecx, eax

; 1783 :   key ^=  (key >> 16);

	mov	eax, ecx
	shr	eax, 16					; 00000010H
	xor	eax, ecx

; 1784 :   return key;
; 1785 : } // end int32hash()

	pop	ebp
	ret	0
_int32hash ENDP
_TEXT	ENDS
PUBLIC	_int64hash
; Function compile flags: /Ogtp
;	COMDAT _int64hash
_TEXT	SEGMENT
_key$ = 8						; size = 8
_int64hash PROC						; COMDAT

; 1801 : {

	push	ebp
	mov	ebp, esp

; 1802 :   key += ~(key << 32);

	push	esi

; 1805 :   key ^= (key >> 8);

	push	edi

; 1802 :   key += ~(key << 32);

	mov	eax, DWORD PTR _key$[ebp]
	xor	ecx, ecx
	mov	edx, eax
	not	edx
	not	ecx
	add	eax, ecx
	mov	ecx, DWORD PTR _key$[ebp+4]
	adc	ecx, edx

; 1803 :   key ^= (key >> 22);

	mov	edx, eax
	mov	esi, ecx
	shrd	edx, esi, 22
	xor	eax, edx
	shr	esi, 22					; 00000016H
	xor	ecx, esi

; 1804 :   key += ~(key << 13);

	mov	edx, eax
	mov	esi, ecx
	shld	esi, edx, 13
	shl	edx, 13					; 0000000dH
	not	edx
	add	eax, edx
	not	esi
	adc	ecx, esi

; 1805 :   key ^= (key >> 8);

	mov	edx, eax
	mov	esi, ecx
	shrd	edx, esi, 8
	xor	edx, eax
	shr	esi, 8
	mov	edi, esi
	xor	edi, ecx

; 1806 :   key += (key << 3);

	mov	ecx, edx
	mov	esi, edi
	shld	edi, edx, 3
	add	edx, edx
	add	edx, edx
	add	edx, edx
	add	ecx, edx
	adc	esi, edi

; 1807 :   key ^= (key >> 15);

	mov	edx, esi
	mov	eax, ecx
	shrd	eax, edx, 15
	shr	edx, 15					; 0000000fH
	xor	esi, edx
	xor	ecx, eax

; 1808 :   key += ~(key << 27);

	mov	edx, esi
	mov	eax, ecx
	shld	edx, eax, 27
	shl	eax, 27					; 0000001bH
	not	eax
	not	edx
	add	ecx, eax
	adc	esi, edx

; 1809 :   key ^= (key >> 31);

	mov	edx, esi
	mov	eax, ecx
	shrd	eax, edx, 31
	shr	edx, 31					; 0000001fH
	xor	eax, ecx
	pop	edi
	xor	edx, esi
	pop	esi

; 1810 :   return key;
; 1811 : } // end int64hash()

	pop	ebp
	ret	0
_int64hash ENDP
_TEXT	ENDS
PUBLIC	_elhash_lookup
; Function compile flags: /Ogtp
;	COMDAT _elhash_lookup
_TEXT	SEGMENT
_id$ = 8						; size = 4
_elhash_lookup PROC					; COMDAT

; 1822 : { element_id key;

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 1823 :   int inx;
; 1824 : 
; 1825 :   key = id_hash(id);

	mov	edi, DWORD PTR _id$[ebp]
	mov	eax, edi
	and	eax, -402653185				; e7ffffffH
	push	eax
	call	_int32hash

; 1826 :   inx = ((int)key) & web.elhashmask;

	mov	esi, DWORD PTR _web+608

; 1827 :   for (;;)
; 1828 :   { if ( web.elhashtable[inx] == NULL )

	mov	edx, DWORD PTR _web+600
	and	eax, esi
	mov	ecx, DWORD PTR [edx+eax*4]
	add	esp, 4
	test	ecx, ecx
	je	SHORT $LN10@elhash_loo
	npad	2
$LL5@elhash_loo:

; 1830 :     if ( web.elhashtable[inx] != ELHASH_FREE )

	cmp	ecx, 1
	je	SHORT $LN1@elhash_loo

; 1831 :       if ( equal_element(web.elhashtable[inx]->self_id,id) )

	mov	ecx, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [ecx+16]
	mov	ebx, edi
	or	ecx, 134217728				; 08000000H
	or	ebx, 134217728				; 08000000H
	cmp	ecx, ebx
	je	SHORT $LN11@elhash_loo
$LN1@elhash_loo:

; 1833 :     inx++;

	inc	eax

; 1834 :     inx &= web.elhashmask; /* wraparound, maybe */

	and	eax, esi
	mov	ecx, DWORD PTR [edx+eax*4]
	test	ecx, ecx
	jne	SHORT $LL5@elhash_loo
$LN10@elhash_loo:
	pop	edi
	pop	esi

; 1829 :       return NULL;

	xor	eax, eax
	pop	ebx

; 1835 :   }
; 1836 : 
; 1837 : } // end elhash_lookup()

	pop	ebp
	ret	0
$LN11@elhash_loo:

; 1832 :         return web.elhashtable[inx];

	mov	eax, DWORD PTR [edx+eax*4]
	pop	edi
	pop	esi
	pop	ebx

; 1835 :   }
; 1836 : 
; 1837 : } // end elhash_lookup()

	pop	ebp
	ret	0
_elhash_lookup ENDP
_TEXT	ENDS
PUBLIC	_elhash_insert
PUBLIC	_elhash_bigger
; Function compile flags: /Ogtp
;	COMDAT _elhash_bigger
_TEXT	SEGMENT
_elhash_bigger PROC					; COMDAT

; 1848 : { int oldsize = web.elhashsize;

	mov	eax, DWORD PTR _web+612
	push	ebx
	push	esi

; 1849 :   struct element ** oldtable;
; 1850 :   int n;
; 1851 : 
; 1852 :   if ( web.elhashsize == 0 )

	xor	esi, esi
	push	edi
	mov	ebx, eax
	cmp	eax, esi
	jne	SHORT $LN6@elhash_big

; 1853 :   { web.elhashsize = 4096;

	mov	eax, 4096				; 00001000H

; 1854 :     web.elhashmask = 0xFFF;

	mov	DWORD PTR _web+608, 4095		; 00000fffH

; 1855 :   }
; 1856 :   else

	jmp	SHORT $LN13@elhash_big
$LN6@elhash_big:

; 1857 :   {
; 1858 :     web.elhashmask |= web.elhashsize; /* depending on power of 2 */

	or	DWORD PTR _web+608, eax

; 1859 :     web.elhashsize *= 2;

	add	eax, eax
$LN13@elhash_big:

; 1860 :   }
; 1861 : 
; 1862 :   oldtable = web.elhashtable;

	mov	edi, DWORD PTR _web+600

; 1863 :   web.elhashtable = (struct element **)mycalloc(web.elhashsize,sizeof(struct element*));

	push	1863					; 00000747H
	push	OFFSET ??_C@_09EOIFBANE@STORAGE?4C?$AA@
	push	4
	push	eax
	mov	DWORD PTR _web+612, eax
	call	_kb_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _web+600, eax

; 1864 : 
; 1865 :   /* rehash */
; 1866 :   web.elhashcount = 0;

	mov	DWORD PTR _web+604, esi

; 1867 :   for ( n = 0 ; n < oldsize ; n++ )

	test	ebx, ebx
	jle	SHORT $LN2@elhash_big
$LL12@elhash_big:

; 1868 :     if ( oldtable[n] && (oldtable[n] != ELHASH_FREE) )

	mov	eax, DWORD PTR [edi+esi*4]
	test	eax, eax
	je	SHORT $LN3@elhash_big
	cmp	eax, 1
	je	SHORT $LN3@elhash_big

; 1869 :       elhash_insert(oldtable[n]->self_id,oldtable[n]);

	push	eax
	mov	eax, DWORD PTR [eax+16]
	push	eax
	call	_elhash_insert
	add	esp, 8
$LN3@elhash_big:

; 1867 :   for ( n = 0 ; n < oldsize ; n++ )

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL12@elhash_big
$LN2@elhash_big:
	pop	edi
	pop	esi
	pop	ebx

; 1870 : } // end elhash_bigger()

	ret	0
_elhash_bigger ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@HPEOCNNK@Internal?5error?3?5bad?5mode?5for?5elh@ ; `string'
PUBLIC	_elhash_extend
;	COMDAT ??_C@_0CP@HPEOCNNK@Internal?5error?3?5bad?5mode?5for?5elh@
CONST	SEGMENT
??_C@_0CP@HPEOCNNK@Internal?5error?3?5bad?5mode?5for?5elh@ DB 'Internal e'
	DB	'rror: bad mode for elhash_extend().', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _elhash_extend
_TEXT	SEGMENT
tv340 = -12						; size = 4
_oldnum$ = -8						; size = 4
_did_graphlock_here$90321 = -4				; size = 4
_newnum$ = 8						; size = 4
_type$ = 8						; size = 4
_newblock$ = 12						; size = 4
_mode$ = 12						; size = 4
_elhash_extend PROC					; COMDAT

; 1883 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 1884 :   int number=0;  /* of new items to allocate */
; 1885 :   char *newblock;
; 1886 :   INDIRECT_TYPE *newiblock;
; 1887 :   struct element *newptr = NULL, *oldptr;
; 1888 :   int k;
; 1889 :   int allocsize;
; 1890 :   long  oldnum = web.skel[type].maxcount;

	mov	ebx, DWORD PTR _type$[ebp]
	push	esi
	push	edi
	mov	edi, ebx
	imul	edi, 112				; 00000070H
	mov	eax, DWORD PTR _web[edi+20]
	xor	esi, esi
	mov	DWORD PTR _oldnum$[ebp], eax

; 1891 :   long  newnum=0;

	mov	DWORD PTR _newnum$[ebp], esi

; 1892 : 
; 1893 :   ENTER_GRAPH_MUTEX;

	call	DWORD PTR __imp__GetCurrentThreadId@0
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN26@elhash_ext
	push	esi
	push	100000					; 000186a0H
	push	esi
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$90321[ebp], 1
	jmp	SHORT $LN25@elhash_ext
$LN26@elhash_ext:
	mov	DWORD PTR _did_graphlock_here$90321[ebp], esi
$LN25@elhash_ext:

; 1894 :   /* Don't mess with structures while graph thread using them */
; 1895 : 
; 1896 :   if ( blockcount[type] >= blockmax[type] )

	mov	eax, DWORD PTR _blockcount[ebx*4]
	cmp	eax, DWORD PTR _blockmax[ebx*4]
	jl	SHORT $LN24@elhash_ext

; 1897 :   { blocklist[type] = (struct blocklist_struct*)
; 1898 :       kb_realloc((char*)(blocklist[type]),
; 1899 :          (blockcount[type]+BATCHSIZE)*sizeof(struct blocklist_struct));

	mov	edx, DWORD PTR _blocklist[ebx*4]
	lea	ecx, DWORD PTR [eax+eax*2+3000]
	push	1899					; 0000076bH
	add	ecx, ecx
	push	OFFSET ??_C@_09EOIFBANE@STORAGE?4C?$AA@
	add	ecx, ecx
	push	ecx
	push	edx
	call	_KB_realloc
	add	esp, 16					; 00000010H

; 1900 :      blockmax[type] += BATCHSIZE;

	add	DWORD PTR _blockmax[ebx*4], 1000	; 000003e8H
	mov	DWORD PTR _blocklist[ebx*4], eax
$LN24@elhash_ext:

; 1901 :   }
; 1902 :   if ( mode == EXTEND_BATCH )

	mov	eax, DWORD PTR _mode$[ebp]
	cmp	eax, 1
	jne	SHORT $LN23@elhash_ext

; 1903 :   {
; 1904 :     /* calculate number of structures to fit in block size just under 2^n */
; 1905 :     allocsize = BATCHSIZE*web.sizes[type];

	mov	esi, DWORD PTR _web[ebx*4+560]
	mov	eax, esi
	imul	eax, 1000				; 000003e8H

; 1906 :     k = 0x100 ; while ( k < allocsize ) k <<= 1 ;

	mov	ecx, 256				; 00000100H
	cmp	eax, ecx
	jle	SHORT $LN21@elhash_ext
$LL22@elhash_ext:
	add	ecx, ecx
	cmp	ecx, eax
	jl	SHORT $LL22@elhash_ext
$LN21@elhash_ext:

; 1907 :     number = (k-16)/web.sizes[type]; /* maybe room for block header */

	lea	eax, DWORD PTR [ecx-16]
	cdq
	idiv	esi
	mov	esi, eax

; 1908 :     newnum = web.skel[type].maxcount + number;

	mov	eax, DWORD PTR _web[edi+20]
	add	eax, esi
	mov	DWORD PTR _newnum$[ebp], eax
	jmp	SHORT $LN17@elhash_ext
$LN23@elhash_ext:

; 1909 :   }
; 1910 :   else if ( mode == EXTEND_FOR_REFINE )

	cmp	eax, 2
	jne	SHORT $LN19@elhash_ext

; 1911 :   { /* increase by 2^surface_dimension factor */
; 1912 :     number = web.skel[type].count*(1<<web.dimension)
; 1913 :                 - web.skel[type].maxcount + 100;

	mov	ecx, DWORD PTR _web+620
	mov	eax, DWORD PTR _web[edi+20]
	mov	esi, 1
	shl	esi, cl
	imul	esi, DWORD PTR _web[edi+64]
	sub	esi, eax
	add	esi, 100				; 00000064H

; 1914 :     newnum = web.skel[type].maxcount + number;

	add	eax, esi
	mov	DWORD PTR _newnum$[ebp], eax

; 1915 :     if ( number <= 0 ) { goto elhash_extend_exit; }/* don't need any more */

	test	esi, esi
	jle	$elhash_extend_exit$90335

; 1916 :   }
; 1917 :   else kb_error(2476,"Internal error: bad mode for elhash_extend().\n",

	jmp	SHORT $LN17@elhash_ext
$LN19@elhash_ext:

; 1918 :     RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CP@HPEOCNNK@Internal?5error?3?5bad?5mode?5for?5elh@
	push	2476					; 000009acH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN17@elhash_ext:

; 1919 :   
; 1920 :   if ( (web.skel[type].maxcount + number) > OFFSETMASK )

	mov	eax, DWORD PTR _web[edi+20]
	add	eax, esi
	cmp	eax, 134217727				; 07ffffffH
	jbe	SHORT $LN16@elhash_ext

; 1921 :   { sprintf(errmsg, "Trying to allocate more %s than ID format allows, %lld\n",
; 1922 :           typenames[type],(long long int)OFFSETMASK);

	mov	ecx, DWORD PTR _typenames[ebx*4]
	push	0
	push	134217727				; 07ffffffH
	push	ecx
	push	OFFSET ??_C@_0DI@JAGENGAO@Trying?5to?5allocate?5more?5?$CFs?5than?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1923 :     kb_error(3214,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3214					; 00000c8eH
	call	_kb_error
	add	esp, 32					; 00000020H
$LN16@elhash_ext:

; 1924 :   }
; 1925 : 
; 1926 :   newblock = mycalloc(number,web.sizes[type]);

	mov	edx, DWORD PTR _web[ebx*4+560]
	lea	eax, DWORD PTR _web[ebx*4+560]
	push	1926					; 00000786H
	push	OFFSET ??_C@_09EOIFBANE@STORAGE?4C?$AA@
	push	edx
	push	esi
	mov	DWORD PTR tv340[ebp], eax
	call	_kb_calloc

; 1927 :   blocklist[type][blockcount[type]].start_ord = oldnum ;

	mov	ecx, DWORD PTR _blocklist[ebx*4]
	mov	edx, DWORD PTR _oldnum$[ebp]
	mov	DWORD PTR _newblock$[ebp], eax
	mov	eax, DWORD PTR _blockcount[ebx*4]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 1928 :   blocklist[type][blockcount[type]].count = number ;

	mov	eax, DWORD PTR _blockcount[ebx*4]
	mov	ecx, DWORD PTR _blocklist[ebx*4]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [ecx+eax*4+8], esi

; 1929 :   blocklist[type][blockcount[type]++].blockptr = (struct element *)newblock;

	mov	eax, DWORD PTR _blockcount[ebx*4]
	mov	ecx, DWORD PTR _newblock$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _blocklist[ebx*4]
	mov	DWORD PTR [eax+edx*4], ecx

; 1930 : 
; 1931 :   while ( newnum > web.skel[type].ialloc )

	mov	edx, DWORD PTR _newnum$[ebp]
	inc	DWORD PTR _blockcount[ebx*4]
	add	esp, 16					; 00000010H
	cmp	edx, DWORD PTR _web[edi+16]
	jle	$LN14@elhash_ext
$LL15@elhash_ext:

; 1932 :   {
; 1933 :     if ( web.skel[type].ibase == NULL )

	mov	eax, DWORD PTR _web[edi+12]
	test	eax, eax
	jne	SHORT $LN13@elhash_ext

; 1934 :     { newiblock = (INDIRECT_TYPE*)mycalloc(number,sizeof(INDIRECT_TYPE));

	push	1934					; 0000078eH
	push	OFFSET ??_C@_09EOIFBANE@STORAGE?4C?$AA@
	push	4
	push	esi
	call	_kb_calloc
	add	esp, 16					; 00000010H

; 1935 :       web.skel[type].ialloc = number;

	mov	DWORD PTR _web[edi+16], esi

; 1936 :     }
; 1937 :     else

	jmp	SHORT $LN12@elhash_ext
$LN13@elhash_ext:

; 1938 :     { newiblock = (INDIRECT_TYPE*)kb_realloc((char*)(web.skel[type].ibase),
; 1939 :         2*web.skel[type].ialloc*sizeof(INDIRECT_TYPE));

	mov	ecx, DWORD PTR _web[edi+16]
	add	ecx, ecx
	push	1939					; 00000793H
	add	ecx, ecx
	push	OFFSET ??_C@_09EOIFBANE@STORAGE?4C?$AA@
	add	ecx, ecx
	push	ecx
	push	eax
	call	_KB_realloc

; 1940 :       web.skel[type].ialloc *= 2;

	mov	edx, DWORD PTR _web[edi+16]
	add	esp, 16					; 00000010H
	add	edx, edx
	mov	DWORD PTR _web[edi+16], edx
$LN12@elhash_ext:

; 1941 :     }
; 1942 :     web.skel[type].ibase = newiblock;

	mov	DWORD PTR _web[edi+12], eax

; 1943 :     switch(type)

	cmp	ebx, 4
	ja	SHORT $LN10@elhash_ext
	jmp	DWORD PTR $LN34@elhash_ext[ebx*4]
$LN9@elhash_ext:

; 1944 :     {    case VERTEX: vibase = newiblock; break;

	mov	DWORD PTR _vibase, eax
	jmp	SHORT $LN10@elhash_ext
$LN8@elhash_ext:

; 1945 :          case EDGE:    eibase = newiblock; break;

	mov	DWORD PTR _eibase, eax
	jmp	SHORT $LN10@elhash_ext
$LN7@elhash_ext:

; 1946 :          case FACET:  fibase = newiblock; break;

	mov	DWORD PTR _fibase, eax
	jmp	SHORT $LN10@elhash_ext
$LN6@elhash_ext:

; 1947 :          case BODY:    bibase = newiblock; break;

	mov	DWORD PTR _bibase, eax
	jmp	SHORT $LN10@elhash_ext
$LN5@elhash_ext:

; 1948 :          case FACETEDGE: feibase = newiblock; break;

	mov	DWORD PTR _feibase, eax
$LN10@elhash_ext:

; 1930 : 
; 1931 :   while ( newnum > web.skel[type].ialloc )

	mov	eax, DWORD PTR _newnum$[ebp]
	cmp	eax, DWORD PTR _web[edi+16]
	jg	$LL15@elhash_ext
$LN14@elhash_ext:

; 1949 :     }
; 1950 :   }
; 1951 : 
; 1952 :   /* add to freelist */
; 1953 :   oldptr = (struct element *)newblock;

	mov	edx, DWORD PTR _newblock$[ebp]

; 1954 :   for ( k = 0 ; k < number ; k++ )

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN2@elhash_ext
$LL4@elhash_ext:

; 1955 :   { newptr = (struct element *)(newblock + k*web.sizes[type]); 

	mov	eax, DWORD PTR tv340[ebp]
	mov	eax, DWORD PTR [eax]
	imul	eax, ecx
	add	eax, DWORD PTR _newblock$[ebp]
	inc	ecx

; 1956 :     *(struct element**)&(oldptr->forechain) = newptr;

	mov	DWORD PTR [edx], eax

; 1957 :     oldptr = newptr;

	mov	edx, eax
	cmp	ecx, esi
	jl	SHORT $LL4@elhash_ext
$LN2@elhash_ext:

; 1958 :   }
; 1959 :   *(struct element**)&(oldptr->forechain) = web.skel[type].freehead;

	mov	ecx, DWORD PTR _web[edi+40]
	mov	DWORD PTR [edx], ecx

; 1960 :   web.skel[type].freehead = (struct element *)newblock;

	mov	edx, DWORD PTR _newblock$[ebp]
	mov	DWORD PTR _web[edi+40], edx
$elhash_extend_exit$90335:

; 1961 :   
; 1962 : elhash_extend_exit:
; 1963 :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$90321[ebp], 0
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN1@elhash_ext
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@elhash_ext:

; 1964 :   
; 1965 : } // end elhash_extend()

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN34@elhash_ext:
	DD	$LN9@elhash_ext
	DD	$LN8@elhash_ext
	DD	$LN7@elhash_ext
	DD	$LN6@elhash_ext
	DD	$LN5@elhash_ext
_elhash_extend ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _elhash_insert
_TEXT	SEGMENT
_id$ = 8						; size = 4
_eptr$ = 12						; size = 4
_elhash_insert PROC					; COMDAT

; 2032 : { element_id key;

	push	ebp
	mov	ebp, esp

; 2033 :   int inx;
; 2034 :   
; 2035 :   if ( web.elhashcount >= web.elhashsize/2 )

	mov	eax, DWORD PTR _web+612
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _web+604, eax
	jl	SHORT $LN6@elhash_ins

; 2036 :     elhash_bigger();

	call	_elhash_bigger
$LN6@elhash_ins:
	push	ebx
	push	esi
	push	edi

; 2037 : 
; 2038 :   key = id_hash(id);

	mov	edi, DWORD PTR _id$[ebp]
	mov	eax, edi
	and	eax, -402653185				; e7ffffffH
	push	eax
	call	_int32hash

; 2039 :   inx = ((int)key) & web.elhashmask;

	mov	esi, DWORD PTR _web+608

; 2040 :   for (;;)
; 2041 :   { if ( (web.elhashtable[inx] == NULL)
; 2042 :       || (web.elhashtable[inx] == ELHASH_FREE) )

	mov	edx, DWORD PTR _web+600
	and	eax, esi
	mov	ecx, DWORD PTR [edx+eax*4]
	add	esp, 4
	test	ecx, ecx
	je	SHORT $LN2@elhash_ins
$LL5@elhash_ins:
	cmp	ecx, 1
	je	SHORT $LN2@elhash_ins

; 2045 :       return;
; 2046 :     }
; 2047 :     if ( equal_element(web.elhashtable[inx]->self_id,id))

	mov	ecx, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [ecx+16]
	mov	ebx, edi
	or	ecx, 134217728				; 08000000H
	or	ebx, 134217728				; 08000000H
	cmp	ecx, ebx
	je	SHORT $LN11@elhash_ins

; 2049 :       return;
; 2050 :     }
; 2051 :     inx++;

	inc	eax

; 2052 :     inx &= web.elhashmask; /* wraparound, maybe */

	and	eax, esi
	mov	ecx, DWORD PTR [edx+eax*4]
	test	ecx, ecx
	jne	SHORT $LL5@elhash_ins
$LN2@elhash_ins:

; 2043 :     { web.elhashtable[inx] = eptr;

	mov	ecx, DWORD PTR _eptr$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+eax*4], ecx

; 2044 :       web.elhashcount++;

	inc	DWORD PTR _web+604
	pop	ebx

; 2053 :   }
; 2054 :    
; 2055 : } // end elhash_insert()

	pop	ebp
	ret	0
$LN11@elhash_ins:

; 2048 :     { web.elhashtable[inx] = eptr;  /* maybe change due to expand() */

	mov	ecx, DWORD PTR _eptr$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+eax*4], ecx
	pop	ebx

; 2053 :   }
; 2054 :    
; 2055 : } // end elhash_insert()

	pop	ebp
	ret	0
_elhash_insert ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@CAECHKFB@INTERNAL?5ERROR?5?9?5elhash_replace?$CI@ ; `string'
PUBLIC	_elhash_replace
;	COMDAT ??_C@_0DF@CAECHKFB@INTERNAL?5ERROR?5?9?5elhash_replace?$CI@
CONST	SEGMENT
??_C@_0DF@CAECHKFB@INTERNAL?5ERROR?5?9?5elhash_replace?$CI@ DB 'INTERNAL '
	DB	'ERROR - elhash_replace(): entry not found.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _elhash_replace
_TEXT	SEGMENT
_id$ = 8						; size = 4
_eptr$ = 12						; size = 4
_elhash_replace PROC					; COMDAT

; 2068 : { element_id key;

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2069 :   int inx;
; 2070 :   
; 2071 :   key = id_hash(id);

	mov	edi, DWORD PTR _id$[ebp]
	mov	eax, edi
	and	eax, -402653185				; e7ffffffH
	push	eax
	call	_int32hash
	mov	esi, eax

; 2072 :   inx = ((int)key) & web.elhashmask;

	mov	eax, DWORD PTR _web+600
	add	esp, 4
$LN12@elhash_rep:
	and	esi, DWORD PTR _web+608

; 2073 :   for (;;)
; 2074 :   { if ( web.elhashtable[inx] == NULL)

	cmp	DWORD PTR [eax+esi*4], 0
	jne	SHORT $LN3@elhash_rep

; 2075 :       kb_error(4382,"INTERNAL ERROR - elhash_replace(): entry not found.\n", RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DF@CAECHKFB@INTERNAL?5ERROR?5?9?5elhash_replace?$CI@
	push	4382					; 0000111eH
	call	_kb_error
	mov	eax, DWORD PTR _web+600
	add	esp, 12					; 0000000cH
$LN3@elhash_rep:

; 2076 :     if ( web.elhashtable[inx] != ELHASH_FREE )

	cmp	DWORD PTR [eax+esi*4], 1
	je	SHORT $LN1@elhash_rep

; 2077 :       if ( equal_element(web.elhashtable[inx]->self_id,id))

	mov	ecx, DWORD PTR [eax+esi*4]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, edi
	or	edx, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	edx, ecx
	je	SHORT $LN11@elhash_rep
$LN1@elhash_rep:

; 2079 :         return;
; 2080 :       }
; 2081 :     inx++;

	inc	esi

; 2082 :     inx &= web.elhashmask; /* wraparound, maybe */
; 2083 :   }

	jmp	SHORT $LN12@elhash_rep
$LN11@elhash_rep:

; 2078 :       { web.elhashtable[inx] = eptr;  /* maybe change due to expand() */

	mov	edx, DWORD PTR _eptr$[ebp]
	pop	edi
	mov	DWORD PTR [eax+esi*4], edx
	pop	esi

; 2084 :    
; 2085 : } // end elhash_replace()

	pop	ebp
	ret	0
_elhash_replace ENDP
_TEXT	ENDS
PUBLIC	_elhash_delete
; Function compile flags: /Ogtp
;	COMDAT _elhash_delete
_TEXT	SEGMENT
_id$ = 8						; size = 4
_elhash_delete PROC					; COMDAT

; 2095 : { element_id key;

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2096 :   int inx;
; 2097 : 
; 2098 :   /* First, find it */
; 2099 :   key = id_hash(id);

	mov	edi, DWORD PTR _id$[ebp]
	mov	eax, edi
	and	eax, -402653185				; e7ffffffH
	push	eax
	call	_int32hash

; 2100 :   inx = ((int)key) & web.elhashmask;

	mov	esi, DWORD PTR _web+608

; 2101 :   for (;;)
; 2102 :   { if ( web.elhashtable[inx] == NULL )

	mov	edx, DWORD PTR _web+600
	and	eax, esi
	mov	ecx, DWORD PTR [edx+eax*4]
	add	esp, 4
	test	ecx, ecx
	je	SHORT $LN5@elhash_del
	push	ebx
	npad	2
$LL4@elhash_del:

; 2103 :       return; /* wasn't there */
; 2104 :     if ( (web.elhashtable[inx] != ELHASH_FREE) &&
; 2105 :             (equal_element(web.elhashtable[inx]->self_id,id)) )

	cmp	ecx, 1
	je	SHORT $LN1@elhash_del
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [ecx+16]
	mov	ebx, edi
	or	ecx, 134217728				; 08000000H
	or	ebx, 134217728				; 08000000H
	cmp	ecx, ebx
	je	SHORT $LN10@elhash_del
$LN1@elhash_del:

; 2106 :       break;
; 2107 :     inx++;

	inc	eax

; 2108 :     inx &= web.elhashmask; /* wraparound, maybe */

	and	eax, esi
	mov	ecx, DWORD PTR [edx+eax*4]
	test	ecx, ecx
	jne	SHORT $LL4@elhash_del
	pop	ebx
	pop	edi
	pop	esi

; 2115 : } // end elhash_delete()

	pop	ebp
	ret	0
$LN10@elhash_del:

; 2109 :   }
; 2110 : 
; 2111 :   /* mark as freed, not empty, so searches will continue past */
; 2112 :   web.elhashtable[inx] = ELHASH_FREE;

	mov	DWORD PTR [edx+eax*4], 1

; 2113 : 
; 2114 :   web.elhashcount--;

	dec	DWORD PTR _web+604
	pop	ebx
$LN5@elhash_del:
	pop	edi
	pop	esi

; 2115 : } // end elhash_delete()

	pop	ebp
	ret	0
_elhash_delete ENDP
_TEXT	ENDS
PUBLIC	_valid_element
; Function compile flags: /Ogtp
;	COMDAT _valid_element
_TEXT	SEGMENT
_id$ = 8						; size = 4
_valid_element PROC					; COMDAT

; 2146 : { struct element *ep;

	push	ebp
	mov	ebp, esp

; 2147 :   int type = id_type(id);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	shr	eax, 29					; 0000001dH

; 2148 :   if ( type > FACETEDGE ) return 0;

	cmp	eax, 4
	jg	SHORT $LN1@valid_elem

; 2149 :   if ( !valid_id(id) ) return 0;

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN1@valid_elem

; 2150 : #ifdef MPI_EVOLVER
; 2151 :   if ( id_task(id) == this_task )
; 2152 : #endif
; 2153 :   if ( ordinal(id) > web.skel[type].max_ord ) return 0;

	mov	edx, eax
	imul	edx, 112				; 00000070H
	and	ecx, 134217727				; 07ffffffH
	cmp	ecx, DWORD PTR _web[edx+68]
	jg	SHORT $LN1@valid_elem

; 2154 :   ep = elptr(id);

	imul	eax, 112				; 00000070H
	mov	eax, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2155 :   if ( ep == NULL ) return 0;

	test	eax, eax
	je	SHORT $LN1@valid_elem

; 2156 :   if ( ep->attr & ALLOCATED ) return 1;

	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN1@valid_elem
	mov	eax, 1

; 2158 : } // end valid_element()

	pop	ebp
	ret	0
$LN1@valid_elem:

; 2157 :   return 0;

	xor	eax, eax

; 2158 : } // end valid_element()

	pop	ebp
	ret	0
_valid_element ENDP
_TEXT	ENDS
PUBLIC	_binary_tree_add
; Function compile flags: /Ogtp
;	COMDAT _binary_tree_add
_TEXT	SEGMENT
_addends$ = 8						; size = 4
_term$ = 12						; size = 8
_binary_tree_add PROC					; COMDAT

; 2173 : { int i;

	push	ebp
	mov	ebp, esp
	push	esi

; 2174 :   for ( i = 0 ; addends[i] != 0.0 ; i++ )

	mov	esi, DWORD PTR _addends$[ebp]
	fld	QWORD PTR [esi]
	xor	edx, edx
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@binary_tre
	fld	QWORD PTR _term$[ebp]
	mov	ecx, esi
	jmp	SHORT $LN3@binary_tre
$LN14@binary_tre:
	fxch	ST(1)
$LN3@binary_tre:

; 2175 :   { term += addends[i];

	fadd	QWORD PTR [ecx]
	inc	edx

; 2176 :     addends[i] = 0.0;

	fxch	ST(1)
	fst	QWORD PTR [ecx]
	lea	ecx, DWORD PTR [esi+edx*8]
	fld	QWORD PTR [ecx]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@binary_tre

; 2177 :   }
; 2178 :   addends[i] = term;

	fstp	ST(0)
	fstp	QWORD PTR [esi+edx*8]
	pop	esi

; 2179 : } // end binary_tree_add()

	pop	ebp
	ret	0
$LN10@binary_tre:

; 2174 :   for ( i = 0 ; addends[i] != 0.0 ; i++ )

	fstp	ST(0)

; 2177 :   }
; 2178 :   addends[i] = term;

	fld	QWORD PTR _term$[ebp]
	fstp	QWORD PTR [esi+edx*8]
	pop	esi

; 2179 : } // end binary_tree_add()

	pop	ebp
	ret	0
_binary_tree_add ENDP
_TEXT	ENDS
PUBLIC	_new_element
EXTRN	_apply_method_num:PROC
EXTRN	_set_v_conmap:PROC
EXTRN	_set_e_conmap:PROC
EXTRN	_set_f_conmap:PROC
EXTRN	_nullcon:QWORD
EXTRN	_datafile_flag:DWORD
EXTRN	_replace_load_flag:DWORD
EXTRN	_addload_flag:DWORD
EXTRN	_match_id_flag:DWORD
EXTRN	_aggregate_depth:DWORD
; Function compile flags: /Ogtp
;	COMDAT _new_element
_TEXT	SEGMENT
_instlist$89297 = -16					; size = 4
tv683 = -12						; size = 4
tv1105 = -8						; size = 4
_e_ptr$89294 = -8					; size = 4
_ord$ = -8						; size = 4
_newid$ = -4						; size = 4
_type$ = 8						; size = 4
tv816 = 12						; size = 4
_parent$ = 12						; size = 4
_desired_id$ = 16					; size = 4
_new_element PROC					; COMDAT

; 399  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 400  :   element_id newid;
; 401  :   struct element *newptr,*last;
; 402  :   ORDTYPE ord;
; 403  :   
; 404  : #ifdef HASH_ID
; 405  :   newptr = elhash_new_element(type,desired_id);
; 406  :   newid = newptr->self_id;
; 407  : #else
; 408  :   newid = web.skel[type].free;

	mov	esi, DWORD PTR _type$[ebp]
	push	edi
	mov	edi, esi
	imul	edi, 112				; 00000070H
	mov	ebx, DWORD PTR _web[edi+28]
	mov	DWORD PTR _newid$[ebp], ebx

; 409  :   
; 410  :   if ( !valid_id(newid) ) /* free list empty */

	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN83@new_elemen

; 411  :   { if ( aggregate_depth == 0 )

	cmp	DWORD PTR _aggregate_depth, 0
	jne	SHORT $LN82@new_elemen

; 412  :     { free_discards(DISCARDS_SOME);

	push	2
	call	_free_discards

; 413  :       newid = web.skel[type].free;

	mov	eax, DWORD PTR _web[edi+28]
	add	esp, 4
	mov	DWORD PTR _newid$[ebp], eax
	mov	ebx, eax
$LN82@new_elemen:

; 414  :     }
; 415  :   }
; 416  : 
; 417  :   if ( !valid_id(newid) ) /* free list empty */

	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN83@new_elemen

; 418  :   { extend(type,EXTEND_BATCH);

	push	1
	push	esi
	call	_extend

; 419  :     newid = web.skel[type].free;

	mov	ecx, DWORD PTR _web[edi+28]
	add	esp, 8
	mov	DWORD PTR _newid$[ebp], ecx
	mov	ebx, ecx
$LN83@new_elemen:

; 420  :   }
; 421  :   newptr = elptr(newid);

	mov	edx, ebx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [eax+ecx*4]

; 422  : 
; 423  :   /* remove from free chain */
; 424  :   web.skel[type].free = newptr->forechain;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR tv683[ebp], ecx
	mov	DWORD PTR _web[edi+28], eax

; 425  :   if ( valid_id(web.skel[type].free) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN43@new_elemen

; 426  :     elptr(web.skel[type].free)->backchain = NULLID;

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+4], 0

; 427  :   else

	jmp	SHORT $LN42@new_elemen
$LN43@new_elemen:

; 428  :     web.skel[type].freelast = NULLID;

	mov	DWORD PTR _web[edi+32], 0
$LN42@new_elemen:

; 429  : #endif
; 430  : 
; 431  :   /* clean out old info */
; 432  :   ord = ordinal(newid);

	mov	DWORD PTR _ord$[ebp], ecx
	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN50@new_elemen
	mov	DWORD PTR _ord$[ebp], -1
$LN50@new_elemen:

; 433  :   memset((char *)newptr,0,web.sizes[type]);

	mov	ecx, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR _web[ecx*4+560]
	push	edx
	push	0
	push	esi
	call	_memset

; 434  :   if ( ord > web.skel[type].max_ord ) 

	mov	edx, DWORD PTR _ord$[ebp]
	add	esp, 12					; 0000000cH
	cmp	edx, DWORD PTR _web[edi+68]
	jle	SHORT $LN41@new_elemen

; 435  :   { web.skel[type].max_ord = ord;

	mov	DWORD PTR _web[edi+68], edx
$LN41@new_elemen:

; 436  :   }
; 437  :   newptr->original = NULLID;

	mov	DWORD PTR [esi+20], 0

; 438  : 
; 439  : #ifndef HASH_ID
; 440  :   if ( match_id_flag && (!addload_flag || replace_load_flag) && datafile_flag )

	cmp	DWORD PTR _match_id_flag, 0
	je	$LN40@new_elemen
	cmp	DWORD PTR _addload_flag, 0
	je	SHORT $LN39@new_elemen
	cmp	DWORD PTR _replace_load_flag, 0
	je	$LN40@new_elemen
$LN39@new_elemen:
	cmp	DWORD PTR _datafile_flag, 0
	je	$LN40@new_elemen

; 441  :   { /* link in numerical order */
; 442  :     int i;
; 443  :     struct element *prev,*next;
; 444  :     for ( i = ord-1 ; i >= 0 ; i-- )

	dec	edx
	js	SHORT $LN76@new_elemen
	mov	eax, DWORD PTR _web[edi+12]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv1105[ebp], ecx
$LL38@new_elemen:

; 445  :     { prev = web.skel[type].ibase[i];

	mov	eax, DWORD PTR tv1105[ebp]
	mov	ecx, DWORD PTR [eax]

; 446  :       if ( prev && (prev->attr & ALLOCATED) )

	test	ecx, ecx
	je	SHORT $LN37@new_elemen
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	jne	SHORT $LN73@new_elemen
	mov	ebx, DWORD PTR _newid$[ebp]
$LN37@new_elemen:

; 441  :   { /* link in numerical order */
; 442  :     int i;
; 443  :     struct element *prev,*next;
; 444  :     for ( i = ord-1 ; i >= 0 ; i-- )

	sub	DWORD PTR tv1105[ebp], 4
	dec	edx
	jns	SHORT $LL38@new_elemen

; 446  :       if ( prev && (prev->attr & ALLOCATED) )

	jmp	SHORT $LN76@new_elemen
$LN73@new_elemen:

; 447  :       { if ( valid_id(prev->forechain) )

	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN80@new_elemen

; 448  :         { next = elptr(prev->forechain);

	mov	ebx, eax
	shr	ebx, 29					; 0000001dH
	imul	ebx, 112				; 00000070H

; 449  :           next->backchain = newid;

	mov	ebx, DWORD PTR _web[ebx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _newid$[ebp]
	mov	DWORD PTR [eax+4], ebx
$LN80@new_elemen:

; 450  :         }
; 451  :         newptr->forechain = prev->forechain;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax

; 452  :         prev->forechain = newid;

	mov	eax, DWORD PTR _newid$[ebp]
	mov	DWORD PTR [ecx], eax

; 453  :         newptr->backchain = prev->self_id;

	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi+4], ecx

; 454  :         break;
; 455  :       }
; 456  :     }
; 457  :     if ( i < 0 )  /* no predecessor */

	mov	ebx, eax
	test	edx, edx
	jns	SHORT $LN33@new_elemen
$LN76@new_elemen:

; 458  :     { newptr->forechain = web.skel[type].used;

	mov	edx, DWORD PTR _web[edi+48]
	mov	DWORD PTR [esi], edx

; 459  :       if ( valid_id(web.skel[type].used) )

	mov	eax, DWORD PTR _web[edi+48]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN87@new_elemen

; 460  :       { next = elptr(web.skel[type].used);

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H

; 461  :         next->backchain = newid;

	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+4], ebx
$LN87@new_elemen:

; 462  :       }
; 463  :       web.skel[type].used = newid;

	mov	DWORD PTR _web[edi+48], ebx
$LN33@new_elemen:

; 464  :     }
; 465  :     if ( !valid_id(newptr->forechain) ) web.skel[type].last = newid;

	test	DWORD PTR [esi], 268435456		; 10000000H
	jne	SHORT $LN88@new_elemen

; 466  :   }
; 467  :   else

	jmp	SHORT $LN28@new_elemen
$LN40@new_elemen:

; 468  :   #endif
; 469  :   { /* add to end of in-use chain */
; 470  :     newptr->forechain = NULLID;

	mov	DWORD PTR [esi], 0

; 471  :     newptr->backchain = web.skel[type].last;

	mov	ecx, DWORD PTR _web[edi+52]
	mov	DWORD PTR [esi+4], ecx

; 472  :     if ( valid_id(web.skel[type].last) )

	mov	eax, DWORD PTR _web[edi+52]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN29@new_elemen

; 473  :     {
; 474  :        last = elptr(web.skel[type].last);     /* find end of in-use chain */

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]

; 475  :        last->forechain = newid;

	mov	DWORD PTR [edx], ebx

; 476  :     }
; 477  :     else

	jmp	SHORT $LN28@new_elemen
$LN29@new_elemen:

; 478  :     {        
; 479  :        web.skel[type].used = newid;

	mov	DWORD PTR _web[edi+48], ebx
$LN28@new_elemen:

; 480  :     }
; 481  :     web.skel[type].last = newid;

	mov	DWORD PTR _web[edi+52], ebx
$LN88@new_elemen:

; 482  :   }
; 483  : 
; 484  :   newptr->attr = ALLOCATED | NEWELEMENT;
; 485  : 
; 486  :   newptr->self_id = newid;
; 487  :   #ifdef MPI_EVOLVER
; 488  :   newptr->local_id = newid;
; 489  :   #endif
; 490  :   web.skel[type].count++;  
; 491  :   
; 492  :   #ifdef MPI_EVOLVER
; 493  :   /* kludge to guarantee max_ord gives enough spaces */
; 494  :   if ( web.skel[type].count > web.skel[type].max_ord+1 )
; 495  :     web.skel[type].max_ord = web.skel[type].count-1;
; 496  :   #endif
; 497  : 
; 498  :   /* inherited attributes and named methods from parent */
; 499  :   if ( valid_id(parent) )

	mov	eax, DWORD PTR _parent$[ebp]
	mov	DWORD PTR [esi+8], 5
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], ebx
	inc	DWORD PTR _web[edi+64]
	test	eax, 268435456				; 10000000H
	je	$LN78@new_elemen

; 500  :   { struct element *e_ptr = elptr(parent);

	mov	edi, eax
	shr	edi, 29					; 0000001dH
	mov	ecx, edi
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ebx, DWORD PTR [eax+edx]

; 501  :     int *instlist = (int*)((char*)e_ptr + get_meth_offset(id_type(parent)));
; 502  :     int i;
; 503  : 
; 504  :     newptr->attr |= e_ptr->attr & (NODISPLAY|FIXED|BOUNDARY|NEGBOUNDARY|
; 505  :         BDRY_ENERGY|CONSTRAINT|BDRY_CONTENT|NEGCONSTRAINT|BARE_NAKED);

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR tv816[ebp], eax
	mov	eax, DWORD PTR _web[edi*4+5664]
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web[ecx+104]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+64]
	add	eax, ebx
	xor	ecx, ecx
	or	DWORD PTR [esi+12], ecx
	and	edx, 88002				; 000157c2H
	or	DWORD PTR [esi+8], edx
	mov	DWORD PTR _instlist$89297[ebp], eax

; 506  : 
; 507  :     if ( e_ptr->attr & CONSTRAINT )

	mov	eax, DWORD PTR [ebx+8]
	and	eax, 1024				; 00000400H
	or	eax, ecx

; 508  :     { conmap_t *parent_conmap=NULL;
; 509  :       switch ( id_type(parent) )

	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR _e_ptr$89294[ebp], ebx
	je	$LN85@new_elemen
	xor	eax, eax
	mov	edx, edi
	sub	edx, eax
	je	SHORT $LN23@new_elemen
	dec	edx
	je	SHORT $LN22@new_elemen
	dec	edx
	jne	SHORT $LN52@new_elemen

; 512  :         case FACET : parent_conmap = get_f_constraint_map(parent); break;

	mov	edx, DWORD PTR _web+328
	cmp	DWORD PTR [edx+ecx+88], eax
	je	SHORT $LN51@new_elemen
	mov	eax, DWORD PTR _web+236
	mov	esi, DWORD PTR tv816[ebp]
	mov	eax, DWORD PTR [esi+eax]
	add	eax, DWORD PTR [edx+ecx+64]
	jmp	SHORT $LN52@new_elemen
$LN22@new_elemen:

; 511  :         case EDGE  : parent_conmap = get_e_constraint_map(parent); break;

	mov	edx, DWORD PTR _web+216
	cmp	DWORD PTR [edx+ecx+1048], eax
	je	SHORT $LN51@new_elemen
	mov	eax, DWORD PTR _web+124
	mov	esi, DWORD PTR tv816[ebp]
	mov	eax, DWORD PTR [esi+eax]
	add	eax, DWORD PTR [edx+ecx+1024]
	jmp	SHORT $LN52@new_elemen
$LN23@new_elemen:

; 510  :       { case VERTEX: parent_conmap = get_v_constraint_map(parent); break;

	mov	edx, DWORD PTR _web+104
	cmp	DWORD PTR [edx+ecx+1288], eax
	je	SHORT $LN51@new_elemen
	mov	eax, DWORD PTR _web+12
	mov	esi, DWORD PTR tv816[ebp]
	mov	eax, DWORD PTR [esi+eax]
	add	eax, DWORD PTR [edx+ecx+1264]
	jmp	SHORT $LN52@new_elemen
$LN51@new_elemen:
	mov	eax, OFFSET _nullcon
$LN52@new_elemen:

; 513  :       }
; 514  :       switch ( type )

	mov	edx, DWORD PTR _type$[ebp]
	sub	edx, 0
	je	SHORT $LN18@new_elemen
	dec	edx
	je	SHORT $LN17@new_elemen
	dec	edx
	jne	SHORT $LN85@new_elemen

; 517  :         case FACET : set_f_conmap(newid,parent_conmap); break; 

	mov	ecx, DWORD PTR _newid$[ebp]
	push	eax
	push	ecx
	call	_set_f_conmap
	jmp	SHORT $LN93@new_elemen
$LN17@new_elemen:

; 516  :         case EDGE  : set_e_conmap(newid,parent_conmap); break; 

	mov	edx, DWORD PTR _newid$[ebp]
	push	eax
	push	edx
	call	_set_e_conmap
	jmp	SHORT $LN93@new_elemen
$LN18@new_elemen:

; 515  :       { case VERTEX: set_v_conmap(newid,parent_conmap); break; 

	push	eax
	mov	eax, DWORD PTR _newid$[ebp]
	push	eax
	call	_set_v_conmap
$LN93@new_elemen:
	mov	ecx, DWORD PTR _dymem
	add	esp, 8
$LN85@new_elemen:

; 518  :       }
; 519  :     }
; 520  :     if ( e_ptr->attr & BOUNDARY )

	mov	eax, DWORD PTR [ebx+8]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	$LN63@new_elemen

; 521  :     { int bnum=0;
; 522  :       switch ( id_type(parent) )

	mov	edx, DWORD PTR _V_BOUNDARY_ATTR
	mov	esi, DWORD PTR _E_BOUNDARY_ATTR
	mov	ebx, DWORD PTR _F_BOUNDARY_ATTR
	xor	eax, eax
	sub	edi, eax
	je	SHORT $LN12@new_elemen
	dec	edi
	je	SHORT $LN11@new_elemen
	dec	edi
	jne	SHORT $LN58@new_elemen

; 525  :         case FACET : bnum = get_facet_boundary_num(parent); break;

	test	ebx, ebx
	je	SHORT $LN57@new_elemen
	mov	edi, DWORD PTR tv816[ebp]
	imul	ebx, 240				; 000000f0H
	add	ebx, DWORD PTR _web+328
	mov	eax, DWORD PTR [ebx+ecx+64]
	mov	ebx, DWORD PTR _web+236
	mov	edi, DWORD PTR [edi+ebx]
	mov	eax, DWORD PTR [eax+edi]
	mov	ebx, DWORD PTR _F_BOUNDARY_ATTR
	jmp	SHORT $LN58@new_elemen
$LN11@new_elemen:

; 524  :         case EDGE  : bnum = get_edge_boundary_num(parent); break;

	test	esi, esi
	je	SHORT $LN57@new_elemen
	mov	ebx, DWORD PTR _web+124
	mov	eax, esi
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	jmp	SHORT $LN92@new_elemen
$LN12@new_elemen:

; 523  :       { case VERTEX: bnum = get_vertex_boundary_num(parent); break;

	test	edx, edx
	je	SHORT $LN57@new_elemen
	mov	ebx, DWORD PTR _web+12
	mov	eax, edx
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
$LN92@new_elemen:
	mov	edi, DWORD PTR tv816[ebp]
	mov	edi, DWORD PTR [edi+ebx]
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR [eax+edi]
	mov	ebx, DWORD PTR _F_BOUNDARY_ATTR
	jmp	SHORT $LN58@new_elemen
$LN57@new_elemen:
	xor	eax, eax
$LN58@new_elemen:

; 526  :       }
; 527  :       switch ( type )

	mov	edi, DWORD PTR _type$[ebp]
	sub	edi, 0
	je	SHORT $LN7@new_elemen
	dec	edi
	je	SHORT $LN6@new_elemen
	dec	edi
	jne	SHORT $LN84@new_elemen

; 530  :         case FACET : set_facet_boundary_num(newid,bnum); break;

	test	ebx, ebx
	je	SHORT $LN84@new_elemen
	mov	edx, DWORD PTR _web+236
	imul	ebx, 240				; 000000f0H
	add	ebx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ebx+ecx+64]
	jmp	SHORT $LN94@new_elemen
$LN6@new_elemen:

; 529  :         case EDGE  : set_edge_boundary_num(newid,bnum); break;

	test	esi, esi
	je	SHORT $LN84@new_elemen
	mov	edx, DWORD PTR _web+124
	imul	esi, 240				; 000000f0H
	add	esi, DWORD PTR _web+216
	mov	ecx, DWORD PTR [esi+ecx+64]
	jmp	SHORT $LN94@new_elemen
$LN7@new_elemen:

; 528  :       { case VERTEX: set_boundary_num(newid,bnum); break;

	test	edx, edx
	je	SHORT $LN84@new_elemen
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [edx+ecx+64]
	mov	edx, DWORD PTR _web+12
$LN94@new_elemen:
	mov	esi, DWORD PTR tv683[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [ecx+edx], eax
$LN84@new_elemen:
	mov	ebx, DWORD PTR _e_ptr$89294[ebp]
$LN63@new_elemen:

; 531  :       }
; 532  :     }
; 533  : 
; 534  :     for ( i = 0 ; i < (int)e_ptr->method_count ; i++ )

	xor	eax, eax
	xor	esi, esi
	cmp	ax, WORD PTR [ebx+24]
	jae	SHORT $LN77@new_elemen
$LL86@new_elemen:

; 535  :     { if ( METH_INSTANCE(abs(instlist[i]))->type <= type )

	mov	ecx, DWORD PTR _instlist$89297[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	edi, DWORD PTR _type$[ebp]
	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	cmp	DWORD PTR [eax+edx+136], edi
	jg	SHORT $LN3@new_elemen

; 536  :          apply_method_num(newid,instlist[i]);

	mov	eax, DWORD PTR _newid$[ebp]
	push	ecx
	push	eax
	call	_apply_method_num
	add	esp, 8
$LN3@new_elemen:

; 531  :       }
; 532  :     }
; 533  : 
; 534  :     for ( i = 0 ; i < (int)e_ptr->method_count ; i++ )

	movzx	ecx, WORD PTR [ebx+24]
	inc	esi
	cmp	esi, ecx
	jl	SHORT $LL86@new_elemen
$LN77@new_elemen:

; 537  :     }
; 538  :   }
; 539  : 
; 540  :   return newid;

	mov	eax, DWORD PTR _newid$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 541  : } /* end new_element() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN78@new_elemen:
	pop	edi
	pop	esi

; 537  :     }
; 538  :   }
; 539  : 
; 540  :   return newid;

	mov	eax, ebx
	pop	ebx

; 541  : } /* end new_element() */

	mov	esp, ebp
	pop	ebp
	ret	0
_new_element ENDP
_TEXT	ENDS
PUBLIC	??_C@_0ED@CBLBDAFA@Internal?5error?3?5Trying?5to?5free?5u@ ; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_0DK@FODFGGNE@Internal?5error?3?5Trying?5to?5free?5i@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	_free_element
EXTRN	_set_facet_body:PROC
EXTRN	_remove_vertex_edge:PROC
EXTRN	_elnames:BYTE
;	COMDAT ??_C@_0ED@CBLBDAFA@Internal?5error?3?5Trying?5to?5free?5u@
CONST	SEGMENT
??_C@_0ED@CBLBDAFA@Internal?5error?3?5Trying?5to?5free?5u@ DB 'Internal e'
	DB	'rror: Trying to free unallocated element type %d id %s ', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_0DK@FODFGGNE@Internal?5error?3?5Trying?5to?5free?5i@
CONST	SEGMENT
??_C@_0DK@FODFGGNE@Internal?5error?3?5Trying?5to?5free?5i@ DB 'Internal e'
	DB	'rror: Trying to free invalid element %s id %s ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _free_element
_TEXT	SEGMENT
tv325 = -4						; size = 4
tv320 = 8						; size = 4
_id$ = 8						; size = 4
_free_element PROC					; COMDAT

; 551  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 552  :   struct element *ptr;
; 553  :   int type = id_type(id);

	mov	esi, DWORD PTR _id$[ebp]
	push	edi
	mov	edi, esi
	shr	edi, 29					; 0000001dH

; 554  : 
; 555  :   if ( !valid_element(id) )

	push	esi
	mov	DWORD PTR tv320[ebp], edi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN12@free_eleme@2

; 556  :   {
; 557  :     sprintf(errmsg,
; 558  :       "Internal error: Trying to free invalid element %s id %s \n",
; 559  :             typenames[type],ELNAME(id));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN15@free_eleme@2
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN16@free_eleme@2
$LN15@free_eleme@2:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN16@free_eleme@2:
	push	eax
	mov	eax, DWORD PTR _typenames[edi*4]
	push	eax
	push	OFFSET ??_C@_0DK@FODFGGNE@Internal?5error?3?5Trying?5to?5free?5i@
	push	OFFSET _errmsg
	call	_sprintf

; 560  :     kb_error(1311,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1311					; 0000051fH
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi

; 659  : 
; 660  : } // end free_element()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@free_eleme@2:
	push	ebx

; 561  :     return;
; 562  :   }
; 563  :      
; 564  :   if ( type == EDGE ) /* remove from vertex lists */

	cmp	edi, 1
	jne	$LN5@free_eleme@2

; 565  :   { vertex_id tailv = get_edge_tailv(id);
; 566  :     vertex_id headv = get_edge_headv(id);

	push	esi
	call	_get_edge_headv
	add	esp, 4

; 567  :     vertex_id midv;
; 568  :     int i; 
; 569  :     remove_vertex_edge(tailv,id);

	push	esi
	push	esi
	mov	ebx, eax
	call	_get_edge_tailv
	add	esp, 4
	push	eax
	call	_remove_vertex_edge

; 570  :     remove_vertex_edge(headv,inverse_id(id));

	mov	ecx, esi
	xor	ecx, 134217728				; 08000000H
	push	ecx
	push	ebx
	call	_remove_vertex_edge
	add	esp, 16					; 00000010H

; 571  :     if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	SHORT $LN21@free_eleme@2

; 572  :     { midv = get_edge_midv(id);

	mov	eax, DWORD PTR _web+124
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+304]
	mov	eax, DWORD PTR [ecx+edx+8]

; 573  :       if ( valid_id(midv) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN2@free_eleme@2

; 574  :         free_element(midv);

	push	eax
	call	_free_element
	add	esp, 4
$LN21@free_eleme@2:

; 575  :      }
; 576  :     if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	jne	SHORT $LN2@free_eleme@2

; 577  :     { vertex_id *v = get_edge_vertices(id);

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR _web+216
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	add	ebx, DWORD PTR [edx+eax+304]

; 578  :       for ( i = 1 ; i < web.lagrange_order ; i++ )

	mov	edi, 1
	cmp	DWORD PTR _web+632, edi
	jle	SHORT $LN23@free_eleme@2
	npad	4
$LL7@free_eleme@2:

; 579  :       { if ( valid_id(v[i]) )

	mov	eax, DWORD PTR [ebx+edi*4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN6@free_eleme@2

; 580  :           free_element(v[i]);

	push	eax
	call	_free_element
	add	esp, 4
$LN6@free_eleme@2:

; 578  :       for ( i = 1 ; i < web.lagrange_order ; i++ )

	inc	edi
	cmp	edi, DWORD PTR _web+632
	jl	SHORT $LL7@free_eleme@2
$LN23@free_eleme@2:

; 598  :     q->flags |= Q_INFO;

	mov	edi, DWORD PTR tv320[ebp]
$LN2@free_eleme@2:

; 599  :   }
; 600  : 
; 601  :   ptr = elptr(id);

	mov	ecx, edi
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]

; 602  :   if ( !(ptr->attr & ALLOCATED) )

	mov	edi, DWORD PTR [edx+8]
	mov	DWORD PTR tv325[ebp], eax
	mov	eax, edi
	xor	ebx, ebx
	and	eax, 1
	or	eax, ebx
	pop	ebx
	jne	$LN1@free_eleme@2

; 603  :   { sprintf(errmsg,
; 604  :       "Internal error: Trying to free unallocated element type %d id %s \n",
; 605  :             type,ELNAME(id));

	test	esi, 268435456				; 10000000H
	je	$LN17@free_eleme@2
	mov	eax, DWORD PTR tv325[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN18@free_eleme@2
$LN5@free_eleme@2:

; 581  :       }
; 582  :     }
; 583  :   }
; 584  :     
; 585  :   if ( type == FACET ) 

	cmp	edi, 2
	jne	SHORT $LN3@free_eleme@2

; 586  :   { 
; 587  :     /* remove from body facet lists */
; 588  :     set_facet_body(id,NULLID);

	push	0
	push	esi
	call	_set_facet_body

; 589  :     set_facet_body(inverse_id(id),NULLID);

	mov	ecx, esi
	xor	ecx, 134217728				; 08000000H
	push	0
	push	ecx
	call	_set_facet_body
	add	esp, 16					; 00000010H

; 590  :   }
; 591  : 
; 592  :   if ( (type == BODY) && everything_quantities_flag )

	jmp	SHORT $LN2@free_eleme@2
$LN3@free_eleme@2:
	cmp	edi, 3
	jne	SHORT $LN2@free_eleme@2
	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN2@free_eleme@2

; 593  :   { // should deallocate body quantity, but don't have that implemented,
; 594  :     // so just making sure volume not fixed.
; 595  :     struct gen_quant *q = GEN_QUANT(get_body_volquant(id));

	mov	eax, DWORD PTR _web+348

; 596  :     q->modulus = 1;

	fld1
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx+404]
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list

; 597  :     q->flags &= ~(Q_ENERGY|Q_FIXED|Q_CONSERVED);

	mov	edx, DWORD PTR [eax+136]
	fstp	QWORD PTR [eax+176]
	and	edx, -12				; fffffff4H

; 598  :     q->flags |= Q_INFO;

	or	edx, 4
	mov	DWORD PTR [eax+136], edx
	jmp	$LN2@free_eleme@2
$LN17@free_eleme@2:

; 603  :   { sprintf(errmsg,
; 604  :       "Internal error: Trying to free unallocated element type %d id %s \n",
; 605  :             type,ELNAME(id));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN18@free_eleme@2:
	mov	ecx, DWORD PTR tv320[ebp]
	push	eax
	push	ecx
	push	OFFSET ??_C@_0ED@CBLBDAFA@Internal?5error?3?5Trying?5to?5free?5u@
	push	OFFSET _errmsg
	call	_sprintf

; 606  :     kb_error(1313,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1313					; 00000521H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi

; 659  : 
; 660  : } // end free_element()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@free_eleme@2:

; 607  :     return;
; 608  :   }
; 609  :   ptr->attr &= ~ALLOCATED;

	mov	eax, DWORD PTR [edx+12]
	and	edi, -2					; fffffffeH
	mov	DWORD PTR [edx+8], edi
	mov	DWORD PTR [edx+12], eax

; 610  : 
; 611  :   #ifdef MPI_EVOLVER
; 612  :   if ( id_task(id) != this_task )
; 613  :   { struct element *e;
; 614  :     mpi_remove_remote(id);
; 615  :     if ( valid_id(ptr->forechain) )
; 616  :     { e = elptr(ptr->forechain);
; 617  :       e->backchain = ptr->local_id;
; 618  :     }
; 619  :     else
; 620  :       web.skel[type].last = ptr->local_id;
; 621  :     if ( valid_id(ptr->backchain) )
; 622  :     { e = elptr(ptr->backchain);
; 623  :       e->forechain = ptr->local_id;
; 624  :     }
; 625  :     else
; 626  :       web.skel[type].used = ptr->local_id;
; 627  :   }
; 628  :   else
; 629  :     mpi_remove_export(id); /* remove from export list */
; 630  :   #endif
; 631  : 
; 632  : 
; 633  : #ifdef OLDDISCARD
; 634  :   /* remove from in-use list */
; 635  :   if ( valid_id(ptr->forechain) )
; 636  :      elptr(ptr->forechain)->backchain = ptr->backchain;
; 637  :   else
; 638  :      web.skel[type].last = ptr->backchain;
; 639  : 
; 640  : /**** DON'T DO THIS! Don't mess with forechains until free_discards()! */
; 641  :   if ( valid_id(ptr->backchain) )
; 642  :     {
; 643  :       /*     elptr(ptr->backchain)->forechain = ptr->forechain;  */
; 644  :     }
; 645  :   else
; 646  :      web.skel[type].used = ptr->forechain;
; 647  : /*****/
; 648  : 
; 649  :   /* add to discard list */
; 650  :   /* save forechain for generators */
; 651  :   ptr->backchain = web.skel[type].discard;
; 652  :   web.skel[type].discard = id & (TYPEMASK | VALIDMASK | OFFSETMASK);
; 653  :                                  /* clear old bits, keep only needed */
; 654  : #else
; 655  :   web.skel[type].discard_count++;

	inc	DWORD PTR _web[ecx+60]

; 656  : #endif
; 657  : 
; 658  :   web.skel[type].count--; 

	dec	DWORD PTR _web[ecx+64]
	pop	edi
	pop	esi

; 659  : 
; 660  : } // end free_element()

	mov	esp, ebp
	pop	ebp
	ret	0
_free_element ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@DOIJNKHB@Internal?5error?3?5Cannot?5find?5elem@ ; `string'
PUBLIC	_move_to_free_front
;	COMDAT ??_C@_0DD@DOIJNKHB@Internal?5error?3?5Cannot?5find?5elem@
CONST	SEGMENT
??_C@_0DD@DOIJNKHB@Internal?5error?3?5Cannot?5find?5elem@ DB 'Internal er'
	DB	'ror: Cannot find element in free list.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _move_to_free_front
_TEXT	SEGMENT
_ord$ = -4						; size = 4
_type$ = 8						; size = 4
_id$ = 12						; size = 4
_move_to_free_front PROC				; COMDAT

; 1200 : { int ord = id - 1;

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 
; 1202 : 
; 1203 : #ifdef HASH_ID
; 1204 :  if ( !match_id_flag || (addload_flag && !replace_load_flag) ) return; /* for old way */
; 1205 :  web.skel[type].free_spot = ord;
; 1206 : #else
; 1207 : 
; 1208 :   element_id eid;
; 1209 :   struct element *eptr,*fptr,*bptr;
; 1210 :  
; 1211 :   if ( !match_id_flag || (addload_flag && !replace_load_flag) ) return; /* for old way */

	cmp	DWORD PTR _match_id_flag, 0
	mov	ecx, DWORD PTR _id$[ebp]
	push	ebx
	lea	ebx, DWORD PTR [ecx-1]
	mov	DWORD PTR _ord$[ebp], ebx
	je	$LN17@move_to_fr
	cmp	DWORD PTR _addload_flag, 0
	je	SHORT $LN18@move_to_fr
	cmp	DWORD PTR _replace_load_flag, 0
	je	$LN17@move_to_fr
$LN18@move_to_fr:
	push	esi
	push	edi

; 1212 : 
; 1213 :   if ( sparse_ibase_flag )
; 1214 :   { /* extend ibase with empty slots far enough */
; 1215 :     if ( id > web.skel[type].ialloc )

	mov	edi, DWORD PTR _type$[ebp]
	mov	esi, edi
	imul	esi, 112				; 00000070H
	cmp	DWORD PTR _sparse_ibase_flag, 0
	je	$LN26@move_to_fr
	mov	eax, DWORD PTR _web[esi+16]
	cmp	ecx, eax
	jle	SHORT $LN15@move_to_fr

; 1216 :     { int imax = web.skel[type].ialloc > 1024 ? 2*web.skel[type].ialloc : 1024;

	lea	ebx, DWORD PTR [eax+eax]
	cmp	eax, 1024				; 00000400H
	jg	SHORT $LN22@move_to_fr
	mov	ebx, 1024				; 00000400H
$LN22@move_to_fr:

; 1217 :       while ( imax < id ) 

	cmp	ebx, ecx
	jge	SHORT $LN13@move_to_fr
$LL14@move_to_fr:

; 1218 :         imax *= 2;

	add	ebx, ebx
	cmp	ebx, ecx
	jl	SHORT $LL14@move_to_fr
$LN13@move_to_fr:

; 1219 :       web.skel[type].ibase = (INDIRECT_TYPE*)kb_realloc((char*)web.skel[type].ibase,
; 1220 :                                  imax*sizeof(INDIRECT_TYPE));

	mov	ecx, DWORD PTR _web[esi+12]
	push	1220					; 000004c4H
	push	OFFSET ??_C@_09EOIFBANE@STORAGE?4C?$AA@
	lea	eax, DWORD PTR [ebx*4]
	push	eax
	push	ecx
	call	_KB_realloc

; 1221 :       web.skel[type].ialloc = imax;

	mov	DWORD PTR _web[esi+16], ebx
	mov	ebx, DWORD PTR _ord$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _web[esi+12], eax
$LN15@move_to_fr:

; 1222 :     }
; 1223 :     if ( !valid_id(web.skel[type].free) )

	test	DWORD PTR _web[esi+28], 268435456	; 10000000H
	jne	SHORT $LN12@move_to_fr

; 1224 :       extend(type,EXTEND_BATCH); /* refill freelist */ 

	push	1
	push	edi
	call	_extend
	add	esp, 8
$LN12@move_to_fr:

; 1225 :     if ( web.skel[type].ibase[ord] == NULL ) 

	mov	eax, DWORD PTR _web[esi+12]
	cmp	DWORD PTR [eax+ebx*4], 0
	jne	$LN7@move_to_fr

; 1226 :     { /* move first of freelist to desired spot */
; 1227 :       element_id free_id = web.skel[type].free;

	mov	edx, DWORD PTR _web[esi+28]

; 1228 :       int free_ord;
; 1229 :       free_ord = ordinal(free_id);

	test	edx, 268435456				; 10000000H
	je	SHORT $LN23@move_to_fr
	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN24@move_to_fr
$LN23@move_to_fr:
	or	edx, -1
$LN24@move_to_fr:

; 1230 :       eptr = web.skel[type].ibase[ord] = web.skel[type].ibase[free_ord];

	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [eax+ebx*4], ecx
	mov	ecx, DWORD PTR _web[esi+12]
	mov	eax, DWORD PTR [ecx+ebx*4]

; 1231 :       web.skel[type].ibase[free_ord] = NULL;
; 1232 :       eptr->self_id = ((element_id)type << TYPESHIFT) | VALIDMASK | ord; 

	shl	edi, 29					; 0000001dH
	or	edi, ebx
	or	edi, 268435456				; 10000000H
	mov	DWORD PTR [ecx+edx*4], 0
	mov	DWORD PTR [eax+16], edi

; 1233 : #ifdef MPI_EVOLVER
; 1234 :       eptr->self_id |= (element_id)this_task << TASK_ID_SHIFT;  
; 1235 : #endif
; 1236 :       web.skel[type].free = eptr->self_id;

	mov	DWORD PTR _web[esi+28], edi

; 1237 :       if ( !valid_id(eptr->forechain) )

	test	DWORD PTR [eax], 268435456		; 10000000H
	jne	$LN31@move_to_fr

; 1238 :         web.skel[type].freelast = eptr->self_id;

	mov	edx, DWORD PTR [eax+16]
	pop	edi
	mov	DWORD PTR _web[esi+32], edx
	pop	esi
	pop	ebx

; 1282 : #endif
; 1283 : } // end move_to_free_front()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@move_to_fr:

; 1239 :          
; 1240 :       return; 
; 1241 :     } 
; 1242 :   }
; 1243 :   else
; 1244 :   { /* dense ibase, extend and allocate empty structures */
; 1245 :     while ( id > web.skel[type].maxcount ) 

	cmp	ecx, DWORD PTR _web[esi+20]
	jle	SHORT $LN7@move_to_fr
	npad	7
$LL8@move_to_fr:

; 1246 :      extend(type,EXTEND_BATCH);

	push	1
	push	edi
	call	_extend
	mov	eax, DWORD PTR _id$[ebp]
	add	esp, 8
	cmp	eax, DWORD PTR _web[esi+20]
	jg	SHORT $LL8@move_to_fr
$LN7@move_to_fr:

; 1247 :   }
; 1248 : 
; 1249 :   eid = ((element_id)type << TYPESHIFT) | VALIDMASK | abs(ord);

	mov	eax, ebx
	cdq
	mov	ebx, eax
	xor	ebx, edx
	sub	ebx, edx
	shl	edi, 29					; 0000001dH
	or	ebx, edi
	or	ebx, 268435456				; 10000000H

; 1250 :   #ifdef MPI_EVOLVER
; 1251 :   eid |= (element_id)this_task << TASK_ID_SHIFT;  
; 1252 :   #endif
; 1253 : 
; 1254 :   eptr = elptr(eid);

	mov	ecx, ebx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+edx*4]

; 1255 :   if ( valid_element(eid) )

	push	ebx
	call	_valid_element
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@move_to_fr

; 1256 :   { kb_error(2187,"Internal error: Cannot find element in free list.\n",
; 1257 :        DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DD@DOIJNKHB@Internal?5error?3?5Cannot?5find?5elem@
	push	2187					; 0000088bH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 1282 : #endif
; 1283 : } // end move_to_free_front()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@move_to_fr:

; 1258 :     return;
; 1259 :   }
; 1260 : 
; 1261 :   if ( eid == web.skel[type].free ) return; /* already in place */

	cmp	ebx, DWORD PTR _web[esi+28]
	je	$LN31@move_to_fr

; 1262 :   if ( eid == web.skel[type].freelast ) 

	cmp	ebx, DWORD PTR _web[esi+32]
	jne	SHORT $LN4@move_to_fr

; 1263 :     web.skel[type].freelast = eptr->backchain;

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR _web[esi+32], ecx
$LN4@move_to_fr:

; 1264 : 
; 1265 :   /* now cut out of free list */
; 1266 :   if ( valid_id(eptr->backchain) )

	mov	eax, DWORD PTR [edi+4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN29@move_to_fr

; 1267 :   { bptr = elptr(eptr->backchain);

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]

; 1268 :     bptr->forechain = eptr->forechain; /* cut */

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [edx], eax
$LN29@move_to_fr:

; 1269 :   }
; 1270 :   if ( valid_id(eptr->forechain) )

	mov	eax, DWORD PTR [edi]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN30@move_to_fr

; 1271 :   { fptr = elptr(eptr->forechain);

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H

; 1272 :     fptr->backchain = eptr->backchain;

	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR [edi+4]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+4], ecx
$LN30@move_to_fr:

; 1273 :   }
; 1274 : 
; 1275 :   /* paste at front of free list */
; 1276 :   if ( valid_id(web.skel[type].free) )

	mov	eax, DWORD PTR _web[esi+28]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@move_to_fr

; 1277 :   { fptr = elptr(web.skel[type].free);

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H

; 1278 :     fptr->backchain = eid;

	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+4], ebx
$LN1@move_to_fr:

; 1279 :   }
; 1280 :   eptr->forechain = web.skel[type].free; 

	mov	eax, DWORD PTR _web[esi+28]
	mov	DWORD PTR [edi], eax

; 1281 :   web.skel[type].free = eid;

	mov	DWORD PTR _web[esi+28], ebx
$LN31@move_to_fr:
	pop	edi
	pop	esi
$LN17@move_to_fr:
	pop	ebx

; 1282 : #endif
; 1283 : } // end move_to_free_front()

	mov	esp, ebp
	pop	ebp
	ret	0
_move_to_free_front ENDP
_TEXT	ENDS
PUBLIC	_interp_edge_attribute
EXTRN	_gauss_lagrange:BYTE
; Function compile flags: /Ogtp
;	COMDAT _interp_edge_attribute
_TEXT	SEGMENT
_sum$ = -12						; size = 8
_ctrl$ = -4						; size = 4
_eid$ = 8						; size = 4
_ext$ = 12						; size = 4
_inx$ = 16						; size = 4
_ptnum$ = 20						; size = 4
_interp_edge_attribute PROC				; COMDAT

; 1642 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1643 :   int ctrl = web.skel[EDGE].ctrlpts;
; 1644 :   REAL sum = 0.0;
; 1645 :   int i;
; 1646 :   vertex_id *v = get_edge_vertices(eid);

	mov	ecx, DWORD PTR _eid$[ebp]
	fldz
	mov	edx, DWORD PTR _web+124
	fst	QWORD PTR _sum$[ebp]
	mov	eax, DWORD PTR _web+120
	push	ebx
	push	esi
	push	edi

; 1647 :   struct gauss_lag *gl = &gauss_lagrange[EDGE][web.gauss1D_order];

	mov	edi, DWORD PTR _web+1592
	and	ecx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	add	ebx, DWORD PTR [ecx+edx+304]
	shl	edi, 5
	add	edi, DWORD PTR _gauss_lagrange+4

; 1648 : 
; 1649 :   if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	mov	DWORD PTR _ctrl$[ebp], eax
	jne	SHORT $LN5@interp_edg

; 1650 :   { sum += gl->gpoly[ptnum][0]*get_extra_attrib_value(v[1],ext,inx);

	mov	eax, DWORD PTR _inx$[ebp]
	fstp	ST(0)
	mov	ecx, DWORD PTR _ext$[ebp]
	mov	edx, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR _ptnum$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_get_extra_attrib_value
	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [eax+esi*4]
	fmul	QWORD PTR [ecx]

; 1651 :     sum += gl->gpoly[ptnum][1]*get_extra_attrib_value(v[2],ext,inx);

	mov	edx, DWORD PTR _inx$[ebp]
	mov	eax, DWORD PTR _ext$[ebp]
	mov	ecx, DWORD PTR [ebx+8]
	fadd	QWORD PTR __real@0000000000000000
	push	edx
	push	eax
	push	ecx
	fstp	QWORD PTR _sum$[ebp]
	call	_get_extra_attrib_value
	mov	edx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [edx+esi*4]
	fmul	QWORD PTR [eax+8]

; 1652 :     sum += gl->gpoly[ptnum][2]*get_extra_attrib_value(v[0],ext,inx);

	mov	ecx, DWORD PTR _inx$[ebp]
	mov	edx, DWORD PTR _ext$[ebp]
	mov	eax, DWORD PTR [ebx]
	fadd	QWORD PTR _sum$[ebp]
	push	ecx
	push	edx
	push	eax
	fstp	QWORD PTR _sum$[ebp]
	call	_get_extra_attrib_value
	mov	ecx, DWORD PTR [edi+20]
	mov	edx, DWORD PTR [ecx+esi*4]
	fmul	QWORD PTR [edx+16]
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi
	fadd	QWORD PTR _sum$[ebp]
	pop	ebx

; 1656 :   return sum;
; 1657 : } // end interp_edge_attribute()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@interp_edg:

; 1653 :   } else
; 1654 :   for ( i = 0 ; i < ctrl ; i++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN1@interp_edg
$LN17@interp_edg:

; 1655 :     sum += gl->gpoly[ptnum][i]*get_extra_attrib_value(v[i],ext,inx);

	mov	eax, DWORD PTR _inx$[ebp]
	fstp	ST(0)
	mov	ecx, DWORD PTR _ext$[ebp]
	mov	edx, DWORD PTR [ebx+esi*4]
	push	eax
	push	ecx
	push	edx
	call	_get_extra_attrib_value
	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR _ptnum$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	fmul	QWORD PTR [edx+esi*8]
	inc	esi
	add	esp, 12					; 0000000cH
	fadd	QWORD PTR _sum$[ebp]
	fst	QWORD PTR _sum$[ebp]
	cmp	esi, DWORD PTR _ctrl$[ebp]
	jl	SHORT $LN17@interp_edg
$LN1@interp_edg:
	pop	edi
	pop	esi
	pop	ebx

; 1656 :   return sum;
; 1657 : } // end interp_edge_attribute()

	mov	esp, ebp
	pop	ebp
	ret	0
_interp_edge_attribute ENDP
_TEXT	ENDS
PUBLIC	_ext$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_interp_facet_attribute
; Function compile flags: /Ogtp
;	COMDAT _interp_facet_attribute
_TEXT	SEGMENT
_gl$ = -52						; size = 4
_sum$ = -48						; size = 8
_ext$GSCopy$ = -40					; size = 4
tv647 = -36						; size = 4
_ctrl$ = -32						; size = 4
_vv$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_fid$ = 8						; size = 4
_ext$ = 12						; size = 4
_inx$ = 16						; size = 4
_ptnum$ = 20						; size = 4
_interp_facet_attribute PROC				; COMDAT

; 1674 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1675 :   int ctrl = web.skel[FACET].ctrlpts;

	mov	ecx, DWORD PTR _ext$[ebp]

; 1676 :   REAL sum = 0.0;

	fldz
	mov	edx, DWORD PTR _web+232
	fstp	QWORD PTR _sum$[ebp]
	mov	eax, DWORD PTR _fid$[ebp]
	mov	DWORD PTR _ext$GSCopy$[ebp], ecx

; 1677 :   int i;
; 1678 :   vertex_id *v;
; 1679 :   vertex_id vv[2*FACET_VERTS];
; 1680 :   struct gauss_lag *gl = &gauss_lagrange[FACET][web.gauss2D_order];

	mov	ecx, DWORD PTR _web+1596
	shl	ecx, 5
	add	ecx, DWORD PTR _gauss_lagrange+8
	push	ebx
	mov	DWORD PTR _gl$[ebp], ecx

; 1681 : 
; 1682 :   if ( web.modeltype == LINEAR )

	mov	ecx, DWORD PTR _web+628
	push	esi
	push	edi
	mov	DWORD PTR _ctrl$[ebp], edx
	cmp	ecx, 1
	jne	$LN10@interp_fac

; 1683 :   { facetedge_id fe = get_facet_fe(fid);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN14@interp_fac
	xor	edx, edx
	jmp	SHORT $LN13@interp_fac
$LN14@interp_fac:
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN13@interp_fac
	xor	edx, 134217728				; 08000000H
$LN13@interp_fac:

; 1684 :     for ( i = 0 ; i < FACET_VERTS ; i++ )
; 1685 :     { vv[i] = get_fe_tailv(fe);

	mov	ecx, DWORD PTR _web+460
	mov	esi, DWORD PTR _dymem
	mov	ebx, DWORD PTR _web+636
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+esi+304]
	mov	esi, DWORD PTR _web+124
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN20@interp_fac
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN19@interp_fac
$LN20@interp_fac:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN19@interp_fac:
	mov	DWORD PTR _vv$[ebp], eax

; 1686 :       fe = get_next_edge(fe);

	test	edx, 134217728				; 08000000H
	je	SHORT $LN24@interp_fac
	mov	edx, DWORD PTR [edi+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN8@interp_fac
$LN24@interp_fac:
	mov	edx, DWORD PTR [edi+32]
$LN8@interp_fac:

; 1684 :     for ( i = 0 ; i < FACET_VERTS ; i++ )
; 1685 :     { vv[i] = get_fe_tailv(fe);

	mov	edi, DWORD PTR _web+460
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+eax*4]
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN62@interp_fac
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN63@interp_fac
$LN62@interp_fac:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN63@interp_fac:
	mov	DWORD PTR _vv$[ebp+4], eax

; 1686 :       fe = get_next_edge(fe);

	test	edx, 134217728				; 08000000H
	je	SHORT $LN64@interp_fac
	mov	eax, DWORD PTR [edi+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN65@interp_fac
$LN64@interp_fac:
	mov	eax, DWORD PTR [edi+32]
$LN65@interp_fac:

; 1684 :     for ( i = 0 ; i < FACET_VERTS ; i++ )
; 1685 :     { vv[i] = get_fe_tailv(fe);

	mov	edi, DWORD PTR _web+460
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN67@interp_fac
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	lea	edx, DWORD PTR [eax+ebx*4]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _vv$[ebp+8], ecx

; 1687 :     }
; 1688 :     v = vv;

	lea	edi, DWORD PTR _vv$[ebp]
	jmp	$LN4@interp_fac

; 1684 :     for ( i = 0 ; i < FACET_VERTS ; i++ )
; 1685 :     { vv[i] = get_fe_tailv(fe);

$LN67@interp_fac:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _vv$[ebp+8], ecx

; 1687 :     }
; 1688 :     v = vv;

	lea	edi, DWORD PTR _vv$[ebp]
	jmp	$LN4@interp_fac
$LN10@interp_fac:

; 1689 :   } else if ( web.modeltype == QUADRATIC ) 

	cmp	ecx, 2
	jne	$LN5@interp_fac

; 1690 :   { facetedge_id fe = get_facet_fe(fid);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN28@interp_fac
	xor	edi, edi
	jmp	SHORT $LN27@interp_fac
$LN28@interp_fac:
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edi, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN27@interp_fac
	xor	edi, 134217728				; 08000000H
$LN27@interp_fac:

; 1691 :     vv[0] = get_fe_tailv(fe);

	mov	eax, DWORD PTR _web+460
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	lea	ebx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+20]
	mov	esi, edi
	and	esi, 134217728				; 08000000H
	xor	ecx, esi
	push	ecx
	mov	DWORD PTR tv647[ebp], eax
	call	_get_edge_tailv

; 1692 :     vv[1] = get_fe_midv(fe);

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _web+216
	mov	DWORD PTR _vv$[ebp], eax
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ecx+edx+304]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+ebx+8]

; 1693 :     vv[2] = get_fe_headv(fe);

	xor	eax, esi
	push	eax
	mov	DWORD PTR _vv$[ebp+4], edx
	call	_get_edge_headv
	add	esp, 8
	mov	DWORD PTR _vv$[ebp+8], eax

; 1694 :     fe = get_next_edge(fe);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN38@interp_fac
	mov	eax, DWORD PTR tv647[ebp]
	mov	esi, DWORD PTR [eax+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN37@interp_fac
$LN38@interp_fac:
	mov	ecx, DWORD PTR tv647[ebp]
	mov	esi, DWORD PTR [ecx+32]
$LN37@interp_fac:

; 1695 :     vv[4] = get_fe_midv(fe);

	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	lea	edi, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [edx+ebx+8]

; 1696 :     vv[5] = get_fe_headv(fe);

	mov	edx, esi
	and	edx, 134217728				; 08000000H
	xor	edx, eax
	push	edx
	mov	DWORD PTR _vv$[ebp+16], ecx
	call	_get_edge_headv
	add	esp, 4
	mov	DWORD PTR _vv$[ebp+20], eax

; 1697 :     fe = get_next_edge(fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN46@interp_fac
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN45@interp_fac
$LN46@interp_fac:
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+32]
$LN45@interp_fac:

; 1698 :     vv[3] = get_fe_midv(fe);

	mov	edx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+ebx+8]
	mov	DWORD PTR _vv$[ebp+12], ecx

; 1699 :     v = vv;

	lea	edi, DWORD PTR _vv$[ebp]

; 1700 :   } else /* LAGRANGE */

	jmp	SHORT $LN4@interp_fac
$LN5@interp_fac:

; 1701 :   v = get_facet_vertices(fid);

	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _web+328
	add	edi, DWORD PTR [eax+ecx+304]
$LN4@interp_fac:

; 1702 : 
; 1703 :   for ( i = 0 ; i < ctrl ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _ctrl$[ebp], esi
	jle	SHORT $LN71@interp_fac
	mov	ebx, DWORD PTR _inx$[ebp]
	jmp	SHORT $LN72@interp_fac
	npad	3
$LL74@interp_fac:
	fstp	ST(0)
$LN72@interp_fac:

; 1704 :     sum += gl->gpoly[ptnum][i]*get_extra_attrib_value(v[i],ext,inx);

	mov	edx, DWORD PTR _ext$GSCopy$[ebp]
	mov	eax, DWORD PTR [edi+esi*4]
	push	ebx
	push	edx
	push	eax
	call	_get_extra_attrib_value
	mov	ecx, DWORD PTR _gl$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _ptnum$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	fmul	QWORD PTR [ecx+esi*8]
	inc	esi
	add	esp, 12					; 0000000cH
	fadd	QWORD PTR _sum$[ebp]
	fst	QWORD PTR _sum$[ebp]
	cmp	esi, DWORD PTR _ctrl$[ebp]
	jl	SHORT $LL74@interp_fac
	pop	edi
	pop	esi
	pop	ebx

; 1705 :   return sum;
; 1706 : } // end interp_facet_attribute()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@interp_fac:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fld	QWORD PTR _sum$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_interp_facet_attribute ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@KPENJBHF@Duplicate?5element?5number?4?6?$AA@ ; `string'
PUBLIC	__real@3fe999999999999a
PUBLIC	_elhash_new_element
;	COMDAT ??_C@_0BL@KPENJBHF@Duplicate?5element?5number?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@KPENJBHF@Duplicate?5element?5number?4?6?$AA@ DB 'Duplicate elem'
	DB	'ent number.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT __real@3fe999999999999a
CONST	SEGMENT
__real@3fe999999999999a DQ 03fe999999999999ar	; 0.8
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _elhash_new_element
_TEXT	SEGMENT
tv203 = -8						; size = 4
tv201 = -4						; size = 4
_newptr$ = 8						; size = 4
_type$ = 8						; size = 4
tv213 = 12						; size = 4
_desired_id$ = 12					; size = 4
_elhash_new_element PROC				; COMDAT

; 1978 : { struct element *newptr,*oldptr;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi

; 1979 :   element_id newid;
; 1980 :   int spot;
; 1981 : 
; 1982 :   if ( web.skel[type].freehead == NULL )

	mov	esi, DWORD PTR _type$[ebp]
	mov	ebx, esi
	imul	ebx, 112				; 00000070H
	cmp	DWORD PTR _web[ebx+40], 0
	push	edi
	jne	SHORT $LN14@elhash_new

; 1983 :     /* allocate another batch */
; 1984 :     elhash_extend(type,EXTEND_BATCH);

	push	1
	push	esi
	call	_elhash_extend
	add	esp, 8
$LN14@elhash_new:

; 1985 :   newptr = web.skel[type].freehead;
; 1986 :   web.skel[type].freehead = *(struct element**)&(newptr->forechain);
; 1987 : 
; 1988 :   if ( web.skel[type].maxcount == 0 )

	cmp	DWORD PTR _web[ebx+20], 0
	mov	edi, DWORD PTR _web[ebx+40]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _newptr$[ebp], edi
	mov	DWORD PTR _web[ebx+40], eax
	jne	SHORT $LN9@elhash_new

; 1989 :     web.skel[type].maxcount = 1024;

	mov	DWORD PTR _web[ebx+20], 1024		; 00000400H
$LN9@elhash_new:

; 1990 :   if ( web.skel[type].alloc > 0.8*web.skel[type].maxcount )

	mov	ecx, DWORD PTR _web[ebx+20]
	fild	DWORD PTR _web[ebx+24]
	lea	eax, DWORD PTR _web[ebx+24]
	mov	DWORD PTR tv201[ebp], ecx
	fild	DWORD PTR tv201[ebp]
	mov	DWORD PTR tv203[ebp], eax
	fmul	QWORD PTR __real@3fe999999999999a
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN8@elhash_new

; 1991 :     web.skel[type].maxcount *= 2;

	add	ecx, ecx
	mov	DWORD PTR _web[ebx+20], ecx
$LN8@elhash_new:

; 1992 :     
; 1993 :   /* find next available element number, using persistant scan */
; 1994 :   if ( desired_id ) 

	mov	eax, DWORD PTR _desired_id$[ebp]

; 1995 :   { spot = (int)(desired_id & OFFSETMASK);
; 1996 :     newid = ((element_id)type << TYPESHIFT) | VALIDMASK | spot;

	shl	esi, 29					; 0000001dH
	test	eax, eax
	je	SHORT $LN7@elhash_new
	and	eax, 134217727				; 07ffffffH
	or	esi, eax
	or	esi, 268435456				; 10000000H

; 1997 :     oldptr = elhash_lookup(newid); 

	push	esi
	call	_elhash_lookup
	add	esp, 4

; 1998 :     if ( oldptr )

	test	eax, eax
	je	SHORT $LN17@elhash_new

; 1999 :       kb_error(5433,"Duplicate element number.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BL@KPENJBHF@Duplicate?5element?5number?4?6?$AA@
	push	5433					; 00001539H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN17@elhash_new:

; 2000 :     elhash_insert(newid,newptr);

	push	edi
	push	esi
	call	_elhash_insert

; 2013 :     web.skel[type].free_spot = spot;
; 2014 :   }
; 2015 :   newptr->self_id = newid;
; 2016 :   web.skel[type].alloc++;

	mov	eax, DWORD PTR tv203[ebp]
	add	esp, 8
	mov	DWORD PTR [edi+16], esi
	inc	DWORD PTR [eax]

; 2017 :  
; 2018 :   return newptr;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2019 : } // end elhash_new_element()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@elhash_new:

; 2001 :   }
; 2002 :   else 
; 2003 :   {  spot = web.skel[type].free_spot;

	mov	edi, DWORD PTR _web[ebx+44]
	mov	DWORD PTR tv213[ebp], esi
	jmp	SHORT $LN4@elhash_new
	npad	7
$LL15@elhash_new:

; 1990 :   if ( web.skel[type].alloc > 0.8*web.skel[type].maxcount )

	mov	esi, DWORD PTR tv213[ebp]
$LN4@elhash_new:

; 2004 :     do 
; 2005 :     {
; 2006 :       newid = ((element_id)type << TYPESHIFT) | VALIDMASK | spot;

	or	esi, edi
	or	esi, 268435456				; 10000000H

; 2007 :       oldptr = elhash_lookup(newid); 

	push	esi
	call	_elhash_lookup

; 2008 :       spot++;

	inc	edi
	add	esp, 4

; 2009 :       if ( spot >= web.skel[type].maxcount )

	cmp	edi, DWORD PTR _web[ebx+20]
	jl	SHORT $LN3@elhash_new

; 2010 :         spot = 0; 

	xor	edi, edi
$LN3@elhash_new:

; 2011 :     } while (oldptr != NULL);

	test	eax, eax
	jne	SHORT $LL15@elhash_new

; 2012 :     elhash_insert(newid,newptr);

	mov	edx, DWORD PTR _newptr$[ebp]
	push	edx
	push	esi
	call	_elhash_insert

; 2013 :     web.skel[type].free_spot = spot;
; 2014 :   }
; 2015 :   newptr->self_id = newid;
; 2016 :   web.skel[type].alloc++;

	mov	eax, DWORD PTR tv203[ebp]
	mov	DWORD PTR _web[ebx+44], edi
	mov	edi, DWORD PTR _newptr$[ebp]
	add	esp, 8
	mov	DWORD PTR [edi+16], esi
	inc	DWORD PTR [eax]

; 2017 :  
; 2018 :   return newptr;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2019 : } // end elhash_new_element()

	mov	esp, ebp
	pop	ebp
	ret	0
_elhash_new_element ENDP
_TEXT	ENDS
END
