; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\ODRV.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_mdi_
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\odrv.c
;	COMDAT _mdi_
_TEXT	SEGMENT
tv233 = -16						; size = 4
_jmax$ = -12						; size = 4
tv516 = -8						; size = 4
_j$ = -4						; size = 4
_n$ = 8							; size = 4
tv523 = 12						; size = 4
_ia$ = 12						; size = 4
_ja$ = 16						; size = 4
_max_$ = 20						; size = 4
tv628 = 24						; size = 4
_v$ = 24						; size = 4
_vi$ = 28						; size = 4
_l$ = 28						; size = 4
_i__1$ = 32						; size = 4
_head$ = 32						; size = 4
_last$ = 36						; size = 4
_next$ = 40						; size = 4
_mark$ = 44						; size = 4
_tag$ = 48						; size = 4
_flag_$ = 52						; size = 4
_mdi_	PROC						; COMDAT

; 442  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx

; 443  :      /* System generated locals */
; 444  :      integer i__1, i__2;
; 445  : 
; 446  :      /* Local variables */
; 447  :      STATIC integer jmin, jmax, j, vi, vj, dvi, sfs;
; 448  : 
; 449  : 
; 450  : /* ----INITIALIZE DEGREES, ELEMENT LISTS, AND DEGREE LISTS */
; 451  :      /* Parameter adjustments */
; 452  :      --mark;
; 453  :      --next;
; 454  :      --last;
; 455  :      --head;

	mov	ebx, DWORD PTR _head$[ebp]
	mov	eax, 4
	sub	DWORD PTR _next$[ebp], eax
	sub	DWORD PTR _last$[ebp], eax

; 456  :      --l;
; 457  :      --v;

	sub	DWORD PTR _v$[ebp], eax

; 458  :      --ja;

	sub	DWORD PTR _ja$[ebp], eax

; 459  :      --ia;

	sub	DWORD PTR _ia$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _l$[ebp]
	push	edi
	mov	edi, DWORD PTR _mark$[ebp]
	sub	edi, eax
	sub	ebx, eax
	sub	esi, eax

; 460  : 
; 461  :      /* Function Body */
; 462  :      i__1 = *n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mark$[ebp], edi
	mov	DWORD PTR _head$[ebp], ebx

; 463  :      for (vi = 1; vi <= i__1; ++vi) {

	cmp	ecx, 1
	jl	SHORT $LN14@mdi_

; 464  :           mark[vi] = 1;

	mov	edx, edi
	sub	edx, esi
	lea	eax, DWORD PTR [esi+4]
	sub	ebx, esi
	npad	11
$LL16@mdi_:
	mov	DWORD PTR [edx+eax], 1

; 465  :           l[vi] = 0;

	mov	DWORD PTR [eax], 0

; 466  : /* L1: */
; 467  :           head[vi] = 0;

	mov	DWORD PTR [ebx+eax], 0
	add	eax, 4
	dec	ecx
	jne	SHORT $LL16@mdi_

; 463  :      for (vi = 1; vi <= i__1; ++vi) {

	mov	ebx, DWORD PTR _head$[ebp]
$LN14@mdi_:

; 468  :      }
; 469  :      sfs = *n + 1;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR tv233[ebp], ecx
	lea	eax, DWORD PTR [ecx+1]

; 470  : 
; 471  : /* ----CREATE NONZERO STRUCTURE */
; 472  : /* ----FOR EACH NONZERO ENTRY A(VI,VJ) IN STRICT UPPER TRIANGLE */
; 473  :      i__1 = *n;
; 474  :      for (vi = 1; vi <= i__1; ++vi) {

	mov	DWORD PTR _vi$[ebp], 1
	cmp	ecx, 1
	jl	$LN11@mdi_
	mov	ecx, DWORD PTR _ia$[ebp]
	sub	ecx, edi
	mov	ebx, esi
	sub	ebx, edi
	lea	edx, DWORD PTR [edi+4]
	mov	DWORD PTR tv516[ebp], ecx
	mov	DWORD PTR tv523[ebp], ebx
	jmp	SHORT $LN13@mdi_
	npad	4
$LL28@mdi_:
	mov	ecx, DWORD PTR tv516[ebp]
$LN13@mdi_:

; 475  :           jmin = ia[vi];

	mov	ebx, DWORD PTR [ecx+edx]

; 476  :           jmax = ia[vi + 1] - 1;

	mov	ecx, DWORD PTR [ecx+edx+4]
	dec	ecx
	mov	DWORD PTR _jmax$[ebp], ecx

; 477  :           if (jmin > jmax) {

	cmp	ebx, ecx
	jg	SHORT $L3$89379

; 478  :                 goto L3;
; 479  :           }
; 480  :           i__2 = jmax;
; 481  :           for (j = jmin; j <= i__2; ++j) {

	mov	DWORD PTR _j$[ebp], ebx
$LL9@mdi_:

; 482  :                 vj = ja[j];

	mov	ecx, DWORD PTR _ja$[ebp]
	mov	ecx, DWORD PTR [ecx+ebx*4]

; 483  :                 if (vi >= vj) {

	cmp	DWORD PTR _vi$[ebp], ecx
	jge	SHORT $L2$89384

; 484  :                      goto L2;
; 485  :                 }
; 486  :                 if (sfs >= *max_) {

	mov	ebx, DWORD PTR _max_$[ebp]
	cmp	eax, DWORD PTR [ebx]
	jge	$L101$89386

; 487  :                      goto L101;
; 488  :                 }
; 489  : 
; 490  : /* ------ENTER VJ IN ELEMENT LIST FOR VI */
; 491  :                 ++mark[vi];

	inc	DWORD PTR [edx]

; 492  :                 v[sfs] = vj;

	mov	ebx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ebx+eax*4], ecx

; 493  :                 l[sfs] = l[vi];

	mov	ebx, DWORD PTR tv523[ebp]
	mov	ebx, DWORD PTR [ebx+edx]
	mov	DWORD PTR [esi+eax*4], ebx

; 494  :                 l[vi] = sfs;

	mov	ebx, DWORD PTR tv523[ebp]
	mov	DWORD PTR [ebx+edx], eax

; 495  :                 ++sfs;
; 496  : 
; 497  : /* ------ENTER VI IN ELEMENT LIST FOR VJ */
; 498  :                 ++mark[vj];

	inc	DWORD PTR [edi+ecx*4]

; 499  :                 v[sfs] = vi;

	mov	edi, DWORD PTR _vi$[ebp]
	mov	ebx, DWORD PTR _v$[ebp]
	inc	eax
	mov	DWORD PTR [ebx+eax*4], edi

; 500  :                 l[sfs] = l[vj];

	mov	edi, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [esi+eax*4], edi

; 501  :                 l[vj] = sfs;
; 502  :                 ++sfs;

	mov	edi, DWORD PTR _mark$[ebp]
	mov	DWORD PTR [esi+ecx*4], eax
	inc	eax
$L2$89384:

; 478  :                 goto L3;
; 479  :           }
; 480  :           i__2 = jmax;
; 481  :           for (j = jmin; j <= i__2; ++j) {

	mov	ebx, DWORD PTR _j$[ebp]
	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, DWORD PTR _jmax$[ebp]
	jle	SHORT $LL9@mdi_
$L3$89379:

; 470  : 
; 471  : /* ----CREATE NONZERO STRUCTURE */
; 472  : /* ----FOR EACH NONZERO ENTRY A(VI,VJ) IN STRICT UPPER TRIANGLE */
; 473  :      i__1 = *n;
; 474  :      for (vi = 1; vi <= i__1; ++vi) {

	mov	ecx, DWORD PTR _vi$[ebp]
	inc	ecx
	add	edx, 4
	mov	DWORD PTR _vi$[ebp], ecx
	cmp	ecx, DWORD PTR tv233[ebp]
	jle	SHORT $LL28@mdi_

; 484  :                      goto L2;
; 485  :                 }
; 486  :                 if (sfs >= *max_) {

	mov	ebx, DWORD PTR _head$[ebp]
$LN11@mdi_:

; 503  : L2:
; 504  :                 ;
; 505  :           }
; 506  : L3:
; 507  :           ;
; 508  :      }
; 509  : 
; 510  : /* ----CREATE DEGREE LISTS AND INITIALIZE MARK VECTOR */
; 511  :      i__1 = *n;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [ecx]

; 512  :      for (vi = 1; vi <= i__1; ++vi) {

	mov	edx, 1
	mov	DWORD PTR _i__1$[ebp], eax
	cmp	eax, edx
	jl	SHORT $LN2@mdi_
	mov	eax, DWORD PTR _last$[ebp]
	sub	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	add	ecx, 4
	sub	edi, DWORD PTR _next$[ebp]
	mov	DWORD PTR tv628[ebp], eax
	npad	3
$LL4@mdi_:

; 513  :           dvi = mark[vi];

	mov	eax, DWORD PTR [edi+ecx]

; 514  :           next[vi] = head[dvi];

	mov	esi, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [ecx], esi

; 515  :           head[dvi] = vi;
; 516  :           last[vi] = -dvi;

	mov	esi, DWORD PTR tv628[ebp]
	mov	DWORD PTR [ebx+eax*4], edx
	neg	eax
	mov	DWORD PTR [esi+ecx], eax

; 517  :           if (next[vi] > 0) {

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jle	SHORT $LN1@mdi_

; 518  :                 last[next[vi]] = vi;

	mov	esi, DWORD PTR _last$[ebp]
	mov	DWORD PTR [esi+eax*4], edx
$LN1@mdi_:

; 519  :           }
; 520  : /* L4: */
; 521  :           mark[vi] = *tag;

	mov	eax, DWORD PTR _tag$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edi+ecx], eax
	inc	edx
	add	ecx, 4
	cmp	edx, DWORD PTR _i__1$[ebp]
	jle	SHORT $LL4@mdi_
$LN2@mdi_:
	pop	edi
	pop	esi

; 522  :      }
; 523  : 
; 524  :      return 0;

	xor	eax, eax
	pop	ebx

; 529  :      return 0;
; 530  : } /* mdi_ */

	mov	esp, ebp
	pop	ebp
	ret	0
$L101$89386:

; 525  : 
; 526  : /* ** ERROR -- INSUFFICIENT STORAGE */
; 527  : L101:
; 528  :      *flag_ = *n * 9 + vi;

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _vi$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	add	edx, eax
	mov	eax, DWORD PTR _flag_$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], edx
	xor	eax, eax
	pop	ebx

; 529  :      return 0;
; 530  : } /* mdi_ */

	mov	esp, ebp
	pop	ebp
	ret	0
_mdi_	ENDP
_TEXT	ENDS
PUBLIC	_mdm_
; Function compile flags: /Ogtp
;	COMDAT _mdm_
_TEXT	SEGMENT
_ls$ = -4						; size = 4
_equiv_0$ = 8						; size = 4
_vk$ = 8						; size = 4
_tail$ = 12						; size = 4
_v$ = 16						; size = 4
_tag$ = 20						; size = 4
_l$ = 20						; size = 4
_last$ = 24						; size = 4
_next$ = 28						; size = 4
tv135 = 32						; size = 4
_mark$ = 32						; size = 4
_mdm_	PROC						; COMDAT

; 545  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 546  :      /* System generated locals */
; 547  :      integer i__1;
; 548  :      STATIC integer equiv_0[1];
; 549  : 
; 550  :      /* Local variables */
; 551  :      STATIC integer b, s, lb;
; 552  : #define es (equiv_0)
; 553  :      STATIC integer vb, ls;
; 554  : #define vs (equiv_0)
; 555  :      STATIC integer blpmax, tag, blp;
; 556  : 
; 557  : 
; 558  : /* ----INITIALIZE TAG AND LIST OF UNELIMINATED NEIGHBORS */
; 559  :      /* Parameter adjustments */
; 560  :      --mark;
; 561  :      --next;
; 562  :      --last;
; 563  :      --l;

	mov	eax, DWORD PTR _l$[ebp]

; 564  :      --v;
; 565  : 
; 566  :      /* Function Body */
; 567  :      tag = mark[*vk];

	mov	edx, DWORD PTR _vk$[ebp]
	push	ebx
	mov	ecx, 4
	sub	DWORD PTR _next$[ebp], ecx
	sub	DWORD PTR _last$[ebp], ecx
	sub	DWORD PTR _v$[ebp], ecx
	push	esi

; 568  :      *tail = *vk;

	mov	esi, DWORD PTR _tail$[ebp]
	push	edi
	mov	edi, DWORD PTR _mark$[ebp]
	sub	edi, ecx
	sub	eax, ecx
	mov	ecx, DWORD PTR [edx]
	mov	ebx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [esi], ecx

; 569  : 
; 570  : /* ----FOR EACH VERTEX/ELEMENT VS/ES IN ELEMENT LIST OF VK */
; 571  :      ls = l[*vk];

	mov	ecx, DWORD PTR [edx]

; 572  : L1:
; 573  :      s = ls;

	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _tag$[ebp], ebx

; 574  :      if (s == 0) {

	test	ecx, ecx
	je	$L5$89418
	npad	4
$L1$89416:

; 575  :           goto L5;
; 576  :      }
; 577  :      ls = l[s];

	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _ls$[ebp], edx

; 578  :      *vs = v[s];

	mov	edx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR [edx+ecx*4]

; 579  :      if (next[*vs] < 0) {

	mov	edx, DWORD PTR _next$[ebp]
	cmp	DWORD PTR [edx+esi*4], 0
	mov	DWORD PTR _equiv_0$[ebp], esi
	jge	SHORT $LN5@mdm_

; 594  :      blpmax = last[*es];
; 595  :      i__1 = blpmax;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	edx, DWORD PTR [eax+esi*4]
$L2$89420:

; 596  :      for (blp = 1; blp <= i__1; ++blp) {

	cmp	ecx, 1
	jl	SHORT $LN2@mdm_

; 588  :      goto L4;
; 589  : 
; 590  : /* ------IF ES IS ACTIVE ELEMENT, THEN ... */
; 591  : /* --------FOR EACH VERTEX VB IN BOUNDARY LIST OF ELEMENT ES */
; 592  : L2:
; 593  :      lb = l[*es];

	mov	DWORD PTR tv135[ebp], ecx
	npad	7
$LL14@mdm_:

; 597  :           b = lb;
; 598  :           lb = l[b];
; 599  :           vb = v[b];

	mov	ebx, DWORD PTR _v$[ebp]
	lea	ecx, DWORD PTR [edx*4]
	mov	esi, edx
	mov	edx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR [ecx+ebx]

; 600  : 
; 601  : /* ----------IF VB IS UNTAGGED VERTEX, THEN TAG AND APPEND TO LIST OF 
; 602  : */
; 603  : /* ----------UNELIMINATED NEIGHBORS */
; 604  :           if (mark[vb] >= tag) {

	mov	ebx, DWORD PTR _tag$[ebp]
	cmp	DWORD PTR [edi+ecx*4], ebx
	jge	SHORT $L3$89426

; 605  :                 goto L3;
; 606  :           }
; 607  :           mark[vb] = tag;

	mov	DWORD PTR [edi+ecx*4], ebx

; 608  :           l[*tail] = b;

	mov	ecx, DWORD PTR _tail$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+ecx*4], esi

; 609  :           *tail = b;

	mov	ecx, DWORD PTR _tail$[ebp]
	mov	DWORD PTR [ecx], esi
$L3$89426:

; 596  :      for (blp = 1; blp <= i__1; ++blp) {

	dec	DWORD PTR tv135[ebp]
	jne	SHORT $LL14@mdm_
	mov	esi, DWORD PTR _equiv_0$[ebp]
$LN2@mdm_:

; 610  : L3:
; 611  :           ;
; 612  :      }
; 613  : 
; 614  : /* --------MARK ES INACTIVE */
; 615  :      mark[*es] = tag;

	mov	DWORD PTR [edi+esi*4], ebx
	jmp	SHORT $L4$89421
$LN5@mdm_:

; 580  :           goto L2;
; 581  :      }
; 582  : 
; 583  : /* ------IF VS IS UNELIMINATED VERTEX, THEN TAG AND APPEND TO LIST OF */
; 584  : /* ------UNELIMINATED NEIGHBORS */
; 585  :      mark[*vs] = tag;
; 586  :      l[*tail] = s;

	mov	edx, DWORD PTR _tail$[ebp]
	mov	DWORD PTR [edi+esi*4], ebx
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax+esi*4], ecx

; 587  :      *tail = s;

	mov	DWORD PTR [edx], ecx
$L4$89421:

; 574  :      if (s == 0) {

	mov	ecx, DWORD PTR _ls$[ebp]
	test	ecx, ecx
	jne	SHORT $L1$89416
$L5$89418:

; 616  : 
; 617  : L4:
; 618  :      goto L1;
; 619  : 
; 620  : /* ----TERMINATE LIST OF UNELIMINATED NEIGHBORS */
; 621  : L5:
; 622  :      l[*tail] = 0;

	mov	edx, DWORD PTR _tail$[ebp]
	mov	ecx, DWORD PTR [edx]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+ecx*4], 0

; 623  : 
; 624  :      return 0;

	xor	eax, eax
	pop	ebx

; 625  : } /* mdm_ */

	mov	esp, ebp
	pop	ebp
	ret	0
_mdm_	ENDP
_TEXT	ENDS
PUBLIC	_mdp_
; Function compile flags: /Ogtp
;	COMDAT _mdp_
_TEXT	SEGMENT
_ofree$ = -24						; size = 4
_vi$ = -20						; size = 4
_tag$ = -16						; size = 4
tv249 = -12						; size = 4
_i$ = -8						; size = 4
tv305 = -4						; size = 4
_k$ = 8							; size = 4
_ek$ = 12						; size = 4
_tail$ = 16						; size = 4
_v$ = 20						; size = 4
_s$ = 24						; size = 4
_l$ = 24						; size = 4
_head$ = 28						; size = 4
_last$ = 32						; size = 4
_next$ = 36						; size = 4
_mark$ = 40						; size = 4
_mdp_	PROC						; COMDAT

; 646  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 647  :      /* System generated locals */
; 648  :      integer i__1;
; 649  : 
; 650  :      /* Local variables */
; 651  :      STATIC integer ofree, i, s, li, es, vi, ls, ilpmax, tag, evi, ilp, lvi;
; 652  : 
; 653  : 
; 654  : /* ----INITIALIZE TAG */
; 655  :      /* Parameter adjustments */
; 656  :      --mark;

	mov	ecx, DWORD PTR _mark$[ebp]

; 657  :      --next;
; 658  :      --last;
; 659  :      --head;
; 660  :      --l;

	mov	eax, DWORD PTR _l$[ebp]
	mov	edx, 4
	sub	DWORD PTR _head$[ebp], edx

; 661  :      --v;

	sub	DWORD PTR _v$[ebp], edx
	push	ebx
	mov	ebx, DWORD PTR _next$[ebp]
	sub	ecx, edx
	push	edi
	mov	edi, DWORD PTR _last$[ebp]
	sub	edi, edx
	sub	ebx, edx
	sub	eax, edx

; 662  : 
; 663  :      /* Function Body */
; 664  :      tag = mark[*ek];

	mov	edx, DWORD PTR _ek$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR _mark$[ebp], ecx
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _tag$[ebp], ecx

; 665  : 
; 666  : /* ----FOR EACH VERTEX VI IN EK */
; 667  :      li = *ek;
; 668  :      ilpmax = last[*ek];

	mov	ecx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR _next$[ebp], ebx
	mov	DWORD PTR _last$[ebp], edi

; 669  :      if (ilpmax <= 0) {

	test	ecx, ecx
	jle	$L12$89460

; 670  :           goto L12;
; 671  :      }
; 672  :      i__1 = ilpmax;
; 673  :      for (ilp = 1; ilp <= i__1; ++ilp) {

	cmp	ecx, 1
	jl	$L12$89460
	push	esi
	mov	DWORD PTR tv249[ebp], ecx
	jmp	SHORT $LN12@mdp_
$LL22@mdp_:
	mov	ebx, DWORD PTR _next$[ebp]
$LN12@mdp_:

; 674  :           i = li;
; 675  :           li = l[i];
; 676  :           vi = v[li];

	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR _i$[ebp], edx
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv305[ebp], edx
	mov	edx, DWORD PTR [edx+eax]
	mov	esi, DWORD PTR [ecx+edx*4]

; 677  : 
; 678  : /* ------REMOVE VI FROM DEGREE LIST */
; 679  :           if (last[vi] == 0) {

	mov	ecx, DWORD PTR [edi+esi*4]
	mov	DWORD PTR _vi$[ebp], esi
	test	ecx, ecx
	je	SHORT $L3$89465

; 680  :                 goto L3;
; 681  :           }
; 682  :           if (last[vi] > 0) {

	jle	SHORT $LN8@mdp_

; 686  :           goto L2;
; 687  : L1:
; 688  :           next[last[vi]] = next[vi];

	mov	edi, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [ebx+ecx*4], edi
	mov	edi, DWORD PTR _last$[ebp]
$L1$89467:
	jmp	SHORT $L2$89468
$LN8@mdp_:

; 683  :                 goto L1;
; 684  :           }
; 685  :           head[-last[vi]] = next[vi];

	mov	ebx, DWORD PTR _head$[ebp]
	add	ecx, ecx
	add	ecx, ecx
	sub	ebx, ecx
	mov	ecx, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [ebx], ecx
$L2$89468:

; 689  : L2:
; 690  :           if (next[vi] > 0) {

	mov	ecx, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	test	ecx, ecx
	jle	SHORT $L3$89465

; 691  :                 last[next[vi]] = last[vi];

	mov	ebx, DWORD PTR [edi+esi*4]
	mov	DWORD PTR [edi+ecx*4], ebx
$L3$89465:

; 692  :           }
; 693  : 
; 694  : /* ------REMOVE INACTIVE ITEMS FROM ELEMENT LIST OF VI */
; 695  : L3:
; 696  :           ls = vi;
; 697  : L4:
; 698  :           s = ls;
; 699  :           ls = l[s];

	mov	ecx, DWORD PTR [eax+esi*4]
	mov	DWORD PTR _s$[ebp], esi

; 700  :           if (ls == 0) {

	test	ecx, ecx
	je	SHORT $L6$89472
	mov	edi, DWORD PTR _tag$[ebp]
	mov	esi, DWORD PTR _mark$[ebp]
$L4$89470:

; 701  :                 goto L6;
; 702  :           }
; 703  :           es = v[ls];
; 704  :           if (mark[es] < tag) {

	mov	ebx, DWORD PTR _v$[ebp]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	cmp	DWORD PTR [esi+ebx*4], edi
	jl	SHORT $L5$89474

; 705  :                 goto L5;
; 706  :           }
; 707  :           ofree = ls;
; 708  :           l[s] = l[ls];

	mov	ebx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _ofree$[ebp], ecx
	mov	ecx, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+ecx*4], ebx
$L5$89474:

; 692  :           }
; 693  : 
; 694  : /* ------REMOVE INACTIVE ITEMS FROM ELEMENT LIST OF VI */
; 695  : L3:
; 696  :           ls = vi;
; 697  : L4:
; 698  :           s = ls;
; 699  :           ls = l[s];

	mov	DWORD PTR _s$[ebp], ecx
	mov	ecx, DWORD PTR [eax+ecx*4]

; 700  :           if (ls == 0) {

	test	ecx, ecx
	jne	SHORT $L4$89470
	mov	edi, DWORD PTR _last$[ebp]
	mov	esi, DWORD PTR _vi$[ebp]
$L6$89472:

; 709  :           ls = s;
; 710  : L5:
; 711  :           goto L4;
; 712  : 
; 713  : /* ------IF VI IS INTERIOR VERTEX, THEN REMOVE FROM LIST AND ELIMINATE
; 714  :  */
; 715  : L6:
; 716  :           lvi = l[vi];

	mov	ecx, DWORD PTR [eax+esi*4]

; 717  :           if (lvi != 0) {

	test	ecx, ecx
	je	SHORT $LN4@mdp_
$L7$89476:

; 726  :           goto L11;
; 727  : 
; 728  : /* ------ELSE ... */
; 729  : /* --------CLASSIFY VERTEX VI */
; 730  : L7:
; 731  :           if (l[lvi] != 0) {

	cmp	DWORD PTR [eax+ecx*4], 0
	jne	SHORT $L9$89479

; 732  :                 goto L9;
; 733  :           }
; 734  :           evi = v[lvi];

	mov	ebx, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [ebx+ecx*4]

; 735  :           if (next[evi] >= 0) {

	mov	ebx, DWORD PTR _next$[ebp]
	cmp	DWORD PTR [ebx+ecx*4], 0
	jl	SHORT $LN2@mdp_
$L9$89479:

; 762  : 
; 763  : /* ----------ELSE MARK VI TO COMPUTE DEGREE */
; 764  : L9:
; 765  :           last[vi] = -(*ek);

	mov	ecx, DWORD PTR _ek$[ebp]
	mov	ecx, DWORD PTR [ecx]
	neg	ecx
	mov	DWORD PTR [edi+esi*4], ecx
	jmp	SHORT $L10$89483
$LN2@mdp_:

; 736  :                 goto L9;
; 737  :           }
; 738  :           if (mark[evi] < 0) {

	mov	ebx, DWORD PTR _mark$[ebp]
	cmp	DWORD PTR [ebx+ecx*4], 0
	jge	SHORT $LN1@mdp_

; 753  :           goto L10;
; 754  : 
; 755  : /* ----------ELSE IF VI IS DUPLICATE VERTEX, THEN MARK AS SUCH AND ADJ
; 756  : UST */
; 757  : /* ----------OVERLAP COUNT FOR CORRESPONDING ELEMENT */
; 758  : L8:
; 759  :           last[vi] = 0;

	mov	DWORD PTR [edi+esi*4], 0

; 760  :           --mark[evi];

	dec	DWORD PTR [ebx+ecx*4]
$L8$89482:

; 761  :           goto L10;

	jmp	SHORT $L10$89483
$LN1@mdp_:

; 739  :                 goto L8;
; 740  :           }
; 741  : 
; 742  : /* ----------IF VI IS PROTOTYPE VERTEX, THEN MARK AS SUCH, INITIALIZE 
; 743  : */
; 744  : /* ----------OVERLAP COUNT FOR CORRESPONDING ELEMENT, AND MOVE VI TO E
; 745  : ND */
; 746  : /* ----------OF BOUNDARY LIST */
; 747  :           last[vi] = evi;

	mov	DWORD PTR [edi+esi*4], ecx

; 748  :           mark[evi] = -1;

	mov	DWORD PTR [ebx+ecx*4], -1

; 749  :           l[*tail] = li;

	mov	ecx, DWORD PTR _tail$[ebp]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edi*4], edx

; 750  :           *tail = li;

	mov	DWORD PTR [ecx], edx

; 751  :           l[i] = l[li];

	mov	edx, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR tv305[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 752  :           li = i;

	mov	edx, DWORD PTR _i$[ebp]
$L10$89483:

; 766  : 
; 767  : /* --------INSERT EK IN ELEMENT LIST OF VI */
; 768  : L10:
; 769  :           v[ofree] = *ek;

	mov	ecx, DWORD PTR _ek$[ebp]
	mov	edi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ofree$[ebp]
	mov	ebx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ebx+ecx*4], edi

; 770  :           l[ofree] = l[vi];

	mov	edi, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [eax+ecx*4], edi

; 771  :           l[vi] = ofree;

	mov	edi, DWORD PTR _last$[ebp]
	mov	DWORD PTR [eax+esi*4], ecx
	jmp	SHORT $L11$89477
$LN4@mdp_:

; 718  :                 goto L7;
; 719  :           }
; 720  :           l[i] = l[li];

	mov	edx, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR tv305[ebp]

; 721  :           li = i;
; 722  : 
; 723  :           ++(*k);
; 724  :           next[vi] = -(*k);

	mov	ebx, DWORD PTR _next$[ebp]
	mov	DWORD PTR [ecx+eax], edx
	mov	ecx, DWORD PTR _k$[ebp]
	inc	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR _i$[ebp]
	neg	ecx
	mov	DWORD PTR [ebx+esi*4], ecx

; 725  :           --last[*ek];

	mov	ecx, DWORD PTR _ek$[ebp]
	mov	ecx, DWORD PTR [ecx]
	dec	DWORD PTR [edi+ecx*4]
	lea	ecx, DWORD PTR [edi+ecx*4]
$L11$89477:

; 670  :           goto L12;
; 671  :      }
; 672  :      i__1 = ilpmax;
; 673  :      for (ilp = 1; ilp <= i__1; ++ilp) {

	dec	DWORD PTR tv249[ebp]
	jne	$LL22@mdp_
	pop	esi
$L12$89460:

; 772  : L11:
; 773  :           ;
; 774  :      }
; 775  : 
; 776  : /* ----TERMINATE BOUNDARY LIST */
; 777  : L12:
; 778  :      l[*tail] = 0;

	mov	edx, DWORD PTR _tail$[ebp]
	mov	ecx, DWORD PTR [edx]
	pop	edi
	mov	DWORD PTR [eax+ecx*4], 0

; 779  : 
; 780  :      return 0;

	xor	eax, eax
	pop	ebx

; 781  : } /* mdp_ */

	mov	esp, ebp
	pop	ebp
	ret	0
_mdp_	ENDP
_TEXT	ENDS
PUBLIC	_mdu_
; Function compile flags: /Ogtp
;	COMDAT _mdu_
_TEXT	SEGMENT
tv306 = -12						; size = 4
tv240 = -8						; size = 4
_vi$ = -4						; size = 4
_ek$ = 8						; size = 4
_dmin_$ = 12						; size = 4
_v$ = 16						; size = 4
_l$ = 20						; size = 4
_head$ = 24						; size = 4
_last$ = 28						; size = 4
_next$ = 32						; size = 4
_s$ = 36						; size = 4
_mark$ = 36						; size = 4
_mdu_	PROC						; COMDAT

; 797  : {

	push	ebp
	mov	ebp, esp

; 798  :      /* System generated locals */
; 799  :      integer i__1, i__2;
; 800  :      STATIC integer equiv_0[1];
; 801  : 
; 802  :      /* Local variables */
; 803  :      STATIC integer b, i, s;
; 804  : #define es (equiv_0)
; 805  :      STATIC integer vb, vi;
; 806  : #define vs (equiv_0)
; 807  :      STATIC integer blpmax, ilpmax, tag, blp, dvi, evi, ilp;
; 808  : 
; 809  : 
; 810  : /* ----INITIALIZE TAG */
; 811  :      /* Parameter adjustments */
; 812  :      --mark;

	mov	eax, DWORD PTR _mark$[ebp]
	sub	esp, 12					; 0000000cH
	push	ebx

; 813  :      --next;
; 814  :      --last;

	mov	ebx, DWORD PTR _last$[ebp]
	mov	ecx, 4
	sub	DWORD PTR _next$[ebp], ecx

; 815  :      --head;

	sub	DWORD PTR _head$[ebp], ecx

; 816  :      --l;

	sub	DWORD PTR _l$[ebp], ecx

; 817  :      --v;

	sub	DWORD PTR _v$[ebp], ecx
	push	esi

; 818  : 
; 819  :      /* Function Body */
; 820  :      tag = mark[*ek] - last[*ek];

	mov	esi, DWORD PTR _ek$[ebp]
	mov	edx, DWORD PTR [esi]
	sub	eax, ecx
	sub	ebx, ecx
	mov	ecx, DWORD PTR [ebx+edx*4]
	push	edi
	mov	edi, DWORD PTR [eax+edx*4]
	sub	edi, ecx
	mov	DWORD PTR _last$[ebp], ebx

; 821  : 
; 822  : /* ----FOR EACH VERTEX VI IN EK */
; 823  :      i = *ek;
; 824  :      ilpmax = last[*ek];
; 825  :      if (ilpmax <= 0) {

	test	ecx, ecx
	jle	$LN32@mdu_

; 826  :           goto L11;
; 827  :      }
; 828  :      i__1 = ilpmax;
; 829  :      for (ilp = 1; ilp <= i__1; ++ilp) {

	cmp	ecx, 1
	jl	$LN32@mdu_
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv240[ebp], ecx
	jmp	SHORT $LN18@mdu_
	npad	2
$LL38@mdu_:
	mov	esi, DWORD PTR _ek$[ebp]
	mov	edx, DWORD PTR tv306[ebp]
$LN18@mdu_:

; 830  :           i = l[i];

	mov	ecx, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]

; 831  :           vi = v[i];

	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR tv306[ebp], ecx

; 832  :           if ((i__2 = last[vi]) < 0) {

	mov	ecx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR _vi$[ebp], edx
	test	ecx, ecx
	jns	$LN39@mdu_

; 835  :                 goto L10;
; 836  :           } else {
; 837  :                 goto L8;
; 838  :           }
; 839  : 
; 840  : /* ------IF VI NEITHER PROTOTYPE NOR DUPLICATE VERTEX, THEN MERGE ELEM
; 841  : ENTS */
; 842  : /* ------TO COMPUTE DEGREE */
; 843  : L1:
; 844  :           ++tag;
; 845  :           dvi = last[*ek];

	mov	ecx, DWORD PTR [esi]
	mov	esi, DWORD PTR [ebx+ecx*4]

; 846  : 
; 847  : /* --------FOR EACH VERTEX/ELEMENT VS/ES IN ELEMENT LIST OF VI */
; 848  :           s = l[vi];
; 849  : L2:
; 850  :           s = l[s];

	mov	ecx, DWORD PTR _l$[ebp]
	mov	ebx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	inc	edi
$L1$89522:
	mov	DWORD PTR _s$[ebp], ecx

; 851  :           if (s == 0) {

	test	ecx, ecx
	je	$L9$89530
$L2$89528:

; 853  :           }
; 854  :           *vs = v[s];

	mov	edx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]

; 855  :           if (next[*vs] < 0) {

	mov	ebx, DWORD PTR _next$[ebp]
	lea	ecx, DWORD PTR [edx*4]
	cmp	DWORD PTR [ecx+ebx], 0
	jge	SHORT $LN10@mdu_
$L3$89532:

; 863  :           goto L5;
; 864  : 
; 865  : /* ----------IF ES IS ACTIVE ELEMENT, THEN EXPAND */
; 866  : /* ------------CHECK FOR OUTMATCHED VERTEX */
; 867  : L3:
; 868  :           if (mark[*es] < 0) {

	cmp	DWORD PTR [ecx+eax], 0
	jl	SHORT $L6$89535

; 874  :           blpmax = last[*es];
; 875  :           i__2 = blpmax;

	mov	edx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx+edx]

; 876  :           for (blp = 1; blp <= i__2; ++blp) {

	cmp	edx, 1
	jl	SHORT $L5$89533

; 869  :                 goto L6;
; 870  :           }
; 871  : 
; 872  : /* ------------FOR EACH VERTEX VB IN ES */
; 873  :           b = *es;

	mov	ebx, edx
	npad	6
$LL8@mdu_:

; 877  :                 b = l[b];

	mov	edx, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]

; 878  :                 vb = v[b];

	mov	edx, DWORD PTR _v$[ebp]
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [ecx+edx]

; 879  : 
; 880  : /* --------------IF VB IS UNTAGGED, THEN TAG AND ADJUST DEGREE */
; 881  :                 if (mark[vb] >= tag) {

	cmp	DWORD PTR [eax+edx*4], edi
	jge	SHORT $L4$89540

; 882  :                      goto L4;
; 883  :                 }
; 884  :                 mark[vb] = tag;

	mov	DWORD PTR [eax+edx*4], edi

; 885  :                 ++dvi;

	inc	esi
$L4$89540:

; 876  :           for (blp = 1; blp <= i__2; ++blp) {

	dec	ebx
	jne	SHORT $LL8@mdu_

; 901  :           if (s == 0) {

	jmp	SHORT $L5$89533
$LN10@mdu_:

; 856  :                 goto L3;
; 857  :           }
; 858  : 
; 859  : /* ----------IF VS IS UNELIMINATED VERTEX, THEN TAG AND ADJUST DEGREE 
; 860  : */
; 861  :           mark[*vs] = tag;

	mov	DWORD PTR [ecx+eax], edi

; 862  :           ++dvi;

	inc	esi
$L5$89533:

; 846  : 
; 847  : /* --------FOR EACH VERTEX/ELEMENT VS/ES IN ELEMENT LIST OF VI */
; 848  :           s = l[vi];
; 849  : L2:
; 850  :           s = l[s];

	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _s$[ebp], ecx

; 851  :           if (s == 0) {

	test	ecx, ecx
	jne	SHORT $L2$89528

; 852  :                 goto L9;

	mov	edx, DWORD PTR _vi$[ebp]
	jmp	SHORT $L9$89530
$L6$89535:

; 886  : L4:
; 887  :                 ;
; 888  :           }
; 889  : 
; 890  : L5:
; 891  :           goto L2;
; 892  : 
; 893  : /* ------ELSE IF VI IS OUTMATCHED VERTEX, THEN ADJUST OVERLAPS BUT DO 
; 894  : NOT */
; 895  : /* ------COMPUTE DEGREE */
; 896  : L6:
; 897  :           last[vi] = 0;

	mov	ecx, DWORD PTR _vi$[ebp]
	mov	ebx, DWORD PTR _last$[ebp]
	mov	DWORD PTR [ebx+ecx*4], 0

; 898  :           --mark[*es];

	dec	DWORD PTR [eax+edx*4]

; 899  : L7:
; 900  :           s = l[s];

	mov	edx, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]

; 901  :           if (s == 0) {

	test	ecx, ecx
	je	SHORT $L10$89525
$L7$89541:

; 903  :           }
; 904  :           *es = v[s];

	mov	edx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]

; 905  :           if (mark[*es] < 0) {

	mov	esi, DWORD PTR [eax+edx*4]
	test	esi, esi
	jns	SHORT $LN3@mdu_

; 906  :                 --mark[*es];

	dec	esi
	mov	DWORD PTR [eax+edx*4], esi
$LN3@mdu_:

; 899  : L7:
; 900  :           s = l[s];

	mov	edx, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]

; 901  :           if (s == 0) {

	test	ecx, ecx
	jne	SHORT $L7$89541

; 902  :                 goto L10;

	jmp	SHORT $L10$89525
$LN39@mdu_:

; 833  :                 goto L1;
; 834  :           } else if (i__2 == 0) {

	je	SHORT $L10$89525

; 907  :           }
; 908  :           goto L7;
; 909  : 
; 910  : /* ------ELSE IF VI IS PROTOTYPE VERTEX, THEN CALCULATE DEGREE BY */
; 911  : /* ------INCLUSION/EXCLUSION AND RESET OVERLAP COUNT */
; 912  : L8:
; 913  :           evi = last[vi];
; 914  :           dvi = last[*ek] + last[evi] + mark[evi];

	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [ebx+esi*4]
	add	esi, DWORD PTR [ebx+ecx*4]
$L8$89527:
	add	esi, DWORD PTR [eax+ecx*4]

; 915  :           mark[evi] = 0;

	mov	DWORD PTR [eax+ecx*4], 0
$L9$89530:

; 916  : 
; 917  : /* ------INSERT VI IN APPROPRIATE DEGREE LIST */
; 918  : L9:
; 919  :           next[vi] = head[dvi];

	mov	ecx, DWORD PTR _head$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	ebx, DWORD PTR _next$[ebp]
	mov	DWORD PTR [ebx+edx*4], ecx

; 920  :           head[dvi] = vi;

	mov	ecx, DWORD PTR _head$[ebp]

; 921  :           last[vi] = -dvi;

	mov	ebx, DWORD PTR _last$[ebp]
	mov	DWORD PTR [ecx+esi*4], edx
	mov	ecx, esi
	neg	ecx
	mov	DWORD PTR [ebx+edx*4], ecx

; 922  :           if (next[vi] > 0) {

	mov	ecx, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	test	ecx, ecx
	jle	SHORT $LN2@mdu_

; 923  :                 last[next[vi]] = vi;

	mov	DWORD PTR [ebx+ecx*4], edx
$LN2@mdu_:

; 924  :           }
; 925  :           if (dvi < *dmin_) {

	mov	ecx, DWORD PTR _dmin_$[ebp]
	cmp	esi, DWORD PTR [ecx]
	jge	SHORT $L10$89525

; 926  :                 *dmin_ = dvi;

	mov	DWORD PTR [ecx], esi
$L10$89525:

; 826  :           goto L11;
; 827  :      }
; 828  :      i__1 = ilpmax;
; 829  :      for (ilp = 1; ilp <= i__1; ++ilp) {

	dec	DWORD PTR tv240[ebp]
	jne	$LL38@mdu_
$LN32@mdu_:
	pop	edi
	pop	esi

; 927  :           }
; 928  : 
; 929  : L10:
; 930  :           ;
; 931  :      }
; 932  : 
; 933  : L11:
; 934  :      return 0;

	xor	eax, eax
$L11$89517:
	pop	ebx

; 935  : } /* mdu_ */

	mov	esp, ebp
	pop	ebp
	ret	0
_mdu_	ENDP
_TEXT	ENDS
PUBLIC	_sro_
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
;	COMDAT _sro_
_TEXT	SEGMENT
tv568 = -16						; size = 4
_jmax$ = -16						; size = 4
_i__1$ = -12						; size = 4
tv537 = -8						; size = 4
tv164 = -4						; size = 4
tv716 = 8						; size = 4
_n$ = 8							; size = 4
_jak$ = 12						; size = 4
_ilast$ = 12						; size = 4
_ip$ = 12						; size = 4
_j$ = 16						; size = 4
_ia$ = 16						; size = 4
_ja$ = 20						; size = 4
_a$ = 24						; size = 4
_jmin$ = 28						; size = 4
_i$ = 28						; size = 4
_q$ = 28						; size = 4
_r$ = 32						; size = 4
_dflag$ = 36						; size = 4
_sro_	PROC						; COMDAT

; 956  : {

	push	ebp
	mov	ebp, esp

; 1006 :      --q;
; 1007 :      --a;
; 1008 :      --ja;
; 1009 :      --ia;
; 1010 :      --ip;

	mov	edx, DWORD PTR _ip$[ebp]
	sub	DWORD PTR _a$[ebp], 8
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, DWORD PTR _q$[ebp]
	mov	eax, 4
	sub	DWORD PTR _r$[ebp], eax
	sub	DWORD PTR _ja$[ebp], eax
	sub	DWORD PTR _ia$[ebp], eax
	push	esi

; 1011 : 
; 1012 :      /* Function Body */
; 1013 :      i__1 = *n;

	mov	esi, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [esi]
	sub	edx, eax
	sub	ebx, eax
	push	edi
	mov	DWORD PTR _ip$[ebp], edx

; 1014 :      for (i = 1; i <= i__1; ++i) {

	cmp	ecx, 1
	jl	SHORT $LN24@sro_

; 957  :      /* System generated locals */
; 958  :      integer i__1, i__2;
; 959  : 
; 960  :      /* Local variables */
; 961  :      STATIC integer jmin, jmax, i, j, k, ilast;
; 962  :      STATIC doublereal ak;
; 963  :      STATIC integer jdummy, jak;
; 964  : 
; 965  : 
; 966  : /*  DESCRIPTION */
; 967  : 
; 968  : /*     THE NONZERO ENTRIES OF THE MATRIX M ARE ASSUMED TO BE STORED */
; 969  : /*     SYMMETRICALLY IN (IA,JA,A) FORMAT (I.E., NOT BOTH M(I,J) AND M(J,I) 
; 970  : */
; 971  : /*     ARE STORED IF I NE J). */
; 972  : 
; 973  : /*     SRO DOES NOT REARRANGE THE ORDER OF THE ROWS, BUT DOES MOVE */
; 974  : /*     NONZEROES FROM ONE ROW TO ANOTHER TO ENSURE THAT IF M(I,J) WILL BE 
; 975  : */
; 976  : /*     IN THE UPPER TRIANGLE OF M WITH RESPECT TO THE NEW ORDERING, THEN */
; 977  : 
; 978  : /*     M(I,J) IS STORED IN ROW I (AND THUS M(J,I) IS NOT STORED);  WHEREAS 
; 979  : */
; 980  : /*     IF M(I,J) WILL BE IN THE STRICT LOWER TRIANGLE OF M, THEN M(J,I) IS 
; 981  : */
; 982  : /*     STORED IN ROW J (AND THUS M(I,J) IS NOT STORED). */
; 983  : 
; 984  : 
; 985  : /*  ADDITIONAL PARAMETERS */
; 986  : 
; 987  : /*     Q      - INTEGER ONE-DIMENSIONAL WORK ARRAY;  DIMENSION = N */
; 988  : 
; 989  : /*     R      - INTEGER ONE-DIMENSIONAL WORK ARRAY;  DIMENSION = NUMBER OF 
; 990  : */
; 991  : /*                NONZERO ENTRIES IN THE UPPER TRIANGLE OF M */
; 992  : 
; 993  : /*     DFLAG - LOGICAL VARIABLE;  IF DFLAG = .TRUE., THEN STORE NONZERO */
; 994  : /*                DIAGONAL ELEMENTS AT THE BEGINNING OF THE ROW */
; 995  : 
; 996  : /* -----------------------------------------------------------------------
; 997  :  */
; 998  : 
; 999  : /*         REAL  A(1),  AK */
; 1000 : 
; 1001 : 
; 1002 : /* --PHASE 1 -- FIND ROW IN WHICH TO STORE EACH NONZERO */
; 1003 : /* ----INITIALIZE COUNT OF NONZEROES TO BE STORED IN EACH ROW */
; 1004 :      /* Parameter adjustments */
; 1005 :      --r;

	lea	edi, DWORD PTR [ebx+4]
	xor	eax, eax
	rep stosd
$LN24@sro_:

; 1015 : /* L1: */
; 1016 :           q[i] = 0;
; 1017 :      }
; 1018 : 
; 1019 : /* ----FOR EACH NONZERO ELEMENT A(J) */
; 1020 :      i__1 = *n;

	mov	esi, DWORD PTR [esi]
	mov	DWORD PTR _i__1$[ebp], esi

; 1021 :      for (i = 1; i <= i__1; ++i) {

	mov	DWORD PTR _i$[ebp], 1
	cmp	esi, 1
	jl	SHORT $LN19@sro_
	mov	ecx, DWORD PTR _ia$[ebp]
	lea	edi, DWORD PTR [edx+4]
	sub	ecx, edx
	mov	DWORD PTR tv537[ebp], edi
	mov	DWORD PTR tv568[ebp], ecx
$LL21@sro_:

; 1022 :           jmin = ia[i];
; 1023 :           jmax = ia[i + 1] - 1;

	mov	eax, DWORD PTR [ecx+edi+4]
	mov	edx, DWORD PTR [ecx+edi]
	dec	eax

; 1024 :           if (jmin > jmax) {

	cmp	edx, eax
	jg	SHORT $L3$89581

; 1034 :                      ja[j] = i;

	mov	esi, DWORD PTR _r$[ebp]
	sub	esi, DWORD PTR _ja$[ebp]
	mov	ecx, DWORD PTR _ja$[ebp]
	mov	edi, DWORD PTR tv537[ebp]
	sub	eax, edx
	inc	eax
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv164[ebp], eax
	npad	7
$LL17@sro_:

; 1029 : 
; 1030 : /* --------FIND ROW (=R(J)) AND COLUMN (=JA(J)) IN WHICH TO STORE 
; 1031 : A(J) ... */
; 1032 :                 k = ja[j];
; 1033 :                 if (ip[k] < ip[i]) {

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _ip$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	cmp	edx, DWORD PTR [edi]
	jge	SHORT $LN14@sro_

; 1034 :                      ja[j] = i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx], edx
$LN14@sro_:

; 1035 :                 }
; 1036 :                 if (ip[k] >= ip[i]) {

	mov	edx, DWORD PTR _ip$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	cmp	edx, DWORD PTR [edi]
	jl	SHORT $LN44@sro_

; 1037 :                      k = i;

	mov	eax, DWORD PTR _i$[ebp]
$LN44@sro_:

; 1038 :                 }
; 1039 :                 r[j] = k;

	mov	DWORD PTR [esi+ecx], eax

; 1040 : 
; 1041 : /* --------... AND INCREMENT COUNT OF NONZEROES (=Q(R(J)) IN THAT 
; 1042 : ROW */
; 1043 : /* L2: */
; 1044 :                 ++q[k];

	inc	DWORD PTR [ebx+eax*4]
	add	ecx, 4
	dec	DWORD PTR tv164[ebp]
	jne	SHORT $LL17@sro_

; 1025 :                 goto L3;
; 1026 :           }
; 1027 :           i__2 = jmax;
; 1028 :           for (j = jmin; j <= i__2; ++j) {

	mov	esi, DWORD PTR _i__1$[ebp]
	mov	ecx, DWORD PTR tv568[ebp]
$L3$89581:

; 1021 :      for (i = 1; i <= i__1; ++i) {

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	edi, 4
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR tv537[ebp], edi
	cmp	eax, esi
	jle	SHORT $LL21@sro_
$LN19@sro_:

; 1045 :           }
; 1046 : L3:
; 1047 :           ;
; 1048 :      }
; 1049 : 
; 1050 : 
; 1051 : /* --PHASE 2 -- FIND NEW IA AND PERMUTATION TO APPLY TO (JA,A) */
; 1052 : /* ----DETERMINE POINTERS TO DELIMIT ROWS IN PERMUTED (JA,A) */
; 1053 :      i__1 = *n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	edi, DWORD PTR [eax]

; 1054 :      for (i = 1; i <= i__1; ++i) {

	cmp	edi, 1
	jl	SHORT $LN10@sro_
	mov	edx, DWORD PTR _ia$[ebp]
	lea	eax, DWORD PTR [ebx+4]
	sub	edx, ebx
$LL12@sro_:

; 1055 :           ia[i + 1] = ia[i] + q[i];

	mov	ecx, DWORD PTR [edx+eax]
	add	ecx, DWORD PTR [eax]
	add	eax, 4
	dec	edi
	mov	DWORD PTR [edx+eax], ecx

; 1056 : /* L4: */
; 1057 :           q[i] = ia[i + 1];

	mov	DWORD PTR [eax-4], ecx
	jne	SHORT $LL12@sro_
$LN10@sro_:

; 1058 :      }
; 1059 : 
; 1060 : /* ----DETERMINE WHERE EACH (JA(J),A(J)) IS STORED IN PERMUTED (JA,A) */
; 1061 : /* ----FOR EACH NONZERO ELEMENT (IN REVERSE ORDER) */
; 1062 :      ilast = 0;
; 1063 :      jmin = ia[1];
; 1064 :      jmax = ia[*n + 1] - 1;

	mov	edx, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _ia$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	edi, DWORD PTR [ecx+edx*4+4]
	mov	eax, DWORD PTR [ecx+4]
	dec	edi
	mov	DWORD PTR _ilast$[ebp], 0
	mov	DWORD PTR _jmin$[ebp], eax
	mov	DWORD PTR _jmax$[ebp], edi

; 1065 :      j = jmax;
; 1066 :      i__1 = jmax;
; 1067 :      for (jdummy = jmin; jdummy <= i__1; ++jdummy) {

	cmp	eax, edi
	jg	SHORT $LN7@sro_
	mov	esi, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR _ja$[ebp]
	sub	edx, esi
	mov	DWORD PTR tv716[ebp], edx
	mov	edx, edi
	sub	edx, eax
	lea	ecx, DWORD PTR [esi+edi*4]
	inc	edx
	npad	6
$LL9@sro_:

; 1068 :           i = r[j];
; 1069 :           if (! (*dflag) || ja[j] != i || i == ilast) {

	mov	esi, DWORD PTR _dflag$[ebp]
	cmp	DWORD PTR [esi], 0
	mov	eax, DWORD PTR [ecx]
	je	SHORT $L5$89595
	mov	esi, DWORD PTR tv716[ebp]
	cmp	DWORD PTR [esi+ecx], eax
	jne	SHORT $L5$89595
	cmp	eax, DWORD PTR _ilast$[ebp]
	je	SHORT $L5$89595

; 1070 :                 goto L5;
; 1071 :           }
; 1072 : 
; 1073 : /* ------IF DFLAG, THEN PUT DIAGONAL NONZERO AT BEGINNING OF ROW */
; 1074 :           r[j] = ia[i];

	mov	esi, DWORD PTR _ia$[ebp]
	mov	esi, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx], esi

; 1075 :           ilast = i;

	mov	DWORD PTR _ilast$[ebp], eax

; 1076 :           goto L6;

	jmp	SHORT $L6$89596
$L5$89595:

; 1077 : 
; 1078 : /* ------PUT (OFF-DIAGONAL) NONZERO IN LAST UNUSED LOCATION IN ROW */
; 1079 : L5:
; 1080 :           --q[i];

	dec	DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [ebx+eax*4]

; 1081 :           r[j] = q[i];

	mov	DWORD PTR [ecx], eax
$L6$89596:

; 1082 : 
; 1083 : L6:
; 1084 :           --j;

	sub	ecx, 4
	dec	edx
	jne	SHORT $LL9@sro_

; 1065 :      j = jmax;
; 1066 :      i__1 = jmax;
; 1067 :      for (jdummy = jmin; jdummy <= i__1; ++jdummy) {

	mov	eax, DWORD PTR _jmin$[ebp]
$LN7@sro_:

; 1085 :      }
; 1086 : 
; 1087 : 
; 1088 : /* --PHASE 3 -- PERMUTE (JA,A) TO UPPER TRIANGULAR FORM (WRT NEW ORDERING)
; 1089 :  */
; 1090 :      i__1 = jmax;
; 1091 :      for (j = jmin; j <= i__1; ++j) {

	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, edi
	jg	SHORT $LN42@sro_
	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	esi, DWORD PTR _ja$[ebp]
	mov	ebx, DWORD PTR _r$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [edx+eax*8]
	sub	esi, ebx
$LL4@sro_:

; 1092 : L7:
; 1093 :           if (r[j] == j) {

	cmp	DWORD PTR [ecx], eax
	je	SHORT $L8$89602
$L7$89600:

; 1094 :                 goto L8;
; 1095 :           }
; 1096 :           k = r[j];

	mov	eax, DWORD PTR [ecx]

; 1097 :           r[j] = r[k];

	mov	edi, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [ecx], edi

; 1098 :           r[k] = k;
; 1099 :           jak = ja[k];

	mov	edi, DWORD PTR _ja$[ebp]
	mov	DWORD PTR [ebx+eax*4], eax
	mov	ebx, DWORD PTR [edi+eax*4]
	mov	DWORD PTR _jak$[ebp], ebx

; 1100 :           ja[k] = ja[j];

	mov	ebx, DWORD PTR [ecx+esi]
	mov	DWORD PTR [edi+eax*4], ebx

; 1101 :           ja[j] = jak;

	mov	edi, DWORD PTR _jak$[ebp]
	mov	ebx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx+esi], edi

; 1102 :           ak = a[k];

	mov	edi, DWORD PTR _a$[ebp]
	fld	QWORD PTR [edi+eax*8]

; 1103 :           a[k] = a[j];

	fld	QWORD PTR [edx]
	fstp	QWORD PTR [edi+eax*8]
	mov	eax, DWORD PTR _j$[ebp]

; 1104 :           a[j] = ak;

	fstp	QWORD PTR [edx]
	cmp	DWORD PTR [ecx], eax
	jne	SHORT $L7$89600

; 1092 : L7:
; 1093 :           if (r[j] == j) {

	mov	edi, DWORD PTR _jmax$[ebp]
$L8$89602:

; 1085 :      }
; 1086 : 
; 1087 : 
; 1088 : /* --PHASE 3 -- PERMUTE (JA,A) TO UPPER TRIANGULAR FORM (WRT NEW ORDERING)
; 1089 :  */
; 1090 :      i__1 = jmax;
; 1091 :      for (j = jmin; j <= i__1; ++j) {

	inc	eax
	add	edx, 8
	add	ecx, 4
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, edi
	jle	SHORT $LL4@sro_
$LN42@sro_:
	pop	edi
	pop	esi

; 1105 :           goto L7;
; 1106 : L8:
; 1107 :           ;
; 1108 :      }
; 1109 : 
; 1110 :      return 0;

	xor	eax, eax
	pop	ebx

; 1111 : } /* sro_ */

	mov	esp, ebp
	pop	ebp
	ret	0
_sro_	ENDP
_TEXT	ENDS
PUBLIC	_md_
; Function compile flags: /Ogtp
;	COMDAT _md_
_TEXT	SEGMENT
tv264 = -12						; size = 4
_tail$ = -12						; size = 4
tv263 = -8						; size = 4
tv266 = -4						; size = 4
_n$ = 8							; size = 4
_equiv_0$ = 12						; size = 4
_ia$ = 12						; size = 4
_dmin_$ = 16						; size = 4
_ja$ = 16						; size = 4
_max_$ = 20						; size = 4
_tag$ = 24						; size = 4
_v$ = 24						; size = 4
tv267 = 28						; size = 4
_l$ = 28						; size = 4
_head$ = 32						; size = 4
_last$ = 36						; size = 4
_next$ = 40						; size = 4
_mark$ = 44						; size = 4
_k$ = 48						; size = 4
_flag_$ = 48						; size = 4
_md_	PROC						; COMDAT

; 329  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 330  :      /* System generated locals */
; 331  :      integer i__1;
; 332  :      STATIC integer equiv_0[1];
; 333  : 
; 334  :      /* Local variables */
; 335  :      STATIC integer dmin_, tail, k;
; 336  : #define ek (equiv_0)
; 337  : #define vk (equiv_0)
; 338  :      STATIC integer tag;
; 339  : #ifdef NOPROTO
; 340  :      extern /* Subroutine */ int mdi_();
; 341  :      extern /* Subroutine */ int mdm_(), mdp_(), mdu_();
; 342  : #endif
; 343  : 
; 344  : 
; 345  : /* ----INITIALIZATION */
; 346  :      /* Parameter adjustments */
; 347  :      --mark;
; 348  :      --next;
; 349  :      --last;
; 350  :      --head;
; 351  :      --l;

	mov	eax, DWORD PTR _l$[ebp]

; 352  :      --v;

	mov	ecx, DWORD PTR _v$[ebp]
	sub	DWORD PTR _last$[ebp], 4
	push	ebx
	mov	ebx, DWORD PTR _head$[ebp]
	push	esi
	mov	esi, DWORD PTR _mark$[ebp]
	push	edi
	mov	edi, DWORD PTR _next$[ebp]

; 353  :      --ja;
; 354  :      --ia;
; 355  : 
; 356  :      /* Function Body */
; 357  :      tag = 0;
; 358  :      mdi_(n, &ia[1], &ja[1], max_, &v[1], &l[1], &head[1], &last[1], &next[1], 
; 359  :                 &mark[1], &tag, flag_);

	mov	DWORD PTR tv267[ebp], ecx
	mov	ecx, DWORD PTR _flag_$[ebp]
	push	ecx
	sub	edi, 4
	sub	esi, 4
	lea	edx, DWORD PTR [edi+4]
	mov	DWORD PTR tv263[ebp], edx
	mov	edx, DWORD PTR _last$[ebp]
	lea	ecx, DWORD PTR _tag$[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv263[ebp]
	add	edx, 4
	mov	DWORD PTR _mark$[ebp], esi
	add	esi, 4
	push	esi
	push	ecx
	mov	DWORD PTR tv264[ebp], edx
	mov	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _ja$[ebp]
	sub	ebx, 4
	lea	edx, DWORD PTR [ebx+4]
	push	edx
	mov	edx, DWORD PTR tv267[ebp]
	push	eax
	push	edx
	mov	edx, DWORD PTR _ia$[ebp]
	mov	DWORD PTR tv266[ebp], eax
	mov	eax, DWORD PTR _max_$[ebp]
	push	eax
	mov	eax, DWORD PTR _n$[ebp]
	push	ecx
	push	edx
	push	eax
	mov	DWORD PTR _next$[ebp], edi
	mov	DWORD PTR _head$[ebp], ebx
	mov	DWORD PTR _tag$[ebp], 0
	call	_mdi_

; 360  :      if (*flag_ != 0) {

	mov	ecx, DWORD PTR _flag_$[ebp]
	add	esp, 48					; 00000030H
	cmp	DWORD PTR [ecx], 0

; 361  :           return 0;

	jne	$LN1@md_

; 362  :      }
; 363  : 
; 364  :      k = 0;
; 365  :      dmin_ = 1;
; 366  : 
; 367  : /* ----WHILE  K < N  DO */
; 368  : L1:
; 369  :      if (k >= *n) {

	mov	edx, DWORD PTR _n$[ebp]
	cmp	DWORD PTR [edx], 0
	mov	ecx, 1
	mov	DWORD PTR _k$[ebp], 0
	mov	DWORD PTR _dmin_$[ebp], ecx
	jle	$L4$89330
	jmp	SHORT $L1$89328
	npad	9
$LL19@md_:
	mov	ecx, DWORD PTR _dmin_$[ebp]
	mov	ebx, DWORD PTR _head$[ebp]
$L1$89328:

; 370  :           goto L4;
; 371  :      }
; 372  : 
; 373  : /* ------SEARCH FOR VERTEX OF MINIMUM DEGREE */
; 374  : L2:
; 375  :      if (head[dmin_] > 0) {

	cmp	DWORD PTR [ebx+ecx*4], 0
	jg	SHORT $L3$89333
	npad	4
$L2$89331:

; 376  :           goto L3;
; 377  :      }
; 378  :      ++dmin_;

	inc	ecx
	cmp	DWORD PTR [ebx+ecx*4], 0
	jle	SHORT $L2$89331
	mov	DWORD PTR _dmin_$[ebp], ecx
$L3$89333:

; 379  :      goto L2;
; 380  : 
; 381  : /* ------REMOVE VERTEX VK OF MINIMUM DEGREE FROM DEGREE LIST */
; 382  : L3:
; 383  :      *vk = head[dmin_];

	mov	eax, DWORD PTR [ebx+ecx*4]

; 384  :      head[dmin_] = next[*vk];

	mov	edx, DWORD PTR [edi+eax*4]
	mov	DWORD PTR _equiv_0$[ebp], eax
	mov	DWORD PTR [ebx+ecx*4], edx

; 385  :      if (head[dmin_] > 0) {

	test	edx, edx
	jle	SHORT $LN20@md_

; 386  :           last[head[dmin_]] = -dmin_;

	mov	edi, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _last$[ebp]
	mov	edx, ecx
	neg	edx
	mov	DWORD PTR [ebx+edi*4], edx
	mov	edi, DWORD PTR _next$[ebp]
	jmp	SHORT $LN4@md_
$LN20@md_:
	mov	ebx, DWORD PTR _last$[ebp]
$LN4@md_:

; 387  :      }
; 388  : 
; 389  : /* ------NUMBER VERTEX VK, ADJUST TAG, AND TAG VK */
; 390  :      ++k;

	mov	edx, DWORD PTR _k$[ebp]
	inc	edx
	mov	DWORD PTR _k$[ebp], edx

; 391  :      next[*vk] = -k;

	neg	edx
	mov	DWORD PTR [edi+eax*4], edx

; 392  :      last[*ek] = dmin_ - 1;
; 393  :      tag += last[*ek];

	mov	edx, DWORD PTR _tag$[ebp]
	dec	ecx
	add	edx, ecx
	mov	DWORD PTR [ebx+eax*4], ecx

; 394  :      mark[*vk] = tag; 

	mov	ecx, DWORD PTR _mark$[ebp]

; 395  : 
; 396  : /* ------FORM ELEMENT EK FROM UNELIMINATED NEIGHBORS OF VK */
; 397  :      mdm_(vk, &tail, &v[1], &l[1], &last[1], &next[1], &mark[1]);

	push	esi
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR tv267[ebp]
	add	edi, 4
	push	edi
	mov	DWORD PTR _tag$[ebp], edx
	mov	edx, DWORD PTR tv266[ebp]
	add	ebx, 4
	push	ebx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _tail$[ebp]
	push	ecx
	lea	edx, DWORD PTR _equiv_0$[ebp]
	push	edx
	call	_mdm_

; 398  : 
; 399  : /* ------PURGE INACTIVE ELEMENTS AND DO MASS ELIMINATION */
; 400  :      mdp_(&k, ek, &tail, &v[1], &l[1], &head[1], &last[1], &next[1], &mark[1]);

	mov	eax, DWORD PTR _head$[ebp]
	mov	ecx, DWORD PTR tv267[ebp]
	push	esi
	push	edi
	push	ebx
	add	eax, 4
	push	eax
	mov	eax, DWORD PTR tv266[ebp]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _tail$[ebp]
	push	edx
	lea	eax, DWORD PTR _equiv_0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_mdp_

; 401  : 
; 402  : 
; 403  : /* ------UPDATE DEGREES OF UNELIMINATED VERTICES IN EK */
; 404  :      mdu_(ek, &dmin_, &v[1], &l[1], &head[1], &last[1], &next[1], &mark[1]);

	mov	eax, DWORD PTR _head$[ebp]
	mov	edx, DWORD PTR tv266[ebp]
	add	esp, 64					; 00000040H
	push	esi
	push	edi
	push	ebx
	add	eax, 4
	push	eax
	mov	eax, DWORD PTR tv267[ebp]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _dmin_$[ebp]
	push	ecx
	lea	edx, DWORD PTR _equiv_0$[ebp]
	push	edx
	call	_mdu_
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR _next$[ebp]
	add	esp, 32					; 00000020H
	cmp	ecx, DWORD PTR [eax]
	jl	$LL19@md_
$L4$89330:

; 405  : 
; 406  :      goto L1;
; 407  : 
; 408  : /* ----GENERATE INVERSE PERMUTATION FROM PERMUTATION */
; 409  : L4:
; 410  :      i__1 = *n;

	mov	edx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [edx]

; 411  :      for (k = 1; k <= i__1; ++k) {

	mov	eax, 1
	cmp	edx, eax
	jl	SHORT $LN1@md_
$LL3@md_:

; 412  :           next[k] = -next[k];

	mov	ecx, DWORD PTR [edi+eax*4]

; 413  : /* L5: */
; 414  :           last[next[k]] = k;

	mov	esi, DWORD PTR _last$[ebp]
	neg	ecx
	mov	DWORD PTR [edi+eax*4], ecx
	mov	DWORD PTR [esi+ecx*4], eax
	inc	eax
	cmp	eax, edx
	jle	SHORT $LL3@md_
$LN1@md_:
	pop	edi
	pop	esi

; 415  :      }
; 416  : 
; 417  :      return 0;

	xor	eax, eax
	pop	ebx

; 418  : } /* md_ */

	mov	esp, ebp
	pop	ebp
	ret	0
_md_	ENDP
_TEXT	ENDS
PUBLIC	_odrv_
; Function compile flags: /Ogtp
;	COMDAT _odrv_
_TEXT	SEGMENT
_n$ = 8							; size = 4
_ia$ = 12						; size = 4
_ja$ = 16						; size = 4
_a$ = 20						; size = 4
_p$ = 24						; size = 4
_ip$ = 28						; size = 4
_nsp$ = 32						; size = 4
_max_$ = 36						; size = 4
_isp$ = 36						; size = 4
_path$ = 40						; size = 4
_dflag$ = 44						; size = 4
_flag_$ = 44						; size = 4
_odrv_	PROC						; COMDAT

; 148  : {

	push	ebp
	mov	ebp, esp

; 149  : 
; 150  :   STATIC integer head, l;
; 151  :   STATIC logical dflag;
; 152  :   STATIC integer q, v;
; 153  :   STATIC integer max_, tmp;
; 154  : #ifdef NOPROTO
; 155  :   extern /* Subroutine */ int md_();
; 156  :   extern /* Subroutine */ int sro_();
; 157  : #endif
; 158  : 
; 159  : /* ....    REAL  A(1) */
; 160  : /* ----INITIALIZE ERROR FLAG AND VALIDATE PATH SPECIFICATION */
; 161  :      /* Parameter adjustments */
; 162  :      --isp;
; 163  :      --ip;
; 164  :      --p;
; 165  :      --a;
; 166  :      --ja;
; 167  :      --ia;
; 168  : 
; 169  :      /* Function Body */
; 170  :      *flag_ = 0;

	mov	ecx, DWORD PTR _flag_$[ebp]
	sub	DWORD PTR _a$[ebp], 8
	push	ebx
	mov	ebx, DWORD PTR _ia$[ebp]
	mov	eax, 4
	sub	DWORD PTR _ip$[ebp], eax
	sub	DWORD PTR _ja$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _isp$[ebp]
	sub	esi, eax
	sub	ebx, eax

; 171  :      if (*path < 1 || 5 < *path) {

	mov	eax, DWORD PTR _path$[ebp]
	mov	DWORD PTR [ecx], 0
	mov	eax, DWORD PTR [eax]
	cmp	eax, 1
	jl	$L111$89288
	cmp	eax, 5
	jg	$L111$89288

; 172  :           goto L111;
; 173  :      }
; 174  : 
; 175  : 
; 176  : /* ----ALLOCATE STORAGE AND FIND MINIMUM DEGREE ORDERING */
; 177  :      if ((*path - 1) * (*path - 2) * (*path - 4) != 0) {

	push	edi
	lea	edx, DWORD PTR [eax-4]
	lea	edi, DWORD PTR [eax-2]
	imul	edx, edi
	dec	eax
	imul	edx, eax
	test	edx, edx
	jne	SHORT $L1$89290

; 178  :           goto L1;
; 179  :      }
; 180  :      max_ = (*nsp - *n) / 2;

	mov	eax, DWORD PTR _n$[ebp]
	mov	edi, DWORD PTR [eax]
	mov	edx, DWORD PTR _nsp$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _max_$[ebp], eax

; 181  :      v = 1;
; 182  :      l = v + max_;
; 183  :      head = l + max_;
; 184  :      if (max_ < *n) {

	cmp	eax, edi
	jl	SHORT $L110$89292

; 185  :           goto L110;
; 186  :      }
; 187  : 
; 188  : 
; 189  : 
; 190  :      md_(n, &ia[1], &ja[1], &max_, &isp[v], &isp[l], &isp[head], &p[1], &ip[1],
; 191  :                  &isp[v], flag_);

	mov	edi, DWORD PTR _flag_$[ebp]
	mov	edx, DWORD PTR _ip$[ebp]
	push	edi
	add	edx, 4
	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	lea	edx, DWORD PTR [eax+eax+1]
	lea	edx, DWORD PTR [esi+edx*4]
	push	edx
	mov	edx, DWORD PTR _ja$[ebp]
	lea	eax, DWORD PTR [esi+eax*4+4]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _max_$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _n$[ebp]
	add	edx, 4
	push	edx
	lea	eax, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	call	_md_
	add	esp, 44					; 0000002cH

; 192  : 
; 193  : 
; 194  :      if (*flag_ != 0) {

	cmp	DWORD PTR [edi], 0

; 212  : 
; 213  : 
; 214  : L2:
; 215  :      return 0;
; 216  : 
; 217  : /* ** ERROR -- ERROR DETECTED IN MD */
; 218  : L100:
; 219  :      return 0;

	jne	SHORT $L2$89296
$L1$89290:

; 195  :           goto L100;
; 196  :      }
; 197  : 
; 198  : /* ----ALLOCATE STORAGE AND SYMMETRICALLY REORDER MATRIX */
; 199  : L1:
; 200  :      if ((*path - 2) * (*path - 3) * (*path - 4) * (*path - 5) != 0) {

	mov	edx, DWORD PTR _path$[ebp]
	mov	edx, DWORD PTR [edx]
	lea	ecx, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-5]
	imul	eax, ecx
	lea	ecx, DWORD PTR [edx-3]
	imul	eax, ecx
	lea	ecx, DWORD PTR [edx-2]
	imul	eax, ecx
	test	eax, eax
	jne	SHORT $L2$89296

; 201  :           goto L2;
; 202  :      }
; 203  :      tmp = *nsp + 1 - *n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	edi, DWORD PTR [eax]
	mov	ecx, DWORD PTR _nsp$[ebp]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, edi

; 204  :      q = tmp - (ia[*n + 1] - 1);

	lea	eax, DWORD PTR [ecx+1]
	sub	eax, DWORD PTR [ebx+edi*4+4]
	inc	eax

; 205  :      if (q < 1) {

	cmp	eax, 1
	jge	SHORT $LN1@odrv_
	mov	ecx, DWORD PTR _flag_$[ebp]
$L110$89292:

; 220  : /* ** ERROR -- INSUFFICIENT STORAGE */
; 221  : L110:
; 222  :      *flag_ = *n * 10 + 1;

	lea	edx, DWORD PTR [edi+edi*4]
	lea	eax, DWORD PTR [edx+edx+1]
	mov	DWORD PTR [ecx], eax
$L2$89296:

; 223  :      return 0;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 227  :      return 0;
; 228  : } /* odrv_ */

	pop	ebp
	ret	0
$LN1@odrv_:

; 206  :           goto L110;
; 207  :      }
; 208  : 
; 209  :      dflag = *path == 4 || *path == 5;

	cmp	edx, 4
	je	SHORT $LN10@odrv_
	mov	DWORD PTR _dflag$[ebp], 0
	cmp	edx, 5
	jne	SHORT $LN11@odrv_
$LN10@odrv_:
	mov	DWORD PTR _dflag$[ebp], 1
$LN11@odrv_:

; 210  : 
; 211  :      sro_(n, &ip[1], &ia[1], &ja[1], &a[1], &isp[tmp], &isp[q], &dflag);

	lea	edx, DWORD PTR _dflag$[ebp]
	push	edx
	mov	edx, DWORD PTR _a$[ebp]
	lea	eax, DWORD PTR [esi+eax*4]
	push	eax
	mov	eax, DWORD PTR _ja$[ebp]
	lea	ecx, DWORD PTR [esi+ecx*4+4]
	push	ecx
	mov	ecx, DWORD PTR _ip$[ebp]
	add	edx, 8
	push	edx
	mov	edx, DWORD PTR _n$[ebp]
	add	eax, 4
	push	eax
	add	ebx, 4
	push	ebx
	add	ecx, 4
	push	ecx
	push	edx
	call	_sro_
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
$L100$89294:

; 223  :      return 0;

	xor	eax, eax
	pop	ebx

; 227  :      return 0;
; 228  : } /* odrv_ */

	pop	ebp
	ret	0
$L111$89288:

; 224  : /* ** ERROR -- ILLEGAL PATH SPECIFIED */
; 225  : L111:
; 226  :      *flag_ = *n * 11 + 1;

	mov	eax, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [eax]
	imul	edx, 11					; 0000000bH
	inc	edx
	pop	esi
	mov	DWORD PTR [ecx], edx
	xor	eax, eax
	pop	ebx

; 227  :      return 0;
; 228  : } /* odrv_ */

	pop	ebp
	ret	0
_odrv_	ENDP
_TEXT	ENDS
END
