; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\QUOTIENT.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_rotorder
PUBLIC	_genpower
PUBLIC	_rotorder_var
PUBLIC	_genpower_var
_DATA	SEGMENT
COMM	_quarter_turn_var:DWORD
_rotorder DD	04H
_genpower DD	01H
_rotmat	DQ	00000000000000000r		; 0
	DQ	0bff0000000000000r		; -1
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
_rotorder_var DD 0ffffffffH
_genpower_var DD 0ffffffffH
_xxx	DQ	03ff0000000000000r		; 1
	DQ	03ff0000000000000r		; 1
	DQ	03ff0000000000000r		; 1
_lift_var DD	0ffffffffH
_twist_var DD	0ffffffffH
_screw_stamp DD	0ffffffffH
_DATA	ENDS
PUBLIC	__real@401921fb54442d18
PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_0BA@FJNJNMKE@generator_power?$AA@		; `string'
PUBLIC	__real@4010000000000000
PUBLIC	??_C@_0P@PIMLINCN@rotation_order?$AA@		; `string'
PUBLIC	_new_rot_order
EXTRN	_dymem:DWORD
EXTRN	_web:BYTE
EXTRN	_localbase:DWORD
EXTRN	_add_global:PROC
EXTRN	_lookup_global:PROC
EXTRN	__fltused:DWORD
EXTRN	__CIsin:PROC
EXTRN	__CIcos:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@401921fb54442d18
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\quotient.c
CONST	SEGMENT
__real@401921fb54442d18 DQ 0401921fb54442d18r	; 6.28319
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_0BA@FJNJNMKE@generator_power?$AA@
CONST	SEGMENT
??_C@_0BA@FJNJNMKE@generator_power?$AA@ DB 'generator_power', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT ??_C@_0P@PIMLINCN@rotation_order?$AA@
CONST	SEGMENT
??_C@_0P@PIMLINCN@rotation_order?$AA@ DB 'rotation_order', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _new_rot_order
_TEXT	SEGMENT
tv373 = -8						; size = 8
_new_rot_order PROC					; COMDAT

; 88   :  {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 89   :    if ((rotorder_var = lookup_global(ROTORDER_NAME)) < 0)

	push	OFFSET ??_C@_0P@PIMLINCN@rotation_order?$AA@
	call	_lookup_global
	add	esp, 4
	mov	DWORD PTR _rotorder_var, eax
	test	eax, eax
	jns	$LN2@new_rot_or

; 90   :    {
; 91   :      rotorder_var = add_global(ROTORDER_NAME);

	push	OFFSET ??_C@_0P@PIMLINCN@rotation_order?$AA@
	call	_add_global

; 92   :      globals(rotorder_var)->value.real = 4.;

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 4
	mov	DWORD PTR _rotorder_var, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN5@new_rot_or
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN7@new_rot_or
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN6@new_rot_or
$LN7@new_rot_or:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN5@new_rot_or
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN6@new_rot_or
$LN5@new_rot_or:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN6@new_rot_or:
	fld	QWORD PTR __real@4010000000000000
	fstp	QWORD PTR [eax+64]

; 93   :      globals(rotorder_var)->flags = ORDINARY_PARAM | RECALC_PARAMETER | ALWAYS_RECALC;

	mov	eax, DWORD PTR _rotorder_var
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN11@new_rot_or
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN13@new_rot_or
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN12@new_rot_or
$LN13@new_rot_or:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN11@new_rot_or
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN12@new_rot_or
$LN11@new_rot_or:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN12@new_rot_or:
	mov	DWORD PTR [eax+192], 134217737		; 08000009H
	mov	eax, DWORD PTR _rotorder_var
$LN2@new_rot_or:

; 94   :    }
; 95   :    rotorder = (int)globals(rotorder_var)->value.real;

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN17@new_rot_or
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN19@new_rot_or
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN18@new_rot_or
$LN19@new_rot_or:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN17@new_rot_or
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN18@new_rot_or
$LN17@new_rot_or:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN18@new_rot_or:
	fld	QWORD PTR [eax+64]
	call	__ftol2_sse

; 96   :    if ((genpower_var = lookup_global(GENPOWER_NAME)) < 0)

	push	OFFSET ??_C@_0BA@FJNJNMKE@generator_power?$AA@
	mov	DWORD PTR _rotorder, eax
	call	_lookup_global
	add	esp, 4
	mov	DWORD PTR _genpower_var, eax
	test	eax, eax
	jns	$LN1@new_rot_or

; 97   :    {
; 98   :      genpower_var = add_global(GENPOWER_NAME);

	push	OFFSET ??_C@_0BA@FJNJNMKE@generator_power?$AA@
	call	_add_global

; 99   :      globals(genpower_var)->value.real = 1.;

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 4
	mov	DWORD PTR _genpower_var, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN23@new_rot_or
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN25@new_rot_or
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN24@new_rot_or
$LN25@new_rot_or:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN23@new_rot_or
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN24@new_rot_or
$LN23@new_rot_or:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN24@new_rot_or:
	fld1
	fstp	QWORD PTR [eax+64]

; 100  :      globals(genpower_var)->flags = ORDINARY_PARAM | RECALC_PARAMETER | ALWAYS_RECALC;

	mov	eax, DWORD PTR _genpower_var
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN29@new_rot_or
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN31@new_rot_or
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN30@new_rot_or
$LN31@new_rot_or:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN29@new_rot_or
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN30@new_rot_or
$LN29@new_rot_or:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN30@new_rot_or:
	mov	DWORD PTR [eax+192], 134217737		; 08000009H
	mov	eax, DWORD PTR _genpower_var
$LN1@new_rot_or:

; 101  :    }
; 102  :    genpower = (int)globals(genpower_var)->value.real;

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN35@new_rot_or
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN37@new_rot_or
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN36@new_rot_or
$LN37@new_rot_or:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN35@new_rot_or
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN36@new_rot_or
$LN35@new_rot_or:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN36@new_rot_or:
	fld	QWORD PTR [eax+64]
	call	__ftol2_sse
	mov	DWORD PTR _genpower, eax

; 103  : 
; 104  :    rotmat[0][0] = rotmat[1][1] = cos(2*M_PI*genpower/rotorder);

	fild	DWORD PTR _genpower
	fmul	QWORD PTR __real@401921fb54442d18
	fidiv	DWORD PTR _rotorder
	fst	QWORD PTR tv373[ebp]
	call	__CIcos
	fst	QWORD PTR _rotmat+24
	fstp	QWORD PTR _rotmat

; 105  :    rotmat[1][0] = -(rotmat[0][1] = sin(2*M_PI*genpower/rotorder));

	fld	QWORD PTR tv373[ebp]
	call	__CIsin
	fst	QWORD PTR _rotmat+8
	fchs
	fstp	QWORD PTR _rotmat+16

; 106  :  } // end new_rot_order()

	mov	esp, ebp
	pop	ebp
	ret	0
_new_rot_order ENDP
_TEXT	ENDS
PUBLIC	_reset_rot_order
; Function compile flags: /Ogtp
;	COMDAT _reset_rot_order
_TEXT	SEGMENT
_reset_rot_order PROC					; COMDAT

; 111  :    if (lookup_global(ROTORDER_NAME) >= 0)

	push	OFFSET ??_C@_0P@PIMLINCN@rotation_order?$AA@
	call	_lookup_global
	add	esp, 4
	test	eax, eax
	js	SHORT $LN1@reset_rot_

; 112  :    new_rot_order();

	jmp	_new_rot_order
$LN1@reset_rot_:

; 113  :  } // end reset_rot_order()

	ret	0
_reset_rot_order ENDP
_TEXT	ENDS
PUBLIC	_rot_new_order
; Function compile flags: /Ogtp
;	COMDAT _rot_new_order
_TEXT	SEGMENT
_rot_new_order PROC					; COMDAT

; 118  :    if (rotorder_var<0)

	cmp	DWORD PTR _rotorder_var, 0
	jge	SHORT $LN1@rot_new_or

; 119  :    new_rot_order();

	jmp	_new_rot_order
$LN1@rot_new_or:

; 120  :  } // end rot_new_order()

	ret	0
_rot_new_order ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_rot_wrap
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _rot_wrap
_TEXT	SEGMENT
tv394 = -56						; size = 4
_t$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_wrap$ = 16						; size = 4
_rot_wrap PROC						; COMDAT

; 137  :  {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 138  :    int i,j,k;
; 139  :    REAL t[MAXCOORD];
; 140  : 
; 141  :    /* copy original coordinates */
; 142  :    memcpy((char*)y,(char*)x,SDIM*sizeof(REAL));

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR _x$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _y$[ebp]
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	push	eax
	push	esi
	call	_memcpy

; 143  :    if (!wrap) return;  /* 0 should always be used to encode the identity */

	mov	ebx, DWORD PTR _wrap$[ebp]
	add	esp, 12					; 0000000cH
	test	ebx, ebx
	je	$LN9@rot_wrap

; 144  : 
; 145  :    rot_new_order();  /* check that we're using the right order */

	push	edi
	call	_rot_new_order

; 146  :    if ( 0 == (wrap = stdwrap(wrap))) 

	mov	edi, DWORD PTR _rotorder
	test	ebx, ebx
	jns	SHORT $LN16@rot_wrap
	lea	ecx, DWORD PTR [edi-1]
	imul	ecx, ebx
	neg	ecx
	jmp	SHORT $LN17@rot_wrap
$LN16@rot_wrap:
	mov	ecx, ebx
$LN17@rot_wrap:
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1
	lea	eax, DWORD PTR [ebx+ecx]
	cdq
	idiv	edi
	mov	edi, edx
	sub	edi, ebx
	je	$LN50@rot_wrap

; 147  :       return; /* adjust to have small abs value */
; 148  : 
; 149  :    /* adjust for wrapping */
; 150  :    for ( i = 0 ; i < (wrap>0?wrap:-wrap); i++ )

	mov	eax, edi
	cdq
	xor	eax, edx
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN50@rot_wrap
	mov	DWORD PTR tv394[ebp], eax
	npad	2
$LL11@rot_wrap:

; 151  :    { memcpy((char*)t,(char*)y,SDIM*sizeof(REAL));

	mov	ebx, DWORD PTR _web+616
	add	ebx, ebx
	add	ebx, ebx
	add	ebx, ebx
	push	ebx
	lea	eax, DWORD PTR _t$[ebp]
	push	esi
	push	eax
	call	_memcpy

; 158  :          t[j] += y[k]*rotmat[j][k];

	fld	QWORD PTR [esi]
	fmul	QWORD PTR _rotmat
	add	esp, 12					; 0000000cH
	fldz
	fadd	ST(1), ST(0)
	fld	QWORD PTR _rotmat+16
	fld	QWORD PTR _rotmat+8
	fld	QWORD PTR [esi+8]
	test	edi, edi
	jle	SHORT $LN29@rot_wrap
	fmul	ST(0), ST(1)

; 159  :        else

	jmp	SHORT $LN63@rot_wrap
$LN29@rot_wrap:

; 160  :          t[j] += y[k]*rotmat[k][j];

	fmul	ST(0), ST(2)
$LN63@rot_wrap:
	faddp	ST(4), ST(0)
	fxch	ST(3)
	fstp	QWORD PTR _t$[ebp]
	test	edi, edi
	jle	SHORT $LN57@rot_wrap

; 152  :      /* copy in all coords, then adjust x,y */
; 153  :      for (j=0; j<2; j++)
; 154  :      {
; 155  :        t[j]=0.;
; 156  :        for (k=0;k<2;k++)
; 157  :        if (wrap>0)

	fstp	ST(2)

; 159  :        else

	jmp	SHORT $LN64@rot_wrap
$LN57@rot_wrap:

; 152  :      /* copy in all coords, then adjust x,y */
; 153  :      for (j=0; j<2; j++)
; 154  :      {
; 155  :        t[j]=0.;
; 156  :        for (k=0;k<2;k++)
; 157  :        if (wrap>0)

	fstp	ST(0)
$LN64@rot_wrap:

; 160  :          t[j] += y[k]*rotmat[k][j];

	fld	QWORD PTR [esi]

; 161  :      }
; 162  :      memcpy((char*)y,(char*)t,SDIM*sizeof(REAL));

	push	ebx
	fmulp	ST(2), ST(0)
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	push	esi
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi+8]
	fmul	QWORD PTR _rotmat+24
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _t$[ebp+8]
	call	_memcpy
	add	esp, 12					; 0000000cH
	dec	DWORD PTR tv394[ebp]
	jne	SHORT $LL11@rot_wrap
$LN50@rot_wrap:
	pop	edi
$LN9@rot_wrap:

; 163  :    }
; 164  :  } // end rot_wrap()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_rot_wrap ENDP
_TEXT	ENDS
PUBLIC	_rot_compose
; Function compile flags: /Ogtp
;	COMDAT _rot_compose
_TEXT	SEGMENT
_wrap1$ = 8						; size = 4
_wrap2$ = 12						; size = 4
_rot_compose PROC					; COMDAT

; 177  :  {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 178  :    rot_new_order();

	call	_rot_new_order

; 179  :    return stdwrap(wrap1 + wrap2);

	mov	eax, DWORD PTR _wrap2$[ebp]
	add	eax, DWORD PTR _wrap1$[ebp]
	mov	edi, DWORD PTR _rotorder
	jns	SHORT $LN3@rot_compos
	lea	ecx, DWORD PTR [edi-1]
	imul	ecx, eax
	neg	ecx
	jmp	SHORT $LN4@rot_compos
$LN3@rot_compos:
	mov	ecx, eax
$LN4@rot_compos:
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	lea	eax, DWORD PTR [esi+ecx]
	cdq
	idiv	edi
	pop	edi
	mov	eax, edx
	sub	eax, esi
	pop	esi

; 180  :  } // end rot_compose()

	pop	ebp
	ret	0
_rot_compose ENDP
_TEXT	ENDS
PUBLIC	_rot_inverse
; Function compile flags: /Ogtp
;	COMDAT _rot_inverse
_TEXT	SEGMENT
_wrap$ = 8						; size = 4
_rot_inverse PROC					; COMDAT

; 192  :  {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 193  :    rot_new_order();

	call	_rot_new_order

; 194  :    return stdwrap(-wrap);

	mov	eax, DWORD PTR _wrap$[ebp]
	mov	edi, DWORD PTR _rotorder
	mov	ecx, eax
	neg	ecx
	jns	SHORT $LN3@rot_invers
	lea	ecx, DWORD PTR [edi-1]
	imul	ecx, eax
$LN3@rot_invers:
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	lea	eax, DWORD PTR [esi+ecx]
	cdq
	idiv	edi
	pop	edi
	mov	eax, edx
	sub	eax, esi
	pop	esi

; 195  :  } // end rot_inverse()

	pop	ebp
	ret	0
_rot_inverse ENDP
_TEXT	ENDS
PUBLIC	_rot_form_pullback
; Function compile flags: /Ogtp
;	COMDAT _rot_form_pullback
_TEXT	SEGMENT
_x$ = 8							; size = 4
_xform$ = 12						; size = 4
_yform$ = 16						; size = 4
_wrap$ = 20						; size = 4
_rot_form_pullback PROC					; COMDAT

; 213  :  {

	push	ebp
	mov	ebp, esp

; 214  :    rot_new_order();

	call	_rot_new_order

; 215  :    rot_wrap(yform,xform,-wrap);

	mov	eax, DWORD PTR _wrap$[ebp]
	mov	ecx, DWORD PTR _xform$[ebp]
	mov	edx, DWORD PTR _yform$[ebp]
	neg	eax
	push	eax
	push	ecx
	push	edx
	call	_rot_wrap
	add	esp, 12					; 0000000cH

; 216  :  } // end rot_form_pullback()

	pop	ebp
	ret	0
_rot_form_pullback ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@LJBJNLKE@Can?8t?5use?5flip_rotations?5with?5od@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_frot_wrap
EXTRN	_kb_error:PROC
;	COMDAT ??_C@_0CJ@LJBJNLKE@Can?8t?5use?5flip_rotations?5with?5od@
CONST	SEGMENT
??_C@_0CJ@LJBJNLKE@Can?8t?5use?5flip_rotations?5with?5od@ DB 'Can''t use '
	DB	'flip_rotations with odd order', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _frot_wrap
_TEXT	SEGMENT
tv655 = -60						; size = 4
tv404 = -56						; size = 4
_t$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_wrap$ = 16						; size = 4
_frot_wrap PROC						; COMDAT

; 237  :  {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 238  :    int i,j,k;
; 239  :    REAL t[MAXCOORD];
; 240  : 
; 241  :    /* copy original coordinates */
; 242  :    memcpy((char*)y,(char*)x,SDIM*sizeof(REAL));

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR _x$[ebp]
	push	esi
	mov	esi, DWORD PTR _y$[ebp]
	push	edi
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	push	eax
	push	esi
	call	_memcpy

; 243  :    if (!wrap) return;  /* 0 should always be used to encode the identity */

	mov	edi, DWORD PTR _wrap$[ebp]
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	$LN10@frot_wrap

; 244  : 
; 245  :    rot_new_order();  /* check that we're using the right order */

	call	_rot_new_order

; 246  :    if (rotorder&1)

	mov	eax, DWORD PTR _rotorder
	test	al, 1
	je	SHORT $LN14@frot_wrap

; 247  :      kb_error(1618,"Can't use flip_rotations with odd order\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CJ@LJBJNLKE@Can?8t?5use?5flip_rotations?5with?5od@
	push	1618					; 00000652H
	call	_kb_error
	mov	eax, DWORD PTR _rotorder
	add	esp, 12					; 0000000cH
$LN14@frot_wrap:

; 248  : 
; 249  :    if ( 0 == (wrap = stdwrap(wrap))) return;  /* adjust to have small abs value */

	test	edi, edi
	jns	SHORT $LN18@frot_wrap
	lea	ecx, DWORD PTR [eax-1]
	imul	ecx, edi
	neg	ecx
	jmp	SHORT $LN19@frot_wrap
$LN18@frot_wrap:
	mov	ecx, edi
$LN19@frot_wrap:
	cdq
	sub	eax, edx
	push	ebx
	mov	ebx, eax
	sar	ebx, 1
	lea	eax, DWORD PTR [ebx+ecx]
	cdq
	idiv	DWORD PTR _rotorder
	mov	edi, edx
	sub	edi, ebx
	je	$LN52@frot_wrap

; 250  : 
; 251  :    /* adjust for wrapping */
; 252  :    for ( i = 0 ; i < (wrap>0?wrap:-wrap); i++ )

	mov	eax, edi
	cdq
	xor	eax, edx
	sub	eax, edx
	test	eax, eax
	jle	$LN52@frot_wrap
	mov	ecx, edi
	and	ecx, 1
	mov	DWORD PTR tv655[ebp], ecx
	mov	DWORD PTR tv404[ebp], eax
	npad	8
$LL12@frot_wrap:

; 253  :    {
; 254  :      memcpy((char*)t,(char*)y,SDIM*sizeof(REAL));

	mov	ebx, DWORD PTR _web+616
	add	ebx, ebx
	add	ebx, ebx
	add	ebx, ebx
	push	ebx
	lea	eax, DWORD PTR _t$[ebp]
	push	esi
	push	eax
	call	_memcpy

; 261  :          t[j] += y[k]*rotmat[j][k];

	fld	QWORD PTR [esi]
	fmul	QWORD PTR _rotmat
	add	esp, 12					; 0000000cH
	fldz
	fadd	ST(1), ST(0)
	fld	QWORD PTR _rotmat+16
	fld	QWORD PTR _rotmat+8
	fld	QWORD PTR [esi+8]
	test	edi, edi
	jle	SHORT $LN31@frot_wrap
	fmul	ST(0), ST(1)

; 262  :        else

	jmp	SHORT $LN65@frot_wrap
$LN31@frot_wrap:

; 263  :          t[j] += y[k]*rotmat[k][j];

	fmul	ST(0), ST(2)
$LN65@frot_wrap:
	faddp	ST(4), ST(0)
	fxch	ST(3)
	fstp	QWORD PTR _t$[ebp]
	test	edi, edi
	jle	SHORT $LN59@frot_wrap

; 255  :      /* copy in all coords, then adjust x,y */
; 256  :      for (j=0; j<2; j++)
; 257  :      {
; 258  :        t[j]=0.;
; 259  :        for (k=0;k<2;k++)
; 260  :        if (wrap>0)

	fstp	ST(2)

; 262  :        else

	jmp	SHORT $LN66@frot_wrap
$LN59@frot_wrap:

; 255  :      /* copy in all coords, then adjust x,y */
; 256  :      for (j=0; j<2; j++)
; 257  :      {
; 258  :        t[j]=0.;
; 259  :        for (k=0;k<2;k++)
; 260  :        if (wrap>0)

	fstp	ST(0)
$LN66@frot_wrap:

; 263  :          t[j] += y[k]*rotmat[k][j];

	fld	QWORD PTR [esi]

; 264  :      }
; 265  :      memcpy((char*)y,(char*)t,SDIM*sizeof(REAL));

	push	ebx
	fmulp	ST(2), ST(0)
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	push	esi
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi+8]
	fmul	QWORD PTR _rotmat+24
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _t$[ebp+8]
	call	_memcpy
	add	esp, 12					; 0000000cH

; 266  :      if (wrap&1) y[2] = -y[2]; /* the flip */

	cmp	DWORD PTR tv655[ebp], 0
	je	SHORT $LN11@frot_wrap
	fld	QWORD PTR [esi+16]
	fchs
	fstp	QWORD PTR [esi+16]
$LN11@frot_wrap:

; 250  : 
; 251  :    /* adjust for wrapping */
; 252  :    for ( i = 0 ; i < (wrap>0?wrap:-wrap); i++ )

	dec	DWORD PTR tv404[ebp]
	jne	$LL12@frot_wrap
$LN52@frot_wrap:
	pop	ebx
$LN10@frot_wrap:

; 267  :    }
; 268  :  } // end frot_wrap()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_frot_wrap ENDP
_TEXT	ENDS
PUBLIC	_frot_form_pullback
; Function compile flags: /Ogtp
;	COMDAT _frot_form_pullback
_TEXT	SEGMENT
_x$ = 8							; size = 4
_xform$ = 12						; size = 4
_yform$ = 16						; size = 4
_wrap$ = 20						; size = 4
_frot_form_pullback PROC				; COMDAT

; 286  :  {

	push	ebp
	mov	ebp, esp

; 287  :    frot_wrap(yform,xform,-wrap);

	mov	eax, DWORD PTR _wrap$[ebp]
	mov	ecx, DWORD PTR _xform$[ebp]
	mov	edx, DWORD PTR _yform$[ebp]
	neg	eax
	push	eax
	push	ecx
	push	edx
	call	_frot_wrap
	add	esp, 12					; 0000000cH

; 288  :  } // end frot_form_pullback()

	pop	ebp
	ret	0
_frot_form_pullback ENDP
_TEXT	ENDS
PUBLIC	_pgcube_wrap
; Function compile flags: /Ogtp
;	COMDAT _pgcube_wrap
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
tv482 = 16						; size = 4
tv478 = 16						; size = 4
tv474 = 16						; size = 4
_wrap$ = 16						; size = 4
_pgcube_wrap PROC					; COMDAT

; 320  :  {

	push	ebp
	mov	ebp, esp

; 321  :    int i,j;
; 322  :    REAL yy;
; 323  : 
; 324  :    /* copy original coordinates */
; 325  :    memcpy((char*)y,(char*)x,SDIM*sizeof(REAL));

	mov	eax, DWORD PTR _web+616
	push	esi
	mov	esi, DWORD PTR _y$[ebp]
	push	edi
	mov	edi, DWORD PTR _x$[ebp]
	lea	ecx, DWORD PTR [eax*8]
	push	ecx
	push	edi
	push	esi
	call	_memcpy

; 326  :    if (!wrap) return;  /* 0 should always be used to encode the identity */

	mov	eax, DWORD PTR _wrap$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN1@pgcube_wra

; 327  : 
; 328  :    /* adjust for wrapping */
; 329  :    for ( i = 0 ; i < 3; i++, wrap >>= 1 )
; 330  :        y[i] = x[i] * ((wrap&1)? -1:1);

	test	al, 1
	mov	edx, 0
	sete	dl
	sar	eax, 1
	test	al, 1
	mov	ecx, 0
	sete	cl
	sar	eax, 1
	test	al, 1
	lea	edx, DWORD PTR [edx+edx-1]
	mov	DWORD PTR tv482[ebp], edx
	fild	DWORD PTR tv482[ebp]
	mov	edx, 0
	sete	dl
	lea	ecx, DWORD PTR [ecx+ecx-1]
	fmul	QWORD PTR [edi]
	mov	DWORD PTR tv478[ebp], ecx
	sar	eax, 1

; 331  :    for ( j = 0 ; j < (wrap&3); j++ )

	mov	ecx, eax
	fstp	QWORD PTR [esi]
	and	ecx, 3
	fild	DWORD PTR tv478[ebp]
	lea	edx, DWORD PTR [edx+edx-1]
	mov	DWORD PTR tv474[ebp], edx
	fmul	QWORD PTR [edi+8]
	fstp	QWORD PTR [esi+8]
	fild	DWORD PTR tv474[ebp]
	fmul	QWORD PTR [edi+16]
	xor	edi, edi
	fstp	QWORD PTR [esi+16]
	cmp	ecx, 4
	jl	SHORT $LC20@pgcube_wra

; 327  : 
; 328  :    /* adjust for wrapping */
; 329  :    for ( i = 0 ; i < 3; i++, wrap >>= 1 )
; 330  :        y[i] = x[i] * ((wrap&1)? -1:1);

	lea	edx, DWORD PTR [ecx-4]
	shr	edx, 2
	inc	edx
	lea	edi, DWORD PTR [edx*4]
	npad	7

; 331  :    for ( j = 0 ; j < (wrap&3); j++ )

$LL21@pgcube_wra:

; 332  :    {
; 333  :        yy = y[2]; y[2] = y[1]; y[1] = y[0]; y[0] = yy;

	dec	edx
	fld	QWORD PTR [esi+16]
	fld	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi+16]
	fld	QWORD PTR [esi]
	fstp	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi]
	fld	QWORD PTR [esi+16]
	fld	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi+16]
	fld	QWORD PTR [esi]
	fstp	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi]
	fld	QWORD PTR [esi+16]
	fld	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi+16]
	fld	QWORD PTR [esi]
	fstp	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi]
	fld	QWORD PTR [esi+16]
	fld	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi+16]
	fld	QWORD PTR [esi]
	fstp	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi]
	jne	SHORT $LL21@pgcube_wra
$LC20@pgcube_wra:

; 331  :    for ( j = 0 ; j < (wrap&3); j++ )

	cmp	edi, ecx
	jge	SHORT $LN19@pgcube_wra
	fld	QWORD PTR [esi+16]
	sub	ecx, edi
	fld	QWORD PTR [esi+8]
	fld	QWORD PTR [esi]
	jmp	SHORT $LC4@pgcube_wra
$LN24@pgcube_wra:
	fxch	ST(1)
	fxch	ST(2)
$LC4@pgcube_wra:
	dec	ecx
	jne	SHORT $LN24@pgcube_wra
	fxch	ST(2)
	fstp	QWORD PTR [esi]
	fxch	ST(1)
	fstp	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi+16]
$LN19@pgcube_wra:

; 334  :    }
; 335  :    wrap >>= 2;
; 336  :    if (wrap&1)

	test	al, 4
	je	SHORT $LN1@pgcube_wra

; 337  :    {
; 338  :        yy = y[1]; y[1] = y[0]; y[0] = yy;

	fld	QWORD PTR [esi+8]
	fld	QWORD PTR [esi]
	fstp	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi]
$LN1@pgcube_wra:
	pop	edi
	pop	esi

; 339  :    }
; 340  :  } // end pgcube_wrap()

	pop	ebp
	ret	0
_pgcube_wrap ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_pgcube_permutesigns
; Function compile flags: /Ogtp
;	COMDAT _pgcube_permutesigns
_TEXT	SEGMENT
_y$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_signs$ = 8						; size = 4
_perm$ = 12						; size = 4
_pgcube_permutesigns PROC				; COMDAT

; 355  :  { int retval;

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 356  :    REAL  y[3];
; 357  :    pgcube_wrap(xxx,y,pgcube_wr(signs,perm));

	mov	eax, DWORD PTR _perm$[ebp]
	mov	ecx, DWORD PTR _signs$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	push	OFFSET _xxx
	call	_pgcube_wrap

; 358  :    retval = (y[0]<0.0) + ((y[1]<0.0) << 1) + ((y[2]<0.0) << 2);

	fldz
	fcom	QWORD PTR _y$[ebp]
	add	esp, 12					; 0000000cH
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN5@pgcube_per
	mov	edx, 1
	jmp	SHORT $LN6@pgcube_per
$LN5@pgcube_per:
	xor	edx, edx
$LN6@pgcube_per:
	fcom	QWORD PTR _y$[ebp+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@pgcube_per
	mov	ecx, 1
	jmp	SHORT $LN4@pgcube_per
$LN3@pgcube_per:
	xor	ecx, ecx
$LN4@pgcube_per:
	fcomp	QWORD PTR _y$[ebp+16]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN7@pgcube_per
	mov	eax, 1

; 359  :    return retval;

	lea	ecx, DWORD PTR [ecx+eax*2]
	lea	eax, DWORD PTR [edx+ecx*2]

; 360  :  } // end pgcube_permutesigns()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@pgcube_per:

; 358  :    retval = (y[0]<0.0) + ((y[1]<0.0) << 1) + ((y[2]<0.0) << 2);

	xor	eax, eax

; 359  :    return retval;

	lea	ecx, DWORD PTR [ecx+eax*2]
	lea	eax, DWORD PTR [edx+ecx*2]

; 360  :  } // end pgcube_permutesigns()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pgcube_permutesigns ENDP
_TEXT	ENDS
PUBLIC	_pgcube_compperm
; Function compile flags: /Ogtp
;	COMDAT _pgcube_compperm
_TEXT	SEGMENT
_perm1$ = 8						; size = 4
_perm2$ = 12						; size = 4
_pgcube_compperm PROC					; COMDAT

; 374  :  {

	push	ebp
	mov	ebp, esp

; 375  :    int flip1,flip2,rot;
; 376  :    flip1=perm1&4; flip2=perm2&4;

	mov	ecx, DWORD PTR _perm1$[ebp]
	mov	edx, DWORD PTR _perm2$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, edx
	and	esi, 4
	and	edi, 4

; 377  :    rot = (perm2&3) + (flip2?-1:1)*(perm1&3);

	mov	eax, 0
	sete	al
	and	ecx, 3
	and	edx, 3
	lea	eax, DWORD PTR [eax+eax-1]
	imul	ecx, eax
	add	ecx, edx

; 378  :    rot = (rot<0)? rot+3 : ( (rot>2)? rot-3:rot );

	jns	SHORT $LN5@pgcube_com

; 379  :    return (flip1^flip2) + rot;

	mov	eax, edi
	xor	eax, esi
	add	ecx, 3
	pop	edi
	add	eax, ecx
	pop	esi

; 380  :  } // end pgcube_compperm()

	pop	ebp
	ret	0
$LN5@pgcube_com:

; 378  :    rot = (rot<0)? rot+3 : ( (rot>2)? rot-3:rot );

	cmp	ecx, 2
	jle	SHORT $LN3@pgcube_com
	sub	ecx, 3
$LN3@pgcube_com:

; 379  :    return (flip1^flip2) + rot;

	mov	eax, edi
	xor	eax, esi
	pop	edi
	add	eax, ecx
	pop	esi

; 380  :  } // end pgcube_compperm()

	pop	ebp
	ret	0
_pgcube_compperm ENDP
_TEXT	ENDS
PUBLIC	_pgcube_compose
; Function compile flags: /Ogtp
;	COMDAT _pgcube_compose
_TEXT	SEGMENT
_comp$ = 8						; size = 4
_wrap1$ = 8						; size = 4
_wrap2$ = 12						; size = 4
_pgcube_compose PROC					; COMDAT

; 394  :  {

	push	ebp
	mov	ebp, esp

; 395  :    int sgns1,sgns2,perm1,perm2,comp,inv,xxx,yyy;
; 396  :    sgns1 = pgcube_sgns(wrap1); perm1 = pgcube_perm(wrap1);

	mov	eax, DWORD PTR _wrap1$[ebp]
	push	ebx
	push	esi
	mov	esi, eax
	sar	eax, 3
	and	eax, 7
	mov	ebx, eax

; 397  :    sgns2 = pgcube_sgns(wrap2); perm2 = pgcube_perm(wrap2);

	mov	eax, DWORD PTR _wrap2$[ebp]
	push	edi
	mov	edi, eax

; 398  :    comp = pgcube_compperm(perm1,perm2); 

	sar	eax, 3
	and	eax, 7
	push	eax
	push	ebx
	and	esi, 7
	and	edi, 7
	call	_pgcube_compperm
	add	esp, 8
	mov	DWORD PTR _comp$[ebp], eax

; 399  :    inv = pgcube_invperm(perm1);

	test	bl, 4
	jne	SHORT $LN3@pgcube_com@2
	test	ebx, ebx
	je	SHORT $LN3@pgcube_com@2
	mov	eax, 3
	sub	eax, ebx
	jmp	SHORT $LN4@pgcube_com@2
$LN3@pgcube_com@2:
	mov	eax, ebx
$LN4@pgcube_com@2:

; 400  :    xxx =  pgcube_permutesigns(sgns2,inv);

	push	eax
	push	edi
	call	_pgcube_permutesigns

; 401  :    yyy = pgcube_wr(sgns1 ^ xxx,comp);

	mov	ecx, DWORD PTR _comp$[ebp]
	add	esp, 8
	pop	edi
	xor	eax, esi
	pop	esi
	lea	eax, DWORD PTR [eax+ecx*8]
	pop	ebx

; 402  :    return yyy;
; 403  :  } // end pgcube_compose()

	pop	ebp
	ret	0
_pgcube_compose ENDP
_TEXT	ENDS
PUBLIC	_pgcube_inverse
; Function compile flags: /Ogtp
;	COMDAT _pgcube_inverse
_TEXT	SEGMENT
_wrap$ = 8						; size = 4
_pgcube_inverse PROC					; COMDAT

; 414  :  {

	push	ebp
	mov	ebp, esp

; 415  :    int sgns, perm;
; 416  :    WRAPTYPE result;
; 417  :    
; 418  :    sgns = pgcube_sgns(wrap); perm = pgcube_perm(wrap);

	mov	eax, DWORD PTR _wrap$[ebp]
	mov	ecx, eax
	sar	eax, 3
	and	eax, 7
	and	ecx, 7
	push	esi

; 419  :    result = pgcube_wr(pgcube_permutesigns(sgns,perm),
; 420  :             pgcube_invperm(perm));

	test	al, 4
	jne	SHORT $LN3@pgcube_inv
	test	eax, eax
	je	SHORT $LN3@pgcube_inv
	push	eax
	mov	esi, 3
	push	ecx
	sub	esi, eax
	call	_pgcube_permutesigns
	add	esp, 8
	lea	eax, DWORD PTR [eax+esi*8]
	pop	esi

; 421  :    return result;
; 422  :  } // end pgcube_inverse()

	pop	ebp
	ret	0
$LN3@pgcube_inv:

; 419  :    result = pgcube_wr(pgcube_permutesigns(sgns,perm),
; 420  :             pgcube_invperm(perm));

	push	eax
	push	ecx
	mov	esi, eax
	call	_pgcube_permutesigns
	add	esp, 8
	lea	eax, DWORD PTR [eax+esi*8]
	pop	esi

; 421  :    return result;
; 422  :  } // end pgcube_inverse()

	pop	ebp
	ret	0
_pgcube_inverse ENDP
_TEXT	ENDS
PUBLIC	_pgcube_form_pullback
; Function compile flags: /Ogtp
;	COMDAT _pgcube_form_pullback
_TEXT	SEGMENT
_x$ = 8							; size = 4
_xform$ = 12						; size = 4
_yform$ = 16						; size = 4
_wrap$ = 20						; size = 4
_pgcube_form_pullback PROC				; COMDAT

; 441  :  {

	push	ebp
	mov	ebp, esp

; 442  :    pgcube_wrap(yform,xform,pgcube_inverse(wrap));

	mov	eax, DWORD PTR _wrap$[ebp]
	push	eax
	call	_pgcube_inverse
	mov	ecx, DWORD PTR _xform$[ebp]
	mov	edx, DWORD PTR _yform$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_pgcube_wrap
	add	esp, 16					; 00000010H

; 443  :  } // end pgcube_form_pullback()

	pop	ebp
	ret	0
_pgcube_form_pullback ENDP
_TEXT	ENDS
PUBLIC	_cubel_wrap
; Function compile flags: /Ogtp
;	COMDAT _cubel_wrap
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$89333 = 16						; size = 4
_wrap$ = 16						; size = 4
_cubel_wrap PROC					; COMDAT

; 477  :  {

	push	ebp
	mov	ebp, esp

; 478  :    int i,j;
; 479  : 
; 480  :    pgcube_wrap(x,y,cubel_pg(wrap)); 

	mov	ecx, DWORD PTR _x$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _y$[ebp]
	push	edi
	mov	edi, DWORD PTR _wrap$[ebp]
	mov	eax, edi
	and	eax, 63					; 0000003fH
	push	eax
	push	esi
	push	ecx
	call	_pgcube_wrap
	add	esp, 12					; 0000000cH

; 481  :    wrap = cubel_tr(wrap);

	sar	edi, 6
	xor	ecx, ecx
	mov	edx, esi
$LL19@cubel_wrap:

; 483  :    { int w = WRAPNUM(wrap & WRAPMASK);

	mov	eax, edi
	and	eax, 31					; 0000001fH
	cmp	eax, 16					; 00000010H
	jle	SHORT $LN11@cubel_wrap
	add	eax, -32				; ffffffe0H
$LN11@cubel_wrap:

; 484  :      if ( web.torus_period )

	cmp	DWORD PTR _web+1608, 0
	mov	DWORD PTR _w$89333[ebp], eax
	je	SHORT $LN5@cubel_wrap

; 485  :        for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN7@cubel_wrap
	fild	DWORD PTR _w$89333[ebp]
$LN17@cubel_wrap:

; 486  :          y[j] += w*web.torus_period[i][j];

	mov	ebx, DWORD PTR _web+1608
	mov	ebx, DWORD PTR [ecx+ebx]
	fld	QWORD PTR [ebx+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN17@cubel_wrap

; 485  :        for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)

; 487  :      else

	jmp	SHORT $LN7@cubel_wrap
$LN5@cubel_wrap:

; 488  :        y[i] += w;

	fild	DWORD PTR _w$89333[ebp]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
$LN7@cubel_wrap:

; 482  :    for (i=0; i<3; i++, wrap >>= TWRAPBITS) 

	add	ecx, 4
	add	edx, 8
	sar	edi, 6
	cmp	ecx, 12					; 0000000cH
	jl	SHORT $LL19@cubel_wrap
	pop	edi
	pop	esi
	pop	ebx

; 489  :    }
; 490  :  } // end cubel_wrap()

	pop	ebp
	ret	0
_cubel_wrap ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_pg_tr_compose
; Function compile flags: /Ogtp
;	COMDAT _pg_tr_compose
_TEXT	SEGMENT
tv74 = -56						; size = 4
_y$ = -52						; size = 24
_x$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_pg$ = 8						; size = 4
_tr$ = 12						; size = 4
_pg_tr_compose PROC					; COMDAT

; 505  :  {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 506  :    WRAPTYPE wrap=0;
; 507  :    int i;
; 508  :    REAL x[3],y[3];
; 509  :    for (i=0; i<3; i++, tr >>= TWRAPBITS) {
; 510  :      x[i] = WRAPNUM(tr & WRAPMASK);

	mov	eax, DWORD PTR _tr$[ebp]
	push	esi
	mov	ecx, eax
	push	edi
	and	ecx, 31					; 0000001fH
	xor	edi, edi
	cmp	ecx, 16					; 00000010H
	jle	SHORT $LN9@pg_tr_comp
	add	ecx, -32				; ffffffe0H
$LN9@pg_tr_comp:
	mov	DWORD PTR tv74[ebp], ecx
	fild	DWORD PTR tv74[ebp]
	sar	eax, 6
	mov	ecx, eax
	and	ecx, 31					; 0000001fH
	fstp	QWORD PTR _x$[ebp]
	cmp	ecx, 16					; 00000010H
	jle	SHORT $LN20@pg_tr_comp
	add	ecx, -32				; ffffffe0H
$LN20@pg_tr_comp:
	mov	DWORD PTR tv74[ebp], ecx
	fild	DWORD PTR tv74[ebp]
	sar	eax, 6
	and	eax, 31					; 0000001fH
	fstp	QWORD PTR _x$[ebp+8]
	cmp	eax, 16					; 00000010H
	jle	SHORT $LN23@pg_tr_comp
	add	eax, -32				; ffffffe0H
$LN23@pg_tr_comp:
	mov	DWORD PTR tv74[ebp], eax

; 511  :    }
; 512  :    pgcube_wrap(x,y,pg);

	mov	eax, DWORD PTR _pg$[ebp]
	fild	DWORD PTR tv74[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	fstp	QWORD PTR _x$[ebp+16]
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_pgcube_wrap
	add	esp, 12					; 0000000cH

; 513  :    for (i=2; i>=0; i--) {

	mov	esi, 2
$LL3@pg_tr_comp:

; 514  :      wrap = (wrap<<TWRAPBITS)+(WRAPMASK&(int)y[i]);

	fld	QWORD PTR _y$[ebp+esi*8]
	call	__ftol2_sse
	and	eax, 31					; 0000001fH
	shl	edi, 6
	add	edi, eax
	dec	esi
	jns	SHORT $LL3@pg_tr_comp

; 515  :    }
; 516  :    return wrap;
; 517  :  } // end pg_tr_compose()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, edi
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pg_tr_compose ENDP
_TEXT	ENDS
PUBLIC	_cubel_compose
; Function compile flags: /Ogtp
;	COMDAT _cubel_compose
_TEXT	SEGMENT
_wrap1$ = 8						; size = 4
_wrap2$ = 12						; size = 4
_cubel_compose PROC					; COMDAT

; 531  :  {

	push	ebp
	mov	ebp, esp

; 532  :    int pg1, pg2, tr1, tr2;
; 533  :    pg1 = cubel_pg(wrap1); tr1 = cubel_tr(wrap1);
; 534  :    pg2 = cubel_pg(wrap2); tr2 = cubel_tr(wrap2);

	mov	eax, DWORD PTR _wrap2$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _wrap1$[ebp]
	push	esi
	push	edi
	sar	eax, 6
	mov	edi, ebx

; 535  :    return cubel_wr( pg_tr_compose(pg1,tr2)+tr1,
; 536  :            pgcube_compose(pg1,pg2) ) ;

	push	eax
	and	edi, 63					; 0000003fH
	push	edi
	call	_pg_tr_compose
	sar	ebx, 6
	lea	esi, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR _wrap2$[ebp]
	and	eax, 63					; 0000003fH
	push	eax
	shl	esi, 6
	push	edi
	and	esi, -545392704				; df7df7c0H
	call	_pgcube_compose
	add	esp, 16					; 00000010H
	pop	edi
	add	eax, esi
	pop	esi
	pop	ebx

; 537  :  } // end cubel_compose()

	pop	ebp
	ret	0
_cubel_compose ENDP
_TEXT	ENDS
PUBLIC	_cubel_inverse
EXTRN	_torus_inverse:PROC
; Function compile flags: /Ogtp
;	COMDAT _cubel_inverse
_TEXT	SEGMENT
_wrap$ = 8						; size = 4
_cubel_inverse PROC					; COMDAT

; 548  :  {

	push	ebp
	mov	ebp, esp
	push	esi

; 549  :    WRAPTYPE pg = pgcube_inverse(cubel_pg(wrap));

	mov	esi, DWORD PTR _wrap$[ebp]
	mov	eax, esi
	and	eax, 63					; 0000003fH
	push	edi
	push	eax
	call	_pgcube_inverse

; 550  :    WRAPTYPE tr = cubel_tr(wrap);

	sar	esi, 6
	mov	edi, eax

; 551  :    return cubel_wr( torus_inverse(pg_tr_compose(pg,tr)), pg );

	push	esi
	push	edi
	call	_pg_tr_compose
	push	eax
	call	_torus_inverse
	and	eax, -8521761				; ff7df7dfH
	add	esp, 16					; 00000010H
	shl	eax, 6
	add	eax, edi
	pop	edi
	pop	esi

; 552  :  } // end cubel_inverse()

	pop	ebp
	ret	0
_cubel_inverse ENDP
_TEXT	ENDS
PUBLIC	_cubel_form_pullback
; Function compile flags: /Ogtp
;	COMDAT _cubel_form_pullback
_TEXT	SEGMENT
_x$ = 8							; size = 4
_xform$ = 12						; size = 4
_yform$ = 16						; size = 4
_wrap$ = 20						; size = 4
_cubel_form_pullback PROC				; COMDAT

; 568  :  {

	push	ebp
	mov	ebp, esp

; 569  :    pgcube_wrap(yform,xform,pgcube_inverse(cubel_pg(wrap)));

	mov	eax, DWORD PTR _wrap$[ebp]
	and	eax, 63					; 0000003fH
	push	eax
	call	_pgcube_inverse
	mov	ecx, DWORD PTR _xform$[ebp]
	mov	edx, DWORD PTR _yform$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_pgcube_wrap
	add	esp, 16					; 00000010H

; 570  :  } // end cubel_form_pullback()

	pop	ebp
	ret	0
_cubel_form_pullback ENDP
_TEXT	ENDS
PUBLIC	_xyz_wrap
; Function compile flags: /Ogtp
;	COMDAT _xyz_wrap
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_wrap$ = 16						; size = 4
_xyz_wrap PROC						; COMDAT

; 584  :  {

	push	ebp
	mov	ebp, esp

; 585  :    memcpy((char*)y,(char*)x,SDIM*sizeof(REAL));

	mov	eax, DWORD PTR _web+616
	push	esi
	mov	esi, DWORD PTR _x$[ebp]
	push	edi
	mov	edi, DWORD PTR _y$[ebp]
	lea	ecx, DWORD PTR [eax*8]
	push	ecx
	push	esi
	push	edi
	call	_memcpy

; 586  :    if ( 0 == (wrap = xstdwrap(wrap))) return;

	mov	eax, DWORD PTR _wrap$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jns	SHORT $LN6@xyz_wrap
	neg	eax
	add	eax, eax
$LN6@xyz_wrap:
	inc	eax
	cdq
	mov	ecx, 3
	idiv	ecx
	dec	edx
	je	SHORT $LN1@xyz_wrap

; 587  : 
; 588  :    if (wrap==-1) y[0]=x[1], y[1]=x[2], y[2]=x[0];

	cmp	edx, -1
	jne	SHORT $LN2@xyz_wrap
	fld	QWORD PTR [esi+8]
	fstp	QWORD PTR [edi]
	fld	QWORD PTR [esi+16]
	fstp	QWORD PTR [edi+8]
	fld	QWORD PTR [esi]

; 589  :    else /*wrap 1*/ y[0]=x[2], y[1]=x[0], y[2]=x[1];

	fstp	QWORD PTR [edi+16]
	pop	edi
	pop	esi

; 590  :  } // end xyz_wrap()

	pop	ebp
	ret	0
$LN2@xyz_wrap:

; 589  :    else /*wrap 1*/ y[0]=x[2], y[1]=x[0], y[2]=x[1];

	fld	QWORD PTR [esi+16]
	fstp	QWORD PTR [edi]
	fld	QWORD PTR [esi]
	fstp	QWORD PTR [edi+8]
	fld	QWORD PTR [esi+8]
	fstp	QWORD PTR [edi+16]
$LN1@xyz_wrap:
	pop	edi
	pop	esi

; 590  :  } // end xyz_wrap()

	pop	ebp
	ret	0
_xyz_wrap ENDP
_TEXT	ENDS
PUBLIC	_xyz_compose
; Function compile flags: /Ogtp
;	COMDAT _xyz_compose
_TEXT	SEGMENT
_wrap1$ = 8						; size = 4
_wrap2$ = 12						; size = 4
_xyz_compose PROC					; COMDAT

; 593  :  { return xstdwrap(wrap1 + wrap2); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _wrap2$[ebp]
	add	eax, DWORD PTR _wrap1$[ebp]
	jns	SHORT $LN3@xyz_compos
	neg	eax
	add	eax, eax
$LN3@xyz_compos:
	inc	eax
	cdq
	mov	ecx, 3
	idiv	ecx
	lea	eax, DWORD PTR [edx-1]
	pop	ebp
	ret	0
_xyz_compose ENDP
_TEXT	ENDS
PUBLIC	_xyz_inverse
; Function compile flags: /Ogtp
;	COMDAT _xyz_inverse
_TEXT	SEGMENT
_wrap$ = 8						; size = 4
_xyz_inverse PROC					; COMDAT

; 596  :  { return xstdwrap(-wrap); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _wrap$[ebp]
	mov	eax, ecx
	neg	eax
	jns	SHORT $LN3@xyz_invers
	lea	eax, DWORD PTR [ecx+ecx]
$LN3@xyz_invers:
	inc	eax
	cdq
	mov	ecx, 3
	idiv	ecx
	lea	eax, DWORD PTR [edx-1]
	pop	ebp
	ret	0
_xyz_inverse ENDP
_TEXT	ENDS
PUBLIC	_xyz_form_pullback
; Function compile flags: /Ogtp
;	COMDAT _xyz_form_pullback
_TEXT	SEGMENT
_x$ = 8							; size = 4
_xform$ = 12						; size = 4
_yform$ = 16						; size = 4
_wrap$ = 20						; size = 4
_xyz_form_pullback PROC					; COMDAT

; 601  :  { xyz_wrap(yform,xform,-wrap); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _wrap$[ebp]
	mov	ecx, DWORD PTR _xform$[ebp]
	mov	edx, DWORD PTR _yform$[ebp]
	neg	eax
	push	eax
	push	ecx
	push	edx
	call	_xyz_wrap
	add	esp, 12					; 0000000cH
	pop	ebp
	ret	0
_xyz_form_pullback ENDP
_TEXT	ENDS
PUBLIC	_central_wrap
; Function compile flags: /Ogtp
;	COMDAT _central_wrap
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_wrap$ = 16						; size = 4
_central_wrap PROC					; COMDAT

; 614  :  { int n;

	push	ebp
	mov	ebp, esp

; 615  :    for ( n = 0 ; n < SDIM ; n++ ) y[n] = wrap ? -x[n] : x[n];

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN1@central_wr
	mov	eax, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	push	esi
	mov	esi, DWORD PTR _wrap$[ebp]
	sub	edx, eax
	npad	7
$LL3@central_wr:
	fld	QWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN7@central_wr
	fchs
$LN7@central_wr:
	fstp	QWORD PTR [edx+eax]
	inc	ecx
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL3@central_wr
	pop	esi
$LN1@central_wr:

; 616  :  } // end central_wrap()

	pop	ebp
	ret	0
_central_wrap ENDP
_TEXT	ENDS
PUBLIC	_central_compose
; Function compile flags: /Ogtp
;	COMDAT _central_compose
_TEXT	SEGMENT
_wrap1$ = 8						; size = 4
_wrap2$ = 12						; size = 4
_central_compose PROC					; COMDAT

; 619  :  { return wrap1 ^ wrap2; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _wrap1$[ebp]
	xor	eax, DWORD PTR _wrap2$[ebp]
	pop	ebp
	ret	0
_central_compose ENDP
_TEXT	ENDS
PUBLIC	_central_inverse
; Function compile flags: /Ogtp
;	COMDAT _central_inverse
_TEXT	SEGMENT
_wrap$ = 8						; size = 4
_central_inverse PROC					; COMDAT

; 622  :  { return wrap; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _wrap$[ebp]
	pop	ebp
	ret	0
_central_inverse ENDP
_TEXT	ENDS
PUBLIC	_central_form_pullback
; Function compile flags: /Ogtp
;	COMDAT _central_form_pullback
_TEXT	SEGMENT
_x$ = 8							; size = 4
_xform$ = 12						; size = 4
_yform$ = 16						; size = 4
_wrap$ = 20						; size = 4
_central_form_pullback PROC				; COMDAT

; 627  :  { int n;

	push	ebp
	mov	ebp, esp

; 628  :    for ( n = 0 ; n < SDIM ; n++ ) xform[n] = wrap ? -yform[n] : yform[n];

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN1@central_fo
	mov	eax, DWORD PTR _yform$[ebp]
	mov	edx, DWORD PTR _xform$[ebp]
	push	esi
	mov	esi, DWORD PTR _wrap$[ebp]
	sub	edx, eax
	npad	7
$LL3@central_fo:
	fld	QWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN7@central_fo
	fchs
$LN7@central_fo:
	fstp	QWORD PTR [edx+eax]
	inc	ecx
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL3@central_fo
	pop	esi
$LN1@central_fo:

; 629  : 
; 630  :  } // end central_form_pullback()

	pop	ebp
	ret	0
_central_form_pullback ENDP
_TEXT	ENDS
PUBLIC	__real@4066800000000000
PUBLIC	__real@400921fb54442d18
PUBLIC	??_C@_0M@JDJEHNPL@screw_angle?$AA@		; `string'
PUBLIC	??_C@_0N@POBJBMDI@screw_height?$AA@		; `string'
PUBLIC	_screw_wrap
EXTRN	_reset_timestamp:DWORD
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT ??_C@_0M@JDJEHNPL@screw_angle?$AA@
CONST	SEGMENT
??_C@_0M@JDJEHNPL@screw_angle?$AA@ DB 'screw_angle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@POBJBMDI@screw_height?$AA@
CONST	SEGMENT
??_C@_0N@POBJBMDI@screw_height?$AA@ DB 'screw_height', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _screw_wrap
_TEXT	SEGMENT
_lift$ = -32						; size = 8
tv371 = -24						; size = 8
tv373 = -16						; size = 8
tv372 = -8						; size = 8
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_wrap$ = 16						; size = 4
_screw_wrap PROC					; COMDAT

; 651  :  { REAL angle,lift;

	push	ebp
	mov	ebp, esp

; 652  :    if ( screw_stamp < reset_timestamp )

	mov	eax, DWORD PTR _screw_stamp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	cmp	eax, DWORD PTR _reset_timestamp
	jge	$LN42@screw_wrap

; 653  :    { if ((lift_var = lookup_global(LIFTNAME)) < 0)

	push	OFFSET ??_C@_0N@POBJBMDI@screw_height?$AA@
	call	_lookup_global
	add	esp, 4
	mov	DWORD PTR _lift_var, eax
	mov	edi, 134217737				; 08000009H
	test	eax, eax
	jns	$LN43@screw_wrap

; 654  :      { lift_var = add_global(LIFTNAME);

	push	OFFSET ??_C@_0N@POBJBMDI@screw_height?$AA@
	call	_add_global

; 655  :        globals(lift_var)->value.real = (REAL)LIFT;

	mov	edx, eax
	and	edx, -16777216				; ff000000H
	add	esp, 4
	mov	DWORD PTR _lift_var, eax
	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN6@screw_wrap
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN8@screw_wrap
	mov	esi, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [esi]
	jmp	SHORT $LN7@screw_wrap
$LN8@screw_wrap:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN6@screw_wrap
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN7@screw_wrap
$LN6@screw_wrap:
	mov	ecx, DWORD PTR _web+5652
	mov	esi, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [ecx+esi]
$LN7@screw_wrap:
	fld	QWORD PTR __real@4010000000000000
	fstp	QWORD PTR [ecx+64]

; 656  :        globals(lift_var)->flags = ORDINARY_PARAM | RECALC_PARAMETER | ALWAYS_RECALC;

	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN12@screw_wrap
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN14@screw_wrap
	mov	edx, DWORD PTR _localbase
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN13@screw_wrap
$LN14@screw_wrap:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN12@screw_wrap
	mov	ecx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN13@screw_wrap
$LN12@screw_wrap:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN13@screw_wrap:
	mov	DWORD PTR [eax+192], edi
$LN43@screw_wrap:

; 657  :      }
; 658  :      if ((twist_var = lookup_global(TWISTNAME)) < 0)

	push	OFFSET ??_C@_0M@JDJEHNPL@screw_angle?$AA@
	call	_lookup_global
	add	esp, 4
	mov	DWORD PTR _twist_var, eax
	test	eax, eax
	jns	$LN1@screw_wrap

; 659  :      { twist_var = add_global(TWISTNAME);

	push	OFFSET ??_C@_0M@JDJEHNPL@screw_angle?$AA@
	call	_add_global

; 660  :        globals(twist_var)->value.real = (REAL)TWIST;

	mov	esi, eax
	and	esi, -16777216				; ff000000H
	add	esp, 4
	mov	DWORD PTR _twist_var, eax
	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN18@screw_wrap
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN20@screw_wrap
	mov	ebx, DWORD PTR _localbase
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	mov	edx, ecx
	imul	edx, 224				; 000000e0H
	add	edx, DWORD PTR [ebx]
	jmp	SHORT $LN19@screw_wrap
$LN20@screw_wrap:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN18@screw_wrap
	mov	edx, DWORD PTR _web+5656
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN19@screw_wrap
$LN18@screw_wrap:
	mov	edx, DWORD PTR _web+5652
	mov	ebx, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [edx+ebx]
$LN19@screw_wrap:
	fldz
	fstp	QWORD PTR [edx+64]

; 661  :        globals(twist_var)->flags = ORDINARY_PARAM | RECALC_PARAMETER | ALWAYS_RECALC;

	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN24@screw_wrap
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN26@screw_wrap
	mov	edx, DWORD PTR _localbase
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN25@screw_wrap
$LN26@screw_wrap:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN24@screw_wrap
	mov	edx, DWORD PTR _web+5656
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN25@screw_wrap
$LN24@screw_wrap:
	mov	edx, DWORD PTR _web+5652
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
$LN25@screw_wrap:
	mov	DWORD PTR [ecx+192], edi
$LN1@screw_wrap:

; 662  :      }
; 663  :      screw_stamp = reset_timestamp;

	mov	ecx, DWORD PTR _reset_timestamp
	mov	DWORD PTR _screw_stamp, ecx
	jmp	SHORT $LN3@screw_wrap
$LN42@screw_wrap:
	mov	eax, DWORD PTR _twist_var
$LN3@screw_wrap:

; 664  :    }
; 665  :    lift = globals(lift_var)->value.real;

	mov	ecx, DWORD PTR _lift_var
	mov	esi, DWORD PTR _dymem
	mov	edi, DWORD PTR _web+5652
	mov	ebx, DWORD PTR _localbase
	mov	edx, ecx
	and	edx, -16777216				; ff000000H
	cmp	edx, 268435456				; 10000000H
	jne	SHORT $LN34@screw_wrap
	and	ecx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [edx+esi]
	jmp	SHORT $LN31@screw_wrap
$LN34@screw_wrap:
	and	ecx, 16777215				; 00ffffffH
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN32@screw_wrap
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [ebx]
	jmp	SHORT $LN31@screw_wrap
$LN32@screw_wrap:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN30@screw_wrap
	mov	edx, DWORD PTR _web+5656
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN31@screw_wrap
$LN30@screw_wrap:
	lea	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+esi]
$LN31@screw_wrap:
	fld	QWORD PTR [ecx+64]

; 666  :    angle = globals(twist_var)->value.real * M_PI/180;

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	fstp	QWORD PTR _lift$[ebp]
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN36@screw_wrap
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN38@screw_wrap
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ebx]
	jmp	SHORT $LN37@screw_wrap
$LN38@screw_wrap:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN36@screw_wrap
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN37@screw_wrap
$LN36@screw_wrap:
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [edx+esi]
$LN37@screw_wrap:
	fld	QWORD PTR [eax+64]
	fmul	QWORD PTR __real@400921fb54442d18
	fdiv	QWORD PTR __real@4066800000000000

; 667  :    y[0] = x[0]*cos(wrap*angle) - x[1]*sin(wrap*angle);

	fild	DWORD PTR _wrap$[ebp]
	fst	QWORD PTR tv371[ebp]
	fmulp	ST(1), ST(0)
	fst	QWORD PTR tv372[ebp]
	call	__CIcos
	fstp	QWORD PTR tv373[ebp]
	fld	QWORD PTR tv372[ebp]
	call	__CIsin
	mov	eax, DWORD PTR _x$[ebp]
	fld	QWORD PTR [eax]
	mov	ecx, DWORD PTR _y$[ebp]
	fld	QWORD PTR tv373[ebp]
	pop	edi
	fmul	ST(1), ST(0)
	pop	esi
	fld	QWORD PTR [eax+8]
	pop	ebx
	fmul	ST(0), ST(3)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [ecx]

; 668  :    y[1] = x[0]*sin(wrap*angle) + x[1]*cos(wrap*angle);

	fmul	QWORD PTR [eax+8]
	fld	QWORD PTR [eax]
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+8]

; 669  :    y[2] = x[2] + wrap*lift;

	fld	QWORD PTR tv371[ebp]
	fmul	QWORD PTR _lift$[ebp]
	fadd	QWORD PTR [eax+16]
	fstp	QWORD PTR [ecx+16]

; 670  :  } // end screw_wrap()

	mov	esp, ebp
	pop	ebp
	ret	0
_screw_wrap ENDP
_TEXT	ENDS
PUBLIC	_screw_compose
; Function compile flags: /Ogtp
;	COMDAT _screw_compose
_TEXT	SEGMENT
_wrap1$ = 8						; size = 4
_wrap2$ = 12						; size = 4
_screw_compose PROC					; COMDAT

; 673  :  { return wrap1 + wrap2; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _wrap2$[ebp]
	add	eax, DWORD PTR _wrap1$[ebp]
	pop	ebp
	ret	0
_screw_compose ENDP
_TEXT	ENDS
PUBLIC	_screw_inverse
; Function compile flags: /Ogtp
;	COMDAT _screw_inverse
_TEXT	SEGMENT
_wrap$ = 8						; size = 4
_screw_inverse PROC					; COMDAT

; 676  :  { return -wrap; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _wrap$[ebp]
	neg	eax
	pop	ebp
	ret	0
_screw_inverse ENDP
_TEXT	ENDS
PUBLIC	_screw_form_pullback
; Function compile flags: /Ogtp
;	COMDAT _screw_form_pullback
_TEXT	SEGMENT
tv216 = -16						; size = 8
tv215 = -8						; size = 8
_x$ = 8							; size = 4
_xform$ = 12						; size = 4
_yform$ = 16						; size = 4
_wrap$ = 20						; size = 4
_screw_form_pullback PROC				; COMDAT

; 681  :  { REAL angle;

	push	ebp
	mov	ebp, esp

; 682  :    angle = globals(twist_var)->value.real * M_PI/180;

	mov	eax, DWORD PTR _twist_var
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	sub	esp, 16					; 00000010H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN3@screw_form
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN5@screw_form
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN4@screw_form
$LN5@screw_form:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN3@screw_form
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN4@screw_form
$LN3@screw_form:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN4@screw_form:
	fld	QWORD PTR [eax+64]
	push	esi
	fmul	QWORD PTR __real@400921fb54442d18
	fdiv	QWORD PTR __real@4066800000000000

; 683  :    xform[0] = yform[0]*cos(wrap*angle) + yform[1]*sin(wrap*angle);

	fimul	DWORD PTR _wrap$[ebp]
	fst	QWORD PTR tv215[ebp]
	call	__CIsin
	mov	esi, DWORD PTR _yform$[ebp]
	fstp	QWORD PTR tv216[ebp]
	fld	QWORD PTR tv215[ebp]
	call	__CIcos
	fld	QWORD PTR [esi]
	mov	eax, DWORD PTR _xform$[ebp]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [esi+8]
	fld	QWORD PTR tv216[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(2)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax]

; 684  :    xform[1] = -yform[0]*sin(wrap*angle) + yform[1]*cos(wrap*angle);

	fld	QWORD PTR [esi+8]
	fmulp	ST(2), ST(0)
	fmul	QWORD PTR [esi]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax+8]

; 685  :    xform[2] = yform[2];

	fld	QWORD PTR [esi+16]
	pop	esi
	fstp	QWORD PTR [eax+16]

; 686  :  } // end screw_form_pullback()

	mov	esp, ebp
	pop	ebp
	ret	0
_screw_form_pullback ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EE@OMNAHJJH@quarter_turn_period?5variable?5not@ ; `string'
PUBLIC	??_C@_0BE@IKJKFEEG@quarter_turn_period?$AA@	; `string'
PUBLIC	_quarter_turn_wrap
;	COMDAT ??_C@_0EE@OMNAHJJH@quarter_turn_period?5variable?5not@
CONST	SEGMENT
??_C@_0EE@OMNAHJJH@quarter_turn_period?5variable?5not@ DB 'quarter_turn_p'
	DB	'eriod variable not defined for quarter_turn symmetry', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IKJKFEEG@quarter_turn_period?$AA@
CONST	SEGMENT
??_C@_0BE@IKJKFEEG@quarter_turn_period?$AA@ DB 'quarter_turn_period', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _quarter_turn_wrap
_TEXT	SEGMENT
_zwrap$ = -8						; size = 4
_ywrap$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xwrap$ = 16						; size = 4
_wrap$ = 16						; size = 4
_quarter_turn_wrap PROC					; COMDAT

; 709  :  { REAL zper;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 710  :    int xwrap,ywrap,zwrap;
; 711  :    if ( quarter_turn_var < 0 )

	cmp	DWORD PTR _quarter_turn_var, 0
	jge	SHORT $LN11@quarter_tu

; 712  :    { quarter_turn_var = lookup_global(QUARTERTURNNAME);

	push	OFFSET ??_C@_0BE@IKJKFEEG@quarter_turn_period?$AA@
	call	_lookup_global
	add	esp, 4
	mov	DWORD PTR _quarter_turn_var, eax

; 713  :      if ( quarter_turn_var < 0)

	test	eax, eax
	jns	SHORT $LN11@quarter_tu

; 714  :        kb_error(4008,
; 715  :         "quarter_turn_period variable not defined for quarter_turn symmetry\n",
; 716  :              RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EE@OMNAHJJH@quarter_turn_period?5variable?5not@
	push	4008					; 00000fa8H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN11@quarter_tu:

; 717  :    }
; 718  :    xwrap = wrap & WRAPMASK;

	mov	eax, DWORD PTR _wrap$[ebp]
	mov	ecx, eax
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR _xwrap$[ebp], ecx

; 719  :    if ( xwrap & 0x10 ) xwrap -= 0x20;

	test	cl, 16					; 00000010H
	je	SHORT $LN10@quarter_tu
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR _xwrap$[ebp], ecx
$LN10@quarter_tu:

; 720  :    ywrap = (wrap >> TWRAPBITS) & WRAPMASK;

	mov	ecx, eax
	sar	ecx, 6
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR _ywrap$[ebp], ecx

; 721  :    if ( ywrap & 0x10 ) ywrap -= 0x20;

	test	cl, 16					; 00000010H
	je	SHORT $LN9@quarter_tu
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR _ywrap$[ebp], ecx
$LN9@quarter_tu:

; 722  :    zwrap = (wrap >> 2*TWRAPBITS) & WRAPMASK;

	sar	eax, 12					; 0000000cH
	and	eax, 31					; 0000001fH
	push	ebx
	mov	ebx, eax
	mov	DWORD PTR _zwrap$[ebp], ebx

; 723  :    if ( zwrap & 0x10 ) zwrap -= 0x20;

	test	bl, 16					; 00000010H
	je	SHORT $LN8@quarter_tu
	sub	ebx, 32					; 00000020H
	mov	DWORD PTR _zwrap$[ebp], ebx
$LN8@quarter_tu:

; 724  : 
; 725  :    y[0] = x[0] + xwrap;

	fild	DWORD PTR _xwrap$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	fld	QWORD PTR [ecx]
	mov	edx, DWORD PTR _y$[ebp]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [edx]

; 726  :    y[1] = x[1] + ywrap;

	fild	DWORD PTR _ywrap$[ebp]
	fld	ST(0)
	fadd	QWORD PTR [ecx+8]
	fstp	QWORD PTR [edx+8]

; 727  :    if ( zwrap )

	test	ebx, ebx
	je	$LN22@quarter_tu

; 728  :    { zper = globals(quarter_turn_var)->value.real;

	mov	eax, DWORD PTR _quarter_turn_var
	push	esi
	mov	esi, eax
	and	esi, -16777216				; ff000000H
	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN15@quarter_tu
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN17@quarter_tu
	mov	esi, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [esi]
	jmp	SHORT $LN16@quarter_tu
$LN17@quarter_tu:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN15@quarter_tu
	mov	esi, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	jmp	SHORT $LN16@quarter_tu
$LN15@quarter_tu:
	mov	esi, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+esi]
$LN16@quarter_tu:

; 729  :      y[2] = x[2] + zwrap * zper;

	fild	DWORD PTR _zwrap$[ebp]
	fmul	QWORD PTR [eax+64]

; 730  :      zwrap = (zwrap + 20) % 4;

	lea	eax, DWORD PTR [ebx+20]
	and	eax, -2147483645			; 80000003H
	fadd	QWORD PTR [ecx+16]
	fstp	QWORD PTR [edx+16]
	jns	SHORT $LN43@quarter_tu
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN43@quarter_tu:

; 731  :      if ( zwrap == 1 )

	pop	esi
	cmp	eax, 1
	jne	SHORT $LN6@quarter_tu

; 732  :      { y[0] = -(x[1] + ywrap);

	fadd	QWORD PTR [ecx+8]
	pop	ebx
	fchs
	fstp	QWORD PTR [edx]

; 733  :        y[1] = x[0] + xwrap;

	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [edx+8]

; 745  : } // end quarter_turn_wrap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@quarter_tu:

; 734  :      }
; 735  :      else if ( zwrap == 2 )

	cmp	eax, 2
	jne	SHORT $LN4@quarter_tu

; 736  :      { y[0] = -(x[0] + xwrap);

	fld	QWORD PTR [ecx]
	pop	ebx
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fchs
	fstp	QWORD PTR [edx]

; 737  :        y[1] = -(x[1] + ywrap);

	fadd	QWORD PTR [ecx+8]
	fchs
	fstp	QWORD PTR [edx+8]

; 745  : } // end quarter_turn_wrap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@quarter_tu:

; 738  :      }
; 739  :      else if ( zwrap == 3 )

	cmp	eax, 3
	jne	SHORT $LN35@quarter_tu

; 740  :      { y[0] = x[1] + ywrap;

	fadd	QWORD PTR [ecx+8]
	pop	ebx
	fstp	QWORD PTR [edx]

; 741  :        y[1] = -(x[0] + xwrap);

	fadd	QWORD PTR [ecx]
	fchs
	fstp	QWORD PTR [edx+8]

; 745  : } // end quarter_turn_wrap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@quarter_tu:

; 727  :    if ( zwrap )

	fstp	ST(1)
	pop	ebx
	fstp	ST(0)

; 742  :      }
; 743  :    }
; 744  :    else y[2] = x[2];

	fld	QWORD PTR [ecx+16]
	fstp	QWORD PTR [edx+16]

; 745  : } // end quarter_turn_wrap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@quarter_tu:

; 738  :      }
; 739  :      else if ( zwrap == 3 )

	fstp	ST(1)
	pop	ebx
	fstp	ST(0)

; 745  : } // end quarter_turn_wrap()

	mov	esp, ebp
	pop	ebp
	ret	0
_quarter_turn_wrap ENDP
_TEXT	ENDS
PUBLIC	_quarter_turn_compose
; Function compile flags: /Ogtp
;	COMDAT _quarter_turn_compose
_TEXT	SEGMENT
_zwrap1$ = 8						; size = 4
_wrap1$ = 8						; size = 4
_xwrap2$ = 12						; size = 4
_wrap2$ = 12						; size = 4
_quarter_turn_compose PROC				; COMDAT

; 748  : { 

	push	ebp
	mov	ebp, esp

; 749  :   int xwrap1,ywrap1,zwrap1;
; 750  :   int xwrap2,ywrap2,zwrap2;
; 751  :    if ( quarter_turn_var < 0 )

	cmp	DWORD PTR _quarter_turn_var, 0
	jge	SHORT $LN12@quarter_tu@2

; 752  :    { quarter_turn_var = lookup_global(QUARTERTURNNAME);

	push	OFFSET ??_C@_0BE@IKJKFEEG@quarter_turn_period?$AA@
	call	_lookup_global
	add	esp, 4
	mov	DWORD PTR _quarter_turn_var, eax

; 753  :      if ( quarter_turn_var < 0)

	test	eax, eax
	jns	SHORT $LN12@quarter_tu@2

; 754  :        kb_error(3877,
; 755  :         "quarter_turn_period variable not defined for quarter_turn symmetry\n",
; 756  :              RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EE@OMNAHJJH@quarter_turn_period?5variable?5not@
	push	3877					; 00000f25H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN12@quarter_tu@2:

; 757  :    }
; 758  :    xwrap1 = wrap1 & WRAPMASK;

	push	esi
	mov	esi, DWORD PTR _wrap1$[ebp]
	mov	ecx, esi
	and	ecx, 31					; 0000001fH
	push	edi

; 759  :    if ( xwrap1 & 0x10 ) xwrap1 -= 0x20;

	test	cl, 16					; 00000010H
	je	SHORT $LN11@quarter_tu@2
	sub	ecx, 32					; 00000020H
$LN11@quarter_tu@2:

; 760  :    ywrap1 = (wrap1 >> TWRAPBITS) & WRAPMASK;

	mov	eax, esi
	sar	eax, 6
	and	eax, 31					; 0000001fH

; 761  :    if ( ywrap1 & 0x10 ) ywrap1 -= 0x20;

	test	al, 16					; 00000010H
	je	SHORT $LN10@quarter_tu@2
	sub	eax, 32					; 00000020H
$LN10@quarter_tu@2:

; 762  :    zwrap1 = (wrap1 >> 2*TWRAPBITS) & WRAPMASK;

	sar	esi, 12					; 0000000cH
	and	esi, 31					; 0000001fH
	mov	edx, esi
	mov	DWORD PTR _zwrap1$[ebp], edx

; 763  :    if ( zwrap1 & 0x10 ) zwrap1 -= 0x20;

	test	dl, 16					; 00000010H
	je	SHORT $LN9@quarter_tu@2
	sub	edx, 32					; 00000020H
	mov	DWORD PTR _zwrap1$[ebp], edx
$LN9@quarter_tu@2:

; 764  : 
; 765  :    xwrap2 = wrap2 & WRAPMASK;

	mov	esi, DWORD PTR _wrap2$[ebp]
	mov	edx, esi
	and	edx, 31					; 0000001fH
	mov	DWORD PTR _xwrap2$[ebp], edx

; 766  :    if ( xwrap2 & 0x10 ) xwrap2 -= 0x20;

	test	dl, 16					; 00000010H
	je	SHORT $LN8@quarter_tu@2
	sub	edx, 32					; 00000020H
	mov	DWORD PTR _xwrap2$[ebp], edx
$LN8@quarter_tu@2:

; 767  :    ywrap2 = (wrap2 >> TWRAPBITS) & WRAPMASK;

	mov	edx, esi
	sar	edx, 6
	and	edx, 31					; 0000001fH

; 768  :    if ( ywrap2 & 0x10 ) ywrap2 -= 0x20;

	test	dl, 16					; 00000010H
	je	SHORT $LN7@quarter_tu@2
	sub	edx, 32					; 00000020H
$LN7@quarter_tu@2:

; 769  :    zwrap2 = (wrap2 >> 2*TWRAPBITS) & WRAPMASK;

	sar	esi, 12					; 0000000cH
	and	esi, 31					; 0000001fH
	push	ebx
	mov	ebx, esi

; 770  :    if ( zwrap2 & 0x10 ) zwrap2 -= 0x20;

	test	bl, 16					; 00000010H
	je	SHORT $LN6@quarter_tu@2
	sub	ebx, 32					; 00000020H
$LN6@quarter_tu@2:

; 771  : 
; 772  :    zwrap2 = (zwrap2 + 20) % 4;

	lea	esi, DWORD PTR [ebx+20]
	and	esi, -2147483645			; 80000003H
	jns	SHORT $LN16@quarter_tu@2
	dec	esi
	or	esi, -4					; fffffffcH
	inc	esi
$LN16@quarter_tu@2:

; 773  :    if ( zwrap2 == 1 )

	pop	ebx
	cmp	esi, 1
	jne	SHORT $LN5@quarter_tu@2

; 774  :    { int temp = xwrap1;

	mov	edi, ecx

; 775  :      xwrap1 = ywrap1;
; 776  :      ywrap1 = -temp;

	neg	edi
	jmp	SHORT $LN17@quarter_tu@2
$LN5@quarter_tu@2:

; 777  :    } 
; 778  :    else if ( zwrap2 == 2 )

	cmp	esi, 2
	jne	SHORT $LN3@quarter_tu@2

; 779  :    { xwrap1 = -xwrap1;

	neg	ecx

; 780  :      ywrap1 = -ywrap1;

	neg	eax
	jmp	SHORT $LN1@quarter_tu@2
$LN3@quarter_tu@2:

; 781  :    }
; 782  :    else if ( zwrap2 == 3 )

	cmp	esi, 3
	jne	SHORT $LN1@quarter_tu@2

; 783  :    { int temp = xwrap1;

	mov	edi, ecx

; 784  :      xwrap1 = -ywrap1;

	neg	eax
$LN17@quarter_tu@2:
	mov	ecx, eax

; 785  :      ywrap1 = temp;

	mov	eax, edi
$LN1@quarter_tu@2:

; 786  :    } 
; 787  : 
; 788  :    return (((zwrap1 + zwrap2) & WRAPMASK) << (2*TWRAPBITS))
; 789  :         + (((ywrap1 + ywrap2) & WRAPMASK) << TWRAPBITS)
; 790  :         + ((xwrap1 + xwrap2) & WRAPMASK); 

	add	esi, DWORD PTR _zwrap1$[ebp]
	add	eax, edx
	mov	edx, DWORD PTR _xwrap2$[ebp]
	shl	eax, 6
	shl	esi, 12					; 0000000cH
	and	esi, 126976				; 0001f000H
	and	eax, 1984				; 000007c0H
	add	edx, ecx
	add	eax, esi
	and	edx, 31					; 0000001fH
	pop	edi
	add	eax, edx
	pop	esi

; 791  : 
; 792  :  } // end quarter_turn_compose()

	pop	ebp
	ret	0
_quarter_turn_compose ENDP
_TEXT	ENDS
PUBLIC	_quarter_turn_inverse
; Function compile flags: /Ogtp
;	COMDAT _quarter_turn_inverse
_TEXT	SEGMENT
_wrap$ = 8						; size = 4
_quarter_turn_inverse PROC				; COMDAT

; 795  : { int temp;

	push	ebp
	mov	ebp, esp

; 796  :   int xwrap,ywrap,zwrap;
; 797  :   xwrap = wrap & WRAPMASK;

	mov	edx, DWORD PTR _wrap$[ebp]
	mov	ecx, edx
	and	ecx, 31					; 0000001fH

; 798  :   if ( xwrap & 0x10 ) xwrap -= 0x20;

	test	cl, 16					; 00000010H
	je	SHORT $LN8@quarter_tu@3
	sub	ecx, 32					; 00000020H
$LN8@quarter_tu@3:

; 799  :   ywrap = (wrap >> TWRAPBITS) & WRAPMASK;

	mov	eax, edx
	sar	eax, 6
	and	eax, 31					; 0000001fH

; 800  :   if ( ywrap & 0x10 ) ywrap -= 0x20;

	test	al, 16					; 00000010H
	je	SHORT $LN7@quarter_tu@3
	sub	eax, 32					; 00000020H
$LN7@quarter_tu@3:

; 801  :   zwrap = (wrap >> 2*TWRAPBITS) & WRAPMASK;

	sar	edx, 12					; 0000000cH
	and	edx, 31					; 0000001fH

; 802  :   if ( zwrap & 0x10 ) zwrap -= 0x20;

	test	dl, 16					; 00000010H
	je	SHORT $LN6@quarter_tu@3
	sub	edx, 32					; 00000020H
$LN6@quarter_tu@3:

; 803  :   xwrap = -xwrap;
; 804  :   ywrap = -ywrap;

	neg	eax

; 805  :   zwrap = -zwrap;

	neg	edx
	push	esi
	mov	esi, eax
	mov	eax, edx

; 806  :   switch ( (zwrap + 20) % 4 )

	lea	edx, DWORD PTR [eax+20]
	neg	ecx
	and	edx, -2147483645			; 80000003H
	jns	SHORT $LN11@quarter_tu@3
	dec	edx
	or	edx, -4					; fffffffcH
	inc	edx
$LN11@quarter_tu@3:
	dec	edx
	je	SHORT $LN3@quarter_tu@3
	dec	edx
	je	SHORT $LN2@quarter_tu@3
	dec	edx
	jne	SHORT $LN4@quarter_tu@3

; 816  :     case 3:
; 817  :      temp = xwrap;

	mov	edx, ecx

; 818  :      xwrap = -ywrap;

	neg	esi

; 819  :      ywrap = temp;
; 820  :      break;

	jmp	SHORT $LN12@quarter_tu@3
$LN2@quarter_tu@3:

; 811  :      break;
; 812  :     case 2:
; 813  :      xwrap = -xwrap;

	neg	ecx

; 814  :      ywrap = -ywrap;

	neg	esi

; 815  :      break;

	jmp	SHORT $LN4@quarter_tu@3
$LN3@quarter_tu@3:

; 807  :   { case 1: 
; 808  :      temp = xwrap;

	mov	edx, ecx

; 809  :      xwrap = ywrap;
; 810  :      ywrap = -temp;

	neg	edx
$LN12@quarter_tu@3:
	mov	ecx, esi
	mov	esi, edx
$LN4@quarter_tu@3:

; 821  :   }
; 822  :   
; 823  :   return ((zwrap  & WRAPMASK) << (2*TWRAPBITS))
; 824  :         + ((ywrap & WRAPMASK) << TWRAPBITS)
; 825  :         + (xwrap  & WRAPMASK); 

	and	eax, 31					; 0000001fH
	shl	eax, 6
	and	esi, 31					; 0000001fH
	add	eax, esi
	shl	eax, 6
	and	ecx, 31					; 0000001fH
	add	eax, ecx
	pop	esi

; 826  : 
; 827  :  } // end quarter_turn_inverse()

	pop	ebp
	ret	0
_quarter_turn_inverse ENDP
_TEXT	ENDS
PUBLIC	_quarter_turn_form_pullback
; Function compile flags: /Ogtp
;	COMDAT _quarter_turn_form_pullback
_TEXT	SEGMENT
_x$ = 8							; size = 4
_xform$ = 12						; size = 4
_yform$ = 16						; size = 4
_wrap$ = 20						; size = 4
_quarter_turn_form_pullback PROC			; COMDAT

; 832  :  { int zwrap;

	push	ebp
	mov	ebp, esp

; 833  :    zwrap = (wrap >> 2*TWRAPBITS) & WRAPMASK;
; 834  :    yform[2] = xform[2];
; 835  :    switch ( (zwrap + 20) % 4 )

	mov	eax, DWORD PTR _wrap$[ebp]
	mov	ecx, DWORD PTR _xform$[ebp]
	fld	QWORD PTR [ecx+16]
	mov	edx, DWORD PTR _yform$[ebp]
	sar	eax, 12					; 0000000cH
	fstp	QWORD PTR [edx+16]
	and	eax, 31					; 0000001fH
	add	eax, 20					; 00000014H
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN9@quarter_tu@4
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN9@quarter_tu@4:
	cmp	eax, 3
	ja	SHORT $LN5@quarter_tu@4
	jmp	DWORD PTR $LN11@quarter_tu@4[eax*4]
$LN4@quarter_tu@4:

; 836  :    { case 0:
; 837  :         yform[0] = xform[0];

	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [edx]

; 838  :         yform[1] = xform[1];

	fld	QWORD PTR [ecx+8]

; 850  :         yform[1] = xform[0];

	fstp	QWORD PTR [edx+8]

; 851  :         break;
; 852  :         break;
; 853  :    }
; 854  :  } // end quarter_turn_form_pullback()

	pop	ebp
	ret	0
$LN3@quarter_tu@4:

; 839  :         break;
; 840  :      case 1:
; 841  :         yform[0] = xform[1];

	fld	QWORD PTR [ecx+8]
	fstp	QWORD PTR [edx]

; 842  :         yform[1] = -xform[0];

	fld	QWORD PTR [ecx]
	fchs

; 850  :         yform[1] = xform[0];

	fstp	QWORD PTR [edx+8]

; 851  :         break;
; 852  :         break;
; 853  :    }
; 854  :  } // end quarter_turn_form_pullback()

	pop	ebp
	ret	0
$LN2@quarter_tu@4:

; 843  :         break;
; 844  :      case 2:
; 845  :         yform[0] = -xform[0];

	fld	QWORD PTR [ecx]
	fchs
	fstp	QWORD PTR [edx]

; 846  :         yform[1] = -xform[1];

	fld	QWORD PTR [ecx+8]
	fchs

; 850  :         yform[1] = xform[0];

	fstp	QWORD PTR [edx+8]

; 851  :         break;
; 852  :         break;
; 853  :    }
; 854  :  } // end quarter_turn_form_pullback()

	pop	ebp
	ret	0
$LN1@quarter_tu@4:

; 847  :         break;
; 848  :      case 3:
; 849  :         yform[0] = -xform[1];

	fld	QWORD PTR [ecx+8]
	fchs
	fstp	QWORD PTR [edx]

; 850  :         yform[1] = xform[0];

	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [edx+8]
$LN5@quarter_tu@4:

; 851  :         break;
; 852  :         break;
; 853  :    }
; 854  :  } // end quarter_turn_form_pullback()

	pop	ebp
	ret	0
	npad	1
$LN11@quarter_tu@4:
	DD	$LN4@quarter_tu@4
	DD	$LN3@quarter_tu@4
	DD	$LN2@quarter_tu@4
	DD	$LN1@quarter_tu@4
_quarter_turn_form_pullback ENDP
_TEXT	ENDS
END
