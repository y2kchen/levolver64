; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\CHECK.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_inconsistent_bodies_count:DWORD
COMM	_edges_same_vertices_count:DWORD
COMM	_edge_loop_count:DWORD
COMM	_facets_same_vertices_count:DWORD
COMM	_bad_next_prev_count:DWORD
COMM	_bad_errors_count:DWORD
_DATA	ENDS
PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_unset_attr
; Function compile flags: /Ogtp
;	COMDAT _unset_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_unset_attr PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 29   :   elptr(id)->attr &= ~attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	not	ecx
	and	DWORD PTR [eax+8], ecx
	not	edx
	and	DWORD PTR [eax+12], edx

; 30   : }

	pop	ebp
	ret	0
_unset_attr ENDP
_TEXT	ENDS
PUBLIC	_get_fe_edge
; Function compile flags: /Ogtp
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _get_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_facet PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp

; 84   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 85   :     return inverse_id(feptr(fe_id)->nextfacet[1]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]
	xor	eax, 134217728				; 08000000H

; 88   : }

	pop	ebp
	ret	0
$LN2@get_prev_f:

; 86   :   else 
; 87   :     return feptr(fe_id)->nextfacet[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]

; 88   : }

	pop	ebp
	ret	0
_get_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_get_edge_wrap
EXTRN	_sym_inverse:DWORD
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_wrap PROC					; COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  :   WRAPTYPE wrap = *EINT(e_id,E_WRAP_ATTR) ;

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+784]
	mov	eax, DWORD PTR [eax+edx]
	pop	esi

; 165  :   return    ( inverted(e_id) ? (*sym_inverse)(wrap) : wrap );

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN4@get_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@get_edge_w:

; 166  : }

	pop	ebp
	ret	0
_get_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_@2
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_@2:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_@2
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_@2:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_head_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_head_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_head_edge PROC				; COMDAT

; 273  : { return inverse_id(eptr(e_id)->next_vedge[inverted(e_id) ?0: 1]); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	not	ecx
	and	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4+32]
	xor	eax, 134217728				; 08000000H
	pop	ebp
	ret	0
_get_next_head_edge ENDP
_TEXT	ENDS
PUBLIC	_get_body_facet
; Function compile flags: /Ogtp
;	COMDAT _get_body_facet
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_facet PROC					; COMDAT

; 279  : { return ( valid_id(b_id) ? bptr(b_id)->f_id : NULLID ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+400]
	pop	ebp
	ret	0
$LN3@get_body_f:
	xor	eax, eax
	pop	ebp
	ret	0
_get_body_facet ENDP
_TEXT	ENDS
PUBLIC	_get_meth_offset
; Function compile flags: /Ogtp
;	COMDAT _get_meth_offset
_TEXT	SEGMENT
_type$ = 8						; size = 4
_get_meth_offset PROC					; COMDAT

; 376  : { int meth_offset;

	push	ebp
	mov	ebp, esp

; 377  :   meth_offset = EXTRAS(type)[web.meth_attr[type]].offset; 

	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR _web[eax*4+5664]
	imul	eax, 112				; 00000070H

; 378  :   return meth_offset;

	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR [ecx+edx+64]

; 379  : }

	pop	ebp
	ret	0
_get_meth_offset ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@CFOEBMGJ@?$CFs?5?$CFs?5has?5method?5?$CFs?5twice?4?6?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	_method_check
EXTRN	_outstring:PROC
EXTRN	_typenames:BYTE
EXTRN	_meth_inst_list:DWORD
EXTRN	_msg:DWORD
EXTRN	_sprintf:PROC
EXTRN	_elnames:BYTE
;	COMDAT ??_C@_0BM@CFOEBMGJ@?$CFs?5?$CFs?5has?5method?5?$CFs?5twice?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@CFOEBMGJ@?$CFs?5?$CFs?5has?5method?5?$CFs?5twice?4?6?$AA@ DB '%'
	DB	's %s has method %s twice.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\check.c
CONST	ENDS
;	COMDAT _method_check
_TEXT	SEGMENT
tv279 = -32						; size = 4
tv448 = -28						; size = 4
tv275 = -24						; size = 4
tv376 = -20						; size = 4
tv280 = -16						; size = 4
_meth_offset$89048 = -12				; size = 4
_count$ = -8						; size = 4
tv407 = -4						; size = 4
_method_check PROC					; COMDAT

; 79   : { int type;

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi

; 80   :   element_id id;
; 81   :   int count = 0;

	xor	eax, eax
	mov	esi, OFFSET _web+48
	push	edi
	mov	DWORD PTR _count$[ebp], eax
	mov	DWORD PTR tv448[ebp], esi

; 82   :   int k,n;
; 83   : 
; 84   :   for ( type = VERTEX; type < FACETEDGE ; type++ )

	mov	DWORD PTR tv407[ebp], eax
	npad	7
$LL15@method_che:

; 85   :   { int meth_offset =  get_meth_offset(type);

	mov	eax, DWORD PTR tv407[ebp]
	mov	ecx, DWORD PTR _web[eax+5664]
	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR [esi+56]
	mov	eax, DWORD PTR [ecx+edx+64]
	mov	DWORD PTR _meth_offset$89048[ebp], eax

; 86   :     FOR_ALL_ELEMENTS(type,id)

	mov	eax, DWORD PTR [esi]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR tv275[ebp], ecx
	je	$LN14@method_che
$LL12@method_che:
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, eax
	mov	eax, DWORD PTR _web[ecx+12]
	lea	edi, DWORD PTR _web[ecx+12]
	and	edx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ebx+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR tv279[ebp], edi
	mov	DWORD PTR tv280[ebp], edx
	je	$LN11@method_che

; 88   :        int *instlist = (int*)((char*)e_ptr + meth_offset);
; 89   :        for ( k = 0; k < (int)e_ptr->method_count ; k++ )

	movzx	eax, WORD PTR [ebx+24]
	mov	ecx, DWORD PTR _meth_offset$89048[ebp]
	add	ecx, ebx
	test	eax, eax
	jle	$LN11@method_che

; 87   :      { struct element *e_ptr = elptr(id);

	mov	edi, 1
	mov	DWORD PTR tv376[ebp], edi
	mov	esi, ecx
$LL7@method_che:

; 90   :          for ( n = k+1; n < (int)e_ptr->method_count ; n++ )

	cmp	edi, eax
	jge	$LN6@method_che
	npad	6
$LL30@method_che:

; 91   :            if ( abs(instlist[k]) == abs(instlist[n]) )

	mov	edx, DWORD PTR _meth_offset$89048[ebp]
	lea	eax, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [eax+edi*4]
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [esi]
	xor	ecx, edx
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, ecx
	jne	SHORT $LN3@method_che

; 92   :            { sprintf(msg,"%s %s has method %s twice.\n",
; 93   :                typenames[type],ELNAME(id),METH_INSTANCE(abs(instlist[k]))->name);

	cmp	DWORD PTR tv275[ebp], 0
	je	SHORT $LN18@method_che
	mov	edx, DWORD PTR tv280[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	ecx, OFFSET _elnames
	jmp	SHORT $LN19@method_che
$LN18@method_che:
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN19@method_che:
	mov	eax, DWORD PTR [esi]
	cdq
	xor	eax, edx
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _msg
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list
	push	eax
	mov	eax, DWORD PTR tv407[ebp]
	push	ecx
	mov	ecx, DWORD PTR _typenames[eax]
	push	ecx
	push	OFFSET ??_C@_0BM@CFOEBMGJ@?$CFs?5?$CFs?5has?5method?5?$CFs?5twice?4?6?$AA@
	push	edx
	call	_sprintf

; 94   :              outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 24					; 00000018H

; 95   :              count++;

	inc	DWORD PTR _count$[ebp]
$LN3@method_che:

; 90   :          for ( n = k+1; n < (int)e_ptr->method_count ; n++ )

	movzx	ecx, WORD PTR [ebx+24]
	inc	edi
	cmp	edi, ecx
	jl	$LL30@method_che
	mov	edi, DWORD PTR tv376[ebp]
	mov	edx, DWORD PTR tv280[ebp]
$LN6@method_che:

; 88   :        int *instlist = (int*)((char*)e_ptr + meth_offset);
; 89   :        for ( k = 0; k < (int)e_ptr->method_count ; k++ )

	movzx	eax, WORD PTR [ebx+24]
	inc	edi
	lea	ecx, DWORD PTR [edi-1]
	add	esi, 4
	mov	DWORD PTR tv376[ebp], edi
	cmp	ecx, eax
	jl	$LL7@method_che
	mov	esi, DWORD PTR tv448[ebp]
	mov	edi, DWORD PTR tv279[ebp]
$LN11@method_che:

; 86   :     FOR_ALL_ELEMENTS(type,id)

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR tv275[ebp], ecx
	jne	$LL12@method_che
$LN14@method_che:

; 82   :   int k,n;
; 83   : 
; 84   :   for ( type = VERTEX; type < FACETEDGE ; type++ )

	add	DWORD PTR tv407[ebp], 4
	add	esi, 112				; 00000070H
	mov	DWORD PTR tv448[ebp], esi
	cmp	esi, OFFSET _web+496
	jl	$LL15@method_che

; 96   :            }
; 97   :       }
; 98   :   }
; 99   :   return count;

	mov	eax, DWORD PTR _count$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 100  : } /* end method_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
_method_check ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@CGAIEGBL@Too?5many?5errors?4?6?$AA@	; `string'
PUBLIC	??_C@_0CL@CNHCHMGK@Type?5?$CFd?5usedlist?5last?5id?5is?5non?9@ ; `string'
PUBLIC	??_C@_0CD@BAFOJFMO@Type?5?$CFd?5usedlist?5has?5?$CFd?5elements@ ; `string'
PUBLIC	??_C@_0DB@IBACNFJK@Type?5?$CFd?5usedlist?5has?5?$CFd?5elements@ ; `string'
PUBLIC	??_C@_0CM@BLIIOENB@Type?5?$CFd?5usedlist?5has?5bad?5id?5?$CFlX?5@ ; `string'
PUBLIC	??_C@_0CN@DOAIOEMO@Type?5?$CFd?5usedlist?5has?5too?5many?5el@ ; `string'
PUBLIC	??_C@_0DL@IDBOPEFN@Type?5?$CFd?5used?5list?5id?5?$CFlX?5has?5bac@ ; `string'
PUBLIC	??_C@_0CL@DMADFCKE@Type?5?$CFd?5freelist?5last?5id?5is?5non?9@ ; `string'
PUBLIC	??_C@_0DB@BKHGDFIF@Type?5?$CFd?5freelist?5has?5?$CFd?5elements@ ; `string'
PUBLIC	??_C@_0DH@FIKLDHEO@Type?5?$CFd?5freelist?5has?5bad?5freelas@ ; `string'
PUBLIC	??_C@_0CB@CAANDLDI@Type?5?$CFd?5freelist?5has?5bad?5id?5?$CFlX?6@ ; `string'
PUBLIC	??_C@_0CJ@OPFPCHAL@Type?5?$CFd?5freelist?5seems?5to?5be?5in?5@ ; `string'
PUBLIC	??_C@_0EC@MPCPBINL@Type?5?$CFd?5freelist?5has?5bad?5backcha@ ; `string'
PUBLIC	_list_check
EXTRN	_valid_element:PROC
EXTRN	_erroutstring:PROC
EXTRN	_errmsg:BYTE
;	COMDAT ??_C@_0BC@CGAIEGBL@Too?5many?5errors?4?6?$AA@
CONST	SEGMENT
??_C@_0BC@CGAIEGBL@Too?5many?5errors?4?6?$AA@ DB 'Too many errors.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CNHCHMGK@Type?5?$CFd?5usedlist?5last?5id?5is?5non?9@
CONST	SEGMENT
??_C@_0CL@CNHCHMGK@Type?5?$CFd?5usedlist?5last?5id?5is?5non?9@ DB 'Type %'
	DB	'd usedlist last id is non-null: %lX', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BAFOJFMO@Type?5?$CFd?5usedlist?5has?5?$CFd?5elements@
CONST	SEGMENT
??_C@_0CD@BAFOJFMO@Type?5?$CFd?5usedlist?5has?5?$CFd?5elements@ DB 'Type '
	DB	'%d usedlist has %d elements.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@IBACNFJK@Type?5?$CFd?5usedlist?5has?5?$CFd?5elements@
CONST	SEGMENT
??_C@_0DB@IBACNFJK@Type?5?$CFd?5usedlist?5has?5?$CFd?5elements@ DB 'Type '
	DB	'%d usedlist has %d elements instead of %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BLIIOENB@Type?5?$CFd?5usedlist?5has?5bad?5id?5?$CFlX?5@
CONST	SEGMENT
??_C@_0CM@BLIIOENB@Type?5?$CFd?5usedlist?5has?5bad?5id?5?$CFlX?5@ DB 'Typ'
	DB	'e %d usedlist has bad id %lX of type %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DOAIOEMO@Type?5?$CFd?5usedlist?5has?5too?5many?5el@
CONST	SEGMENT
??_C@_0CN@DOAIOEMO@Type?5?$CFd?5usedlist?5has?5too?5many?5el@ DB 'Type %d'
	DB	' usedlist has too many elements: %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@IDBOPEFN@Type?5?$CFd?5used?5list?5id?5?$CFlX?5has?5bac@
CONST	SEGMENT
??_C@_0DL@IDBOPEFN@Type?5?$CFd?5used?5list?5id?5?$CFlX?5has?5bac@ DB 'Typ'
	DB	'e %d used list id %lX has backchain %lX instead of %lX', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DMADFCKE@Type?5?$CFd?5freelist?5last?5id?5is?5non?9@
CONST	SEGMENT
??_C@_0CL@DMADFCKE@Type?5?$CFd?5freelist?5last?5id?5is?5non?9@ DB 'Type %'
	DB	'd freelist last id is non-null: %lX', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BKHGDFIF@Type?5?$CFd?5freelist?5has?5?$CFd?5elements@
CONST	SEGMENT
??_C@_0DB@BKHGDFIF@Type?5?$CFd?5freelist?5has?5?$CFd?5elements@ DB 'Type '
	DB	'%d freelist has %d elements instead of %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FIKLDHEO@Type?5?$CFd?5freelist?5has?5bad?5freelas@
CONST	SEGMENT
??_C@_0DH@FIKLDHEO@Type?5?$CFd?5freelist?5has?5bad?5freelas@ DB 'Type %d '
	DB	'freelist has bad freelast %lX instead of %lX.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CAANDLDI@Type?5?$CFd?5freelist?5has?5bad?5id?5?$CFlX?6@
CONST	SEGMENT
??_C@_0CB@CAANDLDI@Type?5?$CFd?5freelist?5has?5bad?5id?5?$CFlX?6@ DB 'Typ'
	DB	'e %d freelist has bad id %lX', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OPFPCHAL@Type?5?$CFd?5freelist?5seems?5to?5be?5in?5@
CONST	SEGMENT
??_C@_0CJ@OPFPCHAL@Type?5?$CFd?5freelist?5seems?5to?5be?5in?5@ DB 'Type %'
	DB	'd freelist seems to be in a loop.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@MPCPBINL@Type?5?$CFd?5freelist?5has?5bad?5backcha@
CONST	SEGMENT
??_C@_0EC@MPCPBINL@Type?5?$CFd?5freelist?5has?5bad?5backcha@ DB 'Type %d '
	DB	'freelist has bad backchain %lX instead of %lX for id %lX', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _list_check
_TEXT	SEGMENT
_maxused$89128 = -28					; size = 4
tv440 = -24						; size = 4
_discards$89129 = -20					; size = 4
_freecount$89089 = -20					; size = 4
_prev_id$89130 = -16					; size = 4
_backid$89087 = -16					; size = 4
_usedcount$89127 = -12					; size = 4
_maxfree$89090 = -12					; size = 4
tv567 = -8						; size = 4
_type$ = -4						; size = 4
_list_check PROC					; COMDAT

; 111  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi

; 112  :   int type;
; 113  :   element_id id;
; 114  :   int numerr = 0;

	xor	edx, edx
	xor	esi, esi

; 115  : 
; 116  :   /* free_discards(DISCARDS_ALL); */
; 117  :   for ( type = 0 ; type < NUMELEMENTS ; type++ )

	xor	ebx, ebx
	mov	ecx, OFFSET _web+20
	push	edi
	mov	DWORD PTR _type$[ebp], ebx
	mov	DWORD PTR tv567[ebp], ecx
	jmp	SHORT $LN34@list_check
	npad	4
$LL64@list_check:

; 112  :   int type;
; 113  :   element_id id;
; 114  :   int numerr = 0;

	xor	edx, edx
$LN34@list_check:

; 118  :   { 
; 119  :     element_id backid = NULLID;
; 120  : 
; 121  : #ifdef MPI_EVOLVER
; 122  :     if ( (this_task == MASTER_TASK) && (type != BODY) )
; 123  :       continue;
; 124  : #endif
; 125  : 
; 126  :     if ( (web.representation == SIMPLEX)  && (type == EDGE) ) continue;

	cmp	DWORD PTR _web+624, 3
	mov	DWORD PTR _backid$89087[ebp], edx
	jne	SHORT $LN59@list_check
	cmp	ebx, 1
	je	$LN33@list_check
$LN59@list_check:

; 127  :     #ifndef HASH_ID
; 128  :     /* check free list */
; 129  :     { int freecount,maxfree;
; 130  :       maxfree = web.skel[type].maxcount - web.skel[type].count
; 131  :                  - web.skel[type].discard_count;

	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [ecx+40]

; 132  :       id = web.skel[type].free;

	mov	edi, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+44]

; 133  :       freecount = 0;

	mov	DWORD PTR _freecount$89089[ebp], edx
	mov	DWORD PTR _maxfree$89090[ebp], eax

; 134  :       while ( id != NULLID )

	cmp	edi, edx
	je	$LN60@list_check
$LL30@list_check:

; 135  :       { freecount++;

	mov	eax, DWORD PTR _freecount$89089[ebp]

; 136  : 
; 137  :         if ( freecount > web.skel[type].maxcount )

	mov	ecx, DWORD PTR tv567[ebp]
	inc	eax
	mov	DWORD PTR _freecount$89089[ebp], eax
	cmp	eax, DWORD PTR [ecx]
	jg	SHORT $LN40@list_check

; 144  :         }
; 145  :         if ( id_type(id) != type )

	mov	eax, edi
	shr	eax, 29					; 0000001dH
	cmp	eax, ebx
	jne	$LN41@list_check

; 149  :           {erroutstring("Too many errors.\n"); return numerr;}
; 150  :           break;
; 151  :         }
; 152  :         if ( elptr(id)->backchain != backid )

	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	mov	ebx, edi
	and	ebx, 134217727				; 07ffffffH
	lea	ecx, DWORD PTR _web[eax+12]
	add	ebx, ebx
	add	ebx, ebx
	mov	eax, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _backid$89087[ebp]
	mov	DWORD PTR tv440[ebp], ecx
	cmp	eax, edx
	je	SHORT $LN23@list_check

; 153  :         { sprintf(errmsg,
; 154  :            "Type %d freelist has bad backchain %lX instead of %lX for id %lX\n",
; 155  :             type, (unsigned long)elptr(id)->backchain,(unsigned long)backid,
; 156  :            (unsigned long)id);

	mov	ecx, DWORD PTR _type$[ebp]
	push	edi
	push	edx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0EC@MPCPBINL@Type?5?$CFd?5freelist?5has?5bad?5backcha@
	push	OFFSET _errmsg
	call	_sprintf

; 157  :           erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 158  :           if ( ++numerr > MAXERR )

	inc	esi
	add	esp, 28					; 0000001cH
	cmp	esi, 20					; 00000014H
	jg	$LN55@list_check
	mov	ecx, DWORD PTR tv440[ebp]
$LN23@list_check:

; 159  :           {erroutstring("Too many errors.\n"); return numerr;}
; 160  :         }
; 161  :         backid = id;
; 162  :        
; 163  :         id = elptr(id)->forechain;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ebx+edx]

; 250  :       if ( ++numerr > MAXERR )

	mov	ebx, DWORD PTR _type$[ebp]
	mov	DWORD PTR _backid$89087[ebp], edi
	mov	edi, DWORD PTR [eax]
	test	edi, edi
	jne	$LL30@list_check
	jmp	SHORT $LN65@list_check
$LN40@list_check:

; 138  :         { sprintf(errmsg,"Type %d freelist seems to be in a loop.\n",
; 139  :             type);

	push	ebx
	push	OFFSET ??_C@_0CJ@OPFPCHAL@Type?5?$CFd?5freelist?5seems?5to?5be?5in?5@
	push	OFFSET _errmsg
	call	_sprintf

; 140  :           erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 16					; 00000010H

; 141  :           if ( ++numerr > MAXERR )
; 142  :           {erroutstring("Too many errors.\n"); return numerr;}
; 143  :           break;

	jmp	SHORT $LN67@list_check
$LN41@list_check:

; 146  :         { sprintf(errmsg,"Type %d freelist has bad id %lX\n",type,(unsigned long)id);

	push	edi
	push	ebx
	push	OFFSET ??_C@_0CB@CAANDLDI@Type?5?$CFd?5freelist?5has?5bad?5id?5?$CFlX?6@
	push	OFFSET _errmsg
	call	_sprintf

; 147  :           erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 20					; 00000014H
$LN67@list_check:

; 148  :           if ( ++numerr > MAXERR )

	inc	esi
	cmp	esi, 20					; 00000014H
	jg	$LN55@list_check
$LN65@list_check:
	mov	eax, DWORD PTR _maxfree$89090[ebp]
$LN60@list_check:

; 164  :       } /* end while */
; 165  : 
; 166  :       if ( backid != web.skel[type].freelast )

	mov	ecx, DWORD PTR tv567[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _backid$89087[ebp]
	cmp	edx, ecx
	je	SHORT $LN63@list_check

; 167  :       { sprintf(errmsg,"Type %d freelist has bad freelast %lX instead of %lX.\n",
; 168  :           type, (unsigned long)web.skel[type].freelast,(unsigned long)backid);

	push	edx
	push	ecx
	push	ebx
	push	OFFSET ??_C@_0DH@FIKLDHEO@Type?5?$CFd?5freelist?5has?5bad?5freelas@
	push	OFFSET _errmsg
	call	_sprintf

; 169  :         erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 170  :         if ( ++numerr > MAXERR )

	inc	esi
	add	esp, 24					; 00000018H
	cmp	esi, 20					; 00000014H
	jg	$LN55@list_check
	mov	eax, DWORD PTR _maxfree$89090[ebp]
$LN63@list_check:

; 171  :         {erroutstring("Too many errors.\n"); return numerr;}
; 172  :       }
; 173  : 
; 174  :       if ( freecount != maxfree )

	mov	ecx, DWORD PTR _freecount$89089[ebp]
	cmp	ecx, eax
	je	SHORT $LN19@list_check

; 175  :       { sprintf(errmsg,"Type %d freelist has %d elements instead of %d.\n",
; 176  :           type,freecount,maxfree);

	push	eax
	push	ecx
	push	ebx
	push	OFFSET ??_C@_0DB@BKHGDFIF@Type?5?$CFd?5freelist?5has?5?$CFd?5elements@
	push	OFFSET _errmsg
	call	_sprintf

; 177  :         erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 178  :         if ( ++numerr > MAXERR )

	inc	esi
	add	esp, 24					; 00000018H
	cmp	esi, 20					; 00000014H
	jg	$LN55@list_check
$LN19@list_check:

; 179  :         {erroutstring("Too many errors.\n"); return numerr;}
; 180  :       }
; 181  :       if ( !equal_id(id,NULLID) )

	test	edi, edi
	je	SHORT $LN17@list_check

; 182  :       { sprintf(errmsg,"Type %d freelist last id is non-null: %lX\n",type,
; 183  :           (unsigned long)id);

	push	edi
	push	ebx
	push	OFFSET ??_C@_0CL@DMADFCKE@Type?5?$CFd?5freelist?5last?5id?5is?5non?9@
	push	OFFSET _errmsg
	call	_sprintf

; 184  :         erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 185  :         if ( ++numerr > MAXERR )

	inc	esi
	add	esp, 20					; 00000014H
	cmp	esi, 20					; 00000014H
	jg	$LN55@list_check
$LN17@list_check:

; 186  :         {erroutstring("Too many errors.\n"); return numerr;}
; 187  :       }
; 188  :     }
; 189  :     #endif
; 190  :     
; 191  : 
; 192  :   { int usedcount,maxused,discards;
; 193  :     element_id prev_id;
; 194  : 
; 195  :     /* check used list */
; 196  :     maxused = web.skel[type].count;

	mov	eax, DWORD PTR tv567[ebp]
	mov	edx, DWORD PTR [eax+44]

; 197  :     id = web.skel[type].used;

	mov	edi, DWORD PTR [eax+28]

; 198  :     prev_id = NULLID;

	xor	eax, eax
	mov	DWORD PTR _maxused$89128[ebp], edx
	mov	DWORD PTR _prev_id$89130[ebp], eax

; 199  :     usedcount = 0;

	mov	DWORD PTR _usedcount$89127[ebp], eax

; 200  :     discards = 0;

	mov	DWORD PTR _discards$89129[ebp], eax

; 201  :     while ( valid_id(id) )

	test	edi, 268435456				; 10000000H
	je	$LN9@list_check
	npad	1
$LL16@list_check:

; 202  :     { 
; 203  :       if ( valid_element(id) )

	push	edi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	je	SHORT $LN14@list_check

; 204  :         usedcount++;

	inc	DWORD PTR _usedcount$89127[ebp]
	jmp	SHORT $LN13@list_check
$LN14@list_check:

; 205  :       else discards++;

	inc	DWORD PTR _discards$89129[ebp]
$LN13@list_check:

; 206  : 
; 207  :       if ( usedcount > maxused )

	mov	eax, DWORD PTR _usedcount$89127[ebp]
	cmp	eax, DWORD PTR _maxused$89128[ebp]
	jg	SHORT $LN43@list_check

; 214  :       }
; 215  :       if ( id_type(id) != type )

	mov	eax, edi
	shr	eax, 29					; 0000001dH
	cmp	eax, ebx
	jne	$LN44@list_check

; 220  :         { erroutstring("Too many errors.\n"); return numerr;}
; 221  :         break;
; 222  :       }
; 223  :       if ( !equal_id(prev_id,elptr(id)->backchain) )

	imul	eax, 112				; 00000070H
	mov	ebx, edi
	and	ebx, 134217727				; 07ffffffH
	lea	ecx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [ecx]
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _prev_id$89130[ebp]
	mov	DWORD PTR tv440[ebp], ecx
	cmp	edx, eax
	je	SHORT $LN7@list_check

; 224  :       { sprintf(errmsg,"Type %d used list id %lX has backchain %lX instead of %lX\n",
; 225  :               type,(unsigned long)id,(unsigned long)elptr(id)->backchain,
; 226  :              (unsigned long)prev_id);

	push	edx
	push	eax
	mov	eax, DWORD PTR _type$[ebp]
	push	edi
	push	eax
	push	OFFSET ??_C@_0DL@IDBOPEFN@Type?5?$CFd?5used?5list?5id?5?$CFlX?5has?5bac@
	push	OFFSET _errmsg
	call	_sprintf

; 227  :         erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 228  :         if ( ++numerr > MAXERR )

	inc	esi
	add	esp, 28					; 0000001cH
	cmp	esi, 20					; 00000014H
	jg	$LN55@list_check
	mov	ecx, DWORD PTR tv440[ebp]
$LN7@list_check:

; 229  :         {erroutstring("Too many errors.\n"); return numerr;}
; 230  :       }
; 231  :       prev_id = id;
; 232  :       id = elptr(id)->forechain;

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx+ecx]

; 250  :       if ( ++numerr > MAXERR )

	mov	ebx, DWORD PTR _type$[ebp]
	mov	DWORD PTR _prev_id$89130[ebp], edi
	mov	edi, DWORD PTR [edx]
	test	edi, 268435456				; 10000000H
	jne	$LL16@list_check
	jmp	SHORT $LN9@list_check
$LN43@list_check:

; 208  :       { sprintf(errmsg,"Type %d usedlist has too many elements: %d.\n",
; 209  :             type,usedcount);

	push	eax
	push	ebx
	push	OFFSET ??_C@_0CN@DOAIOEMO@Type?5?$CFd?5usedlist?5has?5too?5many?5el@
	push	OFFSET _errmsg
	call	_sprintf

; 210  :         erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 20					; 00000014H

; 211  :         if ( ++numerr > MAXERR )
; 212  :         {erroutstring("Too many errors.\n"); return numerr;}
; 213  :         break;

	jmp	SHORT $LN69@list_check
$LN44@list_check:

; 216  :       { sprintf(errmsg,"Type %d usedlist has bad id %lX of type %d\n",
; 217  :             type,(unsigned long)id,id_type(id));

	mov	eax, edi
	shr	eax, 29					; 0000001dH
	push	eax
	push	edi
	push	ebx
	push	OFFSET ??_C@_0CM@BLIIOENB@Type?5?$CFd?5usedlist?5has?5bad?5id?5?$CFlX?5@
	push	OFFSET _errmsg
	call	_sprintf

; 218  :         erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 24					; 00000018H
$LN69@list_check:

; 219  :         if ( ++numerr > MAXERR )

	inc	esi
	cmp	esi, 20					; 00000014H
	jg	$LN55@list_check
$LN9@list_check:

; 233  :     } /* end while */
; 234  :     if ( usedcount != maxused )

	mov	eax, DWORD PTR _usedcount$89127[ebp]
	mov	ecx, DWORD PTR _maxused$89128[ebp]
	cmp	eax, ecx
	je	SHORT $LN5@list_check

; 235  :     { sprintf(errmsg,"Type %d usedlist has %d elements instead of %d.\n",type,usedcount,maxused);

	push	ecx
	push	eax
	push	ebx
	push	OFFSET ??_C@_0DB@IBACNFJK@Type?5?$CFd?5usedlist?5has?5?$CFd?5elements@
	push	OFFSET _errmsg
	call	_sprintf

; 236  :       erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 237  :       if ( ++numerr > MAXERR )

	inc	esi
	add	esp, 24					; 00000018H
	cmp	esi, 20					; 00000014H
	jg	SHORT $LN55@list_check
$LN5@list_check:

; 238  :       {erroutstring("Too many errors.\n"); return numerr;}
; 239  :     }
; 240  :     if ( discards != web.skel[type].discard_count )

	mov	ecx, DWORD PTR _discards$89129[ebp]
	mov	edx, DWORD PTR tv567[ebp]
	cmp	ecx, DWORD PTR [edx+40]
	je	SHORT $LN3@list_check

; 241  :     { sprintf(errmsg,"Type %d usedlist has %d elements.\n",type,usedcount);

	mov	eax, DWORD PTR _usedcount$89127[ebp]
	push	eax
	push	ebx
	push	OFFSET ??_C@_0CD@BAFOJFMO@Type?5?$CFd?5usedlist?5has?5?$CFd?5elements@
	push	OFFSET _errmsg
	call	_sprintf

; 242  :       erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 243  :       if ( ++numerr > MAXERR )

	inc	esi
	add	esp, 20					; 00000014H
	cmp	esi, 20					; 00000014H
	jg	SHORT $LN55@list_check
$LN3@list_check:

; 244  :       {erroutstring("Too many errors.\n"); return numerr;}
; 245  :     }
; 246  :     if ( !equal_id(id,NULLID) )

	test	edi, edi
	je	SHORT $LN33@list_check

; 247  :     { sprintf(errmsg,"Type %d usedlist last id is non-null: %lX\n",type,
; 248  :           (unsigned long)id);

	push	edi
	push	ebx
	push	OFFSET ??_C@_0CL@CNHCHMGK@Type?5?$CFd?5usedlist?5last?5id?5is?5non?9@
	push	OFFSET _errmsg
	call	_sprintf

; 249  :       erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 250  :       if ( ++numerr > MAXERR )

	inc	esi
	add	esp, 20					; 00000014H
	cmp	esi, 20					; 00000014H
	jg	SHORT $LN55@list_check
$LN33@list_check:

; 115  : 
; 116  :   /* free_discards(DISCARDS_ALL); */
; 117  :   for ( type = 0 ; type < NUMELEMENTS ; type++ )

	mov	ecx, DWORD PTR tv567[ebp]
	add	ecx, 112				; 00000070H
	inc	ebx
	mov	DWORD PTR _type$[ebp], ebx
	mov	DWORD PTR tv567[ebp], ecx
	cmp	ecx, OFFSET _web+580
	jl	$LL64@list_check

; 252  :     }
; 253  :   }
; 254  : 
; 255  :   } /* end for loop */
; 256  : 
; 257  :   #ifdef MPI_EVOLVER
; 258  :   for ( type = VERTEX ; type < NUMELEMENTS ; type++ )
; 259  :   { int k;
; 260  :     for ( k = 0 ; k < web.skel[type].maxcount ; k++ )
; 261  :       if ( web.skel[type].ibase[k] && (web.skel[type].ibase[k]->local_id & OFFSETMASK) != k )
; 262  :       { sprintf(errmsg,"Task %d: local_id is %08X on %s ibase[0x%X], self id %08X\n",
; 263  :           this_task,(int)(web.skel[type].ibase[k]->local_id),
; 264  :            typenames[type],k, (int)(web.skel[type].ibase[k]->self_id));
; 265  :         erroutstring(errmsg);
; 266  :       }
; 267  :   }
; 268  :   #endif
; 269  :     
; 270  :   return numerr;

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 271  : } /* end list_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@list_check:

; 251  :       {erroutstring("Too many errors.\n"); return numerr;}

	push	OFFSET ??_C@_0BC@CGAIEGBL@Too?5many?5errors?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	pop	edi

; 252  :     }
; 253  :   }
; 254  : 
; 255  :   } /* end for loop */
; 256  : 
; 257  :   #ifdef MPI_EVOLVER
; 258  :   for ( type = VERTEX ; type < NUMELEMENTS ; type++ )
; 259  :   { int k;
; 260  :     for ( k = 0 ; k < web.skel[type].maxcount ; k++ )
; 261  :       if ( web.skel[type].ibase[k] && (web.skel[type].ibase[k]->local_id & OFFSETMASK) != k )
; 262  :       { sprintf(errmsg,"Task %d: local_id is %08X on %s ibase[0x%X], self id %08X\n",
; 263  :           this_task,(int)(web.skel[type].ibase[k]->local_id),
; 264  :            typenames[type],k, (int)(web.skel[type].ibase[k]->self_id));
; 265  :         erroutstring(errmsg);
; 266  :       }
; 267  :   }
; 268  :   #endif
; 269  :     
; 270  :   return numerr;

	mov	eax, esi
	pop	esi
	pop	ebx

; 271  : } /* end list_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
_list_check ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EG@BJDMGDDK@Facetedge?5?$CFs?5on?5facet?5?$CFs?5and?5edg@ ; `string'
PUBLIC	??_C@_0CN@NOCCOCCG@Facets?5have?5?$CFd?5facet?9edges?5out?5o@ ; `string'
PUBLIC	??_C@_0BI@MBBNMEHH@Facet?5?$CFs?5has?5?$CFd?5edges?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@FFMCKPNG@Edges?5around?5facet?5?$CFs?5do?5not?5lin@ ; `string'
PUBLIC	??_C@_0BN@CIEFJFJB@?5?5?5?5?5?5?$CIoriginally?5facet?5?$CFs?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@MAPEECME@Facetedge?5loop?5not?5closed?5on?5fac@ ; `string'
PUBLIC	??_C@_0CJ@KCENKHDP@Facetedge?5?$CFs?5on?5facet?5?$CFs?5instead@ ; `string'
PUBLIC	??_C@_0CL@GDCDHLPJ@Edges?5have?5?$CFd?5facetedges?5out?5of?5@ ; `string'
PUBLIC	??_C@_0CH@GOFJFPDL@Facets?5around?5edge?5?$CFs?5do?5not?5lin@ ; `string'
PUBLIC	??_C@_0BM@OMAJFPHI@?5?5?5?5?5?5?$CIoriginally?5edge?5?$CFs?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0DC@DGHOPHNN@Edge?5?$CFs?5has?5no?5facets?0?5and?5is?5no@ ; `string'
PUBLIC	??_C@_0CJ@KGDAEMFO@Bad?5chain?5of?5facetedges?5around?5e@ ; `string'
PUBLIC	??_C@_0DH@KKBPNGI@Facetedge?5?$CFs?5on?5edge?5?$CFs?5but?5foun@ ; `string'
PUBLIC	??_C@_04HGGBINEM@?$CFs?$CFd?$AA@		; `string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
PUBLIC	??_C@_0DF@BGOLIMCI@Vertex?5?$CFs?5is?5axial?5and?5not?5first@ ; `string'
PUBLIC	??_C@_0CL@FJKCCBMP@Vertex?5?$CFs?5has?5bad?5edge?5loop?5from@ ; `string'
PUBLIC	??_C@_0BO@LOFCFJMK@Vertex?5?$CFs?5has?5bad?5edge?5link?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@GDOFEGMG@Vertex?5?$CFs?5has?5bad?5midpoint?5edge?5@ ; `string'
PUBLIC	??_C@_0CC@GIACHLB@Vertex?5?$CFs?5has?5invalid?5edge?5link?4@ ; `string'
PUBLIC	??_C@_0BO@GLNHAGJF@?5?5?5?5?5?5?$CIoriginally?5vertex?5?$CFs?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MADMBEHM@Vertex?5?$CFs?5has?5no?5edges?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@EELEPEOJ@Only?5?$CFd?5facetedges?5out?5of?5?$CFld?5ge@ ; `string'
PUBLIC	??_C@_0DE@FPNANCGF@Facetedge?5?$CFs?5tail?5vertex?5disagre@ ; `string'
PUBLIC	??_C@_0DE@DDDHPJPA@Facetedge?5?$CFs?5head?5vertex?5disagre@ ; `string'
PUBLIC	??_C@_0CG@MGMEFBOJ@Facetedge?5?$CFs?5has?5bad?5prev?5facet?5@ ; `string'
PUBLIC	??_C@_0CG@NCGNNPAH@Facetedge?5?$CFs?5has?5bad?5next?5facet?5@ ; `string'
PUBLIC	??_C@_0CF@CCLCMHAG@Facetedge?5?$CFs?5has?5bad?5next?5edge?5l@ ; `string'
PUBLIC	??_C@_0CF@IKGAGGBK@Facetedge?5?$CFs?5has?5bad?5prev?5edge?5l@ ; `string'
PUBLIC	??_C@_0DK@FENCHNIC@Facetedge?5?$CFs?5links?5to?5edge?5?$CFs?5wi@ ; `string'
PUBLIC	??_C@_0CL@KGKIEHFE@Facetedge?5?$CFs?5links?5to?5invalid?5ed@ ; `string'
PUBLIC	??_C@_0DL@KGNCEJOB@Facetedge?5?$CFs?5links?5to?5facet?5?$CFs?5w@ ; `string'
PUBLIC	??_C@_0CN@KFNPPAEL@Facetedge?5?5?$CFs?5links?5to?5invalid?5f@ ; `string'
PUBLIC	_facetedge_check
EXTRN	_set_facet_fe:PROC
EXTRN	_bare_edge_count:DWORD
EXTRN	_kb_error:PROC
;	COMDAT ??_C@_0EG@BJDMGDDK@Facetedge?5?$CFs?5on?5facet?5?$CFs?5and?5edg@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EG@BJDMGDDK@Facetedge?5?$CFs?5on?5facet?5?$CFs?5and?5edg@ DB 'Face'
	DB	'tedge %s on facet %s and edge %s not reached in facet edge li'
	DB	'st.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NOCCOCCG@Facets?5have?5?$CFd?5facet?9edges?5out?5o@
CONST	SEGMENT
??_C@_0CN@NOCCOCCG@Facets?5have?5?$CFd?5facet?9edges?5out?5o@ DB 'Facets '
	DB	'have %d facet-edges out of %ld used.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MBBNMEHH@Facet?5?$CFs?5has?5?$CFd?5edges?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@MBBNMEHH@Facet?5?$CFs?5has?5?$CFd?5edges?4?6?$AA@ DB 'Facet %s '
	DB	'has %d edges.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FFMCKPNG@Edges?5around?5facet?5?$CFs?5do?5not?5lin@
CONST	SEGMENT
??_C@_0CH@FFMCKPNG@Edges?5around?5facet?5?$CFs?5do?5not?5lin@ DB 'Edges a'
	DB	'round facet %s do not link up.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CIEFJFJB@?5?5?5?5?5?5?$CIoriginally?5facet?5?$CFs?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BN@CIEFJFJB@?5?5?5?5?5?5?$CIoriginally?5facet?5?$CFs?$CJ?6?$AA@ DB ' '
	DB	'     (originally facet %s)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MAPEECME@Facetedge?5loop?5not?5closed?5on?5fac@
CONST	SEGMENT
??_C@_0CI@MAPEECME@Facetedge?5loop?5not?5closed?5on?5fac@ DB 'Facetedge l'
	DB	'oop not closed on facet %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KCENKHDP@Facetedge?5?$CFs?5on?5facet?5?$CFs?5instead@
CONST	SEGMENT
??_C@_0CJ@KCENKHDP@Facetedge?5?$CFs?5on?5facet?5?$CFs?5instead@ DB 'Facet'
	DB	'edge %s on facet %s instead of %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GDCDHLPJ@Edges?5have?5?$CFd?5facetedges?5out?5of?5@
CONST	SEGMENT
??_C@_0CL@GDCDHLPJ@Edges?5have?5?$CFd?5facetedges?5out?5of?5@ DB 'Edges h'
	DB	'ave %d facetedges out of %ld used.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GOFJFPDL@Facets?5around?5edge?5?$CFs?5do?5not?5lin@
CONST	SEGMENT
??_C@_0CH@GOFJFPDL@Facets?5around?5edge?5?$CFs?5do?5not?5lin@ DB 'Facets '
	DB	'around edge %s do not link up.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OMAJFPHI@?5?5?5?5?5?5?$CIoriginally?5edge?5?$CFs?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BM@OMAJFPHI@?5?5?5?5?5?5?$CIoriginally?5edge?5?$CFs?$CJ?6?$AA@ DB ' '
	DB	'     (originally edge %s)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DGHOPHNN@Edge?5?$CFs?5has?5no?5facets?0?5and?5is?5no@
CONST	SEGMENT
??_C@_0DC@DGHOPHNN@Edge?5?$CFs?5has?5no?5facets?0?5and?5is?5no@ DB 'Edge '
	DB	'%s has no facets, and is not marked "bare".', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KGDAEMFO@Bad?5chain?5of?5facetedges?5around?5e@
CONST	SEGMENT
??_C@_0CJ@KGDAEMFO@Bad?5chain?5of?5facetedges?5around?5e@ DB 'Bad chain o'
	DB	'f facetedges around edge %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@KKBPNGI@Facetedge?5?$CFs?5on?5edge?5?$CFs?5but?5foun@
CONST	SEGMENT
??_C@_0DH@KKBPNGI@Facetedge?5?$CFs?5on?5edge?5?$CFs?5but?5foun@ DB 'Facet'
	DB	'edge %s on edge %s but found in loop of edge %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HGGBINEM@?$CFs?$CFd?$AA@
CONST	SEGMENT
??_C@_04HGGBINEM@?$CFs?$CFd?$AA@ DB '%s%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BGOLIMCI@Vertex?5?$CFs?5is?5axial?5and?5not?5first@
CONST	SEGMENT
??_C@_0DF@BGOLIMCI@Vertex?5?$CFs?5is?5axial?5and?5not?5first@ DB 'Vertex '
	DB	'%s is axial and not first vertex of edge %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FJKCCBMP@Vertex?5?$CFs?5has?5bad?5edge?5loop?5from@
CONST	SEGMENT
??_C@_0CL@FJKCCBMP@Vertex?5?$CFs?5has?5bad?5edge?5loop?5from@ DB 'Vertex '
	DB	'%s has bad edge loop from edge %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LOFCFJMK@Vertex?5?$CFs?5has?5bad?5edge?5link?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@LOFCFJMK@Vertex?5?$CFs?5has?5bad?5edge?5link?4?6?$AA@ DB 'Verte'
	DB	'x %s has bad edge link.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GDOFEGMG@Vertex?5?$CFs?5has?5bad?5midpoint?5edge?5@
CONST	SEGMENT
??_C@_0CH@GDOFEGMG@Vertex?5?$CFs?5has?5bad?5midpoint?5edge?5@ DB 'Vertex '
	DB	'%s has bad midpoint edge link.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GIACHLB@Vertex?5?$CFs?5has?5invalid?5edge?5link?4@
CONST	SEGMENT
??_C@_0CC@GIACHLB@Vertex?5?$CFs?5has?5invalid?5edge?5link?4@ DB 'Vertex %'
	DB	's has invalid edge link.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GLNHAGJF@?5?5?5?5?5?5?$CIoriginally?5vertex?5?$CFs?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BO@GLNHAGJF@?5?5?5?5?5?5?$CIoriginally?5vertex?5?$CFs?$CJ?6?$AA@ DB ' '
	DB	'     (originally vertex %s)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MADMBEHM@Vertex?5?$CFs?5has?5no?5edges?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@MADMBEHM@Vertex?5?$CFs?5has?5no?5edges?4?6?$AA@ DB 'Vertex %s h'
	DB	'as no edges.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EELEPEOJ@Only?5?$CFd?5facetedges?5out?5of?5?$CFld?5ge@
CONST	SEGMENT
??_C@_0CK@EELEPEOJ@Only?5?$CFd?5facetedges?5out?5of?5?$CFld?5ge@ DB 'Only'
	DB	' %d facetedges out of %ld generated.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FPNANCGF@Facetedge?5?$CFs?5tail?5vertex?5disagre@
CONST	SEGMENT
??_C@_0DE@FPNANCGF@Facetedge?5?$CFs?5tail?5vertex?5disagre@ DB 'Facetedge'
	DB	' %s tail vertex disagrees with prev head.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@DDDHPJPA@Facetedge?5?$CFs?5head?5vertex?5disagre@
CONST	SEGMENT
??_C@_0DE@DDDHPJPA@Facetedge?5?$CFs?5head?5vertex?5disagre@ DB 'Facetedge'
	DB	' %s head vertex disagrees with next tail.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MGMEFBOJ@Facetedge?5?$CFs?5has?5bad?5prev?5facet?5@
CONST	SEGMENT
??_C@_0CG@MGMEFBOJ@Facetedge?5?$CFs?5has?5bad?5prev?5facet?5@ DB 'Faceted'
	DB	'ge %s has bad prev facet link', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NCGNNPAH@Facetedge?5?$CFs?5has?5bad?5next?5facet?5@
CONST	SEGMENT
??_C@_0CG@NCGNNPAH@Facetedge?5?$CFs?5has?5bad?5next?5facet?5@ DB 'Faceted'
	DB	'ge %s has bad next facet link', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CCLCMHAG@Facetedge?5?$CFs?5has?5bad?5next?5edge?5l@
CONST	SEGMENT
??_C@_0CF@CCLCMHAG@Facetedge?5?$CFs?5has?5bad?5next?5edge?5l@ DB 'Faceted'
	DB	'ge %s has bad next edge link', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IKGAGGBK@Facetedge?5?$CFs?5has?5bad?5prev?5edge?5l@
CONST	SEGMENT
??_C@_0CF@IKGAGGBK@Facetedge?5?$CFs?5has?5bad?5prev?5edge?5l@ DB 'Faceted'
	DB	'ge %s has bad prev edge link', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@FENCHNIC@Facetedge?5?$CFs?5links?5to?5edge?5?$CFs?5wi@
CONST	SEGMENT
??_C@_0DK@FENCHNIC@Facetedge?5?$CFs?5links?5to?5edge?5?$CFs?5wi@ DB 'Face'
	DB	'tedge %s links to edge %s with invalid facetedge %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KGKIEHFE@Facetedge?5?$CFs?5links?5to?5invalid?5ed@
CONST	SEGMENT
??_C@_0CL@KGKIEHFE@Facetedge?5?$CFs?5links?5to?5invalid?5ed@ DB 'Facetedg'
	DB	'e %s links to invalid edge %08lX.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@KGNCEJOB@Facetedge?5?$CFs?5links?5to?5facet?5?$CFs?5w@
CONST	SEGMENT
??_C@_0DL@KGNCEJOB@Facetedge?5?$CFs?5links?5to?5facet?5?$CFs?5w@ DB 'Face'
	DB	'tedge %s links to facet %s with invalid facetedge %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KFNPPAEL@Facetedge?5?5?$CFs?5links?5to?5invalid?5f@
CONST	SEGMENT
??_C@_0CN@KFNPPAEL@Facetedge?5?5?$CFs?5links?5to?5invalid?5f@ DB 'Faceted'
	DB	'ge  %s links to invalid facet %08lX.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\check.c
CONST	ENDS
;	COMDAT _facetedge_check
_TEXT	SEGMENT
tv3737 = -48						; size = 8
tv3668 = -44						; size = 4
tv3666 = -44						; size = 4
tv1408 = -44						; size = 4
_start_fe$89545 = -44					; size = 4
_last_fe$ = -44						; size = 4
tv3639 = -40						; size = 4
tv3585 = -40						; size = 4
_first_fe$89459 = -40					; size = 4
_i$89449 = -36						; size = 4
_thiscount$89460 = -32					; size = 4
_first_fe$89379 = -32					; size = 4
tv3655 = -28						; size = 4
tv3607 = -28						; size = 4
tv3603 = -28						; size = 4
_count$89522 = -28					; size = 4
tv3728 = -24						; size = 4
tv3642 = -24						; size = 4
_f_id$ = -24						; size = 4
_fe_id$ = -24						; size = 4
tv3615 = -20						; size = 4
_e_id$ = -20						; size = 4
_count$ = -16						; size = 4
tv3645 = -12						; size = 4
tv3586 = -12						; size = 4
tv3588 = -8						; size = 4
_numerr$ = -4						; size = 4
_flag$ = 8						; size = 4
_facetedge_check PROC					; COMDAT

; 285  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi

; 286  :   vertex_id v_id;
; 287  :   edge_id e_id;
; 288  :   facet_id f_id;
; 289  :   facetedge_id fe_id,last_fe;
; 290  :   int count;
; 291  :   int numerr = 0;
; 292  :   int n;
; 293  : 
; 294  : #ifdef MPI_EVOLVER
; 295  :   if ( this_task == MASTER_TASK )
; 296  :     return 0;
; 297  : #endif
; 298  : 
; 299  :   /* check facetedge chain consistencies */
; 300  :   if ( numerr >= MAXERR ) numerr = 0;
; 301  :   count = 0;
; 302  :   MFOR_ALL_FACETEDGES(fe_id)

	mov	esi, DWORD PTR _web+496
	mov	DWORD PTR _fe_id$[ebp], esi
	xor	ebx, ebx
	xor	eax, eax
	shr	esi, 28					; 0000001cH
	and	esi, 1
	push	edi
	mov	edi, DWORD PTR _web+460
	mov	DWORD PTR _numerr$[ebp], ebx
	mov	DWORD PTR _count$[ebp], eax
	mov	DWORD PTR tv3586[ebp], esi
	je	$LN142@facetedge_
$LL144@facetedge_:
	mov	ebx, DWORD PTR _fe_id$[ebp]
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv3588[ebp], ebx
	je	$LN143@facetedge_

; 303  :   { facetedge_id fe;
; 304  : 
; 305  :     f_id = get_fe_facet(fe_id);

	test	esi, esi
	jne	SHORT $LN249@facetedge_
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN250@facetedge_
$LN249@facetedge_:
	test	DWORD PTR _fe_id$[ebp], 134217728	; 08000000H
	mov	ecx, DWORD PTR [ecx+24]
	je	SHORT $LN248@facetedge_
	xor	ecx, 134217728				; 08000000H
$LN248@facetedge_:
	mov	esi, ecx
$LN250@facetedge_:

; 306  :  #ifdef MPI_EVOLVER
; 307  : 	if ( (web.representation==SOAPFILM) || (id_task(f_id)==this_task) )
; 308  : #endif
; 309  :    if ( valid_id(f_id) && !valid_element(f_id) )

	mov	ebx, esi
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	je	SHORT $LN138@facetedge_
	push	esi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN458@facetedge_

; 310  :      { sprintf(errmsg,"Facetedge  %s links to invalid facet %08lX.\n",
; 311  :           ELNAME(fe_id), (unsigned long)f_id);

	cmp	DWORD PTR tv3586[ebp], eax
	je	SHORT $LN148@facetedge_
	mov	eax, DWORD PTR tv3588[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN149@facetedge_
$LN148@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN149@facetedge_:
	push	esi
	push	eax
	push	OFFSET ??_C@_0CN@KFNPPAEL@Facetedge?5?5?$CFs?5links?5to?5invalid?5f@
	push	OFFSET _errmsg
	call	_sprintf

; 312  :         erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 313  :         bad_errors_count++;
; 314  :         if ( ++numerr > MAXERR )

	mov	edi, DWORD PTR _numerr$[ebp]
	inc	DWORD PTR _bad_errors_count
	inc	edi
	add	esp, 20					; 00000014H
	mov	DWORD PTR _numerr$[ebp], edi
	cmp	edi, 20					; 00000014H
	jg	$LN418@facetedge_
$LN458@facetedge_:
	mov	edi, DWORD PTR _web+460
$LN138@facetedge_:

; 316  :      }
; 317  : #ifdef MPI_EVOLVER
; 318  : 	if ( (web.representation==SOAPFILM) || (id_task(f_id)==this_task) )
; 319  : #endif
; 320  :     if ( valid_id(f_id) && !valid_element(get_facet_fe(f_id)) )

	test	ebx, ebx
	je	$LN136@facetedge_
	mov	ecx, DWORD PTR _web+236
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	eax, DWORD PTR [edx+28]
	shr	esi, 27					; 0000001bH
	and	esi, 1
	je	SHORT $LN252@facetedge_
	xor	eax, 134217728				; 08000000H
$LN252@facetedge_:
	push	eax
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	$LN459@facetedge_

; 321  :     { sprintf(errmsg,"Facetedge %s links to facet %s with invalid facetedge %s.\n",
; 322  :         ELNAME(fe_id),ELNAME1(f_id),ELNAME2(get_facet_fe(f_id)));

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [ecx+28]
	mov	ecx, eax
	test	esi, esi
	je	SHORT $LN501@facetedge_
	xor	ecx, 134217728				; 08000000H
$LN501@facetedge_:
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN150@facetedge_
	test	esi, esi
	je	SHORT $LN260@facetedge_
	xor	eax, 134217728				; 08000000H
$LN260@facetedge_:
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+60
	jmp	SHORT $LN151@facetedge_
$LN150@facetedge_:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN151@facetedge_:
	inc	edi
	push	edi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR tv3586[ebp], 0
	je	SHORT $LN154@facetedge_
	mov	edx, DWORD PTR tv3588[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN155@facetedge_
$LN154@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN155@facetedge_:
	push	esi
	push	OFFSET _elnames+30
	push	eax
	push	OFFSET ??_C@_0DL@KGNCEJOB@Facetedge?5?$CFs?5links?5to?5facet?5?$CFs?5w@
	push	OFFSET _errmsg
	call	_sprintf

; 323  :       erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 324  :       bad_errors_count++;
; 325  :       if ( ++numerr > MAXERR )

	mov	esi, DWORD PTR _numerr$[ebp]
	inc	DWORD PTR _bad_errors_count
	inc	esi
	add	esp, 24					; 00000018H
	mov	DWORD PTR _numerr$[ebp], esi
	cmp	esi, 20					; 00000014H
	jg	$LN419@facetedge_
$LN459@facetedge_:
	mov	edi, DWORD PTR _web+460
$LN136@facetedge_:

; 327  :     }
; 328  :     e_id = get_fe_edge(fe_id);

	mov	ebx, DWORD PTR tv3588[ebp]
	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR [edi+ebx*4]
	mov	esi, DWORD PTR [ecx+20]
	and	eax, 134217728				; 08000000H
	xor	esi, eax
	mov	DWORD PTR tv3639[ebp], eax

; 329  :  #ifdef MPI_EVOLVER
; 330  :     if ( mpi_corona_state > NO_CORONA || id_task(e_id) == this_task )
; 331  :  #endif
; 332  :     
; 333  :     if ( valid_id(e_id) )

	test	esi, 268435456				; 10000000H
	je	$LN503@facetedge_

; 334  :     { if ( !valid_element(e_id) )

	push	esi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN134@facetedge_

; 335  :       { sprintf(msg,"Facetedge %s links to invalid edge %08lX.\n",
; 336  :             ELNAME(fe_id),(unsigned long)e_id);

	cmp	DWORD PTR tv3586[ebp], eax
	je	SHORT $LN156@facetedge_
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN157@facetedge_
$LN156@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN157@facetedge_:
	mov	edx, DWORD PTR _msg
	push	esi
	push	eax
	push	OFFSET ??_C@_0CL@KGKIEHFE@Facetedge?5?$CFs?5links?5to?5invalid?5ed@
	push	edx
	call	_sprintf

; 337  :          erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring

; 338  :          bad_errors_count++;
; 339  :          if ( ++numerr > MAXERR )

	mov	ebx, DWORD PTR _numerr$[ebp]
	inc	DWORD PTR _bad_errors_count
	inc	ebx
	add	esp, 20					; 00000014H
	mov	DWORD PTR _numerr$[ebp], ebx
	cmp	ebx, 20					; 00000014H
	jg	$LN420@facetedge_

; 341  :       }
; 342  :       else

	mov	edi, DWORD PTR _web+460
	jmp	$LN130@facetedge_
$LN134@facetedge_:

; 343  :       { facetedge_id ffe_id = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edi*4]
	test	eax, eax
	jne	SHORT $LN267@facetedge_
	xor	esi, esi
	jmp	SHORT $LN268@facetedge_
$LN267@facetedge_:
	mov	eax, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN266@facetedge_
	xor	eax, 134217728				; 08000000H
$LN266@facetedge_:
	mov	esi, eax
$LN268@facetedge_:

; 344  :         if ( valid_id(e_id) && !valid_element(ffe_id) )

	push	esi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	$LN502@facetedge_

; 345  :         { sprintf(msg,"Facetedge %s links to edge %s with invalid facetedge %s.\n",
; 346  :            ELNAME(fe_id),ELNAME1(e_id),ELNAME2(ffe_id));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN158@facetedge_
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+60
	jmp	SHORT $LN159@facetedge_
$LN158@facetedge_:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN159@facetedge_:
	inc	edi
	push	edi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR tv3586[ebp], 0
	je	SHORT $LN162@facetedge_
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN163@facetedge_
$LN162@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN163@facetedge_:
	mov	edx, DWORD PTR _msg
	push	esi
	push	OFFSET _elnames+30
	push	eax
	push	OFFSET ??_C@_0DK@FENCHNIC@Facetedge?5?$CFs?5links?5to?5edge?5?$CFs?5wi@
	push	edx
	call	_sprintf

; 347  :            erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring

; 348  :            bad_errors_count++;
; 349  :            if ( ++numerr > MAXERR )

	mov	ebx, DWORD PTR _numerr$[ebp]
	inc	DWORD PTR _bad_errors_count
	inc	ebx
	add	esp, 24					; 00000018H
	mov	DWORD PTR _numerr$[ebp], ebx
	cmp	ebx, 20					; 00000014H
	jle	SHORT $LN460@facetedge_
$LN420@facetedge_:

; 340  :               {erroutstring("Too many errors.\n"); return numerr;}

	push	OFFSET ??_C@_0BC@CGAIEGBL@Too?5many?5errors?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 732  : } /* end facetedge_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN502@facetedge_:

; 348  :            bad_errors_count++;
; 349  :            if ( ++numerr > MAXERR )

	mov	ebx, DWORD PTR _numerr$[ebp]
$LN460@facetedge_:
	mov	edi, DWORD PTR _web+460
	jmp	SHORT $LN130@facetedge_
$LN503@facetedge_:

; 341  :       }
; 342  :       else

	mov	ebx, DWORD PTR _numerr$[ebp]
$LN130@facetedge_:

; 350  :            {erroutstring("Too many errors.\n"); return numerr;}
; 351  :         }
; 352  :       }
; 353  :     }
; 354  :     fe = get_prev_edge(fe_id);

	mov	eax, DWORD PTR _fe_id$[ebp]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv3603[ebp], eax
	je	SHORT $LN271@facetedge_
	mov	ecx, DWORD PTR tv3588[ebp]
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	esi, DWORD PTR [edx+32]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN270@facetedge_
$LN271@facetedge_:
	mov	eax, DWORD PTR tv3588[ebp]
	mov	ecx, DWORD PTR [edi+eax*4]
	mov	esi, DWORD PTR [ecx+28]
$LN270@facetedge_:

; 355  :     if ( valid_id(fe) && (!valid_element(fe) || !equal_id(get_next_edge(fe),fe_id)) )

	test	esi, 268435456				; 10000000H
	je	$LN127@facetedge_
	push	esi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	je	SHORT $LN128@facetedge_
	mov	edi, DWORD PTR _web+460
	test	esi, 134217728				; 08000000H
	je	SHORT $LN275@facetedge_
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN274@facetedge_
$LN275@facetedge_:
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [eax+32]
$LN274@facetedge_:
	cmp	eax, DWORD PTR _fe_id$[ebp]
	je	SHORT $LN127@facetedge_
$LN128@facetedge_:

; 356  :     { sprintf(msg,"Facetedge %s has bad prev edge link\n",ELNAME(fe_id));

	cmp	DWORD PTR tv3586[ebp], 0
	je	SHORT $LN164@facetedge_
	mov	ecx, DWORD PTR tv3588[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN165@facetedge_
$LN164@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN165@facetedge_:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0CF@IKGAGGBK@Facetedge?5?$CFs?5has?5bad?5prev?5edge?5l@
	push	edx
	call	_sprintf

; 357  :       erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring

; 358  :       bad_next_prev_count++;

	inc	DWORD PTR _bad_next_prev_count

; 359  :       if ( ++numerr > MAXERR )

	inc	ebx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _numerr$[ebp], ebx
	cmp	ebx, 20					; 00000014H
	jg	$LN420@facetedge_
	mov	edi, DWORD PTR _web+460
$LN127@facetedge_:

; 360  :       {erroutstring("Too many errors.\n"); return numerr;}
; 361  :     }
; 362  :     fe = get_next_edge(fe_id);

	cmp	DWORD PTR tv3603[ebp], 0
	je	SHORT $LN279@facetedge_
	mov	ecx, DWORD PTR tv3588[ebp]
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	esi, DWORD PTR [edx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN278@facetedge_
$LN279@facetedge_:
	mov	eax, DWORD PTR tv3588[ebp]
	mov	ecx, DWORD PTR [edi+eax*4]
	mov	esi, DWORD PTR [ecx+32]
$LN278@facetedge_:

; 363  :     if ( valid_id(fe) && (!valid_element(fe) || !equal_id(get_prev_edge(fe),fe_id)) )

	test	esi, 268435456				; 10000000H
	je	$LN124@facetedge_
	push	esi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	je	SHORT $LN125@facetedge_
	mov	edi, DWORD PTR _web+460
	test	esi, 134217728				; 08000000H
	je	SHORT $LN283@facetedge_
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN282@facetedge_
$LN283@facetedge_:
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [eax+28]
$LN282@facetedge_:
	cmp	eax, DWORD PTR _fe_id$[ebp]
	je	SHORT $LN124@facetedge_
$LN125@facetedge_:

; 364  :     { sprintf(msg,"Facetedge %s has bad next edge link\n",ELNAME(fe_id));

	cmp	DWORD PTR tv3586[ebp], 0
	je	SHORT $LN166@facetedge_
	mov	ecx, DWORD PTR tv3588[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN167@facetedge_
$LN166@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN167@facetedge_:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0CF@CCLCMHAG@Facetedge?5?$CFs?5has?5bad?5next?5edge?5l@
	push	edx
	call	_sprintf

; 365  :       erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring

; 366  :       bad_next_prev_count++;

	inc	DWORD PTR _bad_next_prev_count

; 367  :       if ( ++numerr > MAXERR )

	inc	ebx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _numerr$[ebp], ebx
	cmp	ebx, 20					; 00000014H
	jg	$LN420@facetedge_
	mov	edi, DWORD PTR _web+460
$LN124@facetedge_:

; 368  :       {erroutstring("Too many errors.\n"); return numerr;}
; 369  :     }
; 370  :     fe = get_next_facet(fe_id);

	cmp	DWORD PTR tv3603[ebp], 0
	mov	esi, DWORD PTR tv3588[ebp]
	je	SHORT $LN287@facetedge_
	mov	ecx, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [ecx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN286@facetedge_
$LN287@facetedge_:
	mov	edx, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [edx+40]
$LN286@facetedge_:

; 371  :     if ( valid_id(fe) && !equal_id(get_prev_facet(fe),fe_id) )

	test	eax, 268435456				; 10000000H
	je	$LN506@facetedge_
	test	eax, 134217728				; 08000000H
	je	SHORT $LN291@facetedge_
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+40]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN290@facetedge_
$LN291@facetedge_:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ecx+36]
$LN290@facetedge_:
	cmp	eax, DWORD PTR _fe_id$[ebp]
	je	SHORT $LN506@facetedge_

; 372  :     { sprintf(msg,"Facetedge %s has bad next facet link\n",ELNAME(fe_id));

	cmp	DWORD PTR tv3586[ebp], 0
	je	SHORT $LN168@facetedge_
	lea	edx, DWORD PTR [esi+1]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN169@facetedge_
$LN168@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN169@facetedge_:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0CG@NCGNNPAH@Facetedge?5?$CFs?5has?5bad?5next?5facet?5@
	push	eax
	call	_sprintf

; 373  :       erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 374  :       bad_next_prev_count++;

	inc	DWORD PTR _bad_next_prev_count

; 375  :       if ( ++numerr > MAXERR )

	inc	ebx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _numerr$[ebp], ebx
	cmp	ebx, 20					; 00000014H
	jg	$LN420@facetedge_
	mov	edi, DWORD PTR _web+460
$LN506@facetedge_:

; 376  :       {erroutstring("Too many errors.\n"); return numerr;}
; 377  :     }
; 378  :     fe = get_prev_facet(fe_id);

	cmp	DWORD PTR tv3603[ebp], 0
	je	SHORT $LN295@facetedge_
	mov	edx, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [edx+40]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN294@facetedge_
$LN295@facetedge_:
	mov	eax, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [eax+36]
$LN294@facetedge_:

; 379  :     if ( valid_id(fe) && !equal_id(get_next_facet(fe),fe_id) )

	test	eax, 268435456				; 10000000H
	je	$LN120@facetedge_
	test	eax, 134217728				; 08000000H
	je	SHORT $LN299@facetedge_
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ecx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN298@facetedge_
$LN299@facetedge_:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [edx+40]
$LN298@facetedge_:
	cmp	eax, DWORD PTR _fe_id$[ebp]
	je	SHORT $LN120@facetedge_

; 380  :     { sprintf(msg,"Facetedge %s has bad prev facet link\n",ELNAME(fe_id));

	cmp	DWORD PTR tv3586[ebp], 0
	je	SHORT $LN170@facetedge_
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN171@facetedge_
$LN170@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN171@facetedge_:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0CG@MGMEFBOJ@Facetedge?5?$CFs?5has?5bad?5prev?5facet?5@
	push	eax
	call	_sprintf

; 381  :       erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 382  :       bad_next_prev_count++;

	inc	DWORD PTR _bad_next_prev_count

; 383  :       if ( ++numerr > MAXERR )

	inc	ebx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _numerr$[ebp], ebx
	cmp	ebx, 20					; 00000014H
	jg	$LN420@facetedge_
	mov	edi, DWORD PTR _web+460
$LN120@facetedge_:

; 384  :       {erroutstring("Too many errors.\n"); return numerr;}
; 385  :     }
; 386  :     fe = get_next_edge(fe_id);

	cmp	DWORD PTR tv3603[ebp], 0
	je	SHORT $LN303@facetedge_
	mov	edx, DWORD PTR tv3588[ebp]
	mov	esi, DWORD PTR [edi+edx*4]
	mov	eax, DWORD PTR [esi+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN302@facetedge_
$LN303@facetedge_:
	mov	eax, DWORD PTR tv3588[ebp]
	mov	esi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi+32]
$LN302@facetedge_:

; 387  : #ifndef MPI_EVOLVER
; 388  :     if ( valid_id(fe) && !equal_id(get_fe_headv(fe_id),get_fe_tailv(fe)) )

	test	eax, 268435456				; 10000000H
	je	$LN508@facetedge_
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	eax
	call	_get_edge_tailv
	mov	ecx, DWORD PTR [esi+20]
	xor	ecx, DWORD PTR tv3639[ebp]
	mov	DWORD PTR tv3668[ebp], eax
	push	ecx
	call	_get_edge_headv
	add	esp, 8
	cmp	eax, DWORD PTR tv3668[ebp]
	je	SHORT $LN508@facetedge_

; 389  :     { sprintf(msg,"Facetedge %s head vertex disagrees with next tail.\n",
; 390  :       ELNAME(fe_id));

	cmp	DWORD PTR tv3586[ebp], 0
	je	SHORT $LN172@facetedge_
	mov	edx, DWORD PTR tv3588[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN173@facetedge_
$LN172@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN173@facetedge_:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0DE@DDDHPJPA@Facetedge?5?$CFs?5head?5vertex?5disagre@
	push	eax
	call	_sprintf

; 391  :       erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 392  :       bad_next_prev_count++;

	inc	DWORD PTR _bad_next_prev_count

; 393  :       if ( ++numerr > MAXERR )

	inc	ebx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _numerr$[ebp], ebx
	cmp	ebx, 20					; 00000014H
	jg	$LN420@facetedge_
	mov	edi, DWORD PTR _web+460
$LN508@facetedge_:

; 394  :       {erroutstring("Too many errors.\n"); return numerr;}
; 395  :     }
; 396  : #endif
; 397  :     fe = get_prev_edge(fe_id);

	cmp	DWORD PTR tv3603[ebp], 0
	je	SHORT $LN311@facetedge_
	mov	edx, DWORD PTR tv3588[ebp]
	mov	esi, DWORD PTR [edi+edx*4]
	mov	eax, DWORD PTR [esi+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN310@facetedge_
$LN311@facetedge_:
	mov	eax, DWORD PTR tv3588[ebp]
	mov	esi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi+28]
$LN310@facetedge_:

; 398  : #ifndef MPI_EVOLVER
; 399  :     if ( valid_id(fe) && !equal_id(get_fe_tailv(fe_id),get_fe_headv(fe)) )

	test	eax, 268435456				; 10000000H
	je	$LN509@facetedge_
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	eax
	call	_get_edge_headv
	mov	ecx, DWORD PTR [esi+20]
	xor	ecx, DWORD PTR tv3639[ebp]
	mov	DWORD PTR tv3666[ebp], eax
	push	ecx
	call	_get_edge_tailv
	add	esp, 8
	cmp	eax, DWORD PTR tv3666[ebp]
	je	SHORT $LN509@facetedge_

; 400  :     { sprintf(msg,"Facetedge %s tail vertex disagrees with prev head.\n",
; 401  :       ELNAME(fe_id));

	cmp	DWORD PTR tv3586[ebp], 0
	je	SHORT $LN174@facetedge_
	mov	edx, DWORD PTR tv3588[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN175@facetedge_
$LN174@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN175@facetedge_:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0DE@FPNANCGF@Facetedge?5?$CFs?5tail?5vertex?5disagre@
	push	eax
	call	_sprintf

; 402  :       erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 403  :       bad_next_prev_count++;

	inc	DWORD PTR _bad_next_prev_count

; 404  :       if ( ++numerr > MAXERR )

	inc	ebx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _numerr$[ebp], ebx
	cmp	ebx, 20					; 00000014H
	jg	$LN420@facetedge_
	mov	edi, DWORD PTR _web+460
$LN509@facetedge_:

; 405  :       {erroutstring("Too many errors.\n"); return numerr;}
; 406  :     }
; 407  : #endif
; 408  :     count++;

	inc	DWORD PTR _count$[ebp]
	mov	ebx, DWORD PTR tv3588[ebp]
$LN143@facetedge_:

; 286  :   vertex_id v_id;
; 287  :   edge_id e_id;
; 288  :   facet_id f_id;
; 289  :   facetedge_id fe_id,last_fe;
; 290  :   int count;
; 291  :   int numerr = 0;
; 292  :   int n;
; 293  : 
; 294  : #ifdef MPI_EVOLVER
; 295  :   if ( this_task == MASTER_TASK )
; 296  :     return 0;
; 297  : #endif
; 298  : 
; 299  :   /* check facetedge chain consistencies */
; 300  :   if ( numerr >= MAXERR ) numerr = 0;
; 301  :   count = 0;
; 302  :   MFOR_ALL_FACETEDGES(fe_id)

	mov	edx, DWORD PTR [edi+ebx*4]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR _fe_id$[ebp], esi
	shr	esi, 28					; 0000001cH
	and	esi, 1
	mov	DWORD PTR tv3586[ebp], esi
	jne	$LL144@facetedge_

; 710  :         if ( equal_id(fe_id,start_fe) )

	mov	eax, DWORD PTR _count$[ebp]
	mov	ebx, DWORD PTR _numerr$[ebp]
$LN142@facetedge_:

; 409  :   }
; 410  :   if ( count != web.skel[FACETEDGE].count )

	mov	ecx, DWORD PTR _web+512
	cmp	eax, ecx
	je	SHORT $LN114@facetedge_

; 411  :   { sprintf(msg,"Only %d facetedges out of %ld generated.\n",
; 412  :          count,web.skel[FACETEDGE].count);

	push	ecx
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0CK@EELEPEOJ@Only?5?$CFd?5facetedges?5out?5of?5?$CFld?5ge@
	push	eax
	call	_sprintf

; 413  :     erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 414  :     bad_errors_count++;

	inc	DWORD PTR _bad_errors_count

; 415  :     if ( ++numerr > MAXERR )

	inc	ebx
	add	esp, 20					; 00000014H
	mov	DWORD PTR _numerr$[ebp], ebx
	cmp	ebx, 20					; 00000014H

; 416  :     {erroutstring("Too many errors.\n"); return numerr;}

	jg	$LN420@facetedge_
	mov	edi, DWORD PTR _web+460
$LN114@facetedge_:

; 417  :   }
; 418  : 
; 419  :   /* check that vertices have legit edge link */
; 420  :   FOR_ALL_VERTICES(v_id)

	mov	ebx, DWORD PTR _web+48
	mov	eax, ebx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv3728[ebp], eax
	je	$LN469@facetedge_
	npad	9
$LL480@facetedge_:
	mov	edx, DWORD PTR _web+12
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv3737[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN112@facetedge_

; 421  :   { size_t orig;
; 422  :     e_id = get_vertex_edge(v_id);

	mov	esi, DWORD PTR [edx+28]

; 423  :     if ( !valid_id(e_id) )

	test	esi, 268435456				; 10000000H
	jne	$LN108@facetedge_

; 424  :     { if ( !(get_vattr(v_id) & BARE_NAKED) )

	and	ecx, 65536				; 00010000H
	xor	eax, eax
	or	ecx, eax
	jne	$LN112@facetedge_

; 425  :       { sprintf(errmsg,"Vertex %s has no edges.\n",
; 426  :           ELNAME(v_id));

	mov	esi, DWORD PTR tv3728[ebp]
	test	esi, esi
	je	SHORT $LN176@facetedge_
	lea	ecx, DWORD PTR [edi+1]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN177@facetedge_
$LN418@facetedge_:

; 315  :         {erroutstring("Too many errors.\n"); return numerr;}

	push	OFFSET ??_C@_0BC@CGAIEGBL@Too?5many?5errors?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 732  : } /* end facetedge_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN419@facetedge_:

; 326  :       {erroutstring("Too many errors.\n"); return numerr;}

	push	OFFSET ??_C@_0BC@CGAIEGBL@Too?5many?5errors?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 732  : } /* end facetedge_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN176@facetedge_:

; 425  :       { sprintf(errmsg,"Vertex %s has no edges.\n",
; 426  :           ELNAME(v_id));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN177@facetedge_:
	push	eax
	push	OFFSET ??_C@_0BJ@MADMBEHM@Vertex?5?$CFs?5has?5no?5edges?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 427  :         erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 428  :         orig = get_original(v_id);

	mov	edx, ebx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [ecx+20]
	add	esp, 16					; 00000010H

; 429  :         if ( valid_id(orig) && !equal_element(orig,v_id) )

	test	eax, 268435456				; 10000000H
	je	$LN112@facetedge_
	or	eax, 134217728				; 08000000H
	or	ebx, 134217728				; 08000000H
	cmp	eax, ebx
	je	$LN112@facetedge_

; 430  :         { sprintf(errmsg,"      (originally vertex %s)\n",ELNAME(v_id));

	test	esi, esi
	je	SHORT $LN178@facetedge_
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN179@facetedge_
$LN178@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN179@facetedge_:
	push	eax
	push	OFFSET ??_C@_0BO@GLNHAGJF@?5?5?5?5?5?5?$CIoriginally?5vertex?5?$CFs?$CJ?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 431  :           erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 16					; 00000010H

; 432  :         }
; 433  :       }
; 434  :       continue;

	jmp	$LN112@facetedge_
$LN108@facetedge_:

; 435  :     }
; 436  :     if ( !valid_element(e_id) ) 

	push	esi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN105@facetedge_

; 437  :     { sprintf(errmsg,"Vertex %s has invalid edge link.\n",
; 438  :           ELNAME(v_id)+1);

	cmp	DWORD PTR tv3728[ebp], eax
	je	SHORT $LN180@facetedge_
	lea	eax, DWORD PTR [edi+1]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN181@facetedge_
$LN180@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN181@facetedge_:
	inc	eax
	push	eax
	push	OFFSET ??_C@_0CC@GIACHLB@Vertex?5?$CFs?5has?5invalid?5edge?5link?4@
	push	OFFSET _errmsg
	call	_sprintf

; 439  :       kb_error(1829,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1829					; 00000725H

; 440  :       bad_errors_count++;
; 441  :       if ( ++numerr > MAXERR )
; 442  :       {erroutstring("Too many errors.\n"); return numerr;}  
; 443  :       continue;

	jmp	$LN517@facetedge_
$LN105@facetedge_:

; 444  :     }
; 445  :     else if (get_vattr(v_id) & Q_MIDPOINT)

	mov	ecx, DWORD PTR _web+12
	mov	eax, DWORD PTR [ecx+edi*4]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	mov	DWORD PTR tv3737[ebp+4], edx
	and	eax, 131072				; 00020000H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN102@facetedge_

; 446  :     { if ( !equal_id(v_id,get_edge_midv(e_id)) )

	mov	eax, DWORD PTR _web+124
	mov	edx, DWORD PTR _web+216
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+304]
	cmp	ebx, DWORD PTR [ecx+edx+8]
	je	$LN112@facetedge_

; 447  :       { sprintf(errmsg,"Vertex %s has bad midpoint edge link.\n",ELNAME(v_id));

	cmp	DWORD PTR tv3728[ebp], 0
	je	SHORT $LN182@facetedge_
	lea	eax, DWORD PTR [edi+1]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN183@facetedge_
$LN182@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN183@facetedge_:
	push	eax
	push	OFFSET ??_C@_0CH@GDOFEGMG@Vertex?5?$CFs?5has?5bad?5midpoint?5edge?5@
	push	OFFSET _errmsg
	call	_sprintf

; 448  :         kb_error(1830,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1830					; 00000726H

; 449  :         bad_errors_count++;
; 450  :         if ( ++numerr > MAXERR )
; 451  :         {erroutstring("Too many errors.\n"); return numerr;}   
; 452  :         continue;

	jmp	$LN517@facetedge_
$LN102@facetedge_:

; 453  :       }
; 454  :     }
; 455  :     else if (get_vattr(v_id) & Q_MIDEDGE)

	mov	eax, ecx
	and	eax, 4194304				; 00400000H
	xor	edx, edx
	or	eax, edx
	je	$LN98@facetedge_

; 456  :     { vertex_id *v = get_edge_vertices(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+esi*4]
	add	esi, DWORD PTR [edx+eax+304]

; 457  :       int i;
; 458  :       for ( i = 0 ; i <= web.lagrange_order ; i++ )

	mov	ecx, DWORD PTR _web+632
	xor	eax, eax
	test	ecx, ecx
	js	SHORT $LN481@facetedge_
	npad	6
$LL97@facetedge_:

; 459  :          if ( equal_id(v_id,v[i]) ) break;

	cmp	ebx, DWORD PTR [esi+eax*4]
	je	SHORT $LN481@facetedge_

; 457  :       int i;
; 458  :       for ( i = 0 ; i <= web.lagrange_order ; i++ )

	inc	eax
	cmp	eax, ecx
	jle	SHORT $LL97@facetedge_
$LN481@facetedge_:

; 460  :       bad_errors_count++;

	inc	DWORD PTR _bad_errors_count

; 461  :       if ( i > web.lagrange_order )

	cmp	eax, ecx
	jle	$LN112@facetedge_

; 462  :       { sprintf(errmsg,"Vertex %s has bad edge link.\n",ELNAME(v_id));

	cmp	DWORD PTR tv3728[ebp], 0
	je	SHORT $LN184@facetedge_
	lea	ecx, DWORD PTR [edi+1]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN185@facetedge_
$LN184@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN185@facetedge_:
	push	eax
	push	OFFSET ??_C@_0BO@LOFCFJMK@Vertex?5?$CFs?5has?5bad?5edge?5link?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 463  :         kb_error(1831,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1831					; 00000727H
	call	_kb_error

; 464  :         if ( ++numerr > MAXERR )
; 465  :               {erroutstring("Too many errors.\n"); return numerr;}   
; 466  :       }

	jmp	SHORT $LN518@facetedge_
$LN98@facetedge_:

; 467  :     }
; 468  :     else if (get_vattr(v_id) & Q_MIDFACET) { }

	and	ecx, 2097152				; 00200000H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN112@facetedge_

; 469  :     else if ( !equal_id(v_id,get_edge_tailv(e_id)) )

	push	esi
	call	_get_edge_tailv
	add	esp, 4
	cmp	ebx, eax
	je	SHORT $LN112@facetedge_

; 470  :      { sprintf(errmsg,"Vertex %s has bad edge link.\n",ELNAME(v_id));

	cmp	DWORD PTR tv3728[ebp], 0
	je	SHORT $LN186@facetedge_
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN187@facetedge_
$LN186@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN187@facetedge_:
	push	eax
	push	OFFSET ??_C@_0BO@LOFCFJMK@Vertex?5?$CFs?5has?5bad?5edge?5link?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 471  :        kb_error(1832,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1832					; 00000728H
$LN517@facetedge_:
	call	_kb_error

; 472  :        bad_errors_count++;

	inc	DWORD PTR _bad_errors_count
$LN518@facetedge_:

; 473  :        if ( ++numerr > MAXERR )

	mov	esi, DWORD PTR _numerr$[ebp]
	inc	esi
	add	esp, 24					; 00000018H
	mov	DWORD PTR _numerr$[ebp], esi
	cmp	esi, 20					; 00000014H
	jg	$LN419@facetedge_
$LN112@facetedge_:

; 417  :   }
; 418  : 
; 419  :   /* check that vertices have legit edge link */
; 420  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	ebx, DWORD PTR [ecx]
	mov	eax, ebx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv3728[ebp], eax
	jne	$LL480@facetedge_

; 710  :         if ( equal_id(fe_id,start_fe) )

	mov	edi, DWORD PTR _web+460
$LN469@facetedge_:

; 474  :        {erroutstring("Too many errors.\n"); return numerr;}   
; 475  :        continue;
; 476  :      }
; 477  :   } /* end vertices */
; 478  : 
; 479  :   FOR_ALL_EDGES(e_id)

	mov	ebx, DWORD PTR _web+160
	mov	edx, DWORD PTR _web+124
	mov	eax, ebx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _e_id$[ebp], ebx
	mov	DWORD PTR tv3642[ebp], eax
	je	$LN470@facetedge_
	npad	1
$LL498@facetedge_:
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv3645[ebp], edi
	je	$LN85@facetedge_

; 480  :   { edge_id ee_id;
; 481  : 
; 482  :     v_id = get_edge_tailv(e_id);

	mov	esi, DWORD PTR _dymem
	mov	eax, ebx
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv3655[ebp], eax
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+esi+304]
	je	SHORT $LN319@facetedge_
	mov	esi, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [eax+ecx]
	jmp	SHORT $LN318@facetedge_
$LN319@facetedge_:
	mov	esi, DWORD PTR [ecx+eax]
$LN318@facetedge_:

; 517  :   FOR_ALL_EDGES(e_id)

	mov	edi, DWORD PTR _web+176
	xor	ecx, ecx
	mov	eax, ebx
	add	edi, edi
	npad	6
$LL81@facetedge_:

; 483  :     n = 0; ee_id = e_id;
; 484  :     do 
; 485  :     { ee_id = get_next_tail_edge(ee_id); 

	mov	ebx, eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	shr	ebx, 27					; 0000001bH
	and	ebx, 1
	mov	eax, DWORD PTR [eax+ebx*4+32]

; 486  :       if ( ++n > 2*web.skel[EDGE].count )

	inc	ecx
	cmp	ecx, edi
	jg	SHORT $LN433@facetedge_

; 492  :         {erroutstring("Too many errors.\n"); return numerr;}
; 493  :         break;
; 494  :       }
; 495  :     }
; 496  :     while ( !equal_id(ee_id,e_id) );

	cmp	eax, DWORD PTR _e_id$[ebp]
	jne	SHORT $LL81@facetedge_
	jmp	$LN79@facetedge_
$LN433@facetedge_:

; 487  :       { sprintf(errmsg,"Vertex %s has bad edge loop from edge %s.\n",
; 488  :             ELNAME(v_id),ELNAME1(e_id));

	cmp	DWORD PTR tv3642[ebp], 0
	je	SHORT $LN188@facetedge_
	mov	ecx, DWORD PTR tv3645[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	edi, OFFSET _elnames+30
	jmp	SHORT $LN189@facetedge_
$LN188@facetedge_:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN189@facetedge_:
	test	esi, 268435456				; 10000000H
	je	SHORT $LN190@facetedge_
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN191@facetedge_
$LN190@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN191@facetedge_:
	push	edi
	push	eax
	push	OFFSET ??_C@_0CL@FJKCCBMP@Vertex?5?$CFs?5has?5bad?5edge?5loop?5from@
	push	OFFSET _errmsg
	call	_sprintf

; 489  :         kb_error(1833,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1833					; 00000729H
	call	_kb_error

; 490  :         bad_errors_count++;
; 491  :         if ( ++numerr > MAXERR )

	mov	esi, DWORD PTR _numerr$[ebp]
	inc	DWORD PTR _bad_errors_count
	inc	esi
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _numerr$[ebp], esi
	cmp	esi, 20					; 00000014H
	jg	$LN419@facetedge_
	mov	edx, DWORD PTR _web+124
$LN79@facetedge_:

; 497  :     v_id = get_edge_headv(e_id);

	cmp	DWORD PTR tv3655[ebp], 0
	mov	esi, DWORD PTR _dymem
	je	SHORT $LN325@facetedge_
	mov	eax, DWORD PTR tv3645[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+esi+304]
	mov	esi, DWORD PTR [ecx+eax]
	jmp	SHORT $LN324@facetedge_
$LN325@facetedge_:
	mov	ecx, DWORD PTR tv3645[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+216
	add	eax, DWORD PTR [ecx+esi+304]
	mov	ecx, DWORD PTR _web+636
	mov	esi, DWORD PTR [eax+ecx*4]
$LN324@facetedge_:

; 517  :   FOR_ALL_EDGES(e_id)

	mov	edi, DWORD PTR _web+176
	mov	eax, DWORD PTR _e_id$[ebp]
	xor	ecx, ecx
	add	edi, edi
	npad	9
$LL76@facetedge_:

; 498  :     n = 0; ee_id = e_id;
; 499  :     do 
; 500  :     { ee_id = get_next_head_edge(ee_id); 

	mov	ebx, eax
	shr	ebx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	not	ebx
	and	ebx, 1
	mov	eax, DWORD PTR [eax+ebx*4+32]

; 501  :       if ( ++n > 2*web.skel[EDGE].count )

	inc	ecx
	xor	eax, 134217728				; 08000000H
	cmp	ecx, edi
	jg	$LN434@facetedge_

; 507  :         {erroutstring("Too many errors.\n"); return numerr;} 
; 508  :         break;
; 509  :       }
; 510  :     }
; 511  :     while ( !equal_id(ee_id,e_id) );

	cmp	eax, DWORD PTR _e_id$[ebp]
	jne	SHORT $LL76@facetedge_

; 505  :         bad_errors_count++;
; 506  :         if ( ++numerr > MAXERR )

	mov	edi, DWORD PTR tv3645[ebp]
$LN85@facetedge_:

; 474  :        {erroutstring("Too many errors.\n"); return numerr;}   
; 475  :        continue;
; 476  :      }
; 477  :   } /* end vertices */
; 478  : 
; 479  :   FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR [edx+edi*4]
	mov	ebx, DWORD PTR [eax]
	mov	eax, ebx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _e_id$[ebp], ebx
	mov	DWORD PTR tv3642[ebp], eax
	jne	$LL498@facetedge_

; 710  :         if ( equal_id(fe_id,start_fe) )

	mov	edi, DWORD PTR _web+460
$LN470@facetedge_:

; 512  :   } /* end edges */
; 513  : 
; 514  :   /* some more checks on edges */
; 515  :   count = 0;

	xor	eax, eax
	mov	DWORD PTR _count$[ebp], eax

; 516  :   bare_edge_count = 0;

	mov	DWORD PTR _bare_edge_count, eax

; 517  :   FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+160
	mov	DWORD PTR _e_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv3642[ebp], eax
	je	$LN473@facetedge_
	npad	4
$LL71@facetedge_:
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv3645[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN70@facetedge_

; 518  :   { vertex_id v_id = get_edge_headv(e_id);

	mov	edx, DWORD PTR _e_id$[ebp]
	mov	eax, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+esi+304]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	DWORD PTR tv3655[ebp], edx
	je	$LN331@facetedge_
	mov	ebx, DWORD PTR [ecx+eax]
	jmp	$LN330@facetedge_
$LN434@facetedge_:

; 502  :       { sprintf(errmsg,"Vertex %s has bad edge loop from edge %s.\n",
; 503  :             ELNAME(v_id),ELNAME1(e_id));

	cmp	DWORD PTR tv3642[ebp], 0
	mov	edi, DWORD PTR tv3645[ebp]
	je	SHORT $LN192@facetedge_
	lea	ecx, DWORD PTR [edi+1]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	ebx, OFFSET _elnames+30
	jmp	SHORT $LN193@facetedge_
$LN192@facetedge_:
	mov	ebx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN193@facetedge_:
	test	esi, 268435456				; 10000000H
	je	SHORT $LN194@facetedge_
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN195@facetedge_
$LN194@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN195@facetedge_:
	push	ebx
	push	eax
	push	OFFSET ??_C@_0CL@FJKCCBMP@Vertex?5?$CFs?5has?5bad?5edge?5loop?5from@
	push	OFFSET _errmsg
	call	_sprintf

; 504  :         kb_error(1834,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1834					; 0000072aH
	call	_kb_error

; 505  :         bad_errors_count++;
; 506  :         if ( ++numerr > MAXERR )

	mov	esi, DWORD PTR _numerr$[ebp]
	inc	DWORD PTR _bad_errors_count
	inc	esi
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _numerr$[ebp], esi
	cmp	esi, 20					; 00000014H
	jg	$LN419@facetedge_
	mov	edx, DWORD PTR _web+124
	jmp	$LN85@facetedge_

; 518  :   { vertex_id v_id = get_edge_headv(e_id);

$LN331@facetedge_:
	mov	esi, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+esi*4]
	mov	ebx, DWORD PTR [eax+ecx]
$LN330@facetedge_:

; 519  :     facetedge_id first_fe;
; 520  : 
; 521  : #ifdef MPI_EVOLVER
; 522  :     if ( mpi_corona_state > NO_CORONA || id_task(v_id) == this_task )
; 523  : #endif
; 524  :     if ( get_vattr(v_id) & AXIAL_POINT )

	mov	ecx, DWORD PTR _web+12
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN485@facetedge_

; 525  :     { sprintf(msg,"Vertex %s is axial and not first vertex of edge %s.\n",
; 526  :             ELNAME(v_id),ELNAME1(e_id));

	cmp	DWORD PTR tv3642[ebp], ecx
	je	SHORT $LN196@facetedge_
	mov	edx, DWORD PTR tv3645[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	edi, OFFSET _elnames+30
	jmp	SHORT $LN197@facetedge_
$LN196@facetedge_:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN197@facetedge_:
	test	ebx, 268435456				; 10000000H
	je	SHORT $LN198@facetedge_
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN199@facetedge_
$LN198@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN199@facetedge_:
	push	edi
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0DF@BGOLIMCI@Vertex?5?$CFs?5is?5axial?5and?5not?5first@
	push	eax
	call	_sprintf

; 527  :       erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 528  :       if ( ++numerr > MAXERR )

	mov	esi, DWORD PTR _numerr$[ebp]
	inc	esi
	add	esp, 20					; 00000014H
	mov	DWORD PTR _numerr$[ebp], esi
	cmp	esi, 20					; 00000014H
	jg	$LN419@facetedge_
	mov	edi, DWORD PTR _web+460
	mov	edx, DWORD PTR tv3655[ebp]
$LN485@facetedge_:

; 529  :       {erroutstring("Too many errors.\n"); return numerr;}
; 530  :    
; 531  :     }
; 532  :     last_fe = NULLID;
; 533  :     fe_id = first_fe = get_edge_fe(e_id);

	mov	eax, DWORD PTR tv3645[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	jne	SHORT $LN335@facetedge_
	mov	DWORD PTR _first_fe$89379[ebp], eax
	jmp	SHORT $LN336@facetedge_
$LN335@facetedge_:
	mov	eax, DWORD PTR [eax+28]
	test	edx, edx
	je	SHORT $LN486@facetedge_
	xor	eax, 134217728				; 08000000H
$LN486@facetedge_:
	mov	DWORD PTR _first_fe$89379[ebp], eax
$LN336@facetedge_:
	mov	eax, DWORD PTR _first_fe$89379[ebp]
	mov	ebx, eax

; 534  :     if ( valid_id(fe_id) ) do

	shr	eax, 28					; 0000001cH
	mov	DWORD PTR tv3585[ebp], eax
	test	al, 1
	je	$LN457@facetedge_
	npad	1
$LL63@facetedge_:

; 535  :     { edge_id ee_id = get_fe_edge(fe_id);

	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+eax*4]
	mov	esi, ebx
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [edx+20]
	mov	DWORD PTR tv3588[ebp], eax

; 536  :       if ( !equal_id(e_id,ee_id) )

	cmp	DWORD PTR _e_id$[ebp], esi
	je	$LN59@facetedge_

; 537  :       { sprintf(msg,"Facetedge %s on edge %s but found in loop of edge %s.\n",
; 538  :             ELNAME(fe_id),SELNAME1(ee_id), SELNAME2(e_id));

	cmp	DWORD PTR tv3642[ebp], 0
	je	SHORT $LN202@facetedge_
	cmp	DWORD PTR tv3655[ebp], 0
	mov	eax, OFFSET ??_C@_01JOAMLHOP@?9?$AA@
	jne	SHORT $LN201@facetedge_
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN201@facetedge_:
	mov	ecx, DWORD PTR tv3645[ebp]
	inc	ecx
	push	ecx
	push	eax
	push	OFFSET ??_C@_04HGGBINEM@?$CFs?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 16					; 00000010H
	mov	edi, OFFSET _elnames+60
	jmp	SHORT $LN203@facetedge_
$LN202@facetedge_:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN203@facetedge_:
	test	esi, 268435456				; 10000000H
	je	SHORT $LN206@facetedge_
	mov	eax, OFFSET ??_C@_01JOAMLHOP@?9?$AA@
	test	esi, 134217728				; 08000000H
	jne	SHORT $LN205@facetedge_
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN205@facetedge_:
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	eax
	push	OFFSET ??_C@_04HGGBINEM@?$CFs?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 16					; 00000010H
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN207@facetedge_
$LN206@facetedge_:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN207@facetedge_:
	test	BYTE PTR tv3585[ebp], 1
	je	SHORT $LN208@facetedge_
	mov	edx, DWORD PTR tv3588[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN209@facetedge_
$LN208@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN209@facetedge_:
	push	edi
	push	esi
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0DH@KKBPNGI@Facetedge?5?$CFs?5on?5edge?5?$CFs?5but?5foun@
	push	eax
	call	_sprintf

; 539  :         erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 540  :         bad_errors_count++;
; 541  :         if ( ++numerr > MAXERR )

	mov	eax, DWORD PTR _numerr$[ebp]
	inc	DWORD PTR _bad_errors_count
	inc	eax
	add	esp, 24					; 00000018H
	mov	DWORD PTR _numerr$[ebp], eax
	cmp	eax, 20					; 00000014H
	jg	$LN437@facetedge_
	mov	edi, DWORD PTR _web+460
$LN59@facetedge_:

; 543  :       }
; 544  :       count++;

	mov	eax, DWORD PTR _count$[ebp]
	inc	eax
	mov	DWORD PTR _count$[ebp], eax

; 545  :       if ( count > web.skel[FACETEDGE].count )

	cmp	eax, DWORD PTR _web+512
	jle	SHORT $LN500@facetedge_

; 546  :       { sprintf(msg,"Bad chain of facetedges around edge %s.\n",
; 547  :           ELNAME(e_id));

	cmp	DWORD PTR tv3642[ebp], 0
	je	SHORT $LN210@facetedge_
	mov	edx, DWORD PTR tv3645[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN211@facetedge_
$LN210@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN211@facetedge_:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0CJ@KGDAEMFO@Bad?5chain?5of?5facetedges?5around?5e@
	push	eax
	call	_sprintf

; 548  :         erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 549  :         bad_errors_count++;
; 550  :         if ( ++numerr > MAXERR )

	mov	eax, DWORD PTR _numerr$[ebp]
	inc	DWORD PTR _bad_errors_count
	inc	eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _numerr$[ebp], eax
	cmp	eax, 20					; 00000014H
	jg	$LN437@facetedge_
	mov	edi, DWORD PTR _web+460
$LN500@facetedge_:

; 551  :         {erroutstring("Too many errors.\n"); goto facet_check;}
; 552  :       }
; 553  :       last_fe = fe_id;
; 554  :       fe_id = get_next_facet(fe_id);

	mov	edx, DWORD PTR tv3588[ebp]
	mov	ecx, DWORD PTR [edi+edx*4]
	mov	eax, ebx
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN341@facetedge_
	mov	ebx, DWORD PTR [ecx+36]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN62@facetedge_
$LN341@facetedge_:
	mov	ebx, DWORD PTR [ecx+40]
$LN62@facetedge_:

; 555  :     } while ( valid_id(fe_id) && !equal_id(fe_id,first_fe) );

	mov	ecx, ebx
	shr	ecx, 28					; 0000001cH
	mov	DWORD PTR tv3585[ebp], ecx
	test	cl, 1
	je	SHORT $LN56@facetedge_
	cmp	ebx, DWORD PTR _first_fe$89379[ebp]
	jne	$LL63@facetedge_
$LN56@facetedge_:

; 556  :     if ( last_fe == NULLID )

	test	eax, eax
	jne	$LN55@facetedge_
$LN457@facetedge_:

; 557  :      { 
; 558  :        if ( (web.representation == SOAPFILM) && (flag == REGCHECK) ) 

	mov	eax, 2
	cmp	DWORD PTR _web+624, eax
	jne	$LN70@facetedge_
	cmp	DWORD PTR _flag$[ebp], eax
	jne	$LN70@facetedge_

; 559  :        { edge_id orig;
; 560  :          bare_edge_count++;

	inc	DWORD PTR _bare_edge_count

; 561  :          if ( get_eattr(e_id) & BARE_NAKED ) continue;

	mov	esi, DWORD PTR tv3645[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 65536				; 00010000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN70@facetedge_

; 562  :          sprintf(msg,"Edge %s has no facets, and is not marked \"bare\".\n",ELNAME(e_id));

	mov	edi, DWORD PTR tv3642[ebp]
	test	edi, edi
	je	SHORT $LN212@facetedge_
	lea	eax, DWORD PTR [esi+1]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN213@facetedge_
$LN212@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN213@facetedge_:
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0DC@DGHOPHNN@Edge?5?$CFs?5has?5no?5facets?0?5and?5is?5no@
	push	ecx
	call	_sprintf

; 563  :          erroutstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_erroutstring

; 564  :          orig = get_original(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [eax+20]
	add	esp, 16					; 00000010H

; 565  :          if ( valid_id(orig) && !equal_element(orig,e_id) )

	test	eax, 268435456				; 10000000H
	je	$LN472@facetedge_
	or	eax, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	eax, ecx
	je	$LN472@facetedge_

; 566  :          { sprintf(msg,"      (originally edge %s)\n",ELNAME(e_id));

	test	edi, edi
	je	SHORT $LN214@facetedge_
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN215@facetedge_
$LN214@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN215@facetedge_:
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BM@OMAJFPHI@?5?5?5?5?5?5?$CIoriginally?5edge?5?$CFs?$CJ?6?$AA@
	push	ecx
	call	_sprintf

; 567  :            erroutstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_erroutstring
	add	esp, 16					; 00000010H

; 568  :          }
; 569  :        }

	jmp	$LN472@facetedge_
$LN55@facetedge_:

; 570  :      }
; 571  :     else if ( !equal_id(get_edge_fe(e_id),get_next_facet(last_fe)) )

	mov	ecx, DWORD PTR _web+124
	mov	esi, DWORD PTR tv3645[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	test	ecx, ecx
	je	SHORT $LN511@facetedge_
$LN345@facetedge_:
	cmp	DWORD PTR tv3655[ebp], 0
	mov	ecx, DWORD PTR [ecx+28]
	je	SHORT $LN511@facetedge_
	xor	ecx, 134217728				; 08000000H
$LN511@facetedge_:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN349@facetedge_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN348@facetedge_
$LN349@facetedge_:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+40]
$LN348@facetedge_:
	cmp	ecx, eax
	je	$LN70@facetedge_

; 572  :      { edge_id orig;
; 573  :        sprintf(msg,"Facets around edge %s do not link up.\n",
; 574  :           ELNAME(e_id));

	mov	edi, DWORD PTR tv3642[ebp]
	test	edi, edi
	je	SHORT $LN216@facetedge_
	lea	ecx, DWORD PTR [esi+1]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN217@facetedge_
$LN216@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN217@facetedge_:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0CH@GOFJFPDL@Facets?5around?5edge?5?$CFs?5do?5not?5lin@
	push	edx
	call	_sprintf

; 575  :        erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring

; 576  :        orig = get_original(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	edx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [edx+20]
	add	esp, 16					; 00000010H

; 577  :        if ( valid_id(orig) && !equal_element(orig,e_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN49@facetedge_
	or	eax, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	eax, ecx
	je	SHORT $LN49@facetedge_

; 578  :        { sprintf(msg,"      (originally edge %s)\n",ELNAME(e_id));

	test	edi, edi
	je	SHORT $LN218@facetedge_
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN219@facetedge_
$LN218@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN219@facetedge_:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BM@OMAJFPHI@?5?5?5?5?5?5?$CIoriginally?5edge?5?$CFs?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 579  :          erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring
	add	esp, 16					; 00000010H
$LN49@facetedge_:

; 580  :        }
; 581  :        bad_next_prev_count++;
; 582  :        if ( ++numerr > MAXERR )

	mov	esi, DWORD PTR _numerr$[ebp]
	inc	DWORD PTR _bad_next_prev_count
	inc	esi
	mov	DWORD PTR _numerr$[ebp], esi
	cmp	esi, 20					; 00000014H
	jg	$LN419@facetedge_
$LN472@facetedge_:

; 568  :          }
; 569  :        }

	mov	edi, DWORD PTR _web+460
$LN70@facetedge_:

; 517  :   FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR tv3645[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _e_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv3642[ebp], eax
	jne	$LL71@facetedge_
$LN473@facetedge_:

; 583  :        {erroutstring("Too many errors.\n"); return numerr;}  
; 584  :      }
; 585  :   }
; 586  : #ifndef MPI_EVOLVER
; 587  :   if ( count != web.skel[FACETEDGE].count )

	mov	edx, DWORD PTR _count$[ebp]
	cmp	edx, DWORD PTR _web+512
	je	SHORT $facet_check$89408

; 588  :   { sprintf(msg,"Edges have %d facetedges out of %ld used.\n",
; 589  :         count,web.skel[FACETEDGE].count);

	mov	eax, DWORD PTR _web+512
	push	eax
	mov	ecx, edx
	mov	edx, DWORD PTR _msg
	push	ecx
	push	OFFSET ??_C@_0CL@GDCDHLPJ@Edges?5have?5?$CFd?5facetedges?5out?5of?5@
	push	edx
	call	_sprintf

; 590  :     erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring
	add	esp, 20					; 00000014H

; 591  :     ++numerr;

	inc	DWORD PTR _numerr$[ebp]
$LN514@facetedge_:
	mov	edi, DWORD PTR _web+460
$facet_check$89408:

; 592  :   }
; 593  : #endif
; 594  : 
; 595  : facet_check: 
; 596  :   if ( numerr >= MAXERR ) numerr = 0;

	cmp	DWORD PTR _numerr$[ebp], 20		; 00000014H
	jl	SHORT $LN487@facetedge_
	mov	DWORD PTR _numerr$[ebp], 0
$LN487@facetedge_:

; 597  :   if ( web.representation == SOAPFILM ) 

	mov	eax, DWORD PTR _web+624
	cmp	eax, 2
	jne	$LN45@facetedge_

; 598  :   { int i;
; 599  :     count = 0;
; 600  :     MFOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+272
	mov	DWORD PTR _f_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _count$[ebp], 0
	mov	DWORD PTR tv3607[ebp], eax
	je	$LN488@facetedge_
$LL44@facetedge_:
	mov	eax, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv3615[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN43@facetedge_

; 601  :     { facetedge_id first_fe;
; 602  :       int thiscount = 0;

	xor	eax, eax
	mov	DWORD PTR _thiscount$89460[ebp], eax

; 603  :       
; 604  :       last_fe = NULLID;

	mov	DWORD PTR _last_fe$[ebp], eax

; 605  :       fe_id = first_fe = get_facet_fe(f_id);

	cmp	DWORD PTR tv3607[ebp], eax
	jne	SHORT $LN353@facetedge_
	mov	DWORD PTR _first_fe$89459[ebp], eax
	jmp	SHORT $LN354@facetedge_
$LN437@facetedge_:

; 542  :             {erroutstring("Too many errors.\n"); goto facet_check;}

	push	OFFSET ??_C@_0BC@CGAIEGBL@Too?5many?5errors?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LN514@facetedge_

; 605  :       fe_id = first_fe = get_facet_fe(f_id);

$LN353@facetedge_:
	test	DWORD PTR _f_id$[ebp], 134217728	; 08000000H
	mov	ecx, DWORD PTR [ecx+28]
	je	SHORT $LN352@facetedge_
	xor	ecx, 134217728				; 08000000H
$LN352@facetedge_:
	mov	DWORD PTR _first_fe$89459[ebp], ecx
$LN354@facetedge_:
	mov	ebx, DWORD PTR _first_fe$89459[ebp]

; 606  :       for ( i = 0 ; i < FACET_EDGES ; i++, fe_id = get_next_edge(fe_id) )

	mov	DWORD PTR _i$89449[ebp], eax
	npad	13
$LL356@facetedge_:

; 607  :       { vertex_id v_id;
; 608  :         edge_id e_id = get_fe_edge(fe_id);
; 609  :         facet_id ff_id;
; 610  :   #ifdef MPI_EVOLVER
; 611  :        if ( mpi_corona_state == NO_CORONA )
; 612  :        { if ( id_task(e_id) == this_task )
; 613  :          { v_id = get_edge_tailv(e_id);
; 614  :            if ( id_task(v_id) == this_task )
; 615  :            { if ( (thiscount != 0) && (get_vattr(v_id) & AXIAL_POINT))
; 616  :              { set_facet_fe(f_id,fe_id);       
; 617  :              }
; 618  :            }
; 619  :          }
; 620  :        }
; 621  :        else
; 622  :    #endif
; 623  :        { v_id = get_edge_tailv(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+esi*4]
	mov	eax, ebx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv3588[ebp], esi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN363@facetedge_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN362@facetedge_
$LN363@facetedge_:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]
$LN362@facetedge_:

; 624  :          if ( (thiscount != 0) && (get_vattr(v_id) & AXIAL_POINT))

	cmp	DWORD PTR _thiscount$89460[ebp], 0
	je	SHORT $LN495@facetedge_
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN495@facetedge_

; 625  :          { set_facet_fe(f_id,fe_id);       

	mov	edx, DWORD PTR _f_id$[ebp]
	push	ebx
	push	edx
	call	_set_facet_fe
	mov	edi, DWORD PTR _web+460
	add	esp, 8
$LN495@facetedge_:

; 626  :          }
; 627  :        }
; 628  : 
; 629  :         ff_id = get_fe_facet(fe_id);

	mov	eax, ebx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv3586[ebp], eax
	jne	SHORT $LN367@facetedge_
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN366@facetedge_
$LN367@facetedge_:
	mov	eax, DWORD PTR [edi+esi*4]
	mov	esi, DWORD PTR [eax+24]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN366@facetedge_
	xor	esi, 134217728				; 08000000H
$LN366@facetedge_:

; 630  :         if ( !equal_id(f_id,ff_id) )

	cmp	DWORD PTR _f_id$[ebp], esi
	je	$LN496@facetedge_

; 631  :         { sprintf(msg,"Facetedge %s on facet %s instead of %s.\n",
; 632  :              ELNAME(fe_id),SELNAME1(ff_id), SELNAME2(f_id));

	cmp	DWORD PTR tv3607[ebp], 0
	je	SHORT $LN222@facetedge_
	test	DWORD PTR _f_id$[ebp], 134217728	; 08000000H
	mov	eax, OFFSET ??_C@_01JOAMLHOP@?9?$AA@
	jne	SHORT $LN221@facetedge_
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN221@facetedge_:
	mov	ecx, DWORD PTR tv3615[ebp]
	inc	ecx
	push	ecx
	push	eax
	push	OFFSET ??_C@_04HGGBINEM@?$CFs?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 16					; 00000010H
	mov	edi, OFFSET _elnames+60
	jmp	SHORT $LN223@facetedge_
$LN222@facetedge_:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN223@facetedge_:
	test	esi, 268435456				; 10000000H
	je	SHORT $LN226@facetedge_
	mov	eax, OFFSET ??_C@_01JOAMLHOP@?9?$AA@
	test	esi, 134217728				; 08000000H
	jne	SHORT $LN225@facetedge_
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN225@facetedge_:
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	eax
	push	OFFSET ??_C@_04HGGBINEM@?$CFs?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 16					; 00000010H
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN227@facetedge_
$LN226@facetedge_:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN227@facetedge_:
	cmp	DWORD PTR tv3586[ebp], 0
	je	SHORT $LN228@facetedge_
	mov	edx, DWORD PTR tv3588[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN229@facetedge_
$LN228@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN229@facetedge_:
	push	edi
	push	esi
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0CJ@KCENKHDP@Facetedge?5?$CFs?5on?5facet?5?$CFs?5instead@
	push	eax
	call	_sprintf

; 633  :            erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 634  :            bad_errors_count++;
; 635  :            if ( ++numerr > MAXERR )

	mov	eax, DWORD PTR _numerr$[ebp]
	inc	DWORD PTR _bad_errors_count
	inc	eax
	add	esp, 24					; 00000018H
	mov	DWORD PTR _numerr$[ebp], eax
	cmp	eax, 20					; 00000014H
	jg	SHORT $LN441@facetedge_
	mov	edi, DWORD PTR _web+460
$LN496@facetedge_:

; 637  :          }
; 638  :          count++;
; 639  :          if ( ++thiscount > web.skel[FACETEDGE].count )

	mov	eax, DWORD PTR _thiscount$89460[ebp]
	mov	ecx, 1
	add	DWORD PTR _count$[ebp], ecx
	add	eax, ecx
	mov	DWORD PTR _thiscount$89460[ebp], eax
	cmp	eax, DWORD PTR _web+512
	jg	SHORT $LN442@facetedge_

; 651  :            {erroutstring("Too many errors.\n"); return numerr;}
; 652  :               break;
; 653  :          }
; 654  :        last_fe = fe_id;

	add	DWORD PTR _i$89449[ebp], ecx
	mov	DWORD PTR _last_fe$[ebp], ebx
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN357@facetedge_

; 606  :       for ( i = 0 ; i < FACET_EDGES ; i++, fe_id = get_next_edge(fe_id) )

	mov	edx, DWORD PTR tv3588[ebp]
	mov	eax, DWORD PTR [edi+edx*4]
	mov	ebx, DWORD PTR [eax+28]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN452@facetedge_
$LN357@facetedge_:
	mov	ecx, DWORD PTR tv3588[ebp]
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	ebx, DWORD PTR [edx+32]
$LN452@facetedge_:
	cmp	DWORD PTR _i$89449[ebp], 3
	jl	$LL356@facetedge_

; 710  :         if ( equal_id(fe_id,start_fe) )

	mov	esi, DWORD PTR _f_id$[ebp]
	jmp	$LN31@facetedge_
$LN441@facetedge_:

; 636  :             {erroutstring("Too many errors.\n"); break;}

	push	OFFSET ??_C@_0BC@CGAIEGBL@Too?5many?5errors?4?6?$AA@
	call	_erroutstring
	mov	esi, DWORD PTR _f_id$[ebp]
	add	esp, 4
	jmp	$LN515@facetedge_
$LN442@facetedge_:

; 640  :          { facet_id orig;
; 641  :            sprintf(msg,"Facetedge loop not closed on facet %s.\n",
; 642  :              ELNAME(f_id));

	cmp	DWORD PTR tv3607[ebp], 0
	je	SHORT $LN230@facetedge_
	mov	eax, DWORD PTR tv3615[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN231@facetedge_
$LN230@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN231@facetedge_:
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0CI@MAPEECME@Facetedge?5loop?5not?5closed?5on?5fac@
	push	ecx
	call	_sprintf

; 643  :            erroutstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_erroutstring

; 644  :            orig = get_original(f_id);

	mov	esi, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR tv3615[ebp]
	mov	eax, esi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [eax+20]
	add	esp, 16					; 00000010H

; 645  :            if ( valid_id(orig) && !equal_element(orig,f_id)  )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN492@facetedge_
	mov	ecx, eax
	mov	edx, esi
	or	ecx, 134217728				; 08000000H
	or	edx, 134217728				; 08000000H
	cmp	ecx, edx
	je	SHORT $LN492@facetedge_

; 646  :            { sprintf(msg,"      (originally facet %s)\n", ELNAME(orig));

	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0BN@CIEFJFJB@?5?5?5?5?5?5?$CIoriginally?5facet?5?$CFs?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 647  :              erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring
	add	esp, 28					; 0000001cH
$LN492@facetedge_:

; 648  :            }
; 649  :            bad_errors_count++;
; 650  :            if ( ++numerr > MAXERR )

	mov	edi, DWORD PTR _numerr$[ebp]
	inc	DWORD PTR _bad_errors_count
	inc	edi
	mov	DWORD PTR _numerr$[ebp], edi
	cmp	edi, 20					; 00000014H
	jg	$LN418@facetedge_
$LN515@facetedge_:
	mov	edi, DWORD PTR _web+460
$LN31@facetedge_:

; 655  :      } /* end while */
; 656  :      fe_id = get_next_edge(last_fe);

	mov	eax, DWORD PTR _last_fe$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN371@facetedge_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN370@facetedge_
$LN371@facetedge_:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+32]
$LN370@facetedge_:

; 657  :      if ( !equal_id(first_fe,fe_id) )

	cmp	DWORD PTR _first_fe$89459[ebp], eax
	je	$LN28@facetedge_

; 658  :      { facet_id orig;
; 659  :        sprintf(msg,"Edges around facet %s do not link up.\n",
; 660  :           ELNAME(f_id));

	cmp	DWORD PTR tv3607[ebp], 0
	je	SHORT $LN234@facetedge_
	mov	ecx, DWORD PTR tv3615[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN235@facetedge_
$LN234@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN235@facetedge_:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0CH@FFMCKPNG@Edges?5around?5facet?5?$CFs?5do?5not?5lin@
	push	edx
	call	_sprintf

; 661  :        erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring

; 662  :        orig = get_original(f_id);

	mov	eax, DWORD PTR tv3615[ebp]
	mov	ecx, esi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+20]
	add	esp, 16					; 00000010H

; 663  :        if ( valid_id(orig) &&  !equal_element(orig,f_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN512@facetedge_
	mov	edx, eax
	mov	ecx, esi
	or	edx, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	edx, ecx
	je	SHORT $LN512@facetedge_

; 664  :        { sprintf(msg,"      (originally facet %s)\n", ELNAME(orig));

	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0BN@CIEFJFJB@?5?5?5?5?5?5?$CIoriginally?5facet?5?$CFs?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 665  :          erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring
	add	esp, 28					; 0000001cH
$LN512@facetedge_:

; 666  :        }
; 667  :        bad_errors_count++;
; 668  :        if ( ++numerr > MAXERR )

	mov	eax, DWORD PTR _numerr$[ebp]
	inc	DWORD PTR _bad_errors_count
	inc	eax
	mov	DWORD PTR _numerr$[ebp], eax
	cmp	eax, 20					; 00000014H
	jg	$LN445@facetedge_
	mov	edi, DWORD PTR _web+460
$LN28@facetedge_:

; 669  :        {erroutstring("Too many errors.\n"); break;}
; 670  :      }
; 671  :      if ( (thiscount != 3) && (flag == REGCHECK)  )

	mov	ebx, DWORD PTR _thiscount$89460[ebp]
	cmp	ebx, 3
	je	$LN43@facetedge_
	cmp	DWORD PTR _flag$[ebp], 2
	jne	$LN43@facetedge_

; 672  :      { facet_id orig;
; 673  :        sprintf(msg,"Facet %s has %d edges.\n",ELNAME(f_id),thiscount);

	cmp	DWORD PTR tv3607[ebp], 0
	je	SHORT $LN238@facetedge_
	mov	ecx, DWORD PTR tv3615[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN239@facetedge_
$LN238@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN239@facetedge_:
	mov	edx, DWORD PTR _msg
	push	ebx
	push	eax
	push	OFFSET ??_C@_0BI@MBBNMEHH@Facet?5?$CFs?5has?5?$CFd?5edges?4?6?$AA@
	push	edx
	call	_sprintf

; 674  :        erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring

; 675  :        orig = get_original(f_id);

	mov	eax, DWORD PTR tv3615[ebp]
	mov	ecx, esi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+20]
	add	esp, 20					; 00000014H

; 676  :        if ( valid_id(orig) && !equal_element(orig,f_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN505@facetedge_
	mov	edx, eax
	or	edx, 134217728				; 08000000H
	or	esi, 134217728				; 08000000H
	cmp	edx, esi
	je	SHORT $LN505@facetedge_

; 677  :        { sprintf(msg,"      (originally facet %s)\n", ELNAME(orig));

	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0BN@CIEFJFJB@?5?5?5?5?5?5?$CIoriginally?5facet?5?$CFs?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 678  :          erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring
	add	esp, 28					; 0000001cH
$LN505@facetedge_:

; 679  :        }
; 680  :        bad_errors_count++;
; 681  :        if ( ++numerr > MAXERR )

	mov	eax, DWORD PTR _numerr$[ebp]
	inc	DWORD PTR _bad_errors_count
	inc	eax
	mov	DWORD PTR _numerr$[ebp], eax
	cmp	eax, 20					; 00000014H
	jg	SHORT $LN445@facetedge_
	mov	edi, DWORD PTR _web+460
$LN43@facetedge_:

; 598  :   { int i;
; 599  :     count = 0;
; 600  :     MFOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+236
	mov	edx, DWORD PTR tv3615[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _f_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv3607[ebp], eax
	jne	$LL44@facetedge_

; 710  :         if ( equal_id(fe_id,start_fe) )

	jmp	SHORT $LN488@facetedge_
$LN445@facetedge_:

; 682  :         {erroutstring("Too many errors.\n"); break;}

	push	OFFSET ??_C@_0BC@CGAIEGBL@Too?5many?5errors?4?6?$AA@
	call	_erroutstring
	add	esp, 4
$LN488@facetedge_:

; 683  :      }
; 684  :     }
; 685  :     if ( count != web.skel[FACETEDGE].count )

	mov	ecx, DWORD PTR _count$[ebp]
	mov	eax, DWORD PTR _web+512
	cmp	ecx, eax
	je	$LN4@facetedge_

; 686  :     { sprintf(msg,"Facets have %d facet-edges out of %ld used.\n",
; 687  :           count,web.skel[FACETEDGE].count);

	mov	edx, DWORD PTR _msg
	push	eax
	push	ecx
	push	OFFSET ??_C@_0CN@NOCCOCCG@Facets?5have?5?$CFd?5facet?9edges?5out?5o@
	push	edx
	call	_sprintf

; 688  :       erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring
	add	esp, 20					; 00000014H

; 689  :       ++numerr;

	mov	eax, 1
	add	DWORD PTR _numerr$[ebp], eax

; 690  :       bad_errors_count++;

	add	DWORD PTR _bad_errors_count, eax

; 729  :       }
; 730  :   } // end STRING
; 731  :   return numerr;

	mov	eax, DWORD PTR _numerr$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 732  : } /* end facetedge_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@facetedge_:

; 691  :     }
; 692  :   } /* end SOAPFILM */
; 693  :   else if ( web.representation == STRING )

	cmp	eax, 1
	jne	$LN4@facetedge_

; 694  :   { // see if facets account for all facetedges, to detect
; 695  :     // split facet edge chains.
; 696  :     int count = 0;
; 697  :     MFOR_ALL_FACETEDGES(fe_id)

	mov	edx, DWORD PTR _web+496
	mov	esi, edx
	shr	esi, 28					; 0000001cH
	and	esi, eax
	mov	DWORD PTR _count$89522[ebp], 0
	je	$LN19@facetedge_
$LL477@facetedge_:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	ebx, ebx
	or	ecx, ebx
	je	SHORT $LN20@facetedge_

; 698  :     { unset_attr(fe_id,CHECKMARKED);

	mov	ecx, edx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	lea	ebx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	edi, DWORD PTR [ecx+12]
	and	DWORD PTR [ecx+8], -1073741825		; bfffffffH
	mov	DWORD PTR [ecx+12], edi

; 699  :       if ( !valid_id(get_fe_facet(fe_id)) )

	mov	edi, DWORD PTR _web+460
	test	esi, esi
	jne	SHORT $LN377@facetedge_
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN376@facetedge_
$LN377@facetedge_:
	mov	ecx, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [ecx+24]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN376@facetedge_
	xor	ecx, 134217728				; 08000000H
$LN376@facetedge_:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN20@facetedge_

; 700  :       { count++;
; 701  :         set_attr(fe_id,CHECKMARKED);

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR [ecx+12]
	inc	DWORD PTR _count$89522[ebp]
	or	DWORD PTR [ecx+8], 1073741824		; 40000000H
	mov	DWORD PTR [ecx+12], edx
	mov	edi, DWORD PTR _web+460
$LN20@facetedge_:

; 694  :   { // see if facets account for all facetedges, to detect
; 695  :     // split facet edge chains.
; 696  :     int count = 0;
; 697  :     MFOR_ALL_FACETEDGES(fe_id)

	mov	eax, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [eax]
	mov	esi, edx
	shr	esi, 28					; 0000001cH
	and	esi, 1
	jne	$LL477@facetedge_
$LN19@facetedge_:

; 702  :       }
; 703  :     }
; 704  :     MFOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+272
	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	je	$LN489@facetedge_
$LL15@facetedge_:
	mov	eax, DWORD PTR _web+236
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	$LN14@facetedge_

; 705  :     { facetedge_id start_fe = fe_id = get_facet_fe(f_id);

	test	edx, edx
	jne	SHORT $LN383@facetedge_
	xor	eax, eax
	jmp	SHORT $LN382@facetedge_
$LN383@facetedge_:
	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN382@facetedge_
	xor	eax, 134217728				; 08000000H
$LN382@facetedge_:
	mov	DWORD PTR _start_fe$89545[ebp], eax

; 706  :       while ( valid_id(fe_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN14@facetedge_
	mov	ebx, 1073741824				; 40000000H
$LL10@facetedge_:

; 707  :       { count++;

	inc	DWORD PTR _count$89522[ebp]

; 708  :         set_attr(fe_id,CHECKMARKED);

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [edx+ecx]
	mov	edi, DWORD PTR [edx+12]
	or	DWORD PTR [edx+8], ebx
	mov	DWORD PTR [edx+12], edi

; 709  :         fe_id = get_next_edge(fe_id);

	mov	edi, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN389@facetedge_
	mov	eax, DWORD PTR [ecx+edi]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN388@facetedge_
$LN389@facetedge_:
	mov	ecx, DWORD PTR [ecx+edi]
	mov	eax, DWORD PTR [ecx+32]
$LN388@facetedge_:

; 710  :         if ( equal_id(fe_id,start_fe) )

	cmp	eax, DWORD PTR _start_fe$89545[ebp]
	je	SHORT $LN14@facetedge_

; 706  :       while ( valid_id(fe_id) )

	test	eax, 268435456				; 10000000H
	jne	SHORT $LL10@facetedge_
$LN14@facetedge_:

; 702  :       }
; 703  :     }
; 704  :     MFOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [esi+edx]
	mov	ecx, DWORD PTR [eax]
	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	$LL15@facetedge_
$LN489@facetedge_:

; 711  :           break;
; 712  :       }
; 713  :     }
; 714  :     if ( count != web.skel[FACETEDGE].count )

	mov	ecx, DWORD PTR _count$89522[ebp]
	mov	eax, DWORD PTR _web+512
	cmp	ecx, eax
	je	SHORT $LN513@facetedge_

; 715  :     { sprintf(msg,"Facets have %d facet-edges out of %ld used.\n",
; 716  :           count,web.skel[FACETEDGE].count);

	push	eax
	push	ecx
	mov	ecx, DWORD PTR _msg
	push	OFFSET ??_C@_0CN@NOCCOCCG@Facets?5have?5?$CFd?5facet?9edges?5out?5o@
	push	ecx
	call	_sprintf

; 717  :       erroutstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_erroutstring

; 718  :       ++numerr;   
; 719  :       bad_errors_count++;

	mov	edi, DWORD PTR _web+460
	mov	eax, 1
	add	DWORD PTR _numerr$[ebp], eax
	add	esp, 20					; 00000014H
	add	DWORD PTR _bad_errors_count, eax
$LN513@facetedge_:

; 720  :     }
; 721  :     // check all facetedges reached
; 722  :     MFOR_ALL_FACETEDGES(fe_id)

	mov	esi, DWORD PTR _web+496
	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv3586[ebp], eax
	je	$LN4@facetedge_
	npad	4
$LL6@facetedge_:
	mov	ebx, esi
	and	ebx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN5@facetedge_

; 723  :       if ( !(get_attr(fe_id) & CHECKMARKED) )

	mov	eax, esi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [ecx+ebx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1073741824				; 40000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN5@facetedge_

; 724  :       { sprintf(msg,"Facetedge %s on facet %s and edge %s not reached in facet edge list.\n",
; 725  :            ELNAME(fe_id),ELNAME2(get_fe_facet(fe_id)),ELNAME3(get_fe_edge(fe_id)));

	mov	eax, DWORD PTR [edx+20]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN242@facetedge_
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+90
	call	_sprintf
	mov	edi, DWORD PTR _web+460
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1408[ebp], OFFSET _elnames+90
	jmp	SHORT $LN243@facetedge_
$LN242@facetedge_:
	mov	DWORD PTR tv1408[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN243@facetedge_:
	mov	ecx, DWORD PTR tv3586[ebp]
	test	ecx, ecx
	jne	SHORT $LN397@facetedge_
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN396@facetedge_
$LN397@facetedge_:
	mov	edx, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [edx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN396@facetedge_
	xor	eax, 134217728				; 08000000H
$LN396@facetedge_:
	test	eax, 268435456				; 10000000H
	je	SHORT $LN244@facetedge_
	test	ecx, ecx
	jne	SHORT $LN401@facetedge_
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN400@facetedge_
$LN401@facetedge_:
	mov	eax, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [eax+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN400@facetedge_
	xor	eax, 134217728				; 08000000H
$LN400@facetedge_:
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+60
	jmp	SHORT $LN245@facetedge_
$LN244@facetedge_:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN245@facetedge_:
	cmp	DWORD PTR tv3586[ebp], 0
	je	SHORT $LN246@facetedge_
	lea	ecx, DWORD PTR [ebx+1]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN247@facetedge_
$LN246@facetedge_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN247@facetedge_:
	mov	edx, DWORD PTR tv1408[ebp]
	push	edx
	push	esi
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0EG@BJDMGDDK@Facetedge?5?$CFs?5on?5facet?5?$CFs?5and?5edg@
	push	eax
	call	_sprintf

; 726  :         erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 727  :         ++numerr;
; 728  :         bad_errors_count++;

	mov	edi, DWORD PTR _web+460
	mov	eax, 1
	add	DWORD PTR _numerr$[ebp], eax
	add	esp, 24					; 00000018H
	add	DWORD PTR _bad_errors_count, eax
$LN5@facetedge_:

; 720  :     }
; 721  :     // check all facetedges reached
; 722  :     MFOR_ALL_FACETEDGES(fe_id)

	mov	edx, DWORD PTR [edi+ebx*4]
	mov	esi, DWORD PTR [edx]
	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv3586[ebp], eax
	jne	$LL6@facetedge_
$LN4@facetedge_:

; 729  :       }
; 730  :   } // end STRING
; 731  :   return numerr;

	mov	eax, DWORD PTR _numerr$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 732  : } /* end facetedge_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
_facetedge_check ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@MNEEPMLM@Remaking?5vertex?5facet?5lists?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@MBIFPMFP@Vertex?5?$CFs?5has?5bad?5facet?5list?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@KPFIFJGO@Vertex?5?$CFs?5not?5found?5in?5facet?5?$CFs?4@ ; `string'
PUBLIC	_vertex_facet_check
EXTRN	_make_vfacet_lists:PROC
EXTRN	_get_next_vertex_facet:PROC
EXTRN	_get_vertex_first_facet:PROC
;	COMDAT ??_C@_0BO@MNEEPMLM@Remaking?5vertex?5facet?5lists?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@MNEEPMLM@Remaking?5vertex?5facet?5lists?4?6?$AA@ DB 'Remaking v'
	DB	'ertex facet lists.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MBIFPMFP@Vertex?5?$CFs?5has?5bad?5facet?5list?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@MBIFPMFP@Vertex?5?$CFs?5has?5bad?5facet?5list?4?6?$AA@ DB 'Vert'
	DB	'ex %s has bad facet list.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KPFIFJGO@Vertex?5?$CFs?5not?5found?5in?5facet?5?$CFs?4@
CONST	SEGMENT
??_C@_0CC@KPFIFJGO@Vertex?5?$CFs?5not?5found?5in?5facet?5?$CFs?4@ DB 'Ver'
	DB	'tex %s not found in facet %s.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _vertex_facet_check
_TEXT	SEGMENT
tv381 = -16						; size = 4
tv289 = -12						; size = 4
tv291 = -8						; size = 4
_numerr$ = -4						; size = 4
_vertex_facet_check PROC				; COMDAT

; 742  : { vertex_id v_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 743  :   int numerr = 0;
; 744  : 
; 745  :   MFOR_ALL_VERTICES(v_id)

	mov	esi, DWORD PTR _web+48
	mov	eax, esi
	xor	ecx, ecx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _numerr$[ebp], ecx
	mov	DWORD PTR tv289[ebp], eax
	je	$LN41@vertex_fac
	push	ebx
	push	edi
	npad	11
$LL44@vertex_fac:
	mov	ecx, DWORD PTR _web+12
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv291[ebp], eax
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN18@vertex_fac

; 746  :   { element_id f_id, start_f_id;
; 747  :     int count = 0;
; 748  :     start_f_id = get_vertex_first_facet(v_id);

	push	esi
	xor	ebx, ebx
	call	_get_vertex_first_facet
	mov	edi, eax
	add	esp, 4

; 749  :     f_id = start_f_id;
; 750  :     if ( !valid_id(start_f_id) )

	test	edi, 268435456				; 10000000H
	je	$LN18@vertex_fac

; 751  :       continue;
; 752  :     if ( get_vattr(v_id) & Q_MIDFACET )

	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR tv291[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 2097152				; 00200000H
	xor	edx, edx
	or	ecx, edx
	je	$LL5@vertex_fac

; 753  :     { vertex_id *v = get_facet_vertices(f_id);

	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	add	edi, DWORD PTR [ecx+edx+304]

; 754  :       int i,j,k;
; 755  :       for ( i = 0, k=0 ; i <= web.lagrange_order ; i++ )

	mov	edx, DWORD PTR _web+632
	xor	ecx, ecx
	mov	DWORD PTR tv381[ebp], eax
	test	edx, edx
	js	SHORT $LN10@vertex_fac

; 756  :         for ( j = 0 ; i+j <= web.lagrange_order ; j++,k++ )

	cmp	ebx, edx
	jg	SHORT $LN11@vertex_fac
$LN47@vertex_fac:
	mov	eax, ebx
$LL9@vertex_fac:

; 757  :           if ( equal_id(v_id,v[k]) )

	cmp	esi, DWORD PTR [edi+ecx*4]
	je	$LN18@vertex_fac

; 756  :         for ( j = 0 ; i+j <= web.lagrange_order ; j++,k++ )

	inc	eax
	inc	ecx
	cmp	eax, edx
	jle	SHORT $LL9@vertex_fac
	mov	eax, DWORD PTR tv381[ebp]
$LN11@vertex_fac:

; 754  :       int i,j,k;
; 755  :       for ( i = 0, k=0 ; i <= web.lagrange_order ; i++ )

	inc	ebx
	cmp	ebx, edx
	jle	SHORT $LN47@vertex_fac
$LN10@vertex_fac:

; 758  :             goto vfc_cont;
; 759  :       sprintf(msg,"Vertex %s not found in facet %s.\n",ELNAME(v_id),ELNAME2(f_id));

	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR tv289[ebp], 0
	je	SHORT $LN24@vertex_fac
	mov	eax, DWORD PTR tv291[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN25@vertex_fac
$LN24@vertex_fac:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN25@vertex_fac:
	mov	ecx, DWORD PTR _msg
	push	OFFSET _elnames+60
	push	eax
	push	OFFSET ??_C@_0CC@KPFIFJGO@Vertex?5?$CFs?5not?5found?5in?5facet?5?$CFs?4@
	push	ecx
	call	_sprintf

; 760  :       erroutstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_erroutstring
	add	esp, 20					; 00000014H
$vfc_cont$89608:

; 761  :       ++numerr;
; 762  :       bad_errors_count++;
; 763  : vfc_cont:          
; 764  :       continue;

	jmp	SHORT $LN48@vertex_fac
	npad	3
$LL5@vertex_fac:

; 765  :     }
; 766  : 
; 767  :     do
; 768  :     { f_id = get_next_vertex_facet(v_id,f_id);

	push	eax
	push	esi
	call	_get_next_vertex_facet

; 769  :       count++;
; 770  :       if ( count > 3*web.skel[FACET].count )

	mov	ecx, DWORD PTR _web+288
	inc	ebx
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	esp, 8
	cmp	ebx, ecx
	jg	SHORT $LN33@vertex_fac

; 775  :         break;
; 776  :       }
; 777  :     } while ( !equal_id(f_id,start_f_id) );

	cmp	eax, edi
	jne	SHORT $LL5@vertex_fac
	jmp	SHORT $LN18@vertex_fac
$LN33@vertex_fac:

; 771  :       { sprintf(msg,"Vertex %s has bad facet list.\n",ELNAME(v_id));

	cmp	DWORD PTR tv289[ebp], 0
	je	SHORT $LN26@vertex_fac
	mov	edx, DWORD PTR tv291[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN27@vertex_fac
$LN26@vertex_fac:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN27@vertex_fac:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BP@MBIFPMFP@Vertex?5?$CFs?5has?5bad?5facet?5list?4?6?$AA@
	push	eax
	call	_sprintf

; 772  :         erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring
	add	esp, 16					; 00000010H
$LN48@vertex_fac:

; 773  :         ++numerr;

	mov	eax, 1
	add	DWORD PTR _numerr$[ebp], eax

; 774  :         bad_errors_count++;

	add	DWORD PTR _bad_errors_count, eax
$LN18@vertex_fac:

; 743  :   int numerr = 0;
; 744  : 
; 745  :   MFOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR tv291[ebp]
	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR [ecx]
	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv289[ebp], eax
	jne	$LL44@vertex_fac

; 778  :   }
; 779  : 
; 780  :   if ( (numerr > 0) && (web.representation == SIMPLEX) )

	mov	esi, DWORD PTR _numerr$[ebp]
	pop	edi
	pop	ebx
	test	esi, esi
	jle	SHORT $LN39@vertex_fac
	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN39@vertex_fac

; 781  :   { erroutstring("Remaking vertex facet lists.\n");

	push	OFFSET ??_C@_0BO@MNEEPMLM@Remaking?5vertex?5facet?5lists?4?6?$AA@
	call	_erroutstring
	add	esp, 4

; 782  :     make_vfacet_lists();

	call	_make_vfacet_lists
$LN39@vertex_fac:

; 783  :   }
; 784  : 
; 785  :   return numerr;

	mov	eax, esi
	pop	esi

; 786  : } // end vertex_facet_check()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@vertex_fac:

; 783  :   }
; 784  : 
; 785  :   return numerr;

	mov	eax, ecx
	pop	esi

; 786  : } // end vertex_facet_check()

	mov	esp, ebp
	pop	ebp
	ret	0
_vertex_facet_check ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@NEPGCKBF@Facet?5?$CFs?5next?5body?5facet?5has?5bad@ ; `string'
PUBLIC	??_C@_0DE@IOKAHOJI@Facet?5?$CFs?5on?5body?5?$CFs?5facet?5list?0?5@ ; `string'
PUBLIC	??_C@_0DB@BKMMCNPM@Invalid?5facet?5?$CFs?5on?5body?5facet?5l@ ; `string'
PUBLIC	_check_body_facets
EXTRN	_get_prev_body_facet:PROC
EXTRN	_get_next_body_facet:PROC
;	COMDAT ??_C@_0DD@NEPGCKBF@Facet?5?$CFs?5next?5body?5facet?5has?5bad@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DD@NEPGCKBF@Facet?5?$CFs?5next?5body?5facet?5has?5bad@ DB 'Facet %'
	DB	's next body facet has bad prev_body_facet.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IOKAHOJI@Facet?5?$CFs?5on?5body?5?$CFs?5facet?5list?0?5@
CONST	SEGMENT
??_C@_0DE@IOKAHOJI@Facet?5?$CFs?5on?5body?5?$CFs?5facet?5list?0?5@ DB 'Fa'
	DB	'cet %s on body %s facet list, but is on body %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BKMMCNPM@Invalid?5facet?5?$CFs?5on?5body?5facet?5l@
CONST	SEGMENT
??_C@_0DB@BKMMCNPM@Invalid?5facet?5?$CFs?5on?5body?5facet?5l@ DB 'Invalid'
	DB	' facet %s on body facet list of body %s.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\check.c
CONST	ENDS
;	COMDAT _check_body_facets
_TEXT	SEGMENT
_start_f$89745 = -20					; size = 4
_b_id$ = -16						; size = 4
tv515 = -12						; size = 4
tv513 = -8						; size = 4
_numerr$ = -4						; size = 4
_check_body_facets PROC					; COMDAT

; 908  : { int numerr = 0;

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx

; 909  :   body_id b_id;
; 910  : 
; 911  :   FOR_ALL_BODIES(b_id)

	mov	ebx, DWORD PTR _web+384
	push	esi
	mov	esi, ebx
	xor	eax, eax
	shr	esi, 28					; 0000001cH
	and	esi, 1
	mov	DWORD PTR _numerr$[ebp], eax
	mov	DWORD PTR _b_id$[ebp], ebx
	mov	DWORD PTR tv513[ebp], esi
	je	$LN10@check_body
	push	edi
	mov	edi, DWORD PTR _web+348
	jmp	SHORT $LN12@check_body
$LL59@check_body:
	mov	ebx, DWORD PTR _b_id$[ebp]
	mov	esi, DWORD PTR tv513[ebp]
$LN12@check_body:
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv515[ebp], ebx
	je	$LN11@check_body

; 912  :   { facet_id  start_f,next_f;
; 913  :     facet_id f_id = get_body_facet(b_id);

	test	esi, esi
	je	SHORT $LN33@check_body
	mov	esi, DWORD PTR [ecx+400]
	jmp	SHORT $LN34@check_body
$LN33@check_body:
	xor	esi, esi
$LN34@check_body:

; 914  :     if ( !valid_id(f_id) ) continue;

	test	esi, 268435456				; 10000000H
	je	$LN11@check_body

; 915  :     start_f = f_id; 

	mov	DWORD PTR _start_f$89745[ebp], esi
	npad	1
$LL6@check_body:

; 916  :     do 
; 917  :     { if ( !valid_element(f_id) )

	push	esi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	$LN60@check_body

; 918  :       { sprintf(msg,"Invalid facet %s on body facet list of body %s.\n",
; 919  :               ELNAME(f_id),ELNAME1(b_id));

	cmp	DWORD PTR tv513[ebp], eax
	je	SHORT $LN15@check_body
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	edi, OFFSET _elnames+30
	jmp	SHORT $LN16@check_body
$LN15@check_body:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN16@check_body:
	test	esi, 268435456				; 10000000H
	je	SHORT $LN17@check_body
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN18@check_body
$LN17@check_body:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN18@check_body:
	mov	ecx, DWORD PTR _msg
	push	edi
	push	eax
	push	OFFSET ??_C@_0DB@BKMMCNPM@Invalid?5facet?5?$CFs?5on?5body?5facet?5l@
	push	ecx
	call	_sprintf

; 920  :         erroutstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_erroutstring

; 921  :         numerr++;

	mov	eax, 1
	add	DWORD PTR _numerr$[ebp], eax
	add	esp, 20					; 00000014H

; 922  :         bad_errors_count++;

	add	DWORD PTR _bad_errors_count, eax
$LN60@check_body:

; 923  :       }        
; 924  :       if ( !equal_id(b_id,get_facet_body(f_id)) )

	cmp	DWORD PTR _web+400, 0
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _dymem
	jne	SHORT $LN38@check_body
	xor	edi, edi
	jmp	SHORT $LN35@check_body
$LN38@check_body:
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN37@check_body
	xor	edi, edi
	jmp	SHORT $LN35@check_body
$LN37@check_body:
	mov	ebx, DWORD PTR [eax+edx+784]
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+edi*4]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN36@check_body
	mov	edi, DWORD PTR [edi+ebx+4]
	jmp	SHORT $LN35@check_body
$LN36@check_body:
	mov	edi, DWORD PTR [edi+ebx]
$LN35@check_body:
	cmp	DWORD PTR _b_id$[ebp], edi
	je	$LN58@check_body

; 925  :       { sprintf(msg,"Facet %s on body %s facet list, but is on body %s.\n",
; 926  :           SELNAME(f_id),ELNAME1(b_id),ELNAME2(get_facet_body(f_id))); 

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN44@check_body
	xor	edi, edi
	jmp	SHORT $LN41@check_body
$LN44@check_body:
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN43@check_body
	xor	edi, edi
	jmp	SHORT $LN41@check_body
$LN43@check_body:
	mov	ebx, DWORD PTR [eax+edx+784]
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+edi*4]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN42@check_body
	mov	edi, DWORD PTR [edi+ebx+4]
	jmp	SHORT $LN41@check_body
$LN42@check_body:
	mov	edi, DWORD PTR [edi+ebx]
$LN41@check_body:
	test	edi, 268435456				; 10000000H
	je	SHORT $LN19@check_body
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN50@check_body
	xor	eax, eax
	jmp	SHORT $LN47@check_body
$LN50@check_body:
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN49@check_body
	xor	eax, eax
	jmp	SHORT $LN47@check_body
$LN49@check_body:
	mov	edx, DWORD PTR [eax+edx+784]
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edi*4]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN48@check_body
	mov	eax, DWORD PTR [ecx+edx+4]
	jmp	SHORT $LN47@check_body
$LN48@check_body:
	mov	eax, DWORD PTR [ecx+edx]
$LN47@check_body:
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	ebx, OFFSET _elnames+60
	jmp	SHORT $LN20@check_body
$LN19@check_body:
	mov	ebx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN20@check_body:
	cmp	DWORD PTR tv513[ebp], 0
	je	SHORT $LN21@check_body
	mov	eax, DWORD PTR tv515[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	edi, OFFSET _elnames+30
	jmp	SHORT $LN22@check_body
$LN21@check_body:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN22@check_body:
	test	esi, 268435456				; 10000000H
	je	SHORT $LN25@check_body
	mov	eax, OFFSET ??_C@_01JOAMLHOP@?9?$AA@
	test	esi, 134217728				; 08000000H
	jne	SHORT $LN24@check_body
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN24@check_body:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	eax
	push	OFFSET ??_C@_04HGGBINEM@?$CFs?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 16					; 00000010H
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN26@check_body
$LN25@check_body:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN26@check_body:
	mov	edx, DWORD PTR _msg
	push	ebx
	push	edi
	push	eax
	push	OFFSET ??_C@_0DE@IOKAHOJI@Facet?5?$CFs?5on?5body?5?$CFs?5facet?5list?0?5@
	push	edx
	call	_sprintf

; 927  :         erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring

; 928  :         numerr++;

	mov	ebx, 1
	add	DWORD PTR _numerr$[ebp], ebx
	add	esp, 24					; 00000018H

; 929  :         bad_errors_count++;

	add	DWORD PTR _bad_errors_count, ebx
	jmp	SHORT $LN2@check_body
$LN58@check_body:
	mov	ebx, 1
$LN2@check_body:

; 930  :       }
; 931  :       next_f = get_next_body_facet(f_id);  

	push	esi
	call	_get_next_body_facet
	mov	edi, eax

; 932  :       if ( !equal_id(f_id,get_prev_body_facet(next_f)) )

	push	edi
	call	_get_prev_body_facet
	add	esp, 8
	cmp	esi, eax
	jne	SHORT $LN55@check_body

; 938  :         break;
; 939  :       }
; 940  :       f_id = next_f;

	mov	esi, edi

; 941  :     } while ( !equal_id(f_id,start_f) );

	cmp	edi, DWORD PTR _start_f$89745[ebp]
	je	SHORT $LN4@check_body
	mov	ebx, DWORD PTR tv515[ebp]
	jmp	$LL6@check_body
$LN55@check_body:

; 933  :       { sprintf(msg,"Facet %s next body facet has bad prev_body_facet.\n",
; 934  :          SELNAME(f_id));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN29@check_body
	mov	eax, OFFSET ??_C@_01JOAMLHOP@?9?$AA@
	test	esi, 134217728				; 08000000H
	jne	SHORT $LN28@check_body
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN28@check_body:
	and	esi, 134217727				; 07ffffffH
	add	esi, ebx
	push	esi
	push	eax
	push	OFFSET ??_C@_04HGGBINEM@?$CFs?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 16					; 00000010H
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN30@check_body
$LN29@check_body:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN30@check_body:
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0DD@NEPGCKBF@Facet?5?$CFs?5next?5body?5facet?5has?5bad@
	push	ecx
	call	_sprintf

; 935  :         erroutstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_erroutstring

; 936  :         numerr++;

	add	DWORD PTR _numerr$[ebp], ebx
	add	esp, 16					; 00000010H

; 937  :         bad_errors_count++;

	add	DWORD PTR _bad_errors_count, ebx
$LN4@check_body:
	mov	edi, DWORD PTR _web+348
	mov	ebx, DWORD PTR tv515[ebp]
$LN11@check_body:

; 909  :   body_id b_id;
; 910  : 
; 911  :   FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _b_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv513[ebp], eax
	jne	$LL59@check_body

; 942  :   }
; 943  :   return numerr;

	mov	eax, DWORD PTR _numerr$[ebp]
	pop	edi
$LN10@check_body:
	pop	esi
	pop	ebx

; 944  : }  // end check_body_facets()

	mov	esp, ebp
	pop	ebp
	ret	0
_check_body_facets ENDP
_TEXT	ENDS
PUBLIC	_vvvvcomp
; Function compile flags: /Ogtp
;	COMDAT _vvvvcomp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_vvvvcomp PROC						; COMDAT

; 956  : { int i;

	push	ebp
	mov	ebp, esp

; 957  :   for ( i = 0 ; i < 3 ; i++ )

	mov	ecx, DWORD PTR _b$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _a$[ebp]
	xor	esi, esi
	lea	eax, DWORD PTR [ecx+4]
	sub	edi, ecx
$LL5@vvvvcomp:

; 958  :   { if ( a->v[i] < b->v[i] ) return -1;

	mov	ecx, DWORD PTR [edi+eax]
	mov	edx, DWORD PTR [eax]
	cmp	ecx, edx
	jb	SHORT $LN9@vvvvcomp

; 959  :     if ( a->v[i] > b->v[i] ) return 1;

	ja	SHORT $LN10@vvvvcomp

; 957  :   for ( i = 0 ; i < 3 ; i++ )

	inc	esi
	add	eax, 4
	cmp	esi, 3
	jl	SHORT $LL5@vvvvcomp

; 960  :   }
; 961  :   return 0;

	pop	edi
	xor	eax, eax
	pop	esi

; 962  : } // end vvvvcomp()

	pop	ebp
	ret	0
$LN9@vvvvcomp:
	pop	edi

; 958  :   { if ( a->v[i] < b->v[i] ) return -1;

	or	eax, -1
	pop	esi

; 962  : } // end vvvvcomp()

	pop	ebp
	ret	0
$LN10@vvvvcomp:
	pop	edi

; 959  :     if ( a->v[i] > b->v[i] ) return 1;

	mov	eax, 1
	pop	esi

; 962  : } // end vvvvcomp()

	pop	ebp
	ret	0
_vvvvcomp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@FLFIGBNJ@Facets?5?$CFs?5and?5?$CFs?5have?5same?5verti@ ; `string'
PUBLIC	??_C@_0CL@IGKJHJEK@Facet?5count?5disagrees?5with?5suppo@ ; `string'
PUBLIC	??_C@_0CL@LJFJODBF@Edges?5?$CFs?5and?5?$CFs?5have?5same?5endpoi@ ; `string'
PUBLIC	??_C@_0CK@NEILJMLD@Edge?5count?5disagrees?5with?5suppos@ ; `string'
PUBLIC	??_C@_02MIICKFIN@?4?6?$AA@			; `string'
PUBLIC	??_C@_0BG@MNBJLBP@?5is?5loop?5on?5vertex?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0M@KGDCKMAD@?5?$CIorig?4?5?$CFs?$CJ?$AA@	; `string'
PUBLIC	??_C@_07FKNMECDG@Edge?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_07KPHPMPNA@CHECK?4C?$AA@			; `string'
PUBLIC	_collapse_check
EXTRN	_temp_free:PROC
EXTRN	_qsort:PROC
EXTRN	_kb_temp_calloc:PROC
;	COMDAT ??_C@_0CP@FLFIGBNJ@Facets?5?$CFs?5and?5?$CFs?5have?5same?5verti@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CP@FLFIGBNJ@Facets?5?$CFs?5and?5?$CFs?5have?5same?5verti@ DB 'Face'
	DB	'ts %s and %s have same vertices: %s %s %s.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IGKJHJEK@Facet?5count?5disagrees?5with?5suppo@
CONST	SEGMENT
??_C@_0CL@IGKJHJEK@Facet?5count?5disagrees?5with?5suppo@ DB 'Facet count '
	DB	'disagrees with supposed value.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LJFJODBF@Edges?5?$CFs?5and?5?$CFs?5have?5same?5endpoi@
CONST	SEGMENT
??_C@_0CL@LJFJODBF@Edges?5?$CFs?5and?5?$CFs?5have?5same?5endpoi@ DB 'Edge'
	DB	's %s and %s have same endpoints: %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NEILJMLD@Edge?5count?5disagrees?5with?5suppos@
CONST	SEGMENT
??_C@_0CK@NEILJMLD@Edge?5count?5disagrees?5with?5suppos@ DB 'Edge count d'
	DB	'isagrees with supposed value.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MIICKFIN@?4?6?$AA@
CONST	SEGMENT
??_C@_02MIICKFIN@?4?6?$AA@ DB '.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MNBJLBP@?5is?5loop?5on?5vertex?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BG@MNBJLBP@?5is?5loop?5on?5vertex?5?$CFs?$AA@ DB ' is loop on vert'
	DB	'ex %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KGDCKMAD@?5?$CIorig?4?5?$CFs?$CJ?$AA@
CONST	SEGMENT
??_C@_0M@KGDCKMAD@?5?$CIorig?4?5?$CFs?$CJ?$AA@ DB ' (orig. %s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FKNMECDG@Edge?5?$CFs?$AA@
CONST	SEGMENT
??_C@_07FKNMECDG@Edge?5?$CFs?$AA@ DB 'Edge %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KPHPMPNA@CHECK?4C?$AA@
CONST	SEGMENT
??_C@_07KPHPMPNA@CHECK?4C?$AA@ DB 'CHECK.C', 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\check.c
CONST	ENDS
;	COMDAT _collapse_check
_TEXT	SEGMENT
tv1245 = -28						; size = 4
_v1$ = -28						; size = 4
tv1220 = -24						; size = 4
tv490 = -24						; size = 4
tv413 = -24						; size = 4
_f_id$ = -24						; size = 4
tv1682 = -20						; size = 4
tv1404 = -20						; size = 4
tv510 = -20						; size = 4
tv1930 = -16						; size = 4
tv337 = -16						; size = 4
_v2$ = -16						; size = 4
_vvlist$ = -12						; size = 4
tv1828 = -8						; size = 4
_count$ = -8						; size = 4
_numerr$ = -4						; size = 4
_collapse_check PROC					; COMDAT

; 965  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 966  :   struct vvvv *vvlist,*current;
; 967  :   facet_id f_id;
; 968  :   edge_id e_id;
; 969  :   vertex_id tmp;
; 970  :   vertex_id v1,v2,v3;
; 971  :   int i;
; 972  :   int count;
; 973  :   int numerr = 0;
; 974  :   element_id orig;
; 975  : 
; 976  :   /* check edges */
; 977  :   if ( web.skel[EDGE].count == 0 ) return numerr;

	mov	eax, DWORD PTR _web+176
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR _numerr$[ebp], ebx
	cmp	eax, ebx
	jne	SHORT $LN34@collapse_c
	xor	eax, eax
	pop	ebx

; 1103 : } /* end collapse_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@collapse_c:
	push	esi
	push	edi

; 978  :   vvlist = (struct vvvv *)temp_calloc(web.skel[EDGE].count,sizeof(struct vvvv));

	push	978					; 000003d2H
	push	OFFSET ??_C@_07KPHPMPNA@CHECK?4C?$AA@
	push	16					; 00000010H
	push	eax
	call	_kb_temp_calloc

; 979  : 
; 980  :   current = vvlist;
; 981  :   count = 0;
; 982  :   FOR_ALL_EDGES(e_id)

	mov	esi, DWORD PTR _web+160
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	ecx, 1
	mov	DWORD PTR _vvlist$[ebp], eax
	mov	DWORD PTR _count$[ebp], ebx
	je	$LN31@collapse_c

; 978  :   vvlist = (struct vvvv *)temp_calloc(web.skel[EDGE].count,sizeof(struct vvvv));

	add	eax, 8
	mov	DWORD PTR tv1682[ebp], eax
$LL33@collapse_c:

; 979  : 
; 980  :   current = vvlist;
; 981  :   count = 0;
; 982  :   FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+124
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv1220[ebp], eax
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN32@collapse_c

; 983  :   { 
; 984  :     v1 = get_edge_tailv(e_id);

	mov	eax, DWORD PTR _web+216
	mov	ebx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ebx+304]
	mov	edi, esi
	shr	edi, 27					; 0000001bH
	add	eax, edx
	and	edi, 1
	je	SHORT $LN64@collapse_c
	mov	edx, DWORD PTR _web+636
	mov	ebx, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN63@collapse_c
$LN64@collapse_c:
	mov	ebx, DWORD PTR [eax]
$LN63@collapse_c:

; 985  :     v2 = get_edge_headv(e_id);

	test	edi, edi
	je	SHORT $LN68@collapse_c
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _v2$[ebp], edx
	jmp	SHORT $LN67@collapse_c
$LN68@collapse_c:
	mov	edx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _v2$[ebp], eax
$LN67@collapse_c:

; 986  :     if ( equal_element(v1,v2) && !(get_vattr(v1) & AXIAL_POINT) )

	mov	edx, DWORD PTR _v2$[ebp]
	mov	eax, ebx
	or	eax, 134217728				; 08000000H
	or	edx, 134217728				; 08000000H
	mov	DWORD PTR tv1245[ebp], eax
	cmp	eax, edx
	jne	$LN118@collapse_c
	mov	eax, DWORD PTR _web+12
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	edx, edx
	or	eax, edx
	jne	$LN118@collapse_c

; 987  :     { sprintf(msg,"Edge %s",ELNAME(e_id));

	test	ecx, ecx
	je	SHORT $LN37@collapse_c
	mov	ecx, DWORD PTR tv1220[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN38@collapse_c
$LN37@collapse_c:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN38@collapse_c:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_07FKNMECDG@Edge?5?$CFs?$AA@
	push	edx
	call	_sprintf

; 988  :       erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring

; 989  :       orig = get_original(e_id);

	mov	eax, DWORD PTR tv1220[ebp]
	mov	ecx, esi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+20]
	add	esp, 16					; 00000010H

; 990  :       if ( valid_id(orig) && !equal_element(orig,e_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN117@collapse_c
	mov	edx, eax
	mov	ecx, esi
	or	edx, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	edx, ecx
	je	SHORT $LN117@collapse_c

; 991  :       { sprintf(msg," (orig. %s)",ELNAME(orig));

	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0M@KGDCKMAD@?5?$CIorig?4?5?$CFs?$CJ?$AA@
	push	edx
	call	_sprintf

; 992  :         erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring
	add	esp, 28					; 0000001cH
$LN117@collapse_c:

; 993  :       }
; 994  :       sprintf(msg," is loop on vertex %s",ELNAME(v1));

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN41@collapse_c
	inc	edi
	push	edi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN42@collapse_c
$LN41@collapse_c:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN42@collapse_c:
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BG@MNBJLBP@?5is?5loop?5on?5vertex?5?$CFs?$AA@
	push	ecx
	call	_sprintf

; 995  :       erroutstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_erroutstring

; 996  :       orig = get_original(get_edge_tailv(e_id));

	push	esi
	call	_get_edge_tailv
	mov	edi, eax
	shr	edi, 29					; 0000001dH
	push	esi
	imul	edi, 112				; 00000070H
	call	_get_edge_tailv
	mov	ecx, DWORD PTR _web[edi+12]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+20]
	add	esp, 24					; 00000018H

; 997  :       if ( valid_id(orig) && !equal_element(orig,v1) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN124@collapse_c
	mov	ecx, eax
	or	ecx, 134217728				; 08000000H
	cmp	ecx, DWORD PTR tv1245[ebp]
	je	SHORT $LN124@collapse_c

; 998  :       { sprintf(msg," (orig. %s)",ELNAME(orig));

	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0M@KGDCKMAD@?5?$CIorig?4?5?$CFs?$CJ?$AA@
	push	edx
	call	_sprintf

; 999  :         erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring
	add	esp, 28					; 0000001cH
$LN124@collapse_c:

; 1000 :       }
; 1001 :       erroutstring(".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6?$AA@
	call	_erroutstring

; 1002 :       numerr++;

	mov	eax, 1
	add	DWORD PTR _numerr$[ebp], eax
	add	esp, 4

; 1003 :       edge_loop_count++;

	add	DWORD PTR _edge_loop_count, eax
$LN118@collapse_c:

; 1004 :     }
; 1005 :     if ( v1 <= v2 )

	mov	ecx, DWORD PTR _v2$[ebp]

; 1006 :       { current->id = e_id;

	mov	eax, DWORD PTR tv1682[ebp]
	cmp	ebx, ecx
	ja	SHORT $LN25@collapse_c

; 1007 :         current->v[0] = v1;

	mov	DWORD PTR [eax-4], ebx

; 1008 :         current->v[1] = v2;

	mov	DWORD PTR [eax], ecx

; 1009 :       }
; 1010 :     else

	jmp	SHORT $LN129@collapse_c
$LN25@collapse_c:

; 1011 :       { current->id = inverse_id(e_id);

	xor	esi, 134217728				; 08000000H

; 1012 :         current->v[0] = v2;

	mov	DWORD PTR [eax-4], ecx

; 1013 :         current->v[1] = v1;

	mov	DWORD PTR [eax], ebx
$LN129@collapse_c:

; 1014 :       }
; 1015 :     if ( ++count > web.skel[EDGE].count )

	mov	ebx, DWORD PTR _count$[ebp]
	inc	ebx
	mov	DWORD PTR [eax-8], esi
	mov	DWORD PTR _count$[ebp], ebx
	cmp	ebx, DWORD PTR _web+176
	jg	SHORT $LN109@collapse_c

; 1020 :         break;
; 1021 :       }
; 1022 :     current++;

	add	eax, 16					; 00000010H
	mov	DWORD PTR tv1682[ebp], eax
$LN32@collapse_c:

; 979  : 
; 980  :   current = vvlist;
; 981  :   count = 0;
; 982  :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR tv1220[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	esi, DWORD PTR [eax]
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL33@collapse_c

; 1072 :     current->v[2] = v3;
; 1073 :     if ( ++count > web.skel[FACET].count )

	jmp	SHORT $LN31@collapse_c
$LN109@collapse_c:

; 1016 :       { erroutstring("Edge count disagrees with supposed value.");

	push	OFFSET ??_C@_0CK@NEILJMLD@Edge?5count?5disagrees?5with?5suppos@
	call	_erroutstring

; 1017 :         count--;
; 1018 :         numerr++;

	inc	DWORD PTR _numerr$[ebp]
	add	esp, 4
	dec	ebx

; 1019 :         bad_errors_count++;

	inc	DWORD PTR _bad_errors_count
$LN31@collapse_c:

; 1023 :   }
; 1024 :   qsort((char *)vvlist,count,sizeof(struct vvvv),FCAST vvvvcomp);

	mov	ecx, DWORD PTR _vvlist$[ebp]
	push	OFFSET _vvvvcomp
	push	16					; 00000010H
	push	ebx
	push	ecx
	call	_qsort

; 1025 : 
; 1026 :   /* scan list for duplicates */
; 1027 :   for ( i = 0 ; i < count-1 ; i++ )

	dec	ebx
	add	esp, 16					; 00000010H
	test	ebx, ebx
	jle	$LN123@collapse_c

; 1023 :   }
; 1024 :   qsort((char *)vvlist,count,sizeof(struct vvvv),FCAST vvvvcomp);

	mov	edi, DWORD PTR _vvlist$[ebp]
	add	edi, 16					; 00000010H
	mov	DWORD PTR tv1828[ebp], edi
	mov	DWORD PTR tv413[ebp], ebx
$LL22@collapse_c:

; 1028 :    { if ( vvvvcomp(vvlist+i,vvlist+i+1) == 0 )

	lea	esi, DWORD PTR [edi-16]
	push	edi
	push	esi
	call	_vvvvcomp
	add	esp, 8
	test	eax, eax
	jne	$LN21@collapse_c

; 1029 :      if ( !web.symmetry_flag ||
; 1030 :         (get_edge_wrap(vvlist[i].id) == get_edge_wrap(vvlist[i+1].id)) )

	cmp	DWORD PTR _web+856, eax
	je	$LN17@collapse_c
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _web+124
	mov	esi, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+esi+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN73@collapse_c
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	mov	esi, eax
	jmp	SHORT $LN74@collapse_c
$LN73@collapse_c:
	mov	esi, ecx
$LN74@collapse_c:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+ebx+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN77@collapse_c
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN78@collapse_c
$LN77@collapse_c:
	mov	eax, ecx
$LN78@collapse_c:
	cmp	esi, eax
	jne	$LN21@collapse_c
$LN17@collapse_c:

; 1031 :       { sprintf(errmsg,"Edges %s and %s have same endpoints: %s %s",
; 1032 :          ELNAME(vvlist[i].id),ELNAME1(vvlist[i+1].id),
; 1033 :            ELNAME2(vvlist[i].v[0]), ELNAME3(vvlist[i].v[1]));

	mov	eax, DWORD PTR [edi-8]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN45@collapse_c
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+90
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	edi, OFFSET _elnames+90
	jmp	SHORT $LN46@collapse_c
$LN45@collapse_c:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN46@collapse_c:
	mov	esi, DWORD PTR tv1828[ebp]
	mov	eax, DWORD PTR [esi-12]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN47@collapse_c
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	ebx, OFFSET _elnames+60
	jmp	SHORT $LN48@collapse_c
$LN47@collapse_c:
	mov	ebx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN48@collapse_c:
	mov	eax, DWORD PTR [esi]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN49@collapse_c
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN50@collapse_c
$LN49@collapse_c:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN50@collapse_c:
	mov	eax, DWORD PTR tv1828[ebp]
	mov	eax, DWORD PTR [eax-16]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN51@collapse_c
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN52@collapse_c
$LN51@collapse_c:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN52@collapse_c:
	push	edi
	push	ebx
	push	esi
	push	eax
	push	OFFSET ??_C@_0CL@LJFJODBF@Edges?5?$CFs?5and?5?$CFs?5have?5same?5endpoi@
	push	OFFSET _errmsg
	call	_sprintf

; 1034 :         // erroutstring(errmsg);
; 1035 :          kb_error(8744,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	8744					; 00002228H
	call	_kb_error

; 1036 :          numerr++;
; 1037 :          edges_same_vertices_count++;

	mov	edi, DWORD PTR tv1828[ebp]
	mov	eax, 1
	add	DWORD PTR _numerr$[ebp], eax
	add	esp, 36					; 00000024H
	add	DWORD PTR _edges_same_vertices_count, eax
$LN21@collapse_c:

; 1025 : 
; 1026 :   /* scan list for duplicates */
; 1027 :   for ( i = 0 ; i < count-1 ; i++ )

	add	edi, 16					; 00000010H
	dec	DWORD PTR tv413[ebp]
	mov	DWORD PTR tv1828[ebp], edi
	jne	$LL22@collapse_c
$LN123@collapse_c:

; 1038 :       }
; 1039 :    }
; 1040 :   temp_free((char*)vvlist);

	mov	edx, DWORD PTR _vvlist$[ebp]
	push	edx
	call	_temp_free
	add	esp, 4

; 1041 : 
; 1042 :   if ( web.representation == STRING ) return numerr;

	cmp	DWORD PTR _web+624, 1
	je	$LN130@collapse_c

; 1043 : 
; 1044 : #ifdef MPI_EVOLVER
; 1045 :   if ( mpi_corona_state == NO_CORONA )
; 1046 :      return numerr;
; 1047 : #endif
; 1048 : 
; 1049 :   /* check facets */
; 1050 :   if ( web.skel[FACET].count == 0 ) return numerr;

	mov	eax, DWORD PTR _web+288
	test	eax, eax
	je	$LN130@collapse_c

; 1051 :   vvlist = (struct vvvv *)temp_calloc(web.skel[FACET].count,sizeof(struct vvvv));

	push	1051					; 0000041bH
	push	OFFSET ??_C@_07KPHPMPNA@CHECK?4C?$AA@
	push	16					; 00000010H
	push	eax
	call	_kb_temp_calloc

; 1052 : 
; 1053 :   current = vvlist;
; 1054 :   count = 0;
; 1055 :   FOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR _web+272
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	ecx, 1
	mov	DWORD PTR _vvlist$[ebp], eax
	mov	DWORD PTR _count$[ebp], 0
	mov	DWORD PTR _f_id$[ebp], esi
	je	$LN116@collapse_c

; 1051 :   vvlist = (struct vvvv *)temp_calloc(web.skel[FACET].count,sizeof(struct vvvv));

	mov	ebx, DWORD PTR _web+236
	add	eax, 8
	mov	DWORD PTR tv1930[ebp], eax
	npad	8
$LL14@collapse_c:

; 1052 : 
; 1053 :   current = vvlist;
; 1054 :   count = 0;
; 1055 :   FOR_ALL_FACETS(f_id)

	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN13@collapse_c

; 1056 :   { 
; 1057 :     facetedge_id fe;
; 1058 :     fe = get_facet_fe(f_id);

	test	ecx, ecx
	je	SHORT $LN81@collapse_c
$LN80@collapse_c:
	mov	edx, DWORD PTR [edx+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN79@collapse_c
	xor	edx, 134217728				; 08000000H
$LN79@collapse_c:
	mov	edi, edx
$LN81@collapse_c:

; 1059 :     v1 = positive_id(get_fe_tailv(fe));

	mov	ecx, DWORD PTR _web+460
	mov	ebx, DWORD PTR _web+636
	mov	esi, DWORD PTR _web+124
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv1404[ebp], eax
	mov	eax, DWORD PTR [eax+20]
	mov	edx, edi
	and	edx, 134217728				; 08000000H
	xor	eax, edx
	test	eax, 134217728				; 08000000H
	je	SHORT $LN86@collapse_c
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [ecx+edx+304]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	lea	ecx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [ecx+edx]
	jmp	SHORT $LN85@collapse_c
$LN86@collapse_c:
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ecx+304]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR [edx+ecx]
$LN85@collapse_c:
	and	ecx, -134217729				; f7ffffffH
	mov	DWORD PTR _v1$[ebp], ecx

; 1060 :     v2 = positive_id(get_fe_headv(fe));

	test	eax, 134217728				; 08000000H
	je	SHORT $LN92@collapse_c
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	ecx, DWORD PTR [edx+eax]
	jmp	SHORT $LN91@collapse_c
$LN92@collapse_c:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+eax*4]
	lea	eax, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [eax+edx]
$LN91@collapse_c:

; 1061 :     v3 = positive_id(get_fe_headv(get_next_edge(fe)));

	mov	eax, DWORD PTR tv1404[ebp]
	and	ecx, -134217729				; f7ffffffH
	test	edi, 134217728				; 08000000H
	je	SHORT $LN96@collapse_c
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN95@collapse_c
$LN96@collapse_c:
	mov	eax, DWORD PTR [eax+32]
$LN95@collapse_c:
	mov	ebx, DWORD PTR _web+460
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN102@collapse_c
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	edx, DWORD PTR [edx+eax]
	jmp	SHORT $LN101@collapse_c
$LN102@collapse_c:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+esi*4]
	mov	edx, DWORD PTR [eax+edx]
$LN101@collapse_c:

; 1062 :     /* bubble sort */
; 1063 :     if ( v1 > v2 )

	mov	edi, DWORD PTR _v1$[ebp]

; 1064 :       { tmp = v1; v1 = v2; v2 = tmp; invert(f_id); }

	mov	esi, DWORD PTR _f_id$[ebp]
	and	edx, -134217729				; f7ffffffH
	cmp	edi, ecx
	jbe	SHORT $LN9@collapse_c
	mov	eax, edi
	mov	edi, ecx
	mov	ecx, eax
	xor	esi, 134217728				; 08000000H
$LN9@collapse_c:

; 1065 :     if ( v2 > v3 )

	cmp	ecx, edx
	jbe	SHORT $LN8@collapse_c

; 1066 :       { tmp = v2; v2 = v3; v3 = tmp; invert(f_id); }

	mov	eax, ecx
	mov	ecx, edx
	mov	edx, eax
	xor	esi, 134217728				; 08000000H
$LN8@collapse_c:

; 1067 :     if ( v1 > v2 )

	cmp	edi, ecx
	jbe	SHORT $LN7@collapse_c

; 1068 :       { tmp = v1; v1 = v2; v2 = tmp; invert(f_id); }

	mov	eax, edi
	mov	edi, ecx
	mov	ecx, eax
	xor	esi, 134217728				; 08000000H
$LN7@collapse_c:

; 1069 :     current->id = f_id;

	mov	eax, DWORD PTR tv1930[ebp]

; 1070 :     current->v[0] = v1;
; 1071 :     current->v[1] = v2;

	mov	DWORD PTR [eax], ecx

; 1072 :     current->v[2] = v3;
; 1073 :     if ( ++count > web.skel[FACET].count )

	mov	ecx, DWORD PTR _count$[ebp]
	inc	ecx
	mov	DWORD PTR [eax-8], esi
	mov	DWORD PTR [eax-4], edi
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR _count$[ebp], ecx
	cmp	ecx, DWORD PTR _web+288
	jg	$LN110@collapse_c

; 1079 :         break;
; 1080 :       }
; 1081 :     current++;

	mov	ebx, DWORD PTR _web+236
	add	eax, 16					; 00000010H
	mov	DWORD PTR tv1930[ebp], eax
$LN13@collapse_c:

; 1052 : 
; 1053 :   current = vvlist;
; 1054 :   count = 0;
; 1055 :   FOR_ALL_FACETS(f_id)

	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+esi*4]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _f_id$[ebp], esi
	jne	$LL14@collapse_c
$LN116@collapse_c:

; 1082 :   }
; 1083 :   qsort((char *)vvlist,count,sizeof(struct vvvv),FCAST vvvvcomp);

	mov	esi, DWORD PTR _count$[ebp]
	mov	ebx, DWORD PTR _vvlist$[ebp]
	push	OFFSET _vvvvcomp
	push	16					; 00000010H
	push	esi
	push	ebx
	call	_qsort

; 1084 : 
; 1085 :   /* scan list for duplicates */
; 1086 :   for ( i = 0 ; i < count-1 ; i++ )

	lea	eax, DWORD PTR [esi-1]
	add	esp, 16					; 00000010H
	test	eax, eax
	jle	$LN121@collapse_c

; 1082 :   }
; 1083 :   qsort((char *)vvlist,count,sizeof(struct vvvv),FCAST vvvvcomp);

	mov	esi, DWORD PTR _web+12
	add	ebx, 8
	mov	DWORD PTR tv337[ebp], eax
	npad	7
$LL126@collapse_c:

; 1087 :   { if ( (vvvvcomp(vvlist+i,vvlist+i+1) == 0) 
; 1088 :           && !(get_vattr(vvlist[i].v[0]) & AXIAL_POINT)
; 1089 :           && !(get_vattr(vvlist[i].v[1]) & AXIAL_POINT)
; 1090 :           && !(get_vattr(vvlist[i].v[2]) & AXIAL_POINT)
; 1091 :        )

	lea	eax, DWORD PTR [ebx+8]
	lea	ecx, DWORD PTR [ebx-8]
	push	eax
	push	ecx
	call	_vvvvcomp
	add	esp, 8
	test	eax, eax
	jne	$LN3@collapse_c
	mov	edx, DWORD PTR [ebx-4]
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN3@collapse_c
	mov	eax, DWORD PTR [ebx]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	or	eax, ecx
	jne	$LN3@collapse_c
	mov	edx, DWORD PTR [ebx+4]
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	edi, edi
	or	eax, edi
	jne	$LN3@collapse_c

; 1092 :     { sprintf(errmsg,"Facets %s and %s have same vertices: %s %s %s.",
; 1093 :          ELNAME(vvlist[i].id),ELNAME1(vvlist[i+1].id), ELNAME2(vvlist[i].v[0]),
; 1094 :          ELNAME3(vvlist[i].v[1]),ELNAME4(vvlist[i].v[2]));

	test	edx, 268435456				; 10000000H
	je	SHORT $LN53@collapse_c
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+120
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv490[ebp], OFFSET _elnames+120
	jmp	SHORT $LN54@collapse_c
$LN110@collapse_c:

; 1074 :       { erroutstring("Facet count disagrees with supposed value.");

	push	OFFSET ??_C@_0CL@IGKJHJEK@Facet?5count?5disagrees?5with?5suppo@
	call	_erroutstring

; 1075 :         bad_errors_count++;
; 1076 :         count--;
; 1077 :         if ( ++numerr > MAXERR )

	mov	esi, DWORD PTR _numerr$[ebp]
	inc	DWORD PTR _bad_errors_count
	dec	DWORD PTR _count$[ebp]
	inc	esi
	add	esp, 4
	mov	DWORD PTR _numerr$[ebp], esi
	cmp	esi, 20					; 00000014H
	jle	$LN116@collapse_c

; 1078 :               {erroutstring("Too many errors.\n"); return numerr;}

	push	OFFSET ??_C@_0BC@CGAIEGBL@Too?5many?5errors?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 1103 : } /* end collapse_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@collapse_c:

; 1092 :     { sprintf(errmsg,"Facets %s and %s have same vertices: %s %s %s.",
; 1093 :          ELNAME(vvlist[i].id),ELNAME1(vvlist[i+1].id), ELNAME2(vvlist[i].v[0]),
; 1094 :          ELNAME3(vvlist[i].v[1]),ELNAME4(vvlist[i].v[2]));

	mov	DWORD PTR tv490[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN54@collapse_c:
	mov	eax, DWORD PTR [ebx]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN55@collapse_c
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+90
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv510[ebp], OFFSET _elnames+90
	jmp	SHORT $LN56@collapse_c
$LN55@collapse_c:
	mov	DWORD PTR tv510[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN56@collapse_c:
	mov	eax, DWORD PTR [ebx-4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN57@collapse_c
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	edi, OFFSET _elnames+60
	jmp	SHORT $LN58@collapse_c
$LN57@collapse_c:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN58@collapse_c:
	mov	eax, DWORD PTR [ebx+8]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN59@collapse_c
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN60@collapse_c
$LN59@collapse_c:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN60@collapse_c:
	mov	eax, DWORD PTR [ebx-8]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN61@collapse_c
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN62@collapse_c
$LN61@collapse_c:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN62@collapse_c:
	mov	ecx, DWORD PTR tv490[ebp]
	mov	edx, DWORD PTR tv510[ebp]
	push	ecx
	push	edx
	push	edi
	push	esi
	push	eax
	push	OFFSET ??_C@_0CP@FLFIGBNJ@Facets?5?$CFs?5and?5?$CFs?5have?5same?5verti@
	push	OFFSET _errmsg
	call	_sprintf

; 1095 :      // erroutstring(errmsg);
; 1096 :       kb_error(8473,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	8473					; 00002119H
	call	_kb_error

; 1097 :       numerr++;
; 1098 :       facets_same_vertices_count++;

	mov	esi, DWORD PTR _web+12
	mov	eax, 1
	add	DWORD PTR _numerr$[ebp], eax
	add	esp, 40					; 00000028H
	add	DWORD PTR _facets_same_vertices_count, eax
$LN3@collapse_c:

; 1084 : 
; 1085 :   /* scan list for duplicates */
; 1086 :   for ( i = 0 ; i < count-1 ; i++ )

	add	ebx, 16					; 00000010H
	dec	DWORD PTR tv337[ebp]
	jne	$LL126@collapse_c
	mov	ebx, DWORD PTR _vvlist$[ebp]
$LN121@collapse_c:

; 1099 :     }
; 1100 :   }
; 1101 :   temp_free((char*)vvlist);

	push	ebx
	call	_temp_free
	add	esp, 4
$LN130@collapse_c:

; 1102 :   return numerr;

	mov	eax, DWORD PTR _numerr$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 1103 : } /* end collapse_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
_collapse_check ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_normal_change_check
EXTRN	_dot:PROC
EXTRN	_cross_prod:PROC
EXTRN	_eval:PROC
EXTRN	_saved:BYTE
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@0000000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\check.c
CONST	ENDS
;	COMDAT _normal_change_check
_TEXT	SEGMENT
_max_delta$ = -388					; size = 8
tv4157 = -380						; size = 8
tv1482 = -380						; size = 8
tv1551 = -376						; size = 4
tv1517 = -376						; size = 4
_v_id$ = -372						; size = 4
tv1476 = -368						; size = 4
_f_id$ = -364						; size = 4
tv2261 = -360						; size = 4
tv1500 = -356						; size = 4
tv1473 = -356						; size = 4
tv3295 = -352						; size = 4
tv1497 = -352						; size = 4
tv3279 = -348						; size = 4
tv2242 = -348						; size = 4
_fe$ = -344						; size = 4
_new_normal$ = -340					; size = 48
_old_normal$ = -292					; size = 48
_x$ = -244						; size = 144
_side$ = -100						; size = 96
__$ArrayPad$ = -4					; size = 4
_normal_change_check PROC				; COMDAT

; 1116 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1117 :   facet_id f_id;
; 1118 :   facetedge_id fe;
; 1119 :   vertex_id v_id;
; 1120 :   REAL side[2][MAXCOORD];
; 1121 :   REAL max_delta;
; 1122 :   REAL old_normal[MAXCOORD];
; 1123 :   REAL new_normal[MAXCOORD];
; 1124 :   REAL x[3][MAXCOORD];
; 1125 :   int ord_v;
; 1126 :   REAL diff;
; 1127 :   struct boundary *bdry;
; 1128 :   int i,n;
; 1129 : 
; 1130 :   max_delta = 0.0;

	fldz
	push	ebx

; 1131 : 
; 1132 :   FOR_ALL_FACETS(f_id)

	mov	ebx, DWORD PTR _web+272
	fst	QWORD PTR _max_delta$[ebp]
	mov	eax, ebx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _f_id$[ebp], ebx
	mov	DWORD PTR tv1473[ebp], eax
	je	$LN31@normal_cha
	push	esi
	push	edi
	jmp	SHORT $LN33@normal_cha
$LN104@normal_cha:
	mov	ebx, DWORD PTR _f_id$[ebp]
$LN33@normal_cha:
	mov	eax, DWORD PTR _web+236
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv1482[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv1476[ebp], edi
	je	$LN32@normal_cha

; 1133 :   { int ii;
; 1134 :     if ( get_fattr(f_id) & FIXED ) continue;

	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	jne	$LN32@normal_cha
	fstp	ST(0)

; 1135 : 
; 1136 :     /* get old normal */
; 1137 :     fe = get_facet_fe(f_id);

	cmp	DWORD PTR tv1473[ebp], eax
	jne	SHORT $LN41@normal_cha

; 1138 :     for ( ii = 0 ; ii < FACET_EDGES ; ii++, fe = get_next_edge(fe) )

	lea	ecx, DWORD PTR _x$[ebp+8]
	mov	DWORD PTR _fe$[ebp], eax
	mov	DWORD PTR tv2242[ebp], esi
	mov	DWORD PTR tv2261[ebp], ecx
	jmp	SHORT $LN44@normal_cha

; 1135 : 
; 1136 :     /* get old normal */
; 1137 :     fe = get_facet_fe(f_id);

$LN41@normal_cha:
	mov	edx, DWORD PTR [edx+28]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN40@normal_cha
	xor	edx, 134217728				; 08000000H
$LN40@normal_cha:

; 1138 :     for ( ii = 0 ; ii < FACET_EDGES ; ii++, fe = get_next_edge(fe) )

	lea	ecx, DWORD PTR _x$[ebp+8]
	mov	DWORD PTR _fe$[ebp], edx
	mov	eax, edx
	mov	DWORD PTR tv2242[ebp], esi
	mov	DWORD PTR tv2261[ebp], ecx
	jmp	SHORT $LN44@normal_cha
	npad	7
$LL105@normal_cha:
	mov	eax, DWORD PTR _fe$[ebp]
$LN44@normal_cha:

; 1139 :     {
; 1140 :       v_id = get_fe_tailv(fe);

	mov	edx, DWORD PTR _web+460
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+edx]
	mov	edx, DWORD PTR _web+124
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+216
	mov	DWORD PTR tv1497[ebp], edi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN51@normal_cha
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+304]
	mov	ecx, DWORD PTR _web+636
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _v_id$[ebp], edx
	jmp	SHORT $LN50@normal_cha
$LN51@normal_cha:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _v_id$[ebp], edx
$LN50@normal_cha:

; 1141 :       ord_v = loc_ordinal(v_id);

	test	edx, 268435456				; 10000000H
	je	SHORT $LN36@normal_cha
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	jmp	SHORT $LN37@normal_cha
$LN36@normal_cha:
	or	esi, -1
$LN37@normal_cha:

; 1142 :       if ( get_vattr(v_id) & BOUNDARY )     

	mov	ecx, DWORD PTR _web+12
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 128				; 00000080H
	xor	ebx, ebx
	or	eax, ebx
	je	$LN24@normal_cha

; 1143 :       { bdry = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN38@normal_cha
	mov	ebx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN39@normal_cha
$LN38@normal_cha:
	xor	eax, eax
$LN39@normal_cha:

; 1144 :         for ( i = 0 ; i < SDIM ; i++ )

	xor	ebx, ebx
	cmp	DWORD PTR _web+616, ebx
	jle	$LN26@normal_cha
	mov	edi, DWORD PTR tv2261[ebp]
	lea	ecx, DWORD PTR [esi+esi*2]
	shl	ecx, 4
	mov	DWORD PTR tv1551[ebp], ecx
	add	edi, -8					; fffffff8H
	lea	esi, DWORD PTR [eax+48]
	jmp	SHORT $LN23@normal_cha
$LL102@normal_cha:
	mov	edx, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR tv1551[ebp]
$LN23@normal_cha:

; 1145 :           x[ii][i] = eval(bdry->coordf[i],saved.coord[ord_v],v_id,NULL);

	add	ecx, DWORD PTR _saved
	mov	eax, DWORD PTR [esi]
	push	0
	push	edx
	push	ecx
	push	eax
	call	_eval
	fstp	QWORD PTR [edi]
	inc	ebx
	add	esp, 16					; 00000010H
	add	esi, 4
	add	edi, 8
	cmp	ebx, DWORD PTR _web+616
	jl	SHORT $LL102@normal_cha

; 1146 :       }
; 1147 :       else

	jmp	$LN109@normal_cha
$LN24@normal_cha:

; 1148 :       {    
; 1149 :         for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR _web+616
	xor	ebx, ebx
	cmp	edi, 4
	jl	SHORT $LN106@normal_cha
	mov	ecx, DWORD PTR tv2261[ebp]
	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 4
	add	eax, DWORD PTR _saved
	lea	edx, DWORD PTR [edi-4]
	shr	edx, 2
	inc	edx
	lea	ebx, DWORD PTR [edx*4]
$LL88@normal_cha:

; 1150 :            x[ii][i] = saved.coord[ord_v][i];

	fld	QWORD PTR [eax]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [ecx-8]
	add	ecx, 32					; 00000020H
	dec	edx
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [ecx-32]
	fld	QWORD PTR [eax-16]
	fstp	QWORD PTR [ecx-24]
	fld	QWORD PTR [eax-8]
	fstp	QWORD PTR [ecx-16]
	jne	SHORT $LL88@normal_cha
$LN106@normal_cha:

; 1148 :       {    
; 1149 :         for ( i = 0 ; i < SDIM ; i++ )

	cmp	ebx, edi
	jge	SHORT $LN109@normal_cha
	mov	ecx, DWORD PTR _saved
	mov	edi, DWORD PTR tv2242[ebp]
	lea	edx, DWORD PTR [esi+esi*2]
	lea	eax, DWORD PTR [ebx+edx*2]
	lea	esi, DWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR _web+616
	sub	ecx, ebx
	add	edi, ebx
	add	ecx, ecx
	lea	edi, DWORD PTR _x$[ebp+edi*8]
	and	ecx, 1073741822				; 3ffffffeH
	rep movsd
$LN109@normal_cha:

; 1146 :       }
; 1147 :       else

	mov	edi, DWORD PTR tv1497[ebp]
$LN26@normal_cha:

; 1138 :     for ( ii = 0 ; ii < FACET_EDGES ; ii++, fe = get_next_edge(fe) )

	add	DWORD PTR tv2261[ebp], 48		; 00000030H
	add	DWORD PTR tv2242[ebp], 6
	test	DWORD PTR _fe$[ebp], 134217728		; 08000000H
	je	SHORT $LN45@normal_cha
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN125@normal_cha
$LN45@normal_cha:
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edx+32]
$LN125@normal_cha:
	cmp	DWORD PTR tv2242[ebp], 18		; 00000012H
	mov	DWORD PTR _fe$[ebp], eax
	jl	$LL105@normal_cha

; 1151 :       }
; 1152 :     }
; 1153 :     for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	xor	eax, eax
	cmp	edx, 4
	jl	$LC90@normal_cha
	lea	ecx, DWORD PTR [edx-3]
	npad	1
$LL91@normal_cha:

; 1154 :     { side[0][i] = x[1][i] - x[0][i];

	fld	QWORD PTR _x$[ebp+eax*8+48]

; 1155 :       side[1][i] = x[2][i] - x[0][i];

	add	eax, 4
	fsub	QWORD PTR _x$[ebp+eax*8-32]
	fstp	QWORD PTR _side$[ebp+eax*8-32]
	fld	QWORD PTR _x$[ebp+eax*8+64]
	fsub	QWORD PTR _x$[ebp+eax*8-32]
	fstp	QWORD PTR _side$[ebp+eax*8+16]
	fld	QWORD PTR _x$[ebp+eax*8+24]
	fsub	QWORD PTR _x$[ebp+eax*8-24]
	fstp	QWORD PTR _side$[ebp+eax*8-24]
	fld	QWORD PTR _x$[ebp+eax*8+72]
	fsub	QWORD PTR _x$[ebp+eax*8-24]
	fstp	QWORD PTR _side$[ebp+eax*8+24]
	fld	QWORD PTR _x$[ebp+eax*8+32]
	fsub	QWORD PTR _x$[ebp+eax*8-16]
	fstp	QWORD PTR _side$[ebp+eax*8-16]
	fld	QWORD PTR _x$[ebp+eax*8+80]
	fsub	QWORD PTR _x$[ebp+eax*8-16]
	fstp	QWORD PTR _side$[ebp+eax*8+32]
	fld	QWORD PTR _x$[ebp+eax*8+40]
	fsub	QWORD PTR _x$[ebp+eax*8-8]
	fstp	QWORD PTR _side$[ebp+eax*8-8]
	fld	QWORD PTR _x$[ebp+eax*8+88]
	fsub	QWORD PTR _x$[ebp+eax*8-8]
	fstp	QWORD PTR _side$[ebp+eax*8+40]
	cmp	eax, ecx
	jl	$LL91@normal_cha
$LC90@normal_cha:

; 1151 :       }
; 1152 :     }
; 1153 :     for ( i = 0 ; i < SDIM ; i++ )

	cmp	eax, edx
	jge	SHORT $LN89@normal_cha
	npad	14
$LC16@normal_cha:

; 1154 :     { side[0][i] = x[1][i] - x[0][i];

	fld	QWORD PTR _x$[ebp+eax*8+48]
	inc	eax
	fsub	QWORD PTR _x$[ebp+eax*8-8]
	fstp	QWORD PTR _side$[ebp+eax*8-8]

; 1155 :       side[1][i] = x[2][i] - x[0][i];

	fld	QWORD PTR _x$[ebp+eax*8+88]
	fsub	QWORD PTR _x$[ebp+eax*8-8]
	fstp	QWORD PTR _side$[ebp+eax*8+40]
	cmp	eax, edx
	jl	SHORT $LC16@normal_cha
$LN89@normal_cha:

; 1156 :     }
; 1157 :     cross_prod(side[0],side[1],old_normal);

	lea	ecx, DWORD PTR _old_normal$[ebp]
	push	ecx
	lea	edx, DWORD PTR _side$[ebp+48]
	push	edx
	lea	eax, DWORD PTR _side$[ebp]
	push	eax
	call	_cross_prod
	add	esp, 12					; 0000000cH

; 1158 : 
; 1159 :     /* get new normal */
; 1160 :     fe = get_facet_fe(f_id);

	cmp	DWORD PTR tv1473[ebp], 0
	jne	SHORT $LN55@normal_cha
	xor	edx, edx
	mov	DWORD PTR _fe$[ebp], edx
	jmp	SHORT $LN56@normal_cha
$LN55@normal_cha:
	test	DWORD PTR _f_id$[ebp], 134217728	; 08000000H
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR tv1476[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [eax+28]
	je	SHORT $LN54@normal_cha
	xor	eax, 134217728				; 08000000H
$LN54@normal_cha:
	mov	DWORD PTR _fe$[ebp], eax
	mov	edx, eax
$LN56@normal_cha:

; 1161 :     for ( n = 0 ; n < FACET_EDGES ; n++, fe = get_next_edge(fe) )

	mov	ecx, DWORD PTR _web+216
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [ecx+eax+304]
	mov	ebx, DWORD PTR _web+616
	lea	ecx, DWORD PTR _x$[ebp+8]
	mov	DWORD PTR tv1517[ebp], esi
	mov	DWORD PTR tv3279[ebp], 0
	mov	DWORD PTR tv3295[ebp], ecx
	jmp	SHORT $LN58@normal_cha
$LL107@normal_cha:
	mov	edx, DWORD PTR _fe$[ebp]
	mov	esi, DWORD PTR tv1517[ebp]
$LN58@normal_cha:

; 1162 :     {
; 1163 :       v_id = get_fe_tailv(fe);

	mov	ecx, DWORD PTR _web+460
	mov	edi, DWORD PTR _web+124
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR tv1500[ebp], ecx
	test	eax, 134217728				; 08000000H
	je	SHORT $LN65@normal_cha
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+edi*4]
	mov	esi, DWORD PTR [eax+esi]
	jmp	SHORT $LN64@normal_cha
$LN65@normal_cha:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	esi, DWORD PTR [esi+eax]
$LN64@normal_cha:

; 1164 :       for ( i = 0 ; i < SDIM ; i++ )

	xor	edi, edi
	cmp	ebx, 4
	jl	SHORT $LN108@normal_cha
	mov	edx, DWORD PTR _web+12
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+edx+64]
	mov	edx, DWORD PTR tv3295[ebp]
	lea	ecx, DWORD PTR [eax+ecx+16]
	lea	eax, DWORD PTR [ebx-4]
	shr	eax, 2
	inc	eax
	lea	edi, DWORD PTR [eax*4]
	npad	2
$LL94@normal_cha:

; 1165 :           x[n][i] = get_coord(v_id)[i];

	fld	QWORD PTR [ecx-16]
	add	ecx, 32					; 00000020H
	fstp	QWORD PTR [edx-8]
	add	edx, 32					; 00000020H
	dec	eax
	fld	QWORD PTR [ecx-40]
	fstp	QWORD PTR [edx-32]
	fld	QWORD PTR [ecx-32]
	fstp	QWORD PTR [edx-24]
	fld	QWORD PTR [ecx-24]
	fstp	QWORD PTR [edx-16]
	jne	SHORT $LL94@normal_cha

; 1164 :       for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _fe$[ebp]
	mov	ecx, DWORD PTR tv1500[ebp]
$LN108@normal_cha:
	cmp	edi, ebx
	jge	SHORT $LN12@normal_cha
	mov	eax, DWORD PTR _web+12
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR _dymem
	add	ecx, DWORD PTR [eax+esi+64]
	mov	eax, DWORD PTR tv3279[ebp]
	lea	esi, DWORD PTR [ecx+edi*8]
	add	eax, edi
	mov	ecx, ebx
	sub	ecx, edi
	add	ecx, ecx
	lea	eax, DWORD PTR _x$[ebp+eax*8]
	and	ecx, 1073741822				; 3ffffffeH
	mov	edi, eax
	rep movsd
	mov	ecx, DWORD PTR tv1500[ebp]
$LN12@normal_cha:

; 1161 :     for ( n = 0 ; n < FACET_EDGES ; n++, fe = get_next_edge(fe) )

	add	DWORD PTR tv3295[ebp], 48		; 00000030H
	add	DWORD PTR tv3279[ebp], 6
	test	edx, 134217728				; 08000000H
	je	SHORT $LN59@normal_cha
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _fe$[ebp], eax
	jmp	SHORT $LN82@normal_cha
$LN59@normal_cha:
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _fe$[ebp], edx
$LN82@normal_cha:
	cmp	DWORD PTR tv3279[ebp], 18		; 00000012H
	jl	$LL107@normal_cha

; 1166 :     }
; 1167 :     for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	ebx, 4
	jl	$LC96@normal_cha
	lea	ecx, DWORD PTR [ebx-3]
$LL97@normal_cha:

; 1168 :     { side[0][i] = x[1][i] - x[0][i];

	fld	QWORD PTR _x$[ebp+eax*8+48]

; 1169 :       side[1][i] = x[2][i] - x[0][i];

	add	eax, 4
	fsub	QWORD PTR _x$[ebp+eax*8-32]
	fstp	QWORD PTR _side$[ebp+eax*8-32]
	fld	QWORD PTR _x$[ebp+eax*8+64]
	fsub	QWORD PTR _x$[ebp+eax*8-32]
	fstp	QWORD PTR _side$[ebp+eax*8+16]
	fld	QWORD PTR _x$[ebp+eax*8+24]
	fsub	QWORD PTR _x$[ebp+eax*8-24]
	fstp	QWORD PTR _side$[ebp+eax*8-24]
	fld	QWORD PTR _x$[ebp+eax*8+72]
	fsub	QWORD PTR _x$[ebp+eax*8-24]
	fstp	QWORD PTR _side$[ebp+eax*8+24]
	fld	QWORD PTR _x$[ebp+eax*8+32]
	fsub	QWORD PTR _x$[ebp+eax*8-16]
	fstp	QWORD PTR _side$[ebp+eax*8-16]
	fld	QWORD PTR _x$[ebp+eax*8+80]
	fsub	QWORD PTR _x$[ebp+eax*8-16]
	fstp	QWORD PTR _side$[ebp+eax*8+32]
	fld	QWORD PTR _x$[ebp+eax*8+40]
	fsub	QWORD PTR _x$[ebp+eax*8-8]
	fstp	QWORD PTR _side$[ebp+eax*8-8]
	fld	QWORD PTR _x$[ebp+eax*8+88]
	fsub	QWORD PTR _x$[ebp+eax*8-8]
	fstp	QWORD PTR _side$[ebp+eax*8+40]
	cmp	eax, ecx
	jl	$LL97@normal_cha
$LC96@normal_cha:

; 1166 :     }
; 1167 :     for ( i = 0 ; i < SDIM ; i++ )

	cmp	eax, ebx
	jge	SHORT $LN95@normal_cha
	npad	14
$LC7@normal_cha:

; 1168 :     { side[0][i] = x[1][i] - x[0][i];

	fld	QWORD PTR _x$[ebp+eax*8+48]
	inc	eax
	fsub	QWORD PTR _x$[ebp+eax*8-8]
	fstp	QWORD PTR _side$[ebp+eax*8-8]

; 1169 :       side[1][i] = x[2][i] - x[0][i];

	fld	QWORD PTR _x$[ebp+eax*8+88]
	fsub	QWORD PTR _x$[ebp+eax*8-8]
	fstp	QWORD PTR _side$[ebp+eax*8+40]
	cmp	eax, ebx
	jl	SHORT $LC7@normal_cha
$LN95@normal_cha:

; 1170 :     }
; 1171 :     cross_prod(side[0],side[1],new_normal);

	lea	eax, DWORD PTR _new_normal$[ebp]
	push	eax
	lea	ecx, DWORD PTR _side$[ebp+48]
	push	ecx
	lea	edx, DWORD PTR _side$[ebp]
	push	edx
	call	_cross_prod

; 1172 : 
; 1173 :     /* test difference */
; 1174 :     for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	xor	eax, eax
	cmp	ecx, 4
	jl	SHORT $LC99@normal_cha
	lea	edx, DWORD PTR [ecx-3]
$LL100@normal_cha:

; 1175 :      side[0][i] = new_normal[i] - old_normal[i];

	fld	QWORD PTR _new_normal$[ebp+eax*8]
	add	eax, 4
	fsub	QWORD PTR _old_normal$[ebp+eax*8-32]
	fstp	QWORD PTR _side$[ebp+eax*8-32]
	fld	QWORD PTR _new_normal$[ebp+eax*8-24]
	fsub	QWORD PTR _old_normal$[ebp+eax*8-24]
	fstp	QWORD PTR _side$[ebp+eax*8-24]
	fld	QWORD PTR _new_normal$[ebp+eax*8-16]
	fsub	QWORD PTR _old_normal$[ebp+eax*8-16]
	fstp	QWORD PTR _side$[ebp+eax*8-16]
	fld	QWORD PTR _new_normal$[ebp+eax*8-8]
	fsub	QWORD PTR _old_normal$[ebp+eax*8-8]
	fstp	QWORD PTR _side$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LL100@normal_cha
$LC99@normal_cha:

; 1172 : 
; 1173 :     /* test difference */
; 1174 :     for ( i = 0 ; i < SDIM ; i++ )

	cmp	eax, ecx
	jge	SHORT $LN98@normal_cha
	npad	10
$LC4@normal_cha:

; 1175 :      side[0][i] = new_normal[i] - old_normal[i];

	fld	QWORD PTR _new_normal$[ebp+eax*8]
	inc	eax
	fsub	QWORD PTR _old_normal$[ebp+eax*8-8]
	fstp	QWORD PTR _side$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LC4@normal_cha
$LN98@normal_cha:

; 1176 :     diff = sqrt(SDIM_dot(side[0],side[0])/
; 1177 :                          SDIM_dot(old_normal,old_normal));

	push	ecx
	lea	eax, DWORD PTR _side$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fstp	QWORD PTR tv4157[ebp]
	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _old_normal$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fdivr	QWORD PTR tv4157[ebp]
	add	esp, 24					; 00000018H
	call	__CIsqrt

; 1178 :     if ( diff > max_delta ) 

	fld	QWORD PTR _max_delta$[ebp]

; 1179 :     max_delta = diff;

	mov	edi, DWORD PTR tv1476[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN123@normal_cha
	fstp	ST(0)
	fst	QWORD PTR _max_delta$[ebp]
	jmp	SHORT $LN32@normal_cha
$LN123@normal_cha:

; 1178 :     if ( diff > max_delta ) 

	fstp	ST(1)
$LN32@normal_cha:

; 1131 : 
; 1132 :   FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _f_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv1473[ebp], eax
	jne	$LN104@normal_cha
	pop	edi
	pop	esi
$LN31@normal_cha:

; 1180 :   }
; 1181 : 
; 1182 :   return max_delta;
; 1183 : } /* end normal_change_check() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_normal_change_check ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@JFAIPCJF@Wraps?5around?5facet?5?$CFs?5not?5consis@ ; `string'
PUBLIC	??_C@_0CC@JHIFPKDJ@Facet?5?$CFs?5has?5unclosed?5edge?5loop?4@ ; `string'
PUBLIC	??_C@_0CC@PAEAJMKC@Big?5wrap?5?$CFd?5on?5edge?5?$CFs?5period?5?$CFd@ ; `string'
PUBLIC	_wrap_check
EXTRN	_sym_compose:DWORD
;	COMDAT ??_C@_0CH@JFAIPCJF@Wraps?5around?5facet?5?$CFs?5not?5consis@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CH@JFAIPCJF@Wraps?5around?5facet?5?$CFs?5not?5consis@ DB 'Wraps ar'
	DB	'ound facet %s not consistent.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JHIFPKDJ@Facet?5?$CFs?5has?5unclosed?5edge?5loop?4@
CONST	SEGMENT
??_C@_0CC@JHIFPKDJ@Facet?5?$CFs?5has?5unclosed?5edge?5loop?4@ DB 'Facet %'
	DB	's has unclosed edge loop.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PAEAJMKC@Big?5wrap?5?$CFd?5on?5edge?5?$CFs?5period?5?$CFd@
CONST	SEGMENT
??_C@_0CC@PAEAJMKC@Big?5wrap?5?$CFd?5on?5edge?5?$CFs?5period?5?$CFd@ DB 'B'
	DB	'ig wrap %d on edge %s period %d', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\check.c
CONST	ENDS
;	COMDAT _wrap_check
_TEXT	SEGMENT
_start_fe$90013 = -24					; size = 4
_count$ = -20						; size = 4
tv549 = -16						; size = 4
tv514 = -16						; size = 4
_wrap$90014 = -12					; size = 4
tv551 = -8						; size = 4
_wrap$89987 = -8					; size = 4
_numerr$ = -4						; size = 4
_wrap_check PROC					; COMDAT

; 1196 : { edge_id e_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1197 :   facet_id f_id;
; 1198 :   int numerr = 0;
; 1199 :   int count = 0;
; 1200 :   int i;
; 1201 : 
; 1202 :   if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _numerr$[ebp], 0
	je	$LN77@wrap_check

; 1203 :   { FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+160
	mov	eax, ecx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv514[ebp], eax
	je	$LN77@wrap_check
	npad	12
$LL81@wrap_check:
	mov	eax, DWORD PTR _web+124
	mov	ebx, ecx
	and	ebx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN26@wrap_check

; 1204 :     { WRAPTYPE wrap = get_edge_wrap(e_id);

	mov	eax, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+esi+784]
	mov	edx, DWORD PTR [edx+eax]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN41@wrap_check
	push	edx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	mov	DWORD PTR _wrap$89987[ebp], eax
	jmp	SHORT $LN42@wrap_check
$LN41@wrap_check:
	mov	DWORD PTR _wrap$89987[ebp], edx
$LN42@wrap_check:

; 1205 :       for ( i = 0 ; i < SDIM ; i++, wrap >>= TWRAPBITS )

	xor	edi, edi
	cmp	DWORD PTR _web+616, edi
	jle	SHORT $LN26@wrap_check
	npad	7
$LL22@wrap_check:

; 1206 :         switch ( wrap & WRAPMASK  )

	mov	esi, DWORD PTR _wrap$89987[ebp]
	and	esi, 31					; 0000001fH
	mov	eax, esi
	sub	eax, 0
	je	SHORT $LN21@wrap_check
	dec	eax
	je	SHORT $LN21@wrap_check
	sub	eax, 30					; 0000001eH
	je	SHORT $LN21@wrap_check

; 1207 :         {
; 1208 :             case  NEGWRAP :  break;
; 1209 :             case  0       :  break;
; 1210 :             case  POSWRAP :  break;
; 1211 :             default : 
; 1212 :                 sprintf(errmsg,"Big wrap %d on edge %s period %d\n",
; 1213 :                     (int)WRAPNUM(wrap&WRAPMASK),ELNAME(e_id),i+1);

	cmp	DWORD PTR tv514[ebp], 0
	je	SHORT $LN31@wrap_check
	lea	ecx, DWORD PTR [ebx+1]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN32@wrap_check
$LN31@wrap_check:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN32@wrap_check:
	cmp	esi, 16					; 00000010H
	jle	SHORT $LN33@wrap_check
	add	esi, -32				; ffffffe0H
$LN33@wrap_check:
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	eax
	push	esi
	push	OFFSET ??_C@_0CC@PAEAJMKC@Big?5wrap?5?$CFd?5on?5edge?5?$CFs?5period?5?$CFd@
	push	OFFSET _errmsg
	call	_sprintf

; 1214 :                 erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 24					; 00000018H

; 1215 :                 numerr++;

	inc	DWORD PTR _numerr$[ebp]
$LN21@wrap_check:

; 1205 :       for ( i = 0 ; i < SDIM ; i++, wrap >>= TWRAPBITS )

	sar	DWORD PTR _wrap$89987[ebp], 6
	inc	edi
	cmp	edi, DWORD PTR _web+616
	jl	SHORT $LL22@wrap_check
$LN26@wrap_check:

; 1203 :   { FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, ecx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv514[ebp], eax
	jne	$LL81@wrap_check
$LN77@wrap_check:

; 1216 :               break;
; 1217 :         }
; 1218 :     }
; 1219 :   }
; 1220 : 
; 1221 :   FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+272
	mov	ebx, ecx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	mov	DWORD PTR tv549[ebp], ebx
	je	$LN72@wrap_check
	npad	7
$LL78@wrap_check:
	mov	edx, DWORD PTR _web+236
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	mov	DWORD PTR tv551[ebp], esi
	je	$LN12@wrap_check

; 1222 :   {
; 1223 :      facetedge_id fe,start_fe;
; 1224 :      int wrap = 0;

	xor	eax, eax
	mov	DWORD PTR _wrap$90014[ebp], eax

; 1225 :      fe = start_fe = get_facet_fe(f_id);

	cmp	ebx, eax
	jne	SHORT $LN44@wrap_check
	mov	DWORD PTR _start_fe$90013[ebp], edi
	jmp	SHORT $LN45@wrap_check
$LN44@wrap_check:
	mov	edx, DWORD PTR [edx+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN43@wrap_check
	xor	edx, 134217728				; 08000000H
$LN43@wrap_check:
	mov	edi, edx
	mov	DWORD PTR _start_fe$90013[ebp], edx
$LN45@wrap_check:

; 1226 :      count = 0;

	mov	DWORD PTR _count$[ebp], eax

; 1227 :      if ( valid_id(fe) )

	test	edi, 268435456				; 10000000H
	je	$LN12@wrap_check
	npad	9
$LL7@wrap_check:

; 1228 :      do
; 1229 :      { if ( get_vattr(get_fe_tailv(fe)) & AXIAL_POINT )

	mov	eax, DWORD PTR _web+460
	mov	ebx, DWORD PTR _dymem
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	edx, edi
	and	edx, 134217728				; 08000000H
	xor	ecx, edx
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN50@wrap_check
	add	eax, DWORD PTR [edx+ebx+304]
	mov	edx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN49@wrap_check
$LN50@wrap_check:
	mov	edx, DWORD PTR [edx+ebx+304]
	mov	eax, DWORD PTR [eax+edx]
$LN49@wrap_check:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	edx, edx
	or	eax, edx
	jne	$LN67@wrap_check

; 1231 :        wrap = (*sym_compose)(wrap,get_fe_wrap(fe));

	mov	edx, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ebx+784]
	mov	eax, DWORD PTR [eax+edx]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN57@wrap_check
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN57@wrap_check:
	push	eax
	mov	eax, DWORD PTR _wrap$90014[ebp]
	push	eax
	call	DWORD PTR _sym_compose
	add	esp, 8
	mov	DWORD PTR _wrap$90014[ebp], eax

; 1232 :        fe = get_next_edge(fe);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN60@wrap_check
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [esi+ecx]
	mov	edi, DWORD PTR [edx+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN59@wrap_check
$LN60@wrap_check:
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [ecx+32]
$LN59@wrap_check:

; 1233 :        count++;

	mov	eax, DWORD PTR _count$[ebp]

; 1234 :        if ( count > 2*web.skel[EDGE].count ) 

	mov	edx, DWORD PTR _web+176
	inc	eax
	lea	ecx, DWORD PTR [edx+edx]
	mov	DWORD PTR _count$[ebp], eax
	cmp	eax, ecx
	jg	SHORT $LN68@wrap_check

; 1238 :          break;
; 1239 :        }
; 1240 :      } while ( valid_id(fe) && !equal_id(fe,start_fe) );

	test	edi, 268435456				; 10000000H
	je	SHORT $LN74@wrap_check
	cmp	edi, DWORD PTR _start_fe$90013[ebp]
	jne	$LL7@wrap_check
$LN74@wrap_check:

; 1237 :          numerr++;

	mov	esi, DWORD PTR tv551[ebp]
	mov	ebx, DWORD PTR tv549[ebp]
$LN5@wrap_check:

; 1241 :      if ( valid_id(fe) && (wrap != 0) )

	test	edi, 268435456				; 10000000H
	je	$LN12@wrap_check
	cmp	DWORD PTR _wrap$90014[ebp], 0
	je	$LN12@wrap_check

; 1242 :        { sprintf(errmsg,"Wraps around facet %s not consistent.\n",ELNAME(f_id));

	test	ebx, ebx
	je	SHORT $LN37@wrap_check
	lea	eax, DWORD PTR [esi+1]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN38@wrap_check
$LN67@wrap_check:

; 1230 :        { wrap = 0; break; }

	mov	DWORD PTR _wrap$90014[ebp], edx
	jmp	SHORT $LN74@wrap_check
$LN68@wrap_check:

; 1235 :        { sprintf(errmsg,"Facet %s has unclosed edge loop.\n",ELNAME(f_id));

	mov	ebx, DWORD PTR tv549[ebp]
	mov	esi, DWORD PTR tv551[ebp]
	test	ebx, ebx
	je	SHORT $LN35@wrap_check
	lea	edx, DWORD PTR [esi+1]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN36@wrap_check
$LN35@wrap_check:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN36@wrap_check:
	push	eax
	push	OFFSET ??_C@_0CC@JHIFPKDJ@Facet?5?$CFs?5has?5unclosed?5edge?5loop?4@
	push	OFFSET _errmsg
	call	_sprintf

; 1236 :          erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 16					; 00000010H

; 1237 :          numerr++;

	inc	DWORD PTR _numerr$[ebp]
	jmp	$LN5@wrap_check
$LN37@wrap_check:

; 1242 :        { sprintf(errmsg,"Wraps around facet %s not consistent.\n",ELNAME(f_id));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN38@wrap_check:
	push	eax
	push	OFFSET ??_C@_0CH@JFAIPCJF@Wraps?5around?5facet?5?$CFs?5not?5consis@
	push	OFFSET _errmsg
	call	_sprintf

; 1243 :          kb_error(2000,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2000					; 000007d0H
	call	_kb_error
	add	esp, 24					; 00000018H

; 1244 :          numerr++;

	inc	DWORD PTR _numerr$[ebp]
$LN12@wrap_check:

; 1216 :               break;
; 1217 :         }
; 1218 :     }
; 1219 :   }
; 1220 : 
; 1221 :   FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR [edx]
	mov	ebx, ecx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	mov	DWORD PTR tv549[ebp], ebx
	jne	$LL78@wrap_check
$LN72@wrap_check:

; 1245 :        }
; 1246 :   }
; 1247 :   return numerr;

	mov	eax, DWORD PTR _numerr$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 1248 : } /* end wrap_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
_wrap_check ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@JCEGNCJI@?$DL?5facet?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0N@ONNJPEDG@?5has?5no?5body?$AA@		; `string'
PUBLIC	??_C@_0N@HBEPEIIG@?5has?5body?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0P@KCOBLGNP@?6?5?5?5?5?5facet?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BL@IKHILHNP@?5?5?5?5?5?5?$CIoriginally?5edge?5?$CFs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CL@GLJMCDBK@Inconsistent?5bodies?5for?5facets?5o@ ; `string'
PUBLIC	??_C@_0DE@IKCHHBKK@Body?5?$CFs?5has?5link?5to?5facet?5?$CFs?0?5wh@ ; `string'
PUBLIC	??_C@_0CN@EDEDPPBB@Body?5?$CFs?5has?5invalid?5facet?5link?5t@ ; `string'
PUBLIC	_facet_body_check
EXTRN	_oid:PROC
;	COMDAT ??_C@_0L@JCEGNCJI@?$DL?5facet?5?$CFd?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0L@JCEGNCJI@?$DL?5facet?5?$CFd?$AA@ DB '; facet %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ONNJPEDG@?5has?5no?5body?$AA@
CONST	SEGMENT
??_C@_0N@ONNJPEDG@?5has?5no?5body?$AA@ DB ' has no body', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HBEPEIIG@?5has?5body?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0N@HBEPEIIG@?5has?5body?5?$CFs?$AA@ DB ' has body %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KCOBLGNP@?6?5?5?5?5?5facet?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0P@KCOBLGNP@?6?5?5?5?5?5facet?5?$CFd?$AA@ DB 0aH, '     facet %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IKHILHNP@?5?5?5?5?5?5?$CIoriginally?5edge?5?$CFs?$CJ?$AA@
CONST	SEGMENT
??_C@_0BL@IKHILHNP@?5?5?5?5?5?5?$CIoriginally?5edge?5?$CFs?$CJ?$AA@ DB ' '
	DB	'     (originally edge %s)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GLJMCDBK@Inconsistent?5bodies?5for?5facets?5o@
CONST	SEGMENT
??_C@_0CL@GLJMCDBK@Inconsistent?5bodies?5for?5facets?5o@ DB 'Inconsistent'
	DB	' bodies for facets on edge %s.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IKCHHBKK@Body?5?$CFs?5has?5link?5to?5facet?5?$CFs?0?5wh@
CONST	SEGMENT
??_C@_0DE@IKCHHBKK@Body?5?$CFs?5has?5link?5to?5facet?5?$CFs?0?5wh@ DB 'Bo'
	DB	'dy %s has link to facet %s, which is on body %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EDEDPPBB@Body?5?$CFs?5has?5invalid?5facet?5link?5t@
CONST	SEGMENT
??_C@_0CN@EDEDPPBB@Body?5?$CFs?5has?5invalid?5facet?5link?5t@ DB 'Body %s'
	DB	' has invalid facet link to facet %s.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\check.c
CONST	ENDS
;	COMDAT _facet_body_check
_TEXT	SEGMENT
tv1148 = -36						; size = 4
tv1025 = -32						; size = 4
_fe$ = -28						; size = 4
tv976 = -24						; size = 4
_ff_id$89666 = -20					; size = 4
_f_id$ = -16						; size = 4
tv1027 = -12						; size = 4
_bb_id$89665 = -12					; size = 4
_b_id$ = -8						; size = 4
_numerr$ = -4						; size = 4
_facet_body_check PROC					; COMDAT

; 798  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx

; 799  :   facetedge_id fe;
; 800  :   facet_id f_id;
; 801  :   body_id b_id;
; 802  :   int numerr = 0;
; 803  :   element_id orig;
; 804  :       
; 805  : 
; 806  :   FOR_ALL_BODIES(b_id)

	mov	ebx, DWORD PTR _web+384
	push	esi
	push	edi
	mov	edi, ebx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	mov	DWORD PTR _numerr$[ebp], 0
	je	$LN26@facet_body
	npad	12
$LL28@facet_body:
	mov	ecx, DWORD PTR _web+348
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv1027[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN27@facet_body

; 807  :   { f_id = get_body_facet(b_id);

	test	edi, edi
	je	SHORT $LN65@facet_body
	mov	esi, DWORD PTR [ecx+400]
	jmp	SHORT $LN66@facet_body
$LN65@facet_body:
	xor	esi, esi
$LN66@facet_body:

; 808  :     if ( !valid_id(f_id) ) continue;

	test	esi, 268435456				; 10000000H
	je	$LN27@facet_body

; 809  :     if ( !valid_element(f_id) )

	push	esi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN22@facet_body

; 810  :     { sprintf(msg,"Body %s has invalid facet link to facet %s.\n",
; 811  :        ELNAME(b_id),ELNAME1(f_id));

	and	esi, 134217727				; 07ffffffH
	mov	ebx, 1
	add	esi, ebx
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	test	edi, edi
	je	SHORT $LN33@facet_body
	mov	edx, DWORD PTR tv1027[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN34@facet_body
$LN33@facet_body:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN34@facet_body:
	push	OFFSET _elnames+30
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0CN@EDEDPPBB@Body?5?$CFs?5has?5invalid?5facet?5link?5t@
	push	eax
	call	_sprintf

; 812  :       erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 813  :       numerr++;

	add	DWORD PTR _numerr$[ebp], ebx
	add	esp, 20					; 00000014H

; 814  :       bad_errors_count++;

	add	DWORD PTR _bad_errors_count, ebx

; 815  :       continue;

	jmp	$LN27@facet_body
$LN22@facet_body:

; 816  :      }
; 817  :      if ( !equal_id(b_id,get_facet_body(f_id) ) )

	push	esi
	call	_get_facet_body
	add	esp, 4
	cmp	ebx, eax
	je	$LN27@facet_body

; 818  :      { sprintf(msg,"Body %s has link to facet %s, which is on body %s.\n",
; 819  :          ELNAME(b_id),SELNAME1(f_id),ELNAME2(get_facet_body(f_id)));

	push	esi
	call	_get_facet_body
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN35@facet_body
	push	esi
	call	_get_facet_body
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 16					; 00000010H
	mov	ebx, OFFSET _elnames+60
	jmp	SHORT $LN36@facet_body
$LN35@facet_body:
	mov	ebx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN36@facet_body:
	mov	eax, OFFSET ??_C@_01JOAMLHOP@?9?$AA@
	test	esi, 134217728				; 08000000H
	jne	SHORT $LN38@facet_body
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN38@facet_body:
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	eax
	push	OFFSET ??_C@_04HGGBINEM@?$CFs?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 16					; 00000010H
	test	edi, edi
	je	SHORT $LN41@facet_body
	mov	edx, DWORD PTR tv1027[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN42@facet_body
$LN41@facet_body:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN42@facet_body:
	push	ebx
	push	OFFSET _elnames+30
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0DE@IKCHHBKK@Body?5?$CFs?5has?5link?5to?5facet?5?$CFs?0?5wh@
	push	eax
	call	_sprintf

; 820  :        erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 821  :        numerr++;

	mov	eax, 1
	add	DWORD PTR _numerr$[ebp], eax
	add	esp, 24					; 00000018H

; 822  :        bad_errors_count++;

	add	DWORD PTR _bad_errors_count, eax
$LN27@facet_body:

; 799  :   facetedge_id fe;
; 800  :   facet_id f_id;
; 801  :   body_id b_id;
; 802  :   int numerr = 0;
; 803  :   element_id orig;
; 804  :       
; 805  : 
; 806  :   FOR_ALL_BODIES(b_id)

	mov	edx, DWORD PTR tv1027[ebp]
	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	ebx, DWORD PTR [ecx]
	mov	edi, ebx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	$LL28@facet_body
$LN26@facet_body:

; 823  :      }
; 824  :   }
; 825  : 
; 826  :   if ( web.representation != SOAPFILM ) return numerr;

	cmp	DWORD PTR _web+624, 2
	je	SHORT $LN20@facet_body
	mov	eax, DWORD PTR _numerr$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 897  :   return numerr;
; 898  : } /* end facet_body_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@facet_body:

; 827  : 
; 828  :   FOR_ALL_FACETEDGES(fe)

	mov	edi, DWORD PTR _web+496
	test	edi, 268435456				; 10000000H
	je	$LN17@facet_body
	mov	edx, DWORD PTR _dymem
	npad	2
$LL110@facet_body:
	mov	ecx, DWORD PTR _web+460
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN18@facet_body

; 829  :   { body_id bb_id;
; 830  :     facet_id ff_id;
; 831  :     edge_id e_id;
; 832  :     int k;
; 833  : 
; 834  :     for ( k = 0 ; k < 2 ; k++ )

	mov	DWORD PTR tv976[ebp], 2
	npad	9
$LL14@facet_body:

; 835  :     { fe = inverse_id(fe);

	xor	edi, 134217728				; 08000000H
	mov	DWORD PTR _fe$[ebp], edi

; 836  :      
; 837  :       f_id = get_fe_facet(fe);

	test	edi, 268435456				; 10000000H
	jne	SHORT $LN68@facet_body
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN67@facet_body
$LN68@facet_body:
	mov	ecx, DWORD PTR _web+460
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN67@facet_body
	xor	eax, 134217728				; 08000000H
$LN67@facet_body:

; 838  :       b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	mov	DWORD PTR _f_id$[ebp], eax
	jne	SHORT $LN74@facet_body
	xor	ebx, ebx
	jmp	SHORT $LN115@facet_body
$LN74@facet_body:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN73@facet_body
	xor	ebx, ebx
	jmp	SHORT $LN115@facet_body
$LN73@facet_body:
	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN72@facet_body
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	ebx, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN115@facet_body
$LN72@facet_body:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	ebx, DWORD PTR [eax+ecx]
$LN115@facet_body:

; 839  :       if ( equal_id(fe,get_prev_facet(fe)) ) continue;

	mov	esi, DWORD PTR _web+460
	mov	ecx, edi
	mov	eax, edi
	shr	ecx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	and	ecx, 1
	mov	esi, DWORD PTR [esi+eax*4]
	mov	DWORD PTR _b_id$[ebp], ebx
	je	SHORT $LN78@facet_body
	mov	eax, DWORD PTR [esi+40]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN77@facet_body
$LN78@facet_body:
	mov	eax, DWORD PTR [esi+36]
$LN77@facet_body:
	cmp	edi, eax
	je	$LN13@facet_body

; 840  :       ff_id = get_fe_facet(fe_inverse(get_prev_facet(fe)));

	test	ecx, ecx
	je	SHORT $LN82@facet_body
	mov	eax, DWORD PTR [esi+40]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN81@facet_body
$LN82@facet_body:
	mov	eax, DWORD PTR [esi+36]
$LN81@facet_body:
	xor	eax, 134217728				; 08000000H
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN86@facet_body
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN116@facet_body
$LN86@facet_body:
	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN85@facet_body
	xor	ecx, 134217728				; 08000000H
$LN85@facet_body:
	mov	edx, DWORD PTR _dymem
	mov	eax, ecx
$LN116@facet_body:

; 841  :       bb_id = get_facet_body(ff_id);

	cmp	DWORD PTR _web+400, 0
	mov	DWORD PTR _ff_id$89666[ebp], eax
	jne	SHORT $LN92@facet_body
	xor	ecx, ecx
	jmp	SHORT $LN117@facet_body
$LN92@facet_body:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN91@facet_body
	xor	ecx, ecx
	jmp	SHORT $LN117@facet_body
$LN91@facet_body:
	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN90@facet_body
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	ecx, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN117@facet_body
$LN90@facet_body:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	ecx, DWORD PTR [eax+ecx]
$LN117@facet_body:

; 842  :       e_id = get_fe_edge(fe);

	and	edi, 134217728				; 08000000H
	xor	edi, DWORD PTR [esi+20]

; 843  :       if ( /* !equal_id(b_id,bb_id)  */
; 844  :            (ordinal(b_id) != ordinal(bb_id))  /* for MPI, temp kludge */
; 845  :              && !(get_attr(e_id)&(CONSTRAINT|FIXED|BOUNDARY)) )

	mov	eax, ebx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _bb_id$89665[ebp], ecx
	mov	DWORD PTR tv1025[ebp], eax
	je	SHORT $LN43@facet_body
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	jmp	SHORT $LN44@facet_body
$LN43@facet_body:
	or	esi, -1
$LN44@facet_body:
	mov	eax, ecx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv1148[ebp], eax
	je	SHORT $LN45@facet_body
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN46@facet_body
$LN45@facet_body:
	or	ecx, -1
$LN46@facet_body:
	cmp	esi, ecx
	je	$LN13@facet_body
	mov	eax, edi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	lea	ebx, DWORD PTR _web[eax+12]
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1216				; 000004c0H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN13@facet_body

; 846  :       { sprintf(errmsg,"Inconsistent bodies for facets on edge %s.",
; 847  :               ELNAME(e_id) );

	test	edi, 268435456				; 10000000H
	je	SHORT $LN47@facet_body
	lea	edx, DWORD PTR [esi+1]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN48@facet_body
$LN47@facet_body:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN48@facet_body:
	push	eax
	push	OFFSET ??_C@_0CL@GLJMCDBK@Inconsistent?5bodies?5for?5facets?5o@
	push	OFFSET _errmsg
	call	_sprintf

; 848  :         //erroutstring(errmsg);
; 849  :         kb_error(8745,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	8745					; 00002229H
	call	_kb_error

; 850  :         numerr++;

	mov	eax, 1

; 851  :         inconsistent_bodies_count++;

	add	DWORD PTR _inconsistent_bodies_count, eax
	add	DWORD PTR _numerr$[ebp], eax

; 852  :         orig = get_original(e_id);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ecx+20]
	add	esp, 24					; 00000018H

; 853  :         if ( valid_id(orig) && !equal_element(orig,e_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN105@facet_body
	mov	edx, eax
	or	edx, 134217728				; 08000000H
	or	edi, 134217728				; 08000000H
	cmp	edx, edi
	je	SHORT $LN105@facet_body

; 854  :         { sprintf(msg,"      (originally edge %s)",ELNAME(orig));

	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0BL@IKHILHNP@?5?5?5?5?5?5?$CIoriginally?5edge?5?$CFs?$CJ?$AA@
	push	eax
	call	_sprintf

; 855  :           erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring
	add	esp, 28					; 0000001cH
$LN105@facet_body:

; 856  :         }
; 857  :         sprintf(msg,"\n     facet %d",oid(f_id));

	mov	esi, DWORD PTR _f_id$[ebp]
	push	esi
	call	_oid
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0P@KCOBLGNP@?6?5?5?5?5?5facet?5?$CFd?$AA@
	push	edx
	call	_sprintf

; 858  :         erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring

; 859  :         orig = get_original(f_id);

	mov	ecx, esi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx+20]
	add	esp, 20					; 00000014H

; 860  :         if ( valid_id(orig) && !equal_element(orig,f_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN111@facet_body
	mov	edx, eax
	or	edx, 134217728				; 08000000H
	or	esi, 134217728				; 08000000H
	cmp	edx, esi
	je	SHORT $LN111@facet_body

; 861  :         { sprintf(msg," (orig. %s)",ELNAME(orig)); erroutstring(msg); }

	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0M@KGDCKMAD@?5?$CIorig?4?5?$CFs?$CJ?$AA@
	push	eax
	call	_sprintf
	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring
	add	esp, 28					; 0000001cH
$LN111@facet_body:

; 862  :         if ( valid_id(b_id) )

	cmp	DWORD PTR tv1025[ebp], 0
	je	$LN7@facet_body

; 863  :         {
; 864  :           sprintf(msg," has body %s",ELNAME(b_id));

	mov	edi, DWORD PTR _b_id$[ebp]
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	lea	edx, DWORD PTR [esi+1]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0N@HBEPEIIG@?5has?5body?5?$CFs?$AA@
	push	eax
	call	_sprintf

; 865  :             erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 866  :           orig = get_original(b_id);

	mov	edx, edi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ecx+20]
	add	esp, 28					; 0000001cH

; 867  :           if ( valid_id(orig) && !equal_element(orig,b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN113@facet_body
	mov	edx, eax
	or	edx, 134217728				; 08000000H
	or	edi, 134217728				; 08000000H
	cmp	edx, edi
	je	SHORT $LN113@facet_body

; 868  :              { sprintf(msg," (orig. %s)",ELNAME(orig));

	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0M@KGDCKMAD@?5?$CIorig?4?5?$CFs?$CJ?$AA@
	push	eax
	call	_sprintf

; 869  :                erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring
	add	esp, 28					; 0000001cH

; 870  :              }

	jmp	SHORT $LN113@facet_body
$LN7@facet_body:

; 871  :         }
; 872  :         else erroutstring(" has no body");

	push	OFFSET ??_C@_0N@ONNJPEDG@?5has?5no?5body?$AA@
	call	_erroutstring
	add	esp, 4
$LN113@facet_body:

; 873  :         sprintf(msg,"; facet %d",oid(ff_id));

	mov	esi, DWORD PTR _ff_id$89666[ebp]
	push	esi
	call	_oid
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0L@JCEGNCJI@?$DL?5facet?5?$CFd?$AA@
	push	edx
	call	_sprintf

; 874  :         erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring

; 875  :         orig = get_original(ff_id);

	mov	ecx, esi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx+20]
	add	esp, 20					; 00000014H

; 876  :         if ( valid_id(orig) && !equal_element(orig,ff_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN114@facet_body
	mov	edx, eax
	or	edx, 134217728				; 08000000H
	or	esi, 134217728				; 08000000H
	cmp	edx, esi
	je	SHORT $LN114@facet_body

; 877  :         { sprintf(msg," (orig. %s)",ELNAME(orig));

	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0M@KGDCKMAD@?5?$CIorig?4?5?$CFs?$CJ?$AA@
	push	eax
	call	_sprintf

; 878  :           erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring
	add	esp, 28					; 0000001cH
$LN114@facet_body:

; 879  :         }
; 880  :         if ( valid_id(bb_id) )

	cmp	DWORD PTR tv1148[ebp], 0
	je	$LN3@facet_body

; 881  :         {
; 882  :           sprintf(msg," has body %s",ELNAME(bb_id));

	mov	edi, DWORD PTR _bb_id$89665[ebp]
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	lea	edx, DWORD PTR [esi+1]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0N@HBEPEIIG@?5has?5body?5?$CFs?$AA@
	push	eax
	call	_sprintf

; 883  :           erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 884  :           orig = get_original(bb_id);

	mov	edx, edi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ecx+20]
	add	esp, 28					; 0000001cH

; 885  :           if ( valid_id(orig) && !equal_element(orig,bb_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@facet_body
	mov	edx, eax
	or	edx, 134217728				; 08000000H
	or	edi, 134217728				; 08000000H
	cmp	edx, edi
	je	SHORT $LN1@facet_body

; 886  :              { sprintf(msg," (orig. %s)",ELNAME(orig));

	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0M@KGDCKMAD@?5?$CIorig?4?5?$CFs?$CJ?$AA@
	push	eax
	call	_sprintf

; 887  :                erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring
	add	esp, 28					; 0000001cH

; 888  :              }

	jmp	SHORT $LN1@facet_body
$LN3@facet_body:

; 889  :         }
; 890  :         else erroutstring(" has no body");

	push	OFFSET ??_C@_0N@ONNJPEDG@?5has?5no?5body?$AA@
	call	_erroutstring
	add	esp, 4
$LN1@facet_body:

; 891  :         erroutstring(".\n");

	push	OFFSET ??_C@_02MIICKFIN@?4?6?$AA@
	call	_erroutstring
	mov	edx, DWORD PTR _dymem
	add	esp, 4
$LN13@facet_body:

; 829  :   { body_id bb_id;
; 830  :     facet_id ff_id;
; 831  :     edge_id e_id;
; 832  :     int k;
; 833  : 
; 834  :     for ( k = 0 ; k < 2 ; k++ )

	dec	DWORD PTR tv976[ebp]
	mov	edi, DWORD PTR _fe$[ebp]
	jne	$LL14@facet_body
$LN18@facet_body:

; 827  : 
; 828  :   FOR_ALL_FACETEDGES(fe)

	mov	eax, DWORD PTR _web+460
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR [ecx]
	test	edi, 268435456				; 10000000H
	jne	$LL110@facet_body
$LN17@facet_body:

; 892  :         /* just a warning, not an error */
; 893  :       }
; 894  :     }
; 895  :    } /* end FACETEDGES */
; 896  :   numerr += check_body_facets();

	call	_check_body_facets
	add	eax, DWORD PTR _numerr$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 897  :   return numerr;
; 898  : } /* end facet_body_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
_facet_body_check ENDP
_TEXT	ENDS
PUBLIC	_run_checks
EXTRN	_check_count:DWORD
EXTRN	_memory_report:PROC
EXTRN	_memdebug:DWORD
; Function compile flags: /Ogtp
;	COMDAT _run_checks
_TEXT	SEGMENT
_run_checks PROC					; COMDAT

; 37   : {

	push	esi
	push	edi

; 38   :   int numerr = 0;
; 39   : 
; 40   :   bad_next_prev_count = 0;

	xor	edi, edi
	mov	DWORD PTR _bad_next_prev_count, edi

; 41   :   inconsistent_bodies_count = 0;

	mov	DWORD PTR _inconsistent_bodies_count, edi

; 42   :   edge_loop_count = 0;

	mov	DWORD PTR _edge_loop_count, edi

; 43   :   edges_same_vertices_count = 0;

	mov	DWORD PTR _edges_same_vertices_count, edi

; 44   :   facets_same_vertices_count = 0;

	mov	DWORD PTR _facets_same_vertices_count, edi

; 45   :   bad_errors_count = 0; 

	mov	DWORD PTR _bad_errors_count, edi

; 46   : 
; 47   :   if ( memdebug ) memory_report();

	cmp	DWORD PTR _memdebug, edi
	je	SHORT $LN4@run_checks
	call	_memory_report
$LN4@run_checks:

; 48   :   numerr += list_check();

	call	_list_check

; 49   :   if ( web.representation != SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	mov	esi, eax
	je	SHORT $LN3@run_checks

; 50   :     { numerr += facetedge_check(REGCHECK);

	push	2
	call	_facetedge_check
	add	esp, 4
	add	esi, eax

; 51   :       if ( web.skel[BODY].count > 0 )

	cmp	DWORD PTR _web+400, edi
	jle	SHORT $LN2@run_checks

; 52   :         numerr += facet_body_check();

	call	_facet_body_check
	add	esi, eax
$LN2@run_checks:

; 53   :       numerr += collapse_check();

	call	_collapse_check
	add	esi, eax

; 54   :       numerr += vertex_facet_check();

	call	_vertex_facet_check
	add	esi, eax
$LN3@run_checks:

; 55   :     }
; 56   :   numerr += method_check();

	call	_method_check
	add	esi, eax

; 57   :   if ( web.symmetry_flag ) numerr += wrap_check(); 

	cmp	DWORD PTR _web+856, edi
	je	SHORT $LN1@run_checks
	call	_wrap_check
	add	esi, eax
$LN1@run_checks:

; 58   : 
; 59   :   #ifdef MPI_EVOLVER
; 60   :   numerr += mpi_task_checks();
; 61   :   #endif
; 62   : 
; 63   :   check_count = numerr;
; 64   :   bad_errors_count += bad_next_prev_count;

	mov	eax, DWORD PTR _bad_next_prev_count
	add	DWORD PTR _bad_errors_count, eax
	pop	edi
	mov	DWORD PTR _check_count, esi

; 65   : 
; 66   :   return numerr;

	mov	eax, esi
	pop	esi

; 67   : } /* end run_checks() */

	ret	0
_run_checks ENDP
_TEXT	ENDS
END
