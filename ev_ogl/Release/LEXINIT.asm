; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\LEXINIT.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_vlist
PUBLIC	_elist
PUBLIC	_flist
PUBLIC	_blist
_DATA	SEGMENT
COMM	_facecount:DWORD
COMM	_vmaxlist:DWORD
COMM	_emaxlist:DWORD
COMM	_fmaxlist:DWORD
COMM	_bmaxlist:DWORD
_DATA	ENDS
_BSS	SEGMENT
_vlist	DD	01H DUP (?)
_elist	DD	01H DUP (?)
_flist	DD	01H DUP (?)
_blist	DD	01H DUP (?)
_BSS	ENDS
PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_unset_attr
; Function compile flags: /Ogtp
;	COMDAT _unset_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_unset_attr PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 29   :   elptr(id)->attr &= ~attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	not	ecx
	and	DWORD PTR [eax+8], ecx
	not	edx
	and	DWORD PTR [eax+12], edx

; 30   : }

	pop	ebp
	ret	0
_unset_attr ENDP
_TEXT	ENDS
PUBLIC	_get_fe_edge
; Function compile flags: /Ogtp
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_prev_edge
EXTRN	_top_timestamp:DWORD
EXTRN	_global_timestamp:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_edge PROC					; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp

; 103  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_e

; 104  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_e

; 105  :     { invert(fe);
; 106  :       feptr(fe_id)->nextedge[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+32], ecx

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 111  : }

	pop	ebp
	ret	0
$LN2@set_prev_e:

; 107  :     }
; 108  :   else
; 109  :       feptr(fe_id)->nextedge[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_e:

; 111  : }

	pop	ebp
	ret	0
_set_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_set_next_edge
; Function compile flags: /Ogtp
;	COMDAT _set_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_edge PROC					; COMDAT

; 116  : {

	push	ebp
	mov	ebp, esp

; 117  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_e

; 118  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_e

; 119  :     { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 120  :       feptr(fe_id)->nextedge[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+28], ecx

; 124  : }

	pop	ebp
	ret	0
$LN2@set_next_e:

; 121  :     }
; 122  :   else
; 123  :       feptr(fe_id)->nextedge[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN1@set_next_e:

; 124  : }

	pop	ebp
	ret	0
_set_next_edge ENDP
_TEXT	ENDS
PUBLIC	_set_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _set_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_facet PROC					; COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp

; 130  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_f

; 131  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_f

; 132  :   { invert(fe);
; 133  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+40], ecx

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 138  : }

	pop	ebp
	ret	0
$LN2@set_prev_f:

; 134  :   }
; 135  :   else
; 136  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+36], eax

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_f:

; 138  : }

	pop	ebp
	ret	0
_set_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_set_next_facet
; Function compile flags: /Ogtp
;	COMDAT _set_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_facet PROC					; COMDAT

; 143  : {

	push	ebp
	mov	ebp, esp

; 144  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_f

; 145  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_f

; 146  :   { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 147  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+36], ecx

; 151  : }

	pop	ebp
	ret	0
$LN2@set_next_f:

; 148  :   }
; 149  :   else
; 150  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+40], eax
$LN1@set_next_f:

; 151  : }

	pop	ebp
	ret	0
_set_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_edge_wrap
EXTRN	_dymem:DWORD
EXTRN	_sym_inverse:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_wrap$ = 12						; size = 4
_set_edge_wrap PROC					; COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp

; 158  :  *EINT(e_id,E_WRAP_ATTR) =  inverted(e_id)  ? (*sym_inverse)(wrap) : wrap ;

	mov	eax, DWORD PTR _wrap$[ebp]
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN4@set_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@set_edge_w:
	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+esi+784]
	mov	DWORD PTR [edx+ecx], eax
	pop	esi

; 159  : }

	pop	ebp
	ret	0
_set_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_set_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _set_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_edge_fe PROC					; COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp

; 172  :   if ( inverted(e_id) ) invert(fe);

	mov	eax, DWORD PTR _e_id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN1@set_edge_f
	xor	DWORD PTR _fe$[ebp], 134217728		; 08000000H
$LN1@set_edge_f:

; 173  :   eptr(e_id)->fe_id = fe;

	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 174  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 175  : }

	pop	ebp
	ret	0
_set_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_set_edge_tailv
EXTRN	_insert_vertex_edge:PROC
EXTRN	_remove_vertex_edge:PROC
; Function compile flags: /Ogtp
;	COMDAT _set_edge_tailv
_TEXT	SEGMENT
tv225 = -4						; size = 4
_e_id$ = 8						; size = 4
_v_id$ = 12						; size = 4
_set_edge_tailv PROC					; COMDAT

; 210  : { vertex_id oldv;

	push	ebp
	mov	ebp, esp
	push	ecx

; 211  : 
; 212  :   /* make sure edge not in loop of old vertex */
; 213  :   oldv = get_edge_tailv(e_id);

	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR _web+216
	push	ebx
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	mov	eax, esi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	push	edi
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR tv225[ebp], eax
	je	SHORT $LN7@set_edge_t
	mov	ebx, DWORD PTR _web+636
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	add	eax, DWORD PTR [ecx+edi+304]
	mov	eax, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN6@set_edge_t
$LN7@set_edge_t:
	mov	ebx, DWORD PTR [ecx+edi+304]
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+ebx]
$LN6@set_edge_t:

; 214  :   if ( valid_id(oldv) && !equal_id(oldv,v_id) )

	mov	ebx, DWORD PTR _v_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN10@set_edge_t
	cmp	eax, ebx
	je	SHORT $LN10@set_edge_t

; 215  :     remove_vertex_edge(oldv,e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	eax
	call	_remove_vertex_edge
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	add	esp, 8
$LN10@set_edge_t:

; 216  : 
; 217  :   if ( inverted(e_id) )

	cmp	DWORD PTR tv225[ebp], 0

; 218  :      get_edge_vertices(e_id)[web.headvnum] = v_id;

	mov	edx, DWORD PTR [esi+edx]
	je	SHORT $LN2@set_edge_t
	add	edx, DWORD PTR [ecx+edi+304]
	mov	eax, DWORD PTR _web+636
	mov	DWORD PTR [edx+eax*4], ebx

; 219  :   else

	jmp	SHORT $LN1@set_edge_t
$LN2@set_edge_t:

; 220  :      get_edge_vertices(e_id)[0] = v_id;

	mov	eax, DWORD PTR [ecx+edi+304]
	mov	DWORD PTR [edx+eax], ebx
$LN1@set_edge_t:

; 221  :   insert_vertex_edge(v_id,e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	ebx
	call	_insert_vertex_edge

; 222  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	esp, 8
	pop	edi
	inc	eax
	pop	esi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	ebx

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_set_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_set_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _set_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_v_id$ = 12						; size = 4
_set_edge_headv PROC					; COMDAT

; 229  : {

	push	ebp
	mov	ebp, esp

; 230  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]
	push	esi

; 231  :      get_edge_vertices(e_id)[0] = v_id;

	mov	esi, DWORD PTR _dymem
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_edge_h
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+216
	mov	esi, DWORD PTR [ecx+esi+304]
	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	DWORD PTR [edx+esi], ecx

; 232  :   else

	jmp	SHORT $LN1@set_edge_h
$LN2@set_edge_h:

; 233  :      get_edge_vertices(e_id)[web.headvnum] = v_id;

	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	add	edx, DWORD PTR [ecx+esi+304]
	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	esi, DWORD PTR _web+636
	mov	DWORD PTR [edx+esi*4], ecx
$LN1@set_edge_h:

; 234  :   insert_vertex_edge(v_id,inverse_id(e_id));

	xor	eax, 134217728				; 08000000H
	push	eax
	push	ecx
	call	_insert_vertex_edge

; 235  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	esp, 8
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	esi

; 236  : }

	pop	ebp
	ret	0
_set_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_set_edge_midv
; Function compile flags: /Ogtp
;	COMDAT _set_edge_midv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_v_id$ = 12						; size = 4
_set_edge_midv PROC					; COMDAT

; 241  : { get_edge_vertices(e_id)[2] = v_id;

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _e_id$[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+esi+304]
	mov	eax, DWORD PTR _v_id$[ebp]
	mov	DWORD PTR [ecx+esi+8], eax

; 242  :   set_vertex_edge(v_id,e_id);

	mov	esi, DWORD PTR _web+12
	mov	ecx, eax

; 243  :   set_attr(v_id,Q_MIDPOINT);

	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	esi, DWORD PTR [ecx+esi]
	mov	DWORD PTR [esi+28], edx
	mov	edx, DWORD PTR _web[eax+12]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 131072		; 00020000H
	mov	DWORD PTR [ecx+12], eax

; 244  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	esi

; 245  : }

	pop	ebp
	ret	0
_set_edge_midv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_set_body_density
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_body_density
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_density PROC					; COMDAT

; 323  :       {         ( valid_id(b_id) ?  bptr(b_id)->density = (v) : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@set_body_d
	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+344]
$LN3@set_body_d:
	pop	ebp
	ret	0
_set_body_density ENDP
_TEXT	ENDS
PUBLIC	_set_body_pressure
; Function compile flags: /Ogtp
;	COMDAT _set_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_pressure PROC					; COMDAT

; 326  :       {         ( valid_id(b_id) ?  bptr(b_id)->pressure = (v) : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@set_body_p
	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+312]
$LN3@set_body_p:
	pop	ebp
	ret	0
_set_body_pressure ENDP
_TEXT	ENDS
PUBLIC	_set_body_volconst
EXTRN	_gen_quant_list:DWORD
EXTRN	_everything_quantities_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_body_volconst
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_volconst PROC					; COMDAT

; 329  : { if ( !valid_id(b_id) ) return;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_body_v

; 330  :   bptr(b_id)->volconst = v;

	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	fst	QWORD PTR [edx+328]

; 331  :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN6@set_body_v

; 332  :   { struct gen_quant *q = GEN_QUANT(get_body_volquant(b_id));

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+404]

; 333  :     q->volconst = v;

	mov	ecx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	fstp	QWORD PTR [eax+ecx+208]

; 334  :   }
; 335  : }

	pop	ebp
	ret	0
$LN6@set_body_v:

; 333  :     q->volconst = v;

	fstp	ST(0)
$LN1@set_body_v:

; 334  :   }
; 335  : }

	pop	ebp
	ret	0
_set_body_volconst ENDP
_TEXT	ENDS
PUBLIC	_get_extra
; Function compile flags: /Ogtp
;	COMDAT _get_extra
_TEXT	SEGMENT
_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_extra PROC						; COMDAT

; 348  : { int type = id_type(id);

	push	ebp
	mov	ebp, esp

; 349  : 
; 350  :   return ( (char*)elptr(id) + EXTRAS(type)[n].offset);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	shr	eax, 29					; 0000001dH
	imul	esi, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, esi
	add	eax, DWORD PTR [edi+ecx+64]
	pop	edi
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_get_extra ENDP
_TEXT	ENDS
PUBLIC	__real@40f869f000000000
PUBLIC	__real@3d719799812dea11
PUBLIC	__real@3ff6666666666666
PUBLIC	__real@3fd0000000000000
PUBLIC	??_C@_04GOEDGNCF@area?$AA@			; `string'
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3eb0c6f7a0b5ed8d
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3f1a36e2eb1c432d
PUBLIC	__real@3fe4cccccccccccd
PUBLIC	__real@4000000000000000
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	__real@3f647ae147ae147b
PUBLIC	__real@3f589374bc6a7efa
PUBLIC	__real@3f60624dd2f1a9fc
PUBLIC	__real@4008000000000000
PUBLIC	??_C@_05MHOFLBOO@stdin?$AA@			; `string'
PUBLIC	??_C@_09JGPPFAML@LEXINIT?4C?$AA@		; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@41684bfe477e06cc
PUBLIC	_reset_web
EXTRN	_reset_counts:PROC
EXTRN	_warnings_suppressed_count:DWORD
EXTRN	_expand_attribute:PROC
EXTRN	_expand_global_hash:PROC
EXTRN	_gpolypartial:DWORD
EXTRN	_gpoly:DWORD
EXTRN	_gauss1polyd:DWORD
EXTRN	_gauss1poly:DWORD
EXTRN	_gauss1Dpt:DWORD
EXTRN	_gauss1Dwt:DWORD
EXTRN	_single_redefine:BYTE
EXTRN	_show_expr:BYTE
EXTRN	_show_expr_table:BYTE
EXTRN	_userfunc_init:PROC
EXTRN	_end_normal_motion:PROC
EXTRN	_end_geomview_object:PROC
EXTRN	_metric_convert_flag:DWORD
EXTRN	_phase_flag:DWORD
EXTRN	_v_procnum:DWORD
EXTRN	_el_list:BYTE
EXTRN	_conical_w:DWORD
EXTRN	_conical_x:DWORD
EXTRN	_vertex_normals:DWORD
EXTRN	_transform_colors_flag:DWORD
EXTRN	_transform_gen_swap:DWORD
EXTRN	_allocate_transform_colors:PROC
EXTRN	_transform_colors:DWORD
EXTRN	_view_transform_det:DWORD
EXTRN	_transform_expr:BYTE
EXTRN	_transforms_flag:DWORD
EXTRN	_set_view_transform_generators_global:PROC
EXTRN	_set_view_transforms_global:PROC
EXTRN	_transform_count:DWORD
EXTRN	_zoom_number:DWORD
EXTRN	_view_transforms_unique_point_flag:DWORD
EXTRN	_NULLVERTEX:DWORD
EXTRN	_view_transforms_unique_point:DWORD
EXTRN	_torus_display_period_expr:BYTE
EXTRN	_torus_period_expr:BYTE
EXTRN	_inverse_periods_global:DWORD
EXTRN	_torus_periods_global:DWORD
EXTRN	_localbase:DWORD
EXTRN	_no_refine:DWORD
EXTRN	_reflevel:DWORD
EXTRN	_set_by_user_gauss_2D:DWORD
EXTRN	_set_by_user_gauss_1D:DWORD
EXTRN	_bezier_flag:DWORD
EXTRN	_identity_compose:PROC
EXTRN	_sym_compose:DWORD
EXTRN	_identity_inverse:PROC
EXTRN	_identity_form_pullback:PROC
EXTRN	_sym_form_pullback:DWORD
EXTRN	_identity_wrap:PROC
EXTRN	_sym_wrap:DWORD
EXTRN	_symmetry_name:DWORD
EXTRN	_sym_flags:DWORD
EXTRN	_areaname:DWORD
EXTRN	_view_matrix_global:DWORD
EXTRN	_maxgaussorder:BYTE
EXTRN	_gauss_lagrange:BYTE
EXTRN	_dt_eps:QWORD
EXTRN	_homothety_target:QWORD
EXTRN	_total_time:QWORD
EXTRN	_runge_kutta_flag:DWORD
EXTRN	_pop_to_face_flag:DWORD
EXTRN	_pop_to_edge_flag:DWORD
EXTRN	_pop_enjoin_flag:DWORD
EXTRN	_pop_disjoin_flag:DWORD
EXTRN	_autopop_quartic_flag:DWORD
EXTRN	_immediate_autopop_flag:DWORD
EXTRN	_autopop_flag:DWORD
EXTRN	_autochop_flag:DWORD
EXTRN	_effective_area_flag:DWORD
EXTRN	_conf_edge_curv_flag:DWORD
EXTRN	_klein_metric_flag:DWORD
EXTRN	_kusner_flag:DWORD
EXTRN	_approx_curve_flag:DWORD
EXTRN	_normal_curvature_flag:DWORD
EXTRN	_boundary_curvature_flag:DWORD
EXTRN	_mean_curv_int_flag:DWORD
EXTRN	_square_curvature_flag:DWORD
EXTRN	_sqgauss_flag:DWORD
EXTRN	_area_fixed_flag:DWORD
EXTRN	_old_area_flag:DWORD
EXTRN	_method_instances_predicted:DWORD
EXTRN	_quantities_predicted:DWORD
EXTRN	_elements_predicted:BYTE
EXTRN	_star_fraction:QWORD
EXTRN	_mobility_formula:BYTE
EXTRN	_mobility_flag:DWORD
EXTRN	_mobility_tensor_flag:DWORD
EXTRN	_conj_grad_flag:DWORD
EXTRN	_K_altitude_flag:DWORD
EXTRN	_assume_oriented_flag:DWORD
EXTRN	_ribiere_flag:DWORD
EXTRN	_read_command_flag:DWORD
EXTRN	_post_project_flag:DWORD
EXTRN	_datafile_view_flag:DWORD
EXTRN	_make_pos_def_flag:DWORD
EXTRN	_self_similar_flag:DWORD
EXTRN	_pressure_set_flag:DWORD
EXTRN	_quiet_flag:DWORD
EXTRN	_quiet_go_flag:DWORD
EXTRN	_sobolev_flag:DWORD
EXTRN	_dirichlet_flag:DWORD
EXTRN	_mindeg_debug_level:DWORD
EXTRN	_hess_debug:DWORD
EXTRN	_hessian_by_diff_flag:DWORD
EXTRN	_hessian_quiet_flag:DWORD
EXTRN	_hessian_normal_one_flag:DWORD
EXTRN	_hessian_double_normal_flag:DWORD
EXTRN	_hessian_normal_perp_flag:DWORD
EXTRN	_mobility_tensor:BYTE
EXTRN	_hessian_special_normal_flag:DWORD
EXTRN	_hessian_normal_flag:DWORD
EXTRN	_view_4D_flag:DWORD
EXTRN	_mean_curv_int_quantity_num:DWORD
EXTRN	_sq_mean_curv_quantity_num:DWORD
EXTRN	_gravity_quantity_num:DWORD
EXTRN	_star_sq_mean_curvature_mi:DWORD
EXTRN	_star_eff_area_sq_mean_curvature_mi:DWORD
EXTRN	_hessian_special_normal_expr:BYTE
EXTRN	_star_normal_sq_mean_curvature_mi:DWORD
EXTRN	_mix_sq_mean_curvature_mi:DWORD
EXTRN	_sq_mean_curvature_mi:DWORD
EXTRN	_eff_area_sq_mean_curvature_mi:DWORD
EXTRN	_normal_sq_mean_curvature_mi:DWORD
EXTRN	_innerflag:DWORD
EXTRN	_outerflag:DWORD
EXTRN	_eigen_neg:DWORD
EXTRN	_eigen_pos:DWORD
EXTRN	_eigen_zero:DWORD
EXTRN	_hess_move_con_flag:DWORD
EXTRN	_hessian_linear_metric_flag:DWORD
EXTRN	_min_square_grad_flag:DWORD
EXTRN	_quantities_only_flag:DWORD
EXTRN	_rotorder_var:DWORD
EXTRN	_thickenflag:DWORD
EXTRN	_optparamcount:DWORD
EXTRN	_user_thickness_flag:DWORD
EXTRN	_interp_bdry_param:DWORD
EXTRN	_kraynikpopvertex_flag:DWORD
EXTRN	_kraynikpopedge_flag:DWORD
EXTRN	_rgb_colors_flag:DWORD
EXTRN	_spherical_arc_flag:DWORD
EXTRN	_circular_arc_flag:DWORD
EXTRN	_autorecalc_flag:DWORD
EXTRN	_labelflag:DWORD
EXTRN	_crossingflag:DWORD
EXTRN	_septum_flag:DWORD
EXTRN	_force_edgeswap_flag:DWORD
EXTRN	_gridflag:DWORD
EXTRN	_boundary_expr_flag:DWORD
EXTRN	_ps_cmykflag:DWORD
EXTRN	_ps_colorflag:DWORD
EXTRN	_ackerman_flag:DWORD
EXTRN	_sqcurve_ignore_constr:DWORD
EXTRN	_new_vertex_id:DWORD
EXTRN	_new_edge_id:DWORD
EXTRN	_new_facet_id:DWORD
EXTRN	_new_body_id:DWORD
EXTRN	_needed_version:BYTE
EXTRN	_keep_macros_flag:DWORD
EXTRN	_pickvnum:DWORD
EXTRN	_pickenum:DWORD
EXTRN	_pickfnum:DWORD
EXTRN	_zener_drag_flag:DWORD
EXTRN	_volgrads_every_flag:DWORD
EXTRN	_check_increase_flag:DWORD
EXTRN	_last_error:DWORD
EXTRN	_linear_metric_mix:QWORD
EXTRN	_blas_flag:DWORD
EXTRN	_augmented_hessian_flag:DWORD
EXTRN	_last_hessian_scale:QWORD
EXTRN	_sparse_constraints_flag:DWORD
EXTRN	_last_eigenvalue:QWORD
EXTRN	_bad_errors_count:DWORD
EXTRN	_facets_same_vertices_count:DWORD
EXTRN	_edges_same_vertices_count:DWORD
EXTRN	_thickness:QWORD
EXTRN	_edge_loop_count:DWORD
EXTRN	_inconsistent_bodies_count:DWORD
EXTRN	_bad_next_prev_count:DWORD
EXTRN	_check_count:DWORD
EXTRN	_brightness:QWORD
EXTRN	_inputsave_flag:DWORD
EXTRN	_uminus_flag:DWORD
EXTRN	_hessian_epsilon:QWORD
EXTRN	_volume_method_name:BYTE
EXTRN	_hessian_epsilon_default:QWORD
EXTRN	_length_method_name:BYTE
EXTRN	_hessian_slant_cutoff:QWORD
EXTRN	_area_method_name:BYTE
EXTRN	_permlist:DWORD
EXTRN	_list:DWORD
EXTRN	_listmax:DWORD
EXTRN	_bi_sums:DWORD
EXTRN	_f_sums:DWORD
EXTRN	_cg_hvector:DWORD
EXTRN	_fpicklist:DWORD
EXTRN	_vpicklist:DWORD
EXTRN	_macros:DWORD
EXTRN	_macro_subs:DWORD
EXTRN	_option_q:DWORD
EXTRN	_extra_bdry_param_attr:DWORD
EXTRN	_extra_bdry_attr:DWORD
EXTRN	_local_nest_depth:DWORD
EXTRN	_dont_resize_flag:DWORD
EXTRN	_bezier1invert:BYTE
EXTRN	_bezier1revert:BYTE
EXTRN	_show_command:BYTE
EXTRN	_string_curve_tolerance:QWORD
EXTRN	_bezier_refine_1d:BYTE
EXTRN	_bezier2invert:BYTE
EXTRN	_bezier2revert:BYTE
EXTRN	_bezier_refine_2d:BYTE
EXTRN	_ps_gridedgewidth:QWORD
EXTRN	_edgeshow_flag:DWORD
EXTRN	_mpi_show_corona_flag:DWORD
EXTRN	_thread_stages:DWORD
EXTRN	_tgverts:DWORD
EXTRN	_ps_bareedgewidth:QWORD
EXTRN	_ritzvecs:DWORD
EXTRN	_rleftside:DWORD
EXTRN	_ps_conedgewidth:QWORD
EXTRN	_optparam_congrads:DWORD
EXTRN	_conrhs:DWORD
EXTRN	_ps_tripleedgewidth:QWORD
EXTRN	_pressures:DWORD
EXTRN	_conhess_base:DWORD
EXTRN	_ps_fixededgewidth:QWORD
EXTRN	_vproj_space:DWORD
EXTRN	_ps_stringwidth:QWORD
EXTRN	_vproj_base:DWORD
EXTRN	_vhead:DWORD
EXTRN	_ps_labelsize:QWORD
EXTRN	_pmax:BYTE
EXTRN	_warning_messages_new:DWORD
EXTRN	_warning_messages_max:DWORD
EXTRN	_warning_messages:DWORD
EXTRN	_estimate_flag:DWORD
EXTRN	_verbose_flag:DWORD
EXTRN	_replace_load_flag:DWORD
EXTRN	_addload_flag:DWORD
EXTRN	_file_no_used:DWORD
EXTRN	_pbase:BYTE
EXTRN	_file_names:DWORD
EXTRN	_kb_calloc:PROC
EXTRN	_file_no_max:DWORD
EXTRN	_file_no:DWORD
EXTRN	_srand48:PROC
EXTRN	_srand:PROC
EXTRN	_random_seed:DWORD
EXTRN	_default_random_seed:DWORD
EXTRN	_reset_skeleton:PROC
EXTRN	_initialize_perm_globals:PROC
EXTRN	_clear_globals:PROC
EXTRN	_clear_symtable:PROC
EXTRN	_list_free_all:PROC
EXTRN	_free_all_q_info:PROC
EXTRN	_clip_coeff_set_flag:DWORD
EXTRN	_slice_coeff_set_flag:DWORD
EXTRN	_clip_coeff:BYTE
EXTRN	_one_sided_lagrange_attr:DWORD
EXTRN	_one_sided_present:DWORD
EXTRN	_quantity_function_sparse_flag:DWORD
EXTRN	_some_no_transforms_flag:DWORD
EXTRN	_clip_view_flag:DWORD
EXTRN	_slice_view_flag:DWORD
EXTRN	_slice_coeff:BYTE
EXTRN	_view_transforms:DWORD
EXTRN	_view_transform_gens_expr:DWORD
EXTRN	_view_transform_gens:DWORD
EXTRN	_transform_gen_count:DWORD
EXTRN	_facet_diffusion_attr:DWORD
EXTRN	_edge_diffusion_attr:DWORD
EXTRN	_quarter_turn_var:DWORD
EXTRN	_lmc_mobility_attr:DWORD
EXTRN	_lmc_mc_attr:DWORD
EXTRN	_raw_velocity_attr:DWORD
EXTRN	_suppress_erroutstring:DWORD
EXTRN	_detorus_sticky:DWORD
EXTRN	_f_partition_proc_attr:DWORD
EXTRN	_e_partition_proc_attr:DWORD
EXTRN	_v_partition_proc_attr:DWORD
EXTRN	_f_partition_stage_attr:DWORD
EXTRN	_e_partition_stage_attr:DWORD
EXTRN	_v_partition_stage_attr:DWORD
EXTRN	_opacity_attr:DWORD
EXTRN	_facet_alpha_flag:DWORD
EXTRN	_break_on_warning:DWORD
EXTRN	_bounding_box_color:DWORD
EXTRN	_window_aspect_ratio:QWORD
EXTRN	_box_flag:DWORD
EXTRN	_BK_flag:DWORD
EXTRN	_facet_alpha:QWORD
EXTRN	_realloc:PROC
EXTRN	_thread_data_ptrs:DWORD
EXTRN	_nprocs:DWORD
EXTRN	_little_endian_flag:DWORD
EXTRN	_former_torus_display_mode:DWORD
EXTRN	_torus_display_mode:DWORD
EXTRN	_display_text_count:DWORD
EXTRN	_token_count:DWORD
EXTRN	_dymemsize:DWORD
EXTRN	_text_chunks:BYTE
EXTRN	_unload_libraries:PROC
EXTRN	_memset:PROC
;	COMDAT __real@40f869f000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\lexinit.c
CONST	SEGMENT
__real@40f869f000000000 DQ 040f869f000000000r	; 99999
CONST	ENDS
;	COMDAT __real@3d719799812dea11
CONST	SEGMENT
__real@3d719799812dea11 DQ 03d719799812dea11r	; 1e-012
CONST	ENDS
;	COMDAT __real@3ff6666666666666
CONST	SEGMENT
__real@3ff6666666666666 DQ 03ff6666666666666r	; 1.4
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT ??_C@_04GOEDGNCF@area?$AA@
CONST	SEGMENT
??_C@_04GOEDGNCF@area?$AA@ DB 'area', 00H		; `string'
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __real@3eb0c6f7a0b5ed8d
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-006
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f1a36e2eb1c432d
CONST	SEGMENT
__real@3f1a36e2eb1c432d DQ 03f1a36e2eb1c432dr	; 0.0001
CONST	ENDS
;	COMDAT __real@3fe4cccccccccccd
CONST	SEGMENT
__real@3fe4cccccccccccd DQ 03fe4cccccccccccdr	; 0.65
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT __real@3f647ae147ae147b
CONST	SEGMENT
__real@3f647ae147ae147b DQ 03f647ae147ae147br	; 0.0025
CONST	ENDS
;	COMDAT __real@3f589374bc6a7efa
CONST	SEGMENT
__real@3f589374bc6a7efa DQ 03f589374bc6a7efar	; 0.0015
CONST	ENDS
;	COMDAT __real@3f60624dd2f1a9fc
CONST	SEGMENT
__real@3f60624dd2f1a9fc DQ 03f60624dd2f1a9fcr	; 0.002
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT ??_C@_05MHOFLBOO@stdin?$AA@
CONST	SEGMENT
??_C@_05MHOFLBOO@stdin?$AA@ DB 'stdin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
CONST	SEGMENT
??_C@_09JGPPFAML@LEXINIT?4C?$AA@ DB 'LEXINIT.C', 00H	; `string'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@41684bfe477e06cc
CONST	SEGMENT
__real@41684bfe477e06cc DQ 041684bfe477e06ccr	; 1.27385e+007
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _reset_web
_TEXT	SEGMENT
_stack_used$89378 = -16					; size = 4
_bflag$ = -12						; size = 4
_cflag$ = -8						; size = 4
_sdim$89464 = -4					; size = 4
_i$ = -4						; size = 4
_reset_web PROC						; COMDAT

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 30   :   int i,j;
; 31   :   int cflag = web.torus_clip_flag;

	mov	eax, DWORD PTR _web+800

; 32   :   int bflag = web.torus_body_flag;

	mov	ecx, DWORD PTR _web+804
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _cflag$[ebp], eax
	mov	DWORD PTR _bflag$[ebp], ecx

; 33   : 
; 34   :   
; 35   :   unload_libraries(); /* unload dynamic libraries */

	call	_unload_libraries

; 36   :   dymemsize = 0;

	xor	ebx, ebx

; 37   :   dymem = NULL; 
; 38   :   token_count = 0;
; 39   :   display_text_count = 0;
; 40   :   memset(text_chunks,0,sizeof(text_chunks));

	push	3200					; 00000c80H
	push	ebx
	push	OFFSET _text_chunks
	mov	DWORD PTR _dymemsize, ebx
	mov	DWORD PTR _dymem, ebx
	mov	DWORD PTR _token_count, ebx
	mov	DWORD PTR _display_text_count, ebx
	call	_memset

; 41   :  
; 42   :   if ( torus_display_mode )

	mov	eax, DWORD PTR _torus_display_mode
	add	esp, 12					; 0000000cH
	cmp	eax, ebx
	je	SHORT $LN18@reset_web

; 43   :     former_torus_display_mode = torus_display_mode;

	mov	DWORD PTR _former_torus_display_mode, eax
$LN18@reset_web:

; 44   : 
; 45   :   i = 1;
; 46   :   if ( ((char*)&i)[0] ) little_endian_flag = 1;
; 47   :   else big_endian_flag = 1;
; 48   : 
; 49   :   /* cut down overgrown eval stacks */
; 50   :   for ( i = 0 ; i < nprocs ; i++ )

	xor	edx, edx
	mov	edi, 1
	mov	DWORD PTR _little_endian_flag, edi
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _nprocs, ebx
	jle	SHORT $LN13@reset_web
$LL15@reset_web:

; 51   :   { struct thread_data *td = thread_data_ptrs[i];

	mov	eax, DWORD PTR _thread_data_ptrs
	mov	esi, DWORD PTR [eax+edx*4]

; 52   :     int stack_used = (int)(td->stack_top - td->eval_stack);

	mov	ecx, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+48]
	sub	eax, ecx
	sar	eax, 3
	mov	DWORD PTR _stack_used$89378[ebp], eax

; 53   :     if ( td->eval_stack_size > stack_used + 1000 )

	add	eax, 1000				; 000003e8H
	cmp	DWORD PTR [esi+44], eax
	jle	SHORT $LN14@reset_web

; 54   :     { td->eval_stack_size = stack_used + 1000;
; 55   :       td->eval_stack = 
; 56   :           (REAL*)realloc(td->eval_stack,td->eval_stack_size*sizeof(REAL));

	lea	edx, DWORD PTR [eax*8]
	push	edx
	push	ecx
	mov	DWORD PTR [esi+44], eax
	call	_realloc

; 57   :       td->stack_top = td->eval_stack + stack_used;
; 58   :       td->eval_stack[td->eval_stack_size-1] = STACKMAGIC;

	fld	QWORD PTR __real@41684bfe477e06cc
	mov	ecx, DWORD PTR _stack_used$89378[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+48], edx
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [esi+40], eax
	fstp	QWORD PTR [eax+ecx*8-8]
	add	esp, 8
$LN14@reset_web:

; 44   : 
; 45   :   i = 1;
; 46   :   if ( ((char*)&i)[0] ) little_endian_flag = 1;
; 47   :   else big_endian_flag = 1;
; 48   : 
; 49   :   /* cut down overgrown eval stacks */
; 50   :   for ( i = 0 ; i < nprocs ; i++ )

	add	edx, edi
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, DWORD PTR _nprocs
	jl	SHORT $LL15@reset_web
$LN13@reset_web:

; 59   :     }
; 60   : //    td->stack_top = td->eval_stack;  // don't chop, in case of permload
; 61   :   }   
; 62   : 
; 63   :   /* reset nonzero flags and stuff */
; 64   : 
; 65   :   BK_flag = 0;
; 66   :   box_flag = 0;
; 67   :   bounding_box_color = BLUE;
; 68   :   break_on_warning = 0;
; 69   :   facet_alpha = 1;

	fld1

; 70   :   facet_alpha_flag = 0;
; 71   :   opacity_attr = 0;
; 72   :   v_partition_stage_attr = -1;

	or	esi, -1
	fstp	QWORD PTR _facet_alpha
	mov	DWORD PTR _BK_flag, ebx

; 73   :   e_partition_stage_attr = -1;
; 74   :   f_partition_stage_attr = -1;
; 75   :   v_partition_proc_attr = -1;
; 76   :   e_partition_proc_attr = -1;
; 77   :   f_partition_proc_attr = -1;
; 78   :   detorus_sticky = 1;
; 79   :   suppress_erroutstring = 0;
; 80   :   raw_velocity_attr = -1;
; 81   :   lmc_mc_attr = -1; 
; 82   :   lmc_mobility_attr = -1;
; 83   :   quarter_turn_var = -1;
; 84   :   edge_diffusion_attr = -1;
; 85   :   facet_diffusion_attr = -1;
; 86   :   window_aspect_ratio = 0.0;  /* signifying not used */

	fldz
	mov	DWORD PTR _box_flag, ebx
	fstp	QWORD PTR _window_aspect_ratio
	mov	DWORD PTR _bounding_box_color, edi
	mov	DWORD PTR _break_on_warning, ebx
	mov	DWORD PTR _facet_alpha_flag, ebx
	mov	DWORD PTR _opacity_attr, ebx
	mov	DWORD PTR _v_partition_stage_attr, esi
	mov	DWORD PTR _e_partition_stage_attr, esi
	mov	DWORD PTR _f_partition_stage_attr, esi
	mov	DWORD PTR _v_partition_proc_attr, esi
	mov	DWORD PTR _e_partition_proc_attr, esi
	mov	DWORD PTR _f_partition_proc_attr, esi
	mov	DWORD PTR _detorus_sticky, edi
	mov	DWORD PTR _suppress_erroutstring, ebx
	mov	DWORD PTR _raw_velocity_attr, esi
	mov	DWORD PTR _lmc_mc_attr, esi
	mov	DWORD PTR _lmc_mobility_attr, esi
	mov	DWORD PTR _quarter_turn_var, esi
	mov	DWORD PTR _edge_diffusion_attr, esi
	mov	DWORD PTR _facet_diffusion_attr, esi

; 87   :   transform_gen_count = 0;

	mov	DWORD PTR _transform_gen_count, ebx

; 88   :   view_transform_gens = NULL;

	mov	DWORD PTR _view_transform_gens, ebx

; 89   :   view_transform_gens_expr = NULL;

	mov	DWORD PTR _view_transform_gens_expr, ebx

; 90   :   view_transforms = NULL;

	mov	DWORD PTR _view_transforms, ebx

; 91   :   if ( !bflag && !cflag )

	cmp	DWORD PTR _bflag$[ebp], ebx
	jne	SHORT $LN11@reset_web
	cmp	DWORD PTR _cflag$[ebp], ebx
	jne	SHORT $LN11@reset_web

; 92   :     torus_display_mode = TORUS_DEFAULT_MODE; 

	mov	DWORD PTR _torus_display_mode, ebx
$LN11@reset_web:

; 93   :   slice_view_flag = 0;
; 94   :   clip_view_flag = 0;
; 95   :   some_no_transforms_flag = 0;
; 96   :   quantity_function_sparse_flag = 1;
; 97   :   one_sided_present = 0;
; 98   :   one_sided_lagrange_attr = -1;
; 99   : 
; 100  :   memset(slice_coeff,0,sizeof(slice_coeff));

	push	64					; 00000040H
	push	ebx
	push	OFFSET _slice_coeff
	mov	DWORD PTR _slice_view_flag, ebx
	mov	DWORD PTR _clip_view_flag, ebx
	mov	DWORD PTR _some_no_transforms_flag, ebx
	mov	DWORD PTR _quantity_function_sparse_flag, edi
	mov	DWORD PTR _one_sided_present, ebx
	mov	DWORD PTR _one_sided_lagrange_attr, esi
	call	_memset

; 101  :   memset(clip_coeff,0,sizeof(clip_coeff));

	push	640					; 00000280H
	push	ebx
	push	OFFSET _clip_coeff
	call	_memset

; 102  :   clip_coeff[0][0] = 1.0;

	fld1
	fstp	QWORD PTR _clip_coeff

; 103  :   slice_coeff_set_flag = 0;

	mov	DWORD PTR _slice_coeff_set_flag, ebx

; 104  :   clip_coeff_set_flag = 0;

	mov	DWORD PTR _clip_coeff_set_flag, ebx

; 105  : 
; 106  :   free_all_q_info();

	call	_free_all_q_info

; 107  :   list_free_all(PERM_BLOCK);  /* get rid of everything */

	push	43947					; 0000ababH
	call	_list_free_all

; 108  : 
; 109  :   clear_symtable();

	call	_clear_symtable

; 110  :   clear_globals();  /* need this to reset global name hash table */

	call	_clear_globals

; 111  :   initialize_perm_globals(); /* put some internal variable names in permanent symbol table */

	call	_initialize_perm_globals

; 112  : 
; 113  :   reset_skeleton();  /* cleans out web and resets to 0 */

	call	_reset_skeleton

; 114  : 
; 115  : #ifdef MPI_EVOLVER
; 116  :   mpi_reset();
; 117  : #endif
; 118  : 
; 119  : #ifdef MPI_EVOLVER
; 120  :  random_seed = default_random_seed+this_task;  
; 121  : #else
; 122  :  random_seed = default_random_seed;  

	mov	eax, DWORD PTR _default_random_seed

; 123  : #endif
; 124  :   srand(random_seed); srand48(random_seed);

	push	eax
	mov	DWORD PTR _random_seed, eax
	call	_srand
	mov	edx, DWORD PTR _random_seed
	push	edx
	call	_srand48

; 125  : 
; 126  :   file_no = 0;
; 127  :   file_no_max = 12;
; 128  :   file_names = (char**)mycalloc(file_no_max,sizeof(char**));

	push	128					; 00000080H
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	push	4
	push	12					; 0000000cH
	mov	DWORD PTR _file_no, ebx
	mov	DWORD PTR _file_no_max, 12		; 0000000cH
	call	_kb_calloc

; 129  :   file_names[0] = "stdin";
; 130  :   file_no_used = 1;
; 131  : 
; 132  :   addload_flag = 0;
; 133  :   replace_load_flag = 0;
; 134  :   verbose_flag = 0;
; 135  :   estimate_flag = 0;
; 136  :   warning_messages = NULL;
; 137  :   warning_messages_max = 0;
; 138  :   warning_messages_new = 0;
; 139  :   memset((char*)pbase,0,sizeof(pbase));

	push	576					; 00000240H
	mov	DWORD PTR _file_names, eax
	mov	DWORD PTR [eax], OFFSET ??_C@_05MHOFLBOO@stdin?$AA@
	push	ebx
	push	OFFSET _pbase
	mov	DWORD PTR _file_no_used, edi
	mov	DWORD PTR _addload_flag, ebx
	mov	DWORD PTR _replace_load_flag, ebx
	mov	DWORD PTR _verbose_flag, ebx
	mov	DWORD PTR _estimate_flag, ebx
	mov	DWORD PTR _warning_messages, ebx
	mov	DWORD PTR _warning_messages_max, ebx
	mov	DWORD PTR _warning_messages_new, ebx
	call	_memset
	add	esp, 64					; 00000040H

; 140  :   memset((char*)pmax,0,sizeof(pmax));

	push	576					; 00000240H
	push	ebx
	push	OFFSET _pmax
	call	_memset

; 141  :   vhead = NULL;
; 142  :   vproj_base = NULL; 
; 143  :   vproj_space = NULL;
; 144  :   conhess_base = NULL;
; 145  :   pressures = NULL;
; 146  :   conrhs = NULL;
; 147  :   optparam_congrads = NULL;
; 148  :   rleftside = NULL;
; 149  :   ritzvecs = NULL;
; 150  :   tgverts = NULL;
; 151  :   thread_stages = NULL;
; 152  :   mpi_show_corona_flag = 0;
; 153  :   edgeshow_flag = 1;
; 154  : 
; 155  :   /* Following PostScript line width variables relative to page size */
; 156  :   ps_labelsize = 3.0;

	fld	QWORD PTR __real@4008000000000000
	fstp	QWORD PTR _ps_labelsize
	mov	DWORD PTR _vhead, ebx

; 157  :   ps_stringwidth = 0.002;  /* default edge width */

	fld	QWORD PTR __real@3f60624dd2f1a9fc
	mov	DWORD PTR _vproj_base, ebx
	fst	QWORD PTR _ps_stringwidth
	mov	DWORD PTR _vproj_space, ebx

; 158  :   ps_fixededgewidth = 0.002;

	fst	QWORD PTR _ps_fixededgewidth
	mov	DWORD PTR _conhess_base, ebx

; 159  :   ps_tripleedgewidth = 0.0015;

	fld	QWORD PTR __real@3f589374bc6a7efa
	mov	DWORD PTR _pressures, ebx
	fstp	QWORD PTR _ps_tripleedgewidth
	mov	DWORD PTR _conrhs, ebx
	mov	DWORD PTR _optparam_congrads, ebx

; 160  :   ps_conedgewidth = 0.002;

	fstp	QWORD PTR _ps_conedgewidth
	mov	DWORD PTR _rleftside, ebx

; 161  :   ps_bareedgewidth = 0.0025;

	fld	QWORD PTR __real@3f647ae147ae147b
	mov	DWORD PTR _ritzvecs, ebx
	fstp	QWORD PTR _ps_bareedgewidth
	mov	DWORD PTR _tgverts, ebx
	mov	DWORD PTR _thread_stages, ebx
	mov	DWORD PTR _mpi_show_corona_flag, ebx
	mov	DWORD PTR _edgeshow_flag, edi

; 162  :   ps_gridedgewidth = 0.001;
; 163  : 
; 164  :   for ( i = 0 ; i < MAXLAGRANGE ; i++ )
; 165  :   { bezier1invert[i] = NULL;
; 166  :     bezier1revert[i] = NULL;
; 167  :     bezier_refine_1d[i] = NULL;
; 168  :     bezier2invert[i] = NULL;
; 169  :     bezier2revert[i] = NULL;
; 170  :     bezier_refine_2d[i] = NULL;

	xor	eax, eax
	fld	QWORD PTR __real@3f50624dd2f1a9fc
	fstp	QWORD PTR _ps_gridedgewidth
	mov	DWORD PTR _bezier_refine_2d, eax
	mov	DWORD PTR _bezier_refine_2d+4, eax
	mov	DWORD PTR _bezier_refine_2d+8, eax
	mov	DWORD PTR _bezier_refine_2d+12, eax
	mov	DWORD PTR _bezier_refine_2d+16, eax
	mov	DWORD PTR _bezier_refine_2d+20, eax
	mov	DWORD PTR _bezier_refine_2d+24, eax
	mov	DWORD PTR _bezier_refine_2d+28, eax
	mov	DWORD PTR _bezier_refine_2d+32, eax
	mov	DWORD PTR _bezier_refine_2d+36, eax
	mov	DWORD PTR _bezier_refine_2d+40, eax
	mov	DWORD PTR _bezier_refine_2d+44, eax
	mov	DWORD PTR _bezier_refine_2d+48, eax
	mov	DWORD PTR _bezier_refine_2d+52, eax
	mov	DWORD PTR _bezier_refine_2d+56, eax
	mov	DWORD PTR _bezier_refine_2d+60, eax
	mov	DWORD PTR _bezier_refine_2d+64, eax
	mov	DWORD PTR _bezier_refine_2d+68, eax
	mov	DWORD PTR _bezier_refine_2d+72, eax
	mov	DWORD PTR _bezier_refine_2d+76, eax
	mov	DWORD PTR _bezier2revert, eax
	mov	DWORD PTR _bezier2revert+4, eax
	mov	DWORD PTR _bezier2revert+8, eax
	mov	DWORD PTR _bezier2revert+12, eax
	mov	DWORD PTR _bezier2revert+16, eax
	mov	DWORD PTR _bezier2revert+20, eax
	mov	DWORD PTR _bezier2revert+24, eax
	mov	DWORD PTR _bezier2revert+28, eax
	mov	DWORD PTR _bezier2revert+32, eax
	mov	DWORD PTR _bezier2revert+36, eax
	mov	DWORD PTR _bezier2revert+40, eax
	mov	DWORD PTR _bezier2revert+44, eax
	mov	DWORD PTR _bezier2revert+48, eax
	mov	DWORD PTR _bezier2revert+52, eax
	mov	DWORD PTR _bezier2revert+56, eax
	mov	DWORD PTR _bezier2revert+60, eax
	mov	DWORD PTR _bezier2revert+64, eax
	mov	DWORD PTR _bezier2revert+68, eax
	mov	DWORD PTR _bezier2revert+72, eax
	mov	DWORD PTR _bezier2revert+76, eax
	mov	DWORD PTR _bezier2invert, eax
	mov	DWORD PTR _bezier2invert+4, eax
	mov	DWORD PTR _bezier2invert+8, eax
	mov	DWORD PTR _bezier2invert+12, eax
	mov	DWORD PTR _bezier2invert+16, eax
	mov	DWORD PTR _bezier2invert+20, eax
	mov	DWORD PTR _bezier2invert+24, eax
	mov	DWORD PTR _bezier2invert+28, eax
	mov	DWORD PTR _bezier2invert+32, eax
	mov	DWORD PTR _bezier2invert+36, eax
	mov	DWORD PTR _bezier2invert+40, eax
	mov	DWORD PTR _bezier2invert+44, eax
	mov	DWORD PTR _bezier2invert+48, eax
	mov	DWORD PTR _bezier2invert+52, eax
	mov	DWORD PTR _bezier2invert+56, eax
	mov	DWORD PTR _bezier2invert+60, eax
	mov	DWORD PTR _bezier2invert+64, eax
	mov	DWORD PTR _bezier2invert+68, eax
	mov	DWORD PTR _bezier2invert+72, eax
	mov	DWORD PTR _bezier2invert+76, eax
	mov	DWORD PTR _bezier_refine_1d, eax
	mov	DWORD PTR _bezier_refine_1d+4, eax
	mov	DWORD PTR _bezier_refine_1d+8, eax
	mov	DWORD PTR _bezier_refine_1d+12, eax
	mov	DWORD PTR _bezier_refine_1d+16, eax
	mov	DWORD PTR _bezier_refine_1d+20, eax
	mov	DWORD PTR _bezier_refine_1d+24, eax
	mov	DWORD PTR _bezier_refine_1d+28, eax
	mov	DWORD PTR _bezier_refine_1d+32, eax
	mov	DWORD PTR _bezier_refine_1d+36, eax
	mov	DWORD PTR _bezier_refine_1d+40, eax
	mov	DWORD PTR _bezier_refine_1d+44, eax
	mov	DWORD PTR _bezier_refine_1d+48, eax
	mov	DWORD PTR _bezier_refine_1d+52, eax
	mov	DWORD PTR _bezier_refine_1d+56, eax
	mov	DWORD PTR _bezier_refine_1d+60, eax
	mov	DWORD PTR _bezier_refine_1d+64, eax
	mov	DWORD PTR _bezier_refine_1d+68, eax

; 171  :   }
; 172  :   string_curve_tolerance = 2.0; /* degrees */

	fld	QWORD PTR __real@4000000000000000

; 173  : 
; 174  :   dont_resize_flag = 0;
; 175  :   local_nest_depth = 0;
; 176  :   extra_bdry_attr = 0;
; 177  :   extra_bdry_param_attr = 0;
; 178  :   memset((char*)show_command,0,sizeof(show_command));

	push	520					; 00000208H
	push	ebx
	fstp	QWORD PTR _string_curve_tolerance
	push	OFFSET _show_command
	mov	DWORD PTR _bezier_refine_1d+72, eax
	mov	DWORD PTR _bezier_refine_1d+76, eax
	mov	DWORD PTR _bezier1revert, eax
	mov	DWORD PTR _bezier1revert+4, eax
	mov	DWORD PTR _bezier1revert+8, eax
	mov	DWORD PTR _bezier1revert+12, eax
	mov	DWORD PTR _bezier1revert+16, eax
	mov	DWORD PTR _bezier1revert+20, eax
	mov	DWORD PTR _bezier1revert+24, eax
	mov	DWORD PTR _bezier1revert+28, eax
	mov	DWORD PTR _bezier1revert+32, eax
	mov	DWORD PTR _bezier1revert+36, eax
	mov	DWORD PTR _bezier1revert+40, eax
	mov	DWORD PTR _bezier1revert+44, eax
	mov	DWORD PTR _bezier1revert+48, eax
	mov	DWORD PTR _bezier1revert+52, eax
	mov	DWORD PTR _bezier1revert+56, eax
	mov	DWORD PTR _bezier1revert+60, eax
	mov	DWORD PTR _bezier1revert+64, eax
	mov	DWORD PTR _bezier1revert+68, eax
	mov	DWORD PTR _bezier1revert+72, eax
	mov	DWORD PTR _bezier1revert+76, eax
	mov	DWORD PTR _bezier1invert, eax
	mov	DWORD PTR _bezier1invert+4, eax
	mov	DWORD PTR _bezier1invert+8, eax
	mov	DWORD PTR _bezier1invert+12, eax
	mov	DWORD PTR _bezier1invert+16, eax
	mov	DWORD PTR _bezier1invert+20, eax
	mov	DWORD PTR _bezier1invert+24, eax
	mov	DWORD PTR _bezier1invert+28, eax
	mov	DWORD PTR _bezier1invert+32, eax
	mov	DWORD PTR _bezier1invert+36, eax
	mov	DWORD PTR _bezier1invert+40, eax
	mov	DWORD PTR _bezier1invert+44, eax
	mov	DWORD PTR _bezier1invert+48, eax
	mov	DWORD PTR _bezier1invert+52, eax
	mov	DWORD PTR _bezier1invert+56, eax
	mov	DWORD PTR _bezier1invert+60, eax
	mov	DWORD PTR _bezier1invert+64, eax
	mov	DWORD PTR _bezier1invert+68, eax
	mov	DWORD PTR _bezier1invert+72, eax
	mov	DWORD PTR _bezier1invert+76, eax
	mov	DWORD PTR _dont_resize_flag, ebx
	mov	DWORD PTR _local_nest_depth, ebx
	mov	DWORD PTR _extra_bdry_attr, ebx
	mov	DWORD PTR _extra_bdry_param_attr, ebx
	call	_memset
	add	esp, 24					; 00000018H

; 179  :   macro_subs = NULL;
; 180  :   macros = NULL;
; 181  :   vpicklist = NULL;
; 182  :   fpicklist = NULL;
; 183  :   cg_hvector = NULL;
; 184  :   f_sums = NULL;
; 185  :   bi_sums = NULL;
; 186  :   listmax = 0; list = NULL; permlist = NULL;
; 187  :   if ( option_q == 2 ) option_q = 0;

	cmp	DWORD PTR _option_q, 2
	mov	DWORD PTR _macro_subs, ebx
	mov	DWORD PTR _macros, ebx
	mov	DWORD PTR _vpicklist, ebx
	mov	DWORD PTR _fpicklist, ebx
	mov	DWORD PTR _cg_hvector, ebx
	mov	DWORD PTR _f_sums, ebx
	mov	DWORD PTR _bi_sums, ebx
	mov	DWORD PTR _listmax, ebx
	mov	DWORD PTR _list, ebx
	mov	DWORD PTR _permlist, ebx
	jne	SHORT $LN7@reset_web
	mov	DWORD PTR _option_q, ebx
$LN7@reset_web:

; 188  :   area_method_name[0] = 0;
; 189  :   length_method_name[0] = 0;
; 190  :   volume_method_name[0] = 0;
; 191  :   uminus_flag = 0;
; 192  :   inputsave_flag = 0;
; 193  :   check_count = 0;
; 194  :   bad_next_prev_count = 0;
; 195  :   inconsistent_bodies_count = 0;
; 196  :   edge_loop_count = 0;
; 197  :   edges_same_vertices_count = 0;
; 198  :   facets_same_vertices_count = 0;
; 199  :   bad_errors_count = 0; 
; 200  :   hessian_slant_cutoff = 0.0;

	fldz
	mov	BYTE PTR _area_method_name, bl
	fst	QWORD PTR _hessian_slant_cutoff
	mov	BYTE PTR _length_method_name, bl

; 201  :   hessian_epsilon = hessian_epsilon_default;

	fld	QWORD PTR _hessian_epsilon_default
	mov	BYTE PTR _volume_method_name, bl
	fstp	QWORD PTR _hessian_epsilon
	mov	DWORD PTR _uminus_flag, ebx

; 202  :   #ifdef MPI_EVOLVER
; 203  :   sparse_constraints_flag = 0;
; 204  :   augmented_hessian_flag = 1;
; 205  :   #else
; 206  :   sparse_constraints_flag = 1;
; 207  :   augmented_hessian_flag = -1;
; 208  :   #endif
; 209  :   blas_flag = 0;
; 210  :   last_error = 0;
; 211  :   check_increase_flag = 0;
; 212  :   brightness = DEFAULT_BRIGHTNESS;

	fld	QWORD PTR __real@3fe4cccccccccccd
	mov	DWORD PTR _inputsave_flag, ebx
	fstp	QWORD PTR _brightness
	mov	DWORD PTR _check_count, ebx

; 213  :   volgrads_every_flag = 0;
; 214  :   zener_drag_flag = 0 ;
; 215  :   pickvnum = pickenum = pickfnum = 0;
; 216  :   keep_macros_flag = 0;
; 217  :   needed_version[0] = 0;
; 218  :   new_vertex_id = new_edge_id = new_facet_id = new_body_id = 0;
; 219  :   sqcurve_ignore_constr = 0;
; 220  :   ackerman_flag = 0;
; 221  :   ps_colorflag = -1;
; 222  :   ps_cmykflag = 0;
; 223  :   boundary_expr_flag = 0;
; 224  :   gridflag = -1;
; 225  :   force_edgeswap_flag = 0;
; 226  :   septum_flag = -1;
; 227  :   crossingflag = -1;
; 228  :   labelflag = -1;
; 229  :   web.target_tolerance = DEFAULT_TARGET_TOLERANCE;

	fld	QWORD PTR __real@3f1a36e2eb1c432d
	mov	DWORD PTR _bad_next_prev_count, ebx
	fstp	QWORD PTR _web+760
	mov	DWORD PTR _inconsistent_bodies_count, ebx

; 230  :   web.highcon = -1;
; 231  :   web.highbdry = -1;
; 232  :   autorecalc_flag = 1;
; 233  :   circular_arc_flag = 0;
; 234  :   spherical_arc_flag = 0;
; 235  :   rgb_colors_flag = 0;
; 236  :   kraynikpopedge_flag = 0;
; 237  :   kraynikpopvertex_flag = 1;
; 238  :   interp_bdry_param = 0;
; 239  :   web.headvnum = 1;
; 240  :   thickness = .001;

	fld	QWORD PTR __real@3f50624dd2f1a9fc
	mov	DWORD PTR _edge_loop_count, ebx
	fstp	QWORD PTR _thickness
	mov	DWORD PTR _edges_same_vertices_count, ebx
	mov	DWORD PTR _facets_same_vertices_count, ebx
	mov	DWORD PTR _bad_errors_count, ebx

; 241  :   user_thickness_flag = 0;
; 242  :   last_eigenvalue = 0.0;

	fst	QWORD PTR _last_eigenvalue
	mov	DWORD PTR _sparse_constraints_flag, edi

; 243  :   last_hessian_scale = 0.0;

	fstp	QWORD PTR _last_hessian_scale
	mov	DWORD PTR _augmented_hessian_flag, esi

; 244  :   optparamcount = 0;
; 245  :   thickenflag = 0;
; 246  :   rotorder_var = -1;
; 247  :   quantities_only_flag = everything_quantities_flag = 0;
; 248  :   linear_metric_mix = .50;

	fld	QWORD PTR __real@3fe0000000000000
	mov	DWORD PTR _blas_flag, ebx
	fstp	QWORD PTR _linear_metric_mix
	mov	DWORD PTR _last_error, ebx
	mov	DWORD PTR _check_increase_flag, ebx
	mov	DWORD PTR _volgrads_every_flag, ebx
	mov	DWORD PTR _zener_drag_flag, ebx
	mov	DWORD PTR _pickfnum, ebx
	mov	DWORD PTR _pickenum, ebx
	mov	DWORD PTR _pickvnum, ebx
	mov	DWORD PTR _keep_macros_flag, ebx
	mov	BYTE PTR _needed_version, bl
	mov	DWORD PTR _new_body_id, ebx
	mov	DWORD PTR _new_facet_id, ebx
	mov	DWORD PTR _new_edge_id, ebx
	mov	DWORD PTR _new_vertex_id, ebx
	mov	DWORD PTR _sqcurve_ignore_constr, ebx
	mov	DWORD PTR _ackerman_flag, ebx
	mov	DWORD PTR _ps_colorflag, esi
	mov	DWORD PTR _ps_cmykflag, ebx
	mov	DWORD PTR _boundary_expr_flag, ebx
	mov	DWORD PTR _gridflag, esi
	mov	DWORD PTR _force_edgeswap_flag, ebx
	mov	DWORD PTR _septum_flag, esi
	mov	DWORD PTR _crossingflag, esi
	mov	DWORD PTR _labelflag, esi
	mov	DWORD PTR _web+648, esi
	mov	DWORD PTR _web+772, esi
	mov	DWORD PTR _autorecalc_flag, edi
	mov	DWORD PTR _circular_arc_flag, ebx
	mov	DWORD PTR _spherical_arc_flag, ebx
	mov	DWORD PTR _rgb_colors_flag, ebx
	mov	DWORD PTR _kraynikpopedge_flag, ebx
	mov	DWORD PTR _kraynikpopvertex_flag, edi
	mov	DWORD PTR _interp_bdry_param, ebx
	mov	DWORD PTR _web+636, edi
	mov	DWORD PTR _user_thickness_flag, ebx
	mov	DWORD PTR _optparamcount, ebx
	mov	DWORD PTR _thickenflag, ebx
	mov	DWORD PTR _rotorder_var, esi
	mov	DWORD PTR _everything_quantities_flag, ebx
	mov	DWORD PTR _quantities_only_flag, ebx

; 249  :   min_square_grad_flag = 0;

	mov	DWORD PTR _min_square_grad_flag, ebx

; 250  :   hessian_linear_metric_flag = 0;

	mov	DWORD PTR _hessian_linear_metric_flag, ebx

; 251  :   hess_move_con_flag = 1;

	mov	DWORD PTR _hess_move_con_flag, edi

; 252  :   eigen_neg = eigen_pos = eigen_zero = 0;

	mov	DWORD PTR _eigen_zero, ebx
	mov	DWORD PTR _eigen_pos, ebx
	mov	DWORD PTR _eigen_neg, ebx

; 253  :   innerflag = outerflag = 1;

	mov	DWORD PTR _outerflag, edi
	mov	DWORD PTR _innerflag, edi

; 254  :   normal_sq_mean_curvature_mi = -1;

	mov	DWORD PTR _normal_sq_mean_curvature_mi, esi

; 255  :   eff_area_sq_mean_curvature_mi = -1;

	mov	DWORD PTR _eff_area_sq_mean_curvature_mi, esi

; 256  :   sq_mean_curvature_mi = -1;

	mov	DWORD PTR _sq_mean_curvature_mi, esi

; 257  :   mix_sq_mean_curvature_mi = -1;

	mov	DWORD PTR _mix_sq_mean_curvature_mi, esi

; 258  :   star_normal_sq_mean_curvature_mi = -1;

	mov	DWORD PTR _star_normal_sq_mean_curvature_mi, esi

; 259  :   star_eff_area_sq_mean_curvature_mi = -1;
; 260  :   star_sq_mean_curvature_mi = -1;
; 261  :   gravity_quantity_num = -1;
; 262  :   sq_mean_curv_quantity_num = -1;
; 263  :   mean_curv_int_quantity_num = -1;
; 264  :   view_4D_flag = 0;
; 265  :   hessian_normal_flag = 1;
; 266  :   hessian_special_normal_flag = 0;
; 267  :   memset((char*)hessian_special_normal_expr,0,MAXCOORD*sizeof(struct expnode));

	push	624					; 00000270H
	push	ebx
	push	OFFSET _hessian_special_normal_expr
	mov	DWORD PTR _star_eff_area_sq_mean_curvature_mi, esi
	mov	DWORD PTR _star_sq_mean_curvature_mi, esi
	mov	DWORD PTR _gravity_quantity_num, esi
	mov	DWORD PTR _sq_mean_curv_quantity_num, esi
	mov	DWORD PTR _mean_curv_int_quantity_num, esi
	mov	DWORD PTR _view_4D_flag, ebx
	mov	DWORD PTR _hessian_normal_flag, edi
	mov	DWORD PTR _hessian_special_normal_flag, ebx
	call	_memset

; 268  :   hessian_normal_perp_flag = 0;
; 269  :   hessian_double_normal_flag = 0;
; 270  :   hessian_normal_one_flag = 0;
; 271  :   hessian_quiet_flag = 1;
; 272  :   hessian_by_diff_flag = 0;
; 273  :   hess_debug = 0;
; 274  :   mindeg_debug_level = 0;
; 275  :   dirichlet_flag = 0;
; 276  :   sobolev_flag = 0;
; 277  :   quiet_go_flag = 0;
; 278  :   quiet_flag = 0;
; 279  :   pressure_set_flag = 1;
; 280  :   self_similar_flag = 0;
; 281  :   make_pos_def_flag = 0;
; 282  :   datafile_view_flag = 0;
; 283  :   post_project_flag = 0;
; 284  :   read_command_flag = 0;
; 285  :   ribiere_flag = 1;
; 286  :   assume_oriented_flag = 0;
; 287  :   K_altitude_flag = 0;
; 288  :   conj_grad_flag = 0;
; 289  :   mobility_flag = mobility_tensor_flag = 0;
; 290  :   memset((void*)mobility_tensor,0,sizeof(mobility_tensor));

	push	3744					; 00000ea0H
	push	ebx
	push	OFFSET _mobility_tensor
	mov	DWORD PTR _hessian_normal_perp_flag, ebx
	mov	DWORD PTR _hessian_double_normal_flag, ebx
	mov	DWORD PTR _hessian_normal_one_flag, ebx
	mov	DWORD PTR _hessian_quiet_flag, edi
	mov	DWORD PTR _hessian_by_diff_flag, ebx
	mov	DWORD PTR _hess_debug, ebx
	mov	DWORD PTR _mindeg_debug_level, ebx
	mov	DWORD PTR _dirichlet_flag, ebx
	mov	DWORD PTR _sobolev_flag, ebx
	mov	DWORD PTR _quiet_go_flag, ebx
	mov	DWORD PTR _quiet_flag, ebx
	mov	DWORD PTR _pressure_set_flag, edi
	mov	DWORD PTR _self_similar_flag, ebx
	mov	DWORD PTR _make_pos_def_flag, ebx
	mov	DWORD PTR _datafile_view_flag, ebx
	mov	DWORD PTR _post_project_flag, ebx
	mov	DWORD PTR _read_command_flag, ebx
	mov	DWORD PTR _ribiere_flag, edi
	mov	DWORD PTR _assume_oriented_flag, ebx
	mov	DWORD PTR _K_altitude_flag, ebx
	mov	DWORD PTR _conj_grad_flag, ebx
	mov	DWORD PTR _mobility_tensor_flag, ebx
	mov	DWORD PTR _mobility_flag, ebx
	call	_memset

; 291  :   memset((void*)&mobility_formula,0,sizeof(mobility_formula));

	push	104					; 00000068H
	push	ebx
	push	OFFSET _mobility_formula
	call	_memset

; 292  :   memset((void*)elements_predicted,0,sizeof(elements_predicted));
; 293  :   quantities_predicted = 0;
; 294  :   method_instances_predicted = 0;
; 295  :   old_area_flag = 0;
; 296  :   area_fixed_flag = 0;
; 297  :   sqgauss_flag = 0;
; 298  :   square_curvature_flag = 0;
; 299  :   mean_curv_int_flag = 0;
; 300  :   boundary_curvature_flag = 0;
; 301  :   normal_curvature_flag = 0;
; 302  :   approx_curve_flag = 0;
; 303  :   kusner_flag = 0;
; 304  :   klein_metric_flag = 0;
; 305  :   conf_edge_curv_flag = 0;
; 306  :   effective_area_flag = 0;
; 307  :   autochop_flag = 0; 
; 308  :   autopop_flag = 0;
; 309  :   immediate_autopop_flag = 0;
; 310  :   autopop_quartic_flag = 0;
; 311  :   pop_disjoin_flag = 0;
; 312  :   pop_enjoin_flag = 0;
; 313  :   pop_to_edge_flag = 0;
; 314  :   pop_to_face_flag = 0;
; 315  :   runge_kutta_flag = 0;
; 316  :   web.dimension = 2;
; 317  :   web.representation = SOAPFILM;
; 318  :   web.skel[VERTEX].ctrlpts = 1;
; 319  :   web.skel[EDGE].ctrlpts = 2;
; 320  :   web.skel[FACET].ctrlpts = 3;
; 321  :   star_fraction = web.dimension + 1.0;

	fld	QWORD PTR __real@4008000000000000
	mov	esi, 2
	fstp	QWORD PTR _star_fraction
	mov	eax, 3
	add	esp, 36					; 00000024H
	mov	DWORD PTR _elements_predicted, ebx
	mov	DWORD PTR _elements_predicted+4, ebx
	mov	DWORD PTR _elements_predicted+8, ebx
	mov	DWORD PTR _elements_predicted+12, ebx
	mov	DWORD PTR _elements_predicted+16, ebx
	mov	DWORD PTR _quantities_predicted, ebx
	mov	DWORD PTR _method_instances_predicted, ebx
	mov	DWORD PTR _old_area_flag, ebx
	mov	DWORD PTR _area_fixed_flag, ebx
	mov	DWORD PTR _sqgauss_flag, ebx
	mov	DWORD PTR _square_curvature_flag, ebx
	mov	DWORD PTR _mean_curv_int_flag, ebx
	mov	DWORD PTR _boundary_curvature_flag, ebx
	mov	DWORD PTR _normal_curvature_flag, ebx
	mov	DWORD PTR _approx_curve_flag, ebx
	mov	DWORD PTR _kusner_flag, ebx
	mov	DWORD PTR _klein_metric_flag, ebx
	mov	DWORD PTR _conf_edge_curv_flag, ebx
	mov	DWORD PTR _effective_area_flag, ebx
	mov	DWORD PTR _autochop_flag, ebx
	mov	DWORD PTR _autopop_flag, ebx
	mov	DWORD PTR _immediate_autopop_flag, ebx
	mov	DWORD PTR _autopop_quartic_flag, ebx
	mov	DWORD PTR _pop_disjoin_flag, ebx
	mov	DWORD PTR _pop_enjoin_flag, ebx
	mov	DWORD PTR _pop_to_edge_flag, ebx
	mov	DWORD PTR _pop_to_face_flag, ebx
	mov	DWORD PTR _runge_kutta_flag, ebx
	mov	DWORD PTR _web+620, esi
	mov	DWORD PTR _web+624, esi
	mov	DWORD PTR _web+8, edi
	mov	DWORD PTR _web+120, esi
	mov	DWORD PTR _web+232, eax

; 322  :   areaname = "area";
; 323  :   web.sdim = DEFAULT_SDIM;
; 324  :   total_time = 0.0;

	fldz

; 325  :   homothety_target = 1.0;
; 326  :   sym_flags = 0;
; 327  :   symmetry_name = NULL;
; 328  :   sym_wrap = identity_wrap;
; 329  :   sym_form_pullback = identity_form_pullback;
; 330  :   sym_inverse = identity_inverse;
; 331  :   sym_compose = identity_compose;
; 332  :   web.modeltype = LINEAR;
; 333  :   web.lagrange_order = 1;
; 334  :   bezier_flag = 0;
; 335  :   web.torus_clip_flag = cflag;

	mov	ecx, DWORD PTR _cflag$[ebp]
	fst	QWORD PTR _total_time

; 336  :   web.torus_body_flag = bflag;

	mov	edx, DWORD PTR _bflag$[ebp]
	fld1
	mov	DWORD PTR _web+616, eax
	fst	QWORD PTR _homothety_target

; 337  :   web.torus_flag = 0;
; 338  :   web.full_flag = 0;
; 339  :   dt_eps = DT_EPS_DEFAULT;
; 340  :   web.meritfactor = 0.0;
; 341  :   web.grav_const = 1.0;
; 342  :   web.symmetric_content = 0;
; 343  :   web.pressure_flag = 0;
; 344  :   web.projection_flag = 0;
; 345  :   web.area_norm_flag = 0;
; 346  :   web.vol_flag = 0;
; 347  :   web.jiggle_flag = 0;
; 348  :   web.temperature = 0.05;
; 349  :   web.total_area = 0.0;
; 350  :   web.total_facets = 0;
; 351  :   web.scale = 0.1;
; 352  :   web.scale_scale = 1.0;
; 353  :   web.maxscale = 1.0;
; 354  :   web.pressure = 0.0;
; 355  :   web.bodycount = 0;
; 356  :   web.wulff_count = web.wulff_flag = 0;
; 357  :   web.min_area = 0.1;
; 358  :   web.min_length = 0.25;
; 359  :   web.max_len = 1.4;
; 360  :   web.max_angle = 0.1;
; 361  :   web.spring_constant = 1.0;
; 362  :   web.gauss1D_order = 3;  /* can do 3  degree exactly (need default 7 in quadratic)*/

	mov	DWORD PTR _web+1592, eax
	fld	QWORD PTR __real@3eb0c6f7a0b5ed8d

; 363  :   set_by_user_gauss_1D = 0;
; 364  :   web.gauss2D_order = 6; /* can do 6th degree poly */ 
; 365  :   set_by_user_gauss_2D = 0;
; 366  :   memset(gauss_lagrange,0,sizeof(gauss_lagrange));

	xor	eax, eax
	fstp	QWORD PTR _dt_eps
	mov	DWORD PTR _gauss_lagrange, eax
	fxch	ST(1)
	mov	DWORD PTR _gauss_lagrange+4, eax
	fst	QWORD PTR _web+816
	mov	DWORD PTR _gauss_lagrange+8, eax
	fxch	ST(1)
	mov	DWORD PTR _gauss_lagrange+12, eax
	fst	QWORD PTR _web+832
	mov	DWORD PTR _gauss_lagrange+16, eax
	fld	QWORD PTR __real@3fa999999999999a
	mov	DWORD PTR _gauss_lagrange+20, eax
	fstp	QWORD PTR _web+1576

; 367  :   memset(maxgaussorder,0,sizeof(maxgaussorder));

	mov	DWORD PTR _maxgaussorder, eax
	fxch	ST(1)
	mov	DWORD PTR _maxgaussorder+4, eax
	fst	QWORD PTR _web+992
	mov	DWORD PTR _maxgaussorder+8, eax
	fld	QWORD PTR __real@3fb999999999999a
	mov	DWORD PTR _maxgaussorder+12, eax
	fst	QWORD PTR _web+1512
	mov	DWORD PTR _maxgaussorder+16, eax
	fxch	ST(2)
	mov	DWORD PTR _maxgaussorder+20, eax

; 368  :   web.tolerance = DEFAULT_TOLERANCE;
; 369  :   reflevel = 0;
; 370  :   no_refine = 0;
; 371  : 
; 372  :   globals(view_matrix_global)->attr.arrayptr->sizes[0] = 0;

	mov	eax, DWORD PTR _view_matrix_global
	fst	QWORD PTR _web+1520
	fst	QWORD PTR _web+1528
	mov	DWORD PTR _web+800, ecx
	fxch	ST(1)
	mov	ecx, eax
	fstp	QWORD PTR _web+1536
	and	ecx, -16777216				; ff000000H
	fxch	ST(1)
	mov	DWORD PTR _areaname, OFFSET ??_C@_04GOEDGNCF@area?$AA@
	fst	QWORD PTR _web+1544
	mov	DWORD PTR _sym_flags, ebx
	fld	QWORD PTR __real@3fd0000000000000
	mov	DWORD PTR _symmetry_name, ebx
	fstp	QWORD PTR _web+1552
	mov	DWORD PTR _sym_wrap, OFFSET _identity_wrap
	fld	QWORD PTR __real@3ff6666666666666
	mov	DWORD PTR _sym_form_pullback, OFFSET _identity_form_pullback
	fstp	QWORD PTR _web+1560
	mov	DWORD PTR _sym_inverse, OFFSET _identity_inverse
	mov	DWORD PTR _sym_compose, OFFSET _identity_compose
	mov	DWORD PTR _web+628, edi
	mov	DWORD PTR _web+632, edi
	fstp	QWORD PTR _web+1568
	mov	DWORD PTR _bezier_flag, ebx
	mov	DWORD PTR _web+804, edx
	fstp	QWORD PTR _web+1584
	mov	DWORD PTR _web+860, ebx
	fld	QWORD PTR __real@3d719799812dea11
	mov	DWORD PTR _web+864, ebx
	fstp	QWORD PTR _web+752
	mov	DWORD PTR _web+808, ebx
	mov	DWORD PTR _web+868, ebx
	mov	DWORD PTR _web+872, ebx
	mov	DWORD PTR _web+876, ebx
	mov	DWORD PTR _web+896, ebx
	mov	DWORD PTR _web+900, ebx
	mov	DWORD PTR _web+1496, ebx
	mov	DWORD PTR _web+1500, ebx
	mov	DWORD PTR _web+908, ebx
	mov	DWORD PTR _web+912, ebx
	mov	DWORD PTR _set_by_user_gauss_1D, ebx
	mov	DWORD PTR _web+1596, 6
	mov	DWORD PTR _set_by_user_gauss_2D, ebx
	mov	DWORD PTR _reflevel, ebx
	mov	DWORD PTR _no_refine, ebx
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN21@reset_web
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN23@reset_web
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN22@reset_web
$LN23@reset_web:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN21@reset_web
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN22@reset_web
$LN21@reset_web:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN22@reset_web:
	mov	ecx, DWORD PTR [eax+168]
	mov	DWORD PTR [ecx+24], ebx

; 373  :   globals(torus_periods_global)->attr.arrayptr->sizes[0] = 0;

	mov	eax, DWORD PTR _torus_periods_global
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN27@reset_web
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN29@reset_web
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN28@reset_web
$LN29@reset_web:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN27@reset_web
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN28@reset_web
$LN27@reset_web:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN28@reset_web:
	mov	edx, DWORD PTR [eax+168]
	mov	DWORD PTR [edx+24], ebx

; 374  :   globals(inverse_periods_global)->attr.arrayptr->sizes[0] = 0;

	mov	eax, DWORD PTR _inverse_periods_global
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN33@reset_web
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN35@reset_web
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN34@reset_web
$LN35@reset_web:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN33@reset_web
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN34@reset_web
$LN33@reset_web:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN34@reset_web:
	mov	ecx, DWORD PTR [eax+168]

; 375  :   memset(torus_period_expr,0,sizeof(torus_period_expr));

	push	3744					; 00000ea0H
	push	ebx
	push	OFFSET _torus_period_expr
	mov	DWORD PTR [ecx+24], ebx
	call	_memset

; 376  :   memset(torus_display_period_expr,0,sizeof(torus_display_period_expr));

	push	3744					; 00000ea0H
	push	ebx
	push	OFFSET _torus_display_period_expr
	call	_memset

; 377  :   memset(view_transforms_unique_point,0,sizeof(REAL)*MAXCOORD);

	mov	edx, DWORD PTR _view_transforms_unique_point
	push	48					; 00000030H
	push	ebx
	push	edx
	call	_memset

; 378  :   view_transforms_unique_point_flag = 0;
; 379  :   zoom_number = 1;
; 380  :   web.zoom_v = NULLVERTEX;
; 381  :   web.zoom_radius = 99999.0;

	fld	QWORD PTR __real@40f869f000000000
	mov	eax, DWORD PTR _NULLVERTEX
	fstp	QWORD PTR _web+984
	mov	DWORD PTR _view_transforms_unique_point_flag, ebx
	mov	DWORD PTR _zoom_number, edi
	mov	DWORD PTR _web+976, eax

; 382  :   transform_count = 0;

	mov	DWORD PTR _transform_count, ebx

; 383  :   view_transforms = NULL;

	mov	DWORD PTR _view_transforms, ebx

; 384  :   set_view_transforms_global();

	call	_set_view_transforms_global

; 385  :   set_view_transform_generators_global();

	call	_set_view_transform_generators_global

; 386  :   transforms_flag = 1;
; 387  :   transform_expr[0] = '\0';
; 388  :   view_transform_det = NULL; 
; 389  :   transform_colors = NULL; /* special kludge so allocate... doesn't free */
; 390  :   allocate_transform_colors(0); 

	push	ebx
	mov	DWORD PTR _transforms_flag, edi
	mov	BYTE PTR _transform_expr, bl
	mov	DWORD PTR _view_transform_det, ebx
	mov	DWORD PTR _transform_colors, ebx
	call	_allocate_transform_colors

; 391  :   transform_gen_swap = NULL;

	mov	DWORD PTR _transform_gen_swap, ebx

; 392  :   transform_colors_flag = 0;

	mov	DWORD PTR _transform_colors_flag, ebx

; 393  :   vertex_normals = NULL;

	mov	DWORD PTR _vertex_normals, ebx

; 394  :   conical_x = NULL;

	mov	DWORD PTR _conical_x, ebx

; 395  :   conical_w = NULL;

	mov	DWORD PTR _conical_w, ebx

; 396  :   for ( j = 0 ; j < NUMELEMENTS ; j++ ) el_list[j] = NULL;

	mov	DWORD PTR _el_list, ebx
	mov	DWORD PTR _el_list+4, ebx
	mov	DWORD PTR _el_list+8, ebx
	mov	DWORD PTR _el_list+12, ebx
	mov	DWORD PTR _el_list+16, ebx

; 397  :   v_procnum = NULL;

	mov	DWORD PTR _v_procnum, ebx

; 398  :   phase_flag = 0;

	mov	DWORD PTR _phase_flag, ebx

; 399  :   metric_convert_flag = 0;

	mov	DWORD PTR _metric_convert_flag, ebx

; 400  :   end_geomview_object();

	call	_end_geomview_object

; 401  :   end_normal_motion();

	call	_end_normal_motion

; 402  :   userfunc_init();

	call	_userfunc_init

; 403  :   for ( j = 0 ; j < NUMELEMENTS ; j++ )
; 404  :   {
; 405  :     show_expr[j] = NULL;
; 406  :   }
; 407  :   memset((char*)show_expr_table,0,sizeof(show_expr_table));

	push	520					; 00000208H
	push	ebx
	push	OFFSET _show_expr_table
	mov	DWORD PTR _show_expr, ebx
	mov	DWORD PTR _show_expr+4, ebx
	mov	DWORD PTR _show_expr+8, ebx
	mov	DWORD PTR _show_expr+12, ebx
	mov	DWORD PTR _show_expr+16, ebx
	call	_memset

; 408  :   memset((char*)single_redefine,0,128*sizeof(struct expnode));

	push	13312					; 00003400H
	push	ebx
	push	OFFSET _single_redefine
	call	_memset
	add	esp, 64					; 00000040H

; 409  :   gauss1Dwt = NULL;

	mov	DWORD PTR _gauss1Dwt, ebx

; 410  :   gauss1Dpt = NULL;

	mov	DWORD PTR _gauss1Dpt, ebx

; 411  :   gauss1poly = NULL; 

	mov	DWORD PTR _gauss1poly, ebx

; 412  :   gauss1polyd = NULL; 

	mov	DWORD PTR _gauss1polyd, ebx

; 413  :   gpoly = NULL; 

	mov	DWORD PTR _gpoly, ebx

; 414  :   gpolypartial = NULL; 

	mov	DWORD PTR _gpolypartial, ebx

; 415  : 
; 416  :   expand_global_hash();  /* to get permanent variables on board */

	call	_expand_global_hash

; 417  : 
; 418  :   /* just in case no surface read in, can take commands */
; 419  :   { int sdim = SDIM;

	mov	ecx, DWORD PTR _web+616

; 420  :     expand_attribute(VERTEX,V_COORD_ATTR,&sdim);

	lea	edx, DWORD PTR _sdim$89464[ebp]
	push	edx
	push	ebx
	push	ebx
	mov	DWORD PTR _sdim$89464[ebp], ecx
	call	_expand_attribute

; 421  :     expand_attribute(VERTEX,V_OLDCOORD_ATTR,&sdim);

	lea	eax, DWORD PTR _sdim$89464[ebp]
	push	eax
	push	edi
	push	ebx
	call	_expand_attribute

; 422  :     expand_attribute(VERTEX,V_FORCE_ATTR,&sdim);

	lea	ecx, DWORD PTR _sdim$89464[ebp]
	push	ecx
	push	3
	push	ebx
	call	_expand_attribute

; 423  :     expand_attribute(VERTEX,V_VELOCITY_ATTR,&sdim);

	lea	edx, DWORD PTR _sdim$89464[ebp]
	push	edx
	push	4
	push	ebx
	call	_expand_attribute

; 424  :     expand_attribute(EDGE,E_VERTICES_ATTR,&web.skel[EDGE].ctrlpts);

	push	OFFSET _web+120
	push	edi
	push	edi
	call	_expand_attribute

; 425  :     expand_attribute(FACET,F_VERTICES_ATTR,&web.skel[FACET].ctrlpts);

	push	OFFSET _web+232
	push	edi
	push	esi
	call	_expand_attribute
	add	esp, 72					; 00000048H

; 426  :   }
; 427  : 
; 428  :   warnings_suppressed_count = 0;

	mov	DWORD PTR _warnings_suppressed_count, ebx

; 429  :   reset_counts();

	call	_reset_counts
	pop	edi
	pop	esi
	pop	ebx

; 430  : } // end reset_web()

	mov	esp, ebp
	pop	ebp
	ret	0
_reset_web ENDP
_TEXT	ENDS
PUBLIC	_read_single_value
EXTRN	_get_ordinal_id:PROC
EXTRN	_yylval:BYTE
EXTRN	_unput_tok:PROC
EXTRN	_yytext:DWORD
EXTRN	_kb_yylex:PROC
EXTRN	_tok:DWORD
EXTRN	_read_const:PROC
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Ogtp
;	COMDAT _read_single_value
_TEXT	SEGMENT
tv442 = -8						; size = 8
_val$ = -8						; size = 8
tv489 = -4						; size = 4
tv487 = -4						; size = 4
tv466 = -4						; size = 4
tv464 = -4						; size = 4
tv444 = -4						; size = 4
_type$ = 8						; size = 4
tv492 = 10						; size = 2
tv469 = 10						; size = 2
tv447 = 10						; size = 2
_dest$ = 12						; size = 4
_read_single_value PROC					; COMDAT

; 1844 : { REAL val;

	push	ebp
	mov	ebp, esp

; 1845 : 
; 1846 :         switch (type )

	mov	eax, DWORD PTR _type$[ebp]
	dec	eax
	sub	esp, 8
	cmp	eax, 22					; 00000016H
	ja	SHORT $LN84@read_singl
	jmp	DWORD PTR $LN97@read_singl[eax*4]
$LN83@read_singl:

; 1847 :         { 
; 1848 :           case CHAR_TYPE : 
; 1849 :                 if ( read_const(&val) >= 0 )

	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_read_const
	add	esp, 4
	test	eax, eax
	js	$LN82@read_singl

; 1850 :                   *(char*)dest = (char)val; 

	fld	QWORD PTR _val$[ebp]
	call	__ftol2_sse

; 1855 :                   *(unsigned char*)dest = (unsigned char)val; 

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	BYTE PTR [ecx], al
$LN84@read_singl:

; 2007 : 
; 2008 :         } 
; 2009 :   return 1;

	mov	eax, 1

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN80@read_singl:

; 1851 :                 else return 0;
; 1852 :                 break;
; 1853 :           case UCHAR_TYPE : 
; 1854 :                 if ( read_const(&val) >= 0 )

	lea	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	js	$LN82@read_singl

; 1855 :                   *(unsigned char*)dest = (unsigned char)val; 

	fld	QWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	fnstcw	WORD PTR tv492[ebp]
	movzx	eax, WORD PTR tv492[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv489[ebp], eax
	fldcw	WORD PTR tv489[ebp]
	fistp	DWORD PTR tv487[ebp]
	mov	al, BYTE PTR tv487[ebp]
	mov	BYTE PTR [ecx], al

; 2007 : 
; 2008 :         } 
; 2009 :   return 1;

	mov	eax, 1
	fldcw	WORD PTR tv492[ebp]

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN77@read_singl:

; 1856 :                 else return 0;
; 1857 :                 break;
; 1858 :           case SHORT_TYPE : 
; 1859 :                 if ( read_const(&val) >= 0 )

	lea	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	js	$LN82@read_singl

; 1860 :                   *(short*)dest = (short)val; 

	fld	QWORD PTR _val$[ebp]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [ecx], ax

; 2007 : 
; 2008 :         } 
; 2009 :   return 1;

	mov	eax, 1

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@read_singl:

; 1861 :                 else return 0;
; 1862 :                 break;
; 1863 :           case USHORT_TYPE : 
; 1864 :                 if ( read_const(&val) >= 0 )

	lea	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	js	$LN82@read_singl

; 1865 :                   *(unsigned short*)dest = (unsigned short)val; 

	fld	QWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	fnstcw	WORD PTR tv469[ebp]
	movzx	eax, WORD PTR tv469[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv466[ebp], eax
	fldcw	WORD PTR tv466[ebp]
	fistp	DWORD PTR tv464[ebp]
	mov	ax, WORD PTR tv464[ebp]
	mov	WORD PTR [ecx], ax

; 2007 : 
; 2008 :         } 
; 2009 :   return 1;

	mov	eax, 1
	fldcw	WORD PTR tv469[ebp]

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@read_singl:

; 1866 :                 else return 0;
; 1867 :                 break;
; 1868 :           case INTEGER_TYPE : 
; 1869 :                 if ( read_const(&val) >= 0 )

	lea	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	js	$LN82@read_singl

; 1870 :                    *(int*)dest = (int)val; 

	fld	QWORD PTR _val$[ebp]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [ecx], eax

; 2007 : 
; 2008 :         } 
; 2009 :   return 1;

	mov	eax, 1

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN68@read_singl:

; 1871 :                 else return 0;
; 1872 :                 break;
; 1873 :           case REAL_TYPE : 
; 1874 :                 if ( read_const(&val) >= 0 )

	lea	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	js	$LN82@read_singl

; 1875 :                    *(REAL*)dest = val; 

	mov	eax, DWORD PTR _dest$[ebp]
	fld	QWORD PTR _val$[ebp]
	fstp	QWORD PTR [eax]

; 2007 : 
; 2008 :         } 
; 2009 :   return 1;

	mov	eax, 1

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@read_singl:

; 1876 :                 else return 0;
; 1877 :                 break;
; 1878 :           case ULONG_TYPE : 
; 1879 :                 if ( read_const(&val) >= 0 )

	lea	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_read_const
	add	esp, 4
	test	eax, eax
	js	$LN82@read_singl

; 1880 :                    *((unsigned long *)dest) = (unsigned long)val;

	fld	QWORD PTR _val$[ebp]
	fnstcw	WORD PTR tv447[ebp]
	movzx	eax, WORD PTR tv447[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv444[ebp], eax
	mov	eax, DWORD PTR _dest$[ebp]
	fldcw	WORD PTR tv444[ebp]
	fistp	QWORD PTR tv442[ebp]
	mov	edx, DWORD PTR tv442[ebp]
	mov	DWORD PTR [eax], edx

; 2007 : 
; 2008 :         } 
; 2009 :   return 1;

	mov	eax, 1
	fldcw	WORD PTR tv447[ebp]

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@read_singl:

; 1881 :                 else return 0;
; 1882 :                 break;
; 1883 :           
; 1884 :           case STRING_TYPE:
; 1885 :                 if ( tok == '{' || tok == ',') tok = yylex();

	mov	eax, DWORD PTR _tok
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN60@read_singl
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN61@read_singl
$LN60@read_singl:
	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN61@read_singl:

; 1886 :                 if ( tok == QUOTATION_TOK )

	cmp	eax, 309				; 00000135H
	jne	$LN82@read_singl

; 1887 :                 { *(char**)dest = mycalloc(strlen(yytext)+1,sizeof(char));

	mov	eax, DWORD PTR _yytext
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL90@read_singl:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL90@read_singl
	push	1887					; 0000075fH
	sub	eax, edx
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	inc	eax
	push	1
	push	eax
	call	_kb_calloc
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [ecx], eax

; 1888 :                   strcpy(*(char**)dest,yytext);

	mov	ecx, DWORD PTR _yytext
	add	esp, 16					; 00000010H
	mov	edx, eax
	npad	4
$LL88@read_singl:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL88@read_singl

; 1889 :                   tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1890 :                   if ( tok != ',' ) 

	cmp	eax, 44					; 0000002cH
	je	$LN84@read_singl

; 1891 :                     unput_tok();  // kludgy, I know

	call	_unput_tok

; 2007 : 
; 2008 :         } 
; 2009 :   return 1;

	mov	eax, 1

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@read_singl:

; 1892 :                 }
; 1893 :                 else return 0;
; 1894 :                 break;
; 1895 : 
; 1896 :           case ELEMENTID_TYPE:
; 1897 :                   return 0;
; 1898 :           case VERTEX_TYPE:
; 1899 :                if ( tok != VERTICES_TOK ) return 0;

	cmp	DWORD PTR _tok, 293			; 00000125H
	jne	SHORT $LN82@read_singl

; 1900 :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1901 :                if ( tok != '[' ) return 0;

	cmp	eax, 91					; 0000005bH
	jne	SHORT $LN82@read_singl

; 1902 :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1903 :                if ( (tok != INTEGER_TOK) && (tok != INTEGER_AT_TOK) ) return 0;

	cmp	eax, 265				; 00000109H
	je	SHORT $LN52@read_singl
	cmp	eax, 550				; 00000226H
	jne	SHORT $LN82@read_singl
$LN52@read_singl:

; 1904 :                *(element_id*)dest = get_ordinal_id(VERTEX,yylval.i);

	mov	edx, DWORD PTR _yylval
	push	edx
	push	0
	call	_get_ordinal_id
	mov	ecx, DWORD PTR _dest$[ebp]

; 1905 :                tok = yylex();

	push	0
	mov	DWORD PTR [ecx], eax
	call	_kb_yylex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax

; 1906 :                if ( tok != ']' ) return 0;

	cmp	eax, 93					; 0000005dH
	je	$LN84@read_singl
$LN82@read_singl:
	xor	eax, eax

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@read_singl:

; 1907 :                break;
; 1908 :                 
; 1909 :           case EDGE_TYPE:
; 1910 :                if ( tok != EDGES_TOK ) return 0;

	cmp	DWORD PTR _tok, 294			; 00000126H
	jne	SHORT $LN82@read_singl

; 1911 :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1912 :                if ( tok != '[' ) return 0;

	cmp	eax, 91					; 0000005bH
	jne	SHORT $LN82@read_singl

; 1913 :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1914 :                if ( (tok != INTEGER_TOK) && (tok != INTEGER_AT_TOK) ) return 0;

	cmp	eax, 265				; 00000109H
	je	SHORT $LN47@read_singl
	cmp	eax, 550				; 00000226H
	jne	SHORT $LN82@read_singl
$LN47@read_singl:

; 1915 :                *(element_id*)dest = get_ordinal_id(EDGE,yylval.i);

	mov	edx, DWORD PTR _yylval
	push	edx
	push	1
	call	_get_ordinal_id
	mov	ecx, DWORD PTR _dest$[ebp]

; 1916 :                tok = yylex();

	push	0
	mov	DWORD PTR [ecx], eax
	call	_kb_yylex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax

; 1917 :                if ( tok != ']' ) return 0;

	cmp	eax, 93					; 0000005dH
	je	$LN84@read_singl
	xor	eax, eax

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@read_singl:

; 1918 :                break;
; 1919 :                 
; 1920 :           case FACET_TYPE:
; 1921 :                if ( tok != FACETS_TOK ) return 0;

	cmp	DWORD PTR _tok, 295			; 00000127H
	jne	SHORT $LN82@read_singl

; 1922 :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1923 :                if ( tok != '[' ) return 0;

	cmp	eax, 91					; 0000005bH
	jne	$LN82@read_singl

; 1924 :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1925 :                if ( (tok != INTEGER_TOK) && (tok != INTEGER_AT_TOK) ) return 0;

	cmp	eax, 265				; 00000109H
	je	SHORT $LN42@read_singl
	cmp	eax, 550				; 00000226H
	jne	$LN82@read_singl
$LN42@read_singl:

; 1926 :                *(element_id*)dest = get_ordinal_id(FACET,yylval.i);

	mov	edx, DWORD PTR _yylval
	push	edx
	push	2
	call	_get_ordinal_id
	mov	ecx, DWORD PTR _dest$[ebp]

; 1927 :                tok = yylex();

	push	0
	mov	DWORD PTR [ecx], eax
	call	_kb_yylex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax

; 1928 :                if ( tok != ']' ) return 0;

	cmp	eax, 93					; 0000005dH
	je	$LN84@read_singl
	xor	eax, eax

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@read_singl:

; 1929 :                break;
; 1930 :                 
; 1931 :           case BODY_TYPE:
; 1932 :                if ( tok != BODIES_TOK ) return 0;

	cmp	DWORD PTR _tok, 296			; 00000128H
	jne	$LN82@read_singl

; 1933 :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1934 :                if ( tok != '[' ) return 0;

	cmp	eax, 91					; 0000005bH
	jne	$LN82@read_singl

; 1935 :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1936 :                if ( (tok != INTEGER_TOK) && (tok != INTEGER_AT_TOK) ) return 0;

	cmp	eax, 265				; 00000109H
	je	SHORT $LN37@read_singl
	cmp	eax, 550				; 00000226H
	jne	$LN82@read_singl
$LN37@read_singl:

; 1937 :                *(element_id*)dest = get_ordinal_id(BODY,yylval.i);

	mov	edx, DWORD PTR _yylval
	push	edx
	push	3
	call	_get_ordinal_id
	mov	ecx, DWORD PTR _dest$[ebp]

; 1938 :                tok = yylex();

	push	0
	mov	DWORD PTR [ecx], eax
	call	_kb_yylex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax

; 1939 :                if ( tok != ']' ) return 0;

	cmp	eax, 93					; 0000005dH
	je	$LN84@read_singl
	xor	eax, eax

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@read_singl:

; 1940 :                break;
; 1941 :                 
; 1942 :           case FACETEDGE_TYPE:
; 1943 :                if ( tok != FACETEDGES_TOK ) return 0;

	cmp	DWORD PTR _tok, 307			; 00000133H
	jne	$LN82@read_singl

; 1944 :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1945 :                if ( tok != '[' ) return 0;

	cmp	eax, 91					; 0000005bH
	jne	$LN82@read_singl

; 1946 :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1947 :                if ( (tok != INTEGER_TOK) && (tok != INTEGER_AT_TOK) ) return 0;

	cmp	eax, 265				; 00000109H
	je	SHORT $LN32@read_singl
	cmp	eax, 550				; 00000226H
	jne	$LN82@read_singl
$LN32@read_singl:

; 1948 :                *(element_id*)dest = get_ordinal_id(FACETEDGE,yylval.i);

	mov	edx, DWORD PTR _yylval
	push	edx
	push	4
	call	_get_ordinal_id
	mov	ecx, DWORD PTR _dest$[ebp]

; 1949 :                tok = yylex();

	push	0
	mov	DWORD PTR [ecx], eax
	call	_kb_yylex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax

; 1950 :                if ( tok != ']' ) return 0;

	cmp	eax, 93					; 0000005dH
	je	$LN84@read_singl
	xor	eax, eax

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@read_singl:

; 1951 :                break;
; 1952 :                 
; 1953 :           case CONSTRAINT_TYPE:
; 1954 :                if ( tok == CONSTRAINT_TOK )

	mov	eax, DWORD PTR _tok
	cmp	eax, 320				; 00000140H
	jne	SHORT $LN29@read_singl

; 1955 :                { tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1956 :                  if ( tok == INTEGER_TOK )

	cmp	eax, 265				; 00000109H

; 1957 :                    *(int *)dest = yylval.i;

	je	SHORT $LN92@read_singl

; 1958 :                  else if ( tok == CONSTRAINT_NAME_TOK ) 

	cmp	eax, 519				; 00000207H

; 1959 :                    *(int *)dest = yylval.i;
; 1960 :                  else return 0;
; 1961 :                }
; 1962 :                else

	jmp	$LN95@read_singl
$LN29@read_singl:

; 1963 :                { if ( tok == CONSTRAINT_NAME_TOK ) 

	cmp	eax, 519				; 00000207H
$LN96@read_singl:
	jne	$LN82@read_singl

; 1964 :                    *(int *)dest = yylval.i;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _yylval
	mov	DWORD PTR [eax], ecx

; 2007 : 
; 2008 :         } 
; 2009 :   return 1;

	mov	eax, 1

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@read_singl:

; 1965 :                  else return 0;
; 1966 :                }
; 1967 :                break;
; 1968 :           case BOUNDARY_TYPE: 
; 1969 :                if ( tok == BOUNDARY_TOK )

	mov	eax, DWORD PTR _tok
	cmp	eax, 408				; 00000198H
	jne	SHORT $LN20@read_singl

; 1970 :                { tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1971 :                  if ( tok == INTEGER_TOK )

	cmp	eax, 265				; 00000109H

; 1972 :                    *(int *)dest = yylval.i;

	je	SHORT $LN92@read_singl

; 1973 :                  else if ( tok == BOUNDARY_NAME_TOK ) 

	cmp	eax, 520				; 00000208H

; 1974 :                    *(int *)dest = yylval.i;
; 1975 :                  else return 0;
; 1976 :                }
; 1977 :                else

	jmp	SHORT $LN95@read_singl
$LN20@read_singl:

; 1978 :                { if ( tok == BOUNDARY_NAME_TOK ) 

	cmp	eax, 520				; 00000208H

; 1979 :                    *(int *)dest = yylval.i;
; 1980 :                  else return 0;
; 1981 :                }
; 1982 :                break;

	jmp	SHORT $LN96@read_singl
$LN12@read_singl:

; 1983 : 
; 1984 :           case QUANTITY_TYPE:
; 1985 :                if ( tok == QUANTITY_TOK )

	mov	eax, DWORD PTR _tok
	cmp	eax, 482				; 000001e2H
	jne	SHORT $LN11@read_singl

; 1986 :                  tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN11@read_singl:

; 1987 :                if ( tok == QUANTITY_NAME_TOK ) 

	cmp	eax, 336				; 00000150H
	jne	$LN82@read_singl
$LN92@read_singl:

; 1988 :                  *(int *)dest = yylval.i;

	mov	eax, DWORD PTR _yylval
	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [edx], eax

; 2007 : 
; 2008 :         } 
; 2009 :   return 1;

	mov	eax, 1

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@read_singl:

; 1989 :                else return 0;
; 1990 :                break;
; 1991 : 
; 1992 :           case INSTANCE_TYPE:
; 1993 :                if ( tok == METHOD_INSTANCE_TOK )

	mov	eax, DWORD PTR _tok
	cmp	eax, 491				; 000001ebH
	jne	SHORT $LN7@read_singl

; 1994 :                  tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN7@read_singl:

; 1995 :                if ( tok == METHOD_NAME_TOK ) 

	cmp	eax, 414				; 0000019eH
$LN95@read_singl:
	jne	$LN82@read_singl

; 1996 :                  *(int *)dest = yylval.i;

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _yylval
	mov	DWORD PTR [ecx], edx

; 2007 : 
; 2008 :         } 
; 2009 :   return 1;

	mov	eax, 1

; 2010 : } // end read_single_value()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@read_singl:

; 1997 :                else return 0;
; 1998 :                break;
; 1999 : 
; 2000 :           case PROCEDURE_TYPE:
; 2001 :                if ( tok == PROCEDURE_WORD_TOK )

	mov	eax, DWORD PTR _tok
	cmp	eax, 485				; 000001e5H
	jne	SHORT $LN3@read_singl

; 2002 :                  tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN3@read_singl:

; 2003 :                if ( tok == PROCEDURE_IDENT_TOK ) 

	cmp	eax, 521				; 00000209H

; 2004 :                  *(int *)dest = yylval.i;
; 2005 :                else return 0;
; 2006 :                break;

	jmp	$LN96@read_singl
	npad	3
$LN97@read_singl:

; 2010 : } // end read_single_value()

	DD	$LN68@read_singl
	DD	$LN71@read_singl
	DD	$LN65@read_singl
	DD	$LN80@read_singl
	DD	$LN74@read_singl
	DD	$LN84@read_singl
	DD	$LN84@read_singl
	DD	$LN83@read_singl
	DD	$LN77@read_singl
	DD	$LN84@read_singl
	DD	$LN62@read_singl
	DD	$LN84@read_singl
	DD	$LN55@read_singl
	DD	$LN50@read_singl
	DD	$LN45@read_singl
	DD	$LN40@read_singl
	DD	$LN35@read_singl
	DD	$LN82@read_singl
	DD	$LN21@read_singl
	DD	$LN30@read_singl
	DD	$LN12@read_singl
	DD	$LN8@read_singl
	DD	$LN4@read_singl
_read_single_value ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@ECCJKJJA@Too?5many?5initializers?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DC@JPOKFPEK@Illegal?5token?5in?5initialization?5@ ; `string'
PUBLIC	??_C@_0CJ@PBJANMJM@Too?5many?5initializers?5for?5attrib@ ; `string'
PUBLIC	??_C@_0CB@GHOBBEEK@missing?5value?5for?5attribute?5?$CFs?4?6@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_read_attribute_value
EXTRN	_unput_tok_count:DWORD
EXTRN	_kb_error:PROC
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0BI@ECCJKJJA@Too?5many?5initializers?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@ECCJKJJA@Too?5many?5initializers?4?6?$AA@ DB 'Too many initiali'
	DB	'zers.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@JPOKFPEK@Illegal?5token?5in?5initialization?5@
CONST	SEGMENT
??_C@_0DC@JPOKFPEK@Illegal?5token?5in?5initialization?5@ DB 'Illegal toke'
	DB	'n in initialization of attribute %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PBJANMJM@Too?5many?5initializers?5for?5attrib@
CONST	SEGMENT
??_C@_0CJ@PBJANMJM@Too?5many?5initializers?5for?5attrib@ DB 'Too many ini'
	DB	'tializers for attribute %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GHOBBEEK@missing?5value?5for?5attribute?5?$CFs?4?6@
CONST	SEGMENT
??_C@_0CB@GHOBBEEK@missing?5value?5for?5attribute?5?$CFs?4?6@ DB 'missing'
	DB	' value for attribute %s.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_attribute_value
_TEXT	SEGMENT
_spots$ = -92						; size = 32
_first_bracket_flag$ = -60				; size = 4
_no_first_bracket$ = -56				; size = 4
_blocksize$ = -52					; size = 4
_spot$ = -48						; size = 4
tv487 = -44						; size = 4
tv489 = -40						; size = 4
_items$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_ex$ = 8						; size = 4
_datastart$ = 12					; size = 4
_read_attribute_value PROC				; COMDAT

; 2023 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _datastart$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _ex$[ebp]

; 2024 :     char *spot;
; 2025 :     int depth;
; 2026 :     int blocksize;
; 2027 :     char *spots[MAXARRAYDIMS];
; 2028 :     int items[MAXARRAYDIMS];
; 2029 :     int first_bracket_flag = 0; /* whether seen first bracket, 

	xor	ebx, ebx
	push	edi

; 2030 :                                    which is optional for 1 dim attribute */
; 2031 :     int no_first_bracket = 0;  /* record option */
; 2032 : 
; 2033 :     depth = 0;

	xor	edi, edi
	mov	DWORD PTR _first_bracket_flag$[ebp], ebx
	mov	DWORD PTR _no_first_bracket$[ebp], ebx

; 2034 :     spot = datastart;

	mov	DWORD PTR _spot$[ebp], eax

; 2035 :     if ( ex->array_spec.dim == 0 ) /* scalar */

	cmp	DWORD PTR [esi+76], ebx
	jne	SHORT $LN31@read_attri

; 2036 :     { if ( !read_single_value(ex->type,spot) )

	push	eax
	mov	eax, DWORD PTR [esi+68]
	push	eax
	call	_read_single_value
	add	esp, 8
	test	eax, eax
	jne	$LN30@read_attri

; 2037 :       { sprintf(errmsg,"missing value for attribute %s.\n",ex->name);

	push	esi
	push	OFFSET ??_C@_0CB@GHOBBEEK@missing?5value?5for?5attribute?5?$CFs?4?6@
	push	OFFSET _errmsg
	call	_sprintf

; 2038 :         kb_error(2587,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	2587					; 00000a1bH
	call	_kb_error
	add	esp, 24					; 00000018H

; 2039 :       }
; 2040 :       tok = yylex();  /* get lookahead */
; 2041 :       return;

	jmp	$LN30@read_attri
$LN31@read_attri:

; 2044 :     items[depth] = 0;
; 2045 :     blocksize = ex->array_spec.datacount;

	mov	ecx, DWORD PTR [esi+88]
	mov	DWORD PTR _spots$[ebp], eax
	lea	edx, DWORD PTR [esi+92]
	lea	eax, DWORD PTR [esi+96]
	mov	DWORD PTR _items$[ebp], ebx
	mov	DWORD PTR _blocksize$[ebp], ecx
	mov	DWORD PTR tv487[ebp], edx
	mov	DWORD PTR tv489[ebp], eax
$LN49@read_attri:

; 2042 :     }
; 2043 :     spots[depth] = spot;

	mov	ecx, DWORD PTR _tok
$LL29@read_attri:

; 2046 :     for (;;)
; 2047 :     { 
; 2048 :       if ( depth == ex->array_spec.dim )

	cmp	edi, DWORD PTR [esi+76]
	jne	$LN43@read_attri
$LN51@read_attri:

; 2051 :         { /* kludge with LEAD_INTEGER_ here */
; 2052 :           if ( tok != LEAD_INTEGER_TOK )

	cmp	ecx, 264				; 00000108H
	je	SHORT $LN43@read_attri
$LL42@read_attri:

; 2053 :           { 
; 2054 :             if ( read_single_value(ex->type,spot) )

	mov	ecx, DWORD PTR _spot$[ebp]
	mov	edx, DWORD PTR [esi+68]
	push	ecx
	push	edx
	call	_read_single_value
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@read_attri

; 2055 :             { if ( k < ex->array_spec.sizes[depth-1] ) 

	mov	eax, DWORD PTR tv487[ebp]
	cmp	ebx, DWORD PTR [eax]
	jge	SHORT $LN21@read_attri

; 2056 :                 spot += ex->array_spec.itemsize;

	mov	ecx, DWORD PTR [esi+84]
	add	DWORD PTR _spot$[ebp], ecx

; 2057 :               else

	mov	ecx, DWORD PTR _tok
	jmp	SHORT $LN25@read_attri
$LN21@read_attri:

; 2058 :               { sprintf(errmsg, "Too many initializers for attribute %s.\n",
; 2059 :                     ex->name);

	push	esi
	push	OFFSET ??_C@_0CJ@PBJANMJM@Too?5many?5initializers?5for?5attrib@
	push	OFFSET _errmsg
	call	_sprintf

; 2060 :                 kb_error(2511,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	2511					; 000009cfH
	call	_kb_error

; 2061 :               }
; 2062 :             }
; 2063 :             else

	mov	ecx, DWORD PTR _tok
	add	esp, 24					; 00000018H
	jmp	SHORT $LN25@read_attri
$LN22@read_attri:

; 2064 :             { tok = yylex();  /* get back token exparse pushed back */

	push	0
	call	_kb_yylex
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _tok, ecx

; 2065 :               if ( tok != ',' ) 

	cmp	ecx, 44					; 0000002cH
	jne	SHORT $LN43@read_attri
$LN25@read_attri:

; 2049 :       { int k;
; 2050 :         for ( k = 0 ; ; k++ )

	inc	ebx

; 2051 :         { /* kludge with LEAD_INTEGER_ here */
; 2052 :           if ( tok != LEAD_INTEGER_TOK )

	cmp	ecx, 264				; 00000108H
	jne	SHORT $LL42@read_attri
$LN43@read_attri:

; 2066 :                 break;
; 2067 :             }
; 2068 :           }
; 2069 :           else break;
; 2070 :         }
; 2071 :       }
; 2072 :       if ( !first_bracket_flag ) tok = yylex();

	xor	ebx, ebx
	cmp	DWORD PTR _first_bracket_flag$[ebp], ebx
	jne	SHORT $LN16@read_attri
	push	ebx
	call	_kb_yylex
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _tok, ecx
$LN16@read_attri:

; 2073 :       if ( (tok == '{') || !first_bracket_flag )  

	cmp	ecx, 123				; 0000007bH
	je	$LN47@read_attri
	cmp	DWORD PTR _first_bracket_flag$[ebp], ebx
	je	$LN14@read_attri

; 2085 :       }
; 2086 :       else if ( tok == '}' )

	cmp	ecx, 125				; 0000007dH
	jne	SHORT $LN8@read_attri

; 2087 :       { tok = yylex();

	push	ebx
	call	_kb_yylex
	mov	ecx, eax

; 2088 :         depth--;

	mov	eax, 4
	sub	DWORD PTR tv487[ebp], eax
	sub	DWORD PTR tv489[ebp], eax
	dec	edi
	add	esp, 4
	mov	DWORD PTR _tok, ecx

; 2089 :         if ( depth == 0 ) return;

	cmp	edi, ebx
	je	$LN2@read_attri

; 2090 : 
; 2091 :         blocksize *= ex->array_spec.sizes[depth];

	mov	edx, DWORD PTR tv489[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, DWORD PTR _blocksize$[ebp]

; 2092 :         spots[depth] += blocksize*ex->array_spec.itemsize;

	mov	edx, DWORD PTR [esi+84]
	imul	edx, eax
	add	DWORD PTR _spots$[ebp+edi*4], edx
	mov	DWORD PTR _blocksize$[ebp], eax
	mov	eax, DWORD PTR _spots$[ebp+edi*4]
	mov	DWORD PTR _spot$[ebp], eax

; 2093 :         spot = spots[depth];

	jmp	$LL29@read_attri
$LN8@read_attri:

; 2094 :       }
; 2095 :       else if ( tok == ',' )

	cmp	ecx, 44					; 0000002cH
	jne	SHORT $LN5@read_attri

; 2096 :       { tok = yylex();

	push	ebx
	call	_kb_yylex
	mov	ecx, eax
	mov	DWORD PTR _tok, ecx

; 2097 :         spots[depth] += blocksize*ex->array_spec.itemsize;

	mov	edx, DWORD PTR [esi+84]
	imul	edx, DWORD PTR _blocksize$[ebp]
	add	esp, 4
	add	DWORD PTR _spots$[ebp+edi*4], edx
	jmp	$LL29@read_attri
$LN5@read_attri:

; 2098 :       }
; 2099 :       else if ( no_first_bracket )

	cmp	DWORD PTR _no_first_bracket$[ebp], ebx
	jne	$LN39@read_attri

; 2103 :         return;
; 2104 :       }
; 2105 :       else
; 2106 :       { sprintf(errmsg,"Illegal token in initialization of attribute %s.\n",
; 2107 :               ex->name);

	push	esi
	push	OFFSET ??_C@_0DC@JPOKFPEK@Illegal?5token?5in?5initialization?5@
	push	OFFSET _errmsg
	call	_sprintf

; 2108 :         kb_error(2134,errmsg, DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	2134					; 00000856H
	call	_kb_error
	add	esp, 24					; 00000018H
	jmp	$LN49@read_attri
$LN14@read_attri:

; 2074 :       { if ( tok != '{' ) 
; 2075 :         { unput_tok(); no_first_bracket = 1; }

	call	_unput_tok
	mov	ecx, DWORD PTR _tok
	mov	DWORD PTR _no_first_bracket$[ebp], 1
$LN47@read_attri:

; 2076 :         first_bracket_flag = 1;
; 2077 :         if ( blocksize ) blocksize /= ex->array_spec.sizes[depth]; 

	mov	eax, DWORD PTR _blocksize$[ebp]
	mov	DWORD PTR _first_bracket_flag$[ebp], 1
	cmp	eax, ebx
	je	SHORT $LN12@read_attri
	mov	ebx, DWORD PTR tv489[ebp]
	cdq
	idiv	DWORD PTR [ebx]
	mov	DWORD PTR _blocksize$[ebp], eax
$LN12@read_attri:

; 2078 :         spots[depth] = spot;

	mov	eax, DWORD PTR _spot$[ebp]

; 2079 :         items[depth]++;

	inc	DWORD PTR _items$[ebp+edi*4]

; 2080 :         if ( (depth > 0) && (items[depth] > ex->array_spec.sizes[depth-1]) )

	xor	ebx, ebx
	mov	DWORD PTR _spots$[ebp+edi*4], eax
	mov	eax, DWORD PTR _items$[ebp+edi*4]
	cmp	edi, ebx
	jle	SHORT $LN48@read_attri
	mov	edx, DWORD PTR tv487[ebp]
	cmp	eax, DWORD PTR [edx]
	jle	SHORT $LN48@read_attri

; 2081 :            kb_error(2133,"Too many initializers.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BI@ECCJKJJA@Too?5many?5initializers?4?6?$AA@
	push	2133					; 00000855H
	call	_kb_error
	mov	ecx, DWORD PTR _tok
	add	esp, 12					; 0000000cH
$LN48@read_attri:

; 2082 :         depth++; 

	mov	eax, 4
	add	DWORD PTR tv487[ebp], eax
	add	DWORD PTR tv489[ebp], eax
	inc	edi

; 2083 :         items[depth] = 0;

	mov	DWORD PTR _items$[ebp+edi*4], ebx

; 2084 :         if ( (depth != ex->array_spec.dim) && !no_first_bracket ) tok = yylex();

	cmp	edi, DWORD PTR [esi+76]
	je	$LN51@read_attri
	cmp	DWORD PTR _no_first_bracket$[ebp], ebx
	jne	$LL29@read_attri
	push	ebx
	call	_kb_yylex
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _tok, ecx

; 2109 :       }
; 2110 :     }

	jmp	$LL29@read_attri
$LN39@read_attri:

; 2100 :       { /* must be end of 1-D attribute */
; 2101 :         if ( unput_tok_count )

	cmp	DWORD PTR _unput_tok_count, ebx
	je	SHORT $LN2@read_attri
$LN30@read_attri:

; 2102 :            tok = yylex();  /* get lookahead back */

	push	ebx
	call	_kb_yylex
	mov	DWORD PTR _tok, eax
	add	esp, 4
$LN2@read_attri:

; 2111 : } // end read_attribute_value()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_read_attribute_value ENDP
_TEXT	ENDS
PUBLIC	_read_extra
; Function compile flags: /Ogtp
;	COMDAT _read_extra
_TEXT	SEGMENT
_el_id$ = 8						; size = 4
_exnum$ = 12						; size = 4
_read_extra PROC					; COMDAT

; 2123 : { char *spot;

	push	ebp
	mov	ebp, esp

; 2124 :   int type = id_type(el_id);
; 2125 :   struct extra *ex = EXTRAS(type) + exnum;
; 2126 : 
; 2127 :   spot = get_extra(el_id,exnum);

	mov	ecx, DWORD PTR _el_id$[ebp]
	mov	edx, DWORD PTR _exnum$[ebp]
	mov	eax, ecx
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	push	esi
	mov	esi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	esi, edx
	mov	edx, DWORD PTR _dymem
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	ecx, DWORD PTR [edx+esi+64]
	add	edx, esi

; 2128 :   read_attribute_value(ex,spot);

	push	ecx
	push	edx
	call	_read_attribute_value
	add	esp, 8
	pop	esi

; 2129 : } // end read_extra()

	pop	ebp
	ret	0
_read_extra ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@COILCHG@Wrong?5number?5of?5coordinates?5for?5@ ; `string'
PUBLIC	??_C@_0CF@NGLIKJND@Cannot?5have?5constraint?5and?5bound@ ; `string'
PUBLIC	??_C@_0BG@BKFJJJKH@Unexpected?5token?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0DA@MGFNEFND@Internal?5error?3?5forgot?5to?5get?5lo@ ; `string'
PUBLIC	??_C@_0DB@GPFFHCHH@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5a?5ve@ ; `string'
PUBLIC	??_C@_0BP@MGOCAHJG@Missing?5method?5instance?5name?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CJ@CDBMMBKP@Bad?5constraint?5number?5?$CFd?5for?5ver@ ; `string'
PUBLIC	??_C@_0CL@CBHEBNEI@Wrong?5number?5of?5parameters?5for?5v@ ; `string'
PUBLIC	??_C@_0CH@EDLNKPMJ@Bad?5boundary?5number?5?$CFd?5for?5verte@ ; `string'
PUBLIC	??_C@_0BP@CEDOMNKL@Need?5boundary?5number?5or?5name?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@LOIAMNAG@Illegal?5use?5of?5identifier?5?8?$CFs?8?4?6@ ; `string'
PUBLIC	??_C@_0BF@EAMJGDOF@Need?5quantity?5name?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@NKBFEMPG@ORIGINAL?5number?5missing?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@OEEKDIKO@Duplicate?5vertex?5number?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@BHGPMMFN@Vertex?5number?5must?5be?5positive?4?6@ ; `string'
PUBLIC	??_C@_0CP@JIMMJMCP@Cannot?5find?5VERTICES?5section?5of?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_read_vertices
EXTRN	_project_v_constr:PROC
EXTRN	_eval:PROC
EXTRN	_typenames:BYTE
EXTRN	_apply_method_num:PROC
EXTRN	_set_v_constraint_map:PROC
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	_apply_quantity:PROC
EXTRN	_gettok:PROC
EXTRN	_set_v_global:PROC
EXTRN	_new_vertex:PROC
EXTRN	_move_to_free_front:PROC
EXTRN	_KB_realloc:PROC
;	COMDAT ??_C@_0CM@COILCHG@Wrong?5number?5of?5coordinates?5for?5@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CM@COILCHG@Wrong?5number?5of?5coordinates?5for?5@ DB 'Wrong number'
	DB	' of coordinates for vertex %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NGLIKJND@Cannot?5have?5constraint?5and?5bound@
CONST	SEGMENT
??_C@_0CF@NGLIKJND@Cannot?5have?5constraint?5and?5bound@ DB 'Cannot have '
	DB	'constraint and boundary.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BKFJJJKH@Unexpected?5token?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BG@BKFJJJKH@Unexpected?5token?3?5?$CFs?6?$AA@ DB 'Unexpected token'
	DB	': %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MGFNEFND@Internal?5error?3?5forgot?5to?5get?5lo@
CONST	SEGMENT
??_C@_0DA@MGFNEFND@Internal?5error?3?5forgot?5to?5get?5lo@ DB 'Internal e'
	DB	'rror: forgot to get lookahead token.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GPFFHCHH@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5a?5ve@
CONST	SEGMENT
??_C@_0DB@GPFFHCHH@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5a?5ve@ DB ''''
	DB	'%s'' is a %s attribute, not a vertex attribute.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MGOCAHJG@Missing?5method?5instance?5name?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@MGOCAHJG@Missing?5method?5instance?5name?4?6?$AA@ DB 'Missing m'
	DB	'ethod instance name.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CDBMMBKP@Bad?5constraint?5number?5?$CFd?5for?5ver@
CONST	SEGMENT
??_C@_0CJ@CDBMMBKP@Bad?5constraint?5number?5?$CFd?5for?5ver@ DB 'Bad cons'
	DB	'traint number %d for vertex %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CBHEBNEI@Wrong?5number?5of?5parameters?5for?5v@
CONST	SEGMENT
??_C@_0CL@CBHEBNEI@Wrong?5number?5of?5parameters?5for?5v@ DB 'Wrong numbe'
	DB	'r of parameters for vertex %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EDLNKPMJ@Bad?5boundary?5number?5?$CFd?5for?5verte@
CONST	SEGMENT
??_C@_0CH@EDLNKPMJ@Bad?5boundary?5number?5?$CFd?5for?5verte@ DB 'Bad boun'
	DB	'dary number %d for vertex %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CEDOMNKL@Need?5boundary?5number?5or?5name?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@CEDOMNKL@Need?5boundary?5number?5or?5name?4?6?$AA@ DB 'Need bou'
	DB	'ndary number or name.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LOIAMNAG@Illegal?5use?5of?5identifier?5?8?$CFs?8?4?6@
CONST	SEGMENT
??_C@_0CB@LOIAMNAG@Illegal?5use?5of?5identifier?5?8?$CFs?8?4?6@ DB 'Illeg'
	DB	'al use of identifier ''%s''.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EAMJGDOF@Need?5quantity?5name?4?6?$AA@
CONST	SEGMENT
??_C@_0BF@EAMJGDOF@Need?5quantity?5name?4?6?$AA@ DB 'Need quantity name.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NKBFEMPG@ORIGINAL?5number?5missing?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@NKBFEMPG@ORIGINAL?5number?5missing?4?6?$AA@ DB 'ORIGINAL number'
	DB	' missing.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OEEKDIKO@Duplicate?5vertex?5number?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BM@OEEKDIKO@Duplicate?5vertex?5number?5?$CFd?6?$AA@ DB 'Duplicate '
	DB	'vertex number %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BHGPMMFN@Vertex?5number?5must?5be?5positive?4?6@
CONST	SEGMENT
??_C@_0CB@BHGPMMFN@Vertex?5number?5must?5be?5positive?4?6@ DB 'Vertex num'
	DB	'ber must be positive.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JIMMJMCP@Cannot?5find?5VERTICES?5section?5of?5@
CONST	SEGMENT
??_C@_0CP@JIMMJMCP@Cannot?5find?5VERTICES?5section?5of?5@ DB 'Cannot find'
	DB	' VERTICES section of the datafile.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\lexinit.c
CONST	ENDS
;	COMDAT _read_vertices
_TEXT	SEGMENT
_x$90633 = -64						; size = 4
_sdim$ = -60						; size = 4
tv1962 = -56						; size = 4
_pcount$ = -56						; size = 4
_c$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_read_vertices PROC					; COMDAT

; 2139 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2140 :   int k;
; 2141 :   REAL c[MAXCOORD];  /* temporary number buffer */
; 2142 :   int cnum,bnum,pcount,qnum;
; 2143 :   struct boundary *bdry;
; 2144 :   struct constraint *constr;
; 2145 :   int more_attr;
; 2146 :   int sdim = SDIM;

	mov	eax, DWORD PTR _web+616

; 2147 : 
; 2148 :   /* allocate space in structures */
; 2149 :   EXTRAS(VERTEX)[V_NORMAL_ATTR].array_spec.sizes[0] = SDIM;

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	DWORD PTR _sdim$[ebp], eax
	mov	DWORD PTR [ecx+edx+1776], eax

; 2150 :   EXTRAS(VERTEX)[V_CONSTRAINT_NORMAL_ATTR].array_spec.sizes[0] = SDIM;

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	DWORD PTR [ecx+edx+2016], eax

; 2151 :   expand_attribute(VERTEX,V_COORD_ATTR,&sdim);

	lea	eax, DWORD PTR _sdim$[ebp]
	push	eax
	push	0
	push	0
	call	_expand_attribute

; 2152 :   expand_attribute(VERTEX,V_OLDCOORD_ATTR,&sdim);

	lea	ecx, DWORD PTR _sdim$[ebp]
	push	ecx
	push	1
	push	0
	call	_expand_attribute

; 2153 :   expand_attribute(VERTEX,V_FORCE_ATTR,&sdim);

	lea	edx, DWORD PTR _sdim$[ebp]
	push	edx
	push	3
	push	0
	call	_expand_attribute

; 2154 :   expand_attribute(VERTEX,V_VELOCITY_ATTR,&sdim);

	lea	eax, DWORD PTR _sdim$[ebp]
	push	eax
	push	4
	push	0
	call	_expand_attribute
	add	esp, 48					; 00000030H

; 2155 :   if ( web.maxparam > 0 )

	cmp	DWORD PTR _web+640, 0
	jle	SHORT $LN83@read_verti

; 2156 :   { expand_attribute(VERTEX,V_PARAM_ATTR,&web.maxparam);

	push	OFFSET _web+640
	push	2
	push	0
	call	_expand_attribute
	add	esp, 12					; 0000000cH
$LN83@read_verti:

; 2157 :   }
; 2158 : 
; 2159 :   /* read in vertex coordinates */
; 2160 :   vmaxlist = MAXLIST;
; 2161 :   vlist = (vertex_id *)mycalloc(sizeof(vertex_id),vmaxlist);

	push	2161					; 00000871H
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	push	100					; 00000064H
	push	4
	mov	DWORD PTR _vmaxlist, 100		; 00000064H
	call	_kb_calloc
	add	esp, 16					; 00000010H

; 2162 :   if ( tok != VERTICES_TOK  ) 

	cmp	DWORD PTR _tok, 293			; 00000125H
	mov	DWORD PTR _vlist, eax
	je	SHORT $LN82@read_verti

; 2163 :      kb_error(1115,"Cannot find VERTICES section of the datafile.\n",
; 2164 :           UNRECOVERABLE);

	push	0
	push	OFFSET ??_C@_0CP@JIMMJMCP@Cannot?5find?5VERTICES?5section?5of?5@
	push	1115					; 0000045bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN82@read_verti:

; 2165 : 
; 2166 :   tok = yylex();

	push	ebx
	push	esi
	push	edi
	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	npad	5
$LL167@read_verti:

; 2167 :   while ( (tok == LEAD_INTEGER_TOK) || (tok == LEAD_INTEGER_AT_TOK) )

	mov	eax, DWORD PTR _tok

; 2445 :     }

	mov	ebx, 512				; 00000200H
	cmp	eax, 264				; 00000108H
	je	SHORT $LN79@read_verti

; 2167 :   while ( (tok == LEAD_INTEGER_TOK) || (tok == LEAD_INTEGER_AT_TOK) )

	cmp	eax, 549				; 00000225H
	jne	$LN163@read_verti
$LN79@read_verti:

; 2168 :   { 
; 2169 :     #ifdef MPI_EVOLVER
; 2170 :     /* test task number, for MPI */
; 2171 :     int task;
; 2172 :     if ( tok == LEAD_INTEGER_TOK )
; 2173 :        task = 1;  /* default to task 1 */
; 2174 :     else task = yylval.qnum;
; 2175 :     if ( task >= mpi_nprocs || task < 1 )
; 2176 :     { sprintf(errmsg,"Task number %d must be between 1 and %d, %d\n",
; 2177 :          task,mpi_nprocs-1);
; 2178 :       kb_error(5006,errmsg,RECOVERABLE);
; 2179 :     }
; 2180 :     if ( task != this_task )
; 2181 :     { /* skip this vertex */
; 2182 :       int flag = 0;
; 2183 :       while ( !flag ) 
; 2184 :       { tok = yylex();
; 2185 :         switch (tok)
; 2186 :         { case LEAD_INTEGER_TOK: 
; 2187 :           case LEAD_INTEGER_AT_TOK:
; 2188 :           case EDGES_TOK:
; 2189 :           case FACES_TOK:
; 2190 :           case BODIES_TOK:
; 2191 :           case READ_TOK:
; 2192 :           case 0:
; 2193 :             flag = 1;
; 2194 :             break;
; 2195 :         }
; 2196 :       }
; 2197 :       continue;  /* next vertex */
; 2198 :     }
; 2199 :     #endif
; 2200 :    
; 2201 :     k = yylval.i;

	mov	esi, DWORD PTR _yylval

; 2202 :     if ( k < 1 ) 

	cmp	esi, 1
	jge	SHORT $LN78@read_verti

; 2203 :        kb_error(2103,"Vertex number must be positive.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CB@BHGPMMFN@Vertex?5number?5must?5be?5positive?4?6@
	push	2103					; 00000837H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN78@read_verti:

; 2204 :     for ( pcount = 0 ; pcount < SDIM ; pcount++ )

	cmp	DWORD PTR _web+616, 0
	mov	DWORD PTR _pcount$[ebp], 0
	jle	SHORT $LN168@read_verti
	lea	edi, DWORD PTR _c$[ebp]
	npad	2
$LL178@read_verti:

; 2205 :     { if ( read_const(&c[pcount]) <= 0 ) break;

	push	edi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN168@read_verti

; 2206 :       if ( (tok == LEAD_INTEGER_TOK) || (tok == LEAD_INTEGER_AT_TOK) ) 

	mov	eax, DWORD PTR _tok
	cmp	eax, 264				; 00000108H
	je	SHORT $LN143@read_verti
	cmp	eax, 549				; 00000225H
	je	SHORT $LN143@read_verti

; 2204 :     for ( pcount = 0 ; pcount < SDIM ; pcount++ )

	mov	eax, DWORD PTR _pcount$[ebp]
	inc	eax
	add	edi, 8
	mov	DWORD PTR _pcount$[ebp], eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL178@read_verti

; 2386 :                  if ( (cnum >= web.maxcon) || !(constr->attr & IN_USE) )

	jmp	SHORT $LN168@read_verti
$LN143@read_verti:

; 2207 :       { pcount++; break; }

	inc	DWORD PTR _pcount$[ebp]
$LN168@read_verti:

; 2208 :     }
; 2209 :     tok = yylex(); /* get lookahead */

	push	0
	call	_kb_yylex
	mov	DWORD PTR _tok, eax

; 2210 : 
; 2211 : 
; 2212 :     if ( k >= vmaxlist )

	mov	eax, DWORD PTR _vmaxlist
	add	esp, 4
	cmp	esi, eax
	jl	SHORT $LN165@read_verti

; 2213 :     { int spot = vmaxlist; 

	mov	edi, eax
$LL70@read_verti:

; 2214 :       while ( k >= vmaxlist )
; 2215 :         vmaxlist *= 2;

	add	eax, eax
	cmp	esi, eax
	jge	SHORT $LL70@read_verti

; 2216 :       vlist = (vertex_id *)kb_realloc((char *)vlist,
; 2217 :                vmaxlist*sizeof(vertex_id));

	mov	edx, DWORD PTR _vlist
	push	2217					; 000008a9H
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	push	edx
	mov	DWORD PTR _vmaxlist, eax
	call	_KB_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vlist, eax

; 2218 :       for ( ; spot < vmaxlist ; spot ++ ) vlist[spot] = NULLID;

	cmp	edi, DWORD PTR _vmaxlist
	jge	SHORT $LN165@read_verti
	npad	6
$LL180@read_verti:
	mov	eax, DWORD PTR _vlist
	mov	DWORD PTR [eax+edi*4], 0
	inc	edi
	cmp	edi, DWORD PTR _vmaxlist
	jl	SHORT $LL180@read_verti
	mov	ebx, 512				; 00000200H
$LN165@read_verti:

; 2219 :     }
; 2220 :     if ( valid_id(vlist[k]) )

	mov	ecx, DWORD PTR _vlist
	test	DWORD PTR [ecx+esi*4], 268435456	; 10000000H
	je	SHORT $LN65@read_verti

; 2221 :     { sprintf(errmsg,"Duplicate vertex number %d\n",k);

	push	esi
	push	OFFSET ??_C@_0BM@OEEKDIKO@Duplicate?5vertex?5number?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 2222 :       kb_error(1117,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1117					; 0000045dH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN65@read_verti:

; 2223 :     }
; 2224 :     move_to_free_front(VERTEX,k); /* so id will be k */

	push	esi
	push	0
	call	_move_to_free_front

; 2225 :     vlist[k] = new_vertex(c,NULLID);

	lea	edx, DWORD PTR _c$[ebp]
	push	0
	push	edx
	call	_new_vertex
	mov	ecx, DWORD PTR _vlist
	mov	DWORD PTR [ecx+esi*4], eax

; 2226 :     set_original(vlist[k],(k-1)|((element_id)VERTEX<<TYPESHIFT)|VALIDMASK);

	mov	edx, DWORD PTR _vlist
	mov	eax, DWORD PTR [edx+esi*4]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	ecx, DWORD PTR [esi-1]
	or	ecx, 268435456				; 10000000H
	mov	DWORD PTR [eax+20], ecx

; 2227 : 
; 2228 :     /* attributes */
; 2229 :     if ( web.con_global_map )
; 2230 :     { set_v_global(vlist[k]);

	mov	ecx, DWORD PTR _vlist
	mov	edx, DWORD PTR [ecx+esi*4]
	push	edx
	call	_set_v_global
	add	esp, 20					; 00000014H
$LN191@read_verti:
	mov	ecx, DWORD PTR _tok
	npad	4
$LL63@read_verti:

; 2231 :     }
; 2232 :     for ( more_attr = 1 ; more_attr ; )
; 2233 :       switch ( tok )

	mov	eax, ecx
	cmp	eax, 264				; 00000108H
	jg	SHORT $LN102@read_verti
	je	$LN176@read_verti
	test	eax, eax
	jmp	$LN190@read_verti
$LN102@read_verti:
	cmp	eax, 549				; 00000225H
	jg	$LN103@read_verti
	je	$LN176@read_verti
	sub	eax, 284				; 0000011cH
	cmp	eax, 236				; 000000ecH
	ja	$LN175@read_verti
	movzx	eax, BYTE PTR $LN160@read_verti[eax]
	jmp	DWORD PTR $LN192@read_verti[eax*4]
$LN57@read_verti:

; 2244 : 
; 2245 :            case BARE_TOK:
; 2246 :               set_attr(vlist[k],BARE_NAKED);

	mov	ecx, DWORD PTR _vlist
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	or	DWORD PTR [eax+8], 65536		; 00010000H
$LN188@read_verti:
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], edx
$LN187@read_verti:

; 2247 :               tok = yylex();

	push	0
	call	_kb_yylex
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _tok, ecx

; 2248 :               break;

	jmp	$LL63@read_verti
$LN56@read_verti:

; 2249 : 
; 2250 :            case NO_HESSIAN_NORMAL_TOK:
; 2251 :               set_attr(vlist[k],NO_HESSIAN_NORMAL_ATTR);

	mov	eax, DWORD PTR _vlist
	mov	eax, DWORD PTR [eax+esi*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], -2147483648		; 80000000H
	mov	DWORD PTR [eax+12], ecx

; 2252 :               tok = yylex();
; 2253 :               break;

	jmp	SHORT $LN187@read_verti
$LN55@read_verti:

; 2254 : 
; 2255 : 
; 2256 :            case AXIAL_POINT_TOK:
; 2257 :               set_attr(vlist[k],AXIAL_POINT);

	mov	edx, DWORD PTR _vlist
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 8388608		; 00800000H
	mov	DWORD PTR [eax+12], ecx

; 2258 :               tok = yylex();
; 2259 :               break;

	jmp	SHORT $LN187@read_verti
$LN54@read_verti:

; 2260 : 
; 2261 :            case ORIGINAL_TOK:
; 2262 :               if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN53@read_verti

; 2263 :               { kb_error(2104,"ORIGINAL number missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BK@NKBFEMPG@ORIGINAL?5number?5missing?4?6?$AA@
	push	2104					; 00000838H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2264 :                 break;

	jmp	$LN191@read_verti
$LN53@read_verti:

; 2265 :               }
; 2266 :               set_original(vlist[k],(yylval.i-1)|((element_id)VERTEX<<TYPESHIFT)|VALIDMASK);

	mov	edx, DWORD PTR _vlist
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR _yylval
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	dec	ecx
	or	ecx, 268435456				; 10000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+20], ecx

; 2267 :               tok = yylex();
; 2268 :               break;

	jmp	$LN187@read_verti
$LN52@read_verti:

; 2269 : 
; 2270 :            case FIXED_TOK:
; 2271 :               set_attr(vlist[k],FIXED);

	mov	ecx, DWORD PTR _vlist
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	or	DWORD PTR [eax+8], 64			; 00000040H

; 2272 :               tok = yylex();
; 2273 :               break;

	jmp	$LN188@read_verti
$LN51@read_verti:

; 2274 : 
; 2275 :            case HIT_PARTNER_TOK:
; 2276 :               set_attr(vlist[k],HIT_PARTNER);

	mov	eax, DWORD PTR _vlist
	mov	eax, DWORD PTR [eax+esi*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 32768		; 00008000H
	mov	DWORD PTR [eax+12], ecx

; 2277 :               tok = yylex();
; 2278 :               break;

	jmp	$LN187@read_verti
$LN44@read_verti:

; 2297 :               break;
; 2298 :  
; 2299 :            case QUANTITY_TOK:
; 2300 :               tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 2301 :                if ( tok != QUANTITY_NAME_TOK )

	cmp	eax, 336				; 00000150H
	je	SHORT $LN43@read_verti

; 2302 :                { kb_error(1121,"Need quantity name.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BF@EAMJGDOF@Need?5quantity?5name?4?6?$AA@
	push	1121					; 00000461H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2303 :                  break;

	jmp	$LN191@read_verti
$LN43@read_verti:

; 2304 :                }
; 2305 :                // else fall through
; 2306 : 
; 2307 :            case QUANTITY_NAME_TOK: /* name of quantity */
; 2308 :               qnum = yylval.i;

	mov	edi, DWORD PTR _yylval

; 2309 :               tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 2310 :               if ( tok == '-' || tok == UMINUS_TOK )

	cmp	eax, 45					; 0000002dH
	je	SHORT $LN40@read_verti
	cmp	eax, 287				; 0000011fH
	je	SHORT $LN40@read_verti

; 2313 :               }
; 2314 :               else 
; 2315 :                 apply_quantity(vlist[k],qnum);

	mov	edx, DWORD PTR _vlist
	mov	eax, DWORD PTR [edx+esi*4]
	push	edi
	push	eax
	call	_apply_quantity
	add	esp, 8
	jmp	$LN191@read_verti
$LN40@read_verti:

; 2311 :               { apply_quantity(inverse_id(vlist[k]),qnum);

	mov	ecx, DWORD PTR _vlist
	mov	edx, DWORD PTR [ecx+esi*4]
	xor	edx, 134217728				; 08000000H
	push	edi
	push	edx
	call	_apply_quantity

; 2312 :                 tok = yylex();

	push	0
	call	_kb_yylex
	mov	ecx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, ecx
	jmp	$LL63@read_verti
$LN38@read_verti:

; 2316 :               break;
; 2317 : 
; 2318 :            case IDENT_TOK:  /* maybe method or quantity */
; 2319 :               { sprintf(errmsg,"Illegal use of identifier '%s'.\n",yytext);

	mov	eax, DWORD PTR _yytext
	push	eax
	push	OFFSET ??_C@_0CB@LOIAMNAG@Illegal?5use?5of?5identifier?5?8?$CFs?8?4?6@
	push	OFFSET _errmsg
	call	_sprintf

; 2320 :                 kb_error(1118,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1118					; 0000045eH

; 2321 :               }
; 2322 :               tok = yylex();
; 2323 :               break;

	jmp	$LN185@read_verti
$LN37@read_verti:

; 2324 : 
; 2325 : 
; 2326 :            case BOUNDARY_TOK:
; 2327 :            case BOUNDARY_NAME_TOK:
; 2328 :               {
; 2329 :                 REAL *x,*param;
; 2330 :                 int n;
; 2331 : 
; 2332 :                 if ( tok == BOUNDARY_TOK )

	cmp	ecx, 408				; 00000198H
	jne	SHORT $LN171@read_verti

; 2333 :                   tok = gettok(INTEGER_TOK);

	push	265					; 00000109H
	call	_gettok
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _tok, ecx
$LN171@read_verti:

; 2334 :                 if ( (tok != INTEGER_TOK) && ( tok != BOUNDARY_NAME_TOK ) )  

	cmp	ecx, 265				; 00000109H
	je	SHORT $LN151@read_verti
	cmp	ecx, 520				; 00000208H
	je	SHORT $LN34@read_verti

; 2335 :                 { kb_error(1122,"Need boundary number or name.\n",
; 2336 :                      DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@CEDOMNKL@Need?5boundary?5number?5or?5name?4?6?$AA@
	push	1122					; 00000462H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2337 :                   break;

	jmp	$LN191@read_verti
$LN151@read_verti:

; 2338 :                 }
; 2339 :                 if ( tok == INTEGER_TOK )
; 2340 :                 { bnum = abs(yylval.i);

	mov	eax, DWORD PTR _yylval
	cdq
	xor	eax, edx
	sub	eax, edx

; 2341 :                   if ( (bnum >= web.bdrymax) 
; 2342 :                     ||  !(web.boundaries[bnum].attr & IN_USE) )

	cmp	eax, DWORD PTR _web+768
	jge	SHORT $LN172@read_verti
	mov	edx, DWORD PTR _web+776
	mov	ecx, eax
	imul	ecx, 136				; 00000088H
	mov	ecx, DWORD PTR [ecx+edx+32]
	and	ecx, 32					; 00000020H
	xor	edx, edx
	or	ecx, edx
	jne	$LN31@read_verti
$LN172@read_verti:

; 2343 :                    {
; 2344 :                       sprintf(errmsg,
; 2345 :                           "Bad boundary number %d for vertex %d.\n",bnum,k);

	push	esi
	push	eax
	push	OFFSET ??_C@_0CH@EDLNKPMJ@Bad?5boundary?5number?5?$CFd?5for?5verte@
	push	OFFSET _errmsg
	call	_sprintf

; 2346 :                       kb_error(1123,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1123					; 00000463H
	call	_kb_error

; 2347 :                       yylex();

	push	0
	call	_kb_yylex
	add	esp, 32					; 00000020H

; 2348 :                       break;

	jmp	$LN191@read_verti
$LN34@read_verti:

; 2349 :                    }          
; 2350 :                 }
; 2351 :                 else
; 2352 :                 { bnum = globals(yylval.i)->value.bnum;

	mov	eax, DWORD PTR _yylval
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN86@read_verti
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN88@read_verti
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN87@read_verti
$LN88@read_verti:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN86@read_verti
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN87@read_verti
$LN86@read_verti:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN87@read_verti:
	mov	eax, DWORD PTR [eax+64]
$LN31@read_verti:

; 2353 :                 }
; 2354 :                 set_attr(vlist[k],BOUNDARY);

	mov	ecx, DWORD PTR _vlist
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 128			; 00000080H
	mov	DWORD PTR [ecx+12], edx

; 2355 :                 if ( yylval.i < 0 )  set_attr(vlist[k],NEGBOUNDARY); 

	cmp	DWORD PTR _yylval, 0
	jge	SHORT $LN119@read_verti
	mov	ecx, DWORD PTR _vlist
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 256			; 00000100H
	mov	DWORD PTR [ecx+12], edx
$LN119@read_verti:

; 2356 :                 set_boundary_num(vlist[k],bnum);

	mov	ecx, DWORD PTR _V_BOUNDARY_ATTR
	test	ecx, ecx
	je	SHORT $LN94@read_verti
	mov	edx, DWORD PTR _vlist
	imul	ecx, 240				; 000000f0H
	mov	edx, DWORD PTR [edx+esi*4]
	mov	edi, DWORD PTR _web+12
	add	ecx, DWORD PTR _web+104
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edi+64]
	mov	DWORD PTR [edx+ecx], eax

; 2357 :                 bdry = get_boundary(vlist[k]); 

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN94@read_verti
	mov	edx, DWORD PTR _vlist
	imul	eax, 240				; 000000f0H
	mov	ecx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _web+12
	add	eax, DWORD PTR _web+104
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edi, DWORD PTR [ecx+eax]
	imul	edi, 136				; 00000088H
	add	edi, DWORD PTR _web+776
	jmp	SHORT $LN95@read_verti
$LN94@read_verti:
	xor	edi, edi
$LN95@read_verti:

; 2358 :                 if ( pcount != bdry->pcount )

	mov	ecx, DWORD PTR _pcount$[ebp]
	cmp	ecx, DWORD PTR [edi+40]
	je	SHORT $LN29@read_verti

; 2359 :                   { sprintf(errmsg, "Wrong number of parameters for vertex %d.\n",k);

	push	esi
	push	OFFSET ??_C@_0CL@CBHEBNEI@Wrong?5number?5of?5parameters?5for?5v@
	push	OFFSET _errmsg
	call	_sprintf

; 2360 :                     kb_error(1124,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1124					; 00000464H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN29@read_verti:

; 2361 :                   }          
; 2362 :                 if ( (bdry->attr & CON_ENERGY) && (yytext[0] != '0') )

	mov	eax, DWORD PTR [edi+32]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN173@read_verti
	mov	edx, DWORD PTR _yytext
	cmp	BYTE PTR [edx], 48			; 00000030H
	je	SHORT $LN173@read_verti

; 2363 :                    set_attr(vlist[k], BDRY_ENERGY);

	mov	eax, DWORD PTR _vlist
	mov	eax, DWORD PTR [eax+esi*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ecx
$LN173@read_verti:

; 2364 :                 if ( bdry->attr & CON_CONTENT )

	mov	edi, DWORD PTR [edi+32]
	and	edi, 128				; 00000080H
	xor	eax, eax
	or	edi, eax
	je	SHORT $LN123@read_verti

; 2365 :                    set_attr(vlist[k], BDRY_CONTENT);

	mov	edx, DWORD PTR _vlist
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 4096			; 00001000H
	mov	DWORD PTR [eax+12], ecx
$LN123@read_verti:

; 2366 :                 param = get_param(vlist[k]);

	mov	edx, DWORD PTR _vlist
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR _web+12
	mov	edi, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+104
	mov	eax, DWORD PTR [ecx+edi+544]

; 2367 :                 x = get_coord(vlist[k]);

	mov	ecx, DWORD PTR [ecx+edi+64]
	add	eax, edx
	add	ecx, edx

; 2368 :                 for ( n = 0 ; n < web.maxparam ; n++ )

	xor	edx, edx
	cmp	DWORD PTR _web+640, edx
	jle	SHORT $LN24@read_verti
	sub	ecx, eax
$LL182@read_verti:

; 2369 :                       param[n] = x[n];

	fld	QWORD PTR [ecx+eax]
	inc	edx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	edx, DWORD PTR _web+640
	jl	SHORT $LL182@read_verti
$LN24@read_verti:

; 2370 :                 /* initial coordinate calculation later, after all info */
; 2371 :                 tok = yylex();

	push	0
	call	_kb_yylex

; 2422 :                 tok = yylex();

	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _tok, ecx
	jmp	$LL63@read_verti
$LN23@read_verti:

; 2372 :                     }
; 2373 :                 break;
; 2374 : 
; 2375 :       case CONSTRAINT_TOK:
; 2376 :       case CONSTRAINT_NAME_TOK:
; 2377 :             if ( tok == CONSTRAINT_TOK )

	cmp	ecx, 320				; 00000140H
	jne	SHORT $LL21@read_verti

; 2403 :                     set_attr(vlist[k], BDRY_CONTENT);

$LN131@read_verti:

; 2378 :               tok = gettok(INTEGER_TOK);

	push	265					; 00000109H
	call	_gettok
	mov	ecx, eax
	mov	DWORD PTR _tok, ecx
	add	esp, 4
$LL21@read_verti:

; 2379 :             while ( (tok == INTEGER_TOK) || (tok==CONSTRAINT_NAME_TOK) )

	cmp	ecx, 265				; 00000109H
	je	SHORT $LN150@read_verti
	cmp	ecx, 519				; 00000207H
	jne	$LL63@read_verti

; 2384 :                    cnum = globals(yylval.i)->value.cnum;

	mov	eax, DWORD PTR _yylval
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN96@read_verti
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN98@read_verti
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN97@read_verti
$LN150@read_verti:

; 2380 :               {
; 2381 :                  if ( tok == INTEGER_TOK )
; 2382 :                    cnum = abs(yylval.i);

	mov	eax, DWORD PTR _yylval
	cdq
	xor	eax, edx
	sub	eax, edx

; 2383 :                  else

	jmp	SHORT $LN17@read_verti
$LN98@read_verti:

; 2384 :                    cnum = globals(yylval.i)->value.cnum;

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN96@read_verti
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN97@read_verti
$LN96@read_verti:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN97@read_verti:
	mov	eax, DWORD PTR [eax+64]
$LN17@read_verti:

; 2385 :                  constr = get_constraint(cnum); 

	mov	edi, eax
	and	edi, 1073741823				; 3fffffffH
	imul	edi, 176				; 000000b0H
	add	edi, DWORD PTR _web+652

; 2386 :                  if ( (cnum >= web.maxcon) || !(constr->attr & IN_USE) )

	cmp	eax, DWORD PTR _web+644
	jge	$LN144@read_verti
	mov	ecx, DWORD PTR [edi+32]
	and	ecx, 32					; 00000020H
	xor	edx, edx
	or	ecx, edx
	je	$LN144@read_verti

; 2392 :                       break;
; 2393 :                     }
; 2394 : 
; 2395 :                  set_attr(vlist[k],CONSTRAINT);

	mov	edx, DWORD PTR _vlist
	mov	ecx, DWORD PTR [edx+esi*4]
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 1024			; 00000400H
	mov	DWORD PTR [ecx+12], edx

; 2396 :                  if ( yylval.i < 0 )  

	cmp	DWORD PTR _yylval, 0
	jge	SHORT $LN127@read_verti

; 2397 :                    set_attr(vlist[k],NEGBOUNDARY); 

	mov	ecx, DWORD PTR _vlist
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 256			; 00000100H
	mov	DWORD PTR [ecx+12], edx
$LN127@read_verti:

; 2398 :                  set_v_constraint_map(vlist[k],cnum);

	push	eax
	mov	eax, DWORD PTR _vlist
	mov	ecx, DWORD PTR [eax+esi*4]
	push	ecx
	call	_set_v_constraint_map

; 2399 : 
; 2400 :                  if ( (constr->attr & CON_ENERGY) && (yytext[0] != '0') )

	mov	eax, DWORD PTR [edi+32]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	add	esp, 8
	or	eax, ecx
	je	SHORT $LN170@read_verti
	mov	edx, DWORD PTR _yytext
	cmp	BYTE PTR [edx], 48			; 00000030H
	je	SHORT $LN170@read_verti

; 2401 :                     set_attr(vlist[k], BDRY_ENERGY);

	mov	eax, DWORD PTR _vlist
	mov	eax, DWORD PTR [eax+esi*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ecx
$LN170@read_verti:

; 2402 :                  if ( constr->attr & CON_CONTENT )

	mov	eax, DWORD PTR [edi+32]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN131@read_verti

; 2403 :                     set_attr(vlist[k], BDRY_CONTENT);

	mov	edx, DWORD PTR _vlist
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 4096			; 00001000H
	mov	DWORD PTR [eax+12], ecx

; 2404 :             
; 2405 :                  tok = gettok(INTEGER_TOK);
; 2406 :               }

	jmp	$LN131@read_verti
$LN144@read_verti:

; 2387 :                     {
; 2388 :                       sprintf(errmsg,
; 2389 :                           "Bad constraint number %d for vertex %d.\n",cnum,k);

	push	esi
	push	eax
	push	OFFSET ??_C@_0CJ@CDBMMBKP@Bad?5constraint?5number?5?$CFd?5for?5ver@
	push	OFFSET _errmsg
	call	_sprintf

; 2390 :                       kb_error(1125,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1125					; 00000465H
	call	_kb_error

; 2391 :                       tok = yylex();

	push	0
	call	_kb_yylex

; 2422 :                 tok = yylex();

	mov	ecx, eax
	add	esp, 32					; 00000020H
	mov	DWORD PTR _tok, ecx
	jmp	$LL63@read_verti
$LN103@read_verti:

; 2231 :     }
; 2232 :     for ( more_attr = 1 ; more_attr ; )
; 2233 :       switch ( tok )

	cmp	eax, 35084				; 0000890cH
	jg	$LN104@read_verti
	je	$LN10@read_verti
	cmp	eax, 566				; 00000236H
	je	$LN59@read_verti
	cmp	eax, 35024				; 000088d0H
	jne	$LN175@read_verti

; 2279 : 
; 2280 :            case METHOD_TOK:  /* apply method instance to edge */
; 2281 :               tok = yylex();  /* get name */

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 2282 :               if ( tok != METHOD_NAME_TOK )

	cmp	eax, 414				; 0000019eH
	je	SHORT $LN49@read_verti

; 2283 :               { kb_error(1949,"Missing method instance name.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@MGOCAHJG@Missing?5method?5instance?5name?4?6?$AA@
	push	1949					; 0000079dH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2284 :                 break;

	jmp	$LN191@read_verti
$LN49@read_verti:

; 2285 :               }
; 2286 :               // else fall through to METHOD_NAME_TOK
; 2287 : 
; 2288 :            case METHOD_NAME_TOK:
; 2289 :               qnum = yylval.i;

	mov	edi, DWORD PTR _yylval

; 2290 :               tok = yylex();           

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 2291 :               if ( tok == '-' || tok == UMINUS_TOK )

	cmp	eax, 45					; 0000002dH
	je	SHORT $LN46@read_verti
	cmp	eax, 287				; 0000011fH
	je	SHORT $LN46@read_verti

; 2294 :               }
; 2295 :               else
; 2296 :                 apply_method_num(vlist[k],qnum);

	mov	edx, DWORD PTR _vlist
	mov	eax, DWORD PTR [edx+esi*4]
	push	edi
	push	eax
	call	_apply_method_num
	add	esp, 8
	jmp	$LN191@read_verti
$LN46@read_verti:

; 2292 :               { apply_method_num(inverse_id(vlist[k]),qnum);

	mov	ecx, DWORD PTR _vlist
	mov	edx, DWORD PTR [ecx+esi*4]
	xor	edx, 134217728				; 08000000H
	push	edi
	push	edx
	call	_apply_method_num

; 2293 :                 tok = yylex();

	push	0
	call	_kb_yylex

; 2422 :                 tok = yylex();

	mov	ecx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, ecx
	jmp	$LL63@read_verti
$LN59@read_verti:

; 2234 :         {
; 2235 :            case EXTRA_ATTRIBUTE_TOK:
; 2236 :            case ARRAY_ATTRIBUTE_TOK:
; 2237 :                 if ( yylval.etype != VERTEX )

	mov	eax, DWORD PTR _yylval+24
	test	eax, eax
	je	SHORT $LN58@read_verti

; 2238 :                 { sprintf(errmsg,"'%s' is a %s attribute, not a vertex attribute.\n",
; 2239 :                         yytext,typenames[yylval.etype]);

	mov	eax, DWORD PTR _typenames[eax*4]
	mov	ecx, DWORD PTR _yytext
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DB@GPFFHCHH@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5a?5ve@
	push	OFFSET _errmsg
	call	_sprintf

; 2240 :                   kb_error(2506,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	2506					; 000009caH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN58@read_verti:

; 2241 :                 }
; 2242 :                 read_extra(vlist[k],yylval.qnum);

	mov	edx, DWORD PTR _yylval+4
	mov	eax, DWORD PTR _vlist
	mov	ecx, DWORD PTR [eax+esi*4]
	push	edx
	push	ecx
	call	_read_extra
	add	esp, 8

; 2243 :               break;

	jmp	$LN191@read_verti
$LN10@read_verti:

; 2407 :             /* projection later, after all vertex info read in */
; 2408 :             break;
; 2409 : 
; 2410 :             case EDGES_TOK: case FACES_TOK: case BODIES_TOK: case READ_TOK: 
; 2411 :             case LEAD_INTEGER_TOK: case LEAD_INTEGER_AT_TOK: case NO_TOKEN:
; 2412 :                 more_attr = 0 ; break;  /* error recovery */
; 2413 :             case UNPUTTED_TOK: 
; 2414 :                 kb_error(3701,
; 2415 :                    "Internal error: forgot to get lookahead token.\n",
; 2416 :                        WARNING);

	push	2
	push	OFFSET ??_C@_0DA@MGFNEFND@Internal?5error?3?5forgot?5to?5get?5lo@
	push	3701					; 00000e75H
	call	_kb_error

; 2417 :                 tok = yylex();

	push	0
	call	_kb_yylex

; 2422 :                 tok = yylex();

	mov	ecx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tok, ecx
	jmp	$LL63@read_verti
$LN104@read_verti:

; 2231 :     }
; 2232 :     for ( more_attr = 1 ; more_attr ; )
; 2233 :       switch ( tok )

	cmp	eax, 35086				; 0000890eH
$LN190@read_verti:
	je	SHORT $LN176@read_verti
$LN175@read_verti:

; 2418 :                 break;
; 2419 :             default: 
; 2420 :                 sprintf(errmsg,"Unexpected token: %s\n",yytext);

	mov	edx, DWORD PTR _yytext
	push	edx
	push	OFFSET ??_C@_0BG@BKFJJJKH@Unexpected?5token?3?5?$CFs?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 2421 :                 kb_error(2105,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	2105					; 00000839H
$LN185@read_verti:
	call	_kb_error

; 2422 :                 tok = yylex();

	push	0
	call	_kb_yylex
	mov	ecx, eax
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tok, ecx
	jmp	$LL63@read_verti
$LN176@read_verti:

; 2423 :                 break; 
; 2424 : 
; 2425 :           }
; 2426 : 
; 2427 :       if ((get_vattr(vlist[k])&(BOUNDARY|CONSTRAINT)) == (BOUNDARY|CONSTRAINT))

	mov	eax, DWORD PTR _vlist
	mov	edx, DWORD PTR [eax+esi*4]
	mov	ecx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1152				; 00000480H
	xor	edx, edx
	cmp	eax, 1152				; 00000480H
	jne	SHORT $LN8@read_verti
	test	edx, edx
	jne	SHORT $LN8@read_verti

; 2428 :           kb_error(1126,"Cannot have constraint and boundary.",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CF@NGLIKJND@Cannot?5have?5constraint?5and?5bound@
	push	1126					; 00000466H
	call	_kb_error
	mov	ecx, DWORD PTR _web+12
	add	esp, 12					; 0000000cH
$LN8@read_verti:

; 2429 : 
; 2430 :       if ( !(get_vattr(vlist[k])&BOUNDARY) && (pcount != SDIM) )

	mov	eax, DWORD PTR _vlist
	mov	edx, DWORD PTR [eax+esi*4]
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	jne	SHORT $LN166@read_verti
	mov	eax, DWORD PTR _pcount$[ebp]
	cmp	eax, DWORD PTR _web+616
	je	SHORT $LN166@read_verti

; 2431 :          { sprintf(errmsg,"Wrong number of coordinates for vertex %d.\n",k);

	push	esi
	push	OFFSET ??_C@_0CM@COILCHG@Wrong?5number?5of?5coordinates?5for?5@
	push	OFFSET _errmsg
	call	_sprintf

; 2432 :             kb_error(1127,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1127					; 00000467H
	call	_kb_error
	mov	ecx, DWORD PTR _web+12
	add	esp, 24					; 00000018H
$LN166@read_verti:

; 2433 : 
; 2434 :           }
; 2435 :       if ( get_vattr(vlist[k]) & BOUNDARY )

	mov	edx, DWORD PTR _vlist
	mov	eax, DWORD PTR [edx+esi*4]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 128				; 00000080H
	xor	edi, edi
	or	eax, edi
	je	$LN3@read_verti

; 2436 :       { REAL * x = get_coord(vlist[k]);

	mov	ebx, DWORD PTR _web+104
	mov	edi, DWORD PTR _dymem
	mov	eax, DWORD PTR [ebx+edi+64]
	add	eax, edx
	mov	DWORD PTR _x$90633[ebp], eax

; 2437 :          int n;
; 2438 :          bdry = get_boundary(vlist[k]);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN105@read_verti
	imul	eax, 240				; 000000f0H
	add	eax, ebx
	mov	eax, DWORD PTR [eax+edi+64]
	mov	edx, DWORD PTR [eax+edx]
	imul	edx, 136				; 00000088H
	add	edx, DWORD PTR _web+776
	jmp	SHORT $LN106@read_verti
$LN105@read_verti:
	xor	edx, edx
$LN106@read_verti:

; 2439 :           for ( n = 0 ; n < SDIM ; n++ )

	xor	edi, edi
	cmp	DWORD PTR _web+616, edi
	jle	SHORT $LN3@read_verti
	add	edx, 48					; 00000030H
	mov	DWORD PTR tv1962[ebp], edx
$LL184@read_verti:

; 2440 :              if ( bdry->coordf[n]->root != NULL )

	mov	edx, DWORD PTR [edx]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN4@read_verti

; 2441 :                  x[n] = eval(bdry->coordf[n],get_param(vlist[k]),vlist[k],NULL);

	mov	eax, DWORD PTR _vlist
	mov	eax, DWORD PTR [eax+esi*4]
	push	0
	push	eax
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	add	ecx, DWORD PTR [ebx+eax+544]
	push	ecx
	push	edx
	call	_eval
	mov	ecx, DWORD PTR _x$90633[ebp]
	fstp	QWORD PTR [ecx+edi*8]
	mov	ebx, DWORD PTR _web+104
	mov	ecx, DWORD PTR _web+12
	add	esp, 16					; 00000010H
$LN4@read_verti:

; 2439 :           for ( n = 0 ; n < SDIM ; n++ )

	mov	edx, DWORD PTR tv1962[ebp]
	inc	edi
	add	edx, 4
	mov	DWORD PTR tv1962[ebp], edx
	cmp	edi, DWORD PTR _web+616
	jl	SHORT $LL184@read_verti
$LN3@read_verti:

; 2442 :       }
; 2443 :       if ( get_vattr(vlist[k]) & CONSTRAINT )

	mov	edx, DWORD PTR _vlist
	mov	esi, DWORD PTR [edx+esi*4]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	$LL167@read_verti

; 2444 :          project_v_constr(vlist[k],ACTUAL_MOVE,RESET_ONESIDEDNESS);

	push	1
	push	1
	push	esi
	call	_project_v_constr
	add	esp, 12					; 0000000cH

; 2445 :     }

	jmp	$LL167@read_verti
$LN163@read_verti:

; 2446 :   web.zoom_v = vlist[zoom_number];  /* vertex for zooming in on */

	mov	ecx, DWORD PTR _zoom_number
	mov	edx, DWORD PTR _vlist
	mov	eax, DWORD PTR [edx+ecx*4]

; 2447 : }  /* end read_vertices() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	mov	DWORD PTR _web+976, eax
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN192@read_verti:
	DD	$LN59@read_verti
	DD	$LN38@read_verti
	DD	$LN176@read_verti
	DD	$LN54@read_verti
	DD	$LN52@read_verti
	DD	$LN23@read_verti
	DD	$LN43@read_verti
	DD	$LN56@read_verti
	DD	$LN57@read_verti
	DD	$LN37@read_verti
	DD	$LN49@read_verti
	DD	$LN55@read_verti
	DD	$LN51@read_verti
	DD	$LN44@read_verti
	DD	$LN175@read_verti
$LN160@read_verti:
	DB	0
	DB	14					; 0000000eH
	DB	1
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	2
	DB	14					; 0000000eH
	DB	2
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	3
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	4
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	5
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	6
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	2
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	7
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	8
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	9
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	10					; 0000000aH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	11					; 0000000bH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	12					; 0000000cH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	5
	DB	9
_read_vertices ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@DKGMBMOB@Edge?5?$CFd?3?5vertex?5?$CFd?5is?5not?5define@ ; `string'
PUBLIC	??_C@_0BM@OFNCGKJA@Too?5few?5vertices?5for?5edge?4?6?$AA@ ; `string'
PUBLIC	??_C@_0EC@PDLLHJBK@addload?5datafile?5is?5linear?5model@ ; `string'
PUBLIC	??_C@_0ED@FDOHNEFP@addload?5datafile?5is?5linear?5model@ ; `string'
PUBLIC	??_C@_0DA@JHENGICO@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5an?5e@ ; `string'
PUBLIC	??_C@_0EI@HNEECJIN@?8Energy?8?5obsolete?4?5Implement?5edg@ ; `string'
PUBLIC	??_C@_0BI@JFIOCEAN@Undefined?5quantity?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@PJJAKHC@Missing?5DENSITY?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@JCKGDEOH@Bad?5constraint?5number?5?$CFd?5for?5edg@ ; `string'
PUBLIC	??_C@_0FK@MDDCAAB@Inconsistent?5number?5of?5component@ ; `string'
PUBLIC	??_C@_0GG@EEBCIKGE@Edge?5?$CFs?5is?5on?5constraint?5?$CFs?0?5whi@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0CF@HDBOPHDM@Bad?5boundary?5number?5?$CFd?5for?5edge?5@ ; `string'
PUBLIC	??_C@_0BA@IPLAMOJB@Color?5missing?4?6?$AA@	; `string'
PUBLIC	??_C@_0DC@JNMGKLBI@Cannot?5do?5wraps?5without?5torus?5or@ ; `string'
PUBLIC	??_C@_0BM@NLDAKABN@ORIENTATION?5value?5missing?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@PFOEMAKJ@Missing?5wrap?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CP@DGBDNCJM@Edge?5wraps?5must?5immediately?5foll@ ; `string'
PUBLIC	??_C@_0BK@CJPBBAMB@Duplicate?5edge?5number?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@BDIDPFBJ@Edge?5number?5must?5be?5positive?4?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_read_edges
EXTRN	_valid_element:PROC
EXTRN	_free_element:PROC
EXTRN	_strncpy:PROC
EXTRN	_apply_method:PROC
EXTRN	_set_e_constraint_map:PROC
EXTRN	_elnames:BYTE
EXTRN	_E_BOUNDARY_ATTR:DWORD
EXTRN	_read_wrap_flag:DWORD
EXTRN	_new_edge:PROC
EXTRN	_binom_coeff:PROC
;	COMDAT ??_C@_0CE@DKGMBMOB@Edge?5?$CFd?3?5vertex?5?$CFd?5is?5not?5define@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CE@DKGMBMOB@Edge?5?$CFd?3?5vertex?5?$CFd?5is?5not?5define@ DB 'Edg'
	DB	'e %d: vertex %d is not defined.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OFNCGKJA@Too?5few?5vertices?5for?5edge?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@OFNCGKJA@Too?5few?5vertices?5for?5edge?4?6?$AA@ DB 'Too few ver'
	DB	'tices for edge.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@PDLLHJBK@addload?5datafile?5is?5linear?5model@
CONST	SEGMENT
??_C@_0EC@PDLLHJBK@addload?5datafile?5is?5linear?5model@ DB 'addload data'
	DB	'file is linear model, but current model is Lagrange.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FDOHNEFP@addload?5datafile?5is?5linear?5model@
CONST	SEGMENT
??_C@_0ED@FDOHNEFP@addload?5datafile?5is?5linear?5model@ DB 'addload data'
	DB	'file is linear model, but current model is quadratic.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JHENGICO@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5an?5e@
CONST	SEGMENT
??_C@_0DA@JHENGICO@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5an?5e@ DB ''''
	DB	'%s'' is a %s attribute, not an edge attribute.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@HNEECJIN@?8Energy?8?5obsolete?4?5Implement?5edg@
CONST	SEGMENT
??_C@_0EI@HNEECJIN@?8Energy?8?5obsolete?4?5Implement?5edg@ DB '''Energy'''
	DB	' obsolete. Implement edge integral energy with named quantity'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JFIOCEAN@Undefined?5quantity?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BI@JFIOCEAN@Undefined?5quantity?3?5?$CFs?6?$AA@ DB 'Undefined quan'
	DB	'tity: %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PJJAKHC@Missing?5DENSITY?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@PJJAKHC@Missing?5DENSITY?5value?4?6?$AA@ DB 'Missing DENSITY va'
	DB	'lue.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JCKGDEOH@Bad?5constraint?5number?5?$CFd?5for?5edg@
CONST	SEGMENT
??_C@_0CH@JCKGDEOH@Bad?5constraint?5number?5?$CFd?5for?5edg@ DB 'Bad cons'
	DB	'traint number %d for edge %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@MDDCAAB@Inconsistent?5number?5of?5component@
CONST	SEGMENT
??_C@_0FK@MDDCAAB@Inconsistent?5number?5of?5component@ DB 'Inconsistent n'
	DB	'umber of components in edge %s constraint %s content or energ'
	DB	'y integrands.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@EEBCIKGE@Edge?5?$CFs?5is?5on?5constraint?5?$CFs?0?5whi@
CONST	SEGMENT
??_C@_0GG@EEBCIKGE@Edge?5?$CFs?5is?5on?5constraint?5?$CFs?0?5whi@ DB 'Edg'
	DB	'e %s is on constraint %s, which has an energy integral.  Prob'
	DB	'ably a bad idea in the string model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HDBOPHDM@Bad?5boundary?5number?5?$CFd?5for?5edge?5@
CONST	SEGMENT
??_C@_0CF@HDBOPHDM@Bad?5boundary?5number?5?$CFd?5for?5edge?5@ DB 'Bad bou'
	DB	'ndary number %d for edge %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IPLAMOJB@Color?5missing?4?6?$AA@
CONST	SEGMENT
??_C@_0BA@IPLAMOJB@Color?5missing?4?6?$AA@ DB 'Color missing.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@JNMGKLBI@Cannot?5do?5wraps?5without?5torus?5or@
CONST	SEGMENT
??_C@_0DC@JNMGKLBI@Cannot?5do?5wraps?5without?5torus?5or@ DB 'Cannot do w'
	DB	'raps without torus or symmetry group.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NLDAKABN@ORIENTATION?5value?5missing?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@NLDAKABN@ORIENTATION?5value?5missing?4?6?$AA@ DB 'ORIENTATION v'
	DB	'alue missing.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PFOEMAKJ@Missing?5wrap?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BF@PFOEMAKJ@Missing?5wrap?5value?4?6?$AA@ DB 'Missing wrap value.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@DGBDNCJM@Edge?5wraps?5must?5immediately?5foll@
CONST	SEGMENT
??_C@_0CP@DGBDNCJM@Edge?5wraps?5must?5immediately?5foll@ DB 'Edge wraps m'
	DB	'ust immediately follow endpoints.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CJPBBAMB@Duplicate?5edge?5number?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BK@CJPBBAMB@Duplicate?5edge?5number?5?$CFd?6?$AA@ DB 'Duplicate ed'
	DB	'ge number %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BDIDPFBJ@Edge?5number?5must?5be?5positive?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@BDIDPFBJ@Edge?5number?5must?5be?5positive?4?6?$AA@ DB 'Edge num'
	DB	'ber must be positive.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\lexinit.c
CONST	ENDS
;	COMDAT _read_edges
_TEXT	SEGMENT
tv2456 = -96						; size = 8
_k$ = -92						; size = 4
_one$ = -88						; size = 4
_head$ = -84						; size = 4
_compcount$ = -80					; size = 4
_have_mid$90696 = -76					; size = 4
_value$ = -72						; size = 8
_numv$ = -64						; size = 4
_wrap$90697 = -60					; size = 4
tv2623 = -56						; size = 4
_cnum$ = -56						; size = 4
_tail$ = -56						; size = 4
_vercount$90714 = -56					; size = 4
_h$90974 = -52						; size = 48
_qname$90942 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_read_edges PROC					; COMDAT

; 2458 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2459 :   int i,k;
; 2460 :   element_id head,tail;
; 2461 :   int cnum,bnum;
; 2462 :   struct boundary *bdry;
; 2463 :   struct constraint *constr;
; 2464 :   int more_attr;
; 2465 :   REAL value;  /* for constant expression values */
; 2466 :   int compcount;  /* proper number of components for integrands */
; 2467 :   int numv; /* vertices to read in association with a facet */
; 2468 :   int edim = (web.representation==STRING) ? 1 : web.dimension - 1;

	mov	eax, DWORD PTR _web+624
	push	esi
	push	edi
	cmp	eax, 1
	jne	SHORT $LN152@read_edges
	mov	esi, eax
	jmp	SHORT $LN153@read_edges
$LN152@read_edges:
	mov	esi, DWORD PTR _web+620
	dec	esi
$LN153@read_edges:

; 2469 :   int one = 1;
; 2470 : #ifdef MPI_EVOLVER
; 2471 :   struct element *vdummy = (struct element *)mycalloc(web.sizes[VERTEX],1);
; 2472 : #endif
; 2473 : 
; 2474 :   if ( web.representation == SIMPLEX ) 

	mov	edi, 3
	mov	DWORD PTR _one$[ebp], 1
	cmp	eax, edi
	jne	SHORT $LN149@read_edges

; 2475 :      compcount = binom_coeff(SDIM,edim);

	mov	eax, DWORD PTR _web+616
	push	esi
	push	eax
	call	_binom_coeff
	add	esp, 8
	mov	DWORD PTR _compcount$[ebp], eax
	jmp	SHORT $LN148@read_edges
$LN149@read_edges:

; 2476 :   else compcount = SDIM; 

	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR _compcount$[ebp], ecx
$LN148@read_edges:

; 2477 : 
; 2478 :   /* adjust attributes for space dimension*/
; 2479 :   EXTRAS(EDGE)[E_VECTOR_ATTR].array_spec.sizes[0] = SDIM;

	mov	edx, DWORD PTR _web+216
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+616

; 2480 :   expand_attribute(EDGE,E_VERTICES_ATTR,&web.skel[EDGE].ctrlpts);

	push	OFFSET _web+120
	push	1
	push	1
	mov	DWORD PTR [edx+eax+576], ecx
	call	_expand_attribute
	add	esp, 12					; 0000000cH

; 2481 :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN147@read_edges

; 2482 :      expand_attribute(EDGE,E_WRAP_ATTR,&one);

	lea	edx, DWORD PTR _one$[ebp]
	push	edx
	push	edi
	push	1
	call	_expand_attribute
	add	esp, 12					; 0000000cH
$LN147@read_edges:

; 2483 : 
; 2484 :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, edi
	jne	SHORT $LN146@read_edges

; 2485 :   { if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, edi
	jne	SHORT $LN145@read_edges

; 2486 :         numv = binom_coeff(web.lagrange_order+edim,edim); 

	mov	eax, DWORD PTR _web+632
	add	eax, esi
	push	esi
	push	eax
	call	_binom_coeff
	add	esp, 8
	mov	DWORD PTR _numv$[ebp], eax
	jmp	SHORT $LN140@read_edges
$LN145@read_edges:

; 2487 :      else numv = web.dimension;

	mov	ecx, DWORD PTR _web+620

; 2488 :   }
; 2489 :   else if ( web.modeltype == LAGRANGE )

	jmp	SHORT $LN310@read_edges
$LN146@read_edges:
	mov	eax, DWORD PTR _web+628
	cmp	eax, edi
	jne	SHORT $LN142@read_edges

; 2490 :   { numv = binom_coeff(web.lagrange_order+edim,edim);

	mov	edx, DWORD PTR _web+632
	add	edx, esi
	push	esi
	push	edx
	call	_binom_coeff
	add	esp, 8
	mov	DWORD PTR _numv$[ebp], eax
	jmp	SHORT $LN140@read_edges
$LN142@read_edges:

; 2491 :   }
; 2492 :   else if ( web.modeltype == QUADRATIC ) numv = 3;

	xor	ecx, ecx
	cmp	eax, 2
	sete	cl
	add	ecx, 2
$LN310@read_edges:
	mov	DWORD PTR _numv$[ebp], ecx
$LN140@read_edges:

; 2493 :   else numv = 2;
; 2494 : 
; 2495 :   /* read in edges */
; 2496 :   emaxlist = MAXLIST;
; 2497 :   elist = (edge_id *)mycalloc(sizeof(edge_id),emaxlist);

	push	2497					; 000009c1H
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	push	100					; 00000064H
	push	4
	mov	DWORD PTR _emaxlist, 100		; 00000064H
	call	_kb_calloc
	mov	DWORD PTR _elist, eax

; 2498 :   while ( (tok != EDGES_TOK) && (tok != 0 ) ) 

	mov	eax, DWORD PTR _tok
	add	esp, 16					; 00000010H
	cmp	eax, 294				; 00000126H
	je	SHORT $LN272@read_edges
$LL138@read_edges:
	test	eax, eax
	je	$LN134@read_edges

; 2499 :      tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 294				; 00000126H
	jne	SHORT $LL138@read_edges
$LN272@read_edges:

; 2500 :   if ( tok != EDGES_TOK) return;
; 2501 :   tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	push	ebx
$LL135@read_edges:

; 2502 :   while ( (tok == LEAD_INTEGER_TOK) || (tok == LEAD_INTEGER_AT_TOK) )

	mov	eax, DWORD PTR _tok
	cmp	eax, 264				; 00000108H
	je	SHORT $LN133@read_edges
	cmp	eax, 549				; 00000225H
	jne	$LN307@read_edges
$LN133@read_edges:

; 2503 :   { int have_mid = 0;
; 2504 :     WRAPTYPE wrap = 0;
; 2505 : 
; 2506 :     #ifdef MPI_EVOLVER
; 2507 :     /* test task number, for MPI */
; 2508 :     int task;
; 2509 :     if ( tok == LEAD_INTEGER_TOK )
; 2510 :        task = 1;  /* default to task 1 */
; 2511 :     else task = yylval.qnum;
; 2512 :     if ( task >= mpi_nprocs || task < 1 )
; 2513 :     { sprintf(errmsg,"Task number %d must be between 1 and %d\n",
; 2514 :          task,mpi_nprocs-1);
; 2515 :       kb_error(5007,errmsg,RECOVERABLE);
; 2516 :     }
; 2517 :     if ( task != this_task )
; 2518 :     { /* skip this edge */
; 2519 :       int flag = 0;
; 2520 :       while ( !flag ) 
; 2521 :       { tok = yylex();
; 2522 :         switch (tok)
; 2523 :         { case LEAD_INTEGER_TOK: 
; 2524 :           case LEAD_INTEGER_AT_TOK:
; 2525 :           case FACES_TOK:
; 2526 :           case BODIES_TOK:
; 2527 :           case READ_TOK:
; 2528 :           case 0:
; 2529 :             flag = 1;
; 2530 :             break;
; 2531 :         }
; 2532 :       }
; 2533 :       continue;  /* next edge */
; 2534 :     }
; 2535 :     #endif
; 2536 :     
; 2537 :     /* check edge number */
; 2538 :     k = yylval.i;

	mov	ebx, DWORD PTR _yylval
	xor	eax, eax
	mov	DWORD PTR _have_mid$90696[ebp], eax
	mov	DWORD PTR _wrap$90697[ebp], eax
	mov	DWORD PTR _k$[ebp], ebx

; 2539 :     if ( k < 1 ) 

	cmp	ebx, 1
	jge	SHORT $LN132@read_edges

; 2540 :         kb_error(2106,"Edge number must be positive.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@BDIDPFBJ@Edge?5number?5must?5be?5positive?4?6?$AA@
	push	2106					; 0000083aH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN132@read_edges:

; 2541 :     if ( k >= emaxlist )

	mov	eax, DWORD PTR _emaxlist
	cmp	ebx, eax
	jl	SHORT $LN126@read_edges

; 2542 :     { int spot = emaxlist; 

	mov	esi, eax
	npad	4
$LL130@read_edges:

; 2543 :       while ( k >= emaxlist )
; 2544 :         emaxlist *= 2;

	add	eax, eax
	cmp	ebx, eax
	jge	SHORT $LL130@read_edges

; 2545 :       elist = (edge_id *)kb_realloc((char *)elist,emaxlist*sizeof(edge_id));

	push	2545					; 000009f1H
	lea	edx, DWORD PTR [eax*4]
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	mov	DWORD PTR _emaxlist, eax
	mov	eax, DWORD PTR _elist
	push	edx
	push	eax
	call	_KB_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _elist, eax

; 2546 :       for ( ; spot < emaxlist ; spot ++ ) elist[spot] = NULLID;

	cmp	esi, DWORD PTR _emaxlist
	jge	SHORT $LN126@read_edges
	npad	8
$LL293@read_edges:
	mov	ecx, DWORD PTR _elist
	mov	DWORD PTR [ecx+esi*4], 0
	inc	esi
	cmp	esi, DWORD PTR _emaxlist
	jl	SHORT $LL293@read_edges
$LN126@read_edges:

; 2547 :     }
; 2548 :     if ( valid_id(elist[k]) )

	mov	edx, DWORD PTR _elist
	test	DWORD PTR [edx+ebx*4], 268435456	; 10000000H
	je	SHORT $LN125@read_edges

; 2549 :     { sprintf(errmsg,"Duplicate edge number %d\n",k);

	push	ebx
	push	OFFSET ??_C@_0BK@CJPBBAMB@Duplicate?5edge?5number?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 2550 :       kb_error(1130,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1130					; 0000046aH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN125@read_edges:

; 2551 :     }
; 2552 : 
; 2553 :     { /* read vertex list */
; 2554 :           int vercount;
; 2555 :        vertex_id *v,*vv;
; 2556 : 
; 2557 :        move_to_free_front(EDGE,k); /* so id will be k */

	push	ebx
	push	1
	call	_move_to_free_front

; 2558 :        elist[k] = new_edge(NULLID,NULLID,NULLID);

	push	0
	push	0
	push	0
	call	_new_edge
	mov	ecx, DWORD PTR _elist
	mov	DWORD PTR [ecx+ebx*4], eax

; 2559 :        vv = v = get_edge_vertices(elist[k]);

	mov	edx, DWORD PTR _elist
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	add	edi, DWORD PTR [eax+edx+304]
	add	esp, 20					; 00000014H

; 2560 :        for ( vercount = 0 ; vercount < numv ; vercount++ )

	cmp	DWORD PTR _numv$[ebp], 0
	mov	esi, edi
	mov	DWORD PTR _vercount$90714[ebp], 0
	jle	SHORT $LN295@read_edges
$LL124@read_edges:

; 2561 :        { tok = gettok(INTEGER_TOK);

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 2562 :          if ( tok != INTEGER_TOK )

	cmp	eax, 265				; 00000109H
	jne	$LN256@read_edges

; 2578 :             return; 
; 2579 :           }
; 2580 : #ifdef MPI_EVOLVER
; 2581 :           if ( yylval.qnum == 0 )
; 2582 :              yylval.qnum = 1;
; 2583 :           if ( yylval.qnum >= mpi_nprocs )
; 2584 :           { sprintf(errmsg,"Task number %d exceeds number of tasks running, %d\n",
; 2585 :                yylval.qnum,mpi_nprocs-1);
; 2586 :             kb_error(5008,errmsg,RECOVERABLE);
; 2587 :           }
; 2588 :           if ( yylval.qnum != this_task )
; 2589 :           { 
; 2590 :             *v = ((element_id)VERTEX << TYPESHIFT) | VALIDMASK | 
; 2591 :                 (yylval.i-1) | ((element_id)yylval.qnum << TASK_ID_SHIFT);  
; 2592 :             /* add spaceholder to remote element list */
; 2593 :             memset(vdummy,0,web.sizes[VERTEX]);
; 2594 :             vdummy->self_id = *v;
; 2595 :             vdummy->attr = ALLOCATED|NEWELEMENT;
; 2596 :             mpi_add_remote_element(vdummy);
; 2597 :             v++;
; 2598 :           }
; 2599 :           else
; 2600 : #endif
; 2601 :           if ( (yylval.i >= vmaxlist) || !valid_id(vlist[yylval.i]) )

	mov	ecx, DWORD PTR _yylval
	cmp	ecx, DWORD PTR _vmaxlist
	jge	$LN257@read_edges
	mov	edx, DWORD PTR _vlist
	mov	eax, DWORD PTR [edx+ecx*4]
	test	eax, 268435456				; 10000000H
	je	$LN257@read_edges

; 2604 :             return;
; 2605 :           }
; 2606 :           else *(v++) = vlist[yylval.i];

	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR _vercount$90714[ebp]
	inc	eax
	add	edi, 4
	mov	DWORD PTR _vercount$90714[ebp], eax
	cmp	eax, DWORD PTR _numv$[ebp]
	jl	SHORT $LL124@read_edges
$LN295@read_edges:

; 2607 :         }
; 2608 :        if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	$LN109@read_edges

; 2609 :        { head = vv[1]; tail = vv[0]; set_edge_midv(elist[k],vv[2]); }

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _elist
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	mov	DWORD PTR _tail$[ebp], ecx
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _web+216
	mov	edi, DWORD PTR [edi+ebx+304]
	mov	DWORD PTR _head$[ebp], eax
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+edi+8], eax
	mov	edi, DWORD PTR _web+12
	mov	ecx, eax
	mov	ebx, DWORD PTR _k$[ebp]
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [edi+ecx]
	mov	DWORD PTR [edi+28], edx
	mov	edx, DWORD PTR _web[eax+12]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 131072		; 00020000H
	mov	edi, DWORD PTR _tail$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	eax, DWORD PTR _head$[ebp]
	jmp	SHORT $LN108@read_edges
$LN109@read_edges:

; 2610 :        else { head = vv[numv-1]; tail = vv[0]; }

	mov	ecx, DWORD PTR _numv$[ebp]
	mov	eax, DWORD PTR [esi+ecx*4-4]
	mov	edi, DWORD PTR [esi]
$LN108@read_edges:

; 2611 :        set_edge_headv(elist[k],head);

	mov	edx, DWORD PTR _elist
	push	eax
	mov	eax, DWORD PTR [edx+ebx*4]
	push	eax
	call	_set_edge_headv

; 2612 :        set_edge_tailv(elist[k],tail);

	mov	ecx, DWORD PTR _elist
	mov	edx, DWORD PTR [ecx+ebx*4]
	push	edi
	push	edx
	call	_set_edge_tailv

; 2613 :        if ( web.modeltype == QUADRATIC )

	mov	eax, DWORD PTR _web+628
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jne	SHORT $LN107@read_edges

; 2614 :        { have_mid =1; /* for later */

	mov	DWORD PTR _have_mid$90696[ebp], 1
	jmp	SHORT $LN102@read_edges
$LN107@read_edges:

; 2615 :        }
; 2616 :        else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	SHORT $LN102@read_edges

; 2617 :        { for ( i = 1 ; i < numv-1 ; i++ )

	mov	edx, DWORD PTR _numv$[ebp]
	lea	ecx, DWORD PTR [eax-2]
	dec	edx
	cmp	edx, ecx
	jle	SHORT $LN102@read_edges
	npad	2
$LL104@read_edges:

; 2618 :           { set_attr(vv[i],Q_MIDEDGE); 

	mov	eax, DWORD PTR [esi+ecx*4]
	mov	edi, eax
	shr	edi, 29					; 0000001dH
	imul	edi, 112				; 00000070H
	mov	edi, DWORD PTR _web[edi+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	or	DWORD PTR [eax+8], 4194304		; 00400000H
	mov	edi, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], edi

; 2619 :             set_vertex_edge(vv[i],elist[k]);

	mov	eax, DWORD PTR [esi+ecx*4]
	mov	edi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _elist
	mov	edi, DWORD PTR [edi+ebx*4]
	inc	ecx
	mov	DWORD PTR [eax+28], edi
	cmp	ecx, edx
	jl	SHORT $LL104@read_edges
$LN102@read_edges:

; 2620 :           } 
; 2621 :        }
; 2622 :     } 
; 2623 :     tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4

; 2624 :     if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	mov	edi, eax
	mov	DWORD PTR _tok, edi
	je	SHORT $LN296@read_edges

; 2625 :     { read_wrap_flag = 1;
; 2626 :       for ( i = 0 ; i < SDIM  ; i++ )

	xor	esi, esi
	mov	DWORD PTR _read_wrap_flag, 1
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN296@read_edges
	npad	9
$LL100@read_edges:

; 2627 :       switch ( tok )

	cmp	edi, 272				; 00000110H
	jg	$LN154@read_edges
	je	$LN89@read_edges
	sub	edi, 42					; 0000002aH
	je	SHORT $LN91@read_edges
	dec	edi
	je	$LN92@read_edges
	sub	edi, 2
	jne	$LN88@read_edges
$LN90@read_edges:

; 2640 : 
; 2641 :         case '*': 
; 2642 :             tok = ' '; /* so won't expect more input */
; 2643 :             tok = yylex(); 
; 2644 :            break;
; 2645 : 
; 2646 :         case '-':
; 2647 :         case UMINUS_TOK:
; 2648 :             wrap += NEGWRAP << (i*TWRAPBITS);

	mov	edx, 31					; 0000001fH
$LN311@read_edges:
	lea	ecx, DWORD PTR [esi+esi*2]
	add	ecx, ecx
	shl	edx, cl
	add	DWORD PTR _wrap$90697[ebp], edx
$LN91@read_edges:

; 2649 :             tok = ' '; /* so won't expect more input */
; 2650 :             tok = yylex();

	push	0
	mov	DWORD PTR _tok, 32			; 00000020H
	call	_kb_yylex
	mov	edi, eax
	mov	DWORD PTR _tok, edi
	add	esp, 4
$LN99@read_edges:

; 2625 :     { read_wrap_flag = 1;
; 2626 :       for ( i = 0 ; i < SDIM  ; i++ )

	inc	esi
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL100@read_edges
$LN296@read_edges:

; 2662 :       }
; 2663 :     }
; 2664 :     read_wrap_flag = 0;
; 2665 : 
; 2666 :     set_original(elist[k],(k-1)|((element_id)EDGE<<TYPESHIFT)|VALIDMASK);

	mov	eax, DWORD PTR _elist
	mov	DWORD PTR _read_wrap_flag, 0
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	ecx, DWORD PTR [ebx-1]
	or	ecx, 805306368				; 30000000H
	mov	DWORD PTR [eax+20], ecx

; 2667 : 
; 2668 :     if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	$LN87@read_edges

; 2669 :        set_edge_density(elist[k],1.0);

	mov	ecx, DWORD PTR _elist
	fld1
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	eax, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	fstp	QWORD PTR [ecx+40]

; 2670 :     else

	jmp	$LL85@read_edges
$LN92@read_edges:

; 2635 :         case '+':
; 2636 :             wrap += POSWRAP << (i*TWRAPBITS);

	mov	edx, 1

; 2637 :             tok = ' '; /* so won't expect more input */
; 2638 :             tok = yylex();
; 2639 :             break;

	jmp	$LN311@read_edges
$LN89@read_edges:

; 2651 :             break;
; 2652 : 
; 2653 :         case POW_TOK: /* ** */
; 2654 :              i++;            

	inc	esi

; 2655 :              tok = ' '; /* so won't expect more input */
; 2656 :              tok = yylex(); break;

	jmp	$LN91@read_edges
$LN154@read_edges:

; 2627 :       switch ( tok )

	sub	edi, 287				; 0000011fH
	je	$LN90@read_edges
	sub	edi, 21					; 00000015H
	je	SHORT $LN95@read_edges
$LN88@read_edges:

; 2657 :         default :
; 2658 :           kb_error(1133,"Edge wraps must immediately follow endpoints.\n",
; 2659 :               WARNING);

	push	2
	push	OFFSET ??_C@_0CP@DGBDNCJM@Edge?5wraps?5must?5immediately?5foll@
	push	1133					; 0000046dH
	call	_kb_error

; 2660 :           i = SDIM; /* assume wraps are missing */

	mov	esi, DWORD PTR _web+616

; 2661 :           break;

	mov	edi, DWORD PTR _tok
	add	esp, 12					; 0000000cH
	jmp	$LN99@read_edges
$LN95@read_edges:

; 2628 :       { case WRAP_TOK: 
; 2629 :             if ( read_const(&value) < 0 ) 

	lea	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_read_const
	add	esp, 4
	test	eax, eax
	jns	SHORT $LN94@read_edges

; 2630 :                 kb_error(4135,"Missing wrap value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BF@PFOEMAKJ@Missing?5wrap?5value?4?6?$AA@
	push	4135					; 00001027H
	call	_kb_error
	mov	edi, DWORD PTR _tok
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN93@read_edges
$LN94@read_edges:

; 2631 :             else tok = yylex();

	push	0
	call	_kb_yylex
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _tok, edi
$LN93@read_edges:

; 2632 :             wrap = (WRAPTYPE)value;

	fld	QWORD PTR _value$[ebp]
	call	__ftol2_sse

; 2633 :             i = SDIM;

	mov	esi, DWORD PTR _web+616
	mov	DWORD PTR _wrap$90697[ebp], eax

; 2634 :             break;

	jmp	$LN99@read_edges
$LN87@read_edges:

; 2671 :        set_edge_density(elist[k],0.0);

	mov	edx, DWORD PTR _elist
	fldz
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+40]
$LL85@read_edges:

; 2672 :     /* check attributes */
; 2673 :     for ( more_attr = 1; more_attr ; )
; 2674 :        switch ( tok )

	mov	ecx, DWORD PTR _tok
	mov	eax, ecx
	cmp	eax, 264				; 00000108H
	jg	SHORT $LN187@read_edges
	je	$LN299@read_edges
	test	eax, eax
	jmp	$LN316@read_edges
$LN187@read_edges:
	cmp	eax, 549				; 00000225H
	jg	$LN188@read_edges
	je	$LN299@read_edges
	sub	eax, 284				; 0000011cH
	cmp	eax, 236				; 000000ecH
	ja	$LN7@read_edges
	movzx	eax, BYTE PTR $LN288@read_edges[eax]
	jmp	DWORD PTR $LN318@read_edges[eax*4]
$LN79@read_edges:

; 2685 : 
; 2686 :                case ORIENTATION_TOK:
; 2687 :                   tok = gettok(INTEGER_TOK);

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 2688 :                   if ( tok != INTEGER_TOK )

	cmp	eax, 265				; 00000109H
	je	SHORT $LN78@read_edges

; 2689 :                   { kb_error(2107,"ORIENTATION value missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BM@NLDAKABN@ORIENTATION?5value?5missing?4?6?$AA@
	push	2107					; 0000083bH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2690 :                     break;

	jmp	SHORT $LL85@read_edges
$LN78@read_edges:

; 2691 :                   }
; 2692 :                   if ( yylval.i < 0 ) set_attr(elist[k],NEGBOUNDARY);

	cmp	DWORD PTR _yylval, 0
	jge	SHORT $LN196@read_edges
	mov	ecx, DWORD PTR _elist
	mov	eax, DWORD PTR [ecx+ebx*4]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 256			; 00000100H
	mov	DWORD PTR [eax+12], edx
$LN196@read_edges:

; 2693 :                   tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 2694 :                   break;

	jmp	$LL85@read_edges
$LN76@read_edges:

; 2695 : 
; 2696 :                case NONCONTENT_TOK:
; 2697 :                   set_attr(elist[k],NONCONTENT);

	mov	eax, DWORD PTR _elist
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	or	DWORD PTR [eax+8], 536870912		; 20000000H

; 2698 :                   tok = yylex();
; 2699 :                   break;

	jmp	$LN312@read_edges
$LN75@read_edges:

; 2700 : 
; 2701 :                case NO_REFINE_TOK:
; 2702 :                   set_attr(elist[k],NO_REFINE);

	mov	edx, DWORD PTR _elist
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	or	DWORD PTR [eax+8], 16777216		; 01000000H

; 2703 :                   tok = yylex();
; 2704 :                   break;

	jmp	$LN312@read_edges
$LN74@read_edges:

; 2705 : 
; 2706 :                case NO_TRANSFORM_TOK:
; 2707 :                   set_attr(elist[k],NO_TRANSFORM);

	mov	edx, DWORD PTR _elist
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+8]
	or	DWORD PTR [eax+12], 1

; 2743 :                    tok = yylex();

	push	0
	mov	DWORD PTR [eax+8], ecx
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_edges
$LN73@read_edges:

; 2708 :                   tok = yylex();
; 2709 :                   break;
; 2710 : 
; 2711 :                case BARE_TOK:
; 2712 :                   set_attr(elist[k],BARE_NAKED);

	mov	edx, DWORD PTR _elist
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	or	DWORD PTR [eax+8], 65536		; 00010000H

; 2713 :                   tok = yylex();
; 2714 :                   break;

	jmp	$LN312@read_edges
$LN72@read_edges:

; 2715 : 
; 2716 :                case ORIGINAL_TOK:
; 2717 :                   if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN71@read_edges

; 2718 :                   { kb_error(2108,"ORIGINAL number missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BK@NKBFEMPG@ORIGINAL?5number?5missing?4?6?$AA@
	push	2108					; 0000083cH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2719 :                     break;

	jmp	$LL85@read_edges
$LN71@read_edges:

; 2720 :                   }
; 2721 :                   set_original(elist[k],(yylval.i-1)|((element_id)EDGE<<TYPESHIFT)|VALIDMASK);

	mov	edx, DWORD PTR _elist
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	ecx, DWORD PTR _yylval
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	dec	ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	or	ecx, 805306368				; 30000000H

; 2743 :                    tok = yylex();

	push	0
	mov	DWORD PTR [eax+20], ecx
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_edges
$LN70@read_edges:

; 2722 :                   tok = yylex();
; 2723 :                   break;
; 2724 : 
; 2725 :             case WRAP_TOK:
; 2726 :                    if ( read_const(&value) < 0 ) 

	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jns	SHORT $LN69@read_edges

; 2727 :                       kb_error(1135,"Missing wrap value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BF@PFOEMAKJ@Missing?5wrap?5value?4?6?$AA@
	push	1135					; 0000046fH
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN68@read_edges
$LN69@read_edges:

; 2728 :                    else tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN68@read_edges:

; 2729 :                    wrap = (WRAPTYPE)value;

	fld	QWORD PTR _value$[ebp]
	call	__ftol2_sse

; 2730 :                    if ( !web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	mov	DWORD PTR _wrap$90697[ebp], eax
	jne	SHORT $LN67@read_edges

; 2731 :                        kb_error(1134,"Cannot do wraps without torus or symmetry group.\n",
; 2732 :                           DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DC@JNMGKLBI@Cannot?5do?5wraps?5without?5torus?5or@
	push	1134					; 0000046eH
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	$LL85@read_edges
$LN67@read_edges:

; 2733 :                    else set_edge_wrap(elist[k],wrap);

	mov	edx, DWORD PTR _elist
	mov	esi, DWORD PTR [edx+ebx*4]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN208@read_edges
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN208@read_edges:
	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+esi+784]
	mov	DWORD PTR [edx+ecx], eax

; 2734 :                    break;

	jmp	$LL85@read_edges
$LN65@read_edges:

; 2735 : 
; 2736 :             case FIXED_TOK:
; 2737 :                    set_attr(elist[k],FIXED);  

	mov	edx, DWORD PTR _elist
	mov	eax, DWORD PTR [edx+ebx*4]

; 2738 :                    tok = yylex();
; 2739 :                    break;

	jmp	$LN314@read_edges
$LN63@read_edges:

; 2744 :                    break;
; 2745 : 
; 2746 :             case COLOR_TOK:
; 2747 :                    if ( read_const(&value) <= 0 )

	lea	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN62@read_edges

; 2748 :                    { kb_error(1136,"Color missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BA@IPLAMOJB@Color?5missing?4?6?$AA@
	push	1136					; 00000470H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2749 :                      break;

	jmp	$LL85@read_edges
$LN62@read_edges:

; 2750 :                    }
; 2751 :                    set_edge_color(elist[k],(short)value);

	fld	QWORD PTR _value$[ebp]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _elist
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	push	0
	mov	WORD PTR [edx+56], ax
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_edges
$LN61@read_edges:

; 2752 :                    tok = yylex();
; 2753 :                    break;
; 2754 : 
; 2755 :             case BOUNDARY_TOK:
; 2756 :             case BOUNDARY_NAME_TOK:
; 2757 :                    if ( tok == BOUNDARY_TOK )

	cmp	ecx, 408				; 00000198H
	jne	SHORT $LN60@read_edges

; 2758 :                      tok = gettok(INTEGER_TOK);

	push	265					; 00000109H
	call	_gettok
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _tok, ecx
$LN60@read_edges:

; 2759 :                    if ( (tok != INTEGER_TOK) && ( tok != BOUNDARY_NAME_TOK ) )  

	cmp	ecx, 265				; 00000109H
	je	SHORT $LN271@read_edges
	cmp	ecx, 520				; 00000208H
	je	SHORT $LN58@read_edges

; 2760 :                        { kb_error(2109,"Need boundary number or name.\n",
; 2761 :                            DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@CEDOMNKL@Need?5boundary?5number?5or?5name?4?6?$AA@
	push	2109					; 0000083dH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2762 :                           break;

	jmp	$LL85@read_edges
$LN271@read_edges:

; 2763 :                        }
; 2764 :                    if ( tok == INTEGER_TOK )
; 2765 :                     { bnum = abs(yylval.i);

	mov	eax, DWORD PTR _yylval
	cdq
	xor	eax, edx
	sub	eax, edx

; 2766 :                       if ( (bnum >= web.bdrymax) 
; 2767 :                               || !(web.boundaries[bnum].attr & IN_USE) )

	cmp	eax, DWORD PTR _web+768
	jge	SHORT $LN297@read_edges
	mov	edx, DWORD PTR _web+776
	mov	ecx, eax
	imul	ecx, 136				; 00000088H
	mov	ecx, DWORD PTR [ecx+edx+32]
	and	ecx, 32					; 00000020H
	xor	edx, edx
	or	ecx, edx
	jne	$LN55@read_edges
$LN297@read_edges:

; 2768 :                        {
; 2769 :                           sprintf(errmsg,
; 2770 :                               "Bad boundary number %d for edge %d.\n",bnum,k);

	push	ebx
	push	eax
	push	OFFSET ??_C@_0CF@HDBOPHDM@Bad?5boundary?5number?5?$CFd?5for?5edge?5@
	push	OFFSET _errmsg
	call	_sprintf

; 2771 :                           kb_error(1137,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1137					; 00000471H
	call	_kb_error

; 2772 :                           yylex();

	push	0
	call	_kb_yylex
	add	esp, 32					; 00000020H

; 2773 :                           break;

	jmp	$LL85@read_edges
$LN58@read_edges:

; 2774 :                        }          
; 2775 :                     }
; 2776 :                     else
; 2777 :                     { bnum = globals(yylval.i)->value.bnum;

	mov	eax, DWORD PTR _yylval
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN155@read_edges
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN157@read_edges
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN156@read_edges
$LN157@read_edges:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN155@read_edges
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN156@read_edges
$LN155@read_edges:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN156@read_edges:
	mov	eax, DWORD PTR [eax+64]
$LN55@read_edges:

; 2778 :                     }
; 2779 :                    set_attr(elist[k],BOUNDARY);

	mov	ecx, DWORD PTR _elist
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 128			; 00000080H
	mov	DWORD PTR [ecx+12], edx

; 2780 :                    if ( yylval.i < 0 )  set_attr(vlist[k],NEGBOUNDARY); 

	cmp	DWORD PTR _yylval, 0
	jge	SHORT $LN216@read_edges
	mov	ecx, DWORD PTR _vlist
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 256			; 00000100H
	mov	DWORD PTR [ecx+12], edx
$LN216@read_edges:

; 2781 :                    set_edge_boundary_num(elist[k],bnum);

	mov	ecx, DWORD PTR _E_BOUNDARY_ATTR
	test	ecx, ecx
	je	SHORT $LN163@read_edges
	mov	edx, DWORD PTR _elist
	imul	ecx, 240				; 000000f0H
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	esi, DWORD PTR _web+124
	add	ecx, DWORD PTR _web+216
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+esi+64]
	mov	DWORD PTR [edx+ecx], eax

; 2782 :                    bdry = get_edge_boundary(elist[k]); 

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN163@read_edges
	mov	edx, DWORD PTR _elist
	imul	eax, 240				; 000000f0H
	mov	ecx, DWORD PTR [edx+ebx*4]
	add	eax, DWORD PTR _web+216
	mov	edx, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [ecx+eax]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN164@read_edges
$LN163@read_edges:
	xor	eax, eax
$LN164@read_edges:

; 2783 :                    if ( (bdry->attr & CON_ENERGY) && (yytext[0] == '0') )

	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 64					; 00000040H
	xor	edx, edx
	or	ecx, edx
	je	SHORT $LN218@read_edges
	mov	ecx, DWORD PTR _yytext
	cmp	BYTE PTR [ecx], 48			; 00000030H
	jne	SHORT $LN218@read_edges

; 2784 :                       set_attr(elist[k], BDRY_ENERGY);

	mov	edx, DWORD PTR _elist
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 512			; 00000200H
	mov	DWORD PTR [ecx+12], edx
$LN218@read_edges:

; 2785 :                    if ( bdry->attr & CON_CONTENT )

	mov	eax, DWORD PTR [eax+32]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN313@read_edges

; 2786 :                       set_attr(elist[k], BDRY_CONTENT);

	mov	eax, DWORD PTR _elist
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	or	DWORD PTR [eax+8], 4096			; 00001000H

; 2787 :                    tok = yylex();
; 2788 :                    break;

	jmp	$LN312@read_edges
$LN51@read_edges:

; 2789 : 
; 2790 :           case CONSTRAINT_TOK:
; 2791 :           case CONSTRAINT_NAME_TOK:
; 2792 :              if ( tok == CONSTRAINT_TOK )

	cmp	ecx, 320				; 00000140H
	jne	SHORT $LL49@read_edges

; 2829 :                   set_attr(elist[k], BDRY_CONTENT);

$LN228@read_edges:

; 2793 :                tok = gettok(INTEGER_TOK);

	push	265					; 00000109H
	call	_gettok
	mov	ecx, eax
	mov	DWORD PTR _tok, ecx
	add	esp, 4
	npad	2
$LL49@read_edges:

; 2794 :              while ( (tok == INTEGER_TOK) || (tok==CONSTRAINT_NAME_TOK) )

	cmp	ecx, 265				; 00000109H
	je	SHORT $LN270@read_edges
	cmp	ecx, 519				; 00000207H
	jne	$LL85@read_edges

; 2799 :                  cnum = globals(yylval.i)->value.cnum;

	mov	eax, DWORD PTR _yylval
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN165@read_edges
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN167@read_edges
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN166@read_edges
$LN270@read_edges:

; 2795 :              { struct constraint *con;
; 2796 :                if ( tok == INTEGER_TOK )
; 2797 :                  cnum = abs(yylval.i);

	mov	eax, DWORD PTR _yylval
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _cnum$[ebp], eax

; 2798 :                else

	jmp	SHORT $LN45@read_edges
$LN167@read_edges:

; 2799 :                  cnum = globals(yylval.i)->value.cnum;

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN165@read_edges
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN166@read_edges
$LN165@read_edges:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN166@read_edges:
	mov	edx, DWORD PTR [eax+64]
	mov	DWORD PTR _cnum$[ebp], edx
	mov	eax, edx
$LN45@read_edges:

; 2800 :                con = get_constraint(cnum);

	mov	ecx, DWORD PTR _web+652
	mov	edi, eax
	and	edi, 1073741823				; 3fffffffH
	imul	edi, 176				; 000000b0H
	lea	esi, DWORD PTR [edi+ecx]

; 2801 :                if ( (cnum >= web.maxcon) || !(con->attr & IN_USE) )

	cmp	eax, DWORD PTR _web+644
	jge	$LN258@read_edges
	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [esi+36]
	mov	eax, ecx
	mov	DWORD PTR tv2456[ebp+4], edx
	and	eax, 32					; 00000020H
	xor	edx, edx
	or	eax, edx
	je	$LN258@read_edges

; 2806 :                  break;
; 2807 :                }
; 2808 :                /* check consistency of number of components */
; 2809 :                if ( (con->attr & CON_ENERGY) ||
; 2810 :                     ((con->attr & CON_CONTENT) && web.dimension==SOAPFILM) )

	mov	eax, ecx
	and	eax, 64					; 00000040H
	or	eax, edx
	mov	edx, DWORD PTR _web+620
	jne	SHORT $LN301@read_edges
	and	ecx, 128				; 00000080H
	xor	eax, eax
	or	ecx, eax
	je	$LN38@read_edges
	cmp	edx, 2
	jne	$LN38@read_edges
$LN301@read_edges:

; 2811 :                { if ( web.dimension == 1 )

	cmp	edx, 1
	jne	SHORT $LN40@read_edges

; 2812 :                  { sprintf(errmsg,"Edge %s is on constraint %s, which has an energy integral.  Probably a bad idea in the string model.\n",ELNAME(elist[k]),con->name);

	mov	eax, DWORD PTR _elist
	mov	eax, DWORD PTR [eax+ebx*4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN171@read_edges
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN172@read_edges
$LN171@read_edges:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN172@read_edges:
	push	esi
	push	eax
	push	OFFSET ??_C@_0GG@EEBCIKGE@Edge?5?$CFs?5is?5on?5constraint?5?$CFs?0?5whi@
	push	OFFSET _errmsg
	call	_sprintf

; 2813 :                    kb_error(3918,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	3918					; 00000f4eH
	jmp	SHORT $LN317@read_edges
$LN40@read_edges:

; 2814 :                  }
; 2815 :                  else if ( con->compcount != compcount )

	mov	ecx, DWORD PTR [esi+44]
	cmp	ecx, DWORD PTR _compcount$[ebp]
	je	SHORT $LN38@read_edges

; 2816 :                  { sprintf(errmsg,
; 2817 : "Inconsistent number of components in edge %s constraint %s content or energy integrands.\n",
; 2818 :                     ELNAME(elist[k]),con->name);

	mov	edx, DWORD PTR _elist
	mov	eax, DWORD PTR [edx+ebx*4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN173@read_edges
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN174@read_edges
$LN173@read_edges:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN174@read_edges:
	push	esi
	push	eax
	push	OFFSET ??_C@_0FK@MDDCAAB@Inconsistent?5number?5of?5component@
	push	OFFSET _errmsg
	call	_sprintf

; 2819 :                    kb_error(1139,errmsg, WARNING);

	push	2
	push	OFFSET _errmsg
	push	1139					; 00000473H
$LN317@read_edges:
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN38@read_edges:

; 2820 :                  }
; 2821 :                }
; 2822 :                set_attr(elist[k],CONSTRAINT);

	mov	eax, DWORD PTR _elist
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 1024			; 00000400H
	mov	DWORD PTR [eax+12], ecx

; 2823 :                if ( yylval.i < 0 )  set_attr(elist[k],NEGBOUNDARY); 

	cmp	DWORD PTR _yylval, 0
	jge	SHORT $LN224@read_edges
	mov	edx, DWORD PTR _elist
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 256			; 00000100H
	mov	DWORD PTR [eax+12], ecx
$LN224@read_edges:

; 2824 :                set_e_constraint_map(elist[k],cnum);

	mov	edx, DWORD PTR _cnum$[ebp]
	mov	eax, DWORD PTR _elist
	mov	ecx, DWORD PTR [eax+ebx*4]
	push	edx
	push	ecx
	call	_set_e_constraint_map

; 2825 :                constr = get_constraint(cnum); 
; 2826 :                if ( (constr->attr & CON_ENERGY) && (yytext[0] != '0') )

	mov	edx, DWORD PTR _web+652
	mov	eax, DWORD PTR [edi+edx+32]
	lea	ecx, DWORD PTR [edi+edx+32]
	and	eax, 64					; 00000040H
	xor	edx, edx
	add	esp, 8
	or	eax, edx
	je	SHORT $LN302@read_edges
	mov	eax, DWORD PTR _yytext
	cmp	BYTE PTR [eax], 48			; 00000030H
	je	SHORT $LN302@read_edges

; 2827 :                   set_attr(elist[k], BDRY_ENERGY);

	mov	edx, DWORD PTR _elist
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 512			; 00000200H
	mov	DWORD PTR [eax+12], edx
$LN302@read_edges:

; 2828 :                if ( constr->attr & CON_CONTENT )

	mov	eax, DWORD PTR [ecx]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN228@read_edges

; 2829 :                   set_attr(elist[k], BDRY_CONTENT);

	mov	eax, DWORD PTR _elist
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 4096			; 00001000H
	mov	DWORD PTR [eax+12], ecx

; 2830 :                tok = gettok(INTEGER_TOK);
; 2831 :             }

	jmp	$LN228@read_edges
$LN258@read_edges:

; 2802 :                { sprintf(errmsg,
; 2803 :                         "Bad constraint number %d for edge %d.\n",cnum,k);

	mov	edx, DWORD PTR _cnum$[ebp]
	push	ebx
	push	edx
	push	OFFSET ??_C@_0CH@JCKGDEOH@Bad?5constraint?5number?5?$CFd?5for?5edg@
	push	OFFSET _errmsg
	call	_sprintf

; 2804 :                  kb_error(1138,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1138					; 00000472H
	call	_kb_error

; 2805 :                  tok=yylex();

	push	0
	call	_kb_yylex
	add	esp, 32					; 00000020H
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_edges
$LN34@read_edges:

; 2832 :           break;
; 2833 : 
; 2834 :           case DENSITY_TOK:
; 2835 :                if ( read_const(&value) <= 0 )

	lea	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN33@read_edges

; 2836 :                   kb_error(1140,"Missing DENSITY value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BI@PJJAKHC@Missing?5DENSITY?5value?4?6?$AA@
	push	1140					; 00000474H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN32@read_edges
$LN33@read_edges:

; 2837 :                else tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN32@read_edges:

; 2838 :                set_attr(elist[k],DENSITY);

	mov	ecx, DWORD PTR _elist
	mov	eax, DWORD PTR [ecx+ebx*4]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	or	DWORD PTR [eax+8], 16			; 00000010H
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], edx

; 2839 :                set_edge_density(elist[k],value);

	mov	eax, DWORD PTR _elist
	mov	ecx, DWORD PTR [eax+ebx*4]
	fld	QWORD PTR _value$[ebp]
	mov	edx, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	fstp	QWORD PTR [eax+40]

; 2840 :                break;

	jmp	$LL85@read_edges
$LN31@read_edges:

; 2841 : 
; 2842 :         case QUANTITY_NAME_TOK: /* name of quantity */ 
; 2843 :          { int qnum = yylval.i;

	mov	esi, DWORD PTR _yylval

; 2844 :            tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 2845 :            if ( tok == '-' || tok == UMINUS_TOK )

	cmp	eax, 45					; 0000002dH
	je	SHORT $LN29@read_edges
	cmp	eax, 287				; 0000011fH
	je	SHORT $LN29@read_edges

; 2848 :            }
; 2849 :            else 
; 2850 :              apply_quantity(elist[k],qnum);

	mov	ecx, DWORD PTR _elist
	mov	edx, DWORD PTR [ecx+ebx*4]
	push	esi
	push	edx
	call	_apply_quantity
	add	esp, 8
	jmp	$LL85@read_edges
$LN29@read_edges:

; 2846 :            { apply_quantity(inverse_id(elist[k]),qnum);

	mov	eax, DWORD PTR _elist
	mov	ecx, DWORD PTR [eax+ebx*4]
	xor	ecx, 134217728				; 08000000H
	push	esi
	push	ecx
	call	_apply_quantity

; 2847 :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_edges
$LN27@read_edges:

; 2851 :            break;
; 2852 :          }
; 2853 :           
; 2854 :         case IDENT_TOK:  /* maybe method or quantity */
; 2855 :            if ( globals(yylval.i)->flags & METHOD_NAME )

	mov	esi, DWORD PTR _yylval
	mov	edi, DWORD PTR _dymem
	mov	edx, esi
	and	edx, -16777216				; ff000000H
	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN175@read_edges
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN177@read_edges
	mov	edi, DWORD PTR _localbase
	mov	eax, esi
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edi]
	mov	edi, DWORD PTR _dymem
	jmp	SHORT $LN176@read_edges
$LN177@read_edges:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN175@read_edges
	mov	ecx, DWORD PTR _web+5656
	mov	eax, esi
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN176@read_edges
$LN175@read_edges:
	mov	ecx, DWORD PTR _web+5652
	mov	eax, esi
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [ecx+edi]
$LN176@read_edges:
	test	DWORD PTR [ecx+192], 1024		; 00000400H
	je	SHORT $LN26@read_edges

; 2856 :               apply_method(elist[k],yytext);

	mov	edx, DWORD PTR _yytext
	mov	eax, DWORD PTR _elist
	mov	ecx, DWORD PTR [eax+ebx*4]
	push	edx
	push	ecx
	call	_apply_method
	add	esp, 8
	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_edges
$LN26@read_edges:

; 2857 :            else if ( globals(yylval.i)->flags & QUANTITY_NAME )

	cmp	edx, 268435456				; 10000000H
	jne	SHORT $LN185@read_edges
	mov	edx, DWORD PTR _web+5652
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+edi]
	jmp	SHORT $LN182@read_edges
$LN185@read_edges:
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN183@read_edges
	mov	ecx, DWORD PTR _localbase
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN182@read_edges
$LN183@read_edges:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN181@read_edges
	mov	edx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN182@read_edges
$LN181@read_edges:
	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+edi]
$LN182@read_edges:
	test	BYTE PTR [eax+192], -128		; ffffff80H
	je	SHORT $LN24@read_edges

; 2858 :               apply_quantity(elist[k],yylval.i);

	mov	eax, DWORD PTR _elist
	mov	ecx, DWORD PTR [eax+ebx*4]
	push	esi
	push	ecx
	call	_apply_quantity
	add	esp, 8
	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_edges
$LN24@read_edges:

; 2859 :            else
; 2860 :             { sprintf(errmsg,"Illegal use of identifier '%s'.\n",yytext);

	mov	edx, DWORD PTR _yytext
	push	edx
	push	OFFSET ??_C@_0CB@LOIAMNAG@Illegal?5use?5of?5identifier?5?8?$CFs?8?4?6@
	push	OFFSET _errmsg
	call	_sprintf

; 2861 :               kb_error(1141,yytext,DATAFILE_ERROR);

	mov	eax, DWORD PTR _yytext
	push	6
	push	eax
	push	1141					; 00000475H
	call	_kb_error
	add	esp, 24					; 00000018H
	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_edges
$LN16@read_edges:

; 2882 :            break;
; 2883 :         }
; 2884 : 
; 2885 :         case QUANTITY_TOK:
; 2886 :         /* see if quantity */
; 2887 :         tok = yylex();

	push	0
	call	_kb_yylex

; 2888 :         if ( tok == QUANTITY_NAME_TOK )
; 2889 :         { /* have named quantity/method pair */
; 2890 :           char qname[32];
; 2891 :           int qnum = yylval.i;
; 2892 :           
; 2893 :           strncpy(qname,yytext,sizeof(qname));

	mov	ecx, DWORD PTR _yytext
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 336				; 00000150H
	jne	SHORT $LN15@read_edges
	mov	esi, DWORD PTR _yylval
	push	32					; 00000020H
	push	ecx
	lea	edx, DWORD PTR _qname$90942[ebp]
	push	edx
	call	_strncpy

; 2894 :           tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tok, eax

; 2895 :           if ( tok == '-' || tok == UMINUS_TOK )

	cmp	eax, 45					; 0000002dH
	je	SHORT $LN13@read_edges
	cmp	eax, 287				; 0000011fH
	je	SHORT $LN13@read_edges

; 2898 :           }
; 2899 :           else 
; 2900 :             apply_quantity(elist[k],qnum);

	mov	eax, DWORD PTR _elist
	mov	ecx, DWORD PTR [eax+ebx*4]
	push	esi
	push	ecx
	call	_apply_quantity
	add	esp, 8
	jmp	$LL85@read_edges
$LN13@read_edges:

; 2896 :           { apply_quantity(inverse_id(elist[k]),qnum);

	mov	edx, DWORD PTR _elist
	mov	eax, DWORD PTR [edx+ebx*4]
	xor	eax, 134217728				; 08000000H
	push	esi
	push	eax
	call	_apply_quantity

; 2897 :             tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_edges
$LN15@read_edges:

; 2901 :         }
; 2902 :         else 
; 2903 :         { sprintf(errmsg,"Undefined quantity: %s\n",yytext);

	push	ecx
	push	OFFSET ??_C@_0BI@JFIOCEAN@Undefined?5quantity?3?5?$CFs?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 2904 :           kb_error(1144,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1144					; 00000478H
	call	_kb_error
	add	esp, 24					; 00000018H

; 2905 :         }
; 2906 :         break;

	jmp	$LL85@read_edges
$LN10@read_edges:

; 2907 : 
; 2908 :         case ENERGY_TOK:
; 2909 :         /* obsolete surface energy */
; 2910 :            kb_error(1147,
; 2911 :   "'Energy' obsolete. Implement edge integral energy with named quantity.\n",
; 2912 :             DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0EI@HNEECJIN@?8Energy?8?5obsolete?4?5Implement?5edg@
	push	1147					; 0000047bH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2913 :            break;

	jmp	$LL85@read_edges
$LN188@read_edges:

; 2672 :     /* check attributes */
; 2673 :     for ( more_attr = 1; more_attr ; )
; 2674 :        switch ( tok )

	cmp	eax, 35084				; 0000890cH
	jg	$LN189@read_edges
	je	$LN8@read_edges
	cmp	eax, 566				; 00000236H
	je	$LN81@read_edges
	cmp	eax, 35024				; 000088d0H
	jne	$LN7@read_edges

; 2862 :             }
; 2863 :            tok = yylex();
; 2864 :            break;
; 2865 : 
; 2866 :         case METHOD_TOK:  /* apply method instance to edge */
; 2867 :            tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 2868 :            if ( tok != METHOD_NAME_TOK )

	cmp	eax, 414				; 0000019eH
	je	SHORT $LN21@read_edges

; 2869 :            { kb_error(1950,"Missing method instance name.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@MGOCAHJG@Missing?5method?5instance?5name?4?6?$AA@
	push	1950					; 0000079eH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2870 :              break;

	jmp	$LL85@read_edges
$LN21@read_edges:

; 2871 :            }
; 2872 :            // else fall through to METHOD_NAME_TOK
; 2873 : 
; 2874 :         case METHOD_NAME_TOK:
; 2875 :         { int qnum = yylval.i;      

	mov	esi, DWORD PTR _yylval

; 2876 :            tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 2877 :            if ( tok == UMINUS_TOK  || tok == '-' )

	cmp	eax, 287				; 0000011fH
	je	SHORT $LN18@read_edges
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN18@read_edges

; 2880 :            }
; 2881 :            else apply_method_num(elist[k],qnum);

	mov	edx, DWORD PTR _elist
	mov	eax, DWORD PTR [edx+ebx*4]
	push	esi
	push	eax
	call	_apply_method_num
	add	esp, 8
	jmp	$LL85@read_edges
$LN18@read_edges:

; 2878 :            { apply_method_num(inverse_id(elist[k]),qnum);

	mov	ecx, DWORD PTR _elist
	mov	edx, DWORD PTR [ecx+ebx*4]
	xor	edx, 134217728				; 08000000H
	push	esi
	push	edx
	call	_apply_method_num

; 2879 :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_edges
$LN81@read_edges:

; 2675 :           {
; 2676 :                case EXTRA_ATTRIBUTE_TOK:
; 2677 :                case ARRAY_ATTRIBUTE_TOK:
; 2678 :                   if ( yylval.etype != EDGE )

	mov	eax, DWORD PTR _yylval+24
	cmp	eax, 1
	je	SHORT $LN80@read_edges

; 2679 :                   { sprintf(errmsg,"'%s' is a %s attribute, not an edge attribute.\n",
; 2680 :                         yytext,typenames[yylval.etype]);

	mov	eax, DWORD PTR _typenames[eax*4]
	mov	ecx, DWORD PTR _yytext
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DA@JHENGICO@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5an?5e@
	push	OFFSET _errmsg
	call	_sprintf

; 2681 :                     kb_error(4320,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	4320					; 000010e0H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN80@read_edges:

; 2682 :                   }
; 2683 :                   read_extra(elist[k],yylval.qnum);

	mov	edx, DWORD PTR _yylval+4
	mov	eax, DWORD PTR _elist
	mov	ecx, DWORD PTR [eax+ebx*4]
	push	edx
	push	ecx
	call	_read_extra
	add	esp, 8

; 2684 :                   break;

	jmp	$LL85@read_edges
$LN8@read_edges:

; 2914 : 
; 2915 :           case FACES_TOK: case BODIES_TOK: case READ_TOK: case LEAD_INTEGER_TOK: 
; 2916 :           case LEAD_INTEGER_AT_TOK:
; 2917 :           case NO_TOKEN:    more_attr = 0 ; break;  /* error recovery */
; 2918 :           case UNPUTTED_TOK: 
; 2919 :                 kb_error(3702,
; 2920 :                    "Internal error: forgot to get lookahead token.\n",
; 2921 :                        WARNING);

	push	2
	push	OFFSET ??_C@_0DA@MGFNEFND@Internal?5error?3?5forgot?5to?5get?5lo@
	push	3702					; 00000e76H
	call	_kb_error

; 2922 :                 tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_edges
$LN189@read_edges:

; 2672 :     /* check attributes */
; 2673 :     for ( more_attr = 1; more_attr ; )
; 2674 :        switch ( tok )

	sub	eax, 35085				; 0000890dH
	je	SHORT $LN64@read_edges
	dec	eax
$LN316@read_edges:
	je	SHORT $LN299@read_edges
$LN7@read_edges:

; 2923 :                 break;
; 2924 :           default: 
; 2925 :               sprintf(errmsg,"Unexpected token: %s\n",yytext);

	mov	edx, DWORD PTR _yytext
	push	edx
	push	OFFSET ??_C@_0BG@BKFJJJKH@Unexpected?5token?3?5?$CFs?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 2926 :               kb_error(2110,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2110					; 0000083eH
	call	_kb_error

; 2927 :               tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_edges
$LN64@read_edges:

; 2740 : 
; 2741 :             case EFIXED_TOK: /* edge only, not vertices */ 
; 2742 :                    set_attr(elist[k],FIXED);  

	mov	eax, DWORD PTR _elist
	mov	eax, DWORD PTR [eax+ebx*4]
$LN314@read_edges:
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	or	DWORD PTR [eax+8], 64			; 00000040H
$LN312@read_edges:
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], ecx
$LN313@read_edges:

; 2743 :                    tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_edges
$LN299@read_edges:

; 2928 :               break;
; 2929 : 
; 2930 :        }
; 2931 : 
; 2932 :     if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	$LN294@read_edges

; 2933 :     {  set_edge_wrap(elist[k],wrap);

	mov	edx, DWORD PTR _elist
	mov	esi, DWORD PTR [edx+ebx*4]
	mov	eax, DWORD PTR _wrap$90697[ebp]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN235@read_edges
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN235@read_edges:
	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+esi+784]
	mov	DWORD PTR [edx+ecx], eax

; 2934 :        if ( (web.modeltype == QUADRATIC) && !have_mid )

	cmp	DWORD PTR _web+628, 2
	jne	$LN294@read_edges
	cmp	DWORD PTR _have_mid$90696[ebp], 0
	jne	$LN294@read_edges

; 2935 :        { /* have to adjust midpoints */
; 2936 :          REAL *x = get_coord(get_edge_midv(elist[k]));

	mov	edx, DWORD PTR _elist
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	esi, DWORD PTR _web+104
	mov	edx, DWORD PTR [esi+edx+64]
	mov	edi, DWORD PTR _web+12
	mov	DWORD PTR tv2623[ebp], edx
	mov	edx, DWORD PTR _web+124
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [esi+ecx+8]
	and	esi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+esi*4]
	add	edi, DWORD PTR tv2623[ebp]

; 2937 :          REAL *t = get_coord(get_edge_tailv(elist[k]));

	test	eax, 134217728				; 08000000H
	je	SHORT $LN237@read_edges
	mov	esi, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN236@read_edges
$LN237@read_edges:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN236@read_edges:
	mov	esi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+eax*4]

; 2938 :          REAL h[MAXCOORD];
; 2939 :          (*sym_wrap)(get_coord(get_edge_headv(elist[k])),h,wrap);

	mov	eax, DWORD PTR _elist
	mov	eax, DWORD PTR [eax+ebx*4]
	add	esi, DWORD PTR tv2623[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN241@read_edges
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [ecx+edx]
	jmp	SHORT $LN240@read_edges
$LN241@read_edges:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR [eax+ecx]
$LN240@read_edges:
	mov	edx, DWORD PTR _wrap$90697[ebp]
	push	edx
	mov	edx, DWORD PTR _web+12
	lea	eax, DWORD PTR _h$90974[ebp]
	push	eax
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	add	eax, DWORD PTR tv2623[ebp]
	push	eax
	call	DWORD PTR _sym_wrap

; 2940 :          for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN294@read_edges
	fld	QWORD PTR __real@3fe0000000000000
	lea	ecx, DWORD PTR _h$90974[ebp]
	mov	edx, ecx
	sub	esi, ecx
	sub	edi, edx
$LN305@read_edges:
	lea	ecx, DWORD PTR [esi+eax*8]

; 2941 :             x[i] = 0.5*(t[i] + h[i]);

	fld	QWORD PTR _h$90974[ebp+ecx]
	lea	edx, DWORD PTR [edi+eax*8]
	fadd	QWORD PTR _h$90974[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _h$90974[ebp+edx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN305@read_edges

; 2940 :          for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN294@read_edges:

; 2942 :        }
; 2943 :     }
; 2944 :     if ((get_eattr(elist[k])&(BOUNDARY|CONSTRAINT)) == (BOUNDARY|CONSTRAINT))

	mov	eax, DWORD PTR _elist
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	edx, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1152				; 00000480H
	xor	ecx, ecx
	cmp	eax, 1152				; 00000480H
	jne	$LL135@read_edges
	test	ecx, ecx
	jne	$LL135@read_edges

; 2945 :         kb_error(1148,"Cannot have constraint and boundary.",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CF@NGLIKJND@Cannot?5have?5constraint?5and?5bound@
	push	1148					; 0000047cH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2946 :    }

	jmp	$LL135@read_edges
$LN256@read_edges:

; 2563 :           { free_element(elist[k]);   

	mov	eax, DWORD PTR _elist
	mov	ecx, DWORD PTR [eax+ebx*4]
	push	ecx
	call	_free_element

; 2564 : 		    elist[k] = NULLID;

	mov	edx, DWORD PTR _elist
	add	esp, 4
	mov	DWORD PTR [edx+ebx*4], 0

; 2565 : 			if ( addload_flag && (vercount == 2) )

	cmp	DWORD PTR _addload_flag, 0
	je	$LN120@read_edges
	mov	edi, 2
	cmp	DWORD PTR _vercount$90714[ebp], edi
	jne	$LN120@read_edges

; 2566 : 		    { for ( i = 0 ; i < vmaxlist ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _vmaxlist, esi
	jle	SHORT $LN300@read_edges
	npad	7
$LL306@read_edges:

; 2567 : 				if ( valid_element(vlist[i]) )

	mov	eax, DWORD PTR _vlist
	mov	ecx, DWORD PTR [eax+esi*4]
	push	ecx
	call	_valid_element
	add	esp, 4
	test	eax, eax
	je	SHORT $LN118@read_edges

; 2568 : 					free_element(vlist[i]);

	mov	edx, DWORD PTR _vlist
	mov	eax, DWORD PTR [edx+esi*4]
	push	eax
	call	_free_element
	add	esp, 4
$LN118@read_edges:

; 2566 : 		    { for ( i = 0 ; i < vmaxlist ; i++ )

	inc	esi
	cmp	esi, DWORD PTR _vmaxlist
	jl	SHORT $LL306@read_edges
$LN300@read_edges:

; 2569 : 			  if ( web.modeltype == QUADRATIC )
; 2570 : 				kb_error(5437,"addload datafile is linear model, but current model is quadratic.\n",
; 2571 : 				  RECOVERABLE);

	push	1
	cmp	DWORD PTR _web+628, edi
	jne	SHORT $LN115@read_edges
	push	OFFSET ??_C@_0ED@FDOHNEFP@addload?5datafile?5is?5linear?5model@
	push	5437					; 0000153dH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	ebx
	pop	edi
	pop	esi

; 2947 : 
; 2948 : #ifdef MPI_EVOLVER
; 2949 :   myfree((char*)vdummy);
; 2950 : #endif
; 2951 : 
; 2952 : } /* end read_edges() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN115@read_edges:

; 2572 : 			  else
; 2573 : 				kb_error(5438,"addload datafile is linear model, but current model is Lagrange.\n",
; 2574 : 				  RECOVERABLE);

	push	OFFSET ??_C@_0EC@PDLLHJBK@addload?5datafile?5is?5linear?5model@
	push	5438					; 0000153eH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	ebx
	pop	edi
	pop	esi

; 2947 : 
; 2948 : #ifdef MPI_EVOLVER
; 2949 :   myfree((char*)vdummy);
; 2950 : #endif
; 2951 : 
; 2952 : } /* end read_edges() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN120@read_edges:

; 2575 : 		    } 
; 2576 : 		    else
; 2577 : 			kb_error(1131,"Too few vertices for edge.\n",DATAFILE_ERROR); 

	push	6
	push	OFFSET ??_C@_0BM@OFNCGKJA@Too?5few?5vertices?5for?5edge?4?6?$AA@
	push	1131					; 0000046bH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	ebx
	pop	edi
	pop	esi

; 2947 : 
; 2948 : #ifdef MPI_EVOLVER
; 2949 :   myfree((char*)vdummy);
; 2950 : #endif
; 2951 : 
; 2952 : } /* end read_edges() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN257@read_edges:

; 2602 :           { sprintf(errmsg,"Edge %d: vertex %d is not defined.\n",k,yylval.i);

	push	ecx
	push	ebx
	push	OFFSET ??_C@_0CE@DKGMBMOB@Edge?5?$CFd?3?5vertex?5?$CFd?5is?5not?5define@
	push	OFFSET _errmsg
	call	_sprintf

; 2603 :             kb_error(1132,errmsg, RECOVERABLE /*DATAFILE_ERROR*/ );

	push	1
	push	OFFSET _errmsg
	push	1132					; 0000046cH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN307@read_edges:
	pop	ebx
$LN134@read_edges:

; 2947 : 
; 2948 : #ifdef MPI_EVOLVER
; 2949 :   myfree((char*)vdummy);
; 2950 : #endif
; 2951 : 
; 2952 : } /* end read_edges() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN318@read_edges:
	DD	$LN81@read_edges
	DD	$LN27@read_edges
	DD	$LN63@read_edges
	DD	$LN299@read_edges
	DD	$LN72@read_edges
	DD	$LN70@read_edges
	DD	$LN65@read_edges
	DD	$LN34@read_edges
	DD	$LN51@read_edges
	DD	$LN31@read_edges
	DD	$LN73@read_edges
	DD	$LN61@read_edges
	DD	$LN79@read_edges
	DD	$LN21@read_edges
	DD	$LN10@read_edges
	DD	$LN75@read_edges
	DD	$LN74@read_edges
	DD	$LN76@read_edges
	DD	$LN16@read_edges
	DD	$LN7@read_edges
$LN288@read_edges:
	DB	0
	DB	19					; 00000013H
	DB	1
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	2
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	3
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	4
	DB	19					; 00000013H
	DB	5
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	6
	DB	7
	DB	19					; 00000013H
	DB	8
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	9
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	3
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	10					; 0000000aH
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	13					; 0000000dH
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	14					; 0000000eH
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	19					; 00000013H
	DB	17					; 00000011H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	8
	DB	11					; 0000000bH
_read_edges ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@CHADONEE@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5a?5fa@ ; `string'
PUBLIC	??_C@_0BI@BHPPHJKA@Missing?5quantity?5name?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@MDBJLIJJ@Surface?5energies?5obsolete?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@LHEMMEFB@Bad?5constraint?5number?5?$CFd?5for?5fac@ ; `string'
PUBLIC	??_C@_0CG@NOPNANDI@Bad?5boundary?5number?5?$CFd?5for?5facet@ ; `string'
PUBLIC	??_C@_0BI@IHKMFJBP@Opacity?5value?5missing?4?6?$AA@ ; `string'
PUBLIC	??_C@_07IJGPCJHC@opacity?$AA@			; `string'
PUBLIC	??_C@_0BK@LANJCDLM@Backcolor?5value?5missing?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@DELOLHDF@Frontcolor?5value?5missing?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@OGOMJBJM@Missing?5color?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@DIEMLGNJ@Illegal?5phase?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@DKJJCAOO@Phase?5missing?4?6?$AA@	; `string'
PUBLIC	??_C@_0CI@KHMGPKDK@Phases?5on?5facets?5only?5in?5STRING?5@ ; `string'
PUBLIC	??_C@_0BH@EDLGBDIJ@Phases?5not?5in?5effect?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@NLJGPPIJ@Missing?5DENSITY?5or?5TENSION?5value@ ; `string'
PUBLIC	??_C@_0BJ@ICLHKEOI@ORIGINAL?5value?5missing?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@DFPGPIEE@Need?5facet?5vertices?5in?5Lagrange?5@ ; `string'
PUBLIC	??_C@_0DA@IEDFFOBH@Inconsistency?5in?5face?5?$CFd?5first?5a@ ; `string'
PUBLIC	??_C@_0BM@HAIGIAMA@Face?5?$CFd?5has?5too?5few?5edges?4?6?$AA@ ; `string'
PUBLIC	??_C@_0EN@HCKOHEMK@Inconsistency?5in?5face?5?$CFd?0?5edge?5?$CF@ ; `string'
PUBLIC	??_C@_0CD@GEOGAJGJ@Facet?5?$CFd?3?5edge?5?$CFd?5is?5not?5defined@ ; `string'
PUBLIC	??_C@_0BN@NGNHMCAM@Too?5few?5vertices?5for?5facet?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@BHJOBNNN@Facet?5?$CFd?3?5vertex?5?$CFd?5is?5not?5defin@ ; `string'
PUBLIC	??_C@_0BO@FIGLFJNJ@Too?5many?5vertices?5for?5facet?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@CKBCJFKD@Duplicate?5face?5number?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@JKCGMBJD@Face?5number?5must?5be?5positive?4?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_read_faces
EXTRN	_set_f_constraint_map:PROC
EXTRN	_F_BOUNDARY_ATTR:DWORD
EXTRN	_add_attribute:PROC
EXTRN	_F_PHASE_ATTR:DWORD
EXTRN	_phasemax:DWORD
EXTRN	_set_facet_fe:PROC
EXTRN	_msg:DWORD
EXTRN	_new_facetedge:PROC
EXTRN	_new_facet:PROC
EXTRN	_NULLFACETEDGE:DWORD
;	COMDAT ??_C@_0DA@CHADONEE@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5a?5fa@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DA@CHADONEE@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5a?5fa@ DB ''''
	DB	'%s'' is a %s attribute, not a facet attribute.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BHPPHJKA@Missing?5quantity?5name?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@BHPPHJKA@Missing?5quantity?5name?4?6?$AA@ DB 'Missing quantity '
	DB	'name.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MDBJLIJJ@Surface?5energies?5obsolete?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@MDBJLIJJ@Surface?5energies?5obsolete?4?6?$AA@ DB 'Surface energ'
	DB	'ies obsolete.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LHEMMEFB@Bad?5constraint?5number?5?$CFd?5for?5fac@
CONST	SEGMENT
??_C@_0CH@LHEMMEFB@Bad?5constraint?5number?5?$CFd?5for?5fac@ DB 'Bad cons'
	DB	'traint number %d for face %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NOPNANDI@Bad?5boundary?5number?5?$CFd?5for?5facet@
CONST	SEGMENT
??_C@_0CG@NOPNANDI@Bad?5boundary?5number?5?$CFd?5for?5facet@ DB 'Bad boun'
	DB	'dary number %d for facet %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IHKMFJBP@Opacity?5value?5missing?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@IHKMFJBP@Opacity?5value?5missing?4?6?$AA@ DB 'Opacity value mis'
	DB	'sing.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07IJGPCJHC@opacity?$AA@
CONST	SEGMENT
??_C@_07IJGPCJHC@opacity?$AA@ DB 'opacity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LANJCDLM@Backcolor?5value?5missing?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@LANJCDLM@Backcolor?5value?5missing?4?6?$AA@ DB 'Backcolor value'
	DB	' missing.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DELOLHDF@Frontcolor?5value?5missing?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@DELOLHDF@Frontcolor?5value?5missing?4?6?$AA@ DB 'Frontcolor val'
	DB	'ue missing.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OGOMJBJM@Missing?5color?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BG@OGOMJBJM@Missing?5color?5value?4?6?$AA@ DB 'Missing color value'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DIEMLGNJ@Illegal?5phase?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BG@DIEMLGNJ@Illegal?5phase?5value?4?6?$AA@ DB 'Illegal phase value'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DKJJCAOO@Phase?5missing?4?6?$AA@
CONST	SEGMENT
??_C@_0BA@DKJJCAOO@Phase?5missing?4?6?$AA@ DB 'Phase missing.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KHMGPKDK@Phases?5on?5facets?5only?5in?5STRING?5@
CONST	SEGMENT
??_C@_0CI@KHMGPKDK@Phases?5on?5facets?5only?5in?5STRING?5@ DB 'Phases on '
	DB	'facets only in STRING model.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EDLGBDIJ@Phases?5not?5in?5effect?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@EDLGBDIJ@Phases?5not?5in?5effect?4?6?$AA@ DB 'Phases not in eff'
	DB	'ect.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NLJGPPIJ@Missing?5DENSITY?5or?5TENSION?5value@
CONST	SEGMENT
??_C@_0CD@NLJGPPIJ@Missing?5DENSITY?5or?5TENSION?5value@ DB 'Missing DENS'
	DB	'ITY or TENSION value.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ICLHKEOI@ORIGINAL?5value?5missing?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@ICLHKEOI@ORIGINAL?5value?5missing?4?6?$AA@ DB 'ORIGINAL value m'
	DB	'issing.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DFPGPIEE@Need?5facet?5vertices?5in?5Lagrange?5@
CONST	SEGMENT
??_C@_0CI@DFPGPIEE@Need?5facet?5vertices?5in?5Lagrange?5@ DB 'Need facet '
	DB	'vertices in Lagrange model.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@IEDFFOBH@Inconsistency?5in?5face?5?$CFd?5first?5a@
CONST	SEGMENT
??_C@_0DA@IEDFFOBH@Inconsistency?5in?5face?5?$CFd?5first?5a@ DB 'Inconsis'
	DB	'tency in face %d first and last edges.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HAIGIAMA@Face?5?$CFd?5has?5too?5few?5edges?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@HAIGIAMA@Face?5?$CFd?5has?5too?5few?5edges?4?6?$AA@ DB 'Face %d'
	DB	' has too few edges.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@HCKOHEMK@Inconsistency?5in?5face?5?$CFd?0?5edge?5?$CF@
CONST	SEGMENT
??_C@_0EN@HCKOHEMK@Inconsistency?5in?5face?5?$CFd?0?5edge?5?$CF@ DB 'Inco'
	DB	'nsistency in face %d, edge %d tail vertex disagrees with prev'
	DB	'ious head.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GEOGAJGJ@Facet?5?$CFd?3?5edge?5?$CFd?5is?5not?5defined@
CONST	SEGMENT
??_C@_0CD@GEOGAJGJ@Facet?5?$CFd?3?5edge?5?$CFd?5is?5not?5defined@ DB 'Fac'
	DB	'et %d: edge %d is not defined.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NGNHMCAM@Too?5few?5vertices?5for?5facet?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@NGNHMCAM@Too?5few?5vertices?5for?5facet?4?6?$AA@ DB 'Too few ve'
	DB	'rtices for facet.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BHJOBNNN@Facet?5?$CFd?3?5vertex?5?$CFd?5is?5not?5defin@
CONST	SEGMENT
??_C@_0CF@BHJOBNNN@Facet?5?$CFd?3?5vertex?5?$CFd?5is?5not?5defin@ DB 'Fac'
	DB	'et %d: vertex %d is not defined.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FIGLFJNJ@Too?5many?5vertices?5for?5facet?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@FIGLFJNJ@Too?5many?5vertices?5for?5facet?4?6?$AA@ DB 'Too many '
	DB	'vertices for facet.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CKBCJFKD@Duplicate?5face?5number?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BK@CKBCJFKD@Duplicate?5face?5number?5?$CFd?6?$AA@ DB 'Duplicate fa'
	DB	'ce number %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JKCGMBJD@Face?5number?5must?5be?5positive?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@JKCGMBJD@Face?5number?5must?5be?5positive?4?6?$AA@ DB 'Face num'
	DB	'ber must be positive.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\lexinit.c
CONST	ENDS
;	COMDAT _read_faces
_TEXT	SEGMENT
_value$ = -180						; size = 8
_first_fe$91057 = -172					; size = 4
tv2739 = -168						; size = 4
_one$91219 = -168					; size = 4
_e$ = -168						; size = 4
_old_fe$ = -164						; size = 4
tv2604 = -160						; size = 4
_tt$91084 = -160					; size = 4
_hh$91069 = -160					; size = 4
_numv$ = -156						; size = 4
tv2708 = -152						; size = 4
_e_id$91061 = -152					; size = 4
_k$ = -148						; size = 4
_vercount$91090 = -144					; size = 4
_vercount$91037 = -144					; size = 4
_edge_count$91016 = -144				; size = 4
_this_facet_id$ = -140					; size = 4
_name$91301 = -136					; size = 100
_qname$91310 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_read_faces PROC					; COMDAT

; 2966 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2967 :   int i,k;
; 2968 :   int e;
; 2969 :   facetedge_id old_fe;
; 2970 :   facet_id this_facet_id;
; 2971 :   int cnum,bnum;
; 2972 :   struct constraint *constr;
; 2973 :   REAL value;  /* for constant expression values */
; 2974 :   int numv; /* vertices to read with facet */
; 2975 : #ifdef MPI_EVOLVER
; 2976 :   struct element *vdummy = (struct element *)mycalloc(web.sizes[VERTEX],1);
; 2977 :   struct element *edummy = (struct element *)mycalloc(web.sizes[EDGE],1);
; 2978 :   int facet_task,edge_task;
; 2979 :   int split_loop_flag = 0; /* string, set if task number of any edge is foreign */
; 2980 : #endif
; 2981 : 
; 2982 :   /* optional attributes */
; 2983 :   EXTRAS(EDGE)[F_NORMAL_ATTR].array_spec.sizes[0] = SDIM;

	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _web+216

; 2984 :   expand_attribute(FACET,F_VERTICES_ATTR,&web.skel[FACET].ctrlpts);

	push	OFFSET _web+232
	push	1
	push	2
	mov	DWORD PTR [edx+eax+576], ecx
	call	_expand_attribute

; 2985 : 
; 2986 :   if ( web.representation == SIMPLEX )

	mov	eax, 3
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+624, eax
	jne	SHORT $LN146@read_faces

; 2987 :   { if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, eax
	jne	SHORT $LN145@read_faces

; 2988 :         numv = binom_coeff(web.lagrange_order+web.dimension,web.dimension); 

	mov	eax, DWORD PTR _web+620
	mov	ecx, DWORD PTR _web+632
	push	eax
	add	ecx, eax
	push	ecx
	call	_binom_coeff
	add	esp, 8
	mov	DWORD PTR _numv$[ebp], eax
	jmp	SHORT $LN140@read_faces
$LN145@read_faces:

; 2989 :     else numv = web.dimension;

	mov	edx, DWORD PTR _web+620
	mov	DWORD PTR _numv$[ebp], edx

; 2990 :   }
; 2991 :   else if ( web.modeltype == LAGRANGE )

	jmp	SHORT $LN140@read_faces
$LN146@read_faces:
	cmp	DWORD PTR _web+628, eax
	jne	SHORT $LN142@read_faces

; 2992 :   { numv = binom_coeff(web.lagrange_order+web.dimension,web.dimension);

	mov	eax, DWORD PTR _web+620
	mov	ecx, DWORD PTR _web+632
	push	eax
	add	ecx, eax
	push	ecx
	call	_binom_coeff
	add	esp, 8
	mov	DWORD PTR _numv$[ebp], eax
	jmp	SHORT $LN140@read_faces
$LN142@read_faces:

; 2993 :   }
; 2994 :   else if ( web.modeltype == QUADRATIC ) numv = 0;

	mov	DWORD PTR _numv$[ebp], 0
$LN140@read_faces:

; 2995 :   else numv = 0;
; 2996 : 
; 2997 :   /* read in faces */
; 2998 :   fmaxlist = MAXLIST;
; 2999 :   flist = (facet_id *)mycalloc(sizeof(facet_id),fmaxlist);

	push	2999					; 00000bb7H
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	push	100					; 00000064H
	push	4
	mov	DWORD PTR _fmaxlist, 100		; 00000064H
	call	_kb_calloc

; 3000 : 
; 3001 :   tok = yylex();

	push	0
	mov	DWORD PTR _flist, eax
	call	_kb_yylex
	add	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	DWORD PTR _tok, eax
	push	edi
$LL138@read_faces:

; 3002 :   while ( (tok == LEAD_INTEGER_TOK) || (tok == LEAD_INTEGER_AT_TOK) )

	mov	eax, DWORD PTR _tok
	cmp	eax, 264				; 00000108H
	je	SHORT $LN136@read_faces
	cmp	eax, 549				; 00000225H
	jne	$LN137@read_faces
$LN136@read_faces:

; 3003 :   { int more_attr;
; 3004 :     int edge_count = 0;
; 3005 : 
; 3006 : 
; 3007 :     #ifdef MPI_EVOLVER
; 3008 :     /* test task number, for MPI */
; 3009 :     if ( tok == LEAD_INTEGER_TOK )
; 3010 :        facet_task = 1;  /* default to task 1 */
; 3011 :     else facet_task = yylval.qnum;
; 3012 :     if ( facet_task >= mpi_nprocs || facet_task < 1 )
; 3013 :     { sprintf(errmsg,"Task number %d must be between 1 and %d\n",
; 3014 :          facet_task,mpi_nprocs-1);
; 3015 :       kb_error(5009,errmsg,RECOVERABLE);
; 3016 :     }
; 3017 :     if ( facet_task != this_task )
; 3018 :     { /* skip this facet */
; 3019 :       int flag = 0;
; 3020 :       while ( !flag ) 
; 3021 :       { tok = yylex();
; 3022 :         switch (tok)
; 3023 :         { case LEAD_INTEGER_TOK: 
; 3024 :           case LEAD_INTEGER_AT_TOK:
; 3025 :           case BODIES_TOK:
; 3026 :           case READ_TOK:
; 3027 :           case 0:
; 3028 :             flag = 1;
; 3029 :             break;
; 3030 :         }
; 3031 :       }
; 3032 :       continue;  /* next facet */
; 3033 :     }
; 3034 :     #endif
; 3035 :     
; 3036 :     k = yylval.i;

	mov	edi, DWORD PTR _yylval
	xor	ebx, ebx
	mov	DWORD PTR _edge_count$91016[ebp], ebx
	mov	DWORD PTR _k$[ebp], edi

; 3037 :     if ( k < 1 ) 

	cmp	edi, 1
	jge	SHORT $LN345@read_faces

; 3038 :         kb_error(2111,"Face number must be positive.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@JKCGMBJD@Face?5number?5must?5be?5positive?4?6?$AA@
	push	2111					; 0000083fH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN345@read_faces:

; 3039 :     old_fe = NULLFACETEDGE;
; 3040 : 
; 3041 :     {
; 3042 :       if ( k >= fmaxlist )

	mov	eax, DWORD PTR _fmaxlist
	mov	edx, DWORD PTR _NULLFACETEDGE
	mov	DWORD PTR _old_fe$[ebp], edx
	cmp	edi, eax
	jl	SHORT $LN341@read_faces

; 3043 :       { int spot = fmaxlist;

	mov	esi, eax
	npad	2
$LL133@read_faces:

; 3044 :         while ( k >= fmaxlist )
; 3045 :           fmaxlist *= 2;

	add	eax, eax
	cmp	edi, eax
	jge	SHORT $LL133@read_faces

; 3046 :         flist = (facet_id *)kb_realloc((char *)flist,
; 3047 :                               fmaxlist*sizeof(facet_id));

	mov	ecx, DWORD PTR _flist
	mov	DWORD PTR _fmaxlist, eax
	push	3047					; 00000be7H
	add	eax, eax
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	add	eax, eax
	push	eax
	push	ecx
	call	_KB_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _flist, eax

; 3048 :         for ( ; spot < fmaxlist ; spot++ ) flist[spot] = NULLID;

	cmp	esi, DWORD PTR _fmaxlist
	jge	SHORT $LN341@read_faces
$LL340@read_faces:
	mov	edx, DWORD PTR _flist
	mov	DWORD PTR [edx+esi*4], ebx
	inc	esi
	cmp	esi, DWORD PTR _fmaxlist
	jl	SHORT $LL340@read_faces
	xor	ebx, ebx
$LN341@read_faces:

; 3049 :       }
; 3050 :       if ( valid_id(flist[k]) )

	mov	eax, DWORD PTR _flist
	test	DWORD PTR [eax+edi*4], 268435456	; 10000000H
	je	SHORT $LN346@read_faces

; 3051 :       { sprintf(errmsg,"Duplicate face number %d\n",k);

	push	edi
	push	OFFSET ??_C@_0BK@CKBCJFKD@Duplicate?5face?5number?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 3052 :         kb_error(1152,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1152					; 00000480H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN346@read_faces:

; 3053 :       }
; 3054 :   
; 3055 :       move_to_free_front(FACET,k); /* so id will be k */

	push	edi
	push	2
	call	_move_to_free_front
	add	esp, 8

; 3056 :       flist[k] = new_facet();

	call	_new_facet
	mov	ecx, DWORD PTR _flist
	mov	DWORD PTR [ecx+edi*4], eax

; 3057 :       set_original(flist[k],(k-1)|((element_id)FACET<<TYPESHIFT)|VALIDMASK);

	mov	edx, DWORD PTR _flist
	mov	eax, DWORD PTR [edx+edi*4]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	ecx, DWORD PTR [edi-1]
	or	ecx, 1342177280				; 50000000H
	mov	DWORD PTR [eax+20], ecx

; 3058 :       this_facet_id = flist[k];
; 3059 :     }
; 3060 : 
; 3061 : 
; 3062 :     if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	mov	ecx, DWORD PTR _flist
	mov	esi, DWORD PTR [ecx+edi*4]
	mov	DWORD PTR _this_facet_id$[ebp], esi

; 3066 :       while ( (tok = gettok(INTEGER_TOK)) == INTEGER_TOK )

	push	265					; 00000109H
	jne	$LN127@read_faces

; 3063 :     { /* read vertex list */
; 3064 :       int vercount = 0;
; 3065 :       vertex_id *v = get_facet_vertices(this_facet_id);

	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+328
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	mov	DWORD PTR _vercount$91037[ebp], ebx
	add	esi, esi
	mov	ebx, DWORD PTR [esi+edx]
	add	ebx, DWORD PTR [ecx+eax+304]

; 3066 :       while ( (tok = gettok(INTEGER_TOK)) == INTEGER_TOK )

	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	jne	$LN347@read_faces
$LL126@read_faces:

; 3067 :       { if ( vercount++ > numv )

	mov	eax, DWORD PTR _vercount$91037[ebp]
	mov	edx, eax
	inc	eax
	mov	DWORD PTR _vercount$91037[ebp], eax
	cmp	edx, DWORD PTR _numv$[ebp]
	jle	SHORT $LN124@read_faces

; 3068 :           kb_error(1153,"Too many vertices for facet.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BO@FIGLFJNJ@Too?5many?5vertices?5for?5facet?4?6?$AA@
	push	1153					; 00000481H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN124@read_faces:

; 3069 : #ifdef MPI_EVOLVER
; 3070 :         if ( yylval.qnum == 0 )
; 3071 :              yylval.qnum = 1;
; 3072 :         if ( yylval.qnum >= mpi_nprocs )
; 3073 :         { sprintf(errmsg,"Task number %d exceeds number of tasks running, %d\n",
; 3074 :              yylval.qnum,mpi_nprocs-1);
; 3075 :           kb_error(5010,errmsg,RECOVERABLE);
; 3076 :         }
; 3077 :         if ( yylval.qnum != this_task )
; 3078 :         { *v = ((element_id)VERTEX << TYPESHIFT) | VALIDMASK | 
; 3079 :              (yylval.i-1) | ((element_id)yylval.qnum << TASK_ID_SHIFT);  
; 3080 :           memset(vdummy,0,web.sizes[VERTEX]);
; 3081 :           vdummy->self_id = *v;
; 3082 :           vdummy->attr = ALLOCATED|NEWELEMENT;
; 3083 :           mpi_add_remote_element(vdummy);
; 3084 :           v++;
; 3085 :         }
; 3086 :         else
; 3087 : #endif
; 3088 :         if ( (yylval.i >= vmaxlist) || !valid_id(vlist[yylval.i]) )

	mov	eax, DWORD PTR _yylval
	cmp	eax, DWORD PTR _vmaxlist
	jge	SHORT $LN122@read_faces
	mov	ecx, DWORD PTR _vlist
	mov	ecx, DWORD PTR [ecx+eax*4]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN122@read_faces

; 3091 :         }
; 3092 :         else 
; 3093 :           *(v++) = vlist[yylval.i];

	mov	DWORD PTR [ebx], ecx
	add	ebx, 4
	jmp	SHORT $LN121@read_faces
$LN122@read_faces:

; 3089 :         { sprintf(errmsg,"Facet %d: vertex %d is not defined.\n",k,yylval.i);

	push	eax
	push	edi
	push	OFFSET ??_C@_0CF@BHJOBNNN@Facet?5?$CFd?3?5vertex?5?$CFd?5is?5not?5defin@
	push	OFFSET _errmsg
	call	_sprintf

; 3090 :           kb_error(1154,errmsg,RECOVERABLE /*DATAFILE_ERROR*/);

	push	1
	push	OFFSET _errmsg
	push	1154					; 00000482H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN121@read_faces:

; 3066 :       while ( (tok = gettok(INTEGER_TOK)) == INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	$LL126@read_faces
$LN347@read_faces:

; 3094 :       }
; 3095 :       if ( vercount < numv )

	mov	edx, DWORD PTR _vercount$91037[ebp]
	cmp	edx, DWORD PTR _numv$[ebp]
	jge	$LN94@read_faces

; 3096 :         kb_error(1155,"Too few vertices for facet.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BN@NGNHMCAM@Too?5few?5vertices?5for?5facet?4?6?$AA@
	push	1155					; 00000483H

; 3097 :     }
; 3098 :     else  /* facet_edge representation */

	jmp	$LN381@read_faces
$LN127@read_faces:

; 3099 :     { facetedge_id fe = NULLID;

	xor	esi, esi

; 3100 :       facetedge_id first_fe = NULLID;

	mov	DWORD PTR _first_fe$91057[ebp], ebx

; 3101 : 
; 3102 :       while ( (tok = gettok(INTEGER_TOK)) == INTEGER_TOK )

	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	jne	$LN117@read_faces
	npad	7
$LL118@read_faces:

; 3103 :       { edge_id e_id;
; 3104 :         facetedge_id edge_fe;
; 3105 :             
; 3106 :         edge_count++;
; 3107 :         e = yylval.i;

	mov	ecx, DWORD PTR _yylval
	inc	DWORD PTR _edge_count$91016[ebp]

; 3108 : 
; 3109 : #ifdef MPI_EVOLVER
; 3110 :         edge_task = yylval.qnum;
; 3111 :         if ( edge_task == 0 )  /* for non-partitioned datafiles */
; 3112 :              edge_task = 1;
; 3113 :         if ( edge_task >= mpi_nprocs )
; 3114 :         { sprintf(errmsg,"Edge task number %d exceeds number of tasks running, %d\n",
; 3115 :              edge_task,mpi_nprocs-1);
; 3116 :           kb_error(5011,errmsg,RECOVERABLE);
; 3117 :         }
; 3118 :         if ( edge_task != this_task )
; 3119 :         { if (web.representation==SOAPFILM ) 
; 3120 :           {
; 3121 :           e_id = ((element_id)EDGE << TYPESHIFT) | VALIDMASK | (abs(e)-1) |
; 3122 :              ((element_id)edge_task << TASK_ID_SHIFT);  
; 3123 :           memset(edummy,0,web.sizes[EDGE]);
; 3124 :           edummy->self_id = e_id;
; 3125 :           edummy->attr = ALLOCATED | NEWELEMENT;
; 3126 :           mpi_add_remote_element(edummy);
; 3127 :           if ( e < 0 ) invert(e_id);
; 3128 :           }
; 3129 :           else /* string */
; 3130 :           { 
; 3131 :             split_loop_flag = 1; /* so don't try to close loop at end */
; 3132 :             continue; /* only doing local edges */
; 3133 :           }
; 3134 :         }
; 3135 :         else
; 3136 : #endif
; 3137 :         { if ( abs(e) >= emaxlist )

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _e$[ebp], ecx
	cmp	eax, DWORD PTR _emaxlist
	jl	SHORT $LN116@read_faces

; 3138 :           { sprintf(errmsg,"Facet %d: edge %d is not defined.\n",k,abs(e));

	push	eax
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@GEOGAJGJ@Facet?5?$CFd?3?5edge?5?$CFd?5is?5not?5defined@
	push	OFFSET _errmsg
	call	_sprintf

; 3139 :             e = 0;
; 3140 :             kb_error(1156,errmsg,RECOVERABLE /*DATAFILE_ERROR*/ );

	push	1
	push	OFFSET _errmsg
	push	1156					; 00000484H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 3141 :             continue;

	jmp	$LN251@read_faces
$LN116@read_faces:

; 3142 :           }
; 3143 :           e_id =  e > 0 ? elist[e] : edge_inverse(elist[-e]);

	mov	edx, DWORD PTR _elist
	test	ecx, ecx
	jle	SHORT $LN149@read_faces
	mov	ebx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN382@read_faces
$LN149@read_faces:
	lea	eax, DWORD PTR [ecx*4]
	sub	edx, eax
	mov	ebx, DWORD PTR [edx]
	xor	ebx, 134217728				; 08000000H
$LN382@read_faces:
	mov	DWORD PTR _e_id$91061[ebp], ebx

; 3144 :         }
; 3145 : 
; 3146 :         if ( !valid_id(e_id) )

	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN115@read_faces

; 3147 :         { sprintf(errmsg,"Facet %d: edge %d is not defined.\n",k,e);

	mov	eax, DWORD PTR _k$[ebp]
	push	ecx
	push	eax
	push	OFFSET ??_C@_0CD@GEOGAJGJ@Facet?5?$CFd?3?5edge?5?$CFd?5is?5not?5defined@
	push	OFFSET _errmsg
	call	_sprintf

; 3148 :           kb_error(1157,errmsg,RECOVERABLE /*DATAFILE_ERROR*/);

	push	1
	push	OFFSET _errmsg
	push	1157					; 00000485H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 3149 :           continue;

	jmp	$LN251@read_faces
$LN115@read_faces:

; 3150 :         }
; 3151 : 
; 3152 :         fe = new_facetedge(this_facet_id,e_id);

	mov	ecx, DWORD PTR _this_facet_id$[ebp]
	push	ebx
	push	ecx
	call	_new_facetedge
	add	esp, 8

; 3153 :         if ( valid_id(old_fe) )

	test	DWORD PTR _old_fe$[ebp], 268435456	; 10000000H
	mov	esi, eax
	je	$LN114@read_faces

; 3154 :         { 
; 3155 :           #ifndef MPI_EVOLVER
; 3156 : 		  vertex_id hh,tt;
; 3157 :           hh = get_fe_headv(old_fe);

	mov	eax, DWORD PTR _old_fe$[ebp]
	mov	edx, DWORD PTR _web+460
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+edx]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN189@read_faces
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	edx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
	jmp	SHORT $LN383@read_faces
$LN189@read_faces:
	mov	edx, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx+304]
	mov	edx, DWORD PTR _web+124
	mov	ebx, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN383@read_faces:

; 3158 :           tt = get_fe_tailv(fe);

	mov	ebx, DWORD PTR _web+460
	mov	DWORD PTR _hh$91069[ebp], eax
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ebx+eax*4]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ebx+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN195@read_faces
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _web+636
	lea	edx, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [edx+ecx]
	jmp	SHORT $LN194@read_faces
$LN195@read_faces:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [ecx+eax]
$LN194@read_faces:

; 3159 :           if ( !equal_id(hh,tt) ) 

	cmp	DWORD PTR _hh$91069[ebp], ecx
	je	SHORT $LN344@read_faces

; 3160 :           { sprintf(msg,"Inconsistency in face %d, edge %d tail vertex disagrees with previous head.\n",
; 3161 :                          k,e);

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _msg
	push	ecx
	push	edx
	push	OFFSET ??_C@_0EN@HCKOHEMK@Inconsistency?5in?5face?5?$CFd?0?5edge?5?$CF@
	push	eax
	call	_sprintf

; 3162 :             kb_error(2112,msg,DATAFILE_ERROR);

	mov	ecx, DWORD PTR _msg
	push	6
	push	ecx
	push	2112					; 00000840H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN344@read_faces:

; 3163 :           }
; 3164 :           #endif
; 3165 :           set_next_edge(old_fe,fe);

	test	DWORD PTR _old_fe$[ebp], 134217728	; 08000000H
	mov	ebx, DWORD PTR _e_id$91061[ebp]
	je	SHORT $LN199@read_faces
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edi+eax]
	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [ecx+28], edx
	jmp	SHORT $LN112@read_faces
$LN199@read_faces:
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [edi+edx]
	mov	DWORD PTR [eax+32], esi

; 3166 :         }
; 3167 : 		else 

	jmp	SHORT $LN112@read_faces
$LN114@read_faces:

; 3168 : 			first_fe = fe;

	mov	DWORD PTR _first_fe$91057[ebp], esi
$LN112@read_faces:

; 3169 :         set_prev_edge(fe,old_fe);

	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv2708[ebp], eax
	je	SHORT $LN206@read_faces
	test	esi, 134217728				; 08000000H
	je	SHORT $LN204@read_faces
	mov	eax, DWORD PTR _old_fe$[ebp]
	mov	edx, DWORD PTR _web+460
	xor	eax, 134217728				; 08000000H
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+32], eax
	jmp	SHORT $LN203@read_faces
$LN204@read_faces:
	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _old_fe$[ebp]
	mov	DWORD PTR [ecx+28], edx
$LN203@read_faces:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN206@read_faces:

; 3170 :         old_fe = fe;
; 3171 : 
; 3172 : #ifdef MPI_EVOLVER
; 3173 :        if ( (web.representation == SOAPFILM) || (facet_task == this_task) )
; 3174 : #endif
; 3175 :          if ( !valid_id(get_facet_fe(this_facet_id)) )

	mov	edi, DWORD PTR _this_facet_id$[ebp]
	push	edi
	mov	DWORD PTR _old_fe$[ebp], esi
	call	_get_facet_fe
	add	esp, 4
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN111@read_faces

; 3176 :            set_facet_fe(this_facet_id,fe);

	push	esi
	push	edi
	call	_set_facet_fe
	add	esp, 8
$LN111@read_faces:

; 3177 : 
; 3178 :         /* add to edge facet list, not in geometric order */
; 3179 :         edge_fe = get_edge_fe(e_id);

	mov	eax, DWORD PTR _web+124
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+eax]
	test	eax, eax
	jne	SHORT $LN209@read_faces
	xor	edi, edi
	jmp	SHORT $LN210@read_faces
$LN209@read_faces:
	mov	eax, DWORD PTR [eax+28]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN208@read_faces
	xor	eax, 134217728				; 08000000H
$LN208@read_faces:
	mov	edi, eax
$LN210@read_faces:

; 3180 :         if ( valid_id(edge_fe) )

	test	edi, 268435456				; 10000000H
	je	$LN110@read_faces

; 3181 :         { /* insert in chain */
; 3182 :           set_next_facet(fe,get_next_facet(edge_fe));

	mov	ecx, DWORD PTR _web+460
	mov	eax, edi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv2739[ebp], eax
	mov	edx, edi
	je	SHORT $LN213@read_faces
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	eax, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN212@read_faces
$LN213@read_faces:
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	eax, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [eax+40]
$LN212@read_faces:
	cmp	DWORD PTR tv2708[ebp], 0
	je	$LN343@read_faces
	mov	ebx, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN217@read_faces
	xor	eax, 134217728				; 08000000H
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR [ecx+36], eax
	jmp	SHORT $LN385@read_faces
$LN217@read_faces:
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR [ecx+40], eax
$LN385@read_faces:

; 3183 :           set_prev_facet(fe,edge_fe);

	cmp	DWORD PTR tv2708[ebp], 0
	mov	ecx, DWORD PTR _web+460
	je	SHORT $LN343@read_faces
	mov	eax, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN222@read_faces
	xor	edi, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+40], edi
	jmp	SHORT $LN221@read_faces
$LN222@read_faces:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+36], edi
$LN221@read_faces:
	mov	eax, DWORD PTR _global_timestamp
	mov	ecx, DWORD PTR _web+460
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN343@read_faces:

; 3184 :           set_prev_facet(get_next_facet(fe),fe);

	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN227@read_faces
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN226@read_faces
$LN227@read_faces:
	mov	eax, DWORD PTR [eax+40]
$LN226@read_faces:
	test	eax, 268435456				; 10000000H
	je	SHORT $LN233@read_faces
	test	eax, 134217728				; 08000000H
	je	SHORT $LN231@read_faces
	mov	edi, esi
	xor	edi, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+40], edi
	jmp	SHORT $LN230@read_faces
$LN231@read_faces:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [eax+36], esi
$LN230@read_faces:
	mov	eax, DWORD PTR _global_timestamp
	mov	ecx, DWORD PTR _web+460
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN233@read_faces:

; 3185 :           set_next_facet(edge_fe,fe);

	cmp	DWORD PTR tv2739[ebp], 0
	je	SHORT $LN236@read_faces
	mov	ecx, DWORD PTR [edx+ecx]
	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR [ecx+36], eax
	jmp	$LN251@read_faces
$LN236@read_faces:
	mov	edx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [edx+40], esi

; 3186 :         }
; 3187 :         else

	jmp	$LN251@read_faces
$LN110@read_faces:

; 3188 :         { set_next_facet(fe,fe);

	cmp	DWORD PTR tv2708[ebp], 0
	je	$LN362@read_faces
	mov	eax, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN241@read_faces
	mov	edi, DWORD PTR _web+460
	xor	eax, 134217728				; 08000000H
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [edx+36], eax
	jmp	SHORT $LN361@read_faces
$LN241@read_faces:
	mov	edx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+40], esi
$LN361@read_faces:

; 3189 :           set_prev_facet(fe,fe);

	cmp	DWORD PTR tv2708[ebp], 0
	je	SHORT $LN362@read_faces
	mov	edx, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN246@read_faces
	mov	edi, DWORD PTR _web+460
	xor	edx, 134217728				; 08000000H
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [eax+40], edx
	jmp	SHORT $LN245@read_faces
$LN246@read_faces:
	mov	eax, DWORD PTR _web+460
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [edx+36], esi
$LN245@read_faces:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN362@read_faces:

; 3190 :           set_edge_fe(e_id,fe);      /* link edge to rest of world */

	mov	eax, esi
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN250@read_faces
	xor	eax, 134217728				; 08000000H
$LN250@read_faces:
	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN251@read_faces:

; 3101 : 
; 3102 :       while ( (tok = gettok(INTEGER_TOK)) == INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	$LL118@read_faces
$LN117@read_faces:

; 3191 :         }
; 3192 :       }
; 3193 : 
; 3194 :       if ( ((web.representation == STRING) && (edge_count < 1))
; 3195 :               || ((web.representation == SOAPFILM) && (edge_count < 3)) )

	mov	eax, DWORD PTR _web+624
	cmp	eax, 1
	jne	SHORT $LN106@read_faces
	cmp	DWORD PTR _edge_count$91016[ebp], eax
	jl	SHORT $LN348@read_faces
	jmp	SHORT $LN349@read_faces
$LN106@read_faces:
	cmp	eax, 2
	jne	SHORT $LN349@read_faces
	cmp	DWORD PTR _edge_count$91016[ebp], 3
	jge	SHORT $LN349@read_faces
$LN348@read_faces:

; 3196 :       { sprintf(errmsg,"Face %d has too few edges.\n",k);

	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	push	OFFSET ??_C@_0BM@HAIGIAMA@Face?5?$CFd?5has?5too?5few?5edges?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 3197 :         kb_error(1158,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1158					; 00000486H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN349@read_faces:

; 3198 :       }
; 3199 :       #ifdef MPI_EVOLVER
; 3200 :       if ( !split_loop_flag )
; 3201 :       { set_next_edge(fe,first_fe);  /* close up ring */
; 3202 :         set_prev_edge(first_fe,fe);
; 3203 :       }
; 3204 :       #else
; 3205 : 	  { vertex_id hh,tt;
; 3206 :       tt = get_fe_tailv(first_fe);

	mov	eax, DWORD PTR _first_fe$91057[ebp]
	mov	ecx, DWORD PTR _web+460
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ebx+ecx]
	mov	ecx, DWORD PTR _web+216
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	edx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN256@read_faces
	mov	edi, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN387@read_faces
$LN256@read_faces:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN387@read_faces:

; 3207 :       hh = get_fe_headv(fe);

	mov	edi, DWORD PTR _web+460
	mov	DWORD PTR _tt$91084[ebp], eax
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+eax*4]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN262@read_faces
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [ecx+edx]
	jmp	SHORT $LN261@read_faces
$LN262@read_faces:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR [eax+ecx]
$LN261@read_faces:

; 3208 :       if ( equal_id(tt,hh) ) 

	cmp	DWORD PTR _tt$91084[ebp], ecx
	jne	SHORT $LN105@read_faces

; 3209 :       { set_next_edge(fe,first_fe);  /* close up ring */

	mov	eax, DWORD PTR _first_fe$91057[ebp]
	test	esi, 268435456				; 10000000H
	je	SHORT $LN265@read_faces
	test	esi, 134217728				; 08000000H
	je	SHORT $LN266@read_faces
	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [edi+28], ecx
	jmp	SHORT $LN265@read_faces
$LN266@read_faces:
	mov	DWORD PTR [edi+32], eax
$LN265@read_faces:

; 3210 :         set_prev_edge(first_fe,fe);

	test	eax, 268435456				; 10000000H
	je	SHORT $LN351@read_faces
	test	eax, 134217728				; 08000000H
	je	SHORT $LN271@read_faces
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [ebx+edx]
	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR [eax+32], esi
	jmp	SHORT $LN270@read_faces
$LN271@read_faces:
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [ebx+ecx]
	mov	DWORD PTR [edx+28], esi
$LN270@read_faces:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 3211 :       }
; 3212 :       else 

	jmp	SHORT $LN351@read_faces
$LN105@read_faces:

; 3213 :       { if ( web.representation != STRING )

	cmp	DWORD PTR _web+624, 1
	je	SHORT $LN351@read_faces

; 3214 :         { sprintf(errmsg,
; 3215 :              "Inconsistency in face %d first and last edges.\n",k);

	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	push	OFFSET ??_C@_0DA@IEDFFOBH@Inconsistency?5in?5face?5?$CFd?5first?5a@
	push	OFFSET _errmsg
	call	_sprintf

; 3216 :           kb_error(1159,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1159					; 00000487H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN351@read_faces:

; 3217 :         }
; 3218 :       }
; 3219 : 	  }
; 3220 :       #endif
; 3221 :        
; 3222 :       if ( (web.modeltype == LAGRANGE) && (web.representation == SOAPFILM) )

	cmp	DWORD PTR _web+628, 3
	jne	$LN356@read_faces
	cmp	DWORD PTR _web+624, 2
	jne	$LN356@read_faces

; 3223 :       { /* read vertex list */
; 3224 :         int vercount = 0;
; 3225 :         vertex_id *v;
; 3226 :         if ( tok != VERTICES_TOK )

	cmp	DWORD PTR _tok, 293			; 00000125H
	mov	DWORD PTR _vercount$91090[ebp], 0
	je	SHORT $LN359@read_faces

; 3227 :           kb_error(1160,"Need facet vertices in Lagrange model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CI@DFPGPIEE@Need?5facet?5vertices?5in?5Lagrange?5@
	push	1160					; 00000488H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN359@read_faces:

; 3228 :         v = get_facet_vertices(this_facet_id);

	mov	esi, DWORD PTR _this_facet_id$[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edi, DWORD PTR [esi+ecx]
	add	edi, DWORD PTR [edx+eax+304]

; 3229 :         while ( (tok = gettok(INTEGER_TOK)) == INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	jne	$LN352@read_faces
	mov	ebx, DWORD PTR _k$[ebp]
	npad	2
$LL100@read_faces:

; 3230 :         { if ( vercount++ >= numv )

	mov	eax, DWORD PTR _vercount$91090[ebp]
	mov	ecx, eax
	inc	eax
	mov	DWORD PTR _vercount$91090[ebp], eax
	cmp	ecx, DWORD PTR _numv$[ebp]
	jl	SHORT $LN98@read_faces

; 3231 :              kb_error(1161,"Too many vertices for facet.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BO@FIGLFJNJ@Too?5many?5vertices?5for?5facet?4?6?$AA@
	push	1161					; 00000489H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN95@read_faces
$LN98@read_faces:

; 3232 :           else if ( !valid_id(vlist[yylval.i]) )

	mov	eax, DWORD PTR _yylval
	mov	edx, DWORD PTR _vlist
	mov	ecx, DWORD PTR [edx+eax*4]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN96@read_faces

; 3233 :           { sprintf(errmsg,"Facet %d: vertex %d is not defined.\n",k,yylval.i);

	push	eax
	push	ebx
	push	OFFSET ??_C@_0CF@BHJOBNNN@Facet?5?$CFd?3?5vertex?5?$CFd?5is?5not?5defin@
	push	OFFSET _errmsg
	call	_sprintf

; 3234 :             kb_error(1162,errmsg,RECOVERABLE /*DATAFILE_ERROR*/);

	push	1
	push	OFFSET _errmsg
	push	1162					; 0000048aH
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN95@read_faces
$LN96@read_faces:

; 3235 :           }
; 3236 :           else *(v++) = vlist[yylval.i];

	mov	DWORD PTR [edi], ecx
	add	edi, 4
$LN95@read_faces:

; 3229 :         while ( (tok = gettok(INTEGER_TOK)) == INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	$LL100@read_faces
$LN352@read_faces:

; 3237 :         }
; 3238 :         if ( vercount < numv )

	mov	eax, DWORD PTR _vercount$91090[ebp]
	cmp	eax, DWORD PTR _numv$[ebp]
	jge	SHORT $LN94@read_faces

; 3239 :            kb_error(1163,"Too few vertices for facet.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BN@NGNHMCAM@Too?5few?5vertices?5for?5facet?4?6?$AA@
	push	1163					; 0000048bH
$LN381@read_faces:
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN94@read_faces:

; 3240 :       }
; 3241 :     } 
; 3242 :     if ( (web.modeltype == LAGRANGE) && (web.representation == SOAPFILM) )

	cmp	DWORD PTR _web+628, 3
	jne	$LN356@read_faces
	cmp	DWORD PTR _web+624, 2
	jne	$LN356@read_faces

; 3243 :     { vertex_id *v = get_facet_vertices(this_facet_id);

	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR _web+328
	add	ecx, DWORD PTR [eax+edx+304]

; 3244 :       for ( i = 0 ; i < numv ; i++ ) 

	mov	edi, DWORD PTR _numv$[ebp]
	xor	edx, edx
	test	edi, edi
	jle	SHORT $LN353@read_faces
	mov	ebx, DWORD PTR _this_facet_id$[ebp]
	npad	11
$LL92@read_faces:

; 3245 :         if ( !(get_vattr(v[i]) & Q_MIDEDGE ) )

	mov	eax, DWORD PTR [ecx+edx*4]
	mov	esi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 4194304				; 00400000H
	xor	esi, esi
	or	eax, esi
	jne	SHORT $LN91@read_faces

; 3246 :         { set_attr(v[i],Q_MIDFACET);

	mov	eax, DWORD PTR [ecx+edx*4]
	mov	esi, eax
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	esi, DWORD PTR _web[esi+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 2097152		; 00200000H
	mov	DWORD PTR [eax+12], esi

; 3247 :           set_vertex_facet(v[i],this_facet_id);

	mov	eax, DWORD PTR [ecx+edx*4]
	mov	esi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [eax+32], ebx
$LN91@read_faces:

; 3244 :       for ( i = 0 ; i < numv ; i++ ) 

	inc	edx
	cmp	edx, edi
	jl	SHORT $LL92@read_faces
$LN353@read_faces:

; 3248 :         }
; 3249 :        for ( i = 0 ; i <= web.dimension ; i++ )

	xor	edx, edx
	cmp	DWORD PTR _web+620, edx
	jl	SHORT $LN356@read_faces
	npad	8
$LL88@read_faces:

; 3250 :          unset_attr(v[web.skel[FACET].extreme[i]],Q_MIDFACET);

	mov	eax, DWORD PTR _web[edx*4+296]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	esi, eax
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	esi, DWORD PTR _web[esi+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR [eax+12]
	and	DWORD PTR [eax+8], -2097153		; ffdfffffH
	inc	edx
	mov	DWORD PTR [eax+12], esi
	cmp	edx, DWORD PTR _web+620
	jle	SHORT $LL88@read_faces
$LN356@read_faces:

; 3248 :         }
; 3249 :        for ( i = 0 ; i <= web.dimension ; i++ )

	mov	esi, DWORD PTR _this_facet_id$[ebp]

; 3251 :      }
; 3252 : 
; 3253 : #ifdef MPI_EVOLVER
; 3254 : 	  if ( (web.representation == STRING) && (facet_task != this_task)) 
; 3255 : 	  { /* skip rest of line */
; 3256 :         while ( (tok != LEAD_INTEGER_TOK) && (tok != LEAD_INTEGER_AT_TOK) &&
; 3257 :                (tok != READ_TOK) && (tok != BODIES_TOK) && (tok != 0) )
; 3258 : 		{ tok = yylex();
; 3259 :         }
; 3260 : 		continue;
; 3261 : 	  }
; 3262 : #endif
; 3263 : 
; 3264 :       set_facet_density(this_facet_id,1.0);

	fld1
	mov	ecx, DWORD PTR _web+236
	mov	ebx, esi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ebx+ecx]
	fstp	QWORD PTR [edx+32]
	mov	DWORD PTR tv2604[ebp], ebx
	npad	4
$LL85@read_faces:

; 3265 :       /* have attributes, maybe */
; 3266 :       for ( more_attr = 1 ; more_attr ; )
; 3267 :         switch ( tok )

	mov	ecx, DWORD PTR _tok
	mov	eax, ecx
	cmp	eax, 264				; 00000108H
	jg	SHORT $LN184@read_faces
	je	SHORT $LN372@read_faces
	test	eax, eax
	jne	$LN370@read_faces
$LN372@read_faces:

; 3537 :                 break;
; 3538 :          }
; 3539 : 
; 3540 :       if ((get_fattr(this_facet_id)&(BOUNDARY|CONSTRAINT)) == (BOUNDARY|CONSTRAINT))

	mov	ecx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1152				; 00000480H
	xor	ecx, ecx
	cmp	eax, 1152				; 00000480H
	jne	SHORT $LN2@read_faces
	test	ecx, ecx
	jne	SHORT $LN2@read_faces

; 3541 :           kb_error(1182,"Cannot have constraint and boundary.",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CF@NGLIKJND@Cannot?5have?5constraint?5and?5bound@
	push	1182					; 0000049eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN2@read_faces:

; 3542 : 
; 3543 : 
; 3544 :       if ( k > facecount ) facecount = k;

	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _facecount
	jle	$LL138@read_faces
	mov	eax, edx
	mov	DWORD PTR _facecount, eax

; 3545 :     }

	jmp	$LL138@read_faces
$LN184@read_faces:

; 3265 :       /* have attributes, maybe */
; 3266 :       for ( more_attr = 1 ; more_attr ; )
; 3267 :         switch ( tok )

	cmp	eax, 549				; 00000225H
	jg	$LN185@read_faces
	je	SHORT $LN372@read_faces
	sub	eax, 284				; 0000011cH
	cmp	eax, 236				; 000000ecH
	ja	$LN370@read_faces
	movzx	eax, BYTE PTR $LN337@read_faces[eax]
	jmp	DWORD PTR $LN391@read_faces[eax*4]
$LN79@read_faces:

; 3277 :                     break;
; 3278 : 
; 3279 :             case ORIENTATION_TOK:
; 3280 :                     if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN78@read_faces

; 3281 :                     { kb_error(2113,"ORIENTATION value missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BM@NLDAKABN@ORIENTATION?5value?5missing?4?6?$AA@
	push	2113					; 00000841H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3282 :                       break;

	jmp	$LL85@read_faces
$LN78@read_faces:

; 3283 :                     }
; 3284 :                     if ( yylval.i < 0 ) set_attr(this_facet_id,NEGBOUNDARY);

	cmp	DWORD PTR _yylval, 0
	jge	SHORT $LN279@read_faces
	mov	ecx, esi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	eax, DWORD PTR [edx+ebx]
	or	DWORD PTR [eax+8], 256			; 00000100H
$LN388@read_faces:
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], ecx
$LN279@read_faces:

; 3285 :                     tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3286 :                     break;

	jmp	$LL85@read_faces
$LN76@read_faces:

; 3287 : 
; 3288 : 
; 3289 :             case ORIGINAL_TOK:
; 3290 :                     if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN75@read_faces

; 3291 :                     { kb_error(2114,"ORIGINAL value missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BJ@ICLHKEOI@ORIGINAL?5value?5missing?4?6?$AA@
	push	2114					; 00000842H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3292 :                       break;

	jmp	$LL85@read_faces
$LN75@read_faces:

; 3293 :                     }
; 3294 :                     else 
; 3295 :                     { set_original(this_facet_id,(yylval.i-1)|((element_id)FACET<<TYPESHIFT)|VALIDMASK);

	mov	edx, DWORD PTR _yylval
	mov	eax, esi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [ecx+ebx]
	dec	edx
	or	edx, 1342177280				; 50000000H

; 3296 :                       tok = yylex();

	push	0
	mov	DWORD PTR [eax+20], edx
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3297 :                     }
; 3298 :                     break;

	jmp	$LL85@read_faces
$LN73@read_faces:

; 3299 : 
; 3300 :             case DENSITY_TOK:
; 3301 :                  if ( read_const(&value) <= 0 )

	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN72@read_faces

; 3302 :                     kb_error(1164,"Missing DENSITY or TENSION value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CD@NLJGPPIJ@Missing?5DENSITY?5or?5TENSION?5value@
	push	1164					; 0000048cH
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN71@read_faces
$LN72@read_faces:

; 3303 :                  else tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN71@read_faces:

; 3304 :                  set_attr(this_facet_id,DENSITY);

	mov	edx, esi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	eax, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 16			; 00000010H
	mov	DWORD PTR [eax+12], ecx

; 3305 :                  set_facet_density(this_facet_id,value);

	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ebx+edx]
	fld	QWORD PTR _value$[ebp]
	fstp	QWORD PTR [eax+32]

; 3306 :                  break;

	jmp	$LL85@read_faces
$LN70@read_faces:

; 3307 : 
; 3308 :             case NODISPLAY_TOK:
; 3309 :           /* see if want not to be displayed */
; 3310 :                  set_attr(this_facet_id,NODISPLAY);

	mov	ecx, esi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	eax, DWORD PTR [edx+ebx]
	or	DWORD PTR [eax+8], 2

; 3311 :                  tok = yylex();
; 3312 :                  break;

	jmp	$LN388@read_faces
$LN69@read_faces:

; 3313 : 
; 3314 :              case NONCONTENT_TOK:
; 3315 :                     set_attr(this_facet_id,NONCONTENT);

	mov	edx, esi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	eax, DWORD PTR [eax+ebx]
	or	DWORD PTR [eax+8], 536870912		; 20000000H

; 3316 :                     tok = yylex();
; 3317 :                     break;

	jmp	$LN388@read_faces
$LN68@read_faces:

; 3318 : 
; 3319 :              case NO_REFINE_TOK:
; 3320 :                     set_attr(this_facet_id,NO_REFINE);

	mov	edx, esi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	eax, DWORD PTR [eax+ebx]
	or	DWORD PTR [eax+8], 16777216		; 01000000H

; 3321 :                     tok = yylex();
; 3322 :                     break;

	jmp	$LN388@read_faces
$LN67@read_faces:

; 3323 : 
; 3324 :              case NO_TRANSFORM_TOK:
; 3325 :                   set_attr(this_facet_id,NO_TRANSFORM);

	mov	edx, esi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	eax, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [eax+8]
	or	DWORD PTR [eax+12], 1
	push	0
	mov	DWORD PTR [eax+8], ecx
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_faces
$LN66@read_faces:

; 3326 :                   tok = yylex();
; 3327 :                   break;
; 3328 : 
; 3329 :           case FIXED_TOK:
; 3330 :           /* see if fixed in place */
; 3331 :                  set_attr(this_facet_id,FIXED);

	mov	edx, esi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	eax, DWORD PTR [eax+ebx]
	or	DWORD PTR [eax+8], 64			; 00000040H

; 3332 :                  tok = yylex();
; 3333 :                  break;

	jmp	$LN388@read_faces
$LN65@read_faces:

; 3334 : 
; 3335 :           case PHASE_TOK: 
; 3336 :                 if ( !phase_flag )

	cmp	DWORD PTR _phase_flag, 0
	jne	SHORT $LN367@read_faces

; 3337 :                   kb_error(1165,"Phases not in effect.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BH@EDLGBDIJ@Phases?5not?5in?5effect?4?6?$AA@
	push	1165					; 0000048dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN367@read_faces:

; 3338 : 
; 3339 :                 if ( web.representation != STRING )

	cmp	DWORD PTR _web+624, 1
	je	SHORT $LN373@read_faces

; 3340 :                   kb_error(1166,"Phases on facets only in STRING model.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CI@KHMGPKDK@Phases?5on?5facets?5only?5in?5STRING?5@
	push	1166					; 0000048eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN373@read_faces:

; 3341 : 
; 3342 :                 if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN62@read_faces

; 3343 :                 { kb_error(1167,"Phase missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BA@DKJJCAOO@Phase?5missing?4?6?$AA@
	push	1167					; 0000048fH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3344 :                   break;

	jmp	$LL85@read_faces
$LN62@read_faces:

; 3345 :                 }
; 3346 :                 if ( (yylval.i < 0) || (yylval.i > phasemax) )

	mov	ecx, DWORD PTR _yylval
	test	ecx, ecx
	js	SHORT $LN60@read_faces
	cmp	ecx, DWORD PTR _phasemax
	jle	SHORT $LN61@read_faces
$LN60@read_faces:

; 3347 :                   kb_error(1168,"Illegal phase value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BG@DIEMLGNJ@Illegal?5phase?5value?4?6?$AA@
	push	1168					; 00000490H
	call	_kb_error
	mov	ecx, DWORD PTR _yylval
	add	esp, 12					; 0000000cH
$LN61@read_faces:

; 3348 : 
; 3349 :                 set_f_phase(this_facet_id,yylval.i);

	mov	edx, DWORD PTR _F_PHASE_ATTR
	mov	eax, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+328
	add	eax, edx
	cmp	DWORD PTR [eax+88], 0
	je	$LN279@read_faces
	mov	edx, DWORD PTR _web+236
	mov	edx, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [eax+64]
	push	0
	mov	DWORD PTR [edx+eax], ecx
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_faces
$LN59@read_faces:

; 3350 :                 tok = yylex();
; 3351 :                 break;
; 3352 : 
; 3353 :           case COLOR_TOK:
; 3354 :                 if ( read_const(&value) <= 0 )

	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN58@read_faces

; 3355 :                 { kb_error(1169,"Missing color value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BG@OGOMJBJM@Missing?5color?5value?4?6?$AA@
	push	1169					; 00000491H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3356 :                   break;

	jmp	$LL85@read_faces
$LN58@read_faces:

; 3357 :                 }
; 3358 :                 set_facet_color(this_facet_id,(short)(value));

	fld	QWORD PTR _value$[ebp]
	call	__ftol2_sse
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ebx+edx]
	mov	WORD PTR [ecx+50], ax
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ebx+edx]
	push	0
	mov	WORD PTR [ecx+48], ax
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_faces
$LN57@read_faces:

; 3359 :                 tok = yylex();
; 3360 :                 break;
; 3361 : 
; 3362 :           case FRONTCOLOR_TOK:
; 3363 :                 if ( read_const(&value) <= 0 )

	lea	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN56@read_faces

; 3364 :                 { kb_error(1170,"Frontcolor value missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BL@DELOLHDF@Frontcolor?5value?5missing?4?6?$AA@
	push	1170					; 00000492H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3365 :                   break;

	jmp	$LL85@read_faces
$LN56@read_faces:

; 3366 :                 }
; 3367 :                 set_facet_frontcolor(this_facet_id,(short)value);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN153@read_faces
$LN155@read_faces:
	fld	QWORD PTR _value$[ebp]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR [ebx+ecx]
	push	0
	mov	WORD PTR [edx+50], ax
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_faces
$LN55@read_faces:

; 3368 :                 tok = yylex();
; 3369 :                 break;
; 3370 : 
; 3371 :           case BACKCOLOR_TOK:
; 3372 :                 if ( read_const(&value) <= 0 )

	lea	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN54@read_faces

; 3373 :                 { kb_error(1171,"Backcolor value missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BK@LANJCDLM@Backcolor?5value?5missing?4?6?$AA@
	push	1171					; 00000493H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3374 :                   break;

	jmp	$LL85@read_faces
$LN54@read_faces:

; 3375 :                 }
; 3376 :                 set_facet_backcolor(this_facet_id,(short)value);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN155@read_faces
$LN153@read_faces:
	fld	QWORD PTR _value$[ebp]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR [ebx+ecx]
	push	0
	mov	WORD PTR [edx+48], ax
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_faces
$LN53@read_faces:

; 3377 :                 tok = yylex();
; 3378 :                 break;
; 3379 :                 
; 3380 :           case OPACITY_TOK:
; 3381 :                 if ( !opacity_attr )

	cmp	DWORD PTR _opacity_attr, 0
	jne	$LN49@read_faces

; 3382 :                 { int one = 1;
; 3383 :                   facet_id f_id;
; 3384 :                   opacity_attr = add_attribute(FACET,"opacity",REAL_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _one$91219[ebp]
	push	eax
	push	0
	push	1
	push	OFFSET ??_C@_07IJGPCJHC@opacity?$AA@
	push	2
	mov	DWORD PTR _one$91219[ebp], 1
	call	_add_attribute

; 3385 : 
; 3386 :                   FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	add	esp, 32					; 00000020H
	mov	DWORD PTR _opacity_attr, eax
	test	edx, 268435456				; 10000000H
	je	SHORT $LN49@read_faces
	mov	edi, DWORD PTR _web+236
	fld1
$LN51@read_faces:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	esi, esi
	or	ecx, esi
	je	SHORT $LN50@read_faces

; 3387 :                    *(REAL*)(get_extra(f_id,opacity_attr)) = 1.0;

	mov	ecx, DWORD PTR _opacity_attr
	shr	edx, 29					; 0000001dH
	imul	ecx, 240				; 000000f0H
	imul	edx, 112				; 00000070H
	mov	esi, DWORD PTR _web[edx+104]
	mov	edx, DWORD PTR _web[edx+12]
	mov	edx, DWORD PTR [edx+eax]
	add	esi, ecx
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [esi+ecx+64]
	fst	QWORD PTR [ecx+edx]
	mov	edi, DWORD PTR _web+236
$LN50@read_faces:

; 3385 : 
; 3386 :                   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LN51@read_faces
	fstp	ST(0)
$LN49@read_faces:

; 3388 :                 }
; 3389 :                 if ( read_const(&value) <= 0 )

	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN46@read_faces

; 3390 :                 { kb_error(2502,"Opacity value missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BI@IHKMFJBP@Opacity?5value?5missing?4?6?$AA@
	push	2502					; 000009c6H
	call	_kb_error

; 3391 :                   break;

	mov	esi, DWORD PTR _this_facet_id$[ebp]
	add	esp, 12					; 0000000cH
	jmp	$LL85@read_faces
$LN46@read_faces:

; 3392 :                 }
; 3393 :                 *(REAL*)(get_extra(this_facet_id,opacity_attr)) = value;

	mov	eax, DWORD PTR _this_facet_id$[ebp]
	fld	QWORD PTR _value$[ebp]
	mov	edx, DWORD PTR _opacity_attr
	shr	eax, 29					; 0000001dH
	imul	edx, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+104]
	add	ecx, edx
	mov	edx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+eax+64]
	mov	edx, DWORD PTR [edx+ebx]

; 3394 :                 tok = yylex();

	push	0
	fstp	QWORD PTR [ecx+edx]
	call	_kb_yylex

; 3395 :                 break;

	mov	esi, DWORD PTR _this_facet_id$[ebp]
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_faces
$LN45@read_faces:

; 3396 : 
; 3397 :           case BOUNDARY_TOK:
; 3398 :           case BOUNDARY_NAME_TOK:
; 3399 :           /* see if boundary facet */
; 3400 :                    if ( tok == BOUNDARY_TOK )

	cmp	ecx, 408				; 00000198H
	jne	SHORT $LN368@read_faces

; 3401 :                      tok = gettok(INTEGER_TOK);

	push	265					; 00000109H
	call	_gettok
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _tok, ecx
$LN368@read_faces:

; 3402 :                    if ( (tok != INTEGER_TOK) && ( tok != BOUNDARY_NAME_TOK ) )  

	cmp	ecx, 265				; 00000109H
	je	SHORT $LN327@read_faces
	cmp	ecx, 520				; 00000208H
	je	$LN42@read_faces

; 3403 :                    { kb_error(1173,"Need boundary number or name.\n",
; 3404 :                             DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@CEDOMNKL@Need?5boundary?5number?5or?5name?4?6?$AA@
	push	1173					; 00000495H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3405 :                      break;

	jmp	$LL85@read_faces
$LN327@read_faces:

; 3406 :                    }
; 3407 :                    if ( tok == INTEGER_TOK )
; 3408 :                    { bnum = abs(yylval.i);

	mov	eax, DWORD PTR _yylval
	cdq
	xor	eax, edx
	sub	eax, edx

; 3409 :                      if ( (bnum >= web.bdrymax) 
; 3410 :                                 || !(web.boundaries[bnum].attr & IN_USE) )

	cmp	eax, DWORD PTR _web+768
	jge	SHORT $LN369@read_faces
	mov	edx, DWORD PTR _web+776
	mov	ecx, eax
	imul	ecx, 136				; 00000088H
	mov	ecx, DWORD PTR [ecx+edx+32]
	and	ecx, 32					; 00000020H
	xor	edx, edx
	or	ecx, edx
	jne	$LN39@read_faces
$LN369@read_faces:

; 3411 :                      {
; 3412 :                        sprintf(errmsg,
; 3413 :                            "Bad boundary number %d for facet %d.\n",bnum,k);

	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	push	eax
	push	OFFSET ??_C@_0CG@NOPNANDI@Bad?5boundary?5number?5?$CFd?5for?5facet@
	push	OFFSET _errmsg
	call	_sprintf

; 3414 :                        kb_error(1174,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1174					; 00000496H
	call	_kb_error

; 3415 :                        yylex();

	push	0
	call	_kb_yylex
	add	esp, 32					; 00000020H

; 3416 :                        break;

	jmp	$LL85@read_faces
$LN42@read_faces:

; 3417 :                      }          
; 3418 :                    }
; 3419 :                    else
; 3420 :                    { bnum = globals(yylval.i)->value.bnum;

	mov	eax, DWORD PTR _yylval
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN157@read_faces
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN159@read_faces
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN158@read_faces
$LN159@read_faces:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN157@read_faces
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN158@read_faces
$LN157@read_faces:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN158@read_faces:
	mov	eax, DWORD PTR [eax+64]
$LN39@read_faces:

; 3421 :                    }
; 3422 :                 set_attr(this_facet_id,BOUNDARY);

	mov	edx, esi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 128			; 00000080H
	mov	DWORD PTR [ecx+12], edx

; 3423 :                 set_facet_boundary_num(this_facet_id,bnum);

	mov	ecx, DWORD PTR _F_BOUNDARY_ATTR
	test	ecx, ecx
	je	$LN279@read_faces
	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+328
	push	0
	mov	ecx, DWORD PTR [ecx+edx+64]
	mov	edx, DWORD PTR _web+236
	mov	edx, DWORD PTR [ebx+edx]
	mov	DWORD PTR [ecx+edx], eax
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_faces
$LN38@read_faces:

; 3424 :                 tok = yylex();
; 3425 :                 break;
; 3426 : 
; 3427 :           case CONSTRAINT_TOK:
; 3428 :           case CONSTRAINT_NAME_TOK:
; 3429 :               if ( tok == CONSTRAINT_TOK )

	cmp	ecx, 320				; 00000140H
	jne	SHORT $LL36@read_faces

; 3430 :                 tok = gettok(INTEGER_TOK);

	push	265					; 00000109H
	call	_gettok
$LN390@read_faces:
	mov	ecx, eax
	mov	DWORD PTR _tok, ecx
	add	esp, 4
	npad	1
$LL36@read_faces:

; 3431 :               while ( (tok == INTEGER_TOK) || (tok==CONSTRAINT_NAME_TOK) )

	cmp	ecx, 265				; 00000109H
	je	SHORT $LN326@read_faces
	cmp	ecx, 519				; 00000207H
	jne	$LL85@read_faces

; 3436 :                      cnum = globals(yylval.i)->value.cnum;

	mov	eax, DWORD PTR _yylval
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN165@read_faces
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN167@read_faces
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN166@read_faces
$LN326@read_faces:

; 3432 :               {
; 3433 :                  if ( tok == INTEGER_TOK )
; 3434 :                      cnum = abs(yylval.i);

	mov	eax, DWORD PTR _yylval
	cdq
	xor	eax, edx
	sub	eax, edx

; 3435 :                  else

	jmp	SHORT $LN32@read_faces
$LN167@read_faces:

; 3436 :                      cnum = globals(yylval.i)->value.cnum;

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN165@read_faces
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN166@read_faces
$LN165@read_faces:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN166@read_faces:
	mov	eax, DWORD PTR [eax+64]
$LN32@read_faces:

; 3437 :                  constr = get_constraint(cnum); 

	mov	esi, eax
	and	esi, 1073741823				; 3fffffffH
	imul	esi, 176				; 000000b0H
	add	esi, DWORD PTR _web+652

; 3438 :                  if ( (cnum >= web.maxcon) || !(constr->attr & IN_USE) )

	cmp	eax, DWORD PTR _web+644
	jge	$LN365@read_faces
	mov	ecx, DWORD PTR [esi+32]
	and	ecx, 32					; 00000020H
	xor	edx, edx
	or	ecx, edx
	je	$LN365@read_faces

; 3443 :                    break;
; 3444 :                  }
; 3445 :                  set_attr(this_facet_id,CONSTRAINT);

	mov	edi, DWORD PTR _this_facet_id$[ebp]
	shr	edi, 29					; 0000001dH
	imul	edi, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edi+12]
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 1024			; 00000400H
	lea	edi, DWORD PTR _web[edi+12]
	mov	DWORD PTR [ecx+12], edx

; 3446 : /* ?? */         if ( yylval.i < 0 ) set_attr(this_facet_id,NEGBOUNDARY);

	cmp	DWORD PTR _yylval, 0
	jge	SHORT $LN301@read_faces
	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 256			; 00000100H
	mov	DWORD PTR [ecx+12], edx
$LN301@read_faces:

; 3447 :                  set_f_constraint_map(this_facet_id,cnum);

	push	eax
	mov	eax, DWORD PTR _this_facet_id$[ebp]
	push	eax
	call	_set_f_constraint_map

; 3448 :                  if ( constr->attr & CON_ENERGY )

	mov	eax, DWORD PTR [esi+32]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	add	esp, 8
	or	eax, ecx
	je	SHORT $LN303@read_faces

; 3449 :                  set_attr(this_facet_id, BDRY_ENERGY);

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+ebx]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 512			; 00000200H
	mov	DWORD PTR [eax+12], edx
$LN303@read_faces:

; 3450 : 
; 3451 :                  tok = gettok(INTEGER_TOK);

	push	265					; 00000109H
	call	_gettok

; 3452 :                }

	mov	esi, DWORD PTR _this_facet_id$[ebp]
	jmp	$LN390@read_faces
$LN365@read_faces:

; 3439 :                  { sprintf(errmsg,
; 3440 :                           "Bad constraint number %d for face %d.\n",cnum,k);

	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	push	eax
	push	OFFSET ??_C@_0CH@LHEMMEFB@Bad?5constraint?5number?5?$CFd?5for?5fac@
	push	OFFSET _errmsg
	call	_sprintf

; 3441 :                    kb_error(1175,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1175					; 00000497H
	call	_kb_error

; 3442 :                    tok = yylex();

	push	0
	call	_kb_yylex

; 3453 :                 break;

	mov	esi, DWORD PTR _this_facet_id$[ebp]
	add	esp, 32					; 00000020H
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_faces
$LN27@read_faces:

; 3454 : 
; 3455 :           case ENERGY_TOK:
; 3456 :           /* see if surface energy */
; 3457 :                 tok = yylex();

	push	0
	call	_kb_yylex

; 3458 :                 kb_error(1177,"Surface energies obsolete.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BM@MDBJLIJJ@Surface?5energies?5obsolete?4?6?$AA@
	push	1177					; 00000499H
	mov	DWORD PTR _tok, eax
	call	_kb_error
	add	esp, 16					; 00000010H

; 3459 :                 if ( tok == INTEGER_TOK ) tok = yylex();

	cmp	DWORD PTR _tok, 265			; 00000109H
	jne	$LL85@read_faces

; 3285 :                     tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3286 :                     break;

	jmp	$LL85@read_faces
$LN25@read_faces:

; 3460 :                 break;
; 3461 : 
; 3462 :           case QUANTITY_NAME_TOK: /* name of quantity */
; 3463 :            { int qnum = yylval.i;

	mov	esi, DWORD PTR _yylval

; 3464 :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3465 :              if ( tok == '-' || tok == UMINUS_TOK )

	cmp	eax, 45					; 0000002dH
	je	SHORT $LN23@read_faces
	cmp	eax, 287				; 0000011fH
	je	SHORT $LN23@read_faces

; 3468 :              }
; 3469 :              else
; 3470 :                apply_quantity(this_facet_id,qnum);

	mov	edx, DWORD PTR _this_facet_id$[ebp]
	push	esi
	push	edx
	call	_apply_quantity
	mov	esi, DWORD PTR _this_facet_id$[ebp]
	add	esp, 8
	jmp	$LL85@read_faces
$LN23@read_faces:

; 3466 :              { apply_quantity(inverse_id(this_facet_id),qnum);

	mov	eax, DWORD PTR _this_facet_id$[ebp]
	xor	eax, 134217728				; 08000000H
	push	esi
	push	eax
	call	_apply_quantity

; 3467 :                tok = yylex();

	push	0
	call	_kb_yylex

; 3471 :              break;

	mov	esi, DWORD PTR _this_facet_id$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_faces
$LN21@read_faces:

; 3472 :            }
; 3473 : 
; 3474 :           case IDENT_TOK:  /* maybe method or quantity */
; 3475 :              if ( globals(yylval.i)->flags & METHOD_NAME )

	mov	esi, DWORD PTR _yylval
	mov	edi, DWORD PTR _dymem
	mov	ebx, DWORD PTR _web+5652
	mov	edx, esi
	and	edx, -16777216				; ff000000H
	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN171@read_faces
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN173@read_faces
	mov	ebx, DWORD PTR _localbase
	mov	eax, esi
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR _web+5652
	jmp	SHORT $LN172@read_faces
$LN173@read_faces:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN171@read_faces
	mov	ecx, DWORD PTR _web+5656
	mov	eax, esi
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN172@read_faces
$LN171@read_faces:
	mov	eax, esi
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [ebx+eax*4]
	mov	ecx, DWORD PTR [ecx+edi]
$LN172@read_faces:
	test	DWORD PTR [ecx+192], 1024		; 00000400H
	je	SHORT $LN20@read_faces

; 3476 :                 apply_method(this_facet_id,yytext);

	mov	edx, DWORD PTR _yytext
	mov	eax, DWORD PTR _this_facet_id$[ebp]
	push	edx
	push	eax
	call	_apply_method
	add	esp, 8
	jmp	$LN17@read_faces
$LN20@read_faces:

; 3477 :              else if ( globals(yylval.i)->flags & QUANTITY_NAME )

	cmp	edx, 268435456				; 10000000H
	jne	SHORT $LN181@read_faces
	lea	ecx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [ecx+edi]
	jmp	SHORT $LN178@read_faces
$LN181@read_faces:
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN179@read_faces
	mov	edx, DWORD PTR _localbase
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN178@read_faces
$LN179@read_faces:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN177@read_faces
	mov	ecx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN178@read_faces
$LN177@read_faces:
	lea	edx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [edx+edi]
$LN178@read_faces:
	test	BYTE PTR [eax+192], -128		; ffffff80H
	je	SHORT $LN18@read_faces

; 3478 :                 apply_quantity(this_facet_id,yylval.i);

	mov	eax, DWORD PTR _this_facet_id$[ebp]
	push	esi
	push	eax
	call	_apply_quantity
	add	esp, 8

; 3479 :              else 

	jmp	SHORT $LN17@read_faces
$LN18@read_faces:

; 3480 :              { sprintf(errmsg,"Illegal use of identifier '%s'.\n",yytext);

	mov	ecx, DWORD PTR _yytext
	push	ecx
	push	OFFSET ??_C@_0CB@LOIAMNAG@Illegal?5use?5of?5identifier?5?8?$CFs?8?4?6@
	push	OFFSET _errmsg
	call	_sprintf

; 3481 :                kb_error(1178,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1178					; 0000049aH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN17@read_faces:

; 3482 :              }
; 3483 :              tok = yylex();

	push	0
	call	_kb_yylex

; 3484 :              break;

	mov	esi, DWORD PTR _this_facet_id$[ebp]
	mov	ebx, DWORD PTR tv2604[ebp]
	add	esp, 4
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_faces
$LN10@read_faces:

; 3503 :              break;
; 3504 :           }
; 3505 : 
; 3506 :           case QUANTITY_TOK:            
; 3507 :                 tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3508 :                 if ( tok == QUANTITY_NAME_TOK )

	cmp	eax, 336				; 00000150H
	jne	SHORT $LN9@read_faces

; 3509 :                 { /* have named quantity/method pair */
; 3510 :                   char qname[32];
; 3511 :                   int qnum;
; 3512 : 
; 3513 :                   strncpy(qname,yytext,sizeof(qname));

	mov	edx, DWORD PTR _yytext
	push	32					; 00000020H
	push	edx
	lea	eax, DWORD PTR _qname$91310[ebp]
	push	eax
	call	_strncpy

; 3514 :                   qnum = yylval.i;

	mov	esi, DWORD PTR _yylval

; 3515 :                   tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tok, eax

; 3516 :                   if ( tok == '-' || tok == UMINUS_TOK )

	cmp	eax, 45					; 0000002dH
	je	SHORT $LN7@read_faces
	cmp	eax, 287				; 0000011fH
	je	SHORT $LN7@read_faces

; 3519 :                   }
; 3520 :                   else
; 3521 :                     apply_quantity(this_facet_id,qnum);

	mov	ecx, DWORD PTR _this_facet_id$[ebp]
	push	esi
	push	ecx
	call	_apply_quantity
	mov	esi, DWORD PTR _this_facet_id$[ebp]
	add	esp, 8
	jmp	$LL85@read_faces
$LN7@read_faces:

; 3517 :                   { apply_quantity(inverse_id(this_facet_id),qnum);

	mov	edx, DWORD PTR _this_facet_id$[ebp]
	xor	edx, 134217728				; 08000000H
	push	esi
	push	edx
	call	_apply_quantity

; 3518 :                     tok = yylex();

	push	0
	call	_kb_yylex

; 3526 :                 }
; 3527 :                 break;

	mov	esi, DWORD PTR _this_facet_id$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_faces
$LN9@read_faces:

; 3522 :                 }
; 3523 :                 else 
; 3524 :                 { kb_error(5467,"Missing quantity name.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BI@BHPPHJKA@Missing?5quantity?5name?4?6?$AA@
	push	5467					; 0000155bH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3525 :                   break;

	jmp	$LL85@read_faces
$LN185@read_faces:

; 3265 :       /* have attributes, maybe */
; 3266 :       for ( more_attr = 1 ; more_attr ; )
; 3267 :         switch ( tok )

	cmp	eax, 566				; 00000236H
	je	$LN81@read_faces
	cmp	eax, 35024				; 000088d0H
	je	SHORT $LN16@read_faces
$LN370@read_faces:

; 3528 : 
; 3529 :             case BODIES_TOK: case READ_TOK: case LEAD_INTEGER_TOK: case NO_TOKEN:
; 3530 :             case LEAD_INTEGER_AT_TOK:
; 3531 :                 more_attr = 0 ; break;  /* error recovery */
; 3532 :                 
; 3533 :             default: 
; 3534 :                 sprintf(errmsg,"Unexpected token: %s\n",yytext);

	mov	eax, DWORD PTR _yytext
	push	eax
	push	OFFSET ??_C@_0BG@BKFJJJKH@Unexpected?5token?3?5?$CFs?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 3535 :                 kb_error(2115,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2115					; 00000843H
	call	_kb_error

; 3536 :                 tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_faces
$LN16@read_faces:

; 3485 : 
; 3486 :           case METHOD_TOK:  /* apply method instance to edge */
; 3487 :              tok = yylex(); /* fall through */

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3488 :              if ( tok != METHOD_NAME_TOK )

	cmp	eax, 414				; 0000019eH
	je	SHORT $LN371@read_faces

; 3489 :              { kb_error(1951,"Missing method instance name.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@MGOCAHJG@Missing?5method?5instance?5name?4?6?$AA@
	push	1951					; 0000079fH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3490 :                break;

	jmp	$LL85@read_faces
$LN371@read_faces:

; 3491 :              }
; 3492 :              // else fall through to METHOD_NAME_TOK
; 3493 : 
; 3494 :           case METHOD_NAME_TOK:
; 3495 :           { char name[100];
; 3496 :              strcpy(name,yytext);

	mov	eax, DWORD PTR _yytext
	lea	edx, DWORD PTR _name$91301[ebp]
	sub	edx, eax
$LL375@read_faces:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [eax+edx], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL375@read_faces

; 3497 :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3498 :              if ( (tok == UMINUS_TOK) || (tok == '-') )

	cmp	eax, 287				; 0000011fH
	je	SHORT $LN12@read_faces
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN12@read_faces

; 3501 :              }
; 3502 :              else apply_method(this_facet_id,name);

	lea	ecx, DWORD PTR _name$91301[ebp]
	push	ecx
	push	esi
	call	_apply_method
	add	esp, 8
	jmp	$LL85@read_faces
$LN12@read_faces:

; 3499 :              { apply_method(inverse_id(this_facet_id),name);

	lea	edx, DWORD PTR _name$91301[ebp]
	mov	eax, esi
	push	edx
	xor	eax, 134217728				; 08000000H
	push	eax
	call	_apply_method

; 3500 :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax
	jmp	$LL85@read_faces
$LN81@read_faces:

; 3268 :          { 
; 3269 :             case EXTRA_ATTRIBUTE_TOK:
; 3270 :             case ARRAY_ATTRIBUTE_TOK:
; 3271 :                     if ( yylval.etype != FACET )

	mov	eax, DWORD PTR _yylval+24
	cmp	eax, 2
	je	SHORT $LN80@read_faces

; 3272 :                     { sprintf(errmsg,"'%s' is a %s attribute, not a facet attribute.\n",
; 3273 :                         yytext,typenames[yylval.etype]);

	mov	ecx, DWORD PTR _typenames[eax*4]
	mov	edx, DWORD PTR _yytext
	push	ecx
	push	edx
	push	OFFSET ??_C@_0DA@CHADONEE@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5a?5fa@
	push	OFFSET _errmsg
	call	_sprintf

; 3274 :                       kb_error(2507,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	2507					; 000009cbH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN80@read_faces:

; 3275 :                     }
; 3276 :                     read_extra(this_facet_id,yylval.qnum);

	mov	eax, DWORD PTR _yylval+4
	push	eax
	push	esi
	call	_read_extra
	add	esp, 8
	jmp	$LL85@read_faces
$LN137@read_faces:

; 3546 : 
; 3547 : #ifdef MPI_EVOLVER
; 3548 :   myfree((char*)vdummy);
; 3549 :   myfree((char*)edummy);
; 3550 : #endif
; 3551 : 
; 3552 : } /* end read_faces() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN391@read_faces:
	DD	$LN81@read_faces
	DD	$LN21@read_faces
	DD	$LN59@read_faces
	DD	$LN372@read_faces
	DD	$LN76@read_faces
	DD	$LN53@read_faces
	DD	$LN66@read_faces
	DD	$LN73@read_faces
	DD	$LN38@read_faces
	DD	$LN25@read_faces
	DD	$LN45@read_faces
	DD	$LN79@read_faces
	DD	$LN57@read_faces
	DD	$LN371@read_faces
	DD	$LN55@read_faces
	DD	$LN27@read_faces
	DD	$LN68@read_faces
	DD	$LN67@read_faces
	DD	$LN69@read_faces
	DD	$LN10@read_faces
	DD	$LN70@read_faces
	DD	$LN65@read_faces
	DD	$LN370@read_faces
$LN337@read_faces:
	DB	0
	DB	22					; 00000016H
	DB	1
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	2
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	3
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	4
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	5
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	6
	DB	7
	DB	22					; 00000016H
	DB	8
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	9
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	3
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	12					; 0000000cH
	DB	22					; 00000016H
	DB	13					; 0000000dH
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	14					; 0000000eH
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	15					; 0000000fH
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	22					; 00000016H
	DB	18					; 00000012H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	19					; 00000013H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	20					; 00000014H
	DB	22					; 00000016H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	8
	DB	10					; 0000000aH
_read_faces ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@GJDPGLEJ@Missing?5lagrange_multiplier?5valu@ ; `string'
PUBLIC	??_C@_0CP@MOBMBCEC@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5a?5bo@ ; `string'
PUBLIC	??_C@_0BO@PAEILJJD@Missing?5ACTUAL_VOLUME?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@ELJKNGHN@Illegal?5use?5of?5identifier?3?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CL@NBAGFHJM@Phases?5must?5be?5on?5facets?5in?5STRI@ ; `string'
PUBLIC	??_C@_0BJ@MFADOPAL@Missing?5PRESSURE?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MHEPGMAC@Missing?5VOLCONST?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@NBEBMNFH@Missing?5VOLUME?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DC@BNBOHGOI@Body?5can?8t?5have?5fixed?5volume?5and@ ; `string'
PUBLIC	??_C@_0BH@EDJIGNFI@Body?5?$CFd?5has?5no?5faces?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@PLOKLJGM@Body?5?$CFd?3?5face?5?$CFd?5is?5not?5defined?4@ ; `string'
PUBLIC	??_C@_0BK@FICAHELA@Duplicate?5body?5number?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@PCMMPCBH@Body?5number?5must?5be?5positive?4?6?$AA@ ; `string'
PUBLIC	_read_bodies
EXTRN	_add_outside:PROC
EXTRN	_B_PHASE_ATTR:DWORD
EXTRN	_set_body_fixvol:PROC
EXTRN	_set_facet_body:PROC
EXTRN	_new_body:PROC
;	COMDAT ??_C@_0CE@GJDPGLEJ@Missing?5lagrange_multiplier?5valu@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CE@GJDPGLEJ@Missing?5lagrange_multiplier?5valu@ DB 'Missing lagran'
	DB	'ge_multiplier value.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MOBMBCEC@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5a?5bo@
CONST	SEGMENT
??_C@_0CP@MOBMBCEC@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5a?5bo@ DB ''''
	DB	'%s'' is a %s attribute, not a body attribute.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PAEILJJD@Missing?5ACTUAL_VOLUME?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@PAEILJJD@Missing?5ACTUAL_VOLUME?5value?4?6?$AA@ DB 'Missing ACT'
	DB	'UAL_VOLUME value.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@ELJKNGHN@Illegal?5use?5of?5identifier?3?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@ELJKNGHN@Illegal?5use?5of?5identifier?3?5?$CFs?4?6?$AA@ DB 'Ill'
	DB	'egal use of identifier: %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NBAGFHJM@Phases?5must?5be?5on?5facets?5in?5STRI@
CONST	SEGMENT
??_C@_0CL@NBAGFHJM@Phases?5must?5be?5on?5facets?5in?5STRI@ DB 'Phases mus'
	DB	't be on facets in STRING model.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MFADOPAL@Missing?5PRESSURE?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@MFADOPAL@Missing?5PRESSURE?5value?4?6?$AA@ DB 'Missing PRESSURE'
	DB	' value.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MHEPGMAC@Missing?5VOLCONST?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@MHEPGMAC@Missing?5VOLCONST?5value?4?6?$AA@ DB 'Missing VOLCONST'
	DB	' value.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NBEBMNFH@Missing?5VOLUME?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@NBEBMNFH@Missing?5VOLUME?5value?4?6?$AA@ DB 'Missing VOLUME val'
	DB	'ue.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BNBOHGOI@Body?5can?8t?5have?5fixed?5volume?5and@
CONST	SEGMENT
??_C@_0DC@BNBOHGOI@Body?5can?8t?5have?5fixed?5volume?5and@ DB 'Body can'''
	DB	't have fixed volume and fixed pressure.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EDJIGNFI@Body?5?$CFd?5has?5no?5faces?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@EDJIGNFI@Body?5?$CFd?5has?5no?5faces?4?6?$AA@ DB 'Body %d has n'
	DB	'o faces.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PLOKLJGM@Body?5?$CFd?3?5face?5?$CFd?5is?5not?5defined?4@
CONST	SEGMENT
??_C@_0CC@PLOKLJGM@Body?5?$CFd?3?5face?5?$CFd?5is?5not?5defined?4@ DB 'Bo'
	DB	'dy %d: face %d is not defined.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FICAHELA@Duplicate?5body?5number?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BK@FICAHELA@Duplicate?5body?5number?5?$CFd?6?$AA@ DB 'Duplicate bo'
	DB	'dy number %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PCMMPCBH@Body?5number?5must?5be?5positive?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@PCMMPCBH@Body?5number?5must?5be?5positive?4?6?$AA@ DB 'Body num'
	DB	'ber must be positive.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\lexinit.c
CONST	ENDS
;	COMDAT _read_bodies
_TEXT	SEGMENT
_den$91344 = -36					; size = 8
_value$ = -28						; size = 8
_vol$91345 = -20					; size = 8
_b_id$ = -12						; size = 4
_lagmulflag$ = -8					; size = 4
_face_count$91346 = -4					; size = 4
_read_bodies PROC					; COMDAT

; 3563 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi

; 3564 :   int k;
; 3565 :   int f=0;
; 3566 :   facet_id f_id=NULLID;
; 3567 :   int more_attr;
; 3568 :   REAL value;  /* for constant expression values */
; 3569 :   int lagmulflag = 0;
; 3570 :   body_id b_id = NULLID;
; 3571 : 
; 3572 :   /* read in bodies */
; 3573 :   bmaxlist = MAXLIST;
; 3574 :   blist = (body_id *)mycalloc(sizeof(body_id),bmaxlist);

	push	3574					; 00000df6H
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	push	100					; 00000064H
	push	4
	mov	DWORD PTR _lagmulflag$[ebp], 0
	mov	DWORD PTR _bmaxlist, 100		; 00000064H
	call	_kb_calloc

; 3575 : 
; 3576 :   tok = yylex();

	push	0
	mov	DWORD PTR _blist, eax
	call	_kb_yylex
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tok, eax
$LL66@read_bodie:

; 3577 :   while ( (tok == LEAD_INTEGER_TOK) || (tok == LEAD_INTEGER_AT_TOK) )  /* body loop */

	mov	eax, DWORD PTR _tok
	cmp	eax, 264				; 00000108H
	je	SHORT $LN64@read_bodie
	cmp	eax, 549				; 00000225H
	jne	$LN65@read_bodie
$LN64@read_bodie:

; 3578 :   { 
; 3579 :     REAL den,vol;
; 3580 :     int face_count = 0;
; 3581 :  
; 3582 : 
; 3583 :     #ifdef MPI_EVOLVER
; 3584 :     int facet_task,body_task;
; 3585 : 
; 3586 :     body_task = yylval.qnum;
; 3587 :   
; 3588 :     /* test task number, for MPI */
; 3589 :     if ( tok == LEAD_INTEGER_TOK )
; 3590 :        body_task = 1;  /* default to task 1 */
; 3591 :     else body_task = yylval.qnum;
; 3592 :     if ( body_task >= mpi_nprocs || body_task < 1 )
; 3593 :     { sprintf(errmsg,"Task number %d must be between 1 and %d\n",
; 3594 :          body_task,mpi_nprocs-1);
; 3595 :       kb_error(5029,errmsg,RECOVERABLE);
; 3596 :     }
; 3597 : 
; 3598 :     #endif 
; 3599 :   
; 3600 :     k = yylval.i;

	mov	esi, DWORD PTR _yylval
	mov	DWORD PTR _face_count$91346[ebp], 0

; 3601 :     if ( k < 1 ) 

	cmp	esi, 1
	jge	SHORT $LN63@read_bodie

; 3602 :        kb_error(2116,"Body number must be positive.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@PCMMPCBH@Body?5number?5must?5be?5positive?4?6?$AA@
	push	2116					; 00000844H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN63@read_bodie:

; 3603 :     if ( k >= bmaxlist )

	mov	eax, DWORD PTR _bmaxlist
	cmp	esi, eax
	jl	SHORT $LN57@read_bodie

; 3604 :     { int spot = bmaxlist;

	mov	edi, eax
	npad	7
$LL61@read_bodie:

; 3605 :       while ( k >= bmaxlist )
; 3606 :         bmaxlist *= 2;

	add	eax, eax
	cmp	esi, eax
	jge	SHORT $LL61@read_bodie

; 3607 :       blist = (body_id *)kb_realloc((char *)blist,bmaxlist*sizeof(body_id));

	mov	ecx, DWORD PTR _blist
	mov	DWORD PTR _bmaxlist, eax
	push	3607					; 00000e17H
	add	eax, eax
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	add	eax, eax
	push	eax
	push	ecx
	call	_KB_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _blist, eax

; 3608 :       for ( ; spot < bmaxlist ; spot ++ ) blist[spot] = NULLID;

	cmp	edi, DWORD PTR _bmaxlist
	jge	SHORT $LN57@read_bodie
	npad	10
$LL127@read_bodie:
	mov	edx, DWORD PTR _blist
	mov	DWORD PTR [edx+edi*4], 0
	inc	edi
	cmp	edi, DWORD PTR _bmaxlist
	jl	SHORT $LL127@read_bodie
$LN57@read_bodie:

; 3609 :     }
; 3610 : #ifdef MPI_EVOLVER
; 3611 :     if ( !mpi_local_bodies_flag || (body_task == this_task) )
; 3612 : #endif
; 3613 :     {
; 3614 :       if ( valid_id(blist[k]) )

	mov	eax, DWORD PTR _blist
	test	DWORD PTR [eax+esi*4], 268435456	; 10000000H
	je	SHORT $LN131@read_bodie

; 3615 :       { sprintf(errmsg,"Duplicate body number %d\n",k);

	push	esi
	push	OFFSET ??_C@_0BK@FICAHELA@Duplicate?5body?5number?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 3616 :         kb_error(1187,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1187					; 000004a3H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN131@read_bodie:

; 3617 :       }
; 3618 :       move_to_free_front(BODY,k); /* so id will be k */

	push	esi
	push	3
	call	_move_to_free_front

; 3619 :       blist[k] = new_body();

	call	_new_body
	mov	ecx, DWORD PTR _blist
	mov	DWORD PTR [ecx+esi*4], eax

; 3620 :       set_original(blist[k],(k-1)|((element_id)BODY<<TYPESHIFT)|VALIDMASK);

	mov	edx, DWORD PTR _blist
	mov	eax, DWORD PTR [edx+esi*4]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	ecx, DWORD PTR [esi-1]
	or	ecx, 1879048192				; 70000000H
	mov	DWORD PTR [eax+20], ecx

; 3621 :       b_id = blist[k];

	mov	ecx, DWORD PTR _blist
	mov	edx, DWORD PTR [ecx+esi*4]

; 3622 :     }
; 3623 : #ifdef MPI_EVOLVER
; 3624 :     else
; 3625 :       b_id =  (k-1)|((element_id)BODY<<TYPESHIFT)|VALIDMASK |
; 3626 :                    (((element_id)body_task) << TASK_ID_SHIFT);
; 3627 : #endif
; 3628 : 
; 3629 :     f_id = NULLID;  /* in case no facets */
; 3630 :     while ( (tok = gettok(INTEGER_TOK)) == INTEGER_TOK )

	push	265					; 00000109H
	mov	DWORD PTR _b_id$[ebp], edx
	call	_gettok
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	jne	$LN132@read_bodie
$LL55@read_bodie:

; 3631 :     { 
; 3632 :      
; 3633 :       f = yylval.i;

	mov	edi, DWORD PTR _yylval

; 3634 : #ifdef MPI_EVOLVER
; 3635 :       facet_task = yylval.qnum;
; 3636 :       if ( facet_task == 0 )
; 3637 :              facet_task = 1;
; 3638 :       if ( facet_task >= mpi_nprocs )
; 3639 :       { sprintf(errmsg,"Task number %d exceeds number of tasks running, %d\n",
; 3640 :            facet_task,mpi_nprocs-1);
; 3641 :         kb_error(5012,errmsg,RECOVERABLE);
; 3642 :       }
; 3643 :       if ( facet_task != this_task )
; 3644 :         continue;
; 3645 :       else
; 3646 : #endif
; 3647 :       { 
; 3648 :         face_count++;

	inc	DWORD PTR _face_count$91346[ebp]

; 3649 :         if ( abs(f) >= fmaxlist )

	mov	eax, edi
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, DWORD PTR _fmaxlist
	jl	SHORT $LN53@read_bodie

; 3650 :         { sprintf(errmsg,"Body %d: face %d is not defined.\n",k,f);

	push	edi
	push	esi
	push	OFFSET ??_C@_0CC@PLOKLJGM@Body?5?$CFd?3?5face?5?$CFd?5is?5not?5defined?4@
	push	OFFSET _errmsg
	call	_sprintf

; 3651 :           kb_error(1188,errmsg,RECOVERABLE /*DATAFILE_ERROR*/);

	push	1
	push	OFFSET _errmsg
	push	1188					; 000004a4H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN53@read_bodie:

; 3652 :         }
; 3653 :         f_id = f > 0 ? flist[f] : facet_inverse(flist[-f]);

	test	edi, edi
	jle	SHORT $LN69@read_bodie
	mov	eax, DWORD PTR _flist
	mov	ebx, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN70@read_bodie
$LN69@read_bodie:
	mov	edx, DWORD PTR _flist
	lea	ecx, DWORD PTR [edi*4]
	sub	edx, ecx
	mov	ebx, DWORD PTR [edx]
	xor	ebx, 134217728				; 08000000H
$LN70@read_bodie:

; 3654 :         if ( !valid_id(f_id) )

	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN52@read_bodie

; 3655 :         { sprintf(errmsg,"Body %d: face %d is not defined.\n",k,f);

	push	edi
	push	esi
	push	OFFSET ??_C@_0CC@PLOKLJGM@Body?5?$CFd?3?5face?5?$CFd?5is?5not?5defined?4@
	push	OFFSET _errmsg
	call	_sprintf

; 3656 :           kb_error(1189,errmsg,RECOVERABLE /*DATAFILE_ERROR*/);

	push	1
	push	OFFSET _errmsg
	push	1189					; 000004a5H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN52@read_bodie:

; 3657 :         }
; 3658 :         set_facet_body(f_id, b_id);

	mov	eax, DWORD PTR _b_id$[ebp]
	push	eax
	push	ebx
	call	_set_facet_body
	push	265					; 00000109H
	call	_gettok
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	$LL55@read_bodie
$LN132@read_bodie:

; 3659 :       }
; 3660 :     } 
; 3661 :     #ifndef MPI_EVOLVER 
; 3662 :     if ( (web.representation != STRING) && (face_count < 1) )

	mov	eax, 1
	cmp	DWORD PTR _web+624, eax
	je	SHORT $LN126@read_bodie
	cmp	DWORD PTR _face_count$91346[ebp], eax
	jge	SHORT $LN126@read_bodie

; 3663 :     { sprintf(errmsg,"Body %d has no faces.\n",k);

	push	esi
	push	OFFSET ??_C@_0BH@EDJIGNFI@Body?5?$CFd?5has?5no?5faces?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 3664 :       kb_error(1190,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1190					; 000004a6H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN126@read_bodie:
	mov	edi, 1
	jmp	SHORT $LN50@read_bodie
$LL144@read_bodie:

; 3711 :               else 

	mov	edi, 1
	jmp	SHORT $LN146@read_bodie
	npad	4
$LL141@read_bodie:
	fstp	ST(1)
$LN146@read_bodie:
	fstp	ST(0)
$LN50@read_bodie:

; 3665 :     }
; 3666 :     #endif
; 3667 : 
; 3668 : #ifdef MPI_EVOLVER
; 3669 :     if ( mpi_local_bodies_flag && (body_task != this_task ) )
; 3670 :     {  /* skip until next body */
; 3671 :         while ( (tok != LEAD_INTEGER_TOK) && (tok != LEAD_INTEGER_AT_TOK) &&
; 3672 :                (tok != READ_TOK) && (tok != 0) )
; 3673 : 		{ tok = yylex();
; 3674 :         }
; 3675 :        continue;
; 3676 :     }
; 3677 : #endif
; 3678 : 
; 3679 :     more_attr = 1;
; 3680 :     while ( more_attr )
; 3681 :       switch ( tok )

	mov	eax, DWORD PTR _tok
	cmp	eax, 264				; 00000108H
	jg	SHORT $LN85@read_bodie
	je	SHORT $LN137@read_bodie
	test	eax, eax
	jne	$LN135@read_bodie
$LN137@read_bodie:

; 3827 : 
; 3828 :       }
; 3829 : 
; 3830 :     /* can't have both pressure and volume */
; 3831 :     if ((get_battr(blist[k]) & (FIXEDVOL|PRESSURE)) == (FIXEDVOL|PRESSURE))

	mov	edx, DWORD PTR _blist
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2080				; 00000820H
	xor	ecx, ecx
	cmp	eax, 2080				; 00000820H
	jne	$LL66@read_bodie
	test	ecx, ecx
	jne	$LL66@read_bodie

; 3832 :         kb_error(1203,"Body can't have fixed volume and fixed pressure.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DC@BNBOHGOI@Body?5can?8t?5have?5fixed?5volume?5and@
	push	1203					; 000004b3H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3833 :   } /* end body loop */

	jmp	$LL66@read_bodie
$LN85@read_bodie:

; 3665 :     }
; 3666 :     #endif
; 3667 : 
; 3668 : #ifdef MPI_EVOLVER
; 3669 :     if ( mpi_local_bodies_flag && (body_task != this_task ) )
; 3670 :     {  /* skip until next body */
; 3671 :         while ( (tok != LEAD_INTEGER_TOK) && (tok != LEAD_INTEGER_AT_TOK) &&
; 3672 :                (tok != READ_TOK) && (tok != 0) )
; 3673 : 		{ tok = yylex();
; 3674 :         }
; 3675 :        continue;
; 3676 :     }
; 3677 : #endif
; 3678 : 
; 3679 :     more_attr = 1;
; 3680 :     while ( more_attr )
; 3681 :       switch ( tok )

	cmp	eax, 549				; 00000225H
	jg	$LN86@read_bodie
	je	SHORT $LN137@read_bodie
	sub	eax, 284				; 0000011cH
	cmp	eax, 221				; 000000ddH
	ja	$LN135@read_bodie
	movzx	ecx, BYTE PTR $LN125@read_bodie[eax]
	jmp	DWORD PTR $LN147@read_bodie[ecx*4]
$LN44@read_bodie:

; 3692 :        
; 3693 :         case CENTEROFMASS_TOK:
; 3694 :               set_attr(blist[k],WANT_CENTEROFMASS);

	mov	edx, DWORD PTR _blist
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+8]
	or	DWORD PTR [eax+12], 2

; 3695 :               tok = yylex();

	push	0
	mov	DWORD PTR [eax+8], ecx
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3696 :               break;

	jmp	$LN50@read_bodie
$LN43@read_bodie:

; 3697 : 
; 3698 :         case ORIGINAL_TOK:
; 3699 :               if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN42@read_bodie

; 3700 :               { kb_error(2117,"ORIGINAL value missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BJ@ICLHKEOI@ORIGINAL?5value?5missing?4?6?$AA@
	push	2117					; 00000845H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3701 :                 break;

	jmp	$LN50@read_bodie
$LN42@read_bodie:

; 3702 :               }
; 3703 :               set_original(blist[k],(yylval.i-1)|((element_id)BODY<<TYPESHIFT)|VALIDMASK);

	mov	edx, DWORD PTR _blist
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR _yylval
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	dec	ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	or	ecx, 1879048192				; 70000000H

; 3704 :               tok = yylex();

	push	0
	mov	DWORD PTR [eax+20], ecx
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3705 :               break;

	jmp	$LN50@read_bodie
$LN41@read_bodie:

; 3706 : 
; 3707 :         case VOLUME_TOK:
; 3708 :               /* have a fixed volume constraint */
; 3709 :               if ( read_const(&vol) <= 0 )

	lea	ecx, DWORD PTR _vol$91345[ebp]
	push	ecx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN40@read_bodie

; 3710 :                 kb_error(1191,"Missing VOLUME value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BH@NBEBMNFH@Missing?5VOLUME?5value?4?6?$AA@
	push	1191					; 000004a7H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3711 :               else 

	jmp	$LN50@read_bodie
$LN40@read_bodie:

; 3712 :               { set_attr(blist[k],FIXEDVOL);

	mov	edx, DWORD PTR _blist
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 32			; 00000020H
	mov	DWORD PTR [eax+12], ecx

; 3713 :                 set_body_fixvol(blist[k],vol);

	mov	edx, DWORD PTR _blist
	fld	QWORD PTR _vol$91345[ebp]
	mov	eax, DWORD PTR [edx+esi*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	call	_set_body_fixvol

; 3714 :                 tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tok, eax

; 3715 :               }
; 3716 :               break;

	jmp	$LN50@read_bodie
$LN35@read_bodie:

; 3728 : 
; 3729 : 
; 3730 :         case VOLCONST_TOK:
; 3731 :               /* have a body volume adjustment */
; 3732 :               if ( read_const(&vol) <= 0 )

	lea	ecx, DWORD PTR _vol$91345[ebp]
	push	ecx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN34@read_bodie

; 3733 :                 kb_error(1192,"Missing VOLCONST value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BJ@MHEPGMAC@Missing?5VOLCONST?5value?4?6?$AA@
	push	1192					; 000004a8H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN33@read_bodie
$LN34@read_bodie:

; 3734 :               else tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN33@read_bodie:

; 3735 :               set_body_volconst(blist[k],vol); 

	mov	edx, DWORD PTR _blist
	fld	QWORD PTR _vol$91345[ebp]
	mov	eax, DWORD PTR [edx+esi*4]
	fld	ST(0)
	test	eax, 268435456				; 10000000H
	je	$LL141@read_bodie
	mov	ecx, DWORD PTR _web+348
	fxch	ST(1)
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [ecx+eax]
	fstp	QWORD PTR [edx+328]
	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LL144@read_bodie
	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [edx+404]
	mov	ecx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	fstp	QWORD PTR [eax+ecx+208]

; 3736 :               break;

	jmp	$LN50@read_bodie
$LN32@read_bodie:

; 3737 : 
; 3738 :         case DENSITY_TOK:
; 3739 :               /* have density for gravity */
; 3740 :               if ( read_const(&den) <= 0 )

	lea	edx, DWORD PTR _den$91344[ebp]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN31@read_bodie

; 3741 :                 kb_error(1193,"Missing DENSITY value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BI@PJJAKHC@Missing?5DENSITY?5value?4?6?$AA@
	push	1193					; 000004a9H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN30@read_bodie
$LN31@read_bodie:

; 3742 :               else tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN30@read_bodie:

; 3743 :               web.gravflag = 1;
; 3744 :               set_body_density(blist[k],den);

	mov	eax, DWORD PTR _blist
	mov	DWORD PTR _web+824, edi
	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN133@read_bodie
	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _den$91344[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+344]
$LN133@read_bodie:

; 3745 :               set_attr(blist[k],DENSITY);

	mov	eax, DWORD PTR _blist
	mov	eax, DWORD PTR [eax+esi*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 16			; 00000010H
	mov	DWORD PTR [eax+12], ecx

; 3746 :               break;

	jmp	$LN50@read_bodie
$LN29@read_bodie:

; 3747 : 
; 3748 :         case PRESSURE_TOK:
; 3749 :               /* have prescribed pressure */
; 3750 :               web.pressflag = 1;
; 3751 :               set_attr(blist[k],PRESSURE);

	mov	edx, DWORD PTR _blist
	mov	DWORD PTR _web+844, edi
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 2048			; 00000800H

; 3752 :               if ( read_const(&value) <= 0 )

	lea	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	DWORD PTR [eax+12], ecx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN28@read_bodie

; 3753 :                 kb_error(1194,"Missing PRESSURE value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BJ@MFADOPAL@Missing?5PRESSURE?5value?4?6?$AA@
	push	1194					; 000004aaH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3754 :               else 

	jmp	$LN50@read_bodie
$LN28@read_bodie:

; 3755 :               { set_body_pressure(blist[k],value);

	mov	eax, DWORD PTR _blist
	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN108@read_bodie
	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _value$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+312]
$LN108@read_bodie:

; 3756 :                 tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3757 :               }
; 3758 :               break;

	jmp	$LN50@read_bodie
$LN23@read_bodie:

; 3768 :               
; 3769 :         case PHASE_TOK: 
; 3770 :               if ( !phase_flag )

	cmp	DWORD PTR _phase_flag, 0
	jne	SHORT $LN134@read_bodie

; 3771 :                 kb_error(1195,"Phases not in effect.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BH@EDLGBDIJ@Phases?5not?5in?5effect?4?6?$AA@
	push	1195					; 000004abH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN134@read_bodie:

; 3772 : 
; 3773 :               if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, edi
	jne	SHORT $LN138@read_bodie

; 3774 :                 kb_error(1196,"Phases must be on facets in STRING model.\n",
; 3775 : 
; 3776 :                    DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CL@NBAGFHJM@Phases?5must?5be?5on?5facets?5in?5STRI@
	push	1196					; 000004acH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN138@read_bodie:

; 3777 :               if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN20@read_bodie

; 3778 :                { kb_error(1197,"Phase missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BA@DKJJCAOO@Phase?5missing?4?6?$AA@
	push	1197					; 000004adH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3779 :                   break;

	jmp	$LN50@read_bodie
$LN20@read_bodie:

; 3780 :                }
; 3781 :               if ( (yylval.i < 0) || (yylval.i > phasemax) )

	mov	ecx, DWORD PTR _yylval
	test	ecx, ecx
	js	SHORT $LN18@read_bodie
	cmp	ecx, DWORD PTR _phasemax
	jg	SHORT $LN18@read_bodie

; 3783 : 
; 3784 :               else set_b_phase(blist[k],yylval.i);

	mov	eax, DWORD PTR _B_PHASE_ATTR
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+440
	add	eax, DWORD PTR _dymem
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $LN72@read_bodie
	mov	edx, DWORD PTR _blist
	mov	edx, DWORD PTR [edx+esi*4]
	mov	ebx, DWORD PTR _web+348
	mov	eax, DWORD PTR [eax+64]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]

; 3785 :               tok = yylex();

	push	0
	mov	DWORD PTR [edx+eax], ecx
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3786 :               break;

	jmp	$LN50@read_bodie
$LN18@read_bodie:

; 3782 :                 kb_error(1198,"Illegal phase value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BG@DIEMLGNJ@Illegal?5phase?5value?4?6?$AA@
	push	1198					; 000004aeH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN72@read_bodie:

; 3785 :               tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3786 :               break;

	jmp	$LN50@read_bodie
$LN13@read_bodie:

; 3799 :               break;
; 3800 : 
; 3801 :            case IDENT_TOK:  /* maybe method or quantity */
; 3802 :               if ( globals(yylval.i)->flags & METHOD_NAME )

	mov	edi, DWORD PTR _yylval
	mov	ebx, DWORD PTR _dymem
	mov	edx, edi
	and	edx, -16777216				; ff000000H
	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN73@read_bodie
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN75@read_bodie
	mov	ebx, DWORD PTR _localbase
	mov	eax, edi
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR _dymem
	jmp	SHORT $LN74@read_bodie
$LN75@read_bodie:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN73@read_bodie
	mov	ecx, DWORD PTR _web+5656
	mov	eax, edi
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN74@read_bodie
$LN73@read_bodie:
	mov	ecx, DWORD PTR _web+5652
	mov	eax, edi
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [ecx+ebx]
$LN74@read_bodie:
	test	DWORD PTR [ecx+192], 1024		; 00000400H
	je	SHORT $LN12@read_bodie

; 3803 :                 apply_method(blist[k],yytext);

	mov	edx, DWORD PTR _yytext
	mov	eax, DWORD PTR _blist
	mov	ecx, DWORD PTR [eax+esi*4]
	push	edx
	push	ecx
	call	_apply_method
	add	esp, 8
	jmp	$LN9@read_bodie
$LN12@read_bodie:

; 3804 :               else if ( globals(yylval.i)->flags & QUANTITY_NAME )

	cmp	edx, 268435456				; 10000000H
	jne	SHORT $LN83@read_bodie
	mov	edx, DWORD PTR _web+5652
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ebx]
	jmp	SHORT $LN80@read_bodie
$LN83@read_bodie:
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN81@read_bodie
	mov	ecx, DWORD PTR _localbase
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN80@read_bodie
$LN81@read_bodie:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN79@read_bodie
	mov	edx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN80@read_bodie
$LN79@read_bodie:
	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+ebx]
$LN80@read_bodie:
	test	BYTE PTR [eax+192], -128		; ffffff80H
	je	SHORT $LN10@read_bodie

; 3805 :                 apply_quantity(blist[k],yylval.i);

	mov	eax, DWORD PTR _blist
	mov	ecx, DWORD PTR [eax+esi*4]
	push	edi
	push	ecx
	call	_apply_quantity
	add	esp, 8

; 3806 :               else 

	jmp	SHORT $LN9@read_bodie
$LN10@read_bodie:

; 3807 :               { sprintf(errmsg,"Illegal use of identifier: %s.\n",yytext);

	mov	edx, DWORD PTR _yytext
	push	edx
	push	OFFSET ??_C@_0CA@ELJKNGHN@Illegal?5use?5of?5identifier?3?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 3808 :                 kb_error(1199,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1199					; 000004afH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN9@read_bodie:

; 3809 :               }
; 3810 :               tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3811 :               break;

	mov	edi, 1
	jmp	$LN50@read_bodie
$LN86@read_bodie:

; 3665 :     }
; 3666 :     #endif
; 3667 : 
; 3668 : #ifdef MPI_EVOLVER
; 3669 :     if ( mpi_local_bodies_flag && (body_task != this_task ) )
; 3670 :     {  /* skip until next body */
; 3671 :         while ( (tok != LEAD_INTEGER_TOK) && (tok != LEAD_INTEGER_AT_TOK) &&
; 3672 :                (tok != READ_TOK) && (tok != 0) )
; 3673 : 		{ tok = yylex();
; 3674 :         }
; 3675 :        continue;
; 3676 :     }
; 3677 : #endif
; 3678 : 
; 3679 :     more_attr = 1;
; 3680 :     while ( more_attr )
; 3681 :       switch ( tok )

	cmp	eax, 35013				; 000088c5H
	jg	$LN87@read_bodie
	je	$LN26@read_bodie
	cmp	eax, 566				; 00000236H
	je	$LN46@read_bodie
	cmp	eax, 35011				; 000088c3H
	jne	$LN135@read_bodie

; 3717 : 
; 3718 :         case ACTUAL_VOLUME_TOK: 
; 3719 :               /* have a declared volume */
; 3720 :               if ( read_const(&vol) <= 0 )

	lea	eax, DWORD PTR _vol$91345[ebp]
	push	eax
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN37@read_bodie

; 3721 :                 kb_error(1075,"Missing ACTUAL_VOLUME value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BO@PAEILJJD@Missing?5ACTUAL_VOLUME?5value?4?6?$AA@
	push	1075					; 00000433H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3722 :               else 

	jmp	$LN50@read_bodie
$LN37@read_bodie:

; 3723 :               { set_attr(blist[k],ACTUALVOL);

	mov	ecx, DWORD PTR _blist
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 134217728		; 08000000H
	mov	DWORD PTR [eax+12], edx

; 3724 :                 set_body_actualvolume(blist[k],vol);

	mov	eax, DWORD PTR _blist
	mov	ecx, DWORD PTR [eax+esi*4]
	fld	QWORD PTR _vol$91345[ebp]
	mov	edx, DWORD PTR _web+348
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]

; 3725 :                 tok = yylex();

	push	0
	fstp	QWORD PTR [eax+296]
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3726 :               }
; 3727 :               break;

	jmp	$LN50@read_bodie
$LN46@read_bodie:

; 3682 :       {
; 3683 :         case EXTRA_ATTRIBUTE_TOK:
; 3684 :         case ARRAY_ATTRIBUTE_TOK:
; 3685 :                if ( yylval.etype != BODY )

	mov	eax, DWORD PTR _yylval+24
	cmp	eax, 3
	je	SHORT $LN45@read_bodie

; 3686 :                { sprintf(errmsg,"'%s' is a %s attribute, not a body attribute.\n",
; 3687 :                         yytext,typenames[yylval.etype]);

	mov	ecx, DWORD PTR _typenames[eax*4]
	mov	edx, DWORD PTR _yytext
	push	ecx
	push	edx
	push	OFFSET ??_C@_0CP@MOBMBCEC@?8?$CFs?8?5is?5a?5?$CFs?5attribute?0?5not?5a?5bo@
	push	OFFSET _errmsg
	call	_sprintf

; 3688 :                  kb_error(4319,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	4319					; 000010dfH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN45@read_bodie:

; 3689 :                }
; 3690 :                read_extra(blist[k],yylval.qnum);

	mov	eax, DWORD PTR _yylval+4
	mov	ecx, DWORD PTR _blist
	mov	edx, DWORD PTR [ecx+esi*4]
	push	eax
	push	edx
	call	_read_extra
	add	esp, 8

; 3691 :               break;

	jmp	$LN50@read_bodie
$LN26@read_bodie:

; 3759 : 
; 3760 :         case LAGRANGE_MULTIPLIER_TOK:
; 3761 :               if ( read_const(&value) <= 0 )

	lea	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN25@read_bodie

; 3762 :                 kb_error(2118,"Missing lagrange_multiplier value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CE@GJDPGLEJ@Missing?5lagrange_multiplier?5valu@
	push	2118					; 00000846H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3763 :               else 

	jmp	$LN50@read_bodie
$LN25@read_bodie:

; 3764 :               { set_body_pressure(blist[k],value); lagmulflag = 1; 

	mov	ecx, DWORD PTR _blist
	mov	eax, DWORD PTR [ecx+esi*4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN112@read_bodie
	mov	edx, DWORD PTR _web+348
	fld	QWORD PTR _value$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	fstp	QWORD PTR [eax+312]
$LN112@read_bodie:

; 3765 :                 tok = yylex();

	push	0
	mov	DWORD PTR _lagmulflag$[ebp], edi
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3766 :               }
; 3767 :               break;

	jmp	$LN50@read_bodie
$LN87@read_bodie:

; 3665 :     }
; 3666 :     #endif
; 3667 : 
; 3668 : #ifdef MPI_EVOLVER
; 3669 :     if ( mpi_local_bodies_flag && (body_task != this_task ) )
; 3670 :     {  /* skip until next body */
; 3671 :         while ( (tok != LEAD_INTEGER_TOK) && (tok != LEAD_INTEGER_AT_TOK) &&
; 3672 :                (tok != READ_TOK) && (tok != 0) )
; 3673 : 		{ tok = yylex();
; 3674 :         }
; 3675 :        continue;
; 3676 :     }
; 3677 : #endif
; 3678 : 
; 3679 :     more_attr = 1;
; 3680 :     while ( more_attr )
; 3681 :       switch ( tok )

	sub	eax, 35024				; 000088d0H
	je	SHORT $LN16@read_bodie
	sub	eax, 60					; 0000003cH
	je	SHORT $LN7@read_bodie
$LN135@read_bodie:

; 3822 :       default: 
; 3823 :           sprintf(errmsg,"Unexpected token: %s\n",yytext);

	mov	ecx, DWORD PTR _yytext
	push	ecx
	push	OFFSET ??_C@_0BG@BKFJJJKH@Unexpected?5token?3?5?$CFs?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 3824 :           kb_error(2119,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2119					; 00000847H
	call	_kb_error

; 3825 :           tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tok, eax

; 3826 :           break;

	jmp	$LN50@read_bodie
$LN7@read_bodie:

; 3812 : 
; 3813 : 		   case READ_TOK: case LEAD_INTEGER_TOK: case NO_TOKEN: case LEAD_INTEGER_AT_TOK:
; 3814 :                 more_attr = 0 ; break; 
; 3815 :  /* error recovery */
; 3816 :         case UNPUTTED_TOK: 
; 3817 :                 kb_error(3703,
; 3818 :                    "Internal error: forgot to get lookahead token.\n",
; 3819 :                        WARNING);

	push	2
	push	OFFSET ??_C@_0DA@MGFNEFND@Internal?5error?3?5forgot?5to?5get?5lo@
	push	3703					; 00000e77H
	call	_kb_error

; 3820 :                 tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tok, eax

; 3821 :                 break;

	jmp	$LN50@read_bodie
$LN16@read_bodie:

; 3787 : 
; 3788 :            case METHOD_TOK:  /* apply method instance to edge */
; 3789 :               tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3790 :               if ( tok != METHOD_NAME_TOK )

	cmp	eax, 414				; 0000019eH
	je	SHORT $LN130@read_bodie

; 3791 :               { kb_error(5777,"Missing method instance name.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@MGOCAHJG@Missing?5method?5instance?5name?4?6?$AA@
	push	5777					; 00001691H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3792 :                 break;

	jmp	$LN50@read_bodie
$LN130@read_bodie:

; 3793 :               }
; 3794 :               // else fall through to METHOD_NAME_TOK
; 3795 : 
; 3796 :            case METHOD_NAME_TOK:
; 3797 :               apply_method(blist[k],yytext);

	mov	edx, DWORD PTR _yytext
	mov	eax, DWORD PTR _blist
	mov	ecx, DWORD PTR [eax+esi*4]
	push	edx
	push	ecx
	call	_apply_method

; 3798 :               tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax
	jmp	$LN50@read_bodie
$LN65@read_bodie:

; 3834 : 
; 3835 :   if ( web.bodycount > 0 )

	cmp	DWORD PTR _web+1500, 0
	pop	edi
	pop	esi
	pop	ebx
	jle	SHORT $LN4@read_bodie

; 3836 :       web.projection_flag = 1;

	mov	DWORD PTR _web+872, 1
$LN4@read_bodie:

; 3837 : 
; 3838 :   if ( !lagmulflag ) pressure_set_flag = 0;

	cmp	DWORD PTR _lagmulflag$[ebp], 0
	jne	SHORT $LN3@read_bodie
	mov	DWORD PTR _pressure_set_flag, 0
$LN3@read_bodie:

; 3839 : 
; 3840 :   if ( web.pressure_flag)

	cmp	DWORD PTR _web+868, 0
	je	SHORT $LN1@read_bodie

; 3841 :   {
; 3842 :     if ( !web.full_flag && !valid_id(web.outside_body) )

	cmp	DWORD PTR _web+864, 0
	jne	SHORT $LN1@read_bodie
	test	DWORD PTR _web+1504, 268435456		; 10000000H
	jne	SHORT $LN1@read_bodie

; 3843 :       add_outside();

	call	_add_outside
$LN1@read_bodie:

; 3844 :   }
; 3845 : 
; 3846 : } /* end read_bodies() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN147@read_bodie:
	DD	$LN46@read_bodie
	DD	$LN13@read_bodie
	DD	$LN35@read_bodie
	DD	$LN41@read_bodie
	DD	$LN43@read_bodie
	DD	$LN32@read_bodie
	DD	$LN29@read_bodie
	DD	$LN137@read_bodie
	DD	$LN130@read_bodie
	DD	$LN44@read_bodie
	DD	$LN23@read_bodie
	DD	$LN135@read_bodie
$LN125@read_bodie:
	DB	0
	DB	11					; 0000000bH
	DB	1
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	2
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	3
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	4
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	5
	DB	6
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	7
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	8
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	9
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	10					; 0000000aH
_read_bodies ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@NJENFFAA@Cannot?5do?5homothety?5without?5bodi@ ; `string'
PUBLIC	??_C@_0BP@OAFHPFJG@Number?5of?5vertices?5popped?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@BCFEOGPP@No?5edges?5found?5in?5datafile?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@OOHLDEKN@No?5vertices?5found?5in?5datafile?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@MPAJEHHD@Bad?5data?5file?4?6?$AA@	; `string'
PUBLIC	??_C@_06IJDLPEM@length?$AA@			; `string'
PUBLIC	??_C@_0DI@FNDBGOJC@Converting?5to?5named?5quantities?5f@ ; `string'
PUBLIC	??_C@_0DE@NGDIDIBI@Converting?5to?5named?5quantities?5f@ ; `string'
PUBLIC	??_C@_0CE@CPMJENCO@Faces?5list?5must?5precede?5body?5lis@ ; `string'
PUBLIC	??_C@_0CL@JFDKOOIO@Vertices?5list?5must?5be?5first?5elem@ ; `string'
PUBLIC	??_C@_0EA@HCFNNEMF@Must?5have?5simplex?5representation@ ; `string'
PUBLIC	??_C@_0CJ@JHNGAGBL@Edges?5list?5must?5be?5second?5elemen@ ; `string'
PUBLIC	??_C@_0EI@LFINBAOG@Bad?5content?5component?5?$CFd?5definit@ ; `string'
PUBLIC	??_C@_0BF@JFDCKONH@Illegal?5token?5?8?$CFs?8?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@DBLPODHF@Missing?5TEMPERATURE?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@FELGNELD@Missing?5GAP_CONSTANT?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@ELBPBAMK@Missing?5GRAVITY_CONSTANT?5value?4?6@ ; `string'
PUBLIC	??_C@_0BN@NGGEHPKJ@Missing?5MERIT?5FACTOR?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@DLJCKBBD@Tolerance?5must?5be?5positive?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@NPCHGACN@Missing?5CONSTRAINT_TOLERANCE?5val@ ; `string'
PUBLIC	??_C@_0BN@PPLFNOLF@Missing?5ZOOM?5VERTEX?5number?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@KIOPFAJA@Missing?5ZOOM?5RADIUS?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@BNFBILLP@Missing?5TOTAL_TIME?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@CEOHDAHL@Missing?5SCALE_LIMIT?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@IDOBCKPD@mobility?5tensor?5component?5?$FL?$CFd?$FN?$FL?$CF@ ; `string'
PUBLIC	??_C@_0CJ@EAPHMDEP@Bad?5mobility_tensor?$FL?$CFd?$FN?$FL?$CFd?$FN?5defi@ ; `string'
PUBLIC	??_C@_0BK@IDOKOAMM@Bad?5mobility?5definition?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BB@OCMPBOEO@mobility?5formula?$AA@	; `string'
PUBLIC	??_C@_0CJ@EADLCLOO@Missing?5square?5curvature?5modulus@ ; `string'
PUBLIC	??_C@_0BF@ODONALIB@sq_curvature_modulus?$AA@	; `string'
PUBLIC	??_C@_0DH@EKACIEOJ@Can?5do?5square?5gauss?5curvature?5on@ ; `string'
PUBLIC	??_C@_0CI@NKIKIKPL@Missing?5square?5gaussian?5modulus?5@ ; `string'
PUBLIC	??_C@_0BF@MCIHOOCD@square_gauss_modulus?$AA@	; `string'
PUBLIC	??_C@_0BJ@PHNDOFLD@gauss_curvature_integral?$AA@ ; `string'
PUBLIC	??_C@_0DA@FONHHPKP@Can?5do?5gauss?5curvature?5only?5in?5S@ ; `string'
PUBLIC	??_C@_0DL@CJGMDKOF@Can?5do?5integral?5of?5mean?5curvatur@ ; `string'
PUBLIC	??_C@_0FI@LKAHFFEK@Missing?5integral?5mean?5curvature?5@ ; `string'
PUBLIC	??_C@_0BH@HGNBHJNG@mean_curvature_modulus?$AA@	; `string'
PUBLIC	??_C@_0BE@LOBABENM@uniform_knot_energy?$AA@	; `string'
PUBLIC	??_C@_0M@BGBMOCLO@knot_energy?$AA@		; `string'
PUBLIC	??_C@_0CF@FBNOILCH@clip_coeff?5initializer?5missing?5?8@ ; `string'
PUBLIC	??_C@_0CH@MIIDBODK@Not?5enough?5values?5for?5display_or@ ; `string'
PUBLIC	??_C@_0P@OAMDDONM@display_origin?$AA@		; `string'
PUBLIC	??_C@_0BN@DMLCKLLD@Cannot?5find?5phasefile?5name?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@DNEHBIJK@Wulff?5file?5name?5missing?4?6?$AA@ ; `string'
PUBLIC	??_C@_0EB@JHOGNIBN@addload?5datafile?5has?5different?5L@ ; `string'
PUBLIC	??_C@_0CI@BAGDPBEE@addload?5datafile?5not?5in?5Lagrange@ ; `string'
PUBLIC	??_C@_0BJ@MMMIPAME@Lagrange?5order?5missing?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@DILGNDHE@Missing?5symmetry?5group?5name?4?6?$AA@ ; `string'
PUBLIC	??_C@_05FCPCBJIO@torus?$AA@			; `string'
PUBLIC	??_C@_0CN@IJOKADDI@Symmetry?5name?5?8?$CFs?8?5not?5found?5in?5@ ; `string'
PUBLIC	??_C@_0BK@OOHCNGCP@metric?5component?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	??_C@_0CC@EDNHONDD@Bad?5metric?5g?$FL?$CFd?$FN?$FL?$CFd?$FN?5definition?4@ ; `string'
PUBLIC	??_C@_0BB@LMKJAPE@conformal?5metric?$AA@	; `string'
PUBLIC	??_C@_0CC@GHIPFDMN@Bad?5conformal?5metric?5definition?4@ ; `string'
PUBLIC	??_C@_0DA@FILMHLNM@Surface?5dimension?5higher?5than?5sp@ ; `string'
PUBLIC	??_C@_0BP@GAKBJBHJ@Dimension?5of?5surface?5missing?4?6?$AA@ ; `string'
PUBLIC	??_C@_0EN@IGMMIJNI@Space?5dimension?5too?5high?4?5?5Recom@ ; `string'
PUBLIC	??_C@_0BN@LPEBGEG@Dimension?5of?5space?5missing?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@KPGCCCNG@LOAD_LIBRARY?5file?5name?5missing?4?6@ ; `string'
PUBLIC	??_C@_0EH@KBCGPNLA@?6Datafile?5?$CFs?5needs?5Evolver?5versi@ ; `string'
PUBLIC	??_C@_0CH@EPFCLKFB@area_method_name?5needs?5quoted?5st@ ; `string'
PUBLIC	??_C@_0CJ@PIDJOHNH@length_method_name?5needs?5quoted?5@ ; `string'
PUBLIC	??_C@_0BF@GPHNFCAP@spherical_arc_length?$AA@	; `string'
PUBLIC	??_C@_0BE@OOOEBCHL@circular_arc_length?$AA@	; `string'
PUBLIC	??_C@_0CE@EPOONLLG@hessian_special_normal?5component@ ; `string'
PUBLIC	??_C@_0DB@ILDABPKE@Method_instances_predicted?5must?5@ ; `string'
PUBLIC	??_C@_0CM@BCDJPNPP@Missing?5method_instances_predict@ ; `string'
PUBLIC	??_C@_0CL@ILLLMBPC@Quantities_predicted?5must?5be?5non@ ; `string'
PUBLIC	??_C@_0CG@HOIDIOKP@Missing?5quantities_predicted?5num@ ; `string'
PUBLIC	??_C@_0CL@LJPHAGLH@Facetedges_predicted?5must?5be?5non@ ; `string'
PUBLIC	??_C@_0CG@FNDIGCBP@Missing?5facetedges_predicted?5num@ ; `string'
PUBLIC	??_C@_0CH@KOAIAFMM@Bodies_predicted?5must?5be?5nonnega@ ; `string'
PUBLIC	??_C@_0CC@PMAPEPHJ@Missing?5bodies_predicted?5number?4@ ; `string'
PUBLIC	??_C@_0CG@KFHJFP@Faces_predicted?5must?5be?5nonnegat@ ; `string'
PUBLIC	??_C@_0CC@BOGJNNPF@Missing?5facets_predicted?5number?4@ ; `string'
PUBLIC	??_C@_0CG@JLLOGAAP@Edges_predicted?5must?5be?5nonnegat@ ; `string'
PUBLIC	??_C@_0CB@FDEIENDO@Missing?5edges_predicted?5number?4?6@ ; `string'
PUBLIC	??_C@_0CJ@DHAABPBI@Vertices_predicted?5must?5be?5nonne@ ; `string'
PUBLIC	??_C@_0CE@MMMILBBM@Missing?5vertices_predicted?5numbe@ ; `string'
PUBLIC	??_C@_0CJ@HAEPAFLK@volume_method_name?5needs?5quoted?5@ ; `string'
PUBLIC	??_C@_0CF@CGCPNNKG@Invalid?5INTEGRAL_ORDER_2D?5value?5@ ; `string'
PUBLIC	??_C@_0CC@PMAPNCHP@Missing?5INTEGRAL_ORDER_2D?5value?4@ ; `string'
PUBLIC	??_C@_0CG@OMGLPLHB@Missing?5unsuppressed?5warning?5num@ ; `string'
PUBLIC	??_C@_0CC@IDAJELNI@Invalid?5INTEGRAL_ORDER?5value?5?$CFd?4@ ; `string'
PUBLIC	??_C@_0BP@GEPDLMPC@Missing?5INTEGRAL_ORDER?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@FKEOPIHN@Invalid?5INTEGRAL_ORDER_1D?5value?5@ ; `string'
PUBLIC	??_C@_0CC@GFONLEHO@Missing?5INTEGRAL_ORDER_1D?5value?4@ ; `string'
PUBLIC	??_C@_0BP@EAFIIJC@Too?5many?5warnings?5suppressed?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CE@PBGBCJEK@Missing?5suppressed?5warning?5numbe@ ; `string'
PUBLIC	??_C@_0BG@HHDBINKH@Missing?5SCALE?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@KFFCGAOL@Missing?5AUTOCHOP?5length?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@JNKAIEKD@Missing?5DIFFUSION?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@IJBPFNBA@Missing?5fixed?5area?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DH@FLLLMGHG@Area_fixed?5is?5obsolete?4?5?5Replace@ ; `string'
PUBLIC	??_C@_0BJ@DGNKKEGC@procedure?5_anti_line_no_?$AA@ ; `string'
PUBLIC	??_C@_0BI@KKMILGMA@function?5_anti_line_no_?$AA@ ; `string'
PUBLIC	??_C@_0CE@BPKPNIKE@Not?5enough?5values?5for?5view?5matri@ ; `string'
PUBLIC	??_C@_0CJ@JOABNBND@addload?5datafile?5not?5in?5quadrati@ ; `string'
PUBLIC	??_C@_0CG@OFJHKPPL@addload?5datafile?5not?5in?5linear?5m@ ; `string'
PUBLIC	??_C@_0CL@OCCCFIHM@Bad?5function?5definition?5for?5attr@ ; `string'
PUBLIC	??_C@_0BH@MCCLBIBM@attribute?5?8?$CFs?8?5formula?$AA@ ; `string'
PUBLIC	??_C@_0CJ@MFGCEIAK@Attribute?5dimension?5must?5be?5at?5l@ ; `string'
PUBLIC	??_C@_0BI@HJEBGFAN@Need?5dimension?5number?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DN@NKHGBANH@Extra?5attribute?5?$CFs?5has?5more?5dime@ ; `string'
PUBLIC	??_C@_0BK@DDHFONOJ@Need?5attribute?5datatype?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@BGBAKMFH@Need?5new?5identifier?4?5?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@FPBINCDC@Need?5ATTRIBUTE?5keyword?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@BJFMIBDG@Bad?5element?5type?5in?5?8define?8?4?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_initialize
EXTRN	_auto_convert_flag:DWORD
EXTRN	_update_display:PROC
EXTRN	_edgepop_film:PROC
EXTRN	_verpop_str:PROC
EXTRN	_string_grad_l:PROC
EXTRN	_string_grad:DWORD
EXTRN	_edge_area_l:PROC
EXTRN	_calc_edge_area:DWORD
EXTRN	_edge_force_l:PROC
EXTRN	_calc_edge_forces:DWORD
EXTRN	_edge_energy_l:PROC
EXTRN	_calc_edge_energy:DWORD
EXTRN	_film_grad_l:PROC
EXTRN	_film_grad:DWORD
EXTRN	_facet_volume_l:PROC
EXTRN	_facet_force_l:PROC
EXTRN	_facet_energy_l:PROC
EXTRN	_refine_simplex_init:PROC
EXTRN	_volume_factorial:QWORD
EXTRN	_myfree:PROC
EXTRN	_facetedge_check:PROC
EXTRN	_facet_body_check:PROC
EXTRN	_set_f_phase_density:PROC
EXTRN	_set_e_phase_density:PROC
EXTRN	_string_fixup:PROC
EXTRN	_fe_reorder:PROC
EXTRN	_face_triangulate:PROC
EXTRN	_mark_recalc_params:PROC
EXTRN	_convert_bodies_to_quantities:PROC
EXTRN	_outstring:PROC
EXTRN	_convert_to_quantities:PROC
EXTRN	_pop_commandfd:PROC
EXTRN	_brace_depth:DWORD
EXTRN	_parens:DWORD
EXTRN	_in_quote:DWORD
EXTRN	_view_transforms_unique_point_global:DWORD
EXTRN	_reset_view:PROC
EXTRN	_calc_periods:PROC
EXTRN	_setup_q_info:PROC
EXTRN	_gauss_setup:PROC
EXTRN	_check_forwards:PROC
EXTRN	_square_curvature_param:DWORD
EXTRN	_sqgauss_param:DWORD
EXTRN	_mean_curvature_param:DWORD
EXTRN	_add_standard_quantity:PROC
EXTRN	_read_surface_energy:PROC
EXTRN	_read_parameter:PROC
EXTRN	_slice_coeff_global:DWORD
EXTRN	_read_array_initializer:PROC
EXTRN	_clip_coeff_global:DWORD
EXTRN	_read_transform_generators:PROC
EXTRN	_add_global:PROC
EXTRN	_lookup_global:PROC
EXTRN	_read_display_periods:PROC
EXTRN	_read_periods:PROC
EXTRN	_phase_initialize:PROC
EXTRN	_wulff_initialize:PROC
EXTRN	_torus_compose:PROC
EXTRN	_torus_inverse:PROC
EXTRN	_torus_form_pullback:PROC
EXTRN	_torus_wrap:PROC
EXTRN	_torus_period_init:PROC
EXTRN	_kb_stricmp:PROC
EXTRN	_sym_register:BYTE
EXTRN	_det_array:DWORD
EXTRN	_metric_partial:DWORD
EXTRN	_kb_dmatrix3:PROC
EXTRN	_metric:DWORD
EXTRN	_kb_dmatrix:PROC
EXTRN	_calc_simplex_forces:PROC
EXTRN	_calc_facet_forces:DWORD
EXTRN	_calc_simplex_energy:PROC
EXTRN	_calc_facet_energy:DWORD
EXTRN	_calc_simplex_volume:PROC
EXTRN	_calc_facet_volume:DWORD
EXTRN	_init_view:PROC
EXTRN	_sparse_ibase_flag:DWORD
EXTRN	_match_id_flag:DWORD
EXTRN	_load_library:PROC
EXTRN	_datafilename:BYTE
EXTRN	_evolver_version:DWORD
EXTRN	_kb_lower_array:BYTE
EXTRN	_mpi_local_bodies_flag:DWORD
EXTRN	_warnings_suppressed:BYTE
EXTRN	_autochop_length:QWORD
EXTRN	_area_fixed_target:QWORD
EXTRN	_read_method_instance:PROC
EXTRN	_read_quantity:PROC
EXTRN	_read_constraint:PROC
EXTRN	_read_boundary:PROC
EXTRN	_command:PROC
EXTRN	_datafile_flag:DWORD
EXTRN	_function_kludge_flag:DWORD
EXTRN	_read_transforms:PROC
EXTRN	_view:DWORD
EXTRN	_linear_to_lagrange:PROC
EXTRN	_quad_to_lagrange:PROC
EXTRN	_lagrange_to_lagrange:PROC
EXTRN	_linear_to_quad:PROC
EXTRN	_exparse:PROC
EXTRN	_define_array:PROC
EXTRN	_topflag:DWORD
EXTRN	_graph_timestamp:DWORD
EXTRN	_reset_timestamp:DWORD
EXTRN	_quantity_init:PROC
EXTRN	_lists_flag:DWORD
EXTRN	_verb_flag:DWORD
EXTRN	_bare_edge_count:DWORD
EXTRN	_recovery_flag:DWORD
EXTRN	_parse_errors:DWORD
EXTRN	_parse_error_flag:DWORD
EXTRN	_line_no:DWORD
EXTRN	_macro_init:PROC
EXTRN	_yylex_init:PROC
;	COMDAT ??_C@_0DE@NJENFFAA@Cannot?5do?5homothety?5without?5bodi@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DE@NJENFFAA@Cannot?5do?5homothety?5without?5bodi@ DB 'Cannot do ho'
	DB	'mothety without bodies. Homothety OFF.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OAFHPFJG@Number?5of?5vertices?5popped?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BP@OAFHPFJG@Number?5of?5vertices?5popped?3?5?$CFd?6?$AA@ DB 'Numbe'
	DB	'r of vertices popped: %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BCFEOGPP@No?5edges?5found?5in?5datafile?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@BCFEOGPP@No?5edges?5found?5in?5datafile?4?6?$AA@ DB 'No edges f'
	DB	'ound in datafile.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OOHLDEKN@No?5vertices?5found?5in?5datafile?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@OOHLDEKN@No?5vertices?5found?5in?5datafile?4?6?$AA@ DB 'No vert'
	DB	'ices found in datafile.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MPAJEHHD@Bad?5data?5file?4?6?$AA@
CONST	SEGMENT
??_C@_0BA@MPAJEHHD@Bad?5data?5file?4?6?$AA@ DB 'Bad data file.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJDLPEM@length?$AA@
CONST	SEGMENT
??_C@_06IJDLPEM@length?$AA@ DB 'length', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@FNDBGOJC@Converting?5to?5named?5quantities?5f@
CONST	SEGMENT
??_C@_0DI@FNDBGOJC@Converting?5to?5named?5quantities?5f@ DB 'Converting t'
	DB	'o named quantities for boundary integrals.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NGDIDIBI@Converting?5to?5named?5quantities?5f@
CONST	SEGMENT
??_C@_0DE@NGDIDIBI@Converting?5to?5named?5quantities?5f@ DB 'Converting t'
	DB	'o named quantities for Lagrange model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CPMJENCO@Faces?5list?5must?5precede?5body?5lis@
CONST	SEGMENT
??_C@_0CE@CPMJENCO@Faces?5list?5must?5precede?5body?5lis@ DB 'Faces list '
	DB	'must precede body list.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JFDKOOIO@Vertices?5list?5must?5be?5first?5elem@
CONST	SEGMENT
??_C@_0CL@JFDKOOIO@Vertices?5list?5must?5be?5first?5elem@ DB 'Vertices li'
	DB	'st must be first element list.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@HCFNNEMF@Must?5have?5simplex?5representation@
CONST	SEGMENT
??_C@_0EA@HCFNNEMF@Must?5have?5simplex?5representation@ DB 'Must have sim'
	DB	'plex representation for surface dimension over 2.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JHNGAGBL@Edges?5list?5must?5be?5second?5elemen@
CONST	SEGMENT
??_C@_0CJ@JHNGAGBL@Edges?5list?5must?5be?5second?5elemen@ DB 'Edges list '
	DB	'must be second element list.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@LFINBAOG@Bad?5content?5component?5?$CFd?5definit@
CONST	SEGMENT
??_C@_0EI@LFINBAOG@Bad?5content?5component?5?$CFd?5definit@ DB 'Bad conte'
	DB	'nt component %d definition for hessian_special_normal_vector.'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JFDCKONH@Illegal?5token?5?8?$CFs?8?4?6?$AA@
CONST	SEGMENT
??_C@_0BF@JFDCKONH@Illegal?5token?5?8?$CFs?8?4?6?$AA@ DB 'Illegal token '''
	DB	'%s''.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DBLPODHF@Missing?5TEMPERATURE?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@DBLPODHF@Missing?5TEMPERATURE?5value?4?6?$AA@ DB 'Missing TEMPE'
	DB	'RATURE value.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FELGNELD@Missing?5GAP_CONSTANT?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@FELGNELD@Missing?5GAP_CONSTANT?5value?4?6?$AA@ DB 'Missing GAP_'
	DB	'CONSTANT value.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@ELBPBAMK@Missing?5GRAVITY_CONSTANT?5value?4?6@
CONST	SEGMENT
??_C@_0CB@ELBPBAMK@Missing?5GRAVITY_CONSTANT?5value?4?6@ DB 'Missing GRAV'
	DB	'ITY_CONSTANT value.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NGGEHPKJ@Missing?5MERIT?5FACTOR?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@NGGEHPKJ@Missing?5MERIT?5FACTOR?5value?4?6?$AA@ DB 'Missing MER'
	DB	'IT FACTOR value.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DLJCKBBD@Tolerance?5must?5be?5positive?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@DLJCKBBD@Tolerance?5must?5be?5positive?4?6?$AA@ DB 'Tolerance m'
	DB	'ust be positive.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NPCHGACN@Missing?5CONSTRAINT_TOLERANCE?5val@
CONST	SEGMENT
??_C@_0CF@NPCHGACN@Missing?5CONSTRAINT_TOLERANCE?5val@ DB 'Missing CONSTR'
	DB	'AINT_TOLERANCE value.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PPLFNOLF@Missing?5ZOOM?5VERTEX?5number?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@PPLFNOLF@Missing?5ZOOM?5VERTEX?5number?4?6?$AA@ DB 'Missing ZOO'
	DB	'M VERTEX number.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KIOPFAJA@Missing?5ZOOM?5RADIUS?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@KIOPFAJA@Missing?5ZOOM?5RADIUS?5value?4?6?$AA@ DB 'Missing ZOOM'
	DB	' RADIUS value.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BNFBILLP@Missing?5TOTAL_TIME?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@BNFBILLP@Missing?5TOTAL_TIME?5value?4?6?$AA@ DB 'Missing TOTAL_'
	DB	'TIME value.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CEOHDAHL@Missing?5SCALE_LIMIT?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@CEOHDAHL@Missing?5SCALE_LIMIT?5value?4?6?$AA@ DB 'Missing SCALE'
	DB	'_LIMIT value.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IDOBCKPD@mobility?5tensor?5component?5?$FL?$CFd?$FN?$FL?$CF@
CONST	SEGMENT
??_C@_0CD@IDOBCKPD@mobility?5tensor?5component?5?$FL?$CFd?$FN?$FL?$CF@ DB 'm'
	DB	'obility tensor component [%d][%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EAPHMDEP@Bad?5mobility_tensor?$FL?$CFd?$FN?$FL?$CFd?$FN?5defi@
CONST	SEGMENT
??_C@_0CJ@EAPHMDEP@Bad?5mobility_tensor?$FL?$CFd?$FN?$FL?$CFd?$FN?5defi@ DB 'B'
	DB	'ad mobility_tensor[%d][%d] definition.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IDOKOAMM@Bad?5mobility?5definition?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@IDOKOAMM@Bad?5mobility?5definition?4?6?$AA@ DB 'Bad mobility de'
	DB	'finition.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OCMPBOEO@mobility?5formula?$AA@
CONST	SEGMENT
??_C@_0BB@OCMPBOEO@mobility?5formula?$AA@ DB 'mobility formula', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EADLCLOO@Missing?5square?5curvature?5modulus@
CONST	SEGMENT
??_C@_0CJ@EADLCLOO@Missing?5square?5curvature?5modulus@ DB 'Missing squar'
	DB	'e curvature modulus value.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ODONALIB@sq_curvature_modulus?$AA@
CONST	SEGMENT
??_C@_0BF@ODONALIB@sq_curvature_modulus?$AA@ DB 'sq_curvature_modulus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EKACIEOJ@Can?5do?5square?5gauss?5curvature?5on@
CONST	SEGMENT
??_C@_0DH@EKACIEOJ@Can?5do?5square?5gauss?5curvature?5on@ DB 'Can do squa'
	DB	're gauss curvature only in SOAPFILM model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NKIKIKPL@Missing?5square?5gaussian?5modulus?5@
CONST	SEGMENT
??_C@_0CI@NKIKIKPL@Missing?5square?5gaussian?5modulus?5@ DB 'Missing squa'
	DB	're gaussian modulus value.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MCIHOOCD@square_gauss_modulus?$AA@
CONST	SEGMENT
??_C@_0BF@MCIHOOCD@square_gauss_modulus?$AA@ DB 'square_gauss_modulus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PHNDOFLD@gauss_curvature_integral?$AA@
CONST	SEGMENT
??_C@_0BJ@PHNDOFLD@gauss_curvature_integral?$AA@ DB 'gauss_curvature_inte'
	DB	'gral', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FONHHPKP@Can?5do?5gauss?5curvature?5only?5in?5S@
CONST	SEGMENT
??_C@_0DA@FONHHPKP@Can?5do?5gauss?5curvature?5only?5in?5S@ DB 'Can do gau'
	DB	'ss curvature only in SOAPFILM model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@CJGMDKOF@Can?5do?5integral?5of?5mean?5curvatur@
CONST	SEGMENT
??_C@_0DL@CJGMDKOF@Can?5do?5integral?5of?5mean?5curvatur@ DB 'Can do inte'
	DB	'gral of mean curvature only in SOAPFILM model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@LKAHFFEK@Missing?5integral?5mean?5curvature?5@
CONST	SEGMENT
??_C@_0FI@LKAHFFEK@Missing?5integral?5mean?5curvature?5@ DB 'Missing inte'
	DB	'gral mean curvature modulus value.', 0aH, 'Syntax: mean_curva'
	DB	'ture_integral: modulus', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HGNBHJNG@mean_curvature_modulus?$AA@
CONST	SEGMENT
??_C@_0BH@HGNBHJNG@mean_curvature_modulus?$AA@ DB 'mean_curvature_modulus'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LOBABENM@uniform_knot_energy?$AA@
CONST	SEGMENT
??_C@_0BE@LOBABENM@uniform_knot_energy?$AA@ DB 'uniform_knot_energy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BGBMOCLO@knot_energy?$AA@
CONST	SEGMENT
??_C@_0M@BGBMOCLO@knot_energy?$AA@ DB 'knot_energy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FBNOILCH@clip_coeff?5initializer?5missing?5?8@
CONST	SEGMENT
??_C@_0CF@FBNOILCH@clip_coeff?5initializer?5missing?5?8@ DB 'clip_coeff i'
	DB	'nitializer missing ''=''.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MIIDBODK@Not?5enough?5values?5for?5display_or@
CONST	SEGMENT
??_C@_0CH@MIIDBODK@Not?5enough?5values?5for?5display_or@ DB 'Not enough v'
	DB	'alues for display_origin.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OAMDDONM@display_origin?$AA@
CONST	SEGMENT
??_C@_0P@OAMDDONM@display_origin?$AA@ DB 'display_origin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DMLCKLLD@Cannot?5find?5phasefile?5name?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@DMLCKLLD@Cannot?5find?5phasefile?5name?4?6?$AA@ DB 'Cannot find'
	DB	' phasefile name.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DNEHBIJK@Wulff?5file?5name?5missing?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@DNEHBIJK@Wulff?5file?5name?5missing?4?6?$AA@ DB 'Wulff file nam'
	DB	'e missing.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@JHOGNIBN@addload?5datafile?5has?5different?5L@
CONST	SEGMENT
??_C@_0EB@JHOGNIBN@addload?5datafile?5has?5different?5L@ DB 'addload data'
	DB	'file has different Lagrange order %d, should be %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BAGDPBEE@addload?5datafile?5not?5in?5Lagrange@
CONST	SEGMENT
??_C@_0CI@BAGDPBEE@addload?5datafile?5not?5in?5Lagrange@ DB 'addload data'
	DB	'file not in Lagrange mode.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MMMIPAME@Lagrange?5order?5missing?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@MMMIPAME@Lagrange?5order?5missing?4?6?$AA@ DB 'Lagrange order m'
	DB	'issing.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DILGNDHE@Missing?5symmetry?5group?5name?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@DILGNDHE@Missing?5symmetry?5group?5name?4?6?$AA@ DB 'Missing sy'
	DB	'mmetry group name.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FCPCBJIO@torus?$AA@
CONST	SEGMENT
??_C@_05FCPCBJIO@torus?$AA@ DB 'torus', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IJOKADDI@Symmetry?5name?5?8?$CFs?8?5not?5found?5in?5@
CONST	SEGMENT
??_C@_0CN@IJOKADDI@Symmetry?5name?5?8?$CFs?8?5not?5found?5in?5@ DB 'Symme'
	DB	'try name ''%s'' not found in registry.c ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OOHCNGCP@metric?5component?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BK@OOHCNGCP@metric?5component?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$AA@ DB 'm'
	DB	'etric component [%d][%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@EDNHONDD@Bad?5metric?5g?$FL?$CFd?$FN?$FL?$CFd?$FN?5definition?4@
CONST	SEGMENT
??_C@_0CC@EDNHONDD@Bad?5metric?5g?$FL?$CFd?$FN?$FL?$CFd?$FN?5definition?4@ DB 'B'
	DB	'ad metric g[%d][%d] definition.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LMKJAPE@conformal?5metric?$AA@
CONST	SEGMENT
??_C@_0BB@LMKJAPE@conformal?5metric?$AA@ DB 'conformal metric', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GHIPFDMN@Bad?5conformal?5metric?5definition?4@
CONST	SEGMENT
??_C@_0CC@GHIPFDMN@Bad?5conformal?5metric?5definition?4@ DB 'Bad conforma'
	DB	'l metric definition.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FILMHLNM@Surface?5dimension?5higher?5than?5sp@
CONST	SEGMENT
??_C@_0DA@FILMHLNM@Surface?5dimension?5higher?5than?5sp@ DB 'Surface dime'
	DB	'nsion higher than space dimension.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GAKBJBHJ@Dimension?5of?5surface?5missing?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@GAKBJBHJ@Dimension?5of?5surface?5missing?4?6?$AA@ DB 'Dimension'
	DB	' of surface missing.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@IGMMIJNI@Space?5dimension?5too?5high?4?5?5Recom@
CONST	SEGMENT
??_C@_0EN@IGMMIJNI@Space?5dimension?5too?5high?4?5?5Recom@ DB 'Space dime'
	DB	'nsion too high.  Recompile with -DMAXCOORD=%d as compiler opt'
	DB	'ion.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LPEBGEG@Dimension?5of?5space?5missing?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@LPEBGEG@Dimension?5of?5space?5missing?4?6?$AA@ DB 'Dimension of'
	DB	' space missing.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KPGCCCNG@LOAD_LIBRARY?5file?5name?5missing?4?6@
CONST	SEGMENT
??_C@_0CB@KPGCCCNG@LOAD_LIBRARY?5file?5name?5missing?4?6@ DB 'LOAD_LIBRAR'
	DB	'Y file name missing.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@KBCGPNLA@?6Datafile?5?$CFs?5needs?5Evolver?5versi@
CONST	SEGMENT
??_C@_0EH@KBCGPNLA@?6Datafile?5?$CFs?5needs?5Evolver?5versi@ DB 0aH, 'Dat'
	DB	'afile %s needs Evolver version at least %s.  This is version '
	DB	'%s.', 0aH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EPFCLKFB@area_method_name?5needs?5quoted?5st@
CONST	SEGMENT
??_C@_0CH@EPFCLKFB@area_method_name?5needs?5quoted?5st@ DB 'area_method_n'
	DB	'ame needs quoted string.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PIDJOHNH@length_method_name?5needs?5quoted?5@
CONST	SEGMENT
??_C@_0CJ@PIDJOHNH@length_method_name?5needs?5quoted?5@ DB 'length_method'
	DB	'_name needs quoted string.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GPHNFCAP@spherical_arc_length?$AA@
CONST	SEGMENT
??_C@_0BF@GPHNFCAP@spherical_arc_length?$AA@ DB 'spherical_arc_length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OOOEBCHL@circular_arc_length?$AA@
CONST	SEGMENT
??_C@_0BE@OOOEBCHL@circular_arc_length?$AA@ DB 'circular_arc_length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EPOONLLG@hessian_special_normal?5component@
CONST	SEGMENT
??_C@_0CE@EPOONLLG@hessian_special_normal?5component@ DB 'hessian_special'
	DB	'_normal component %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@ILDABPKE@Method_instances_predicted?5must?5@
CONST	SEGMENT
??_C@_0DB@ILDABPKE@Method_instances_predicted?5must?5@ DB 'Method_instanc'
	DB	'es_predicted must be nonnegative.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BCDJPNPP@Missing?5method_instances_predict@
CONST	SEGMENT
??_C@_0CM@BCDJPNPP@Missing?5method_instances_predict@ DB 'Missing method_'
	DB	'instances_predicted number.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@ILLLMBPC@Quantities_predicted?5must?5be?5non@
CONST	SEGMENT
??_C@_0CL@ILLLMBPC@Quantities_predicted?5must?5be?5non@ DB 'Quantities_pr'
	DB	'edicted must be nonnegative.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HOIDIOKP@Missing?5quantities_predicted?5num@
CONST	SEGMENT
??_C@_0CG@HOIDIOKP@Missing?5quantities_predicted?5num@ DB 'Missing quanti'
	DB	'ties_predicted number.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LJPHAGLH@Facetedges_predicted?5must?5be?5non@
CONST	SEGMENT
??_C@_0CL@LJPHAGLH@Facetedges_predicted?5must?5be?5non@ DB 'Facetedges_pr'
	DB	'edicted must be nonnegative.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FNDIGCBP@Missing?5facetedges_predicted?5num@
CONST	SEGMENT
??_C@_0CG@FNDIGCBP@Missing?5facetedges_predicted?5num@ DB 'Missing facete'
	DB	'dges_predicted number.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KOAIAFMM@Bodies_predicted?5must?5be?5nonnega@
CONST	SEGMENT
??_C@_0CH@KOAIAFMM@Bodies_predicted?5must?5be?5nonnega@ DB 'Bodies_predic'
	DB	'ted must be nonnegative.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PMAPEPHJ@Missing?5bodies_predicted?5number?4@
CONST	SEGMENT
??_C@_0CC@PMAPEPHJ@Missing?5bodies_predicted?5number?4@ DB 'Missing bodie'
	DB	's_predicted number.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KFHJFP@Faces_predicted?5must?5be?5nonnegat@
CONST	SEGMENT
??_C@_0CG@KFHJFP@Faces_predicted?5must?5be?5nonnegat@ DB 'Faces_predicted'
	DB	' must be nonnegative.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BOGJNNPF@Missing?5facets_predicted?5number?4@
CONST	SEGMENT
??_C@_0CC@BOGJNNPF@Missing?5facets_predicted?5number?4@ DB 'Missing facet'
	DB	's_predicted number.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JLLOGAAP@Edges_predicted?5must?5be?5nonnegat@
CONST	SEGMENT
??_C@_0CG@JLLOGAAP@Edges_predicted?5must?5be?5nonnegat@ DB 'Edges_predict'
	DB	'ed must be nonnegative.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FDEIENDO@Missing?5edges_predicted?5number?4?6@
CONST	SEGMENT
??_C@_0CB@FDEIENDO@Missing?5edges_predicted?5number?4?6@ DB 'Missing edge'
	DB	's_predicted number.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DHAABPBI@Vertices_predicted?5must?5be?5nonne@
CONST	SEGMENT
??_C@_0CJ@DHAABPBI@Vertices_predicted?5must?5be?5nonne@ DB 'Vertices_pred'
	DB	'icted must be nonnegative.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MMMILBBM@Missing?5vertices_predicted?5numbe@
CONST	SEGMENT
??_C@_0CE@MMMILBBM@Missing?5vertices_predicted?5numbe@ DB 'Missing vertic'
	DB	'es_predicted number.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HAEPAFLK@volume_method_name?5needs?5quoted?5@
CONST	SEGMENT
??_C@_0CJ@HAEPAFLK@volume_method_name?5needs?5quoted?5@ DB 'volume_method'
	DB	'_name needs quoted string.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CGCPNNKG@Invalid?5INTEGRAL_ORDER_2D?5value?5@
CONST	SEGMENT
??_C@_0CF@CGCPNNKG@Invalid?5INTEGRAL_ORDER_2D?5value?5@ DB 'Invalid INTEG'
	DB	'RAL_ORDER_2D value %d.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PMAPNCHP@Missing?5INTEGRAL_ORDER_2D?5value?4@
CONST	SEGMENT
??_C@_0CC@PMAPNCHP@Missing?5INTEGRAL_ORDER_2D?5value?4@ DB 'Missing INTEG'
	DB	'RAL_ORDER_2D value.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OMGLPLHB@Missing?5unsuppressed?5warning?5num@
CONST	SEGMENT
??_C@_0CG@OMGLPLHB@Missing?5unsuppressed?5warning?5num@ DB 'Missing unsup'
	DB	'pressed warning number.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IDAJELNI@Invalid?5INTEGRAL_ORDER?5value?5?$CFd?4@
CONST	SEGMENT
??_C@_0CC@IDAJELNI@Invalid?5INTEGRAL_ORDER?5value?5?$CFd?4@ DB 'Invalid I'
	DB	'NTEGRAL_ORDER value %d.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GEPDLMPC@Missing?5INTEGRAL_ORDER?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@GEPDLMPC@Missing?5INTEGRAL_ORDER?5value?4?6?$AA@ DB 'Missing IN'
	DB	'TEGRAL_ORDER value.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FKEOPIHN@Invalid?5INTEGRAL_ORDER_1D?5value?5@
CONST	SEGMENT
??_C@_0CF@FKEOPIHN@Invalid?5INTEGRAL_ORDER_1D?5value?5@ DB 'Invalid INTEG'
	DB	'RAL_ORDER_1D value %d.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GFONLEHO@Missing?5INTEGRAL_ORDER_1D?5value?4@
CONST	SEGMENT
??_C@_0CC@GFONLEHO@Missing?5INTEGRAL_ORDER_1D?5value?4@ DB 'Missing INTEG'
	DB	'RAL_ORDER_1D value.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EAFIIJC@Too?5many?5warnings?5suppressed?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@EAFIIJC@Too?5many?5warnings?5suppressed?4?6?$AA@ DB 'Too many w'
	DB	'arnings suppressed.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PBGBCJEK@Missing?5suppressed?5warning?5numbe@
CONST	SEGMENT
??_C@_0CE@PBGBCJEK@Missing?5suppressed?5warning?5numbe@ DB 'Missing suppr'
	DB	'essed warning number.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HHDBINKH@Missing?5SCALE?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BG@HHDBINKH@Missing?5SCALE?5value?4?6?$AA@ DB 'Missing SCALE value'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KFFCGAOL@Missing?5AUTOCHOP?5length?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@KFFCGAOL@Missing?5AUTOCHOP?5length?4?6?$AA@ DB 'Missing AUTOCHO'
	DB	'P length.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JNKAIEKD@Missing?5DIFFUSION?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@JNKAIEKD@Missing?5DIFFUSION?5value?4?6?$AA@ DB 'Missing DIFFUSI'
	DB	'ON value.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IJBPFNBA@Missing?5fixed?5area?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@IJBPFNBA@Missing?5fixed?5area?5value?4?6?$AA@ DB 'Missing fixed'
	DB	' area value.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FLLLMGHG@Area_fixed?5is?5obsolete?4?5?5Replace@
CONST	SEGMENT
??_C@_0DH@FLLLMGHG@Area_fixed?5is?5obsolete?4?5?5Replace@ DB 'Area_fixed '
	DB	'is obsolete.  Replace with named quantity.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DGNKKEGC@procedure?5_anti_line_no_?$AA@
CONST	SEGMENT
??_C@_0BJ@DGNKKEGC@procedure?5_anti_line_no_?$AA@ DB 'procedure _anti_lin'
	DB	'e_no_', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KKMILGMA@function?5_anti_line_no_?$AA@
CONST	SEGMENT
??_C@_0BI@KKMILGMA@function?5_anti_line_no_?$AA@ DB 'function _anti_line_'
	DB	'no_', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BPKPNIKE@Not?5enough?5values?5for?5view?5matri@
CONST	SEGMENT
??_C@_0CE@BPKPNIKE@Not?5enough?5values?5for?5view?5matri@ DB 'Not enough '
	DB	'values for view matrix.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JOABNBND@addload?5datafile?5not?5in?5quadrati@
CONST	SEGMENT
??_C@_0CJ@JOABNBND@addload?5datafile?5not?5in?5quadrati@ DB 'addload data'
	DB	'file not in quadratic mode.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OFJHKPPL@addload?5datafile?5not?5in?5linear?5m@
CONST	SEGMENT
??_C@_0CG@OFJHKPPL@addload?5datafile?5not?5in?5linear?5m@ DB 'addload dat'
	DB	'afile not in linear mode.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@OCCCFIHM@Bad?5function?5definition?5for?5attr@
CONST	SEGMENT
??_C@_0CL@OCCCFIHM@Bad?5function?5definition?5for?5attr@ DB 'Bad function'
	DB	' definition for attribute %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MCCLBIBM@attribute?5?8?$CFs?8?5formula?$AA@
CONST	SEGMENT
??_C@_0BH@MCCLBIBM@attribute?5?8?$CFs?8?5formula?$AA@ DB 'attribute ''%s'''
	DB	' formula', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MFGCEIAK@Attribute?5dimension?5must?5be?5at?5l@
CONST	SEGMENT
??_C@_0CJ@MFGCEIAK@Attribute?5dimension?5must?5be?5at?5l@ DB 'Attribute d'
	DB	'imension must be at least 0.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HJEBGFAN@Need?5dimension?5number?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@HJEBGFAN@Need?5dimension?5number?4?6?$AA@ DB 'Need dimension nu'
	DB	'mber.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@NKHGBANH@Extra?5attribute?5?$CFs?5has?5more?5dime@
CONST	SEGMENT
??_C@_0DN@NKHGBANH@Extra?5attribute?5?$CFs?5has?5more?5dime@ DB 'Extra at'
	DB	'tribute %s has more dimensions than the allowed %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DDHFONOJ@Need?5attribute?5datatype?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@DDHFONOJ@Need?5attribute?5datatype?4?6?$AA@ DB 'Need attribute '
	DB	'datatype.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BGBAKMFH@Need?5new?5identifier?4?5?6?$AA@
CONST	SEGMENT
??_C@_0BH@BGBAKMFH@Need?5new?5identifier?4?5?6?$AA@ DB 'Need new identifi'
	DB	'er. ', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FPBINCDC@Need?5ATTRIBUTE?5keyword?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@FPBINCDC@Need?5ATTRIBUTE?5keyword?4?6?$AA@ DB 'Need ATTRIBUTE k'
	DB	'eyword.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BJFMIBDG@Bad?5element?5type?5in?5?8define?8?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@BJFMIBDG@Bad?5element?5type?5in?5?8define?8?4?6?$AA@ DB 'Bad el'
	DB	'ement type in ''define''.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\lexinit.c
CONST	ENDS
;	COMDAT _initialize
_TEXT	SEGMENT
_val$89681 = -120					; size = 8
_modulus$ = -112					; size = 8
tv3974 = -104						; size = 4
tv3917 = -104						; size = 4
_k$ = -104						; size = 4
_attr_type$89648 = -104					; size = 4
_sizes$89650 = -100					; size = 32
_name$89651 = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_initialize PROC					; COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 458  :   int f;
; 459  :   facetedge_id fe;
; 460  :   int i,j,k;
; 461  :   int dataflag;
; 462  :   int esize;
; 463  :   REAL modulus;
; 464  : 
; 465  :   yylex_init();  /* reset lex */

	call	_yylex_init

; 466  :   macro_init();  /* reset macros in parser */

	call	_macro_init

; 467  :   line_no = 1;
; 468  :   parse_error_flag = 0;

	xor	esi, esi
	mov	edi, 1
	mov	DWORD PTR _line_no, edi
	mov	DWORD PTR _parse_error_flag, esi

; 469  :   parse_errors = 0;

	mov	DWORD PTR _parse_errors, esi

; 470  :   recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 471  :   facecount = 0;

	mov	DWORD PTR _facecount, esi

; 472  :   bare_edge_count = 0;

	mov	DWORD PTR _bare_edge_count, esi

; 473  :   verb_flag = 0;

	mov	DWORD PTR _verb_flag, esi

; 474  :   lists_flag = LISTS_OFF;

	mov	DWORD PTR _lists_flag, esi

; 475  :   vlist = NULL;

	mov	DWORD PTR _vlist, esi

; 476  :   elist = NULL;

	mov	DWORD PTR _elist, esi

; 477  :   flist = NULL;

	mov	DWORD PTR _flist, esi

; 478  :   blist = NULL;

	mov	DWORD PTR _blist, esi

; 479  : 
; 480  :   if ( !addload_flag )

	cmp	DWORD PTR _addload_flag, esi
	jne	SHORT $LN415@initialize

; 481  :     quantity_init(); 

	call	_quantity_init
$LN415@initialize:

; 482  : 
; 483  :   reset_timestamp = top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	eax, edi
	mov	DWORD PTR _top_timestamp, eax
	mov	DWORD PTR _reset_timestamp, eax

; 484  :   graph_timestamp = ++global_timestamp;

	add	eax, edi

; 485  :   /* read in any header information */
; 486  :   topflag = 1;
; 487  :   tok = yylex();

	push	esi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _graph_timestamp, eax
	mov	DWORD PTR _topflag, edi
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 488  :   while ( (tok != 0) && topflag )

	cmp	eax, esi
	je	$LN413@initialize
$LL414@initialize:
	cmp	DWORD PTR _topflag, 0
	je	$LN413@initialize

; 489  :   { switch ( tok )

	mov	eax, DWORD PTR _tok
	cmp	eax, 561				; 00000231H
	jg	$LN462@initialize
	je	$LN381@initialize
	sub	eax, 262				; 00000106H
	cmp	eax, 238				; 000000eeH
	ja	$LN90@initialize
	movzx	eax, BYTE PTR $LN532@initialize[eax]
	jmp	DWORD PTR $LN600@initialize[eax*4]
$LN325@initialize:

; 756  : 
; 757  :         case DEFINE_TOK:  /* extra attribute definition */
; 758  :            { int dim,e_type=0,attr_type=0,anum;

	xor	ebx, ebx

; 759  :              int sizes[MAXARRAYDIMS];
; 760  :              char name[ATTR_NAME_SIZE+1];
; 761  :              tok = yylex();

	push	ebx
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 762  :              switch ( tok )

	cmp	eax, 296				; 00000128H
	jg	SHORT $LN419@initialize
	je	SHORT $LN317@initialize
	sub	eax, 268				; 0000010cH
	je	SHORT $LN322@initialize
	sub	eax, 25					; 00000019H
	je	SHORT $LN320@initialize
	dec	eax
	jne	SHORT $LN315@initialize

; 766  :                case EDGES_TOK:     e_type = EDGE; break;

	lea	ebx, DWORD PTR [eax+1]
	jmp	SHORT $LN323@initialize
$LN320@initialize:

; 764  :                case ARRAYIDENT_TOK : define_array(); goto define_exit;
; 765  :                case VERTICES_TOK: e_type = VERTEX; break;

	xor	ebx, ebx
	jmp	SHORT $LN323@initialize
$LN322@initialize:

; 763  :              { case NEWIDENT_TOK : define_array(); goto define_exit;

	call	_define_array
	jmp	$LN548@initialize
$LN317@initialize:

; 768  :                case BODIES_TOK:    e_type = BODY;  break;

	mov	ebx, 3
	jmp	SHORT $LN323@initialize
$LN419@initialize:

; 762  :              switch ( tok )

	sub	eax, 307				; 00000133H
	je	SHORT $LN316@initialize
	sub	eax, 125				; 0000007dH
	je	SHORT $LN322@initialize
	sub	eax, 34654				; 0000875eH
	je	SHORT $LN318@initialize
$LN315@initialize:

; 770  :                default: kb_error(1065,"Bad element type in 'define'.\n",
; 771  :                   DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@BJFMIBDG@Bad?5element?5type?5in?5?8define?8?4?6?$AA@
	push	1065					; 00000429H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN323@initialize
$LN318@initialize:

; 767  :                case FACES_TOK:     e_type = FACET; break;

	mov	ebx, 2
	jmp	SHORT $LN323@initialize
$LN316@initialize:

; 769  :                case FACETEDGES_TOK: e_type = FACETEDGE; break;

	mov	ebx, 4
$LN323@initialize:

; 772  :              };
; 773  :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 774  :              if ( tok != ATTRIBUTE_TOK )

	cmp	eax, 363				; 0000016bH
	je	SHORT $LN572@initialize

; 775  :                 kb_error(1066,"Need ATTRIBUTE keyword.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BJ@FPBINCDC@Need?5ATTRIBUTE?5keyword?4?6?$AA@
	push	1066					; 0000042aH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN572@initialize:

; 776  : 
; 777  :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 778  :              if ( (tok != NEWIDENT_TOK) && !addload_flag )

	cmp	eax, 268				; 0000010cH
	je	SHORT $LN576@initialize
	cmp	DWORD PTR _addload_flag, 0
	jne	SHORT $LN576@initialize

; 779  :                 kb_error(1067,"Need new identifier. \n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BH@BGBAKMFH@Need?5new?5identifier?4?5?6?$AA@
	push	1067					; 0000042bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN576@initialize:

; 780  : 
; 781  :              strncpy(name,yytext,ATTR_NAME_SIZE);

	mov	ecx, DWORD PTR _yytext
	push	63					; 0000003fH
	push	ecx
	lea	edx, DWORD PTR _name$89651[ebp]
	push	edx
	call	_strncpy

; 782  :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tok, eax

; 783  :              if ( tok == DATATYPE_TOK )

	cmp	eax, 358				; 00000166H
	jne	SHORT $LN312@initialize

; 784  :              { attr_type = yylval.datatype;

	mov	eax, DWORD PTR _yylval+28
	mov	DWORD PTR _attr_type$89648[ebp], eax

; 785  :              }
; 786  :              else

	jmp	SHORT $LN311@initialize
$LN312@initialize:

; 787  :              { kb_error(1068,"Need attribute datatype.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BK@DDHFONOJ@Need?5attribute?5datatype?4?6?$AA@
	push	1068					; 0000042cH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 788  :                attr_type = REAL_TYPE; /* reasonable default */

	mov	DWORD PTR _attr_type$89648[ebp], 1
$LN311@initialize:

; 789  :              }
; 790  :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4

; 791  :              dim = 0; sizes[0] = 1;

	xor	edi, edi
	mov	DWORD PTR _tok, eax
	mov	DWORD PTR _sizes$89650[ebp], 1

; 792  :              while ( tok == '[' )

	cmp	eax, 91					; 0000005bH
	jne	$LN561@initialize

; 789  :              }
; 790  :              tok = yylex();

	lea	esi, DWORD PTR _sizes$89650[ebp]
	sub	esi, 4
	npad	5
$LL310@initialize:

; 793  :              {  REAL val=0.0;

	fldz

; 794  :                 dim += 1;

	inc	edi
	add	esi, 4
	fstp	QWORD PTR _val$89681[ebp]

; 795  :                 if ( dim > MAXARRAYDIMS )

	cmp	edi, 8
	jle	SHORT $LN308@initialize

; 796  :                 { sprintf(errmsg,
; 797  :                 "Extra attribute %s has more dimensions than the allowed %d.\n",
; 798  :                     name,MAXARRAYDIMS);

	push	8
	lea	ecx, DWORD PTR _name$89651[ebp]
	push	ecx
	push	OFFSET ??_C@_0DN@NKHGBANH@Extra?5attribute?5?$CFs?5has?5more?5dime@
	push	OFFSET _errmsg
	call	_sprintf

; 799  :                   kb_error(2566,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2566					; 00000a06H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN308@initialize:

; 800  :                 } 
; 801  :               
; 802  :                 if ( read_const(&val) <= 0 )

	lea	edx, DWORD PTR _val$89681[ebp]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN307@initialize

; 803  :                 {
; 804  :                   kb_error(1069,"Need dimension number.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BI@HJEBGFAN@Need?5dimension?5number?4?6?$AA@
	push	1069					; 0000042dH
	call	_kb_error

; 805  :                   sizes[dim-1] = 1;

	mov	DWORD PTR [esi], 1

; 806  :                 }
; 807  :                 else 

	jmp	SHORT $LN583@initialize
$LN307@initialize:

; 808  :                   sizes[dim-1] = (int)val;

	fld	QWORD PTR _val$89681[ebp]
	call	__ftol2_sse
	mov	DWORD PTR [esi], eax

; 809  :                 if ( sizes[dim-1] < 0 )

	test	eax, eax
	jns	SHORT $LN305@initialize

; 810  :                   kb_error(1070,"Attribute dimension must be at least 0.\n",
; 811  :                      DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CJ@MFGCEIAK@Attribute?5dimension?5must?5be?5at?5l@
	push	1070					; 0000042eH
	call	_kb_error
$LN583@initialize:
	add	esp, 12					; 0000000cH
$LN305@initialize:

; 812  :                 tok = yylex();  

	push	0
	call	_kb_yylex

; 813  :                 tok = yylex(); /* eat ] */

	push	0
	mov	DWORD PTR _tok, eax
	call	_kb_yylex
	add	esp, 8
	mov	DWORD PTR _tok, eax
	cmp	eax, 91					; 0000005bH
	je	$LL310@initialize
$LN561@initialize:

; 814  :              }
; 815  :              anum = add_attribute(e_type,name,attr_type,dim,sizes,DUMP_ATTR,NULL,MPI_NO_PROPAGATE);

	mov	ecx, DWORD PTR _attr_type$89648[ebp]
	push	0
	push	0
	push	1
	lea	eax, DWORD PTR _sizes$89650[ebp]
	push	eax
	push	edi
	push	ecx
	lea	edx, DWORD PTR _name$89651[ebp]
	push	edx
	push	ebx
	call	_add_attribute
	add	esp, 32					; 00000020H

; 816  :              if ( (tok == FUNCTION_TOK) && (dim == 0) )

	cmp	DWORD PTR _tok, 428			; 000001acH
	jne	$LN548@initialize
	test	edi, edi
	jne	$LL414@initialize

; 817  :              { /* have calculable attribute */
; 818  :                struct extra *ext = EXTRAS(e_type) + anum;
; 819  :                esize = exparse(SDIM,&(ext->code),USERCOPY);

	mov	ecx, DWORD PTR _web+616
	imul	ebx, 112				; 00000070H
	imul	eax, 240				; 000000f0H
	mov	esi, DWORD PTR _web[ebx+104]
	add	esi, eax
	add	esi, DWORD PTR _dymem
	push	1
	lea	eax, DWORD PTR [esi+128]
	push	eax
	push	ecx
	call	_exparse

; 820  :                sprintf(ext->code.name,"attribute '%s' formula",name);

	lea	edx, DWORD PTR _name$89651[ebp]
	push	edx
	mov	edi, eax
	lea	eax, DWORD PTR [esi+148]
	push	OFFSET ??_C@_0BH@MCCLBIBM@attribute?5?8?$CFs?8?5formula?$AA@
	push	eax
	call	_sprintf

; 821  :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _tok, eax

; 822  :                if ( esize <= 0 )

	test	edi, edi
	jg	SHORT $LN303@initialize

; 823  :                { sprintf(errmsg,
; 824  :                  "Bad function definition for attribute %s.\n",name);

	lea	ecx, DWORD PTR _name$89651[ebp]
	push	ecx
	push	OFFSET ??_C@_0CL@OCCCFIHM@Bad?5function?5definition?5for?5attr@
	push	OFFSET _errmsg
	call	_sprintf

; 825  :                  kb_error(2099,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	2099					; 00000833H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN303@initialize:

; 826  :                }
; 827  :                ext->flags |= FUNCTION_ATTR;

	or	DWORD PTR [esi+232], 2
$define_exit$89658:

; 828  :              }
; 829  :             
; 830  :             } /* end DEFINE */
; 831  : define_exit:
; 832  :             break;

	jmp	$LN548@initialize
$LN280@initialize:

; 935  : 
; 936  :         case STRING_TOK:
; 937  :              web.dimension = 1;
; 938  :              web.representation = STRING;
; 939  :              web.skel[EDGE].dimension = 1;
; 940  :              web.skel[FACET].dimension = 2;
; 941  :              star_fraction = web.dimension + 1.0;

	fld	QWORD PTR __real@4000000000000000
	mov	eax, 1

; 942  :              edgeshow_flag = 0; /* for suppressing dummy facet edges */

	xor	esi, esi
	fstp	QWORD PTR _star_fraction

; 943  :              tok = yylex();

	push	esi
	mov	DWORD PTR _web+620, eax
	mov	DWORD PTR _web+624, eax
	mov	DWORD PTR _web+116, eax
	mov	DWORD PTR _web+228, 2
	mov	DWORD PTR _edgeshow_flag, esi
	call	_kb_yylex

; 944  :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 945  :              break;

	jmp	$LN584@initialize
$LN278@initialize:

; 954  : 
; 955  :         case LINEAR_TOK:
; 956  :              if ( addload_flag )

	cmp	DWORD PTR _addload_flag, 0
	je	SHORT $LN562@initialize

; 957  :              { if ( web.modeltype != LINEAR )

	cmp	DWORD PTR _web+628, 1
	je	SHORT $LN562@initialize

; 958  :                  kb_error(5342,"addload datafile not in linear mode.\n",
; 959  :                       RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CG@OFJHKPPL@addload?5datafile?5not?5in?5linear?5m@
	push	5342					; 000014deH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN562@initialize:

; 960  :              }
; 961  :              web.modeltype = LINEAR;

	mov	DWORD PTR _web+628, 1
$LN272@initialize:

; 962  :              tok = yylex();

	push	0
	call	_kb_yylex

; 963  :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, 0

; 964  :              break;

	jmp	$LN584@initialize
$LN275@initialize:

; 965  :               
; 966  :         case QUADRATIC_TOK:
; 967  :              if ( addload_flag )

	cmp	DWORD PTR _addload_flag, 0
	je	SHORT $LN274@initialize

; 968  :              { if ( web.modeltype != QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	je	SHORT $LN272@initialize

; 969  :                  kb_error(5343,"addload datafile not in quadratic mode.\n",
; 970  :                       RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CJ@JOABNBND@addload?5datafile?5not?5in?5quadrati@
	push	5343					; 000014dfH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 971  :              }
; 972  :              else

	jmp	SHORT $LN272@initialize
$LN274@initialize:

; 973  :                linear_to_quad();

	call	_linear_to_quad

; 974  :              tok = yylex();
; 975  :              recovery_flag = 0;
; 976  :              break;

	jmp	SHORT $LN272@initialize
$LN271@initialize:

; 977  : 
; 978  :         case LAGRANGE_TOK:
; 979  :              switch ( web.modeltype )

	mov	eax, DWORD PTR _web+628
	dec	eax
	je	SHORT $LN268@initialize
	dec	eax
	je	SHORT $LN267@initialize
	dec	eax
	jne	SHORT $LN272@initialize

; 982  :                case LAGRANGE:  lagrange_to_lagrange(1); break;

	push	1
	call	_lagrange_to_lagrange
	add	esp, 4

; 983  :              }
; 984  :              tok = yylex();
; 985  :              recovery_flag = 0;
; 986  :              break;

	jmp	SHORT $LN272@initialize
$LN267@initialize:

; 981  :                case QUADRATIC: quad_to_lagrange(1); break;

	push	1
	call	_quad_to_lagrange
	add	esp, 4

; 983  :              }
; 984  :              tok = yylex();
; 985  :              recovery_flag = 0;
; 986  :              break;

	jmp	SHORT $LN272@initialize
$LN268@initialize:

; 980  :              { case LINEAR: linear_to_lagrange(1); break;

	push	1
	call	_linear_to_lagrange
	add	esp, 4

; 983  :              }
; 984  :              tok = yylex();
; 985  :              recovery_flag = 0;
; 986  :              break;

	jmp	SHORT $LN272@initialize
$LN251@initialize:

; 1036 :               
; 1037 :         case JIGGLE_TOK:
; 1038 :              web.jiggle_flag = 1;

	mov	DWORD PTR _web+900, 1

; 1039 :              tok = yylex();
; 1040 :              recovery_flag = 0;
; 1041 :              break;

	jmp	$LN272@initialize
$LN235@initialize:

; 1118 : 
; 1119 :         case VIEW_MATRIX_TOK: recovery_flag = 0; 
; 1120 :             lists_flag = LISTS_SOME;
; 1121 :              uminus_flag = 1;
; 1122 :              for ( i = 0 ; i <= SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	xor	edi, edi
	mov	ebx, 1
	mov	DWORD PTR _recovery_flag, edi
	mov	DWORD PTR _lists_flag, ebx
	mov	DWORD PTR _uminus_flag, ebx
	cmp	eax, edi
	jl	SHORT $LN232@initialize
	npad	2
$LL573@initialize:

; 1123 :              { for ( j = 0 ; j <= SDIM ; j++ ) 

	xor	esi, esi
	test	eax, eax
	js	SHORT $LN233@initialize
	npad	10
$LL231@initialize:
	mov	edx, DWORD PTR _view
	mov	eax, DWORD PTR [edx+edi*4]
	lea	ecx, DWORD PTR [eax+esi*8]

; 1124 :                { if ( read_const(&view[i][j]) <= 0 )

	push	ecx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN502@initialize

; 1123 :              { for ( j = 0 ; j <= SDIM ; j++ ) 

	add	esi, ebx
	cmp	esi, DWORD PTR _web+616
	jle	SHORT $LL231@initialize

; 1705 :     if ( (web.boundaries[i].attr & (CON_ENERGY|CON_CONTENT)) 
; 1706 :                  && !everything_quantities_flag  )

	jmp	SHORT $LN233@initialize
$LN502@initialize:

; 1125 :                  { kb_error(1861,"Not enough values for view matrix.\n",
; 1126 :                      DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CE@BPKPNIKE@Not?5enough?5values?5for?5view?5matri@
	push	1861					; 00000745H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN233@initialize:

; 1118 : 
; 1119 :         case VIEW_MATRIX_TOK: recovery_flag = 0; 
; 1120 :             lists_flag = LISTS_SOME;
; 1121 :              uminus_flag = 1;
; 1122 :              for ( i = 0 ; i <= SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	add	edi, ebx
	cmp	edi, eax
	jle	SHORT $LL573@initialize
$LN232@initialize:

; 1127 :                    break;
; 1128 :                  }
; 1129 :                }     
; 1130 :              }
; 1131 :              datafile_view_flag = 1;

	mov	DWORD PTR _datafile_view_flag, ebx

; 1132 :              lists_flag = LISTS_OFF;

	mov	DWORD PTR _lists_flag, 0

; 1133 :              if ( i > SDIM ) tok = yylex();  /* lookahead */

	cmp	edi, eax
	jle	$LN548@initialize

; 1134 :           break;

	jmp	$LN89@initialize
$LN226@initialize:

; 1135 : 
; 1136 :         case VIEW_TRANSFORMS_TOK: recovery_flag = 0; uminus_flag = 1; 
; 1137 :              read_transforms(0); break;

	push	0
	mov	DWORD PTR _recovery_flag, 0
	mov	DWORD PTR _uminus_flag, 1
	call	_read_transforms
	jmp	$LN586@initialize
$LN218@initialize:

; 1164 : 
; 1165 :         case OPTIMIZING_PARAMETER_TOK:  recovery_flag = 0; uminus_flag = 0; 
; 1166 :              read_parameter(); break;
; 1167 : 
; 1168 :         case FUNCTION_TOK:
; 1169 :              datafile_flag = 0; 

	xor	esi, esi

; 1171 :              command("function _anti_line_no_",NO_HISTORY);

	push	esi
	push	OFFSET ??_C@_0BI@KKMILGMA@function?5_anti_line_no_?$AA@
$LN598@initialize:

; 1170 :              function_kludge_flag = 1;

	mov	edi, 1
	mov	DWORD PTR _function_kludge_flag, edi
	mov	DWORD PTR _datafile_flag, esi

; 1171 :              command("function _anti_line_no_",NO_HISTORY);

	call	_command

; 1172 :              function_kludge_flag = 0;
; 1173 :              datafile_flag = 1;
; 1174 :              verb_flag = 0;
; 1175 :              tok = yylex();

	push	esi
	mov	DWORD PTR _function_kludge_flag, esi
	mov	DWORD PTR _datafile_flag, edi
	mov	DWORD PTR _verb_flag, esi
	call	_kb_yylex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax

; 1176 :              break;

	jmp	$LN548@initialize
$LN217@initialize:

; 1177 : 
; 1178 :         case PROCEDURE_WORD_TOK: 
; 1179 :              datafile_flag = 0; 

	xor	esi, esi

; 1180 :              function_kludge_flag = 1;
; 1181 :              command("procedure _anti_line_no_",NO_HISTORY);

	push	esi
	push	OFFSET ??_C@_0BJ@DGNKKEGC@procedure?5_anti_line_no_?$AA@

; 1182 :              function_kludge_flag = 0;
; 1183 :              datafile_flag = 1;
; 1184 :              verb_flag = 0;
; 1185 :              tok = yylex();
; 1186 :              break;

	jmp	SHORT $LN598@initialize
$LN216@initialize:

; 1187 : 
; 1188 :         case BOUNDARY_TOK:  recovery_flag = 0; uminus_flag = 0; 

	xor	eax, eax
	mov	DWORD PTR _recovery_flag, eax
	mov	DWORD PTR _uminus_flag, eax

; 1189 :              read_boundary(); break;

	call	_read_boundary
	jmp	$LN548@initialize
$LN215@initialize:

; 1190 : 
; 1191 :         case CONSTRAINT_TOK:  recovery_flag = 0; uminus_flag = 0; 

	xor	eax, eax
	mov	DWORD PTR _recovery_flag, eax
	mov	DWORD PTR _uminus_flag, eax

; 1192 :              read_constraint(); break;

	call	_read_constraint
	jmp	$LN548@initialize
$LN213@initialize:

; 1196 : 
; 1197 :         case QUANTITY_TOK: recovery_flag = 0; uminus_flag = 0; 

	xor	eax, eax
	mov	DWORD PTR _recovery_flag, eax
	mov	DWORD PTR _uminus_flag, eax

; 1198 :              read_quantity(); break;

	call	_read_quantity
	jmp	$LN548@initialize
$LN212@initialize:

; 1199 : 
; 1200 :         case METHOD_INSTANCE_TOK: recovery_flag = 0; uminus_flag = 0; 

	xor	eax, eax
	mov	DWORD PTR _recovery_flag, eax
	mov	DWORD PTR _uminus_flag, eax

; 1201 :              read_method_instance(); break;

	call	_read_method_instance
	jmp	$LN548@initialize
$LN211@initialize:

; 1202 : 
; 1203 :         case AREA_FIXED_TOK:
; 1204 :              kb_error(2101,
; 1205 :                 "Area_fixed is obsolete.  Replace with named quantity.\n",
; 1206 :                  DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DH@FLLLMGHG@Area_fixed?5is?5obsolete?4?5?5Replace@
	push	2101					; 00000835H
	call	_kb_error

; 1207 :              area_fixed_flag = 1;
; 1208 :              uminus_flag = 0;

	xor	esi, esi

; 1209 :              if ( read_const(&area_fixed_target) <= 0 )

	push	OFFSET _area_fixed_target
	mov	DWORD PTR _area_fixed_flag, 1
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 16					; 00000010H
	test	eax, eax
	jg	SHORT $LN210@initialize

; 1210 :              { kb_error(1078,"Missing fixed area value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BL@IJBPFNBA@Missing?5fixed?5area?5value?4?6?$AA@
	push	1078					; 00000436H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1211 :                 if ( tok == AREA_FIXED_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 448			; 000001c0H
	jne	SHORT $LN208@initialize
$LN210@initialize:

; 1212 :              }
; 1213 :              else tok = yylex();

	push	esi
	call	_kb_yylex
	mov	DWORD PTR _tok, eax
	add	esp, 4
$LN208@initialize:

; 1214 :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 1215 :              break;

	jmp	$LN548@initialize
$LN207@initialize:

; 1216 : 
; 1217 :         case DIFFUSION_TOK:
; 1218 :              web.diffusion_flag = 1;
; 1219 :              web.diffusion_const = 0.0;

	fldz

; 1220 :              uminus_flag = 0;

	xor	esi, esi

; 1221 :              if ( read_const(&web.diffusion_const) <= 0 )

	push	OFFSET _web+784
	fstp	QWORD PTR _web+784
	mov	DWORD PTR _web+780, 1
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN206@initialize

; 1222 :              { kb_error(1079,"Missing DIFFUSION value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BK@JNKAIEKD@Missing?5DIFFUSION?5value?4?6?$AA@
	push	1079					; 00000437H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1223 :                if ( tok == DIFFUSION_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 382			; 0000017eH
$LN599@initialize:
	jne	SHORT $LN208@initialize
$LN206@initialize:

; 1224 :              }
; 1225 :              else tok = yylex();

	push	esi
	call	_kb_yylex

; 1226 :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 1227 :              break;

	jmp	$LN584@initialize
$LN197@initialize:

; 1254 :               
; 1255 :         case AUTOCHOP_TOK:
; 1256 :              autochop_flag = 1;
; 1257 :              autochop_length = 1.0;

	fld1

; 1258 :              uminus_flag = 0;

	xor	esi, esi

; 1259 :              if ( read_const(&autochop_length) <= 0 )

	push	OFFSET _autochop_length
	fstp	QWORD PTR _autochop_length
	mov	DWORD PTR _autochop_flag, 1
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN206@initialize

; 1260 :              { kb_error(1080,"Missing AUTOCHOP length.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BK@KFFCGAOL@Missing?5AUTOCHOP?5length?4?6?$AA@
	push	1080					; 00000438H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1261 :                if ( tok == AUTOCHOP_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 361			; 00000169H

; 1262 :              }
; 1263 :              else tok = yylex();
; 1264 :              recovery_flag = 0;
; 1265 :              break;

	jmp	SHORT $LN599@initialize
$LN104@initialize:

; 1542 : 
; 1543 :         case SCALE_TOK:
; 1544 :              uminus_flag = 0;

	xor	esi, esi

; 1545 :              if ( read_const(&web.scale) <= 0 )

	push	OFFSET _web+1512
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN103@initialize

; 1546 :              { kb_error(1103,"Missing SCALE value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BG@HHDBINKH@Missing?5SCALE?5value?4?6?$AA@
	push	1103					; 0000044fH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1547 :                if ( tok == SCALE_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 404			; 00000194H
	jne	SHORT $LN101@initialize
$LN103@initialize:

; 1548 :              }
; 1549 :              else tok = yylex();

	push	esi
	call	_kb_yylex
	mov	DWORD PTR _tok, eax
	add	esp, 4
$LN101@initialize:

; 1550 :              if ( tok == FIXED_TOK )

	cmp	DWORD PTR _tok, 317			; 0000013dH
	jne	SHORT $LN114@initialize

; 1551 :              { web.motion_flag = 1;

	mov	DWORD PTR _web+852, 1
$LN115@initialize:

; 1552 :                tok = yylex();

	push	esi
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN114@initialize:

; 1553 :              }
; 1554 :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 1555 :              break;

	jmp	$LN548@initialize
$LN95@initialize:

; 1566 : 
; 1567 :         case PRESSURE_TOK:
; 1568 :              uminus_flag = 0;

	xor	esi, esi

; 1569 :              if ( read_const(&web.pressure) <= 0 )

	push	OFFSET _web+1536
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN94@initialize

; 1570 :              { kb_error(1105,"Missing PRESSURE value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BJ@MFADOPAL@Missing?5PRESSURE?5value?4?6?$AA@
	push	1105					; 00000451H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1571 :                if ( tok == PRESSURE_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 319			; 0000013fH
	jne	SHORT $LN92@initialize
	push	esi
	call	_kb_yylex

; 1572 :              }
; 1573 :              else 
; 1574 :              { tok = yylex(); web.pressure_flag = 1; }

	mov	DWORD PTR _tok, eax
	add	esp, 4

; 1575 :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 1576 :              break;

	jmp	$LN548@initialize
$LN94@initialize:

; 1572 :              }
; 1573 :              else 
; 1574 :              { tok = yylex(); web.pressure_flag = 1; }

	push	esi
	call	_kb_yylex
	mov	DWORD PTR _web+868, 1
	mov	DWORD PTR _tok, eax
	add	esp, 4
$LN92@initialize:

; 1575 :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 1576 :              break;

	jmp	$LN548@initialize
$LN91@initialize:

; 1577 : 
; 1578 :         case VERTICES_TOK: lists_flag = LISTS_FULL; topflag = 0; break;  

	mov	DWORD PTR _lists_flag, 2
	mov	DWORD PTR _topflag, 0
	jmp	$LN548@initialize
$LN381@initialize:

; 579  : 
; 580  :         case SUPPRESS_WARNING_TOK:
; 581  :              if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN380@initialize

; 582  :              { kb_error(4531,"Missing suppressed warning number.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CE@PBGBCJEK@Missing?5suppressed?5warning?5numbe@
	push	4531					; 000011b3H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 583  :                break;

	jmp	$LN548@initialize
$LN380@initialize:

; 584  :              }
; 585  :              if ( warnings_suppressed_count < MAXSUPPRESS )

	mov	eax, DWORD PTR _warnings_suppressed_count
	cmp	eax, 100				; 00000064H
	jge	SHORT $LN379@initialize

; 586  :                warnings_suppressed[warnings_suppressed_count++] = yylval.i;

	mov	edx, DWORD PTR _yylval
	mov	DWORD PTR _warnings_suppressed[eax*4], edx
	inc	eax
	mov	DWORD PTR _warnings_suppressed_count, eax

; 587  :              else

	jmp	$LN89@initialize
$LN379@initialize:

; 588  :                kb_error(4532,"Too many warnings suppressed.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BP@EAFIIJC@Too?5many?5warnings?5suppressed?4?6?$AA@
	push	4532					; 000011b4H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 589  :              
; 590  :              tok = yylex();  /* eat the number */
; 591  :              break;

	jmp	$LN89@initialize
$LN462@initialize:

; 489  :   { switch ( tok )

	cmp	eax, 35002				; 000088baH
	jg	$LN463@initialize
	je	$LN353@initialize
	cmp	eax, 1842				; 00000732H
	jg	$LN464@initialize
	je	$LN125@initialize
	cmp	eax, 562				; 00000232H
	je	$LN377@initialize
	cmp	eax, 1642				; 0000066aH
	je	SHORT $LN133@initialize
	cmp	eax, 1841				; 00000731H
	jne	$LN90@initialize

; 1462 : 
; 1463 :         case V_INTEGRAL_ORDER_1D:
; 1464 :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1465 :              if ( tok != INTEGER_TOK )

	cmp	eax, 265				; 00000109H
	je	SHORT $LN128@initialize

; 1466 :                 { kb_error(1095,"Missing INTEGRAL_ORDER_1D value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CC@GFONLEHO@Missing?5INTEGRAL_ORDER_1D?5value?4@
	push	1095					; 00000447H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1467 :                   break;

	jmp	$LN548@initialize
$LN128@initialize:

; 1468 :                 }
; 1469 :              if ( yylval.i < 1 )

	mov	eax, DWORD PTR _yylval
	cmp	eax, 1
	jge	SHORT $LN127@initialize

; 1470 :               { sprintf(errmsg,"Invalid INTEGRAL_ORDER_1D value %d.\n",yylval.i);

	push	eax
	push	OFFSET ??_C@_0CF@FKEOPIHN@Invalid?5INTEGRAL_ORDER_1D?5value?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1471 :                  kb_error(1096,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1096					; 00000448H
	call	_kb_error
	add	esp, 24					; 00000018H
	jmp	$LN272@initialize
$LN127@initialize:

; 1472 :               }
; 1473 :              else {  web.gauss1D_order = yylval.i; 

	mov	DWORD PTR _web+1592, eax

; 1474 :                      set_by_user_gauss_1D = web.gauss1D_order;

	mov	DWORD PTR _set_by_user_gauss_1D, eax

; 1475 :                   }
; 1476 :              tok = yylex();
; 1477 :              recovery_flag = 0;
; 1478 :              break;

	jmp	$LN272@initialize
$LN133@initialize:

; 1440 :              recovery_flag = 0;
; 1441 :              break;
; 1442 : 
; 1443 :         case V_INTEGRAL_ORDER:
; 1444 :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1445 :              if ( tok != INTEGER_TOK )

	cmp	eax, 265				; 00000109H
	je	SHORT $LN132@initialize

; 1446 :                 { kb_error(1093,"Missing INTEGRAL_ORDER value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BP@GEPDLMPC@Missing?5INTEGRAL_ORDER?5value?4?6?$AA@
	push	1093					; 00000445H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1447 :                   break;

	jmp	$LN548@initialize
$LN132@initialize:

; 1448 :                 }
; 1449 :              if ( yylval.i < 1 )

	mov	eax, DWORD PTR _yylval
	cmp	eax, 1
	jge	SHORT $LN131@initialize

; 1450 :               { sprintf(errmsg,"Invalid INTEGRAL_ORDER value %d.\n",yylval.i);

	push	eax
	push	OFFSET ??_C@_0CC@IDAJELNI@Invalid?5INTEGRAL_ORDER?5value?5?$CFd?4@
	push	OFFSET _errmsg
	call	_sprintf

; 1451 :                 kb_error(1094,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1094					; 00000446H
	call	_kb_error
	add	esp, 24					; 00000018H

; 1452 :               }
; 1453 :              else

	jmp	$LN272@initialize
$LN131@initialize:

; 1454 :              { web.gauss1D_order = 2*yylval.i-1; 

	lea	ecx, DWORD PTR [eax+eax-1]
	mov	DWORD PTR _web+1592, ecx

; 1455 :                set_by_user_gauss_1D = web.gauss1D_order;

	mov	DWORD PTR _set_by_user_gauss_1D, ecx
$LN123@initialize:

; 1456 :                web.gauss2D_order = yylval.i;

	mov	DWORD PTR _web+1596, eax

; 1457 :                set_by_user_gauss_2D = web.gauss2D_order;

	mov	DWORD PTR _set_by_user_gauss_2D, eax

; 1458 :              }
; 1459 :              tok = yylex();
; 1460 :              recovery_flag = 0;
; 1461 :              break;

	jmp	$LN272@initialize
$LN377@initialize:

; 592  :       
; 593  :        case UNSUPPRESS_WARNING_TOK:
; 594  :              if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN376@initialize

; 595  :              { kb_error(4533,"Missing unsuppressed warning number.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CG@OMGLPLHB@Missing?5unsuppressed?5warning?5num@
	push	4533					; 000011b5H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 596  :                break;

	jmp	$LN548@initialize
$LN376@initialize:

; 597  :              }
; 598  :              for ( i = 0 ; i < warnings_suppressed_count ; i++ )

	mov	ecx, DWORD PTR _warnings_suppressed_count
	xor	eax, eax
	test	ecx, ecx
	jle	$LN89@initialize
	mov	edx, DWORD PTR _yylval
$LL375@initialize:

; 599  :                if ( warnings_suppressed[i] == yylval.i )

	cmp	DWORD PTR _warnings_suppressed[eax*4], edx
	je	SHORT $LN503@initialize

; 597  :              }
; 598  :              for ( i = 0 ; i < warnings_suppressed_count ; i++ )

	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL375@initialize

; 1705 :     if ( (web.boundaries[i].attr & (CON_ENERGY|CON_CONTENT)) 
; 1706 :                  && !everything_quantities_flag  )

	jmp	$LN89@initialize
$LN503@initialize:

; 600  :                { warnings_suppressed[i] = warnings_suppressed[--warnings_suppressed_count];

	dec	ecx
	mov	DWORD PTR _warnings_suppressed_count, ecx
	mov	ecx, DWORD PTR _warnings_suppressed[ecx*4]
	mov	DWORD PTR _warnings_suppressed[eax*4], ecx

; 601  :                  break;
; 602  :                }          
; 603  :              tok = yylex();  /* eat the number */
; 604  :              break;

	jmp	$LN89@initialize
$LN125@initialize:

; 1479 : 
; 1480 :         case V_INTEGRAL_ORDER_2D:
; 1481 :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1482 :              if ( tok != INTEGER_TOK )

	cmp	eax, 265				; 00000109H
	je	SHORT $LN124@initialize

; 1483 :                 { kb_error(1097,"Missing INTEGRAL_ORDER_2D value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CC@PMAPNCHP@Missing?5INTEGRAL_ORDER_2D?5value?4@
	push	1097					; 00000449H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1484 :                   break;

	jmp	$LN548@initialize
$LN124@initialize:

; 1485 :                 }
; 1486 :              if ( yylval.i < 1 )

	mov	eax, DWORD PTR _yylval
	cmp	eax, 1
	jge	$LN123@initialize

; 1487 :               { sprintf(errmsg,"Invalid INTEGRAL_ORDER_2D value %d.\n",yylval.i);

	push	eax
	push	OFFSET ??_C@_0CF@CGCPNNKG@Invalid?5INTEGRAL_ORDER_2D?5value?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1488 :                 kb_error(1098,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1098					; 0000044aH
	call	_kb_error
	add	esp, 24					; 00000018H
	jmp	$LN272@initialize
$LN464@initialize:

; 489  :   { switch ( tok )

	cmp	eax, 2271				; 000008dfH
	je	SHORT $LN340@initialize
	cmp	eax, 10639				; 0000298fH
	jne	$LN90@initialize

; 574  : 
; 575  :         case MPI_LOCAL_BODIES_NODE: 
; 576  :              mpi_local_bodies_flag = 1;

	mov	DWORD PTR _mpi_local_bodies_flag, 1

; 577  :              tok = yylex();  /* eat it */
; 578  :              break;

	jmp	$LN89@initialize
$LN340@initialize:

; 693  : 
; 694  :         case V_EVERYTHING_QUANTITIES:
; 695  :              /*everything_quantities_flag = quantities_only_flag = 1;*/
; 696  :              if ( !option_q) option_q = 2;

	cmp	DWORD PTR _option_q, 0
	jne	$LN89@initialize
	mov	DWORD PTR _option_q, 2

; 697  :              tok = yylex();
; 698  :              /* should warn if anything else done yet */
; 699  :              break;

	jmp	$LN89@initialize
$LN353@initialize:

; 654  : 
; 655  :         case VOLUME_METHOD_NAME_TOK:   
; 656  :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 657  :              if ( tok == QUOTATION_TOK )

	cmp	eax, 309				; 00000135H
	jne	SHORT $LN352@initialize

; 658  :              { if ( SDIM == 2 ) 

	mov	esi, 2

; 659  :                 strncpy(area_method_name,yytext,sizeof(area_method_name)-1);

	push	99					; 00000063H
	cmp	DWORD PTR _web+616, esi
	jne	SHORT $LN351@initialize
	mov	edx, DWORD PTR _yytext
	push	edx
	push	OFFSET _area_method_name

; 660  :                else

	jmp	SHORT $LN588@initialize
$LN351@initialize:

; 661  :                 strncpy(volume_method_name,yytext,sizeof(volume_method_name)-1);

	mov	eax, DWORD PTR _yytext
	push	eax
	push	OFFSET _volume_method_name
$LN588@initialize:
	call	_strncpy
	add	esp, 12					; 0000000cH

; 662  :                tok = yylex();   

	push	0
	call	_kb_yylex
	add	esp, 4

; 663  :                if ( !option_q) option_q = 2;  /* convert_to_quantities */

	cmp	DWORD PTR _option_q, 0
	mov	DWORD PTR _tok, eax
	jne	$LN548@initialize
	mov	DWORD PTR _option_q, esi

; 664  :              } 
; 665  :              else

	jmp	$LN548@initialize
$LN352@initialize:

; 666  :                kb_error(2096,"volume_method_name needs quoted string.\n",
; 667  :                       DATAFILE_ERROR);  

	push	6
	push	OFFSET ??_C@_0CJ@HAEPAFLK@volume_method_name?5needs?5quoted?5@
	push	2096					; 00000830H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 668  :              break;

	jmp	$LN548@initialize
$LN463@initialize:

; 489  :   { switch ( tok )

	sub	eax, 35004				; 000088bcH
	cmp	eax, 98					; 00000062H
	ja	$LN90@initialize
	movzx	ecx, BYTE PTR $LN533@initialize[eax]
	jmp	DWORD PTR $LN601@initialize[ecx*4]
$LN410@initialize:

; 490  :      { 
; 491  :         case VERTICES_PREDICTED_TOK:
; 492  :              if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN409@initialize

; 493  :              { kb_error(7531,"Missing vertices_predicted number.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CE@MMMILBBM@Missing?5vertices_predicted?5numbe@
	push	7531					; 00001d6bH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 494  :                break;

	jmp	$LN548@initialize
$LN409@initialize:

; 495  :              }
; 496  :              if ( yylval.i < 0 )

	mov	eax, DWORD PTR _yylval
	test	eax, eax
	jns	SHORT $LN408@initialize

; 497  :                kb_error(7364,"Vertices_predicted must be nonnegative.\n",WARNING);               

	push	2
	push	OFFSET ??_C@_0CJ@DHAABPBI@Vertices_predicted?5must?5be?5nonne@
	push	7364					; 00001cc4H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 498  :              else

	jmp	$LN89@initialize
$LN408@initialize:

; 499  :                elements_predicted[VERTEX] = yylval.i;                

	mov	DWORD PTR _elements_predicted, eax

; 500  :              tok = yylex();  /* eat the number */
; 501  :              break;

	jmp	$LN89@initialize
$LN406@initialize:

; 502  : 
; 503  :         case EDGES_PREDICTED_TOK:
; 504  :              if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN405@initialize

; 505  :              { kb_error(7532,"Missing edges_predicted number.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CB@FDEIENDO@Missing?5edges_predicted?5number?4?6@
	push	7532					; 00001d6cH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 506  :                break;

	jmp	$LN548@initialize
$LN405@initialize:

; 507  :              }
; 508  :              if ( yylval.i < 0 )

	mov	eax, DWORD PTR _yylval
	test	eax, eax
	jns	SHORT $LN404@initialize

; 509  :                kb_error(7365,"Edges_predicted must be nonnegative.\n",WARNING);               

	push	2
	push	OFFSET ??_C@_0CG@JLLOGAAP@Edges_predicted?5must?5be?5nonnegat@
	push	7365					; 00001cc5H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 510  :              else

	jmp	$LN89@initialize
$LN404@initialize:

; 511  :                elements_predicted[EDGE] = yylval.i;                

	mov	DWORD PTR _elements_predicted+4, eax

; 512  :              tok = yylex();  /* eat the number */
; 513  :              break;

	jmp	$LN89@initialize
$LN402@initialize:

; 514  :                      
; 515  :         case FACETS_PREDICTED_TOK:
; 516  :              if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN401@initialize

; 517  :              { kb_error(7533,"Missing facets_predicted number.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CC@BOGJNNPF@Missing?5facets_predicted?5number?4@
	push	7533					; 00001d6dH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 518  :                break;

	jmp	$LN548@initialize
$LN401@initialize:

; 519  :              }
; 520  :              if ( yylval.i < 0 )

	mov	eax, DWORD PTR _yylval
	test	eax, eax
	jns	SHORT $LN400@initialize

; 521  :                kb_error(7366,"Faces_predicted must be nonnegative.\n",WARNING);               

	push	2
	push	OFFSET ??_C@_0CG@KFHJFP@Faces_predicted?5must?5be?5nonnegat@
	push	7366					; 00001cc6H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 522  :              else

	jmp	$LN89@initialize
$LN400@initialize:

; 523  :                elements_predicted[FACET] = yylval.i;                

	mov	DWORD PTR _elements_predicted+8, eax

; 524  :              tok = yylex();  /* eat the number */
; 525  :              break;

	jmp	$LN89@initialize
$LN398@initialize:

; 526  : 
; 527  :         case BODIES_PREDICTED_TOK:
; 528  :              if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN397@initialize

; 529  :              { kb_error(7534,"Missing bodies_predicted number.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CC@PMAPEPHJ@Missing?5bodies_predicted?5number?4@
	push	7534					; 00001d6eH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 530  :                break;

	jmp	$LN548@initialize
$LN397@initialize:

; 531  :              }
; 532  :              if ( yylval.i < 0 )

	mov	eax, DWORD PTR _yylval
	test	eax, eax
	jns	SHORT $LN396@initialize

; 533  :                kb_error(7367,"Bodies_predicted must be nonnegative.\n",WARNING);               

	push	2
	push	OFFSET ??_C@_0CH@KOAIAFMM@Bodies_predicted?5must?5be?5nonnega@
	push	7367					; 00001cc7H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 534  :              else

	jmp	$LN89@initialize
$LN396@initialize:

; 535  :                elements_predicted[BODY] = yylval.i;                

	mov	DWORD PTR _elements_predicted+12, eax

; 536  :              tok = yylex();  /* eat the number */
; 537  :              break;

	jmp	$LN89@initialize
$LN394@initialize:

; 538  : 
; 539  :         case FACETEDGES_PREDICTED_TOK:
; 540  :              if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN393@initialize

; 541  :              { kb_error(7535,"Missing facetedges_predicted number.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CG@FNDIGCBP@Missing?5facetedges_predicted?5num@
	push	7535					; 00001d6fH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 542  :                break;

	jmp	$LN548@initialize
$LN393@initialize:

; 543  :              }
; 544  :              if ( yylval.i < 0 )

	mov	eax, DWORD PTR _yylval
	test	eax, eax
	jns	SHORT $LN392@initialize

; 545  :                kb_error(2667,"Facetedges_predicted must be nonnegative.\n",WARNING);               

	push	2
	push	OFFSET ??_C@_0CL@LJPHAGLH@Facetedges_predicted?5must?5be?5non@
	push	2667					; 00000a6bH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 546  :              else

	jmp	$LN89@initialize
$LN392@initialize:

; 547  :                elements_predicted[FACETEDGE] = yylval.i;                

	mov	DWORD PTR _elements_predicted+16, eax

; 548  :              tok = yylex();  /* eat the number */
; 549  :              break;

	jmp	$LN89@initialize
$LN390@initialize:

; 550  : 
; 551  :         case QUANTITIES_PREDICTED_TOK:
; 552  :              if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN389@initialize

; 553  :              { kb_error(7536,"Missing quantities_predicted number.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CG@HOIDIOKP@Missing?5quantities_predicted?5num@
	push	7536					; 00001d70H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 554  :                break;

	jmp	$LN548@initialize
$LN389@initialize:

; 555  :              }
; 556  :              if ( yylval.i < 0 )

	mov	eax, DWORD PTR _yylval
	test	eax, eax
	jns	SHORT $LN388@initialize

; 557  :                kb_error(7368,"Quantities_predicted must be nonnegative.\n",WARNING);               

	push	2
	push	OFFSET ??_C@_0CL@ILLLMBPC@Quantities_predicted?5must?5be?5non@
	push	7368					; 00001cc8H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 558  :              else

	jmp	$LN89@initialize
$LN388@initialize:

; 559  :                quantities_predicted = yylval.i;                

	mov	DWORD PTR _quantities_predicted, eax

; 560  :              tok = yylex();  /* eat the number */
; 561  :              break;

	jmp	$LN89@initialize
$LN386@initialize:

; 562  : 
; 563  :         case METHOD_INSTANCES_PREDICTED_TOK:
; 564  :              if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN385@initialize

; 565  :              { kb_error(7537,"Missing method_instances_predicted number.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CM@BCDJPNPP@Missing?5method_instances_predict@
	push	7537					; 00001d71H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 566  :                break;

	jmp	$LN548@initialize
$LN385@initialize:

; 567  :              }
; 568  :              if ( yylval.i < 0 )

	mov	eax, DWORD PTR _yylval
	test	eax, eax
	jns	SHORT $LN384@initialize

; 569  :                kb_error(7369,"Method_instances_predicted must be nonnegative.\n",WARNING);               

	push	2
	push	OFFSET ??_C@_0DB@ILDABPKE@Method_instances_predicted?5must?5@
	push	7369					; 00001cc9H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 570  :              else

	jmp	$LN89@initialize
$LN384@initialize:

; 571  :                method_instances_predicted = yylval.i;                

	mov	DWORD PTR _method_instances_predicted, eax

; 572  :              tok = yylex();  /* eat the number */
; 573  :              break;

	jmp	$LN89@initialize
$LN371@initialize:

; 605  : 
; 606  : 
; 607  :         case HESSIAN_SPECIAL_NORMAL_VECTOR_TOK:
; 608  :              tok = yylex();

	push	0
	call	_kb_yylex
	mov	DWORD PTR _tok, eax

; 609  :              for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 4
	xor	esi, esi
	test	eax, eax
	jle	$LN548@initialize

; 605  : 
; 606  : 
; 607  :         case HESSIAN_SPECIAL_NORMAL_VECTOR_TOK:
; 608  :              tok = yylex();

	mov	edi, OFFSET _hessian_special_normal_expr+20
	npad	5
$LL370@initialize:

; 610  :              { 
; 611  :                if ( (tolower(yytext[0]) != 'c') || (yytext[1] != '1' + i) )

	mov	ecx, DWORD PTR _yytext
	movsx	edx, BYTE PTR [ecx]
	cmp	BYTE PTR _kb_lower_array[edx], 99	; 00000063H
	jne	$LN548@initialize
	movsx	ecx, BYTE PTR [ecx+1]
	lea	edx, DWORD PTR [esi+49]
	cmp	ecx, edx
	jne	$LN548@initialize

; 612  :                   break;
; 613  :                esize = exparse(SDIM,hessian_special_normal_expr+i,USERCOPY);

	push	1
	lea	ecx, DWORD PTR [edi-20]
	push	ecx
	push	eax
	call	_exparse

; 614  :                sprintf(hessian_special_normal_expr[i].name,
; 615  :                   "hessian_special_normal component %d",i);

	push	esi
	push	OFFSET ??_C@_0CE@EPOONLLG@hessian_special_normal?5component@
	push	edi
	mov	ebx, eax
	call	_sprintf

; 616  :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 28					; 0000001cH
	inc	esi
	mov	DWORD PTR _tok, eax

; 617  :                if ( esize <= 0 )

	test	ebx, ebx
	jle	$LN505@initialize

; 609  :              for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	add	edi, 104				; 00000068H
	cmp	esi, eax
	jl	SHORT $LL370@initialize

; 622  :                  return;
; 623  :                }
; 624  :              }
; 625  :              break;

	jmp	$LN548@initialize
$LN364@initialize:

; 626  : 
; 627  :         case LENGTH_METHOD_NAME_TOK:   
; 628  :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 629  :              if ( tok == QUOTATION_TOK )

	cmp	eax, 309				; 00000135H
	jne	$LN363@initialize

; 630  :              { strncpy(length_method_name,yytext,sizeof(length_method_name)-1);

	mov	edx, DWORD PTR _yytext
	push	99					; 00000063H
	push	edx
	push	OFFSET _length_method_name
	call	_strncpy

; 631  :                if ( strcmp(yytext,"circular_arc_length")==0 )

	mov	esi, DWORD PTR _yytext
	add	esp, 12					; 0000000cH
	mov	ecx, OFFSET ??_C@_0BE@OOOEBCHL@circular_arc_length?$AA@
	mov	eax, esi
$LL534@initialize:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN535@initialize
	test	dl, dl
	je	SHORT $LN574@initialize
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN535@initialize
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL534@initialize
$LN574@initialize:
	xor	eax, eax
	jmp	SHORT $LN537@initialize
$LN535@initialize:
	sbb	eax, eax
	sbb	eax, -1
$LN537@initialize:
	test	eax, eax
	jne	SHORT $LN362@initialize

; 632  :                  circular_arc_flag = 1;

	mov	DWORD PTR _circular_arc_flag, 1
	jmp	SHORT $LN360@initialize
$LN362@initialize:

; 633  :                else if ( strcmp(yytext,"spherical_arc_length")==0 )

	mov	ecx, OFFSET ??_C@_0BF@GPHNFCAP@spherical_arc_length?$AA@
	mov	eax, esi
$LL538@initialize:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN539@initialize
	test	dl, dl
	je	SHORT $LN540@initialize
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN539@initialize
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL538@initialize
$LN540@initialize:
	xor	eax, eax
	jmp	SHORT $LN541@initialize
$LN539@initialize:
	sbb	eax, eax
	sbb	eax, -1
$LN541@initialize:
	test	eax, eax
	jne	SHORT $LN360@initialize

; 634  :                  spherical_arc_flag = 1;

	mov	DWORD PTR _spherical_arc_flag, 1
$LN360@initialize:

; 635  :                tok = yylex();   

	push	0
	call	_kb_yylex
	add	esp, 4
$LN594@initialize:

; 636  :                if ( !option_q) option_q = 2;  /* convert_to_quantities */

	cmp	DWORD PTR _option_q, 0
	mov	DWORD PTR _tok, eax
	jne	$LN548@initialize
	mov	DWORD PTR _option_q, 2

; 637  :              } 
; 638  :              else

	jmp	$LN548@initialize
$LN363@initialize:

; 639  :                kb_error(2485,"length_method_name needs quoted string.\n",
; 640  :                       DATAFILE_ERROR);  

	push	6
	push	OFFSET ??_C@_0CJ@PIDJOHNH@length_method_name?5needs?5quoted?5@
	push	2485					; 000009b5H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 641  :              break;

	jmp	$LN548@initialize
$LN357@initialize:

; 642  : 
; 643  :         case AREA_METHOD_NAME_TOK:   
; 644  :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 645  :              if ( tok == QUOTATION_TOK )

	cmp	eax, 309				; 00000135H
	jne	SHORT $LN356@initialize

; 646  :              { strncpy(area_method_name,yytext,sizeof(area_method_name)-1);

	mov	eax, DWORD PTR _yytext
	push	99					; 00000063H
	push	eax
	push	OFFSET _area_method_name
	call	_strncpy

; 647  :                tok = yylex();   

	push	0
	call	_kb_yylex
	add	esp, 16					; 00000010H

; 648  :                if ( !option_q) option_q = 2;  /* convert_to_quantities */
; 649  :              } 
; 650  :              else

	jmp	SHORT $LN594@initialize
$LN356@initialize:

; 651  :                kb_error(2590,"area_method_name needs quoted string.\n",
; 652  :                       DATAFILE_ERROR);  

	push	6
	push	OFFSET ??_C@_0CH@EPFCLKFB@area_method_name?5needs?5quoted?5st@
	push	2590					; 00000a1eH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 653  :              break;

	jmp	$LN548@initialize
$LN347@initialize:

; 669  : 
; 670  :         case KEEP_MACROS_TOK : keep_macros_flag = 1; tok = yylex();  break;

	mov	DWORD PTR _keep_macros_flag, 1
	jmp	$LN89@initialize
$LN346@initialize:

; 671  :         case VERSION_TOK:
; 672  :              tok = yylex();

	push	0
	call	_kb_yylex
	mov	DWORD PTR _tok, eax

; 673  :              strcpy(needed_version,yytext);

	mov	eax, DWORD PTR _yytext
	mov	edx, OFFSET _needed_version
	add	esp, 4
	sub	edx, eax
	npad	1
$LL418@initialize:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL418@initialize

; 674  :              tok = yylex();

	push	0
	call	_kb_yylex

; 675  :              if ( strcmp(needed_version,evolver_version) > 0 )

	mov	esi, DWORD PTR _evolver_version
	mov	DWORD PTR _tok, eax
	add	esp, 4
	mov	ecx, esi
	mov	eax, OFFSET _needed_version
$LL542@initialize:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN543@initialize
	test	dl, dl
	je	SHORT $LN544@initialize
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN543@initialize
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL542@initialize
$LN544@initialize:
	xor	eax, eax
	jmp	SHORT $LN545@initialize
$LN543@initialize:
	sbb	eax, eax
	sbb	eax, -1
$LN545@initialize:
	test	eax, eax
	jle	$LN548@initialize

; 676  :              { sprintf(errmsg,"\nDatafile %s needs Evolver version at least %s.  This is version %s.\n\n",datafilename,needed_version,evolver_version);

	push	esi
	push	OFFSET _needed_version
	push	OFFSET _datafilename
	push	OFFSET ??_C@_0EH@KBCGPNLA@?6Datafile?5?$CFs?5needs?5Evolver?5versi@
	push	OFFSET _errmsg
	call	_sprintf

; 677  :                kb_error(2097,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2097					; 00000831H
	call	_kb_error
	add	esp, 32					; 00000020H

; 678  :              }
; 679  :              break;

	jmp	$LN548@initialize
$LN344@initialize:

; 680  :         case LOAD_LIBRARY_TOK: 
; 681  :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 682  :              if ( tok == QUOTATION_TOK )

	cmp	eax, 309				; 00000135H
	jne	SHORT $LN343@initialize

; 683  :              {  load_library(yytext);

	mov	ecx, DWORD PTR _yytext
	push	ecx
	call	_load_library

; 684  :                 tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 8
	mov	DWORD PTR _tok, eax

; 688  :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, 0

; 689  :              break;

	jmp	$LN548@initialize
$LN343@initialize:

; 685  :              }
; 686  :              else
; 687  :               kb_error(2098,"LOAD_LIBRARY file name missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CB@KPGCCCNG@LOAD_LIBRARY?5file?5name?5missing?4?6@
	push	2098					; 00000832H
$LN592@initialize:
	call	_kb_error
	add	esp, 12					; 0000000cH

; 688  :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, 0

; 689  :              break;

	jmp	$LN548@initialize
$LN341@initialize:

; 690  : 
; 691  :         case INTERP_BDRY_PARAM_TOK:
; 692  :              interp_bdry_param = 1; tok = yylex(); break;

	mov	DWORD PTR _interp_bdry_param, 1
	jmp	$LN89@initialize
$LN338@initialize:

; 700  : 
; 701  :         case KEEP_ORIGINALS_TOK: match_id_flag = 1; sparse_ibase_flag = 1;

	mov	eax, 1
	mov	DWORD PTR _match_id_flag, eax
	mov	DWORD PTR _sparse_ibase_flag, eax

; 702  :              tok = yylex(); break;

	jmp	$LN89@initialize
$LN337@initialize:

; 703  : 
; 704  :         case SPACE_DIMENSION_TOK:
; 705  :              if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN336@initialize

; 706  :              { kb_error(1060,"Dimension of space missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BN@LPEBGEG@Dimension?5of?5space?5missing?4?6?$AA@
	push	1060					; 00000424H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 707  :                break;

	jmp	$LN548@initialize
$LN336@initialize:

; 708  :              }
; 709  :              if ( yylval.i > MAXCOORD )

	mov	eax, DWORD PTR _yylval
	cmp	eax, 6
	jle	SHORT $LN335@initialize

; 710  :              { sprintf(msg,"Space dimension too high.  Recompile with -DMAXCOORD=%d as compiler option.\n",yylval.i);

	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0EN@IGMMIJNI@Space?5dimension?5too?5high?4?5?5Recom@
	push	edx
	call	_sprintf

; 711  :                 kb_error(1061,msg,RECOVERABLE);

	mov	eax, DWORD PTR _msg
	push	1
	push	eax
	push	1061					; 00000425H
	call	_kb_error
	mov	eax, DWORD PTR _yylval
	add	esp, 24					; 00000018H
$LN335@initialize:

; 712  :              }
; 713  :              web.sdim = yylval.i;

	mov	DWORD PTR _web+616, eax

; 714  :              if ( web.sdim != DEFAULT_SDIM ) init_view();

	cmp	eax, 3
	je	SHORT $LN334@initialize
	call	_init_view
	mov	eax, DWORD PTR _yylval
$LN334@initialize:

; 715  :              web.skel[BODY].dimension = yylval.i;

	mov	DWORD PTR _web+340, eax

; 716  :              if ( web.sdim != SDIM )
; 717  :              { sprintf(errmsg,
; 718  :                   "This Evolver compiled strictly for space dimension %d.\n",
; 719  :                       SDIM);
; 720  :                kb_error(1062,errmsg,RECOVERABLE);
; 721  :              }
; 722  :              tok = yylex();
; 723  :              break;

	jmp	$LN89@initialize
$LN332@initialize:

; 724  : 
; 725  :         case SURFACE_DIMENSION_TOK:
; 726  :              if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN331@initialize

; 727  :              { kb_error(1063,"Dimension of surface missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@GAKBJBHJ@Dimension?5of?5surface?5missing?4?6?$AA@
	push	1063					; 00000427H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 728  :                break;

	jmp	$LN548@initialize
$LN331@initialize:

; 729  :              }
; 730  :              web.dimension = yylval.i;

	mov	eax, DWORD PTR _yylval
	mov	DWORD PTR _web+620, eax

; 731  :              if ( yylval.i > web.sdim )

	cmp	eax, DWORD PTR _web+616
	jle	SHORT $LN563@initialize

; 732  :                 kb_error(1064,"Surface dimension higher than space dimension.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DA@FILMHLNM@Surface?5dimension?5higher?5than?5sp@
	push	1064					; 00000428H
	call	_kb_error
	mov	eax, DWORD PTR _web+620
	add	esp, 12					; 0000000cH
$LN563@initialize:

; 733  : 
; 734  :              star_fraction = web.dimension + 1.0;
; 735  :              if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	fild	DWORD PTR _web+620
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR _star_fraction
	jne	SHORT $LN329@initialize

; 736  :              { web.skel[EDGE].ctrlpts = web.dimension;
; 737  :                 web.skel[EDGE].dimension = web.dimension - 1;

	lea	ecx, DWORD PTR [eax-1]

; 738  :                 web.skel[FACET].ctrlpts = web.dimension+1;

	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR _web+120, eax
	mov	DWORD PTR _web+116, ecx
	mov	DWORD PTR _web+232, edx

; 739  :                 web.skel[FACET].dimension = web.dimension;

	mov	DWORD PTR _web+228, eax
	jmp	$LN89@initialize
$LN329@initialize:

; 740  :              }
; 741  :              else if ( web.dimension == 1 ) web.representation = STRING;

	cmp	eax, 1
	jne	$LN89@initialize
	mov	DWORD PTR _web+624, eax

; 742  :              tok = yylex();
; 743  :              break;

	jmp	$LN89@initialize
$LN326@initialize:

; 744  : 
; 745  :         case SIMPLEX_REP_TOK:
; 746  :              web.representation = SIMPLEX;
; 747  :              web.skel[EDGE].ctrlpts = web.dimension;

	mov	eax, DWORD PTR _web+620

; 748  :              web.skel[EDGE].dimension = web.dimension - 1;

	lea	ecx, DWORD PTR [eax-1]

; 749  :              web.skel[FACET].ctrlpts = web.dimension+1;

	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR _web+624, 3
	mov	DWORD PTR _web+120, eax
	mov	DWORD PTR _web+116, ecx
	mov	DWORD PTR _web+232, edx

; 750  :              web.skel[FACET].dimension = web.dimension;

	mov	DWORD PTR _web+228, eax

; 751  :              calc_facet_volume = calc_simplex_volume;            

	mov	DWORD PTR _calc_facet_volume, OFFSET _calc_simplex_volume

; 752  :              calc_facet_energy = calc_simplex_energy;

	mov	DWORD PTR _calc_facet_energy, OFFSET _calc_simplex_energy

; 753  :              calc_facet_forces = calc_simplex_forces;

	mov	DWORD PTR _calc_facet_forces, OFFSET _calc_simplex_forces

; 754  :              tok = yylex();
; 755  :              break;

	jmp	$LN89@initialize
$LN302@initialize:

; 833  :           
; 834  :         case CONFORMAL_TOK:  /* have background metric on domain */
; 835  :              web.metric_flag = 1;

	mov	eax, 1

; 836  :              web.conformal_flag = 1;
; 837  :              recovery_flag = 0;
; 838  :              uminus_flag = 0;
; 839  :              if (exparse(SDIM,&web.metric[0][0],USERCOPY) <= 0 )

	push	eax
	mov	DWORD PTR _web+1676, eax
	mov	DWORD PTR _web+1680, eax
	mov	eax, DWORD PTR _web+616
	xor	esi, esi
	push	OFFSET _web+1688
	push	eax
	mov	DWORD PTR _recovery_flag, esi
	mov	DWORD PTR _uminus_flag, esi
	call	_exparse
	add	esp, 12					; 0000000cH
	test	eax, eax
	jg	SHORT $LN301@initialize

; 840  :              { sprintf(errmsg,"Bad conformal metric definition.\n");

	push	OFFSET ??_C@_0CC@GHIPFDMN@Bad?5conformal?5metric?5definition?4@
	push	OFFSET _errmsg
	call	_sprintf

; 841  :                kb_error(1071,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1071					; 0000042fH
	call	_kb_error
	add	esp, 20					; 00000014H
$LN301@initialize:

; 842  :              }
; 843  :              sprintf(web.metric[0][0].name,"conformal metric"); 

	push	OFFSET ??_C@_0BB@LMKJAPE@conformal?5metric?$AA@
	push	OFFSET _web+1708
	call	_sprintf

; 844  :              metric = dmatrix(0,SDIM-1,0,SDIM-1);

	mov	eax, DWORD PTR _web+616
	push	844					; 0000034cH
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	dec	eax
	push	eax
	push	esi
	push	eax
	push	esi
	call	_kb_dmatrix

; 845  :              metric_partial = dmatrix3(SDIM,SDIM,SDIM);

	push	845					; 0000034dH
	mov	DWORD PTR _metric, eax
	mov	eax, DWORD PTR _web+616
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	push	eax
	push	eax
	push	eax
	call	_kb_dmatrix3

; 846  :              det_array = dmatrix(0,web.dimension-1,0,web.dimension-1);

	push	846					; 0000034eH
	mov	DWORD PTR _metric_partial, eax
	mov	eax, DWORD PTR _web+620
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	dec	eax
	push	eax
	push	esi
	push	eax
	push	esi
	call	_kb_dmatrix
	add	esp, 76					; 0000004cH
	mov	DWORD PTR _det_array, eax

; 847  :              tok = yylex();

	push	esi

; 848  :              break;

	jmp	$LN589@initialize
$LN300@initialize:

; 849  :              
; 850  :         case KLEIN_METRIC_TOK:
; 851  :              klein_metric_flag = 1;

	mov	eax, 1
	mov	DWORD PTR _klein_metric_flag, eax

; 852  :              web.metric_flag = 1;

	mov	DWORD PTR _web+1676, eax

; 853  :              tok = yylex();
; 854  :              break;

	jmp	$LN89@initialize
$LN299@initialize:

; 855  :           
; 856  :         case METRIC_TOK:  /* have background metric on domain */
; 857  :              web.metric_flag = 1;

	mov	eax, 1
	mov	DWORD PTR _web+1676, eax

; 858  :              recovery_flag = 0;

	xor	edi, edi

; 859  :              lists_flag = LISTS_SOME;

	mov	DWORD PTR _lists_flag, eax

; 860  :              uminus_flag = 1;

	mov	DWORD PTR _uminus_flag, eax

; 861  :              for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	mov	DWORD PTR _recovery_flag, edi
	cmp	eax, edi
	jle	SHORT $LN296@initialize

; 855  :           
; 856  :         case METRIC_TOK:  /* have background metric on domain */
; 857  :              web.metric_flag = 1;

	mov	DWORD PTR tv3917[ebp], OFFSET _web+1708
$LL298@initialize:

; 862  :                 for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN297@initialize
	mov	ebx, DWORD PTR tv3917[ebp]
	npad	3
$LL295@initialize:

; 863  :                 { 
; 864  :                   esize = exparse(SDIM,&web.metric[i][j],USERCOPY);

	push	1
	lea	ecx, DWORD PTR [ebx-20]
	push	ecx
	push	eax
	call	_exparse
	add	esp, 12					; 0000000cH

; 865  :                   if ( esize <= 0 )

	test	eax, eax
	jg	SHORT $LN292@initialize

; 866  :                   { sprintf(errmsg,
; 867  :                         "Bad metric g[%d][%d] definition.\n",i,j);

	push	esi
	push	edi
	push	OFFSET ??_C@_0CC@EDNHONDD@Bad?5metric?5g?$FL?$CFd?$FN?$FL?$CFd?$FN?5definition?4@
	push	OFFSET _errmsg
	call	_sprintf

; 868  :                     kb_error(1072,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1072					; 00000430H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN292@initialize:

; 869  :                   }
; 870  :                   sprintf(web.metric[i][j].name,"metric component [%d][%d]",
; 871  :                       i+1,j+1);

	inc	esi
	push	esi
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	OFFSET ??_C@_0BK@OOHCNGCP@metric?5component?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$AA@
	push	ebx
	call	_sprintf
	mov	eax, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	add	ebx, 104				; 00000068H
	cmp	esi, eax
	jl	SHORT $LL295@initialize
$LN297@initialize:

; 861  :              for ( i = 0 ; i < SDIM ; i++ )

	add	DWORD PTR tv3917[ebp], 624		; 00000270H
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL298@initialize
$LN296@initialize:

; 872  :                 }
; 873  :              metric = dmatrix(0,SDIM-1,0,SDIM-1);

	push	873					; 00000369H
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 874  :              metric_partial = dmatrix3(SDIM,SDIM,SDIM);

	push	874					; 0000036aH
	mov	DWORD PTR _metric, eax
	mov	eax, DWORD PTR _web+616
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	push	eax
	push	eax
	push	eax
	call	_kb_dmatrix3

; 875  :              det_array = dmatrix(0,web.dimension-1,0,web.dimension-1);

	push	875					; 0000036bH
	mov	DWORD PTR _metric_partial, eax
	mov	eax, DWORD PTR _web+620
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix
	add	esp, 68					; 00000044H
	mov	DWORD PTR _det_array, eax

; 876  :              lists_flag = LISTS_OFF;

	mov	DWORD PTR _lists_flag, 0

; 877  :              tok = yylex();
; 878  :              break;

	jmp	$LN89@initialize
$LN291@initialize:

; 879  :              
; 880  :         case SYMMETRY_GROUP_TOK:
; 881  :              web.symmetry_flag = 1;
; 882  :              tok = yylex();

	push	0
	mov	DWORD PTR _web+856, 1
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 883  :              if ( tok == QUOTATION_TOK )

	cmp	eax, 309				; 00000135H
	jne	$LN290@initialize

; 884  :              { struct sym_registry *reg;
; 885  :                for ( reg = sym_register ; reg->name != NULL ; reg++ )

	cmp	DWORD PTR _sym_register, 0
	mov	esi, OFFSET _sym_register
	je	SHORT $LN530@initialize
	npad	1
$LL289@initialize:

; 886  :                if ( stricmp(yytext,reg->name) == 0 )

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _yytext
	push	eax
	push	ecx
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN506@initialize

; 884  :              { struct sym_registry *reg;
; 885  :                for ( reg = sym_register ; reg->name != NULL ; reg++ )

	add	esi, 24					; 00000018H
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL289@initialize

; 1705 :     if ( (web.boundaries[i].attr & (CON_ENERGY|CON_CONTENT)) 
; 1706 :                  && !everything_quantities_flag  )

	jmp	SHORT $LN530@initialize
$LN506@initialize:

; 887  :                { symmetry_name = reg->name;
; 888  :                  sym_wrap = reg->wrapper;

	mov	edx, DWORD PTR [esi+8]

; 889  :                  sym_form_pullback = reg->pullback;

	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _sym_wrap, edx

; 890  :                  sym_inverse = reg->inverse;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR _sym_form_pullback, ecx

; 891  :                  sym_compose = reg->compose;

	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _sym_inverse, edx

; 892  :                  sym_flags = reg->flags;

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _symmetry_name, eax
	mov	DWORD PTR _sym_compose, ecx
	mov	DWORD PTR _sym_flags, edx

; 893  :                  break;
; 894  :                }
; 895  :                if ( reg->name == NULL ) /* search failed */

	test	eax, eax
	jne	SHORT $LN285@initialize
$LN530@initialize:

; 896  :                { sprintf(errmsg,
; 897  :                    "Symmetry name '%s' not found in registry.c \n", yytext);

	mov	eax, DWORD PTR _yytext
	push	eax
	push	OFFSET ??_C@_0CN@IJOKADDI@Symmetry?5name?5?8?$CFs?8?5not?5found?5in?5@
	push	OFFSET _errmsg
	call	_sprintf

; 898  :                  kb_error(1073,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1073					; 00000431H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN285@initialize:

; 899  :                }
; 900  :                if ( stricmp(yytext,"torus")==0 ) torus_period_init();

	mov	ecx, DWORD PTR _yytext
	push	OFFSET ??_C@_05FCPCBJIO@torus?$AA@
	push	ecx
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN284@initialize
	call	_torus_period_init
$LN284@initialize:

; 901  :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	mov	DWORD PTR _recovery_flag, 0
	jmp	$LN548@initialize
$LN290@initialize:

; 902  :              }
; 903  :              else
; 904  :                kb_error(1074,"Missing symmetry group name.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BO@DILGNDHE@Missing?5symmetry?5group?5name?4?6?$AA@
	push	1074					; 00000432H

; 905  :              recovery_flag = 0;
; 906  :              break;

	jmp	$LN592@initialize
$LN282@initialize:

; 907  : 
; 908  : 
; 909  :         case TORUS_TOK:
; 910  :              web.torus_flag = 1;

	mov	eax, 1
	mov	DWORD PTR _web+860, eax

; 911  :              web.symmetry_flag = 1;

	mov	DWORD PTR _web+856, eax

; 912  :              sym_wrap = torus_wrap;

	mov	DWORD PTR _sym_wrap, OFFSET _torus_wrap

; 913  :              sym_form_pullback = torus_form_pullback;

	mov	DWORD PTR _sym_form_pullback, OFFSET _torus_form_pullback

; 914  :              sym_inverse = torus_inverse;

	mov	DWORD PTR _sym_inverse, OFFSET _torus_inverse

; 915  :              sym_compose = torus_compose;

	mov	DWORD PTR _sym_compose, OFFSET _torus_compose

; 916  :              torus_period_init();

	call	_torus_period_init

; 917  :              sym_flags = 0;

	xor	esi, esi

; 918  :              tok = yylex();

	push	esi
	mov	DWORD PTR _sym_flags, esi
	call	_kb_yylex

; 919  :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 920  :              break;

	jmp	$LN584@initialize
$LN281@initialize:

; 921  : 
; 922  :         case TORUS_FILLED_TOK:
; 923  :              web.torus_flag = 1;

	mov	esi, 1

; 924  :              web.symmetry_flag = 1;
; 925  :              sym_wrap = torus_wrap;
; 926  :              sym_form_pullback = torus_form_pullback;
; 927  :              sym_inverse = torus_inverse;
; 928  :              sym_compose = torus_compose;
; 929  :              sym_flags = 0;

	xor	edi, edi
	mov	DWORD PTR _web+860, esi
	mov	DWORD PTR _web+856, esi
	mov	DWORD PTR _sym_wrap, OFFSET _torus_wrap
	mov	DWORD PTR _sym_form_pullback, OFFSET _torus_form_pullback
	mov	DWORD PTR _sym_inverse, OFFSET _torus_inverse
	mov	DWORD PTR _sym_compose, OFFSET _torus_compose
	mov	DWORD PTR _sym_flags, edi

; 930  :              torus_period_init();

	call	_torus_period_init

; 931  :              web.full_flag = 1;
; 932  :              tok = yylex();

	push	edi
	mov	DWORD PTR _web+864, esi
	call	_kb_yylex

; 933  :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, edi

; 934  :              break;

	jmp	$LN584@initialize
$LN279@initialize:

; 946  : 
; 947  :         case SOAPFILM_TOK:
; 948  :              web.dimension = 2;
; 949  :              web.representation = SOAPFILM;
; 950  :              star_fraction = web.dimension + 1.0;

	fld	QWORD PTR __real@4008000000000000
	mov	eax, 2
	fstp	QWORD PTR _star_fraction
	mov	DWORD PTR _web+620, eax
	mov	DWORD PTR _web+624, eax

; 951  :              tok = yylex();
; 952  :              recovery_flag = 0;
; 953  :              break;

	jmp	$LN272@initialize
$LN265@initialize:

; 987  : 
; 988  :         case LAGRANGE_ORDER_TOK:
; 989  :              if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN264@initialize

; 990  :              { kb_error(2100,"Lagrange order missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BJ@MMMIPAME@Lagrange?5order?5missing?4?6?$AA@
	push	2100					; 00000834H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 991  :                break;

	jmp	$LN548@initialize
$LN264@initialize:

; 992  :              }
; 993  :              if ( addload_flag )

	cmp	DWORD PTR _addload_flag, 0
	je	SHORT $LN547@initialize

; 994  :              { if ( web.modeltype != LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	je	SHORT $LN564@initialize

; 995  :                  kb_error(5345,"addload datafile not in Lagrange mode.\n",
; 996  :                       RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CI@BAGDPBEE@addload?5datafile?5not?5in?5Lagrange@
	push	5345					; 000014e1H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN564@initialize:

; 997  :                if ( web.lagrange_order != yylval.i )

	mov	eax, DWORD PTR _web+632
	mov	ecx, DWORD PTR _yylval
	cmp	eax, ecx
	je	SHORT $LN261@initialize

; 998  :                { sprintf(errmsg,
; 999  :            "addload datafile has different Lagrange order %d, should be %d.\n",
; 1000 : 		           yylval.i,web.lagrange_order);

	push	eax
	push	ecx
	push	OFFSET ??_C@_0EB@JHOGNIBN@addload?5datafile?5has?5different?5L@
	push	OFFSET _errmsg
	call	_sprintf

; 1001 :                  kb_error(5346,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5346					; 000014e2H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN547@initialize:
	mov	ecx, DWORD PTR _yylval
$LN261@initialize:

; 1002 :                }
; 1003 :              }
; 1004 :              switch ( web.modeltype )

	mov	eax, DWORD PTR _web+628
	dec	eax
	je	SHORT $LN258@initialize
	dec	eax
	je	SHORT $LN257@initialize
	dec	eax
	jne	$LN272@initialize

; 1007 :                case LAGRANGE:  lagrange_to_lagrange(yylval.i); break;

	push	ecx
	call	_lagrange_to_lagrange
	add	esp, 4

; 1008 :              }
; 1009 :              tok = yylex();
; 1010 :              recovery_flag = 0;
; 1011 :              break;

	jmp	$LN272@initialize
$LN257@initialize:

; 1006 :                case QUADRATIC: quad_to_lagrange(yylval.i); break;

	push	ecx
	call	_quad_to_lagrange
	add	esp, 4

; 1008 :              }
; 1009 :              tok = yylex();
; 1010 :              recovery_flag = 0;
; 1011 :              break;

	jmp	$LN272@initialize
$LN258@initialize:

; 1005 :              { case LINEAR: linear_to_lagrange(yylval.i); break;

	push	ecx
	call	_linear_to_lagrange
	add	esp, 4

; 1008 :              }
; 1009 :              tok = yylex();
; 1010 :              recovery_flag = 0;
; 1011 :              break;

	jmp	$LN272@initialize
$LN255@initialize:

; 1012 :               
; 1013 :         case SYMMETRIC_CONTENT_TOK:
; 1014 :              web.symmetric_content = 1;

	mov	DWORD PTR _web+808, 1

; 1015 :              tok = yylex();
; 1016 :              recovery_flag = 0;
; 1017 :              break;

	jmp	$LN272@initialize
$LN254@initialize:

; 1018 :               
; 1019 :         case MEAN_CURV_TOK:
; 1020 :              web.area_norm_flag = 1;

	mov	DWORD PTR _web+876, 1

; 1021 :              tok = yylex();
; 1022 :              recovery_flag = 0;
; 1023 :              break;

	jmp	$LN272@initialize
$LN253@initialize:

; 1024 :   
; 1025 :         case BOUNDARY_CURVATURE_TOK:
; 1026 :              boundary_curvature_flag = 1;

	mov	DWORD PTR _boundary_curvature_flag, 1

; 1027 :              tok = yylex();
; 1028 :              recovery_flag = 0;
; 1029 :              break;

	jmp	$LN272@initialize
$LN252@initialize:

; 1030 : 
; 1031 :         case EFFECTIVE_AREA_TOK:
; 1032 :              effective_area_flag = 1;

	mov	DWORD PTR _effective_area_flag, 1

; 1033 :              tok = yylex();
; 1034 :              recovery_flag = 0;
; 1035 :              break;

	jmp	$LN272@initialize
$LN250@initialize:

; 1042 :               
; 1043 : 
; 1044 :         case WULFF_TOK: 
; 1045 :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1046 :              if ( tok == QUOTATION_TOK )

	cmp	eax, 309				; 00000135H
	jne	SHORT $LN249@initialize

; 1047 :              { wulff_initialize(yytext);

	mov	edx, DWORD PTR _yytext
	push	edx
	call	_wulff_initialize

; 1048 :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 8
	mov	DWORD PTR _tok, eax
	mov	DWORD PTR _recovery_flag, 0
	jmp	$LN548@initialize
$LN249@initialize:

; 1049 :              }
; 1050 :              else
; 1051 :                kb_error(1076,"Wulff file name missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BK@DNEHBIJK@Wulff?5file?5name?5missing?4?6?$AA@
	push	1076					; 00000434H

; 1052 :              recovery_flag = 0;
; 1053 :              break;

	jmp	$LN592@initialize
$LN247@initialize:

; 1054 : 
; 1055 :         case PHASEFILE_TOK: 
; 1056 :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1057 :              if ( tok == QUOTATION_TOK )

	cmp	eax, 309				; 00000135H
	jne	SHORT $LN246@initialize

; 1058 :              { phase_initialize(yytext);

	mov	eax, DWORD PTR _yytext
	push	eax
	call	_phase_initialize

; 1059 :                tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 8
	mov	DWORD PTR _tok, eax
	mov	DWORD PTR _recovery_flag, 0
	jmp	$LN548@initialize
$LN246@initialize:

; 1060 :              }
; 1061 :              else
; 1062 :                kb_error(1077,"Cannot find phasefile name.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BN@DMLCKLLD@Cannot?5find?5phasefile?5name?4?6?$AA@
	push	1077					; 00000435H

; 1063 : 
; 1064 :              recovery_flag = 0;
; 1065 :              break;

	jmp	$LN592@initialize
$LN244@initialize:

; 1066 : 
; 1067 :         case TORUS_PERIODS_TOK:
; 1068 :         case PERIODS_TOK:  recovery_flag = 0; 
; 1069 :                 lists_flag = LISTS_SOME;

	mov	eax, 1
	xor	esi, esi
	mov	DWORD PTR _recovery_flag, esi
	mov	DWORD PTR _lists_flag, eax

; 1070 :                 uminus_flag = 1;

	mov	DWORD PTR _uminus_flag, eax

; 1071 :                 read_periods();

	call	_read_periods

; 1072 :                 lists_flag = LISTS_OFF;

	mov	DWORD PTR _lists_flag, esi

; 1073 :                 tok = yylex(); /* lookahead */ 

	push	esi

; 1074 :                 break;

	jmp	$LN589@initialize
$LN243@initialize:

; 1075 : 
; 1076 :         case DISPLAY_PERIODS_TOK:  recovery_flag = 0; 
; 1077 :                 lists_flag = LISTS_SOME;

	mov	eax, 1
	xor	esi, esi
	mov	DWORD PTR _recovery_flag, esi
	mov	DWORD PTR _lists_flag, eax

; 1078 :                 uminus_flag = 1;

	mov	DWORD PTR _uminus_flag, eax

; 1079 :                 read_display_periods();

	call	_read_display_periods

; 1080 :                 lists_flag = LISTS_OFF;

	mov	DWORD PTR _lists_flag, esi

; 1081 :                 tok = yylex(); /* lookahead */ 

	push	esi

; 1082 :                 break;

	jmp	$LN589@initialize
$LN242@initialize:

; 1083 : 
; 1084 :         case DISPLAY_ORIGIN_TOK: 
; 1085 :           {  int n;
; 1086 :              struct global *g ;
; 1087 :              struct array *a;
; 1088 : 
; 1089 :              recovery_flag = 0;

	xor	edi, edi

; 1090 :                               
; 1091 :              n = lookup_global("display_origin");

	push	OFFSET ??_C@_0P@OAMDDONM@display_origin?$AA@
	mov	DWORD PTR _recovery_flag, edi
	call	_lookup_global
	add	esp, 4

; 1092 :              if ( n < 0 )

	cmp	eax, edi
	jge	SHORT $LN241@initialize

; 1093 :                n = add_global("display_origin");

	push	OFFSET ??_C@_0P@OAMDDONM@display_origin?$AA@
	call	_add_global
	add	esp, 4
$LN241@initialize:

; 1094 :              g = globals(n);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN420@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN422@initialize
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	mov	esi, eax
	jmp	SHORT $LN421@initialize
$LN422@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN420@initialize
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN421@initialize
$LN420@initialize:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax]
$LN421@initialize:

; 1095 :              g->flags |= INTERNAL_NAME|ARRAY_PARAM|RECALC_PARAMETER|ALWAYS_RECALC;

	or	DWORD PTR [esi+192], 138414088		; 08400808H

; 1096 :              a = g->attr.arrayptr = (struct array*)mycalloc(1,
; 1097 :                      sizeof(struct array)+sizeof(int));

	push	1097					; 00000449H
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	push	60					; 0000003cH
	mov	ebx, 1
	push	ebx
	call	_kb_calloc
	mov	DWORD PTR [esi+168], eax

; 1098 :              a->dim = 1;

	mov	DWORD PTR [eax+4], ebx

; 1099 :              a->itemsize = sizeof(REAL);

	mov	DWORD PTR [eax+12], 8

; 1100 :              a->datatype = REAL_TYPE;

	mov	DWORD PTR [eax+8], ebx

; 1101 :              a->datacount = SDIM*sizeof(REAL);

	mov	ecx, DWORD PTR _web+616
	lea	edx, DWORD PTR [ecx*8]
	mov	DWORD PTR [eax+16], edx

; 1102 :              a->sizes[0] = SDIM;

	mov	ecx, DWORD PTR _web+616

; 1103 :              a->datastart = (char*)web.display_origin-(char*)a;

	mov	edx, OFFSET _web+1624
	sub	edx, eax
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+20], edx
	add	esp, 16					; 00000010H

; 1104 : 
; 1105 :              lists_flag = LISTS_SOME;
; 1106 :              uminus_flag = 1;
; 1107 :              lists_flag = LISTS_OFF;
; 1108 :              for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	mov	DWORD PTR _uminus_flag, ebx
	mov	DWORD PTR _lists_flag, edi
	cmp	DWORD PTR _web+616, edi
	jle	$LN89@initialize

; 1095 :              g->flags |= INTERNAL_NAME|ARRAY_PARAM|RECALC_PARAMETER|ALWAYS_RECALC;

	mov	edi, OFFSET _web+1624
$LL240@initialize:

; 1109 :              { if ( read_const(&web.display_origin[i]) <= 0 )

	push	edi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN507@initialize

; 1104 : 
; 1105 :              lists_flag = LISTS_SOME;
; 1106 :              uminus_flag = 1;
; 1107 :              lists_flag = LISTS_OFF;
; 1108 :              for ( i = 0 ; i < SDIM ; i++ )

	add	esi, ebx
	add	edi, 8
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL240@initialize

; 1705 :     if ( (web.boundaries[i].attr & (CON_ENERGY|CON_CONTENT)) 
; 1706 :                  && !everything_quantities_flag  )

	jmp	$LN89@initialize
$LN507@initialize:

; 1110 :                  { kb_error(3861,"Not enough values for display_origin.\n",
; 1111 :                      DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CH@MIIDBODK@Not?5enough?5values?5for?5display_or@
	push	3861					; 00000f15H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1112 :                    break;
; 1113 :                  }
; 1114 :              }
; 1115 :              if ( i >= SDIM ) tok = yylex();  /* lookahead */

	cmp	esi, DWORD PTR _web+616
	jl	$LN548@initialize

; 1116 :           }
; 1117 :              break;

	jmp	$LN89@initialize
$LN225@initialize:

; 1138 : 
; 1139 :         case VIEW_TRANSFORM_GENS_TOK: recovery_flag = 0; 
; 1140 :              uminus_flag = 1;
; 1141 :              read_transform_generators(0); break;

	push	0
	mov	DWORD PTR _recovery_flag, 0
	mov	DWORD PTR _uminus_flag, 1
	call	_read_transform_generators
	jmp	$LN586@initialize
$LN224@initialize:

; 1142 : 
; 1143 :         case CLIP_COEFF_TOK:
; 1144 :              tok = yylex();  /* eat clip_coeff */

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1145 :              if ( tok != '=' && tok != ASSIGN_TOK )

	cmp	eax, 61					; 0000003dH
	je	SHORT $LN223@initialize
	cmp	eax, 441				; 000001b9H
	je	SHORT $LN223@initialize

; 1146 :                kb_error(3441,"clip_coeff initializer missing '='.\n",
; 1147 :                   DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CF@FBNOILCH@clip_coeff?5initializer?5missing?5?8@
	push	3441					; 00000d71H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN223@initialize:

; 1148 :              read_array_initializer(perm_globals(clip_coeff_global)->attr.arrayptr); 

	mov	eax, DWORD PTR _clip_coeff_global
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+168]
	push	eax
	call	_read_array_initializer

; 1149 :              clip_coeff_set_flag = 1;

	mov	DWORD PTR _clip_coeff_set_flag, 1

; 1150 :              break;

	jmp	$LN586@initialize
$LN222@initialize:

; 1151 : 
; 1152 :         case SLICE_COEFF_TOK:
; 1153 :              tok = yylex();  /* eat clip_coeff */

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1154 :              if ( tok != '=' && tok != ASSIGN_TOK )

	cmp	eax, 61					; 0000003dH
	je	SHORT $LN221@initialize
	cmp	eax, 441				; 000001b9H
	je	SHORT $LN221@initialize

; 1155 :                kb_error(1910,"clip_coeff initializer missing '='.\n",
; 1156 :                   DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CF@FBNOILCH@clip_coeff?5initializer?5missing?5?8@
	push	1910					; 00000776H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN221@initialize:

; 1157 :              read_array_initializer(perm_globals(slice_coeff_global)->attr.arrayptr); 

	mov	ecx, DWORD PTR _slice_coeff_global
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+168]
	push	ecx
	call	_read_array_initializer

; 1158 :              slice_coeff_set_flag = 1;

	mov	DWORD PTR _slice_coeff_set_flag, 1

; 1159 :              break;

	jmp	$LN586@initialize
$LN220@initialize:

; 1160 : 
; 1161 : 
; 1162 :         case PARAMETERS_TOK:  recovery_flag = 0; uminus_flag = 0; 

	xor	eax, eax
	mov	DWORD PTR _recovery_flag, eax
	mov	DWORD PTR _uminus_flag, eax

; 1163 :              read_parameter(); break;

	call	_read_parameter
	jmp	$LN548@initialize
$LN214@initialize:

; 1193 : 
; 1194 :         case SURFACE_ENERGY_TOK: recovery_flag = 0; uminus_flag = 0; 

	xor	eax, eax
	mov	DWORD PTR _recovery_flag, eax
	mov	DWORD PTR _uminus_flag, eax

; 1195 :              read_surface_energy(); break;

	call	_read_surface_energy
	jmp	$LN548@initialize
$LN203@initialize:

; 1228 : 
; 1229 :         case HOMOTHETY_TOK:
; 1230 :              web.homothety = 1;
; 1231 :              uminus_flag = 0;
; 1232 :              if ( read_const(&homothety_target) <= 0 )

	push	OFFSET _homothety_target
	mov	DWORD PTR _web+904, 1
	mov	DWORD PTR _uminus_flag, 0
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	$LN89@initialize

; 1233 :                 homothety_target = 1.0; 

	fld1
	fstp	QWORD PTR _homothety_target
	jmp	$LN548@initialize
$LN200@initialize:

; 1234 :              else tok = yylex();
; 1235 :              break;
; 1236 : 
; 1237 :         case AUTOPOP_TOK:
; 1238 :              autopop_flag = 1;

	mov	DWORD PTR _autopop_flag, 1

; 1239 :              tok = yylex();
; 1240 :              recovery_flag = 0;
; 1241 :              break;

	jmp	$LN272@initialize
$LN199@initialize:

; 1242 :               
; 1243 :         case IMMEDIATE_AUTOPOP_TOK:
; 1244 :              immediate_autopop_flag = 1;

	mov	DWORD PTR _immediate_autopop_flag, 1

; 1245 :              tok = yylex();
; 1246 :              recovery_flag = 0;
; 1247 :              break;

	jmp	$LN272@initialize
$LN198@initialize:

; 1248 :               
; 1249 :         case AUTOPOP_QUARTIC_TOK:
; 1250 :              autopop_quartic_flag = 1;

	mov	DWORD PTR _autopop_quartic_flag, 1

; 1251 :              tok = yylex();
; 1252 :              recovery_flag = 0;
; 1253 :              break;

	jmp	$LN272@initialize
$LN193@initialize:

; 1266 :              
; 1267 :         case APPROX_CURV_TOK:
; 1268 :              approx_curve_flag = 1;

	mov	DWORD PTR _approx_curve_flag, 1

; 1269 :              tok = yylex();
; 1270 :              recovery_flag = 0;
; 1271 :              break;

	jmp	$LN272@initialize
$LN192@initialize:

; 1272 : 
; 1273 :         case CONDUCTING_KNOT_ENERGY_TOK:
; 1274 :              { tok = yylex();

	xor	esi, esi
	push	esi
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1275 :                if ( tok != MODULUS_TOK ) 

	cmp	eax, 473				; 000001d9H
	je	SHORT $LN191@initialize

; 1276 :                  unput_tok();

	call	_unput_tok
$LN191@initialize:

; 1277 :                uminus_flag = 0;
; 1278 :                if (read_const(&modulus) <= 0) modulus = 1.0;

	lea	edx, DWORD PTR _modulus$[ebp]
	push	edx
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN190@initialize
	fld1
	fstp	QWORD PTR _modulus$[ebp]
	jmp	SHORT $LN189@initialize
$LN190@initialize:

; 1279 :                else tok = yylex();

	push	esi
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN189@initialize:

; 1280 :                add_standard_quantity("knot_energy",modulus);

	fld	QWORD PTR _modulus$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0M@BGBMOCLO@knot_energy?$AA@
	call	_add_standard_quantity
	add	esp, 12					; 0000000cH

; 1281 :                recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 1282 :                break;

	jmp	$LN548@initialize
$LN188@initialize:

; 1283 :              }
; 1284 :              
; 1285 :         case INSULATING_KNOT_ENERGY_TOK:
; 1286 :               { tok = yylex();

	xor	esi, esi
	push	esi
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1287 :                 if ( tok != MODULUS_TOK ) 

	cmp	eax, 473				; 000001d9H
	je	SHORT $LN187@initialize

; 1288 :                   unput_tok();

	call	_unput_tok
$LN187@initialize:

; 1289 :                 uminus_flag = 0;
; 1290 :                 if (read_const(&modulus) <= 0) modulus = 1.0;

	lea	eax, DWORD PTR _modulus$[ebp]
	push	eax
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN186@initialize
	fld1
	fstp	QWORD PTR _modulus$[ebp]
	jmp	SHORT $LN185@initialize
$LN186@initialize:

; 1291 :                 else tok = yylex();

	push	esi
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN185@initialize:

; 1292 :                 add_standard_quantity("uniform_knot_energy",modulus);

	fld	QWORD PTR _modulus$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BE@LOBABENM@uniform_knot_energy?$AA@
	call	_add_standard_quantity
	add	esp, 12					; 0000000cH

; 1293 :                 recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 1294 :                 break;

	jmp	$LN548@initialize
$LN184@initialize:

; 1295 :               }
; 1296 :              
; 1297 :         case MEAN_CURV_INT_TOK:
; 1298 :              mean_curv_int_flag = 1;
; 1299 :              mean_curvature_param = lookup_global("mean_curvature_modulus");

	push	OFFSET ??_C@_0BH@HGNBHJNG@mean_curvature_modulus?$AA@
	mov	DWORD PTR _mean_curv_int_flag, 1
	call	_lookup_global

; 1300 :              if ( mean_curvature_param < 0 )

	xor	esi, esi
	add	esp, 4
	mov	DWORD PTR _mean_curvature_param, eax
	cmp	eax, esi
	jge	SHORT $LN183@initialize

; 1301 :                 mean_curvature_param = add_global("mean_curvature_modulus");

	push	OFFSET ??_C@_0BH@HGNBHJNG@mean_curvature_modulus?$AA@
	call	_add_global
	add	esp, 4
	mov	DWORD PTR _mean_curvature_param, eax
$LN183@initialize:

; 1302 :              globals(mean_curvature_param)->flags |= 
; 1303 :                              ORDINARY_PARAM | RECALC_PARAMETER | ALWAYS_RECALC;

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN426@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN428@initialize
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN427@initialize
$LN428@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN426@initialize
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN427@initialize
$LN426@initialize:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN427@initialize:
	or	DWORD PTR [eax+192], 134217737		; 08000009H

; 1304 :              uminus_flag = 0;
; 1305 :              if ( read_const(&globals(mean_curvature_param)->value.real) <= 0 )

	mov	eax, DWORD PTR _mean_curvature_param
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	mov	DWORD PTR _uminus_flag, esi
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN432@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN434@initialize
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN433@initialize
$LN434@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN432@initialize
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN433@initialize
$LN432@initialize:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN433@initialize:
	add	eax, 64					; 00000040H
	push	eax
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN182@initialize

; 1306 :              { kb_error(1081,"Missing integral mean curvature modulus value.\nSyntax: mean_curvature_integral: modulus",WARNING);

	push	2
	push	OFFSET ??_C@_0FI@LKAHFFEK@Missing?5integral?5mean?5curvature?5@
	push	1081					; 00000439H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1307 :                 if ( tok == MEAN_CURV_INT_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 35043			; 000088e3H
	jne	SHORT $LN180@initialize
$LN182@initialize:

; 1308 :              }
; 1309 :              else tok = yylex();

	push	esi
	call	_kb_yylex
	mov	DWORD PTR _tok, eax
	add	esp, 4
$LN180@initialize:

; 1310 :              if ( web.representation != SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	je	SHORT $LN179@initialize

; 1311 :                   kb_error(1082,"Can do integral of mean curvature only in SOAPFILM model.\n",
; 1312 :                      DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DL@CJGMDKOF@Can?5do?5integral?5of?5mean?5curvatur@
	push	1082					; 0000043aH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN179@initialize:

; 1313 :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 1314 :              break;

	jmp	$LN548@initialize
$LN178@initialize:

; 1315 : 
; 1316 :         case GAUSS_CURVATURE_TOK:
; 1317 :               { tok = yylex();

	xor	esi, esi
	push	esi
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1318 :                 if ( tok != MODULUS_TOK ) 

	cmp	eax, 473				; 000001d9H
	je	SHORT $LN177@initialize

; 1319 :                   unput_tok();

	call	_unput_tok
$LN177@initialize:

; 1320 :                 uminus_flag = 0;
; 1321 :                 if (read_const(&modulus) <= 0) modulus = 1.0;

	lea	ecx, DWORD PTR _modulus$[ebp]
	push	ecx
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN176@initialize
	fld1
	fstp	QWORD PTR _modulus$[ebp]
	jmp	SHORT $LN175@initialize
$LN176@initialize:

; 1322 :                 else tok = yylex();

	push	esi
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN175@initialize:

; 1323 :                 if ( (web.representation != SOAPFILM) )

	cmp	DWORD PTR _web+624, 2
	je	SHORT $LN174@initialize

; 1324 :                   kb_error(1083,"Can do gauss curvature only in SOAPFILM model.\n",
; 1325 :                      DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DA@FONHHPKP@Can?5do?5gauss?5curvature?5only?5in?5S@
	push	1083					; 0000043bH
	call	_kb_error

; 1326 :                 else add_standard_quantity("gauss_curvature_integral",modulus);

	add	esp, 12					; 0000000cH

; 1327 :                 recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 1328 :                 break;

	jmp	$LN548@initialize
$LN174@initialize:

; 1326 :                 else add_standard_quantity("gauss_curvature_integral",modulus);

	fld	QWORD PTR _modulus$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BJ@PHNDOFLD@gauss_curvature_integral?$AA@
	call	_add_standard_quantity
	add	esp, 12					; 0000000cH

; 1327 :                 recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 1328 :                 break;

	jmp	$LN548@initialize
$LN172@initialize:

; 1329 :               }
; 1330 :              
; 1331 :         case SQGAUSS_TOK:
; 1332 :              sqgauss_flag = 1;
; 1333 :              sqgauss_param = lookup_global("square_gauss_modulus");

	push	OFFSET ??_C@_0BF@MCIHOOCD@square_gauss_modulus?$AA@
	mov	DWORD PTR _sqgauss_flag, 1
	call	_lookup_global

; 1334 :              if (sqgauss_param < 0 )

	xor	esi, esi
	add	esp, 4
	mov	DWORD PTR _sqgauss_param, eax
	cmp	eax, esi
	jge	SHORT $LN171@initialize

; 1335 :                sqgauss_param = add_global("square_gauss_modulus");

	push	OFFSET ??_C@_0BF@MCIHOOCD@square_gauss_modulus?$AA@
	call	_add_global
	add	esp, 4
	mov	DWORD PTR _sqgauss_param, eax
$LN171@initialize:

; 1336 :              globals(sqgauss_param)->flags |= ORDINARY_PARAM | RECALC_PARAMETER | ALWAYS_RECALC;

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN438@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN440@initialize
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN439@initialize
$LN440@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN438@initialize
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN439@initialize
$LN438@initialize:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN439@initialize:
	or	DWORD PTR [eax+192], 134217737		; 08000009H

; 1337 :              uminus_flag = 0;
; 1338 :              if ( read_const(&globals(sqgauss_param)->value.real) <= 0 )

	mov	eax, DWORD PTR _sqgauss_param
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	mov	DWORD PTR _uminus_flag, esi
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN444@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN446@initialize
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN445@initialize
$LN446@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN444@initialize
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN445@initialize
$LN444@initialize:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN445@initialize:
	add	eax, 64					; 00000040H
	push	eax
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN170@initialize

; 1339 :              { kb_error(1084,"Missing square gaussian modulus value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CI@NKIKIKPL@Missing?5square?5gaussian?5modulus?5@
	push	1084					; 0000043cH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1340 :                if ( tok == SQGAUSS_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 35047			; 000088e7H
	jne	SHORT $LN168@initialize
$LN170@initialize:

; 1341 :              }
; 1342 :              else tok = yylex();

	push	esi
	call	_kb_yylex
	mov	DWORD PTR _tok, eax
	add	esp, 4
$LN168@initialize:

; 1343 :              if ( web.representation != SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	je	$LN179@initialize

; 1344 :                kb_error(1085,
; 1345 :                    "Can do square gauss curvature only in SOAPFILM model.\n",
; 1346 :                      DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DH@EKACIEOJ@Can?5do?5square?5gauss?5curvature?5on@
	push	1085					; 0000043dH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1347 :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 1348 :              break;

	jmp	$LN548@initialize
$LN166@initialize:

; 1349 : 
; 1350 :         case SQUARE_CURVATURE_TOK:
; 1351 :              square_curvature_flag = 1;
; 1352 :              square_curvature_param = lookup_global("sq_curvature_modulus");

	push	OFFSET ??_C@_0BF@ODONALIB@sq_curvature_modulus?$AA@
	mov	DWORD PTR _square_curvature_flag, 1
	call	_lookup_global

; 1353 :              if ( square_curvature_param < 0 )

	xor	esi, esi
	add	esp, 4
	mov	DWORD PTR _square_curvature_param, eax
	cmp	eax, esi
	jge	SHORT $LN165@initialize

; 1354 :                square_curvature_param = add_global("sq_curvature_modulus");

	push	OFFSET ??_C@_0BF@ODONALIB@sq_curvature_modulus?$AA@
	call	_add_global
	add	esp, 4
	mov	DWORD PTR _square_curvature_param, eax
$LN165@initialize:

; 1355 :              globals(square_curvature_param)->flags |= 
; 1356 :                                   ORDINARY_PARAM | RECALC_PARAMETER | ALWAYS_RECALC;

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN450@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN452@initialize
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN451@initialize
$LN452@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN450@initialize
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN451@initialize
$LN450@initialize:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN451@initialize:
	or	DWORD PTR [eax+192], 134217737		; 08000009H

; 1357 :              uminus_flag = 0;
; 1358 :              if ( read_const(&globals(square_curvature_param)->value.real) <= 0 )

	mov	eax, DWORD PTR _square_curvature_param
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	mov	DWORD PTR _uminus_flag, esi
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN456@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN458@initialize
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN457@initialize
$LN458@initialize:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN456@initialize
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN457@initialize
$LN456@initialize:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN457@initialize:
	add	eax, 64					; 00000040H
	push	eax
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	$LN206@initialize

; 1359 :              { kb_error(1086,"Missing square curvature modulus value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CJ@EADLCLOO@Missing?5square?5curvature?5modulus@
	push	1086					; 0000043eH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1360 :                if ( tok == SQUARE_CURVATURE_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 35045			; 000088e5H

; 1361 :              }
; 1362 :              else tok = yylex();
; 1363 :              recovery_flag = 0;
; 1364 :              break;

	jmp	$LN599@initialize
$LN161@initialize:

; 1365 : 
; 1366 :         case NORMAL_CURVATURE_TOK:
; 1367 :              normal_curvature_flag = 1;

	mov	DWORD PTR _normal_curvature_flag, 1

; 1368 :              tok = yylex();
; 1369 :              break;

	jmp	$LN89@initialize
$LN160@initialize:

; 1370 : 
; 1371 :         case MOBILITY_TOK:
; 1372 :              recovery_flag = 0;
; 1373 :              uminus_flag = 0;
; 1374 :              esize = exparse(SDIM,&mobility_formula,USERCOPY);

	mov	edx, DWORD PTR _web+616
	push	1
	xor	edi, edi
	push	OFFSET _mobility_formula
	push	edx
	mov	DWORD PTR _recovery_flag, edi
	mov	DWORD PTR _uminus_flag, edi
	call	_exparse

; 1375 :              sprintf(mobility_formula.name,"mobility formula");

	push	OFFSET ??_C@_0BB@OCMPBOEO@mobility?5formula?$AA@
	push	OFFSET _mobility_formula+20
	mov	esi, eax
	call	_sprintf

; 1376 :              tok = yylex();

	push	edi
	call	_kb_yylex
	add	esp, 24					; 00000018H
	mov	DWORD PTR _tok, eax

; 1377 :              if ( esize <= 0 )

	cmp	esi, edi
	jg	SHORT $LN159@initialize

; 1378 :                 kb_error(1087,"Bad mobility definition.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BK@IDOKOAMM@Bad?5mobility?5definition?4?6?$AA@
	push	1087					; 0000043fH
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	$LN548@initialize
$LN159@initialize:

; 1379 :              else mobility_flag = 1; 

	mov	DWORD PTR _mobility_flag, 1

; 1380 :              break;

	jmp	$LN548@initialize
$LN157@initialize:

; 1381 :              
; 1382 :         case MOBILITY_TENSOR_TOK:
; 1383 :              mobility_flag = 1;

	mov	eax, 1
	mov	DWORD PTR _mobility_flag, eax

; 1384 :              mobility_tensor_flag = 1;

	mov	DWORD PTR _mobility_tensor_flag, eax

; 1385 :              recovery_flag = 0;

	xor	edi, edi

; 1386 :              lists_flag = LISTS_SOME;

	mov	DWORD PTR _lists_flag, eax

; 1387 :              uminus_flag = 1;

	mov	DWORD PTR _uminus_flag, eax

; 1388 :              for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	mov	DWORD PTR _recovery_flag, edi
	cmp	eax, edi
	jle	SHORT $LN154@initialize

; 1381 :              
; 1382 :         case MOBILITY_TENSOR_TOK:
; 1383 :              mobility_flag = 1;

	mov	DWORD PTR tv3974[ebp], OFFSET _mobility_tensor+20
$LL156@initialize:

; 1389 :                 for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN155@initialize
	mov	ebx, DWORD PTR tv3974[ebp]
$LL153@initialize:

; 1390 :                 { esize = exparse(SDIM,&mobility_tensor[i][j],USERCOPY);

	push	1
	lea	ecx, DWORD PTR [ebx-20]
	push	ecx
	push	eax
	call	_exparse
	add	esp, 12					; 0000000cH

; 1391 :                   if ( esize <= 0 )

	test	eax, eax
	jg	SHORT $LN150@initialize

; 1392 :                   { sprintf(errmsg,
; 1393 :                        "Bad mobility_tensor[%d][%d] definition.\n",i,j);

	push	esi
	push	edi
	push	OFFSET ??_C@_0CJ@EAPHMDEP@Bad?5mobility_tensor?$FL?$CFd?$FN?$FL?$CFd?$FN?5defi@
	push	OFFSET _errmsg
	call	_sprintf

; 1394 :                     kb_error(1088,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1088					; 00000440H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN150@initialize:

; 1395 :                   }
; 1396 :                   sprintf(mobility_tensor[i][j].name,
; 1397 :                     "mobility tensor component [%d][%d]",i+1,j+1);

	inc	esi
	push	esi
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	OFFSET ??_C@_0CD@IDOBCKPD@mobility?5tensor?5component?5?$FL?$CFd?$FN?$FL?$CF@
	push	ebx
	call	_sprintf
	mov	eax, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	add	ebx, 104				; 00000068H
	cmp	esi, eax
	jl	SHORT $LL153@initialize
$LN155@initialize:

; 1388 :              for ( i = 0 ; i < SDIM ; i++ )

	add	DWORD PTR tv3974[ebp], 624		; 00000270H
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL156@initialize
$LN154@initialize:

; 1398 :                 }
; 1399 :              lists_flag = LISTS_OFF;

	mov	DWORD PTR _lists_flag, 0

; 1400 :              tok = yylex();
; 1401 :              break;

	jmp	$LN89@initialize
$LN149@initialize:

; 1402 :              
; 1403 :         case RUNGE_KUTTA_TOK: runge_kutta_flag = 1; tok = yylex(); break;

	mov	DWORD PTR _runge_kutta_flag, 1
	jmp	$LN89@initialize
$LN148@initialize:

; 1404 : 
; 1405 :         case SCALE_LIMIT_TOK:
; 1406 :              uminus_flag = 0;

	xor	esi, esi

; 1407 :              if ( read_const(&web.maxscale) <= 0 )

	push	OFFSET _web+1528
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	$LN206@initialize

; 1408 :              { kb_error(1089,"Missing SCALE_LIMIT value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BM@CEOHDAHL@Missing?5SCALE_LIMIT?5value?4?6?$AA@
	push	1089					; 00000441H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1409 :                if ( tok == SCALE_LIMIT_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 35075			; 00008903H

; 1410 :              }
; 1411 :              else tok = yylex();
; 1412 :              recovery_flag = 0;
; 1413 :              break;

	jmp	$LN599@initialize
$LN144@initialize:

; 1414 : 
; 1415 :         case TOTAL_TIME_TOK:
; 1416 :              uminus_flag = 0;

	xor	esi, esi

; 1417 :              if ( read_const(&total_time) <= 0 )

	push	OFFSET _total_time
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	$LN206@initialize

; 1418 :              { kb_error(1090,"Missing TOTAL_TIME value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BL@BNFBILLP@Missing?5TOTAL_TIME?5value?4?6?$AA@
	push	1090					; 00000442H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1419 :                 if ( tok == TOTAL_TIME_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 35040			; 000088e0H

; 1420 :              }
; 1421 :              else tok = yylex();
; 1422 :              recovery_flag = 0;
; 1423 :              break;

	jmp	$LN599@initialize
$LN140@initialize:

; 1424 : 
; 1425 :         case ZOOM_RADIUS_TOK:
; 1426 :              uminus_flag = 0;

	xor	esi, esi

; 1427 :              if ( read_const(&web.zoom_radius) <= 0 )

	push	OFFSET _web+984
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	$LN206@initialize

; 1428 :              { kb_error(1091,"Missing ZOOM RADIUS value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BM@KIOPFAJA@Missing?5ZOOM?5RADIUS?5value?4?6?$AA@
	push	1091					; 00000443H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1429 :                if ( tok == ZOOM_RADIUS_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 35076			; 00008904H

; 1430 :              }
; 1431 :              else tok = yylex();
; 1432 :              recovery_flag = 0;
; 1433 :              break;

	jmp	$LN599@initialize
$LN136@initialize:

; 1434 : 
; 1435 :         case ZOOM_VERTEX_TOK:
; 1436 :              tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1437 :              if ( tok != INTEGER_TOK )

	cmp	eax, 265				; 00000109H
	je	SHORT $LN135@initialize

; 1438 :                 kb_error(1092,"Missing ZOOM VERTEX number.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BN@PPLFNOLF@Missing?5ZOOM?5VERTEX?5number?4?6?$AA@
	push	1092					; 00000444H
	jmp	$LN592@initialize
$LN135@initialize:

; 1439 :              else { zoom_number = yylval.i; tok = yylex(); }

	mov	eax, DWORD PTR _yylval
	push	0
	mov	DWORD PTR _zoom_number, eax
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
	mov	DWORD PTR _recovery_flag, 0
	jmp	$LN548@initialize
$LN121@initialize:

; 1489 :               }
; 1490 :              else {  web.gauss2D_order = yylval.i; 
; 1491 :                      set_by_user_gauss_2D = web.gauss2D_order;
; 1492 :                   }
; 1493 :              tok = yylex();
; 1494 :              recovery_flag = 0;
; 1495 :              break;
; 1496 : 
; 1497 :         case CONSTRAINT_TOLERANCE_TOK:
; 1498 :              uminus_flag = 0;

	xor	esi, esi

; 1499 :              if ( read_const(&web.tolerance) <= 0 )

	push	OFFSET _web+752
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN120@initialize

; 1500 :              { kb_error(1099,"Missing CONSTRAINT_TOLERANCE value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CF@NPCHGACN@Missing?5CONSTRAINT_TOLERANCE?5val@
	push	1099					; 0000044bH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1501 :                if ( tok == CONSTRAINT_TOLERANCE_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 35078			; 00008906H
	jne	SHORT $LN118@initialize
$LN120@initialize:

; 1502 :              }
; 1503 :              else tok = yylex();

	push	esi
	call	_kb_yylex
	mov	DWORD PTR _tok, eax
	add	esp, 4
$LN118@initialize:

; 1504 :              if ( web.tolerance <= 0.0 )

	fldz
	fcomp	QWORD PTR _web+752
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN117@initialize

; 1505 :              { kb_error(2102,"Tolerance must be positive.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BN@DLJCKBBD@Tolerance?5must?5be?5positive?4?6?$AA@
	push	2102					; 00000836H
	call	_kb_error

; 1506 :                web.tolerance = DEFAULT_TOLERANCE;

	fld	QWORD PTR __real@3d719799812dea11
	fstp	QWORD PTR _web+752
	add	esp, 12					; 0000000cH
$LN117@initialize:

; 1507 :              }
; 1508 :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 1509 :              break;

	jmp	$LN548@initialize
$LN116@initialize:

; 1510 : 
; 1511 :         case MERITFACTOR_TOK:
; 1512 :              uminus_flag = 0;

	xor	esi, esi

; 1513 :              if ( read_const(&web.meritfactor) <= 0 )

	push	OFFSET _web+816
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	$LN115@initialize

; 1514 :                 kb_error(1100,"Missing MERIT FACTOR value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BN@NGGEHPKJ@Missing?5MERIT?5FACTOR?5value?4?6?$AA@
	push	1100					; 0000044cH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1553 :              }
; 1554 :              recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, esi

; 1555 :              break;

	jmp	$LN548@initialize
$LN113@initialize:

; 1515 :              else tok = yylex();
; 1516 :              recovery_flag = 0;
; 1517 :              break;
; 1518 : 
; 1519 :         case GRAV_CONST_TOK:
; 1520 :              uminus_flag = 0;

	xor	esi, esi

; 1521 :              if ( read_const(&web.grav_const) <= 0 )

	push	OFFSET _web+832
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN112@initialize

; 1522 :              { kb_error(1101,"Missing GRAVITY_CONSTANT value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CB@ELBPBAMK@Missing?5GRAVITY_CONSTANT?5value?4?6@
	push	1101					; 0000044dH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1523 :                if ( tok == GRAV_CONST_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 35080			; 00008908H

; 1524 :              }
; 1525 :              else 

	jmp	$LN599@initialize
$LN112@initialize:

; 1526 :              { if ( web.grav_const != 0.0 )  web.gravflag = 1;

	fld	QWORD PTR _web+832
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN206@initialize
	push	esi
	mov	DWORD PTR _web+824, 1
	call	_kb_yylex
	mov	DWORD PTR _recovery_flag, esi
	jmp	$LN584@initialize
$LN108@initialize:

; 1527 :                tok = yylex();
; 1528 :              }
; 1529 :              recovery_flag = 0;
; 1530 :              break;
; 1531 : 
; 1532 :         case SPRING_CONSTANT_TOK:
; 1533 :         case GAP_CONSTANT_TOK:
; 1534 :              uminus_flag = 0;

	xor	esi, esi

; 1535 :              if ( read_const(&web.spring_constant) <= 0 )

	push	OFFSET _web+1584
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	$LN206@initialize

; 1536 :              { kb_error(1102,"Missing GAP_CONSTANT value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BN@FELGNELD@Missing?5GAP_CONSTANT?5value?4?6?$AA@
	push	1102					; 0000044eH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1537 :                if ( tok == SPRING_CONSTANT_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 35081			; 00008909H

; 1538 :              }
; 1539 :              else tok = yylex();
; 1540 :              recovery_flag = 0;
; 1541 :              break;

	jmp	$LN599@initialize
$LN99@initialize:

; 1556 : 
; 1557 :         case TEMPERATURE_TOK:
; 1558 :              uminus_flag = 0;

	xor	esi, esi

; 1559 :              if ( read_const(&web.temperature) <= 0 )

	push	OFFSET _web+1576
	mov	DWORD PTR _uminus_flag, esi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	$LN206@initialize

; 1560 :              { kb_error(1104,"Missing TEMPERATURE value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BM@DBLPODHF@Missing?5TEMPERATURE?5value?4?6?$AA@
	push	1104					; 00000450H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1561 :                if ( tok == TEMPERATURE_TOK ) tok = yylex(); /* ensure progress */

	cmp	DWORD PTR _tok, 35082			; 0000890aH

; 1562 :              }
; 1563 :              else tok = yylex();
; 1564 :              recovery_flag = 0;
; 1565 :              break;

	jmp	$LN599@initialize
$LN90@initialize:

; 1579 :             /* done with top stuff */
; 1580 : 
; 1581 :         default: 
; 1582 :              if ( !recovery_flag )

	cmp	DWORD PTR _recovery_flag, 0
	jne	SHORT $LN89@initialize

; 1583 :                 { sprintf(errmsg,"Illegal token '%s'.\n",yytext);

	mov	ecx, DWORD PTR _yytext
	push	ecx
	push	OFFSET ??_C@_0BF@JFDCKONH@Illegal?5token?5?8?$CFs?8?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1584 :                   kb_error(1106,errmsg,PARSE_ERROR);

	push	3
	push	OFFSET _errmsg
	push	1106					; 00000452H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN89@initialize:

; 1585 :                 }
; 1586 :              tok = yylex();

	push	0
$LN589@initialize:
	call	_kb_yylex
$LN584@initialize:
	mov	DWORD PTR _tok, eax
$LN586@initialize:
	add	esp, 4
$LN548@initialize:

; 488  :   while ( (tok != 0) && topflag )

	cmp	DWORD PTR _tok, 0
	jne	$LL414@initialize
$LN413@initialize:

; 1587 :              break;
; 1588 :      }
; 1589 :   }
; 1590 : 
; 1591 :   /* see that all forward declarations resolved */
; 1592 :   check_forwards();

	call	_check_forwards

; 1593 :   
; 1594 :   /* set up gaussian quadrature */
; 1595 :   gauss_setup();

	call	_gauss_setup

; 1596 :   setup_q_info();

	call	_setup_q_info

; 1597 :   
; 1598 :   if ( web.torus_flag )

	xor	esi, esi

; 1599 :      calc_periods(ADJUST_VOLUMES);  /* adjust torus volume constants */

	lea	edi, DWORD PTR [esi+1]
	cmp	DWORD PTR _web+860, esi
	je	SHORT $LN528@initialize
	push	edi
	call	_calc_periods
	add	esp, 4

; 1600 :    
; 1601 :   if ( !web.torus_flag )

	cmp	DWORD PTR _web+860, esi
	jne	SHORT $LN87@initialize
$LN528@initialize:

; 1602 :     torus_display_mode = TORUS_DEFAULT_MODE; 

	mov	DWORD PTR _torus_display_mode, esi
$LN87@initialize:

; 1603 : 
; 1604 :   reset_view();   /* can do this now, since know ambient dimension */

	call	_reset_view

; 1605 :   globals(view_transforms_unique_point_global)->attr.arrayptr->sizes[0] = SDIM;

	mov	eax, DWORD PTR _view_transforms_unique_point_global
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN465@initialize
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN467@initialize
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN466@initialize
$LN505@initialize:

; 618  :                { sprintf(errmsg,
; 619  :                  "Bad content component %d definition for hessian_special_normal_vector.\n",
; 620  :                      i+1);

	push	esi
	push	OFFSET ??_C@_0EI@LFINBAOG@Bad?5content?5component?5?$CFd?5definit@
	push	OFFSET _errmsg
	call	_sprintf

; 621  :                  kb_error(2095,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	2095					; 0000082fH
	call	_kb_error
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 1827 : 
; 1828 : }  /* end initialize */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN467@initialize:

; 1605 :   globals(view_transforms_unique_point_global)->attr.arrayptr->sizes[0] = SDIM;

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN465@initialize
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN466@initialize
$LN465@initialize:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN466@initialize:
	mov	edx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR _web+616
	mov	DWORD PTR [edx+24], eax

; 1606 : 
; 1607 :   #ifdef HASH_ID
; 1608 :   elhash_bigger();
; 1609 :   #endif
; 1610 : 
; 1611 :   // Dimension calculated attributes
; 1612 :   { struct extra *ex;
; 1613 :     ex = EXTRAS(VERTEX) + V_NORMAL_ATTR;

	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	lea	eax, DWORD PTR [edx+ecx+1680]

; 1614 :     ex->array_spec.datacount = SDIM;

	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR [eax+88], ecx

; 1615 :     ex->array_spec.sizes[0] = SDIM;

	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR [eax+96], edx

; 1616 :     ex = EXTRAS(VERTEX) + V_CONSTRAINT_NORMAL_ATTR;

	mov	ecx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem

; 1617 :     ex->array_spec.datacount = SDIM;

	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR [ecx+eax+2008], edx
	lea	eax, DWORD PTR [ecx+eax+1920]

; 1618 :     ex->array_spec.sizes[0] = SDIM;

	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR [eax+96], ecx

; 1619 :     ex = EXTRAS(EDGE) + E_VECTOR_ATTR;

	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216

; 1620 :     ex->array_spec.datacount = SDIM;

	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR [eax+edx+568], ecx
	lea	eax, DWORD PTR [eax+edx+480]

; 1621 :     ex->array_spec.sizes[0] = SDIM;

	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR [eax+96], edx

; 1622 :     ex = EXTRAS(FACET) + F_NORMAL_ATTR;

	mov	ecx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem

; 1623 :     ex->array_spec.datacount = SDIM;

	mov	edx, DWORD PTR _web+616
	lea	eax, DWORD PTR [ecx+eax+480]
	mov	DWORD PTR [eax+88], edx

; 1624 :     ex->array_spec.sizes[0] = SDIM;

	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR [eax+96], ecx

; 1625 :   }
; 1626 :   dataflag = 1;
; 1627 :   uminus_flag = 1;
; 1628 :   while ( (tok != 0) && dataflag )

	mov	eax, DWORD PTR _tok
	mov	ebx, edi
	mov	DWORD PTR _uminus_flag, edi
	cmp	eax, esi
	je	$LN566@initialize
$LL86@initialize:
	cmp	ebx, esi
	je	$LN566@initialize

; 1629 :     switch ( tok )

	cmp	eax, 296				; 00000128H
	jg	$LN471@initialize
	je	$LN73@initialize
	sub	eax, 293				; 00000125H
	je	SHORT $LN82@initialize
	sub	eax, edi
	jne	$LN70@initialize

; 1642 : 
; 1643 :         case EDGES_TOK: 
; 1644 :              if (  flist || blist )

	cmp	DWORD PTR _flist, esi
	jne	SHORT $LN76@initialize
	cmp	DWORD PTR _blist, esi
	je	SHORT $LN77@initialize
$LN76@initialize:

; 1645 :                kb_error(2410,"Edges list must be second element list.\n",
; 1646 :                           RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0CJ@JHNGAGBL@Edges?5list?5must?5be?5second?5elemen@
	push	2410					; 0000096aH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN77@initialize:

; 1647 :              recovery_flag = 0; 

	mov	DWORD PTR _recovery_flag, esi

; 1648 :              read_edges();

	call	_read_edges

; 1649 :              break;

	mov	eax, DWORD PTR _tok
	jmp	$LN83@initialize
$LN82@initialize:

; 1630 :      { 
; 1631 :         case VERTICES_TOK: 
; 1632 :              if ( (web.dimension > 2) && (web.representation != SIMPLEX) )

	cmp	DWORD PTR _web+620, 2
	jle	SHORT $LN81@initialize
	cmp	DWORD PTR _web+624, 3
	je	SHORT $LN81@initialize

; 1633 :                 kb_error(1107,
; 1634 :              "Must have simplex representation for surface dimension over 2.\n",
; 1635 :                 UNRECOVERABLE);

	push	esi
	push	OFFSET ??_C@_0EA@HCFNNEMF@Must?5have?5simplex?5representation@
	push	1107					; 00000453H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN81@initialize:

; 1636 :              if ( elist || flist || blist )

	cmp	DWORD PTR _elist, esi
	jne	SHORT $LN79@initialize
	cmp	DWORD PTR _flist, esi
	jne	SHORT $LN79@initialize
	cmp	DWORD PTR _blist, esi
	je	SHORT $LN80@initialize
$LN79@initialize:

; 1637 :                kb_error(2409,"Vertices list must be first element list.\n",
; 1638 :                           RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0CL@JFDKOOIO@Vertices?5list?5must?5be?5first?5elem@
	push	2409					; 00000969H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN80@initialize:

; 1639 :              recovery_flag = 0; 

	mov	DWORD PTR _recovery_flag, esi

; 1640 :              read_vertices();

	call	_read_vertices

; 1641 :              break;

	mov	eax, DWORD PTR _tok
	jmp	$LN83@initialize
$LN73@initialize:

; 1658 : 
; 1659 :         case BODIES_TOK: 
; 1660 :              recovery_flag = 0; 

	mov	DWORD PTR _recovery_flag, esi

; 1661 :              read_bodies();

	call	_read_bodies

; 1662 :              break;

	mov	eax, DWORD PTR _tok
	jmp	$LN83@initialize
$LN471@initialize:

; 1629 :     switch ( tok )

	cmp	eax, 342				; 00000156H
	je	$LN72@initialize
	cmp	eax, 35086				; 0000890eH
	je	SHORT $LN75@initialize
$LN70@initialize:

; 1676 :              break;
; 1677 : 
; 1678 :         default: 
; 1679 :              if ( !recovery_flag )

	cmp	DWORD PTR _recovery_flag, esi
	jne	SHORT $LN69@initialize

; 1680 :                 { sprintf(errmsg,"Illegal token '%s'.\n",yytext);

	mov	edx, DWORD PTR _yytext
	push	edx
	push	OFFSET ??_C@_0BF@JFDCKONH@Illegal?5token?5?8?$CFs?8?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1681 :                   kb_error(1108,errmsg,PARSE_ERROR);

	push	3
	push	OFFSET _errmsg
	push	1108					; 00000454H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN69@initialize:

; 1682 :                 }
; 1683 :              brace_depth = parens = in_quote = 0; /* just in case */
; 1684 :              tok = yylex();

	push	esi
	mov	DWORD PTR _in_quote, esi
	mov	DWORD PTR _parens, esi
	mov	DWORD PTR _brace_depth, esi
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1685 :              break;

	jmp	SHORT $LN83@initialize
$LN75@initialize:

; 1650 : 
; 1651 :         case FACES_TOK: 
; 1652 :              if (  blist )

	cmp	DWORD PTR _blist, esi
	je	SHORT $LN74@initialize

; 1653 :                kb_error(2411,"Faces list must precede body list.\n",
; 1654 :                           RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0CE@CPMJENCO@Faces?5list?5must?5precede?5body?5lis@
	push	2411					; 0000096bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN74@initialize:

; 1655 :              recovery_flag = 0; 

	mov	DWORD PTR _recovery_flag, esi

; 1656 :              read_faces();

	call	_read_faces

; 1657 :              break;

	mov	eax, DWORD PTR _tok
	jmp	SHORT $LN83@initialize
$LN72@initialize:

; 1663 : 
; 1664 :         case READ_TOK: 
; 1665 :              if ( addload_flag )

	cmp	DWORD PTR _addload_flag, esi
	je	SHORT $LN71@initialize

; 1666 :              { pop_commandfd();

	call	_pop_commandfd

; 1667 :                lists_flag = LISTS_OFF;     
; 1668 :                dataflag = 0;  /* end of element data */
; 1669 :                break;

	mov	eax, DWORD PTR _tok
	xor	ebx, ebx
	jmp	SHORT $LN595@initialize
$LN71@initialize:

; 1673 :              read_command_flag = 1; 
; 1674 :              dataflag = 0;  /* end of element data */

	xor	ebx, ebx

; 1675 :              line_no++; /* kludge */

	add	DWORD PTR _line_no, edi
	mov	DWORD PTR _read_command_flag, edi
$LN595@initialize:

; 1670 :              }
; 1671 :              /* read commands from datafile */
; 1672 :              lists_flag = LISTS_OFF;

	mov	DWORD PTR _lists_flag, esi
$LN83@initialize:

; 1625 :   }
; 1626 :   dataflag = 1;
; 1627 :   uminus_flag = 1;
; 1628 :   while ( (tok != 0) && dataflag )

	cmp	eax, esi
	jne	$LL86@initialize
$LN566@initialize:

; 1686 :      }
; 1687 :              
; 1688 :   if ( parse_errors ) return;

	cmp	DWORD PTR _parse_errors, esi
	jne	$LN1@initialize

; 1689 : 
; 1690 :   datafile_flag = 1;  /* got zeroed by pop_commandfd; need to read x1 */

	mov	DWORD PTR _datafile_flag, edi

; 1691 :   if ( option_q || everything_quantities_flag )

	cmp	DWORD PTR _option_q, esi
	jne	SHORT $LN66@initialize
	mov	ebx, DWORD PTR _everything_quantities_flag
	cmp	ebx, esi
	je	SHORT $LN67@initialize
$LN66@initialize:

; 1692 :      convert_to_quantities();

	call	_convert_to_quantities
	mov	ebx, DWORD PTR _everything_quantities_flag
$LN67@initialize:

; 1693 :   if ( optparamcount && !everything_quantities_flag )

	cmp	DWORD PTR _optparamcount, esi
	je	SHORT $LN65@initialize
	cmp	ebx, esi
	jne	SHORT $LN65@initialize

; 1694 :      convert_to_quantities();

	call	_convert_to_quantities
	mov	ebx, DWORD PTR _everything_quantities_flag
$LN65@initialize:

; 1695 :   if ( (web.modeltype == LAGRANGE) && !everything_quantities_flag )

	cmp	DWORD PTR _web+628, 3
	jne	SHORT $LN64@initialize
	cmp	ebx, esi
	jne	SHORT $LN527@initialize

; 1696 :   { outstring("Converting to named quantities for Lagrange model.\n");

	push	OFFSET ??_C@_0DE@NGDIDIBI@Converting?5to?5named?5quantities?5f@
	call	_outstring
	add	esp, 4

; 1697 :     option_q = 1;  /* so convert_to_quantities doesn't try to calc */

	mov	DWORD PTR _option_q, edi

; 1698 :     convert_to_quantities();

	call	_convert_to_quantities

; 1699 :     option_q = 0;

	mov	DWORD PTR _option_q, esi
	jmp	SHORT $LN596@initialize
$LN64@initialize:

; 1700 :   }
; 1701 :   else if ( everything_quantities_flag && replace_load_flag )

	cmp	ebx, esi
	je	SHORT $LN62@initialize
$LN527@initialize:
	cmp	DWORD PTR _replace_load_flag, esi
	je	SHORT $LN62@initialize

; 1702 :   {  convert_bodies_to_quantities();

	call	_convert_bodies_to_quantities
$LN596@initialize:
	mov	ebx, DWORD PTR _everything_quantities_flag
$LN62@initialize:

; 1703 :   }
; 1704 :   for ( i = 0 ; i < web.bdrymax ; i++ )

	mov	edi, DWORD PTR _web+768
	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN59@initialize
	mov	edx, DWORD PTR _web+776
	add	edx, 32					; 00000020H
$LL61@initialize:

; 1705 :     if ( (web.boundaries[i].attr & (CON_ENERGY|CON_CONTENT)) 
; 1706 :                  && !everything_quantities_flag  )

	mov	eax, DWORD PTR [edx]
	and	eax, 192				; 000000c0H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN60@initialize
	test	ebx, ebx
	je	SHORT $LN508@initialize
$LN60@initialize:

; 1703 :   }
; 1704 :   for ( i = 0 ; i < web.bdrymax ; i++ )

	inc	esi
	add	edx, 136				; 00000088H
	cmp	esi, edi
	jl	SHORT $LL61@initialize

; 1705 :     if ( (web.boundaries[i].attr & (CON_ENERGY|CON_CONTENT)) 
; 1706 :                  && !everything_quantities_flag  )

	jmp	SHORT $LN59@initialize
$LN508@initialize:

; 1707 :     { outstring("Converting to named quantities for boundary integrals.\n");

	push	OFFSET ??_C@_0DI@FNDBGOJC@Converting?5to?5named?5quantities?5f@
	call	_outstring
	add	esp, 4

; 1708 :       option_q = 1;  /* so convert_to_quantities doesn't try to calc */

	mov	DWORD PTR _option_q, 1

; 1709 :       convert_to_quantities();

	call	_convert_to_quantities

; 1710 :       option_q = 0;

	mov	DWORD PTR _option_q, 0
$LN59@initialize:

; 1711 :       break;
; 1712 :     }
; 1713 :   datafile_flag = 0;
; 1714 : 
; 1715 :   if ( web.dimension == 1 ) areaname = "length";

	cmp	DWORD PTR _web+620, 1
	mov	DWORD PTR _datafile_flag, 0
	mov	DWORD PTR _areaname, OFFSET ??_C@_06IJDLPEM@length?$AA@
	je	SHORT $LN56@initialize

; 1716 :   else areaname = "area";

	mov	DWORD PTR _areaname, OFFSET ??_C@_04GOEDGNCF@area?$AA@
$LN56@initialize:

; 1717 : 
; 1718 :   mark_recalc_params();

	call	_mark_recalc_params

; 1719 : 
; 1720 : #ifdef MPI_EVOLVER
; 1721 :   mpi_task_set_thin_corona();  /* get neighbor elements, with basic corona */
; 1722 : #endif
; 1723 : 
; 1724 :   /* create initial triangulation of each face */
; 1725 : 
; 1726 :   if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	jne	$LN556@initialize

; 1727 :     for ( f = 1 ; f <= facecount ; f++ )

	mov	ebx, 1
	cmp	DWORD PTR _facecount, ebx
	jl	$LN555@initialize
	mov	edi, DWORD PTR _web+460
$LL568@initialize:

; 1728 :     { facetedge_id first_fe;
; 1729 :       int edgecount = 0;
; 1730 : 
; 1731 :       if ( !valid_id(flist[f]) ) continue;

	mov	eax, DWORD PTR _flist
	mov	ecx, DWORD PTR [eax+ebx*4]
	xor	edx, edx
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN53@initialize

; 1732 : 
; 1733 :       /* see how many edges, and if we want to refine */
; 1734 :       fe = first_fe = get_facet_fe(flist[f]);

	mov	esi, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN472@initialize
	xor	eax, 134217728				; 08000000H
$LN472@initialize:
	mov	esi, eax

; 1735 :       if ( valid_id(fe) ) do

	test	esi, 268435456				; 10000000H
	je	SHORT $LN53@initialize
$LL49@initialize:

; 1736 :       { edgecount++;

	inc	edx

; 1737 :         fe = get_next_edge(fe);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN477@initialize
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN48@initialize
$LN477@initialize:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+32]
$LN48@initialize:

; 1738 :       } while ( valid_id(fe) && !equal_id(fe,first_fe) );

	test	eax, 268435456				; 10000000H
	je	SHORT $LN46@initialize
	cmp	eax, esi
	jne	SHORT $LL49@initialize
$LN46@initialize:

; 1739 :       if ( edgecount > 3 ) face_triangulate(flist[f],edgecount);  

	cmp	edx, 3
	jle	SHORT $LN53@initialize
	push	edx
	push	ecx
	call	_face_triangulate
	mov	edi, DWORD PTR _web+460
	add	esp, 8
$LN53@initialize:

; 1727 :     for ( f = 1 ; f <= facecount ; f++ )

	inc	ebx
	cmp	ebx, DWORD PTR _facecount
	jle	$LL568@initialize

; 1740 :     }
; 1741 : 
; 1742 :  
; 1743 :   /* straighten out facet order around edges */
; 1744 :   if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	jne	SHORT $LN556@initialize
$LN555@initialize:

; 1745 :   { edge_id e_id;
; 1746 :     MFOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+160
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN558@initialize
	npad	5
$LL43@initialize:
	mov	edx, DWORD PTR _web+124
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [edx+esi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN42@initialize

; 1747 :       fe_reorder(e_id);

	push	ecx
	call	_fe_reorder
	add	esp, 4
$LN42@initialize:

; 1745 :   { edge_id e_id;
; 1746 :     MFOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [eax+esi]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL43@initialize
$LN556@initialize:

; 1748 :   }
; 1749 : 
; 1750 :   /* put facet-edges on string network if no facets defined */
; 1751 : 
; 1752 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN558@initialize

; 1753 :      string_fixup();

	call	_string_fixup
$LN558@initialize:

; 1754 : 
; 1755 : 
; 1756 :   /* phase boundary energies */
; 1757 :   if ( phase_flag && (web.representation == STRING) )

	cmp	DWORD PTR _phase_flag, 0
	je	$LN28@initialize
	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN34@initialize

; 1758 :   { edge_id e_id;
; 1759 :     FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+160
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN34@initialize
	mov	eax, DWORD PTR _web+124
$LL36@initialize:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [eax+esi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN35@initialize

; 1760 :       set_e_phase_density(e_id);

	push	ecx
	call	_set_e_phase_density
	add	esp, 4
$LN35@initialize:

; 1758 :   { edge_id e_id;
; 1759 :     FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+124
	mov	edx, DWORD PTR [eax+esi]
	mov	ecx, DWORD PTR [edx]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL36@initialize
$LN34@initialize:

; 1761 :   }
; 1762 :   if ( phase_flag && (web.representation != STRING) )

	cmp	DWORD PTR _phase_flag, 0
	je	SHORT $LN28@initialize
	cmp	DWORD PTR _web+624, 1
	je	SHORT $LN28@initialize

; 1763 :   { facet_id f_id;
; 1764 :     FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+272
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN28@initialize
	mov	edi, DWORD PTR _web+236
	npad	1
$LL30@initialize:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN29@initialize

; 1765 :       set_f_phase_density(f_id);

	push	ecx
	call	_set_f_phase_density
	mov	edi, DWORD PTR _web+236
	add	esp, 4
$LN29@initialize:

; 1763 :   { facet_id f_id;
; 1764 :     FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR [edi+esi]
	mov	ecx, DWORD PTR [eax]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL30@initialize
$LN28@initialize:

; 1766 :   }
; 1767 : 
; 1768 :   /* run preliminary checks */
; 1769 :   if ( web.representation != SIMPLEX  )

	mov	esi, 3
	cmp	DWORD PTR _web+624, esi
	je	SHORT $LN570@initialize

; 1770 :   { facet_body_check();

	call	_facet_body_check

; 1771 :     if ( facetedge_check(PRELIMCHECK)  )

	mov	edi, 1
	push	edi
	call	_facetedge_check
	add	esp, 4
	test	eax, eax
	je	SHORT $LN24@initialize

; 1772 :         kb_error(1109,"Bad data file.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BA@MPAJEHHD@Bad?5data?5file?4?6?$AA@
	push	1109					; 00000455H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN24@initialize
$LN570@initialize:
	mov	edi, 1
$LN24@initialize:

; 1773 :   }
; 1774 :   if ( vlist == NULL )

	cmp	DWORD PTR _vlist, 0
	jne	SHORT $LN571@initialize

; 1775 :      kb_error(1110,"No vertices found in datafile.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CA@OOHLDEKN@No?5vertices?5found?5in?5datafile?4?6?$AA@
	push	1110					; 00000456H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN571@initialize:

; 1776 :   if ( (elist == NULL) && (web.representation != SIMPLEX) )

	cmp	DWORD PTR _elist, 0
	jne	SHORT $LN575@initialize
	cmp	DWORD PTR _web+624, esi
	je	SHORT $LN575@initialize

; 1777 :      kb_error(1111,"No edges found in datafile.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BN@BCFEOGPP@No?5edges?5found?5in?5datafile?4?6?$AA@
	push	1111					; 00000457H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN575@initialize:

; 1778 : 
; 1779 : 
; 1780 :   if ( vlist ) myfree((char *)vlist);

	mov	eax, DWORD PTR _vlist
	test	eax, eax
	je	SHORT $LN21@initialize
	push	eax
	call	_myfree
	add	esp, 4
$LN21@initialize:

; 1781 :   if ( elist ) myfree((char *)elist);

	mov	eax, DWORD PTR _elist
	test	eax, eax
	je	SHORT $LN20@initialize
	push	eax
	call	_myfree
	add	esp, 4
$LN20@initialize:

; 1782 :   if ( flist ) myfree((char *)flist);

	mov	eax, DWORD PTR _flist
	test	eax, eax
	je	SHORT $LN19@initialize
	push	eax
	call	_myfree
	add	esp, 4
$LN19@initialize:

; 1783 :   if ( blist ) myfree((char *)blist);

	mov	eax, DWORD PTR _blist
	test	eax, eax
	je	SHORT $LN18@initialize
	push	eax
	call	_myfree
	add	esp, 4
$LN18@initialize:

; 1784 :          
; 1785 :   for ( k = 2, web.simplex_factorial = 1.0 ; k <= web.dimension ; k++ )

	fld1
	mov	ecx, DWORD PTR _web+620
	mov	eax, 2
	fst	QWORD PTR _web+792
	mov	DWORD PTR _k$[ebp], eax
	cmp	ecx, eax
	jl	SHORT $LN15@initialize
$LN17@initialize:

; 1786 :      web.simplex_factorial *= k;

	fimul	DWORD PTR _k$[ebp]
	add	eax, edi
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, ecx
	jle	SHORT $LN17@initialize
	fst	QWORD PTR _web+792
$LN15@initialize:

; 1787 :   volume_factorial = web.simplex_factorial*SDIM;

	fimul	DWORD PTR _web+616
	fstp	QWORD PTR _volume_factorial

; 1788 :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, esi
	jne	SHORT $LN14@initialize

; 1789 :   { refine_simplex_init();

	call	_refine_simplex_init
	jmp	SHORT $LN12@initialize
$LN14@initialize:

; 1790 :   }
; 1791 :   else  if ( web.modeltype == LINEAR )

	cmp	DWORD PTR _web+628, edi
	jne	SHORT $LN12@initialize

; 1792 :   { calc_facet_energy =  facet_energy_l;

	mov	DWORD PTR _calc_facet_energy, OFFSET _facet_energy_l

; 1793 :     calc_facet_forces =  facet_force_l;

	mov	DWORD PTR _calc_facet_forces, OFFSET _facet_force_l

; 1794 :     calc_facet_volume = facet_volume_l;

	mov	DWORD PTR _calc_facet_volume, OFFSET _facet_volume_l

; 1795 :     film_grad = film_grad_l;

	mov	DWORD PTR _film_grad, OFFSET _film_grad_l

; 1796 :     calc_edge_energy = edge_energy_l;

	mov	DWORD PTR _calc_edge_energy, OFFSET _edge_energy_l

; 1797 :     calc_edge_forces  = edge_force_l;

	mov	DWORD PTR _calc_edge_forces, OFFSET _edge_force_l

; 1798 :     calc_edge_area = edge_area_l;

	mov	DWORD PTR _calc_edge_area, OFFSET _edge_area_l

; 1799 :     string_grad = string_grad_l;

	mov	DWORD PTR _string_grad, OFFSET _string_grad_l
$LN12@initialize:

; 1800 :   }
; 1801 : 
; 1802 :   if ( transform_count == 0 )  /* set up identity transform */

	cmp	DWORD PTR _transform_count, 0
	jne	SHORT $LN11@initialize

; 1804 :     view_transforms = dmatrix3(1,SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	push	1804					; 0000070cH
	inc	eax
	push	OFFSET ??_C@_09JGPPFAML@LEXINIT?4C?$AA@
	push	eax
	push	eax
	push	edi
	mov	DWORD PTR _transform_count, edi
	call	_kb_dmatrix3

; 1805 :     for ( j = 0 ; j <= SDIM ; j++ )

	xor	ecx, ecx
	add	esp, 20					; 00000014H
	mov	DWORD PTR _view_transforms, eax
	cmp	DWORD PTR _web+616, ecx
	jl	SHORT $LN8@initialize

; 1803 :   { transform_count = 1;

	mov	eax, DWORD PTR [eax]
	fld1
$LN10@initialize:

; 1806 :       view_transforms[0][j][j] = 1.0;

	mov	edx, DWORD PTR [eax]
	fst	QWORD PTR [edx+ecx*8]
	add	ecx, edi
	add	eax, 4
	cmp	ecx, DWORD PTR _web+616
	jle	SHORT $LN10@initialize

; 1805 :     for ( j = 0 ; j <= SDIM ; j++ )

	fstp	ST(0)
$LN8@initialize:

; 1807 :     set_view_transforms_global();

	call	_set_view_transforms_global
$LN11@initialize:

; 1808 :   }
; 1809 :   
; 1810 :   if ( autopop_flag )

	cmp	DWORD PTR _autopop_flag, 0
	je	SHORT $LN4@initialize

; 1811 :   { int n;
; 1812 :     if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, edi
	jne	SHORT $LN6@initialize

; 1813 :       sprintf(msg,"Number of vertices popped: %d\n", n = verpop_str());

	call	_verpop_str
	mov	esi, eax
	mov	eax, DWORD PTR _msg
	push	esi
	push	OFFSET ??_C@_0BP@OAFHPFJG@Number?5of?5vertices?5popped?3?5?$CFd?6?$AA@
	push	eax

; 1814 :     else

	jmp	SHORT $LN597@initialize
$LN6@initialize:

; 1815 :       sprintf(msg,"Number of vertices popped: %d\n", n = edgepop_film());

	call	_edgepop_film
	mov	ecx, DWORD PTR _msg
	mov	esi, eax
	push	esi
	push	OFFSET ??_C@_0BP@OAFHPFJG@Number?5of?5vertices?5popped?3?5?$CFd?6?$AA@
	push	ecx
$LN597@initialize:
	call	_sprintf

; 1816 :     outstring(msg);

	mov	edx, DWORD PTR _msg
	add	esp, 12					; 0000000cH
	push	edx
	call	_outstring
	add	esp, 4

; 1817 :     if ( n > 0 ) update_display();

	test	esi, esi
	jle	SHORT $LN4@initialize
	call	_update_display
$LN4@initialize:

; 1818 :   }
; 1819 : 
; 1820 :   if ( web.homothety && (web.skel[BODY].count == 0) )

	cmp	DWORD PTR _web+904, 0
	je	SHORT $LN3@initialize
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN3@initialize

; 1821 :      { web.homothety = 0;
; 1822 :        kb_error(1112,"Cannot do homothety without bodies. Homothety OFF.\n",RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0DE@NJENFFAA@Cannot?5do?5homothety?5without?5bodi@
	push	1112					; 00000458H
	mov	DWORD PTR _web+904, 0
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN3@initialize:

; 1823 :      }
; 1824 : 
; 1825 :   if ( sym_flags & NEED_FORM_UNWRAPPING )

	test	BYTE PTR _sym_flags, 2
	je	SHORT $LN1@initialize

; 1826 :      if ( auto_convert_flag ) convert_to_quantities();

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN1@initialize
	call	_convert_to_quantities
$LN1@initialize:

; 1827 : 
; 1828 : }  /* end initialize */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN600@initialize:
	DD	$LN235@initialize
	DD	$LN244@initialize
	DD	$LN91@initialize
	DD	$LN95@initialize
	DD	$LN215@initialize
	DD	$LN325@initialize
	DD	$LN197@initialize
	DD	$LN278@initialize
	DD	$LN275@initialize
	DD	$LN207@initialize
	DD	$LN104@initialize
	DD	$LN216@initialize
	DD	$LN271@initialize
	DD	$LN218@initialize
	DD	$LN211@initialize
	DD	$LN280@initialize
	DD	$LN108@initialize
	DD	$LN213@initialize
	DD	$LN217@initialize
	DD	$LN212@initialize
	DD	$LN251@initialize
	DD	$LN226@initialize
	DD	$LN90@initialize
$LN532@initialize:
	DB	0
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	1
	DB	2
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	3
	DB	4
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	5
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	6
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	7
	DB	8
	DB	22					; 00000016H
	DB	9
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	10					; 0000000aH
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	11					; 0000000bH
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	12					; 0000000cH
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	13					; 0000000dH
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	14					; 0000000eH
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	15					; 0000000fH
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	16					; 00000010H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	17					; 00000011H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	18					; 00000012H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	19					; 00000013H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	20					; 00000014H
	DB	21					; 00000015H
	npad	1
$LN601@initialize:
	DD	$LN242@initialize
	DD	$LN364@initialize
	DD	$LN357@initialize
	DD	$LN371@initialize
	DD	$LN338@initialize
	DD	$LN347@initialize
	DD	$LN346@initialize
	DD	$LN344@initialize
	DD	$LN341@initialize
	DD	$LN265@initialize
	DD	$LN220@initialize
	DD	$LN160@initialize
	DD	$LN157@initialize
	DD	$LN253@initialize
	DD	$LN225@initialize
	DD	$LN203@initialize
	DD	$LN193@initialize
	DD	$LN247@initialize
	DD	$LN200@initialize
	DD	$LN198@initialize
	DD	$LN144@initialize
	DD	$LN252@initialize
	DD	$LN149@initialize
	DD	$LN184@initialize
	DD	$LN161@initialize
	DD	$LN166@initialize
	DD	$LN172@initialize
	DD	$LN178@initialize
	DD	$LN188@initialize
	DD	$LN337@initialize
	DD	$LN332@initialize
	DD	$LN326@initialize
	DD	$LN302@initialize
	DD	$LN300@initialize
	DD	$LN299@initialize
	DD	$LN291@initialize
	DD	$LN282@initialize
	DD	$LN281@initialize
	DD	$LN279@initialize
	DD	$LN255@initialize
	DD	$LN254@initialize
	DD	$LN250@initialize
	DD	$LN244@initialize
	DD	$LN243@initialize
	DD	$LN224@initialize
	DD	$LN222@initialize
	DD	$LN214@initialize
	DD	$LN199@initialize
	DD	$LN192@initialize
	DD	$LN148@initialize
	DD	$LN140@initialize
	DD	$LN136@initialize
	DD	$LN121@initialize
	DD	$LN116@initialize
	DD	$LN113@initialize
	DD	$LN108@initialize
	DD	$LN99@initialize
	DD	$LN410@initialize
	DD	$LN406@initialize
	DD	$LN402@initialize
	DD	$LN398@initialize
	DD	$LN394@initialize
	DD	$LN390@initialize
	DD	$LN386@initialize
	DD	$LN90@initialize
$LN533@initialize:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	5
	DB	64					; 00000040H
	DB	6
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	7
	DB	8
	DB	9
	DB	64					; 00000040H
	DB	10					; 0000000aH
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	64					; 00000040H
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	64					; 00000040H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	64					; 00000040H
	DB	26					; 0000001aH
	DB	64					; 00000040H
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	64					; 00000040H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	10					; 0000000aH
	DB	46					; 0000002eH
	DB	47					; 0000002fH
	DB	48					; 00000030H
	DB	49					; 00000031H
	DB	50					; 00000032H
	DB	51					; 00000033H
	DB	52					; 00000034H
	DB	53					; 00000035H
	DB	54					; 00000036H
	DB	55					; 00000037H
	DB	56					; 00000038H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	64					; 00000040H
	DB	57					; 00000039H
	DB	58					; 0000003aH
	DB	59					; 0000003bH
	DB	60					; 0000003cH
	DB	61					; 0000003dH
	DB	62					; 0000003eH
	DB	63					; 0000003fH
_initialize ENDP
_TEXT	ENDS
END
