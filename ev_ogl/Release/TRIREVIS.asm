; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\TRIREVIS.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_did_global_edge_calc
_BSS	SEGMENT
_did_global_edge_calc DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_unset_attr
; Function compile flags: /Ogtp
;	COMDAT _unset_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_unset_attr PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 29   :   elptr(id)->attr &= ~attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	not	ecx
	and	DWORD PTR [eax+8], ecx
	not	edx
	and	DWORD PTR [eax+12], edx

; 30   : }

	pop	ebp
	ret	0
_unset_attr ENDP
_TEXT	ENDS
PUBLIC	_set_fe_edge
EXTRN	_top_timestamp:DWORD
EXTRN	_global_timestamp:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_e_id$ = 12						; size = 4
_set_fe_edge PROC					; COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp

; 36   :   if ( inverted(fe_id) ) invert(e_id);

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN1@set_fe_edg
	xor	DWORD PTR _e_id$[ebp], 134217728	; 08000000H
$LN1@set_fe_edg:

; 37   :   feptr(fe_id)->fe_edge_id = e_id;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR [edx+20], eax

; 38   :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 39   : }

	pop	ebp
	ret	0
_set_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_edge
; Function compile flags: /Ogtp
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _get_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_facet PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp

; 84   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 85   :     return inverse_id(feptr(fe_id)->nextfacet[1]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]
	xor	eax, 134217728				; 08000000H

; 88   : }

	pop	ebp
	ret	0
$LN2@get_prev_f:

; 86   :   else 
; 87   :     return feptr(fe_id)->nextfacet[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]

; 88   : }

	pop	ebp
	ret	0
_get_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _set_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_edge PROC					; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp

; 103  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_e

; 104  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_e

; 105  :     { invert(fe);
; 106  :       feptr(fe_id)->nextedge[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+32], ecx

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 111  : }

	pop	ebp
	ret	0
$LN2@set_prev_e:

; 107  :     }
; 108  :   else
; 109  :       feptr(fe_id)->nextedge[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_e:

; 111  : }

	pop	ebp
	ret	0
_set_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_set_next_edge
; Function compile flags: /Ogtp
;	COMDAT _set_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_edge PROC					; COMDAT

; 116  : {

	push	ebp
	mov	ebp, esp

; 117  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_e

; 118  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_e

; 119  :     { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 120  :       feptr(fe_id)->nextedge[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+28], ecx

; 124  : }

	pop	ebp
	ret	0
$LN2@set_next_e:

; 121  :     }
; 122  :   else
; 123  :       feptr(fe_id)->nextedge[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN1@set_next_e:

; 124  : }

	pop	ebp
	ret	0
_set_next_edge ENDP
_TEXT	ENDS
PUBLIC	_set_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _set_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_facet PROC					; COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp

; 130  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_f

; 131  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_f

; 132  :   { invert(fe);
; 133  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+40], ecx

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 138  : }

	pop	ebp
	ret	0
$LN2@set_prev_f:

; 134  :   }
; 135  :   else
; 136  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+36], eax

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_f:

; 138  : }

	pop	ebp
	ret	0
_set_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_set_next_facet
; Function compile flags: /Ogtp
;	COMDAT _set_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_facet PROC					; COMDAT

; 143  : {

	push	ebp
	mov	ebp, esp

; 144  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_f

; 145  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_f

; 146  :   { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 147  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+36], ecx

; 151  : }

	pop	ebp
	ret	0
$LN2@set_next_f:

; 148  :   }
; 149  :   else
; 150  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+40], eax
$LN1@set_next_f:

; 151  : }

	pop	ebp
	ret	0
_set_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_edge_wrap
EXTRN	_dymem:DWORD
EXTRN	_sym_inverse:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_wrap$ = 12						; size = 4
_set_edge_wrap PROC					; COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp

; 158  :  *EINT(e_id,E_WRAP_ATTR) =  inverted(e_id)  ? (*sym_inverse)(wrap) : wrap ;

	mov	eax, DWORD PTR _wrap$[ebp]
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN4@set_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@set_edge_w:
	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+esi+784]
	mov	DWORD PTR [edx+ecx], eax
	pop	esi

; 159  : }

	pop	ebp
	ret	0
_set_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_get_edge_wrap
; Function compile flags: /Ogtp
;	COMDAT _get_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_wrap PROC					; COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  :   WRAPTYPE wrap = *EINT(e_id,E_WRAP_ATTR) ;

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+784]
	mov	eax, DWORD PTR [eax+edx]
	pop	esi

; 165  :   return    ( inverted(e_id) ? (*sym_inverse)(wrap) : wrap );

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN4@get_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@get_edge_w:

; 166  : }

	pop	ebp
	ret	0
_get_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_set_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _set_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_edge_fe PROC					; COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp

; 172  :   if ( inverted(e_id) ) invert(fe);

	mov	eax, DWORD PTR _e_id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN1@set_edge_f
	xor	DWORD PTR _fe$[ebp], 134217728		; 08000000H
$LN1@set_edge_f:

; 173  :   eptr(e_id)->fe_id = fe;

	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 174  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 175  : }

	pop	ebp
	ret	0
_set_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_set_edge_tailv
EXTRN	_insert_vertex_edge:PROC
EXTRN	_remove_vertex_edge:PROC
; Function compile flags: /Ogtp
;	COMDAT _set_edge_tailv
_TEXT	SEGMENT
tv225 = -4						; size = 4
_e_id$ = 8						; size = 4
_v_id$ = 12						; size = 4
_set_edge_tailv PROC					; COMDAT

; 210  : { vertex_id oldv;

	push	ebp
	mov	ebp, esp
	push	ecx

; 211  : 
; 212  :   /* make sure edge not in loop of old vertex */
; 213  :   oldv = get_edge_tailv(e_id);

	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR _web+216
	push	ebx
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	mov	eax, esi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	push	edi
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR tv225[ebp], eax
	je	SHORT $LN7@set_edge_t
	mov	ebx, DWORD PTR _web+636
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	add	eax, DWORD PTR [ecx+edi+304]
	mov	eax, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN6@set_edge_t
$LN7@set_edge_t:
	mov	ebx, DWORD PTR [ecx+edi+304]
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+ebx]
$LN6@set_edge_t:

; 214  :   if ( valid_id(oldv) && !equal_id(oldv,v_id) )

	mov	ebx, DWORD PTR _v_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN10@set_edge_t
	cmp	eax, ebx
	je	SHORT $LN10@set_edge_t

; 215  :     remove_vertex_edge(oldv,e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	eax
	call	_remove_vertex_edge
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	add	esp, 8
$LN10@set_edge_t:

; 216  : 
; 217  :   if ( inverted(e_id) )

	cmp	DWORD PTR tv225[ebp], 0

; 218  :      get_edge_vertices(e_id)[web.headvnum] = v_id;

	mov	edx, DWORD PTR [esi+edx]
	je	SHORT $LN2@set_edge_t
	add	edx, DWORD PTR [ecx+edi+304]
	mov	eax, DWORD PTR _web+636
	mov	DWORD PTR [edx+eax*4], ebx

; 219  :   else

	jmp	SHORT $LN1@set_edge_t
$LN2@set_edge_t:

; 220  :      get_edge_vertices(e_id)[0] = v_id;

	mov	eax, DWORD PTR [ecx+edi+304]
	mov	DWORD PTR [edx+eax], ebx
$LN1@set_edge_t:

; 221  :   insert_vertex_edge(v_id,e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	ebx
	call	_insert_vertex_edge

; 222  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	esp, 8
	pop	edi
	inc	eax
	pop	esi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	ebx

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_set_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_set_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _set_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_v_id$ = 12						; size = 4
_set_edge_headv PROC					; COMDAT

; 229  : {

	push	ebp
	mov	ebp, esp

; 230  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]
	push	esi

; 231  :      get_edge_vertices(e_id)[0] = v_id;

	mov	esi, DWORD PTR _dymem
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_edge_h
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+216
	mov	esi, DWORD PTR [ecx+esi+304]
	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	DWORD PTR [edx+esi], ecx

; 232  :   else

	jmp	SHORT $LN1@set_edge_h
$LN2@set_edge_h:

; 233  :      get_edge_vertices(e_id)[web.headvnum] = v_id;

	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	add	edx, DWORD PTR [ecx+esi+304]
	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	esi, DWORD PTR _web+636
	mov	DWORD PTR [edx+esi*4], ecx
$LN1@set_edge_h:

; 234  :   insert_vertex_edge(v_id,inverse_id(e_id));

	xor	eax, 134217728				; 08000000H
	push	eax
	push	ecx
	call	_insert_vertex_edge

; 235  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	esp, 8
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	esi

; 236  : }

	pop	ebp
	ret	0
_set_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_@2
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_@2:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_@2
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_@2:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	_get_body_facet
; Function compile flags: /Ogtp
;	COMDAT _get_body_facet
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_facet PROC					; COMDAT

; 279  : { return ( valid_id(b_id) ? bptr(b_id)->f_id : NULLID ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+400]
	pop	ebp
	ret	0
$LN3@get_body_f:
	xor	eax, eax
	pop	ebp
	ret	0
_get_body_facet ENDP
_TEXT	ENDS
PUBLIC	_get_vertex_fe
; Function compile flags: /Ogtp
;	COMDAT _get_vertex_fe
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_get_vertex_fe PROC					; COMDAT

; 287  : { facet_id fe;

	push	ebp
	mov	ebp, esp

; 288  :   edge_id start_e, xx_id=vptr(v_id)->e_id;

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 289  :   // might be bare edge, so seek along edge loop
; 290  :   if ( !valid_id(xx_id) ) return NULLID;

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN4@get_vertex
	xor	eax, eax

; 299  : }

	pop	ebp
	ret	0
$LN4@get_vertex:
	push	esi

; 291  :   fe = eptr(xx_id)->fe_id;

	mov	esi, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	push	edi

; 292  :   start_e = xx_id;
; 293  :   while ( !valid_id(fe) )

	test	edx, 268435456				; 10000000H
	jne	SHORT $LN2@get_vertex
	mov	edi, eax
	or	edi, 134217728				; 08000000H
	npad	8
$LL3@get_vertex:

; 294  :   { xx_id = get_next_tail_edge(xx_id);

	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	eax, DWORD PTR [ecx+eax*4+32]

; 295  :     if ( equal_element(xx_id,start_e) ) return NULLID;

	mov	edx, eax
	or	edx, 134217728				; 08000000H
	cmp	edx, edi
	je	SHORT $LN10@get_vertex

; 296  :     fe = eptr(xx_id)->fe_id;

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	test	edx, 268435456				; 10000000H
	je	SHORT $LL3@get_vertex
$LN2@get_vertex:

; 297  :   }
; 298  :   return  same_sign(fe,xx_id);

	and	eax, 134217728				; 08000000H
	pop	edi
	xor	eax, edx
	pop	esi

; 299  : }

	pop	ebp
	ret	0
$LN10@get_vertex:
	pop	edi

; 295  :     if ( equal_element(xx_id,start_e) ) return NULLID;

	xor	eax, eax
	pop	esi

; 299  : }

	pop	ebp
	ret	0
_get_vertex_fe ENDP
_TEXT	ENDS
PUBLIC	_set_body_facet
; Function compile flags: /Ogtp
;	COMDAT _set_body_facet
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_f_id$ = 12						; size = 4
_set_body_facet PROC					; COMDAT

; 302  : {  if ( valid_id(b_id) )  bptr(b_id)->f_id = (f_id); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _f_id$[ebp]
	mov	DWORD PTR [edx+400], eax
$LN1@set_body_f:
	pop	ebp
	ret	0
_set_body_facet ENDP
_TEXT	ENDS
PUBLIC	_get_meth_offset
; Function compile flags: /Ogtp
;	COMDAT _get_meth_offset
_TEXT	SEGMENT
_type$ = 8						; size = 4
_get_meth_offset PROC					; COMDAT

; 376  : { int meth_offset;

	push	ebp
	mov	ebp, esp

; 377  :   meth_offset = EXTRAS(type)[web.meth_attr[type]].offset; 

	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR _web[eax*4+5664]
	imul	eax, 112				; 00000070H

; 378  :   return meth_offset;

	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR [ecx+edx+64]

; 379  : }

	pop	ebp
	ret	0
_get_meth_offset ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@3fc0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_0L@CNPEKLEL@TRIREVIS?4C?$AA@		; `string'
PUBLIC	??_C@_0DJ@PKKAKKLI@Can?8t?5refine?5in?5Lagrange?5model?5w@ ; `string'
PUBLIC	??_C@_0CM@PIKNH@No?5refining?5in?5simplex?5Lagrange?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_local_refine
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	_bare_edge_count:DWORD
EXTRN	_autochop_length:QWORD
EXTRN	_reflevel:DWORD
EXTRN	_free_matrix:PROC
EXTRN	_sym_flags:DWORD
EXTRN	_set_facet_fe:PROC
EXTRN	_new_vertex:PROC
EXTRN	_free_element:PROC
EXTRN	_cross_cut:PROC
EXTRN	_sym_compose:DWORD
EXTRN	_sym_wrap:DWORD
EXTRN	_bezier_refine_2d:BYTE
EXTRN	_bezier_flag:DWORD
EXTRN	_kb_dmatrix:PROC
EXTRN	_edge_divide:PROC
EXTRN	_generate_all:PROC
EXTRN	_NULLEDGE:DWORD
EXTRN	__imp__MsgWaitForMultipleObjects@20:PROC
EXTRN	_graphmutex:DWORD
EXTRN	_locking_thread:DWORD
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	_refine_all_simplices:PROC
EXTRN	_extend:PROC
EXTRN	_kb_error:PROC
EXTRN	_mat2d_setup:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3fc0000000000000
CONST	SEGMENT
__real@3fc0000000000000 DQ 03fc0000000000000r	; 0.125
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_0L@CNPEKLEL@TRIREVIS?4C?$AA@
CONST	SEGMENT
??_C@_0L@CNPEKLEL@TRIREVIS?4C?$AA@ DB 'TRIREVIS.C', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@PKKAKKLI@Can?8t?5refine?5in?5Lagrange?5model?5w@
CONST	SEGMENT
??_C@_0DJ@PKKAKKLI@Can?8t?5refine?5in?5Lagrange?5model?5w@ DB 'Can''t ref'
	DB	'ine in Lagrange model with no_refine edge yet.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PIKNH@No?5refining?5in?5simplex?5Lagrange?5@
CONST	SEGMENT
??_C@_0CM@PIKNH@No?5refining?5in?5simplex?5Lagrange?5@ DB 'No refining in'
	DB	' simplex Lagrange model yet.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\trirevis.c
CONST	ENDS
;	COMDAT _local_refine
_TEXT	SEGMENT
_vxqXvS$ = -4024					; size = 24
_w3$ = -4000						; size = 4
tv8728 = -3996						; size = 4
_facet_bdry_flag$89308 = -3996				; size = 4
_w2$ = -3992						; size = 4
_vx$ = -3988						; size = 4
_sentinel$ = -3984					; size = 4
_oldp$ = -3980						; size = 4
tv10902 = -3976						; size = 4
_did_graphlock_here$89143 = -3976			; size = 4
tv10271 = -3972						; size = 4
tv5974 = -3972						; size = 4
tv5356 = -3972						; size = 4
_interp$ = -3968					; size = 4
_w6$ = -3964						; size = 4
_w5$ = -3960						; size = 4
tv11579 = -3956						; size = 4
tv8654 = -3956						; size = 4
_w4$ = -3952						; size = 4
tv5250 = -3948						; size = 8
_attr$89068 = -3948					; size = 8
tv10266 = -3944						; size = 4
tv6321 = -3944						; size = 4
tv5767 = -3944						; size = 4
tv5675 = -3944						; size = 4
tv5629 = -3944						; size = 4
_vp$89565 = -3944					; size = 4
_vx$89546 = -3944					; size = 4
tv11577 = -3940						; size = 4
tv8530 = -3940						; size = 4
tv11598 = -3936						; size = 4
tv8569 = -3936						; size = 4
_oldx$ = -3932						; size = 4
tv8321 = -3928						; size = 4
tv7883 = -3928						; size = 4
tv7228 = -3928						; size = 4
_v1$89305 = -3928					; size = 4
_next_fe$89201 = -3928					; size = 4
_f_id$ = -3924						; size = 4
tv11554 = -3920						; size = 4
tv10760 = -3920						; size = 4
tv8712 = -3920						; size = 4
_oldctrl$89301 = -3920					; size = 4
tv11653 = -3916						; size = 4
tv10758 = -3916						; size = 4
tv8944 = -3916						; size = 4
tv8590 = -3916						; size = 4
tv5649 = -3916						; size = 4
_fe$89200 = -3912					; size = 4
_q$89159 = -3912					; size = 4
_e_id$ = -3908						; size = 4
tv11394 = -3904						; size = 4
tv11362 = -3904						; size = 4
tv10920 = -3904						; size = 4
tv10676 = -3904						; size = 4
tv9137 = -3904						; size = 4
tv8710 = -3904						; size = 4
tv5646 = -3904						; size = 4
_fewrap$89213 = -3904					; size = 4
tv10756 = -3900						; size = 4
tv8942 = -3900						; size = 4
tv5643 = -3900						; size = 4
_v3$89307 = -3900					; size = 4
_i$89160 = -3900					; size = 4
tv6062 = -3896						; size = 4
tv5644 = -3896						; size = 4
_v2$89306 = -3896					; size = 4
_wrap$89212 = -3896					; size = 4
_i$89202 = -3896					; size = 4
_p$89158 = -3896					; size = 4
tv11646 = -3892						; size = 4
tv11364 = -3892						; size = 4
tv10867 = -3892						; size = 4
tv10864 = -3892						; size = 4
tv10861 = -3892						; size = 4
tv10824 = -3892						; size = 4
tv10822 = -3892						; size = 4
tv10819 = -3892						; size = 4
tv10784 = -3892						; size = 4
tv10782 = -3892						; size = 4
tv10779 = -3892						; size = 4
tv8940 = -3892						; size = 4
_v$89303 = -3892					; size = 4
_j$89203 = -3892					; size = 4
_c$89165 = -3892					; size = 4
_b$89164 = -3892					; size = 4
_a$89163 = -3892					; size = 4
_N$ = -3888						; size = 4
tv11052 = -3884						; size = 4
tv10856 = -3884						; size = 4
tv10853 = -3884						; size = 4
tv10851 = -3884						; size = 4
tv10847 = -3884						; size = 4
tv10845 = -3884						; size = 4
tv10842 = -3884						; size = 4
tv10839 = -3884						; size = 4
tv10836 = -3884						; size = 4
tv10834 = -3884						; size = 4
tv10831 = -3884						; size = 4
tv10814 = -3884						; size = 4
tv10811 = -3884						; size = 4
tv10809 = -3884						; size = 4
tv10806 = -3884						; size = 4
tv10804 = -3884						; size = 4
tv10801 = -3884						; size = 4
tv10799 = -3884						; size = 4
tv10796 = -3884						; size = 4
tv10793 = -3884						; size = 4
tv10790 = -3884						; size = 4
tv10774 = -3884						; size = 4
tv10771 = -3884						; size = 4
tv10769 = -3884						; size = 4
tv10766 = -3884						; size = 4
tv10764 = -3884						; size = 4
tv10759 = -3884						; size = 4
tv10755 = -3884						; size = 4
tv10752 = -3884						; size = 4
tv10750 = -3884						; size = 4
tv10747 = -3884						; size = 4
tv10010 = -3884						; size = 4
tv9957 = -3884						; size = 4
tv9691 = -3884						; size = 4
tv9621 = -3884						; size = 4
tv9357 = -3884						; size = 4
tv9287 = -3884						; size = 4
tv9105 = -3884						; size = 4
tv8510 = -3884						; size = 4
tv8104 = -3884						; size = 4
tv8072 = -3884						; size = 4
tv7666 = -3884						; size = 4
tv7634 = -3884						; size = 4
tv7445 = -3884						; size = 4
tv5655 = -3884						; size = 4
tv2465 = -3884						; size = 4
tv2098 = -3884						; size = 4
_v0$89304 = -3884					; size = 4
tv457 = -3884						; size = 4
_vxxJ$ = -3880						; size = 288
_wraps$ = -3592						; size = 1764
_allv$ = -1828						; size = 1764
_newx$89616 = -64					; size = 48
_x$89206 = -64						; size = 48
_newf$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_local_refine PROC					; COMDAT

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 4024				; 00000fb8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 43   :   vertex_id v_id;
; 44   :   edge_id e_id;
; 45   :   element_id sentinel;
; 46   :   facet_id f_id;
; 47   :   MAT2D(vx,FACET_CTRL,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _vxxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vxqXvS$[ebp]
	push	ecx
	call	_mat2d_setup

; 48   :   REAL **interp=NULL,**oldx=NULL,**oldp=NULL;
; 49   :   facet_id newf[FACET_EDGES];
; 50   :   vertex_id allv[MAXLAGRANGE+1][MAXLAGRANGE+1];
; 51   :   WRAPTYPE wraps[MAXLAGRANGE+1][MAXLAGRANGE+1];
; 52   :   WRAPTYPE w2=0,w3=0,w4=0,w5=0,w6=0;
; 53   :   int N = web.lagrange_order;

	mov	edx, DWORD PTR _web+632
	xor	ebx, ebx
	mov	DWORD PTR _vx$[ebp], eax

; 54   :   int type;
; 55   :  
; 56   :   /* check impediments to Lagrange model refining */
; 57   :   if ( web.modeltype == LAGRANGE )

	mov	eax, 3
	add	esp, 16					; 00000010H
	mov	DWORD PTR _interp$[ebp], ebx
	mov	DWORD PTR _oldx$[ebp], ebx
	mov	DWORD PTR _oldp$[ebp], ebx
	mov	DWORD PTR _w2$[ebp], ebx
	mov	DWORD PTR _w3$[ebp], ebx
	mov	DWORD PTR _w4$[ebp], ebx
	mov	DWORD PTR _w5$[ebp], ebx
	mov	DWORD PTR _w6$[ebp], ebx
	mov	DWORD PTR _N$[ebp], edx
	cmp	DWORD PTR _web+628, eax
	jne	$LN732@local_refi

; 58   :   { if ( web.representation == SIMPLEX) 

	cmp	DWORD PTR _web+624, eax
	jne	SHORT $LN296@local_refi

; 59   :     kb_error(1338,"No refining in simplex Lagrange model yet.\n",RECOVERABLE );

	push	1
	push	OFFSET ??_C@_0CM@PIKNH@No?5refining?5in?5simplex?5Lagrange?5@
	push	1338					; 0000053aH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN296@local_refi:

; 60   :     if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	jne	$LN732@local_refi

; 61   :     { FOR_ALL_EDGES(e_id)

	mov	esi, DWORD PTR _web+160
	mov	DWORD PTR _e_id$[ebp], esi
	test	esi, 268435456				; 10000000H
	je	SHORT $LN732@local_refi
$LL294@local_refi:
	mov	ecx, DWORD PTR _web+124
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edi, DWORD PTR [eax+12]
	mov	eax, ecx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN293@local_refi

; 62   :       { ATTR attr = get_eattr(e_id);
; 63   :         if ( (attr & NO_REFINE) && !(attr & BARE_EDGE) )

	mov	eax, ecx
	and	eax, 16777216				; 01000000H
	or	eax, edx
	mov	DWORD PTR _attr$89068[ebp+4], edi
	je	SHORT $LN293@local_refi
	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN293@local_refi

; 64   :           kb_error(2195,
; 65   :            "Can't refine in Lagrange model with no_refine edge yet.\n",
; 66   :               RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DJ@PKKAKKLI@Can?8t?5refine?5in?5Lagrange?5model?5w@
	push	2195					; 00000893H
	call	_kb_error
	mov	esi, DWORD PTR _e_id$[ebp]
	add	esp, 12					; 0000000cH
$LN293@local_refi:

; 61   :     { FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _e_id$[ebp], esi
	test	esi, 268435456				; 10000000H
	jne	SHORT $LL294@local_refi
$LN732@local_refi:

; 67   :       }
; 68   :     }
; 69   :   }
; 70   : 
; 71   :   web.vol_flag = 0;
; 72   :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp

; 73   : 
; 74   :   /* clean out NEW flags */
; 75   :   MFOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	mov	edi, DWORD PTR _web+12
	inc	eax
	mov	DWORD PTR _web+896, ebx
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	ebx, -5					; fffffffbH
	test	edx, 268435456				; 10000000H
	je	SHORT $LN286@local_refi
$LL288@local_refi:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	esi, esi
	or	ecx, esi
	je	SHORT $LN287@local_refi

; 76   :      unset_attr(v_id,NEWVERTEX);

	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx+12]
	and	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], edx
	mov	edi, DWORD PTR _web+12
$LN287@local_refi:

; 73   : 
; 74   :   /* clean out NEW flags */
; 75   :   MFOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL288@local_refi
$LN286@local_refi:

; 77   :   MFOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	mov	DWORD PTR _e_id$[ebp], edx
	test	edx, 268435456				; 10000000H
	je	SHORT $LN281@local_refi
	mov	edi, DWORD PTR _web+124
$LL283@local_refi:
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN282@local_refi

; 78   :      unset_attr(e_id,NEWEDGE);

	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [ecx+12]
	and	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _e_id$[ebp]
	mov	edi, DWORD PTR _web+124
$LN282@local_refi:

; 77   :   MFOR_ALL_EDGES(e_id)

	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _e_id$[ebp], edx
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL283@local_refi
	mov	edi, DWORD PTR _web+12
$LN281@local_refi:

; 79   :   MFOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	mov	DWORD PTR _f_id$[ebp], edx
	test	edx, 268435456				; 10000000H
	je	SHORT $LN276@local_refi
	mov	edi, DWORD PTR _web+236
	npad	4
$LL278@local_refi:
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN277@local_refi

; 80   :      unset_attr(f_id,NEWFACET);

	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [ecx+12]
	and	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _f_id$[ebp]
	mov	edi, DWORD PTR _web+236
$LN277@local_refi:

; 79   :   MFOR_ALL_FACETS(f_id)

	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _f_id$[ebp], edx
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL278@local_refi
	mov	edi, DWORD PTR _web+12
$LN276@local_refi:

; 81   : 
; 82   :   if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	jne	$LN270@local_refi

; 83   :   { /* save in oldcoord attribute */
; 84   :     MFOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	$LN270@local_refi
	npad	5
$LL272@local_refi:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR [esi+edi]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	mov	DWORD PTR tv5250[ebp+4], edx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN271@local_refi

; 85   :     { if ( get_vattr(v_id) & BOUNDARY )

	and	ecx, 128				; 00000080H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN267@local_refi

; 86   :         memcpy((char *)(get_force(v_id)),(char *)get_param(v_id),
; 87   :                                            sizeof(REAL)*web.maxparam);

	mov	edx, DWORD PTR _web+640
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	mov	edi, DWORD PTR [esi+edi]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	mov	edx, DWORD PTR [eax+ecx+544]
	mov	eax, DWORD PTR [eax+ecx+784]
	add	edx, edi
	push	edx
	add	eax, edi
	push	eax
	call	_memcpy
	mov	edi, DWORD PTR _web+12
	add	esp, 12					; 0000000cH
$LN267@local_refi:

; 88   :   
; 89   :         memcpy((char *)(get_oldcoord(v_id)),(char *)get_coord(v_id),
; 90   :                                            sizeof(REAL)*SDIM);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	mov	edi, DWORD PTR [esi+edi]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR [eax+ecx+304]
	add	edx, edi
	push	edx
	add	eax, edi
	push	eax
	call	_memcpy
	mov	edi, DWORD PTR _web+12
	add	esp, 12					; 0000000cH
$LN271@local_refi:

; 83   :   { /* save in oldcoord attribute */
; 84   :     MFOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	jne	$LL272@local_refi
$LN270@local_refi:

; 91   :     }
; 92   :   }
; 93   : 
; 94   :   /* allocate room for new elements */
; 95   :   for ( type = VERTEX ; type <= FACETEDGE ; type++ )

	xor	esi, esi
	lea	edi, DWORD PTR [esi+1]
$LL266@local_refi:

; 96   :    extend(type,EXTEND_FOR_REFINE);

	push	2
	push	esi
	call	_extend
	add	esi, edi
	add	esp, 8
	cmp	esi, 4
	jle	SHORT $LL266@local_refi

; 97   : 
; 98   :   if ( web.representation == SIMPLEX ) 

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN263@local_refi

; 99   :   { refine_all_simplices(); 

	call	_refine_all_simplices

; 100  :     if ( web.dimension > 2 )

	mov	eax, DWORD PTR _web+620
	cmp	eax, 2
	jle	$LN1@local_refi

; 101  :          web.maxscale *= 1 << (web.dimension-2);

	lea	ecx, DWORD PTR [eax-2]
	shl	edi, cl
	mov	DWORD PTR tv10902[ebp], edi
	fild	DWORD PTR tv10902[ebp]
	pop	edi
	pop	esi
	pop	ebx
	fmul	QWORD PTR _web+1528
	fstp	QWORD PTR _web+1528

; 555  : 
; 556  : } /* end refine() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN263@local_refi:

; 102  :     return;
; 103  :   }
; 104  : 
; 105  :   ENTER_GRAPH_MUTEX;

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN261@local_refi
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	edi
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89143[ebp], edi
	jmp	SHORT $LN260@local_refi
$LN261@local_refi:
	mov	DWORD PTR _did_graphlock_here$89143[ebp], 0
$LN260@local_refi:

; 106  : 
; 107  :   /* first, subdivide all edges */
; 108  :   e_id = NULLEDGE;

	mov	edx, DWORD PTR _NULLEDGE

; 109  :   while ( generate_all(EDGE,&e_id,&sentinel) )

	lea	eax, DWORD PTR _sentinel$[ebp]
	push	eax
	lea	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	edi
	mov	DWORD PTR _e_id$[ebp], edx
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN258@local_refi
$LL259@local_refi:

; 110  :   { if ( get_eattr(e_id) & (NEWEDGE|NO_REFINE) ) continue;

	mov	edx, DWORD PTR _e_id$[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 16777220				; 01000004H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN662@local_refi

; 111  :     edge_divide(e_id);

	push	edx
	call	_edge_divide
	add	esp, 4
$LN662@local_refi:

; 109  :   while ( generate_all(EDGE,&e_id,&sentinel) )

	lea	edx, DWORD PTR _sentinel$[ebp]
	push	edx
	lea	eax, DWORD PTR _e_id$[ebp]
	push	eax
	push	edi
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LL259@local_refi
$LN258@local_refi:

; 112  :   }
; 113  : 
; 114  :   #ifdef MPI_EVOLVER
; 115  :   mpi_refine_edge_synch();
; 116  :   #endif
; 117  : 
; 118  :   if ( web.representation == STRING ) goto windup; 

	cmp	DWORD PTR _web+624, edi
	je	$windup$89154

; 119  :   /* don't want to subdivide facets */
; 120  :      
; 121  :   if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	jne	$LN250@local_refi

; 124  :     int oldctrl = web.skel[FACET].ctrlpts;
; 125  :     int p,q,i,j,k,a,b,c;
; 126  :      
; 127  :     oldx = dmatrix(0,oldctrl,0,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	esi, DWORD PTR _web+232
	push	127					; 0000007fH
	push	OFFSET ??_C@_0L@CNPEKLEL@TRIREVIS?4C?$AA@
	push	ecx
	push	0
	push	esi
	push	0
	call	_kb_dmatrix

; 128  :     oldp = dmatrix(0,oldctrl,0,SDIM);

	mov	edx, DWORD PTR _web+616
	push	128					; 00000080H
	push	OFFSET ??_C@_0L@CNPEKLEL@TRIREVIS?4C?$AA@
	push	edx
	push	0
	push	esi
	push	0
	mov	DWORD PTR _oldx$[ebp], eax
	call	_kb_dmatrix
	add	esp, 48					; 00000030H

; 129  :     if ( bezier_flag )

	cmp	DWORD PTR _bezier_flag, 0
	mov	DWORD PTR _oldp$[ebp], eax

; 130  :       interp = bezier_refine_2d[N]; 

	mov	eax, DWORD PTR _N$[ebp]
	je	SHORT $LN254@local_refi
	mov	ecx, DWORD PTR _bezier_refine_2d[eax*4]
	mov	DWORD PTR _interp$[ebp], ecx

; 131  :     else /* regular lagrange */

	jmp	$LN250@local_refi
$LN254@local_refi:

; 122  :   { /* interpolation matrix */
; 123  :     int newctrl = (2*N+1)*(N+1);

	lea	ebx, DWORD PTR [eax+eax]
	inc	eax
	lea	edx, DWORD PTR [ebx+1]

; 132  :     { interp = dmatrix(0,newctrl,0,oldctrl);

	push	132					; 00000084H
	imul	edx, eax
	push	OFFSET ??_C@_0L@CNPEKLEL@TRIREVIS?4C?$AA@
	push	esi
	push	0
	push	edx
	push	0
	mov	DWORD PTR tv5356[ebp], ebx
	call	_kb_dmatrix
	add	esp, 24					; 00000018H
	mov	DWORD PTR _interp$[ebp], eax

; 133  :       for ( p = 1 ; p < 2*N ; p++ ) 

	mov	DWORD PTR _p$89158[ebp], edi
	cmp	ebx, 1
	jle	$LN250@local_refi
	fld1
$LN783@local_refi:

; 134  :         for ( q = 1 ; p+q < 2*N ; q++ ) 

	mov	eax, DWORD PTR _p$89158[ebp]
	inc	eax
	mov	DWORD PTR _q$89159[ebp], 1
	mov	DWORD PTR tv5629[ebp], eax
	cmp	eax, ebx
	jge	$LN251@local_refi

; 135  :         { REAL x,y,z,prod;
; 136  :           x = p/2.; y = q/2.; z = N - x - y;

	fild	DWORD PTR _p$89158[ebp]
	mov	ecx, DWORD PTR _N$[ebp]
	mov	DWORD PTR tv8710[ebp], ebx
	mov	DWORD PTR tv8712[ebp], 2
	fmul	QWORD PTR __real@3fe0000000000000
	fild	DWORD PTR _N$[ebp]
	fsub	ST(0), ST(1)
$LN749@local_refi:
	fild	DWORD PTR _q$89159[ebp]

; 137  :           for ( i = 0 ; i <= N ; i++ )

	xor	esi, esi
	mov	DWORD PTR _i$89160[ebp], esi
	fmul	QWORD PTR __real@3fe0000000000000
	fld	ST(1)
	fsub	ST(0), ST(1)
	test	ecx, ecx
	js	$LN831@local_refi

; 135  :         { REAL x,y,z,prod;
; 136  :           x = p/2.; y = q/2.; z = N - x - y;

	mov	DWORD PTR tv8654[ebp], ecx
$LN246@local_refi:

; 138  :             for ( j = 0 ; i+j <= N ; j++ )

	xor	edi, edi
	cmp	esi, ecx
	jg	$LN245@local_refi
	mov	eax, DWORD PTR tv8712[ebp]
	imul	eax, DWORD PTR _q$89159[ebp]
	mov	ebx, DWORD PTR tv8654[ebp]
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _interp$[ebp]
	sar	eax, 1
	add	eax, DWORD PTR tv8710[ebp]
	mov	DWORD PTR tv8530[ebp], edi
	add	eax, DWORD PTR _p$89158[ebp]
	mov	DWORD PTR tv8569[ebp], 3
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv8728[ebp], eax
	mov	DWORD PTR tv8590[ebp], ebx
$LN243@local_refi:

; 140  :               prod = 1.0;
; 141  :               for ( a = 0 ; a < i ; a++ ) prod *= (x-a)/(REAL)(i-a);

	xor	edx, edx
	fld	ST(4)
	mov	DWORD PTR _a$89163[ebp], edx
	cmp	esi, 8
	jl	$LC724@local_refi

; 139  :             { k = N - i - j;

	add	esi, -7					; fffffff9H
	mov	ecx, 2
	lea	eax, DWORD PTR [esi+5]
	mov	DWORD PTR tv7228[ebp], ecx
	mov	DWORD PTR tv7445[ebp], eax

; 140  :               prod = 1.0;
; 141  :               for ( a = 0 ; a < i ; a++ ) prod *= (x-a)/(REAL)(i-a);

$LN725@local_refi:
	fild	DWORD PTR _a$89163[ebp]
	lea	ebx, DWORD PTR [eax+2]
	mov	DWORD PTR tv10867[ebp], ebx
	lea	ebx, DWORD PTR [ecx-1]
	fsubr	ST(0), ST(5)
	add	edx, 8
	fild	DWORD PTR tv10867[ebp]
	mov	DWORD PTR tv10864[ebp], ebx
	lea	ebx, DWORD PTR [eax+1]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10864[ebp]
	mov	DWORD PTR tv10861[ebp], ebx
	lea	ebx, DWORD PTR [ecx+1]
	fsubr	ST(0), ST(5)
	fild	DWORD PTR tv10861[ebp]
	mov	DWORD PTR _a$89163[ebp], edx
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv7228[ebp]
	fsubr	ST(0), ST(5)
	fidiv	DWORD PTR tv7445[ebp]
	mov	DWORD PTR tv10856[ebp], ebx
	lea	ebx, DWORD PTR [eax-1]
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10856[ebp]
	mov	DWORD PTR tv10853[ebp], ebx
	lea	ebx, DWORD PTR [ecx+2]
	fsubr	ST(0), ST(5)
	fild	DWORD PTR tv10853[ebp]
	mov	DWORD PTR tv10851[ebp], ebx
	lea	ebx, DWORD PTR [eax-2]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10851[ebp]
	mov	DWORD PTR tv10847[ebp], ebx
	lea	ebx, DWORD PTR [ecx+3]
	fsubr	ST(0), ST(5)
	fild	DWORD PTR tv10847[ebp]
	mov	DWORD PTR tv10845[ebp], ebx
	lea	ebx, DWORD PTR [eax-3]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10845[ebp]
	mov	DWORD PTR tv10842[ebp], ebx
	lea	ebx, DWORD PTR [ecx+4]
	fsubr	ST(0), ST(5)
	fild	DWORD PTR tv10842[ebp]
	mov	DWORD PTR tv10839[ebp], ebx
	lea	ebx, DWORD PTR [eax-4]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10839[ebp]
	mov	DWORD PTR tv10836[ebp], ebx
	lea	ebx, DWORD PTR [ecx+5]
	add	ecx, 8
	fsubr	ST(0), ST(5)
	mov	DWORD PTR tv7228[ebp], ecx
	fild	DWORD PTR tv10836[ebp]
	mov	DWORD PTR tv10834[ebp], ebx
	lea	ebx, DWORD PTR [eax-5]
	sub	eax, 8
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10834[ebp]
	mov	DWORD PTR tv10831[ebp], ebx
	fsubr	ST(0), ST(5)
	fild	DWORD PTR tv10831[ebp]
	mov	DWORD PTR tv7445[ebp], eax
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	cmp	edx, esi
	jl	$LN725@local_refi
	mov	esi, DWORD PTR _i$89160[ebp]
	mov	ecx, DWORD PTR _N$[ebp]
	mov	ebx, DWORD PTR tv8590[ebp]
$LC724@local_refi:
	cmp	edx, esi
	jge	SHORT $LN723@local_refi
	mov	eax, esi
	sub	eax, edx
	mov	DWORD PTR tv7634[ebp], eax
$LC240@local_refi:
	fild	DWORD PTR _a$89163[ebp]
	inc	edx
	dec	eax
	mov	DWORD PTR _a$89163[ebp], edx
	fsubr	ST(0), ST(5)
	fidiv	DWORD PTR tv7634[ebp]
	mov	DWORD PTR tv7634[ebp], eax
	fmulp	ST(1), ST(0)
	cmp	edx, esi
	jl	SHORT $LC240@local_refi
$LN723@local_refi:

; 142  :               for ( b = 0 ; b < j ; b++ ) prod *= (y-b)/(REAL)(j-b);

	xor	edx, edx
	mov	DWORD PTR _b$89164[ebp], edx
	cmp	edi, 8
	jl	$LC727@local_refi
	lea	esi, DWORD PTR [edi-2]
	mov	ecx, 2
	mov	DWORD PTR tv7666[ebp], ecx
	mov	eax, esi
	mov	DWORD PTR tv7883[ebp], esi
$LN728@local_refi:
	fild	DWORD PTR _b$89164[ebp]
	lea	ebx, DWORD PTR [eax+2]
	mov	DWORD PTR tv10824[ebp], ebx
	lea	ebx, DWORD PTR [ecx-1]
	fsubr	ST(0), ST(3)
	add	edx, 8
	fild	DWORD PTR tv10824[ebp]
	mov	DWORD PTR tv10822[ebp], ebx
	lea	ebx, DWORD PTR [eax+1]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10822[ebp]
	mov	DWORD PTR tv10819[ebp], ebx
	lea	ebx, DWORD PTR [ecx+1]
	fsubr	ST(0), ST(3)
	fild	DWORD PTR tv10819[ebp]
	mov	DWORD PTR _b$89164[ebp], edx
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv7666[ebp]
	mov	DWORD PTR tv10814[ebp], ebx
	lea	ebx, DWORD PTR [eax-1]
	fsubr	ST(0), ST(3)
	fidiv	DWORD PTR tv7883[ebp]
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10814[ebp]
	mov	DWORD PTR tv10811[ebp], ebx
	lea	ebx, DWORD PTR [ecx+2]
	fsubr	ST(0), ST(3)
	fild	DWORD PTR tv10811[ebp]
	mov	DWORD PTR tv10809[ebp], ebx
	lea	ebx, DWORD PTR [eax-2]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10809[ebp]
	mov	DWORD PTR tv10806[ebp], ebx
	lea	ebx, DWORD PTR [ecx+3]
	fsubr	ST(0), ST(3)
	fild	DWORD PTR tv10806[ebp]
	mov	DWORD PTR tv10804[ebp], ebx
	lea	ebx, DWORD PTR [eax-3]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10804[ebp]
	mov	DWORD PTR tv10801[ebp], ebx
	lea	ebx, DWORD PTR [ecx+4]
	fsubr	ST(0), ST(3)
	fild	DWORD PTR tv10801[ebp]
	mov	DWORD PTR tv10799[ebp], ebx
	lea	ebx, DWORD PTR [eax-4]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10799[ebp]
	mov	DWORD PTR tv10796[ebp], ebx
	lea	ebx, DWORD PTR [ecx+5]
	add	ecx, 8
	fsubr	ST(0), ST(3)
	fild	DWORD PTR tv10796[ebp]
	mov	DWORD PTR tv10793[ebp], ebx
	lea	ebx, DWORD PTR [eax-5]
	sub	eax, 8
	fdivp	ST(1), ST(0)
	mov	DWORD PTR tv7883[ebp], eax
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10793[ebp]
	mov	DWORD PTR tv10790[ebp], ebx
	lea	ebx, DWORD PTR [esi-5]
	fsubr	ST(0), ST(3)
	fild	DWORD PTR tv10790[ebp]
	mov	DWORD PTR tv7666[ebp], ecx
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	cmp	edx, ebx
	jl	$LN728@local_refi
	mov	esi, DWORD PTR _i$89160[ebp]
	mov	ecx, DWORD PTR _N$[ebp]
	mov	ebx, DWORD PTR tv8590[ebp]
$LC727@local_refi:
	cmp	edx, edi
	jge	SHORT $LN726@local_refi
	mov	eax, edi
	sub	eax, edx
	mov	DWORD PTR tv8072[ebp], eax
$LC237@local_refi:
	fild	DWORD PTR _b$89164[ebp]
	inc	edx
	dec	eax
	mov	DWORD PTR _b$89164[ebp], edx
	fsubr	ST(0), ST(3)
	fidiv	DWORD PTR tv8072[ebp]
	mov	DWORD PTR tv8072[ebp], eax
	fmulp	ST(1), ST(0)
	cmp	edx, edi
	jl	SHORT $LC237@local_refi
$LN726@local_refi:

; 143  :               for ( c = 0 ; c < k ; c++ ) prod *= (z-c)/(REAL)(k-c);

	xor	edx, edx
	mov	DWORD PTR _c$89165[ebp], edx
	cmp	ebx, 8
	jl	$LC730@local_refi
	mov	ecx, 2
	lea	eax, DWORD PTR [ebx-2]
	lea	esi, DWORD PTR [ebx-7]
	mov	DWORD PTR tv8104[ebp], ecx
	mov	DWORD PTR tv8321[ebp], eax
$LN731@local_refi:
	fild	DWORD PTR _c$89165[ebp]
	lea	ebx, DWORD PTR [eax+2]
	mov	DWORD PTR tv10784[ebp], ebx
	lea	ebx, DWORD PTR [ecx-1]
	fsubr	ST(0), ST(2)
	add	edx, 8
	fild	DWORD PTR tv10784[ebp]
	mov	DWORD PTR tv10782[ebp], ebx
	lea	ebx, DWORD PTR [eax+1]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10782[ebp]
	mov	DWORD PTR tv10779[ebp], ebx
	lea	ebx, DWORD PTR [ecx+1]
	fsubr	ST(0), ST(2)
	fild	DWORD PTR tv10779[ebp]
	mov	DWORD PTR _c$89165[ebp], edx
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv8104[ebp]
	mov	DWORD PTR tv10774[ebp], ebx
	lea	ebx, DWORD PTR [eax-1]
	fsubr	ST(0), ST(2)
	fidiv	DWORD PTR tv8321[ebp]
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10774[ebp]
	mov	DWORD PTR tv10771[ebp], ebx
	lea	ebx, DWORD PTR [ecx+2]
	fsubr	ST(0), ST(2)
	fild	DWORD PTR tv10771[ebp]
	mov	DWORD PTR tv10769[ebp], ebx
	lea	ebx, DWORD PTR [eax-2]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10769[ebp]
	mov	DWORD PTR tv10766[ebp], ebx
	lea	ebx, DWORD PTR [ecx+3]
	fsubr	ST(0), ST(2)
	fild	DWORD PTR tv10766[ebp]
	mov	DWORD PTR tv10764[ebp], ebx
	lea	ebx, DWORD PTR [eax-3]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10764[ebp]
	mov	DWORD PTR tv10759[ebp], ebx
	lea	ebx, DWORD PTR [ecx+4]
	fsubr	ST(0), ST(2)
	fild	DWORD PTR tv10759[ebp]
	mov	DWORD PTR tv10755[ebp], ebx
	lea	ebx, DWORD PTR [eax-4]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10755[ebp]
	mov	DWORD PTR tv10752[ebp], ebx
	lea	ebx, DWORD PTR [ecx+5]
	add	ecx, 8
	fsubr	ST(0), ST(2)
	fild	DWORD PTR tv10752[ebp]
	mov	DWORD PTR tv10750[ebp], ebx
	lea	ebx, DWORD PTR [eax-5]
	sub	eax, 8
	fdivp	ST(1), ST(0)
	mov	DWORD PTR tv8321[ebp], eax
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv10750[ebp]
	mov	DWORD PTR tv10747[ebp], ebx
	fsubr	ST(0), ST(2)
	fild	DWORD PTR tv10747[ebp]
	mov	DWORD PTR tv8104[ebp], ecx
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	cmp	edx, esi
	jl	$LN731@local_refi
	mov	esi, DWORD PTR _i$89160[ebp]
	mov	ecx, DWORD PTR _N$[ebp]
	mov	ebx, DWORD PTR tv8590[ebp]
$LC730@local_refi:
	cmp	edx, ebx
	jge	SHORT $LN729@local_refi
	mov	eax, ebx
	sub	eax, edx
	mov	DWORD PTR tv8510[ebp], eax
$LC234@local_refi:
	fild	DWORD PTR _c$89165[ebp]
	inc	edx
	dec	eax
	mov	DWORD PTR _c$89165[ebp], edx
	fsubr	ST(0), ST(2)
	fidiv	DWORD PTR tv8510[ebp]
	mov	DWORD PTR tv8510[ebp], eax
	fmulp	ST(1), ST(0)
	cmp	edx, ebx
	jl	SHORT $LC234@local_refi
$LN729@local_refi:

; 144  :               interp[p+2*N*q+(3*q-q*q)/2][i+j*N+(3*j-j*j)/2] = prod;

	mov	eax, DWORD PTR tv8569[ebp]
	imul	eax, edi
	dec	DWORD PTR tv8569[ebp]
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR tv8728[ebp]
	sar	eax, 1
	add	eax, DWORD PTR tv8530[ebp]
	add	DWORD PTR tv8530[ebp], ecx
	add	eax, esi
	inc	edi
	dec	ebx
	fstp	QWORD PTR [edx+eax*8]
	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR tv8590[ebp], ebx
	cmp	eax, ecx
	jle	$LN243@local_refi

; 138  :             for ( j = 0 ; i+j <= N ; j++ )

	mov	ebx, DWORD PTR tv5356[ebp]
$LN245@local_refi:

; 137  :           for ( i = 0 ; i <= N ; i++ )

	dec	DWORD PTR tv8654[ebp]
	inc	esi
	mov	DWORD PTR _i$89160[ebp], esi
	cmp	esi, ecx
	jle	$LN246@local_refi
$LN831@local_refi:

; 134  :         for ( q = 1 ; p+q < 2*N ; q++ ) 

	mov	eax, DWORD PTR _q$89159[ebp]

; 138  :             for ( j = 0 ; i+j <= N ; j++ )

	fstp	ST(1)
	dec	DWORD PTR tv8712[ebp]
	fstp	ST(0)
	add	DWORD PTR tv8710[ebp], ebx
	inc	eax
	mov	DWORD PTR _q$89159[ebp], eax
	add	eax, DWORD PTR _p$89158[ebp]
	cmp	eax, ebx
	jl	$LN749@local_refi
	fstp	ST(1)
	fstp	ST(0)
$LN251@local_refi:

; 133  :       for ( p = 1 ; p < 2*N ; p++ ) 

	mov	eax, DWORD PTR tv5629[ebp]
	mov	DWORD PTR _p$89158[ebp], eax
	cmp	eax, ebx
	jl	$LN783@local_refi
	fstp	ST(0)
$LN250@local_refi:

; 145  :             }
; 146  :         }
; 147  :     }
; 148  :   }
; 149  :   /* now subdivide each facet */
; 150  :   f_id = NULLFACET;

	mov	eax, DWORD PTR _NULLFACET

; 151  :   while ( generate_all(FACET,&f_id,&sentinel) )

	lea	ecx, DWORD PTR _sentinel$[ebp]
	push	ecx
	lea	edx, DWORD PTR _f_id$[ebp]
	push	edx
	push	2
	mov	DWORD PTR _f_id$[ebp], eax
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$windup$89154
	npad	7
$LL231@local_refi:

; 152  :   { facetedge_id fe;
; 153  :     facetedge_id next_fe;
; 154  :     int i,j,k,n;
; 155  :     REAL *x[2*FACET_CTRL],*xmid;
; 156  : 
; 157  :     if ( get_fattr(f_id) & NEWFACET ) continue;

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 4
	xor	edx, edx
	or	eax, edx
	jne	$LN582@local_refi

; 158  :     newf[0] = newf[1] = newf[2] = NULLFACET;

	mov	eax, DWORD PTR _NULLFACET
	mov	DWORD PTR _newf$[ebp+8], eax
	mov	DWORD PTR _newf$[ebp+4], eax
	mov	DWORD PTR _newf$[ebp], eax

; 159  : 
; 160  :     if ( web.modeltype == QUADRATIC )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	$LN228@local_refi

; 161  :     { /* will need old vertex coords for quadratic corrections */
; 162  :       int wrap,fewrap;
; 163  :       fe = get_facet_fe(f_id);

	mov	edx, DWORD PTR _f_id$[ebp]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LN307@local_refi
	xor	eax, eax
	jmp	SHORT $LN306@local_refi
$LN307@local_refi:
	mov	eax, DWORD PTR [ecx+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN306@local_refi
	xor	eax, 134217728				; 08000000H
$LN306@local_refi:

; 164  :       if ( inverted(get_fe_edge(fe)) ) fe = get_prev_edge(fe);

	mov	ecx, DWORD PTR _web+460
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [ecx+20]
	xor	edx, eax
	mov	DWORD PTR _fe$89200[ebp], eax
	test	edx, 134217728				; 08000000H
	je	SHORT $LN312@local_refi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN313@local_refi
	mov	ecx, DWORD PTR [ecx+32]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR _fe$89200[ebp], ecx
	jmp	SHORT $LN312@local_refi
$LN313@local_refi:
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _fe$89200[ebp], eax
$LN312@local_refi:

; 165  :       for ( i = 0,wrap=0 ; i < 6 ; i++ )

	mov	edi, DWORD PTR _web+124
	mov	edx, DWORD PTR _dymem
	xor	esi, esi
	xor	ebx, ebx
	mov	DWORD PTR _wrap$89212[ebp], ebx
	npad	3
$LL226@local_refi:

; 166  :       {
; 167  :          if ( get_eattr(get_fe_edge(fe)) & NO_REFINE )

	mov	eax, DWORD PTR _fe$89200[ebp]
	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv5643[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR tv5649[ebp], eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 16777216				; 01000000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN223@local_refi

; 168  :          { 
; 169  :             e_id = get_fe_edge(fe);

	mov	ecx, DWORD PTR _fe$89200[ebp]
	and	ecx, 134217728				; 08000000H
	mov	eax, ecx
	xor	eax, DWORD PTR tv5649[ebp]

; 170  :             if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	mov	DWORD PTR _e_id$[ebp], eax
	je	$LN222@local_refi

; 171  :             { REAL *y = get_coord(get_fe_tailv(fe));

	mov	eax, DWORD PTR _web+460
	mov	ebx, DWORD PTR tv5643[ebp]
	mov	eax, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [eax+20]
	xor	eax, ecx
	test	eax, 134217728				; 08000000H
	je	SHORT $LN323@local_refi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _web+216
	add	ecx, DWORD PTR [eax+edx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN322@local_refi
$LN323@local_refi:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edx+304]
	mov	eax, DWORD PTR [ecx+eax]
$LN322@local_refi:

; 172  :               (*sym_wrap)(y,vx[i],wrap);

	mov	ebx, DWORD PTR _wrap$89212[ebp]
	mov	edi, DWORD PTR _vx$[ebp]
	mov	ecx, DWORD PTR [edi+esi*4]
	push	ebx
	push	ecx
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+104
	add	eax, DWORD PTR [ecx+edx+64]
	push	eax
	call	DWORD PTR _sym_wrap

; 173  :               x[i] = x[i+6] = vx[i];

	mov	eax, DWORD PTR [edi+esi*4]

; 174  :               fewrap = get_edge_wrap(e_id);

	mov	edx, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR _x$89206[ebp+esi*4+24], eax
	mov	DWORD PTR _x$89206[ebp+esi*4], eax
	mov	eax, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [eax+edx+784]
	mov	eax, DWORD PTR [ecx+edx]
	add	esp, 12					; 0000000cH
	test	DWORD PTR _e_id$[ebp], 134217728	; 08000000H
	je	SHORT $LN328@local_refi
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN328@local_refi:

; 175  :               if ( inverted(e_id) ) wrap = (*sym_compose)(wrap,fewrap);

	test	DWORD PTR _e_id$[ebp], 134217728	; 08000000H
	mov	DWORD PTR _fewrap$89213[ebp], eax
	je	SHORT $LN221@local_refi
	push	eax
	push	ebx
	call	DWORD PTR _sym_compose
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _wrap$89212[ebp], ebx
$LN221@local_refi:

; 176  :               y = get_coord(get_fe_midv(fe));
; 177  :               (*sym_wrap)(y,vx[i],wrap);

	mov	ecx, DWORD PTR [edi+esi*4]
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR tv5643[ebp]
	push	ebx
	push	ecx
	mov	ecx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+304]
	mov	ecx, DWORD PTR [ecx+edx+8]
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+104
	add	ecx, DWORD PTR [edx+eax+64]
	push	ecx
	call	DWORD PTR _sym_wrap

; 178  :               x[i] = x[i+6] = vx[i];

	mov	edi, DWORD PTR [edi+esi*4]
	add	esp, 12					; 0000000cH

; 179  :               if ( !inverted(e_id) ) wrap = (*sym_compose)(wrap,fewrap);

	test	DWORD PTR _e_id$[ebp], 134217728	; 08000000H
	mov	DWORD PTR _x$89206[ebp+esi*4+24], edi
	mov	DWORD PTR _x$89206[ebp+esi*4], edi
	jne	SHORT $LN735@local_refi
	mov	eax, DWORD PTR _fewrap$89213[ebp]
	push	eax
	push	ebx
	call	DWORD PTR _sym_compose
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _wrap$89212[ebp], ebx
$LN735@local_refi:

; 180  :             }
; 181  :             else

	mov	edx, DWORD PTR _dymem
	mov	edi, DWORD PTR _web+124

; 184  :             }
; 185  :             i++;

	inc	esi

; 186  :          }
; 187  :          else

	jmp	$LN216@local_refi
$LN222@local_refi:

; 182  :             { x[i] = x[i+6] = get_coord(get_fe_tailv(fe));

	mov	eax, DWORD PTR tv5643[ebp]
	mov	ebx, DWORD PTR _web+460
	mov	eax, DWORD PTR [eax+ebx]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR tv5649[ebp], eax
	xor	eax, ecx
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN335@local_refi
	mov	ebx, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN334@local_refi
$LN335@local_refi:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN334@local_refi:
	mov	ebx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	add	ebx, eax
	mov	DWORD PTR _x$89206[ebp+esi*4+24], ebx
	mov	DWORD PTR _x$89206[ebp+esi*4], ebx

; 183  :               x[i+1] = x[i+1+6] = get_coord(get_fe_midv(fe));

	mov	ebx, DWORD PTR tv5649[ebp]
	and	ebx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edi+ebx*4]
	mov	ecx, DWORD PTR [ebx+ecx+8]
	mov	ebx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _wrap$89212[ebp]
	add	eax, ecx
	mov	DWORD PTR _x$89206[ebp+esi*4+28], eax
	mov	DWORD PTR _x$89206[ebp+esi*4+4], eax

; 184  :             }
; 185  :             i++;

	inc	esi

; 186  :          }
; 187  :          else

	jmp	$LN216@local_refi
$LN223@local_refi:

; 188  :          {
; 189  :             if ( web.symmetry_flag )
; 190  :             { REAL *y = get_coord(get_fe_tailv(fe));

	mov	eax, DWORD PTR _fe$89200[ebp]
	and	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+856, ecx
	mov	ecx, DWORD PTR _web+216
	je	$LN217@local_refi
	mov	DWORD PTR tv5675[ebp], eax
	xor	eax, DWORD PTR tv5649[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN343@local_refi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	add	eax, DWORD PTR [ecx+edx+304]
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN342@local_refi
$LN343@local_refi:
	mov	ecx, DWORD PTR [ecx+edx+304]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN342@local_refi:

; 191  :               (*sym_wrap)(y,vx[i],wrap);

	mov	ecx, DWORD PTR _vx$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	push	ebx
	push	ecx
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+104
	add	eax, DWORD PTR [ecx+edx+64]
	push	eax
	call	DWORD PTR _sym_wrap

; 192  :               fewrap = get_fe_wrap(fe);

	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR tv5643[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [ecx+20]
	xor	eax, DWORD PTR tv5675[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edi+784]
	mov	ecx, DWORD PTR [edx+ecx]
	add	esp, 12					; 0000000cH
	test	eax, 134217728				; 08000000H
	je	SHORT $LN350@local_refi
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN351@local_refi
$LN350@local_refi:
	mov	eax, ecx
$LN351@local_refi:

; 193  :               wrap = (*sym_compose)(wrap,fewrap);

	push	eax
	push	ebx
	call	DWORD PTR _sym_compose

; 194  :               x[i] = x[i+6] = vx[i];

	mov	edx, DWORD PTR _vx$[ebp]
	mov	edi, DWORD PTR _web+124
	mov	ebx, eax
	mov	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _dymem
	add	esp, 8
	mov	DWORD PTR _wrap$89212[ebp], ebx
	jmp	SHORT $LN859@local_refi
$LN217@local_refi:

; 195  :             }
; 196  :             else x[i] = x[i+6] = get_coord(get_fe_tailv(fe));

	xor	eax, DWORD PTR tv5649[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN355@local_refi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	add	eax, DWORD PTR [ecx+edx+304]
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN354@local_refi
$LN355@local_refi:
	mov	ecx, DWORD PTR [ecx+edx+304]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN354@local_refi:
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+edx+64]
	add	eax, ecx
$LN859@local_refi:
	mov	DWORD PTR _x$89206[ebp+esi*4], eax
	mov	DWORD PTR _x$89206[ebp+esi*4+24], eax
$LN216@local_refi:

; 197  :          }
; 198  :          fe = get_next_edge(fe);

	test	DWORD PTR _fe$89200[ebp], 134217728	; 08000000H
	je	SHORT $LN359@local_refi
	mov	eax, DWORD PTR tv5643[ebp]
	mov	ecx, DWORD PTR _web+460
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN860@local_refi
$LN359@local_refi:
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR tv5643[ebp]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [ecx+32]
$LN860@local_refi:
	inc	esi
	mov	DWORD PTR _fe$89200[ebp], eax
	cmp	esi, 6
	jl	$LL226@local_refi

; 199  :       }
; 200  :     }
; 201  :     else if ( web.modeltype == LAGRANGE )

	jmp	$LN861@local_refi
$LN228@local_refi:
	cmp	eax, 3
	jne	$LN737@local_refi

; 202  :     { 
; 203  :       if (  web.symmetry_flag )

	cmp	DWORD PTR _web+856, edx
	je	$LN737@local_refi

; 204  :       { /* get some handy wraps */
; 205  :         fe = get_facet_fe(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN363@local_refi
	xor	edi, edi
	jmp	SHORT $LN364@local_refi
$LN363@local_refi:
	mov	ecx, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN362@local_refi
	xor	ecx, 134217728				; 08000000H
$LN362@local_refi:
	mov	edi, ecx
$LN364@local_refi:

; 206  :         e_id = get_fe_edge(fe);

	mov	edx, DWORD PTR _web+460
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+ecx*4]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, edi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [esi+20]
	mov	DWORD PTR _e_id$[ebp], eax

; 207  :         if ( inverted(e_id) ) fe = get_prev_edge(fe);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN368@local_refi
	test	edi, 134217728				; 08000000H
	je	SHORT $LN369@local_refi
	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax+32]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN368@local_refi
$LN369@local_refi:
	mov	ecx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+28]
$LN368@local_refi:

; 208  :         w4 = get_fe_wrap(fe);

	mov	ebx, DWORD PTR _dymem
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+edx]
	mov	eax, edi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ebx+784]
	mov	ecx, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN376@local_refi
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	mov	DWORD PTR _w4$[ebp], eax
	jmp	SHORT $LN862@local_refi
$LN376@local_refi:
	mov	DWORD PTR _w4$[ebp], ecx
$LN862@local_refi:
	mov	eax, DWORD PTR _web+460

; 209  :         fe = get_next_edge(fe);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN379@local_refi
	mov	ecx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [ecx+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN378@local_refi
$LN379@local_refi:
	mov	edx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [edx+32]
$LN378@local_refi:

; 210  :         w2 = (*sym_compose)(w4,get_fe_wrap(fe));

	mov	ebx, DWORD PTR _dymem
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	eax, edi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+ebx+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN386@local_refi
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN387@local_refi
$LN386@local_refi:
	mov	eax, ecx
$LN387@local_refi:
	mov	edx, DWORD PTR _w4$[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose
	add	esp, 8
	mov	DWORD PTR _w2$[ebp], eax

; 211  :         fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	test	edi, 134217728				; 08000000H
	je	SHORT $LN389@local_refi
	mov	ecx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [ecx+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN388@local_refi
$LN389@local_refi:
	mov	edx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [edx+32]
$LN388@local_refi:

; 212  :         w5 = (*sym_compose)(w2,get_fe_wrap(fe));

	mov	ebx, DWORD PTR _dymem
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	eax, edi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+ebx+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN396@local_refi
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN397@local_refi
$LN396@local_refi:
	mov	eax, ecx
$LN397@local_refi:
	mov	edx, DWORD PTR _w2$[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose
	add	esp, 8
	mov	DWORD PTR _w5$[ebp], eax

; 213  :         fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	test	edi, 134217728				; 08000000H
	je	SHORT $LN399@local_refi
	mov	ecx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [ecx+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN398@local_refi
$LN399@local_refi:
	mov	edx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [edx+32]
$LN398@local_refi:

; 214  :         w3 = (*sym_compose)(w5,get_fe_wrap(fe));

	mov	ebx, DWORD PTR _dymem
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	eax, edi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+ebx+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN406@local_refi
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN407@local_refi
$LN406@local_refi:
	mov	eax, ecx
$LN407@local_refi:
	mov	edx, DWORD PTR _w5$[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose

; 215  :         fe = get_next_edge(fe);

	mov	ecx, DWORD PTR _web+460
	add	esp, 8
	mov	ebx, eax
	mov	DWORD PTR _w3$[ebp], ebx
	test	edi, 134217728				; 08000000H
	je	SHORT $LN409@local_refi
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN408@local_refi
$LN409@local_refi:
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+32]
$LN408@local_refi:

; 216  :         w6 = (*sym_compose)(w3,get_fe_wrap(fe));

	mov	esi, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+esi+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN416@local_refi
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN417@local_refi
$LN416@local_refi:
	mov	eax, ecx
$LN417@local_refi:
	push	eax
	push	ebx
	call	DWORD PTR _sym_compose
	add	esp, 8
	mov	DWORD PTR _w6$[ebp], eax
$LN737@local_refi:
	mov	edi, DWORD PTR _web+124
	mov	edx, DWORD PTR _dymem
$LN861@local_refi:

; 217  :       }
; 218  :     }
; 219  : 
; 220  :     /* walk around subdivided edges, cutting off points as new facets */
; 221  :     fe = get_facet_fe(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	esi, DWORD PTR _web+460
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN419@local_refi
	xor	ecx, ecx
	jmp	SHORT $LN418@local_refi
$LN419@local_refi:
	mov	ebx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN418@local_refi
	xor	ecx, 134217728				; 08000000H
$LN418@local_refi:

; 222  :     if ( inverted(get_fe_edge(fe)) )

	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	ebx, DWORD PTR [eax+20]
	xor	ebx, ecx
	mov	DWORD PTR _fe$89200[ebp], ecx
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN777@local_refi

; 223  :         fe = get_prev_edge(fe);  

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN425@local_refi
	mov	ecx, DWORD PTR [eax+32]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN863@local_refi
$LN425@local_refi:
	mov	ecx, DWORD PTR [eax+28]
$LN863@local_refi:
	mov	DWORD PTR _fe$89200[ebp], ecx
$LN777@local_refi:

; 224  :     if ( get_eattr(get_fe_edge(get_prev_edge(fe))) & NO_REFINE ) i = 1;

	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN429@local_refi
	mov	eax, DWORD PTR [eax+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN428@local_refi
$LN429@local_refi:
	mov	eax, DWORD PTR [eax+28]
$LN428@local_refi:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+20]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 16777216				; 01000000H
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN210@local_refi
	lea	eax, DWORD PTR [ebx+1]
	jmp	SHORT $LN864@local_refi
$LN210@local_refi:

; 225  :     else i = 0;

	xor	eax, eax
$LN864@local_refi:
	mov	DWORD PTR _i$89202[ebp], eax

; 226  :     for (  n = 0 ; i < FACET_EDGES ; n++  )

	cmp	eax, 3
	jge	$LN739@local_refi
	lea	eax, DWORD PTR _x$89206[ebp+16]
	mov	DWORD PTR tv8940[ebp], eax
	lea	eax, DWORD PTR _x$89206[ebp+12]
	mov	DWORD PTR tv8942[ebp], eax
	lea	eax, DWORD PTR _x$89206[ebp+8]
	mov	DWORD PTR tv8944[ebp], eax
$LL208@local_refi:

; 227  :     { vertex_id headv,midv;
; 228  :       edge_id next_e;
; 229  : 
; 230  :       next_fe = get_next_edge(fe);

	mov	eax, ecx
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv5655[ebp], eax
	mov	ebx, ecx
	je	SHORT $LN435@local_refi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	esi, DWORD PTR [ebx+esi]
	mov	eax, DWORD PTR [esi+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN865@local_refi
$LN435@local_refi:
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	esi, DWORD PTR [ebx+esi]
	mov	eax, DWORD PTR [esi+32]
$LN865@local_refi:
	mov	DWORD PTR _next_fe$89201[ebp], eax

; 231  :       headv = get_fe_headv(fe);

	mov	eax, ecx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [esi+20]
	mov	DWORD PTR tv5646[ebp], esi
	mov	esi, DWORD PTR _web+216
	test	eax, 134217728				; 08000000H
	je	SHORT $LN441@local_refi
	mov	esi, DWORD PTR [esi+edx+304]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+esi]
	jmp	SHORT $LN440@local_refi
$LN441@local_refi:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	add	eax, DWORD PTR [esi+edx+304]
	mov	esi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+esi*4]
$LN440@local_refi:

; 232  :       if ( get_vattr(headv) & NEWVERTEX )

	mov	esi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 4
	xor	esi, esi
	or	eax, esi
	je	$LN771@local_refi

; 233  :       { cross_cut(get_prev_edge(fe),fe);

	mov	esi, DWORD PTR tv5655[ebp]
	test	esi, esi
	je	SHORT $LN445@local_refi
	mov	edx, DWORD PTR tv5646[ebp]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN444@local_refi
$LN445@local_refi:
	mov	eax, DWORD PTR tv5646[ebp]
	mov	eax, DWORD PTR [eax+28]
$LN444@local_refi:
	push	ecx
	push	eax
	call	_cross_cut
	add	esp, 8

; 234  :         if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	$LN738@local_refi

; 235  :         {
; 236  :           /* add quadratic correction to linear interpolation */
; 237  :           next_e = get_next_edge(fe);

	test	esi, esi
	je	SHORT $LN449@local_refi
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN448@local_refi
$LN449@local_refi:
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx+32]
$LN448@local_refi:

; 238  :           midv = get_fe_midv(next_e);

	mov	edx, DWORD PTR _web+460

; 239  :           xmid = get_coord(midv);

	mov	edi, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _dymem
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	eax, DWORD PTR [eax+ecx+8]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	ecx, DWORD PTR [eax+edx+64]

; 240  :           for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN768@local_refi
	mov	edx, DWORD PTR tv8942[ebp]
	fld	QWORD PTR __real@3fc0000000000000
	mov	eax, DWORD PTR [edx]
	fld	QWORD PTR __real@4000000000000000
	mov	edx, DWORD PTR tv8944[ebp]
	mov	edi, DWORD PTR tv8940[ebp]
	mov	edx, DWORD PTR [edx]
	mov	edi, DWORD PTR [edi]
	sub	edx, eax
	sub	edi, eax
	sub	ecx, eax
$LN203@local_refi:

; 241  :             xmid[j] -= (x[n+2][j] - 2*x[n+3][j] + x[n+4][j])/8.0;

	fld	QWORD PTR [eax]
	inc	esi
	fmul	ST(0), ST(1)
	add	eax, 8
	fsubr	QWORD PTR [edx+eax-8]
	fadd	QWORD PTR [edi+eax-8]
	fmul	ST(0), ST(2)
	fsubr	QWORD PTR [ecx+eax-8]
	fstp	QWORD PTR [ecx+eax-8]
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LN203@local_refi

; 240  :           for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
	fstp	ST(0)
$LN738@local_refi:
	mov	edx, DWORD PTR _dymem
	mov	edi, DWORD PTR _web+124
$LN768@local_refi:

; 242  :         }
; 243  :         newf[i] = get_fe_facet(fe);

	test	DWORD PTR _fe$89200[ebp], 268435456	; 10000000H
	jne	SHORT $LN455@local_refi
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN456@local_refi
$LN455@local_refi:
	cmp	DWORD PTR tv5655[ebp], 0
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx+24]
	je	SHORT $LN454@local_refi
	xor	eax, 134217728				; 08000000H
$LN454@local_refi:
	mov	ecx, eax
$LN456@local_refi:
	mov	eax, DWORD PTR _i$89202[ebp]
	mov	DWORD PTR _newf$[ebp+eax*4], ecx

; 244  :         i++;

	inc	eax
	mov	DWORD PTR _i$89202[ebp], eax
$LN771@local_refi:
	mov	esi, DWORD PTR _web+460

; 245  :       }
; 246  :       if ( get_eattr(get_fe_edge(fe)) & NO_REFINE ) {n++,i++;}

	mov	eax, DWORD PTR [ebx+esi]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 16777216				; 01000000H
	xor	ecx, ecx
	or	eax, ecx
	lea	eax, DWORD PTR [ecx+4]
	je	SHORT $LN200@local_refi
	add	DWORD PTR tv8944[ebp], eax
	add	DWORD PTR tv8942[ebp], eax
	add	DWORD PTR tv8940[ebp], eax
	inc	DWORD PTR _i$89202[ebp]
$LN200@local_refi:

; 247  :       fe = next_fe;

	mov	ecx, DWORD PTR _next_fe$89201[ebp]
	add	DWORD PTR tv8944[ebp], eax
	add	DWORD PTR tv8942[ebp], eax
	add	DWORD PTR tv8940[ebp], eax
	cmp	DWORD PTR _i$89202[ebp], 3
	mov	DWORD PTR _fe$89200[ebp], ecx
	jl	$LL208@local_refi
$LN739@local_refi:

; 248  :     }
; 249  : 
; 250  :     if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	jne	$LN13@local_refi

; 251  :     { /* fill in allv array with all vertices needed */
; 252  :       int oldctrl = web.skel[FACET].ctrlpts;
; 253  :       vertex_id vv_id, *v,*v0,*v1,*v2,*v3;
; 254  :       int facet_bdry_flag = get_fattr(f_id) & BOUNDARY;

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+232
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR _oldctrl$89301[ebp], edx

; 255  : 
; 256  :       for ( i = 0 ; i <= 2*N ; i++ )

	mov	edx, DWORD PTR _N$[ebp]
	and	eax, 128				; 00000080H
	xor	esi, esi
	add	edx, edx
	mov	DWORD PTR _facet_bdry_flag$89308[ebp], eax
	js	SHORT $LN753@local_refi

; 257  :          for ( j = 0 ; i+j <= 2*N ; j++ )

	lea	ebx, DWORD PTR _allv$[ebp]
	cmp	esi, edx
	jg	SHORT $LN197@local_refi
$LN867@local_refi:
	mov	ecx, esi
	mov	eax, ebx
$LL195@local_refi:

; 258  :             allv[i][j] = NULLID; 

	mov	DWORD PTR [eax], 0
	inc	ecx
	add	eax, 4
	cmp	ecx, edx
	jle	SHORT $LL195@local_refi
$LN197@local_refi:

; 255  : 
; 256  :       for ( i = 0 ; i <= 2*N ; i++ )

	inc	esi
	add	ebx, 84					; 00000054H
	cmp	esi, edx
	jle	SHORT $LN867@local_refi
$LN753@local_refi:

; 259  : 
; 260  :       /* use old interior vertices, in same positions */
; 261  :       v = get_facet_vertices(f_id);

	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+328
	mov	eax, DWORD PTR [eax+edx+304]
	add	eax, edi

; 262  :       for ( i = 1 ; i < N ; i++)

	mov	esi, 1
	mov	DWORD PTR _v$89303[ebp], eax
	cmp	DWORD PTR _N$[ebp], esi
	jle	$LN190@local_refi

; 259  : 
; 260  :       /* use old interior vertices, in same positions */
; 261  :       v = get_facet_vertices(f_id);

	lea	ecx, DWORD PTR _allv$[ebp+176]
	mov	DWORD PTR tv9137[ebp], ecx
	npad	13
$LL192@local_refi:

; 263  :          for ( j = 1; i+j < N ; j++ )

	lea	eax, DWORD PTR [esi+1]
	mov	ecx, 1
	mov	DWORD PTR tv5767[ebp], eax
	cmp	eax, DWORD PTR _N$[ebp]
	jge	SHORT $LN191@local_refi
	mov	edx, DWORD PTR tv9137[ebp]
	mov	ebx, DWORD PTR _N$[ebp]
	mov	edi, 2
	mov	DWORD PTR tv9105[ebp], edx
	npad	3
$LL189@local_refi:

; 264  :             allv[2*j][2*i] = v[i+j*N+(3*j-j*j)/2];

	mov	eax, edi
	imul	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _v$89303[ebp]
	sar	eax, 1
	add	eax, ebx
	add	eax, esi
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR tv9105[ebp]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR _N$[ebp]
	add	eax, 168				; 000000a8H
	inc	ecx
	mov	DWORD PTR tv9105[ebp], eax
	lea	eax, DWORD PTR [ecx+esi]
	dec	edi
	add	ebx, edx
	cmp	eax, edx
	jl	SHORT $LL189@local_refi
$LN191@local_refi:

; 262  :       for ( i = 1 ; i < N ; i++)

	mov	esi, DWORD PTR tv5767[ebp]
	add	DWORD PTR tv9137[ebp], 8
	cmp	esi, DWORD PTR _N$[ebp]
	jl	SHORT $LL192@local_refi
$LN190@local_refi:

; 265  : 
; 266  :       /* now extract from various edges */
; 267  :       fe = get_facet_fe(newf[0]);

	mov	eax, DWORD PTR _newf$[ebp]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN461@local_refi
	xor	ebx, ebx
	jmp	SHORT $LN460@local_refi
$LN461@local_refi:
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN460@local_refi
	xor	ebx, 134217728				; 08000000H
$LN460@local_refi:

; 268  :       e_id = get_fe_edge(fe);

	mov	eax, DWORD PTR _web+460

; 269  :       v = get_edge_vertices(e_id);

	mov	esi, DWORD PTR _web+124
	mov	edi, DWORD PTR _web+216
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	lea	edx, DWORD PTR [eax+edx*4]
	mov	eax, ebx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR tv5644[ebp], edx
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	DWORD PTR _e_id$[ebp], eax
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	esi, DWORD PTR [edi+ecx+304]

; 270  :       if ( inverted(e_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN186@local_refi

; 271  :          for ( i = 0 ; i <= N ; i++ )

	mov	ecx, DWORD PTR _N$[ebp]
	xor	eax, eax
	test	ecx, ecx
	js	SHORT $LN754@local_refi
	lea	edx, DWORD PTR _allv$[ebp+ecx*4]
$LL185@local_refi:

; 272  :             allv[0][N-i] = v[i];

	mov	edi, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx], edi
	inc	eax
	sub	edx, 4
	cmp	eax, ecx
	jle	SHORT $LL185@local_refi

; 273  :       else

	mov	edx, DWORD PTR tv5644[ebp]
	jmp	SHORT $LN181@local_refi
$LN186@local_refi:

; 274  :          for ( i = 0 ; i <= N ; i++ )

	cmp	DWORD PTR _N$[ebp], 0
	jl	SHORT $LN754@local_refi
	mov	ecx, DWORD PTR _N$[ebp]
	mov	edx, DWORD PTR tv5644[ebp]
	inc	ecx
	lea	edi, DWORD PTR _allv$[ebp]
	rep movsd
$LN754@local_refi:
	mov	ecx, DWORD PTR _N$[ebp]
$LN181@local_refi:

; 275  :             allv[0][i] = v[i];
; 276  : 
; 277  :       fe = get_next_edge(fe);  /* crosscut edge */

	test	ebx, 134217728				; 08000000H
	je	SHORT $LN467@local_refi
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN868@local_refi
$LN467@local_refi:
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+32]
$LN868@local_refi:

; 278  :       e_id = get_fe_edge(fe);

	mov	esi, DWORD PTR _web+460

; 279  :       v = get_edge_vertices(e_id);

	mov	edi, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	esi, DWORD PTR [edx+esi]
	mov	DWORD PTR _fe$89200[ebp], eax
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [esi+20]
	mov	DWORD PTR tv5643[ebp], edx
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	DWORD PTR _e_id$[ebp], eax
	mov	esi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR _web+216
	add	esi, DWORD PTR [edi+ebx+304]

; 280  :       if ( inverted(e_id) )
; 281  :          for ( i = 1 ; i < N ; i++ )

	mov	ebx, 1
	test	eax, 134217728				; 08000000H
	je	$LN178@local_refi
	cmp	ecx, ebx
	jle	$LN755@local_refi
	mov	eax, ecx
	imul	eax, 84					; 00000054H
	lea	eax, DWORD PTR _allv$[ebp+eax-80]
	mov	DWORD PTR tv9287[ebp], eax
	npad	11
$LL177@local_refi:

; 282  :          { vv_id = allv[N-i][i];

	mov	edi, DWORD PTR [eax]

; 283  :            if ( valid_id(vv_id) )  /* use old vertex */

	test	edi, 268435456				; 10000000H
	je	$LN174@local_refi

; 284  :            { unset_attr(vv_id,Q_MIDFACET);

	mov	ecx, edi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	lea	ecx, DWORD PTR _web[ecx+12]
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv6062[ebp], ecx
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edx]
	and	DWORD PTR [ecx+8], -2097153		; ffdfffffH
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+12], edx

; 285  :              set_attr(vv_id,Q_MIDEDGE);

	mov	ecx, DWORD PTR tv6062[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 4194304		; 00400000H
	mov	DWORD PTR [ecx+12], edx

; 286  :              set_vertex_edge(vv_id,e_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR [edx+28], eax

; 287  :              free_element(v[i]);

	mov	ecx, DWORD PTR [esi+ebx*4]
	push	ecx
	call	_free_element

; 288  :              v[i] = vv_id;
; 289  :            }
; 290  :            else

	mov	ecx, DWORD PTR _N$[ebp]
	mov	eax, DWORD PTR tv9287[ebp]
	mov	edx, DWORD PTR tv5643[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+ebx*4], edi
	jmp	SHORT $LN176@local_refi
$LN174@local_refi:

; 291  :              allv[N-i][i] = v[i];

	mov	edi, DWORD PTR [esi+ebx*4]
	mov	DWORD PTR [eax], edi
$LN176@local_refi:

; 280  :       if ( inverted(e_id) )
; 281  :          for ( i = 1 ; i < N ; i++ )

	inc	ebx
	sub	eax, 80					; 00000050H
	mov	DWORD PTR tv9287[ebp], eax
	cmp	ebx, ecx
	jl	$LL177@local_refi

; 292  :          }
; 293  :       else

	jmp	$LN169@local_refi
$LN178@local_refi:

; 294  :          for ( i = 1 ; i < N ; i++ )

	cmp	DWORD PTR _N$[ebp], ebx
	jle	$LN755@local_refi
	mov	eax, DWORD PTR _N$[ebp]
	lea	eax, DWORD PTR _allv$[ebp+eax*4+80]
	mov	DWORD PTR tv9357[ebp], eax
	npad	5
$LL171@local_refi:

; 295  :          { vv_id = allv[i][N-i];

	mov	edi, DWORD PTR [eax]

; 296  :            if ( valid_id(vv_id) )  /* use old vertex */

	test	edi, 268435456				; 10000000H
	je	SHORT $LN168@local_refi

; 297  :            { unset_attr(vv_id,Q_MIDFACET);

	mov	edx, edi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	lea	ecx, DWORD PTR _web[edx+12]
	mov	DWORD PTR tv6062[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	and	DWORD PTR [ecx+8], -2097153		; ffdfffffH
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+12], edx

; 298  :              set_attr(vv_id,Q_MIDEDGE);

	mov	ecx, DWORD PTR tv6062[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 4194304		; 00400000H
	mov	DWORD PTR [ecx+12], edx

; 299  :              set_vertex_edge(vv_id,e_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR [edx+28], eax

; 300  :              free_element(v[i]);

	mov	ecx, DWORD PTR [esi+ebx*4]
	push	ecx
	call	_free_element

; 301  :              v[i] = vv_id;
; 302  :            }
; 303  :            else

	mov	eax, DWORD PTR tv9357[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+ebx*4], edi
	jmp	SHORT $LN170@local_refi
$LN168@local_refi:

; 304  :              allv[i][N-i] = v[i];

	mov	edx, DWORD PTR [esi+ebx*4]
	mov	DWORD PTR [eax], edx
$LN170@local_refi:

; 294  :          for ( i = 1 ; i < N ; i++ )

	inc	ebx
	add	eax, 80					; 00000050H
	mov	DWORD PTR tv9357[ebp], eax
	cmp	ebx, DWORD PTR _N$[ebp]
	jl	$LL171@local_refi
$LN755@local_refi:
	mov	edx, DWORD PTR tv5643[ebp]
	mov	ecx, DWORD PTR _N$[ebp]
$LN169@local_refi:

; 305  :          }
; 306  : 
; 307  :       fe = get_next_edge(fe);

	test	DWORD PTR _fe$89200[ebp], 134217728	; 08000000H
	mov	ebx, DWORD PTR _web+460
	je	SHORT $LN481@local_refi
	mov	eax, DWORD PTR [edx+ebx]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN480@local_refi
$LN481@local_refi:
	mov	eax, DWORD PTR _web+460
	mov	edx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [edx+32]
$LN480@local_refi:

; 308  :       e_id = get_fe_edge(fe);
; 309  :       v = get_edge_vertices(e_id);

	mov	esi, DWORD PTR _web+124
	mov	edi, DWORD PTR _web+216
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	DWORD PTR _e_id$[ebp], eax
	mov	esi, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR _dymem
	add	esi, DWORD PTR [edi+edx+304]

; 310  :       if ( inverted(e_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN166@local_refi

; 311  :          for ( i = 0 ; i <= N ; i++ )

	xor	eax, eax
	test	ecx, ecx
	js	SHORT $LN756@local_refi
	lea	edx, DWORD PTR _allv$[ebp]
	npad	3
$LL165@local_refi:

; 312  :             allv[i][0] = v[i];

	mov	edi, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx], edi
	inc	eax
	add	edx, 84					; 00000054H
	cmp	eax, ecx
	jle	SHORT $LL165@local_refi

; 313  :       else

	jmp	SHORT $LN756@local_refi
$LN166@local_refi:

; 314  :          for ( i = 0 ; i <= N ; i++ )

	xor	eax, eax
	test	ecx, ecx
	js	SHORT $LN756@local_refi
	mov	edx, ecx
	imul	edx, 84					; 00000054H
	lea	edx, DWORD PTR _allv$[ebp+edx]
$LL161@local_refi:

; 315  :             allv[N-i][0] = v[i];

	mov	edi, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx], edi
	inc	eax
	sub	edx, 84					; 00000054H
	cmp	eax, ecx
	jle	SHORT $LL161@local_refi
$LN756@local_refi:

; 316  : 
; 317  :       fe = get_facet_fe(newf[1]);

	mov	eax, DWORD PTR _newf$[ebp+4]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN487@local_refi
	xor	edi, edi
	jmp	SHORT $LN486@local_refi
$LN487@local_refi:
	mov	esi, DWORD PTR _web+236
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	edi, DWORD PTR [edx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN486@local_refi
	xor	edi, 134217728				; 08000000H
$LN486@local_refi:

; 318  :       e_id = get_fe_edge(fe);
; 319  :       v = get_edge_vertices(e_id);

	mov	esi, DWORD PTR _web+124
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	lea	edx, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _dymem
	mov	DWORD PTR tv5644[ebp], edx
	mov	edx, DWORD PTR [edx]
	mov	eax, edi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	DWORD PTR _e_id$[ebp], eax
	mov	esi, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR _web+216
	add	esi, DWORD PTR [edx+ebx+304]

; 320  :       if ( inverted(e_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN158@local_refi

; 321  :          for ( i = 0 ; i <= N ; i++ )

	xor	eax, eax
	test	ecx, ecx
	js	SHORT $LN779@local_refi
	mov	edx, ecx
	imul	edx, 88					; 00000058H
	lea	edx, DWORD PTR _allv$[ebp+edx]
	npad	4
$LL157@local_refi:

; 322  :             allv[N-i][N+i] = v[i];

	mov	ebx, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx], ebx
	inc	eax
	sub	edx, 80					; 00000050H
	cmp	eax, ecx
	jle	SHORT $LL157@local_refi

; 323  :       else

	jmp	SHORT $LN779@local_refi
$LN158@local_refi:

; 324  :          for ( i = 0 ; i <= N ; i++ )

	xor	eax, eax
	test	ecx, ecx
	js	SHORT $LN779@local_refi
	lea	edx, DWORD PTR _allv$[ebp+ecx*8]
	npad	4
$LL153@local_refi:

; 325  :             allv[i][2*N-i] = v[i];

	mov	ebx, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx], ebx
	inc	eax
	add	edx, 80					; 00000050H
	cmp	eax, ecx
	jle	SHORT $LL153@local_refi
$LN779@local_refi:

; 326  : 
; 327  :       fe = get_next_edge(fe);  /* crosscut edge */

	test	edi, 134217728				; 08000000H
	je	SHORT $LN493@local_refi
	mov	eax, DWORD PTR tv5644[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN869@local_refi
$LN493@local_refi:
	mov	edx, DWORD PTR tv5644[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+32]
$LN869@local_refi:

; 328  :       e_id = get_fe_edge(fe);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR tv5643[ebp], ecx
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _fe$89200[ebp], eax
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 329  :       v = get_edge_vertices(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	DWORD PTR _e_id$[ebp], eax
	mov	esi, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	esi, DWORD PTR [edx+ecx+304]

; 330  :       if ( inverted(e_id) )
; 331  :          for ( i = 1 ; i < N ; i++ )

	mov	ebx, 1
	test	eax, 134217728				; 08000000H
	je	$LN150@local_refi
	cmp	DWORD PTR _N$[ebp], ebx
	jle	$LN773@local_refi
	mov	eax, DWORD PTR _N$[ebp]
	lea	eax, DWORD PTR _allv$[ebp+eax*4+84]
	mov	DWORD PTR tv9621[ebp], eax
	npad	12
$LL149@local_refi:

; 332  :          { vv_id = allv[i][N];

	mov	edi, DWORD PTR [eax]

; 333  :            if ( valid_id(vv_id) )  /* use old vertex */

	test	edi, 268435456				; 10000000H
	je	$LN146@local_refi

; 334  :            { unset_attr(vv_id,Q_MIDFACET);

	mov	edx, edi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	lea	ecx, DWORD PTR _web[edx+12]
	mov	DWORD PTR tv6062[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	and	DWORD PTR [ecx+8], -2097153		; ffdfffffH
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+12], edx

; 335  :              set_attr(vv_id,Q_MIDEDGE);

	mov	ecx, DWORD PTR tv6062[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 4194304		; 00400000H
	mov	DWORD PTR [ecx+12], edx

; 336  :              set_vertex_edge(vv_id,e_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR [edx+28], eax

; 337  :              free_element(v[i]);

	mov	ecx, DWORD PTR [esi+ebx*4]
	push	ecx
	call	_free_element

; 338  :              v[i] = vv_id;
; 339  :            }
; 340  :            else

	mov	eax, DWORD PTR tv9621[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+ebx*4], edi
	jmp	SHORT $LN148@local_refi
$LN146@local_refi:

; 341  :             allv[i][N] = v[i];

	mov	edx, DWORD PTR [esi+ebx*4]
	mov	DWORD PTR [eax], edx
$LN148@local_refi:

; 330  :       if ( inverted(e_id) )
; 331  :          for ( i = 1 ; i < N ; i++ )

	inc	ebx
	add	eax, 84					; 00000054H
	mov	DWORD PTR tv9621[ebp], eax
	cmp	ebx, DWORD PTR _N$[ebp]
	jl	$LL149@local_refi

; 342  :          }
; 343  :       else

	jmp	$LN773@local_refi
$LN150@local_refi:

; 344  :          for ( i = 1 ; i < N ; i++ )

	mov	ecx, DWORD PTR _N$[ebp]
	cmp	ecx, 1
	jle	$LN773@local_refi
	mov	eax, ecx
	imul	eax, 88					; 00000058H
	lea	eax, DWORD PTR _allv$[ebp+eax-84]
	mov	DWORD PTR tv9691[ebp], eax
$LL143@local_refi:

; 345  :          { vv_id = allv[N-i][N];

	mov	edi, DWORD PTR [eax]

; 346  :            if ( valid_id(vv_id) )  /* use old vertex */

	test	edi, 268435456				; 10000000H
	je	$LN140@local_refi

; 347  :            { unset_attr(vv_id,Q_MIDFACET);

	mov	ecx, edi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	lea	ecx, DWORD PTR _web[ecx+12]
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv6062[ebp], ecx
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edx]
	and	DWORD PTR [ecx+8], -2097153		; ffdfffffH
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+12], edx

; 348  :              set_attr(vv_id,Q_MIDEDGE);

	mov	ecx, DWORD PTR tv6062[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 4194304		; 00400000H
	mov	DWORD PTR [ecx+12], edx

; 349  :              set_vertex_edge(vv_id,e_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR [edx+28], eax

; 350  :              free_element(v[i]);

	mov	ecx, DWORD PTR [esi+ebx*4]
	push	ecx
	call	_free_element

; 351  :              v[i] = vv_id;
; 352  :            }
; 353  :            else

	mov	ecx, DWORD PTR _N$[ebp]
	mov	eax, DWORD PTR tv9691[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+ebx*4], edi
	jmp	SHORT $LN142@local_refi
$LN140@local_refi:

; 354  :             allv[N-i][N] = v[i];

	mov	edx, DWORD PTR [esi+ebx*4]
	mov	DWORD PTR [eax], edx
$LN142@local_refi:

; 344  :          for ( i = 1 ; i < N ; i++ )

	inc	ebx
	sub	eax, 84					; 00000054H
	mov	DWORD PTR tv9691[ebp], eax
	cmp	ebx, ecx
	jl	$LL143@local_refi
$LN773@local_refi:

; 355  :          }
; 356  : 
; 357  :       fe = get_next_edge(fe);

	test	DWORD PTR _fe$89200[ebp], 134217728	; 08000000H
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR tv5643[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	je	SHORT $LN507@local_refi
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN506@local_refi
$LN507@local_refi:
	mov	eax, DWORD PTR [ecx+32]
$LN506@local_refi:

; 358  :       e_id = get_fe_edge(fe);
; 359  :       v = get_edge_vertices(e_id);

	mov	esi, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem

; 360  :       if ( inverted(e_id) )
; 361  :          for ( i = 0 ; i <= N ; i++ )

	mov	ebx, DWORD PTR _N$[ebp]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	DWORD PTR _e_id$[ebp], eax
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR _web+216
	add	esi, DWORD PTR [ecx+edi+304]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN138@local_refi
	xor	eax, eax
	test	ebx, ebx
	js	SHORT $LN770@local_refi
	lea	ecx, DWORD PTR _allv$[ebp+ebx*8]
$LL137@local_refi:

; 362  :             allv[0][2*N-i] = v[i];

	mov	edi, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx], edi
	inc	eax
	sub	ecx, 4
	cmp	eax, ebx
	jle	SHORT $LL137@local_refi

; 363  :       else

	jmp	SHORT $LN770@local_refi
$LN138@local_refi:

; 364  :          for ( i = 0 ; i <= N ; i++ )

	test	ebx, ebx
	js	SHORT $LN770@local_refi
	lea	edi, DWORD PTR _allv$[ebp+ebx*4]
	lea	ecx, DWORD PTR [ebx+1]
	rep movsd
$LN770@local_refi:

; 365  :             allv[0][N+i] = v[i];
; 366  :             
; 367  :       fe = get_facet_fe(newf[2]);

	mov	eax, DWORD PTR _newf$[ebp+8]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN513@local_refi
	xor	edi, edi
	jmp	SHORT $LN512@local_refi
$LN513@local_refi:
	mov	esi, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	edi, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN512@local_refi
	xor	edi, 134217728				; 08000000H
$LN512@local_refi:

; 368  :       e_id = get_fe_edge(fe);
; 369  :       v = get_edge_vertices(e_id);

	mov	esi, DWORD PTR _dymem
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv5644[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	mov	eax, edi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	DWORD PTR _e_id$[ebp], eax
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _web+216
	add	ecx, DWORD PTR [edx+esi+304]

; 370  :       if ( inverted(e_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN130@local_refi

; 371  :          for ( i = 0 ; i <= N ; i++ )

	xor	eax, eax
	test	ebx, ebx
	js	SHORT $LN778@local_refi
	mov	edx, ebx
	imul	edx, 84					; 00000054H
	lea	esi, DWORD PTR _allv$[ebp+edx]
	npad	2
$LL129@local_refi:

; 372  :             allv[N+i][0] = v[i];

	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi], edx
	inc	eax
	add	esi, 84					; 00000054H
	cmp	eax, ebx
	jle	SHORT $LL129@local_refi

; 373  :       else

	jmp	SHORT $LN778@local_refi
$LN130@local_refi:

; 374  :          for ( i = 0 ; i <= N ; i++ )

	xor	eax, eax
	test	ebx, ebx
	js	SHORT $LN778@local_refi
	mov	edx, ebx
	imul	edx, 168				; 000000a8H
	lea	esi, DWORD PTR _allv$[ebp+edx]
$LL125@local_refi:

; 375  :             allv[2*N-i][0] = v[i];

	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi], edx
	inc	eax
	sub	esi, 84					; 00000054H
	cmp	eax, ebx
	jle	SHORT $LL125@local_refi
$LN778@local_refi:

; 376  : 
; 377  :       fe = get_next_edge(fe);  /* crosscut edge */

	test	edi, 134217728				; 08000000H
	je	SHORT $LN519@local_refi
	mov	eax, DWORD PTR tv5644[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN870@local_refi
$LN519@local_refi:
	mov	edx, DWORD PTR tv5644[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+32]
$LN870@local_refi:

; 378  :       e_id = get_fe_edge(fe);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR tv5643[ebp], ecx
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _fe$89200[ebp], eax
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 379  :       v = get_edge_vertices(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	DWORD PTR _e_id$[ebp], eax
	mov	esi, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	esi, DWORD PTR [edx+ecx+304]

; 380  :       if ( inverted(e_id) )
; 381  :          for ( i = 1 ; i < N ; i++ )

	mov	ebx, 1
	test	eax, 134217728				; 08000000H
	je	$LN122@local_refi
	cmp	DWORD PTR _N$[ebp], ebx
	jle	$LN774@local_refi
	mov	eax, DWORD PTR _N$[ebp]
	imul	eax, 88					; 00000058H
	lea	eax, DWORD PTR _allv$[ebp+eax-4]
	mov	DWORD PTR tv9957[ebp], eax
	npad	5
$LL121@local_refi:

; 382  :          { vv_id = allv[N][N-i];

	mov	edi, DWORD PTR [eax]

; 383  :            if ( valid_id(vv_id) )  /* use old vertex */

	test	edi, 268435456				; 10000000H
	je	$LN118@local_refi

; 384  :            { unset_attr(vv_id,Q_MIDFACET);

	mov	edx, edi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	lea	ecx, DWORD PTR _web[edx+12]
	mov	DWORD PTR tv6062[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	and	DWORD PTR [ecx+8], -2097153		; ffdfffffH
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+12], edx

; 385  :              set_attr(vv_id,Q_MIDEDGE);

	mov	ecx, DWORD PTR tv6062[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 4194304		; 00400000H
	mov	DWORD PTR [ecx+12], edx

; 386  :              set_vertex_edge(vv_id,e_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR [edx+28], eax

; 387  :              free_element(v[i]);

	mov	ecx, DWORD PTR [esi+ebx*4]
	push	ecx
	call	_free_element

; 388  :              v[i] = vv_id;
; 389  :            }
; 390  :            else

	mov	eax, DWORD PTR tv9957[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+ebx*4], edi
	jmp	SHORT $LN120@local_refi
$LN118@local_refi:

; 391  :             allv[N][N-i] = v[i];

	mov	edx, DWORD PTR [esi+ebx*4]
	mov	DWORD PTR [eax], edx
$LN120@local_refi:

; 380  :       if ( inverted(e_id) )
; 381  :          for ( i = 1 ; i < N ; i++ )

	inc	ebx
	sub	eax, 4
	mov	DWORD PTR tv9957[ebp], eax
	cmp	ebx, DWORD PTR _N$[ebp]
	jl	$LL121@local_refi

; 392  :          }
; 393  :       else

	jmp	$LN774@local_refi
$LN122@local_refi:

; 394  :          for ( i = 1 ; i < N ; i++ )

	mov	ecx, DWORD PTR _N$[ebp]
	cmp	ecx, 1
	jle	$LN774@local_refi
	mov	eax, ecx
	imul	eax, 84					; 00000054H
	lea	eax, DWORD PTR _allv$[ebp+eax+4]
	mov	DWORD PTR tv10010[ebp], eax
$LL115@local_refi:

; 395  :          { vv_id = allv[N][i];

	mov	edi, DWORD PTR [eax]

; 396  :            if ( valid_id(vv_id) )  /* use old vertex */

	test	edi, 268435456				; 10000000H
	je	$LN112@local_refi

; 397  :            { unset_attr(vv_id,Q_MIDFACET);

	mov	ecx, edi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	lea	ecx, DWORD PTR _web[ecx+12]
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv6062[ebp], ecx
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edx]
	and	DWORD PTR [ecx+8], -2097153		; ffdfffffH
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+12], edx

; 398  :              set_attr(vv_id,Q_MIDEDGE);

	mov	ecx, DWORD PTR tv6062[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 4194304		; 00400000H
	mov	DWORD PTR [ecx+12], edx

; 399  :              set_vertex_edge(vv_id,e_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR [edx+28], eax

; 400  :              free_element(v[i]);

	mov	ecx, DWORD PTR [esi+ebx*4]
	push	ecx
	call	_free_element

; 401  :              v[i] = vv_id;
; 402  :            }
; 403  :            else

	mov	ecx, DWORD PTR _N$[ebp]
	mov	eax, DWORD PTR tv10010[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+ebx*4], edi
	jmp	SHORT $LN114@local_refi
$LN112@local_refi:

; 404  :             allv[N][i] = v[i];

	mov	edx, DWORD PTR [esi+ebx*4]
	mov	DWORD PTR [eax], edx
$LN114@local_refi:

; 394  :          for ( i = 1 ; i < N ; i++ )

	inc	ebx
	add	eax, 4
	mov	DWORD PTR tv10010[ebp], eax
	cmp	ebx, ecx
	jl	$LL115@local_refi
$LN774@local_refi:

; 405  :          }
; 406  : 
; 407  :       fe = get_next_edge(fe);

	test	DWORD PTR _fe$89200[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR tv5643[ebp]
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [eax+ecx]
	je	SHORT $LN533@local_refi
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN532@local_refi
$LN533@local_refi:
	mov	eax, DWORD PTR [edx+32]
$LN532@local_refi:

; 408  :       e_id = get_fe_edge(fe);
; 409  :       v = get_edge_vertices(e_id);

	mov	edi, DWORD PTR _dymem

; 410  :       if ( inverted(e_id) )
; 411  :          for ( i = 0 ; i <= N ; i++ )

	mov	esi, DWORD PTR _N$[ebp]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	DWORD PTR _e_id$[ebp], eax
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _web+216
	add	ecx, DWORD PTR [edx+edi+304]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN110@local_refi
	xor	eax, eax
	test	esi, esi
	js	SHORT $LN769@local_refi
	mov	edx, esi
	imul	edx, 168				; 000000a8H
	lea	edx, DWORD PTR _allv$[ebp+edx]
	npad	7
$LL109@local_refi:

; 412  :             allv[2*N-i][i] = v[i];

	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx], ebx
	inc	eax
	sub	edx, 80					; 00000050H
	cmp	eax, esi
	jle	SHORT $LL109@local_refi

; 413  :       else

	jmp	SHORT $LN769@local_refi
$LN110@local_refi:

; 414  :          for ( i = 0 ; i <= N ; i++ )

	xor	eax, eax
	test	esi, esi
	js	SHORT $LN769@local_refi
	mov	edx, esi
	imul	edx, 88					; 00000058H
	lea	edx, DWORD PTR _allv$[ebp+edx]
$LL105@local_refi:

; 415  :             allv[N+i][N-i] = v[i];

	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx], ebx
	inc	eax
	add	edx, 80					; 00000050H
	cmp	eax, esi
	jle	SHORT $LL105@local_refi
$LN769@local_refi:

; 416  : 
; 417  :       /* unwrap coordinates of old vertices */
; 418  :       v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+328

; 419  :       for ( i = 0 ; i < oldctrl ; i++)

	mov	esi, DWORD PTR _oldctrl$89301[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+eax*4]
	add	ebx, DWORD PTR [edx+edi+304]
	mov	DWORD PTR _v$89303[ebp], ebx
	test	esi, esi
	jle	$LN757@local_refi
	mov	eax, DWORD PTR _oldx$[ebp]
	sub	eax, ebx
	mov	DWORD PTR tv10266[ebp], eax
	mov	eax, DWORD PTR _oldp$[ebp]
	sub	eax, ebx
	mov	DWORD PTR tv10271[ebp], eax
	mov	eax, esi
	mov	edi, ebx
	mov	DWORD PTR tv2465[ebp], eax
	npad	7
$LL102@local_refi:

; 420  :       { REAL *vx = get_oldcoord(v[i]);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR _web+104
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	add	ecx, DWORD PTR [eax+edx+304]

; 421  :         for ( k = 0 ; k < SDIM ; k++ ) 

	xor	esi, esi
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN775@local_refi

; 420  :       { REAL *vx = get_oldcoord(v[i]);

	mov	eax, DWORD PTR tv10266[ebp]
	mov	eax, DWORD PTR [edi+eax]

; 421  :         for ( k = 0 ; k < SDIM ; k++ ) 

	sub	ecx, eax
$LL99@local_refi:

; 422  :           oldx[i][k] = vx[k];

	fld	QWORD PTR [ecx+eax]
	inc	esi
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL99@local_refi
$LN775@local_refi:

; 423  :         if ( get_vattr(v[i]) & BOUNDARY )

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN101@local_refi

; 424  :         { REAL *vp = get_param(v[i]);

	mov	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+edx+544]
	add	esi, ecx

; 425  :           for ( k = 0 ; k < web.maxparam ; k++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+640, ecx
	jle	SHORT $LN101@local_refi

; 424  :         { REAL *vp = get_param(v[i]);

	mov	eax, DWORD PTR tv10271[ebp]
	mov	eax, DWORD PTR [edi+eax]

; 425  :           for ( k = 0 ; k < web.maxparam ; k++ )

	sub	esi, eax
$LL95@local_refi:

; 426  :             oldp[i][k] = vp[k];

	fld	QWORD PTR [esi+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+640
	jl	SHORT $LL95@local_refi
$LN101@local_refi:

; 419  :       for ( i = 0 ; i < oldctrl ; i++)

	add	edi, 4
	dec	DWORD PTR tv2465[ebp]
	jne	$LL102@local_refi
	mov	esi, DWORD PTR _oldctrl$89301[ebp]
$LN757@local_refi:

; 427  :         }
; 428  :       }
; 429  :       if ( w2 ) (*sym_wrap)(get_coord(v[N]),oldx[N],w2);

	mov	eax, DWORD PTR _w2$[ebp]
	test	eax, eax
	je	SHORT $LN784@local_refi
	mov	ecx, DWORD PTR _oldx$[ebp]
	push	eax
	mov	eax, DWORD PTR _N$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ecx, DWORD PTR _web+12
	push	edx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+64]
	push	edx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH
$LN784@local_refi:

; 430  :       if ( w3 ) (*sym_wrap)(get_coord(v[oldctrl-1]),oldx[oldctrl-1],w3);

	mov	eax, DWORD PTR _w3$[ebp]
	test	eax, eax
	je	SHORT $LN91@local_refi
	mov	edx, DWORD PTR _oldx$[ebp]
	mov	ecx, DWORD PTR [ebx+esi*4-4]
	push	eax
	mov	eax, DWORD PTR [edx+esi*4-4]
	mov	edx, DWORD PTR _web+12
	push	eax
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+64]
	push	eax
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH
$LN91@local_refi:

; 431  :       if ( w4 )

	cmp	DWORD PTR _w4$[ebp], 0
	je	SHORT $LN87@local_refi

; 432  :           for ( i = 1 ; i < N ; i++ )

	cmp	DWORD PTR _N$[ebp], 1
	jle	SHORT $LN87@local_refi
	mov	edi, DWORD PTR _oldx$[ebp]
	mov	eax, ebx
	mov	ebx, DWORD PTR _N$[ebp]
	sub	edi, eax
	lea	esi, DWORD PTR [eax+4]
	dec	ebx
$LL740@local_refi:

; 433  :               (*sym_wrap)(get_coord(v[i]),oldx[i],w4);

	mov	eax, DWORD PTR _w4$[ebp]
	mov	ecx, DWORD PTR [esi+edi]
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR _web+12
	push	ecx
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	add	ecx, DWORD PTR [eax+edx+64]
	push	ecx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH
	add	esi, 4
	dec	ebx
	jne	SHORT $LL740@local_refi
$LN87@local_refi:

; 434  :       if ( w5 )

	cmp	DWORD PTR _w5$[ebp], 0
	je	$LN83@local_refi

; 435  :           for ( i = 1 ; i < N ; i++ )

	mov	esi, 1
	cmp	DWORD PTR _N$[ebp], esi
	jle	$LN83@local_refi
	mov	ebx, DWORD PTR _N$[ebp]
	dec	ebx
	mov	DWORD PTR tv6321[ebp], ebx
	mov	edi, 2
	npad	1
$LL741@local_refi:

; 436  :           { j = N-i +i*N+(3*i-i*i)/2;
; 437  :              (*sym_wrap)(get_coord(v[j]),oldx[j],w5);

	mov	ecx, DWORD PTR _w5$[ebp]
	mov	eax, esi
	imul	eax, edi
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _oldx$[ebp]
	sar	eax, 1
	add	eax, ebx
	add	eax, DWORD PTR _N$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _v$89303[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	add	edx, DWORD PTR [ecx+eax+64]
	push	edx
	call	DWORD PTR _sym_wrap
	add	ebx, DWORD PTR tv6321[ebp]
	inc	esi
	add	esp, 12					; 0000000cH
	dec	edi
	cmp	esi, DWORD PTR _N$[ebp]
	jl	SHORT $LL741@local_refi
$LN83@local_refi:

; 438  :           }
; 439  :       if ( w6 )

	cmp	DWORD PTR _w6$[ebp], 0
	je	$LN79@local_refi

; 440  :           for ( i = 1 ; i < N ; i++ )

	mov	esi, 1
	cmp	DWORD PTR _N$[ebp], esi
	jle	SHORT $LN79@local_refi
	mov	ebx, DWORD PTR _N$[ebp]
	mov	edi, 2
	npad	8
$LL742@local_refi:

; 441  :           { j = i*N+(3*i-i*i)/2;
; 442  :              (*sym_wrap)(get_coord(v[j]),oldx[j],w6);

	mov	ecx, DWORD PTR _oldx$[ebp]
	mov	eax, esi
	imul	eax, edi
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _w6$[ebp]
	sar	eax, 1
	push	edx
	add	eax, ebx
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _v$89303[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	add	ecx, DWORD PTR [eax+edx+64]
	push	ecx
	call	DWORD PTR _sym_wrap
	mov	eax, DWORD PTR _N$[ebp]
	inc	esi
	add	esp, 12					; 0000000cH
	dec	edi
	add	ebx, eax
	cmp	esi, eax
	jl	SHORT $LL742@local_refi
$LN79@local_refi:

; 443  :           }
; 444  : 
; 445  :       /* now allocate new vertices and calculate coordinates as needed */
; 446  :       for ( j = 1 ; j < 2*N ; j++)

	mov	eax, DWORD PTR _N$[ebp]
	add	eax, eax
	mov	DWORD PTR _j$89203[ebp], 1
	cmp	eax, 1
	jle	$LN76@local_refi
	mov	eax, DWORD PTR _N$[ebp]
	add	eax, eax
	lea	ecx, DWORD PTR _allv$[ebp+88]
	mov	DWORD PTR tv10756[ebp], eax
	mov	DWORD PTR tv10758[ebp], 2
	mov	DWORD PTR tv10760[ebp], ecx
	npad	6
$LL766@local_refi:

; 447  :         for ( i = 1; i+j < 2*N ; i++ )

	mov	ecx, DWORD PTR _j$89203[ebp]
	mov	eax, DWORD PTR _N$[ebp]
	inc	ecx
	add	eax, eax
	mov	DWORD PTR _i$89202[ebp], 1
	mov	DWORD PTR tv5974[ebp], ecx
	cmp	ecx, eax
	jge	$LN77@local_refi
	mov	edx, DWORD PTR tv10760[ebp]
	mov	DWORD PTR tv10676[ebp], edx
	npad	13
$LL75@local_refi:

; 448  :         { REAL *vx,sum;
; 449  :           if ( !valid_id(allv[j][i]) )

	mov	esi, DWORD PTR tv10676[ebp]
	test	DWORD PTR [esi], 268435456		; 10000000H
	jne	SHORT $LN758@local_refi

; 450  :           { allv[j][i] = new_vertex(NULL,f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	push	0
	call	_new_vertex

; 451  :             set_attr(allv[j][i],Q_MIDFACET);

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	DWORD PTR [esi], eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	add	esp, 8
	or	DWORD PTR [eax+8], 2097152		; 00200000H
	mov	DWORD PTR [eax+12], ecx
$LN758@local_refi:

; 452  :           }
; 453  :             /* regular coordinates */
; 454  :           { vx = get_coord(allv[j][i]);

	mov	edi, DWORD PTR [esi]

; 455  :             for ( n = 0 ; n < SDIM ; n++ )

	fldz
	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR _dymem
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+edx]
	mov	edx, DWORD PTR _web+104
	add	eax, DWORD PTR [edx+ecx+64]
	xor	esi, esi
	mov	DWORD PTR _vx$89546[ebp], eax
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN69@local_refi
$LN743@local_refi:
	mov	ebx, DWORD PTR _web+232

; 456  :             { for ( k = 0, sum = 0.0 ; k < web.skel[FACET].ctrlpts ; k++ )

	fld	ST(0)
	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN767@local_refi
	mov	eax, DWORD PTR tv10758[ebp]
	imul	eax, DWORD PTR _j$89203[ebp]
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _interp$[ebp]
	sar	eax, 1
	add	eax, DWORD PTR tv10756[ebp]
	add	eax, DWORD PTR _i$89202[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
$LN68@local_refi:

; 457  :                 sum += interp[i+2*N*j+(3*j-j*j)/2][k]*oldx[k][n];

	mov	edx, DWORD PTR _oldx$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	fld	QWORD PTR [edx+esi*8]
	inc	ecx
	fmul	QWORD PTR [eax]
	add	eax, 8
	faddp	ST(1), ST(0)
	cmp	ecx, ebx
	jl	SHORT $LN68@local_refi
$LN767@local_refi:

; 458  :               vx[n] = sum;

	mov	eax, DWORD PTR _vx$89546[ebp]
	fstp	QWORD PTR [eax+esi*8]
	inc	esi
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LN743@local_refi
$LN69@local_refi:

; 459  :             }
; 460  :           }
; 461  :          
; 462  :           /* whole facet boundary parameters */
; 463  :           if ( facet_bdry_flag && (get_vattr(allv[j][i]) & Q_MIDFACET) )

	cmp	DWORD PTR _facet_bdry_flag$89308[ebp], 0
	je	$LN857@local_refi
	mov	ecx, DWORD PTR _web+12
	mov	edi, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 2097152				; 00200000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN857@local_refi

; 464  :             { REAL * vp = get_param(allv[j][i]);

	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax+544]
	mov	ebx, DWORD PTR _oldp$[ebp]
	add	eax, edi
	mov	DWORD PTR _vp$89565[ebp], eax
	xor	esi, esi
$LN744@local_refi:
	mov	edi, DWORD PTR _web+232

; 466  :               { for ( k = 0, sum = 0.0 ; k < web.skel[FACET].ctrlpts ; k++ )

	fld	ST(0)
	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN772@local_refi
	mov	eax, DWORD PTR tv10758[ebp]
	imul	eax, DWORD PTR _j$89203[ebp]
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _interp$[ebp]
	sar	eax, 1
	add	eax, DWORD PTR tv10756[ebp]
	add	eax, DWORD PTR _i$89202[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
$LN61@local_refi:

; 467  :                   sum += interp[i+2*N*j+(3*j-j*j)/2][k]*oldp[k][n];

	mov	edx, DWORD PTR [ebx+ecx*4]
	fld	QWORD PTR [edx+esi]
	inc	ecx
	fmul	QWORD PTR [eax]
	add	eax, 8
	faddp	ST(1), ST(0)
	cmp	ecx, edi
	jl	SHORT $LN61@local_refi
$LN772@local_refi:

; 468  :                 vp[n] = sum;

	mov	eax, DWORD PTR _vp$89565[ebp]
	fstp	QWORD PTR [esi+eax]
	add	esi, 8
	cmp	esi, 16					; 00000010H
	jl	SHORT $LN744@local_refi
$LN857@local_refi:

; 447  :         for ( i = 1; i+j < 2*N ; i++ )

	mov	eax, DWORD PTR _i$89202[ebp]

; 465  :               for ( n = 0 ; n < 2 ; n++ )

	fstp	ST(0)
	mov	ecx, DWORD PTR _j$89203[ebp]
	add	DWORD PTR tv10676[ebp], 4
	inc	eax
	add	ecx, eax
	mov	DWORD PTR _i$89202[ebp], eax
	mov	eax, DWORD PTR _N$[ebp]
	add	eax, eax
	cmp	ecx, eax
	jl	$LL75@local_refi
$LN77@local_refi:

; 443  :           }
; 444  : 
; 445  :       /* now allocate new vertices and calculate coordinates as needed */
; 446  :       for ( j = 1 ; j < 2*N ; j++)

	mov	eax, DWORD PTR _N$[ebp]
	mov	ecx, DWORD PTR tv5974[ebp]
	add	DWORD PTR tv10760[ebp], 84		; 00000054H
	dec	DWORD PTR tv10758[ebp]
	add	eax, eax
	add	DWORD PTR tv10756[ebp], eax
	mov	DWORD PTR _j$89203[ebp], ecx
	cmp	ecx, eax
	jl	$LL766@local_refi
$LN76@local_refi:

; 469  :               }
; 470  :             }
; 471  : 
; 472  :            
; 473  :         }
; 474  : 
; 475  :   
; 476  :       /* wrap coordinates of internal vertices */
; 477  :       if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	$LN22@local_refi

; 478  :       { 
; 479  :          for ( i = 1 ; i < N ; i++ )

	mov	ebx, DWORD PTR _N$[ebp]
	cmp	ebx, 1
	jle	SHORT $LN759@local_refi
	mov	edx, 2
	lea	esi, DWORD PTR _wraps$[ebp+88]
	lea	edi, DWORD PTR [ebx-1]
	npad	1
$LL57@local_refi:

; 480  :             for ( j = 1 ; i+j < N ; j++ ) wraps[j][i] = 0;

	cmp	edx, ebx
	jge	SHORT $LN56@local_refi
	mov	ecx, edx
	mov	eax, esi
	npad	8
$LL54@local_refi:
	mov	DWORD PTR [eax], 0
	inc	ecx
	add	eax, 84					; 00000054H
	cmp	ecx, ebx
	jl	SHORT $LL54@local_refi
$LN56@local_refi:

; 478  :       { 
; 479  :          for ( i = 1 ; i < N ; i++ )

	inc	edx
	add	esi, 4
	dec	edi
	jne	SHORT $LL57@local_refi
$LN759@local_refi:

; 481  :          for ( i = N+1 ; i < 2*N ; i++ )

	lea	eax, DWORD PTR [ebx+1]
	lea	esi, DWORD PTR [ebx+ebx]
	cmp	eax, esi
	jge	SHORT $LN760@local_refi
	lea	ecx, DWORD PTR _wraps$[ebp+eax*4+84]
	mov	DWORD PTR tv10920[ebp], ecx
	mov	ecx, esi
	sub	ecx, eax
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR tv2098[ebp], ecx
	npad	7
$LL51@local_refi:

; 482  :             for ( j = 1 ; i+j < 2*N ; j++ ) wraps[j][i] = w4;

	cmp	edx, esi
	jge	SHORT $LN50@local_refi
	mov	eax, DWORD PTR tv10920[ebp]
	mov	ecx, edx
	npad	4
$LL48@local_refi:
	mov	edi, DWORD PTR _w4$[ebp]
	mov	DWORD PTR [eax], edi
	inc	ecx
	add	eax, 84					; 00000054H
	cmp	ecx, esi
	jl	SHORT $LL48@local_refi
$LN50@local_refi:

; 481  :          for ( i = N+1 ; i < 2*N ; i++ )

	add	DWORD PTR tv10920[ebp], 4
	inc	edx
	dec	DWORD PTR tv2098[ebp]
	jne	SHORT $LL51@local_refi
$LN760@local_refi:

; 483  :          for ( i = 1 ; i < N ; i++ )

	mov	edi, DWORD PTR _w6$[ebp]
	mov	eax, 1
	cmp	ebx, eax
	jle	SHORT $LN43@local_refi
	npad	1
$LL45@local_refi:

; 484  :             for ( j = N+1 ; i+j < 2*N ; j++ ) wraps[j][i] = w6;

	lea	ecx, DWORD PTR [ebx+1]
	lea	edx, DWORD PTR [ecx+eax]
	cmp	edx, esi
	jge	SHORT $LN44@local_refi
	imul	ecx, 21					; 00000015H
	add	ecx, eax
	lea	ecx, DWORD PTR _wraps$[ebp+ecx*4]
$LL42@local_refi:
	mov	DWORD PTR [ecx], edi
	inc	edx
	add	ecx, 84					; 00000054H
	cmp	edx, esi
	jl	SHORT $LL42@local_refi
$LN44@local_refi:

; 483  :          for ( i = 1 ; i < N ; i++ )

	inc	eax
	cmp	eax, ebx
	jl	SHORT $LL45@local_refi
$LN43@local_refi:

; 485  :          for ( i = 1 ; i < N ; i++ )

	mov	eax, 1
	cmp	ebx, eax
	jle	$LN25@local_refi
	mov	ecx, ebx
	imul	ecx, 21					; 00000015H
	mov	esi, ebx
	mov	DWORD PTR tv11052[ebp], ecx
	npad	1
$LL39@local_refi:

; 486  :             for ( j = N-i+1 ; j < N ; j++ ) wraps[j][i] = w5;

	cmp	esi, ebx
	jge	SHORT $LN38@local_refi
	lea	edx, DWORD PTR [ecx+eax]
	mov	ecx, ebx
	lea	edx, DWORD PTR _wraps$[ebp+edx*4]
	sub	ecx, esi
$LL36@local_refi:
	mov	edi, DWORD PTR _w5$[ebp]
	mov	DWORD PTR [edx], edi
	add	edx, 84					; 00000054H
	dec	ecx
	jne	SHORT $LL36@local_refi
	mov	edi, DWORD PTR _w6$[ebp]
	mov	ecx, DWORD PTR tv11052[ebp]
$LN38@local_refi:

; 485  :          for ( i = 1 ; i < N ; i++ )

	inc	eax
	sub	ecx, 21					; 00000015H
	dec	esi
	mov	DWORD PTR tv11052[ebp], ecx
	cmp	eax, ebx
	jl	SHORT $LL39@local_refi

; 487  :          for ( i = 1 ; i < N ; i++ ) wraps[N-i][i] = w4;

	cmp	ebx, 1
	jle	SHORT $LN25@local_refi
	mov	edx, ebx
	imul	edx, 84					; 00000054H
	lea	eax, DWORD PTR _wraps$[ebp+edx-80]
	lea	ecx, DWORD PTR [ebx-1]
	npad	1
$LL33@local_refi:
	mov	edx, DWORD PTR _w4$[ebp]
	mov	DWORD PTR [eax], edx
	sub	eax, 80					; 00000050H
	dec	ecx
	jne	SHORT $LL33@local_refi

; 488  :          for ( i = 1 ; i < N ; i++ ) wraps[N][i] = w6;

	cmp	ebx, 1
	jle	SHORT $LN25@local_refi
	mov	eax, ebx
	imul	eax, 84					; 00000054H
	lea	edx, DWORD PTR _wraps$[ebp+eax+4]
	mov	eax, edi
	lea	ecx, DWORD PTR [ebx-1]
	mov	edi, edx
	rep stosd

; 489  :          for ( j = 1 ; j < N ; j++ ) wraps[j][N] = w5;

	cmp	ebx, 1
	jle	SHORT $LN25@local_refi
	lea	eax, DWORD PTR _wraps$[ebp+ebx*4+84]
	lea	ecx, DWORD PTR [ebx-1]
	npad	9
$LL27@local_refi:
	mov	edx, DWORD PTR _w5$[ebp]
	mov	DWORD PTR [eax], edx
	add	eax, 84					; 00000054H
	dec	ecx
	jne	SHORT $LL27@local_refi
$LN25@local_refi:

; 490  :          /* now unwrap coordinates */
; 491  :          for ( i = 1 ; i < 2*N ; i++ )

	add	ebx, ebx
	cmp	ebx, 1
	jle	$LN22@local_refi
	mov	eax, DWORD PTR _N$[ebp]
	add	eax, eax
	dec	eax
	mov	DWORD PTR tv11362[ebp], 4
	mov	DWORD PTR tv11364[ebp], 2
	mov	DWORD PTR tv457[ebp], eax
	npad	4
$LL780@local_refi:

; 492  :            for ( j = 1 ; i+j < 2*N ; j++ ) 

	mov	eax, DWORD PTR _N$[ebp]
	add	eax, eax
	cmp	DWORD PTR tv11364[ebp], eax
	jge	$LN23@local_refi
	mov	ebx, DWORD PTR tv11364[ebp]
	mov	edi, DWORD PTR tv11362[ebp]
$LL745@local_refi:

; 493  :            { REAL newx[MAXCOORD];
; 494  :              REAL *vx = get_coord(allv[j][i]);

	mov	eax, DWORD PTR _allv$[ebp+edi+84]
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]

; 495  :              (*sym_wrap)(vx,newx,sym_inverse(wraps[j][i]));

	mov	ecx, DWORD PTR _wraps$[ebp+edi+84]
	mov	eax, DWORD PTR _web+104
	add	esi, DWORD PTR [eax+edx+64]
	push	ecx
	call	DWORD PTR _sym_inverse
	push	eax
	lea	edx, DWORD PTR _newx$89616[ebp]
	push	edx
	push	esi
	call	DWORD PTR _sym_wrap

; 496  :              for ( k = 0 ; k < SDIM ; k++ ) vx[k] = newx[k];

	xor	ecx, ecx
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN20@local_refi
	lea	edx, DWORD PTR _newx$89616[ebp]
	mov	eax, esi
	sub	edx, esi
$LL18@local_refi:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL18@local_refi
$LN20@local_refi:

; 492  :            for ( j = 1 ; i+j < 2*N ; j++ ) 

	mov	eax, DWORD PTR _N$[ebp]
	inc	ebx
	add	eax, eax
	add	edi, 84					; 00000054H
	cmp	ebx, eax
	jl	SHORT $LL745@local_refi
$LN23@local_refi:

; 490  :          /* now unwrap coordinates */
; 491  :          for ( i = 1 ; i < 2*N ; i++ )

	add	DWORD PTR tv11362[ebp], 4
	mov	eax, 1
	add	DWORD PTR tv11364[ebp], eax
	sub	DWORD PTR tv457[ebp], eax
	jne	$LL780@local_refi
$LN22@local_refi:

; 497  :            }
; 498  :       }
; 499  : 
; 500  :       /* assign vertices to facets */
; 501  :       v0 = get_facet_vertices(f_id);

	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+328
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR _f_id$[ebp]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	add	ecx, eax
	mov	DWORD PTR _v0$89304[ebp], ecx

; 502  :       v1 = get_facet_vertices(newf[0]);

	mov	ecx, DWORD PTR _newf$[ebp]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	add	ecx, eax
	mov	DWORD PTR _v1$89305[ebp], ecx

; 503  :       v2 = get_facet_vertices(newf[1]);

	mov	ecx, DWORD PTR _newf$[ebp+4]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	add	ecx, eax
	mov	DWORD PTR _v2$89306[ebp], ecx

; 504  :       v3 = get_facet_vertices(newf[2]);

	mov	ecx, DWORD PTR _newf$[ebp+8]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	add	ecx, eax
	mov	DWORD PTR _v3$89307[ebp], ecx

; 505  :       for ( i = 0 ; i <= N ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _N$[ebp], ecx
	jl	$LN13@local_refi

; 497  :            }
; 498  :       }
; 499  : 
; 500  :       /* assign vertices to facets */
; 501  :       v0 = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _N$[ebp]
	lea	edx, DWORD PTR _allv$[ebp]
	mov	DWORD PTR tv11646[ebp], edx
	lea	edx, DWORD PTR _allv$[ebp+eax*4]
	mov	DWORD PTR tv11653[ebp], edx
	npad	7
$LL15@local_refi:

; 506  :         for ( j = 0 ; i+j <= N ; j++ )

	xor	esi, esi
	cmp	ecx, DWORD PTR _N$[ebp]
	jg	$LN14@local_refi
	mov	eax, DWORD PTR tv11646[ebp]
	mov	DWORD PTR tv11554[ebp], eax
	mov	eax, DWORD PTR _N$[ebp]
	mov	edx, eax
	imul	eax, 22					; 00000016H
	imul	edx, 21					; 00000015H
	add	edx, ecx
	lea	edx, DWORD PTR _allv$[ebp+edx*4]
	sub	eax, ecx
	mov	DWORD PTR tv11577[ebp], edx
	mov	edx, DWORD PTR tv11653[ebp]
	lea	eax, DWORD PTR _allv$[ebp+eax*4]
	mov	DWORD PTR tv11394[ebp], esi
	lea	edi, DWORD PTR [esi+3]
	mov	DWORD PTR tv11579[ebp], edx
	mov	DWORD PTR tv11598[ebp], eax
	npad	5
$LL750@local_refi:

; 507  :         { int spot = i + N*j + (3*j-j*j)/2;
; 508  :           v0[spot] = allv[N-j][N-i];

	mov	ebx, DWORD PTR _v0$89304[ebp]
	mov	eax, edi
	imul	eax, esi
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR tv11598[ebp]
	mov	edx, DWORD PTR [edx]
	sar	eax, 1
	add	eax, ecx
	add	eax, DWORD PTR tv11394[ebp]
	mov	DWORD PTR [ebx+eax*4], edx

; 509  :           v1[spot] = allv[j][i];

	mov	edx, DWORD PTR tv11554[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ebx, DWORD PTR _v1$89305[ebp]
	mov	DWORD PTR [ebx+eax*4], edx

; 510  :           v2[spot] = allv[j][N+i];

	mov	edx, DWORD PTR tv11579[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ebx, DWORD PTR _v2$89306[ebp]
	mov	DWORD PTR [ebx+eax*4], edx

; 511  :           v3[spot] = allv[N+j][i];

	mov	edx, DWORD PTR tv11577[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ebx, DWORD PTR _v3$89307[ebp]
	mov	DWORD PTR [ebx+eax*4], edx

; 512  :           if ( (i>0) && (j>0) && (i+j<N) )

	test	ecx, ecx
	jle	$LN11@local_refi
	test	esi, esi
	jle	$LN11@local_refi
	lea	edx, DWORD PTR [esi+ecx]
	cmp	edx, DWORD PTR _N$[ebp]
	jge	$LN11@local_refi

; 513  :           { set_vertex_facet(v0[spot],f_id);

	mov	ebx, DWORD PTR _web+12
	mov	edx, DWORD PTR _v0$89304[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _f_id$[ebp]
	mov	DWORD PTR [edx+32], ebx

; 514  :             set_vertex_facet(v1[spot],newf[0]);

	mov	edx, DWORD PTR _v1$89305[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	ebx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _newf$[ebp]
	mov	DWORD PTR [edx+32], ebx

; 515  :             set_vertex_facet(v2[spot],newf[1]);

	mov	edx, DWORD PTR _v2$89306[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	ebx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _newf$[ebp+4]
	mov	DWORD PTR [edx+32], ebx

; 516  :             set_vertex_facet(v3[spot],newf[2]);

	mov	edx, DWORD PTR _v3$89307[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _newf$[ebp+8]
	mov	DWORD PTR [eax+32], edx
$LN11@local_refi:

; 506  :         for ( j = 0 ; i+j <= N ; j++ )

	mov	eax, DWORD PTR _N$[ebp]
	add	DWORD PTR tv11394[ebp], eax
	mov	edx, 84					; 00000054H
	add	DWORD PTR tv11554[ebp], edx
	add	DWORD PTR tv11579[ebp], edx
	add	DWORD PTR tv11577[ebp], edx
	sub	DWORD PTR tv11598[ebp], edx
	inc	esi
	lea	edx, DWORD PTR [esi+ecx]
	dec	edi
	cmp	edx, eax
	jle	$LL750@local_refi
$LN14@local_refi:

; 505  :       for ( i = 0 ; i <= N ; i++ )

	mov	eax, 4
	add	DWORD PTR tv11646[ebp], eax
	add	DWORD PTR tv11653[ebp], eax
	inc	ecx
	cmp	ecx, DWORD PTR _N$[ebp]
	jle	$LL15@local_refi
$LN13@local_refi:

; 517  :           }
; 518  :        }
; 519  :     }
; 520  : 
; 521  :     /* adjust facet_fe so new facets similar to old */
; 522  :     if ( valid_id(newf[1]) )

	mov	ecx, DWORD PTR _newf$[ebp+4]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN763@local_refi

; 523  :        set_facet_fe(newf[1],get_prev_edge(get_facet_fe(newf[1])));

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN540@local_refi
	xor	eax, 134217728				; 08000000H
$LN540@local_refi:
	mov	edx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN545@local_refi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN544@local_refi
$LN545@local_refi:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]
$LN544@local_refi:
	push	eax
	push	ecx
	call	_set_facet_fe
	add	esp, 8
$LN763@local_refi:

; 524  :     if ( valid_id(newf[2]) )

	mov	ecx, DWORD PTR _newf$[ebp+8]
	mov	edi, DWORD PTR _web+460
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN785@local_refi

; 525  :        set_facet_fe(newf[2],get_next_edge(get_facet_fe(newf[2])));

	mov	eax, DWORD PTR _web+236
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edx+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN548@local_refi
	xor	eax, 134217728				; 08000000H
$LN548@local_refi:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN553@local_refi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN552@local_refi
$LN553@local_refi:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [edx+32]
$LN552@local_refi:
	push	eax
	push	ecx
	call	_set_facet_fe
	mov	edi, DWORD PTR _web+460
	add	esp, 8
$LN785@local_refi:

; 526  : 
; 527  :     if ( web.symmetry_flag && (sym_flags & HAS_FIXED_PTS) )

	cmp	DWORD PTR _web+856, 0
	je	$LN582@local_refi
	test	BYTE PTR _sym_flags, 1
	je	$LN582@local_refi

; 528  :     { /* get proper wrap on edge cutting off old base point */
; 529  :       edge_id prev_e,next_e;
; 530  :       WRAPTYPE we,wn,wp,wi;
; 531  :       fe = get_facet_fe(f_id);

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN557@local_refi
	xor	eax, eax
	jmp	SHORT $LN556@local_refi
$LN557@local_refi:
	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN556@local_refi
	xor	eax, 134217728				; 08000000H
$LN556@local_refi:

; 532  :       e_id = get_fe_edge(fe);

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+ecx*4]
	lea	edx, DWORD PTR [edi+ecx*4]
	mov	ecx, eax
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [esi+20]

; 533  :       prev_e = get_fe_edge(get_prev_edge(fe));

	shr	eax, 27					; 0000001bH
	mov	esi, eax
	and	esi, 1
	mov	DWORD PTR _e_id$[ebp], ecx
	mov	edx, DWORD PTR [edx]
	je	SHORT $LN563@local_refi
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN562@local_refi
$LN563@local_refi:
	mov	eax, DWORD PTR [edx+28]
$LN562@local_refi:
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edi+ebx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ebx+20]
	mov	ebx, eax

; 534  :       next_e = get_fe_edge(get_next_edge(fe));

	test	esi, esi
	je	SHORT $LN569@local_refi
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN568@local_refi
$LN569@local_refi:
	mov	eax, DWORD PTR [edx+32]
$LN568@local_refi:
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]

; 535  :       we = get_edge_wrap(e_id);

	mov	edi, DWORD PTR _dymem
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _web+124
	mov	esi, eax
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+edi+784]
	mov	eax, DWORD PTR [eax+edx]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN576@local_refi
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN576@local_refi:

; 536  :       wp = get_edge_wrap(prev_e);

	mov	ecx, DWORD PTR _web+124
	mov	edi, eax
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN580@local_refi
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN580@local_refi:

; 537  :       wi = (*sym_compose)(wp,we);

	push	edi
	push	eax
	call	DWORD PTR _sym_compose

; 538  :       wn = (*sym_inverse)(wi);

	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 12					; 0000000cH

; 539  :       set_edge_wrap(next_e,wn);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN584@local_refi
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN584@local_refi:
	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+esi+784]
	mov	DWORD PTR [edx+ecx], eax
$LN582@local_refi:

; 151  :   while ( generate_all(FACET,&f_id,&sentinel) )

	lea	edx, DWORD PTR _sentinel$[ebp]
	push	edx
	lea	eax, DWORD PTR _f_id$[ebp]
	push	eax
	push	2
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LL231@local_refi
$windup$89154:

; 540  :     }
; 541  : 
; 542  :   } 
; 543  : 
; 544  : windup:
; 545  :   if ( web.modeltype == LAGRANGE ) 

	cmp	DWORD PTR _web+628, 3
	jne	SHORT $LN764@local_refi

; 546  :   { if ( !bezier_flag ) free_matrix(interp);

	cmp	DWORD PTR _bezier_flag, 0
	jne	SHORT $LN4@local_refi
	mov	ecx, DWORD PTR _interp$[ebp]
	push	ecx
	call	_free_matrix
	add	esp, 4
$LN4@local_refi:

; 547  :     free_matrix(oldx);

	mov	edx, DWORD PTR _oldx$[ebp]
	push	edx
	call	_free_matrix
	add	esp, 4
$LN764@local_refi:

; 548  :   } 
; 549  :   if ( oldp ) free_matrix(oldp);

	mov	eax, DWORD PTR _oldp$[ebp]
	test	eax, eax
	je	SHORT $LN3@local_refi
	push	eax
	call	_free_matrix
	add	esp, 4
$LN3@local_refi:

; 550  :   if ( reflevel < MAXLEVEL-1 ) reflevel++;  /* for extrapolation */

	cmp	DWORD PTR _reflevel, 29			; 0000001dH
	jge	SHORT $LN765@local_refi
	inc	DWORD PTR _reflevel
$LN765@local_refi:

; 551  :   autochop_length /= 2;    /* keep same relative scale */

	fld	QWORD PTR _autochop_length

; 552  :   bare_edge_count++;

	inc	DWORD PTR _bare_edge_count

; 553  : 
; 554  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89143[ebp], 0
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR _autochop_length
	je	SHORT $LN1@local_refi
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@local_refi:

; 555  : 
; 556  : } /* end refine() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_local_refine ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@DNCDCMFB@?$CFg?5?9?5?$CFg?5?5?5?5?5?5?$CF6d?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@DMDGNPBD@?$CFf?5?9?5?$CFg?5?5?5?5?5?5?$CF6d?5?6?$AA@ ; `string'
PUBLIC	__real@c02bb9d3beb8c86b
PUBLIC	??_C@_0CG@HEMKBGFB@?5?5?5?5?5?5?5?5?5area?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5nu@ ; `string'
PUBLIC	__real@3ff71547652b82fe
PUBLIC	__real@408f400000000000
PUBLIC	__$ArrayPad$
PUBLIC	_area_histogram
EXTRN	_sprintf:PROC
EXTRN	_msg:DWORD
EXTRN	_outstring:PROC
EXTRN	_recalc_facet_area:PROC
EXTRN	__CIexp:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_floor:PROC
EXTRN	__CIlog:PROC
;	COMDAT ??_C@_0BC@DNCDCMFB@?$CFg?5?9?5?$CFg?5?5?5?5?5?5?$CF6d?6?$AA@
CONST	SEGMENT
??_C@_0BC@DNCDCMFB@?$CFg?5?9?5?$CFg?5?5?5?5?5?5?$CF6d?6?$AA@ DB '%g - %g '
	DB	'     %6d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DMDGNPBD@?$CFf?5?9?5?$CFg?5?5?5?5?5?5?$CF6d?5?6?$AA@
CONST	SEGMENT
??_C@_0BD@DMDGNPBD@?$CFf?5?9?5?$CFg?5?5?5?5?5?5?$CF6d?5?6?$AA@ DB '%f - %'
	DB	'g      %6d ', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT __real@c02bb9d3beb8c86b
CONST	SEGMENT
__real@c02bb9d3beb8c86b DQ 0c02bb9d3beb8c86br	; -13.8629
CONST	ENDS
;	COMDAT ??_C@_0CG@HEMKBGFB@?5?5?5?5?5?5?5?5?5area?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5nu@
CONST	SEGMENT
??_C@_0CG@HEMKBGFB@?5?5?5?5?5?5?5?5?5area?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5nu@ DB ' '
	DB	'        area                 number', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@3ff71547652b82fe
CONST	SEGMENT
__real@3ff71547652b82fe DQ 03ff71547652b82fer	; 1.4427
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _area_histogram
_TEXT	SEGMENT
tv346 = -180						; size = 4
_ref_area$ = -176					; size = 8
tv340 = -168						; size = 4
_bincount$ = -164					; size = 160
__$ArrayPad$ = -4					; size = 4
_area_histogram PROC					; COMDAT

; 838  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 839  :   facet_id f_id;  /* facet being worked on */
; 840  :   int bincount[HISTO_BINS];
; 841  :   int n;
; 842  :   REAL ref_area = web.total_area/1000;

	fld	QWORD PTR _web+992

; 843  : 
; 844  :   for ( n = 0 ; n < HISTO_BINS ; n++ ) bincount[n] = 0;

	xor	eax, eax
	fdiv	QWORD PTR __real@408f400000000000

; 845  : 
; 846  :   /* main loop sweeping over all triangles */
; 847  :   FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+272
	push	ebx
	push	esi
	mov	esi, eax
	push	edi
	mov	DWORD PTR _bincount$[ebp], esi
	mov	DWORD PTR _bincount$[ebp+4], eax
	mov	DWORD PTR _bincount$[ebp+8], eax
	mov	DWORD PTR _bincount$[ebp+12], eax
	mov	DWORD PTR _bincount$[ebp+16], eax
	mov	DWORD PTR _bincount$[ebp+20], eax
	mov	DWORD PTR _bincount$[ebp+24], eax
	mov	DWORD PTR _bincount$[ebp+28], eax
	mov	DWORD PTR _bincount$[ebp+32], eax
	mov	DWORD PTR _bincount$[ebp+36], eax
	mov	DWORD PTR _bincount$[ebp+40], eax
	mov	DWORD PTR _bincount$[ebp+44], eax
	mov	DWORD PTR _bincount$[ebp+48], eax
	mov	DWORD PTR _bincount$[ebp+52], eax
	mov	DWORD PTR _bincount$[ebp+56], eax
	mov	DWORD PTR _bincount$[ebp+60], eax
	mov	DWORD PTR _bincount$[ebp+64], eax
	mov	DWORD PTR _bincount$[ebp+68], eax
	mov	DWORD PTR _bincount$[ebp+72], eax
	mov	DWORD PTR _bincount$[ebp+76], eax
	mov	DWORD PTR _bincount$[ebp+80], eax
	mov	DWORD PTR _bincount$[ebp+84], eax
	mov	DWORD PTR _bincount$[ebp+88], eax
	mov	DWORD PTR _bincount$[ebp+92], eax
	mov	DWORD PTR _bincount$[ebp+96], eax
	mov	DWORD PTR _bincount$[ebp+100], eax
	mov	DWORD PTR _bincount$[ebp+104], eax
	mov	DWORD PTR _bincount$[ebp+108], eax
	mov	DWORD PTR _bincount$[ebp+112], eax
	mov	DWORD PTR _bincount$[ebp+116], eax
	mov	DWORD PTR _bincount$[ebp+120], eax
	mov	DWORD PTR _bincount$[ebp+124], eax
	fstp	QWORD PTR _ref_area$[ebp]
	mov	DWORD PTR _bincount$[ebp+128], eax
	mov	DWORD PTR _bincount$[ebp+132], eax
	mov	DWORD PTR _bincount$[ebp+136], eax
	mov	DWORD PTR _bincount$[ebp+140], eax
	mov	DWORD PTR _bincount$[ebp+144], eax
	mov	DWORD PTR _bincount$[ebp+148], eax
	mov	DWORD PTR _bincount$[ebp+152], eax
	mov	DWORD PTR _bincount$[ebp+156], eax
	test	ecx, 268435456				; 10000000H
	je	$LN12@area_histo
	mov	ebx, DWORD PTR _web+236
	npad	9
$LL14@area_histo:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edi, DWORD PTR [esi+ebx]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN13@area_histo

; 848  :      {
; 849  :         REAL area;      /* area of triangle */
; 850  : 
; 851  :         area = get_facet_area(f_id);

	push	ecx
	call	_recalc_facet_area
	mov	ebx, DWORD PTR _web+236
	mov	edi, DWORD PTR [esi+ebx]
	fld	QWORD PTR [edi+40]
	add	esp, 4

; 852  :         if ( area == 0.0 ) n = 0;

	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@area_histo
	fstp	ST(0)
	xor	eax, eax

; 853  :         else

	jmp	SHORT $LN6@area_histo
$LN9@area_histo:

; 854  :           n = HISTO_BINS/2 + 1 + (int)floor(log(area/ref_area)*HISTO_BINSIZE);

	fdiv	QWORD PTR _ref_area$[ebp]
	call	__CIlog
	fmul	QWORD PTR __real@3ff71547652b82fe
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	add	eax, 21					; 00000015H

; 855  :         if ( n < 0 ) n = 0;

	jns	SHORT $LN7@area_histo
	xor	eax, eax

; 856  :         if ( n >= HISTO_BINS ) n = HISTO_BINS - 1;

	jmp	SHORT $LN6@area_histo
$LN7@area_histo:
	cmp	eax, 40					; 00000028H
	jl	SHORT $LN6@area_histo
	mov	eax, 39					; 00000027H
$LN6@area_histo:

; 857  :         bincount[n]++;

	inc	DWORD PTR _bincount$[ebp+eax*4]
	lea	eax, DWORD PTR _bincount$[ebp+eax*4]
$LN13@area_histo:

; 845  : 
; 846  :   /* main loop sweeping over all triangles */
; 847  :   FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR [edi]
	test	ecx, 268435456				; 10000000H
	jne	$LL14@area_histo
	mov	esi, DWORD PTR _bincount$[ebp]
$LN12@area_histo:

; 858  :      }
; 859  :   outstring("         area                 number\n");

	push	OFFSET ??_C@_0CG@HEMKBGFB@?5?5?5?5?5?5?5?5?5area?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5nu@
	call	_outstring
	add	esp, 4

; 860  :   if ( bincount[0] )

	test	esi, esi
	je	SHORT $LN5@area_histo

; 861  :      {
; 862  :         sprintf(msg,"%f - %g      %6d \n",0.0,
; 863  :              (DOUBLE)(ref_area*exp((-HISTO_BINS/2)/HISTO_BINSIZE)), bincount[0]);

	fld	QWORD PTR __real@c02bb9d3beb8c86b
	push	esi
	call	__CIexp
	fmul	QWORD PTR _ref_area$[ebp]
	mov	eax, DWORD PTR _msg
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fldz
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BD@DMDGNPBD@?$CFf?5?9?5?$CFg?5?5?5?5?5?5?$CF6d?5?6?$AA@
	push	eax
	call	_sprintf

; 864  :         outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 32					; 00000020H
$LN5@area_histo:

; 865  :      }
; 866  :   for ( n = 1 ; n < HISTO_BINS ; n++ )

	mov	edi, -20				; ffffffecH
	mov	DWORD PTR tv340[ebp], edi
	lea	esi, DWORD PTR _bincount$[ebp+4]
	lea	ebx, DWORD PTR [edi+59]
	npad	2
$LL4@area_histo:

; 867  :     if ( bincount[n] )

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@area_histo

; 868  :      {
; 869  :         sprintf(msg,"%g - %g      %6d\n",
; 870  :                 (DOUBLE)(ref_area*exp((n-HISTO_BINS/2-1)/HISTO_BINSIZE)),
; 871  :                   (DOUBLE)(exp((n-HISTO_BINS/2)/HISTO_BINSIZE)*ref_area),bincount[n]);

	lea	edx, DWORD PTR [edi+1]
	mov	DWORD PTR tv346[ebp], edx
	fild	DWORD PTR tv346[ebp]
	push	eax
	fdiv	QWORD PTR __real@3ff71547652b82fe
	call	__CIexp
	fmul	QWORD PTR _ref_area$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fild	DWORD PTR tv340[ebp]
	fdiv	QWORD PTR __real@3ff71547652b82fe
	call	__CIexp
	fmul	QWORD PTR _ref_area$[ebp]
	mov	eax, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BC@DNCDCMFB@?$CFg?5?9?5?$CFg?5?5?5?5?5?5?$CF6d?6?$AA@
	push	eax
	call	_sprintf

; 872  :         outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 32					; 00000020H
$LN3@area_histo:

; 865  :      }
; 866  :   for ( n = 1 ; n < HISTO_BINS ; n++ )

	inc	edi
	add	esi, 4
	dec	ebx
	mov	DWORD PTR tv340[ebp], edi
	jne	SHORT $LL4@area_histo

; 873  :      }
; 874  : } // end area_histogram()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_area_histogram ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@OJBAHNBM@?5?5?5?5?5?5?5?5?5angle?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5n@ ; `string'
PUBLIC	__real@400921fb54442d18
PUBLIC	__$ArrayPad$
PUBLIC	_skinny_histogram
EXTRN	_get_edge_length:PROC
EXTRN	_calc_edge:PROC
EXTRN	__CIacos:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT ??_C@_0CH@OJBAHNBM@?5?5?5?5?5?5?5?5?5angle?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5n@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CH@OJBAHNBM@?5?5?5?5?5?5?5?5?5angle?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5n@ DB ' '
	DB	'        angle                 number', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\trirevis.c
CONST	ENDS
;	COMDAT _skinny_histogram
_TEXT	SEGMENT
tv560 = -216						; size = 8
tv578 = -212						; size = 4
tv630 = -208						; size = 4
tv394 = -208						; size = 4
_fe$89921 = -204					; size = 16
_bincount$ = -188					; size = 160
_sside$89919 = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_skinny_histogram PROC					; COMDAT

; 988  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 989  :   facet_id f_id;  /* facet being worked on */ 
; 990  :   int bincount[HISTO_BINS]; 
; 991  :   int n; 
; 992  :  
; 993  :   for ( n = 0 ; n < HISTO_BINS ; n++ ) bincount[n] = 0;

	xor	eax, eax

; 994  :   /* main loop sweeping over all triangles */ 
; 995  :   FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	push	ebx
	mov	ecx, edx
	push	esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	esi, eax
	push	edi
	mov	DWORD PTR _bincount$[ebp], esi
	mov	DWORD PTR _bincount$[ebp+4], eax
	mov	DWORD PTR _bincount$[ebp+8], eax
	mov	DWORD PTR _bincount$[ebp+12], eax
	mov	DWORD PTR _bincount$[ebp+16], eax
	mov	DWORD PTR _bincount$[ebp+20], eax
	mov	DWORD PTR _bincount$[ebp+24], eax
	mov	DWORD PTR _bincount$[ebp+28], eax
	mov	DWORD PTR _bincount$[ebp+32], eax
	mov	DWORD PTR _bincount$[ebp+36], eax
	mov	DWORD PTR _bincount$[ebp+40], eax
	mov	DWORD PTR _bincount$[ebp+44], eax
	mov	DWORD PTR _bincount$[ebp+48], eax
	mov	DWORD PTR _bincount$[ebp+52], eax
	mov	DWORD PTR _bincount$[ebp+56], eax
	mov	DWORD PTR _bincount$[ebp+60], eax
	mov	DWORD PTR _bincount$[ebp+64], eax
	mov	DWORD PTR _bincount$[ebp+68], eax
	mov	DWORD PTR _bincount$[ebp+72], eax
	mov	DWORD PTR _bincount$[ebp+76], eax
	mov	DWORD PTR _bincount$[ebp+80], eax
	mov	DWORD PTR _bincount$[ebp+84], eax
	mov	DWORD PTR _bincount$[ebp+88], eax
	mov	DWORD PTR _bincount$[ebp+92], eax
	mov	DWORD PTR _bincount$[ebp+96], eax
	mov	DWORD PTR _bincount$[ebp+100], eax
	mov	DWORD PTR _bincount$[ebp+104], eax
	mov	DWORD PTR _bincount$[ebp+108], eax
	mov	DWORD PTR _bincount$[ebp+112], eax
	mov	DWORD PTR _bincount$[ebp+116], eax
	mov	DWORD PTR _bincount$[ebp+120], eax
	mov	DWORD PTR _bincount$[ebp+124], eax
	mov	DWORD PTR _bincount$[ebp+128], eax
	mov	DWORD PTR _bincount$[ebp+132], eax
	mov	DWORD PTR _bincount$[ebp+136], eax
	mov	DWORD PTR _bincount$[ebp+140], eax
	mov	DWORD PTR _bincount$[ebp+144], eax
	mov	DWORD PTR _bincount$[ebp+148], eax
	mov	DWORD PTR _bincount$[ebp+152], eax
	mov	DWORD PTR _bincount$[ebp+156], eax
	je	$LN16@skinny_his
	mov	ebx, DWORD PTR _web+236
	npad	7
$LL52@skinny_his:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	esi, DWORD PTR [eax+ebx]
	mov	DWORD PTR tv394[ebp], eax
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN17@skinny_his

; 996  :     {
; 997  :         REAL sside[FACET_EDGES]; /* squares of side lengths */ 
; 998  :         REAL angle;      /* area of triangle */
; 999  :         facetedge_id fe[FACET_EDGES+1]; /* edges of triangle */
; 1000 :         int i;              /* side number */
; 1001 :         int smallside,mid,big;
; 1002 : 
; 1003 :         /* find sides and area */
; 1004 :         fe[0] = get_facet_fe(f_id);

	test	ecx, ecx
	jne	SHORT $LN33@skinny_his
	xor	esi, esi
	jmp	SHORT $LN32@skinny_his
$LN33@skinny_his:
	mov	esi, DWORD PTR [esi+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN32@skinny_his
	xor	esi, 134217728				; 08000000H
$LN32@skinny_his:
	mov	DWORD PTR _fe$89921[ebp], esi

; 1005 :         for ( i = 0 ; i < FACET_EDGES ; i++ ) 

	xor	edi, edi
	npad	11
$LL13@skinny_his:

; 1006 :           { 
; 1007 :              calc_edge(get_fe_edge(fe[i]));

	mov	esi, DWORD PTR _fe$89921[ebp+edi*4]
	mov	ecx, DWORD PTR _web+460
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	eax
	call	_calc_edge

; 1008 :              sside[i] = get_edge_length(get_fe_edge(fe[i]));

	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax+20]
	mov	ecx, esi
	and	ecx, 134217728				; 08000000H
	xor	ecx, eax
	push	ecx
	call	_get_edge_length
	fstp	QWORD PTR _sside$89919[ebp+edi*8]
	add	esp, 8

; 1009 :              fe[i+1] = get_next_edge(fe[i]);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN41@skinny_his
	mov	edx, DWORD PTR _web+460
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN40@skinny_his
$LN41@skinny_his:
	mov	ecx, DWORD PTR _web+460
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [edx+32]
$LN40@skinny_his:
	mov	DWORD PTR _fe$89921[ebp+edi*4+4], eax
	inc	edi
	cmp	edi, 3
	jl	$LL13@skinny_his

; 1010 :           }
; 1011 :         /* find shortest side */
; 1012 :         smallside = (sside[0] < sside[1]) ? 0 : 1;

	fld	QWORD PTR _sside$89919[ebp+8]
	fld	QWORD PTR _sside$89919[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN24@skinny_his
	xor	edx, edx
	jmp	SHORT $LN25@skinny_his
$LN24@skinny_his:
	mov	edx, 1
$LN25@skinny_his:

; 1013 :         smallside = (sside[smallside] < sside[2]) ? smallside : 2;

	fld	QWORD PTR _sside$89919[ebp+16]
	fcom	QWORD PTR _sside$89919[ebp+edx*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN53@skinny_his
	mov	edx, 2
$LN53@skinny_his:

; 1014 :         /* find longest side */
; 1015 :         big = (sside[0] > sside[1]) ? 0 : 1;

	fxch	ST(1)
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jne	SHORT $LN28@skinny_his
	xor	ecx, ecx
	jmp	SHORT $LN29@skinny_his
$LN28@skinny_his:
	mov	ecx, 1
$LN29@skinny_his:

; 1016 :         big = (sside[big] > sside[2]) ? big : 2;

	fcomp	QWORD PTR _sside$89919[ebp+ecx*8]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN31@skinny_his
	mov	ecx, 2
$LN31@skinny_his:

; 1017 :         /* find middle side */
; 1018 :         mid = 3 - (smallside+big);
; 1019 :         angle = acos((sside[mid]+sside[big]-sside[smallside])/2/
; 1020 :                                  sqrt(sside[mid]*sside[big]) );

	fld	QWORD PTR _sside$89919[ebp+ecx*8]
	mov	eax, 3
	sub	eax, ecx
	lea	ecx, DWORD PTR _sside$89919[ebp+ecx*8]
	sub	eax, edx
	fadd	QWORD PTR _sside$89919[ebp+eax*8]
	lea	eax, DWORD PTR _sside$89919[ebp+eax*8]
	fsub	QWORD PTR _sside$89919[ebp+edx*8]
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR tv560[ebp]
	fld	QWORD PTR [ecx]
	fmul	QWORD PTR [eax]
	call	__CIsqrt
	fdivr	QWORD PTR tv560[ebp]
	call	__CIacos

; 1021 :         if ( angle == 0.0 ) n = 0;

	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@skinny_his
	fstp	ST(0)
	xor	eax, eax

; 1022 :         else

	jmp	SHORT $LN6@skinny_his
$LN10@skinny_his:

; 1023 :           n = HISTO_BINS + (int)floor(log(angle/M_PI)*HISTO_BINSIZE); 

	fdiv	QWORD PTR __real@400921fb54442d18
	call	__CIlog
	fmul	QWORD PTR __real@3ff71547652b82fe
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	add	eax, 40					; 00000028H

; 1024 :           
; 1025 :         if ( n < 0 ) 

	jns	SHORT $LN8@skinny_his

; 1026 :           n = 0; 

	xor	eax, eax
	jmp	SHORT $LN6@skinny_his
$LN8@skinny_his:

; 1027 :         else if ( n >= HISTO_BINS ) 

	cmp	eax, 40					; 00000028H
	jl	SHORT $LN6@skinny_his

; 1028 :           n = HISTO_BINS - 1;

	mov	eax, 39					; 00000027H
$LN6@skinny_his:

; 1029 : 
; 1030 :         bincount[n]++;

	inc	DWORD PTR _bincount$[ebp+eax*4]
	mov	ebx, DWORD PTR _web+236
	lea	eax, DWORD PTR _bincount$[ebp+eax*4]
$LN17@skinny_his:

; 994  :   /* main loop sweeping over all triangles */ 
; 995  :   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR tv394[ebp]
	mov	ecx, DWORD PTR [eax+ebx]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL52@skinny_his
	mov	esi, DWORD PTR _bincount$[ebp]
$LN16@skinny_his:

; 1031 :      }
; 1032 : 
; 1033 :   outstring("         angle                 number\n");

	push	OFFSET ??_C@_0CH@OJBAHNBM@?5?5?5?5?5?5?5?5?5angle?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5n@
	call	_outstring
	add	esp, 4

; 1034 :   if ( bincount[0] )

	test	esi, esi
	je	SHORT $LN5@skinny_his

; 1035 :      {
; 1036 :         sprintf(msg,"%f - %g      %6d \n",0.0,
; 1037 :              (DOUBLE)(M_PI*exp((-HISTO_BINS/2)/HISTO_BINSIZE)), bincount[0]);

	fld	QWORD PTR __real@c02bb9d3beb8c86b
	push	esi
	call	__CIexp
	fmul	QWORD PTR __real@400921fb54442d18
	mov	edx, DWORD PTR _msg
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fldz
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BD@DMDGNPBD@?$CFf?5?9?5?$CFg?5?5?5?5?5?5?$CF6d?5?6?$AA@
	push	edx
	call	_sprintf

; 1038 :         outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 32					; 00000020H
$LN5@skinny_his:

; 1039 :      }
; 1040 :   for ( n = 1 ; n < HISTO_BINS ; n++ )

	mov	edi, -39				; ffffffd9H
	mov	DWORD PTR tv630[ebp], edi
	lea	esi, DWORD PTR _bincount$[ebp+4]
	lea	ebx, DWORD PTR [edi+78]
$LL4@skinny_his:

; 1041 :     if ( bincount[n] )

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@skinny_his

; 1042 :      {
; 1043 :         sprintf(msg,"%g - %g      %6d\n",
; 1044 :                 (DOUBLE)(M_PI*exp((n-HISTO_BINS)/HISTO_BINSIZE)),
; 1045 :                   (DOUBLE)(exp((n-HISTO_BINS+1)/HISTO_BINSIZE)*M_PI),bincount[n]);

	lea	ecx, DWORD PTR [edi+1]
	mov	DWORD PTR tv578[ebp], ecx
	fild	DWORD PTR tv578[ebp]
	push	eax
	fdiv	QWORD PTR __real@3ff71547652b82fe
	call	__CIexp
	fmul	QWORD PTR __real@400921fb54442d18
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fild	DWORD PTR tv630[ebp]
	fdiv	QWORD PTR __real@3ff71547652b82fe
	call	__CIexp
	fmul	QWORD PTR __real@400921fb54442d18
	mov	edx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BC@DNCDCMFB@?$CFg?5?9?5?$CFg?5?5?5?5?5?5?$CF6d?6?$AA@
	push	edx
	call	_sprintf

; 1046 :         outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 32					; 00000020H
$LN3@skinny_his:

; 1039 :      }
; 1040 :   for ( n = 1 ; n < HISTO_BINS ; n++ )

	inc	edi
	add	esi, 4
	dec	ebx
	mov	DWORD PTR tv630[ebp], edi
	jne	SHORT $LL4@skinny_his

; 1047 :      }
; 1048 : } // end skinny_histogram()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_skinny_histogram ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@MILFMNBC@?$CF8?46g?5?9?5?$CF8?46g?5?5?5?5?5?5?$CF6d?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@DMEEOPDJ@?$CF8?46g?5?9?5?$CF8?46g?5?5?5?5?5?5?$CF6d?5?6?$AA@ ; `string'
PUBLIC	??_C@_0CE@DOAOFEGN@?5?5?5?5?5side?5length?5?5?5?5?5?5?5?5?5?5?5?5numb@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_edge_histogram
EXTRN	_resize:PROC
EXTRN	_overall_size:QWORD
;	COMDAT ??_C@_0BI@MILFMNBC@?$CF8?46g?5?9?5?$CF8?46g?5?5?5?5?5?5?$CF6d?6?$AA@
CONST	SEGMENT
??_C@_0BI@MILFMNBC@?$CF8?46g?5?9?5?$CF8?46g?5?5?5?5?5?5?$CF6d?6?$AA@ DB '%'
	DB	'8.6g - %8.6g      %6d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DMEEOPDJ@?$CF8?46g?5?9?5?$CF8?46g?5?5?5?5?5?5?$CF6d?5?6?$AA@
CONST	SEGMENT
??_C@_0BJ@DMEEOPDJ@?$CF8?46g?5?9?5?$CF8?46g?5?5?5?5?5?5?$CF6d?5?6?$AA@ DB '%'
	DB	'8.6g - %8.6g      %6d ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DOAOFEGN@?5?5?5?5?5side?5length?5?5?5?5?5?5?5?5?5?5?5?5numb@
CONST	SEGMENT
??_C@_0CE@DOAOFEGN@?5?5?5?5?5side?5length?5?5?5?5?5?5?5?5?5?5?5?5numb@ DB ' '
	DB	'    side length            number', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _edge_histogram
_TEXT	SEGMENT
tv307 = -172						; size = 4
tv306 = -168						; size = 4
_bincount$ = -164					; size = 160
__$ArrayPad$ = -4					; size = 4
_edge_histogram PROC					; COMDAT

; 1109 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1115 : 
; 1116 :   /* main loop over all edges */
; 1117 : 
; 1118 :   if ( overall_size <= 0.0 ) resize();

	push	ebx
	push	esi
	push	edi

; 1110 :   edge_id e_id;
; 1111 :   int bincount[HISTO_BINS];
; 1112 :   int n;
; 1113 : 
; 1114 :   for ( n = 0 ; n < HISTO_BINS ; n++ ) bincount[n] = 0;

	xor	eax, eax

; 1115 : 
; 1116 :   /* main loop over all edges */
; 1117 : 
; 1118 :   if ( overall_size <= 0.0 ) resize();

	fldz
	fcomp	QWORD PTR _overall_size
	mov	esi, eax
	mov	DWORD PTR _bincount$[ebp+4], eax
	mov	DWORD PTR _bincount$[ebp+8], eax
	mov	DWORD PTR _bincount$[ebp+12], eax
	mov	DWORD PTR _bincount$[ebp+16], eax
	mov	DWORD PTR _bincount$[ebp+20], eax
	mov	DWORD PTR _bincount$[ebp+24], eax
	mov	DWORD PTR _bincount$[ebp+28], eax
	mov	DWORD PTR _bincount$[ebp+32], eax
	mov	DWORD PTR _bincount$[ebp+36], eax
	mov	DWORD PTR _bincount$[ebp+40], eax
	mov	DWORD PTR _bincount$[ebp+44], eax
	mov	DWORD PTR _bincount$[ebp+48], eax
	mov	DWORD PTR _bincount$[ebp+52], eax
	mov	DWORD PTR _bincount$[ebp+56], eax
	mov	DWORD PTR _bincount$[ebp+60], eax
	mov	DWORD PTR _bincount$[ebp+64], eax
	mov	DWORD PTR _bincount$[ebp+68], eax
	mov	DWORD PTR _bincount$[ebp+72], eax
	mov	DWORD PTR _bincount$[ebp+76], eax
	mov	DWORD PTR _bincount$[ebp+80], eax
	mov	DWORD PTR _bincount$[ebp+84], eax
	mov	DWORD PTR _bincount$[ebp+88], eax
	mov	DWORD PTR _bincount$[ebp+92], eax
	mov	DWORD PTR _bincount$[ebp+96], eax
	mov	DWORD PTR _bincount$[ebp+100], eax
	mov	DWORD PTR _bincount$[ebp+104], eax
	mov	DWORD PTR _bincount$[ebp+108], eax
	mov	DWORD PTR _bincount$[ebp+112], eax
	mov	DWORD PTR _bincount$[ebp+116], eax
	mov	DWORD PTR _bincount$[ebp+120], eax
	mov	DWORD PTR _bincount$[ebp+124], eax
	mov	DWORD PTR _bincount$[ebp+128], eax
	mov	DWORD PTR _bincount$[ebp+132], eax
	mov	DWORD PTR _bincount$[ebp+136], eax
	mov	DWORD PTR _bincount$[ebp+140], eax
	mov	DWORD PTR _bincount$[ebp+144], eax
	mov	DWORD PTR _bincount$[ebp+148], eax
	mov	DWORD PTR _bincount$[ebp+152], eax
	mov	DWORD PTR _bincount$[ebp+156], eax
	fnstsw	ax
	mov	DWORD PTR _bincount$[ebp], esi
	test	ah, 1
	jne	SHORT $LN15@edge_histo
	call	_resize
$LN15@edge_histo:

; 1119 :   FOR_ALL_EDGES(e_id)

	mov	edi, DWORD PTR _web+160
	test	edi, 268435456				; 10000000H
	je	$LN12@edge_histo
	mov	edx, DWORD PTR _web+124
	npad	7
$LL14@edge_histo:
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN13@edge_histo

; 1120 :      {
; 1121 :         REAL side_len;  /* actual side length */
; 1122 : 
; 1123 :         calc_edge(e_id);

	push	edi
	call	_calc_edge

; 1124 :         side_len = get_edge_length(e_id);

	push	edi
	call	_get_edge_length

; 1125 :         if ( side_len <= 0.0 ) n = 0;

	fldz
	fcomp	ST(1)
	add	esp, 8
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN9@edge_histo
	fstp	ST(0)
	xor	eax, eax

; 1126 :         else n = HISTO_BINS/2 + 1 

	jmp	SHORT $LN6@edge_histo
$LN9@edge_histo:

; 1127 :                         + (int)floor(log(side_len/overall_size)*HISTO_BINSIZE);

	fdiv	QWORD PTR _overall_size
	call	__CIlog
	fmul	QWORD PTR __real@3ff71547652b82fe
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	add	eax, 21					; 00000015H

; 1128 :         if ( n < 0 ) n = 0;

	jns	SHORT $LN7@edge_histo
	xor	eax, eax

; 1129 :         if ( n >= HISTO_BINS ) n = HISTO_BINS - 1;

	jmp	SHORT $LN6@edge_histo
$LN7@edge_histo:
	cmp	eax, 40					; 00000028H
	jl	SHORT $LN6@edge_histo
	mov	eax, 39					; 00000027H
$LN6@edge_histo:

; 1130 :         bincount[n]++;

	inc	DWORD PTR _bincount$[ebp+eax*4]
	mov	edx, DWORD PTR _web+124
	lea	eax, DWORD PTR _bincount$[ebp+eax*4]
$LN13@edge_histo:

; 1119 :   FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR [esi+edx]
	mov	edi, DWORD PTR [eax]
	test	edi, 268435456				; 10000000H
	jne	$LL14@edge_histo
	mov	esi, DWORD PTR _bincount$[ebp]
$LN12@edge_histo:

; 1131 :      }
; 1132 :   outstring("     side length            number\n");

	push	OFFSET ??_C@_0CE@DOAOFEGN@?5?5?5?5?5side?5length?5?5?5?5?5?5?5?5?5?5?5?5numb@
	call	_outstring
	add	esp, 4

; 1133 :   if ( bincount[0] )

	test	esi, esi
	je	SHORT $LN5@edge_histo

; 1134 :      {
; 1135 :         sprintf(msg,"%8.6g - %8.6g      %6d \n",0.0,
; 1136 :             (DOUBLE)(overall_size*exp((-HISTO_BINS/2)/HISTO_BINSIZE)),
; 1137 :                                                                   bincount[0]);

	fld	QWORD PTR __real@c02bb9d3beb8c86b
	push	esi
	call	__CIexp
	fmul	QWORD PTR _overall_size
	mov	ecx, DWORD PTR _msg
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fldz
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BJ@DMEEOPDJ@?$CF8?46g?5?9?5?$CF8?46g?5?5?5?5?5?5?$CF6d?5?6?$AA@
	push	ecx
	call	_sprintf

; 1138 :         outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 32					; 00000020H
$LN5@edge_histo:

; 1139 :      }
; 1140 :   for ( n = 1 ; n < HISTO_BINS ; n++ )

	mov	edi, -20				; ffffffecH
	mov	DWORD PTR tv306[ebp], edi
	lea	esi, DWORD PTR _bincount$[ebp+4]
	lea	ebx, DWORD PTR [edi+59]
$LL4@edge_histo:

; 1141 :     if ( bincount[n] )

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@edge_histo

; 1142 :      {
; 1143 :         sprintf(msg,"%8.6g - %8.6g      %6d\n",
; 1144 :             (DOUBLE)(overall_size*exp((n-HISTO_BINS/2-1)/HISTO_BINSIZE)),
; 1145 :             (DOUBLE)(overall_size*exp((n-HISTO_BINS/2)/HISTO_BINSIZE)),bincount[n]);

	push	eax
	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR tv307[ebp], eax
	fild	DWORD PTR tv307[ebp]
	fdiv	QWORD PTR __real@3ff71547652b82fe
	call	__CIexp
	fmul	QWORD PTR _overall_size
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fild	DWORD PTR tv306[ebp]
	fdiv	QWORD PTR __real@3ff71547652b82fe
	call	__CIexp
	fmul	QWORD PTR _overall_size
	mov	ecx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BI@MILFMNBC@?$CF8?46g?5?9?5?$CF8?46g?5?5?5?5?5?5?$CF6d?6?$AA@
	push	ecx
	call	_sprintf

; 1146 :         outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 32					; 00000020H
$LN3@edge_histo:

; 1139 :      }
; 1140 :   for ( n = 1 ; n < HISTO_BINS ; n++ )

	inc	edi
	add	esi, 4
	dec	ebx
	mov	DWORD PTR tv306[ebp], edi
	jne	SHORT $LL4@edge_histo

; 1147 :      }
; 1148 : } // end edge_histogram()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_histogram ENDP
_TEXT	ENDS
PUBLIC	_body_facet_fixup
; Function compile flags: /Ogtp
;	COMDAT _body_facet_fixup
_TEXT	SEGMENT
tv399 = -8						; size = 4
tv388 = -4						; size = 4
_facet$ = 8						; size = 4
_body_facet_fixup PROC					; COMDAT

; 1753 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 1754 :   body_id b_id;
; 1755 :   facet_id bf_id;
; 1756 :   facet_id f_id;
; 1757 : 
; 1758 :   /* fix any body references to facet */
; 1759 :   if ( valid_id(facet) )

	mov	ebx, DWORD PTR _facet$[ebp]
	test	ebx, 268435456				; 10000000H
	je	$LN45@body_facet

; 1760 :   { b_id = get_facet_body(facet);

	push	edi
	push	ebx
	call	_get_facet_body
	mov	edi, eax

; 1761 :     bf_id = get_body_facet(b_id);

	mov	ecx, edi
	shr	ecx, 28					; 0000001cH
	add	esp, 4
	and	ecx, 1
	mov	DWORD PTR tv388[ebp], ecx
	je	SHORT $LN24@body_facet
	mov	edx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+400]
	jmp	SHORT $LN25@body_facet
$LN24@body_facet:
	xor	eax, eax
$LN25@body_facet:

; 1762 :     if ( equal_element(facet,bf_id) )

	mov	edx, ebx
	or	edx, 134217728				; 08000000H
	or	eax, 134217728				; 08000000H
	push	esi
	mov	DWORD PTR tv399[ebp], edx
	cmp	edx, eax
	jne	$LN32@body_facet

; 1763 :     { /* need to reset body facet */
; 1764 :       set_body_facet(b_id,NULLID);  /* in case none found */

	test	ecx, ecx
	je	SHORT $LN26@body_facet
	mov	edx, DWORD PTR _web+348
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+400], 0
$LN26@body_facet:

; 1765 :       FOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR _web+272
	test	esi, 268435456				; 10000000H
	je	$LN32@body_facet
$LL58@body_facet:
	mov	edx, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [ebx+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN16@body_facet

; 1766 :       { if ( equal_element(f_id,facet) ) continue;

	mov	eax, esi
	or	eax, 134217728				; 08000000H
	cmp	eax, DWORD PTR tv399[ebp]
	je	SHORT $LN16@body_facet

; 1767 :         if ( equal_id(get_facet_body(f_id),b_id) )

	push	esi
	call	_get_facet_body
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN50@body_facet

; 1769 :         if ( equal_id(get_facet_body(inverse_id(f_id)),b_id) )

	mov	ecx, esi
	xor	ecx, 134217728				; 08000000H
	push	ecx
	call	_get_facet_body
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN51@body_facet
$LN16@body_facet:

; 1765 :       FOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR [ebx]
	test	esi, 268435456				; 10000000H
	jne	SHORT $LL58@body_facet

; 1783 :         if ( equal_id(get_facet_body(inverse_id(f_id)),b_id) )

	jmp	SHORT $LN59@body_facet
$LN50@body_facet:

; 1768 :         { set_body_facet(b_id,f_id); break; }

	cmp	DWORD PTR tv388[ebp], 0
	je	SHORT $LN59@body_facet
	mov	edx, DWORD PTR _web+348
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+edi*4]
	mov	DWORD PTR [eax+400], esi
	jmp	SHORT $LN59@body_facet
$LN51@body_facet:

; 1770 :         { set_body_facet(b_id,inverse_id(f_id)); break; }

	cmp	DWORD PTR tv388[ebp], 0
	je	SHORT $LN59@body_facet
	mov	ecx, DWORD PTR _web+348
	xor	esi, 134217728				; 08000000H
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	DWORD PTR [edx+400], esi
$LN59@body_facet:

; 1768 :         { set_body_facet(b_id,f_id); break; }

	mov	ebx, DWORD PTR _facet$[ebp]

; 1770 :         { set_body_facet(b_id,inverse_id(f_id)); break; }

$LN32@body_facet:

; 1771 :       }
; 1772 :     }
; 1773 :     b_id = get_facet_body(inverse_id(facet));

	xor	ebx, 134217728				; 08000000H
	push	ebx
	call	_get_facet_body
	mov	edi, eax

; 1774 :     bf_id = get_body_facet(b_id);

	shr	eax, 28					; 0000001cH
	add	esp, 4
	and	eax, 1
	mov	DWORD PTR tv388[ebp], eax
	je	SHORT $LN37@body_facet
	mov	edx, DWORD PTR _web+348
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+400]
	jmp	SHORT $LN38@body_facet
$LN37@body_facet:
	xor	ecx, ecx
$LN38@body_facet:

; 1775 :     if ( equal_element(facet,bf_id) )

	or	ecx, 134217728				; 08000000H
	cmp	DWORD PTR tv399[ebp], ecx
	jne	$LN62@body_facet

; 1776 :     { /* need to reset body facet */
; 1777 :       set_body_facet(b_id,NULLID);  /* in case none found */

	test	eax, eax
	je	SHORT $LN39@body_facet
	mov	eax, DWORD PTR _web+348
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+400], 0
$LN39@body_facet:

; 1778 :       FOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR _web+272
	test	esi, 268435456				; 10000000H
	je	$LN62@body_facet
	npad	1
$LL60@body_facet:
	mov	ebx, DWORD PTR _web+236
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN7@body_facet

; 1779 :       { invert(f_id);

	xor	esi, 134217728				; 08000000H

; 1780 :         if ( equal_element(f_id,facet) ) continue;

	mov	eax, esi
	or	eax, 134217728				; 08000000H
	cmp	eax, DWORD PTR tv399[ebp]
	je	SHORT $LN7@body_facet

; 1781 :         if ( equal_id(get_facet_body(f_id),b_id) )

	push	esi
	call	_get_facet_body
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN52@body_facet

; 1783 :         if ( equal_id(get_facet_body(inverse_id(f_id)),b_id) )

	mov	ecx, esi
	xor	ecx, 134217728				; 08000000H
	push	ecx
	call	_get_facet_body
	add	esp, 4
	cmp	eax, edi
	je	SHORT $LN53@body_facet
$LN7@body_facet:

; 1778 :       FOR_ALL_FACETS(f_id)

	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+esi*4]
	mov	esi, DWORD PTR [edx]
	test	esi, 268435456				; 10000000H
	jne	SHORT $LL60@body_facet
	pop	esi
	pop	edi
	pop	ebx

; 1785 :       }
; 1786 :     }
; 1787 :   }
; 1788 : } // end body_facet_fixup()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@body_facet:

; 1782 :         { set_body_facet(b_id,f_id); break; }

	cmp	DWORD PTR tv388[ebp], 0
	je	SHORT $LN62@body_facet
	mov	eax, DWORD PTR _web+348
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [ecx+400], esi
	pop	esi
	pop	edi
	pop	ebx

; 1785 :       }
; 1786 :     }
; 1787 :   }
; 1788 : } // end body_facet_fixup()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@body_facet:

; 1784 :         { set_body_facet(b_id,inverse_id(f_id)); break; }

	cmp	DWORD PTR tv388[ebp], 0
	je	SHORT $LN62@body_facet
	mov	edx, DWORD PTR _web+348
	xor	esi, 134217728				; 08000000H
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+edi*4]
	mov	DWORD PTR [eax+400], esi
$LN62@body_facet:
	pop	esi
	pop	edi
$LN45@body_facet:
	pop	ebx

; 1785 :       }
; 1786 :     }
; 1787 :   }
; 1788 : } // end body_facet_fixup()

	mov	esp, ebp
	pop	ebp
	ret	0
_body_facet_fixup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@FLHGBHLG@Internal?5error?3?5change_vertex?3?5l@ ; `string'
PUBLIC	_change_vertex
;	COMDAT ??_C@_0CO@FLHGBHLG@Internal?5error?3?5change_vertex?3?5l@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CO@FLHGBHLG@Internal?5error?3?5change_vertex?3?5l@ DB 'Internal er'
	DB	'ror: change_vertex: looping edge! ', 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\trirevis.c
CONST	ENDS
;	COMDAT _change_vertex
_TEXT	SEGMENT
tv348 = -4						; size = 4
_fe$ = 8						; size = 4
_old_v$ = 12						; size = 4
_new_v$ = 16						; size = 4
_wrap$ = 20						; size = 4
_change_vertex PROC					; COMDAT

; 1807 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi

; 1808 :   facetedge_id next_fe;  /* looping around current edge */
; 1809 :   facetedge_id pre_fe;    /* going back around facet to new edge */
; 1810 :   edge_id e_id;
; 1811 : 
; 1812 :   if ( equal_id(old_v,new_v) )

	mov	edi, DWORD PTR _new_v$[ebp]
	cmp	DWORD PTR _old_v$[ebp], edi
	jne	SHORT $LN6@change_ver

; 1813 :       kb_error(1346,"Internal error: change_vertex: looping edge! ",WARNING);

	push	2
	push	OFFSET ??_C@_0CO@FLHGBHLG@Internal?5error?3?5change_vertex?3?5l@
	push	1346					; 00000542H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN6@change_ver:

; 1814 : 
; 1815 : 
; 1816 :   e_id = get_fe_edge(fe);

	mov	ebx, DWORD PTR _fe$[ebp]
	mov	ecx, DWORD PTR _web+460
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	esi, ebx
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [edx+20]

; 1817 :   set_edge_tailv(e_id,new_v);

	push	edi
	push	esi
	call	_set_edge_tailv
	add	esp, 8

; 1818 :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN15@change_ver

; 1819 :         set_edge_wrap(e_id,(*sym_compose)(wrap,get_edge_wrap(e_id)));

	mov	eax, DWORD PTR _web+124
	mov	edx, DWORD PTR _web+216
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+784]
	mov	eax, DWORD PTR [ecx+edx]
	shr	esi, 27					; 0000001bH
	and	esi, 1
	je	SHORT $LN13@change_ver
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN13@change_ver:
	push	eax
	mov	eax, DWORD PTR _wrap$[ebp]
	push	eax
	call	DWORD PTR _sym_compose
	add	esp, 8
	test	esi, esi
	je	SHORT $LN17@change_ver
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN17@change_ver:
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [edi+ecx]
	mov	ecx, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+esi+784]
	mov	DWORD PTR [edx+ecx], eax
$LN15@change_ver:

; 1820 : 
; 1821 :   next_fe = fe;

	mov	edx, DWORD PTR _web+460
	mov	eax, ebx
	mov	ebx, DWORD PTR _dymem
$LL4@change_ver:

; 1822 :   do
; 1823 :      { pre_fe = fe_inverse(get_prev_edge(next_fe));

	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR tv348[ebp], ecx
	je	SHORT $LN20@change_ver
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN19@change_ver
$LN20@change_ver:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [ecx+28]
$LN19@change_ver:
	xor	eax, 134217728				; 08000000H
	mov	ecx, eax

; 1824 :         if ( equal_id(get_fe_tailv(pre_fe),old_v) )

	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+eax*4]
	mov	eax, ecx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]
	mov	edi, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN26@change_ver
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	add	eax, DWORD PTR [edi+ebx+304]
	mov	edi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN25@change_ver
$LN26@change_ver:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	mov	edi, DWORD PTR [edi+ebx+304]
	mov	eax, DWORD PTR [eax+edi]
$LN25@change_ver:
	mov	edi, DWORD PTR _old_v$[ebp]
	cmp	eax, edi
	jne	SHORT $LN35@change_ver

; 1825 :           change_vertex(pre_fe,old_v,new_v,wrap);

	mov	edx, DWORD PTR _wrap$[ebp]
	mov	eax, DWORD PTR _new_v$[ebp]
	push	edx
	push	eax
	push	edi
	push	ecx
	call	_change_vertex
	mov	edx, DWORD PTR _web+460
	mov	ebx, DWORD PTR _dymem
	add	esp, 16					; 00000010H
$LN35@change_ver:

; 1826 :         next_fe = get_next_facet(next_fe);

	cmp	DWORD PTR tv348[ebp], 0
	je	SHORT $LN30@change_ver
	mov	ecx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [ecx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN3@change_ver
$LN30@change_ver:
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+40]
$LN3@change_ver:

; 1827 :      }
; 1828 :   while ( !equal_id(next_fe,fe) );

	cmp	eax, DWORD PTR _fe$[ebp]
	jne	$LL4@change_ver
	pop	edi
	pop	esi
	pop	ebx

; 1829 : } // end change_vertex()

	mov	esp, ebp
	pop	ebp
	ret	0
_change_vertex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EK@EPKFJPHH@Cannot?5refine?5an?5edge?5in?5Lagrang@ ; `string'
PUBLIC	_edge_refine
EXTRN	_valid_element:PROC
;	COMDAT ??_C@_0EK@EPKFJPHH@Cannot?5refine?5an?5edge?5in?5Lagrang@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EK@EPKFJPHH@Cannot?5refine?5an?5edge?5in?5Lagrang@ DB 'Cannot refi'
	DB	'ne an edge in Lagrange model. Suggest reverting to quadratic.'
	DB	0aH, 00H					; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\trirevis.c
CONST	ENDS
;	COMDAT _edge_refine
_TEXT	SEGMENT
_new_e$ = -20						; size = 4
_did_graphlock_here$90445 = -16				; size = 4
_f_id$90459 = -12					; size = 4
_first_fe$90449 = -8					; size = 4
tv415 = -4						; size = 4
_e_id$ = 8						; size = 4
_edge_refine PROC					; COMDAT

; 1895 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 1896 :   facetedge_id fe; /* for facet being subdvided */
; 1897 :   edge_id new_e;
; 1898 : 
; 1899 :   if ( !valid_element(e_id) )

	mov	esi, DWORD PTR _e_id$[ebp]
	push	esi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@edge_refin
	pop	esi

; 1931 : } // end edge_refine()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@edge_refin:

; 1900 :     return NULLID;
; 1901 :     
; 1902 :   if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	jne	SHORT $LN46@edge_refin

; 1903 :   kb_error(2199,"Cannot refine an edge in Lagrange model. Suggest reverting to quadratic.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EK@EPKFJPHH@Cannot?5refine?5an?5edge?5in?5Lagrang@
	push	2199					; 00000897H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN46@edge_refin:

; 1904 : 
; 1905 :   ENTER_GRAPH_MUTEX;

	push	edi
	mov	edi, DWORD PTR __imp__GetCurrentThreadId@0
	call	edi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN12@edge_refin
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	edi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$90445[ebp], 1
	jmp	SHORT $LN11@edge_refin
$LN12@edge_refin:
	mov	DWORD PTR _did_graphlock_here$90445[ebp], 0
$LN11@edge_refin:

; 1906 :   new_e = edge_divide(e_id);  /* e_id now tail half of old edge */

	push	esi
	call	_edge_divide
	add	esp, 4

; 1907 : 
; 1908 :   if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	mov	DWORD PTR _new_e$[ebp], eax
	jne	$LN6@edge_refin

; 1909 :   { facetedge_id first_fe;
; 1910 :     /* now go around facet loop of edge dividing facets */
; 1911 :     fe = first_fe = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	jne	SHORT $LN18@edge_refin
	xor	edi, edi
	mov	DWORD PTR _first_fe$90449[ebp], edi
	jmp	SHORT $LN19@edge_refin
$LN18@edge_refin:
	mov	eax, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN17@edge_refin
	xor	eax, 134217728				; 08000000H
$LN17@edge_refin:
	mov	DWORD PTR _first_fe$90449[ebp], eax
	mov	edi, eax
$LN19@edge_refin:

; 1912 :     if ( valid_id(fe) ) do

	test	edi, 268435456				; 10000000H
	je	$LN6@edge_refin
	push	ebx
	mov	ebx, DWORD PTR _web+460
	jmp	SHORT $LN8@edge_refin
$LL47@edge_refin:
	mov	esi, DWORD PTR _e_id$[ebp]
$LN8@edge_refin:

; 1913 :     { if ( get_vattr(get_edge_tailv(e_id)) & AXIAL_POINT )

	push	esi
	call	_get_edge_tailv
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	ecx, ecx
	add	esp, 4
	or	eax, ecx

; 1914 :       { facetedge_id ffe = get_next_edge(fe);

	mov	esi, edi
	je	$LN5@edge_refin
	mov	edx, edi
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	DWORD PTR tv415[ebp], edx
	je	SHORT $LN22@edge_refin
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+ebx]
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN21@edge_refin
$LN22@edge_refin:
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+ebx]
	mov	eax, DWORD PTR [ecx+32]
$LN21@edge_refin:

; 1915 :         facet_id f_id = get_fe_facet(fe);

	test	edi, 268435456				; 10000000H
	jne	SHORT $LN26@edge_refin
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN48@edge_refin
$LN26@edge_refin:
	mov	ecx, DWORD PTR [ecx+24]
	test	edx, edx
	je	SHORT $LN48@edge_refin
	xor	ecx, 134217728				; 08000000H
$LN48@edge_refin:

; 1916 :         cross_cut(ffe,get_next_edge(ffe));

	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	DWORD PTR _f_id$90459[ebp], ecx
	mov	ecx, DWORD PTR [ebx+edx*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN30@edge_refin
	mov	ecx, DWORD PTR [ecx+28]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN29@edge_refin
$LN30@edge_refin:
	mov	ecx, DWORD PTR [ecx+32]
$LN29@edge_refin:
	push	ecx
	push	eax
	call	_cross_cut

; 1917 :         if ( inverted(f_id) ) 

	mov	ecx, DWORD PTR _f_id$90459[ebp]
	add	esp, 8
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN4@edge_refin

; 1918 :           set_facet_fe(inverse_id(f_id),inverse_id(get_prev_edge(fe)));

	cmp	DWORD PTR tv415[ebp], 0
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [esi+edx]
	je	SHORT $LN34@edge_refin
	mov	eax, DWORD PTR [eax+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN33@edge_refin
$LN34@edge_refin:
	mov	eax, DWORD PTR [eax+28]
$LN33@edge_refin:
	xor	eax, 134217728				; 08000000H
	push	eax
	xor	ecx, 134217728				; 08000000H
	push	ecx
	call	_set_facet_fe

; 1919 :         else 

	jmp	SHORT $LN49@edge_refin
$LN4@edge_refin:

; 1920 :           set_facet_fe(f_id,fe);

	push	edi
	push	ecx
	call	_set_facet_fe

; 1921 :       }
; 1922 :       else

	jmp	SHORT $LN49@edge_refin
$LN5@edge_refin:

; 1923 :         cross_cut(get_prev_edge(fe),fe);

	mov	eax, edi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv415[ebp], eax
	je	SHORT $LN38@edge_refin
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+ebx]
	mov	eax, DWORD PTR [ecx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN37@edge_refin
$LN38@edge_refin:
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+ebx]
	mov	eax, DWORD PTR [edx+28]
$LN37@edge_refin:
	push	edi
	push	eax
	call	_cross_cut
$LN49@edge_refin:

; 1924 :       fe = get_next_facet(fe);

	mov	ebx, DWORD PTR _web+460
	add	esp, 8
	cmp	DWORD PTR tv415[ebp], 0
	je	SHORT $LN42@edge_refin
	mov	eax, DWORD PTR [esi+ebx]
	mov	edi, DWORD PTR [eax+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN7@edge_refin
$LN42@edge_refin:
	mov	ecx, DWORD PTR [esi+ebx]
	mov	edi, DWORD PTR [ecx+40]
$LN7@edge_refin:

; 1925 :     } while ( !equal_id(fe,first_fe) );

	cmp	edi, DWORD PTR _first_fe$90449[ebp]
	jne	$LL47@edge_refin
	pop	ebx
$LN6@edge_refin:

; 1926 :   }
; 1927 :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$90445[ebp], 0
	pop	edi
	je	SHORT $LN1@edge_refin
	mov	edx, DWORD PTR _graphmutex
	push	edx
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@edge_refin:

; 1928 : 
; 1929 :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 1930 :   return new_e;

	mov	eax, DWORD PTR _new_e$[ebp]
	pop	esi

; 1931 : } // end edge_refine()

	mov	esp, ebp
	pop	ebp
	ret	0
_edge_refine ENDP
_TEXT	ENDS
PUBLIC	_thread_calc_edges
EXTRN	_thread_stages:DWORD
EXTRN	_max_thread_stages:DWORD
EXTRN	_nprocs:DWORD
EXTRN	_win_get_thread_data:PROC
EXTRN	_thread_data_key:DWORD
; Function compile flags: /Ogtp
;	COMDAT _thread_calc_edges
_TEXT	SEGMENT
tv205 = -12						; size = 4
tv138 = -8						; size = 4
_maxstage$90591 = -4					; size = 4
_thread_calc_edges PROC					; COMDAT

; 2127 : { 

	push	ebp
	mov	ebp, esp

; 2128 :   THREAD_FOR_ALL_NEW(EDGE,
; 2129 :       { 
; 2130 :           calc_edge(*idptr);
; 2131 :       }
; 2132 :   )

	mov	eax, DWORD PTR _thread_data_key
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	push	eax
	call	_win_get_thread_data
	mov	ecx, DWORD PTR _nprocs
	mov	edi, eax
	mov	esi, DWORD PTR [edi]
	dec	ecx
	add	esp, 4
	cmp	esi, ecx
	jne	SHORT $LN11@thread_cal
	xor	eax, eax
	jmp	SHORT $LN12@thread_cal
$LN11@thread_cal:
	lea	eax, DWORD PTR [esi+1]
$LN12@thread_cal:
	test	esi, esi
	jne	SHORT $LN13@thread_cal
	mov	edx, DWORD PTR _max_thread_stages
	inc	edx
	mov	DWORD PTR _maxstage$90591[ebp], edx
	jmp	SHORT $LN14@thread_cal
$LN13@thread_cal:
	mov	ecx, DWORD PTR _max_thread_stages
	mov	DWORD PTR _maxstage$90591[ebp], ecx
$LN14@thread_cal:
	imul	esi, 548				; 00000224H
	add	esi, DWORD PTR _thread_stages
	mov	DWORD PTR [esi+540], 0
	mov	edx, DWORD PTR [esi+540]
	cmp	edx, DWORD PTR _maxstage$90591[ebp]
	jge	$LN6@thread_cal
	imul	eax, 548				; 00000224H
	add	eax, 540				; 0000021cH
	mov	DWORD PTR tv205[ebp], eax
	push	ebx
	npad	7
$LL5@thread_cal:
	mov	eax, DWORD PTR _thread_stages
	mov	ecx, DWORD PTR tv205[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [esi+540]
	cmp	edx, eax
	jl	SHORT $LL5@thread_cal
	mov	ecx, DWORD PTR [esi+540]
	rdtsc
	mov	DWORD PTR [edi+ecx*8+1808], eax
	mov	DWORD PTR [edi+ecx*8+1812], edx
	mov	ecx, DWORD PTR [esi+540]
	mov	edx, DWORD PTR [esi+540]
	mov	eax, DWORD PTR [esi+edx*4+216]
	mov	ebx, DWORD PTR [esi+ecx*4+36]
	test	eax, eax
	jle	SHORT $LN1@thread_cal
	mov	DWORD PTR tv138[ebp], eax
	npad	7
$LL3@thread_cal:
	mov	eax, DWORD PTR [ebx]
	push	eax
	call	_calc_edge
	add	esp, 4
	add	ebx, 4
	dec	DWORD PTR tv138[ebp]
	jne	SHORT $LL3@thread_cal
$LN1@thread_cal:
	mov	ecx, DWORD PTR [esi+540]
	rdtsc
	mov	DWORD PTR [edi+ecx*8+1880], eax
	mov	DWORD PTR [edi+ecx*8+1884], edx
	inc	DWORD PTR [esi+540]
	mov	ecx, DWORD PTR [esi+540]
	cmp	ecx, DWORD PTR _maxstage$90591[ebp]
	jl	$LL5@thread_cal
	pop	ebx
$LN6@thread_cal:
	pop	edi
	pop	esi

; 2133 : } // end thread_calc_edges()

	mov	esp, ebp
	pop	ebp
	ret	0
_thread_calc_edges ENDP
_TEXT	ENDS
PUBLIC	_eartest
; Function compile flags: /Ogtp
;	COMDAT _eartest
_TEXT	SEGMENT
_start_id$ = -12					; size = 4
tv361 = -8						; size = 4
tv369 = -4						; size = 4
_start_fe$90621 = 8					; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_v3$ = 16						; size = 4
_v4$ = 20						; size = 4
_eartest PROC						; COMDAT

; 2151 : { edge_id e_id,start_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2152 : 
; 2153 :   e_id = start_id = get_vertex_edge(v1);

	mov	eax, DWORD PTR _v1$[ebp]
	mov	ecx, DWORD PTR _web+12
	push	ebx
	mov	ebx, DWORD PTR _web+216
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	push	esi
	push	edi
	mov	edi, DWORD PTR _web+124
	mov	DWORD PTR _start_id$[ebp], eax
	npad	4
$LL10@eartest:

; 2154 :   do
; 2155 :   { if ( equal_id(v2,get_edge_headv(e_id)) )

	mov	esi, eax
	shr	esi, 27					; 0000001bH
	and	esi, 1
	mov	DWORD PTR tv361[ebp], esi
	je	SHORT $LN14@eartest
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [ebx+eax+304]
	mov	eax, DWORD PTR [edx+ecx]
	jmp	SHORT $LN43@eartest
$LN14@eartest:
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [ebx+edx+304]
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _web+636
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN43@eartest:
	mov	DWORD PTR tv369[ebp], ecx
	cmp	DWORD PTR _v2$[ebp], eax
	jne	$LN3@eartest

; 2156 :     { /* see if facets on edge have third vertex equal to v3 or v4 */
; 2157 :       facetedge_id fe,start_fe,next_fe;
; 2158 :       vertex_id other_v;
; 2159 :       fe = start_fe = get_edge_fe(e_id);

	test	ecx, ecx
	jne	SHORT $LN18@eartest
	xor	eax, eax
	jmp	SHORT $LN17@eartest
$LN18@eartest:
	mov	eax, DWORD PTR [ecx+28]
	test	esi, esi
	je	SHORT $LN17@eartest
	xor	eax, 134217728				; 08000000H
$LN17@eartest:
	mov	DWORD PTR _start_fe$90621[ebp], eax

; 2160 :       if ( valid_id(start_fe) )

	test	eax, 268435456				; 10000000H
	je	$LN3@eartest
$LL5@eartest:

; 2161 :       do
; 2162 :       {
; 2163 :         next_fe = get_next_edge(fe);

	mov	ecx, DWORD PTR _web+460
	mov	esi, eax
	shr	esi, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	and	esi, 1
	mov	ecx, DWORD PTR [ecx+eax*4]
	je	SHORT $LN22@eartest
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN21@eartest
$LN22@eartest:
	mov	eax, DWORD PTR [ecx+32]
$LN21@eartest:

; 2164 :         other_v = get_fe_headv(next_fe);

	mov	ebx, DWORD PTR _web+460
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]
	mov	edi, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN28@eartest
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [edx+eax]
	jmp	SHORT $LN27@eartest
$LN28@eartest:
	mov	ebx, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+edx]
$LN27@eartest:

; 2165 :         if ( equal_id(other_v,v3) || equal_id(other_v,v4) ) 

	cmp	eax, DWORD PTR _v3$[ebp]
	je	SHORT $LN39@eartest
	cmp	eax, DWORD PTR _v4$[ebp]
	je	SHORT $LN39@eartest

; 2167 :         fe = get_next_facet(fe); 

	test	esi, esi
	je	SHORT $LN32@eartest
	mov	eax, DWORD PTR [ecx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN4@eartest
$LN32@eartest:
	mov	eax, DWORD PTR [ecx+40]
$LN4@eartest:

; 2168 :       } while ( !equal_id(fe,start_fe) );

	cmp	eax, DWORD PTR _start_fe$90621[ebp]
	jne	$LL5@eartest
	mov	ebx, DWORD PTR _web+216
	mov	esi, DWORD PTR tv361[ebp]
	mov	ecx, DWORD PTR tv369[ebp]
$LN3@eartest:

; 2169 :     }
; 2170 :     e_id = get_next_tail_edge(e_id);

	mov	eax, DWORD PTR [ecx+esi*4+32]

; 2171 :   } while ( e_id != start_id );

	cmp	eax, DWORD PTR _start_id$[ebp]
	jne	$LL10@eartest

; 2172 :   return 0;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 2173 : } // end eartest()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@eartest:
	pop	edi
	pop	esi

; 2166 :           return 1; 

	mov	eax, 1
	pop	ebx

; 2173 : } // end eartest()

	mov	esp, ebp
	pop	ebp
	ret	0
_eartest ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@PFKHEFIP@Not?5swapping?5edge?5?$CFs?4?5Unequal?5ed@ ; `string'
PUBLIC	??_C@_0DK@NDONHJGE@Not?5swapping?5edge?5?$CFs?4?5Unequal?5fa@ ; `string'
PUBLIC	_do_edgeswap
PUBLIC	??_C@_0ED@KIMDKOGH@Not?5swapping?5edge?5?$CFs?4?5Would?5crea@ ; `string'
PUBLIC	??_C@_0DF@PCEPAFCO@Not?5swapping?5edge?5?$CFs?4?5Would?5be?5a@ ; `string'
PUBLIC	??_C@_0DG@COFGBKNC@Not?5swapping?5edge?5?$CFs?0?5facets?5hav@ ; `string'
PUBLIC	??_C@_0DC@GAFAOALL@Not?5swapping?5edge?5?$CFs?0?5facets?5hav@ ; `string'
PUBLIC	??_C@_0DA@LEKBHNOF@Not?5swapping?5edge?5?$CFs?4?5Unequal?5fa@ ; `string'
PUBLIC	__real@3ddb7cdfd9d7bdbb
PUBLIC	??_C@_0CN@KHELAKIK@Not?5swapping?5edge?5?$CFs?$DL?5more?5than?5@ ; `string'
PUBLIC	??_C@_0CD@LPFPFICA@Not?5swapping?5single?9facet?5edge?5?$CF@ ; `string'
PUBLIC	??_C@_0BL@MLNKKGMH@Not?5swapping?5bare?5edge?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@EOAEMLEC@Not?5swapping?5fixed?5edge?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	_edgeswap
EXTRN	_force_edgeswap_flag:DWORD
EXTRN	_F_BOUNDARY_ATTR:DWORD
EXTRN	_E_BOUNDARY_ATTR:DWORD
EXTRN	_equal_constr:PROC
EXTRN	_elnames:BYTE
EXTRN	_verbose_flag:DWORD
;	COMDAT ??_C@_0DL@PFKHEFIP@Not?5swapping?5edge?5?$CFs?4?5Unequal?5ed@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DL@PFKHEFIP@Not?5swapping?5edge?5?$CFs?4?5Unequal?5ed@ DB 'Not swa'
	DB	'pping edge %s. Unequal edge and facet constraints.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@NDONHJGE@Not?5swapping?5edge?5?$CFs?4?5Unequal?5fa@
CONST	SEGMENT
??_C@_0DK@NDONHJGE@Not?5swapping?5edge?5?$CFs?4?5Unequal?5fa@ DB 'Not swa'
	DB	'pping edge %s. Unequal facet and edge boundaries.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@KIMDKOGH@Not?5swapping?5edge?5?$CFs?4?5Would?5crea@
CONST	SEGMENT
??_C@_0ED@KIMDKOGH@Not?5swapping?5edge?5?$CFs?4?5Would?5crea@ DB 'Not swa'
	DB	'pping edge %s. Would create two facets with same vertices.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PCEPAFCO@Not?5swapping?5edge?5?$CFs?4?5Would?5be?5a@
CONST	SEGMENT
??_C@_0DF@PCEPAFCO@Not?5swapping?5edge?5?$CFs?4?5Would?5be?5a@ DB 'Not sw'
	DB	'apping edge %s. Would be a loop on vertex %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@COFGBKNC@Not?5swapping?5edge?5?$CFs?0?5facets?5hav@
CONST	SEGMENT
??_C@_0DG@COFGBKNC@Not?5swapping?5edge?5?$CFs?0?5facets?5hav@ DB 'Not swa'
	DB	'pping edge %s, facets have unequal NO_REFINE.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@GAFAOALL@Not?5swapping?5edge?5?$CFs?0?5facets?5hav@
CONST	SEGMENT
??_C@_0DC@GAFAOALL@Not?5swapping?5edge?5?$CFs?0?5facets?5hav@ DB 'Not swa'
	DB	'pping edge %s, facets have unequal FIXED.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@LEKBHNOF@Not?5swapping?5edge?5?$CFs?4?5Unequal?5fa@
CONST	SEGMENT
??_C@_0DA@LEKBHNOF@Not?5swapping?5edge?5?$CFs?4?5Unequal?5fa@ DB 'Not swa'
	DB	'pping edge %s. Unequal facet densities.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@3ddb7cdfd9d7bdbb
CONST	SEGMENT
__real@3ddb7cdfd9d7bdbb DQ 03ddb7cdfd9d7bdbbr	; 1e-010
CONST	ENDS
;	COMDAT ??_C@_0CN@KHELAKIK@Not?5swapping?5edge?5?$CFs?$DL?5more?5than?5@
CONST	SEGMENT
??_C@_0CN@KHELAKIK@Not?5swapping?5edge?5?$CFs?$DL?5more?5than?5@ DB 'Not '
	DB	'swapping edge %s; more than two facets.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LPFPFICA@Not?5swapping?5single?9facet?5edge?5?$CF@
CONST	SEGMENT
??_C@_0CD@LPFPFICA@Not?5swapping?5single?9facet?5edge?5?$CF@ DB 'Not swap'
	DB	'ping single-facet edge %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MLNKKGMH@Not?5swapping?5bare?5edge?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BL@MLNKKGMH@Not?5swapping?5bare?5edge?5?$CFs?6?$AA@ DB 'Not swappi'
	DB	'ng bare edge %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EOAEMLEC@Not?5swapping?5fixed?5edge?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BM@EOAEMLEC@Not?5swapping?5fixed?5edge?5?$CFs?6?$AA@ DB 'Not swapp'
	DB	'ing fixed edge %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\trirevis.c
CONST	ENDS
;	COMDAT _edgeswap
_TEXT	SEGMENT
tv796 = -24						; size = 8
tv786 = -24						; size = 8
_f1$ = -16						; size = 4
_fe_a$ = -12						; size = 4
tv320 = -8						; size = 4
_f2$ = -8						; size = 4
tv736 = -4						; size = 4
_e_id$ = 8						; size = 4
_edgeswap PROC						; COMDAT

; 2190 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2191 :   facetedge_id fe_a; /* for edge under test */
; 2192 :   facetedge_id fe_ai; /* other facetedge of e_id */
; 2193 :   facetedge_id fe_c; /* other side of one triangle */
; 2194 :   facetedge_id fe_d; /* other side of other triangle */
; 2195 :   facet_id f1,f2;
; 2196 : 
; 2197 :   web.vol_flag = 0;
; 2198 :   if ( get_eattr(e_id) & FIXED ) 

	mov	edx, DWORD PTR _e_id$[ebp]
	mov	eax, DWORD PTR _web+124
	push	ebx
	mov	ebx, edx
	and	ebx, 134217727				; 07ffffffH
	mov	DWORD PTR _web+896, 0
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [ecx+8]
	push	esi
	and	eax, 64					; 00000040H
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv736[ebp], ebx
	je	SHORT $LN27@edgeswap

; 2199 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, esi
	je	SHORT $LN26@edgeswap

; 2200 :     { sprintf(msg,"Not swapping fixed edge %s\n",ELNAME(e_id));

	test	edx, 268435456				; 10000000H
	je	SHORT $LN30@edgeswap
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN31@edgeswap
$LN30@edgeswap:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN31@edgeswap:
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BM@EOAEMLEC@Not?5swapping?5fixed?5edge?5?$CFs?6?$AA@
	push	ecx
	call	_sprintf

; 2201 :       outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN26@edgeswap:

; 2202 :     }
; 2203 :     return 0;

	pop	esi
	xor	eax, eax
	pop	ebx

; 2308 : 
; 2309 : } // end edgeswap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@edgeswap:

; 2204 :   }
; 2205 :       
; 2206 :   /* test to be sure edge has exactly two adjacent facets */
; 2207 :   fe_a = get_edge_fe(e_id);

	test	ecx, ecx
	jne	SHORT $LN63@edgeswap
	xor	esi, esi
	mov	DWORD PTR _fe_a$[ebp], esi
	jmp	SHORT $LN64@edgeswap
$LN63@edgeswap:
	mov	ecx, DWORD PTR [ecx+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN62@edgeswap
	xor	ecx, 134217728				; 08000000H
$LN62@edgeswap:
	mov	esi, ecx
	mov	DWORD PTR _fe_a$[ebp], ecx
$LN64@edgeswap:

; 2208 :   if ( !valid_id(fe_a) ) /* might be bare edge */

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN25@edgeswap

; 2209 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN26@edgeswap

; 2210 :     { sprintf(msg,"Not swapping bare edge %s\n",ELNAME(e_id));

	test	edx, 268435456				; 10000000H
	je	SHORT $LN32@edgeswap
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN33@edgeswap
$LN32@edgeswap:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN33@edgeswap:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BL@MLNKKGMH@Not?5swapping?5bare?5edge?5?$CFs?6?$AA@
	push	eax
	call	_sprintf

; 2211 :        outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
	pop	esi

; 2212 :     }
; 2213 :     return 0;

	xor	eax, eax
	pop	ebx

; 2308 : 
; 2309 : } // end edgeswap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@edgeswap:
	push	edi

; 2214 :   }
; 2215 :   fe_ai = get_next_facet(fe_a);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN67@edgeswap
	mov	ecx, DWORD PTR _web+460
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edi, DWORD PTR [eax+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN66@edgeswap
$LN67@edgeswap:
	mov	eax, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	edi, DWORD PTR [ecx+40]
$LN66@edgeswap:

; 2216 :   if ( equal_id(fe_a,fe_ai) ) 

	cmp	esi, edi
	jne	SHORT $LN23@edgeswap

; 2217 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN9@edgeswap

; 2218 :     { sprintf(msg,"Not swapping single-facet edge %s\n",ELNAME(e_id));

	test	edx, 268435456				; 10000000H
	je	SHORT $LN34@edgeswap
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	push	eax
	push	OFFSET ??_C@_0CD@LPFPFICA@Not?5swapping?5single?9facet?5edge?5?$CF@

; 2219 :        outstring(msg);
; 2220 :     }
; 2221 :     return 0;

	jmp	$LN74@edgeswap
$LN34@edgeswap:

; 2218 :     { sprintf(msg,"Not swapping single-facet edge %s\n",ELNAME(e_id));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0CD@LPFPFICA@Not?5swapping?5single?9facet?5edge?5?$CF@

; 2219 :        outstring(msg);
; 2220 :     }
; 2221 :     return 0;

	jmp	$LN74@edgeswap
$LN23@edgeswap:

; 2222 :   }
; 2223 : 
; 2224 :   if ( !equal_id(fe_ai,get_prev_facet(fe_a)) )

	push	esi
	call	_get_prev_facet
	add	esp, 4
	cmp	edi, eax
	je	SHORT $LN21@edgeswap

; 2225 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN9@edgeswap

; 2226 :     { sprintf(msg,"Not swapping edge %s; more than two facets.\n",ELNAME(e_id));

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN36@edgeswap
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN37@edgeswap
$LN36@edgeswap:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN37@edgeswap:
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0CN@KHELAKIK@Not?5swapping?5edge?5?$CFs?$DL?5more?5than?5@
	push	ecx
	call	_sprintf

; 2227 :        outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx

; 2267 :       { sprintf(msg,"Not swapping edge %s. Unequal edge and facet constraints.\n",
; 2268 :                 ELNAME(e_id)); outstring(msg);

	call	_outstring
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 2269 :       }
; 2270 :        return 0;

	xor	eax, eax
	pop	ebx

; 2308 : 
; 2309 : } // end edgeswap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@edgeswap:

; 2228 :     }
; 2229 :     return 0;
; 2230 :   }
; 2231 : 
; 2232 :   f1 = get_fe_facet(fe_a);

	push	esi
	call	_get_fe_facet
	mov	edi, eax

; 2233 :   f2 = get_fe_facet(get_next_facet(fe_a));

	push	esi
	mov	DWORD PTR _f1$[ebp], edi
	call	_get_next_facet
	push	eax
	call	_get_fe_facet

; 2234 : 
; 2235 :   /* test for equal density */
; 2236 :   if ( (get_fattr(f1)&DENSITY) || (get_fattr(f2)&DENSITY) )

	mov	ecx, DWORD PTR _web+236
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+ecx]
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR _f2$[ebp], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv786[ebp+4], eax
	mov	eax, ebx
	and	eax, 16					; 00000010H
	xor	esi, esi
	add	esp, 12					; 0000000cH
	or	eax, esi
	mov	DWORD PTR tv786[ebp], ebx
	jne	SHORT $LN18@edgeswap
	mov	esi, DWORD PTR _f2$[ebp]
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [ecx+8]
	xor	ebx, ebx
	and	eax, 16					; 00000010H
	or	eax, ebx
	mov	ebx, DWORD PTR tv786[ebp]
	je	SHORT $LN17@edgeswap
	mov	ecx, DWORD PTR _web+236
$LN18@edgeswap:

; 2237 :     if ( fabs(get_facet_density(f1) - get_facet_density(f2)) > 1e-10 )

	mov	esi, DWORD PTR _f2$[ebp]
	fld	QWORD PTR [edx+32]
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+ecx]
	fsub	QWORD PTR [ecx+32]
	fabs
	fcomp	QWORD PTR __real@3ddb7cdfd9d7bdbb
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN17@edgeswap

; 2238 :     { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN9@edgeswap

; 2239 :       { sprintf(msg,"Not swapping edge %s. Unequal facet densities.\n",
; 2240 :                 ELNAME(e_id)); outstring(msg);

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN38@edgeswap
	mov	ecx, DWORD PTR tv736[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	push	eax
	push	OFFSET ??_C@_0DA@LEKBHNOF@Not?5swapping?5edge?5?$CFs?4?5Unequal?5fa@

; 2241 :        }
; 2242 :        return 0;

	jmp	$LN74@edgeswap
$LN38@edgeswap:

; 2239 :       { sprintf(msg,"Not swapping edge %s. Unequal facet densities.\n",
; 2240 :                 ELNAME(e_id)); outstring(msg);

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0DA@LEKBHNOF@Not?5swapping?5edge?5?$CFs?4?5Unequal?5fa@

; 2241 :        }
; 2242 :        return 0;

	jmp	$LN74@edgeswap
$LN17@edgeswap:

; 2243 :     }
; 2244 : 
; 2245 :   /* test for equal no_refine and fixedness */
; 2246 :   if ( (get_fattr(f1)&(FIXED)) != (get_fattr(f2)&(FIXED)) )

	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, edx
	xor	eax, ebx
	mov	DWORD PTR tv796[ebp+4], ecx
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN15@edgeswap

; 2247 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, ecx
	je	$LN9@edgeswap

; 2248 :     { sprintf(msg,"Not swapping edge %s, facets have unequal FIXED.\n",
; 2249 :          ELNAME(e_id));

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN40@edgeswap
	mov	edx, DWORD PTR tv736[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN41@edgeswap
$LN40@edgeswap:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN41@edgeswap:
	push	eax
	push	OFFSET ??_C@_0DC@GAFAOALL@Not?5swapping?5edge?5?$CFs?0?5facets?5hav@
$LN77@edgeswap:
	mov	eax, DWORD PTR _msg
	push	eax
	call	_sprintf

; 2250 :        outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx

; 2267 :       { sprintf(msg,"Not swapping edge %s. Unequal edge and facet constraints.\n",
; 2268 :                 ELNAME(e_id)); outstring(msg);

	call	_outstring
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 2269 :       }
; 2270 :        return 0;

	xor	eax, eax
	pop	ebx

; 2308 : 
; 2309 : } // end edgeswap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@edgeswap:

; 2251 :     }
; 2252 :     return 0;
; 2253 :   }
; 2254 :   if ( (get_fattr(f1)&(NO_REFINE)) != 
; 2255 :                 (get_fattr(f2)&(NO_REFINE)) )

	xor	edx, ebx
	and	edx, 16777216				; 01000000H
	xor	eax, eax
	or	edx, eax
	je	SHORT $LN13@edgeswap

; 2256 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, eax
	je	$LN9@edgeswap

; 2257 :     { sprintf(msg,"Not swapping edge %s, facets have unequal NO_REFINE.\n",
; 2258 :          ELNAME(e_id));

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN42@edgeswap
	mov	edx, DWORD PTR tv736[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	push	eax
	push	OFFSET ??_C@_0DG@COFGBKNC@Not?5swapping?5edge?5?$CFs?0?5facets?5hav@

; 2259 :        outstring(msg);
; 2260 :     }
; 2261 :     return 0;

	jmp	SHORT $LN77@edgeswap
$LN42@edgeswap:

; 2257 :     { sprintf(msg,"Not swapping edge %s, facets have unequal NO_REFINE.\n",
; 2258 :          ELNAME(e_id));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0DG@COFGBKNC@Not?5swapping?5edge?5?$CFs?0?5facets?5hav@

; 2259 :        outstring(msg);
; 2260 :     }
; 2261 :     return 0;

	jmp	SHORT $LN77@edgeswap
$LN13@edgeswap:

; 2262 :   }
; 2263 : 
; 2264 :   /* test for equal constraints */
; 2265 :   if ( !equal_constr(e_id,f1) || !equal_constr(e_id,f2) )

	mov	edx, DWORD PTR _f1$[ebp]
	mov	ebx, DWORD PTR _e_id$[ebp]
	push	edx
	push	ebx
	call	_equal_constr
	add	esp, 8
	test	eax, eax
	je	$LN10@edgeswap
	mov	eax, DWORD PTR _f2$[ebp]
	push	eax
	push	ebx
	call	_equal_constr
	add	esp, 8
	test	eax, eax
	je	$LN10@edgeswap

; 2271 :     }
; 2272 :  
; 2273 :   /* test for equal boundary */
; 2274 :   if ( ( get_edge_boundary(e_id) != get_facet_boundary(f1))
; 2275 :             ||( get_edge_boundary(e_id) != get_facet_boundary(f2)) )

	mov	ecx, DWORD PTR _E_BOUNDARY_ATTR
	test	ecx, ecx
	je	SHORT $LN46@edgeswap
	mov	eax, DWORD PTR _dymem
	mov	ebx, DWORD PTR tv736[ebp]
	mov	edx, ecx
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	ebx, DWORD PTR [edx+eax]
	imul	ebx, 136				; 00000088H
	add	ebx, DWORD PTR _web+776
	jmp	SHORT $LN76@edgeswap
$LN46@edgeswap:
	xor	ebx, ebx
$LN76@edgeswap:
	mov	edx, DWORD PTR _F_BOUNDARY_ATTR
	mov	DWORD PTR tv320[ebp], ebx
	test	edx, edx
	je	SHORT $LN48@edgeswap
	mov	ebx, DWORD PTR _dymem
	mov	eax, edx
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	ebx, DWORD PTR _web+236
	mov	edi, DWORD PTR [edi+ebx]
	mov	eax, DWORD PTR [eax+edi]
	mov	ebx, DWORD PTR tv320[ebp]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN49@edgeswap
$LN48@edgeswap:
	xor	eax, eax
$LN49@edgeswap:
	cmp	ebx, eax
	jne	$LN72@edgeswap
	test	ecx, ecx
	je	SHORT $LN50@edgeswap
	mov	eax, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+216
	mov	edi, DWORD PTR tv736[ebp]
	mov	ecx, DWORD PTR [ecx+eax+64]
	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+edi*4]
	mov	ecx, DWORD PTR [ecx+eax]
	imul	ecx, 136				; 00000088H
	add	ecx, DWORD PTR _web+776
	jmp	SHORT $LN51@edgeswap
$LN50@edgeswap:
	xor	ecx, ecx
$LN51@edgeswap:
	test	edx, edx
	je	SHORT $LN52@edgeswap
	mov	eax, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+328
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR _web+236
	mov	eax, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [edx+eax]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN53@edgeswap
$LN52@edgeswap:
	xor	eax, eax
$LN53@edgeswap:
	cmp	ecx, eax
	jne	$LN72@edgeswap

; 2281 :     }
; 2282 : 
; 2283 :   fe_c = get_prev_edge(fe_a);

	mov	edi, DWORD PTR _fe_a$[ebp]
	push	edi
	call	_get_prev_edge

; 2284 :   fe_ai = fe_inverse(get_next_facet(fe_a));

	push	edi
	mov	esi, eax
	call	_get_next_facet
	xor	eax, 134217728				; 08000000H

; 2285 :   fe_d = get_next_edge(fe_ai); 

	push	eax
	call	_get_next_edge
	add	esp, 12					; 0000000cH

; 2286 : 
; 2287 :   /* may want to switch, but test that opposite vertices are different */
; 2288 :   if ( !force_edgeswap_flag )

	cmp	DWORD PTR _force_edgeswap_flag, 0
	mov	edi, eax
	jne	$LN71@edgeswap

; 2289 :   {
; 2290 :     if ( equal_id(get_fe_tailv(fe_c),get_fe_headv(fe_d)) ) 

	push	edi
	call	_get_fe_edge
	push	eax
	call	_get_edge_headv
	push	esi
	mov	ebx, eax
	call	_get_fe_edge
	push	eax
	call	_get_edge_tailv
	add	esp, 16					; 00000010H
	cmp	eax, ebx
	jne	$LN4@edgeswap

; 2291 :     { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN9@edgeswap

; 2292 :       { sprintf(msg,"Not swapping edge %s. Would be a loop on vertex %s.\n",
; 2293 :                 ELNAME(e_id),ELNAME1(get_fe_tailv(fe_c))); outstring(msg);

	push	esi
	call	_get_fe_edge
	push	eax
	call	_get_edge_tailv
	add	esp, 8
	test	eax, 268435456				; 10000000H
	je	SHORT $LN56@edgeswap
	push	esi
	call	_get_fe_edge
	push	eax
	call	_get_edge_tailv
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 20					; 00000014H
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN57@edgeswap
$LN56@edgeswap:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN57@edgeswap:
	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN58@edgeswap
	mov	ecx, DWORD PTR tv736[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN59@edgeswap
$LN58@edgeswap:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN59@edgeswap:
	mov	edx, DWORD PTR _msg
	push	esi
	push	eax
	push	OFFSET ??_C@_0DF@PCEPAFCO@Not?5swapping?5edge?5?$CFs?4?5Would?5be?5a@
	push	edx
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 2308 : 
; 2309 : } // end edgeswap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@edgeswap:

; 2294 :       }
; 2295 :       return 0;
; 2296 :     }
; 2297 :     if ( eartest(get_fe_tailv(fe_c),get_fe_headv(fe_d),get_edge_tailv(e_id),
; 2298 :                      get_edge_headv(e_id)) )

	mov	ebx, DWORD PTR _e_id$[ebp]
	push	ebx
	call	_get_edge_headv
	add	esp, 4
	push	eax
	push	ebx
	call	_get_edge_tailv
	add	esp, 4
	push	eax
	push	edi
	call	_get_fe_edge
	push	eax
	call	_get_edge_headv
	add	esp, 8
	push	eax
	push	esi
	call	_get_fe_edge
	push	eax
	call	_get_edge_tailv
	add	esp, 8
	push	eax
	call	_eartest
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN2@edgeswap

; 2299 :     { if (verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN9@edgeswap

; 2300 :       { sprintf(msg,"Not swapping edge %s. Would create two facets with same vertices.\n",
; 2301 :                 ELNAME(e_id)); outstring(msg);

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN60@edgeswap
	mov	ecx, DWORD PTR tv736[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	push	eax
	push	OFFSET ??_C@_0ED@KIMDKOGH@Not?5swapping?5edge?5?$CFs?4?5Would?5crea@

; 2302 :       }
; 2303 :       return 0;

	jmp	$LN74@edgeswap
$LN60@edgeswap:

; 2300 :       { sprintf(msg,"Not swapping edge %s. Would create two facets with same vertices.\n",
; 2301 :                 ELNAME(e_id)); outstring(msg);

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0ED@KIMDKOGH@Not?5swapping?5edge?5?$CFs?4?5Would?5crea@

; 2302 :       }
; 2303 :       return 0;

	jmp	$LN74@edgeswap
$LN71@edgeswap:

; 2300 :       { sprintf(msg,"Not swapping edge %s. Would create two facets with same vertices.\n",
; 2301 :                 ELNAME(e_id)); outstring(msg);

	mov	ebx, DWORD PTR _e_id$[ebp]
$LN2@edgeswap:

; 2304 :     }
; 2305 :   }
; 2306 : 
; 2307 :   return do_edgeswap(e_id);

	push	ebx
	call	_do_edgeswap
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2308 : 
; 2309 : } // end edgeswap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@edgeswap:

; 2276 :     { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN9@edgeswap

; 2277 :       { sprintf(msg,"Not swapping edge %s. Unequal facet and edge boundaries.\n",
; 2278 :                 ELNAME(e_id)); outstring(msg);

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN54@edgeswap
	mov	ecx, DWORD PTR tv736[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	push	eax
	push	OFFSET ??_C@_0DK@NDONHJGE@Not?5swapping?5edge?5?$CFs?4?5Unequal?5fa@

; 2279 :       }
; 2280 :        return 0;

	jmp	SHORT $LN74@edgeswap
$LN54@edgeswap:

; 2277 :       { sprintf(msg,"Not swapping edge %s. Unequal facet and edge boundaries.\n",
; 2278 :                 ELNAME(e_id)); outstring(msg);

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0DK@NDONHJGE@Not?5swapping?5edge?5?$CFs?4?5Unequal?5fa@

; 2279 :       }
; 2280 :        return 0;

	jmp	SHORT $LN74@edgeswap
$LN10@edgeswap:

; 2266 :     { if ( verbose_flag) 

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN9@edgeswap

; 2267 :       { sprintf(msg,"Not swapping edge %s. Unequal edge and facet constraints.\n",
; 2268 :                 ELNAME(e_id)); outstring(msg);

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN44@edgeswap
	mov	ecx, DWORD PTR tv736[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN45@edgeswap
$LN44@edgeswap:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN45@edgeswap:
	push	eax
	push	OFFSET ??_C@_0DL@PFKHEFIP@Not?5swapping?5edge?5?$CFs?4?5Unequal?5ed@
$LN74@edgeswap:
	mov	edx, DWORD PTR _msg
	push	edx
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
$LN9@edgeswap:

; 2269 :       }
; 2270 :        return 0;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 2308 : 
; 2309 : } // end edgeswap()

	mov	esp, ebp
	pop	ebp
	ret	0
_edgeswap ENDP
_TEXT	ENDS
PUBLIC	_test_axial_points
; Function compile flags: /Ogtp
;	COMDAT _test_axial_points
_TEXT	SEGMENT
_i$ = -4						; size = 4
_f_id$ = 8						; size = 4
_test_axial_points PROC					; COMDAT

; 2319 : { facetedge_id fe;

	push	ebp
	mov	ebp, esp
	push	ecx

; 2320 :   int i;
; 2321 : 
; 2322 :   if ( inverted(f_id) ) f_id = inverse_id(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN5@test_axial
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _f_id$[ebp], eax
$LN5@test_axial:

; 2323 :   fe = get_facet_fe(f_id);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN9@test_axial
	xor	edx, edx
	jmp	SHORT $LN8@test_axial
$LN9@test_axial:
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN8@test_axial
	xor	edx, 134217728				; 08000000H
$LN8@test_axial:

; 2324 :   for ( i = 0 ; i < FACET_EDGES ; i++ )

	push	ebx
	mov	ebx, DWORD PTR _web+124
	push	esi
	push	edi
	mov	edi, DWORD PTR _web+216
	mov	DWORD PTR _i$[ebp], 0
	npad	8
$LL25@test_axial:

; 2325 :   { vertex_id v_id;
; 2326 :     v_id = get_fe_tailv(fe);

	mov	ecx, DWORD PTR _web+460
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [esi+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN15@test_axial
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	add	eax, DWORD PTR [edi+ecx+304]
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN14@test_axial
$LN15@test_axial:
	mov	ecx, DWORD PTR [edi+ecx+304]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN14@test_axial:

; 2327 :     if ( get_vattr(v_id) & AXIAL_POINT )

	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN23@test_axial

; 2329 :     fe = get_next_edge(fe);

	test	edx, 134217728				; 08000000H
	je	SHORT $LN19@test_axial
	mov	edx, DWORD PTR [esi+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN3@test_axial
$LN19@test_axial:
	mov	edx, DWORD PTR [esi+32]
$LN3@test_axial:

; 2324 :   for ( i = 0 ; i < FACET_EDGES ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, 3
	jl	$LL25@test_axial
	pop	edi
	pop	esi
	pop	ebx

; 2330 :   }
; 2331 : } // end test_axial_points()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@test_axial:

; 2328 :     { set_facet_fe(f_id,fe); return; }

	push	edx
	mov	edx, DWORD PTR _f_id$[ebp]
	push	edx
	call	_set_facet_fe
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 2330 :   }
; 2331 : } // end test_axial_points()

	mov	esp, ebp
	pop	ebp
	ret	0
_test_axial_points ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@JMPCBAH@Swapping?5edge?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0EG@KACMNLNF@Not?5swapping?5edge?5?$CFs?4?5Would?5crea@ ; `string'
EXTRN	_new_vertex_average:PROC
EXTRN	_torus_wrap:PROC
EXTRN	_set_fe_facet:PROC
;	COMDAT ??_C@_0BC@JMPCBAH@Swapping?5edge?5?$CFs?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BC@JMPCBAH@Swapping?5edge?5?$CFs?6?$AA@ DB 'Swapping edge %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@KACMNLNF@Not?5swapping?5edge?5?$CFs?4?5Would?5crea@
CONST	SEGMENT
??_C@_0EG@KACMNLNF@Not?5swapping?5edge?5?$CFs?4?5Would?5crea@ DB 'Not swa'
	DB	'pping edge %s. Would create edge with both ends axial points.'
	DB	0aH, 00H					; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\trirevis.c
CONST	ENDS
;	COMDAT _do_edgeswap
_TEXT	SEGMENT
tv1380 = -56						; size = 4
tv1341 = -52						; size = 4
tv1411 = -48						; size = 4
tv1284 = -48						; size = 4
tv1404 = -44						; size = 4
tv1280 = -40						; size = 4
tv1334 = -36						; size = 4
tv1318 = -32						; size = 4
tv1294 = -28						; size = 4
tv1297 = -24						; size = 4
_fe_ai$ = -20						; size = 4
_fe_a$ = -16						; size = 4
_fe_c$ = -12						; size = 4
_fe_e$ = -8						; size = 4
_fe_b$ = -4						; size = 4
_e_id$ = 8						; size = 4
_do_edgeswap PROC					; COMDAT

; 2343 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 2344 :   vertex_id v_id;
; 2345 :   facetedge_id fe_a; /* for edge under test */
; 2346 :   facetedge_id fe_ai; /* other facetedge of e_id */
; 2347 :   facetedge_id fe_b,fe_c; /* other sides of one triangle */
; 2348 :   facetedge_id fe_d,fe_e; /* other sides of other triangle */
; 2349 : 
; 2350 : 
; 2351 :   fe_a = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv1280[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv1284[ebp], eax
	test	eax, eax
	je	SHORT $LN17@do_edgeswa
$LN18@do_edgeswa:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN17@do_edgeswa
	xor	eax, 134217728				; 08000000H
$LN17@do_edgeswa:

; 2352 :   fe_b = get_next_edge(fe_a);

	mov	ecx, DWORD PTR _web+460
	push	ebx
	push	esi
	mov	esi, eax
	shr	esi, 27					; 0000001bH
	and	esi, 1
	mov	DWORD PTR _fe_a$[ebp], eax
	push	edi
	mov	DWORD PTR tv1294[ebp], esi
	je	SHORT $LN22@do_edgeswa
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1297[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [eax+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN141@do_edgeswa
$LN22@do_edgeswa:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1297[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [eax+32]
$LN141@do_edgeswa:
	mov	DWORD PTR _fe_b$[ebp], edx

; 2353 :   fe_c = get_prev_edge(fe_a);

	test	esi, esi
	je	SHORT $LN26@do_edgeswa
	mov	ebx, DWORD PTR [eax+32]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN142@do_edgeswa
$LN26@do_edgeswa:
	mov	ebx, DWORD PTR [eax+28]
$LN142@do_edgeswa:
	mov	DWORD PTR _fe_c$[ebp], ebx

; 2354 :   fe_ai = fe_inverse(get_next_facet(fe_a));

	test	esi, esi
	je	SHORT $LN30@do_edgeswa
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN29@do_edgeswa
$LN30@do_edgeswa:
	mov	eax, DWORD PTR [eax+40]
$LN29@do_edgeswa:
	xor	eax, 134217728				; 08000000H
	mov	edi, eax

; 2355 :   fe_d = get_next_edge(fe_ai); 

	mov	edx, edi
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	DWORD PTR _fe_ai$[ebp], edi
	mov	DWORD PTR tv1318[ebp], edx
	je	SHORT $LN34@do_edgeswa
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ecx]
	mov	esi, DWORD PTR [eax+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN33@do_edgeswa
$LN34@do_edgeswa:
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ecx]
	mov	esi, DWORD PTR [eax+32]
$LN33@do_edgeswa:

; 2356 :   fe_e = get_prev_edge(fe_ai); 

	test	edx, edx
	je	SHORT $LN38@do_edgeswa
	mov	eax, DWORD PTR [eax+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN143@do_edgeswa
$LN38@do_edgeswa:
	mov	eax, DWORD PTR [eax+28]
$LN143@do_edgeswa:
	mov	DWORD PTR _fe_e$[ebp], eax

; 2357 : 
; 2358 :   /* special check so axial point does not become head of swapped edge */
; 2359 :   if ( get_vattr(get_fe_tailv(fe_c)) & AXIAL_POINT )

	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1334[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+20]
	mov	edx, ebx
	mov	ebx, DWORD PTR _dymem
	and	edx, 134217728				; 08000000H
	xor	eax, edx
	mov	DWORD PTR tv1341[ebp], edx
	mov	edx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN44@do_edgeswa
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	add	eax, DWORD PTR [edx+ebx+304]
	mov	edx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN43@do_edgeswa
$LN44@do_edgeswa:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ebx+304]
	mov	eax, DWORD PTR [eax+edx]
$LN43@do_edgeswa:
	mov	ebx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	edx, edx
	or	eax, edx
	je	$LN10@do_edgeswa

; 2360 :   { int retval;
; 2361 :     if ( get_vattr(get_fe_headv(fe_d)) & AXIAL_POINT )

	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [ecx+20]
	push	esi
	call	_get_edge_headv
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	ecx, ecx
	add	esp, 4
	or	eax, ecx
	je	SHORT $LN9@do_edgeswa

; 2362 :     { if ( verbose_flag ) 

	cmp	DWORD PTR _verbose_flag, ecx
	je	SHORT $LN8@do_edgeswa

; 2363 :       { sprintf(msg,"Not swapping edge %s. Would create edge with both ends axial points.\n",
; 2364 :                 ELNAME(e_id)); outstring(msg);

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN13@do_edgeswa
	mov	edx, DWORD PTR tv1280[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN14@do_edgeswa
$LN13@do_edgeswa:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN14@do_edgeswa:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0EG@KACMNLNF@Not?5swapping?5edge?5?$CFs?4?5Would?5crea@
	push	eax
	call	_sprintf
	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
$LN8@do_edgeswa:

; 2365 :       }
; 2366 :       return 0;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 2450 : } /* end do_edgeswap */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@do_edgeswa:

; 2367 :     }
; 2368 :     set_edge_fe(e_id,inverse_id(fe_ai)); 

	mov	eax, DWORD PTR _fe_ai$[ebp]
	mov	ecx, DWORD PTR _e_id$[ebp]
	xor	eax, 134217728				; 08000000H
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN49@do_edgeswa
	xor	eax, 134217728				; 08000000H
$LN49@do_edgeswa:
	mov	edx, DWORD PTR tv1284[ebp]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _global_timestamp
	inc	eax

; 2369 :     retval = edgeswap(e_id); 

	push	ecx
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	call	_edgeswap
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2450 : } /* end do_edgeswap */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@do_edgeswa:

; 2370 :     return retval;
; 2371 :   }
; 2372 : 
; 2373 :   /* if we are here, we want to switch diagonals */
; 2374 :   if ( verbose_flag )
; 2375 :   { sprintf(msg,"Swapping edge %s\n",ELNAME(e_id)); outstring(msg); 

	mov	ebx, DWORD PTR _e_id$[ebp]
	cmp	DWORD PTR _verbose_flag, edx
	je	SHORT $LN7@do_edgeswa
	test	ebx, 268435456				; 10000000H
	je	SHORT $LN15@do_edgeswa
	mov	eax, DWORD PTR tv1280[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN16@do_edgeswa
$LN15@do_edgeswa:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN16@do_edgeswa:
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BC@JMPCBAH@Swapping?5edge?5?$CFs?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN7@do_edgeswa:

; 2376 :   }
; 2377 :   remove_vertex_edge(get_edge_tailv(e_id),e_id);

	push	ebx
	push	ebx
	call	_get_edge_tailv
	add	esp, 4
	push	eax
	call	_remove_vertex_edge

; 2378 :   remove_vertex_edge(get_edge_headv(e_id),inverse_id(e_id));

	mov	eax, ebx
	add	esp, 8
	xor	eax, 134217728				; 08000000H
	push	eax
	push	ebx
	call	_get_edge_headv
	add	esp, 4
	push	eax
	call	_remove_vertex_edge

; 2379 :   set_facet_fe(get_fe_facet(fe_a),fe_a);

	mov	ecx, DWORD PTR _fe_a$[ebp]
	mov	eax, ecx
	shr	eax, 28					; 0000001cH
	add	esp, 8
	and	eax, 1
	mov	DWORD PTR tv1404[ebp], eax
	jne	SHORT $LN53@do_edgeswa
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN52@do_edgeswa
$LN53@do_edgeswa:
	cmp	DWORD PTR tv1294[ebp], 0
	mov	eax, DWORD PTR tv1297[ebp]
	mov	edx, DWORD PTR _web+460
	mov	edx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [edx+24]
	je	SHORT $LN52@do_edgeswa
	xor	eax, 134217728				; 08000000H
$LN52@do_edgeswa:
	push	ecx
	push	eax
	call	_set_facet_fe

; 2380 :   set_facet_fe(get_fe_facet(fe_ai),fe_ai);

	mov	ecx, DWORD PTR _fe_ai$[ebp]
	mov	ebx, ecx
	shr	ebx, 28					; 0000001cH
	add	esp, 8
	and	ebx, 1
	mov	DWORD PTR tv1411[ebp], ebx
	jne	SHORT $LN57@do_edgeswa
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN140@do_edgeswa
$LN57@do_edgeswa:
	cmp	DWORD PTR tv1318[ebp], 0
	mov	eax, DWORD PTR _web+460
	mov	edx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [edx+24]
	je	SHORT $LN140@do_edgeswa
	xor	eax, 134217728				; 08000000H
$LN140@do_edgeswa:
	push	ecx
	push	eax
	call	_set_facet_fe
	add	esp, 8

; 2381 :   set_fe_facet(fe_b,get_fe_facet(fe_ai));

	test	ebx, ebx
	jne	SHORT $LN61@do_edgeswa
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN60@do_edgeswa
$LN61@do_edgeswa:
	cmp	DWORD PTR tv1318[ebp], 0
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx+24]
	je	SHORT $LN60@do_edgeswa
	xor	eax, 134217728				; 08000000H
$LN60@do_edgeswa:
	mov	edx, DWORD PTR _fe_b$[ebp]
	push	eax
	push	edx
	call	_set_fe_facet
	add	esp, 8

; 2382 :   set_fe_facet(fe_d,get_fe_facet(fe_a));

	cmp	DWORD PTR tv1404[ebp], 0
	jne	SHORT $LN65@do_edgeswa
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN64@do_edgeswa
$LN65@do_edgeswa:
	cmp	DWORD PTR tv1294[ebp], 0
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR tv1297[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [edx+24]
	je	SHORT $LN64@do_edgeswa
	xor	eax, 134217728				; 08000000H
$LN64@do_edgeswa:
	push	eax
	push	esi
	call	_set_fe_facet

; 2383 :   v_id = get_fe_tailv(fe_c);

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR tv1334[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [edx+20]
	xor	eax, DWORD PTR tv1341[ebp]
	push	eax
	call	_get_edge_tailv

; 2384 :   set_edge_headv(e_id,v_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	eax
	push	ecx
	call	_set_edge_headv

; 2385 :   v_id = get_fe_headv(fe_d);

	mov	edx, DWORD PTR _web+460
	mov	ebx, esi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+edx]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	edx, eax
	push	edx
	mov	DWORD PTR tv1380[ebp], eax
	call	_get_edge_headv

; 2386 :   set_edge_tailv(e_id,v_id);

	push	eax
	mov	eax, DWORD PTR _e_id$[ebp]
	push	eax
	call	_set_edge_tailv
	add	esp, 32					; 00000020H

; 2387 :   set_next_edge(fe_a,fe_c);

	cmp	DWORD PTR tv1404[ebp], 0
	je	SHORT $LN72@do_edgeswa
	cmp	DWORD PTR tv1294[ebp], 0
	je	SHORT $LN73@do_edgeswa
	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe_c$[ebp]
	mov	eax, DWORD PTR tv1297[ebp]
	mov	edx, DWORD PTR [eax+edx]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [edx+28], ecx
	jmp	SHORT $LN72@do_edgeswa
$LN73@do_edgeswa:
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR tv1297[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _fe_c$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN72@do_edgeswa:

; 2388 :   set_prev_edge(fe_a,fe_d);

	mov	ecx, DWORD PTR _fe_a$[ebp]
	push	esi
	push	ecx
	call	_set_prev_edge
	add	esp, 8

; 2389 :   set_next_edge(fe_ai,fe_e);

	cmp	DWORD PTR tv1411[ebp], 0
	je	SHORT $LN77@do_edgeswa
	cmp	DWORD PTR tv1318[ebp], 0
	je	SHORT $LN78@do_edgeswa
	mov	eax, DWORD PTR _web+460
	mov	edx, DWORD PTR _fe_e$[ebp]
	mov	ecx, DWORD PTR [edi+eax]
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [ecx+28], edx
	jmp	SHORT $LN77@do_edgeswa
$LN78@do_edgeswa:
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [edi+edx]
	mov	ecx, DWORD PTR _fe_e$[ebp]
	mov	DWORD PTR [eax+32], ecx
$LN77@do_edgeswa:

; 2390 :   set_prev_edge(fe_ai,fe_b);

	mov	edx, DWORD PTR _fe_b$[ebp]
	mov	eax, DWORD PTR _fe_ai$[ebp]
	push	edx
	push	eax
	call	_set_prev_edge
	add	esp, 8

; 2391 :   set_next_edge(fe_b,fe_ai);

	test	DWORD PTR _fe_b$[ebp], 268435456	; 10000000H
	je	SHORT $LN82@do_edgeswa
	mov	eax, DWORD PTR _fe_b$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN83@do_edgeswa
	mov	ecx, DWORD PTR _fe_ai$[ebp]
	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+28], ecx
	jmp	SHORT $LN82@do_edgeswa
$LN83@do_edgeswa:
	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe_ai$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN82@do_edgeswa:

; 2392 :   set_prev_edge(fe_b,fe_e);

	mov	ecx, DWORD PTR _fe_e$[ebp]
	mov	edx, DWORD PTR _fe_b$[ebp]
	push	ecx
	push	edx
	call	_set_prev_edge
	add	esp, 8

; 2393 :   set_next_edge(fe_c,fe_d);

	test	DWORD PTR _fe_c$[ebp], 268435456	; 10000000H
	je	SHORT $LN87@do_edgeswa
	test	DWORD PTR _fe_c$[ebp], 134217728	; 08000000H
	je	SHORT $LN88@do_edgeswa
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR tv1334[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN87@do_edgeswa
$LN88@do_edgeswa:
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR tv1334[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR [ecx+32], esi
$LN87@do_edgeswa:

; 2394 :   set_prev_edge(fe_c,fe_a);

	mov	edx, DWORD PTR _fe_a$[ebp]
	mov	eax, DWORD PTR _fe_c$[ebp]
	push	edx
	push	eax
	call	_set_prev_edge
	add	esp, 8

; 2395 :   set_next_edge(fe_d,fe_a);

	test	esi, 268435456				; 10000000H
	je	SHORT $LN92@do_edgeswa
	test	esi, 134217728				; 08000000H
	je	SHORT $LN93@do_edgeswa
	mov	ecx, DWORD PTR _web+460
	mov	eax, DWORD PTR _fe_a$[ebp]
	mov	edx, DWORD PTR [ebx+ecx]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR [edx+28], eax
	jmp	SHORT $LN92@do_edgeswa
$LN93@do_edgeswa:
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ebx+eax]
	mov	edx, DWORD PTR _fe_a$[ebp]
	mov	DWORD PTR [ecx+32], edx
$LN92@do_edgeswa:

; 2396 :   set_prev_edge(fe_d,fe_c);

	mov	eax, DWORD PTR _fe_c$[ebp]
	push	eax
	push	esi
	call	_set_prev_edge

; 2397 :   set_next_edge(fe_e,fe_b);

	mov	eax, DWORD PTR _fe_e$[ebp]
	add	esp, 8
	test	eax, 268435456				; 10000000H
	je	SHORT $LN97@do_edgeswa
	test	eax, 134217728				; 08000000H
	je	SHORT $LN98@do_edgeswa
	mov	ecx, DWORD PTR _fe_b$[ebp]
	mov	esi, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+28], ecx
	jmp	SHORT $LN97@do_edgeswa
$LN98@do_edgeswa:
	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _fe_b$[ebp]
	mov	DWORD PTR [ecx+32], edx
$LN97@do_edgeswa:

; 2398 :   set_prev_edge(fe_e,fe_ai);

	mov	ecx, DWORD PTR _fe_ai$[ebp]
	push	ecx
	push	eax
	call	_set_prev_edge

; 2399 :   calc_edge(e_id);

	mov	edx, DWORD PTR _e_id$[ebp]
	push	edx
	call	_calc_edge
	add	esp, 12					; 0000000cH

; 2400 :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	$LN2@do_edgeswa

; 2401 :   { test_axial_points(get_fe_facet(fe_a));

	cmp	DWORD PTR tv1404[ebp], 0
	jne	SHORT $LN103@do_edgeswa
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN136@do_edgeswa
$LN103@do_edgeswa:
	cmp	DWORD PTR tv1294[ebp], 0
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR tv1297[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [edx+24]
	je	SHORT $LN136@do_edgeswa
	xor	eax, 134217728				; 08000000H
$LN136@do_edgeswa:
	push	eax
	call	_test_axial_points
	add	esp, 4

; 2402 :     test_axial_points(get_fe_facet(fe_ai));

	cmp	DWORD PTR tv1411[ebp], 0
	jne	SHORT $LN107@do_edgeswa
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN106@do_edgeswa
$LN107@do_edgeswa:
	cmp	DWORD PTR tv1318[ebp], 0
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx+24]
	je	SHORT $LN106@do_edgeswa
	xor	eax, 134217728				; 08000000H
$LN106@do_edgeswa:
	push	eax
	call	_test_axial_points
	add	esp, 4

; 2403 :   }
; 2404 : 
; 2405 :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	$LN2@do_edgeswa

; 2406 :   { 
; 2407 :     edge_id ed,ec;
; 2408 :     WRAPTYPE w;
; 2409 : 
; 2410 :     if ( get_vattr(get_fe_tailv(fe_d)) & AXIAL_POINT )

	mov	edi, DWORD PTR _web+460
	mov	edx, DWORD PTR [ebx+edi]
	mov	esi, DWORD PTR [edx+20]
	xor	esi, DWORD PTR tv1380[ebp]
	push	esi
	call	_get_edge_tailv
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	ecx, ecx
	add	esp, 4
	or	eax, ecx
	je	$LN4@do_edgeswa

; 2411 :     { ed = get_fe_edge(fe_b);

	mov	esi, DWORD PTR _fe_b$[ebp]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+edx*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [eax+20]

; 2412 :       ec = get_fe_edge(fe_e);

	mov	eax, DWORD PTR _fe_e$[ebp]
	mov	ecx, eax
	and	eax, 134217728				; 08000000H
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	xor	eax, DWORD PTR [edx+20]

; 2413 :       w = (*sym_compose)(get_edge_wrap(ec),get_edge_wrap(ed));

	mov	ecx, DWORD PTR _web+124
	mov	edi, eax
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN118@do_edgeswa
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN118@do_edgeswa:
	mov	edx, DWORD PTR _web+124
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ebx, eax
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	eax, DWORD PTR [eax+ecx]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN122@do_edgeswa
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN122@do_edgeswa:
	push	ebx
	push	eax
	call	DWORD PTR _sym_compose

; 2414 :       set_edge_wrap(e_id,w);

	mov	edx, DWORD PTR _e_id$[ebp]
	push	eax
	push	edx
	call	_set_edge_wrap
	add	esp, 16					; 00000010H

; 2415 :     }
; 2416 :     else

	jmp	$LN3@do_edgeswa
$LN4@do_edgeswa:

; 2417 :     { ed = get_fe_edge(fe_d);
; 2418 :       ec = get_fe_edge(fe_c);

	mov	eax, DWORD PTR tv1334[ebp]
	mov	ecx, DWORD PTR [eax+edi]

; 2419 :       w = (*sym_compose)(get_edge_wrap(ec),get_edge_wrap(ed));

	mov	eax, DWORD PTR _web+124
	mov	edi, DWORD PTR [ecx+20]
	xor	edi, DWORD PTR tv1341[ebp]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [eax+edx+784]
	mov	eax, DWORD PTR [ecx+edx]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN130@do_edgeswa
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN130@do_edgeswa:
	mov	ecx, DWORD PTR _web+124
	mov	ebx, eax
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN134@do_edgeswa
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN134@do_edgeswa:
	push	ebx
	push	eax
	call	DWORD PTR _sym_compose

; 2420 :       set_edge_wrap(e_id,(*sym_inverse)(w));

	push	eax
	call	DWORD PTR _sym_inverse
	mov	ecx, DWORD PTR _e_id$[ebp]
	push	eax
	push	ecx
	call	_set_edge_wrap
	add	esp, 20					; 00000014H
$LN3@do_edgeswa:

; 2421 :     }
; 2422 :     if ( ed && (web.modeltype == QUADRATIC) )

	test	esi, esi
	je	SHORT $LN2@do_edgeswa
	cmp	DWORD PTR _web+628, 2
	jne	$LN137@do_edgeswa

; 2423 :     { /* adjust coordinates of midpoint */
; 2424 :       REAL *x = get_coord(get_edge_midv(e_id));

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR tv1280[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+304]
	mov	ecx, DWORD PTR [ecx+edx+8]
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+104
	add	edi, DWORD PTR [ecx+eax+64]

; 2425 :       torus_wrap(x,x,(*sym_inverse)(get_edge_wrap(ed)));

	push	esi
	call	_get_edge_wrap
	push	eax
	call	DWORD PTR _sym_inverse
	push	eax
	push	edi
	push	edi
	call	_torus_wrap
	add	esp, 20					; 00000014H
$LN2@do_edgeswa:

; 2426 :     }
; 2427 :   }
; 2428 :   if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	SHORT $LN137@do_edgeswa

; 2429 :     new_vertex_average(get_edge_midv(e_id),VOLKEEP);

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR tv1280[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+304]
	mov	eax, DWORD PTR [ecx+edx+8]
	push	1
	push	eax
	call	_new_vertex_average
	add	esp, 8
$LN137@do_edgeswa:

; 2430 : 
; 2431 : #ifdef MPI_EVOLVER
; 2432 :   /* Record changed facet-edges for synchronization */
; 2433 :   if ( id_task(fe_a) != this_task )
; 2434 :     mpi_add_to_synch_list(fe_a);
; 2435 :   if ( id_task(fe_ai) != this_task )
; 2436 :     mpi_add_to_synch_list(fe_ai);
; 2437 :   if ( id_task(fe_b) != this_task )
; 2438 :     mpi_add_to_synch_list(fe_b);
; 2439 :   if ( id_task(fe_c) != this_task )
; 2440 :     mpi_add_to_synch_list(fe_c);
; 2441 :   if ( id_task(fe_d) != this_task )
; 2442 :     mpi_add_to_synch_list(fe_d);
; 2443 :   if ( id_task(fe_e) != this_task )
; 2444 :     mpi_add_to_synch_list(fe_e);
; 2445 : #endif
; 2446 :     
; 2447 : 
; 2448 :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	pop	edi
	pop	esi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 2449 :   return 1;

	mov	eax, 1
	pop	ebx

; 2450 : } /* end do_edgeswap */

	mov	esp, ebp
	pop	ebp
	ret	0
_do_edgeswap ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_vertex_angle
EXTRN	_dot:PROC
EXTRN	_get_edge_side:PROC
EXTRN	__CIasin:PROC
; Function compile flags: /Ogtp
;	COMDAT _vertex_angle
_TEXT	SEGMENT
_b$ = -100						; size = 48
_netforce$ = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_vertex_angle PROC					; COMDAT

; 2461 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2462 :   REAL b[MAXCOORD];  /* edge vectors */
; 2463 :   REAL angle;
; 2464 :   REAL bb;
; 2465 :   edge_id ea,eb;
; 2466 :   REAL ac;
; 2467 :   REAL netforce[MAXCOORD];
; 2468 :   int n;
; 2469 :   int count = 0;
; 2470 : 
; 2471 :   for ( n = 0 ; n < SDIM ; n++ ) netforce[n] = 0.0;

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _v_id$[ebp]
	push	ebx
	push	esi
	xor	ebx, ebx
	push	edi
	test	ecx, ecx
	jle	SHORT $LN12@vertex_ang
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	lea	edi, DWORD PTR _netforce$[ebp]
	rep stosd
$LN12@vertex_ang:

; 2472 : 
; 2473 :   eb = ea = get_vertex_edge(v_id);

	mov	eax, DWORD PTR _web+12
	fldz
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edi, DWORD PTR [ecx+28]
	mov	esi, edi
$LN9@vertex_ang:

; 2474 :   do {
; 2475 :      if ( !valid_id(eb) ) return 0.0;

	test	esi, 268435456				; 10000000H
	je	$LN13@vertex_ang

; 2476 :      get_edge_side(eb,b);

	lea	edx, DWORD PTR _b$[ebp]
	fstp	ST(0)
	push	edx
	push	esi
	call	_get_edge_side

; 2477 :      bb = sqrt(SDIM_dot(b,b));

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	add	esp, 20					; 00000014H
	call	__CIsqrt

; 2478 :      if ( bb > 0.0 )

	fldz
	mov	edx, DWORD PTR _web+616
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN42@vertex_ang

; 2479 :         for ( n = 0 ; n < SDIM ; n++ ) netforce[n] += b[n]/bb;

	xor	eax, eax
	cmp	edx, 4
	jl	SHORT $LC27@vertex_ang
	lea	ecx, DWORD PTR [edx-3]
$LN28@vertex_ang:
	fld	QWORD PTR _b$[ebp+eax*8]
	add	eax, 4
	fdiv	ST(0), ST(2)
	fadd	QWORD PTR _netforce$[ebp+eax*8-32]
	fstp	QWORD PTR _netforce$[ebp+eax*8-32]
	fld	QWORD PTR _b$[ebp+eax*8-24]
	fdiv	ST(0), ST(2)
	fadd	QWORD PTR _netforce$[ebp+eax*8-24]
	fstp	QWORD PTR _netforce$[ebp+eax*8-24]
	fld	QWORD PTR _b$[ebp+eax*8-16]
	fdiv	ST(0), ST(2)
	fadd	QWORD PTR _netforce$[ebp+eax*8-16]
	fstp	QWORD PTR _netforce$[ebp+eax*8-16]
	fld	QWORD PTR _b$[ebp+eax*8-8]
	fdiv	ST(0), ST(2)
	fadd	QWORD PTR _netforce$[ebp+eax*8-8]
	fstp	QWORD PTR _netforce$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN28@vertex_ang
$LC27@vertex_ang:
	cmp	eax, edx
	jge	SHORT $LN42@vertex_ang
$LC4@vertex_ang:
	fld	QWORD PTR _b$[ebp+eax*8]
	inc	eax
	fdiv	ST(0), ST(2)
	fadd	QWORD PTR _netforce$[ebp+eax*8-8]
	fstp	QWORD PTR _netforce$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC4@vertex_ang
$LN42@vertex_ang:

; 2480 :      count++;
; 2481 :      eb = get_next_tail_edge(eb); 

	mov	ecx, DWORD PTR _web+124
	fstp	ST(1)
	mov	eax, esi
	shr	eax, 27					; 0000001bH
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+esi*4]
	and	eax, 1
	mov	esi, DWORD PTR [ecx+eax*4+32]

; 2482 :   } while ( !equal_element(ea,eb) );

	mov	eax, edi
	mov	ecx, esi
	or	eax, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	inc	ebx
	cmp	eax, ecx
	jne	$LN9@vertex_ang

; 2483 :   if ( count < 2 ) return 0.0;

	cmp	ebx, 2
	jl	SHORT $LN13@vertex_ang

; 2484 :   ac = sqrt(SDIM_dot(netforce,netforce));

	push	edx
	fstp	ST(0)
	lea	edx, DWORD PTR _netforce$[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 2485 :   angle = (ac >= 2.0) ? M_PI : 2*asin(ac/2);

	fld	QWORD PTR __real@4000000000000000
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN15@vertex_ang
	pop	edi
	fstp	ST(0)
	fld	QWORD PTR __real@400921fb54442d18
	pop	esi
	pop	ebx

; 2486 :   return angle;
; 2487 : } // end vertex_angle()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@vertex_ang:

; 2485 :   angle = (ac >= 2.0) ? M_PI : 2*asin(ac/2);

	fmul	QWORD PTR __real@3fe0000000000000
	call	__CIasin
	fadd	ST(0), ST(0)
$LN13@vertex_ang:

; 2486 :   return angle;
; 2487 : } // end vertex_angle()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_vertex_angle ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_dihedral
;	COMDAT __real@bff0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\trirevis.c
CONST	ENDS
;	COMDAT _dihedral
_TEXT	SEGMENT
_aa$ = -188						; size = 8
_ad$ = -180						; size = 8
_bb$ = -172						; size = 8
_dd$ = -164						; size = 8
tv519 = -160						; size = 4
tv511 = -156						; size = 8
_ab$ = -156						; size = 8
_a$ = -148						; size = 48
_d$ = -100						; size = 48
_b$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_dihedral PROC						; COMDAT

; 2502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, DWORD PTR _e_id$[ebp]
	push	esi

; 2503 :   facetedge_id fe_a; /* for edge under test */
; 2504 :   facetedge_id fe_ai; /* other facetedge of e_id */
; 2505 :   facetedge_id fe_b; /* other side of one triangle */
; 2506 :   facetedge_id fe_d; /* other side of other triangle */
; 2507 :   REAL a[MAXCOORD],b[MAXCOORD],d[MAXCOORD];  /* edge vectors */
; 2508 :   REAL denom,costh;
; 2509 :   REAL aa,bb,dd,ad,ab,bd;
; 2510 : 
; 2511 :   /* test to be sure edge has exactly two adjacent facets */
; 2512 :   if ( get_vattr(get_edge_tailv(e_id)) & AXIAL_POINT )

	mov	esi, DWORD PTR _web+124
	push	edi
	mov	edi, DWORD PTR _dymem
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN11@dihedral
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR _web+216
	add	edx, DWORD PTR [eax+edi+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN10@dihedral
$LN11@dihedral:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+edi+304]
	mov	eax, DWORD PTR [eax+edx]
$LN10@dihedral:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN7@dihedral

; 2513 :     e_id = inverse_id(e_id);

	xor	ecx, 134217728				; 08000000H
$LN7@dihedral:

; 2514 :   fe_a = get_edge_fe(e_id);

	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	test	eax, eax
	jne	SHORT $LN15@dihedral
	xor	edx, edx
	jmp	SHORT $LN16@dihedral
$LN15@dihedral:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN14@dihedral
	xor	eax, 134217728				; 08000000H
$LN14@dihedral:
	mov	edx, eax
$LN16@dihedral:

; 2515 :   if ( !valid_id(fe_a) )  return 0.0;

	test	edx, 268435456				; 10000000H
	jne	SHORT $LN6@dihedral
	fldz
	pop	edi
	pop	esi

; 2539 : 
; 2540 : } // end dihedral()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@dihedral:

; 2516 :   if ( !equal_id(get_next_facet(fe_a),get_prev_facet(fe_a)) ) return 0.0;

	mov	edi, edx
	shr	edi, 27					; 0000001bH
	and	edi, 1
	push	ebx
	mov	ebx, DWORD PTR _web+460
	mov	DWORD PTR tv519[ebp], edi
	je	SHORT $LN19@dihedral
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	eax, DWORD PTR [ecx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN18@dihedral
$LN19@dihedral:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [ecx+40]
$LN18@dihedral:
	test	edi, edi
	je	SHORT $LN23@dihedral
	mov	esi, DWORD PTR [ecx+40]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN22@dihedral
$LN23@dihedral:
	mov	esi, DWORD PTR [ecx+36]
$LN22@dihedral:
	cmp	eax, esi
	jne	$LN54@dihedral

; 2517 :   fe_b = fe_inverse(get_prev_edge(fe_a));

	test	edi, edi
	je	SHORT $LN27@dihedral
	mov	edi, DWORD PTR [ecx+32]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN26@dihedral
$LN27@dihedral:
	mov	edi, DWORD PTR [ecx+28]
$LN26@dihedral:
	xor	edi, 134217728				; 08000000H

; 2518 :   fe_ai = fe_inverse(get_next_facet(fe_a));

	cmp	DWORD PTR tv519[ebp], 0
	je	SHORT $LN31@dihedral
	mov	eax, DWORD PTR [ecx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN30@dihedral
$LN31@dihedral:
	mov	eax, DWORD PTR [ecx+40]
$LN30@dihedral:
	xor	eax, 134217728				; 08000000H

; 2519 :   fe_d = get_next_edge(fe_ai); 

	test	eax, 134217728				; 08000000H
	je	SHORT $LN35@dihedral
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	esi, DWORD PTR [eax+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN34@dihedral
$LN35@dihedral:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	esi, DWORD PTR [eax+32]
$LN34@dihedral:

; 2520 :   if ( equal_id(fe_b,fe_d) ) return 0.0;

	cmp	edi, esi
	je	$LN54@dihedral

; 2521 : 
; 2522 :   /* test parallelism */
; 2523 :   get_fe_side(fe_a,a);

	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR [ecx+20]
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	push	edx
	call	_get_edge_side

; 2524 :   get_fe_side(fe_b,b);

	mov	eax, DWORD PTR _web+460
	mov	edx, edi
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	and	edi, 134217728				; 08000000H
	xor	edi, DWORD PTR [ecx+20]
	push	edi
	call	_get_edge_side

; 2525 :   get_fe_side(fe_d,d);

	mov	ecx, DWORD PTR _web+460
	mov	eax, esi
	lea	edx, DWORD PTR _d$[ebp]
	push	edx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [edx+20]
	push	esi
	call	_get_edge_side

; 2526 :   /* works in general dimension */
; 2527 :   aa = SDIM_dot(a,a);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _aa$[ebp]

; 2528 :   bb = SDIM_dot(b,b);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _bb$[ebp]

; 2529 :   dd = SDIM_dot(d,d);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _dd$[ebp]

; 2530 :   ab = SDIM_dot(a,b);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	call	_dot
	fstp	QWORD PTR _ab$[ebp]

; 2531 :   ad = SDIM_dot(a,d);

	mov	eax, DWORD PTR _web+616
	add	esp, 72					; 00000048H
	push	eax
	lea	ecx, DWORD PTR _d$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	call	_dot
	fstp	QWORD PTR _ad$[ebp]

; 2532 :   bd = SDIM_dot(b,d);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _d$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	call	_dot

; 2533 :   denom = (aa*bb - ab*ab)*(aa*dd - ad*ad);

	fld	QWORD PTR _dd$[ebp]
	fld	QWORD PTR _aa$[ebp]
	add	esp, 24					; 00000018H
	fmul	ST(1), ST(0)
	fld	QWORD PTR _ad$[ebp]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fsubp	ST(3), ST(0)
	fld	QWORD PTR _bb$[ebp]
	fmul	ST(0), ST(2)
	fld	QWORD PTR _ab$[ebp]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(4)
	fmulp	ST(1), ST(0)

; 2534 :   if ( denom <= 0.0 ) return 0.0;

	fldz
	fcom	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN46@dihedral
	fstp	ST(3)
	pop	ebx
	fstp	ST(3)
	pop	edi
	fstp	ST(0)
	pop	esi
	fstp	ST(1)
	fstp	ST(1)

; 2539 : 
; 2540 : } // end dihedral()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@dihedral:

; 2534 :   if ( denom <= 0.0 ) return 0.0;

	fstp	ST(0)

; 2535 :   costh = (ab*ad - aa*bd)/sqrt(denom);

	fxch	ST(1)
	fmulp	ST(3), ST(0)
	fxch	ST(3)
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR tv511[ebp]
	call	__CIsqrt
	fdivr	QWORD PTR tv511[ebp]

; 2536 :   if ( costh > 1.0 ) return 0.0;

	fld1
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@dihedral
	fstp	ST(0)
$LN54@dihedral:
	fldz
	pop	ebx
	pop	edi
	pop	esi

; 2539 : 
; 2540 : } // end dihedral()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@dihedral:

; 2537 :   if ( costh < -1.0 ) return M_PI;

	fld	QWORD PTR __real@bff0000000000000
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@dihedral
	pop	ebx
	fstp	ST(0)
	fld	QWORD PTR __real@400921fb54442d18
	pop	edi
	pop	esi

; 2539 : 
; 2540 : } // end dihedral()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@dihedral:

; 2538 :   return acos(costh);

	call	__CIacos

; 2539 : 
; 2540 : } // end dihedral()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	ebx
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_dihedral ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@LJAMFAPD@Notching?5edge?5?$CFs?6?$AA@	; `string'
PUBLIC	_ridge_notcher
EXTRN	_temp_free:PROC
EXTRN	_face_triangulate:PROC
EXTRN	_kb_temp_calloc:PROC
;	COMDAT ??_C@_0BC@LJAMFAPD@Notching?5edge?5?$CFs?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BC@LJAMFAPD@Notching?5edge?5?$CFs?6?$AA@ DB 'Notching edge %s', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\trirevis.c
CONST	ENDS
;	COMDAT _ridge_notcher
_TEXT	SEGMENT
tv416 = -20						; size = 4
_sentinel$ = -16					; size = 4
_notchcount$ = -12					; size = 4
_todo$ = -8						; size = 4
_e_id$ = -4						; size = 4
_max_angle$ = 8						; size = 8
_ridge_notcher PROC					; COMDAT

; 2557 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2558 :   int notchcount = 0;  /* number of edges notched */
; 2559 :   edge_id e_id;          /* edge to notch */
; 2560 :   facet_id *todo;     /* for list of facets to refine */
; 2561 :   int i;
; 2562 :   int maxfacet = web.skel[FACET].max_ord+1;

	mov	eax, DWORD PTR _web+292
	push	esi
	push	edi

; 2563 :   edge_id sentinel;
; 2564 : 
; 2565 :   web.vol_flag = 0;
; 2566 : 
; 2567 :   todo = (facet_id *)temp_calloc(web.skel[FACET].max_ord+1,sizeof(facet_id));

	push	2567					; 00000a07H
	push	OFFSET ??_C@_0L@CNPEKLEL@TRIREVIS?4C?$AA@
	inc	eax
	xor	ecx, ecx
	push	4
	push	eax
	mov	DWORD PTR _notchcount$[ebp], ecx
	mov	DWORD PTR tv416[ebp], eax
	mov	DWORD PTR _web+896, ecx
	call	_kb_temp_calloc

; 2568 : 
; 2569 :   /* first, unmark all NEWEDGE attributes */
; 2570 :   FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	add	esp, 16					; 00000010H
	mov	esi, eax
	mov	DWORD PTR _todo$[ebp], esi
	mov	DWORD PTR _e_id$[ebp], edx
	test	edx, 268435456				; 10000000H
	je	SHORT $LN13@ridge_notc
	mov	edi, DWORD PTR _web+124
	npad	3
$LL15@ridge_notc:
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN14@ridge_notc

; 2571 :       unset_attr(e_id,NEWEDGE);

	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [ecx+12]
	and	DWORD PTR [ecx+8], -5			; fffffffbH
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR _e_id$[ebp]
	mov	edi, DWORD PTR _web+124
$LN14@ridge_notc:

; 2568 : 
; 2569 :   /* first, unmark all NEWEDGE attributes */
; 2570 :   FOR_ALL_EDGES(e_id)

	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _e_id$[ebp], edx
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL15@ridge_notc
	mov	esi, DWORD PTR _todo$[ebp]
$LN13@ridge_notc:

; 2572 : 
; 2573 :   /* main loop over all edges */
; 2574 :   e_id = NULLEDGE;

	mov	ecx, DWORD PTR _NULLEDGE

; 2575 :   while ( generate_all(EDGE,&e_id,&sentinel) )

	lea	edx, DWORD PTR _sentinel$[ebp]
	push	edx
	lea	eax, DWORD PTR _e_id$[ebp]
	push	eax
	push	1
	mov	DWORD PTR _e_id$[ebp], ecx
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN51@ridge_notc
	npad	7
$LL10@ridge_notc:

; 2576 :   { REAL angle;
; 2577 :     facetedge_id fe_a;
; 2578 :     facet_id f_id;
; 2579 : 
; 2580 :     if ( get_eattr(e_id) & (FIXED | BOUNDARY | NEWEDGE) )

	mov	edx, DWORD PTR _e_id$[ebp]
	mov	eax, DWORD PTR _web+124
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 196				; 000000c4H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN6@ridge_notc

; 2581 :         continue;
; 2582 : 
; 2583 :     angle = dihedral(e_id);

	push	edx
	call	_dihedral

; 2584 :     if ( angle < max_angle )

	fcomp	QWORD PTR _max_angle$[ebp]
	add	esp, 4
	fnstsw	ax
	test	ah, 5
	jnp	$LN6@ridge_notc

; 2585 :       continue;
; 2586 : 
; 2587 :     /* record neighboring facets for subdivision */
; 2588 :     fe_a = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	eax, DWORD PTR _web+124
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $LN26@ridge_notc
$LN27@ridge_notc:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN26@ridge_notc
	xor	eax, 134217728				; 08000000H
$LN26@ridge_notc:

; 2589 :     f_id = get_fe_facet(fe_a);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN31@ridge_notc
	mov	edx, DWORD PTR _NULLFACET
	jmp	SHORT $LN30@ridge_notc
$LN31@ridge_notc:
	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN30@ridge_notc
	xor	edx, 134217728				; 08000000H
$LN30@ridge_notc:

; 2590 :     todo[loc_ordinal(f_id)] = f_id;

	test	edx, 268435456				; 10000000H
	je	SHORT $LN18@ridge_notc
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN19@ridge_notc
$LN18@ridge_notc:
	or	ecx, -1
$LN19@ridge_notc:
	mov	DWORD PTR [esi+ecx*4], edx

; 2591 :     f_id = get_fe_facet(get_next_facet(fe_a));

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN35@ridge_notc
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN34@ridge_notc
$LN35@ridge_notc:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+40]
$LN34@ridge_notc:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN39@ridge_notc
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN38@ridge_notc
$LN39@ridge_notc:
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN38@ridge_notc
	xor	ecx, 134217728				; 08000000H
$LN38@ridge_notc:

; 2592 :     todo[loc_ordinal(f_id)] = f_id;

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN20@ridge_notc
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN21@ridge_notc
$LN20@ridge_notc:
	or	eax, -1
$LN21@ridge_notc:
	mov	DWORD PTR [esi+eax*4], ecx

; 2593 :     if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN6@ridge_notc

; 2594 :     { sprintf(msg,"Notching edge %s\n",ELNAME(e_id));

	mov	eax, DWORD PTR _e_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN22@ridge_notc
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN23@ridge_notc
$LN22@ridge_notc:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN23@ridge_notc:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BC@LJAMFAPD@Notching?5edge?5?$CFs?6?$AA@
	push	edx
	call	_sprintf

; 2595 :       outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
$LN6@ridge_notc:

; 2575 :   while ( generate_all(EDGE,&e_id,&sentinel) )

	lea	ecx, DWORD PTR _sentinel$[ebp]
	push	ecx
	lea	edx, DWORD PTR _e_id$[ebp]
	push	edx
	push	1
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LL10@ridge_notc
$LN51@ridge_notc:

; 2596 :     }
; 2597 : 
; 2598 :   }
; 2599 : 
; 2600 :   for ( i = 0 ; i < maxfacet ; i++ )

	mov	edi, DWORD PTR tv416[ebp]
	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN50@ridge_notc
$LL5@ridge_notc:

; 2601 :      if ( valid_id(todo[i]) )

	mov	eax, DWORD PTR _todo$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@ridge_notc

; 2602 :         { face_triangulate(todo[i],FACET_EDGES);

	push	3
	push	eax
	call	_face_triangulate
	add	esp, 8

; 2603 :           notchcount++;

	inc	DWORD PTR _notchcount$[ebp]
$LN4@ridge_notc:

; 2596 :     }
; 2597 : 
; 2598 :   }
; 2599 : 
; 2600 :   for ( i = 0 ; i < maxfacet ; i++ )

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL5@ridge_notc
$LN50@ridge_notc:

; 2604 :         }
; 2605 :   temp_free((char*)todo);

	mov	ecx, DWORD PTR _todo$[ebp]
	push	ecx
	call	_temp_free

; 2606 : 
; 2607 :   if ( notchcount > 0 ) top_timestamp = ++global_timestamp;

	mov	ecx, DWORD PTR _notchcount$[ebp]
	add	esp, 4
	pop	edi
	pop	esi
	test	ecx, ecx
	jle	SHORT $LN49@ridge_notc
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN49@ridge_notc:

; 2608 :   return notchcount;

	mov	eax, ecx

; 2609 : } // end ridge_notcher()

	mov	esp, ebp
	pop	ebp
	ret	0
_ridge_notcher ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@CBCAKLHN@?$CFf?5?9?5?$CFf?5?5?5?5?5?5?$CF6d?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@OBKAAGJG@?$CFf?5?9?5?$CFf?5?5?5?5?5?5?$CF6d?5?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_ridge_histogram
;	COMDAT ??_C@_0BC@CBCAKLHN@?$CFf?5?9?5?$CFf?5?5?5?5?5?5?$CF6d?6?$AA@
CONST	SEGMENT
??_C@_0BC@CBCAKLHN@?$CFf?5?9?5?$CFf?5?5?5?5?5?5?$CF6d?6?$AA@ DB '%f - %f '
	DB	'     %6d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OBKAAGJG@?$CFf?5?9?5?$CFf?5?5?5?5?5?5?$CF6d?5?6?$AA@
CONST	SEGMENT
??_C@_0BD@OBKAAGJG@?$CFf?5?9?5?$CFf?5?5?5?5?5?5?$CF6d?5?6?$AA@ DB '%f - %'
	DB	'f      %6d ', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _ridge_histogram
_TEXT	SEGMENT
tv240 = -176						; size = 8
tv288 = -172						; size = 4
tv303 = -168						; size = 4
_bincount$ = -164					; size = 160
__$ArrayPad$ = -4					; size = 4
_ridge_histogram PROC					; COMDAT

; 2619 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2620 :   edge_id e_id;          /* edge to notch */
; 2621 :   int bincount[HISTO_BINS];
; 2622 :   int n;
; 2623 : 
; 2624 :   for ( n = 0 ; n < HISTO_BINS ; n++ ) bincount[n] = 0;

	xor	eax, eax

; 2625 : 
; 2626 :   /* main loop over all edges */
; 2627 :   FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	push	ebx
	push	esi
	mov	esi, eax
	push	edi
	mov	DWORD PTR _bincount$[ebp], esi
	mov	DWORD PTR _bincount$[ebp+4], eax
	mov	DWORD PTR _bincount$[ebp+8], eax
	mov	DWORD PTR _bincount$[ebp+12], eax
	mov	DWORD PTR _bincount$[ebp+16], eax
	mov	DWORD PTR _bincount$[ebp+20], eax
	mov	DWORD PTR _bincount$[ebp+24], eax
	mov	DWORD PTR _bincount$[ebp+28], eax
	mov	DWORD PTR _bincount$[ebp+32], eax
	mov	DWORD PTR _bincount$[ebp+36], eax
	mov	DWORD PTR _bincount$[ebp+40], eax
	mov	DWORD PTR _bincount$[ebp+44], eax
	mov	DWORD PTR _bincount$[ebp+48], eax
	mov	DWORD PTR _bincount$[ebp+52], eax
	mov	DWORD PTR _bincount$[ebp+56], eax
	mov	DWORD PTR _bincount$[ebp+60], eax
	mov	DWORD PTR _bincount$[ebp+64], eax
	mov	DWORD PTR _bincount$[ebp+68], eax
	mov	DWORD PTR _bincount$[ebp+72], eax
	mov	DWORD PTR _bincount$[ebp+76], eax
	mov	DWORD PTR _bincount$[ebp+80], eax
	mov	DWORD PTR _bincount$[ebp+84], eax
	mov	DWORD PTR _bincount$[ebp+88], eax
	mov	DWORD PTR _bincount$[ebp+92], eax
	mov	DWORD PTR _bincount$[ebp+96], eax
	mov	DWORD PTR _bincount$[ebp+100], eax
	mov	DWORD PTR _bincount$[ebp+104], eax
	mov	DWORD PTR _bincount$[ebp+108], eax
	mov	DWORD PTR _bincount$[ebp+112], eax
	mov	DWORD PTR _bincount$[ebp+116], eax
	mov	DWORD PTR _bincount$[ebp+120], eax
	mov	DWORD PTR _bincount$[ebp+124], eax
	mov	DWORD PTR _bincount$[ebp+128], eax
	mov	DWORD PTR _bincount$[ebp+132], eax
	mov	DWORD PTR _bincount$[ebp+136], eax
	mov	DWORD PTR _bincount$[ebp+140], eax
	mov	DWORD PTR _bincount$[ebp+144], eax
	mov	DWORD PTR _bincount$[ebp+148], eax
	mov	DWORD PTR _bincount$[ebp+152], eax
	mov	DWORD PTR _bincount$[ebp+156], eax
	test	edx, 268435456				; 10000000H
	je	$LN13@ridge_hist
	mov	ebx, DWORD PTR _web+124
$LL15@ridge_hist:
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ebx]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv240[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN14@ridge_hist

; 2628 :      { REAL angle;
; 2629 : 
; 2630 :         if ( get_eattr(e_id) & (FIXED | BOUNDARY ) ) continue;

	and	ecx, 192				; 000000c0H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN14@ridge_hist

; 2631 : 
; 2632 :         angle = dihedral(e_id);

	push	edx
	call	_dihedral

; 2633 :         if ( angle == 0.0 ) n = 0;

	fld	ST(0)
	fldz
	add	esp, 4
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@ridge_hist
	fstp	ST(0)
	xor	eax, eax

; 2634 :         else

	jmp	SHORT $LN6@ridge_hist
$LN9@ridge_hist:

; 2635 :           n = HISTO_BINS/2 + 1 + (int)floor(log(angle)*HISTO_BINSIZE);

	call	__CIlog
	fmul	QWORD PTR __real@3ff71547652b82fe
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	add	eax, 21					; 00000015H

; 2636 :         if ( n < 0 ) n = 0;

	jns	SHORT $LN7@ridge_hist
	xor	eax, eax

; 2637 :         if ( n >= HISTO_BINS ) n = HISTO_BINS - 1;

	jmp	SHORT $LN6@ridge_hist
$LN7@ridge_hist:
	cmp	eax, 40					; 00000028H
	jl	SHORT $LN6@ridge_hist
	mov	eax, 39					; 00000027H
$LN6@ridge_hist:

; 2638 :         bincount[n]++;

	inc	DWORD PTR _bincount$[ebp+eax*4]
	mov	ebx, DWORD PTR _web+124
	lea	eax, DWORD PTR _bincount$[ebp+eax*4]
$LN14@ridge_hist:

; 2625 : 
; 2626 :   /* main loop over all edges */
; 2627 :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR [esi+ebx]
	mov	edx, DWORD PTR [ecx]
	test	edx, 268435456				; 10000000H
	jne	$LL15@ridge_hist
	mov	esi, DWORD PTR _bincount$[ebp]
$LN13@ridge_hist:

; 2639 : 
; 2640 :      }
; 2641 : 
; 2642 :   /* print histogram */
; 2643 :   outstring("         angle                 number\n");

	push	OFFSET ??_C@_0CH@OJBAHNBM@?5?5?5?5?5?5?5?5?5angle?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5n@
	call	_outstring
	add	esp, 4

; 2644 :   if ( bincount[0] )

	test	esi, esi
	je	SHORT $LN5@ridge_hist

; 2645 :      {
; 2646 :         sprintf(msg,"%f - %f      %6d \n",0.0,
; 2647 :          (DOUBLE)(exp((-HISTO_BINS/2)/HISTO_BINSIZE)), bincount[0]);

	fld	QWORD PTR __real@c02bb9d3beb8c86b
	push	esi
	call	__CIexp
	mov	edx, DWORD PTR _msg
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fldz
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BD@OBKAAGJG@?$CFf?5?9?5?$CFf?5?5?5?5?5?5?$CF6d?5?6?$AA@
	push	edx
	call	_sprintf

; 2648 :         outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 32					; 00000020H
$LN5@ridge_hist:

; 2649 :      }
; 2650 :   for ( n = 1 ; n < HISTO_BINS ; n++ )

	mov	edi, -20				; ffffffecH
	mov	DWORD PTR tv303[ebp], edi
	lea	esi, DWORD PTR _bincount$[ebp+4]
	lea	ebx, DWORD PTR [edi+59]
	npad	5
$LL4@ridge_hist:

; 2651 :     if ( bincount[n] )

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@ridge_hist

; 2652 :      {
; 2653 :         sprintf(msg,"%f - %f      %6d\n",
; 2654 :                   (DOUBLE)(exp((n-HISTO_BINS/2-1)/HISTO_BINSIZE)),
; 2655 :                   (DOUBLE)(exp((n-HISTO_BINS/2)/HISTO_BINSIZE)),bincount[n]);

	lea	ecx, DWORD PTR [edi+1]
	mov	DWORD PTR tv288[ebp], ecx
	fild	DWORD PTR tv288[ebp]
	push	eax
	fdiv	QWORD PTR __real@3ff71547652b82fe
	call	__CIexp
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fild	DWORD PTR tv303[ebp]
	fdiv	QWORD PTR __real@3ff71547652b82fe
	call	__CIexp
	mov	edx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BC@CBCAKLHN@?$CFf?5?9?5?$CFf?5?5?5?5?5?5?$CF6d?6?$AA@
	push	edx
	call	_sprintf

; 2656 :         outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 32					; 00000020H
$LN3@ridge_hist:

; 2649 :      }
; 2650 :   for ( n = 1 ; n < HISTO_BINS ; n++ )

	inc	edi
	add	esi, 4
	dec	ebx
	mov	DWORD PTR tv303[ebp], edi
	jne	SHORT $LL4@ridge_hist

; 2657 :      }
; 2658 : 
; 2659 : } // end ridge_histogram()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ridge_histogram ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@GFBPCGBG@body_?$CFd_bdry_?$CFd_meth?$AA@ ; `string'
PUBLIC	??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@ ; `string'
PUBLIC	??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@	; `string'
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_fixup_vertex_content_meths
EXTRN	_apply_method:PROC
EXTRN	_nullcon:QWORD
EXTRN	_meth_inst_list:DWORD
EXTRN	_everything_quantities_flag:DWORD
EXTRN	_V_BOUNDARY_ATTR:DWORD
;	COMDAT ??_C@_0BF@GFBPCGBG@body_?$CFd_bdry_?$CFd_meth?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BF@GFBPCGBG@body_?$CFd_bdry_?$CFd_meth?$AA@ DB 'body_%d_bdry_%d_me'
	DB	'th', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@
CONST	SEGMENT
??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@ DB 'body_%d_con_%d_meth'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@
CONST	SEGMENT
??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@ DB 'body_%d_%s_meth', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\trirevis.c
CONST	ENDS
;	COMDAT _fixup_vertex_content_meths
_TEXT	SEGMENT
tv610 = -256						; size = 8
_attr$ = -248						; size = 8
_start_fe$ = -240					; size = 4
_bdry$ = -236						; size = 4
tv223 = -232						; size = 4
_k$ = -228						; size = 4
_f_id$90982 = -224					; size = 4
tv618 = -220						; size = 4
_map$ = -216						; size = 4
_v_id$GSCopy$ = -212					; size = 4
_fe$ = -208						; size = 4
_name$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_fixup_vertex_content_meths PROC			; COMDAT

; 2701 : { int  meth_offset = get_meth_offset(VERTEX); 

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2702 :   struct vertex *v_ptr = (struct vertex*)vptr(v_id);

	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR _web+104
	push	ebx
	mov	ebx, DWORD PTR _v_id$[ebp]

; 2752 :        { sprintf(name,"body_%d_bdry_%d_meth",ordinal(b_id)+1,get_vertex_boundary_num(v_id));

	mov	DWORD PTR _v_id$GSCopy$[ebp], ebx
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR _web+5664
	imul	eax, 240				; 000000f0H
	push	esi
	add	eax, edx
	push	edi
	mov	edi, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+edi+64]
	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	add	esi, ecx
	test	eax, eax
	je	SHORT $LN25@fixup_vert

; 2703 :   int *instlist = (int*)((char*)v_ptr + meth_offset);
; 2704 :   facetedge_id start_fe,fe;
; 2705 :   conmap_t *map;
; 2706 :   struct boundary *bdry = get_vertex_boundary(v_id);

	imul	eax, 240				; 000000f0H
	add	eax, edx
	mov	eax, DWORD PTR [eax+edi+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	mov	DWORD PTR _bdry$[ebp], eax
	jmp	SHORT $LN26@fixup_vert
$LN25@fixup_vert:
	mov	DWORD PTR _bdry$[ebp], 0
$LN26@fixup_vert:

; 2707 :   ATTR attr;
; 2708 :   int i,k; 
; 2709 :   char name[200];
; 2710 :   
; 2711 :   if ( !everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN13@fixup_vert

; 2712 :     return;
; 2713 : 
; 2714 :   attr = get_vattr(v_id);

	mov	eax, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+12]
	mov	DWORD PTR _attr$[ebp], eax
	mov	DWORD PTR _attr$[ebp+4], edi

; 2715 :   if ( !(attr & (BOUNDARY|CONSTRAINT)) )

	and	eax, 1152				; 00000480H
	xor	edi, edi
	or	eax, edi
	je	$LN13@fixup_vert

; 2716 :     return;
; 2717 : 
; 2718 :   /* Delete old content methods. */
; 2719 :   for ( i = 0 ; i < (int)v_ptr->method_count ; i++ )

	xor	eax, eax
	cmp	ax, WORD PTR [ecx+24]
	jae	SHORT $LN66@fixup_vert
	npad	4
$LL20@fixup_vert:

; 2720 :   { if ( METH_INSTANCE(instlist[i])->flags & BODY_INSTANCE )

	mov	eax, DWORD PTR [esi+edi*4]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	test	DWORD PTR [eax+edx+140], 16777216	; 01000000H
	je	SHORT $LN19@fixup_vert

; 2721 :     { instlist[i] = instlist[--v_ptr->method_count];

	mov	eax, 65535				; 0000ffffH
	add	WORD PTR [ecx+24], ax
	movzx	edx, WORD PTR [ecx+24]
	mov	eax, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [esi+edi*4], eax

; 2722 :       i--;

	dec	edi
$LN19@fixup_vert:

; 2716 :     return;
; 2717 : 
; 2718 :   /* Delete old content methods. */
; 2719 :   for ( i = 0 ; i < (int)v_ptr->method_count ; i++ )

	movzx	edx, WORD PTR [ecx+24]
	inc	edi
	cmp	edi, edx
	jl	SHORT $LL20@fixup_vert
	mov	edx, DWORD PTR _web+104
$LN66@fixup_vert:

; 2723 :     }
; 2724 :   }
; 2725 : 
; 2726 :   map = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _dymem
	cmp	DWORD PTR [edx+eax+1288], 0
	je	SHORT $LN27@fixup_vert
	mov	ecx, DWORD PTR _web+12
	mov	ebx, DWORD PTR [ebx+ecx]
	add	ebx, DWORD PTR [edx+eax+1264]
	mov	DWORD PTR _map$[ebp], ebx
	jmp	SHORT $LN28@fixup_vert
$LN27@fixup_vert:
	mov	DWORD PTR _map$[ebp], OFFSET _nullcon
$LN28@fixup_vert:

; 2727 : 
; 2728 :   /* Add current content methods */  
; 2729 :   start_fe = fe = get_vertex_fe(v_id);

	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	push	edx
	call	_get_vertex_fe
	add	esp, 4
	mov	DWORD PTR _fe$[ebp], eax
	mov	DWORD PTR _start_fe$[ebp], eax

; 2730 :   if ( valid_id(fe) )

	test	eax, 268435456				; 10000000H
	je	$LN13@fixup_vert
	mov	eax, DWORD PTR _web+460
	mov	edx, DWORD PTR _web+236
	npad	10
$LL15@fixup_vert:

; 2731 :   do
; 2732 :   { int sides;
; 2733 :     facet_id f_id = get_fe_facet(fe);

	mov	ecx, DWORD PTR _fe$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN40@fixup_vert
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN39@fixup_vert
$LN40@fixup_vert:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN39@fixup_vert
	xor	esi, 134217728				; 08000000H
$LN39@fixup_vert:
	mov	ebx, DWORD PTR _v_id$GSCopy$[ebp]
	mov	eax, ebx
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _f_id$90982[ebp], esi

; 2734 :     vertex_id vv_id = v_id;

	mov	DWORD PTR tv618[ebp], eax
	mov	DWORD PTR tv223[ebp], 2
	jmp	SHORT $LN12@fixup_vert
	npad	9
$LL63@fixup_vert:
	mov	ebx, DWORD PTR _v_id$GSCopy$[ebp]
$LN12@fixup_vert:

; 2735 :     for ( sides = 0 ; sides < 2 ; sides++ )
; 2736 :     { body_id b_id;
; 2737 :     
; 2738 :       b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN46@fixup_vert
	xor	edi, edi
	jmp	SHORT $LN43@fixup_vert
$LN46@fixup_vert:
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN45@fixup_vert
	xor	edi, edi
	jmp	SHORT $LN43@fixup_vert
$LN45@fixup_vert:
	test	esi, 134217728				; 08000000H
	je	SHORT $LN44@fixup_vert
	mov	edi, DWORD PTR _dymem
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+edi+784]
	mov	edi, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN43@fixup_vert
$LN44@fixup_vert:
	mov	edi, DWORD PTR _web+328
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edi+eax+784]
	mov	edi, DWORD PTR [ecx+eax]
$LN43@fixup_vert:

; 2739 :       if ( valid_id(f_id) && valid_id(b_id) && !(get_fattr(f_id) & NONCONTENT) )

	test	esi, 268435456				; 10000000H
	je	$LN69@fixup_vert
	test	edi, 268435456				; 10000000H
	je	$LN69@fixup_vert
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN69@fixup_vert

; 2740 :       { if ( attr & CONSTRAINT )

	mov	eax, DWORD PTR _attr$[ebp]
	and	eax, 1024				; 00000400H
	or	eax, ecx
	je	$LN64@fixup_vert

; 2741 :           for ( k = 1 ; k <= (int)map[0] ; k++ )

	mov	ecx, DWORD PTR _map$[ebp]
	mov	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR [ecx], eax
	jl	$LN64@fixup_vert
	npad	5
$LL60@fixup_vert:

; 2742 :           { struct constraint *con = get_constraint(map[k]);

	mov	edx, DWORD PTR _map$[ebp]
	mov	esi, DWORD PTR [edx+eax*4]
	and	esi, 1073741823				; 3fffffffH
	mov	eax, esi
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 2743 :             if ( con->attr & CON_CONTENT )

	xor	ebx, ebx
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR tv610[ebp+4], ecx
	mov	ecx, edx
	and	ecx, 128				; 00000080H
	or	ecx, ebx
	je	SHORT $LN6@fixup_vert

; 2744 :             { if ( con->attr & NAMED_THING )

	and	edx, 512				; 00000200H
	xor	ecx, ecx
	or	edx, ecx
	je	SHORT $LN3@fixup_vert

; 2745 :                  sprintf(name,"body_%d_%s_meth",ordinal(b_id)+1,con->name);

	mov	edx, edi
	push	eax
	and	edx, 134217727				; 07ffffffH
	inc	edx
	push	edx
	push	OFFSET ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@
	lea	eax, DWORD PTR _name$[ebp]
	push	eax

; 2746 :               else

	jmp	SHORT $LN71@fixup_vert
$LN3@fixup_vert:

; 2747 :                  sprintf(name,"body_%d_con_%d_meth",ordinal(b_id)+1,map[k]&CONMASK);

	mov	ecx, edi
	push	esi
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
$LN71@fixup_vert:
	call	_sprintf

; 2748 :               apply_method(inverse_id(vv_id),name); 

	mov	ecx, DWORD PTR tv618[ebp]
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	push	ecx
	call	_apply_method
	add	esp, 8
$LN6@fixup_vert:

; 2741 :           for ( k = 1 ; k <= (int)map[0] ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _map$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR [edx]
	jle	$LL60@fixup_vert
	mov	edx, DWORD PTR _web+236
	mov	esi, DWORD PTR _f_id$90982[ebp]
	mov	ebx, DWORD PTR _v_id$GSCopy$[ebp]
$LN64@fixup_vert:

; 2749 :             }
; 2750 :           }
; 2751 :        if ( bdry && (bdry->attr & CON_CONTENT) )

	mov	eax, DWORD PTR _bdry$[ebp]
	test	eax, eax
	je	SHORT $LN69@fixup_vert
	mov	eax, DWORD PTR [eax+32]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN69@fixup_vert

; 2752 :        { sprintf(name,"body_%d_bdry_%d_meth",ordinal(b_id)+1,get_vertex_boundary_num(v_id));

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN33@fixup_vert
	mov	ecx, DWORD PTR _web+12
	imul	eax, 240				; 000000f0H
	and	ebx, 134217727				; 07ffffffH
	add	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR [edx+eax]
	jmp	SHORT $LN34@fixup_vert
$LN33@fixup_vert:
	xor	eax, eax
$LN34@fixup_vert:
	push	eax
	and	edi, 134217727				; 07ffffffH
	inc	edi
	push	edi
	lea	ecx, DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0BF@GFBPCGBG@body_?$CFd_bdry_?$CFd_meth?$AA@
	push	ecx
	call	_sprintf

; 2753 :          apply_method(inverse_id(vv_id),name);

	mov	eax, DWORD PTR tv618[ebp]
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	push	eax
	call	_apply_method
	mov	edx, DWORD PTR _web+236
	add	esp, 24					; 00000018H
$LN69@fixup_vert:

; 2754 :        }
; 2755 :       }
; 2756 :       f_id = inverse_id(f_id);
; 2757 :       v_id = inverse_id(vv_id);

	mov	ecx, DWORD PTR tv618[ebp]
	xor	esi, 134217728				; 08000000H
	dec	DWORD PTR tv223[ebp]
	mov	DWORD PTR _f_id$90982[ebp], esi
	mov	DWORD PTR _v_id$GSCopy$[ebp], ecx
	jne	$LL63@fixup_vert

; 2758 :     }
; 2759 :     fe = get_next_facet(fe);

	mov	eax, DWORD PTR _fe$[ebp]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	test	eax, 134217728				; 08000000H
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [eax+ecx*4]
	je	SHORT $LN50@fixup_vert
	mov	ecx, DWORD PTR [ecx+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN72@fixup_vert
$LN50@fixup_vert:
	mov	ecx, DWORD PTR [ecx+40]
$LN72@fixup_vert:
	mov	DWORD PTR _fe$[ebp], ecx

; 2760 :   } while ( !equal_id(fe,start_fe) );

	mov	ecx, DWORD PTR _start_fe$[ebp]
	cmp	DWORD PTR _fe$[ebp], ecx
	jne	$LL15@fixup_vert
$LN13@fixup_vert:

; 2761 : } /* end fixup_vertex_content_meths() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fixup_vertex_content_meths ENDP
_TEXT	ENDS
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_fixup_edge_content_meths
EXTRN	_apply_method_num:PROC
; Function compile flags: /Ogtp
;	COMDAT _fixup_edge_content_meths
_TEXT	SEGMENT
tv1059 = -260						; size = 8
_attr$ = -252						; size = 8
_bdry$ = -244						; size = 4
_k$ = -240						; size = 4
tv778 = -236						; size = 4
_f_id$91090 = -232					; size = 4
_map$ = -228						; size = 4
_ee_id$91091 = -224					; size = 4
_start_fe$ = -220					; size = 4
tv833 = -216						; size = 4
_e_id$GSCopy$ = -212					; size = 4
_fe$ = -208						; size = 4
_name$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_fixup_edge_content_meths PROC				; COMDAT

; 2775 : { int  meth_offset = get_meth_offset(EDGE); 

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	edx, DWORD PTR _web+5668
	mov	eax, DWORD PTR _e_id$[ebp]
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+216

; 2776 :   struct edge *e_ptr = (struct edge*)eptr(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	DWORD PTR _e_id$GSCopy$[ebp], eax
	and	eax, 134217727				; 07ffffffH
	push	ebx

; 2777 :   int *instlist = (int*)((char*)e_ptr + meth_offset);

	mov	ebx, DWORD PTR _dymem
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	push	esi
	mov	esi, DWORD PTR [edx+ebx+64]
	push	edi
	mov	DWORD PTR tv833[ebp], eax

; 2778 :   facetedge_id start_fe,fe;
; 2779 :   conmap_t *map;
; 2780 :   struct boundary *bdry = get_edge_boundary(e_id);

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	xor	edi, edi
	add	esi, ecx
	cmp	eax, edi
	je	SHORT $LN38@fixup_edge
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	mov	DWORD PTR _bdry$[ebp], eax
	jmp	SHORT $LN39@fixup_edge
$LN38@fixup_edge:
	mov	DWORD PTR _bdry$[ebp], edi
$LN39@fixup_edge:

; 2781 :   ATTR attr;
; 2782 :   int i,k;
; 2783 :   char name[200];
; 2784 :   
; 2785 :   if ( !everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, edi
	je	$LN13@fixup_edge

; 2786 :     return;
; 2787 : 
; 2788 :   if ( web.representation == STRING )

	mov	eax, DWORD PTR _web+624
	cmp	eax, 1
	jne	$LN34@fixup_edge

; 2789 :   { facet_id f_id;
; 2790 :     body_id b_id,bb_id;
; 2791 : 
; 2792 :     /* Delete old content methods. */
; 2793 :     for ( i = 0 ; i < (int)e_ptr->method_count ; i++ )

	xor	edx, edx
	cmp	dx, WORD PTR [ecx+24]
	jae	SHORT $LN109@fixup_edge
	mov	ebx, 16777216				; 01000000H
$LL33@fixup_edge:

; 2794 :     { if ( METH_INSTANCE(instlist[i])->flags & BODY_INSTANCE )

	mov	eax, DWORD PTR [esi+edi*4]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	test	DWORD PTR [eax+edx+140], ebx
	je	SHORT $LN32@fixup_edge

; 2795 :       { instlist[i] = instlist[--e_ptr->method_count];

	mov	eax, 65535				; 0000ffffH
	add	WORD PTR [ecx+24], ax
	movzx	edx, WORD PTR [ecx+24]
	mov	eax, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [esi+edi*4], eax

; 2796 :         i--;

	dec	edi
$LN32@fixup_edge:

; 2789 :   { facet_id f_id;
; 2790 :     body_id b_id,bb_id;
; 2791 : 
; 2792 :     /* Delete old content methods. */
; 2793 :     for ( i = 0 ; i < (int)e_ptr->method_count ; i++ )

	movzx	edx, WORD PTR [ecx+24]
	inc	edi
	cmp	edi, edx
	jl	SHORT $LL33@fixup_edge
	mov	ebx, DWORD PTR _dymem
$LN109@fixup_edge:

; 2797 :       }
; 2798 :     }
; 2799 :     fe = start_fe = get_edge_fe(e_id);

	mov	eax, DWORD PTR tv833[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+ecx]
	test	eax, eax
	je	SHORT $LN52@fixup_edge
$LN53@fixup_edge:
	test	DWORD PTR _e_id$GSCopy$[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR [eax+28]
	je	SHORT $LN52@fixup_edge
	xor	eax, 134217728				; 08000000H
$LN52@fixup_edge:
	mov	DWORD PTR _start_fe$[ebp], eax
	mov	edi, eax

; 2800 :     if ( valid_id(fe) )

	shr	eax, 28					; 0000001cH
	test	al, 1
	je	$LN13@fixup_edge
	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _web+236
	npad	6
$LL28@fixup_edge:

; 2801 :       do
; 2802 :       { f_id = get_fe_facet(fe);

	test	al, 1
	jne	SHORT $LN57@fixup_edge
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN56@fixup_edge
$LN57@fixup_edge:
	mov	esi, DWORD PTR _web+460
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR [eax+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN56@fixup_edge
	xor	esi, 134217728				; 08000000H
$LN56@fixup_edge:

; 2803 :         b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN63@fixup_edge
	xor	eax, eax
	jmp	SHORT $LN60@fixup_edge
$LN63@fixup_edge:
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN62@fixup_edge
	xor	eax, eax
	jmp	SHORT $LN60@fixup_edge
$LN62@fixup_edge:
	mov	ebx, DWORD PTR [ecx+ebx+784]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN61@fixup_edge
	mov	eax, DWORD PTR [eax+ebx+4]
	jmp	SHORT $LN112@fixup_edge
$LN61@fixup_edge:
	mov	eax, DWORD PTR [eax+ebx]
$LN112@fixup_edge:
	mov	ebx, DWORD PTR _dymem
$LN60@fixup_edge:

; 2804 :         if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN25@fixup_edge

; 2805 :         { int m = get_body_volmeth(b_id);
; 2806 :           apply_method_num(e_id,m);

	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+412]
	mov	ecx, DWORD PTR _e_id$GSCopy$[ebp]
	push	eax
	push	ecx
	call	_apply_method_num
	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _web+236
	mov	ebx, DWORD PTR _dymem
	add	esp, 8
$LN25@fixup_edge:

; 2807 :         }
; 2808 :         bb_id = get_facet_body(inverse_id(f_id));

	xor	esi, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	mov	eax, esi
	jne	SHORT $LN69@fixup_edge
	xor	eax, eax
	jmp	SHORT $LN66@fixup_edge
$LN69@fixup_edge:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN68@fixup_edge
	xor	eax, eax
	jmp	SHORT $LN66@fixup_edge
$LN68@fixup_edge:
	mov	esi, DWORD PTR [ecx+ebx+784]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN67@fixup_edge
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+esi+4]
	jmp	SHORT $LN66@fixup_edge
$LN67@fixup_edge:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+esi]
$LN66@fixup_edge:

; 2809 :         if ( valid_id(bb_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN110@fixup_edge

; 2810 :         { int m = get_body_volmeth(bb_id);
; 2811 :           apply_method_num(e_id,-m);

	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+412]
	mov	ecx, DWORD PTR _e_id$GSCopy$[ebp]
	neg	eax
	push	eax
	push	ecx
	call	_apply_method_num
	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _web+236
	mov	ebx, DWORD PTR _dymem
	add	esp, 8
$LN110@fixup_edge:

; 2812 :         }
; 2813 :         fe = get_next_facet(fe);

	mov	eax, DWORD PTR _web+460
	test	edi, 134217728				; 08000000H
	je	SHORT $LN73@fixup_edge
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR [eax+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN27@fixup_edge
$LN73@fixup_edge:
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR [eax+40]
$LN27@fixup_edge:

; 2814 :       } while ( valid_id(fe) && !equal_id(fe,start_fe) );

	mov	eax, edi
	shr	eax, 28					; 0000001cH
	test	al, 1
	je	$LN13@fixup_edge
	cmp	edi, DWORD PTR _start_fe$[ebp]
	jne	$LL28@fixup_edge
	pop	edi
	pop	esi
	pop	ebx

; 2868 : } /* end fixup_edge_content_meths() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@fixup_edge:

; 2815 :     return;
; 2816 :   }
; 2817 : 
; 2818 :   if ( web.representation != SOAPFILM )

	cmp	eax, 2
	jne	$LN13@fixup_edge

; 2819 :     return;
; 2820 : 
; 2821 :   attr = get_eattr(e_id);

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _attr$[ebp], eax
	mov	DWORD PTR _attr$[ebp+4], edx

; 2822 :   if ( !(attr & (BOUNDARY|CONSTRAINT)) )

	and	eax, 1152				; 00000480H
	xor	edx, edx
	or	eax, edx
	je	$LN13@fixup_edge

; 2823 :     return;
; 2824 : 
; 2825 :   /* Delete old content methods. */
; 2826 :   for ( i = 0 ; i < (int)e_ptr->method_count ; i++ )

	xor	eax, eax
	xor	edi, edi
	cmp	ax, WORD PTR [ecx+24]
	jae	SHORT $LN111@fixup_edge
	mov	ebx, 16777216				; 01000000H
$LL20@fixup_edge:

; 2827 :   { if ( METH_INSTANCE(instlist[i])->flags & BODY_INSTANCE )

	mov	eax, DWORD PTR [esi+edi*4]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	test	DWORD PTR [eax+edx+140], ebx
	je	SHORT $LN19@fixup_edge

; 2828 :     { instlist[i] = instlist[--e_ptr->method_count];

	mov	eax, 65535				; 0000ffffH
	add	WORD PTR [ecx+24], ax
	movzx	edx, WORD PTR [ecx+24]
	mov	eax, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [esi+edi*4], eax

; 2829 :       i--;

	dec	edi
$LN19@fixup_edge:

; 2823 :     return;
; 2824 : 
; 2825 :   /* Delete old content methods. */
; 2826 :   for ( i = 0 ; i < (int)e_ptr->method_count ; i++ )

	movzx	edx, WORD PTR [ecx+24]
	inc	edi
	cmp	edi, edx
	jl	SHORT $LL20@fixup_edge
	mov	ebx, DWORD PTR _dymem
$LN111@fixup_edge:

; 2830 :     }
; 2831 :   }
; 2832 : 
; 2833 :   map = get_e_constraint_map(e_id);

	mov	ecx, DWORD PTR _web+216
	cmp	DWORD PTR [ecx+ebx+1048], 0
	je	SHORT $LN40@fixup_edge
	mov	eax, DWORD PTR tv833[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+edx]
	add	eax, DWORD PTR [ecx+ebx+1024]
	mov	DWORD PTR _map$[ebp], eax
	jmp	SHORT $LN41@fixup_edge
$LN40@fixup_edge:
	mov	DWORD PTR _map$[ebp], OFFSET _nullcon
$LN41@fixup_edge:

; 2834 : 
; 2835 :   /* Add current content methods */  
; 2836 :   start_fe = fe = get_edge_fe(e_id);

	mov	eax, DWORD PTR tv833[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+ecx]
	test	eax, eax
	je	SHORT $LN76@fixup_edge
$LN77@fixup_edge:
	test	DWORD PTR _e_id$GSCopy$[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR [eax+28]
	je	SHORT $LN76@fixup_edge
	xor	eax, 134217728				; 08000000H
$LN76@fixup_edge:
	mov	DWORD PTR _fe$[ebp], eax
	mov	DWORD PTR _start_fe$[ebp], eax

; 2837 :   if ( valid_id(fe) )

	test	eax, 268435456				; 10000000H
	je	$LN13@fixup_edge
	mov	eax, DWORD PTR _web+460
	mov	edx, DWORD PTR _web+236
$LL15@fixup_edge:

; 2838 :   do
; 2839 :   { int sides;
; 2840 :     facet_id f_id = get_fe_facet(fe);

	mov	ecx, DWORD PTR _fe$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN81@fixup_edge
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN80@fixup_edge
$LN81@fixup_edge:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN80@fixup_edge
	xor	esi, 134217728				; 08000000H
$LN80@fixup_edge:

; 2841 :     edge_id ee_id = e_id;

	mov	ecx, DWORD PTR _e_id$GSCopy$[ebp]
	mov	DWORD PTR _f_id$91090[ebp], esi
	mov	DWORD PTR _ee_id$91091[ebp], ecx
	mov	DWORD PTR tv778[ebp], 2
$LL12@fixup_edge:

; 2842 :     for ( sides = 0 ; sides < 2 ; sides++ )
; 2843 :     { body_id b_id;
; 2844 :     
; 2845 :       b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN87@fixup_edge
	xor	edi, edi
	jmp	SHORT $LN84@fixup_edge
$LN87@fixup_edge:
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN86@fixup_edge
	xor	edi, edi
	jmp	SHORT $LN84@fixup_edge
$LN86@fixup_edge:
	test	esi, 134217728				; 08000000H
	je	SHORT $LN85@fixup_edge
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	eax, DWORD PTR [eax+ebx+784]
	mov	edi, DWORD PTR [ecx+eax+4]
	jmp	SHORT $LN84@fixup_edge
$LN85@fixup_edge:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+ebx+784]
	mov	edi, DWORD PTR [eax+ecx]
$LN84@fixup_edge:

; 2846 :       if ( valid_id(f_id) && valid_id(b_id) && !(get_fattr(f_id) & NONCONTENT) )

	test	esi, 268435456				; 10000000H
	je	$LN1@fixup_edge
	test	edi, 268435456				; 10000000H
	je	$LN1@fixup_edge
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN1@fixup_edge

; 2847 :       { if ( attr & CONSTRAINT )

	mov	eax, DWORD PTR _attr$[ebp]
	and	eax, 1024				; 00000400H
	or	eax, ecx
	je	$LN5@fixup_edge

; 2848 :           for ( k = 1 ; k <= (int)map[0] ; k++ )

	mov	ecx, DWORD PTR _map$[ebp]
	mov	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR [ecx], eax
	jl	$LN5@fixup_edge
	npad	8
$LL104@fixup_edge:

; 2849 :           { struct constraint *con = get_constraint(map[k]);

	mov	edx, DWORD PTR _map$[ebp]
	mov	esi, DWORD PTR [edx+eax*4]
	and	esi, 1073741823				; 3fffffffH
	mov	eax, esi
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 2850 :             if ( con->attr & CON_CONTENT )

	xor	ebx, ebx
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR tv1059[ebp+4], ecx
	mov	ecx, edx
	and	ecx, 128				; 00000080H
	or	ecx, ebx
	je	SHORT $LN6@fixup_edge

; 2851 :             { if ( con->attr & NAMED_THING )

	and	edx, 512				; 00000200H
	xor	ecx, ecx
	or	edx, ecx
	je	SHORT $LN3@fixup_edge

; 2852 :                  sprintf(name,"body_%d_%s_meth",ordinal(b_id)+1,con->name);

	mov	edx, edi
	push	eax
	and	edx, 134217727				; 07ffffffH
	inc	edx
	push	edx
	push	OFFSET ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@
	lea	eax, DWORD PTR _name$[ebp]
	push	eax

; 2853 :               else

	jmp	SHORT $LN113@fixup_edge
$LN3@fixup_edge:

; 2854 :                  sprintf(name,"body_%d_con_%d_meth",ordinal(b_id)+1,map[k]&CONMASK);

	mov	ecx, edi
	push	esi
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
$LN113@fixup_edge:
	call	_sprintf

; 2855 :               apply_method(ee_id,name); 

	mov	ecx, DWORD PTR _ee_id$91091[ebp]
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	push	ecx
	call	_apply_method
	add	esp, 8
$LN6@fixup_edge:

; 2848 :           for ( k = 1 ; k <= (int)map[0] ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _map$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR [edx]
	jle	$LL104@fixup_edge
	mov	edx, DWORD PTR _web+236
	mov	ebx, DWORD PTR _dymem
	mov	esi, DWORD PTR _f_id$91090[ebp]
$LN5@fixup_edge:

; 2856 :             }
; 2857 :           }
; 2858 :        if ( bdry && (bdry->attr & CON_CONTENT) )

	mov	eax, DWORD PTR _bdry$[ebp]
	test	eax, eax
	je	SHORT $LN1@fixup_edge
	mov	eax, DWORD PTR [eax+32]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN1@fixup_edge

; 2859 :        { sprintf(name,"body_%d_bdry_%d_meth",ordinal(b_id)+1,get_edge_boundary_num(e_id));

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN46@fixup_edge
	mov	ecx, DWORD PTR tv833[ebp]
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN47@fixup_edge
$LN46@fixup_edge:
	xor	eax, eax
$LN47@fixup_edge:
	push	eax
	and	edi, 134217727				; 07ffffffH
	inc	edi
	push	edi
	lea	edx, DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_0BF@GFBPCGBG@body_?$CFd_bdry_?$CFd_meth?$AA@
	push	edx
	call	_sprintf

; 2860 :          apply_method(ee_id,name);

	mov	ecx, DWORD PTR _ee_id$91091[ebp]
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	push	ecx
	call	_apply_method
	mov	edx, DWORD PTR _web+236
	mov	ebx, DWORD PTR _dymem
	add	esp, 24					; 00000018H
$LN1@fixup_edge:

; 2861 :        }
; 2862 :       }
; 2863 :       f_id = inverse_id(f_id);
; 2864 :       ee_id = inverse_id(ee_id);

	xor	DWORD PTR _ee_id$91091[ebp], 134217728	; 08000000H
	xor	esi, 134217728				; 08000000H
	dec	DWORD PTR tv778[ebp]
	mov	DWORD PTR _f_id$91090[ebp], esi
	jne	$LL12@fixup_edge

; 2865 :     }
; 2866 :     fe = get_next_facet(fe);

	mov	eax, DWORD PTR _fe$[ebp]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	test	eax, 134217728				; 08000000H
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [eax+ecx*4]
	je	SHORT $LN91@fixup_edge
	mov	ecx, DWORD PTR [ecx+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN114@fixup_edge
$LN91@fixup_edge:
	mov	ecx, DWORD PTR [ecx+40]
$LN114@fixup_edge:
	mov	DWORD PTR _fe$[ebp], ecx

; 2867 :   } while ( !equal_id(fe,start_fe) );

	cmp	ecx, DWORD PTR _start_fe$[ebp]
	jne	$LL15@fixup_edge
$LN13@fixup_edge:

; 2868 : } /* end fixup_edge_content_meths() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fixup_edge_content_meths ENDP
_TEXT	ENDS
PUBLIC	_refine
; Function compile flags: /Ogtp
;	COMDAT _refine
_TEXT	SEGMENT
_refine	PROC						; COMDAT

; 26   :   #ifdef MPI_EVOLVER
; 27   :   mpi_refine();
; 28   :   #else
; 29   :   local_refine();

	jmp	_local_refine
_refine	ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_skinny
EXTRN	_K_altitude_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _skinny
_TEXT	SEGMENT
_sentinel$ = -116					; size = 4
_did_graphlock_here$89863 = -112			; size = 4
_weedcount$ = -108					; size = 4
tv851 = -104						; size = 8
tv849 = -104						; size = 8
_lambda$ = -104						; size = 8
_cosa$ = -104						; size = 8
_f_id$ = -96						; size = 4
_side$89869 = -92					; size = 48
_fe$89872 = -44						; size = 16
_sside$89870 = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_min_angle$ = 8						; size = 8
_skinny	PROC						; COMDAT

; 894  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 895  :   facet_id f_id;  /* facet being worked on */
; 896  :   facet_id sentinel;
; 897  :   int weedcount = 0; /* number of facets created */
; 898  :   REAL cosa;  // cosine of smallest angle
; 899  :   edge_id e_id;
; 900  :   REAL lambda; // foot of altibude bary coord
; 901  :   web.vol_flag = 0;
; 902  : 
; 903  :   /* first, unmark all NEWFACET attributes */
; 904  :   FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	push	ebx
	xor	eax, eax
	push	esi
	push	edi
	mov	DWORD PTR _weedcount$[ebp], eax
	mov	DWORD PTR _web+896, eax
	mov	DWORD PTR _f_id$[ebp], edx
	test	edx, 268435456				; 10000000H
	je	SHORT $LN68@skinny
	mov	edi, DWORD PTR _web+236
	lea	ebx, DWORD PTR [eax-5]
	npad	9
$LL22@skinny:
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN21@skinny

; 905  :       unset_attr(f_id,NEWFACET);

	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [ecx+12]
	and	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR _f_id$[ebp]
	mov	edi, DWORD PTR _web+236
$LN21@skinny:

; 895  :   facet_id f_id;  /* facet being worked on */
; 896  :   facet_id sentinel;
; 897  :   int weedcount = 0; /* number of facets created */
; 898  :   REAL cosa;  // cosine of smallest angle
; 899  :   edge_id e_id;
; 900  :   REAL lambda; // foot of altibude bary coord
; 901  :   web.vol_flag = 0;
; 902  : 
; 903  :   /* first, unmark all NEWFACET attributes */
; 904  :   FOR_ALL_FACETS(f_id)

	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _f_id$[ebp], edx
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL22@skinny
$LN68@skinny:

; 906  : 
; 907  :   ENTER_GRAPH_MUTEX;

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN17@skinny
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89863[ebp], 1
	jmp	SHORT $LN16@skinny
$LN17@skinny:
	mov	DWORD PTR _did_graphlock_here$89863[ebp], 0
$LN16@skinny:

; 908  : 
; 909  :   /* main loop sweeping over all triangles */
; 910  :   f_id = NULLFACET;

	mov	ecx, DWORD PTR _NULLFACET

; 911  :   while ( generate_all(FACET,&f_id,&sentinel) )

	lea	edx, DWORD PTR _sentinel$[ebp]
	push	edx
	lea	eax, DWORD PTR _f_id$[ebp]
	push	eax
	push	2
	mov	DWORD PTR _f_id$[ebp], ecx
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN14@skinny
$LL15@skinny:

; 912  :   { REAL side[MAXCOORD];  /* side vector */
; 913  :     REAL sside[FACET_EDGES]; /* squares of side lengths */
; 914  :     REAL angle;      /* area of triangle */
; 915  :     facetedge_id fe[FACET_EDGES+1]; /* edges of triangle, with wrap */
; 916  :     int i;              /* side number */
; 917  :     int smallside, mid, big;
; 918  :     REAL *tailx,*newx;
; 919  : 
; 920  :     /* skip already modified triangles */
; 921  :     if ( get_fattr(f_id) & NEWFACET )

	mov	esi, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 4
	xor	edx, edx
	or	eax, edx
	jne	$LN71@skinny

; 922  :          continue;
; 923  : 
; 924  :     /* find sides */
; 925  :     fe[0] = get_facet_fe(f_id);

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN38@skinny
	xor	ecx, ecx
	jmp	SHORT $LN37@skinny
$LN38@skinny:
	mov	ecx, DWORD PTR [ecx+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN37@skinny
	xor	ecx, 134217728				; 08000000H
$LN37@skinny:

; 926  :     for ( i = 0 ; i < FACET_EDGES ; i++ ) 

	mov	ebx, DWORD PTR _web+460
	mov	DWORD PTR _fe$89872[ebp], ecx
	xor	edi, edi
	npad	2
$LL69@skinny:

; 927  :     { get_fe_side(fe[i],side);

	mov	esi, DWORD PTR _fe$89872[ebp+edi*4]
	lea	eax, DWORD PTR _side$89869[ebp]
	push	eax
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+ecx*4]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	eax
	call	_get_edge_side

; 928  :       sside[i] = SDIM_dot(side,side);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _side$89869[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	fstp	QWORD PTR _sside$89870[ebp+edi*8]

; 929  :       fe[i+1] = get_next_edge(fe[i]);

	mov	ebx, DWORD PTR _web+460
	add	esp, 20					; 00000014H
	test	esi, 134217728				; 08000000H
	je	SHORT $LN44@skinny
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+esi*4]
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN43@skinny
$LN44@skinny:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+esi*4]
	mov	eax, DWORD PTR [edx+32]
$LN43@skinny:
	mov	DWORD PTR _fe$89872[ebp+edi*4+4], eax
	inc	edi
	cmp	edi, 3
	jl	SHORT $LL69@skinny

; 930  :     }
; 931  : 
; 932  :     /* find shortest side */
; 933  :     smallside = (sside[0] < sside[1]) ? 0 : 1;

	fld	QWORD PTR _sside$89870[ebp+8]
	fld	QWORD PTR _sside$89870[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN25@skinny
	xor	ecx, ecx
	jmp	SHORT $LN26@skinny
$LN25@skinny:
	mov	ecx, 1
$LN26@skinny:

; 934  :     smallside = (sside[smallside] < sside[2]) ? smallside : 2;

	fld	QWORD PTR _sside$89870[ebp+16]
	fcom	QWORD PTR _sside$89870[ebp+ecx*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN70@skinny
	mov	ecx, 2
$LN70@skinny:

; 935  :     /* find longest side */
; 936  :     big = (sside[0] > sside[1]) ? 0 : 1;

	fxch	ST(1)
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jne	SHORT $LN29@skinny
	xor	esi, esi
	jmp	SHORT $LN30@skinny
$LN29@skinny:
	mov	esi, 1
$LN30@skinny:

; 937  :     big = (sside[big] > sside[2]) ? big : 2;

	fcomp	QWORD PTR _sside$89870[ebp+esi*8]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN32@skinny
	mov	esi, 2
$LN32@skinny:

; 938  :     /* find middle side */
; 939  :     mid = 3 - (smallside+big);
; 940  : 	cosa = (sside[mid]+sside[big]-sside[smallside])/2/
; 941  :                              sqrt(sside[mid]*sside[big]) ;

	fld	QWORD PTR _sside$89870[ebp+esi*8]
	mov	edi, 3
	sub	edi, esi
	sub	edi, ecx
	fadd	QWORD PTR _sside$89870[ebp+edi*8]
	fsub	QWORD PTR _sside$89870[ebp+ecx*8]
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR tv849[ebp]
	fld	QWORD PTR _sside$89870[ebp+esi*8]
	fmul	QWORD PTR _sside$89870[ebp+edi*8]
	call	__CIsqrt
	fdivr	QWORD PTR tv849[ebp]
	fst	QWORD PTR _cosa$[ebp]

; 942  :     angle = acos(cosa);

	call	__CIacos

; 943  :     if ( angle > min_angle )  /* skip fat triangles */

	fcomp	QWORD PTR _min_angle$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN71@skinny

; 944  :          continue;
; 945  : 
; 946  :     e_id = get_fe_edge(fe[big]);

	mov	eax, DWORD PTR _fe$89872[ebp+esi*4]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]

; 947  :     if ( K_altitude_flag )

	cmp	DWORD PTR _K_altitude_flag, 0
	mov	ebx, eax
	je	SHORT $LN8@skinny

; 948  :     {
; 949  :    	  // Calculate foot of altitude     
; 950  : 	  lambda = sqrt(sside[mid])*cosa/sqrt(sside[big]);

	fld	QWORD PTR _sside$89870[ebp+edi*8]
	call	__CIsqrt
	fmul	QWORD PTR _cosa$[ebp]
	fstp	QWORD PTR tv851[ebp]
	fld	QWORD PTR _sside$89870[ebp+esi*8]
	call	__CIsqrt
	fdivr	QWORD PTR tv851[ebp]

; 951  : 	  if ( (mid==big+1 || mid==big-2) == !inverted(e_id) )

	lea	eax, DWORD PTR [esi+1]
	fst	QWORD PTR _lambda$[ebp]
	cmp	edi, eax
	je	SHORT $LN33@skinny
	add	esi, -2					; fffffffeH
	cmp	edi, esi
	je	SHORT $LN33@skinny
	xor	eax, eax
	jmp	SHORT $LN34@skinny
$LN33@skinny:
	mov	eax, 1
$LN34@skinny:
	mov	ecx, ebx
	shr	ecx, 27					; 0000001bH
	not	ecx
	and	ecx, 1
	cmp	eax, ecx
	jne	SHORT $LN90@skinny

; 952  :         lambda = 1-lambda;

	fld1
	fsubrp	ST(1), ST(0)
	fstp	QWORD PTR _lambda$[ebp]

; 953  :     }
; 954  :     else

	jmp	SHORT $LN6@skinny
$LN8@skinny:

; 955  :       lambda = 0.5;

	fld	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR _lambda$[ebp]
	jmp	SHORT $LN6@skinny
$LN90@skinny:
	fstp	ST(0)
$LN6@skinny:

; 956  :     get_edge_side(e_id,side);

	lea	edx, DWORD PTR _side$89869[ebp]
	push	edx
	push	ebx
	call	_get_edge_side
	add	esp, 8

; 957  : 	tailx = get_coord(get_edge_tailv(e_id));

	test	ebx, 134217728				; 08000000H
	je	SHORT $LN50@skinny
	mov	ecx, DWORD PTR _web+124
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN49@skinny
$LN50@skinny:
	mov	edx, DWORD PTR _web+124
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ecx+304]
	mov	eax, DWORD PTR [eax+edx]
$LN49@skinny:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	edi, DWORD PTR [eax+ecx+64]

; 958  : 
; 959  :     edge_refine(positive_id(e_id));

	mov	esi, ebx
	and	esi, -134217729				; f7ffffffH
	push	esi
	call	_edge_refine

; 960  : 
; 961  :     // Move division vertex to foot of altitude
; 962  : 	newx = get_coord(get_edge_headv(positive_id(e_id)));

	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR _web+216
	add	esp, 4
	test	esi, 134217728				; 08000000H
	je	SHORT $LN54@skinny
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]
	jmp	SHORT $LN53@skinny
$LN54@skinny:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
$LN53@skinny:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+ecx+64]

; 963  : 	for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN3@skinny
	fld	QWORD PTR _lambda$[ebp]
	lea	esi, DWORD PTR _side$89869[ebp]
	sub	esi, edi
	mov	eax, edi
	sub	edx, edi
$LN5@skinny:

; 964  : 	   newx[i] = tailx[i] + lambda*side[i];

	fld	QWORD PTR [eax+esi]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [edx+eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN5@skinny

; 963  : 	for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN3@skinny:

; 965  : 
; 966  :     
; 967  : 
; 968  :     weedcount++;

	inc	DWORD PTR _weedcount$[ebp]
$LN71@skinny:

; 911  :   while ( generate_all(FACET,&f_id,&sentinel) )

	lea	ecx, DWORD PTR _sentinel$[ebp]
	push	ecx
	lea	edx, DWORD PTR _f_id$[ebp]
	push	edx
	push	2
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LL15@skinny
$LN14@skinny:

; 969  : 
; 970  :   }  /* end main sweep loop */
; 971  : 
; 972  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89863[ebp], 0
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN2@skinny
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN2@skinny:

; 973  : 
; 974  :   if ( weedcount > 0 ) top_timestamp = ++global_timestamp;

	mov	ecx, DWORD PTR _weedcount$[ebp]
	test	ecx, ecx
	jle	SHORT $LN67@skinny
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN67@skinny:

; 975  :   return weedcount;

	mov	eax, ecx

; 976  : } // end skinny()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_skinny	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FA@PFANEEBK@Can?8t?5delete?5edge?5?$CFs?5due?5to?5conf@ ; `string'
PUBLIC	??_C@_0DE@PFLGPGEF@Edge?5amenity?5failed?5second?5time?5@ ; `string'
PUBLIC	??_C@_0EH@DAGLDMDM@Edge?5?$CFs?5not?5deleted?5due?5to?5adjac@ ; `string'
PUBLIC	??_C@_0CN@CGONHFJB@Internal?5error?3?5Bad?5edge?5loop?5on@ ; `string'
PUBLIC	??_C@_0BC@GCCMJCEH@Deleting?5edge?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0EP@HFOOEEPN@Risky?5configuration?0?5but?5proceed@ ; `string'
PUBLIC	??_C@_0FB@OMDNIJNH@Not?5deleting?5edge?5due?5to?5multipl@ ; `string'
PUBLIC	??_C@_0CK@DNIEOAEI@Not?5deleting?5edge?5?$CFs?5due?5to?5axia@ ; `string'
PUBLIC	??_C@_0EI@NLIMAAGI@Can?8t?5delete?5edge?5?$CFs?5due?5to?5cons@ ; `string'
PUBLIC	??_C@_0CJ@GFKOCDCK@Not?5deleting?5edge?5?$CFs?5since?5it?5is@ ; `string'
PUBLIC	??_C@_0CJ@LDODGOLA@No?5delete_edge?$CI?$CJ?5in?5Lagrange?5mod@ ; `string'
PUBLIC	??_C@_0CJ@HLDCMKCA@Cannot?5eliminate?5edge?5in?5simplex@ ; `string'
PUBLIC	_delete_edge
EXTRN	_basic_gen_methods:BYTE
EXTRN	_set_e_phase_density:PROC
EXTRN	_phase_flag:DWORD
EXTRN	_unstar:PROC
EXTRN	_get_edge_valence:PROC
EXTRN	_wrap_vertex:PROC
EXTRN	_torus_unwrap_edge:PROC
EXTRN	_force_deletion:DWORD
EXTRN	_star_finagle:PROC
EXTRN	_star_finagling:DWORD
EXTRN	_simple_unstar:PROC
EXTRN	_errmsg:BYTE
EXTRN	_compare_edge_facet_attr:PROC
EXTRN	_compare_edge_attr:PROC
EXTRN	_compare_vertex_attr:PROC
EXTRN	_compare_vertex_edge_attr:PROC
EXTRN	_unfree_element:PROC
;	COMDAT ??_C@_0FA@PFANEEBK@Can?8t?5delete?5edge?5?$CFs?5due?5to?5conf@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0FA@PFANEEBK@Can?8t?5delete?5edge?5?$CFs?5due?5to?5conf@ DB 'Can''t'
	DB	' delete edge %s due to conflicting constraints, boundaries, o'
	DB	'r fixedness.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PFLGPGEF@Edge?5amenity?5failed?5second?5time?5@
CONST	SEGMENT
??_C@_0DE@PFLGPGEF@Edge?5amenity?5failed?5second?5time?5@ DB 'Edge amenit'
	DB	'y failed second time through on edge %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@DAGLDMDM@Edge?5?$CFs?5not?5deleted?5due?5to?5adjac@
CONST	SEGMENT
??_C@_0EH@DAGLDMDM@Edge?5?$CFs?5not?5deleted?5due?5to?5adjac@ DB 'Edge %s'
	DB	' not deleted due to adjacent configuration involving facet %s'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CGONHFJB@Internal?5error?3?5Bad?5edge?5loop?5on@
CONST	SEGMENT
??_C@_0CN@CGONHFJB@Internal?5error?3?5Bad?5edge?5loop?5on@ DB 'Internal e'
	DB	'rror: Bad edge loop on vertex %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GCCMJCEH@Deleting?5edge?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BC@GCCMJCEH@Deleting?5edge?5?$CFs?6?$AA@ DB 'Deleting edge %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@HFOOEEPN@Risky?5configuration?0?5but?5proceed@
CONST	SEGMENT
??_C@_0EP@HFOOEEPN@Risky?5configuration?0?5but?5proceed@ DB 'Risky config'
	DB	'uration, but proceeding with deletion since force_deletion is'
	DB	' on.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@OMDNIJNH@Not?5deleting?5edge?5due?5to?5multipl@
CONST	SEGMENT
??_C@_0FB@OMDNIJNH@Not?5deleting?5edge?5due?5to?5multipl@ DB 'Not deletin'
	DB	'g edge due to multiple edges between endpoints with different'
	DB	' wraps.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DNIEOAEI@Not?5deleting?5edge?5?$CFs?5due?5to?5axia@
CONST	SEGMENT
??_C@_0CK@DNIEOAEI@Not?5deleting?5edge?5?$CFs?5due?5to?5axia@ DB 'Not del'
	DB	'eting edge %s due to axial point.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@NLIMAAGI@Can?8t?5delete?5edge?5?$CFs?5due?5to?5cons@
CONST	SEGMENT
??_C@_0EI@NLIMAAGI@Can?8t?5delete?5edge?5?$CFs?5due?5to?5cons@ DB 'Can''t'
	DB	' delete edge %s due to constraints or methods on edges %s and'
	DB	' %s.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GFKOCDCK@Not?5deleting?5edge?5?$CFs?5since?5it?5is@
CONST	SEGMENT
??_C@_0CJ@GFKOCDCK@Not?5deleting?5edge?5?$CFs?5since?5it?5is@ DB 'Not del'
	DB	'eting edge %s since it is FIXED.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@LDODGOLA@No?5delete_edge?$CI?$CJ?5in?5Lagrange?5mod@
CONST	SEGMENT
??_C@_0CJ@LDODGOLA@No?5delete_edge?$CI?$CJ?5in?5Lagrange?5mod@ DB 'No del'
	DB	'ete_edge() in Lagrange model yet.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HLDCMKCA@Cannot?5eliminate?5edge?5in?5simplex@
CONST	SEGMENT
??_C@_0CJ@HLDCMKCA@Cannot?5eliminate?5edge?5in?5simplex@ DB 'Cannot elimi'
	DB	'nate edge in simplex model.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\trirevis.c
CONST	ENDS
;	COMDAT _delete_edge
_TEXT	SEGMENT
_start_e$90349 = -92					; size = 4
_first_fe$ = -92					; size = 4
tv2816 = -88						; size = 4
tv3057 = -84						; size = 4
_eb_ptr$90296 = -80					; size = 4
_e_id$93220 = -76					; size = 4
_did_graphlock_here$90132 = -76				; size = 4
_f_id$90085 = -76					; size = 4
tv3129 = -72						; size = 4
tv3058 = -72						; size = 4
tv2976 = -72						; size = 4
tv2893 = -72						; size = 4
tv2761 = -72						; size = 4
_ffe$90151 = -72					; size = 4
tv2718 = -68						; size = 4
_third_v$90196 = -68					; size = 4
tv2819 = -64						; size = 4
tv2627 = -64						; size = 4
_nn$90174 = -64						; size = 4
_bad_flag$90114 = -64					; size = 4
_facet$90225 = -60					; size = 4
_b_id$ = -60						; size = 4
_tail_edge_comp$ = -60					; size = 4
tv3152 = -56						; size = 4
tv3072 = -56						; size = 4
_i$90305 = -56						; size = 4
_flag$90228 = -56					; size = 4
_tail_head_comp$ = -56					; size = 4
tv2721 = -52						; size = 4
_throw_edge$90227 = -52					; size = 4
_head_edge_comp$ = -52					; size = 4
_a_edge$90223 = -48					; size = 4
_fe_b$90080 = -48					; size = 4
_tailv$ = -48						; size = 4
_j$90306 = -44						; size = 4
_b_prev$90221 = -44					; size = 4
_fe_a$90079 = -44					; size = 4
_b$90217 = -40						; size = 4
_fe$90073 = -40						; size = 4
_a$90216 = -36						; size = 4
_edge_tail_same$ = -36					; size = 4
_ameths$90299 = -32					; size = 4
_rprev$90267 = -32					; size = 4
_a_prev$90219 = -32					; size = 4
_keep_v$ = -28						; size = 4
_b_edge$90224 = -24					; size = 4
_edge_head_same$ = -24					; size = 4
tv3241 = -20						; size = 4
_ff_id$90265 = -20					; size = 4
_b_next$90220 = -20					; size = 4
_base_fe$ = -16						; size = 4
_bmeths$90302 = -12					; size = 4
_rfe$90261 = -12					; size = 4
_a_next$90218 = -12					; size = 4
_elim_v$ = -8						; size = 4
_keep_edge$90226 = -4					; size = 4
_short_edge$ = 8					; size = 4
_delete_edge PROC					; COMDAT

; 1169 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	esi

; 1170 :   facetedge_id base_fe;  /* along edge to be eliminated */
; 1171 :   vertex_id headv,tailv;
; 1172 :   vertex_id elim_v;  /* vertex to eliminate */
; 1173 :   vertex_id keep_v;  /* vertex to keep */
; 1174 :   int edge_head_same,edge_tail_same;  /* whether same constraints and stuff */
; 1175 :   int head_edge_comp,tail_edge_comp,tail_head_comp;
; 1176 :   body_id b_id;
; 1177 :   facet_id f_id;
; 1178 :   facetedge_id first_fe;
; 1179 :   int retval = 0;
; 1180 : 
; 1181 :   if ( web.representation == SIMPLEX )

	mov	esi, 3
	push	edi
	cmp	DWORD PTR _web+624, esi
	jne	SHORT $LN152@delete_edg

; 1182 :      kb_error(1341,"Cannot eliminate edge in simplex model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CJ@HLDCMKCA@Cannot?5eliminate?5edge?5in?5simplex@
	push	1341					; 0000053dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN152@delete_edg:

; 1183 : 
; 1184 :   if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, esi
	jne	SHORT $LN151@delete_edg

; 1185 :      kb_error(1342,"No delete_edge() in Lagrange model yet.\n",RECOVERABLE );

	push	1
	push	OFFSET ??_C@_0CJ@LDODGOLA@No?5delete_edge?$CI?$CJ?5in?5Lagrange?5mod@
	push	1342					; 0000053eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN151@delete_edg:

; 1186 : 
; 1187 :   if ( !valid_element(short_edge) ) return 0;

	mov	edi, DWORD PTR _short_edge$[ebp]
	push	edi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	je	SHORT $LN148@delete_edg

; 1188 :   if ( get_eattr(short_edge) & FIXED )

	mov	eax, DWORD PTR _web+124
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv2627[ebp], ecx
	je	SHORT $LN149@delete_edg

; 1189 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, edx
	je	SHORT $LN148@delete_edg

; 1190 :     { sprintf(msg,"Not deleting edge %s since it is FIXED.\n",
; 1191 :         ELNAME(short_edge));

	test	edi, 268435456				; 10000000H
	je	SHORT $LN155@delete_edg
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN156@delete_edg
$LN155@delete_edg:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN156@delete_edg:
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0CJ@GFKOCDCK@Not?5deleting?5edge?5?$CFs?5since?5it?5is@
	push	ecx
	call	_sprintf

; 1192 :       outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN148@delete_edg:

; 1193 :     }
; 1194 :     return 0;

	pop	edi
	xor	eax, eax
	pop	esi

; 1744 : } /* end delete_edge() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN149@delete_edg:
	push	ebx

; 1195 :   }
; 1196 :   web.vol_flag = 0;
; 1197 : 
; 1198 :   headv = get_edge_headv(short_edge);

	push	edi
	mov	DWORD PTR _web+896, edx
	call	_get_edge_headv

; 1199 :   tailv = get_edge_tailv(short_edge);

	push	edi
	mov	esi, eax
	call	_get_edge_tailv
	mov	ebx, eax

; 1200 : 
; 1201 :   /* kludge to overcome problem with change_vertex not finding
; 1202 :       all edges linked to vertex */
; 1203 :   if ( !valid_element(headv) ) 

	push	esi
	mov	DWORD PTR _tailv$[ebp], ebx
	call	_valid_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN147@delete_edg

; 1204 :      unfree_element(headv);

	push	esi
	call	_unfree_element
	add	esp, 4
$LN147@delete_edg:

; 1205 :   if ( !valid_element(tailv) ) 

	push	ebx
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN146@delete_edg

; 1206 :      unfree_element(tailv);

	push	ebx
	call	_unfree_element
	add	esp, 4
$LN146@delete_edg:

; 1207 : 
; 1208 :   /* Figure out which vertex to eliminate.  Keep fixed vertices. */
; 1209 : 
; 1210 :   head_edge_comp = compare_vertex_edge_attr(headv,short_edge); 

	push	edi
	push	esi
	call	_compare_vertex_edge_attr

; 1211 :   tail_edge_comp = compare_vertex_edge_attr(tailv,short_edge); 

	push	edi
	push	ebx
	mov	DWORD PTR _head_edge_comp$[ebp], eax
	call	_compare_vertex_edge_attr

; 1212 :   tail_head_comp = compare_vertex_attr(tailv,headv);

	push	esi
	push	ebx
	mov	DWORD PTR _tail_edge_comp$[ebp], eax
	call	_compare_vertex_attr

; 1213 :   edge_head_same =  ((head_edge_comp==A_SUB_B) || (head_edge_comp==A_EQ_B)) && 
; 1214 :                           !(get_vattr(headv) & FIXED); 

	mov	edx, DWORD PTR _web+12
	add	esp, 24					; 00000018H
	cmp	DWORD PTR _head_edge_comp$[ebp], 1
	mov	DWORD PTR _tail_head_comp$[ebp], eax
	je	SHORT $LN157@delete_edg
	cmp	DWORD PTR _head_edge_comp$[ebp], 2
	jne	SHORT $LN403@delete_edg
$LN157@delete_edg:
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN403@delete_edg
	lea	edi, DWORD PTR [eax+1]
	jmp	SHORT $LN421@delete_edg
$LN403@delete_edg:
	xor	edi, edi
$LN421@delete_edg:

; 1215 :   edge_tail_same =  ((tail_edge_comp==A_SUB_B) || (tail_edge_comp==A_EQ_B)) &&
; 1216 :                           !(get_vattr(tailv) & FIXED);

	mov	eax, DWORD PTR _tail_edge_comp$[ebp]
	mov	DWORD PTR _edge_head_same$[ebp], edi
	cmp	eax, 1
	je	SHORT $LN160@delete_edg
	cmp	eax, 2
	jne	SHORT $LN161@delete_edg
$LN160@delete_edg:
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	mov	DWORD PTR _edge_tail_same$[ebp], 1
	je	SHORT $LN162@delete_edg
$LN161@delete_edg:
	mov	DWORD PTR _edge_tail_same$[ebp], 0
$LN162@delete_edg:

; 1217 :   if ( ( edge_head_same || 
; 1218 :          ((head_edge_comp == A_EQ_B || head_edge_comp == A_SUPER_B) &&
; 1219 :          (tail_head_comp == A_EQ_B || tail_head_comp == A_SUPER_B)) 
; 1220 :        ) 
; 1221 :      && 
; 1222 :         (get_boundary(headv) == get_edge_boundary(short_edge)) 
; 1223 :      &&   !( get_vattr(headv) & (FIXED|AXIAL_POINT)) )

	mov	ebx, DWORD PTR _web+776
	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	edi, edi
	mov	edi, DWORD PTR _V_BOUNDARY_ATTR
	jne	SHORT $LN142@delete_edg
	mov	ecx, DWORD PTR _head_edge_comp$[ebp]
	cmp	ecx, 2
	je	SHORT $LN400@delete_edg
	cmp	ecx, 3
	jne	$LN145@delete_edg
$LN400@delete_edg:
	mov	ecx, DWORD PTR _tail_head_comp$[ebp]
	cmp	ecx, 2
	je	SHORT $LN142@delete_edg
	cmp	ecx, 3
	jne	$LN145@delete_edg
$LN142@delete_edg:
	test	edi, edi
	je	SHORT $LN163@delete_edg
	mov	ebx, DWORD PTR _web+12
	mov	edx, edi
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ebx+64]
	mov	edx, DWORD PTR [ecx+edx]
	mov	ebx, DWORD PTR _web+776
	imul	edx, 136				; 00000088H
	add	edx, ebx
	jmp	SHORT $LN164@delete_edg
$LN163@delete_edg:
	xor	edx, edx
$LN164@delete_edg:
	test	eax, eax
	je	SHORT $LN165@delete_edg
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	ebx, DWORD PTR tv2627[ebp]
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ecx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	ebx, DWORD PTR _web+776
	imul	ecx, 136				; 00000088H
	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	add	ecx, ebx
	jmp	SHORT $LN166@delete_edg
$LN165@delete_edg:
	xor	ecx, ecx
$LN166@delete_edg:
	cmp	edx, ecx
	jne	SHORT $LN145@delete_edg
	mov	edx, DWORD PTR _web+12
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR [esi+8]
	and	ecx, 8388672				; 00800040H
	xor	edx, edx
	or	ecx, edx
	je	$LN136@delete_edg
$LN145@delete_edg:

; 1224 :   { /* short_edge ok */
; 1225 :   }
; 1226 :   else 
; 1227 :   if ( ( edge_tail_same ||
; 1228 :          ((tail_edge_comp == A_EQ_B || tail_edge_comp == A_SUPER_B) &&
; 1229 :          (tail_head_comp == A_EQ_B || tail_head_comp == A_SUB_B))  
; 1230 :         ) 
; 1231 :      &&
; 1232 :        (get_boundary(tailv) == get_edge_boundary(short_edge) ) 
; 1233 :      &&   !( get_vattr(tailv) & (FIXED|AXIAL_POINT)) )

	cmp	DWORD PTR _edge_tail_same$[ebp], 0
	jne	SHORT $LN137@delete_edg
	mov	ecx, DWORD PTR _tail_edge_comp$[ebp]
	cmp	ecx, 2
	je	SHORT $LN138@delete_edg
	cmp	ecx, 3
	jne	$LN140@delete_edg
$LN138@delete_edg:
	mov	ecx, DWORD PTR _tail_head_comp$[ebp]
	cmp	ecx, 2
	je	SHORT $LN137@delete_edg
	cmp	ecx, 1
	jne	$LN140@delete_edg
$LN137@delete_edg:
	test	edi, edi
	je	SHORT $LN167@delete_edg
	mov	ecx, DWORD PTR _tailv$[ebp]
	imul	edi, 240				; 000000f0H
	mov	edx, DWORD PTR _web+12
	add	edi, DWORD PTR _web+104
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edi+edx+64]
	mov	ecx, DWORD PTR [ecx+edx]
	imul	ecx, 136				; 00000088H
	add	ecx, ebx
	jmp	SHORT $LN168@delete_edg
$LN167@delete_edg:
	xor	ecx, ecx
$LN168@delete_edg:
	test	eax, eax
	je	SHORT $LN169@delete_edg
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	esi, DWORD PTR tv2627[ebp]
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edx, DWORD PTR _web+124
	mov	edx, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [eax+edx]
	imul	eax, 136				; 00000088H
	add	eax, ebx
	jmp	SHORT $LN170@delete_edg
$LN169@delete_edg:
	xor	eax, eax
$LN170@delete_edg:
	cmp	ecx, eax
	jne	$LN140@delete_edg
	mov	eax, DWORD PTR _tailv$[ebp]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388672				; 00800040H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN140@delete_edg

; 1234 : 
; 1235 :   { short_edge = edge_inverse(short_edge);

	xor	DWORD PTR _short_edge$[ebp], 134217728	; 08000000H
$LN136@delete_edg:

; 1243 :   }
; 1244 : 
; 1245 :   /* check edges that would be merged */
; 1246 :   if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	jne	$LN382@delete_edg

; 1247 :   { facetedge_id fe;
; 1248 :     base_fe = get_edge_fe(short_edge);

	mov	edx, DWORD PTR _short_edge$[ebp]
	push	edx
	call	_get_edge_fe
	add	esp, 4
	mov	DWORD PTR _base_fe$[ebp], eax

; 1249 :     fe = base_fe;

	mov	DWORD PTR _fe$90073[ebp], eax

; 1250 :     if ( valid_id(base_fe) )

	test	eax, 268435456				; 10000000H
	je	$LN382@delete_edg
	mov	ecx, DWORD PTR _web+460
	npad	1
$LL132@delete_edg:

; 1251 :     for (;;)
; 1252 :     { facetedge_id fe_a = get_prev_edge(fe);

	mov	esi, DWORD PTR _fe$90073[ebp]
	mov	edi, esi
	shr	edi, 27					; 0000001bH
	and	edi, 1
	mov	DWORD PTR tv2718[ebp], edi
	mov	eax, esi
	je	SHORT $LN192@delete_edg
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2721[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [eax+32]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN422@delete_edg
$LN192@delete_edg:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2721[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [eax+28]
$LN422@delete_edg:
	mov	DWORD PTR _fe_a$90079[ebp], edx

; 1253 :       facetedge_id fe_b = get_next_edge(fe);

	test	edi, edi
	je	SHORT $LN196@delete_edg
	mov	edx, DWORD PTR [eax+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN423@delete_edg
$LN196@delete_edg:
	mov	edx, DWORD PTR [eax+32]
$LN423@delete_edg:
	mov	DWORD PTR _fe_b$90080[ebp], edx

; 1254 :       if ( valid_id(get_fe_facet(fe)) )

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN200@delete_edg
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN199@delete_edg
$LN200@delete_edg:
	mov	eax, DWORD PTR [eax+24]
	test	edi, edi
	je	SHORT $LN199@delete_edg
	xor	eax, 134217728				; 08000000H
$LN199@delete_edg:
	test	eax, 268435456				; 10000000H
	je	$LN128@delete_edg

; 1255 :       { int abcomp = compare_edge_attr(get_fe_edge(fe_a),get_fe_edge(fe_b));

	mov	ebx, DWORD PTR _fe_b$90080[ebp]
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	edx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _fe_a$90079[ebp]
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	mov	DWORD PTR _e_id$93220[ebp], edx
	add	edi, edi
	and	ebx, 134217728				; 08000000H
	add	edi, edi
	mov	ecx, DWORD PTR [edi+ecx]
	mov	ecx, DWORD PTR [ecx+20]
	and	eax, 134217728				; 08000000H
	mov	edx, ebx
	xor	edx, DWORD PTR _e_id$93220[ebp]
	mov	DWORD PTR tv2761[ebp], eax
	push	edx
	xor	eax, ecx
	push	eax
	call	_compare_edge_attr
	add	esp, 8

; 1256 :         if ( abcomp == INCOMPARABLE)

	test	eax, eax
	jne	SHORT $LN381@delete_edg

; 1257 :         { facet_id f_id = get_fe_facet(fe);

	mov	eax, DWORD PTR _fe$90073[ebp]
	push	eax
	call	_get_fe_facet

; 1258 :           int acomp = compare_edge_facet_attr(get_fe_edge(fe_a),f_id);

	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [edi+ecx]
	push	eax
	mov	DWORD PTR _f_id$90085[ebp], eax
	mov	eax, DWORD PTR tv2761[ebp]
	xor	eax, DWORD PTR [edx+20]
	push	eax
	call	_compare_edge_facet_attr

; 1259 :           int bcomp = compare_edge_facet_attr(get_fe_edge(fe_b),f_id);

	mov	edx, DWORD PTR _f_id$90085[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [esi+eax]
	xor	ebx, DWORD PTR [ecx+20]
	push	edx
	push	ebx
	call	_compare_edge_facet_attr
	add	esp, 20					; 00000014H

; 1260 :           if ( !(acomp==A_SUB_B || acomp==A_EQ_B || bcomp==A_SUB_B || bcomp==A_EQ_B) )

	cmp	edi, 1
	je	SHORT $LN381@delete_edg
	cmp	edi, 2
	je	SHORT $LN381@delete_edg
	cmp	eax, 1
	je	SHORT $LN381@delete_edg
	cmp	eax, 2
	jne	$LN344@delete_edg
$LN381@delete_edg:
	mov	ecx, DWORD PTR _web+460
$LN128@delete_edg:

; 1265 :             }
; 1266 :             return 0; 
; 1267 :           }
; 1268 :         }
; 1269 :       }
; 1270 :       fe = get_next_facet(fe);

	cmp	DWORD PTR tv2718[ebp], 0
	mov	eax, DWORD PTR tv2721[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	je	SHORT $LN212@delete_edg
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN424@delete_edg
$LN212@delete_edg:
	mov	eax, DWORD PTR [edx+40]
$LN424@delete_edg:
	mov	DWORD PTR _fe$90073[ebp], eax

; 1271 :       if ( equal_id(fe,base_fe) ) break;

	cmp	eax, DWORD PTR _base_fe$[ebp]
	jne	$LL132@delete_edg
$LN382@delete_edg:

; 1272 :     }
; 1273 :   }
; 1274 : 
; 1275 :   elim_v = get_edge_headv(short_edge);

	mov	ebx, DWORD PTR _short_edge$[ebp]
	push	ebx
	call	_get_edge_headv

; 1276 :   keep_v = get_edge_tailv(short_edge);

	push	ebx
	mov	DWORD PTR _elim_v$[ebp], eax
	call	_get_edge_tailv

; 1277 : 
; 1278 :   if ( get_vattr(keep_v) & AXIAL_POINT )

	mov	edx, DWORD PTR _web+12
	mov	DWORD PTR _keep_v$[ebp], eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	ecx, ecx
	add	esp, 8
	or	eax, ecx
	je	$LN125@delete_edg

; 1279 :   {  sprintf(errmsg,"Not deleting edge %s due to axial point.\n",
; 1280 :          ELNAME(short_edge));

	test	ebx, 268435456				; 10000000H
	je	$LN179@delete_edg
	and	ebx, 134217727				; 07ffffffH
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	$LN180@delete_edg
$LN344@delete_edg:

; 1261 :           { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN135@delete_edg

; 1262 :             { sprintf(msg,
; 1263 :              "Can't delete edge %s due to constraints or methods on edges %s and %s.\n",ELNAME(short_edge),ELNAME1(get_fe_edge(fe_a)),ELNAME2(get_fe_edge(fe_b)));

	mov	esi, DWORD PTR _fe_b$90080[ebp]
	push	esi
	call	_get_fe_edge
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN173@delete_edg
	push	esi
	call	_get_fe_edge
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 16					; 00000010H
	mov	edi, OFFSET _elnames+60
	jmp	SHORT $LN174@delete_edg
$LN173@delete_edg:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN174@delete_edg:
	mov	esi, DWORD PTR _fe_a$90079[ebp]
	push	esi
	call	_get_fe_edge
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN175@delete_edg
	push	esi
	call	_get_fe_edge
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 16					; 00000010H
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN176@delete_edg
$LN175@delete_edg:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN176@delete_edg:
	mov	eax, DWORD PTR _short_edge$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN177@delete_edg
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN178@delete_edg
$LN177@delete_edg:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN178@delete_edg:
	push	edi
	push	esi
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0EI@NLIMAAGI@Can?8t?5delete?5edge?5?$CFs?5due?5to?5cons@
	push	eax
	call	_sprintf

; 1264 :                outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 24					; 00000018H
	pop	ebx
	pop	edi
	xor	eax, eax
	pop	esi

; 1744 : } /* end delete_edge() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN179@delete_edg:

; 1279 :   {  sprintf(errmsg,"Not deleting edge %s due to axial point.\n",
; 1280 :          ELNAME(short_edge));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN180@delete_edg:
	push	eax
	push	OFFSET ??_C@_0CK@DNIEOAEI@Not?5deleting?5edge?5?$CFs?5due?5to?5axia@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1281 :   /*    kb_error(2197,errmsg,WARNING);  john doesn't like warning */
; 1282 :      if ( verbose_flag ) outstring(errmsg);

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN135@delete_edg
	push	OFFSET _errmsg
	call	_outstring
	add	esp, 4
	pop	ebx
	pop	edi
	xor	eax, eax
	pop	esi

; 1744 : } /* end delete_edge() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN125@delete_edg:

; 1283 :      return 0;
; 1284 :   }
; 1285 : 
; 1286 :   /* check for multiple edges between endpoints */
; 1287 :   if ( web.symmetry_flag && (web.representation == SOAPFILM) )

	cmp	DWORD PTR _web+856, ecx
	je	SHORT $LN120@delete_edg
	cmp	DWORD PTR _web+624, 2
	jne	$LN396@delete_edg

; 1288 :   { edge_id e_id = short_edge;
; 1289 :     e_id = get_next_tail_edge(e_id);

	push	ebx
	call	_get_next_tail_edge
	add	esp, 4
	mov	esi, eax
$LL122@delete_edg:

; 1290 :     do
; 1291 :     { if ( equal_id(get_edge_headv(e_id) ,elim_v) 
; 1292 :           && (get_edge_wrap(e_id) != get_edge_wrap(short_edge)) )

	push	esi
	call	_get_edge_headv
	add	esp, 4
	cmp	eax, DWORD PTR _elim_v$[ebp]
	jne	SHORT $LN402@delete_edg
	push	esi
	call	_get_edge_wrap
	push	ebx
	mov	edi, eax
	call	_get_edge_wrap
	add	esp, 8
	cmp	edi, eax
	jne	$LN346@delete_edg
$LN402@delete_edg:

; 1295 :         return 0;  
; 1296 :       }
; 1297 :        e_id = get_next_tail_edge(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	eax, esi
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	esi, DWORD PTR [edx+eax*4+32]

; 1298 :     }
; 1299 :     while ( !equal_id(short_edge,e_id) );

	cmp	ebx, esi
	jne	SHORT $LL122@delete_edg
$LN120@delete_edg:

; 1300 :   }
; 1301 : 
; 1302 :   /* Go through facets around edge,  checking for stars (adjacent
; 1303 :      triangulated triangle) and unstarring if found.              */
; 1304 :   if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	jne	$LN396@delete_edg

; 1305 :   { int bad_flag = 0;
; 1306 :   
; 1307 :     base_fe = first_fe = get_edge_fe(short_edge);

	push	ebx
	mov	DWORD PTR _bad_flag$90114[ebp], 0
	call	_get_edge_fe
	mov	edi, eax
	add	esp, 4
	mov	esi, edi

; 1308 :     while ( valid_id(base_fe) )

	test	edi, 268435456				; 10000000H
	je	SHORT $LN395@delete_edg
$LL116@delete_edg:

; 1309 :     {
; 1310 :       if ( simple_unstar(base_fe) < 0 )

	push	esi
	call	_simple_unstar
	add	esp, 4
	test	eax, eax
	jns	SHORT $LN114@delete_edg

; 1311 :         bad_flag = 1;

	mov	DWORD PTR _bad_flag$90114[ebp], 1
$LN114@delete_edg:

; 1312 : 
; 1313 :       base_fe = get_next_facet(base_fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN218@delete_edg
	mov	eax, DWORD PTR _web+460
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN217@delete_edg
$LN346@delete_edg:

; 1293 :       { if ( verbose_flag ) outstring(

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN135@delete_edg

; 1294 :                 "Not deleting edge due to multiple edges between endpoints with different wraps.\n");

	push	OFFSET ??_C@_0FB@OMDNIJNH@Not?5deleting?5edge?5due?5to?5multipl@
	call	_outstring
	add	esp, 4
	pop	ebx
	pop	edi
	xor	eax, eax
	pop	esi

; 1744 : } /* end delete_edge() */

	mov	esp, ebp
	pop	ebp
	ret	0

; 1312 : 
; 1313 :       base_fe = get_next_facet(base_fe);

$LN218@delete_edg:
	mov	edx, DWORD PTR _web+460
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [eax+40]
$LN217@delete_edg:

; 1314 :       if ( equal_id(base_fe,first_fe) ) base_fe = NULLID;

	cmp	esi, edi
	jne	SHORT $LN113@delete_edg
	xor	esi, esi
$LN113@delete_edg:

; 1308 :     while ( valid_id(base_fe) )

	test	esi, 268435456				; 10000000H
	jne	SHORT $LL116@delete_edg
$LN395@delete_edg:

; 1315 :     } /* end base_fe loop */
; 1316 :     
; 1317 :     /* extra checks for bad configurations */
; 1318 :     if ( star_finagling )

	cmp	DWORD PTR _star_finagling, 0
	je	SHORT $LN111@delete_edg

; 1319 :       if( star_finagle(short_edge) < 0 )

	push	ebx
	call	_star_finagle
	add	esp, 4
	test	eax, eax
	js	SHORT $LN361@delete_edg
$LN111@delete_edg:

; 1320 :         bad_flag = 1;
; 1321 : 
; 1322 :     if ( bad_flag )

	cmp	DWORD PTR _bad_flag$90114[ebp], 0
	je	SHORT $LN396@delete_edg
$LN361@delete_edg:

; 1323 :     { if ( force_deletion )

	cmp	DWORD PTR _force_deletion, 0
	je	$LN135@delete_edg

; 1324 :       { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN106@delete_edg

; 1325 :           outstring("Risky configuration, but proceeding with deletion since force_deletion is on.\n");

	push	OFFSET ??_C@_0EP@HFOOEEPN@Risky?5configuration?0?5but?5proceed@
	call	_outstring
	add	esp, 4
$LN396@delete_edg:

; 1326 :       } 
; 1327 :       else return 0;
; 1328 :     }
; 1329 :   }
; 1330 : 
; 1331 :   if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN106@delete_edg

; 1332 :   { sprintf(msg,"Deleting edge %s\n",ELNAME(short_edge));

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN181@delete_edg
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN182@delete_edg
$LN181@delete_edg:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN182@delete_edg:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BC@GCCMJCEH@Deleting?5edge?5?$CFs?6?$AA@
	push	edx
	call	_sprintf

; 1333 :     outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
$LN106@delete_edg:

; 1334 :   }
; 1335 :   
; 1336 :  ENTER_GRAPH_MUTEX;

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN105@delete_edg
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$90132[ebp], 1
	jmp	SHORT $LN104@delete_edg
$LN105@delete_edg:
	mov	DWORD PTR _did_graphlock_here$90132[ebp], 0
$LN104@delete_edg:

; 1337 : 
; 1338 :  /* unwrap edge */
; 1339 :  if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	je	SHORT $LN103@delete_edg

; 1340 :    torus_unwrap_edge(short_edge);

	push	ebx
	call	_torus_unwrap_edge
	add	esp, 4
	jmp	SHORT $LN384@delete_edg
$LN103@delete_edg:

; 1341 :  else if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN384@delete_edg

; 1342 :   { 
; 1343 :     int wrap = get_edge_wrap(short_edge);

	push	ebx
	call	_get_edge_wrap
	mov	esi, eax
	add	esp, 4

; 1344 :     if ( wrap )

	test	esi, esi
	je	SHORT $LN100@delete_edg

; 1345 :       wrap_vertex(elim_v,wrap);

	mov	ecx, DWORD PTR _elim_v$[ebp]
	push	esi
	push	ecx
	call	_wrap_vertex
	add	esp, 8
$LN100@delete_edg:

; 1346 :     if ( (web.modeltype == QUADRATIC) && inverted(short_edge) )

	cmp	DWORD PTR _web+628, 2
	jne	SHORT $LN384@delete_edg
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN97@delete_edg

; 1347 :       wrap_vertex(get_edge_midv(short_edge),wrap);

	mov	eax, DWORD PTR _web+124
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+304]
	mov	eax, DWORD PTR [ecx+edx+8]
	push	esi
	push	eax
	call	_wrap_vertex
	add	esp, 8
$LN384@delete_edg:

; 1348 :   }
; 1349 : 
; 1350 :   /* put keep_v at middle of old edge if possible */
; 1351 :   if ( (web.modeltype == LINEAR) || (web.modeltype == QUADRATIC) )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	je	SHORT $LN97@delete_edg
	cmp	eax, 2
	jne	$LN385@delete_edg
$LN97@delete_edg:

; 1352 :   { if ( edge_head_same && edge_tail_same )

	cmp	DWORD PTR _edge_head_same$[ebp], 0
	je	$LN385@delete_edg
	mov	edi, DWORD PTR _edge_tail_same$[ebp]
	test	edi, edi
	je	$LN385@delete_edg

; 1353 :     { if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	$LN407@delete_edg

; 1354 :       { /* could eliminate either end, so keep high valence vertex */
; 1355 :         facetedge_id fe = get_edge_fe(short_edge);

	push	ebx
	call	_get_edge_fe
	mov	esi, eax
	add	esp, 4

; 1356 :         facetedge_id ffe;
; 1357 :         edge_id e1,e2; 
; 1358 :         if ( valid_id(fe) )

	test	esi, 268435456				; 10000000H
	je	$LN407@delete_edg

; 1359 :         { ffe = get_next_facet(fe);

	push	esi
	call	_get_next_facet

; 1360 :           e1 = get_fe_edge(get_prev_edge(fe));
; 1361 :           e2 = get_fe_edge(get_prev_edge(ffe));

	push	eax
	mov	DWORD PTR _ffe$90151[ebp], eax
	call	_get_prev_edge
	push	eax
	call	_get_fe_edge
	push	esi
	mov	edi, eax
	call	_get_prev_edge
	push	eax
	call	_get_fe_edge

; 1362 :           edge_tail_same = equal_id(e1,e2);
; 1363 :           e1 = get_fe_edge(get_next_edge(fe));
; 1364 :           e2 = get_fe_edge(get_next_edge(ffe));

	mov	edx, DWORD PTR _ffe$90151[ebp]
	xor	ecx, ecx
	cmp	eax, edi
	sete	cl
	push	edx
	mov	edi, ecx
	call	_get_next_edge
	push	eax
	call	_get_fe_edge
	push	esi
	mov	DWORD PTR tv3129[ebp], eax
	call	_get_next_edge
	push	eax
	call	_get_fe_edge

; 1365 :           edge_head_same = equal_id(e1,e2);

	xor	ecx, ecx
	add	esp, 36					; 00000024H
	cmp	eax, DWORD PTR tv3129[ebp]
	sete	cl
	mov	DWORD PTR _edge_head_same$[ebp], ecx

; 1366 :           if ( edge_tail_same && !edge_head_same )

	test	edi, edi
	je	SHORT $LN407@delete_edg
	test	ecx, ecx
	jne	SHORT $LN407@delete_edg

; 1367 :           { short_edge = edge_inverse(short_edge);

	xor	ebx, 134217728				; 08000000H

; 1368 :             elim_v = get_edge_headv(short_edge);

	push	ebx
	mov	DWORD PTR _short_edge$[ebp], ebx
	call	_get_edge_headv

; 1369 :             keep_v = get_edge_tailv(short_edge);

	push	ebx
	mov	DWORD PTR _elim_v$[ebp], eax
	call	_get_edge_tailv
	add	esp, 8
	mov	DWORD PTR _keep_v$[ebp], eax
$LN407@delete_edg:

; 1370 :           }
; 1371 :         }
; 1372 :       }
; 1373 :       if ( edge_tail_same == edge_head_same )

	cmp	edi, DWORD PTR _edge_head_same$[ebp]
	jne	SHORT $LN385@delete_edg

; 1374 :       { REAL *tailx = get_coord(keep_v);

	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR _keep_v$[ebp]
	mov	ecx, DWORD PTR _web+12

; 1375 :         REAL *headx = get_coord(elim_v); /* since unwrapped */

	mov	esi, DWORD PTR _elim_v$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+esi*4]
	add	eax, edx
	add	ecx, edx

; 1376 :         int i;
; 1377 :         for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN385@delete_edg
	fld	QWORD PTR __real@3fe0000000000000
	sub	ecx, eax
$LN91@delete_edg:

; 1378 :           tailx[i] = (tailx[i]+headx[i])/2;

	fld	QWORD PTR [ecx+eax]
	inc	edx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LN91@delete_edg

; 1376 :         int i;
; 1377 :         for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN385@delete_edg:

; 1379 :       }
; 1380 :     }
; 1381 :   }     
; 1382 :   
; 1383 :   /* change all references to the eliminated vertex to the
; 1384 :       kept vertex. */
; 1385 :   if ( !equal_id(elim_v,keep_v) )

	mov	ecx, DWORD PTR _keep_v$[ebp]
	cmp	DWORD PTR _elim_v$[ebp], ecx
	je	$LN86@delete_edg

; 1386 :   { edge_id e_id;
; 1387 :     int nn = 0;
; 1388 :     for (;;)
; 1389 :     { e_id = get_vertex_edge(elim_v);

	mov	edi, DWORD PTR _elim_v$[ebp]
	mov	edx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+edi*4]
	mov	esi, DWORD PTR [eax+28]
	mov	DWORD PTR _nn$90174[ebp], 0

; 1390 :       if ( !valid_id(e_id) ) break;

	test	esi, 268435456				; 10000000H
	je	$LN86@delete_edg
	mov	eax, ebx
	or	eax, 134217728				; 08000000H
	mov	DWORD PTR tv2893[ebp], eax
	npad	2
$LL87@delete_edg:

; 1391 :       remove_vertex_edge(elim_v,e_id);

	mov	ecx, DWORD PTR _elim_v$[ebp]
	push	esi
	push	ecx
	call	_remove_vertex_edge

; 1392 :       if ( equal_element(e_id,short_edge) ) 

	mov	edx, esi
	or	edx, 134217728				; 08000000H
	add	esp, 8
	cmp	edx, DWORD PTR tv2893[ebp]
	je	SHORT $LN83@delete_edg

; 1393 :          continue;
; 1394 :       set_edge_tailv(e_id,keep_v);

	mov	eax, DWORD PTR _keep_v$[ebp]
	push	eax
	push	esi
	call	_set_edge_tailv

; 1395 :       if ( ++nn > web.skel[EDGE].count ) 

	mov	eax, DWORD PTR _nn$90174[ebp]
	inc	eax
	add	esp, 8
	mov	DWORD PTR _nn$90174[ebp], eax
	cmp	eax, DWORD PTR _web+176
	jg	SHORT $LN348@delete_edg
$LN83@delete_edg:

; 1386 :   { edge_id e_id;
; 1387 :     int nn = 0;
; 1388 :     for (;;)
; 1389 :     { e_id = get_vertex_edge(elim_v);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	esi, DWORD PTR [edx+28]

; 1390 :       if ( !valid_id(e_id) ) break;

	test	esi, 268435456				; 10000000H
	jne	SHORT $LL87@delete_edg
	jmp	SHORT $LN86@delete_edg
$LN348@delete_edg:

; 1396 :       { sprintf(errmsg,"Internal error: Bad edge loop on vertex %s.\n",
; 1397 :            ELNAME(elim_v));

	test	DWORD PTR _elim_v$[ebp], 268435456	; 10000000H
	je	SHORT $LN183@delete_edg
	inc	edi
	push	edi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN184@delete_edg
$LN183@delete_edg:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN184@delete_edg:
	push	eax
	push	OFFSET ??_C@_0CN@CGONHFJB@Internal?5error?3?5Bad?5edge?5loop?5on@
	push	OFFSET _errmsg
	call	_sprintf

; 1398 :         kb_error(1344,errmsg,WARNING); 

	push	2
	push	OFFSET _errmsg
	push	1344					; 00000540H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN86@delete_edg:

; 1399 :         break; 
; 1400 :       }
; 1401 :     }
; 1402 :   }
; 1403 :   remove_vertex_edge(keep_v,short_edge);

	mov	eax, DWORD PTR _keep_v$[ebp]
	push	ebx
	push	eax
	call	_remove_vertex_edge

; 1404 : 
; 1405 : #ifdef MPI_EVOLVER
; 1406 :   mpi_note_edge_delete(short_edge,elim_v,keep_v);
; 1407 : #endif
; 1408 : 
; 1409 :   /* Go through facets around edge, adjusting facet loops
; 1410 :       of the merged edges, deleting facetedges, and facets */
; 1411 :   base_fe = first_fe = get_edge_fe(short_edge);

	push	ebx
	call	_get_edge_fe
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _first_fe$[ebp], eax
	mov	DWORD PTR _base_fe$[ebp], eax

; 1412 :   while ( valid_id(base_fe) )

	test	eax, 268435456				; 10000000H
	je	$LN81@delete_edg
	npad	3
$LL82@delete_edg:

; 1413 :   {
; 1414 :     facetedge_id next_base;  /* to get before freeing base_fe */
; 1415 :     facetedge_id aa,bb;
; 1416 :     facetedge_id bbase_fe;
; 1417 :     facetedge_id next_fe,prev_fe;
; 1418 :     vertex_id third_v;
; 1419 : 
; 1420 :     next_fe = get_next_edge(base_fe);

	mov	esi, DWORD PTR _base_fe$[ebp]
	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR tv2816[ebp], ecx
	mov	eax, esi
	je	SHORT $LN222@delete_edg
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2819[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	mov	edi, DWORD PTR [eax+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN221@delete_edg
$LN222@delete_edg:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2819[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	mov	edi, DWORD PTR [eax+32]
$LN221@delete_edg:

; 1421 :     prev_fe = get_prev_edge(base_fe);

	test	ecx, ecx
	je	SHORT $LN226@delete_edg
	mov	ebx, DWORD PTR [eax+32]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN225@delete_edg
$LN226@delete_edg:
	mov	ebx, DWORD PTR [eax+28]
$LN225@delete_edg:

; 1422 :     third_v = get_fe_headv(next_fe);

	mov	ecx, DWORD PTR _web+460
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, edi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	eax
	call	_get_edge_headv
	add	esp, 4

; 1423 :     if ( (web.representation == STRING) && 
; 1424 :        ((!valid_id(get_fe_facet(base_fe)) || !valid_id(prev_fe) || 
; 1425 :        ((!equal_id(get_next_edge(next_fe), prev_fe)) && !equal_id(prev_fe,next_fe)))
; 1426 :         || ((web.modeltype == QUADRATIC) && (!equal_id(prev_fe,next_fe)))) ) 

	cmp	DWORD PTR _web+624, 1
	mov	DWORD PTR _third_v$90196[ebp], eax
	jne	$LN390@delete_edg
	push	esi
	call	_get_fe_facet
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN79@delete_edg
	test	ebx, 268435456				; 10000000H
	je	SHORT $LN79@delete_edg
	push	edi
	call	_get_next_edge
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN78@delete_edg
	cmp	ebx, edi
	jne	SHORT $LN79@delete_edg
$LN78@delete_edg:
	cmp	DWORD PTR _web+628, 2
	jne	$LN390@delete_edg
	cmp	ebx, edi
	je	$LN390@delete_edg
$LN79@delete_edg:

; 1427 :     {
; 1428 :       /* do not eliminate facets with more than 3 edges */
; 1429 :       /* but might have free end */
; 1430 : 
; 1431 :       bbase_fe = base_fe;
; 1432 :   /*    do  */
; 1433 :       {
; 1434 :         next_fe = get_next_edge(bbase_fe);

	push	esi
	call	_get_next_edge
	mov	edi, eax
	add	esp, 4

; 1435 :         if ( valid_id(next_fe) && equal_element(short_edge,get_fe_edge(next_fe)) )

	test	edi, 268435456				; 10000000H
	je	SHORT $LN389@delete_edg
	mov	edx, DWORD PTR _web+460
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _short_edge$[ebp]
	or	ecx, 134217728				; 08000000H
	or	edx, 134217728				; 08000000H
	cmp	edx, ecx
	jne	SHORT $LN389@delete_edg

; 1436 :           next_fe = get_next_edge(next_fe);

	push	edi
	call	_get_next_edge
	add	esp, 4
	mov	edi, eax
$LN389@delete_edg:

; 1437 : 
; 1438 :         prev_fe = get_prev_edge(bbase_fe);

	push	esi
	call	_get_prev_edge
	mov	ebx, eax
	add	esp, 4

; 1439 :         if ( valid_id(prev_fe) && equal_element(short_edge,get_fe_edge(prev_fe)) )

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN76@delete_edg
	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _short_edge$[ebp]
	or	eax, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	ecx, eax
	jne	SHORT $LN76@delete_edg

; 1440 :           prev_fe = get_prev_edge(prev_fe);

	push	ebx
	call	_get_prev_edge
	add	esp, 4
	mov	ebx, eax
$LN76@delete_edg:

; 1441 : 
; 1442 :         set_next_edge(prev_fe,next_fe);

	push	edi
	push	ebx
	call	_set_next_edge

; 1443 :         set_prev_edge(next_fe,prev_fe);

	push	ebx
	push	edi
	call	_set_prev_edge

; 1444 :         f_id = get_fe_facet(bbase_fe);

	push	esi
	call	_get_fe_facet
	mov	esi, eax
	add	esp, 20					; 00000014H

; 1445 :         if ( valid_id(f_id) && equal_id(bbase_fe,get_facet_fe(f_id)) )

	test	esi, 268435456				; 10000000H
	je	$LN12@delete_edg
	push	esi
	call	_get_facet_fe
	add	esp, 4
	cmp	DWORD PTR _base_fe$[ebp], eax
	jne	$LN12@delete_edg

; 1446 :         { b_id = get_facet_body(f_id);

	push	esi
	call	_get_facet_body
	add	esp, 4
	mov	DWORD PTR _b_id$[ebp], eax

; 1447 :           if ( valid_id(next_fe) )

	test	edi, 268435456				; 10000000H
	je	SHORT $LN74@delete_edg

; 1448 :           { set_facet_fe(f_id,next_fe);

	push	edi

; 1449 :             if ( valid_id(b_id) )
; 1450 :               set_body_facet(b_id,f_id);
; 1451 :           } else

	jmp	SHORT $LN436@delete_edg
$LN74@delete_edg:

; 1452 :           { set_facet_fe(f_id,prev_fe);

	push	ebx
$LN436@delete_edg:
	push	esi
	call	_set_facet_fe

; 1453 :             if ( valid_id(b_id) )

	mov	eax, DWORD PTR _b_id$[ebp]
	add	esp, 8
	test	eax, 268435456				; 10000000H
	je	$LN12@delete_edg

; 1454 :               set_body_facet(b_id,f_id);

	push	esi
	push	eax
	call	_set_body_facet
	add	esp, 8

; 1455 :           }
; 1456 :         }
; 1457 :         bbase_fe = get_next_facet(bbase_fe);
; 1458 :       } /*while ( valid_id(bbase_fe) && (!equal_id(bbase_fe,base_fe)) );*/
; 1459 :     }
; 1460 :     else

	jmp	$LN12@delete_edg
$LN390@delete_edg:

; 1461 :     { /* eliminate whole facet */
; 1462 :       facetedge_id a=0;  /* for edge to be merged */

	xor	ebx, ebx

; 1463 :       facetedge_id b=0;  /* for edge to be merged with */
; 1464 :       facetedge_id a_next=0,a_prev=0,b_next=0,b_prev=0;
; 1465 :                  /* facet chain links around edges a,b */
; 1466 :       facetedge_id next_fea;  /* next around facet loop of a */
; 1467 :       edge_id  a_edge=0; /* edge of side a */
; 1468 :       edge_id  b_edge=0; /* edge of side b */
; 1469 :       facet_id  facet=0;  /* facet to be eliminated */ 
; 1470 :       edge_id keep_edge=0,throw_edge=0;
; 1471 : 
; 1472 :       /* label relevant edges and */
; 1473 :       /* see if we have an adjacent starred triangle which will give
; 1474 :           trouble if we don't unstar it */
; 1475 :       bbase_fe = base_fe;
; 1476 :       /* for(;;) */ /* may take multiple passes for unstarring */
; 1477 :       { int flag;
; 1478 :         int unstar_count = 0;
; 1479 :         int ktcomp;
; 1480 :         /* first, set up to favor deletion of valence 2 edge */
; 1481 :         if ( get_edge_valence(get_fe_edge(get_prev_edge(bbase_fe))) == 2 )

	push	esi
	mov	DWORD PTR _a$90216[ebp], ebx
	mov	DWORD PTR _b$90217[ebp], ebx
	mov	DWORD PTR _a_next$90218[ebp], ebx
	mov	DWORD PTR _a_prev$90219[ebp], ebx
	mov	DWORD PTR _b_next$90220[ebp], ebx
	mov	DWORD PTR _b_prev$90221[ebp], ebx
	mov	DWORD PTR _a_edge$90223[ebp], ebx
	mov	DWORD PTR _keep_edge$90226[ebp], ebx
	mov	DWORD PTR _throw_edge$90227[ebp], ebx
	call	_get_prev_edge
	mov	ecx, DWORD PTR _web+460
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	eax
	call	_get_edge_valence
	add	esp, 8
	cmp	eax, 2
	jne	SHORT $LN69@delete_edg

; 1482 :               bbase_fe = inverse_id(bbase_fe);

	xor	esi, 134217728				; 08000000H
$LN69@delete_edg:

; 1483 :         /* now check conditions and set up for elimination */
; 1484 :         for (flag=0;flag<2;flag++)

	mov	DWORD PTR _flag$90228[ebp], ebx
	npad	11
$LL68@delete_edg:

; 1485 :         { facet = get_fe_facet(bbase_fe);

	mov	edi, DWORD PTR _web+460
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN238@delete_edg
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN237@delete_edg
$LN238@delete_edg:
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ecx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN237@delete_edg
	xor	eax, 134217728				; 08000000H
$LN237@delete_edg:
	mov	DWORD PTR _facet$90225[ebp], eax

; 1486 :           if ( !valid_id(facet) ) break;

	test	eax, 268435456				; 10000000H
	je	$LN391@delete_edg

; 1487 :           a = get_next_edge(bbase_fe);

	mov	eax, esi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv2976[ebp], eax
	je	SHORT $LN242@delete_edg
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edi+edx*4]
	mov	eax, DWORD PTR [ebx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN425@delete_edg
$LN242@delete_edg:
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ebx+32]
$LN425@delete_edg:

; 1488 :           a_edge = get_fe_edge(a);

	mov	ecx, eax
	mov	edx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _a$90216[ebp], eax

; 1489 :           a_next = get_next_facet(a);

	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR _a_edge$90223[ebp], edx
	je	SHORT $LN248@delete_edg
	mov	edx, DWORD PTR [ecx+36]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN426@delete_edg
$LN248@delete_edg:
	mov	edx, DWORD PTR [ecx+40]
$LN426@delete_edg:
	mov	DWORD PTR _a_next$90218[ebp], edx

; 1490 :           a_prev = get_prev_facet(a);

	test	eax, eax
	je	SHORT $LN252@delete_edg
	mov	ecx, DWORD PTR [ecx+40]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR _a_prev$90219[ebp], ecx
	jmp	SHORT $LN251@delete_edg
$LN252@delete_edg:
	mov	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _a_prev$90219[ebp], eax
$LN251@delete_edg:

; 1491 :           b = get_prev_edge(bbase_fe);

	cmp	DWORD PTR tv2976[ebp], 0
	je	SHORT $LN256@delete_edg
	mov	eax, DWORD PTR [ebx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN427@delete_edg
$LN256@delete_edg:
	mov	eax, DWORD PTR [ebx+28]
$LN427@delete_edg:

; 1492 :           b_edge = get_fe_edge(b);

	mov	ecx, eax
	mov	ebx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR _b$90217[ebp], eax
	and	ebx, 134217728				; 08000000H
	xor	ebx, DWORD PTR [edi+20]

; 1493 :           b_next = get_next_facet(b);

	shr	eax, 27					; 0000001bH
	and	eax, 1
	je	SHORT $LN262@delete_edg
	mov	ecx, DWORD PTR [edi+36]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR _b_next$90220[ebp], ecx
	jmp	SHORT $LN261@delete_edg
$LN262@delete_edg:
	mov	edx, DWORD PTR [edi+40]
	mov	DWORD PTR _b_next$90220[ebp], edx
$LN261@delete_edg:

; 1494 :           b_prev = get_prev_facet(b);

	test	eax, eax
	je	SHORT $LN266@delete_edg
	mov	edi, DWORD PTR [edi+40]
	xor	edi, 134217728				; 08000000H
	mov	DWORD PTR _b_prev$90221[ebp], edi
	jmp	SHORT $LN265@delete_edg
$LN266@delete_edg:
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR _b_prev$90221[ebp], eax
$LN265@delete_edg:

; 1495 :           keep_edge = b_edge; throw_edge = a_edge; 

	mov	edi, DWORD PTR _a_edge$90223[ebp]

; 1496 :           
; 1497 :           ktcomp = compare_edge_attr(keep_edge,throw_edge);

	push	edi
	push	ebx
	mov	DWORD PTR _keep_edge$90226[ebp], ebx
	mov	DWORD PTR _throw_edge$90227[ebp], edi
	call	_compare_edge_attr
	add	esp, 8

; 1498 :           if ( ktcomp == A_SUB_B )

	cmp	eax, 1

; 1499 :           { bbase_fe = inverse_id(bbase_fe); continue; } 

	je	SHORT $LN428@delete_edg

; 1500 :           if ( ktcomp == INCOMPARABLE )

	test	eax, eax
	jne	SHORT $LN410@delete_edg

; 1501 :           { facet_id f_id = get_fe_facet(bbase_fe);

	push	esi
	call	_get_fe_facet

; 1502 :             int tcomp = compare_edge_facet_attr(throw_edge,f_id);

	push	eax
	push	edi
	call	_compare_edge_facet_attr
	add	esp, 12					; 0000000cH

; 1503 :             if ( !(tcomp==A_SUB_B || tcomp==A_EQ_B) )

	cmp	eax, 1
	je	SHORT $LN410@delete_edg
	cmp	eax, 2
	je	SHORT $LN410@delete_edg
$LN428@delete_edg:

; 1483 :         /* now check conditions and set up for elimination */
; 1484 :         for (flag=0;flag<2;flag++)

	mov	eax, DWORD PTR _flag$90228[ebp]
	inc	eax

; 1504 :             { bbase_fe = inverse_id(bbase_fe); continue; }

	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR _flag$90228[ebp], eax
	cmp	eax, 2
	jl	$LL68@delete_edg

; 1492 :           b_edge = get_fe_edge(b);

	mov	DWORD PTR _b_edge$90224[ebp], ebx

; 1734 :       } while ( !equal_id(ea,start_e) );

	jmp	$LN364@delete_edg
$LN410@delete_edg:

; 1505 :           } 
; 1506 :           
; 1507 :           if ( equal_element(a_edge,b_edge) ) break;

	mov	ecx, ebx
	mov	edx, edi
	or	ecx, 134217728				; 08000000H
	or	edx, 134217728				; 08000000H
	mov	DWORD PTR _b_edge$90224[ebp], ebx
	cmp	edx, ecx
	je	$LN386@delete_edg

; 1508 :           aa = get_next_edge(a_next);

	mov	eax, DWORD PTR _a_next$90218[ebp]
	push	eax
	call	_get_next_edge
	add	esp, 4

; 1510 :           if ( web.representation != SOAPFILM ) break;

	cmp	DWORD PTR _web+624, 2
	mov	esi, eax
	jne	$LN386@delete_edg

; 1511 :           if ( get_vattr(get_edge_headv(a_edge)) & AXIAL_POINT ) break;

	push	edi
	call	_get_edge_headv
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	ecx, ecx
	add	esp, 4
	or	eax, ecx
	jne	$LN386@delete_edg

; 1509 :           bb = get_prev_edge(b_next);

	mov	edx, DWORD PTR _b_next$90220[ebp]
	push	edx
	call	_get_prev_edge
	mov	edi, eax

; 1512 :           if ( equal_id(get_next_facet(aa),inverse_id(bb)) )

	push	esi
	xor	edi, 134217728				; 08000000H
	call	_get_next_facet
	add	esp, 8
	cmp	eax, edi
	jne	$LN386@delete_edg

; 1513 :           { int ret = unstar(aa); 

	push	esi
	call	_unstar
	add	esp, 4

; 1514 :             if ( ret < 0 )

	test	eax, eax
	jns	$LN11@delete_edg

; 1515 :             { sprintf(errmsg,
; 1516 :         "Edge %s not deleted due to adjacent configuration involving facet %s.\n",
; 1517 :                                  ELNAME(short_edge),ELNAME1(facet));

	mov	eax, DWORD PTR _facet$90225[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN185@delete_edg
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN186@delete_edg
$LN185@delete_edg:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN186@delete_edg:
	mov	eax, DWORD PTR _short_edge$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN187@delete_edg
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN188@delete_edg
$LN187@delete_edg:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN188@delete_edg:
	push	esi
	push	eax
	push	OFFSET ??_C@_0EH@DAGLDMDM@Edge?5?$CFs?5not?5deleted?5due?5to?5adjac@
	push	OFFSET _errmsg
	call	_sprintf

; 1518 : 
; 1519 :             kb_error(1345,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1345					; 00000541H
	call	_kb_error
	mov	edi, DWORD PTR _web+460
	mov	ebx, DWORD PTR _b_edge$90224[ebp]
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN363@delete_edg
$LN386@delete_edg:
	mov	edi, DWORD PTR _web+460
	jmp	SHORT $LN363@delete_edg
$LN391@delete_edg:

; 1492 :           b_edge = get_fe_edge(b);

	mov	DWORD PTR _b_edge$90224[ebp], ebx
$LN363@delete_edg:

; 1520 :               break;
; 1521 :             }
; 1522 :             unstar_count = 1;
; 1523 :           }
; 1524 :           break;  
; 1525 :         }
; 1526 :         if ( unstar_count ) continue;  /* retry */
; 1527 :         if ( flag >= 2 ) 

	cmp	DWORD PTR _flag$90228[ebp], 2
	jl	SHORT $LN55@delete_edg
$LN364@delete_edg:

; 1528 :         {
; 1529 :           sprintf(errmsg,"Edge amenity failed second time through on edge %s\n",
; 1530 :               ELNAME(short_edge));

	mov	eax, DWORD PTR _short_edge$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN189@delete_edg
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN190@delete_edg
$LN189@delete_edg:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN190@delete_edg:
	push	eax
	push	OFFSET ??_C@_0DE@PFLGPGEF@Edge?5amenity?5failed?5second?5time?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1531 :           kb_error(2198,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2198					; 00000896H
	call	_kb_error
	mov	edi, DWORD PTR _web+460
	add	esp, 24					; 00000018H
$LN55@delete_edg:

; 1532 :         }
; 1533 :         /* break;  since not doing for loop any more */
; 1534 :       }
; 1535 : 
; 1536 :       /* put throw_edge constraints on keep_edge */
; 1537 : /* probably don't want to do this wholesale 
; 1538 :       set_attr(keep_edge,get_eattr(throw_edge));
; 1539 :       set_e_conmap(keep_edge,get_e_constraint_map(throw_edge));
; 1540 :       if ( get_eattr(throw_edge) & BOUNDARY )
; 1541 :         set_edge_boundary_num(keep_edge,get_edge_boundary_num(throw_edge));
; 1542 : */
; 1543 :       if ( equal_element(a,b) )

	mov	esi, DWORD PTR _b$90217[ebp]
	mov	edx, DWORD PTR _a$90216[ebp]
	mov	eax, esi
	mov	ecx, edx
	or	eax, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	mov	DWORD PTR tv3057[ebp], eax
	mov	DWORD PTR tv3058[ebp], ecx
	cmp	ecx, eax
	jne	$LN54@delete_edg

; 1544 :       { /* dihedron; should be only in quadratic model */     
; 1545 :         facetedge_id rfe = get_next_facet(a);

	test	edx, 134217728				; 08000000H
	je	SHORT $LN270@delete_edg
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+edx*4]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _rfe$90261[ebp], eax
	jmp	SHORT $LL53@delete_edg
$LN270@delete_edg:
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _rfe$90261[ebp], edx
	npad	9
$LL53@delete_edg:

; 1546 :         do
; 1547 :         { facet_id ff_id = get_fe_facet(rfe);

	mov	ecx, DWORD PTR _rfe$90261[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN274@delete_edg
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN273@delete_edg
$LN274@delete_edg:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+edx*4]
	mov	eax, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN273@delete_edg
	xor	eax, 134217728				; 08000000H
$LN273@delete_edg:

; 1548 :           facetedge_id rnext = get_next_edge(rfe);

	mov	edx, ecx
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	DWORD PTR _ff_id$90265[ebp], eax
	mov	DWORD PTR tv3072[ebp], edx
	mov	ebx, ecx
	je	SHORT $LN278@delete_edg
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	eax, DWORD PTR [ebx+edi]
	mov	esi, DWORD PTR [eax+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN277@delete_edg
$LN278@delete_edg:
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	eax, DWORD PTR [ebx+edi]
	mov	esi, DWORD PTR [eax+32]
$LN277@delete_edg:

; 1549 :           facetedge_id rprev = get_prev_edge(rfe);

	test	edx, edx
	je	SHORT $LN282@delete_edg
	mov	eax, DWORD PTR [eax+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN429@delete_edg
$LN282@delete_edg:
	mov	eax, DWORD PTR [eax+28]
$LN429@delete_edg:

; 1550 :           if ( equal_element(rfe,get_facet_fe(ff_id)) )

	mov	edx, DWORD PTR _ff_id$90265[ebp]
	mov	DWORD PTR _rprev$90267[ebp], eax
	test	edx, 268435456				; 10000000H
	jne	SHORT $LN286@delete_edg
	xor	edx, edx
	jmp	SHORT $LN287@delete_edg
$LN286@delete_edg:
	mov	ecx, DWORD PTR _web+236
	and	edx, 134217727				; 07ffffffH
	test	DWORD PTR _ff_id$90265[ebp], 134217728	; 08000000H
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [edx+28]
	je	SHORT $LN285@delete_edg
	xor	edx, 134217728				; 08000000H
$LN285@delete_edg:
	mov	ecx, DWORD PTR _rfe$90261[ebp]
$LN287@delete_edg:
	or	edx, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	ecx, edx
	jne	SHORT $LN393@delete_edg

; 1551 :           { /* reset ff_id facetedge link */
; 1552 :             if ( equal_id(rnext,rfe) )

	mov	ecx, DWORD PTR _rfe$90261[ebp]
	cmp	esi, ecx
	jne	SHORT $LN49@delete_edg

; 1553 :             { if ( equal_id(rfe,rprev) )

	cmp	ecx, eax
	jne	SHORT $LN48@delete_edg

; 1554 :                 set_facet_fe(ff_id,NULLID);

	push	0

; 1555 :               else

	jmp	SHORT $LN430@delete_edg
$LN48@delete_edg:

; 1556 :                 set_facet_fe(ff_id,rprev);

	mov	ecx, DWORD PTR _rprev$90267[ebp]
	mov	edx, DWORD PTR _ff_id$90265[ebp]
	push	ecx
	push	edx

; 1557 :             }
; 1558 :             else 

	jmp	SHORT $LN431@delete_edg
$LN49@delete_edg:

; 1559 :               set_facet_fe(ff_id,rnext);              

	push	esi
$LN430@delete_edg:
	mov	eax, DWORD PTR _ff_id$90265[ebp]
	push	eax
$LN431@delete_edg:
	call	_set_facet_fe
	mov	edi, DWORD PTR _web+460
	mov	eax, DWORD PTR _rprev$90267[ebp]
	add	esp, 8
$LN393@delete_edg:

; 1560 :           }
; 1561 :           set_next_edge(rprev,rnext);

	test	eax, 268435456				; 10000000H
	je	SHORT $LN289@delete_edg
	test	eax, 134217728				; 08000000H
	je	SHORT $LN290@delete_edg
	mov	ecx, esi
	xor	ecx, 134217728				; 08000000H
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [edx+28], ecx
	jmp	SHORT $LN432@delete_edg
$LN290@delete_edg:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [edx+32], esi
$LN432@delete_edg:
	mov	edi, DWORD PTR _web+460
$LN289@delete_edg:

; 1562 :           set_prev_edge(rnext,rprev);

	test	esi, 268435456				; 10000000H
	je	SHORT $LN297@delete_edg
	test	esi, 134217728				; 08000000H
	je	SHORT $LN295@delete_edg
	xor	eax, 134217728				; 08000000H
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+esi*4]
	mov	DWORD PTR [ecx+32], eax
	jmp	SHORT $LN294@delete_edg
$LN295@delete_edg:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+esi*4]
	mov	DWORD PTR [edx+28], eax
$LN294@delete_edg:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN297@delete_edg:

; 1563 :           free_element(rfe);

	mov	eax, DWORD PTR _rfe$90261[ebp]
	push	eax
	call	_free_element

; 1564 :           rfe = get_next_facet(rfe);

	mov	edi, DWORD PTR _web+460
	add	esp, 4
	cmp	DWORD PTR tv3072[ebp], 0
	je	SHORT $LN300@delete_edg
	mov	ecx, DWORD PTR [ebx+edi]
	mov	eax, DWORD PTR [ecx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN433@delete_edg
$LN300@delete_edg:
	mov	edx, DWORD PTR [ebx+edi]
	mov	eax, DWORD PTR [edx+40]
$LN433@delete_edg:
	mov	DWORD PTR _rfe$90261[ebp], eax

; 1565 :         } while ( !equal_element(a,rfe) );

	or	eax, 134217728				; 08000000H
	cmp	DWORD PTR tv3058[ebp], eax
	jne	$LL53@delete_edg

; 1566 :         goto wasloop;   

	jmp	$wasloop$90273
$LN54@delete_edg:

; 1567 :       }
; 1568 :       
; 1569 :       if ( equal_id(a_next,a) )  /* single facet on edge a */

	cmp	DWORD PTR _a_next$90218[ebp], edx
	jne	SHORT $LN45@delete_edg

; 1570 :       { if ( equal_id(b_next,b) ) /* and on edge b */

	cmp	DWORD PTR _b_next$90220[ebp], esi
	jne	SHORT $LN44@delete_edg

; 1571 :             set_edge_fe(keep_edge,NULLID);

	mov	eax, DWORD PTR _keep_edge$90226[ebp]
	push	0
	push	eax
	call	_set_edge_fe
	add	esp, 8

; 1572 :         else  /* have more around b */

	jmp	$LN36@delete_edg
$LN44@delete_edg:

; 1573 :         { set_next_facet(b_prev,b_next);

	mov	esi, DWORD PTR _b_next$90220[ebp]
	mov	edi, DWORD PTR _b_prev$90221[ebp]
	push	esi
	push	edi
	call	_set_next_facet

; 1574 :           set_prev_facet(b_next,b_prev);

	push	edi
	push	esi
	call	_set_prev_facet

; 1575 :           set_edge_fe(keep_edge,b_next);

	mov	ecx, DWORD PTR _keep_edge$90226[ebp]
	push	esi
	push	ecx
	call	_set_edge_fe
	add	esp, 24					; 00000018H

; 1576 :         }

	jmp	$LN36@delete_edg
$LN45@delete_edg:

; 1577 :       }
; 1578 :       else if ( equal_id(b_next,b) )  /* single facet on edge b */

	cmp	DWORD PTR _b_next$90220[ebp], esi
	jne	SHORT $LN41@delete_edg

; 1579 :       { set_next_facet(a_prev,a_next);

	mov	esi, DWORD PTR _a_next$90218[ebp]
	mov	edi, DWORD PTR _a_prev$90219[ebp]
	push	esi
	push	edi
	call	_set_next_facet

; 1580 :         set_prev_facet(a_next,a_prev);

	push	edi
	push	esi
	call	_set_prev_facet

; 1581 :         set_edge_fe(keep_edge,fe_inverse(a_next));

	mov	edx, DWORD PTR _keep_edge$90226[ebp]
	xor	esi, 134217728				; 08000000H
	push	esi
	push	edx
	call	_set_edge_fe
	add	esp, 24					; 00000018H
	jmp	$LN36@delete_edg
$LN41@delete_edg:

; 1582 :       }
; 1583 :       else if ( equal_element(a_edge,b_edge) )

	mov	eax, DWORD PTR _a_edge$90223[ebp]
	or	ebx, 134217728				; 08000000H
	or	eax, 134217728				; 08000000H
	cmp	eax, ebx
	jne	SHORT $LN39@delete_edg

; 1584 :       { /* excise a,b from loop */
; 1585 :         set_prev_facet(a_next,a_prev);

	mov	esi, DWORD PTR _a_prev$90219[ebp]
	mov	edi, DWORD PTR _a_next$90218[ebp]
	push	esi
	push	edi
	call	_set_prev_facet

; 1586 :         set_next_facet(a_prev,a_next);

	push	edi
	push	esi
	call	_set_next_facet

; 1587 :         b_next = get_next_facet(b); /* in case of change */

	mov	edi, DWORD PTR _b$90217[ebp]
	push	edi
	call	_get_next_facet

; 1588 :         b_prev = get_prev_facet(b);

	push	edi
	mov	esi, eax
	call	_get_prev_facet
	add	esp, 24					; 00000018H
	mov	ebx, eax

; 1589 :         if ( equal_id(b,b_next) )

	cmp	edi, esi
	jne	SHORT $LN38@delete_edg

; 1590 :               set_edge_fe(keep_edge,NULLEDGE); /* dropped only facet */

	mov	ecx, DWORD PTR _NULLEDGE
	mov	edx, DWORD PTR _keep_edge$90226[ebp]
	push	ecx
	push	edx
	call	_set_edge_fe
	add	esp, 8

; 1591 :         else

	jmp	SHORT $LN36@delete_edg
$LN38@delete_edg:

; 1592 :         { /* excise b */
; 1593 :           set_prev_facet(b_next,b_prev);

	push	ebx
	push	esi
	call	_set_prev_facet

; 1594 :           set_next_facet(b_prev,b_next);

	push	esi
	push	ebx
	call	_set_next_facet

; 1595 :           set_edge_fe(keep_edge,b_next);

	mov	eax, DWORD PTR _keep_edge$90226[ebp]
	push	esi
	push	eax
	call	_set_edge_fe
	add	esp, 24					; 00000018H

; 1596 :         }
; 1597 :       }
; 1598 :       else  /* have to join chains */

	jmp	SHORT $LN36@delete_edg
$LN39@delete_edg:

; 1599 :       { set_prev_facet(a_next,fe_inverse(b_next));

	mov	ebx, DWORD PTR _b_next$90220[ebp]
	mov	edx, DWORD PTR _a_next$90218[ebp]
	mov	ecx, ebx
	xor	ecx, 134217728				; 08000000H
	push	ecx
	push	edx
	call	_set_prev_facet

; 1600 :         set_next_facet(a_prev,fe_inverse(b_prev));

	mov	esi, DWORD PTR _b_prev$90221[ebp]
	mov	edi, DWORD PTR _a_prev$90219[ebp]
	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	push	eax
	push	edi
	call	_set_next_facet

; 1601 :         set_next_facet(b_prev,fe_inverse(a_prev));

	xor	edi, 134217728				; 08000000H
	push	edi
	push	esi
	call	_set_next_facet

; 1602 :         set_prev_facet(b_next,fe_inverse(a_next));

	mov	esi, DWORD PTR _a_next$90218[ebp]
	xor	esi, 134217728				; 08000000H
	push	esi
	push	ebx
	call	_set_prev_facet

; 1603 :         set_edge_fe(keep_edge,fe_inverse(a_next));

	mov	ecx, DWORD PTR _keep_edge$90226[ebp]
	push	esi
	push	ecx
	call	_set_edge_fe
	add	esp, 40					; 00000028H
$LN36@delete_edg:

; 1604 :       }
; 1605 :               
; 1606 :       /* fix edge references around deleted edge to refer to kept edge */
; 1607 :       next_fea = get_edge_fe(keep_edge);

	mov	ecx, DWORD PTR _keep_edge$90226[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv3152[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	test	eax, eax
	jne	SHORT $LN304@delete_edg
	xor	esi, esi
	jmp	SHORT $LN305@delete_edg
$LN304@delete_edg:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN303@delete_edg
	xor	eax, 134217728				; 08000000H
$LN303@delete_edg:
	mov	esi, eax
$LN305@delete_edg:

; 1608 :       if ( valid_id(next_fea) )

	mov	edi, DWORD PTR _web+460
	mov	ebx, DWORD PTR _keep_edge$90226[ebp]
	test	esi, 268435456				; 10000000H
	je	SHORT $LN32@delete_edg
$LL34@delete_edg:

; 1609 :         do
; 1610 :         { set_fe_edge(next_fea,keep_edge);

	mov	eax, esi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	ecx, ebx
	je	SHORT $LN409@delete_edg
	xor	ecx, 134217728				; 08000000H
$LN409@delete_edg:
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [edi+esi]
	mov	DWORD PTR [edx+20], ecx
	mov	ecx, DWORD PTR _global_timestamp

; 1611 :           next_fea = get_next_facet(next_fea);

	mov	edi, DWORD PTR _web+460
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
	test	eax, eax
	je	SHORT $LN311@delete_edg
	mov	eax, DWORD PTR [edi+esi]
	mov	esi, DWORD PTR [eax+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN33@delete_edg
$LN311@delete_edg:
	mov	ecx, DWORD PTR [edi+esi]
	mov	esi, DWORD PTR [ecx+40]
$LN33@delete_edg:

; 1612 :         }
; 1613 :         while ( next_fea != get_edge_fe(keep_edge) );

	push	ebx
	call	_get_edge_fe
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LL34@delete_edg
$LN32@delete_edg:

; 1614 : 
; 1615 :       /* fix phase tension */
; 1616 :       if ( (web.representation == STRING) && phase_flag )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN31@delete_edg
	cmp	DWORD PTR _phase_flag, 0
	je	SHORT $LN31@delete_edg

; 1617 :           set_e_phase_density(keep_edge);

	push	ebx
	call	_set_e_phase_density
	mov	edi, DWORD PTR _web+460
	add	esp, 4
$LN31@delete_edg:

; 1618 : 
; 1619 :       /* fix no_refine, in favor of not no_refine */
; 1620 :       if ( !(get_eattr(throw_edge) & NO_REFINE) )

	mov	ecx, DWORD PTR _throw_edge$90227[ebp]
	mov	edx, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 16777216				; 01000000H
	xor	edx, edx
	or	eax, edx
	jne	SHORT $LN314@delete_edg

; 1621 :         unset_attr(keep_edge,NO_REFINE);

	mov	edx, DWORD PTR tv3152[ebp]
	shr	ebx, 29					; 0000001dH
	imul	ebx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ebx+12]
	mov	eax, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR [eax+12]
	and	DWORD PTR [eax+8], -16777217		; feffffffH
	mov	DWORD PTR [eax+12], edx
	mov	edi, DWORD PTR _web+460
$LN314@delete_edg:

; 1622 : 
; 1623 :       /* fix method instances. Oppositely oriented signed methods cancel;
; 1624 :          others combined.                                                   */
; 1625 :       { struct edge *ea_ptr = eptr(keep_edge);

	mov	edx, DWORD PTR tv3152[ebp]
	mov	eax, DWORD PTR _web+124
	mov	esi, DWORD PTR [edx+eax]

; 1626 :         struct edge *eb_ptr = eptr(throw_edge);

	mov	ecx, DWORD PTR [ecx+eax]

; 1627 :         int meth_offset = get_meth_offset(EDGE);

	mov	eax, DWORD PTR _web+5668
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	DWORD PTR _eb_ptr$90296[ebp], ecx
	mov	eax, DWORD PTR [eax+edx+64]

; 1628 :         int *ameths = (int*)((char*)ea_ptr+meth_offset);

	lea	edx, DWORD PTR [eax+esi]

; 1629 :         int *bmeths = (int*)((char*)eb_ptr+meth_offset);

	add	eax, ecx
	mov	DWORD PTR _bmeths$90302[ebp], eax

; 1630 :         int i,j;
; 1631 :         for ( i = 0 ; i < (int)eb_ptr->method_count ; i++ )

	xor	eax, eax
	mov	DWORD PTR _ameths$90299[ebp], edx
	mov	DWORD PTR _i$90305[ebp], 0
	cmp	ax, WORD PTR [ecx+24]
	jae	$wasloop$90273
	npad	7
$LL415@delete_edg:

; 1632 :         { int m;
; 1633 :           int handled = 0;
; 1634 :   
; 1635 :           int orientable;
; 1636 :           m = abs(bmeths[i]);

	mov	ecx, DWORD PTR _bmeths$90302[ebp]
	mov	edx, DWORD PTR _i$90305[ebp]
	mov	edi, DWORD PTR [ecx+edx*4]
	mov	eax, edi
	cdq
	mov	ecx, eax
	xor	ecx, edx
	sub	ecx, edx

; 1637 :           orientable = basic_gen_methods[METH_INSTANCE(m)->gen_method].flags &
; 1638 :                            ORIENTABLE_METHOD;

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	mov	eax, DWORD PTR [eax+edx+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	mov	ebx, DWORD PTR _basic_gen_methods[eax+132]

; 1639 :           for ( j = 0 ; j < (int)ea_ptr->method_count ; j++ )

	movzx	eax, WORD PTR [esi+24]
	and	ebx, 65536				; 00010000H
	mov	DWORD PTR _j$90306[ebp], 0
	mov	DWORD PTR tv3241[ebp], eax
	test	eax, eax
	jle	SHORT $LN365@delete_edg
$LL416@delete_edg:

; 1640 :           { int n;
; 1641 :             n = abs(ameths[j]);

	mov	edx, DWORD PTR _ameths$90299[ebp]
	mov	eax, DWORD PTR _j$90306[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	cdq
	xor	eax, edx
	sub	eax, edx

; 1642 :             if ( n == m ) 

	cmp	eax, ecx
	je	SHORT $LN350@delete_edg

; 1639 :           for ( j = 0 ; j < (int)ea_ptr->method_count ; j++ )

	mov	eax, DWORD PTR _j$90306[ebp]
	movzx	edx, WORD PTR [esi+24]
	inc	eax
	mov	DWORD PTR _j$90306[ebp], eax
	cmp	eax, edx
	jl	SHORT $LL416@delete_edg
$LN365@delete_edg:

; 1654 :           /* Not found on keep_edge, so paste onto keep_edge */
; 1655 :           if ( orientable && same_sign(keep_edge,throw_edge) )

	test	ebx, ebx
	je	SHORT $LN20@delete_edg
	mov	edx, DWORD PTR _throw_edge$90227[ebp]
	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR _keep_edge$90226[ebp]
	je	SHORT $LN20@delete_edg

; 1656 :             ameths[ea_ptr->method_count++] = bmeths[i];

	mov	eax, DWORD PTR _ameths$90299[ebp]
	mov	ecx, DWORD PTR tv3241[ebp]
	mov	DWORD PTR [eax+ecx*4], edi

; 1657 :           else

	jmp	SHORT $LN434@delete_edg
$LN350@delete_edg:

; 1643 :             { /* see if orientable and cancellable */
; 1644 :               if ( orientable )

	test	ebx, ebx
	je	SHORT $LN28@delete_edg

; 1645 :               { /* drop from keep_edge */
; 1646 :                 ameths[j] = ameths[--ea_ptr->method_count];

	movzx	eax, WORD PTR [esi+24]
	dec	eax
	movzx	ecx, ax
	mov	WORD PTR [esi+24], ax
	mov	eax, DWORD PTR _ameths$90299[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _j$90306[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 1647 :               }
; 1648 :               /* else leave alone */
; 1649 :               handled = 1;
; 1650 :               break;
; 1651 :             }
; 1652 :           }
; 1653 :           if ( handled ) continue;

	jmp	SHORT $LN28@delete_edg
$LN20@delete_edg:

; 1658 :             ameths[ea_ptr->method_count++] = -bmeths[i];

	mov	edx, DWORD PTR _ameths$90299[ebp]
	mov	eax, DWORD PTR tv3241[ebp]
	neg	edi
	mov	DWORD PTR [edx+eax*4], edi
$LN434@delete_edg:
	inc	WORD PTR [esi+24]
$LN28@delete_edg:

; 1630 :         int i,j;
; 1631 :         for ( i = 0 ; i < (int)eb_ptr->method_count ; i++ )

	mov	ecx, DWORD PTR _eb_ptr$90296[ebp]
	mov	eax, DWORD PTR _i$90305[ebp]
	movzx	edx, WORD PTR [ecx+24]
	inc	eax
	mov	DWORD PTR _i$90305[ebp], eax
	cmp	eax, edx
	jl	$LL415@delete_edg
	mov	edi, DWORD PTR _web+460
$wasloop$90273:

; 1659 :        } /* end b meth loop */
; 1660 :       } /* end method adjust */
; 1661 :       
; 1662 : wasloop:
; 1663 : 
; 1664 : #ifdef MPI_EVOLVER
; 1665 :       mpi_note_facet_delete(facet,keep_edge,throw_edge);
; 1666 : #endif
; 1667 : 
; 1668 :       /* free structures  */
; 1669 :       if ( !equal_element(a_edge,b_edge) ) 

	mov	eax, DWORD PTR _b_edge$90224[ebp]
	mov	ecx, DWORD PTR _a_edge$90223[ebp]
	or	eax, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	ecx, eax
	je	SHORT $LN18@delete_edg

; 1670 :         free_element(throw_edge);

	mov	eax, DWORD PTR _throw_edge$90227[ebp]
	push	eax
	call	_free_element
	mov	edi, DWORD PTR _web+460
	add	esp, 4
$LN18@delete_edg:

; 1671 :       if ( !valid_id(get_edge_fe(keep_edge)) )  /* get rid of bare edge */

	mov	ecx, DWORD PTR _keep_edge$90226[ebp]
	mov	edx, DWORD PTR _web+124
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	test	eax, eax
	je	SHORT $LN318@delete_edg
$LN319@delete_edg:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN318@delete_edg
	xor	eax, 134217728				; 08000000H
$LN318@delete_edg:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN17@delete_edg

; 1672 :         free_element(keep_edge);

	mov	eax, DWORD PTR _keep_edge$90226[ebp]
	push	eax
	call	_free_element
	mov	edi, DWORD PTR _web+460
	add	esp, 4
$LN17@delete_edg:

; 1673 :       if ( !valid_id(get_vertex_edge(third_v)) ) /* get rid of bare vertex */

	mov	ecx, DWORD PTR _third_v$90196[ebp]
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	test	DWORD PTR [eax+28], 268435456		; 10000000H
	jne	SHORT $LN16@delete_edg

; 1674 :         free_element(third_v);

	mov	ecx, DWORD PTR _third_v$90196[ebp]
	push	ecx
	call	_free_element
	mov	edi, DWORD PTR _web+460
	add	esp, 4
$LN16@delete_edg:

; 1675 :       if ( !equal_element(a,b) ) 

	mov	edx, DWORD PTR tv3057[ebp]

; 1676 :         free_element(a);

	mov	eax, DWORD PTR _a$90216[ebp]
	cmp	DWORD PTR tv3058[ebp], edx

; 1677 :       else

	jne	SHORT $LN435@delete_edg

; 1678 :       { /* get rid of loop edge */
; 1679 :         free_element(get_fe_edge(a));

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
$LN435@delete_edg:
	push	eax
	call	_free_element

; 1680 :       }
; 1681 :       free_element(b);

	mov	eax, DWORD PTR _b$90217[ebp]
	add	esp, 4
	push	eax
	call	_free_element

; 1682 :       
; 1683 :       if ( valid_id(facet) )

	mov	eax, DWORD PTR _facet$90225[ebp]
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN13@delete_edg

; 1684 :         free_element(facet); /*  also takes care of body facet links */

	push	eax
	call	_free_element
	add	esp, 4
$LN13@delete_edg:

; 1685 : 
; 1686 :          
; 1687 :       if ( everything_quantities_flag && (get_eattr(keep_edge) 
; 1688 :              & (BOUNDARY|CONSTRAINT)) )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN12@delete_edg
	mov	ecx, DWORD PTR _web+124
	mov	esi, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1152				; 00000480H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN12@delete_edg

; 1689 :       { /* kludge to correct for getting edge content integral back */
; 1690 :         fixup_edge_content_meths(keep_edge);

	mov	edx, DWORD PTR _keep_edge$90226[ebp]
	push	edx
	call	_fixup_edge_content_meths
	add	esp, 4
$LN12@delete_edg:

; 1691 : 
; 1692 :       }
; 1693 :     
; 1694 :       
; 1695 :    }
; 1696 :    next_base = get_next_facet(base_fe);

	cmp	DWORD PTR tv2816[ebp], 0
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR tv2819[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	je	SHORT $LN325@delete_edg
	mov	esi, DWORD PTR [edx+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN324@delete_edg
$LN325@delete_edg:
	mov	esi, DWORD PTR [edx+40]
$LN324@delete_edg:

; 1697 :    free_element(base_fe);

	mov	eax, DWORD PTR _base_fe$[ebp]
	push	eax
	call	_free_element
	add	esp, 4

; 1698 :    base_fe = next_base;

	mov	DWORD PTR _base_fe$[ebp], esi

; 1699 :    if ( equal_id(base_fe,first_fe) ) base_fe = NULLID;

	cmp	esi, DWORD PTR _first_fe$[ebp]
	jne	SHORT $LN11@delete_edg
	mov	DWORD PTR _base_fe$[ebp], 0
$LN11@delete_edg:

; 1412 :   while ( valid_id(base_fe) )

	test	DWORD PTR _base_fe$[ebp], 268435456	; 10000000H
	jne	$LL82@delete_edg
$LN81@delete_edg:

; 1700 :   }  /* end facets around short edge loop */
; 1701 : 
; 1702 :   if ( !equal_id(elim_v,keep_v) )    /* see note above */

	mov	eax, DWORD PTR _elim_v$[ebp]
	mov	edi, DWORD PTR _keep_v$[ebp]
	cmp	eax, edi
	je	SHORT $LN10@delete_edg

; 1703 :      free_element(elim_v);

	push	eax
	call	_free_element
	add	esp, 4
$LN10@delete_edg:

; 1704 :   if ( !valid_id(get_vertex_edge(keep_v)) ) /* get rid of bare vertex */

	mov	ecx, DWORD PTR _web+12
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	test	DWORD PTR [eax+28], 268435456		; 10000000H
	jne	SHORT $LN9@delete_edg

; 1705 :   { free_element(keep_v);

	push	edi
	call	_free_element
	add	esp, 4

; 1706 :     retval = 1; 
; 1707 :     goto delete_edge_exit;

	jmp	$delete_edge_exit$90343
$LN9@delete_edg:

; 1708 :   }
; 1709 : 
; 1710 : 
; 1711 :       /* note: short_edge cannot be eliminated here since caller
; 1712 :           has to use it to continue edge generation.  Caller 
; 1713 :           cannot save next edge before calling, since this routine
; 1714 :           frees other edges, which might include the saved one. 
; 1715 :       */
; 1716 : 
; 1717 :  if ( web.representation == STRING && everything_quantities_flag &&
; 1718 :     (get_vattr(keep_v) & (BOUNDARY|CONSTRAINT)) )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN392@delete_edg
	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN392@delete_edg
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1152				; 00000480H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN392@delete_edg

; 1719 :  { /* kludge to correct for getting edge content integral back */
; 1720 :     fixup_vertex_content_meths(keep_v);

	push	edi
	call	_fixup_vertex_content_meths
	add	esp, 4
$LN392@delete_edg:

; 1721 :  }
; 1722 : 
; 1723 :  if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	SHORT $delete_edge_exit$90343

; 1724 :   { /* fix up adjacent midpoints  */
; 1725 :     edge_id start_e = get_vertex_edge(keep_v);

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [esi+edx]
	mov	edi, DWORD PTR [eax+28]

; 1726 :     edge_id ea = start_e;
; 1727 :     int bailcount = 0;

	xor	ebx, ebx
	mov	DWORD PTR _start_e$90349[ebp], edi

; 1728 : 
; 1729 :     if ( valid_id(ea) )

	test	edi, 268435456				; 10000000H
	je	SHORT $delete_edge_exit$90343
	mov	eax, DWORD PTR _web+124
	npad	8
$LL5@delete_edg:

; 1730 :     { do
; 1731 :       { new_vertex_average(get_edge_midv(ea),VOLKEEP);

	mov	edx, DWORD PTR _web+216
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+304]
	mov	eax, DWORD PTR [ecx+edx+8]
	push	1
	push	eax
	call	_new_vertex_average

; 1732 :         ea = get_next_tail_edge(ea);

	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [esi+eax]
	shr	edi, 27					; 0000001bH

; 1733 :         if ( bailcount++ > 1000 ) break;

	mov	edx, ebx
	and	edi, 1
	mov	edi, DWORD PTR [ecx+edi*4+32]
	add	esp, 8
	inc	ebx
	cmp	edx, 1000				; 000003e8H
	jg	SHORT $delete_edge_exit$90343

; 1734 :       } while ( !equal_id(ea,start_e) );

	cmp	edi, DWORD PTR _start_e$90349[ebp]
	jne	SHORT $LL5@delete_edg
$delete_edge_exit$90343:

; 1735 :     }
; 1736 :   }
; 1737 :   retval = 1;
; 1738 : 
; 1739 : delete_edge_exit:
; 1740 :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$90132[ebp], 0
	je	SHORT $LN1@delete_edg
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@delete_edg:

; 1741 : 
; 1742 :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	pop	ebx
	pop	edi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 1743 :   return retval;

	mov	eax, 1
	pop	esi

; 1744 : } /* end delete_edge() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN140@delete_edg:

; 1236 :   }
; 1237 :   else 
; 1238 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN135@delete_edg

; 1239 :     { sprintf(msg,"Can't delete edge %s due to conflicting constraints, boundaries, or fixedness.\n",ELNAME(short_edge));

	test	DWORD PTR _short_edge$[ebp], 268435456	; 10000000H
	je	SHORT $LN171@delete_edg
	mov	ecx, DWORD PTR tv2627[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN172@delete_edg
$LN171@delete_edg:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN172@delete_edg:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0FA@PFANEEBK@Can?8t?5delete?5edge?5?$CFs?5due?5to?5conf@
	push	edx
	call	_sprintf

; 1240 :              outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
$LN135@delete_edg:

; 1241 :     }
; 1242 :     return 0; /* can't safely eliminate edge */

	pop	ebx
	pop	edi
	xor	eax, eax
	pop	esi

; 1744 : } /* end delete_edge() */

	mov	esp, ebp
	pop	ebp
	ret	0
_delete_edge ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@EICPDLDL@Must?5have?5positive?5minimum?5lengt@ ; `string'
PUBLIC	_articulate
EXTRN	_simplex_long_edges:PROC
;	COMDAT ??_C@_0CE@EICPDLDL@Must?5have?5positive?5minimum?5lengt@
CONST	SEGMENT
??_C@_0CE@EICPDLDL@Must?5have?5positive?5minimum?5lengt@ DB 'Must have po'
	DB	'sitive minimum length.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _articulate
_TEXT	SEGMENT
_sentinel$ = -8						; size = 4
_e_id$ = -4						; size = 4
_max_len$ = 8						; size = 8
_articulate PROC					; COMDAT

; 1848 : {

	push	ebp
	mov	ebp, esp

; 1849 :   edge_id e_id,sentinel;
; 1850 :   int new_edge_count = 0;
; 1851 : 
; 1852 :   web.vol_flag = 0;
; 1853 : 
; 1854 :   /* first, a little error check */
; 1855 :   if ( max_len <= 0.0 ) 

	fldz
	sub	esp, 8
	fcomp	QWORD PTR _max_len$[ebp]
	push	edi
	xor	edi, edi
	mov	DWORD PTR _web+896, edi
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN9@articulate

; 1856 :      kb_error(1347,"Must have positive minimum length.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CE@EICPDLDL@Must?5have?5positive?5minimum?5lengt@
	push	1347					; 00000543H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN9@articulate:

; 1857 : 
; 1858 :   if ( web.representation == SIMPLEX ) return simplex_long_edges(max_len);

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN8@articulate
	fld	QWORD PTR _max_len$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_simplex_long_edges
	add	esp, 8
	pop	edi

; 1880 : } // end articulate()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@articulate:
	push	esi

; 1859 : 
; 1860 :   ENTER_GRAPH_MUTEX;

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN7@articulate
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	esi, 1
	jmp	SHORT $LN6@articulate
$LN7@articulate:
	xor	esi, esi
$LN6@articulate:

; 1861 : 
; 1862 :   /* main loop over all edges */
; 1863 :   e_id = NULLEDGE;

	mov	eax, DWORD PTR _NULLEDGE

; 1864 :   while ( generate_all(EDGE,&e_id,&sentinel) )

	lea	ecx, DWORD PTR _sentinel$[ebp]
	push	ecx
	lea	edx, DWORD PTR _e_id$[ebp]
	push	edx
	push	1
	mov	DWORD PTR _e_id$[ebp], eax
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@articulate
$LL5@articulate:

; 1865 :   { REAL side_len;  /* actual side length */
; 1866 : 
; 1867 :     calc_edge(e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	push	eax
	call	_calc_edge

; 1868 :     side_len = get_edge_length(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	call	_get_edge_length

; 1869 :     if ( side_len > max_len ) 

	fcomp	QWORD PTR _max_len$[ebp]
	add	esp, 8
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN13@articulate

; 1870 :     {
; 1871 :       edge_refine(e_id);

	mov	edx, DWORD PTR _e_id$[ebp]
	push	edx
	call	_edge_refine
	add	esp, 4

; 1872 :       new_edge_count++;

	inc	edi
$LN13@articulate:

; 1864 :   while ( generate_all(EDGE,&e_id,&sentinel) )

	lea	eax, DWORD PTR _sentinel$[ebp]
	push	eax
	lea	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	1
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LL5@articulate
$LN4@articulate:

; 1873 :     }
; 1874 :   }
; 1875 : 
; 1876 :   LEAVE_GRAPH_MUTEX;

	test	esi, esi
	pop	esi
	je	SHORT $LN2@articulate
	mov	edx, DWORD PTR _graphmutex
	push	edx
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN2@articulate:

; 1877 : 
; 1878 :   if ( new_edge_count > 0 ) top_timestamp = ++global_timestamp;

	test	edi, edi
	jle	SHORT $LN1@articulate
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN1@articulate:

; 1879 :     return new_edge_count;

	mov	eax, edi
	pop	edi

; 1880 : } // end articulate()

	mov	esp, ebp
	pop	ebp
	ret	0
_articulate ENDP
_TEXT	ENDS
PUBLIC	__real@bf50624dd2f1a9fc
PUBLIC	_equiangulate_edge
;	COMDAT __real@bf50624dd2f1a9fc
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@bf50624dd2f1a9fc DQ 0bf50624dd2f1a9fcr	; -0.001
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\trirevis.c
CONST	ENDS
;	COMDAT _equiangulate_edge
_TEXT	SEGMENT
_b$ = -32						; size = 8
_f1$ = -28						; size = 4
_d$ = -24						; size = 8
tv449 = -20						; size = 4
_a$ = -16						; size = 8
tv490 = -12						; size = 4
tv178 = -12						; size = 4
_c$ = -8						; size = 8
_fe_a$ = -4						; size = 4
_e_id$ = 8						; size = 4
_equiangulate_edge PROC					; COMDAT

; 1944 : { facetedge_id fe_a; /* for edge under test */

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1945 :   facetedge_id fe_ai; /* other facetedge of e_id */
; 1946 :   REAL a;  /* length of e_id */
; 1947 :   facetedge_id fe_b,fe_c; /* other sides of one triangle */
; 1948 :   REAL b,c;  /* lengths of other sides of one triangle */
; 1949 :   facetedge_id fe_d,fe_e; /* other sides of other triangle */
; 1950 :   REAL d,e;  /* lengths of other sides of other triangle */
; 1951 :   facet_id f1,f2; 
; 1952 : 
; 1953 :   if ( get_eattr(e_id) & FIXED ) 

	mov	ecx, DWORD PTR _web+124
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv449[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 64					; 00000040H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN22@equiangula
$LN50@equiangula:

; 1954 :     return 0;

	xor	eax, eax
	pop	esi

; 2031 : 
; 2032 : } /* end equiangulate_edge() */ 

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@equiangula:

; 1955 : 
; 1956 :   /* test to be sure edge has exactly two adjacent facets */
; 1957 :   fe_a = get_edge_fe(e_id);

	test	ecx, ecx
	jne	SHORT $LN34@equiangula
	xor	esi, esi
	mov	DWORD PTR _fe_a$[ebp], esi
	jmp	SHORT $LN35@equiangula
$LN34@equiangula:
	mov	ecx, DWORD PTR [ecx+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN33@equiangula
	xor	ecx, 134217728				; 08000000H
$LN33@equiangula:
	mov	DWORD PTR _fe_a$[ebp], ecx
	mov	esi, ecx
$LN35@equiangula:

; 1958 :   if ( !valid_id(fe_a) ) 

	test	esi, 268435456				; 10000000H

; 1959 :     return 0; /* might be bare edge */

	je	SHORT $LN50@equiangula

; 1960 :   fe_ai = get_next_facet(fe_a);

	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	push	edi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN38@equiangula
	mov	edi, DWORD PTR [ecx+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN37@equiangula
$LN38@equiangula:
	mov	edi, DWORD PTR [ecx+40]
$LN37@equiangula:

; 1961 :   if ( equal_id(fe_a,fe_ai) ) 

	cmp	esi, edi

; 1962 :     return 0;

	je	SHORT $LN49@equiangula

; 1963 :   if ( !equal_id(fe_ai,get_prev_facet(fe_a)) ) 

	push	esi
	call	_get_prev_facet
	add	esp, 4
	cmp	edi, eax
	je	SHORT $LN19@equiangula
$LN49@equiangula:
	pop	edi

; 1964 :     return 0;

	xor	eax, eax
	pop	esi

; 2031 : 
; 2032 : } /* end equiangulate_edge() */ 

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@equiangula:
	push	ebx

; 1965 : 
; 1966 :   f1 = get_fe_facet(fe_a);

	push	esi
	call	_get_fe_facet
	mov	edi, eax

; 1967 :   f2 = get_fe_facet(get_next_facet(fe_a));

	push	esi
	mov	DWORD PTR _f1$[ebp], edi
	call	_get_next_facet
	push	eax
	call	_get_fe_facet

; 1968 : 
; 1969 :   /* test for equal density */
; 1970 :   if ( (get_fattr(f1)&DENSITY) || (get_fattr(f2)&DENSITY) )

	mov	ecx, DWORD PTR _web+236
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+ecx]
	mov	ebx, eax
	mov	eax, DWORD PTR [edx+8]
	and	eax, 16					; 00000010H
	xor	esi, esi
	add	esp, 12					; 0000000cH
	or	eax, esi
	jne	SHORT $LN17@equiangula
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 16					; 00000010H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN16@equiangula
	mov	edx, DWORD PTR [edi+ecx]
$LN17@equiangula:

; 1971 :     if ( fabs(get_facet_density(f1) - get_facet_density(f2)) > 1e-10 )

	fld	QWORD PTR [edx+32]
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	fsub	QWORD PTR [eax+32]
	fabs
	fcomp	QWORD PTR __real@3ddb7cdfd9d7bdbb
	fnstsw	ax
	test	ah, 65					; 00000041H

; 1972 :         return 0;

	je	$LN14@equiangula
$LN16@equiangula:

; 1973 : 
; 1974 :   /* test for equal constraints */
; 1975 :   if ( !equal_constr(e_id,f1) || !equal_constr(e_id,f2) )

	mov	ecx, DWORD PTR _f1$[ebp]
	mov	edx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	edx
	call	_equal_constr
	add	esp, 8
	test	eax, eax
	je	$LN14@equiangula
	mov	eax, DWORD PTR _e_id$[ebp]
	push	ebx
	push	eax
	call	_equal_constr
	add	esp, 8
	test	eax, eax
	je	$LN14@equiangula

; 1977 :  
; 1978 :   /* test for equal boundary */
; 1979 :   if ( ( get_edge_boundary(e_id) != get_facet_boundary(f1))
; 1980 :       ||( get_edge_boundary(e_id) != get_facet_boundary(f2)) )

	mov	ecx, DWORD PTR _E_BOUNDARY_ATTR
	test	ecx, ecx
	je	SHORT $LN25@equiangula
	mov	eax, DWORD PTR _dymem
	mov	ebx, DWORD PTR tv449[ebp]
	mov	edx, ecx
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [ebx+eax]
	mov	ebx, DWORD PTR [edx+eax]
	imul	ebx, 136				; 00000088H
	add	ebx, DWORD PTR _web+776
	jmp	SHORT $LN48@equiangula
$LN25@equiangula:
	xor	ebx, ebx
$LN48@equiangula:
	mov	edx, DWORD PTR _F_BOUNDARY_ATTR
	mov	DWORD PTR tv178[ebp], ebx
	test	edx, edx
	je	SHORT $LN27@equiangula
	mov	ebx, DWORD PTR _dymem
	mov	eax, edx
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	ebx, DWORD PTR _web+236
	mov	edi, DWORD PTR [edi+ebx]
	mov	eax, DWORD PTR [eax+edi]
	mov	edi, DWORD PTR _web+776
	imul	eax, 136				; 00000088H
	mov	ebx, DWORD PTR tv178[ebp]
	add	eax, edi
	jmp	SHORT $LN28@equiangula
$LN27@equiangula:
	mov	edi, DWORD PTR _web+776
	xor	eax, eax
$LN28@equiangula:
	cmp	ebx, eax
	jne	$LN14@equiangula
	test	ecx, ecx
	je	SHORT $LN29@equiangula
	mov	eax, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+216
	mov	ebx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+eax+64]
	mov	eax, DWORD PTR tv449[ebp]
	mov	eax, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [ecx+eax]
	imul	ecx, 136				; 00000088H
	add	ecx, edi
	jmp	SHORT $LN30@equiangula
$LN29@equiangula:
	xor	ecx, ecx
$LN30@equiangula:
	test	edx, edx
	je	SHORT $LN31@equiangula
	mov	eax, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+328
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR _web+236
	mov	eax, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [edx+eax]
	imul	eax, 136				; 00000088H
	add	eax, edi
	jmp	SHORT $LN32@equiangula
$LN31@equiangula:
	xor	eax, eax
$LN32@equiangula:
	cmp	ecx, eax
	jne	$LN14@equiangula

; 1981 :     return 0;
; 1982 : 
; 1983 :   /* test equiangularity */
; 1984 :   if ( !did_global_edge_calc ) 

	cmp	DWORD PTR _did_global_edge_calc, 0
	jne	SHORT $LN41@equiangula

; 1985 :     calc_edge(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	call	_calc_edge
	add	esp, 4
$LN41@equiangula:

; 1986 :   a = get_edge_length(e_id);

	mov	edx, DWORD PTR _e_id$[ebp]
	push	edx
	call	_get_edge_length
	fstp	QWORD PTR _a$[ebp]

; 1987 :   fe_b = get_next_edge(fe_a);

	mov	esi, DWORD PTR _fe_a$[ebp]
	push	esi
	call	_get_next_edge
	add	esp, 8

; 1988 :   if ( !did_global_edge_calc ) 

	cmp	DWORD PTR _did_global_edge_calc, 0
	mov	edi, eax
	jne	SHORT $LN10@equiangula

; 1989 :     calc_edge(get_fe_edge(fe_b));

	push	edi
	call	_get_fe_edge
	push	eax
	call	_calc_edge
	add	esp, 8
$LN10@equiangula:

; 1990 :   b = get_edge_length(get_fe_edge(fe_b));

	push	edi
	call	_get_fe_edge
	push	eax
	call	_get_edge_length
	fstp	QWORD PTR _b$[ebp]

; 1991 :   fe_c = get_prev_edge(fe_a);

	push	esi
	call	_get_prev_edge
	add	esp, 12					; 0000000cH

; 1992 :   if ( !did_global_edge_calc ) 

	cmp	DWORD PTR _did_global_edge_calc, 0
	mov	ebx, eax
	jne	SHORT $LN9@equiangula

; 1993 :     calc_edge(get_fe_edge(fe_c));

	push	ebx
	call	_get_fe_edge
	push	eax
	call	_calc_edge
	add	esp, 8
$LN9@equiangula:

; 1994 :   c = get_edge_length(get_fe_edge(fe_c));

	push	ebx
	call	_get_fe_edge
	push	eax
	call	_get_edge_length
	fst	QWORD PTR _c$[ebp]

; 1995 :   if ( b*c == 0.0 ) 

	fmul	QWORD PTR _b$[ebp]
	add	esp, 8
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H

; 1996 :     return 0;

	jnp	$LN14@equiangula

; 1997 :   fe_ai = fe_inverse(get_next_facet(fe_a));

	push	esi
	call	_get_next_facet
	mov	esi, eax
	xor	esi, 134217728				; 08000000H

; 1998 :   fe_d = get_next_edge(fe_ai); 

	push	esi
	call	_get_next_edge
	add	esp, 8

; 1999 :   if ( !did_global_edge_calc ) 

	cmp	DWORD PTR _did_global_edge_calc, 0
	mov	edi, eax
	jne	SHORT $LN7@equiangula

; 2000 :     calc_edge(get_fe_edge(fe_d));

	push	edi
	call	_get_fe_edge
	push	eax
	call	_calc_edge
	add	esp, 8
$LN7@equiangula:

; 2001 :   d = get_edge_length(get_fe_edge(fe_d));

	push	edi
	call	_get_fe_edge
	push	eax
	call	_get_edge_length
	fstp	QWORD PTR _d$[ebp]

; 2002 :   fe_e = get_prev_edge(fe_ai); 

	push	esi
	call	_get_prev_edge
	add	esp, 12					; 0000000cH

; 2003 :   if ( !did_global_edge_calc ) 

	cmp	DWORD PTR _did_global_edge_calc, 0
	mov	esi, eax
	jne	SHORT $LN6@equiangula

; 2004 :     calc_edge(get_fe_edge(fe_e));

	push	esi
	call	_get_fe_edge
	push	eax
	call	_calc_edge
	add	esp, 8
$LN6@equiangula:

; 2005 :   e = get_edge_length(get_fe_edge(fe_e));

	push	esi
	call	_get_fe_edge
	push	eax
	call	_get_edge_length

; 2006 :   if ( e*d == 0.0 ) 

	fld	ST(0)
	fld	QWORD PTR _d$[ebp]
	add	esp, 8
	fmul	ST(1), ST(0)
	fldz
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@equiangula
	fstp	ST(1)
	fstp	ST(0)
$LN14@equiangula:

; 1976 :     return 0;

	pop	ebx
	pop	edi
	xor	eax, eax
	pop	esi

; 2031 : 
; 2032 : } /* end equiangulate_edge() */ 

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@equiangula:

; 2007 :     return 0;
; 2008 :   if ( (b*b + c*c - a*a)/b/c + (d*d + e*e - a*a)/d/e > -0.001 )

	fld	QWORD PTR _a$[ebp]
	fmul	ST(0), ST(0)
	fld	ST(2)
	fmul	ST(0), ST(3)
	fld	ST(2)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(1)
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fdivrp	ST(2), ST(0)
	fld	QWORD PTR _c$[ebp]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fld	QWORD PTR _b$[ebp]
	fld	ST(0)
	fmul	ST(0), ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fsubrp	ST(3), ST(0)
	fdivp	ST(2), ST(0)
	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fcomp	QWORD PTR __real@bf50624dd2f1a9fc
	fnstsw	ax
	test	ah, 65					; 00000041H

; 2009 :       return 0;

	je	SHORT $LN14@equiangula

; 2010 :                                          /* -0.01 prevents cycling */
; 2011 : 
; 2012 :   /* test acuteness ??? (fix 0.0001 to make scale invariant)*/
; 2013 : /*        if ( a*a + d*d <= e*e + 0.0001 ) return 0;
; 2014 :         if ( a*a + e*e <= d*d + 0.0001 ) return 0;
; 2015 :         if ( a*a + b*b <= c*c + 0.0001 ) return 0;
; 2016 :         if ( a*a + c*c <= b*b + 0.0001 ) return 0;
; 2017 :         if ( a*a + d*d <= e*e + 0.0001 ) return 0;
; 2018 : */
; 2019 :   /* may want to switch, but test that opposite vertices are different */
; 2020 :   if ( !force_edgeswap_flag )

	cmp	DWORD PTR _force_edgeswap_flag, 0
	jne	SHORT $LN42@equiangula

; 2021 :   {
; 2022 :     if ( equal_id(get_fe_tailv(fe_c),get_fe_headv(fe_d)) ) 

	push	edi
	call	_get_fe_edge
	push	eax
	call	_get_edge_headv
	push	ebx
	mov	esi, eax
	call	_get_fe_edge
	push	eax
	call	_get_edge_tailv
	add	esp, 16					; 00000010H
	cmp	eax, esi

; 2023 :         return 0;

	je	SHORT $LN14@equiangula

; 2024 :     if ( eartest(get_fe_tailv(fe_c),get_fe_headv(fe_d), get_edge_tailv(e_id),
; 2025 :           get_edge_headv(e_id)) ) 

	mov	esi, DWORD PTR _e_id$[ebp]
	push	esi
	call	_get_edge_headv
	add	esp, 4
	push	eax
	push	esi
	call	_get_edge_tailv
	add	esp, 4
	push	eax
	push	edi
	call	_get_fe_edge
	push	eax
	call	_get_edge_headv
	add	esp, 8
	push	eax
	push	ebx
	call	_get_fe_edge
	push	eax
	call	_get_edge_tailv
	add	esp, 8
	push	eax
	call	_eartest
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@equiangula

; 1976 :     return 0;

	pop	ebx
	pop	edi
	xor	eax, eax
	pop	esi

; 2031 : 
; 2032 : } /* end equiangulate_edge() */ 

	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@equiangula:

; 2024 :     if ( eartest(get_fe_tailv(fe_c),get_fe_headv(fe_d), get_edge_tailv(e_id),
; 2025 :           get_edge_headv(e_id)) ) 

	mov	esi, DWORD PTR _e_id$[ebp]
$LN1@equiangula:

; 2026 :        return 0;
; 2027 :   }
; 2028 : 
; 2029 :   /* if we are here, we want to switch diagonals */
; 2030 :   return do_edgeswap(e_id);

	push	esi
	call	_do_edgeswap
	add	esp, 4
	pop	ebx
	pop	edi
	pop	esi

; 2031 : 
; 2032 : } /* end equiangulate_edge() */ 

	mov	esp, ebp
	pop	ebp
	ret	0
_equiangulate_edge ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@JFBHJHPK@Cannot?5equiangulate?5string?5model@ ; `string'
PUBLIC	??_C@_0CF@HECBANGM@Cannot?5equiangulate?5LAGRANGE?5mod@ ; `string'
PUBLIC	_equiangulate
EXTRN	_proc_int_ret:BYTE
EXTRN	_thread_launch:PROC
EXTRN	_threadflag:DWORD
EXTRN	_simplex_equiangulate:PROC
;	COMDAT ??_C@_0CD@JFBHJHPK@Cannot?5equiangulate?5string?5model@
CONST	SEGMENT
??_C@_0CD@JFBHJHPK@Cannot?5equiangulate?5string?5model@ DB 'Cannot equian'
	DB	'gulate string model.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HECBANGM@Cannot?5equiangulate?5LAGRANGE?5mod@
CONST	SEGMENT
??_C@_0CF@HECBANGM@Cannot?5equiangulate?5LAGRANGE?5mod@ DB 'Cannot equian'
	DB	'gulate LAGRANGE model.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _equiangulate
_TEXT	SEGMENT
_sentinel$ = -12					; size = 4
_switchcount$ = -8					; size = 4
_e_id$ = -4						; size = 4
_equiangulate PROC					; COMDAT

; 2056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 2057 :   int switchcount = 0;

	xor	edi, edi

; 2058 :   edge_id e_id;  /* edge being examined */
; 2059 :   edge_id sentinel;
; 2060 : 
; 2061 :   if ( web.modeltype == LAGRANGE )

	mov	esi, 3
	mov	DWORD PTR _switchcount$[ebp], edi
	cmp	DWORD PTR _web+628, esi
	jne	SHORT $LN32@equiangula@2

; 2062 :      kb_error(1348,"Cannot equiangulate LAGRANGE model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CF@HECBANGM@Cannot?5equiangulate?5LAGRANGE?5mod@
	push	1348					; 00000544H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN32@equiangula@2:

; 2063 : 
; 2064 :   if ( web.dimension == 1 )

	mov	ebx, 1
	cmp	DWORD PTR _web+620, ebx
	jne	SHORT $LN19@equiangula@2

; 2065 :      kb_error(2200,"Cannot equiangulate string model.\n",RECOVERABLE);

	push	ebx
	push	OFFSET ??_C@_0CD@JFBHJHPK@Cannot?5equiangulate?5string?5model@
	push	2200					; 00000898H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN19@equiangula@2:

; 2066 : 
; 2067 :   if ( web.representation == SIMPLEX ) {  return simplex_equiangulate(); }

	cmp	DWORD PTR _web+624, esi
	jne	SHORT $LN18@equiangula@2
	call	_simplex_equiangulate
	pop	edi
	pop	esi
	pop	ebx

; 2096 : } // end equiangulate()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@equiangula@2:

; 2068 :   
; 2069 :   web.vol_flag = 0;

	mov	DWORD PTR _web+896, edi

; 2070 : 
; 2071 :   if ( threadflag )

	cmp	DWORD PTR _threadflag, edi
	je	SHORT $LN17@equiangula@2

; 2072 :     thread_launch(TH_CALC_EDGES,EDGE);

	push	ebx
	push	16					; 00000010H
	call	_thread_launch
	add	esp, 8

; 2073 :   else

	jmp	SHORT $LN13@equiangula@2
$LN17@equiangula@2:

; 2074 :   { MFOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+160
	mov	DWORD PTR _e_id$[ebp], ecx
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN13@equiangula@2
	mov	esi, DWORD PTR _web+124
$LL15@equiangula@2:
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, ebx
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN14@equiangula@2

; 2075 :       calc_edge(e_id);

	push	ecx
	call	_calc_edge
	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	esi, DWORD PTR _web+124
	add	esp, 4
$LN14@equiangula@2:

; 2074 :   { MFOR_ALL_EDGES(e_id)

	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR _e_id$[ebp], ecx
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL15@equiangula@2
$LN13@equiangula@2:

; 2076 :   }
; 2077 :   did_global_edge_calc = 1;
; 2078 : 
; 2079 :   /* main loop through edges */
; 2080 :   ENTER_GRAPH_MUTEX;

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR _did_global_edge_calc, ebx
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN10@equiangula@2
	push	edi
	push	100000					; 000186a0H
	push	edi
	push	OFFSET _graphmutex
	push	ebx
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	jmp	SHORT $LN9@equiangula@2
$LN10@equiangula@2:
	xor	ebx, ebx
$LN9@equiangula@2:

; 2081 :   if ( threadflag )

	cmp	DWORD PTR _threadflag, edi
	je	SHORT $LN8@equiangula@2

; 2082 :   { int i;
; 2083 :     thread_launch(TH_EQUIANGULATE,EDGE);

	push	1
	push	12					; 0000000cH
	xor	esi, esi
	call	_thread_launch

; 2084 :     for ( i = 0 ; i < nprocs ; i++ )

	mov	edx, DWORD PTR _nprocs
	add	esp, 8
	xor	eax, eax
	cmp	edx, 2
	jl	SHORT $LC30@equiangula@2
	lea	ecx, DWORD PTR [edx-1]
	npad	4
$LL31@equiangula@2:

; 2085 :       switchcount += proc_int_ret[i];

	add	esi, DWORD PTR _proc_int_ret[eax*4]
	add	edi, DWORD PTR _proc_int_ret[eax*4+4]
	add	eax, 2
	cmp	eax, ecx
	jl	SHORT $LL31@equiangula@2
$LC30@equiangula@2:

; 2084 :     for ( i = 0 ; i < nprocs ; i++ )

	cmp	eax, edx
	jge	SHORT $LN33@equiangula@2

; 2085 :       switchcount += proc_int_ret[i];

	mov	edx, DWORD PTR _proc_int_ret[eax*4]
	mov	DWORD PTR _switchcount$[ebp], edx
$LN33@equiangula@2:

; 2086 :   }
; 2087 :   else

	add	esi, edi
	add	DWORD PTR _switchcount$[ebp], esi
	xor	edi, edi
	jmp	SHORT $LN2@equiangula@2
$LN8@equiangula@2:

; 2088 :   { e_id = NULLEDGE;

	mov	eax, DWORD PTR _NULLEDGE

; 2089 :     while ( generate_all(EDGE,&e_id,&sentinel) )

	lea	ecx, DWORD PTR _sentinel$[ebp]
	push	ecx
	lea	edx, DWORD PTR _e_id$[ebp]
	push	edx
	push	1
	mov	DWORD PTR _e_id$[ebp], eax
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@equiangula@2
	npad	6
$LL3@equiangula@2:

; 2090 :       switchcount += equiangulate_edge(e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	push	eax
	call	_equiangulate_edge
	add	DWORD PTR _switchcount$[ebp], eax
	lea	ecx, DWORD PTR _sentinel$[ebp]
	push	ecx
	lea	edx, DWORD PTR _e_id$[ebp]
	push	edx
	push	1
	call	_generate_all
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LL3@equiangula@2
$LN2@equiangula@2:

; 2091 :   }
; 2092 :   LEAVE_GRAPH_MUTEX;

	cmp	ebx, edi
	je	SHORT $LN1@equiangula@2
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, edi
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@equiangula@2:

; 2093 : 
; 2094 :   did_global_edge_calc = 0;
; 2095 :   return switchcount;

	mov	eax, DWORD PTR _switchcount$[ebp]
	mov	DWORD PTR _did_global_edge_calc, edi
	pop	edi
	pop	esi
	pop	ebx

; 2096 : } // end equiangulate()

	mov	esp, ebp
	pop	ebp
	ret	0
_equiangulate ENDP
_TEXT	ENDS
PUBLIC	_thread_equiangulate
; Function compile flags: /Ogtp
;	COMDAT _thread_equiangulate
_TEXT	SEGMENT
tv205 = -20						; size = 4
_data$ = -16						; size = 4
tv136 = -12						; size = 4
_count$ = -8						; size = 4
_maxstage$90572 = -4					; size = 4
_thread_equiangulate PROC				; COMDAT

; 2106 : { int count = 0;

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2107 :   struct thread_data *data = GET_THREAD_DATA;

	mov	eax, DWORD PTR _thread_data_key
	push	ebx
	push	esi
	push	edi
	xor	edi, edi
	push	eax
	mov	DWORD PTR _count$[ebp], edi
	call	_win_get_thread_data

; 2108 : 
; 2109 :   THREAD_FOR_ALL_NEW(EDGE,
; 2110 :       { 
; 2111 :           count += equiangulate_edge(*idptr);
; 2112 :       }
; 2113 :   )

	mov	ecx, DWORD PTR _thread_data_key
	push	ecx
	mov	DWORD PTR _data$[ebp], eax
	call	_win_get_thread_data
	mov	edx, DWORD PTR _nprocs
	mov	ebx, eax
	mov	esi, DWORD PTR [ebx]
	dec	edx
	add	esp, 8
	cmp	esi, edx
	jne	SHORT $LN11@thread_equ
	xor	eax, eax
	jmp	SHORT $LN12@thread_equ
$LN11@thread_equ:
	lea	eax, DWORD PTR [esi+1]
$LN12@thread_equ:
	cmp	esi, edi
	jne	SHORT $LN13@thread_equ
	mov	ecx, DWORD PTR _max_thread_stages
	inc	ecx
	mov	DWORD PTR _maxstage$90572[ebp], ecx
	jmp	SHORT $LN14@thread_equ
$LN13@thread_equ:
	mov	edx, DWORD PTR _max_thread_stages
	mov	DWORD PTR _maxstage$90572[ebp], edx
$LN14@thread_equ:
	imul	esi, 548				; 00000224H
	add	esi, DWORD PTR _thread_stages
	mov	DWORD PTR [esi+540], edi
	mov	ecx, DWORD PTR [esi+540]
	cmp	ecx, DWORD PTR _maxstage$90572[ebp]
	jge	$LN20@thread_equ
	imul	eax, 548				; 00000224H
	add	eax, 540				; 0000021cH
	mov	DWORD PTR tv205[ebp], eax
	npad	7
$LL5@thread_equ:
	mov	edx, DWORD PTR _thread_stages
	mov	eax, DWORD PTR tv205[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR [esi+540]
	cmp	ecx, edx
	jl	SHORT $LL5@thread_equ
	mov	ecx, DWORD PTR [esi+540]
	rdtsc
	mov	DWORD PTR [ebx+ecx*8+1808], eax
	mov	DWORD PTR [ebx+ecx*8+1812], edx
	mov	eax, DWORD PTR [esi+540]
	mov	ecx, DWORD PTR [esi+540]
	mov	edi, DWORD PTR [esi+eax*4+36]
	mov	eax, DWORD PTR [esi+ecx*4+216]
	test	eax, eax
	jle	SHORT $LN1@thread_equ
	mov	DWORD PTR tv136[ebp], eax
	npad	6
$LL3@thread_equ:
	mov	edx, DWORD PTR [edi]
	push	edx
	call	_equiangulate_edge
	add	DWORD PTR _count$[ebp], eax
	add	esp, 4
	add	edi, 4
	dec	DWORD PTR tv136[ebp]
	jne	SHORT $LL3@thread_equ
$LN1@thread_equ:
	mov	ecx, DWORD PTR [esi+540]
	rdtsc
	mov	DWORD PTR [ebx+ecx*8+1880], eax
	mov	DWORD PTR [ebx+ecx*8+1884], edx
	inc	DWORD PTR [esi+540]
	mov	eax, DWORD PTR [esi+540]
	cmp	eax, DWORD PTR _maxstage$90572[ebp]
	jl	$LL5@thread_equ

; 2114 : 
; 2115 :   proc_int_ret[data->worker_id] = count;

	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _count$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR _proc_int_ret[edx*4], eax
	pop	ebx

; 2116 : 
; 2117 : } // end thread_equiangulate()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@thread_equ:

; 2114 : 
; 2115 :   proc_int_ret[data->worker_id] = count;

	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _proc_int_ret[edx*4], edi
	pop	edi
	pop	esi
	pop	ebx

; 2116 : 
; 2117 : } // end thread_equiangulate()

	mov	esp, ebp
	pop	ebp
	ret	0
_thread_equiangulate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@NEFHNHPB@Couldn?8t?5weed?5facet?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BB@DPJMLADA@Weeded?5facet?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0DG@PPNJKCHK@Areaweed?5not?5implemented?5for?5sim@ ; `string'
PUBLIC	??_C@_0CK@FFKJLJHN@Can?5only?5do?5area?5weed?5on?5soapfil@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_areaweed
;	COMDAT ??_C@_0BI@NEFHNHPB@Couldn?8t?5weed?5facet?5?$CFs?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BI@NEFHNHPB@Couldn?8t?5weed?5facet?5?$CFs?6?$AA@ DB 'Couldn''t wee'
	DB	'd facet %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DPJMLADA@Weeded?5facet?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BB@DPJMLADA@Weeded?5facet?5?$CFs?6?$AA@ DB 'Weeded facet %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@PPNJKCHK@Areaweed?5not?5implemented?5for?5sim@
CONST	SEGMENT
??_C@_0DG@PPNJKCHK@Areaweed?5not?5implemented?5for?5sim@ DB 'Areaweed not'
	DB	' implemented for simplex representation.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FFKJLJHN@Can?5only?5do?5area?5weed?5on?5soapfil@
CONST	SEGMENT
??_C@_0CK@FFKJLJHN@Can?5only?5do?5area?5weed?5on?5soapfil@ DB 'Can only d'
	DB	'o area weed on soapfilm model.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\trirevis.c
CONST	ENDS
;	COMDAT _areaweed
_TEXT	SEGMENT
_sentinel$ = -208					; size = 4
tv653 = -204						; size = 4
_did_graphlock_here$89689 = -200			; size = 4
_weedcount$ = -196					; size = 4
_f_id$ = -192						; size = 4
_side$89695 = -188					; size = 144
_sside$89696 = -44					; size = 24
_fe$89698 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_min_area$ = 8						; size = 8
_areaweed PROC						; COMDAT

; 581  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi

; 582  :   facet_id f_id;  /* facet being worked on */
; 583  :   facet_id sentinel;
; 584  :   int weedcount = 0; /* number of facets created */

	xor	esi, esi

; 585  : 
; 586  :   if ( web.representation != SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	push	edi
	mov	DWORD PTR _weedcount$[ebp], esi
	je	SHORT $LN69@areaweed

; 587  :      kb_error(1339,"Can only do area weed on soapfilm model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CK@FFKJLJHN@Can?5only?5do?5area?5weed?5on?5soapfil@
	push	1339					; 0000053bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN69@areaweed:

; 588  : 
; 589  :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN26@areaweed

; 590  :       kb_error(1340,"Areaweed not implemented for simplex representation.\n",
; 591  :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DG@PPNJKCHK@Areaweed?5not?5implemented?5for?5sim@
	push	1340					; 0000053cH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN26@areaweed:

; 592  : 
; 593  :   web.vol_flag = 0;
; 594  : 
; 595  :   /* first, unmark all NEWFACET attributes */
; 596  :   FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	mov	DWORD PTR _web+896, esi
	mov	DWORD PTR _f_id$[ebp], edx
	test	edx, 268435456				; 10000000H
	je	SHORT $LN70@areaweed
	mov	edi, DWORD PTR _web+236
	mov	ebx, -5					; fffffffbH
	npad	3
$LL75@areaweed:
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN24@areaweed

; 597  :       unset_attr(f_id,NEWFACET);

	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [ecx+12]
	and	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR _f_id$[ebp]
	mov	edi, DWORD PTR _web+236
$LN24@areaweed:

; 592  : 
; 593  :   web.vol_flag = 0;
; 594  : 
; 595  :   /* first, unmark all NEWFACET attributes */
; 596  :   FOR_ALL_FACETS(f_id)

	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _f_id$[ebp], edx
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL75@areaweed
$LN70@areaweed:

; 598  : 
; 599  :   ENTER_GRAPH_MUTEX;

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN20@areaweed
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89689[ebp], 1
	jmp	SHORT $LN19@areaweed
$LN20@areaweed:
	mov	DWORD PTR _did_graphlock_here$89689[ebp], 0
$LN19@areaweed:

; 600  : 
; 601  :   /* main loop sweeping over all triangles */
; 602  :   f_id = NULLFACET;

	mov	ecx, DWORD PTR _NULLFACET

; 603  :   while ( generate_all(FACET,&f_id,&sentinel) )

	lea	edx, DWORD PTR _sentinel$[ebp]
	push	edx
	lea	eax, DWORD PTR _f_id$[ebp]
	push	eax
	push	2
	mov	DWORD PTR _f_id$[ebp], ecx
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN17@areaweed
	npad	9
$LL18@areaweed:

; 604  :   { REAL side[FACET_EDGES][MAXCOORD];  /* side vector */
; 605  :     REAL sside[FACET_EDGES]; /* squares of side lengths */
; 606  :     REAL area;      /* area of triangle */
; 607  :     facetedge_id fe[FACET_EDGES+1]; /* edges of triangle */
; 608  :     edge_id e_id;
; 609  :     int i;              /* side number */
; 610  :     int elimcount;
; 611  : #ifdef _DEBUGXX
; 612  :     if ( (f_id & 0xFFFFFF) == 0xb3b )
; 613  :       break;
; 614  : #endif
; 615  :     /* skip already modified triangles */
; 616  :     if ( get_fattr(f_id) & NEWFACET )

	mov	esi, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 4
	xor	edx, edx
	or	eax, edx
	jne	$LN72@areaweed

; 617  :        continue;
; 618  : 
; 619  :     /* find sides and area */
; 620  :     fe[0] = get_facet_fe(f_id);

	test	esi, 268435456				; 10000000H
	je	SHORT $LN40@areaweed
$LN41@areaweed:
	mov	eax, DWORD PTR [ecx+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN40@areaweed
	xor	eax, 134217728				; 08000000H
$LN40@areaweed:
	mov	ecx, DWORD PTR _web+460
	mov	DWORD PTR _fe$89698[ebp], eax

; 621  :     for ( i = 0 ; i < FACET_EDGES ; i++ ) 

	xor	edi, edi
	lea	ebx, DWORD PTR _side$89695[ebp]
$LL71@areaweed:

; 622  :     { get_fe_side(fe[i],side[i]);

	mov	esi, DWORD PTR _fe$89698[ebp+edi*4]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	edx, esi
	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR [ecx+20]
	push	ebx
	push	edx
	call	_get_edge_side

; 623  :       sside[i] = SDIM_dot(side[i],side[i]);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	ebx
	push	ebx
	call	_dot
	fstp	QWORD PTR _sside$89696[ebp+edi*8]

; 624  :       fe[i+1] = get_next_edge(fe[i]);

	mov	ecx, DWORD PTR _web+460
	add	esp, 20					; 00000014H
	test	esi, 134217728				; 08000000H
	je	SHORT $LN47@areaweed
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN46@areaweed
$LN47@areaweed:
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [eax+32]
$LN46@areaweed:
	mov	DWORD PTR _fe$89698[ebp+edi*4+4], eax
	inc	edi
	add	ebx, 48					; 00000030H
	cmp	edi, 3
	jl	SHORT $LL71@areaweed

; 625  :     }
; 626  :     
; 627  :     area = get_facet_area(f_id);

	mov	ecx, DWORD PTR _f_id$[ebp]
	push	ecx
	call	_recalc_facet_area

; 628  : 
; 629  :     if ( area > min_area )  /* skip big triangles */

	fld	QWORD PTR _min_area$[ebp]
	mov	edx, DWORD PTR _f_id$[ebp]
	mov	eax, DWORD PTR _web+236
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	fcomp	QWORD PTR [ecx+40]
	add	esp, 4
	fnstsw	ax
	test	ah, 5
	jnp	$LN72@areaweed

; 630  :       continue;  
; 631  : 
; 632  :     /* weed by eliminating shortest side. eliminate obtuse vertex,
; 633  :        the one between the two shortest sides, if possible.
; 634  :        Follow with equiangulation  */
; 635  :     i = (sside[0] < sside[1]) ? 0 : 1;

	fld	QWORD PTR _sside$89696[ebp+8]
	fcomp	QWORD PTR _sside$89696[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN30@areaweed
	xor	ebx, ebx
	jmp	SHORT $LN31@areaweed
$LN30@areaweed:
	mov	ebx, 1
$LN31@areaweed:

; 636  :     i = (sside[i] < sside[2]) ? i : 2;

	fld	QWORD PTR _sside$89696[ebp+16]
	fcomp	QWORD PTR _sside$89696[ebp+ebx*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN33@areaweed
	mov	ebx, 2
$LN33@areaweed:

; 637  :    
; 638  :     e_id = get_fe_edge(fe[i]);

	mov	esi, DWORD PTR _fe$89698[ebp+ebx*4]
	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [ecx+20]

; 639  :     elimcount = delete_edge(e_id);

	push	esi
	call	_delete_edge
	mov	edi, eax
	add	esp, 4

; 640  :     if ( elimcount ) goto elimdone;

	test	edi, edi
	jne	$LN73@areaweed

; 641  : 
; 642  :     if ( sside[(i+1)%3] < sside[(i+2)%3] )

	lea	eax, DWORD PTR [ebx+1]
	cdq
	mov	ecx, 3
	idiv	ecx
	lea	eax, DWORD PTR [ebx+2]
	mov	esi, 3
	mov	ecx, edx
	cdq
	idiv	esi
	mov	DWORD PTR tv653[ebp], ecx
	mov	ebx, edx
	fld	QWORD PTR _sside$89696[ebp+ebx*8]
	fcomp	QWORD PTR _sside$89696[ebp+ecx*8]
	fnstsw	ax
	test	ah, 65					; 00000041H

; 643  :     { e_id = get_fe_edge(fe[(i+1)%3]);

	mov	eax, DWORD PTR _web+460
	jne	SHORT $LN10@areaweed
	mov	esi, DWORD PTR _fe$89698[ebp+ecx*4]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [ecx+20]

; 644  :       elimcount = delete_edge(e_id);

	push	esi
	call	_delete_edge
	mov	edi, eax
	add	esp, 4

; 645  :       if ( elimcount ) goto elimdone;

	test	edi, edi
	jne	$LN73@areaweed

; 646  :       e_id = get_fe_edge(fe[(i+2)%3]);

	mov	esi, DWORD PTR _fe$89698[ebp+ebx*4]
	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [ecx+20]

; 647  :       elimcount = delete_edge(e_id);
; 648  :     }
; 649  :     else

	jmp	SHORT $LN76@areaweed
$LN10@areaweed:

; 650  :     { e_id = get_fe_edge(fe[(i+2)%3]);

	mov	esi, DWORD PTR _fe$89698[ebp+ebx*4]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [ecx+20]

; 651  :       elimcount = delete_edge(e_id);

	push	esi
	call	_delete_edge
	mov	edi, eax
	add	esp, 4

; 652  :       if ( elimcount ) goto elimdone;

	test	edi, edi
	jne	SHORT $LN73@areaweed

; 653  :       e_id = get_fe_edge(fe[(i+1)%3]);

	mov	edx, DWORD PTR tv653[ebp]
	mov	esi, DWORD PTR _fe$89698[ebp+edx*4]
	mov	ecx, DWORD PTR _web+460
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [edx+20]
$LN76@areaweed:

; 654  :       elimcount = delete_edge(e_id);

	push	esi
	call	_delete_edge
	mov	edi, eax
	add	esp, 4
$elimdone$89711:

; 655  :     }
; 656  : elimdone:
; 657  :     if ( elimcount )

	test	edi, edi
	je	SHORT $LN6@areaweed
$LN73@areaweed:

; 658  :     { free_element(e_id);

	push	esi
	call	_free_element
	add	esp, 4

; 659  :       if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN5@areaweed

; 660  :       { sprintf(msg,"Weeded facet %s\n",ELNAME(f_id));

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN34@areaweed
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN35@areaweed
$LN34@areaweed:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN35@areaweed:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BB@DPJMLADA@Weeded?5facet?5?$CFs?6?$AA@
	push	eax
	call	_sprintf

; 661  :         outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
$LN5@areaweed:

; 662  :       }
; 663  :       weedcount += elimcount;

	add	DWORD PTR _weedcount$[ebp], edi
	jmp	SHORT $LN72@areaweed
$LN6@areaweed:

; 664  :     }
; 665  :     else if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN72@areaweed

; 666  :     { sprintf(msg,"Couldn't weed facet %s\n",ELNAME(f_id));

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN36@areaweed
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN37@areaweed
$LN36@areaweed:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN37@areaweed:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BI@NEFHNHPB@Couldn?8t?5weed?5facet?5?$CFs?6?$AA@
	push	edx
	call	_sprintf

; 667  :       outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
$LN72@areaweed:

; 603  :   while ( generate_all(FACET,&f_id,&sentinel) )

	lea	ecx, DWORD PTR _sentinel$[ebp]
	push	ecx
	lea	edx, DWORD PTR _f_id$[ebp]
	push	edx
	push	2
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LL18@areaweed
$LN17@areaweed:

; 668  :     }
; 669  : 
; 670  :   }  /* end main sweep loop */
; 671  : 
; 672  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89689[ebp], 0
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN2@areaweed
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN2@areaweed:

; 673  : 
; 674  :   if ( weedcount > 0 ) top_timestamp = ++global_timestamp;

	mov	ecx, DWORD PTR _weedcount$[ebp]
	test	ecx, ecx
	jle	SHORT $LN68@areaweed
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN68@areaweed:

; 675  :   return weedcount;

	mov	eax, ecx

; 676  : } // end int areaweed()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_areaweed ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@HPHJCDMI@Couldn?8t?5entirely?5delete?5facet?5?$CF@ ; `string'
PUBLIC	??_C@_0BC@HGEKCAFE@Deleted?5facet?5?$CFs?6?$AA@	; `string'
PUBLIC	_string_delete_facet
;	COMDAT ??_C@_0CD@HPHJCDMI@Couldn?8t?5entirely?5delete?5facet?5?$CF@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CD@HPHJCDMI@Couldn?8t?5entirely?5delete?5facet?5?$CF@ DB 'Couldn'''
	DB	't entirely delete facet %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HGEKCAFE@Deleted?5facet?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BC@HGEKCAFE@Deleted?5facet?5?$CFs?6?$AA@ DB 'Deleted facet %s', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\trirevis.c
CONST	ENDS
;	COMDAT _string_delete_facet
_TEXT	SEGMENT
_final_e$ = -20						; size = 4
tv385 = -16						; size = 4
_did_graphlock_here$89778 = -12				; size = 4
_not_done$ = -8						; size = 4
_elimcount$ = -4					; size = 4
_f_id$ = 8						; size = 4
_string_delete_facet PROC				; COMDAT

; 758  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 759  :   facetedge_id fe,start_fe,next_fe; 
; 760  :   edge_id e_id,final_e=NULLID;
; 761  :   int done,not_done=0;              /* side number */
; 762  :   int elimcount=0;
; 763  :   int loop_flag; /* whether edges form closed loop */
; 764  : 
; 765  :   /* find starting point */
; 766  :   fe = get_facet_fe(f_id);

	mov	ecx, DWORD PTR _f_id$[ebp]
	push	ebx
	mov	eax, ecx
	push	edi
	xor	edi, edi
	xor	ebx, ebx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _final_e$[ebp], ebx
	mov	DWORD PTR _not_done$[ebp], edi
	mov	DWORD PTR _elimcount$[ebp], edi
	mov	DWORD PTR tv385[ebp], eax
	je	SHORT $LN30@string_del
	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN30@string_del
	xor	edi, 134217728				; 08000000H
$LN30@string_del:

; 767  :   if ( !valid_id(fe) )

	test	edi, 268435456				; 10000000H
	jne	SHORT $LN23@string_del

; 768  :   { free_element(f_id);

	push	ecx
	call	_free_element
	add	esp, 4
	pop	edi

; 769  :     return 1;

	mov	eax, 1
	pop	ebx

; 827  : } // end string_delete_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@string_del:
	push	esi

; 770  :   }
; 771  : 
; 772  :   ENTER_GRAPH_MUTEX;

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN22@string_del
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89778[ebp], 1
	jmp	SHORT $LN21@string_del
$LN22@string_del:
	mov	DWORD PTR _did_graphlock_here$89778[ebp], ebx
$LN21@string_del:

; 773  : 
; 774  :   loop_flag = 1;
; 775  :   start_fe = fe;
; 776  :   do
; 777  :   { if ( equal_element(get_next_edge(fe),fe) )

	push	edi
	mov	esi, edi
	call	_get_next_edge
	mov	edx, DWORD PTR _web+460
	or	eax, 134217728				; 08000000H
	or	edi, 134217728				; 08000000H
	add	esp, 4
	cmp	eax, edi
	jne	SHORT $LN13@string_del
	npad	4
$LL15@string_del:

; 778  :     { /* end of edge chain */
; 779  :       loop_flag = 0;
; 780  :     }
; 781  :   } while ( !equal_id(fe,start_fe) );
; 782  : 
; 783  :   if ( loop_flag == 0 )
; 784  :   { /* find start of chain */
; 785  :     while ( !equal_element(get_prev_edge(start_fe),start_fe) )

	mov	edi, esi
	shr	edi, 27					; 0000001bH
	and	edi, 1
	je	SHORT $LN35@string_del
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [ecx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN34@string_del
$LN35@string_del:
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+28]
$LN34@string_del:
	mov	ebx, esi
	or	eax, 134217728				; 08000000H
	or	ebx, 134217728				; 08000000H
	cmp	eax, ebx
	je	SHORT $LN60@string_del

; 786  :       start_fe = get_prev_edge(start_fe);

	test	edi, edi
	je	SHORT $LN39@string_del
	mov	esi, DWORD PTR [ecx+32]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LL15@string_del
$LN39@string_del:
	mov	esi, DWORD PTR [ecx+28]
	jmp	SHORT $LL15@string_del
$LN60@string_del:
	mov	ebx, DWORD PTR _final_e$[ebp]

; 787  :   }
; 788  : 
; 789  :   fe = start_fe;

	jmp	SHORT $LN13@string_del
	npad	10
$LL59@string_del:
	mov	edx, DWORD PTR _web+460
$LN13@string_del:

; 790  :   do
; 791  :   { next_fe = get_next_edge(fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN43@string_del
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	edi, DWORD PTR [eax+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN42@string_del
$LN43@string_del:
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [eax+32]
$LN42@string_del:

; 792  :     e_id = get_fe_edge(fe);

	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [eax+20]

; 793  :     if ( valid_id(next_fe) )

	test	edi, 268435456				; 10000000H
	je	SHORT $LN10@string_del

; 794  :       final_e = get_fe_edge(next_fe);

	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ebx, edi
	and	ebx, 134217728				; 08000000H
	xor	ebx, DWORD PTR [edx+20]
$LN10@string_del:

; 795  :     done = delete_edge(e_id);

	push	esi
	call	_delete_edge
	add	esp, 4

; 796  :     if ( done )

	test	eax, eax
	je	SHORT $LN9@string_del

; 797  :     { elimcount++;

	inc	DWORD PTR _elimcount$[ebp]

; 798  :       free_element(e_id);

	push	esi
	call	_free_element
	add	esp, 4
	jmp	SHORT $LN8@string_del
$LN9@string_del:

; 799  :     }
; 800  :     else not_done++;

	inc	DWORD PTR _not_done$[ebp]
$LN8@string_del:

; 801  :     fe = next_fe;
; 802  :   } while ( valid_element(fe) );

	push	edi
	mov	esi, edi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	$LL59@string_del

; 803  : 
; 804  :   // clean up dangling edge maybe left by last deletion
; 805  :   if ( valid_element(final_e) )

	push	ebx
	call	_valid_element
	add	esp, 4
	pop	esi
	test	eax, eax
	je	SHORT $LN61@string_del

; 806  :   { done = delete_edge(final_e);

	push	ebx
	call	_delete_edge
	add	esp, 4

; 807  :     if ( done )

	test	eax, eax
	je	SHORT $LN61@string_del

; 808  :     { elimcount++;

	inc	DWORD PTR _elimcount$[ebp]

; 809  :       free_element(final_e);

	push	ebx
	call	_free_element
	add	esp, 4
$LN61@string_del:

; 810  :     }
; 811  :   }
; 812  : 
; 813  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89778[ebp], 0
	je	SHORT $LN5@string_del
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN5@string_del:

; 814  : 
; 815  :   if ( not_done == 0 )

	cmp	DWORD PTR _not_done$[ebp], 0
	jne	SHORT $LN4@string_del

; 816  :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN62@string_del

; 817  :     { sprintf(msg,"Deleted facet %s\n",ELNAME(f_id));

	cmp	DWORD PTR tv385[ebp], 0
	je	SHORT $LN26@string_del
	mov	eax, DWORD PTR _f_id$[ebp]
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN27@string_del
$LN26@string_del:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN27@string_del:
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BC@HGEKCAFE@Deleted?5facet?5?$CFs?6?$AA@
	push	ecx
	call	_sprintf

; 818  :       outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN62@string_del:

; 819  :     }
; 820  :     return 1;

	pop	edi
	mov	eax, 1
	pop	ebx

; 827  : } // end string_delete_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@string_del:

; 821  :   }
; 822  :   else if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN1@string_del

; 823  :   { sprintf(msg,"Couldn't entirely delete facet %s\n",ELNAME(f_id));

	cmp	DWORD PTR tv385[ebp], 0
	je	SHORT $LN28@string_del
	mov	eax, DWORD PTR _f_id$[ebp]
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN29@string_del
$LN28@string_del:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN29@string_del:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0CD@HPHJCDMI@Couldn?8t?5entirely?5delete?5facet?5?$CF@
	push	eax
	call	_sprintf

; 824  :     outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
$LN1@string_del:

; 825  :   }
; 826  :   return -elimcount;

	mov	eax, DWORD PTR _elimcount$[ebp]
	pop	edi
	neg	eax
	pop	ebx

; 827  : } // end string_delete_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
_string_delete_facet ENDP
_TEXT	ENDS
PUBLIC	_edgeweed
EXTRN	_simplex_tiny_edges:PROC
; Function compile flags: /Ogtp
;	COMDAT _edgeweed
_TEXT	SEGMENT
_sentinel$ = -8						; size = 4
_e_id$ = -4						; size = 4
_min_length$ = 8					; size = 8
_edgeweed PROC						; COMDAT

; 1066 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	edi

; 1067 :   edge_id e_id,sentinel;
; 1068 :   int weedcount = 0;

	xor	edi, edi

; 1069 : 
; 1070 :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN9@edgeweed

; 1071 :      return simplex_tiny_edges(min_length);

	fld	QWORD PTR _min_length$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_simplex_tiny_edges
	add	esp, 8
	pop	edi

; 1098 : } // end edgeweed()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@edgeweed:
	push	esi

; 1072 : 
; 1073 :   web.vol_flag = 0;
; 1074 : 
; 1075 :   /* main loop over all edges */
; 1076 : 
; 1077 :   ENTER_GRAPH_MUTEX;

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR _web+896, edi
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN8@edgeweed
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	esi, 1
	jmp	SHORT $LN7@edgeweed
$LN8@edgeweed:
	xor	esi, esi
$LN7@edgeweed:

; 1078 : 
; 1079 :   e_id = NULLEDGE;

	mov	eax, DWORD PTR _NULLEDGE

; 1080 :   while ( generate_all(EDGE,&e_id,&sentinel) )

	lea	ecx, DWORD PTR _sentinel$[ebp]
	push	ecx
	lea	edx, DWORD PTR _e_id$[ebp]
	push	edx
	push	1
	mov	DWORD PTR _e_id$[ebp], eax
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@edgeweed
$LL6@edgeweed:

; 1081 :   {
; 1082 :     REAL side_len;  /* actual side length */
; 1083 :     int elimcount = 0;
; 1084 : 
; 1085 :     calc_edge(e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	push	eax
	call	_calc_edge

; 1086 :     side_len = get_edge_length(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	call	_get_edge_length

; 1087 : 
; 1088 :     if ( side_len < min_length ) elimcount = delete_edge(e_id);

	fcomp	QWORD PTR _min_length$[ebp]
	add	esp, 8
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN13@edgeweed
	mov	edx, DWORD PTR _e_id$[ebp]
	push	edx
	call	_delete_edge
	add	esp, 4

; 1089 :     if ( elimcount ) 

	test	eax, eax
	je	SHORT $LN13@edgeweed

; 1090 :     { free_element(e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	push	eax
	call	_free_element
	add	esp, 4

; 1091 :       weedcount++ ;

	inc	edi
$LN13@edgeweed:

; 1080 :   while ( generate_all(EDGE,&e_id,&sentinel) )

	lea	ecx, DWORD PTR _sentinel$[ebp]
	push	ecx
	lea	edx, DWORD PTR _e_id$[ebp]
	push	edx
	push	1
	call	_generate_all
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LL6@edgeweed
$LN5@edgeweed:

; 1092 :     }
; 1093 :   }
; 1094 :   LEAVE_GRAPH_MUTEX;

	test	esi, esi
	pop	esi
	je	SHORT $LN2@edgeweed
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN2@edgeweed:

; 1095 : 
; 1096 :   if ( weedcount > 0 ) top_timestamp = ++global_timestamp;

	test	edi, edi
	jle	SHORT $LN1@edgeweed
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN1@edgeweed:

; 1097 :     return weedcount;

	mov	eax, edi
	pop	edi

; 1098 : } // end edgeweed()

	mov	esp, ebp
	pop	ebp
	ret	0
_edgeweed ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@CECNCJAC@Couldn?8t?5delete?5facet?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@NNGGCGKN@Deleting?5facet?5?$CFs?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_delete_facet
EXTRN	_simplex_delete_facet:PROC
;	COMDAT ??_C@_0BK@CECNCJAC@Couldn?8t?5delete?5facet?5?$CFs?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BK@CECNCJAC@Couldn?8t?5delete?5facet?5?$CFs?6?$AA@ DB 'Couldn''t d'
	DB	'elete facet %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NNGGCGKN@Deleting?5facet?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BD@NNGGCGKN@Deleting?5facet?5?$CFs?6?$AA@ DB 'Deleting facet %s', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\trirevis.c
CONST	ENDS
;	COMDAT _delete_facet
_TEXT	SEGMENT
tv456 = -100						; size = 4
_did_graphlock_here$89741 = -96				; size = 4
tv388 = -92						; size = 4
_side$ = -88						; size = 48
_sside$ = -40						; size = 24
_fe$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_f_id$ = 8						; size = 4
_delete_facet PROC					; COMDAT

; 687  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 688  :   REAL side[MAXCOORD];  /* side vector */
; 689  :   REAL sside[FACET_EDGES]; /* squares of side lengths */
; 690  :   facetedge_id fe[FACET_EDGES]; /* edges of triangle */
; 691  :   edge_id e_id;
; 692  :   int i;              /* side number */
; 693  :   int elimcount;
; 694  : 
; 695  :   if ( web.dimension == 1 ) return string_delete_facet(f_id);

	mov	ebx, 1
	cmp	DWORD PTR _web+620, ebx
	jne	SHORT $LN17@delete_fac
	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	call	_string_delete_facet
	add	esp, 4
	pop	ebx

; 745  :   return elimcount;
; 746  : } // end delete_facet()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@delete_fac:

; 696  :   if ( web.representation == SIMPLEX ) return simplex_delete_facet(f_id);

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN16@delete_fac
	mov	ecx, DWORD PTR _f_id$[ebp]
	push	ecx
	call	_simplex_delete_facet
	add	esp, 4
	pop	ebx

; 745  :   return elimcount;
; 746  : } // end delete_facet()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@delete_fac:
	push	esi

; 697  : 
; 698  :   ENTER_GRAPH_MUTEX;

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	push	edi
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN15@delete_fac
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	ebx
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89741[ebp], ebx
	jmp	SHORT $LN14@delete_fac
$LN15@delete_fac:
	mov	DWORD PTR _did_graphlock_here$89741[ebp], 0
$LN14@delete_fac:

; 699  : 
; 700  :   /* find sides */
; 701  :   fe[0] = get_facet_fe(f_id);

	mov	ecx, DWORD PTR _f_id$[ebp]
	mov	eax, ecx
	shr	eax, 28					; 0000001cH
	and	eax, ebx
	mov	DWORD PTR tv388[ebp], eax
	jne	SHORT $LN29@delete_fac
	xor	eax, eax
	jmp	SHORT $LN28@delete_fac
$LN29@delete_fac:
	mov	eax, DWORD PTR _web+236
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edx+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN28@delete_fac
	xor	eax, 134217728				; 08000000H
$LN28@delete_fac:

; 702  :   for ( i = 0 ; i < FACET_EDGES ; i++ ) 

	mov	ecx, DWORD PTR _web+460
	mov	DWORD PTR _fe$[ebp], eax
	xor	edi, edi
$LL55@delete_fac:

; 703  :   {
; 704  :      get_fe_side(fe[i],side);

	mov	esi, DWORD PTR _fe$[ebp+edi*4]
	lea	eax, DWORD PTR _side$[ebp]
	mov	edx, esi
	push	eax
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, esi
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_get_edge_side

; 705  :      sside[i] = SDIM_dot(side,side);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _side$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fstp	QWORD PTR _sside$[ebp+edi*8]

; 706  :      fe[i+1] = get_next_edge(fe[i]);

	mov	ecx, DWORD PTR _web+460
	add	esp, 20					; 00000014H
	test	esi, 134217728				; 08000000H
	je	SHORT $LN35@delete_fac
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN34@delete_fac
$LN35@delete_fac:
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [eax+32]
$LN34@delete_fac:
	mov	DWORD PTR _fe$[ebp+edi*4+4], eax
	add	edi, ebx
	cmp	edi, 3
	jl	SHORT $LL55@delete_fac

; 707  :   }
; 708  : 
; 709  :   /* weed by eliminating shortest side. eliminate obtuse vertex,
; 710  :      the one between the two shortest sides, if possible.
; 711  :   */
; 712  :   i = (sside[0] < sside[1]) ? 0 : 1;

	fld	QWORD PTR _sside$[ebp+8]
	fcomp	QWORD PTR _sside$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN20@delete_fac
	xor	ebx, ebx
$LN20@delete_fac:

; 713  :   i = (sside[i] < sside[2]) ? i : 2;

	fld	QWORD PTR _sside$[ebp+16]
	fcomp	QWORD PTR _sside$[ebp+ebx*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN23@delete_fac
	mov	ebx, 2
$LN23@delete_fac:

; 714  :   e_id = get_fe_edge(fe[i]);

	mov	esi, DWORD PTR _fe$[ebp+ebx*4]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edx*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [eax+20]

; 715  :   elimcount = delete_edge(e_id);

	push	esi
	call	_delete_edge
	mov	edi, eax
	add	esp, 4

; 716  :   if ( elimcount ) goto elimdone;

	test	edi, edi
	jne	$LN51@delete_fac

; 717  : 
; 718  :   if ( sside[(i+1)%3] < sside[(i+2)%3] )

	lea	eax, DWORD PTR [ebx+1]
	cdq
	mov	ecx, 3
	idiv	ecx
	lea	eax, DWORD PTR [ebx+2]
	mov	esi, 3
	mov	ecx, edx
	cdq
	idiv	esi
	mov	DWORD PTR tv456[ebp], ecx
	mov	ebx, edx
	fld	QWORD PTR _sside$[ebp+ebx*8]
	fcomp	QWORD PTR _sside$[ebp+ecx*8]
	fnstsw	ax
	test	ah, 65					; 00000041H

; 719  :   { e_id = get_fe_edge(fe[(i+1)%3]);

	mov	eax, DWORD PTR _web+460
	jne	SHORT $LN9@delete_fac
	mov	esi, DWORD PTR _fe$[ebp+ecx*4]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [ecx+20]

; 720  :     elimcount = delete_edge(e_id);

	push	esi
	call	_delete_edge
	mov	edi, eax
	add	esp, 4

; 721  :     if ( elimcount ) goto elimdone;

	test	edi, edi
	jne	SHORT $LN51@delete_fac

; 722  :     e_id = get_fe_edge(fe[(i+2)%3]);

	mov	esi, DWORD PTR _fe$[ebp+ebx*4]
	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [ecx+20]

; 723  :     elimcount = delete_edge(e_id);
; 724  :   }
; 725  :   else 

	jmp	SHORT $LN56@delete_fac
$LN9@delete_fac:

; 726  :   { e_id = get_fe_edge(fe[(i+2)%3]);

	mov	esi, DWORD PTR _fe$[ebp+ebx*4]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [ecx+20]

; 727  :     elimcount = delete_edge(e_id);

	push	esi
	call	_delete_edge
	mov	edi, eax
	add	esp, 4

; 728  :     if ( elimcount ) goto elimdone;

	test	edi, edi
	jne	SHORT $LN51@delete_fac

; 729  :     e_id = get_fe_edge(fe[(i+1)%3]);

	mov	edx, DWORD PTR tv456[ebp]
	mov	esi, DWORD PTR _fe$[ebp+edx*4]
	mov	ecx, DWORD PTR _web+460
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [edx+20]
$LN56@delete_fac:

; 730  :     elimcount = delete_edge(e_id);

	push	esi
	call	_delete_edge
	mov	edi, eax
	add	esp, 4
$elimdone$89748:

; 731  :   }
; 732  : elimdone:
; 733  :   if ( elimcount )

	test	edi, edi
	je	SHORT $LN5@delete_fac
$LN51@delete_fac:

; 734  :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN4@delete_fac

; 735  :     { sprintf(msg,"Deleting facet %s\n",ELNAME(f_id));

	cmp	DWORD PTR tv388[ebp], 0
	je	SHORT $LN24@delete_fac
	mov	eax, DWORD PTR _f_id$[ebp]
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN25@delete_fac
$LN24@delete_fac:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN25@delete_fac:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BD@NNGGCGKN@Deleting?5facet?5?$CFs?6?$AA@
	push	eax
	call	_sprintf

; 736  :        outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
$LN4@delete_fac:

; 737  :     }
; 738  :     free_element(e_id);

	push	esi
	call	_free_element
	add	esp, 4
	jmp	SHORT $LN2@delete_fac
$LN5@delete_fac:

; 739  :   }
; 740  :   else if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN2@delete_fac

; 741  :     { sprintf(msg,"Couldn't delete facet %s\n",ELNAME(f_id));

	cmp	DWORD PTR tv388[ebp], 0
	je	SHORT $LN26@delete_fac
	mov	eax, DWORD PTR _f_id$[ebp]
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN27@delete_fac
$LN26@delete_fac:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN27@delete_fac:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BK@CECNCJAC@Couldn?8t?5delete?5facet?5?$CFs?6?$AA@
	push	edx
	call	_sprintf

; 742  :        outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
$LN2@delete_fac:

; 743  :     }
; 744  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89741[ebp], 0
	je	SHORT $LN1@delete_fac
	mov	ecx, DWORD PTR _graphmutex
	push	ecx
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@delete_fac:

; 745  :   return elimcount;
; 746  : } // end delete_facet()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_delete_facet ENDP
_TEXT	ENDS
END
