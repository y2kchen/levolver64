; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\LEXYY.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0M@FKBLKCGO@where_count?$AA@		; `string'
PUBLIC	??_C@_09NANCMDLE@pop_count?$AA@			; `string'
PUBLIC	??_C@_0P@JACOHDHP@dissolve_count?$AA@		; `string'
PUBLIC	??_C@_0M@KEDMJLF@notch_count?$AA@		; `string'
PUBLIC	??_C@_0N@BGIPOCMC@refine_count?$AA@		; `string'
PUBLIC	??_C@_0N@MDBAOLCA@delete_count?$AA@		; `string'
PUBLIC	??_C@_0L@MMIEKJIF@equi_count?$AA@		; `string'
PUBLIC	??_C@_0BA@FLAJOIPD@hessian_epsilon?$AA@		; `string'
PUBLIC	??_C@_0N@PMIPBODO@total_length?$AA@		; `string'
PUBLIC	??_C@_0L@KNDBPLBH@total_area?$AA@		; `string'
PUBLIC	??_C@_0N@FOHOADKL@total_energy?$AA@		; `string'
PUBLIC	??_C@_0BA@KJPGFHE@facetedge_count?$AA@		; `string'
PUBLIC	??_C@_0L@BLNIGKEE@body_count?$AA@		; `string'
PUBLIC	??_C@_0M@MDEFFDDC@facet_count?$AA@		; `string'
PUBLIC	??_C@_0L@NIJKJMJB@edge_count?$AA@		; `string'
PUBLIC	??_C@_0N@HPKCIPGC@vertex_count?$AA@		; `string'
PUBLIC	??_C@_0M@FONFPPOA@scale_scale?$AA@		; `string'
PUBLIC	??_C@_0BC@OLOACPCP@iteration_counter?$AA@	; `string'
PUBLIC	??_C@_0BD@HHELJMGO@jiggle_temperature?$AA@	; `string'
PUBLIC	??_C@_09OAKPPPIB@eigenzero?$AA@			; `string'
PUBLIC	??_C@_08EPNFMFBP@eigenneg?$AA@			; `string'
PUBLIC	??_C@_08NMCKLHDA@eigenpos?$AA@			; `string'
PUBLIC	??_C@_0L@BENLKAPC@eigen_zero?$AA@		; `string'
PUBLIC	??_C@_09OPDPOHAJ@eigen_neg?$AA@			; `string'
PUBLIC	??_C@_09HMMAJFCG@eigen_pos?$AA@			; `string'
PUBLIC	??_C@_08LBHOIHHJ@pickfnum?$AA@			; `string'
PUBLIC	??_C@_08PGNOPNKJ@pickenum?$AA@			; `string'
PUBLIC	??_C@_08NBJOBAPL@pickvnum?$AA@			; `string'
PUBLIC	??_C@_0BF@GFGAKDLL@quadratic_metric_mix?$AA@	; `string'
PUBLIC	??_C@_0BC@DAHPKAPK@linear_metric_mix?$AA@	; `string'
PUBLIC	??_C@_06NLFCANPD@random?$AA@			; `string'
PUBLIC	??_C@_0M@PANFJEDO@random_seed?$AA@		; `string'
PUBLIC	??_C@_0BD@CHOAMOKA@last_hessian_scale?$AA@	; `string'
PUBLIC	??_C@_0BA@OBNGJMBG@last_eigenvalue?$AA@		; `string'
PUBLIC	??_C@_09GLPKLBIH@thickness?$AA@			; `string'
PUBLIC	??_C@_0BB@GHHBGKKF@target_tolerance?$AA@	; `string'
PUBLIC	??_C@_0M@HBHAPOJO@cpu_counter?$AA@		; `string'
PUBLIC	??_C@_05DDECJJKE@clock?$AA@			; `string'
PUBLIC	??_C@_0BA@BIIIJIED@transform_count?$AA@		; `string'
PUBLIC	??_C@_0BA@JDILIPNO@diffusion_coeff?$AA@		; `string'
PUBLIC	??_C@_0L@BECHNFGG@brightness?$AA@		; `string'
PUBLIC	??_C@_0L@EGCKCJDC@background?$AA@		; `string'
PUBLIC	??_C@_0M@NJPPNBCL@memory_used?$AA@		; `string'
PUBLIC	??_C@_0N@HIDDLAJM@memory_arena?$AA@		; `string'
PUBLIC	??_C@_0L@IAKFAOLO@last_error?$AA@		; `string'
PUBLIC	??_C@_0BH@OAPNEHDB@ambient_pressure_value?$AA@	; `string'
PUBLIC	??_C@_0BF@PLHANHAM@hessian_slant_cutoff?$AA@	; `string'
PUBLIC	??_C@_09MEOACIKB@breakflag?$AA@			; `string'
PUBLIC	??_C@_0BA@HBCDBDGE@bad_error_count?$AA@		; `string'
PUBLIC	??_C@_0BL@CKKLJMAI@facets_same_vertices_count?$AA@ ; `string'
PUBLIC	??_C@_0BK@JKNABKBA@edges_same_vertices_count?$AA@ ; `string'
PUBLIC	??_C@_0BA@GMPBMHMF@edge_loop_count?$AA@		; `string'
PUBLIC	??_C@_0BK@LLHOBCKD@inconsistent_bodies_count?$AA@ ; `string'
PUBLIC	??_C@_0BE@CJKHIDDP@bad_next_prev_count?$AA@	; `string'
PUBLIC	??_C@_0M@PLDEDAON@check_count?$AA@		; `string'
PUBLIC	??_C@_0BB@GILLHKAL@visibility_debug?$AA@	; `string'
PUBLIC	??_C@_0BB@NLMEBPED@scrollbuffersize?$AA@	; `string'
PUBLIC	??_C@_0BB@OFCJADDO@ps_gridedgewidth?$AA@	; `string'
PUBLIC	??_C@_0BB@NEEDDBHF@ps_bareedgewidth?$AA@	; `string'
PUBLIC	??_C@_0BA@LMLNIMJE@ps_conedgewidth?$AA@		; `string'
PUBLIC	??_C@_0BD@DOBHCOCD@ps_tripleedgewidth?$AA@	; `string'
PUBLIC	??_C@_0BC@CPCJJCCO@ps_fixededgewidth?$AA@	; `string'
PUBLIC	??_C@_0P@MKDKOLJB@ps_stringwidth?$AA@		; `string'
PUBLIC	??_C@_0N@PPOIJFFB@ps_labelsize?$AA@		; `string'
PUBLIC	??_C@_0BC@EADCAAG@t1_edgeswap_count?$AA@	; `string'
PUBLIC	??_C@_0P@IOOMGAHI@edgeswap_count?$AA@		; `string'
PUBLIC	??_C@_0BH@GEAHEOKO@pop_quad_to_quad_count?$AA@	; `string'
PUBLIC	??_C@_0BG@LGGDNHOG@pop_edge_to_tri_count?$AA@	; `string'
PUBLIC	??_C@_0BG@NFPFNFEP@pop_tri_to_edge_count?$AA@	; `string'
PUBLIC	??_C@_0P@CIHELNID@edge_pop_count?$AA@		; `string'
PUBLIC	??_C@_0BB@PNOKJDFD@vertex_pop_count?$AA@	; `string'
PUBLIC	??_C@_0BD@KDOCBOAO@facet_refine_count?$AA@	; `string'
PUBLIC	??_C@_0BC@LJKCEDIK@edge_refine_count?$AA@	; `string'
PUBLIC	??_C@_0BE@CKCDJLNA@body_dissolve_count?$AA@	; `string'
PUBLIC	??_C@_0BF@EDGKOAGH@facet_dissolve_count?$AA@	; `string'
PUBLIC	??_C@_0BE@JFPIKCB@edge_dissolve_count?$AA@	; `string'
PUBLIC	??_C@_0BG@MLIFIJNF@vertex_dissolve_count?$AA@	; `string'
PUBLIC	??_C@_0BD@HGHNBHOM@facet_delete_count?$AA@	; `string'
PUBLIC	??_C@_0BC@GMDNEKGI@edge_delete_count?$AA@	; `string'
PUBLIC	??_C@_0M@HMIJLFOH@unfix_count?$AA@		; `string'
PUBLIC	??_C@_09FKJNFACE@fix_count?$AA@			; `string'
PUBLIC	??_C@_0O@IOPDAKCK@mindeg_margin?$AA@		; `string'
PUBLIC	??_C@_0BH@CCPNJHKC@mindeg_min_region_size?$AA@	; `string'
PUBLIC	??_C@_0BD@ICNMFEGJ@mindeg_debug_level?$AA@	; `string'
PUBLIC	??_C@_0BE@LMLDEADG@window_aspect_ratio?$AA@	; `string'
PUBLIC	??_C@_09LEOGOINP@this_task?$AA@			; `string'
PUBLIC	??_C@_0M@JCMEGIAD@mpi_maxtask?$AA@		; `string'
PUBLIC	??_C@_0N@ILKHNNHO@corona_state?$AA@		; `string'
PUBLIC	??_C@_0BH@CENGABA@string_curve_tolerance?$AA@	; `string'
PUBLIC	??_C@_0BA@OIGENEKE@autochop_length?$AA@		; `string'
PUBLIC	??_C@_0BA@GKOHKDJ@detorus_epsilon?$AA@		; `string'
PUBLIC	??_C@_0BD@ENGCHOCN@bounding_box_color?$AA@	; `string'
PUBLIC	??_C@_05PMAELIEO@white?$AA@			; `string'
PUBLIC	??_C@_06ENJNJKEL@yellow?$AA@			; `string'
PUBLIC	??_C@_0N@BBECPGBJ@lightmagenta?$AA@		; `string'
PUBLIC	??_C@_08EEFKFEFN@lightred?$AA@			; `string'
PUBLIC	??_C@_09KPGEKFMK@lightcyan?$AA@			; `string'
PUBLIC	??_C@_0L@OPBGACJD@lightgreen?$AA@		; `string'
PUBLIC	??_C@_09NBIPJLA@lightblue?$AA@			; `string'
PUBLIC	??_C@_08EHDJKNHJ@darkgrey?$AA@			; `string'
PUBLIC	??_C@_08EADAAFKF@darkgray?$AA@			; `string'
PUBLIC	??_C@_04GDBIAANM@grey?$AA@			; `string'
PUBLIC	??_C@_04GEBBKIAA@gray?$AA@			; `string'
PUBLIC	??_C@_09IPGPKIEB@lightgrey?$AA@			; `string'
PUBLIC	??_C@_09IIGGAAJN@lightgray?$AA@			; `string'
PUBLIC	??_C@_05EBJGJMAL@brown?$AA@			; `string'
PUBLIC	??_C@_07EMDGAPCI@magenta?$AA@			; `string'
PUBLIC	??_C@_03FAAAOPJM@red?$AA@			; `string'
PUBLIC	??_C@_04EDBDANFH@cyan?$AA@			; `string'
PUBLIC	??_C@_05GBEEJKMC@green?$AA@			; `string'
PUBLIC	??_C@_04OBGPFBCN@blue?$AA@			; `string'
PUBLIC	??_C@_05BIMBDNDC@black?$AA@			; `string'
PUBLIC	??_C@_0M@CEEDCJLA@transparent?$AA@		; `string'
PUBLIC	??_C@_05MEHLAELG@clear?$AA@			; `string'
PUBLIC	??_C@_07BCIELMPF@pinning?$AA@			; `string'
PUBLIC	??_C@_0L@MABNKBMJ@autorecalc?$AA@		; `string'
PUBLIC	??_C@_0BC@LJJGFBGD@metric_conversion?$AA@	; `string'
PUBLIC	??_C@_09BPDDPHCA@gv_binary?$AA@			; `string'
PUBLIC	??_C@_0N@FFMNCIGF@self_similar?$AA@		; `string'
PUBLIC	??_C@_0BF@KHPBBAHH@div_normal_curvature?$AA@	; `string'
PUBLIC	??_C@_07IBJKBKNG@shading?$AA@			; `string'
PUBLIC	??_C@_0N@BNMHNAMC@facet_colors?$AA@		; `string'
PUBLIC	??_C@_09BAKALBHB@conj_grad?$AA@			; `string'
PUBLIC	??_C@_0O@HCDDDEHN@hessian_quiet?$AA@		; `string'
PUBLIC	??_C@_07HBPOHFLN@quietgo?$AA@			; `string'
PUBLIC	??_C@_05PMBAOCDH@quiet?$AA@			; `string'
PUBLIC	??_C@_0L@DLCCMBJF@transforms?$AA@		; `string'
PUBLIC	??_C@_0N@NFINOFHM@post_project?$AA@		; `string'
PUBLIC	??_C@_08LDELGPJH@estimate?$AA@			; `string'
PUBLIC	??_C@_07GFBFDLBM@gravity?$AA@			; `string'
PUBLIC	??_C@_07GGEALCBM@itdebug?$AA@			; `string'
PUBLIC	??_C@_08ONKONDHK@memdebug?$AA@			; `string'
PUBLIC	??_C@_05GFCDIDHO@debug?$AA@			; `string'
PUBLIC	??_C@_0P@OGHBAHOF@check_increase?$AA@		; `string'
PUBLIC	??_C@_0M@GGBEIMML@approx_curv?$AA@		; `string'
PUBLIC	??_C@_08MINHKHMD@old_area?$AA@			; `string'
PUBLIC	??_C@_07ENPKKAPH@sqgauss?$AA@			; `string'
PUBLIC	??_C@_09MFCEMNNF@conf_edge?$AA@			; `string'
PUBLIC	??_C@_07EMJKOPJK@view_4d?$AA@			; `string'
PUBLIC	??_C@_06IGFDKMHM@kusner?$AA@			; `string'
PUBLIC	??_C@_07LLNNGCPP@deturck?$AA@			; `string'
PUBLIC	??_C@_0O@PKIOMPCC@normal_motion?$AA@		; `string'
PUBLIC	??_C@_0N@PBIFKJMI@hessian_diff?$AA@		; `string'
PUBLIC	??_C@_07KCLCNBJB@thicken?$AA@			; `string'
PUBLIC	??_C@_08OMBDDLKJ@colormap?$AA@			; `string'
PUBLIC	??_C@_0L@LOICIGID@show_outer?$AA@		; `string'
PUBLIC	??_C@_0BA@FMBIOPNC@connected_cells?$AA@		; `string'
PUBLIC	??_C@_09JGOMOAGJ@connected?$AA@			; `string'
PUBLIC	??_C@_09DNEEIDBP@raw_cells?$AA@			; `string'
PUBLIC	??_C@_0O@ILHEOIGK@clipped_cells?$AA@		; `string'
PUBLIC	??_C@_07HKDEBIPG@clipped?$AA@			; `string'
PUBLIC	??_C@_0L@EAEPHEPG@show_inner?$AA@		; `string'
PUBLIC	??_C@_0M@DMCDJPBF@autodisplay?$AA@		; `string'
PUBLIC	??_C@_0O@MHBOMMFK@force_pos_def?$AA@		; `string'
PUBLIC	??_C@_07PIJPCAMN@ribiere?$AA@			; `string'
PUBLIC	??_C@_0BA@NLJCNNPB@assume_oriented?$AA@		; `string'
PUBLIC	??_C@_0P@BMDMDICD@hessian_normal?$AA@		; `string'
PUBLIC	??_C@_0P@GKFGPBHG@bunch_kauffman?$AA@		; `string'
PUBLIC	??_C@_0O@BFFIKKOE@bunch_kaufman?$AA@		; `string'
PUBLIC	??_C@_03JKDNAPFH@mkl?$AA@			; `string'
PUBLIC	??_C@_04NLKFKEKL@ysmp?$AA@			; `string'
PUBLIC	??_C@_0BA@HGBJAEID@quantities_only?$AA@		; `string'
PUBLIC	??_C@_0P@OHNEFNEP@metric_convert?$AA@		; `string'
PUBLIC	??_C@_0O@PLHGPNIO@linear_metric?$AA@		; `string'
PUBLIC	??_C@_0BB@GPGBGBKF@squared_gradient?$AA@	; `string'
PUBLIC	??_C@_0BB@GLJECMNP@h_inverse_metric?$AA@	; `string'
PUBLIC	??_C@_0BG@GAEGJDMI@hessian_double_normal?$AA@	; `string'
PUBLIC	??_C@_0BD@HMMIFHMP@hessian_normal_one?$AA@	; `string'
PUBLIC	??_C@_0N@ECHDFDIC@ps_labelflag?$AA@		; `string'
PUBLIC	??_C@_09KMOLHLBE@labelflag?$AA@			; `string'
PUBLIC	??_C@_0BA@MDFPOHGI@ps_crossingflag?$AA@		; `string'
PUBLIC	??_C@_0N@JJEIJGBI@crossingflag?$AA@		; `string'
PUBLIC	??_C@_08EGOBEDIK@gridflag?$AA@			; `string'
PUBLIC	??_C@_0M@NAKIPJII@ps_gridflag?$AA@		; `string'
PUBLIC	??_C@_0M@LOFHKFBI@ps_cmykflag?$AA@		; `string'
PUBLIC	??_C@_0N@PDJMPNAK@ps_colorflag?$AA@		; `string'
PUBLIC	??_C@_0M@MGNBMOID@pscolorflag?$AA@		; `string'
PUBLIC	??_C@_0BE@PABNDBOD@show_all_quantities?$AA@	; `string'
PUBLIC	??_C@_0BE@IEAFMCH@hessian_normal_perp?$AA@	; `string'
PUBLIC	??_C@_0BH@DJGEPEF@hessian_special_normal?$AA@	; `string'
PUBLIC	??_C@_0L@PLJDOBHE@zener_drag?$AA@		; `string'
PUBLIC	??_C@_0P@PLDNIGHE@volgrads_every?$AA@		; `string'
PUBLIC	??_C@_0P@DFOEIAJO@interp_normals?$AA@		; `string'
PUBLIC	??_C@_0O@DOAHOLKA@rotate_lights?$AA@		; `string'
PUBLIC	??_C@_08KFLJAAGL@backcull?$AA@			; `string'
PUBLIC	??_C@_0BB@JLCFDFN@ambient_pressure?$AA@		; `string'
PUBLIC	??_C@_07KBAMPNJK@verbose?$AA@			; `string'
PUBLIC	??_C@_0P@DEKALNNI@dirichlet_mode?$AA@		; `string'
PUBLIC	??_C@_0N@IAKIABKB@sobolev_mode?$AA@		; `string'
PUBLIC	??_C@_0P@EOAPCHNN@kraynikpopedge?$AA@		; `string'
PUBLIC	??_C@_0BB@OFKJMHPN@kraynikpopvertex?$AA@	; `string'
PUBLIC	??_C@_0L@NAICPCIF@rgb_colors?$AA@		; `string'
PUBLIC	??_C@_0BC@ENFIPPEC@circular_arc_draw?$AA@	; `string'
PUBLIC	??_C@_0BA@NBAAGIKN@visibility_test?$AA@		; `string'
PUBLIC	??_C@_0BD@LILDNGFC@sparse_constraints?$AA@	; `string'
PUBLIC	??_C@_0BC@OIKNNBJM@augmented_hessian?$AA@	; `string'
PUBLIC	??_C@_09ELACHHOE@blas_flag?$AA@			; `string'
PUBLIC	??_C@_0BB@GKDPKLCB@break_on_warning?$AA@	; `string'
PUBLIC	??_C@_0BE@HEFINIJJ@break_after_warning?$AA@	; `string'
PUBLIC	??_C@_0N@OJEGAGKB@bezier_basis?$AA@		; `string'
PUBLIC	??_C@_0N@DFPINMIP@smooth_graph?$AA@		; `string'
PUBLIC	??_C@_09PJOICEHA@mpi_debug?$AA@			; `string'
PUBLIC	??_C@_0M@FHCBDAPB@pop_to_face?$AA@		; `string'
PUBLIC	??_C@_0M@CAFGBCMP@pop_to_edge?$AA@		; `string'
PUBLIC	??_C@_0L@NBNMFCPF@pop_enjoin?$AA@		; `string'
PUBLIC	??_C@_0M@PDGIDHIC@pop_disjoin?$AA@		; `string'
PUBLIC	??_C@_0BC@PCBOIGLG@full_bounding_box?$AA@	; `string'
PUBLIC	??_C@_0O@EKBDJBFN@little_endian?$AA@		; `string'
PUBLIC	??_C@_0L@HGLBMAAF@big_endian?$AA@		; `string'
PUBLIC	??_C@_09EOFABKBN@quietload?$AA@			; `string'
PUBLIC	??_C@_09FMDIMAMP@clip_view?$AA@			; `string'
PUBLIC	??_C@_0L@KMEPJMME@slice_view?$AA@		; `string'
PUBLIC	??_C@_0BJ@GACLGPHB@function_quantity_sparse?$AA@ ; `string'
PUBLIC	??_C@_0P@BHLDEOD@force_deletion?$AA@		; `string'
PUBLIC	??_C@_0P@JPONPFLM@star_finagling?$AA@		; `string'
PUBLIC	??_C@_0BC@PCLABFDB@immediate_autopop?$AA@	; `string'
PUBLIC	??_C@_0P@HBGAENON@detorus_sticky?$AA@		; `string'
PUBLIC	??_C@_0CB@GFKKBGMN@view_transforms_use_unique_point@ ; `string'
PUBLIC	??_C@_0M@FKFJNJHN@septum_flag?$AA@		; `string'
PUBLIC	??_C@_0BC@IOPGAMGF@show_bounding_box?$AA@	; `string'
PUBLIC	??_C@_0BA@FEGMCNGA@K_altitude_mode?$AA@		; `string'
PUBLIC	??_C@_0P@BMEBABFE@show_all_edges?$AA@		; `string'
PUBLIC	??_C@_0P@EJEJKKN@force_edgeswap?$AA@		; `string'
PUBLIC	??_C@_08GIBBNMIA@optimise?$AA@			; `string'
PUBLIC	??_C@_08GHMAOHAP@optimize?$AA@			; `string'
PUBLIC	??_C@_06BDEIOILB@recalc?$AA@			; `string'
PUBLIC	??_C@_05EPBFLBEJ@unset?$AA@			; `string'
PUBLIC	??_C@_03KCHOJKKI@set?$AA@			; `string'
PUBLIC	??_C@_05OOLEAMGB@shell?$AA@			; `string'
PUBLIC	??_C@_08KFIPBGJH@dissolve?$AA@			; `string'
PUBLIC	??_C@_06FOBLBEIN@delete?$AA@			; `string'
PUBLIC	??_C@_05GOBGMMII@showq?$AA@			; `string'
PUBLIC	??_C@_04FKMICODN@show?$AA@			; `string'
PUBLIC	??_C@_04DONFEANM@list?$AA@			; `string'
PUBLIC	??_C@_05LCFPHLEE@where?$AA@			; `string'
PUBLIC	??_C@_07MEIPJMCG@sqcurve?$AA@			; `string'
PUBLIC	??_C@_04GOEDGNCF@area?$AA@			; `string'
PUBLIC	??_C@_07HKCFKCGH@valence?$AA@			; `string'
PUBLIC	??_C@_06IJDLPEM@length?$AA@			; `string'
PUBLIC	??_C@_0L@BBAJEGNK@bottominfo?$AA@		; `string'
PUBLIC	??_C@_07CFPPNLMH@topinfo?$AA@			; `string'
PUBLIC	??_C@_03PLGJJJLK@oid?$AA@			; `string'
PUBLIC	??_C@_02EGCJHIOB@id?$AA@			; `string'
PUBLIC	??_C@_08MGNLKBNG@show_vol?$AA@			; `string'
PUBLIC	??_C@_05KJHPNPAA@check?$AA@			; `string'
PUBLIC	??_C@_06ELMCDMMG@refine?$AA@			; `string'
PUBLIC	??_C@_02KPEDIMCA@go?$AA@			; `string'
PUBLIC	??_C@_07ENILCFOA@rawestv?$AA@			; `string'
PUBLIC	??_C@_04BBIOILIO@rawv?$AA@			; `string'
PUBLIC	??_C@_05CDBKKPFJ@longj?$AA@			; `string'
PUBLIC	??_C@_05IHFEJEKL@chdir?$AA@			; `string'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	??_C@_05IJMOJOL@utest?$AA@			; `string'
PUBLIC	??_C@_04HKCCIOCO@zoom?$AA@			; `string'
PUBLIC	??_C@_0P@HKDMGBBG@stability_test?$AA@		; `string'
PUBLIC	??_C@_05MFGCEKPN@alice?$AA@			; `string'
PUBLIC	??_C@_0M@EKPFJKCG@edge_divide?$AA@		; `string'
PUBLIC	??_C@_08EFAMPBPP@edgeweed?$AA@			; `string'
PUBLIC	??_C@_08KODKMLGA@areaweed?$AA@			; `string'
PUBLIC	??_C@_03MCADLMAF@off?$AA@			; `string'
PUBLIC	??_C@_0M@MMGMMHEK@extrapolate?$AA@		; `string'
PUBLIC	??_C@_06JMEOMOEA@counts?$AA@			; `string'
PUBLIC	??_C@_02LIELOMNJ@on?$AA@			; `string'
PUBLIC	??_C@_0L@LFLJKKDA@procedures?$AA@		; `string'
PUBLIC	??_C@_0O@DNBEMPOF@binary_printf?$AA@		; `string'
PUBLIC	??_C@_07DNAEFDKF@sprintf?$AA@			; `string'
PUBLIC	??_C@_09JOJNMAED@errprintf?$AA@			; `string'
PUBLIC	??_C@_06OHJFMFMB@printf?$AA@			; `string'
PUBLIC	??_C@_06HMBJBPPM@eprint?$AA@			; `string'
PUBLIC	??_C@_05IJDJACGD@print?$AA@			; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_03CFFIJAMA@sum?$AA@			; `string'
PUBLIC	??_C@_03CHOBFJAH@avg?$AA@			; `string'
PUBLIC	??_C@_03KLIPLJLL@min?$AA@			; `string'
PUBLIC	??_C@_03LJAEFNNE@max?$AA@			; `string'
PUBLIC	??_C@_08BKGECACE@dihedral?$AA@			; `string'
PUBLIC	??_C@_0L@BHDKNBMG@show_trans?$AA@		; `string'
PUBLIC	??_C@_09INMNGPFE@show_expr?$AA@			; `string'
PUBLIC	??_C@_0N@MFCDHBBC@loghistogram?$AA@		; `string'
PUBLIC	??_C@_09JOLNEMIB@histogram?$AA@			; `string'
PUBLIC	??_C@_04FHMCPBIP@else?$AA@			; `string'
PUBLIC	??_C@_04HOHPNOOD@then?$AA@			; `string'
PUBLIC	??_C@_02HEBPBKGD@if?$AA@			; `string'
PUBLIC	??_C@_02KNAFDCHJ@do?$AA@			; `string'
PUBLIC	??_C@_05OODBEKIG@while?$AA@			; `string'
PUBLIC	??_C@_05GEEJHDPH@notch?$AA@			; `string'
PUBLIC	??_C@_08MJMACJHA@permload?$AA@			; `string'
PUBLIC	??_C@_04EONOHKEP@load?$AA@			; `string'
PUBLIC	??_C@_04GGLOKIEE@dump?$AA@			; `string'
PUBLIC	??_C@_03MDONDFG@bye?$AA@			; `string'
PUBLIC	??_C@_04MKNBDEPB@exit?$AA@			; `string'
PUBLIC	??_C@_04KNNLNNGO@quit?$AA@			; `string'
PUBLIC	??_C@_04PCJFHION@help?$AA@			; `string'
PUBLIC	??_C@_0N@NJLPGECL@hessian_menu?$AA@		; `string'
PUBLIC	??_C@_0N@NOHLJNPG@hessian_seek?$AA@		; `string'
PUBLIC	??_C@_07IHNMECBN@hessian?$AA@			; `string'
PUBLIC	??_C@_0P@MKIFIEMC@transform_expr?$AA@		; `string'
PUBLIC	??_C@_0BA@IPCFDLJD@transform_depth?$AA@		; `string'
PUBLIC	??_C@_08BOPEGKMG@show_off?$AA@			; `string'
PUBLIC	??_C@_0L@HANDHNGN@close_show?$AA@		; `string'
PUBLIC	??_C@_08GHINPAG@burchard?$AA@			; `string'
PUBLIC	??_C@_06HAMJBNFB@rebody?$AA@			; `string'
PUBLIC	??_C@_07ICLAOFOB@foreach?$AA@			; `string'
PUBLIC	??_C@_05INHNKAIM@unfix?$AA@			; `string'
PUBLIC	??_C@_03GABGILGN@fix?$AA@			; `string'
PUBLIC	??_C@_07MMNEDCBK@history?$AA@			; `string'
PUBLIC	??_C@_05KBOMEDGA@total?$AA@			; `string'
PUBLIC	??_C@_0P@BLIMDDOG@dirichlet_seek?$AA@		; `string'
PUBLIC	??_C@_09JHHPCHFN@dirichlet?$AA@			; `string'
PUBLIC	??_C@_0N@KPIEIPJP@sobolev_seek?$AA@		; `string'
PUBLIC	??_C@_07NNCLFLCE@sobolev?$AA@			; `string'
PUBLIC	??_C@_0L@HNMJPKNA@attributes?$AA@		; `string'
PUBLIC	??_C@_04CIOKLOBL@midv?$AA@			; `string'
PUBLIC	??_C@_06PNAKCKLH@saddle?$AA@			; `string'
PUBLIC	??_C@_08GOLFMCHH@geomview?$AA@			; `string'
PUBLIC	??_C@_0N@PEAHACPA@datafilename?$AA@		; `string'
PUBLIC	??_C@_0N@DHNCNHBM@triple_point?$AA@		; `string'
PUBLIC	??_C@_0M@DFLKEBKH@tetra_point?$AA@		; `string'
PUBLIC	??_C@_07JPCPFHFE@lanczos?$AA@			; `string'
PUBLIC	??_C@_0L@FLCFPHEO@eigenprobe?$AA@		; `string'
PUBLIC	??_C@_04HKMJFCDE@ritz?$AA@			; `string'
PUBLIC	??_C@_08DLICDMBN@continue?$AA@			; `string'
PUBLIC	??_C@_08HEBLBDOI@volfixed?$AA@			; `string'
PUBLIC	??_C@_05ELPHFHOI@break?$AA@			; `string'
PUBLIC	??_C@_0M@HIFAJGPB@t1_edgeswap?$AA@		; `string'
PUBLIC	??_C@_08GDDLLHKC@edgeswap?$AA@			; `string'
PUBLIC	??_C@_0BG@LAOGOOCK@convert_to_quantities?$AA@	; `string'
PUBLIC	??_C@_08IDOMCGJP@geompipe?$AA@			; `string'
PUBLIC	??_C@_04HDMMNHEL@move?$AA@			; `string'
PUBLIC	??_C@_06FPFOALMG@sizeof?$AA@			; `string'
PUBLIC	??_C@_06FNJMBFGF@ometis?$AA@			; `string'
PUBLIC	??_C@_06KJNDDBHG@kmetis?$AA@			; `string'
PUBLIC	??_C@_0L@JJNAPELC@body_metis?$AA@		; `string'
PUBLIC	??_C@_0P@BEHGJJCH@metis_readjust?$AA@		; `string'
PUBLIC	??_C@_05MMMFHLE@metis?$AA@			; `string'
PUBLIC	??_C@_0N@GAAHAAOL@metis_factor?$AA@		; `string'
PUBLIC	??_C@_0BG@EBKCCFDE@rawest_vertex_average?$AA@	; `string'
PUBLIC	??_C@_0BD@FBBKFDM@raw_vertex_average?$AA@	; `string'
PUBLIC	??_C@_0P@OLMKLKE@vertex_average?$AA@		; `string'
PUBLIC	??_C@_0BA@IBDAIKBO@binary_off_file?$AA@		; `string'
PUBLIC	??_C@_08KLNLDNLL@ooglfile?$AA@			; `string'
PUBLIC	??_C@_0L@CCPMELKB@postscript?$AA@		; `string'
PUBLIC	??_C@_06LNOFJDNM@return?$AA@			; `string'
PUBLIC	??_C@_08PANPCJAE@new_body?$AA@			; `string'
PUBLIC	??_C@_09OAIEDJBI@new_facet?$AA@			; `string'
PUBLIC	??_C@_08HBMPJBBB@new_edge?$AA@			; `string'
PUBLIC	??_C@_0L@KAOEHGMG@new_vertex?$AA@		; `string'
PUBLIC	??_C@_08JONLCJIM@backbody?$AA@			; `string'
PUBLIC	??_C@_09GNLMKAKO@frontbody?$AA@			; `string'
PUBLIC	??_C@_0L@GKBDMEAN@keylogfile?$AA@		; `string'
PUBLIC	??_C@_07HMINABEO@logfile?$AA@			; `string'
PUBLIC	??_C@_05PDJBBECF@pause?$AA@			; `string'
PUBLIC	??_C@_0N@JJMKEIGG@renumber_all?$AA@		; `string'
PUBLIC	??_C@_0BA@PJJKCDON@reorder_storage?$AA@		; `string'
PUBLIC	??_C@_0L@FMKAEFLC@is_defined?$AA@		; `string'
PUBLIC	??_C@_0M@CJACPCIB@wrap_vertex?$AA@		; `string'
PUBLIC	??_C@_04MGEIEJAD@exec?$AA@			; `string'
PUBLIC	??_C@_07BKFFEMDK@exprint?$AA@			; `string'
PUBLIC	??_C@_0O@DICBBEEI@date_and_time?$AA@		; `string'
PUBLIC	??_C@_09BADENEHP@colorfile?$AA@			; `string'
PUBLIC	??_C@_0N@ICOOBCNI@vertexnormal?$AA@		; `string'
PUBLIC	??_C@_0N@PBJCFAJD@equiangulate?$AA@		; `string'
PUBLIC	??_C@_0BB@FIMKOPGK@warning_messages?$AA@	; `string'
PUBLIC	??_C@_03JOHEBPFF@for?$AA@			; `string'
PUBLIC	??_C@_05IDKHKMLA@local?$AA@			; `string'
PUBLIC	??_C@_0BB@NFBBDANK@pop_quad_to_quad?$AA@	; `string'
PUBLIC	??_C@_0BA@LLOFFOFA@pop_edge_to_tri?$AA@		; `string'
PUBLIC	??_C@_0BA@HKCODAC@pop_tri_to_edge?$AA@		; `string'
PUBLIC	??_C@_03NJDAHFJE@pop?$AA@			; `string'
PUBLIC	??_C@_09BOMFCCD@task_exec?$AA@			; `string'
PUBLIC	??_C@_0O@OJLJIFPG@parallel_exec?$AA@		; `string'
PUBLIC	??_C@_0P@FKOPBMAL@mean_curvature?$AA@		; `string'
PUBLIC	??_C@_08KEAKBNCK@mpi_task?$AA@			; `string'
PUBLIC	??_C@_0M@HCCAAKMF@facet_merge?$AA@		; `string'
PUBLIC	??_C@_0L@GJPPMFGG@edge_merge?$AA@		; `string'
PUBLIC	??_C@_0N@MOMHNGJF@vertex_merge?$AA@		; `string'
PUBLIC	??_C@_0N@BFEIANBO@reset_counts?$AA@		; `string'
PUBLIC	??_C@_0O@HEMOCGDL@valid_element?$AA@		; `string'
PUBLIC	??_C@_0N@HEKOHBEK@flush_counts?$AA@		; `string'
PUBLIC	??_C@_09BPLDEHMH@mid_facet?$AA@			; `string'
PUBLIC	??_C@_08EJNLDOMI@mid_edge?$AA@			; `string'
PUBLIC	??_C@_0BD@JJNPEKJD@matrix_determinant?$AA@	; `string'
PUBLIC	??_C@_0P@EBJBPEJC@matrix_inverse?$AA@		; `string'
PUBLIC	??_C@_0BA@JNPAPNBO@matrix_multiply?$AA@		; `string'
PUBLIC	??_C@_0BE@KCPFLFEG@reverse_orientation?$AA@	; `string'
PUBLIC	??_C@_0N@GDMIKNMD@dump_memlist?$AA@		; `string'
PUBLIC	??_C@_0O@OKPNNEJG@free_discards?$AA@		; `string'
PUBLIC	??_C@_0M@PLKJAEAL@repartition?$AA@		; `string'
PUBLIC	??_C@_0L@KHFNHBNM@subcommand?$AA@		; `string'
PUBLIC	??_C@_05BBAEEBBH@abort?$AA@			; `string'
PUBLIC	??_C@_0M@BKKBNEBK@breakpoints?$AA@		; `string'
PUBLIC	??_C@_0L@LCAMEHJC@breakpoint?$AA@		; `string'
PUBLIC	??_C@_08DHCGNBAN@whereami?$AA@			; `string'
PUBLIC	??_C@_0N@OJACEENF@replace_load?$AA@		; `string'
PUBLIC	??_C@_07BNADNHKE@addload?$AA@			; `string'
PUBLIC	??_C@_0O@ECJLFEKE@simplex_to_fe?$AA@		; `string'
PUBLIC	??_C@_0N@CJJGNHCN@display_text?$AA@		; `string'
PUBLIC	??_C@_0M@EOIFPGKG@delete_text?$AA@		; `string'
PUBLIC	??_C@_0BA@OHLAHHBM@reset_profiling?$AA@		; `string'
PUBLIC	??_C@_09IICGFFJH@profiling?$AA@			; `string'
PUBLIC	??_C@_0P@CFKICEKD@valid_boundary?$AA@		; `string'
PUBLIC	??_C@_0BB@CNFDAFCL@valid_constraint?$AA@	; `string'
PUBLIC	??_C@_0O@KPBBKELJ@is_constraint?$AA@		; `string'
PUBLIC	??_C@_07LDNKKEH@detorus?$AA@			; `string'
PUBLIC	??_C@_0P@KJENOODO@facet_crosscut?$AA@		; `string'
PUBLIC	??_C@_0BC@NBLIDMLB@make_thread_lists?$AA@	; `string'
PUBLIC	??_C@_0BC@KBMGOFNF@no_hessian_normal?$AA@	; `string'
PUBLIC	??_C@_07LFPCKGAP@p_force?$AA@			; `string'
PUBLIC	??_C@_0L@LJPKPJJM@p_velocity?$AA@		; `string'
PUBLIC	??_C@_07IAPJLEJH@no_dump?$AA@			; `string'
PUBLIC	??_C@_0O@KIAILNPN@normal_vector?$AA@		; `string'
PUBLIC	??_C@_06IKLLLDHL@normal?$AA@			; `string'
PUBLIC	??_C@_03JGHBODFD@pow?$AA@			; `string'
PUBLIC	??_C@_07CCOEHHFD@minimum?$AA@			; `string'
PUBLIC	??_C@_07MEIENILC@maximum?$AA@			; `string'
PUBLIC	??_C@_0BE@DIEKFJPK@incompleteEllipticE?$AA@	; `string'
PUBLIC	??_C@_0BE@BDGHAKDJ@incompleteEllipticF?$AA@	; `string'
PUBLIC	??_C@_05KNGEOGJB@atan2?$AA@			; `string'
PUBLIC	??_C@_0N@HGNPFHKM@wrap_compose?$AA@		; `string'
PUBLIC	??_C@_03BCGAIFPO@abs?$AA@			; `string'
PUBLIC	??_C@_05PBJFFIGL@floor?$AA@			; `string'
PUBLIC	??_C@_04GFPJNGEK@ceil?$AA@			; `string'
PUBLIC	??_C@_03OPALDGIC@sqr?$AA@			; `string'
PUBLIC	??_C@_04EIAKFFMI@sqrt?$AA@			; `string'
PUBLIC	??_C@_05ONDAFDEP@atanh?$AA@			; `string'
PUBLIC	??_C@_05MLNBFPMN@acosh?$AA@			; `string'
PUBLIC	??_C@_05JKKEKHLA@asinh?$AA@			; `string'
PUBLIC	??_C@_04FJHINJAO@tanh?$AA@			; `string'
PUBLIC	??_C@_04HPJJNFIM@cosh?$AA@			; `string'
PUBLIC	??_C@_04COOMCNPB@sinh?$AA@			; `string'
PUBLIC	??_C@_04MLLJIGOK@atan?$AA@			; `string'
PUBLIC	??_C@_04PDIFKINK@acos?$AA@			; `string'
PUBLIC	??_C@_04FIHNOPOL@asin?$AA@			; `string'
PUBLIC	??_C@_03IIINPABG@tan?$AA@			; `string'
PUBLIC	??_C@_03LALBNOCG@cos?$AA@			; `string'
PUBLIC	??_C@_03BLEJJJBH@sin?$AA@			; `string'
PUBLIC	??_C@_03KHJOGHMM@exp?$AA@			; `string'
PUBLIC	??_C@_03MGHMBJCF@log?$AA@			; `string'
PUBLIC	??_C@_09IOEHKLLB@ellipticE?$AA@			; `string'
PUBLIC	??_C@_09BAMEIGDP@ellipticK?$AA@			; `string'
PUBLIC	??_C@_0N@CCAKCFDI@wrap_inverse?$AA@		; `string'
PUBLIC	??_C@_09CMEJCHLK@facetedge?$AA@			; `string'
PUBLIC	??_C@_0L@CPIKDJIA@facetedges?$AA@		; `string'
PUBLIC	??_C@_0L@LKKCPKKM@facet_edge?$AA@		; `string'
PUBLIC	??_C@_0M@NLMIGHAM@facet_edges?$AA@		; `string'
PUBLIC	??_C@_04IEJGKNJ@body?$AA@			; `string'
PUBLIC	??_C@_06OHIKIKDI@bodies?$AA@			; `string'
PUBLIC	??_C@_05BIBOABDC@facet?$AA@			; `string'
PUBLIC	??_C@_06MMNNGFLE@facets?$AA@			; `string'
PUBLIC	??_C@_04POCOPAPC@face?$AA@			; `string'
PUBLIC	??_C@_05FHFPJHPF@faces?$AA@			; `string'
PUBLIC	??_C@_04IJFJNCMM@edge?$AA@			; `string'
PUBLIC	??_C@_05JGEJPNHM@edges?$AA@			; `string'
PUBLIC	??_C@_06HLKHCFCI@vertex?$AA@			; `string'
PUBLIC	??_C@_08BOLPBPCL@vertices?$AA@			; `string'
PUBLIC	??_C@_08LAAABFKN@original?$AA@			; `string'
PUBLIC	??_C@_0M@CBIPACOJ@dot_product?$AA@		; `string'
PUBLIC	??_C@_04CHNIFDFF@idiv?$AA@			; `string'
PUBLIC	??_C@_04CGKJBALO@imod?$AA@			; `string'
PUBLIC	??_C@_03FFONCNID@mod?$AA@			; `string'
PUBLIC	??_C@_03NJKJADM@not?$AA@			; `string'
PUBLIC	??_C@_02FODMLBIE@or?$AA@			; `string'
PUBLIC	??_C@_03BOPJPIAM@and?$AA@			; `string'
PUBLIC	??_C@_04POLDLDMI@read?$AA@			; `string'
PUBLIC	??_C@_08IMINLCCL@volconst?$AA@			; `string'
PUBLIC	??_C@_08OCNIHGPN@quantity?$AA@			; `string'
PUBLIC	??_C@_0M@EMFGBOOI@zoom_radius?$AA@		; `string'
PUBLIC	??_C@_0M@JBIJOPDG@zoom_vertex?$AA@		; `string'
PUBLIC	??_C@_0M@PJCBAJEM@scale_limit?$AA@		; `string'
PUBLIC	??_C@_09KIHCPOPL@nodisplay?$AA@			; `string'
PUBLIC	??_C@_07BJBOFKDG@tension?$AA@			; `string'
PUBLIC	??_C@_07HAFFKDBK@density?$AA@			; `string'
PUBLIC	??_C@_06EMCPHFGM@volume?$AA@			; `string'
PUBLIC	??_C@_08POHEELCJ@pressure?$AA@			; `string'
PUBLIC	??_C@_0M@GJEHHDCL@temperature?$AA@		; `string'
PUBLIC	??_C@_06HACLPJI@pscale?$AA@			; `string'
PUBLIC	??_C@_05MHMEBBGO@scale?$AA@			; `string'
PUBLIC	??_C@_0N@DKAJABDK@gap_constant?$AA@		; `string'
PUBLIC	??_C@_0BA@CNIKOEML@spring_constant?$AA@		; `string'
PUBLIC	??_C@_0BB@LFLMFBL@gravity_constant?$AA@		; `string'
PUBLIC	??_C@_0N@OMNDKHGB@merit_factor?$AA@		; `string'
PUBLIC	??_C@_09NBBNKAEP@diffusion?$AA@			; `string'
PUBLIC	??_C@_06LGAKKEPJ@jiggle?$AA@			; `string'
PUBLIC	??_C@_0BD@JAENIDNE@area_normalization?$AA@	; `string'
PUBLIC	??_C@_06HPJICMPM@linear?$AA@			; `string'
PUBLIC	??_C@_09NDEBDKFB@quadratic?$AA@			; `string'
PUBLIC	??_C@_07ICAJMOAO@content?$AA@			; `string'
PUBLIC	??_C@_06KKGCKCNJ@energy?$AA@			; `string'
PUBLIC	??_C@_0M@EANCEANL@nonpositive?$AA@		; `string'
PUBLIC	??_C@_0M@MKNCPPEA@nonnegative?$AA@		; `string'
PUBLIC	??_C@_07FAFBHKGP@nonwall?$AA@			; `string'
PUBLIC	??_C@_06OAMDAHCP@convex?$AA@			; `string'
PUBLIC	??_C@_0BF@MOILGEJM@constraint_tolerance?$AA@	; `string'
PUBLIC	??_C@_0BF@CFFGCHHD@integration_order_2d?$AA@	; `string'
PUBLIC	??_C@_0BF@CHBAJJCK@integration_order_1d?$AA@	; `string'
PUBLIC	??_C@_0BC@CCICJAIC@integration_order?$AA@	; `string'
PUBLIC	??_C@_0BC@CBPAEDJL@integral_order_2d?$AA@	; `string'
PUBLIC	??_C@_0BC@CDLGPNMC@integral_order_1d?$AA@	; `string'
PUBLIC	??_C@_0P@JOOJGKKP@integral_order?$AA@		; `string'
PUBLIC	??_C@_0BC@COAHFEML@symmetric_content?$AA@	; `string'
PUBLIC	??_C@_0P@EAADGFKM@parameter_file?$AA@		; `string'
PUBLIC	??_C@_0L@HHPOFMCB@parameters?$AA@		; `string'
PUBLIC	??_C@_09DAGAJHIH@parameter?$AA@			; `string'
PUBLIC	??_C@_08HFFPPCHF@function?$AA@			; `string'
PUBLIC	??_C@_07LHCFJCJM@formula?$AA@			; `string'
PUBLIC	??_C@_0P@LFIPMAJA@surface_energy?$AA@		; `string'
PUBLIC	??_C@_0M@JGLONDGH@constraints?$AA@		; `string'
PUBLIC	??_C@_0L@HOHHMJMM@constraint?$AA@		; `string'
PUBLIC	??_C@_0L@PABKJGNF@boundaries?$AA@		; `string'
PUBLIC	??_C@_08KIKGFOKI@boundary?$AA@			; `string'
PUBLIC	??_C@_05GHCFDPJC@wulff?$AA@			; `string'
PUBLIC	??_C@_08DODCPBAM@soapfilm?$AA@			; `string'
PUBLIC	??_C@_06ICGJLFIM@string?$AA@			; `string'
PUBLIC	??_C@_0BA@HCKIGAAA@display_periods?$AA@		; `string'
PUBLIC	??_C@_07BFECMFCO@periods?$AA@			; `string'
PUBLIC	??_C@_0O@IMAKABFD@torus_periods?$AA@		; `string'
PUBLIC	??_C@_0N@IGCELFFA@torus_filled?$AA@		; `string'
PUBLIC	??_C@_05FCPCBJIO@torus?$AA@			; `string'
PUBLIC	??_C@_04NFDDIEML@wrap?$AA@			; `string'
PUBLIC	??_C@_0P@GKEDIIHF@symmetry_group?$AA@		; `string'
PUBLIC	??_C@_06BAJEJFKD@efixed?$AA@			; `string'
PUBLIC	??_C@_0L@DKEDBIHO@noncontent?$AA@		; `string'
PUBLIC	??_C@_0L@ODCODBLD@no_display?$AA@		; `string'
PUBLIC	??_C@_0N@OFAMNBMC@centerofmass?$AA@		; `string'
PUBLIC	??_C@_0M@JAGBIOBF@hit_partner?$AA@		; `string'
PUBLIC	??_C@_0N@CMIGFPCH@no_transform?$AA@		; `string'
PUBLIC	??_C@_09PFNGBABC@no_refine?$AA@			; `string'
PUBLIC	??_C@_05OFLEIIDM@fixed?$AA@			; `string'
PUBLIC	??_C@_0BB@HOLKBDMI@conformal_metric?$AA@	; `string'
PUBLIC	??_C@_0N@FGNFAGIK@klein_metric?$AA@		; `string'
PUBLIC	??_C@_06BEHJHFJO@metric?$AA@			; `string'
PUBLIC	??_C@_0BH@ELELLFNL@simplex_representation?$AA@	; `string'
PUBLIC	??_C@_0BC@CCLFHFGM@surface_dimension?$AA@	; `string'
PUBLIC	??_C@_0BA@NCBBEAIN@space_dimension?$AA@		; `string'
PUBLIC	??_C@_0BH@PBMPDDPJ@conducting_knot_energy?$AA@	; `string'
PUBLIC	??_C@_0BH@KFIJAGHO@insulating_knot_energy?$AA@	; `string'
PUBLIC	??_C@_0BA@MAJEELEA@gauss_curvature?$AA@		; `string'
PUBLIC	??_C@_0BL@MADIBINB@squared_gaussian_curvature?$AA@ ; `string'
PUBLIC	??_C@_0BK@FKPNCHGB@square_gaussian_curvature?$AA@ ; `string'
PUBLIC	??_C@_0BC@ODOAEPAL@squared_curvature?$AA@	; `string'
PUBLIC	??_C@_0BB@OIOLOLOH@square_curvature?$AA@	; `string'
PUBLIC	??_C@_0BB@ODBHHAP@normal_curvature?$AA@		; `string'
PUBLIC	??_C@_0BI@KGGFDDEC@mean_curvature_integral?$AA@	; `string'
PUBLIC	??_C@_0L@DKEJANLD@frontcolor?$AA@		; `string'
PUBLIC	??_C@_09OPNKCLNO@backcolor?$AA@			; `string'
PUBLIC	??_C@_05PEENBMOG@color?$AA@			; `string'
PUBLIC	??_C@_0M@OBNGAKOC@runge_kutta?$AA@		; `string'
PUBLIC	??_C@_0P@OMMOBLOA@effective_area?$AA@		; `string'
PUBLIC	??_C@_0L@OIFGKHMH@total_time?$AA@		; `string'
PUBLIC	??_C@_08BLGPIPGP@autochop?$AA@			; `string'
PUBLIC	??_C@_0BA@KEKJOJEJ@autopop_quartic?$AA@		; `string'
PUBLIC	??_C@_07LEJGIFAD@autopop?$AA@			; `string'
PUBLIC	??_C@_05CBPKLGJM@phase?$AA@			; `string'
PUBLIC	??_C@_09JNGEFCBF@phasefile?$AA@			; `string'
PUBLIC	??_C@_0BB@MNCGPOEG@approx_curvature?$AA@	; `string'
PUBLIC	??_C@_0BG@CNKFKNKC@approximate_curvature?$AA@	; `string'
PUBLIC	??_C@_09PDIDGCEH@homothety?$AA@			; `string'
PUBLIC	??_C@_0BK@PJALNND@view_transform_generators?$AA@ ; `string'
PUBLIC	??_C@_0BA@IFLDONLI@view_transforms?$AA@		; `string'
PUBLIC	??_C@_0M@PIDOJOI@view_matrix?$AA@		; `string'
PUBLIC	??_C@_0L@HCEEFND@fixed_area?$AA@		; `string'
PUBLIC	??_C@_0L@IDDPHJLO@area_fixed?$AA@		; `string'
PUBLIC	??_C@_06FJKEMHGD@global?$AA@			; `string'
PUBLIC	??_C@_0O@LJFOIPB@global_method?$AA@		; `string'
PUBLIC	??_C@_09EMCPFNEA@info_only?$AA@			; `string'
PUBLIC	??_C@_07CJECEDDG@modulus?$AA@			; `string'
PUBLIC	??_C@_0BD@MOPCCJLG@boundary_curvature?$AA@	; `string'
PUBLIC	??_C@_04BGEKJPHF@bare?$AA@			; `string'
PUBLIC	??_C@_0BA@LJFNGFOM@mobility_tensor?$AA@		; `string'
PUBLIC	??_C@_08DJCKBMBN@mobility?$AA@			; `string'
PUBLIC	??_C@_0P@LNEAGBL@form_integrand?$AA@		; `string'
PUBLIC	??_C@_0P@HMNODAPJ@k_vector_order?$AA@		; `string'
PUBLIC	??_C@_0BB@CNKNAII@vector_integrand?$AA@		; `string'
PUBLIC	??_C@_0BB@KCGOMKJL@scalar_integrand?$AA@	; `string'
PUBLIC	??_C@_06GABBCIBA@method?$AA@			; `string'
PUBLIC	??_C@_0BA@FCDDEKDG@method_instance?$AA@		; `string'
PUBLIC	??_C@_09HGIEBAJ@attribute?$AA@			; `string'
PUBLIC	??_C@_06EPMMJFDC@define?$AA@			; `string'
PUBLIC	??_C@_06JJLAMBGK@target?$AA@			; `string'
PUBLIC	??_C@_05MFEJDJP@value?$AA@			; `string'
PUBLIC	??_C@_0BG@DMHBIFMB@everything_quantities?$AA@	; `string'
PUBLIC	??_C@_0BF@PCMDHFO@optimising_parameter?$AA@	; `string'
PUBLIC	??_C@_0BF@HJFOCADB@optimizing_parameter?$AA@	; `string'
PUBLIC	??_C@_0M@JADJAFPH@parameter_2?$AA@		; `string'
PUBLIC	??_C@_0M@LLBEFGDE@parameter_1?$AA@		; `string'
PUBLIC	??_C@_0P@DDMFGHDB@lagrange_order?$AA@		; `string'
PUBLIC	??_C@_08JNKCHLOP@lagrange?$AA@			; `string'
PUBLIC	??_C@_0M@BIHLDDLK@axial_point?$AA@		; `string'
PUBLIC	??_C@_0BC@KPHKHJOD@interp_bdry_param?$AA@	; `string'
PUBLIC	??_C@_0N@KPOPAFCP@load_library?$AA@		; `string'
PUBLIC	??_C@_0N@DPCDAEDN@ignore_fixed?$AA@		; `string'
PUBLIC	??_C@_0BD@IJHNDEKK@ignore_constraints?$AA@	; `string'
PUBLIC	??_C@_0M@KPMDGEHG@orientation?$AA@		; `string'
PUBLIC	??_C@_0BA@DKKLMIEO@evolver_version?$AA@		; `string'
PUBLIC	??_C@_0BE@MPMEKLIN@lagrange_multiplier?$AA@	; `string'
PUBLIC	??_C@_09FFJNLCDE@tolerance?$AA@			; `string'
PUBLIC	??_C@_0P@EHFNPAFG@on_assign_call?$AA@		; `string'
PUBLIC	??_C@_06BCKCJHAK@pdelta?$AA@			; `string'
PUBLIC	??_C@_0M@MGPGBEBP@keep_macros?$AA@		; `string'
PUBLIC	??_C@_0O@CFOLDLE@actual_volume?$AA@		; `string'
PUBLIC	??_C@_09GHGMGLNO@conserved?$AA@			; `string'
PUBLIC	??_C@_04PJDNGLKJ@self?$AA@			; `string'
PUBLIC	??_C@_0M@GNHLGAPA@swap_colors?$AA@		; `string'
PUBLIC	??_C@_0BA@EFLDDNJL@element_modulus?$AA@		; `string'
PUBLIC	??_C@_0P@NAPIFNOG@keep_originals?$AA@		; `string'
PUBLIC	??_C@_0BO@JLAEKIJE@hessian_special_normal_vector?$AA@ ; `string'
PUBLIC	??_C@_0BB@CNJENMNM@area_method_name?$AA@	; `string'
PUBLIC	??_C@_0BD@LPDEKMFI@length_method_name?$AA@	; `string'
PUBLIC	??_C@_0P@OAMDDONM@display_origin?$AA@		; `string'
PUBLIC	??_C@_09KAGJCBDL@procedure?$AA@			; `string'
PUBLIC	??_C@_0BA@FGAGLOAP@partner_hitting?$AA@		; `string'
PUBLIC	??_C@_0BD@PDLHDKOI@volume_method_name?$AA@	; `string'
PUBLIC	??_C@_0BD@JLBMBNDA@unsuppress_warning?$AA@	; `string'
PUBLIC	??_C@_0BB@DAFJNDLH@suppress_warning?$AA@	; `string'
PUBLIC	??_C@_0O@FHDEFNFH@high_boundary?$AA@		; `string'
PUBLIC	??_C@_0BA@HEFKJKJG@high_constraint?$AA@		; `string'
PUBLIC	??_C@_0N@BGNGCLLP@content_rank?$AA@		; `string'
PUBLIC	??_C@_0BD@DOOANBHL@on_method_instance?$AA@	; `string'
PUBLIC	??_C@_0M@GPHPDHLO@on_quantity?$AA@		; `string'
PUBLIC	??_C@_0M@CFABBPOL@on_boundary?$AA@		; `string'
PUBLIC	??_C@_0BE@CFDLCAJO@value_of_constraint?$AA@	; `string'
PUBLIC	??_C@_0P@FJLNFBKF@hit_constraint?$AA@		; `string'
PUBLIC	??_C@_0O@KEPICJKL@on_constraint?$AA@		; `string'
PUBLIC	??_C@_0M@GOLNCKNL@slice_coeff?$AA@		; `string'
PUBLIC	??_C@_0L@PJJPIEAP@clip_coeff?$AA@		; `string'
PUBLIC	??_C@_0BB@EHCKFCGI@mpi_local_bodies?$AA@	; `string'
PUBLIC	??_C@_07IJGPCJHC@opacity?$AA@			; `string'
PUBLIC	??_C@_0BL@GEDNAPDC@method_instances_predicted?$AA@ ; `string'
PUBLIC	??_C@_0BF@MMBIFFBD@quantities_predicted?$AA@	; `string'
PUBLIC	??_C@_0BF@OBIIONED@facetedges_predicted?$AA@	; `string'
PUBLIC	??_C@_0BB@PCLCALDK@bodies_predicted?$AA@	; `string'
PUBLIC	??_C@_0BB@HJFNDLDG@facets_predicted?$AA@	; `string'
PUBLIC	??_C@_0BA@EPBHJJLH@edges_predicted?$AA@		; `string'
PUBLIC	??_C@_0BD@ICOCBELD@vertices_predicted?$AA@	; `string'
PUBLIC	??_C@_0BA@GIOJPOGN@calculate_in_3d?$AA@		; `string'
PUBLIC	??_C@_06INBLBDJM@?5?7?$AN?0?3?$DL?$AA@		; `string'
PUBLIC	??_C@_01JEJKBAGA@g?$AA@				; `string'
PUBLIC	??_C@_01KGKMHCOC@e?$AA@				; `string'
PUBLIC	??_C@_02OAHAJOFD@pi?$AA@			; `string'
PUBLIC	_yyin
PUBLIC	_yyout
PUBLIC	_const_expr_keywords
PUBLIC	_next_err_token
PUBLIC	_line_no
PUBLIC	_whitespace
PUBLIC	_datafile_keywords
PUBLIC	_mathfunc_keywords
PUBLIC	_mathfunc2_keywords
PUBLIC	_command_keywords
PUBLIC	_togglenames
PUBLIC	_colornames
PUBLIC	_internal_variables
PUBLIC	_inputbuffersize
PUBLIC	_inputbufferspot
PUBLIC	_inputsave_flag
PUBLIC	_ubuff_max
PUBLIC	_ubuff_spot
_DATA	SEGMENT
COMM	_macro_subs_max:DWORD
COMM	_inputbuffer:DWORD
COMM	_unput_tok_count:DWORD
COMM	_macro_subs_top:DWORD
COMM	_err_tok_gen_flag:DWORD
COMM	_yytext_max:DWORD
COMM	_morebuff:BYTE:03eaH
COMM	_unput_buff:DWORD
COMM	_yyleng:DWORD
COMM	_yylval:BYTE:068H
COMM	_macro_flag:DWORD
COMM	_unputted_tok:DWORD:0aH
COMM	_macro_max:DWORD
COMM	_yytext:DWORD
COMM	_token_count:DWORD
_DATA	ENDS
_BSS	SEGMENT
_yy_current_buffer DD 01H DUP (?)
_yy_c_buf_p DD	01H DUP (?)
_yy_start DD	01H DUP (?)
_yyin	DD	01H DUP (?)
_yyout	DD	01H DUP (?)
_previous_char DD 01H DUP (?)
_BUFFSIZE DD	01H DUP (?)
_buff	DD	01H DUP (?)
_spot	DD	01H DUP (?)
_next_err_token DD 01H DUP (?)
_inputbuffersize DD 01H DUP (?)
_inputbufferspot DD 01H DUP (?)
_inputsave_flag DD 01H DUP (?)
?sorted@?1??identcase@@9@9 DD 01H DUP (?)		; `identcase'::`2'::sorted
_ubuff_max DD	01H DUP (?)
_ubuff_spot DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0M@FKBLKCGO@where_count?$AA@
CONST	SEGMENT
??_C@_0M@FKBLKCGO@where_count?$AA@ DB 'where_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NANCMDLE@pop_count?$AA@
CONST	SEGMENT
??_C@_09NANCMDLE@pop_count?$AA@ DB 'pop_count', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JACOHDHP@dissolve_count?$AA@
CONST	SEGMENT
??_C@_0P@JACOHDHP@dissolve_count?$AA@ DB 'dissolve_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KEDMJLF@notch_count?$AA@
CONST	SEGMENT
??_C@_0M@KEDMJLF@notch_count?$AA@ DB 'notch_count', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BGIPOCMC@refine_count?$AA@
CONST	SEGMENT
??_C@_0N@BGIPOCMC@refine_count?$AA@ DB 'refine_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDBAOLCA@delete_count?$AA@
CONST	SEGMENT
??_C@_0N@MDBAOLCA@delete_count?$AA@ DB 'delete_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MMIEKJIF@equi_count?$AA@
CONST	SEGMENT
??_C@_0L@MMIEKJIF@equi_count?$AA@ DB 'equi_count', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FLAJOIPD@hessian_epsilon?$AA@
CONST	SEGMENT
??_C@_0BA@FLAJOIPD@hessian_epsilon?$AA@ DB 'hessian_epsilon', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PMIPBODO@total_length?$AA@
CONST	SEGMENT
??_C@_0N@PMIPBODO@total_length?$AA@ DB 'total_length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KNDBPLBH@total_area?$AA@
CONST	SEGMENT
??_C@_0L@KNDBPLBH@total_area?$AA@ DB 'total_area', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FOHOADKL@total_energy?$AA@
CONST	SEGMENT
??_C@_0N@FOHOADKL@total_energy?$AA@ DB 'total_energy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KJPGFHE@facetedge_count?$AA@
CONST	SEGMENT
??_C@_0BA@KJPGFHE@facetedge_count?$AA@ DB 'facetedge_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BLNIGKEE@body_count?$AA@
CONST	SEGMENT
??_C@_0L@BLNIGKEE@body_count?$AA@ DB 'body_count', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MDEFFDDC@facet_count?$AA@
CONST	SEGMENT
??_C@_0M@MDEFFDDC@facet_count?$AA@ DB 'facet_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NIJKJMJB@edge_count?$AA@
CONST	SEGMENT
??_C@_0L@NIJKJMJB@edge_count?$AA@ DB 'edge_count', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HPKCIPGC@vertex_count?$AA@
CONST	SEGMENT
??_C@_0N@HPKCIPGC@vertex_count?$AA@ DB 'vertex_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FONFPPOA@scale_scale?$AA@
CONST	SEGMENT
??_C@_0M@FONFPPOA@scale_scale?$AA@ DB 'scale_scale', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OLOACPCP@iteration_counter?$AA@
CONST	SEGMENT
??_C@_0BC@OLOACPCP@iteration_counter?$AA@ DB 'iteration_counter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HHELJMGO@jiggle_temperature?$AA@
CONST	SEGMENT
??_C@_0BD@HHELJMGO@jiggle_temperature?$AA@ DB 'jiggle_temperature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OAKPPPIB@eigenzero?$AA@
CONST	SEGMENT
??_C@_09OAKPPPIB@eigenzero?$AA@ DB 'eigenzero', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPNFMFBP@eigenneg?$AA@
CONST	SEGMENT
??_C@_08EPNFMFBP@eigenneg?$AA@ DB 'eigenneg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NMCKLHDA@eigenpos?$AA@
CONST	SEGMENT
??_C@_08NMCKLHDA@eigenpos?$AA@ DB 'eigenpos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BENLKAPC@eigen_zero?$AA@
CONST	SEGMENT
??_C@_0L@BENLKAPC@eigen_zero?$AA@ DB 'eigen_zero', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OPDPOHAJ@eigen_neg?$AA@
CONST	SEGMENT
??_C@_09OPDPOHAJ@eigen_neg?$AA@ DB 'eigen_neg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HMMAJFCG@eigen_pos?$AA@
CONST	SEGMENT
??_C@_09HMMAJFCG@eigen_pos?$AA@ DB 'eigen_pos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBHOIHHJ@pickfnum?$AA@
CONST	SEGMENT
??_C@_08LBHOIHHJ@pickfnum?$AA@ DB 'pickfnum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PGNOPNKJ@pickenum?$AA@
CONST	SEGMENT
??_C@_08PGNOPNKJ@pickenum?$AA@ DB 'pickenum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NBJOBAPL@pickvnum?$AA@
CONST	SEGMENT
??_C@_08NBJOBAPL@pickvnum?$AA@ DB 'pickvnum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GFGAKDLL@quadratic_metric_mix?$AA@
CONST	SEGMENT
??_C@_0BF@GFGAKDLL@quadratic_metric_mix?$AA@ DB 'quadratic_metric_mix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DAHPKAPK@linear_metric_mix?$AA@
CONST	SEGMENT
??_C@_0BC@DAHPKAPK@linear_metric_mix?$AA@ DB 'linear_metric_mix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06NLFCANPD@random?$AA@
CONST	SEGMENT
??_C@_06NLFCANPD@random?$AA@ DB 'random', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PANFJEDO@random_seed?$AA@
CONST	SEGMENT
??_C@_0M@PANFJEDO@random_seed?$AA@ DB 'random_seed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CHOAMOKA@last_hessian_scale?$AA@
CONST	SEGMENT
??_C@_0BD@CHOAMOKA@last_hessian_scale?$AA@ DB 'last_hessian_scale', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OBNGJMBG@last_eigenvalue?$AA@
CONST	SEGMENT
??_C@_0BA@OBNGJMBG@last_eigenvalue?$AA@ DB 'last_eigenvalue', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GLPKLBIH@thickness?$AA@
CONST	SEGMENT
??_C@_09GLPKLBIH@thickness?$AA@ DB 'thickness', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHHBGKKF@target_tolerance?$AA@
CONST	SEGMENT
??_C@_0BB@GHHBGKKF@target_tolerance?$AA@ DB 'target_tolerance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBHAPOJO@cpu_counter?$AA@
CONST	SEGMENT
??_C@_0M@HBHAPOJO@cpu_counter?$AA@ DB 'cpu_counter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05DDECJJKE@clock?$AA@
CONST	SEGMENT
??_C@_05DDECJJKE@clock?$AA@ DB 'clock', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BIIIJIED@transform_count?$AA@
CONST	SEGMENT
??_C@_0BA@BIIIJIED@transform_count?$AA@ DB 'transform_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JDILIPNO@diffusion_coeff?$AA@
CONST	SEGMENT
??_C@_0BA@JDILIPNO@diffusion_coeff?$AA@ DB 'diffusion_coeff', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BECHNFGG@brightness?$AA@
CONST	SEGMENT
??_C@_0L@BECHNFGG@brightness?$AA@ DB 'brightness', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EGCKCJDC@background?$AA@
CONST	SEGMENT
??_C@_0L@EGCKCJDC@background?$AA@ DB 'background', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJPPNBCL@memory_used?$AA@
CONST	SEGMENT
??_C@_0M@NJPPNBCL@memory_used?$AA@ DB 'memory_used', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HIDDLAJM@memory_arena?$AA@
CONST	SEGMENT
??_C@_0N@HIDDLAJM@memory_arena?$AA@ DB 'memory_arena', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IAKFAOLO@last_error?$AA@
CONST	SEGMENT
??_C@_0L@IAKFAOLO@last_error?$AA@ DB 'last_error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OAPNEHDB@ambient_pressure_value?$AA@
CONST	SEGMENT
??_C@_0BH@OAPNEHDB@ambient_pressure_value?$AA@ DB 'ambient_pressure_value'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PLHANHAM@hessian_slant_cutoff?$AA@
CONST	SEGMENT
??_C@_0BF@PLHANHAM@hessian_slant_cutoff?$AA@ DB 'hessian_slant_cutoff', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MEOACIKB@breakflag?$AA@
CONST	SEGMENT
??_C@_09MEOACIKB@breakflag?$AA@ DB 'breakflag', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HBCDBDGE@bad_error_count?$AA@
CONST	SEGMENT
??_C@_0BA@HBCDBDGE@bad_error_count?$AA@ DB 'bad_error_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CKKLJMAI@facets_same_vertices_count?$AA@
CONST	SEGMENT
??_C@_0BL@CKKLJMAI@facets_same_vertices_count?$AA@ DB 'facets_same_vertic'
	DB	'es_count', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JKNABKBA@edges_same_vertices_count?$AA@
CONST	SEGMENT
??_C@_0BK@JKNABKBA@edges_same_vertices_count?$AA@ DB 'edges_same_vertices'
	DB	'_count', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMPBMHMF@edge_loop_count?$AA@
CONST	SEGMENT
??_C@_0BA@GMPBMHMF@edge_loop_count?$AA@ DB 'edge_loop_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LLHOBCKD@inconsistent_bodies_count?$AA@
CONST	SEGMENT
??_C@_0BK@LLHOBCKD@inconsistent_bodies_count?$AA@ DB 'inconsistent_bodies'
	DB	'_count', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CJKHIDDP@bad_next_prev_count?$AA@
CONST	SEGMENT
??_C@_0BE@CJKHIDDP@bad_next_prev_count?$AA@ DB 'bad_next_prev_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PLDEDAON@check_count?$AA@
CONST	SEGMENT
??_C@_0M@PLDEDAON@check_count?$AA@ DB 'check_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GILLHKAL@visibility_debug?$AA@
CONST	SEGMENT
??_C@_0BB@GILLHKAL@visibility_debug?$AA@ DB 'visibility_debug', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NLMEBPED@scrollbuffersize?$AA@
CONST	SEGMENT
??_C@_0BB@NLMEBPED@scrollbuffersize?$AA@ DB 'scrollbuffersize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OFCJADDO@ps_gridedgewidth?$AA@
CONST	SEGMENT
??_C@_0BB@OFCJADDO@ps_gridedgewidth?$AA@ DB 'ps_gridedgewidth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NEEDDBHF@ps_bareedgewidth?$AA@
CONST	SEGMENT
??_C@_0BB@NEEDDBHF@ps_bareedgewidth?$AA@ DB 'ps_bareedgewidth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LMLNIMJE@ps_conedgewidth?$AA@
CONST	SEGMENT
??_C@_0BA@LMLNIMJE@ps_conedgewidth?$AA@ DB 'ps_conedgewidth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DOBHCOCD@ps_tripleedgewidth?$AA@
CONST	SEGMENT
??_C@_0BD@DOBHCOCD@ps_tripleedgewidth?$AA@ DB 'ps_tripleedgewidth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CPCJJCCO@ps_fixededgewidth?$AA@
CONST	SEGMENT
??_C@_0BC@CPCJJCCO@ps_fixededgewidth?$AA@ DB 'ps_fixededgewidth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MKDKOLJB@ps_stringwidth?$AA@
CONST	SEGMENT
??_C@_0P@MKDKOLJB@ps_stringwidth?$AA@ DB 'ps_stringwidth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PPOIJFFB@ps_labelsize?$AA@
CONST	SEGMENT
??_C@_0N@PPOIJFFB@ps_labelsize?$AA@ DB 'ps_labelsize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EADCAAG@t1_edgeswap_count?$AA@
CONST	SEGMENT
??_C@_0BC@EADCAAG@t1_edgeswap_count?$AA@ DB 't1_edgeswap_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IOOMGAHI@edgeswap_count?$AA@
CONST	SEGMENT
??_C@_0P@IOOMGAHI@edgeswap_count?$AA@ DB 'edgeswap_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GEAHEOKO@pop_quad_to_quad_count?$AA@
CONST	SEGMENT
??_C@_0BH@GEAHEOKO@pop_quad_to_quad_count?$AA@ DB 'pop_quad_to_quad_count'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LGGDNHOG@pop_edge_to_tri_count?$AA@
CONST	SEGMENT
??_C@_0BG@LGGDNHOG@pop_edge_to_tri_count?$AA@ DB 'pop_edge_to_tri_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NFPFNFEP@pop_tri_to_edge_count?$AA@
CONST	SEGMENT
??_C@_0BG@NFPFNFEP@pop_tri_to_edge_count?$AA@ DB 'pop_tri_to_edge_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CIHELNID@edge_pop_count?$AA@
CONST	SEGMENT
??_C@_0P@CIHELNID@edge_pop_count?$AA@ DB 'edge_pop_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PNOKJDFD@vertex_pop_count?$AA@
CONST	SEGMENT
??_C@_0BB@PNOKJDFD@vertex_pop_count?$AA@ DB 'vertex_pop_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KDOCBOAO@facet_refine_count?$AA@
CONST	SEGMENT
??_C@_0BD@KDOCBOAO@facet_refine_count?$AA@ DB 'facet_refine_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LJKCEDIK@edge_refine_count?$AA@
CONST	SEGMENT
??_C@_0BC@LJKCEDIK@edge_refine_count?$AA@ DB 'edge_refine_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CKCDJLNA@body_dissolve_count?$AA@
CONST	SEGMENT
??_C@_0BE@CKCDJLNA@body_dissolve_count?$AA@ DB 'body_dissolve_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EDGKOAGH@facet_dissolve_count?$AA@
CONST	SEGMENT
??_C@_0BF@EDGKOAGH@facet_dissolve_count?$AA@ DB 'facet_dissolve_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JFPIKCB@edge_dissolve_count?$AA@
CONST	SEGMENT
??_C@_0BE@JFPIKCB@edge_dissolve_count?$AA@ DB 'edge_dissolve_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MLIFIJNF@vertex_dissolve_count?$AA@
CONST	SEGMENT
??_C@_0BG@MLIFIJNF@vertex_dissolve_count?$AA@ DB 'vertex_dissolve_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HGHNBHOM@facet_delete_count?$AA@
CONST	SEGMENT
??_C@_0BD@HGHNBHOM@facet_delete_count?$AA@ DB 'facet_delete_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GMDNEKGI@edge_delete_count?$AA@
CONST	SEGMENT
??_C@_0BC@GMDNEKGI@edge_delete_count?$AA@ DB 'edge_delete_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HMIJLFOH@unfix_count?$AA@
CONST	SEGMENT
??_C@_0M@HMIJLFOH@unfix_count?$AA@ DB 'unfix_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FKJNFACE@fix_count?$AA@
CONST	SEGMENT
??_C@_09FKJNFACE@fix_count?$AA@ DB 'fix_count', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IOPDAKCK@mindeg_margin?$AA@
CONST	SEGMENT
??_C@_0O@IOPDAKCK@mindeg_margin?$AA@ DB 'mindeg_margin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CCPNJHKC@mindeg_min_region_size?$AA@
CONST	SEGMENT
??_C@_0BH@CCPNJHKC@mindeg_min_region_size?$AA@ DB 'mindeg_min_region_size'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ICNMFEGJ@mindeg_debug_level?$AA@
CONST	SEGMENT
??_C@_0BD@ICNMFEGJ@mindeg_debug_level?$AA@ DB 'mindeg_debug_level', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LMLDEADG@window_aspect_ratio?$AA@
CONST	SEGMENT
??_C@_0BE@LMLDEADG@window_aspect_ratio?$AA@ DB 'window_aspect_ratio', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LEOGOINP@this_task?$AA@
CONST	SEGMENT
??_C@_09LEOGOINP@this_task?$AA@ DB 'this_task', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JCMEGIAD@mpi_maxtask?$AA@
CONST	SEGMENT
??_C@_0M@JCMEGIAD@mpi_maxtask?$AA@ DB 'mpi_maxtask', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ILKHNNHO@corona_state?$AA@
CONST	SEGMENT
??_C@_0N@ILKHNNHO@corona_state?$AA@ DB 'corona_state', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CENGABA@string_curve_tolerance?$AA@
CONST	SEGMENT
??_C@_0BH@CENGABA@string_curve_tolerance?$AA@ DB 'string_curve_tolerance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OIGENEKE@autochop_length?$AA@
CONST	SEGMENT
??_C@_0BA@OIGENEKE@autochop_length?$AA@ DB 'autochop_length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GKOHKDJ@detorus_epsilon?$AA@
CONST	SEGMENT
??_C@_0BA@GKOHKDJ@detorus_epsilon?$AA@ DB 'detorus_epsilon', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ENGCHOCN@bounding_box_color?$AA@
CONST	SEGMENT
??_C@_0BD@ENGCHOCN@bounding_box_color?$AA@ DB 'bounding_box_color', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PMAELIEO@white?$AA@
CONST	SEGMENT
??_C@_05PMAELIEO@white?$AA@ DB 'white', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ENJNJKEL@yellow?$AA@
CONST	SEGMENT
??_C@_06ENJNJKEL@yellow?$AA@ DB 'yellow', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BBECPGBJ@lightmagenta?$AA@
CONST	SEGMENT
??_C@_0N@BBECPGBJ@lightmagenta?$AA@ DB 'lightmagenta', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EEFKFEFN@lightred?$AA@
CONST	SEGMENT
??_C@_08EEFKFEFN@lightred?$AA@ DB 'lightred', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KPGEKFMK@lightcyan?$AA@
CONST	SEGMENT
??_C@_09KPGEKFMK@lightcyan?$AA@ DB 'lightcyan', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OPBGACJD@lightgreen?$AA@
CONST	SEGMENT
??_C@_0L@OPBGACJD@lightgreen?$AA@ DB 'lightgreen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NBIPJLA@lightblue?$AA@
CONST	SEGMENT
??_C@_09NBIPJLA@lightblue?$AA@ DB 'lightblue', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EHDJKNHJ@darkgrey?$AA@
CONST	SEGMENT
??_C@_08EHDJKNHJ@darkgrey?$AA@ DB 'darkgrey', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EADAAFKF@darkgray?$AA@
CONST	SEGMENT
??_C@_08EADAAFKF@darkgray?$AA@ DB 'darkgray', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GDBIAANM@grey?$AA@
CONST	SEGMENT
??_C@_04GDBIAANM@grey?$AA@ DB 'grey', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GEBBKIAA@gray?$AA@
CONST	SEGMENT
??_C@_04GEBBKIAA@gray?$AA@ DB 'gray', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IPGPKIEB@lightgrey?$AA@
CONST	SEGMENT
??_C@_09IPGPKIEB@lightgrey?$AA@ DB 'lightgrey', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IIGGAAJN@lightgray?$AA@
CONST	SEGMENT
??_C@_09IIGGAAJN@lightgray?$AA@ DB 'lightgray', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05EBJGJMAL@brown?$AA@
CONST	SEGMENT
??_C@_05EBJGJMAL@brown?$AA@ DB 'brown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EMDGAPCI@magenta?$AA@
CONST	SEGMENT
??_C@_07EMDGAPCI@magenta?$AA@ DB 'magenta', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FAAAOPJM@red?$AA@
CONST	SEGMENT
??_C@_03FAAAOPJM@red?$AA@ DB 'red', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EDBDANFH@cyan?$AA@
CONST	SEGMENT
??_C@_04EDBDANFH@cyan?$AA@ DB 'cyan', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GBEEJKMC@green?$AA@
CONST	SEGMENT
??_C@_05GBEEJKMC@green?$AA@ DB 'green', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OBGPFBCN@blue?$AA@
CONST	SEGMENT
??_C@_04OBGPFBCN@blue?$AA@ DB 'blue', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BIMBDNDC@black?$AA@
CONST	SEGMENT
??_C@_05BIMBDNDC@black?$AA@ DB 'black', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CEEDCJLA@transparent?$AA@
CONST	SEGMENT
??_C@_0M@CEEDCJLA@transparent?$AA@ DB 'transparent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEHLAELG@clear?$AA@
CONST	SEGMENT
??_C@_05MEHLAELG@clear?$AA@ DB 'clear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BCIELMPF@pinning?$AA@
CONST	SEGMENT
??_C@_07BCIELMPF@pinning?$AA@ DB 'pinning', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MABNKBMJ@autorecalc?$AA@
CONST	SEGMENT
??_C@_0L@MABNKBMJ@autorecalc?$AA@ DB 'autorecalc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LJJGFBGD@metric_conversion?$AA@
CONST	SEGMENT
??_C@_0BC@LJJGFBGD@metric_conversion?$AA@ DB 'metric_conversion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BPDDPHCA@gv_binary?$AA@
CONST	SEGMENT
??_C@_09BPDDPHCA@gv_binary?$AA@ DB 'gv_binary', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FFMNCIGF@self_similar?$AA@
CONST	SEGMENT
??_C@_0N@FFMNCIGF@self_similar?$AA@ DB 'self_similar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KHPBBAHH@div_normal_curvature?$AA@
CONST	SEGMENT
??_C@_0BF@KHPBBAHH@div_normal_curvature?$AA@ DB 'div_normal_curvature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IBJKBKNG@shading?$AA@
CONST	SEGMENT
??_C@_07IBJKBKNG@shading?$AA@ DB 'shading', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BNMHNAMC@facet_colors?$AA@
CONST	SEGMENT
??_C@_0N@BNMHNAMC@facet_colors?$AA@ DB 'facet_colors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BAKALBHB@conj_grad?$AA@
CONST	SEGMENT
??_C@_09BAKALBHB@conj_grad?$AA@ DB 'conj_grad', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HCDDDEHN@hessian_quiet?$AA@
CONST	SEGMENT
??_C@_0O@HCDDDEHN@hessian_quiet?$AA@ DB 'hessian_quiet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HBPOHFLN@quietgo?$AA@
CONST	SEGMENT
??_C@_07HBPOHFLN@quietgo?$AA@ DB 'quietgo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PMBAOCDH@quiet?$AA@
CONST	SEGMENT
??_C@_05PMBAOCDH@quiet?$AA@ DB 'quiet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DLCCMBJF@transforms?$AA@
CONST	SEGMENT
??_C@_0L@DLCCMBJF@transforms?$AA@ DB 'transforms', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NFINOFHM@post_project?$AA@
CONST	SEGMENT
??_C@_0N@NFINOFHM@post_project?$AA@ DB 'post_project', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LDELGPJH@estimate?$AA@
CONST	SEGMENT
??_C@_08LDELGPJH@estimate?$AA@ DB 'estimate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GFBFDLBM@gravity?$AA@
CONST	SEGMENT
??_C@_07GFBFDLBM@gravity?$AA@ DB 'gravity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GGEALCBM@itdebug?$AA@
CONST	SEGMENT
??_C@_07GGEALCBM@itdebug?$AA@ DB 'itdebug', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08ONKONDHK@memdebug?$AA@
CONST	SEGMENT
??_C@_08ONKONDHK@memdebug?$AA@ DB 'memdebug', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFCDIDHO@debug?$AA@
CONST	SEGMENT
??_C@_05GFCDIDHO@debug?$AA@ DB 'debug', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OGHBAHOF@check_increase?$AA@
CONST	SEGMENT
??_C@_0P@OGHBAHOF@check_increase?$AA@ DB 'check_increase', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GGBEIMML@approx_curv?$AA@
CONST	SEGMENT
??_C@_0M@GGBEIMML@approx_curv?$AA@ DB 'approx_curv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MINHKHMD@old_area?$AA@
CONST	SEGMENT
??_C@_08MINHKHMD@old_area?$AA@ DB 'old_area', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07ENPKKAPH@sqgauss?$AA@
CONST	SEGMENT
??_C@_07ENPKKAPH@sqgauss?$AA@ DB 'sqgauss', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFCEMNNF@conf_edge?$AA@
CONST	SEGMENT
??_C@_09MFCEMNNF@conf_edge?$AA@ DB 'conf_edge', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EMJKOPJK@view_4d?$AA@
CONST	SEGMENT
??_C@_07EMJKOPJK@view_4d?$AA@ DB 'view_4d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IGFDKMHM@kusner?$AA@
CONST	SEGMENT
??_C@_06IGFDKMHM@kusner?$AA@ DB 'kusner', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LLNNGCPP@deturck?$AA@
CONST	SEGMENT
??_C@_07LLNNGCPP@deturck?$AA@ DB 'deturck', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PKIOMPCC@normal_motion?$AA@
CONST	SEGMENT
??_C@_0O@PKIOMPCC@normal_motion?$AA@ DB 'normal_motion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PBIFKJMI@hessian_diff?$AA@
CONST	SEGMENT
??_C@_0N@PBIFKJMI@hessian_diff?$AA@ DB 'hessian_diff', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KCLCNBJB@thicken?$AA@
CONST	SEGMENT
??_C@_07KCLCNBJB@thicken?$AA@ DB 'thicken', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OMBDDLKJ@colormap?$AA@
CONST	SEGMENT
??_C@_08OMBDDLKJ@colormap?$AA@ DB 'colormap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LOICIGID@show_outer?$AA@
CONST	SEGMENT
??_C@_0L@LOICIGID@show_outer?$AA@ DB 'show_outer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FMBIOPNC@connected_cells?$AA@
CONST	SEGMENT
??_C@_0BA@FMBIOPNC@connected_cells?$AA@ DB 'connected_cells', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JGOMOAGJ@connected?$AA@
CONST	SEGMENT
??_C@_09JGOMOAGJ@connected?$AA@ DB 'connected', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DNEEIDBP@raw_cells?$AA@
CONST	SEGMENT
??_C@_09DNEEIDBP@raw_cells?$AA@ DB 'raw_cells', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ILHEOIGK@clipped_cells?$AA@
CONST	SEGMENT
??_C@_0O@ILHEOIGK@clipped_cells?$AA@ DB 'clipped_cells', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HKDEBIPG@clipped?$AA@
CONST	SEGMENT
??_C@_07HKDEBIPG@clipped?$AA@ DB 'clipped', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EAEPHEPG@show_inner?$AA@
CONST	SEGMENT
??_C@_0L@EAEPHEPG@show_inner?$AA@ DB 'show_inner', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DMCDJPBF@autodisplay?$AA@
CONST	SEGMENT
??_C@_0M@DMCDJPBF@autodisplay?$AA@ DB 'autodisplay', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MHBOMMFK@force_pos_def?$AA@
CONST	SEGMENT
??_C@_0O@MHBOMMFK@force_pos_def?$AA@ DB 'force_pos_def', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PIJPCAMN@ribiere?$AA@
CONST	SEGMENT
??_C@_07PIJPCAMN@ribiere?$AA@ DB 'ribiere', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NLJCNNPB@assume_oriented?$AA@
CONST	SEGMENT
??_C@_0BA@NLJCNNPB@assume_oriented?$AA@ DB 'assume_oriented', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BMDMDICD@hessian_normal?$AA@
CONST	SEGMENT
??_C@_0P@BMDMDICD@hessian_normal?$AA@ DB 'hessian_normal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GKFGPBHG@bunch_kauffman?$AA@
CONST	SEGMENT
??_C@_0P@GKFGPBHG@bunch_kauffman?$AA@ DB 'bunch_kauffman', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BFFIKKOE@bunch_kaufman?$AA@
CONST	SEGMENT
??_C@_0O@BFFIKKOE@bunch_kaufman?$AA@ DB 'bunch_kaufman', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JKDNAPFH@mkl?$AA@
CONST	SEGMENT
??_C@_03JKDNAPFH@mkl?$AA@ DB 'mkl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NLKFKEKL@ysmp?$AA@
CONST	SEGMENT
??_C@_04NLKFKEKL@ysmp?$AA@ DB 'ysmp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HGBJAEID@quantities_only?$AA@
CONST	SEGMENT
??_C@_0BA@HGBJAEID@quantities_only?$AA@ DB 'quantities_only', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OHNEFNEP@metric_convert?$AA@
CONST	SEGMENT
??_C@_0P@OHNEFNEP@metric_convert?$AA@ DB 'metric_convert', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PLHGPNIO@linear_metric?$AA@
CONST	SEGMENT
??_C@_0O@PLHGPNIO@linear_metric?$AA@ DB 'linear_metric', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GPGBGBKF@squared_gradient?$AA@
CONST	SEGMENT
??_C@_0BB@GPGBGBKF@squared_gradient?$AA@ DB 'squared_gradient', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GLJECMNP@h_inverse_metric?$AA@
CONST	SEGMENT
??_C@_0BB@GLJECMNP@h_inverse_metric?$AA@ DB 'h_inverse_metric', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GAEGJDMI@hessian_double_normal?$AA@
CONST	SEGMENT
??_C@_0BG@GAEGJDMI@hessian_double_normal?$AA@ DB 'hessian_double_normal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HMMIFHMP@hessian_normal_one?$AA@
CONST	SEGMENT
??_C@_0BD@HMMIFHMP@hessian_normal_one?$AA@ DB 'hessian_normal_one', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ECHDFDIC@ps_labelflag?$AA@
CONST	SEGMENT
??_C@_0N@ECHDFDIC@ps_labelflag?$AA@ DB 'ps_labelflag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KMOLHLBE@labelflag?$AA@
CONST	SEGMENT
??_C@_09KMOLHLBE@labelflag?$AA@ DB 'labelflag', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDFPOHGI@ps_crossingflag?$AA@
CONST	SEGMENT
??_C@_0BA@MDFPOHGI@ps_crossingflag?$AA@ DB 'ps_crossingflag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JJEIJGBI@crossingflag?$AA@
CONST	SEGMENT
??_C@_0N@JJEIJGBI@crossingflag?$AA@ DB 'crossingflag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EGOBEDIK@gridflag?$AA@
CONST	SEGMENT
??_C@_08EGOBEDIK@gridflag?$AA@ DB 'gridflag', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NAKIPJII@ps_gridflag?$AA@
CONST	SEGMENT
??_C@_0M@NAKIPJII@ps_gridflag?$AA@ DB 'ps_gridflag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LOFHKFBI@ps_cmykflag?$AA@
CONST	SEGMENT
??_C@_0M@LOFHKFBI@ps_cmykflag?$AA@ DB 'ps_cmykflag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PDJMPNAK@ps_colorflag?$AA@
CONST	SEGMENT
??_C@_0N@PDJMPNAK@ps_colorflag?$AA@ DB 'ps_colorflag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MGNBMOID@pscolorflag?$AA@
CONST	SEGMENT
??_C@_0M@MGNBMOID@pscolorflag?$AA@ DB 'pscolorflag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PABNDBOD@show_all_quantities?$AA@
CONST	SEGMENT
??_C@_0BE@PABNDBOD@show_all_quantities?$AA@ DB 'show_all_quantities', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IEAFMCH@hessian_normal_perp?$AA@
CONST	SEGMENT
??_C@_0BE@IEAFMCH@hessian_normal_perp?$AA@ DB 'hessian_normal_perp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DJGEPEF@hessian_special_normal?$AA@
CONST	SEGMENT
??_C@_0BH@DJGEPEF@hessian_special_normal?$AA@ DB 'hessian_special_normal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PLJDOBHE@zener_drag?$AA@
CONST	SEGMENT
??_C@_0L@PLJDOBHE@zener_drag?$AA@ DB 'zener_drag', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PLDNIGHE@volgrads_every?$AA@
CONST	SEGMENT
??_C@_0P@PLDNIGHE@volgrads_every?$AA@ DB 'volgrads_every', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DFOEIAJO@interp_normals?$AA@
CONST	SEGMENT
??_C@_0P@DFOEIAJO@interp_normals?$AA@ DB 'interp_normals', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DOAHOLKA@rotate_lights?$AA@
CONST	SEGMENT
??_C@_0O@DOAHOLKA@rotate_lights?$AA@ DB 'rotate_lights', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KFLJAAGL@backcull?$AA@
CONST	SEGMENT
??_C@_08KFLJAAGL@backcull?$AA@ DB 'backcull', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JLCFDFN@ambient_pressure?$AA@
CONST	SEGMENT
??_C@_0BB@JLCFDFN@ambient_pressure?$AA@ DB 'ambient_pressure', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KBAMPNJK@verbose?$AA@
CONST	SEGMENT
??_C@_07KBAMPNJK@verbose?$AA@ DB 'verbose', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DEKALNNI@dirichlet_mode?$AA@
CONST	SEGMENT
??_C@_0P@DEKALNNI@dirichlet_mode?$AA@ DB 'dirichlet_mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IAKIABKB@sobolev_mode?$AA@
CONST	SEGMENT
??_C@_0N@IAKIABKB@sobolev_mode?$AA@ DB 'sobolev_mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EOAPCHNN@kraynikpopedge?$AA@
CONST	SEGMENT
??_C@_0P@EOAPCHNN@kraynikpopedge?$AA@ DB 'kraynikpopedge', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OFKJMHPN@kraynikpopvertex?$AA@
CONST	SEGMENT
??_C@_0BB@OFKJMHPN@kraynikpopvertex?$AA@ DB 'kraynikpopvertex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NAICPCIF@rgb_colors?$AA@
CONST	SEGMENT
??_C@_0L@NAICPCIF@rgb_colors?$AA@ DB 'rgb_colors', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ENFIPPEC@circular_arc_draw?$AA@
CONST	SEGMENT
??_C@_0BC@ENFIPPEC@circular_arc_draw?$AA@ DB 'circular_arc_draw', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NBAAGIKN@visibility_test?$AA@
CONST	SEGMENT
??_C@_0BA@NBAAGIKN@visibility_test?$AA@ DB 'visibility_test', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LILDNGFC@sparse_constraints?$AA@
CONST	SEGMENT
??_C@_0BD@LILDNGFC@sparse_constraints?$AA@ DB 'sparse_constraints', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OIKNNBJM@augmented_hessian?$AA@
CONST	SEGMENT
??_C@_0BC@OIKNNBJM@augmented_hessian?$AA@ DB 'augmented_hessian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ELACHHOE@blas_flag?$AA@
CONST	SEGMENT
??_C@_09ELACHHOE@blas_flag?$AA@ DB 'blas_flag', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GKDPKLCB@break_on_warning?$AA@
CONST	SEGMENT
??_C@_0BB@GKDPKLCB@break_on_warning?$AA@ DB 'break_on_warning', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HEFINIJJ@break_after_warning?$AA@
CONST	SEGMENT
??_C@_0BE@HEFINIJJ@break_after_warning?$AA@ DB 'break_after_warning', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OJEGAGKB@bezier_basis?$AA@
CONST	SEGMENT
??_C@_0N@OJEGAGKB@bezier_basis?$AA@ DB 'bezier_basis', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DFPINMIP@smooth_graph?$AA@
CONST	SEGMENT
??_C@_0N@DFPINMIP@smooth_graph?$AA@ DB 'smooth_graph', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PJOICEHA@mpi_debug?$AA@
CONST	SEGMENT
??_C@_09PJOICEHA@mpi_debug?$AA@ DB 'mpi_debug', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FHCBDAPB@pop_to_face?$AA@
CONST	SEGMENT
??_C@_0M@FHCBDAPB@pop_to_face?$AA@ DB 'pop_to_face', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CAFGBCMP@pop_to_edge?$AA@
CONST	SEGMENT
??_C@_0M@CAFGBCMP@pop_to_edge?$AA@ DB 'pop_to_edge', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NBNMFCPF@pop_enjoin?$AA@
CONST	SEGMENT
??_C@_0L@NBNMFCPF@pop_enjoin?$AA@ DB 'pop_enjoin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PDGIDHIC@pop_disjoin?$AA@
CONST	SEGMENT
??_C@_0M@PDGIDHIC@pop_disjoin?$AA@ DB 'pop_disjoin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PCBOIGLG@full_bounding_box?$AA@
CONST	SEGMENT
??_C@_0BC@PCBOIGLG@full_bounding_box?$AA@ DB 'full_bounding_box', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EKBDJBFN@little_endian?$AA@
CONST	SEGMENT
??_C@_0O@EKBDJBFN@little_endian?$AA@ DB 'little_endian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HGLBMAAF@big_endian?$AA@
CONST	SEGMENT
??_C@_0L@HGLBMAAF@big_endian?$AA@ DB 'big_endian', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EOFABKBN@quietload?$AA@
CONST	SEGMENT
??_C@_09EOFABKBN@quietload?$AA@ DB 'quietload', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FMDIMAMP@clip_view?$AA@
CONST	SEGMENT
??_C@_09FMDIMAMP@clip_view?$AA@ DB 'clip_view', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KMEPJMME@slice_view?$AA@
CONST	SEGMENT
??_C@_0L@KMEPJMME@slice_view?$AA@ DB 'slice_view', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GACLGPHB@function_quantity_sparse?$AA@
CONST	SEGMENT
??_C@_0BJ@GACLGPHB@function_quantity_sparse?$AA@ DB 'function_quantity_sp'
	DB	'arse', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BHLDEOD@force_deletion?$AA@
CONST	SEGMENT
??_C@_0P@BHLDEOD@force_deletion?$AA@ DB 'force_deletion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JPONPFLM@star_finagling?$AA@
CONST	SEGMENT
??_C@_0P@JPONPFLM@star_finagling?$AA@ DB 'star_finagling', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PCLABFDB@immediate_autopop?$AA@
CONST	SEGMENT
??_C@_0BC@PCLABFDB@immediate_autopop?$AA@ DB 'immediate_autopop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HBGAENON@detorus_sticky?$AA@
CONST	SEGMENT
??_C@_0P@HBGAENON@detorus_sticky?$AA@ DB 'detorus_sticky', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GFKKBGMN@view_transforms_use_unique_point@
CONST	SEGMENT
??_C@_0CB@GFKKBGMN@view_transforms_use_unique_point@ DB 'view_transforms_'
	DB	'use_unique_point', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FKFJNJHN@septum_flag?$AA@
CONST	SEGMENT
??_C@_0M@FKFJNJHN@septum_flag?$AA@ DB 'septum_flag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IOPGAMGF@show_bounding_box?$AA@
CONST	SEGMENT
??_C@_0BC@IOPGAMGF@show_bounding_box?$AA@ DB 'show_bounding_box', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FEGMCNGA@K_altitude_mode?$AA@
CONST	SEGMENT
??_C@_0BA@FEGMCNGA@K_altitude_mode?$AA@ DB 'K_altitude_mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BMEBABFE@show_all_edges?$AA@
CONST	SEGMENT
??_C@_0P@BMEBABFE@show_all_edges?$AA@ DB 'show_all_edges', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EJEJKKN@force_edgeswap?$AA@
CONST	SEGMENT
??_C@_0P@EJEJKKN@force_edgeswap?$AA@ DB 'force_edgeswap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GIBBNMIA@optimise?$AA@
CONST	SEGMENT
??_C@_08GIBBNMIA@optimise?$AA@ DB 'optimise', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHMAOHAP@optimize?$AA@
CONST	SEGMENT
??_C@_08GHMAOHAP@optimize?$AA@ DB 'optimize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BDEIOILB@recalc?$AA@
CONST	SEGMENT
??_C@_06BDEIOILB@recalc?$AA@ DB 'recalc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EPBFLBEJ@unset?$AA@
CONST	SEGMENT
??_C@_05EPBFLBEJ@unset?$AA@ DB 'unset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCHOJKKI@set?$AA@
CONST	SEGMENT
??_C@_03KCHOJKKI@set?$AA@ DB 'set', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OOLEAMGB@shell?$AA@
CONST	SEGMENT
??_C@_05OOLEAMGB@shell?$AA@ DB 'shell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KFIPBGJH@dissolve?$AA@
CONST	SEGMENT
??_C@_08KFIPBGJH@dissolve?$AA@ DB 'dissolve', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FOBLBEIN@delete?$AA@
CONST	SEGMENT
??_C@_06FOBLBEIN@delete?$AA@ DB 'delete', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GOBGMMII@showq?$AA@
CONST	SEGMENT
??_C@_05GOBGMMII@showq?$AA@ DB 'showq', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FKMICODN@show?$AA@
CONST	SEGMENT
??_C@_04FKMICODN@show?$AA@ DB 'show', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DONFEANM@list?$AA@
CONST	SEGMENT
??_C@_04DONFEANM@list?$AA@ DB 'list', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LCFPHLEE@where?$AA@
CONST	SEGMENT
??_C@_05LCFPHLEE@where?$AA@ DB 'where', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MEIPJMCG@sqcurve?$AA@
CONST	SEGMENT
??_C@_07MEIPJMCG@sqcurve?$AA@ DB 'sqcurve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GOEDGNCF@area?$AA@
CONST	SEGMENT
??_C@_04GOEDGNCF@area?$AA@ DB 'area', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HKCFKCGH@valence?$AA@
CONST	SEGMENT
??_C@_07HKCFKCGH@valence?$AA@ DB 'valence', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJDLPEM@length?$AA@
CONST	SEGMENT
??_C@_06IJDLPEM@length?$AA@ DB 'length', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BBAJEGNK@bottominfo?$AA@
CONST	SEGMENT
??_C@_0L@BBAJEGNK@bottominfo?$AA@ DB 'bottominfo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CFPPNLMH@topinfo?$AA@
CONST	SEGMENT
??_C@_07CFPPNLMH@topinfo?$AA@ DB 'topinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PLGJJJLK@oid?$AA@
CONST	SEGMENT
??_C@_03PLGJJJLK@oid?$AA@ DB 'oid', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id?$AA@
CONST	SEGMENT
??_C@_02EGCJHIOB@id?$AA@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MGNLKBNG@show_vol?$AA@
CONST	SEGMENT
??_C@_08MGNLKBNG@show_vol?$AA@ DB 'show_vol', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KJHPNPAA@check?$AA@
CONST	SEGMENT
??_C@_05KJHPNPAA@check?$AA@ DB 'check', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ELMCDMMG@refine?$AA@
CONST	SEGMENT
??_C@_06ELMCDMMG@refine?$AA@ DB 'refine', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPEDIMCA@go?$AA@
CONST	SEGMENT
??_C@_02KPEDIMCA@go?$AA@ DB 'go', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07ENILCFOA@rawestv?$AA@
CONST	SEGMENT
??_C@_07ENILCFOA@rawestv?$AA@ DB 'rawestv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BBIOILIO@rawv?$AA@
CONST	SEGMENT
??_C@_04BBIOILIO@rawv?$AA@ DB 'rawv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CDBKKPFJ@longj?$AA@
CONST	SEGMENT
??_C@_05CDBKKPFJ@longj?$AA@ DB 'longj', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IHFEJEKL@chdir?$AA@
CONST	SEGMENT
??_C@_05IHFEJEKL@chdir?$AA@ DB 'chdir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IJMOJOL@utest?$AA@
CONST	SEGMENT
??_C@_05IJMOJOL@utest?$AA@ DB 'utest', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HKCCIOCO@zoom?$AA@
CONST	SEGMENT
??_C@_04HKCCIOCO@zoom?$AA@ DB 'zoom', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HKDMGBBG@stability_test?$AA@
CONST	SEGMENT
??_C@_0P@HKDMGBBG@stability_test?$AA@ DB 'stability_test', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFGCEKPN@alice?$AA@
CONST	SEGMENT
??_C@_05MFGCEKPN@alice?$AA@ DB 'alice', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EKPFJKCG@edge_divide?$AA@
CONST	SEGMENT
??_C@_0M@EKPFJKCG@edge_divide?$AA@ DB 'edge_divide', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EFAMPBPP@edgeweed?$AA@
CONST	SEGMENT
??_C@_08EFAMPBPP@edgeweed?$AA@ DB 'edgeweed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KODKMLGA@areaweed?$AA@
CONST	SEGMENT
??_C@_08KODKMLGA@areaweed?$AA@ DB 'areaweed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCADLMAF@off?$AA@
CONST	SEGMENT
??_C@_03MCADLMAF@off?$AA@ DB 'off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MMGMMHEK@extrapolate?$AA@
CONST	SEGMENT
??_C@_0M@MMGMMHEK@extrapolate?$AA@ DB 'extrapolate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JMEOMOEA@counts?$AA@
CONST	SEGMENT
??_C@_06JMEOMOEA@counts?$AA@ DB 'counts', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02LIELOMNJ@on?$AA@
CONST	SEGMENT
??_C@_02LIELOMNJ@on?$AA@ DB 'on', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LFLJKKDA@procedures?$AA@
CONST	SEGMENT
??_C@_0L@LFLJKKDA@procedures?$AA@ DB 'procedures', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DNBEMPOF@binary_printf?$AA@
CONST	SEGMENT
??_C@_0O@DNBEMPOF@binary_printf?$AA@ DB 'binary_printf', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DNAEFDKF@sprintf?$AA@
CONST	SEGMENT
??_C@_07DNAEFDKF@sprintf?$AA@ DB 'sprintf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JOJNMAED@errprintf?$AA@
CONST	SEGMENT
??_C@_09JOJNMAED@errprintf?$AA@ DB 'errprintf', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OHJFMFMB@printf?$AA@
CONST	SEGMENT
??_C@_06OHJFMFMB@printf?$AA@ DB 'printf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HMBJBPPM@eprint?$AA@
CONST	SEGMENT
??_C@_06HMBJBPPM@eprint?$AA@ DB 'eprint', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IJDJACGD@print?$AA@
CONST	SEGMENT
??_C@_05IJDJACGD@print?$AA@ DB 'print', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CFFIJAMA@sum?$AA@
CONST	SEGMENT
??_C@_03CFFIJAMA@sum?$AA@ DB 'sum', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CHOBFJAH@avg?$AA@
CONST	SEGMENT
??_C@_03CHOBFJAH@avg?$AA@ DB 'avg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KLIPLJLL@min?$AA@
CONST	SEGMENT
??_C@_03KLIPLJLL@min?$AA@ DB 'min', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJAEFNNE@max?$AA@
CONST	SEGMENT
??_C@_03LJAEFNNE@max?$AA@ DB 'max', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08BKGECACE@dihedral?$AA@
CONST	SEGMENT
??_C@_08BKGECACE@dihedral?$AA@ DB 'dihedral', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BHDKNBMG@show_trans?$AA@
CONST	SEGMENT
??_C@_0L@BHDKNBMG@show_trans?$AA@ DB 'show_trans', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09INMNGPFE@show_expr?$AA@
CONST	SEGMENT
??_C@_09INMNGPFE@show_expr?$AA@ DB 'show_expr', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MFCDHBBC@loghistogram?$AA@
CONST	SEGMENT
??_C@_0N@MFCDHBBC@loghistogram?$AA@ DB 'loghistogram', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JOLNEMIB@histogram?$AA@
CONST	SEGMENT
??_C@_09JOLNEMIB@histogram?$AA@ DB 'histogram', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FHMCPBIP@else?$AA@
CONST	SEGMENT
??_C@_04FHMCPBIP@else?$AA@ DB 'else', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HOHPNOOD@then?$AA@
CONST	SEGMENT
??_C@_04HOHPNOOD@then?$AA@ DB 'then', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HEBPBKGD@if?$AA@
CONST	SEGMENT
??_C@_02HEBPBKGD@if?$AA@ DB 'if', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNAFDCHJ@do?$AA@
CONST	SEGMENT
??_C@_02KNAFDCHJ@do?$AA@ DB 'do', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OODBEKIG@while?$AA@
CONST	SEGMENT
??_C@_05OODBEKIG@while?$AA@ DB 'while', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GEEJHDPH@notch?$AA@
CONST	SEGMENT
??_C@_05GEEJHDPH@notch?$AA@ DB 'notch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MJMACJHA@permload?$AA@
CONST	SEGMENT
??_C@_08MJMACJHA@permload?$AA@ DB 'permload', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EONOHKEP@load?$AA@
CONST	SEGMENT
??_C@_04EONOHKEP@load?$AA@ DB 'load', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GGLOKIEE@dump?$AA@
CONST	SEGMENT
??_C@_04GGLOKIEE@dump?$AA@ DB 'dump', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MDONDFG@bye?$AA@
CONST	SEGMENT
??_C@_03MDONDFG@bye?$AA@ DB 'bye', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKNBDEPB@exit?$AA@
CONST	SEGMENT
??_C@_04MKNBDEPB@exit?$AA@ DB 'exit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KNNLNNGO@quit?$AA@
CONST	SEGMENT
??_C@_04KNNLNNGO@quit?$AA@ DB 'quit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help?$AA@
CONST	SEGMENT
??_C@_04PCJFHION@help?$AA@ DB 'help', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NJLPGECL@hessian_menu?$AA@
CONST	SEGMENT
??_C@_0N@NJLPGECL@hessian_menu?$AA@ DB 'hessian_menu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NOHLJNPG@hessian_seek?$AA@
CONST	SEGMENT
??_C@_0N@NOHLJNPG@hessian_seek?$AA@ DB 'hessian_seek', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IHNMECBN@hessian?$AA@
CONST	SEGMENT
??_C@_07IHNMECBN@hessian?$AA@ DB 'hessian', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MKIFIEMC@transform_expr?$AA@
CONST	SEGMENT
??_C@_0P@MKIFIEMC@transform_expr?$AA@ DB 'transform_expr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IPCFDLJD@transform_depth?$AA@
CONST	SEGMENT
??_C@_0BA@IPCFDLJD@transform_depth?$AA@ DB 'transform_depth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BOPEGKMG@show_off?$AA@
CONST	SEGMENT
??_C@_08BOPEGKMG@show_off?$AA@ DB 'show_off', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HANDHNGN@close_show?$AA@
CONST	SEGMENT
??_C@_0L@HANDHNGN@close_show?$AA@ DB 'close_show', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHINPAG@burchard?$AA@
CONST	SEGMENT
??_C@_08GHINPAG@burchard?$AA@ DB 'burchard', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HAMJBNFB@rebody?$AA@
CONST	SEGMENT
??_C@_06HAMJBNFB@rebody?$AA@ DB 'rebody', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07ICLAOFOB@foreach?$AA@
CONST	SEGMENT
??_C@_07ICLAOFOB@foreach?$AA@ DB 'foreach', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05INHNKAIM@unfix?$AA@
CONST	SEGMENT
??_C@_05INHNKAIM@unfix?$AA@ DB 'unfix', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GABGILGN@fix?$AA@
CONST	SEGMENT
??_C@_03GABGILGN@fix?$AA@ DB 'fix', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MMNEDCBK@history?$AA@
CONST	SEGMENT
??_C@_07MMNEDCBK@history?$AA@ DB 'history', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KBOMEDGA@total?$AA@
CONST	SEGMENT
??_C@_05KBOMEDGA@total?$AA@ DB 'total', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BLIMDDOG@dirichlet_seek?$AA@
CONST	SEGMENT
??_C@_0P@BLIMDDOG@dirichlet_seek?$AA@ DB 'dirichlet_seek', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JHHPCHFN@dirichlet?$AA@
CONST	SEGMENT
??_C@_09JHHPCHFN@dirichlet?$AA@ DB 'dirichlet', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KPIEIPJP@sobolev_seek?$AA@
CONST	SEGMENT
??_C@_0N@KPIEIPJP@sobolev_seek?$AA@ DB 'sobolev_seek', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NNCLFLCE@sobolev?$AA@
CONST	SEGMENT
??_C@_07NNCLFLCE@sobolev?$AA@ DB 'sobolev', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HNMJPKNA@attributes?$AA@
CONST	SEGMENT
??_C@_0L@HNMJPKNA@attributes?$AA@ DB 'attributes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CIOKLOBL@midv?$AA@
CONST	SEGMENT
??_C@_04CIOKLOBL@midv?$AA@ DB 'midv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PNAKCKLH@saddle?$AA@
CONST	SEGMENT
??_C@_06PNAKCKLH@saddle?$AA@ DB 'saddle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GOLFMCHH@geomview?$AA@
CONST	SEGMENT
??_C@_08GOLFMCHH@geomview?$AA@ DB 'geomview', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PEAHACPA@datafilename?$AA@
CONST	SEGMENT
??_C@_0N@PEAHACPA@datafilename?$AA@ DB 'datafilename', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DHNCNHBM@triple_point?$AA@
CONST	SEGMENT
??_C@_0N@DHNCNHBM@triple_point?$AA@ DB 'triple_point', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DFLKEBKH@tetra_point?$AA@
CONST	SEGMENT
??_C@_0M@DFLKEBKH@tetra_point?$AA@ DB 'tetra_point', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JPCPFHFE@lanczos?$AA@
CONST	SEGMENT
??_C@_07JPCPFHFE@lanczos?$AA@ DB 'lanczos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FLCFPHEO@eigenprobe?$AA@
CONST	SEGMENT
??_C@_0L@FLCFPHEO@eigenprobe?$AA@ DB 'eigenprobe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HKMJFCDE@ritz?$AA@
CONST	SEGMENT
??_C@_04HKMJFCDE@ritz?$AA@ DB 'ritz', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DLICDMBN@continue?$AA@
CONST	SEGMENT
??_C@_08DLICDMBN@continue?$AA@ DB 'continue', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HEBLBDOI@volfixed?$AA@
CONST	SEGMENT
??_C@_08HEBLBDOI@volfixed?$AA@ DB 'volfixed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05ELPHFHOI@break?$AA@
CONST	SEGMENT
??_C@_05ELPHFHOI@break?$AA@ DB 'break', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HIFAJGPB@t1_edgeswap?$AA@
CONST	SEGMENT
??_C@_0M@HIFAJGPB@t1_edgeswap?$AA@ DB 't1_edgeswap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GDDLLHKC@edgeswap?$AA@
CONST	SEGMENT
??_C@_08GDDLLHKC@edgeswap?$AA@ DB 'edgeswap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LAOGOOCK@convert_to_quantities?$AA@
CONST	SEGMENT
??_C@_0BG@LAOGOOCK@convert_to_quantities?$AA@ DB 'convert_to_quantities', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDOMCGJP@geompipe?$AA@
CONST	SEGMENT
??_C@_08IDOMCGJP@geompipe?$AA@ DB 'geompipe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDMMNHEL@move?$AA@
CONST	SEGMENT
??_C@_04HDMMNHEL@move?$AA@ DB 'move', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FPFOALMG@sizeof?$AA@
CONST	SEGMENT
??_C@_06FPFOALMG@sizeof?$AA@ DB 'sizeof', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FNJMBFGF@ometis?$AA@
CONST	SEGMENT
??_C@_06FNJMBFGF@ometis?$AA@ DB 'ometis', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KJNDDBHG@kmetis?$AA@
CONST	SEGMENT
??_C@_06KJNDDBHG@kmetis?$AA@ DB 'kmetis', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JJNAPELC@body_metis?$AA@
CONST	SEGMENT
??_C@_0L@JJNAPELC@body_metis?$AA@ DB 'body_metis', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BEHGJJCH@metis_readjust?$AA@
CONST	SEGMENT
??_C@_0P@BEHGJJCH@metis_readjust?$AA@ DB 'metis_readjust', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MMMFHLE@metis?$AA@
CONST	SEGMENT
??_C@_05MMMFHLE@metis?$AA@ DB 'metis', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GAAHAAOL@metis_factor?$AA@
CONST	SEGMENT
??_C@_0N@GAAHAAOL@metis_factor?$AA@ DB 'metis_factor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EBKCCFDE@rawest_vertex_average?$AA@
CONST	SEGMENT
??_C@_0BG@EBKCCFDE@rawest_vertex_average?$AA@ DB 'rawest_vertex_average', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FBBKFDM@raw_vertex_average?$AA@
CONST	SEGMENT
??_C@_0BD@FBBKFDM@raw_vertex_average?$AA@ DB 'raw_vertex_average', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OLMKLKE@vertex_average?$AA@
CONST	SEGMENT
??_C@_0P@OLMKLKE@vertex_average?$AA@ DB 'vertex_average', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IBDAIKBO@binary_off_file?$AA@
CONST	SEGMENT
??_C@_0BA@IBDAIKBO@binary_off_file?$AA@ DB 'binary_off_file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KLNLDNLL@ooglfile?$AA@
CONST	SEGMENT
??_C@_08KLNLDNLL@ooglfile?$AA@ DB 'ooglfile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CCPMELKB@postscript?$AA@
CONST	SEGMENT
??_C@_0L@CCPMELKB@postscript?$AA@ DB 'postscript', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LNOFJDNM@return?$AA@
CONST	SEGMENT
??_C@_06LNOFJDNM@return?$AA@ DB 'return', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PANPCJAE@new_body?$AA@
CONST	SEGMENT
??_C@_08PANPCJAE@new_body?$AA@ DB 'new_body', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OAIEDJBI@new_facet?$AA@
CONST	SEGMENT
??_C@_09OAIEDJBI@new_facet?$AA@ DB 'new_facet', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HBMPJBBB@new_edge?$AA@
CONST	SEGMENT
??_C@_08HBMPJBBB@new_edge?$AA@ DB 'new_edge', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KAOEHGMG@new_vertex?$AA@
CONST	SEGMENT
??_C@_0L@KAOEHGMG@new_vertex?$AA@ DB 'new_vertex', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JONLCJIM@backbody?$AA@
CONST	SEGMENT
??_C@_08JONLCJIM@backbody?$AA@ DB 'backbody', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GNLMKAKO@frontbody?$AA@
CONST	SEGMENT
??_C@_09GNLMKAKO@frontbody?$AA@ DB 'frontbody', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GKBDMEAN@keylogfile?$AA@
CONST	SEGMENT
??_C@_0L@GKBDMEAN@keylogfile?$AA@ DB 'keylogfile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HMINABEO@logfile?$AA@
CONST	SEGMENT
??_C@_07HMINABEO@logfile?$AA@ DB 'logfile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause?$AA@
CONST	SEGMENT
??_C@_05PDJBBECF@pause?$AA@ DB 'pause', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JJMKEIGG@renumber_all?$AA@
CONST	SEGMENT
??_C@_0N@JJMKEIGG@renumber_all?$AA@ DB 'renumber_all', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PJJKCDON@reorder_storage?$AA@
CONST	SEGMENT
??_C@_0BA@PJJKCDON@reorder_storage?$AA@ DB 'reorder_storage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FMKAEFLC@is_defined?$AA@
CONST	SEGMENT
??_C@_0L@FMKAEFLC@is_defined?$AA@ DB 'is_defined', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CJACPCIB@wrap_vertex?$AA@
CONST	SEGMENT
??_C@_0M@CJACPCIB@wrap_vertex?$AA@ DB 'wrap_vertex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MGEIEJAD@exec?$AA@
CONST	SEGMENT
??_C@_04MGEIEJAD@exec?$AA@ DB 'exec', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BKFFEMDK@exprint?$AA@
CONST	SEGMENT
??_C@_07BKFFEMDK@exprint?$AA@ DB 'exprint', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DICBBEEI@date_and_time?$AA@
CONST	SEGMENT
??_C@_0O@DICBBEEI@date_and_time?$AA@ DB 'date_and_time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BADENEHP@colorfile?$AA@
CONST	SEGMENT
??_C@_09BADENEHP@colorfile?$AA@ DB 'colorfile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ICOOBCNI@vertexnormal?$AA@
CONST	SEGMENT
??_C@_0N@ICOOBCNI@vertexnormal?$AA@ DB 'vertexnormal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PBJCFAJD@equiangulate?$AA@
CONST	SEGMENT
??_C@_0N@PBJCFAJD@equiangulate?$AA@ DB 'equiangulate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FIMKOPGK@warning_messages?$AA@
CONST	SEGMENT
??_C@_0BB@FIMKOPGK@warning_messages?$AA@ DB 'warning_messages', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JOHEBPFF@for?$AA@
CONST	SEGMENT
??_C@_03JOHEBPFF@for?$AA@ DB 'for', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IDKHKMLA@local?$AA@
CONST	SEGMENT
??_C@_05IDKHKMLA@local?$AA@ DB 'local', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NFBBDANK@pop_quad_to_quad?$AA@
CONST	SEGMENT
??_C@_0BB@NFBBDANK@pop_quad_to_quad?$AA@ DB 'pop_quad_to_quad', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LLOFFOFA@pop_edge_to_tri?$AA@
CONST	SEGMENT
??_C@_0BA@LLOFFOFA@pop_edge_to_tri?$AA@ DB 'pop_edge_to_tri', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HKCODAC@pop_tri_to_edge?$AA@
CONST	SEGMENT
??_C@_0BA@HKCODAC@pop_tri_to_edge?$AA@ DB 'pop_tri_to_edge', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJDAHFJE@pop?$AA@
CONST	SEGMENT
??_C@_03NJDAHFJE@pop?$AA@ DB 'pop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09BOMFCCD@task_exec?$AA@
CONST	SEGMENT
??_C@_09BOMFCCD@task_exec?$AA@ DB 'task_exec', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OJLJIFPG@parallel_exec?$AA@
CONST	SEGMENT
??_C@_0O@OJLJIFPG@parallel_exec?$AA@ DB 'parallel_exec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FKOPBMAL@mean_curvature?$AA@
CONST	SEGMENT
??_C@_0P@FKOPBMAL@mean_curvature?$AA@ DB 'mean_curvature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KEAKBNCK@mpi_task?$AA@
CONST	SEGMENT
??_C@_08KEAKBNCK@mpi_task?$AA@ DB 'mpi_task', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HCCAAKMF@facet_merge?$AA@
CONST	SEGMENT
??_C@_0M@HCCAAKMF@facet_merge?$AA@ DB 'facet_merge', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GJPPMFGG@edge_merge?$AA@
CONST	SEGMENT
??_C@_0L@GJPPMFGG@edge_merge?$AA@ DB 'edge_merge', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOMHNGJF@vertex_merge?$AA@
CONST	SEGMENT
??_C@_0N@MOMHNGJF@vertex_merge?$AA@ DB 'vertex_merge', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BFEIANBO@reset_counts?$AA@
CONST	SEGMENT
??_C@_0N@BFEIANBO@reset_counts?$AA@ DB 'reset_counts', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HEMOCGDL@valid_element?$AA@
CONST	SEGMENT
??_C@_0O@HEMOCGDL@valid_element?$AA@ DB 'valid_element', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HEKOHBEK@flush_counts?$AA@
CONST	SEGMENT
??_C@_0N@HEKOHBEK@flush_counts?$AA@ DB 'flush_counts', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BPLDEHMH@mid_facet?$AA@
CONST	SEGMENT
??_C@_09BPLDEHMH@mid_facet?$AA@ DB 'mid_facet', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EJNLDOMI@mid_edge?$AA@
CONST	SEGMENT
??_C@_08EJNLDOMI@mid_edge?$AA@ DB 'mid_edge', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JJNPEKJD@matrix_determinant?$AA@
CONST	SEGMENT
??_C@_0BD@JJNPEKJD@matrix_determinant?$AA@ DB 'matrix_determinant', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EBJBPEJC@matrix_inverse?$AA@
CONST	SEGMENT
??_C@_0P@EBJBPEJC@matrix_inverse?$AA@ DB 'matrix_inverse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JNPAPNBO@matrix_multiply?$AA@
CONST	SEGMENT
??_C@_0BA@JNPAPNBO@matrix_multiply?$AA@ DB 'matrix_multiply', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KCPFLFEG@reverse_orientation?$AA@
CONST	SEGMENT
??_C@_0BE@KCPFLFEG@reverse_orientation?$AA@ DB 'reverse_orientation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GDMIKNMD@dump_memlist?$AA@
CONST	SEGMENT
??_C@_0N@GDMIKNMD@dump_memlist?$AA@ DB 'dump_memlist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OKPNNEJG@free_discards?$AA@
CONST	SEGMENT
??_C@_0O@OKPNNEJG@free_discards?$AA@ DB 'free_discards', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PLKJAEAL@repartition?$AA@
CONST	SEGMENT
??_C@_0M@PLKJAEAL@repartition?$AA@ DB 'repartition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KHFNHBNM@subcommand?$AA@
CONST	SEGMENT
??_C@_0L@KHFNHBNM@subcommand?$AA@ DB 'subcommand', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05BBAEEBBH@abort?$AA@
CONST	SEGMENT
??_C@_05BBAEEBBH@abort?$AA@ DB 'abort', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BKKBNEBK@breakpoints?$AA@
CONST	SEGMENT
??_C@_0M@BKKBNEBK@breakpoints?$AA@ DB 'breakpoints', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LCAMEHJC@breakpoint?$AA@
CONST	SEGMENT
??_C@_0L@LCAMEHJC@breakpoint?$AA@ DB 'breakpoint', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DHCGNBAN@whereami?$AA@
CONST	SEGMENT
??_C@_08DHCGNBAN@whereami?$AA@ DB 'whereami', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OJACEENF@replace_load?$AA@
CONST	SEGMENT
??_C@_0N@OJACEENF@replace_load?$AA@ DB 'replace_load', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BNADNHKE@addload?$AA@
CONST	SEGMENT
??_C@_07BNADNHKE@addload?$AA@ DB 'addload', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ECJLFEKE@simplex_to_fe?$AA@
CONST	SEGMENT
??_C@_0O@ECJLFEKE@simplex_to_fe?$AA@ DB 'simplex_to_fe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CJJGNHCN@display_text?$AA@
CONST	SEGMENT
??_C@_0N@CJJGNHCN@display_text?$AA@ DB 'display_text', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EOIFPGKG@delete_text?$AA@
CONST	SEGMENT
??_C@_0M@EOIFPGKG@delete_text?$AA@ DB 'delete_text', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OHLAHHBM@reset_profiling?$AA@
CONST	SEGMENT
??_C@_0BA@OHLAHHBM@reset_profiling?$AA@ DB 'reset_profiling', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IICGFFJH@profiling?$AA@
CONST	SEGMENT
??_C@_09IICGFFJH@profiling?$AA@ DB 'profiling', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CFKICEKD@valid_boundary?$AA@
CONST	SEGMENT
??_C@_0P@CFKICEKD@valid_boundary?$AA@ DB 'valid_boundary', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CNFDAFCL@valid_constraint?$AA@
CONST	SEGMENT
??_C@_0BB@CNFDAFCL@valid_constraint?$AA@ DB 'valid_constraint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KPBBKELJ@is_constraint?$AA@
CONST	SEGMENT
??_C@_0O@KPBBKELJ@is_constraint?$AA@ DB 'is_constraint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LDNKKEH@detorus?$AA@
CONST	SEGMENT
??_C@_07LDNKKEH@detorus?$AA@ DB 'detorus', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KJENOODO@facet_crosscut?$AA@
CONST	SEGMENT
??_C@_0P@KJENOODO@facet_crosscut?$AA@ DB 'facet_crosscut', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NBLIDMLB@make_thread_lists?$AA@
CONST	SEGMENT
??_C@_0BC@NBLIDMLB@make_thread_lists?$AA@ DB 'make_thread_lists', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBMGOFNF@no_hessian_normal?$AA@
CONST	SEGMENT
??_C@_0BC@KBMGOFNF@no_hessian_normal?$AA@ DB 'no_hessian_normal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LFPCKGAP@p_force?$AA@
CONST	SEGMENT
??_C@_07LFPCKGAP@p_force?$AA@ DB 'p_force', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LJPKPJJM@p_velocity?$AA@
CONST	SEGMENT
??_C@_0L@LJPKPJJM@p_velocity?$AA@ DB 'p_velocity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IAPJLEJH@no_dump?$AA@
CONST	SEGMENT
??_C@_07IAPJLEJH@no_dump?$AA@ DB 'no_dump', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KIAILNPN@normal_vector?$AA@
CONST	SEGMENT
??_C@_0O@KIAILNPN@normal_vector?$AA@ DB 'normal_vector', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKLLLDHL@normal?$AA@
CONST	SEGMENT
??_C@_06IKLLLDHL@normal?$AA@ DB 'normal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JGHBODFD@pow?$AA@
CONST	SEGMENT
??_C@_03JGHBODFD@pow?$AA@ DB 'pow', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CCOEHHFD@minimum?$AA@
CONST	SEGMENT
??_C@_07CCOEHHFD@minimum?$AA@ DB 'minimum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MEIENILC@maximum?$AA@
CONST	SEGMENT
??_C@_07MEIENILC@maximum?$AA@ DB 'maximum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DIEKFJPK@incompleteEllipticE?$AA@
CONST	SEGMENT
??_C@_0BE@DIEKFJPK@incompleteEllipticE?$AA@ DB 'incompleteEllipticE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BDGHAKDJ@incompleteEllipticF?$AA@
CONST	SEGMENT
??_C@_0BE@BDGHAKDJ@incompleteEllipticF?$AA@ DB 'incompleteEllipticF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KNGEOGJB@atan2?$AA@
CONST	SEGMENT
??_C@_05KNGEOGJB@atan2?$AA@ DB 'atan2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HGNPFHKM@wrap_compose?$AA@
CONST	SEGMENT
??_C@_0N@HGNPFHKM@wrap_compose?$AA@ DB 'wrap_compose', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BCGAIFPO@abs?$AA@
CONST	SEGMENT
??_C@_03BCGAIFPO@abs?$AA@ DB 'abs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PBJFFIGL@floor?$AA@
CONST	SEGMENT
??_C@_05PBJFFIGL@floor?$AA@ DB 'floor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GFPJNGEK@ceil?$AA@
CONST	SEGMENT
??_C@_04GFPJNGEK@ceil?$AA@ DB 'ceil', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OPALDGIC@sqr?$AA@
CONST	SEGMENT
??_C@_03OPALDGIC@sqr?$AA@ DB 'sqr', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EIAKFFMI@sqrt?$AA@
CONST	SEGMENT
??_C@_04EIAKFFMI@sqrt?$AA@ DB 'sqrt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ONDAFDEP@atanh?$AA@
CONST	SEGMENT
??_C@_05ONDAFDEP@atanh?$AA@ DB 'atanh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MLNBFPMN@acosh?$AA@
CONST	SEGMENT
??_C@_05MLNBFPMN@acosh?$AA@ DB 'acosh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKKEKHLA@asinh?$AA@
CONST	SEGMENT
??_C@_05JKKEKHLA@asinh?$AA@ DB 'asinh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FJHINJAO@tanh?$AA@
CONST	SEGMENT
??_C@_04FJHINJAO@tanh?$AA@ DB 'tanh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPJJNFIM@cosh?$AA@
CONST	SEGMENT
??_C@_04HPJJNFIM@cosh?$AA@ DB 'cosh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COOMCNPB@sinh?$AA@
CONST	SEGMENT
??_C@_04COOMCNPB@sinh?$AA@ DB 'sinh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLLJIGOK@atan?$AA@
CONST	SEGMENT
??_C@_04MLLJIGOK@atan?$AA@ DB 'atan', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PDIFKINK@acos?$AA@
CONST	SEGMENT
??_C@_04PDIFKINK@acos?$AA@ DB 'acos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FIHNOPOL@asin?$AA@
CONST	SEGMENT
??_C@_04FIHNOPOL@asin?$AA@ DB 'asin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IIINPABG@tan?$AA@
CONST	SEGMENT
??_C@_03IIINPABG@tan?$AA@ DB 'tan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LALBNOCG@cos?$AA@
CONST	SEGMENT
??_C@_03LALBNOCG@cos?$AA@ DB 'cos', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BLEJJJBH@sin?$AA@
CONST	SEGMENT
??_C@_03BLEJJJBH@sin?$AA@ DB 'sin', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHJOGHMM@exp?$AA@
CONST	SEGMENT
??_C@_03KHJOGHMM@exp?$AA@ DB 'exp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGHMBJCF@log?$AA@
CONST	SEGMENT
??_C@_03MGHMBJCF@log?$AA@ DB 'log', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09IOEHKLLB@ellipticE?$AA@
CONST	SEGMENT
??_C@_09IOEHKLLB@ellipticE?$AA@ DB 'ellipticE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BAMEIGDP@ellipticK?$AA@
CONST	SEGMENT
??_C@_09BAMEIGDP@ellipticK?$AA@ DB 'ellipticK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CCAKCFDI@wrap_inverse?$AA@
CONST	SEGMENT
??_C@_0N@CCAKCFDI@wrap_inverse?$AA@ DB 'wrap_inverse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CMEJCHLK@facetedge?$AA@
CONST	SEGMENT
??_C@_09CMEJCHLK@facetedge?$AA@ DB 'facetedge', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CPIKDJIA@facetedges?$AA@
CONST	SEGMENT
??_C@_0L@CPIKDJIA@facetedges?$AA@ DB 'facetedges', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LKKCPKKM@facet_edge?$AA@
CONST	SEGMENT
??_C@_0L@LKKCPKKM@facet_edge?$AA@ DB 'facet_edge', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NLMIGHAM@facet_edges?$AA@
CONST	SEGMENT
??_C@_0M@NLMIGHAM@facet_edges?$AA@ DB 'facet_edges', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IEJGKNJ@body?$AA@
CONST	SEGMENT
??_C@_04IEJGKNJ@body?$AA@ DB 'body', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OHIKIKDI@bodies?$AA@
CONST	SEGMENT
??_C@_06OHIKIKDI@bodies?$AA@ DB 'bodies', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BIBOABDC@facet?$AA@
CONST	SEGMENT
??_C@_05BIBOABDC@facet?$AA@ DB 'facet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MMNNGFLE@facets?$AA@
CONST	SEGMENT
??_C@_06MMNNGFLE@facets?$AA@ DB 'facets', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POCOPAPC@face?$AA@
CONST	SEGMENT
??_C@_04POCOPAPC@face?$AA@ DB 'face', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FHFPJHPF@faces?$AA@
CONST	SEGMENT
??_C@_05FHFPJHPF@faces?$AA@ DB 'faces', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IJFJNCMM@edge?$AA@
CONST	SEGMENT
??_C@_04IJFJNCMM@edge?$AA@ DB 'edge', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JGEJPNHM@edges?$AA@
CONST	SEGMENT
??_C@_05JGEJPNHM@edges?$AA@ DB 'edges', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HLKHCFCI@vertex?$AA@
CONST	SEGMENT
??_C@_06HLKHCFCI@vertex?$AA@ DB 'vertex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BOLPBPCL@vertices?$AA@
CONST	SEGMENT
??_C@_08BOLPBPCL@vertices?$AA@ DB 'vertices', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LAAABFKN@original?$AA@
CONST	SEGMENT
??_C@_08LAAABFKN@original?$AA@ DB 'original', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CBIPACOJ@dot_product?$AA@
CONST	SEGMENT
??_C@_0M@CBIPACOJ@dot_product?$AA@ DB 'dot_product', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CHNIFDFF@idiv?$AA@
CONST	SEGMENT
??_C@_04CHNIFDFF@idiv?$AA@ DB 'idiv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGKJBALO@imod?$AA@
CONST	SEGMENT
??_C@_04CGKJBALO@imod?$AA@ DB 'imod', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFONCNID@mod?$AA@
CONST	SEGMENT
??_C@_03FFONCNID@mod?$AA@ DB 'mod', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJKJADM@not?$AA@
CONST	SEGMENT
??_C@_03NJKJADM@not?$AA@ DB 'not', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FODMLBIE@or?$AA@
CONST	SEGMENT
??_C@_02FODMLBIE@or?$AA@ DB 'or', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BOPJPIAM@and?$AA@
CONST	SEGMENT
??_C@_03BOPJPIAM@and?$AA@ DB 'and', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04POLDLDMI@read?$AA@
CONST	SEGMENT
??_C@_04POLDLDMI@read?$AA@ DB 'read', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IMINLCCL@volconst?$AA@
CONST	SEGMENT
??_C@_08IMINLCCL@volconst?$AA@ DB 'volconst', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OCNIHGPN@quantity?$AA@
CONST	SEGMENT
??_C@_08OCNIHGPN@quantity?$AA@ DB 'quantity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EMFGBOOI@zoom_radius?$AA@
CONST	SEGMENT
??_C@_0M@EMFGBOOI@zoom_radius?$AA@ DB 'zoom_radius', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JBIJOPDG@zoom_vertex?$AA@
CONST	SEGMENT
??_C@_0M@JBIJOPDG@zoom_vertex?$AA@ DB 'zoom_vertex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PJCBAJEM@scale_limit?$AA@
CONST	SEGMENT
??_C@_0M@PJCBAJEM@scale_limit?$AA@ DB 'scale_limit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KIHCPOPL@nodisplay?$AA@
CONST	SEGMENT
??_C@_09KIHCPOPL@nodisplay?$AA@ DB 'nodisplay', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BJBOFKDG@tension?$AA@
CONST	SEGMENT
??_C@_07BJBOFKDG@tension?$AA@ DB 'tension', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HAFFKDBK@density?$AA@
CONST	SEGMENT
??_C@_07HAFFKDBK@density?$AA@ DB 'density', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EMCPHFGM@volume?$AA@
CONST	SEGMENT
??_C@_06EMCPHFGM@volume?$AA@ DB 'volume', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08POHEELCJ@pressure?$AA@
CONST	SEGMENT
??_C@_08POHEELCJ@pressure?$AA@ DB 'pressure', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GJEHHDCL@temperature?$AA@
CONST	SEGMENT
??_C@_0M@GJEHHDCL@temperature?$AA@ DB 'temperature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HACLPJI@pscale?$AA@
CONST	SEGMENT
??_C@_06HACLPJI@pscale?$AA@ DB 'pscale', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MHMEBBGO@scale?$AA@
CONST	SEGMENT
??_C@_05MHMEBBGO@scale?$AA@ DB 'scale', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DKAJABDK@gap_constant?$AA@
CONST	SEGMENT
??_C@_0N@DKAJABDK@gap_constant?$AA@ DB 'gap_constant', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CNIKOEML@spring_constant?$AA@
CONST	SEGMENT
??_C@_0BA@CNIKOEML@spring_constant?$AA@ DB 'spring_constant', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LFLMFBL@gravity_constant?$AA@
CONST	SEGMENT
??_C@_0BB@LFLMFBL@gravity_constant?$AA@ DB 'gravity_constant', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OMNDKHGB@merit_factor?$AA@
CONST	SEGMENT
??_C@_0N@OMNDKHGB@merit_factor?$AA@ DB 'merit_factor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NBBNKAEP@diffusion?$AA@
CONST	SEGMENT
??_C@_09NBBNKAEP@diffusion?$AA@ DB 'diffusion', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LGAKKEPJ@jiggle?$AA@
CONST	SEGMENT
??_C@_06LGAKKEPJ@jiggle?$AA@ DB 'jiggle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JAENIDNE@area_normalization?$AA@
CONST	SEGMENT
??_C@_0BD@JAENIDNE@area_normalization?$AA@ DB 'area_normalization', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HPJICMPM@linear?$AA@
CONST	SEGMENT
??_C@_06HPJICMPM@linear?$AA@ DB 'linear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NDEBDKFB@quadratic?$AA@
CONST	SEGMENT
??_C@_09NDEBDKFB@quadratic?$AA@ DB 'quadratic', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07ICAJMOAO@content?$AA@
CONST	SEGMENT
??_C@_07ICAJMOAO@content?$AA@ DB 'content', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KKGCKCNJ@energy?$AA@
CONST	SEGMENT
??_C@_06KKGCKCNJ@energy?$AA@ DB 'energy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EANCEANL@nonpositive?$AA@
CONST	SEGMENT
??_C@_0M@EANCEANL@nonpositive?$AA@ DB 'nonpositive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MKNCPPEA@nonnegative?$AA@
CONST	SEGMENT
??_C@_0M@MKNCPPEA@nonnegative?$AA@ DB 'nonnegative', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FAFBHKGP@nonwall?$AA@
CONST	SEGMENT
??_C@_07FAFBHKGP@nonwall?$AA@ DB 'nonwall', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OAMDAHCP@convex?$AA@
CONST	SEGMENT
??_C@_06OAMDAHCP@convex?$AA@ DB 'convex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MOILGEJM@constraint_tolerance?$AA@
CONST	SEGMENT
??_C@_0BF@MOILGEJM@constraint_tolerance?$AA@ DB 'constraint_tolerance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CFFGCHHD@integration_order_2d?$AA@
CONST	SEGMENT
??_C@_0BF@CFFGCHHD@integration_order_2d?$AA@ DB 'integration_order_2d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CHBAJJCK@integration_order_1d?$AA@
CONST	SEGMENT
??_C@_0BF@CHBAJJCK@integration_order_1d?$AA@ DB 'integration_order_1d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CCICJAIC@integration_order?$AA@
CONST	SEGMENT
??_C@_0BC@CCICJAIC@integration_order?$AA@ DB 'integration_order', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CBPAEDJL@integral_order_2d?$AA@
CONST	SEGMENT
??_C@_0BC@CBPAEDJL@integral_order_2d?$AA@ DB 'integral_order_2d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CDLGPNMC@integral_order_1d?$AA@
CONST	SEGMENT
??_C@_0BC@CDLGPNMC@integral_order_1d?$AA@ DB 'integral_order_1d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JOOJGKKP@integral_order?$AA@
CONST	SEGMENT
??_C@_0P@JOOJGKKP@integral_order?$AA@ DB 'integral_order', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@COAHFEML@symmetric_content?$AA@
CONST	SEGMENT
??_C@_0BC@COAHFEML@symmetric_content?$AA@ DB 'symmetric_content', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EAADGFKM@parameter_file?$AA@
CONST	SEGMENT
??_C@_0P@EAADGFKM@parameter_file?$AA@ DB 'parameter_file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HHPOFMCB@parameters?$AA@
CONST	SEGMENT
??_C@_0L@HHPOFMCB@parameters?$AA@ DB 'parameters', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DAGAJHIH@parameter?$AA@
CONST	SEGMENT
??_C@_09DAGAJHIH@parameter?$AA@ DB 'parameter', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HFFPPCHF@function?$AA@
CONST	SEGMENT
??_C@_08HFFPPCHF@function?$AA@ DB 'function', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LHCFJCJM@formula?$AA@
CONST	SEGMENT
??_C@_07LHCFJCJM@formula?$AA@ DB 'formula', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LFIPMAJA@surface_energy?$AA@
CONST	SEGMENT
??_C@_0P@LFIPMAJA@surface_energy?$AA@ DB 'surface_energy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JGLONDGH@constraints?$AA@
CONST	SEGMENT
??_C@_0M@JGLONDGH@constraints?$AA@ DB 'constraints', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOHHMJMM@constraint?$AA@
CONST	SEGMENT
??_C@_0L@HOHHMJMM@constraint?$AA@ DB 'constraint', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PABKJGNF@boundaries?$AA@
CONST	SEGMENT
??_C@_0L@PABKJGNF@boundaries?$AA@ DB 'boundaries', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KIKGFOKI@boundary?$AA@
CONST	SEGMENT
??_C@_08KIKGFOKI@boundary?$AA@ DB 'boundary', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GHCFDPJC@wulff?$AA@
CONST	SEGMENT
??_C@_05GHCFDPJC@wulff?$AA@ DB 'wulff', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DODCPBAM@soapfilm?$AA@
CONST	SEGMENT
??_C@_08DODCPBAM@soapfilm?$AA@ DB 'soapfilm', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string?$AA@
CONST	SEGMENT
??_C@_06ICGJLFIM@string?$AA@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HCKIGAAA@display_periods?$AA@
CONST	SEGMENT
??_C@_0BA@HCKIGAAA@display_periods?$AA@ DB 'display_periods', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BFECMFCO@periods?$AA@
CONST	SEGMENT
??_C@_07BFECMFCO@periods?$AA@ DB 'periods', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IMAKABFD@torus_periods?$AA@
CONST	SEGMENT
??_C@_0O@IMAKABFD@torus_periods?$AA@ DB 'torus_periods', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IGCELFFA@torus_filled?$AA@
CONST	SEGMENT
??_C@_0N@IGCELFFA@torus_filled?$AA@ DB 'torus_filled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05FCPCBJIO@torus?$AA@
CONST	SEGMENT
??_C@_05FCPCBJIO@torus?$AA@ DB 'torus', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NFDDIEML@wrap?$AA@
CONST	SEGMENT
??_C@_04NFDDIEML@wrap?$AA@ DB 'wrap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GKEDIIHF@symmetry_group?$AA@
CONST	SEGMENT
??_C@_0P@GKEDIIHF@symmetry_group?$AA@ DB 'symmetry_group', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BAJEJFKD@efixed?$AA@
CONST	SEGMENT
??_C@_06BAJEJFKD@efixed?$AA@ DB 'efixed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DKEDBIHO@noncontent?$AA@
CONST	SEGMENT
??_C@_0L@DKEDBIHO@noncontent?$AA@ DB 'noncontent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ODCODBLD@no_display?$AA@
CONST	SEGMENT
??_C@_0L@ODCODBLD@no_display?$AA@ DB 'no_display', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OFAMNBMC@centerofmass?$AA@
CONST	SEGMENT
??_C@_0N@OFAMNBMC@centerofmass?$AA@ DB 'centerofmass', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JAGBIOBF@hit_partner?$AA@
CONST	SEGMENT
??_C@_0M@JAGBIOBF@hit_partner?$AA@ DB 'hit_partner', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CMIGFPCH@no_transform?$AA@
CONST	SEGMENT
??_C@_0N@CMIGFPCH@no_transform?$AA@ DB 'no_transform', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PFNGBABC@no_refine?$AA@
CONST	SEGMENT
??_C@_09PFNGBABC@no_refine?$AA@ DB 'no_refine', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OFLEIIDM@fixed?$AA@
CONST	SEGMENT
??_C@_05OFLEIIDM@fixed?$AA@ DB 'fixed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HOLKBDMI@conformal_metric?$AA@
CONST	SEGMENT
??_C@_0BB@HOLKBDMI@conformal_metric?$AA@ DB 'conformal_metric', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FGNFAGIK@klein_metric?$AA@
CONST	SEGMENT
??_C@_0N@FGNFAGIK@klein_metric?$AA@ DB 'klein_metric', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BEHJHFJO@metric?$AA@
CONST	SEGMENT
??_C@_06BEHJHFJO@metric?$AA@ DB 'metric', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ELELLFNL@simplex_representation?$AA@
CONST	SEGMENT
??_C@_0BH@ELELLFNL@simplex_representation?$AA@ DB 'simplex_representation'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CCLFHFGM@surface_dimension?$AA@
CONST	SEGMENT
??_C@_0BC@CCLFHFGM@surface_dimension?$AA@ DB 'surface_dimension', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NCBBEAIN@space_dimension?$AA@
CONST	SEGMENT
??_C@_0BA@NCBBEAIN@space_dimension?$AA@ DB 'space_dimension', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PBMPDDPJ@conducting_knot_energy?$AA@
CONST	SEGMENT
??_C@_0BH@PBMPDDPJ@conducting_knot_energy?$AA@ DB 'conducting_knot_energy'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KFIJAGHO@insulating_knot_energy?$AA@
CONST	SEGMENT
??_C@_0BH@KFIJAGHO@insulating_knot_energy?$AA@ DB 'insulating_knot_energy'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MAJEELEA@gauss_curvature?$AA@
CONST	SEGMENT
??_C@_0BA@MAJEELEA@gauss_curvature?$AA@ DB 'gauss_curvature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MADIBINB@squared_gaussian_curvature?$AA@
CONST	SEGMENT
??_C@_0BL@MADIBINB@squared_gaussian_curvature?$AA@ DB 'squared_gaussian_c'
	DB	'urvature', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FKPNCHGB@square_gaussian_curvature?$AA@
CONST	SEGMENT
??_C@_0BK@FKPNCHGB@square_gaussian_curvature?$AA@ DB 'square_gaussian_cur'
	DB	'vature', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ODOAEPAL@squared_curvature?$AA@
CONST	SEGMENT
??_C@_0BC@ODOAEPAL@squared_curvature?$AA@ DB 'squared_curvature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OIOLOLOH@square_curvature?$AA@
CONST	SEGMENT
??_C@_0BB@OIOLOLOH@square_curvature?$AA@ DB 'square_curvature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ODBHHAP@normal_curvature?$AA@
CONST	SEGMENT
??_C@_0BB@ODBHHAP@normal_curvature?$AA@ DB 'normal_curvature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KGGFDDEC@mean_curvature_integral?$AA@
CONST	SEGMENT
??_C@_0BI@KGGFDDEC@mean_curvature_integral?$AA@ DB 'mean_curvature_integr'
	DB	'al', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DKEJANLD@frontcolor?$AA@
CONST	SEGMENT
??_C@_0L@DKEJANLD@frontcolor?$AA@ DB 'frontcolor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OPNKCLNO@backcolor?$AA@
CONST	SEGMENT
??_C@_09OPNKCLNO@backcolor?$AA@ DB 'backcolor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PEENBMOG@color?$AA@
CONST	SEGMENT
??_C@_05PEENBMOG@color?$AA@ DB 'color', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OBNGAKOC@runge_kutta?$AA@
CONST	SEGMENT
??_C@_0M@OBNGAKOC@runge_kutta?$AA@ DB 'runge_kutta', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OMMOBLOA@effective_area?$AA@
CONST	SEGMENT
??_C@_0P@OMMOBLOA@effective_area?$AA@ DB 'effective_area', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OIFGKHMH@total_time?$AA@
CONST	SEGMENT
??_C@_0L@OIFGKHMH@total_time?$AA@ DB 'total_time', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BLGPIPGP@autochop?$AA@
CONST	SEGMENT
??_C@_08BLGPIPGP@autochop?$AA@ DB 'autochop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KEKJOJEJ@autopop_quartic?$AA@
CONST	SEGMENT
??_C@_0BA@KEKJOJEJ@autopop_quartic?$AA@ DB 'autopop_quartic', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LEJGIFAD@autopop?$AA@
CONST	SEGMENT
??_C@_07LEJGIFAD@autopop?$AA@ DB 'autopop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CBPKLGJM@phase?$AA@
CONST	SEGMENT
??_C@_05CBPKLGJM@phase?$AA@ DB 'phase', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JNGEFCBF@phasefile?$AA@
CONST	SEGMENT
??_C@_09JNGEFCBF@phasefile?$AA@ DB 'phasefile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MNCGPOEG@approx_curvature?$AA@
CONST	SEGMENT
??_C@_0BB@MNCGPOEG@approx_curvature?$AA@ DB 'approx_curvature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CNKFKNKC@approximate_curvature?$AA@
CONST	SEGMENT
??_C@_0BG@CNKFKNKC@approximate_curvature?$AA@ DB 'approximate_curvature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PDIDGCEH@homothety?$AA@
CONST	SEGMENT
??_C@_09PDIDGCEH@homothety?$AA@ DB 'homothety', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PJALNND@view_transform_generators?$AA@
CONST	SEGMENT
??_C@_0BK@PJALNND@view_transform_generators?$AA@ DB 'view_transform_gener'
	DB	'ators', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IFLDONLI@view_transforms?$AA@
CONST	SEGMENT
??_C@_0BA@IFLDONLI@view_transforms?$AA@ DB 'view_transforms', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PIDOJOI@view_matrix?$AA@
CONST	SEGMENT
??_C@_0M@PIDOJOI@view_matrix?$AA@ DB 'view_matrix', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HCEEFND@fixed_area?$AA@
CONST	SEGMENT
??_C@_0L@HCEEFND@fixed_area?$AA@ DB 'fixed_area', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IDDPHJLO@area_fixed?$AA@
CONST	SEGMENT
??_C@_0L@IDDPHJLO@area_fixed?$AA@ DB 'area_fixed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FJKEMHGD@global?$AA@
CONST	SEGMENT
??_C@_06FJKEMHGD@global?$AA@ DB 'global', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LJFOIPB@global_method?$AA@
CONST	SEGMENT
??_C@_0O@LJFOIPB@global_method?$AA@ DB 'global_method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EMCPFNEA@info_only?$AA@
CONST	SEGMENT
??_C@_09EMCPFNEA@info_only?$AA@ DB 'info_only', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CJECEDDG@modulus?$AA@
CONST	SEGMENT
??_C@_07CJECEDDG@modulus?$AA@ DB 'modulus', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MOPCCJLG@boundary_curvature?$AA@
CONST	SEGMENT
??_C@_0BD@MOPCCJLG@boundary_curvature?$AA@ DB 'boundary_curvature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGEKJPHF@bare?$AA@
CONST	SEGMENT
??_C@_04BGEKJPHF@bare?$AA@ DB 'bare', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LJFNGFOM@mobility_tensor?$AA@
CONST	SEGMENT
??_C@_0BA@LJFNGFOM@mobility_tensor?$AA@ DB 'mobility_tensor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DJCKBMBN@mobility?$AA@
CONST	SEGMENT
??_C@_08DJCKBMBN@mobility?$AA@ DB 'mobility', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LNEAGBL@form_integrand?$AA@
CONST	SEGMENT
??_C@_0P@LNEAGBL@form_integrand?$AA@ DB 'form_integrand', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HMNODAPJ@k_vector_order?$AA@
CONST	SEGMENT
??_C@_0P@HMNODAPJ@k_vector_order?$AA@ DB 'k_vector_order', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CNKNAII@vector_integrand?$AA@
CONST	SEGMENT
??_C@_0BB@CNKNAII@vector_integrand?$AA@ DB 'vector_integrand', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KCGOMKJL@scalar_integrand?$AA@
CONST	SEGMENT
??_C@_0BB@KCGOMKJL@scalar_integrand?$AA@ DB 'scalar_integrand', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GABBCIBA@method?$AA@
CONST	SEGMENT
??_C@_06GABBCIBA@method?$AA@ DB 'method', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FCDDEKDG@method_instance?$AA@
CONST	SEGMENT
??_C@_0BA@FCDDEKDG@method_instance?$AA@ DB 'method_instance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HGIEBAJ@attribute?$AA@
CONST	SEGMENT
??_C@_09HGIEBAJ@attribute?$AA@ DB 'attribute', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EPMMJFDC@define?$AA@
CONST	SEGMENT
??_C@_06EPMMJFDC@define?$AA@ DB 'define', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJLAMBGK@target?$AA@
CONST	SEGMENT
??_C@_06JJLAMBGK@target?$AA@ DB 'target', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFEJDJP@value?$AA@
CONST	SEGMENT
??_C@_05MFEJDJP@value?$AA@ DB 'value', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DMHBIFMB@everything_quantities?$AA@
CONST	SEGMENT
??_C@_0BG@DMHBIFMB@everything_quantities?$AA@ DB 'everything_quantities', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PCMDHFO@optimising_parameter?$AA@
CONST	SEGMENT
??_C@_0BF@PCMDHFO@optimising_parameter?$AA@ DB 'optimising_parameter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HJFOCADB@optimizing_parameter?$AA@
CONST	SEGMENT
??_C@_0BF@HJFOCADB@optimizing_parameter?$AA@ DB 'optimizing_parameter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JADJAFPH@parameter_2?$AA@
CONST	SEGMENT
??_C@_0M@JADJAFPH@parameter_2?$AA@ DB 'parameter_2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LLBEFGDE@parameter_1?$AA@
CONST	SEGMENT
??_C@_0M@LLBEFGDE@parameter_1?$AA@ DB 'parameter_1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DDMFGHDB@lagrange_order?$AA@
CONST	SEGMENT
??_C@_0P@DDMFGHDB@lagrange_order?$AA@ DB 'lagrange_order', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JNKCHLOP@lagrange?$AA@
CONST	SEGMENT
??_C@_08JNKCHLOP@lagrange?$AA@ DB 'lagrange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BIHLDDLK@axial_point?$AA@
CONST	SEGMENT
??_C@_0M@BIHLDDLK@axial_point?$AA@ DB 'axial_point', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KPHKHJOD@interp_bdry_param?$AA@
CONST	SEGMENT
??_C@_0BC@KPHKHJOD@interp_bdry_param?$AA@ DB 'interp_bdry_param', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KPOPAFCP@load_library?$AA@
CONST	SEGMENT
??_C@_0N@KPOPAFCP@load_library?$AA@ DB 'load_library', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DPCDAEDN@ignore_fixed?$AA@
CONST	SEGMENT
??_C@_0N@DPCDAEDN@ignore_fixed?$AA@ DB 'ignore_fixed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IJHNDEKK@ignore_constraints?$AA@
CONST	SEGMENT
??_C@_0BD@IJHNDEKK@ignore_constraints?$AA@ DB 'ignore_constraints', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KPMDGEHG@orientation?$AA@
CONST	SEGMENT
??_C@_0M@KPMDGEHG@orientation?$AA@ DB 'orientation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DKKLMIEO@evolver_version?$AA@
CONST	SEGMENT
??_C@_0BA@DKKLMIEO@evolver_version?$AA@ DB 'evolver_version', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MPMEKLIN@lagrange_multiplier?$AA@
CONST	SEGMENT
??_C@_0BE@MPMEKLIN@lagrange_multiplier?$AA@ DB 'lagrange_multiplier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FFJNLCDE@tolerance?$AA@
CONST	SEGMENT
??_C@_09FFJNLCDE@tolerance?$AA@ DB 'tolerance', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EHFNPAFG@on_assign_call?$AA@
CONST	SEGMENT
??_C@_0P@EHFNPAFG@on_assign_call?$AA@ DB 'on_assign_call', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BCKCJHAK@pdelta?$AA@
CONST	SEGMENT
??_C@_06BCKCJHAK@pdelta?$AA@ DB 'pdelta', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MGPGBEBP@keep_macros?$AA@
CONST	SEGMENT
??_C@_0M@MGPGBEBP@keep_macros?$AA@ DB 'keep_macros', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFOLDLE@actual_volume?$AA@
CONST	SEGMENT
??_C@_0O@CFOLDLE@actual_volume?$AA@ DB 'actual_volume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GHGMGLNO@conserved?$AA@
CONST	SEGMENT
??_C@_09GHGMGLNO@conserved?$AA@ DB 'conserved', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJDNGLKJ@self?$AA@
CONST	SEGMENT
??_C@_04PJDNGLKJ@self?$AA@ DB 'self', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GNHLGAPA@swap_colors?$AA@
CONST	SEGMENT
??_C@_0M@GNHLGAPA@swap_colors?$AA@ DB 'swap_colors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EFLDDNJL@element_modulus?$AA@
CONST	SEGMENT
??_C@_0BA@EFLDDNJL@element_modulus?$AA@ DB 'element_modulus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NAPIFNOG@keep_originals?$AA@
CONST	SEGMENT
??_C@_0P@NAPIFNOG@keep_originals?$AA@ DB 'keep_originals', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JLAEKIJE@hessian_special_normal_vector?$AA@
CONST	SEGMENT
??_C@_0BO@JLAEKIJE@hessian_special_normal_vector?$AA@ DB 'hessian_special'
	DB	'_normal_vector', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CNJENMNM@area_method_name?$AA@
CONST	SEGMENT
??_C@_0BB@CNJENMNM@area_method_name?$AA@ DB 'area_method_name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LPDEKMFI@length_method_name?$AA@
CONST	SEGMENT
??_C@_0BD@LPDEKMFI@length_method_name?$AA@ DB 'length_method_name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OAMDDONM@display_origin?$AA@
CONST	SEGMENT
??_C@_0P@OAMDDONM@display_origin?$AA@ DB 'display_origin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KAGJCBDL@procedure?$AA@
CONST	SEGMENT
??_C@_09KAGJCBDL@procedure?$AA@ DB 'procedure', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FGAGLOAP@partner_hitting?$AA@
CONST	SEGMENT
??_C@_0BA@FGAGLOAP@partner_hitting?$AA@ DB 'partner_hitting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PDLHDKOI@volume_method_name?$AA@
CONST	SEGMENT
??_C@_0BD@PDLHDKOI@volume_method_name?$AA@ DB 'volume_method_name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JLBMBNDA@unsuppress_warning?$AA@
CONST	SEGMENT
??_C@_0BD@JLBMBNDA@unsuppress_warning?$AA@ DB 'unsuppress_warning', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DAFJNDLH@suppress_warning?$AA@
CONST	SEGMENT
??_C@_0BB@DAFJNDLH@suppress_warning?$AA@ DB 'suppress_warning', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FHDEFNFH@high_boundary?$AA@
CONST	SEGMENT
??_C@_0O@FHDEFNFH@high_boundary?$AA@ DB 'high_boundary', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HEFKJKJG@high_constraint?$AA@
CONST	SEGMENT
??_C@_0BA@HEFKJKJG@high_constraint?$AA@ DB 'high_constraint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BGNGCLLP@content_rank?$AA@
CONST	SEGMENT
??_C@_0N@BGNGCLLP@content_rank?$AA@ DB 'content_rank', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DOOANBHL@on_method_instance?$AA@
CONST	SEGMENT
??_C@_0BD@DOOANBHL@on_method_instance?$AA@ DB 'on_method_instance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPHPDHLO@on_quantity?$AA@
CONST	SEGMENT
??_C@_0M@GPHPDHLO@on_quantity?$AA@ DB 'on_quantity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CFABBPOL@on_boundary?$AA@
CONST	SEGMENT
??_C@_0M@CFABBPOL@on_boundary?$AA@ DB 'on_boundary', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CFDLCAJO@value_of_constraint?$AA@
CONST	SEGMENT
??_C@_0BE@CFDLCAJO@value_of_constraint?$AA@ DB 'value_of_constraint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FJLNFBKF@hit_constraint?$AA@
CONST	SEGMENT
??_C@_0P@FJLNFBKF@hit_constraint?$AA@ DB 'hit_constraint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KEPICJKL@on_constraint?$AA@
CONST	SEGMENT
??_C@_0O@KEPICJKL@on_constraint?$AA@ DB 'on_constraint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GOLNCKNL@slice_coeff?$AA@
CONST	SEGMENT
??_C@_0M@GOLNCKNL@slice_coeff?$AA@ DB 'slice_coeff', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PJJPIEAP@clip_coeff?$AA@
CONST	SEGMENT
??_C@_0L@PJJPIEAP@clip_coeff?$AA@ DB 'clip_coeff', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EHCKFCGI@mpi_local_bodies?$AA@
CONST	SEGMENT
??_C@_0BB@EHCKFCGI@mpi_local_bodies?$AA@ DB 'mpi_local_bodies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IJGPCJHC@opacity?$AA@
CONST	SEGMENT
??_C@_07IJGPCJHC@opacity?$AA@ DB 'opacity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GEDNAPDC@method_instances_predicted?$AA@
CONST	SEGMENT
??_C@_0BL@GEDNAPDC@method_instances_predicted?$AA@ DB 'method_instances_p'
	DB	'redicted', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MMBIFFBD@quantities_predicted?$AA@
CONST	SEGMENT
??_C@_0BF@MMBIFFBD@quantities_predicted?$AA@ DB 'quantities_predicted', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OBIIONED@facetedges_predicted?$AA@
CONST	SEGMENT
??_C@_0BF@OBIIONED@facetedges_predicted?$AA@ DB 'facetedges_predicted', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PCLCALDK@bodies_predicted?$AA@
CONST	SEGMENT
??_C@_0BB@PCLCALDK@bodies_predicted?$AA@ DB 'bodies_predicted', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HJFNDLDG@facets_predicted?$AA@
CONST	SEGMENT
??_C@_0BB@HJFNDLDG@facets_predicted?$AA@ DB 'facets_predicted', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EPBHJJLH@edges_predicted?$AA@
CONST	SEGMENT
??_C@_0BA@EPBHJJLH@edges_predicted?$AA@ DB 'edges_predicted', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ICOCBELD@vertices_predicted?$AA@
CONST	SEGMENT
??_C@_0BD@ICOCBELD@vertices_predicted?$AA@ DB 'vertices_predicted', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GIOJPOGN@calculate_in_3d?$AA@
CONST	SEGMENT
??_C@_0BA@GIOJPOGN@calculate_in_3d?$AA@ DB 'calculate_in_3d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06INBLBDJM@?5?7?$AN?0?3?$DL?$AA@
CONST	SEGMENT
??_C@_06INBLBDJM@?5?7?$AN?0?3?$DL?$AA@ DB ' ', 09H, 0dH, ',:;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01JEJKBAGA@g?$AA@
CONST	SEGMENT
??_C@_01JEJKBAGA@g?$AA@ DB 'g', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT
??_C@_01KGKMHCOC@e?$AA@ DB 'e', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OAHAJOFD@pi?$AA@
CONST	SEGMENT
??_C@_02OAHAJOFD@pi?$AA@ DB 'pi', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_yy_init DD	01H
_line_no DD	01H
_yy_accept DW	00H
	DW	00H
	DW	00H
	DW	045H
	DW	043H
	DW	041H
	DW	03H
	DW	038H
	DW	019H
	DW	043H
	DW	029H
	DW	043H
	DW	043H
	DW	02eH
	DW	02fH
	DW	029H
	DW	029H
	DW	028H
	DW	029H
	DW	029H
	DW	07H
	DW	07H
	DW	07H
	DW	042H
	DW	02aH
	DW	029H
	DW	02dH
	DW	029H
	DW	03fH
	DW	03fH
	DW	030H
	DW	02bH
	DW	039H
	DW	02cH
	DW	041H
	DW	029H
	DW	01fH
	DW	029H
	DW	05H
	DW	05H
	DW	05H
	DW	00H
	DW	00H
	DW	01cH
	DW	00H
	DW	033H
	DW	00H
	DW	00H
	DW	037H
	DW	00H
	DW	031H
	DW	024H
	DW	022H
	DW	023H
	DW	017H
	DW	01H
	DW	02H
	DW	025H
	DW	016H
	DW	07H
	DW	07H
	DW	0bH
	DW	00H
	DW	00H
	DW	00H
	DW	020H
	DW	021H
	DW	034H
	DW	032H
	DW	035H
	DW	03aH
	DW	03fH
	DW	03fH
	DW	00H
	DW	03cH
	DW	036H
	DW	00H
	DW	00H
	DW	01cH
	DW	00H
	DW	05H
	DW	00H
	DW	00H
	DW	01eH
	DW	05H
	DW	014H
	DW	013H
	DW	05H
	DW	05H
	DW	00H
	DW	00H
	DW	00H
	DW	06H
	DW	01aH
	DW	01bH
	DW	06H
	DW	01dH
	DW	00H
	DW	00H
	DW	00H
	DW	040H
	DW	00H
	DW	02H
	DW	016H
	DW	00H
	DW	00H
	DW	018H
	DW	0aH
	DW	00H
	DW	026H
	DW	03bH
	DW	03fH
	DW	00H
	DW	06H
	DW	05H
	DW	014H
	DW	013H
	DW	00H
	DW	00H
	DW	0eH
	DW	0dH
	DW	00H
	DW	00H
	DW	013H
	DW	00H
	DW	08H
	DW	00H
	DW	015H
	DW	011H
	DW	010H
	DW	00H
	DW	09H
	DW	00H
	DW	00H
	DW	00H
	DW	017H
	DW	00H
	DW	0cH
	DW	0cH
	DW	00H
	DW	016H
	DW	027H
	DW	03fH
	DW	0eH
	DW	0dH
	DW	00H
	DW	00H
	DW	013H
	DW	00H
	DW	08H
	DW	00H
	DW	015H
	DW	00H
	DW	0dH
	DW	00H
	DW	00H
	DW	0fH
	DW	00H
	DW	014H
	DW	00H
	DW	0cH
	DW	00H
	DW	013H
	DW	00H
	DW	010H
	DW	00H
	DW	00H
	DW	012H
	DW	00H
	DW	00H
	DW	00H
	DW	016H
	DW	03fH
	DW	00H
	DW	0dH
	DW	00H
	DW	00H
	DW	0fH
	DW	00H
	DW	014H
	DW	00H
	DW	00H
	DW	013H
	DW	00H
	DW	0eH
	DW	00H
	DW	00H
	DW	0dH
	DW	00H
	DW	013H
	DW	00H
	DW	011H
	DW	00H
	DW	00H
	DW	010H
	DW	00H
	DW	00H
	DW	03fH
	DW	00H
	DW	0eH
	DW	00H
	DW	00H
	DW	0dH
	DW	00H
	DW	013H
	DW	00H
	DW	0dH
	DW	00H
	DW	010H
	DW	03dH
	DW	00H
	DW	03fH
	DW	00H
	DW	0dH
	DW	00H
	DW	03fH
	DW	00H
	DW	00H
	DW	03fH
	DW	00H
	DW	03eH
	DW	03fH
	DW	03fH
	DW	03fH
	DW	03fH
	DW	03fH
	DW	03fH
	DW	03fH
	DW	04H
	DW	00H
_whitespace DD	FLAT:??_C@_06INBLBDJM@?5?7?$AN?0?3?$DL?$AA@
_yy_ec	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	03H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	01H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	DD	011H
	DD	012H
	DD	013H
	DD	014H
	DD	015H
	DD	015H
	DD	015H
	DD	015H
	DD	015H
	DD	015H
	DD	015H
	DD	015H
	DD	016H
	DD	017H
	DD	018H
	DD	019H
	DD	01aH
	DD	08H
	DD	01bH
	DD	01cH
	DD	01dH
	DD	01cH
	DD	01eH
	DD	01eH
	DD	01cH
	DD	01fH
	DD	01fH
	DD	01fH
	DD	01fH
	DD	020H
	DD	01fH
	DD	01fH
	DD	01fH
	DD	021H
	DD	01fH
	DD	01fH
	DD	01fH
	DD	01fH
	DD	022H
	DD	01fH
	DD	01fH
	DD	01fH
	DD	01fH
	DD	01fH
	DD	01fH
	DD	08H
	DD	01H
	DD	08H
	DD	08H
	DD	023H
	DD	024H
	DD	025H
	DD	026H
	DD	027H
	DD	028H
	DD	029H
	DD	02aH
	DD	02bH
	DD	02bH
	DD	02cH
	DD	02bH
	DD	02bH
	DD	02dH
	DD	02bH
	DD	02eH
	DD	02fH
	DD	02bH
	DD	02bH
	DD	02bH
	DD	02bH
	DD	030H
	DD	031H
	DD	02bH
	DD	02bH
	DD	032H
	DD	02bH
	DD	02bH
	DD	033H
	DD	034H
	DD	035H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
_yy_meta DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	03H
	DD	03H
	DD	03H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	04H
	DD	04H
	DD	05H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	07H
	DD	01H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	08H
	DD	08H
	DD	08H
	DD	08H
	DD	08H
	DD	08H
	DD	08H
	DD	08H
	DD	01H
	DD	01H
	DD	01H
_yy_base DW	00H
	DW	00H
	DW	034H
	DW	0133H
	DW	033bH
	DW	03cH
	DW	033bH
	DW	0118H
	DW	033bH
	DW	0fH
	DW	033bH
	DW	011eH
	DW	00H
	DW	033bH
	DW	033bH
	DW	02dH
	DW	0107H
	DW	0106H
	DW	03fH
	DW	048H
	DW	051H
	DW	0e9H
	DW	04aH
	DW	023H
	DW	0fdH
	DW	0f7H
	DW	0f2H
	DW	034H
	DW	00H
	DW	0e1H
	DW	047H
	DW	033bH
	DW	0cdH
	DW	033bH
	DW	082H
	DW	058H
	DW	074H
	DW	044H
	DW	087H
	DW	0caH
	DW	0a9H
	DW	0c6H
	DW	06aH
	DW	0daH
	DW	08bH
	DW	033bH
	DW	0d2H
	DW	0cbH
	DW	033bH
	DW	0ebH
	DW	033bH
	DW	033bH
	DW	033bH
	DW	033bH
	DW	097H
	DW	033bH
	DW	00H
	DW	033bH
	DW	0a3H
	DW	0c2H
	DW	0ceH
	DW	033bH
	DW	0eaH
	DW	00H
	DW	04aH
	DW	033bH
	DW	033bH
	DW	033bH
	DW	033bH
	DW	033bH
	DW	0d0H
	DW	00H
	DW	0bbH
	DW	058H
	DW	033bH
	DW	033bH
	DW	00H
	DW	0d3H
	DW	0efH
	DW	06dH
	DW	0f4H
	DW	077H
	DW	0f9H
	DW	033bH
	DW	0100H
	DW	0105H
	DW	0111H
	DW	0b3H
	DW	00H
	DW	094H
	DW	0122H
	DW	09eH
	DW	012aH
	DW	03bH
	DW	033bH
	DW	0143H
	DW	033bH
	DW	0baH
	DW	0b6H
	DW	0b1H
	DW	033bH
	DW	0132H
	DW	00H
	DW	0137H
	DW	0154H
	DW	0ddH
	DW	0117H
	DW	00H
	DW	0b7H
	DW	033bH
	DW	033bH
	DW	099H
	DW	013aH
	DW	0148H
	DW	0161H
	DW	015aH
	DW	0166H
	DW	0172H
	DW	017dH
	DW	0180H
	DW	0183H
	DW	018fH
	DW	019fH
	DW	0192H
	DW	01a9H
	DW	0186H
	DW	01acH
	DW	01afH
	DW	01b2H
	DW	01b5H
	DW	01c1H
	DW	01b8H
	DW	09aH
	DW	098H
	DW	01c4H
	DW	01ccH
	DW	01d4H
	DW	01d7H
	DW	01dfH
	DW	01e3H
	DW	01e6H
	DW	033bH
	DW	097H
	DW	01e9H
	DW	01ecH
	DW	01f8H
	DW	0208H
	DW	01fbH
	DW	0212H
	DW	01efH
	DW	0215H
	DW	0218H
	DW	0220H
	DW	0223H
	DW	022bH
	DW	022fH
	DW	0232H
	DW	0235H
	DW	023aH
	DW	0242H
	DW	024aH
	DW	024dH
	DW	0250H
	DW	0258H
	DW	025bH
	DW	0263H
	DW	0267H
	DW	026aH
	DW	094H
	DW	08aH
	DW	026dH
	DW	0272H
	DW	091H
	DW	027aH
	DW	027dH
	DW	0285H
	DW	0289H
	DW	028cH
	DW	028fH
	DW	0294H
	DW	029cH
	DW	029fH
	DW	02a2H
	DW	02a5H
	DW	02a8H
	DW	02b0H
	DW	02b3H
	DW	02b6H
	DW	02b9H
	DW	02bcH
	DW	02bfH
	DW	02c2H
	DW	02caH
	DW	02cdH
	DW	02d0H
	DW	085H
	DW	07bH
	DW	074H
	DW	02d3H
	DW	02d6H
	DW	02deH
	DW	02e1H
	DW	02e4H
	DW	02e7H
	DW	02eaH
	DW	02edH
	DW	02f0H
	DW	02f3H
	DW	02f6H
	DW	033bH
	DW	074H
	DW	06dH
	DW	02f9H
	DW	02fcH
	DW	0d1H
	DW	066H
	DW	0310H
	DW	08bH
	DW	066H
	DW	088H
	DW	033bH
	DW	059H
	DW	047H
	DW	045H
	DW	04dH
	DW	048H
	DW	022H
	DW	021H
	DW	00H
	DW	033bH
	DW	0313H
	DW	0319H
	DW	0321H
	DW	0327H
	DW	032aH
	DW	0332H
_yy_def	DW	00H
	DW	0e5H
	DW	01H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e6H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	014H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e7H
	DW	0e7H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	026H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e8H
	DW	0e5H
	DW	0e5H
	DW	014H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e9H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e7H
	DW	0e7H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	022H
	DW	0e5H
	DW	02bH
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	026H
	DW	028H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e8H
	DW	0eaH
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e9H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e7H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0eaH
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0eaH
	DW	089H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e7H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	089H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e7H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e7H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e7H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e7H
	DW	0e5H
	DW	0ebH
	DW	0e7H
	DW	0ebH
	DW	0e5H
	DW	0e7H
	DW	0e7H
	DW	0e7H
	DW	0e7H
	DW	0e7H
	DW	0e7H
	DW	0e7H
	DW	0e7H
	DW	00H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
_yy_nxt	DW	00H
	DW	04H
	DW	05H
	DW	06H
	DW	05H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	0fH
	DW	010H
	DW	0aH
	DW	011H
	DW	012H
	DW	013H
	DW	014H
	DW	015H
	DW	016H
	DW	017H
	DW	018H
	DW	019H
	DW	01aH
	DW	01bH
	DW	04H
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01eH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01cH
	DW	01fH
	DW	020H
	DW	021H
	DW	022H
	DW	02eH
	DW	022H
	DW	040H
	DW	032H
	DW	02fH
	DW	041H
	DW	05dH
	DW	029H
	DW	05dH
	DW	029H
	DW	0e4H
	DW	023H
	DW	0e3H
	DW	024H
	DW	025H
	DW	033H
	DW	026H
	DW	027H
	DW	028H
	DW	02aH
	DW	049H
	DW	02bH
	DW	045H
	DW	046H
	DW	02cH
	DW	02cH
	DW	02cH
	DW	036H
	DW	036H
	DW	036H
	DW	037H
	DW	04aH
	DW	055H
	DW	055H
	DW	055H
	DW	038H
	DW	03aH
	DW	049H
	DW	03cH
	DW	03cH
	DW	03cH
	DW	06cH
	DW	039H
	DW	03aH
	DW	06dH
	DW	03bH
	DW	03bH
	DW	03cH
	DW	04aH
	DW	03eH
	DW	051H
	DW	0e2H
	DW	052H
	DW	052H
	DW	052H
	DW	03dH
	DW	03eH
	DW	0e1H
	DW	034H
	DW	03eH
	DW	03eH
	DW	0e0H
	DW	0dfH
	DW	053H
	DW	03dH
	DW	053H
	DW	03eH
	DW	03eH
	DW	05bH
	DW	0deH
	DW	05cH
	DW	05cH
	DW	05cH
	DW	073H
	DW	073H
	DW	073H
	DW	03fH
	DW	04cH
	DW	051H
	DW	04cH
	DW	054H
	DW	054H
	DW	054H
	DW	077H
	DW	077H
	DW	077H
	DW	035H
	DW	0dcH
	DW	0ddH
	DW	04dH
	DW	0dcH
	DW	04eH
	DW	04fH
	DW	0daH
	DW	050H
	DW	050H
	DW	050H
	DW	056H
	DW	0d7H
	DW	057H
	DW	057H
	DW	058H
	DW	0d6H
	DW	02cH
	DW	02cH
	DW	02cH
	DW	0d3H
	DW	059H
	DW	0d2H
	DW	03dH
	DW	05aH
	DW	061H
	DW	07dH
	DW	07dH
	DW	07dH
	DW	036H
	DW	036H
	DW	036H
	DW	03dH
	DW	0d1H
	DW	05aH
	DW	05aH
	DW	080H
	DW	080H
	DW	080H
	DW	0c5H
	DW	065H
	DW	067H
	DW	067H
	DW	067H
	DW	03fH
	DW	056H
	DW	0c4H
	DW	058H
	DW	058H
	DW	058H
	DW	065H
	DW	065H
	DW	068H
	DW	0c3H
	DW	0acH
	DW	059H
	DW	0a9H
	DW	0a8H
	DW	05aH
	DW	029H
	DW	08eH
	DW	029H
	DW	068H
	DW	068H
	DW	083H
	DW	083H
	DW	083H
	DW	08dH
	DW	05aH
	DW	05aH
	DW	0d8H
	DW	02aH
	DW	0d8H
	DW	02bH
	DW	0d9H
	DW	085H
	DW	02cH
	DW	02cH
	DW	02cH
	DW	05dH
	DW	05eH
	DW	05dH
	DW	03aH
	DW	084H
	DW	03cH
	DW	03cH
	DW	03cH
	DW	070H
	DW	0e5H
	DW	071H
	DW	071H
	DW	071H
	DW	06fH
	DW	06eH
	DW	05bH
	DW	03eH
	DW	05fH
	DW	05fH
	DW	05fH
	DW	06aH
	DW	06aH
	DW	06aH
	DW	060H
	DW	0e5H
	DW	064H
	DW	03eH
	DW	03eH
	DW	069H
	DW	063H
	DW	069H
	DW	062H
	DW	0e5H
	DW	06aH
	DW	06aH
	DW	06aH
	DW	070H
	DW	04bH
	DW	072H
	DW	072H
	DW	072H
	DW	074H
	DW	048H
	DW	050H
	DW	050H
	DW	050H
	DW	078H
	DW	044H
	DW	052H
	DW	052H
	DW	052H
	DW	075H
	DW	043H
	DW	078H
	DW	076H
	DW	054H
	DW	054H
	DW	054H
	DW	042H
	DW	079H
	DW	055H
	DW	055H
	DW	055H
	DW	0e5H
	DW	076H
	DW	076H
	DW	079H
	DW	035H
	DW	034H
	DW	079H
	DW	079H
	DW	07aH
	DW	07bH
	DW	07bH
	DW	07bH
	DW	030H
	DW	079H
	DW	079H
	DW	06aH
	DW	06aH
	DW	06aH
	DW	07aH
	DW	07aH
	DW	07cH
	DW	07eH
	DW	02dH
	DW	07eH
	DW	0e5H
	DW	0e5H
	DW	07fH
	DW	07fH
	DW	07fH
	DW	0e5H
	DW	07cH
	DW	07cH
	DW	081H
	DW	0e5H
	DW	05cH
	DW	05cH
	DW	05cH
	DW	086H
	DW	0e5H
	DW	086H
	DW	0e5H
	DW	0e5H
	DW	087H
	DW	087H
	DW	087H
	DW	082H
	DW	0e5H
	DW	067H
	DW	067H
	DW	067H
	DW	08fH
	DW	08fH
	DW	08fH
	DW	0e5H
	DW	0e5H
	DW	082H
	DW	082H
	DW	081H
	DW	088H
	DW	05fH
	DW	05fH
	DW	05fH
	DW	090H
	DW	0e5H
	DW	071H
	DW	071H
	DW	071H
	DW	061H
	DW	08aH
	DW	08aH
	DW	082H
	DW	08bH
	DW	0e5H
	DW	08bH
	DW	0e5H
	DW	091H
	DW	08cH
	DW	08cH
	DW	08cH
	DW	0e5H
	DW	082H
	DW	082H
	DW	073H
	DW	073H
	DW	073H
	DW	091H
	DW	091H
	DW	090H
	DW	0e5H
	DW	072H
	DW	072H
	DW	072H
	DW	0e5H
	DW	092H
	DW	093H
	DW	093H
	DW	093H
	DW	061H
	DW	0e5H
	DW	0e5H
	DW	091H
	DW	0e5H
	DW	0e5H
	DW	092H
	DW	092H
	DW	094H
	DW	095H
	DW	095H
	DW	095H
	DW	0e5H
	DW	091H
	DW	091H
	DW	096H
	DW	0e5H
	DW	096H
	DW	094H
	DW	094H
	DW	097H
	DW	097H
	DW	097H
	DW	077H
	DW	077H
	DW	077H
	DW	099H
	DW	099H
	DW	099H
	DW	07dH
	DW	07dH
	DW	07dH
	DW	0e5H
	DW	09bH
	DW	098H
	DW	09bH
	DW	0e5H
	DW	09aH
	DW	09cH
	DW	09cH
	DW	09cH
	DW	07bH
	DW	07bH
	DW	07bH
	DW	098H
	DW	098H
	DW	0e5H
	DW	09aH
	DW	09aH
	DW	09dH
	DW	0e5H
	DW	09dH
	DW	09fH
	DW	0e5H
	DW	09eH
	DW	09eH
	DW	09eH
	DW	0e5H
	DW	0e5H
	DW	0a1H
	DW	0e5H
	DW	0a1H
	DW	0a0H
	DW	0a0H
	DW	0a2H
	DW	0a2H
	DW	0a2H
	DW	07fH
	DW	07fH
	DW	07fH
	DW	07fH
	DW	07fH
	DW	07fH
	DW	080H
	DW	080H
	DW	080H
	DW	0a4H
	DW	0a4H
	DW	0a4H
	DW	083H
	DW	083H
	DW	083H
	DW	0e5H
	DW	0a6H
	DW	0a3H
	DW	0a6H
	DW	0e5H
	DW	0a5H
	DW	0a7H
	DW	0a7H
	DW	0a7H
	DW	087H
	DW	087H
	DW	087H
	DW	0a3H
	DW	0a3H
	DW	0e5H
	DW	0a5H
	DW	0a5H
	DW	087H
	DW	087H
	DW	087H
	DW	0aaH
	DW	0e5H
	DW	0aaH
	DW	0e5H
	DW	0e5H
	DW	0abH
	DW	0abH
	DW	0abH
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0aaH
	DW	0e5H
	DW	0aaH
	DW	0e5H
	DW	0e5H
	DW	0abH
	DW	0abH
	DW	0abH
	DW	0e5H
	DW	08cH
	DW	08cH
	DW	08cH
	DW	08cH
	DW	08cH
	DW	08cH
	DW	08fH
	DW	08fH
	DW	08fH
	DW	0aeH
	DW	0aeH
	DW	0aeH
	DW	095H
	DW	095H
	DW	095H
	DW	0e5H
	DW	0b0H
	DW	0adH
	DW	0b0H
	DW	0e5H
	DW	0afH
	DW	0b1H
	DW	0b1H
	DW	0b1H
	DW	093H
	DW	093H
	DW	093H
	DW	0adH
	DW	0adH
	DW	0e5H
	DW	0afH
	DW	0afH
	DW	0b2H
	DW	0e5H
	DW	0b2H
	DW	0b4H
	DW	0e5H
	DW	0b3H
	DW	0b3H
	DW	0b3H
	DW	0e5H
	DW	0e5H
	DW	0b5H
	DW	0e5H
	DW	0b5H
	DW	0b4H
	DW	0b4H
	DW	0b6H
	DW	0b6H
	DW	0b6H
	DW	097H
	DW	097H
	DW	097H
	DW	097H
	DW	097H
	DW	097H
	DW	0b7H
	DW	0e5H
	DW	0b7H
	DW	0e5H
	DW	0e5H
	DW	0b8H
	DW	0b8H
	DW	0b8H
	DW	099H
	DW	099H
	DW	099H
	DW	0baH
	DW	0e5H
	DW	0baH
	DW	0e5H
	DW	0e5H
	DW	0bbH
	DW	0bbH
	DW	0bbH
	DW	0b9H
	DW	09cH
	DW	09cH
	DW	09cH
	DW	09cH
	DW	09cH
	DW	09cH
	DW	09eH
	DW	09eH
	DW	09eH
	DW	0b9H
	DW	0b9H
	DW	09eH
	DW	09eH
	DW	09eH
	DW	0bcH
	DW	0e5H
	DW	0bcH
	DW	0e5H
	DW	0e5H
	DW	0bdH
	DW	0bdH
	DW	0bdH
	DW	0bcH
	DW	0e5H
	DW	0bcH
	DW	0e5H
	DW	0e5H
	DW	0bdH
	DW	0bdH
	DW	0bdH
	DW	0a2H
	DW	0a2H
	DW	0a2H
	DW	0a2H
	DW	0a2H
	DW	0a2H
	DW	0beH
	DW	0e5H
	DW	0beH
	DW	0e5H
	DW	0e5H
	DW	0bfH
	DW	0bfH
	DW	0bfH
	DW	0a4H
	DW	0a4H
	DW	0a4H
	DW	0c1H
	DW	0e5H
	DW	0c1H
	DW	0e5H
	DW	0e5H
	DW	0c2H
	DW	0c2H
	DW	0c2H
	DW	0c0H
	DW	0a7H
	DW	0a7H
	DW	0a7H
	DW	0a7H
	DW	0a7H
	DW	0a7H
	DW	0abH
	DW	0abH
	DW	0abH
	DW	0c0H
	DW	0c0H
	DW	0abH
	DW	0abH
	DW	0abH
	DW	0c6H
	DW	0e5H
	DW	0c6H
	DW	0e5H
	DW	0e5H
	DW	0c7H
	DW	0c7H
	DW	0c7H
	DW	0aeH
	DW	0aeH
	DW	0aeH
	DW	0c9H
	DW	0e5H
	DW	0c9H
	DW	0e5H
	DW	0e5H
	DW	0caH
	DW	0caH
	DW	0caH
	DW	0c8H
	DW	0b1H
	DW	0b1H
	DW	0b1H
	DW	0b1H
	DW	0b1H
	DW	0b1H
	DW	0b3H
	DW	0b3H
	DW	0b3H
	DW	0c8H
	DW	0c8H
	DW	0b3H
	DW	0b3H
	DW	0b3H
	DW	0cbH
	DW	0e5H
	DW	0cbH
	DW	0e5H
	DW	0e5H
	DW	0ccH
	DW	0ccH
	DW	0ccH
	DW	0b6H
	DW	0b6H
	DW	0b6H
	DW	0b6H
	DW	0b6H
	DW	0b6H
	DW	0b8H
	DW	0b8H
	DW	0b8H
	DW	0b8H
	DW	0b8H
	DW	0b8H
	DW	0cdH
	DW	0e5H
	DW	0cdH
	DW	0e5H
	DW	0e5H
	DW	0ceH
	DW	0ceH
	DW	0ceH
	DW	0bbH
	DW	0bbH
	DW	0bbH
	DW	0bbH
	DW	0bbH
	DW	0bbH
	DW	0bdH
	DW	0bdH
	DW	0bdH
	DW	0bdH
	DW	0bdH
	DW	0bdH
	DW	0bfH
	DW	0bfH
	DW	0bfH
	DW	0bfH
	DW	0bfH
	DW	0bfH
	DW	0cfH
	DW	0e5H
	DW	0cfH
	DW	0e5H
	DW	0e5H
	DW	0d0H
	DW	0d0H
	DW	0d0H
	DW	0c2H
	DW	0c2H
	DW	0c2H
	DW	0c2H
	DW	0c2H
	DW	0c2H
	DW	0c7H
	DW	0c7H
	DW	0c7H
	DW	0c7H
	DW	0c7H
	DW	0c7H
	DW	0d4H
	DW	0e5H
	DW	0d4H
	DW	0e5H
	DW	0e5H
	DW	0d5H
	DW	0d5H
	DW	0d5H
	DW	0caH
	DW	0caH
	DW	0caH
	DW	0caH
	DW	0caH
	DW	0caH
	DW	0ccH
	DW	0ccH
	DW	0ccH
	DW	0ccH
	DW	0ccH
	DW	0ccH
	DW	0ceH
	DW	0ceH
	DW	0ceH
	DW	0ceH
	DW	0ceH
	DW	0ceH
	DW	0d0H
	DW	0d0H
	DW	0d0H
	DW	0d0H
	DW	0d0H
	DW	0d0H
	DW	0d5H
	DW	0d5H
	DW	0d5H
	DW	0d5H
	DW	0d5H
	DW	0d5H
	DW	0d8H
	DW	0e5H
	DW	0d8H
	DW	0e5H
	DW	0d9H
	DW	031H
	DW	031H
	DW	031H
	DW	0e5H
	DW	031H
	DW	047H
	DW	047H
	DW	047H
	DW	047H
	DW	047H
	DW	047H
	DW	066H
	DW	0e5H
	DW	066H
	DW	066H
	DW	066H
	DW	066H
	DW	066H
	DW	066H
	DW	06bH
	DW	06bH
	DW	06bH
	DW	089H
	DW	0e5H
	DW	089H
	DW	0e5H
	DW	0e5H
	DW	089H
	DW	0dbH
	DW	0dbH
	DW	0dbH
	DW	0dbH
	DW	0dbH
	DW	0dbH
	DW	0dbH
	DW	0dbH
	DW	03H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	ORG $+6
_yy_chk	DW	00H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	09H
	DW	02H
	DW	017H
	DW	0fH
	DW	09H
	DW	017H
	DW	05dH
	DW	05H
	DW	05dH
	DW	05H
	DW	0e3H
	DW	02H
	DW	0e2H
	DW	02H
	DW	02H
	DW	0fH
	DW	02H
	DW	02H
	DW	02H
	DW	05H
	DW	01eH
	DW	05H
	DW	01bH
	DW	01bH
	DW	05H
	DW	05H
	DW	05H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	01eH
	DW	025H
	DW	025H
	DW	025H
	DW	013H
	DW	016H
	DW	049H
	DW	016H
	DW	016H
	DW	016H
	DW	040H
	DW	013H
	DW	014H
	DW	040H
	DW	014H
	DW	014H
	DW	014H
	DW	049H
	DW	016H
	DW	023H
	DW	0e1H
	DW	023H
	DW	023H
	DW	023H
	DW	014H
	DW	014H
	DW	0e0H
	DW	023H
	DW	016H
	DW	016H
	DW	0dfH
	DW	0deH
	DW	024H
	DW	014H
	DW	024H
	DW	014H
	DW	014H
	DW	02aH
	DW	0ddH
	DW	02aH
	DW	02aH
	DW	02aH
	DW	04fH
	DW	04fH
	DW	04fH
	DW	014H
	DW	022H
	DW	024H
	DW	022H
	DW	024H
	DW	024H
	DW	024H
	DW	051H
	DW	051H
	DW	051H
	DW	024H
	DW	0dbH
	DW	0daH
	DW	022H
	DW	0d9H
	DW	022H
	DW	022H
	DW	0d7H
	DW	022H
	DW	022H
	DW	022H
	DW	026H
	DW	0d3H
	DW	026H
	DW	026H
	DW	026H
	DW	0d2H
	DW	02cH
	DW	02cH
	DW	02cH
	DW	0c5H
	DW	026H
	DW	0c4H
	DW	026H
	DW	026H
	DW	02cH
	DW	059H
	DW	059H
	DW	059H
	DW	036H
	DW	036H
	DW	036H
	DW	026H
	DW	0c3H
	DW	026H
	DW	026H
	DW	05bH
	DW	05bH
	DW	05bH
	DW	0acH
	DW	036H
	DW	03aH
	DW	03aH
	DW	03aH
	DW	026H
	DW	028H
	DW	0a9H
	DW	028H
	DW	028H
	DW	028H
	DW	036H
	DW	036H
	DW	03aH
	DW	0a8H
	DW	08eH
	DW	028H
	DW	085H
	DW	084H
	DW	028H
	DW	029H
	DW	06fH
	DW	029H
	DW	03aH
	DW	03aH
	DW	061H
	DW	061H
	DW	061H
	DW	06cH
	DW	028H
	DW	028H
	DW	0d6H
	DW	029H
	DW	0d6H
	DW	029H
	DW	0d6H
	DW	063H
	DW	029H
	DW	029H
	DW	029H
	DW	02bH
	DW	02bH
	DW	02bH
	DW	03cH
	DW	062H
	DW	03cH
	DW	03cH
	DW	03cH
	DW	04dH
	DW	057H
	DW	04dH
	DW	04dH
	DW	04dH
	DW	048H
	DW	046H
	DW	02bH
	DW	03cH
	DW	02bH
	DW	02bH
	DW	02bH
	DW	069H
	DW	069H
	DW	069H
	DW	02bH
	DW	03bH
	DW	031H
	DW	03cH
	DW	03cH
	DW	03eH
	DW	02fH
	DW	03eH
	DW	02eH
	DW	027H
	DW	03eH
	DW	03eH
	DW	03eH
	DW	04eH
	DW	020H
	DW	04eH
	DW	04eH
	DW	04eH
	DW	050H
	DW	01dH
	DW	050H
	DW	050H
	DW	050H
	DW	052H
	DW	01aH
	DW	052H
	DW	052H
	DW	052H
	DW	050H
	DW	019H
	DW	054H
	DW	050H
	DW	054H
	DW	054H
	DW	054H
	DW	018H
	DW	052H
	DW	055H
	DW	055H
	DW	055H
	DW	015H
	DW	050H
	DW	050H
	DW	054H
	DW	011H
	DW	010H
	DW	052H
	DW	052H
	DW	055H
	DW	056H
	DW	056H
	DW	056H
	DW	0bH
	DW	054H
	DW	054H
	DW	06aH
	DW	06aH
	DW	06aH
	DW	055H
	DW	055H
	DW	056H
	DW	05aH
	DW	07H
	DW	05aH
	DW	03H
	DW	00H
	DW	05aH
	DW	05aH
	DW	05aH
	DW	00H
	DW	056H
	DW	056H
	DW	05cH
	DW	00H
	DW	05cH
	DW	05cH
	DW	05cH
	DW	065H
	DW	00H
	DW	065H
	DW	00H
	DW	00H
	DW	065H
	DW	065H
	DW	065H
	DW	05cH
	DW	00H
	DW	067H
	DW	067H
	DW	067H
	DW	070H
	DW	070H
	DW	070H
	DW	00H
	DW	00H
	DW	05cH
	DW	05cH
	DW	05fH
	DW	067H
	DW	05fH
	DW	05fH
	DW	05fH
	DW	071H
	DW	00H
	DW	071H
	DW	071H
	DW	071H
	DW	05fH
	DW	067H
	DW	067H
	DW	05fH
	DW	068H
	DW	00H
	DW	068H
	DW	00H
	DW	071H
	DW	068H
	DW	068H
	DW	068H
	DW	00H
	DW	05fH
	DW	05fH
	DW	073H
	DW	073H
	DW	073H
	DW	071H
	DW	071H
	DW	072H
	DW	00H
	DW	072H
	DW	072H
	DW	072H
	DW	00H
	DW	073H
	DW	074H
	DW	074H
	DW	074H
	DW	072H
	DW	00H
	DW	00H
	DW	072H
	DW	00H
	DW	00H
	DW	073H
	DW	073H
	DW	074H
	DW	075H
	DW	075H
	DW	075H
	DW	00H
	DW	072H
	DW	072H
	DW	076H
	DW	00H
	DW	076H
	DW	074H
	DW	074H
	DW	076H
	DW	076H
	DW	076H
	DW	077H
	DW	077H
	DW	077H
	DW	078H
	DW	078H
	DW	078H
	DW	07dH
	DW	07dH
	DW	07dH
	DW	00H
	DW	079H
	DW	077H
	DW	079H
	DW	00H
	DW	078H
	DW	079H
	DW	079H
	DW	079H
	DW	07bH
	DW	07bH
	DW	07bH
	DW	077H
	DW	077H
	DW	00H
	DW	078H
	DW	078H
	DW	07aH
	DW	00H
	DW	07aH
	DW	07bH
	DW	00H
	DW	07aH
	DW	07aH
	DW	07aH
	DW	00H
	DW	00H
	DW	07cH
	DW	00H
	DW	07cH
	DW	07bH
	DW	07bH
	DW	07cH
	DW	07cH
	DW	07cH
	DW	07eH
	DW	07eH
	DW	07eH
	DW	07fH
	DW	07fH
	DW	07fH
	DW	080H
	DW	080H
	DW	080H
	DW	081H
	DW	081H
	DW	081H
	DW	083H
	DW	083H
	DW	083H
	DW	00H
	DW	082H
	DW	080H
	DW	082H
	DW	00H
	DW	081H
	DW	082H
	DW	082H
	DW	082H
	DW	086H
	DW	086H
	DW	086H
	DW	080H
	DW	080H
	DW	00H
	DW	081H
	DW	081H
	DW	087H
	DW	087H
	DW	087H
	DW	088H
	DW	00H
	DW	088H
	DW	00H
	DW	00H
	DW	088H
	DW	088H
	DW	088H
	DW	089H
	DW	089H
	DW	089H
	DW	08aH
	DW	00H
	DW	08aH
	DW	00H
	DW	00H
	DW	08aH
	DW	08aH
	DW	08aH
	DW	089H
	DW	08bH
	DW	08bH
	DW	08bH
	DW	08cH
	DW	08cH
	DW	08cH
	DW	08fH
	DW	08fH
	DW	08fH
	DW	090H
	DW	090H
	DW	090H
	DW	095H
	DW	095H
	DW	095H
	DW	00H
	DW	091H
	DW	08fH
	DW	091H
	DW	00H
	DW	090H
	DW	091H
	DW	091H
	DW	091H
	DW	093H
	DW	093H
	DW	093H
	DW	08fH
	DW	08fH
	DW	00H
	DW	090H
	DW	090H
	DW	092H
	DW	00H
	DW	092H
	DW	093H
	DW	00H
	DW	092H
	DW	092H
	DW	092H
	DW	00H
	DW	00H
	DW	094H
	DW	00H
	DW	094H
	DW	093H
	DW	093H
	DW	094H
	DW	094H
	DW	094H
	DW	096H
	DW	096H
	DW	096H
	DW	097H
	DW	097H
	DW	097H
	DW	098H
	DW	00H
	DW	098H
	DW	00H
	DW	00H
	DW	098H
	DW	098H
	DW	098H
	DW	099H
	DW	099H
	DW	099H
	DW	09aH
	DW	00H
	DW	09aH
	DW	00H
	DW	00H
	DW	09aH
	DW	09aH
	DW	09aH
	DW	099H
	DW	09bH
	DW	09bH
	DW	09bH
	DW	09cH
	DW	09cH
	DW	09cH
	DW	09dH
	DW	09dH
	DW	09dH
	DW	099H
	DW	099H
	DW	09eH
	DW	09eH
	DW	09eH
	DW	09fH
	DW	00H
	DW	09fH
	DW	00H
	DW	00H
	DW	09fH
	DW	09fH
	DW	09fH
	DW	0a0H
	DW	00H
	DW	0a0H
	DW	00H
	DW	00H
	DW	0a0H
	DW	0a0H
	DW	0a0H
	DW	0a1H
	DW	0a1H
	DW	0a1H
	DW	0a2H
	DW	0a2H
	DW	0a2H
	DW	0a3H
	DW	00H
	DW	0a3H
	DW	00H
	DW	00H
	DW	0a3H
	DW	0a3H
	DW	0a3H
	DW	0a4H
	DW	0a4H
	DW	0a4H
	DW	0a5H
	DW	00H
	DW	0a5H
	DW	00H
	DW	00H
	DW	0a5H
	DW	0a5H
	DW	0a5H
	DW	0a4H
	DW	0a6H
	DW	0a6H
	DW	0a6H
	DW	0a7H
	DW	0a7H
	DW	0a7H
	DW	0aaH
	DW	0aaH
	DW	0aaH
	DW	0a4H
	DW	0a4H
	DW	0abH
	DW	0abH
	DW	0abH
	DW	0adH
	DW	00H
	DW	0adH
	DW	00H
	DW	00H
	DW	0adH
	DW	0adH
	DW	0adH
	DW	0aeH
	DW	0aeH
	DW	0aeH
	DW	0afH
	DW	00H
	DW	0afH
	DW	00H
	DW	00H
	DW	0afH
	DW	0afH
	DW	0afH
	DW	0aeH
	DW	0b0H
	DW	0b0H
	DW	0b0H
	DW	0b1H
	DW	0b1H
	DW	0b1H
	DW	0b2H
	DW	0b2H
	DW	0b2H
	DW	0aeH
	DW	0aeH
	DW	0b3H
	DW	0b3H
	DW	0b3H
	DW	0b4H
	DW	00H
	DW	0b4H
	DW	00H
	DW	00H
	DW	0b4H
	DW	0b4H
	DW	0b4H
	DW	0b5H
	DW	0b5H
	DW	0b5H
	DW	0b6H
	DW	0b6H
	DW	0b6H
	DW	0b7H
	DW	0b7H
	DW	0b7H
	DW	0b8H
	DW	0b8H
	DW	0b8H
	DW	0b9H
	DW	00H
	DW	0b9H
	DW	00H
	DW	00H
	DW	0b9H
	DW	0b9H
	DW	0b9H
	DW	0baH
	DW	0baH
	DW	0baH
	DW	0bbH
	DW	0bbH
	DW	0bbH
	DW	0bcH
	DW	0bcH
	DW	0bcH
	DW	0bdH
	DW	0bdH
	DW	0bdH
	DW	0beH
	DW	0beH
	DW	0beH
	DW	0bfH
	DW	0bfH
	DW	0bfH
	DW	0c0H
	DW	00H
	DW	0c0H
	DW	00H
	DW	00H
	DW	0c0H
	DW	0c0H
	DW	0c0H
	DW	0c1H
	DW	0c1H
	DW	0c1H
	DW	0c2H
	DW	0c2H
	DW	0c2H
	DW	0c6H
	DW	0c6H
	DW	0c6H
	DW	0c7H
	DW	0c7H
	DW	0c7H
	DW	0c8H
	DW	00H
	DW	0c8H
	DW	00H
	DW	00H
	DW	0c8H
	DW	0c8H
	DW	0c8H
	DW	0c9H
	DW	0c9H
	DW	0c9H
	DW	0caH
	DW	0caH
	DW	0caH
	DW	0cbH
	DW	0cbH
	DW	0cbH
	DW	0ccH
	DW	0ccH
	DW	0ccH
	DW	0cdH
	DW	0cdH
	DW	0cdH
	DW	0ceH
	DW	0ceH
	DW	0ceH
	DW	0cfH
	DW	0cfH
	DW	0cfH
	DW	0d0H
	DW	0d0H
	DW	0d0H
	DW	0d4H
	DW	0d4H
	DW	0d4H
	DW	0d5H
	DW	0d5H
	DW	0d5H
	DW	0d8H
	DW	00H
	DW	0d8H
	DW	00H
	DW	0d8H
	DW	0e6H
	DW	0e6H
	DW	0e6H
	DW	00H
	DW	0e6H
	DW	0e7H
	DW	0e7H
	DW	0e7H
	DW	0e7H
	DW	0e7H
	DW	0e7H
	DW	0e8H
	DW	00H
	DW	0e8H
	DW	0e8H
	DW	0e8H
	DW	0e8H
	DW	0e8H
	DW	0e8H
	DW	0e9H
	DW	0e9H
	DW	0e9H
	DW	0eaH
	DW	00H
	DW	0eaH
	DW	00H
	DW	00H
	DW	0eaH
	DW	0ebH
	DW	0ebH
	DW	0ebH
	DW	0ebH
	DW	0ebH
	DW	0ebH
	DW	0ebH
	DW	0ebH
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	DW	0e5H
	ORG $+2
_const_expr_keywords DD FLAT:??_C@_02OAHAJOFD@pi?$AA@
	DD	0116H
	DD	FLAT:??_C@_01KGKMHCOC@e?$AA@
	DD	0117H
	DD	FLAT:??_C@_01JEJKBAGA@g?$AA@
	DD	0118H
	ORG $+4
_datafile_keywords DD FLAT:??_C@_0BA@GIOJPOGN@calculate_in_3d?$AA@
	DD	0891fH
	DD	FLAT:??_C@_0BD@ICOCBELD@vertices_predicted?$AA@
	DD	08918H
	DD	FLAT:??_C@_0BA@EPBHJJLH@edges_predicted?$AA@
	DD	08919H
	DD	FLAT:??_C@_0BB@HJFNDLDG@facets_predicted?$AA@
	DD	0891aH
	DD	FLAT:??_C@_0BB@PCLCALDK@bodies_predicted?$AA@
	DD	0891bH
	DD	FLAT:??_C@_0BF@OBIIONED@facetedges_predicted?$AA@
	DD	0891cH
	DD	FLAT:??_C@_0BF@MMBIFFBD@quantities_predicted?$AA@
	DD	0891dH
	DD	FLAT:??_C@_0BL@GEDNAPDC@method_instances_predicted?$AA@
	DD	0891eH
	DD	FLAT:??_C@_07IJGPCJHC@opacity?$AA@
	DD	0138H
	DD	FLAT:??_C@_0BB@EHCKFCGI@mpi_local_bodies?$AA@
	DD	0298fH
	DD	FLAT:??_C@_0L@PJJPIEAP@clip_coeff?$AA@
	DD	088fdH
	DD	FLAT:??_C@_0M@GOLNCKNL@slice_coeff?$AA@
	DD	088feH
	DD	FLAT:??_C@_0O@KEPICJKL@on_constraint?$AA@
	DD	0245H
	DD	FLAT:??_C@_0P@FJLNFBKF@hit_constraint?$AA@
	DD	0246H
	DD	FLAT:??_C@_0BE@CFDLCAJO@value_of_constraint?$AA@
	DD	0152H
	DD	FLAT:??_C@_0M@CFABBPOL@on_boundary?$AA@
	DD	0247H
	DD	FLAT:??_C@_0M@GPHPDHLO@on_quantity?$AA@
	DD	0248H
	DD	FLAT:??_C@_0BD@DOOANBHL@on_method_instance?$AA@
	DD	0249H
	DD	FLAT:??_C@_0N@BGNGCLLP@content_rank?$AA@
	DD	088b9H
	DD	FLAT:??_C@_0BA@HEFKJKJG@high_constraint?$AA@
	DD	0902H
	DD	FLAT:??_C@_0O@FHDEFNFH@high_boundary?$AA@
	DD	0903H
	DD	FLAT:??_C@_0BB@DAFJNDLH@suppress_warning?$AA@
	DD	0231H
	DD	FLAT:??_C@_0BD@JLBMBNDA@unsuppress_warning?$AA@
	DD	0232H
	DD	FLAT:??_C@_0BD@PDLHDKOI@volume_method_name?$AA@
	DD	088baH
	DD	FLAT:??_C@_0BA@FGAGLOAP@partner_hitting?$AA@
	DD	088bbH
	DD	FLAT:??_C@_09KAGJCBDL@procedure?$AA@
	DD	01e5H
	DD	FLAT:??_C@_0P@OAMDDONM@display_origin?$AA@
	DD	088bcH
	DD	FLAT:??_C@_0BD@LPDEKMFI@length_method_name?$AA@
	DD	088bdH
	DD	FLAT:??_C@_0BB@CNJENMNM@area_method_name?$AA@
	DD	088beH
	DD	FLAT:??_C@_0BO@JLAEKIJE@hessian_special_normal_vector?$AA@
	DD	088bfH
	DD	FLAT:??_C@_0P@NAPIFNOG@keep_originals?$AA@
	DD	088c0H
	DD	FLAT:??_C@_0BA@EFLDDNJL@element_modulus?$AA@
	DD	088c1H
	DD	FLAT:??_C@_0M@GNHLGAPA@swap_colors?$AA@
	DD	088c2H
	DD	FLAT:??_C@_04PJDNGLKJ@self?$AA@
	DD	015bH
	DD	FLAT:??_C@_09GHGMGLNO@conserved?$AA@
	DD	01b7H
	DD	FLAT:??_C@_0O@CFOLDLE@actual_volume?$AA@
	DD	088c3H
	DD	FLAT:??_C@_0M@MGPGBEBP@keep_macros?$AA@
	DD	088c4H
	DD	FLAT:??_C@_06BCKCJHAK@pdelta?$AA@
	DD	01deH
	DD	FLAT:??_C@_0P@EHFNPAFG@on_assign_call?$AA@
	DD	0107H
	DD	FLAT:??_C@_09FFJNLCDE@tolerance?$AA@
	DD	01f0H
	DD	FLAT:??_C@_0BE@MPMEKLIN@lagrange_multiplier?$AA@
	DD	088c5H
	DD	FLAT:??_C@_0BA@DKKLMIEO@evolver_version?$AA@
	DD	088c6H
	DD	FLAT:??_C@_0M@KPMDGEHG@orientation?$AA@
	DD	0199H
	DD	FLAT:??_C@_0BD@IJHNDEKK@ignore_constraints?$AA@
	DD	088c7H
	DD	FLAT:??_C@_0N@DPCDAEDN@ignore_fixed?$AA@
	DD	088c8H
	DD	FLAT:??_C@_0N@KPOPAFCP@load_library?$AA@
	DD	088c9H
	DD	FLAT:??_C@_0BC@KPHKHJOD@interp_bdry_param?$AA@
	DD	088caH
	DD	FLAT:??_C@_0M@BIHLDDLK@axial_point?$AA@
	DD	01b5H
	DD	FLAT:??_C@_08JNKCHLOP@lagrange?$AA@
	DD	01a3H
	DD	FLAT:??_C@_0P@DDMFGHDB@lagrange_order?$AA@
	DD	088cbH
	DD	FLAT:??_C@_0M@LLBEFGDE@parameter_1?$AA@
	DD	088ccH
	DD	FLAT:??_C@_0M@JADJAFPH@parameter_2?$AA@
	DD	08920H
	DD	FLAT:??_C@_0BF@HJFOCADB@optimizing_parameter?$AA@
	DD	088cdH
	DD	FLAT:??_C@_0BF@PCMDHFO@optimising_parameter?$AA@
	DD	088cdH
	DD	FLAT:??_C@_0BG@DMHBIFMB@everything_quantities?$AA@
	DD	088cfH
	DD	FLAT:??_C@_05MFEJDJP@value?$AA@
	DD	01dbH
	DD	FLAT:??_C@_06JJLAMBGK@target?$AA@
	DD	01daH
	DD	FLAT:??_C@_06EPMMJFDC@define?$AA@
	DD	0164H
	DD	FLAT:??_C@_09HGIEBAJ@attribute?$AA@
	DD	016bH
	DD	FLAT:??_C@_0BA@FCDDEKDG@method_instance?$AA@
	DD	01ebH
	DD	FLAT:??_C@_06GABBCIBA@method?$AA@
	DD	088d0H
	DD	FLAT:??_C@_0BB@KCGOMKJL@scalar_integrand?$AA@
	DD	088d1H
	DD	FLAT:??_C@_0BB@CNKNAII@vector_integrand?$AA@
	DD	088d2H
	DD	FLAT:??_C@_0P@HMNODAPJ@k_vector_order?$AA@
	DD	088d3H
	DD	FLAT:??_C@_0P@LNEAGBL@form_integrand?$AA@
	DD	088d4H
	DD	FLAT:??_C@_08DJCKBMBN@mobility?$AA@
	DD	088d5H
	DD	FLAT:??_C@_0BA@LJFNGFOM@mobility_tensor?$AA@
	DD	088d6H
	DD	FLAT:??_C@_04BGEKJPHF@bare?$AA@
	DD	018fH
	DD	FLAT:??_C@_0BD@MOPCCJLG@boundary_curvature?$AA@
	DD	088d7H
	DD	FLAT:??_C@_07CJECEDDG@modulus?$AA@
	DD	01d9H
	DD	FLAT:??_C@_09EMCPFNEA@info_only?$AA@
	DD	01b8H
	DD	FLAT:??_C@_0O@LJFOIPB@global_method?$AA@
	DD	088d8H
	DD	FLAT:??_C@_06FJKEMHGD@global?$AA@
	DD	0224H
	DD	FLAT:??_C@_0L@IDDPHJLO@area_fixed?$AA@
	DD	01c0H
	DD	FLAT:??_C@_0L@HCEEFND@fixed_area?$AA@
	DD	01c0H
	DD	FLAT:??_C@_0M@PIDOJOI@view_matrix?$AA@
	DD	0106H
	DD	FLAT:??_C@_0BA@IFLDONLI@view_transforms?$AA@
	DD	01f4H
	DD	FLAT:??_C@_0BK@PJALNND@view_transform_generators?$AA@
	DD	088d9H
	DD	FLAT:??_C@_09PDIDGCEH@homothety?$AA@
	DD	088daH
	DD	FLAT:??_C@_0BG@CNKFKNKC@approximate_curvature?$AA@
	DD	088dbH
	DD	FLAT:??_C@_0BB@MNCGPOEG@approx_curvature?$AA@
	DD	088dbH
	DD	FLAT:??_C@_09JNGEFCBF@phasefile?$AA@
	DD	088ddH
	DD	FLAT:??_C@_05CBPKLGJM@phase?$AA@
	DD	01f9H
	DD	FLAT:??_C@_07LEJGIFAD@autopop?$AA@
	DD	088deH
	DD	FLAT:??_C@_0BA@KEKJOJEJ@autopop_quartic?$AA@
	DD	088dfH
	DD	FLAT:??_C@_08BLGPIPGP@autochop?$AA@
	DD	0169H
	DD	FLAT:??_C@_0L@OIFGKHMH@total_time?$AA@
	DD	088e0H
	DD	FLAT:??_C@_0P@OMMOBLOA@effective_area?$AA@
	DD	088e1H
	DD	FLAT:??_C@_0M@OBNGAKOC@runge_kutta?$AA@
	DD	088e2H
	DD	FLAT:??_C@_05PEENBMOG@color?$AA@
	DD	0121H
	DD	FLAT:??_C@_09OPNKCLNO@backcolor?$AA@
	DD	01a2H
	DD	FLAT:??_C@_0L@DKEJANLD@frontcolor?$AA@
	DD	019cH
	DD	FLAT:??_C@_0BI@KGGFDDEC@mean_curvature_integral?$AA@
	DD	088e3H
	DD	FLAT:??_C@_0BB@ODBHHAP@normal_curvature?$AA@
	DD	088e4H
	DD	FLAT:??_C@_0BB@OIOLOLOH@square_curvature?$AA@
	DD	088e5H
	DD	FLAT:??_C@_0BC@ODOAEPAL@squared_curvature?$AA@
	DD	088e5H
	DD	FLAT:??_C@_0BK@FKPNCHGB@square_gaussian_curvature?$AA@
	DD	088e7H
	DD	FLAT:??_C@_0BL@MADIBINB@squared_gaussian_curvature?$AA@
	DD	088e7H
	DD	FLAT:??_C@_0BA@MAJEELEA@gauss_curvature?$AA@
	DD	088e9H
	DD	FLAT:??_C@_0BH@KFIJAGHO@insulating_knot_energy?$AA@
	DD	088eaH
	DD	FLAT:??_C@_0BH@PBMPDDPJ@conducting_knot_energy?$AA@
	DD	08902H
	DD	FLAT:??_C@_0BA@NCBBEAIN@space_dimension?$AA@
	DD	088ebH
	DD	FLAT:??_C@_0BC@CCLFHFGM@surface_dimension?$AA@
	DD	088ecH
	DD	FLAT:??_C@_0BH@ELELLFNL@simplex_representation?$AA@
	DD	088edH
	DD	FLAT:??_C@_06BEHJHFJO@metric?$AA@
	DD	088f2H
	DD	FLAT:??_C@_0N@FGNFAGIK@klein_metric?$AA@
	DD	088f1H
	DD	FLAT:??_C@_0BB@HOLKBDMI@conformal_metric?$AA@
	DD	088f0H
	DD	FLAT:??_C@_05OFLEIIDM@fixed?$AA@
	DD	013dH
	DD	FLAT:??_C@_09PFNGBABC@no_refine?$AA@
	DD	01c7H
	DD	FLAT:??_C@_0N@CMIGFPCH@no_transform?$AA@
	DD	01c8H
	DD	FLAT:??_C@_0M@JAGBIOBF@hit_partner?$AA@
	DD	01ccH
	DD	FLAT:??_C@_0N@OFAMNBMC@centerofmass?$AA@
	DD	01c3H
	DD	FLAT:??_C@_0L@ODCODBLD@no_display?$AA@
	DD	01f7H
	DD	FLAT:??_C@_0L@DKEDBIHO@noncontent?$AA@
	DD	01caH
	DD	FLAT:??_C@_06BAJEJFKD@efixed?$AA@
	DD	0890dH
	DD	FLAT:??_C@_0P@GKEDIIHF@symmetry_group?$AA@
	DD	088f3H
	DD	FLAT:??_C@_04NFDDIEML@wrap?$AA@
	DD	0134H
	DD	FLAT:??_C@_05FCPCBJIO@torus?$AA@
	DD	088f4H
	DD	FLAT:??_C@_0N@IGCELFFA@torus_filled?$AA@
	DD	088f5H
	DD	FLAT:??_C@_0O@IMAKABFD@torus_periods?$AA@
	DD	0124H
	DD	FLAT:??_C@_07BFECMFCO@periods?$AA@
	DD	088fbH
	DD	FLAT:??_C@_0BA@HCKIGAAA@display_periods?$AA@
	DD	088fcH
	DD	FLAT:??_C@_06ICGJLFIM@string?$AA@
	DD	01c9H
	DD	FLAT:??_C@_08DODCPBAM@soapfilm?$AA@
	DD	088f6H
	DD	FLAT:??_C@_05GHCFDPJC@wulff?$AA@
	DD	088faH
	DD	FLAT:??_C@_08KIKGFOKI@boundary?$AA@
	DD	0198H
	DD	FLAT:??_C@_0L@PABKJGNF@boundaries?$AA@
	DD	0198H
	DD	FLAT:??_C@_0L@HOHHMJMM@constraint?$AA@
	DD	0140H
	DD	FLAT:??_C@_0M@JGLONDGH@constraints?$AA@
	DD	0140H
	DD	FLAT:??_C@_0P@LFIPMAJA@surface_energy?$AA@
	DD	08900H
	DD	FLAT:??_C@_07LHCFJCJM@formula?$AA@
	DD	01acH
	DD	FLAT:??_C@_08HFFPPCHF@function?$AA@
	DD	01acH
	DD	FLAT:??_C@_09DAGAJHIH@parameter?$AA@
	DD	088ffH
	DD	FLAT:??_C@_0L@HHPOFMCB@parameters?$AA@
	DD	088ffH
	DD	FLAT:??_C@_0P@EAADGFKM@parameter_file?$AA@
	DD	08911H
	DD	FLAT:??_C@_0BC@COAHFEML@symmetric_content?$AA@
	DD	088f8H
	DD	FLAT:??_C@_0P@JOOJGKKP@integral_order?$AA@
	DD	066aH
	DD	FLAT:??_C@_0BC@CDLGPNMC@integral_order_1d?$AA@
	DD	0731H
	DD	FLAT:??_C@_0BC@CBPAEDJL@integral_order_2d?$AA@
	DD	0732H
	DD	FLAT:??_C@_0BC@CCICJAIC@integration_order?$AA@
	DD	066aH
	DD	FLAT:??_C@_0BF@CHBAJJCK@integration_order_1d?$AA@
	DD	0731H
	DD	FLAT:??_C@_0BF@CFFGCHHD@integration_order_2d?$AA@
	DD	0732H
	DD	FLAT:??_C@_0BF@MOILGEJM@constraint_tolerance?$AA@
	DD	08906H
	DD	FLAT:??_C@_06OAMDAHCP@convex?$AA@
	DD	08912H
	DD	FLAT:??_C@_07FAFBHKGP@nonwall?$AA@
	DD	08913H
	DD	FLAT:??_C@_0M@MKNCPPEA@nonnegative?$AA@
	DD	0184H
	DD	FLAT:??_C@_0M@EANCEANL@nonpositive?$AA@
	DD	0183H
	DD	FLAT:??_C@_06FJKEMHGD@global?$AA@
	DD	0224H
	DD	FLAT:??_C@_06KKGCKCNJ@energy?$AA@
	DD	01b6H
	DD	FLAT:??_C@_07ICAJMOAO@content?$AA@
	DD	08916H
	DD	FLAT:??_C@_09NDEBDKFB@quadratic?$AA@
	DD	017cH
	DD	FLAT:??_C@_06HPJICMPM@linear?$AA@
	DD	017bH
	DD	FLAT:??_C@_0BD@JAENIDNE@area_normalization?$AA@
	DD	088f9H
	DD	FLAT:??_C@_06LGAKKEPJ@jiggle?$AA@
	DD	01f3H
	DD	FLAT:??_C@_09NBBNKAEP@diffusion?$AA@
	DD	017eH
	DD	FLAT:??_C@_0N@OMNDKHGB@merit_factor?$AA@
	DD	08907H
	DD	FLAT:??_C@_0BB@LFLMFBL@gravity_constant?$AA@
	DD	08908H
	DD	FLAT:??_C@_0BA@CNIKOEML@spring_constant?$AA@
	DD	08909H
	DD	FLAT:??_C@_0N@DKAJABDK@gap_constant?$AA@
	DD	01dfH
	DD	FLAT:??_C@_05MHMEBBGO@scale?$AA@
	DD	0194H
	DD	FLAT:??_C@_06HACLPJI@pscale?$AA@
	DD	0195H
	DD	FLAT:??_C@_0M@GJEHHDCL@temperature?$AA@
	DD	0890aH
	DD	FLAT:??_C@_08POHEELCJ@pressure?$AA@
	DD	013fH
	DD	FLAT:??_C@_06EMCPHFGM@volume?$AA@
	DD	012eH
	DD	FLAT:??_C@_07HAFFKDBK@density?$AA@
	DD	013eH
	DD	FLAT:??_C@_07BJBOFKDG@tension?$AA@
	DD	013eH
	DD	FLAT:??_C@_09KIHCPOPL@nodisplay?$AA@
	DD	01f7H
	DD	FLAT:??_C@_0M@PJCBAJEM@scale_limit?$AA@
	DD	08903H
	DD	FLAT:??_C@_0M@JBIJOPDG@zoom_vertex?$AA@
	DD	08905H
	DD	FLAT:??_C@_0M@EMFGBOOI@zoom_radius?$AA@
	DD	08904H
	DD	FLAT:??_C@_08OCNIHGPN@quantity?$AA@
	DD	01e2H
	DD	FLAT:??_C@_08IMINLCCL@volconst?$AA@
	DD	0123H
	DD	FLAT:??_C@_04POLDLDMI@read?$AA@
	DD	0156H
	DD	FLAT:??_C@_03BOPJPIAM@and?$AA@
	DD	023fH
	DD	FLAT:??_C@_02FODMLBIE@or?$AA@
	DD	023eH
	DD	FLAT:??_C@_03NJKJADM@not?$AA@
	DD	0240H
	DD	FLAT:??_C@_03FFONCNID@mod?$AA@
	DD	025H
	DD	FLAT:??_C@_04CGKJBALO@imod?$AA@
	DD	024aH
	DD	FLAT:??_C@_04CHNIFDFF@idiv?$AA@
	DD	024cH
	DD	FLAT:??_C@_0M@CBIPACOJ@dot_product?$AA@
	DD	024bH
	DD	FLAT:??_C@_02OAHAJOFD@pi?$AA@
	DD	0116H
	DD	FLAT:??_C@_01KGKMHCOC@e?$AA@
	DD	0117H
	DD	FLAT:??_C@_01JEJKBAGA@g?$AA@
	DD	0118H
	DD	FLAT:??_C@_08LAAABFKN@original?$AA@
	DD	0132H
	DD	FLAT:??_C@_08BOLPBPCL@vertices?$AA@
	DD	0125H
	DD	FLAT:??_C@_06HLKHCFCI@vertex?$AA@
	DD	0125H
	DD	FLAT:??_C@_05JGEJPNHM@edges?$AA@
	DD	0126H
	DD	FLAT:??_C@_04IJFJNCMM@edge?$AA@
	DD	0126H
	DD	FLAT:??_C@_05FHFPJHPF@faces?$AA@
	DD	0890eH
	DD	FLAT:??_C@_04POCOPAPC@face?$AA@
	DD	0890eH
	DD	FLAT:??_C@_06MMNNGFLE@facets?$AA@
	DD	0890eH
	DD	FLAT:??_C@_05BIBOABDC@facet?$AA@
	DD	0890eH
	DD	FLAT:??_C@_06OHIKIKDI@bodies?$AA@
	DD	0128H
	DD	FLAT:??_C@_04IEJGKNJ@body?$AA@
	DD	0128H
	DD	FLAT:??_C@_0M@NLMIGHAM@facet_edges?$AA@
	DD	0133H
	DD	FLAT:??_C@_0L@LKKCPKKM@facet_edge?$AA@
	DD	0133H
	DD	FLAT:??_C@_0L@CPIKDJIA@facetedges?$AA@
	DD	0133H
	DD	FLAT:??_C@_09CMEJCHLK@facetedge?$AA@
	DD	0133H
_mathfunc_keywords DD FLAT:??_C@_0N@CCAKCFDI@wrap_inverse?$AA@
	DD	02797H
	DD	FLAT:??_C@_09BAMEIGDP@ellipticK?$AA@
	DD	027acH
	DD	FLAT:??_C@_09IOEHKLLB@ellipticE?$AA@
	DD	027adH
	DD	FLAT:??_C@_03MGHMBJCF@log?$AA@
	DD	027a8H
	DD	FLAT:??_C@_03KHJOGHMM@exp?$AA@
	DD	027a1H
	DD	FLAT:??_C@_03BLEJJJBH@sin?$AA@
	DD	0279eH
	DD	FLAT:??_C@_03LALBNOCG@cos?$AA@
	DD	0279fH
	DD	FLAT:??_C@_03IIINPABG@tan?$AA@
	DD	027a0H
	DD	FLAT:??_C@_04FIHNOPOL@asin?$AA@
	DD	027a9H
	DD	FLAT:??_C@_04PDIFKINK@acos?$AA@
	DD	027aaH
	DD	FLAT:??_C@_04MLLJIGOK@atan?$AA@
	DD	027abH
	DD	FLAT:??_C@_04COOMCNPB@sinh?$AA@
	DD	027a2H
	DD	FLAT:??_C@_04HPJJNFIM@cosh?$AA@
	DD	027a3H
	DD	FLAT:??_C@_04FJHINJAO@tanh?$AA@
	DD	027a4H
	DD	FLAT:??_C@_05JKKEKHLA@asinh?$AA@
	DD	027a5H
	DD	FLAT:??_C@_05MLNBFPMN@acosh?$AA@
	DD	027a6H
	DD	FLAT:??_C@_05ONDAFDEP@atanh?$AA@
	DD	027a7H
	DD	FLAT:??_C@_04EIAKFFMI@sqrt?$AA@
	DD	0279aH
	DD	FLAT:??_C@_03OPALDGIC@sqr?$AA@
	DD	02799H
	DD	FLAT:??_C@_04GFPJNGEK@ceil?$AA@
	DD	0279bH
	DD	FLAT:??_C@_05PBJFFIGL@floor?$AA@
	DD	0279cH
	DD	FLAT:??_C@_03BCGAIFPO@abs?$AA@
	DD	0279dH
_mathfunc2_keywords DD FLAT:??_C@_0N@HGNPFHKM@wrap_compose?$AA@
	DD	02796H
	DD	FLAT:??_C@_05KNGEOGJB@atan2?$AA@
	DD	02798H
	DD	FLAT:??_C@_0BE@BDGHAKDJ@incompleteEllipticF?$AA@
	DD	027aeH
	DD	FLAT:??_C@_0BE@DIEKFJPK@incompleteEllipticE?$AA@
	DD	027afH
	DD	FLAT:??_C@_07MEIENILC@maximum?$AA@
	DD	02794H
	DD	FLAT:??_C@_07CCOEHHFD@minimum?$AA@
	DD	02795H
	DD	FLAT:??_C@_03JGHBODFD@pow?$AA@
	DD	02793H
_command_keywords DD FLAT:??_C@_06IKLLLDHL@normal?$AA@
	DD	012bH
	DD	FLAT:??_C@_0M@MKNCPPEA@nonnegative?$AA@
	DD	0184H
	DD	FLAT:??_C@_0M@EANCEANL@nonpositive?$AA@
	DD	0183H
	DD	FLAT:??_C@_0O@KIAILNPN@normal_vector?$AA@
	DD	0168H
	DD	FLAT:??_C@_07IAPJLEJH@no_dump?$AA@
	DD	013bH
	DD	FLAT:??_C@_0L@LJPKPJJM@p_velocity?$AA@
	DD	01fdH
	DD	FLAT:??_C@_07LFPCKGAP@p_force?$AA@
	DD	01fcH
	DD	FLAT:??_C@_0BC@KBMGOFNF@no_hessian_normal?$AA@
	DD	0176H
	DD	FLAT:??_C@_0BC@NBLIDMLB@make_thread_lists?$AA@
	DD	0239H
	DD	FLAT:??_C@_0P@KJENOODO@facet_crosscut?$AA@
	DD	01d8H
	DD	FLAT:??_C@_07LDNKKEH@detorus?$AA@
	DD	0238H
	DD	FLAT:??_C@_0O@KPBBKELJ@is_constraint?$AA@
	DD	0111H
	DD	FLAT:??_C@_0BB@CNFDAFCL@valid_constraint?$AA@
	DD	0234H
	DD	FLAT:??_C@_0P@CFKICEKD@valid_boundary?$AA@
	DD	0235H
	DD	FLAT:??_C@_09IICGFFJH@profiling?$AA@
	DD	0237H
	DD	FLAT:??_C@_0BA@OHLAHHBM@reset_profiling?$AA@
	DD	0233H
	DD	FLAT:??_C@_0BB@DAFJNDLH@suppress_warning?$AA@
	DD	0231H
	DD	FLAT:??_C@_0BD@JLBMBNDA@unsuppress_warning?$AA@
	DD	0232H
	DD	FLAT:??_C@_0M@EOIFPGKG@delete_text?$AA@
	DD	0230H
	DD	FLAT:??_C@_0N@CJJGNHCN@display_text?$AA@
	DD	022fH
	DD	FLAT:??_C@_0O@ECJLFEKE@simplex_to_fe?$AA@
	DD	022dH
	DD	FLAT:??_C@_07BNADNHKE@addload?$AA@
	DD	022cH
	DD	FLAT:??_C@_0N@OJACEENF@replace_load?$AA@
	DD	022eH
	DD	FLAT:??_C@_08DHCGNBAN@whereami?$AA@
	DD	022bH
	DD	FLAT:??_C@_0L@LCAMEHJC@breakpoint?$AA@
	DD	022aH
	DD	FLAT:??_C@_0M@BKKBNEBK@breakpoints?$AA@
	DD	022aH
	DD	FLAT:??_C@_05BBAEEBBH@abort?$AA@
	DD	0229H
	DD	FLAT:??_C@_0L@KHFNHBNM@subcommand?$AA@
	DD	0228H
	DD	FLAT:??_C@_06FJKEMHGD@global?$AA@
	DD	0224H
	DD	FLAT:??_C@_0M@PLKJAEAL@repartition?$AA@
	DD	0221H
	DD	FLAT:??_C@_0O@OKPNNEJG@free_discards?$AA@
	DD	0220H
	DD	FLAT:??_C@_0N@GDMIKNMD@dump_memlist?$AA@
	DD	021fH
	DD	FLAT:??_C@_0BE@KCPFLFEG@reverse_orientation?$AA@
	DD	021bH
	DD	FLAT:??_C@_0BA@JNPAPNBO@matrix_multiply?$AA@
	DD	021cH
	DD	FLAT:??_C@_0P@EBJBPEJC@matrix_inverse?$AA@
	DD	021dH
	DD	FLAT:??_C@_0BD@JJNPEKJD@matrix_determinant?$AA@
	DD	0227H
	DD	FLAT:??_C@_08EJNLDOMI@mid_edge?$AA@
	DD	0216H
	DD	FLAT:??_C@_09BPLDEHMH@mid_facet?$AA@
	DD	0217H
	DD	FLAT:??_C@_0N@HEKOHBEK@flush_counts?$AA@
	DD	0167H
	DD	FLAT:??_C@_0O@HEMOCGDL@valid_element?$AA@
	DD	0215H
	DD	FLAT:??_C@_0N@BFEIANBO@reset_counts?$AA@
	DD	0214H
	DD	FLAT:??_C@_0N@MOMHNGJF@vertex_merge?$AA@
	DD	0213H
	DD	FLAT:??_C@_0L@GJPPMFGG@edge_merge?$AA@
	DD	0211H
	DD	FLAT:??_C@_0M@HCCAAKMF@facet_merge?$AA@
	DD	0212H
	DD	FLAT:??_C@_08KEAKBNCK@mpi_task?$AA@
	DD	020fH
	DD	FLAT:??_C@_0P@FKOPBMAL@mean_curvature?$AA@
	DD	0223H
	DD	FLAT:??_C@_0BA@EFLDDNJL@element_modulus?$AA@
	DD	088c1H
	DD	FLAT:??_C@_0BD@IJHNDEKK@ignore_constraints?$AA@
	DD	088c7H
	DD	FLAT:??_C@_0N@DPCDAEDN@ignore_fixed?$AA@
	DD	088c8H
	DD	FLAT:??_C@_0O@LJFOIPB@global_method?$AA@
	DD	088d8H
	DD	FLAT:??_C@_0BB@KCGOMKJL@scalar_integrand?$AA@
	DD	088d1H
	DD	FLAT:??_C@_0BB@CNKNAII@vector_integrand?$AA@
	DD	088d2H
	DD	FLAT:??_C@_0P@HMNODAPJ@k_vector_order?$AA@
	DD	088d3H
	DD	FLAT:??_C@_0P@LNEAGBL@form_integrand?$AA@
	DD	088d4H
	DD	FLAT:??_C@_09EMCPFNEA@info_only?$AA@
	DD	01b8H
	DD	FLAT:??_C@_06GABBCIBA@method?$AA@
	DD	088d0H
	DD	FLAT:??_C@_0O@OJLJIFPG@parallel_exec?$AA@
	DD	01a7H
	DD	FLAT:??_C@_09BOMFCCD@task_exec?$AA@
	DD	019fH
	DD	FLAT:??_C@_03NJDAHFJE@pop?$AA@
	DD	016fH
	DD	FLAT:??_C@_0BA@HKCODAC@pop_tri_to_edge?$AA@
	DD	020aH
	DD	FLAT:??_C@_0BA@LLOFFOFA@pop_edge_to_tri?$AA@
	DD	020bH
	DD	FLAT:??_C@_0BB@NFBBDANK@pop_quad_to_quad?$AA@
	DD	020cH
	DD	FLAT:??_C@_05IDKHKMLA@local?$AA@
	DD	01b2H
	DD	FLAT:??_C@_03JOHEBPFF@for?$AA@
	DD	01cbH
	DD	FLAT:??_C@_0BB@FIMKOPGK@warning_messages?$AA@
	DD	01c2H
	DD	FLAT:??_C@_0N@PBJCFAJD@equiangulate?$AA@
	DD	01bdH
	DD	FLAT:??_C@_09PFNGBABC@no_refine?$AA@
	DD	01c7H
	DD	FLAT:??_C@_0N@CMIGFPCH@no_transform?$AA@
	DD	01c8H
	DD	FLAT:??_C@_0M@JAGBIOBF@hit_partner?$AA@
	DD	01ccH
	DD	FLAT:??_C@_0N@OFAMNBMC@centerofmass?$AA@
	DD	01c3H
	DD	FLAT:??_C@_0L@ODCODBLD@no_display?$AA@
	DD	01f7H
	DD	FLAT:??_C@_0N@ICOOBCNI@vertexnormal?$AA@
	DD	016eH
	DD	FLAT:??_C@_09BADENEHP@colorfile?$AA@
	DD	01cfH
	DD	FLAT:??_C@_0O@DICBBEEI@date_and_time?$AA@
	DD	01b1H
	DD	FLAT:??_C@_0BA@DKKLMIEO@evolver_version?$AA@
	DD	017dH
	DD	FLAT:??_C@_07BKFFEMDK@exprint?$AA@
	DD	01adH
	DD	FLAT:??_C@_06KKGCKCNJ@energy?$AA@
	DD	01b6H
	DD	FLAT:??_C@_09EMCPFNEA@info_only?$AA@
	DD	01b8H
	DD	FLAT:??_C@_09GHGMGLNO@conserved?$AA@
	DD	01b7H
	DD	FLAT:??_C@_04MGEIEJAD@exec?$AA@
	DD	0175H
	DD	FLAT:??_C@_0M@CJACPCIB@wrap_vertex?$AA@
	DD	01afH
	DD	FLAT:??_C@_04PJDNGLKJ@self?$AA@
	DD	015bH
	DD	FLAT:??_C@_0L@FMKAEFLC@is_defined?$AA@
	DD	01f6H
	DD	FLAT:??_C@_09KIHCPOPL@nodisplay?$AA@
	DD	01f7H
	DD	FLAT:??_C@_0L@ODCODBLD@no_display?$AA@
	DD	01f7H
	DD	FLAT:??_C@_08HFFPPCHF@function?$AA@
	DD	01acH
	DD	FLAT:??_C@_0BA@PJJKCDON@reorder_storage?$AA@
	DD	0205H
	DD	FLAT:??_C@_0N@JJMKEIGG@renumber_all?$AA@
	DD	0206H
	DD	FLAT:??_C@_05PDJBBECF@pause?$AA@
	DD	0151H
	DD	FLAT:??_C@_06BCKCJHAK@pdelta?$AA@
	DD	01deH
	DD	FLAT:??_C@_0P@EHFNPAFG@on_assign_call?$AA@
	DD	0107H
	DD	FLAT:??_C@_06HACLPJI@pscale?$AA@
	DD	0195H
	DD	FLAT:??_C@_05MHMEBBGO@scale?$AA@
	DD	0194H
	DD	FLAT:??_C@_09FFJNLCDE@tolerance?$AA@
	DD	01f0H
	DD	FLAT:??_C@_0BA@FCDDEKDG@method_instance?$AA@
	DD	01ebH
	DD	FLAT:??_C@_07HMINABEO@logfile?$AA@
	DD	0115H
	DD	FLAT:??_C@_0L@GKBDMEAN@keylogfile?$AA@
	DD	0193H
	DD	FLAT:??_C@_09GNLMKAKO@frontbody?$AA@
	DD	01cdH
	DD	FLAT:??_C@_08JONLCJIM@backbody?$AA@
	DD	01ceH
	DD	FLAT:??_C@_0L@KAOEHGMG@new_vertex?$AA@
	DD	01d5H
	DD	FLAT:??_C@_08HBMPJBBB@new_edge?$AA@
	DD	01d6H
	DD	FLAT:??_C@_09OAIEDJBI@new_facet?$AA@
	DD	01d7H
	DD	FLAT:??_C@_08PANPCJAE@new_body?$AA@
	DD	01ddH
	DD	FLAT:??_C@_0L@DKEDBIHO@noncontent?$AA@
	DD	01caH
	DD	FLAT:??_C@_06LNOFJDNM@return?$AA@
	DD	01a4H
	DD	FLAT:??_C@_0L@CCPMELKB@postscript?$AA@
	DD	012aH
	DD	FLAT:??_C@_08KLNLDNLL@ooglfile?$AA@
	DD	01a6H
	DD	FLAT:??_C@_0BA@IBDAIKBO@binary_off_file?$AA@
	DD	01a8H
	DD	FLAT:??_C@_0P@OLMKLKE@vertex_average?$AA@
	DD	01eaH
	DD	FLAT:??_C@_0BD@FBBKFDM@raw_vertex_average?$AA@
	DD	01ecH
	DD	FLAT:??_C@_0BG@EBKCCFDE@rawest_vertex_average?$AA@
	DD	01f1H
	DD	FLAT:??_C@_0M@BIHLDDLK@axial_point?$AA@
	DD	01b5H
	DD	FLAT:??_C@_0N@GAAHAAOL@metis_factor?$AA@
	DD	01abH
	DD	FLAT:??_C@_08JNKCHLOP@lagrange?$AA@
	DD	01a3H
	DD	FLAT:??_C@_05MMMFHLE@metis?$AA@
	DD	0191H
	DD	FLAT:??_C@_0P@BEHGJJCH@metis_readjust?$AA@
	DD	0222H
	DD	FLAT:??_C@_0L@JJNAPELC@body_metis?$AA@
	DD	021aH
	DD	FLAT:??_C@_06KJNDDBHG@kmetis?$AA@
	DD	0192H
	DD	FLAT:??_C@_06FNJMBFGF@ometis?$AA@
	DD	019aH
	DD	FLAT:??_C@_06FPFOALMG@sizeof?$AA@
	DD	018dH
	DD	FLAT:??_C@_04HDMMNHEL@move?$AA@
	DD	016dH
	DD	FLAT:??_C@_08IDOMCGJP@geompipe?$AA@
	DD	015aH
	DD	FLAT:??_C@_0BG@LAOGOOCK@convert_to_quantities?$AA@
	DD	01aaH
	DD	FLAT:??_C@_08GDDLLHKC@edgeswap?$AA@
	DD	014aH
	DD	FLAT:??_C@_0M@HIFAJGPB@t1_edgeswap?$AA@
	DD	0210H
	DD	FLAT:??_C@_05ELPHFHOI@break?$AA@
	DD	018bH
	DD	FLAT:??_C@_08HEBLBDOI@volfixed?$AA@
	DD	011dH
	DD	FLAT:??_C@_08DLICDMBN@continue?$AA@
	DD	018cH
	DD	FLAT:??_C@_08IMINLCCL@volconst?$AA@
	DD	0123H
	DD	FLAT:??_C@_04HKMJFCDE@ritz?$AA@
	DD	016cH
	DD	FLAT:??_C@_0M@KPMDGEHG@orientation?$AA@
	DD	0199H
	DD	FLAT:??_C@_0L@FLCFPHEO@eigenprobe?$AA@
	DD	0174H
	DD	FLAT:??_C@_07JPCPFHFE@lanczos?$AA@
	DD	0173H
	DD	FLAT:??_C@_0M@DFLKEBKH@tetra_point?$AA@
	DD	0171H
	DD	FLAT:??_C@_0N@DHNCNHBM@triple_point?$AA@
	DD	0172H
	DD	FLAT:??_C@_05MFEJDJP@value?$AA@
	DD	01dbH
	DD	FLAT:??_C@_06JJLAMBGK@target?$AA@
	DD	01daH
	DD	FLAT:??_C@_0N@PEAHACPA@datafilename?$AA@
	DD	0114H
	DD	FLAT:??_C@_08GOLFMCHH@geomview?$AA@
	DD	0105H
	DD	FLAT:??_C@_06PNAKCKLH@saddle?$AA@
	DD	013aH
	DD	FLAT:??_C@_04CIOKLOBL@midv?$AA@
	DD	0113H
	DD	FLAT:??_C@_06EPMMJFDC@define?$AA@
	DD	0164H
	DD	FLAT:??_C@_09HGIEBAJ@attribute?$AA@
	DD	016bH
	DD	FLAT:??_C@_0L@HNMJPKNA@attributes?$AA@
	DD	016bH
	DD	FLAT:??_C@_06ICGJLFIM@string?$AA@
	DD	01c9H
	DD	FLAT:??_C@_07NNCLFLCE@sobolev?$AA@
	DD	0200H
	DD	FLAT:??_C@_0N@KPIEIPJP@sobolev_seek?$AA@
	DD	0202H
	DD	FLAT:??_C@_09JHHPCHFN@dirichlet?$AA@
	DD	01ffH
	DD	FLAT:??_C@_0P@BLIMDDOG@dirichlet_seek?$AA@
	DD	0203H
	DD	FLAT:??_C@_04NFDDIEML@wrap?$AA@
	DD	0134H
	DD	FLAT:??_C@_05KBOMEDGA@total?$AA@
	DD	011bH
	DD	FLAT:??_C@_07MMNEDCBK@history?$AA@
	DD	0104H
	DD	FLAT:??_C@_03GABGILGN@fix?$AA@
	DD	014cH
	DD	FLAT:??_C@_05INHNKAIM@unfix?$AA@
	DD	014dH
	DD	FLAT:??_C@_04BGEKJPHF@bare?$AA@
	DD	018fH
	DD	FLAT:??_C@_05CBPKLGJM@phase?$AA@
	DD	01f9H
	DD	FLAT:??_C@_07ICLAOFOB@foreach?$AA@
	DD	01bbH
	DD	FLAT:??_C@_06HAMJBNFB@rebody?$AA@
	DD	0197H
	DD	FLAT:??_C@_08GHINPAG@burchard?$AA@
	DD	0196H
	DD	FLAT:??_C@_0L@HANDHNGN@close_show?$AA@
	DD	01f5H
	DD	FLAT:??_C@_08BOPEGKMG@show_off?$AA@
	DD	01f5H
	DD	FLAT:??_C@_0BA@IPCFDLJD@transform_depth?$AA@
	DD	0180H
	DD	FLAT:??_C@_0P@MKIFIEMC@transform_expr?$AA@
	DD	018eH
	DD	FLAT:??_C@_07CJECEDDG@modulus?$AA@
	DD	01d9H
	DD	FLAT:??_C@_08KIKGFOKI@boundary?$AA@
	DD	0198H
	DD	FLAT:??_C@_0O@KEPICJKL@on_constraint?$AA@
	DD	0245H
	DD	FLAT:??_C@_0P@FJLNFBKF@hit_constraint?$AA@
	DD	0246H
	DD	FLAT:??_C@_0BE@CFDLCAJO@value_of_constraint?$AA@
	DD	0152H
	DD	FLAT:??_C@_0M@CFABBPOL@on_boundary?$AA@
	DD	0247H
	DD	FLAT:??_C@_0M@GPHPDHLO@on_quantity?$AA@
	DD	0248H
	DD	FLAT:??_C@_0BD@DOOANBHL@on_method_instance?$AA@
	DD	0249H
	DD	FLAT:??_C@_07IHNMECBN@hessian?$AA@
	DD	0122H
	DD	FLAT:??_C@_0N@NOHLJNPG@hessian_seek?$AA@
	DD	0204H
	DD	FLAT:??_C@_0N@NJLPGECL@hessian_menu?$AA@
	DD	0129H
	DD	FLAT:??_C@_04PCJFHION@help?$AA@
	DD	01e9H
	DD	FLAT:??_C@_04KNNLNNGO@quit?$AA@
	DD	01c1H
	DD	FLAT:??_C@_04MKNBDEPB@exit?$AA@
	DD	01c1H
	DD	FLAT:??_C@_03MDONDFG@bye?$AA@
	DD	01c1H
	DD	FLAT:??_C@_04GGLOKIEE@dump?$AA@
	DD	01e0H
	DD	FLAT:??_C@_04EONOHKEP@load?$AA@
	DD	01e3H
	DD	FLAT:??_C@_08MJMACJHA@permload?$AA@
	DD	01e8H
	DD	FLAT:??_C@_08OCNIHGPN@quantity?$AA@
	DD	01e2H
	DD	FLAT:??_C@_0BA@CNIKOEML@spring_constant?$AA@
	DD	01dfH
	DD	FLAT:??_C@_0N@DKAJABDK@gap_constant?$AA@
	DD	01dfH
	DD	FLAT:??_C@_05GEEJHDPH@notch?$AA@
	DD	01e1H
	DD	FLAT:??_C@_05OODBEKIG@while?$AA@
	DD	01c5H
	DD	FLAT:??_C@_02KNAFDCHJ@do?$AA@
	DD	01c6H
	DD	FLAT:??_C@_02HEBPBKGD@if?$AA@
	DD	01c4H
	DD	FLAT:??_C@_04HOHPNOOD@then?$AA@
	DD	023cH
	DD	FLAT:??_C@_04FHMCPBIP@else?$AA@
	DD	023dH
	DD	FLAT:??_C@_09JOLNEMIB@histogram?$AA@
	DD	01beH
	DD	FLAT:??_C@_0N@MFCDHBBC@loghistogram?$AA@
	DD	01bfH
	DD	FLAT:??_C@_09INMNGPFE@show_expr?$AA@
	DD	01b3H
	DD	FLAT:??_C@_0L@BHDKNBMG@show_trans?$AA@
	DD	01b4H
	DD	FLAT:??_C@_08BKGECACE@dihedral?$AA@
	DD	01aeH
	DD	FLAT:??_C@_03LJAEFNNE@max?$AA@
	DD	0186H
	DD	FLAT:??_C@_03KLIPLJLL@min?$AA@
	DD	0187H
	DD	FLAT:??_C@_03CHOBFJAH@avg?$AA@
	DD	018aH
	DD	FLAT:??_C@_03CFFIJAMA@sum?$AA@
	DD	0189H
	DD	FLAT:??_C@_05IOMEMJEC@count?$AA@
	DD	0188H
	DD	FLAT:??_C@_05IJDJACGD@print?$AA@
	DD	0185H
	DD	FLAT:??_C@_06HMBJBPPM@eprint?$AA@
	DD	024eH
	DD	FLAT:??_C@_06OHJFMFMB@printf?$AA@
	DD	0181H
	DD	FLAT:??_C@_09JOJNMAED@errprintf?$AA@
	DD	0182H
	DD	FLAT:??_C@_07DNAEFDKF@sprintf?$AA@
	DD	01a9H
	DD	FLAT:??_C@_0O@DNBEMPOF@binary_printf?$AA@
	DD	021eH
	DD	FLAT:??_C@_0L@LFLJKKDA@procedures?$AA@
	DD	020eH
	DD	FLAT:??_C@_09KAGJCBDL@procedure?$AA@
	DD	01e5H
	DD	FLAT:??_C@_02LIELOMNJ@on?$AA@
	DD	0158H
	DD	FLAT:??_C@_06JMEOMOEA@counts?$AA@
	DD	015fH
	DD	FLAT:??_C@_0M@MMGMMHEK@extrapolate?$AA@
	DD	017fH
	DD	FLAT:??_C@_03MCADLMAF@off?$AA@
	DD	0159H
	DD	FLAT:??_C@_08KODKMLGA@areaweed?$AA@
	DD	0177H
	DD	FLAT:??_C@_08EFAMPBPP@edgeweed?$AA@
	DD	0178H
	DD	FLAT:??_C@_0M@EKPFJKCG@edge_divide?$AA@
	DD	017aH
	DD	FLAT:??_C@_05MFGCEKPN@alice?$AA@
	DD	0162H
	DD	FLAT:??_C@_0P@HKDMGBBG@stability_test?$AA@
	DD	0163H
	DD	FLAT:??_C@_04HKCCIOCO@zoom?$AA@
	DD	0157H
	DD	FLAT:??_C@_05IJMOJOL@utest?$AA@
	DD	016aH
	DD	FLAT:??_C@_06FHFOAHML@system?$AA@
	DD	0170H
	DD	FLAT:??_C@_05IHFEJEKL@chdir?$AA@
	DD	0160H
	DD	FLAT:??_C@_05CDBKKPFJ@longj?$AA@
	DD	015dH
	DD	FLAT:??_C@_04BBIOILIO@rawv?$AA@
	DD	015eH
	DD	FLAT:??_C@_07ENILCFOA@rawestv?$AA@
	DD	01a0H
	DD	FLAT:??_C@_02KPEDIMCA@go?$AA@
	DD	0153H
	DD	FLAT:??_C@_06ELMCDMMG@refine?$AA@
	DD	0147H
	DD	FLAT:??_C@_05KJHPNPAA@check?$AA@
	DD	0155H
	DD	FLAT:??_C@_08MGNLKBNG@show_vol?$AA@
	DD	0154H
	DD	FLAT:??_C@_02EGCJHIOB@id?$AA@
	DD	012fH
	DD	FLAT:??_C@_03PLGJJJLK@oid?$AA@
	DD	0130H
	DD	FLAT:??_C@_03BOPJPIAM@and?$AA@
	DD	023fH
	DD	FLAT:??_C@_02FODMLBIE@or?$AA@
	DD	023eH
	DD	FLAT:??_C@_03NJKJADM@not?$AA@
	DD	0240H
	DD	FLAT:??_C@_03FFONCNID@mod?$AA@
	DD	025H
	DD	FLAT:??_C@_04CGKJBALO@imod?$AA@
	DD	024aH
	DD	FLAT:??_C@_04CHNIFDFF@idiv?$AA@
	DD	024cH
	DD	FLAT:??_C@_0M@CBIPACOJ@dot_product?$AA@
	DD	024bH
	DD	FLAT:??_C@_02OAHAJOFD@pi?$AA@
	DD	0116H
	DD	FLAT:??_C@_01KGKMHCOC@e?$AA@
	DD	0117H
	DD	FLAT:??_C@_01JEJKBAGA@g?$AA@
	DD	0118H
	DD	FLAT:??_C@_08LAAABFKN@original?$AA@
	DD	0132H
	DD	FLAT:??_C@_05OFLEIIDM@fixed?$AA@
	DD	013dH
	DD	FLAT:??_C@_08BOLPBPCL@vertices?$AA@
	DD	0125H
	DD	FLAT:??_C@_06HLKHCFCI@vertex?$AA@
	DD	0125H
	DD	FLAT:??_C@_05JGEJPNHM@edges?$AA@
	DD	0126H
	DD	FLAT:??_C@_04IJFJNCMM@edge?$AA@
	DD	0126H
	DD	FLAT:??_C@_06MMNNGFLE@facets?$AA@
	DD	0127H
	DD	FLAT:??_C@_05BIBOABDC@facet?$AA@
	DD	0127H
	DD	FLAT:??_C@_05FHFPJHPF@faces?$AA@
	DD	0127H
	DD	FLAT:??_C@_04POCOPAPC@face?$AA@
	DD	0127H
	DD	FLAT:??_C@_0M@NLMIGHAM@facet_edges?$AA@
	DD	0133H
	DD	FLAT:??_C@_0L@LKKCPKKM@facet_edge?$AA@
	DD	0133H
	DD	FLAT:??_C@_0L@CPIKDJIA@facetedges?$AA@
	DD	0133H
	DD	FLAT:??_C@_09CMEJCHLK@facetedge?$AA@
	DD	0133H
	DD	FLAT:??_C@_06OHIKIKDI@bodies?$AA@
	DD	0128H
	DD	FLAT:??_C@_04IEJGKNJ@body?$AA@
	DD	0128H
	DD	FLAT:??_C@_07CFPPNLMH@topinfo?$AA@
	DD	0137H
	DD	FLAT:??_C@_0L@BBAJEGNK@bottominfo?$AA@
	DD	0190H
	DD	FLAT:??_C@_06IJDLPEM@length?$AA@
	DD	012cH
	DD	FLAT:??_C@_07HKCFKCGH@valence?$AA@
	DD	0139H
	DD	FLAT:??_C@_04GOEDGNCF@area?$AA@
	DD	012dH
	DD	FLAT:??_C@_06EMCPHFGM@volume?$AA@
	DD	012eH
	DD	FLAT:??_C@_07MEIPJMCG@sqcurve?$AA@
	DD	019bH
	DD	FLAT:??_C@_05LCFPHLEE@where?$AA@
	DD	0143H
	DD	FLAT:??_C@_04DONFEANM@list?$AA@
	DD	0144H
	DD	FLAT:??_C@_04FKMICODN@show?$AA@
	DD	0145H
	DD	FLAT:??_C@_05GOBGMMII@showq?$AA@
	DD	0149H
	DD	FLAT:??_C@_06FOBLBEIN@delete?$AA@
	DD	0146H
	DD	FLAT:??_C@_08KFIPBGJH@dissolve?$AA@
	DD	0142H
	DD	FLAT:??_C@_06ELMCDMMG@refine?$AA@
	DD	0147H
	DD	FLAT:??_C@_05OOLEAMGB@shell?$AA@
	DD	0120H
	DD	FLAT:??_C@_0L@HOHHMJMM@constraint?$AA@
	DD	0140H
	DD	FLAT:??_C@_08POHEELCJ@pressure?$AA@
	DD	013fH
	DD	FLAT:??_C@_05PEENBMOG@color?$AA@
	DD	0121H
	DD	FLAT:??_C@_09OPNKCLNO@backcolor?$AA@
	DD	01a2H
	DD	FLAT:??_C@_0L@DKEJANLD@frontcolor?$AA@
	DD	019cH
	DD	FLAT:??_C@_07IJGPCJHC@opacity?$AA@
	DD	0138H
	DD	FLAT:??_C@_06EMCPHFGM@volume?$AA@
	DD	012eH
	DD	FLAT:??_C@_07HAFFKDBK@density?$AA@
	DD	013eH
	DD	FLAT:??_C@_07BJBOFKDG@tension?$AA@
	DD	013eH
	DD	FLAT:??_C@_03KCHOJKKI@set?$AA@
	DD	013cH
	DD	FLAT:??_C@_04POLDLDMI@read?$AA@
	DD	0156H
	DD	FLAT:??_C@_05EPBFLBEJ@unset?$AA@
	DD	0136H
	DD	FLAT:??_C@_06BDEIOILB@recalc?$AA@
	DD	0148H
	DD	FLAT:??_C@_08GHMAOHAP@optimize?$AA@
	DD	01eeH
	DD	FLAT:??_C@_08GIBBNMIA@optimise?$AA@
	DD	01eeH
	DD	FLAT:??_C@_08BLGPIPGP@autochop?$AA@
	DD	0169H
_togglenames DD	FLAT:??_C@_0P@EJEJKKN@force_edgeswap?$AA@
	DD	02963H
	DD	FLAT:??_C@_0P@BMEBABFE@show_all_edges?$AA@
	DD	02968H
	DD	FLAT:??_C@_0BA@FEGMCNGA@K_altitude_mode?$AA@
	DD	02985H
	DD	FLAT:??_C@_0BC@IOPGAMGF@show_bounding_box?$AA@
	DD	02967H
	DD	FLAT:??_C@_0M@FKFJNJHN@septum_flag?$AA@
	DD	02969H
	DD	FLAT:??_C@_0CB@GFKKBGMN@view_transforms_use_unique_point@
	DD	02970H
	DD	FLAT:??_C@_0P@HBGAENON@detorus_sticky?$AA@
	DD	0296fH
	DD	FLAT:??_C@_0BC@PCLABFDB@immediate_autopop?$AA@
	DD	02949H
	DD	FLAT:??_C@_0P@JPONPFLM@star_finagling?$AA@
	DD	02972H
	DD	FLAT:??_C@_0P@BHLDEOD@force_deletion?$AA@
	DD	02971H
	DD	FLAT:??_C@_0BJ@GACLGPHB@function_quantity_sparse?$AA@
	DD	0296eH
	DD	FLAT:??_C@_0L@KMEPJMME@slice_view?$AA@
	DD	02973H
	DD	FLAT:??_C@_09FMDIMAMP@clip_view?$AA@
	DD	02974H
	DD	FLAT:??_C@_09EOFABKBN@quietload?$AA@
	DD	0296dH
	DD	FLAT:??_C@_0L@HGLBMAAF@big_endian?$AA@
	DD	0298cH
	DD	FLAT:??_C@_0O@EKBDJBFN@little_endian?$AA@
	DD	0298dH
	DD	FLAT:??_C@_0BC@PCBOIGLG@full_bounding_box?$AA@
	DD	02987H
	DD	FLAT:??_C@_0M@PDGIDHIC@pop_disjoin?$AA@
	DD	0298aH
	DD	FLAT:??_C@_0L@NBNMFCPF@pop_enjoin?$AA@
	DD	0298bH
	DD	FLAT:??_C@_0M@CAFGBCMP@pop_to_edge?$AA@
	DD	02988H
	DD	FLAT:??_C@_0M@FHCBDAPB@pop_to_face?$AA@
	DD	02989H
	DD	FLAT:??_C@_09PJOICEHA@mpi_debug?$AA@
	DD	0298eH
	DD	FLAT:??_C@_0N@DFPINMIP@smooth_graph?$AA@
	DD	02986H
	DD	FLAT:??_C@_0N@OJEGAGKB@bezier_basis?$AA@
	DD	02990H
	DD	FLAT:??_C@_0BE@HEFINIJJ@break_after_warning?$AA@
	DD	0297cH
	DD	FLAT:??_C@_0BB@GKDPKLCB@break_on_warning?$AA@
	DD	0297dH
	DD	FLAT:??_C@_09ELACHHOE@blas_flag?$AA@
	DD	0297eH
	DD	FLAT:??_C@_09NBBNKAEP@diffusion?$AA@
	DD	029e0H
	DD	FLAT:??_C@_0BC@OIKNNBJM@augmented_hessian?$AA@
	DD	0297fH
	DD	FLAT:??_C@_0BD@LILDNGFC@sparse_constraints?$AA@
	DD	02980H
	DD	FLAT:??_C@_0BA@NBAAGIKN@visibility_test?$AA@
	DD	02981H
	DD	FLAT:??_C@_0BC@ENFIPPEC@circular_arc_draw?$AA@
	DD	02982H
	DD	FLAT:??_C@_0L@NAICPCIF@rgb_colors?$AA@
	DD	0297bH
	DD	FLAT:??_C@_0BB@OFKJMHPN@kraynikpopvertex?$AA@
	DD	02983H
	DD	FLAT:??_C@_0P@EOAPCHNN@kraynikpopedge?$AA@
	DD	02984H
	DD	FLAT:??_C@_0N@IAKIABKB@sobolev_mode?$AA@
	DD	02991H
	DD	FLAT:??_C@_0P@DEKALNNI@dirichlet_mode?$AA@
	DD	0297aH
	DD	FLAT:??_C@_07KBAMPNJK@verbose?$AA@
	DD	0296bH
	DD	FLAT:??_C@_0N@IGCELFFA@torus_filled?$AA@
	DD	0296aH
	DD	FLAT:??_C@_0BB@JLCFDFN@ambient_pressure?$AA@
	DD	029e6H
	DD	FLAT:??_C@_08KFLJAAGL@backcull?$AA@
	DD	02975H
	DD	FLAT:??_C@_0O@DOAHOLKA@rotate_lights?$AA@
	DD	02976H
	DD	FLAT:??_C@_0P@DFOEIAJO@interp_normals?$AA@
	DD	029e4H
	DD	FLAT:??_C@_0P@PLDNIGHE@volgrads_every?$AA@
	DD	02977H
	DD	FLAT:??_C@_0L@PLJDOBHE@zener_drag?$AA@
	DD	02978H
	DD	FLAT:??_C@_0BH@DJGEPEF@hessian_special_normal?$AA@
	DD	02993H
	DD	FLAT:??_C@_0BE@IEAFMCH@hessian_normal_perp?$AA@
	DD	02994H
	DD	FLAT:??_C@_0BE@PABNDBOD@show_all_quantities?$AA@
	DD	02960H
	DD	FLAT:??_C@_0M@MGNBMOID@pscolorflag?$AA@
	DD	02961H
	DD	FLAT:??_C@_0N@PDJMPNAK@ps_colorflag?$AA@
	DD	02961H
	DD	FLAT:??_C@_0M@LOFHKFBI@ps_cmykflag?$AA@
	DD	02962H
	DD	FLAT:??_C@_0M@NAKIPJII@ps_gridflag?$AA@
	DD	02964H
	DD	FLAT:??_C@_08EGOBEDIK@gridflag?$AA@
	DD	02964H
	DD	FLAT:??_C@_0N@JJEIJGBI@crossingflag?$AA@
	DD	02965H
	DD	FLAT:??_C@_0BA@MDFPOHGI@ps_crossingflag?$AA@
	DD	02965H
	DD	FLAT:??_C@_09KMOLHLBE@labelflag?$AA@
	DD	02966H
	DD	FLAT:??_C@_0N@ECHDFDIC@ps_labelflag?$AA@
	DD	02966H
	DD	FLAT:??_C@_0BD@HMMIFHMP@hessian_normal_one?$AA@
	DD	02996H
	DD	FLAT:??_C@_0BC@KPHKHJOD@interp_bdry_param?$AA@
	DD	02999H
	DD	FLAT:??_C@_0BG@GAEGJDMI@hessian_double_normal?$AA@
	DD	02995H
	DD	FLAT:??_C@_0BB@GLJECMNP@h_inverse_metric?$AA@
	DD	0294eH
	DD	FLAT:??_C@_0BB@GPGBGBKF@squared_gradient?$AA@
	DD	029feH
	DD	FLAT:??_C@_0O@PLHGPNIO@linear_metric?$AA@
	DD	029ffH
	DD	FLAT:??_C@_0P@OHNEFNEP@metric_convert?$AA@
	DD	029fcH
	DD	FLAT:??_C@_0BA@HGBJAEID@quantities_only?$AA@
	DD	029fdH
	DD	FLAT:??_C@_04NLKFKEKL@ysmp?$AA@
	DD	02a01H
	DD	FLAT:??_C@_03JKDNAPFH@mkl?$AA@
	DD	02a00H
	DD	FLAT:??_C@_0O@BFFIKKOE@bunch_kaufman?$AA@
	DD	02a03H
	DD	FLAT:??_C@_0P@GKFGPBHG@bunch_kauffman?$AA@
	DD	02a03H
	DD	FLAT:??_C@_0P@BMDMDICD@hessian_normal?$AA@
	DD	02992H
	DD	FLAT:??_C@_06LGAKKEPJ@jiggle?$AA@
	DD	0295cH
	DD	FLAT:??_C@_0BA@NLJCNNPB@assume_oriented?$AA@
	DD	0294fH
	DD	FLAT:??_C@_07PIJPCAMN@ribiere?$AA@
	DD	0295dH
	DD	FLAT:??_C@_0BD@JAENIDNE@area_normalization?$AA@
	DD	0295fH
	DD	FLAT:??_C@_0O@MHBOMMFK@force_pos_def?$AA@
	DD	02941H
	DD	FLAT:??_C@_0M@DMCDJPBF@autodisplay?$AA@
	DD	029e1H
	DD	FLAT:??_C@_08JNKCHLOP@lagrange?$AA@
	DD	0271cH
	DD	FLAT:??_C@_09NDEBDKFB@quadratic?$AA@
	DD	0271bH
	DD	FLAT:??_C@_06HPJICMPM@linear?$AA@
	DD	0271aH
	DD	FLAT:??_C@_0L@EAEPHEPG@show_inner?$AA@
	DD	029e2H
	DD	FLAT:??_C@_0L@IDDPHJLO@area_fixed?$AA@
	DD	01c0H
	DD	FLAT:??_C@_0L@HCEEFND@fixed_area?$AA@
	DD	01c0H
	DD	FLAT:??_C@_07HKDEBIPG@clipped?$AA@
	DD	029faH
	DD	FLAT:??_C@_0O@ILHEOIGK@clipped_cells?$AA@
	DD	029faH
	DD	FLAT:??_C@_09DNEEIDBP@raw_cells?$AA@
	DD	029f8H
	DD	FLAT:??_C@_09JGOMOAGJ@connected?$AA@
	DD	029f9H
	DD	FLAT:??_C@_0BA@FMBIOPNC@connected_cells?$AA@
	DD	029f9H
	DD	FLAT:??_C@_0L@LOICIGID@show_outer?$AA@
	DD	029e3H
	DD	FLAT:??_C@_08OMBDDLKJ@colormap?$AA@
	DD	029e5H
	DD	FLAT:??_C@_07KCLCNBJB@thicken?$AA@
	DD	029fbH
	DD	FLAT:??_C@_0N@PBIFKJMI@hessian_diff?$AA@
	DD	02998H
	DD	FLAT:??_C@_0O@PKIOMPCC@normal_motion?$AA@
	DD	02935H
	DD	FLAT:??_C@_0M@OBNGAKOC@runge_kutta?$AA@
	DD	029dbH
	DD	FLAT:??_C@_07LLNNGCPP@deturck?$AA@
	DD	02944H
	DD	FLAT:??_C@_06IGFDKMHM@kusner?$AA@
	DD	0293bH
	DD	FLAT:??_C@_07EMJKOPJK@view_4d?$AA@
	DD	02936H
	DD	FLAT:??_C@_09MFCEMNNF@conf_edge?$AA@
	DD	0293dH
	DD	FLAT:??_C@_0BI@KGGFDDEC@mean_curvature_integral?$AA@
	DD	0293fH
	DD	FLAT:??_C@_07ENPKKAPH@sqgauss?$AA@
	DD	02945H
	DD	FLAT:??_C@_07LEJGIFAD@autopop?$AA@
	DD	02947H
	DD	FLAT:??_C@_0BA@KEKJOJEJ@autopop_quartic?$AA@
	DD	02948H
	DD	FLAT:??_C@_08MINHKHMD@old_area?$AA@
	DD	0294cH
	DD	FLAT:??_C@_0M@GGBEIMML@approx_curv?$AA@
	DD	0294dH
	DD	FLAT:??_C@_0P@OGHBAHOF@check_increase?$AA@
	DD	029dcH
	DD	FLAT:??_C@_05GFCDIDHO@debug?$AA@
	DD	028f9H
	DD	FLAT:??_C@_08ONKONDHK@memdebug?$AA@
	DD	028fbH
	DD	FLAT:??_C@_07GGEALCBM@itdebug?$AA@
	DD	028faH
	DD	FLAT:??_C@_07GFBFDLBM@gravity?$AA@
	DD	0292dH
	DD	FLAT:??_C@_0P@OMMOBLOA@effective_area?$AA@
	DD	029e7H
	DD	FLAT:??_C@_08LDELGPJH@estimate?$AA@
	DD	02942H
	DD	FLAT:??_C@_0N@NFINOFHM@post_project?$AA@
	DD	0293eH
	DD	FLAT:??_C@_0L@DLCCMBJF@transforms?$AA@
	DD	02943H
	DD	FLAT:??_C@_05PMBAOCDH@quiet?$AA@
	DD	0296cH
	DD	FLAT:??_C@_07HBPOHFLN@quietgo?$AA@
	DD	02979H
	DD	FLAT:??_C@_0O@HCDDDEHN@hessian_quiet?$AA@
	DD	02997H
	DD	FLAT:??_C@_09BAKALBHB@conj_grad?$AA@
	DD	0295eH
	DD	FLAT:??_C@_09PDIDGCEH@homothety?$AA@
	DD	029ddH
	DD	FLAT:??_C@_0N@BNMHNAMC@facet_colors?$AA@
	DD	0292fH
	DD	FLAT:??_C@_07IBJKBKNG@shading?$AA@
	DD	02930H
	DD	FLAT:??_C@_0BF@KHPBBAHH@div_normal_curvature?$AA@
	DD	029e9H
	DD	FLAT:??_C@_0BB@ODBHHAP@normal_curvature?$AA@
	DD	029e8H
	DD	FLAT:??_C@_0BD@MOPCCJLG@boundary_curvature?$AA@
	DD	0293cH
	DD	FLAT:??_C@_0N@FFMNCIGF@self_similar?$AA@
	DD	02939H
	DD	FLAT:??_C@_09BPDDPHCA@gv_binary?$AA@
	DD	0293aH
	DD	FLAT:??_C@_0BC@LJJGFBGD@metric_conversion?$AA@
	DD	02938H
	DD	FLAT:??_C@_0L@MABNKBMJ@autorecalc?$AA@
	DD	02940H
	DD	FLAT:??_C@_07BCIELMPF@pinning?$AA@
	DD	02937H
_colornames DD	FLAT:??_C@_05MEHLAELG@clear?$AA@
	DD	0ffffffffH
	DD	FLAT:??_C@_0M@CEEDCJLA@transparent?$AA@
	DD	0ffffffffH
	DD	FLAT:??_C@_05BIMBDNDC@black?$AA@
	DD	00H
	DD	FLAT:??_C@_04OBGPFBCN@blue?$AA@
	DD	01H
	DD	FLAT:??_C@_05GBEEJKMC@green?$AA@
	DD	02H
	DD	FLAT:??_C@_04EDBDANFH@cyan?$AA@
	DD	03H
	DD	FLAT:??_C@_03FAAAOPJM@red?$AA@
	DD	04H
	DD	FLAT:??_C@_07EMDGAPCI@magenta?$AA@
	DD	05H
	DD	FLAT:??_C@_05EBJGJMAL@brown?$AA@
	DD	06H
	DD	FLAT:??_C@_09IIGGAAJN@lightgray?$AA@
	DD	07H
	DD	FLAT:??_C@_09IPGPKIEB@lightgrey?$AA@
	DD	07H
	DD	FLAT:??_C@_04GEBBKIAA@gray?$AA@
	DD	07H
	DD	FLAT:??_C@_04GDBIAANM@grey?$AA@
	DD	07H
	DD	FLAT:??_C@_08EADAAFKF@darkgray?$AA@
	DD	08H
	DD	FLAT:??_C@_08EHDJKNHJ@darkgrey?$AA@
	DD	08H
	DD	FLAT:??_C@_09NBIPJLA@lightblue?$AA@
	DD	09H
	DD	FLAT:??_C@_0L@OPBGACJD@lightgreen?$AA@
	DD	0aH
	DD	FLAT:??_C@_09KPGEKFMK@lightcyan?$AA@
	DD	0bH
	DD	FLAT:??_C@_08EEFKFEFN@lightred?$AA@
	DD	0cH
	DD	FLAT:??_C@_0N@BBECPGBJ@lightmagenta?$AA@
	DD	0dH
	DD	FLAT:??_C@_06ENJNJKEL@yellow?$AA@
	DD	0eH
	DD	FLAT:??_C@_05PMAELIEO@white?$AA@
	DD	0fH
_internal_variables DD FLAT:??_C@_0BD@ENGCHOCN@bounding_box_color?$AA@
	DD	0905H
	DD	FLAT:??_C@_0BA@GKOHKDJ@detorus_epsilon?$AA@
	DD	0904H
	DD	FLAT:??_C@_0BA@HEFKJKJG@high_constraint?$AA@
	DD	0902H
	DD	FLAT:??_C@_0O@FHDEFNFH@high_boundary?$AA@
	DD	0903H
	DD	FLAT:??_C@_0BA@OIGENEKE@autochop_length?$AA@
	DD	08eeH
	DD	FLAT:??_C@_0BH@CENGABA@string_curve_tolerance?$AA@
	DD	08ffH
	DD	FLAT:??_C@_0N@ILKHNNHO@corona_state?$AA@
	DD	08f9H
	DD	FLAT:??_C@_0M@JCMEGIAD@mpi_maxtask?$AA@
	DD	08f0H
	DD	FLAT:??_C@_09LEOGOINP@this_task?$AA@
	DD	08e7H
	DD	FLAT:??_C@_0BE@LMLDEADG@window_aspect_ratio?$AA@
	DD	08e5H
	DD	FLAT:??_C@_0BD@ICNMFEGJ@mindeg_debug_level?$AA@
	DD	08dcH
	DD	FLAT:??_C@_0BH@CCPNJHKC@mindeg_min_region_size?$AA@
	DD	08deH
	DD	FLAT:??_C@_0O@IOPDAKCK@mindeg_margin?$AA@
	DD	08ddH
	DD	FLAT:??_C@_09FKJNFACE@fix_count?$AA@
	DD	0842H
	DD	FLAT:??_C@_0M@HMIJLFOH@unfix_count?$AA@
	DD	0843H
	DD	FLAT:??_C@_0BC@GMDNEKGI@edge_delete_count?$AA@
	DD	083fH
	DD	FLAT:??_C@_0BD@HGHNBHOM@facet_delete_count?$AA@
	DD	0840H
	DD	FLAT:??_C@_0BG@MLIFIJNF@vertex_dissolve_count?$AA@
	DD	082fH
	DD	FLAT:??_C@_0BE@JFPIKCB@edge_dissolve_count?$AA@
	DD	0830H
	DD	FLAT:??_C@_0BF@EDGKOAGH@facet_dissolve_count?$AA@
	DD	0831H
	DD	FLAT:??_C@_0BE@CKCDJLNA@body_dissolve_count?$AA@
	DD	0832H
	DD	FLAT:??_C@_0BC@LJKCEDIK@edge_refine_count?$AA@
	DD	0833H
	DD	FLAT:??_C@_0BD@KDOCBOAO@facet_refine_count?$AA@
	DD	0834H
	DD	FLAT:??_C@_0BB@PNOKJDFD@vertex_pop_count?$AA@
	DD	0835H
	DD	FLAT:??_C@_0P@CIHELNID@edge_pop_count?$AA@
	DD	0836H
	DD	FLAT:??_C@_0BG@NFPFNFEP@pop_tri_to_edge_count?$AA@
	DD	0838H
	DD	FLAT:??_C@_0BG@LGGDNHOG@pop_edge_to_tri_count?$AA@
	DD	0839H
	DD	FLAT:??_C@_0BH@GEAHEOKO@pop_quad_to_quad_count?$AA@
	DD	083aH
	DD	FLAT:??_C@_0P@IOOMGAHI@edgeswap_count?$AA@
	DD	083bH
	DD	FLAT:??_C@_0BC@EADCAAG@t1_edgeswap_count?$AA@
	DD	083cH
	DD	FLAT:??_C@_0N@PPOIJFFB@ps_labelsize?$AA@
	DD	0844H
	DD	FLAT:??_C@_0P@MKDKOLJB@ps_stringwidth?$AA@
	DD	07e9H
	DD	FLAT:??_C@_0BC@CPCJJCCO@ps_fixededgewidth?$AA@
	DD	07eaH
	DD	FLAT:??_C@_0BD@DOBHCOCD@ps_tripleedgewidth?$AA@
	DD	07ebH
	DD	FLAT:??_C@_0BA@LMLNIMJE@ps_conedgewidth?$AA@
	DD	07ecH
	DD	FLAT:??_C@_0BB@NEEDDBHF@ps_bareedgewidth?$AA@
	DD	07edH
	DD	FLAT:??_C@_0BB@OFCJADDO@ps_gridedgewidth?$AA@
	DD	07eeH
	DD	FLAT:??_C@_0BB@NLMEBPED@scrollbuffersize?$AA@
	DD	07e3H
	DD	FLAT:??_C@_0BB@GILLHKAL@visibility_debug?$AA@
	DD	07e2H
	DD	FLAT:??_C@_0M@PLDEDAON@check_count?$AA@
	DD	07c2H
	DD	FLAT:??_C@_0BE@CJKHIDDP@bad_next_prev_count?$AA@
	DD	08e0H
	DD	FLAT:??_C@_0BK@LLHOBCKD@inconsistent_bodies_count?$AA@
	DD	08e1H
	DD	FLAT:??_C@_0BA@GMPBMHMF@edge_loop_count?$AA@
	DD	08e2H
	DD	FLAT:??_C@_0BK@JKNABKBA@edges_same_vertices_count?$AA@
	DD	08e3H
	DD	FLAT:??_C@_0BL@CKKLJMAI@facets_same_vertices_count?$AA@
	DD	08e4H
	DD	FLAT:??_C@_0BA@HBCDBDGE@bad_error_count?$AA@
	DD	08e6H
	DD	FLAT:??_C@_09MEOACIKB@breakflag?$AA@
	DD	07c3H
	DD	FLAT:??_C@_0BG@DMHBIFMB@everything_quantities?$AA@
	DD	08dfH
	DD	FLAT:??_C@_0BB@LFLMFBL@gravity_constant?$AA@
	DD	08908H
	DD	FLAT:??_C@_0BF@PLHANHAM@hessian_slant_cutoff?$AA@
	DD	07b8H
	DD	FLAT:??_C@_0BH@OAPNEHDB@ambient_pressure_value?$AA@
	DD	07b7H
	DD	FLAT:??_C@_0L@IAKFAOLO@last_error?$AA@
	DD	0799H
	DD	FLAT:??_C@_0N@HIDDLAJM@memory_arena?$AA@
	DD	0796H
	DD	FLAT:??_C@_0M@NJPPNBCL@memory_used?$AA@
	DD	0797H
	DD	FLAT:??_C@_0L@EGCKCJDC@background?$AA@
	DD	0792H
	DD	FLAT:??_C@_0L@BECHNFGG@brightness?$AA@
	DD	078fH
	DD	FLAT:??_C@_0BA@JDILIPNO@diffusion_coeff?$AA@
	DD	0790H
	DD	FLAT:??_C@_0BA@BIIIJIED@transform_count?$AA@
	DD	0770H
	DD	FLAT:??_C@_0M@PJCBAJEM@scale_limit?$AA@
	DD	075cH
	DD	FLAT:??_C@_05DDECJJKE@clock?$AA@
	DD	0758H
	DD	FLAT:??_C@_0M@HBHAPOJO@cpu_counter?$AA@
	DD	0845H
	DD	FLAT:??_C@_0BB@GHHBGKKF@target_tolerance?$AA@
	DD	0757H
	DD	FLAT:??_C@_09GLPKLBIH@thickness?$AA@
	DD	0756H
	DD	FLAT:??_C@_0BA@CNIKOEML@spring_constant?$AA@
	DD	0755H
	DD	FLAT:??_C@_0N@DKAJABDK@gap_constant?$AA@
	DD	0755H
	DD	FLAT:??_C@_0P@DDMFGHDB@lagrange_order?$AA@
	DD	074dH
	DD	FLAT:??_C@_0BA@OBNGJMBG@last_eigenvalue?$AA@
	DD	0747H
	DD	FLAT:??_C@_0BD@CHOAMOKA@last_hessian_scale?$AA@
	DD	0748H
	DD	FLAT:??_C@_0P@JOOJGKKP@integral_order?$AA@
	DD	066aH
	DD	FLAT:??_C@_0BC@CDLGPNMC@integral_order_1d?$AA@
	DD	0731H
	DD	FLAT:??_C@_0BC@CBPAEDJL@integral_order_2d?$AA@
	DD	0732H
	DD	FLAT:??_C@_0BC@CCICJAIC@integration_order?$AA@
	DD	066aH
	DD	FLAT:??_C@_0BF@CHBAJJCK@integration_order_1d?$AA@
	DD	0731H
	DD	FLAT:??_C@_0BF@CFFGCHHD@integration_order_2d?$AA@
	DD	0732H
	DD	FLAT:??_C@_0M@PANFJEDO@random_seed?$AA@
	DD	072fH
	DD	FLAT:??_C@_06NLFCANPD@random?$AA@
	DD	0789H
	DD	FLAT:??_C@_0BC@DAHPKAPK@linear_metric_mix?$AA@
	DD	0728H
	DD	FLAT:??_C@_0BF@GFGAKDLL@quadratic_metric_mix?$AA@
	DD	0745H
	DD	FLAT:??_C@_08NBJOBAPL@pickvnum?$AA@
	DD	0724H
	DD	FLAT:??_C@_08PGNOPNKJ@pickenum?$AA@
	DD	0725H
	DD	FLAT:??_C@_08LBHOIHHJ@pickfnum?$AA@
	DD	0726H
	DD	FLAT:??_C@_09HMMAJFCG@eigen_pos?$AA@
	DD	071aH
	DD	FLAT:??_C@_09OPDPOHAJ@eigen_neg?$AA@
	DD	071bH
	DD	FLAT:??_C@_0L@BENLKAPC@eigen_zero?$AA@
	DD	071cH
	DD	FLAT:??_C@_08NMCKLHDA@eigenpos?$AA@
	DD	071aH
	DD	FLAT:??_C@_08EPNFMFBP@eigenneg?$AA@
	DD	071bH
	DD	FLAT:??_C@_09OAKPPPIB@eigenzero?$AA@
	DD	071cH
	DD	FLAT:??_C@_0L@OIFGKHMH@total_time?$AA@
	DD	0703H
	DD	FLAT:??_C@_0BD@HHELJMGO@jiggle_temperature?$AA@
	DD	0704H
	DD	FLAT:??_C@_0BC@OLOACPCP@iteration_counter?$AA@
	DD	06fbH
	DD	FLAT:??_C@_0M@FONFPPOA@scale_scale?$AA@
	DD	06f2H
	DD	FLAT:??_C@_0N@HPKCIPGC@vertex_count?$AA@
	DD	0642H
	DD	FLAT:??_C@_0L@NIJKJMJB@edge_count?$AA@
	DD	0643H
	DD	FLAT:??_C@_0M@MDEFFDDC@facet_count?$AA@
	DD	0644H
	DD	FLAT:??_C@_0L@BLNIGKEE@body_count?$AA@
	DD	0645H
	DD	FLAT:??_C@_0BA@KJPGFHE@facetedge_count?$AA@
	DD	0646H
	DD	FLAT:??_C@_0N@FOHOADKL@total_energy?$AA@
	DD	0647H
	DD	FLAT:??_C@_0L@KNDBPLBH@total_area?$AA@
	DD	0648H
	DD	FLAT:??_C@_0N@PMIPBODO@total_length?$AA@
	DD	0649H
	DD	FLAT:??_C@_05MHMEBBGO@scale?$AA@
	DD	064aH
	DD	FLAT:??_C@_0BA@NCBBEAIN@space_dimension?$AA@
	DD	0664H
	DD	FLAT:??_C@_0BC@CCLFHFGM@surface_dimension?$AA@
	DD	0663H
	DD	FLAT:??_C@_05FCPCBJIO@torus?$AA@
	DD	0666H
	DD	FLAT:??_C@_0P@GKEDIIHF@symmetry_group?$AA@
	DD	0668H
	DD	FLAT:??_C@_0BH@ELELLFNL@simplex_representation?$AA@
	DD	0669H
	DD	FLAT:??_C@_0BF@MOILGEJM@constraint_tolerance?$AA@
	DD	066eH
	DD	FLAT:??_C@_0BA@FLAJOIPD@hessian_epsilon?$AA@
	DD	06ccH
	DD	FLAT:??_C@_0L@MMIEKJIF@equi_count?$AA@
	DD	0670H
	DD	FLAT:??_C@_0N@MDBAOLCA@delete_count?$AA@
	DD	0672H
	DD	FLAT:??_C@_0N@BGIPOCMC@refine_count?$AA@
	DD	0673H
	DD	FLAT:??_C@_0M@KEDMJLF@notch_count?$AA@
	DD	0674H
	DD	FLAT:??_C@_0P@JACOHDHP@dissolve_count?$AA@
	DD	0675H
	DD	FLAT:??_C@_09NANCMDLE@pop_count?$AA@
	DD	0676H
	DD	FLAT:??_C@_0M@FKBLKCGO@where_count?$AA@
	DD	0677H
_DATA	ENDS
PUBLIC	??_C@_0CO@NMEDNICH@Internal?5error?3?5unputted_tok?5sta@ ; `string'
PUBLIC	_unput_tok
EXTRN	_tok:DWORD
EXTRN	_kb_error:PROC
;	COMDAT ??_C@_0CO@NMEDNICH@Internal?5error?3?5unputted_tok?5sta@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\lexyy.c
CONST	SEGMENT
??_C@_0CO@NMEDNICH@Internal?5error?3?5unputted_tok?5sta@ DB 'Internal err'
	DB	'or: unputted_tok stack overflow.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _unput_tok
_TEXT	SEGMENT
_unput_tok PROC						; COMDAT

; 762  :   if ( unput_tok_count >= UNPUTMAX )

	mov	eax, DWORD PTR _unput_tok_count
	cmp	eax, 10					; 0000000aH
	jl	SHORT $LN4@unput_tok

; 763  :     kb_error(2324,"Internal error: unputted_tok stack overflow.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CO@NMEDNICH@Internal?5error?3?5unputted_tok?5sta@
	push	2324					; 00000914H
	call	_kb_error

; 764  :   unputted_tok[unput_tok_count++] = tok;

	mov	eax, DWORD PTR _unput_tok_count
	mov	ecx, DWORD PTR _tok
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _unputted_tok[eax*4], ecx
	inc	eax
	mov	DWORD PTR _unput_tok_count, eax

; 765  :   /* fprintf(stderr,"UNPUT %3d %s %s\n",tok,tokname(tok),yytext); */
; 766  :   /* tok = UNPUTTED_TOK; */ /* some places depend on knowing unput lookahead */
; 767  :  
; 768  : } // end unput_tok()

	ret	0
$LN4@unput_tok:

; 764  :   unputted_tok[unput_tok_count++] = tok;

	mov	edx, DWORD PTR _tok
	mov	DWORD PTR _unputted_tok[eax*4], edx
	inc	eax
	mov	DWORD PTR _unput_tok_count, eax

; 765  :   /* fprintf(stderr,"UNPUT %3d %s %s\n",tok,tokname(tok),yytext); */
; 766  :   /* tok = UNPUTTED_TOK; */ /* some places depend on knowing unput lookahead */
; 767  :  
; 768  : } // end unput_tok()

	ret	0
_unput_tok ENDP
_TEXT	ENDS
_BSS	SEGMENT
_yy_last_accepting_cpos DD 01H DUP (?)
_yy_last_accepting_state DD 01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _yy_get_previous_state
_TEXT	SEGMENT
_yy_get_previous_state PROC				; COMDAT

; 2454 : 	register yy_state_type yy_current_state;
; 2455 : 	register char *yy_cp;
; 2456 : 
; 2457 : 	yy_current_state = yy_start;
; 2458 : 	yy_current_state += YY_AT_BOL();

	mov	eax, DWORD PTR _yy_current_buffer
	mov	eax, DWORD PTR [eax+28]
	add	eax, DWORD PTR _yy_start
	push	esi

; 2459 : 
; 2460 : 	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )

	mov	esi, DWORD PTR _yytext
	cmp	esi, DWORD PTR _yy_c_buf_p
	jae	$LN5@yy_get_pre
	push	ebx
	push	edi
$LL7@yy_get_pre:

; 2461 : 		{
; 2462 : 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);

	mov	cl, BYTE PTR [esi]
	test	cl, cl
	je	SHORT $LN10@yy_get_pre
	movzx	ecx, cl
	mov	bl, BYTE PTR _yy_ec[ecx*4]
	jmp	SHORT $LN11@yy_get_pre
$LN10@yy_get_pre:
	mov	bl, 1
$LN11@yy_get_pre:

; 2463 : 		if ( yy_accept[yy_current_state] )

	lea	ecx, DWORD PTR [eax+eax]
	cmp	WORD PTR _yy_accept[ecx], 0
	je	SHORT $LN13@yy_get_pre

; 2464 : 			{
; 2465 : 			yy_last_accepting_state = yy_current_state;

	mov	DWORD PTR _yy_last_accepting_state, eax

; 2466 : 			yy_last_accepting_cpos = yy_cp;

	mov	DWORD PTR _yy_last_accepting_cpos, esi
$LN13@yy_get_pre:

; 2467 : 			}
; 2468 : 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )

	movsx	edi, WORD PTR _yy_base[ecx]
	movzx	edx, bl
	add	edi, edx
	movsx	edi, WORD PTR _yy_chk[edi*2]
	cmp	edi, eax
	je	SHORT $LN2@yy_get_pre
	npad	9
$LL3@yy_get_pre:

; 2469 : 			{
; 2470 : 			yy_current_state = (int) yy_def[yy_current_state];

	movsx	eax, WORD PTR _yy_def[ecx]

; 2471 : 			if ( yy_current_state >= 230 )

	cmp	eax, 230				; 000000e6H
	jl	SHORT $LN1@yy_get_pre

; 2472 : 				yy_c = yy_meta[(unsigned int) yy_c];

	mov	bl, BYTE PTR _yy_meta[edx*4]
$LN1@yy_get_pre:

; 2467 : 			}
; 2468 : 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )

	lea	ecx, DWORD PTR [eax+eax]
	movsx	edi, WORD PTR _yy_base[ecx]
	movzx	edx, bl
	add	edi, edx
	movsx	edi, WORD PTR _yy_chk[edi*2]
	cmp	edi, eax
	jne	SHORT $LL3@yy_get_pre
$LN2@yy_get_pre:

; 2473 : 			}
; 2474 : 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];

	movsx	edx, WORD PTR _yy_base[eax*2]
	movzx	eax, bl
	add	edx, eax
	movsx	eax, WORD PTR _yy_nxt[edx*2]
	inc	esi
	cmp	esi, DWORD PTR _yy_c_buf_p
	jb	$LL7@yy_get_pre
	pop	edi
	pop	ebx
$LN5@yy_get_pre:
	pop	esi

; 2475 : 		}
; 2476 : 
; 2477 : 	return yy_current_state;
; 2478 : 	}

	ret	0
_yy_get_previous_state ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _yy_try_NUL_trans
_TEXT	SEGMENT
_yy_try_NUL_trans PROC					; COMDAT
; _yy_current_state$ = eax

; 2494 : 	register int yy_is_jam;
; 2495 : 	register char *yy_cp = yy_c_buf_p;
; 2496 : 
; 2497 : 	register YY_CHAR yy_c = 1;
; 2498 : 	if ( yy_accept[yy_current_state] )

	lea	ecx, DWORD PTR [eax+eax]
	cmp	WORD PTR _yy_accept[ecx], 0
	push	esi
	mov	dl, 1
	je	SHORT $LN7@yy_try_NUL

; 2499 : 		{
; 2500 : 		yy_last_accepting_state = yy_current_state;
; 2501 : 		yy_last_accepting_cpos = yy_cp;

	mov	esi, DWORD PTR _yy_c_buf_p
	mov	DWORD PTR _yy_last_accepting_state, eax
	mov	DWORD PTR _yy_last_accepting_cpos, esi
$LN7@yy_try_NUL:

; 2502 : 		}
; 2503 : 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )

	movsx	esi, WORD PTR _yy_base[ecx]
	movsx	esi, WORD PTR _yy_chk[esi*2+2]
	cmp	esi, eax
	je	SHORT $LN2@yy_try_NUL
	push	edi
	npad	11
$LL3@yy_try_NUL:

; 2504 : 		{
; 2505 : 		yy_current_state = (int) yy_def[yy_current_state];

	movsx	eax, WORD PTR _yy_def[ecx]

; 2506 : 		if ( yy_current_state >= 230 )

	cmp	eax, 230				; 000000e6H
	jl	SHORT $LN1@yy_try_NUL

; 2507 : 			yy_c = yy_meta[(unsigned int) yy_c];

	movzx	ecx, dl
	mov	dl, BYTE PTR _yy_meta[ecx*4]
$LN1@yy_try_NUL:

; 2502 : 		}
; 2503 : 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )

	lea	ecx, DWORD PTR [eax+eax]
	movsx	esi, WORD PTR _yy_base[ecx]
	movzx	edi, dl
	add	esi, edi
	movsx	esi, WORD PTR _yy_chk[esi*2]
	cmp	esi, eax
	jne	SHORT $LL3@yy_try_NUL
	pop	edi
$LN2@yy_try_NUL:

; 2508 : 		}
; 2509 : 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];

	movsx	eax, WORD PTR _yy_base[eax*2]
	movzx	ecx, dl
	add	eax, ecx
	movsx	ecx, WORD PTR _yy_nxt[eax*2]

; 2510 : 	yy_is_jam = (yy_current_state == 229);

	lea	eax, DWORD PTR [ecx-229]

; 2511 : 
; 2512 : 	return yy_is_jam ? 0 : yy_current_state;

	neg	eax
	sbb	eax, eax
	and	eax, ecx
	pop	esi

; 2513 : 	}

	ret	0
_yy_try_NUL_trans ENDP
_TEXT	ENDS
PUBLIC	_yy_load_buffer_state
_BSS	SEGMENT
_yy_hold_char DB 01H DUP (?)
	ALIGN	4

_yy_n_chars DD	01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _yy_load_buffer_state
_TEXT	SEGMENT
_yy_load_buffer_state PROC				; COMDAT

; 2681 : 	yy_n_chars = yy_current_buffer->yy_n_chars;

	mov	eax, DWORD PTR _yy_current_buffer
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _yy_n_chars, ecx

; 2682 : 	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _yytext, ecx

; 2683 : 	yyin = yy_current_buffer->yy_input_file;

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _yyin, edx

; 2684 : 	yy_hold_char = *yy_c_buf_p;

	mov	al, BYTE PTR [ecx]
	mov	DWORD PTR _yy_c_buf_p, ecx
	mov	BYTE PTR _yy_hold_char, al

; 2685 : 	}

	ret	0
_yy_load_buffer_state ENDP
_TEXT	ENDS
PUBLIC	_yy_flush_buffer
; Function compile flags: /Ogtp
;	COMDAT _yy_flush_buffer
_TEXT	SEGMENT
_b$ = 8							; size = 4
_yy_flush_buffer PROC					; COMDAT

; 2779 : 	{

	push	ebp
	mov	ebp, esp

; 2780 : 	b->yy_n_chars = 0;

	mov	eax, DWORD PTR _b$[ebp]

; 2781 : 
; 2782 : 	/* We always need two end-of-buffer characters.  The first causes
; 2783 : 	 * a transition to the end-of-buffer state.  The second causes
; 2784 : 	 * a jam in that state.
; 2785 : 	 */
; 2786 : 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;

	mov	edx, DWORD PTR [eax+4]
	xor	ecx, ecx
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [edx], cl

; 2787 : 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	mov	edx, DWORD PTR [eax+4]
	mov	BYTE PTR [edx+1], cl

; 2788 : 
; 2789 : 	b->yy_buf_pos = &b->yy_ch_buf[0];

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx

; 2790 : 
; 2791 : 	b->yy_at_bol = 1;

	mov	DWORD PTR [eax+28], 1

; 2792 : 	b->yy_buffer_status = YY_BUFFER_NEW;

	mov	DWORD PTR [eax+36], ecx

; 2793 : 
; 2794 : 	if ( b == yy_current_buffer )

	cmp	eax, DWORD PTR _yy_current_buffer
	jne	SHORT $LN1@yy_flush_b

; 2796 : 	}

	pop	ebp

; 2795 : 		yy_load_buffer_state();

	jmp	_yy_load_buffer_state
$LN1@yy_flush_b:

; 2796 : 	}

	pop	ebp
	ret	0
_yy_flush_buffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
EXTRN	_exit:PROC
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _yy_fatal_error
_TEXT	SEGMENT
_yy_fatal_error PROC					; COMDAT
; _msg$ = eax

; 2956 : 	(void) fprintf( stderr, "%s\n", msg );

	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 2957 : 	exit( YY_EXIT_FAILURE );

	push	2
	call	_exit
$LN4@yy_fatal_e:
$LN3@yy_fatal_e:
	int	3
_yy_fatal_error ENDP
_TEXT	ENDS
EXTRN	_malloc:PROC
; Function compile flags: /Ogtp
;	COMDAT _yy_flex_alloc
_TEXT	SEGMENT
_yy_flex_alloc PROC					; COMDAT
; _size$ = eax

; 3020 : 	return (void *) malloc( size );

	push	eax
	call	_malloc
	add	esp, 4

; 3021 : 	}

	ret	0
_yy_flex_alloc ENDP
_TEXT	ENDS
EXTRN	_realloc:PROC
; Function compile flags: /Ogtp
;	COMDAT _yy_flex_realloc
_TEXT	SEGMENT
_yy_flex_realloc PROC					; COMDAT
; _ptr$ = ecx
; _size$ = eax

; 3031 : 	/* The cast to (char *) in the following accommodates both
; 3032 : 	 * implementations that use char* generic pointers, and those
; 3033 : 	 * that use void* generic pointers.  It works with the latter
; 3034 : 	 * because both ANSI C and C++ allow castless assignment from
; 3035 : 	 * any pointer type to void*, and deal with argument conversions
; 3036 : 	 * as though doing an assignment.
; 3037 : 	 */
; 3038 : 	return (void *) realloc( (char *) ptr, size );

	push	eax
	push	ecx
	call	_realloc
	add	esp, 8

; 3039 : 	}

	ret	0
_yy_flex_realloc ENDP
_TEXT	ENDS
EXTRN	_free:PROC
; Function compile flags: /Ogtp
;	COMDAT _yy_flex_free
_TEXT	SEGMENT
_yy_flex_free PROC					; COMDAT
; _ptr$ = eax

; 3048 : 	free( ptr );

	push	eax
	call	_free
	pop	ecx

; 3049 : 	}

	ret	0
_yy_flex_free ENDP
_TEXT	ENDS
PUBLIC	??_C@_07HIIALNMO@LEXYY?4C?$AA@			; `string'
PUBLIC	_savein
EXTRN	_list_realloc:PROC
;	COMDAT ??_C@_07HIIALNMO@LEXYY?4C?$AA@
CONST	SEGMENT
??_C@_07HIIALNMO@LEXYY?4C?$AA@ DB 'LEXYY.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _savein
_TEXT	SEGMENT
_c$ = 8							; size = 4
_savein	PROC						; COMDAT

; 3072 : { if ( !inputsave_flag ) return;

	push	ebp
	mov	ebp, esp
	cmp	DWORD PTR _inputsave_flag, 0
	je	SHORT $LN3@savein

; 3073 :   if ( inputbufferspot >= inputbuffersize )

	mov	eax, DWORD PTR _inputbuffersize
	cmp	DWORD PTR _inputbufferspot, eax
	jl	SHORT $LN7@savein

; 3074 :   { int newsize = inputbuffersize?2*inputbuffersize:1000;

	push	esi
	lea	esi, DWORD PTR [eax+eax]
	test	eax, eax
	jne	SHORT $LN6@savein
	mov	esi, 1000				; 000003e8H
$LN6@savein:

; 3075 :     inputbuffer = my_list_realloc(inputbuffer,newsize,ETERNAL_BLOCK);

	mov	eax, DWORD PTR _inputbuffer
	push	3075					; 00000c03H
	push	OFFSET ??_C@_07HIIALNMO@LEXYY?4C?$AA@
	push	60138					; 0000eaeaH
	push	esi
	push	eax
	call	_list_realloc
	add	esp, 20					; 00000014H

; 3076 :     inputbuffersize = newsize;

	mov	DWORD PTR _inputbuffersize, esi
	mov	DWORD PTR _inputbuffer, eax
	pop	esi
$LN7@savein:

; 3077 :   }
; 3078 :   inputbuffer[inputbufferspot++] = (char)c;

	mov	eax, DWORD PTR _inputbufferspot
	mov	cl, BYTE PTR _c$[ebp]
	mov	edx, DWORD PTR _inputbuffer
	mov	BYTE PTR [edx+eax], cl
	inc	DWORD PTR _inputbufferspot
$LN3@savein:

; 3079 : } // end savein()

	pop	ebp
	ret	0
_savein	ENDP
_TEXT	ENDS
PUBLIC	_reset_inputbuffer
; Function compile flags: /Ogtp
;	COMDAT _reset_inputbuffer
_TEXT	SEGMENT
_reset_inputbuffer PROC					; COMDAT

; 3086 : { inputbufferspot = 0;

	mov	DWORD PTR _inputbufferspot, 0

; 3087 :   inputsave_flag = 1;

	mov	DWORD PTR _inputsave_flag, 1

; 3088 : }

	ret	0
_reset_inputbuffer ENDP
_TEXT	ENDS
PUBLIC	_rawinput
EXTRN	_in_comment:DWORD
EXTRN	_in_quote:DWORD
EXTRN	_datafile_flag:DWORD
EXTRN	_pop_commandfd:PROC
EXTRN	_getc:PROC
EXTRN	_commandfd:DWORD
EXTRN	_getstring:PROC
EXTRN	_cmdptr:DWORD
_BSS	SEGMENT
_errbuff DB	054H DUP (?)
_errspot DD	01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _rawinput
_TEXT	SEGMENT
_rawinput PROC						; COMDAT

; 3098 : {

	mov	ecx, DWORD PTR _cmdptr
	push	ebx
	push	esi
	xor	ebx, ebx
	push	edi
	mov	esi, OFFSET _morebuff
	lea	edi, DWORD PTR [ebx+13]
$LL19@rawinput:

; 3099 :   int c=0,retval;
; 3100 : 
; 3101 :   if ( cmdptr ) /* read from string */

	cmp	ecx, ebx
	je	SHORT $LL8@rawinput

; 3102 :    {
; 3103 :      if ( *cmdptr == 0 )  /* newline at end of each line */

	mov	al, BYTE PTR [ecx]
	cmp	al, bl
	je	$LN27@rawinput

; 3108 :        }
; 3109 :        else retval = 0;
; 3110 :        goto rawreturn; 
; 3111 :      }
; 3112 :      c = *(cmdptr++);

	movsx	eax, al
	inc	ecx
	mov	DWORD PTR _cmdptr, ecx

; 3113 :      if ( c == MOREIN ) /* for really long input lines */

	cmp	eax, 1
	jne	SHORT $LN25@rawinput

; 3114 :      { 
; 3115 : #ifdef USE_READLINE  //CSL
; 3116 :        prompt(CONTPROMPT,morebuff,MOREMAX);
; 3117 : #else
; 3118 :        getstring(morebuff,MOREMAX);

	push	1000					; 000003e8H
	push	esi
	call	_getstring

; 3119 : #endif
; 3120 :        cmdptr = morebuff;
; 3121 :        if ( !*cmdptr ) 

	mov	al, BYTE PTR _morebuff
	add	esp, 8
	mov	DWORD PTR _cmdptr, esi
	cmp	al, bl
	je	$LN28@rawinput

; 3126 :        }
; 3127 :        c = *(cmdptr++);

	mov	ecx, OFFSET _morebuff+1
	movsx	eax, al
	mov	DWORD PTR _cmdptr, ecx

; 3128 :      }
; 3129 :    }
; 3130 :   else /* read from file */

	jmp	SHORT $LN25@rawinput
$LL8@rawinput:

; 3131 :    { for(;;)
; 3132 :      {
; 3133 :        if ( commandfd == NULL )  /* in case read after close */

	mov	eax, DWORD PTR _commandfd
	cmp	eax, ebx
	je	SHORT $LN26@rawinput

; 3134 :        { retval = previous_char = 0; goto rawreturn; }
; 3135 :        c = getc(commandfd);

	push	eax
	call	_getc
	add	esp, 4

; 3136 :        if ( c != -1 ) break;

	cmp	eax, -1
	jne	SHORT $LN31@rawinput

; 3137 :        pop_commandfd();  /* EOF, so pop #include stack */

	call	_pop_commandfd

; 3138 :        if ( !datafile_flag ) /* EOF for a command file */

	cmp	DWORD PTR _datafile_flag, ebx
	jne	SHORT $LL8@rawinput
$LN26@rawinput:

; 3139 :        { retval =  previous_char = 0; goto rawreturn; }

	mov	DWORD PTR _previous_char, ebx
$LN14@rawinput:
	xor	eax, eax
$rawreturn$90596:
	pop	edi
	pop	esi
	pop	ebx

; 3163 : } // end rawinput()

	ret	0
$LN31@rawinput:

; 3140 :      }

	mov	ecx, DWORD PTR _cmdptr
$LN25@rawinput:

; 3141 :    }
; 3142 : 
; 3143 :   /* taking care of various line-ending combinations */
; 3144 :   if ( (c == '\n') && (previous_char == '\r') ) 

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN3@rawinput
	cmp	DWORD PTR _previous_char, edi
	je	$LL19@rawinput
$LN3@rawinput:

; 3145 :     return  rawinput();
; 3146 :   previous_char = c;

	mov	DWORD PTR _previous_char, eax

; 3147 :   if ( c == '\r' ) 

	cmp	eax, edi
	jne	SHORT $LN2@rawinput

; 3148 :      c = '\n';

	mov	eax, 10					; 0000000aH
$LN2@rawinput:

; 3149 : 
; 3150 :   errbuff[errspot++] = (char)c;

	mov	ecx, DWORD PTR _errspot
	mov	BYTE PTR _errbuff[ecx], al
	inc	ecx
	mov	DWORD PTR _errspot, ecx

; 3151 :   retval = c;

	mov	ebx, eax

; 3152 : 
; 3153 :   savein(retval);

	push	eax
$LN33@rawinput:
	call	_savein
	add	esp, 4

; 3154 : 
; 3155 : rawexit:
; 3156 :   if ( errspot >= ERRBUFFSIZE ) /* need partial reset */

	cmp	DWORD PTR _errspot, 80			; 00000050H
$rawexit$90600:

; 3159 :     }
; 3160 : 
; 3161 : rawreturn:
; 3162 :   return  retval;

	mov	eax, ebx
	jl	SHORT $rawreturn$90596

; 3157 :     { memcpy(errbuff,errbuff+ERRBUFFSIZE/2,ERRBUFFSIZE/2);

	mov	ecx, 10					; 0000000aH
	mov	esi, OFFSET _errbuff+40
	mov	edi, OFFSET _errbuff
	rep movsd
	pop	edi
	pop	esi

; 3158 :       errspot = ERRBUFFSIZE/2;

	mov	DWORD PTR _errspot, 40			; 00000028H
	pop	ebx

; 3163 : } // end rawinput()

	ret	0
$LN27@rawinput:

; 3104 :      { if ( previous_char != '\n' )

	mov	esi, 10					; 0000000aH
	cmp	DWORD PTR _previous_char, esi
	je	SHORT $LN14@rawinput

; 3105 :        { retval = previous_char = '\n';
; 3106 :          errbuff[errspot++] = retval; 

	mov	eax, DWORD PTR _errspot
	mov	BYTE PTR _errbuff[eax], 10		; 0000000aH
	inc	eax

; 3107 :          savein(retval);

	push	esi
	mov	DWORD PTR _previous_char, esi
	mov	DWORD PTR _errspot, eax
	call	_savein
	add	esp, 4
	pop	edi

; 3159 :     }
; 3160 : 
; 3161 : rawreturn:
; 3162 :   return  retval;

	mov	eax, esi
	pop	esi
	pop	ebx

; 3163 : } // end rawinput()

	ret	0
$LN28@rawinput:

; 3122 :        { if (!in_quote && !in_comment) errbuff[errspot++] = '\n';  

	cmp	DWORD PTR _in_quote, ebx
	jne	SHORT $LN10@rawinput
	cmp	DWORD PTR _in_comment, ebx
	jne	SHORT $LN10@rawinput
	mov	eax, DWORD PTR _errspot
	mov	BYTE PTR _errbuff[eax], 10		; 0000000aH
	inc	eax
	mov	DWORD PTR _errspot, eax
$LN10@rawinput:

; 3123 :          retval = '\n'; 

	mov	ebx, 10					; 0000000aH

; 3124 :          savein(retval);

	push	ebx

; 3125 :          goto rawexit; 

	jmp	$LN33@rawinput
_rawinput ENDP
_TEXT	ENDS
PUBLIC	??_C@_06EFMLOIIN@more?$DO?5?$AA@		; `string'
PUBLIC	_get_more_input
EXTRN	_catfulltext:PROC
EXTRN	_outstring:PROC
EXTRN	_quiet_load_flag:DWORD
EXTRN	_topflag:DWORD
;	COMDAT ??_C@_06EFMLOIIN@more?$DO?5?$AA@
CONST	SEGMENT
??_C@_06EFMLOIIN@more?$DO?5?$AA@ DB 'more> ', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_more_input
_TEXT	SEGMENT
_get_more_input PROC					; COMDAT

; 3172 :  #ifdef USE_READLINE //CSL
; 3173 :   prompt(MOREPROMPT,morebuff,MOREMAX);
; 3174 :  #else
; 3175 :   if ( !topflag && (!quiet_load_flag || (commandfd == stdin)) ) 

	cmp	DWORD PTR _topflag, 0
	jne	SHORT $LN3@get_more_i
	cmp	DWORD PTR _quiet_load_flag, 0
	je	SHORT $LN2@get_more_i
	call	___iob_func
	cmp	DWORD PTR _commandfd, eax
	jne	SHORT $LN3@get_more_i
$LN2@get_more_i:

; 3176 :      outstring("more> ");

	push	OFFSET ??_C@_06EFMLOIIN@more?$DO?5?$AA@
	call	_outstring
	add	esp, 4
$LN3@get_more_i:

; 3177 :   getstring(morebuff,MOREMAX);

	push	1000					; 000003e8H
	push	OFFSET _morebuff
	call	_getstring

; 3178 :  #endif
; 3179 :   n = (int)strlen(morebuff); 

	mov	eax, OFFSET _morebuff
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL6@get_more_i:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL6@get_more_i
	sub	eax, edx

; 3180 :   if ( (morebuff[n-1] != MOREIN) && (morebuff[n-1] != '\n') )

	mov	cl, BYTE PTR _morebuff[eax-1]
	cmp	cl, 1
	je	SHORT $LN1@get_more_i
	cmp	cl, 10					; 0000000aH
	je	SHORT $LN1@get_more_i

; 3181 :   morebuff[n] = '\n'; morebuff[n+1] = 0;

	mov	BYTE PTR _morebuff[eax], 10		; 0000000aH
$LN1@get_more_i:

; 3182 :   catfulltext(morebuff);

	push	OFFSET _morebuff
	mov	BYTE PTR _morebuff[eax+1], 0
	call	_catfulltext
	add	esp, 4

; 3183 :   cmdptr = morebuff;

	mov	DWORD PTR _cmdptr, OFFSET _morebuff

; 3184 : }

	ret	0
_get_more_input ENDP
_TEXT	ENDS
PUBLIC	_rawunput
; Function compile flags: /Ogtp
;	COMDAT _rawunput
_TEXT	SEGMENT
_c$ = 8							; size = 4
_rawunput PROC						; COMDAT

; 3231 : {

	push	ebp
	mov	ebp, esp

; 3232 :   if ( spot >= BUFFSIZE - 1 ) 

	mov	eax, DWORD PTR _BUFFSIZE
	mov	ecx, DWORD PTR _spot
	lea	edx, DWORD PTR [eax-1]
	cmp	ecx, edx
	jl	SHORT $LN4@rawunput

; 3233 :   { buff = my_list_realloc(buff,BUFFSIZE+500,ETERNAL_BLOCK);

	push	3233					; 00000ca1H
	push	OFFSET ??_C@_07HIIALNMO@LEXYY?4C?$AA@
	add	eax, 500				; 000001f4H
	push	60138					; 0000eaeaH
	push	eax
	mov	eax, DWORD PTR _buff
	push	eax
	call	_list_realloc

; 3234 :     BUFFSIZE += 500;
; 3235 :   }
; 3236 : 
; 3237 :   buff[spot++] = (char)c;

	mov	ecx, DWORD PTR _spot
	mov	dl, BYTE PTR _c$[ebp]
	add	DWORD PTR _BUFFSIZE, 500		; 000001f4H
	add	esp, 20					; 00000014H
	mov	BYTE PTR [eax+ecx], dl
	inc	ecx
	mov	DWORD PTR _buff, eax
	mov	DWORD PTR _spot, ecx

; 3238 : } // end rawunput()

	pop	ebp
	ret	0
$LN4@rawunput:

; 3234 :     BUFFSIZE += 500;
; 3235 :   }
; 3236 : 
; 3237 :   buff[spot++] = (char)c;

	mov	al, BYTE PTR _c$[ebp]
	mov	edx, DWORD PTR _buff
	mov	BYTE PTR [edx+ecx], al
	inc	ecx
	mov	DWORD PTR _spot, ecx

; 3238 : } // end rawunput()

	pop	ebp
	ret	0
_rawunput ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0BH@FPMNJDAM@?5?5Input?5line?5so?5far?3?5?6?$AA@ ; `string'
PUBLIC	_dump_buff
EXTRN	_strncat:PROC
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FPMNJDAM@?5?5Input?5line?5so?5far?3?5?6?$AA@
CONST	SEGMENT
??_C@_0BH@FPMNJDAM@?5?5Input?5line?5so?5far?3?5?6?$AA@ DB '  Input line s'
	DB	'o far: ', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _dump_buff
_TEXT	SEGMENT
_str$ = 8						; size = 4
_size$ = 12						; size = 4
_dump_buff PROC						; COMDAT

; 3258 : { int place;

	push	ebp
	mov	ebp, esp
	push	ebx

; 3259 :   strcpy(str,"  Input line so far: \n");

	mov	ebx, DWORD PTR _str$[ebp]
	push	esi
	push	edi
	mov	ecx, 5
	mov	esi, OFFSET ??_C@_0BH@FPMNJDAM@?5?5Input?5line?5so?5far?3?5?6?$AA@
	mov	edi, ebx
	rep movsd
	movsw

; 3260 :   size -= (int)strlen(str)+3;

	mov	eax, ebx
	movsb
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL12@dump_buff:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL12@dump_buff
	mov	esi, DWORD PTR _size$[ebp]
	sub	eax, edx
	mov	ecx, -3					; fffffffdH
	sub	ecx, eax
	add	esi, ecx

; 3261 :   errbuff[errspot] = 0;

	mov	ecx, DWORD PTR _errspot

; 3262 :   for ( place = errspot-1 ; place >= 0 ; place-- )

	lea	eax, DWORD PTR [ecx-1]
	mov	BYTE PTR _errbuff[ecx], 0
	test	eax, eax
	js	SHORT $LN10@dump_buff
	mov	dl, 32					; 00000020H
	npad	5
$LL6@dump_buff:

; 3263 :   { if (errbuff[place]==0 ) errbuff[place] = ' '; /* nulls creep in */ 

	cmp	BYTE PTR _errbuff[eax], 0
	jne	SHORT $LN3@dump_buff
	mov	BYTE PTR _errbuff[eax], dl
$LN3@dump_buff:

; 3264 :     if (errbuff[place]=='\n' && place < errspot-2) break;

	cmp	BYTE PTR _errbuff[eax], 10		; 0000000aH
	jne	SHORT $LN5@dump_buff
	lea	edi, DWORD PTR [ecx-2]
	cmp	eax, edi
	jl	SHORT $LN10@dump_buff
$LN5@dump_buff:

; 3262 :   for ( place = errspot-1 ; place >= 0 ; place-- )

	dec	eax
	jns	SHORT $LL6@dump_buff
$LN10@dump_buff:

; 3265 :   } 
; 3266 :   strncat(str,errbuff+place+1,size);

	push	esi
	lea	edx, DWORD PTR _errbuff[eax+1]
	push	edx
	push	ebx
	call	_strncat

; 3267 :   if ( str[strlen(str)-1] != '\n' ) strcat(str,"\n");

	mov	eax, ebx
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL13@dump_buff:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL13@dump_buff
	sub	eax, edx
	cmp	BYTE PTR [eax+ebx-1], 10		; 0000000aH
	je	SHORT $LN1@dump_buff
	lea	edi, DWORD PTR [ebx-1]
	npad	5
$LL14@dump_buff:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL14@dump_buff
	mov	ax, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@
	mov	WORD PTR [edi], ax
$LN1@dump_buff:
	pop	edi
	pop	esi
	pop	ebx

; 3268 : } // end dump_buff()

	pop	ebp
	ret	0
_dump_buff ENDP
_TEXT	ENDS
PUBLIC	_yywrap
EXTRN	_read_wrap_flag:DWORD
EXTRN	_help_flag:DWORD
EXTRN	_in_control_structure:DWORD
EXTRN	_in_function:DWORD
EXTRN	_brace_depth:DWORD
EXTRN	_parens:DWORD
; Function compile flags: /Ogtp
;	COMDAT _yywrap
_TEXT	SEGMENT
_yywrap	PROC						; COMDAT

; 3276 :   spot = 0; /* clean buffer */
; 3277 :   if ( (parens > 0) || (brace_depth > 0) || in_quote || in_comment 
; 3278 :          || in_function || in_control_structure /* || loopdepth */ )

	cmp	DWORD PTR _parens, 0
	mov	DWORD PTR _spot, 0
	jg	$LN9@yywrap
	cmp	DWORD PTR _brace_depth, 0
	jg	$LN9@yywrap
	cmp	DWORD PTR _in_quote, 0
	jne	$LN9@yywrap
	cmp	DWORD PTR _in_comment, 0
	jne	$LN9@yywrap
	cmp	DWORD PTR _in_function, 0
	jne	$LN9@yywrap
	cmp	DWORD PTR _in_control_structure, 0
	jne	SHORT $LN9@yywrap

; 3280 :   if ( !help_flag )

	cmp	DWORD PTR _help_flag, 0
	jne	SHORT $LN1@yywrap

; 3281 :     switch ( tok )

	mov	eax, DWORD PTR _tok
	cmp	eax, 316				; 0000013cH
	jg	SHORT $LN13@yywrap
	je	SHORT $LN9@yywrap
	sub	eax, 37					; 00000025H
	cmp	eax, 250				; 000000faH
	ja	SHORT $LN1@yywrap
	movzx	eax, BYTE PTR $LN15@yywrap[eax]
	jmp	DWORD PTR $LN18@yywrap[eax*4]
$LN5@yywrap:

; 3282 :     { case '+': case '-': case '*': /* might be wrap symbols */
; 3283 :         if ( read_wrap_flag ) return 1;

	cmp	DWORD PTR _read_wrap_flag, 0
	je	SHORT $LN9@yywrap
$LN1@yywrap:

; 3284 :         else { get_more_input(); return 0 ; }
; 3285 :         break;
; 3286 :       case UMINUS_TOK: case ',':
; 3287 :       case '=': case '?': case ':': case OR_TOK: case AND_TOK: case NOT_TOK:
; 3288 :       case EQ_TOK: case '>': case '<': case LE_TOK: case GE_TOK: case NE_TOK:
; 3289 :       case '/': case '%': case '^': case ON_CONSTRAINT_TOK: case VALUE_OF_CONSTRAINT_TOK:
; 3290 :       case HIT_CONSTRAINT_TOK: case ON_BOUNDARY_TOK: case DO_TOK: case FOR_TOK:
; 3291 :       case WHILE_TOK: case IF_TOK: case ELSE_TOK: case THEN_TOK: case SET_TOK:
; 3292 :       case DEFINE_TOK: case WHERE_TOK: case ASSIGN_TOK: case PERM_ASSIGN_TOK:
; 3293 :       case REDEFINE_TOK: case FUNCTION_TOK: case PROCEDURE_WORD_TOK:
; 3294 :       get_more_input(); return 0;
; 3295 :       break;
; 3296 :       default: return 1;

	mov	eax, 1

; 3297 :         }
; 3298 :   return 1;  /* done */
; 3299 : } // end yywrap()

	ret	0
$LN13@yywrap:

; 3281 :     switch ( tok )

	cmp	eax, 454				; 000001c6H
	jg	SHORT $LN14@yywrap
	cmp	eax, 452				; 000001c4H
	jge	SHORT $LN9@yywrap
	sub	eax, 323				; 00000143H
	cmp	eax, 118				; 00000076H
	ja	SHORT $LN1@yywrap
	movzx	ecx, BYTE PTR $LN16@yywrap[eax]
	jmp	DWORD PTR $LN19@yywrap[ecx*4]
$LN14@yywrap:
	sub	eax, 459				; 000001cbH
	cmp	eax, 124				; 0000007cH
	ja	SHORT $LN1@yywrap
	movzx	edx, BYTE PTR $LN17@yywrap[eax]
	jmp	DWORD PTR $LN20@yywrap[edx*4]
$LN9@yywrap:

; 3279 :     { get_more_input(); return 0; }

	call	_get_more_input
	xor	eax, eax

; 3297 :         }
; 3298 :   return 1;  /* done */
; 3299 : } // end yywrap()

	ret	0
$LN18@yywrap:
	DD	$LN9@yywrap
	DD	$LN5@yywrap
	DD	$LN1@yywrap
$LN15@yywrap:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	1
	DB	0
	DB	1
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	npad	1
$LN19@yywrap:
	DD	$LN9@yywrap
	DD	$LN1@yywrap
$LN16@yywrap:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	npad	1
$LN20@yywrap:
	DD	$LN9@yywrap
	DD	$LN1@yywrap
$LN17@yywrap:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
_yywrap	ENDP
_TEXT	ENDS
PUBLIC	_macro_init
EXTRN	_macro_count:DWORD
EXTRN	_macros:DWORD
EXTRN	_myfree:PROC
EXTRN	_macro_subs:DWORD
; Function compile flags: /Ogtp
;	COMDAT _macro_init
_TEXT	SEGMENT
_macro_init PROC					; COMDAT

; 3307 :   if ( macro_subs ) myfree((char *)macro_subs);

	mov	eax, DWORD PTR _macro_subs
	push	esi
	xor	esi, esi
	cmp	eax, esi
	je	SHORT $LN2@macro_init
	push	eax
	call	_myfree
	add	esp, 4
$LN2@macro_init:

; 3308 :   if ( macros ) myfree((char *)macros);

	mov	eax, DWORD PTR _macros
	cmp	eax, esi
	je	SHORT $LN1@macro_init
	push	eax
	call	_myfree
	add	esp, 4
$LN1@macro_init:

; 3309 :   macro_subs = NULL;

	mov	DWORD PTR _macro_subs, esi

; 3310 :   macros = NULL;

	mov	DWORD PTR _macros, esi

; 3311 :   macro_count = macro_subs_top = macro_max = macro_subs_max = 0;

	mov	DWORD PTR _macro_subs_max, esi
	mov	DWORD PTR _macro_max, esi
	mov	DWORD PTR _macro_subs_top, esi
	mov	DWORD PTR _macro_count, esi
	pop	esi

; 3312 : } // end macro_init()

	ret	0
_macro_init ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_yylex_init
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _yylex_init
_TEXT	SEGMENT
_yylex_init PROC					; COMDAT

; 3320 :   unput_tok_count = 0;
; 3321 :   ubuff_spot = 0;
; 3322 :   spot = 0;
; 3323 :   errspot = 0;
; 3324 :   yylval.i = 0;
; 3325 :   yylval.r = 0.0;

	fldz

; 3326 :   in_function = brace_depth = in_quote = in_comment = 0;
; 3327 : #ifdef FLEX_SCANNER
; 3328 :   if ( yy_current_buffer) YY_FLUSH_BUFFER;

	mov	ecx, DWORD PTR _yy_current_buffer
	xor	eax, eax
	fstp	QWORD PTR _yylval+16
	mov	DWORD PTR _unput_tok_count, eax
	mov	DWORD PTR _ubuff_spot, eax
	mov	DWORD PTR _spot, eax
	mov	DWORD PTR _errspot, eax
	mov	DWORD PTR _yylval, eax
	mov	DWORD PTR _in_comment, eax
	mov	DWORD PTR _in_quote, eax
	mov	DWORD PTR _brace_depth, eax
	mov	DWORD PTR _in_function, eax
	cmp	ecx, eax
	je	SHORT $LN1@yylex_init
	push	ecx
	call	_yy_flush_buffer
	pop	ecx
$LN1@yylex_init:

; 3329 : #endif
; 3330 : } // end yylex_init()

	ret	0
_yylex_init ENDP
_TEXT	ENDS
PUBLIC	_minus_type
; Function compile flags: /Ogtp
;	COMDAT _minus_type
_TEXT	SEGMENT
_c$ = 8							; size = 4
_minus_type PROC					; COMDAT

; 3457 : { int result;

	push	ebp
	mov	ebp, esp

; 3458 :   switch ( tok )

	mov	eax, DWORD PTR _tok
	cmp	eax, 370				; 00000172H
	jg	SHORT $LN7@minus_type
	cmp	eax, 369				; 00000171H
	jge	SHORT $LN2@minus_type
	cmp	eax, 93					; 0000005dH
	jg	SHORT $LN8@minus_type
	je	SHORT $LN2@minus_type
	cmp	eax, 41					; 00000029H
	je	SHORT $LN2@minus_type
$LN1@minus_type:

; 3459 :   {  case LEAD_INTEGER_TOK:
; 3460 :      case SIGNED_NUMBER_TOK:
; 3461 :      case INTEGER_TOK:
; 3462 :      case REAL_TOK:
; 3463 :      case PI_TOK:
; 3464 :      case E_TOK:
; 3465 :      case G_TOK:
; 3466 :      case PARAM_TOK: case ARRAYIDENT_TOK: case STRINGARRAY_TOK:
; 3467 :      case COORD_TOK: case VALUE_TOK: case BARE_TOK:
; 3468 :      case IDENT_TOK: case QUANTITY_NAME_TOK: case WRAP_TOK: case PERM_IDENT_TOK:
; 3469 :      case LENGTH_TOK: case DIHEDRAL_TOK: case VALENCE_TOK:
; 3470 :      case AREA_TOK: case VOLUME_TOK: case DENSITY_TOK: case TAG_TOK:
; 3471 :      case ID_TOK: case ORIGINAL_TOK: case SQ_MEAN_CURV_TOK:
; 3472 :      case OID_TOK: case INTERNAL_VARIABLE_TOK: case COLOR_TOK:
; 3473 :      case TOGGLEVALUE_TOK: case EXTRA_ATTRIBUTE_TOK: case PRESSURE_TOK:
; 3474 :      case ARRAY_ATTRIBUTE_TOK:
; 3475 :      case FRONTCOLOR_TOK: case BACKCOLOR_TOK: case TARGET_TOK:
; 3476 :      case NO_REFINE_TOK: case VOLCONST_TOK: case FRONTBODY_TOK: case NONCONTENT_TOK:
; 3477 :      case BACKBODY_TOK: case TETRA_POINT_TOK: case TRIPLE_POINT_TOK:
; 3478 :      case MIDV_TOK: case PHASE_TOK: case MODULUS_TOK: 
; 3479 :      case METHOD_NAME_TOK: case NODISPLAY_TOK: case HIT_PARTNER_TOK:
; 3480 :      case CENTEROFMASS_TOK:
; 3481 :      case ']': case ')':
; 3482 :         result = c; 
; 3483 :         break; 
; 3484 :      default: 
; 3485 :         result = (c=='-' ? UMINUS_TOK: UPLUS_TOK) ; 

	mov	eax, DWORD PTR _c$[ebp]
	sub	eax, 45					; 0000002dH
	neg	eax
	sbb	eax, eax
	and	eax, 70					; 00000046H
	add	eax, 287				; 0000011fH

; 3489 : } // end minus_type()

	pop	ebp
	ret	0
$LN8@minus_type:

; 3458 :   switch ( tok )

	sub	eax, 264				; 00000108H
	cmp	eax, 72					; 00000048H
	ja	SHORT $LN1@minus_type
	movzx	eax, BYTE PTR $LN9@minus_type[eax]
	jmp	DWORD PTR $LN11@minus_type[eax*4]
$LN7@minus_type:
	sub	eax, 399				; 0000018fH
	cmp	eax, 167				; 000000a7H
	ja	SHORT $LN1@minus_type
	movzx	ecx, BYTE PTR $LN10@minus_type[eax]
	jmp	DWORD PTR $LN12@minus_type[ecx*4]
$LN2@minus_type:

; 3486 :         break;
; 3487 :   }
; 3488 :   return result; 

	mov	eax, DWORD PTR _c$[ebp]

; 3489 : } // end minus_type()

	pop	ebp
	ret	0
	npad	3
$LN11@minus_type:
	DD	$LN2@minus_type
	DD	$LN1@minus_type
$LN9@minus_type:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	npad	3
$LN12@minus_type:
	DD	$LN2@minus_type
	DD	$LN1@minus_type
$LN10@minus_type:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_minus_type ENDP
_TEXT	ENDS
PUBLIC	_keyword_compare
EXTRN	_kb_stricmp:PROC
; Function compile flags: /Ogtp
;	COMDAT _keyword_compare
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_keyword_compare PROC					; COMDAT

; 3498 : { return stricmp(a->name,b->name); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	eax
	call	_kb_stricmp
	add	esp, 8
	pop	ebp
	ret	0
_keyword_compare ENDP
_TEXT	ENDS
PUBLIC	??_C@_04DOKPJKJF@HELP?$AA@			; `string'
PUBLIC	??_C@_0DP@CHCDDAG@Use?5of?5the?5keyword?5?8?$CFs?8?5as?5an?5id@ ; `string'
PUBLIC	??_C@_0BC@NDPAEDHG@f_constraint_list?$AA@	; `string'
PUBLIC	??_C@_0BE@PEKCNEI@__f_constraint_list?$AA@	; `string'
PUBLIC	??_C@_0BC@DJHGJOBE@e_constraint_list?$AA@	; `string'
PUBLIC	??_C@_0BE@OFMMPACK@__e_constraint_list?$AA@	; `string'
PUBLIC	??_C@_0BC@PNFDBPGO@v_constraint_list?$AA@	; `string'
PUBLIC	??_C@_0BE@CBOJHBFA@__v_constraint_list?$AA@	; `string'
PUBLIC	??_C@_0L@FBEPDDNP@v_velocity?$AA@		; `string'
PUBLIC	??_C@_0L@KMJOICIN@__velocity?$AA@		; `string'
PUBLIC	??_C@_07HDJNKPII@v_force?$AA@			; `string'
PUBLIC	??_C@_07JFKENGPF@__force?$AA@			; `string'
PUBLIC	??_C@_0N@NKPDEDNN@facet_normal?$AA@		; `string'
PUBLIC	??_C@_0P@KJNKFOHM@__facet_normal?$AA@		; `string'
PUBLIC	??_C@_0M@MONDCLHN@edge_vector?$AA@		; `string'
PUBLIC	??_C@_0O@DLNIAJPK@__edge_vector?$AA@		; `string'
PUBLIC	??_C@_0BA@BAIGEPJG@__vertex_normal?$AA@		; `string'
PUBLIC	??_C@_0O@LBCEPFPF@vertex_normal?$AA@		; `string'
PUBLIC	??_C@_03MJOELNDA@usr?$AA@			; `string'
PUBLIC	??_C@_06CHPMNBAB@_expr_?$AA@			; `string'
PUBLIC	??_C@_09GLBCIIDB@_command_?$AA@			; `string'
PUBLIC	_identcase
EXTRN	_add_global:PROC
EXTRN	_search_libraries:PROC
EXTRN	_lookup_global_hash:PROC
EXTRN	_symtable:BYTE
EXTRN	_yysym:DWORD
EXTRN	_symbol_lookup:PROC
EXTRN	_dymem:DWORD
EXTRN	_web:BYTE
EXTRN	_localbase:DWORD
EXTRN	_lookup_local_var:PROC
EXTRN	_datatype_name:BYTE
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
EXTRN	_backquote_flag:DWORD
EXTRN	_const_expr_flag:DWORD
EXTRN	_bsearch:PROC
EXTRN	_strncmp:PROC
EXTRN	_atoi:PROC
EXTRN	_isdigit:PROC
EXTRN	_single_redefine:BYTE
EXTRN	_strncpy:PROC
EXTRN	_idname:BYTE
EXTRN	_kb_upper_array:BYTE
EXTRN	_verb_flag:DWORD
EXTRN	_strtok:PROC
EXTRN	_qsort:PROC
;	COMDAT ??_C@_04DOKPJKJF@HELP?$AA@
CONST	SEGMENT
??_C@_04DOKPJKJF@HELP?$AA@ DB 'HELP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@CHCDDAG@Use?5of?5the?5keyword?5?8?$CFs?8?5as?5an?5id@
CONST	SEGMENT
??_C@_0DP@CHCDDAG@Use?5of?5the?5keyword?5?8?$CFs?8?5as?5an?5id@ DB 'Use o'
	DB	'f the keyword ''%s'' as an identifier is very ill-advised!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NDPAEDHG@f_constraint_list?$AA@
CONST	SEGMENT
??_C@_0BC@NDPAEDHG@f_constraint_list?$AA@ DB 'f_constraint_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PEKCNEI@__f_constraint_list?$AA@
CONST	SEGMENT
??_C@_0BE@PEKCNEI@__f_constraint_list?$AA@ DB '__f_constraint_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DJHGJOBE@e_constraint_list?$AA@
CONST	SEGMENT
??_C@_0BC@DJHGJOBE@e_constraint_list?$AA@ DB 'e_constraint_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OFMMPACK@__e_constraint_list?$AA@
CONST	SEGMENT
??_C@_0BE@OFMMPACK@__e_constraint_list?$AA@ DB '__e_constraint_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PNFDBPGO@v_constraint_list?$AA@
CONST	SEGMENT
??_C@_0BC@PNFDBPGO@v_constraint_list?$AA@ DB 'v_constraint_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CBOJHBFA@__v_constraint_list?$AA@
CONST	SEGMENT
??_C@_0BE@CBOJHBFA@__v_constraint_list?$AA@ DB '__v_constraint_list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FBEPDDNP@v_velocity?$AA@
CONST	SEGMENT
??_C@_0L@FBEPDDNP@v_velocity?$AA@ DB 'v_velocity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KMJOICIN@__velocity?$AA@
CONST	SEGMENT
??_C@_0L@KMJOICIN@__velocity?$AA@ DB '__velocity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HDJNKPII@v_force?$AA@
CONST	SEGMENT
??_C@_07HDJNKPII@v_force?$AA@ DB 'v_force', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JFKENGPF@__force?$AA@
CONST	SEGMENT
??_C@_07JFKENGPF@__force?$AA@ DB '__force', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NKPDEDNN@facet_normal?$AA@
CONST	SEGMENT
??_C@_0N@NKPDEDNN@facet_normal?$AA@ DB 'facet_normal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KJNKFOHM@__facet_normal?$AA@
CONST	SEGMENT
??_C@_0P@KJNKFOHM@__facet_normal?$AA@ DB '__facet_normal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MONDCLHN@edge_vector?$AA@
CONST	SEGMENT
??_C@_0M@MONDCLHN@edge_vector?$AA@ DB 'edge_vector', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DLNIAJPK@__edge_vector?$AA@
CONST	SEGMENT
??_C@_0O@DLNIAJPK@__edge_vector?$AA@ DB '__edge_vector', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BAIGEPJG@__vertex_normal?$AA@
CONST	SEGMENT
??_C@_0BA@BAIGEPJG@__vertex_normal?$AA@ DB '__vertex_normal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LBCEPFPF@vertex_normal?$AA@
CONST	SEGMENT
??_C@_0O@LBCEPFPF@vertex_normal?$AA@ DB 'vertex_normal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03MJOELNDA@usr?$AA@
CONST	SEGMENT
??_C@_03MJOELNDA@usr?$AA@ DB 'usr', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CHPMNBAB@_expr_?$AA@
CONST	SEGMENT
??_C@_06CHPMNBAB@_expr_?$AA@ DB '_expr_', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GLBCIIDB@_command_?$AA@
CONST	SEGMENT
??_C@_09GLBCIIDB@_command_?$AA@ DB '_command_', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _identcase
_TEXT	SEGMENT
_key$ = -12						; size = 8
_type$ = -4						; size = 4
_lexeme$ = 8						; size = 4
_identcase PROC						; COMDAT

; 3501 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 3502 :    int k,i;
; 3503 :    int type;
; 3504 :    struct sym *s;
; 3505 :    static int sorted = 0; /* flag for sorting keywords */
; 3506 :    struct ckey *keyptr;
; 3507 :    struct ckey key;  /* for bsearch key */
; 3508 :    char *c,*p;
; 3509 :    dll_func_type h;
; 3510 : 
; 3511 :    yylval.i = 0; 

	xor	edi, edi
	mov	DWORD PTR _yylval, edi

; 3512 : 
; 3513 :    if ( ! sorted )

	lea	esi, DWORD PTR [edi+1]
	cmp	DWORD PTR ?sorted@?1??identcase@@9@9, edi
	jne	$LN164@identcase

; 3514 :    { qsort((char*)datafile_keywords,
; 3515 :       sizeof(datafile_keywords)/ sizeof(struct dkey),sizeof(struct dkey),
; 3516 :       FCAST keyword_compare);

	push	OFFSET _keyword_compare
	push	8
	push	198					; 000000c6H
	push	OFFSET _datafile_keywords
	call	_qsort

; 3517 :      qsort((char*)command_keywords,
; 3518 :       sizeof(command_keywords)/ sizeof(struct ckey),sizeof(struct ckey),
; 3519 :       FCAST keyword_compare);

	push	OFFSET _keyword_compare
	push	8
	push	287					; 0000011fH
	push	OFFSET _command_keywords
	call	_qsort

; 3520 :      qsort((char*)togglenames,
; 3521 :       sizeof(togglenames)/ sizeof(struct ckey),sizeof(struct ckey),
; 3522 :       FCAST keyword_compare);

	push	OFFSET _keyword_compare
	push	8
	push	127					; 0000007fH
	push	OFFSET _togglenames
	call	_qsort

; 3523 :      qsort((char*)colornames,
; 3524 :       sizeof(colornames)/ sizeof(struct ckey),sizeof(struct ckey),
; 3525 :       FCAST keyword_compare);

	push	OFFSET _keyword_compare
	push	8
	push	22					; 00000016H
	push	OFFSET _colornames
	call	_qsort
	add	esp, 64					; 00000040H

; 3526 :      qsort((char*)internal_variables,
; 3527 :       sizeof(internal_variables)/ sizeof(struct ckey),sizeof(struct ckey),
; 3528 :       FCAST keyword_compare);

	push	OFFSET _keyword_compare
	push	8
	push	114					; 00000072H
	push	OFFSET _internal_variables
	call	_qsort

; 3529 :      qsort((char*)mathfunc_keywords,
; 3530 :       sizeof(mathfunc_keywords)/ sizeof(struct ckey),sizeof(struct ckey),
; 3531 :       FCAST keyword_compare);

	push	OFFSET _keyword_compare
	push	8
	push	22					; 00000016H
	push	OFFSET _mathfunc_keywords
	call	_qsort

; 3532 :      qsort((char*)mathfunc2_keywords,
; 3533 :       sizeof(mathfunc2_keywords)/ sizeof(struct ckey),sizeof(struct ckey),
; 3534 :       FCAST keyword_compare);

	push	OFFSET _keyword_compare
	push	8
	push	7
	push	OFFSET _mathfunc2_keywords
	call	_qsort
	add	esp, 48					; 00000030H

; 3535 :      sorted = 1;

	mov	DWORD PTR ?sorted@?1??identcase@@9@9, esi
$LN164@identcase:

; 3536 :    }
; 3537 : 
; 3538 :    if ( strcmp(lexeme,"_command_") == 0 )  { return tok = COMMAND_START_TOK; }

	mov	ebx, DWORD PTR _lexeme$[ebp]
	mov	ecx, OFFSET ??_C@_09GLBCIIDB@_command_?$AA@
	mov	eax, ebx
$LL211@identcase:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN212@identcase
	test	dl, dl
	je	SHORT $LN213@identcase
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN212@identcase
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL211@identcase
$LN213@identcase:
	xor	eax, eax
	jmp	SHORT $LN214@identcase
$LN212@identcase:
	sbb	eax, eax
	sbb	eax, -1
$LN214@identcase:
	cmp	eax, edi
	jne	SHORT $LN163@identcase
	pop	edi
	mov	eax, 259				; 00000103H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN163@identcase:

; 3539 :    if ( strcmp(lexeme,"_expr_") == 0 )   { return tok = EXPRESSION_START_TOK; }

	mov	ecx, OFFSET ??_C@_06CHPMNBAB@_expr_?$AA@
	mov	eax, ebx
$LL215@identcase:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN216@identcase
	test	dl, dl
	je	SHORT $LN217@identcase
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN216@identcase
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL215@identcase
$LN217@identcase:
	xor	eax, eax
	jmp	SHORT $LN218@identcase
$LN216@identcase:
	sbb	eax, eax
	sbb	eax, -1
$LN218@identcase:
	cmp	eax, edi
	jne	SHORT $LN162@identcase
	pop	edi
	mov	eax, 258				; 00000102H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN162@identcase:

; 3540 : 
; 3541 :    /* strip whitespace from front of lexeme */
; 3542 :    c = strtok(lexeme,whitespace);

	mov	eax, DWORD PTR _whitespace
	push	eax
	push	ebx
	call	_strtok
	add	esp, 8

; 3543 :    if ( c != lexeme ) { p = lexeme;  while ( *c )  *(p++) = *(c++); *p = 0;}

	cmp	eax, ebx
	je	SHORT $LN161@identcase
	mov	cl, BYTE PTR [eax]
	mov	edx, ebx
	test	cl, cl
	je	SHORT $LN159@identcase
	sub	eax, ebx
	npad	7
$LL160@identcase:
	mov	BYTE PTR [edx], cl
	add	edx, esi
	mov	cl, BYTE PTR [eax+edx]
	test	cl, cl
	jne	SHORT $LL160@identcase
$LN159@identcase:
	mov	BYTE PTR [edx], 0
$LN161@identcase:

; 3544 : 
; 3545 :    if ( strlen(lexeme) == 1 )

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL219@identcase:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL219@identcase
	sub	eax, edx
	cmp	eax, esi
	jne	$LN145@identcase

; 3546 :    { char ch = lexeme[0];
; 3547 :      if ( verb_flag == 1 || // tok==PRINT_TOK||
; 3548 :        (verb_flag == 2 && (toupper(ch) < 'W'))  )

	mov	ecx, DWORD PTR _verb_flag
	cmp	ecx, esi
	je	$LN156@identcase
	cmp	ecx, 2
	jne	SHORT $LN157@identcase
	movsx	edx, BYTE PTR [ebx]
	cmp	BYTE PTR _kb_upper_array[edx], 87	; 00000057H
	jl	SHORT $LN156@identcase
$LN157@identcase:

; 3558 :          default: return ( tok = SINGLE_LETTER_TOK);
; 3559 :        } 
; 3560 :      }
; 3561 :      else 
; 3562 :       switch ( toupper(lexeme[0]) )

	movsx	eax, BYTE PTR [ebx]
	mov	al, BYTE PTR _kb_upper_array[eax]
	cmp	al, 80					; 00000050H
	je	SHORT $LN143@identcase
	lea	ecx, DWORD PTR [eax-87]
	cmp	cl, 3
	ja	$LN145@identcase

; 3563 :       { case 'X': case 'Y': case 'Z': case 'W':
; 3564 :           yylval.i = ((toupper(lexeme[0]) - 'X' + 4) % 4) + 1;

	movsx	edx, al
	sub	edx, 84					; 00000054H
	and	edx, -2147483645			; 80000003H
	jns	SHORT $LN268@identcase
	dec	edx
	or	edx, -4					; fffffffcH
	inc	edx
$LN268@identcase:
	add	edx, esi
	mov	DWORD PTR _yylval, edx
$LN281@identcase:

; 3565 :           return COORD_TOK;

	pop	edi
	pop	esi
	mov	eax, 321				; 00000141H
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN143@identcase:

; 3566 :         case 'P':
; 3567 :         { strncpy(idname,lexeme,sizeof(idname)); /* save text */

	push	35					; 00000023H
	push	ebx
	push	OFFSET _idname
	call	_strncpy
	add	esp, 12					; 0000000cH

; 3568 :           yylval.qnum = V_PARAM_ATTR;
; 3569 :           yylval.etype = VERTEX;

	mov	DWORD PTR _yylval+24, edi
	pop	edi

; 3570 :           yylval.i = 1;

	mov	DWORD PTR _yylval, esi

; 3571 :           return tok = ARRAY_ATTRIBUTE_TOK; 

	mov	eax, 566				; 00000236H
	pop	esi
	mov	DWORD PTR _yylval+4, 2

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN156@identcase:

; 3549 :      { yylval.i=lexeme[0]; 

	movsx	eax, BYTE PTR [ebx]

; 3550 :        if ( single_redefine[yylval.i].start ) return tok = SINGLE_REDEFD_TOK;

	mov	edx, eax
	imul	edx, 104				; 00000068H
	mov	DWORD PTR _yylval, eax
	cmp	DWORD PTR _single_redefine[edx], edi
	je	SHORT $LN155@identcase
	pop	edi
	mov	eax, 413				; 0000019dH
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN155@identcase:

; 3551 :        switch ( yylval.i )

	add	eax, -71				; ffffffb9H
	cmp	eax, 50					; 00000032H
	ja	$LN149@identcase
	movzx	eax, BYTE PTR $LN220@identcase[eax]
	jmp	DWORD PTR $LN282@identcase[eax*4]
$LN152@identcase:
	pop	edi

; 3552 :        { case 't': case 'l': case 'j': case 'P': case 'M':
; 3553 :          case 'w': case 'n': case 'm':  case 'b':
; 3554 :          case 'k': case 'K': case 'p': case 'y': case 'q':
; 3555 :            return ( tok = SINGLE_LETTER_ARG_TOK);

	mov	eax, 417				; 000001a1H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN151@identcase:

; 3556 :            case 'G': if ( verb_flag ) return ( tok = SINGLE_LETTER_ARG_TOK);

	cmp	ecx, edi
	jne	SHORT $LN152@identcase

; 3557 :          else return tok=G_TOK;

	pop	edi
	mov	eax, 280				; 00000118H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN145@identcase:

; 3572 :         }
; 3573 :       }
; 3574 :     }
; 3575 : 
; 3576 :     // x1, x2, ... form of coordinates
; 3577 :     if ( toupper(lexeme[0]) == 'X' )

	movsx	ecx, BYTE PTR [ebx]
	cmp	BYTE PTR _kb_upper_array[ecx], 88	; 00000058H
	jne	SHORT $LN137@identcase

; 3578 :     { char *c;
; 3579 :       for ( c = lexeme+1 ; isdigit(*c) ; c++ ) ;

	lea	edi, DWORD PTR [ebx+1]
	mov	esi, edi
	movsx	edx, BYTE PTR [esi]
	push	edx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN139@identcase
$LL141@identcase:
	movsx	eax, BYTE PTR [esi+1]
	inc	esi
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LL141@identcase
$LN139@identcase:

; 3580 :       if ( *c == 0 )

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN137@identcase

; 3581 :       { yylval.i = atoi(lexeme+1);

	push	edi
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _yylval, eax

; 3582 :         if ( yylval.i != 0 )

	test	eax, eax

; 3583 :           return COORD_TOK;

	jne	$LN281@identcase
$LN137@identcase:

; 3584 :       }
; 3585 :     }
; 3586 : 
; 3587 :     // parameter names p1, p2, ...
; 3588 :     if ( toupper(lexeme[0]) == 'P' && isdigit(lexeme[1]) && !lexeme[2] )

	movsx	ecx, BYTE PTR [ebx]
	cmp	BYTE PTR _kb_upper_array[ecx], 80	; 00000050H
	jne	SHORT $LN136@identcase
	movsx	edx, BYTE PTR [ebx+1]
	lea	esi, DWORD PTR [ebx+1]
	push	edx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN136@identcase
	cmp	BYTE PTR [ebx+2], 0
	jne	SHORT $LN136@identcase

; 3589 :     { yylval.i = atoi(lexeme+1);

	push	esi
	call	_atoi
	add	esp, 4
	pop	edi
	pop	esi
	mov	DWORD PTR _yylval, eax

; 3590 :       return PARAM_TOK;

	mov	eax, 281				; 00000119H
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN136@identcase:

; 3591 :     }
; 3592 : 
; 3593 :     // special gn kludge
; 3594 :     if ( lexeme[0] == 'g' )

	cmp	BYTE PTR [ebx], 103			; 00000067H
	jne	SHORT $LN131@identcase

; 3595 :     { char *c;
; 3596 :       for ( c = lexeme+1 ; isdigit(*c) ; c++ ) ;

	lea	edi, DWORD PTR [ebx+1]
	mov	esi, edi
	movsx	eax, BYTE PTR [esi]
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN132@identcase
$LL134@identcase:
	movsx	ecx, BYTE PTR [esi+1]
	inc	esi
	push	ecx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LL134@identcase
$LN132@identcase:

; 3597 :       if ( *c == 0 )

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN131@identcase

; 3598 :       { yylval.i = atoi(lexeme+1);

	push	edi
	call	_atoi
	add	esp, 4
	pop	edi
	pop	esi
	mov	DWORD PTR _yylval, eax

; 3599 :         return GO_COUNT_TOK;

	mov	eax, 536				; 00000218H
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN131@identcase:

; 3600 :       }
; 3601 :     }
; 3602 : 
; 3603 :     if ( strncmp(lexeme,"usr",3) == 0 )

	push	3
	push	OFFSET ??_C@_03MJOELNDA@usr?$AA@
	push	ebx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN126@identcase

; 3604 :     { char *c;
; 3605 :       for ( c = lexeme+3 ; isdigit(*c) ; c++ ) ;

	lea	edi, DWORD PTR [ebx+3]
	mov	esi, edi
	movsx	edx, BYTE PTR [esi]
	push	edx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN127@identcase
$LL129@identcase:
	movsx	eax, BYTE PTR [esi+1]
	inc	esi
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LL129@identcase
$LN127@identcase:

; 3606 :       if ( *c == 0 )

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN126@identcase

; 3607 :       { yylval.i = atoi(lexeme+3);

	push	edi
	call	_atoi
	add	esp, 4
	pop	edi
	pop	esi
	mov	DWORD PTR _yylval, eax

; 3608 :         return USERFUNC_TOK;

	mov	eax, 274				; 00000112H
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN126@identcase:

; 3609 :       }
; 3610 :     }
; 3611 :  
; 3612 :     key.name = lexeme;
; 3613 : 
; 3614 : #define BSEARCH(namelist)\
; 3615 :     (struct ckey*)bsearch((char*)&key,(char*)(namelist),\
; 3616 :          sizeof(namelist)/sizeof(struct ckey),\
; 3617 :           sizeof(struct ckey),FCAST keyword_compare);
; 3618 : 
; 3619 :     keyptr = BSEARCH(colornames);

	push	OFFSET _keyword_compare
	push	8
	push	22					; 00000016H
	lea	ecx, DWORD PTR _key$[ebp]
	push	OFFSET _colornames
	push	ecx
	mov	DWORD PTR _key$[ebp], ebx
	call	_bsearch
	add	esp, 20					; 00000014H

; 3620 :     if ( keyptr )

	test	eax, eax
	je	SHORT $LN125@identcase

; 3621 :         { yylval.r = yylval.i = keyptr->token;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _yylval, edx
	fild	DWORD PTR _yylval
	pop	edi

; 3622 :           return (tok = INTEGER_TOK);

	mov	eax, 265				; 00000109H
	pop	esi
	fstp	QWORD PTR _yylval+16

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN125@identcase:

; 3623 :         }
; 3624 :     /* search math funcs */
; 3625 :     keyptr = BSEARCH(mathfunc_keywords);

	push	OFFSET _keyword_compare
	push	8
	push	22					; 00000016H
	lea	eax, DWORD PTR _key$[ebp]
	push	OFFSET _mathfunc_keywords
	push	eax
	call	_bsearch
	add	esp, 20					; 00000014H

; 3626 :     if ( keyptr ) {  yylval.i = keyptr->token; return (tok = MATHFUNC_TOK); }

	test	eax, eax
	je	SHORT $LN124@identcase
	mov	ecx, DWORD PTR [eax+4]
	pop	edi
	mov	eax, 270				; 0000010eH
	pop	esi
	mov	DWORD PTR _yylval, ecx

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN124@identcase:

; 3627 : 
; 3628 :     keyptr = BSEARCH(mathfunc2_keywords);

	push	OFFSET _keyword_compare
	push	8
	push	7
	lea	edx, DWORD PTR _key$[ebp]
	push	OFFSET _mathfunc2_keywords
	push	edx
	call	_bsearch
	add	esp, 20					; 00000014H

; 3629 :     if ( keyptr ) {  yylval.i  = keyptr->token; return (tok = MATHFUNC2_TOK); }

	test	eax, eax
	je	SHORT $LN123@identcase
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	mov	DWORD PTR _yylval, eax
	mov	eax, 271				; 0000010fH
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN123@identcase:

; 3630 : 
; 3631 :     if ( const_expr_flag )

	cmp	DWORD PTR _const_expr_flag, 0
	je	SHORT $LN119@identcase

; 3632 :     { for ( k=0 ; k<sizeof(const_expr_keywords)/ sizeof(struct ckey) ; k++ )

	xor	esi, esi
$LL121@identcase:

; 3633 :       if (stricmp(lexeme,const_expr_keywords[k].name)==0)

	mov	ecx, DWORD PTR _const_expr_keywords[esi*8]
	push	ecx
	push	ebx
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN200@identcase

; 3632 :     { for ( k=0 ; k<sizeof(const_expr_keywords)/ sizeof(struct ckey) ; k++ )

	inc	esi
	cmp	esi, 3
	jb	SHORT $LL121@identcase
$LN119@identcase:

; 3635 :     }
; 3636 : 
; 3637 :     /* kludges for some backward compatibility */
; 3638 :     if ( strcmp(lexeme,"vertexnormal") == 0 )

	mov	ecx, OFFSET ??_C@_0N@ICOOBCNI@vertexnormal?$AA@
	mov	eax, ebx
$LL221@identcase:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN222@identcase
	test	dl, dl
	je	SHORT $LN260@identcase
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN222@identcase
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL221@identcase
$LN260@identcase:
	xor	eax, eax
	jmp	SHORT $LN224@identcase
$LN200@identcase:

; 3634 :            return (tok = const_expr_keywords[k].token);

	mov	eax, DWORD PTR _const_expr_keywords[esi*8+4]
	pop	edi
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN222@identcase:

; 3635 :     }
; 3636 : 
; 3637 :     /* kludges for some backward compatibility */
; 3638 :     if ( strcmp(lexeme,"vertexnormal") == 0 )

	sbb	eax, eax
	sbb	eax, -1
$LN224@identcase:
	test	eax, eax
	jne	SHORT $LN117@identcase

; 3639 :       strcpy(lexeme,"vertex_normal");

	mov	edx, DWORD PTR ??_C@_0O@LBCEPFPF@vertex_normal?$AA@
	mov	DWORD PTR [ebx], edx
	mov	eax, DWORD PTR ??_C@_0O@LBCEPFPF@vertex_normal?$AA@+4
	mov	DWORD PTR [ebx+4], eax
	mov	ecx, DWORD PTR ??_C@_0O@LBCEPFPF@vertex_normal?$AA@+8
	mov	DWORD PTR [ebx+8], ecx
	mov	dx, WORD PTR ??_C@_0O@LBCEPFPF@vertex_normal?$AA@+12
	mov	WORD PTR [ebx+12], dx
$LN117@identcase:

; 3640 :     if ( lexeme[0] == '_' )

	cmp	BYTE PTR [ebx], 95			; 0000005fH
	jne	$LN108@identcase

; 3641 :     {
; 3642 :       if ( strcmp(lexeme,"__vertex_normal") == 0 )

	mov	ecx, OFFSET ??_C@_0BA@BAIGEPJG@__vertex_normal?$AA@
	mov	eax, ebx
$LL225@identcase:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN226@identcase
	test	dl, dl
	je	SHORT $LN261@identcase
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN226@identcase
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL225@identcase
$LN261@identcase:
	xor	eax, eax
	jmp	SHORT $LN228@identcase
$LN226@identcase:
	sbb	eax, eax
	sbb	eax, -1
$LN228@identcase:
	test	eax, eax
	jne	SHORT $LN115@identcase

; 3643 :         strcpy(lexeme,"vertex_normal");

	mov	eax, DWORD PTR ??_C@_0O@LBCEPFPF@vertex_normal?$AA@
	mov	DWORD PTR [ebx], eax
	mov	ecx, DWORD PTR ??_C@_0O@LBCEPFPF@vertex_normal?$AA@+4
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR ??_C@_0O@LBCEPFPF@vertex_normal?$AA@+8
	mov	DWORD PTR [ebx+8], edx
	mov	ax, WORD PTR ??_C@_0O@LBCEPFPF@vertex_normal?$AA@+12
	mov	WORD PTR [ebx+12], ax
$LN115@identcase:

; 3644 :       if ( strcmp(lexeme,"__edge_vector") == 0 )

	mov	ecx, OFFSET ??_C@_0O@DLNIAJPK@__edge_vector?$AA@
	mov	eax, ebx
	npad	7
$LL229@identcase:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN230@identcase
	test	dl, dl
	je	SHORT $LN262@identcase
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN230@identcase
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL229@identcase
$LN262@identcase:
	xor	eax, eax
	jmp	SHORT $LN232@identcase
$LN230@identcase:
	sbb	eax, eax
	sbb	eax, -1
$LN232@identcase:
	test	eax, eax
	jne	SHORT $LN114@identcase

; 3645 :         strcpy(lexeme,"edge_vector");

	mov	ecx, DWORD PTR ??_C@_0M@MONDCLHN@edge_vector?$AA@
	mov	DWORD PTR [ebx], ecx
	mov	edx, DWORD PTR ??_C@_0M@MONDCLHN@edge_vector?$AA@+4
	mov	DWORD PTR [ebx+4], edx
	mov	eax, DWORD PTR ??_C@_0M@MONDCLHN@edge_vector?$AA@+8
	mov	DWORD PTR [ebx+8], eax
$LN114@identcase:

; 3646 :       if ( strcmp(lexeme,"__facet_normal") == 0 )

	mov	ecx, OFFSET ??_C@_0P@KJNKFOHM@__facet_normal?$AA@
	mov	eax, ebx
	npad	7
$LL233@identcase:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN234@identcase
	test	dl, dl
	je	SHORT $LN263@identcase
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN234@identcase
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL233@identcase
$LN263@identcase:
	xor	eax, eax
	jmp	SHORT $LN236@identcase
$LN234@identcase:
	sbb	eax, eax
	sbb	eax, -1
$LN236@identcase:
	test	eax, eax
	jne	SHORT $LN113@identcase

; 3647 :         strcpy(lexeme,"facet_normal");

	mov	ecx, DWORD PTR ??_C@_0N@NKPDEDNN@facet_normal?$AA@
	mov	DWORD PTR [ebx], ecx
	mov	edx, DWORD PTR ??_C@_0N@NKPDEDNN@facet_normal?$AA@+4
	mov	DWORD PTR [ebx+4], edx
	mov	eax, DWORD PTR ??_C@_0N@NKPDEDNN@facet_normal?$AA@+8
	mov	DWORD PTR [ebx+8], eax
	mov	cl, BYTE PTR ??_C@_0N@NKPDEDNN@facet_normal?$AA@+12
	mov	BYTE PTR [ebx+12], cl
$LN113@identcase:

; 3648 :       if ( strcmp(lexeme,"__force") == 0 )

	mov	ecx, OFFSET ??_C@_07JFKENGPF@__force?$AA@
	mov	eax, ebx
$LL237@identcase:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN238@identcase
	test	dl, dl
	je	SHORT $LN264@identcase
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN238@identcase
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL237@identcase
$LN264@identcase:
	xor	eax, eax
	jmp	SHORT $LN240@identcase
$LN238@identcase:
	sbb	eax, eax
	sbb	eax, -1
$LN240@identcase:
	test	eax, eax
	jne	SHORT $LN112@identcase

; 3649 :         strcpy(lexeme,"v_force");

	mov	edx, DWORD PTR ??_C@_07HDJNKPII@v_force?$AA@
	mov	DWORD PTR [ebx], edx
	mov	eax, DWORD PTR ??_C@_07HDJNKPII@v_force?$AA@+4
	mov	DWORD PTR [ebx+4], eax
$LN112@identcase:

; 3650 :       if ( strcmp(lexeme,"__velocity") == 0 )

	mov	ecx, OFFSET ??_C@_0L@KMJOICIN@__velocity?$AA@
	mov	eax, ebx
$LL241@identcase:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN242@identcase
	test	dl, dl
	je	SHORT $LN265@identcase
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN242@identcase
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL241@identcase
$LN265@identcase:
	xor	eax, eax
	jmp	SHORT $LN244@identcase
$LN242@identcase:
	sbb	eax, eax
	sbb	eax, -1
$LN244@identcase:
	test	eax, eax
	jne	SHORT $LN111@identcase

; 3651 :         strcpy(lexeme,"v_velocity");

	mov	ecx, DWORD PTR ??_C@_0L@FBEPDDNP@v_velocity?$AA@
	mov	DWORD PTR [ebx], ecx
	mov	edx, DWORD PTR ??_C@_0L@FBEPDDNP@v_velocity?$AA@+4
	mov	DWORD PTR [ebx+4], edx
	mov	ax, WORD PTR ??_C@_0L@FBEPDDNP@v_velocity?$AA@+8
	mov	WORD PTR [ebx+8], ax
	mov	cl, BYTE PTR ??_C@_0L@FBEPDDNP@v_velocity?$AA@+10
	mov	BYTE PTR [ebx+10], cl
$LN111@identcase:

; 3652 :       if ( strcmp(lexeme,"__v_constraint_list") == 0 )

	mov	ecx, OFFSET ??_C@_0BE@CBOJHBFA@__v_constraint_list?$AA@
	mov	eax, ebx
$LL245@identcase:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN246@identcase
	test	dl, dl
	je	SHORT $LN266@identcase
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN246@identcase
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL245@identcase
$LN266@identcase:
	xor	eax, eax
	jmp	SHORT $LN248@identcase
$LN246@identcase:
	sbb	eax, eax
	sbb	eax, -1
$LN248@identcase:
	test	eax, eax
	jne	SHORT $LN110@identcase

; 3653 :         strcpy(lexeme,"v_constraint_list");

	mov	edx, DWORD PTR ??_C@_0BC@PNFDBPGO@v_constraint_list?$AA@
	mov	DWORD PTR [ebx], edx
	mov	eax, DWORD PTR ??_C@_0BC@PNFDBPGO@v_constraint_list?$AA@+4
	mov	DWORD PTR [ebx+4], eax
	mov	ecx, DWORD PTR ??_C@_0BC@PNFDBPGO@v_constraint_list?$AA@+8
	mov	DWORD PTR [ebx+8], ecx
	mov	edx, DWORD PTR ??_C@_0BC@PNFDBPGO@v_constraint_list?$AA@+12
	mov	DWORD PTR [ebx+12], edx
	mov	ax, WORD PTR ??_C@_0BC@PNFDBPGO@v_constraint_list?$AA@+16
	mov	WORD PTR [ebx+16], ax
$LN110@identcase:

; 3654 :       if ( strcmp(lexeme,"__e_constraint_list") == 0 )

	mov	ecx, OFFSET ??_C@_0BE@OFMMPACK@__e_constraint_list?$AA@
	mov	eax, ebx
$LL249@identcase:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN250@identcase
	test	dl, dl
	je	SHORT $LN267@identcase
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN250@identcase
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL249@identcase
$LN267@identcase:
	xor	eax, eax
	jmp	SHORT $LN252@identcase
$LN250@identcase:
	sbb	eax, eax
	sbb	eax, -1
$LN252@identcase:
	test	eax, eax
	jne	SHORT $LN109@identcase

; 3655 :         strcpy(lexeme,"e_constraint_list");

	mov	ecx, DWORD PTR ??_C@_0BC@DJHGJOBE@e_constraint_list?$AA@
	mov	DWORD PTR [ebx], ecx
	mov	edx, DWORD PTR ??_C@_0BC@DJHGJOBE@e_constraint_list?$AA@+4
	mov	DWORD PTR [ebx+4], edx
	mov	eax, DWORD PTR ??_C@_0BC@DJHGJOBE@e_constraint_list?$AA@+8
	mov	DWORD PTR [ebx+8], eax
	mov	ecx, DWORD PTR ??_C@_0BC@DJHGJOBE@e_constraint_list?$AA@+12
	mov	DWORD PTR [ebx+12], ecx
	mov	dx, WORD PTR ??_C@_0BC@DJHGJOBE@e_constraint_list?$AA@+16
	mov	WORD PTR [ebx+16], dx
$LN109@identcase:

; 3656 :       if ( strcmp(lexeme,"__f_constraint_list") == 0 )

	mov	ecx, OFFSET ??_C@_0BE@PEKCNEI@__f_constraint_list?$AA@
	mov	eax, ebx
	npad	1
$LL253@identcase:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN254@identcase
	test	dl, dl
	je	SHORT $LN255@identcase
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN254@identcase
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL253@identcase
$LN255@identcase:
	xor	eax, eax
	jmp	SHORT $LN256@identcase
$LN254@identcase:
	sbb	eax, eax
	sbb	eax, -1
$LN256@identcase:
	test	eax, eax
	jne	SHORT $LN108@identcase

; 3657 :         strcpy(lexeme,"f_constraint_list");

	mov	eax, DWORD PTR ??_C@_0BC@NDPAEDHG@f_constraint_list?$AA@
	mov	DWORD PTR [ebx], eax
	mov	ecx, DWORD PTR ??_C@_0BC@NDPAEDHG@f_constraint_list?$AA@+4
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR ??_C@_0BC@NDPAEDHG@f_constraint_list?$AA@+8
	mov	DWORD PTR [ebx+8], edx
	mov	eax, DWORD PTR ??_C@_0BC@NDPAEDHG@f_constraint_list?$AA@+12
	mov	DWORD PTR [ebx+12], eax
	mov	cx, WORD PTR ??_C@_0BC@NDPAEDHG@f_constraint_list?$AA@+16
	mov	WORD PTR [ebx+16], cx
$LN108@identcase:

; 3658 :      }
; 3659 :      
; 3660 :     if ( datafile_flag && !backquote_flag )

	cmp	DWORD PTR _datafile_flag, 0
	je	$LN107@identcase
	cmp	DWORD PTR _backquote_flag, 0
	jne	$LN107@identcase

; 3661 :     { keyptr = BSEARCH(datafile_keywords);

	push	OFFSET _keyword_compare
	push	8
	push	198					; 000000c6H
	lea	edx, DWORD PTR _key$[ebp]
	push	OFFSET _datafile_keywords
	push	edx
	call	_bsearch
	add	esp, 20					; 00000014H

; 3662 :       if ( keyptr ) {  return tok = keyptr->token;}

	test	eax, eax
	je	SHORT $LN106@identcase
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN106@identcase:

; 3663 :       keyptr = BSEARCH(command_keywords);

	push	OFFSET _keyword_compare
	push	8
	push	287					; 0000011fH
	lea	eax, DWORD PTR _key$[ebp]
	push	OFFSET _command_keywords
	push	eax
	call	_bsearch
	add	esp, 20					; 00000014H

; 3664 :       if ( keyptr ) 

	test	eax, eax
	je	SHORT $LN103@identcase

; 3665 :       { sprintf(errmsg,
; 3666 :          "Use of the keyword '%s' as an identifier is very ill-advised!\n",
; 3667 :            lexeme);

	push	ebx
	push	OFFSET ??_C@_0DP@CHCDDAG@Use?5of?5the?5keyword?5?8?$CFs?8?5as?5an?5id@
	push	OFFSET _errmsg
	call	_sprintf

; 3668 :         kb_error(2328,errmsg, WARNING);

	push	2
	push	OFFSET _errmsg
	push	2328					; 00000918H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN103@identcase:

; 3698 :                       verb_flag = 0;
; 3699 :                       break;
; 3700 :         }
; 3701 :          return tok;
; 3702 :       }
; 3703 :      }
; 3704 : 
; 3705 :     for ( i = 0 ; i < NUMDATATYPES ; i++ )

	xor	edi, edi
	xor	esi, esi
	npad	8
$LL93@identcase:

; 3706 :       if ( stricmp(lexeme,datatype_name[i]) == 0 )

	mov	eax, DWORD PTR _datatype_name[esi*4]
	push	eax
	push	ebx
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	$LN201@identcase

; 3698 :                       verb_flag = 0;
; 3699 :                       break;
; 3700 :         }
; 3701 :          return tok;
; 3702 :       }
; 3703 :      }
; 3704 : 
; 3705 :     for ( i = 0 ; i < NUMDATATYPES ; i++ )

	inc	esi
	cmp	esi, 25					; 00000019H
	jl	SHORT $LL93@identcase

; 3709 :         return tok = DATATYPE_TOK;
; 3710 :       }
; 3711 : 
; 3712 :     keyptr = BSEARCH(togglenames);

	push	OFFSET _keyword_compare
	push	8
	push	127					; 0000007fH
	lea	ecx, DWORD PTR _key$[ebp]
	push	OFFSET _togglenames
	push	ecx
	call	_bsearch
	add	esp, 20					; 00000014H

; 3713 :     if ( keyptr ) 

	cmp	eax, edi
	je	$LN89@identcase

; 3714 :     { yylval.i = keyptr->token;

	mov	edx, DWORD PTR [eax+4]

; 3715 :       if ( verb_flag != 0 ) tok = TOGGLENAME_TOK;

	mov	eax, DWORD PTR _verb_flag
	neg	eax
	pop	edi
	sbb	eax, eax
	add	eax, 335				; 0000014fH
	pop	esi
	mov	DWORD PTR _yylval, edx

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN107@identcase:

; 3669 :       }
; 3670 :     }
; 3671 :     else /* search keywords and internal variables */
; 3672 :     { 
; 3673 :       keyptr = BSEARCH(command_keywords);

	push	OFFSET _keyword_compare
	push	8
	push	287					; 0000011fH
	lea	ecx, DWORD PTR _key$[ebp]
	push	OFFSET _command_keywords
	push	ecx
	call	_bsearch
	mov	esi, eax

; 3674 :       if ( keyptr ) 

	xor	edi, edi
	add	esp, 20					; 00000014H
	cmp	esi, edi
	je	$LN103@identcase

; 3675 :       { if ( kb_stricmp(lexeme,"HELP") == 0 ) help_flag = 1;

	push	OFFSET ??_C@_04DOKPJKJF@HELP?$AA@
	push	ebx
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN259@identcase
	mov	DWORD PTR _help_flag, 1
$LN259@identcase:

; 3676 :         yylval.i = tok = keyptr->token;

	mov	eax, DWORD PTR [esi+4]

; 3677 :         switch ( tok )

	mov	ecx, eax
	mov	DWORD PTR _tok, eax
	mov	DWORD PTR _yylval, eax
	cmp	ecx, 573				; 0000023dH
	jg	SHORT $LN167@identcase
	cmp	ecx, 572				; 0000023cH
	jge	SHORT $LN99@identcase
	sub	ecx, 310				; 00000136H
	cmp	ecx, 232				; 000000e8H
	ja	$LN165@identcase
	movzx	edx, BYTE PTR $LN257@identcase[ecx]
	jmp	DWORD PTR $LN283@identcase[edx*4]
$LN97@identcase:

; 3694 :           case SHOW_TOK: if ( verb_flag ) tok = SHOWVERB_TOK;

	cmp	DWORD PTR _verb_flag, edi
	je	SHORT $LN98@identcase
	mov	DWORD PTR _verb_flag, edi
	pop	edi
	mov	eax, 525				; 0000020dH
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN95@identcase:

; 3695 :                       verb_flag = 0;
; 3696 :                       break;
; 3697 :           case TRANSFORM_EXPR_TOK: if ( verb_flag ) tok = TRANSFORM_EXPR_VERB_TOK;

	cmp	DWORD PTR _verb_flag, edi
	je	SHORT $LN98@identcase
	mov	DWORD PTR _verb_flag, edi
	pop	edi
	mov	eax, 421				; 000001a5H
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN99@identcase:
	pop	edi
	pop	esi

; 3678 :         { /* set verb_flag when expecting a command */
; 3679 :           case THEN_TOK: case ELSE_TOK: case DO_TOK: verb_flag = 1; break;

	mov	DWORD PTR _verb_flag, 1
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN167@identcase:

; 3677 :         switch ( tok )

	cmp	ecx, 590				; 0000024eH
	je	SHORT $LN98@identcase
	cmp	ecx, 35038				; 000088deH
	jne	$LN165@identcase
$LN98@identcase:

; 3680 :           /* clear verb_flag when expecting an expression */
; 3681 :           case PRINT_TOK: 
; 3682 :           case IF_TOK: case WHILE_TOK: case VIEW_TRANSFORMS_TOK: case TRANSFORM_DEPTH_TOK:
; 3683 :           case METIS_TOK: case KMETIS_TOK: case OMETIS_TOK: case EDGEWEED_TOK:
; 3684 :           case AREAWEED_TOK: case EDGEDIVIDE_TOK: case LANCZOS_TOK: case RITZ_TOK:
; 3685 :           case EIGENPROBE_TOK: case MOVE_TOK: case ZOOM_TOK: case LAGRANGE_TOK: case SET_TOK:
; 3686 :           case PRINTF_TOK: case LIST_TOK: case DELETE_TOK: case VERTEX_AVERAGE_TOK:
; 3687 :           case BINARY_PRINTF_TOK: 
; 3688 :           case DISSOLVE_TOK: case REFINE_TOK: case EDGESWAP_TOK: case FIX_TOK: case UNFIX_TOK:
; 3689 :               case SPRINTF_TOK: case EPRINT_TOK: case HISTOGRAM_TOK: case LOGHISTOGRAM_TOK:
; 3690 :           case FOREACH_TOK: case SHOW_EXPR_TOK: case UNSET_TOK:
; 3691 :           case HESSIAN_SADDLE_TOK: case HESSIAN_SEEK_TOK: case NOTCH_TOK:
; 3692 :           case AUTOCHOP_TOK: case AUTOPOP_TOK: case OPTIMIZE_TOK:
; 3693 :                verb_flag = 0; break;

	mov	DWORD PTR _verb_flag, edi
	pop	edi
	pop	esi
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN201@identcase:
	pop	edi

; 3707 :       { yylval.i = DATATYPE_TOK;

	mov	eax, 358				; 00000166H

; 3708 :         yylval.datatype = i;

	mov	DWORD PTR _yylval+28, esi
	pop	esi
	mov	DWORD PTR _yylval, eax

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN89@identcase:

; 3716 :       else tok = TOGGLEVALUE_TOK;
; 3717 :       return tok;
; 3718 :     }
; 3719 :     keyptr = BSEARCH(internal_variables);

	push	OFFSET _keyword_compare
	push	8
	push	114					; 00000072H
	lea	eax, DWORD PTR _key$[ebp]
	push	OFFSET _internal_variables
	push	eax
	call	_bsearch
	add	esp, 20					; 00000014H

; 3720 :     if ( keyptr ) 

	cmp	eax, edi
	je	SHORT $LN86@identcase

; 3721 :     { yylval.i = keyptr->token;

	mov	ecx, DWORD PTR [eax+4]
	pop	edi

; 3722 :       return tok = INTERNAL_VARIABLE_TOK;

	mov	eax, 510				; 000001feH
	pop	esi
	mov	DWORD PTR _yylval, ecx

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN86@identcase:

; 3723 :     }
; 3724 : 
; 3725 :     /* search local variables */
; 3726 :     yylval.i = lookup_local_var(lexeme);

	push	ebx
	call	_lookup_local_var
	add	esp, 4
	mov	DWORD PTR _yylval, eax

; 3727 :     if ( yylval.i )

	cmp	eax, edi
	je	$LN52@identcase

; 3728 :     { struct global *g;
; 3729 :       g = globals(yylval.i); 

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN168@identcase
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN170@identcase
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN169@identcase
$LN170@identcase:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN168@identcase
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN169@identcase
$LN168@identcase:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN169@identcase:

; 3730 :       if ( g->flags & SUBROUTINE )

	mov	ecx, DWORD PTR [eax+192]
	test	cl, 4
	je	SHORT $LN84@identcase
$LN270@identcase:
	pop	edi

; 3731 :         return ( tok = PROCEDURE_TOK);

	mov	eax, 442				; 000001baH
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN84@identcase:

; 3732 :       else if ( g->flags & ORDINARY_PARAM )

	test	cl, 1
	je	$LN82@identcase

; 3733 :       { switch ( g->type )

	mov	eax, DWORD PTR [eax+200]
	add	eax, -13				; fffffff3H
	cmp	eax, 5
	ja	$LN73@identcase
	jmp	DWORD PTR $LN284@identcase[eax*4]
$LN79@identcase:

; 3734 :         { case VERTEX_TYPE: 
; 3735 :              yylval.etype = VERTEX;

	mov	DWORD PTR _yylval+24, edi
	pop	edi

; 3736 :              return ( tok = ELEMENT_IDENT_TOK);

	mov	eax, 537				; 00000219H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN78@identcase:
	pop	edi

; 3737 :           case ELEMENTID_TYPE:
; 3738 :              yylval.etype = -1;
; 3739 :              return ( tok = ELEMENT_IDENT_TOK);

	mov	eax, 537				; 00000219H
	pop	esi
	mov	DWORD PTR _yylval+24, -1

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN77@identcase:
	pop	edi

; 3740 :           case EDGE_TYPE:
; 3741 :              yylval.etype = EDGE;
; 3742 :              return ( tok = ELEMENT_IDENT_TOK);

	mov	eax, 537				; 00000219H
	pop	esi
	mov	DWORD PTR _yylval+24, 1

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@identcase:
	pop	edi

; 3743 :           case FACET_TYPE:
; 3744 :              yylval.etype = FACET;
; 3745 :              return ( tok = ELEMENT_IDENT_TOK);

	mov	eax, 537				; 00000219H
	pop	esi
	mov	DWORD PTR _yylval+24, 2

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN75@identcase:
	pop	edi

; 3746 :           case BODY_TYPE:
; 3747 :              yylval.etype = BODY;
; 3748 :              return ( tok = ELEMENT_IDENT_TOK);

	mov	eax, 537				; 00000219H
	pop	esi
	mov	DWORD PTR _yylval+24, 3

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@identcase:
	pop	edi

; 3749 :           case FACETEDGE_TYPE:
; 3750 :              yylval.etype = FACETEDGE;
; 3751 :              return ( tok = ELEMENT_IDENT_TOK);

	mov	eax, 537				; 00000219H
	pop	esi
	mov	DWORD PTR _yylval+24, 4

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@identcase:
	pop	edi

; 3752 :           default:
; 3753 :             return ( tok = IDENT_TOK);

	mov	eax, 286				; 0000011eH
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN82@identcase:

; 3754 :         }
; 3755 :       }
; 3756 :       else if ( g->flags & FUNCTION_NAME )

	test	ecx, 1048576				; 00100000H
	je	SHORT $LN71@identcase
$LN272@identcase:
	pop	edi

; 3757 :         return ( tok = FUNCTION_IDENT_TOK);

	mov	eax, 465				; 000001d1H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@identcase:

; 3758 :       else if ( g->flags & PROCEDURE_NAME )

	test	ecx, 2097152				; 00200000H
	je	SHORT $LN69@identcase
$LN273@identcase:
	pop	edi

; 3759 :         return ( tok = PROCEDURE_IDENT_TOK);

	mov	eax, 521				; 00000209H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN69@identcase:

; 3760 :       else if ( g->flags & STRINGVAL )

	test	ecx, 8192				; 00002000H
	je	SHORT $LN67@identcase
$LN274@identcase:
	pop	edi

; 3761 :         return ( tok = STRINGGLOBAL_TOK);

	mov	eax, 444				; 000001bcH
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN67@identcase:

; 3762 :       else if ( g->flags & QUANTITY_NAME )  /* can't happen */

	test	cl, cl
	jns	SHORT $LN65@identcase
$LN275@identcase:
	pop	edi

; 3763 :         return ( tok = QUANTITY_NAME_TOK);

	mov	eax, 336				; 00000150H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@identcase:

; 3764 :       else if ( g->flags & METHOD_NAME )  /* can't happen */

	test	ecx, 1024				; 00000400H
	je	SHORT $LN63@identcase
$LN276@identcase:
	pop	edi

; 3765 :         return ( tok = METHOD_NAME_TOK);

	mov	eax, 414				; 0000019eH
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@identcase:

; 3766 :       else if ( g->flags & CONSTRAINT_NAME )  /* can't happen */

	test	ecx, 131072				; 00020000H
	je	SHORT $LN61@identcase
$LN277@identcase:
	pop	edi

; 3767 :         return ( tok = CONSTRAINT_NAME_TOK);

	mov	eax, 519				; 00000207H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@identcase:

; 3768 :       else if ( g->flags & BOUNDARY_NAME )  /* can't happen */

	test	ecx, 262144				; 00040000H
	je	SHORT $LN59@identcase
$LN278@identcase:
	pop	edi

; 3769 :         return ( tok = BOUNDARY_NAME_TOK);

	mov	eax, 520				; 00000208H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@identcase:

; 3770 :       else if ( g->flags & DYNAMIC_LOAD_FUNC )  /* can't happen */

	test	ecx, 65536				; 00010000H

; 3771 :         return ( tok = DYNAMIC_LOAD_FUNC_TOK);

	jne	$LN279@identcase

; 3772 :       else if ( g->flags & ARRAY_PARAM )

	test	ecx, 2048				; 00000800H
	je	SHORT $LN55@identcase
$LN280@identcase:
	pop	edi

; 3773 : 	  {// if ( g->type == STRING )
; 3774 : 	   //   return ( tok = STRINGARRAY_TOK);
; 3775 : 		//else
; 3776 :           return ( tok = ARRAYIDENT_TOK);

	mov	eax, 432				; 000001b0H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@identcase:

; 3777 :       }
; 3778 :       else if ( g->flags & GLOB_LOCALVAR )

	test	ecx, 524288				; 00080000H
	je	$LN53@identcase

; 3779 :         return IDENT_TOK;

	pop	edi
	pop	esi
	mov	eax, 286				; 0000011eH
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@identcase:

; 3780 :       else 
; 3781 :         return (tok = NEWIDENT_TOK);
; 3782 :     }
; 3783 : 
; 3784 :     /* search symbol table */
; 3785 :     s = symbol_lookup(lexeme);

	push	ebx
	call	_symbol_lookup
	add	esp, 4

; 3786 :     if ( s ) 

	cmp	eax, edi
	je	SHORT $LN51@identcase

; 3787 :     { yysym = s; yylval.i = (int)(yysym-symtable); verb_flag = 0;

	mov	DWORD PTR _yysym, eax
	sub	eax, OFFSET _symtable
	mov	ecx, eax
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _verb_flag, edi
	pop	edi
	mov	DWORD PTR _yylval, eax

; 3788 :       return (tok = SYMBOL_TOK);

	mov	eax, 282				; 0000011aH
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@identcase:

; 3789 :     }
; 3790 : 
; 3791 :     /* search parameter names */
; 3792 :     yylval.i = lookup_global_hash(lexeme,0,0,HASH_LOOK);

	push	edi
	push	edi
	push	edi
	push	ebx
	call	_lookup_global_hash
	add	esp, 16					; 00000010H
	mov	DWORD PTR _yylval, eax

; 3793 :     if ( yylval.i != 0 )

	cmp	eax, edi
	je	$LN17@identcase

; 3794 :     { int nametype = yylval.i & NAMETYPEMASK;

	mov	ecx, eax
	and	ecx, -536870912				; e0000000H

; 3795 :       struct global *g;
; 3796 :       yylval.i &= INDEXMASK; /* get plain index */

	and	eax, 536870911				; 1fffffffH
	mov	DWORD PTR _yylval, eax

; 3797 : 
; 3798 :       if ( nametype == QUANTITYNAME )

	cmp	ecx, 1610612736				; 60000000H

; 3799 :         return tok = QUANTITY_NAME_TOK;

	je	$LN275@identcase

; 3800 :       else if ( nametype == METHODNAME )

	cmp	ecx, 1073741824				; 40000000H

; 3801 :         return tok = METHOD_NAME_TOK;

	je	$LN276@identcase

; 3802 :       else if ( nametype == PERM_NAME )

	cmp	ecx, -2147483648			; 80000000H
	jne	SHORT $LN39@identcase

; 3803 :       { yylval.i |= PERMGLOBAL;
; 3804 :         if ( perm_globals(yylval.i)->flags & SUBROUTINE )

	mov	ecx, DWORD PTR _web+5656
	or	eax, 536870912				; 20000000H
	mov	DWORD PTR _yylval, eax
	and	eax, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+192]
	test	al, 4
	je	SHORT $LN44@identcase

; 3805 :           return ( tok = PERM_PROCEDURE_TOK);

	pop	edi
	mov	eax, 484				; 000001e4H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@identcase:

; 3806 :         else if ( perm_globals(yylval.i)->flags & STRINGVAL )

	test	eax, 8192				; 00002000H
	je	SHORT $LN42@identcase

; 3807 :           return ( tok = PERM_STRINGGLOBAL_TOK);

	pop	edi
	mov	eax, 464				; 000001d0H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@identcase:

; 3808 :         else if ( perm_globals(yylval.i)->flags & ARRAY_PARAM )

	test	eax, 2048				; 00000800H

; 3809 :           return ( tok = ARRAYIDENT_TOK);

	jne	$LN280@identcase

; 3810 :         else return (tok = PERM_IDENT_TOK);

	pop	edi
	mov	eax, 487				; 000001e7H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@identcase:

; 3811 :       }
; 3812 :       yylval.i |= EPHGLOBAL;

	or	eax, 268435456				; 10000000H

; 3813 :       g = globals(yylval.i); 

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	mov	DWORD PTR _yylval, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN174@identcase
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN176@identcase
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN175@identcase
$LN176@identcase:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN174@identcase
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN175@identcase
$LN174@identcase:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN175@identcase:

; 3814 :       if ( g->flags & SUBROUTINE )

	mov	ecx, DWORD PTR [eax+192]
	test	cl, 4

; 3815 :         return ( tok = PROCEDURE_TOK);

	jne	$LN270@identcase

; 3816 :       else if ( g->flags & FUNCTION_NAME )

	test	ecx, 1048576				; 00100000H

; 3817 :         return ( tok = FUNCTION_IDENT_TOK);

	jne	$LN272@identcase

; 3818 :       else if ( g->flags & PROCEDURE_NAME )

	test	ecx, 2097152				; 00200000H

; 3819 :         return ( tok = PROCEDURE_IDENT_TOK);

	jne	$LN273@identcase

; 3820 :       else if ( g->flags & STRINGVAL )

	test	ecx, 8192				; 00002000H

; 3821 :         return ( tok = STRINGGLOBAL_TOK);

	jne	$LN274@identcase

; 3822 :       else if ( g->flags & QUANTITY_NAME )

	test	cl, cl

; 3823 :         return ( tok = QUANTITY_NAME_TOK);

	js	$LN275@identcase

; 3824 :       else if ( g->flags & METHOD_NAME )

	test	ecx, 1024				; 00000400H

; 3825 :         return ( tok = METHOD_NAME_TOK);

	jne	$LN276@identcase

; 3826 :       else if ( g->flags & CONSTRAINT_NAME )

	test	ecx, 131072				; 00020000H

; 3827 :         return ( tok = CONSTRAINT_NAME_TOK);

	jne	$LN277@identcase

; 3828 :       else if ( g->flags & BOUNDARY_NAME )

	test	ecx, 262144				; 00040000H

; 3829 :         return ( tok = BOUNDARY_NAME_TOK);

	jne	$LN278@identcase

; 3830 :       else if ( g->flags & DYNAMIC_LOAD_FUNC )

	test	ecx, 65536				; 00010000H

; 3831 :         return ( tok = DYNAMIC_LOAD_FUNC_TOK);

	jne	$LN279@identcase

; 3832 :       else if ( g->flags & ARRAY_PARAM )

	test	ecx, 2048				; 00000800H

; 3833 :         return ( tok = ARRAYIDENT_TOK);

	jne	$LN280@identcase

; 3834 :       else 
; 3835 :       { switch ( g->type )

	mov	eax, DWORD PTR [eax+200]
	add	eax, -13				; fffffff3H
	cmp	eax, 5
	ja	$LN73@identcase
	jmp	DWORD PTR $LN285@identcase[eax*4]
$LN15@identcase:
	pop	edi

; 3736 :              return ( tok = ELEMENT_IDENT_TOK);

	mov	eax, 537				; 00000219H
	pop	esi

; 3836 :         { case VERTEX_TYPE: 
; 3837 :              yylval.etype = VERTEX;
; 3838 :              return ( tok = ELEMENT_IDENT_TOK);
; 3839 :           case ELEMENTID_TYPE:
; 3840 :              yylval.etype = -1;

	mov	DWORD PTR _yylval+24, -1

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@identcase:
	pop	edi

; 3736 :              return ( tok = ELEMENT_IDENT_TOK);

	mov	eax, 537				; 00000219H
	pop	esi

; 3841 :              return ( tok = ELEMENT_IDENT_TOK);
; 3842 :           case EDGE_TYPE:
; 3843 :              yylval.etype = EDGE;

	mov	DWORD PTR _yylval+24, 1

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@identcase:
	pop	edi

; 3736 :              return ( tok = ELEMENT_IDENT_TOK);

	mov	eax, 537				; 00000219H
	pop	esi

; 3844 :              return ( tok = ELEMENT_IDENT_TOK);
; 3845 :           case FACET_TYPE:
; 3846 :              yylval.etype = FACET;

	mov	DWORD PTR _yylval+24, 2

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@identcase:
	pop	edi

; 3736 :              return ( tok = ELEMENT_IDENT_TOK);

	mov	eax, 537				; 00000219H
	pop	esi

; 3847 :              return ( tok = ELEMENT_IDENT_TOK);
; 3848 :           case BODY_TYPE:
; 3849 :              yylval.etype = BODY;

	mov	DWORD PTR _yylval+24, 3

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@identcase:
	pop	edi

; 3736 :              return ( tok = ELEMENT_IDENT_TOK);

	mov	eax, 537				; 00000219H
	pop	esi

; 3850 :              return ( tok = ELEMENT_IDENT_TOK);
; 3851 :           case FACETEDGE_TYPE:
; 3852 :              yylval.etype = FACETEDGE;

	mov	DWORD PTR _yylval+24, 4

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@identcase:

; 3853 :              return ( tok = ELEMENT_IDENT_TOK);
; 3854 :           default:
; 3855 :             return ( tok = IDENT_TOK);
; 3856 :         }
; 3857 :       }
; 3858 :     }
; 3859 : 
; 3860 :     /* search extra attributes */
; 3861 :     for ( type = 0 ; type < NUMELEMENTS ; type++ )

	mov	DWORD PTR _type$[ebp], edi
	mov	edi, OFFSET _web+108
	npad	1
$LL9@identcase:

; 3862 :     { struct extra *ex;
; 3863 :       int i;
; 3864 : 
; 3865 :       for ( i=0, ex=EXTRAS(type) ; i < web.skel[type].extra_count ; i++, ex++ )

	mov	esi, DWORD PTR [edi-4]
	add	esi, DWORD PTR _dymem
	xor	ebx, ebx
	cmp	DWORD PTR [edi], ebx
	jle	SHORT $LN8@identcase
	npad	1
$LL6@identcase:

; 3866 :         if ( stricmp(lexeme, ex->name) == 0 )

	mov	ecx, DWORD PTR _lexeme$[ebp]
	push	esi
	push	ecx
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN202@identcase

; 3862 :     { struct extra *ex;
; 3863 :       int i;
; 3864 : 
; 3865 :       for ( i=0, ex=EXTRAS(type) ; i < web.skel[type].extra_count ; i++, ex++ )

	inc	ebx
	add	esi, 240				; 000000f0H
	cmp	ebx, DWORD PTR [edi]
	jl	SHORT $LL6@identcase
$LN8@identcase:

; 3853 :              return ( tok = ELEMENT_IDENT_TOK);
; 3854 :           default:
; 3855 :             return ( tok = IDENT_TOK);
; 3856 :         }
; 3857 :       }
; 3858 :     }
; 3859 : 
; 3860 :     /* search extra attributes */
; 3861 :     for ( type = 0 ; type < NUMELEMENTS ; type++ )

	inc	DWORD PTR _type$[ebp]
	add	edi, 112				; 00000070H
	cmp	edi, OFFSET _web+668
	jl	SHORT $LL9@identcase

; 3871 :         }
; 3872 :     }
; 3873 : 
; 3874 :     /* search dynamic load libraries */
; 3875 :     h = search_libraries(lexeme);

	mov	esi, DWORD PTR _lexeme$[ebp]
	push	esi
	call	_search_libraries
	mov	edi, eax
	add	esp, 4

; 3876 :     if ( h )

	test	edi, edi
	je	$LN2@identcase

; 3877 :     { yylval.i = add_global(lexeme);

	push	esi
	call	_add_global

; 3878 :       globals(yylval.i)->flags |= DYNAMIC_LOAD_FUNC;

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 4
	mov	DWORD PTR _yylval, eax
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN180@identcase
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN182@identcase
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN181@identcase
$LN202@identcase:

; 3867 :         { strncpy(idname,lexeme,sizeof(idname)); /* save text */

	mov	edx, DWORD PTR _lexeme$[ebp]
	push	35					; 00000023H
	push	edx
	push	OFFSET _idname
	call	_strncpy

; 3868 :           yylval.qnum = i;
; 3869 :           yylval.etype = type;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR _yylval+24, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _yylval+4, ebx

; 3870 :           return tok = ex->array_spec.dim ? ARRAY_ATTRIBUTE_TOK: EXTRA_ATTRIBUTE_TOK; 

	mov	eax, DWORD PTR [esi+76]
	neg	eax
	sbb	eax, eax
	pop	edi
	and	eax, 282				; 0000011aH
	add	eax, 284				; 0000011cH
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN182@identcase:

; 3878 :       globals(yylval.i)->flags |= DYNAMIC_LOAD_FUNC;

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN180@identcase
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN181@identcase
$LN180@identcase:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN181@identcase:
	or	DWORD PTR [eax+192], 65536		; 00010000H

; 3879 :       globals(yylval.i)->value.funcptr = h;

	mov	eax, DWORD PTR _yylval
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN186@identcase
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN188@identcase
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR [eax+64], edi
	pop	edi

; 3880 :       return ( tok = DYNAMIC_LOAD_FUNC_TOK);

	mov	eax, 486				; 000001e6H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN188@identcase:

; 3879 :       globals(yylval.i)->value.funcptr = h;

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN186@identcase
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+64], edi
	pop	edi

; 3880 :       return ( tok = DYNAMIC_LOAD_FUNC_TOK);

	mov	eax, 486				; 000001e6H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN186@identcase:

; 3879 :       globals(yylval.i)->value.funcptr = h;

	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR [eax+64], edi
$LN279@identcase:

; 3880 :       return ( tok = DYNAMIC_LOAD_FUNC_TOK);

	pop	edi
	mov	eax, 486				; 000001e6H
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@identcase:

; 3881 :     }
; 3882 : 
; 3883 :     /* if here, then not keyword */
; 3884 :     strncpy(idname,lexeme,sizeof(idname)); /* save text */

	push	35					; 00000023H
	push	esi
	push	OFFSET _idname
	call	_strncpy

; 3885 :     if ( strlen(lexeme) == 1 )

	mov	eax, esi
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL258@identcase:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL258@identcase
	sub	eax, edx
	cmp	eax, 1
	jne	SHORT $LN1@identcase

; 3886 :     { yylval.i = lexeme[0];

	movsx	ecx, BYTE PTR [esi]
	mov	DWORD PTR _yylval, ecx
$LN149@identcase:

; 3887 :       return ( tok = SINGLE_LETTER_TOK);

	pop	edi
	mov	eax, 348				; 0000015cH
	pop	esi

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@identcase:

; 3888 :     }
; 3889 :     
; 3890 :    yylval.i = 0;

	mov	DWORD PTR _yylval, 0
$LN53@identcase:

; 3891 :    return(tok = NEWIDENT_TOK) ;

	mov	eax, 268				; 0000010cH
	mov	DWORD PTR _tok, eax
$LN165@identcase:
	pop	edi
	pop	esi
	pop	ebx

; 3892 : } /* end identcase() */

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN282@identcase:
	DD	$LN151@identcase
	DD	$LN152@identcase
	DD	$LN149@identcase
$LN220@identcase:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	1
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	2
	DB	1
	DB	1
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	1
	DB	2
	DB	1
	npad	1
$LN283@identcase:
	DD	$LN98@identcase
	DD	$LN97@identcase
	DD	$LN95@identcase
	DD	$LN99@identcase
	DD	$LN165@identcase
$LN257@identcase:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	0
	DB	1
	DB	0
	DB	0
	DB	4
	DB	4
	DB	0
	DB	4
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	4
	DB	4
	DB	0
	DB	0
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	npad	3
$LN284@identcase:
	DD	$LN79@identcase
	DD	$LN77@identcase
	DD	$LN76@identcase
	DD	$LN75@identcase
	DD	$LN74@identcase
	DD	$LN78@identcase
$LN285@identcase:
	DD	$LN79@identcase
	DD	$LN14@identcase
	DD	$LN13@identcase
	DD	$LN12@identcase
	DD	$LN11@identcase
	DD	$LN15@identcase
_identcase ENDP
_TEXT	ENDS
PUBLIC	_keywordname
EXTRN	_tokname:PROC
_BSS	SEGMENT
?name@?4??keywordname@@9@9 DB 052H DUP (?)		; `keywordname'::`5'::name
	ALIGN	4

?name@?3??keywordname@@9@9 DB 052H DUP (?)		; `keywordname'::`4'::name
	ALIGN	4

?name@?2??keywordname@@9@9 DB 052H DUP (?)		; `keywordname'::`3'::name
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _keywordname
_TEXT	SEGMENT
_toknum$ = 8						; size = 4
_keywordname PROC					; COMDAT

; 3903 : {  int k,i,imax;

	push	ebp
	mov	ebp, esp

; 3904 : 
; 3905 :     for ( k = 0 ; k < sizeof(command_keywords)/sizeof(struct ckey) ; k++ )

	mov	ecx, DWORD PTR _toknum$[ebp]
	xor	eax, eax
	npad	8
$LL28@keywordnam:

; 3906 :       if ( toknum == command_keywords[k].token )

	cmp	ecx, DWORD PTR _command_keywords[eax*8+4]
	je	$LN38@keywordnam

; 3904 : 
; 3905 :     for ( k = 0 ; k < sizeof(command_keywords)/sizeof(struct ckey) ; k++ )

	inc	eax
	cmp	eax, 287				; 0000011fH
	jb	SHORT $LL28@keywordnam

; 3910 :       }
; 3911 :     for ( k = 0 ; k < sizeof(togglenames)/sizeof(struct ckey) ; k++ )

	xor	eax, eax
	npad	9
$LL24@keywordnam:

; 3912 :       if ( toknum == togglenames[k].token )

	cmp	ecx, DWORD PTR _togglenames[eax*8+4]
	je	$LN39@keywordnam

; 3910 :       }
; 3911 :     for ( k = 0 ; k < sizeof(togglenames)/sizeof(struct ckey) ; k++ )

	inc	eax
	cmp	eax, 127				; 0000007fH
	jb	SHORT $LL24@keywordnam

; 3916 :       }
; 3917 :     for ( k = 0 ; k < sizeof(internal_variables)/sizeof(struct ckey) ; k++ )

	xor	eax, eax
	npad	11
$LL20@keywordnam:

; 3918 :       if ( toknum == internal_variables[k].token )

	cmp	ecx, DWORD PTR _internal_variables[eax*8+4]
	je	$LN40@keywordnam

; 3916 :       }
; 3917 :     for ( k = 0 ; k < sizeof(internal_variables)/sizeof(struct ckey) ; k++ )

	inc	eax
	cmp	eax, 114				; 00000072H
	jb	SHORT $LL20@keywordnam

; 3922 :       }
; 3923 : 
; 3924 :     imax = sizeof(colornames)/sizeof(struct ckey);
; 3925 :     for ( i = 0 ; i < imax ; i++ )

	xor	eax, eax
	npad	11
$LL16@keywordnam:

; 3926 :       if ( colornames[i].token == toknum )

	cmp	DWORD PTR _colornames[eax*8+4], ecx
	je	$LN41@keywordnam

; 3922 :       }
; 3923 : 
; 3924 :     imax = sizeof(colornames)/sizeof(struct ckey);
; 3925 :     for ( i = 0 ; i < imax ; i++ )

	inc	eax
	cmp	eax, 22					; 00000016H
	jl	SHORT $LL16@keywordnam

; 3928 : 
; 3929 :     imax = sizeof(datafile_keywords)/sizeof(struct dkey);
; 3930 :     for ( i = 0 ; i < imax ; i++ )

	xor	eax, eax
	npad	11
$LL12@keywordnam:

; 3931 :       if ( datafile_keywords[i].token == toknum )

	cmp	DWORD PTR _datafile_keywords[eax*8+4], ecx
	je	$LN42@keywordnam

; 3928 : 
; 3929 :     imax = sizeof(datafile_keywords)/sizeof(struct dkey);
; 3930 :     for ( i = 0 ; i < imax ; i++ )

	inc	eax
	cmp	eax, 198				; 000000c6H
	jl	SHORT $LL12@keywordnam

; 3933 : 
; 3934 :     imax = sizeof(mathfunc_keywords)/sizeof(struct ckey);
; 3935 :     for ( i = 0 ; i < imax ; i++ )

	xor	eax, eax
	npad	9
$LL8@keywordnam:

; 3936 :       if ( mathfunc_keywords[i].token == toknum )

	cmp	DWORD PTR _mathfunc_keywords[eax*8+4], ecx
	je	$LN43@keywordnam

; 3933 : 
; 3934 :     imax = sizeof(mathfunc_keywords)/sizeof(struct ckey);
; 3935 :     for ( i = 0 ; i < imax ; i++ )

	inc	eax
	cmp	eax, 22					; 00000016H
	jl	SHORT $LL8@keywordnam

; 3938 : 
; 3939 :     imax = sizeof(mathfunc2_keywords)/sizeof(struct ckey);
; 3940 :     for ( i = 0 ; i < imax ; i++ )

	xor	eax, eax
	npad	11
$LL4@keywordnam:

; 3941 :       if ( mathfunc2_keywords[i].token == toknum )

	cmp	DWORD PTR _mathfunc2_keywords[eax*8+4], ecx
	je	$LN44@keywordnam

; 3938 : 
; 3939 :     imax = sizeof(mathfunc2_keywords)/sizeof(struct ckey);
; 3940 :     for ( i = 0 ; i < imax ; i++ )

	inc	eax
	cmp	eax, 7
	jl	SHORT $LL4@keywordnam

; 3943 : 
; 3944 :    /* unfound */
; 3945 :    return tokname(toknum);

	push	ecx
	call	_tokname
	add	esp, 4

; 3946 : 
; 3947 : } // end keywordname()

	pop	ebp
	ret	0
$LN38@keywordnam:

; 3907 :       { static char name[82]; 
; 3908 :         strncpy(name,command_keywords[k].name,81);

	mov	eax, DWORD PTR _command_keywords[eax*8]
	push	81					; 00000051H
	push	eax
	push	OFFSET ?name@?2??keywordname@@9@9
	call	_strncpy
	add	esp, 12					; 0000000cH

; 3909 :         return name;

	mov	eax, OFFSET ?name@?2??keywordname@@9@9

; 3946 : 
; 3947 : } // end keywordname()

	pop	ebp
	ret	0
$LN39@keywordnam:

; 3913 :       { static char name[82]; 
; 3914 :         strncpy(name,togglenames[k].name,81);

	mov	ecx, DWORD PTR _togglenames[eax*8]
	push	81					; 00000051H
	push	ecx
	push	OFFSET ?name@?3??keywordname@@9@9
	call	_strncpy
	add	esp, 12					; 0000000cH

; 3915 :         return name;

	mov	eax, OFFSET ?name@?3??keywordname@@9@9

; 3946 : 
; 3947 : } // end keywordname()

	pop	ebp
	ret	0
$LN40@keywordnam:

; 3919 :       { static char name[82]; 
; 3920 :         strncpy(name,internal_variables[k].name,81);

	mov	edx, DWORD PTR _internal_variables[eax*8]
	push	81					; 00000051H
	push	edx
	push	OFFSET ?name@?4??keywordname@@9@9
	call	_strncpy
	add	esp, 12					; 0000000cH

; 3921 :         return name;

	mov	eax, OFFSET ?name@?4??keywordname@@9@9

; 3946 : 
; 3947 : } // end keywordname()

	pop	ebp
	ret	0
$LN41@keywordnam:

; 3927 :         return colornames[i].name;

	mov	eax, DWORD PTR _colornames[eax*8]

; 3946 : 
; 3947 : } // end keywordname()

	pop	ebp
	ret	0
$LN42@keywordnam:

; 3932 :         return datafile_keywords[i].name;

	mov	eax, DWORD PTR _datafile_keywords[eax*8]

; 3946 : 
; 3947 : } // end keywordname()

	pop	ebp
	ret	0
$LN43@keywordnam:

; 3937 :         return mathfunc_keywords[i].name;

	mov	eax, DWORD PTR _mathfunc_keywords[eax*8]

; 3946 : 
; 3947 : } // end keywordname()

	pop	ebp
	ret	0
$LN44@keywordnam:

; 3942 :         return mathfunc2_keywords[i].name;

	mov	eax, DWORD PTR _mathfunc2_keywords[eax*8]

; 3946 : 
; 3947 : } // end keywordname()

	pop	ebp
	ret	0
_keywordname ENDP
_TEXT	ENDS
PUBLIC	_identtype
EXTRN	_lookup_global:PROC
EXTRN	_lookup_perm_global:PROC
; Function compile flags: /Ogtp
;	COMDAT _identtype
_TEXT	SEGMENT
_key$ = -12						; size = 8
_type$ = -4						; size = 4
_word$ = 8						; size = 4
_identtype PROC						; COMDAT

; 3958 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 3959 :    int type;
; 3960 :    struct sym *s;
; 3961 :    struct ckey *keyptr;
; 3962 :    struct ckey key;  /* for bsearch key */
; 3963 : 
; 3964 : 
; 3965 :    if ( strlen(word) == 1 )

	mov	esi, DWORD PTR _word$[ebp]
	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL124@identtype:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL124@identtype
	sub	eax, edx
	cmp	eax, 1
	jne	SHORT $LN59@identtype

; 3966 :    {
; 3967 :      if ( single_redefine[yylval.i].start ) return tok = SINGLE_REDEFD_TOK;

	mov	eax, DWORD PTR _yylval
	imul	eax, 104				; 00000068H
	cmp	DWORD PTR _single_redefine[eax], 0
	je	SHORT $LN61@identtype
	mov	eax, 413				; 0000019dH

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@identtype:

; 3968 :      switch ( word[0] )

	movsx	eax, BYTE PTR [esi]
	add	eax, -71				; ffffffb9H
	cmp	eax, 50					; 00000032H
	ja	SHORT $LN54@identtype
	movzx	ecx, BYTE PTR $LN125@identtype[eax]
	jmp	DWORD PTR $LN131@identtype[ecx*4]
$LN58@identtype:

; 3969 :        { case 't': case 'l': case 'j': case 'P': case 'M':
; 3970 :          case 'w': case 'n': case 'm': case 'b':
; 3971 :          case 'k': case 'K': case 'p': case 'y':
; 3972 :            return ( tok = SINGLE_LETTER_ARG_TOK);

	mov	eax, 417				; 000001a1H

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@identtype:

; 3973 :              case 'G': if ( verb_flag ) return tok = SINGLE_LETTER_ARG_TOK;

	cmp	DWORD PTR _verb_flag, 0
	jne	SHORT $LN58@identtype

; 3974 :                else return tok = G_TOK; break;

	mov	eax, 280				; 00000118H

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@identtype:

; 3975 :          default: return ( tok = SINGLE_LETTER_TOK);

	mov	eax, 348				; 0000015cH

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@identtype:

; 3976 :        } 
; 3977 :     }
; 3978 :     key.name = word;
; 3979 :     keyptr = BSEARCH(colornames);

	push	OFFSET _keyword_compare
	push	8
	push	22					; 00000016H
	lea	edx, DWORD PTR _key$[ebp]
	push	OFFSET _colornames
	push	edx
	mov	DWORD PTR _key$[ebp], esi
	call	_bsearch
	add	esp, 20					; 00000014H

; 3980 :     if ( keyptr )

	test	eax, eax
	je	SHORT $LN53@identtype

; 3981 :           return  INTEGER_TOK;

	mov	eax, 265				; 00000109H
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@identtype:

; 3982 : 
; 3983 :     /* search math funcs */
; 3984 :     keyptr = BSEARCH(mathfunc_keywords);

	push	OFFSET _keyword_compare
	push	8
	push	22					; 00000016H
	lea	eax, DWORD PTR _key$[ebp]
	push	OFFSET _mathfunc_keywords
	push	eax
	call	_bsearch
	add	esp, 20					; 00000014H

; 3985 :     if ( keyptr ) {  return MATHFUNC_TOK; }

	test	eax, eax
	je	SHORT $LN52@identtype
	mov	eax, 270				; 0000010eH
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@identtype:

; 3986 : 
; 3987 :     keyptr = BSEARCH(mathfunc2_keywords);

	push	OFFSET _keyword_compare
	push	8
	push	7
	lea	ecx, DWORD PTR _key$[ebp]
	push	OFFSET _mathfunc2_keywords
	push	ecx
	call	_bsearch
	add	esp, 20					; 00000014H

; 3988 :     if ( keyptr ) {  return  MATHFUNC2_TOK; }

	test	eax, eax
	je	SHORT $LN51@identtype
	mov	eax, 271				; 0000010fH
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@identtype:

; 3989 : 
; 3990 :     /* search keywords and internal variables */
; 3991 :     { 
; 3992 :       keyptr = BSEARCH(command_keywords);

	push	OFFSET _keyword_compare
	push	8
	push	287					; 0000011fH
	lea	edx, DWORD PTR _key$[ebp]
	push	OFFSET _command_keywords
	push	edx
	call	_bsearch
	add	esp, 20					; 00000014H

; 3993 :       if ( keyptr ) 

	test	eax, eax
	je	SHORT $LN50@identtype
$LN129@identtype:

; 3994 :       {  
; 3995 :          return tok;

	mov	eax, DWORD PTR _tok
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@identtype:

; 3996 :       }
; 3997 : 
; 3998 :       keyptr = BSEARCH(togglenames);

	push	OFFSET _keyword_compare
	push	8
	push	127					; 0000007fH
	lea	eax, DWORD PTR _key$[ebp]
	push	OFFSET _togglenames
	push	eax
	call	_bsearch
	add	esp, 20					; 00000014H

; 3999 :       if ( keyptr ) 

	test	eax, eax

; 4000 :            return tok;

	jne	SHORT $LN129@identtype

; 4001 :       keyptr = BSEARCH(internal_variables);

	push	OFFSET _keyword_compare
	push	8
	push	114					; 00000072H
	lea	ecx, DWORD PTR _key$[ebp]
	push	OFFSET _internal_variables
	push	ecx
	call	_bsearch
	add	esp, 20					; 00000014H

; 4002 :       if ( keyptr ) { return  INTERNAL_VARIABLE_TOK; }

	test	eax, eax
	je	SHORT $LN48@identtype
	mov	eax, 510				; 000001feH
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@identtype:

; 4003 :     }
; 4004 : 
; 4005 :     /* search local variables */
; 4006 :     yylval.i = lookup_local_var(word);

	push	esi
	call	_lookup_local_var
	add	esp, 4
	mov	DWORD PTR _yylval, eax

; 4007 :     if ( yylval.i )

	test	eax, eax
	je	$LN27@identtype

; 4008 :     { struct global *g;
; 4009 :       g = globals(yylval.i); 

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN65@identtype
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN67@identtype
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN66@identtype
$LN67@identtype:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN65@identtype
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN66@identtype
$LN65@identtype:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN66@identtype:

; 4010 :       if ( g->flags & SUBROUTINE )

	mov	eax, DWORD PTR [eax+192]
	test	al, 4
	je	SHORT $LN46@identtype

; 4011 :         return ( tok = PROCEDURE_TOK);

	mov	eax, 442				; 000001baH

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@identtype:

; 4012 :       else if ( g->flags & ORDINARY_PARAM )

	test	al, 1
	je	SHORT $LN44@identtype

; 4013 :         return ( tok = IDENT_TOK);

	mov	eax, 286				; 0000011eH

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@identtype:

; 4014 :       else if ( g->flags & STRINGVAL )

	test	eax, 8192				; 00002000H
	je	SHORT $LN42@identtype

; 4015 :         return ( tok = STRINGGLOBAL_TOK);

	mov	eax, 444				; 000001bcH

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@identtype:

; 4016 :       else if ( g->flags & QUANTITY_NAME )  /* can't happen */

	test	al, al
	jns	SHORT $LN40@identtype

; 4017 :         return ( tok = QUANTITY_NAME_TOK);

	mov	eax, 336				; 00000150H

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@identtype:

; 4018 :       else if ( g->flags & METHOD_NAME )  /* can't happen */

	test	eax, 1024				; 00000400H
	je	SHORT $LN38@identtype

; 4019 :         return ( tok = METHOD_NAME_TOK);

	mov	eax, 414				; 0000019eH

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@identtype:

; 4020 :       else if ( g->flags & CONSTRAINT_NAME )  /* can't happen */

	test	eax, 131072				; 00020000H
	je	SHORT $LN36@identtype

; 4021 :         return ( tok = CONSTRAINT_NAME_TOK);

	mov	eax, 519				; 00000207H

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@identtype:

; 4022 :       else if ( g->flags & BOUNDARY_NAME )  /* can't happen */

	test	eax, 262144				; 00040000H
	je	SHORT $LN34@identtype

; 4023 :         return ( tok = BOUNDARY_NAME_TOK);

	mov	eax, 520				; 00000208H

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@identtype:

; 4024 :       else if ( g->flags & DYNAMIC_LOAD_FUNC )  /* can't happen */

	test	eax, 65536				; 00010000H
	je	SHORT $LN32@identtype

; 4025 :         return ( tok = DYNAMIC_LOAD_FUNC_TOK);

	mov	eax, 486				; 000001e6H

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@identtype:

; 4026 :       else if ( g->flags & ARRAY_PARAM )

	test	eax, 2048				; 00000800H
	je	SHORT $LN30@identtype

; 4027 :         return ( tok = ARRAYIDENT_TOK);

	mov	eax, 432				; 000001b0H

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@identtype:

; 4028 :       else if ( g->flags & GLOB_LOCALVAR )

	test	eax, 524288				; 00080000H
	je	SHORT $LN28@identtype

; 4029 :         return IDENT_TOK;

	mov	eax, 286				; 0000011eH
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@identtype:

; 4030 :       else return (tok = NEWIDENT_TOK);

	mov	eax, 268				; 0000010cH

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@identtype:

; 4031 :     }
; 4032 : 
; 4033 :     /* search symbol table */
; 4034 :     s = symbol_lookup(word);

	push	esi
	call	_symbol_lookup
	add	esp, 4

; 4035 :     if ( s ) 

	test	eax, eax
	je	SHORT $LN26@identtype

; 4036 :     { yysym = s; yylval.i = (int)(yysym-symtable); verb_flag = 0;

	mov	DWORD PTR _yysym, eax
	sub	eax, OFFSET _symtable
	mov	ecx, eax
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _yylval, eax

; 4037 :       return (tok = SYMBOL_TOK);

	mov	eax, 282				; 0000011aH
	mov	DWORD PTR _verb_flag, 0

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@identtype:

; 4038 :     }
; 4039 : 
; 4040 :     /* search parameter names */
; 4041 :     yylval.i = lookup_perm_global(word);

	push	esi
	call	_lookup_perm_global
	add	esp, 4
	mov	DWORD PTR _yylval, eax

; 4042 :     if ( yylval.i >= 0 )

	test	eax, eax
	js	$LN21@identtype

; 4043 :       { 
; 4044 :         if ( perm_globals(yylval.i)->flags & SUBROUTINE )

	mov	edx, DWORD PTR _web+5656
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	test	BYTE PTR [edx+192], 4
	je	SHORT $LN24@identtype

; 4045 :         return ( tok = PERM_PROCEDURE_TOK);

	mov	eax, 484				; 000001e4H

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@identtype:

; 4046 :         else if ( globals(yylval.i)->flags & STRINGVAL )

	and	eax, -16777216				; ff000000H
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN75@identtype
	mov	eax, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [ecx+edx]
	jmp	SHORT $LN72@identtype
$LN75@identtype:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN73@identtype
	mov	eax, DWORD PTR _localbase
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [eax]
	jmp	SHORT $LN72@identtype
$LN73@identtype:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN71@identtype
	mov	ecx, edx
	jmp	SHORT $LN72@identtype
$LN71@identtype:
	mov	edx, DWORD PTR _web+5652
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [eax+ecx]
$LN72@identtype:
	test	DWORD PTR [ecx+192], 8192		; 00002000H
	je	SHORT $LN22@identtype

; 4047 :         return ( tok = PERM_STRINGGLOBAL_TOK);

	mov	eax, 464				; 000001d0H

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@identtype:

; 4048 :         else return (tok = PERM_IDENT_TOK);

	mov	eax, 487				; 000001e7H

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@identtype:
	push	ebx
	push	edi

; 4049 :       }
; 4050 : 
; 4051 :     yylval.i = lookup_global(word);

	push	esi
	call	_lookup_global

; 4052 :     if ( yylval.i >= 0 )

	mov	edx, DWORD PTR _dymem
	add	esp, 4
	mov	DWORD PTR _yylval, eax
	test	eax, eax
	js	$LN8@identtype

; 4053 :       { 
; 4054 :         if ( globals(yylval.i)->flags & ORDINARY_PARAM )

	mov	edi, DWORD PTR _web+5652
	mov	ebx, DWORD PTR _localbase
	mov	esi, eax
	and	esi, -16777216				; ff000000H
	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN77@identtype
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN79@identtype
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [ebx]
	jmp	SHORT $LN78@identtype
$LN79@identtype:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN77@identtype
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN78@identtype
$LN77@identtype:
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [ecx+edx]
$LN78@identtype:
	test	BYTE PTR [ecx+192], 1
	je	SHORT $LN19@identtype

; 4055 :           return ( tok = IDENT_TOK);

	pop	edi
	mov	eax, 286				; 0000011eH
	pop	ebx

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@identtype:

; 4056 :         if ( globals(yylval.i)->flags & SUBROUTINE )

	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN83@identtype
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN85@identtype
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [ebx]
	jmp	SHORT $LN84@identtype
$LN85@identtype:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN83@identtype
	mov	ecx, DWORD PTR _web+5656
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN84@identtype
$LN83@identtype:
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [ecx+edx]
$LN84@identtype:
	test	BYTE PTR [ecx+192], 4
	je	SHORT $LN18@identtype

; 4057 :           return ( tok = PROCEDURE_TOK);

	pop	edi
	mov	eax, 442				; 000001baH
	pop	ebx

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@identtype:

; 4058 :         else if ( globals(yylval.i)->flags & STRINGVAL )

	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN89@identtype
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN91@identtype
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [ebx]
	jmp	SHORT $LN90@identtype
$LN91@identtype:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN89@identtype
	mov	ecx, DWORD PTR _web+5656
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN90@identtype
$LN89@identtype:
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [ecx+edx]
$LN90@identtype:
	test	DWORD PTR [ecx+192], 8192		; 00002000H
	je	SHORT $LN16@identtype

; 4059 :           return ( tok = STRINGGLOBAL_TOK);

	pop	edi
	mov	eax, 444				; 000001bcH
	pop	ebx

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@identtype:

; 4060 :         else if ( globals(yylval.i)->flags & QUANTITY_NAME )

	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN95@identtype
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN97@identtype
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [ebx]
	jmp	SHORT $LN96@identtype
$LN97@identtype:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN95@identtype
	mov	ecx, DWORD PTR _web+5656
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN96@identtype
$LN95@identtype:
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [ecx+edx]
$LN96@identtype:
	test	BYTE PTR [ecx+192], -128		; ffffff80H
	je	SHORT $LN14@identtype

; 4061 :           return ( tok = QUANTITY_NAME_TOK);

	pop	edi
	mov	eax, 336				; 00000150H
	pop	ebx

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@identtype:

; 4062 :         else if ( globals(yylval.i)->flags & METHOD_NAME )

	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN101@identtype
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN103@identtype
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [ebx]
	jmp	SHORT $LN102@identtype
$LN103@identtype:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN101@identtype
	mov	ecx, DWORD PTR _web+5656
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN102@identtype
$LN101@identtype:
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [ecx+edx]
$LN102@identtype:
	test	DWORD PTR [ecx+192], 1024		; 00000400H
	je	SHORT $LN12@identtype

; 4063 :           return ( tok = METHOD_NAME_TOK);

	pop	edi
	mov	eax, 414				; 0000019eH
	pop	ebx

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@identtype:

; 4064 :         else if ( globals(yylval.i)->flags & DYNAMIC_LOAD_FUNC )

	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN107@identtype
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN109@identtype
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [ebx]
	jmp	SHORT $LN108@identtype
$LN109@identtype:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN107@identtype
	mov	ecx, DWORD PTR _web+5656
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN108@identtype
$LN107@identtype:
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [ecx+edx]
$LN108@identtype:
	test	DWORD PTR [ecx+192], 65536		; 00010000H
	je	SHORT $LN10@identtype

; 4065 :           return ( tok = DYNAMIC_LOAD_FUNC_TOK);

	pop	edi
	mov	eax, 486				; 000001e6H
	pop	ebx

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@identtype:

; 4066 :         else if ( globals(yylval.i)->flags & ARRAY_PARAM )

	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN113@identtype
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN115@identtype
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ebx]
	jmp	SHORT $LN114@identtype
$LN115@identtype:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN113@identtype
	mov	ecx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN114@identtype
$LN113@identtype:
	lea	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+edx]
$LN114@identtype:
	test	DWORD PTR [eax+192], 2048		; 00000800H
	je	SHORT $LN8@identtype

; 4067 :           return ( tok = ARRAYIDENT_TOK);

	pop	edi
	mov	eax, 432				; 000001b0H
	pop	ebx

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@identtype:

; 4068 :       }
; 4069 : 
; 4070 :     /* search extra attributes */
; 4071 :     for ( type = 0 ; type <= BODY ; type++ )

	mov	DWORD PTR _type$[ebp], 0
	mov	edi, OFFSET _web+108
$LL7@identtype:

; 4072 :     { struct extra *ex;
; 4073 :       int i;
; 4074 : 
; 4075 :       for ( i = 0, ex = EXTRAS(type) ; 
; 4076 :          i < web.skel[type].extra_count ; i++ , ex++ )

	mov	esi, DWORD PTR [edi-4]
	xor	ebx, ebx
	add	esi, edx
	cmp	DWORD PTR [edi], ebx
	jle	SHORT $LN6@identtype
	npad	4
$LL4@identtype:

; 4077 :       if ( stricmp(word, ex->name) == 0 )

	mov	ecx, DWORD PTR _word$[ebp]
	push	esi
	push	ecx
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN121@identtype

; 4072 :     { struct extra *ex;
; 4073 :       int i;
; 4074 : 
; 4075 :       for ( i = 0, ex = EXTRAS(type) ; 
; 4076 :          i < web.skel[type].extra_count ; i++ , ex++ )

	inc	ebx
	add	esi, 240				; 000000f0H
	cmp	ebx, DWORD PTR [edi]
	jl	SHORT $LL4@identtype
	mov	edx, DWORD PTR _dymem
$LN6@identtype:

; 4068 :       }
; 4069 : 
; 4070 :     /* search extra attributes */
; 4071 :     for ( type = 0 ; type <= BODY ; type++ )

	inc	DWORD PTR _type$[ebp]
	add	edi, 112				; 00000070H
	cmp	edi, OFFSET _web+444
	jle	SHORT $LL7@identtype

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	pop	edi
	mov	eax, 268				; 0000010cH
	pop	ebx
	mov	DWORD PTR _yylval, 0
	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN121@identtype:

; 4078 :       { strncpy(idname,word,sizeof(idname)); /* save text */

	mov	edx, DWORD PTR _word$[ebp]
	push	35					; 00000023H
	push	edx
	push	OFFSET _idname
	call	_strncpy

; 4079 :         yylval.qnum = i;
; 4080 :         yylval.etype = type;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR _yylval+24, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _yylval+4, ebx

; 4081 :         return tok = ex->array_spec.dim ? ARRAY_ATTRIBUTE_TOK: EXTRA_ATTRIBUTE_TOK; 

	mov	eax, DWORD PTR [esi+76]
	neg	eax
	sbb	eax, eax
	pop	edi
	and	eax, 282				; 0000011aH
	add	eax, 284				; 0000011cH
	pop	ebx

; 4082 :       }
; 4083 :     }
; 4084 : 
; 4085 :     /* if here, then not keyword */
; 4086 :     yylval.i = 0;
; 4087 :     return(tok = NEWIDENT_TOK) ;

	mov	DWORD PTR _tok, eax
	pop	esi

; 4088 : } /* end identtype() */

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN131@identtype:
	DD	$LN57@identtype
	DD	$LN58@identtype
	DD	$LN54@identtype
$LN125@identtype:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	1
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	1
	DB	2
	DB	1
_identtype ENDP
_TEXT	ENDS
PUBLIC	_kb_input_new
; Function compile flags: /Ogtp
;	COMDAT _kb_input_new
_TEXT	SEGMENT
_kb_input_new PROC					; COMDAT

; 4153 : 
; 4154 :   if ( ubuff_spot )

	mov	ecx, DWORD PTR _ubuff_spot
	test	ecx, ecx
	je	SHORT $LN5@kb_input_n

; 4155 :   { c = unput_buff[--ubuff_spot];

	mov	edx, DWORD PTR _unput_buff
	dec	ecx
	mov	DWORD PTR _ubuff_spot, ecx
	mov	al, BYTE PTR [edx+ecx]

; 4156 :     unput_buff[ubuff_spot] = 0;

	mov	BYTE PTR [edx+ecx], 0

; 4165 :    }
; 4166 :    return c;
; 4167 :    
; 4168 : } // end kb_input_new()

	ret	0
$LN5@kb_input_n:

; 4157 :     return c;
; 4158 :   }
; 4159 :   c = rawinput();

	call	_rawinput

; 4160 :   while ( c == 0 ) // done with this input

	test	al, al
	jne	SHORT $LN6@kb_input_n
$LL4@kb_input_n:

; 4161 :   { if ( yywrap() ) // check for continuation 

	call	_yywrap
	test	eax, eax
	jne	SHORT $LN9@kb_input_n

; 4163 :     else
; 4164 :       c = rawinput();

	call	_rawinput
	test	al, al
	je	SHORT $LL4@kb_input_n

; 4165 :    }
; 4166 :    return c;
; 4167 :    
; 4168 : } // end kb_input_new()

	ret	0
$LN9@kb_input_n:

; 4162 :       return 0;   // no continuation, so done

	xor	al, al
$LN6@kb_input_n:

; 4165 :    }
; 4166 :    return c;
; 4167 :    
; 4168 : } // end kb_input_new()

	ret	0
_kb_input_new ENDP
_TEXT	ENDS
PUBLIC	_kb_unput
EXTRN	_calloc:PROC
; Function compile flags: /Ogtp
;	COMDAT _kb_unput
_TEXT	SEGMENT
_c$ = 8							; size = 1
_kb_unput PROC						; COMDAT

; 4177 : { if ( ubuff_spot >= ubuff_max )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _ubuff_max
	push	esi
	mov	esi, DWORD PTR _ubuff_spot
	cmp	esi, eax
	jl	SHORT $LN6@kb_unput

; 4178 :   { if ( unput_buff )

	mov	ecx, DWORD PTR _unput_buff
	test	ecx, ecx
	je	SHORT $LN2@kb_unput

; 4179 :     { ubuff_max *= 2;

	add	eax, eax

; 4180 :       unput_buff = realloc(unput_buff,ubuff_max);

	push	eax
	push	ecx
	mov	DWORD PTR _ubuff_max, eax
	call	_realloc

; 4185 :     }
; 4186 :   }
; 4187 : 
; 4188 :   unput_buff[ubuff_spot++] = c;

	mov	ecx, DWORD PTR _ubuff_spot
	mov	dl, BYTE PTR _c$[ebp]
	add	esp, 8
	mov	DWORD PTR _unput_buff, eax
	mov	BYTE PTR [eax+ecx], dl
	inc	DWORD PTR _ubuff_spot
	pop	esi

; 4189 :   
; 4190 : } // end kb_unput()

	pop	ebp
	ret	0
$LN2@kb_unput:

; 4181 :     }
; 4182 :     else
; 4183 :     { ubuff_max = 16000;
; 4184 :       unput_buff = calloc(ubuff_max,sizeof(char));

	push	1
	push	16000					; 00003e80H
	mov	DWORD PTR _ubuff_max, 16000		; 00003e80H
	call	_calloc

; 4185 :     }
; 4186 :   }
; 4187 : 
; 4188 :   unput_buff[ubuff_spot++] = c;

	mov	cl, BYTE PTR _c$[ebp]
	add	esp, 8
	mov	DWORD PTR _unput_buff, eax
	mov	BYTE PTR [eax+esi], cl
	inc	DWORD PTR _ubuff_spot
	pop	esi

; 4189 :   
; 4190 : } // end kb_unput()

	pop	ebp
	ret	0
$LN6@kb_unput:

; 4185 :     }
; 4186 :   }
; 4187 : 
; 4188 :   unput_buff[ubuff_spot++] = c;

	mov	dl, BYTE PTR _c$[ebp]
	mov	eax, DWORD PTR _unput_buff
	mov	BYTE PTR [eax+esi], dl
	inc	DWORD PTR _ubuff_spot
	pop	esi

; 4189 :   
; 4190 : } // end kb_unput()

	pop	ebp
	ret	0
_kb_unput ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@PGEHNOOP@flex?5scanner?5push?9back?5overflow?$AA@ ; `string'
;	COMDAT ??_C@_0CA@PGEHNOOP@flex?5scanner?5push?9back?5overflow?$AA@
CONST	SEGMENT
??_C@_0CA@PGEHNOOP@flex?5scanner?5push?9back?5overflow?$AA@ DB 'flex scan'
	DB	'ner push-back overflow', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _yyunput
_TEXT	SEGMENT
_c$ = 8							; size = 4
_yy_bp$ = 12						; size = 4
_yyunput PROC						; COMDAT

; 2524 : 	{

	push	ebp
	mov	ebp, esp

; 2525 : 	register char *yy_cp = yy_c_buf_p;
; 2526 : 
; 2527 : 	/* undo effects of setting up yytext */
; 2528 : 	*yy_cp = yy_hold_char;

	mov	cl, BYTE PTR _yy_hold_char
	push	esi
	push	edi
	mov	edi, DWORD PTR _yy_c_buf_p
	mov	BYTE PTR [edi], cl

; 2529 : 
; 2530 : 	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )

	mov	ecx, DWORD PTR _yy_current_buffer
	mov	edx, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [edx+2]
	mov	eax, edi
	cmp	edi, esi
	jae	SHORT $LN10@yyunput

; 2531 : 		{ /* need to shift things up to make room */
; 2532 : 		/* +2 for EOB chars. */
; 2533 : 		register int number_to_move = yy_n_chars + 2;
; 2534 : 		register char *dest = &yy_current_buffer->yy_ch_buf[
; 2535 : 					yy_current_buffer->yy_buf_size + 2];

	mov	esi, DWORD PTR [ecx+12]
	push	ebx

; 2536 : 		register char *source =
; 2537 : 				&yy_current_buffer->yy_ch_buf[number_to_move];

	mov	ebx, DWORD PTR _yy_n_chars
	mov	eax, edx
	lea	esi, DWORD PTR [esi+eax+2]
	lea	eax, DWORD PTR [eax+ebx+2]
	pop	ebx

; 2538 : 
; 2539 : 		while ( source > yy_current_buffer->yy_ch_buf )

	cmp	eax, edx
	jbe	SHORT $LN9@yyunput
	npad	2
$LL3@yyunput:

; 2540 : 			*--dest = *--source;

	mov	dl, BYTE PTR [eax-1]
	dec	eax
	dec	esi
	mov	BYTE PTR [esi], dl
	cmp	eax, DWORD PTR [ecx+4]
	ja	SHORT $LL3@yyunput
$LN9@yyunput:

; 2541 : 
; 2542 : 		yy_cp += (int) (dest - source);
; 2543 : 		yy_bp += (int) (dest - source);
; 2544 : 		yy_n_chars = yy_current_buffer->yy_buf_size;

	mov	edx, DWORD PTR [ecx+12]

; 2545 : 
; 2546 : 		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )

	mov	ecx, DWORD PTR [ecx+4]
	sub	esi, eax
	add	DWORD PTR _yy_bp$[ebp], esi
	lea	eax, DWORD PTR [esi+edi]
	add	ecx, 2
	mov	DWORD PTR _yy_n_chars, edx
	cmp	eax, ecx
	jae	SHORT $LN10@yyunput

; 2547 : 			YY_FATAL_ERROR( "flex scanner push-back overflow" );

	mov	eax, OFFSET ??_C@_0CA@PGEHNOOP@flex?5scanner?5push?9back?5overflow?$AA@
	call	_yy_fatal_error
$LN12@yyunput:
$LN10@yyunput:

; 2548 : 		}
; 2549 : 
; 2550 : 	*--yy_cp = (char) c;

	mov	dl, BYTE PTR _c$[ebp]

; 2551 : 
; 2552 : 
; 2553 : 	yytext_ptr = yy_bp;

	mov	ecx, DWORD PTR _yy_bp$[ebp]
	dec	eax
	mov	BYTE PTR [eax], dl
	mov	DWORD PTR _yytext, ecx

; 2554 : 	yy_hold_char = *yy_cp;

	movzx	edx, BYTE PTR [eax]
	pop	edi
	mov	BYTE PTR _yy_hold_char, dl

; 2555 : 	yy_c_buf_p = yy_cp;

	mov	DWORD PTR _yy_c_buf_p, eax
	pop	esi

; 2556 : 	}

	pop	ebp
	ret	0
$LN11@yyunput:
_yyunput ENDP
_TEXT	ENDS
PUBLIC	_yy_switch_to_buffer
_BSS	SEGMENT
	ALIGN	4

_yy_did_buffer_switch_on_eof DD 01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _yy_switch_to_buffer
_TEXT	SEGMENT
_new_buffer$ = 8					; size = 4
_yy_switch_to_buffer PROC				; COMDAT

; 2651 : 	{

	push	ebp
	mov	ebp, esp

; 2652 : 	if ( yy_current_buffer == new_buffer )

	mov	eax, DWORD PTR _yy_current_buffer
	push	esi
	mov	esi, DWORD PTR _new_buffer$[ebp]
	cmp	eax, esi
	je	SHORT $LN3@yy_switch_

; 2653 : 		return;
; 2654 : 
; 2655 : 	if ( yy_current_buffer )

	test	eax, eax
	je	SHORT $LN1@yy_switch_

; 2656 : 		{
; 2657 : 		/* Flush out information for old buffer. */
; 2658 : 		*yy_c_buf_p = yy_hold_char;

	mov	ecx, DWORD PTR _yy_c_buf_p
	mov	dl, BYTE PTR _yy_hold_char
	mov	BYTE PTR [ecx], dl

; 2659 : 		yy_current_buffer->yy_buf_pos = yy_c_buf_p;

	mov	DWORD PTR [eax+8], ecx

; 2660 : 		yy_current_buffer->yy_n_chars = yy_n_chars;

	mov	ecx, DWORD PTR _yy_n_chars
	mov	DWORD PTR [eax+16], ecx
$LN1@yy_switch_:

; 2661 : 		}
; 2662 : 
; 2663 : 	yy_current_buffer = new_buffer;

	mov	DWORD PTR _yy_current_buffer, esi

; 2664 : 	yy_load_buffer_state();

	call	_yy_load_buffer_state

; 2665 : 
; 2666 : 	/* We don't actually know whether we did this switch during
; 2667 : 	 * EOF (yywrap()) processing, but the only time this flag
; 2668 : 	 * is looked at is after yywrap() is called, so it's safe
; 2669 : 	 * to go ahead and always set it.
; 2670 : 	 */
; 2671 : 	yy_did_buffer_switch_on_eof = 1;

	mov	DWORD PTR _yy_did_buffer_switch_on_eof, 1
$LN3@yy_switch_:
	pop	esi

; 2672 : 	}

	pop	ebp
	ret	0
_yy_switch_to_buffer ENDP
_TEXT	ENDS
PUBLIC	_yy_delete_buffer
; Function compile flags: /Ogtp
;	COMDAT _yy_delete_buffer
_TEXT	SEGMENT
_b$ = 8							; size = 4
_yy_delete_buffer PROC					; COMDAT

; 2725 : 	{

	push	ebp
	mov	ebp, esp
	push	esi

; 2726 : 	if ( ! b )

	mov	esi, DWORD PTR _b$[ebp]
	test	esi, esi
	je	SHORT $LN4@yy_delete_

; 2727 : 		return;
; 2728 : 
; 2729 : 	if ( b == yy_current_buffer )

	cmp	esi, DWORD PTR _yy_current_buffer
	jne	SHORT $LN2@yy_delete_

; 2730 : 		yy_current_buffer = (YY_BUFFER_STATE) 0;

	mov	DWORD PTR _yy_current_buffer, 0
$LN2@yy_delete_:

; 2731 : 
; 2732 : 	if ( b->yy_is_our_buffer )

	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN1@yy_delete_

; 2733 : 		yy_flex_free( (void *) b->yy_ch_buf );

	mov	eax, DWORD PTR [esi+4]
	call	_yy_flex_free
$LN1@yy_delete_:

; 2734 : 
; 2735 : 	yy_flex_free( (void *) b );

	mov	eax, esi
	pop	esi

; 2736 : 	}

	pop	ebp

; 2734 : 
; 2735 : 	yy_flex_free( (void *) b );

	jmp	_yy_flex_free
$LN4@yy_delete_:
	pop	esi

; 2736 : 	}

	pop	ebp
	ret	0
_yy_delete_buffer ENDP
_TEXT	ENDS
PUBLIC	_yy_init_buffer
EXTRN	_isatty:PROC
EXTRN	_fileno:PROC
; Function compile flags: /Ogtp
;	COMDAT _yy_init_buffer
_TEXT	SEGMENT
_b$ = 8							; size = 4
_file$ = 12						; size = 4
_yy_init_buffer PROC					; COMDAT

; 2754 : 	{

	push	ebp
	mov	ebp, esp
	push	esi

; 2755 : 	yy_flush_buffer( b );

	mov	esi, DWORD PTR _b$[ebp]
	push	esi
	call	_yy_flush_buffer

; 2756 : 
; 2757 : 	b->yy_input_file = file;

	mov	eax, DWORD PTR _file$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 2758 : 	b->yy_fill_buffer = 1;

	mov	DWORD PTR [esi+32], 1

; 2759 : 
; 2760 : #if YY_ALWAYS_INTERACTIVE
; 2761 : 	b->yy_is_interactive = 1;
; 2762 : #else
; 2763 : #if YY_NEVER_INTERACTIVE
; 2764 : 	b->yy_is_interactive = 0;
; 2765 : #else
; 2766 : 	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;

	test	eax, eax
	je	SHORT $LN3@yy_init_bu
	push	eax
	call	_fileno
	push	eax
	call	_isatty
	xor	ecx, ecx
	add	esp, 8
	test	eax, eax
	setg	cl
	mov	eax, ecx
	mov	DWORD PTR [esi+24], eax
	pop	esi

; 2767 : #endif
; 2768 : #endif
; 2769 : 	}

	pop	ebp
	ret	0
$LN3@yy_init_bu:

; 2759 : 
; 2760 : #if YY_ALWAYS_INTERACTIVE
; 2761 : 	b->yy_is_interactive = 1;
; 2762 : #else
; 2763 : #if YY_NEVER_INTERACTIVE
; 2764 : 	b->yy_is_interactive = 0;
; 2765 : #else
; 2766 : 	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;

	xor	eax, eax
	mov	DWORD PTR [esi+24], eax
	pop	esi

; 2767 : #endif
; 2768 : #endif
; 2769 : 	}

	pop	ebp
	ret	0
_yy_init_buffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@BNMIIHCN@out?5of?5dynamic?5memory?5in?5yy_scan@ ; `string'
PUBLIC	_yy_scan_buffer
;	COMDAT ??_C@_0CK@BNMIIHCN@out?5of?5dynamic?5memory?5in?5yy_scan@
CONST	SEGMENT
??_C@_0CK@BNMIIHCN@out?5of?5dynamic?5memory?5in?5yy_scan@ DB 'out of dyna'
	DB	'mic memory in yy_scan_buffer()', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _yy_scan_buffer
_TEXT	SEGMENT
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_yy_scan_buffer PROC					; COMDAT

; 2807 : 	{

	push	ebp
	mov	ebp, esp
	push	ebx

; 2808 : 	YY_BUFFER_STATE b;
; 2809 : 
; 2810 : 	if ( size < 2 ||
; 2811 : 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
; 2812 : 	     base[size-1] != YY_END_OF_BUFFER_CHAR )

	mov	ebx, DWORD PTR _size$[ebp]
	push	edi
	cmp	ebx, 2
	jb	SHORT $LN2@yy_scan_bu
	mov	edi, DWORD PTR _base$[ebp]
	cmp	BYTE PTR [edi+ebx-2], 0
	jne	SHORT $LN2@yy_scan_bu
	cmp	BYTE PTR [edi+ebx-1], 0
	jne	SHORT $LN2@yy_scan_bu

; 2815 : 
; 2816 : 	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );

	push	esi
	mov	eax, 40					; 00000028H
	call	_yy_flex_alloc
	mov	esi, eax

; 2817 : 	if ( ! b )

	xor	ecx, ecx
	cmp	esi, ecx
	jne	SHORT $LN1@yy_scan_bu

; 2818 : 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	mov	eax, OFFSET ??_C@_0CK@BNMIIHCN@out?5of?5dynamic?5memory?5in?5yy_scan@
	call	_yy_fatal_error
$LN7@yy_scan_bu:
$LN1@yy_scan_bu:

; 2819 : 
; 2820 : 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */

	lea	eax, DWORD PTR [ebx-2]

; 2821 : 	b->yy_buf_pos = b->yy_ch_buf = base;
; 2822 : 	b->yy_is_our_buffer = 0;
; 2823 : 	b->yy_input_file = 0;
; 2824 : 	b->yy_n_chars = b->yy_buf_size;
; 2825 : 	b->yy_is_interactive = 0;
; 2826 : 	b->yy_at_bol = 1;
; 2827 : 	b->yy_fill_buffer = 0;
; 2828 : 	b->yy_buffer_status = YY_BUFFER_NEW;
; 2829 : 
; 2830 : 	yy_switch_to_buffer( b );

	push	esi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], 1
	mov	DWORD PTR [esi+32], ecx
	mov	DWORD PTR [esi+36], ecx
	call	_yy_switch_to_buffer
	add	esp, 4

; 2831 : 
; 2832 : 	return b;

	mov	eax, esi
	pop	esi
	pop	edi
	pop	ebx

; 2833 : 	}

	pop	ebp
	ret	0
$LN2@yy_scan_bu:
	pop	edi

; 2813 : 		/* They forgot to leave room for the EOB's. */
; 2814 : 		return 0;

	xor	eax, eax
	pop	ebx

; 2833 : 	}

	pop	ebp
	ret	0
$LN6@yy_scan_bu:
_yy_scan_buffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@LOBFGDHO@bad?5buffer?5in?5yy_scan_bytes?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CJ@POHJPACM@out?5of?5dynamic?5memory?5in?5yy_scan@ ; `string'
PUBLIC	_yy_scan_bytes
;	COMDAT ??_C@_0BO@LOBFGDHO@bad?5buffer?5in?5yy_scan_bytes?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BO@LOBFGDHO@bad?5buffer?5in?5yy_scan_bytes?$CI?$CJ?$AA@ DB 'bad bu'
	DB	'ffer in yy_scan_bytes()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@POHJPACM@out?5of?5dynamic?5memory?5in?5yy_scan@
CONST	SEGMENT
??_C@_0CJ@POHJPACM@out?5of?5dynamic?5memory?5in?5yy_scan@ DB 'out of dyna'
	DB	'mic memory in yy_scan_bytes()', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _yy_scan_bytes
_TEXT	SEGMENT
_bytes$ = 8						; size = 4
_n$ = 12						; size = 4
_len$ = 12						; size = 4
_yy_scan_bytes PROC					; COMDAT

; 2862 : 	{

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2863 : 	YY_BUFFER_STATE b;
; 2864 : 	char *buf;
; 2865 : 	yy_size_t n;
; 2866 : 	int i;
; 2867 : 
; 2868 : 	/* Get memory for full buffer, including space for trailing EOB's. */
; 2869 : 	n = len + 2;

	mov	edi, DWORD PTR _len$[ebp]
	lea	esi, DWORD PTR [edi+2]

; 2870 : 	buf = (char *) yy_flex_alloc( n );

	mov	eax, esi
	mov	DWORD PTR _n$[ebp], esi
	call	_yy_flex_alloc

; 2871 : 	if ( ! buf )

	test	eax, eax
	jne	SHORT $LN5@yy_scan_by

; 2872 : 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	mov	eax, OFFSET ??_C@_0CJ@POHJPACM@out?5of?5dynamic?5memory?5in?5yy_scan@
	call	_yy_fatal_error
$LN11@yy_scan_by:
$LN5@yy_scan_by:

; 2873 : 
; 2874 : 	for ( i = 0; i < len; ++i )

	test	edi, edi
	jle	SHORT $LN2@yy_scan_by
	mov	esi, DWORD PTR _bytes$[ebp]
	mov	ecx, eax
	sub	esi, eax
	mov	edx, edi
	push	ebx
$LL4@yy_scan_by:

; 2875 : 		buf[i] = bytes[i];

	mov	bl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [ecx], bl
	inc	ecx
	dec	edx
	jne	SHORT $LL4@yy_scan_by

; 2873 : 
; 2874 : 	for ( i = 0; i < len; ++i )

	mov	esi, DWORD PTR _n$[ebp]
	pop	ebx
$LN2@yy_scan_by:

; 2876 : 
; 2877 : 	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
; 2878 : 
; 2879 : 	b = yy_scan_buffer( buf, n );

	push	esi
	push	eax
	mov	WORD PTR [eax+edi], 0
	call	_yy_scan_buffer
	add	esp, 8
	pop	edi
	pop	esi

; 2880 : 	if ( ! b )

	test	eax, eax
	jne	SHORT $LN1@yy_scan_by

; 2881 : 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	mov	eax, OFFSET ??_C@_0BO@LOBFGDHO@bad?5buffer?5in?5yy_scan_bytes?$CI?$CJ?$AA@
	call	_yy_fatal_error
$LN12@yy_scan_by:
$LN1@yy_scan_by:

; 2882 : 
; 2883 : 	/* It's okay to grow etc. this buffer, and we should throw it
; 2884 : 	 * away when we're done.
; 2885 : 	 */
; 2886 : 	b->yy_is_our_buffer = 1;

	mov	DWORD PTR [eax+20], 1

; 2887 : 
; 2888 : 	return b;
; 2889 : 	}

	pop	ebp
	ret	0
$LN10@yy_scan_by:
_yy_scan_bytes ENDP
_TEXT	ENDS
PUBLIC	_kb_input
; Function compile flags: /Ogtp
;	COMDAT _kb_input
_TEXT	SEGMENT
_kb_input PROC						; COMDAT

; 3192 :   int c;
; 3193 : 
; 3194 :   if ( spot > 0 ) 

	mov	eax, DWORD PTR _spot
	test	eax, eax
	jle	SHORT $retry$90624

; 3195 :     { c = buff[--spot];

	mov	ecx, DWORD PTR _buff
	dec	eax
	mov	DWORD PTR _spot, eax
	movsx	eax, BYTE PTR [ecx+eax]

; 3221 : input_exit:
; 3222 : 
; 3223 :   return c;
; 3224 : } // end kb_input()

	ret	0
$LN22@kb_input:

; 3220 :   if ( c == 0 && in_quote ) { get_more_input(); goto retry; }

	call	_get_more_input
	npad	1
$retry$90624:

; 3196 :       goto input_exit;
; 3197 :     }
; 3198 : 
; 3199 : retry:
; 3200 :   c = rawinput();

	call	_rawinput

; 3201 : 
; 3202 :   if ( c == '\\' )  /* line splicing */

	cmp	eax, 92					; 0000005cH
	je	SHORT $LN18@kb_input

; 3218 :   }
; 3219 :   if ( c == 0 && in_comment ) { get_more_input(); goto retry; }

	test	eax, eax
	jne	SHORT $input_exit$90623
	cmp	DWORD PTR _in_comment, eax
	jne	SHORT $LN22@kb_input

; 3220 :   if ( c == 0 && in_quote ) { get_more_input(); goto retry; }

	cmp	DWORD PTR _in_quote, eax
	je	SHORT $input_exit$90623
	jmp	SHORT $LN22@kb_input
$LN18@kb_input:

; 3203 :   { /* have to do line splicing as input filter to remove 
; 3204 :        special character of line start */
; 3205 :     int cc = c;
; 3206 :     c = rawinput();

	call	_rawinput

; 3207 :     if ( c == 0 ) 

	test	eax, eax
	je	SHORT $LN14@kb_input

; 3208 :     { get_more_input(); c = ' '; goto input_exit; }
; 3209 :     if ( c == '\n' ) 

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN5@kb_input

; 3210 :     { int ccc;
; 3211 :       line_no++;

	inc	DWORD PTR _line_no

; 3212 :       ccc = rawinput();

	call	_rawinput

; 3213 :       if ( ccc == 0 ) 

	test	eax, eax
	je	SHORT $LN14@kb_input

; 3215 :       rawunput(ccc); c = ' ';

	push	eax
	call	_rawunput
	add	esp, 4
	mov	eax, 32					; 00000020H

; 3221 : input_exit:
; 3222 : 
; 3223 :   return c;
; 3224 : } // end kb_input()

	ret	0
$LN5@kb_input:

; 3216 :     } 
; 3217 :     else { rawunput(c); c = cc; /* not linesplicing */ } 

	push	eax
	call	_rawunput
	add	esp, 4
	mov	eax, 92					; 0000005cH

; 3221 : input_exit:
; 3222 : 
; 3223 :   return c;
; 3224 : } // end kb_input()

	ret	0
$LN14@kb_input:

; 3214 :       { get_more_input(); c = ' '; goto input_exit; }

	call	_get_more_input
	mov	eax, 32					; 00000020H
$input_exit$90623:

; 3221 : input_exit:
; 3222 : 
; 3223 :   return c;
; 3224 : } // end kb_input()

	ret	0
_kb_input ENDP
_TEXT	ENDS
PUBLIC	_unput_string
; Function compile flags: /Ogtp
;	COMDAT _unput_string
_TEXT	SEGMENT
_s$ = 8							; size = 4
_unput_string PROC					; COMDAT

; 3245 : { char *c;

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 3246 :   c = s ; while ( *c )  c++;   /* find end of token */

	mov	edi, DWORD PTR _s$[ebp]
	cmp	BYTE PTR [edi], 0
	mov	esi, edi
	je	SHORT $LN1@unput_stri
	npad	1
$LL4@unput_stri:
	inc	esi
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LL4@unput_stri

; 3247 :   while ( c != s ) { --c; unput(*c); }

	cmp	esi, edi
	je	SHORT $LN1@unput_stri
	npad	6
$LL2@unput_stri:
	mov	eax, DWORD PTR _yytext
	movsx	ecx, BYTE PTR [esi-1]
	dec	esi
	push	eax
	push	ecx
	call	_yyunput
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL2@unput_stri
$LN1@unput_stri:
	pop	edi
	pop	esi

; 3248 : } // end unput_string()

	pop	ebp
	ret	0
_unput_string ENDP
_TEXT	ENDS
PUBLIC	??_C@_02CBLDBPFN@?1?1?$AA@			; `string'
PUBLIC	_record_macro
EXTRN	_kb_strstr:PROC
EXTRN	_KB_realloc:PROC
EXTRN	_kb_calloc:PROC
;	COMDAT ??_C@_02CBLDBPFN@?1?1?$AA@
CONST	SEGMENT
??_C@_02CBLDBPFN@?1?1?$AA@ DB '//', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _record_macro
_TEXT	SEGMENT
_backslash_spot$ = -4					; size = 4
_record_macro PROC					; COMDAT

; 3340 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3341 :   int len;
; 3342 :   char *mspot;
; 3343 :   int cont_flag;
; 3344 :   int backslash_spot;
; 3345 : 
; 3346 :   macro_flag = 0;
; 3347 : 
; 3348 :   if ( macro_count >= macro_max )

	mov	eax, DWORD PTR _macro_max
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR _macro_flag, edi
	cmp	DWORD PTR _macro_count, eax
	jl	SHORT $LN31@record_mac

; 3349 :   { if ( macro_max == 0 )

	cmp	eax, edi
	jne	SHORT $LN19@record_mac

; 3350 :     { macro_max = 10; 
; 3351 :       macros = (struct macro *)mycalloc(macro_max,sizeof(struct macro));

	push	3351					; 00000d17H
	push	OFFSET ??_C@_07HIIALNMO@LEXYY?4C?$AA@
	push	40					; 00000028H
	push	10					; 0000000aH
	mov	DWORD PTR _macro_max, 10		; 0000000aH
	call	_kb_calloc
	mov	DWORD PTR _macros, eax

; 3352 :     }
; 3353 :     else

	jmp	SHORT $LN36@record_mac
$LN19@record_mac:

; 3354 :     { 
; 3355 :       macros = (struct macro *)kb_realloc((char *)macros,
; 3356 :         2*macro_max*sizeof(struct macro));

	mov	ecx, DWORD PTR _macros
	push	3356					; 00000d1cH
	lea	eax, DWORD PTR [eax+eax*4]
	push	OFFSET ??_C@_07HIIALNMO@LEXYY?4C?$AA@
	shl	eax, 4
	push	eax
	push	ecx
	call	_KB_realloc

; 3357 :       macro_max *= 2;

	mov	edx, DWORD PTR _macro_max
	mov	DWORD PTR _macros, eax
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR _macro_max, eax
$LN36@record_mac:

; 3354 :     { 
; 3355 :       macros = (struct macro *)kb_realloc((char *)macros,
; 3356 :         2*macro_max*sizeof(struct macro));

	add	esp, 16					; 00000010H
$LN31@record_mac:

; 3358 :     }
; 3359 :   }
; 3360 : 
; 3361 :   strncpy(macros[macro_count].name,yytext,MACRONAMESIZE);

	mov	eax, DWORD PTR _macro_count
	mov	ecx, DWORD PTR _yytext
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _macros
	push	30					; 0000001eH
	push	ecx
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 3362 : 
; 3363 :   if ( macro_subs_max == 0 )

	cmp	DWORD PTR _macro_subs_max, edi
	jne	SHORT $LN34@record_mac

; 3364 :   { macro_subs_max = 2*SUBMAX; 
; 3365 :     macro_subs = (char *)mycalloc(macro_subs_max,1);

	push	3365					; 00000d25H
	push	OFFSET ??_C@_07HIIALNMO@LEXYY?4C?$AA@
	push	1
	push	1000					; 000003e8H
	mov	DWORD PTR _macro_subs_max, 1000		; 000003e8H
	call	_kb_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _macro_subs, eax
$LN34@record_mac:

; 3366 :   }
; 3367 : 
; 3368 :   /* read in macro string */
; 3369 :   for ( len = 0, cont_flag = 0 ; ; len++ )

	xor	esi, esi
	push	ebx
	npad	5
$LL16@record_mac:

; 3370 :     { int c = KB_INPUT();

	call	_kb_input_new
	movsx	ebx, al

; 3371 :       if ( len == 0 && (c == ' ' || c == '\t') )

	test	esi, esi
	jne	SHORT $LN33@record_mac
	cmp	ebx, 32					; 00000020H
	je	SHORT $LN12@record_mac
	cmp	ebx, 9
	jne	SHORT $LN33@record_mac
$LN12@record_mac:

; 3372 :       { len--;

	or	esi, -1
	inc	esi
	jmp	SHORT $LL16@record_mac
$LN33@record_mac:

; 3373 :         continue; /* skip leading whitespace */
; 3374 :       }
; 3375 :       if ( c == '\\' )

	cmp	ebx, 92					; 0000005cH
	jne	SHORT $LN11@record_mac

; 3376 :       { cont_flag = 1;

	lea	edi, DWORD PTR [ebx-91]

; 3377 :         backslash_spot = len;

	mov	DWORD PTR _backslash_spot$[ebp], esi
	jmp	SHORT $LN29@record_mac
$LN11@record_mac:

; 3378 :       }
; 3379 :       else if ( c != ' ' && c != '\t' && c != '\n' && c != 0 )

	cmp	ebx, 32					; 00000020H
	je	SHORT $LN35@record_mac
	cmp	ebx, 9
	je	SHORT $LN35@record_mac
	cmp	ebx, 10					; 0000000aH
	je	SHORT $LN35@record_mac
	test	al, al
	je	SHORT $LN7@record_mac

; 3380 :         cont_flag = 0;

	xor	edi, edi
$LN35@record_mac:

; 3381 :       if ( (c == '\0') || (c == '\n') )

	test	al, al
	je	SHORT $LN7@record_mac
	cmp	ebx, 10					; 0000000aH
	je	SHORT $LN7@record_mac
$LN29@record_mac:

; 3390 :         continue;
; 3391 :       }
; 3392 :       if ( macro_subs_top+len >= macro_subs_max-2 )

	mov	edx, DWORD PTR _macro_subs_top
	mov	eax, DWORD PTR _macro_subs_max
	add	edx, esi
	lea	ecx, DWORD PTR [eax-2]
	cmp	edx, ecx
	jl	SHORT $LN32@record_mac

; 3393 :       { macro_subs = (char *)kb_realloc(macro_subs,macro_subs_max+2*SUBMAX);

	mov	edx, DWORD PTR _macro_subs
	push	3393					; 00000d41H
	push	OFFSET ??_C@_07HIIALNMO@LEXYY?4C?$AA@
	add	eax, 1000				; 000003e8H
	push	eax
	push	edx
	call	_KB_realloc
	add	esp, 16					; 00000010H

; 3394 :         macro_subs_max += 2*SUBMAX;

	add	DWORD PTR _macro_subs_max, 1000		; 000003e8H
	mov	DWORD PTR _macro_subs, eax
$LN32@record_mac:

; 3395 :       }
; 3396 :       macro_subs[macro_subs_top+len] = (char)c;

	mov	eax, DWORD PTR _macro_subs_top
	add	eax, DWORD PTR _macro_subs
	inc	esi
	mov	BYTE PTR [eax+esi-1], bl
	jmp	$LL16@record_mac
$LN7@record_mac:

; 3382 :       { 
; 3383 :         line_no++; 

	inc	DWORD PTR _line_no

; 3384 :         if ( !cont_flag ) 

	test	edi, edi
	je	SHORT $LN26@record_mac

; 3385 :            break; 
; 3386 :         cont_flag = 0;
; 3387 :         len = backslash_spot;
; 3388 :         macro_subs[macro_subs_top+len] = 0;

	mov	eax, DWORD PTR _macro_subs_top
	add	eax, DWORD PTR _macro_subs
	mov	esi, DWORD PTR _backslash_spot$[ebp]
	mov	BYTE PTR [eax+esi], 0

; 3389 :         len--;

	dec	esi
	xor	edi, edi
	inc	esi
	jmp	$LL16@record_mac
$LN26@record_mac:

; 3397 :     }
; 3398 :   mspot = macro_subs+macro_subs_top;

	mov	edi, DWORD PTR _macro_subs_top
	add	edi, DWORD PTR _macro_subs

; 3399 : 
; 3400 :   /* strip terminal comment */
; 3401 :   if ( strstr(mspot,"//") )

	push	OFFSET ??_C@_02CBLDBPFN@?1?1?$AA@
	push	edi
	call	_kb_strstr
	add	esp, 8
	pop	ebx
	test	eax, eax
	je	SHORT $LN4@record_mac

; 3402 :     { *strstr(mspot,"//") = 0;

	push	OFFSET ??_C@_02CBLDBPFN@?1?1?$AA@
	push	edi
	call	_kb_strstr

; 3403 :       len = (int)strlen(mspot);

	mov	esi, edi
	add	esp, 8
	mov	BYTE PTR [eax], 0
	lea	ecx, DWORD PTR [esi+1]
$LL30@record_mac:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL30@record_mac
	sub	esi, ecx
	jmp	SHORT $LN25@record_mac
$LN4@record_mac:

; 3404 :     }
; 3405 :   else mspot[len] = 0;

	mov	BYTE PTR [edi+esi], 0
$LN25@record_mac:

; 3406 :   /* strip trailing blanks */
; 3407 :   while ( (len > 0) && (mspot[len-1] == ' ') ) mspot[--len] = 0;

	test	esi, esi
	jle	SHORT $LN1@record_mac
	npad	5
$LL2@record_mac:
	cmp	BYTE PTR [edi+esi-1], 32		; 00000020H
	jne	SHORT $LN1@record_mac
	dec	esi
	mov	BYTE PTR [edi+esi], 0
	test	esi, esi
	jg	SHORT $LL2@record_mac
$LN1@record_mac:

; 3408 :   macros[macro_count].subsize = len;

	mov	eax, DWORD PTR _macro_count
	mov	ecx, DWORD PTR _macros
	lea	eax, DWORD PTR [eax+eax*4]
	mov	DWORD PTR [ecx+eax*8+36], esi

; 3409 :   macros[macro_count++].offset = macro_subs_top;

	mov	eax, DWORD PTR _macro_count
	mov	ecx, DWORD PTR _macros
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _macro_subs_top
	mov	DWORD PTR [ecx+edx*8+32], eax

; 3410 :   macro_subs_top += len+1;

	mov	edx, DWORD PTR _macro_subs_top
	inc	DWORD PTR _macro_count
	lea	eax, DWORD PTR [edx+esi+1]
	pop	edi
	mov	DWORD PTR _macro_subs_top, eax
	pop	esi

; 3411 : } // end record_macro()

	mov	esp, ebp
	pop	ebp
	ret	0
_record_macro ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@LKGBNJCI@_anti_line_no_?$AA@		; `string'
PUBLIC	_macro
EXTRN	_keep_macros_flag:DWORD
;	COMDAT ??_C@_0P@LKGBNJCI@_anti_line_no_?$AA@
CONST	SEGMENT
??_C@_0P@LKGBNJCI@_anti_line_no_?$AA@ DB '_anti_line_no_', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _macro
_TEXT	SEGMENT
_macro	PROC						; COMDAT

; 3424 :   int n,k;
; 3425 :   char *c;
; 3426 :   
; 3427 :   if ( macro_flag ) { record_macro(); return WAS_MACRO_DEF; }

	cmp	DWORD PTR _macro_flag, 0
	je	SHORT $LN11@macro
	call	_record_macro
	mov	eax, 1

; 3450 : } // end macro()

	ret	0
$LN11@macro:

; 3428 :   if ( strcmp(yytext,"_anti_line_no_") == 0 )

	mov	eax, DWORD PTR _yytext
	mov	ecx, OFFSET ??_C@_0P@LKGBNJCI@_anti_line_no_?$AA@
	npad	2
$LL20@macro:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN21@macro
	test	dl, dl
	je	SHORT $LN22@macro
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN21@macro
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL20@macro
$LN22@macro:
	xor	eax, eax
	jmp	SHORT $LN23@macro
$LN21@macro:
	sbb	eax, eax
	sbb	eax, -1
$LN23@macro:
	test	eax, eax
	jne	SHORT $LN10@macro

; 3429 :   { line_no--;  /* kludge line backup */

	mov	eax, 1
	sub	DWORD PTR _line_no, eax

; 3430 :     errspot -= 15;

	sub	DWORD PTR _errspot, 15			; 0000000fH

; 3450 : } // end macro()

	ret	0
$LN10@macro:

; 3431 :     return 1;
; 3432 :   }
; 3433 : 
; 3434 :   if ( !keep_macros_flag && !datafile_flag ) return 0;  /* no macros in commands */

	cmp	DWORD PTR _keep_macros_flag, 0
	jne	SHORT $LN9@macro
	cmp	DWORD PTR _datafile_flag, 0
	jne	SHORT $LN9@macro
	xor	eax, eax

; 3450 : } // end macro()

	ret	0
$LN9@macro:
	push	ebx
	push	esi

; 3435 :   /* find name, simple linear search */
; 3436 :   for ( n = macro_count-1 ; n >= 0 ; n-- )  /* use latest definition */

	mov	esi, DWORD PTR _macro_count
	dec	esi
	push	edi
	js	SHORT $LN19@macro
	mov	ebx, DWORD PTR _macros
	lea	eax, DWORD PTR [esi+esi*4]
	lea	edi, DWORD PTR [ebx+eax*8]
	npad	7
$LL8@macro:

; 3437 :      if ( strcmp(yytext,macros[n].name) == 0 ) break;

	mov	eax, DWORD PTR _yytext
	mov	ecx, edi
$LL24@macro:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN25@macro
	test	dl, dl
	je	SHORT $LN26@macro
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN25@macro
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL24@macro
$LN26@macro:
	xor	eax, eax
	jmp	SHORT $LN27@macro
$LN25@macro:
	sbb	eax, eax
	sbb	eax, -1
$LN27@macro:
	test	eax, eax
	je	SHORT $LN16@macro

; 3435 :   /* find name, simple linear search */
; 3436 :   for ( n = macro_count-1 ; n >= 0 ; n-- )  /* use latest definition */

	sub	edi, 40					; 00000028H
	dec	esi
	jns	SHORT $LL8@macro

; 3438 : 
; 3439 :   if ( n < 0 ) return 0;   /* not found */

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 3450 : } // end macro()

	ret	0
$LN16@macro:

; 3438 : 
; 3439 :   if ( n < 0 ) return 0;   /* not found */

	test	esi, esi
	jns	SHORT $LN4@macro
$LN19@macro:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 3450 : } // end macro()

	ret	0
$LN4@macro:

; 3440 : 
; 3441 :   /* insert string into input in reverse order so reads ok */
; 3442 :   c = macro_subs+macros[n].offset;

	lea	ecx, DWORD PTR [esi+esi*4]
	mov	edi, DWORD PTR [ebx+ecx*8+32]

; 3443 :   for ( k = macros[n].subsize - 1 ; k >= 0 ; k-- )

	mov	esi, DWORD PTR [ebx+ecx*8+36]
	add	edi, DWORD PTR _macro_subs
	dec	esi
	lea	eax, DWORD PTR [ebx+ecx*8]
	js	SHORT $LN1@macro
	npad	3
$LL3@macro:

; 3444 :     KB_UNPUT(c[k]);

	movzx	edx, BYTE PTR [esi+edi]
	push	edx
	call	_kb_unput
	add	esp, 4
	dec	esi
	jns	SHORT $LL3@macro
$LN1@macro:

; 3445 : 
; 3446 :   KB_UNPUT(' ');  /* substitution starts with whitespace; for proper

	push	32					; 00000020H
	call	_kb_unput
	add	esp, 4
	pop	edi
	pop	esi

; 3447 :                      preservation of unary minus leading in the macro */
; 3448 : 
; 3449 :   return MACRO_EXPANDED;

	mov	eax, 2
	pop	ebx

; 3450 : } // end macro()

	ret	0
_macro	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@LCPJAPLP@Unhandled?5state?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@DHNHEAEL@You?5mistyped?5?8?$DL?$DN?8?5for?5?8?3?$DN?8?$DP?6?$AA@ ; `string'
PUBLIC	__real@41dfffffffc00000
PUBLIC	??_C@_0CO@JMNNKCOA@Single?5quote?5not?5closed?5after?5on@ ; `string'
PUBLIC	??_C@_0BI@GCFMAGKE@Dangling?5single?5quote?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@OHKGDBKM@Empty?5single?5quotes?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@KLMIAMJK@Illegal?5token?5?8?$CG?8?5?5Line?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@JALBIPLM@Illegal?5token?5?8?3?3?3?8?5?5Line?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@NMIBGLJK@Illegal?5token?5?8?3?3?8?5?5Line?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0DD@DNMMELCD@Missing?5exponent?5for?5scientific?5@ ; `string'
PUBLIC	??_C@_0BI@DHOEFMOD@End?9of?9file?5in?5comment?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@NBEKCKOC@Missing?5task?5number?4?5Line?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BO@JPEPPLDA@Missing?5task?5number?0?5line?5?$CFd?4?$AA@ ; `string'
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	??_C@_0BP@BCHKDMKI@Illegal?5?$CD?5directive?0?5line?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@JOFLDBCP@Unclosed?5quote?5after?5?$CDinclude?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@NMJMJNCI@Need?5double?9quoted?5filename?5afte@ ; `string'
PUBLIC	??_C@_08GPLAJCBH@?$CDinclude?$AA@		; `string'
PUBLIC	??_C@_0CI@OBOFPJIA@?$CDdefine?5valid?5only?5in?5top?5of?5dat@ ; `string'
PUBLIC	??_C@_07MAHLPAJA@?$CDdefine?$AA@		; `string'
PUBLIC	??_C@_0DO@PIEGGMIL@Illegal?5backslash?4?5Backslash?5is?5@ ; `string'
PUBLIC	??_C@_0BI@NJGLLJPD@Illegal?5character?5?8?$CFc?8?6?$AA@ ; `string'
PUBLIC	_kblex
EXTRN	_lists_flag:DWORD
EXTRN	_reduce_string:PROC
EXTRN	_cond_expr_flag:DWORD
EXTRN	_isalnum:PROC
EXTRN	_atof:PROC
EXTRN	_strchr:PROC
EXTRN	_uminus_flag:DWORD
EXTRN	_isspace:PROC
EXTRN	_sscanf:PROC
EXTRN	_push_commandfd:PROC
EXTRN	_isalpha:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BF@LCPJAPLP@Unhandled?5state?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BF@LCPJAPLP@Unhandled?5state?3?5?$CFd?6?$AA@ DB 'Unhandled state: '
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DHNHEAEL@You?5mistyped?5?8?$DL?$DN?8?5for?5?8?3?$DN?8?$DP?6?$AA@
CONST	SEGMENT
??_C@_0BN@DHNHEAEL@You?5mistyped?5?8?$DL?$DN?8?5for?5?8?3?$DN?8?$DP?6?$AA@ DB 'Y'
	DB	'ou mistyped '';='' for '':=''?', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+009
CONST	ENDS
;	COMDAT ??_C@_0CO@JMNNKCOA@Single?5quote?5not?5closed?5after?5on@
CONST	SEGMENT
??_C@_0CO@JMNNKCOA@Single?5quote?5not?5closed?5after?5on@ DB 'Single quot'
	DB	'e not closed after one character.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GCFMAGKE@Dangling?5single?5quote?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@GCFMAGKE@Dangling?5single?5quote?4?6?$AA@ DB 'Dangling single q'
	DB	'uote.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OHKGDBKM@Empty?5single?5quotes?4?6?$AA@
CONST	SEGMENT
??_C@_0BG@OHKGDBKM@Empty?5single?5quotes?4?6?$AA@ DB 'Empty single quotes'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KLMIAMJK@Illegal?5token?5?8?$CG?8?5?5Line?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BM@KLMIAMJK@Illegal?5token?5?8?$CG?8?5?5Line?5?$CFd?6?$AA@ DB 'Ill'
	DB	'egal token ''&''  Line %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JALBIPLM@Illegal?5token?5?8?3?3?3?8?5?5Line?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BO@JALBIPLM@Illegal?5token?5?8?3?3?3?8?5?5Line?5?$CFd?6?$AA@ DB 'I'
	DB	'llegal token '':::''  Line %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NMIBGLJK@Illegal?5token?5?8?3?3?8?5?5Line?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BN@NMIBGLJK@Illegal?5token?5?8?3?3?8?5?5Line?5?$CFd?6?$AA@ DB 'Ill'
	DB	'egal token ''::''  Line %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@DNMMELCD@Missing?5exponent?5for?5scientific?5@
CONST	SEGMENT
??_C@_0DD@DNMMELCD@Missing?5exponent?5for?5scientific?5@ DB 'Missing expo'
	DB	'nent for scientific notation. Line %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DHOEFMOD@End?9of?9file?5in?5comment?6?$AA@
CONST	SEGMENT
??_C@_0BI@DHOEFMOD@End?9of?9file?5in?5comment?6?$AA@ DB 'End-of-file in c'
	DB	'omment', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NBEKCKOC@Missing?5task?5number?4?5Line?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BN@NBEKCKOC@Missing?5task?5number?4?5Line?5?$CFd?$AA@ DB 'Missing '
	DB	'task number. Line %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JPEPPLDA@Missing?5task?5number?0?5line?5?$CFd?4?$AA@
CONST	SEGMENT
??_C@_0BO@JPEPPLDA@Missing?5task?5number?0?5line?5?$CFd?4?$AA@ DB 'Missin'
	DB	'g task number, line %d.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BCHKDMKI@Illegal?5?$CD?5directive?0?5line?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@BCHKDMKI@Illegal?5?$CD?5directive?0?5line?5?$CFd?4?6?$AA@ DB 'I'
	DB	'llegal # directive, line %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JOFLDBCP@Unclosed?5quote?5after?5?$CDinclude?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@JOFLDBCP@Unclosed?5quote?5after?5?$CDinclude?4?6?$AA@ DB 'Unclo'
	DB	'sed quote after #include.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NMJMJNCI@Need?5double?9quoted?5filename?5afte@
CONST	SEGMENT
??_C@_0CN@NMJMJNCI@Need?5double?9quoted?5filename?5afte@ DB 'Need double-'
	DB	'quoted filename after #include.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GPLAJCBH@?$CDinclude?$AA@
CONST	SEGMENT
??_C@_08GPLAJCBH@?$CDinclude?$AA@ DB '#include', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OBOFPJIA@?$CDdefine?5valid?5only?5in?5top?5of?5dat@
CONST	SEGMENT
??_C@_0CI@OBOFPJIA@?$CDdefine?5valid?5only?5in?5top?5of?5dat@ DB '#define'
	DB	' valid only in top of datafile.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MAHLPAJA@?$CDdefine?$AA@
CONST	SEGMENT
??_C@_07MAHLPAJA@?$CDdefine?$AA@ DB '#define', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@PIEGGMIL@Illegal?5backslash?4?5Backslash?5is?5@
CONST	SEGMENT
??_C@_0DO@PIEGGMIL@Illegal?5backslash?4?5Backslash?5is?5@ DB 'Illegal bac'
	DB	'kslash. Backslash is line continuation character.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NJGLLJPD@Illegal?5character?5?8?$CFc?8?6?$AA@
CONST	SEGMENT
??_C@_0BI@NJGLLJPD@Illegal?5character?5?8?$CFc?8?6?$AA@ DB 'Illegal chara'
	DB	'cter ''%c''', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _kblex
_TEXT	SEGMENT
tv812 = -8						; size = 4
_yyspot$ = -8						; size = 4
_nextchar$ = -4						; size = 1
_kblex	PROC						; COMDAT

; 4204 : { int state;

	push	ebp
	mov	ebp, esp

; 4205 :   unsigned char nextchar;
; 4206 :   char *yyspot; /* first empty spot in yytext */
; 4207 :   int retval;
; 4208 : 
; 4209 :   PROF_START(kblex);
; 4210 : 
; 4211 :   if ( !yytext )

	mov	eax, DWORD PTR _yytext
	sub	esp, 8
	test	eax, eax
	jne	SHORT $LN315@kblex

; 4212 :   { yytext_max = 200;
; 4213 :     yytext = calloc(yytext_max,sizeof(char));

	push	1
	push	200					; 000000c8H
	mov	DWORD PTR _yytext_max, 200		; 000000c8H
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _yytext, eax
$LN315@kblex:

; 4214 :   } 
; 4215 : 
; 4216 :     yyspot = yytext;
; 4217 :     memset(&yylval,0,sizeof(yylval));

	push	ebx
	push	esi
	push	edi
	push	104					; 00000068H
	push	0
	push	OFFSET _yylval
	mov	DWORD PTR _yyspot$[ebp], eax
	call	_memset

; 4218 :     state = tok ? L_START : L_LINESTART;

	xor	eax, eax
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _tok, eax
	sete	al
	lea	esi, DWORD PTR [eax*8+1]
	npad	10
$LL316@kblex:

; 4936 :           break;

	mov	edi, DWORD PTR _yyspot$[ebp]
$LL228@kblex:

; 4219 :     
; 4220 :     for(;;)
; 4221 :     { int len = yyspot-yytext;

	mov	ecx, DWORD PTR _yytext

; 4222 :       if ( len >= yytext_max-2 )

	mov	eax, DWORD PTR _yytext_max
	mov	ebx, edi
	sub	ebx, ecx
	lea	edx, DWORD PTR [eax-2]
	cmp	ebx, edx
	jl	SHORT $LN226@kblex

; 4223 :       { yytext_max *= 2;

	add	eax, eax

; 4224 :         yytext = realloc(yytext,yytext_max);

	push	eax
	push	ecx
	mov	DWORD PTR _yytext_max, eax
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _yytext, eax

; 4225 :         yyspot = yytext + len;

	lea	edi, DWORD PTR [eax+ebx]
$LN226@kblex:

; 4226 :       }
; 4227 :       *(yyspot++) = nextchar = kb_input_new();

	call	_kb_input_new
	mov	bl, al
	mov	BYTE PTR [edi], bl
	inc	edi

; 4228 :       switch ( state )

	lea	eax, DWORD PTR [esi-1]
	mov	BYTE PTR _nextchar$[ebp], bl
	mov	DWORD PTR _yyspot$[ebp], edi
	cmp	eax, 37					; 00000025H
	ja	$LN1@kblex
	jmp	DWORD PTR $LN343@kblex[eax*4]
$LN223@kblex:

; 4229 :       {
; 4230 :         case L_START:
; 4231 :            if ( nextchar == '0' )

	cmp	bl, 48					; 00000030H
	jne	SHORT $LN222@kblex

; 4232 :              state = L_ZERO;

	mov	esi, 27					; 0000001bH
	jmp	SHORT $LL228@kblex
$LN222@kblex:

; 4233 :            else if ( isdigit(nextchar) )

	movzx	eax, bl
	push	eax
	mov	DWORD PTR tv812[ebp], eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN220@kblex

; 4234 :              state = L_DIGITS;

	mov	esi, 5
	jmp	SHORT $LL228@kblex
$LN220@kblex:

; 4235 :            else if ( isalpha(nextchar) ) 

	mov	eax, DWORD PTR tv812[ebp]
	push	eax
	call	_isalpha
	add	esp, 4
	test	eax, eax
	je	SHORT $LN218@kblex
$LN209@kblex:

; 4236 :              state = L_ALPHANUM;

	mov	esi, 14					; 0000000eH

; 4237 :            else

	jmp	$LL228@kblex
$LN218@kblex:

; 4238 :            switch ( nextchar )

	mov	eax, DWORD PTR tv812[ebp]
	cmp	eax, 147				; 00000093H
	ja	$LN189@kblex
	movzx	ecx, BYTE PTR $LN293@kblex[eax]
	jmp	DWORD PTR $LN344@kblex[ecx*4]
$LN213@kblex:

; 4241 :              case '\n' : line_no++; yyspot = yytext; state = L_LINESTART;

	inc	DWORD PTR _line_no
	mov	edi, DWORD PTR _yytext
	mov	esi, 9

; 4242 :                          break;

	jmp	$LL228@kblex
$LN212@kblex:

; 4243 :              case ' ': case '\t':
; 4244 :                yyspot--; state = L_WHITESPACE; break;

	dec	edi
	mov	esi, 7
	jmp	$LL228@kblex
$LN211@kblex:

; 4245 :              case '/':  state = L_SLASH; break;

	mov	esi, 2
	jmp	$LL228@kblex
$LN210@kblex:

; 4246 :              case '.':  state = L_DOT; break;         

	mov	esi, 4
	jmp	$LL228@kblex
$LN208@kblex:

; 4247 :              case '_':  state = L_ALPHANUM; break;
; 4248 :              case ':':  state = L_COLON; break;

	mov	esi, 15					; 0000000fH
	jmp	$LL228@kblex
$LN207@kblex:

; 4249 :              case ';':  state = L_SEMICOLON; break;

	mov	esi, 16					; 00000010H
	jmp	$LL228@kblex
$LN206@kblex:

; 4250 :              case '+':  state = L_PLUS; break;

	mov	esi, 17					; 00000011H
	jmp	$LL228@kblex
$LN205@kblex:

; 4251 :              case '-':  state = L_MINUS; break; 

	mov	esi, 18					; 00000012H
	jmp	$LL228@kblex
$LN204@kblex:

; 4252 :              case '*':  state = L_STAR; break; 

	mov	esi, 19					; 00000013H
	jmp	$LL228@kblex
$LN203@kblex:

; 4253 :              case '!':  state = L_BANG; break; 

	mov	esi, 20					; 00000014H
	jmp	$LL228@kblex
$LN202@kblex:

; 4254 :              case '|':  state = L_PIPE; break; 

	mov	esi, 21					; 00000015H
	jmp	$LL228@kblex
$LN201@kblex:

; 4255 :              case '&':  state = L_AND; break; 

	mov	esi, 22					; 00000016H
	jmp	$LL228@kblex
$LN200@kblex:

; 4256 :              case '>':  state = L_GREATER; break;

	mov	esi, 23					; 00000017H
	jmp	$LL228@kblex
$LN199@kblex:

; 4257 :              case '\'': case 0x91: state = L_SINGLE_QUOTE; break;

	mov	esi, 25					; 00000019H
	jmp	$LL228@kblex
$LN198@kblex:

; 4258 :              case '"': case 0x93: state = L_QUOTE; break;

	mov	esi, 32					; 00000020H
	jmp	$LL228@kblex
$LN197@kblex:

; 4259 :              case '`':  state = L_BACKQUOTE; break;

	mov	esi, 29					; 0000001dH
	jmp	$LL228@kblex
$LN196@kblex:

; 4260 :              case '=':  state = L_EQUAL; break;

	mov	esi, 33					; 00000021H
	jmp	$LL228@kblex
$LN195@kblex:

; 4261 :              case '<':  state = L_LESS; break;

	mov	esi, 34					; 00000022H
	jmp	$LL228@kblex
$LN194@kblex:

; 4262 :              case '\\': state = L_BACKSLASH; break;

	mov	esi, 37					; 00000025H
	jmp	$LL228@kblex
$LN193@kblex:

; 4263 :              case '#':  state = L_SHARP; break;

	mov	esi, 30					; 0000001eH
	jmp	$LL228@kblex
$LN189@kblex:

; 4278 :                 *yyspot = 0; tok = nextchar; goto kblex_exit;
; 4279 :              default:  
; 4280 :                sprintf(errmsg,"Illegal character '%c'\n",nextchar);

	mov	edx, DWORD PTR tv812[ebp]
	push	edx
	push	OFFSET ??_C@_0BI@NJGLLJPD@Illegal?5character?5?8?$CFc?8?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4281 :                kb_error(3658,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3658					; 00000e4aH
	call	_kb_error
	add	esp, 24					; 00000018H

; 4282 :            }
; 4283 :            break;

	jmp	$LL228@kblex
$LL187@kblex:

; 4284 : 
; 4285 :         case L_BACKSLASH:
; 4286 :            /* allow trailing whitespace */
; 4287 :            while ( nextchar == ' ' || nextchar == '\t' )

	cmp	bl, 32					; 00000020H
	je	SHORT $LN185@kblex
	cmp	bl, 9
	jne	SHORT $LN186@kblex
$LN185@kblex:

; 4288 :               nextchar = kb_input_new();

	call	_kb_input_new
	mov	bl, al
	jmp	SHORT $LL187@kblex
$LN186@kblex:

; 4289 :            if ( nextchar == '\n' )

	cmp	bl, 10					; 0000000aH
	jne	SHORT $LN184@kblex

; 4290 :            { yyspot = yytext;

	mov	edi, DWORD PTR _yytext

; 4291 :              state = L_START;

	mov	esi, 1

; 4292 :              line_no++;

	add	DWORD PTR _line_no, esi

; 4293 :              if ( datafile_flag != IN_DATAFILE )

	cmp	DWORD PTR _datafile_flag, esi
	je	$LL228@kblex

; 4294 :                get_more_input();

	call	_get_more_input

; 4295 :              break;

	jmp	$LL228@kblex
$LN184@kblex:

; 4296 :            }
; 4297 :            kb_error(3659,
; 4298 :               "Illegal backslash. Backslash is line continuation character.\n",
; 4299 :                  RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DO@PIEGGMIL@Illegal?5backslash?4?5Backslash?5is?5@
	push	3659					; 00000e4bH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 4300 :            break;

	jmp	$LL228@kblex
$LN168@kblex:

; 4346 :              goto kblex_exit;
; 4347 :            }
; 4348 :            break;
; 4349 : 
; 4350 :         case L_GREATER:
; 4351 :            if ( nextchar == '>' )

	cmp	bl, 62					; 0000003eH
	jne	$LN167@kblex

; 4352 :               state = L_GRGR;

	mov	esi, 28					; 0000001cH

; 4362 :              goto kblex_exit;
; 4363 :            }
; 4364 :            break;

	jmp	$LL228@kblex
$LN163@kblex:

; 4365 : 
; 4366 :         case L_GRGR:
; 4367 :            if ( nextchar == '>' )

	cmp	bl, 62					; 0000003eH
	jne	$LN162@kblex

; 4368 :            { *yyspot = 0;

	mov	BYTE PTR [edi], 0

; 4369 :              tok = REDIRECTOVER_TOK;

	mov	DWORD PTR _tok, 495			; 000001efH

; 4370 :              state = L_GRGRGR;

	mov	esi, 38					; 00000026H

; 4381 :              goto kblex_exit;
; 4382 :            }
; 4383 :            break;

	jmp	$LL228@kblex
$LN240@kblex:

; 4424 :            goto kblex_exit;
; 4425 :            break;
; 4426 : 
; 4427 :         case L_SHARP:
; 4428 :            while ( isalpha(nextchar) )

	movzx	eax, bl
	push	eax
	call	_isalpha
	add	esp, 4
	test	eax, eax
	je	SHORT $LN143@kblex
	npad	3
$LL144@kblex:

; 4429 :               *(yyspot++) = nextchar = kb_input_new();

	call	_kb_input_new
	mov	bl, al
	movzx	ecx, bl
	mov	BYTE PTR [edi], bl
	push	ecx
	inc	edi
	call	_isalpha
	add	esp, 4
	test	eax, eax
	jne	SHORT $LL144@kblex
	mov	DWORD PTR _yyspot$[ebp], edi
$LN143@kblex:

; 4430 :            yyspot[-1] = 0;

	mov	edx, DWORD PTR _yyspot$[ebp]
	mov	BYTE PTR [edx-1], 0

; 4431 :            if ( strcmp(yytext,"#define") == 0 )

	mov	edx, DWORD PTR _yytext
	mov	edi, OFFSET ??_C@_07MAHLPAJA@?$CDdefine?$AA@
	mov	eax, edx
$LL328@kblex:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edi]
	jne	SHORT $LN295@kblex
	test	cl, cl
	je	SHORT $LN296@kblex
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edi+1]
	jne	SHORT $LN295@kblex
	add	eax, 2
	add	edi, 2
	test	cl, cl
	jne	SHORT $LL328@kblex
$LN296@kblex:
	xor	eax, eax
	jmp	SHORT $LN297@kblex
$LN295@kblex:
	sbb	eax, eax
	sbb	eax, -1
$LN297@kblex:
	test	eax, eax
	jne	SHORT $LN142@kblex

; 4432 :            { if (!datafile_flag)

	cmp	DWORD PTR _datafile_flag, eax
	jne	SHORT $LN141@kblex

; 4433 :              kb_error(2853,"#define valid only in top of datafile.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CI@OBOFPJIA@?$CDdefine?5valid?5only?5in?5top?5of?5dat@
	push	2853					; 00000b25H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN141@kblex:

; 4434 :              macro_flag = 1;
; 4435 :              state = L_START;
; 4436 :              yyspot = yytext;

	mov	eax, DWORD PTR _yytext
	mov	esi, 1
	mov	DWORD PTR _macro_flag, esi

; 4437 :              break;

	mov	edi, eax
	jmp	$LL228@kblex
$LN142@kblex:

; 4438 :            }
; 4439 :            if ( strcmp(yytext,"#include") == 0 )

	mov	edi, OFFSET ??_C@_08GPLAJCBH@?$CDinclude?$AA@
	mov	eax, edx
$LL329@kblex:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edi]
	jne	SHORT $LN299@kblex
	test	cl, cl
	je	SHORT $LN300@kblex
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edi+1]
	jne	SHORT $LN299@kblex
	add	eax, 2
	add	edi, 2
	test	cl, cl
	jne	SHORT $LL329@kblex
$LN300@kblex:
	xor	eax, eax
	jmp	SHORT $LN301@kblex
$LN299@kblex:
	sbb	eax, eax
	sbb	eax, -1
$LN301@kblex:
	test	eax, eax
	jne	$LN140@kblex

; 4440 :            { 
; 4441 :              while ( (nextchar != '"' && nextchar != 0x94) && nextchar > 0 && nextchar != '\n' ) 

	cmp	bl, 34					; 00000022H
	je	SHORT $LN319@kblex
$LL139@kblex:
	cmp	bl, 148					; 00000094H
	je	SHORT $LN138@kblex
	test	bl, bl
	je	SHORT $LN138@kblex
	cmp	bl, 10					; 0000000aH
	je	SHORT $LN138@kblex

; 4442 :                 nextchar = kb_input_new();

	call	_kb_input_new
	mov	bl, al
	cmp	bl, 34					; 00000022H
	jne	SHORT $LL139@kblex

; 4443 :              if ( (nextchar != '"' && nextchar != 0x94) )

	jmp	SHORT $LN319@kblex
$LN138@kblex:
	cmp	bl, 34					; 00000022H
	je	SHORT $LN319@kblex
	cmp	bl, 148					; 00000094H
	je	SHORT $LN319@kblex

; 4444 :              { kb_error(6377,"Need double-quoted filename after #include.\n",UNRECOVERABLE);

	push	0
	push	OFFSET ??_C@_0CN@NMJMJNCI@Need?5double?9quoted?5filename?5afte@
	push	6377					; 000018e9H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN319@kblex:

; 4445 :              }
; 4446 :              yyspot = yytext;

	mov	esi, DWORD PTR _yytext
$LL136@kblex:

; 4447 :              do
; 4448 :                *(yyspot++) = nextchar = kb_input_new();

	call	_kb_input_new
	mov	BYTE PTR [esi], al
	inc	esi

; 4449 :              while ( (nextchar != '"' && nextchar != 0x94) && nextchar > 0 && nextchar != '\n');

	cmp	al, 34					; 00000022H
	je	SHORT $LN321@kblex
	cmp	al, 148					; 00000094H
	je	SHORT $LN321@kblex
	test	al, al
	je	SHORT $LN133@kblex
	cmp	al, 10					; 0000000aH
	jne	SHORT $LL136@kblex
$LN133@kblex:

; 4450 :              if ( (nextchar != '"' && nextchar != 0x94) )

	cmp	al, 148					; 00000094H
	je	SHORT $LN321@kblex

; 4451 :              { kb_error(6378,"Unclosed quote after #include.\n",UNRECOVERABLE);

	push	0
	push	OFFSET ??_C@_0CA@JOFLDBCP@Unclosed?5quote?5after?5?$CDinclude?4?6?$AA@
	push	6378					; 000018eaH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN321@kblex:

; 4452 :              }
; 4453 :              yyspot[-1] = 0;

	mov	BYTE PTR [esi-1], 0

; 4454 :              push_commandfd(NULL,yytext);

	mov	ecx, DWORD PTR _yytext
	push	ecx
	push	0
	call	_push_commandfd

; 4455 :              state = L_LINESTART;
; 4456 :              yyspot = yytext;

	mov	edx, DWORD PTR _yytext
	add	esp, 8
	mov	esi, 9

; 4457 :              break;

	mov	edi, edx
	jmp	$LL228@kblex
$LN140@kblex:

; 4458 :            }         
; 4459 : 		   sprintf(errmsg,"Illegal # directive, line %d.\n",line_no);

	mov	eax, DWORD PTR _line_no
	push	eax
	push	OFFSET ??_C@_0BP@BCHKDMKI@Illegal?5?$CD?5directive?0?5line?5?$CFd?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4460 : 		   kb_error(3681,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3681					; 00000e61H
	call	_kb_error
	add	esp, 24					; 00000018H

; 4461 :            break;

	jmp	$LL316@kblex
$LN131@kblex:

; 4462 : 
; 4463 :         case L_ZERO:
; 4464 :            if ( toupper(nextchar) == 'X' )

	movzx	eax, bl
	cmp	BYTE PTR _kb_upper_array[eax], 88	; 00000058H
	jne	SHORT $LN130@kblex

; 4465 :              state = L_HEXNUMBER;

	mov	esi, 26					; 0000001aH
	jmp	$LL228@kblex
$LN130@kblex:

; 4466 :            else if ( nextchar == '.' )

	cmp	bl, 46					; 0000002eH
	jne	SHORT $LN128@kblex

; 4467 :              state = L_DIGITS_DOT;

	mov	esi, 6
	jmp	$LL228@kblex
$LN128@kblex:

; 4468 :            else if ( isdigit(nextchar) )

	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	$LN126@kblex

; 4469 :              state = L_DIGITS;

	mov	esi, 5

; 4476 :              goto kblex_exit;
; 4477 :            }
; 4478 :            break;

	jmp	$LL228@kblex
$LN124@kblex:

; 4479 : 
; 4480 :         case L_HEXNUMBER:
; 4481 :            if ( isdigit(nextchar) ||
; 4482 :                  (toupper(nextchar) >= 'A' && toupper(nextchar) <= 'F') )

	movzx	ebx, bl
	push	ebx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	$LL228@kblex
	mov	al, BYTE PTR _kb_upper_array[ebx]
	cmp	al, 65					; 00000041H
	jl	SHORT $LN123@kblex
	cmp	al, 70					; 00000046H
	jle	$LL228@kblex
$LN123@kblex:

; 4483 :               break;
; 4484 :            yyspot[-1] = 0;
; 4485 :            kb_unput(nextchar);

	mov	eax, DWORD PTR _nextchar$[ebp]
	push	eax
	mov	BYTE PTR [edi-1], 0
	call	_kb_unput

; 4486 :            sscanf(yytext+2,"%x",&yylval.i);

	mov	ecx, DWORD PTR _yytext
	push	OFFSET _yylval
	add	ecx, 2
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	ecx
	call	_sscanf
	add	esp, 16					; 00000010H
$LN342@kblex:

; 4487 :            yylval.r = (REAL)yylval.i;

	fild	DWORD PTR _yylval
	pop	edi

; 4488 :            verb_flag = 0;
; 4489 :            tok = INTEGER_TOK;

	mov	eax, 265				; 00000109H
	pop	esi
	fstp	QWORD PTR _yylval+16
	mov	DWORD PTR _verb_flag, 0

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN121@kblex:

; 4490 :            goto kblex_exit;
; 4491 : 
; 4492 :         case L_WHITESPACE:
; 4493 :            if ( nextchar == '+' || nextchar == '-' )

	cmp	bl, 43					; 0000002bH
	je	SHORT $LN119@kblex
	cmp	bl, 45					; 0000002dH
	je	SHORT $LN119@kblex

; 4496 :            }
; 4497 :            if ( nextchar == ' ' || nextchar == '\t' )

	cmp	bl, 32					; 00000020H
	je	SHORT $LN117@kblex
	cmp	bl, 9
	je	SHORT $LN117@kblex

; 4498 :            { yyspot--; break;
; 4499 :            }
; 4500 :            else
; 4501 :            { state = L_START;
; 4502 :              kb_unput(nextchar);

	mov	ecx, DWORD PTR _nextchar$[ebp]
	push	ecx
	mov	esi, 1
	call	_kb_unput
	add	esp, 4
$LN117@kblex:

; 4503 :              yyspot--;

	dec	edi

; 4504 :            }
; 4505 :            break;

	jmp	$LL228@kblex
$LN119@kblex:

; 4494 :            { state = L_WHITESIGN;

	mov	esi, 8

; 4495 :              break;

	jmp	$LL228@kblex
$LN115@kblex:

; 4506 : 
; 4507 :         case L_WHITESIGN:
; 4508 :            kb_unput(nextchar);

	mov	edx, DWORD PTR _nextchar$[ebp]
	push	edx
	call	_kb_unput

; 4509 :            if ( !isspace(nextchar) && (yytext[0] == '-') )

	movzx	eax, bl
	push	eax
	call	_isspace
	add	esp, 8
	test	eax, eax
	mov	eax, DWORD PTR _yytext
	jne	SHORT $LN113@kblex
	cmp	BYTE PTR [eax], 45			; 0000002dH
	jne	SHORT $LN113@kblex

; 4510 :            { if ( datafile_flag && uminus_flag && (parens == 0) )

	cmp	DWORD PTR _datafile_flag, 0
	je	SHORT $LN113@kblex
	cmp	DWORD PTR _uminus_flag, 0
	je	SHORT $LN113@kblex
	cmp	DWORD PTR _parens, 0
	je	$LN250@kblex
$LN113@kblex:

; 4512 :                goto kblex_exit;
; 4513 :              }
; 4514 :            }
; 4515 :            /* else go back and treat as ordinary - */
; 4516 :            yyspot--;
; 4517 :            state = yytext[0] == '+' ? L_PLUS : L_MINUS;

	xor	ecx, ecx
	dec	edi
	cmp	BYTE PTR [eax], 43			; 0000002bH
	setne	cl
	lea	esi, DWORD PTR [ecx+17]

; 4518 :            break;

	jmp	$LL228@kblex
$LN112@kblex:

; 4519 : 
; 4520 :         case L_LINESTART:
; 4521 :            if ( nextchar == 0 ) 

	test	bl, bl
	je	$LN214@kblex

; 4522 :            { tok = 0;
; 4523 :              goto kblex_exit;
; 4524 :            }
; 4525 :            if ( nextchar == ' ' || nextchar == '\t' )

	cmp	bl, 32					; 00000020H
	je	SHORT $LN117@kblex
	cmp	bl, 9
	je	SHORT $LN117@kblex

; 4526 :              yyspot--;
; 4527 :            else if ( isdigit(nextchar) )

	movzx	edx, bl
	push	edx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN107@kblex

; 4528 :              state = L_LEAD_INTEGER;

	mov	esi, 10					; 0000000aH
	jmp	$LL228@kblex
$LN107@kblex:

; 4529 :            else if ( nextchar == '-' )

	cmp	bl, 45					; 0000002dH
	jne	SHORT $LN105@kblex

; 4530 :              state = L_LEAD_MINUS;

	mov	esi, 36					; 00000024H

; 4531 :            else

	jmp	$LL228@kblex
$LN105@kblex:

; 4532 :            { kb_unput(nextchar);

	mov	eax, DWORD PTR _nextchar$[ebp]
	push	eax
	call	_kb_unput

; 4533 :              state = L_START;
; 4534 :              yyspot = yytext;

	mov	edi, DWORD PTR _yytext
	add	esp, 4
	mov	esi, 1
	jmp	$LL228@kblex
$LN103@kblex:

; 4535 :            }
; 4536 :            break;
; 4537 :         
; 4538 :         case L_LEAD_MINUS:
; 4539 :            if ( isdigit(nextchar) )

	movzx	ecx, bl
	push	ecx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN102@kblex

; 4540 :              state = L_LEAD_INTEGER;

	mov	esi, 10					; 0000000aH

; 4541 :            else

	jmp	$LL228@kblex
$LN102@kblex:

; 4542 :            { kb_unput(nextchar);

	mov	edx, DWORD PTR _nextchar$[ebp]
	push	edx
	call	_kb_unput
	add	esp, 4

; 4543 :              state = L_WHITESIGN;

	mov	esi, 8

; 4544 :              yyspot--;

	dec	edi

; 4545 :            }
; 4546 :            break;

	jmp	$LL228@kblex
$LN100@kblex:

; 4547 : 
; 4548 :         case L_LEAD_INTEGER:
; 4549 :            if ( isdigit(nextchar) )

	movzx	eax, bl
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	$LL316@kblex

; 4550 :              break;
; 4551 :            if ( nextchar == '.' )

	cmp	bl, 46					; 0000002eH
	jne	SHORT $LN98@kblex

; 4552 :            { state = L_DIGITS_DOT;

	lea	esi, DWORD PTR [eax+6]

; 4553 :              break;

	jmp	$LL228@kblex
$LN98@kblex:

; 4554 :            }           
; 4555 :            if ( toupper(nextchar) == 'X' )

	movzx	eax, bl
	mov	al, BYTE PTR _kb_upper_array[eax]
	cmp	al, 88					; 00000058H
	jne	SHORT $LN97@kblex

; 4556 :            { state = L_HEXNUMBER;

	mov	esi, 26					; 0000001aH

; 4557 :              break;

	jmp	$LL228@kblex
$LN97@kblex:

; 4558 :            }
; 4559 :            if ( (toupper(nextchar) == 'E') || (toupper(nextchar) == 'D') )

	cmp	al, 69					; 00000045H
	je	SHORT $LN95@kblex
	cmp	al, 68					; 00000044H
	je	SHORT $LN95@kblex

; 4562 :            }
; 4563 :            if ( nextchar == '@' )

	cmp	bl, 64					; 00000040H
	jne	$LN94@kblex

; 4564 :            { state = L_LEAD_INTEGER_AT;

	mov	esi, 11					; 0000000bH

; 4565 :              break;

	jmp	$LL228@kblex
$LN95@kblex:

; 4560 :            { state = L_DIGITS_E;

	mov	esi, 13					; 0000000dH

; 4561 :              break;

	jmp	$LL228@kblex
$LN85@kblex:

; 4586 :              goto kblex_exit;
; 4587 :            }
; 4588 :            break;
; 4589 : 
; 4590 :         case L_DIGITS:
; 4591 :            if ( isdigit(nextchar) )

	movzx	eax, bl
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	$LL316@kblex

; 4592 :              break;
; 4593 :            if ( nextchar == '.' )

	cmp	bl, 46					; 0000002eH
	jne	SHORT $LN83@kblex

; 4594 :            { state = L_DIGITS_DOT;

	lea	esi, DWORD PTR [eax+6]

; 4595 :              break;

	jmp	$LL228@kblex
$LN83@kblex:

; 4596 :            }
; 4597 :            if ( (toupper(nextchar) == 'E') || (toupper(nextchar) == 'D') )

	movzx	eax, bl
	mov	al, BYTE PTR _kb_upper_array[eax]
	cmp	al, 69					; 00000045H
	je	SHORT $LN95@kblex
	cmp	al, 68					; 00000044H
	je	SHORT $LN95@kblex

; 4598 :            { state = L_DIGITS_E;
; 4599 :              break;
; 4600 :            }
; 4601 :            if ( nextchar == '@' )

	cmp	bl, 64					; 00000040H
	jne	$LN80@kblex

; 4602 :            { state = L_INTEGER_AT;

	mov	esi, 12					; 0000000cH

; 4603 :              break;

	jmp	$LL228@kblex
$LN73@kblex:

; 4626 :            goto kblex_exit;
; 4627 : 
; 4628 :         case L_DIGITS_DOT:
; 4629 :            if ( (toupper(nextchar) == 'E') || (toupper(nextchar) == 'D') )

	movzx	ecx, bl
	mov	al, BYTE PTR _kb_upper_array[ecx]
	cmp	al, 69					; 00000045H
	je	SHORT $LN95@kblex
	cmp	al, 68					; 00000044H
	je	SHORT $LN95@kblex

; 4630 :            { state = L_DIGITS_E;
; 4631 :              break;
; 4632 :            }
; 4633 :            if ( isdigit(nextchar) )

	push	ecx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	$LL228@kblex

; 4634 :              break;
; 4635 :            if ( isalpha(nextchar) )

	movzx	eax, bl
	push	eax
	call	_isalpha
	add	esp, 4
	test	eax, eax
	je	$LN69@kblex

; 4940 :           *yyspot = 0;

	mov	BYTE PTR [edi], 0
	pop	edi
	mov	eax, 35095				; 00008917H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_1$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN68@kblex:

; 4646 :            goto kblex_exit;
; 4647 : 
; 4648 :         case L_DOT:
; 4649 :            if ( isdigit(nextchar) )

	movzx	eax, bl
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	$LN67@kblex

; 4650 :            { state = L_DIGITS_DOT;

	mov	esi, 6

; 4651 :              break;

	jmp	$LL228@kblex
$LN66@kblex:

; 4657 :            goto kblex_exit;
; 4658 : 
; 4659 :         case L_LEAD_INTEGER_AT:
; 4660 :            if ( isdigit(nextchar) )

	movzx	ecx, bl
	push	ecx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	$LL228@kblex

; 4661 :              break;
; 4662 :            /* have token */
; 4663 :            kb_unput(nextchar);

	mov	ecx, DWORD PTR _nextchar$[ebp]
	push	ecx
	call	_kb_unput

; 4664 :            yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0

; 4665 :            yylval.i = atoi(yytext);

	mov	edx, DWORD PTR _yytext
	push	edx
	call	_atoi
	mov	DWORD PTR _yylval, eax

; 4666 :            yylval.qnum = atoi(strchr(yytext,'@')+1);

	mov	eax, DWORD PTR _yytext
	push	64					; 00000040H
	push	eax
	call	_strchr
	inc	eax
	push	eax
	call	_atoi
	add	esp, 20					; 00000014H

; 4667 :            if ( yylval.i == 0 )

	cmp	DWORD PTR _yylval, 0
	mov	DWORD PTR _yylval+4, eax
	jne	SHORT $LN64@kblex

; 4668 :            { sprintf(errmsg, "Missing task number, line %d.",line_no);

	mov	ecx, DWORD PTR _line_no
	push	ecx
	push	OFFSET ??_C@_0BO@JPEPPLDA@Missing?5task?5number?0?5line?5?$CFd?4?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4669 : 		     kb_error(3554,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	3554					; 00000de2H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN64@kblex:

; 4670 : 		   }
; 4671 :            verb_flag = 0;
; 4672 :            tok = LEAD_INTEGER_AT_TOK;

	pop	edi
	mov	eax, 549				; 00000225H
	pop	esi
	mov	DWORD PTR _verb_flag, 0

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_2$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@kblex:

; 4673 :            goto kblex_exit;
; 4674 : 
; 4675 :         case L_INTEGER_AT:
; 4676 :            if ( isdigit(nextchar) )

	movzx	edx, bl
	push	edx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	$LL228@kblex

; 4677 :              break;
; 4678 :            /* have token */
; 4679 :            kb_unput(nextchar);

	mov	edx, DWORD PTR _nextchar$[ebp]
	push	edx
	call	_kb_unput

; 4680 :            yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0

; 4681 :            yylval.i = atoi(yytext);

	mov	eax, DWORD PTR _yytext
	push	eax
	call	_atoi

; 4682 :            yylval.qnum = atoi(strchr(yytext,'@')+1);

	mov	ecx, DWORD PTR _yytext
	push	64					; 00000040H
	push	ecx
	mov	DWORD PTR _yylval, eax
	call	_strchr
	inc	eax
	push	eax
	call	_atoi
	add	esp, 20					; 00000014H

; 4683 :            if ( yylval.i == 0 )

	cmp	DWORD PTR _yylval, 0
	mov	DWORD PTR _yylval+4, eax
	jne	SHORT $LN61@kblex

; 4684 :            {
; 4685 : 		     sprintf(errmsg,"Missing task number. Line %d",line_no);

	mov	edx, DWORD PTR _line_no
	push	edx
	push	OFFSET ??_C@_0BN@NBEKCKOC@Missing?5task?5number?4?5Line?5?$CFd?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4686 : 		     kb_error(3553,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	3553					; 00000de1H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN61@kblex:

; 4687 : 		   }
; 4688 :            verb_flag = 0;
; 4689 :            tok = INTEGER_AT_TOK;

	pop	edi
	mov	eax, 550				; 00000226H
	pop	esi
	mov	DWORD PTR _verb_flag, 0

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_3$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN60@kblex:

; 4690 :            goto kblex_exit;
; 4691 : 
; 4692 :         case L_SLASH:
; 4693 :            switch ( nextchar )

	cmp	bl, 42					; 0000002aH
	je	SHORT $LN57@kblex
	cmp	bl, 47					; 0000002fH
	jne	$LN252@kblex

; 4720 :               }
; 4721 :               break;
; 4722 :             
; 4723 :             case '/': state = L_LINECOMMENT; break;

	mov	esi, 3
	jmp	$LL228@kblex
$LN57@kblex:

; 4694 :            { case '*': 
; 4695 :               { /* eat comment */
; 4696 :                 register int c;
; 4697 :                 in_comment = 1;

	mov	esi, 1
	mov	DWORD PTR _in_comment, esi

; 4698 :                 state = L_START;

	mov	edi, esi
$LL56@kblex:

; 4699 :                 for ( ; ; )
; 4700 :                 { while ( (c = kb_input_new()) != '*' && c != 0 )

	call	_kb_input_new
	movsx	eax, al
	cmp	eax, 42					; 0000002aH
	je	SHORT $LL50@kblex
$LL54@kblex:
	test	eax, eax
	je	SHORT $LN275@kblex

; 4701 :                     if ( c == '\n' ) 

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN52@kblex

; 4702 :                     { line_no++; /* eat up text of comment */

	add	DWORD PTR _line_no, edi

; 4703 :                       state = L_LINESTART;

	lea	esi, DWORD PTR [eax-1]
$LN52@kblex:

; 4699 :                 for ( ; ; )
; 4700 :                 { while ( (c = kb_input_new()) != '*' && c != 0 )

	call	_kb_input_new
	movsx	eax, al
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LL54@kblex
$LL50@kblex:

; 4704 :                     }
; 4705 :                   if ( c == '*' )
; 4706 :                   { while ( (c = kb_input_new()) == '*' ) ;

	call	_kb_input_new
	movsx	eax, al
	cmp	eax, 42					; 0000002aH
	je	SHORT $LL50@kblex

; 4707 :                     if ( c == '/' ) break;    /* found the end */

	cmp	eax, 47					; 0000002fH
	je	SHORT $LN324@kblex

; 4708 :                     if ( c == '\n' ) 

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN47@kblex

; 4709 :                     { line_no++;

	add	DWORD PTR _line_no, edi

; 4710 :                       state = L_LINESTART;

	lea	esi, DWORD PTR [eax-1]

; 4711 :                     }
; 4712 :                   }
; 4713 :                   if ( c == 0 && yywrap() )

	jmp	SHORT $LL56@kblex
$LN47@kblex:
	test	eax, eax
	jne	SHORT $LL56@kblex
$LN275@kblex:
	call	_yywrap
	test	eax, eax

; 4715 :                     break; 
; 4716 :                   }
; 4717 :                 }

	je	SHORT $LL56@kblex

; 4714 :                   { kb_error(2861,"End-of-file in comment\n",RECOVERABLE ); 

	push	edi
	push	OFFSET ??_C@_0BI@DHOEFMOD@End?9of?9file?5in?5comment?6?$AA@
	push	2861					; 00000b2dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN324@kblex:

; 4718 :                 in_comment = 0;
; 4719 :                 yyspot = yytext;

	mov	edi, DWORD PTR _yytext
	mov	DWORD PTR _in_comment, 0

; 4733 :                      goto kblex_exit;
; 4734 :          }
; 4735 :          break;  /* end L_SLASH */

	jmp	$LL228@kblex
$LN42@kblex:

; 4736 : 
; 4737 :         case L_DIGITS_E:
; 4738 :           if ( isdigit(nextchar) || nextchar == '+' || nextchar == '-' )

	movzx	eax, bl
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN40@kblex
	cmp	bl, 43					; 0000002bH
	je	SHORT $LN40@kblex
	cmp	bl, 45					; 0000002dH
	je	SHORT $LN40@kblex

; 4741 :           }       
; 4742 : 		  sprintf(errmsg,"Missing exponent for scientific notation. Line %d\n",line_no);

	mov	ecx, DWORD PTR _line_no
	push	ecx
	push	OFFSET ??_C@_0DD@DNMMELCD@Missing?5exponent?5for?5scientific?5@
	push	OFFSET _errmsg
	call	_sprintf

; 4743 :           kb_error(3664, errmsg,  RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3664					; 00000e50H
	call	_kb_error
	add	esp, 24					; 00000018H

; 4744 :           break;

	jmp	$LL228@kblex
$LN40@kblex:

; 4739 :           { state = L_DIGITS_E_DIGITS;

	mov	esi, 35					; 00000023H

; 4740 :             break; 

	jmp	$LL228@kblex
$LN39@kblex:

; 4745 : 
; 4746 :         case L_DIGITS_E_DIGITS:
; 4747 :           if ( isdigit(nextchar) ) 

	movzx	edx, bl
	push	edx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	$LL228@kblex
$LN69@kblex:

; 4636 :            { *yyspot = 0;
; 4637 :              tok = VERSIONTOKEN_TOK;
; 4638 :              goto kblex_exit;
; 4639 :            }
; 4640 :            /* have complete REAL */
; 4641 :            kb_unput(nextchar);

	mov	ecx, DWORD PTR _nextchar$[ebp]
	push	ecx
	call	_kb_unput

; 4642 :            yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0

; 4643 :            yylval.r = atof(yytext);

	mov	edx, DWORD PTR _yytext
	push	edx
	call	_atof
	fstp	QWORD PTR _yylval+16
	add	esp, 8
	pop	edi

; 4644 :            verb_flag = 0;
; 4645 :            tok = REAL_TOK;

	mov	eax, 266				; 0000010aH
	pop	esi
	mov	DWORD PTR _verb_flag, 0

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_4$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@kblex:

; 4748 :             break;
; 4749 :           /* have token */
; 4750 :           kb_unput(nextchar);
; 4751 :           yyspot[-1] = 0;
; 4752 :           yylval.r = atof(yytext);
; 4753 :           verb_flag = 0;
; 4754 :           tok = REAL_TOK;
; 4755 :           goto kblex_exit;
; 4756 : 
; 4757 :         case L_ALPHANUM:
; 4758 :           if ( isalnum(nextchar) || nextchar == '_' )

	movzx	eax, bl
	push	eax
	call	_isalnum
	add	esp, 4
	test	eax, eax
	jne	$LL228@kblex
	cmp	bl, 95					; 0000005fH
	je	$LL228@kblex

; 4759 :             break;
; 4760 :           /* have token */
; 4761 :           kb_unput(nextchar);

	mov	ecx, DWORD PTR _nextchar$[ebp]
	push	ecx
	call	_kb_unput

; 4762 :           yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0

; 4763 :           strncpy(yylval.lexeme,yytext,LEXEME_SIZE);

	mov	edx, DWORD PTR _yytext
	push	63					; 0000003fH
	push	edx
	push	OFFSET _yylval+36
	call	_strncpy
	add	esp, 16					; 00000010H

; 4764 :           retval = macro();

	call	_macro

; 4765 :           if ( retval == WAS_MACRO_DEF ) 

	cmp	eax, 1
	jne	SHORT $LN34@kblex

; 4766 :           { /* macro() ate up rest of line */
; 4767 :             state = L_LINESTART;
; 4768 :             yyspot = yytext;

	mov	edi, DWORD PTR _yytext
	lea	esi, DWORD PTR [eax+8]
	jmp	$LL228@kblex
$LN34@kblex:

; 4769 :           }
; 4770 :           else if ( retval == MACRO_EXPANDED )

	cmp	eax, 2
	jne	$LN32@kblex

; 4771 :           { state = L_START;
; 4772 :             yyspot = yytext;

	mov	edi, DWORD PTR _yytext
	lea	esi, DWORD PTR [eax-1]

; 4777 :             goto kblex_exit;
; 4778 :           }
; 4779 :           break;

	jmp	$LL228@kblex
$LN30@kblex:

; 4780 : 
; 4781 :         case L_COLON:
; 4782 :           if ( nextchar == '=' )

	cmp	bl, 61					; 0000003dH
	je	$LN253@kblex

; 4785 :             goto kblex_exit;
; 4786 :           }
; 4787 :           if ( nextchar == ':' )

	cmp	bl, 58					; 0000003aH
	jne	SHORT $LN28@kblex

; 4788 :           { state = L_COLONCOLON;

	mov	esi, 24					; 00000018H

; 4789 :             break;

	jmp	$LL228@kblex
$LN28@kblex:

; 4790 :           }
; 4791 :           kb_unput(nextchar);

	mov	eax, DWORD PTR _nextchar$[ebp]
	push	eax
	call	_kb_unput
	add	esp, 4

; 4792 :           yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0

; 4793 :           if ( cond_expr_flag )

	cmp	DWORD PTR _cond_expr_flag, 0
	jne	$LN254@kblex

; 4795 :             goto kblex_exit;
; 4796 :           }
; 4797 :           /* else treat as whitespace */
; 4798 :           yyspot = yytext;

	mov	edi, DWORD PTR _yytext

; 4799 :           state = L_START;

	mov	esi, 1

; 4800 :           break;

	jmp	$LL228@kblex
$LN26@kblex:

; 4801 : 
; 4802 :         case L_COLONCOLON:
; 4803 :           if ( nextchar == '=' )

	cmp	bl, 61					; 0000003dH
	je	$LN255@kblex

; 4806 :             goto kblex_exit;
; 4807 :           }
; 4808 :           if ( nextchar == ':' )

	cmp	bl, 58					; 0000003aH
	jne	SHORT $LN24@kblex

; 4809 :           { state = L_COLONCOLONCOLON;

	mov	esi, 31					; 0000001fH

; 4810 :             break;

	jmp	$LL228@kblex
$LN24@kblex:

; 4811 :           }          
; 4812 : 		  sprintf(errmsg,"Illegal token '::'  Line %d\n",line_no);

	mov	ecx, DWORD PTR _line_no
	push	ecx
	push	OFFSET ??_C@_0BN@NMIBGLJK@Illegal?5token?5?8?3?3?8?5?5Line?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4813 : 		  kb_error(3568,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3568					; 00000df0H
	call	_kb_error
	add	esp, 24					; 00000018H

; 4814 :           break;

	jmp	$LL228@kblex
$LN23@kblex:

; 4815 : 
; 4816 :         case L_COLONCOLONCOLON:
; 4817 :           if ( nextchar == '=' )

	cmp	bl, 61					; 0000003dH
	je	$LN256@kblex

; 4820 :             goto kblex_exit;
; 4821 :           }          
; 4822 : 		  sprintf(errmsg,"Illegal token ':::'  Line %d\n",line_no);

	mov	edx, DWORD PTR _line_no
	push	edx
	push	OFFSET ??_C@_0BO@JALBIPLM@Illegal?5token?5?8?3?3?3?8?5?5Line?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4823 : 		  kb_error(3569,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3569					; 00000df1H
	call	_kb_error
	add	esp, 24					; 00000018H

; 4824 :           break;

	jmp	$LL228@kblex
$LN6@kblex:

; 4916 :            goto kblex_exit;
; 4917 : 
; 4918 :         case L_AND:
; 4919 :            if ( nextchar == '&' )

	cmp	bl, 38					; 00000026H
	je	$LN257@kblex

; 4920 :            { *yyspot = 0;
; 4921 :              tok = AND_TOK;
; 4922 :              goto kblex_exit;
; 4923 :            }         
; 4924 : 		   sprintf(errmsg,"Illegal token '&'  Line %d\n",line_no);

	mov	eax, DWORD PTR _line_no
	push	eax
	push	OFFSET ??_C@_0BM@KLMIAMJK@Illegal?5token?5?8?$CG?8?5?5Line?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4925 : 		   kb_error(3566,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3566					; 00000deeH
	call	_kb_error
	add	esp, 24					; 00000018H

; 4926 :           break;

	jmp	$LL228@kblex
$LN4@kblex:

; 4927 : 
; 4928 :         case L_LINECOMMENT:
; 4929 :           if ( (nextchar == '\n') || (nextchar == 0) )

	cmp	bl, 10					; 0000000aH
	je	SHORT $LN2@kblex
	test	bl, bl
	je	SHORT $LN2@kblex

; 4933 :             break;
; 4934 :           }
; 4935 :           yyspot--;  /* don't save comment token */

	dec	edi

; 4936 :           break;

	jmp	$LL228@kblex
$LN2@kblex:

; 4930 :           { line_no++;

	inc	DWORD PTR _line_no

; 4931 :             state = L_LINESTART; 
; 4932 :             yyspot = yytext;

	mov	edi, DWORD PTR _yytext
	mov	esi, 9

; 4942 :           goto kblex_exit;
; 4943 :       }
; 4944 :     }

	jmp	$LL228@kblex
$LN214@kblex:
	pop	edi

; 4239 :            {
; 4240 :              case 0:  tok=0; goto kblex_exit;

	xor	eax, eax
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_5$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN192@kblex:

; 4264 : 
; 4265 :              case '(': verb_flag = 0;

	mov	DWORD PTR _verb_flag, 0
$LN191@kblex:

; 4940 :           *yyspot = 0;

	mov	BYTE PTR [edi], 0
	movzx	eax, bl
	pop	edi
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_6$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN190@kblex:

; 4266 :                 *yyspot = 0;  tok = nextchar; goto kblex_exit;
; 4267 :              case ')':
; 4268 :              case '^':
; 4269 :              case ',':
; 4270 :              case '?':
; 4271 :              case '%':
; 4272 :              case '[':
; 4273 :              case ']':
; 4274 :              case '}': 
; 4275 :              case '@':
; 4276 :                 *yyspot = 0;  tok = nextchar; goto kblex_exit;
; 4277 :              case '{': verb_flag = 1;

	mov	DWORD PTR _verb_flag, 1

; 4940 :           *yyspot = 0;

	mov	BYTE PTR [edi], 0
	movzx	eax, bl
	pop	edi
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_7$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN182@kblex:

; 4301 : 
; 4302 :         case L_EQUAL:
; 4303 :            if ( nextchar == '=' )

	cmp	bl, 61					; 0000003dH
	jne	SHORT $LN181@kblex

; 4940 :           *yyspot = 0;

	mov	BYTE PTR [edi], 0
	pop	edi
	mov	eax, 580				; 00000244H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_8$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN181@kblex:

; 4304 :            { *yyspot = 0;
; 4305 :              tok = EQ_TOK;
; 4306 :              goto kblex_exit;
; 4307 :            }
; 4308 :            kb_unput(nextchar);

	mov	ecx, DWORD PTR _nextchar$[ebp]
	push	ecx
	call	_kb_unput
	add	esp, 4

; 4309 :            yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0

; 4310 :            tok = (datafile_flag ? '=' : EQ_TOK);

	mov	eax, DWORD PTR _datafile_flag
	neg	eax
	sbb	eax, eax
	pop	edi
	and	eax, -519				; fffffdf9H
	add	eax, 580				; 00000244H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_9$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN180@kblex:

; 4311 :            goto kblex_exit;
; 4312 :            
; 4313 :         case L_QUOTE:
; 4314 :            { /* read quoted string */
; 4315 :              int n;
; 4316 :              in_quote = 1;

	mov	DWORD PTR _in_quote, 1

; 4317 :              for (n=0;;n++)

	xor	esi, esi
$LL335@kblex:

; 4318 :              { if ( nextchar == '\n' ) line_no++;

	cmp	bl, 10					; 0000000aH
	jne	SHORT $LN176@kblex
	inc	DWORD PTR _line_no
$LN320@kblex:

; 4319 :                if ( (nextchar == '"' || nextchar == 0x94) && (n == 0 || (yytext[n-1] != '\\')) ) 

	mov	eax, DWORD PTR _yytext
$LN175@kblex:

; 4320 :                  break;
; 4321 :                if ( n >= yytext_max - 2 )

	mov	ecx, DWORD PTR _yytext_max
	lea	edx, DWORD PTR [ecx-2]
	cmp	esi, edx
	jl	SHORT $LN172@kblex

; 4322 :                { yytext_max *= 2;

	add	ecx, ecx

; 4323 :                  yytext = realloc(yytext,yytext_max);

	push	ecx
	push	eax
	mov	DWORD PTR _yytext_max, ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _yytext, eax
$LN172@kblex:

; 4324 :                }
; 4325 :                yytext[n] = nextchar;

	mov	BYTE PTR [eax+esi], bl

; 4326 :                nextchar = kb_input_new();

	call	_kb_input_new
	mov	bl, al
	inc	esi
	jmp	SHORT $LL335@kblex
$LN176@kblex:

; 4319 :                if ( (nextchar == '"' || nextchar == 0x94) && (n == 0 || (yytext[n-1] != '\\')) ) 

	cmp	bl, 34					; 00000022H
	je	SHORT $LN174@kblex
	cmp	bl, 148					; 00000094H
	jne	SHORT $LN320@kblex
$LN174@kblex:
	mov	eax, DWORD PTR _yytext
	test	esi, esi
	je	SHORT $LN258@kblex
	cmp	BYTE PTR [eax+esi-1], 92		; 0000005cH
	je	SHORT $LN175@kblex
$LN258@kblex:

; 4327 :              }
; 4328 :              yytext[n] = 0;

	mov	BYTE PTR [eax+esi], 0

; 4329 :              reduce_string(yytext);

	mov	eax, DWORD PTR _yytext
	push	eax
	call	_reduce_string
	add	esp, 4
	pop	edi

; 4330 :              in_quote = 0;
; 4331 :              tok = QUOTATION_TOK;

	mov	eax, 309				; 00000135H
	pop	esi
	mov	DWORD PTR _in_quote, 0

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_10$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN171@kblex:

; 4332 :              goto kblex_exit;
; 4333 :            }
; 4334 :            break;
; 4335 :    
; 4336 :         case L_LESS:
; 4337 :            if ( nextchar == '=' )

	cmp	bl, 61					; 0000003dH
	jne	SHORT $LN170@kblex

; 4940 :           *yyspot = 0;

	mov	BYTE PTR [edi], 0
	pop	edi
	mov	eax, 579				; 00000243H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_11$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN170@kblex:

; 4338 :            { *yyspot = 0;
; 4339 :              tok = LE_TOK;
; 4340 :              goto kblex_exit;
; 4341 :            }
; 4342 :            else
; 4343 :            { kb_unput(nextchar);

	mov	ecx, DWORD PTR _nextchar$[ebp]
	push	ecx
	call	_kb_unput
	add	esp, 4

; 4344 :              yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0
	pop	edi

; 4345 :              tok = '<';

	mov	eax, 60					; 0000003cH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_12$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN167@kblex:

; 4353 :            else if ( nextchar == '=' )

	cmp	bl, 61					; 0000003dH
	jne	SHORT $LN165@kblex

; 4940 :           *yyspot = 0;

	mov	BYTE PTR [edi], 0
	pop	edi
	mov	eax, 578				; 00000242H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_13$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN165@kblex:

; 4354 :            { *yyspot = 0;
; 4355 :              tok = GE_TOK;
; 4356 :              goto kblex_exit;
; 4357 :            }
; 4358 :            else
; 4359 :            { kb_unput(nextchar);

	mov	edx, DWORD PTR _nextchar$[ebp]
	push	edx
	call	_kb_unput
	add	esp, 4

; 4360 :              yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0
	pop	edi

; 4361 :              tok = '>';

	mov	eax, 62					; 0000003eH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_14$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN162@kblex:

; 4371 :            } 
; 4372 : 		   else if ( nextchar == '2' )

	cmp	bl, 50					; 00000032H
	jne	SHORT $LN160@kblex

; 4940 :           *yyspot = 0;

	mov	BYTE PTR [edi], 0
	pop	edi
	mov	eax, 498				; 000001f2H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_15$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN160@kblex:

; 4373 :            { *yyspot = 0;
; 4374 :              tok = REDIRECT_ERR_TOK;
; 4375 :              goto kblex_exit;
; 4376 :            } 
; 4377 :            else
; 4378 :            { kb_unput(nextchar);

	mov	eax, DWORD PTR _nextchar$[ebp]
	push	eax
	call	_kb_unput
	add	esp, 4

; 4379 :              yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0
	pop	edi

; 4380 :              tok = REDIRECT_TOK;

	mov	eax, 468				; 000001d4H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_16$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN158@kblex:

; 4384 : 
; 4385 :         case L_GRGRGR:
; 4386 :            if ( nextchar == '2' )

	cmp	bl, 50					; 00000032H
	jne	SHORT $LN157@kblex

; 4940 :           *yyspot = 0;

	mov	BYTE PTR [edi], 0
	pop	edi
	mov	eax, 493				; 000001edH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_17$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN157@kblex:

; 4387 :            { *yyspot = 0;
; 4388 :              tok = REDIRECTOVER_ERR_TOK;
; 4389 :              goto kblex_exit;
; 4390 :            } 
; 4391 :            else
; 4392 :            { kb_unput(nextchar);

	mov	ecx, DWORD PTR _nextchar$[ebp]
	push	ecx
	call	_kb_unput
	add	esp, 4

; 4393 :              yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0
	pop	edi

; 4394 :              tok = REDIRECTOVER_TOK;

	mov	eax, 495				; 000001efH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_18$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN155@kblex:

; 4395 :              goto kblex_exit;
; 4396 :            }
; 4397 :            break;
; 4398 : 
; 4399 :         case L_SINGLE_QUOTE:
; 4400 :            if ( nextchar == '\'' || nextchar == 0x92 )

	cmp	bl, 39					; 00000027H
	je	SHORT $LN153@kblex
	cmp	bl, 146					; 00000092H
	jne	SHORT $LN154@kblex
$LN153@kblex:

; 4401 :               kb_error(3577,"Empty single quotes.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BG@OHKGDBKM@Empty?5single?5quotes?4?6?$AA@
	push	3577					; 00000df9H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN154@kblex:

; 4402 :            if ( nextchar == 0 || nextchar == '\n' )

	test	bl, bl
	je	SHORT $LN151@kblex
	cmp	bl, 10					; 0000000aH
	jne	SHORT $LN322@kblex
$LN151@kblex:

; 4403 :               kb_error(3570,"Dangling single quote.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BI@GCFMAGKE@Dangling?5single?5quote?4?6?$AA@
	push	3570					; 00000df2H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN322@kblex:

; 4404 :            yylval.i = nextchar;

	movzx	edx, bl
	mov	DWORD PTR _yylval, edx

; 4405 :            nextchar = kb_input_new();

	call	_kb_input_new

; 4406 :            if ( nextchar != '\'' && nextchar != 0x92) 

	cmp	al, 39					; 00000027H
	je	SHORT $LN150@kblex
	cmp	al, 146					; 00000092H
	je	SHORT $LN150@kblex

; 4407 :               kb_error(3583,"Single quote not closed after one character.\n",
; 4408 :                               RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CO@JMNNKCOA@Single?5quote?5not?5closed?5after?5on@
	push	3583					; 00000dffH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN150@kblex:

; 4409 :            yytext[1] = 0;

	mov	eax, DWORD PTR _yytext
	pop	edi
	mov	BYTE PTR [eax+1], 0

; 4410 :            tok = QUOTED_LETTER_TOK;

	mov	eax, 353				; 00000161H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_19$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN239@kblex:

; 4411 :            goto kblex_exit;
; 4412 :            break;
; 4413 : 
; 4414 :         case L_BACKQUOTE:
; 4415 :            while ( nextchar == ' ' ) yyspot[-1] = nextchar = kb_input_new();

	cmp	bl, 32					; 00000020H
	jne	SHORT $LN147@kblex
	npad	4
$LL148@kblex:
	call	_kb_input_new
	mov	bl, al
	mov	BYTE PTR _nextchar$[ebp], bl
	mov	BYTE PTR [edi-1], bl
	cmp	bl, 32					; 00000020H
	je	SHORT $LL148@kblex
$LN147@kblex:

; 4416 :            if ( nextchar == ',' )

	cmp	bl, 44					; 0000002cH
	jne	SHORT $LN146@kblex

; 4940 :           *yyspot = 0;

	mov	BYTE PTR [edi], 0
	pop	edi
	mov	eax, 507				; 000001fbH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_20$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN146@kblex:

; 4417 :            { *yyspot = 0;
; 4418 :              tok = BACKQUOTE_COMMA_TOK;
; 4419 :              goto kblex_exit;
; 4420 :            }
; 4421 :            yyspot[-1] = 0;
; 4422 :            kb_unput(nextchar);

	mov	ecx, DWORD PTR _nextchar$[ebp]
	push	ecx
	mov	BYTE PTR [edi-1], 0
	call	_kb_unput
	add	esp, 4
	pop	edi

; 4423 :            tok = '`';

	mov	eax, 96					; 00000060H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_21$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN126@kblex:

; 4470 :            else
; 4471 :            { kb_unput(nextchar);

	mov	edx, DWORD PTR _nextchar$[ebp]
	push	edx
	call	_kb_unput
	add	esp, 4

; 4472 :              yyspot[-1] = 0;
; 4473 :              yylval.i = 0;

	xor	eax, eax
	mov	BYTE PTR [edi-1], 0
	mov	DWORD PTR _yylval, eax

; 4474 :              verb_flag = 0;

	mov	DWORD PTR _verb_flag, eax
$LN232@kblex:

; 4475 :              tok = INTEGER_TOK;

	pop	edi
	mov	eax, 265				; 00000109H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_22$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN250@kblex:
	pop	edi

; 4511 :              { tok = UMINUS_TOK;

	mov	eax, 287				; 0000011fH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_23$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN94@kblex:

; 4566 :            }
; 4567 :            /* have LEAD_INTEGER_TOK*/
; 4568 :            kb_unput(nextchar);

	mov	edx, DWORD PTR _nextchar$[ebp]
	push	edx
	call	_kb_unput

; 4569 :            yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0

; 4570 :            yylval.r = atof(yytext);

	mov	eax, DWORD PTR _yytext
	push	eax
	call	_atof
	fstp	QWORD PTR _yylval+16

; 4571 :            yylval.i = atoi(yytext);

	mov	ecx, DWORD PTR _yytext
	push	ecx
	call	_atoi
	add	esp, 12					; 0000000cH

; 4572 :            verb_flag = 0;
; 4573 :            if ( lists_flag==LISTS_FULL ) 

	cmp	DWORD PTR _lists_flag, 2
	mov	DWORD PTR _yylval, eax
	mov	DWORD PTR _verb_flag, 0
	jne	SHORT $LN93@kblex

; 4574 :            { tok = LEAD_INTEGER_TOK;

	pop	edi
	mov	eax, 264				; 00000108H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_24$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN93@kblex:

; 4575 :              goto kblex_exit;
; 4576 :            }
; 4577 :            else if ( uminus_flag || yytext[0] != '-' )

	cmp	DWORD PTR _uminus_flag, 0
	jne	$LN90@kblex
	mov	eax, DWORD PTR _yytext
	cmp	BYTE PTR [eax], 45			; 0000002dH
	jne	$LN90@kblex

; 4578 :            { tok = (fabs(yylval.r) > MAXINT) ? REAL_TOK: INTEGER_TOK;
; 4579 :              goto kblex_exit;
; 4580 :            }
; 4581 :            else 
; 4582 :            { for ( yyspot -= 2 ; yyspot != yytext ; yyspot-- ) 

	sub	edi, 2
	cmp	edi, eax
	je	SHORT $LN86@kblex
$LL337@kblex:

; 4583 :                kb_unput(*yyspot);

	movzx	edx, BYTE PTR [edi]
	push	edx
	call	_kb_unput
	mov	eax, DWORD PTR _yytext
	dec	edi
	add	esp, 4
	cmp	edi, eax
	jne	SHORT $LL337@kblex
$LN86@kblex:

; 4584 :              yytext[1] = 0;

	mov	BYTE PTR [eax+1], 0

; 4585 :              tok = minus_type(yytext[0]);

	mov	eax, DWORD PTR _yytext
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	_minus_type
	add	esp, 4
	pop	edi
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_25$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN80@kblex:

; 4604 :            } 
; 4605 : 
; 4606 :            if ( toupper(nextchar) == 'B' )

	movzx	edx, bl
	cmp	BYTE PTR _kb_upper_array[edx], 66	; 00000042H
	jne	SHORT $LN74@kblex

; 4607 :            { char *c;
; 4608 :              yylval.i = 0;
; 4609 :              for ( c = yytext;  *c=='0' || *c=='1'  ; c++ )

	mov	ecx, DWORD PTR _yytext
	xor	edx, edx
$LN341@kblex:
	mov	DWORD PTR _yylval, edx
	mov	al, BYTE PTR [ecx]
	cmp	al, 48					; 00000030H
	je	SHORT $LN75@kblex
	cmp	al, 49					; 00000031H
	jne	SHORT $LN76@kblex
$LN75@kblex:

; 4610 :                yylval.i = 2*yylval.i + (*c - '0');

	movsx	eax, al
	lea	edx, DWORD PTR [eax+edx*2-48]
	inc	ecx
	jmp	SHORT $LN341@kblex
$LN76@kblex:

; 4611 :              if ( c == yyspot-1 )

	lea	edx, DWORD PTR [edi-1]
	cmp	ecx, edx

; 4612 :              { yylval.r = (REAL)yylval.i;
; 4613 :                verb_flag = 0;
; 4614 :                tok = INTEGER_TOK;
; 4615 :                goto kblex_exit;

	je	$LN342@kblex
$LN74@kblex:

; 4616 :              }
; 4617 :              /* else fall through to ordinary integer */
; 4618 :            }
; 4619 :            /* have INTEGER_TOK*/
; 4620 :            kb_unput(nextchar);

	mov	eax, DWORD PTR _nextchar$[ebp]
	push	eax
	call	_kb_unput

; 4621 :            yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0

; 4622 :            yylval.r = atof(yytext);

	mov	ecx, DWORD PTR _yytext
	push	ecx
	call	_atof
	fstp	QWORD PTR _yylval+16

; 4623 :            yylval.i = atoi(yytext);

	mov	edx, DWORD PTR _yytext
	push	edx
	call	_atoi
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _yylval, eax

; 4624 :            verb_flag = 0;

	mov	DWORD PTR _verb_flag, 0
$LN90@kblex:

; 4625 :            tok = (fabs(yylval.r) > MAXINT) ? REAL_TOK: INTEGER_TOK;

	fld	QWORD PTR _yylval+16
	fabs
	fcomp	QWORD PTR __real@41dfffffffc00000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN232@kblex
	pop	edi
	mov	eax, 266				; 0000010aH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_26$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN67@kblex:

; 4652 :            }
; 4653 :            /* else just a dot */
; 4654 :            kb_unput(nextchar);

	mov	eax, DWORD PTR _nextchar$[ebp]
	push	eax
	call	_kb_unput
	add	esp, 4

; 4655 :            yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0
	pop	edi

; 4656 :            tok = '.';

	mov	eax, 46					; 0000002eH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_27$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN252@kblex:

; 4690 :            goto kblex_exit;
; 4691 : 
; 4692 :         case L_SLASH:
; 4693 :            switch ( nextchar )

	cmp	bl, 61					; 0000003dH
	je	SHORT $LN44@kblex

; 4727 :                        goto kblex_exit;
; 4728 :                        
; 4729 :             default: kb_unput(nextchar); 

	mov	eax, DWORD PTR _nextchar$[ebp]
	push	eax
	call	_kb_unput
	add	esp, 4

; 4730 :                      yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0
	pop	edi

; 4731 :                      verb_flag = 0;
; 4732 :                      tok = '/';

	mov	eax, 47					; 0000002fH
	pop	esi
	mov	DWORD PTR _verb_flag, 0

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_28$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@kblex:

; 4724 :             case '=': *yyspot = 0; yylval.i = DIVASSIGN_OP; 

	mov	BYTE PTR [edi], 0
	pop	edi

; 4725 :                        verb_flag = 0;
; 4726 :                        tok=ASSIGNOP_TOK;

	mov	eax, 570				; 0000023aH
	pop	esi
	mov	DWORD PTR _yylval, 30005		; 00007535H
	mov	DWORD PTR _verb_flag, 0

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_29$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@kblex:

; 4773 :           }
; 4774 :           else
; 4775 :           {
; 4776 :             tok = identcase(yytext);

	mov	eax, DWORD PTR _yytext
	push	eax
	call	_identcase
	add	esp, 4
	pop	edi
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_30$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN253@kblex:

; 4783 :           { verb_flag = 2; yyspot[-1] = 0; 

	mov	DWORD PTR _verb_flag, 2
	mov	BYTE PTR [edi-1], 0
	pop	edi

; 4784 :             tok = ASSIGN_TOK;

	mov	eax, 441				; 000001b9H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_31$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN254@kblex:
	pop	edi

; 4794 :           { tok = ':';

	mov	eax, 58					; 0000003aH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_32$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN255@kblex:

; 4804 :           { verb_flag = 2; yyspot[-1] = 0; 

	mov	DWORD PTR _verb_flag, 2
	mov	BYTE PTR [edi-1], 0
	pop	edi

; 4805 :             tok = PERM_ASSIGN_TOK;

	mov	eax, 504				; 000001f8H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_33$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN256@kblex:

; 4818 :           { verb_flag = 2; yyspot[-1] = 0; 

	mov	DWORD PTR _verb_flag, 2
	mov	BYTE PTR [edi-1], 0
	pop	edi

; 4819 :             tok = REDEFINE_TOK;

	mov	eax, 269				; 0000010dH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_34$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@kblex:

; 4825 : 
; 4826 :         case L_SEMICOLON:
; 4827 :           if ( nextchar == '=' )

	cmp	bl, 61					; 0000003dH
	jne	SHORT $LN20@kblex

; 4828 :           { verb_flag = 2; 
; 4829 :             kb_error(2868,"You mistyped ';=' for ':='?\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BN@DHNHEAEL@You?5mistyped?5?8?$DL?$DN?8?5for?5?8?3?$DN?8?$DP?6?$AA@
	push	2868					; 00000b34H
	mov	DWORD PTR _verb_flag, 2
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi

; 4830 :             tok= ASSIGN_TOK;

	mov	eax, 441				; 000001b9H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_35$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@kblex:

; 4831 :             goto kblex_exit;
; 4832 :           }
; 4833 :           kb_unput(nextchar);

	mov	ecx, DWORD PTR _nextchar$[ebp]
	push	ecx
	call	_kb_unput
	add	esp, 4

; 4834 :           yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0
	pop	edi

; 4835 :           verb_flag = 1;
; 4836 :           tok = ';';

	mov	eax, 59					; 0000003bH
	pop	esi
	mov	DWORD PTR _verb_flag, 1

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_36$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@kblex:

; 4837 :           goto kblex_exit;
; 4838 :  
; 4839 :         case L_PLUS:
; 4840 :           verb_flag = 0;

	xor	eax, eax
	mov	DWORD PTR _verb_flag, eax

; 4841 :           if ( nextchar == '=' )

	cmp	bl, 61					; 0000003dH
	jne	SHORT $LN18@kblex

; 4842 :           { verb_flag = 0; *yyspot = 0;

	mov	DWORD PTR _verb_flag, eax
	mov	BYTE PTR [edi], al
	pop	edi

; 4843 :             yylval.i = PLUSASSIGN_OP;
; 4844 :             tok = ASSIGNOP_TOK;

	mov	eax, 570				; 0000023aH
	pop	esi
	mov	DWORD PTR _yylval, 30002		; 00007532H

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_37$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@kblex:

; 4845 :             goto kblex_exit;
; 4846 :           }
; 4847 :           if ( nextchar == '+' )

	cmp	bl, 43					; 0000002bH
	jne	SHORT $LN17@kblex

; 4848 :           { verb_flag = 0; *yyspot = 0;

	mov	DWORD PTR _verb_flag, eax
	mov	BYTE PTR [edi], al
	pop	edi

; 4849 :             yylval.i = PLUSPLUS_OP;
; 4850 :             tok = INCREMENT_TOK;

	mov	eax, 589				; 0000024dH
	pop	esi
	mov	DWORD PTR _yylval, 30006		; 00007536H

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_38$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@kblex:

; 4851 :             goto kblex_exit;
; 4852 :           }
; 4853 :           kb_unput(nextchar);

	mov	edx, DWORD PTR _nextchar$[ebp]
	push	edx
	call	_kb_unput
	add	esp, 4

; 4854 :           yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0
	pop	edi

; 4855 :           tok = '+';

	mov	eax, 43					; 0000002bH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_39$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@kblex:

; 4856 :           goto kblex_exit;
; 4857 :           
; 4858 :         case L_MINUS:
; 4859 :           verb_flag = 0;
; 4860 :           if ( nextchar == '=' )
; 4861 :           { verb_flag = 0; yylval.i = SUBASSIGN_OP; 

	mov	DWORD PTR _verb_flag, 0
	cmp	bl, 61					; 0000003dH
	jne	SHORT $LN15@kblex
	mov	DWORD PTR _yylval, 30003		; 00007533H

; 4940 :           *yyspot = 0;

	mov	BYTE PTR [edi], 0
	pop	edi
	mov	eax, 570				; 0000023aH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_40$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@kblex:

; 4862 :             *yyspot = 0;
; 4863 :             tok= ASSIGNOP_TOK;
; 4864 :             goto kblex_exit;
; 4865 :           }
; 4866 :           if ( nextchar == '-' )

	cmp	bl, 45					; 0000002dH
	jne	SHORT $LN14@kblex

; 4867 :           { verb_flag = 0; *yyspot = 0;

	mov	BYTE PTR [edi], 0
	pop	edi

; 4868 :             yylval.i = MINUSMINUS_OP;
; 4869 :             tok = INCREMENT_TOK;

	mov	eax, 589				; 0000024dH
	pop	esi
	mov	DWORD PTR _yylval, 30007		; 00007537H

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_41$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@kblex:

; 4870 :             goto kblex_exit;
; 4871 :           }
; 4872 :           verb_flag = 0; 
; 4873 :           kb_unput(nextchar);

	mov	eax, DWORD PTR _nextchar$[ebp]
	push	eax
	call	_kb_unput

; 4874 :           tok = minus_type('-');

	push	45					; 0000002dH
	call	_minus_type
	add	esp, 8
	pop	edi
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_42$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@kblex:

; 4875 :           goto kblex_exit;
; 4876 : 
; 4877 :         case L_STAR:
; 4878 :           verb_flag = 0;

	xor	eax, eax
	mov	DWORD PTR _verb_flag, eax

; 4879 :           if ( nextchar == '=' )

	cmp	bl, 61					; 0000003dH
	jne	SHORT $LN12@kblex

; 4880 :           { verb_flag = 0; *yyspot = 0;

	mov	DWORD PTR _verb_flag, eax
	mov	BYTE PTR [edi], al
	pop	edi

; 4881 :             yylval.i = MULTASSIGN_OP;
; 4882 :             tok = ASSIGNOP_TOK;

	mov	eax, 570				; 0000023aH
	pop	esi
	mov	DWORD PTR _yylval, 30004		; 00007534H

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_43$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@kblex:

; 4883 :             goto kblex_exit;
; 4884 :           }
; 4885 :           if ( nextchar == '*' )

	cmp	bl, 42					; 0000002aH
	jne	SHORT $LN11@kblex

; 4886 :           { verb_flag = 0; *yyspot = 0; 

	mov	DWORD PTR _verb_flag, eax
	mov	BYTE PTR [edi], al
	pop	edi

; 4887 :             tok = '^';

	mov	eax, 94					; 0000005eH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_44$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@kblex:

; 4888 :             goto kblex_exit;
; 4889 :           }
; 4890 :           kb_unput(nextchar);

	mov	ecx, DWORD PTR _nextchar$[ebp]
	push	ecx
	call	_kb_unput
	add	esp, 4

; 4891 :           yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0
	pop	edi

; 4892 :           tok = '*';

	mov	eax, 42					; 0000002aH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_45$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@kblex:

; 4893 :           goto kblex_exit;
; 4894 : 
; 4895 :         case L_BANG:
; 4896 :            verb_flag = 0;

	mov	DWORD PTR _verb_flag, 0

; 4897 :            if ( nextchar == '=' )

	cmp	bl, 61					; 0000003dH
	jne	SHORT $LN9@kblex

; 4940 :           *yyspot = 0;

	mov	BYTE PTR [edi], 0
	pop	edi
	mov	eax, 577				; 00000241H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_46$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@kblex:

; 4898 :            { *yyspot = 0;
; 4899 :              tok = NE_TOK;
; 4900 :              goto kblex_exit;
; 4901 :            }
; 4902 :            kb_unput(nextchar);

	mov	edx, DWORD PTR _nextchar$[ebp]
	push	edx
	call	_kb_unput
	add	esp, 4

; 4903 :            yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0
	pop	edi

; 4904 :            tok = NOT_TOK;

	mov	eax, 576				; 00000240H
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_47$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@kblex:

; 4905 :            goto kblex_exit;
; 4906 : 
; 4907 :         case L_PIPE:
; 4908 :            if ( nextchar == '|' )

	cmp	bl, 124					; 0000007cH
	jne	SHORT $LN7@kblex

; 4940 :           *yyspot = 0;

	mov	BYTE PTR [edi], 0
	pop	edi
	mov	eax, 574				; 0000023eH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_48$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@kblex:

; 4909 :            { *yyspot = 0;
; 4910 :              tok = OR_TOK;
; 4911 :              goto kblex_exit;
; 4912 :            }
; 4913 :            kb_unput(nextchar);

	mov	eax, DWORD PTR _nextchar$[ebp]
	push	eax
	call	_kb_unput
	add	esp, 4

; 4914 :            yyspot[-1] = 0;

	mov	BYTE PTR [edi-1], 0
	pop	edi

; 4915 :            tok = PIPE_TOK; 

	mov	eax, 571				; 0000023bH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_49$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN257@kblex:

; 4940 :           *yyspot = 0;

	mov	BYTE PTR [edi], 0
	pop	edi
	mov	eax, 575				; 0000023fH
	pop	esi

; 4941 :           tok = 1;

	mov	DWORD PTR _tok, eax
$kblex_exit_50$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@kblex:

; 4937 : 
; 4938 :         default: 
; 4939 :           fprintf(stderr,"Unhandled state: %d\n",state);

	push	esi
	push	OFFSET ??_C@_0BF@LCPJAPLP@Unhandled?5state?3?5?$CFd?6?$AA@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 4940 :           *yyspot = 0;

	mov	BYTE PTR [edi], 0
	pop	edi

; 4941 :           tok = 1;

	mov	eax, 1
	pop	esi
	mov	DWORD PTR _tok, eax
$kblex_exit_51$91325:
	pop	ebx

; 4945 :   kblex_exit:
; 4946 :   PROF_FINISH(kblex);
; 4947 :  
; 4948 :   return tok;
; 4949 :   
; 4950 : } // end kblex()

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN343@kblex:
	DD	$LN223@kblex
	DD	$LN60@kblex
	DD	$LN4@kblex
	DD	$LN68@kblex
	DD	$LN85@kblex
	DD	$LN73@kblex
	DD	$LN121@kblex
	DD	$LN115@kblex
	DD	$LN112@kblex
	DD	$LN100@kblex
	DD	$LN66@kblex
	DD	$LN63@kblex
	DD	$LN42@kblex
	DD	$LN37@kblex
	DD	$LN30@kblex
	DD	$LN21@kblex
	DD	$LN19@kblex
	DD	$LN16@kblex
	DD	$LN13@kblex
	DD	$LN10@kblex
	DD	$LN8@kblex
	DD	$LN6@kblex
	DD	$LN168@kblex
	DD	$LN26@kblex
	DD	$LN155@kblex
	DD	$LN124@kblex
	DD	$LN131@kblex
	DD	$LN163@kblex
	DD	$LN239@kblex
	DD	$LN240@kblex
	DD	$LN23@kblex
	DD	$LN180@kblex
	DD	$LN182@kblex
	DD	$LN171@kblex
	DD	$LN39@kblex
	DD	$LN103@kblex
	DD	$LL187@kblex
	DD	$LN158@kblex
$LN344@kblex:
	DD	$LN214@kblex
	DD	$LN212@kblex
	DD	$LN213@kblex
	DD	$LN203@kblex
	DD	$LN198@kblex
	DD	$LN193@kblex
	DD	$LN191@kblex
	DD	$LN201@kblex
	DD	$LN199@kblex
	DD	$LN192@kblex
	DD	$LN204@kblex
	DD	$LN206@kblex
	DD	$LN205@kblex
	DD	$LN210@kblex
	DD	$LN211@kblex
	DD	$LN208@kblex
	DD	$LN207@kblex
	DD	$LN195@kblex
	DD	$LN196@kblex
	DD	$LN200@kblex
	DD	$LN194@kblex
	DD	$LN209@kblex
	DD	$LN197@kblex
	DD	$LN190@kblex
	DD	$LN202@kblex
	DD	$LN189@kblex
$LN293@kblex:
	DB	0
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	1
	DB	2
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	1
	DB	3
	DB	4
	DB	5
	DB	25					; 00000019H
	DB	6
	DB	7
	DB	8
	DB	9
	DB	6
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	6
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	6
	DB	6
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	6
	DB	20					; 00000014H
	DB	6
	DB	6
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	6
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	8
	DB	25					; 00000019H
	DB	4
_kblex	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@JNCBHLKL@generated?5error?$AA@	; `string'
PUBLIC	_kb_yylex
;	COMDAT ??_C@_0BA@JNCBHLKL@generated?5error?$AA@
CONST	SEGMENT
??_C@_0BA@JNCBHLKL@generated?5error?$AA@ DB 'generated error', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _kb_yylex
_TEXT	SEGMENT
_lvalp$ = 8						; size = 4
_kb_yylex PROC						; COMDAT

; 701  : {

	push	ebp
	mov	ebp, esp

; 702  :   if ( lvalp )
; 703  :   { PROF_FINISH(yyparse); /* exclude from yyparse time */
; 704  :   }
; 705  : 
; 706  :   PROF_START(yylex);
; 707  : 
; 708  :   if ( unput_tok_count ) 

	mov	eax, DWORD PTR _unput_tok_count
	push	esi

; 709  :   { tok = unputted_tok[--unput_tok_count]; 

	mov	esi, 1
	test	eax, eax
	je	SHORT $LN15@kb_yylex
	sub	eax, esi
	mov	DWORD PTR _unput_tok_count, eax
	mov	eax, DWORD PTR _unputted_tok[eax*4]

; 710  :   }
; 711  :   else 

	jmp	SHORT $LN22@kb_yylex
$LN15@kb_yylex:

; 712  :   { 
; 713  :     /* clean out previous data */
; 714  :     /* memset(&yylval,0,sizeof(yylval)); time hog*/
; 715  :     /*  tok = yylex(); */
; 716  :     if ( err_tok_gen_flag )

	cmp	DWORD PTR _err_tok_gen_flag, 0
	je	SHORT $LN13@kb_yylex

; 717  :     { if ( token_count == next_err_token )

	mov	eax, DWORD PTR _token_count
	cmp	eax, DWORD PTR _next_err_token
	jne	SHORT $LN12@kb_yylex

; 718  :       { tok = GEN_ERROR_TOKEN;
; 719  :         if ( yytext )

	mov	eax, DWORD PTR _yytext
	mov	DWORD PTR _tok, 10000			; 00002710H
	test	eax, eax
	je	SHORT $LN11@kb_yylex

; 720  :           strcpy(yytext,"generated error");

	mov	ecx, DWORD PTR ??_C@_0BA@JNCBHLKL@generated?5error?$AA@
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ??_C@_0BA@JNCBHLKL@generated?5error?$AA@+4
	mov	eax, DWORD PTR _yytext
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ??_C@_0BA@JNCBHLKL@generated?5error?$AA@+8
	mov	edx, DWORD PTR _yytext
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR ??_C@_0BA@JNCBHLKL@generated?5error?$AA@+12
	mov	ecx, DWORD PTR _yytext
	mov	DWORD PTR [ecx+12], eax
$LN11@kb_yylex:

; 721  :         next_err_token++;

	inc	DWORD PTR _next_err_token

; 722  :         token_count += 10000000; /* just one error per file */

	add	DWORD PTR _token_count, 10000000	; 00989680H

; 738  :   {
; 739  :     {
; 740  :       /* non-movsd substitute for     *lvalp = yylval; */
; 741  :       int i;
; 742  :       int *dest = (int*)lvalp;
; 743  :       int *src  = (int*)&yylval;
; 744  :       for ( i = 0 ; i < sizeof(yylval)/sizeof(int) ; i++ )

	mov	eax, DWORD PTR _tok
	pop	esi

; 746  :     }
; 747  : 
; 748  :     PROF_START(yyparse);
; 749  :   }
; 750  : 
; 751  : 
; 752  :   PROF_FINISH(yylex);
; 753  :   return tok;
; 754  : } // end kb_yylex()

	pop	ebp
	ret	0
$LN12@kb_yylex:

; 723  :         return tok;
; 724  :       }
; 725  :       token_count++;

	add	DWORD PTR _token_count, esi
$LN13@kb_yylex:

; 726  :     }
; 727  :     tok = kblex();

	call	_kblex
$LN22@kb_yylex:

; 728  :   }
; 729  : 
; 730  :   switch ( tok )

	lea	ecx, DWORD PTR [eax-40]
	mov	DWORD PTR _tok, eax
	cmp	ecx, 85					; 00000055H
	ja	SHORT $LN9@kb_yylex
	movzx	edx, BYTE PTR $LN21@kb_yylex[ecx]
	jmp	DWORD PTR $LN24@kb_yylex[edx*4]
$LN8@kb_yylex:

; 731  :   { case '(' : parens++; break;

	add	DWORD PTR _parens, esi
	jmp	SHORT $LN9@kb_yylex
$LN7@kb_yylex:

; 732  :     case ')' : parens--; break;

	sub	DWORD PTR _parens, esi
	jmp	SHORT $LN9@kb_yylex
$LN6@kb_yylex:

; 733  :     case '{' : brace_depth++; break;

	add	DWORD PTR _brace_depth, esi
	jmp	SHORT $LN9@kb_yylex
$LN5@kb_yylex:

; 734  :     case '}' : brace_depth--; break;

	sub	DWORD PTR _brace_depth, esi
$LN9@kb_yylex:

; 735  :   }
; 736  : 
; 737  :   if ( lvalp ) 

	mov	edx, DWORD PTR _lvalp$[ebp]
	test	edx, edx
	je	SHORT $LN17@kb_yylex

; 738  :   {
; 739  :     {
; 740  :       /* non-movsd substitute for     *lvalp = yylval; */
; 741  :       int i;
; 742  :       int *dest = (int*)lvalp;
; 743  :       int *src  = (int*)&yylval;
; 744  :       for ( i = 0 ; i < sizeof(yylval)/sizeof(int) ; i++ )

	mov	ecx, OFFSET _yylval
	mov	eax, edx
	sub	ecx, edx
	mov	edx, 26					; 0000001aH
	push	edi
$LL3@kb_yylex:

; 745  :          *(dest++) = *(src++);

	mov	edi, DWORD PTR [ecx+eax]
	mov	DWORD PTR [eax], edi
	add	eax, 4
	sub	edx, esi
	jne	SHORT $LL3@kb_yylex

; 738  :   {
; 739  :     {
; 740  :       /* non-movsd substitute for     *lvalp = yylval; */
; 741  :       int i;
; 742  :       int *dest = (int*)lvalp;
; 743  :       int *src  = (int*)&yylval;
; 744  :       for ( i = 0 ; i < sizeof(yylval)/sizeof(int) ; i++ )

	mov	eax, DWORD PTR _tok
	pop	edi
$LN17@kb_yylex:
	pop	esi

; 746  :     }
; 747  : 
; 748  :     PROF_START(yyparse);
; 749  :   }
; 750  : 
; 751  : 
; 752  :   PROF_FINISH(yylex);
; 753  :   return tok;
; 754  : } // end kb_yylex()

	pop	ebp
	ret	0
	npad	3
$LN24@kb_yylex:
	DD	$LN8@kb_yylex
	DD	$LN7@kb_yylex
	DD	$LN6@kb_yylex
	DD	$LN5@kb_yylex
	DD	$LN9@kb_yylex
$LN21@kb_yylex:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	3
_kb_yylex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@KGHDCJOD@out?5of?5dynamic?5memory?5in?5yy_crea@ ; `string'
PUBLIC	_yy_create_buffer
;	COMDAT ??_C@_0CM@KGHDCJOD@out?5of?5dynamic?5memory?5in?5yy_crea@
CONST	SEGMENT
??_C@_0CM@KGHDCJOD@out?5of?5dynamic?5memory?5in?5yy_crea@ DB 'out of dyna'
	DB	'mic memory in yy_create_buffer()', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _yy_create_buffer
_TEXT	SEGMENT
_file$ = 8						; size = 4
_size$ = 12						; size = 4
_yy_create_buffer PROC					; COMDAT

; 2695 : 	{

	push	ebp
	mov	ebp, esp
	push	esi

; 2696 : 	YY_BUFFER_STATE b;
; 2697 : 
; 2698 : 	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );

	mov	eax, 40					; 00000028H
	call	_yy_flex_alloc
	mov	esi, eax

; 2699 : 	if ( ! b )

	test	esi, esi
	jne	SHORT $LN2@yy_create_

; 2700 : 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	mov	eax, OFFSET ??_C@_0CM@KGHDCJOD@out?5of?5dynamic?5memory?5in?5yy_crea@
	call	_yy_fatal_error
$LN6@yy_create_:
$LN2@yy_create_:

; 2701 : 
; 2702 : 	b->yy_buf_size = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [esi+12], eax

; 2703 : 
; 2704 : 	/* yy_ch_buf has to be 2 characters longer than the size given because
; 2705 : 	 * we need to put in 2 end-of-buffer characters.
; 2706 : 	 */
; 2707 : 	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );

	add	eax, 2
	call	_yy_flex_alloc
	mov	DWORD PTR [esi+4], eax

; 2708 : 	if ( ! b->yy_ch_buf )

	test	eax, eax
	jne	SHORT $LN1@yy_create_

; 2709 : 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	mov	eax, OFFSET ??_C@_0CM@KGHDCJOD@out?5of?5dynamic?5memory?5in?5yy_crea@
	call	_yy_fatal_error
$LN7@yy_create_:
$LN1@yy_create_:

; 2710 : 
; 2711 : 	b->yy_is_our_buffer = 1;
; 2712 : 
; 2713 : 	yy_init_buffer( b, file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	esi
	mov	DWORD PTR [esi+20], 1
	call	_yy_init_buffer
	add	esp, 8

; 2714 : 
; 2715 : 	return b;

	mov	eax, esi
	pop	esi

; 2716 : 	}

	pop	ebp
	ret	0
$LN5@yy_create_:
_yy_create_buffer ENDP
_TEXT	ENDS
PUBLIC	_yy_scan_string
; Function compile flags: /Ogtp
;	COMDAT _yy_scan_string
_TEXT	SEGMENT
_str$ = 8						; size = 4
_yy_scan_string PROC					; COMDAT

; 2844 : 	{

	push	ebp
	mov	ebp, esp

; 2845 : 	int len;
; 2846 : 	for ( len = 0; str[len]; ++len )

	mov	ecx, DWORD PTR _str$[ebp]
	xor	eax, eax
	cmp	BYTE PTR [ecx], al
	je	SHORT $LN1@yy_scan_st
	npad	4
$LL3@yy_scan_st:
	inc	eax
	cmp	BYTE PTR [eax+ecx], 0
	jne	SHORT $LL3@yy_scan_st
$LN1@yy_scan_st:

; 2847 : 		;
; 2848 : 
; 2849 : 	return yy_scan_bytes( str, len );

	push	eax
	push	ecx
	call	_yy_scan_bytes
	add	esp, 8

; 2850 : 	}

	pop	ebp
	ret	0
_yy_scan_string ENDP
_TEXT	ENDS
PUBLIC	_yyrestart
; Function compile flags: /Ogtp
;	COMDAT _yyrestart
_TEXT	SEGMENT
_input_file$ = 8					; size = 4
_yyrestart PROC						; COMDAT

; 2636 : 	{

	push	ebp
	mov	ebp, esp

; 2637 : 	if ( ! yy_current_buffer )

	mov	eax, DWORD PTR _yy_current_buffer
	test	eax, eax
	jne	SHORT $LN1@yyrestart

; 2638 : 		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

	mov	eax, DWORD PTR _yyin
	push	16384					; 00004000H
	push	eax
	call	_yy_create_buffer
	add	esp, 8
	mov	DWORD PTR _yy_current_buffer, eax
$LN1@yyrestart:

; 2639 : 
; 2640 : 	yy_init_buffer( yy_current_buffer, input_file );

	mov	ecx, DWORD PTR _input_file$[ebp]
	push	ecx
	push	eax
	call	_yy_init_buffer
	add	esp, 8

; 2642 : 	}

	pop	ebp

; 2641 : 	yy_load_buffer_state();

	jmp	_yy_load_buffer_state
_yyrestart ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@KBIPOOPN@fatal?5error?5?9?5scanner?5input?5buff@ ; `string'
PUBLIC	??_C@_0DI@MLIALAAB@fatal?5flex?5scanner?5internal?5erro@ ; `string'
;	COMDAT ??_C@_0CM@KBIPOOPN@fatal?5error?5?9?5scanner?5input?5buff@
CONST	SEGMENT
??_C@_0CM@KBIPOOPN@fatal?5error?5?9?5scanner?5input?5buff@ DB 'fatal erro'
	DB	'r - scanner input buffer overflow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MLIALAAB@fatal?5flex?5scanner?5internal?5erro@
CONST	SEGMENT
??_C@_0DI@MLIALAAB@fatal?5flex?5scanner?5internal?5erro@ DB 'fatal flex s'
	DB	'canner internal error--end of buffer missed', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _yy_get_next_buffer
_TEXT	SEGMENT
tv79 = -4						; size = 4
_yy_c_buf_p_offset$90406 = -4				; size = 4
_yy_get_next_buffer PROC				; COMDAT

; 2323 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 2324 : 	register char *dest = yy_current_buffer->yy_ch_buf;

	mov	edx, DWORD PTR _yy_current_buffer

; 2325 : 	register char *source = yytext_ptr;
; 2326 : 	register int number_to_move, i;
; 2327 : 	int ret_val;
; 2328 : 
; 2329 : 	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )

	mov	eax, DWORD PTR _yy_n_chars
	push	esi
	mov	esi, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [esi+eax+1]
	mov	eax, DWORD PTR _yy_c_buf_p
	push	edi
	mov	edi, DWORD PTR _yytext
	cmp	eax, ecx
	jbe	SHORT $LN21@yy_get_nex

; 2330 : 		YY_FATAL_ERROR(
; 2331 : 		"fatal flex scanner internal error--end of buffer missed" );

	mov	eax, OFFSET ??_C@_0DI@MLIALAAB@fatal?5flex?5scanner?5internal?5erro@
	call	_yy_fatal_error
$LN34@yy_get_nex:
$LN21@yy_get_nex:

; 2332 : 
; 2333 : 	if ( yy_current_buffer->yy_fill_buffer == 0 )

	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN18@yy_get_nex

; 2334 : 		{ /* Don't try to fill the buffer, so this is an EOF. */
; 2335 : 		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )

	sub	eax, edi
	dec	eax
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	inc	eax
	pop	esi

; 2447 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@yy_get_nex:
	push	ebx

; 2336 : 			{
; 2337 : 			/* We matched a single character, the EOB, so
; 2338 : 			 * treat this as a final EOF.
; 2339 : 			 */
; 2340 : 			return EOB_ACT_END_OF_FILE;
; 2341 : 			}
; 2342 : 
; 2343 : 		else
; 2344 : 			{
; 2345 : 			/* We matched some text prior to the EOB, first
; 2346 : 			 * process it.
; 2347 : 			 */
; 2348 : 			return EOB_ACT_LAST_MATCH;
; 2349 : 			}
; 2350 : 		}
; 2351 : 
; 2352 : 	/* Try to read more data. */
; 2353 : 
; 2354 : 	/* First move last chars to start of buffer. */
; 2355 : 	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

	mov	ebx, eax
	sub	ebx, edi
	dec	ebx

; 2356 : 
; 2357 : 	for ( i = 0; i < number_to_move; ++i )

	test	ebx, ebx
	jle	SHORT $LN15@yy_get_nex

; 2336 : 			{
; 2337 : 			/* We matched a single character, the EOB, so
; 2338 : 			 * treat this as a final EOF.
; 2339 : 			 */
; 2340 : 			return EOB_ACT_END_OF_FILE;
; 2341 : 			}
; 2342 : 
; 2343 : 		else
; 2344 : 			{
; 2345 : 			/* We matched some text prior to the EOB, first
; 2346 : 			 * process it.
; 2347 : 			 */
; 2348 : 			return EOB_ACT_LAST_MATCH;
; 2349 : 			}
; 2350 : 		}
; 2351 : 
; 2352 : 	/* Try to read more data. */
; 2353 : 
; 2354 : 	/* First move last chars to start of buffer. */
; 2355 : 	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

	mov	DWORD PTR tv79[ebp], ebx
$LL17@yy_get_nex:

; 2358 : 		*(dest++) = *(source++);

	mov	cl, BYTE PTR [edi]
	mov	BYTE PTR [esi], cl
	inc	esi
	inc	edi
	dec	DWORD PTR tv79[ebp]
	jne	SHORT $LL17@yy_get_nex
$LN15@yy_get_nex:

; 2359 : 
; 2360 : 	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )

	cmp	DWORD PTR [edx+36], 2

; 2361 : 		/* don't do the read, it's not guaranteed to return an EOF,
; 2362 : 		 * just force an EOF
; 2363 : 		 */
; 2364 : 		yy_n_chars = 0;
; 2365 : 
; 2366 : 	else

	je	$LN33@yy_get_nex

; 2367 : 		{
; 2368 : 		int num_to_read =
; 2369 : 			yy_current_buffer->yy_buf_size - number_to_move - 1;
; 2370 : 
; 2371 : 		while ( num_to_read <= 0 )

	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, ebx
	dec	ecx
	test	ecx, ecx
	jg	SHORT $LN11@yy_get_nex
$LL12@yy_get_nex:

; 2372 : 			{ /* Not enough room in the buffer - grow it. */
; 2373 : #ifdef YY_USES_REJECT
; 2374 : 			YY_FATAL_ERROR(
; 2375 : "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
; 2376 : #else
; 2377 : 
; 2378 : 			/* just a shorter name for the current buffer */
; 2379 : 			YY_BUFFER_STATE b = yy_current_buffer;
; 2380 : 
; 2381 : 			int yy_c_buf_p_offset =
; 2382 : 				(int) (yy_c_buf_p - b->yy_ch_buf);

	mov	ecx, DWORD PTR [edx+4]
	lea	esi, DWORD PTR [edx+4]
	sub	eax, ecx

; 2383 : 
; 2384 : 			if ( b->yy_is_our_buffer )

	cmp	DWORD PTR [edx+20], 0
	mov	DWORD PTR _yy_c_buf_p_offset$90406[ebp], eax
	je	SHORT $LN10@yy_get_nex

; 2385 : 				{
; 2386 : 				int new_size = b->yy_buf_size * 2;

	mov	eax, DWORD PTR [edx+12]
	lea	edi, DWORD PTR [eax+eax]

; 2387 : 
; 2388 : 				if ( new_size <= 0 )

	test	edi, edi
	jg	SHORT $LN9@yy_get_nex

; 2389 : 					b->yy_buf_size += b->yy_buf_size / 8;

	mov	edi, eax
	shr	edi, 3
	add	edi, eax
$LN9@yy_get_nex:

; 2390 : 				else
; 2391 : 					b->yy_buf_size *= 2;
; 2392 : 
; 2393 : 				b->yy_ch_buf = (char *)
; 2394 : 					/* Include room in for 2 EOB chars. */
; 2395 : 					yy_flex_realloc( (void *) b->yy_ch_buf,
; 2396 : 							 b->yy_buf_size + 2 );

	mov	eax, edi
	add	eax, 2
	mov	DWORD PTR [edx+12], edi
	call	_yy_flex_realloc

; 2397 : 				}
; 2398 : 			else

	mov	edx, DWORD PTR _yy_current_buffer
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LN7@yy_get_nex
$LN10@yy_get_nex:

; 2399 : 				/* Can't grow it, we don't own it. */
; 2400 : 				b->yy_ch_buf = 0;

	mov	DWORD PTR [esi], 0
$LN7@yy_get_nex:

; 2401 : 
; 2402 : 			if ( ! b->yy_ch_buf )

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $LN28@yy_get_nex

; 2405 : 
; 2406 : 			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

	mov	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _yy_c_buf_p_offset$90406[ebp]
	sub	ecx, ebx
	add	eax, esi

; 2407 : 
; 2408 : 			num_to_read = yy_current_buffer->yy_buf_size -
; 2409 : 						number_to_move - 1;

	dec	ecx
	mov	DWORD PTR _yy_c_buf_p, eax
	test	ecx, ecx
	jle	SHORT $LL12@yy_get_nex
$LN11@yy_get_nex:

; 2410 : #endif
; 2411 : 			}
; 2412 : 
; 2413 : 		if ( num_to_read > YY_READ_BUF_SIZE )
; 2414 : 			num_to_read = YY_READ_BUF_SIZE;
; 2415 : 
; 2416 : 		/* Read in more data. */
; 2417 : 		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
; 2418 : 			yy_n_chars, num_to_read );

	call	_kb_input
	mov	edx, DWORD PTR _yy_current_buffer
	test	eax, eax
	je	SHORT $LN33@yy_get_nex
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ebx+ecx], al
	mov	eax, 1

; 2438 : 		ret_val = EOB_ACT_CONTINUE_SCAN;

	xor	esi, esi
$LN1@yy_get_nex:

; 2439 : 
; 2440 : 	yy_n_chars += number_to_move;
; 2441 : 	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;

	mov	ecx, DWORD PTR [edx+4]
	add	eax, ebx
	mov	BYTE PTR [eax+ecx], 0

; 2442 : 	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+ecx+1], 0

; 2443 : 
; 2444 : 	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

	mov	edx, DWORD PTR [edx+4]
	pop	ebx
	mov	DWORD PTR _yy_n_chars, eax
	pop	edi

; 2445 : 
; 2446 : 	return ret_val;

	mov	eax, esi
	mov	DWORD PTR _yytext, edx
	pop	esi

; 2447 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@yy_get_nex:

; 2403 : 				YY_FATAL_ERROR(
; 2404 : 				"fatal error - scanner input buffer overflow" );

	mov	eax, OFFSET ??_C@_0CM@KBIPOOPN@fatal?5error?5?9?5scanner?5input?5buff@
	call	_yy_fatal_error
$LN35@yy_get_nex:
$LN33@yy_get_nex:

; 2410 : #endif
; 2411 : 			}
; 2412 : 
; 2413 : 		if ( num_to_read > YY_READ_BUF_SIZE )
; 2414 : 			num_to_read = YY_READ_BUF_SIZE;
; 2415 : 
; 2416 : 		/* Read in more data. */
; 2417 : 		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
; 2418 : 			yy_n_chars, num_to_read );

	xor	eax, eax
	mov	DWORD PTR _yy_n_chars, eax

; 2419 : 		}
; 2420 : 
; 2421 : 	if ( yy_n_chars == 0 )
; 2422 : 		{
; 2423 : 		if ( number_to_move == YY_MORE_ADJ )

	test	ebx, ebx
	jne	SHORT $LN3@yy_get_nex

; 2424 : 			{
; 2425 : 			ret_val = EOB_ACT_END_OF_FILE;
; 2426 : 			yyrestart( yyin );

	mov	edx, DWORD PTR _yyin
	push	edx
	lea	esi, DWORD PTR [eax+1]
	call	_yyrestart

; 2427 : 			}
; 2428 : 
; 2429 : 		else

	mov	edx, DWORD PTR _yy_current_buffer
	mov	eax, DWORD PTR _yy_n_chars
	add	esp, 4
	jmp	SHORT $LN1@yy_get_nex
$LN3@yy_get_nex:

; 2430 : 			{
; 2431 : 			ret_val = EOB_ACT_LAST_MATCH;

	mov	esi, 2

; 2432 : 			yy_current_buffer->yy_buffer_status =
; 2433 : 				YY_BUFFER_EOF_PENDING;

	mov	DWORD PTR [edx+36], esi

; 2434 : 			}
; 2435 : 		}
; 2436 : 
; 2437 : 	else

	jmp	SHORT $LN1@yy_get_nex
$LN32@yy_get_nex:
_yy_get_next_buffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@HEBAAMNP@unexpected?5last?5match?5in?5input?$CI?$CJ@ ; `string'
;	COMDAT ??_C@_0CB@HEBAAMNP@unexpected?5last?5match?5in?5input?$CI?$CJ@
CONST	SEGMENT
??_C@_0CB@HEBAAMNP@unexpected?5last?5match?5in?5input?$CI?$CJ@ DB 'unexpe'
	DB	'cted last match in input()', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _input
_TEXT	SEGMENT
_input	PROC						; COMDAT

; 2566 : 	int c;
; 2567 : 
; 2568 : 	*yy_c_buf_p = yy_hold_char;

	mov	al, BYTE PTR _yy_hold_char
	mov	ecx, DWORD PTR _yy_c_buf_p
	push	esi
	mov	BYTE PTR [ecx], al

; 2569 : 
; 2570 : 	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )

	test	al, al
	jne	$LN19@input
	npad	10
$LL13@input:

; 2571 : 		{
; 2572 : 		/* yy_c_buf_p now points to the character we want to return.
; 2573 : 		 * If this occurs *before* the EOB characters, then it's a
; 2574 : 		 * valid NUL; if not, then we've hit the end of the buffer.
; 2575 : 		 */
; 2576 : 		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )

	mov	eax, DWORD PTR _yy_current_buffer
	mov	edx, DWORD PTR [eax+4]
	add	edx, DWORD PTR _yy_n_chars
	cmp	ecx, edx
	jb	SHORT $LN15@input

; 2581 : 			{ /* need more input */
; 2582 : 			int offset = yy_c_buf_p - yytext_ptr;

	mov	esi, ecx
	sub	esi, DWORD PTR _yytext

; 2583 : 			++yy_c_buf_p;

	inc	ecx
	mov	DWORD PTR _yy_c_buf_p, ecx

; 2584 : 
; 2585 : 			switch ( yy_get_next_buffer() )

	call	_yy_get_next_buffer
	sub	eax, 0
	je	SHORT $LN2@input
	dec	eax
	jne	SHORT $LN17@input

; 2586 : 				{
; 2587 : 				case EOB_ACT_END_OF_FILE:
; 2588 : 					{
; 2589 : 					if ( yywrap() )

	call	_yywrap
	test	eax, eax
	jne	SHORT $LN16@input

; 2593 : 						}
; 2594 : 
; 2595 : 					if ( ! yy_did_buffer_switch_on_eof )

	cmp	DWORD PTR _yy_did_buffer_switch_on_eof, eax
	jne	SHORT $LN3@input

; 2596 : 						YY_NEW_FILE;

	mov	eax, DWORD PTR _yyin
	push	eax
	call	_yyrestart
	add	esp, 4
$LN3@input:

; 2566 : 	int c;
; 2567 : 
; 2568 : 	*yy_c_buf_p = yy_hold_char;

	mov	al, BYTE PTR _yy_hold_char
	mov	ecx, DWORD PTR _yy_c_buf_p
	mov	BYTE PTR [ecx], al

; 2569 : 
; 2570 : 	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )

	test	al, al
	je	SHORT $LL13@input
	jmp	SHORT $LN19@input
$LN17@input:

; 2584 : 
; 2585 : 			switch ( yy_get_next_buffer() )

	dec	eax
	je	SHORT $LN1@input
	mov	ecx, DWORD PTR _yy_c_buf_p
	jmp	SHORT $LN19@input
$LN15@input:

; 2577 : 			/* This was really a NUL. */
; 2578 : 			*yy_c_buf_p = '\0';

	mov	BYTE PTR [ecx], 0

; 2579 : 
; 2580 : 		else

	jmp	SHORT $LN19@input
$LN1@input:

; 2606 : 					break;
; 2607 : 
; 2608 : 				case EOB_ACT_LAST_MATCH:
; 2609 : #ifdef __cplusplus
; 2610 : 					YY_FATAL_ERROR(
; 2611 : 					"unexpected last match in yyinput()" );
; 2612 : #else
; 2613 : 					YY_FATAL_ERROR(
; 2614 : 					"unexpected last match in input()" );

	mov	eax, OFFSET ??_C@_0CB@HEBAAMNP@unexpected?5last?5match?5in?5input?$CI?$CJ@
	call	_yy_fatal_error
$LN21@input:
$LN16@input:

; 2590 : 						{
; 2591 : 						yy_c_buf_p = yytext_ptr + offset;

	mov	ecx, DWORD PTR _yytext
	add	ecx, esi
	mov	DWORD PTR _yy_c_buf_p, ecx

; 2592 : 						return EOF;

	or	eax, -1
	pop	esi

; 2625 : 
; 2626 : 	return c;
; 2627 : 	}

	ret	0
$LN2@input:

; 2597 : #ifdef __cplusplus
; 2598 : 					return yyinput();
; 2599 : #else
; 2600 : 					return input();
; 2601 : #endif
; 2602 : 					}
; 2603 : 
; 2604 : 				case EOB_ACT_CONTINUE_SCAN:
; 2605 : 					yy_c_buf_p = yytext_ptr + offset;

	mov	ecx, DWORD PTR _yytext
	add	ecx, esi
$LN19@input:

; 2615 : #endif
; 2616 : 				}
; 2617 : 			}
; 2618 : 		}
; 2619 : 
; 2620 : 	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */

	movzx	eax, BYTE PTR [ecx]

; 2621 : 	*yy_c_buf_p = '\0';	/* preserve yytext */

	mov	BYTE PTR [ecx], 0

; 2622 : 	yy_hold_char = *++yy_c_buf_p;

	inc	ecx

; 2623 : 
; 2624 : 	yy_current_buffer->yy_at_bol = (c == '\n');

	xor	edx, edx
	cmp	eax, 10					; 0000000aH
	sete	dl
	mov	DWORD PTR _yy_c_buf_p, ecx
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR _yy_hold_char, cl
	mov	ecx, DWORD PTR _yy_current_buffer
	pop	esi
	mov	DWORD PTR [ecx+28], edx

; 2625 : 
; 2626 : 	return c;
; 2627 : 	}

	ret	0
$LN20@input:
_input	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@JHONDBLF@fatal?5flex?5scanner?5internal?5erro@ ; `string'
PUBLIC	??_C@_0BH@KCGBJAHM@Illegal?5token?3?50x?$CF02X?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@BMOPDEKI@Illegal?5token?3?5?$CFc?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@KMKLPONF@Quoted?5string?5over?5198?5character@ ; `string'
PUBLIC	_yylex
EXTRN	_yyerror:PROC
EXTRN	_isprint:PROC
EXTRN	_fwrite:PROC
;	COMDAT ??_C@_0DD@JHONDBLF@fatal?5flex?5scanner?5internal?5erro@
CONST	SEGMENT
??_C@_0DD@JHONDBLF@fatal?5flex?5scanner?5internal?5erro@ DB 'fatal flex s'
	DB	'canner internal error--no action found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KCGBJAHM@Illegal?5token?3?50x?$CF02X?6?$AA@
CONST	SEGMENT
??_C@_0BH@KCGBJAHM@Illegal?5token?3?50x?$CF02X?6?$AA@ DB 'Illegal token: '
	DB	'0x%02X', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BMOPDEKI@Illegal?5token?3?5?$CFc?6?$AA@
CONST	SEGMENT
??_C@_0BD@BMOPDEKI@Illegal?5token?3?5?$CFc?6?$AA@ DB 'Illegal token: %c', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KMKLPONF@Quoted?5string?5over?5198?5character@
CONST	SEGMENT
??_C@_0CD@KMKLPONF@Quoted?5string?5over?5198?5character@ DB 'Quoted strin'
	DB	'g over 198 characters.', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _yylex
_TEXT	SEGMENT
_yy_bp$ = -8						; size = 4
_yy_c$90153 = -1					; size = 1
_yylex	PROC						; COMDAT

; 1745 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1746 : 	register yy_state_type yy_current_state;
; 1747 : 	register char *yy_cp, *yy_bp;
; 1748 : 	register int yy_act;
; 1749 : 
; 1750 : 
; 1751 : 
; 1752 : 	if ( yy_init )

	cmp	DWORD PTR _yy_init, 0
	push	ebx
	push	esi
	push	edi
	je	SHORT $LL265@yylex

; 1753 : 		{
; 1754 : 		yy_init = 0;
; 1755 : 
; 1756 : #ifdef YY_USER_INIT
; 1757 : 		YY_USER_INIT;
; 1758 : #endif
; 1759 : 
; 1760 : 		if ( ! yy_start )

	cmp	DWORD PTR _yy_start, 0
	mov	DWORD PTR _yy_init, 0
	jne	SHORT $LN189@yylex

; 1761 : 			yy_start = 1;	/* first start state */

	mov	DWORD PTR _yy_start, 1
$LN189@yylex:

; 1762 : 
; 1763 : 		if ( ! yyin )

	cmp	DWORD PTR _yyin, 0
	jne	SHORT $LN188@yylex

; 1764 : 			yyin = stdin;

	call	___iob_func
	mov	DWORD PTR _yyin, eax
$LN188@yylex:

; 1765 : 
; 1766 : 		if ( ! yyout )

	cmp	DWORD PTR _yyout, 0
	jne	SHORT $LN187@yylex

; 1767 : 			yyout = stdout;

	call	___iob_func
	add	eax, 32					; 00000020H
	mov	DWORD PTR _yyout, eax
$LN187@yylex:

; 1768 : 
; 1769 : 		if ( ! yy_current_buffer )

	mov	ebx, DWORD PTR _yy_current_buffer
	test	ebx, ebx
	jne	SHORT $LN186@yylex

; 1770 : 			yy_current_buffer =
; 1771 : 				yy_create_buffer( yyin, YY_BUF_SIZE );

	mov	eax, DWORD PTR _yyin
	push	16384					; 00004000H
	push	eax
	call	_yy_create_buffer
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _yy_current_buffer, ebx
$LN186@yylex:

; 1772 : 
; 1773 : 		yy_load_buffer_state();

	call	_yy_load_buffer_state
	jmp	SHORT $LN250@yylex
$LL265@yylex:

; 1851 :        }
; 1852 : 	YY_BREAK

	mov	ebx, DWORD PTR _yy_current_buffer
$LN250@yylex:
	mov	dl, BYTE PTR _yy_hold_char
$LL185@yylex:

; 1774 : 		}
; 1775 : 
; 1776 : 	while ( 1 )		/* loops until end-of-file is reached */
; 1777 : 		{
; 1778 : 		yy_cp = yy_c_buf_p;

	mov	edi, DWORD PTR _yy_c_buf_p

; 1779 : 
; 1780 : 		/* Support of yytext. */
; 1781 : 		*yy_cp = yy_hold_char;

	mov	BYTE PTR [edi], dl

; 1782 : 
; 1783 : 		/* yy_bp points to the position in yy_ch_buf of the start of
; 1784 : 		 * the current run.
; 1785 : 		 */
; 1786 : 		yy_bp = yy_cp;
; 1787 : 
; 1788 : 		yy_current_state = yy_start;
; 1789 : 		yy_current_state += YY_AT_BOL();

	mov	esi, DWORD PTR [ebx+28]
	add	esi, DWORD PTR _yy_start
	mov	DWORD PTR _yy_bp$[ebp], edi
	npad	12
$yy_match$90149:

; 1790 : yy_match:
; 1791 : 		do
; 1792 : 			{
; 1793 : 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];

	movzx	ecx, BYTE PTR [edi]
	mov	cl, BYTE PTR _yy_ec[ecx*4]

; 1794 : 			if ( yy_accept[yy_current_state] )

	lea	eax, DWORD PTR [esi+esi]
	cmp	WORD PTR _yy_accept[eax], 0
	mov	BYTE PTR _yy_c$90153[ebp], cl
	je	SHORT $LN205@yylex

; 1795 : 				{
; 1796 : 				yy_last_accepting_state = yy_current_state;

	mov	DWORD PTR _yy_last_accepting_state, esi

; 1797 : 				yy_last_accepting_cpos = yy_cp;

	mov	DWORD PTR _yy_last_accepting_cpos, edi
$LN205@yylex:

; 1798 : 				}
; 1799 : 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )

	movsx	edx, WORD PTR _yy_base[eax]
	movzx	ecx, cl
	add	edx, ecx
	movsx	edx, WORD PTR _yy_chk[edx*2]
	cmp	edx, esi
	je	SHORT $LN178@yylex
	npad	2
$LL179@yylex:

; 1800 : 				{
; 1801 : 				yy_current_state = (int) yy_def[yy_current_state];

	movsx	esi, WORD PTR _yy_def[eax]

; 1802 : 				if ( yy_current_state >= 230 )

	cmp	esi, 230				; 000000e6H
	jl	SHORT $LN269@yylex

; 1803 : 					yy_c = yy_meta[(unsigned int) yy_c];

	mov	al, BYTE PTR _yy_meta[ecx*4]
	mov	BYTE PTR _yy_c$90153[ebp], al
$LN269@yylex:

; 1798 : 				}
; 1799 : 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )

	movzx	ecx, BYTE PTR _yy_c$90153[ebp]
	lea	eax, DWORD PTR [esi+esi]
	movsx	edx, WORD PTR _yy_base[eax]
	add	edx, ecx
	movsx	edx, WORD PTR _yy_chk[edx*2]
	cmp	edx, esi
	jne	SHORT $LL179@yylex
$LN178@yylex:

; 1804 : 				}
; 1805 : 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];

	movsx	eax, WORD PTR _yy_base[esi*2]
	movzx	ecx, BYTE PTR _yy_c$90153[ebp]
	add	eax, ecx
	movsx	esi, WORD PTR _yy_nxt[eax*2]

; 1806 : 			++yy_cp;
; 1807 : 			}
; 1808 : 		while ( yy_base[yy_current_state] != 827 );

	mov	edx, 827				; 0000033bH
	inc	edi
	cmp	WORD PTR _yy_base[esi*2], dx
	jne	$yy_match$90149
	npad	1
$LL181@yylex:
	mov	ecx, DWORD PTR _yy_last_accepting_state
	mov	edx, DWORD PTR _yy_last_accepting_cpos
	npad	4
$yy_find_action$90164:

; 1809 : 
; 1810 : yy_find_action:
; 1811 : 		yy_act = yy_accept[yy_current_state];

	movsx	eax, WORD PTR _yy_accept[esi*2]

; 1812 : 		if ( yy_act == 0 )

	test	eax, eax
	jne	SHORT $LN176@yylex

; 1813 : 			{ /* have to back up */
; 1814 : 			yy_cp = yy_last_accepting_cpos;
; 1815 : 			yy_current_state = yy_last_accepting_state;
; 1816 : 			yy_act = yy_accept[yy_current_state];

	movsx	eax, WORD PTR _yy_accept[ecx*2]
	mov	edi, edx
$LN176@yylex:

; 1817 : 			}
; 1818 : 
; 1819 : 		YY_DO_BEFORE_ACTION;

	mov	ecx, DWORD PTR _yy_bp$[ebp]
	mov	edx, edi
	sub	edx, ecx
	mov	DWORD PTR _yytext, ecx
	mov	DWORD PTR _yyleng, edx
	mov	dl, BYTE PTR [edi]
	mov	BYTE PTR [edi], 0
	mov	ecx, DWORD PTR _yytext
	mov	BYTE PTR _yy_hold_char, dl
	mov	DWORD PTR _yy_c_buf_p, edi
$do_action$90167:

; 1820 : 
; 1821 : 
; 1822 : do_action:	/* This label is used only to access EOF actions. */
; 1823 : 
; 1824 : 
; 1825 : 		switch ( yy_act )

	cmp	eax, 70					; 00000046H
	ja	$LN1@yylex
	jmp	DWORD PTR $LN306@yylex[eax*4]
$LN15@yylex:

; 2183 : 
; 2184 : 	case YY_END_OF_BUFFER:
; 2185 : 		{
; 2186 : 		/* Amount of text matched not including the EOB char. */
; 2187 : 		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

	mov	esi, edi
	sub	esi, ecx

; 2188 : 
; 2189 : 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
; 2190 : 		*yy_cp = yy_hold_char;

	mov	BYTE PTR [edi], dl

; 2191 : 		YY_RESTORE_YY_MORE_OFFSET
; 2192 : 
; 2193 : 		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )

	cmp	DWORD PTR [ebx+36], 0
	jne	SHORT $LN267@yylex

; 2194 : 			{
; 2195 : 			/* We're scanning a new file or input source.  It's
; 2196 : 			 * possible that this happened because the user
; 2197 : 			 * just pointed yyin at a new source and called
; 2198 : 			 * yylex().  If so, then we have to assure
; 2199 : 			 * consistency between yy_current_buffer and our
; 2200 : 			 * globals.  Here is the right place to do so, because
; 2201 : 			 * this is the first action (other than possibly a
; 2202 : 			 * back-up) that will match for the new input source.
; 2203 : 			 */
; 2204 : 			yy_n_chars = yy_current_buffer->yy_n_chars;
; 2205 : 			yy_current_buffer->yy_input_file = yyin;

	mov	ecx, DWORD PTR _yyin
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR _yy_n_chars, eax
	mov	DWORD PTR [ebx], ecx

; 2206 : 			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;

	mov	DWORD PTR [ebx+36], 1
$LN267@yylex:

; 2207 : 			}
; 2208 : 
; 2209 : 		/* Note that here we test for yy_c_buf_p "<=" to the position
; 2210 : 		 * of the first EOB in the buffer, since yy_c_buf_p will
; 2211 : 		 * already have been incremented past the NUL character
; 2212 : 		 * (since all states make transitions on EOB to the
; 2213 : 		 * end-of-buffer state).  Contrast this with the test
; 2214 : 		 * in input().
; 2215 : 		 */
; 2216 : 		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )

	mov	edx, DWORD PTR [ebx+4]
	add	edx, DWORD PTR _yy_n_chars
	cmp	DWORD PTR _yy_c_buf_p, edx
	jbe	$LN217@yylex

; 2249 : 				}
; 2250 : 			}
; 2251 : 
; 2252 : 		else switch ( yy_get_next_buffer() )

	call	_yy_get_next_buffer
	sub	eax, 0
	je	$LN3@yylex
	dec	eax
	jne	SHORT $LN262@yylex

; 2253 : 			{
; 2254 : 			case EOB_ACT_END_OF_FILE:
; 2255 : 				{
; 2256 : 				yy_did_buffer_switch_on_eof = 0;

	mov	DWORD PTR _yy_did_buffer_switch_on_eof, eax

; 2257 : 
; 2258 : 				if ( yywrap() )

	call	_yywrap
	test	eax, eax
	je	$LN6@yylex

; 2259 : 					{
; 2260 : 					/* Note: because we've taken care in
; 2261 : 					 * yy_get_next_buffer() to have set up
; 2262 : 					 * yytext, we can now set up
; 2263 : 					 * yy_c_buf_p so that if some total
; 2264 : 					 * hoser (like flex itself) wants to
; 2265 : 					 * call the scanner after we return the
; 2266 : 					 * YY_NULL, it'll still work - another
; 2267 : 					 * YY_NULL will get returned.
; 2268 : 					 */
; 2269 : 					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
; 2270 : 
; 2271 : 					yy_act = YY_STATE_EOF(YY_START);

	mov	eax, DWORD PTR _yy_start
	mov	ecx, DWORD PTR _yytext

; 2272 : 					goto do_action;

	mov	ebx, DWORD PTR _yy_current_buffer
	dec	eax
	cdq
	sub	eax, edx
	mov	dl, BYTE PTR _yy_hold_char
	sar	eax, 1
	mov	DWORD PTR _yy_c_buf_p, ecx
	add	eax, 70					; 00000046H
	jmp	$do_action$90167
$LN173@yylex:

; 1826 : 	{ /* beginning of action switch */
; 1827 : 			case 0: /* must back up */
; 1828 : 			/* undo the effects of YY_DO_BEFORE_ACTION */
; 1829 : 			*yy_cp = yy_hold_char;
; 1830 : 			yy_cp = yy_last_accepting_cpos;
; 1831 : 			yy_current_state = yy_last_accepting_state;

	mov	ecx, DWORD PTR _yy_last_accepting_state
	mov	BYTE PTR [edi], dl
	mov	edx, DWORD PTR _yy_last_accepting_cpos
	mov	edi, edx
	mov	esi, ecx

; 1871 :                else if ( uminus_flag || c[0] != '-' )  

	jmp	$yy_find_action$90164
$LN262@yylex:

; 2249 : 				}
; 2250 : 			}
; 2251 : 
; 2252 : 		else switch ( yy_get_next_buffer() )

	dec	eax
	jne	$LL265@yylex

; 2292 : 
; 2293 : 			case EOB_ACT_LAST_MATCH:
; 2294 : 				yy_c_buf_p =
; 2295 : 				&yy_current_buffer->yy_ch_buf[yy_n_chars];

	mov	ebx, DWORD PTR _yy_current_buffer
	mov	edi, DWORD PTR [ebx+4]
	add	edi, DWORD PTR _yy_n_chars
	mov	DWORD PTR _yy_c_buf_p, edi

; 2296 : 
; 2297 : 				yy_current_state = yy_get_previous_state();

	call	_yy_get_previous_state

; 2298 : 
; 2299 : 				yy_cp = yy_c_buf_p;
; 2300 : 				yy_bp = yytext_ptr + YY_MORE_ADJ;

	mov	ecx, DWORD PTR _yytext
	mov	esi, eax
	mov	DWORD PTR _yy_bp$[ebp], ecx
	jmp	$LL181@yylex
$LN217@yylex:

; 2217 : 			{ /* This was really a NUL. */
; 2218 : 			yy_state_type yy_next_state;
; 2219 : 
; 2220 : 			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

	mov	edi, DWORD PTR _yytext
	lea	eax, DWORD PTR [edi+esi-1]
	mov	DWORD PTR _yy_c_buf_p, eax

; 2221 : 
; 2222 : 			yy_current_state = yy_get_previous_state();

	call	_yy_get_previous_state
	mov	esi, eax

; 2223 : 
; 2224 : 			/* Okay, we're now positioned to make the NUL
; 2225 : 			 * transition.  We couldn't have
; 2226 : 			 * yy_get_previous_state() go ahead and do it
; 2227 : 			 * for us because it doesn't know how to deal
; 2228 : 			 * with the possibility of jamming (and we don't
; 2229 : 			 * want to build jamming into it because then it
; 2230 : 			 * will run more slowly).
; 2231 : 			 */
; 2232 : 
; 2233 : 			yy_next_state = yy_try_NUL_trans( yy_current_state );

	call	_yy_try_NUL_trans

; 2234 : 
; 2235 : 			yy_bp = yytext_ptr + YY_MORE_ADJ;

	mov	DWORD PTR _yy_bp$[ebp], edi

; 2243 : 				}
; 2244 : 
; 2245 : 			else
; 2246 : 				{
; 2247 : 				yy_cp = yy_c_buf_p;

	mov	edi, DWORD PTR _yy_c_buf_p
	test	eax, eax

; 2248 : 				goto yy_find_action;

	je	$LL181@yylex

; 2236 : 
; 2237 : 			if ( yy_next_state )
; 2238 : 				{
; 2239 : 				/* Consume the NUL. */
; 2240 : 				yy_cp = ++yy_c_buf_p;
; 2241 : 				yy_current_state = yy_next_state;

	inc	edi
	mov	esi, eax

; 2242 : 				goto yy_match;

	jmp	$yy_match$90149
$LN3@yylex:

; 2279 : 					}
; 2280 : 				break;
; 2281 : 				}
; 2282 : 
; 2283 : 			case EOB_ACT_CONTINUE_SCAN:
; 2284 : 				yy_c_buf_p =
; 2285 : 					yytext_ptr + yy_amount_of_matched_text;

	mov	ebx, DWORD PTR _yytext
	lea	edi, DWORD PTR [ebx+esi-1]
	mov	DWORD PTR _yy_c_buf_p, edi

; 2286 : 
; 2287 : 				yy_current_state = yy_get_previous_state();

	call	_yy_get_previous_state

; 2288 : 
; 2289 : 				yy_cp = yy_c_buf_p;
; 2290 : 				yy_bp = yytext_ptr + YY_MORE_ADJ;

	mov	DWORD PTR _yy_bp$[ebp], ebx

; 2291 : 				goto yy_match;

	mov	ebx, DWORD PTR _yy_current_buffer
	mov	esi, eax
	jmp	$yy_match$90149
$LN172@yylex:

; 1832 : 			goto yy_find_action;
; 1833 : 
; 1834 : case 1:
; 1835 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN171@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
$LN171@yylex:

; 1836 : { /* eat comment */
; 1837 :          register int c;
; 1838 :          in_comment = 1;

	mov	DWORD PTR _in_comment, 1
	mov	esi, 1
	npad	3
$LL170@yylex:

; 1839 :          for ( ; ; )
; 1840 :           { while ( (c = input()) != '*' && c != 0 )

	call	_input
	cmp	eax, 42					; 0000002aH
	je	SHORT $LL164@yylex
	npad	6
$LL168@yylex:
	test	eax, eax
	je	SHORT $LN237@yylex

; 1841 :           if ( c == '\n' ) line_no++; /* eat up text of comment */

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN166@yylex
	add	DWORD PTR _line_no, esi
$LN166@yylex:

; 1839 :          for ( ; ; )
; 1840 :           { while ( (c = input()) != '*' && c != 0 )

	call	_input
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LL168@yylex
	npad	7
$LL164@yylex:

; 1842 :             if ( c == '*' )
; 1843 :               { while ( (c = input()) == '*' ) ;

	call	_input
	cmp	eax, 42					; 0000002aH
	je	SHORT $LL164@yylex

; 1844 :                 if ( c == '/' ) break;    /* found the end */ 

	cmp	eax, 47					; 0000002fH
	je	SHORT $LN274@yylex

; 1845 :             if ( c == '\n' ) line_no++; 

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN161@yylex
	add	DWORD PTR _line_no, esi

; 1846 :               }
; 1847 :             if ( c == 0 && yywrap() )

	jmp	SHORT $LL170@yylex
$LN161@yylex:
	test	eax, eax
	jne	SHORT $LL170@yylex
$LN237@yylex:
	call	_yywrap
	test	eax, eax

; 1849 :           }

	je	SHORT $LL170@yylex

; 1848 :               { kb_error(2325,"End-of-file in comment\n",DATAFILE_ERROR ); break; }

	push	6
	push	OFFSET ??_C@_0BI@DHOEFMOD@End?9of?9file?5in?5comment?6?$AA@
	push	2325					; 00000915H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN274@yylex:

; 1850 :          in_comment = 0; 

	mov	DWORD PTR _in_comment, 0

; 1851 :        }
; 1852 : 	YY_BREAK

	jmp	$LL265@yylex
$LN159@yylex:

; 1853 : case 2:
; 1854 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	$LL185@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax

; 1855 : /* comment */ ;
; 1856 : 	YY_BREAK

	jmp	$LL185@yylex
$LN157@yylex:

; 1857 : case 3:
; 1858 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN270@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN270@yylex:

; 1859 : { line_no++; }

	inc	DWORD PTR _line_no

; 1860 : 	YY_BREAK

	jmp	$LL185@yylex
$LN155@yylex:

; 1861 : case 4:
; 1862 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN271@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN271@yylex:

; 1863 : { errspot -= 15; line_no--; }

	sub	DWORD PTR _errspot, 15			; 0000000fH
	dec	DWORD PTR _line_no

; 1864 : 	YY_BREAK

	jmp	$LL185@yylex
$LN37@yylex:

; 2133 : 	YY_BREAK
; 2134 : case 61:
; 2135 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN272@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN272@yylex:

; 2136 : { if (!datafile_flag)

	cmp	DWORD PTR _datafile_flag, 0
	jne	SHORT $LN35@yylex

; 2137 :              kb_error(1880,"#define valid only in top of datafile.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CI@OBOFPJIA@?$CDdefine?5valid?5only?5in?5top?5of?5dat@
	push	1880					; 00000758H
	call	_kb_error
	mov	ebx, DWORD PTR _yy_current_buffer
	mov	dl, BYTE PTR _yy_hold_char
	add	esp, 12					; 0000000cH
$LN35@yylex:

; 2138 :              macro_flag = 1;

	mov	DWORD PTR _macro_flag, 1

; 2139 :            }
; 2140 : 	YY_BREAK

	jmp	$LL185@yylex
$LN34@yylex:

; 2141 : case 62:
; 2142 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN33@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
	mov	ecx, DWORD PTR _yytext
$LN33@yylex:

; 2143 : { /* nested include */
; 2144 :              char *name = strchr(yytext,'"')+1;/* initial quote + 1 */

	push	34					; 00000022H
	push	ecx
	call	_strchr
	lea	esi, DWORD PTR [eax+1]

; 2145 :              *strchr(name,'"') = 0; /* replace final quote by 0 */

	push	34					; 00000022H
	push	esi
	call	_strchr

; 2146 :              push_commandfd(NULL,name);

	push	esi
	push	0
	mov	BYTE PTR [eax], 0
	call	_push_commandfd
	add	esp, 24					; 00000018H

; 2147 :            }
; 2148 : 	YY_BREAK

	jmp	$LL265@yylex
$LN32@yylex:

; 2149 : case 63:
; 2150 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN31@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
	mov	ecx, DWORD PTR _yytext
$LN31@yylex:

; 2151 : { strncpy(yylval.lexeme,yytext,LEXEME_SIZE);

	push	63					; 0000003fH
	push	ecx
	push	OFFSET _yylval+36
	call	_strncpy
	add	esp, 12					; 0000000cH

; 2152 :                            if ( !macro() ) return identcase(yytext); 

	call	_macro
	test	eax, eax
	jne	$LL265@yylex
	mov	ecx, DWORD PTR _yytext
	push	ecx
	call	_identcase
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@yylex:

; 2158 : 	YY_BREAK
; 2159 : case 65:
; 2160 : YY_RULE_SETUP
; 2161 : ;
; 2162 : 	YY_BREAK
; 2163 : case 66:
; 2164 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN24@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN24@yylex:

; 2165 : { if ( cond_expr_flag ) return tok = ':';}

	cmp	DWORD PTR _cond_expr_flag, 0
	je	$LL185@yylex
	pop	edi
	mov	eax, 58					; 0000003aH
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@yylex:

; 2175 :         }
; 2176 : 	YY_BREAK
; 2177 : case 68:
; 2178 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN17@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
	mov	ecx, DWORD PTR _yytext
	mov	esi, DWORD PTR _yyleng
$LN17@yylex:

; 2179 : ECHO;

	mov	eax, DWORD PTR _yyout
	push	eax
	push	1
	push	esi
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 2180 : 	YY_BREAK

	jmp	$LL265@yylex
$LN6@yylex:

; 2273 : 					}
; 2274 : 
; 2275 : 				else
; 2276 : 					{
; 2277 : 					if ( ! yy_did_buffer_switch_on_eof )

	cmp	DWORD PTR _yy_did_buffer_switch_on_eof, 0
	jne	$LL265@yylex

; 2278 : 						YY_NEW_FILE;

	mov	ecx, DWORD PTR _yyin
	push	ecx
	call	_yyrestart
	add	esp, 4
	jmp	$LL265@yylex
$LN153@yylex:

; 1865 : case 5:
; 1866 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN152@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
	mov	ecx, DWORD PTR _yytext
$LN152@yylex:

; 1867 : { char *c = strtok(yytext,whitespace);

	mov	eax, DWORD PTR _whitespace
	push	eax
	push	ecx
	call	_strtok

; 1868 :                yylval.r = atof(strtok(yytext,whitespace));

	mov	ecx, DWORD PTR _whitespace
	mov	edx, DWORD PTR _yytext
	push	ecx
	push	edx
	mov	edi, eax
	call	_strtok
	push	eax
	call	_atof
	fstp	QWORD PTR _yylval+16

; 1869 :                yylval.i = atoi(strtok(yytext,whitespace));

	mov	eax, DWORD PTR _whitespace
	mov	ecx, DWORD PTR _yytext
	push	eax
	push	ecx
	call	_strtok
	push	eax
	call	_atoi
	add	esp, 32					; 00000020H

; 1870 :                if ( lists_flag==LISTS_FULL ) return(tok=LEAD_INTEGER_TOK); 

	cmp	DWORD PTR _lists_flag, 2
	mov	DWORD PTR _yylval, eax
	jne	SHORT $LN151@yylex
	pop	edi
	mov	eax, 264				; 00000108H
	pop	esi

; 1872 :                  return(tok = (fabs(yylval.r) > MAXINT) ? REAL_TOK: INTEGER_TOK);

	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN151@yylex:

; 1871 :                else if ( uminus_flag || c[0] != '-' )  

	cmp	DWORD PTR _uminus_flag, 0
	jne	SHORT $LN148@yylex
	cmp	BYTE PTR [edi], 45			; 0000002dH
	jne	SHORT $LN148@yylex

; 1873 :                else { unput_string(c+1);  c[1] = 0;

	lea	esi, DWORD PTR [edi+1]
	push	esi
	call	_unput_string

; 1874 :                return (tok = minus_type(c[0])); 

	movsx	edx, BYTE PTR [edi]
	push	edx
	mov	BYTE PTR [esi], 0
	call	_minus_type
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN148@yylex:

; 1872 :                  return(tok = (fabs(yylval.r) > MAXINT) ? REAL_TOK: INTEGER_TOK);

	fld	QWORD PTR _yylval+16
$LN301@yylex:
	fabs
	fcomp	QWORD PTR __real@41dfffffffc00000
	fnstsw	ax
	test	ah, 65					; 00000041H
	mov	eax, 266				; 0000010aH
	je	$LN297@yylex
	pop	edi
	mov	eax, 265				; 00000109H
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN146@yylex:

; 1875 :              }
; 1876 :           }
; 1877 : 	YY_BREAK
; 1878 : case 6:
; 1879 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN145@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
	mov	ecx, DWORD PTR _yytext
$LN145@yylex:

; 1880 : { char *c = strtok(yytext,whitespace);

	mov	edx, DWORD PTR _whitespace
	push	edx
	push	ecx
	call	_strtok
	mov	esi, eax

; 1881 :                yylval.i = atoi(c); 

	push	esi
	call	_atoi
	mov	DWORD PTR _yylval, eax

; 1882 :                yylval.r = atof(strtok(c,whitespace));

	mov	eax, DWORD PTR _whitespace
	push	eax
	push	esi
	call	_strtok
	push	eax
	call	_atof
	fst	QWORD PTR _yylval+16
	add	esp, 24					; 00000018H

; 1883 :                yylval.qnum = 0;
; 1884 :                if ((lists_flag!=LISTS_OFF) && uminus_flag && (parens==0))

	cmp	DWORD PTR _lists_flag, 0
	mov	DWORD PTR _yylval+4, 0
	je	SHORT $LN294@yylex
	cmp	DWORD PTR _uminus_flag, 0
	je	SHORT $LN294@yylex
	cmp	DWORD PTR _parens, 0

; 1885 :                return(tok = (fabs(yylval.r) > MAXINT) ? REAL_TOK: INTEGER_TOK);

	je	$LN301@yylex
$LN294@yylex:

; 1886 :                else { unput_string(c+1);  c[1] = 0;

	lea	edi, DWORD PTR [esi+1]
	fstp	ST(0)
	push	edi
	call	_unput_string

; 1887 :                return (tok = minus_type(c[0])); 

	movsx	ecx, BYTE PTR [esi]
	push	ecx
	mov	BYTE PTR [edi], 0
	call	_minus_type
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN142@yylex:

; 1888 :              }
; 1889 :           }
; 1890 : 	YY_BREAK
; 1891 : case 7:
; 1892 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN141@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
	mov	ecx, DWORD PTR _yytext
$LN141@yylex:

; 1893 : { yylval.i = atoi(yytext); 

	push	ecx
	call	_atoi

; 1894 :             yylval.r = atof(strtok(yytext,whitespace));

	mov	ecx, DWORD PTR _yytext
	mov	DWORD PTR _yylval, eax
	mov	eax, DWORD PTR _whitespace
	push	eax
	push	ecx
	call	_strtok
	push	eax
	call	_atof
	fst	QWORD PTR _yylval+16
	add	esp, 16					; 00000010H

; 1895 :             yylval.qnum = 0;

	mov	DWORD PTR _yylval+4, 0

; 1896 :             return(tok = (fabs(yylval.r) > MAXINT) ? REAL_TOK: INTEGER_TOK);

	jmp	$LN301@yylex
$LN140@yylex:

; 1897 :           }
; 1898 : 	YY_BREAK
; 1899 : case 8:
; 1900 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN139@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
	mov	ecx, DWORD PTR _yytext
$LN139@yylex:

; 1901 : { yylval.i = atoi(yytext);

	push	ecx
	call	_atoi
	mov	DWORD PTR _yylval, eax

; 1902 :               yylval.qnum = atoi(strchr(yytext,'@')+1);

	mov	eax, DWORD PTR _yytext
	push	64					; 00000040H
	push	eax
	call	_strchr
	inc	eax
	push	eax
	call	_atoi
	add	esp, 16					; 00000010H
	pop	edi
	mov	DWORD PTR _yylval+4, eax

; 1903 :               return(tok = LEAD_INTEGER_AT_TOK);

	mov	eax, 549				; 00000225H
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN138@yylex:

; 1904 :             }
; 1905 : 	YY_BREAK
; 1906 : case 9:
; 1907 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN137@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
	mov	ecx, DWORD PTR _yytext
$LN137@yylex:

; 1908 : { yylval.i = atoi(yytext);

	push	ecx
	call	_atoi
	mov	DWORD PTR _yylval, eax

; 1909 :               yylval.qnum = atoi(strchr(yytext,'@')+1);

	mov	eax, DWORD PTR _yytext
	push	64					; 00000040H
	push	eax
	call	_strchr
	inc	eax
	push	eax
	call	_atoi
	add	esp, 16					; 00000010H
	pop	edi
	mov	DWORD PTR _yylval+4, eax

; 1910 :               return(tok = INTEGER_AT_TOK);

	mov	eax, 550				; 00000226H
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN136@yylex:

; 1911 :             }
; 1912 : 	YY_BREAK
; 1913 : case 10:
; 1914 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN135@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
	mov	ecx, DWORD PTR _yytext
$LN135@yylex:

; 1915 : { sscanf(yytext+2,"%x",&yylval.i); 

	push	OFFSET _yylval
	add	ecx, 2
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	ecx
	call	_sscanf

; 1916 :               yylval.r = (REAL)(yylval.i);

	fild	DWORD PTR _yylval
	add	esp, 12					; 0000000cH
	pop	edi
	mov	eax, 265				; 00000109H
	fstp	QWORD PTR _yylval+16
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN134@yylex:

; 1917 :               return(tok = INTEGER_TOK);
; 1918 :             }  /* hex */
; 1919 : 	YY_BREAK
; 1920 : case 11:
; 1921 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN133@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
	mov	ecx, DWORD PTR _yytext
$LN133@yylex:

; 1922 : { char *c = yytext;  /* binary */

	mov	esi, ecx

; 1923 :               yylval.i = 0;

	mov	DWORD PTR _yylval, 0

; 1924 :               while ( isdigit(*c) ) { yylval.i = 2*yylval.i + *c - '0'; c++;}

	movsx	ecx, BYTE PTR [esi]
	push	ecx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN131@yylex
	npad	6
$LL132@yylex:
	movsx	edx, BYTE PTR [esi]
	mov	eax, DWORD PTR _yylval
	lea	ecx, DWORD PTR [edx+eax*2-48]
	mov	DWORD PTR _yylval, ecx
	movsx	edx, BYTE PTR [esi+1]
	inc	esi
	push	edx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LL132@yylex
$LN131@yylex:

; 1925 :               yylval.r = (REAL)(yylval.i);

	fild	DWORD PTR _yylval
	pop	edi
	mov	eax, 265				; 00000109H
	pop	esi
	fstp	QWORD PTR _yylval+16
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN130@yylex:

; 1926 :               return(tok = INTEGER_TOK);
; 1927 :             }
; 1928 : 	YY_BREAK
; 1929 : case 12:
; 1930 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN129@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN129@yylex:

; 1931 : return VERSIONTOKEN_TOK;

	pop	edi
	pop	esi
	mov	eax, 35095				; 00008917H
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN128@yylex:

; 1932 : 	YY_BREAK
; 1933 : case 13:
; 1934 : case 14:
; 1935 : case 15:
; 1936 : case 16:
; 1937 : case 17:
; 1938 : case 18:
; 1939 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN127@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
	mov	ecx, DWORD PTR _yytext
$LN127@yylex:

; 1940 : { 
; 1941 :              char *c = strtok(yytext,whitespace);

	mov	eax, DWORD PTR _whitespace
	push	eax
	push	ecx
	call	_strtok
	mov	esi, eax

; 1942 :              yylval.r = atof(c); 

	push	esi
	call	_atof
	fstp	QWORD PTR _yylval+16
	add	esp, 12					; 0000000cH

; 1943 :              if ((lists_flag!=LISTS_OFF) && uminus_flag && (parens==0))

	cmp	DWORD PTR _lists_flag, 0
	je	SHORT $LN126@yylex
	cmp	DWORD PTR _uminus_flag, 0
	je	SHORT $LN126@yylex
	cmp	DWORD PTR _parens, 0

; 1944 :                return(tok = REAL_TOK); 

	je	SHORT $LN303@yylex
$LN126@yylex:

; 1945 :              else 
; 1946 :              { unput_string(c+1);   c[1] = 0;

	lea	edi, DWORD PTR [esi+1]
	push	edi
	call	_unput_string
	mov	BYTE PTR [edi], 0

; 1947 :                verb_flag = 0;  

	mov	DWORD PTR _verb_flag, 0

; 1948 :                return (tok = minus_type(c[0])); 

	movsx	ecx, BYTE PTR [esi]
	push	ecx
	call	_minus_type
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN124@yylex:

; 1949 :              }
; 1950 :           }
; 1951 : 	YY_BREAK
; 1952 : case 19:
; 1953 : case 20:
; 1954 : case 21:
; 1955 : case 22:
; 1956 : case 23:
; 1957 : case 24:
; 1958 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN123@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
	mov	ecx, DWORD PTR _yytext
$LN123@yylex:

; 1959 : { yylval.r = atof(yytext);

	push	ecx
	call	_atof
	fstp	QWORD PTR _yylval+16
	add	esp, 4
$LN303@yylex:

; 1960 :      return(tok = REAL_TOK); }

	pop	edi
	mov	eax, 266				; 0000010aH
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN122@yylex:

; 1961 : 	YY_BREAK
; 1962 : case 25:
; 1963 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN121@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN121@yylex:

; 1964 : { /* read quoted string */
; 1965 :               int n;
; 1966 :           in_quote = 1;
; 1967 :           for (n=0;;n++)

	xor	esi, esi
	mov	DWORD PTR _in_quote, 1
	mov	bl, 92					; 0000005cH
	lea	edi, DWORD PTR [esi+1]
	npad	4
$LL286@yylex:

; 1968 :           { int c;
; 1969 :         c = input();

	call	_input

; 1970 :         if ( c == '\n' ) line_no++;

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN117@yylex
	add	DWORD PTR _line_no, edi

; 1971 :         if ( c == '"' && (n == 0 || (yytext[n-1] != '\\')) ) break; 

	jmp	SHORT $LN266@yylex
$LN117@yylex:
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN266@yylex
	mov	ecx, DWORD PTR _yytext
	test	esi, esi
	je	SHORT $LN115@yylex
	cmp	BYTE PTR [ecx+esi-1], bl
	jne	SHORT $LN115@yylex
$LN266@yylex:

; 1972 :         if ( n < 198 ) yytext[n] = c;

	cmp	esi, 198				; 000000c6H
	jge	SHORT $LN114@yylex
	mov	ecx, DWORD PTR _yytext
	mov	BYTE PTR [ecx+esi], al
	add	esi, edi
	jmp	SHORT $LL286@yylex
$LN114@yylex:

; 1973 :         else if ( n==199 )

	cmp	esi, 199				; 000000c7H
	jne	SHORT $LN119@yylex

; 1974 :           kb_error(2326,"Quoted string over 198 characters.",WARNING);

	push	2
	push	OFFSET ??_C@_0CD@KMKLPONF@Quoted?5string?5over?5198?5character@
	push	2326					; 00000916H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN119@yylex:

; 1964 : { /* read quoted string */
; 1965 :               int n;
; 1966 :           in_quote = 1;
; 1967 :           for (n=0;;n++)

	add	esi, edi
	jmp	SHORT $LL286@yylex
$LN115@yylex:

; 1975 :               }
; 1976 :           yytext[n] = 0;

	mov	BYTE PTR [ecx+esi], 0

; 1977 :           reduce_string(yytext);

	mov	edx, DWORD PTR _yytext
	push	edx
	call	_reduce_string

; 1991 : verb_flag = 0; return (tok = minus_type('-'));   

	add	esp, 4
	pop	edi
	mov	eax, 309				; 00000135H
	pop	esi
	mov	DWORD PTR _in_quote, 0
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN111@yylex:

; 1978 :           in_quote = 0;
; 1979 :           return(tok = QUOTATION_TOK);
; 1980 :         }
; 1981 : 	YY_BREAK
; 1982 : case 26:
; 1983 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN108@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN108@yylex:

; 1991 : verb_flag = 0; return (tok = minus_type('-'));   

	mov	DWORD PTR _verb_flag, 0
$LN100@yylex:
	push	45					; 0000002dH
	call	_minus_type
	add	esp, 4
$LN297@yylex:

; 1872 :                  return(tok = (fabs(yylval.r) > MAXINT) ? REAL_TOK: INTEGER_TOK);

	pop	edi
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN109@yylex:

; 1984 : verb_flag = 0; return (tok = minus_type('-'));   
; 1985 : 	YY_BREAK
; 1986 : case 27:
; 1987 : *yy_cp = yy_hold_char; /* undo effects of setting up yytext */
; 1988 : yy_c_buf_p = yy_cp -= 1;
; 1989 : YY_DO_BEFORE_ACTION; /* set up yytext again */

	mov	eax, DWORD PTR _yy_bp$[ebp]
	mov	BYTE PTR [edi], dl
	dec	edi
	mov	ecx, edi
	sub	ecx, eax
	mov	DWORD PTR _yytext, eax
	mov	DWORD PTR _yyleng, ecx
	mov	dl, BYTE PTR [edi]
	mov	BYTE PTR [edi], 0

; 1990 : YY_RULE_SETUP

	mov	eax, DWORD PTR _yyleng
	mov	BYTE PTR _yy_hold_char, dl
	mov	DWORD PTR _yy_c_buf_p, edi
	test	eax, eax
	jle	SHORT $LN108@yylex
	mov	edx, DWORD PTR _yytext
	xor	ecx, ecx
	cmp	BYTE PTR [eax+edx-1], 10		; 0000000aH
	sete	cl
	mov	DWORD PTR [ebx+28], ecx

; 1991 : verb_flag = 0; return (tok = minus_type('-'));   

	jmp	SHORT $LN108@yylex
$LN107@yylex:

; 1992 : 	YY_BREAK
; 1993 : case 28:
; 1994 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN106@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN106@yylex:

; 1995 : { if (datafile_flag && uminus_flag && (parens == 0) )  

	cmp	DWORD PTR _datafile_flag, 0
	je	$LN108@yylex
	cmp	DWORD PTR _uminus_flag, 0
	je	$LN108@yylex
	cmp	DWORD PTR _parens, 0
	jne	$LN108@yylex

; 1996 :                return(tok = UMINUS_TOK);

	pop	edi
	mov	eax, 287				; 0000011fH
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN103@yylex:

; 1997 :              else { verb_flag = 0; return ( tok = minus_type('-') );}
; 1998 :            }
; 1999 : 	YY_BREAK
; 2000 : case 29:
; 2001 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN102@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
$LN102@yylex:

; 2002 : { verb_flag = 2; yylval.i = SUBASSIGN_OP; return (tok= ASSIGNOP_TOK);}

	pop	edi
	mov	eax, 570				; 0000023aH
	pop	esi
	mov	DWORD PTR _verb_flag, 2
	mov	DWORD PTR _yylval, 30003		; 00007533H
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN101@yylex:

; 2003 : 	YY_BREAK
; 2004 : case 30:
; 2005 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	$LN100@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax

; 2006 : { return ( tok = minus_type('-')); }

	jmp	$LN100@yylex
$LN99@yylex:

; 2007 : 	YY_BREAK
; 2008 : case 31:
; 2009 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN98@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
$LN98@yylex:

; 2010 : { if (datafile_flag && uminus_flag && (parens == 0) ) 

	cmp	DWORD PTR _datafile_flag, 0
	je	$LN108@yylex
	cmp	DWORD PTR _uminus_flag, 0
	je	$LN108@yylex
	cmp	DWORD PTR _parens, 0
	jne	$LN108@yylex

; 2011 :                return ( tok = UMINUS_TOK);

	pop	edi
	mov	eax, 287				; 0000011fH
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN95@yylex:

; 2012 :              else { verb_flag = 0; return ( tok = minus_type('-') ); }
; 2013 :            }
; 2014 : 	YY_BREAK
; 2015 : case 32:
; 2016 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN94@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN94@yylex:

; 2017 : { verb_flag = 2; return (tok= ASSIGN_TOK);}

	pop	edi
	mov	eax, 441				; 000001b9H
	pop	esi
	mov	DWORD PTR _verb_flag, 2
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN93@yylex:

; 2018 : 	YY_BREAK
; 2019 : case 33:
; 2020 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN92@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
$LN92@yylex:

; 2021 : { verb_flag = 2; 
; 2022 :              kb_error(2327,"You mistyped ';=' for ':='?\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BN@DHNHEAEL@You?5mistyped?5?8?$DL?$DN?8?5for?5?8?3?$DN?8?$DP?6?$AA@
	push	2327					; 00000917H
	mov	DWORD PTR _verb_flag, 2
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi

; 2023 :              return (tok= ASSIGN_TOK);

	mov	eax, 441				; 000001b9H
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN91@yylex:

; 2024 :            }
; 2025 : 	YY_BREAK
; 2026 : case 34:
; 2027 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN90@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN90@yylex:

; 2028 : { verb_flag = 2; yylval.i = PLUSASSIGN_OP; return (tok= ASSIGNOP_TOK);}

	pop	edi
	mov	eax, 570				; 0000023aH
	pop	esi
	mov	DWORD PTR _verb_flag, 2
	mov	DWORD PTR _yylval, 30002		; 00007532H
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN87@yylex:

; 2029 : 	YY_BREAK
; 2030 : case 35:
; 2031 : YY_RULE_SETUP
; 2032 : { verb_flag = 2; yylval.i = SUBASSIGN_OP; return (tok= ASSIGNOP_TOK);}
; 2033 : 	YY_BREAK
; 2034 : case 36:
; 2035 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN86@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN86@yylex:

; 2036 : { verb_flag = 2; yylval.i = MULTASSIGN_OP; return (tok= ASSIGNOP_TOK);}

	pop	edi
	mov	eax, 570				; 0000023aH
	pop	esi
	mov	DWORD PTR _verb_flag, 2
	mov	DWORD PTR _yylval, 30004		; 00007534H
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN85@yylex:

; 2037 : 	YY_BREAK
; 2038 : case 37:
; 2039 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN84@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
$LN84@yylex:

; 2040 : { verb_flag = 2; yylval.i = DIVASSIGN_OP; return (tok= ASSIGNOP_TOK);}

	pop	edi
	mov	eax, 570				; 0000023aH
	pop	esi
	mov	DWORD PTR _verb_flag, 2
	mov	DWORD PTR _yylval, 30005		; 00007535H
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN83@yylex:

; 2041 : 	YY_BREAK
; 2042 : case 38:
; 2043 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN82@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN82@yylex:

; 2044 : { verb_flag = 2; return (tok = PERM_ASSIGN_TOK);}

	pop	edi
	mov	eax, 504				; 000001f8H
	pop	esi
	mov	DWORD PTR _verb_flag, 2
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN81@yylex:

; 2045 : 	YY_BREAK
; 2046 : case 39:
; 2047 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN80@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
$LN80@yylex:

; 2048 : { verb_flag = 2; return (tok = REDEFINE_TOK); }

	pop	edi
	mov	eax, 269				; 0000010dH
	pop	esi
	mov	DWORD PTR _verb_flag, 2
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN77@yylex:

; 2049 : 	YY_BREAK
; 2050 : case 40:
; 2051 : YY_RULE_SETUP
; 2052 : { return (tok = minus_type('-'));  }
; 2053 : 	YY_BREAK
; 2054 : case 41:
; 2055 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN76@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
$LN304@yylex:
	mov	ecx, DWORD PTR _yytext
$LN76@yylex:

; 2056 : { verb_flag = 0 ;  return(tok = yytext[0]); }

	mov	DWORD PTR _verb_flag, 0
$LN64@yylex:
	movsx	eax, BYTE PTR [ecx]
	pop	edi
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN75@yylex:

; 2057 : 	YY_BREAK
; 2058 : case 42:
; 2059 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN74@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN74@yylex:

; 2060 : { verb_flag = 1; return tok = ';'; }

	pop	edi
	mov	eax, 59					; 0000003bH
	pop	esi
	mov	DWORD PTR _verb_flag, 1
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@yylex:

; 2061 : 	YY_BREAK
; 2062 : case 43:
; 2063 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN72@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
	mov	ecx, DWORD PTR _yytext
$LN72@yylex:

; 2064 : {  verb_flag = 1; return(tok = yytext[0]); }

	mov	DWORD PTR _verb_flag, 1
	movsx	eax, BYTE PTR [ecx]
	pop	edi
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@yylex:

; 2065 : 	YY_BREAK
; 2066 : case 44:
; 2067 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN70@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
	mov	ecx, DWORD PTR _yytext
$LN70@yylex:

; 2068 : {  return(tok = yytext[0]);  }

	movsx	eax, BYTE PTR [ecx]
	pop	edi
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN69@yylex:

; 2069 : 	YY_BREAK
; 2070 : case 45:
; 2071 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN68@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
$LN68@yylex:

; 2072 : { return tok = (datafile_flag ? '=' : EQ_TOK); }

	mov	eax, DWORD PTR _datafile_flag
	neg	eax
	sbb	eax, eax
	pop	edi
	and	eax, -519				; fffffdf9H
	add	eax, 580				; 00000244H
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN67@yylex:

; 2073 : 	YY_BREAK
; 2074 : case 46:
; 2075 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	$LN76@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax

; 2076 : {   verb_flag = 0; return(tok = yytext[0]); }

	jmp	$LN304@yylex
$LN65@yylex:

; 2077 : 	YY_BREAK
; 2078 : case 47:
; 2079 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	$LN64@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	pop	edi
	sete	dl
	pop	esi
	mov	DWORD PTR [ebx+28], edx
	mov	ecx, DWORD PTR _yytext
	movsx	eax, BYTE PTR [ecx]
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@yylex:

; 2080 : {  return(tok = yytext[0]);  }
; 2081 : 	YY_BREAK
; 2082 : case 48:
; 2083 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	$LN64@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	pop	edi
	sete	al
	pop	esi
	mov	DWORD PTR [ebx+28], eax
	mov	ecx, DWORD PTR _yytext
	movsx	eax, BYTE PTR [ecx]
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@yylex:

; 2084 : {  return(tok = yytext[0]);  }
; 2085 : 	YY_BREAK
; 2086 : case 49:
; 2087 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN60@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
$LN60@yylex:

; 2088 : { return(tok = '^'); }

	pop	edi
	mov	eax, 94					; 0000005eH
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@yylex:

; 2089 : 	YY_BREAK
; 2090 : case 50:
; 2091 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN58@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN58@yylex:

; 2092 : { return(tok = EQ_TOK); }

	pop	edi
	mov	eax, 580				; 00000244H
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@yylex:

; 2093 : 	YY_BREAK
; 2094 : case 51:
; 2095 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN56@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
$LN56@yylex:

; 2096 : { return(tok = NE_TOK); }

	pop	edi
	mov	eax, 577				; 00000241H
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@yylex:

; 2097 : 	YY_BREAK
; 2098 : case 52:
; 2099 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN54@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN54@yylex:

; 2100 : { return(tok = LE_TOK); }

	pop	edi
	mov	eax, 579				; 00000243H
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@yylex:

; 2101 : 	YY_BREAK
; 2102 : case 53:
; 2103 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN52@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
$LN52@yylex:

; 2104 : { return(tok = GE_TOK); }

	pop	edi
	mov	eax, 578				; 00000242H
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@yylex:

; 2105 : 	YY_BREAK
; 2106 : case 54:
; 2107 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN50@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN50@yylex:

; 2108 : { return(tok = OR_TOK); }

	pop	edi
	mov	eax, 574				; 0000023eH
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@yylex:

; 2109 : 	YY_BREAK
; 2110 : case 55:
; 2111 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN48@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
$LN48@yylex:

; 2112 : { return(tok = AND_TOK); }

	pop	edi
	mov	eax, 575				; 0000023fH
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@yylex:

; 2113 : 	YY_BREAK
; 2114 : case 56:
; 2115 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN46@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN46@yylex:

; 2116 : { return(tok = NOT_TOK); }

	pop	edi
	mov	eax, 576				; 00000240H
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@yylex:

; 2117 : 	YY_BREAK
; 2118 : case 57:
; 2119 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN44@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
$LN44@yylex:

; 2120 : { return (tok = PIPE_TOK); /* pipe followed by quoted string */ }

	pop	edi
	mov	eax, 571				; 0000023bH
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@yylex:

; 2121 : 	YY_BREAK
; 2122 : case 58:
; 2123 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN42@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN42@yylex:

; 2124 : { return (tok = REDIRECT_TOK); /* for redirection */ }

	pop	edi
	mov	eax, 468				; 000001d4H
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@yylex:

; 2125 : 	YY_BREAK
; 2126 : case 59:
; 2127 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN40@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
$LN40@yylex:

; 2128 : { return (tok = REDIRECTOVER_TOK); /* for overwrite redirection */ }

	pop	edi
	mov	eax, 495				; 000001efH
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@yylex:

; 2129 : 	YY_BREAK
; 2130 : case 60:
; 2131 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN38@yylex
	xor	eax, eax
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	al
	mov	DWORD PTR [ebx+28], eax
$LN38@yylex:

; 2132 : { return (tok = BACKQUOTE_COMMA_TOK); }

	pop	edi
	mov	eax, 507				; 000001fbH
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@yylex:

; 2153 :                          } 
; 2154 : 	YY_BREAK
; 2155 : case 64:
; 2156 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN28@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
	mov	ecx, DWORD PTR _yytext
$LN28@yylex:

; 2157 : { yylval.i = yytext[1]; return tok = QUOTED_LETTER_TOK; }

	movsx	eax, BYTE PTR [ecx+1]
	pop	edi
	mov	DWORD PTR _yylval, eax
	mov	eax, 353				; 00000161H
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@yylex:

; 2166 : 	YY_BREAK
; 2167 : case 67:
; 2168 : YY_RULE_SETUP

	mov	esi, DWORD PTR _yyleng
	test	esi, esi
	jle	SHORT $LN21@yylex
	xor	edx, edx
	cmp	BYTE PTR [esi+ecx-1], 10		; 0000000aH
	sete	dl
	mov	DWORD PTR [ebx+28], edx
	mov	ecx, DWORD PTR _yytext
$LN21@yylex:

; 2169 : { if ( isprint(yytext[0]) )

	movsx	eax, BYTE PTR [ecx]
	push	eax
	call	_isprint
	add	esp, 4
	test	eax, eax
	je	SHORT $LN20@yylex

; 2170 :             sprintf(errmsg,"Illegal token: %c\n",yytext[0]);

	mov	ecx, DWORD PTR _yytext
	movsx	edx, BYTE PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0BD@BMOPDEKI@Illegal?5token?3?5?$CFc?6?$AA@

; 2171 :           else

	jmp	SHORT $LN300@yylex
$LN20@yylex:

; 2172 :             sprintf(errmsg,"Illegal token: 0x%02X\n",yytext[0]);

	mov	eax, DWORD PTR _yytext
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0BH@KCGBJAHM@Illegal?5token?3?50x?$CF02X?6?$AA@
$LN300@yylex:
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2173 :           yyerror(errmsg);

	push	OFFSET _errmsg
	call	_yyerror
	add	esp, 4
	pop	edi

; 2174 :           return tok=LEXERROR;

	mov	eax, 15004				; 00003a9cH
	pop	esi
	mov	DWORD PTR _tok, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@yylex:
	pop	edi
	pop	esi

; 2181 : case YY_STATE_EOF(INITIAL):
; 2182 : 	yyterminate();

	xor	eax, eax
	pop	ebx

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@yylex:

; 2301 : 				goto yy_find_action;
; 2302 : 			}
; 2303 : 		break;
; 2304 : 		}
; 2305 : 
; 2306 : 	default:
; 2307 : 		YY_FATAL_ERROR(
; 2308 : 			"fatal flex scanner internal error--no action found" );

	mov	eax, OFFSET ??_C@_0DD@JHONDBLF@fatal?5flex?5scanner?5internal?5erro@
	call	_yy_fatal_error
$LN307@yylex:
$LN296@yylex:
$LN306@yylex:

; 2309 : 	} /* end of action switch */
; 2310 : 		} /* end of scanning one token */
; 2311 : 	} /* end of yylex */

	DD	$LN173@yylex
	DD	$LN172@yylex
	DD	$LN159@yylex
	DD	$LN157@yylex
	DD	$LN155@yylex
	DD	$LN153@yylex
	DD	$LN146@yylex
	DD	$LN142@yylex
	DD	$LN140@yylex
	DD	$LN138@yylex
	DD	$LN136@yylex
	DD	$LN134@yylex
	DD	$LN130@yylex
	DD	$LN128@yylex
	DD	$LN128@yylex
	DD	$LN128@yylex
	DD	$LN128@yylex
	DD	$LN128@yylex
	DD	$LN128@yylex
	DD	$LN124@yylex
	DD	$LN124@yylex
	DD	$LN124@yylex
	DD	$LN124@yylex
	DD	$LN124@yylex
	DD	$LN124@yylex
	DD	$LN122@yylex
	DD	$LN111@yylex
	DD	$LN109@yylex
	DD	$LN107@yylex
	DD	$LN103@yylex
	DD	$LN101@yylex
	DD	$LN99@yylex
	DD	$LN95@yylex
	DD	$LN93@yylex
	DD	$LN91@yylex
	DD	$LN103@yylex
	DD	$LN87@yylex
	DD	$LN85@yylex
	DD	$LN83@yylex
	DD	$LN81@yylex
	DD	$LN101@yylex
	DD	$LN77@yylex
	DD	$LN75@yylex
	DD	$LN73@yylex
	DD	$LN71@yylex
	DD	$LN69@yylex
	DD	$LN67@yylex
	DD	$LN65@yylex
	DD	$LN63@yylex
	DD	$LN61@yylex
	DD	$LN59@yylex
	DD	$LN57@yylex
	DD	$LN55@yylex
	DD	$LN53@yylex
	DD	$LN51@yylex
	DD	$LN49@yylex
	DD	$LN47@yylex
	DD	$LN45@yylex
	DD	$LN43@yylex
	DD	$LN41@yylex
	DD	$LN39@yylex
	DD	$LN37@yylex
	DD	$LN34@yylex
	DD	$LN32@yylex
	DD	$LN29@yylex
	DD	$LN159@yylex
	DD	$LN25@yylex
	DD	$LN22@yylex
	DD	$LN18@yylex
	DD	$LN15@yylex
	DD	$LN16@yylex
_yylex	ENDP
_TEXT	ENDS
END
