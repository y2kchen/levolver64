; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\tmain.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_just_lex_flag
PUBLIC	_cpu_affinity_flag
PUBLIC	_element_mutex_ptr
PUBLIC	_web_mutex_ptr
PUBLIC	_spincount
PUBLIC	_oblique_coeff
_DATA	SEGMENT
COMM	_tty_flag:DWORD
COMM	_web_cs:BYTE:018H
COMM	_crit_count:DWORD
COMM	_web_unlocks:DWORD
COMM	_element_unlocks:DWORD
COMM	_threadlist:DWORD
COMM	_workthread_wakeup:DWORD
COMM	_barrier_count:DWORD
COMM	_web_locks:DWORD
COMM	_barrier_event:DWORD
COMM	_mainthread_wakeup:DWORD
COMM	_thread_cs:BYTE:018H
COMM	_element_locks:DWORD
COMM	_thread_locks:DWORD
COMM	_cmdstring:BYTE:02710H
COMM	_thread_unlocks:DWORD
COMM	_cmdstring_flag:DWORD
COMM	_element_cs:BYTE:018H
COMM	_thread_data_key:DWORD
_DATA	ENDS
_BSS	SEGMENT
_just_lex_flag DD 01H DUP (?)
_cpu_affinity_flag DD 01H DUP (?)
_spincount DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_element_mutex_ptr DD FLAT:_element_cs
_web_mutex_ptr DD FLAT:_web_cs
_oblique_coeff DQ 03fbf9af1b79feee2r		; 0.123458
	DQ	03ff164a658b1e79br		; 1.08707
	DQ	03fea7d158faf6eeer		; 0.827769
	DQ	03fdda19c4eff6e1cr		; 0.462989
	ORG $+16
_DATA	ENDS
PUBLIC	_get_fe_edge
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_extra
; Function compile flags: /Ogtp
;	COMDAT _get_extra
_TEXT	SEGMENT
_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_extra PROC						; COMDAT

; 348  : { int type = id_type(id);

	push	ebp
	mov	ebp, esp

; 349  : 
; 350  :   return ( (char*)elptr(id) + EXTRAS(type)[n].offset);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	shr	eax, 29					; 0000001dH
	imul	esi, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, esi
	add	eax, DWORD PTR [edi+ecx+64]
	pop	edi
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_get_extra ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DHMHPBFG@ev?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_affinity_mongering
EXTRN	_graphics_affinity_mask:DWORD
EXTRN	__imp__SetThreadAffinityMask@8:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__GetProcessAffinityMask@12:PROC
EXTRN	_strncmp:PROC
EXTRN	_GetModuleBaseNameA@16:PROC
EXTRN	_EnumProcessModules@16:PROC
EXTRN	__imp__OpenProcess@12:PROC
EXTRN	_EnumProcesses@12:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_02DHMHPBFG@ev?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\tmain.c
CONST	SEGMENT
??_C@_02DHMHPBFG@ev?$AA@ DB 'ev', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _affinity_mongering
_TEXT	SEGMENT
_cbNeeded$81648 = -4392					; size = 4
_cbNeeded$ = -4388					; size = 4
_mainmask$ = -4384					; size = 4
_sysmask$ = -4380					; size = 4
_procmask$ = -4376					; size = 4
_cummask$ = -4372					; size = 4
_i$ = -4368						; size = 4
_this_process$ = -4368					; size = 4
_prime$ = -4364						; size = 4
_hMod$81647 = -4364					; size = 4
_aProcesses$ = -4360					; size = 4096
_szProcessName$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_affinity_mongering PROC				; COMDAT

; 793  : {   char szProcessName[MAX_PATH];

	push	ebp
	mov	ebp, esp
	mov	eax, 4392				; 00001128H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 794  :     DWORD aProcesses[1024];
; 795  : 	DWORD this_process = GetCurrentProcessId();

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	DWORD PTR _this_process$[ebp], eax

; 796  : 	unsigned int cbNeeded, cProcesses;
; 797  :     unsigned int i;
; 798  : 	DWORD_PTR procmask = 0,sysmask = 0,cummask = 0, maskcopy = 0, mainmask = 0, graphmask = 0;
; 799  : 	unsigned int cpu_top;
; 800  : 	unsigned int prime;
; 801  : 
; 802  : 	// Get the list of process identifiers.
; 803  :     if ( !EnumProcesses( aProcesses, sizeof(aProcesses), &cbNeeded ) )

	lea	eax, DWORD PTR _cbNeeded$[ebp]
	push	eax
	xor	esi, esi
	push	4096					; 00001000H
	lea	ecx, DWORD PTR _aProcesses$[ebp]
	push	ecx
	mov	DWORD PTR _procmask$[ebp], esi
	mov	DWORD PTR _sysmask$[ebp], esi
	mov	DWORD PTR _cummask$[ebp], esi
	mov	DWORD PTR _mainmask$[ebp], esi
	call	_EnumProcesses@12
	test	eax, eax
	je	$LN22@affinity_m

; 804  :         return ;
; 805  : 
; 806  :     // Calculate how many process identifiers were returned.
; 807  :     cProcesses = cbNeeded / sizeof(DWORD);

	push	ebx
	mov	ebx, DWORD PTR _cbNeeded$[ebp]
	push	edi
	shr	ebx, 2

; 808  : 
; 809  : 	for ( i = 0; i < cProcesses; i++ )

	xor	edi, edi
	cmp	ebx, esi
	jbe	$LN18@affinity_m
	npad	13
$LL20@affinity_m:

; 810  :     { if( (aProcesses[i] != 0) && (aProcesses[i] != this_process) )

	mov	eax, DWORD PTR _aProcesses$[ebp+edi*4]
	cmp	eax, esi
	je	$LN19@affinity_m
	cmp	eax, DWORD PTR _this_process$[ebp]
	je	$LN19@affinity_m

; 811  :       { HANDLE hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |
; 812  :                                    PROCESS_VM_READ, FALSE, aProcesses[i] );

	push	eax
	push	esi
	push	1040					; 00000410H
	call	DWORD PTR __imp__OpenProcess@12
	mov	esi, eax

; 813  : 	    if (NULL != hProcess )

	test	esi, esi
	je	SHORT $LN19@affinity_m

; 814  :         { HMODULE hMod;
; 815  :           DWORD cbNeeded;
; 816  : 
; 817  :           if ( EnumProcessModules( hProcess, &hMod, sizeof(hMod), &cbNeeded) )

	lea	edx, DWORD PTR _cbNeeded$81648[ebp]
	push	edx
	push	4
	lea	eax, DWORD PTR _hMod$81647[ebp]
	push	eax
	push	esi
	call	_EnumProcessModules@16
	test	eax, eax
	je	SHORT $LN19@affinity_m

; 818  :           { GetModuleBaseName( hProcess, hMod, szProcessName, sizeof(szProcessName)/sizeof(TCHAR) );

	mov	edx, DWORD PTR _hMod$81647[ebp]
	push	260					; 00000104H
	lea	ecx, DWORD PTR _szProcessName$[ebp]
	push	ecx
	push	edx
	push	esi
	call	_GetModuleBaseNameA@16

; 819  : 		    if ( strncmp(szProcessName,"ev",2) == 0 )

	push	2
	lea	eax, DWORD PTR _szProcessName$[ebp]
	push	OFFSET ??_C@_02DHMHPBFG@ev?$AA@
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@affinity_m

; 820  : 			{ GetProcessAffinityMask(hProcess,&procmask,&sysmask);

	lea	ecx, DWORD PTR _sysmask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _procmask$[ebp]
	push	edx
	push	esi
	call	DWORD PTR __imp__GetProcessAffinityMask@12

; 821  : 			  cummask |= procmask;

	mov	eax, DWORD PTR _procmask$[ebp]
	or	DWORD PTR _cummask$[ebp], eax
$LN19@affinity_m:

; 808  : 
; 809  : 	for ( i = 0; i < cProcesses; i++ )

	inc	edi
	xor	esi, esi
	cmp	edi, ebx
	jb	$LL20@affinity_m
$LN18@affinity_m:

; 822  : 			}
; 823  : 		  }
; 824  : 		}
; 825  :    	  }
; 826  : 	}
; 827  : 	// Be sure to get sysmask, in case this first Evolver
; 828  : 	GetProcessAffinityMask(GetCurrentProcess(),&procmask,&sysmask);

	lea	ecx, DWORD PTR _sysmask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _procmask$[ebp]
	push	edx
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__GetProcessAffinityMask@12

; 829  : 
; 830  : 	// get highest cpu number
; 831  : 	for ( cpu_top = 0, maskcopy = sysmask ; maskcopy ; maskcopy >>= 1 )

	mov	eax, DWORD PTR _sysmask$[ebp]
	xor	edi, edi
	cmp	eax, esi
	je	SHORT $LN11@affinity_m
	npad	2
$LL13@affinity_m:

; 832  : 		cpu_top++;

	inc	edi
	shr	eax, 1
	jne	SHORT $LL13@affinity_m
$LN11@affinity_m:

; 833  : 
; 834  : 	// Now pick an unused CPU, if there are any.  Complicated by the fact
; 835  : 	// there might be hyperthreading, and we would rather not assign two
; 836  : 	// processes to the same physical core.  Also, want to give affinity
; 837  : 	// to two CPUs so graphics thread can have one.  To take care of
; 838  : 	// both kinds of hyperthread numbering, we increment by a prime
; 839  : 	// not dividing cpu_top.
; 840  : 	prime = 3;
; 841  : 	if ( (cpu_top % prime) == 0 ) prime = 5;

	xor	edx, edx
	mov	eax, edi
	mov	ecx, 3
	div	ecx
	mov	DWORD PTR _prime$[ebp], 3
	test	edx, edx
	jne	SHORT $LN10@affinity_m
	mov	DWORD PTR _prime$[ebp], 5
$LN10@affinity_m:

; 842  : 	if ( (cpu_top % prime) == 0 ) prime = 7;

	xor	edx, edx
	mov	eax, edi
	div	DWORD PTR _prime$[ebp]
	test	edx, edx
	jne	SHORT $LN9@affinity_m
	mov	DWORD PTR _prime$[ebp], 7
$LN9@affinity_m:

; 843  : 
; 844  : 	for ( i = 0 ; i < cpu_top ; i++ )

	mov	DWORD PTR _i$[ebp], esi
	cmp	edi, esi
	jbe	SHORT $LN35@affinity_m
	xor	ebx, ebx
	npad	4
$LL8@affinity_m:

; 845  : 	{ unsigned int spot = (i*prime) % cpu_top;

	xor	edx, edx
	mov	eax, ebx
	div	edi

; 846  : 	  unsigned int mask = 1 << spot;

	mov	esi, 1
	mov	ecx, edx
	shl	esi, cl

; 847  : 	  if ( !(cummask & mask) )

	test	esi, DWORD PTR _cummask$[ebp]
	jne	SHORT $LN32@affinity_m

; 848  : 	  { if ( mainmask )

	mov	eax, DWORD PTR _mainmask$[ebp]
	test	eax, eax

; 849  : 	       graphmask = mask;
; 850  : 	    else

	jne	SHORT $LN3@affinity_m

; 851  : 		   mainmask = mask;

	mov	DWORD PTR _mainmask$[ebp], esi

; 852  : 	  }
; 853  : 	  if ( graphmask )

	jmp	SHORT $LN32@affinity_m
$LN3@affinity_m:
	test	esi, esi
	jne	SHORT $LN31@affinity_m
$LN32@affinity_m:

; 843  : 
; 844  : 	for ( i = 0 ; i < cpu_top ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	ebx, DWORD PTR _prime$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, edi
	jb	SHORT $LL8@affinity_m
	pop	edi
	pop	ebx
	pop	esi

; 864  : 
; 865  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@affinity_m:

; 854  : 		 break;
; 855  : 	}
; 856  : 
; 857  :     if ( !graphmask )
; 858  : 		// nothing free, so don't do anything
; 859  : 		return;
; 860  : 
; 861  : //	SetProcessAffinityMask(GetCurrentProcess(),mainmask+graphmask);
; 862  : 	SetThreadAffinityMask(GetCurrentThread(),mainmask);

	push	eax
	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__SetThreadAffinityMask@8

; 863  : 	graphics_affinity_mask = graphmask; // for graphics thread to use when launched

	mov	DWORD PTR _graphics_affinity_mask, esi
$LN35@affinity_m:
	pop	edi
	pop	ebx
$LN22@affinity_m:

; 864  : 
; 865  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_affinity_mongering ENDP
_TEXT	ENDS
PUBLIC	_my_exit
EXTRN	_exit:PROC
EXTRN	_signal:PROC
EXTRN	_End_OOGL:PROC
EXTRN	_OOGL_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _my_exit
_TEXT	SEGMENT
_code$ = 8						; size = 4
_my_exit PROC						; COMDAT

; 876  : {

	push	ebp
	mov	ebp, esp

; 877  :   if ( OOGL_flag ) End_OOGL();

	cmp	DWORD PTR _OOGL_flag, 0
	je	SHORT $LN1@my_exit
	call	_End_OOGL
$LN1@my_exit:

; 878  : 
; 879  : #ifdef SIGTERM
; 880  :   signal(SIGTERM,SIG_DFL);

	push	0
	push	15					; 0000000fH
	call	_signal

; 881  : #endif
; 882  : 
; 883  : #ifdef SGI_MULTI
; 884  :   if ( nprocs > 1)
; 885  :      { m_rele_procs();
; 886  :        m_kill_procs();  /* kill any parallel threads */
; 887  :      }
; 888  : #endif
; 889  : 
; 890  : #if defined(MPI_EVOLVER)
; 891  :   mpi_my_exit();
; 892  : #endif
; 893  : 
; 894  : #ifdef USE_READLINE /* CSL */
; 895  :   save_readline_history();
; 896  : #endif
; 897  :   
; 898  : 
; 899  :   exit(code);

	mov	eax, DWORD PTR _code$[ebp]
	add	esp, 8
	push	eax
	call	_exit
$LN5@my_exit:
$LN4@my_exit:
	int	3
_my_exit ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_exec_commands
EXTRN	_old_menu:PROC
EXTRN	_pop_commandfd:PROC
EXTRN	_prompt:PROC
EXTRN	_free_discards:PROC
EXTRN	_temp_free_all:PROC
EXTRN	_datafile_flag:DWORD
EXTRN	_subshell_depth:DWORD
EXTRN	_commandfd:DWORD
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT _exec_commands
_TEXT	SEGMENT
_response$81682 = -2004					; size = 2000
__$ArrayPad$ = -4					; size = 4
_basefd$ = 8						; size = 4
_promptstring$ = 12					; size = 4
_exec_commands PROC					; COMDAT

; 914  : { /* main event loop of program */

	push	ebp
	mov	ebp, esp
	sub	esp, 2004				; 000007d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 915  :   while ( commandfd && (commandfd != basefd))

	mov	eax, DWORD PTR _commandfd
	push	esi
	mov	esi, DWORD PTR _promptstring$[ebp]
	push	edi
	test	eax, eax
	je	SHORT $LN5@exec_comma
	mov	edi, DWORD PTR _basefd$[ebp]
$LL6@exec_comma:
	cmp	eax, edi
	je	SHORT $LN5@exec_comma

; 916  :   {
; 917  :     char response[2000];
; 918  : 
; 919  :     datafile_flag = 0;  /* in case of error bailout sometimes */
; 920  :     if ( !subshell_depth )

	cmp	DWORD PTR _subshell_depth, 0
	mov	DWORD PTR _datafile_flag, 0
	jne	SHORT $LN4@exec_comma

; 921  :     {
; 922  :       temp_free_all(); /* stray memory blocks */

	call	_temp_free_all

; 923  :       free_discards(DISCARDS_ALL); /* from previous cycle */

	push	1
	call	_free_discards

; 924  :       memset(response,0,sizeof(response));

	push	2000					; 000007d0H
	lea	eax, DWORD PTR _response$81682[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 16					; 00000010H
$LN4@exec_comma:

; 925  :     }
; 926  :     if ( prompt(promptstring,response,sizeof(response)) == EOF ) 

	push	2000					; 000007d0H
	lea	ecx, DWORD PTR _response$81682[ebp]
	push	ecx
	push	esi
	call	_prompt
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN3@exec_comma

; 927  :       pop_commandfd();

	call	_pop_commandfd

; 928  :     else 

	jmp	SHORT $LN1@exec_comma
$LN3@exec_comma:

; 929  :       if ( old_menu(response) == END_COMMANDS )

	lea	edx, DWORD PTR _response$81682[ebp]
	push	edx
	call	_old_menu
	add	esp, 4
	cmp	eax, 1234551234				; 4995c1c2H
	je	SHORT $LN10@exec_comma
$LN1@exec_comma:

; 915  :   while ( commandfd && (commandfd != basefd))

	mov	eax, DWORD PTR _commandfd
	test	eax, eax
	jne	SHORT $LL6@exec_comma
$LN5@exec_comma:
	pop	edi

; 930  :          return END_COMMANDS;
; 931  :   }
; 932  :   return 0;

	xor	eax, eax
	pop	esi

; 933  : } // end exec_commands()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@exec_comma:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	mov	eax, 1234551234				; 4995c1c2H
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_exec_commands ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@LDMPFPFF@Enter?5command?3?5?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_exec_file
EXTRN	_push_commandfd:PROC
EXTRN	_read_depth:DWORD
;	COMDAT ??_C@_0BA@LDMPFPFF@Enter?5command?3?5?$AA@
CONST	SEGMENT
??_C@_0BA@LDMPFPFF@Enter?5command?3?5?$AA@ DB 'Enter command: ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _exec_file
_TEXT	SEGMENT
_response$81696 = -2004					; size = 2000
__$ArrayPad$ = -4					; size = 4
_fd$ = 8						; size = 4
_name$ = 12						; size = 4
_exec_file PROC						; COMDAT

; 1039 : { int old_read_depth = read_depth;

	push	ebp
	mov	ebp, esp
	sub	esp, 2004				; 000007d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, DWORD PTR _name$[ebp]
	mov	eax, DWORD PTR _fd$[ebp]
	push	esi
	mov	esi, DWORD PTR _read_depth

; 1040 :   push_commandfd(fd,name);

	push	ecx
	push	eax
	call	_push_commandfd
	add	esp, 8
	npad	6
$LL5@exec_file:

; 1041 :   do  /* main event loop of program */
; 1042 :   {
; 1043 :     char response[2000];
; 1044 : 
; 1045 :     temp_free_all(); /* stray memory blocks */

	call	_temp_free_all

; 1046 :     free_discards(DISCARDS_SOME); /* from previous cycle */

	push	2
	call	_free_discards

; 1047 :     memset(response,0,sizeof(response));

	push	2000					; 000007d0H
	lea	eax, DWORD PTR _response$81696[ebp]
	push	0
	push	eax
	call	_memset

; 1048 :     if ( prompt("Enter command: ",response,sizeof(response)) == EOF ) 

	push	2000					; 000007d0H
	lea	ecx, DWORD PTR _response$81696[ebp]
	push	ecx
	push	OFFSET ??_C@_0BA@LDMPFPFF@Enter?5command?3?5?$AA@
	call	_prompt
	add	esp, 28					; 0000001cH
	cmp	eax, -1
	jne	SHORT $LN2@exec_file

; 1049 :       pop_commandfd();

	call	_pop_commandfd

; 1050 :     else 

	jmp	SHORT $LN4@exec_file
$LN2@exec_file:

; 1051 :       old_menu(response);

	lea	edx, DWORD PTR _response$81696[ebp]
	push	edx
	call	_old_menu
	add	esp, 4
$LN4@exec_file:

; 1052 :   }
; 1053 :   while ( read_depth > old_read_depth ); 

	cmp	DWORD PTR _read_depth, esi
	jg	SHORT $LL5@exec_file

; 1054 : } // end exec_file()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_exec_file ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DO@LJGKHFMC@Invalid?5datafile?4?5?5Surface?5may?5n@ ; `string'
PUBLIC	__real@4008000000000000
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_0BF@IEEOCDJK@Surface?5Evolver?5?9?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BK@OMAPGNOH@Cannot?5open?5datafile?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_04MKNBDEPB@exit?$AA@			; `string'
PUBLIC	??_C@_03MDONDFG@bye?$AA@			; `string'
PUBLIC	??_C@_04KNNLNNGO@quit?$AA@			; `string'
PUBLIC	??_C@_01IIACKFLH@q?$AA@				; `string'
PUBLIC	??_C@_0DI@EGCFACCM@Enter?5new?5datafile?5name?5?$CInone?5to@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_startup
EXTRN	_ask_wrap_display:PROC
EXTRN	_target_length:QWORD
EXTRN	_calc_energy:PROC
EXTRN	_calc_pressure:PROC
EXTRN	_fix_volconst:PROC
EXTRN	_calc_content:PROC
EXTRN	_update_display:PROC
EXTRN	_run_checks:PROC
EXTRN	_kb_error:PROC
EXTRN	_parse_errors:DWORD
EXTRN	_graph_new_surface:PROC
EXTRN	_resize:PROC
EXTRN	_overall_size:QWORD
EXTRN	_dont_resize_flag:DWORD
EXTRN	_view:DWORD
EXTRN	_datafile_view_flag:DWORD
EXTRN	_line_no:DWORD
EXTRN	_initialize:PROC
EXTRN	_cmdptr:DWORD
EXTRN	_datafile_input_flag:DWORD
EXTRN	_memory_report:PROC
EXTRN	_memdebug:DWORD
EXTRN	_init_view:PROC
EXTRN	_reset_web:PROC
EXTRN	__imp__SetConsoleTitleA@4:PROC
EXTRN	_console_title:BYTE
EXTRN	_datafilename:BYTE
EXTRN	_exit_after_error:DWORD
EXTRN	_erroutstring:PROC
EXTRN	_sprintf:PROC
EXTRN	_msg:DWORD
EXTRN	_path_open:PROC
EXTRN	_strchr:PROC
EXTRN	_fclose:PROC
EXTRN	_cmdfile_stack:BYTE
EXTRN	_cmdfilename:DWORD
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__MsgWaitForMultipleObjects@20:PROC
EXTRN	_graphmutex:DWORD
EXTRN	_locking_thread:DWORD
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_0DO@LJGKHFMC@Invalid?5datafile?4?5?5Surface?5may?5n@
CONST	SEGMENT
??_C@_0DO@LJGKHFMC@Invalid?5datafile?4?5?5Surface?5may?5n@ DB 'Invalid da'
	DB	'tafile.  Surface may not be in a consistent state.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0BF@IEEOCDJK@Surface?5Evolver?5?9?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BF@IEEOCDJK@Surface?5Evolver?5?9?5?$CFs?$AA@ DB 'Surface Evolver -'
	DB	' %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OMAPGNOH@Cannot?5open?5datafile?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@OMAPGNOH@Cannot?5open?5datafile?5?$CFs?4?6?$AA@ DB 'Cannot open'
	DB	' datafile %s.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKNBDEPB@exit?$AA@
CONST	SEGMENT
??_C@_04MKNBDEPB@exit?$AA@ DB 'exit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MDONDFG@bye?$AA@
CONST	SEGMENT
??_C@_03MDONDFG@bye?$AA@ DB 'bye', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KNNLNNGO@quit?$AA@
CONST	SEGMENT
??_C@_04KNNLNNGO@quit?$AA@ DB 'quit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01IIACKFLH@q?$AA@
CONST	SEGMENT
??_C@_01IIACKFLH@q?$AA@ DB 'q', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@EGCFACCM@Enter?5new?5datafile?5name?5?$CInone?5to@
CONST	SEGMENT
??_C@_0DI@EGCFACCM@Enter?5new?5datafile?5name?5?$CInone?5to@ DB 'Enter ne'
	DB	'w datafile name (none to continue, q to quit): ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _startup
_TEXT	SEGMENT
_newfd$ = -1008						; size = 4
_response$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_file_name$ = 8						; size = 4
_startup PROC						; COMDAT

; 1065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1008				; 000003f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi

; 1066 :   char *name = file_name;
; 1067 :   char response[1000];
; 1068 :   FILE *newfd = NULL;
; 1069 : 
; 1070 :   /* be sure graphics thread is ok before loading new file */
; 1071 :   ENTER_GRAPH_MUTEX;

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	push	edi
	mov	edi, DWORD PTR _file_name$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _newfd$[ebp], ebx
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN123@startup
	push	ebx
	push	100000					; 000186a0H
	push	ebx
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi

; 1072 :   LEAVE_GRAPH_MUTEX;

	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, ebx
	call	DWORD PTR __imp__ReleaseMutex@4
$LN123@startup:

; 1073 : 
; 1074 :   datafile_flag = 0;
; 1075 :   /* close leftover input files */
; 1076 :   for ( ; read_depth > (cmdfilename ? 2 : 1) ; read_depth-- ) 

	mov	eax, DWORD PTR _read_depth
	xor	ecx, ecx
	cmp	DWORD PTR _cmdfilename, ebx
	mov	DWORD PTR _datafile_flag, ebx
	setne	cl
	inc	ecx
	cmp	eax, ecx
	jle	SHORT $file_retry$81713
	npad	12
$LL40@startup:

; 1077 :       fclose(cmdfile_stack[read_depth-1].fd);

	imul	eax, 1016				; 000003f8H
	mov	edx, DWORD PTR _cmdfile_stack[eax-1016]
	push	edx
	call	_fclose
	mov	eax, DWORD PTR _read_depth
	dec	eax
	xor	ecx, ecx
	add	esp, 4
	cmp	DWORD PTR _cmdfilename, ebx
	mov	DWORD PTR _read_depth, eax
	setne	cl
	inc	ecx
	cmp	eax, ecx
	jg	SHORT $LL40@startup
$file_retry$81713:

; 1078 : 
; 1079 : file_retry:
; 1080 :   if ( name == NULL )

	cmp	edi, ebx
	jne	$LN37@startup

; 1081 :   { char *c;
; 1082 : #ifdef MPI_EVOLVER
; 1083 :     if ( this_task != MASTER_TASK )
; 1084 :        return; /* wait for master to get new name */
; 1085 : #endif
; 1086 :     prompt("Enter new datafile name (none to continue, q to quit): ",
; 1087 :        response,sizeof(response));

	push	1000					; 000003e8H
	lea	edx, DWORD PTR _response$[ebp]
	push	edx
	push	OFFSET ??_C@_0DI@EGCFACCM@Enter?5new?5datafile?5name?5?$CInone?5to@
	call	_prompt

; 1088 :     c = strchr(response,'\n');

	lea	eax, DWORD PTR _response$[ebp]
	push	10					; 0000000aH
	push	eax
	call	_strchr
	add	esp, 20					; 00000014H

; 1089 :     if ( c ) *c = 0;

	cmp	eax, ebx
	je	SHORT $LN36@startup
	mov	BYTE PTR [eax], bl
$LN36@startup:

; 1090 :     // strip quotes
; 1091 :     if ( response[0] == '"' )

	cmp	BYTE PTR _response$[ebp], 34		; 00000022H
	jne	SHORT $LN32@startup

; 1092 :     { for ( c = response+1 ; *c ; c++ )

	lea	eax, DWORD PTR _response$[ebp+1]
	cmp	BYTE PTR _response$[ebp+1], bl
	je	SHORT $LN32@startup
	npad	4
$LL125@startup:

; 1093 :       { if ( *c == '"' && c[-1] != '\\' )

	mov	cl, BYTE PTR [eax]
	cmp	cl, 34					; 00000022H
	jne	SHORT $LN31@startup
	cmp	BYTE PTR [eax-1], 92			; 0000005cH
	jne	SHORT $LN53@startup
$LN31@startup:

; 1095 :           break;
; 1096 :         }
; 1097 :         c[-1] = *c;

	mov	BYTE PTR [eax-1], cl
	inc	eax
	cmp	BYTE PTR [eax], bl
	jne	SHORT $LL125@startup

; 1121 :       if ( exit_after_error ) my_exit(1);

	jmp	SHORT $LN32@startup
$LN53@startup:

; 1094 :         { c[-1] = 0;

	mov	BYTE PTR [eax-1], bl
$LN32@startup:

; 1098 :       }
; 1099 :     }
; 1100 :     if ( (strcmp(response,"q") == 0) || (strcmp(response,"quit")==0)
; 1101 :            || (strcmp(response,"bye")==0) || (strcmp(response,"exit")==0))

	mov	ecx, OFFSET ??_C@_01IIACKFLH@q?$AA@
	lea	eax, DWORD PTR _response$[ebp]
$LL126@startup:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN100@startup
	cmp	dl, bl
	je	SHORT $LN101@startup
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN100@startup
	add	eax, 2
	add	ecx, 2
	cmp	dl, bl
	jne	SHORT $LL126@startup
$LN101@startup:
	xor	eax, eax
	jmp	SHORT $LN102@startup
$LN100@startup:
	sbb	eax, eax
	sbb	eax, -1
$LN102@startup:
	cmp	eax, ebx
	je	$LN29@startup
	mov	ecx, OFFSET ??_C@_04KNNLNNGO@quit?$AA@
	lea	eax, DWORD PTR _response$[ebp]
	npad	3
$LL127@startup:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN104@startup
	cmp	dl, bl
	je	SHORT $LN105@startup
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN104@startup
	add	eax, 2
	add	ecx, 2
	cmp	dl, bl
	jne	SHORT $LL127@startup
$LN105@startup:
	xor	eax, eax
	jmp	SHORT $LN106@startup
$LN104@startup:
	sbb	eax, eax
	sbb	eax, -1
$LN106@startup:
	cmp	eax, ebx
	je	$LN29@startup
	mov	ecx, OFFSET ??_C@_03MDONDFG@bye?$AA@
	lea	eax, DWORD PTR _response$[ebp]
$LL128@startup:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN108@startup
	cmp	dl, bl
	je	SHORT $LN109@startup
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN108@startup
	add	eax, 2
	add	ecx, 2
	cmp	dl, bl
	jne	SHORT $LL128@startup
$LN109@startup:
	xor	eax, eax
	jmp	SHORT $LN110@startup
$LN108@startup:
	sbb	eax, eax
	sbb	eax, -1
$LN110@startup:
	cmp	eax, ebx
	je	$LN29@startup
	mov	ecx, OFFSET ??_C@_04MKNBDEPB@exit?$AA@
	lea	eax, DWORD PTR _response$[ebp]
$LL129@startup:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN112@startup
	cmp	dl, bl
	je	SHORT $LN113@startup
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN112@startup
	add	eax, 2
	add	ecx, 2
	cmp	dl, bl
	jne	SHORT $LL129@startup
$LN113@startup:
	xor	eax, eax
	jmp	SHORT $LN114@startup
$LN112@startup:
	sbb	eax, eax
	sbb	eax, -1
$LN114@startup:
	cmp	eax, ebx
	je	$LN29@startup

; 1103 :     else if ( !response[0] ) 

	cmp	BYTE PTR _response$[ebp], bl
	je	$LN55@startup

; 1108 :     }
; 1109 :     name = response;

	lea	edi, DWORD PTR _response$[ebp]
$LN37@startup:

; 1110 : #ifdef MPI_EVOLVER
; 1111 : 	strcpy(loadfilename,name);
; 1112 : 	mpi_loadfile();
; 1113 : #endif
; 1114 :   }
; 1115 :   newfd = path_open(name,SETDATAFILENAME);

	push	1
	push	edi
	call	_path_open
	add	esp, 8
	mov	DWORD PTR _newfd$[ebp], eax

; 1116 :   if (newfd == NULL)

	cmp	eax, ebx
	jne	$LN24@startup

; 1117 :   { if ( name[0] )

	cmp	BYTE PTR [edi], bl
	je	$LN1@startup

; 1118 :     { 
; 1119 : 	  sprintf(msg,"Cannot open datafile %s.\n",name);

	mov	ecx, DWORD PTR _msg
	push	edi
	push	OFFSET ??_C@_0BK@OMAPGNOH@Cannot?5open?5datafile?5?$CFs?4?6?$AA@
	push	ecx
	call	_sprintf

; 1120 :       erroutstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_erroutstring
	add	esp, 16					; 00000010H

; 1121 :       if ( exit_after_error ) my_exit(1);

	cmp	DWORD PTR _exit_after_error, ebx
	jne	SHORT $LN56@startup

; 1122 :       name = NULL;
; 1123 :       while ( read_depth > (cmdfilename ? 2 : 1)  ) pop_commandfd(); 

	xor	eax, eax
	xor	edi, edi
	cmp	DWORD PTR _cmdfilename, ebx
	setne	al
	inc	eax
	cmp	DWORD PTR _read_depth, eax
	jle	$file_retry$81713
$LL21@startup:
	call	_pop_commandfd
	xor	ecx, ecx
	cmp	DWORD PTR _cmdfilename, ebx
	setne	cl
	inc	ecx
	cmp	DWORD PTR _read_depth, ecx
	jg	SHORT $LL21@startup

; 1124 :       goto file_retry;

	jmp	$file_retry$81713
$LN55@startup:

; 1104 :     { if ( datafilename[0] ) 

	cmp	BYTE PTR _datafilename, bl
	jne	$LN1@startup

; 1105 :         return; /* continue same */
; 1106 :       else
; 1107 :         goto emptybailout;

	jmp	SHORT $emptybailout$81734
$LN29@startup:

; 1102 :              my_exit(0);

	push	ebx
	call	_my_exit
$LN133@startup:
$LN56@startup:

; 1121 :       if ( exit_after_error ) my_exit(1);

	push	1
	call	_my_exit
$LN134@startup:
$LN24@startup:

; 1125 :     }
; 1126 :     return; /* continue with old */
; 1127 :   }
; 1128 : 
; 1129 : #ifdef WIN32
; 1130 : #ifdef MPI_EVOLVER
; 1131 :   sprintf(console_title,"Surface Evolver MPI - %s",name);
; 1132 : #else
; 1133 :   sprintf(console_title,"Surface Evolver - %s",name);

	push	edi
	push	OFFSET ??_C@_0BF@IEEOCDJK@Surface?5Evolver?5?9?5?$CFs?$AA@
	push	OFFSET _console_title
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1134 : #endif
; 1135 :   SetConsoleTitleA(console_title);

	push	OFFSET _console_title
	call	DWORD PTR __imp__SetConsoleTitleA@4
$emptybailout$81734:

; 1136 : #endif
; 1137 : 
; 1138 : emptybailout:
; 1139 : 
; 1140 :   ENTER_GRAPH_MUTEX;

	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN19@startup
	push	ebx
	push	100000					; 000186a0H
	push	ebx
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	esi, 1
	jmp	SHORT $LN18@startup
$LN19@startup:
	xor	esi, esi
$LN18@startup:

; 1141 : 
; 1142 :   reset_web(); 

	call	_reset_web

; 1143 : 
; 1144 :   init_view();

	call	_init_view

; 1145 : 
; 1146 : if (memdebug) memory_report();

	cmp	DWORD PTR _memdebug, ebx
	je	SHORT $LN17@startup
	call	_memory_report
$LN17@startup:

; 1147 : 
; 1148 :   push_commandfd(newfd,name); /* start #include stack */

	push	edi
	mov	edi, DWORD PTR _newfd$[ebp]
	push	edi
	call	_push_commandfd

; 1149 : 
; 1150 : #ifdef __WIN32__
; 1151 : if ( heapcheck() < 0 )
; 1152 :   kb_error(1324,"Internal error: Corrupt heap.\n",UNRECOVERABLE);
; 1153 : 
; 1154 : #endif
; 1155 : 
; 1156 :   datafile_flag = 1;  /* so parser knows */

	mov	eax, 1
	add	esp, 8
	mov	DWORD PTR _datafile_flag, eax

; 1157 :   datafile_input_flag = 1;  /* so lex input knows */

	mov	DWORD PTR _datafile_input_flag, eax

; 1158 :   cmdptr = 0;

	mov	DWORD PTR _cmdptr, ebx

; 1159 : 
; 1160 :   if ( newfd ) 

	cmp	edi, ebx
	je	SHORT $LN16@startup

; 1161 :     initialize();

	call	_initialize
$LN16@startup:

; 1162 :   LEAVE_GRAPH_MUTEX;

	cmp	esi, ebx
	je	SHORT $LN15@startup
	mov	edx, DWORD PTR _graphmutex
	push	edx
	mov	DWORD PTR _locking_thread, ebx
	call	DWORD PTR __imp__ReleaseMutex@4
$LN15@startup:

; 1163 : 
; 1164 :   datafile_flag = 0;
; 1165 :   if ( read_depth > 0 )

	mov	eax, DWORD PTR _read_depth
	mov	DWORD PTR _datafile_flag, ebx
	cmp	eax, ebx
	jle	SHORT $LN14@startup

; 1166 :         cmdfile_stack[read_depth-1].line = line_no;

	mov	ecx, DWORD PTR _line_no
	imul	eax, 1016				; 000003f8H
	mov	DWORD PTR _cmdfile_stack[eax-12], ecx
$LN14@startup:

; 1167 : 
; 1168 :   if ( datafile_view_flag )

	cmp	DWORD PTR _datafile_view_flag, ebx
	je	SHORT $LN13@startup

; 1169 :   { int i,j;
; 1170 :     REAL sum; 
; 1171 : 
; 1172 :     for ( sum = 0.0, i = 0 ; i < 3 ; i++ )
; 1173 :       for ( j = 0 ; j < 3 ; j++ ) sum += fabs(view[i][j]);

	mov	ecx, DWORD PTR _view
	mov	eax, DWORD PTR [ecx]
	fld	QWORD PTR [eax+8]
	fabs
	fld	QWORD PTR [eax]
	fabs
	fadd	QWORD PTR __real@0000000000000000
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax+16]
	mov	eax, DWORD PTR [ecx+4]
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax+8]
	fabs
	fld	QWORD PTR [eax]
	fabs
	faddp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax+16]
	mov	eax, DWORD PTR [ecx+8]
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax+8]
	fabs
	fld	QWORD PTR [eax]
	fabs
	faddp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax+16]

; 1174 :     overall_size = 3/sum;
; 1175 :     dont_resize_flag = 1;

	mov	DWORD PTR _dont_resize_flag, 1
	fabs
	faddp	ST(1), ST(0)
	fdivr	QWORD PTR __real@4008000000000000
	fstp	QWORD PTR _overall_size

; 1176 :   }
; 1177 :   else

	jmp	SHORT $LN6@startup
$LN13@startup:

; 1178 :   { 
; 1179 :     resize(); 

	call	_resize
$LN6@startup:

; 1180 :   }
; 1181 :   graph_new_surface(); /* tell graphics we have new one */

	call	_graph_new_surface

; 1182 : 
; 1183 :   if ( parse_errors ) 

	cmp	DWORD PTR _parse_errors, ebx
	je	SHORT $LN5@startup

; 1184 :   { while ( (read_depth > 1) ) pop_commandfd();

	mov	esi, 1
	cmp	DWORD PTR _read_depth, esi
	jle	SHORT $LN3@startup
$LL4@startup:
	call	_pop_commandfd
	cmp	DWORD PTR _read_depth, esi
	jg	SHORT $LL4@startup
$LN3@startup:

; 1185 :      kb_error(1325,"Invalid datafile.  Surface may not be in a consistent state.\n",RECOVERABLE);

	push	esi
	push	OFFSET ??_C@_0DO@LJGKHFMC@Invalid?5datafile?4?5?5Surface?5may?5n@
	push	1325					; 0000052dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN5@startup:

; 1186 :   }
; 1187 : 
; 1188 :   run_checks();

	call	_run_checks

; 1189 :   update_display();

	call	_update_display

; 1190 :   
; 1191 :   #ifndef MPI_EVOLVER
; 1192 :   calc_content(Q_ENERGY|Q_FIXED|Q_INFO|Q_RENORMALIZE);

	push	39					; 00000027H
	call	_calc_content
	fstp	ST(0)
	add	esp, 4

; 1193 :   if ( web.torus_flag ) fix_volconst();

	cmp	DWORD PTR _web+860, ebx
	je	SHORT $LN2@startup
	call	_fix_volconst
$LN2@startup:

; 1194 :   calc_pressure();

	call	_calc_pressure

; 1195 :   calc_energy();  /* just to get initial total area */

	call	_calc_energy

; 1196 :   target_length = web.total_area; /* for square curvature string model */

	fld	QWORD PTR _web+992
	fstp	QWORD PTR _target_length

; 1197 :   if ( OOGL_flag ) ask_wrap_display();

	cmp	DWORD PTR _OOGL_flag, ebx
	je	SHORT $LN1@startup
	call	_ask_wrap_display
$LN1@startup:

; 1198 :   #endif 
; 1199 : } // end startup()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN132@startup:
_startup ENDP
_TEXT	ENDS
PUBLIC	_pcomp
; Function compile flags: /Ogtp
;	COMDAT _pcomp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_pcomp	PROC						; COMDAT

; 1380 : {

	push	ebp
	mov	ebp, esp

; 1381 :   if ( a->p_coord < b->p_coord ) return -1;

	mov	ecx, DWORD PTR _b$[ebp]
	fld	QWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@pcomp
	or	eax, -1

; 1384 : } // end pcomp()

	pop	ebp
	ret	0
$LN2@pcomp:

; 1382 :   if ( a->p_coord > b->p_coord ) return  1;

	fld	QWORD PTR [ecx]
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@pcomp
	mov	eax, 1

; 1384 : } // end pcomp()

	pop	ebp
	ret	0
$LN1@pcomp:

; 1383 :   return 0;

	xor	eax, eax

; 1384 : } // end pcomp()

	pop	ebp
	ret	0
_pcomp	ENDP
_TEXT	ENDS
PUBLIC	??_C@_07KINGIIKE@tmain?4c?$AA@			; `string'
PUBLIC	??_C@_0DL@JGGAIHII@Vertex?5?$CFs?5v_partition_stage?5?$CFd?5e@ ; `string'
PUBLIC	??_C@_0DL@DKOILONO@Illegal?5negative?5value?5of?5vertex@ ; `string'
PUBLIC	??_C@_0DM@MCGEEHMJ@Vertex?5?$CFs?5v_partition_proc?5?$CFd?5ex@ ; `string'
PUBLIC	??_C@_0DK@KOKCGJDK@Illegal?5negative?5value?5of?5vertex@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	_make_thread_lists
EXTRN	_partition_timestamp:DWORD
EXTRN	_global_timestamp:DWORD
EXTRN	_f_partition_stage_attr:DWORD
EXTRN	_f_partition_proc_attr:DWORD
EXTRN	_e_partition_stage_attr:DWORD
EXTRN	_e_partition_proc_attr:DWORD
EXTRN	_KB_realloc:PROC
EXTRN	_errmsg:BYTE
EXTRN	_elnames:BYTE
EXTRN	_v_partition_stage_attr:DWORD
EXTRN	_v_partition_proc_attr:DWORD
EXTRN	_max_thread_stages:DWORD
EXTRN	_thread_stages:DWORD
EXTRN	_nprocs:DWORD
;	COMDAT ??_C@_07KINGIIKE@tmain?4c?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_07KINGIIKE@tmain?4c?$AA@ DB 'tmain.c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@JGGAIHII@Vertex?5?$CFs?5v_partition_stage?5?$CFd?5e@
CONST	SEGMENT
??_C@_0DL@JGGAIHII@Vertex?5?$CFs?5v_partition_stage?5?$CFd?5e@ DB 'Vertex'
	DB	' %s v_partition_stage %d exceeds allowed maximum %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@DKOILONO@Illegal?5negative?5value?5of?5vertex@
CONST	SEGMENT
??_C@_0DL@DKOILONO@Illegal?5negative?5value?5of?5vertex@ DB 'Illegal nega'
	DB	'tive value of vertex %s v_partition_stage: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@MCGEEHMJ@Vertex?5?$CFs?5v_partition_proc?5?$CFd?5ex@
CONST	SEGMENT
??_C@_0DM@MCGEEHMJ@Vertex?5?$CFs?5v_partition_proc?5?$CFd?5ex@ DB 'Vertex'
	DB	' %s v_partition_proc %d exceeds number of threads %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@KOKCGJDK@Illegal?5negative?5value?5of?5vertex@
CONST	SEGMENT
??_C@_0DK@KOKCGJDK@Illegal?5negative?5value?5of?5vertex@ DB 'Illegal nega'
	DB	'tive value of vertex %s v_partition_proc: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\tmain.c
CONST	ENDS
;	COMDAT _make_thread_lists
_TEXT	SEGMENT
tv1710 = -36						; size = 4
tv1688 = -36						; size = 4
tv1513 = -32						; size = 4
tv1391 = -32						; size = 4
_f_id$ = -32						; size = 4
tv1645 = -28						; size = 4
tv1421 = -24						; size = 4
_e_id$ = -24						; size = 4
_topband$81927 = -20					; size = 4
_tproc$81888 = -20					; size = 4
_v_id$ = -20						; size = 4
tv1408 = -16						; size = 4
_lowband$81928 = -16					; size = 4
_hproc$81886 = -16					; size = 4
tv1493 = -12						; size = 4
tv1389 = -12						; size = 4
_hstage$81890 = -12					; size = 4
tv1667 = -8						; size = 4
tv1478 = -8						; size = 4
_fe$81926 = -4						; size = 4
_proc$ = -4						; size = 4
_make_thread_lists PROC					; COMDAT

; 1395 : { int i,proc,stage;

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx

; 1396 :   vertex_id v_id;
; 1397 :   edge_id e_id;
; 1398 :   facet_id f_id;
; 1399 :   struct thread_stages_data *th;
; 1400 : 
; 1401 :    for ( proc = 0 ; proc < nprocs ; proc++ )

	xor	edx, edx
	push	esi
	push	edi
	cmp	DWORD PTR _nprocs, edx
	jle	SHORT $LN56@make_threa
	mov	esi, 180				; 000000b4H
	npad	8
$LL58@make_threa:

; 1402 :     for ( stage = 0 ; stage < MAXTHREADSTAGES ; stage++ )

	mov	eax, esi
	mov	ecx, 9
	npad	9
$LL55@make_threa:

; 1403 :       thread_stages[proc].counts[VERTEX][stage] = 0;

	mov	edi, DWORD PTR _thread_stages
	mov	DWORD PTR [eax+edi], 0
	add	eax, 4
	dec	ecx
	jne	SHORT $LL55@make_threa

; 1396 :   vertex_id v_id;
; 1397 :   edge_id e_id;
; 1398 :   facet_id f_id;
; 1399 :   struct thread_stages_data *th;
; 1400 : 
; 1401 :    for ( proc = 0 ; proc < nprocs ; proc++ )

	inc	edx
	add	esi, 548				; 00000224H
	cmp	edx, DWORD PTR _nprocs
	jl	SHORT $LL58@make_threa
$LN56@make_threa:

; 1404 : 
; 1405 :    max_thread_stages = 0;
; 1406 : 
; 1407 :    FOR_ALL_VERTICES(v_id) 

	mov	ebx, DWORD PTR _web+48
	mov	edx, ebx
	xor	ecx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	DWORD PTR _max_thread_stages, ecx
	mov	DWORD PTR _v_id$[ebp], ebx
	mov	DWORD PTR tv1389[ebp], edx
	je	$LN50@make_threa
	mov	edi, DWORD PTR _web+12
	npad	6
$LL52@make_threa:
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv1391[ebp], ebx
	je	$LN51@make_threa

; 1408 :    { proc = *(int*)get_extra(v_id,v_partition_proc_attr);

	mov	eax, DWORD PTR _v_id$[ebp]
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	esi, DWORD PTR _web[eax+12]
	mov	esi, DWORD PTR [esi+ebx*4]
	mov	eax, DWORD PTR _web[eax+104]
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR tv1408[ebp], esi
	mov	esi, DWORD PTR _v_partition_proc_attr
	imul	esi, 240				; 000000f0H
	add	esi, eax
	mov	esi, DWORD PTR [esi+edi+64]
	mov	edi, DWORD PTR tv1408[ebp]
	mov	esi, DWORD PTR [edi+esi]

; 1409 :      stage = *(int*)get_extra(v_id,v_partition_stage_attr);

	mov	edi, DWORD PTR _v_partition_stage_attr
	imul	edi, 240				; 000000f0H
	add	edi, eax
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edi+eax+64]
	mov	edi, DWORD PTR tv1408[ebp]
	mov	edi, DWORD PTR [edi+eax]

; 1410 :      if ( proc < 0 )

	test	esi, esi
	jns	SHORT $LN47@make_threa

; 1411 :      { sprintf(errmsg,"Illegal negative value of vertex %s v_partition_proc: %d\n",
; 1412 :           ELNAME(v_id),proc);

	test	edx, edx
	je	SHORT $LN61@make_threa
	lea	ecx, DWORD PTR [ebx+1]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN62@make_threa
$LN61@make_threa:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN62@make_threa:
	push	esi
	push	eax
	push	OFFSET ??_C@_0DK@KOKCGJDK@Illegal?5negative?5value?5of?5vertex@
	push	OFFSET _errmsg
	call	_sprintf

; 1413 :        kb_error(5991,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5991					; 00001767H
	call	_kb_error
	mov	ecx, DWORD PTR _max_thread_stages
	mov	edx, DWORD PTR tv1389[ebp]
	add	esp, 28					; 0000001cH
$LN47@make_threa:

; 1414 :      }
; 1415 :      if ( proc >= nprocs )

	cmp	esi, DWORD PTR _nprocs
	jl	SHORT $LN46@make_threa

; 1416 :      { sprintf(errmsg,"Vertex %s v_partition_proc %d exceeds number of threads %d\n",
; 1417 :           ELNAME(v_id),proc,nprocs);

	test	edx, edx
	je	SHORT $LN63@make_threa
	lea	edx, DWORD PTR [ebx+1]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN64@make_threa
$LN63@make_threa:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN64@make_threa:
	mov	ecx, DWORD PTR _nprocs
	push	ecx
	push	esi
	push	eax
	push	OFFSET ??_C@_0DM@MCGEEHMJ@Vertex?5?$CFs?5v_partition_proc?5?$CFd?5ex@
	push	OFFSET _errmsg
	call	_sprintf

; 1418 :        kb_error(5992,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5992					; 00001768H
	call	_kb_error
	mov	ecx, DWORD PTR _max_thread_stages
	mov	edx, DWORD PTR tv1389[ebp]
	add	esp, 32					; 00000020H
$LN46@make_threa:

; 1419 :      }
; 1420 :      if ( stage < 0 )

	test	edi, edi
	jns	SHORT $LN45@make_threa

; 1421 :      { sprintf(errmsg,"Illegal negative value of vertex %s v_partition_stage: %d\n",
; 1422 :           ELNAME(v_id),stage);

	test	edx, edx
	je	SHORT $LN65@make_threa
	lea	edx, DWORD PTR [ebx+1]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN66@make_threa
$LN65@make_threa:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN66@make_threa:
	push	edi
	push	eax
	push	OFFSET ??_C@_0DL@DKOILONO@Illegal?5negative?5value?5of?5vertex@
	push	OFFSET _errmsg
	call	_sprintf

; 1423 :        kb_error(5993,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5993					; 00001769H
	call	_kb_error
	mov	ecx, DWORD PTR _max_thread_stages
	mov	edx, DWORD PTR tv1389[ebp]
	add	esp, 28					; 0000001cH
$LN45@make_threa:

; 1424 :      }
; 1425 :      if ( stage >= MAXTHREADSTAGES )

	cmp	edi, 9
	jl	SHORT $LN44@make_threa

; 1426 :      { sprintf(errmsg,"Vertex %s v_partition_stage %d exceeds allowed maximum %d\n",
; 1427 :           ELNAME(v_id),proc,MAXTHREADSTAGES-1);

	test	edx, edx
	je	SHORT $LN67@make_threa
	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN68@make_threa
$LN67@make_threa:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN68@make_threa:
	push	8
	push	esi
	push	eax
	push	OFFSET ??_C@_0DL@JGGAIHII@Vertex?5?$CFs?5v_partition_stage?5?$CFd?5e@
	push	OFFSET _errmsg
	call	_sprintf

; 1428 :        kb_error(5994,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5994					; 0000176aH
	call	_kb_error
	mov	ecx, DWORD PTR _max_thread_stages
	add	esp, 32					; 00000020H
$LN44@make_threa:

; 1429 :      }
; 1430 :      if ( stage >= max_thread_stages )

	cmp	edi, ecx
	jl	SHORT $LN43@make_threa

; 1431 :        max_thread_stages = stage+1;

	lea	ecx, DWORD PTR [edi+1]
	mov	DWORD PTR _max_thread_stages, ecx
$LN43@make_threa:

; 1432 : 
; 1433 :      th = thread_stages+proc;

	imul	esi, 548				; 00000224H
	add	esi, DWORD PTR _thread_stages

; 1434 :      if ( th->counts[VERTEX][stage] >= th->allocated[VERTEX][stage] )

	mov	eax, DWORD PTR [esi+edi*4+360]
	cmp	DWORD PTR [esi+edi*4+180], eax
	jl	SHORT $LN42@make_threa

; 1435 :      { int newalloc = th->allocated[VERTEX][stage] + 10
; 1436 :                  + 2*web.skel[VERTEX].count/(nprocs*max_thread_stages);

	imul	ecx, DWORD PTR _nprocs
	mov	eax, DWORD PTR _web+64
	add	eax, eax
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR [esi+edi*4+360]

; 1437 :        th->blocks[VERTEX][stage] = (element_id *)kb_realloc(
; 1438 :             (char*)(th->blocks[VERTEX][stage]),newalloc*sizeof(element_id));

	mov	edx, DWORD PTR [esi+edi*4]
	push	1438					; 0000059eH
	push	OFFSET ??_C@_07KINGIIKE@tmain?4c?$AA@
	lea	ebx, DWORD PTR [eax+ecx+10]
	lea	ecx, DWORD PTR [ebx*4]
	push	ecx
	push	edx
	call	_KB_realloc

; 1439 :        th->allocated[VERTEX][stage] = newalloc;

	mov	DWORD PTR [esi+edi*4+360], ebx
	mov	ebx, DWORD PTR tv1391[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+edi*4], eax
$LN42@make_threa:

; 1440 :      }
; 1441 :      th->blocks[VERTEX][stage][th->counts[VERTEX][stage]++] = v_id;

	mov	eax, DWORD PTR [esi+edi*4+180]
	mov	ecx, DWORD PTR [esi+edi*4]
	mov	edx, DWORD PTR _v_id$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	inc	DWORD PTR [esi+edi*4+180]
	mov	ecx, DWORD PTR _max_thread_stages
	mov	edi, DWORD PTR _web+12
$LN51@make_threa:

; 1404 : 
; 1405 :    max_thread_stages = 0;
; 1406 : 
; 1407 :    FOR_ALL_VERTICES(v_id) 

	mov	eax, DWORD PTR [edi+ebx*4]
	mov	ebx, DWORD PTR [eax]
	mov	edx, ebx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	DWORD PTR _v_id$[ebp], ebx
	mov	DWORD PTR tv1389[ebp], edx
	jne	$LL52@make_threa
$LN50@make_threa:

; 1442 :    }
; 1443 : 
; 1444 :    for ( proc = 0 ; proc < nprocs ; proc++ )

	xor	esi, esi
	cmp	DWORD PTR _nprocs, esi
	jle	SHORT $LN39@make_threa
	mov	edi, 216				; 000000d8H
$LL41@make_threa:

; 1445 :     for ( stage = 0 ; stage < max_thread_stages ; stage++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN40@make_threa
	mov	edx, edi
$LL38@make_threa:

; 1446 :       thread_stages[proc].counts[EDGE][stage] = 0;

	mov	ecx, DWORD PTR _thread_stages
	mov	DWORD PTR [edx+ecx], 0
	mov	ecx, DWORD PTR _max_thread_stages
	inc	eax
	add	edx, 4
	cmp	eax, ecx
	jl	SHORT $LL38@make_threa
$LN40@make_threa:

; 1442 :    }
; 1443 : 
; 1444 :    for ( proc = 0 ; proc < nprocs ; proc++ )

	inc	esi
	add	edi, 548				; 00000224H
	cmp	esi, DWORD PTR _nprocs
	jl	SHORT $LL41@make_threa
$LN39@make_threa:

; 1447 :    thread_stages[0].counts[EDGE][max_thread_stages] = 0;

	mov	edx, DWORD PTR _thread_stages
	mov	DWORD PTR [edx+ecx*4+216], 0

; 1448 : 
; 1449 :    FOR_ALL_EDGES(e_id) 

	mov	esi, DWORD PTR _web+160
	mov	DWORD PTR _e_id$[ebp], esi
	test	esi, 268435456				; 10000000H
	je	$LN33@make_threa
	mov	ebx, DWORD PTR _web+124
$LL35@make_threa:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [ecx+ebx]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	mov	DWORD PTR tv1478[ebp], ecx
	je	$LN34@make_threa

; 1450 :    { vertex_id head = get_edge_headv(e_id); 

	mov	eax, DWORD PTR _web+216
	mov	ebx, DWORD PTR _web+636
	mov	edi, esi
	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+esi+304]
	shr	edi, 27					; 0000001bH
	and	edi, 1
	je	SHORT $LN74@make_threa
	mov	ecx, DWORD PTR [eax+edx]
	add	eax, edx
	jmp	SHORT $LN73@make_threa
$LN74@make_threa:
	add	eax, edx
	mov	ecx, DWORD PTR [eax+ebx*4]
$LN73@make_threa:

; 1451 :      vertex_id tail = get_edge_tailv(e_id); 

	test	edi, edi
	je	SHORT $LN78@make_threa
	mov	edi, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN77@make_threa
$LN78@make_threa:
	mov	edi, DWORD PTR [eax]
$LN77@make_threa:

; 1452 :      int hproc = *(int*)get_extra(head,v_partition_proc_attr);

	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _v_partition_proc_attr
	imul	edx, 240				; 000000f0H
	mov	DWORD PTR tv1513[ebp], eax
	add	eax, edx
	mov	eax, DWORD PTR [eax+esi+64]
	mov	ecx, DWORD PTR [ebx+eax]
	mov	DWORD PTR _hproc$81886[ebp], ecx

; 1453 :      int tproc = *(int*)get_extra(tail,v_partition_proc_attr);

	mov	ecx, edi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _web[ecx+104]
	add	edx, ecx
	mov	edx, DWORD PTR [edx+esi+64]
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edi*4]
	mov	edx, DWORD PTR [eax+edx]

; 1454 :      int hstage = *(int*)get_extra(head,v_partition_stage_attr);

	mov	edi, DWORD PTR tv1513[ebp]
	mov	DWORD PTR _tproc$81888[ebp], edx
	mov	edx, DWORD PTR _v_partition_stage_attr
	imul	edx, 240				; 000000f0H
	add	edi, edx
	mov	edi, DWORD PTR [edi+esi+64]
	mov	edi, DWORD PTR [ebx+edi]

; 1455 :      int tstage = *(int*)get_extra(tail,v_partition_stage_attr);
; 1456 :      int hband = hstage + max_thread_stages*hproc;

	mov	ebx, DWORD PTR _max_thread_stages
	add	ecx, edx
	mov	ecx, DWORD PTR [ecx+esi+64]
	mov	DWORD PTR _hstage$81890[ebp], edi
	mov	edi, DWORD PTR [eax+ecx]
	mov	esi, ebx
	imul	esi, DWORD PTR _hproc$81886[ebp]
	add	esi, DWORD PTR _hstage$81890[ebp]

; 1457 :      int tband = tstage + max_thread_stages*tproc;

	mov	ecx, ebx
	imul	ecx, DWORD PTR _tproc$81888[ebp]
	add	ecx, edi

; 1458 :      if ( abs(hband-tband) <= 1 )

	mov	eax, esi
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 1
	mov	eax, DWORD PTR _nprocs
	jg	SHORT $LN30@make_threa

; 1459 :      { if ( hband < tband ) { proc = hproc; stage = hstage; } 

	cmp	esi, ecx
	jge	SHORT $LN29@make_threa
	mov	edx, DWORD PTR _hproc$81886[ebp]
	mov	esi, DWORD PTR _hstage$81890[ebp]
	mov	DWORD PTR _proc$[ebp], edx
	jmp	SHORT $LN23@make_threa
$LN30@make_threa:

; 1460 :        else { proc = tproc; stage = tstage;}
; 1461 :      }
; 1462 :      else if ( web.symmetry_flag && (hband == 0) && 
; 1463 :                 (tband == nprocs*max_thread_stages-1 ) )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN160@make_threa
	test	esi, esi
	jne	SHORT $LN159@make_threa
	mov	edx, ebx
	imul	edx, eax
	dec	edx
	cmp	ecx, edx
	jne	SHORT $LN159@make_threa
$LN29@make_threa:

; 1464 :        { proc = tproc; stage = tstage;}

	mov	ecx, DWORD PTR _tproc$81888[ebp]
	mov	DWORD PTR _proc$[ebp], ecx
	mov	esi, edi

; 1465 :      else if ( web.symmetry_flag && (tband == 0) && 

	jmp	SHORT $LN23@make_threa
$LN159@make_threa:

; 1466 :                 (hband == nprocs*max_thread_stages-1 ) )

	test	ecx, ecx
	jne	SHORT $LN160@make_threa
	mov	edx, ebx
	imul	edx, eax
	dec	edx
	cmp	esi, edx
	jne	SHORT $LN160@make_threa

; 1467 :        { proc = hproc; stage = hstage;}

	mov	ecx, DWORD PTR _hproc$81886[ebp]
	mov	esi, DWORD PTR _hstage$81890[ebp]
	mov	DWORD PTR _proc$[ebp], ecx

; 1468 :      else /* big element */

	jmp	SHORT $LN23@make_threa
$LN160@make_threa:

; 1469 :        { proc = 0; stage = max_thread_stages; }

	mov	DWORD PTR _proc$[ebp], 0
	mov	esi, ebx
$LN23@make_threa:

; 1470 : 
; 1471 :      th = thread_stages+proc;

	mov	edi, DWORD PTR _proc$[ebp]
	imul	edi, 548				; 00000224H
	add	edi, DWORD PTR _thread_stages

; 1472 :      if ( th->counts[EDGE][stage] >= th->allocated[EDGE][stage] )

	mov	ecx, DWORD PTR [edi+esi*4+396]
	cmp	DWORD PTR [edi+esi*4+216], ecx
	jl	SHORT $LN22@make_threa

; 1473 :      { int newalloc = th->allocated[EDGE][stage] + 10
; 1474 :                  + 2*web.skel[EDGE].count/(nprocs*max_thread_stages);

	imul	ebx, eax
	mov	eax, DWORD PTR _web+176
	add	eax, eax
	cdq
	idiv	ebx

; 1475 :        th->blocks[EDGE][stage] = (element_id *)kb_realloc(
; 1476 :             (char*)(th->blocks[EDGE][stage]),newalloc*sizeof(element_id));

	push	1476					; 000005c4H
	push	OFFSET ??_C@_07KINGIIKE@tmain?4c?$AA@
	lea	ebx, DWORD PTR [eax+ecx+10]
	mov	eax, DWORD PTR [edi+esi*4+36]
	lea	edx, DWORD PTR [ebx*4]
	push	edx
	push	eax
	call	_KB_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi+esi*4+36], eax

; 1477 :        th->allocated[EDGE][stage] = newalloc;

	mov	DWORD PTR [edi+esi*4+396], ebx
$LN22@make_threa:

; 1478 :      }
; 1479 :      th->blocks[EDGE][stage][th->counts[EDGE][stage]++] = e_id;

	mov	ecx, DWORD PTR [edi+esi*4+216]
	mov	edx, DWORD PTR [edi+esi*4+36]
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	inc	DWORD PTR [edi+esi*4+216]

; 1480 :      *((int *)(get_extra(e_id,e_partition_proc_attr))) = proc;

	mov	ecx, DWORD PTR _e_partition_proc_attr
	mov	edi, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	mov	ebx, DWORD PTR _proc$[ebp]
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	add	ecx, DWORD PTR _web[eax+104]
	mov	edx, DWORD PTR _web[eax+12]
	mov	edi, DWORD PTR [ecx+edi+64]
	mov	ecx, DWORD PTR tv1478[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [edi+edx], ebx

; 1481 :      *((int *)(get_extra(e_id,e_partition_stage_attr))) = stage;

	mov	edx, DWORD PTR _e_partition_stage_attr
	mov	edi, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	mov	edx, DWORD PTR [edx+edi+64]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR [edx+eax], esi
	mov	ebx, DWORD PTR _web+124
$LN34@make_threa:

; 1448 : 
; 1449 :    FOR_ALL_EDGES(e_id) 

	mov	ecx, DWORD PTR [ecx+ebx]
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR _e_id$[ebp], esi
	test	esi, 268435456				; 10000000H
	jne	$LL35@make_threa
$LN33@make_threa:

; 1482 :    }
; 1483 :    thread_stages[0].counts[VERTEX][max_thread_stages] = 0;

	mov	edx, DWORD PTR _thread_stages
	mov	eax, DWORD PTR _max_thread_stages
	xor	esi, esi
	mov	DWORD PTR [edx+eax*4+180], esi
	mov	edx, DWORD PTR _max_thread_stages

; 1484 : 
; 1485 :    for ( proc = 0 ; proc < nprocs ; proc++ )

	cmp	DWORD PTR _nprocs, esi
	jle	SHORT $LN19@make_threa

; 1482 :    }
; 1483 :    thread_stages[0].counts[VERTEX][max_thread_stages] = 0;

	mov	edi, 252				; 000000fcH
$LL21@make_threa:

; 1486 :     for ( stage = 0 ; stage < max_thread_stages ; stage++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN20@make_threa
	mov	ecx, edi
	npad	7
$LL18@make_threa:

; 1487 :       thread_stages[proc].counts[FACET][stage] = 0;

	mov	edx, DWORD PTR _thread_stages
	mov	DWORD PTR [ecx+edx], 0
	mov	edx, DWORD PTR _max_thread_stages
	inc	eax
	add	ecx, 4
	cmp	eax, edx
	jl	SHORT $LL18@make_threa
$LN20@make_threa:

; 1484 : 
; 1485 :    for ( proc = 0 ; proc < nprocs ; proc++ )

	inc	esi
	add	edi, 548				; 00000224H
	cmp	esi, DWORD PTR _nprocs
	jl	SHORT $LL21@make_threa
$LN19@make_threa:

; 1488 :    thread_stages[0].counts[FACET][max_thread_stages] = 0;

	mov	eax, DWORD PTR _thread_stages
	mov	DWORD PTR [eax+edx*4+252], 0

; 1489 : 
; 1490 :    FOR_ALL_FACETS(f_id) 

	mov	esi, DWORD PTR _web+272
	mov	edx, esi
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	DWORD PTR _f_id$[ebp], esi
	je	$LN157@make_threa
$LL15@make_threa:
	mov	eax, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv1645[ebp], ecx
	je	$LN14@make_threa

; 1491 :    { facetedge_id fe = get_facet_fe(f_id);

	test	edx, edx
	jne	SHORT $LN94@make_threa
	xor	ecx, ecx
	mov	DWORD PTR _fe$81926[ebp], ecx
	jmp	SHORT $LN95@make_threa
$LN94@make_threa:
	mov	edi, DWORD PTR [edi+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN93@make_threa
	xor	edi, 134217728				; 08000000H
$LN93@make_threa:
	mov	ecx, edi
	mov	DWORD PTR _fe$81926[ebp], edi
$LN95@make_threa:

; 1492 :      int topband = -1;
; 1493 :      int lowband = 1000000;
; 1494 :      int vproc,vstage,vband;
; 1495 : 
; 1496 :      for ( i = 0 ; i < FACET_VERTS ; i++ )
; 1497 :      { v_id = get_fe_headv(fe); 

	mov	eax, DWORD PTR _web+460
	mov	esi, DWORD PTR _dymem
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+216
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv1667[ebp], eax
	mov	eax, DWORD PTR [edx+esi+304]
	mov	edx, DWORD PTR _web+124
	mov	DWORD PTR _topband$81927[ebp], -1
	mov	DWORD PTR _lowband$81928[ebp], 1000000	; 000f4240H
	mov	DWORD PTR tv1493[ebp], eax
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN100@make_threa
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+ecx]
	jmp	SHORT $LN99@make_threa
$LN100@make_threa:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+636
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [ecx+eax]
$LN99@make_threa:

; 1498 :        vproc = *(int*)get_extra(v_id,v_partition_proc_attr);

	mov	edi, DWORD PTR _v_partition_proc_attr
	mov	ecx, edx
	imul	edi, 240				; 000000f0H
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _web[ecx+104]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]

; 1499 :        vstage = *(int*)get_extra(v_id,v_partition_stage_attr);

	mov	eax, DWORD PTR _v_partition_stage_attr
	imul	eax, 240				; 000000f0H
	lea	ebx, DWORD PTR [edi+ecx]

; 1500 :        vband = vstage + max_thread_stages*vproc;

	mov	ebx, DWORD PTR [ebx+esi+64]
	mov	DWORD PTR tv1688[ebp], edx
	mov	edx, DWORD PTR [ebx+edx]
	mov	ebx, DWORD PTR _max_thread_stages
	imul	edx, ebx
	mov	DWORD PTR tv1421[ebp], eax
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+esi+64]
	mov	eax, DWORD PTR tv1688[ebp]
	add	edx, DWORD PTR [ecx+eax]

; 1501 :        if ( vband < lowband ) lowband = vband;

	cmp	edx, 1000000				; 000f4240H
	jge	SHORT $LN7@make_threa
	mov	DWORD PTR _lowband$81928[ebp], edx
$LN7@make_threa:

; 1502 :        if ( vband > topband ) topband = vband;

	cmp	edx, -1
	jle	SHORT $LN6@make_threa
	mov	DWORD PTR _topband$81927[ebp], edx
$LN6@make_threa:

; 1503 :        fe = get_next_edge(fe);

	test	DWORD PTR _fe$81926[ebp], 134217728	; 08000000H
	je	SHORT $LN108@make_threa
	mov	ecx, DWORD PTR tv1667[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN167@make_threa
$LN108@make_threa:
	mov	edx, DWORD PTR tv1667[ebp]
	mov	ecx, DWORD PTR [edx+32]
$LN167@make_threa:

; 1492 :      int topband = -1;
; 1493 :      int lowband = 1000000;
; 1494 :      int vproc,vstage,vband;
; 1495 : 
; 1496 :      for ( i = 0 ; i < FACET_VERTS ; i++ )
; 1497 :      { v_id = get_fe_headv(fe); 

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 1503 :        fe = get_next_edge(fe);

	mov	DWORD PTR _fe$81926[ebp], ecx
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv1667[ebp], eax
	mov	eax, DWORD PTR _web+124
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN144@make_threa

; 1492 :      int topband = -1;
; 1493 :      int lowband = 1000000;
; 1494 :      int vproc,vstage,vband;
; 1495 : 
; 1496 :      for ( i = 0 ; i < FACET_VERTS ; i++ )
; 1497 :      { v_id = get_fe_headv(fe); 

	mov	edx, DWORD PTR tv1493[ebp]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR [edx+ecx]
	jmp	SHORT $LN145@make_threa
$LN144@make_threa:
	mov	edx, DWORD PTR _web+636
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR tv1493[ebp]
	mov	edx, DWORD PTR [eax+ecx]
$LN145@make_threa:

; 1498 :        vproc = *(int*)get_extra(v_id,v_partition_proc_attr);

	mov	ecx, edx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _web[ecx+104]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	lea	eax, DWORD PTR [edi+ecx]

; 1500 :        vband = vstage + max_thread_stages*vproc;

	mov	eax, DWORD PTR [eax+esi+64]
	mov	DWORD PTR tv1710[ebp], edx
	mov	edx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR tv1421[ebp]
	imul	edx, ebx
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+esi+64]
	mov	eax, DWORD PTR tv1710[ebp]
	add	edx, DWORD PTR [ecx+eax]

; 1501 :        if ( vband < lowband ) lowband = vband;

	cmp	edx, DWORD PTR _lowband$81928[ebp]
	jge	SHORT $LN146@make_threa
	mov	DWORD PTR _lowband$81928[ebp], edx
$LN146@make_threa:

; 1502 :        if ( vband > topband ) topband = vband;

	cmp	edx, DWORD PTR _topband$81927[ebp]
	jle	SHORT $LN147@make_threa
	mov	DWORD PTR _topband$81927[ebp], edx
$LN147@make_threa:

; 1503 :        fe = get_next_edge(fe);

	test	DWORD PTR _fe$81926[ebp], 134217728	; 08000000H
	je	SHORT $LN148@make_threa
	mov	ecx, DWORD PTR tv1667[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN149@make_threa
$LN148@make_threa:
	mov	edx, DWORD PTR tv1667[ebp]
	mov	ecx, DWORD PTR [edx+32]
$LN149@make_threa:

; 1492 :      int topband = -1;
; 1493 :      int lowband = 1000000;
; 1494 :      int vproc,vstage,vband;
; 1495 : 
; 1496 :      for ( i = 0 ; i < FACET_VERTS ; i++ )
; 1497 :      { v_id = get_fe_headv(fe); 

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+124
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [eax+20]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN151@make_threa
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR tv1493[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	jmp	SHORT $LN152@make_threa
$LN151@make_threa:
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+636
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR tv1493[ebp]
	mov	edx, DWORD PTR [edx+eax]
$LN152@make_threa:

; 1498 :        vproc = *(int*)get_extra(v_id,v_partition_proc_attr);

	mov	ecx, edx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _web[ecx+104]
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	add	edi, ecx

; 1500 :        vband = vstage + max_thread_stages*vproc;

	mov	edx, DWORD PTR [edi+esi+64]
	mov	edx, DWORD PTR [edx+eax]
	mov	edi, DWORD PTR tv1421[ebp]
	imul	edx, ebx
	add	edi, ecx
	mov	ecx, DWORD PTR [edi+esi+64]
	add	edx, DWORD PTR [ecx+eax]

; 1501 :        if ( vband < lowband ) lowband = vband;

	mov	eax, DWORD PTR _lowband$81928[ebp]
	cmp	edx, eax
	jge	SHORT $LN153@make_threa
	mov	eax, edx
$LN153@make_threa:

; 1502 :        if ( vband > topband ) topband = vband;

	mov	ecx, DWORD PTR _topband$81927[ebp]
	cmp	edx, ecx
	jle	SHORT $LN154@make_threa
	mov	ecx, edx
$LN154@make_threa:

; 1504 :      }
; 1505 : 
; 1506 :      if ( topband-lowband <= 1 )

	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 1
	jg	SHORT $LN5@make_threa

; 1507 :      { proc = lowband/max_thread_stages; 

	cdq
	idiv	ebx
	mov	DWORD PTR _proc$[ebp], eax

; 1508 :        stage = lowband % max_thread_stages;

	mov	esi, edx

; 1509 :      }
; 1510 :      else if ( web.symmetry_flag && (lowband == 0) && 

	jmp	SHORT $LN2@make_threa
$LN5@make_threa:

; 1511 :                 (topband == nprocs*max_thread_stages-1 ) )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN3@make_threa
	test	eax, eax
	jne	SHORT $LN3@make_threa
	mov	eax, ebx
	imul	eax, DWORD PTR _nprocs
	dec	eax
	cmp	ecx, eax
	jne	SHORT $LN3@make_threa

; 1512 :      { proc = topband/max_thread_stages; 

	mov	eax, ecx
	cdq
	idiv	ebx
	mov	DWORD PTR _proc$[ebp], eax

; 1513 :        stage = topband % max_thread_stages;

	mov	esi, edx

; 1514 :      }
; 1515 :      else /* big element */

	jmp	SHORT $LN2@make_threa
$LN3@make_threa:

; 1516 :      { proc = 0; stage = max_thread_stages; }

	mov	DWORD PTR _proc$[ebp], 0
	mov	esi, ebx
$LN2@make_threa:

; 1517 : 
; 1518 :      th = thread_stages+proc;

	mov	edi, DWORD PTR _proc$[ebp]
	imul	edi, 548				; 00000224H
	add	edi, DWORD PTR _thread_stages

; 1519 :      if ( th->counts[FACET][stage] >= th->allocated[FACET][stage] )

	mov	ecx, DWORD PTR [edi+esi*4+432]
	cmp	DWORD PTR [edi+esi*4+252], ecx
	jl	SHORT $LN1@make_threa

; 1520 :      { int newalloc = th->allocated[FACET][stage] + 10
; 1521 :                  + 2*web.skel[FACET].count/(nprocs*max_thread_stages);

	imul	ebx, DWORD PTR _nprocs
	mov	eax, DWORD PTR _web+288
	add	eax, eax
	cdq
	idiv	ebx

; 1522 :        th->blocks[FACET][stage] = (element_id *)kb_realloc(
; 1523 :             (char*)(th->blocks[FACET][stage]),newalloc*sizeof(element_id));

	mov	edx, DWORD PTR [edi+esi*4+72]
	push	1523					; 000005f3H
	push	OFFSET ??_C@_07KINGIIKE@tmain?4c?$AA@
	lea	ebx, DWORD PTR [eax+ecx+10]
	lea	ecx, DWORD PTR [ebx*4]
	push	ecx
	push	edx
	call	_KB_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi+esi*4+72], eax

; 1524 :        th->allocated[FACET][stage] = newalloc;

	mov	DWORD PTR [edi+esi*4+432], ebx
$LN1@make_threa:

; 1525 :      }
; 1526 :      th->blocks[FACET][stage][th->counts[FACET][stage]++] = f_id;

	mov	ecx, DWORD PTR [edi+esi*4+252]
	mov	edx, DWORD PTR [edi+esi*4+72]
	mov	eax, DWORD PTR _f_id$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	inc	DWORD PTR [edi+esi*4+252]

; 1527 :      *((int *)(get_extra(f_id,f_partition_proc_attr))) = proc;

	mov	ecx, DWORD PTR _f_partition_proc_attr
	mov	ebx, DWORD PTR _proc$[ebp]
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _dymem
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+104]
	mov	edx, DWORD PTR [ecx+edx+64]
	mov	edi, DWORD PTR _web[eax+12]
	mov	ecx, DWORD PTR tv1645[ebp]
	mov	edi, DWORD PTR [ecx+edi]
	mov	DWORD PTR [edx+edi], ebx

; 1528 :      *((int *)(get_extra(f_id,f_partition_stage_attr))) = stage;

	mov	edx, DWORD PTR _f_partition_stage_attr
	mov	edi, DWORD PTR _web[eax+104]
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web[eax+12]
	mov	edx, DWORD PTR [edx+edi+64]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR [edx+eax], esi
$LN14@make_threa:

; 1489 : 
; 1490 :    FOR_ALL_FACETS(f_id) 

	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ecx+edx]
	mov	esi, DWORD PTR [eax]
	mov	edx, esi
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	DWORD PTR _f_id$[ebp], esi
	jne	$LL15@make_threa

; 1529 :    }
; 1530 : 
; 1531 : 
; 1532 :   partition_timestamp = global_timestamp;

	mov	ecx, DWORD PTR _global_timestamp
	pop	edi
	pop	esi
	mov	DWORD PTR _partition_timestamp, ecx
	pop	ebx

; 1533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN157@make_threa:

; 1529 :    }
; 1530 : 
; 1531 : 
; 1532 :   partition_timestamp = global_timestamp;

	mov	edx, DWORD PTR _global_timestamp
	pop	edi
	pop	esi
	mov	DWORD PTR _partition_timestamp, edx
	pop	ebx

; 1533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_make_thread_lists ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@HAMGDPCB@f_partition_proc?$AA@	; `string'
PUBLIC	??_C@_0BC@LKJBBBGC@f_partition_stage?$AA@	; `string'
PUBLIC	??_C@_0BB@CDFMGEKF@e_partition_proc?$AA@	; `string'
PUBLIC	??_C@_0BC@FABHMMAA@e_partition_stage?$AA@	; `string'
PUBLIC	??_C@_0BB@GHJHKGFM@v_partition_proc?$AA@	; `string'
PUBLIC	??_C@_0BC@JEDCENHK@v_partition_stage?$AA@	; `string'
PUBLIC	??_C@_0BC@GDPNMOJL@v_partition_coord?$AA@	; `string'
PUBLIC	_thread_stage_setup
EXTRN	_kb_calloc:PROC
EXTRN	_temp_free:PROC
EXTRN	_qsort:PROC
EXTRN	_kb_temp_calloc:PROC
EXTRN	_add_attribute:PROC
EXTRN	_v_partition_coord_attr:DWORD
EXTRN	_find_attribute:PROC
;	COMDAT ??_C@_0BB@HAMGDPCB@f_partition_proc?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BB@HAMGDPCB@f_partition_proc?$AA@ DB 'f_partition_proc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LKJBBBGC@f_partition_stage?$AA@
CONST	SEGMENT
??_C@_0BC@LKJBBBGC@f_partition_stage?$AA@ DB 'f_partition_stage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CDFMGEKF@e_partition_proc?$AA@
CONST	SEGMENT
??_C@_0BB@CDFMGEKF@e_partition_proc?$AA@ DB 'e_partition_proc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FABHMMAA@e_partition_stage?$AA@
CONST	SEGMENT
??_C@_0BC@FABHMMAA@e_partition_stage?$AA@ DB 'e_partition_stage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHJHKGFM@v_partition_proc?$AA@
CONST	SEGMENT
??_C@_0BB@GHJHKGFM@v_partition_proc?$AA@ DB 'v_partition_proc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JEDCENHK@v_partition_stage?$AA@
CONST	SEGMENT
??_C@_0BC@JEDCENHK@v_partition_stage?$AA@ DB 'v_partition_stage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GDPNMOJL@v_partition_coord?$AA@
CONST	SEGMENT
??_C@_0BC@GDPNMOJL@v_partition_coord?$AA@ DB 'v_partition_coord', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\tmain.c
CONST	ENDS
;	COMDAT _thread_stage_setup
_TEXT	SEGMENT
_perstage$ = -28					; size = 4
tv700 = -24						; size = 4
_stage$ = -24						; size = 4
_pspot$ = -20						; size = 4
_pcoords$ = -16						; size = 4
_proc$ = -12						; size = 4
_pcount$ = -8						; size = 4
_one$ = -4						; size = 4
_thread_stage_setup PROC				; COMDAT

; 1546 : { int i,pcount,pspot,perstage;

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1547 :   vertex_id v_id;
; 1548 :   int proc,stage;
; 1549 :   struct pcoord *pcoords;
; 1550 :   int one = 1;
; 1551 : 
; 1552 :   max_thread_stages = 2;  /* simple 1-D partitioning */
; 1553 :   
; 1554 :   /* Make sure vertex partitioning coord exists */
; 1555 :   v_partition_coord_attr = find_attribute(VERTEX,"v_partition_coord");

	push	OFFSET ??_C@_0BC@GDPNMOJL@v_partition_coord?$AA@
	push	0
	mov	DWORD PTR _one$[ebp], 1
	mov	DWORD PTR _max_thread_stages, 2
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _v_partition_coord_attr, eax

; 1556 :   if ( v_partition_coord_attr < 0 )

	test	eax, eax
	jns	SHORT $LN30@thread_sta

; 1557 :   { v_partition_coord_attr = add_attribute(VERTEX,"v_partition_coord",
; 1558 :         REAL_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _one$[ebp]
	push	eax
	push	0
	push	1
	push	OFFSET ??_C@_0BC@GDPNMOJL@v_partition_coord?$AA@
	push	0
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _v_partition_coord_attr, eax
$LN30@thread_sta:

; 1559 :   }
; 1560 : 
; 1561 :   /* default for now: use oblique coordinate as partition coordinate */
; 1562 :   FOR_ALL_VERTICES(v_id)

	push	ebx
	push	esi
	mov	esi, DWORD PTR _web+48
	push	edi
	test	esi, 268435456				; 10000000H
	je	$LN27@thread_sta
	fldz
	mov	eax, DWORD PTR _web+12
$LN57@thread_sta:
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	edi, DWORD PTR [edx+eax]
	mov	ecx, DWORD PTR [edi+8]
	and	ecx, 1
	xor	ebx, ebx
	or	ecx, ebx
	je	SHORT $LN28@thread_sta

; 1563 :   { int i;
; 1564 :     REAL sum = 0.0;
; 1565 :     REAL *x = get_coord(v_id);

	mov	ecx, DWORD PTR _web+104
	fld	ST(0)
	mov	eax, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ecx+eax+64]
	add	ebx, edi

; 1566 :     for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR _web+616
	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN22@thread_sta
	sub	ebx, OFFSET _oblique_coeff
$LN24@thread_sta:

; 1567 :       sum += oblique_coeff[i]*x[i];

	fld	QWORD PTR _oblique_coeff[ebx+ecx*8]
	inc	ecx
	fmul	QWORD PTR _oblique_coeff[ecx*8-8]
	faddp	ST(1), ST(0)
	cmp	ecx, edi
	jl	SHORT $LN24@thread_sta
$LN22@thread_sta:

; 1568 :     *((REAL*)(get_extra(v_id,v_partition_coord_attr))) = sum;

	shr	esi, 29					; 0000001dH
	mov	ecx, esi
	mov	esi, DWORD PTR _v_partition_coord_attr
	imul	ecx, 112				; 00000070H
	mov	edi, DWORD PTR _web[ecx+104]
	imul	esi, 240				; 000000f0H
	mov	ecx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR [ecx+edx]
	add	edi, esi
	mov	eax, DWORD PTR [edi+eax+64]
	fstp	QWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _web+12
$LN28@thread_sta:

; 1559 :   }
; 1560 : 
; 1561 :   /* default for now: use oblique coordinate as partition coordinate */
; 1562 :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR [edx+eax]
	mov	esi, DWORD PTR [edx]
	test	esi, 268435456				; 10000000H
	jne	$LN57@thread_sta
	fstp	ST(0)
$LN27@thread_sta:

; 1569 :   }
; 1570 :   
; 1571 :   v_partition_stage_attr = find_attribute(VERTEX,"v_partition_stage");

	push	OFFSET ??_C@_0BC@JEDCENHK@v_partition_stage?$AA@
	push	0
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _v_partition_stage_attr, eax

; 1572 :   if ( v_partition_stage_attr < 0 )

	test	eax, eax
	jns	SHORT $LN58@thread_sta

; 1573 :   { v_partition_stage_attr = add_attribute(VERTEX,"v_partition_stage",
; 1574 :         INTEGER_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _one$[ebp]
	push	eax
	push	0
	push	2
	push	OFFSET ??_C@_0BC@JEDCENHK@v_partition_stage?$AA@
	push	0
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _v_partition_stage_attr, eax
$LN58@thread_sta:

; 1575 :   }
; 1576 :   v_partition_proc_attr = find_attribute(VERTEX,"v_partition_proc");

	push	OFFSET ??_C@_0BB@GHJHKGFM@v_partition_proc?$AA@
	push	0
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _v_partition_proc_attr, eax

; 1577 :   if ( v_partition_proc_attr < 0 )

	test	eax, eax
	jns	SHORT $LN60@thread_sta

; 1578 :   { v_partition_proc_attr = add_attribute(VERTEX,"v_partition_proc",
; 1579 :         INTEGER_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _one$[ebp]
	push	ecx
	push	0
	push	2
	push	OFFSET ??_C@_0BB@GHJHKGFM@v_partition_proc?$AA@
	push	0
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _v_partition_proc_attr, eax
$LN60@thread_sta:

; 1580 :   }
; 1581 :   
; 1582 :   e_partition_stage_attr = find_attribute(EDGE,"e_partition_stage");

	push	OFFSET ??_C@_0BC@FABHMMAA@e_partition_stage?$AA@
	push	1
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _e_partition_stage_attr, eax

; 1583 :   if ( e_partition_stage_attr < 0 )

	test	eax, eax
	jns	SHORT $LN62@thread_sta

; 1584 :   { e_partition_stage_attr = add_attribute(EDGE,"e_partition_stage",
; 1585 :         INTEGER_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _one$[ebp]
	push	edx
	push	0
	push	2
	push	OFFSET ??_C@_0BC@FABHMMAA@e_partition_stage?$AA@
	push	1
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _e_partition_stage_attr, eax
$LN62@thread_sta:

; 1586 :   }
; 1587 :   e_partition_proc_attr = find_attribute(EDGE,"e_partition_proc");

	push	OFFSET ??_C@_0BB@CDFMGEKF@e_partition_proc?$AA@
	push	1
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _e_partition_proc_attr, eax

; 1588 :   if ( e_partition_proc_attr < 0 )

	test	eax, eax
	jns	SHORT $LN63@thread_sta

; 1589 :   { e_partition_proc_attr = add_attribute(EDGE,"e_partition_proc",
; 1590 :         INTEGER_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _one$[ebp]
	push	eax
	push	0
	push	2
	push	OFFSET ??_C@_0BB@CDFMGEKF@e_partition_proc?$AA@
	push	1
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _e_partition_proc_attr, eax
$LN63@thread_sta:

; 1591 :   }
; 1592 :   
; 1593 :   f_partition_stage_attr = find_attribute(FACET,"f_partition_stage");

	push	OFFSET ??_C@_0BC@LKJBBBGC@f_partition_stage?$AA@
	push	2
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _f_partition_stage_attr, eax

; 1594 :   if ( f_partition_stage_attr < 0 )

	test	eax, eax
	jns	SHORT $LN17@thread_sta

; 1595 :   { f_partition_stage_attr = add_attribute(FACET,"f_partition_stage",
; 1596 :         INTEGER_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _one$[ebp]
	push	ecx
	push	0
	push	2
	push	OFFSET ??_C@_0BC@LKJBBBGC@f_partition_stage?$AA@
	push	2
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _f_partition_stage_attr, eax
$LN17@thread_sta:

; 1597 :   }
; 1598 :   f_partition_proc_attr = find_attribute(FACET,"f_partition_proc");

	push	OFFSET ??_C@_0BB@HAMGDPCB@f_partition_proc?$AA@
	push	2
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _f_partition_proc_attr, eax

; 1599 :   if ( f_partition_proc_attr < 0 )

	test	eax, eax
	jns	SHORT $LN16@thread_sta

; 1600 :   { f_partition_proc_attr = add_attribute(FACET,"f_partition_proc",
; 1601 :         INTEGER_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _one$[ebp]
	push	edx
	push	0
	push	2
	push	OFFSET ??_C@_0BB@HAMGDPCB@f_partition_proc?$AA@
	push	2
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _f_partition_proc_attr, eax
$LN16@thread_sta:

; 1602 :   }
; 1603 :   
; 1604 :   /* Find percentiles, for load balancing */
; 1605 :   pcoords = (struct pcoord*)temp_calloc(web.skel[VERTEX].count,
; 1606 :                  sizeof(struct pcoord));

	mov	eax, DWORD PTR _web+64
	push	1606					; 00000646H
	push	OFFSET ??_C@_07KINGIIKE@tmain?4c?$AA@
	push	16					; 00000010H
	push	eax
	call	_kb_temp_calloc

; 1607 :   pcount = 0;
; 1608 :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	xor	esi, esi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pcoords$[ebp], eax
	mov	DWORD PTR _pcount$[ebp], esi
	test	edx, 268435456				; 10000000H
	je	SHORT $LN13@thread_sta

; 1602 :   }
; 1603 :   
; 1604 :   /* Find percentiles, for load balancing */
; 1605 :   pcoords = (struct pcoord*)temp_calloc(web.skel[VERTEX].count,
; 1606 :                  sizeof(struct pcoord));

	mov	ebx, DWORD PTR _web+12
	mov	esi, eax
	npad	6
$LL15@thread_sta:

; 1607 :   pcount = 0;
; 1608 :   FOR_ALL_VERTICES(v_id)

	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	edi, edi
	or	ecx, edi
	je	SHORT $LN14@thread_sta

; 1609 :   { pcoords[pcount].p_coord = *((REAL*)(get_extra(v_id,v_partition_coord_attr)));

	mov	edi, DWORD PTR _v_partition_coord_attr

; 1610 :     pcoords[pcount].v_id = v_id;
; 1611 :     pcount++;

	inc	DWORD PTR _pcount$[ebp]
	imul	edi, 240				; 000000f0H
	mov	ecx, edx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ebx, DWORD PTR _web[ecx+104]
	mov	ecx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR [ecx+eax]
	add	ebx, edi
	mov	edi, DWORD PTR _dymem
	mov	edi, DWORD PTR [ebx+edi+64]
	add	esi, 16					; 00000010H
	fld	QWORD PTR [edi+ecx]
	mov	DWORD PTR [esi-8], edx
	fstp	QWORD PTR [esi-16]
	mov	ebx, DWORD PTR _web+12
$LN14@thread_sta:

; 1607 :   pcount = 0;
; 1608 :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR [eax+ebx]
	mov	edx, DWORD PTR [edx]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL15@thread_sta
	mov	esi, DWORD PTR _pcount$[ebp]
	mov	eax, DWORD PTR _pcoords$[ebp]
$LN13@thread_sta:

; 1612 :   } 
; 1613 :   qsort((char*)pcoords,pcount,sizeof(struct pcoord),FCAST pcomp);

	push	OFFSET _pcomp
	push	16					; 00000010H
	push	esi
	push	eax
	call	_qsort

; 1614 :   pspot = 0;
; 1615 :   perstage = pcount/(nprocs*max_thread_stages) + 1;

	mov	edi, DWORD PTR _nprocs
	mov	ebx, DWORD PTR _max_thread_stages
	mov	eax, edi
	imul	eax, ebx
	mov	DWORD PTR tv700[ebp], eax
	mov	eax, esi
	cdq
	idiv	DWORD PTR tv700[ebp]
	xor	ecx, ecx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pspot$[ebp], ecx

; 1616 :   for ( proc = 0 ; proc < nprocs ; proc++ )

	mov	DWORD PTR _proc$[ebp], ecx
	inc	eax
	mov	DWORD PTR _perstage$[ebp], eax
	test	edi, edi
	jle	$LN8@thread_sta
$LL61@thread_sta:

; 1617 :   {
; 1618 :     for ( stage = 0 ; stage < max_thread_stages ; stage++ )

	xor	edx, edx
	mov	DWORD PTR _stage$[ebp], edx
	test	ebx, ebx
	jle	$LN9@thread_sta
	npad	3
$LL59@thread_sta:

; 1619 :     { 
; 1620 :        for ( i = 0 ;  (i < perstage) && (pspot < pcount) ; i++,pspot++ )

	xor	edi, edi
	test	eax, eax
	jle	$LN6@thread_sta
	mov	ebx, DWORD PTR _pcoords$[ebp]
	mov	esi, ecx
	add	esi, esi
	lea	esi, DWORD PTR [ebx+esi*8+8]
$LL54@thread_sta:
	cmp	ecx, DWORD PTR _pcount$[ebp]
	jge	$LN56@thread_sta

; 1621 :        { *((int *)(get_extra(pcoords[pspot].v_id,v_partition_proc_attr))) = proc;

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _v_partition_proc_attr
	mov	ecx, edx
	imul	eax, 240				; 000000f0H
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ebx, DWORD PTR _web[ecx+104]
	mov	ecx, DWORD PTR _web[ecx+12]
	add	ebx, eax
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [ebx+eax+64]
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _proc$[ebp]
	mov	DWORD PTR [eax+ecx], edx

; 1622 :          *((int *)(get_extra(pcoords[pspot].v_id,v_partition_stage_attr))) = stage;

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _v_partition_stage_attr
	mov	ecx, edx
	imul	eax, 240				; 000000f0H
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ebx, DWORD PTR _web[ecx+104]
	mov	ecx, DWORD PTR _web[ecx+12]
	add	ebx, eax
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [ebx+eax+64]
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _stage$[ebp]
	mov	DWORD PTR [eax+ecx], edx
	mov	ecx, DWORD PTR _pspot$[ebp]
	mov	eax, DWORD PTR _perstage$[ebp]
	inc	edi
	inc	ecx
	add	esi, 16					; 00000010H
	mov	DWORD PTR _pspot$[ebp], ecx
	cmp	edi, eax
	jl	$LL54@thread_sta
$LN56@thread_sta:

; 1619 :     { 
; 1620 :        for ( i = 0 ;  (i < perstage) && (pspot < pcount) ; i++,pspot++ )

	mov	ebx, DWORD PTR _max_thread_stages
$LN6@thread_sta:

; 1617 :   {
; 1618 :     for ( stage = 0 ; stage < max_thread_stages ; stage++ )

	inc	edx
	mov	DWORD PTR _stage$[ebp], edx
	cmp	edx, ebx
	jl	$LL59@thread_sta
	mov	edi, DWORD PTR _nprocs
$LN9@thread_sta:

; 1616 :   for ( proc = 0 ; proc < nprocs ; proc++ )

	mov	edx, DWORD PTR _proc$[ebp]
	inc	edx
	mov	DWORD PTR _proc$[ebp], edx
	cmp	edx, edi
	jl	$LL61@thread_sta
$LN8@thread_sta:

; 1623 :        }
; 1624 :     }
; 1625 :   }
; 1626 :   temp_free((char*)pcoords);

	mov	edx, DWORD PTR _pcoords$[ebp]
	push	edx
	call	_temp_free
	add	esp, 4

; 1627 : 
; 1628 :   if ( thread_stages == NULL )

	cmp	DWORD PTR _thread_stages, 0
	pop	edi
	pop	esi
	pop	ebx
	jne	SHORT $LN1@thread_sta

; 1629 :     thread_stages = (struct thread_stages_data*)mycalloc(nprocs,
; 1630 :                          sizeof(struct thread_stages_data));

	mov	eax, DWORD PTR _nprocs
	push	1630					; 0000065eH
	push	OFFSET ??_C@_07KINGIIKE@tmain?4c?$AA@
	push	548					; 00000224H
	push	eax
	call	_kb_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _thread_stages, eax
$LN1@thread_sta:

; 1631 : 
; 1632 :   /* set up all element's stage lists */
; 1633 :   make_thread_lists();

	call	_make_thread_lists

; 1634 : 
; 1635 : } /* end thread_stage_setup */

	mov	esp, ebp
	pop	ebp
	ret	0
_thread_stage_setup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@OPMDIENI@thread_launch_end?5?5?5?5?5?$CF12I64X?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@NECFHFPE@task?51?5stage?5?$CFd?5start?3?5?$CF12I64X?5e@ ; `string'
PUBLIC	??_C@_0CN@HLGBOHLD@task?50?5stage?5?$CFd?5start?3?5?$CF12I64X?5e@ ; `string'
PUBLIC	??_C@_0BP@HBODMCED@thread_launch_start?5?5?5?$CF12I64X?6?$AA@ ; `string'
PUBLIC	_thread_launch
EXTRN	_printf:PROC
EXTRN	_verbose_flag:DWORD
EXTRN	_thread_launch_end:QWORD
EXTRN	_thread_data_ptrs:DWORD
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	_busythreads:DWORD
EXTRN	_procs_requested:DWORD
EXTRN	_thread_task:DWORD
EXTRN	__imp__ResetEvent@4:PROC
EXTRN	_top_timestamp:DWORD
EXTRN	_global_id:DWORD
EXTRN	_thread_launch_start:QWORD
;	COMDAT ??_C@_0BP@OPMDIENI@thread_launch_end?5?5?5?5?5?$CF12I64X?6?$AA@
CONST	SEGMENT
??_C@_0BP@OPMDIENI@thread_launch_end?5?5?5?5?5?$CF12I64X?6?$AA@ DB 'threa'
	DB	'd_launch_end     %12I64X', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NECFHFPE@task?51?5stage?5?$CFd?5start?3?5?$CF12I64X?5e@
CONST	SEGMENT
??_C@_0CN@NECFHFPE@task?51?5stage?5?$CFd?5start?3?5?$CF12I64X?5e@ DB 'tas'
	DB	'k 1 stage %d start: %12I64X end: %12I64X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HLGBOHLD@task?50?5stage?5?$CFd?5start?3?5?$CF12I64X?5e@
CONST	SEGMENT
??_C@_0CN@HLGBOHLD@task?50?5stage?5?$CFd?5start?3?5?$CF12I64X?5e@ DB 'tas'
	DB	'k 0 stage %d start: %12I64X end: %12I64X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HBODMCED@thread_launch_start?5?5?5?$CF12I64X?6?$AA@
CONST	SEGMENT
??_C@_0BP@HBODMCED@thread_launch_start?5?5?5?$CF12I64X?6?$AA@ DB 'thread_'
	DB	'launch_start   %12I64X', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _thread_launch
_TEXT	SEGMENT
_task$ = 8						; size = 4
_j$ = 12						; size = 4
_element_type$ = 12					; size = 4
_thread_launch PROC					; COMDAT

; 1655 : { int i,j,proc;

	push	ebp
	mov	ebp, esp

; 1656 :   long long int now=0;
; 1657 :   
; 1658 :   PROF_NOW(now);

	rdtsc

; 1659 :   thread_launch_start = now;

	mov	DWORD PTR _thread_launch_start, eax

; 1660 : 
; 1661 :   global_id = web.skel[element_type].used;  /* in case no threads */

	mov	eax, DWORD PTR _element_type$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+48]
	mov	DWORD PTR _thread_launch_start+4, edx

; 1662 : 
; 1663 :   if ( partition_timestamp < top_timestamp )

	mov	edx, DWORD PTR _partition_timestamp
	mov	DWORD PTR _global_id, ecx
	cmp	edx, DWORD PTR _top_timestamp
	jge	SHORT $LN20@thread_lau

; 1664 :     thread_stage_setup();

	call	_thread_stage_setup
$LN20@thread_lau:
	push	ebx

; 1665 :   for ( proc = 0 ; proc < nprocs ; proc++ )

	xor	ebx, ebx
	push	esi
	xor	ecx, ecx
	push	edi
	cmp	DWORD PTR _nprocs, ebx
	jle	SHORT $LN17@thread_lau
	xor	eax, eax
	npad	10
$LL19@thread_lau:

; 1666 :     thread_stages[proc].stage = thread_stages[proc].spot = 0;

	mov	edx, DWORD PTR _thread_stages
	mov	DWORD PTR [eax+edx+544], ebx
	mov	edx, DWORD PTR _thread_stages
	mov	DWORD PTR [eax+edx+540], ebx
	inc	ecx
	add	eax, 548				; 00000224H
	cmp	ecx, DWORD PTR _nprocs
	jl	SHORT $LL19@thread_lau
$LN17@thread_lau:

; 1667 : 
; 1668 :   thread_task = task; 
; 1669 :   ResetEvent(mainthread_wakeup);  /* just to be sure */

	mov	eax, DWORD PTR _mainthread_wakeup
	mov	esi, DWORD PTR _task$[ebp]
	mov	edi, DWORD PTR __imp__ResetEvent@4
	push	eax
	mov	DWORD PTR _thread_task, esi
	call	edi

; 1670 :   busythreads = procs_requested;
; 1671 :   ResetEvent(barrier_event);

	mov	edx, DWORD PTR _barrier_event
	mov	ecx, DWORD PTR _procs_requested
	mov	DWORD PTR _busythreads, ecx
	push	edx
	call	edi

; 1672 :   barrier_count = procs_requested;
; 1673 :   SetEvent(workthread_wakeup);

	mov	ecx, DWORD PTR _workthread_wakeup
	mov	eax, DWORD PTR _procs_requested
	push	ecx
	mov	DWORD PTR _barrier_count, eax
	call	DWORD PTR __imp__SetEvent@4

; 1674 :   WaitForSingleObject(mainthread_wakeup,INFINITE);

	mov	edx, DWORD PTR _mainthread_wakeup
	push	-1
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8

; 1675 : 
; 1676 :   /* Cleanup and amalgamation of data */
; 1677 :   switch ( task )

	cmp	esi, 3
	jne	$LN33@thread_lau

; 1678 :   { case TH_CALC_FACET_ENERGY:
; 1679 :       for ( i = 0 ; i < nprocs ; i++ )

	mov	edi, DWORD PTR _nprocs
	fld	QWORD PTR _web+1240
	mov	esi, DWORD PTR _thread_data_ptrs
	fld	QWORD PTR _web+992
	xor	ecx, ecx
	cmp	edi, 4
	jl	$LC34@thread_lau
	lea	edx, DWORD PTR [edi-4]
	shr	edx, 2
	inc	edx
	lea	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [edx*4]
$LN35@thread_lau:

; 1680 :       { web.total_energy += thread_data_ptrs[i]->total_energy;

	mov	ebx, DWORD PTR [eax-8]
	fld	QWORD PTR [ebx+24]

; 1681 :         web.total_area  += thread_data_ptrs[i]->total_area;

	add	eax, 16					; 00000010H
	dec	edx
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _web+1240
	mov	ebx, DWORD PTR [eax-24]
	fld	QWORD PTR [ebx+32]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _web+992
	mov	ebx, DWORD PTR [eax-20]
	fld	QWORD PTR [ebx+24]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _web+1240
	mov	ebx, DWORD PTR [eax-20]
	fld	QWORD PTR [ebx+32]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _web+992
	mov	ebx, DWORD PTR [eax-16]
	fld	QWORD PTR [ebx+24]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _web+1240
	mov	ebx, DWORD PTR [eax-16]
	fld	QWORD PTR [ebx+32]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _web+992
	mov	ebx, DWORD PTR [eax-12]
	fld	QWORD PTR [ebx+24]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _web+1240
	mov	ebx, DWORD PTR [eax-12]
	fld	QWORD PTR [ebx+32]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _web+992
	jne	$LN35@thread_lau
$LC34@thread_lau:

; 1678 :   { case TH_CALC_FACET_ENERGY:
; 1679 :       for ( i = 0 ; i < nprocs ; i++ )

	cmp	ecx, edi
	jge	SHORT $LN45@thread_lau
$LC13@thread_lau:

; 1680 :       { web.total_energy += thread_data_ptrs[i]->total_energy;

	mov	eax, DWORD PTR [esi+ecx*4]
	fld	QWORD PTR [eax+24]
	inc	ecx
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _web+1240

; 1681 :         web.total_area  += thread_data_ptrs[i]->total_area;

	mov	edx, DWORD PTR [esi+ecx*4-4]
	fld	QWORD PTR [edx+32]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _web+992
	cmp	ecx, edi
	jl	SHORT $LC13@thread_lau
$LN45@thread_lau:

; 1678 :   { case TH_CALC_FACET_ENERGY:
; 1679 :       for ( i = 0 ; i < nprocs ; i++ )

	fstp	ST(1)
	xor	ebx, ebx
	fstp	ST(0)
$LN33@thread_lau:

; 1682 :       }
; 1683 :       break;
; 1684 :   }
; 1685 : 
; 1686 :   PROF_NOW(now);

	rdtsc

; 1687 :   thread_launch_end = now;

	mov	DWORD PTR _thread_launch_end, eax
	mov	DWORD PTR _thread_launch_end+4, edx

; 1688 : 
; 1689 : if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, ebx
	je	$LN10@thread_lau

; 1690 : {
; 1691 : /* print detailed clock timing */
; 1692 : printf("thread_launch_start   %12I64X\n",thread_launch_start-thread_launch_start);

	push	ebx
	push	ebx
	push	OFFSET ??_C@_0BP@HBODMCED@thread_launch_start?5?5?5?$CF12I64X?6?$AA@
	call	_printf

; 1693 : for (i = 0 ; i <= max_thread_stages ; i++ )

	mov	eax, DWORD PTR _max_thread_stages
	add	esp, 12					; 0000000cH
	cmp	eax, ebx
	jl	SHORT $LN7@thread_lau

; 1690 : {
; 1691 : /* print detailed clock timing */
; 1692 : printf("thread_launch_start   %12I64X\n",thread_launch_start-thread_launch_start);

	mov	esi, 1808				; 00000710H
	npad	9
$LL9@thread_lau:

; 1694 :   printf("task 0 stage %d start: %12I64X end: %12I64X\n",i,
; 1695 :     thread_data_ptrs[0]->stagestart[i]-thread_launch_start,
; 1696 :     thread_data_ptrs[0]->stageend[i]-thread_launch_start);

	mov	eax, DWORD PTR _thread_data_ptrs
	mov	eax, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi+eax+72]
	mov	ecx, DWORD PTR _thread_launch_start
	mov	edi, DWORD PTR [esi+eax+76]
	sub	edx, ecx
	sbb	edi, DWORD PTR _thread_launch_start+4
	push	edi
	push	edx
	mov	edx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [esi+eax+4]
	sub	edx, ecx
	sbb	eax, DWORD PTR _thread_launch_start+4
	push	eax
	push	edx
	push	ebx
	push	OFFSET ??_C@_0CN@HLGBOHLD@task?50?5stage?5?$CFd?5start?3?5?$CF12I64X?5e@
	call	_printf
	mov	eax, DWORD PTR _max_thread_stages
	inc	ebx
	add	esp, 24					; 00000018H
	add	esi, 8
	cmp	ebx, eax
	jle	SHORT $LL9@thread_lau
$LN7@thread_lau:

; 1697 : for ( j = 1; j < nprocs ; j++ )

	mov	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	cmp	DWORD PTR _nprocs, ecx
	jle	SHORT $LN4@thread_lau
	npad	5
$LL6@thread_lau:

; 1698 : { for (i = 0 ; i < max_thread_stages ; i++ )

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN5@thread_lau
	mov	esi, 1808				; 00000710H
	npad	5
$LL37@thread_lau:

; 1699 :     printf("task 1 stage %d start: %12I64X end: %12I64X\n",i,
; 1700 :       thread_data_ptrs[j]->stagestart[i]-thread_launch_start,
; 1701 :       thread_data_ptrs[j]->stageend[i]-thread_launch_start);

	mov	ecx, DWORD PTR _thread_data_ptrs
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [esi+eax+72]
	mov	ecx, DWORD PTR _thread_launch_start
	mov	ebx, DWORD PTR [esi+eax+76]
	sub	edx, ecx
	sbb	ebx, DWORD PTR _thread_launch_start+4
	push	ebx
	push	edx
	mov	edx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [esi+eax+4]
	sub	edx, ecx
	sbb	eax, DWORD PTR _thread_launch_start+4
	push	eax
	push	edx
	push	edi
	push	OFFSET ??_C@_0CN@NECFHFPE@task?51?5stage?5?$CFd?5start?3?5?$CF12I64X?5e@
	call	_printf
	mov	eax, DWORD PTR _max_thread_stages
	inc	edi
	add	esp, 24					; 00000018H
	add	esi, 8
	cmp	edi, eax
	jl	SHORT $LL37@thread_lau
$LN5@thread_lau:

; 1697 : for ( j = 1; j < nprocs ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR _nprocs
	jl	SHORT $LL6@thread_lau
$LN4@thread_lau:

; 1702 : }
; 1703 : printf("thread_launch_end     %12I64X\n",thread_launch_end-thread_launch_start);

	mov	ecx, DWORD PTR _thread_launch_end
	sub	ecx, DWORD PTR _thread_launch_start
	mov	edx, DWORD PTR _thread_launch_end+4
	sbb	edx, DWORD PTR _thread_launch_start+4
	push	edx
	push	ecx
	push	OFFSET ??_C@_0BP@OPMDIENI@thread_launch_end?5?5?5?5?5?$CF12I64X?6?$AA@
	call	_printf
	add	esp, 12					; 0000000cH
$LN10@thread_lau:
	pop	edi
	pop	esi
	pop	ebx

; 1704 : }
; 1705 : 
; 1706 : } // end thread_launch()

	pop	ebp
	ret	0
_thread_launch ENDP
_TEXT	ENDS
PUBLIC	_mylock_element
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__TryEnterCriticalSection@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _mylock_element
_TEXT	SEGMENT
_id$ = 8						; size = 4
_mylock_element PROC					; COMDAT

; 1865 : {  if ( TryEnterCriticalSection(element_mutex_ptr)==0 )

	mov	eax, DWORD PTR _element_mutex_ptr
	push	eax
	call	DWORD PTR __imp__TryEnterCriticalSection@4
	test	eax, eax
	jne	SHORT $LN2@mylock_ele

; 1866 :     {EnterCriticalSection(element_mutex_ptr);

	mov	ecx, DWORD PTR _element_mutex_ptr
	push	ecx
	call	DWORD PTR __imp__EnterCriticalSection@4

; 1867 :      element_locks++;

	inc	DWORD PTR _element_locks

; 1870 :    return 0;  /* so can be used in conditionals */

	xor	eax, eax

; 1871 : }

	ret	0
$LN2@mylock_ele:

; 1868 :     }
; 1869 :    else element_unlocks++; 

	inc	DWORD PTR _element_unlocks

; 1870 :    return 0;  /* so can be used in conditionals */

	xor	eax, eax

; 1871 : }

	ret	0
_mylock_element ENDP
_TEXT	ENDS
PUBLIC	_myunlock_element
EXTRN	__imp__LeaveCriticalSection@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _myunlock_element
_TEXT	SEGMENT
_id$ = 8						; size = 4
_myunlock_element PROC					; COMDAT

; 1873 : {  LeaveCriticalSection(element_mutex_ptr); 

	mov	eax, DWORD PTR _element_mutex_ptr
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 1874 :    return 0;

	xor	eax, eax

; 1875 : }

	ret	0
_myunlock_element ENDP
_TEXT	ENDS
PUBLIC	_mylock_web
; Function compile flags: /Ogtp
;	COMDAT _mylock_web
_TEXT	SEGMENT
_mylock_web PROC					; COMDAT

; 1877 : {  if ( TryEnterCriticalSection(web_mutex_ptr)==0 )

	mov	eax, DWORD PTR _web_mutex_ptr
	push	eax
	call	DWORD PTR __imp__TryEnterCriticalSection@4
	test	eax, eax
	jne	SHORT $LN2@mylock_web

; 1878 :     {EnterCriticalSection(web_mutex_ptr);

	mov	ecx, DWORD PTR _web_mutex_ptr
	push	ecx
	call	DWORD PTR __imp__EnterCriticalSection@4

; 1879 :      web_locks++;

	inc	DWORD PTR _web_locks

; 1882 :    return 0;

	xor	eax, eax

; 1883 : }

	ret	0
$LN2@mylock_web:

; 1880 :     }
; 1881 :    else web_unlocks++; 

	inc	DWORD PTR _web_unlocks

; 1882 :    return 0;

	xor	eax, eax

; 1883 : }

	ret	0
_mylock_web ENDP
_TEXT	ENDS
PUBLIC	_myunlock_web
; Function compile flags: /Ogtp
;	COMDAT _myunlock_web
_TEXT	SEGMENT
_myunlock_web PROC					; COMDAT

; 1885 : {  LeaveCriticalSection(web_mutex_ptr); 

	mov	eax, DWORD PTR _web_mutex_ptr
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 1886 :    return 0;

	xor	eax, eax

; 1887 : }

	ret	0
_myunlock_web ENDP
_TEXT	ENDS
PUBLIC	_win_get_thread_data
EXTRN	__imp__TlsGetValue@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _win_get_thread_data
_TEXT	SEGMENT
_key$ = 8						; size = 4
_win_get_thread_data PROC				; COMDAT

; 1889 : { return (struct thread_data *)TlsGetValue(key);

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	DWORD PTR __imp__TlsGetValue@4

; 1890 : }

	pop	ebp
	ret	0
_win_get_thread_data ENDP
_TEXT	ENDS
PUBLIC	__real@41e65a0bc0000000
PUBLIC	_find_cpu_speed
EXTRN	_cpu_speed:QWORD
;	COMDAT __real@41e65a0bc0000000
CONST	SEGMENT
__real@41e65a0bc0000000 DQ 041e65a0bc0000000r	; 3e+009
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _find_cpu_speed
_TEXT	SEGMENT
_find_cpu_speed PROC					; COMDAT

; 1926 : #if defined(_MSC_VER) && defined(PROFILING)
; 1927 :   { /* use high-performance counter to estimate frequency */
; 1928 :     LARGE_INTEGER freq,start,finish;
; 1929 :     long long int profstart,profnow;
; 1930 :     QueryPerformanceFrequency(&freq);
; 1931 :     PROF_NOW(profstart);
; 1932 :     PROF_NOW(profnow);
; 1933 :     QueryPerformanceCounter(&start);
; 1934 :     do {
; 1935 :       if ( profnow - profstart <= 0 )
; 1936 :       { /* something wrong; maybe hibernated in middle of loop! */
; 1937 :         return;
; 1938 :       }
; 1939 :       PROF_NOW(profnow);
; 1940 :     }
; 1941 :     while ( profnow - profstart < 100000000 );
; 1942 :     QueryPerformanceCounter(&finish);
; 1943 :     cpu_speed = (profnow-profstart)/
; 1944 :              ((finish.QuadPart-start.QuadPart)/(double)freq.QuadPart);
; 1945 :   }
; 1946 : #else
; 1947 :    cpu_speed = 3e9;  /* rough guess */

	fld	QWORD PTR __real@41e65a0bc0000000
	fstp	QWORD PTR _cpu_speed

; 1948 : #endif
; 1949 : } // end find_cpu_speed()

	ret	0
_find_cpu_speed ENDP
_TEXT	ENDS
PUBLIC	_m_set_idlist
EXTRN	_proc_ids:BYTE
EXTRN	_getpid:PROC
; Function compile flags: /Ogtp
;	COMDAT _m_set_idlist
_TEXT	SEGMENT
_m_set_idlist PROC					; COMDAT

; 90   : { proc_ids[GET_THREAD_ID] = getpid(); }

	mov	eax, DWORD PTR _thread_data_key
	push	esi
	push	eax
	call	_win_get_thread_data
	add	esp, 4
	mov	esi, eax
	call	_getpid
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _proc_ids[ecx*4], eax
	pop	esi
	ret	0
_m_set_idlist ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@KADPCLAC@Invalid?5thread?5task?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	_task_caller
EXTRN	_thread_calc_edges:PROC
EXTRN	_thread_equiangulate:PROC
EXTRN	_thread_calc_edge_con_volume:PROC
EXTRN	_thread_calc_facet_volume:PROC
EXTRN	_thread_move_vertices:PROC
EXTRN	_m_calc_quant_hess:PROC
EXTRN	_m_mode:DWORD
EXTRN	_m_rhs:DWORD
EXTRN	_m_fix_grads:PROC
EXTRN	_m_calc_quant_grads:PROC
EXTRN	_multi_calc_quants:PROC
EXTRN	_m_type:DWORD
EXTRN	_thread_calc_facet_forces:PROC
EXTRN	_thread_calc_facet_energy:PROC
EXTRN	_thread_project_all:PROC
;	COMDAT ??_C@_0BJ@KADPCLAC@Invalid?5thread?5task?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BJ@KADPCLAC@Invalid?5thread?5task?3?5?$CFd?6?$AA@ DB 'Invalid thre'
	DB	'ad task: %d', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _task_caller
_TEXT	SEGMENT
_thread_tasknum$ = 8					; size = 4
_task_caller PROC					; COMDAT

; 1217 : { 

	push	ebp
	mov	ebp, esp

; 1218 :   struct thread_data *data = GET_THREAD_DATA;

	mov	eax, DWORD PTR _thread_data_key
	push	esi
	push	eax
	call	_win_get_thread_data

; 1219 :   long long int task_caller_elapsed_time;
; 1220 :   long long int now;
; 1221 :   data->task_state = 1;
; 1222 : 
; 1223 : PROF_NOW(now);
; 1224 : #ifdef _MSC_VER
; 1225 : data->stagestart[0] = now;
; 1226 : #endif
; 1227 : 
; 1228 : PROF_START(task_caller)
; 1229 :   switch ( thread_tasknum )

	mov	ecx, DWORD PTR _thread_tasknum$[ebp]
	mov	esi, eax
	rdtsc
	mov	DWORD PTR [esi+1808], eax
	lea	eax, DWORD PTR [ecx-1]
	add	esp, 4
	mov	DWORD PTR [esi+8], 1
	mov	DWORD PTR [esi+1812], edx
	cmp	eax, 15					; 0000000fH
	ja	$LN1@task_calle
	jmp	DWORD PTR $LN19@task_calle[eax*4]
$LN14@task_calle:

; 1230 :     {
; 1231 :       case TH_PROJECT_ALL_TEST: thread_project_all(TEST_MOVE); break;

	push	0
	call	_thread_project_all
	add	esp, 4

; 1248 :     }
; 1249 : PROF_FINISH(task_caller)
; 1250 : 
; 1251 : #ifdef  ZZZZZ
; 1252 : if(verbose_flag)
; 1253 : { char *taskname;
; 1254 :   switch ( thread_tasknum )
; 1255 :     {
; 1256 :       case TH_PROJECT_ALL_TEST: taskname="thread_project_all"; break;
; 1257 :       case TH_PROJECT_ALL_ACTUAL: taskname="thread_project_all"; break;
; 1258 :       case TH_CALC_FACET_ENERGY:
; 1259 :              taskname="thread_calc_facet_energy"; break;
; 1260 :       case TH_CALC_FACET_FORCES: taskname="thread_calc_facet_forces"; break;
; 1261 :       case TH_MULTI_CALC_QUANT: taskname="multi_calc_quants"; break;
; 1262 :       case TH_MULTI_QUANT_GRADS: taskname="m_calc_quant_grads"; break;
; 1263 :       case TH_FIX_GRADS: taskname="m_fix_grads"; break;
; 1264 :       case TH_MULTI_QUANT_HESS: taskname="m_calc_quant_hess"; break;
; 1265 :       case TH_CALC_FACET_VOLUME: taskname="thread_calc_facet_volume"; break;
; 1266 :       case TH_CALC_EDGE_CON_VOLUME: taskname="thread_calc_edge_con_volume"; break;
; 1267 :       default: taskname="default";
; 1268 :     }
; 1269 : printf("%30s",taskname);
; 1270 : PROF_PRINT(task_caller)
; 1271 : }
; 1272 : #endif
; 1273 : 
; 1274 :   data->task_state = 2;

	mov	DWORD PTR [esi+8], 2
	pop	esi

; 1275 : 
; 1276 : } // end task_caller()

	pop	ebp
	ret	0
$LN13@task_calle:

; 1232 :       case TH_PROJECT_ALL_ACTUAL: thread_project_all(ACTUAL_MOVE); break;

	push	1
	call	_thread_project_all
	add	esp, 4

; 1248 :     }
; 1249 : PROF_FINISH(task_caller)
; 1250 : 
; 1251 : #ifdef  ZZZZZ
; 1252 : if(verbose_flag)
; 1253 : { char *taskname;
; 1254 :   switch ( thread_tasknum )
; 1255 :     {
; 1256 :       case TH_PROJECT_ALL_TEST: taskname="thread_project_all"; break;
; 1257 :       case TH_PROJECT_ALL_ACTUAL: taskname="thread_project_all"; break;
; 1258 :       case TH_CALC_FACET_ENERGY:
; 1259 :              taskname="thread_calc_facet_energy"; break;
; 1260 :       case TH_CALC_FACET_FORCES: taskname="thread_calc_facet_forces"; break;
; 1261 :       case TH_MULTI_CALC_QUANT: taskname="multi_calc_quants"; break;
; 1262 :       case TH_MULTI_QUANT_GRADS: taskname="m_calc_quant_grads"; break;
; 1263 :       case TH_FIX_GRADS: taskname="m_fix_grads"; break;
; 1264 :       case TH_MULTI_QUANT_HESS: taskname="m_calc_quant_hess"; break;
; 1265 :       case TH_CALC_FACET_VOLUME: taskname="thread_calc_facet_volume"; break;
; 1266 :       case TH_CALC_EDGE_CON_VOLUME: taskname="thread_calc_edge_con_volume"; break;
; 1267 :       default: taskname="default";
; 1268 :     }
; 1269 : printf("%30s",taskname);
; 1270 : PROF_PRINT(task_caller)
; 1271 : }
; 1272 : #endif
; 1273 : 
; 1274 :   data->task_state = 2;

	mov	DWORD PTR [esi+8], 2
	pop	esi

; 1275 : 
; 1276 : } // end task_caller()

	pop	ebp
	ret	0
$LN12@task_calle:

; 1233 :       case TH_CALC_FACET_ENERGY:
; 1234 :              data->total_energy = data->total_area = 0.0;

	fldz
	fst	QWORD PTR [esi+32]
	fstp	QWORD PTR [esi+24]

; 1235 :              thread_calc_facet_energy(); break;

	call	_thread_calc_facet_energy

; 1248 :     }
; 1249 : PROF_FINISH(task_caller)
; 1250 : 
; 1251 : #ifdef  ZZZZZ
; 1252 : if(verbose_flag)
; 1253 : { char *taskname;
; 1254 :   switch ( thread_tasknum )
; 1255 :     {
; 1256 :       case TH_PROJECT_ALL_TEST: taskname="thread_project_all"; break;
; 1257 :       case TH_PROJECT_ALL_ACTUAL: taskname="thread_project_all"; break;
; 1258 :       case TH_CALC_FACET_ENERGY:
; 1259 :              taskname="thread_calc_facet_energy"; break;
; 1260 :       case TH_CALC_FACET_FORCES: taskname="thread_calc_facet_forces"; break;
; 1261 :       case TH_MULTI_CALC_QUANT: taskname="multi_calc_quants"; break;
; 1262 :       case TH_MULTI_QUANT_GRADS: taskname="m_calc_quant_grads"; break;
; 1263 :       case TH_FIX_GRADS: taskname="m_fix_grads"; break;
; 1264 :       case TH_MULTI_QUANT_HESS: taskname="m_calc_quant_hess"; break;
; 1265 :       case TH_CALC_FACET_VOLUME: taskname="thread_calc_facet_volume"; break;
; 1266 :       case TH_CALC_EDGE_CON_VOLUME: taskname="thread_calc_edge_con_volume"; break;
; 1267 :       default: taskname="default";
; 1268 :     }
; 1269 : printf("%30s",taskname);
; 1270 : PROF_PRINT(task_caller)
; 1271 : }
; 1272 : #endif
; 1273 : 
; 1274 :   data->task_state = 2;

	mov	DWORD PTR [esi+8], 2
	pop	esi

; 1275 : 
; 1276 : } // end task_caller()

	pop	ebp
	ret	0
$LN11@task_calle:

; 1236 :       case TH_CALC_FACET_FORCES: thread_calc_facet_forces(); break;

	call	_thread_calc_facet_forces

; 1248 :     }
; 1249 : PROF_FINISH(task_caller)
; 1250 : 
; 1251 : #ifdef  ZZZZZ
; 1252 : if(verbose_flag)
; 1253 : { char *taskname;
; 1254 :   switch ( thread_tasknum )
; 1255 :     {
; 1256 :       case TH_PROJECT_ALL_TEST: taskname="thread_project_all"; break;
; 1257 :       case TH_PROJECT_ALL_ACTUAL: taskname="thread_project_all"; break;
; 1258 :       case TH_CALC_FACET_ENERGY:
; 1259 :              taskname="thread_calc_facet_energy"; break;
; 1260 :       case TH_CALC_FACET_FORCES: taskname="thread_calc_facet_forces"; break;
; 1261 :       case TH_MULTI_CALC_QUANT: taskname="multi_calc_quants"; break;
; 1262 :       case TH_MULTI_QUANT_GRADS: taskname="m_calc_quant_grads"; break;
; 1263 :       case TH_FIX_GRADS: taskname="m_fix_grads"; break;
; 1264 :       case TH_MULTI_QUANT_HESS: taskname="m_calc_quant_hess"; break;
; 1265 :       case TH_CALC_FACET_VOLUME: taskname="thread_calc_facet_volume"; break;
; 1266 :       case TH_CALC_EDGE_CON_VOLUME: taskname="thread_calc_edge_con_volume"; break;
; 1267 :       default: taskname="default";
; 1268 :     }
; 1269 : printf("%30s",taskname);
; 1270 : PROF_PRINT(task_caller)
; 1271 : }
; 1272 : #endif
; 1273 : 
; 1274 :   data->task_state = 2;

	mov	DWORD PTR [esi+8], 2
	pop	esi

; 1275 : 
; 1276 : } // end task_caller()

	pop	ebp
	ret	0
$LN10@task_calle:

; 1237 :       case TH_MULTI_CALC_QUANT: multi_calc_quants(m_type); break;

	mov	ecx, DWORD PTR _m_type
	push	ecx
	call	_multi_calc_quants
	add	esp, 4

; 1248 :     }
; 1249 : PROF_FINISH(task_caller)
; 1250 : 
; 1251 : #ifdef  ZZZZZ
; 1252 : if(verbose_flag)
; 1253 : { char *taskname;
; 1254 :   switch ( thread_tasknum )
; 1255 :     {
; 1256 :       case TH_PROJECT_ALL_TEST: taskname="thread_project_all"; break;
; 1257 :       case TH_PROJECT_ALL_ACTUAL: taskname="thread_project_all"; break;
; 1258 :       case TH_CALC_FACET_ENERGY:
; 1259 :              taskname="thread_calc_facet_energy"; break;
; 1260 :       case TH_CALC_FACET_FORCES: taskname="thread_calc_facet_forces"; break;
; 1261 :       case TH_MULTI_CALC_QUANT: taskname="multi_calc_quants"; break;
; 1262 :       case TH_MULTI_QUANT_GRADS: taskname="m_calc_quant_grads"; break;
; 1263 :       case TH_FIX_GRADS: taskname="m_fix_grads"; break;
; 1264 :       case TH_MULTI_QUANT_HESS: taskname="m_calc_quant_hess"; break;
; 1265 :       case TH_CALC_FACET_VOLUME: taskname="thread_calc_facet_volume"; break;
; 1266 :       case TH_CALC_EDGE_CON_VOLUME: taskname="thread_calc_edge_con_volume"; break;
; 1267 :       default: taskname="default";
; 1268 :     }
; 1269 : printf("%30s",taskname);
; 1270 : PROF_PRINT(task_caller)
; 1271 : }
; 1272 : #endif
; 1273 : 
; 1274 :   data->task_state = 2;

	mov	DWORD PTR [esi+8], 2
	pop	esi

; 1275 : 
; 1276 : } // end task_caller()

	pop	ebp
	ret	0
$LN9@task_calle:

; 1238 :       case TH_MULTI_QUANT_GRADS: m_calc_quant_grads(m_type); break;

	mov	edx, DWORD PTR _m_type
	push	edx
	call	_m_calc_quant_grads
	add	esp, 4

; 1248 :     }
; 1249 : PROF_FINISH(task_caller)
; 1250 : 
; 1251 : #ifdef  ZZZZZ
; 1252 : if(verbose_flag)
; 1253 : { char *taskname;
; 1254 :   switch ( thread_tasknum )
; 1255 :     {
; 1256 :       case TH_PROJECT_ALL_TEST: taskname="thread_project_all"; break;
; 1257 :       case TH_PROJECT_ALL_ACTUAL: taskname="thread_project_all"; break;
; 1258 :       case TH_CALC_FACET_ENERGY:
; 1259 :              taskname="thread_calc_facet_energy"; break;
; 1260 :       case TH_CALC_FACET_FORCES: taskname="thread_calc_facet_forces"; break;
; 1261 :       case TH_MULTI_CALC_QUANT: taskname="multi_calc_quants"; break;
; 1262 :       case TH_MULTI_QUANT_GRADS: taskname="m_calc_quant_grads"; break;
; 1263 :       case TH_FIX_GRADS: taskname="m_fix_grads"; break;
; 1264 :       case TH_MULTI_QUANT_HESS: taskname="m_calc_quant_hess"; break;
; 1265 :       case TH_CALC_FACET_VOLUME: taskname="thread_calc_facet_volume"; break;
; 1266 :       case TH_CALC_EDGE_CON_VOLUME: taskname="thread_calc_edge_con_volume"; break;
; 1267 :       default: taskname="default";
; 1268 :     }
; 1269 : printf("%30s",taskname);
; 1270 : PROF_PRINT(task_caller)
; 1271 : }
; 1272 : #endif
; 1273 : 
; 1274 :   data->task_state = 2;

	mov	DWORD PTR [esi+8], 2
	pop	esi

; 1275 : 
; 1276 : } // end task_caller()

	pop	ebp
	ret	0
$LN8@task_calle:

; 1239 :       case TH_FIX_GRADS: m_fix_grads(); break;

	call	_m_fix_grads

; 1248 :     }
; 1249 : PROF_FINISH(task_caller)
; 1250 : 
; 1251 : #ifdef  ZZZZZ
; 1252 : if(verbose_flag)
; 1253 : { char *taskname;
; 1254 :   switch ( thread_tasknum )
; 1255 :     {
; 1256 :       case TH_PROJECT_ALL_TEST: taskname="thread_project_all"; break;
; 1257 :       case TH_PROJECT_ALL_ACTUAL: taskname="thread_project_all"; break;
; 1258 :       case TH_CALC_FACET_ENERGY:
; 1259 :              taskname="thread_calc_facet_energy"; break;
; 1260 :       case TH_CALC_FACET_FORCES: taskname="thread_calc_facet_forces"; break;
; 1261 :       case TH_MULTI_CALC_QUANT: taskname="multi_calc_quants"; break;
; 1262 :       case TH_MULTI_QUANT_GRADS: taskname="m_calc_quant_grads"; break;
; 1263 :       case TH_FIX_GRADS: taskname="m_fix_grads"; break;
; 1264 :       case TH_MULTI_QUANT_HESS: taskname="m_calc_quant_hess"; break;
; 1265 :       case TH_CALC_FACET_VOLUME: taskname="thread_calc_facet_volume"; break;
; 1266 :       case TH_CALC_EDGE_CON_VOLUME: taskname="thread_calc_edge_con_volume"; break;
; 1267 :       default: taskname="default";
; 1268 :     }
; 1269 : printf("%30s",taskname);
; 1270 : PROF_PRINT(task_caller)
; 1271 : }
; 1272 : #endif
; 1273 : 
; 1274 :   data->task_state = 2;

	mov	DWORD PTR [esi+8], 2
	pop	esi

; 1275 : 
; 1276 : } // end task_caller()

	pop	ebp
	ret	0
$LN7@task_calle:

; 1240 :       case TH_MULTI_QUANT_HESS: m_calc_quant_hess(m_type,m_mode,m_rhs); break;

	mov	eax, DWORD PTR _m_rhs
	mov	ecx, DWORD PTR _m_mode
	mov	edx, DWORD PTR _m_type
	push	eax
	push	ecx
	push	edx
	call	_m_calc_quant_hess
	add	esp, 12					; 0000000cH

; 1248 :     }
; 1249 : PROF_FINISH(task_caller)
; 1250 : 
; 1251 : #ifdef  ZZZZZ
; 1252 : if(verbose_flag)
; 1253 : { char *taskname;
; 1254 :   switch ( thread_tasknum )
; 1255 :     {
; 1256 :       case TH_PROJECT_ALL_TEST: taskname="thread_project_all"; break;
; 1257 :       case TH_PROJECT_ALL_ACTUAL: taskname="thread_project_all"; break;
; 1258 :       case TH_CALC_FACET_ENERGY:
; 1259 :              taskname="thread_calc_facet_energy"; break;
; 1260 :       case TH_CALC_FACET_FORCES: taskname="thread_calc_facet_forces"; break;
; 1261 :       case TH_MULTI_CALC_QUANT: taskname="multi_calc_quants"; break;
; 1262 :       case TH_MULTI_QUANT_GRADS: taskname="m_calc_quant_grads"; break;
; 1263 :       case TH_FIX_GRADS: taskname="m_fix_grads"; break;
; 1264 :       case TH_MULTI_QUANT_HESS: taskname="m_calc_quant_hess"; break;
; 1265 :       case TH_CALC_FACET_VOLUME: taskname="thread_calc_facet_volume"; break;
; 1266 :       case TH_CALC_EDGE_CON_VOLUME: taskname="thread_calc_edge_con_volume"; break;
; 1267 :       default: taskname="default";
; 1268 :     }
; 1269 : printf("%30s",taskname);
; 1270 : PROF_PRINT(task_caller)
; 1271 : }
; 1272 : #endif
; 1273 : 
; 1274 :   data->task_state = 2;

	mov	DWORD PTR [esi+8], 2
	pop	esi

; 1275 : 
; 1276 : } // end task_caller()

	pop	ebp
	ret	0
$LN6@task_calle:

; 1241 :       case TH_MOVE_VERTICES: thread_move_vertices(); break;

	call	_thread_move_vertices

; 1248 :     }
; 1249 : PROF_FINISH(task_caller)
; 1250 : 
; 1251 : #ifdef  ZZZZZ
; 1252 : if(verbose_flag)
; 1253 : { char *taskname;
; 1254 :   switch ( thread_tasknum )
; 1255 :     {
; 1256 :       case TH_PROJECT_ALL_TEST: taskname="thread_project_all"; break;
; 1257 :       case TH_PROJECT_ALL_ACTUAL: taskname="thread_project_all"; break;
; 1258 :       case TH_CALC_FACET_ENERGY:
; 1259 :              taskname="thread_calc_facet_energy"; break;
; 1260 :       case TH_CALC_FACET_FORCES: taskname="thread_calc_facet_forces"; break;
; 1261 :       case TH_MULTI_CALC_QUANT: taskname="multi_calc_quants"; break;
; 1262 :       case TH_MULTI_QUANT_GRADS: taskname="m_calc_quant_grads"; break;
; 1263 :       case TH_FIX_GRADS: taskname="m_fix_grads"; break;
; 1264 :       case TH_MULTI_QUANT_HESS: taskname="m_calc_quant_hess"; break;
; 1265 :       case TH_CALC_FACET_VOLUME: taskname="thread_calc_facet_volume"; break;
; 1266 :       case TH_CALC_EDGE_CON_VOLUME: taskname="thread_calc_edge_con_volume"; break;
; 1267 :       default: taskname="default";
; 1268 :     }
; 1269 : printf("%30s",taskname);
; 1270 : PROF_PRINT(task_caller)
; 1271 : }
; 1272 : #endif
; 1273 : 
; 1274 :   data->task_state = 2;

	mov	DWORD PTR [esi+8], 2
	pop	esi

; 1275 : 
; 1276 : } // end task_caller()

	pop	ebp
	ret	0
$LN5@task_calle:

; 1242 :       case TH_CALC_FACET_VOLUME: thread_calc_facet_volume(); break;

	call	_thread_calc_facet_volume

; 1248 :     }
; 1249 : PROF_FINISH(task_caller)
; 1250 : 
; 1251 : #ifdef  ZZZZZ
; 1252 : if(verbose_flag)
; 1253 : { char *taskname;
; 1254 :   switch ( thread_tasknum )
; 1255 :     {
; 1256 :       case TH_PROJECT_ALL_TEST: taskname="thread_project_all"; break;
; 1257 :       case TH_PROJECT_ALL_ACTUAL: taskname="thread_project_all"; break;
; 1258 :       case TH_CALC_FACET_ENERGY:
; 1259 :              taskname="thread_calc_facet_energy"; break;
; 1260 :       case TH_CALC_FACET_FORCES: taskname="thread_calc_facet_forces"; break;
; 1261 :       case TH_MULTI_CALC_QUANT: taskname="multi_calc_quants"; break;
; 1262 :       case TH_MULTI_QUANT_GRADS: taskname="m_calc_quant_grads"; break;
; 1263 :       case TH_FIX_GRADS: taskname="m_fix_grads"; break;
; 1264 :       case TH_MULTI_QUANT_HESS: taskname="m_calc_quant_hess"; break;
; 1265 :       case TH_CALC_FACET_VOLUME: taskname="thread_calc_facet_volume"; break;
; 1266 :       case TH_CALC_EDGE_CON_VOLUME: taskname="thread_calc_edge_con_volume"; break;
; 1267 :       default: taskname="default";
; 1268 :     }
; 1269 : printf("%30s",taskname);
; 1270 : PROF_PRINT(task_caller)
; 1271 : }
; 1272 : #endif
; 1273 : 
; 1274 :   data->task_state = 2;

	mov	DWORD PTR [esi+8], 2
	pop	esi

; 1275 : 
; 1276 : } // end task_caller()

	pop	ebp
	ret	0
$LN4@task_calle:

; 1243 :       case TH_CALC_EDGE_CON_VOLUME: thread_calc_edge_con_volume(); break;

	call	_thread_calc_edge_con_volume

; 1248 :     }
; 1249 : PROF_FINISH(task_caller)
; 1250 : 
; 1251 : #ifdef  ZZZZZ
; 1252 : if(verbose_flag)
; 1253 : { char *taskname;
; 1254 :   switch ( thread_tasknum )
; 1255 :     {
; 1256 :       case TH_PROJECT_ALL_TEST: taskname="thread_project_all"; break;
; 1257 :       case TH_PROJECT_ALL_ACTUAL: taskname="thread_project_all"; break;
; 1258 :       case TH_CALC_FACET_ENERGY:
; 1259 :              taskname="thread_calc_facet_energy"; break;
; 1260 :       case TH_CALC_FACET_FORCES: taskname="thread_calc_facet_forces"; break;
; 1261 :       case TH_MULTI_CALC_QUANT: taskname="multi_calc_quants"; break;
; 1262 :       case TH_MULTI_QUANT_GRADS: taskname="m_calc_quant_grads"; break;
; 1263 :       case TH_FIX_GRADS: taskname="m_fix_grads"; break;
; 1264 :       case TH_MULTI_QUANT_HESS: taskname="m_calc_quant_hess"; break;
; 1265 :       case TH_CALC_FACET_VOLUME: taskname="thread_calc_facet_volume"; break;
; 1266 :       case TH_CALC_EDGE_CON_VOLUME: taskname="thread_calc_edge_con_volume"; break;
; 1267 :       default: taskname="default";
; 1268 :     }
; 1269 : printf("%30s",taskname);
; 1270 : PROF_PRINT(task_caller)
; 1271 : }
; 1272 : #endif
; 1273 : 
; 1274 :   data->task_state = 2;

	mov	DWORD PTR [esi+8], 2
	pop	esi

; 1275 : 
; 1276 : } // end task_caller()

	pop	ebp
	ret	0
$LN3@task_calle:

; 1244 :       case TH_EQUIANGULATE: thread_equiangulate(); break;

	call	_thread_equiangulate

; 1248 :     }
; 1249 : PROF_FINISH(task_caller)
; 1250 : 
; 1251 : #ifdef  ZZZZZ
; 1252 : if(verbose_flag)
; 1253 : { char *taskname;
; 1254 :   switch ( thread_tasknum )
; 1255 :     {
; 1256 :       case TH_PROJECT_ALL_TEST: taskname="thread_project_all"; break;
; 1257 :       case TH_PROJECT_ALL_ACTUAL: taskname="thread_project_all"; break;
; 1258 :       case TH_CALC_FACET_ENERGY:
; 1259 :              taskname="thread_calc_facet_energy"; break;
; 1260 :       case TH_CALC_FACET_FORCES: taskname="thread_calc_facet_forces"; break;
; 1261 :       case TH_MULTI_CALC_QUANT: taskname="multi_calc_quants"; break;
; 1262 :       case TH_MULTI_QUANT_GRADS: taskname="m_calc_quant_grads"; break;
; 1263 :       case TH_FIX_GRADS: taskname="m_fix_grads"; break;
; 1264 :       case TH_MULTI_QUANT_HESS: taskname="m_calc_quant_hess"; break;
; 1265 :       case TH_CALC_FACET_VOLUME: taskname="thread_calc_facet_volume"; break;
; 1266 :       case TH_CALC_EDGE_CON_VOLUME: taskname="thread_calc_edge_con_volume"; break;
; 1267 :       default: taskname="default";
; 1268 :     }
; 1269 : printf("%30s",taskname);
; 1270 : PROF_PRINT(task_caller)
; 1271 : }
; 1272 : #endif
; 1273 : 
; 1274 :   data->task_state = 2;

	mov	DWORD PTR [esi+8], 2
	pop	esi

; 1275 : 
; 1276 : } // end task_caller()

	pop	ebp
	ret	0
$LN2@task_calle:

; 1245 :       case TH_CALC_EDGES: thread_calc_edges(); break;

	call	_thread_calc_edges

; 1248 :     }
; 1249 : PROF_FINISH(task_caller)
; 1250 : 
; 1251 : #ifdef  ZZZZZ
; 1252 : if(verbose_flag)
; 1253 : { char *taskname;
; 1254 :   switch ( thread_tasknum )
; 1255 :     {
; 1256 :       case TH_PROJECT_ALL_TEST: taskname="thread_project_all"; break;
; 1257 :       case TH_PROJECT_ALL_ACTUAL: taskname="thread_project_all"; break;
; 1258 :       case TH_CALC_FACET_ENERGY:
; 1259 :              taskname="thread_calc_facet_energy"; break;
; 1260 :       case TH_CALC_FACET_FORCES: taskname="thread_calc_facet_forces"; break;
; 1261 :       case TH_MULTI_CALC_QUANT: taskname="multi_calc_quants"; break;
; 1262 :       case TH_MULTI_QUANT_GRADS: taskname="m_calc_quant_grads"; break;
; 1263 :       case TH_FIX_GRADS: taskname="m_fix_grads"; break;
; 1264 :       case TH_MULTI_QUANT_HESS: taskname="m_calc_quant_hess"; break;
; 1265 :       case TH_CALC_FACET_VOLUME: taskname="thread_calc_facet_volume"; break;
; 1266 :       case TH_CALC_EDGE_CON_VOLUME: taskname="thread_calc_edge_con_volume"; break;
; 1267 :       default: taskname="default";
; 1268 :     }
; 1269 : printf("%30s",taskname);
; 1270 : PROF_PRINT(task_caller)
; 1271 : }
; 1272 : #endif
; 1273 : 
; 1274 :   data->task_state = 2;

	mov	DWORD PTR [esi+8], 2
	pop	esi

; 1275 : 
; 1276 : } // end task_caller()

	pop	ebp
	ret	0
$LN1@task_calle:

; 1246 :       default: sprintf(errmsg,"Invalid thread task: %d\n",thread_tasknum);

	push	ecx
	push	OFFSET ??_C@_0BJ@KADPCLAC@Invalid?5thread?5task?3?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1247 :                kb_error(2192,errmsg,UNRECOVERABLE);

	push	0
	push	OFFSET _errmsg
	push	2192					; 00000890H
	call	_kb_error
	add	esp, 24					; 00000018H

; 1248 :     }
; 1249 : PROF_FINISH(task_caller)
; 1250 : 
; 1251 : #ifdef  ZZZZZ
; 1252 : if(verbose_flag)
; 1253 : { char *taskname;
; 1254 :   switch ( thread_tasknum )
; 1255 :     {
; 1256 :       case TH_PROJECT_ALL_TEST: taskname="thread_project_all"; break;
; 1257 :       case TH_PROJECT_ALL_ACTUAL: taskname="thread_project_all"; break;
; 1258 :       case TH_CALC_FACET_ENERGY:
; 1259 :              taskname="thread_calc_facet_energy"; break;
; 1260 :       case TH_CALC_FACET_FORCES: taskname="thread_calc_facet_forces"; break;
; 1261 :       case TH_MULTI_CALC_QUANT: taskname="multi_calc_quants"; break;
; 1262 :       case TH_MULTI_QUANT_GRADS: taskname="m_calc_quant_grads"; break;
; 1263 :       case TH_FIX_GRADS: taskname="m_fix_grads"; break;
; 1264 :       case TH_MULTI_QUANT_HESS: taskname="m_calc_quant_hess"; break;
; 1265 :       case TH_CALC_FACET_VOLUME: taskname="thread_calc_facet_volume"; break;
; 1266 :       case TH_CALC_EDGE_CON_VOLUME: taskname="thread_calc_edge_con_volume"; break;
; 1267 :       default: taskname="default";
; 1268 :     }
; 1269 : printf("%30s",taskname);
; 1270 : PROF_PRINT(task_caller)
; 1271 : }
; 1272 : #endif
; 1273 : 
; 1274 :   data->task_state = 2;

	mov	DWORD PTR [esi+8], 2
	pop	esi

; 1275 : 
; 1276 : } // end task_caller()

	pop	ebp
	ret	0
	npad	3
$LN19@task_calle:
	DD	$LN14@task_calle
	DD	$LN13@task_calle
	DD	$LN12@task_calle
	DD	$LN11@task_calle
	DD	$LN10@task_calle
	DD	$LN9@task_calle
	DD	$LN7@task_calle
	DD	$LN8@task_calle
	DD	$LN6@task_calle
	DD	$LN5@task_calle
	DD	$LN4@task_calle
	DD	$LN3@task_calle
	DD	$LN1@task_calle
	DD	$LN1@task_calle
	DD	$LN1@task_calle
	DD	$LN2@task_calle
_task_caller ENDP
_TEXT	ENDS
PUBLIC	_winthread_worker@4
EXTRN	__imp__InterlockedDecrement@4:PROC
EXTRN	__imp__TlsSetValue@8:PROC
; Function compile flags: /Ogtp
;	COMDAT _winthread_worker@4
_TEXT	SEGMENT
_arg$ = 8						; size = 4
_winthread_worker@4 PROC				; COMDAT

; 1290 : { struct thread_data *data = (struct thread_data *)arg;

	push	ebp
	mov	ebp, esp

; 1291 : 
; 1292 :   /* set per-thread data */
; 1293 :   TlsSetValue(thread_data_key,(void*)data);

	mov	eax, DWORD PTR _arg$[ebp]
	mov	ecx, DWORD PTR _thread_data_key
	push	ebx
	push	esi
	push	edi
	push	eax
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	mov	esi, DWORD PTR __imp__InterlockedDecrement@4
	mov	ebx, DWORD PTR __imp__SetEvent@4
	mov	edi, DWORD PTR __imp__WaitForSingleObject@8
	npad	7
$LL4@winthread_:

; 1294 :  
; 1295 :   /* Set affinity mask.  Actually seems to hurt. */ 
; 1296 :   /*
; 1297 :   SetThreadAffinityMask(threadlist[data->worker_id],1<<data->worker_id);
; 1298 :   */
; 1299 :   
; 1300 :   /* Loop waiting for wakeup calls.  Use single event rather than event */
; 1301 :   /* for each type of task since MAXIMUM_WAIT_OBJECTS is 64. */
; 1302 :   for (;;)
; 1303 :   { 
; 1304 :     InterlockedDecrement(&busythreads);

	push	OFFSET _busythreads
	call	esi

; 1305 :     if ( busythreads == 0 )

	mov	edx, DWORD PTR _busythreads
	test	edx, edx
	jne	SHORT $LN2@winthread_

; 1306 :     { 
; 1307 :       ResetEvent(workthread_wakeup); 

	mov	eax, DWORD PTR _workthread_wakeup
	push	eax
	call	DWORD PTR __imp__ResetEvent@4

; 1308 :       SetEvent(barrier_event);

	mov	ecx, DWORD PTR _barrier_event
	push	ecx
	call	ebx
$LN2@winthread_:

; 1309 :     }
; 1310 :     WaitForSingleObject(barrier_event,INFINITE);

	mov	edx, DWORD PTR _barrier_event
	push	-1
	push	edx
	call	edi

; 1311 :     InterlockedDecrement(&barrier_count);

	push	OFFSET _barrier_count
	call	esi

; 1312 :     if ( barrier_count == 0 )

	mov	eax, DWORD PTR _barrier_count
	test	eax, eax
	jne	SHORT $LN1@winthread_

; 1313 :        SetEvent(mainthread_wakeup);

	mov	ecx, DWORD PTR _mainthread_wakeup
	push	ecx
	call	ebx
$LN1@winthread_:

; 1314 :     WaitForSingleObject(workthread_wakeup,INFINITE);

	mov	edx, DWORD PTR _workthread_wakeup
	push	-1
	push	edx
	call	edi

; 1315 :     task_caller(thread_task);

	mov	eax, DWORD PTR _thread_task
	push	eax
	call	_task_caller
	add	esp, 4

; 1316 :   }

	jmp	SHORT $LL4@winthread_
_winthread_worker@4 ENDP
_TEXT	ENDS
PUBLIC	_thread_next_element
EXTRN	_valid_element:PROC
EXTRN	_threadflag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _thread_next_element
_TEXT	SEGMENT
_eltype$ = -12						; size = 4
tv329 = -8						; size = 4
_proc$ = -4						; size = 4
_thread_next_element PROC				; COMDAT

; 1796 : { element_id id;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1797 :   int proc,nextproc;
; 1798 :   int eltype;
; 1799 :   struct thread_stages_data *th;
; 1800 :   struct thread_data *data;
; 1801 : 
; 1802 :   long long int now=0;  /* for timing */
; 1803 : 
; 1804 : 
; 1805 :   /* First, in case multithreading not being used */
; 1806 :   if ( threadflag == 0 )

	cmp	DWORD PTR _threadflag, 0
	jne	$LN19@thread_nex

; 1807 :   {
; 1808 :     while ( valid_id(global_id) & !valid_element(global_id) )

	mov	eax, DWORD PTR _global_id
	push	eax
	call	_valid_element
	add	esp, 4
	neg	eax
	sbb	ecx, ecx
	mov	eax, DWORD PTR _global_id
	mov	edx, eax
	shr	edx, 28					; 0000001cH
	inc	ecx
	and	edx, 1
	test	cl, dl
	je	SHORT $LN17@thread_nex
$LL18@thread_nex:

; 1809 :       global_id = elptr(global_id)->forechain;

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	DWORD PTR _global_id, eax
	call	_valid_element
	add	esp, 4
	neg	eax
	sbb	ecx, ecx
	mov	eax, DWORD PTR _global_id
	mov	edx, eax
	shr	edx, 28					; 0000001cH
	inc	ecx
	and	edx, 1
	test	cl, dl
	jne	SHORT $LL18@thread_nex
$LN17@thread_nex:

; 1810 :     if ( !valid_id(global_id) ) return NULLID;

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN16@thread_nex
	xor	eax, eax

; 1850 : #endif
; 1851 :       }
; 1852 :     }
; 1853 :   } 
; 1854 :   return id;
; 1855 : } // end thread_next_element()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@thread_nex:

; 1811 : 
; 1812 :     id = global_id;
; 1813 :     global_id = elptr(id)->forechain;

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ecx+12]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR _global_id, ecx

; 1850 : #endif
; 1851 :       }
; 1852 :     }
; 1853 :   } 
; 1854 :   return id;
; 1855 : } // end thread_next_element()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@thread_nex:

; 1814 :     return id;
; 1815 :   }
; 1816 : 
; 1817 :   data = GET_THREAD_DATA;

	mov	edx, DWORD PTR _thread_data_key
	push	ebx
	push	esi
	push	edi
	push	edx
	call	_win_get_thread_data
	mov	edi, eax

; 1818 :   proc = data->worker_id;

	mov	ebx, DWORD PTR [edi]

; 1819 :   th = thread_stages + proc;
; 1820 :   eltype = id_type(global_id);

	mov	eax, DWORD PTR _global_id
	mov	ecx, ebx
	imul	ecx, 548				; 00000224H
	add	ecx, DWORD PTR _thread_stages
	shr	eax, 29					; 0000001dH

; 1821 :   for (;;)  /* loop just for case when starting new stage */
; 1822 :   {
; 1823 :     if ( th->spot < th->counts[eltype][th->stage] )

	mov	esi, DWORD PTR [ecx+540]
	lea	edx, DWORD PTR [eax+eax*8+45]
	add	esi, edx
	mov	DWORD PTR tv329[ebp], edx
	mov	edx, DWORD PTR [ecx+544]
	add	esp, 4
	mov	DWORD PTR _proc$[ebp], ebx
	mov	DWORD PTR _eltype$[ebp], eax
	cmp	edx, DWORD PTR [ecx+esi*4]
	jl	$LN32@thread_nex
	npad	11
$LL15@thread_nex:

; 1825 :       break;
; 1826 :     }
; 1827 :     else
; 1828 :     { th->stage++;  /* signify done */

	inc	DWORD PTR [ecx+540]

; 1829 : #ifdef _MSC_VER
; 1830 : PROF_NOW(now);
; 1831 : data->stageend[th->stage-1] = now;

	mov	esi, DWORD PTR [ecx+540]
	rdtsc
	mov	DWORD PTR [edi+esi*8+1872], eax
	mov	DWORD PTR [edi+esi*8+1876], edx

; 1832 : #endif
; 1833 :       th->spot = 0;

	mov	DWORD PTR [ecx+544], 0

; 1834 :       if ( th->stage == ((proc==0) ? max_thread_stages+1 : max_thread_stages) )

	mov	eax, DWORD PTR _max_thread_stages
	test	ebx, ebx
	jne	SHORT $LN23@thread_nex
	inc	eax
$LN23@thread_nex:
	mov	edx, DWORD PTR [ecx+540]
	cmp	edx, eax
	je	$LN33@thread_nex

; 1836 :         break;
; 1837 :       }
; 1838 :       else /* look for next stage */
; 1839 :       { if ( th->stage < max_thread_stages )

	mov	eax, DWORD PTR [ecx+540]
	cmp	eax, DWORD PTR _max_thread_stages
	jge	SHORT $LN9@thread_nex

; 1840 :         {  nextproc = (proc == nprocs - 1) ? 0 : proc+1;

	mov	edx, DWORD PTR _nprocs
	dec	edx
	cmp	ebx, edx
	jne	SHORT $LN24@thread_nex
	xor	eax, eax
	jmp	SHORT $LN25@thread_nex
$LN24@thread_nex:
	lea	eax, DWORD PTR [ebx+1]
$LN25@thread_nex:
	imul	eax, 548				; 00000224H
	npad	12
$LL8@thread_nex:

; 1841 :            while ( thread_stages[nextproc].stage < th->stage ) ;  /* wait */

	mov	edx, DWORD PTR _thread_stages
	mov	edx, DWORD PTR [eax+edx+540]
	mov	esi, DWORD PTR [ecx+540]
	cmp	edx, esi
	jl	SHORT $LL8@thread_nex

; 1842 :         }
; 1843 :         else /* proc 0 to do big elements */

	jmp	SHORT $LN3@thread_nex
$LN9@thread_nex:

; 1844 :         { for ( nextproc = 1 ; nextproc < nprocs ; nextproc++ )

	mov	eax, 1
	cmp	DWORD PTR _nprocs, eax
	jle	SHORT $LN3@thread_nex
	mov	edx, 1088				; 00000440H
	npad	5
$LL2@thread_nex:

; 1845 :            while ( thread_stages[nextproc].stage < th->stage ) ;  /* wait */

	mov	esi, DWORD PTR _thread_stages
	mov	esi, DWORD PTR [edx+esi]
	mov	ebx, DWORD PTR [ecx+540]
	cmp	esi, ebx
	jl	SHORT $LL2@thread_nex

; 1844 :         { for ( nextproc = 1 ; nextproc < nprocs ; nextproc++ )

	inc	eax
	add	edx, 548				; 00000224H
	cmp	eax, DWORD PTR _nprocs
	jl	SHORT $LL2@thread_nex
	mov	ebx, DWORD PTR _proc$[ebp]
$LN3@thread_nex:

; 1846 :         }  
; 1847 : #ifdef _MSC_VER
; 1848 : PROF_NOW(now);
; 1849 : data->stagestart[th->stage] = now;

	mov	esi, DWORD PTR [ecx+540]
	rdtsc
	mov	DWORD PTR [edi+esi*8+1808], eax
	mov	DWORD PTR [edi+esi*8+1812], edx
	mov	eax, DWORD PTR [ecx+540]
	add	eax, DWORD PTR tv329[ebp]
	mov	edx, DWORD PTR [ecx+544]
	cmp	edx, DWORD PTR [ecx+eax*4]
	jge	$LL15@thread_nex

; 1821 :   for (;;)  /* loop just for case when starting new stage */
; 1822 :   {
; 1823 :     if ( th->spot < th->counts[eltype][th->stage] )

	mov	eax, DWORD PTR _eltype$[ebp]
$LN32@thread_nex:

; 1824 :     { id = th->blocks[eltype][th->stage][th->spot++];

	mov	esi, DWORD PTR [ecx+540]
	mov	edx, DWORD PTR [ecx+544]
	lea	eax, DWORD PTR [eax+eax*8]
	add	eax, esi
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+edx*4]
	pop	edi
	inc	edx
	pop	esi
	mov	DWORD PTR [ecx+544], edx
	pop	ebx

; 1850 : #endif
; 1851 :       }
; 1852 :     }
; 1853 :   } 
; 1854 :   return id;
; 1855 : } // end thread_next_element()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@thread_nex:
	pop	edi
	pop	esi

; 1835 :       { id = NULLID;

	xor	eax, eax
	pop	ebx

; 1850 : #endif
; 1851 :       }
; 1852 :     }
; 1853 :   } 
; 1854 :   return id;
; 1855 : } // end thread_next_element()

	mov	esp, ebp
	pop	ebp
	ret	0
_thread_next_element ENDP
_TEXT	ENDS
PUBLIC	??_C@_05MHOFLBOO@stdin?$AA@			; `string'
PUBLIC	??_C@_0CH@FFHPDDF@Extra?5command?5line?5arguments?5ign@ ; `string'
PUBLIC	??_C@_0DE@GCOFAIKO@Created?5?$CFd?5worker?5threads?5on?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0FG@IKHOPOID@Cannot?5set?5affinity?5of?5worker?5th@ ; `string'
PUBLIC	??_C@_0CN@NAEJCMBF@Set?5affinity?5of?5worker?5thread?5?$CFd@ ; `string'
PUBLIC	??_C@_0BP@BDKMGAFD@Cannot?5create?5worker?5threads?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@HBHLBOMI@Failed?5to?5enter?5I?1O?5layer?5mode?$AA@ ; `string'
PUBLIC	??_C@_0CH@NGDDKCCO@Set?5affinity?5of?5main?5thread?5to?5c@ ; `string'
PUBLIC	??_C@_0DC@PHCLOHKK@Pausing?5due?5to?5?9Z?5option?4?5Hit?5EN@ ; `string'
PUBLIC	??_C@_0CK@DFJMJICF@?5?5?9h?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5print?5t@ ; `string'
PUBLIC	??_C@_0DA@FCNELPGG@?5?5?9pn?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5use?5n?5w@ ; `string'
PUBLIC	??_C@_0CO@BNFHPOGE@?5?5?9m?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5memory?5@ ; `string'
PUBLIC	??_C@_0CO@KNAPIEDP@?5?5?9d?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5parser?5@ ; `string'
PUBLIC	??_C@_0CO@IOEOGMKH@?5?5?9y?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5break?5a@ ; `string'
PUBLIC	??_C@_0CN@GPPPFMIP@?5?5?9w?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5exit?5af@ ; `string'
PUBLIC	??_C@_0CL@HLFJHKHP@?5?5?9x?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5exit?5af@ ; `string'
PUBLIC	??_C@_0EH@KPMJFDKA@?5?5?9a?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5auto?5co@ ; `string'
PUBLIC	??_C@_0DG@PNABHOIJ@?5?5?9q?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5convert@ ; `string'
PUBLIC	??_C@_0DI@GJIELDDD@?5?5?9i?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5use?5id?5@ ; `string'
PUBLIC	??_C@_0CP@CFHHDJJ@?5?5?9ffilename?5?5?5?5?5?5?5?5?5?5take?5comma@ ; `string'
PUBLIC	??_C@_0BB@CALHPDE@Legal?5options?3?5?6?$AA@	; `string'
PUBLIC	??_C@_0BE@MGCJELGD@Illegal?5option?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0ED@POEJMLIP@Threads?5set?5to?5?$CFd?4?5Recompile?5wit@ ; `string'
PUBLIC	??_C@_0DJ@KPIECAMP@This?5Evolver?5only?5compiled?5for?5a@ ; `string'
PUBLIC	??_C@_0CP@LBANCBEK@?9p?5with?5nonpositive?5number?4?5Thre@ ; `string'
PUBLIC	??_C@_0CF@HEGAMOJB@Successfully?5entered?5I?1O?5layer?5m@ ; `string'
PUBLIC	??_C@_0CE@DOHCHCPK@?2communication?2history?2png_path?4@ ; `string'
PUBLIC	??_C@_0BD@HFAIHCGO@?2communication?2br?2?$AA@	; `string'
PUBLIC	??_C@_01MCMALHOG@a?$AA@				; `string'
PUBLIC	??_C@_0BE@OPGILNCF@?2communication?2out?2?$AA@	; `string'
PUBLIC	??_C@_0CG@POPNAIIB@Levolver?5Error?3?5Cannot?5Open?5?9F?$DN?$DM@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0BD@LHDFKPHL@?2communication?2in?2?$AA@	; `string'
PUBLIC	??_C@_0DK@GFFGCGIG@Levolver?5Error?3?5current?5working?5@ ; `string'
PUBLIC	??_C@_0DM@EJAOCHNH@Levolver?5Error?3?5missing?5second?5?3@ ; `string'
PUBLIC	??_C@_0DF@GDOFOJFC@Levolver?5Error?3?5missing?5?3?5in?5com@ ; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	__real@4024000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_0BM@GGHEKEIC@Surface?5Evolver?5?$CFs?0?5?$CFd?9bit?6?$AA@ ; `string'
PUBLIC	_argv$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_main
EXTRN	_mpi_initialization_flag:DWORD
EXTRN	_loadfilename:BYTE
EXTRN	_myfree:PROC
EXTRN	_permlist:DWORD
EXTRN	_list:DWORD
EXTRN	_loadjumpbuf:BYTE
EXTRN	_jumpbuf:BYTE
EXTRN	_vcoeff_init:PROC
EXTRN	_scoeff_init:PROC
EXTRN	_catcher:PROC
EXTRN	_default_thread_data_ptr:DWORD
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__FormatMessageA@28:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__InitializeCriticalSectionAndSpinCount@8:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	_default_thread_data:BYTE
EXTRN	__imp__TlsAlloc@0:PROC
EXTRN	_main_thread_id:DWORD
EXTRN	_break_after_warning:DWORD
EXTRN	_exit_after_warning:DWORD
EXTRN	_default_random_seed:DWORD
EXTRN	_sparse_ibase_flag:DWORD
EXTRN	_match_id_flag:DWORD
EXTRN	_yydebug:DWORD
EXTRN	_strncpy:PROC
EXTRN	_ActivatePngPathLogic:PROC
EXTRN	_l_brfd:DWORD
EXTRN	_l_outfd:DWORD
EXTRN	_l_infd:DWORD
EXTRN	_fopen:PROC
EXTRN	_l_evolver_mode:DWORD
EXTRN	__getcwd:PROC
EXTRN	_GraphicsWindowTitleText:DWORD
EXTRN	_GraphicsWindowTitleTextBuffer:BYTE
EXTRN	_ProgramBreakDelay:DWORD
EXTRN	_cProgramBreakDelay:DWORD
EXTRN	_y_pixel_down_cmd_line:DWORD
EXTRN	_y_pixel_height_cmd_line:DWORD
EXTRN	_x_pixel_width_cmd_line:DWORD
EXTRN	_atoi:PROC
EXTRN	_fputs:PROC
EXTRN	_kb_strstr:PROC
EXTRN	_echo_flag:DWORD
EXTRN	_quiet_load_flag:DWORD
EXTRN	_option_q:DWORD
EXTRN	_auto_convert_flag:DWORD
EXTRN	_err_tok_gen_flag:DWORD
EXTRN	__imp__FreeConsole@0:PROC
EXTRN	_print_express:PROC
EXTRN	_transforms_mutex:DWORD
EXTRN	_mem_mutex:DWORD
EXTRN	__imp__CreateMutexA@12:PROC
EXTRN	_DWIDTH:DWORD
EXTRN	_DPREC:DWORD
EXTRN	_root8machine_eps:QWORD
EXTRN	_machine_eps:QWORD
EXTRN	_outstring:PROC
EXTRN	_VERSION:DWORD
EXTRN	_erroutfd:DWORD
EXTRN	_outfd:DWORD
EXTRN	___iob_func:PROC
EXTRN	_set_ctypes:PROC
EXTRN	_list_calloc:PROC
EXTRN	_msgmax:DWORD
EXTRN	__setjmp3:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_floor:PROC
EXTRN	__CIlog:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT ??_C@_05MHOFLBOO@stdin?$AA@
CONST	SEGMENT
??_C@_05MHOFLBOO@stdin?$AA@ DB 'stdin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FFHPDDF@Extra?5command?5line?5arguments?5ign@
CONST	SEGMENT
??_C@_0CH@FFHPDDF@Extra?5command?5line?5arguments?5ign@ DB 'Extra command'
	DB	' line arguments ignored.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@GCOFAIKO@Created?5?$CFd?5worker?5threads?5on?5?$CFd?5@
CONST	SEGMENT
??_C@_0DE@GCOFAIKO@Created?5?$CFd?5worker?5threads?5on?5?$CFd?5@ DB 'Crea'
	DB	'ted %d worker threads on %d processor machine.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@IKHOPOID@Cannot?5set?5affinity?5of?5worker?5th@
CONST	SEGMENT
??_C@_0FG@IKHOPOID@Cannot?5set?5affinity?5of?5worker?5th@ DB 'Cannot set '
	DB	'affinity of worker thread %d to cpu %d; ', 0aH, '  process af'
	DB	'finity mask is 0x%X.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NAEJCMBF@Set?5affinity?5of?5worker?5thread?5?$CFd@
CONST	SEGMENT
??_C@_0CN@NAEJCMBF@Set?5affinity?5of?5worker?5thread?5?$CFd@ DB 'Set affi'
	DB	'nity of worker thread %d to cpu %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BDKMGAFD@Cannot?5create?5worker?5threads?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@BDKMGAFD@Cannot?5create?5worker?5threads?4?6?$AA@ DB 'Cannot cr'
	DB	'eate worker threads.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HBHLBOMI@Failed?5to?5enter?5I?1O?5layer?5mode?$AA@
CONST	SEGMENT
??_C@_0BP@HBHLBOMI@Failed?5to?5enter?5I?1O?5layer?5mode?$AA@ DB 'Failed t'
	DB	'o enter I/O layer mode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NGDDKCCO@Set?5affinity?5of?5main?5thread?5to?5c@
CONST	SEGMENT
??_C@_0CH@NGDDKCCO@Set?5affinity?5of?5main?5thread?5to?5c@ DB 'Set affini'
	DB	'ty of main thread to cpu 0.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@PHCLOHKK@Pausing?5due?5to?5?9Z?5option?4?5Hit?5EN@
CONST	SEGMENT
??_C@_0DC@PHCLOHKK@Pausing?5due?5to?5?9Z?5option?4?5Hit?5EN@ DB 'Pausing '
	DB	'due to -Z option. Hit ENTER to continue.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DFJMJICF@?5?5?9h?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5print?5t@
CONST	SEGMENT
??_C@_0CK@DFJMJICF@?5?5?9h?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5print?5t@ DB ' '
	DB	' -h                     print this help', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FCNELPGG@?5?5?9pn?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5use?5n?5w@
CONST	SEGMENT
??_C@_0DA@FCNELPGG@?5?5?9pn?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5use?5n?5w@ DB ' '
	DB	' -pn                    use n worker threads ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BNFHPOGE@?5?5?9m?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5memory?5@
CONST	SEGMENT
??_C@_0CO@BNFHPOGE@?5?5?9m?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5memory?5@ DB ' '
	DB	' -m                     memory debugging on', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KNAPIEDP@?5?5?9d?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5parser?5@
CONST	SEGMENT
??_C@_0CO@KNAPIEDP@?5?5?9d?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5parser?5@ DB ' '
	DB	' -d                     parser debugging on', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IOEOGMKH@?5?5?9y?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5break?5a@
CONST	SEGMENT
??_C@_0CO@IOEOGMKH@?5?5?9y?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5break?5a@ DB ' '
	DB	' -y                     break after warning', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GPPPFMIP@?5?5?9w?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5exit?5af@
CONST	SEGMENT
??_C@_0CN@GPPPFMIP@?5?5?9w?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5exit?5af@ DB ' '
	DB	' -w                     exit after warning', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HLFJHKHP@?5?5?9x?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5exit?5af@
CONST	SEGMENT
??_C@_0CL@HLFJHKHP@?5?5?9x?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5exit?5af@ DB ' '
	DB	' -x                     exit after error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@KPMJFDKA@?5?5?9a?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5auto?5co@
CONST	SEGMENT
??_C@_0EH@KPMJFDKA@?5?5?9a?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5auto?5co@ DB ' '
	DB	' -a                     auto convert to named quantities when'
	DB	' needed', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@PNABHOIJ@?5?5?9q?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5convert@
CONST	SEGMENT
??_C@_0DG@PNABHOIJ@?5?5?9q?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5convert@ DB ' '
	DB	' -q                     convert to named quantities', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@GJIELDDD@?5?5?9i?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5use?5id?5@
CONST	SEGMENT
??_C@_0DI@GJIELDDD@?5?5?9i?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5use?5id?5@ DB ' '
	DB	' -i                     use id numbers as in datafile', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@CFHHDJJ@?5?5?9ffilename?5?5?5?5?5?5?5?5?5?5take?5comma@
CONST	SEGMENT
??_C@_0CP@CFHHDJJ@?5?5?9ffilename?5?5?5?5?5?5?5?5?5?5take?5comma@ DB '  -'
	DB	'ffilename          take commands from file', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CALHPDE@Legal?5options?3?5?6?$AA@
CONST	SEGMENT
??_C@_0BB@CALHPDE@Legal?5options?3?5?6?$AA@ DB 'Legal options: ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGCJELGD@Illegal?5option?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BE@MGCJELGD@Illegal?5option?3?5?$CFs?6?$AA@ DB 'Illegal option: %s'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@POEJMLIP@Threads?5set?5to?5?$CFd?4?5Recompile?5wit@
CONST	SEGMENT
??_C@_0ED@POEJMLIP@Threads?5set?5to?5?$CFd?4?5Recompile?5wit@ DB 'Threads'
	DB	' set to %d. Recompile with -DMAXPROCS=%d if you want more.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@KPIECAMP@This?5Evolver?5only?5compiled?5for?5a@
CONST	SEGMENT
??_C@_0DJ@KPIECAMP@This?5Evolver?5only?5compiled?5for?5a@ DB 'This Evolve'
	DB	'r only compiled for a maximum of %d threads.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LBANCBEK@?9p?5with?5nonpositive?5number?4?5Thre@
CONST	SEGMENT
??_C@_0CP@LBANCBEK@?9p?5with?5nonpositive?5number?4?5Thre@ DB '-p with no'
	DB	'npositive number. Threads set to 1.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HEGAMOJB@Successfully?5entered?5I?1O?5layer?5m@
CONST	SEGMENT
??_C@_0CF@HEGAMOJB@Successfully?5entered?5I?1O?5layer?5m@ DB 'Successfull'
	DB	'y entered I/O layer mode', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DOHCHCPK@?2communication?2history?2png_path?4@
CONST	SEGMENT
??_C@_0CE@DOHCHCPK@?2communication?2history?2png_path?4@ DB '\communicati'
	DB	'on\history\png_path.txt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HFAIHCGO@?2communication?2br?2?$AA@
CONST	SEGMENT
??_C@_0BD@HFAIHCGO@?2communication?2br?2?$AA@ DB '\communication\br\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT
??_C@_01MCMALHOG@a?$AA@ DB 'a', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OPGILNCF@?2communication?2out?2?$AA@
CONST	SEGMENT
??_C@_0BE@OPGILNCF@?2communication?2out?2?$AA@ DB '\communication\out\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@POPNAIIB@Levolver?5Error?3?5Cannot?5Open?5?9F?$DN?$DM@
CONST	SEGMENT
??_C@_0CG@POPNAIIB@Levolver?5Error?3?5Cannot?5Open?5?9F?$DN?$DM@ DB 'Levo'
	DB	'lver Error: Cannot Open -F=<file>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LHDFKPHL@?2communication?2in?2?$AA@
CONST	SEGMENT
??_C@_0BD@LHDFKPHL@?2communication?2in?2?$AA@ DB '\communication\in\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@GFFGCGIG@Levolver?5Error?3?5current?5working?5@
CONST	SEGMENT
??_C@_0DK@GFFGCGIG@Levolver?5Error?3?5current?5working?5@ DB 'Levolver Er'
	DB	'ror: current working directory name too long!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EJAOCHNH@Levolver?5Error?3?5missing?5second?5?3@
CONST	SEGMENT
??_C@_0DM@EJAOCHNH@Levolver?5Error?3?5missing?5second?5?3@ DB 'Levolver E'
	DB	'rror: missing second : in command line option -S', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GDOFOJFC@Levolver?5Error?3?5missing?5?3?5in?5com@
CONST	SEGMENT
??_C@_0DF@GDOFOJFC@Levolver?5Error?3?5missing?5?3?5in?5com@ DB 'Levolver '
	DB	'Error: missing : in command line option -S', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_0BM@GGHEKEIC@Surface?5Evolver?5?$CFs?0?5?$CFd?9bit?6?$AA@
CONST	SEGMENT
??_C@_0BM@GGHEKEIC@Surface?5Evolver?5?$CFs?0?5?$CFd?9bit?6?$AA@ DB 'Surfa'
	DB	'ce Evolver %s, %d-bit', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _main
_TEXT	SEGMENT
_si$81557 = -2148					; size = 36
_one$81423 = -2112					; size = 8
_eps$81422 = -2104					; size = 8
_tid$81572 = -2096					; size = 4
_retval$81556 = -2092					; size = 4
tv970 = -2088						; size = 8
_system_affinity_mask$81586 = -2084			; size = 4
_proc_affinity_mask$81585 = -2080			; size = 4
_colon_character_pointer2$ = -2076			; size = 4
_c$81503 = -2072					; size = 4
_colon_character_pointer$ = -2068			; size = 4
_plevolverpath$ = -2064					; size = 4
_pause_flag$ = -2060					; size = 4
_argv$GSCopy$ = -2056					; size = 4
_levolverpath$ = -2052					; size = 1024
_lfname$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 104  : { int pause_flag=0;  /* whether to pause after banner message */

	push	ebp
	mov	ebp, esp
	sub	esp, 2148				; 00000864H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _argv$[ebp]
	xor	eax, eax
	push	esi
	push	edi
	mov	DWORD PTR _argv$GSCopy$[ebp], ebx
	mov	DWORD PTR _pause_flag$[ebp], eax

; 105  : #ifdef __L_EVOLVER__
; 106  :   char *plevolverpath=NULL , levolverpath[1024];

	mov	DWORD PTR _plevolverpath$[ebp], eax

; 107  :   char lfname[1024];   /*"\\Evolver\\communication\\"..*/
; 108  :   extern void ActivatePngPathLogic(char *lfname);
; 109  :   char *colon_character_pointer;
; 110  :   char *colon_character_pointer2;
; 111  : #endif
; 112  :   msgmax = 2000; 

	mov	DWORD PTR _msgmax, 2000			; 000007d0H

; 113  :   if ( !msg ) msg = my_list_calloc(1,msgmax,ETERNAL_BLOCK); 

	lea	edi, DWORD PTR [eax+1]
	cmp	DWORD PTR _msg, eax
	jne	SHORT $LN104@main
	push	113					; 00000071H
	push	OFFSET ??_C@_07KINGIIKE@tmain?4c?$AA@
	push	60138					; 0000eaeaH
	push	2000					; 000007d0H
	push	edi
	call	_list_calloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _msg, eax
$LN104@main:

; 114  :   set_ctypes();

	call	_set_ctypes

; 115  : 
; 116  :   outfd = stdout;

	call	___iob_func
	add	eax, 32					; 00000020H
	mov	DWORD PTR _outfd, eax

; 117  :   erroutfd = stderr;

	call	___iob_func

; 118  :   sprintf(msg,"Surface Evolver %s, %d-bit\n",VERSION,8*(int)sizeof(int*));

	mov	ecx, DWORD PTR _msg
	add	eax, 64					; 00000040H
	mov	DWORD PTR _erroutfd, eax
	mov	eax, DWORD PTR _VERSION
	push	32					; 00000020H
	push	eax
	push	OFFSET ??_C@_0BM@GGHEKEIC@Surface?5Evolver?5?$CFs?0?5?$CFd?9bit?6?$AA@
	push	ecx
	call	_sprintf

; 119  :   outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 120  : #ifdef LONG_ID
; 121  :   if ( sizeof(int*) == 8 )
; 122  :   { sprintf(msg,"Compiled with LONG_ID, for extraordinarily large models.\n",
; 123  :       OFFSETMASK);
; 124  :     outstring(msg);
; 125  :   }
; 126  : #endif
; 127  : 
; 128  :   // Calculate REAL precision
; 129  :   /* find machine resolution */
; 130  :   { REAL eps,one = 1.0;

	fld1
	fst	QWORD PTR _one$81423[ebp]
	add	esp, 20					; 00000014H

; 131  :     for ( eps = 1.0 ; one + eps != one ; eps /= 2.0 ) ;

	fld	ST(0)
	fld	QWORD PTR __real@3fe0000000000000
$LN103@main:
	fmul	ST(1), ST(0)
	fld	ST(1)
	fadd	ST(0), ST(3)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN103@main
	fstp	ST(2)
	fstp	ST(1)
	fst	QWORD PTR _eps$81422[ebp]

; 132  :     machine_eps = 2.0*eps;

	fadd	ST(0), ST(0)
	fst	QWORD PTR _machine_eps

; 133  :     root8machine_eps = sqrt(sqrt(sqrt(machine_eps)));

	call	__CIsqrt
	call	__CIsqrt
	call	__CIsqrt
	fstp	QWORD PTR _root8machine_eps

; 134  :     DPREC = floor(-log(machine_eps)/log(10.0));

	fld	QWORD PTR _machine_eps
	call	__CIlog
	fstp	QWORD PTR tv970[ebp]
	fld	QWORD PTR __real@4024000000000000
	call	__CIlog
	fdivr	QWORD PTR tv970[ebp]
	sub	esp, 8
	fchs
	fstp	QWORD PTR [esp]
	call	_floor
	call	__ftol2_sse
	mov	DWORD PTR _DPREC, eax

; 135  :     DWIDTH = DPREC + 3;

	add	eax, 3

; 136  :   }
; 137  : 
; 138  : #ifdef FLOAT128
; 139  :   sprintf(msg,"Compiled for float128, %d digits precision.\n",DPREC);
; 140  :   outstring(msg);
; 141  : #elif defined(LONGDOUBLE)
; 142  :   sprintf(msg,"Compiled for %d-byte long double, %d digits precision.\n",(int)sizeof(REAL),DPREC);
; 143  :   outstring(msg);
; 144  : #endif
; 145  :   outstring("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	DWORD PTR _DWIDTH, eax
	call	_outstring

; 146  : 
; 147  : #ifdef MPI_EVOLVER
; 148  :   MPI_Barrier(MPI_COMM_WORLD); /* wait for everybody to print */
; 149  : #endif
; 150  : 
; 151  : 
; 152  :  if ( sizeof(element_id) > sizeof(REAL) )
; 153  :     kb_error(3102,"Bad datatype sizes: element_id is %d bytes, but REAL is %d.\n",
; 154  :       UNRECOVERABLE);
; 155  :       
; 156  : #ifdef _HISTORY_H_
; 157  :  /* readline history initialization */
; 158  :  using_history(); 
; 159  : #endif
; 160  : 
; 161  : #ifdef SGI_MULTI
; 162  :   procs_requested = 1;  /* default at John's request.  m_get_numprocs(); */
; 163  : #endif
; 164  : 
; 165  : #ifdef WIN32
; 166  : /* Mutex for use between graph thread and main thread. */
; 167  : /* Nameless to prevent interference between separate processes. */
; 168  :   graphmutex = CreateMutex(NULL,0,NULL);

	mov	esi, DWORD PTR __imp__CreateMutexA@12
	add	esp, 12					; 0000000cH
	push	0
	push	0
	push	0
	call	esi

; 169  :   mem_mutex = CreateMutex(NULL,0,NULL);

	push	0
	push	0
	push	0
	mov	DWORD PTR _graphmutex, eax
	call	esi

; 170  :   transforms_mutex = CreateMutex(NULL,0,NULL);

	push	0
	push	0
	push	0
	mov	DWORD PTR _mem_mutex, eax
	call	esi

; 171  : 
; 172  : 
; 173  : #ifdef MPI_EVOLVER
; 174  :   mpi_mutex = CreateMutex(NULL,0,NULL);
; 175  : #endif
; 176  : #elif defined(PTHREADS)
; 177  :   pthread_mutex_init(&graphmutex,NULL);
; 178  :   pthread_mutex_init(&transforms_mutex,NULL);
; 179  :   pthread_mutex_init(&mem_mutex,NULL);
; 180  : #ifdef MPI_EVOLVER
; 181  :   pthread_mutex_init(&mpi_mutex,NULL);
; 182  : #endif
; 183  : #endif
; 184  : 
; 185  : 
; 186  : 
; 187  :   print_express(NULL,0); /* just to initialize string allocation */

	push	0
	push	0
	mov	DWORD PTR _transforms_mutex, eax
	call	_print_express
	add	esp, 8

; 188  : 
; 189  :   find_cpu_speed();

	call	_find_cpu_speed

; 190  :   
; 191  :   /* parse command line options */
; 192  :   if ( argc > 0 )

	cmp	DWORD PTR _argc$[ebp], 0
	jle	$LN97@main

; 193  :   {
; 194  :      argv++; argc--;

	add	ebx, 4
	sub	DWORD PTR _argc$[ebp], edi
	mov	DWORD PTR _argv$GSCopy$[ebp], ebx

; 195  :      while (  argc && (argv[0] != NULL) && (argv[0][0] == '-') )

	je	$LN97@main
$LN98@main:
	cmp	DWORD PTR [ebx], 0
	je	$LN150@main
	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax], 45			; 0000002dH
	jne	$LN150@main

; 196  :      { switch ( argv[0][1] )

	movsx	ecx, BYTE PTR [eax+1]
	add	ecx, -65				; ffffffbfH
	cmp	ecx, 56					; 00000038H
	ja	$LN33@main
	movzx	ecx, BYTE PTR $LN127@main[ecx]
	jmp	DWORD PTR $LN158@main[ecx*4]
$LN94@main:

; 197  :      {    case 'U': 
; 198  : #ifdef WIN32
; 199  :           FreeConsole();

	call	DWORD PTR __imp__FreeConsole@0

; 200  : #endif
; 201  :             break;

	jmp	$LN95@main
$LN93@main:

; 202  :           case 'E': err_tok_gen_flag = 1;

	mov	DWORD PTR _err_tok_gen_flag, edi

; 203  :                     break;

	jmp	$LN95@main
$LN92@main:

; 204  :           case 'a': auto_convert_flag = (argv[0][2]=='-') ? 0 : 1; break;

	xor	edx, edx
	cmp	BYTE PTR [eax+2], 45			; 0000002dH
	setne	dl
	mov	DWORD PTR _auto_convert_flag, edx
	jmp	$LN95@main
$LN91@main:

; 205  :           case 'q': option_q = (argv[0][2]=='-') ? 0 : 1; break; 

	xor	ecx, ecx
	cmp	BYTE PTR [eax+2], 45			; 0000002dH
	setne	cl
	mov	DWORD PTR _option_q, ecx
	jmp	$LN95@main
$LN90@main:

; 206  :           case 'Q': quiet_load_flag = 1; break;

	mov	DWORD PTR _quiet_load_flag, edi
	jmp	$LN95@main
$LN89@main:

; 207  :           case 'e': echo_flag = 1; break;

	mov	DWORD PTR _echo_flag, edi
	jmp	$LN95@main
$LN88@main:

; 208  : 		  case 'Z': pause_flag = 1; break;  /* chance to attach debugger */

	mov	DWORD PTR _pause_flag$[ebp], edi
	jmp	$LN95@main
$LN87@main:

; 209  : #ifdef MPI_EVOLVER
; 210  :           case 'z': mpi_debug = 1; break;
; 211  : #endif
; 212  :           case 't': tty_flag = 1;

	mov	DWORD PTR _tty_flag, edi

; 213  :                 break; 

	jmp	$LN95@main
$LN85@main:

; 214  :           case 'u': tty_flag = 1; 
; 215  :                 break; 
; 216  :           case 'f' : /* commands from file */
; 217  :                  cmdfilename = argv[0]+2;

	add	eax, 2
	mov	DWORD PTR _cmdfilename, eax

; 218  :                  if ( cmdfilename[0] == 0 ) /* probably a space inserted */

	cmp	BYTE PTR [eax], 0
	jne	$LN95@main

; 219  :                     { cmdfilename = *++argv; argc--; }

	mov	edx, DWORD PTR [ebx+4]
	add	ebx, 4
	sub	DWORD PTR _argc$[ebp], edi
	mov	DWORD PTR _cmdfilename, edx

; 220  :                  break;

	jmp	$LN95@main
$LN83@main:

; 221  : #ifdef __L_EVOLVER__
; 222  : /* When Evolver starts with the command line option "-F=<Filename>" I/O goes
; 223  :     through a file layer, i.e. Evolver attempts to access 3 unique files for
; 224  :     input, output, and break commands (control-c). If needed this can be expanded
; 225  :     to include a file that logs total_energy.
; 226  : 
; 227  :     This was created because there was some problems using pipes with FIT sending
; 228  :     break commands, getting total_energy from output, and needing to log commands.
; 229  : 
; 230  : 	When Evolver starts with the command line option "-G=<Title>" the graphics
; 231  : 	window will display the Title text rather then the filename
; 232  :     
; 233  : */
; 234  : 		  case 'S':
; 235  : 
; 236  : 			  if( argv[0][2] = '=' )

	mov	BYTE PTR [eax+2], 61			; 0000003dH

; 237  : 			  //{
; 238  : 				 // ScreenSizeIndex = atoi(argv[0]+3);
; 239  : 			  //}
; 240  : 			    //modified by Y. Chen, 12/05/2011, for proper window position in the SE-FIT viewer
; 241  : 				{
; 242  : 				/* first find ':' , process last number, second number, then first number; */
; 243  : 				colon_character_pointer = strstr(argv[0]+3, ":");

	mov	eax, DWORD PTR [ebx]
	add	eax, 3
	push	OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
	push	eax
	call	_kb_strstr
	mov	esi, eax
	add	esp, 8
	mov	DWORD PTR _colon_character_pointer$[ebp], esi

; 244  : 				if (!colon_character_pointer)

	test	esi, esi
	jne	SHORT $LN81@main

; 245  : 					fputs("Levolver Error: missing : in command line option -S\n",stdout);

	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	push	OFFSET ??_C@_0DF@GDOFOJFC@Levolver?5Error?3?5missing?5?3?5in?5com@
	call	_fputs
	add	esp, 8

; 246  : 				else

	jmp	$LN95@main
$LN81@main:

; 247  : 					{
; 248  : 					colon_character_pointer2 = strstr(1+colon_character_pointer, ":");

	lea	edi, DWORD PTR [esi+1]
	push	OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
	push	edi
	call	_kb_strstr
	add	esp, 8
	mov	DWORD PTR _colon_character_pointer2$[ebp], eax

; 249  : 					if (!colon_character_pointer2)

	test	eax, eax
	jne	SHORT $LN79@main

; 250  : 						fputs("Levolver Error: missing second : in command line option -S\n",stdout);

	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	push	OFFSET ??_C@_0DM@EJAOCHNH@Levolver?5Error?3?5missing?5second?5?3@
	call	_fputs
	add	esp, 8

; 251  : 					else

	mov	edi, 1
	jmp	$LN95@main
$LN79@main:

; 252  : 						{
; 253  : 						*colon_character_pointer = 0;

	mov	BYTE PTR [esi], 0

; 254  : 						*colon_character_pointer2 = 0;

	mov	BYTE PTR [eax], 0

; 255  : 						x_pixel_width_cmd_line = atoi(++colon_character_pointer2);

	inc	eax
	push	eax
	mov	DWORD PTR _colon_character_pointer2$[ebp], eax
	call	_atoi

; 256  : 						y_pixel_height_cmd_line = atoi(++colon_character_pointer);

	push	edi
	mov	DWORD PTR _x_pixel_width_cmd_line, eax
	mov	DWORD PTR _colon_character_pointer$[ebp], edi
	call	_atoi
	mov	DWORD PTR _y_pixel_height_cmd_line, eax

; 257  : 						y_pixel_down_cmd_line = atoi(argv[0]+3);

	mov	ecx, DWORD PTR [ebx]
	add	ecx, 3
	push	ecx
	call	_atoi
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _y_pixel_down_cmd_line, eax

; 258  : 						}
; 259  : 					}
; 260  : 				}
; 261  : 			  else    
; 262  : 				{
; 263  : 				fputs("Levolver Error: missing = in command line option -S\n",stdout);
; 264  : 				}                   
; 265  :           break;   

	mov	edi, 1
	jmp	$LN95@main
$LN76@main:

; 266  : 
; 267  :           case 'X' : /* Program Break Delay (warning: case sensitive, x defined elsewhere)*/
; 268  : 			  if( argv[0][2] = '=' )

	mov	BYTE PTR [eax+2], 61			; 0000003dH

; 269  : 					{
; 270  : 					cProgramBreakDelay=0;

	mov	DWORD PTR _cProgramBreakDelay, 0

; 271  : 
; 272  :                     ProgramBreakDelay = atoi(argv[0]+3);

	mov	edx, DWORD PTR [ebx]
	add	edx, 3
	push	edx
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _ProgramBreakDelay, eax

; 273  : 					}
; 274  :                 else    
; 275  :                     {
; 276  :                     fputs("Levolver Error: missing = in command line option -X\n",stdout);
; 277  :                     }                   
; 278  :           break;   

	jmp	$LN95@main
$LN73@main:

; 279  : 		  case 'G' : /* Graphics Window Title Text */
; 280  : 				if( argv[0][2] = '=' )

	mov	BYTE PTR [eax+2], 61			; 0000003dH

; 281  : 					{
; 282  : 					strcpy(GraphicsWindowTitleTextBuffer, argv[0]+3);

	mov	eax, DWORD PTR [ebx]
	add	eax, 3
	mov	edx, OFFSET _GraphicsWindowTitleTextBuffer
	npad	4
$LL107@main:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	add	eax, edi
	add	edx, edi
	test	cl, cl
	jne	SHORT $LL107@main

; 283  : 					GraphicsWindowTitleText = GraphicsWindowTitleTextBuffer;					

	mov	DWORD PTR _GraphicsWindowTitleText, OFFSET _GraphicsWindowTitleTextBuffer

; 284  : 					}
; 285  :                 else    
; 286  :                     {
; 287  :                     fputs("Levolver Error: missing = in command line option -F\n",stdout);
; 288  :                     }                   
; 289  :           break;           

	jmp	$LN95@main
$LN70@main:

; 290  : 
; 291  :           case 'F' : /*  in, out, break for LEVOLVER */
; 292  : 				  plevolverpath=_getcwd(levolverpath,1024); 

	lea	eax, DWORD PTR _levolverpath$[ebp]
	push	1024					; 00000400H
	push	eax
	call	__getcwd
	add	esp, 8
	mov	DWORD PTR _plevolverpath$[ebp], eax

; 293  : 
; 294  : 				  if (plevolverpath == NULL)

	test	eax, eax
	jne	SHORT $LN69@main

; 295  : 					fputs("Levolver Error: current working directory name too long!\n",stderr);

	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	push	OFFSET ??_C@_0DK@GFFGCGIG@Levolver?5Error?3?5current?5working?5@
	call	_fputs
	add	esp, 8
	jmp	$LN95@main
$LN69@main:

; 296  : 				  else if( argv[0][2] = '=' )

	mov	ecx, DWORD PTR [ebx]
	mov	BYTE PTR [ecx+2], 61			; 0000003dH

; 297  :                     {
; 298  :                     l_evolver_mode = TRUE;

	mov	DWORD PTR _l_evolver_mode, edi

; 299  : 
; 300  : 					strcpy(lfname, levolverpath);

	xor	eax, eax
	npad	14
$LL108@main:
	mov	cl, BYTE PTR _levolverpath$[ebp+eax]
	mov	BYTE PTR _lfname$[ebp+eax], cl
	add	eax, edi
	test	cl, cl
	jne	SHORT $LL108@main

; 301  : #ifndef WIN32
; 302  : 					strcat(lfname, "/communication/in/");
; 303  : #else
; 304  : 					strcat(lfname, "\\communication\\in\\");

	lea	eax, DWORD PTR _lfname$[ebp]
	dec	eax
	npad	5
$LL128@main:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL128@main
	mov	edx, DWORD PTR ??_C@_0BD@LHDFKPHL@?2communication?2in?2?$AA@
	mov	ecx, DWORD PTR ??_C@_0BD@LHDFKPHL@?2communication?2in?2?$AA@+4
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR ??_C@_0BD@LHDFKPHL@?2communication?2in?2?$AA@+8
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR ??_C@_0BD@LHDFKPHL@?2communication?2in?2?$AA@+12
	mov	DWORD PTR [eax+8], edx
	mov	dx, WORD PTR ??_C@_0BD@LHDFKPHL@?2communication?2in?2?$AA@+16
	mov	DWORD PTR [eax+12], ecx
	mov	cl, BYTE PTR ??_C@_0BD@LHDFKPHL@?2communication?2in?2?$AA@+18
	mov	WORD PTR [eax+16], dx
	mov	BYTE PTR [eax+18], cl

; 305  : #endif
; 306  : 					strcat(lfname, argv[0]+3);

	mov	eax, DWORD PTR [ebx]
	add	eax, 3
	mov	ecx, eax
$LL129@main:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL129@main
	lea	edi, DWORD PTR _lfname$[ebp]
	sub	eax, ecx
	mov	esi, ecx
	dec	edi
$LL130@main:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL130@main
	mov	ecx, eax
	shr	ecx, 2
	rep movsd
	mov	ecx, eax

; 307  :                     l_infd = fopen(lfname, "r");

	lea	edx, DWORD PTR _lfname$[ebp]
	and	ecx, 3
	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	push	edx
	rep movsb
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _l_infd, eax

; 308  :                     if ( !l_infd ) 

	test	eax, eax
	jne	SHORT $LN66@main

; 309  :                         {
; 310  : 						l_evolver_mode = 0;
; 311  :                         outstring("Levolver Error: Cannot Open -F=<file>");

	push	OFFSET ??_C@_0CG@POPNAIIB@Levolver?5Error?3?5Cannot?5Open?5?9F?$DN?$DM@
	mov	DWORD PTR _l_evolver_mode, eax
	call	_outstring

; 312  : 						outstring(lfname);

	lea	eax, DWORD PTR _lfname$[ebp]
	push	eax
	call	_outstring
	add	esp, 8
$LN66@main:

; 313  : 						}
; 314  : 					strcpy(lfname, levolverpath);

	xor	eax, eax
	npad	5
$LL109@main:
	mov	cl, BYTE PTR _levolverpath$[ebp+eax]
	mov	BYTE PTR _lfname$[ebp+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL109@main

; 315  : #ifndef WIN32
; 316  : 					strcat(lfname, "/communication/out/");
; 317  : #else
; 318  : 					strcat(lfname, "\\communication\\out\\");

	lea	eax, DWORD PTR _lfname$[ebp]
	dec	eax
	npad	6
$LL131@main:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL131@main
	mov	ecx, DWORD PTR ??_C@_0BE@OPGILNCF@?2communication?2out?2?$AA@
	mov	edx, DWORD PTR ??_C@_0BE@OPGILNCF@?2communication?2out?2?$AA@+4
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR ??_C@_0BE@OPGILNCF@?2communication?2out?2?$AA@+8
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR ??_C@_0BE@OPGILNCF@?2communication?2out?2?$AA@+12
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR ??_C@_0BE@OPGILNCF@?2communication?2out?2?$AA@+16
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], ecx

; 319  : #endif
; 320  : 					strcat(lfname, argv[0]+3);

	mov	eax, DWORD PTR [ebx]
	add	eax, 3
	mov	ecx, eax
	npad	5
$LL132@main:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL132@main
	lea	edi, DWORD PTR _lfname$[ebp]
	sub	eax, ecx
	mov	esi, ecx
	dec	edi
$LL133@main:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL133@main
	mov	ecx, eax
	shr	ecx, 2
	rep movsd
	mov	ecx, eax

; 321  :                     l_outfd = fopen(lfname, "a");

	lea	edx, DWORD PTR _lfname$[ebp]
	and	ecx, 3
	push	OFFSET ??_C@_01MCMALHOG@a?$AA@
	push	edx
	rep movsb
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _l_outfd, eax

; 322  :                     if ( !l_outfd )  

	test	eax, eax
	jne	SHORT $LN65@main

; 323  :                         {
; 324  : 						l_evolver_mode = 0;
; 325  :                         outstring("Levolver Error: Cannot Open -F=<file>");

	push	OFFSET ??_C@_0CG@POPNAIIB@Levolver?5Error?3?5Cannot?5Open?5?9F?$DN?$DM@
	mov	DWORD PTR _l_evolver_mode, eax
	call	_outstring

; 326  : 						outstring(lfname);

	lea	eax, DWORD PTR _lfname$[ebp]
	push	eax
	call	_outstring
	add	esp, 8
$LN65@main:

; 327  : 						}
; 328  : 					//else
; 329  : 						//cmdfilename = lfname;
; 330  : 
; 331  : 					strcpy(lfname, levolverpath);

	xor	eax, eax
	npad	11
$LL110@main:
	mov	cl, BYTE PTR _levolverpath$[ebp+eax]
	mov	BYTE PTR _lfname$[ebp+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL110@main

; 332  : #ifndef WIN32
; 333  : 					strcat(lfname, "/communication/br/");
; 334  : #else
; 335  : 					strcat(lfname, "\\communication\\br\\");

	lea	eax, DWORD PTR _lfname$[ebp]
	dec	eax
	npad	6
$LL134@main:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL134@main
	mov	ecx, DWORD PTR ??_C@_0BD@HFAIHCGO@?2communication?2br?2?$AA@
	mov	edx, DWORD PTR ??_C@_0BD@HFAIHCGO@?2communication?2br?2?$AA@+4
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR ??_C@_0BD@HFAIHCGO@?2communication?2br?2?$AA@+8
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR ??_C@_0BD@HFAIHCGO@?2communication?2br?2?$AA@+12
	mov	DWORD PTR [eax+8], ecx
	mov	cx, WORD PTR ??_C@_0BD@HFAIHCGO@?2communication?2br?2?$AA@+16
	mov	DWORD PTR [eax+12], edx
	mov	dl, BYTE PTR ??_C@_0BD@HFAIHCGO@?2communication?2br?2?$AA@+18
	mov	WORD PTR [eax+16], cx
	mov	BYTE PTR [eax+18], dl

; 336  : #endif
; 337  : 					strcat(lfname, argv[0]+3);

	mov	eax, DWORD PTR [ebx]
	add	eax, 3
	mov	ecx, eax
$LL135@main:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL135@main
	lea	edi, DWORD PTR _lfname$[ebp]
	sub	eax, ecx
	mov	esi, ecx
	dec	edi
$LL136@main:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL136@main
	mov	ecx, eax
	shr	ecx, 2
	rep movsd
	mov	ecx, eax

; 338  :                     l_brfd = fopen( lfname, "r");

	lea	eax, DWORD PTR _lfname$[ebp]
	and	ecx, 3
	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	push	eax
	rep movsb
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _l_brfd, eax

; 339  :                     if ( !l_brfd ) 

	test	eax, eax
	jne	SHORT $LN64@main

; 340  :                         {
; 341  : 						l_evolver_mode = 0;
; 342  :                         outstring("Levolver Error: Cannot Open -F=<file>");

	push	OFFSET ??_C@_0CG@POPNAIIB@Levolver?5Error?3?5Cannot?5Open?5?9F?$DN?$DM@
	mov	DWORD PTR _l_evolver_mode, eax
	call	_outstring

; 343  : 						outstring(lfname);

	lea	ecx, DWORD PTR _lfname$[ebp]
	push	ecx
	call	_outstring
	mov	eax, DWORD PTR _l_brfd
	add	esp, 8
$LN64@main:

; 344  : 						}
; 345  : 
; 346  :                     if ( !l_infd || !l_outfd || !l_brfd ) 

	cmp	DWORD PTR _l_infd, 0
	je	$LN148@main
	cmp	DWORD PTR _l_outfd, 0
	je	$LN148@main
	test	eax, eax
	je	$LN148@main

; 347  :                         {
; 348  : 						fputs("Failed to enter I/O layer mode",stdout);
; 349  :                         my_exit(0);
; 350  : /*kb_error(1349,"Broken pipe.\n",RECOVERABLE); 
; 351  : */
; 352  :                         }
; 353  : 					else
; 354  : 						{
; 355  : 						//prepare string to represent png path
; 356  : 							
; 357  : 						strcpy(lfname, levolverpath);

	xor	eax, eax
	npad	14
$LL111@main:
	mov	cl, BYTE PTR _levolverpath$[ebp+eax]
	mov	BYTE PTR _lfname$[ebp+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL111@main

; 358  : #ifndef WIN32
; 359  : 						strcat(lfname, "/communication/history/png_path.txt");
; 360  : #else
; 361  : 						strcat(lfname, "\\communication\\history\\png_path.txt");

	lea	edi, DWORD PTR _lfname$[ebp]
	dec	edi
	npad	6
$LL137@main:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL137@main

; 362  : #endif
; 363  : 						ActivatePngPathLogic(lfname);

	lea	edx, DWORD PTR _lfname$[ebp]
	mov	ecx, 9
	mov	esi, OFFSET ??_C@_0CE@DOHCHCPK@?2communication?2history?2png_path?4@
	push	edx
	rep movsd
	call	_ActivatePngPathLogic

; 364  : 						fputs("Successfully entered I/O layer mode\n",stdout);						

	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	push	OFFSET ??_C@_0CF@HEGAMOJB@Successfully?5entered?5I?1O?5layer?5m@
	call	_fputs
	add	esp, 12					; 0000000cH

; 365  : 						}
; 366  :                     }
; 367  :                 else    
; 368  :                     {
; 369  :                     fputs("Levolver Error: missing = in command line option -F\n",stdout);
; 370  :                     }                   
; 371  :           break;           

	mov	edi, 1
	jmp	$LN95@main
$LN59@main:

; 372  : #endif				 
; 373  : 
; 374  :           case 'r' : // -r command line option
; 375  :                  if ( argv[0][2] )

	add	eax, 2
	cmp	BYTE PTR [eax], 0

; 376  :                    strncpy(cmdstring,argv[0]+2,sizeof(cmdstring));

	push	10000					; 00002710H
	je	SHORT $LN58@main
	push	eax
	push	OFFSET _cmdstring
	call	_strncpy
	add	esp, 12					; 0000000cH

; 377  :                  else /* probably a space inserted */

	jmp	SHORT $LN57@main
$LN58@main:

; 378  :                  { strncpy(cmdstring,argv[1],sizeof(cmdstring));

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	push	OFFSET _cmdstring
	call	_strncpy
	add	esp, 12					; 0000000cH
	add	ebx, 4

; 379  :                    ++argv; argc--; 

	sub	DWORD PTR _argc$[ebp], edi
$LN57@main:

; 380  :                  }
; 381  :                  // convert escapes
; 382  :                  { char *c;
; 383  :                    for ( c = cmdstring ; *c ; c++ )

	cmp	BYTE PTR _cmdstring, 0
	mov	eax, OFFSET _cmdstring
	mov	DWORD PTR _c$81503[ebp], eax
	je	SHORT $LN54@main
$LL56@main:

; 384  :                    { if ( *c == '\\' )

	cmp	BYTE PTR [eax], 92			; 0000005cH
	jne	SHORT $LN55@main

; 385  :                      { *c = ' ';

	mov	BYTE PTR [eax], 32			; 00000020H

; 386  :                        switch ( c[1] )

	mov	cl, BYTE PTR [eax+1]
	cmp	cl, 110					; 0000006eH
	je	SHORT $LN49@main
	cmp	cl, 116					; 00000074H
	jne	SHORT $LN55@main

; 387  :                        { case 't': c[1] = '\t'; break;

	mov	BYTE PTR [eax+1], 9
	jmp	SHORT $LN55@main
$LN49@main:

; 388  :                          case 'n': c[1] = '\n'; break;

	mov	BYTE PTR [eax+1], 10			; 0000000aH
$LN55@main:

; 380  :                  }
; 381  :                  // convert escapes
; 382  :                  { char *c;
; 383  :                    for ( c = cmdstring ; *c ; c++ )

	add	eax, edi
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL56@main
	mov	DWORD PTR _c$81503[ebp], eax
$LN54@main:

; 389  :                        }
; 390  :                      }
; 391  :                    }
; 392  :                  }
; 393  :                  cmdstring_flag = 1;

	mov	DWORD PTR _cmdstring_flag, edi

; 394  :                  break;

	jmp	$LN95@main
$LN48@main:

; 395  : 
; 396  :           case 'd' :  /* parser debug */
; 397  :                  yydebug = 1;

	mov	DWORD PTR _yydebug, edi

; 398  :                  break;

	jmp	$LN95@main
$LN47@main:

; 399  :           case 'i' : match_id_flag = 1; sparse_ibase_flag = 1; break;

	mov	DWORD PTR _match_id_flag, edi
$LN46@main:
	mov	DWORD PTR _sparse_ibase_flag, edi
	jmp	$LN95@main
$LN45@main:

; 400  :           case 'I' : sparse_ibase_flag = 1; break;
; 401  :           case 's' : default_random_seed = atoi(argv[0]+2); 

	add	eax, 2
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _default_random_seed, eax

; 402  :                      break;

	jmp	$LN95@main
$LN44@main:

; 403  :           case 'p' : 
; 404  :                 if ( argv[0][2] )

	add	eax, 2
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN43@main

; 405  :                   procs_requested = atoi(argv[0]+2);

	push	eax
	call	_atoi
	add	esp, 4

; 406  :                 else 

	jmp	SHORT $LN155@main
$LN43@main:

; 407  :                 { procs_requested = atoi(argv[1]);

	mov	ecx, DWORD PTR [ebx+4]
	push	ecx
	call	_atoi
	add	esp, 4
	add	ebx, 4

; 408  :                   argv++; argc--;

	sub	DWORD PTR _argc$[ebp], edi
$LN155@main:

; 409  :                 }
; 410  : #if defined(SGI_MULTI) || defined (THREADS)
; 411  :                 if ( procs_requested < 1 )

	mov	DWORD PTR _procs_requested, eax
	cmp	eax, edi
	jge	SHORT $LN41@main

; 412  :                   { kb_error(1321, 
; 413  :                       "-p with nonpositive number. Threads set to 1.\n",
; 414  :                                     WARNING);

	push	2
	push	OFFSET ??_C@_0CP@LBANCBEK@?9p?5with?5nonpositive?5number?4?5Thre@
	push	1321					; 00000529H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 415  :                      procs_requested = 1;

	mov	DWORD PTR _procs_requested, edi

; 426  :                }
; 427  :                   
; 428  : #ifdef THREADS
; 429  :                 threadflag = 1;

	mov	DWORD PTR _threadflag, edi

; 430  : #endif
; 431  : #else
; 432  :                 kb_error(1322,"-p option not effective.  This Evolver not compiled for multithreading.\n", WARNING);
; 433  : #endif
; 434  :                 break; 

	jmp	$LN95@main
$LN41@main:

; 416  :                   }
; 417  :                 if ( procs_requested > MAXPROCS )

	cmp	eax, 144				; 00000090H
	jle	SHORT $LN40@main

; 418  :                 { sprintf(errmsg,
; 419  :     "This Evolver only compiled for a maximum of %d threads.\n",MAXPROCS);

	push	144					; 00000090H
	push	OFFSET ??_C@_0DJ@KPIECAMP@This?5Evolver?5only?5compiled?5for?5a@
	push	OFFSET _errmsg
	call	_sprintf

; 420  :                    kb_error(2551,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2551					; 000009f7H
	call	_kb_error

; 421  :                   sprintf(errmsg,
; 422  :      "Threads set to %d. Recompile with -DMAXPROCS=%d if you want more.\n",
; 423  :                     MAXPROCS,procs_requested);

	mov	edx, DWORD PTR _procs_requested
	push	edx
	push	144					; 00000090H
	push	OFFSET ??_C@_0ED@POEJMLIP@Threads?5set?5to?5?$CFd?4?5Recompile?5wit@
	push	OFFSET _errmsg
	call	_sprintf

; 424  :                   erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 44					; 0000002cH

; 425  :                   procs_requested = MAXPROCS;

	mov	DWORD PTR _procs_requested, 144		; 00000090H
$LN40@main:

; 426  :                }
; 427  :                   
; 428  : #ifdef THREADS
; 429  :                 threadflag = 1;

	mov	DWORD PTR _threadflag, edi

; 430  : #endif
; 431  : #else
; 432  :                 kb_error(1322,"-p option not effective.  This Evolver not compiled for multithreading.\n", WARNING);
; 433  : #endif
; 434  :                 break; 

	jmp	$LN95@main
$LN39@main:

; 435  :           case 'A' : cpu_affinity_flag = 1; break;

	mov	DWORD PTR _cpu_affinity_flag, edi
	jmp	$LN95@main
$LN38@main:

; 436  :           case 'x' : exit_after_error = 1; break;

	mov	DWORD PTR _exit_after_error, edi
	jmp	$LN95@main
$LN37@main:

; 437  :           case 'w' : exit_after_warning = exit_after_error = 1; break;

	mov	DWORD PTR _exit_after_error, edi
	mov	DWORD PTR _exit_after_warning, edi
	jmp	$LN95@main
$LN36@main:

; 438  :           case 'y' : break_after_warning = 1; break;

	mov	DWORD PTR _break_after_warning, edi
	jmp	$LN95@main
$LN35@main:

; 439  :           case 'm' : memdebug = 1; break;

	mov	DWORD PTR _memdebug, edi
	jmp	$LN95@main
$LN34@main:

; 440  :           case 'l' : just_lex_flag = 1; break;

	mov	DWORD PTR _just_lex_flag, edi
	jmp	$LN95@main
$LN33@main:

; 441  :           default:
; 442  :                  sprintf(msg,"Illegal option: %s\n",argv[0]); outstring(msg);

	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BE@MGCJELGD@Illegal?5option?3?5?$CFs?6?$AA@
	push	eax
	call	_sprintf
	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
$LN32@main:

; 443  :           case 'h' :
; 444  :                  outstring("Legal options: \n"); 

	push	OFFSET ??_C@_0BB@CALHPDE@Legal?5options?3?5?6?$AA@
	call	_outstring

; 445  :                  outstring("  -ffilename          take commands from file\n"); 

	push	OFFSET ??_C@_0CP@CFHHDJJ@?5?5?9ffilename?5?5?5?5?5?5?5?5?5?5take?5comma@
	call	_outstring

; 446  :                  outstring("  -i                     use id numbers as in datafile\n"); 

	push	OFFSET ??_C@_0DI@GJIELDDD@?5?5?9i?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5use?5id?5@
	call	_outstring

; 447  :                  outstring("  -q                     convert to named quantities\n"); 

	push	OFFSET ??_C@_0DG@PNABHOIJ@?5?5?9q?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5convert@
	call	_outstring

; 448  :                  outstring("  -a                     auto convert to named quantities when needed\n"); 

	push	OFFSET ??_C@_0EH@KPMJFDKA@?5?5?9a?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5auto?5co@
	call	_outstring

; 449  :                  outstring("  -x                     exit after error\n"); 

	push	OFFSET ??_C@_0CL@HLFJHKHP@?5?5?9x?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5exit?5af@
	call	_outstring

; 450  :                  outstring("  -w                     exit after warning\n"); 

	push	OFFSET ??_C@_0CN@GPPPFMIP@?5?5?9w?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5exit?5af@
	call	_outstring

; 451  :                  outstring("  -y                     break after warning\n"); 

	push	OFFSET ??_C@_0CO@IOEOGMKH@?5?5?9y?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5break?5a@
	call	_outstring

; 452  :                  outstring("  -d                     parser debugging on\n"); 

	push	OFFSET ??_C@_0CO@KNAPIEDP@?5?5?9d?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5parser?5@
	call	_outstring

; 453  :                  outstring("  -m                     memory debugging on\n"); 

	push	OFFSET ??_C@_0CO@BNFHPOGE@?5?5?9m?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5memory?5@
	call	_outstring

; 454  : #ifdef SGI_MULTI
; 455  :                  outstring("  -pn                    use n processes \n"); 
; 456  : #endif
; 457  : #if defined(THREADS)
; 458  :                  outstring("  -pn                    use n worker threads \n"); 

	push	OFFSET ??_C@_0DA@FCNELPGG@?5?5?9pn?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5use?5n?5w@
	call	_outstring

; 459  : #endif
; 460  :                  outstring("  -h                     print this help\n"); 

	push	OFFSET ??_C@_0CK@DFJMJICF@?5?5?9h?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5print?5t@
	call	_outstring
	add	esp, 48					; 00000030H
$LN95@main:

; 461  :                  break;
; 462  :             }
; 463  :         argv++; argc--;

	add	ebx, 4
	sub	DWORD PTR _argc$[ebp], edi
	jne	$LN98@main
$LN150@main:
	mov	DWORD PTR _argv$GSCopy$[ebp], ebx
$LN97@main:

; 464  :      }
; 465  :   }
; 466  : 
; 467  :   if ( pause_flag )

	cmp	DWORD PTR _pause_flag$[ebp], 0
	je	SHORT $LN31@main

; 468  :   { 
; 469  :     #ifdef MPI_EVOLVER
; 470  :       MPI_Barrier(MPI_COMM_WORLD);   // to get all banners printed first
; 471  :       if ( this_task == MASTER_TASK )  // only master gets input, but all tasks wait on master anyway.
; 472  :          prompt("\nPausing due to -Z option. Hit ENTER to continue.\n",msg,sizeof(msg));
; 473  :       MPI_Barrier(MPI_COMM_WORLD);
; 474  :     #else
; 475  :          prompt("Pausing due to -Z option. Hit ENTER to continue.\n",msg,sizeof(msg));

	mov	edx, DWORD PTR _msg
	push	4
	push	edx
	push	OFFSET ??_C@_0DC@PHCLOHKK@Pausing?5due?5to?5?9Z?5option?4?5Hit?5EN@
	call	_prompt
	add	esp, 12					; 0000000cH
$LN31@main:

; 476  :     #endif
; 477  :   }
; 478  : 
; 479  :  
; 480  : #ifdef SGI_MULTI
; 481  :   sprintf(msg,"Using %d processes on %d processors.\n\n",
; 482  :       procs_requested,m_get_numprocs()); 
; 483  :   outstring(msg);
; 484  :   m_set_procs(procs_requested);
; 485  :   if ( m_get_numprocs() > 1 )
; 486  :   { int n;
; 487  :      /* set up list of locks available for critical sections */
; 488  :      usconfig(CONF_INITSIZE,200*_MAXLOCKS);
; 489  :      usconfig(CONF_ARENATYPE,US_SHAREDONLY);
; 490  :      usconfig(CONF_INITUSERS,4+m_get_numprocs());
; 491  :      lock_arena = usinit(lock_arena_name);
; 492  :      if ( lock_arena == NULL ) { perror(lock_arena_name); exit(2); }
; 493  :      for ( n = 0 ; n < _MAXLOCKS ; n++ )
; 494  :      { locklist[n] = usnewlock(lock_arena);
; 495  :         if ( locklist[n] == NULL )
; 496  :         { fprintf(stderr,"lock allocation failure on lock %d.\n",n);
; 497  :           perror("usnewlock");
; 498  :           exit(2);
; 499  :         }
; 500  :      }
; 501  :      m_fork(m_set_idlist);
; 502  :      m_park_procs();
; 503  :      mpflag = M_INACTIVE;
; 504  :   }
; 505  : #endif
; 506  :   nprocs = procs_requested;

	mov	eax, DWORD PTR _procs_requested
	mov	DWORD PTR _nprocs, eax

; 507  : 
; 508  : #ifdef WINTHREADS
; 509  :   main_thread_id = GetCurrentThreadId();

	call	DWORD PTR __imp__GetCurrentThreadId@0

; 510  :   if ( cpu_affinity_flag )

	cmp	DWORD PTR _cpu_affinity_flag, 0
	mov	ebx, DWORD PTR __imp__SetThreadAffinityMask@8
	mov	edi, DWORD PTR __imp__GetCurrentThread@0
	mov	DWORD PTR _main_thread_id, eax
	je	SHORT $LN30@main

; 511  :   { SetThreadAffinityMask(GetCurrentThread(),1);

	push	1
	call	edi
	push	eax
	call	ebx

; 512  :     outstring("Set affinity of main thread to cpu 0.\n");

	push	OFFSET ??_C@_0CH@NGDDKCCO@Set?5affinity?5of?5main?5thread?5to?5c@
	call	_outstring
	add	esp, 4
	jmp	SHORT $LN28@main
$LN148@main:

; 461  :                  break;
; 462  :             }
; 463  :         argv++; argc--;

	mov	DWORD PTR _argv$GSCopy$[ebp], ebx
	call	___iob_func
	add	eax, 32					; 00000020H
	push	eax
	push	OFFSET ??_C@_0BP@HBHLBOMI@Failed?5to?5enter?5I?1O?5layer?5mode?$AA@
	call	_fputs
	add	esp, 8
	push	0
	call	_my_exit
$LN159@main:
$LN30@main:

; 513  :   }
; 514  :   else if ( procs_requested <= 1 )

	cmp	DWORD PTR _procs_requested, 1
	jg	SHORT $LN28@main

; 515  :     affinity_mongering();

	call	_affinity_mongering
$LN28@main:

; 516  : 
; 517  :   /* Set up worker threads for MS-Windows multiprocessor machines */
; 518  :   thread_data_key = TlsAlloc();

	call	DWORD PTR __imp__TlsAlloc@0

; 519  :   TlsSetValue(thread_data_key,(void*)&default_thread_data);  // for main thread

	push	OFFSET _default_thread_data
	push	eax
	mov	DWORD PTR _thread_data_key, eax
	call	DWORD PTR __imp__TlsSetValue@8

; 520  :   if ( threadflag )

	cmp	DWORD PTR _threadflag, 0
	je	$LN27@main

; 521  :   { int i;
; 522  :     int retval;
; 523  :     SYSTEM_INFO si;
; 524  :     GetSystemInfo(&si);

	lea	ecx, DWORD PTR _si$81557[ebp]
	push	ecx
	call	DWORD PTR __imp__GetSystemInfo@4

; 525  :     workthread_wakeup = CreateEvent(NULL,TRUE,FALSE,NULL);

	mov	esi, DWORD PTR __imp__CreateEventA@16
	push	0
	push	0
	push	1
	push	0
	call	esi

; 526  :     mainthread_wakeup = CreateEvent(NULL,TRUE,TRUE,NULL);

	push	0
	push	1
	push	1
	push	0
	mov	DWORD PTR _workthread_wakeup, eax
	call	esi

; 527  :     barrier_event = CreateEvent(NULL,TRUE,TRUE,NULL);

	push	0
	push	1
	push	1
	push	0
	mov	DWORD PTR _mainthread_wakeup, eax
	call	esi

; 528  : 
; 529  : #if _WIN32_WINNT >= 0x0500  
; 530  :     { retval = InitializeCriticalSectionAndSpinCount(&thread_cs,spincount); 

	mov	edx, DWORD PTR _spincount
	mov	esi, DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8
	push	edx
	push	OFFSET _thread_cs
	mov	DWORD PTR _barrier_event, eax
	call	esi

; 531  :       retval = InitializeCriticalSectionAndSpinCount(&element_cs,spincount); 

	mov	eax, DWORD PTR _spincount
	push	eax
	push	OFFSET _element_cs
	call	esi

; 532  :       retval = InitializeCriticalSectionAndSpinCount(&web_cs,spincount); 

	mov	ecx, DWORD PTR _spincount
	push	ecx
	push	OFFSET _web_cs
	call	esi

; 533  :     }
; 534  : #else
; 535  :     { InitializeCriticalSection(&thread_cs); 
; 536  :       InitializeCriticalSection(&element_cs); 
; 537  :       InitializeCriticalSection(&web_cs); 
; 538  :     }
; 539  : #endif
; 540  :     if ( cpu_affinity_flag )  

	cmp	DWORD PTR _cpu_affinity_flag, 0
	mov	DWORD PTR _retval$81556[ebp], eax
	je	SHORT $LN26@main

; 541  :       SetThreadAffinityMask(GetCurrentThread(),1);

	push	1
	call	edi
	push	eax
	call	ebx
$LN26@main:

; 542  : 
; 543  :     threadlist = (HANDLE*)my_list_calloc(procs_requested,sizeof(HANDLE),
; 544  :                        ETERNAL_BLOCK);

	mov	edx, DWORD PTR _procs_requested
	push	544					; 00000220H
	push	OFFSET ??_C@_07KINGIIKE@tmain?4c?$AA@
	push	60138					; 0000eaeaH
	push	4
	push	edx
	call	_list_calloc

; 545  :     thread_data_ptrs = (struct thread_data**)my_list_calloc(procs_requested,
; 546  :                       sizeof(struct thread_data*),ETERNAL_BLOCK);

	push	546					; 00000222H
	push	OFFSET ??_C@_07KINGIIKE@tmain?4c?$AA@
	push	60138					; 0000eaeaH
	mov	DWORD PTR _threadlist, eax
	mov	eax, DWORD PTR _procs_requested
	push	4
	push	eax
	call	_list_calloc

; 547  :     busythreads = procs_requested;
; 548  :     barrier_count = procs_requested;
; 549  :     ResetEvent(barrier_event);

	mov	ecx, DWORD PTR _barrier_event
	mov	DWORD PTR _thread_data_ptrs, eax
	mov	eax, DWORD PTR _procs_requested
	add	esp, 40					; 00000028H
	mov	DWORD PTR _busythreads, eax
	push	ecx
	mov	DWORD PTR _barrier_count, eax
	call	DWORD PTR __imp__ResetEvent@4

; 550  :     for ( i = 0 ; i < procs_requested ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _procs_requested, esi
	jle	$LN23@main
	mov	edi, DWORD PTR __imp__CreateThread@24
	mov	ebx, DWORD PTR __imp__FormatMessageA@28
	npad	9
$LL25@main:

; 551  :     { DWORD tid;  /* dummy for thread id */
; 552  :       thread_data_ptrs[i] = 
; 553  :            (struct thread_data *)my_list_calloc(1,sizeof(struct thread_data),
; 554  :                  ETERNAL_BLOCK);

	push	554					; 0000022aH
	push	OFFSET ??_C@_07KINGIIKE@tmain?4c?$AA@
	push	60138					; 0000eaeaH
	push	1952					; 000007a0H
	push	1
	call	_list_calloc
	mov	edx, DWORD PTR _thread_data_ptrs
	mov	DWORD PTR [edx+esi*4], eax

; 555  :       thread_data_ptrs[i]->worker_id = i;

	mov	eax, DWORD PTR _thread_data_ptrs
	mov	ecx, DWORD PTR [eax+esi*4]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [ecx], esi

; 556  :       threadlist[i] = CreateThread(NULL,0,winthread_worker,
; 557  :                          thread_data_ptrs[i],0,&tid);  

	mov	eax, DWORD PTR _thread_data_ptrs
	mov	ecx, DWORD PTR [eax+esi*4]
	lea	edx, DWORD PTR _tid$81572[ebp]
	push	edx
	push	0
	push	ecx
	push	OFFSET _winthread_worker@4
	push	0
	push	0
	call	edi
	mov	edx, DWORD PTR _threadlist
	mov	DWORD PTR [edx+esi*4], eax

; 558  :       if ( threadlist[i] == NULL )

	mov	eax, DWORD PTR _threadlist
	cmp	DWORD PTR [eax+esi*4], 0
	jne	SHORT $LN22@main

; 559  :       { FormatMessage( 
; 560  :            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
; 561  :            NULL, GetLastError(),
; 562  :            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), /* Default language */
; 563  :            (LPTSTR) &errmsg, ERRMSGSIZE, NULL );

	push	0
	push	2000					; 000007d0H
	push	OFFSET _errmsg
	push	1024					; 00000400H
	call	DWORD PTR __imp__GetLastError@0
	push	eax
	push	0
	push	4608					; 00001200H
	call	ebx

; 564  :         erroutstring("Cannot create worker threads.\n");

	push	OFFSET ??_C@_0BP@BDKMGAFD@Cannot?5create?5worker?5threads?4?6?$AA@
	call	_erroutstring

; 565  :         kb_error(2190,errmsg,UNRECOVERABLE);

	push	0
	push	OFFSET _errmsg
	push	2190					; 0000088eH
	call	_kb_error
	add	esp, 16					; 00000010H
$LN22@main:

; 566  :       }
; 567  :       if ( cpu_affinity_flag )

	cmp	DWORD PTR _cpu_affinity_flag, 0
	je	$LN24@main

; 568  :       { DWORD_PTR  proc_affinity_mask,system_affinity_mask;
; 569  :         GetProcessAffinityMask(GetCurrentProcess(),&proc_affinity_mask,
; 570  :             &system_affinity_mask);

	lea	ecx, DWORD PTR _system_affinity_mask$81586[ebp]
	push	ecx
	lea	edx, DWORD PTR _proc_affinity_mask$81585[ebp]
	push	edx
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__GetProcessAffinityMask@12

; 571  :         if ( proc_affinity_mask & (2<<i) )

	mov	ecx, esi
	mov	eax, 2
	shl	eax, cl
	mov	ecx, DWORD PTR _proc_affinity_mask$81585[ebp]
	test	eax, ecx
	je	SHORT $LN20@main

; 572  :         { SetThreadAffinityMask(threadlist[i],2<<i);

	push	eax
	mov	eax, DWORD PTR _threadlist
	mov	ecx, DWORD PTR [eax+esi*4]
	push	ecx
	call	DWORD PTR __imp__SetThreadAffinityMask@8

; 573  :           sprintf(msg,"Set affinity of worker thread %d to cpu %d.\n",i+1,i);

	mov	eax, DWORD PTR _msg
	push	esi
	lea	edx, DWORD PTR [esi+1]
	push	edx
	push	OFFSET ??_C@_0CN@NAEJCMBF@Set?5affinity?5of?5worker?5thread?5?$CFd@
	push	eax
	call	_sprintf

; 574  :           outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 20					; 00000014H

; 575  :         }
; 576  :         else

	jmp	SHORT $LN24@main
$LN20@main:

; 577  :         { sprintf(errmsg,"Cannot set affinity of worker thread %d to cpu %d; \n  process affinity mask is 0x%X.\n",
; 578  :                   i+1,i+1,proc_affinity_mask);

	push	ecx
	lea	eax, DWORD PTR [esi+1]
	push	eax
	push	eax
	push	OFFSET ??_C@_0FG@IKHOPOID@Cannot?5set?5affinity?5of?5worker?5th@
	push	OFFSET _errmsg
	call	_sprintf

; 579  :           kb_error(1932,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1932					; 0000078cH
	call	_kb_error
	add	esp, 32					; 00000020H
$LN24@main:

; 550  :     for ( i = 0 ; i < procs_requested ; i++ )

	inc	esi
	cmp	esi, DWORD PTR _procs_requested
	jl	$LL25@main
$LN23@main:

; 580  :         }
; 581  :       }
; 582  :     }
; 583  :     WaitForSingleObject(mainthread_wakeup,INFINITE);

	mov	edx, DWORD PTR _mainthread_wakeup
	push	-1
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8

; 584  :     sprintf(msg,"Created %d worker threads on %d processor machine.\n",
; 585  :         procs_requested,si.dwNumberOfProcessors);

	mov	eax, DWORD PTR _si$81557[ebp+20]
	mov	ecx, DWORD PTR _procs_requested
	mov	edx, DWORD PTR _msg
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DE@GCOFAIKO@Created?5?$CFd?5worker?5threads?5on?5?$CFd?5@
	push	edx
	call	_sprintf

; 586  :     if ( si.dwNumberOfProcessors == 1 ) 

	mov	eax, DWORD PTR _si$81557[ebp+20]

; 587  :        spincount = 1;  /* spin worthless on 1 cpu */
; 588  :     else spincount = 4000;
; 589  :     outstring(msg);

	mov	ecx, DWORD PTR _msg
	dec	eax
	neg	eax
	sbb	eax, eax
	and	eax, 3999				; 00000f9fH
	inc	eax
	push	ecx
	mov	DWORD PTR _spincount, eax
	call	_outstring
	add	esp, 20					; 00000014H
$LN27@main:

; 590  :   }
; 591  : #endif
; 592  : 
; 593  : #ifdef PTHREADS
; 594  :   main_thread_id = pthread_self();
; 595  :   /* Set up worker threads for Unix multiprocessor machines with pthreads */
; 596  :   pthread_key_create(&thread_data_key,NULL);
; 597  :   pthread_setspecific(thread_data_key,(void*)&default_thread_data); // for main thread
; 598  :   if ( threadflag )
; 599  :   { int i;
; 600  :     pthread_cond_init(&mainthread_wakeup,NULL);
; 601  :     pthread_cond_init(&workthread_wakeup,NULL);
; 602  : 
; 603  :     pthread_mutex_init(&thread_mutex, NULL);
; 604  :     pthread_mutex_init(&element_mutex, NULL);
; 605  :     threadlist = (pthread_t *)my_list_calloc(procs_requested+10,sizeof(int),
; 606  :               ETERNAL_BLOCK);
; 607  :     thread_data_ptrs = (struct thread_data**)my_list_calloc(procs_requested,
; 608  :                       sizeof(struct thread_data *),ETERNAL_BLOCK);
; 609  :     busythreads = procs_requested;  /* countdown barrier */
; 610  :     pthread_mutex_lock(&thread_mutex); 
; 611  :     for ( i = 0 ; i < procs_requested ; i++ )
; 612  :     { int ret;  /* dummy for thread id */
; 613  :       thread_data_ptrs[i] = (struct thread_data *)my_list_calloc(1,
; 614  :                 sizeof(struct thread_data),ETERNAL_BLOCK);
; 615  :       thread_data_ptrs[i]->worker_id = i;
; 616  :       ret = pthread_create(threadlist+i,NULL,pthread_worker,
; 617  :                (void*)(thread_data_ptrs[i]));
; 618  :       if ( ret != 0 )
; 619  :       {
; 620  :         kb_error(2191,"Cannot create worker threads.\n",UNRECOVERABLE);
; 621  :       }
; 622  :     }
; 623  :     /* wait for workers to begin waiting; */
; 624  :     pthread_cond_wait(&mainthread_wakeup,&thread_mutex);
; 625  :     pthread_mutex_unlock(&thread_mutex);
; 626  : 
; 627  :     sprintf(msg,"Created %d worker threads.\n", procs_requested);
; 628  :     outstring(msg);
; 629  :   }
; 630  : #endif
; 631  : 
; 632  :   /* If not doing multiple processes then have a thread data
; 633  :      structure so we don't have to write different code
; 634  :      for threading and nonthreading various places */
; 635  :   if ( thread_data_ptrs == NULL )

	cmp	DWORD PTR _thread_data_ptrs, 0
	jne	SHORT $LN16@main

; 636  :   { thread_data_ptrs = &default_thread_data_ptr;
; 637  :     thread_data_ptrs[0] = &default_thread_data;
; 638  :     #ifdef WINTHREADS
; 639  :     /* set per-thread data */
; 640  :     TlsSetValue(thread_data_key,(void*)&default_thread_data);

	mov	edx, DWORD PTR _thread_data_key
	push	OFFSET _default_thread_data
	push	edx
	mov	DWORD PTR _thread_data_ptrs, OFFSET _default_thread_data_ptr
	mov	DWORD PTR _default_thread_data_ptr, OFFSET _default_thread_data
	call	DWORD PTR __imp__TlsSetValue@8
$LN16@main:

; 641  :     #endif
; 642  :     #ifdef PTHREADS
; 643  :     /* set per-thread data */
; 644  :     pthread_setspecific(thread_data_key,(void*)&default_thread_data);
; 645  :     #endif
; 646  :   }
; 647  : 
; 648  : 
; 649  :   signal(SIGINT,catcher);    /* to catch user interrupt */     

	push	OFFSET _catcher
	push	2
	call	_signal

; 650  : #ifdef SIGUSR1
; 651  :   signal(SIGUSR1,catcher);    /* to catch user interrupt */     
; 652  : #endif
; 653  : #ifdef SIGALRM
; 654  :   signal(SIGALRM,catcher);    /* to catch alarm clock */     
; 655  : #endif
; 656  : #ifdef SIGTERM
; 657  :   signal(SIGTERM,catcher);    /* to catch user interrupt, dump and kill  */     

	push	OFFSET _catcher
	push	15					; 0000000fH
	call	_signal
	add	esp, 16					; 00000010H

; 658  : #endif
; 659  : #ifdef SIGHUP
; 660  :   signal(SIGHUP,catcher);    /* to catch user interrupt, dump and kill  */     
; 661  : #endif
; 662  : #ifdef SIGPIPE
; 663  :   signal(SIGPIPE,catcher);    /* to catch broken pipe */     
; 664  : #endif
; 665  : 
; 666  :   ENTER_GRAPH_MUTEX;

	call	DWORD PTR __imp__GetCurrentThreadId@0
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN15@main
	xor	edi, edi
	push	edi
	push	100000					; 000186a0H
	push	edi
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR _locking_thread, eax
	lea	esi, DWORD PTR [edi+1]
	jmp	SHORT $LN14@main
$LN15@main:
	xor	esi, esi
	xor	edi, edi
$LN14@main:

; 667  :   scoeff_init();

	call	_scoeff_init

; 668  :   vcoeff_init();  

	call	_vcoeff_init

; 669  : //  reset_web();  /* in case no datafile on command line */
; 670  : //  init_view();
; 671  :   LEAVE_GRAPH_MUTEX;

	cmp	esi, edi
	je	SHORT $LN13@main
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, edi
	call	DWORD PTR __imp__ReleaseMutex@4
$LN13@main:

; 672  : 
; 673  :   if ( argc && argv &&  argv[0] && argv[1] )

	cmp	DWORD PTR _argc$[ebp], edi
	je	SHORT $LN12@main
	mov	eax, DWORD PTR _argv$GSCopy$[ebp]
	cmp	eax, edi
	je	SHORT $LN12@main
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN12@main
	cmp	DWORD PTR [eax+4], edi
	je	SHORT $LN12@main

; 674  :      kb_error(1323,"Extra command line arguments ignored.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CH@FFHPDDF@Extra?5command?5line?5arguments?5ign@
	push	1323					; 0000052bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN12@main:

; 675  : 
; 676  :   /* command sources stack */
; 677  :   push_commandfd(stdin,"stdin");

	push	OFFSET ??_C@_05MHOFLBOO@stdin?$AA@
	call	___iob_func
	push	eax
	call	_push_commandfd
	add	esp, 8

; 678  : 
; 679  :   subshell_depth = 0;

	mov	DWORD PTR _subshell_depth, edi

; 680  :   if ( cmdfilename )    /* trap back to here if error and skip cmdfilename */

	cmp	DWORD PTR _cmdfilename, edi
	je	SHORT $LN10@main

; 681  :   { if ( !setjmp(jumpbuf[subshell_depth]) ) 

	push	edi
	push	OFFSET _jumpbuf
	call	__setjmp3
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@main

; 682  : #ifdef __L_EVOLVER__
; 683  : 		//if (l_evolver_mode)
; 684  : 			//push_commandfd(l_infd,"");
; 685  : 		//else
; 686  : #endif  
; 687  :       push_commandfd(NULL,cmdfilename);

	mov	ecx, DWORD PTR _cmdfilename
	push	ecx
	push	edi
	call	_push_commandfd
	add	esp, 8
$LN10@main:

; 688  :   }
; 689  : 
; 690  : #ifdef __cplusplus
; 691  :   char *to_load = (argc > 0) ? argv[0] : NULL; 
; 692  :   for ( ;; )
; 693  :   {
; 694  :     try
; 695  :     {
; 696  :       startup(to_load);
; 697  :       datafile_flag = 0;
; 698  :       /* use C++ exception mechanism instead of setjmp/longjmp */
; 699  :       for (;;)
; 700  :       {
; 701  :         try
; 702  :         { 
; 703  :           exec_commands(NULL,"Enter command: "); /* command read/execute loop */
; 704  :         }
; 705  :         catch ( int k )
; 706  :         { 
; 707  :         }
; 708  :       }
; 709  :     }
; 710  :     catch ( loadexcep k )  /* corresponds to loadjumpbuf */
; 711  :     { /* LOAD command returns here */
; 712  :       if ( list && (list != permlist)) 
; 713  :       { myfree((char*)list); list = NULL; }/* plug memory leak */
; 714  :       to_load = loadfilename[0] ? loadfilename : NULL;
; 715  :     }
; 716  :     catch ( int j )   /* corresponds to jumpbuf */
; 717  :     { to_load = NULL;
; 718  :     }
; 719  :   }
; 720  : 
; 721  : #else
; 722  :   if ( setjmp(loadjumpbuf) )

	push	edi
	push	OFFSET _loadjumpbuf
	call	__setjmp3
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@main

; 723  :   { /* LOAD command returns here */
; 724  :     if ( list && (list != permlist)) 

	mov	eax, DWORD PTR _list
	cmp	eax, edi
	je	SHORT $LN8@main
	cmp	eax, DWORD PTR _permlist
	je	SHORT $LN8@main

; 725  :     { myfree((char*)list); list = NULL; }/* plug memory leak */

	push	eax
	call	_myfree
	add	esp, 4
	mov	DWORD PTR _list, edi
$LN8@main:

; 726  : #ifdef MPI_EVOLVER
; 727  :     if ( this_task == MASTER_TASK )
; 728  :        mpi_loadfile();
; 729  : #endif
; 730  :     mpi_initialization_flag = 1;
; 731  :     startup(loadfilename);

	push	OFFSET _loadfilename
	mov	DWORD PTR _mpi_initialization_flag, 1
	call	_startup

; 732  :     mpi_initialization_flag = 0;

	mov	DWORD PTR _mpi_initialization_flag, edi

; 733  :   }
; 734  :   else

	jmp	SHORT $LN156@main
$LN9@main:

; 735  :   { if ( setjmp(jumpbuf[subshell_depth]) )    /* return here after datafile errors */

	mov	edx, DWORD PTR _subshell_depth
	shl	edx, 6
	add	edx, OFFSET _jumpbuf
	push	edi
	push	edx
	call	__setjmp3
	add	esp, 8
	test	eax, eax

; 736  :     { 
; 737  :         startup(NULL);
; 738  :     }
; 739  :     else

	jne	SHORT $LN4@main

; 740  :     { if ( argc > 0 ) 

	cmp	DWORD PTR _argc$[ebp], edi
	jle	SHORT $LN4@main

; 741  : 	    startup(argv[0]);

	mov	eax, DWORD PTR _argv$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx

; 742  :       else

	jmp	SHORT $LN157@main
$LN4@main:

; 743  : 	  {
; 744  : #ifdef MPI_EVOLVER
; 745  : 		  if ( this_task != MASTER_TASK )
; 746  : 		    return 0; /* let master task ask for datafile */  
; 747  : #endif
; 748  : 		  startup(NULL);

	push	edi
$LN157@main:
	call	_startup
$LN156@main:
	add	esp, 4

; 749  :        }
; 750  : 
; 751  :     }
; 752  :   }
; 753  :   datafile_flag = 0;
; 754  : #endif
; 755  : 
; 756  : #ifdef MPI_EVOLVER
; 757  : //  MPI_Barrier(MPI_COMM_WORLD);
; 758  :   if ( this_task > 0 )
; 759  :     return 0;   /* return to mpi main() */
; 760  :   calc_energy();  /* initial energy */
; 761  : #endif
; 762  : 
; 763  :   subshell_depth = 0;

	xor	eax, eax
	mov	DWORD PTR _datafile_flag, edi
	mov	DWORD PTR _subshell_depth, eax
	jmp	SHORT $LN2@main
	npad	1
$LL139@main:
	mov	eax, DWORD PTR _subshell_depth
$LN2@main:

; 764  : #ifdef __cplusplus
; 765  : #else
; 766  :   /* return here after commandfile  errors */
; 767  :   while ( setjmp(jumpbuf[subshell_depth]) != 0 );   

	shl	eax, 6
	add	eax, OFFSET _jumpbuf
	push	0
	push	eax
	call	__setjmp3
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL139@main

; 768  :   exec_commands(NULL,"Enter command: ");  /* command read and execute loop */

	push	OFFSET ??_C@_0BA@LDMPFPFF@Enter?5command?3?5?$AA@
	push	eax
	call	_exec_commands
	add	esp, 8

; 769  : #endif
; 770  : 
; 771  :   my_exit(0);

	push	0
	call	_my_exit
$LN160@main:
$LN154@main:
	npad	3
$LN158@main:

; 772  : 
; 773  :   return 0; /* success return code */
; 774  : } // end main()

	DD	$LN39@main
	DD	$LN93@main
	DD	$LN70@main
	DD	$LN73@main
	DD	$LN46@main
	DD	$LN90@main
	DD	$LN83@main
	DD	$LN94@main
	DD	$LN76@main
	DD	$LN88@main
	DD	$LN92@main
	DD	$LN48@main
	DD	$LN89@main
	DD	$LN85@main
	DD	$LN32@main
	DD	$LN47@main
	DD	$LN34@main
	DD	$LN35@main
	DD	$LN44@main
	DD	$LN91@main
	DD	$LN59@main
	DD	$LN45@main
	DD	$LN87@main
	DD	$LN37@main
	DD	$LN38@main
	DD	$LN36@main
	DD	$LN33@main
$LN127@main:
	DB	0
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	1
	DB	2
	DB	3
	DB	26					; 0000001aH
	DB	4
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	5
	DB	26					; 0000001aH
	DB	6
	DB	26					; 0000001aH
	DB	7
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	8
	DB	26					; 0000001aH
	DB	9
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	10					; 0000000aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	26					; 0000001aH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	26					; 0000001aH
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
_main	ENDP
_TEXT	ENDS
END
