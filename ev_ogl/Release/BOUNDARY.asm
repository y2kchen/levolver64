; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\BOUNDARY.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_a$GSCopy$
PUBLIC	_param$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_b_proj
EXTRN	_mat_inv:PROC
EXTRN	_dot:PROC
EXTRN	_eval_all:PROC
EXTRN	_mat2d_setup:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT __real@0000000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\boundary.c
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _b_proj
_TEXT	SEGMENT
_BqXvS$ = -728						; size = 24
_TqXvS$ = -704						; size = 24
_dummy$ = -680						; size = 8
tv4255 = -672						; size = 4
_pcount$ = -672						; size = 4
tv4383 = -668						; size = 4
tv4357 = -668						; size = 4
tv3283 = -668						; size = 4
tv4340 = -664						; size = 4
tv4183 = -664						; size = 4
tv1263 = -664						; size = 4
_k$ = -660						; size = 4
tv1972 = -656						; size = 4
tv486 = -652						; size = 4
_B$ = -652						; size = 4
_T$ = -648						; size = 4
tv4007 = -644						; size = 4
tv3837 = -644						; size = 4
tv2975 = -644						; size = 4
tv2543 = -644						; size = 4
_param$GSCopy$ = -644					; size = 4
tv3039 = -640						; size = 4
tv2520 = -640						; size = 4
_i$ = -640						; size = 4
tv4252 = -636						; size = 4
tv1922 = -636						; size = 4
tv877 = -636						; size = 4
tv156 = -636						; size = 4
_m$ = -636						; size = 4
tv3600 = -632						; size = 4
tv3280 = -632						; size = 4
tv2539 = -632						; size = 4
_a$GSCopy$ = -632					; size = 4
_BxJ$ = -628						; size = 288
_TxJ$ = -340						; size = 288
_temp$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_bdry$ = 8						; size = 4
_param$ = 12						; size = 4
_a$ = 16						; size = 4
_type$ = 20						; size = 4
_v_id$ = 24						; size = 4
_b_proj	PROC						; COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 728				; 000002d8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 54   :   int pcount = bdry->pcount;
; 55   :   int i,j,k,m;
; 56   :   REAL dummy;  /* for eval_all function value */
; 57   :   REAL temp[MAXCOORD];
; 58   :   MAT2D(B,MAXCOORD,MAXCOORD); /* both A and B above */

	mov	eax, DWORD PTR _param$[ebp]

; 82   :       { a[m][j] = 0.0;

	mov	ecx, DWORD PTR _a$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _bdry$[ebp]
	mov	ebx, DWORD PTR [edi+40]
	push	6
	push	6
	lea	edx, DWORD PTR _BxJ$[ebp]
	mov	DWORD PTR _param$GSCopy$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _BqXvS$[ebp]
	push	eax
	mov	DWORD PTR _a$GSCopy$[ebp], ecx
	mov	DWORD PTR _pcount$[ebp], ebx
	call	_mat2d_setup
	push	6
	push	6
	lea	ecx, DWORD PTR _TxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _TqXvS$[ebp]
	push	edx
	mov	DWORD PTR _B$[ebp], eax
	call	_mat2d_setup
	xor	esi, esi
	add	esp, 32					; 00000020H
	mov	DWORD PTR _T$[ebp], eax
	cmp	DWORD PTR _web+616, esi
	jle	$LN96@b_proj

; 62   :   { eval_all(bdry->coordf[j],param,pcount,&dummy,temp,v_id);

	add	edi, 48					; 00000030H
	mov	DWORD PTR tv1922[ebp], edi
	npad	8
$LL47@b_proj:
	mov	eax, DWORD PTR _v_id$[ebp]
	push	eax
	mov	eax, DWORD PTR _param$GSCopy$[ebp]
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR _dummy$[ebp]
	push	edx
	push	ebx
	push	eax
	push	ecx
	call	_eval_all
	add	esp, 24					; 00000018H

; 63   :     for ( i = 0 ; i < pcount ; i++ )

	xor	eax, eax
	cmp	ebx, 4
	jl	SHORT $LC79@b_proj

; 62   :   { eval_all(bdry->coordf[j],param,pcount,&dummy,temp,v_id);

	mov	ecx, DWORD PTR _T$[ebp]
	lea	edx, DWORD PTR [ebx-3]
	add	ecx, 8

; 63   :     for ( i = 0 ; i < pcount ; i++ )

$LL80@b_proj:

; 64   :       T[i][j] = temp[i];

	fld	QWORD PTR _temp$[ebp+eax*8]
	mov	edi, DWORD PTR [ecx-8]
	fstp	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR [ecx-4]
	fld	QWORD PTR _temp$[ebp+eax*8+8]
	add	eax, 4
	fstp	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR [ecx]
	fld	QWORD PTR _temp$[ebp+eax*8-16]
	add	ecx, 16					; 00000010H
	fstp	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR [ecx-12]
	fld	QWORD PTR _temp$[ebp+eax*8-8]
	fstp	QWORD PTR [edi+esi*8]
	cmp	eax, edx
	jl	SHORT $LL80@b_proj
$LC79@b_proj:

; 63   :     for ( i = 0 ; i < pcount ; i++ )

	cmp	eax, ebx
	jge	SHORT $LN46@b_proj
	npad	6
$LC44@b_proj:

; 64   :       T[i][j] = temp[i];

	mov	edx, DWORD PTR _T$[ebp]
	fld	QWORD PTR _temp$[ebp+eax*8]
	mov	ecx, DWORD PTR [edx+eax*4]
	inc	eax
	fstp	QWORD PTR [ecx+esi*8]
	cmp	eax, ebx
	jl	SHORT $LC44@b_proj
$LN46@b_proj:

; 59   :   MAT2D(T,MAXCOORD,MAXCOORD);
; 60   : 
; 61   :   for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR tv1922[ebp]
	inc	esi
	add	edi, 4
	mov	DWORD PTR tv1922[ebp], edi
	cmp	esi, DWORD PTR _web+616
	jl	$LL47@b_proj
$LN96@b_proj:

; 65   :   }
; 66   :   for ( i = 0 ; i < pcount ; i++ )

	test	ebx, ebx
	jle	SHORT $LN39@b_proj
	mov	edi, DWORD PTR _B$[ebp]
	mov	eax, DWORD PTR _T$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv1972[ebp], eax
	mov	DWORD PTR tv877[ebp], ebx
	npad	1
$LL90@b_proj:

; 67   :      for ( j = 0 ; j < pcount ; j++ )

	xor	esi, esi
	npad	14
$LL91@b_proj:

; 68   :         B[i][j] = SDIM_dot(T[i],T[j]);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _T$[ebp]
	mov	ecx, DWORD PTR [eax+esi*4]
	push	edx
	mov	edx, DWORD PTR tv1972[ebp]
	mov	eax, DWORD PTR [edx+edi]
	push	ecx
	push	eax
	call	_dot
	mov	ecx, DWORD PTR [edi]
	fstp	QWORD PTR [ecx+esi*8]
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, ebx
	jl	SHORT $LL91@b_proj

; 65   :   }
; 66   :   for ( i = 0 ; i < pcount ; i++ )

	add	edi, 4
	dec	DWORD PTR tv877[ebp]
	jne	SHORT $LL90@b_proj
$LN39@b_proj:

; 69   :   mat_inv(B,pcount);

	mov	edi, DWORD PTR _B$[ebp]
	push	ebx
	push	edi
	call	_mat_inv

; 70   : 
; 71   :   if ( type == PARAMPROJ )

	mov	eax, DWORD PTR _type$[ebp]
	add	esp, 8
	cmp	eax, 1
	jne	$LN35@b_proj

; 72   :   { for ( i = 0 ; i < pcount ; i++ )

	test	ebx, ebx
	jle	$LN7@b_proj
	mov	edx, DWORD PTR _a$GSCopy$[ebp]
	fldz
	mov	eax, DWORD PTR _web+616
	sub	edx, edi
	mov	DWORD PTR tv2520[ebp], edi
	mov	DWORD PTR tv2539[ebp], edx
	mov	DWORD PTR tv486[ebp], ebx
$LN34@b_proj:

; 73   :       for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	eax, eax
	jle	$LN33@b_proj

; 72   :   { for ( i = 0 ; i < pcount ; i++ )

	mov	eax, DWORD PTR [edx+edi]
	mov	DWORD PTR tv2543[ebp], eax
$LN99@b_proj:

; 74   :       { a[i][j] = 0.0;

	mov	eax, DWORD PTR tv2543[ebp]
	fst	QWORD PTR [eax+ecx*8]

; 75   :         for ( k = 0 ; k < pcount ; k++ )

	xor	eax, eax
	cmp	ebx, 4
	jl	$LC82@b_proj

; 74   :       { a[i][j] = 0.0;

	mov	edx, DWORD PTR [edx+edi]
	mov	eax, DWORD PTR [edi]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	inc	edi
	lea	esi, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _T$[ebp]
	mov	DWORD PTR tv156[ebp], edi
	add	edi, edi
	add	edx, 8
	add	eax, 16					; 00000010H
	add	edi, edi
	mov	DWORD PTR _k$[ebp], edi

; 75   :         for ( k = 0 ; k < pcount ; k++ )

$LN83@b_proj:

; 76   :            a[i][j] += B[i][k]*T[k][j];

	mov	edi, DWORD PTR [edx-8]
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR [edx-4]
	fmul	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv156[ebp]
	fadd	QWORD PTR [esi]
	fst	QWORD PTR [esi]
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR [edx-16]
	fmul	QWORD PTR [eax-40]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [esi]
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR [edx-12]
	fmul	QWORD PTR [eax-32]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [esi]
	fld	QWORD PTR [edi+ecx*8]
	fmul	QWORD PTR [eax-24]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi]
	jne	SHORT $LN83@b_proj

; 74   :       { a[i][j] = 0.0;

	mov	edx, DWORD PTR tv2539[ebp]
	mov	edi, DWORD PTR tv2520[ebp]
	mov	eax, DWORD PTR _k$[ebp]
$LC82@b_proj:

; 75   :         for ( k = 0 ; k < pcount ; k++ )

	cmp	eax, ebx
	jge	SHORT $LN30@b_proj

; 73   :       for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR [edx+edi]
	lea	esi, DWORD PTR [edx+ecx*8]

; 75   :         for ( k = 0 ; k < pcount ; k++ )

	mov	edx, DWORD PTR [edi]
	lea	edx, DWORD PTR [edx+eax*8]
$LN95@b_proj:

; 76   :            a[i][j] += B[i][k]*T[k][j];

	mov	edi, DWORD PTR _T$[ebp]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+ecx*8]
	inc	eax
	fmul	QWORD PTR [edx]
	add	edx, 8
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	cmp	eax, ebx
	jl	SHORT $LN95@b_proj

; 75   :         for ( k = 0 ; k < pcount ; k++ )

	mov	edi, DWORD PTR tv2520[ebp]
	mov	edx, DWORD PTR tv2539[ebp]
$LN30@b_proj:

; 73   :       for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	inc	ecx
	cmp	ecx, eax
	jl	$LN99@b_proj
$LN33@b_proj:

; 72   :   { for ( i = 0 ; i < pcount ; i++ )

	add	edi, 4
	dec	DWORD PTR tv486[ebp]
	mov	DWORD PTR tv2520[ebp], edi
	jne	$LN34@b_proj

; 89   :   { for ( i = 0 ; i < SDIM ; i++ )

	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx

; 94   :       }
; 95   :   }
; 96   : } /* end b_proj() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@b_proj:

; 77   :       }
; 78   :   }
; 79   :   else if ( type == TANGPROJ )

	cmp	eax, 2
	jne	$LN24@b_proj

; 80   :   { for ( m = 0 ; m < SDIM ; m++ )

	mov	eax, DWORD PTR _web+616
	xor	edi, edi
	mov	DWORD PTR _m$[ebp], edi
	test	eax, eax
	jle	$LN7@b_proj
	mov	ecx, DWORD PTR _a$GSCopy$[ebp]
	fldz
	mov	DWORD PTR tv3280[ebp], ecx
$LN102@b_proj:

; 81   :       for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	eax, eax
	jle	$LN22@b_proj

; 72   :   { for ( i = 0 ; i < pcount ; i++ )

	mov	edx, DWORD PTR tv3280[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv3283[ebp], eax
$LN100@b_proj:

; 82   :       { a[m][j] = 0.0;

	mov	edx, DWORD PTR tv3283[ebp]
	fst	QWORD PTR [edx+ecx*8]

; 83   :         for ( i = 0 ; i < pcount ; i++ )

	test	ebx, ebx
	jle	$LN19@b_proj
	mov	edx, DWORD PTR _B$[ebp]
	mov	esi, DWORD PTR _T$[ebp]
	sub	esi, edx
	mov	DWORD PTR tv3039[ebp], edx
	mov	DWORD PTR tv1972[ebp], esi
	mov	DWORD PTR tv2975[ebp], ebx
$LN17@b_proj:

; 84   :           for ( k = 0 ; k < pcount ; k++ )

	xor	eax, eax
	cmp	ebx, 4
	jl	$LC85@b_proj

; 81   :       for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR [edx+esi]
	mov	edx, DWORD PTR tv3280[ebp]
	lea	edi, DWORD PTR [eax+edi*8]
	mov	eax, DWORD PTR [edx]

; 84   :           for ( k = 0 ; k < pcount ; k++ )

	mov	edx, DWORD PTR _T$[ebp]
	add	ebx, -4					; fffffffcH
	shr	ebx, 2
	lea	esi, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR tv3039[ebp]
	mov	eax, DWORD PTR [eax]
	inc	ebx
	mov	DWORD PTR tv1263[ebp], ebx
	add	ebx, ebx
	add	edx, 8
	add	eax, 16					; 00000010H
	add	ebx, ebx
	mov	DWORD PTR _k$[ebp], ebx
$LN86@b_proj:

; 85   :             a[m][j] += T[i][m]*B[i][k]*T[k][j];

	fld	QWORD PTR [eax-16]
	mov	ebx, DWORD PTR [edx-8]
	fmul	QWORD PTR [edi]
	add	eax, 32					; 00000020H
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv1263[ebp]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-20]
	fadd	QWORD PTR [esi]
	fst	QWORD PTR [esi]
	fld	QWORD PTR [eax-40]
	fmul	QWORD PTR [edi]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-16]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [esi]
	fld	QWORD PTR [edi]
	fmul	QWORD PTR [eax-32]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-12]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [esi]
	fld	QWORD PTR [eax-24]
	fmul	QWORD PTR [edi]
	fmul	QWORD PTR [ebx+ecx*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi]
	jne	SHORT $LN86@b_proj

; 84   :           for ( k = 0 ; k < pcount ; k++ )

	mov	ebx, DWORD PTR _pcount$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR _m$[ebp]
	mov	esi, DWORD PTR tv1972[ebp]
	mov	edx, DWORD PTR tv3039[ebp]
$LC85@b_proj:
	cmp	eax, ebx
	jge	SHORT $LN16@b_proj
	mov	esi, DWORD PTR [edx+esi]
	mov	edx, DWORD PTR [edx]
	lea	edi, DWORD PTR [esi+edi*8]
	mov	esi, DWORD PTR tv3280[ebp]
	mov	esi, DWORD PTR [esi]
	lea	esi, DWORD PTR [esi+ecx*8]
	mov	DWORD PTR tv4340[ebp], esi
	lea	edx, DWORD PTR [edx+eax*8]
$LN93@b_proj:

; 85   :             a[m][j] += T[i][m]*B[i][k]*T[k][j];

	fld	QWORD PTR [edi]
	mov	esi, DWORD PTR _T$[ebp]
	fmul	QWORD PTR [edx]
	mov	esi, DWORD PTR [esi+eax*4]
	inc	eax
	add	edx, 8
	fmul	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR tv4340[ebp]
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	cmp	eax, ebx
	jl	SHORT $LN93@b_proj

; 84   :           for ( k = 0 ; k < pcount ; k++ )

	mov	esi, DWORD PTR tv1972[ebp]
	mov	edx, DWORD PTR tv3039[ebp]
	mov	edi, DWORD PTR _m$[ebp]
$LN16@b_proj:

; 83   :         for ( i = 0 ; i < pcount ; i++ )

	add	edx, 4
	dec	DWORD PTR tv2975[ebp]
	mov	DWORD PTR tv3039[ebp], edx
	jne	$LN17@b_proj
$LN19@b_proj:

; 81   :       for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	inc	ecx
	cmp	ecx, eax
	jl	$LN100@b_proj
$LN22@b_proj:

; 80   :   { for ( m = 0 ; m < SDIM ; m++ )

	add	DWORD PTR tv3280[ebp], 4
	inc	edi
	mov	DWORD PTR _m$[ebp], edi
	cmp	edi, eax
	jl	$LN102@b_proj

; 89   :   { for ( i = 0 ; i < SDIM ; i++ )

	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx

; 94   :       }
; 95   :   }
; 96   : } /* end b_proj() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@b_proj:

; 86   :       }
; 87   :   }
; 88   :   else if ( type == GRADPROJ )

	cmp	eax, 3
	jne	$LN7@b_proj

; 89   :   { for ( i = 0 ; i < SDIM ; i++ )

	xor	edi, edi
	mov	DWORD PTR _i$[ebp], edi
	cmp	DWORD PTR _web+616, edi
	jle	$LN7@b_proj
	mov	edx, DWORD PTR _a$GSCopy$[ebp]
	fldz
	mov	DWORD PTR tv4252[ebp], edx
$LN103@b_proj:

; 90   :       for ( j = 0 ; j < pcount ; j++ )

	xor	eax, eax
	test	ebx, ebx
	jle	$LN8@b_proj

; 72   :   { for ( i = 0 ; i < pcount ; i++ )

	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR tv4255[ebp], ecx
$LN101@b_proj:

; 91   :       { a[i][j] = 0.0;

	mov	ecx, DWORD PTR tv4255[ebp]
	fst	QWORD PTR [ecx+eax*8]

; 92   :         for ( k = 0 ; k < pcount ; k++ )

	xor	ecx, ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ebx, 4
	jl	$LC88@b_proj

; 91   :       { a[i][j] = 0.0;

	mov	esi, DWORD PTR _T$[ebp]
	mov	edi, DWORD PTR _B$[ebp]
	mov	edx, DWORD PTR [edx]
	lea	ecx, DWORD PTR [esi+12]

; 93   :           a[i][j] += T[k][i]*B[k][j];

	sub	esi, edi
	mov	DWORD PTR tv1972[ebp], esi
	lea	esi, DWORD PTR [ebx-4]
	shr	esi, 2
	inc	esi
	mov	DWORD PTR tv3837[ebp], esi
	add	esi, esi
	lea	edx, DWORD PTR [edx+eax*8]
	add	esi, esi
	mov	DWORD PTR tv3600[ebp], ecx
	mov	DWORD PTR tv4357[ebp], edx
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR _k$[ebp], esi
$LN92@b_proj:
	mov	esi, DWORD PTR [ecx-4]
	fld	QWORD PTR [esi+eax*8]
	mov	edi, DWORD PTR tv3600[ebp]
	mov	edi, DWORD PTR [edi-12]
	mov	esi, DWORD PTR _i$[ebp]
	fmul	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR [ecx]
	add	ecx, 16					; 00000010H
	fadd	QWORD PTR [edx]
	fst	QWORD PTR [edx]
	mov	edx, DWORD PTR tv1972[ebp]
	mov	edx, DWORD PTR [edx+ecx-16]
	fld	QWORD PTR [edx+esi*8]
	mov	edx, DWORD PTR tv4357[ebp]
	fmul	QWORD PTR [edi+eax*8]
	mov	esi, DWORD PTR [ecx-12]
	mov	edi, DWORD PTR tv3600[ebp]
	mov	edi, DWORD PTR [edi-4]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [edx]
	fld	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR _i$[ebp]
	fmul	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR tv3600[ebp]
	mov	esi, DWORD PTR [ecx-8]
	mov	edi, DWORD PTR [edi]
	add	DWORD PTR tv3600[ebp], 16		; 00000010H
	faddp	ST(1), ST(0)
	dec	DWORD PTR tv3837[ebp]
	mov	DWORD PTR tv4183[ebp], edi
	mov	edi, DWORD PTR _i$[ebp]
	fst	QWORD PTR [edx]
	fld	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR tv4183[ebp]
	fmul	QWORD PTR [esi+edi*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx]
	jne	$LN92@b_proj

; 91   :       { a[i][j] = 0.0;

	mov	edx, DWORD PTR tv4252[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
$LC88@b_proj:

; 92   :         for ( k = 0 ; k < pcount ; k++ )

	cmp	ecx, ebx
	jge	SHORT $LN5@b_proj
	mov	edx, DWORD PTR [edx]
	mov	esi, DWORD PTR _B$[ebp]
	lea	edx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR tv4383[ebp], edx
	mov	edx, DWORD PTR _T$[ebp]
	sub	edx, esi
	lea	ecx, DWORD PTR [esi+ecx*4]
	mov	esi, ebx
	sub	esi, DWORD PTR _k$[ebp]
	mov	DWORD PTR tv1972[ebp], edx
	mov	DWORD PTR tv4007[ebp], esi
	jmp	SHORT $LC3@b_proj
$LN94@b_proj:
	mov	edx, DWORD PTR tv1972[ebp]
$LC3@b_proj:

; 93   :           a[i][j] += T[k][i]*B[k][j];

	mov	edx, DWORD PTR [edx+ecx]
	fld	QWORD PTR [edx+edi*8]
	mov	esi, DWORD PTR [ecx]
	fmul	QWORD PTR [esi+eax*8]
	mov	edx, DWORD PTR tv4383[ebp]
	add	ecx, 4
	dec	DWORD PTR tv4007[ebp]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	jne	SHORT $LN94@b_proj

; 92   :         for ( k = 0 ; k < pcount ; k++ )

	mov	edx, DWORD PTR tv4252[ebp]
$LN5@b_proj:

; 90   :       for ( j = 0 ; j < pcount ; j++ )

	inc	eax
	cmp	eax, ebx
	jl	$LN101@b_proj
$LN8@b_proj:

; 89   :   { for ( i = 0 ; i < SDIM ; i++ )

	inc	edi
	add	edx, 4
	mov	DWORD PTR _i$[ebp], edi
	mov	DWORD PTR tv4252[ebp], edx
	cmp	edi, DWORD PTR _web+616
	jl	$LN103@b_proj
	fstp	ST(0)
$LN7@b_proj:

; 94   :       }
; 95   :   }
; 96   : } /* end b_proj() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_b_proj	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0GA@DPACIFHN@Extrapolate?5does?5not?5converge?5in@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ddb7cdfd9d7bdbb
PUBLIC	_new_param$GSCopy$
PUBLIC	_new_x$GSCopy$
PUBLIC	_bdry$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_b_extrapolate
EXTRN	_kb_error:PROC
EXTRN	_errmsg:BYTE
EXTRN	_sprintf:PROC
EXTRN	_elnames:BYTE
EXTRN	_eval:PROC
EXTRN	_matvec_mul:PROC
;	COMDAT ??_C@_0GA@DPACIFHN@Extrapolate?5does?5not?5converge?5in@
CONST	SEGMENT
??_C@_0GA@DPACIFHN@Extrapolate?5does?5not?5converge?5in@ DB 'Extrapolate '
	DB	'does not converge in 10 steps:  ', 0aH, '  boundary %s is not'
	DB	' smooth enough at vertex %s. ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3ddb7cdfd9d7bdbb
CONST	SEGMENT
__real@3ddb7cdfd9d7bdbb DQ 03ddb7cdfd9d7bdbbr	; 1e-010
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _b_extrapolate
_TEXT	SEGMENT
_aqXvS$ = -572						; size = 24
_newsq$89135 = -548					; size = 8
_newx$89136 = -540					; size = 8
_new_x$GSCopy$ = -532					; size = 4
_lambda$89133 = -528					; size = 8
_a$ = -520						; size = 4
_oldsq$89134 = -516					; size = 8
_bdry$GSCopy$ = -508					; size = 4
_new_param$GSCopy$ = -504				; size = 4
tv2332 = -500						; size = 4
tv1001 = -500						; size = 4
tv1268 = -496						; size = 4
_iter$89138 = -496					; size = 4
tv1804 = -492						; size = 4
tv1440 = -492						; size = 4
tv1272 = -492						; size = 4
_pcount$ = -488						; size = 4
_axJ$ = -484						; size = 288
_co$ = -196						; size = 48
_pp$89137 = -148					; size = 48
_s$ = -100						; size = 48
_x$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_bdry$ = 8						; size = 4
_base_x$ = 12						; size = 4
_point_x$ = 16						; size = 4
_new_x$ = 20						; size = 4
_base_param$ = 24					; size = 4
_new_param$ = 28					; size = 4
_v_id$ = 32						; size = 4
_b_extrapolate PROC					; COMDAT

; 116  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 572				; 0000023cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 117  :   int pcount;
; 118  :   REAL co[MAXCOORD];
; 119  :   int i,k;
; 120  :   REAL x[MAXCOORD],s[MAXCOORD];
; 121  :   MAT2D(a,MAXPARAM,MAXCOORD);

	mov	eax, DWORD PTR _new_x$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _bdry$[ebp]
	push	edi
	mov	edi, DWORD PTR _new_param$[ebp]
	push	6
	push	6
	lea	ecx, DWORD PTR _axJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _aqXvS$[ebp]
	push	edx
	mov	DWORD PTR _bdry$GSCopy$[ebp], esi
	mov	DWORD PTR _new_x$GSCopy$[ebp], eax

; 154  :       {
; 155  :         // the goal is  x + lambda*(point_x - x)
; 156  :         // the distance is lambda*sqrt(oldsq);
; 157  :         for( k=0;k<pcount;k++){ pp[k]= new_param[k]+lambda*co[k]; }

	mov	DWORD PTR _new_param$GSCopy$[ebp], edi
	call	_mat2d_setup
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR _a$[ebp], eax
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR _pcount$[ebp], eax
	add	esp, 16					; 00000010H
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN30@b_extrapol

; 122  : 
; 123  :   pcount = bdry->pcount;
; 124  :   for ( k = 0 ; k < SDIM ; k++ )

	mov	ecx, DWORD PTR _base_x$[ebp]
	lea	edx, DWORD PTR _x$[ebp]
	sub	ecx, edx
	mov	edx, DWORD PTR _base_param$[ebp]
	lea	esi, DWORD PTR _x$[ebp]
	sub	edx, esi
	mov	esi, edi
	lea	ebx, DWORD PTR _x$[ebp]
	sub	esi, ebx
	mov	DWORD PTR tv1001[ebp], esi
	jmp	SHORT $LN32@b_extrapol
	npad	11
$LL70@b_extrapol:
	mov	esi, DWORD PTR tv1001[ebp]
$LN32@b_extrapol:
	lea	ebx, DWORD PTR [ecx+eax*8]

; 125  :   { x[k] = base_x[k];              /* start at base point */

	fld	QWORD PTR _x$[ebp+ebx]
	lea	ebx, DWORD PTR [edx+eax*8]
	fstp	QWORD PTR _x$[ebp+eax*8]
	lea	esi, DWORD PTR [esi+eax*8]

; 126  :     new_param[k] = base_param[k];

	fld	QWORD PTR _x$[ebp+ebx]
	inc	eax
	fstp	QWORD PTR _x$[ebp+esi]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL70@b_extrapol

; 122  : 
; 123  :   pcount = bdry->pcount;
; 124  :   for ( k = 0 ; k < SDIM ; k++ )

	mov	edx, DWORD PTR _web+616
$LN30@b_extrapol:

; 127  :   }
; 128  : 
; 129  : #ifdef OLDWAY
; 130  :   /* iterate projection on tangent till get close to desired point */
; 131  :   for ( i = 0 ; i < 5 ; i++ )
; 132  :   {
; 133  :     for ( k = 0 ; k < SDIM ; k++ )
; 134  :       s[k] = point_x[k] - x[k];
; 135  :     b_proj(bdry,new_param,a,PARAMPROJ,v_id);
; 136  :     matvec_mul(a,s,co,pcount,SDIM);
; 137  :     for ( k = 0 ; k < pcount ; k++ )
; 138  :       new_param[k] += co[k];
; 139  :     for ( k = 0 ; k < SDIM ; k++ )
; 140  :       x[k] = eval(bdry->coordf[k],new_param,NULLID,NULL);
; 141  :   }
; 142  : #else
; 143  :   /* from Laszlo Csirmaz, being much more careful */
; 144  :   for ( i=0; i<5; i++)

	fld	QWORD PTR __real@3ddb7cdfd9d7bdbb
	mov	DWORD PTR tv2332[ebp], 5
$LN29@b_extrapol:

; 145  :   { REAL lambda, oldsq,newsq,newx; REAL pp[MAXPARAM];
; 146  :     int iter;
; 147  :     lambda=1.0; oldsq=0.0;

	fld1

; 148  :     for(k=0;k<SDIM;k++){ s[k]=point_x[k]-x[k]; oldsq += s[k]*s[k]; }

	xor	ecx, ecx
	fstp	QWORD PTR _lambda$89133[ebp]
	fldz
	fst	QWORD PTR _oldsq$89134[ebp]
	cmp	edx, 4
	jl	$LN66@b_extrapol
	mov	esi, DWORD PTR _point_x$[ebp]
	lea	ebx, DWORD PTR _s$[ebp]
	sub	ebx, esi
	mov	DWORD PTR tv1268[ebp], ebx
	lea	ebx, DWORD PTR _x$[ebp+8]
	sub	ebx, esi
	mov	DWORD PTR tv1272[ebp], ebx
	lea	edx, DWORD PTR _x$[ebp]
	lea	ebx, DWORD PTR _s$[ebp+8]
	sub	edx, esi
	lea	eax, DWORD PTR [esi+16]
	sub	ebx, esi
$LN58@b_extrapol:
	fld	QWORD PTR [eax-16]
	mov	esi, DWORD PTR tv1268[ebp]
	fsub	QWORD PTR _x$[ebp+ecx*8]
	add	ecx, 4
	add	eax, 32					; 00000020H
	fst	QWORD PTR _s$[ebp+ecx*8-32]
	fld	QWORD PTR [eax-40]
	fsub	QWORD PTR _x$[ebp+ecx*8-24]
	fst	QWORD PTR _s$[ebp+ecx*8-24]
	fld	QWORD PTR [eax-32]
	fsub	QWORD PTR [edx+eax-32]
	fst	QWORD PTR [esi+eax-32]
	mov	esi, DWORD PTR tv1272[ebp]
	fld	QWORD PTR [eax-24]
	fsub	QWORD PTR [esi+eax-32]
	mov	esi, DWORD PTR _web+616
	add	esi, -3					; fffffffdH
	fst	QWORD PTR [ebx+eax-32]
	fld	ST(3)
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	faddp	ST(4), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(3)
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	cmp	ecx, esi
	jl	SHORT $LN58@b_extrapol
	mov	edx, DWORD PTR _web+616
	fst	QWORD PTR _oldsq$89134[ebp]
$LN66@b_extrapol:
	cmp	ecx, edx
	jge	SHORT $LN56@b_extrapol
	mov	esi, DWORD PTR _point_x$[ebp]
	lea	eax, DWORD PTR _x$[ebp]
	sub	esi, eax
$LC26@b_extrapol:
	lea	eax, DWORD PTR _x$[ebp+ecx*8]
	fld	QWORD PTR [eax+esi]
	inc	ecx
	fsub	QWORD PTR [eax]
	fst	QWORD PTR _s$[ebp+ecx*8-8]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	cmp	ecx, edx
	jl	SHORT $LC26@b_extrapol
	fst	QWORD PTR _oldsq$89134[ebp]
$LN56@b_extrapol:

; 149  :     if( oldsq > 1e-10 )

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN28@b_extrapol

; 150  :     {
; 151  :       b_proj(bdry,new_param,a,PARAMPROJ,v_id);

	mov	ecx, DWORD PTR _v_id$[ebp]
	fstp	ST(0)
	mov	esi, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _bdry$GSCopy$[ebp]
	push	ecx
	push	1
	push	esi
	push	edi
	push	edx
	call	_b_proj

; 152  :       matvec_mul(a,s,co,pcount,SDIM); /* the correcting vector is in co */

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _pcount$[ebp]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _co$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	push	esi
	call	_matvec_mul

; 153  :       for(iter=0;iter<10;iter++)

	fld	QWORD PTR _oldsq$89134[ebp]
	fld	QWORD PTR _lambda$89133[ebp]
	add	esp, 40					; 00000028H
	fldz
	mov	DWORD PTR _iter$89138[ebp], 0
	fld	QWORD PTR __real@3ddb7cdfd9d7bdbb
	fld	QWORD PTR __real@3fe0000000000000
	jmp	SHORT $LN22@b_extrapol
$LN63@b_extrapol:
	fldz
	fxch	ST(1)
	fxch	ST(4)
	fxch	ST(3)
	fxch	ST(1)
	fxch	ST(2)
$LN22@b_extrapol:

; 154  :       {
; 155  :         // the goal is  x + lambda*(point_x - x)
; 156  :         // the distance is lambda*sqrt(oldsq);
; 157  :         for( k=0;k<pcount;k++){ pp[k]= new_param[k]+lambda*co[k]; }

	xor	ecx, ecx
	cmp	DWORD PTR _pcount$[ebp], 4
	jl	$LC60@b_extrapol
	lea	ebx, DWORD PTR _co$[ebp+8]
	sub	ebx, edi
	mov	DWORD PTR tv1804[ebp], ebx
	lea	edx, DWORD PTR _co$[ebp]
	lea	esi, DWORD PTR _pp$89137[ebp]
	lea	ebx, DWORD PTR _pp$89137[ebp+8]
	sub	edx, edi
	sub	esi, edi
	lea	eax, DWORD PTR [edi+16]
	sub	ebx, edi
$LN61@b_extrapol:
	fld	QWORD PTR _co$[ebp+ecx*8]
	mov	edi, DWORD PTR tv1804[ebp]
	fmul	ST(0), ST(4)
	add	ecx, 4
	add	eax, 32					; 00000020H
	fadd	QWORD PTR [eax-48]
	fstp	QWORD PTR _pp$89137[ebp+ecx*8-32]
	fld	QWORD PTR _co$[ebp+ecx*8-24]
	fmul	ST(0), ST(4)
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR _pp$89137[ebp+ecx*8-24]
	fld	QWORD PTR [edx+eax-32]
	fmul	ST(0), ST(4)
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [esi+eax-32]
	fld	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR _pcount$[ebp]
	fmul	ST(0), ST(4)
	add	edi, -3					; fffffffdH
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [ebx+eax-32]
	cmp	ecx, edi
	jl	SHORT $LN61@b_extrapol
	mov	edi, DWORD PTR _new_param$GSCopy$[ebp]
$LC60@b_extrapol:
	cmp	ecx, DWORD PTR _pcount$[ebp]
	jge	SHORT $LN59@b_extrapol
	mov	edx, DWORD PTR _pcount$[ebp]
	lea	esi, DWORD PTR _co$[ebp]
	lea	ebx, DWORD PTR _pp$89137[ebp]
	sub	esi, edi
	sub	ebx, edi
	lea	eax, DWORD PTR [edi+ecx*8]
	sub	edx, ecx
$LC19@b_extrapol:
	fld	QWORD PTR [eax+esi]
	add	eax, 8
	dec	edx
	fmul	ST(0), ST(4)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax+ebx-8]
	jne	SHORT $LC19@b_extrapol
$LN59@b_extrapol:

; 158  :         // let's see how close we get
; 159  :         newsq=0.0; newx=0.0;

	fld	ST(2)

; 160  :         for(k=0;k<SDIM;k++)

	xor	esi, esi
	fst	QWORD PTR _newsq$89135[ebp]
	fxch	ST(3)
	fst	QWORD PTR _newx$89136[ebp]
	cmp	DWORD PTR _web+616, esi
	jle	$LN14@b_extrapol
	mov	eax, DWORD PTR _point_x$[ebp]
	fstp	ST(3)
	mov	edi, DWORD PTR _bdry$GSCopy$[ebp]
	fstp	ST(3)
	fstp	ST(1)
	lea	ebx, DWORD PTR _s$[ebp]
	lea	ecx, DWORD PTR _x$[ebp]
	fstp	ST(2)
	add	edi, 48					; 00000030H
	fstp	ST(0)
	sub	ebx, eax
	sub	eax, ecx
	mov	DWORD PTR tv1440[ebp], eax
	jmp	SHORT $LN133@b_extrapol
	npad	7
$LL130@b_extrapol:
	fstp	ST(0)
	fstp	ST(1)
$LN133@b_extrapol:

; 161  :         { REAL tmp;
; 162  :           s[k]=eval(bdry->coordf[k],pp,NULLID,NULL);

	mov	eax, DWORD PTR [edi]
	fstp	ST(0)
	push	0
	push	0
	lea	edx, DWORD PTR _pp$89137[ebp]
	push	edx
	push	eax
	call	_eval
	mov	ecx, DWORD PTR tv1440[ebp]
	lea	eax, DWORD PTR [ecx+esi*8]
	lea	eax, DWORD PTR _x$[ebp+eax]
	fst	QWORD PTR [ebx+eax]
	inc	esi

; 163  :           tmp = x[k]-s[k]; newx += tmp*tmp;

	fsubr	QWORD PTR _x$[ebp+esi*8-8]
	add	esp, 16					; 00000010H
	add	edi, 4
	fld	ST(0)
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _newx$89136[ebp]
	fst	QWORD PTR _newx$89136[ebp]

; 164  :           tmp += lambda*(point_x[k]-x[k]);

	fld	QWORD PTR [eax]
	fsub	QWORD PTR _x$[ebp+esi*8-8]
	fld	QWORD PTR _lambda$89133[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	faddp	ST(3), ST(0)

; 165  :           newsq+= tmp*tmp;

	fld	ST(2)
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	fadd	QWORD PTR _newsq$89135[ebp]
	fst	QWORD PTR _newsq$89135[ebp]
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL130@b_extrapol

; 160  :         for(k=0;k<SDIM;k++)

	fld	QWORD PTR _oldsq$89134[ebp]
	mov	edi, DWORD PTR _new_param$GSCopy$[ebp]
	fld	QWORD PTR __real@3ddb7cdfd9d7bdbb
	fld	QWORD PTR __real@3fe0000000000000
	fxch	ST(2)
	fxch	ST(5)
	fxch	ST(4)
	fxch	ST(1)
	fxch	ST(2)
	fxch	ST(1)
$LN14@b_extrapol:

; 166  :         }
; 167  :         // is it close enough? 
; 168  :         if( newsq <= 0.5*oldsq || (newsq <= oldsq+1e-10 &&
; 169  :               (newx <= 0.5*oldsq || newsq <= 1e-10 || newx <= 1e-10 ))) break;

	fld	ST(5)
	fmul	ST(0), ST(2)
	fcom	ST(4)
	fnstsw	ax
	test	ah, 1
	je	$LN105@b_extrapol
	fld	ST(6)
	fadd	ST(0), ST(4)
	fcomp	ST(5)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN108@b_extrapol
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 1
	je	$LN111@b_extrapol
	fxch	ST(3)
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	$LN114@b_extrapol
	fxch	ST(2)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN13@b_extrapol
	fstp	ST(2)
	jmp	SHORT $LN134@b_extrapol
$LN108@b_extrapol:
	fstp	ST(4)
	fstp	ST(0)
	fstp	ST(2)
$LN13@b_extrapol:

; 170  :         lambda *= 0.5;

	mov	eax, DWORD PTR _iter$89138[ebp]
	fxch	ST(2)
	fmul	ST(0), ST(1)
	inc	eax
	mov	DWORD PTR _iter$89138[ebp], eax
	fst	QWORD PTR _lambda$89133[ebp]

; 171  :         oldsq  *= 0.25;

	fxch	ST(3)
	fmul	QWORD PTR __real@3fd0000000000000
	fst	QWORD PTR _oldsq$89134[ebp]
	cmp	eax, 10					; 0000000aH
	jl	$LN63@b_extrapol

; 153  :       for(iter=0;iter<10;iter++)

	fstp	ST(3)
$LN134@b_extrapol:
	fstp	ST(2)
	fstp	ST(1)
$LN71@b_extrapol:

; 172  :       }
; 173  :       if(iter== 10 )

	cmp	DWORD PTR _iter$89138[ebp], 10		; 0000000aH
	jne	SHORT $LN10@b_extrapol

; 174  :       {
; 175  :          sprintf(errmsg,"Extrapolate does not converge in 10 steps:  \n  boundary %s is not smooth enough at vertex %s. \n", bdry->name, ELNAME(v_id));

	mov	eax, DWORD PTR _v_id$[ebp]
	fstp	ST(0)
	test	eax, 268435456				; 10000000H
	je	SHORT $LN35@b_extrapol
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN36@b_extrapol
$LN105@b_extrapol:

; 153  :       for(iter=0;iter<10;iter++)

	fstp	ST(4)
	fstp	ST(4)
	fstp	ST(3)
	fstp	ST(3)
	fstp	ST(0)
	fstp	ST(0)

; 166  :         }
; 167  :         // is it close enough? 
; 168  :         if( newsq <= 0.5*oldsq || (newsq <= oldsq+1e-10 &&
; 169  :               (newx <= 0.5*oldsq || newsq <= 1e-10 || newx <= 1e-10 ))) break;

	jmp	SHORT $LN71@b_extrapol
$LN111@b_extrapol:
	fstp	ST(3)
$LN114@b_extrapol:
	fstp	ST(3)
	fstp	ST(1)
	fstp	ST(2)
	fstp	ST(0)
	jmp	SHORT $LN71@b_extrapol
$LN35@b_extrapol:

; 174  :       {
; 175  :          sprintf(errmsg,"Extrapolate does not converge in 10 steps:  \n  boundary %s is not smooth enough at vertex %s. \n", bdry->name, ELNAME(v_id));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN36@b_extrapol:
	mov	edx, DWORD PTR _bdry$GSCopy$[ebp]
	push	eax
	push	edx
	push	OFFSET ??_C@_0GA@DPACIFHN@Extrapolate?5does?5not?5converge?5in@
	push	OFFSET _errmsg
	call	_sprintf

; 176  :          kb_error(9000, errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	9000					; 00002328H
	call	_kb_error
	fld	QWORD PTR __real@3ddb7cdfd9d7bdbb
	add	esp, 28					; 0000001cH
$LN10@b_extrapol:

; 177  :       }
; 178  :       for(k=0;k<SDIM;k++) x[k]=s[k];

	mov	ecx, DWORD PTR _web+616
	test	ecx, ecx
	jle	SHORT $LN68@b_extrapol
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	lea	esi, DWORD PTR _s$[ebp]
	lea	edi, DWORD PTR _x$[ebp]
	rep movsd
	mov	edi, DWORD PTR _new_param$GSCopy$[ebp]
$LN68@b_extrapol:

; 179  :       for(k=0;k<pcount;k++) new_param[k]=pp[k];

	mov	ecx, DWORD PTR _pcount$[ebp]
	test	ecx, ecx
	jle	SHORT $LN62@b_extrapol
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	lea	esi, DWORD PTR _pp$89137[ebp]
	rep movsd
	mov	edi, DWORD PTR _new_param$GSCopy$[ebp]
$LN62@b_extrapol:
	mov	edx, DWORD PTR _web+616
$LN28@b_extrapol:

; 127  :   }
; 128  : 
; 129  : #ifdef OLDWAY
; 130  :   /* iterate projection on tangent till get close to desired point */
; 131  :   for ( i = 0 ; i < 5 ; i++ )
; 132  :   {
; 133  :     for ( k = 0 ; k < SDIM ; k++ )
; 134  :       s[k] = point_x[k] - x[k];
; 135  :     b_proj(bdry,new_param,a,PARAMPROJ,v_id);
; 136  :     matvec_mul(a,s,co,pcount,SDIM);
; 137  :     for ( k = 0 ; k < pcount ; k++ )
; 138  :       new_param[k] += co[k];
; 139  :     for ( k = 0 ; k < SDIM ; k++ )
; 140  :       x[k] = eval(bdry->coordf[k],new_param,NULLID,NULL);
; 141  :   }
; 142  : #else
; 143  :   /* from Laszlo Csirmaz, being much more careful */
; 144  :   for ( i=0; i<5; i++)

	dec	DWORD PTR tv2332[ebp]
	jne	$LN29@b_extrapol
	pop	edi
	fstp	ST(0)

; 180  :     }
; 181  :   }
; 182  : #endif
; 183  : 
; 184  :   for ( i = 0 ; i < SDIM ; i++ ) new_x[i] = x[i];

	xor	ecx, ecx
	pop	esi
	pop	ebx
	test	edx, edx
	jle	SHORT $LN1@b_extrapol
	mov	eax, DWORD PTR _new_x$GSCopy$[ebp]
	lea	edx, DWORD PTR _x$[ebp]
	sub	edx, eax
$LL3@b_extrapol:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL3@b_extrapol
$LN1@b_extrapol:

; 185  : 
; 186  : } /* end b_extrapolate() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_b_extrapolate ENDP
_TEXT	ENDS
PUBLIC	__real@4008000000000000
PUBLIC	__real@4018000000000000
PUBLIC	__real@c018000000000000
PUBLIC	__real@4028000000000000
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_bdry_force
EXTRN	_eval_second:PROC
EXTRN	_get_edge_side:PROC
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	_E_BOUNDARY_ATTR:DWORD
EXTRN	__CIsqrt:PROC
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT __real@c018000000000000
CONST	SEGMENT
__real@c018000000000000 DQ 0c018000000000000r	; -6
CONST	ENDS
;	COMDAT __real@4028000000000000
CONST	SEGMENT
__real@4028000000000000 DQ 04028000000000000r	; 12
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _bdry_force
_TEXT	SEGMENT
_aqXvS$ = -424						; size = 12
_val$89227 = -412					; size = 8
_ac$89214 = -404					; size = 8
tv690 = -396						; size = 8
_st1$89217 = -388					; size = 8
_t1t1$89215 = -380					; size = 8
_t2t2$89216 = -372					; size = 8
_su1$89228 = -364					; size = 8
_t1u1$89219 = -356					; size = 8
_st2$89218 = -348					; size = 8
_t1t2$89226 = -340					; size = 8
_accel$89224 = -332					; size = 4
tv745 = -328						; size = 8
_ep$89223 = -328					; size = 8
_ar1$89221 = -328					; size = 8
tv713 = -320						; size = 8
_params$89225 = -316					; size = 4
tv733 = -312						; size = 8
_ss$ = -312						; size = 8
tv638 = -304						; size = 4
_a$ = -304						; size = 4
tv796 = -300						; size = 8
_su2$89229 = -300					; size = 8
_qq$ = -292						; size = 8
_t2u2$89220 = -292					; size = 8
_bdry$ = -284						; size = 4
tv696 = -280						; size = 4
_head$ = -280						; size = 4
tv729 = -276						; size = 8
tv1105 = -272						; size = 4
tv980 = -272						; size = 4
_e_id$GSCopy$ = -272					; size = 4
_axJ$ = -268						; size = 72
_t2$89213 = -196					; size = 48
_t1$89212 = -148					; size = 48
_q$ = -100						; size = 48
_s$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_bdry_force PROC					; COMDAT

; 210  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 424				; 000001a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]

; 211  :   REAL s[MAXCOORD],q[MAXCOORD],*f;
; 212  :   struct boundary *bdry;
; 213  :   vertex_id head,tail;
; 214  :   REAL norm;
; 215  :   int i; 
; 216  :   REAL qq,ss;
; 217  :   MAT2D(a,3,3);

	push	3
	push	3
	lea	eax, DWORD PTR _axJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _aqXvS$[ebp]
	push	ecx

; 229  :        if ( bdry != get_boundary(tail) ) return;

	mov	DWORD PTR _e_id$GSCopy$[ebp], esi
	call	_mat2d_setup
	mov	DWORD PTR _a$[ebp], eax
	mov	eax, DWORD PTR _web+124
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 64					; 00000040H
	xor	edx, edx
	add	esp, 16					; 00000010H
	or	eax, edx
	jne	$LN1@bdry_force

; 218  : 
; 219  :   if ( get_eattr(e_id) & FIXED ) return;
; 220  : 
; 221  :   /* see if edge and tail are on same boundary */
; 222  :   bdry = get_edge_boundary(e_id);

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	eax, eax
	je	$LN1@bdry_force
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	push	edi
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edi, DWORD PTR [eax+ecx]
	imul	edi, 136				; 00000088H
	add	edi, DWORD PTR _web+776
	mov	DWORD PTR _bdry$[ebp], edi

; 223  :   if ( !bdry ) return;

	je	$LN49@bdry_force

; 224  :   if ( !(bdry->attr & B_CONVEX) ) return;

	mov	eax, DWORD PTR [edi+32]
	and	eax, 8
	xor	ecx, ecx
	or	eax, ecx
	je	$LN49@bdry_force

; 225  :   tail = get_edge_tailv(e_id);

	push	ebx
	push	esi
	call	_get_edge_tailv

; 226  :   if ( bdry != get_boundary(tail) )

	mov	esi, DWORD PTR _V_BOUNDARY_ATTR
	add	esp, 4
	mov	ebx, eax
	test	esi, esi
	je	SHORT $LN30@bdry_force
	mov	eax, DWORD PTR _web+12
	mov	edx, esi
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR [ecx+edx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN31@bdry_force
$LN30@bdry_force:
	xor	eax, eax
$LN31@bdry_force:
	cmp	edi, eax
	je	SHORT $LN21@bdry_force

; 227  :      { invert(e_id);

	mov	eax, DWORD PTR _e_id$GSCopy$[ebp]
	xor	eax, 134217728				; 08000000H

; 228  :        tail = get_edge_tailv(e_id);

	push	eax
	mov	DWORD PTR _e_id$GSCopy$[ebp], eax
	call	_get_edge_tailv
	add	esp, 4
	mov	ebx, eax

; 229  :        if ( bdry != get_boundary(tail) ) return;

	test	esi, esi
	je	SHORT $LN32@bdry_force
	mov	ecx, DWORD PTR _web+12
	imul	esi, 240				; 000000f0H
	add	esi, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [esi+eax+64]
	mov	eax, DWORD PTR [edx+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN33@bdry_force
$LN32@bdry_force:
	xor	eax, eax
$LN33@bdry_force:
	cmp	edi, eax
	jne	$LN50@bdry_force
$LN21@bdry_force:

; 230  :      }
; 231  :   head = get_edge_headv(e_id);

	mov	esi, DWORD PTR _e_id$GSCopy$[ebp]
	push	esi
	call	_get_edge_headv

; 232  : 
; 233  :   /* now the calculation */
; 234  :   get_edge_side(e_id,s);

	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	push	esi
	mov	DWORD PTR _head$[ebp], eax
	call	_get_edge_side

; 235  :   ss = SDIM_dot(s,s);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _ss$[ebp]
	add	esp, 24					; 00000018H

; 236  : 
; 237  :   
; 238  :   if ( bdry->pcount == 1 )

	cmp	DWORD PTR [edi+40], 1
	jne	$LN20@bdry_force

; 241  : 
; 242  :      /* tail vertex */
; 243  :      params = get_param(tail);
; 244  :      su1 = t1t1 = st1 = t1u1 = 0.0;

	fldz
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _web+104
	fst	QWORD PTR _t1u1$89219[ebp]

; 245  :      for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _web+616
	fld	ST(0)
	lea	eax, DWORD PTR _ac$89214[ebp]
	fst	QWORD PTR _st1$89217[ebp]
	mov	DWORD PTR _accel$89224[ebp], eax
	fld	ST(1)
	mov	eax, ebx
	fst	QWORD PTR _t1t1$89215[ebp]
	and	eax, 134217727				; 07ffffffH
	fxch	ST(2)
	add	eax, eax
	fstp	QWORD PTR _su1$89228[ebp]
	add	eax, eax
	mov	DWORD PTR tv638[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+544]
	xor	edi, edi
	mov	DWORD PTR _params$89225[ebp], eax
	test	esi, esi
	jle	$LN17@bdry_force

; 239  :   { REAL t1[MAXCOORD],t2[MAXCOORD], ac,t1t1,t2t2,st1,st2,t1u1,t2u2,ar1,ar2,ep;
; 240  :     REAL *accel = &ac,*params,t1t2,val,su1,su2;

	mov	edx, DWORD PTR _bdry$[ebp]
	add	edx, 48					; 00000030H
	mov	DWORD PTR tv980[ebp], edx
	jmp	SHORT $LN80@bdry_force
	npad	1
$LL67@bdry_force:
	mov	eax, DWORD PTR _params$89225[ebp]
$LN80@bdry_force:

; 246  :      {
; 247  :         eval_second(bdry->coordf[i],params,bdry->pcount,&val,t1+i,&accel,tail);

	push	ebx
	fstp	ST(0)
	lea	ecx, DWORD PTR _accel$89224[ebp]
	fstp	ST(0)
	push	ecx
	mov	ecx, DWORD PTR _bdry$[ebp]
	lea	esi, DWORD PTR _t1$89212[ebp+edi*8]
	push	esi
	lea	edx, DWORD PTR _val$89227[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	push	eax
	mov	eax, DWORD PTR tv980[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_eval_second

; 248  :         t1t1 += t1[i]*t1[i];

	fld	QWORD PTR [esi]
	fmul	ST(0), ST(0)
	add	DWORD PTR tv980[ebp], 4
	inc	edi
	add	esp, 28					; 0000001cH
	fadd	QWORD PTR _t1t1$89215[ebp]
	fst	QWORD PTR _t1t1$89215[ebp]

; 249  :         st1 += s[i]*t1[i];

	fld	QWORD PTR _s$[ebp+edi*8-8]
	fmul	QWORD PTR [esi]
	fadd	QWORD PTR _st1$89217[ebp]
	fst	QWORD PTR _st1$89217[ebp]

; 250  :         t1u1 += t1[i]*ac;

	fld	QWORD PTR [esi]
	mov	esi, DWORD PTR _web+616
	fld	QWORD PTR _ac$89214[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR _t1u1$89219[ebp]
	fstp	QWORD PTR _t1u1$89219[ebp]

; 251  :         su1 += s[i]*ac;

	fmul	QWORD PTR _s$[ebp+edi*8-8]
	fadd	QWORD PTR _su1$89228[ebp]
	fstp	QWORD PTR _su1$89228[ebp]
	cmp	edi, esi
	jl	$LL67@bdry_force
$LN17@bdry_force:

; 252  :      }
; 253  :      ar1 = sqrt(ss*t1t1/st1/st1 - 1.0);

	fxch	ST(1)
	fmul	QWORD PTR _ss$[ebp]
	fst	QWORD PTR tv690[ebp]
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)
	fsub	QWORD PTR __real@3ff0000000000000
	call	__CIsqrt
	fstp	QWORD PTR _ar1$89221[ebp]

; 254  : 
; 255  :      /* head vertex */
; 256  :      params = get_param(head);

	mov	eax, DWORD PTR _head$[ebp]

; 257  :      su2 = t2t2 = st2 = t2u2 = t1t2 = 0.0;

	fldz
	mov	edx, DWORD PTR _web+12
	fst	QWORD PTR _t1t2$89226[ebp]
	mov	ecx, DWORD PTR _web+104
	fst	QWORD PTR _t2u2$89220[ebp]
	and	eax, 134217727				; 07ffffffH
	fld	ST(0)
	add	eax, eax
	fst	QWORD PTR _st2$89218[ebp]
	add	eax, eax
	fld	ST(1)
	mov	DWORD PTR tv696[ebp], eax
	fst	QWORD PTR _t2t2$89216[ebp]
	mov	eax, DWORD PTR [eax+edx]
	fxch	ST(2)
	mov	edx, DWORD PTR _dymem
	fstp	QWORD PTR _su2$89229[ebp]
	add	eax, DWORD PTR [ecx+edx+544]

; 258  :      for ( i = 0 ; i < SDIM ; i++ )

	xor	edi, edi
	mov	DWORD PTR _params$89225[ebp], eax
	test	esi, esi
	jle	$LN14@bdry_force

; 252  :      }
; 253  :      ar1 = sqrt(ss*t1t1/st1/st1 - 1.0);

	mov	ecx, DWORD PTR _bdry$[ebp]
	add	ecx, 48					; 00000030H
	mov	DWORD PTR tv1105[ebp], ecx
	jmp	SHORT $LN81@bdry_force
	npad	8
$LL68@bdry_force:
	mov	eax, DWORD PTR _params$89225[ebp]
$LN81@bdry_force:

; 259  :      {
; 260  :         eval_second(bdry->coordf[i],params,bdry->pcount,&val,t2+i,&accel,tail);

	push	ebx
	fstp	ST(0)
	lea	edx, DWORD PTR _accel$89224[ebp]
	fstp	ST(0)
	push	edx
	mov	edx, DWORD PTR _bdry$[ebp]
	lea	esi, DWORD PTR _t2$89213[ebp+edi*8]
	push	esi
	lea	ecx, DWORD PTR _val$89227[ebp]
	push	ecx
	mov	ecx, DWORD PTR [edx+40]
	mov	edx, DWORD PTR tv1105[ebp]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_eval_second

; 261  :         t2t2 += t2[i]*t2[i];

	fld	QWORD PTR [esi]
	fmul	ST(0), ST(0)
	add	DWORD PTR tv1105[ebp], 4
	inc	edi
	add	esp, 28					; 0000001cH
	fadd	QWORD PTR _t2t2$89216[ebp]
	fst	QWORD PTR _t2t2$89216[ebp]

; 262  :         t1t2 += t1[i]*t2[i];

	fld	QWORD PTR _t1$89212[ebp+edi*8-8]
	fmul	QWORD PTR [esi]
	fadd	QWORD PTR _t1t2$89226[ebp]
	fstp	QWORD PTR _t1t2$89226[ebp]

; 263  :         st2 += s[i]*t2[i];

	fld	QWORD PTR _s$[ebp+edi*8-8]
	fmul	QWORD PTR [esi]
	fadd	QWORD PTR _st2$89218[ebp]
	fst	QWORD PTR _st2$89218[ebp]

; 264  :         t2u2 += t2[i]*ac;

	fld	QWORD PTR [esi]
	mov	esi, DWORD PTR _web+616
	fld	QWORD PTR _ac$89214[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR _t2u2$89220[ebp]
	fstp	QWORD PTR _t2u2$89220[ebp]

; 265  :         su2 += s[i]*ac;

	fmul	QWORD PTR _s$[ebp+edi*8-8]
	fadd	QWORD PTR _su2$89229[ebp]
	fstp	QWORD PTR _su2$89229[ebp]
	cmp	edi, esi
	jl	$LL68@bdry_force
$LN14@bdry_force:

; 266  :      }
; 267  :      ar2 = sqrt(ss*t2t2/st2/st2 - 1.0);

	fxch	ST(1)
	fmul	QWORD PTR _ss$[ebp]
	fst	QWORD PTR tv713[ebp]
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)
	fsub	QWORD PTR __real@3ff0000000000000
	call	__CIsqrt

; 268  : 
; 269  :      ep = -st1/6*(ar1+ar2);
; 270  :      ep += ss/12/ar1*((-st1*t1t1+ss*t1u1) - ss*t1t1*(-t1t1+su1)/st1)/st1/st1;

	fld	QWORD PTR _ss$[ebp]
	fld	QWORD PTR __real@4028000000000000

; 271  :      ep += ss/12/ar2*(-st1*t2t2 + ss*t2t2*t1t2/st2)/st2/st2;
; 272  :      f = get_force(tail);

	mov	ecx, DWORD PTR tv638[ebp]
	fdivr	ST(0), ST(1)
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+784]

; 273  :      for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	fld	ST(0)
	fld	QWORD PTR _ar1$89221[ebp]
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fst	QWORD PTR tv729[ebp]
	fld	ST(4)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR tv733[ebp]
	fxch	ST(2)
	fdivrp	ST(4), ST(0)
	fxch	ST(3)
	fstp	QWORD PTR tv745[ebp]
	fld	QWORD PTR _t1u1$89219[ebp]
	fmul	ST(0), ST(2)
	fld	QWORD PTR _st1$89217[ebp]
	fld	ST(0)
	fld	QWORD PTR _t1t1$89215[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(3)
	fsubrp	ST(1), ST(0)
	fld	QWORD PTR _su1$89228[ebp]
	fsub	ST(0), ST(3)
	fmul	QWORD PTR tv690[ebp]
	fdiv	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fmulp	ST(5), ST(0)
	fdiv	ST(4), ST(0)
	fdiv	ST(4), ST(0)
	fld	QWORD PTR __real@c018000000000000
	fdivr	ST(0), ST(1)
	fmulp	ST(3), ST(0)
	fxch	ST(4)
	faddp	ST(2), ST(0)
	fld	QWORD PTR tv713[ebp]
	fmul	QWORD PTR _t1t2$89226[ebp]
	fld	QWORD PTR _st2$89218[ebp]
	fdiv	ST(1), ST(0)
	fld	QWORD PTR _t2t2$89216[ebp]
	fld	ST(0)
	fmul	ST(0), ST(7)
	fsubp	ST(3), ST(0)
	fld	QWORD PTR tv745[ebp]
	fmul	ST(3), ST(0)
	fxch	ST(3)
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(2)
	faddp	ST(5), ST(0)
	fxch	ST(4)
	fstp	QWORD PTR _ep$89223[ebp]
	test	esi, esi
	jle	SHORT $LN11@bdry_force
	lea	edx, DWORD PTR _t1$89212[ebp]
	sub	edx, eax
$LN46@bdry_force:

; 274  :         f[i] -= ep*t1[i]/t1t1;

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	QWORD PTR _ep$89223[ebp]
	add	eax, 8
	fdiv	ST(0), ST(3)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	esi, DWORD PTR _web+616
	cmp	ecx, esi
	jl	SHORT $LN46@bdry_force
$LN11@bdry_force:

; 275  : 
; 276  :      ep = st2/6*(ar1+ar2);
; 277  :      ep += ss/12/ar2*((st2*t2t2+ss*t2u2) - ss*t2t2*(t2t2+su2)/st2)/st2/st2;

	fld	ST(0)

; 278  :      ep += ss/12/ar1*(st2*t1t1 - ss*t1t1*t1t2/st1)/st1/st1;
; 279  :      f = get_force(head);

	mov	ecx, DWORD PTR _web+12
	fmul	ST(0), ST(4)
	mov	eax, DWORD PTR tv696[ebp]
	fld	QWORD PTR _t2u2$89220[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	fmulp	ST(6), ST(0)
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	add	eax, DWORD PTR [edx+ecx+784]
	faddp	ST(5), ST(0)

; 280  :      for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	fld	ST(3)
	fadd	QWORD PTR _su2$89229[ebp]
	fmul	QWORD PTR tv713[ebp]
	fdiv	ST(0), ST(1)
	fsubp	ST(5), ST(0)
	fxch	ST(4)
	fmulp	ST(1), ST(0)
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(3)
	fld	ST(3)
	fdiv	QWORD PTR __real@4018000000000000
	fmul	QWORD PTR tv733[ebp]
	faddp	ST(1), ST(0)
	fxch	ST(3)
	fmulp	ST(1), ST(0)
	fld	QWORD PTR tv690[ebp]
	fmul	QWORD PTR _t1t2$89226[ebp]
	fdiv	ST(0), ST(4)
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR tv729[ebp]
	fdiv	ST(0), ST(3)
	fdivrp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	test	esi, esi
	jle	SHORT $LN62@bdry_force
	lea	edx, DWORD PTR _t2$89213[ebp]
	sub	edx, eax
$LN10@bdry_force:

; 281  :         f[i] -= ep*t2[i]/t2t2;

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(2)
	add	eax, 8
	fdiv	ST(0), ST(1)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN10@bdry_force
$LN62@bdry_force:

; 280  :      for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(1)
$LN75@bdry_force:

; 298  :      for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN50@bdry_force:
	pop	ebx
$LN49@bdry_force:
	pop	edi
$LN1@bdry_force:
	pop	esi

; 300  :   }
; 301  : } /* end bdry_force */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@bdry_force:

; 282  : 
; 283  :   }
; 284  :   else  /* 2 or more parameters */
; 285  :   { b_proj(bdry,get_param(tail),a,TANGPROJ,tail);

	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR _web+104
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	push	ebx
	mov	ebx, DWORD PTR _a$[ebp]
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+544]
	push	2
	push	ebx
	push	eax
	push	edi
	call	_b_proj

; 286  :      matvec_mul(a,s,q,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	push	ebx
	call	_matvec_mul

; 287  :      qq = SDIM_dot(q,q);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fst	QWORD PTR _qq$[ebp]

; 288  :      norm = web.spring_constant*(1 + (ss-qq)/3/qq)*sqrt(fabs(ss-qq)/qq)/2; 

	fld	QWORD PTR _ss$[ebp]
	add	esp, 52					; 00000034H
	fsub	ST(0), ST(1)
	fst	QWORD PTR tv796[ebp]
	fabs
	fdivrp	ST(1), ST(0)
	call	__CIsqrt
	fld	QWORD PTR tv796[ebp]
	fdiv	QWORD PTR __real@4008000000000000

; 289  :      f = get_force(tail);

	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR _web+104
	mov	esi, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR _dymem
	add	esi, DWORD PTR [ecx+eax+784]

; 290  :      for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	fdiv	QWORD PTR _qq$[ebp]
	fadd	QWORD PTR __real@3ff0000000000000
	fmul	QWORD PTR _web+1584
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fe0000000000000
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN73@bdry_force
	lea	edx, DWORD PTR _q$[ebp]
	mov	eax, esi
	sub	edx, esi
$LN6@bdry_force:

; 291  :         f[i] += norm*q[i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN6@bdry_force
$LN73@bdry_force:

; 292  : 
; 293  :      b_proj(bdry,get_param(head),a,TANGPROJ,head);

	mov	eax, DWORD PTR _head$[ebp]
	fstp	ST(0)
	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR _web+104
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	push	eax
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+544]
	push	2
	push	ebx
	push	eax
	push	edi
	call	_b_proj

; 294  :      matvec_mul(a,s,q,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	push	ebx
	call	_matvec_mul

; 295  :      qq = SDIM_dot(q,q);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fst	QWORD PTR _qq$[ebp]

; 296  :      norm = web.spring_constant*(1 + (ss-qq)/3/qq)*sqrt(fabs(ss-qq)/qq)/2; 

	fld	QWORD PTR _ss$[ebp]
	add	esp, 52					; 00000034H
	fsub	ST(0), ST(1)
	fst	QWORD PTR tv796[ebp]
	fabs
	fdivrp	ST(1), ST(0)
	call	__CIsqrt
	fld	QWORD PTR tv796[ebp]
	fdiv	QWORD PTR __real@4008000000000000

; 297  :      f = get_force(head);

	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR _dymem
	mov	esi, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR _web+104
	add	esi, DWORD PTR [eax+ecx+784]

; 298  :      for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	fdiv	QWORD PTR _qq$[ebp]
	fadd	QWORD PTR __real@3ff0000000000000
	fmul	QWORD PTR _web+1584
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fe0000000000000
	cmp	DWORD PTR _web+616, ecx
	jle	$LN75@bdry_force
	lea	edx, DWORD PTR _q$[ebp]
	mov	eax, esi
	sub	edx, esi
$LN3@bdry_force:

; 299  :         f[i] -= norm*q[i];

	fld	QWORD PTR [eax+edx]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN3@bdry_force

; 300  :   }
; 301  : } /* end bdry_force */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	pop	ebx
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_bdry_force ENDP
_TEXT	ENDS
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_bdry_spring_energy
EXTRN	_binary_tree_add:PROC
; Function compile flags: /Ogtp
;	COMDAT _bdry_spring_energy
_TEXT	SEGMENT
_aqXvS$ = -208						; size = 12
tv327 = -196						; size = 8
_head$ = -192						; size = 4
_sprenergy$ = -188					; size = 8
_a$ = -184						; size = 4
_ss$ = -180						; size = 8
_e_id$GSCopy$ = -176					; size = 4
_axJ$ = -172						; size = 72
_s$ = -100						; size = 48
_q$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_bdry_spring_energy PROC				; COMDAT

; 311  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]

; 312  :   REAL s[MAXCOORD],q[MAXCOORD];
; 313  :   struct boundary *bdry;
; 314  :   vertex_id tail,head;
; 315  :   REAL ss,qq,sprenergy;
; 316  :   MAT2D(a,3,3);

	push	3
	push	3
	lea	eax, DWORD PTR _axJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _aqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _e_id$GSCopy$[ebp], edi
	call	_mat2d_setup
	mov	DWORD PTR _a$[ebp], eax

; 317  : 
; 318  :   if ( get_eattr(e_id) & FIXED ) return;

	mov	eax, DWORD PTR _web+124
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv327[ebp+4], eax
	mov	eax, edx
	and	eax, 64					; 00000040H
	xor	esi, esi
	add	esp, 16					; 00000010H
	or	eax, esi
	jne	$LN7@bdry_sprin

; 319  :   if ( !(get_eattr(e_id) & BOUNDARY) ) return;

	and	edx, 128				; 00000080H
	or	edx, eax
	je	$LN7@bdry_sprin

; 320  : 
; 321  :   /* see if edge and tail are on same boundary */
; 322  :   bdry = get_edge_boundary(e_id);

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	eax, eax
	je	$LN7@bdry_sprin
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	push	ebx
	mov	eax, DWORD PTR [eax+edx+64]
	mov	ebx, DWORD PTR [eax+ecx]
	imul	ebx, 136				; 00000088H
	add	ebx, DWORD PTR _web+776

; 323  :   if ( !bdry ) return;

	je	$LN15@bdry_sprin

; 324  :   if ( !(bdry->attr & B_CONVEX) ) return;

	mov	eax, DWORD PTR [ebx+32]
	and	eax, 8
	xor	ecx, ecx
	or	eax, ecx
	je	$LN15@bdry_sprin

; 325  :   tail = get_edge_tailv(e_id);

	push	edi
	call	_get_edge_tailv

; 326  :   head = get_edge_headv(e_id);

	push	edi
	mov	esi, eax
	call	_get_edge_headv

; 327  :   if ( bdry != get_boundary(tail) )

	mov	edi, DWORD PTR _V_BOUNDARY_ATTR
	add	esp, 8
	mov	DWORD PTR _head$[ebp], eax
	test	edi, edi
	je	SHORT $LN11@bdry_sprin
	mov	eax, DWORD PTR _web+12
	mov	edx, edi
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR [ecx+edx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN12@bdry_sprin
$LN11@bdry_sprin:
	xor	eax, eax
$LN12@bdry_sprin:
	cmp	ebx, eax
	je	SHORT $LN1@bdry_sprin

; 328  :      { 
; 329  :         invert(e_id);

	mov	eax, DWORD PTR _e_id$GSCopy$[ebp]
	xor	eax, 134217728				; 08000000H

; 330  :         tail = get_edge_tailv(e_id);

	push	eax
	mov	DWORD PTR _e_id$GSCopy$[ebp], eax
	call	_get_edge_tailv
	mov	esi, eax

; 331  :         head = get_edge_headv(e_id);

	mov	eax, DWORD PTR _e_id$GSCopy$[ebp]
	push	eax
	call	_get_edge_headv
	add	esp, 8
	mov	DWORD PTR _head$[ebp], eax

; 332  :         if ( bdry != get_boundary(tail) ) return;

	test	edi, edi
	je	SHORT $LN13@bdry_sprin
	mov	edx, DWORD PTR _web+12
	imul	edi, 240				; 000000f0H
	add	edi, DWORD PTR _web+104
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edi+ecx+64]
	mov	eax, DWORD PTR [eax+edx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN14@bdry_sprin
$LN13@bdry_sprin:
	xor	eax, eax
$LN14@bdry_sprin:
	cmp	ebx, eax
	jne	$LN15@bdry_sprin
$LN1@bdry_sprin:

; 333  :      }
; 334  : 
; 335  :   /* now the calculation */
; 336  :   get_edge_side(e_id,s);

	mov	ecx, DWORD PTR _e_id$GSCopy$[ebp]
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	push	ecx
	call	_get_edge_side

; 337  :   ss = SDIM_dot(s,s);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fstp	QWORD PTR _ss$[ebp]

; 338  : 
; 339  :   b_proj(bdry,get_param(tail),a,TANGPROJ,tail);

	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR _web+104
	mov	edi, DWORD PTR _a$[ebp]
	push	esi
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+544]
	push	2
	push	edi
	push	eax
	push	ebx
	call	_b_proj

; 340  :   matvec_mul(a,s,q,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	push	edi
	call	_matvec_mul

; 341  :   qq = SDIM_dot(q,q);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot

; 342  :   sprenergy = web.spring_constant*ss*sqrt((ss - qq)/qq)/12;

	fld	QWORD PTR _ss$[ebp]
	fsub	ST(0), ST(1)
	add	esp, 72					; 00000048H
	fdivrp	ST(1), ST(0)
	call	__CIsqrt
	fld	QWORD PTR _web+1584
	fmul	QWORD PTR _ss$[ebp]

; 343  : 
; 344  :   b_proj(bdry,get_param(head),a,TANGPROJ,head);

	mov	eax, DWORD PTR _head$[ebp]
	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR _web+104
	fmulp	ST(1), ST(0)
	push	eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	fdiv	QWORD PTR __real@4028000000000000
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+544]
	push	2
	push	edi
	push	eax
	push	ebx
	fstp	QWORD PTR _sprenergy$[ebp]
	call	_b_proj

; 345  :   matvec_mul(a,s,q,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	push	edi
	call	_matvec_mul

; 346  :   qq = SDIM_dot(q,q);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot

; 347  :   sprenergy += web.spring_constant*ss*sqrt((ss - qq)/qq)/12;

	fld	QWORD PTR _ss$[ebp]
	add	esp, 52					; 00000034H
	fsub	ST(0), ST(1)
	fdivrp	ST(1), ST(0)
	call	__CIsqrt
	fld	QWORD PTR _web+1584
	fmul	QWORD PTR _ss$[ebp]

; 348  : 
; 349  :   binary_tree_add(web.total_energy_addends,sprenergy);

	sub	esp, 8
	fmulp	ST(1), ST(0)
	fdiv	QWORD PTR __real@4028000000000000
	fadd	QWORD PTR _sprenergy$[ebp]
	fst	QWORD PTR _sprenergy$[ebp]
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1248
	call	_binary_tree_add

; 350  :   web.spring_energy += sprenergy;

	fld	QWORD PTR _web+1488
	fadd	QWORD PTR _sprenergy$[ebp]
	add	esp, 12					; 0000000cH
	fstp	QWORD PTR _web+1488
$LN15@bdry_sprin:
	pop	ebx
$LN7@bdry_sprin:

; 351  : } /* end bdry_spring_energy */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_bdry_spring_energy ENDP
_TEXT	ENDS
PUBLIC	_v_id$GSCopy$
PUBLIC	_basis$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_bdry_basis
; Function compile flags: /Ogtp
;	COMDAT _bdry_basis
_TEXT	SEGMENT
_dummy$ = -72						; size = 8
_v_id$GSCopy$ = -64					; size = 4
_basis$GSCopy$ = -60					; size = 4
tv291 = -56						; size = 4
_temp$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_basis$ = 12						; size = 4
_bdry_basis PROC					; COMDAT

; 365  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _basis$[ebp]
	mov	edx, DWORD PTR _v_id$[ebp]

; 372  : 
; 373  :   for ( j = 0 ; j < SDIM ; j++ )

	mov	DWORD PTR _basis$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	push	esi
	push	edi
	mov	DWORD PTR _v_id$GSCopy$[ebp], edx
	test	eax, eax
	je	SHORT $LN16@bdry_basis

; 366  :   struct boundary *b = get_boundary(v_id);

	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	edi, edx
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ecx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+ecx]
	mov	esi, DWORD PTR [eax+ecx]
	imul	esi, 136				; 00000088H
	add	esi, DWORD PTR _web+776

; 367  :   int j,i;
; 368  :   REAL dummy;  /* for eval_all function value */
; 369  :   REAL temp[MAXCOORD];
; 370  : 
; 371  :   if ( !b ) return 0;

	jne	SHORT $LN7@bdry_basis
$LN16@bdry_basis:
	pop	edi
	xor	eax, eax
	pop	esi

; 378  :    }
; 379  : 
; 380  :   return b->pcount;
; 381  : 
; 382  : } /* end bdry_basis() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@bdry_basis:
	push	ebx

; 372  : 
; 373  :   for ( j = 0 ; j < SDIM ; j++ )

	xor	ebx, ebx
	cmp	DWORD PTR _web+616, ebx
	jle	SHORT $LN4@bdry_basis
	mov	ecx, DWORD PTR [esi+40]
	lea	eax, DWORD PTR [esi+48]
	mov	DWORD PTR tv291[ebp], eax
	jmp	SHORT $LN6@bdry_basis
	npad	5
$LL17@bdry_basis:
	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
$LN6@bdry_basis:

; 374  :    {
; 375  :      eval_all(b->coordf[j],get_param(v_id),b->pcount,&dummy,temp,v_id);

	push	edx
	lea	edx, DWORD PTR _temp$[ebp]
	push	edx
	lea	eax, DWORD PTR _dummy$[ebp]
	push	eax
	mov	eax, DWORD PTR _web+104
	push	ecx
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [edi+ecx]
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+544]
	push	edx
	mov	edx, DWORD PTR tv291[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_eval_all

; 376  :      for ( i = 0 ; i < b->pcount ; i++ )

	mov	ecx, DWORD PTR [esi+40]
	add	esp, 24					; 00000018H
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN5@bdry_basis
$LL3@bdry_basis:

; 377  :         basis[i][j] = temp[i];

	mov	ecx, DWORD PTR _basis$GSCopy$[ebp]
	fld	QWORD PTR _temp$[ebp+eax*8]
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+ebx*8]
	mov	ecx, DWORD PTR [esi+40]
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL3@bdry_basis
$LN5@bdry_basis:

; 372  : 
; 373  :   for ( j = 0 ; j < SDIM ; j++ )

	add	DWORD PTR tv291[ebp], 4
	inc	ebx
	cmp	ebx, DWORD PTR _web+616
	jl	SHORT $LL17@bdry_basis
$LN4@bdry_basis:

; 378  :    }
; 379  : 
; 380  :   return b->pcount;
; 381  : 
; 382  : } /* end bdry_basis() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, DWORD PTR [esi+40]
	pop	ebx
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_bdry_basis ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@DNBPGHEO@Partner?5of?5?$CFs?5is?5?$CFd?0?5but?5partner@ ; `string'
PUBLIC	??_C@_0BA@EHMMIKMP@bdryhit_partner?$AA@		; `string'
PUBLIC	_detect_bdry_hits
EXTRN	_get_ordinal_id:PROC
EXTRN	_find_extra:PROC
;	COMDAT ??_C@_0CP@DNBPGHEO@Partner?5of?5?$CFs?5is?5?$CFd?0?5but?5partner@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CP@DNBPGHEO@Partner?5of?5?$CFs?5is?5?$CFd?0?5but?5partner@ DB 'Par'
	DB	'tner of %s is %d, but partner of %d is %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EHMMIKMP@bdryhit_partner?$AA@
CONST	SEGMENT
??_C@_0BA@EHMMIKMP@bdryhit_partner?$AA@ DB 'bdryhit_partner', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\boundary.c
CONST	ENDS
;	COMDAT _detect_bdry_hits
_TEXT	SEGMENT
_eltype$ = -44						; size = 4
_exnum$ = -40						; size = 4
tv491 = -36						; size = 8
tv529 = -32						; size = 4
tv565 = -28						; size = 8
tv541 = -24						; size = 4
tv513 = -24						; size = 4
tv482 = -20						; size = 4
tv191 = -20						; size = 4
_x$89423 = -20						; size = 4
tv725 = -16						; size = 4
tv684 = -16						; size = 4
tv166 = -16						; size = 4
_v_id$ = -12						; size = 4
_bdry$ = -8						; size = 4
tv484 = -4						; size = 4
_detect_bdry_hits PROC					; COMDAT

; 401  : { vertex_id v_id,vv_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 402  :   struct boundary *bdry;
; 403  :   int i,exnum,partner;
; 404  :   REAL p1,pp1;
; 405  :   int eltype;
; 406  :   
; 407  :   exnum = find_extra(BDRYHIT_PARTNER_NAME,&eltype);

	lea	eax, DWORD PTR _eltype$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@EHMMIKMP@bdryhit_partner?$AA@
	call	_find_extra
	add	esp, 8
	mov	DWORD PTR _exnum$[ebp], eax

; 408  :   if ( exnum < 0 ) 

	test	eax, eax
	js	$LN17@detect_bdr

; 409  :     return;
; 410  : 
; 411  :   FOR_ALL_VERTICES(v_id)

	push	esi
	mov	esi, DWORD PTR _web+48
	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _v_id$[ebp], esi
	mov	DWORD PTR tv482[ebp], eax
	je	$LN44@detect_bdr
	mov	ecx, DWORD PTR _web+12
	push	ebx
	push	edi
	jmp	SHORT $LN19@detect_bdr
	npad	9
$LL41@detect_bdr:
	mov	esi, DWORD PTR _v_id$[ebp]
$LN19@detect_bdr:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [edx+12]
	mov	edi, DWORD PTR [edx+8]
	mov	DWORD PTR tv491[ebp+4], eax
	mov	eax, edi
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv484[ebp], esi
	je	$LN18@detect_bdr

; 412  :   { if ( !(get_vattr(v_id) & BOUNDARY) ) continue;

	and	edi, 128				; 00000080H
	xor	eax, eax
	or	edi, eax
	je	$LN18@detect_bdr

; 413  :     bdry = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN23@detect_bdr
	mov	edi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edi+64]
	mov	eax, DWORD PTR [eax+edx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	mov	DWORD PTR _bdry$[ebp], eax
	jmp	SHORT $LN24@detect_bdr
$LN23@detect_bdr:
	mov	DWORD PTR _bdry$[ebp], ebx
	mov	eax, ebx
$LN24@detect_bdr:

; 414  :     if ( !(bdry->attr & PARTNER_HITTING) ) continue;

	mov	eax, DWORD PTR [eax+32]
	and	eax, 2048				; 00000800H
	xor	edi, edi
	or	eax, edi
	je	$LN18@detect_bdr

; 415  :     partner = *VINT(v_id,exnum);

	mov	eax, DWORD PTR _exnum$[ebp]
	mov	edi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	mov	DWORD PTR tv513[ebp], eax
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edi+64]
	mov	ebx, DWORD PTR [edx+eax]

; 416  :     if ( partner == 0 ) continue;

	test	ebx, ebx
	je	$LN18@detect_bdr

; 417  :     vv_id = get_ordinal_id(VERTEX,abs(partner)-1);

	mov	eax, ebx
	cdq
	xor	eax, edx
	sub	eax, edx
	dec	eax
	push	eax
	push	0
	call	_get_ordinal_id
	mov	edi, eax
	add	esp, 8

; 418  :     if ( !valid_id(vv_id) ) continue;

	test	edi, 268435456				; 10000000H
	je	$LN39@detect_bdr

; 419  : 
; 420  :     if ( abs(*VINT(vv_id,exnum)) != loc_ordinal(v_id)+1 )

	cmp	DWORD PTR tv482[ebp], 0
	mov	DWORD PTR tv166[ebp], esi
	jne	SHORT $LN26@detect_bdr
	mov	DWORD PTR tv166[ebp], -1
$LN26@detect_bdr:
	mov	ecx, DWORD PTR tv513[ebp]
	add	ecx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [ecx+eax+64]
	mov	ecx, DWORD PTR _web+12
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+eax]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR tv166[ebp]
	inc	edx
	mov	DWORD PTR tv529[ebp], esi
	cmp	eax, edx
	je	$LN10@detect_bdr

; 421  :     { sprintf(errmsg,"Partner of %s is %d, but partner of %d is %d.\n",
; 422  :         ELNAME(v_id),partner,partner,abs(*VINT(vv_id,exnum)));

	cmp	DWORD PTR tv482[ebp], 0
	je	SHORT $LN27@detect_bdr
	mov	eax, DWORD PTR tv484[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	ecx, DWORD PTR _web+12
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv191[ebp], OFFSET _elnames
	jmp	SHORT $LN28@detect_bdr
$LN27@detect_bdr:
	mov	DWORD PTR tv191[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN28@detect_bdr:
	mov	edx, DWORD PTR tv513[ebp]
	add	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+eax]
	mov	ecx, DWORD PTR tv191[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	push	eax
	push	ebx
	push	ebx
	push	ecx
	push	OFFSET ??_C@_0CP@DNBPGHEO@Partner?5of?5?$CFs?5is?5?$CFd?0?5but?5partner@
	push	OFFSET _errmsg
	call	_sprintf

; 423  :       kb_error(3378,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3378					; 00000d32H
	call	_kb_error
	mov	ecx, DWORD PTR _web+12
	add	esp, 36					; 00000024H
$LN10@detect_bdr:

; 424  :     }
; 425  :     p1 = get_param(v_id)[0];

	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+eax+544]
	mov	edx, DWORD PTR tv484[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv541[ebp], eax
	mov	eax, DWORD PTR [eax]
	fld	QWORD PTR [eax+edx]

; 426  :     pp1 = get_param(vv_id)[0];

	mov	edx, DWORD PTR [esi+ecx]
	fld	QWORD PTR [eax+edx]

; 427  :     if ( ((partner > 0) && (pp1 < p1 )) || ((partner < 0) && (pp1 > p1)) )

	test	ebx, ebx
	jle	SHORT $LN57@detect_bdr
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN8@detect_bdr
	test	ebx, ebx
$LN57@detect_bdr:
	jns	$LN56@detect_bdr
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN56@detect_bdr
$LN8@detect_bdr:

; 428  :     { REAL *param = get_param(v_id);

	mov	edx, DWORD PTR tv541[ebp]

; 429  :       REAL *x = get_coord(v_id);
; 430  :       param[0] = (p1+pp1)/2;

	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR tv484[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	ebx, DWORD PTR [edx]
	fmul	QWORD PTR __real@3fe0000000000000
	mov	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+64]
	fst	QWORD PTR tv565[ebp]
	add	ebx, ecx
	add	eax, ecx
	fst	QWORD PTR [ebx]

; 431  :       for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	mov	DWORD PTR _x$89423[ebp], eax
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN4@detect_bdr
	mov	eax, DWORD PTR _bdry$[ebp]
	fstp	ST(0)
	add	eax, 48					; 00000030H
	mov	DWORD PTR tv684[ebp], eax
$LL42@detect_bdr:

; 432  :          x[i] = eval(bdry->coordf[i],param,v_id,NULL);

	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	edx, DWORD PTR tv684[ebp]
	mov	eax, DWORD PTR [edx]
	push	0
	push	ecx
	push	ebx
	push	eax
	call	_eval
	mov	ecx, DWORD PTR _x$89423[ebp]
	add	DWORD PTR tv684[ebp], 4
	fstp	QWORD PTR [ecx+esi*8]
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL42@detect_bdr

; 431  :       for ( i = 0 ; i < SDIM ; i++ )

	fld	QWORD PTR tv565[ebp]
$LN4@detect_bdr:

; 433  :       param = get_param(vv_id);

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+12
	mov	esi, DWORD PTR tv529[ebp]
	mov	ebx, DWORD PTR [ecx+edx+544]
	mov	eax, DWORD PTR [esi+eax]

; 434  :       x = get_coord(vv_id);

	mov	ecx, DWORD PTR [ecx+edx+64]

; 435  :       param[0] = (p1+pp1)/2;

	fstp	QWORD PTR [ebx+eax]
	add	ebx, eax
	add	ecx, eax

; 436  :       for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	mov	DWORD PTR _x$89423[ebp], ecx
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN1@detect_bdr

; 433  :       param = get_param(vv_id);

	mov	ecx, DWORD PTR _bdry$[ebp]
	add	ecx, 48					; 00000030H
	mov	DWORD PTR tv725[ebp], ecx
	npad	4
$LL43@detect_bdr:

; 437  :          x[i] = eval(bdry->coordf[i],param,vv_id,NULL);

	mov	edx, DWORD PTR tv725[ebp]
	mov	eax, DWORD PTR [edx]
	push	0
	push	edi
	push	ebx
	push	eax
	call	_eval
	mov	ecx, DWORD PTR _x$89423[ebp]
	add	DWORD PTR tv725[ebp], 4
	fstp	QWORD PTR [ecx+esi*8]
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL43@detect_bdr
$LN1@detect_bdr:

; 438  :       set_attr(v_id,HIT_PARTNER);

	mov	eax, DWORD PTR _v_id$[ebp]
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR tv484[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+12]

; 439  :       set_attr(vv_id,HIT_PARTNER);

	shr	edi, 29					; 0000001dH
	imul	edi, 112				; 00000070H
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR tv529[ebp]
	mov	ecx, 32768				; 00008000H
	or	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _web[edi+12]
	mov	eax, DWORD PTR [eax+edx]
	or	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR _web+12
	jmp	SHORT $LN40@detect_bdr
$LN39@detect_bdr:
	mov	ecx, DWORD PTR _web+12
	jmp	SHORT $LN18@detect_bdr
$LN56@detect_bdr:

; 427  :     if ( ((partner > 0) && (pp1 < p1 )) || ((partner < 0) && (pp1 > p1)) )

	fstp	ST(1)
	fstp	ST(0)
$LN40@detect_bdr:

; 439  :       set_attr(vv_id,HIT_PARTNER);

	mov	esi, DWORD PTR tv484[ebp]
$LN18@detect_bdr:

; 409  :     return;
; 410  : 
; 411  :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _v_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv482[ebp], eax
	jne	$LL41@detect_bdr
	pop	edi
	pop	ebx
$LN44@detect_bdr:
	pop	esi
$LN17@detect_bdr:

; 440  :     }
; 441  :   }
; 442  : } // end detect_bdry_hits()

	mov	esp, ebp
	pop	ebp
	ret	0
_detect_bdry_hits ENDP
_TEXT	ENDS
PUBLIC	_partner_hit_velocity_fix
; Function compile flags: /Ogtp
;	COMDAT _partner_hit_velocity_fix
_TEXT	SEGMENT
tv267 = -16						; size = 8
_eltype$ = -8						; size = 4
_exnum$ = -4						; size = 4
_partner_hit_velocity_fix PROC				; COMDAT

; 454  : { vertex_id v_id,vv_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 455  :   struct boundary *bdry;
; 456  :   int i,exnum,partner,eltype;
; 457  :   REAL *v,*vv;
; 458  :  
; 459  :   exnum = find_extra(BDRYHIT_PARTNER_NAME,&eltype);

	lea	eax, DWORD PTR _eltype$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@EHMMIKMP@bdryhit_partner?$AA@
	call	_find_extra
	add	esp, 8
	mov	DWORD PTR _exnum$[ebp], eax

; 460  :   if ( exnum < 0 ) 

	test	eax, eax
	js	$LN9@partner_hi

; 461  :     return;
; 462  : 
; 463  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	$LN9@partner_hi
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _web+12
	npad	5
$LL11@partner_hi:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	ebx, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [ebx+edi]
	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv267[ebp+4], eax
	mov	eax, edx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN10@partner_hi

; 464  :   { if ( !(get_vattr(v_id) & HIT_PARTNER) ) continue;

	and	edx, 32768				; 00008000H
	xor	eax, eax
	or	edx, eax
	je	$LN10@partner_hi

; 465  :     bdry = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN15@partner_hi
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN16@partner_hi
$LN15@partner_hi:
	xor	eax, eax
$LN16@partner_hi:

; 466  :     if ( !(bdry->attr & PARTNER_HITTING) ) continue;

	mov	eax, DWORD PTR [eax+32]
	and	eax, 2048				; 00000800H
	xor	edx, edx
	or	eax, edx
	je	$LN10@partner_hi

; 467  :     partner = *VINT(v_id,exnum);

	mov	edx, DWORD PTR _exnum$[ebp]
	mov	eax, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR [ecx+edx]

; 468  :     if ( partner == 0 ) continue;

	test	eax, eax
	je	SHORT $LN10@partner_hi

; 469  :     vv_id = get_ordinal_id(VERTEX,abs(partner)-1);

	cdq
	xor	eax, edx
	sub	eax, edx
	dec	eax
	push	eax
	push	0
	call	_get_ordinal_id

; 470  :     v = get_velocity(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR [ecx+edx+1024]
	mov	edi, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ebx+edi]

; 471  :     vv = get_velocity(vv_id);

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+eax*4]
	add	ecx, esi
	add	edx, esi

; 472  :     for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	add	esp, 8
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN10@partner_hi
	fld	QWORD PTR __real@3fe0000000000000
	mov	eax, ecx
	sub	edx, ecx
$LN3@partner_hi:

; 473  :     { REAL avev = (v[i]+vv[i])/2;

	fld	QWORD PTR [edx+eax]
	inc	esi
	fadd	QWORD PTR [eax]
	add	eax, 8
	fmul	ST(0), ST(1)

; 474  :       v[i] = vv[i] = avev;

	fst	QWORD PTR [edx+eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LN3@partner_hi

; 472  :     for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR _web+12
	fstp	ST(0)
$LN10@partner_hi:

; 461  :     return;
; 462  : 
; 463  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [ebx+edi]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL11@partner_hi
	pop	edi
	pop	esi
	pop	ebx
$LN9@partner_hi:

; 475  :     }
; 476  :   }
; 477  : } // end partner_hit_velocity_fix()

	mov	esp, ebp
	pop	ebp
	ret	0
_partner_hit_velocity_fix ENDP
_TEXT	ENDS
PUBLIC	_partner_hit_volgrad_fix
EXTRN	_get_vertex_vgrad:PROC
; Function compile flags: /Ogtp
;	COMDAT _partner_hit_volgrad_fix
_TEXT	SEGMENT
_eltype$ = -16						; size = 4
tv235 = -12						; size = 8
_vv_id$ = -8						; size = 4
_exnum$ = -4						; size = 4
_partner_hit_volgrad_fix PROC				; COMDAT

; 488  : { vertex_id v_id,vv_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 489  :   struct boundary *bdry;
; 490  :   int i,exnum,partner,eltype;
; 491  :  
; 492  :   exnum = find_extra(BDRYHIT_PARTNER_NAME,&eltype);

	lea	eax, DWORD PTR _eltype$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@EHMMIKMP@bdryhit_partner?$AA@
	call	_find_extra
	add	esp, 8
	mov	DWORD PTR _exnum$[ebp], eax

; 493  :   if ( exnum < 0 ) 

	test	eax, eax
	js	$LN16@partner_hi@2

; 494  :     return;
; 495  : 
; 496  :   FOR_ALL_VERTICES(v_id)

	push	edi
	mov	edi, DWORD PTR _web+48
	test	edi, 268435456				; 10000000H
	je	$LN33@partner_hi@2
	push	ebx
	push	esi
	npad	9
$LL18@partner_hi@2:
	mov	ecx, DWORD PTR _web+12
	mov	ebx, edi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv235[ebp+4], eax
	mov	eax, edx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN17@partner_hi@2

; 497  :   { struct volgrad *vgptr,*vvgptr;
; 498  :     if ( !(get_vattr(v_id) & HIT_PARTNER) ) continue;

	and	edx, 32768				; 00008000H
	xor	eax, eax
	or	edx, eax
	je	$LN17@partner_hi@2

; 499  :     bdry = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN22@partner_hi@2
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN23@partner_hi@2
$LN22@partner_hi@2:
	xor	eax, eax
$LN23@partner_hi@2:

; 500  :     if ( !(bdry->attr & PARTNER_HITTING) ) continue;

	mov	eax, DWORD PTR [eax+32]
	and	eax, 2048				; 00000800H
	xor	edx, edx
	or	eax, edx
	je	$LN17@partner_hi@2

; 501  :     partner = *VINT(v_id,exnum);

	mov	edx, DWORD PTR _exnum$[ebp]
	mov	eax, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR [ecx+edx]

; 502  :     if ( partner == 0 ) continue;

	test	eax, eax
	je	SHORT $LN17@partner_hi@2

; 503  :     vv_id = get_ordinal_id(VERTEX,abs(partner)-1);

	cdq
	xor	eax, edx
	sub	eax, edx
	dec	eax
	push	eax
	push	0
	call	_get_ordinal_id

; 504  :     for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; 
; 505  :                                                    vgptr = vgptr->chain )

	push	edi
	mov	DWORD PTR _vv_id$[ebp], eax
	call	_get_vertex_vgrad
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	je	SHORT $LN17@partner_hi@2
$LL10@partner_hi@2:

; 506  :       for ( vvgptr = get_vertex_vgrad(vv_id) ; vvgptr ; 
; 507  :                                                    vvgptr = vvgptr->chain )

	mov	eax, DWORD PTR _vv_id$[ebp]
	push	eax
	call	_get_vertex_vgrad
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@partner_hi@2
	mov	edx, DWORD PTR _web+616
	fld	QWORD PTR __real@3fe0000000000000
$LN7@partner_hi@2:

; 508  :         if ( vgptr->fixnum == vvgptr->fixnum )

	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN6@partner_hi@2

; 509  :         { for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN6@partner_hi@2
$LN3@partner_hi@2:
	mov	edx, DWORD PTR [eax+20]

; 510  :           { REAL avev = (vgptr->velocity[i]+vvgptr->velocity[i])/2;

	mov	edi, DWORD PTR [esi+20]
	fld	QWORD PTR [edi+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fadd	QWORD PTR [edx]
	inc	ecx
	fmul	ST(0), ST(1)

; 511  :             vgptr->velocity[i] = vvgptr->velocity[i] = avev;

	fst	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+20]
	fstp	QWORD PTR [edx+ecx*8-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jl	SHORT $LN3@partner_hi@2
$LN6@partner_hi@2:

; 506  :       for ( vvgptr = get_vertex_vgrad(vv_id) ; vvgptr ; 
; 507  :                                                    vvgptr = vvgptr->chain )

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jne	SHORT $LN7@partner_hi@2
	fstp	ST(0)
$LN9@partner_hi@2:

; 504  :     for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; 
; 505  :                                                    vgptr = vgptr->chain )

	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	jne	SHORT $LL10@partner_hi@2
$LN17@partner_hi@2:

; 494  :     return;
; 495  : 
; 496  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ebx+eax]
	mov	edi, DWORD PTR [ecx]
	test	edi, 268435456				; 10000000H
	jne	$LL18@partner_hi@2
	pop	esi
	pop	ebx
$LN33@partner_hi@2:
	pop	edi
$LN16@partner_hi@2:

; 512  :           }
; 513  :         }
; 514  :   }
; 515  : } // end partner_hit_volgrad_fix()

	mov	esp, ebp
	pop	ebp
	ret	0
_partner_hit_volgrad_fix ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@HBKMEOLO@Partner?5of?5?$CFd?5is?5?$CFd?0?5but?5partner@ ; `string'
PUBLIC	_partner_shift_grads
EXTRN	_set_vertex_vgrad:PROC
EXTRN	_vgradbase:DWORD
;	COMDAT ??_C@_0CP@HBKMEOLO@Partner?5of?5?$CFd?5is?5?$CFd?0?5but?5partner@
CONST	SEGMENT
??_C@_0CP@HBKMEOLO@Partner?5of?5?$CFd?5is?5?$CFd?0?5but?5partner@ DB 'Par'
	DB	'tner of %d is %d, but partner of %d is %d.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _partner_shift_grads
_TEXT	SEGMENT
_temp$89561 = -56					; size = 28
_eltype$ = -28						; size = 4
tv395 = -24						; size = 8
_vv_id$ = -20						; size = 4
_exnum$ = -16						; size = 4
tv386 = -12						; size = 4
_vvgptr$89559 = -12					; size = 4
_v_id$ = -8						; size = 4
tv388 = -4						; size = 4
_mode$ = 8						; size = 4
_partner_shift_grads PROC				; COMDAT

; 528  : { vertex_id v_id,vv_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	ebx

; 529  :   struct boundary *bdry;
; 530  :   int i,exnum,partner,eltype;
; 531  :  
; 532  :   exnum = find_extra(BDRYHIT_PARTNER_NAME,&eltype);

	lea	eax, DWORD PTR _eltype$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@EHMMIKMP@bdryhit_partner?$AA@
	call	_find_extra
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _exnum$[ebp], ebx

; 533  :   if ( exnum < 0 ) 

	test	ebx, ebx
	js	$LN26@partner_sh

; 534  :     return;
; 535  : 
; 536  :   FOR_ALL_VERTICES(v_id)

	push	esi
	mov	esi, DWORD PTR _web+48
	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _v_id$[ebp], esi
	mov	DWORD PTR tv386[ebp], eax
	je	$LN58@partner_sh
	push	edi
	jmp	SHORT $LN28@partner_sh
$LL54@partner_sh:
	mov	esi, DWORD PTR _v_id$[ebp]
	mov	ebx, DWORD PTR _exnum$[ebp]
$LN28@partner_sh:
	mov	ecx, DWORD PTR _web+12
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv395[ebp+4], eax
	mov	eax, edx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	mov	DWORD PTR tv388[ebp], esi
	je	$LN27@partner_sh

; 537  :   { struct volgrad *vgptr,*vvgptr,*prev,temp;
; 538  :     REAL *x,*xx;
; 539  :     if ( !(get_vattr(v_id) & HIT_PARTNER) ) continue;

	and	edx, 32768				; 00008000H
	xor	eax, eax
	or	edx, eax
	je	$LN27@partner_sh

; 540  :     bdry = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN32@partner_sh
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN33@partner_sh
$LN32@partner_sh:
	xor	eax, eax
$LN33@partner_sh:

; 541  :     if ( !(bdry->attr & PARTNER_HITTING) ) continue;

	mov	eax, DWORD PTR [eax+32]
	and	eax, 2048				; 00000800H
	xor	edx, edx
	or	eax, edx
	je	$LN27@partner_sh

; 542  :     partner = *VINT(v_id,exnum);

	mov	edx, DWORD PTR _web+104
	mov	edi, ebx
	imul	edi, 240				; 000000f0H
	lea	eax, DWORD PTR [edi+edx]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+64]
	mov	ebx, DWORD PTR [ecx+eax]

; 543  :     if ( partner == 0 ) continue;

	test	ebx, ebx
	je	$LN27@partner_sh

; 544  :     if ( abs(partner) >= ordinal(v_id)+1 ) continue;

	cmp	DWORD PTR tv386[ebp], 0
	je	SHORT $LN34@partner_sh
	mov	ecx, esi
	jmp	SHORT $LN35@partner_sh
$LN34@partner_sh:
	or	ecx, -1
$LN35@partner_sh:
	mov	eax, ebx
	cdq
	xor	eax, edx
	sub	eax, edx
	inc	ecx
	cmp	eax, ecx
	jge	$LN27@partner_sh

; 545  : 
; 546  :     vv_id = get_ordinal_id(VERTEX,abs(partner)-1);  /* destination */

	dec	eax
	push	eax
	push	0
	call	_get_ordinal_id
	add	esp, 8

; 547  :     if ( abs(*VINT(vv_id,exnum)) != ordinal(v_id)+1 )

	cmp	DWORD PTR tv386[ebp], 0
	mov	DWORD PTR _vv_id$[ebp], eax
	je	SHORT $LN36@partner_sh
	mov	ecx, esi
	jmp	SHORT $LN37@partner_sh
$LN36@partner_sh:
	or	ecx, -1
$LN37@partner_sh:
	add	edi, DWORD PTR _web+104
	mov	esi, eax
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edi+eax+64]
	mov	edi, DWORD PTR _web+12
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [edx+eax]
	cdq
	xor	eax, edx
	sub	eax, edx
	inc	ecx
	cmp	eax, ecx
	je	SHORT $LN55@partner_sh

; 548  :     { sprintf(errmsg,"Partner of %d is %d, but partner of %d is %d.\n",
; 549  :         ordinal(v_id)+1,partner,partner,abs(*VINT(vv_id,exnum)));

	cmp	DWORD PTR tv386[ebp], 0
	je	SHORT $LN38@partner_sh
	mov	ecx, DWORD PTR tv388[ebp]
	jmp	SHORT $LN39@partner_sh
$LN38@partner_sh:
	or	ecx, -1
$LN39@partner_sh:
	push	eax
	push	ebx
	push	ebx
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_0CP@HBKMEOLO@Partner?5of?5?$CFd?5is?5?$CFd?0?5but?5partner@
	push	OFFSET _errmsg
	call	_sprintf

; 550  :       kb_error(3383,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3383					; 00000d37H
	call	_kb_error
	mov	edi, DWORD PTR _web+12
	add	esp, 36					; 00000024H
$LN55@partner_sh:

; 551  :     }
; 552  : 
; 553  :     if ( mode & CALC_FORCE )

	mov	dl, BYTE PTR _mode$[ebp]
	test	dl, 1
	je	SHORT $LN56@partner_sh

; 554  :     { x = get_force(v_id);

	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+eax+784]
	mov	eax, DWORD PTR tv388[ebp]
	mov	eax, DWORD PTR [edi+eax*4]

; 555  :       xx = get_force(vv_id);

	mov	esi, DWORD PTR [esi+edi]
	add	eax, ecx
	add	esi, ecx

; 556  :       for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN56@partner_sh
	fldz
	sub	esi, eax
$LN17@partner_sh:

; 557  :       { xx[i] += x[i];

	fld	QWORD PTR [esi+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [esi+eax-8]

; 558  :         x[i] = 0.0;

	fst	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN17@partner_sh

; 556  :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN56@partner_sh:

; 559  :       }
; 560  :     }
; 561  : 
; 562  :     if ( (mode & CALC_VOLGRADS) && vgradbase )

	test	dl, 2
	je	$LN53@partner_sh
	cmp	DWORD PTR _vgradbase, 0
	je	$LN53@partner_sh

; 563  :     { prev = NULL;
; 564  :       for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; prev = vgptr,
; 565  :                                                    vgptr = vgptr->chain )

	mov	ecx, DWORD PTR _v_id$[ebp]
	push	ecx
	xor	ebx, ebx
	call	_get_vertex_vgrad
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	$LN53@partner_sh
$LL13@partner_sh:

; 566  :       { int found = 0;
; 567  :         for ( vvgptr = get_vertex_vgrad(vv_id) ; vvgptr ; 
; 568  :                                                    vvgptr = vvgptr->chain )

	mov	edi, DWORD PTR _vv_id$[ebp]
	push	edi
	call	_get_vertex_vgrad
	add	esp, 4
	test	eax, eax
	je	SHORT $LN51@partner_sh
	mov	ecx, DWORD PTR [esi]
$LL10@partner_sh:

; 569  :           if ( vgptr->fixnum == vvgptr->fixnum )

	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN45@partner_sh

; 566  :       { int found = 0;
; 567  :         for ( vvgptr = get_vertex_vgrad(vv_id) ; vvgptr ; 
; 568  :                                                    vvgptr = vvgptr->chain )

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jne	SHORT $LL10@partner_sh
$LN51@partner_sh:

; 579  :         { vvgptr = get_vertex_vgrad(vv_id);            

	push	edi
	call	_get_vertex_vgrad
	mov	DWORD PTR _vvgptr$89559[ebp], eax

; 580  :           temp.chain = vgptr->chain;

	mov	eax, DWORD PTR [esi+12]

; 581  :           set_vertex_vgrad(vv_id,vgptr);

	push	esi
	push	edi
	mov	DWORD PTR _temp$89561[ebp+12], eax
	call	_set_vertex_vgrad
	add	esp, 12					; 0000000cH

; 582  :           if ( prev )

	test	ebx, ebx
	je	SHORT $LN2@partner_sh

; 583  :             prev->chain = vgptr->chain;

	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [ebx+12], ecx
	jmp	SHORT $LN1@partner_sh
$LN45@partner_sh:

; 570  :           { for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN12@partner_sh
	fldz
$LN6@partner_sh:
	mov	edx, DWORD PTR [eax+16]

; 571  :             { vvgptr->grad[i] += vgptr->grad[i];

	mov	edi, DWORD PTR [esi+16]
	fld	QWORD PTR [edi+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fadd	QWORD PTR [edx]
	inc	ecx
	fstp	QWORD PTR [edx]

; 572  :               vgptr->grad[i] = 0.0;

	mov	edx, DWORD PTR [esi+16]
	fst	QWORD PTR [edx+ecx*8-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN6@partner_sh

; 570  :           { for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)

; 573  :             }
; 574  :             found = 1;
; 575  :             break;
; 576  :           }
; 577  :   
; 578  :         if ( !found ) /* move whole structure over to vv_id */

	jmp	SHORT $LN12@partner_sh
$LN2@partner_sh:

; 584  :           else set_vertex_vgrad(v_id,vgptr->chain); 

	mov	edx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR _v_id$[ebp]
	push	edx
	push	eax
	call	_set_vertex_vgrad
	add	esp, 8
$LN1@partner_sh:

; 585  :           vgptr->chain = vvgptr;

	mov	ecx, DWORD PTR _vvgptr$89559[ebp]
	mov	DWORD PTR [esi+12], ecx

; 586  :           vgptr = &temp;

	lea	esi, DWORD PTR _temp$89561[ebp]
$LN12@partner_sh:

; 563  :     { prev = NULL;
; 564  :       for ( vgptr = get_vertex_vgrad(v_id) ; vgptr ; prev = vgptr,
; 565  :                                                    vgptr = vgptr->chain )

	mov	ebx, esi
	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	jne	$LL13@partner_sh
$LN53@partner_sh:
	mov	esi, DWORD PTR tv388[ebp]
$LN27@partner_sh:

; 534  :     return;
; 535  : 
; 536  :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _v_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv386[ebp], eax
	jne	$LL54@partner_sh
	pop	edi
$LN58@partner_sh:
	pop	esi
$LN26@partner_sh:
	pop	ebx

; 587  :         }
; 588  :       }
; 589  :     }
; 590  :   }
; 591  : 
; 592  : } // end partner_shift_grads()

	mov	esp, ebp
	pop	ebp
	ret	0
_partner_shift_grads ENDP
_TEXT	ENDS
PUBLIC	_partner_move
; Function compile flags: /Ogtp
;	COMDAT _partner_move
_TEXT	SEGMENT
_eltype$ = -24						; size = 4
_exnum$ = -20						; size = 4
tv395 = -16						; size = 8
_bdry$ = -12						; size = 4
tv386 = -8						; size = 4
tv388 = -4						; size = 4
_partner_move PROC					; COMDAT

; 603  : { vertex_id v_id,vv_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx

; 604  :   struct boundary *bdry;
; 605  :   int i,exnum,partner,eltype;
; 606  :  
; 607  :   exnum = find_extra(BDRYHIT_PARTNER_NAME,&eltype);

	lea	eax, DWORD PTR _eltype$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@EHMMIKMP@bdryhit_partner?$AA@
	call	_find_extra
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _exnum$[ebp], ebx

; 608  :   if ( exnum < 0 ) 

	test	ebx, ebx
	js	$LN15@partner_mo

; 609  :     return;
; 610  : 
; 611  :   FOR_ALL_VERTICES(v_id)

	push	edi
	mov	edi, DWORD PTR _web+48
	mov	eax, edi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv386[ebp], eax
	je	$LN40@partner_mo
	push	esi
	jmp	SHORT $LN17@partner_mo
$LL37@partner_mo:
	mov	ebx, DWORD PTR _exnum$[ebp]
$LN17@partner_mo:
	mov	ecx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv395[ebp+4], eax
	mov	eax, edx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv388[ebp], edi
	je	$LN16@partner_mo

; 612  :   { REAL *x,*xx,*p,*pp;
; 613  :     
; 614  :     if ( !(get_vattr(v_id) & HIT_PARTNER) ) continue;

	and	edx, 32768				; 00008000H
	xor	eax, eax
	or	edx, eax
	je	$LN16@partner_mo

; 615  :     bdry = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN21@partner_mo
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	mov	DWORD PTR _bdry$[ebp], eax
	jmp	SHORT $LN22@partner_mo
$LN21@partner_mo:
	mov	DWORD PTR _bdry$[ebp], esi
	mov	eax, esi
$LN22@partner_mo:

; 616  :     if ( !(bdry->attr & PARTNER_HITTING) ) continue;

	mov	eax, DWORD PTR [eax+32]
	and	eax, 2048				; 00000800H
	xor	edx, edx
	or	eax, edx
	je	$LN16@partner_mo

; 617  :     partner = *VINT(v_id,exnum);

	mov	edx, DWORD PTR _web+104
	mov	esi, ebx
	imul	esi, 240				; 000000f0H
	lea	eax, DWORD PTR [esi+edx]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+64]
	mov	ebx, DWORD PTR [ecx+eax]

; 618  :     if ( partner == 0 ) continue;

	test	ebx, ebx
	je	$LN16@partner_mo

; 619  :     if ( abs(partner) >= ordinal(v_id)+1 ) continue;

	cmp	DWORD PTR tv386[ebp], 0
	je	SHORT $LN23@partner_mo
	mov	ecx, edi
	jmp	SHORT $LN24@partner_mo
$LN23@partner_mo:
	or	ecx, -1
$LN24@partner_mo:
	mov	eax, ebx
	cdq
	xor	eax, edx
	sub	eax, edx
	inc	ecx
	cmp	eax, ecx
	jge	$LN16@partner_mo

; 620  : 
; 621  :     vv_id = get_ordinal_id(VERTEX,abs(partner)-1);  /* destination */

	dec	eax
	push	eax
	push	0
	call	_get_ordinal_id
	add	esp, 8

; 622  :     if ( !valid_id(vv_id) ) continue;

	test	eax, 268435456				; 10000000H
	je	$LN16@partner_mo

; 623  :     if ( abs(*VINT(vv_id,exnum)) != ordinal(v_id)+1 )

	cmp	DWORD PTR tv386[ebp], 0
	je	SHORT $LN25@partner_mo
	mov	ecx, edi
	jmp	SHORT $LN26@partner_mo
$LN25@partner_mo:
	or	ecx, -1
$LN26@partner_mo:
	add	esi, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [esi+eax+64]
	mov	esi, DWORD PTR _web+12
	mov	eax, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [edx+eax]
	cdq
	xor	eax, edx
	sub	eax, edx
	inc	ecx
	cmp	eax, ecx
	je	SHORT $LN38@partner_mo

; 624  :     { sprintf(errmsg,"Partner of %d is %d, but partner of %d is %d.\n",
; 625  :         ordinal(v_id)+1,partner,partner,abs(*VINT(vv_id,exnum)));

	cmp	DWORD PTR tv386[ebp], 0
	je	SHORT $LN27@partner_mo
	mov	ecx, DWORD PTR tv388[ebp]
	jmp	SHORT $LN28@partner_mo
$LN27@partner_mo:
	or	ecx, -1
$LN28@partner_mo:
	push	eax
	push	ebx
	push	ebx
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_0CP@HBKMEOLO@Partner?5of?5?$CFd?5is?5?$CFd?0?5but?5partner@
	push	OFFSET _errmsg
	call	_sprintf

; 626  :       kb_error(3006,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3006					; 00000bbeH
	call	_kb_error
	mov	esi, DWORD PTR _web+12
	add	esp, 36					; 00000024H
$LN38@partner_mo:

; 627  :     }
; 628  :     p = get_param(v_id);

	mov	ecx, DWORD PTR tv388[ebp]
	mov	eax, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx+544]

; 629  :     pp = get_param(vv_id);

	mov	edx, DWORD PTR [edi+esi]

; 630  :     x = get_coord(v_id);

	mov	esi, DWORD PTR _dymem
	lea	ebx, DWORD PTR [ecx+eax]
	lea	edi, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+esi+64]
	add	eax, ecx

; 631  :     xx = get_coord(vv_id);

	add	edx, ecx

; 632  :     for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN4@partner_mo
	sub	edx, eax
	npad	5
$LL6@partner_mo:

; 633  :       x[i] = xx[i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL6@partner_mo
$LN4@partner_mo:

; 634  :     for ( i = 0 ; i < bdry->pcount ; i++ )

	mov	esi, DWORD PTR _bdry$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [esi+40], ecx
	jle	SHORT $LN36@partner_mo
	mov	edx, edi
	mov	eax, ebx
	sub	edx, ebx
$LL3@partner_mo:

; 635  :       p[i] = pp[i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR [esi+40]
	jl	SHORT $LL3@partner_mo
$LN36@partner_mo:

; 634  :     for ( i = 0 ; i < bdry->pcount ; i++ )

	mov	edi, DWORD PTR tv388[ebp]
$LN16@partner_mo:

; 609  :     return;
; 610  : 
; 611  :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [edx+edi*4]
	mov	edi, DWORD PTR [eax]
	mov	eax, edi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv386[ebp], eax
	jne	$LL37@partner_mo
	pop	esi
$LN40@partner_mo:
	pop	edi
$LN15@partner_mo:
	pop	ebx

; 636  :     
; 637  :   }
; 638  : } // partner_move()

	mov	esp, ebp
	pop	ebp
	ret	0
_partner_move ENDP
_TEXT	ENDS
END
