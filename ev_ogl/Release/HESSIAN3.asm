; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\HESSIAN3.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_get_fe_edge
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_@2
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_@2:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_@2
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_@2:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_get_body_volume
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_body_volume
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volume PROC					; COMDAT

; 308  :     { return    ( valid_id(b_id) ?  bptr(b_id)->volume : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]
	pop	ebp
	ret	0
$LN3@get_body_v:
	fldz
	pop	ebp
	ret	0
_get_body_volume ENDP
_TEXT	ENDS
PUBLIC	_get_body_fixvol
; Function compile flags: /Ogtp
;	COMDAT _get_body_fixvol
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_fixvol PROC					; COMDAT

; 311  :      { return ( valid_id(b_id) ?  bptr(b_id)->fixvol : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+32]
	pop	ebp
	ret	0
$LN3@get_body_f:
	fldz
	pop	ebp
	ret	0
_get_body_fixvol ENDP
_TEXT	ENDS
PUBLIC	_get_body_pressure
; Function compile flags: /Ogtp
;	COMDAT _get_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_pressure PROC					; COMDAT

; 317  :     { return  ( valid_id(b_id) ?    bptr(b_id)->pressure : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_p
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+312]
	pop	ebp
	ret	0
$LN3@get_body_p:
	fldz
	pop	ebp
	ret	0
_get_body_pressure ENDP
_TEXT	ENDS
PUBLIC	__real@4000000000000000
PUBLIC	__real@bfe0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	_rhs$GSCopy$
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_area_hessian
EXTRN	_fill_mixed_entry:PROC
EXTRN	_fill_self_entry:PROC
EXTRN	_hess_flag:DWORD
EXTRN	_fill_grad:PROC
EXTRN	_dot:PROC
EXTRN	_get_edge_side:PROC
EXTRN	_vhead:DWORD
EXTRN	_vhead_attr:DWORD
EXTRN	_mat2d_setup:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@bfe0000000000000
CONST	SEGMENT
__real@bfe0000000000000 DQ 0bfe0000000000000r	; -0.5
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\hessian3.c
CONST	ENDS
;	COMDAT _area_hessian
_TEXT	SEGMENT
_self2qXvS$ = -1128					; size = 24
_otherDqXvS$ = -1104					; size = 24
_v$89059 = -1080					; size = 12
_density$89062 = -1068					; size = 8
_two_area$89060 = -1060					; size = 8
_ii$89092 = -1052					; size = 4
tv3481 = -1048						; size = 4
_rhs$GSCopy$ = -1044					; size = 4
tv3402 = -1040						; size = 4
tv3484 = -1036						; size = 4
tv3643 = -1032						; size = 4
_jj$89093 = -1028					; size = 4
tv964 = -1024						; size = 4
_otherD$ = -1020					; size = 4
_self2$ = -1016						; size = 4
_S$GSCopy$ = -1012					; size = 4
tv3503 = -1008						; size = 4
tv3501 = -1004						; size = 4
tv2923 = -1004						; size = 4
tv3593 = -1000						; size = 4
tv2989 = -1000						; size = 4
tv3202 = -996						; size = 4
tv2946 = -996						; size = 4
tv3540 = -992						; size = 4
tv1479 = -992						; size = 4
tv1084 = -992						; size = 4
_ii$89079 = -992					; size = 4
tv3591 = -988						; size = 4
tv2952 = -988						; size = 4
tv280 = -988						; size = 4
tv3495 = -984						; size = 4
tv2993 = -984						; size = 4
tv1402 = -984						; size = 4
tv3465 = -980						; size = 4
tv1416 = -980						; size = 4
_jj$89080 = -980					; size = 4
_otherDxJ$ = -976					; size = 288
_self2xJ$ = -688					; size = 288
_first$89061 = -400					; size = 144
_side$89055 = -256					; size = 144
_grad$89081 = -112					; size = 48
_sd$89057 = -64						; size = 24
_v_id$89064 = -40					; size = 12
_ss$89056 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_rhs$ = 12						; size = 4
_area_hessian PROC					; COMDAT

; 31   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1128				; 00000468H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 32   :   int i,j,k;
; 33   :   facet_id f_id;
; 34   :   MAT2D(self2,MAXCOORD,MAXCOORD);

	mov	eax, DWORD PTR _S$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	push	edi
	push	6
	push	6
	lea	edx, DWORD PTR _self2xJ$[ebp]
	mov	DWORD PTR _S$GSCopy$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _self2qXvS$[ebp]
	push	eax
	mov	DWORD PTR _rhs$GSCopy$[ebp], ecx
	call	_mat2d_setup

; 35   :   MAT2D(otherD,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	ecx, DWORD PTR _otherDxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _otherDqXvS$[ebp]
	push	edx
	mov	DWORD PTR _self2$[ebp], eax
	call	_mat2d_setup

; 36   : 
; 37   :   /* fill in sparse matrix rows and volume constraint rows */
; 38   : 
; 39   :   FOR_ALL_FACETS(f_id)

	mov	edi, DWORD PTR _web+272
	mov	edx, edi
	shr	edx, 28					; 0000001cH
	add	esp, 32					; 00000020H
	and	edx, 1
	mov	DWORD PTR _otherD$[ebp], eax
	je	$LN32@area_hessi
	push	ebx
	mov	ebx, DWORD PTR _web+236
	push	esi
	npad	1
$LL80@area_hessi:
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+ebx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv964[ebp], ecx
	je	$LN33@area_hessi

; 40   :   {
; 41   :     REAL side[FACET_EDGES][MAXCOORD];    /* 3 sides of facet */
; 42   :     REAL ss[FACET_EDGES];      /* squares of sides */
; 43   :     REAL sd[FACET_EDGES];    /* dot of side with next side */
; 44   :     facetedge_id fe_id;         
; 45   :     struct hess_verlist *v[FACET_VERTS];
; 46   :     REAL two_area;    /* twice area of facet */
; 47   :     REAL first[FACET_VERTS][MAXCOORD]; /* first partials */
; 48   :     REAL density = get_facet_density(f_id);

	mov	esi, DWORD PTR [ecx+ebx]
	fld	QWORD PTR [esi+32]
	fst	QWORD PTR _density$89062[ebp]

; 49   :     vertex_id v_id[FACET_VERTS];
; 50   : 
; 51   :     if ( density == 0.0 ) continue;

	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN33@area_hessi

; 52   :     fe_id = get_facet_fe(f_id);

	test	edx, edx
	jne	SHORT $LN38@area_hessi
	xor	esi, esi
	jmp	SHORT $LN37@area_hessi
$LN38@area_hessi:
	mov	esi, DWORD PTR [esi+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN37@area_hessi
	xor	esi, 134217728				; 08000000H
$LN37@area_hessi:

; 53   :     for ( i = 0 ; i < FACET_EDGES ; i++ )

	lea	eax, DWORD PTR _side$89055[ebp]
	mov	DWORD PTR tv1416[ebp], eax
	mov	eax, DWORD PTR _web+460
	mov	DWORD PTR tv1402[ebp], 0
	npad	12
$LL79@area_hessi:

; 54   :     { v_id[i] = get_fe_tailv(fe_id);

	mov	ebx, DWORD PTR _web+216
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	edx, esi
	and	edx, 134217728				; 08000000H
	xor	ecx, edx
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN44@area_hessi
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ebx+edx+304]
	mov	ebx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN43@area_hessi
$LN44@area_hessi:
	mov	eax, DWORD PTR _web+124
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ebx+edx+304]
	mov	eax, DWORD PTR [eax+ebx]
$LN43@area_hessi:
	mov	ebx, DWORD PTR tv1402[ebp]
	mov	DWORD PTR _v_id$89064[ebp+ebx], eax

; 55   :       v[i] = get_vertex_vhead(v_id[i]);

	mov	ebx, DWORD PTR _vhead_attr
	imul	ebx, 240				; 000000f0H
	add	ebx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx+64]
	mov	ebx, DWORD PTR _web+12
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	edx, DWORD PTR [edx+eax]

; 56   :       get_fe_side(fe_id,side[i]);

	mov	eax, DWORD PTR tv1416[ebp]
	mov	ebx, DWORD PTR tv1402[ebp]
	shl	edx, 5
	add	edx, DWORD PTR _vhead
	push	eax
	push	ecx
	mov	DWORD PTR _v$89059[ebp+ebx], edx
	call	_get_edge_side

; 57   :       fe_id = get_next_edge(fe_id);

	mov	eax, DWORD PTR _web+460
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN50@area_hessi
	mov	ecx, DWORD PTR [edi+eax]
	mov	esi, DWORD PTR [ecx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN27@area_hessi
$LN50@area_hessi:
	mov	edx, DWORD PTR [edi+eax]
	mov	esi, DWORD PTR [edx+32]
$LN27@area_hessi:

; 53   :     for ( i = 0 ; i < FACET_EDGES ; i++ )

	add	DWORD PTR tv1416[ebp], 48		; 00000030H
	add	ebx, 4
	mov	DWORD PTR tv1402[ebp], ebx
	cmp	ebx, 12					; 0000000cH
	jl	$LL79@area_hessi

; 58   :     }
; 59   : 
; 60   :     for ( i = 0 ; i < FACET_EDGES ; i++ )

	mov	edi, 1
	lea	esi, DWORD PTR _side$89055[ebp]
	xor	ebx, ebx
	mov	DWORD PTR tv280[ebp], 3
	npad	6
$LL25@area_hessi:

; 61   :     { ss[i] = SDIM_dot(side[i],side[i]);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	esi
	push	esi
	call	_dot
	fstp	QWORD PTR _ss$89056[ebp+ebx]

; 62   :       sd[i] = -SDIM_dot(side[(i+1)%FACET_EDGES],side[(i+2)%FACET_EDGES]);

	mov	ecx, DWORD PTR _web+616
	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR tv1479[ebp], eax
	cdq
	push	ecx
	mov	ecx, 3
	idiv	ecx
	lea	edx, DWORD PTR [edx+edx*2]
	add	edx, edx
	lea	eax, DWORD PTR _side$89055[ebp+edx*8]
	push	eax
	mov	eax, edi
	cdq
	idiv	ecx
	lea	edx, DWORD PTR [edx+edx*2]
	add	edx, edx
	lea	eax, DWORD PTR _side$89055[ebp+edx*8]
	push	eax
	call	_dot
	fchs
	mov	edi, DWORD PTR tv1479[ebp]
	fstp	QWORD PTR _sd$89057[ebp+ebx]
	add	esp, 24					; 00000018H
	add	esi, 48					; 00000030H
	add	ebx, 8
	dec	DWORD PTR tv280[ebp]
	jne	SHORT $LL25@area_hessi

; 63   :     }
; 64   :     two_area = sqrt(ss[1]*ss[2] - sd[0]*sd[0]);

	fld	QWORD PTR _ss$89056[ebp+16]
	fmul	QWORD PTR _ss$89056[ebp+8]
	fld	QWORD PTR _sd$89057[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)
	call	__CIsqrt
	fst	QWORD PTR _two_area$89060[ebp]
	mov	esi, 1
	lea	edi, DWORD PTR _v$89059[ebp]
	lea	ecx, DWORD PTR _first$89061[ebp+8]
	mov	DWORD PTR tv2946[ebp], 0
	mov	DWORD PTR tv2952[ebp], esi
	mov	DWORD PTR tv2989[ebp], edi
	lea	ebx, DWORD PTR _sd$89057[ebp]
	mov	DWORD PTR tv2993[ebp], ecx
	mov	DWORD PTR tv2923[ebp], 3
$LN81@area_hessi:

; 68   :     {
; 69   :       int ii,jj;
; 70   :       REAL grad[MAXCOORD];
; 71   : 
; 72   :       if ( v[i]->freedom <= 0 ) continue;

	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax+8], 0
	jle	$LN21@area_hessi

; 73   :       ii = (i+2)%FACET_EDGES;  /* side previous vertex i */

	lea	eax, DWORD PTR [esi+1]
	fld	QWORD PTR __real@3fe0000000000000
	cdq
	fld	QWORD PTR _density$89062[ebp]
	mov	ecx, 3
	idiv	ecx

; 74   :       jj = (i+1)%FACET_EDGES;  /* side opposite vertex i, next vertex */

	mov	eax, esi
	mov	esi, 3
	mov	ecx, edx
	cdq
	idiv	esi

; 75   :       for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, 4
	mov	DWORD PTR _ii$89079[ebp], ecx
	mov	DWORD PTR _jj$89080[ebp], edx
	jl	$LC70@area_hessi

; 73   :       ii = (i+2)%FACET_EDGES;  /* side previous vertex i */

	mov	edi, DWORD PTR tv2993[ebp]
	lea	esi, DWORD PTR [edx+edx*2]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	esi, esi
	add	ecx, ecx
	lea	esi, DWORD PTR _side$89055[ebp+esi*8+8]
	lea	ecx, DWORD PTR _side$89055[ebp+ecx*8+8]

; 75   :       for ( k = 0 ; k < SDIM ; k++ )

$LN71@area_hessi:

; 76   :       { first[i][k] = (side[ii][k]*ss[jj] - sd[i]*(-side[jj][k]))/2/two_area;

	fld	QWORD PTR [ecx-8]

; 77   :         grad[k] = density*first[i][k];

	add	eax, 4
	fmul	QWORD PTR _ss$89056[ebp+edx*8]
	mov	edx, DWORD PTR _jj$89080[ebp]
	fld	QWORD PTR [esi-8]
	add	ecx, 32					; 00000020H
	fchs
	add	esi, 32					; 00000020H
	fmul	QWORD PTR [ebx]
	add	edi, 32					; 00000020H
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fdiv	ST(0), ST(3)
	fst	QWORD PTR [edi-40]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _grad$89081[ebp+eax*8-32]
	fld	QWORD PTR [ecx-32]
	fmul	QWORD PTR _ss$89056[ebp+edx*8]
	fld	QWORD PTR [esi-32]
	fchs
	fmul	QWORD PTR [ebx]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fdiv	ST(0), ST(3)
	fst	QWORD PTR [edi-32]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _grad$89081[ebp+eax*8-24]
	fld	QWORD PTR [ecx-24]
	fmul	QWORD PTR _ss$89056[ebp+edx*8]
	fld	QWORD PTR [esi-24]
	fchs
	fmul	QWORD PTR [ebx]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fdiv	ST(0), ST(3)
	fst	QWORD PTR [edi-24]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _grad$89081[ebp+eax*8-16]
	fld	QWORD PTR [ecx-16]
	fmul	QWORD PTR _ss$89056[ebp+edx*8]
	mov	edx, DWORD PTR _web+616
	fld	QWORD PTR [esi-16]
	add	edx, -3					; fffffffdH
	fchs
	cmp	eax, edx
	fmul	QWORD PTR [ebx]
	mov	edx, DWORD PTR _jj$89080[ebp]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fdiv	ST(0), ST(3)
	fst	QWORD PTR [edi-16]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _grad$89081[ebp+eax*8-8]
	jl	$LN71@area_hessi
	mov	ecx, DWORD PTR _ii$89079[ebp]
$LC70@area_hessi:

; 75   :       for ( k = 0 ; k < SDIM ; k++ )

	cmp	eax, DWORD PTR _web+616
	jge	SHORT $LN99@area_hessi

; 84   :      for ( i = 0 ; i < FACET_EDGES ; i++ )

	lea	esi, DWORD PTR _ss$89056[ebp+edx*8]
	mov	DWORD PTR tv1084[ebp], esi
	mov	esi, DWORD PTR tv2946[ebp]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	esi, eax
	lea	edx, DWORD PTR [eax+edx*2]
	lea	ecx, DWORD PTR [eax+ecx*2]
	lea	esi, DWORD PTR _first$89061[ebp+esi*8]
	lea	edx, DWORD PTR _side$89055[ebp+edx*8]
	lea	ecx, DWORD PTR _side$89055[ebp+ecx*8]
$LN76@area_hessi:

; 76   :       { first[i][k] = (side[ii][k]*ss[jj] - sd[i]*(-side[jj][k]))/2/two_area;

	fld	QWORD PTR [ecx]
	mov	edi, DWORD PTR tv1084[ebp]
	fmul	QWORD PTR [edi]
	inc	eax
	fld	QWORD PTR [edx]
	add	ecx, 8
	fchs
	add	edx, 8
	fmul	QWORD PTR [ebx]
	add	esi, 8
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fdiv	ST(0), ST(3)
	fst	QWORD PTR [esi-8]

; 77   :         grad[k] = density*first[i][k];

	fmul	ST(0), ST(1)
	fstp	QWORD PTR _grad$89081[ebp+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN76@area_hessi
$LN99@area_hessi:

; 78   :       }
; 79   :       fill_grad(S,v[i],grad,rhs);

	mov	edx, DWORD PTR _rhs$GSCopy$[ebp]
	fstp	ST(2)
	mov	edi, DWORD PTR tv2989[ebp]
	fstp	ST(1)
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	fstp	ST(0)
	push	edx
	lea	eax, DWORD PTR _grad$89081[ebp]
	push	eax
	mov	eax, DWORD PTR [edi]
	push	eax
	push	ecx
	call	_fill_grad
	fld	QWORD PTR _two_area$89060[ebp]
	mov	esi, DWORD PTR tv2952[ebp]
	add	esp, 16					; 00000010H
$LN21@area_hessi:

; 65   : 
; 66   :     /* first derivatives of area */
; 67   :     for ( i = 0 ; i < FACET_EDGES ; i++ )

	add	DWORD PTR tv2993[ebp], 48		; 00000030H
	add	DWORD PTR tv2946[ebp], 6
	inc	esi
	add	edi, 4
	add	ebx, 8
	dec	DWORD PTR tv2923[ebp]
	mov	DWORD PTR tv2952[ebp], esi
	mov	DWORD PTR tv2989[ebp], edi
	jne	$LN81@area_hessi

; 80   :     }
; 81   : 
; 82   :     /* second derivatives */
; 83   :     if ( hess_flag )

	xor	eax, eax
	cmp	DWORD PTR _hess_flag, eax
	je	$LN103@area_hessi

; 84   :      for ( i = 0 ; i < FACET_EDGES ; i++ )

	lea	edx, DWORD PTR _sd$89057[ebp]
	mov	DWORD PTR tv3591[ebp], edx
	mov	ecx, 1
	lea	edx, DWORD PTR _first$89061[ebp]
	mov	DWORD PTR tv3501[ebp], eax
	mov	DWORD PTR tv3503[ebp], ecx
	mov	DWORD PTR tv3593[ebp], edx
	mov	DWORD PTR tv3495[ebp], eax
	mov	DWORD PTR tv3540[ebp], 3
$LN82@area_hessi:

; 85   :      { REAL self,other;
; 86   :        int ii,jj;
; 87   : 
; 88   :        if ( v[i]->freedom <= 0 ) continue;

	mov	eax, DWORD PTR tv3495[ebp]
	mov	edx, DWORD PTR _v$89059[ebp+eax]
	cmp	DWORD PTR [edx+8], 0
	jle	$LN13@area_hessi

; 89   : 
; 90   :        ii = (i+2)%FACET_EDGES;  /* side previous vertex i */

	lea	eax, DWORD PTR [ecx+1]
	cdq
	mov	esi, 3
	idiv	esi

; 91   :        jj = (i+1)%FACET_EDGES;  /* side opposite vertex i, next vertex */

	mov	eax, ecx
	mov	ecx, esi
	mov	DWORD PTR _ii$89092[ebp], edx
	cdq
	idiv	ecx

; 92   : 
; 93   :        /* for now, all degrees of freedom are coordinate */
; 94   :        for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	mov	esi, edx
	xor	edx, edx
	mov	DWORD PTR _jj$89093[ebp], esi
	test	ecx, ecx
	jle	$LN110@area_hessi
	mov	eax, DWORD PTR _otherD$[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	mov	edi, DWORD PTR _self2$[ebp]
	fld	QWORD PTR _density$89062[ebp]
	fld	QWORD PTR __real@bfe0000000000000
	sub	edi, eax
	fld	QWORD PTR __real@4000000000000000
	mov	DWORD PTR tv3465[ebp], eax
	mov	DWORD PTR tv3481[ebp], edi
$LN10@area_hessi:

; 95   :           for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	test	ecx, ecx
	jle	$LN9@area_hessi

; 92   : 
; 93   :        /* for now, all degrees of freedom are coordinate */
; 94   :        for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR tv3465[ebp]
	mov	ecx, DWORD PTR [edi+ecx]
	mov	DWORD PTR tv3484[ebp], ecx
	mov	ecx, DWORD PTR _v$89059[ebp+esi*4]
	mov	DWORD PTR tv3643[ebp], ecx
	lea	ecx, DWORD PTR [esi+esi*2]
	mov	esi, DWORD PTR tv3501[ebp]
	add	ecx, ecx
	add	esi, edx
	fld	QWORD PTR _first$89061[ebp+esi*8]

; 95   :           for ( k = 0 ; k < SDIM ; k++ )

	mov	esi, DWORD PTR tv3593[ebp]
	lea	ebx, DWORD PTR [ecx+edx]
	fmul	ST(0), ST(1)
	lea	edi, DWORD PTR [ecx*8]
	lea	ebx, DWORD PTR _side$89055[ebp+ebx*8]
	mov	DWORD PTR tv3202[ebp], esi
	mov	DWORD PTR tv3402[ebp], edi
$LN7@area_hessi:

; 96   :           { self = -(side[jj][j]*side[jj][k])/2;

	fld	QWORD PTR [ebx]
	lea	esi, DWORD PTR [edi+eax*8]
	fmul	QWORD PTR _side$89055[ebp+esi]
	lea	esi, DWORD PTR _side$89055[ebp+esi]
	fmul	ST(0), ST(3)

; 97   :             if ( j == k ) self += ss[jj]/2;

	cmp	edx, eax
	jne	SHORT $LN4@area_hessi
	mov	ecx, DWORD PTR _jj$89093[ebp]
	fld	QWORD PTR _ss$89056[ebp+ecx*8]
	fmul	ST(0), ST(6)
	faddp	ST(1), ST(0)
$LN4@area_hessi:

; 98   :             self2[j][k] = 
; 99   :                       density*(self - 2*first[i][j]*first[i][k])/two_area;

	mov	ecx, DWORD PTR tv3202[ebp]
	fld	QWORD PTR [ecx]
	mov	ecx, DWORD PTR tv3484[ebp]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fdiv	ST(0), ST(6)
	fstp	QWORD PTR [ecx+eax*8]

; 100  :             if ( v[jj]->freedom <= 0 ) continue;

	mov	ecx, DWORD PTR tv3643[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jle	SHORT $LN6@area_hessi

; 101  :             other = -side[ii][j]*side[jj][k] - side[jj][j]*(-side[ii][k])/2;

	mov	ecx, DWORD PTR _ii$89092[ebp]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	lea	edi, DWORD PTR [ecx+edx]
	fld	QWORD PTR _side$89055[ebp+edi*8]
	add	ecx, eax
	fmul	QWORD PTR [esi]
	fchs
	fld	QWORD PTR _side$89055[ebp+ecx*8]
	fchs
	fmul	QWORD PTR [ebx]
	fmul	ST(0), ST(6)
	fsubp	ST(1), ST(0)

; 102  :             if ( j == k ) other -= sd[i]/2;

	cmp	edx, eax
	jne	SHORT $LN77@area_hessi
	mov	ecx, DWORD PTR tv3591[ebp]
	fld	QWORD PTR [ecx]
	fmul	ST(0), ST(6)
	fsubp	ST(1), ST(0)
$LN77@area_hessi:

; 95   :           for ( k = 0 ; k < SDIM ; k++ )

	mov	edi, DWORD PTR tv3402[ebp]
	lea	ecx, DWORD PTR [edi+eax*8]

; 103  :             otherD[j][k] = 
; 104  :                     density*(other - 2*first[i][j]*first[jj][k])/two_area;

	fld	QWORD PTR _first$89061[ebp+ecx]
	mov	ecx, DWORD PTR tv3465[ebp]
	fmul	ST(0), ST(2)
	mov	ecx, DWORD PTR [ecx]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fdiv	ST(0), ST(6)
	fstp	QWORD PTR [ecx+eax*8]
$LN6@area_hessi:

; 95   :           for ( k = 0 ; k < SDIM ; k++ )

	mov	ecx, DWORD PTR _web+616
	add	DWORD PTR tv3202[ebp], 8
	inc	eax
	cmp	eax, ecx
	jl	$LN7@area_hessi
	mov	esi, DWORD PTR _jj$89093[ebp]
	fstp	ST(0)
	mov	edi, DWORD PTR tv3481[ebp]
$LN9@area_hessi:

; 92   : 
; 93   :        /* for now, all degrees of freedom are coordinate */
; 94   :        for ( j = 0 ; j < SDIM ; j++ )

	add	DWORD PTR tv3465[ebp], 4
	inc	edx
	cmp	edx, ecx
	jl	$LN10@area_hessi

; 95   :           for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(4)
	fstp	ST(1)
	fstp	ST(1)
	fstp	ST(0)
$LN110@area_hessi:

; 105  :           }
; 106  :           fill_self_entry(S,v_id[i],self2);

	mov	edx, DWORD PTR tv3495[ebp]
	fstp	ST(0)
	mov	eax, DWORD PTR _self2$[ebp]
	mov	edi, DWORD PTR _v_id$89064[ebp+edx]
	mov	ebx, DWORD PTR _S$GSCopy$[ebp]
	push	eax
	push	edi
	push	ebx
	call	_fill_self_entry

; 107  :           if ( v[jj]->freedom > 0 ) 

	mov	ecx, DWORD PTR _v$89059[ebp+esi*4]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [ecx+8], 0
	jle	SHORT $LN74@area_hessi

; 108  :             fill_mixed_entry(S,v_id[i],v_id[jj],otherD);

	mov	edx, DWORD PTR _otherD$[ebp]
	mov	eax, DWORD PTR _v_id$89064[ebp+esi*4]
	push	edx
	push	eax
	push	edi
	push	ebx
	call	_fill_mixed_entry
	add	esp, 16					; 00000010H
$LN74@area_hessi:
	fld	QWORD PTR _two_area$89060[ebp]
$LN13@area_hessi:

; 84   :      for ( i = 0 ; i < FACET_EDGES ; i++ )

	mov	ecx, DWORD PTR tv3503[ebp]
	add	DWORD PTR tv3501[ebp], 6
	add	DWORD PTR tv3593[ebp], 48		; 00000030H
	add	DWORD PTR tv3591[ebp], 8
	add	DWORD PTR tv3495[ebp], 4
	inc	ecx
	dec	DWORD PTR tv3540[ebp]
	mov	DWORD PTR tv3503[ebp], ecx
	jne	$LN82@area_hessi
$LN103@area_hessi:
	mov	ecx, DWORD PTR tv964[ebp]
	fstp	ST(0)
	mov	ebx, DWORD PTR _web+236
$LN33@area_hessi:

; 36   : 
; 37   :   /* fill in sparse matrix rows and volume constraint rows */
; 38   : 
; 39   :   FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR [ecx+ebx]
	mov	edi, DWORD PTR [ecx]
	mov	edx, edi
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	$LL80@area_hessi
	pop	esi
	pop	ebx
$LN32@area_hessi:

; 109  :         }
; 110  :   }
; 111  : }  /* end area_hessian() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_area_hessian ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	_first$GSCopy$
PUBLIC	_e_id$GSCopy$
PUBLIC	_second$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_constr_hessian
EXTRN	_gauss1Dwt:DWORD
EXTRN	_vec_mat_mul:PROC
EXTRN	_eval_all:PROC
EXTRN	_gauss1Dpt:DWORD
EXTRN	_gauss1D_num:DWORD
EXTRN	_nullcon:QWORD
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _edge_constr_hessian
_TEXT	SEGMENT
_e_id$GSCopy$ = -572					; size = 4
_green_deriv$ = -568					; size = 24
_first$GSCopy$ = -544					; size = 4
tv2475 = -540						; size = 4
tv1988 = -540						; size = 4
_sign$ = -536						; size = 4
_hcoord$ = -532						; size = 4
_tcoord$ = -528						; size = 4
_second$GSCopy$ = -524					; size = 4
tv1992 = -520						; size = 4
tv1127 = -520						; size = 4
tv1417 = -516						; size = 4
_j$ = -516						; size = 4
tv1553 = -512						; size = 4
_m$ = -512						; size = 4
_conmap$ = -508						; size = 4
tv2481 = -504						; size = 4
tv1886 = -504						; size = 4
tv1557 = -504						; size = 4
tv1659 = -500						; size = 4
tv1561 = -500						; size = 4
_constr$ = -500						; size = 4
tv2269 = -496						; size = 4
tv1984 = -496						; size = 4
tv1109 = -496						; size = 4
tv2766 = -492						; size = 4
tv1499 = -492						; size = 4
_i$ = -492						; size = 4
tv2487 = -488						; size = 4
tv2256 = -488						; size = 4
tv1935 = -488						; size = 4
tv1536 = -488						; size = 4
_green_deriv_space$ = -484				; size = 288
_grad$ = -196						; size = 48
_green$ = -148						; size = 48
_midpt$ = -100						; size = 48
_side$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_e_id$ = 12						; size = 4
_first$ = 16						; size = 4
_second$ = 20						; size = 4
_edge_constr_hessian PROC				; COMDAT

; 180  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 572				; 0000023cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 181  :   REAL *tcoord,*hcoord;
; 182  :   struct constraint *constr;
; 183  :   int i,m;
; 184  :   REAL side[MAXCOORD];
; 185  :   REAL green[MAXCOORD];
; 186  :   REAL green_deriv_space[MAXCOORD][MAXCOORD];
; 187  :   REAL *green_deriv[MAXCOORD];
; 188  :   int j,sign;
; 189  :   conmap_t *conmap;
; 190  :   REAL midpt[MAXCOORD];
; 191  :   REAL grad[MAXCOORD];
; 192  : 
; 193  :   conmap = get_e_constraint_map(e_id);

	mov	ecx, DWORD PTR _second$[ebp]
	mov	edx, DWORD PTR _web+216

; 205  :      }
; 206  : 
; 207  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _first$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR _second$GSCopy$[ebp], ecx
	mov	ecx, DWORD PTR _dymem
	cmp	DWORD PTR [edx+ecx+1048], 0
	push	esi
	mov	esi, DWORD PTR _web+124

; 219  :          for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _e_id$GSCopy$[ebp], ebx
	mov	DWORD PTR _first$GSCopy$[ebp], eax
	je	SHORT $LN31@edge_const

; 181  :   REAL *tcoord,*hcoord;
; 182  :   struct constraint *constr;
; 183  :   int i,m;
; 184  :   REAL side[MAXCOORD];
; 185  :   REAL green[MAXCOORD];
; 186  :   REAL green_deriv_space[MAXCOORD][MAXCOORD];
; 187  :   REAL *green_deriv[MAXCOORD];
; 188  :   int j,sign;
; 189  :   conmap_t *conmap;
; 190  :   REAL midpt[MAXCOORD];
; 191  :   REAL grad[MAXCOORD];
; 192  : 
; 193  :   conmap = get_e_constraint_map(e_id);

	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	add	eax, DWORD PTR [edx+ecx+1024]
	mov	DWORD PTR _conmap$[ebp], eax
	jmp	SHORT $LN32@edge_const
$LN31@edge_const:
	mov	DWORD PTR _conmap$[ebp], OFFSET _nullcon
	mov	eax, DWORD PTR _conmap$[ebp]
$LN32@edge_const:

; 194  :   if ( !conmap[0] ) return;

	cmp	DWORD PTR [eax], 0
	je	$LN19@edge_const

; 195  :   if ( get_eattr(e_id) & NEGBOUNDARY ) sign = -1;

	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN27@edge_const
	or	eax, -1
	jmp	SHORT $LN104@edge_const
$LN27@edge_const:

; 196  :   else sign = 1;

	mov	eax, 1
$LN104@edge_const:
	mov	DWORD PTR _sign$[ebp], eax

; 197  :   if ( inverted(e_id) ) sign = -sign;

	test	ebx, 134217728				; 08000000H
	je	SHORT $LN25@edge_const
	neg	eax
	mov	DWORD PTR _sign$[ebp], eax
$LN25@edge_const:

; 198  : 
; 199  :   tcoord = get_coord(get_edge_tailv(e_id));

	mov	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR [eax+ecx+64]
	push	edi
	push	ebx
	call	_get_edge_tailv
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]
	add	edi, esi

; 200  :   hcoord = get_coord(get_edge_headv(e_id));

	push	ebx
	mov	DWORD PTR _tcoord$[ebp], edi
	call	_get_edge_headv
	mov	edx, DWORD PTR _web+12

; 201  :   for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _web+616
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	add	edx, esi
	add	esp, 8
	xor	eax, eax
	mov	DWORD PTR _hcoord$[ebp], edx
	cmp	ebx, 4
	jl	$LC48@edge_const

; 204  :         green_deriv[j] = green_deriv_space[j];

	mov	esi, edx
	sub	esi, edi
	mov	DWORD PTR tv1536[ebp], esi
	lea	esi, DWORD PTR _side$[ebp]
	sub	esi, edi
	mov	DWORD PTR tv1553[ebp], esi
	lea	esi, DWORD PTR _side$[ebp+8]
	sub	esi, edi
	mov	DWORD PTR tv1557[ebp], esi
	lea	ecx, DWORD PTR _green_deriv_space$[ebp+48]
	mov	DWORD PTR tv1417[ebp], ecx
	lea	esi, DWORD PTR _side$[ebp+16]
	lea	ecx, DWORD PTR [edx+24]
	sub	esi, edi
	mov	DWORD PTR tv1499[ebp], ecx
	mov	DWORD PTR tv1561[ebp], esi
	mov	esi, DWORD PTR tv1417[ebp]
	lea	ecx, DWORD PTR [edi+8]
	npad	10
$LL60@edge_const:

; 202  :      { 
; 203  :         side[j] = hcoord[j] - tcoord[j];

	mov	edi, DWORD PTR tv1499[ebp]
	fld	QWORD PTR [edi-24]

; 204  :         green_deriv[j] = green_deriv_space[j];

	lea	edi, DWORD PTR [esi-48]
	fsub	QWORD PTR [ecx-8]
	mov	DWORD PTR _green_deriv$[ebp+eax*4], edi
	mov	edi, DWORD PTR tv1536[ebp]
	add	eax, 4
	fstp	QWORD PTR _side$[ebp+eax*8-32]
	add	ecx, 32					; 00000020H
	fld	QWORD PTR [edi+ecx-32]
	mov	edi, DWORD PTR tv1553[ebp]
	fsub	QWORD PTR [ecx-32]
	mov	DWORD PTR _green_deriv$[ebp+eax*4-12], esi
	fstp	QWORD PTR [edi+ecx-32]
	mov	edi, DWORD PTR tv1499[ebp]
	fld	QWORD PTR [edi-8]
	mov	edi, DWORD PTR tv1557[ebp]
	fsub	QWORD PTR [ecx-24]
	fstp	QWORD PTR [edi+ecx-32]
	lea	edi, DWORD PTR [esi+48]
	mov	DWORD PTR _green_deriv$[ebp+eax*4-8], edi
	mov	edi, DWORD PTR tv1499[ebp]
	fld	QWORD PTR [edi]
	mov	edi, DWORD PTR tv1561[ebp]
	fsub	QWORD PTR [ecx-16]
	add	DWORD PTR tv1499[ebp], 32		; 00000020H
	fstp	QWORD PTR [edi+ecx-32]
	lea	edi, DWORD PTR [esi+96]
	mov	DWORD PTR _green_deriv$[ebp+eax*4-4], edi
	lea	edi, DWORD PTR [ebx-3]
	add	esi, 192				; 000000c0H
	cmp	eax, edi
	jl	$LL60@edge_const
	mov	edi, DWORD PTR _tcoord$[ebp]
$LC48@edge_const:

; 201  :   for ( j = 0 ; j < SDIM ; j++ )

	cmp	eax, ebx
	jge	SHORT $LN47@edge_const
	lea	ecx, DWORD PTR [eax+eax*2]
	add	ecx, ecx
	mov	esi, edx
	sub	esi, edi
	lea	ecx, DWORD PTR _green_deriv_space$[ebp+ecx*8]
	mov	DWORD PTR tv1536[ebp], esi
	lea	esi, DWORD PTR _side$[ebp]
	mov	DWORD PTR tv1659[ebp], ecx
	lea	ecx, DWORD PTR [edi+eax*8]
	sub	esi, edi
	npad	13
$LL61@edge_const:

; 202  :      { 
; 203  :         side[j] = hcoord[j] - tcoord[j];

	mov	edi, DWORD PTR tv1536[ebp]
	fld	QWORD PTR [ecx+edi]

; 204  :         green_deriv[j] = green_deriv_space[j];

	mov	edi, DWORD PTR tv1659[ebp]
	fsub	QWORD PTR [ecx]
	mov	DWORD PTR _green_deriv$[ebp+eax*4], edi
	inc	eax
	add	edi, 48					; 00000030H
	fstp	QWORD PTR [ecx+esi]
	add	ecx, 8
	mov	DWORD PTR tv1659[ebp], edi
	cmp	eax, ebx
	jl	SHORT $LL61@edge_const
$LN47@edge_const:

; 205  :      }
; 206  : 
; 207  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _conmap$[ebp]
	mov	esi, 1
	mov	DWORD PTR _j$[ebp], esi
	cmp	DWORD PTR [eax], esi
	jl	$LN63@edge_const
	fld1
$LN62@edge_const:

; 208  :    {
; 209  :      constr = get_constraint(conmap[j]);

	mov	ecx, DWORD PTR _conmap$[ebp]
	mov	eax, DWORD PTR [ecx+esi*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 210  :      if ( !(constr->attr & CON_ENERGY) 
; 211  :               || (constr->compcount != SDIM) ) continue;

	xor	edi, edi
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 64					; 00000040H
	or	ecx, edi
	mov	DWORD PTR _constr$[ebp], eax
	je	$LN20@edge_const
	cmp	DWORD PTR [eax+44], ebx
	jne	$LN20@edge_const

; 212  :      for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	DWORD PTR _m$[ebp], edi
	cmp	DWORD PTR _gauss1D_num, edi
	jle	$LN20@edge_const
	jmp	SHORT $LN16@edge_const
$LN56@edge_const:
	mov	eax, DWORD PTR _constr$[ebp]
$LN16@edge_const:

; 213  :       {
; 214  :          for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _gauss1Dpt
	xor	esi, esi
	mov	DWORD PTR _i$[ebp], esi
	cmp	ebx, 4
	jl	$LC51@edge_const
	mov	esi, DWORD PTR _tcoord$[ebp]
	lea	eax, DWORD PTR [esi+24]

; 215  :             midpt[i] = gauss1Dpt[m]*hcoord[i] + (1 - gauss1Dpt[m])*tcoord[i];

	sub	esi, edx
	mov	DWORD PTR tv1935[ebp], esi
	lea	esi, DWORD PTR _midpt$[ebp]
	sub	esi, edx
	mov	DWORD PTR tv1984[ebp], esi
	lea	esi, DWORD PTR _midpt$[ebp+8]
	sub	esi, edx
	mov	DWORD PTR tv1988[ebp], esi
	lea	esi, DWORD PTR _midpt$[ebp+16]
	sub	esi, edx
	mov	DWORD PTR tv1886[ebp], eax
	mov	DWORD PTR tv1992[ebp], esi
	mov	esi, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [edx+8]
$LN55@edge_const:
	mov	edx, DWORD PTR tv1886[ebp]
	fld	ST(0)
	fsub	QWORD PTR [ecx+edi*8]
	add	edx, 32					; 00000020H
	mov	DWORD PTR tv1886[ebp], edx
	add	eax, 32					; 00000020H
	fmul	QWORD PTR [edx-56]
	fld	QWORD PTR [eax-40]
	fmul	QWORD PTR [ecx+edi*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _midpt$[ebp+esi*8]
	mov	esi, DWORD PTR tv1935[ebp]
	fld	ST(0)
	fsub	QWORD PTR [ecx+edi*8]
	fmul	QWORD PTR [esi+eax-32]
	mov	esi, DWORD PTR tv1984[ebp]
	fld	QWORD PTR [ecx+edi*8]
	fmul	QWORD PTR [eax-32]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+eax-32]
	mov	esi, DWORD PTR tv1988[ebp]
	fld	ST(0)
	fsub	QWORD PTR [ecx+edi*8]
	fmul	QWORD PTR [edx-40]
	fld	QWORD PTR [eax-24]
	fmul	QWORD PTR [ecx+edi*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+eax-32]
	mov	esi, DWORD PTR tv1992[ebp]
	fld	ST(0)
	fsub	QWORD PTR [ecx+edi*8]
	fmul	QWORD PTR [edx-32]
	lea	edx, DWORD PTR [ebx-3]
	fld	QWORD PTR [eax-16]
	fmul	QWORD PTR [ecx+edi*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+eax-32]
	mov	esi, DWORD PTR _i$[ebp]
	add	esi, 4
	mov	DWORD PTR _i$[ebp], esi
	cmp	esi, edx
	jl	$LN55@edge_const
	mov	edx, DWORD PTR _hcoord$[ebp]
	mov	eax, DWORD PTR _constr$[ebp]
$LC51@edge_const:

; 213  :       {
; 214  :          for ( i = 0 ; i < SDIM ; i++ )

	cmp	esi, ebx
	jge	SHORT $LN80@edge_const
	lea	eax, DWORD PTR [edx+esi*8]
	mov	esi, DWORD PTR _tcoord$[ebp]
	sub	esi, edx
	mov	DWORD PTR tv1935[ebp], esi
	lea	esi, DWORD PTR _midpt$[ebp]
	sub	esi, edx
	mov	edx, ebx
	sub	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv1984[ebp], esi
$LN58@edge_const:

; 215  :             midpt[i] = gauss1Dpt[m]*hcoord[i] + (1 - gauss1Dpt[m])*tcoord[i];

	mov	esi, DWORD PTR tv1935[ebp]
	fld	ST(0)
	fsub	QWORD PTR [ecx+edi*8]
	add	eax, 8
	dec	edx
	fmul	QWORD PTR [esi+eax-8]
	mov	esi, DWORD PTR tv1984[ebp]
	fld	QWORD PTR [eax-8]
	fmul	QWORD PTR [ecx+edi*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+eax-8]
	jne	SHORT $LN58@edge_const

; 213  :       {
; 214  :          for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _constr$[ebp]
$LN80@edge_const:

; 216  :          for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	fstp	ST(0)
	test	ebx, ebx
	jle	SHORT $LN8@edge_const
	lea	ecx, DWORD PTR _green$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR tv2256[ebp], ecx
	mov	DWORD PTR tv2269[ebp], eax
	npad	11
$LL57@edge_const:

; 217  :             eval_all(constr->envect[i],midpt,SDIM,&green[i],green_deriv[i],e_id);

	mov	edx, DWORD PTR _e_id$GSCopy$[ebp]
	mov	eax, DWORD PTR _green_deriv$[ebp+esi*4]
	mov	ecx, DWORD PTR tv2256[ebp]
	push	edx
	push	eax
	mov	eax, DWORD PTR tv2269[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	push	ebx
	lea	edx, DWORD PTR _midpt$[ebp]
	push	edx
	push	ecx
	call	_eval_all
	mov	ebx, DWORD PTR _web+616
	add	DWORD PTR tv2269[ebp], 4
	add	DWORD PTR tv2256[ebp], 8
	inc	esi
	add	esp, 24					; 00000018H
	cmp	esi, ebx
	jl	SHORT $LL57@edge_const
$LN8@edge_const:

; 218  :          vec_mat_mul(side,green_deriv,grad,SDIM,SDIM);

	push	ebx
	push	ebx
	lea	edx, DWORD PTR _grad$[ebp]
	push	edx
	lea	eax, DWORD PTR _green_deriv$[ebp]
	push	eax
	lea	ecx, DWORD PTR _side$[ebp]
	push	ecx
	call	_vec_mat_mul

; 219  :          for ( i = 0 ; i < SDIM ; i++ )

	mov	ebx, DWORD PTR _web+616
	add	esp, 20					; 00000014H
	xor	ecx, ecx
	test	ebx, ebx
	jle	$LN54@edge_const
	mov	edx, DWORD PTR _first$GSCopy$[ebp]
	fild	DWORD PTR _sign$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld1
	mov	edx, DWORD PTR _gauss1Dwt
	mov	DWORD PTR tv1127[ebp], eax
	mov	eax, DWORD PTR _gauss1Dpt
	lea	ebx, DWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR _first$GSCopy$[ebp]
	lea	esi, DWORD PTR [eax+edi*8]
	mov	eax, DWORD PTR [edx]
	lea	edx, DWORD PTR _grad$[ebp]
	sub	eax, edx
	mov	DWORD PTR tv1109[ebp], ebx
	mov	DWORD PTR tv2766[ebp], eax
	jmp	SHORT $LN7@edge_const
$LN59@edge_const:
	mov	ebx, DWORD PTR tv1109[ebp]
$LN7@edge_const:

; 220  :             { int jj;
; 221  : 
; 222  :               first[0][i] += sign*gauss1Dwt[m]*((1-gauss1Dpt[m])*grad[i]-green[i]);

	fld	ST(0)
	lea	edx, DWORD PTR _grad$[ebp+ecx*8]
	fsub	QWORD PTR [esi]
	fmul	QWORD PTR [edx]
	fsub	QWORD PTR _green$[ebp+ecx*8]
	fld	QWORD PTR [ebx]
	fmul	ST(0), ST(3)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR [eax+edx]
	fstp	QWORD PTR [eax+edx]

; 223  :               first[1][i] += sign*gauss1Dwt[m]*(gauss1Dpt[m]*grad[i] + green[i]);

	fld	QWORD PTR [edx]
	mov	edx, DWORD PTR tv1127[ebp]
	fmul	QWORD PTR [esi]
	fadd	QWORD PTR _green$[ebp+ecx*8]
	fld	QWORD PTR [ebx]
	fmul	ST(0), ST(3)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+ecx*8]

; 224  : 
; 225  :               if ( hess_flag )

	cmp	DWORD PTR _hess_flag, 0

; 226  :                 for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	ebx, DWORD PTR _web+616
	je	$LN6@edge_const
	xor	edx, edx
	test	ebx, ebx
	jle	$LN6@edge_const
	mov	eax, DWORD PTR _second$GSCopy$[ebp]
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	eax, DWORD PTR [eax+ecx*4]
	sub	edi, eax
	mov	DWORD PTR tv2475[ebp], edi
	mov	edi, DWORD PTR _second$GSCopy$[ebp]
	mov	edi, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi+ecx*4]
	sub	edi, eax
	mov	DWORD PTR tv2481[ebp], edi
	mov	edi, DWORD PTR _second$GSCopy$[ebp]
	mov	edi, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi+ecx*4]
	sub	edi, eax
	mov	DWORD PTR tv2487[ebp], edi
$LN3@edge_const:

; 227  :                 { second[0][0][i][jj] -= sign*gauss1Dwt[m]*
; 228  :                     (green_deriv[i][jj]+green_deriv[jj][i])*(1-gauss1Dpt[m]);

	mov	edi, DWORD PTR _green_deriv$[ebp+edx*4]
	fld	QWORD PTR [edi+ecx*8]
	mov	ebx, DWORD PTR _green_deriv$[ebp+ecx*4]
	fadd	QWORD PTR [ebx+edx*8]
	mov	edi, DWORD PTR tv1109[ebp]
	fld	QWORD PTR [edi]
	mov	ebx, DWORD PTR tv2475[ebp]
	fmul	ST(0), ST(3)
	inc	edx
	add	eax, 8
	fmulp	ST(1), ST(0)
	fld	ST(1)
	fsub	QWORD PTR [esi]
	fmulp	ST(1), ST(0)
	fsubr	QWORD PTR [ebx+eax-8]
	fstp	QWORD PTR [ebx+eax-8]

; 229  :                   second[0][1][i][jj] += sign*gauss1Dwt[m]*
; 230  :                     (-green_deriv[i][jj]*(1-gauss1Dpt[m])
; 231  :                         + green_deriv[jj][i]*gauss1Dpt[m]);

	mov	ebx, DWORD PTR _green_deriv$[ebp+edx*4-4]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR _green_deriv$[ebp+ecx*4]
	fmul	QWORD PTR [esi]
	fld	ST(1)
	fsub	QWORD PTR [esi]
	fmul	QWORD PTR [ebx+edx*8-8]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [edi]
	fmul	ST(0), ST(3)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]

; 232  :                   second[1][0][i][jj] += sign*gauss1Dwt[m]*
; 233  :                     (-green_deriv[jj][i]*(1-gauss1Dpt[m])
; 234  :                         + green_deriv[i][jj]*gauss1Dpt[m]);

	mov	ebx, DWORD PTR _green_deriv$[ebp+ecx*4]
	fld	QWORD PTR [ebx+edx*8-8]
	mov	ebx, DWORD PTR _green_deriv$[ebp+edx*4-4]
	fmul	QWORD PTR [esi]
	fld	ST(1)
	fsub	QWORD PTR [esi]
	fmul	QWORD PTR [ebx+ecx*8]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [edi]
	mov	edi, DWORD PTR tv2481[ebp]
	fmul	ST(0), ST(3)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR [edi+eax-8]
	fstp	QWORD PTR [edi+eax-8]

; 235  :                   second[1][1][i][jj] += sign*gauss1Dwt[m]*
; 236  :                     (green_deriv[i][jj]+green_deriv[jj][i])*gauss1Dpt[m];

	mov	edi, DWORD PTR _green_deriv$[ebp+edx*4-4]
	fld	QWORD PTR [edi+ecx*8]
	mov	ebx, DWORD PTR _green_deriv$[ebp+ecx*4]
	fadd	QWORD PTR [ebx+edx*8-8]
	mov	edi, DWORD PTR tv1109[ebp]
	fld	QWORD PTR [edi]
	mov	edi, DWORD PTR tv2487[ebp]
	fmul	ST(0), ST(3)
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR [esi]
	fadd	QWORD PTR [edi+eax-8]
	fstp	QWORD PTR [edi+eax-8]
	mov	ebx, DWORD PTR _web+616
	cmp	edx, ebx
	jl	$LN3@edge_const

; 226  :                 for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	edi, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR tv2766[ebp]
$LN6@edge_const:

; 219  :          for ( i = 0 ; i < SDIM ; i++ )

	inc	ecx
	cmp	ecx, ebx
	jl	$LN59@edge_const
	fstp	ST(1)
	jmp	SHORT $LN15@edge_const
$LN54@edge_const:
	fld1
$LN15@edge_const:

; 212  :      for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	edx, DWORD PTR _hcoord$[ebp]
	inc	edi
	mov	DWORD PTR _m$[ebp], edi
	cmp	edi, DWORD PTR _gauss1D_num
	jl	$LN56@edge_const
	mov	esi, DWORD PTR _j$[ebp]
$LN20@edge_const:

; 205  :      }
; 206  : 
; 207  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	ecx, DWORD PTR _conmap$[ebp]
	inc	esi
	mov	DWORD PTR _j$[ebp], esi
	cmp	esi, DWORD PTR [ecx]
	jle	$LN62@edge_const
	fstp	ST(0)
$LN63@edge_const:
	pop	edi
$LN19@edge_const:

; 237  :                 }
; 238  :             }
; 239  :         }
; 240  :     }
; 241  : } /* end edge_constr_hessian() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_constr_hessian ENDP
_TEXT	ENDS
PUBLIC	__real@4018000000000000
PUBLIC	__real@c018000000000000
PUBLIC	??_C@_09GELDJEGO@?$CFd?5?5?5?5?$CFg?6?$AA@	; `string'
PUBLIC	??_C@_0M@FIJONOPB@Z?5vector?3?5?6?$AA@		; `string'
PUBLIC	??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@		; `string'
PUBLIC	_rhs$GSCopy$
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_body_hessian
EXTRN	_temp_free:PROC
EXTRN	_sp_hash_search:PROC
EXTRN	_cross_prod:PROC
EXTRN	_everything_quantities_flag:DWORD
EXTRN	_rhs_flag:DWORD
EXTRN	_printf:PROC
EXTRN	_hess_debug:DWORD
EXTRN	_kb_temp_calloc:PROC
;	COMDAT __real@4018000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT __real@c018000000000000
CONST	SEGMENT
__real@c018000000000000 DQ 0c018000000000000r	; -6
CONST	ENDS
;	COMDAT ??_C@_09GELDJEGO@?$CFd?5?5?5?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_09GELDJEGO@?$CFd?5?5?5?5?$CFg?6?$AA@ DB '%d    %g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FIJONOPB@Z?5vector?3?5?6?$AA@
CONST	SEGMENT
??_C@_0M@FIJONOPB@Z?5vector?3?5?6?$AA@ DB 'Z vector: ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
CONST	SEGMENT
??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@ DB 'HESSIAN3.C', 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\hessian3.c
CONST	ENDS
;	COMDAT _body_hessian
_TEXT	SEGMENT
_selfqXvS$ = -1036					; size = 24
_otherDqXvS$ = -1012					; size = 24
_v$89400 = -988						; size = 12
_v$89317 = -988						; size = 12
_otherD$ = -976						; size = 4
_rhs$GSCopy$ = -972					; size = 4
_self$ = -968						; size = 4
_do_b$89320 = -964					; size = 4
_do_bb$89321 = -960					; size = 4
_coe$ = -956						; size = 8
_x$89401 = -948						; size = 12
_ssum$ = -944						; size = 8
tv1739 = -936						; size = 8
_zsum$ = -936						; size = 8
_a$89322 = -936						; size = 8
tv1730 = -928						; size = 4
_jj$89432 = -928					; size = 4
_b_id$ = -924						; size = 4
tv2911 = -920						; size = 4
tv2908 = -920						; size = 4
tv2248 = -920						; size = 4
_Z$ = -916						; size = 4
tv2739 = -912						; size = 4
_ggg$89365 = -912					; size = 4
tv2930 = -908						; size = 4
tv675 = -908						; size = 4
_fe_id$89399 = -908					; size = 4
tv1783 = -904						; size = 4
_S$GSCopy$ = -900					; size = 4
tv2170 = -896						; size = 4
tv1850 = -896						; size = 4
tv642 = -896						; size = 4
tv2130 = -892						; size = 4
_bb_id$89319 = -892					; size = 4
tv2838 = -888						; size = 4
tv1868 = -888						; size = 4
tv1786 = -888						; size = 4
_ii$89431 = -888					; size = 4
tv2873 = -884						; size = 4
tv2725 = -884						; size = 4
tv1780 = -884						; size = 4
_otherDxJ$ = -880					; size = 288
_selfxJ$ = -592						; size = 288
_side$89315 = -304					; size = 144
_gg$89364 = -160					; size = 48
_grad$89366 = -112					; size = 48
_g$89363 = -64						; size = 48
_v_id$89402 = -16					; size = 12
_x$89318 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_rhs$ = 12						; size = 4
_body_hessian PROC					; COMDAT

; 256  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1036				; 0000040cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 285  :     }
; 286  :   }
; 287  : 
; 288  :   /* body volume constraints, linear part */
; 289  :   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _S$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	push	ebx
	push	esi
	push	edi
	push	6
	push	6
	lea	edx, DWORD PTR _otherDxJ$[ebp]
	mov	DWORD PTR _S$GSCopy$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _otherDqXvS$[ebp]
	push	eax
	mov	DWORD PTR _rhs$GSCopy$[ebp], ecx
	call	_mat2d_setup
	push	6
	push	6
	lea	ecx, DWORD PTR _selfxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _selfqXvS$[ebp]
	push	edx
	mov	DWORD PTR _otherD$[ebp], eax
	call	_mat2d_setup
	push	267					; 0000010bH
	mov	DWORD PTR _self$[ebp], eax
	mov	eax, DWORD PTR _web+404
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	inc	eax
	push	8
	push	eax
	call	_kb_temp_calloc
	fldz
	mov	edi, eax
	mov	eax, DWORD PTR _web+384
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	add	esp, 48					; 00000030H
	and	ecx, 1
	mov	DWORD PTR _Z$[ebp], edi
	je	SHORT $LN220@body_hessi
$LN230@body_hessi:

; 257  :   int i,j;
; 258  :   int count = 0;
; 259  :   facet_id f_id;
; 260  :   body_id b_id;
; 261  :   REAL *Z;
; 262  :   REAL coe;
; 263  :   MAT2D(otherD,MAXCOORD,MAXCOORD);
; 264  :   MAT2D(self,MAXCOORD,MAXCOORD);
; 265  :   REAL zsum,ssum;
; 266  : 
; 267  :   Z = (REAL *)temp_calloc(web.skel[BODY].max_ord+1,sizeof(REAL));
; 268  :   FOR_ALL_BODIES(b_id) 

	mov	edx, DWORD PTR _web+348
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR tv1739[ebp+4], eax
	mov	eax, edx
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN80@body_hessi

; 269  :      if ( get_battr(b_id) & FIXEDVOL )

	and	edx, 32					; 00000020H
	xor	eax, eax
	or	edx, eax
	je	SHORT $LN80@body_hessi

; 270  :         Z[loc_ordinal(b_id)] = get_body_pressure(b_id);

	test	ecx, ecx
	je	SHORT $LN84@body_hessi
	fld	QWORD PTR [edi+312]
	mov	eax, esi
	jmp	SHORT $LN107@body_hessi
$LN84@body_hessi:
	or	eax, -1
	fld	ST(0)
$LN107@body_hessi:
	mov	ecx, DWORD PTR _Z$[ebp]
	fstp	QWORD PTR [ecx+eax*8]
$LN80@body_hessi:

; 257  :   int i,j;
; 258  :   int count = 0;
; 259  :   facet_id f_id;
; 260  :   body_id b_id;
; 261  :   REAL *Z;
; 262  :   REAL coe;
; 263  :   MAT2D(otherD,MAXCOORD,MAXCOORD);
; 264  :   MAT2D(self,MAXCOORD,MAXCOORD);
; 265  :   REAL zsum,ssum;
; 266  : 
; 267  :   Z = (REAL *)temp_calloc(web.skel[BODY].max_ord+1,sizeof(REAL));
; 268  :   FOR_ALL_BODIES(b_id) 

	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	SHORT $LN230@body_hessi
	mov	edi, DWORD PTR _Z$[ebp]
$LN220@body_hessi:

; 271  :   /* Z is vector of coefficients for adding constraint hessians */
; 272  : 
; 273  :   if ( hess_debug ) 

	cmp	DWORD PTR _hess_debug, 0
	je	SHORT $LN72@body_hessi

; 274  :   { printf("Z vector: \n");

	push	OFFSET ??_C@_0M@FIJONOPB@Z?5vector?3?5?6?$AA@
	fstp	ST(0)
	call	_printf

; 275  :     for ( i = 0 ; i < web.skel[BODY].max_ord+1 ; i++ ) 

	mov	ecx, DWORD PTR _web+404
	inc	ecx
	add	esp, 4
	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN221@body_hessi
$LL74@body_hessi:

; 276  :        printf("%d    %g\n",i,(DOUBLE)Z[i]);

	fld	QWORD PTR [edi+esi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	esi
	push	OFFSET ??_C@_09GELDJEGO@?$CFd?5?5?5?5?$CFg?6?$AA@
	call	_printf
	mov	edx, DWORD PTR _web+404
	inc	esi
	inc	edx
	add	esp, 16					; 00000010H
	cmp	esi, edx
	jl	SHORT $LL74@body_hessi
$LN221@body_hessi:

; 275  :     for ( i = 0 ; i < web.skel[BODY].max_ord+1 ; i++ ) 

	fldz
$LN72@body_hessi:

; 277  :   }
; 278  : 
; 279  :   /* rhs for body constraint rows */
; 280  :   if ( rhs_flag && !everything_quantities_flag )

	cmp	DWORD PTR _rhs_flag, 0
	je	$LN68@body_hessi
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	$LN68@body_hessi

; 281  :   { FOR_ALL_BODIES(b_id)

	mov	edx, DWORD PTR _web+384
	mov	edi, edx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	je	SHORT $LN68@body_hessi
$LN233@body_hessi:
	mov	eax, DWORD PTR _web+348
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR tv1739[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN69@body_hessi

; 282  :     { REAL *current = rhs + S->bodyrowstart + loc_ordinal(b_id);

	test	edi, edi
	je	SHORT $LN86@body_hessi
	mov	eax, edx
	jmp	SHORT $LN87@body_hessi
$LN86@body_hessi:
	or	eax, -1
$LN87@body_hessi:
	mov	ebx, DWORD PTR _S$GSCopy$[ebp]
	mov	ebx, DWORD PTR [ebx+20]
	add	ebx, eax
	mov	eax, DWORD PTR _rhs$GSCopy$[ebp]
	lea	ebx, DWORD PTR [eax+ebx*8]

; 283  :       if ( get_battr(b_id) & FIXEDVOL )

	and	ecx, 32					; 00000020H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN69@body_hessi

; 284  :            *current = -(get_body_fixvol(b_id) - get_body_volume(b_id));

	test	edi, edi
	je	SHORT $LN110@body_hessi
	fld	QWORD PTR [esi+32]
	fld	QWORD PTR [esi+40]
	jmp	SHORT $LN115@body_hessi
$LN110@body_hessi:
	fld	ST(0)
	fld	ST(1)
$LN115@body_hessi:
	fsubp	ST(1), ST(0)
	fchs
	fstp	QWORD PTR [ebx]
$LN69@body_hessi:

; 281  :   { FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [edx]
	mov	edi, edx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	SHORT $LN233@body_hessi
$LN68@body_hessi:

; 285  :     }
; 286  :   }
; 287  : 
; 288  :   /* body volume constraints, linear part */
; 289  :   FOR_ALL_FACETS(f_id)

	mov	edi, DWORD PTR _web+272
	mov	eax, edi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv1780[ebp], eax
	je	$LN62@body_hessi
	mov	esi, DWORD PTR _web+236
$LN64@body_hessi:
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1783[ebp], eax
	mov	eax, DWORD PTR [eax+esi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN63@body_hessi

; 290  :   {
; 291  :     REAL side[FACET_EDGES][MAXCOORD];    /* 3 sides of facet */
; 292  :     facetedge_id fe_id;         
; 293  :     struct hess_verlist *v[FACET_VERTS];
; 294  :     REAL *x[FACET_VERTS];  /* for volume calculation */
; 295  :     body_id bb_id;
; 296  :     int do_b, do_bb; /* flags for whether bodies fixed */
; 297  :     ATTR a;
; 298  : 
; 299  :     if ( get_attr(f_id) & NONCONTENT ) continue;

	mov	edx, DWORD PTR tv1783[ebp]
	mov	eax, edi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN63@body_hessi

; 300  : 
; 301  :     b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, ecx
	je	SHORT $LN430@body_hessi
$LN119@body_hessi:
	cmp	DWORD PTR tv1780[ebp], ecx
	jne	SHORT $LN118@body_hessi
	xor	eax, eax
	jmp	SHORT $LN430@body_hessi
$LN118@body_hessi:
	test	edi, 134217728				; 08000000H
	je	SHORT $LN117@body_hessi
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR tv1783[ebp]
	mov	ecx, DWORD PTR [eax+esi]
	mov	eax, DWORD PTR [edx+ecx+4]
	jmp	SHORT $LN430@body_hessi
$LN117@body_hessi:
	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+eax+784]
	mov	edx, DWORD PTR tv1783[ebp]
	mov	eax, DWORD PTR [edx+esi]
	mov	eax, DWORD PTR [ecx+eax]
$LN430@body_hessi:

; 302  :     if ( valid_id(b_id) )

	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _b_id$[ebp], eax
	mov	DWORD PTR tv1730[ebp], ecx
	je	SHORT $LN58@body_hessi

; 303  :     { a = get_battr(b_id);

	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+8]

; 304  :       do_b =  (a & FIXEDVOL) && !(a & REDUNDANT_BIT);

	mov	eax, ecx
	mov	DWORD PTR _a$89322[ebp+4], edx
	and	eax, 32					; 00000020H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN58@body_hessi
	and	ecx, 268435456				; 10000000H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN58@body_hessi
	lea	ebx, DWORD PTR [edx+1]
	jmp	SHORT $LN431@body_hessi
$LN58@body_hessi:

; 305  :     } else do_b = 0;

	xor	ebx, ebx
$LN431@body_hessi:

; 306  : 
; 307  :     bb_id = get_facet_body(inverse_id(f_id));

	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	mov	DWORD PTR _do_b$89320[ebp], ebx
	jne	SHORT $LN125@body_hessi
	xor	eax, eax
	jmp	SHORT $LN432@body_hessi
$LN125@body_hessi:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN124@body_hessi
	xor	eax, eax
	jmp	SHORT $LN432@body_hessi
$LN124@body_hessi:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN123@body_hessi
	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+784]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN432@body_hessi
$LN123@body_hessi:
	mov	ecx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]
$LN432@body_hessi:

; 308  :     if ( valid_id(bb_id) )

	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _bb_id$89319[ebp], eax
	mov	DWORD PTR tv1850[ebp], ecx
	je	SHORT $LN56@body_hessi

; 309  :     { a = get_battr(bb_id);

	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+8]

; 310  :       do_bb =  (a & FIXEDVOL) && !(a & REDUNDANT_BIT);

	mov	eax, ecx
	mov	DWORD PTR _a$89322[ebp+4], edx
	and	eax, 32					; 00000020H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN56@body_hessi
	and	ecx, 268435456				; 10000000H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN56@body_hessi
	lea	eax, DWORD PTR [edx+1]
	jmp	SHORT $LN433@body_hessi
$LN56@body_hessi:

; 311  :     } else do_bb = 0;

	xor	eax, eax
$LN433@body_hessi:
	mov	DWORD PTR _do_bb$89321[ebp], eax

; 312  : 
; 313  :     if ( !do_b && !do_bb ) continue;

	test	ebx, ebx
	jne	SHORT $LN314@body_hessi
	test	eax, eax
	je	$LN63@body_hessi
$LN314@body_hessi:

; 314  : 
; 315  :     fe_id = get_facet_fe(f_id);

	cmp	DWORD PTR tv1780[ebp], 0
	fstp	ST(0)
	jne	SHORT $LN129@body_hessi
	xor	esi, esi
	jmp	SHORT $LN128@body_hessi
$LN129@body_hessi:
	mov	eax, DWORD PTR tv1783[ebp]
	mov	ecx, DWORD PTR [eax+esi]
	mov	esi, DWORD PTR [ecx+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN128@body_hessi
	xor	esi, 134217728				; 08000000H
$LN128@body_hessi:

; 316  :     for ( i = 0 ; i < FACET_EDGES ; i++ )

	mov	ecx, DWORD PTR _web+460
	lea	edx, DWORD PTR _side$89315[ebp]
	mov	DWORD PTR tv2739[ebp], edx
	mov	DWORD PTR tv2725[ebp], 0
	npad	1
$LL222@body_hessi:
	mov	edx, DWORD PTR _dymem

; 317  :     { v[i] = get_vertex_vhead(get_fe_tailv(fe_id));

	mov	edi, DWORD PTR _web+124
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1868[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+20]
	mov	ecx, esi
	and	ecx, 134217728				; 08000000H
	xor	eax, ecx
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR [ecx+edx+304]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN135@body_hessi
	mov	edi, DWORD PTR _web+636
	lea	ecx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [ecx+edx]
	jmp	SHORT $LN134@body_hessi
$LN135@body_hessi:
	mov	ecx, DWORD PTR [edx+ecx]
$LN134@body_hessi:
	mov	edi, DWORD PTR _vhead_attr
	mov	ebx, DWORD PTR _dymem
	imul	edi, 240				; 000000f0H
	add	edi, DWORD PTR _web+104
	and	ecx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edi+ebx+64]
	mov	edi, DWORD PTR _web+12
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ebx+ecx]
	mov	ebx, DWORD PTR tv2725[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _vhead
	mov	DWORD PTR _v$89317[ebp+ebx], ecx

; 318  :       x[i] = get_coord(get_fe_tailv(fe_id));

	mov	ebx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN141@body_hessi
	mov	ebx, DWORD PTR _web+636
	lea	ecx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [ecx+edx]
	jmp	SHORT $LN140@body_hessi
$LN141@body_hessi:
	mov	ecx, DWORD PTR [edx+ecx]
$LN140@body_hessi:
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	add	edx, DWORD PTR [ecx+edi+64]
	mov	edi, DWORD PTR tv2725[ebp]
	mov	DWORD PTR _x$89318[ebp+edi], edx

; 319  :       get_fe_side(fe_id,side[i]);

	mov	edx, DWORD PTR tv2739[ebp]
	push	edx
	push	eax
	call	_get_edge_side

; 320  :       fe_id = get_next_edge(fe_id);

	mov	ecx, DWORD PTR _web+460
	mov	eax, DWORD PTR tv1868[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN147@body_hessi
	mov	esi, DWORD PTR [edx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN52@body_hessi
$LN147@body_hessi:
	mov	esi, DWORD PTR [edx+32]
$LN52@body_hessi:

; 316  :     for ( i = 0 ; i < FACET_EDGES ; i++ )

	add	DWORD PTR tv2739[ebp], 48		; 00000030H
	add	edi, 4
	mov	DWORD PTR tv2725[ebp], edi
	cmp	edi, 12					; 0000000cH
	jl	$LL222@body_hessi

; 321  :     }
; 322  : 
; 323  :     coe = 0.0;
; 324  :     if ( valid_id(b_id) )

	cmp	DWORD PTR tv1730[ebp], 0
	fldz
	fld	ST(0)
	fst	QWORD PTR _coe$[ebp]
	je	SHORT $LN414@body_hessi

; 325  :        coe += Z[loc_ordinal(b_id)];

	mov	eax, DWORD PTR _b_id$[ebp]
	fstp	ST(0)
	mov	ecx, DWORD PTR _Z$[ebp]
	and	eax, 134217727				; 07ffffffH
	fadd	QWORD PTR [ecx+eax*8]
	fst	QWORD PTR _coe$[ebp]
	jmp	SHORT $LN225@body_hessi
$LN414@body_hessi:
	fstp	ST(1)
$LN225@body_hessi:

; 326  :     if ( valid_id(bb_id) )

	cmp	DWORD PTR tv1850[ebp], 0
	je	SHORT $LN49@body_hessi

; 327  :        coe -= Z[loc_ordinal(bb_id)];

	mov	edx, DWORD PTR _bb_id$89319[ebp]
	mov	eax, DWORD PTR _Z$[ebp]
	and	edx, 134217727				; 07ffffffH
	fsub	QWORD PTR [eax+edx*8]
	fst	QWORD PTR _coe$[ebp]
$LN49@body_hessi:

; 328  : 
; 329  :     zsum = (x[0][2]+x[1][2]+x[2][2]);

	mov	ecx, DWORD PTR _x$89318[ebp+4]
	fld	QWORD PTR [ecx+16]
	mov	edx, DWORD PTR _x$89318[ebp]
	fadd	QWORD PTR [edx+16]
	mov	eax, DWORD PTR _x$89318[ebp+8]
	lea	ecx, DWORD PTR _v$89317[ebp]
	mov	DWORD PTR tv2838[ebp], 2
	fadd	QWORD PTR [eax+16]
	mov	DWORD PTR tv2873[ebp], ecx
	mov	DWORD PTR tv675[ebp], 3
	fst	QWORD PTR _zsum$[ebp]

; 330  :     ssum = side[0][0]*side[1][1] - side[0][1]*side[1][0];

	fld	QWORD PTR _side$89315[ebp+56]
	fmul	QWORD PTR _side$89315[ebp]
	fld	QWORD PTR _side$89315[ebp+48]
	fmul	QWORD PTR _side$89315[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _ssum$[ebp]
	jmp	SHORT $LN48@body_hessi
	npad	4
$LL223@body_hessi:

; 328  : 
; 329  :     zsum = (x[0][2]+x[1][2]+x[2][2]);

	fld	QWORD PTR _coe$[ebp]
	fld	QWORD PTR _zsum$[ebp]
$LN48@body_hessi:

; 333  :     {
; 334  :       int currentrow;
; 335  :       REAL g[MAXCOORD],gg[MAXCOORD],*ggg;
; 336  :       REAL grad[MAXCOORD];
; 337  :       int ii = (i+1)%3;

	mov	esi, DWORD PTR tv2838[ebp]
	lea	eax, DWORD PTR [esi-1]
	cdq
	mov	ecx, 3
	idiv	ecx

; 338  :       int iii = (i+2)%3;

	mov	eax, esi
	mov	esi, 3
	mov	ecx, edx
	cdq
	idiv	esi

; 339  : 
; 340  :       if ( web.symmetric_content )

	cmp	DWORD PTR _web+808, 0
	je	SHORT $LN45@body_hessi

; 341  :           cross_prod(x[ii],x[iii],g);

	mov	edx, DWORD PTR _x$89318[ebp+edx*4]
	fstp	ST(0)
	lea	eax, DWORD PTR _g$89363[ebp]
	fstp	ST(0)
	push	eax
	mov	eax, DWORD PTR _x$89318[ebp+ecx*4]
	push	edx
	push	eax
	call	_cross_prod

; 342  :       else

	fld	QWORD PTR _coe$[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN44@body_hessi
$LN45@body_hessi:

; 343  :       { g[0] = zsum*(x[ii][1]-x[iii][1]);

	mov	eax, DWORD PTR _x$89318[ebp+ecx*4]
	fld	QWORD PTR [eax+8]
	mov	ecx, DWORD PTR _x$89318[ebp+edx*4]
	fsub	QWORD PTR [ecx+8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _g$89363[ebp]

; 344  :         g[1] = zsum*(x[iii][0]-x[ii][0]);

	fld	QWORD PTR [ecx]
	fsub	QWORD PTR [eax]
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR _g$89363[ebp+8]

; 345  :         g[2] = ssum;

	fld	QWORD PTR _ssum$[ebp]
	fstp	QWORD PTR _g$89363[ebp+16]
$LN44@body_hessi:

; 346  :       }
; 347  : 
; 348  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN425@body_hessi
	fld	QWORD PTR __real@c018000000000000
$LN43@body_hessi:

; 349  :          grad[j] = -coe*g[j]/6;

	fld	QWORD PTR _g$89363[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(2)
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _grad$89366[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN43@body_hessi

; 346  :       }
; 347  : 
; 348  :       for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
$LN425@body_hessi:

; 350  :       fill_grad(S,v[i],grad,rhs);

	mov	edx, DWORD PTR _rhs$GSCopy$[ebp]
	fstp	ST(0)
	mov	ecx, DWORD PTR tv2873[ebp]
	mov	edi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	push	edx
	lea	eax, DWORD PTR _grad$89366[ebp]
	push	eax
	push	edi
	push	ecx
	call	_fill_grad
	add	esp, 16					; 00000010H

; 351  : 
; 352  :       if ( !hess_flag ) continue;

	cmp	DWORD PTR _hess_flag, 0
	je	$LN47@body_hessi

; 353  : 
; 354  :       if ( v[i]->proj )

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN39@body_hessi

; 355  :       { vec_mat_mul(g,v[i]->proj,gg,SDIM,v[i]->freedom);

	mov	edx, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR _web+616
	push	edx
	push	ecx
	lea	edx, DWORD PTR _gg$89364[ebp]
	push	edx
	push	eax
	lea	eax, DWORD PTR _g$89363[ebp]
	push	eax
	call	_vec_mat_mul

; 356  :         ggg = gg;

	lea	ecx, DWORD PTR _gg$89364[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ggg$89365[ebp], ecx
	jmp	SHORT $LN38@body_hessi
$LN39@body_hessi:

; 357  :       }
; 358  :       else ggg = g;

	lea	edx, DWORD PTR _g$89363[ebp]
	mov	DWORD PTR _ggg$89365[ebp], edx
$LN38@body_hessi:

; 359  : 
; 360  :       if ( do_b )

	cmp	DWORD PTR _do_b$89320[ebp], 0
	je	$LN34@body_hessi

; 361  :       {
; 362  :         currentrow = S->bodyrowstart + loc_ordinal(b_id);

	cmp	DWORD PTR tv1730[ebp], 0
	je	SHORT $LN96@body_hessi
	mov	eax, DWORD PTR _b_id$[ebp]
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN97@body_hessi
$LN96@body_hessi:
	or	eax, -1
$LN97@body_hessi:
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	mov	ebx, DWORD PTR [ecx+20]

; 363  :         for ( j = 0 ; j < v[i]->freedom ; j++ )

	xor	esi, esi
	add	ebx, eax
	cmp	DWORD PTR [edi+8], esi
	jle	SHORT $LN34@body_hessi

; 364  :         { sp_hash_search(S,v[i]->rownum+j,currentrow,ggg[j]/6);

	mov	edx, DWORD PTR tv2873[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv2908[ebp], eax
$LL36@body_hessi:
	mov	ecx, DWORD PTR _ggg$89365[ebp]
	fld	QWORD PTR [ecx+esi*8]
	mov	edx, DWORD PTR [edi+12]
	fdiv	QWORD PTR __real@4018000000000000
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	sub	esp, 8
	add	edx, esi
	fstp	QWORD PTR [esp]
	push	ebx
	push	edx
	push	eax
	call	_sp_hash_search
	mov	ecx, DWORD PTR tv2908[ebp]
	inc	esi
	add	esp, 20					; 00000014H
	cmp	esi, DWORD PTR [ecx+8]
	jl	SHORT $LL36@body_hessi
$LN34@body_hessi:

; 365  :         }
; 366  :       }
; 367  :          
; 368  :       if ( do_bb )

	cmp	DWORD PTR _do_bb$89321[ebp], 0
	je	$LN47@body_hessi

; 369  :       {
; 370  :         currentrow = S->bodyrowstart + loc_ordinal(bb_id);

	cmp	DWORD PTR tv1850[ebp], 0
	je	SHORT $LN98@body_hessi
	mov	eax, DWORD PTR _bb_id$89319[ebp]
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN99@body_hessi
$LN98@body_hessi:
	or	eax, -1
$LN99@body_hessi:
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	mov	ebx, DWORD PTR [edx+20]

; 371  :         for ( j = 0 ; j < v[i]->freedom ; j++ )

	xor	esi, esi
	add	ebx, eax
	cmp	DWORD PTR [edi+8], esi
	jle	SHORT $LN47@body_hessi

; 372  :         { sp_hash_search(S,v[i]->rownum+j,currentrow,-ggg[j]/6);

	mov	eax, DWORD PTR tv2873[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv2911[ebp], ecx
$LL32@body_hessi:
	mov	edx, DWORD PTR _ggg$89365[ebp]
	fld	QWORD PTR [edx+esi*8]
	mov	eax, DWORD PTR [edi+12]
	fdiv	QWORD PTR __real@c018000000000000
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	sub	esp, 8
	add	eax, esi
	fstp	QWORD PTR [esp]
	push	ebx
	push	eax
	push	ecx
	call	_sp_hash_search
	mov	edx, DWORD PTR tv2911[ebp]
	inc	esi
	add	esp, 20					; 00000014H
	cmp	esi, DWORD PTR [edx+8]
	jl	SHORT $LL32@body_hessi
$LN47@body_hessi:

; 331  : 
; 332  :     for ( i = 0 ; i < FACET_VERTS ; i++ )

	add	DWORD PTR tv2873[ebp], 4
	mov	eax, 1
	add	DWORD PTR tv2838[ebp], eax
	sub	DWORD PTR tv675[ebp], eax
	jne	$LL223@body_hessi
	mov	esi, DWORD PTR _web+236
	fldz
$LN63@body_hessi:

; 285  :     }
; 286  :   }
; 287  : 
; 288  :   /* body volume constraints, linear part */
; 289  :   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR tv1783[ebp]
	mov	ecx, DWORD PTR [eax+esi]
	mov	edi, DWORD PTR [ecx]
	mov	eax, edi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv1780[ebp], eax
	jne	$LN64@body_hessi
$LN62@body_hessi:

; 373  :         }
; 374  :       }
; 375  :     }
; 376  :   }
; 377  : 
; 378  :   /* Now quadratic part */
; 379  : 
; 380  :   otherD[0][0] = otherD[1][1] = otherD[2][2] = 0.0;

	mov	ebx, DWORD PTR _otherD$[ebp]
	mov	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+4]
	fst	QWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ebx]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [ecx]

; 381  :   self[0][0] = self[1][1] = self[2][2] = 0.0;

	mov	ecx, DWORD PTR _self$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ecx+4]
	fst	QWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [ecx]

; 382  :   self[0][1] = self[1][0] = 0.0;

	fst	QWORD PTR [eax]
	fst	QWORD PTR [ecx+8]

; 383  :   /* now add constraint hessians to energy hessian */
; 384  :   if ( hess_flag )

	cmp	DWORD PTR _hess_flag, 0
	je	$LN412@body_hessi

; 385  :   { FOR_ALL_FACETS(f_id)

	mov	edi, DWORD PTR _web+272
	mov	eax, edi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv1780[ebp], eax
	je	$LN412@body_hessi
	mov	edx, DWORD PTR _dymem
$LN28@body_hessi:
	mov	eax, DWORD PTR _web+236
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR tv1786[ebp], eax
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv1783[ebp], ecx
	je	$LN27@body_hessi

; 386  :      {
; 387  :         facetedge_id fe_id;         
; 388  :         struct hess_verlist *v[FACET_VERTS];
; 389  :         REAL *x[FACET_VERTS];  /* for volume calculation */
; 390  :         vertex_id v_id[FACET_VERTS];
; 391  : 
; 392  :         if ( get_attr(f_id) & NONCONTENT ) continue;

	mov	eax, edi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	eax, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	or	eax, esi
	jne	$LN27@body_hessi

; 393  : 
; 394  :         coe = 0.0;

	fld	ST(0)

; 395  :         b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, esi
	je	SHORT $LN150@body_hessi
$LN153@body_hessi:
	cmp	DWORD PTR tv1780[ebp], esi
	jne	SHORT $LN152@body_hessi
	xor	eax, eax
	jmp	SHORT $LN150@body_hessi
$LN152@body_hessi:
	mov	eax, DWORD PTR _web+328
	mov	esi, DWORD PTR tv1786[ebp]
	mov	eax, DWORD PTR [eax+edx+784]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN151@body_hessi
	mov	eax, DWORD PTR [eax+esi+4]
	jmp	SHORT $LN150@body_hessi
$LN151@body_hessi:
	mov	eax, DWORD PTR [esi+eax]
$LN150@body_hessi:

; 396  :         if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN22@body_hessi

; 397  :           coe += Z[loc_ordinal(b_id)];

	mov	esi, DWORD PTR _Z$[ebp]
	fstp	ST(0)
	and	eax, 134217727				; 07ffffffH
	fld	QWORD PTR [esi+eax*8]
	fadd	ST(0), ST(1)
$LN22@body_hessi:

; 398  :         b_id = get_facet_body(inverse_id(f_id));

	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN159@body_hessi
	xor	eax, eax
	jmp	SHORT $LN156@body_hessi
$LN159@body_hessi:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN158@body_hessi
	xor	eax, eax
	jmp	SHORT $LN156@body_hessi
$LN158@body_hessi:
	mov	esi, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN157@body_hessi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+328
	mov	esi, DWORD PTR [esi+edx+784]
	mov	eax, DWORD PTR [eax+esi+4]
	jmp	SHORT $LN156@body_hessi
$LN157@body_hessi:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+328
	mov	esi, DWORD PTR [esi+edx+784]
	mov	eax, DWORD PTR [eax+esi]
$LN156@body_hessi:

; 399  :         if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN21@body_hessi

; 400  :           coe -= Z[loc_ordinal(b_id)];

	mov	esi, DWORD PTR _Z$[ebp]
	and	eax, 134217727				; 07ffffffH
	fsub	QWORD PTR [esi+eax*8]
$LN21@body_hessi:

; 401  :         coe /= 6; /* tetrahedron factor */

	fdiv	QWORD PTR __real@4018000000000000
	fst	QWORD PTR _coe$[ebp]

; 402  :         if ( coe == 0.0 ) continue;

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN354@body_hessi

; 403  : 
; 404  :         fe_id = get_facet_fe(f_id);

	cmp	DWORD PTR tv1780[ebp], 0
	jne	SHORT $LN163@body_hessi
	xor	eax, eax
	jmp	SHORT $LN162@body_hessi
$LN163@body_hessi:
	mov	ecx, DWORD PTR tv1786[ebp]
	mov	eax, DWORD PTR [ecx+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN162@body_hessi
	xor	eax, 134217728				; 08000000H
$LN162@body_hessi:

; 405  :         for ( i = 0 ; i < FACET_EDGES ; i++ )
; 406  :         { v_id[i] = get_fe_tailv(fe_id);

	mov	esi, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR _web+124
	mov	DWORD PTR _fe_id$89399[ebp], eax
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR tv2130[ebp], ecx
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN169@body_hessi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN168@body_hessi
$LN169@body_hessi:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN168@body_hessi:

; 407  :           v[i] = get_vertex_vhead(v_id[i]);

	mov	esi, DWORD PTR _web+12
	mov	DWORD PTR _v_id$89402[ebp], eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _vhead_attr
	imul	esi, 240				; 000000f0H
	add	esi, DWORD PTR _web+104
	mov	esi, DWORD PTR [esi+edx+64]
	mov	edi, DWORD PTR [eax+esi]
	shl	edi, 5
	add	edi, DWORD PTR _vhead
	mov	DWORD PTR _v$89400[ebp], edi

; 408  :           x[i] = get_coord(v_id[i]);

	mov	edi, DWORD PTR _web+104
	mov	edx, DWORD PTR [edi+edx+64]
	add	eax, edx

; 409  :           fe_id = get_next_edge(fe_id);

	test	DWORD PTR _fe_id$89399[ebp], 134217728	; 08000000H
	mov	DWORD PTR tv2170[ebp], edx
	mov	DWORD PTR _x$89401[ebp], eax
	je	SHORT $LN173@body_hessi
	mov	edx, DWORD PTR tv2130[ebp]
	mov	edx, DWORD PTR [edx+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN18@body_hessi
$LN173@body_hessi:
	mov	eax, DWORD PTR tv2130[ebp]
	mov	edx, DWORD PTR [eax+32]
$LN18@body_hessi:

; 405  :         for ( i = 0 ; i < FACET_EDGES ; i++ )
; 406  :         { v_id[i] = get_fe_tailv(fe_id);

	mov	edi, DWORD PTR _web+460
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+eax*4]
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]
	mov	DWORD PTR tv2130[ebp], edi
	mov	edi, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN209@body_hessi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN210@body_hessi
$LN209@body_hessi:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN210@body_hessi:

; 407  :           v[i] = get_vertex_vhead(v_id[i]);

	mov	edi, DWORD PTR _web+12
	mov	DWORD PTR _v_id$89402[ebp+4], eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [eax+esi]

; 408  :           x[i] = get_coord(v_id[i]);

	add	eax, DWORD PTR tv2170[ebp]
	shl	edi, 5
	add	edi, DWORD PTR _vhead
	mov	DWORD PTR _x$89401[ebp+4], eax
	mov	DWORD PTR _v$89400[ebp+4], edi

; 409  :           fe_id = get_next_edge(fe_id);

	test	edx, 134217728				; 08000000H
	je	SHORT $LN211@body_hessi
	mov	edx, DWORD PTR tv2130[ebp]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN212@body_hessi
$LN211@body_hessi:
	mov	eax, DWORD PTR tv2130[ebp]
	mov	eax, DWORD PTR [eax+32]
$LN212@body_hessi:

; 405  :         for ( i = 0 ; i < FACET_EDGES ; i++ )
; 406  :         { v_id[i] = get_fe_tailv(fe_id);

	mov	edi, DWORD PTR _web+460
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN214@body_hessi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN215@body_hessi
$LN214@body_hessi:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN215@body_hessi:

; 407  :           v[i] = get_vertex_vhead(v_id[i]);

	mov	ecx, DWORD PTR _web+12
	mov	DWORD PTR _v_id$89402[ebp+8], eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [eax+esi]

; 410  :         }
; 411  :         zsum = x[0][2] + x[1][2] + x[2][2];

	mov	ecx, DWORD PTR _x$89401[ebp]
	add	eax, DWORD PTR tv2170[ebp]
	shl	edx, 5
	add	edx, DWORD PTR _vhead

; 412  : 
; 413  :         /* second derivatives */
; 414  :         if ( hess_flag )

	cmp	DWORD PTR _hess_flag, 0
	mov	DWORD PTR _v$89400[ebp+8], edx
	mov	edx, DWORD PTR _x$89401[ebp+4]
	fld	QWORD PTR [edx+16]
	mov	DWORD PTR _x$89401[ebp+8], eax
	fadd	QWORD PTR [ecx+16]
	fadd	QWORD PTR [eax+16]
	fstp	QWORD PTR _zsum$[ebp]
	je	$LN381@body_hessi

; 415  :          for ( i = 0 ; i < FACET_EDGES ; i++ )

	mov	ecx, 2
	mov	DWORD PTR tv2930[ebp], ecx
	xor	esi, esi
	mov	DWORD PTR tv642[ebp], 3
$LN228@body_hessi:

; 416  :           { int ii,jj;
; 417  : 
; 418  :              jj = (i+1)%FACET_EDGES;  /* next vertex */

	lea	eax, DWORD PTR [ecx-1]
	cdq
	mov	edi, 3
	idiv	edi

; 419  :              ii = (i+2)%FACET_EDGES;  /* vertex previous vertex i */

	mov	eax, ecx
	mov	ecx, 3
	mov	edi, edx
	cdq
	idiv	ecx
	mov	DWORD PTR _jj$89432[ebp], edi
	mov	DWORD PTR _ii$89431[ebp], edx

; 420  : 
; 421  :              if ( v[i]->freedom <= 0 ) continue;

	mov	edx, DWORD PTR _v$89400[ebp+esi]
	cmp	DWORD PTR [edx+8], 0
	jle	$LN14@body_hessi

; 422  :              if ( !web.symmetric_content )

	cmp	DWORD PTR _web+808, 0
	jne	$LN11@body_hessi

; 423  :              {
; 424  :                 self[0][2] = self[2][0] = coe*(x[jj][1]-x[ii][1]);

	mov	ecx, DWORD PTR _x$89401[ebp+edi*4]

; 425  :                 self[1][2] = self[2][1] = coe*(x[ii][0]-x[jj][0]);
; 426  :                 fill_self_entry(S,v_id[i],self); 

	fstp	ST(1)
	fld	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR _ii$89431[ebp]
	mov	eax, DWORD PTR _x$89401[ebp+eax*4]
	fsub	QWORD PTR [eax+8]
	mov	DWORD PTR tv2248[ebp], eax
	mov	eax, DWORD PTR _self$[ebp]
	mov	edx, DWORD PTR [eax+8]
	fmul	ST(0), ST(1)
	push	eax
	fst	QWORD PTR [edx]
	mov	edx, DWORD PTR [eax]
	fstp	QWORD PTR [edx+16]
	mov	edx, DWORD PTR tv2248[ebp]
	fld	QWORD PTR [edx]
	mov	edx, DWORD PTR _v_id$89402[ebp+esi]
	fsub	QWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+8]
	push	edx
	fmulp	ST(1), ST(0)
	fst	QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	fstp	QWORD PTR [ecx+16]
	push	eax
	call	_fill_self_entry
	fldz
	fld	QWORD PTR _coe$[ebp]
	add	esp, 12					; 0000000cH
$LN11@body_hessi:

; 427  :              }
; 428  :              if ( v[jj]->freedom <= 0 ) continue;

	mov	ecx, DWORD PTR _v$89400[ebp+edi*4]
	cmp	DWORD PTR [ecx+8], 0
	jle	$LN14@body_hessi

; 429  : 
; 430  :              /* for now, all degrees of freedom are coordinate */
; 431  :              if ( web.symmetric_content )

	cmp	DWORD PTR _web+808, 0
	fstp	ST(1)

; 432  :              { otherD[0][1] = -coe*x[ii][2];

	mov	ecx, DWORD PTR [ebx]
	je	SHORT $LN9@body_hessi
	mov	edx, DWORD PTR _ii$89431[ebp]
	mov	eax, DWORD PTR _x$89401[ebp+edx*4]
	fld	QWORD PTR [eax+16]

; 433  :                otherD[1][0] =  coe*x[ii][2];

	mov	edx, DWORD PTR [ebx+4]
	fmul	ST(0), ST(1)
	fchs
	fstp	QWORD PTR [ecx+8]
	fld	QWORD PTR [eax+16]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx]

; 434  :                otherD[0][2] =  coe*x[ii][1];

	fld	QWORD PTR [eax+8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [ecx+16]

; 435  :                otherD[2][0] = -coe*x[ii][1];

	mov	ecx, DWORD PTR [ebx+8]
	fld	QWORD PTR [eax+8]
	fmul	ST(0), ST(1)
	fchs
	fstp	QWORD PTR [ecx]

; 436  :                otherD[2][1] =  coe*x[ii][0];

	fld	ST(0)
	fmul	QWORD PTR [eax]
	fstp	QWORD PTR [ecx+8]

; 437  :                otherD[1][2] = -coe*x[ii][0];

	fmul	QWORD PTR [eax]
	fchs
	fstp	QWORD PTR [edx+16]

; 438  :              } 
; 439  :              else

	jmp	$LN8@body_hessi
$LN9@body_hessi:

; 440  :              { otherD[0][1] = -coe*zsum;

	fld	QWORD PTR _zsum$[ebp]

; 441  :                otherD[1][0] =  coe*zsum;

	mov	edx, DWORD PTR [ebx+4]

; 442  :                otherD[0][2] = -coe*(x[jj][1]-x[ii][1]);

	mov	edi, DWORD PTR _x$89401[ebp+edi*4]
	fmul	ST(0), ST(1)
	mov	eax, DWORD PTR _ii$89431[ebp]
	mov	eax, DWORD PTR _x$89401[ebp+eax*4]
	fld	ST(0)

; 443  :                otherD[2][0] = -coe*(x[ii][1]-x[i ][1]);

	mov	ebx, DWORD PTR [ebx+8]
	fchs
	fstp	QWORD PTR [ecx+8]
	fstp	QWORD PTR [edx]
	fld	QWORD PTR [edi+8]
	fsub	QWORD PTR [eax+8]
	fmul	ST(0), ST(1)
	fchs
	fstp	QWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _x$89401[ebp+esi]
	fld	QWORD PTR [eax+8]
	fsub	QWORD PTR [ecx+8]
	fmul	ST(0), ST(1)
	fchs
	fstp	QWORD PTR [ebx]

; 444  :                otherD[1][2] = -coe*(x[ii][0]-x[jj][0]);

	fld	QWORD PTR [eax]
	fsub	QWORD PTR [edi]

; 445  :                otherD[2][1] = -coe*(x[i ][0]-x[ii][0]);

	mov	edi, DWORD PTR _jj$89432[ebp]
	fmul	ST(0), ST(1)
	fchs
	fstp	QWORD PTR [edx+16]
	fld	QWORD PTR [ecx]
	fsub	QWORD PTR [eax]
	fmulp	ST(1), ST(0)
	fchs
	fstp	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR _otherD$[ebp]
$LN8@body_hessi:

; 446  :              }
; 447  :              fill_mixed_entry(S,v_id[i],v_id[jj],otherD); 

	mov	ecx, DWORD PTR _v_id$89402[ebp+edi*4]
	mov	edx, DWORD PTR _v_id$89402[ebp+esi]
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	push	ebx
	push	ecx
	push	edx
	push	eax
	call	_fill_mixed_entry
	fldz
	fld	QWORD PTR _coe$[ebp]
	add	esp, 16					; 00000010H
$LN14@body_hessi:

; 415  :          for ( i = 0 ; i < FACET_EDGES ; i++ )

	mov	ecx, DWORD PTR tv2930[ebp]
	inc	ecx
	add	esi, 4
	dec	DWORD PTR tv642[ebp]
	mov	DWORD PTR tv2930[ebp], ecx
	jne	$LN228@body_hessi
$LN381@body_hessi:
	mov	ecx, DWORD PTR tv1783[ebp]
	mov	edx, DWORD PTR _dymem
$LN354@body_hessi:

; 402  :         if ( coe == 0.0 ) continue;

	fstp	ST(0)
$LN27@body_hessi:

; 385  :   { FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edi, DWORD PTR [ecx]
	mov	eax, edi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv1780[ebp], eax
	jne	$LN28@body_hessi
$LN412@body_hessi:

; 448  :           }
; 449  :       }
; 450  :   }
; 451  :   temp_free((char*)Z);

	mov	edx, DWORD PTR _Z$[ebp]
	fstp	ST(0)
	push	edx
	call	_temp_free

; 452  : 
; 453  :   count = 0;

	xor	eax, eax
	add	esp, 4

; 454  :   if ( !everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, eax
	jne	SHORT $LN4@body_hessi

; 455  :   { FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR _web+384
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN4@body_hessi
	mov	ebx, DWORD PTR _web+348
$LL6@body_hessi:
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR tv1739[ebp+4], ecx
	mov	ecx, edx
	and	ecx, 1
	xor	edi, edi
	or	ecx, edi
	je	SHORT $LN5@body_hessi

; 456  :     { if ( get_battr(b_id) & FIXEDVOL )

	and	edx, 32					; 00000020H
	xor	ecx, ecx
	or	edx, ecx
	je	SHORT $LN5@body_hessi

; 457  :           count++;

	inc	eax
$LN5@body_hessi:

; 455  :   { FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR [esi]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL6@body_hessi
$LN4@body_hessi:

; 458  :     }
; 459  :   }
; 460  :   return count;
; 461  : } /* end body_hessian() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_body_hessian ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@BAIBBGCA@Internal?5error?3?5Mysterious?5value@ ; `string'
PUBLIC	??_C@_0DE@KBDFAOLA@Internal?5error?3?5Illegal?5path?5spe@ ; `string'
PUBLIC	??_C@_0CO@KAIJGMFJ@Internal?5error?3?5Insufficient?5sto@ ; `string'
PUBLIC	??_C@_0DE@MIBKOCKL@Internal?5error?3?5Insufficient?5sto@ ; `string'
PUBLIC	??_C@_0DC@BLIIHFAP@Internal?5error?5after?5ODRV?3?5?5N?5?$DN?5@ ; `string'
PUBLIC	_odrv_flag_check
EXTRN	_kb_error:PROC
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
;	COMDAT ??_C@_0DG@BAIBBGCA@Internal?5error?3?5Mysterious?5value@
CONST	SEGMENT
??_C@_0DG@BAIBBGCA@Internal?5error?3?5Mysterious?5value@ DB 'Internal err'
	DB	'or: Mysterious value of FLAG in ORDV: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KBDFAOLA@Internal?5error?3?5Illegal?5path?5spe@
CONST	SEGMENT
??_C@_0DE@KBDFAOLA@Internal?5error?3?5Illegal?5path?5spe@ DB 'Internal er'
	DB	'ror: Illegal path specification in ORDV', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KAIJGMFJ@Internal?5error?3?5Insufficient?5sto@
CONST	SEGMENT
??_C@_0CO@KAIJGMFJ@Internal?5error?3?5Insufficient?5sto@ DB 'Internal err'
	DB	'or: Insufficient storage in ODRV', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@MIBKOCKL@Internal?5error?3?5Insufficient?5sto@
CONST	SEGMENT
??_C@_0DE@MIBKOCKL@Internal?5error?3?5Insufficient?5sto@ DB 'Internal err'
	DB	'or: Insufficient storage in MD, K = %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BLIIHFAP@Internal?5error?5after?5ODRV?3?5?5N?5?$DN?5@
CONST	SEGMENT
??_C@_0DC@BLIIHFAP@Internal?5error?5after?5ODRV?3?5?5N?5?$DN?5@ DB 'Inter'
	DB	'nal error after ODRV:  N = %d  FLAG = %d -- ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _odrv_flag_check
_TEXT	SEGMENT
_FLAG$ = 8						; size = 4
_N$ = 12						; size = 4
_odrv_flag_check PROC					; COMDAT

; 620  : {

	push	ebp
	mov	ebp, esp
	push	edi

; 621  :   if (!FLAG) return;

	mov	edi, DWORD PTR _FLAG$[ebp]
	test	edi, edi
	je	$LN8@odrv_flag_

; 622  : 
; 623  :   /*  Fatal error */
; 624  :   sprintf(errmsg,"Internal error after ODRV:  N = %d  FLAG = %d -- ",N,FLAG);

	push	esi
	mov	esi, DWORD PTR _N$[ebp]
	push	edi
	push	esi
	push	OFFSET ??_C@_0DC@BLIIHFAP@Internal?5error?5after?5ODRV?3?5?5N?5?$DN?5@
	push	OFFSET _errmsg
	call	_sprintf

; 625  :   if ( 9*N<FLAG && FLAG<=10*N )

	lea	edx, DWORD PTR [esi+esi*8]
	add	esp, 16					; 00000010H
	cmp	edx, edi
	jge	SHORT $LN6@odrv_flag_
	lea	eax, DWORD PTR [esi+esi*4]
	add	eax, eax
	cmp	edi, eax
	jg	SHORT $LN6@odrv_flag_

; 626  :     sprintf(errmsg+strlen(errmsg),"Internal error: Insufficient storage in MD, K = %d\n",FLAG-9*N);

	mov	eax, OFFSET _errmsg
	lea	esi, DWORD PTR [eax+1]
	npad	1
$LL10@odrv_flag_:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL10@odrv_flag_
	sub	eax, esi
	sub	edi, edx
	push	edi
	push	OFFSET ??_C@_0DE@MIBKOCKL@Internal?5error?3?5Insufficient?5sto@
	lea	ecx, DWORD PTR _errmsg[eax]
	push	ecx
	jmp	SHORT $LN13@odrv_flag_
$LN6@odrv_flag_:

; 627  :   else if ( FLAG == 10*N + 1 )

	lea	edx, DWORD PTR [esi+esi*4]
	lea	eax, DWORD PTR [edx+edx+1]
	cmp	edi, eax
	jne	SHORT $LN4@odrv_flag_

; 628  :     strcat(errmsg,"Internal error: Insufficient storage in ODRV\n");

	mov	edi, OFFSET _errmsg
	dec	edi
	npad	5
$LL11@odrv_flag_:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL11@odrv_flag_
	mov	ecx, 11					; 0000000bH
	mov	esi, OFFSET ??_C@_0CO@KAIJGMFJ@Internal?5error?3?5Insufficient?5sto@
	rep movsd
	movsw
	jmp	SHORT $LN1@odrv_flag_
$LN4@odrv_flag_:

; 629  :   else if ( FLAG == 11*N + 1 )

	imul	esi, 11					; 0000000bH
	inc	esi
	cmp	edi, esi
	jne	SHORT $LN2@odrv_flag_

; 630  :     strcat(errmsg,"Internal error: Illegal path specification in ORDV\n");

	mov	edi, OFFSET _errmsg
	dec	edi
$LL12@odrv_flag_:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL12@odrv_flag_
	mov	ecx, 13					; 0000000dH
	mov	esi, OFFSET ??_C@_0DE@KBDFAOLA@Internal?5error?3?5Illegal?5path?5spe@
	rep movsd

; 631  :   else

	jmp	SHORT $LN1@odrv_flag_
$LN2@odrv_flag_:

; 632  :     sprintf(errmsg,"Internal error: Mysterious value of FLAG in ORDV: %d\n",FLAG);

	push	edi
	push	OFFSET ??_C@_0DG@BAIBBGCA@Internal?5error?3?5Mysterious?5value@
	push	OFFSET _errmsg
$LN13@odrv_flag_:
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1@odrv_flag_:

; 633  :   kb_error(1845,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1845					; 00000735H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	esi
$LN8@odrv_flag_:
	pop	edi

; 634  : } // end odrv_flag_check()

	pop	ebp
	ret	0
_odrv_flag_check ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@OJKHOOIO@Internal?5error?0?5SDRV?3?5Mysterious@ ; `string'
PUBLIC	??_C@_0DC@FNGNKEOM@Internal?5error?0?5SDRV?3?5Illegal?5pa@ ; `string'
PUBLIC	??_C@_0DE@FPKCHHAG@Internal?5error?0?5SDRV?3?5Insufficie@ ; `string'
PUBLIC	??_C@_0CM@JKNNJIKB@Internal?5error?0?5SDRV?3?5Zero?5pivot@ ; `string'
PUBLIC	??_C@_0DD@CFLGBOLH@Internal?5error?0?5SDRV?3?5Insufficie@ ; `string'
PUBLIC	??_C@_0DN@CMMDDNEJ@Internal?5error?0?5SDRV?3?5Insufficie@ ; `string'
PUBLIC	??_C@_0DG@BBIFJEMB@Internal?5error?0?5SDRV?3?5Duplicate?5@ ; `string'
PUBLIC	??_C@_0DF@FLHDDHNL@Internal?5error?3?5after?5SDRVMD?3?5?5N@ ; `string'
PUBLIC	??_C@_0CI@LIHHEPJH@SDRVMD?3?5Hessian?5not?5positive?5def@ ; `string'
PUBLIC	??_C@_0DH@EBCIHGAK@Internal?5error?3?5?5SDRVMD?3?5?5Storag@ ; `string'
PUBLIC	_sdrv_flag_check
EXTRN	_negdiag:DWORD
EXTRN	_hessian_quiet_flag:DWORD
EXTRN	_pos_def_warning_flag:DWORD
;	COMDAT ??_C@_0DE@OJKHOOIO@Internal?5error?0?5SDRV?3?5Mysterious@
CONST	SEGMENT
??_C@_0DE@OJKHOOIO@Internal?5error?0?5SDRV?3?5Mysterious@ DB 'Internal er'
	DB	'ror, SDRV: Mysterious value of FLAG: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FNGNKEOM@Internal?5error?0?5SDRV?3?5Illegal?5pa@
CONST	SEGMENT
??_C@_0DC@FNGNKEOM@Internal?5error?0?5SDRV?3?5Illegal?5pa@ DB 'Internal e'
	DB	'rror, SDRV: Illegal path specification', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FPKCHHAG@Internal?5error?0?5SDRV?3?5Insufficie@
CONST	SEGMENT
??_C@_0DE@FPKCHHAG@Internal?5error?0?5SDRV?3?5Insufficie@ DB 'Internal er'
	DB	'ror, SDRV: Insufficient storage in SDRV', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@JKNNJIKB@Internal?5error?0?5SDRV?3?5Zero?5pivot@
CONST	SEGMENT
??_C@_0CM@JKNNJIKB@Internal?5error?0?5SDRV?3?5Zero?5pivot@ DB 'Internal e'
	DB	'rror, SDRV: Zero pivot at row %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@CFLGBOLH@Internal?5error?0?5SDRV?3?5Insufficie@
CONST	SEGMENT
??_C@_0DD@CFLGBOLH@Internal?5error?0?5SDRV?3?5Insufficie@ DB 'Internal er'
	DB	'ror, SDRV: Insufficient storage in SNF', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@CMMDDNEJ@Internal?5error?0?5SDRV?3?5Insufficie@
CONST	SEGMENT
??_C@_0DN@CMMDDNEJ@Internal?5error?0?5SDRV?3?5Insufficie@ DB 'Internal er'
	DB	'ror, SDRV: Insufficient storage in SSF at row %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@BBIFJEMB@Internal?5error?0?5SDRV?3?5Duplicate?5@
CONST	SEGMENT
??_C@_0DG@BBIFJEMB@Internal?5error?0?5SDRV?3?5Duplicate?5@ DB 'Internal e'
	DB	'rror, SDRV: Duplicate entry in A at row %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FLHDDHNL@Internal?5error?3?5after?5SDRVMD?3?5?5N@
CONST	SEGMENT
??_C@_0DF@FLHDDHNL@Internal?5error?3?5after?5SDRVMD?3?5?5N@ DB 'Internal '
	DB	'error: after SDRVMD:  N = %d  FLAG = %d -- ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LIHHEPJH@SDRVMD?3?5Hessian?5not?5positive?5def@
CONST	SEGMENT
??_C@_0CI@LIHHEPJH@SDRVMD?3?5Hessian?5not?5positive?5def@ DB 'SDRVMD: Hes'
	DB	'sian not positive definite.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EBCIHGAK@Internal?5error?3?5?5SDRVMD?3?5?5Storag@
CONST	SEGMENT
??_C@_0DH@EBCIHGAK@Internal?5error?3?5?5SDRVMD?3?5?5Storag@ DB 'Internal '
	DB	'error:  SDRVMD:  Storage shortage:  ESP = %d', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _sdrv_flag_check
_TEXT	SEGMENT
_ESP$ = 8						; size = 4
_FLAG$ = 12						; size = 4
_N$ = 16						; size = 4
_sdrv_flag_check PROC					; COMDAT

; 649  : { char *c;

	push	ebp
	mov	ebp, esp

; 650  : 
; 651  :   if (ESP<0)

	mov	eax, DWORD PTR _ESP$[ebp]
	test	eax, eax
	jns	SHORT $LN16@sdrv_flag_

; 652  :   { sprintf(errmsg,"Internal error:  SDRVMD:  Storage shortage:  ESP = %d\n",ESP);

	push	eax
	push	OFFSET ??_C@_0DH@EBCIHGAK@Internal?5error?3?5?5SDRVMD?3?5?5Storag@
	push	OFFSET _errmsg
	call	_sprintf

; 653  :      kb_error(1846,errmsg,RECOVERABLE); 

	push	1
	push	OFFSET _errmsg
	push	1846					; 00000736H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN16@sdrv_flag_:

; 654  : 
; 655  :   }
; 656  :   if (FLAG==0) return;

	push	esi
	mov	esi, DWORD PTR _FLAG$[ebp]
	test	esi, esi
	je	$LN17@sdrv_flag_

; 657  :   if (FLAG<0)

	jns	SHORT $LN14@sdrv_flag_

; 658  :   { if ( !pos_def_warning_flag && !hessian_quiet_flag )

	cmp	DWORD PTR _pos_def_warning_flag, 0
	jne	SHORT $LN13@sdrv_flag_
	cmp	DWORD PTR _hessian_quiet_flag, 0
	jne	SHORT $LN13@sdrv_flag_

; 659  :       { kb_error(1847,"SDRVMD: Hessian not positive definite.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CI@LIHHEPJH@SDRVMD?3?5Hessian?5not?5positive?5def@
	push	1847					; 00000737H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 660  :          pos_def_warning_flag = 1;

	mov	DWORD PTR _pos_def_warning_flag, 1
$LN13@sdrv_flag_:

; 661  :       }
; 662  :      negdiag = -FLAG-1; 

	or	eax, -1
	sub	eax, esi
	mov	DWORD PTR _negdiag, eax
	pop	esi

; 683  : } /* end sdrv_flag_check() */

	pop	ebp
	ret	0
$LN14@sdrv_flag_:
	push	edi

; 663  :      return;
; 664  :   }
; 665  : 
; 666  :   /*  Fatal error:  print message and abort */
; 667  :   sprintf(errmsg,"Internal error: after SDRVMD:  N = %d  FLAG = %d -- ",N,FLAG);

	mov	edi, DWORD PTR _N$[ebp]
	push	esi
	push	edi
	push	OFFSET ??_C@_0DF@FLHDDHNL@Internal?5error?3?5after?5SDRVMD?3?5?5N@
	push	OFFSET _errmsg
	call	_sprintf

; 668  :   c = errmsg + strlen(errmsg);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL19@sdrv_flag_:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL19@sdrv_flag_
	sub	eax, edx
	lea	ecx, DWORD PTR _errmsg[eax]

; 669  :   if ( 2*N < FLAG && FLAG <= 3*N )

	lea	eax, DWORD PTR [edi+edi]
	cmp	eax, esi
	jge	SHORT $LN12@sdrv_flag_
	lea	edx, DWORD PTR [edi+edi*2]
	cmp	esi, edx
	jg	SHORT $LN12@sdrv_flag_

; 670  :     sprintf(c,"Internal error, SDRV: Duplicate entry in A at row %d\n",FLAG-2*N);

	sub	esi, eax
	push	esi
	push	OFFSET ??_C@_0DG@BBIFJEMB@Internal?5error?0?5SDRV?3?5Duplicate?5@
	push	ecx
	call	_sprintf
	jmp	$LN20@sdrv_flag_
$LN12@sdrv_flag_:

; 671  :   else if ( 6*N < FLAG && FLAG <= 7*N )

	lea	eax, DWORD PTR [edi+edi*2]
	add	eax, eax
	cmp	eax, esi
	jge	SHORT $LN10@sdrv_flag_
	lea	edx, DWORD PTR [edi*8]
	sub	edx, edi
	cmp	esi, edx
	jg	SHORT $LN10@sdrv_flag_

; 672  :     sprintf(c,"Internal error, SDRV: Insufficient storage in SSF at row %d\n",FLAG-6*N);

	sub	esi, eax
	push	esi
	push	OFFSET ??_C@_0DN@CMMDDNEJ@Internal?5error?0?5SDRV?3?5Insufficie@
	push	ecx
	call	_sprintf
	jmp	SHORT $LN20@sdrv_flag_
$LN10@sdrv_flag_:

; 673  :   else if ( FLAG == 7*N + 1 )

	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	inc	eax
	cmp	esi, eax
	jne	SHORT $LN8@sdrv_flag_

; 674  :     sprintf(c,"Internal error, SDRV: Insufficient storage in SNF\n");

	push	OFFSET ??_C@_0DD@CFLGBOLH@Internal?5error?0?5SDRV?3?5Insufficie@
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	SHORT $LN1@sdrv_flag_
$LN8@sdrv_flag_:

; 675  :   else if ( 8*N < FLAG && FLAG <= 9*N )

	lea	eax, DWORD PTR [edi*8]
	cmp	eax, esi
	jge	SHORT $LN6@sdrv_flag_
	lea	edx, DWORD PTR [edi+edi*8]
	cmp	esi, edx
	jg	SHORT $LN6@sdrv_flag_

; 676  :     sprintf(c,"Internal error, SDRV: Zero pivot at row %d\n",FLAG-8*N);

	sub	esi, eax
	push	esi
	push	OFFSET ??_C@_0CM@JKNNJIKB@Internal?5error?0?5SDRV?3?5Zero?5pivot@
	push	ecx
	call	_sprintf
	jmp	SHORT $LN20@sdrv_flag_
$LN6@sdrv_flag_:

; 677  :   else if ( FLAG == 10*N + 1 )

	lea	eax, DWORD PTR [edi+edi*4]
	lea	edx, DWORD PTR [eax+eax+1]
	cmp	esi, edx
	jne	SHORT $LN4@sdrv_flag_

; 678  :     sprintf(c,"Internal error, SDRV: Insufficient storage in SDRV\n");

	push	OFFSET ??_C@_0DE@FPKCHHAG@Internal?5error?0?5SDRV?3?5Insufficie@
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	SHORT $LN1@sdrv_flag_
$LN4@sdrv_flag_:

; 679  :   else if ( FLAG == 11*N + 1 )

	imul	edi, 11					; 0000000bH
	inc	edi
	cmp	esi, edi
	jne	SHORT $LN2@sdrv_flag_

; 680  :     sprintf(c,"Internal error, SDRV: Illegal path specification\n");

	push	OFFSET ??_C@_0DC@FNGNKEOM@Internal?5error?0?5SDRV?3?5Illegal?5pa@
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	SHORT $LN1@sdrv_flag_
$LN2@sdrv_flag_:

; 681  :   else printf(c,"Internal error, SDRV: Mysterious value of FLAG: %d\n",FLAG);

	push	esi
	push	OFFSET ??_C@_0DE@OJKHOOIO@Internal?5error?0?5SDRV?3?5Mysterious@
	push	ecx
	call	_printf
$LN20@sdrv_flag_:
	add	esp, 12					; 0000000cH
$LN1@sdrv_flag_:

; 682  :   kb_error(1848,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1848					; 00000738H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
$LN17@sdrv_flag_:
	pop	esi

; 683  : } /* end sdrv_flag_check() */

	pop	ebp
	ret	0
_sdrv_flag_check ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@BLKAPKBA@Internal?5error?3?5Empty?5spot?5in?5Me@ ; `string'
PUBLIC	??_C@_0DL@DKAEFLCJ@Internal?5error?3?5Bad?5j?5in?5linear_@ ; `string'
PUBLIC	??_C@_0P@EGKIEAM@Bad?5col?5?$DM?5row?6?$AA@	; `string'
PUBLIC	__real@4028000000000000
PUBLIC	??_C@_0CI@IIDDMHOH@Internal?5error?5in?5linear_metric_@ ; `string'
PUBLIC	__real@3fd0000000000000
PUBLIC	??_C@_0EC@DHHMKCIK@Using?5alternate?5minimal?5degree?5w@ ; `string'
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_linear_metric_setup_quadratic
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
EXTRN	_gpoly:DWORD
EXTRN	_gauss2Dwt:DWORD
EXTRN	_mat_mult:PROC
EXTRN	_gpolypartial:DWORD
EXTRN	_gauss2D_num:DWORD
EXTRN	_get_facet_verts:PROC
EXTRN	_recalc_facet_area:PROC
EXTRN	_identmat:DWORD
EXTRN	_tr_mat_mul:PROC
EXTRN	_quadratic_metric_mix:QWORD
EXTRN	_gauss1poly:DWORD
EXTRN	_gauss1polyd:DWORD
EXTRN	_edge_ctrl:DWORD
EXTRN	_get_edge_length:PROC
EXTRN	_get_edge_verts:PROC
EXTRN	_optparamcount:DWORD
EXTRN	_outstring:PROC
EXTRN	_sp_CHinvC:PROC
EXTRN	_sp_CHinvC_func:DWORD
EXTRN	_sp_ordering_func:DWORD
EXTRN	_xmd_solve_multi:PROC
EXTRN	_sp_solve_multi_func:DWORD
EXTRN	_xmd_solve:PROC
EXTRN	_sp_solve_func:DWORD
EXTRN	_xmd_factor:PROC
EXTRN	_sp_factor_func:DWORD
EXTRN	_BK_hess_project_setup:PROC
EXTRN	_sp_hess_project_setup_func:DWORD
EXTRN	_bk_constraint_setup:PROC
EXTRN	_sp_constraint_setup_func:DWORD
EXTRN	_bk_AIJ_setup:PROC
EXTRN	_sp_AIJ_setup_func:DWORD
EXTRN	_bk_mul:PROC
EXTRN	_sp_mul_func:DWORD
EXTRN	_ysmp_flag:DWORD
;	COMDAT ??_C@_0CE@BLKAPKBA@Internal?5error?3?5Empty?5spot?5in?5Me@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CE@BLKAPKBA@Internal?5error?3?5Empty?5spot?5in?5Me@ DB 'Internal e'
	DB	'rror: Empty spot in Met.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@DKAEFLCJ@Internal?5error?3?5Bad?5j?5in?5linear_@
CONST	SEGMENT
??_C@_0DL@DKAEFLCJ@Internal?5error?3?5Bad?5j?5in?5linear_@ DB 'Internal e'
	DB	'rror: Bad j in linear_metric_setup_quadratic().', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EGKIEAM@Bad?5col?5?$DM?5row?6?$AA@
CONST	SEGMENT
??_C@_0P@EGKIEAM@Bad?5col?5?$DM?5row?6?$AA@ DB 'Bad col < row', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4028000000000000
CONST	SEGMENT
__real@4028000000000000 DQ 04028000000000000r	; 12
CONST	ENDS
;	COMDAT ??_C@_0CI@IIDDMHOH@Internal?5error?5in?5linear_metric_@
CONST	SEGMENT
??_C@_0CI@IIDDMHOH@Internal?5error?5in?5linear_metric_@ DB 'Internal erro'
	DB	'r in linear_metric_setup.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT ??_C@_0EC@DHHMKCIK@Using?5alternate?5minimal?5degree?5w@
CONST	SEGMENT
??_C@_0EC@DHHMKCIK@Using?5alternate?5minimal?5degree?5w@ DB 'Using altern'
	DB	'ate minimal degree with linear interpolation metric.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\hessian3.c
CONST	ENDS
;	COMDAT _linear_metric_setup_quadratic
_TEXT	SEGMENT
_temp_matqXvS$ = -1236					; size = 24
_weightsqXvS$ = -1212					; size = 24
_col$ = -1188						; size = 4
_vh$90448 = -1184					; size = 24
_xqXvS$90515 = -1172					; size = 12
_vh$90415 = -1172					; size = 12
_tangqXvS$90616 = -1168					; size = 8
_st$90666 = -1160					; size = 8
tv10739 = -1156						; size = 4
tv9855 = -1156						; size = 4
tv6885 = -1156						; size = 4
_S$GSCopy$ = -1156					; size = 4
_density$90634 = -1152					; size = 8
_len$ = -1152						; size = 8
tv11368 = -1148						; size = 4
tv11356 = -1148						; size = 4
tv11328 = -1148						; size = 4
tv11251 = -1148						; size = 4
tv10845 = -1148						; size = 4
_temp_mat$ = -1144					; size = 4
tv11445 = -1140						; size = 4
tv8723 = -1140						; size = 4
_tang$90618 = -1140					; size = 4
_vvh$90590 = -1140					; size = 4
_ss$90665 = -1136					; size = 8
tv11456 = -1132						; size = 4
tv10657 = -1132						; size = 4
tv10278 = -1132						; size = 4
tv9937 = -1132						; size = 4
tv9572 = -1132						; size = 4
tv5221 = -1132						; size = 4
tv4746 = -1132						; size = 4
tv1559 = -1132						; size = 4
_area$90615 = -1128					; size = 8
tv11458 = -1124						; size = 4
tv10697 = -1124						; size = 4
tv10511 = -1124						; size = 4
tv5806 = -1124						; size = 4
$T91833 = -1124						; size = 4
_end$ = -1124						; size = 4
_m$ = -1124						; size = 4
_fe_id$90449 = -1124					; size = 4
_f_id$ = -1124						; size = 4
tv9833 = -1120						; size = 4
tv6607 = -1120						; size = 4
_v$90684 = -1120					; size = 4
_a_from_spot$90742 = -1116				; size = 4
_weights$ = -1116					; size = 4
tv8720 = -1112						; size = 4
tv5919 = -1112						; size = 4
_ja_from_spot$90740 = -1112				; size = 4
_x$90517 = -1112					; size = 4
_jj$ = -1108						; size = 4
tv10794 = -1104						; size = 4
tv9746 = -1104						; size = 4
tv9629 = -1104						; size = 4
tv6513 = -1104						; size = 4
_j$ = -1104						; size = 4
_kk$ = -1100						; size = 4
_k$ = -1100						; size = 4
tv9895 = -1096						; size = 4
_mat$ = -1096						; size = 4
_i$ = -1096						; size = 4
tv11128 = -1092						; size = 4
tv11125 = -1092						; size = 4
tv11122 = -1092						; size = 4
tv11119 = -1092						; size = 4
tv11116 = -1092						; size = 4
tv11113 = -1092						; size = 4
tv11094 = -1092						; size = 4
tv10024 = -1092						; size = 4
tv9587 = -1092						; size = 4
tv5922 = -1092						; size = 4
tv5763 = -1092						; size = 4
_ii$90753 = -1092					; size = 4
_x$90622 = -1092					; size = 4
tv9982 = -1088						; size = 4
tv9172 = -1088						; size = 4
tv5940 = -1088						; size = 4
_vv$90706 = -1088					; size = 4
_fe_id$90636 = -1088					; size = 4
_weightsxJ$ = -1084					; size = 288
_temp_matxJ$ = -796					; size = 288
_xxJ$90621 = -508					; size = 288
_xxJ$90516 = -220					; size = 144
_tangxJ$90617 = -172					; size = 96
_tang$90519 = -76					; size = 48
_xqXvS$90620 = -52					; size = 24
_ix$90633 = -28						; size = 24
_vv$ = -28						; size = 24
_vv$90447 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_M$ = 12						; size = 4
_linear_metric_setup_quadratic PROC			; COMDAT

; 1241 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1236				; 000004d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _M$[ebp]
	push	edi
	mov	edi, DWORD PTR _S$[ebp]

; 1242 :   int i,j,jj,k,kk,m,n;
; 1243 :   int sum;
; 1244 :   edge_id e_id;
; 1245 :   vertex_id v_id;
; 1246 :   facet_id f_id;
; 1247 :   int hi;
; 1248 :   REAL len;
; 1249 :   MAT2D(weights,FACET_CTRL,FACET_CTRL);

	push	6
	push	6
	lea	eax, DWORD PTR _weightsxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _weightsqXvS$[ebp]
	push	ecx

; 1302 :               M->IA[j] += vh[k]->freedom;

	mov	DWORD PTR _S$GSCopy$[ebp], edi
	call	_mat2d_setup
	push	6
	push	6
	lea	edx, DWORD PTR _temp_matxJ$[ebp]
	mov	DWORD PTR _weights$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _temp_matqXvS$[ebp]
	push	eax
	call	_mat2d_setup
	xor	ebx, ebx
	add	esp, 32					; 00000020H
	mov	DWORD PTR _temp_mat$[ebp], eax
	cmp	DWORD PTR _ysmp_flag, ebx
	je	SHORT $LN252@linear_met

; 1250 :   MAT2D(temp_mat,MAXCOORD,MAXCOORD);
; 1251 :   REAL **mat;
; 1252 :   int col,end;
; 1253 :   int ii[FACET_CTRL];
; 1254 :   vertex_id vv[FACET_CTRL];
; 1255 :   int lo;
; 1256 : 
; 1257 :   if ( ysmp_flag != MINDEG_FACTORING )
; 1258 :   { ysmp_flag = MINDEG_FACTORING;

	push	OFFSET ??_C@_0EC@DHHMKCIK@Using?5alternate?5minimal?5degree?5w@
	mov	DWORD PTR _ysmp_flag, ebx

; 1259 :     sp_mul_func = bk_mul;

	mov	DWORD PTR _sp_mul_func, OFFSET _bk_mul

; 1260 :     sp_AIJ_setup_func = bk_AIJ_setup;

	mov	DWORD PTR _sp_AIJ_setup_func, OFFSET _bk_AIJ_setup

; 1261 :     sp_constraint_setup_func = bk_constraint_setup;

	mov	DWORD PTR _sp_constraint_setup_func, OFFSET _bk_constraint_setup

; 1262 :     sp_hess_project_setup_func= BK_hess_project_setup;

	mov	DWORD PTR _sp_hess_project_setup_func, OFFSET _BK_hess_project_setup

; 1263 :     sp_factor_func = xmd_factor;

	mov	DWORD PTR _sp_factor_func, OFFSET _xmd_factor

; 1264 :     sp_solve_func = xmd_solve;

	mov	DWORD PTR _sp_solve_func, OFFSET _xmd_solve

; 1265 :     sp_solve_multi_func = xmd_solve_multi;

	mov	DWORD PTR _sp_solve_multi_func, OFFSET _xmd_solve_multi

; 1266 :     sp_ordering_func = NULL;

	mov	DWORD PTR _sp_ordering_func, ebx

; 1267 :     sp_CHinvC_func = sp_CHinvC;

	mov	DWORD PTR _sp_CHinvC_func, OFFSET _sp_CHinvC

; 1268 :     outstring(
; 1269 :        "Using alternate minimal degree with linear interpolation metric.\n");

	call	_outstring
	add	esp, 4
$LN252@linear_met:

; 1270 :   }
; 1271 :   M->N = S->N;

	mov	ecx, DWORD PTR [edi+4]

; 1272 :   M->flags &= ~ S_ODRV_REORDERED; 

	and	DWORD PTR [esi], -17			; ffffffefH

; 1273 : 
; 1274 :   /* allocate storage for arrays */
; 1275 :   M->IA = (int *)temp_calloc(M->N+1,sizeof(int));

	push	1275					; 000004fbH
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	lea	edx, DWORD PTR [ecx+1]
	push	4
	push	edx
	mov	DWORD PTR [esi+4], ecx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+52], eax

; 1276 :   if ( M->P == NULL ) M->P = (int *)temp_calloc(M->N,sizeof(int));

	cmp	DWORD PTR [esi+68], ebx
	jne	SHORT $LN251@linear_met
	mov	eax, DWORD PTR [esi+4]
	push	1276					; 000004fcH
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	4
	push	eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+68], eax
$LN251@linear_met:

; 1277 :   if ( M->IP == NULL ) M->IP = (int *)temp_calloc(M->N,sizeof(int));

	cmp	DWORD PTR [esi+72], ebx
	jne	SHORT $LN250@linear_met
	mov	ecx, DWORD PTR [esi+4]
	push	1277					; 000004fdH
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	4
	push	ecx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+72], eax
$LN250@linear_met:

; 1278 : 
; 1279 :   for ( i = S->optparamrowstart ; i < S->N ; i++ )

	mov	eax, DWORD PTR [edi+16]
	cmp	eax, DWORD PTR [edi+4]
	jge	SHORT $LN247@linear_met
	npad	2
$LL249@linear_met:

; 1280 :   { /* make sure rest of diagonal exists, but no shift */
; 1281 :     M->IA[i] = 1;

	mov	edx, DWORD PTR [esi+52]
	mov	DWORD PTR [edx+eax*4], 1
	inc	eax
	cmp	eax, DWORD PTR [edi+4]
	jl	SHORT $LL249@linear_met
$LN247@linear_met:

; 1282 :   }
; 1283 : 
; 1284 :   /* have to count number of higher-row-number neighbors of each vertex */
; 1285 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ebx, DWORD PTR _vhead_attr
	test	eax, 268435456				; 10000000H
	je	$LN244@linear_met
$LL246@linear_met:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv5763[ebp], edi
	je	SHORT $LN245@linear_met

; 1286 :   { struct hess_verlist *vh = get_vertex_vhead(v_id);

	mov	eax, DWORD PTR _dymem
	mov	edx, ebx
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR [ecx+edx]
	shl	eax, 5
	add	eax, DWORD PTR _vhead

; 1287 :     for ( j = vh->rownum, jj = 0 ; jj < vh->freedom ; jj++,j++ )

	xor	edx, edx
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	jle	SHORT $LN245@linear_met

; 1286 :   { struct hess_verlist *vh = get_vertex_vhead(v_id);

	mov	edi, DWORD PTR [eax+12]
	lea	ebx, DWORD PTR [edi*4]
$LL241@linear_met:

; 1288 :        M->IA[j] += vh->freedom-jj;

	mov	edi, DWORD PTR [esi+52]
	sub	ecx, edx
	add	DWORD PTR [edi+ebx], ecx
	mov	ecx, DWORD PTR [eax+8]
	inc	edx
	add	ebx, 4
	cmp	edx, ecx
	jl	SHORT $LL241@linear_met

; 1287 :     for ( j = vh->rownum, jj = 0 ; jj < vh->freedom ; jj++,j++ )

	mov	ebx, DWORD PTR _vhead_attr
	mov	edi, DWORD PTR tv5763[ebp]
$LN245@linear_met:

; 1282 :   }
; 1283 : 
; 1284 :   /* have to count number of higher-row-number neighbors of each vertex */
; 1285 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	jne	$LL246@linear_met
$LN244@linear_met:

; 1289 :   }
; 1290 :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+160
	test	ecx, 268435456				; 10000000H
	je	$LN616@linear_met
	npad	10
$LL238@linear_met:
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR tv5806[ebp], eax
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN237@linear_met

; 1291 :   { vertex_id v[3];
; 1292 :     struct hess_verlist *vh[3];
; 1293 :     v[0] = get_edge_tailv(e_id);

	mov	eax, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edi+304]
	shr	ecx, 27					; 0000001bH
	add	eax, edx
	and	ecx, 1
	je	SHORT $LN268@linear_met
	mov	edx, DWORD PTR _web+636
	mov	edx, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN267@linear_met
$LN268@linear_met:
	mov	edx, DWORD PTR [eax]
$LN267@linear_met:

; 1294 :     v[1] = get_edge_headv(e_id);

	test	ecx, ecx
	je	SHORT $LN272@linear_met
	mov	edi, DWORD PTR [eax]
	jmp	SHORT $LN271@linear_met
$LN272@linear_met:
	mov	ecx, DWORD PTR _web+636
	mov	edi, DWORD PTR [eax+ecx*4]
$LN271@linear_met:

; 1295 :     v[2] = get_edge_midv(e_id);
; 1296 :     for ( i = 0 ; i < 3 ; i ++ )
; 1297 :       vh[i] = get_vertex_vhead(v[i]);

	mov	ecx, DWORD PTR _dymem
	imul	ebx, 240				; 000000f0H
	add	ebx, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ebx+ecx+64]
	mov	ebx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _vhead
	shl	ebx, 5
	add	ebx, edx
	and	edi, 134217727				; 07ffffffH
	mov	DWORD PTR _vh$90415[ebp], ebx
	mov	ebx, DWORD PTR _web+12
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	edi, DWORD PTR [ecx+edi]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ecx, DWORD PTR [ecx+eax]
	shl	edi, 5
	add	edi, edx
	shl	ecx, 5
	add	ecx, edx
	lea	edx, DWORD PTR _vh$90415[ebp]
	mov	DWORD PTR _vh$90415[ebp+4], edi
	mov	DWORD PTR _vh$90415[ebp+8], ecx
	mov	DWORD PTR tv8720[ebp], edx
	mov	DWORD PTR tv5221[ebp], 3
	npad	7
$LL230@linear_met:

; 1299 :       for ( k = 0 ; k < 3 ; k++ )

	mov	ecx, DWORD PTR tv8720[ebp]
	mov	ebx, DWORD PTR [ecx]
	xor	eax, eax
	mov	DWORD PTR _k$[ebp], eax
	mov	DWORD PTR tv8723[ebp], ebx
	npad	10
$LL227@linear_met:

; 1300 :         if ( vh[i]->rownum < vh[k]->rownum )

	mov	edi, DWORD PTR _vh$90415[ebp+eax*4]
	mov	ecx, DWORD PTR [ebx+12]
	cmp	ecx, DWORD PTR [edi+12]
	jge	SHORT $LN226@linear_met

; 1301 :            for ( j = vh[i]->rownum, jj = 0 ; jj < vh[i]->freedom ; j++,jj++ )

	xor	edx, edx
	cmp	DWORD PTR [ebx+8], edx
	jle	SHORT $LN226@linear_met
	mov	eax, DWORD PTR tv8720[ebp]
	mov	eax, DWORD PTR [eax]
	add	ecx, ecx
	mov	DWORD PTR tv11094[ebp], eax
	add	ecx, ecx
	npad	8
$LL223@linear_met:

; 1302 :               M->IA[j] += vh[k]->freedom;

	mov	eax, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR [edi+8]
	add	DWORD PTR [eax+ecx], ebx
	mov	eax, DWORD PTR tv11094[ebp]
	inc	edx
	add	ecx, 4
	cmp	edx, DWORD PTR [eax+8]
	jl	SHORT $LL223@linear_met

; 1301 :            for ( j = vh[i]->rownum, jj = 0 ; jj < vh[i]->freedom ; j++,jj++ )

	mov	ebx, DWORD PTR tv8723[ebp]
	mov	eax, DWORD PTR _k$[ebp]
$LN226@linear_met:

; 1299 :       for ( k = 0 ; k < 3 ; k++ )

	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, 3
	jl	SHORT $LL227@linear_met

; 1298 :     for ( i = 0 ; i < 3 ; i ++ )

	add	DWORD PTR tv8720[ebp], 4
	dec	DWORD PTR tv5221[ebp]
	jne	$LL230@linear_met
	mov	ebx, DWORD PTR _vhead_attr
$LN237@linear_met:

; 1289 :   }
; 1290 :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv5806[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [eax]
	test	ecx, 268435456				; 10000000H
	jne	$LL238@linear_met
$LN616@linear_met:

; 1303 :   }
; 1304 :   if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	jne	$LN217@linear_met

; 1305 :   { FOR_ALL_FACETS(f_id)  // add pairs not on same edge

	mov	edx, DWORD PTR _web+272
	mov	edi, edx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	je	$LN217@linear_met
	npad	9
$LL219@linear_met:
	mov	eax, DWORD PTR _web+236
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR tv5922[ebp], eax
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv5919[ebp], ecx
	je	$LN218@linear_met

; 1306 :     { vertex_id vv[FACET_CTRL];
; 1307 :       struct hess_verlist *vh[FACET_CTRL];
; 1308 :       facetedge_id  fe_id = get_facet_fe(f_id);

	test	edi, edi
	jne	SHORT $LN276@linear_met
	xor	edx, edx
	mov	DWORD PTR _fe_id$90449[ebp], edx
	jmp	SHORT $LN277@linear_met
$LN276@linear_met:
	mov	ecx, DWORD PTR tv5922[ebp]
	mov	eax, DWORD PTR [ecx+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN275@linear_met
	xor	eax, 134217728				; 08000000H
$LN275@linear_met:
	mov	edx, eax
	mov	DWORD PTR _fe_id$90449[ebp], eax
$LN277@linear_met:

; 1309 :       int v[FACET_CTRL];
; 1310 :   
; 1311 :       for ( i = 0 ; i < FACET_EDGES ; i++ )
; 1312 :       {
; 1313 :          vv[i] = get_fe_tailv(fe_id);

	mov	ecx, DWORD PTR _web+460
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edi, DWORD PTR [eax+20]
	mov	DWORD PTR tv5940[ebp], eax
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, edi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN282@linear_met
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	ebx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR _web+636
	lea	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR _fe_id$90449[ebp]
	jmp	SHORT $LN281@linear_met
$LN282@linear_met:
	mov	ebx, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ebx+ecx+304]
	mov	ebx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN281@linear_met:

; 1314 :          vv[i+3] = get_fe_midv(fe_id);

	and	edi, 134217727				; 07ffffffH
	mov	DWORD PTR _vv$90447[ebp], eax
	mov	eax, DWORD PTR [ebx+edi*4]
	mov	eax, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR _vv$90447[ebp+12], eax

; 1315 :          fe_id = get_next_edge(fe_id);

	test	edx, 134217728				; 08000000H
	je	SHORT $LN288@linear_met
	mov	edx, DWORD PTR tv5940[ebp]
	mov	edx, DWORD PTR [edx+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN213@linear_met
$LN288@linear_met:
	mov	eax, DWORD PTR tv5940[ebp]
	mov	edx, DWORD PTR [eax+32]
$LN213@linear_met:

; 1309 :       int v[FACET_CTRL];
; 1310 :   
; 1311 :       for ( i = 0 ; i < FACET_EDGES ; i++ )
; 1312 :       {
; 1313 :          vv[i] = get_fe_tailv(fe_id);

	mov	edi, DWORD PTR _web+460
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [eax+20]
	mov	DWORD PTR tv5940[ebp], eax
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, edi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN457@linear_met
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
	mov	ebx, DWORD PTR _web+124
	jmp	SHORT $LN458@linear_met
$LN457@linear_met:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN458@linear_met:

; 1314 :          vv[i+3] = get_fe_midv(fe_id);

	and	edi, 134217727				; 07ffffffH
	mov	DWORD PTR _vv$90447[ebp+4], eax
	mov	eax, DWORD PTR [ebx+edi*4]
	mov	eax, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR _vv$90447[ebp+16], eax

; 1315 :          fe_id = get_next_edge(fe_id);

	test	edx, 134217728				; 08000000H
	je	SHORT $LN459@linear_met
	mov	edx, DWORD PTR tv5940[ebp]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN460@linear_met
$LN459@linear_met:
	mov	eax, DWORD PTR tv5940[ebp]
	mov	eax, DWORD PTR [eax+32]
$LN460@linear_met:

; 1309 :       int v[FACET_CTRL];
; 1310 :   
; 1311 :       for ( i = 0 ; i < FACET_EDGES ; i++ )
; 1312 :       {
; 1313 :          vv[i] = get_fe_tailv(fe_id);

	mov	edi, DWORD PTR _web+460
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [edx+20]
	and	eax, 134217728				; 08000000H
	xor	eax, edx
	test	eax, 134217728				; 08000000H
	je	SHORT $LN462@linear_met
	mov	edi, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	lea	eax, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN730@linear_met
$LN462@linear_met:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN730@linear_met:

; 1314 :          vv[i+3] = get_fe_midv(fe_id);

	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ecx, DWORD PTR [edx+ecx+8]

; 1316 :       }
; 1317 :   
; 1318 :       for ( i = 0 ; i < FACET_CTRL ; i++ ) 
; 1319 :       { v[i] = loc_ordinal(vv[i]);

	mov	edx, DWORD PTR _vv$90447[ebp]
	mov	DWORD PTR $T91833[ebp], eax
	test	edx, 268435456				; 10000000H
	je	SHORT $LN255@linear_met
	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN256@linear_met
$LN255@linear_met:
	or	edx, -1
$LN256@linear_met:

; 1320 :         vh[i] = get_vertex_vhead(v[i]);

	mov	eax, DWORD PTR _vhead_attr
	mov	edi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	ebx, DWORD PTR _vhead
	mov	eax, DWORD PTR [eax+edi+64]
	mov	edi, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [eax+edx]
	shl	edx, 5
	add	edx, ebx
	mov	DWORD PTR _vh$90448[ebp], edx
	mov	edx, DWORD PTR _vv$90447[ebp+4]
	test	edx, 268435456				; 10000000H
	je	SHORT $LN471@linear_met

; 1316 :       }
; 1317 :   
; 1318 :       for ( i = 0 ; i < FACET_CTRL ; i++ ) 
; 1319 :       { v[i] = loc_ordinal(vv[i]);

	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN472@linear_met
$LN471@linear_met:
	or	edx, -1
$LN472@linear_met:

; 1320 :         vh[i] = get_vertex_vhead(v[i]);

	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [eax+edx]
	shl	edx, 5
	add	edx, ebx
	mov	DWORD PTR _vh$90448[ebp+4], edx
	mov	edx, DWORD PTR $T91833[ebp]
	test	edx, 268435456				; 10000000H
	je	SHORT $LN474@linear_met

; 1316 :       }
; 1317 :   
; 1318 :       for ( i = 0 ; i < FACET_CTRL ; i++ ) 
; 1319 :       { v[i] = loc_ordinal(vv[i]);

	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN475@linear_met
$LN474@linear_met:
	or	edx, -1
$LN475@linear_met:

; 1320 :         vh[i] = get_vertex_vhead(v[i]);

	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [eax+edx]
	shl	edx, 5
	add	edx, ebx
	mov	DWORD PTR _vh$90448[ebp+8], edx
	mov	edx, DWORD PTR _vv$90447[ebp+12]
	test	edx, 268435456				; 10000000H
	je	SHORT $LN477@linear_met

; 1316 :       }
; 1317 :   
; 1318 :       for ( i = 0 ; i < FACET_CTRL ; i++ ) 
; 1319 :       { v[i] = loc_ordinal(vv[i]);

	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN478@linear_met
$LN477@linear_met:
	or	edx, -1
$LN478@linear_met:

; 1320 :         vh[i] = get_vertex_vhead(v[i]);

	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [eax+edx]
	shl	edx, 5
	add	edx, ebx
	mov	DWORD PTR _vh$90448[ebp+12], edx
	mov	edx, DWORD PTR _vv$90447[ebp+16]
	test	edx, 268435456				; 10000000H
	je	SHORT $LN480@linear_met

; 1316 :       }
; 1317 :   
; 1318 :       for ( i = 0 ; i < FACET_CTRL ; i++ ) 
; 1319 :       { v[i] = loc_ordinal(vv[i]);

	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN481@linear_met
$LN480@linear_met:
	or	edx, -1
$LN481@linear_met:

; 1320 :         vh[i] = get_vertex_vhead(v[i]);

	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [eax+edx]
	shl	edx, 5
	add	edx, ebx
	mov	DWORD PTR _vh$90448[ebp+16], edx
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN483@linear_met

; 1316 :       }
; 1317 :   
; 1318 :       for ( i = 0 ; i < FACET_CTRL ; i++ ) 
; 1319 :       { v[i] = loc_ordinal(vv[i]);

	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN484@linear_met
$LN483@linear_met:
	or	ecx, -1
$LN484@linear_met:

; 1321 :       }
; 1322 :   
; 1323 : #define ADDON(a,b) \
; 1324 :       if ( vh[a]->rownum > vh[b]->rownum ) {lo = b; hi = a; } else { lo = a; hi = b;}\
; 1325 :       for ( j = vh[lo]->rownum, jj = 0 ; jj < vh[lo]->freedom ; j++,jj++ )\
; 1326 :           M->IA[j] += vh[hi]->freedom;
; 1327 :   
; 1328 :       ADDON(0,4); ADDON(1,5); ADDON(2,3); ADDON(4,5); ADDON(3,4); ADDON(3,5);

	mov	edx, DWORD PTR _vh$90448[ebp]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	eax, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _vh$90448[ebp+16]
	shl	eax, 5
	add	eax, ebx
	mov	DWORD PTR _vh$90448[ebp+20], eax
	cmp	ecx, DWORD PTR [edx+12]
	jle	SHORT $LN208@linear_met
	mov	ecx, 4
	xor	ebx, ebx
	jmp	SHORT $LN207@linear_met
$LN208@linear_met:
	xor	ecx, ecx
	lea	ebx, DWORD PTR [ecx+4]
$LN207@linear_met:
	mov	edx, DWORD PTR _vh$90448[ebp+ecx*4]
	mov	edi, DWORD PTR [edx+12]
	lea	ecx, DWORD PTR _vh$90448[ebp+ecx*4]
	mov	DWORD PTR _j$[ebp], edi
	xor	edi, edi
	cmp	DWORD PTR [edx+8], edi
	jle	SHORT $LN643@linear_met
	mov	ebx, DWORD PTR _vh$90448[ebp+ebx*4]
	mov	DWORD PTR tv11113[ebp], edx
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, edx
	add	edx, edx
	npad	8
$LL206@linear_met:
	mov	ecx, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [ebx+8]
	add	DWORD PTR [ecx+edx], eax
	mov	ecx, DWORD PTR tv11113[ebp]
	inc	edi
	add	edx, 4
	cmp	edi, DWORD PTR [ecx+8]
	jl	SHORT $LL206@linear_met
	mov	eax, DWORD PTR _vh$90448[ebp+20]
$LN643@linear_met:
	mov	edx, DWORD PTR _vh$90448[ebp+4]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+12]
	jle	SHORT $LN203@linear_met
	mov	ecx, 5
	lea	ebx, DWORD PTR [ecx-4]
	jmp	SHORT $LN202@linear_met
$LN203@linear_met:
	mov	ecx, 1
	lea	ebx, DWORD PTR [ecx+4]
$LN202@linear_met:
	mov	edx, DWORD PTR _vh$90448[ebp+ecx*4]
	mov	eax, DWORD PTR [edx+12]
	lea	ecx, DWORD PTR _vh$90448[ebp+ecx*4]
	xor	edi, edi
	cmp	DWORD PTR [edx+8], edi
	jle	SHORT $LN199@linear_met
	mov	ebx, DWORD PTR _vh$90448[ebp+ebx*4]
	mov	DWORD PTR tv11116[ebp], edx
	lea	edx, DWORD PTR [eax*4]
	npad	6
$LL201@linear_met:
	mov	ecx, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [ebx+8]
	add	DWORD PTR [ecx+edx], eax
	mov	ecx, DWORD PTR tv11116[ebp]
	inc	edi
	add	edx, 4
	cmp	edi, DWORD PTR [ecx+8]
	jl	SHORT $LL201@linear_met
$LN199@linear_met:
	mov	edx, DWORD PTR _vh$90448[ebp+8]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _vh$90448[ebp+12]
	cmp	eax, DWORD PTR [ecx+12]
	jle	SHORT $LN198@linear_met
	mov	ecx, 3
	lea	ebx, DWORD PTR [ecx-1]
	jmp	SHORT $LN197@linear_met
$LN198@linear_met:
	mov	ecx, 2
	lea	ebx, DWORD PTR [ecx+1]
$LN197@linear_met:
	mov	edx, DWORD PTR _vh$90448[ebp+ecx*4]
	mov	eax, DWORD PTR [edx+12]
	lea	ecx, DWORD PTR _vh$90448[ebp+ecx*4]
	xor	edi, edi
	cmp	DWORD PTR [edx+8], edi
	jle	SHORT $LN649@linear_met
	mov	ebx, DWORD PTR _vh$90448[ebp+ebx*4]
	mov	DWORD PTR tv11119[ebp], edx
	lea	edx, DWORD PTR [eax*4]
	npad	6
$LL196@linear_met:
	mov	ecx, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [ebx+8]
	add	DWORD PTR [ecx+edx], eax
	mov	ecx, DWORD PTR tv11119[ebp]
	inc	edi
	add	edx, 4
	cmp	edi, DWORD PTR [ecx+8]
	jl	SHORT $LL196@linear_met
$LN649@linear_met:
	mov	edx, DWORD PTR _vh$90448[ebp+16]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _vh$90448[ebp+20]
	cmp	eax, DWORD PTR [ecx+12]
	jle	SHORT $LN193@linear_met
	mov	ecx, 5
	lea	ebx, DWORD PTR [ecx-1]
	jmp	SHORT $LN192@linear_met
$LN193@linear_met:
	mov	ecx, 4
	lea	ebx, DWORD PTR [ecx+1]
$LN192@linear_met:
	mov	edx, DWORD PTR _vh$90448[ebp+ecx*4]
	mov	eax, DWORD PTR [edx+12]
	lea	ecx, DWORD PTR _vh$90448[ebp+ecx*4]
	xor	edi, edi
	cmp	DWORD PTR [edx+8], edi
	jle	SHORT $LN650@linear_met
	mov	ebx, DWORD PTR _vh$90448[ebp+ebx*4]
	mov	DWORD PTR tv11122[ebp], edx
	lea	edx, DWORD PTR [eax*4]
	npad	6
$LL191@linear_met:
	mov	ecx, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [ebx+8]
	add	DWORD PTR [ecx+edx], eax
	mov	ecx, DWORD PTR tv11122[ebp]
	inc	edi
	add	edx, 4
	cmp	edi, DWORD PTR [ecx+8]
	jl	SHORT $LL191@linear_met
$LN650@linear_met:
	mov	edx, DWORD PTR _vh$90448[ebp+12]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _vh$90448[ebp+16]
	cmp	eax, DWORD PTR [ecx+12]
	jle	SHORT $LN188@linear_met
	mov	ecx, 4
	lea	ebx, DWORD PTR [ecx-1]
	jmp	SHORT $LN187@linear_met
$LN188@linear_met:
	mov	ecx, 3
	lea	ebx, DWORD PTR [ecx+1]
$LN187@linear_met:
	mov	edx, DWORD PTR _vh$90448[ebp+ecx*4]
	mov	eax, DWORD PTR [edx+12]
	lea	ecx, DWORD PTR _vh$90448[ebp+ecx*4]
	xor	edi, edi
	cmp	DWORD PTR [edx+8], edi
	jle	SHORT $LN651@linear_met
	mov	ebx, DWORD PTR _vh$90448[ebp+ebx*4]
	mov	DWORD PTR tv11125[ebp], edx
	lea	edx, DWORD PTR [eax*4]
	npad	6
$LL186@linear_met:
	mov	ecx, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [ebx+8]
	add	DWORD PTR [ecx+edx], eax
	mov	ecx, DWORD PTR tv11125[ebp]
	inc	edi
	add	edx, 4
	cmp	edi, DWORD PTR [ecx+8]
	jl	SHORT $LL186@linear_met
$LN651@linear_met:
	mov	edx, DWORD PTR _vh$90448[ebp+12]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _vh$90448[ebp+20]
	cmp	eax, DWORD PTR [ecx+12]
	jle	SHORT $LN183@linear_met
	mov	eax, 5
	lea	edi, DWORD PTR [eax-2]
	jmp	SHORT $LN182@linear_met
$LN183@linear_met:
	mov	eax, 3
	lea	edi, DWORD PTR [eax+2]
$LN182@linear_met:
	mov	ecx, DWORD PTR _vh$90448[ebp+eax*4]
	mov	ebx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR _vh$90448[ebp+eax*4]
	xor	edx, edx
	cmp	DWORD PTR [ecx+8], edx
	jle	SHORT $LN644@linear_met
	mov	edi, DWORD PTR _vh$90448[ebp+edi*4]
	mov	DWORD PTR tv11128[ebp], ecx
	lea	ecx, DWORD PTR [ebx*4]
	npad	6
$LL181@linear_met:
	mov	eax, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR [edi+8]
	add	DWORD PTR [eax+ecx], ebx
	mov	eax, DWORD PTR tv11128[ebp]
	inc	edx
	add	ecx, 4
	cmp	edx, DWORD PTR [eax+8]
	jl	SHORT $LL181@linear_met
$LN644@linear_met:
	mov	ecx, DWORD PTR tv5919[ebp]
$LN218@linear_met:

; 1305 :   { FOR_ALL_FACETS(f_id)  // add pairs not on same edge

	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR [eax]
	mov	edi, edx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	$LL219@linear_met
$LN217@linear_met:

; 1329 :     }
; 1330 :   }
; 1331 :   for ( i = 0, sum = 0 ; i < M->N ; i++ ) /* add to running totals */

	xor	eax, eax
	xor	edi, edi
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN645@linear_met
$LL178@linear_met:
	mov	ecx, DWORD PTR [esi+52]
	lea	ecx, DWORD PTR [ecx+eax*4]

; 1332 :   { int tmp = sum; 
; 1333 :     sum += M->IA[i];
; 1334 :     M->IA[i] = tmp + A_OFF;

	lea	edx, DWORD PTR [edi+1]
	add	edi, DWORD PTR [ecx]
	inc	eax
	mov	DWORD PTR [ecx], edx
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL178@linear_met
$LN645@linear_met:

; 1335 :   }
; 1336 :   M->IA[M->N] = sum + A_OFF;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+52]

; 1337 : 
; 1338 :   /* now can allocate space */
; 1339 :   M->JA = (int *)temp_calloc(sum,sizeof(int));

	push	1339					; 0000053bH
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	lea	edx, DWORD PTR [edi+1]
	push	4
	push	edi
	mov	DWORD PTR [ecx+eax*4], edx
	call	_kb_temp_calloc

; 1340 :   M->A  = (REAL *)temp_calloc(sum,sizeof(REAL));

	push	1340					; 0000053cH
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	8
	push	edi
	mov	DWORD PTR [esi+56], eax
	call	_kb_temp_calloc
	mov	DWORD PTR [esi+60], eax
	add	esp, 32					; 00000020H

; 1341 : 
; 1342 :   for ( i = 0 ; i < sum ; i++ ) M->JA[i] = -1;  /* vacant */

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN656@linear_met
$LL175@linear_met:
	mov	edx, DWORD PTR [esi+56]
	mov	DWORD PTR [edx+eax*4], -1
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL175@linear_met
$LN656@linear_met:

; 1343 :   for ( i = 0 ; i < M->N ; i++ )

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN170@linear_met
	npad	8
$LL172@linear_met:

; 1344 :   { M->JA[M->IA[i]-A_OFF] = i + A_OFF; /* diagonal entry at start */

	mov	edx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [esi+56]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [edi+edx*4-4], ecx

; 1345 :     M->IP[i] = M->P[i] = i;    /* unpermuted */

	mov	edx, DWORD PTR [esi+68]
	mov	DWORD PTR [edx+eax*4], eax
	mov	edx, DWORD PTR [esi+72]
	mov	DWORD PTR [edx+eax*4], eax
	mov	eax, ecx
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL172@linear_met
$LN170@linear_met:

; 1346 :   }
; 1347 : 
; 1348 :   /* set up interpolation weight matrix */
; 1349 :   for ( i = 0 ; i < optparamcount ; i++ )

	fld1
	xor	eax, eax
	cmp	DWORD PTR _optparamcount, eax
	jle	SHORT $LN662@linear_met
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
$LN169@linear_met:

; 1350 :     M->A[M->IA[S->optparamrowstart+i]-A_OFF] = 1.0;

	mov	edx, DWORD PTR [ecx+16]
	mov	edi, DWORD PTR [esi+52]
	add	edx, eax
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR [esi+60]
	inc	eax
	fst	QWORD PTR [edi+edx*8-8]
	cmp	eax, DWORD PTR _optparamcount
	jl	SHORT $LN169@linear_met
$LN662@linear_met:

; 1351 :   /* leave rest of diagonal zero in case of augmented hessian */
; 1352 : 
; 1353 : 
; 1354 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	fstp	ST(0)

; 1355 :   { MAT2D(x,EDGE_CTRL,MAXCOORD);

	push	6
	jne	$LN166@linear_met
	push	3
	lea	eax, DWORD PTR _xxJ$90516[ebp]
	push	eax
	lea	ecx, DWORD PTR _xqXvS$90515[ebp]
	push	ecx
	call	_mat2d_setup

; 1356 :     REAL tang[MAXCOORD];
; 1357 : 
; 1358 :     /* edge by edge */
; 1359 :     FOR_ALL_EDGES(e_id)

	mov	edi, DWORD PTR _web+160
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$90517[ebp], eax
	test	edi, 268435456				; 10000000H
	je	$LN94@linear_met
	mov	ebx, DWORD PTR _web+124
$LL165@linear_met:
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ebx]
	mov	DWORD PTR tv5806[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN164@linear_met

; 1360 :     { 
; 1361 :       vv[0] = get_edge_tailv(e_id);

	mov	eax, DWORD PTR _web+216
	mov	ebx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ebx+304]
	mov	edx, edi
	shr	edx, 27					; 0000001bH
	add	eax, ecx
	and	edx, 1
	je	SHORT $LN292@linear_met
	mov	ecx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN291@linear_met
$LN292@linear_met:
	mov	ecx, DWORD PTR [eax]
$LN291@linear_met:
	mov	DWORD PTR _vv$[ebp], ecx

; 1362 :       vv[1] = get_edge_midv(e_id);

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _vv$[ebp+4], ecx

; 1363 :       vv[2] = get_edge_headv(e_id);

	test	edx, edx
	je	SHORT $LN296@linear_met
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN295@linear_met
$LN296@linear_met:
	mov	edx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edx*4]
$LN295@linear_met:
	mov	DWORD PTR _vv$[ebp+8], eax

; 1364 :       ii[0] = loc_ordinal(vv[0]);
; 1365 :       ii[1] = loc_ordinal(vv[1]);
; 1366 :       ii[2] = loc_ordinal(vv[2]);
; 1367 :       get_edge_verts(e_id,x,NULL);

	mov	eax, DWORD PTR _x$90517[ebp]
	push	0
	push	eax
	push	edi
	call	_get_edge_verts

; 1368 :       len = get_edge_length(e_id);

	push	edi
	call	_get_edge_length
	fst	QWORD PTR _len$[ebp]

; 1369 : 
; 1370 :       /* weight matrix */
; 1371 :       for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	edx, DWORD PTR _edge_ctrl
	fldz
	add	esp, 16					; 00000010H
	xor	edi, edi
	test	edx, edx
	jle	SHORT $LN158@linear_met
	mov	ebx, DWORD PTR _weights$[ebp]
$LN160@linear_met:

; 1372 :         for ( j = 0 ; j < edge_ctrl ; j++ ) weights[i][j] = 0.0;

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN159@linear_met

; 1369 : 
; 1370 :       /* weight matrix */
; 1371 :       for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	eax, DWORD PTR [ebx+edi*4]
$LN157@linear_met:

; 1372 :         for ( j = 0 ; j < edge_ctrl ; j++ ) weights[i][j] = 0.0;

	fst	QWORD PTR [eax]
	mov	edx, DWORD PTR _edge_ctrl
	inc	ecx
	add	eax, 8
	cmp	ecx, edx
	jl	SHORT $LN157@linear_met
$LN159@linear_met:

; 1369 : 
; 1370 :       /* weight matrix */
; 1371 :       for ( i = 0 ; i < edge_ctrl ; i++ )

	inc	edi
	cmp	edi, edx
	jl	SHORT $LN160@linear_met
$LN158@linear_met:

; 1373 : 
; 1374 :       for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	edi, edi
	cmp	DWORD PTR _gauss1D_num, edi
	jle	$LN675@linear_met
	fstp	ST(1)
	jmp	SHORT $LN154@linear_met
$LL619@linear_met:
	fldz
$LN154@linear_met:

; 1375 :       { REAL value;
; 1376 :         for ( n = 0 ; n < SDIM ; n ++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	$LN694@linear_met
	mov	ebx, DWORD PTR _gauss1polyd
$LN151@linear_met:

; 1378 :           for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	eax, eax
	fst	QWORD PTR _tang$90519[ebp+ecx*8]
	mov	DWORD PTR _k$[ebp], eax
	cmp	edx, 4
	jl	$LC486@linear_met

; 1377 :         { tang[n] = 0.0;

	mov	edx, DWORD PTR _x$90517[ebp]
	lea	eax, DWORD PTR [edx+12]

; 1379 :           tang[n] += gauss1polyd[k][m]*x[k][n];

	sub	edx, ebx
	mov	DWORD PTR tv9629[ebp], edx
	mov	edx, DWORD PTR _edge_ctrl
	add	edx, -4					; fffffffcH
	shr	edx, 2
	inc	edx
	mov	DWORD PTR tv4746[ebp], edx
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv9172[ebp], eax
	lea	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _k$[ebp], edx
$LN627@linear_met:
	mov	edx, DWORD PTR [eax-4]
	fld	QWORD PTR [edx+edi*8]
	mov	ebx, DWORD PTR tv9172[ebp]
	mov	ebx, DWORD PTR [ebx-12]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	edx, DWORD PTR tv9629[ebp]
	add	eax, 16					; 00000010H
	fadd	QWORD PTR _tang$90519[ebp+ecx*8]
	fst	QWORD PTR _tang$90519[ebp+ecx*8]
	mov	edx, DWORD PTR [eax+edx-16]
	mov	ebx, DWORD PTR [eax-16]
	fld	QWORD PTR [edx+ecx*8]
	fmul	QWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR tv9172[ebp]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$90519[ebp+ecx*8]
	mov	edx, DWORD PTR [eax-12]
	mov	ebx, DWORD PTR [ebx-4]
	fld	QWORD PTR [edx+edi*8]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR tv9172[ebp]
	add	DWORD PTR tv9172[ebp], 16		; 00000010H
	dec	DWORD PTR tv4746[ebp]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$90519[ebp+ecx*8]
	mov	edx, DWORD PTR [eax-8]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [edx+edi*8]
	fmul	QWORD PTR [ebx+ecx*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _tang$90519[ebp+ecx*8]
	jne	SHORT $LN627@linear_met

; 1377 :         { tang[n] = 0.0;

	mov	ebx, DWORD PTR _gauss1polyd
	mov	edx, DWORD PTR _edge_ctrl
	mov	eax, DWORD PTR _k$[ebp]
$LC486@linear_met:

; 1378 :           for ( k = 0 ; k < edge_ctrl ; k++ )

	cmp	eax, edx
	jge	SHORT $LN150@linear_met
	mov	edx, DWORD PTR _x$90517[ebp]
	sub	edx, ebx
	mov	DWORD PTR tv9629[ebp], edx
	mov	edx, DWORD PTR _edge_ctrl
	sub	edx, DWORD PTR _k$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR tv1559[ebp], edx
$LC148@linear_met:

; 1379 :           tang[n] += gauss1polyd[k][m]*x[k][n];

	mov	edx, DWORD PTR tv9629[ebp]
	mov	edx, DWORD PTR [edx+eax]
	mov	ebx, DWORD PTR [eax]
	fld	QWORD PTR [edx+ecx*8]
	fmul	QWORD PTR [ebx+edi*8]
	add	eax, 4
	dec	DWORD PTR tv1559[ebp]
	fadd	QWORD PTR _tang$90519[ebp+ecx*8]
	fstp	QWORD PTR _tang$90519[ebp+ecx*8]
	jne	SHORT $LC148@linear_met

; 1378 :           for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	edx, DWORD PTR _edge_ctrl
	mov	ebx, DWORD PTR _gauss1polyd
$LN150@linear_met:

; 1375 :       { REAL value;
; 1376 :         for ( n = 0 ; n < SDIM ; n ++ )

	inc	ecx
	cmp	ecx, DWORD PTR _web+616
	jl	$LN151@linear_met
$LN694@linear_met:

; 1380 :         }
; 1381 :         value = gauss1Dwt[m]*sqrt(SDIM_dot(tang,tang));

	mov	eax, DWORD PTR _web+616
	fstp	ST(0)
	push	eax
	lea	ecx, DWORD PTR _tang$90519[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 1382 :         for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	edx, DWORD PTR _edge_ctrl
	mov	eax, DWORD PTR _gauss1Dwt
	fmul	QWORD PTR [eax+edi*8]
	mov	DWORD PTR _i$[ebp], 0
	test	edx, edx
	jle	SHORT $LN715@linear_met
	mov	eax, DWORD PTR _weights$[ebp]
	mov	ebx, DWORD PTR _gauss1poly
	sub	ebx, eax
	mov	DWORD PTR tv9572[ebp], eax
	mov	DWORD PTR tv9587[ebp], ebx
$LN145@linear_met:

; 1383 :         { for ( j = 0 ; j < edge_ctrl ; j++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN144@linear_met
	mov	edx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [eax]
	lea	ebx, DWORD PTR [edx+edi*8]
$LN617@linear_met:

; 1384 :             weights[i][j] += quadratic_metric_mix*value
; 1385 :                              *gauss1poly[i][m]*gauss1poly[j][m];

	fld	QWORD PTR _quadratic_metric_mix
	mov	edx, DWORD PTR _gauss1poly
	mov	edx, DWORD PTR [edx+ecx*4]
	fmul	ST(0), ST(1)
	inc	ecx
	add	eax, 8
	fmul	QWORD PTR [ebx]
	fmul	QWORD PTR [edx+edi*8]
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _edge_ctrl
	cmp	ecx, edx
	jl	SHORT $LN617@linear_met

; 1383 :         { for ( j = 0 ; j < edge_ctrl ; j++ )

	mov	ebx, DWORD PTR tv9587[ebp]
	mov	eax, DWORD PTR tv9572[ebp]
$LN144@linear_met:

; 1382 :         for ( i = 0 ; i < edge_ctrl ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	inc	ecx
	add	eax, 4
	mov	DWORD PTR _i$[ebp], ecx
	mov	DWORD PTR tv9572[ebp], eax
	cmp	ecx, edx
	jl	SHORT $LN145@linear_met
$LN715@linear_met:

; 1373 : 
; 1374 :       for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	edi

; 1383 :         { for ( j = 0 ; j < edge_ctrl ; j++ )

	fstp	ST(0)
	cmp	edi, DWORD PTR _gauss1D_num
	jl	$LL619@linear_met

; 1373 : 
; 1374 :       for ( m = 0 ; m < gauss1D_num ; m++ )

	fld	QWORD PTR _len$[ebp]
	jmp	SHORT $LN152@linear_met
$LN675@linear_met:
	fstp	ST(0)
$LN152@linear_met:

; 1386 :         }
; 1387 :       }
; 1388 :       /* simple vertex weighting part */
; 1389 :       for ( i = 0 ; i < edge_ctrl ; i++ )

	xor	eax, eax
	test	edx, edx
	mov	edx, DWORD PTR _weights$[ebp]
	jle	SHORT $LN696@linear_met
	fld	QWORD PTR __real@3fd0000000000000
	fld	QWORD PTR __real@3fe0000000000000
	fld1
$LN139@linear_met:

; 1390 :         weights[i][i] += (1-quadratic_metric_mix)*((i==1) ? 0.5*len : 0.25*len);

	fld	ST(3)
	cmp	eax, 1
	jne	SHORT $LN263@linear_met
	fmul	ST(0), ST(2)
	jmp	SHORT $LN264@linear_met
$LN263@linear_met:
	fmul	ST(0), ST(3)
$LN264@linear_met:
	mov	ecx, DWORD PTR [edx+eax*4]
	fld	ST(1)
	fsub	QWORD PTR _quadratic_metric_mix
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	eax
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _edge_ctrl
	jl	SHORT $LN139@linear_met

; 1386 :         }
; 1387 :       }
; 1388 :       /* simple vertex weighting part */
; 1389 :       for ( i = 0 ; i < edge_ctrl ; i++ )

	fstp	ST(3)
	fstp	ST(0)
	fstp	ST(0)
$LN696@linear_met:

; 1391 : 
; 1392 :       /* fill in metric matrix */
; 1393 :       for ( i = 0 ; i < 3 ; i++ )

	lea	eax, DWORD PTR _vv$[ebp]
	fstp	ST(0)
	sub	eax, edx
	mov	DWORD PTR tv9937[ebp], 0
	mov	DWORD PTR tv9982[ebp], edx
	mov	DWORD PTR tv10024[ebp], eax
$LL136@linear_met:

; 1394 :       { struct hess_verlist *vh = get_vertex_vhead(vv[i]);

	mov	edx, DWORD PTR tv10024[ebp]
	mov	eax, DWORD PTR tv9982[ebp]
	mov	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR _vhead_attr
	mov	eax, DWORD PTR _web+12
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+64]
	mov	edi, DWORD PTR [ecx+edx]
	shl	edi, 5
	add	edi, DWORD PTR _vhead

; 1395 :          
; 1396 :         /* self */
; 1397 :         if ( vh->proj )

	cmp	DWORD PTR [edi+16], 0
	je	SHORT $LN133@linear_met

; 1398 :         { 
; 1399 :           tr_mat_mul(vh->proj,vh->proj,temp_mat,SDIM,vh->freedom,vh->freedom);

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+16]
	mov	ebx, DWORD PTR _temp_mat$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR _web+616
	push	eax
	push	ebx
	push	ecx
	push	ecx
	call	_tr_mat_mul
	add	esp, 24					; 00000018H

; 1400 :           mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], ebx
	jmp	SHORT $LN132@linear_met
$LN133@linear_met:

; 1401 :         }
; 1402 :         else mat = identmat;

	mov	ecx, DWORD PTR _identmat
	mov	DWORD PTR _mat$[ebp], ecx
$LN132@linear_met:

; 1403 :         for ( jj = 0 ; jj < vh->freedom ; jj++ )

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR _jj$[ebp], 0
	test	eax, eax
	jle	$LN129@linear_met
	npad	13
$LL131@linear_met:

; 1404 :           for ( k = jj ; k < vh->freedom ; k++ )

	mov	ecx, DWORD PTR _jj$[ebp]
	mov	ebx, ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ecx, eax
	jge	$LN130@linear_met
$LL128@linear_met:

; 1405 :           { col = vh->rownum + k + A_OFF;

	mov	eax, DWORD PTR [edi+12]
	lea	edx, DWORD PTR [eax+ebx+1]

; 1406 :             end = M->IA[vh->rownum+jj+1]-A_OFF;

	add	eax, ecx
	mov	ecx, DWORD PTR [esi+52]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+4]

; 1407 :             for ( j = M->IA[vh->rownum+jj]-A_OFF ; j < end  ; j++ )

	mov	eax, DWORD PTR [eax]
	dec	ecx
	dec	eax
	cmp	eax, ecx
	jge	$LN731@linear_met

; 1405 :           { col = vh->rownum + k + A_OFF;

	mov	ebx, DWORD PTR [esi+56]
	lea	ebx, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR tv9746[ebp], ebx
$LL125@linear_met:

; 1408 :               if ( (M->JA[j] < A_OFF) || (M->JA[j] == col) )

	mov	ebx, DWORD PTR tv9746[ebp]
	mov	ebx, DWORD PTR [ebx]
	cmp	ebx, 1
	jl	SHORT $LN378@linear_met
	cmp	ebx, edx
	je	SHORT $LN378@linear_met

; 1407 :             for ( j = M->IA[vh->rownum+jj]-A_OFF ; j < end  ; j++ )

	add	DWORD PTR tv9746[ebp], 4
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL125@linear_met

; 1573 :      if ( M->JA[i] < A_OFF )

	mov	ebx, DWORD PTR _k$[ebp]
	jmp	SHORT $LN123@linear_met
$LN378@linear_met:

; 1409 :               { M->JA[j] = col;

	mov	ebx, DWORD PTR [esi+56]
	mov	DWORD PTR [ebx+eax*4], edx

; 1410 :                 M->A[j] += vh->slant*vh->slant*weights[i][i]*mat[jj][k];

	fld	QWORD PTR [edi+24]
	mov	edx, DWORD PTR [esi+60]
	fmul	ST(0), ST(0)
	mov	ebx, DWORD PTR tv9937[ebp]
	lea	edx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR tv6513[ebp], edx
	mov	edx, DWORD PTR tv9982[ebp]
	mov	edx, DWORD PTR [edx]
	fmul	QWORD PTR [ebx+edx]
	mov	ebx, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [edx+ebx*8]
	mov	edx, DWORD PTR tv6513[ebp]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
$LN123@linear_met:

; 1411 :                 break;
; 1412 :               }
; 1413 :               if ( j == end )

	cmp	eax, ecx
$LN731@linear_met:
	jne	SHORT $LN127@linear_met

; 1414 :                  kb_error(1856,"Internal error in linear_metric_setup.\n",
; 1415 :                     RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CI@IIDDMHOH@Internal?5error?5in?5linear_metric_@
	push	1856					; 00000740H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN127@linear_met:

; 1404 :           for ( k = jj ; k < vh->freedom ; k++ )

	mov	ecx, DWORD PTR _jj$[ebp]
	inc	ebx
	mov	DWORD PTR _k$[ebp], ebx
	cmp	ebx, DWORD PTR [edi+8]
	jl	$LL128@linear_met
$LN130@linear_met:

; 1403 :         for ( jj = 0 ; jj < vh->freedom ; jj++ )

	mov	eax, DWORD PTR [edi+8]
	inc	ecx
	mov	DWORD PTR _jj$[ebp], ecx
	cmp	ecx, eax
	jl	$LL131@linear_met
$LN129@linear_met:

; 1416 :           }
; 1417 : 
; 1418 :         /* cross terms */
; 1419 :         for ( k = 0 ; k < 3 ; k++ )

	lea	eax, DWORD PTR _vv$[ebp]
	mov	DWORD PTR tv9855[ebp], 0
	mov	DWORD PTR tv9895[ebp], eax
$LL119@linear_met:

; 1420 :         { struct hess_verlist *vvh = get_vertex_vhead(vv[k]);

	mov	eax, DWORD PTR _vhead_attr
	mov	ecx, DWORD PTR tv9895[ebp]
	imul	eax, 240				; 000000f0H
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+12
	add	eax, DWORD PTR _web+104
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ebx, DWORD PTR [edx+eax]
	shl	ebx, 5
	add	ebx, DWORD PTR _vhead

; 1421 :           if ( vvh->rownum <= vh->rownum ) continue;

	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR _vvh$90590[ebp], ebx
	cmp	ecx, DWORD PTR [edi+12]
	jle	$LN118@linear_met

; 1422 :           if ( vh->proj && vvh->proj )

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN113@linear_met
	mov	ecx, DWORD PTR [ebx+16]
	test	ecx, ecx
	je	SHORT $LN115@linear_met

; 1423 :           { tr_mat_mul(vh->proj,vvh->proj,temp_mat,SDIM,vh->freedom,
; 1424 :                vvh->freedom);

	mov	edx, DWORD PTR [ebx+8]
	push	edx
	mov	edx, DWORD PTR [edi+8]
	push	edx
	mov	edx, DWORD PTR _web+616
	push	edx
	mov	edx, DWORD PTR _temp_mat$[ebp]
	push	edx
	push	ecx
	push	eax
	call	_tr_mat_mul

; 1425 :             mat = temp_mat;

	mov	eax, DWORD PTR _temp_mat$[ebp]
	add	esp, 24					; 00000018H
	jmp	SHORT $LN110@linear_met
$LN115@linear_met:

; 1426 :           }
; 1427 :           else if ( vh->proj )
; 1428 :           { tr_mat_mul(vh->proj,identmat,temp_mat,SDIM,vh->freedom,vvh->freedom);

	mov	ecx, DWORD PTR [ebx+8]
	mov	edx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, DWORD PTR _web+616
	push	edx
	mov	edx, DWORD PTR _temp_mat$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _identmat
	push	edx
	push	ecx
	push	eax
	call	_tr_mat_mul

; 1429 :             mat = temp_mat;

	mov	eax, DWORD PTR _temp_mat$[ebp]
	add	esp, 24					; 00000018H
	jmp	SHORT $LN110@linear_met
$LN113@linear_met:

; 1430 :           }
; 1431 :           else if ( vvh->proj ) mat = vvh->proj;

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	jne	SHORT $LN110@linear_met

; 1432 :           else mat = identmat;

	mov	eax, DWORD PTR _identmat
$LN110@linear_met:

; 1433 : 
; 1434 :           for ( jj = 0 ; jj < vh->freedom ; jj++ )  

	cmp	DWORD PTR [edi+8], 0
	mov	DWORD PTR _jj$[ebp], 0
	jle	$LN118@linear_met
	mov	DWORD PTR tv9833[ebp], eax
	npad	4
$LL109@linear_met:

; 1435 :             for ( kk = 0 ; kk < vvh->freedom ; kk++ )  

	xor	eax, eax
	mov	DWORD PTR _kk$[ebp], eax
	cmp	DWORD PTR [ebx+8], eax
	jle	$LN108@linear_met
$LL620@linear_met:

; 1436 :             { col = vvh->rownum + kk + A_OFF ;

	mov	edx, DWORD PTR [ebx+12]

; 1437 :               end = M->IA[vh->rownum+jj+1]-A_OFF;

	mov	ecx, DWORD PTR [edi+12]
	add	ecx, DWORD PTR _jj$[ebp]
	lea	eax, DWORD PTR [edx+eax+1]
	mov	edx, DWORD PTR [esi+52]
	mov	DWORD PTR _col$[ebp], eax
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+4]

; 1438 :               for ( j = M->IA[vh->rownum+jj]+1-A_OFF ; ; j++ )

	mov	eax, DWORD PTR [eax]

; 1439 :                 if ( (M->JA[j] < A_OFF) || (M->JA[j] == col)  )

	mov	edx, DWORD PTR [esi+56]
	dec	ecx
	cmp	DWORD PTR [edx+eax*4], 1
	jl	SHORT $LN379@linear_met
	npad	4
$LL621@linear_met:
	mov	ebx, DWORD PTR _col$[ebp]
	cmp	DWORD PTR [edx+eax*4], ebx
	je	SHORT $LN379@linear_met
	mov	ebx, DWORD PTR [esi+56]
	inc	eax
	cmp	DWORD PTR [ebx+eax*4], 1
	jge	SHORT $LL621@linear_met
$LN379@linear_met:

; 1440 :                 { M->JA[j] = col; 

	mov	ebx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [edx+eax*4], ebx

; 1441 :                   M->A[j] += vh->slant*vvh->slant*mat[jj][kk]*weights[i][k];

	fld	QWORD PTR [edi+24]
	mov	edx, DWORD PTR [esi+60]
	mov	ebx, DWORD PTR _vvh$90590[ebp]
	fmul	QWORD PTR [ebx+24]
	mov	ebx, DWORD PTR _kk$[ebp]
	lea	edx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR tv6513[ebp], edx
	mov	edx, DWORD PTR tv9833[ebp]
	mov	edx, DWORD PTR [edx]
	fmul	QWORD PTR [edx+ebx*8]
	mov	edx, DWORD PTR tv9982[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ebx, DWORD PTR tv9855[ebp]
	fmul	QWORD PTR [ebx+edx]
	mov	edx, DWORD PTR tv6513[ebp]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]

; 1442 :                   break;
; 1443 :                 }
; 1444 :               if ( j == end )

	cmp	eax, ecx
	jne	SHORT $LN105@linear_met

; 1445 :                  kb_error(1857,"Internal error in linear_metric_setup.\n",
; 1446 :                    RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CI@IIDDMHOH@Internal?5error?5in?5linear_metric_@
	push	1857					; 00000741H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN105@linear_met:

; 1435 :             for ( kk = 0 ; kk < vvh->freedom ; kk++ )  

	mov	eax, DWORD PTR _kk$[ebp]
	mov	ebx, DWORD PTR _vvh$90590[ebp]
	inc	eax
	mov	DWORD PTR _kk$[ebp], eax
	cmp	eax, DWORD PTR [ebx+8]
	jl	$LL620@linear_met
$LN108@linear_met:

; 1433 : 
; 1434 :           for ( jj = 0 ; jj < vh->freedom ; jj++ )  

	mov	eax, DWORD PTR _jj$[ebp]
	add	DWORD PTR tv9833[ebp], 4
	inc	eax
	mov	DWORD PTR _jj$[ebp], eax
	cmp	eax, DWORD PTR [edi+8]
	jl	$LL109@linear_met
$LN118@linear_met:

; 1416 :           }
; 1417 : 
; 1418 :         /* cross terms */
; 1419 :         for ( k = 0 ; k < 3 ; k++ )

	mov	eax, DWORD PTR tv9855[ebp]
	add	DWORD PTR tv9895[ebp], 4
	add	eax, 8
	mov	DWORD PTR tv9855[ebp], eax
	cmp	eax, 24					; 00000018H
	jl	$LL119@linear_met

; 1391 : 
; 1392 :       /* fill in metric matrix */
; 1393 :       for ( i = 0 ; i < 3 ; i++ )

	mov	eax, DWORD PTR tv9937[ebp]
	add	DWORD PTR tv9982[ebp], 4
	add	eax, 8
	mov	DWORD PTR tv9937[ebp], eax
	cmp	eax, 24					; 00000018H
	jl	$LL136@linear_met
	mov	ebx, DWORD PTR _web+124
$LN164@linear_met:

; 1356 :     REAL tang[MAXCOORD];
; 1357 : 
; 1358 :     /* edge by edge */
; 1359 :     FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR tv5806[ebp]
	mov	ecx, DWORD PTR [eax+ebx]
	mov	edi, DWORD PTR [ecx]
	test	edi, 268435456				; 10000000H
	jne	$LL165@linear_met

; 1447 :             }
; 1448 :          }
; 1449 :        }
; 1450 :     }
; 1451 :   }
; 1452 :   else 

	jmp	$LN94@linear_met
$LN166@linear_met:

; 1453 :   { 
; 1454 :      REAL area;
; 1455 :      MAT2D(tang,2,MAXCOORD);

	push	2
	lea	edx, DWORD PTR _tangxJ$90617[ebp]
	push	edx
	lea	eax, DWORD PTR _tangqXvS$90616[ebp]
	push	eax
	call	_mat2d_setup

; 1456 :      MAT2D(x,FACET_CTRL,MAXCOORD);

	push	6
	push	6
	lea	ecx, DWORD PTR _xxJ$90621[ebp]
	push	ecx
	lea	edx, DWORD PTR _xqXvS$90620[ebp]
	push	edx
	mov	DWORD PTR _tang$90618[ebp], eax
	call	_mat2d_setup

; 1457 : 
; 1458 :      /* facet by facet */
; 1459 :      FOR_ALL_FACETS(f_id)

	mov	edi, DWORD PTR _web+272
	mov	ecx, edi
	shr	ecx, 28					; 0000001cH
	add	esp, 32					; 00000020H
	and	ecx, 1
	mov	DWORD PTR _x$90622[ebp], eax
	mov	DWORD PTR _f_id$[ebp], edi
	je	$LN94@linear_met
	npad	11
$LL96@linear_met:
	mov	edx, DWORD PTR _web+236
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR tv5919[ebp], eax
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	$LN95@linear_met

; 1460 :      { vertex_id ix[FACET_CTRL];
; 1461 :        REAL density = get_facet_density(f_id);

	fld	QWORD PTR [edx+32]
	fst	QWORD PTR _density$90634[ebp]

; 1462 :        facetedge_id  fe_id = get_facet_fe(f_id);

	test	ecx, ecx
	jne	SHORT $LN300@linear_met
	mov	DWORD PTR _fe_id$90636[ebp], ebx
	jmp	SHORT $LN301@linear_met
$LN300@linear_met:
	mov	edx, DWORD PTR [edx+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN299@linear_met
	xor	edx, 134217728				; 08000000H
$LN299@linear_met:
	mov	ebx, edx
	mov	DWORD PTR _fe_id$90636[ebp], edx
$LN301@linear_met:

; 1463 : 
; 1464 :        if ( density == 0.0 ) density = 1.0;

	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN91@linear_met
	fld1
	fstp	QWORD PTR _density$90634[ebp]
$LN91@linear_met:

; 1465 : 
; 1466 :        for ( i = 0 ; i < FACET_EDGES ; i++ )
; 1467 :        {
; 1468 :          ix[2*i] = get_fe_tailv(fe_id);

	mov	ecx, DWORD PTR _web+460
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edi, DWORD PTR [eax+20]
	mov	DWORD PTR tv6607[ebp], eax
	mov	eax, ebx
	and	eax, 134217728				; 08000000H
	xor	eax, edi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN306@linear_met
	mov	edx, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx+304]
	mov	edx, DWORD PTR _web+124
	mov	ebx, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
	mov	ebx, DWORD PTR _fe_id$90636[ebp]
	jmp	SHORT $LN305@linear_met
$LN306@linear_met:
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	edx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN305@linear_met:
	mov	DWORD PTR _ix$90633[ebp], eax

; 1469 :          ix[2*i+1] = get_fe_midv(fe_id);

	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR _ix$90633[ebp+4], eax

; 1470 :          fe_id = get_next_edge(fe_id);

	mov	eax, DWORD PTR tv6607[ebp]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN312@linear_met
	mov	ebx, DWORD PTR [eax+28]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN732@linear_met
$LN312@linear_met:
	mov	ebx, DWORD PTR [eax+32]
$LN732@linear_met:

; 1465 : 
; 1466 :        for ( i = 0 ; i < FACET_EDGES ; i++ )
; 1467 :        {
; 1468 :          ix[2*i] = get_fe_tailv(fe_id);

	mov	edi, DWORD PTR _web+460
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [eax+20]
	mov	DWORD PTR tv6607[ebp], eax
	mov	eax, ebx
	and	eax, 134217728				; 08000000H
	xor	eax, edi

; 1470 :          fe_id = get_next_edge(fe_id);

	mov	DWORD PTR _fe_id$90636[ebp], ebx
	test	eax, 134217728				; 08000000H
	je	SHORT $LN495@linear_met

; 1465 : 
; 1466 :        for ( i = 0 ; i < FACET_EDGES ; i++ )
; 1467 :        {
; 1468 :          ix[2*i] = get_fe_tailv(fe_id);

	mov	ebx, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
	mov	ebx, DWORD PTR _fe_id$90636[ebp]
	jmp	SHORT $LN496@linear_met
$LN495@linear_met:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN496@linear_met:
	mov	DWORD PTR _ix$90633[ebp+8], eax

; 1469 :          ix[2*i+1] = get_fe_midv(fe_id);

	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR _ix$90633[ebp+12], eax

; 1470 :          fe_id = get_next_edge(fe_id);

	mov	eax, DWORD PTR tv6607[ebp]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN497@linear_met
	mov	edi, DWORD PTR [eax+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN498@linear_met
$LN497@linear_met:
	mov	edi, DWORD PTR [eax+32]
$LN498@linear_met:

; 1465 : 
; 1466 :        for ( i = 0 ; i < FACET_EDGES ; i++ )
; 1467 :        {
; 1468 :          ix[2*i] = get_fe_tailv(fe_id);

	mov	ebx, DWORD PTR _web+460
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+20]
	and	edi, 134217728				; 08000000H
	xor	edi, eax
	test	edi, 134217728				; 08000000H
	je	SHORT $LN500@linear_met
	mov	ebx, DWORD PTR _web+636
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+edi*4]
	lea	edi, DWORD PTR [edi+ebx*4]
	mov	edi, DWORD PTR [edi+ecx]
	jmp	SHORT $LN501@linear_met
$LN500@linear_met:
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+edi*4]
	mov	edi, DWORD PTR [ecx+edi]
$LN501@linear_met:

; 1469 :          ix[2*i+1] = get_fe_midv(fe_id);

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _ix$90633[ebp+16], edi

; 1471 :        }
; 1472 :        area = get_facet_area(f_id);

	mov	edi, DWORD PTR _f_id$[ebp]
	push	edi
	mov	DWORD PTR _ix$90633[ebp+20], eax
	call	_recalc_facet_area
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR tv5919[ebp]
	mov	eax, DWORD PTR [edx+ecx]

; 1473 :        for ( i = 0 ; i < FACET_CTRL ; i++ ) 
; 1474 :           ii[i] = loc_ordinal(ix[i]);
; 1475 : 
; 1476 :        /* weight matrix */
; 1477 :        get_facet_verts(f_id,x,NULL);

	mov	ecx, DWORD PTR _x$90622[ebp]
	fld	QWORD PTR [eax+40]
	push	0
	fstp	QWORD PTR _area$90615[ebp]
	push	ecx
	push	edi
	call	_get_facet_verts

; 1478 :        for ( i = 0 ; i < FACET_CTRL ; i++ )
; 1479 :          for ( j = 0 ; j < FACET_CTRL ; j++ ) weights[i][j] = 0.0;

	fldz
	mov	ebx, DWORD PTR _weights$[ebp]
	mov	eax, DWORD PTR [ebx]
	fst	QWORD PTR [eax]
	mov	ecx, DWORD PTR [ebx+4]
	fst	QWORD PTR [eax+8]
	mov	edx, DWORD PTR [ebx+8]
	fst	QWORD PTR [eax+16]
	mov	edi, DWORD PTR [ebx+12]
	fst	QWORD PTR [eax+24]
	mov	ebx, DWORD PTR [ebx+16]
	fst	QWORD PTR [eax+32]
	add	esp, 16					; 00000010H
	fst	QWORD PTR [eax+40]
	fst	QWORD PTR [ecx]
	fst	QWORD PTR [ecx+8]
	fst	QWORD PTR [ecx+16]
	fst	QWORD PTR [ecx+24]
	fst	QWORD PTR [ecx+32]
	fst	QWORD PTR [ecx+40]
	fst	QWORD PTR [edx]
	fst	QWORD PTR [edx+8]
	fst	QWORD PTR [edx+16]
	fst	QWORD PTR [edx+24]
	fst	QWORD PTR [edx+32]
	fst	QWORD PTR [edx+40]
	fst	QWORD PTR [edi]
	fst	QWORD PTR [edi+8]
	fst	QWORD PTR [edi+16]
	fst	QWORD PTR [edi+24]
	fst	QWORD PTR [edi+32]
	fst	QWORD PTR [edi+40]
	fst	QWORD PTR [ebx]
	fst	QWORD PTR [ebx+8]
	fst	QWORD PTR [ebx+16]
	fst	QWORD PTR [ebx+24]
	fst	QWORD PTR [ebx+32]
	fst	QWORD PTR [ebx+40]
	mov	ebx, DWORD PTR _weights$[ebp]
	mov	ebx, DWORD PTR [ebx+20]
	fst	QWORD PTR [ebx]
	fst	QWORD PTR [ebx+8]
	fst	QWORD PTR [ebx+16]
	fst	QWORD PTR [ebx+24]
	fst	QWORD PTR [ebx+32]
	fstp	QWORD PTR [ebx+40]

; 1480 :        /* simple vertex weighting part */
; 1481 :        for ( i = 0 ; i < 3 ; i++ )
; 1482 :        { weights[2*i][2*i] = (1-quadratic_metric_mix)/12*area; 

	fld1
	fld	QWORD PTR _quadratic_metric_mix
	fsubr	ST(0), ST(1)
	fld	QWORD PTR __real@4028000000000000
	fdiv	ST(1), ST(0)
	fld	QWORD PTR _area$90615[ebp]
	fmul	ST(2), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR [eax]

; 1483 :          weights[2*i+1][2*i+1] = (1-quadratic_metric_mix)/4*area;

	fld	ST(2)
	fsub	QWORD PTR _quadratic_metric_mix
	fld	QWORD PTR __real@3fd0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	fstp	QWORD PTR [ecx+8]
	fld	ST(3)

; 1480 :        /* simple vertex weighting part */
; 1481 :        for ( i = 0 ; i < 3 ; i++ )
; 1482 :        { weights[2*i][2*i] = (1-quadratic_metric_mix)/12*area; 

	fsub	QWORD PTR _quadratic_metric_mix
	fdiv	ST(0), ST(2)
	fmul	ST(0), ST(3)
	fstp	QWORD PTR [edx+16]
	mov	edx, DWORD PTR _weights$[ebp]

; 1483 :          weights[2*i+1][2*i+1] = (1-quadratic_metric_mix)/4*area;

	fld	ST(3)
	mov	eax, DWORD PTR [edx+16]
	fsub	QWORD PTR _quadratic_metric_mix
	fmul	ST(0), ST(1)
	fmul	ST(0), ST(3)
	fstp	QWORD PTR [edi+24]
	fld	ST(3)
	fsub	QWORD PTR _quadratic_metric_mix
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [eax+32]
	fxch	ST(2)
	fsub	QWORD PTR _quadratic_metric_mix
	fmulp	ST(2), ST(0)
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR [ebx+40]

; 1484 :        }
; 1485 : 
; 1486 :        for ( m = 0 ; m < gauss2D_num ; m++ )

	xor	ebx, ebx
	mov	DWORD PTR _m$[ebp], ebx
	cmp	DWORD PTR _gauss2D_num, ebx
	jle	$LN624@linear_met
$LL631@linear_met:

; 1487 :        { REAL value,ss,st,tt,det;
; 1488 :          mat_mult(gpolypartial[m],x,tang,web.dimension,FACET_CTRL,SDIM);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _web+620
	mov	edi, DWORD PTR _tang$90618[ebp]
	mov	ecx, DWORD PTR _x$90622[ebp]
	push	edx
	mov	edx, DWORD PTR _gpolypartial
	push	6
	push	eax
	mov	eax, DWORD PTR [edx+ebx*4]
	push	edi
	push	ecx
	push	eax
	call	_mat_mult

; 1489 :          ss = SDIM_dot(tang[0],tang[0]);

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [edi]
	push	ecx
	push	eax
	push	eax
	call	_dot
	fstp	QWORD PTR _ss$90665[ebp]

; 1490 :          st = SDIM_dot(tang[0],tang[1]);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	push	edx
	push	eax
	push	ecx
	call	_dot
	fstp	QWORD PTR _st$90666[ebp]

; 1491 :          tt = SDIM_dot(tang[1],tang[1]);

	mov	edx, DWORD PTR _web+616
	mov	edi, DWORD PTR [edi+4]
	push	edx
	push	edi
	push	edi
	call	_dot

; 1492 :          det = ss*tt - st*st;

	fmul	QWORD PTR _ss$90665[ebp]
	fld	QWORD PTR _st$90666[ebp]
	add	esp, 60					; 0000003cH
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)

; 1493 :          value = gauss2Dwt[m]*sqrt(det)/2; /* with triangle factor */

	call	__CIsqrt
	mov	eax, DWORD PTR _gauss2Dwt
	fmul	QWORD PTR [eax+ebx*8]
	mov	ecx, DWORD PTR _gpoly
	mov	eax, DWORD PTR [ecx+ebx*4]
	mov	edx, eax
	fmul	QWORD PTR __real@3fe0000000000000

; 1494 :          for ( i = 0 ; i < FACET_CTRL ; i++ )

	mov	ebx, eax
	xor	edi, edi
	sub	ebx, edx
	mov	DWORD PTR tv6885[ebp], eax
	mov	ecx, edx
	mov	DWORD PTR tv10278[ebp], ebx
	jmp	SHORT $LN72@linear_met
$LN632@linear_met:
	mov	ebx, DWORD PTR tv10278[ebp]
$LN72@linear_met:

; 1495 :          { for ( j = 0 ; j < FACET_CTRL ; j++ )
; 1496 :             weights[i][j] += quadratic_metric_mix*value*gpoly[m][i]*gpoly[m][j];

	fld	QWORD PTR _quadratic_metric_mix
	mov	eax, DWORD PTR _weights$[ebp]
	mov	eax, DWORD PTR [eax+edi*4]
	fmul	ST(0), ST(1)
	inc	edi
	add	ecx, 8
	fmul	QWORD PTR [ecx+ebx-8]
	mov	ebx, DWORD PTR tv6885[ebp]
	fmul	QWORD PTR [ebx]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	fld	QWORD PTR _quadratic_metric_mix
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ecx-8]
	fmul	QWORD PTR [edx+8]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	fld	QWORD PTR _quadratic_metric_mix
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ecx-8]
	fmul	QWORD PTR [edx+16]
	fadd	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+16]
	fld	QWORD PTR _quadratic_metric_mix
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ecx-8]
	fmul	QWORD PTR [edx+24]
	fadd	QWORD PTR [eax+24]
	fstp	QWORD PTR [eax+24]
	fld	QWORD PTR _quadratic_metric_mix
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ecx-8]
	fmul	QWORD PTR [edx+32]
	fadd	QWORD PTR [eax+32]
	fstp	QWORD PTR [eax+32]
	fld	QWORD PTR _quadratic_metric_mix
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ecx-8]
	fmul	QWORD PTR [edx+40]
	fadd	QWORD PTR [eax+40]
	fstp	QWORD PTR [eax+40]
	cmp	edi, 6
	jl	$LN632@linear_met

; 1494 :          for ( i = 0 ; i < FACET_CTRL ; i++ )

	mov	ebx, DWORD PTR _m$[ebp]
	fstp	ST(0)
	inc	ebx
	mov	DWORD PTR _m$[ebp], ebx
	cmp	ebx, DWORD PTR _gauss2D_num
	jl	$LL631@linear_met

; 1484 :        }
; 1485 : 
; 1486 :        for ( m = 0 ; m < gauss2D_num ; m++ )

	mov	edx, DWORD PTR _weights$[ebp]
$LN624@linear_met:

; 1497 :          }
; 1498 :        }
; 1499 :        for ( i = 0 ; i < FACET_CTRL ; i++ )

	fld	QWORD PTR _density$90634[ebp]
	xor	ecx, ecx
$LN66@linear_met:

; 1500 :          for ( j = 0 ; j < FACET_CTRL ; j++ ) 
; 1501 :            weights[i][j] *= density;

	mov	eax, DWORD PTR [edx+ecx*4]
	fld	QWORD PTR [eax]
	inc	ecx
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax]
	fld	QWORD PTR [eax+8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax+8]
	fld	QWORD PTR [eax+16]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax+16]
	fld	QWORD PTR [eax+24]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax+24]
	fld	QWORD PTR [eax+32]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax+32]
	fld	QWORD PTR [eax+40]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax+40]
	cmp	ecx, 6
	jl	SHORT $LN66@linear_met

; 1502 : 
; 1503 :        for ( i = 0 ; i < FACET_CTRL ; i++ )

	lea	eax, DWORD PTR _ix$90633[ebp]
	fstp	ST(0)
	sub	eax, edx
	mov	DWORD PTR tv10739[ebp], 0
	mov	DWORD PTR tv10794[ebp], edx
	mov	DWORD PTR tv10845[ebp], eax
	npad	4
$LL60@linear_met:

; 1504 :        { struct hess_verlist *v = get_vertex_vhead(ix[i]);

	mov	ecx, DWORD PTR tv10845[ebp]
	mov	edx, DWORD PTR tv10794[ebp]
	mov	eax, DWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR _vhead_attr
	mov	edx, DWORD PTR _web+12
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+64]
	mov	edi, DWORD PTR [eax+ecx]
	shl	edi, 5
	add	edi, DWORD PTR _vhead

; 1505 : 
; 1506 :          /* self */
; 1507 :          if ( v->proj )

	cmp	DWORD PTR [edi+16], 0
	mov	DWORD PTR _v$90684[ebp], edi
	je	SHORT $LN57@linear_met

; 1508 :          { 
; 1509 :            tr_mat_mul(v->proj,v->proj,temp_mat,SDIM,v->freedom,v->freedom);

	mov	eax, DWORD PTR [edi+8]
	mov	edx, DWORD PTR _web+616
	mov	ecx, DWORD PTR [edi+16]
	mov	ebx, DWORD PTR _temp_mat$[ebp]
	push	eax
	push	eax
	push	edx
	push	ebx
	push	ecx
	push	ecx
	call	_tr_mat_mul
	add	esp, 24					; 00000018H

; 1510 :            mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], ebx
	jmp	SHORT $LN56@linear_met
$LN57@linear_met:

; 1511 :          }
; 1512 :          else mat = identmat;

	mov	eax, DWORD PTR _identmat
	mov	DWORD PTR _mat$[ebp], eax
$LN56@linear_met:

; 1513 : 
; 1514 :          for ( jj = 0 ; jj < v->freedom ; jj++ )

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR _jj$[ebp], 0
	test	eax, eax
	jle	$LN53@linear_met
	npad	7
$LL55@linear_met:

; 1515 :            for ( k = jj ; k < v->freedom ; k++ )

	mov	ecx, DWORD PTR _jj$[ebp]
	mov	ebx, ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ecx, eax
	jge	$LN54@linear_met
$LL52@linear_met:

; 1516 :            { col = v->rownum + k + A_OFF;

	mov	eax, DWORD PTR [edi+12]
	lea	edx, DWORD PTR [eax+ebx+1]

; 1517 :              end = M->IA[v->rownum+jj+1]-A_OFF;

	add	eax, ecx
	mov	ecx, DWORD PTR [esi+52]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+4]

; 1518 :              for ( j = M->IA[v->rownum+jj]-A_OFF ; j < end  ; j++ )

	mov	eax, DWORD PTR [eax]
	dec	ecx
	dec	eax
	cmp	eax, ecx
	jge	SHORT $LN733@linear_met

; 1516 :            { col = v->rownum + k + A_OFF;

	mov	ebx, DWORD PTR [esi+56]
	lea	ebx, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR tv10511[ebp], ebx
	npad	4
$LL49@linear_met:

; 1519 :                if ( (M->JA[j] < A_OFF) || (M->JA[j] == col) )

	mov	ebx, DWORD PTR tv10511[ebp]
	mov	ebx, DWORD PTR [ebx]
	cmp	ebx, 1
	jl	SHORT $LN380@linear_met
	cmp	ebx, edx
	je	SHORT $LN380@linear_met

; 1518 :              for ( j = M->IA[v->rownum+jj]-A_OFF ; j < end  ; j++ )

	add	DWORD PTR tv10511[ebp], 4
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL49@linear_met

; 1573 :      if ( M->JA[i] < A_OFF )

	mov	ebx, DWORD PTR _k$[ebp]
	jmp	SHORT $LN47@linear_met
$LN380@linear_met:

; 1520 :                { M->JA[j] = col;

	mov	ebx, DWORD PTR [esi+56]
	mov	DWORD PTR [ebx+eax*4], edx

; 1521 :                  M->A[j] += v->slant*v->slant*weights[i][i]*mat[jj][k];

	fld	QWORD PTR [edi+24]
	mov	edi, DWORD PTR tv10794[ebp]
	fmul	ST(0), ST(0)
	mov	edi, DWORD PTR [edi]
	mov	ebx, DWORD PTR tv10739[ebp]
	fmul	QWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR _jj$[ebp]
	mov	edi, DWORD PTR _mat$[ebp]
	mov	edi, DWORD PTR [edi+ebx*4]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [edi+ebx*8]
	mov	edx, DWORD PTR [esi+60]
	mov	edi, DWORD PTR _v$90684[ebp]
	lea	edx, DWORD PTR [edx+eax*8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
$LN47@linear_met:

; 1522 :                  break;
; 1523 :                }
; 1524 :                if ( j == end )

	cmp	eax, ecx
$LN733@linear_met:
	jne	SHORT $LN51@linear_met

; 1525 :                   kb_error(1858,"Internal error in linear_metric_setup.\n",
; 1526 :                       RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CI@IIDDMHOH@Internal?5error?5in?5linear_metric_@
	push	1858					; 00000742H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN51@linear_met:

; 1515 :            for ( k = jj ; k < v->freedom ; k++ )

	mov	ecx, DWORD PTR _jj$[ebp]
	inc	ebx
	mov	DWORD PTR _k$[ebp], ebx
	cmp	ebx, DWORD PTR [edi+8]
	jl	$LL52@linear_met
$LN54@linear_met:

; 1513 : 
; 1514 :          for ( jj = 0 ; jj < v->freedom ; jj++ )

	mov	eax, DWORD PTR [edi+8]
	inc	ecx
	mov	DWORD PTR _jj$[ebp], ecx
	cmp	ecx, eax
	jl	$LL55@linear_met
$LN53@linear_met:

; 1527 :            }
; 1528 : 
; 1529 :          /* cross terms */
; 1530 :          for ( k = 0 ; k < FACET_CTRL ; k++ )

	lea	eax, DWORD PTR _ix$90633[ebp]
	mov	DWORD PTR tv10657[ebp], 0
	mov	DWORD PTR tv10697[ebp], eax
	npad	4
$LL43@linear_met:

; 1531 :          { struct hess_verlist *vv = get_vertex_vhead(ix[k]);

	mov	eax, DWORD PTR _vhead_attr
	mov	ecx, DWORD PTR tv10697[ebp]
	imul	eax, 240				; 000000f0H
	mov	edx, DWORD PTR [ecx]
	add	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR [edx+eax]

; 1532 :             
; 1533 :           //if ( ii[k] <= ii[i] ) continue;
; 1534 :             if ( vv->rownum <= v->rownum ) 

	mov	edx, DWORD PTR _v$90684[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _vhead
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _vv$90706[ebp], eax
	cmp	ecx, DWORD PTR [edx+12]
	jle	$LN42@linear_met

; 1535 :                continue;
; 1536 : 
; 1537 :             if ( v->proj && vv->proj )

	mov	edi, edx
	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN37@linear_met
	mov	ecx, DWORD PTR _vv$90706[ebp]
	mov	edx, DWORD PTR [ecx+16]

; 1538 :             { tr_mat_mul(v->proj,vv->proj,temp_mat,SDIM,v->freedom,vv->freedom);

	mov	ebx, DWORD PTR _temp_mat$[ebp]
	test	edx, edx
	je	SHORT $LN39@linear_met
	mov	ecx, DWORD PTR [ecx+8]
	push	ecx
	mov	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, DWORD PTR _web+616
	push	ecx
	push	ebx
	push	edx
	push	eax
	call	_tr_mat_mul
	add	esp, 24					; 00000018H

; 1539 :               mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], ebx
	jmp	SHORT $LN34@linear_met
$LN39@linear_met:

; 1540 :             }
; 1541 :             else if ( v->proj )
; 1542 :             { tr_mat_mul(v->proj,identmat,temp_mat,SDIM,v->freedom,vv->freedom);

	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [edi+8]
	push	edx
	mov	edx, DWORD PTR _web+616
	push	ecx
	mov	ecx, DWORD PTR _identmat
	push	edx
	push	ebx
	push	ecx
	push	eax
	call	_tr_mat_mul
	add	esp, 24					; 00000018H

; 1543 :               mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], ebx
	jmp	SHORT $LN34@linear_met
$LN37@linear_met:

; 1544 :             }
; 1545 :             else if ( vv->proj ) mat = vv->proj;

	mov	edx, DWORD PTR _vv$90706[ebp]
	mov	eax, DWORD PTR [edx+16]
	test	eax, eax
	jne	SHORT $LN734@linear_met

; 1546 :             else mat = identmat;

	mov	eax, DWORD PTR _identmat
$LN734@linear_met:
	mov	DWORD PTR _mat$[ebp], eax
$LN34@linear_met:

; 1547 : 
; 1548 : 
; 1549 :             for ( jj = 0 ; jj < v->freedom ; jj++ )  

	cmp	DWORD PTR [edi+8], 0
	mov	DWORD PTR _jj$[ebp], 0
	jle	$LN42@linear_met
	npad	8
$LL33@linear_met:

; 1550 :               for ( kk = 0 ; kk < vv->freedom ; kk++ )  

	mov	ecx, DWORD PTR _vv$90706[ebp]
	cmp	DWORD PTR [ecx+8], 0
	mov	DWORD PTR _kk$[ebp], 0
	jle	$LN32@linear_met
	npad	6
$LL30@linear_met:

; 1551 :               { col = vv->rownum + kk + A_OFF ;

	mov	edx, DWORD PTR _vv$90706[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _kk$[ebp]
	lea	edx, DWORD PTR [eax+ecx+1]

; 1552 :                 end = M->IA[v->rownum+jj+1]-A_OFF;

	mov	eax, DWORD PTR _v$90684[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _jj$[ebp]
	mov	DWORD PTR _col$[ebp], edx
	mov	edx, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR [edx+ecx*4+4]

; 1553 :                 for ( j = M->IA[v->rownum+jj]+1-A_OFF ; j < end ; j++ )

	mov	edi, DWORD PTR [edx+ecx*4]
	lea	eax, DWORD PTR [edx+ecx*4]
	dec	ebx
	cmp	edi, ebx
	jge	$LN735@linear_met

; 1551 :               { col = vv->rownum + kk + A_OFF ;

	mov	edx, DWORD PTR [esi+56]
	lea	eax, DWORD PTR [edx+edi*4]
$LL628@linear_met:

; 1554 :                   if ( (M->JA[j] < A_OFF) || (M->JA[j] == col)  )

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 1
	jl	SHORT $LN629@linear_met
	cmp	ecx, DWORD PTR _col$[ebp]
	je	SHORT $LN629@linear_met

; 1553 :                 for ( j = M->IA[v->rownum+jj]+1-A_OFF ; j < end ; j++ )

	inc	edi
	add	eax, 4
	cmp	edi, ebx
	jl	SHORT $LL628@linear_met

; 1573 :      if ( M->JA[i] < A_OFF )

	jmp	SHORT $LN25@linear_met
$LN629@linear_met:

; 1555 :                   { M->JA[j] = col; 

	mov	eax, DWORD PTR _col$[ebp]

; 1556 : if ( col <= v->rownum+jj+1 )

	mov	ecx, DWORD PTR _v$90684[ebp]
	mov	DWORD PTR [edx+edi*4], eax
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _jj$[ebp]
	lea	edx, DWORD PTR [edx+ecx+1]
	cmp	eax, edx
	jg	SHORT $LN22@linear_met

; 1557 :   fprintf(stderr,"Bad col < row\n");

	push	OFFSET ??_C@_0P@EGKIEAM@Bad?5col?5?$DM?5row?6?$AA@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 8
$LN22@linear_met:

; 1558 :                     M->A[j] += v->slant*vv->slant*mat[jj][kk]*weights[i][k];

	mov	edx, DWORD PTR _jj$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _vv$90706[ebp]
	fld	QWORD PTR [edx+24]
	mov	edx, DWORD PTR _v$90684[ebp]
	fmul	QWORD PTR [edx+24]
	mov	edx, DWORD PTR _kk$[ebp]
	mov	eax, DWORD PTR [esi+60]
	lea	eax, DWORD PTR [eax+edi*8]
	fmul	QWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR tv10794[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv10657[ebp]
	fmul	QWORD PTR [edx+ecx]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
$LN25@linear_met:

; 1559 :                     break;
; 1560 :                   }
; 1561 :                 if ( j == end )

	cmp	edi, ebx
$LN735@linear_met:
	jne	SHORT $LN29@linear_met

; 1562 :                    kb_error(1859,
; 1563 :      "Internal error: Bad j in linear_metric_setup_quadratic().\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DL@DKAEFLCJ@Internal?5error?3?5Bad?5j?5in?5linear_@
	push	1859					; 00000743H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN29@linear_met:

; 1550 :               for ( kk = 0 ; kk < vv->freedom ; kk++ )  

	mov	eax, DWORD PTR _kk$[ebp]
	mov	edx, DWORD PTR _vv$90706[ebp]
	inc	eax
	mov	DWORD PTR _kk$[ebp], eax
	cmp	eax, DWORD PTR [edx+8]
	jl	$LL30@linear_met
$LN32@linear_met:

; 1547 : 
; 1548 : 
; 1549 :             for ( jj = 0 ; jj < v->freedom ; jj++ )  

	mov	eax, DWORD PTR _jj$[ebp]
	mov	ecx, DWORD PTR _v$90684[ebp]
	inc	eax
	mov	DWORD PTR _jj$[ebp], eax
	cmp	eax, DWORD PTR [ecx+8]
	jl	$LL33@linear_met
$LN42@linear_met:

; 1527 :            }
; 1528 : 
; 1529 :          /* cross terms */
; 1530 :          for ( k = 0 ; k < FACET_CTRL ; k++ )

	mov	eax, DWORD PTR tv10657[ebp]
	add	DWORD PTR tv10697[ebp], 4
	add	eax, 8
	mov	DWORD PTR tv10657[ebp], eax
	cmp	eax, 48					; 00000030H
	jl	$LL43@linear_met

; 1502 : 
; 1503 :        for ( i = 0 ; i < FACET_CTRL ; i++ )

	mov	eax, DWORD PTR tv10739[ebp]
	add	DWORD PTR tv10794[ebp], 4
	add	eax, 8
	mov	DWORD PTR tv10739[ebp], eax
	cmp	eax, 48					; 00000030H
	jl	$LL60@linear_met
$LN95@linear_met:

; 1457 : 
; 1458 :      /* facet by facet */
; 1459 :      FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR tv5919[ebp]
	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [edx+eax]
	mov	edi, DWORD PTR [ecx]
	mov	ecx, edi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _f_id$[ebp], edi
	jne	$LL96@linear_met
$LN94@linear_met:

; 1564 : 
; 1565 :               }
; 1566 :            }
; 1567 :         }
; 1568 :      }
; 1569 :   }
; 1570 : 
; 1571 :   /* compact matrix by looking for -1 in M->JA */
; 1572 :   for ( i = 0 ; i < M->IA[M->N]-A_OFF ; i++ )

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [eax+edx*4]
	dec	ecx
	xor	edi, edi
	test	ecx, ecx
	jle	SHORT $LN625@linear_met
	mov	eax, DWORD PTR [esi+56]
	npad	3
$LL20@linear_met:

; 1573 :      if ( M->JA[i] < A_OFF )

	cmp	DWORD PTR [eax], 1
	jl	SHORT $LN382@linear_met

; 1564 : 
; 1565 :               }
; 1566 :            }
; 1567 :         }
; 1568 :      }
; 1569 :   }
; 1570 : 
; 1571 :   /* compact matrix by looking for -1 in M->JA */
; 1572 :   for ( i = 0 ; i < M->IA[M->N]-A_OFF ; i++ )

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+edx*4]
	inc	edi
	dec	edx
	add	eax, 4
	cmp	edi, edx
	jl	SHORT $LL20@linear_met

; 1573 :      if ( M->JA[i] < A_OFF )

	jmp	SHORT $LN625@linear_met
$LN382@linear_met:

; 1574 :      { kb_error(1860,"Internal error: Empty spot in Met.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CE@BLKAPKBA@Internal?5error?3?5Empty?5spot?5in?5Me@
	push	1860					; 00000744H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN625@linear_met:

; 1575 :         break;
; 1576 :      }
; 1577 :   if ( i < M->IA[M->N]-A_OFF )

	mov	ebx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [eax+ebx*4]
	dec	ecx
	cmp	edi, ecx
	jge	$LN648@linear_met

; 1578 :   { int *ja_to_spot = M->JA,*ja_from_spot = M->JA;

	mov	ecx, DWORD PTR [esi+56]

; 1579 :      REAL *a_to_spot= M->A,*a_from_spot= M->A;

	mov	eax, DWORD PTR [esi+60]

; 1580 :      for ( i = 0 ; i < M->N ; i++ )

	xor	edx, edx
	mov	edi, ecx
	mov	DWORD PTR _ja_from_spot$90740[ebp], edi
	mov	DWORD PTR _a_from_spot$90742[ebp], eax
	mov	DWORD PTR _i$[ebp], edx
	test	ebx, ebx
	jle	$LN648@linear_met
$LL15@linear_met:
	mov	ebx, DWORD PTR [esi+52]
	lea	edx, DWORD PTR [ebx+edx*4]

; 1581 :      { end = M->IA[i+1]-A_OFF;

	mov	ebx, DWORD PTR [edx+4]

; 1582 :         for ( j = M->IA[i]-A_OFF ; j < end ; j++,ja_from_spot++,a_from_spot++ )

	mov	edx, DWORD PTR [edx]
	dec	ebx
	dec	edx
	mov	DWORD PTR _end$[ebp], ebx
	cmp	edx, ebx
	jge	$LN14@linear_met
	sub	ebx, edx
	cmp	ebx, 4
	jl	$LC604@linear_met
	npad	7
$LL635@linear_met:

; 1583 :         { if ( M->JA[j] >= A_OFF )

	mov	ebx, DWORD PTR [esi+56]
	cmp	DWORD PTR [ebx+edx*4], 1
	jl	SHORT $LN605@linear_met

; 1584 :           { *ja_to_spot = *ja_from_spot;

	mov	ebx, DWORD PTR [edi]
	mov	DWORD PTR [ecx], ebx

; 1585 :              *a_to_spot  = *a_from_spot;

	mov	ebx, DWORD PTR _a_from_spot$90742[ebp]
	fld	QWORD PTR [ebx]

; 1586 :              a_to_spot++; ja_to_spot++;

	add	eax, 8
	fstp	QWORD PTR [eax-8]
	add	ecx, 4
$LN605@linear_met:

; 1583 :         { if ( M->JA[j] >= A_OFF )

	mov	ebx, DWORD PTR [esi+56]
	cmp	DWORD PTR [ebx+edx*4+4], 1
	jl	SHORT $LN606@linear_met

; 1584 :           { *ja_to_spot = *ja_from_spot;

	mov	edi, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx], edi

; 1585 :              *a_to_spot  = *a_from_spot;

	mov	edi, DWORD PTR _a_from_spot$90742[ebp]
	fld	QWORD PTR [edi+8]

; 1586 :              a_to_spot++; ja_to_spot++;

	add	eax, 8
	fstp	QWORD PTR [eax-8]
	add	ecx, 4
$LN606@linear_met:

; 1583 :         { if ( M->JA[j] >= A_OFF )

	mov	edi, DWORD PTR [esi+56]
	cmp	DWORD PTR [edi+edx*4+8], 1
	jl	SHORT $LN607@linear_met

; 1584 :           { *ja_to_spot = *ja_from_spot;

	mov	edi, DWORD PTR _ja_from_spot$90740[ebp]
	mov	edi, DWORD PTR [edi+8]
	mov	DWORD PTR [ecx], edi

; 1585 :              *a_to_spot  = *a_from_spot;

	mov	edi, DWORD PTR _a_from_spot$90742[ebp]
	fld	QWORD PTR [edi+16]

; 1586 :              a_to_spot++; ja_to_spot++;

	add	eax, 8
	fstp	QWORD PTR [eax-8]
	add	ecx, 4
$LN607@linear_met:

; 1583 :         { if ( M->JA[j] >= A_OFF )

	mov	edi, DWORD PTR [esi+56]
	cmp	DWORD PTR [edi+edx*4+12], 1

; 1584 :           { *ja_to_spot = *ja_from_spot;

	mov	edi, DWORD PTR _ja_from_spot$90740[ebp]
	jl	SHORT $LN608@linear_met
	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [ecx], ebx

; 1585 :              *a_to_spot  = *a_from_spot;

	mov	ebx, DWORD PTR _a_from_spot$90742[ebp]
	fld	QWORD PTR [ebx+24]

; 1586 :              a_to_spot++; ja_to_spot++;

	add	eax, 8
	fstp	QWORD PTR [eax-8]
	add	ecx, 4
$LN608@linear_met:

; 1587 :           }
; 1588 :         }
; 1589 :      }
; 1590 :   }
; 1591 : 
; 1592 :   // Seems that JA is not always properly sorted, so check that, and
; 1593 :   // bubblesort each row.
; 1594 :   for ( i = 0 ; i < M->N ; i++ )

	mov	ebx, DWORD PTR _end$[ebp]
	add	DWORD PTR _a_from_spot$90742[ebp], 32	; 00000020H
	add	edi, 16					; 00000010H
	add	edx, 4
	add	ebx, -3					; fffffffdH
	mov	DWORD PTR _ja_from_spot$90740[ebp], edi
	cmp	edx, ebx
	jl	$LL635@linear_met
$LC604@linear_met:

; 1582 :         for ( j = M->IA[i]-A_OFF ; j < end ; j++,ja_from_spot++,a_from_spot++ )

	cmp	edx, DWORD PTR _end$[ebp]
	jge	SHORT $LN14@linear_met
	npad	7
$LC12@linear_met:

; 1583 :         { if ( M->JA[j] >= A_OFF )

	mov	ebx, DWORD PTR [esi+56]
	cmp	DWORD PTR [ebx+edx*4], 1
	jl	SHORT $LN11@linear_met

; 1584 :           { *ja_to_spot = *ja_from_spot;

	mov	ebx, DWORD PTR [edi]
	mov	DWORD PTR [ecx], ebx

; 1585 :              *a_to_spot  = *a_from_spot;

	mov	ebx, DWORD PTR _a_from_spot$90742[ebp]
	fld	QWORD PTR [ebx]

; 1586 :              a_to_spot++; ja_to_spot++;

	add	eax, 8
	fstp	QWORD PTR [eax-8]
	add	ecx, 4
$LN11@linear_met:

; 1582 :         for ( j = M->IA[i]-A_OFF ; j < end ; j++,ja_from_spot++,a_from_spot++ )

	add	DWORD PTR _a_from_spot$90742[ebp], 8
	inc	edx
	add	edi, 4
	cmp	edx, DWORD PTR _end$[ebp]
	jl	SHORT $LC12@linear_met
	mov	DWORD PTR _ja_from_spot$90740[ebp], edi
$LN14@linear_met:

; 1580 :      for ( i = 0 ; i < M->N ; i++ )

	mov	edx, DWORD PTR _i$[ebp]
	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, DWORD PTR [esi+4]
	jl	$LL15@linear_met
$LN648@linear_met:

; 1587 :           }
; 1588 :         }
; 1589 :      }
; 1590 :   }
; 1591 : 
; 1592 :   // Seems that JA is not always properly sorted, so check that, and
; 1593 :   // bubblesort each row.
; 1594 :   for ( i = 0 ; i < M->N ; i++ )

	xor	ecx, ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR [esi+4], ecx
	jle	$LN6@linear_met
	npad	2
$LL655@linear_met:
	mov	edx, DWORD PTR [esi+52]

; 1595 :   { int ii = M->IA[i]-A_OFF;

	mov	edi, DWORD PTR [edx+ecx*4]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1596 :     int jj = M->IA[i+1]-A_OFF;
; 1597 :     { for (  j = ii+1 ; j < M->IA[i+1]-A_OFF ; j++ )

	mov	eax, DWORD PTR [eax+4]
	dec	edi
	lea	edx, DWORD PTR [edi+1]
	dec	eax
	mov	DWORD PTR _ii$90753[ebp], edi
	mov	DWORD PTR _j$[ebp], edx
	cmp	edx, eax
	jge	$LN7@linear_met

; 1595 :   { int ii = M->IA[i]-A_OFF;

	lea	ecx, DWORD PTR [edx*8-16]
	mov	eax, edx
	mov	DWORD PTR tv11456[ebp], ecx
	sub	eax, edi
	lea	ecx, DWORD PTR [edx*4-8]
	mov	DWORD PTR tv11445[ebp], eax
	mov	DWORD PTR tv11458[ebp], ecx
	npad	7
$LL654@linear_met:
	cmp	edx, edi
	jle	$LN4@linear_met

; 1598 :       { k = j;
; 1599 :         while ( k > ii && M->JA[k] < M->JA[k-1] )

	cmp	eax, 4
	jl	$LC610@linear_met

; 1605 :           M->JA[k] = itemp;

	mov	eax, DWORD PTR tv11458[ebp]
	mov	ecx, DWORD PTR tv11456[ebp]
	npad	3
$LL614@linear_met:

; 1598 :       { k = j;
; 1599 :         while ( k > ii && M->JA[k] < M->JA[k-1] )

	mov	edi, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [eax+edi+4]
	lea	edi, DWORD PTR [eax+edi+8]
	mov	DWORD PTR tv11328[ebp], ebx
	cmp	DWORD PTR [edi], ebx
	jge	$LN630@linear_met

; 1600 :         { REAL temp = M->A[k-1];

	mov	edi, DWORD PTR [esi+60]
	fld	QWORD PTR [edi+ecx+8]
	lea	edi, DWORD PTR [edi+ecx+16]

; 1601 :           int itemp = M->JA[k-1];
; 1602 :           M->A[k-1] = M->A[k];

	fld	QWORD PTR [edi]
	fstp	QWORD PTR [edi-8]

; 1603 :           M->A[k] = temp;

	mov	edi, DWORD PTR [esi+60]
	fstp	QWORD PTR [ecx+edi+16]

; 1604 :           M->JA[k-1] = M->JA[k];

	mov	edi, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [eax+edi+8]
	lea	edi, DWORD PTR [eax+edi+8]
	mov	DWORD PTR [edi-4], ebx

; 1605 :           M->JA[k] = itemp;

	mov	ebx, DWORD PTR tv11328[ebp]
	mov	edi, DWORD PTR [esi+56]
	mov	DWORD PTR [eax+edi+8], ebx
	mov	edi, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [eax+edi]
	mov	DWORD PTR tv11251[ebp], ebx
	cmp	DWORD PTR [edi+eax+4], ebx
	jge	$LN630@linear_met

; 1600 :         { REAL temp = M->A[k-1];

	mov	edi, DWORD PTR [esi+60]
	fld	QWORD PTR [ecx+edi]

; 1601 :           int itemp = M->JA[k-1];
; 1602 :           M->A[k-1] = M->A[k];

	fld	QWORD PTR [edi+ecx+8]
	fstp	QWORD PTR [ecx+edi]

; 1603 :           M->A[k] = temp;

	mov	edi, DWORD PTR [esi+60]
	fstp	QWORD PTR [edi+ecx+8]

; 1604 :           M->JA[k-1] = M->JA[k];

	mov	edi, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [edi+eax+4]
	mov	DWORD PTR [eax+edi], ebx

; 1605 :           M->JA[k] = itemp;

	mov	ebx, DWORD PTR tv11251[ebp]
	mov	edi, DWORD PTR [esi+56]
	mov	DWORD PTR [eax+edi+4], ebx
	mov	edi, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [edi+eax-4]
	mov	DWORD PTR tv11356[ebp], ebx
	cmp	DWORD PTR [eax+edi], ebx
	jge	$LN630@linear_met

; 1600 :         { REAL temp = M->A[k-1];

	mov	edi, DWORD PTR [esi+60]
	fld	QWORD PTR [edi+ecx-8]

; 1601 :           int itemp = M->JA[k-1];
; 1602 :           M->A[k-1] = M->A[k];

	fld	QWORD PTR [ecx+edi]
	fstp	QWORD PTR [edi+ecx-8]

; 1603 :           M->A[k] = temp;

	mov	edi, DWORD PTR [esi+60]
	fstp	QWORD PTR [ecx+edi]

; 1604 :           M->JA[k-1] = M->JA[k];

	mov	edi, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [eax+edi]
	mov	DWORD PTR [edi+eax-4], ebx

; 1605 :           M->JA[k] = itemp;

	mov	ebx, DWORD PTR tv11356[ebp]
	mov	edi, DWORD PTR [esi+56]
	mov	DWORD PTR [eax+edi], ebx
	mov	edi, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [edi+eax-8]
	mov	DWORD PTR tv11368[ebp], ebx
	cmp	DWORD PTR [edi+eax-4], ebx
	jge	$LN630@linear_met

; 1600 :         { REAL temp = M->A[k-1];

	mov	edi, DWORD PTR [esi+60]
	fld	QWORD PTR [ecx+edi-16]

; 1605 :           M->JA[k] = itemp;

	sub	edx, 4
	fld	QWORD PTR [edi+ecx-8]
	sub	ecx, 32					; 00000020H
	fstp	QWORD PTR [ecx+edi+16]
	mov	edi, DWORD PTR [esi+60]
	sub	eax, 16					; 00000010H
	fstp	QWORD PTR [ecx+edi+24]
	mov	edi, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [edi+eax+12]
	mov	DWORD PTR [edi+eax+8], ebx
	mov	edi, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR tv11368[ebp]
	mov	DWORD PTR [eax+edi+12], ebx
	mov	edi, DWORD PTR _ii$90753[ebp]
	lea	ebx, DWORD PTR [edi+3]
	cmp	edx, ebx
	jg	$LL614@linear_met
$LC610@linear_met:

; 1598 :       { k = j;
; 1599 :         while ( k > ii && M->JA[k] < M->JA[k-1] )

	cmp	edx, edi
	jle	SHORT $LN4@linear_met
	npad	1
$LC2@linear_met:
	mov	eax, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR [eax+edx*4-4]
	cmp	DWORD PTR [eax+edx*4], ecx
	lea	eax, DWORD PTR [eax+edx*4]
	jge	SHORT $LN4@linear_met
	mov	eax, DWORD PTR [esi+60]

; 1600 :         { REAL temp = M->A[k-1];

	fld	QWORD PTR [eax+edx*8-8]
	lea	eax, DWORD PTR [eax+edx*8]

; 1601 :           int itemp = M->JA[k-1];
; 1602 :           M->A[k-1] = M->A[k];

	fld	QWORD PTR [eax]
	fstp	QWORD PTR [eax-8]

; 1603 :           M->A[k] = temp;

	mov	eax, DWORD PTR [esi+60]
	fstp	QWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR [esi+56]

; 1604 :           M->JA[k-1] = M->JA[k];

	mov	ebx, DWORD PTR [eax+edx*4]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [eax-4], ebx

; 1605 :           M->JA[k] = itemp;

	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR [eax+edx*4], ecx
	dec	edx
	cmp	edx, edi
	jg	SHORT $LC2@linear_met

; 1598 :       { k = j;
; 1599 :         while ( k > ii && M->JA[k] < M->JA[k-1] )

	jmp	SHORT $LN4@linear_met
$LN630@linear_met:
	mov	edi, DWORD PTR _ii$90753[ebp]
$LN4@linear_met:

; 1596 :     int jj = M->IA[i+1]-A_OFF;
; 1597 :     { for (  j = ii+1 ; j < M->IA[i+1]-A_OFF ; j++ )

	mov	ebx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR tv11445[ebp]
	mov	ebx, DWORD PTR [ebx+ecx*4+4]
	add	DWORD PTR tv11458[ebp], 4
	add	DWORD PTR tv11456[ebp], 8
	inc	edx
	inc	eax
	dec	ebx
	mov	DWORD PTR _j$[ebp], edx
	mov	DWORD PTR tv11445[ebp], eax
	cmp	edx, ebx
	jl	$LL654@linear_met
$LN7@linear_met:

; 1587 :           }
; 1588 :         }
; 1589 :      }
; 1590 :   }
; 1591 : 
; 1592 :   // Seems that JA is not always properly sorted, so check that, and
; 1593 :   // bubblesort each row.
; 1594 :   for ( i = 0 ; i < M->N ; i++ )

	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, DWORD PTR [esi+4]
	jl	$LL655@linear_met
$LN6@linear_met:

; 1606 :           k--;
; 1607 :         }
; 1608 :       }
; 1609 :     }
; 1610 :   }
; 1611 : 
; 1612 : } /* end linear_metric_setup_quadratic() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_linear_metric_setup_quadratic ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EB@FKEJFEGH@Internal?5error?5in?5linear_metric?5@ ; `string'
PUBLIC	??_C@_0EL@MDAGIOLL@Using?5alternate?5minimal?5degree?5w@ ; `string'
PUBLIC	_M$GSCopy$
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_linear_metric_setup_lagrange
EXTRN	_free_matrix:PROC
EXTRN	_factorial:BYTE
EXTRN	_det_adjoint:PROC
EXTRN	_kb_dmatrix:PROC
EXTRN	_gauss_lagrange:BYTE
;	COMDAT ??_C@_0EB@FKEJFEGH@Internal?5error?5in?5linear_metric?5@
CONST	SEGMENT
??_C@_0EB@FKEJFEGH@Internal?5error?5in?5linear_metric?5@ DB 'Internal err'
	DB	'or in linear_metric setup Lagrange: count > maxcount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@MDAGIOLL@Using?5alternate?5minimal?5degree?5w@
CONST	SEGMENT
??_C@_0EL@MDAGIOLL@Using?5alternate?5minimal?5degree?5w@ DB 'Using altern'
	DB	'ate minimal degree with Lagrange linear interpolation metric.'
	DB	0aH, 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _linear_metric_setup_lagrange
_TEXT	SEGMENT
_temp_matqXvS$ = -1092					; size = 24
_tangqXvS$90908 = -1068					; size = 24
_mattqXvS$90914 = -1044					; size = 24
tv6500 = -1020						; size = 4
_maxcount$ = -1016					; size = 4
_density$90936 = -1012					; size = 8
tv8352 = -1008						; size = 4
tv6380 = -1008						; size = 4
tv3552 = -1004						; size = 4
_tang$90910 = -1004					; size = 4
_gl$90818 = -1004					; size = 4
_attr$90953 = -1000					; size = 8
tv8446 = -996						; size = 4
_temp$90906 = -996					; size = 4
_v$90832 = -996						; size = 4
_temp$91024 = -992					; size = 4
_col$ = -992						; size = 4
tv6350 = -988						; size = 4
_matt$90916 = -988					; size = 4
_x$ = -984						; size = 4
_temp_mat$ = -980					; size = 4
_ii$ = -976						; size = 4
tv10624 = -972						; size = 4
tv6501 = -972						; size = 4
tv5755 = -972						; size = 4
tv3875 = -972						; size = 4
_S$GSCopy$ = -968					; size = 4
_temp$ = -968						; size = 4
tv10589 = -964						; size = 4
tv8566 = -964						; size = 4
tv7440 = -964						; size = 4
tv7202 = -964						; size = 4
tv3510 = -964						; size = 4
tv10707 = -960						; size = 4
tv9731 = -960						; size = 4
tv9559 = -960						; size = 4
_M$GSCopy$ = -960					; size = 4
_mlist$ = -956						; size = 4
tv8416 = -952						; size = 4
tv7741 = -952						; size = 4
tv6156 = -952						; size = 4
tv3188 = -952						; size = 4
tv1373 = -952						; size = 4
tv6466 = -948						; size = 4
_gl$90913 = -948					; size = 4
_ix$90931 = -944					; size = 4
_jj$ = -944						; size = 4
_weights$ = -940					; size = 4
_i$ = -936						; size = 4
tv8278 = -932						; size = 4
tv5199 = -932						; size = 4
_k$ = -932						; size = 4
_j$ = -932						; size = 4
_count$ = -928						; size = 4
tv8532 = -924						; size = 4
tv7555 = -924						; size = 4
tv7464 = -924						; size = 4
tv6286 = -924						; size = 4
tv6212 = -924						; size = 4
tv5569 = -924						; size = 4
_ctrl$90912 = -920					; size = 4
_ctrl$90817 = -920					; size = 4
_tangxJ$90909 = -916					; size = 288
_temp_matxJ$ = -628					; size = 288
_mattxJ$90915 = -340					; size = 288
_tang$90816 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_M$ = 12						; size = 4
_linear_metric_setup_lagrange PROC			; COMDAT

; 1626 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1092				; 00000444H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _M$[ebp]
	push	edi
	mov	edi, DWORD PTR _S$[ebp]

; 1627 :   int i,j,jj,k,kk,m,n;
; 1628 :   edge_id e_id;
; 1629 :   facet_id f_id;
; 1630 :   MAT2D(temp_mat,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _temp_matxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp_matqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _S$GSCopy$[ebp], edi
	mov	DWORD PTR _M$GSCopy$[ebp], esi
	call	_mat2d_setup

; 1631 :   REAL **mat=NULL;
; 1632 :   int col,row;
; 1633 :   int *ii;
; 1634 :   REAL **weights=NULL;
; 1635 :   REAL **x = NULL;
; 1636 :   struct mentry { int row; int col; REAL val; } *temp,*mlist;
; 1637 :   int maxcount;
; 1638 :   int count,total;
; 1639 : 
; 1640 :   if ( ysmp_flag != MINDEG_FACTORING )

	xor	ebx, ebx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _temp_mat$[ebp], eax
	cmp	DWORD PTR _ysmp_flag, ebx
	je	SHORT $LN179@linear_met@2

; 1641 :   { ysmp_flag = MINDEG_FACTORING;
; 1642 :      sp_mul_func = bk_mul;
; 1643 :      sp_AIJ_setup_func= bk_AIJ_setup;
; 1644 :      sp_constraint_setup_func = bk_constraint_setup;
; 1645 :      sp_hess_project_setup_func= BK_hess_project_setup;
; 1646 :      sp_factor_func = xmd_factor;
; 1647 :      sp_solve_func = xmd_solve;
; 1648 :      sp_solve_multi_func = xmd_solve_multi;
; 1649 :      sp_ordering_func = NULL;
; 1650 :      sp_CHinvC_func = sp_CHinvC;
; 1651 :      outstring(
; 1652 :         "Using alternate minimal degree with Lagrange linear interpolation metric.\n");

	push	OFFSET ??_C@_0EL@MDAGIOLL@Using?5alternate?5minimal?5degree?5w@
	mov	DWORD PTR _ysmp_flag, ebx
	mov	DWORD PTR _sp_mul_func, OFFSET _bk_mul
	mov	DWORD PTR _sp_AIJ_setup_func, OFFSET _bk_AIJ_setup
	mov	DWORD PTR _sp_constraint_setup_func, OFFSET _bk_constraint_setup
	mov	DWORD PTR _sp_hess_project_setup_func, OFFSET _BK_hess_project_setup
	mov	DWORD PTR _sp_factor_func, OFFSET _xmd_factor
	mov	DWORD PTR _sp_solve_func, OFFSET _xmd_solve
	mov	DWORD PTR _sp_solve_multi_func, OFFSET _xmd_solve_multi
	mov	DWORD PTR _sp_ordering_func, ebx
	mov	DWORD PTR _sp_CHinvC_func, OFFSET _sp_CHinvC
	call	_outstring
	add	esp, 4
$LN179@linear_met@2:

; 1653 :   }
; 1654 :   M->N = S->N;

	mov	edx, DWORD PTR [edi+4]

; 1655 :   M->flags &= ~ S_ODRV_REORDERED; 

	and	DWORD PTR [esi], -17			; ffffffefH

; 1656 : 
; 1657 :   /* allocate storage for arrays */
; 1658 :   M->IA = (int *)temp_calloc(M->N+1,sizeof(int));

	push	1658					; 0000067aH
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	lea	eax, DWORD PTR [edx+1]
	push	4
	push	eax
	mov	DWORD PTR [esi+4], edx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+52], eax

; 1659 :   if ( M->P == NULL ) M->P = (int *)temp_calloc(M->N,sizeof(int));

	cmp	DWORD PTR [esi+68], ebx
	jne	SHORT $LN178@linear_met@2
	mov	ecx, DWORD PTR [esi+4]
	push	1659					; 0000067bH
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	4
	push	ecx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+68], eax
$LN178@linear_met@2:

; 1660 :   if ( M->IP == NULL ) M->IP = (int *)temp_calloc(M->N,sizeof(int));

	cmp	DWORD PTR [esi+72], ebx
	jne	SHORT $LN177@linear_met@2
	mov	edx, DWORD PTR [esi+4]
	push	1660					; 0000067cH
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	4
	push	edx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+72], eax
$LN177@linear_met@2:

; 1661 : 
; 1662 :   for ( i = 0 ; i < M->N ; i++ )

	xor	eax, eax
	cmp	DWORD PTR [esi+4], ebx
	jle	SHORT $LN174@linear_met@2
$LL176@linear_met@2:

; 1663 :      M->IP[i] = M->P[i] = i;    /* unpermuted */

	mov	ecx, DWORD PTR [esi+68]
	mov	DWORD PTR [ecx+eax*4], eax
	mov	edx, DWORD PTR [esi+72]
	mov	DWORD PTR [edx+eax*4], eax
	inc	eax
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL176@linear_met@2
$LN174@linear_met@2:

; 1664 : 
; 1665 : 
; 1666 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	$LN173@linear_met@2

; 1667 :   { REAL tang[MAXCOORD];
; 1668 :     int ctrl = web.skel[EDGE].ctrlpts;
; 1669 :     struct gauss_lag *gl = &gauss_lagrange[web.dimension][web.gauss1D_order];

	mov	ebx, DWORD PTR _web+1592
	mov	eax, DWORD PTR _web+620
	mov	edi, DWORD PTR _web+120

; 1670 : 
; 1671 :     ii = (int*)temp_calloc(ctrl,sizeof(int));

	push	1671					; 00000687H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	shl	ebx, 5
	add	ebx, DWORD PTR _gauss_lagrange[eax*4]
	push	4
	push	edi
	mov	DWORD PTR _ctrl$90817[ebp], edi
	mov	DWORD PTR _gl$90818[ebp], ebx
	call	_kb_temp_calloc

; 1672 :     weights = dmatrix(0,ctrl,0,ctrl);

	push	1672					; 00000688H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	edi
	push	0
	push	edi
	push	0
	mov	DWORD PTR _ii$[ebp], eax
	call	_kb_dmatrix

; 1673 :     x = dmatrix(0,ctrl,0,SDIM);

	mov	ecx, DWORD PTR _web+616
	push	1673					; 00000689H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	ecx
	push	0
	push	edi
	push	0
	mov	DWORD PTR _weights$[ebp], eax
	call	_kb_dmatrix
	mov	DWORD PTR _x$[ebp], eax

; 1674 :     maxcount = web.skel[EDGE].count*ctrl*(ctrl+1)/2*SDIM*SDIM;

	lea	eax, DWORD PTR [edi+1]
	imul	eax, DWORD PTR _web+176
	imul	eax, edi
	cdq
	sub	eax, edx
	mov	edx, eax
	mov	eax, DWORD PTR _web+616
	sar	edx, 1
	imul	edx, eax
	imul	edx, eax

; 1675 :     maxcount += M->N - M->optparamrowstart + 10;

	sub	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+4]
	add	esp, 64					; 00000040H

; 1676 :     mlist = (struct mentry *)temp_calloc(maxcount,sizeof(struct mentry));

	push	1676					; 0000068cH
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	lea	edi, DWORD PTR [edx+eax+10]
	push	16					; 00000010H
	push	edi
	mov	DWORD PTR _maxcount$[ebp], edi
	call	_kb_temp_calloc

; 1677 :     count = 0;
; 1678 :     /* edge by edge */
; 1679 :     FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	add	esp, 16					; 00000010H
	mov	DWORD PTR _mlist$[ebp], eax
	mov	DWORD PTR _count$[ebp], 0
	test	edx, 268435456				; 10000000H
	je	$LN351@linear_met@2
	fld1
	fldz
$LN172@linear_met@2:
	mov	ecx, DWORD PTR _web+124
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv3510[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN171@linear_met@2

; 1680 :     { vertex_id *v = get_edge_vertices(e_id);

	mov	esi, DWORD PTR _dymem
	fstp	ST(1)
	mov	eax, DWORD PTR _web+216
	fstp	ST(0)
	mov	eax, DWORD PTR [eax+esi+304]

; 1681 :       for ( i = 0 ; i < ctrl ; i++ ) ii[i] = loc_ordinal(v[i]);

	mov	esi, DWORD PTR _ctrl$90817[ebp]
	add	eax, ecx
	mov	DWORD PTR _v$90832[ebp], eax
	test	esi, esi
	jle	SHORT $LN334@linear_met@2
	mov	edi, DWORD PTR _ii$[ebp]
	sub	edi, eax
	mov	DWORD PTR tv3188[ebp], esi
	npad	3
$LL167@linear_met@2:
	mov	ecx, DWORD PTR [eax]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN182@linear_met@2
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN183@linear_met@2
$LN182@linear_met@2:
	or	ecx, -1
$LN183@linear_met@2:
	mov	DWORD PTR [eax+edi], ecx
	add	eax, 4
	dec	DWORD PTR tv3188[ebp]
	jne	SHORT $LL167@linear_met@2
$LN334@linear_met@2:

; 1682 :       get_edge_verts(e_id,x,NULL);

	mov	ecx, DWORD PTR _x$[ebp]
	push	0
	push	ecx
	push	edx
	call	_get_edge_verts

; 1683 : 
; 1684 :       /* weight matrix */
; 1685 :       for ( i = 0 ; i < ctrl ; i++ )

	fldz
	xor	edi, edi
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _i$[ebp], edi
	test	esi, esi
	jle	SHORT $LN162@linear_met@2
$LN164@linear_met@2:

; 1686 :         for ( j = 0 ; j < ctrl ; j++ ) weights[i][j] = 0.0;

	xor	edx, edx
	cmp	esi, 4
	jl	SHORT $LC279@linear_met@2
	mov	edx, DWORD PTR _weights$[ebp]
	mov	eax, DWORD PTR [edx+edi*4]
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	add	eax, 16					; 00000010H
	inc	ecx
	lea	edx, DWORD PTR [ecx*4]
$LN280@linear_met@2:
	fst	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	ecx
	fst	QWORD PTR [eax-40]
	fst	QWORD PTR [eax-32]
	fst	QWORD PTR [eax-24]
	jne	SHORT $LN280@linear_met@2
$LC279@linear_met@2:
	cmp	edx, esi
	jge	SHORT $LN163@linear_met@2
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _weights$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, esi
	sub	ecx, edx
	add	ecx, ecx
	lea	edi, DWORD PTR [eax+edx*8]
	and	ecx, 1073741822				; 3ffffffeH
	xor	eax, eax
	rep stosd
	mov	edi, DWORD PTR _i$[ebp]
$LN163@linear_met@2:

; 1683 : 
; 1684 :       /* weight matrix */
; 1685 :       for ( i = 0 ; i < ctrl ; i++ )

	inc	edi
	mov	DWORD PTR _i$[ebp], edi
	cmp	edi, esi
	jl	SHORT $LN164@linear_met@2
$LN162@linear_met@2:

; 1687 : 
; 1688 :       for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	esi, esi
	cmp	DWORD PTR [ebx+4], esi
	jle	$LN156@linear_met@2
	npad	8
$LL158@linear_met@2:

; 1689 :       { REAL value;
; 1690 :         for ( n = 0 ; n < SDIM ; n ++ )

	mov	eax, DWORD PTR _web+616
	xor	ecx, ecx
	test	eax, eax
	jle	$LN406@linear_met@2
$LN155@linear_met@2:

; 1692 :           for ( k = 0 ; k < ctrl ; k++ )

	xor	eax, eax
	fst	QWORD PTR _tang$90816[ebp+ecx*8]
	cmp	DWORD PTR _ctrl$90817[ebp], 4
	jl	$LC282@linear_met@2

; 1691 :         { tang[n] = 0.0;

	mov	edx, DWORD PTR _x$[ebp]
	add	edx, 8
	mov	DWORD PTR tv5199[ebp], edx

; 1692 :           for ( k = 0 ; k < ctrl ; k++ )

$LN283@linear_met@2:

; 1693 :             tang[n] += gl->gpolypart[m][0][k]*x[k][n];

	mov	edx, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+eax*8]
	mov	edi, DWORD PTR tv5199[ebp]
	mov	edi, DWORD PTR [edi-8]
	fmul	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR tv5199[ebp]
	add	eax, 4
	fadd	QWORD PTR _tang$90816[ebp+ecx*8]
	fst	QWORD PTR _tang$90816[ebp+ecx*8]
	mov	edx, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+eax*8-24]
	mov	edi, DWORD PTR [edi-4]
	fmul	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR tv5199[ebp]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$90816[ebp+ecx*8]
	mov	edx, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+eax*8-16]
	mov	edi, DWORD PTR [edi]
	fmul	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR tv5199[ebp]
	add	DWORD PTR tv5199[ebp], 16		; 00000010H
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$90816[ebp+ecx*8]
	mov	edx, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+eax*8-8]
	mov	edi, DWORD PTR [edi+4]
	fmul	QWORD PTR [edi+ecx*8]
	mov	edx, DWORD PTR _ctrl$90817[ebp]
	add	edx, -3					; fffffffdH
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _tang$90816[ebp+ecx*8]
	cmp	eax, edx
	jl	$LN283@linear_met@2
$LC282@linear_met@2:

; 1692 :           for ( k = 0 ; k < ctrl ; k++ )

	cmp	eax, DWORD PTR _ctrl$90817[ebp]
	jge	SHORT $LN154@linear_met@2
$LN335@linear_met@2:

; 1693 :             tang[n] += gl->gpolypart[m][0][k]*x[k][n];

	mov	edx, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [edx]
	mov	edi, DWORD PTR _x$[ebp]
	fld	QWORD PTR [edx+eax*8]
	mov	edi, DWORD PTR [edi+eax*4]
	fmul	QWORD PTR [edi+ecx*8]
	inc	eax
	fadd	QWORD PTR _tang$90816[ebp+ecx*8]
	fstp	QWORD PTR _tang$90816[ebp+ecx*8]
	cmp	eax, DWORD PTR _ctrl$90817[ebp]
	jl	SHORT $LN335@linear_met@2
$LN154@linear_met@2:

; 1689 :       { REAL value;
; 1690 :         for ( n = 0 ; n < SDIM ; n ++ )

	mov	eax, DWORD PTR _web+616
	inc	ecx
	cmp	ecx, eax
	jl	$LN155@linear_met@2
$LN406@linear_met@2:

; 1694 :         }
; 1695 :         value = gl->gausswt[m]*sqrt(SDIM_dot(tang,tang));

	push	eax
	fstp	ST(0)
	lea	eax, DWORD PTR _tang$90816[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	mov	edx, DWORD PTR [ebx+12]
	fmul	QWORD PTR [edx+esi*8]

; 1696 :         for ( i = 0 ; i < ctrl ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _ctrl$90817[ebp], ecx
	jle	$LN467@linear_met@2
$LN149@linear_met@2:

; 1697 :         { for ( j = 0 ; j < ctrl ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _ctrl$90817[ebp], 4
	jl	$LN346@linear_met@2
	mov	edx, DWORD PTR _ctrl$90817[ebp]
	mov	eax, DWORD PTR _weights$[ebp]
	mov	edi, DWORD PTR [eax+ecx*4]
	add	edx, -4					; fffffffcH
	shr	edx, 2
	inc	edx
	mov	DWORD PTR tv1373[ebp], edx
	lea	eax, DWORD PTR [edi+16]

; 1698 :             weights[i][j] += quadratic_metric_mix*value
; 1699 :                    *gl->gpoly[m][i]*gl->gpoly[m][j];

	neg	edi
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv5569[ebp], 16		; 00000010H
	mov	DWORD PTR tv5755[ebp], edi
	mov	DWORD PTR _j$[ebp], edx
$LN286@linear_met@2:
	fld	QWORD PTR _quadratic_metric_mix
	mov	edx, DWORD PTR [ebx+20]
	mov	edx, DWORD PTR [edx+esi*4]
	fmul	ST(0), ST(1)
	lea	edi, DWORD PTR [edi+eax-16]
	add	eax, 32					; 00000020H
	fmul	QWORD PTR [edx+ecx*8]
	fmul	QWORD PTR [edi+edx]
	fadd	QWORD PTR [eax-48]
	fstp	QWORD PTR [eax-48]
	mov	edx, DWORD PTR [ebx+20]
	fld	QWORD PTR _quadratic_metric_mix
	mov	edx, DWORD PTR [edx+esi*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edx+ecx*8]
	fmul	QWORD PTR [edi+edx+8]
	mov	edi, DWORD PTR tv5569[ebp]
	add	DWORD PTR tv5569[ebp], 32		; 00000020H
	dec	DWORD PTR tv1373[ebp]
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	mov	edx, DWORD PTR [ebx+20]
	fld	QWORD PTR _quadratic_metric_mix
	mov	edx, DWORD PTR [edx+esi*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edx+ecx*8]
	fmul	QWORD PTR [edx+edi]
	mov	edi, DWORD PTR tv5755[ebp]
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	mov	edx, DWORD PTR [ebx+20]
	fld	QWORD PTR _quadratic_metric_mix
	mov	edx, DWORD PTR [edx+esi*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edi+edx+8]
	fmul	QWORD PTR [edx+eax-32]
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	jne	$LN286@linear_met@2

; 1697 :         { for ( j = 0 ; j < ctrl ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
$LN346@linear_met@2:
	cmp	eax, DWORD PTR _ctrl$90817[ebp]
	jge	SHORT $LN148@linear_met@2
	mov	edx, DWORD PTR _weights$[ebp]
	mov	edi, DWORD PTR [edx+ecx*4]
$LC146@linear_met@2:

; 1698 :             weights[i][j] += quadratic_metric_mix*value
; 1699 :                    *gl->gpoly[m][i]*gl->gpoly[m][j];

	fld	QWORD PTR _quadratic_metric_mix
	mov	edx, DWORD PTR [ebx+20]
	mov	edx, DWORD PTR [edx+esi*4]
	fmul	ST(0), ST(1)
	inc	eax
	fmul	QWORD PTR [edx+ecx*8]
	fmul	QWORD PTR [edx+eax*8-8]
	fadd	QWORD PTR [edi+eax*8-8]
	fstp	QWORD PTR [edi+eax*8-8]
	cmp	eax, DWORD PTR _ctrl$90817[ebp]
	jl	SHORT $LC146@linear_met@2
$LN148@linear_met@2:

; 1696 :         for ( i = 0 ; i < ctrl ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR _ctrl$90817[ebp]
	jl	$LN149@linear_met@2
$LN467@linear_met@2:

; 1687 : 
; 1688 :       for ( m = 0 ; m < gl->gnumpts ; m++ )

	inc	esi

; 1697 :         { for ( j = 0 ; j < ctrl ; j++ )

	fstp	ST(0)
	fldz
	cmp	esi, DWORD PTR [ebx+4]
	jl	$LL158@linear_met@2
$LN156@linear_met@2:

; 1700 :         }
; 1701 :       }
; 1702 :       /* simple vertex weighting part */
; 1703 :       weights[0][0] += (1-quadratic_metric_mix)*.5/(ctrl-1);

	mov	esi, DWORD PTR _ctrl$90817[ebp]
	lea	eax, DWORD PTR [esi-1]
	mov	DWORD PTR tv10624[ebp], eax
	fild	DWORD PTR tv10624[ebp]
	mov	edx, DWORD PTR _weights$[ebp]
	fld1
	mov	eax, DWORD PTR [edx]
	fld	QWORD PTR _quadratic_metric_mix

; 1704 :       weights[ctrl][ctrl] = (1-quadratic_metric_mix)*.5/(ctrl-1);

	mov	ecx, DWORD PTR [edx+esi*4]
	fsubr	ST(0), ST(1)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(3)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 1705 :       for ( i = 1 ; i < edge_ctrl-1 ; i++ )

	mov	eax, 1
	fld	ST(1)
	fsub	QWORD PTR _quadratic_metric_mix
	fmulp	ST(1), ST(0)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [ecx+esi*8]
	mov	ecx, DWORD PTR _edge_ctrl
	dec	ecx
	cmp	ecx, eax
	jle	SHORT $LN409@linear_met@2
$LN143@linear_met@2:

; 1706 :         weights[i][i] += (1-quadratic_metric_mix)/(ctrl-1);

	fld	QWORD PTR _quadratic_metric_mix
	mov	ecx, DWORD PTR [edx+eax*4]
	fsubr	ST(0), ST(1)
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	eax
	fdiv	ST(0), ST(2)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _edge_ctrl
	dec	ecx
	cmp	eax, ecx
	jl	SHORT $LN143@linear_met@2
$LN409@linear_met@2:

; 1705 :       for ( i = 1 ; i < edge_ctrl-1 ; i++ )

	fstp	ST(1)

; 1707 : 
; 1708 :       /* fill in metric matrix */
; 1709 :       for ( i = 0 ; i < ctrl ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	esi, esi
	jle	$LN454@linear_met@2
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _v$90832[ebp]
	sub	ecx, eax
	sub	eax, edx
	mov	DWORD PTR tv6466[ebp], edx
	mov	DWORD PTR tv6380[ebp], ecx
	mov	DWORD PTR tv6500[ebp], eax
$LN140@linear_met@2:

; 1710 :       { struct hess_verlist *vh = get_vertex_vhead(v[i]);

	mov	eax, DWORD PTR tv6466[ebp]
	add	eax, DWORD PTR tv6500[ebp]
	mov	ecx, DWORD PTR tv6380[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _web+12
	mov	DWORD PTR tv6501[ebp], eax
	mov	eax, DWORD PTR _vhead_attr
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	esi, DWORD PTR [edx+eax]
	shl	esi, 5
	add	esi, DWORD PTR _vhead

; 1711 :         
; 1712 :         /* self */
; 1713 :         if ( vh->proj )

	cmp	DWORD PTR [esi+16], 0
	je	$LN137@linear_met@2

; 1714 :         { 
; 1715 :           tr_mat_mul(vh->proj,vh->proj,temp_mat,SDIM,vh->freedom,vh->freedom);

	mov	eax, DWORD PTR [esi+8]
	fstp	ST(0)
	mov	edx, DWORD PTR _web+616
	fstp	ST(0)
	mov	ecx, DWORD PTR [esi+16]
	mov	edi, DWORD PTR _temp_mat$[ebp]
	push	eax
	push	eax
	push	edx
	push	edi
	push	ecx
	push	ecx
	call	_tr_mat_mul

; 1716 :           mat = temp_mat;

	fld1
	fldz
	add	esp, 24					; 00000018H
	mov	ecx, edi
	fxch	ST(1)
$LN136@linear_met@2:

; 1719 :         for ( jj = 0 ; jj < vh->freedom ; jj++ )

	mov	eax, DWORD PTR [esi+8]
	xor	edi, edi
	mov	DWORD PTR _jj$[ebp], edi
	test	eax, eax
	jle	$LN133@linear_met@2
	mov	DWORD PTR tv6212[ebp], ecx

; 1720 :           for ( k = jj ; k < vh->freedom ; k++ )

	cmp	edi, eax
	jge	SHORT $LN134@linear_met@2
$LN622@linear_met@2:
	mov	edx, DWORD PTR _count$[ebp]
	lea	eax, DWORD PTR [edi*8]
	mov	DWORD PTR tv6156[ebp], eax
	mov	eax, DWORD PTR _mlist$[ebp]
	add	edx, edx
	mov	ecx, edi
	lea	eax, DWORD PTR [eax+edx*8+8]
$LN336@linear_met@2:

; 1721 :           { col = vh->rownum + k;
; 1722 :             row = vh->rownum + jj;

	mov	edx, DWORD PTR [esi+12]

; 1723 :             mlist[count].col = col;
; 1724 :             mlist[count].row = row;
; 1725 :             mlist[count++].val = vh->slant*vh->slant*weights[i][i]*mat[jj][k];

	inc	DWORD PTR _count$[ebp]
	add	edi, edx
	add	edx, ecx
	mov	DWORD PTR [eax-4], edx
	mov	edx, DWORD PTR tv6466[ebp]
	mov	DWORD PTR [eax-8], edi
	fld	QWORD PTR [esi+24]
	mov	edx, DWORD PTR [edx]
	fmul	ST(0), ST(0)
	mov	edi, DWORD PTR _i$[ebp]
	inc	ecx
	fmul	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR tv6212[ebp]
	mov	edi, DWORD PTR [edx]
	mov	edx, DWORD PTR tv6156[ebp]
	fmul	QWORD PTR [edx+edi]
	mov	edi, DWORD PTR _jj$[ebp]
	add	edx, 8
	add	eax, 16					; 00000010H
	fstp	QWORD PTR [eax-16]
	mov	DWORD PTR tv6156[ebp], edx
	cmp	ecx, DWORD PTR [esi+8]
	jl	SHORT $LN336@linear_met@2
$LN134@linear_met@2:

; 1719 :         for ( jj = 0 ; jj < vh->freedom ; jj++ )

	mov	eax, DWORD PTR [esi+8]
	add	DWORD PTR tv6212[ebp], 4
	inc	edi
	mov	DWORD PTR _jj$[ebp], edi
	cmp	edi, eax
	jl	$LN622@linear_met@2
$LN133@linear_met@2:

; 1726 :           }
; 1727 : 
; 1728 :           /* cross terms */
; 1729 :           for ( k = 0 ; k < ctrl ; k++ )

	mov	eax, DWORD PTR _ii$[ebp]
	mov	DWORD PTR _k$[ebp], 0
	mov	DWORD PTR tv6350[ebp], eax
$LN129@linear_met@2:

; 1730 :           { struct hess_verlist *vv = get_vertex_vhead(v[k]);

	mov	eax, DWORD PTR tv6350[ebp]
	mov	ecx, DWORD PTR tv6380[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR _vhead_attr
	mov	edi, DWORD PTR _web+12
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+104
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edi+64]
	mov	edi, DWORD PTR [edx+ecx]

; 1731 :             if ( ii[k] <= ii[i] ) continue;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR tv6501[ebp]
	shl	edi, 5
	add	edi, DWORD PTR _vhead
	cmp	edx, DWORD PTR [eax]
	jle	$LN128@linear_met@2

; 1732 :             if ( vh->proj && vv->proj )

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	$LN123@linear_met@2
	mov	ecx, DWORD PTR [edi+16]
	fstp	ST(0)
	fstp	ST(0)
	test	ecx, ecx
	je	SHORT $LN125@linear_met@2

; 1733 :             { tr_mat_mul(vh->proj,vv->proj,temp_mat,SDIM,vh->freedom,vv->freedom);

	mov	edx, DWORD PTR [edi+8]
	push	edx
	mov	edx, DWORD PTR [esi+8]
	push	edx
	mov	edx, DWORD PTR _web+616
	push	edx

; 1734 :               mat = temp_mat;

	jmp	SHORT $LN625@linear_met@2
$LN137@linear_met@2:

; 1717 :         }
; 1718 :         else mat = identmat;

	mov	ecx, DWORD PTR _identmat
	jmp	$LN136@linear_met@2
$LN125@linear_met@2:

; 1735 :             }
; 1736 :             else if ( vh->proj )
; 1737 :             { tr_mat_mul(vh->proj,identmat,temp_mat,SDIM,vh->freedom,vv->freedom);

	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR _web+616
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _identmat
$LN625@linear_met@2:
	mov	edx, DWORD PTR _temp_mat$[ebp]
	push	edx
	push	ecx
	push	eax
	call	_tr_mat_mul

; 1738 :               mat = temp_mat;

	fld1
	fldz
	mov	eax, DWORD PTR _temp_mat$[ebp]
	add	esp, 24					; 00000018H
	fxch	ST(1)
$LN120@linear_met@2:

; 1742 : 
; 1743 :             for ( jj = 0 ; jj < vh->freedom ; jj++ )  

	cmp	DWORD PTR [esi+8], 0
	mov	DWORD PTR _jj$[ebp], 0
	jle	$LN128@linear_met@2
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR tv6286[ebp], eax
$LN119@linear_met@2:

; 1744 :               for ( kk = 0 ; kk < vv->freedom ; kk++ )  

	xor	ecx, ecx
	test	edx, edx
	jle	$LN118@linear_met@2
	mov	edx, DWORD PTR _count$[ebp]
	mov	eax, DWORD PTR _mlist$[ebp]
	add	edx, edx
	lea	eax, DWORD PTR [eax+edx*8+8]
$LN333@linear_met@2:

; 1745 :                 { col = vv->rownum + kk;

	mov	edx, DWORD PTR [edi+12]
	add	edx, ecx
	mov	DWORD PTR _col$[ebp], edx

; 1746 :                   row = vh->rownum+jj;

	mov	edx, DWORD PTR [esi+12]
	add	edx, DWORD PTR _jj$[ebp]

; 1747 :                   if ( col < row )

	mov	ebx, DWORD PTR _col$[ebp]
	cmp	ebx, edx
	jge	SHORT $LN113@linear_met@2

; 1748 :                   { int temp = col; col = row; row = temp; }

	mov	DWORD PTR _temp$90906[ebp], ebx
	mov	ebx, edx
	mov	edx, DWORD PTR _temp$90906[ebp]
$LN113@linear_met@2:

; 1749 :                   mlist[count].col = col;
; 1750 :                   mlist[count].row = row;
; 1751 :                   mlist[count++].val = vh->slant*vv->slant*mat[jj][kk]*weights[i][k];

	inc	DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR tv6286[ebp]
	mov	DWORD PTR [eax-4], ebx
	fld	QWORD PTR [edi+24]
	mov	edx, DWORD PTR [edx]
	fmul	QWORD PTR [esi+24]
	mov	ebx, DWORD PTR _k$[ebp]
	inc	ecx
	fmul	QWORD PTR [edx+ecx*8-8]
	mov	edx, DWORD PTR tv6466[ebp]
	mov	edx, DWORD PTR [edx]
	add	eax, 16					; 00000010H
	fmul	QWORD PTR [edx+ebx*8]
	fstp	QWORD PTR [eax-16]
	mov	edx, DWORD PTR [edi+8]
	cmp	ecx, edx
	jl	SHORT $LN333@linear_met@2

; 1744 :               for ( kk = 0 ; kk < vv->freedom ; kk++ )  

	mov	ebx, DWORD PTR _gl$90818[ebp]
$LN118@linear_met@2:

; 1742 : 
; 1743 :             for ( jj = 0 ; jj < vh->freedom ; jj++ )  

	mov	eax, DWORD PTR _jj$[ebp]
	add	DWORD PTR tv6286[ebp], 4
	inc	eax
	mov	DWORD PTR _jj$[ebp], eax
	cmp	eax, DWORD PTR [esi+8]
	jl	$LN119@linear_met@2
$LN128@linear_met@2:

; 1726 :           }
; 1727 : 
; 1728 :           /* cross terms */
; 1729 :           for ( k = 0 ; k < ctrl ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _ctrl$90817[ebp]
	inc	eax
	mov	edx, 4
	add	DWORD PTR tv6350[ebp], edx
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, ecx
	jl	$LN129@linear_met@2

; 1707 : 
; 1708 :       /* fill in metric matrix */
; 1709 :       for ( i = 0 ; i < ctrl ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv6466[ebp], edx
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, ecx
	jl	$LN140@linear_met@2
$LN454@linear_met@2:

; 1726 :           }
; 1727 : 
; 1728 :           /* cross terms */
; 1729 :           for ( k = 0 ; k < ctrl ; k++ )

	fxch	ST(1)
$LN171@linear_met@2:

; 1677 :     count = 0;
; 1678 :     /* edge by edge */
; 1679 :     FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR tv3510[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [edx]
	test	edx, 268435456				; 10000000H
	jne	$LN172@linear_met@2

; 1752 :                 }
; 1753 :           }
; 1754 :         }
; 1755 :      }
; 1756 :   }
; 1757 :   else /* facets */

	mov	edi, DWORD PTR _maxcount$[ebp]
	mov	esi, DWORD PTR _M$GSCopy$[ebp]
	jmp	$LN626@linear_met@2
$LN123@linear_met@2:

; 1739 :             }
; 1740 :             else if ( vv->proj ) mat = vv->proj;

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	jne	$LN120@linear_met@2

; 1741 :             else mat = identmat;

	mov	eax, DWORD PTR _identmat
	jmp	$LN120@linear_met@2
$LN173@linear_met@2:

; 1758 :   { 
; 1759 :     MAT2D(tang,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _tangxJ$90909[ebp]
	push	eax
	lea	ecx, DWORD PTR _tangqXvS$90908[ebp]
	push	ecx
	call	_mat2d_setup

; 1760 :     int ctrl = web.skel[FACET].ctrlpts;
; 1761 :     struct gauss_lag *gl = &gauss_lagrange[web.dimension][web.gauss2D_order];

	mov	edx, DWORD PTR _web+620
	mov	ebx, DWORD PTR _web+232
	mov	DWORD PTR _tang$90910[ebp], eax
	mov	eax, DWORD PTR _web+1596
	shl	eax, 5
	add	eax, DWORD PTR _gauss_lagrange[edx*4]

; 1762 :     MAT2D(matt,MAXCOORD,MAXCOORD);

	push	6
	mov	DWORD PTR _gl$90913[ebp], eax
	push	6
	lea	eax, DWORD PTR _mattxJ$90915[ebp]
	push	eax
	lea	ecx, DWORD PTR _mattqXvS$90914[ebp]
	push	ecx
	mov	DWORD PTR _ctrl$90912[ebp], ebx
	call	_mat2d_setup

; 1763 : 
; 1764 :     ii = (int*)temp_calloc(ctrl,sizeof(int));

	push	1764					; 000006e4H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	4
	push	ebx
	mov	DWORD PTR _matt$90916[ebp], eax
	call	_kb_temp_calloc

; 1765 :     weights = dmatrix(0,ctrl,0,ctrl);

	push	1765					; 000006e5H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	ebx
	push	0
	push	ebx
	push	0
	mov	DWORD PTR _ii$[ebp], eax
	call	_kb_dmatrix

; 1766 :     x = dmatrix(0,ctrl,0,SDIM);

	mov	edx, DWORD PTR _web+616
	add	esp, 72					; 00000048H
	push	1766					; 000006e6H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	edx
	push	0
	push	ebx
	push	0
	mov	DWORD PTR _weights$[ebp], eax
	call	_kb_dmatrix
	mov	DWORD PTR _x$[ebp], eax

; 1767 :     maxcount = web.skel[FACET].count*ctrl*(ctrl+1)/2*SDIM*SDIM;

	lea	eax, DWORD PTR [ebx+1]
	imul	eax, ebx
	imul	eax, DWORD PTR _web+288
	cdq
	sub	eax, edx

; 1768 :     maxcount += M->N - M->optparamrowstart + 10;

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, DWORD PTR _web+616
	sar	ecx, 1
	imul	ecx, eax
	imul	ecx, eax
	sub	ecx, DWORD PTR [esi+16]

; 1769 :     count = 0;
; 1770 :     mlist = (struct mentry *)temp_calloc(maxcount,sizeof(struct mentry));

	push	1770					; 000006eaH
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	lea	edi, DWORD PTR [ecx+edx+10]
	push	16					; 00000010H
	push	edi
	mov	DWORD PTR _maxcount$[ebp], edi
	mov	DWORD PTR _count$[ebp], 0
	call	_kb_temp_calloc

; 1771 : 
; 1772 :     /* facet by facet */
; 1773 :     FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	add	esp, 40					; 00000028H
	mov	DWORD PTR _mlist$[ebp], eax
	test	edx, 268435456				; 10000000H
	je	$LN351@linear_met@2
	fld1
	mov	ecx, DWORD PTR _web+236
	fldz
$LN340@linear_met@2:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv3875[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN110@linear_met@2

; 1774 :     { vertex_id *ix = get_facet_vertices(f_id);

	mov	eax, DWORD PTR tv3875[ebp]
	fstp	ST(1)
	mov	eax, DWORD PTR [eax+ecx]
	fstp	ST(0)
	mov	ecx, DWORD PTR _web+328

; 1775 :       REAL density = get_facet_density(f_id);

	fld	QWORD PTR [eax+32]
	mov	esi, DWORD PTR _dymem
	fstp	QWORD PTR _density$90936[ebp]
	mov	ecx, DWORD PTR [ecx+esi+304]

; 1776 : 
; 1777 :       for ( i = 0 ; i < ctrl ; i++ ) ii[i] = loc_ordinal(ix[i]);

	mov	ebx, DWORD PTR _ctrl$90912[ebp]
	add	ecx, eax
	mov	DWORD PTR _ix$90931[ebp], ecx
	test	ebx, ebx
	jle	SHORT $LN337@linear_met@2
	mov	esi, DWORD PTR _ii$[ebp]
	mov	eax, ecx
	sub	esi, ecx
	mov	edi, ebx
$LL106@linear_met@2:
	mov	ecx, DWORD PTR [eax]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN184@linear_met@2
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN185@linear_met@2
$LN184@linear_met@2:
	or	ecx, -1
$LN185@linear_met@2:
	mov	DWORD PTR [esi+eax], ecx
	add	eax, 4
	dec	edi
	jne	SHORT $LL106@linear_met@2
$LN337@linear_met@2:

; 1778 :       /* weight matrix */
; 1779 :       get_facet_verts(f_id,x,NULL);

	mov	eax, DWORD PTR _x$[ebp]
	push	0
	push	eax
	push	edx
	call	_get_facet_verts

; 1780 :       for ( i = 0 ; i < ctrl ; i++ )

	fldz
	add	esp, 12					; 0000000cH
	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN101@linear_met@2
$LN358@linear_met@2:

; 1781 :         for ( j = 0 ; j < ctrl ; j++ ) weights[i][j] = 0.0;

	xor	edx, edx
	cmp	ebx, 4
	jl	SHORT $LC288@linear_met@2
	mov	ecx, DWORD PTR _weights$[ebp]
	mov	eax, DWORD PTR [ecx+esi*4]
	lea	ecx, DWORD PTR [ebx-4]
	shr	ecx, 2
	add	eax, 16					; 00000010H
	inc	ecx
	lea	edx, DWORD PTR [ecx*4]
$LN289@linear_met@2:
	fst	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	ecx
	fst	QWORD PTR [eax-40]
	fst	QWORD PTR [eax-32]
	fst	QWORD PTR [eax-24]
	jne	SHORT $LN289@linear_met@2
$LC288@linear_met@2:
	cmp	edx, ebx
	jge	SHORT $LN102@linear_met@2
	mov	eax, DWORD PTR _weights$[ebp]
	mov	ecx, DWORD PTR [eax+esi*4]
	lea	edi, DWORD PTR [ecx+edx*8]
	mov	ecx, ebx
	sub	ecx, edx
	add	ecx, ecx
	and	ecx, 1073741822				; 3ffffffeH
	xor	eax, eax
	rep stosd
$LN102@linear_met@2:

; 1780 :       for ( i = 0 ; i < ctrl ; i++ )

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LN358@linear_met@2
$LN101@linear_met@2:

; 1782 :       /* simple vertex weighting part */
; 1783 :       for ( i = 0 ; i < ctrl ; i++ ) /* not very precise */

	xor	ebx, ebx
	cmp	DWORD PTR _ctrl$90912[ebp], 4
	jl	$LN330@linear_met@2
	mov	eax, DWORD PTR _ix$90931[ebp]
	fild	DWORD PTR _ctrl$90912[ebp]
	mov	ecx, DWORD PTR _weights$[ebp]
	fld1
	lea	edi, DWORD PTR [eax+12]
	sub	eax, ecx
	lea	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv7202[ebp], eax
$LN304@linear_met@2:

; 1784 :       { ATTR attr = get_vattr(ix[i]);

	mov	eax, DWORD PTR [edi-12]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _attr$90953[ebp+4], eax

; 1785 :         if ( attr & Q_MIDFACET )

	mov	eax, ecx
	and	eax, 2097152				; 00200000H
	xor	esi, esi
	or	eax, esi

; 1786 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl; 

	jne	SHORT $LN293@linear_met@2

; 1787 :         else if ( attr & Q_MIDEDGE )

	and	ecx, 4194304				; 00400000H
	or	ecx, eax
	je	SHORT $LN293@linear_met@2

; 1788 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl;

	fld	QWORD PTR _quadratic_metric_mix
	mov	eax, DWORD PTR [edx-4]
	fsubr	ST(0), ST(1)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [eax+ebx*8]

; 1789 :         else

	jmp	SHORT $LN294@linear_met@2
$LN293@linear_met@2:

; 1790 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl;

	fld	QWORD PTR _quadratic_metric_mix
	mov	ecx, DWORD PTR [edx-4]
	fsubr	ST(0), ST(1)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [ecx+ebx*8]
$LN294@linear_met@2:

; 1784 :       { ATTR attr = get_vattr(ix[i]);

	mov	eax, DWORD PTR tv7202[ebp]
	mov	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _attr$90953[ebp+4], eax

; 1785 :         if ( attr & Q_MIDFACET )

	mov	eax, ecx
	and	eax, 2097152				; 00200000H
	xor	esi, esi
	or	eax, esi

; 1786 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl; 

	jne	SHORT $LN296@linear_met@2

; 1787 :         else if ( attr & Q_MIDEDGE )

	and	ecx, 4194304				; 00400000H
	or	ecx, eax
	je	SHORT $LN296@linear_met@2

; 1788 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl;

	fld	QWORD PTR _quadratic_metric_mix
	mov	eax, DWORD PTR [edx]
	fsubr	ST(0), ST(1)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [eax+ebx*8+8]

; 1789 :         else

	jmp	SHORT $LN297@linear_met@2
$LN296@linear_met@2:

; 1790 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl;

	fld	QWORD PTR _quadratic_metric_mix
	mov	ecx, DWORD PTR [edx]
	fsubr	ST(0), ST(1)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [ecx+ebx*8+8]
$LN297@linear_met@2:

; 1784 :       { ATTR attr = get_vattr(ix[i]);

	mov	eax, DWORD PTR [edi-4]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _attr$90953[ebp+4], eax

; 1785 :         if ( attr & Q_MIDFACET )

	mov	eax, ecx
	and	eax, 2097152				; 00200000H
	xor	esi, esi
	or	eax, esi

; 1786 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl; 

	jne	SHORT $LN299@linear_met@2

; 1787 :         else if ( attr & Q_MIDEDGE )

	and	ecx, 4194304				; 00400000H
	or	ecx, eax
	je	SHORT $LN299@linear_met@2

; 1788 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl;

	fld	QWORD PTR _quadratic_metric_mix
	mov	eax, DWORD PTR [edx+4]
	fsubr	ST(0), ST(1)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [eax+ebx*8+16]

; 1789 :         else

	jmp	SHORT $LN300@linear_met@2
$LN299@linear_met@2:

; 1790 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl;

	fld	QWORD PTR _quadratic_metric_mix
	mov	ecx, DWORD PTR [edx+4]
	fsubr	ST(0), ST(1)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [ecx+ebx*8+16]
$LN300@linear_met@2:

; 1784 :       { ATTR attr = get_vattr(ix[i]);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _attr$90953[ebp+4], eax

; 1785 :         if ( attr & Q_MIDFACET )

	mov	eax, ecx
	and	eax, 2097152				; 00200000H
	xor	esi, esi
	or	eax, esi

; 1786 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl; 

	jne	SHORT $LN302@linear_met@2

; 1787 :         else if ( attr & Q_MIDEDGE )

	and	ecx, 4194304				; 00400000H
	or	ecx, eax
	je	SHORT $LN302@linear_met@2

; 1788 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl;

	fld	QWORD PTR _quadratic_metric_mix
	mov	eax, DWORD PTR [edx+8]
	fsubr	ST(0), ST(1)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [eax+ebx*8+24]

; 1789 :         else

	jmp	SHORT $LN303@linear_met@2
$LN302@linear_met@2:

; 1790 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl;

	fld	QWORD PTR _quadratic_metric_mix
	mov	ecx, DWORD PTR [edx+8]
	fsubr	ST(0), ST(1)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [ecx+ebx*8+24]
$LN303@linear_met@2:

; 1782 :       /* simple vertex weighting part */
; 1783 :       for ( i = 0 ; i < ctrl ; i++ ) /* not very precise */

	mov	eax, DWORD PTR _ctrl$90912[ebp]
	add	ebx, 4
	add	eax, -3					; fffffffdH
	add	edx, 16					; 00000010H
	add	edi, 16					; 00000010H
	cmp	ebx, eax
	jl	$LN304@linear_met@2

; 1790 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl;

	fstp	ST(1)

; 1782 :       /* simple vertex weighting part */
; 1783 :       for ( i = 0 ; i < ctrl ; i++ ) /* not very precise */

	jmp	SHORT $LC291@linear_met@2
$LN330@linear_met@2:
	fld1
$LC291@linear_met@2:
	cmp	ebx, DWORD PTR _ctrl$90912[ebp]
	jge	SHORT $LN290@linear_met@2
	mov	eax, DWORD PTR _weights$[ebp]
	fild	DWORD PTR _ctrl$90912[ebp]
	mov	edi, DWORD PTR _ix$90931[ebp]
	lea	edx, DWORD PTR [eax+ebx*4]
	sub	edi, eax
$LC97@linear_met@2:

; 1784 :       { ATTR attr = get_vattr(ix[i]);

	mov	eax, DWORD PTR [edx+edi]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _attr$90953[ebp+4], eax

; 1785 :         if ( attr & Q_MIDFACET )

	mov	eax, ecx
	and	eax, 2097152				; 00200000H
	xor	esi, esi
	or	eax, esi

; 1786 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl; 

	jne	SHORT $LN92@linear_met@2

; 1787 :         else if ( attr & Q_MIDEDGE )

	and	ecx, 4194304				; 00400000H
	or	ecx, eax
	je	SHORT $LN92@linear_met@2

; 1788 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl;

	fld	ST(1)
	mov	eax, DWORD PTR [edx]
	fsub	QWORD PTR _quadratic_metric_mix
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax+ebx*8]

; 1789 :         else

	jmp	SHORT $LN96@linear_met@2
$LN92@linear_met@2:

; 1790 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl;

	fld	ST(1)
	mov	ecx, DWORD PTR [edx]
	fsub	QWORD PTR _quadratic_metric_mix
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [ecx+ebx*8]
$LN96@linear_met@2:

; 1782 :       /* simple vertex weighting part */
; 1783 :       for ( i = 0 ; i < ctrl ; i++ ) /* not very precise */

	inc	ebx
	add	edx, 4
	cmp	ebx, DWORD PTR _ctrl$90912[ebp]
	jl	SHORT $LC97@linear_met@2

; 1790 :             weights[i][i] = (1-quadratic_metric_mix)/ctrl;

	fstp	ST(0)
$LN290@linear_met@2:

; 1791 :       }
; 1792 : 
; 1793 :       for ( m = 0 ; m < gl->gnumpts ; m++ )

	mov	edx, DWORD PTR _gl$90913[ebp]
	xor	edi, edi
	cmp	DWORD PTR [edx+4], edi
	jle	$LN88@linear_met@2
	fstp	ST(0)
$LN615@linear_met@2:

; 1794 :       { REAL value,det;
; 1795 :         mat_mult(gl->gpolypart[m],x,tang,web.dimension,ctrl,SDIM);

	mov	eax, DWORD PTR _web+616
	fstp	ST(0)
	mov	ecx, DWORD PTR _ctrl$90912[ebp]
	mov	edx, DWORD PTR _web+620
	mov	esi, DWORD PTR _tang$90910[ebp]
	push	eax
	mov	eax, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _gl$90913[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+24]
	push	esi
	push	eax
	mov	eax, DWORD PTR [edx+edi*4]
	push	eax
	call	_mat_mult

; 1796 :         for ( i = 0 ; i < web.dimension ; i++ )

	mov	eax, DWORD PTR _web+620
	add	esp, 24					; 00000018H
	mov	DWORD PTR _i$[ebp], 0
	test	eax, eax
	jle	$LN341@linear_met@2
	mov	ecx, DWORD PTR _matt$90916[ebp]
	sub	esi, ecx
	mov	DWORD PTR tv7464[ebp], ecx
	mov	DWORD PTR tv7440[ebp], esi
	npad	3
$LL87@linear_met@2:

; 1797 :           for ( j = 0 ; j <= i ; j++ )

	xor	esi, esi
	cmp	DWORD PTR _i$[ebp], esi
	jl	SHORT $LN86@linear_met@2
	mov	ebx, DWORD PTR _matt$90916[ebp]
$LL84@linear_met@2:

; 1798 :             matt[i][j] = matt[j][i] = SDIM_dot(tang[i],tang[j]);

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR tv7440[ebp]
	mov	edx, DWORD PTR [eax+ebx]
	push	ecx
	mov	ecx, DWORD PTR tv7464[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	_dot
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR tv7464[ebp]
	fst	QWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR [edx]
	fstp	QWORD PTR [ecx+esi*8]
	inc	esi
	add	esp, 12					; 0000000cH
	add	ebx, 4
	cmp	esi, eax
	jle	SHORT $LL84@linear_met@2

; 1797 :           for ( j = 0 ; j <= i ; j++ )

	mov	eax, DWORD PTR _web+620
$LN86@linear_met@2:

; 1796 :         for ( i = 0 ; i < web.dimension ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	add	DWORD PTR tv7464[ebp], 4
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, eax
	jl	SHORT $LL87@linear_met@2
$LN341@linear_met@2:

; 1799 :         det = det_adjoint(matt,web.dimension);

	mov	edx, DWORD PTR _matt$90916[ebp]
	push	eax
	push	edx
	call	_det_adjoint

; 1800 :         if ( det <= 0.0 ) value = 0.0;

	fldz
	fcom	ST(1)
	add	esp, 8
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN598@linear_met@2
	fstp	ST(1)
	fld	ST(0)
	jmp	SHORT $LN80@linear_met@2
$LN598@linear_met@2:
	fstp	ST(0)

; 1801 :         else value = gl->gausswt[m]*sqrt(det)/factorial[web.dimension];

	call	__CIsqrt
	mov	eax, DWORD PTR _gl$90913[ebp]
	mov	ecx, DWORD PTR [eax+12]
	fmul	QWORD PTR [ecx+edi*8]
	mov	edx, DWORD PTR _web+620
	fdiv	QWORD PTR _factorial[edx*8]
	fldz
	fxch	ST(1)
$LN80@linear_met@2:

; 1802 :         for ( i = 0 ; i < ctrl ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _ctrl$90912[ebp], ecx
	jle	$LN613@linear_met@2
$LN79@linear_met@2:

; 1803 :         { for ( j = 0 ; j < ctrl ; j++ )

	cmp	DWORD PTR _ctrl$90912[ebp], 4
	mov	DWORD PTR _j$[ebp], 0
	jl	$LC306@linear_met@2
	mov	eax, DWORD PTR _weights$[ebp]
	mov	ebx, DWORD PTR _ctrl$90912[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	add	ebx, -4					; fffffffcH
	lea	eax, DWORD PTR [edx+16]

; 1804 :             weights[i][j] += quadratic_metric_mix*value
; 1805 :                           *gl->gpoly[m][i]*gl->gpoly[m][j];

	neg	edx
	shr	ebx, 2
	inc	ebx
	mov	DWORD PTR tv7741[ebp], edx
	lea	edx, DWORD PTR [ebx*4]
	mov	DWORD PTR tv7555[ebp], 16		; 00000010H
	mov	DWORD PTR _j$[ebp], edx
$LN307@linear_met@2:
	fld	QWORD PTR _quadratic_metric_mix
	mov	edx, DWORD PTR _gl$90913[ebp]
	mov	edx, DWORD PTR [edx+20]
	fmul	ST(0), ST(1)
	mov	edx, DWORD PTR [edx+edi*4]
	mov	esi, DWORD PTR tv7741[ebp]
	fmul	QWORD PTR [edx+ecx*8]
	lea	esi, DWORD PTR [esi+eax-16]
	add	eax, 32					; 00000020H
	fmul	QWORD PTR [edx+esi]
	mov	edx, DWORD PTR _gl$90913[ebp]
	fadd	QWORD PTR [eax-48]
	fstp	QWORD PTR [eax-48]
	mov	edx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR [edx+edi*4]
	fld	QWORD PTR _quadratic_metric_mix
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edx+ecx*8]
	fmul	QWORD PTR [edx+esi+8]
	mov	edx, DWORD PTR _gl$90913[ebp]
	mov	esi, DWORD PTR tv7555[ebp]
	add	DWORD PTR tv7555[ebp], 32		; 00000020H
	dec	ebx
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	mov	edx, DWORD PTR [edx+20]
	fld	QWORD PTR _quadratic_metric_mix
	mov	edx, DWORD PTR [edx+edi*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edx+ecx*8]
	fmul	QWORD PTR [edx+esi]
	mov	edx, DWORD PTR _gl$90913[ebp]
	mov	esi, DWORD PTR tv7741[ebp]
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	mov	edx, DWORD PTR [edx+20]
	fld	QWORD PTR _quadratic_metric_mix
	mov	edx, DWORD PTR [edx+edi*4]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+esi+8]
	fmul	QWORD PTR [edx+eax-32]
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	jne	$LN307@linear_met@2
$LC306@linear_met@2:

; 1803 :         { for ( j = 0 ; j < ctrl ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR _ctrl$90912[ebp]
	cmp	eax, ebx
	jge	SHORT $LN78@linear_met@2
	mov	edx, DWORD PTR _weights$[ebp]
	mov	esi, DWORD PTR [edx+ecx*4]
$LC76@linear_met@2:

; 1804 :             weights[i][j] += quadratic_metric_mix*value
; 1805 :                           *gl->gpoly[m][i]*gl->gpoly[m][j];

	fld	QWORD PTR _quadratic_metric_mix
	mov	edx, DWORD PTR _gl$90913[ebp]
	mov	edx, DWORD PTR [edx+20]
	fmul	ST(0), ST(1)
	mov	edx, DWORD PTR [edx+edi*4]
	inc	eax
	fmul	QWORD PTR [edx+ecx*8]
	fmul	QWORD PTR [edx+eax*8-8]
	fadd	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]
	cmp	eax, ebx
	jl	SHORT $LC76@linear_met@2
$LN78@linear_met@2:

; 1802 :         for ( i = 0 ; i < ctrl ; i++ )

	inc	ecx
	cmp	ecx, ebx
	jl	$LN79@linear_met@2
$LN613@linear_met@2:

; 1791 :       }
; 1792 : 
; 1793 :       for ( m = 0 ; m < gl->gnumpts ; m++ )

	mov	eax, DWORD PTR _gl$90913[ebp]

; 1803 :         { for ( j = 0 ; j < ctrl ; j++ )

	fstp	ST(0)
	inc	edi
	cmp	edi, DWORD PTR [eax+4]
	jl	$LN615@linear_met@2

; 1791 :       }
; 1792 : 
; 1793 :       for ( m = 0 ; m < gl->gnumpts ; m++ )

	fld1
$LN88@linear_met@2:

; 1806 :         }
; 1807 :       }
; 1808 :       for ( i = 0 ; i < ctrl ; i++ )

	mov	esi, DWORD PTR _ctrl$90912[ebp]
	mov	ebx, DWORD PTR _weights$[ebp]
	xor	edi, edi
	test	esi, esi
	jle	SHORT $LN71@linear_met@2
	fld	QWORD PTR _density$90936[ebp]
$LN359@linear_met@2:

; 1809 :         for ( j = 0 ; j < ctrl ; j++ ) weights[i][j] *= density;

	xor	edx, edx
	cmp	esi, 4
	jl	SHORT $LC309@linear_met@2
	mov	eax, DWORD PTR [ebx+edi*4]
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	add	eax, 16					; 00000010H
	inc	ecx
	lea	edx, DWORD PTR [ecx*4]
$LN310@linear_met@2:
	fld	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	ecx
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-48]
	fld	ST(0)
	fmul	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax-32]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-32]
	fld	ST(0)
	fmul	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN310@linear_met@2
$LC309@linear_met@2:
	cmp	edx, esi
	jge	SHORT $LN72@linear_met@2
	mov	ecx, DWORD PTR [ebx+edi*4]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, esi
	sub	ecx, edx
$LC70@linear_met@2:
	fld	QWORD PTR [eax]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC70@linear_met@2
$LN72@linear_met@2:

; 1806 :         }
; 1807 :       }
; 1808 :       for ( i = 0 ; i < ctrl ; i++ )

	inc	edi
	cmp	edi, esi
	jl	SHORT $LN359@linear_met@2
	fstp	ST(0)
$LN71@linear_met@2:

; 1810 : 
; 1811 :       for ( i = 0 ; i < ctrl ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	esi, esi
	jle	$LN326@linear_met@2
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR _ix$90931[ebp]
	sub	ecx, eax
	sub	eax, ebx
	mov	DWORD PTR tv8532[ebp], ebx
	mov	DWORD PTR tv8446[ebp], ecx
	mov	DWORD PTR tv6500[ebp], eax
	jmp	SHORT $LN67@linear_met@2
$LN344@linear_met@2:
	mov	eax, DWORD PTR tv6500[ebp]
	mov	ecx, DWORD PTR tv8446[ebp]
$LN67@linear_met@2:

; 1812 :       { struct hess_verlist *v = get_vertex_vhead(ix[i]);

	add	eax, DWORD PTR tv8532[ebp]
	mov	edx, DWORD PTR _web+12
	mov	DWORD PTR tv8566[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _vhead_attr
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+64]
	mov	esi, DWORD PTR [eax+ecx]
	shl	esi, 5
	add	esi, DWORD PTR _vhead

; 1813 : 
; 1814 :         /* self */
; 1815 :         if ( v->proj )

	cmp	DWORD PTR [esi+16], 0
	je	$LN64@linear_met@2

; 1816 :         { 
; 1817 :           tr_mat_mul(v->proj,v->proj,temp_mat,SDIM,v->freedom,v->freedom);

	mov	eax, DWORD PTR [esi+8]
	fstp	ST(0)
	mov	edx, DWORD PTR _web+616
	fstp	ST(0)
	mov	ecx, DWORD PTR [esi+16]
	mov	edi, DWORD PTR _temp_mat$[ebp]
	push	eax
	push	eax
	push	edx
	push	edi
	push	ecx
	push	ecx
	call	_tr_mat_mul

; 1818 :           mat = temp_mat;

	fld1
	fldz
	add	esp, 24					; 00000018H
	fxch	ST(1)
$LN63@linear_met@2:

; 1821 : 
; 1822 :         for ( jj = 0 ; jj < v->freedom ; jj++ )

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN60@linear_met@2
	mov	DWORD PTR tv8278[ebp], edi
$LN62@linear_met@2:

; 1823 :           for ( k = jj ; k < v->freedom ; k++ )

	mov	ecx, ebx
	cmp	ebx, eax
	jge	SHORT $LN61@linear_met@2
	mov	eax, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _mlist$[ebp]
	add	eax, eax
	lea	eax, DWORD PTR [edx+eax*8+8]
$LN59@linear_met@2:

; 1824 :           { col = v->rownum + k;
; 1825 :             row = v->rownum+jj;

	mov	edx, DWORD PTR [esi+12]

; 1826 :             mlist[count].col = col;
; 1827 :             mlist[count].row = row;
; 1828 :             mlist[count++].val = v->slant*v->slant*weights[i][i]*mat[jj][k];

	inc	DWORD PTR _count$[ebp]
	lea	edi, DWORD PTR [edx+ebx]
	add	edx, ecx
	mov	DWORD PTR [eax-4], edx
	mov	edx, DWORD PTR tv8532[ebp]
	mov	DWORD PTR [eax-8], edi
	fld	QWORD PTR [esi+24]
	mov	edx, DWORD PTR [edx]
	fmul	ST(0), ST(0)
	mov	edi, DWORD PTR _i$[ebp]
	inc	ecx
	fmul	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR tv8278[ebp]
	mov	edx, DWORD PTR [edx]
	add	eax, 16					; 00000010H
	fmul	QWORD PTR [edx+ecx*8-8]
	fstp	QWORD PTR [eax-16]
	cmp	ecx, DWORD PTR [esi+8]
	jl	SHORT $LN59@linear_met@2
$LN61@linear_met@2:

; 1821 : 
; 1822 :         for ( jj = 0 ; jj < v->freedom ; jj++ )

	mov	eax, DWORD PTR [esi+8]
	add	DWORD PTR tv8278[ebp], 4
	inc	ebx
	cmp	ebx, eax
	jl	SHORT $LN62@linear_met@2
$LN60@linear_met@2:

; 1829 :           }
; 1830 : 
; 1831 :         /* cross terms */
; 1832 :         for ( k = 0 ; k < ctrl ; k++ )

	mov	eax, DWORD PTR _ii$[ebp]
	mov	DWORD PTR _k$[ebp], 0
	mov	DWORD PTR tv8416[ebp], eax
	jmp	SHORT $LN56@linear_met@2
$LN64@linear_met@2:

; 1819 :         }
; 1820 :         else mat = identmat;

	mov	edi, DWORD PTR _identmat
	jmp	$LN63@linear_met@2
$LN347@linear_met@2:

; 1829 :           }
; 1830 : 
; 1831 :         /* cross terms */
; 1832 :         for ( k = 0 ; k < ctrl ; k++ )

	mov	eax, DWORD PTR tv8416[ebp]
$LN56@linear_met@2:

; 1833 :         { struct hess_verlist *vv = get_vertex_vhead(ix[k]);

	mov	ecx, DWORD PTR tv8446[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR _vhead_attr
	mov	edi, DWORD PTR _web+12
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+104
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edi+64]
	mov	edi, DWORD PTR [edx+ecx]

; 1834 :             
; 1835 :           if ( ii[k] <= ii[i] ) continue;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR tv8566[ebp]
	shl	edi, 5
	add	edi, DWORD PTR _vhead
	cmp	edx, DWORD PTR [eax]
	jle	$LN55@linear_met@2

; 1836 : 
; 1837 :           if ( v->proj && vv->proj )

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	$LN50@linear_met@2
	mov	ecx, DWORD PTR [edi+16]
	fstp	ST(0)

; 1838 :           { tr_mat_mul(v->proj,vv->proj,temp_mat,SDIM,v->freedom,vv->freedom);

	mov	ebx, DWORD PTR _temp_mat$[ebp]
	fstp	ST(0)
	test	ecx, ecx
	je	$LN52@linear_met@2
	mov	edx, DWORD PTR [edi+8]
	push	edx
	mov	edx, DWORD PTR [esi+8]
	push	edx
	mov	edx, DWORD PTR _web+616
	push	edx
	push	ebx
	push	ecx
$LN624@linear_met@2:
	push	eax
	call	_tr_mat_mul

; 1839 :             mat = temp_mat;

	fld1
	fldz
	add	esp, 24					; 00000018H
	mov	eax, ebx

; 1843 :             mat = temp_mat;

	fxch	ST(1)
$LN47@linear_met@2:

; 1847 : 
; 1848 :           for ( jj = 0 ; jj < v->freedom ; jj++ )  

	cmp	DWORD PTR [esi+8], 0
	mov	DWORD PTR _jj$[ebp], 0
	jle	$LN55@linear_met@2
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR tv8352[ebp], eax
$LN46@linear_met@2:

; 1849 :             for ( kk = 0 ; kk < vv->freedom ; kk++ )  

	xor	ecx, ecx
	test	edx, edx
	jle	$LN45@linear_met@2
	mov	eax, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _mlist$[ebp]
	add	eax, eax
	lea	eax, DWORD PTR [edx+eax*8+8]
$LN332@linear_met@2:

; 1850 :             { col = vv->rownum + kk;

	mov	edx, DWORD PTR [edi+12]
	add	edx, ecx
	mov	DWORD PTR _col$[ebp], edx

; 1851 :               row = v->rownum+jj;

	mov	edx, DWORD PTR [esi+12]
	add	edx, DWORD PTR _jj$[ebp]

; 1852 :               if ( col < row )

	mov	ebx, DWORD PTR _col$[ebp]
	cmp	ebx, edx
	jge	SHORT $LN40@linear_met@2

; 1853 :               { int temp = col; col = row; row = temp; }

	mov	DWORD PTR _temp$91024[ebp], ebx
	mov	ebx, edx
	mov	edx, DWORD PTR _temp$91024[ebp]
$LN40@linear_met@2:

; 1854 :               mlist[count].col = col;
; 1855 :               mlist[count].row = row;
; 1856 :               mlist[count++].val = 
; 1857 :                  v->slant*vv->slant*mat[jj][kk]*weights[i][k];

	inc	DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR tv8352[ebp]
	mov	DWORD PTR [eax-4], ebx
	fld	QWORD PTR [edi+24]
	mov	edx, DWORD PTR [edx]
	fmul	QWORD PTR [esi+24]
	mov	ebx, DWORD PTR _k$[ebp]
	inc	ecx
	fmul	QWORD PTR [edx+ecx*8-8]
	mov	edx, DWORD PTR tv8532[ebp]
	mov	edx, DWORD PTR [edx]
	add	eax, 16					; 00000010H
	fmul	QWORD PTR [edx+ebx*8]
	fstp	QWORD PTR [eax-16]
	mov	edx, DWORD PTR [edi+8]
	cmp	ecx, edx
	jl	SHORT $LN332@linear_met@2
$LN45@linear_met@2:

; 1847 : 
; 1848 :           for ( jj = 0 ; jj < v->freedom ; jj++ )  

	mov	eax, DWORD PTR _jj$[ebp]
	add	DWORD PTR tv8352[ebp], 4
	inc	eax
	mov	DWORD PTR _jj$[ebp], eax
	cmp	eax, DWORD PTR [esi+8]
	jl	$LN46@linear_met@2
$LN55@linear_met@2:

; 1829 :           }
; 1830 : 
; 1831 :         /* cross terms */
; 1832 :         for ( k = 0 ; k < ctrl ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	add	DWORD PTR tv8416[ebp], 4
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _ctrl$90912[ebp]
	jl	$LN347@linear_met@2

; 1810 : 
; 1811 :       for ( i = 0 ; i < ctrl ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv8532[ebp], 4
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _ctrl$90912[ebp]
	jl	$LN344@linear_met@2
$LN326@linear_met@2:
	mov	ecx, DWORD PTR _web+236
	fxch	ST(1)
$LN110@linear_met@2:

; 1771 : 
; 1772 :     /* facet by facet */
; 1773 :     FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR tv3875[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [edx]
	test	edx, 268435456				; 10000000H
	jne	$LN340@linear_met@2
	mov	edi, DWORD PTR _maxcount$[ebp]
	mov	esi, DWORD PTR _M$GSCopy$[ebp]
	jmp	SHORT $LN626@linear_met@2
$LN52@linear_met@2:

; 1840 :           }
; 1841 :           else if ( v->proj )
; 1842 :           { tr_mat_mul(v->proj,identmat,temp_mat,SDIM,v->freedom,vv->freedom);

	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR _web+616
	push	edx
	mov	edx, DWORD PTR _identmat
	push	ecx
	push	ebx
	push	edx

; 1843 :             mat = temp_mat;

	jmp	$LN624@linear_met@2
$LN50@linear_met@2:

; 1844 :           }
; 1845 :           else if ( vv->proj ) mat = vv->proj;

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	jne	$LN47@linear_met@2

; 1846 :           else mat = identmat;

	mov	eax, DWORD PTR _identmat
	jmp	$LN47@linear_met@2
$LN351@linear_met@2:

; 1771 : 
; 1772 :     /* facet by facet */
; 1773 :     FOR_ALL_FACETS(f_id)

	fld1
	fldz
$LN626@linear_met@2:

; 1858 :             }
; 1859 :          }
; 1860 :        }
; 1861 :      }
; 1862 :   }
; 1863 :   if ( count > maxcount ) 

	mov	edx, DWORD PTR _count$[ebp]
	mov	ebx, DWORD PTR _S$GSCopy$[ebp]
	cmp	edx, edi
	jle	SHORT $LN39@linear_met@2

; 1864 :   {kb_error(1869,
; 1865 :      "Internal error in linear_metric setup Lagrange: count > maxcount",
; 1866 :     RECOVERABLE);

	push	1
	fstp	ST(1)
	push	OFFSET ??_C@_0EB@FKEJFEGH@Internal?5error?5in?5linear_metric?5@
	fstp	ST(0)
	push	1869					; 0000074dH
	call	_kb_error
	fld1
	fldz
	mov	edx, DWORD PTR _count$[ebp]
	add	esp, 12					; 0000000cH
$LN39@linear_met@2:

; 1867 :   }
; 1868 : 
; 1869 :   /* non-element stuff */
; 1870 :   for ( i = 0 ; i < optparamcount ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _optparamcount, ecx
	jle	SHORT $LN371@linear_met@2
	mov	edi, DWORD PTR _mlist$[ebp]
	mov	eax, edx
	add	eax, eax
	lea	eax, DWORD PTR [edi+eax*8+8]
	jmp	SHORT $LN38@linear_met@2
$LN375@linear_met@2:
	fxch	ST(1)
$LN38@linear_met@2:

; 1871 :   { mlist[count].row = S->optparamrowstart+i;

	mov	edi, DWORD PTR [ebx+16]

; 1872 :     mlist[count].col = S->optparamrowstart+i;
; 1873 :     mlist[count].val = 1.0;

	fxch	ST(1)
	add	edi, ecx
	mov	DWORD PTR [eax-8], edi
	mov	edi, DWORD PTR [ebx+16]
	fst	QWORD PTR [eax]
	add	edi, ecx
	mov	DWORD PTR [eax-4], edi
	inc	ecx

; 1874 :     count++;

	inc	edx
	add	eax, 16					; 00000010H
	cmp	ecx, DWORD PTR _optparamcount
	jl	SHORT $LN375@linear_met@2
	fstp	ST(0)
	mov	DWORD PTR _count$[ebp], edx
	jmp	SHORT $LN352@linear_met@2
$LN371@linear_met@2:
	fstp	ST(1)
$LN352@linear_met@2:

; 1875 :   }
; 1876 :   /* leave rest of diagonal zero in case of augmented hessian */
; 1877 : 
; 1878 :   for ( i = S->optparamrowstart ; i < S->N ; i++ )

	mov	ecx, DWORD PTR [ebx+16]
	cmp	ecx, DWORD PTR [ebx+4]
	jge	SHORT $LN378@linear_met@2
	mov	edi, DWORD PTR _mlist$[ebp]
	mov	eax, edx
	add	eax, eax
	lea	eax, DWORD PTR [edi+eax*8+8]
$LN35@linear_met@2:

; 1879 :   { /* make sure rest of diagonal exists, but no shift */
; 1880 :     mlist[count].row = i;

	mov	DWORD PTR [eax-8], ecx

; 1881 :     mlist[count].col = i;
; 1882 :     mlist[count].val = 0.0;

	fst	QWORD PTR [eax]
	mov	DWORD PTR [eax-4], ecx
	inc	ecx

; 1883 :     count++;

	inc	edx
	add	eax, 16					; 00000010H
	cmp	ecx, DWORD PTR [ebx+4]
	jl	SHORT $LN35@linear_met@2
	mov	DWORD PTR _count$[ebp], edx
$LN378@linear_met@2:

; 1884 :   }
; 1885 : 
; 1886 :   /* sort and combine entries */
; 1887 :   temp = (struct mentry *)temp_calloc(count,sizeof(struct mentry));

	mov	edi, DWORD PTR _count$[ebp]
	fstp	ST(0)
	push	1887					; 0000075fH
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	16					; 00000010H
	push	edi
	call	_kb_temp_calloc
	mov	ebx, DWORD PTR _mlist$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _temp$[ebp], eax

; 1888 :   /* radix sort, first on columns */
; 1889 :   /* count columns */
; 1890 :   for ( i = 0 ; i < count ; i++ ) M->IA[mlist[i].col]++;

	test	edi, edi
	jle	SHORT $LN30@linear_met@2

; 1884 :   }
; 1885 : 
; 1886 :   /* sort and combine entries */
; 1887 :   temp = (struct mentry *)temp_calloc(count,sizeof(struct mentry));

	lea	ecx, DWORD PTR [ebx+4]
	mov	edx, edi
$LL32@linear_met@2:

; 1888 :   /* radix sort, first on columns */
; 1889 :   /* count columns */
; 1890 :   for ( i = 0 ; i < count ; i++ ) M->IA[mlist[i].col]++;

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [esi+52]
	inc	DWORD PTR [edi+eax*4]
	lea	eax, DWORD PTR [edi+eax*4]
	add	ecx, 16					; 00000010H
	dec	edx
	jne	SHORT $LL32@linear_met@2
$LN30@linear_met@2:

; 1891 :   for ( n = 0, total = 0 ; n < M->N ; n++ )

	xor	eax, eax
	xor	edx, edx
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN27@linear_met@2
	npad	6
$LL29@linear_met@2:
	mov	ecx, DWORD PTR [esi+52]

; 1892 :   { int tmp = M->IA[n];

	mov	edi, DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]

; 1893 :     M->IA[n] = total;

	mov	DWORD PTR [ecx], edx
	inc	eax

; 1894 :     total += tmp;

	add	edx, edi
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL29@linear_met@2
$LN27@linear_met@2:

; 1895 :   }
; 1896 :   M->IA[M->N] = total;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx+eax*4], edx

; 1897 :   /* sort into temp */
; 1898 :   for ( i = 0 ; i < count ; i++ )

	mov	edx, DWORD PTR _count$[ebp]
	test	edx, edx
	jle	SHORT $LN355@linear_met@2

; 1895 :   }
; 1896 :   M->IA[M->N] = total;

	lea	ecx, DWORD PTR [ebx+4]
	npad	7
$LL26@linear_met@2:

; 1899 :      temp[M->IA[mlist[i].col]++] = mlist[i];

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [ecx-4]
	shl	eax, 4
	add	eax, DWORD PTR _temp$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx-16]
	mov	DWORD PTR [eax+4], edi
	mov	edi, DWORD PTR [ecx-12]
	mov	DWORD PTR [eax+8], edi
	mov	edi, DWORD PTR [ecx-8]
	mov	DWORD PTR [eax+12], edi
	mov	eax, DWORD PTR [ecx-16]
	mov	edi, DWORD PTR [esi+52]
	inc	DWORD PTR [edi+eax*4]
	dec	edx
	lea	eax, DWORD PTR [edi+eax*4]
	jne	SHORT $LL26@linear_met@2

; 1897 :   /* sort into temp */
; 1898 :   for ( i = 0 ; i < count ; i++ )

	mov	edx, DWORD PTR _count$[ebp]
$LN355@linear_met@2:

; 1900 :   /* now sort on rows */
; 1901 :   for ( n = 0; n < M->N ; n++ )M->IA[n] = 0;

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN21@linear_met@2
	npad	9
$LL23@linear_met@2:
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx+eax*4], 0
	inc	eax
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL23@linear_met@2
$LN21@linear_met@2:

; 1902 :   for ( i = 0 ; i < count ; i++ ) M->IA[temp[i].row]++;

	test	edx, edx
	jle	SHORT $LN18@linear_met@2
	mov	ecx, DWORD PTR _temp$[ebp]
	npad	6
$LL20@linear_met@2:
	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [esi+52]
	inc	DWORD PTR [edi+eax*4]
	lea	eax, DWORD PTR [edi+eax*4]
	add	ecx, 16					; 00000010H
	dec	edx
	jne	SHORT $LL20@linear_met@2
$LN18@linear_met@2:

; 1903 :   for ( n = 0, total = 0 ; n < M->N ; n++ )

	xor	eax, eax
	xor	edx, edx
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN15@linear_met@2
	npad	6
$LL17@linear_met@2:
	mov	ecx, DWORD PTR [esi+52]

; 1904 :   { int tmp = M->IA[n];

	mov	edi, DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]

; 1905 :     M->IA[n] = total;

	mov	DWORD PTR [ecx], edx
	inc	eax

; 1906 :     total += tmp;

	add	edx, edi
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL17@linear_met@2
$LN15@linear_met@2:

; 1909 :   /* sort into mlist */
; 1910 :   for ( i = 0 ; i < count ; i++ )

	mov	edi, DWORD PTR _count$[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx+eax*4], edx
	test	edi, edi
	jle	SHORT $LN356@linear_met@2

; 1907 :   }
; 1908 :   M->IA[M->N] = total;

	mov	ecx, DWORD PTR _temp$[ebp]
	mov	edx, edi
	npad	2
$LL14@linear_met@2:

; 1911 :      mlist[M->IA[temp[i].row]++] = temp[i];

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [ecx]
	shl	eax, 4
	mov	DWORD PTR [eax+ebx], edi
	mov	edi, DWORD PTR [ecx+4]
	add	eax, ebx
	mov	DWORD PTR [eax+4], edi
	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edi
	mov	edi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edi
	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [esi+52]
	inc	DWORD PTR [edi+eax*4]
	lea	eax, DWORD PTR [edi+eax*4]
	add	ecx, 16					; 00000010H
	dec	edx
	jne	SHORT $LL14@linear_met@2

; 1909 :   /* sort into mlist */
; 1910 :   for ( i = 0 ; i < count ; i++ )

	mov	edi, DWORD PTR _count$[ebp]
$LN356@linear_met@2:

; 1912 :   /* compress */
; 1913 :   for ( i = 1, j = 0 ; i < count ; i++ )

	mov	eax, 1
	xor	edx, edx
	mov	DWORD PTR _i$[ebp], eax
	cmp	edi, eax
	jle	$LN354@linear_met@2
	lea	ecx, DWORD PTR [edi-1]
	cmp	ecx, 4
	jl	$LC312@linear_met@2

; 1914 :   { if ( (mlist[j].row == mlist[i].row) && (mlist[j].col == mlist[i].col) )

	add	edi, -5					; fffffffbH
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv9559[ebp], edi
	lea	edi, DWORD PTR [edi*4+1]
	mov	eax, ebx
	lea	ecx, DWORD PTR [ebx+24]
	mov	DWORD PTR _i$[ebp], edi
	npad	5
$LL321@linear_met@2:
	mov	edi, DWORD PTR [eax]
	cmp	edi, DWORD PTR [ecx-8]
	jne	SHORT $LN313@linear_met@2
	mov	edi, DWORD PTR [eax+4]
	cmp	edi, DWORD PTR [ecx-4]
	jne	SHORT $LN313@linear_met@2

; 1915 :          mlist[j].val += mlist[i].val;

	fld	QWORD PTR [eax+8]
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [eax+8]
	jmp	SHORT $LN314@linear_met@2
$LN313@linear_met@2:

; 1916 :     else { mlist[++j] = mlist[i]; }

	mov	edi, DWORD PTR [ecx-8]
	inc	edx
	mov	eax, edx
	shl	eax, 4
	add	eax, ebx
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx-4]
	mov	DWORD PTR [eax+4], edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], edi
$LN314@linear_met@2:

; 1914 :   { if ( (mlist[j].row == mlist[i].row) && (mlist[j].col == mlist[i].col) )

	mov	edi, DWORD PTR [eax]
	cmp	edi, DWORD PTR [ecx+8]
	jne	SHORT $LN315@linear_met@2
	mov	edi, DWORD PTR [eax+4]
	cmp	edi, DWORD PTR [ecx+12]
	jne	SHORT $LN315@linear_met@2

; 1915 :          mlist[j].val += mlist[i].val;

	fld	QWORD PTR [ecx+16]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	jmp	SHORT $LN316@linear_met@2
$LN315@linear_met@2:

; 1916 :     else { mlist[++j] = mlist[i]; }

	mov	edi, DWORD PTR [ecx+8]
	inc	edx
	mov	eax, edx
	shl	eax, 4
	add	eax, ebx
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edi
	mov	edi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+8], edi
	mov	edi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+12], edi
$LN316@linear_met@2:

; 1914 :   { if ( (mlist[j].row == mlist[i].row) && (mlist[j].col == mlist[i].col) )

	mov	edi, DWORD PTR [eax]
	cmp	edi, DWORD PTR [ecx+24]
	jne	SHORT $LN317@linear_met@2
	mov	edi, DWORD PTR [eax+4]
	cmp	edi, DWORD PTR [ecx+28]
	jne	SHORT $LN317@linear_met@2

; 1915 :          mlist[j].val += mlist[i].val;

	fld	QWORD PTR [ecx+32]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	jmp	SHORT $LN318@linear_met@2
$LN317@linear_met@2:

; 1916 :     else { mlist[++j] = mlist[i]; }

	mov	edi, DWORD PTR [ecx+24]
	inc	edx
	mov	eax, edx
	shl	eax, 4
	add	eax, ebx
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+4], edi
	mov	edi, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+8], edi
	mov	edi, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+12], edi
$LN318@linear_met@2:

; 1914 :   { if ( (mlist[j].row == mlist[i].row) && (mlist[j].col == mlist[i].col) )

	mov	edi, DWORD PTR [eax]
	cmp	edi, DWORD PTR [ecx+40]
	jne	SHORT $LN319@linear_met@2
	mov	edi, DWORD PTR [eax+4]
	cmp	edi, DWORD PTR [ecx+44]
	jne	SHORT $LN319@linear_met@2

; 1915 :          mlist[j].val += mlist[i].val;

	fld	QWORD PTR [ecx+48]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	jmp	SHORT $LN320@linear_met@2
$LN319@linear_met@2:

; 1916 :     else { mlist[++j] = mlist[i]; }

	mov	edi, DWORD PTR [ecx+40]
	inc	edx
	mov	eax, edx
	shl	eax, 4
	add	eax, ebx
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+4], edi
	mov	edi, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+8], edi
	mov	edi, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+12], edi
$LN320@linear_met@2:

; 1914 :   { if ( (mlist[j].row == mlist[i].row) && (mlist[j].col == mlist[i].col) )

	add	ecx, 64					; 00000040H
	dec	DWORD PTR tv9559[ebp]
	jne	$LL321@linear_met@2
	mov	eax, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR _count$[ebp]
$LC312@linear_met@2:

; 1912 :   /* compress */
; 1913 :   for ( i = 1, j = 0 ; i < count ; i++ )

	cmp	eax, edi
	jge	SHORT $LN354@linear_met@2
	mov	ecx, edx
	shl	ecx, 4
	shl	eax, 4
	add	ecx, ebx
	add	eax, ebx
	sub	edi, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv9731[ebp], edi
	npad	7
$LC11@linear_met@2:

; 1914 :   { if ( (mlist[j].row == mlist[i].row) && (mlist[j].col == mlist[i].col) )

	mov	edi, DWORD PTR [ecx]
	cmp	edi, DWORD PTR [eax]
	jne	SHORT $LN8@linear_met@2
	mov	edi, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [eax+4]
	jne	SHORT $LN8@linear_met@2

; 1915 :          mlist[j].val += mlist[i].val;

	fld	QWORD PTR [ecx+8]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [ecx+8]
	jmp	SHORT $LN10@linear_met@2
$LN8@linear_met@2:

; 1916 :     else { mlist[++j] = mlist[i]; }

	mov	edi, DWORD PTR [eax]
	inc	edx
	mov	ecx, edx
	shl	ecx, 4
	add	ecx, ebx
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edi
	mov	edi, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edi
$LN10@linear_met@2:

; 1912 :   /* compress */
; 1913 :   for ( i = 1, j = 0 ; i < count ; i++ )

	add	eax, 16					; 00000010H
	dec	DWORD PTR tv9731[ebp]
	jne	SHORT $LC11@linear_met@2
$LN354@linear_met@2:

; 1921 :   M->JA = (int*)temp_calloc(count,sizeof(int));

	push	1921					; 00000781H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	lea	edi, DWORD PTR [edx+1]
	push	4
	push	edi
	mov	DWORD PTR _count$[ebp], edi
	call	_kb_temp_calloc

; 1922 :   M->A = (REAL *)temp_calloc(count,sizeof(REAL));

	push	1922					; 00000782H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	8
	push	edi
	mov	DWORD PTR [esi+56], eax
	call	_kb_temp_calloc

; 1923 :   M->IA[0] = A_OFF;

	mov	edx, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+60], eax
	add	esp, 32					; 00000020H

; 1924 :   for ( j = 0 ; j < count ; j++ )

	xor	eax, eax
	mov	DWORD PTR [edx], 1
	cmp	edi, 4
	jl	$LN350@linear_met@2

; 1917 :   }
; 1918 : 
; 1919 :   /* put into M structure */
; 1920 :   count = j+1;

	lea	ecx, DWORD PTR [ebx+8]
	npad	1

; 1924 :   for ( j = 0 ; j < count ; j++ )

$LL324@linear_met@2:

; 1925 :   { M->IA[mlist[j].row+1] = j + 1 + A_OFF;

	mov	edi, DWORD PTR [ecx-8]
	mov	ebx, DWORD PTR [esi+52]

; 1927 :     M->A[j] = mlist[j].val;

	lea	edx, DWORD PTR [eax+2]
	mov	DWORD PTR [ebx+edi*4+4], edx
	mov	edx, DWORD PTR [ecx-4]
	mov	edi, DWORD PTR [esi+56]
	inc	edx
	mov	DWORD PTR [edi+eax*4], edx
	fld	QWORD PTR [ecx]
	mov	edx, DWORD PTR [esi+60]
	fstp	QWORD PTR [edx+eax*8]
	mov	edi, DWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [esi+52]
	lea	edx, DWORD PTR [eax+3]
	mov	DWORD PTR [ebx+edi*4+4], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	edi, DWORD PTR [esi+56]
	inc	edx
	mov	DWORD PTR [edi+eax*4+4], edx
	fld	QWORD PTR [ecx+16]
	mov	edx, DWORD PTR [esi+60]
	fstp	QWORD PTR [edx+eax*8+8]
	mov	edi, DWORD PTR [ecx+24]
	mov	ebx, DWORD PTR [esi+52]
	lea	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ebx+edi*4+4], edx
	mov	edi, DWORD PTR [ecx+28]
	mov	ebx, DWORD PTR [esi+56]
	inc	edi
	mov	DWORD PTR [ebx+eax*4+8], edi
	fld	QWORD PTR [ecx+32]
	mov	ebx, DWORD PTR [esi+60]
	mov	DWORD PTR tv3552[ebp], edx
	lea	edx, DWORD PTR [eax*4+12]
	lea	edi, DWORD PTR [eax*8+24]
	fstp	QWORD PTR [edi+ebx-8]
	mov	ebx, DWORD PTR [esi+52]
	add	eax, 5
	mov	DWORD PTR tv10589[ebp], edi
	mov	edi, DWORD PTR [ecx+40]
	mov	DWORD PTR [ebx+edi*4+4], eax
	mov	eax, DWORD PTR [ecx+44]
	mov	edi, DWORD PTR [esi+56]
	inc	eax
	mov	DWORD PTR [edx+edi], eax
	fld	QWORD PTR [ecx+48]
	mov	edx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR tv10589[ebp]
	mov	edi, DWORD PTR _count$[ebp]
	fstp	QWORD PTR [eax+edx]
	mov	eax, DWORD PTR tv3552[ebp]
	lea	edx, DWORD PTR [edi-3]
	add	ecx, 64					; 00000040H
	cmp	eax, edx
	jl	$LL324@linear_met@2
$LN350@linear_met@2:

; 1924 :   for ( j = 0 ; j < count ; j++ )

	cmp	eax, edi
	jge	SHORT $LN357@linear_met@2
	mov	edx, DWORD PTR _mlist$[ebp]
	mov	ecx, eax
	add	ecx, ecx
	lea	ecx, DWORD PTR [edx+ecx*8+8]
	mov	DWORD PTR tv10707[ebp], ecx
$LC6@linear_met@2:

; 1925 :   { M->IA[mlist[j].row+1] = j + 1 + A_OFF;

	mov	ecx, DWORD PTR [ecx-8]
	mov	ebx, DWORD PTR [esi+52]
	lea	edx, DWORD PTR [eax+2]
	mov	DWORD PTR [ebx+ecx*4+4], edx

; 1926 :     M->JA[j] = mlist[j].col + A_OFF;

	mov	ecx, DWORD PTR tv10707[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ebx, DWORD PTR [esi+56]
	inc	edx
	mov	DWORD PTR [ebx+eax*4], edx

; 1927 :     M->A[j] = mlist[j].val;

	fld	QWORD PTR [ecx]
	mov	edx, DWORD PTR [esi+60]
	fstp	QWORD PTR [edx+eax*8]
	inc	eax
	add	ecx, 16					; 00000010H
	mov	DWORD PTR tv10707[ebp], ecx
	cmp	eax, edi
	jl	SHORT $LC6@linear_met@2
$LN357@linear_met@2:

; 1928 :   }
; 1929 :   M->IA[M->N] = count + A_OFF;
; 1930 : 
; 1931 :   /* free working space */
; 1932 :   temp_free((char*)temp);

	mov	edx, DWORD PTR _temp$[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+52]
	inc	edi
	push	edx
	mov	DWORD PTR [ecx+eax*4], edi
	call	_temp_free

; 1933 :   temp_free((char*)mlist);

	mov	eax, DWORD PTR _mlist$[ebp]
	push	eax
	call	_temp_free

; 1934 :   if ( ii ) temp_free((char*)ii);

	mov	eax, DWORD PTR _ii$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN3@linear_met@2
	push	eax
	call	_temp_free
	add	esp, 4
$LN3@linear_met@2:

; 1935 :   if ( weights ) free_matrix(weights);

	mov	eax, DWORD PTR _weights$[ebp]
	test	eax, eax
	je	SHORT $LN2@linear_met@2
	push	eax
	call	_free_matrix
	add	esp, 4
$LN2@linear_met@2:

; 1936 :   if ( x ) free_matrix(x);

	mov	eax, DWORD PTR _x$[ebp]
	test	eax, eax
	je	SHORT $LN1@linear_met@2
	push	eax
	call	_free_matrix
	add	esp, 4
$LN1@linear_met@2:

; 1937 : 
; 1938 : }  /* linear_metric_setup_lagrange() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_linear_metric_setup_lagrange ENDP
_TEXT	ENDS
PUBLIC	_rhs$GSCopy$
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_energy_hessian
EXTRN	_mat4d_setup:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT _edge_energy_hessian
_TEXT	SEGMENT
_secondqXvS$ = -1440					; size = 120
_firstqXvS$ = -1320					; size = 8
_v$89132 = -1312					; size = 24
_rhs$GSCopy$ = -1288					; size = 4
_first$ = -1284						; size = 4
tv741 = -1280						; size = 4
tv356 = -1276						; size = 4
tv753 = -1272						; size = 4
_v_id$89133 = -1268					; size = 4
tv697 = -1264						; size = 4
_second$ = -1260					; size = 4
_S$GSCopy$ = -1256					; size = 4
_secondxJ$ = -1252					; size = 1152
_firstxJ$ = -100					; size = 96
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_rhs$ = 12						; size = 4
_edge_energy_hessian PROC				; COMDAT

; 126  : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 1440				; 000005a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _S$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	push	esi

; 127  :   int head,tail;
; 128  :   edge_id e_id;
; 129  :   MAT2D(first,2,MAXCOORD);

	push	6
	push	2
	lea	edx, DWORD PTR _firstxJ$[ebp]
	mov	DWORD PTR _S$GSCopy$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _firstqXvS$[ebp]
	push	eax
	mov	DWORD PTR _rhs$GSCopy$[ebp], ecx
	call	_mat2d_setup

; 130  :   MAT4D(second,2,2,MAXCOORD,MAXCOORD);

	push	6
	push	6
	push	2
	push	2
	lea	ecx, DWORD PTR _secondxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _secondqXvS$[ebp]
	push	edx
	mov	DWORD PTR _first$[ebp], eax
	call	_mat4d_setup

; 131  : 
; 132  :   /* do edges */
; 133  :     FOR_ALL_EDGES(e_id)

	mov	esi, DWORD PTR _web+160
	add	esp, 40					; 00000028H
	mov	DWORD PTR _second$[ebp], eax
	test	esi, 268435456				; 10000000H
	je	$LN21@edge_energ
	mov	edx, DWORD PTR _dymem
	push	ebx
	mov	ebx, DWORD PTR _web+216
	push	edi
	npad	12
$LL23@edge_energ:
	mov	ecx, DWORD PTR _web+124
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv356[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN22@edge_energ

; 134  :      {  
; 135  :         struct hess_verlist *v[MAXCOORD];
; 136  :         vertex_id *v_id = get_edge_vertices(e_id);

	mov	edi, DWORD PTR [ebx+edx+304]
	add	edi, ecx

; 137  : 
; 138  :         if ( ! get_e_constraint_map(e_id)[0] ) continue;

	cmp	DWORD PTR [ebx+edx+1048], 0
	mov	DWORD PTR _v_id$89133[ebp], edi
	je	SHORT $LN26@edge_energ
	mov	eax, DWORD PTR [ebx+edx+1024]
	add	eax, ecx
	jmp	SHORT $LN27@edge_energ
$LN26@edge_energ:
	mov	eax, OFFSET _nullcon
$LN27@edge_energ:
	cmp	DWORD PTR [eax], 0
	je	$LN22@edge_energ

; 139  : 
; 140  :         for ( i = 0 ; i < 2 ; i++ )
; 141  :           v[i] = get_vertex_vhead(v_id[i]);

	mov	eax, DWORD PTR _vhead_attr
	mov	ecx, DWORD PTR _web+12
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104

; 142  : 
; 143  :         memset((char*)first[0],0,sizeof(REAL)*2*MAXCOORD);

	push	96					; 00000060H
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edx, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi+4]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ebx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _vhead
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	eax, DWORD PTR [eax+ecx]
	mov	edi, DWORD PTR _first$[ebp]
	mov	ecx, DWORD PTR [edi]
	shl	eax, 5
	shl	ebx, 5
	add	ebx, edx
	add	eax, edx
	push	0
	push	ecx
	mov	DWORD PTR _v$89132[ebp], ebx
	mov	DWORD PTR _v$89132[ebp+4], eax
	call	_memset

; 144  :         memset((char*)second[0][0][0],0,sizeof(REAL)*2*2*MAXCOORD*MAXCOORD);

	mov	ebx, DWORD PTR _second$[ebp]
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	push	1152					; 00000480H
	push	0
	push	ecx
	call	_memset

; 145  : 
; 146  :         edge_constr_hessian(S,e_id,first,second);

	push	ebx
	mov	ebx, DWORD PTR _S$GSCopy$[ebp]
	push	edi
	push	esi
	push	ebx
	call	_edge_constr_hessian

; 147  :     
; 148  :         /* first derivatives on right hand side */
; 149  :         for ( i = 0 ; i < 2 ; i++ )

	lea	edx, DWORD PTR _v$89132[ebp]
	add	esp, 40					; 00000028H
	xor	esi, esi
	sub	edi, edx
	npad	9
$LL14@edge_energ:

; 150  :          fill_grad(S,v[i],first[i],rhs);

	mov	eax, DWORD PTR _rhs$GSCopy$[ebp]
	push	eax
	mov	eax, DWORD PTR _v$89132[ebp+esi*4]
	lea	ecx, DWORD PTR [edi+esi*4]
	mov	edx, DWORD PTR _v$89132[ebp+ecx]
	push	edx
	push	eax
	push	ebx
	call	_fill_grad
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, 2
	jl	SHORT $LL14@edge_energ

; 151  :         /* second derivatives */
; 152  :         if ( hess_flag )

	cmp	DWORD PTR _hess_flag, 0
	je	$LN45@edge_energ

; 153  :          for ( i = 0 ; i < 2 ; i++ )

	mov	eax, DWORD PTR _v_id$89133[ebp]
	lea	ecx, DWORD PTR _v$89132[ebp]
	xor	edi, edi
	sub	ecx, eax
	mov	DWORD PTR tv697[ebp], eax
	mov	DWORD PTR tv741[ebp], ecx
$LL10@edge_energ:

; 154  :           for ( j = i ; j < 2 ; j++ )

	mov	esi, edi
	cmp	edi, 2
	jge	$LN9@edge_energ
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR tv753[ebp], edx
	mov	ebx, eax
	npad	8
$LL48@edge_energ:

; 155  :           {
; 156  :              if ( (v[i]->freedom==0) || (v[j]->freedom==0) ) continue;

	mov	edx, DWORD PTR tv753[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN6@edge_energ
	mov	edx, DWORD PTR [ecx+ebx]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN6@edge_energ

; 157  :              if ( loc_ordinal(v_id[i]) > loc_ordinal(v_id[j]) )

	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN28@edge_energ
	and	eax, 134217727				; 07ffffffH
	mov	ecx, eax
	jmp	SHORT $LN29@edge_energ
$LN28@edge_energ:
	or	ecx, -1
$LN29@edge_energ:
	mov	eax, DWORD PTR [ebx]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN30@edge_energ
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN31@edge_energ
$LN30@edge_energ:
	or	eax, -1
$LN31@edge_energ:
	cmp	ecx, eax
	jle	SHORT $LN2@edge_energ

; 158  :                  { tail = i; head = j; }

	mov	eax, edi
	mov	ecx, esi
	jmp	SHORT $LN1@edge_energ
$LN2@edge_energ:

; 159  :              else { tail = j; head = i; }

	mov	eax, esi
	mov	ecx, edi
$LN1@edge_energ:

; 160  : 
; 161  :              fill_mixed_entry(S,v_id[tail],v_id[head],second[tail][head]);

	mov	edx, DWORD PTR _second$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [edx+ecx*4]
	push	edx
	mov	edx, DWORD PTR _v_id$89133[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	push	ecx
	push	edx
	push	eax
	call	_fill_mixed_entry
	mov	eax, DWORD PTR tv697[ebp]
	mov	ecx, DWORD PTR tv741[ebp]
	add	esp, 16					; 00000010H
$LN6@edge_energ:

; 154  :           for ( j = i ; j < 2 ; j++ )

	inc	esi
	add	ebx, 4
	cmp	esi, 2
	jl	$LL48@edge_energ
$LN9@edge_energ:

; 153  :          for ( i = 0 ; i < 2 ; i++ )

	inc	edi
	add	eax, 4
	mov	DWORD PTR tv697[ebp], eax
	cmp	edi, 2
	jl	$LL10@edge_energ
$LN45@edge_energ:
	mov	edx, DWORD PTR _dymem
	mov	ebx, DWORD PTR _web+216
$LN22@edge_energ:

; 131  : 
; 132  :   /* do edges */
; 133  :     FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR tv356[ebp]
	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+eax]
	mov	esi, DWORD PTR [ecx]
	test	esi, 268435456				; 10000000H
	jne	$LL23@edge_energ
	pop	edi
	pop	ebx
$LN21@edge_energ:

; 162  :             }
; 163  :       }
; 164  : } /* end edge_energy_hessian() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_energy_hessian ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@ILFOGACK@New?5allocation?5at?5?$CFp?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DH@NHHDDGMM@YSMP?5allocation?5at?5?$CFp?5of?5?$CFd?$CK8?5ov@ ; `string'
PUBLIC	??_C@_0DJ@CJNPMOAL@YSMP?5allocation?5at?5?$CFp?5of?5?$CFd?$CK8?5sh@ ; `string'
PUBLIC	_ysmp_factor
EXTRN	_mat_null:DWORD
EXTRN	_mat_index:DWORD
EXTRN	_kb_temp_realloc:PROC
EXTRN	_msg:DWORD
EXTRN	_sdrvmd_:PROC
EXTRN	_odrv_:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__CIlog:PROC
;	COMDAT ??_C@_0BH@ILFOGACK@New?5allocation?5at?5?$CFp?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@ILFOGACK@New?5allocation?5at?5?$CFp?4?6?$AA@ DB 'New allocation'
	DB	' at %p.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@NHHDDGMM@YSMP?5allocation?5at?5?$CFp?5of?5?$CFd?$CK8?5ov@
CONST	SEGMENT
??_C@_0DH@NHHDDGMM@YSMP?5allocation?5at?5?$CFp?5of?5?$CFd?$CK8?5ov@ DB 'Y'
	DB	'SMP allocation at %p of %d*8 over by %d*8. Reducing.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@CJNPMOAL@YSMP?5allocation?5at?5?$CFp?5of?5?$CFd?$CK8?5sh@
CONST	SEGMENT
??_C@_0DJ@CJNPMOAL@YSMP?5allocation?5at?5?$CFp?5of?5?$CFd?$CK8?5sh@ DB 'Y'
	DB	'SMP allocation at %p of %d*8 short by %d*8. Expanding.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _ysmp_factor
_TEXT	SEGMENT
_EMAX$ = -16						; size = 8
_ESP$ = -8						; size = 4
_FLAG$ = -4						; size = 4
tv683 = 8						; size = 4
_PATH$ = 8						; size = 4
_S$ = 8							; size = 4
_mtype$ = 12						; size = 4
_ysmp_factor PROC					; COMDAT

; 487  : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 488  :   int PATH,FLAG=0,ESP=0;
; 489  :   REAL *RSP,EMAX;
; 490  : 
; 491  :   PROF_START(hessian_factor);
; 492  : 
; 493  :   /* need just enough at first to do symbolic factorization */
; 494  :   if ( S->NSP == 0 )

	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+88]
	xor	ecx, ecx
	lea	ebx, DWORD PTR [esi+88]
	push	edi
	mov	DWORD PTR _FLAG$[ebp], ecx
	mov	DWORD PTR _ESP$[ebp], ecx
	cmp	eax, ecx
	jne	SHORT $LN26@ysmp_facto

; 495  :   { S->NSP = (4 + (int)(log(S->N+1)))*(S->N + S->IA[S->N]);

	mov	edi, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR tv683[ebp], eax
	fild	DWORD PTR tv683[ebp]
	call	__CIlog
	call	__ftol2_sse
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+edi*4]
	add	eax, 4
	add	edx, edi
	imul	eax, edx

; 496  :     S->ISP = (int *)temp_calloc(S->NSP,sizeof(REAL));

	push	496					; 000001f0H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	8
	push	eax
	mov	DWORD PTR [ebx], eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+92], eax
	jmp	SHORT $LN25@ysmp_facto
$LN26@ysmp_facto:

; 497  :   }
; 498  :   else memset((char*)S->ISP,0,S->NSP*sizeof(REAL));

	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+92]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN25@ysmp_facto:

; 499  : 
; 500  :   if ( S->N == 0 ) return; /* empty hessian */

	cmp	DWORD PTR [esi+4], 0
	je	$LN5@ysmp_facto

; 501  : 
; 502  :   /* subtract lambda from diagonal */
; 503  :   if ( S->lambda != 0.0 )

	fld	QWORD PTR [esi+112]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN20@ysmp_facto

; 504  :   for ( i = 0 ; i < S->A_rows ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR [esi+12], ecx
	jle	SHORT $LN20@ysmp_facto
$LL22@ysmp_facto:
	mov	edx, DWORD PTR [esi+52]

; 505  :   { for ( j = S->IA[i]-A_OFF ; j < S->IA[i+1]-A_OFF ; j++ )

	mov	eax, DWORD PTR [edx+ecx*4]
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [edx+4]
	dec	eax
	dec	edx
	cmp	eax, edx
	jge	SHORT $LN21@ysmp_facto
	mov	edx, DWORD PTR [esi+56]
	lea	edx, DWORD PTR [edx+eax*4]
	npad	7
$LL19@ysmp_facto:

; 506  :       if ( S->JA[j]-A_OFF == i )

	mov	edi, DWORD PTR [edx]
	dec	edi
	cmp	edi, ecx
	je	SHORT $LN33@ysmp_facto

; 505  :   { for ( j = S->IA[i]-A_OFF ; j < S->IA[i+1]-A_OFF ; j++ )

	mov	edi, DWORD PTR [esi+52]
	mov	edi, DWORD PTR [edi+ecx*4+4]
	inc	eax
	dec	edi
	add	edx, 4
	cmp	eax, edi
	jl	SHORT $LL19@ysmp_facto

; 555  :             if ( S->JA[j]-A_OFF == i )

	jmp	SHORT $LN21@ysmp_facto
$LN33@ysmp_facto:

; 507  :          { S->A[j] -= S->lambda; break; }

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8]
	lea	eax, DWORD PTR [edx+eax*8]
	fsub	QWORD PTR [esi+112]
	fstp	QWORD PTR [eax]
$LN21@ysmp_facto:

; 504  :   for ( i = 0 ; i < S->A_rows ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR [esi+12]
	jl	SHORT $LL22@ysmp_facto
$LN20@ysmp_facto:

; 508  :   }
; 509  :   /*  Call ODRV to perform the reordering on A, if not done yet */
; 510  :   if ( !(S->flags & S_ODRV_REORDERED) )

	mov	eax, DWORD PTR [esi]
	test	al, 16					; 00000010H
	jne	$LN40@ysmp_facto

; 511  :   { PATH = (S->flags & S_ORDERFOUND) ? 3 : 2; 

	and	eax, 64					; 00000040H
	or	eax, 128				; 00000080H
	shr	eax, 6

; 512  :     if ( S->P == NULL ) S->P = (int *)temp_calloc(S->N,sizeof(int));

	cmp	DWORD PTR [esi+68], 0
	mov	DWORD PTR _PATH$[ebp], eax
	jne	SHORT $LN39@ysmp_facto
	mov	eax, DWORD PTR [esi+4]
	push	512					; 00000200H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	4
	push	eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+68], eax
$LN39@ysmp_facto:

; 513  :     if ( S->IP == NULL ) S->IP = (int *)temp_calloc(S->N,sizeof(int));

	cmp	DWORD PTR [esi+72], 0
	jne	SHORT $LN13@ysmp_facto
	mov	ecx, DWORD PTR [esi+4]
	push	513					; 00000201H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	4
	push	ecx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+72], eax
$LN13@ysmp_facto:

; 514  :     odrv_( &S->N, S->IA,S->JA,S->A, S->P,S->IP, &S->NSP,S->ISP,&PATH,&FLAG );

	mov	ecx, DWORD PTR [esi+92]
	lea	edx, DWORD PTR _FLAG$[ebp]
	push	edx
	mov	edx, DWORD PTR [esi+72]
	lea	eax, DWORD PTR _PATH$[ebp]
	push	eax
	mov	eax, DWORD PTR [esi+68]
	push	ecx
	mov	ecx, DWORD PTR [esi+60]
	push	ebx
	push	edx
	mov	edx, DWORD PTR [esi+56]
	push	eax
	mov	eax, DWORD PTR [esi+52]
	push	ecx
	push	edx
	push	eax
	lea	edi, DWORD PTR [esi+4]
	push	edi
	call	_odrv_

; 515  :     odrv_flag_check(FLAG,S->N);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _FLAG$[ebp]
	push	ecx
	push	edx
	call	_odrv_flag_check
	add	esp, 48					; 00000030H

; 516  :     S->flags |= S_ODRV_REORDERED;

	or	DWORD PTR [esi], 16			; 00000010H
$LN40@ysmp_facto:

; 517  :   }
; 518  :   
; 519  : 
; 520  : 
; 521  :   /*  Call SDRVMD to factor symbolically and numerically */
; 522  :   PATH = 4; /* symbolic factor */
; 523  :   RSP = (REAL *) S->ISP;

	mov	eax, DWORD PTR [esi+92]

; 524  :   sdrvmd_(&S->N,S->P,S->IP,S->IA,S->JA,S->A,NULL,NULL,&S->NSP,
; 525  :             S->ISP,RSP,&ESP, &PATH,&FLAG,&EMAX);

	lea	ecx, DWORD PTR _EMAX$[ebp]
	push	ecx
	lea	edx, DWORD PTR _FLAG$[ebp]
	push	edx
	lea	ecx, DWORD PTR _PATH$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [esi+56]
	lea	edx, DWORD PTR _ESP$[ebp]
	push	edx
	mov	edx, DWORD PTR [esi+52]
	push	eax
	push	eax
	mov	eax, DWORD PTR [esi+60]
	push	ebx
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR [esi+72]
	push	ecx
	mov	ecx, DWORD PTR [esi+68]
	push	edx
	push	eax
	push	ecx
	lea	edi, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR _PATH$[ebp], 4
	call	_sdrvmd_

; 526  :  
; 527  :  sdrv_flag_check(0,FLAG,S->N);

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR _FLAG$[ebp]
	push	edx
	push	eax
	push	0
	call	_sdrv_flag_check
	add	esp, 72					; 00000048H

; 528  :   PATH = 6; /* numeric factor */
; 529  :   if ( !hessian_quiet_flag )

	cmp	DWORD PTR _hessian_quiet_flag, 0
	mov	DWORD PTR _PATH$[ebp], 6
	jne	SHORT $LN12@ysmp_facto

; 530  :   { if ( ESP < 0 )

	mov	eax, DWORD PTR _ESP$[ebp]

; 531  :      sprintf(msg,"YSMP allocation at %p of %d*8 short by %d*8. Expanding.\n",
; 532  :                S->ISP,S->NSP,-ESP);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [esi+92]
	test	eax, eax
	jns	SHORT $LN11@ysmp_facto
	neg	eax
	push	eax
	push	ecx
	push	edx
	push	OFFSET ??_C@_0DJ@CJNPMOAL@YSMP?5allocation?5at?5?$CFp?5of?5?$CFd?$CK8?5sh@

; 533  :     else

	jmp	SHORT $LN41@ysmp_facto
$LN11@ysmp_facto:

; 534  :      sprintf(msg,"YSMP allocation at %p of %d*8 over by %d*8. Reducing.\n",
; 535  :                S->ISP,S->NSP,ESP);

	push	eax
	push	ecx
	push	edx
	push	OFFSET ??_C@_0DH@NHHDDGMM@YSMP?5allocation?5at?5?$CFp?5of?5?$CFd?$CK8?5ov@
$LN41@ysmp_facto:
	mov	eax, DWORD PTR _msg
	push	eax
	call	_sprintf

; 536  :     outstring(msg);

	mov	ecx, DWORD PTR _msg
	add	esp, 20					; 00000014H
	push	ecx
	call	_outstring
	add	esp, 4
$LN12@ysmp_facto:

; 537  :   }
; 538  :   S->ISP = (int*)temp_realloc((char*)(S->ISP),
; 539  :           (S->NSP-ESP+10)*sizeof(REAL));

	mov	edx, DWORD PTR [ebx]
	sub	edx, DWORD PTR _ESP$[ebp]
	mov	ecx, DWORD PTR [esi+92]
	push	539					; 0000021bH
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	lea	eax, DWORD PTR [edx*8+80]
	push	eax
	push	ecx
	call	_kb_temp_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+92], eax

; 540  :   if ( !hessian_quiet_flag )

	cmp	DWORD PTR _hessian_quiet_flag, 0
	jne	SHORT $LN9@ysmp_facto

; 541  :   { sprintf(msg,"New allocation at %p.\n",S->ISP);  outstring(msg); }

	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BH@ILFOGACK@New?5allocation?5at?5?$CFp?4?6?$AA@
	push	edx
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
$LN9@ysmp_facto:

; 542  :   S->NSP += -ESP + 10;
; 543  :   RSP = (REAL *) S->ISP;

	mov	eax, DWORD PTR [esi+92]
	mov	ecx, 10					; 0000000aH
	sub	ecx, DWORD PTR _ESP$[ebp]

; 544  :   sdrvmd_(&S->N,S->P,S->IP,S->IA,S->JA,S->A,NULL,NULL,&S->NSP,
; 545  :             S->ISP,RSP,&ESP, &PATH,&FLAG,&EMAX);

	lea	edx, DWORD PTR _EMAX$[ebp]
	add	DWORD PTR [ebx], ecx
	push	edx
	lea	ecx, DWORD PTR _FLAG$[ebp]
	push	ecx
	lea	edx, DWORD PTR _PATH$[ebp]
	push	edx
	mov	edx, DWORD PTR [esi+60]
	lea	ecx, DWORD PTR _ESP$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [esi+52]
	push	eax
	push	eax
	mov	eax, DWORD PTR [esi+56]
	push	ebx
	push	0
	push	0
	push	edx
	mov	edx, DWORD PTR [esi+72]
	push	eax
	mov	eax, DWORD PTR [esi+68]
	push	ecx
	push	edx
	push	eax
	push	edi
	call	_sdrvmd_

; 546  :   sdrv_flag_check(ESP,FLAG,S->N);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _FLAG$[ebp]
	mov	eax, DWORD PTR _ESP$[ebp]
	push	ecx
	push	edx
	push	eax
	call	_sdrv_flag_check

; 547  :   S->neg = mat_index;
; 548  :   S->zero = mat_null;
; 549  :   S->pos = S->N - mat_index - mat_null;
; 550  : 
; 551  :   /* add lambda back to diagonal */
; 552  :   if ( S->lambda != 0.0 )

	fld	QWORD PTR [esi+112]
	mov	ecx, DWORD PTR _mat_index
	fldz
	mov	eax, DWORD PTR [edi]
	fucompp
	mov	DWORD PTR [esi+188], ecx
	mov	edx, DWORD PTR _mat_null
	mov	DWORD PTR [esi+192], edx
	sub	eax, DWORD PTR _mat_null
	add	esp, 72					; 00000048H
	sub	eax, DWORD PTR _mat_index
	mov	DWORD PTR [esi+184], eax
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@ysmp_facto

; 553  :     for ( i = 0 ; i < S->A_rows ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR [esi+12], ecx
	jle	SHORT $LN5@ysmp_facto
$LL7@ysmp_facto:
	mov	edx, DWORD PTR [esi+52]

; 554  :       { for ( j = S->IA[i]-A_OFF ; j < S->IA[i+1]-A_OFF ; j++ )

	mov	eax, DWORD PTR [edx+ecx*4]
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [edx+4]
	dec	eax
	dec	edx
	cmp	eax, edx
	jge	SHORT $LN6@ysmp_facto
	mov	edx, DWORD PTR [esi+56]
	lea	edx, DWORD PTR [edx+eax*4]
$LL4@ysmp_facto:

; 555  :             if ( S->JA[j]-A_OFF == i )

	mov	edi, DWORD PTR [edx]
	dec	edi
	cmp	edi, ecx
	je	SHORT $LN34@ysmp_facto

; 554  :       { for ( j = S->IA[i]-A_OFF ; j < S->IA[i+1]-A_OFF ; j++ )

	mov	edi, DWORD PTR [esi+52]
	mov	edi, DWORD PTR [edi+ecx*4+4]
	inc	eax
	dec	edi
	add	edx, 4
	cmp	eax, edi
	jl	SHORT $LL4@ysmp_facto

; 555  :             if ( S->JA[j]-A_OFF == i )

	jmp	SHORT $LN6@ysmp_facto
$LN34@ysmp_facto:

; 556  :             { S->A[j] += S->lambda; break; }

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8]
	lea	eax, DWORD PTR [edx+eax*8]
	fadd	QWORD PTR [esi+112]
	fstp	QWORD PTR [eax]
$LN6@ysmp_facto:

; 553  :     for ( i = 0 ; i < S->A_rows ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR [esi+12]
	jl	SHORT $LL7@ysmp_facto
$LN5@ysmp_facto:
	pop	edi
	pop	esi
	pop	ebx

; 557  :       }
; 558  : 
; 559  :   PROF_FINISH(hessian_factor);
; 560  : }  /* end ysmp_factor() */

	mov	esp, ebp
	pop	ebp
	ret	0
_ysmp_factor ENDP
_TEXT	ENDS
PUBLIC	_ysmp_solve
; Function compile flags: /Ogtp
;	COMDAT _ysmp_solve
_TEXT	SEGMENT
_EMAX$ = -16						; size = 8
_ESP$ = -8						; size = 4
_FLAG$ = -4						; size = 4
_PATH$ = 8						; size = 4
_S$ = 8							; size = 4
_b$ = 12						; size = 4
_x$ = 16						; size = 4
_mtype$ = 20						; size = 4
_ysmp_solve PROC					; COMDAT

; 575  : { int PATH,FLAG=0,ESP;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 576  :   REAL *RSP,EMAX;
; 577  : 
; 578  :   PROF_START(hessian_factor);
; 579  : 
; 580  :   if ( S->N == 0 ) return;

	mov	eax, DWORD PTR _S$[ebp]
	cmp	DWORD PTR [eax+4], 0
	push	esi
	lea	esi, DWORD PTR [eax+4]
	mov	DWORD PTR _FLAG$[ebp], 0
	je	SHORT $LN2@ysmp_solve

; 581  :   RSP = (REAL *) S->ISP;

	mov	ecx, DWORD PTR [eax+92]

; 582  :   PATH = 3;  /* solution only */
; 583  :   sdrvmd_(&S->N,S->P,S->IP,S->IA,S->JA,S->A,b,x,&S->NSP,S->ISP,RSP,&ESP, 
; 584  :         &PATH,&FLAG,&EMAX);

	lea	edx, DWORD PTR _EMAX$[ebp]
	push	edx
	lea	edx, DWORD PTR _FLAG$[ebp]
	push	edx
	lea	edx, DWORD PTR _PATH$[ebp]
	push	edx
	lea	edx, DWORD PTR _ESP$[ebp]
	push	edx
	mov	edx, DWORD PTR _x$[ebp]
	push	ecx
	push	ecx
	lea	ecx, DWORD PTR [eax+88]
	push	ecx
	mov	ecx, DWORD PTR _b$[ebp]
	push	edx
	mov	edx, DWORD PTR [eax+60]
	push	ecx
	mov	ecx, DWORD PTR [eax+56]
	push	edx
	mov	edx, DWORD PTR [eax+52]
	push	ecx
	mov	ecx, DWORD PTR [eax+72]
	push	edx
	mov	edx, DWORD PTR [eax+68]
	push	ecx
	push	edx
	push	esi
	mov	DWORD PTR _PATH$[ebp], 3
	call	_sdrvmd_

; 585  :   sdrv_flag_check(ESP,FLAG,S->N);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _FLAG$[ebp]
	mov	edx, DWORD PTR _ESP$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_sdrv_flag_check
	add	esp, 72					; 00000048H
$LN2@ysmp_solve:
	pop	esi

; 586  : 
; 587  :   PROF_FINISH(hessian_factor);
; 588  : } // end ysmp_solve()

	mov	esp, ebp
	pop	ebp
	ret	0
_ysmp_solve ENDP
_TEXT	ENDS
PUBLIC	_ysmp_solve_multi
; Function compile flags: /Ogtp
;	COMDAT _ysmp_solve_multi
_TEXT	SEGMENT
_S$ = 8							; size = 4
_b$ = 12						; size = 4
_x$ = 16						; size = 4
_rk$ = 20						; size = 4
_mtype$ = 24						; size = 4
_ysmp_solve_multi PROC					; COMDAT

; 605  : { int k;

	push	ebp
	mov	ebp, esp
	push	ebx

; 606  :   for ( k = 0 ; k < rk ; k++ ) 

	mov	ebx, DWORD PTR _rk$[ebp]
	test	ebx, ebx
	jle	SHORT $LN1@ysmp_solve@2
	push	esi
	mov	esi, DWORD PTR _b$[ebp]
	push	edi
	mov	edi, DWORD PTR _x$[ebp]
	sub	edi, esi
$LL3@ysmp_solve@2:

; 607  :     ysmp_solve(S,b[k],x[k],mtype);

	mov	eax, DWORD PTR _mtype$[ebp]
	mov	ecx, DWORD PTR [edi+esi]
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR _S$[ebp]
	push	ecx
	push	edx
	push	eax
	call	_ysmp_solve
	add	esp, 16					; 00000010H
	add	esi, 4
	dec	ebx
	jne	SHORT $LL3@ysmp_solve@2
	pop	edi
	pop	esi
$LN1@ysmp_solve@2:
	pop	ebx

; 608  : } // end ysmp_solve_multi()

	pop	ebp
	ret	0
_ysmp_solve_multi ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_06FNCNKGB@?5?$CF9?46f?$AA@		; `string'
PUBLIC	??_C@_0L@CCBFPMDD@?5?5?5?5?5?5?5?5?5?5?$AA@	; `string'
PUBLIC	??_C@_05NHABLKGM@?6A?3?5?6?$AA@			; `string'
PUBLIC	??_C@_05GCDFEGGO@?6JA?3?5?$AA@			; `string'
PUBLIC	??_C@_03JDANDILB@?$CFd?5?$AA@			; `string'
PUBLIC	??_C@_04PDOOEJGG@IA?3?5?$AA@			; `string'
PUBLIC	??_C@_0BA@FJCICACH@Metric?5matrix?3?6?$AA@	; `string'
PUBLIC	??_C@_0DB@HDFPKDEI@Internal?5error?3?5Bad?5j?5in?5linear_@ ; `string'
PUBLIC	__real@4008000000000000
PUBLIC	??_C@_0CN@LGDOGIDG@Too?5many?5neighbors?5in?5linear_met@ ; `string'
PUBLIC	??_C@_0DO@KPCNAEIF@Sorry?$DL?5linear_metric?5not?5working@ ; `string'
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_linear_metric_setup
EXTRN	_get_facet_normal:PROC
EXTRN	_hessian_normal_perp_flag:DWORD
EXTRN	_linear_metric_mix:QWORD
EXTRN	_get_next_vertex_facet:PROC
EXTRN	_get_vertex_first_facet:PROC
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FNCNKGB@?5?$CF9?46f?$AA@
CONST	SEGMENT
??_C@_06FNCNKGB@?5?$CF9?46f?$AA@ DB ' %9.6f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CCBFPMDD@?5?5?5?5?5?5?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0L@CCBFPMDD@?5?5?5?5?5?5?5?5?5?5?$AA@ DB '          ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05NHABLKGM@?6A?3?5?6?$AA@
CONST	SEGMENT
??_C@_05NHABLKGM@?6A?3?5?6?$AA@ DB 0aH, 'A: ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GCDFEGGO@?6JA?3?5?$AA@
CONST	SEGMENT
??_C@_05GCDFEGGO@?6JA?3?5?$AA@ DB 0aH, 'JA: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JDANDILB@?$CFd?5?$AA@
CONST	SEGMENT
??_C@_03JDANDILB@?$CFd?5?$AA@ DB '%d ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PDOOEJGG@IA?3?5?$AA@
CONST	SEGMENT
??_C@_04PDOOEJGG@IA?3?5?$AA@ DB 'IA: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FJCICACH@Metric?5matrix?3?6?$AA@
CONST	SEGMENT
??_C@_0BA@FJCICACH@Metric?5matrix?3?6?$AA@ DB 'Metric matrix:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HDFPKDEI@Internal?5error?3?5Bad?5j?5in?5linear_@
CONST	SEGMENT
??_C@_0DB@HDFPKDEI@Internal?5error?3?5Bad?5j?5in?5linear_@ DB 'Internal e'
	DB	'rror: Bad j in linear_metric_setup().', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT ??_C@_0CN@LGDOGIDG@Too?5many?5neighbors?5in?5linear_met@
CONST	SEGMENT
??_C@_0CN@LGDOGIDG@Too?5many?5neighbors?5in?5linear_met@ DB 'Too many nei'
	DB	'ghbors in linear_metric_setup()', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@KPCNAEIF@Sorry?$DL?5linear_metric?5not?5working@
CONST	SEGMENT
??_C@_0DO@KPCNAEIF@Sorry?$DL?5linear_metric?5not?5working@ DB 'Sorry; lin'
	DB	'ear_metric not working with optimizing parameters.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\hessian3.c
CONST	ENDS
;	COMDAT _linear_metric_setup
_TEXT	SEGMENT
_weightsqXvS$ = -1012					; size = 28
_temp_matqXvS$ = -984					; size = 24
_vh$90179 = -960					; size = 32
_area$90164 = -928					; size = 8
_len$ = -928						; size = 8
_weights$ = -920					; size = 4
tv4001 = -916						; size = 4
_vv$90226 = -916					; size = 4
_vh$90104 = -912					; size = 8
tv6280 = -908						; size = 4
tv4291 = -908						; size = 4
tv4274 = -908						; size = 4
_cfudge$90227 = -904					; size = 8
_fudge$90203 = -904					; size = 8
_density$90176 = -904					; size = 8
_cfudge$90142 = -904					; size = 8
_fudge$90121 = -904					; size = 8
_col$ = -896						; size = 4
_temp_mat$ = -892					; size = 4
tv6200 = -888						; size = 4
tv1260 = -888						; size = 4
_a_from_spot$90275 = -888				; size = 4
_nbrcount$89964 = -888					; size = 4
tv6243 = -884						; size = 4
tv5692 = -884						; size = 4
_nbrlist$89962 = -884					; size = 4
_jj$ = -880						; size = 4
tv5567 = -876						; size = 4
tv5253 = -876						; size = 4
tv4014 = -876						; size = 4
_f_id$89965 = -876					; size = 4
_np$90247 = -872					; size = 4
_wp$90239 = -872					; size = 4
_wp$90232 = -872					; size = 4
_kk$ = -872						; size = 4
_v_id$ = -872						; size = 4
tv4334 = -868						; size = 4
tv4142 = -868						; size = 4
tv3638 = -868						; size = 4
tv3581 = -868						; size = 4
tv2507 = -868						; size = 4
tv2319 = -868						; size = 4
_m$90328 = -868						; size = 4
_mat$ = -864						; size = 4
tv6198 = -860						; size = 4
tv5979 = -860						; size = 4
tv4073 = -860						; size = 4
_vv$90141 = -860					; size = 4
_j$ = -860						; size = 4
_m$89968 = -860						; size = 4
_v$89967 = -860						; size = 4
_v$90202 = -856						; size = 4
_end$ = -856						; size = 4
_v$90120 = -856						; size = 4
_vh$89980 = -856					; size = 4
tv5679 = -852						; size = 4
_S$GSCopy$ = -852					; size = 4
_ja_from_spot$90273 = -852				; size = 4
_dim$ = -852						; size = 4
tv6070 = -848						; size = 4
tv3693 = -848						; size = 4
tv3580 = -848						; size = 4
_np$90251 = -848					; size = 4
_wwp$90246 = -848					; size = 4
_np$90240 = -848					; size = 4
_wwp$90233 = -848					; size = 4
_wp$90207 = -848					; size = 4
_fe$90175 = -848					; size = 4
_k$ = -844						; size = 4
_i$ = -844						; size = 4
_weightsxJ$ = -840					; size = 392
_temp_matxJ$ = -448					; size = 288
_w$90230 = -160						; size = 48
_w$90206 = -160						; size = 48
_ww$90245 = -112					; size = 48
_w$90238 = -112						; size = 48
_ww$90231 = -112					; size = 48
_ix$90174 = -64						; size = 12
_normal$90178 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_M$ = 12						; size = 4
_linear_metric_setup PROC				; COMDAT

; 792  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1012				; 000003f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _M$[ebp]
	push	edi
	mov	edi, DWORD PTR _S$[ebp]

; 793  :   int i,jj,k,kk,m;
; 794  :   size_t j;
; 795  :   int sum;
; 796  :   edge_id e_id;
; 797  :   vertex_id v_id;
; 798  :   int ti=0,hi=0;
; 799  :   REAL len;
; 800  :   MAT2D(weights,MAXCOORD+1,MAXCOORD+1);

	push	7
	push	7
	lea	eax, DWORD PTR _weightsxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _weightsqXvS$[ebp]
	push	ecx

; 875  :            M->IA[j] += vhi->freedom;

	mov	DWORD PTR _S$GSCopy$[ebp], edi
	call	_mat2d_setup
	push	6
	push	6
	lea	edx, DWORD PTR _temp_matxJ$[ebp]
	mov	DWORD PTR _weights$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _temp_matqXvS$[ebp]
	push	eax
	call	_mat2d_setup
	xor	ebx, ebx
	add	esp, 32					; 00000020H
	mov	DWORD PTR _temp_mat$[ebp], eax
	cmp	DWORD PTR _optparamcount, ebx
	jle	SHORT $LN461@linear_met@3

; 801  :   MAT2D(temp_mat,MAXCOORD,MAXCOORD);
; 802  :   REAL **mat;
; 803  :   int col;
; 804  :   size_t end;
; 805  :   int ii[MAXCOORD+1];
; 806  :   int dim;
; 807  : 
; 808  :   if ( optparamcount > 0 )
; 809  :     kb_error(2444,"Sorry; linear_metric not working with optimizing parameters.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DO@KPCNAEIF@Sorry?$DL?5linear_metric?5not?5working@
	push	2444					; 0000098cH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN461@linear_met@3:

; 810  : 
; 811  :   if ( web.modeltype == QUADRATIC )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	SHORT $LN236@linear_met@3

; 812  :   { linear_metric_setup_quadratic(S,M); goto apinv_setup; }

	push	esi
	push	edi
	call	_linear_metric_setup_quadratic
	add	esp, 8
	jmp	$apinv_setup$89946
$LN236@linear_met@3:

; 813  :   if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	SHORT $LN235@linear_met@3

; 814  :   { linear_metric_setup_lagrange(S,M); goto apinv_setup; }

	push	esi
	push	edi
	call	_linear_metric_setup_lagrange
	add	esp, 8
	jmp	$apinv_setup$89946
$LN235@linear_met@3:

; 815  : 
; 816  :   if ( ysmp_flag != MINDEG_FACTORING )

	cmp	DWORD PTR _ysmp_flag, ebx
	je	SHORT $LN234@linear_met@3

; 817  :   { ysmp_flag = MINDEG_FACTORING;
; 818  :     sp_mul_func = bk_mul;
; 819  :     sp_AIJ_setup_func = bk_AIJ_setup;
; 820  :     sp_constraint_setup_func = bk_constraint_setup;
; 821  :     sp_hess_project_setup_func = BK_hess_project_setup;
; 822  :     sp_factor_func = xmd_factor;
; 823  :     sp_solve_func = xmd_solve;
; 824  :     sp_solve_multi_func = xmd_solve_multi;
; 825  :     sp_ordering_func = NULL;
; 826  :     sp_CHinvC_func = sp_CHinvC;
; 827  :     outstring(
; 828  :         "Using alternate minimal degree with linear interpolation metric.\n");

	push	OFFSET ??_C@_0EC@DHHMKCIK@Using?5alternate?5minimal?5degree?5w@
	mov	DWORD PTR _ysmp_flag, ebx
	mov	DWORD PTR _sp_mul_func, OFFSET _bk_mul
	mov	DWORD PTR _sp_AIJ_setup_func, OFFSET _bk_AIJ_setup
	mov	DWORD PTR _sp_constraint_setup_func, OFFSET _bk_constraint_setup
	mov	DWORD PTR _sp_hess_project_setup_func, OFFSET _BK_hess_project_setup
	mov	DWORD PTR _sp_factor_func, OFFSET _xmd_factor
	mov	DWORD PTR _sp_solve_func, OFFSET _xmd_solve
	mov	DWORD PTR _sp_solve_multi_func, OFFSET _xmd_solve_multi
	mov	DWORD PTR _sp_ordering_func, ebx
	mov	DWORD PTR _sp_CHinvC_func, OFFSET _sp_CHinvC
	call	_outstring
	add	esp, 4
$LN234@linear_met@3:

; 829  :   }
; 830  :   M->N = S->N;

	mov	ecx, DWORD PTR [edi+4]

; 831  :   M->flags &= ~ S_ODRV_REORDERED; 

	and	DWORD PTR [esi], -17			; ffffffefH

; 832  : 
; 833  :   /* allocate storage for arrays */
; 834  :   M->IA = (int *)temp_calloc(M->N+1,sizeof(int));

	push	834					; 00000342H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	lea	edx, DWORD PTR [ecx+1]
	push	4
	push	edx
	mov	DWORD PTR [esi+4], ecx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+52], eax

; 835  :   if ( M->P == NULL ) M->P = (int *)temp_calloc(M->N,sizeof(int));

	cmp	DWORD PTR [esi+68], ebx
	jne	SHORT $LN484@linear_met@3
	mov	eax, DWORD PTR [esi+4]
	push	835					; 00000343H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	4
	push	eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+68], eax
$LN484@linear_met@3:

; 836  :   if ( M->IP == NULL ) M->IP = (int *)temp_calloc(M->N,sizeof(int));

	cmp	DWORD PTR [esi+72], ebx
	jne	SHORT $LN487@linear_met@3
	mov	ecx, DWORD PTR [esi+4]
	push	836					; 00000344H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	4
	push	ecx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+72], eax
$LN487@linear_met@3:

; 837  : 
; 838  :   /* have to count number of higher-ordinal neighbors of each vertex */
; 839  :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	jne	$LN231@linear_met@3

; 840  :   { vertex_id *nbrlist;
; 841  :     int nbralloc = 1000;
; 842  :     int nbrcount;
; 843  :     facet_id f_id,start_f;
; 844  :     vertex_id *v;
; 845  :     int m;
; 846  : 
; 847  :     nbrlist = (vertex_id *)temp_calloc(nbralloc,sizeof(vertex_id));

	push	847					; 0000034fH
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	4
	push	1000					; 000003e8H
	call	_kb_temp_calloc
	mov	DWORD PTR _nbrlist$89962[ebp], eax

; 848  :     FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	ecx, 1
	mov	DWORD PTR _v_id$[ebp], eax
	je	$LN192@linear_met@3
	mov	edi, DWORD PTR _vhead_attr
	npad	6
$LL230@linear_met@3:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv3580[ebp], eax
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	$LN229@linear_met@3

; 849  :     { struct hess_verlist *vh = get_vertex_vhead(v_id);

	mov	eax, DWORD PTR _dymem
	imul	edi, 240				; 000000f0H
	add	edi, DWORD PTR _web+104
	mov	eax, DWORD PTR [edi+eax+64]
	mov	edx, DWORD PTR [edx+eax]
	shl	edx, 5
	add	edx, DWORD PTR _vhead
	mov	DWORD PTR _vh$89980[ebp], edx

; 850  :       i = loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN240@linear_met@3
	mov	ecx, DWORD PTR tv3580[ebp]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN241@linear_met@3
$LN240@linear_met@3:
	mov	DWORD PTR _i$[ebp], -1
$LN241@linear_met@3:

; 851  :       nbrcount = 1;
; 852  :       nbrlist[0] = v_id;

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	edx, DWORD PTR _nbrlist$89962[ebp]

; 853  :       f_id = start_f = get_vertex_first_facet(v_id);

	push	eax
	mov	edi, 1
	mov	DWORD PTR [edx], eax
	call	_get_vertex_first_facet
	add	esp, 4
	mov	DWORD PTR _f_id$89965[ebp], eax
	or	eax, 134217728				; 08000000H
	mov	DWORD PTR tv3638[ebp], eax
$LL225@linear_met@3:

; 854  :       do
; 855  :       { v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _f_id$89965[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+304]

; 856  :         for ( k = 0 ; k <= web.dimension ; k++ )

	xor	ebx, ebx
	mov	DWORD PTR _v$89967[ebp], eax
	cmp	DWORD PTR _web+620, ebx
	jl	$LN220@linear_met@3
	jmp	SHORT $LN222@linear_met@3
$LL475@linear_met@3:
	mov	eax, DWORD PTR _v$89967[ebp]
$LN222@linear_met@3:

; 857  :           if ( loc_ordinal(v[k]) > i )

	mov	ecx, DWORD PTR [eax+ebx*4]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN242@linear_met@3
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN243@linear_met@3
$LN242@linear_met@3:
	or	eax, -1
$LN243@linear_met@3:
	cmp	eax, DWORD PTR _i$[ebp]
	jle	SHORT $LN221@linear_met@3

; 858  :           { for ( m = 0 ; m < nbrcount ; m++ )

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN476@linear_met@3
	npad	4
$LL218@linear_met@3:

; 859  :               if ( nbrlist[m] == v[k] ) break;

	mov	edx, DWORD PTR _nbrlist$89962[ebp]
	cmp	DWORD PTR [edx+eax*4], ecx
	je	SHORT $LN476@linear_met@3

; 858  :           { for ( m = 0 ; m < nbrcount ; m++ )

	inc	eax
	cmp	eax, edi
	jl	SHORT $LL218@linear_met@3
$LN476@linear_met@3:

; 860  :             if ( m == nbrcount )

	cmp	eax, edi
	jne	SHORT $LN221@linear_met@3

; 861  :             { if ( nbrcount >= nbralloc )

	cmp	edi, 1000				; 000003e8H
	jl	SHORT $LN213@linear_met@3

; 862  :                  kb_error(1849,"Too many neighbors in linear_metric_setup()\n",
; 863  :                       RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CN@LGDOGIDG@Too?5many?5neighbors?5in?5linear_met@
	push	1849					; 00000739H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN213@linear_met@3:

; 864  :                nbrlist[nbrcount++] = v[k];

	mov	eax, DWORD PTR _v$89967[ebp]
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	edx, DWORD PTR _nbrlist$89962[ebp]
	mov	DWORD PTR [edx+edi*4], ecx
	inc	edi
$LN221@linear_met@3:

; 856  :         for ( k = 0 ; k <= web.dimension ; k++ )

	inc	ebx
	cmp	ebx, DWORD PTR _web+620
	jle	SHORT $LL475@linear_met@3
$LN220@linear_met@3:

; 865  :             }
; 866  :           }
; 867  :           f_id = get_next_vertex_facet(v_id,f_id);

	mov	eax, DWORD PTR _f_id$89965[ebp]
	mov	ecx, DWORD PTR _v_id$[ebp]
	push	eax
	push	ecx
	call	_get_next_vertex_facet
	mov	DWORD PTR _f_id$89965[ebp], eax

; 868  :       } while ( !equal_element(f_id,start_f));

	or	eax, 134217728				; 08000000H
	add	esp, 8
	cmp	eax, DWORD PTR tv3638[ebp]
	jne	$LL225@linear_met@3

; 869  :       /* now count total degrees of freedom */
; 870  :       for ( j = vh->rownum, jj = 0 ; jj < vh->freedom ; jj++,j++ )

	mov	edx, DWORD PTR _vh$89980[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ebx, DWORD PTR [edx+12]
	xor	ecx, ecx
	mov	DWORD PTR _nbrcount$89964[ebp], edi
	test	eax, eax
	jle	SHORT $LN462@linear_met@3
	add	ebx, ebx
	add	ebx, ebx
$LL212@linear_met@3:

; 871  :         M->IA[j] += vh->freedom-jj;

	mov	edx, DWORD PTR [esi+52]
	sub	eax, ecx
	add	DWORD PTR [edx+ebx], eax
	mov	eax, DWORD PTR _vh$89980[ebp]
	mov	eax, DWORD PTR [eax+8]
	inc	ecx
	add	ebx, 4
	cmp	ecx, eax
	jl	SHORT $LL212@linear_met@3

; 869  :       /* now count total degrees of freedom */
; 870  :       for ( j = vh->rownum, jj = 0 ; jj < vh->freedom ; jj++,j++ )

	mov	edx, DWORD PTR _vh$89980[ebp]
$LN462@linear_met@3:

; 872  :       for ( m = 1 ; m < nbrcount ; m++ )

	mov	eax, 1
	cmp	edi, eax
	mov	edi, DWORD PTR _vhead_attr
	mov	DWORD PTR _m$89968[ebp], eax
	jle	$LN229@linear_met@3
	mov	ecx, DWORD PTR [edx+8]
$LL209@linear_met@3:

; 873  :       { struct hess_verlist *vhi = get_vertex_vhead(nbrlist[m]);

	mov	edx, DWORD PTR _nbrlist$89962[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ebx, DWORD PTR _web+12
	mov	edx, edi
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ebx+64]
	mov	eax, DWORD PTR [eax+edx]

; 874  :         for ( j = vh->rownum, jj = 0 ; jj < vh->freedom ; j++,jj++ )

	mov	edx, DWORD PTR _vh$89980[ebp]
	mov	ebx, DWORD PTR [edx+12]
	shl	eax, 5
	add	eax, DWORD PTR _vhead
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN208@linear_met@3

; 873  :       { struct hess_verlist *vhi = get_vertex_vhead(nbrlist[m]);

	lea	edi, DWORD PTR [ebx*4]
$LL206@linear_met@3:

; 875  :            M->IA[j] += vhi->freedom;

	mov	ecx, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR [eax+8]
	add	DWORD PTR [ecx+edi], ebx
	mov	ecx, DWORD PTR _vh$89980[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	inc	edx
	add	edi, 4
	cmp	edx, ecx
	jl	SHORT $LL206@linear_met@3

; 874  :         for ( j = vh->rownum, jj = 0 ; jj < vh->freedom ; j++,jj++ )

	mov	edi, DWORD PTR _vhead_attr
$LN208@linear_met@3:

; 872  :       for ( m = 1 ; m < nbrcount ; m++ )

	mov	eax, DWORD PTR _m$89968[ebp]
	inc	eax
	mov	DWORD PTR _m$89968[ebp], eax
	cmp	eax, DWORD PTR _nbrcount$89964[ebp]
	jl	$LL209@linear_met@3
$LN229@linear_met@3:

; 848  :     FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR tv3580[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _v_id$[ebp], eax
	jne	$LL230@linear_met@3

; 876  :       }
; 877  :     }
; 878  :   }
; 879  :   else 

	jmp	$LN192@linear_met@3
$LN231@linear_met@3:

; 880  :   { /* fe model */
; 881  :     FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	$LN431@linear_met@3
$LL202@linear_met@3:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edi, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv3581[ebp], edi
	je	SHORT $LN201@linear_met@3

; 882  :     { struct hess_verlist *vh = get_vertex_vhead(v_id);

	mov	eax, DWORD PTR _vhead_attr
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [ecx+eax]
	shl	eax, 5
	add	eax, DWORD PTR _vhead

; 883  :       for ( j = vh->rownum, jj = 0 ; jj < vh->freedom ; jj++,j++ )

	xor	edx, edx
	mov	ecx, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax+12]
	test	ecx, ecx
	jle	SHORT $LN201@linear_met@3

; 882  :     { struct hess_verlist *vh = get_vertex_vhead(v_id);

	add	ebx, ebx
	add	ebx, ebx
	npad	1
$LL197@linear_met@3:

; 884  :         M->IA[j] += vh->freedom-jj;      

	mov	edi, DWORD PTR [esi+52]
	sub	ecx, edx
	add	DWORD PTR [edi+ebx], ecx
	mov	ecx, DWORD PTR [eax+8]
	inc	edx
	add	ebx, 4
	cmp	edx, ecx
	jl	SHORT $LL197@linear_met@3

; 883  :       for ( j = vh->rownum, jj = 0 ; jj < vh->freedom ; jj++,j++ )

	mov	edi, DWORD PTR tv3581[ebp]
$LN201@linear_met@3:

; 880  :   { /* fe model */
; 881  :     FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	$LL202@linear_met@3
$LN431@linear_met@3:

; 885  :     }
; 886  :     FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	test	edx, 268435456				; 10000000H
	je	$LN192@linear_met@3
$LL194@linear_met@3:
	mov	eax, DWORD PTR _web+124
	mov	ebx, edx
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	mov	DWORD PTR tv3693[ebp], ebx
	je	$LN193@linear_met@3

; 887  :     { vertex_id tailv = get_edge_tailv(e_id);

	mov	eax, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edi+304]
	shr	edx, 27					; 0000001bH
	add	ecx, eax
	and	edx, 1
	je	SHORT $LN247@linear_met@3
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN246@linear_met@3
$LN247@linear_met@3:
	mov	eax, DWORD PTR [ecx]
$LN246@linear_met@3:

; 888  :       vertex_id headv = get_edge_headv(e_id);

	test	edx, edx
	je	SHORT $LN251@linear_met@3
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN250@linear_met@3
$LN251@linear_met@3:
	mov	edx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [ecx+edx*4]
$LN250@linear_met@3:

; 889  :       struct hess_verlist *vt = get_vertex_vhead(tailv),*vhtmp;

	mov	edx, DWORD PTR _vhead_attr
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+edi+64]
	mov	edi, DWORD PTR _web+12
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [edx+eax]

; 890  :       struct hess_verlist *vh = get_vertex_vhead(headv);

	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [edx+ecx]
	shl	eax, 5
	add	eax, DWORD PTR _vhead
	shl	ecx, 5
	add	ecx, DWORD PTR _vhead

; 891  : 
; 892  :       if ( vt->rownum > vh->rownum ) 

	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jle	SHORT $LN189@linear_met@3

; 893  :       { 
; 894  :         vhtmp = vh; vh = vt; vt = vhtmp;

	mov	edx, ecx
	mov	ecx, eax
	mov	eax, edx
$LN189@linear_met@3:

; 895  :       }
; 896  :       if ( vh->freedom == 0 ) continue;

	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN193@linear_met@3

; 897  :       for ( j = vt->rownum, jj = 0 ; jj < vt->freedom ; j++,jj++ )

	mov	edx, DWORD PTR [eax+12]
	xor	edi, edi
	cmp	DWORD PTR [eax+8], edi
	jle	SHORT $LN193@linear_met@3
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv5253[ebp], edx
$LL187@linear_met@3:

; 898  :          M->IA[j] += vh->freedom;

	mov	edx, DWORD PTR [esi+52]
	add	edx, DWORD PTR tv5253[ebp]
	mov	ebx, DWORD PTR [ecx+8]
	add	DWORD PTR [edx], ebx
	add	DWORD PTR tv5253[ebp], 4
	inc	edi
	cmp	edi, DWORD PTR [eax+8]
	jl	SHORT $LL187@linear_met@3

; 897  :       for ( j = vt->rownum, jj = 0 ; jj < vt->freedom ; j++,jj++ )

	mov	ebx, DWORD PTR tv3693[ebp]
$LN193@linear_met@3:

; 885  :     }
; 886  :     FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ebx+eax]
	mov	edx, DWORD PTR [ecx]
	test	edx, 268435456				; 10000000H
	jne	$LL194@linear_met@3
$LN192@linear_met@3:

; 899  :     }
; 900  :   }
; 901  :   for ( i = S->optparamrowstart ; i < S->N ; i++ )

	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [ecx+4]
	jge	SHORT $LN463@linear_met@3
	npad	10
$LL184@linear_met@3:

; 902  :     M->IA[i] = 1;  /* diagonal elements */

	mov	edx, DWORD PTR [esi+52]
	mov	DWORD PTR [edx+eax*4], 1
	inc	eax
	cmp	eax, DWORD PTR [ecx+4]
	jl	SHORT $LL184@linear_met@3
$LN463@linear_met@3:

; 903  : 
; 904  :   for ( i = 0, sum = 0 ; i < M->N ; i++ ) /* add to running totals */

	xor	eax, eax
	xor	edi, edi
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN179@linear_met@3
	npad	7
$LL181@linear_met@3:
	mov	ecx, DWORD PTR [esi+52]

; 905  :   { int tmp = sum; 
; 906  :     sum += M->IA[i] + optparamcount;

	mov	ebx, DWORD PTR [ecx+eax*4]
	add	ebx, DWORD PTR _optparamcount
	lea	ecx, DWORD PTR [ecx+eax*4]

; 907  :     M->IA[i] = tmp + A_OFF;

	lea	edx, DWORD PTR [edi+1]
	inc	eax
	add	edi, ebx
	mov	DWORD PTR [ecx], edx
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL181@linear_met@3
$LN179@linear_met@3:

; 908  :   }
; 909  :   M->IA[M->N] = sum + A_OFF;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+52]

; 910  : 
; 911  :   /* now can allocate space */
; 912  :   M->JA = (int *)temp_calloc(sum,sizeof(int));

	push	912					; 00000390H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	lea	edx, DWORD PTR [edi+1]
	push	4
	push	edi
	mov	DWORD PTR [ecx+eax*4], edx
	call	_kb_temp_calloc

; 913  :   M->A  = (REAL *)temp_calloc(sum,sizeof(REAL));

	push	913					; 00000391H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	8
	push	edi
	mov	DWORD PTR [esi+56], eax
	call	_kb_temp_calloc
	mov	DWORD PTR [esi+60], eax
	add	esp, 32					; 00000020H

; 914  : 
; 915  :   for ( i = 0 ; i < sum ; i++ ) M->JA[i] = -1;  /* vacant */

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN464@linear_met@3
	npad	5
$LL178@linear_met@3:
	mov	edx, DWORD PTR [esi+56]
	mov	DWORD PTR [edx+eax*4], -1
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL178@linear_met@3
$LN464@linear_met@3:

; 916  :   for ( i = 0 ; i < M->N ; i++ )

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN173@linear_met@3
$LL175@linear_met@3:

; 917  :   { M->JA[M->IA[i]-A_OFF] = i + A_OFF; /* diagonal entry at start */

	mov	edx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [esi+56]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [edi+edx*4-4], ecx

; 918  :     M->IP[i] = M->P[i] = i;    /* unpermuted */

	mov	edx, DWORD PTR [esi+68]
	mov	DWORD PTR [edx+eax*4], eax
	mov	edx, DWORD PTR [esi+72]
	mov	DWORD PTR [edx+eax*4], eax
	mov	eax, ecx
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL175@linear_met@3
$LN173@linear_met@3:

; 919  :   }
; 920  : 
; 921  : 
; 922  :   /* set up interpolation weight matrix */
; 923  : 
; 924  :   for ( i = 0 ; i < optparamcount ; i++ )

	fld1
	xor	eax, eax
	cmp	DWORD PTR _optparamcount, eax
	jle	SHORT $LN170@linear_met@3
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
$LN172@linear_met@3:

; 925  :     M->A[M->IA[S->optparamrowstart+i]-A_OFF] = 1.0;

	mov	edx, DWORD PTR [ecx+16]
	mov	edi, DWORD PTR [esi+52]
	add	edx, eax
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR [esi+60]
	inc	eax
	fst	QWORD PTR [edi+edx*8-8]
	cmp	eax, DWORD PTR _optparamcount
	jl	SHORT $LN172@linear_met@3
$LN170@linear_met@3:

; 926  :   /* leave rest of diagonal zero in case of augmented hessian */
; 927  : 
; 928  :   dim = web.dimension;

	mov	edi, DWORD PTR _web+620

; 929  :   for ( i = 0 ; i <= dim ; i++ )  /* index for vertices of element */

	xor	ebx, ebx
	mov	DWORD PTR _dim$[ebp], edi
	mov	DWORD PTR _i$[ebp], ebx
	test	edi, edi
	js	$LN494@linear_met@3
	fld	QWORD PTR __real@4000000000000000
	mov	eax, DWORD PTR _weights$[ebp]
$LN473@linear_met@3:

; 930  :     for ( m = 0 ; m <= dim ; m++ )

	lea	edx, DWORD PTR [edi+1]
	xor	ecx, ecx
	cmp	edx, 4
	jl	$LN474@linear_met@3
	fild	DWORD PTR _dim$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	lea	edx, DWORD PTR [ecx+2]
	add	eax, 16					; 00000010H
	fld	ST(0)
	fadd	ST(0), ST(3)
	fxch	ST(1)
	fadd	ST(0), ST(2)
$LN409@linear_met@3:

; 931  :     { if ( i == m )
; 932  :          weights[i][m] = linear_metric_mix*2.0/(dim+1.0)/(dim+2.0)
; 933  :               + (1.0 - linear_metric_mix)/(dim+1.0);

	fld	QWORD PTR _linear_metric_mix
	cmp	ebx, ecx
	jne	SHORT $LN401@linear_met@3
	fld	ST(0)
	fmul	ST(0), ST(4)
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(2)
	fld	ST(5)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	jmp	SHORT $LN546@linear_met@3
$LN401@linear_met@3:

; 934  :       else weights[i][m] = linear_metric_mix/(dim+1.0)/(dim+2.0);

	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(1)
$LN546@linear_met@3:
	lea	edi, DWORD PTR [edx-1]
	fstp	QWORD PTR [eax-16]
	fld	QWORD PTR _linear_metric_mix
	cmp	ebx, edi
	jne	SHORT $LN403@linear_met@3

; 931  :     { if ( i == m )
; 932  :          weights[i][m] = linear_metric_mix*2.0/(dim+1.0)/(dim+2.0)
; 933  :               + (1.0 - linear_metric_mix)/(dim+1.0);

	fld	ST(0)
	fmul	ST(0), ST(4)
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(2)
	fld	ST(5)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	jmp	SHORT $LN547@linear_met@3
$LN403@linear_met@3:

; 934  :       else weights[i][m] = linear_metric_mix/(dim+1.0)/(dim+2.0);

	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(1)
$LN547@linear_met@3:
	fstp	QWORD PTR [eax-8]
	fld	QWORD PTR _linear_metric_mix
	cmp	ebx, edx
	jne	SHORT $LN405@linear_met@3

; 931  :     { if ( i == m )
; 932  :          weights[i][m] = linear_metric_mix*2.0/(dim+1.0)/(dim+2.0)
; 933  :               + (1.0 - linear_metric_mix)/(dim+1.0);

	fld	ST(0)
	fmul	ST(0), ST(4)
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(2)
	fld	ST(5)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	jmp	SHORT $LN548@linear_met@3
$LN405@linear_met@3:

; 934  :       else weights[i][m] = linear_metric_mix/(dim+1.0)/(dim+2.0);

	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(1)
$LN548@linear_met@3:
	lea	edi, DWORD PTR [edx+1]
	fstp	QWORD PTR [eax]
	fld	QWORD PTR _linear_metric_mix
	cmp	ebx, edi
	jne	SHORT $LN407@linear_met@3

; 931  :     { if ( i == m )
; 932  :          weights[i][m] = linear_metric_mix*2.0/(dim+1.0)/(dim+2.0)
; 933  :               + (1.0 - linear_metric_mix)/(dim+1.0);

	fld	ST(0)
	fmul	ST(0), ST(4)
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(2)
	fld	ST(5)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	jmp	SHORT $LN549@linear_met@3
$LN407@linear_met@3:

; 934  :       else weights[i][m] = linear_metric_mix/(dim+1.0)/(dim+2.0);

	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(1)
$LN549@linear_met@3:
	mov	edi, DWORD PTR _dim$[ebp]
	fstp	QWORD PTR [eax+8]
	lea	ebx, DWORD PTR [edi-3]
	add	ecx, 4
	add	eax, 32					; 00000020H
	add	edx, 4
	cmp	ecx, ebx
	mov	ebx, DWORD PTR _i$[ebp]
	jle	$LN409@linear_met@3
	mov	eax, DWORD PTR _weights$[ebp]
	fstp	ST(1)
	fstp	ST(0)
$LN474@linear_met@3:

; 930  :     for ( m = 0 ; m <= dim ; m++ )

	cmp	ecx, edi
	jg	SHORT $LN168@linear_met@3
	fild	DWORD PTR _dim$[ebp]
	mov	edx, DWORD PTR [eax+ebx*4]
	lea	edx, DWORD PTR [edx+ecx*8]
	fld	ST(0)
	fadd	ST(0), ST(3)
	fxch	ST(1)
	fadd	ST(0), ST(2)
$LC166@linear_met@3:

; 931  :     { if ( i == m )
; 932  :          weights[i][m] = linear_metric_mix*2.0/(dim+1.0)/(dim+2.0)
; 933  :               + (1.0 - linear_metric_mix)/(dim+1.0);

	fld	QWORD PTR _linear_metric_mix
	cmp	ebx, ecx
	jne	SHORT $LN163@linear_met@3
	fld	ST(0)
	fmul	ST(0), ST(4)
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(2)
	fld	ST(5)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	jmp	SHORT $LN550@linear_met@3
$LN163@linear_met@3:

; 934  :       else weights[i][m] = linear_metric_mix/(dim+1.0)/(dim+2.0);

	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(1)
$LN550@linear_met@3:
	fstp	QWORD PTR [edx]
	inc	ecx
	add	edx, 8
	cmp	ecx, edi
	jle	SHORT $LC166@linear_met@3
	fstp	ST(1)
	fstp	ST(0)
$LN168@linear_met@3:

; 929  :   for ( i = 0 ; i <= dim ; i++ )  /* index for vertices of element */

	inc	ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, edi
	jle	$LN473@linear_met@3

; 934  :       else weights[i][m] = linear_metric_mix/(dim+1.0)/(dim+2.0);

	fstp	ST(1)
$LN494@linear_met@3:

; 935  :     }
; 936  : 
; 937  :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	fstp	ST(0)
	jne	$LN161@linear_met@3

; 938  :   { /* edge by edge */
; 939  :     FOR_ALL_EDGES(e_id)

	mov	ebx, DWORD PTR _web+160
	test	ebx, 268435456				; 10000000H
	je	$LN113@linear_met@3
	mov	edi, DWORD PTR _web+124
$LL441@linear_met@3:
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edi]
	mov	DWORD PTR tv3693[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN159@linear_met@3

; 940  :     { struct hess_verlist *vh[2];
; 941  :       vertex_id tailv = get_edge_tailv(e_id);

	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edx+304]
	mov	edi, ebx
	shr	edi, 27					; 0000001bH
	add	eax, ecx
	and	edi, 1
	je	SHORT $LN255@linear_met@3
	mov	ecx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN254@linear_met@3
$LN255@linear_met@3:
	mov	ecx, DWORD PTR [eax]
$LN254@linear_met@3:

; 942  :       vertex_id headv = get_edge_headv(e_id);

	test	edi, edi
	je	SHORT $LN259@linear_met@3
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN258@linear_met@3
$LN259@linear_met@3:
	mov	edi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edi*4]
$LN258@linear_met@3:

; 943  :       vh[0] = get_vertex_vhead(headv);

	mov	edi, DWORD PTR _vhead_attr
	imul	edi, 240				; 000000f0H
	add	edi, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx+64]
	mov	edi, DWORD PTR _web+12
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [edx+eax]

; 944  :       vh[1] = get_vertex_vhead(tailv);

	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [edx+ecx]
	shl	eax, 5
	add	eax, DWORD PTR _vhead
	shl	ecx, 5
	add	ecx, DWORD PTR _vhead

; 945  : 
; 946  :       if ( vh[0]->rownum > vh[1]->rownum )

	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _vh$90104[ebp], eax
	mov	DWORD PTR _vh$90104[ebp+4], ecx
	cmp	edx, DWORD PTR [ecx+12]
	jle	SHORT $LN155@linear_met@3

; 947  :       { struct hess_verlist *t = vh[0];
; 948  :         vh[0] = vh[1];

	mov	DWORD PTR _vh$90104[ebp], ecx

; 949  :         vh[1] = t;

	mov	DWORD PTR _vh$90104[ebp+4], eax
$LN155@linear_met@3:

; 950  :       }
; 951  :       len = get_edge_length(e_id);

	push	ebx
	call	_get_edge_length
	fstp	QWORD PTR _len$[ebp]
	lea	eax, DWORD PTR _vh$90104[ebp]
	add	esp, 4
	mov	DWORD PTR tv5679[ebp], 1
	mov	DWORD PTR tv5692[ebp], eax
	mov	DWORD PTR tv1260[ebp], 2
	npad	6
$LL154@linear_met@3:

; 953  :       { struct hess_verlist *v = vh[i];

	mov	ecx, DWORD PTR tv5692[ebp]
	mov	edi, DWORD PTR [ecx]

; 954  :         REAL fudge = v->slant*v->slant;
; 955  :          
; 956  :         /* self */
; 957  :         if ( v->proj )

	cmp	DWORD PTR [edi+16], 0
	fld	QWORD PTR [edi+24]
	fmul	ST(0), ST(0)
	mov	DWORD PTR _v$90120[ebp], edi
	fstp	QWORD PTR _fudge$90121[ebp]
	je	SHORT $LN151@linear_met@3

; 958  :         { 
; 959  :           tr_mat_mul(v->proj,v->proj,temp_mat,SDIM,v->freedom,v->freedom);

	mov	eax, DWORD PTR [edi+8]
	mov	edx, DWORD PTR _web+616
	mov	ecx, DWORD PTR [edi+16]
	mov	ebx, DWORD PTR _temp_mat$[ebp]
	push	eax
	push	eax
	push	edx
	push	ebx
	push	ecx
	push	ecx
	call	_tr_mat_mul
	add	esp, 24					; 00000018H

; 960  :           mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], ebx
	jmp	SHORT $LN150@linear_met@3
$LN151@linear_met@3:

; 961  :         }
; 962  :         else mat = identmat;

	mov	eax, DWORD PTR _identmat
	mov	DWORD PTR _mat$[ebp], eax
$LN150@linear_met@3:

; 963  :         for ( jj = 0 ; jj < v->freedom ; jj++ )

	mov	eax, DWORD PTR [edi+8]
	xor	ecx, ecx
	mov	DWORD PTR _jj$[ebp], ecx
	test	eax, eax
	jle	$LN147@linear_met@3
$LL149@linear_met@3:

; 964  :           for ( k = jj ; k < v->freedom ; k++ )

	mov	ebx, ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ecx, eax
	jge	$LN148@linear_met@3
$LL146@linear_met@3:

; 965  :           { col = v->rownum + k + A_OFF;

	mov	eax, DWORD PTR [edi+12]
	lea	edx, DWORD PTR [eax+ebx+1]

; 966  :             end = M->IA[v->rownum+jj+1]-A_OFF;

	add	eax, ecx
	mov	ecx, DWORD PTR [esi+52]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+4]

; 967  :             for ( m = M->IA[v->rownum+jj]-A_OFF ; m < (int)end  ; m++ )

	mov	eax, DWORD PTR [eax]
	dec	ecx
	dec	eax
	mov	DWORD PTR _col$[ebp], edx
	cmp	eax, ecx
	jge	$LN551@linear_met@3

; 965  :           { col = v->rownum + k + A_OFF;

	mov	edx, DWORD PTR [esi+56]
	lea	edx, DWORD PTR [edx+eax*4]
	npad	1
$LL445@linear_met@3:

; 968  :               if ( (M->JA[m] < A_OFF) || (M->JA[m] == col) )

	mov	edi, DWORD PTR [edx]
	cmp	edi, 1
	jl	SHORT $LN446@linear_met@3
	cmp	edi, DWORD PTR _col$[ebp]
	je	SHORT $LN446@linear_met@3

; 967  :             for ( m = M->IA[v->rownum+jj]-A_OFF ; m < (int)end  ; m++ )

	inc	eax
	add	edx, 4
	cmp	eax, ecx
	jl	SHORT $LL445@linear_met@3

; 1156 :      if ( M->JA[i] < A_OFF ) break;

	jmp	SHORT $LN552@linear_met@3
$LN446@linear_met@3:

; 969  :               { M->JA[m] = col;

	mov	edx, DWORD PTR [esi+56]

; 970  :                 M->A[m] += fudge*(3-linear_metric_mix)*len/6*mat[jj][k];

	fld	QWORD PTR __real@4008000000000000
	mov	edi, DWORD PTR _col$[ebp]
	mov	DWORD PTR [edx+eax*4], edi
	fsub	QWORD PTR _linear_metric_mix
	mov	ebx, DWORD PTR _mat$[ebp]
	mov	edi, DWORD PTR _jj$[ebp]
	fmul	QWORD PTR _fudge$90121[ebp]
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR [esi+60]
	fmul	QWORD PTR _len$[ebp]
	lea	edx, DWORD PTR [edx+eax*8]
	fdiv	QWORD PTR __real@4018000000000000
	fmul	QWORD PTR [edi+ebx*8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
$LN552@linear_met@3:
	mov	edi, DWORD PTR _v$90120[ebp]

; 971  :                 break;
; 972  :               }
; 973  :             if ( m == end )

	cmp	eax, ecx
$LN551@linear_met@3:
	jne	SHORT $LN145@linear_met@3

; 974  :                kb_error(1851,"Internal error in linear_metric_setup.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CI@IIDDMHOH@Internal?5error?5in?5linear_metric_@
	push	1851					; 0000073bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN145@linear_met@3:

; 964  :           for ( k = jj ; k < v->freedom ; k++ )

	mov	ecx, DWORD PTR _jj$[ebp]
	inc	ebx
	mov	DWORD PTR _k$[ebp], ebx
	cmp	ebx, DWORD PTR [edi+8]
	jl	$LL146@linear_met@3
$LN148@linear_met@3:

; 963  :         for ( jj = 0 ; jj < v->freedom ; jj++ )

	mov	eax, DWORD PTR [edi+8]
	inc	ecx
	mov	DWORD PTR _jj$[ebp], ecx
	cmp	ecx, eax
	jl	$LL149@linear_met@3
$LN147@linear_met@3:

; 975  :           }
; 976  : 
; 977  :           /* cross terms */
; 978  :           for ( k = i+1 ; k < 2 ; k++ )

	mov	eax, DWORD PTR tv5679[ebp]
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, 2
	jge	$LN153@linear_met@3
$LL458@linear_met@3:

; 979  :           { struct hess_verlist *vv = vh[k];

	mov	eax, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _vh$90104[ebp+eax*4]

; 980  :             REAL cfudge = v->slant*vv->slant;

	mov	edi, DWORD PTR _v$90120[ebp]
	fld	QWORD PTR [eax+24]
	fmul	QWORD PTR [edi+24]

; 981  :             if ( v->proj && vv->proj )

	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR _vv$90141[ebp], eax
	fstp	QWORD PTR _cfudge$90142[ebp]
	test	ecx, ecx
	je	SHORT $LN132@linear_met@3
	mov	edx, DWORD PTR [eax+16]

; 982  :             { tr_mat_mul(v->proj,vv->proj,temp_mat,SDIM,v->freedom,
; 983  :                     vv->freedom);

	mov	ebx, DWORD PTR _temp_mat$[ebp]
	test	edx, edx
	je	SHORT $LN134@linear_met@3
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	eax, DWORD PTR [edi+8]
	push	eax
	mov	eax, DWORD PTR _web+616
	push	eax
	push	ebx
	push	edx
	push	ecx
	call	_tr_mat_mul
	add	esp, 24					; 00000018H

; 984  :               mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], ebx
	jmp	SHORT $LN129@linear_met@3
$LN134@linear_met@3:

; 985  :             }
; 986  :             else if ( v->proj )
; 987  :             { tr_mat_mul(v->proj,identmat,temp_mat,SDIM,v->freedom,
; 988  :                   vv->freedom);

	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edi+8]
	push	edx
	mov	edx, DWORD PTR _web+616
	push	eax
	mov	eax, DWORD PTR _identmat
	push	edx
	push	ebx
	push	eax
	push	ecx
	call	_tr_mat_mul
	add	esp, 24					; 00000018H

; 989  :               mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], ebx
	jmp	SHORT $LN129@linear_met@3
$LN132@linear_met@3:

; 990  :             }
; 991  :             else if ( vv->proj ) mat = vv->proj;

	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	SHORT $LN130@linear_met@3
	mov	DWORD PTR _mat$[ebp], eax
	jmp	SHORT $LN129@linear_met@3
$LN130@linear_met@3:

; 992  :             else mat = identmat;

	mov	ecx, DWORD PTR _identmat
	mov	DWORD PTR _mat$[ebp], ecx
$LN129@linear_met@3:

; 993  : 
; 994  :             for ( jj = 0 ; jj < v->freedom ; jj++ )  

	xor	ebx, ebx
	mov	DWORD PTR _jj$[ebp], ebx
	cmp	DWORD PTR [edi+8], ebx
	jle	$LN136@linear_met@3
	npad	3
$LL128@linear_met@3:

; 995  :               for ( kk = 0 ; kk < vv->freedom ; kk++ )  

	mov	eax, DWORD PTR _vv$90141[ebp]
	xor	edi, edi
	mov	DWORD PTR _kk$[ebp], edi
	cmp	DWORD PTR [eax+8], edi
	jle	$LN127@linear_met@3
	npad	9
$LL125@linear_met@3:

; 996  :               { col = vv->rownum + kk + A_OFF ;

	mov	edx, DWORD PTR [eax+12]

; 997  :                 end = M->IA[v->rownum+jj+1]-A_OFF;

	mov	ecx, DWORD PTR _v$90120[ebp]
	lea	eax, DWORD PTR [edx+edi+1]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _col$[ebp], eax
	mov	eax, DWORD PTR [esi+52]
	add	edx, ebx
	mov	ecx, DWORD PTR [eax+edx*4+4]
	lea	eax, DWORD PTR [eax+edx*4]

; 998  :                 for ( j = M->IA[v->rownum+jj]+1-A_OFF ; (int)j < end ; j++ )

	mov	eax, DWORD PTR [eax]
	dec	ecx
	cmp	eax, ecx
	jae	$LN553@linear_met@3

; 996  :               { col = vv->rownum + kk + A_OFF ;

	mov	edx, DWORD PTR [esi+56]
	lea	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv5567[ebp], edx
	npad	7
$LL439@linear_met@3:

; 999  :                   if ( (M->JA[j] < A_OFF) || (M->JA[j] == col)  )

	mov	edx, DWORD PTR tv5567[ebp]
	mov	edx, DWORD PTR [edx]
	cmp	edx, 1
	jl	SHORT $LN440@linear_met@3
	cmp	edx, DWORD PTR _col$[ebp]
	je	SHORT $LN440@linear_met@3

; 998  :                 for ( j = M->IA[v->rownum+jj]+1-A_OFF ; (int)j < end ; j++ )

	add	DWORD PTR tv5567[ebp], 4
	inc	eax
	cmp	eax, ecx
	jb	SHORT $LL439@linear_met@3

; 1156 :      if ( M->JA[i] < A_OFF ) break;

	jmp	SHORT $LN120@linear_met@3
$LN440@linear_met@3:

; 1000 :                   { M->JA[j] = col; 

	mov	edx, DWORD PTR [esi+56]
	mov	edi, DWORD PTR _col$[ebp]
	mov	DWORD PTR [edx+eax*4], edi

; 1001 :                     M->A[j] += cfudge*mat[jj][kk]*len/6*linear_metric_mix;

	mov	edi, DWORD PTR _mat$[ebp]
	mov	ebx, DWORD PTR [edi+ebx*4]
	mov	edi, DWORD PTR _kk$[ebp]
	fld	QWORD PTR [ebx+edi*8]
	mov	edx, DWORD PTR [esi+60]
	fmul	QWORD PTR _cfudge$90142[ebp]
	mov	ebx, DWORD PTR _jj$[ebp]
	lea	edx, DWORD PTR [edx+eax*8]
	fmul	QWORD PTR _len$[ebp]
	fdiv	QWORD PTR __real@4018000000000000
	fmul	QWORD PTR _linear_metric_mix
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
$LN120@linear_met@3:

; 1002 :                     break;
; 1003 :                   }
; 1004 :                 if ( j == end )

	cmp	eax, ecx
$LN553@linear_met@3:
	jne	SHORT $LN124@linear_met@3

; 1005 :                     kb_error(1852,"Internal error in linear_metric_setup.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CI@IIDDMHOH@Internal?5error?5in?5linear_metric_@
	push	1852					; 0000073cH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN124@linear_met@3:

; 995  :               for ( kk = 0 ; kk < vv->freedom ; kk++ )  

	mov	eax, DWORD PTR _vv$90141[ebp]
	inc	edi
	mov	DWORD PTR _kk$[ebp], edi
	cmp	edi, DWORD PTR [eax+8]
	jl	$LL125@linear_met@3
$LN127@linear_met@3:

; 993  : 
; 994  :             for ( jj = 0 ; jj < v->freedom ; jj++ )  

	mov	eax, DWORD PTR _v$90120[ebp]
	inc	ebx
	mov	DWORD PTR _jj$[ebp], ebx
	cmp	ebx, DWORD PTR [eax+8]
	jl	$LL128@linear_met@3
$LN136@linear_met@3:

; 975  :           }
; 976  : 
; 977  :           /* cross terms */
; 978  :           for ( k = i+1 ; k < 2 ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, 2
	jl	$LL458@linear_met@3
$LN153@linear_met@3:

; 952  :       for ( i = 0 ; i < 2 ; i++ )

	add	DWORD PTR tv5692[ebp], 4
	mov	eax, 1
	add	DWORD PTR tv5679[ebp], eax
	sub	DWORD PTR tv1260[ebp], eax
	jne	$LL154@linear_met@3
	mov	edi, DWORD PTR _web+124
$LN159@linear_met@3:

; 938  :   { /* edge by edge */
; 939  :     FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR tv3693[ebp]
	mov	edx, DWORD PTR [ecx+edi]
	mov	ebx, DWORD PTR [edx]
	test	ebx, 268435456				; 10000000H
	jne	$LL441@linear_met@3

; 1006 :               }
; 1007 :           }
; 1008 :         }
; 1009 :      }
; 1010 :   }
; 1011 :   else 

	jmp	$LN113@linear_met@3
$LN161@linear_met@3:

; 1012 :   { facet_id f_id;
; 1013 :     REAL area;
; 1014 : 
; 1015 :     /* facet by facet */
; 1016 :     FOR_ALL_FACETS(f_id)

	mov	edi, DWORD PTR _web+272
	mov	ebx, edi
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	je	$LN113@linear_met@3
	npad	9
$LL115@linear_met@3:
	mov	edx, DWORD PTR _web+236
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv4014[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN114@linear_met@3

; 1017 :     { vertex_id ix[FACET_VERTS];
; 1018 :       facetedge_id fe;
; 1019 :       REAL density = get_facet_density(f_id); 

	mov	eax, DWORD PTR tv4014[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	fld	QWORD PTR [ecx+32]

; 1020 :       REAL normal[MAXCOORD];
; 1021 :       struct hess_verlist *vh[MAXCOORD+2];
; 1022 : 
; 1023 :       area = get_facet_area(f_id);

	push	edi
	fstp	QWORD PTR _density$90176[ebp]
	call	_recalc_facet_area
	mov	eax, DWORD PTR _web+236
	mov	edx, DWORD PTR tv4014[ebp]
	mov	ecx, DWORD PTR [edx+eax]
	fld	QWORD PTR [ecx+40]
	add	esp, 4
	fst	QWORD PTR _area$90164[ebp]

; 1024 :       if ( density != 0.0 ) area *= density;

	fld	QWORD PTR _density$90176[ebp]
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN531@linear_met@3
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR _area$90164[ebp]
	jmp	SHORT $LN110@linear_met@3
$LN531@linear_met@3:
	fstp	ST(0)
	fstp	ST(0)
$LN110@linear_met@3:

; 1025 :       if ( hessian_normal_perp_flag ) 

	cmp	DWORD PTR _hessian_normal_perp_flag, 0
	je	$LN432@linear_met@3

; 1026 :       { REAL d;
; 1027 :         get_facet_normal(f_id,normal);

	lea	edx, DWORD PTR _normal$90178[ebp]
	push	edx
	push	edi
	call	_get_facet_normal

; 1028 :         d = sqrt(SDIM_dot(normal,normal));

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _normal$90178[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	add	esp, 20					; 00000014H
	call	__CIsqrt

; 1029 :         for ( i = 0 ; i < SDIM ; i++ ) normal[i] /= d;

	mov	edx, DWORD PTR _web+616
	xor	eax, eax
	cmp	edx, 4
	jl	SHORT $LC411@linear_met@3
	lea	ecx, DWORD PTR [edx-3]
$LN412@linear_met@3:
	fld	QWORD PTR _normal$90178[ebp+eax*8]
	add	eax, 4
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _normal$90178[ebp+eax*8-32]
	fld	QWORD PTR _normal$90178[ebp+eax*8-24]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _normal$90178[ebp+eax*8-24]
	fld	QWORD PTR _normal$90178[ebp+eax*8-16]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _normal$90178[ebp+eax*8-16]
	fld	QWORD PTR _normal$90178[ebp+eax*8-8]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _normal$90178[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN412@linear_met@3
$LC411@linear_met@3:
	cmp	eax, edx
	jge	SHORT $LN539@linear_met@3
$LC108@linear_met@3:
	fld	QWORD PTR _normal$90178[ebp+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _normal$90178[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC108@linear_met@3
$LN539@linear_met@3:
	fstp	ST(0)
$LN432@linear_met@3:

; 1030 :       }
; 1031 : 
; 1032 :       fe = get_facet_fe(f_id);

	test	ebx, ebx
	jne	SHORT $LN263@linear_met@3
	xor	eax, eax
	mov	DWORD PTR _fe$90175[ebp], eax
	jmp	SHORT $LN264@linear_met@3
$LN263@linear_met@3:
	mov	eax, DWORD PTR tv4014[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN262@linear_met@3
	xor	eax, 134217728				; 08000000H
$LN262@linear_met@3:
	mov	DWORD PTR _fe$90175[ebp], eax
$LN264@linear_met@3:

; 1033 :       ix[0] = get_fe_tailv(fe);

	mov	edx, DWORD PTR _web+460
	mov	ebx, DWORD PTR _web+636
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, eax
	mov	eax, DWORD PTR [ecx+20]
	and	edx, 134217728				; 08000000H
	xor	eax, edx
	mov	edx, DWORD PTR _dymem
	mov	DWORD PTR tv4073[ebp], ecx
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	edx, DWORD PTR _web+124
	mov	edi, eax
	test	eax, 134217728				; 08000000H
	je	SHORT $LN269@linear_met@3
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+edi*4]
	lea	edi, DWORD PTR [edi+ebx*4]
	mov	edi, DWORD PTR [edi+ecx]
	jmp	SHORT $LN268@linear_met@3
$LN269@linear_met@3:
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+edi*4]
	mov	edi, DWORD PTR [ecx+edi]
$LN268@linear_met@3:
	mov	DWORD PTR _ix$90174[ebp], edi

; 1034 :       ix[1] = get_fe_headv(fe);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN275@linear_met@3
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
	jmp	SHORT $LN274@linear_met@3
$LN275@linear_met@3:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN274@linear_met@3:

; 1035 :       fe = get_next_edge(fe);

	test	DWORD PTR _fe$90175[ebp], 134217728	; 08000000H
	mov	DWORD PTR _ix$90174[ebp+4], eax
	mov	eax, DWORD PTR tv4073[ebp]
	je	SHORT $LN279@linear_met@3
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN278@linear_met@3
$LN279@linear_met@3:
	mov	eax, DWORD PTR [eax+32]
$LN278@linear_met@3:

; 1036 :       ix[2] = get_fe_headv(fe);

	mov	ebx, DWORD PTR _web+460
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN285@linear_met@3
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [ecx+edx]
	jmp	SHORT $LN284@linear_met@3
$LN285@linear_met@3:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR [eax+ecx]
$LN284@linear_met@3:

; 1037 :       
; 1038 :       for ( i = 0 ; i <= dim ; i++ )  /* bubble sort vertices */

	mov	edx, DWORD PTR _dim$[ebp]
	mov	DWORD PTR _ix$90174[ebp+8], ecx
	xor	ecx, ecx
	test	edx, edx
	js	$LN114@linear_met@3
	mov	eax, DWORD PTR _vhead_attr
	mov	edi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edi+64]
	lea	edi, DWORD PTR _vh$90179[ebp]
	sub	edi, 4
	mov	DWORD PTR tv4142[ebp], eax
	mov	DWORD PTR tv5979[ebp], edi
	npad	7
$LL486@linear_met@3:

; 1039 :       { 
; 1040 :         vh[dim+1] = get_vertex_vhead(ix[i]);

	mov	eax, DWORD PTR _ix$90174[ebp+ecx*4]
	mov	ebx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR tv4142[ebp]
	mov	eax, DWORD PTR [ebx+eax]
	shl	eax, 5
	add	eax, DWORD PTR _vhead

; 1041 :         j = vh[dim+1]->rownum;

	mov	ebx, DWORD PTR [eax+12]
	mov	DWORD PTR _vh$90179[ebp+edx*4+4], eax

; 1042 :         for ( k = i ; k > 0 ; k-- )

	mov	eax, ecx
	test	ecx, ecx
	jle	SHORT $LN99@linear_met@3
$LL102@linear_met@3:

; 1043 :           if ( vh[k-1]->rownum > j ) 

	mov	edx, DWORD PTR [edi]
	cmp	DWORD PTR [edx+12], ebx
	jbe	SHORT $LN455@linear_met@3

; 1044 :           {
; 1045 :             vh[k] = vh[k-1];

	mov	DWORD PTR [edi+4], edx
	dec	eax
	sub	edi, 4
	test	eax, eax
	jg	SHORT $LL102@linear_met@3
$LN455@linear_met@3:

; 1042 :         for ( k = i ; k > 0 ; k-- )

	mov	edx, DWORD PTR _dim$[ebp]
$LN99@linear_met@3:

; 1046 :           }
; 1047 :           else break;       
; 1048 :         vh[k] = vh[dim+1];

	mov	edi, DWORD PTR _vh$90179[ebp+edx*4+4]
	mov	DWORD PTR _vh$90179[ebp+eax*4], edi
	mov	edi, DWORD PTR tv5979[ebp]
	inc	ecx
	add	edi, 4
	mov	DWORD PTR tv5979[ebp], edi
	cmp	ecx, edx
	jle	SHORT $LL486@linear_met@3

; 1049 :       }
; 1050 :       for ( i = 0 ; i <= dim ; i++ )

	test	edx, edx
	js	$LN114@linear_met@3
	mov	ecx, DWORD PTR _weights$[ebp]
	lea	eax, DWORD PTR _vh$90179[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv6243[ebp], ecx
	mov	ecx, DWORD PTR _dim$[ebp]
	inc	ecx
	mov	DWORD PTR tv6198[ebp], 1
	mov	DWORD PTR tv6200[ebp], 0
	mov	DWORD PTR tv6280[ebp], eax
	mov	DWORD PTR tv2507[ebp], ecx
$LL460@linear_met@3:

; 1051 :       { struct hess_verlist *v = vh[i];

	mov	eax, DWORD PTR tv6243[ebp]
	mov	edx, DWORD PTR tv6280[ebp]
	mov	edi, DWORD PTR [edx+eax]

; 1052 :         REAL fudge = v->slant*v->slant;

	fld	QWORD PTR [edi+24]

; 1053 :         /* self */
; 1054 :         if ( v->proj )

	mov	eax, DWORD PTR [edi+16]
	fmul	ST(0), ST(0)
	mov	DWORD PTR _v$90202[ebp], edi
	fstp	QWORD PTR _fudge$90203[ebp]
	test	eax, eax
	je	$LN94@linear_met@3

; 1055 :         { 
; 1056 :           if ( hessian_normal_perp_flag )

	cmp	DWORD PTR _hessian_normal_perp_flag, 0
	je	SHORT $LN93@linear_met@3

; 1057 :           { REAL w[MAXCOORD], *wp=w;
; 1058 :             vec_mat_mul(normal,v->proj,w,SDIM,v->freedom);

	mov	edx, DWORD PTR [edi+8]
	push	edx
	lea	ecx, DWORD PTR _w$90206[ebp]
	mov	DWORD PTR _wp$90207[ebp], ecx
	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _w$90206[ebp]
	push	edx
	push	eax
	lea	eax, DWORD PTR _normal$90178[ebp]
	push	eax
	call	_vec_mat_mul

; 1059 :             tr_mat_mul(&wp,&wp,temp_mat,1,v->freedom,v->freedom);

	mov	eax, DWORD PTR [edi+8]
	mov	ebx, DWORD PTR _temp_mat$[ebp]
	push	eax
	push	eax
	push	1
	lea	ecx, DWORD PTR _wp$90207[ebp]
	push	ebx
	push	ecx
	mov	edx, ecx
	push	edx
	call	_tr_mat_mul

; 1060 :             fudge = 1.0;

	fld1
	fstp	QWORD PTR _fudge$90203[ebp]
	add	esp, 44					; 0000002cH

; 1065 :           }
; 1066 :           mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], ebx
	jmp	SHORT $LN91@linear_met@3
$LN93@linear_met@3:

; 1061 :           }
; 1062 :           else
; 1063 :           {
; 1064 :             tr_mat_mul(v->proj,v->proj,temp_mat,SDIM,v->freedom,v->freedom);

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+16]
	mov	ebx, DWORD PTR _temp_mat$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR _web+616
	push	eax
	push	ebx
	push	ecx
	push	ecx
	call	_tr_mat_mul
	add	esp, 24					; 00000018H

; 1065 :           }
; 1066 :           mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], ebx
	jmp	SHORT $LN91@linear_met@3
$LN94@linear_met@3:

; 1067 :         }
; 1068 :         else mat = identmat;

	mov	ecx, DWORD PTR _identmat
	mov	DWORD PTR _mat$[ebp], ecx
$LN91@linear_met@3:

; 1069 : 
; 1070 :         for ( jj = 0 ; jj < v->freedom ; jj++ )

	mov	eax, DWORD PTR [edi+8]
	xor	ebx, ebx
	mov	DWORD PTR _jj$[ebp], ebx
	test	eax, eax
	jle	$LN88@linear_met@3
$LL90@linear_met@3:

; 1071 :           for ( k = jj ; k < v->freedom ; k++ )

	mov	edi, ebx
	mov	DWORD PTR _k$[ebp], edi
	cmp	ebx, eax
	jge	$LN89@linear_met@3
$LL435@linear_met@3:

; 1072 :           { col = v->rownum + k + A_OFF;

	mov	edx, DWORD PTR _v$90202[ebp]
	mov	eax, DWORD PTR [edx+12]

; 1073 :             end = M->IA[v->rownum+jj+1]-A_OFF;

	mov	edx, DWORD PTR [esi+52]
	lea	ecx, DWORD PTR [eax+edi+1]
	add	eax, ebx
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _col$[ebp], ecx
	mov	ecx, DWORD PTR [eax+4]

; 1074 :             for ( j = M->IA[v->rownum+jj]-A_OFF ; (int)j < end  ; j++ )

	mov	eax, DWORD PTR [eax]
	dec	ecx
	dec	eax
	cmp	eax, ecx
	jae	$LN555@linear_met@3

; 1072 :           { col = v->rownum + k + A_OFF;

	mov	edx, DWORD PTR [esi+56]
	lea	edx, DWORD PTR [edx+eax*4]
$LL443@linear_met@3:

; 1075 :               if ( (M->JA[j] < A_OFF) || (M->JA[j] == col) )

	mov	ebx, DWORD PTR [edx]
	cmp	ebx, 1
	jl	SHORT $LN444@linear_met@3
	cmp	ebx, DWORD PTR _col$[ebp]
	je	SHORT $LN444@linear_met@3

; 1074 :             for ( j = M->IA[v->rownum+jj]-A_OFF ; (int)j < end  ; j++ )

	inc	eax
	add	edx, 4
	cmp	eax, ecx
	jb	SHORT $LL443@linear_met@3

; 1156 :      if ( M->JA[i] < A_OFF ) break;

	jmp	SHORT $LN556@linear_met@3
$LN444@linear_met@3:

; 1076 :               { M->JA[j] = col;

	mov	edx, DWORD PTR [esi+56]
	mov	edi, DWORD PTR _col$[ebp]

; 1077 :                 M->A[j] += fudge*weights[i][i]*area*mat[jj][k];

	mov	ebx, DWORD PTR tv6200[ebp]
	mov	DWORD PTR [edx+eax*4], edi
	mov	edx, DWORD PTR [esi+60]
	mov	edi, DWORD PTR _mat$[ebp]
	lea	edx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR tv4001[ebp], edx
	mov	edx, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR tv6243[ebp]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+ebx]
	mov	edi, DWORD PTR _k$[ebp]
	fmul	QWORD PTR _fudge$90203[ebp]
	fmul	QWORD PTR _area$90164[ebp]
	fmul	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR tv4001[ebp]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
$LN556@linear_met@3:
	mov	ebx, DWORD PTR _jj$[ebp]

; 1078 :                 break;
; 1079 :               }
; 1080 :               if ( j == end )

	cmp	eax, ecx
$LN555@linear_met@3:
	jne	SHORT $LN86@linear_met@3

; 1081 :                  kb_error(1853,"Internal error in linear_metric_setup.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CI@IIDDMHOH@Internal?5error?5in?5linear_metric_@
	push	1853					; 0000073dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN86@linear_met@3:

; 1071 :           for ( k = jj ; k < v->freedom ; k++ )

	mov	eax, DWORD PTR _v$90202[ebp]
	inc	edi
	mov	DWORD PTR _k$[ebp], edi
	cmp	edi, DWORD PTR [eax+8]
	jl	$LL435@linear_met@3
$LN89@linear_met@3:

; 1069 : 
; 1070 :         for ( jj = 0 ; jj < v->freedom ; jj++ )

	mov	ecx, DWORD PTR _v$90202[ebp]
	mov	eax, DWORD PTR [ecx+8]
	inc	ebx
	mov	DWORD PTR _jj$[ebp], ebx
	cmp	ebx, eax
	jl	$LL90@linear_met@3
$LN88@linear_met@3:

; 1082 :           }
; 1083 : 
; 1084 :         /* cross terms */
; 1085 :         for ( k = i+1 ; k <= dim ; k++ )

	mov	eax, DWORD PTR tv6198[ebp]
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _dim$[ebp]
	jg	$LN96@linear_met@3
	npad	9
$LL78@linear_met@3:

; 1086 :         { struct hess_verlist *vv = vh[k];

	mov	edx, DWORD PTR _k$[ebp]
	mov	ebx, DWORD PTR _vh$90179[ebp+edx*4]

; 1087 :           REAL cfudge = v->slant*vv->slant;

	mov	edi, DWORD PTR _v$90202[ebp]
	fld	QWORD PTR [ebx+24]
	fmul	QWORD PTR [edi+24]

; 1088 :           if ( v->proj && vv->proj )

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR _vv$90226[ebp], ebx
	fstp	QWORD PTR _cfudge$90227[ebp]
	test	eax, eax
	je	$LN71@linear_met@3
	mov	ecx, DWORD PTR [ebx+16]
	test	ecx, ecx
	je	$LN75@linear_met@3

; 1089 :           { 
; 1090 :             if ( hessian_normal_perp_flag )

	cmp	DWORD PTR _hessian_normal_perp_flag, 0
	je	$LN74@linear_met@3

; 1091 :             { REAL w[MAXCOORD],ww[MAXCOORD],*wp=w,*wwp=ww;

	lea	ecx, DWORD PTR _w$90230[ebp]
	mov	DWORD PTR _wp$90232[ebp], ecx

; 1092 :               vec_mat_mul(normal,v->proj,w,SDIM,v->freedom);

	mov	ecx, DWORD PTR [edi+8]
	push	ecx
	lea	edx, DWORD PTR _ww$90231[ebp]
	mov	DWORD PTR _wwp$90233[ebp], edx
	mov	edx, DWORD PTR _web+616
	push	edx
	lea	ecx, DWORD PTR _w$90230[ebp]
	push	ecx
	push	eax
	lea	edx, DWORD PTR _normal$90178[ebp]
	push	edx
	call	_vec_mat_mul

; 1093 :               vec_mat_mul(normal,vv->proj,ww,SDIM,vv->freedom);

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR _web+616
	push	eax
	mov	eax, DWORD PTR [ebx+16]
	push	ecx
	lea	edx, DWORD PTR _ww$90231[ebp]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _normal$90178[ebp]
	push	ecx
	call	_vec_mat_mul

; 1094 :               tr_mat_mul(&wp,&wwp,temp_mat,1,v->freedom,vv->freedom);

	mov	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [edi+8]
	mov	edi, DWORD PTR _temp_mat$[ebp]
	push	edx
	push	eax
	push	1
	push	edi
	lea	ecx, DWORD PTR _wwp$90233[ebp]
	push	ecx
	lea	edx, DWORD PTR _wp$90232[ebp]
	push	edx
	call	_tr_mat_mul

; 1095 :               cfudge = 1.0;

	fld1
	fstp	QWORD PTR _cfudge$90227[ebp]
	add	esp, 64					; 00000040H

; 1111 :               mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], edi
	jmp	$LN62@linear_met@3
$LN74@linear_met@3:

; 1096 :             }
; 1097 :             else 
; 1098 :               tr_mat_mul(v->proj,vv->proj,temp_mat,SDIM,v->freedom,vv->freedom);

	mov	edx, DWORD PTR [ebx+8]
	push	edx
	mov	edx, DWORD PTR [edi+8]
	mov	edi, DWORD PTR _temp_mat$[ebp]
	push	edx
	mov	edx, DWORD PTR _web+616
	push	edx
	push	edi
	push	ecx
	push	eax
	call	_tr_mat_mul
	add	esp, 24					; 00000018H

; 1099 :             mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], edi
	jmp	$LN62@linear_met@3
$LN75@linear_met@3:

; 1100 :           }
; 1101 :           else if ( v->proj )
; 1102 :           { 
; 1103 :             if ( hessian_normal_perp_flag )

	cmp	DWORD PTR _hessian_normal_perp_flag, 0
	je	$LN70@linear_met@3

; 1104 :             { REAL w[MAXCOORD],*wp=w,*np=normal;

	lea	ecx, DWORD PTR _w$90238[ebp]
	mov	DWORD PTR _wp$90239[ebp], ecx

; 1105 :               vec_mat_mul(normal,v->proj,w,SDIM,v->freedom);

	mov	ecx, DWORD PTR [edi+8]
	push	ecx
	lea	edx, DWORD PTR _normal$90178[ebp]
	mov	DWORD PTR _np$90240[ebp], edx
	mov	edx, DWORD PTR _web+616
	push	edx
	lea	ecx, DWORD PTR _w$90238[ebp]
	push	ecx
	push	eax
	lea	edx, DWORD PTR _normal$90178[ebp]
	push	edx
	call	_vec_mat_mul

; 1106 :               tr_mat_mul(&wp,&np,temp_mat,1,v->freedom,vv->freedom);

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [edi+8]
	mov	edi, DWORD PTR _temp_mat$[ebp]
	push	eax
	push	ecx
	push	1
	push	edi
	lea	edx, DWORD PTR _np$90240[ebp]
	push	edx
	lea	eax, DWORD PTR _wp$90239[ebp]
	push	eax
	call	_tr_mat_mul

; 1107 :               cfudge = 1.0;

	fld1
	fstp	QWORD PTR _cfudge$90227[ebp]
	add	esp, 44					; 0000002cH

; 1111 :               mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], edi
	jmp	$LN62@linear_met@3
$LN70@linear_met@3:

; 1108 :             }
; 1109 :             else 
; 1110 :               tr_mat_mul(v->proj,identmat,temp_mat,SDIM,v->freedom,vv->freedom);

	mov	ecx, DWORD PTR [ebx+8]
	mov	edx, DWORD PTR [edi+8]
	mov	edi, DWORD PTR _temp_mat$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _web+616
	push	edx
	mov	edx, DWORD PTR _identmat
	push	ecx
	push	edi
	push	edx
	push	eax
	call	_tr_mat_mul
	add	esp, 24					; 00000018H

; 1111 :               mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], edi
	jmp	$LN62@linear_met@3
$LN71@linear_met@3:

; 1112 :           }
; 1113 :           else if ( vv->proj )

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	$LN67@linear_met@3

; 1114 :           {
; 1115 :             if ( hessian_normal_perp_flag )

	cmp	DWORD PTR _hessian_normal_perp_flag, 0
	je	$LN66@linear_met@3

; 1116 :             { REAL ww[MAXCOORD],*wwp=ww,*np=normal;

	lea	ecx, DWORD PTR _ww$90245[ebp]
	mov	DWORD PTR _wwp$90246[ebp], ecx

; 1117 :               vec_mat_mul(normal,vv->proj,ww,SDIM,vv->freedom);

	mov	ecx, DWORD PTR [ebx+8]
	push	ecx
	lea	edx, DWORD PTR _normal$90178[ebp]
	mov	DWORD PTR _np$90247[ebp], edx
	mov	edx, DWORD PTR _web+616
	push	edx
	lea	ecx, DWORD PTR _ww$90245[ebp]
	push	ecx
	push	eax
	lea	edx, DWORD PTR _normal$90178[ebp]
	push	edx
	call	_vec_mat_mul

; 1118 :               tr_mat_mul(&np,&wwp,temp_mat,1,v->freedom,vv->freedom);

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [edi+8]
	mov	edi, DWORD PTR _temp_mat$[ebp]
	push	eax
	push	ecx
	push	1
	push	edi
	lea	edx, DWORD PTR _wwp$90246[ebp]
	push	edx
	lea	eax, DWORD PTR _np$90247[ebp]
	push	eax
	call	_tr_mat_mul

; 1119 :               cfudge = 1.0;

	fld1
	fstp	QWORD PTR _cfudge$90227[ebp]
	add	esp, 44					; 0000002cH

; 1120 :               mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], edi

; 1121 :             }
; 1122 :             else 

	jmp	SHORT $LN62@linear_met@3
$LN67@linear_met@3:

; 1123 :               mat = vv->proj;
; 1124 :           }
; 1125 :           else
; 1126 :           {
; 1127 :             if ( hessian_normal_perp_flag )

	cmp	DWORD PTR _hessian_normal_perp_flag, 0
	je	SHORT $LN63@linear_met@3

; 1128 :             { REAL *np=normal;
; 1129 :               tr_mat_mul(&np,&np,temp_mat,1,v->freedom,vv->freedom);

	mov	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [edi+8]
	mov	edi, DWORD PTR _temp_mat$[ebp]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _normal$90178[ebp]
	push	1
	mov	DWORD PTR _np$90251[ebp], ecx
	lea	ecx, DWORD PTR _np$90251[ebp]
	push	edi
	push	ecx
	mov	edx, ecx
	push	edx
	call	_tr_mat_mul

; 1130 :               cfudge = 1.0;

	fld1
	fstp	QWORD PTR _cfudge$90227[ebp]
	add	esp, 24					; 00000018H

; 1131 :               mat = temp_mat;

	mov	DWORD PTR _mat$[ebp], edi

; 1132 :             }
; 1133 :             else 

	jmp	SHORT $LN62@linear_met@3
$LN63@linear_met@3:

; 1134 :             mat = identmat;

	mov	eax, DWORD PTR _identmat
$LN66@linear_met@3:
	mov	DWORD PTR _mat$[ebp], eax
$LN62@linear_met@3:

; 1135 :           }
; 1136 :           for ( jj = 0 ; jj < v->freedom ; jj++ )  

	mov	ecx, DWORD PTR _v$90202[ebp]
	xor	edi, edi
	mov	DWORD PTR _jj$[ebp], edi
	cmp	DWORD PTR [ecx+8], edi
	jle	$LN77@linear_met@3
	npad	2
$LL61@linear_met@3:

; 1137 :            for ( kk = 0 ; kk < vv->freedom ; kk++ )  

	cmp	DWORD PTR [ebx+8], 0
	mov	DWORD PTR _kk$[ebp], 0
	jle	$LN60@linear_met@3
	npad	12
$LL436@linear_met@3:

; 1138 :            { col = vv->rownum + kk + A_OFF ;

	mov	eax, DWORD PTR _kk$[ebp]
	mov	edx, DWORD PTR [ebx+12]

; 1139 :              end = M->IA[v->rownum+jj+1]-A_OFF;

	mov	ecx, DWORD PTR _v$90202[ebp]
	lea	edx, DWORD PTR [edx+eax+1]
	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [esi+52]
	add	eax, edi
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+4]

; 1140 :              for ( j = M->IA[v->rownum+jj]+1-A_OFF ; (int)j < end ; j++ )

	mov	eax, DWORD PTR [eax]
	dec	ecx
	mov	DWORD PTR _col$[ebp], edx
	cmp	eax, ecx
	jae	$LN557@linear_met@3

; 1138 :            { col = vv->rownum + kk + A_OFF ;

	mov	ebx, DWORD PTR [esi+56]
	lea	ebx, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR tv6070[ebp], ebx
	npad	2
$LL55@linear_met@3:

; 1141 :                if ( (M->JA[j] < A_OFF) || (M->JA[j] == col)  )

	mov	ebx, DWORD PTR tv6070[ebp]
	mov	ebx, DWORD PTR [ebx]
	cmp	ebx, 1
	jl	SHORT $LN345@linear_met@3
	cmp	ebx, edx
	je	SHORT $LN345@linear_met@3

; 1140 :              for ( j = M->IA[v->rownum+jj]+1-A_OFF ; (int)j < end ; j++ )

	add	DWORD PTR tv6070[ebp], 4
	inc	eax
	cmp	eax, ecx
	jb	SHORT $LL55@linear_met@3

; 1156 :      if ( M->JA[i] < A_OFF ) break;

	jmp	SHORT $LN558@linear_met@3
$LN345@linear_met@3:

; 1142 :                { M->JA[j] = col; 

	mov	edx, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [edx+eax*4], ebx

; 1143 :                  M->A[j] += cfudge*mat[jj][kk]*weights[i][k]*area;

	mov	ebx, DWORD PTR _mat$[ebp]
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR _kk$[ebp]
	fld	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR tv6243[ebp]
	fmul	QWORD PTR _cfudge$90227[ebp]
	mov	edi, DWORD PTR [edi]
	mov	ebx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR [esi+60]
	fmul	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR _jj$[ebp]
	lea	edx, DWORD PTR [edx+eax*8]
	fmul	QWORD PTR _area$90164[ebp]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
$LN558@linear_met@3:
	mov	ebx, DWORD PTR _vv$90226[ebp]

; 1144 :                  break;
; 1145 :                }
; 1146 :              if ( j == end )

	cmp	eax, ecx
$LN557@linear_met@3:
	jne	SHORT $LN57@linear_met@3

; 1147 :                kb_error(1854,"Internal error: Bad j in linear_metric_setup().\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DB@HDFPKDEI@Internal?5error?3?5Bad?5j?5in?5linear_@
	push	1854					; 0000073eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN57@linear_met@3:

; 1137 :            for ( kk = 0 ; kk < vv->freedom ; kk++ )  

	mov	eax, DWORD PTR _kk$[ebp]
	inc	eax
	mov	DWORD PTR _kk$[ebp], eax
	cmp	eax, DWORD PTR [ebx+8]
	jl	$LL436@linear_met@3
$LN60@linear_met@3:

; 1135 :           }
; 1136 :           for ( jj = 0 ; jj < v->freedom ; jj++ )  

	mov	eax, DWORD PTR _v$90202[ebp]
	inc	edi
	mov	DWORD PTR _jj$[ebp], edi
	cmp	edi, DWORD PTR [eax+8]
	jl	$LL61@linear_met@3
$LN77@linear_met@3:

; 1082 :           }
; 1083 : 
; 1084 :         /* cross terms */
; 1085 :         for ( k = i+1 ; k <= dim ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _dim$[ebp]
	jle	$LL78@linear_met@3
$LN96@linear_met@3:

; 1049 :       }
; 1050 :       for ( i = 0 ; i <= dim ; i++ )

	add	DWORD PTR tv6200[ebp], 8
	add	DWORD PTR tv6243[ebp], 4
	mov	eax, 1
	add	DWORD PTR tv6198[ebp], eax
	sub	DWORD PTR tv2507[ebp], eax
	jne	$LL460@linear_met@3
$LN114@linear_met@3:

; 1012 :   { facet_id f_id;
; 1013 :     REAL area;
; 1014 : 
; 1015 :     /* facet by facet */
; 1016 :     FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR tv4014[ebp]
	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ecx+edx]
	mov	edi, DWORD PTR [eax]
	mov	ebx, edi
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	jne	$LL115@linear_met@3
$LN113@linear_met@3:

; 1148 :            }
; 1149 :          }
; 1150 :        }
; 1151 :      }
; 1152 :   }
; 1153 : 
; 1154 :   /* compact matrix by looking for -1 in M->JA */
; 1155 :   for ( i = 0 ; i < M->IA[M->N]-A_OFF ; i++ )

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	dec	ecx
	xor	eax, eax
	mov	DWORD PTR tv4274[ebp], ecx
	test	ecx, ecx
	jle	SHORT $LN437@linear_met@3
	mov	ecx, DWORD PTR [esi+56]
	npad	6
$LL482@linear_met@3:

; 1156 :      if ( M->JA[i] < A_OFF ) break;

	cmp	DWORD PTR [ecx], 1
	jl	SHORT $LN437@linear_met@3

; 1148 :            }
; 1149 :          }
; 1150 :        }
; 1151 :      }
; 1152 :   }
; 1153 : 
; 1154 :   /* compact matrix by looking for -1 in M->JA */
; 1155 :   for ( i = 0 ; i < M->IA[M->N]-A_OFF ; i++ )

	mov	edx, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [edi+edx*4]
	inc	eax
	dec	edx
	add	ecx, 4
	cmp	eax, edx
	jl	SHORT $LL482@linear_met@3
$LN437@linear_met@3:

; 1157 :   if ( i < M->IA[M->N]-A_OFF )

	cmp	eax, DWORD PTR tv4274[ebp]
	jge	$LN469@linear_met@3

; 1159 :     REAL *a_to_spot= M->A,*a_from_spot= M->A;

	mov	ecx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [esi+56]

; 1160 :     for ( i = 0 ; i < M->N ; i++ )

	xor	edi, edi
	mov	edx, ecx
	mov	DWORD PTR _ja_from_spot$90273[ebp], eax
	mov	DWORD PTR _a_from_spot$90275[ebp], edx
	mov	DWORD PTR _i$[ebp], edi
	test	ebx, ebx
	jle	$LN469@linear_met@3
	jmp	SHORT $LN44@linear_met@3
	npad	7
$LL452@linear_met@3:
	mov	edx, DWORD PTR _a_from_spot$90275[ebp]
$LN44@linear_met@3:

; 1161 :     { end = M->IA[i+1]-A_OFF;

	mov	ebx, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR [ebx+edi*4+4]

; 1162 :       for ( j = ja_from_spot - M->JA ; (int)j < end ; j++,ja_from_spot++,a_from_spot++ )

	mov	edi, DWORD PTR _ja_from_spot$90273[ebp]
	sub	edi, DWORD PTR [esi+56]
	dec	ebx
	sar	edi, 2
	mov	DWORD PTR _end$[ebp], ebx
	mov	DWORD PTR tv4291[ebp], edi
	mov	DWORD PTR _j$[ebp], edi
	cmp	edi, ebx
	jae	$LN457@linear_met@3
	sub	ebx, edi
	cmp	ebx, 4
	jl	$LN456@linear_met@3

; 1163 :       { if ( *ja_from_spot >= A_OFF )

	mov	ebx, DWORD PTR _end$[ebp]
	sub	ebx, edi
	sub	ebx, 4
	shr	ebx, 2
	inc	ebx
	lea	edi, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR _j$[ebp], edi
	npad	9
$LL419@linear_met@3:
	mov	edi, DWORD PTR _ja_from_spot$90273[ebp]
	mov	edi, DWORD PTR [edi]
	cmp	edi, 1
	jl	SHORT $LN415@linear_met@3

; 1164 :         { *ja_to_spot = *ja_from_spot;

	mov	DWORD PTR [eax], edi

; 1165 :           *a_to_spot  = *a_from_spot;

	fld	QWORD PTR [edx]
	fstp	QWORD PTR [ecx]

; 1166 :           a_to_spot++; ja_to_spot++;

	add	ecx, 8
	add	eax, 4
$LN415@linear_met@3:

; 1163 :       { if ( *ja_from_spot >= A_OFF )

	mov	edi, DWORD PTR _ja_from_spot$90273[ebp]
	mov	edi, DWORD PTR [edi+4]
	cmp	edi, 1
	jl	SHORT $LN416@linear_met@3

; 1164 :         { *ja_to_spot = *ja_from_spot;

	mov	DWORD PTR [eax], edi

; 1165 :           *a_to_spot  = *a_from_spot;

	fld	QWORD PTR [edx+8]
	fstp	QWORD PTR [ecx]

; 1166 :           a_to_spot++; ja_to_spot++;

	add	ecx, 8
	add	eax, 4
$LN416@linear_met@3:

; 1163 :       { if ( *ja_from_spot >= A_OFF )

	mov	edi, DWORD PTR _ja_from_spot$90273[ebp]
	mov	edi, DWORD PTR [edi+8]
	cmp	edi, 1
	jl	SHORT $LN417@linear_met@3

; 1164 :         { *ja_to_spot = *ja_from_spot;

	mov	DWORD PTR [eax], edi

; 1165 :           *a_to_spot  = *a_from_spot;

	fld	QWORD PTR [edx+16]
	fstp	QWORD PTR [ecx]

; 1166 :           a_to_spot++; ja_to_spot++;

	add	ecx, 8
	add	eax, 4
$LN417@linear_met@3:

; 1163 :       { if ( *ja_from_spot >= A_OFF )

	mov	edi, DWORD PTR _ja_from_spot$90273[ebp]
	mov	edi, DWORD PTR [edi+12]
	cmp	edi, 1
	jl	SHORT $LN418@linear_met@3

; 1164 :         { *ja_to_spot = *ja_from_spot;

	mov	DWORD PTR [eax], edi

; 1165 :           *a_to_spot  = *a_from_spot;

	fld	QWORD PTR [edx+24]
	fstp	QWORD PTR [ecx]

; 1166 :           a_to_spot++; ja_to_spot++;

	add	ecx, 8
	add	eax, 4
$LN418@linear_met@3:

; 1163 :       { if ( *ja_from_spot >= A_OFF )

	add	DWORD PTR _ja_from_spot$90273[ebp], 16	; 00000010H
	add	edx, 32					; 00000020H
	dec	ebx
	jne	SHORT $LL419@linear_met@3

; 1158 :   { int *ja_to_spot = M->JA,*ja_from_spot = M->JA;

	mov	DWORD PTR _a_from_spot$90275[ebp], edx
$LN456@linear_met@3:

; 1162 :       for ( j = ja_from_spot - M->JA ; (int)j < end ; j++,ja_from_spot++,a_from_spot++ )

	mov	edi, DWORD PTR _end$[ebp]
	mov	ebx, DWORD PTR _j$[ebp]
	cmp	ebx, edi
	jae	SHORT $LN457@linear_met@3
	sub	edi, ebx
	mov	ebx, DWORD PTR _ja_from_spot$90273[ebp]
	mov	DWORD PTR tv2319[ebp], edi
	npad	5
$LC41@linear_met@3:

; 1163 :       { if ( *ja_from_spot >= A_OFF )

	mov	edi, DWORD PTR [ebx]
	cmp	edi, 1
	jl	SHORT $LN40@linear_met@3

; 1164 :         { *ja_to_spot = *ja_from_spot;

	mov	DWORD PTR [eax], edi

; 1165 :           *a_to_spot  = *a_from_spot;

	fld	QWORD PTR [edx]
	fstp	QWORD PTR [ecx]

; 1166 :           a_to_spot++; ja_to_spot++;

	add	ecx, 8
	add	eax, 4
$LN40@linear_met@3:

; 1162 :       for ( j = ja_from_spot - M->JA ; (int)j < end ; j++,ja_from_spot++,a_from_spot++ )

	add	ebx, 4
	add	edx, 8
	dec	DWORD PTR tv2319[ebp]
	jne	SHORT $LC41@linear_met@3
	mov	DWORD PTR _a_from_spot$90275[ebp], edx
	mov	DWORD PTR _ja_from_spot$90273[ebp], ebx
$LN457@linear_met@3:

; 1167 :         }
; 1168 :       }
; 1169 :       M->IA[i+1] = (int)(ja_to_spot - M->JA + A_OFF);

	mov	edi, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR [esi+52]
	mov	edx, eax
	sub	edx, DWORD PTR [esi+56]
	inc	edi
	sar	edx, 2
	inc	edx
	mov	DWORD PTR [ebx+edi*4], edx
	mov	DWORD PTR _i$[ebp], edi
	cmp	edi, DWORD PTR [esi+4]
	jl	$LL452@linear_met@3
$LN469@linear_met@3:

; 1170 :     }
; 1171 :   }
; 1172 : 
; 1173 :   // Sort within rows to get columns in increasing order.  Just bubble sort.
; 1174 :   for ( i = 0 ; i < M->N ; i++ )

	cmp	DWORD PTR [esi+4], 0
	mov	DWORD PTR _i$[ebp], 0
	jle	$apinv_setup$89946
	npad	10
$LL453@linear_met@3:
	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR _i$[ebp]

; 1175 :   { int start = M->IA[i] - A_OFF + 1;
; 1176 :     size_t k;
; 1177 :     end = M->IA[i+1] - A_OFF;

	mov	ebx, DWORD PTR [eax+ecx*4+4]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [ecx]
	dec	ebx
	mov	DWORD PTR _end$[ebp], ebx

; 1178 :     for ( j = start ; j < end ; j++ )

	cmp	eax, ebx
	jae	$LN36@linear_met@3

; 1170 :     }
; 1171 :   }
; 1172 : 
; 1173 :   // Sort within rows to get columns in increasing order.  Just bubble sort.
; 1174 :   for ( i = 0 ; i < M->N ; i++ )

	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR tv4334[ebp], edx
	npad	6
$LL34@linear_met@3:

; 1179 :       for ( k = start+1 ; k < end ; k++ )

	mov	ecx, DWORD PTR tv4334[ebp]
	cmp	ecx, ebx
	jae	$LN33@linear_met@3
	mov	edx, ebx
	sub	edx, ecx
	cmp	edx, 4
	jl	$LC421@linear_met@3
	npad	5
$LL426@linear_met@3:

; 1180 :         if ( M->JA[k] < M->JA[j] )

	mov	edx, DWORD PTR [esi+56]
	mov	edi, DWORD PTR [edx+eax*4]
	mov	ebx, DWORD PTR [edx+ecx*4]
	cmp	ebx, edi
	jge	SHORT $LN422@linear_met@3

; 1184 :           M->JA[j] = M->JA[k];

	mov	DWORD PTR [edx+eax*4], ebx

; 1185 :           M->JA[k] = tmp;

	mov	edx, DWORD PTR [esi+56]
	mov	DWORD PTR [edx+ecx*4], edi

; 1186 :           rtmp = M->A[j];

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8]

; 1187 :           M->A[j] = M->A[k];

	fld	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+eax*8]

; 1188 :           M->A[k] = rtmp;

	mov	edx, DWORD PTR [esi+60]
	fstp	QWORD PTR [edx+ecx*8]
$LN422@linear_met@3:

; 1180 :         if ( M->JA[k] < M->JA[j] )

	mov	edx, DWORD PTR [esi+56]
	mov	edi, DWORD PTR [edx+eax*4]
	mov	ebx, DWORD PTR [edx+ecx*4+4]
	cmp	ebx, edi
	jge	SHORT $LN423@linear_met@3

; 1184 :           M->JA[j] = M->JA[k];

	mov	DWORD PTR [edx+eax*4], ebx

; 1185 :           M->JA[k] = tmp;

	mov	edx, DWORD PTR [esi+56]
	mov	DWORD PTR [edx+ecx*4+4], edi

; 1186 :           rtmp = M->A[j];

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8]

; 1187 :           M->A[j] = M->A[k];

	fld	QWORD PTR [edx+ecx*8+8]
	fstp	QWORD PTR [edx+eax*8]

; 1188 :           M->A[k] = rtmp;

	mov	edx, DWORD PTR [esi+60]
	fstp	QWORD PTR [edx+ecx*8+8]
$LN423@linear_met@3:

; 1180 :         if ( M->JA[k] < M->JA[j] )

	mov	edx, DWORD PTR [esi+56]
	mov	edi, DWORD PTR [edx+ecx*4+8]
	mov	ebx, DWORD PTR [edx+eax*4]
	cmp	edi, ebx
	jge	SHORT $LN450@linear_met@3

; 1184 :           M->JA[j] = M->JA[k];

	mov	DWORD PTR [edx+eax*4], edi

; 1185 :           M->JA[k] = tmp;

	mov	edx, DWORD PTR [esi+56]
	mov	DWORD PTR [edx+ecx*4+8], ebx

; 1186 :           rtmp = M->A[j];

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8]

; 1187 :           M->A[j] = M->A[k];

	fld	QWORD PTR [edx+ecx*8+16]
	fstp	QWORD PTR [edx+eax*8]

; 1188 :           M->A[k] = rtmp;

	mov	edx, DWORD PTR [esi+60]
	fstp	QWORD PTR [edx+ecx*8+16]
$LN450@linear_met@3:

; 1180 :         if ( M->JA[k] < M->JA[j] )

	mov	edx, DWORD PTR [esi+56]
	mov	edi, DWORD PTR [edx+ecx*4+12]
	mov	ebx, DWORD PTR [edx+eax*4]
	cmp	edi, ebx
	jge	SHORT $LN451@linear_met@3

; 1184 :           M->JA[j] = M->JA[k];

	mov	DWORD PTR [edx+eax*4], edi

; 1185 :           M->JA[k] = tmp;

	mov	edx, DWORD PTR [esi+56]
	mov	DWORD PTR [edx+ecx*4+12], ebx

; 1186 :           rtmp = M->A[j];

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8]

; 1187 :           M->A[j] = M->A[k];

	fld	QWORD PTR [edx+ecx*8+24]
	fstp	QWORD PTR [edx+eax*8]

; 1188 :           M->A[k] = rtmp;

	mov	edx, DWORD PTR [esi+60]
	fstp	QWORD PTR [edx+ecx*8+24]
$LN451@linear_met@3:
	mov	ebx, DWORD PTR _end$[ebp]
	add	ecx, 4
	lea	edx, DWORD PTR [ebx-3]
	cmp	ecx, edx
	jb	$LL426@linear_met@3
$LC421@linear_met@3:

; 1179 :       for ( k = start+1 ; k < end ; k++ )

	cmp	ecx, ebx
	jae	SHORT $LN33@linear_met@3
$LC31@linear_met@3:

; 1180 :         if ( M->JA[k] < M->JA[j] )

	mov	edx, DWORD PTR [esi+56]
	mov	edi, DWORD PTR [edx+ecx*4]
	cmp	edi, DWORD PTR [edx+eax*4]
	jge	SHORT $LN30@linear_met@3

; 1181 :         { int tmp;
; 1182 :           REAL rtmp;
; 1183 :           tmp = M->JA[j];

	mov	ebx, DWORD PTR [edx+eax*4]

; 1184 :           M->JA[j] = M->JA[k];

	mov	DWORD PTR [edx+eax*4], edi

; 1185 :           M->JA[k] = tmp;

	mov	edx, DWORD PTR [esi+56]
	mov	DWORD PTR [edx+ecx*4], ebx

; 1186 :           rtmp = M->A[j];

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8]

; 1188 :           M->A[k] = rtmp;

	mov	ebx, DWORD PTR _end$[ebp]
	fld	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [esi+60]
	fstp	QWORD PTR [edx+ecx*8]
$LN30@linear_met@3:

; 1179 :       for ( k = start+1 ; k < end ; k++ )

	inc	ecx
	cmp	ecx, ebx
	jb	SHORT $LC31@linear_met@3
$LN33@linear_met@3:

; 1178 :     for ( j = start ; j < end ; j++ )

	inc	eax
	cmp	eax, ebx
	jb	$LL34@linear_met@3
$LN36@linear_met@3:

; 1170 :     }
; 1171 :   }
; 1172 : 
; 1173 :   // Sort within rows to get columns in increasing order.  Just bubble sort.
; 1174 :   for ( i = 0 ; i < M->N ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [esi+4]
	jl	$LL453@linear_met@3
$apinv_setup$89946:

; 1189 :         }
; 1190 :   }
; 1191 : 
; 1192 : apinv_setup:
; 1193 :   /* approximate inverse, as diagonal inverse sum of row */
; 1194 :   M->apinv = (REAL *)temp_calloc(M->N,sizeof(REAL));

	mov	eax, DWORD PTR [esi+4]
	push	1194					; 000004aaH
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc

; 1195 :   /* sums of rows */
; 1196 :   for ( i = 0 ; i < M->N ; i++ )

	xor	ecx, ecx
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+200], eax
	cmp	DWORD PTR [esi+4], ecx
	jle	$LN438@linear_met@3
$LL27@linear_met@3:
	mov	edx, DWORD PTR [esi+52]

; 1197 :   { int start = M->IA[i] - A_OFF;

	mov	eax, DWORD PTR [edx+ecx*4]

; 1198 :     end = M->IA[i+1] - A_OFF;

	mov	edi, DWORD PTR [edx+ecx*4+4]

; 1199 :     M->apinv[i] += M->A[start];

	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-8]
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [esi+200]
	fadd	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	dec	edi
	fstp	QWORD PTR [edx]
	cmp	eax, edi
	jae	$LN26@linear_met@3

; 1200 :     for ( j = start+1 ; (int)j < end ; j++ )

	mov	edx, edi
	sub	edx, eax
	cmp	edx, 4
	jl	$LN467@linear_met@3
	npad	8
$LL429@linear_met@3:

; 1201 :     { M->apinv[i] += M->A[j];

	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8]
	mov	edx, DWORD PTR [esi+200]
	fadd	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]

; 1202 :       M->apinv[M->JA[j]-A_OFF] += M->A[j];

	add	eax, 4
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-16]
	mov	ebx, DWORD PTR [esi+200]
	lea	edx, DWORD PTR [ebx+edx*8-8]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-32]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-24]
	mov	edx, DWORD PTR [esi+200]
	fadd	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-12]
	mov	ebx, DWORD PTR [esi+200]
	lea	edx, DWORD PTR [ebx+edx*8-8]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-24]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-16]
	mov	edx, DWORD PTR [esi+200]
	fadd	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-8]
	mov	ebx, DWORD PTR [esi+200]
	lea	edx, DWORD PTR [ebx+edx*8-8]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-16]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-8]
	mov	edx, DWORD PTR [esi+200]
	fadd	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-4]
	mov	ebx, DWORD PTR [esi+200]
	lea	edx, DWORD PTR [ebx+edx*8-8]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	lea	edx, DWORD PTR [edi-3]
	cmp	eax, edx
	jb	$LL429@linear_met@3
$LN467@linear_met@3:

; 1200 :     for ( j = start+1 ; (int)j < end ; j++ )

	cmp	eax, edi
	jae	SHORT $LN26@linear_met@3
	npad	11
$LC24@linear_met@3:

; 1201 :     { M->apinv[i] += M->A[j];

	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8]
	mov	edx, DWORD PTR [esi+200]
	fadd	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	inc	eax
	fstp	QWORD PTR [edx]

; 1202 :       M->apinv[M->JA[j]-A_OFF] += M->A[j];

	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-4]
	mov	ebx, DWORD PTR [esi+200]
	lea	edx, DWORD PTR [ebx+edx*8-8]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	cmp	eax, edi
	jb	SHORT $LC24@linear_met@3
$LN26@linear_met@3:

; 1195 :   /* sums of rows */
; 1196 :   for ( i = 0 ; i < M->N ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR [esi+4]
	jl	$LL27@linear_met@3
$LN438@linear_met@3:

; 1203 :     }
; 1204 :   }
; 1205 :   for ( i = 0 ; i < M->N ; i++ ) 

	xor	ecx, ecx
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN19@linear_met@3
	fldz
	fld1
$LN21@linear_met@3:
	mov	eax, DWORD PTR [esi+200]

; 1206 :      M->apinv[i] = (M->apinv[i]==0.0) ? 0.0 : 1/M->apinv[i];

	fld	QWORD PTR [eax+ecx*8]
	lea	edx, DWORD PTR [eax+ecx*8]
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN244@linear_met@3
	fld	ST(1)
	jmp	SHORT $LN245@linear_met@3
$LN244@linear_met@3:
	fld	ST(0)
	fdiv	QWORD PTR [edx]
$LN245@linear_met@3:
	inc	ecx
	fstp	QWORD PTR [edx]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LN21@linear_met@3

; 1203 :     }
; 1204 :   }
; 1205 :   for ( i = 0 ; i < M->N ; i++ ) 

	fstp	ST(1)
	fstp	ST(0)
$LN19@linear_met@3:

; 1207 : 
; 1208 : if ( hess_debug) 

	cmp	DWORD PTR _hess_debug, 0
	je	$LN18@linear_met@3

; 1209 : { printf("Metric matrix:\n");

	push	OFFSET ??_C@_0BA@FJCICACH@Metric?5matrix?3?6?$AA@
	call	_printf

; 1210 :   printf("IA: ");

	push	OFFSET ??_C@_04PDOOEJGG@IA?3?5?$AA@
	call	_printf

; 1211 :   for ( i = 0 ; i <= M->N ; i++ ) printf("%d ",M->IA[i]);

	xor	edi, edi
	add	esp, 8
	cmp	DWORD PTR [esi+4], edi
	jl	SHORT $LN15@linear_met@3
$LL17@linear_met@3:
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+edi*4]
	push	edx
	push	OFFSET ??_C@_03JDANDILB@?$CFd?5?$AA@
	call	_printf
	inc	edi
	add	esp, 8
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LL17@linear_met@3
$LN15@linear_met@3:

; 1212 :   printf("\nJA: ");

	push	OFFSET ??_C@_05GCDFEGGO@?6JA?3?5?$AA@
	call	_printf

; 1213 :   for ( i = 0 ; i < M->IA[M->N]-A_OFF ; i++ ) printf("%d ",M->JA[i]);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+eax*4]
	dec	edx
	add	esp, 4
	xor	edi, edi
	test	edx, edx
	jle	SHORT $LN12@linear_met@3
$LL14@linear_met@3:
	mov	eax, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR [eax+edi*4]
	push	ecx
	push	OFFSET ??_C@_03JDANDILB@?$CFd?5?$AA@
	call	_printf
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [eax+edx*4]
	inc	edi
	dec	ecx
	add	esp, 8
	cmp	edi, ecx
	jl	SHORT $LL14@linear_met@3
$LN12@linear_met@3:

; 1214 :   printf("\nA: \n");

	push	OFFSET ??_C@_05NHABLKGM@?6A?3?5?6?$AA@
	call	_printf

; 1215 :   for ( i = 0 ; i < M->N ; i++ )

	xor	ebx, ebx
	add	esp, 4
	cmp	DWORD PTR [esi+4], ebx
	jle	$LN9@linear_met@3
$LL472@linear_met@3:

; 1216 :   { int k,m;
; 1217 :     for ( m = 0 ; m < i ; m++ ) printf("          ");

	test	ebx, ebx
	jle	SHORT $LN6@linear_met@3
	mov	edi, ebx
	npad	8
$LL8@linear_met@3:
	push	OFFSET ??_C@_0L@CCBFPMDD@?5?5?5?5?5?5?5?5?5?5?$AA@
	call	_printf
	add	esp, 4
	dec	edi
	jne	SHORT $LL8@linear_met@3
$LN6@linear_met@3:

; 1218 :     for ( m = i,  k = M->IA[i]-A_OFF ; m < M->N ; m++ )

	mov	edx, DWORD PTR [esi+52]
	mov	edi, DWORD PTR [edx+ebx*4]
	mov	eax, ebx
	dec	edi
	mov	DWORD PTR _m$90328[ebp], eax
	cmp	ebx, DWORD PTR [esi+4]
	jge	SHORT $LN3@linear_met@3
$LL5@linear_met@3:

; 1219 :       if ( (m == M->JA[k]-A_OFF) && (k < M->IA[i+1]-A_OFF) )

	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [ecx+edi*4]
	dec	edx
	cmp	eax, edx
	jne	SHORT $LN2@linear_met@3
	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [eax+ebx*4+4]
	dec	ecx
	cmp	edi, ecx
	jge	SHORT $LN2@linear_met@3

; 1220 :         { printf(" %9.6f",(DOUBLE)M->A[k]); k++; }

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+edi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_06FNCNKGB@?5?$CF9?46f?$AA@
	call	_printf
	add	esp, 12					; 0000000cH
	inc	edi
	jmp	SHORT $LN4@linear_met@3
$LN2@linear_met@3:

; 1221 :       else printf(" %9.6f",0.0);

	fldz
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_06FNCNKGB@?5?$CF9?46f?$AA@
	call	_printf
	add	esp, 12					; 0000000cH
$LN4@linear_met@3:

; 1218 :     for ( m = i,  k = M->IA[i]-A_OFF ; m < M->N ; m++ )

	mov	eax, DWORD PTR _m$90328[ebp]
	inc	eax
	mov	DWORD PTR _m$90328[ebp], eax
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL5@linear_met@3
$LN3@linear_met@3:

; 1222 :     printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	inc	ebx
	add	esp, 4
	cmp	ebx, DWORD PTR [esi+4]
	jl	$LL472@linear_met@3
$LN9@linear_met@3:

; 1223 :   }
; 1224 :   printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	add	esp, 4
$LN18@linear_met@3:

; 1225 : }
; 1226 : 
; 1227 : } /* end linear_metric_setup() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_linear_metric_setup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DJ@MBIPLGGC@Using?5alternate?5minimal?5degree?5w@ ; `string'
PUBLIC	_star_metric_setup
EXTRN	_star_fraction:QWORD
EXTRN	_get_vertex_area_star:PROC
EXTRN	_get_vertex_length_star:PROC
;	COMDAT ??_C@_0DJ@MBIPLGGC@Using?5alternate?5minimal?5degree?5w@
CONST	SEGMENT
??_C@_0DJ@MBIPLGGC@Using?5alternate?5minimal?5degree?5w@ DB 'Using altern'
	DB	'ate minimal degree with area normalization.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _star_metric_setup
_TEXT	SEGMENT
_j$ = -4						; size = 4
_S$ = 8							; size = 4
_M$ = 12						; size = 4
_star_metric_setup PROC					; COMDAT

; 698  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 699  :   int i,j,k;
; 700  :   int  Total_entries = 0;
; 701  :   struct hess_verlist *vh;
; 702  :   vertex_id v_id;
; 703  : 
; 704  :   if ( web.lagrange_order > 1 ) { linear_metric_setup(S,M); return; }

	cmp	DWORD PTR _web+632, 1
	jle	SHORT $LN28@star_metri
	mov	eax, DWORD PTR _M$[ebp]
	mov	ecx, DWORD PTR _S$[ebp]
	push	eax
	push	ecx
	call	_linear_metric_setup
	add	esp, 8

; 778  : } /* end star_metric_setup() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@star_metri:

; 705  : 
; 706  :   if ( ysmp_flag != MINDEG_FACTORING )

	xor	eax, eax
	cmp	DWORD PTR _ysmp_flag, eax
	je	SHORT $LN27@star_metri

; 707  :   { ysmp_flag = MINDEG_FACTORING;
; 708  :     sp_mul_func = bk_mul;
; 709  :     sp_AIJ_setup_func = bk_AIJ_setup;
; 710  :     sp_constraint_setup_func = bk_constraint_setup;
; 711  :     sp_hess_project_setup_func= BK_hess_project_setup;
; 712  :     sp_factor_func = xmd_factor;
; 713  :     sp_solve_func = xmd_solve;
; 714  :     sp_solve_multi_func = xmd_solve_multi;
; 715  :     sp_ordering_func = NULL;
; 716  :     sp_CHinvC_func = sp_CHinvC;
; 717  :     outstring("Using alternate minimal degree with area normalization.\n");

	push	OFFSET ??_C@_0DJ@MBIPLGGC@Using?5alternate?5minimal?5degree?5w@
	mov	DWORD PTR _ysmp_flag, eax
	mov	DWORD PTR _sp_mul_func, OFFSET _bk_mul
	mov	DWORD PTR _sp_AIJ_setup_func, OFFSET _bk_AIJ_setup
	mov	DWORD PTR _sp_constraint_setup_func, OFFSET _bk_constraint_setup
	mov	DWORD PTR _sp_hess_project_setup_func, OFFSET _BK_hess_project_setup
	mov	DWORD PTR _sp_factor_func, OFFSET _xmd_factor
	mov	DWORD PTR _sp_solve_func, OFFSET _xmd_solve
	mov	DWORD PTR _sp_solve_multi_func, OFFSET _xmd_solve_multi
	mov	DWORD PTR _sp_ordering_func, eax
	mov	DWORD PTR _sp_CHinvC_func, OFFSET _sp_CHinvC
	call	_outstring
	add	esp, 4
$LN27@star_metri:

; 718  :   }
; 719  :   M->N = S->N;

	push	ebx
	push	esi
	mov	esi, DWORD PTR _M$[ebp]
	push	edi
	mov	edi, DWORD PTR _S$[ebp]
	mov	edx, DWORD PTR [edi+4]

; 720  :   M->flags &= ~ S_ODRV_REORDERED; 

	and	DWORD PTR [esi], -17			; ffffffefH

; 721  : 
; 722  :   Total_entries = S->N;  /* pure diagonal */
; 723  : 
; 724  :   /* allocate storage for arrays */
; 725  :   M->IA = (int *)temp_calloc(M->N+1,sizeof(int));

	push	725					; 000002d5H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	lea	eax, DWORD PTR [edx+1]
	push	4
	mov	DWORD PTR [esi+4], edx
	mov	ebx, DWORD PTR [edi+4]
	push	eax
	call	_kb_temp_calloc

; 726  :   M->JA = (int *)temp_calloc(Total_entries,sizeof(int));

	push	726					; 000002d6H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	4
	push	ebx
	mov	DWORD PTR [esi+52], eax
	call	_kb_temp_calloc

; 727  :   M->A  = (REAL *)temp_calloc(Total_entries,sizeof(REAL));

	push	727					; 000002d7H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	8
	push	ebx
	mov	DWORD PTR [esi+56], eax
	call	_kb_temp_calloc
	add	esp, 48					; 00000030H

; 728  :   if ( M->P == NULL ) M->P = (int *)temp_calloc(M->N,sizeof(int));

	cmp	DWORD PTR [esi+68], 0
	mov	DWORD PTR [esi+60], eax
	jne	SHORT $LN57@star_metri
	mov	ecx, DWORD PTR [esi+4]
	push	728					; 000002d8H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	4
	push	ecx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+68], eax
$LN57@star_metri:

; 729  :   if ( M->IP == NULL ) M->IP = (int *)temp_calloc(M->N,sizeof(int));

	cmp	DWORD PTR [esi+72], 0
	jne	SHORT $LN25@star_metri
	mov	edx, DWORD PTR [esi+4]
	push	729					; 000002d9H
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	push	4
	push	edx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+72], eax
$LN25@star_metri:

; 730  : 
; 731  :   /* go through, vertex by vertex */
; 732  :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	test	edx, 268435456				; 10000000H
	je	$LN22@star_metri
$LL56@star_metri:
	mov	eax, DWORD PTR _web+12
	mov	ebx, edx
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN23@star_metri

; 733  :   { 
; 734  :     REAL area;
; 735  :     vh = get_vertex_vhead(v_id);

	mov	eax, DWORD PTR _vhead_attr
	mov	edi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edi+64]
	mov	edi, DWORD PTR [ecx+eax]
	shl	edi, 5
	add	edi, DWORD PTR _vhead

; 736  : 
; 737  :     if ( vh->freedom == 0 ) continue;

	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN23@star_metri

; 738  : 
; 739  :     area = ((web.representation==STRING)?get_vertex_length_star(v_id):
; 740  :                                     get_vertex_area_star(v_id))/star_fraction;

	cmp	DWORD PTR _web+624, 1
	push	edx
	jne	SHORT $LN31@star_metri
	call	_get_vertex_length_star
	jmp	SHORT $LN82@star_metri
$LN31@star_metri:
	call	_get_vertex_area_star
$LN82@star_metri:
	fdiv	QWORD PTR _star_fraction

; 741  : 
; 742  :     for ( j = 0, k = vh->rownum  ; j < vh->freedom ; j++,k++ )

	mov	eax, DWORD PTR [edi+12]
	add	esp, 4
	cmp	DWORD PTR [edi+8], 0
	mov	DWORD PTR _j$[ebp], 0
	jle	SHORT $LN64@star_metri

; 738  : 
; 739  :     area = ((web.representation==STRING)?get_vertex_length_star(v_id):
; 740  :                                     get_vertex_area_star(v_id))/star_fraction;

	lea	ecx, DWORD PTR [eax+1]
$LN18@star_metri:

; 743  :     { M->IA[k] = M->JA[k] = k + A_OFF;

	mov	edx, DWORD PTR [esi+56]
	mov	DWORD PTR [edx+eax*4], ecx
	mov	edx, DWORD PTR [esi+52]
	mov	DWORD PTR [edx+eax*4], ecx

; 744  :       M->A[k] = area;

	mov	edx, DWORD PTR [esi+60]
	fst	QWORD PTR [edx+eax*8]

; 745  :       M->IP[k] = M->P[k] = k;    /* unpermuted */

	mov	edx, DWORD PTR [esi+68]
	mov	DWORD PTR [edx+eax*4], eax
	mov	edx, DWORD PTR [esi+72]
	mov	DWORD PTR [edx+eax*4], eax
	mov	edx, DWORD PTR _j$[ebp]
	inc	edx
	inc	eax
	inc	ecx
	mov	DWORD PTR _j$[ebp], edx
	cmp	edx, DWORD PTR [edi+8]
	jl	SHORT $LN18@star_metri
$LN64@star_metri:

; 741  : 
; 742  :     for ( j = 0, k = vh->rownum  ; j < vh->freedom ; j++,k++ )

	fstp	ST(0)
$LN23@star_metri:

; 730  : 
; 731  :   /* go through, vertex by vertex */
; 732  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ebx+eax]
	mov	edx, DWORD PTR [ecx]
	test	edx, 268435456				; 10000000H
	jne	$LL56@star_metri
	mov	edi, DWORD PTR _S$[ebp]
$LN22@star_metri:

; 746  :     }
; 747  :   }
; 748  : 
; 749  :   for ( i = S->optparamrowstart ; i < S->bodyrowstart ; i++ )

	mov	eax, DWORD PTR [edi+16]
	fld1
	cmp	eax, DWORD PTR [edi+20]
	jge	SHORT $LN69@star_metri
	lea	ecx, DWORD PTR [eax+1]
$LN15@star_metri:

; 750  :   { /* metric 1 for optimizing parameters */
; 751  :     M->IA[i] = M->JA[i] = i + A_OFF;

	mov	edx, DWORD PTR [esi+56]
	mov	DWORD PTR [edx+eax*4], ecx
	mov	edx, DWORD PTR [esi+52]
	mov	DWORD PTR [edx+eax*4], ecx

; 752  :     M->A[i] = 1.0;

	mov	edx, DWORD PTR [esi+60]
	fst	QWORD PTR [edx+eax*8]

; 753  :     M->IP[i] = M->P[i] = i;    /* unpermuted */

	mov	edx, DWORD PTR [esi+68]
	mov	DWORD PTR [edx+eax*4], eax
	mov	edx, DWORD PTR [esi+72]
	mov	DWORD PTR [edx+eax*4], eax
	inc	eax
	inc	ecx
	cmp	eax, DWORD PTR [edi+20]
	jl	SHORT $LN15@star_metri
$LN69@star_metri:

; 754  :   }
; 755  :   for ( i = S->bodyrowstart ; i < S->N ; i++ )

	mov	eax, DWORD PTR [edi+20]
	fstp	ST(0)
	fldz
	cmp	eax, DWORD PTR [edi+4]
	jge	SHORT $LN74@star_metri
	lea	ecx, DWORD PTR [eax+1]
$LN12@star_metri:

; 756  :   { /* make sure rest of diagonal exists, but no shift */
; 757  :     M->IA[i] = M->JA[i] = i + A_OFF;

	mov	edx, DWORD PTR [esi+56]
	mov	DWORD PTR [edx+eax*4], ecx
	mov	edx, DWORD PTR [esi+52]
	mov	DWORD PTR [edx+eax*4], ecx

; 758  :     M->A[i] = 0.0;

	mov	edx, DWORD PTR [esi+60]
	fst	QWORD PTR [edx+eax*8]

; 759  :     M->IP[i] = M->P[i] = i;    /* unpermuted */

	mov	edx, DWORD PTR [esi+68]
	mov	DWORD PTR [edx+eax*4], eax
	mov	edx, DWORD PTR [esi+72]
	mov	DWORD PTR [edx+eax*4], eax
	inc	eax
	inc	ecx
	cmp	eax, DWORD PTR [edi+4]
	jl	SHORT $LN12@star_metri
$LN74@star_metri:

; 760  :   }
; 761  : 
; 762  : 
; 763  :   M->IA[M->N] = M->N + A_OFF;

	mov	eax, DWORD PTR [esi+4]
	fstp	ST(0)
	mov	edx, DWORD PTR [esi+52]

; 764  : 
; 765  :   M->apinv = (REAL *)temp_calloc(M->N,sizeof(REAL));

	push	765					; 000002fdH
	lea	ecx, DWORD PTR [eax+1]
	push	OFFSET ??_C@_0L@OJFLNMOD@HESSIAN3?4C?$AA@
	mov	DWORD PTR [edx+eax*4], ecx
	mov	eax, DWORD PTR [esi+4]
	push	8
	push	eax
	call	_kb_temp_calloc

; 766  :   /* sums of rows */
; 767  :   for ( i = 0 ; i < M->N ; i++ )

	xor	ecx, ecx
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+200], eax
	cmp	DWORD PTR [esi+4], ecx
	jle	$LN7@star_metri
	npad	9
$LL55@star_metri:
	mov	edx, DWORD PTR [esi+52]

; 768  :   { int start = M->IA[i] - A_OFF;

	mov	eax, DWORD PTR [edx+ecx*4]

; 769  :     int end = M->IA[i+1] - A_OFF;

	mov	edi, DWORD PTR [edx+ecx*4+4]

; 770  :     M->apinv[i] = M->A[start];

	mov	ebx, DWORD PTR [esi+200]
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8-8]
	dec	edi
	fstp	QWORD PTR [ebx+ecx*8]
	cmp	eax, edi
	jge	$LN8@star_metri

; 771  :     for ( j = start+1 ; j < end ; j++ )

	mov	edx, edi
	sub	edx, eax
	cmp	edx, 4
	jl	$LC50@star_metri
$LL51@star_metri:

; 772  :     { M->apinv[i] += M->A[j];

	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8]
	mov	edx, DWORD PTR [esi+200]
	fadd	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]

; 773  :       M->apinv[M->JA[j]] += M->A[j];

	add	eax, 4
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-16]
	mov	ebx, DWORD PTR [esi+200]
	lea	edx, DWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-32]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-24]
	mov	edx, DWORD PTR [esi+200]
	fadd	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-12]
	mov	ebx, DWORD PTR [esi+200]
	lea	edx, DWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-24]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-16]
	mov	edx, DWORD PTR [esi+200]
	fadd	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-8]
	mov	ebx, DWORD PTR [esi+200]
	lea	edx, DWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-16]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-8]
	mov	edx, DWORD PTR [esi+200]
	fadd	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-4]
	mov	ebx, DWORD PTR [esi+200]
	lea	edx, DWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	lea	edx, DWORD PTR [edi-3]
	cmp	eax, edx
	jl	$LL51@star_metri
$LC50@star_metri:

; 771  :     for ( j = start+1 ; j < end ; j++ )

	cmp	eax, edi
	jge	SHORT $LN8@star_metri
$LC6@star_metri:

; 772  :     { M->apinv[i] += M->A[j];

	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8]
	mov	edx, DWORD PTR [esi+200]
	fadd	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	inc	eax
	fstp	QWORD PTR [edx]

; 773  :       M->apinv[M->JA[j]] += M->A[j];

	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-4]
	mov	ebx, DWORD PTR [esi+200]
	lea	edx, DWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8-8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	cmp	eax, edi
	jl	SHORT $LC6@star_metri
$LN8@star_metri:

; 766  :   /* sums of rows */
; 767  :   for ( i = 0 ; i < M->N ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR [esi+4]
	jl	$LL55@star_metri
$LN7@star_metri:

; 774  :     }
; 775  :   }
; 776  :   for ( i = 0 ; i < M->N ; i++ ) 

	xor	ecx, ecx
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN58@star_metri
	fldz
	fld1
$LN3@star_metri:
	mov	eax, DWORD PTR [esi+200]

; 777  :      M->apinv[i] = (M->apinv[i]==0.0) ? 0.0 : 1/M->apinv[i];

	fld	QWORD PTR [eax+ecx*8]
	lea	edx, DWORD PTR [eax+ecx*8]
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN33@star_metri
	fld	ST(1)
	jmp	SHORT $LN34@star_metri
$LN33@star_metri:
	fld	ST(0)
	fdiv	QWORD PTR [edx]
$LN34@star_metri:
	inc	ecx
	fstp	QWORD PTR [edx]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LN3@star_metri

; 774  :     }
; 775  :   }
; 776  :   for ( i = 0 ; i < M->N ; i++ ) 

	fstp	ST(1)
	fstp	ST(0)
$LN58@star_metri:
	pop	edi
	pop	esi
	pop	ebx

; 778  : } /* end star_metric_setup() */

	mov	esp, ebp
	pop	ebp
	ret	0
_star_metric_setup ENDP
_TEXT	ENDS
END
