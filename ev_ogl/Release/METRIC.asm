; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\METRIC.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_euclidean_area:QWORD
_DATA	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_force_l_metric
EXTRN	_dot:PROC
EXTRN	_eval_all:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\metric.c
CONST	ENDS
;	COMDAT _edge_force_l_metric
_TEXT	SEGMENT
_density$ = -2224					; size = 8
_gg$ = -2216						; size = 8
tv449 = -2208						; size = 4
_len$ = -2204						; size = 8
tv764 = -2200						; size = 4
tv420 = -2196						; size = 4
_j$ = -2192						; size = 4
_e_id$GSCopy$ = -2188					; size = 4
_i$ = -2184						; size = 4
tv439 = -2180						; size = 4
_tforce$ = -2180					; size = 4
tv762 = -2176						; size = 4
_hforce$ = -2176					; size = 4
tv1079 = -2172						; size = 4
tv766 = -2172						; size = 4
tv1185 = -2168						; size = 4
tv720 = -2168						; size = 4
_g_partial$ = -2164					; size = 1728
_g$ = -436						; size = 288
_gg_partial$ = -148					; size = 48
_midx$ = -100						; size = 48
_v$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_edge_force_l_metric PROC				; COMDAT

; 26   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2224				; 000008b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 27   :   REAL v[MAXCOORD],len,f,fp,*tforce,*hforce;
; 28   :   int i,j,k;
; 29   :   vertex_id tv = get_edge_tailv(e_id);

	mov	ecx, DWORD PTR _web+124
	push	ebx
	mov	ebx, DWORD PTR _web+636
	push	esi
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]
	mov	esi, edi
	shr	esi, 27					; 0000001bH
	and	esi, 1

; 51   :         eval_all(&web.metric[i][j],midx,SDIM,&g[i][j],g_partial[i][j],e_id);

	mov	DWORD PTR _e_id$GSCopy$[ebp], edi
	mov	eax, edi
	je	SHORT $LN32@edge_force

; 27   :   REAL v[MAXCOORD],len,f,fp,*tforce,*hforce;
; 28   :   int i,j,k;
; 29   :   vertex_id tv = get_edge_tailv(e_id);

	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR tv420[ebp], eax
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR [eax+ecx+304]
	add	ecx, edx
	mov	eax, DWORD PTR [ecx+ebx*4]
	jmp	SHORT $LN31@edge_force
$LN32@edge_force:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR tv420[ebp], eax
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [ecx+edx]
	add	ecx, edx
$LN31@edge_force:

; 30   :   vertex_id hv = get_edge_headv(e_id);

	test	esi, esi
	je	SHORT $LN36@edge_force
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN35@edge_force
$LN36@edge_force:
	mov	ecx, DWORD PTR [ecx+ebx*4]
$LN35@edge_force:

; 31   :   REAL density = get_edge_density(e_id);

	fld	QWORD PTR [edx+40]

; 32   :   REAL g[MAXCOORD][MAXCOORD];
; 33   :   REAL g_partial[MAXCOORD][MAXCOORD][MAXCOORD];
; 34   :   REAL *xt=get_coord(tv);

	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR _web+104
	fstp	QWORD PTR _density$[ebp]
	mov	esi, DWORD PTR [esi+edx+64]

; 35   :   REAL *xh=get_coord(hv);
; 36   :   REAL midx[MAXCOORD];
; 37   :   REAL gg=0.0,gg_partial[MAXCOORD];

	fldz
	mov	ebx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	and	ecx, 134217727				; 07ffffffH
	add	eax, eax
	mov	edx, DWORD PTR [eax+ebx]
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR tv439[ebp], eax
	mov	eax, DWORD PTR [ecx+ebx]
	fstp	QWORD PTR _gg$[ebp]
	add	edx, esi
	add	eax, esi

; 38   : 
; 39   :   /* force due to linear tension, metric evaluated at midpoint */
; 40   :   for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _web+616
	mov	DWORD PTR tv449[ebp], ecx
	test	esi, esi
	jle	SHORT $LN26@edge_force
	fld	QWORD PTR __real@3fe0000000000000
	lea	ecx, DWORD PTR _midx$[ebp]
	lea	ebx, DWORD PTR _v$[ebp]
	sub	ecx, eax
	sub	edx, eax
	sub	ebx, eax
	mov	edi, esi
$LN28@edge_force:

; 41   :   { midx[i] = (xt[i] + xh[i])/2;

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	edi
	fadd	QWORD PTR [edx+eax-8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [ecx+eax-8]

; 42   :     v[i] = xh[i] - xt[i];

	fld	QWORD PTR [eax-8]
	fsub	QWORD PTR [edx+eax-8]
	fstp	QWORD PTR [ebx+eax-8]
	jne	SHORT $LN28@edge_force

; 38   : 
; 39   :   /* force due to linear tension, metric evaluated at midpoint */
; 40   :   for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR _e_id$GSCopy$[ebp]
	fstp	ST(0)
$LN26@edge_force:

; 43   :   }
; 44   :   if ( web.conformal_flag )

	cmp	DWORD PTR _web+1680, 0
	je	SHORT $LN25@edge_force

; 45   :   { eval_all(&web.metric[0][0],midx,SDIM,&gg,gg_partial,e_id);

	push	edi
	lea	eax, DWORD PTR _gg_partial$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gg$[ebp]
	push	ecx
	push	esi
	lea	edx, DWORD PTR _midx$[ebp]
	push	edx
	push	OFFSET _web+1688
	call	_eval_all

; 46   :     len = gg*SDIM_dot(v,v);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _v$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fmul	QWORD PTR _gg$[ebp]

; 47   :   }
; 48   :   else

	mov	esi, DWORD PTR _web+616
	add	esp, 36					; 00000024H
	jmp	$LN15@edge_force
$LN25@edge_force:

; 49   :   { for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	esi, esi
	jle	$LN21@edge_force
	lea	edi, DWORD PTR _g_partial$[ebp]
	lea	ebx, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv762[ebp], edi
	mov	DWORD PTR tv764[ebp], ebx
	mov	DWORD PTR tv766[ebp], OFFSET _web+1688
	npad	6
$LL59@edge_force:

; 50   :       for ( j = 0 ; j < SDIM ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	test	esi, esi
	jle	SHORT $LN22@edge_force
	mov	eax, DWORD PTR tv766[ebp]
	mov	DWORD PTR tv720[ebp], eax
	npad	6
$LL56@edge_force:

; 51   :         eval_all(&web.metric[i][j],midx,SDIM,&g[i][j],g_partial[i][j],e_id);

	mov	ecx, DWORD PTR _e_id$GSCopy$[ebp]
	mov	eax, DWORD PTR tv720[ebp]
	push	ecx
	push	edi
	push	ebx
	push	esi
	lea	edx, DWORD PTR _midx$[ebp]
	push	edx
	push	eax
	call	_eval_all
	mov	eax, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _web+616
	add	DWORD PTR tv720[ebp], 104		; 00000068H
	inc	eax
	add	esp, 24					; 00000018H
	add	edi, 48					; 00000030H
	add	ebx, 8
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, esi
	jl	SHORT $LL56@edge_force
$LN22@edge_force:

; 49   :   { for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR tv764[ebp]
	mov	edi, DWORD PTR tv762[ebp]
	add	DWORD PTR tv766[ebp], 624		; 00000270H
	inc	eax
	add	ebx, 48					; 00000030H
	add	edi, 288				; 00000120H
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR tv764[ebp], ebx
	mov	DWORD PTR tv762[ebp], edi
	cmp	eax, esi
	jl	$LL59@edge_force
$LN21@edge_force:

; 52   :     for ( len = 0.0, i = 0 ; i < SDIM ; i++ )

	fldz
	test	esi, esi
	jle	SHORT $LN15@edge_force
	lea	edi, DWORD PTR _g$[ebp]
	lea	edx, DWORD PTR _v$[ebp]
	mov	ebx, esi
$LN58@edge_force:

; 53   :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	mov	ecx, edi
$LN14@edge_force:

; 54   :         len += v[i]*g[i][j]*v[j];

	fld	QWORD PTR [edx]
	inc	eax
	fmul	QWORD PTR [ecx]
	add	ecx, 8
	fmul	QWORD PTR _v$[ebp+eax*8-8]
	faddp	ST(1), ST(0)
	cmp	eax, esi
	jl	SHORT $LN14@edge_force

; 52   :     for ( len = 0.0, i = 0 ; i < SDIM ; i++ )

	add	edx, 8
	add	edi, 48					; 00000030H
	dec	ebx
	jne	SHORT $LN58@edge_force
$LN15@edge_force:

; 55   :   }
; 56   :   len = sqrt(len);

	call	__CIsqrt
	fst	QWORD PTR _len$[ebp]

; 57   :   tforce = get_force(tv);

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [ecx+edx+784]
	mov	ecx, DWORD PTR tv439[ebp]
	mov	edx, DWORD PTR _web+12
	mov	ebx, DWORD PTR [ecx+edx]

; 58   :   hforce = get_force(hv);

	mov	ecx, DWORD PTR tv449[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	add	ebx, eax
	add	edx, eax

; 59   :   for ( k = 0 ; k < SDIM ; k++ )

	xor	edi, edi
	mov	DWORD PTR _tforce$[ebp], ebx
	mov	DWORD PTR _hforce$[ebp], edx
	test	esi, esi
	jle	$LN9@edge_force

; 55   :   }
; 56   :   len = sqrt(len);

	fld	QWORD PTR __real@3fd0000000000000
	lea	eax, DWORD PTR _g$[ebp]
	fldz
	mov	DWORD PTR tv1185[ebp], eax
	fld	QWORD PTR _density$[ebp]
$LN55@edge_force:

; 60   :   { if ( web.conformal_flag )

	cmp	DWORD PTR _web+1680, 0
	je	$LN8@edge_force
	fstp	ST(2)

; 61   :     { fp = gg_partial[k]*SDIM_dot(v,v);

	lea	ecx, DWORD PTR _v$[ebp]
	fstp	ST(2)
	push	esi
	push	ecx
	fstp	ST(0)
	mov	edx, ecx
	fstp	ST(0)
	push	edx
	call	_dot
	fmul	QWORD PTR _gg_partial$[ebp+edi*8]

; 62   :       f  = gg*v[k];

	fld	QWORD PTR _v$[ebp+edi*8]

; 63   :     }
; 64   :     else

	mov	edx, DWORD PTR _hforce$[ebp]
	fmul	QWORD PTR _gg$[ebp]
	add	esp, 12					; 0000000cH
	fld	QWORD PTR __real@3fd0000000000000
	fldz
	fld	QWORD PTR _len$[ebp]
	fld	QWORD PTR _density$[ebp]
	fxch	ST(1)
	fxch	ST(5)
	fxch	ST(3)
	fxch	ST(4)
	fxch	ST(2)
	fxch	ST(3)
	fxch	ST(1)
	fxch	ST(2)
$LN4@edge_force:

; 69   :       }
; 70   :     tforce[k] += density*(f-fp)/len;

	fld	ST(0)
	add	DWORD PTR tv1185[ebp], 48		; 00000030H
	fsub	ST(0), ST(2)
	inc	edi
	fmul	ST(0), ST(3)
	fdiv	ST(0), ST(6)
	fadd	QWORD PTR [ebx+edi*8-8]
	fstp	QWORD PTR [ebx+edi*8-8]

; 71   :     hforce[k] -= density*(f+fp)/len;

	faddp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(4)
	fsubr	QWORD PTR [edx+edi*8-8]
	fstp	QWORD PTR [edx+edi*8-8]
	mov	esi, DWORD PTR _web+616
	cmp	edi, esi
	jl	$LN55@edge_force

; 59   :   for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(2)
	fstp	ST(1)
	fstp	ST(0)
$LN9@edge_force:

; 72   :   }
; 73   :   set_edge_length(e_id,len);

	mov	ecx, DWORD PTR tv420[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [ecx+edx]

; 74   : 
; 75   : } // end edge_force_l_metric()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	QWORD PTR [eax+48]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@edge_force:

; 65   :       for ( f = fp = 0.0, i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	fld	ST(1)
	fld	ST(2)
	test	esi, esi
	jle	SHORT $LN4@edge_force
	mov	ebx, DWORD PTR tv1185[ebp]
	lea	eax, DWORD PTR _g_partial$[ebp+edi*8]
	mov	DWORD PTR tv1079[ebp], eax
$LN57@edge_force:

; 66   :       { for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR tv1079[ebp]
	xor	eax, eax
$LN3@edge_force:

; 67   :           fp += g_partial[i][j][k]*v[i]*v[j]/4;

	fld	QWORD PTR _v$[ebp+ecx*8]
	inc	eax
	fmul	QWORD PTR [edx]
	add	edx, 48					; 00000030H
	fmul	QWORD PTR _v$[ebp+eax*8-8]
	fmul	ST(0), ST(5)
	faddp	ST(2), ST(0)
	cmp	eax, esi
	jl	SHORT $LN3@edge_force

; 68   :         f += g[k][i]*v[i];

	fld	QWORD PTR _v$[ebp+ecx*8]
	add	DWORD PTR tv1079[ebp], 288		; 00000120H
	fmul	QWORD PTR [ebx]
	inc	ecx
	add	ebx, 8
	faddp	ST(1), ST(0)
	cmp	ecx, esi
	jl	SHORT $LN57@edge_force

; 65   :       for ( f = fp = 0.0, i = 0 ; i < SDIM ; i++ )

	mov	ebx, DWORD PTR _tforce$[ebp]
	mov	edx, DWORD PTR _hforce$[ebp]
	jmp	$LN4@edge_force
_edge_force_l_metric ENDP
_TEXT	ENDS
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_energy_l_metric
EXTRN	_binary_tree_add:PROC
EXTRN	_eval:PROC
; Function compile flags: /Ogtp
;	COMDAT _edge_energy_l_metric
_TEXT	SEGMENT
_e_id$GSCopy$ = -124					; size = 4
_i$ = -120						; size = 4
tv579 = -116						; size = 4
_energy$ = -112						; size = 8
_gg$89122 = -112					; size = 8
tv324 = -104						; size = 4
_midx$ = -100						; size = 48
_v$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_edge_energy_l_metric PROC				; COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _e_id$[ebp]

; 86   :   REAL energy;
; 87   :   REAL midx[MAXCOORD];
; 88   :   int i,j;
; 89   :   vertex_id tv = get_edge_tailv(e_id);

	mov	edx, DWORD PTR _dymem
	push	ebx
	mov	ebx, DWORD PTR _web+636
	push	esi
	mov	esi, eax
	shr	esi, 27					; 0000001bH
	and	esi, 1
	push	edi

; 108  :     for ( energy = 0.0, i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _e_id$GSCopy$[ebp], eax
	je	SHORT $LN16@edge_energ

; 86   :   REAL energy;
; 87   :   REAL midx[MAXCOORD];
; 88   :   int i,j;
; 89   :   vertex_id tv = get_edge_tailv(e_id);

	mov	edi, eax
	mov	eax, DWORD PTR _web+124
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edx+304]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR tv324[ebp], edi
	jmp	SHORT $LN15@edge_energ
$LN16@edge_energ:
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv324[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	edi, DWORD PTR tv324[ebp]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx]
$LN15@edge_energ:

; 90   :   vertex_id hv = get_edge_headv(e_id);

	test	esi, esi
	je	SHORT $LN20@edge_energ
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN19@edge_energ
$LN20@edge_energ:
	mov	ecx, DWORD PTR [ecx+ebx*4]
$LN19@edge_energ:

; 91   :   REAL *xt=get_coord(tv);

	mov	esi, DWORD PTR _web+104
	mov	esi, DWORD PTR [esi+edx+64]
	mov	ebx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]

; 92   :   REAL *xh=get_coord(hv);

	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+ecx*4]

; 93   :   REAL v[MAXCOORD];
; 94   :   REAL euclidean;
; 95   : 
; 96   :   /* energy due to linear tension, metric evaluated at midpoint */
; 97   :   for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	edx, esi
	add	eax, esi
	test	ecx, ecx
	jle	SHORT $LN10@edge_energ
	fld	QWORD PTR __real@3fe0000000000000
	lea	esi, DWORD PTR _midx$[ebp]
	lea	ebx, DWORD PTR _v$[ebp]
	sub	esi, eax
	sub	edx, eax
	sub	ebx, eax
	mov	edi, ecx
$LN12@edge_energ:

; 98   :   { midx[i] = (xt[i] + xh[i])/2;

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	edi
	fadd	QWORD PTR [edx+eax-8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi+eax-8]

; 99   :     v[i] = xh[i] - xt[i];

	fld	QWORD PTR [eax-8]
	fsub	QWORD PTR [edx+eax-8]
	fstp	QWORD PTR [ebx+eax-8]
	jne	SHORT $LN12@edge_energ

; 93   :   REAL v[MAXCOORD];
; 94   :   REAL euclidean;
; 95   : 
; 96   :   /* energy due to linear tension, metric evaluated at midpoint */
; 97   :   for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR tv324[ebp]
	fstp	ST(0)
$LN10@edge_energ:

; 100  :   }
; 101  :   if ( web.conformal_flag )

	cmp	DWORD PTR _web+1680, 0
	je	SHORT $LN9@edge_energ

; 102  :   { REAL gg = eval(&web.metric[0][0],midx,e_id,NULL);

	mov	edx, DWORD PTR _e_id$GSCopy$[ebp]
	push	0
	push	edx
	lea	eax, DWORD PTR _midx$[ebp]
	push	eax
	push	OFFSET _web+1688
	call	_eval
	fstp	QWORD PTR _gg$89122[ebp]

; 103  :     euclidean = SDIM_dot(v,v);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _v$[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot

; 104  :     energy = gg*euclidean;

	fld	QWORD PTR _gg$89122[ebp]
	fmul	ST(0), ST(1)
	add	esp, 28					; 0000001cH
	fstp	QWORD PTR _energy$[ebp]

; 105  :     euclidean_area += sqrt(euclidean);

	call	__CIsqrt
	fadd	QWORD PTR _euclidean_area
	fstp	QWORD PTR _euclidean_area

; 106  :   }
; 107  :   else

	jmp	SHORT $LN5@edge_energ
$LN9@edge_energ:

; 108  :     for ( energy = 0.0, i = 0 ; i < SDIM ; i++ )

	fldz
	mov	DWORD PTR _i$[ebp], 0
	fstp	QWORD PTR _energy$[ebp]
	test	ecx, ecx
	jle	SHORT $LN5@edge_energ
	mov	DWORD PTR tv579[ebp], OFFSET _web+1688
	lea	ebx, DWORD PTR _v$[ebp]
	npad	3
$LL29@edge_energ:

; 109  :      for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN6@edge_energ
	mov	edi, DWORD PTR tv579[ebp]
	npad	7
$LL4@edge_energ:

; 110  :         energy += v[i]*v[j]*eval(&web.metric[i][j],midx,e_id,NULL);

	mov	ecx, DWORD PTR _e_id$GSCopy$[ebp]
	push	0
	push	ecx
	lea	edx, DWORD PTR _midx$[ebp]
	push	edx
	push	edi
	call	_eval
	fld	QWORD PTR _v$[ebp+esi*8]
	fmul	QWORD PTR [ebx]
	mov	ecx, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	fmulp	ST(1), ST(0)
	add	edi, 104				; 00000068H
	fadd	QWORD PTR _energy$[ebp]
	fstp	QWORD PTR _energy$[ebp]
	cmp	esi, ecx
	jl	SHORT $LL4@edge_energ

; 109  :      for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR tv324[ebp]
$LN6@edge_energ:

; 108  :     for ( energy = 0.0, i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv579[ebp], 624		; 00000270H
	inc	eax
	add	ebx, 8
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, ecx
	jl	SHORT $LL29@edge_energ
$LN5@edge_energ:

; 111  :   energy = sqrt(energy);

	fld	QWORD PTR _energy$[ebp]
	call	__CIsqrt
	fst	QWORD PTR _energy$[ebp]

; 112  : 
; 113  :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN1@edge_energ

; 114  :       /* don't count triple junction as area */
; 115  :       binary_tree_add(web.total_area_addends,energy);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1000
	call	_binary_tree_add
	fld	QWORD PTR _energy$[ebp]
	add	esp, 12					; 0000000cH
$LN1@edge_energ:

; 116  : 
; 117  :   energy *= get_edge_density(e_id);

	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [edi+eax]
	fmul	QWORD PTR [ecx+40]

; 118  :   binary_tree_add(web.total_energy_addends,energy);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1248
	call	_binary_tree_add

; 119  : 
; 120  : } // end edge_energy_l_metric()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_energy_l_metric ENDP
_TEXT	ENDS
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_energy_q_metric
EXTRN	_gauss2wt:BYTE
EXTRN	_gcombo:BYTE
EXTRN	_sdip:BYTE
; Function compile flags: /Ogtp
;	COMDAT _edge_energy_q_metric
_TEXT	SEGMENT
tv1297 = -144						; size = 4
_pt$ = -140						; size = 12
_e_id$GSCopy$ = -128					; size = 4
tv1322 = -124						; size = 4
_len$ = -120						; size = 8
_euclidean$ = -120					; size = 8
tv676 = -112						; size = 4
tv1165 = -108						; size = 4
_k$ = -108						; size = 4
tv1320 = -104						; size = 4
tv1175 = -104						; size = 4
_tang$ = -100						; size = 48
_gpt$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_edge_energy_q_metric PROC				; COMDAT

; 132  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _e_id$[ebp]
	push	ebx

; 133  :   REAL *pt[EDGE_CTRL];
; 134  :   REAL tang[MAXCOORD];
; 135  :   vertex_id v[EDGE_CTRL];
; 136  :   int i,j,k;
; 137  :   REAL gpt[MAXCOORD];
; 138  :   REAL len;
; 139  :   REAL euclidean;
; 140  : 
; 141  :   v[0] = get_edge_tailv(e_id);

	mov	ebx, DWORD PTR _dymem
	mov	edx, eax
	shr	edx, 27					; 0000001bH
	and	edx, 1
	push	esi
	push	edi

; 163  :       for ( len = 0.0, k = 0 ; k < SDIM ; k++ )

	mov	DWORD PTR _e_id$GSCopy$[ebp], eax
	je	SHORT $LN25@edge_energ@2

; 133  :   REAL *pt[EDGE_CTRL];
; 134  :   REAL tang[MAXCOORD];
; 135  :   vertex_id v[EDGE_CTRL];
; 136  :   int i,j,k;
; 137  :   REAL gpt[MAXCOORD];
; 138  :   REAL len;
; 139  :   REAL euclidean;
; 140  : 
; 141  :   v[0] = get_edge_tailv(e_id);

	mov	edi, eax
	mov	eax, DWORD PTR _web+124
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ebx+304]
	add	ecx, eax
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv676[ebp], edi
	jmp	SHORT $LN24@edge_energ@2
$LN25@edge_energ@2:
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv676[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+ebx+304]
	mov	edi, DWORD PTR tv676[ebp]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx]
$LN24@edge_energ@2:

; 142  :   v[1] = get_edge_midv(e_id);

	mov	esi, DWORD PTR [ecx+8]

; 143  :   v[2] = get_edge_headv(e_id);

	test	edx, edx
	je	SHORT $LN29@edge_energ@2
	mov	edx, DWORD PTR [ecx]
	jmp	SHORT $LN28@edge_energ@2
$LN29@edge_energ@2:
	mov	edx, DWORD PTR _web+636
	mov	edx, DWORD PTR [ecx+edx*4]
$LN28@edge_energ@2:

; 144  :   for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 145  :     pt[i] = get_coord(v[i]);

	mov	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+ebx+64]
	mov	ebx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	add	eax, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	and	esi, 134217727				; 07ffffffH
	mov	DWORD PTR _pt$[ebp], eax
	mov	eax, DWORD PTR [ebx+esi*4]
	add	eax, ecx
	add	edx, ecx
	mov	DWORD PTR _pt$[ebp+4], eax
	mov	DWORD PTR _pt$[ebp+8], edx

; 146  :      
; 147  :   /* calculate tangents at integration points and accumulate */
; 148  :   for ( i = 0 ; i < EDGE_INTERP ; i++ )

	xor	esi, esi
	jmp	SHORT $LN69@edge_energ@2
	npad	2
$LL52@edge_energ@2:
	mov	eax, DWORD PTR _pt$[ebp+4]
$LN69@edge_energ@2:

; 149  :   { for ( j = 0 ; j < SDIM ; j ++ )

	mov	ebx, DWORD PTR _web+616
	fldz
	xor	edx, edx
	test	ebx, ebx
	jle	$LN13@edge_energ@2

; 150  :     { tang[j] = 0.0;

	mov	edi, DWORD PTR _pt$[ebp]
	sub	edi, eax
	lea	ecx, DWORD PTR _tang$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv1165[ebp], eax
	mov	eax, DWORD PTR _pt$[ebp+8]
	sub	eax, ecx
	mov	DWORD PTR tv1175[ebp], eax
$LN53@edge_energ@2:

; 151  :       gpt[j] = 0.0;
; 152  :       for ( k = 0 ; k < EDGE_CTRL ; k++ )
; 153  :       { tang[j] += sdip[k][i]*pt[k][j];

	mov	ecx, DWORD PTR tv1165[ebp]
	fst	QWORD PTR _tang$[ebp+edx*8]
	fst	QWORD PTR _gpt$[ebp+edx*8]
	lea	eax, DWORD PTR _tang$[ebp+edx*8]
	fld	QWORD PTR _sdip[esi]
	add	ecx, eax
	fmul	QWORD PTR [ecx+edi]
	inc	edx
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 154  :         gpt[j] += gcombo[k][i]*pt[k][j];

	fld	QWORD PTR _gcombo[esi]
	fmul	QWORD PTR [ecx+edi]
	fadd	QWORD PTR _gpt$[ebp+edx*8-8]
	fstp	QWORD PTR _gpt$[ebp+edx*8-8]
	fld	QWORD PTR _sdip[esi+24]
	fmul	QWORD PTR [ecx]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	fld	QWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1175[ebp]
	fmul	QWORD PTR _gcombo[esi+24]
	fadd	QWORD PTR _gpt$[ebp+edx*8-8]
	fstp	QWORD PTR _gpt$[ebp+edx*8-8]
	fld	QWORD PTR _sdip[esi+48]
	fmul	QWORD PTR [eax+ecx]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	fld	QWORD PTR [eax+ecx]
	fmul	QWORD PTR _gcombo[esi+48]
	fadd	QWORD PTR _gpt$[ebp+edx*8-8]
	fstp	QWORD PTR _gpt$[ebp+edx*8-8]
	cmp	edx, ebx
	jl	SHORT $LN53@edge_energ@2

; 149  :   { for ( j = 0 ; j < SDIM ; j ++ )

	mov	edi, DWORD PTR tv676[ebp]
$LN13@edge_energ@2:

; 155  :       }
; 156  :     }
; 157  :     if ( web.conformal_flag )

	cmp	DWORD PTR _web+1680, 0
	je	SHORT $LN9@edge_energ@2

; 158  :     { euclidean = eval(&web.metric[0][0],gpt,e_id,NULL);

	mov	edx, DWORD PTR _e_id$GSCopy$[ebp]
	fstp	ST(0)
	push	0
	push	edx
	lea	eax, DWORD PTR _gpt$[ebp]
	push	eax
	push	OFFSET _web+1688
	call	_eval
	fstp	QWORD PTR _euclidean$[ebp]

; 159  :       len = euclidean*SDIM_dot(tang,tang);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _tang$[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	fld	QWORD PTR _euclidean$[ebp]
	fmul	ST(1), ST(0)
	add	esp, 28					; 0000001cH
	fxch	ST(1)
	fstp	QWORD PTR _len$[ebp]

; 160  :       euclidean_area += gauss2wt[i]*sqrt(euclidean);

	call	__CIsqrt
	fmul	QWORD PTR _gauss2wt[esi]
	fadd	QWORD PTR _euclidean_area
	fstp	QWORD PTR _euclidean_area

; 161  :     }
; 162  :     else

	jmp	$LN5@edge_energ@2
$LN9@edge_energ@2:

; 163  :       for ( len = 0.0, k = 0 ; k < SDIM ; k++ )

	fstp	QWORD PTR _len$[ebp]
	mov	DWORD PTR _k$[ebp], 0
	test	ebx, ebx
	jle	SHORT $LN5@edge_energ@2
	lea	ecx, DWORD PTR _tang$[ebp]
	mov	DWORD PTR tv1320[ebp], OFFSET _web+1688
	mov	DWORD PTR tv1322[ebp], ecx
$LL54@edge_energ@2:

; 164  :         for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN6@edge_energ@2
	mov	ebx, DWORD PTR tv1320[ebp]
	jmp	SHORT $LN4@edge_energ@2
	npad	5
$LL55@edge_energ@2:
	mov	ebx, DWORD PTR tv1297[ebp]
$LN4@edge_energ@2:

; 165  :           len += tang[k]*tang[j]*eval(&web.metric[k][j],gpt,e_id,NULL);

	mov	edx, DWORD PTR _e_id$GSCopy$[ebp]
	push	0
	push	edx
	lea	eax, DWORD PTR _gpt$[ebp]
	push	eax
	push	ebx
	call	_eval
	fld	QWORD PTR _tang$[ebp+edi*8]
	mov	ecx, DWORD PTR tv1322[ebp]
	fmul	QWORD PTR [ecx]
	add	ebx, 104				; 00000068H
	mov	DWORD PTR tv1297[ebp], ebx
	mov	ebx, DWORD PTR _web+616
	fmulp	ST(1), ST(0)
	inc	edi
	add	esp, 16					; 00000010H
	fadd	QWORD PTR _len$[ebp]
	fstp	QWORD PTR _len$[ebp]
	cmp	edi, ebx
	jl	SHORT $LL55@edge_energ@2
$LN6@edge_energ@2:

; 163  :       for ( len = 0.0, k = 0 ; k < SDIM ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	add	DWORD PTR tv1322[ebp], 8
	add	DWORD PTR tv1320[ebp], 624		; 00000270H
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, ebx
	jl	SHORT $LL54@edge_energ@2
	mov	edi, DWORD PTR tv676[ebp]
$LN5@edge_energ@2:

; 166  :     len = gauss2wt[i]*sqrt(len);

	fld	QWORD PTR _len$[ebp]
	call	__CIsqrt
	fmul	QWORD PTR _gauss2wt[esi]

; 167  :     if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	fst	QWORD PTR _len$[ebp]
	jne	SHORT $LN1@edge_energ@2

; 168  :     { /* don't count triple junction as area */
; 169  :       binary_tree_add(web.total_area_addends,len);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1000
	call	_binary_tree_add
	fld	QWORD PTR _len$[ebp]
	add	esp, 12					; 0000000cH
$LN1@edge_energ@2:

; 170  :     }
; 171  : 
; 172  :     len *= get_edge_density(e_id);

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [edi+edx]
	fmul	QWORD PTR [eax+40]

; 173  :     binary_tree_add(web.total_energy_addends,len);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1248
	call	_binary_tree_add
	add	esi, 8
	add	esp, 12					; 0000000cH
	cmp	esi, 24					; 00000018H
	jl	$LL52@edge_energ@2

; 174  :   }
; 175  :      
; 176  :   return;
; 177  : } // end edge_energy_q_metric()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_energy_q_metric ENDP
_TEXT	ENDS
PUBLIC	__real@41f0000000000000
PUBLIC	_e_id$GSCopy$
PUBLIC	__real@3ff0000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_edge_force_q_metric
;	COMDAT __real@41f0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\metric.c
CONST	ENDS
;	COMDAT _edge_force_q_metric
_TEXT	SEGMENT
_density$ = -2212					; size = 8
_force$ = -2204						; size = 12
_vv$ = -2192						; size = 8
_pt$ = -2184						; size = 12
tv2393 = -2172						; size = 8
tv2408 = -2168						; size = 4
tv2404 = -2168						; size = 4
_e_id$GSCopy$ = -2164					; size = 4
tv2333 = -2160						; size = 4
_n$ = -2156						; size = 4
_j$ = -2156						; size = 4
tv2124 = -2152						; size = 4
tv1749 = -2152						; size = 4
tv1703 = -2148						; size = 4
_m$ = -2148						; size = 4
tv2226 = -2144						; size = 4
tv1574 = -2144						; size = 4
tv1273 = -2144						; size = 4
tv2412 = -2140						; size = 4
tv2038 = -2140						; size = 4
_k$ = -2140						; size = 4
tv2128 = -2136						; size = 4
tv1747 = -2136						; size = 4
tv2156 = -2132						; size = 4
tv1745 = -2132						; size = 4
tv1584 = -2132						; size = 4
tv634 = -2132						; size = 4
_g_partial$ = -2128					; size = 1728
_g$ = -400						; size = 288
_tang$ = -112						; size = 48
_gpt$ = -64						; size = 48
_v$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_edge_force_q_metric PROC				; COMDAT

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2212				; 000008a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 190  :   REAL *pt[EDGE_CTRL];
; 191  :   REAL tang[MAXCOORD];
; 192  :   vertex_id v[EDGE_CTRL];
; 193  :   int i,j,k,m,n;
; 194  :   REAL gpt[MAXCOORD];
; 195  :   REAL g[MAXCOORD][MAXCOORD];
; 196  :   REAL g_partial[MAXCOORD][MAXCOORD][MAXCOORD];
; 197  :   REAL *force[EDGE_CTRL];
; 198  :   REAL f,fp,fudge;
; 199  :   REAL density = get_edge_density(e_id);

	mov	ecx, DWORD PTR _web+124

; 200  :   REAL len;
; 201  :   REAL vv = 1.0;
; 202  :           
; 203  :   v[0] = get_edge_tailv(e_id);

	mov	edx, DWORD PTR _dymem
	push	ebx
	mov	ebx, DWORD PTR _web+636
	push	esi
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [eax+40]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	fstp	QWORD PTR _density$[ebp]
	fld1

; 229  :           eval_all(&web.metric[k][j],gpt,SDIM,&g[k][j],g_partial[k][j],e_id);

	mov	DWORD PTR _e_id$GSCopy$[ebp], edi
	shr	edi, 27					; 0000001bH
	fstp	QWORD PTR _vv$[ebp]
	and	edi, 1
	je	SHORT $LN45@edge_force@2

; 200  :   REAL len;
; 201  :   REAL vv = 1.0;
; 202  :           
; 203  :   v[0] = get_edge_tailv(e_id);

	add	eax, ecx
	mov	ecx, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN44@edge_force@2
$LN45@edge_force@2:
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
$LN44@edge_force@2:

; 204  :   v[1] = get_edge_midv(e_id);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR _v$[ebp], ecx
	mov	DWORD PTR _v$[ebp+4], esi

; 205  :   v[2] = get_edge_headv(e_id);

	test	edi, edi
	je	SHORT $LN49@edge_force@2
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN48@edge_force@2
$LN49@edge_force@2:
	mov	eax, DWORD PTR [eax+ebx*4]
$LN48@edge_force@2:

; 206  :   for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 207  :   { pt[i] = get_coord(v[i]);

	mov	edi, DWORD PTR _web+12
	fldz
	and	ecx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+edx+64]
	mov	DWORD PTR tv1273[ebp], ebx
	add	ebx, ecx
	mov	DWORD PTR _pt$[ebp], ebx

; 208  :     force[i] = get_force(v[i]);

	mov	ebx, DWORD PTR _web+104
	mov	edx, DWORD PTR [ebx+edx+784]
	mov	ebx, DWORD PTR tv1273[ebp]
	and	esi, 134217727				; 07ffffffH
	lea	esi, DWORD PTR [edi+esi*4]
	add	ebx, edx
	mov	DWORD PTR _force$[ebp], ebx
	mov	ebx, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi]
	mov	DWORD PTR _v$[ebp+8], eax
	add	esi, edx
	and	eax, 134217727				; 07ffffffH
	lea	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR _force$[ebp+4], esi
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax]
	add	ebx, ecx
	add	esi, ecx
	add	eax, edx
	mov	DWORD PTR _pt$[ebp+4], ebx
	xor	ebx, ebx
	mov	DWORD PTR _pt$[ebp+8], esi
	mov	esi, DWORD PTR _web+616
	mov	DWORD PTR _force$[ebp+8], eax
	mov	DWORD PTR tv2333[ebp], ebx
$LN90@edge_force@2:

; 213  :   { for ( j = 0 ; j < SDIM ; j ++ )

	xor	edx, edx
	test	esi, esi
	jle	$LN33@edge_force@2

; 214  :     { tang[j] = 0.0;

	mov	eax, DWORD PTR _pt$[ebp+4]
	mov	edi, DWORD PTR _pt$[ebp]
	sub	edi, eax
	lea	ecx, DWORD PTR _tang$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv1574[ebp], eax
	mov	eax, DWORD PTR _pt$[ebp+8]
	sub	eax, ecx
	mov	DWORD PTR tv1584[ebp], eax
$LN87@edge_force@2:

; 215  :       gpt[j] = 0.0;
; 216  :       for ( k = 0 ; k < EDGE_CTRL ; k++ )
; 217  :       { tang[j] += sdip[k][i]*pt[k][j];

	mov	ecx, DWORD PTR tv1574[ebp]
	fst	QWORD PTR _tang$[ebp+edx*8]
	fst	QWORD PTR _gpt$[ebp+edx*8]
	lea	eax, DWORD PTR _tang$[ebp+edx*8]
	add	ecx, eax
	fld	QWORD PTR [edi+ecx]
	inc	edx
	fmul	QWORD PTR _sdip[ebx]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 218  :         gpt[j] += gcombo[k][i]*pt[k][j];

	fld	QWORD PTR [edi+ecx]
	fmul	QWORD PTR _gcombo[ebx]
	fadd	QWORD PTR _gpt$[ebp+edx*8-8]
	fstp	QWORD PTR _gpt$[ebp+edx*8-8]
	fld	QWORD PTR [ecx]
	fmul	QWORD PTR _sdip[ebx+24]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	fld	QWORD PTR _gcombo[ebx+24]
	fmul	QWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1584[ebp]
	fadd	QWORD PTR _gpt$[ebp+edx*8-8]
	fstp	QWORD PTR _gpt$[ebp+edx*8-8]
	fld	QWORD PTR [ecx+eax]
	fmul	QWORD PTR _sdip[ebx+48]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	fld	QWORD PTR _gcombo[ebx+48]
	fmul	QWORD PTR [ecx+eax]
	fadd	QWORD PTR _gpt$[ebp+edx*8-8]
	fstp	QWORD PTR _gpt$[ebp+edx*8-8]
	cmp	edx, esi
	jl	SHORT $LN87@edge_force@2
$LN33@edge_force@2:

; 219  :       }
; 220  :     }
; 221  :     if ( web.conformal_flag )

	cmp	DWORD PTR _web+1680, 0
	je	$LN29@edge_force@2

; 222  :     { eval_all(&web.metric[0][0],gpt,SDIM,&g[0][0],g_partial[0][0],e_id);

	mov	edx, DWORD PTR _e_id$GSCopy$[ebp]
	fstp	ST(0)
	push	edx
	lea	eax, DWORD PTR _g_partial$[ebp]
	push	eax
	lea	ecx, DWORD PTR _g$[ebp]
	push	ecx
	push	esi
	lea	edx, DWORD PTR _gpt$[ebp]
	push	edx
	push	OFFSET _web+1688
	call	_eval_all

; 223  :       vv = SDIM_dot(tang,tang);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _tang$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fst	QWORD PTR _vv$[ebp]

; 224  :       len = vv*g[0][0];

	fmul	QWORD PTR _g$[ebp]

; 225  :     }
; 226  :     else

	mov	esi, DWORD PTR _web+616
	fldz
	add	esp, 36					; 00000024H
	fxch	ST(1)
$LN19@edge_force@2:

; 233  :     }
; 234  :     if ( len <= 0.0 ) continue;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	$LN107@edge_force@2
	fstp	ST(1)

; 235  :     len = sqrt(len);
; 236  :     fudge = density*gauss2wt[i]/len/2;

	fld	QWORD PTR _gauss2wt[ebx]
	fmul	QWORD PTR _density$[ebp]
	fstp	QWORD PTR tv2393[ebp]
	call	__CIsqrt
	fdivr	QWORD PTR tv2393[ebp]

; 237  :     for ( m = 0 ; m < EDGE_CTRL ; m++ )

	xor	eax, eax
	mov	edi, ebx
	mov	DWORD PTR _m$[ebp], eax
	mov	DWORD PTR tv2226[ebp], edi
	fmul	QWORD PTR __real@3fe0000000000000
	fldz
	fld	QWORD PTR _vv$[ebp]
$LN14@edge_force@2:

; 238  :       for ( n = 0 ; n < SDIM ; n++ )

	xor	ecx, ecx
	mov	DWORD PTR _n$[ebp], ecx
	test	esi, esi
	jle	$LN13@edge_force@2
	mov	eax, DWORD PTR _force$[ebp+eax*4]
	lea	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv2128[ebp], edx
	lea	edx, DWORD PTR _g_partial$[ebp]
	sub	edx, eax
	mov	DWORD PTR tv2124[ebp], eax
	mov	DWORD PTR tv2156[ebp], edx
	jmp	$LN11@edge_force@2
$LN29@edge_force@2:

; 227  :     { for ( k = 0 ; k < SDIM ; k++ )

	mov	DWORD PTR _k$[ebp], 0
	test	esi, esi
	jle	$LN25@edge_force@2
	lea	edi, DWORD PTR _g_partial$[ebp]
	lea	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv1745[ebp], edi
	mov	DWORD PTR tv1747[ebp], eax
	mov	DWORD PTR tv1749[ebp], OFFSET _web+1688
$LN27@edge_force@2:

; 228  :         for ( j = 0 ; j < SDIM ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	test	esi, esi
	jle	SHORT $LN26@edge_force@2
	mov	ecx, DWORD PTR tv1749[ebp]
	fstp	ST(0)
	mov	ebx, DWORD PTR tv1747[ebp]
	mov	DWORD PTR tv1703[ebp], ecx
$LL85@edge_force@2:

; 229  :           eval_all(&web.metric[k][j],gpt,SDIM,&g[k][j],g_partial[k][j],e_id);

	mov	edx, DWORD PTR _e_id$GSCopy$[ebp]
	mov	ecx, DWORD PTR tv1703[ebp]
	push	edx
	push	edi
	push	ebx
	push	esi
	lea	eax, DWORD PTR _gpt$[ebp]
	push	eax
	push	ecx
	call	_eval_all
	mov	eax, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _web+616
	add	DWORD PTR tv1703[ebp], 104		; 00000068H
	inc	eax
	add	esp, 24					; 00000018H
	add	edi, 48					; 00000030H
	add	ebx, 8
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, esi
	jl	SHORT $LL85@edge_force@2

; 228  :         for ( j = 0 ; j < SDIM ; j++ )

	fldz
	mov	ebx, DWORD PTR tv2333[ebp]
$LN26@edge_force@2:

; 227  :     { for ( k = 0 ; k < SDIM ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR tv1745[ebp]
	add	DWORD PTR tv1749[ebp], 624		; 00000270H
	add	DWORD PTR tv1747[ebp], 48		; 00000030H
	inc	eax
	add	edi, 288				; 00000120H
	mov	DWORD PTR _k$[ebp], eax
	mov	DWORD PTR tv1745[ebp], edi
	cmp	eax, esi
	jl	$LN27@edge_force@2
$LN25@edge_force@2:

; 230  :         for ( len = 0.0, k = 0 ; k < SDIM ; k++ )

	fld	ST(0)
	test	esi, esi
	jle	$LN107@edge_force@2
	lea	edi, DWORD PTR _g$[ebp]
	lea	edx, DWORD PTR _tang$[ebp]
	mov	DWORD PTR tv634[ebp], esi
$LN21@edge_force@2:

; 231  :           for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	mov	ecx, edi
$LN18@edge_force@2:

; 232  :             len += tang[k]*g[k][j]*tang[j];

	fld	QWORD PTR [ecx]
	inc	eax
	fmul	QWORD PTR [edx]
	add	ecx, 8
	fmul	QWORD PTR _tang$[ebp+eax*8-8]
	faddp	ST(1), ST(0)
	cmp	eax, esi
	jl	SHORT $LN18@edge_force@2

; 230  :         for ( len = 0.0, k = 0 ; k < SDIM ; k++ )

	add	edx, 8
	add	edi, 48					; 00000030H
	dec	DWORD PTR tv634[ebp]
	jne	SHORT $LN21@edge_force@2
	jmp	$LN19@edge_force@2
$LN84@edge_force@2:

; 238  :       for ( n = 0 ; n < SDIM ; n++ )

	mov	edx, DWORD PTR tv2156[ebp]
$LN11@edge_force@2:

; 239  :       { if ( web.conformal_flag )

	cmp	DWORD PTR _web+1680, 0
	je	SHORT $LN8@edge_force@2

; 240  :         { fp = g_partial[0][0][n]*vv;

	fld	QWORD PTR [edx+eax]

; 241  :           f  = g[0][0]*v[n];

	mov	edx, DWORD PTR _v$[ebp+ecx*4]
	fmul	ST(0), ST(1)
	fild	DWORD PTR _v$[ebp+ecx*4]
	test	edx, edx
	jns	SHORT $LN141@edge_force@2
	fadd	QWORD PTR __real@41f0000000000000
$LN141@edge_force@2:
	fmul	QWORD PTR _g$[ebp]

; 242  :         }
; 243  :         else

	jmp	$LN89@edge_force@2
$LN8@edge_force@2:

; 244  :           for ( f = fp = 0.0, k = 0 ; k < SDIM ; k++ )

	xor	edx, edx
	fld	ST(1)
	fld	ST(2)
	test	esi, esi
	jle	$LN89@edge_force@2
	mov	ecx, DWORD PTR tv2128[ebp]
	mov	edi, DWORD PTR tv2156[ebp]
	mov	DWORD PTR tv2038[ebp], ecx
	add	edi, eax
$LN86@edge_force@2:

; 245  :           { for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _v$[ebp+edx*4]
	fild	DWORD PTR _v$[ebp+edx*4]
	xor	eax, eax
	test	ecx, ecx
	jns	SHORT $LN142@edge_force@2
	fadd	QWORD PTR __real@41f0000000000000
$LN142@edge_force@2:
	mov	ecx, edi
$LN3@edge_force@2:

; 246  :               fp += g_partial[k][j][n]*v[k]*v[j];

	mov	ebx, DWORD PTR _v$[ebp+eax*4]
	fild	DWORD PTR _v$[ebp+eax*4]
	test	ebx, ebx
	jns	SHORT $LN143@edge_force@2
	fadd	QWORD PTR __real@41f0000000000000
$LN143@edge_force@2:
	fld	QWORD PTR [ecx]
	inc	eax
	fmul	ST(0), ST(2)
	add	ecx, 48					; 00000030H
	fmulp	ST(1), ST(0)
	faddp	ST(3), ST(0)
	cmp	eax, esi
	jl	SHORT $LN3@edge_force@2

; 247  :             f += g[n][k]*v[k];

	mov	eax, DWORD PTR tv2038[ebp]
	fmul	QWORD PTR [eax]
	inc	edx
	add	eax, 8
	add	edi, 288				; 00000120H
	faddp	ST(1), ST(0)
	mov	DWORD PTR tv2038[ebp], eax
	cmp	edx, esi
	jl	SHORT $LN86@edge_force@2

; 244  :           for ( f = fp = 0.0, k = 0 ; k < SDIM ; k++ )

	mov	edi, DWORD PTR tv2226[ebp]
	mov	eax, DWORD PTR tv2124[ebp]
	mov	ebx, DWORD PTR tv2333[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
$LN89@edge_force@2:

; 248  :           }
; 249  :           force[m][n] -= fudge*(2*sdip[m][i]*f + gcombo[m][i]*fp);

	fld	QWORD PTR _sdip[edi]
	add	DWORD PTR tv2128[ebp], 48		; 00000030H
	fadd	ST(0), ST(0)
	inc	ecx
	add	eax, 8
	mov	DWORD PTR _n$[ebp], ecx
	fmulp	ST(1), ST(0)
	mov	DWORD PTR tv2124[ebp], eax
	fld	QWORD PTR _gcombo[edi]
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(3)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	esi, DWORD PTR _web+616
	cmp	ecx, esi
	jl	$LN84@edge_force@2

; 238  :       for ( n = 0 ; n < SDIM ; n++ )

	mov	eax, DWORD PTR _m$[ebp]
$LN13@edge_force@2:

; 237  :     for ( m = 0 ; m < EDGE_CTRL ; m++ )

	inc	eax
	add	edi, 24					; 00000018H
	mov	DWORD PTR _m$[ebp], eax
	mov	DWORD PTR tv2226[ebp], edi
	cmp	eax, 3
	jl	$LN14@edge_force@2

; 244  :           for ( f = fp = 0.0, k = 0 ; k < SDIM ; k++ )

	fstp	ST(2)
	fstp	ST(1)
$LN37@edge_force@2:

; 209  :   }
; 210  :      
; 211  :   /* calculate tangents at integration points and accumulate */
; 212  :   for ( i = 0 ; i < EDGE_INTERP ; i++ )

	add	ebx, 8
	mov	DWORD PTR tv2333[ebp], ebx
	cmp	ebx, 24					; 00000018H
	jl	$LN90@edge_force@2

; 250  :      }
; 251  :   }
; 252  : 
; 253  :   return;
; 254  : } // end edge_energy_q_metric()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN107@edge_force@2:

; 237  :     for ( m = 0 ; m < EDGE_CTRL ; m++ )

	fstp	ST(0)

; 230  :         for ( len = 0.0, k = 0 ; k < SDIM ; k++ )

	jmp	SHORT $LN37@edge_force@2
_edge_force_q_metric ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@HGPFMAMK@Metric?5not?5positive?5definite?4?6?$AA@ ; `string'
PUBLIC	_pt$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_energy_metric
EXTRN	_gauss2Dwt:DWORD
EXTRN	_kb_error:PROC
EXTRN	_determinant:PROC
EXTRN	_quadratic_form:PROC
EXTRN	_det_array:DWORD
EXTRN	_metric:DWORD
EXTRN	_mat_mult:PROC
EXTRN	_gpolypartial:DWORD
EXTRN	_vec_mat_mul:PROC
EXTRN	_gpoly:DWORD
EXTRN	_ctrl_num:DWORD
EXTRN	_gauss2D_num:DWORD
EXTRN	_mat2d_setup:PROC
EXTRN	__CIpow:PROC
;	COMDAT ??_C@_0BP@HGPFMAMK@Metric?5not?5positive?5definite?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@HGPFMAMK@Metric?5not?5positive?5definite?4?6?$AA@ DB 'Metric no'
	DB	't positive definite.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _simplex_energy_metric
_TEXT	SEGMENT
_tangqXvS$ = -392					; size = 24
_area$ = -368						; size = 8
_pt$GSCopy$ = -360					; size = 4
_new_area$ = -356					; size = 8
_det$ = -356						; size = 8
tv484 = -352						; size = 4
_tang$ = -348						; size = 4
_k$ = -344						; size = 4
_tangxJ$ = -340						; size = 288
_gpt$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v$ = 8							; size = 4
_pt$ = 12						; size = 4
_simplex_energy_metric PROC				; COMDAT

; 281  : { int i,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 392				; 00000188H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 282  :   REAL gpt[MAXCOORD];
; 283  :   REAL area = 0.0;  /* total */

	fldz
	push	esi
	push	edi
	fstp	QWORD PTR _area$[ebp]
	mov	edi, DWORD PTR _pt$[ebp]

; 284  :   REAL new_area;
; 285  :   MAT2D(tang,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _tangxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tangqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _pt$GSCopy$[ebp], edi
	call	_mat2d_setup

; 286  :   REAL det;
; 287  : 
; 288  :   /* calculate integrands at integration points and accumulate */
; 289  :   for ( k = 0 ; k < gauss2D_num ; k++ )

	xor	esi, esi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tang$[ebp], eax
	mov	DWORD PTR _k$[ebp], esi
	cmp	DWORD PTR _gauss2D_num, esi
	jle	$LN43@simplex_en
	push	ebx
	jmp	SHORT $LN25@simplex_en
	npad	3
$LL50@simplex_en:
	mov	edi, DWORD PTR _pt$GSCopy$[ebp]
$LN25@simplex_en:

; 290  :   { /* get gauss pt */
; 291  :     vec_mat_mul(gpoly[k],pt,gpt,ctrl_num,SDIM);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _ctrl_num
	push	edx
	mov	edx, DWORD PTR _gpoly
	push	eax
	mov	eax, DWORD PTR [edx+esi*4]
	lea	ecx, DWORD PTR _gpt$[ebp]
	push	ecx
	push	edi
	push	eax
	call	_vec_mat_mul

; 292  : 
; 293  :     /* get tangents */
; 294  :     mat_mult(gpolypartial[k],pt,tang,web.dimension,ctrl_num, SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _ctrl_num
	mov	eax, DWORD PTR _web+620
	push	ecx
	mov	ecx, DWORD PTR _tang$[ebp]
	push	edx
	mov	edx, DWORD PTR _gpolypartial
	push	eax
	mov	eax, DWORD PTR [edx+esi*4]
	push	ecx
	push	edi
	push	eax
	call	_mat_mult
	add	esp, 44					; 0000002cH

; 295  : 
; 296  :     /* evaluate metric and fill in determinant */
; 297  :     if ( web.conformal_flag )

	cmp	DWORD PTR _web+1680, 0
	je	$LN22@simplex_en

; 298  :     { metric[0][0] = eval(&web.metric[0][0],gpt,NULLID,NULL);

	push	0
	push	0
	lea	ecx, DWORD PTR _gpt$[ebp]
	push	ecx
	push	OFFSET _web+1688
	call	_eval
	mov	edx, DWORD PTR _metric
	mov	eax, DWORD PTR [edx]
	fstp	QWORD PTR [eax]

; 299  :       for (  i = 0 ; i < web.dimension ; i++ )

	mov	ecx, DWORD PTR _web+620
	add	esp, 16					; 00000010H
	xor	edi, edi
	test	ecx, ecx
	jle	$LN49@simplex_en
$LL44@simplex_en:

; 300  :         for ( j = 0 ; j <= i ; j++ )

	xor	esi, esi
	test	edi, edi
	js	SHORT $LN20@simplex_en
	npad	9
$LL18@simplex_en:

; 301  :           det_array[i][j] = det_array[j][i] =
; 302  :                  metric[0][0]*SDIM_dot(tang[i],tang[j]);

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR _tang$[ebp]
	mov	edx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	push	eax
	call	_dot
	mov	ecx, DWORD PTR _metric
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _det_array
	fmul	QWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+esi*4]
	inc	esi
	fst	QWORD PTR [ecx+edi*8]
	mov	edx, DWORD PTR _det_array
	mov	eax, DWORD PTR [edx+edi*4]
	fstp	QWORD PTR [eax+esi*8-8]
	add	esp, 12					; 0000000cH
	cmp	esi, edi
	jle	SHORT $LL18@simplex_en

; 300  :         for ( j = 0 ; j <= i ; j++ )

	mov	ecx, DWORD PTR _web+620
$LN20@simplex_en:

; 299  :       for (  i = 0 ; i < web.dimension ; i++ )

	inc	edi
	cmp	edi, ecx
	jl	SHORT $LL44@simplex_en

; 303  :     }
; 304  :     else

	jmp	$LN54@simplex_en
$LN22@simplex_en:

; 305  :     { for (  i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN12@simplex_en
	mov	edi, OFFSET _web+1688
	mov	DWORD PTR tv484[ebp], edi
	npad	6
$LL45@simplex_en:

; 306  :         for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN13@simplex_en
$LL46@simplex_en:

; 307  :           metric[i][j] = eval(&web.metric[i][j],gpt,NULLID,NULL);

	push	0
	push	0
	lea	ecx, DWORD PTR _gpt$[ebp]
	push	ecx
	push	edi
	call	_eval
	mov	edx, DWORD PTR _metric
	mov	eax, DWORD PTR [edx+ebx*4]
	fstp	QWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	add	edi, 104				; 00000068H
	cmp	esi, eax
	jl	SHORT $LL46@simplex_en
$LN13@simplex_en:

; 305  :     { for (  i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR tv484[ebp]
	inc	ebx
	add	edi, 624				; 00000270H
	mov	DWORD PTR tv484[ebp], edi
	cmp	ebx, eax
	jl	SHORT $LL45@simplex_en
	mov	esi, DWORD PTR _k$[ebp]
$LN12@simplex_en:

; 308  :         for (  i = 0 ; i < web.dimension ; i++ )

	mov	ecx, DWORD PTR _web+620
	xor	edi, edi
	test	ecx, ecx
	jle	SHORT $LN49@simplex_en
	npad	7
$LL47@simplex_en:

; 309  :           for ( j = 0 ; j <= i ; j++ )

	xor	esi, esi
	test	edi, edi
	js	SHORT $LN7@simplex_en
	npad	10
$LL5@simplex_en:

; 310  :             det_array[i][j] = det_array[j][i] =
; 311  :                     quadratic_form(tang[i],metric,tang[j],SDIM);

	mov	edx, DWORD PTR _metric
	push	eax
	mov	eax, DWORD PTR _tang$[ebp]
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	push	eax
	call	_quadratic_form
	mov	ecx, DWORD PTR _det_array
	mov	edx, DWORD PTR [ecx+esi*4]
	fst	QWORD PTR [edx+edi*8]
	mov	eax, DWORD PTR _det_array
	mov	ecx, DWORD PTR [eax+edi*4]
	fstp	QWORD PTR [ecx+esi*8]
	mov	eax, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, edi
	jle	SHORT $LL5@simplex_en

; 309  :           for ( j = 0 ; j <= i ; j++ )

	mov	ecx, DWORD PTR _web+620
$LN7@simplex_en:

; 308  :         for (  i = 0 ; i < web.dimension ; i++ )

	inc	edi
	cmp	edi, ecx
	jl	SHORT $LL47@simplex_en
$LN54@simplex_en:
	mov	esi, DWORD PTR _k$[ebp]
$LN49@simplex_en:

; 312  :     }
; 313  :     /* evaluate determinant and add to total */
; 314  :     det = determinant(det_array,web.dimension);

	mov	edx, DWORD PTR _det_array
	push	ecx
	push	edx
	call	_determinant
	fst	QWORD PTR _det$[ebp]

; 315  :     if ( det < 0.0 )

	fldz
	add	esp, 8
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN48@simplex_en

; 316  :       kb_error(2170,"Metric not positive definite.\n",RECOVERABLE);

	push	1
	fstp	ST(0)
	push	OFFSET ??_C@_0BP@HGPFMAMK@Metric?5not?5positive?5definite?4?6?$AA@
	push	2170					; 0000087aH
	call	_kb_error
	fld	QWORD PTR _det$[ebp]
	add	esp, 12					; 0000000cH
$LN48@simplex_en:

; 317  :     new_area = gauss2Dwt[k]*sqrt(det);

	call	__CIsqrt

; 318  :     area += new_area;
; 319  :     if ( web.conformal_flag )

	cmp	DWORD PTR _web+1680, 0
	mov	eax, DWORD PTR _gauss2Dwt
	fmul	QWORD PTR [eax+esi*8]
	fst	QWORD PTR _new_area$[ebp]
	fadd	QWORD PTR _area$[ebp]
	fstp	QWORD PTR _area$[ebp]
	je	SHORT $LN24@simplex_en

; 320  :       euclidean_area += new_area/pow(metric[0][0],web.dimension/2.0)
; 321  :                                 /web.simplex_factorial;

	mov	ecx, DWORD PTR _metric
	fild	DWORD PTR _web+620
	mov	edx, DWORD PTR [ecx]
	fmul	QWORD PTR __real@3fe0000000000000
	fld	QWORD PTR [edx]
	fxch	ST(1)
	call	__CIpow
	fdivr	QWORD PTR _new_area$[ebp]
	fdiv	QWORD PTR _web+792
	fadd	QWORD PTR _euclidean_area
	fstp	QWORD PTR _euclidean_area
$LN24@simplex_en:

; 286  :   REAL det;
; 287  : 
; 288  :   /* calculate integrands at integration points and accumulate */
; 289  :   for ( k = 0 ; k < gauss2D_num ; k++ )

	inc	esi
	mov	DWORD PTR _k$[ebp], esi
	cmp	esi, DWORD PTR _gauss2D_num
	jl	$LL50@simplex_en
	pop	ebx
$LN43@simplex_en:

; 322  :   }
; 323  : 
; 324  :   area /= web.simplex_factorial;
; 325  : 
; 326  :   return area;
; 327  : } // end simplex_energy_metric()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fld	QWORD PTR _area$[ebp]
	fdiv	QWORD PTR _web+792
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_energy_metric ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@FEMFBODD@Zero?5area?5facet?4?6?$AA@	; `string'
PUBLIC	_forces$GSCopy$
PUBLIC	_pt$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_force_metric
EXTRN	_matvec_mul:PROC
EXTRN	_det_adjoint:PROC
EXTRN	_metric_partial:DWORD
;	COMDAT ??_C@_0BC@FEMFBODD@Zero?5area?5facet?4?6?$AA@
CONST	SEGMENT
??_C@_0BC@FEMFBODD@Zero?5area?5facet?4?6?$AA@ DB 'Zero area facet.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _simplex_force_metric
_TEXT	SEGMENT
_tangqXvS$ = -852					; size = 24
_area$ = -828						; size = 8
_factor$89360 = -820					; size = 8
_pt$GSCopy$ = -812					; size = 4
_forces$GSCopy$ = -808					; size = 4
_j$ = -804						; size = 4
tv619 = -800						; size = 4
_mu$ = -800						; size = 4
tv1454 = -796						; size = 4
tv1549 = -792						; size = 4
_k$ = -788						; size = 4
_tang$ = -784						; size = 4
tv1504 = -780						; size = 4
tv783 = -780						; size = 4
tv928 = -776						; size = 4
tv848 = -776						; size = 4
_i$ = -776						; size = 4
_tangxJ$ = -772						; size = 288
_vv$ = -484						; size = 288
_tempvec2$ = -196					; size = 48
_gpt$ = -148						; size = 48
_tempvec1$ = -100					; size = 48
_qsum$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v$ = 8							; size = 4
_pt$ = 12						; size = 4
_density$ = 16						; size = 8
_forces$ = 24						; size = 4
_simplex_force_metric PROC				; COMDAT

; 364  : { int i,j,k,mu,nu,m,n;

	push	ebp
	mov	ebp, esp
	sub	esp, 852				; 00000354H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 411  : 
; 412  :     for (  i = 0 ; i < web.dimension ; i++ )

	mov	eax, DWORD PTR _forces$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _pt$[ebp]
	push	esi
	push	edi
	push	6
	push	6
	lea	ecx, DWORD PTR _tangxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tangqXvS$[ebp]
	push	edx
	mov	DWORD PTR _pt$GSCopy$[ebp], ebx
	mov	DWORD PTR _forces$GSCopy$[ebp], eax
	call	_mat2d_setup
	xor	edi, edi
	add	esp, 16					; 00000010H
	mov	esi, eax
	mov	DWORD PTR _tang$[ebp], esi
	mov	DWORD PTR _k$[ebp], edi
	cmp	DWORD PTR _gauss2D_num, edi
	jle	$LN33@simplex_fo

; 365  :   REAL gpt[MAXCOORD];
; 366  :   REAL area = 0.0;  /* total */
; 367  :   REAL tempvec1[MAXCOORD],tempvec2[MAXCOORD];
; 368  :   REAL qsum[MAXCOORD];
; 369  :   REAL vv[MAXCOORD][MAXCOORD];
; 370  :   MAT2D(tang,MAXCOORD,MAXCOORD);
; 371  : 
; 372  :   /* calculate integrands at integration points and accumulate */
; 373  :   for ( k = 0 ; k < gauss2D_num ; k++ )

	mov	edx, DWORD PTR _web+616
	jmp	SHORT $LN59@simplex_fo
	npad	10
$LL110@simplex_fo:
	mov	ebx, DWORD PTR _pt$GSCopy$[ebp]
$LN59@simplex_fo:

; 374  :   { /* get gauss pt */
; 375  :     vec_mat_mul(gpoly[k],pt,gpt,ctrl_num,SDIM);

	mov	eax, DWORD PTR _ctrl_num
	push	edx
	mov	edx, DWORD PTR _gpoly
	push	eax
	mov	eax, DWORD PTR [edx+edi*4]
	lea	ecx, DWORD PTR _gpt$[ebp]
	push	ecx
	push	ebx
	push	eax
	call	_vec_mat_mul

; 376  : 
; 377  :     /* get tangents */
; 378  :     mat_mult(gpolypartial[k],pt,tang,web.dimension,ctrl_num,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _ctrl_num
	mov	eax, DWORD PTR _web+620
	push	ecx
	mov	ecx, DWORD PTR _gpolypartial
	push	edx
	mov	edx, DWORD PTR [ecx+edi*4]
	push	eax
	push	esi
	push	ebx
	push	edx
	call	_mat_mult
	add	esp, 44					; 0000002cH

; 379  : 
; 380  :     /* evaluate metric and fill in determinant */
; 381  :     if ( web.conformal_flag )

	cmp	DWORD PTR _web+1680, 0
	je	$LN56@simplex_fo

; 382  :     { eval_all(&web.metric[0][0],gpt,SDIM,&metric[0][0], 
; 383  :              metric_partial[0][0],NULLID); 

	mov	eax, DWORD PTR _metric_partial
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _metric
	mov	ecx, DWORD PTR [eax]
	push	0
	push	edx
	mov	edx, DWORD PTR _web+616
	push	ecx
	push	edx
	lea	eax, DWORD PTR _gpt$[ebp]
	push	eax
	push	OFFSET _web+1688
	call	_eval_all

; 384  :       for (  i = 0 ; i < web.dimension ; i++ )

	mov	ecx, DWORD PTR _web+620
	add	esp, 24					; 00000018H
	xor	edi, edi
	test	ecx, ecx
	jle	$LN109@simplex_fo

; 382  :     { eval_all(&web.metric[0][0],gpt,SDIM,&metric[0][0], 
; 383  :              metric_partial[0][0],NULLID); 

	lea	edx, DWORD PTR _vv$[ebp]
	mov	DWORD PTR tv848[ebp], edx
$LL108@simplex_fo:

; 385  :         for ( j = 0 ; j <= i ; j++ )

	xor	ebx, ebx
	test	edi, edi
	js	SHORT $LN54@simplex_fo
	mov	eax, DWORD PTR tv848[ebp]
	mov	DWORD PTR tv783[ebp], eax
	lea	esi, DWORD PTR _vv$[ebp+edi*8]
	npad	3
$LL52@simplex_fo:

; 386  :         { vv[i][j] = vv[j][i] = SDIM_dot(tang[i],tang[j]);

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR _tang$[ebp]
	mov	edx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	push	eax
	call	_dot
	fst	QWORD PTR [esi]

; 387  :           det_array[i][j] = det_array[j][i] = metric[0][0]*vv[i][j];

	mov	ecx, DWORD PTR _metric
	mov	eax, DWORD PTR tv783[ebp]
	mov	edx, DWORD PTR [ecx]
	fst	QWORD PTR [eax]
	fmul	QWORD PTR [edx]
	mov	ecx, DWORD PTR _det_array
	mov	edx, DWORD PTR [ecx+ebx*4]
	inc	ebx
	fst	QWORD PTR [edx+edi*8]
	mov	ecx, DWORD PTR _det_array
	mov	edx, DWORD PTR [ecx+edi*4]
	fstp	QWORD PTR [edx+ebx*8-8]
	add	eax, 8
	add	esp, 12					; 0000000cH
	add	esi, 48					; 00000030H
	mov	DWORD PTR tv783[ebp], eax
	cmp	ebx, edi
	jle	SHORT $LL52@simplex_fo

; 385  :         for ( j = 0 ; j <= i ; j++ )

	mov	ecx, DWORD PTR _web+620
	mov	esi, DWORD PTR _tang$[ebp]
$LN54@simplex_fo:

; 384  :       for (  i = 0 ; i < web.dimension ; i++ )

	add	DWORD PTR tv848[ebp], 48		; 00000030H
	inc	edi
	cmp	edi, ecx
	jl	$LL108@simplex_fo

; 388  :         }
; 389  :     }
; 390  :     else

	jmp	$LN109@simplex_fo
$LN56@simplex_fo:

; 391  :     { for (  i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN46@simplex_fo
	mov	DWORD PTR tv928[ebp], OFFSET _web+1688
$LL111@simplex_fo:

; 392  :         for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN47@simplex_fo
	mov	esi, DWORD PTR tv928[ebp]
	npad	3
$LL45@simplex_fo:

; 393  :           eval_all(&web.metric[i][j],gpt,SDIM,&metric[i][j],
; 394  :                 metric_partial[i][j],NULLID);

	mov	ecx, DWORD PTR _metric_partial
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR _metric
	push	0
	push	ecx
	mov	ecx, DWORD PTR [edx+ebx*4]
	lea	edx, DWORD PTR [ecx+edi*8]
	push	edx
	push	eax
	lea	eax, DWORD PTR _gpt$[ebp]
	push	eax
	push	esi
	call	_eval_all
	mov	eax, DWORD PTR _web+616
	inc	edi
	add	esp, 24					; 00000018H
	add	esi, 104				; 00000068H
	cmp	edi, eax
	jl	SHORT $LL45@simplex_fo

; 392  :         for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _tang$[ebp]
$LN47@simplex_fo:

; 391  :     { for (  i = 0 ; i < SDIM ; i++ )

	add	DWORD PTR tv928[ebp], 624		; 00000270H
	inc	ebx
	cmp	ebx, eax
	jl	SHORT $LL111@simplex_fo
$LN46@simplex_fo:

; 395  :         for (  i = 0 ; i < web.dimension ; i++ )

	mov	ecx, DWORD PTR _web+620
	xor	ebx, ebx
	test	ecx, ecx
	jle	SHORT $LN109@simplex_fo
	npad	5
$LL42@simplex_fo:

; 396  :           for ( j = 0 ; j <= i ; j++ )

	xor	edi, edi
	test	ebx, ebx
	js	SHORT $LN41@simplex_fo
$LL39@simplex_fo:

; 397  :             det_array[i][j] = det_array[j][i] =
; 398  :                 quadratic_form(tang[i],metric,tang[j],SDIM);

	mov	ecx, DWORD PTR [esi+edi*4]
	mov	edx, DWORD PTR _metric
	push	eax
	mov	eax, DWORD PTR [esi+ebx*4]
	push	ecx
	push	edx
	push	eax
	call	_quadratic_form
	mov	ecx, DWORD PTR _det_array
	mov	edx, DWORD PTR [ecx+edi*4]
	fst	QWORD PTR [edx+ebx*8]
	mov	eax, DWORD PTR _det_array
	mov	ecx, DWORD PTR [eax+ebx*4]
	fstp	QWORD PTR [ecx+edi*8]
	mov	eax, DWORD PTR _web+616
	inc	edi
	add	esp, 16					; 00000010H
	cmp	edi, ebx
	jle	SHORT $LL39@simplex_fo

; 396  :           for ( j = 0 ; j <= i ; j++ )

	mov	ecx, DWORD PTR _web+620
$LN41@simplex_fo:

; 395  :         for (  i = 0 ; i < web.dimension ; i++ )

	inc	ebx
	cmp	ebx, ecx
	jl	SHORT $LL42@simplex_fo
$LN109@simplex_fo:

; 399  :     }
; 400  : 
; 401  :     area = det_adjoint(det_array,web.dimension);

	mov	edx, DWORD PTR _det_array
	push	ecx
	push	edx
	call	_det_adjoint

; 402  :     /* det_array now has adjoint transpose */
; 403  :     if ( area <= 0.0 )

	fldz
	fcomp	ST(1)
	add	esp, 8
	fnstsw	ax
	test	ah, 1
	je	$LN114@simplex_fo

; 408  :       return;
; 409  :     }
; 410  :     area = sqrt(area);

	call	__CIsqrt
	fstp	QWORD PTR _area$[ebp]

; 411  : 
; 412  :     for (  i = 0 ; i < web.dimension ; i++ )

	mov	eax, DWORD PTR _web+620
	mov	edx, DWORD PTR _web+616
	xor	ecx, ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	eax, ecx
	jle	$LN58@simplex_fo

; 408  :       return;
; 409  :     }
; 410  :     area = sqrt(area);

	mov	ebx, DWORD PTR _metric
	mov	DWORD PTR tv1504[ebp], ecx
	mov	DWORD PTR tv1549[ebp], esi
$LL107@simplex_fo:

; 413  :       for ( j = 0 ; j < web.dimension ; j++ )

	xor	esi, esi
	mov	DWORD PTR _j$[ebp], esi
	test	eax, eax
	jle	$LN28@simplex_fo
	mov	eax, DWORD PTR _tang$[ebp]
	mov	DWORD PTR tv1454[ebp], eax
	npad	3
$LL102@simplex_fo:

; 414  :       { REAL factor = 
; 415  :           gauss2Dwt[k]*density*det_array[j][i]/2/area/web.simplex_factorial;
; 416  : 
; 417  :         if ( web.conformal_flag )

	cmp	DWORD PTR _web+1680, 0
	mov	ecx, DWORD PTR _det_array
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _gauss2Dwt
	mov	edi, DWORD PTR _k$[ebp]
	fld	QWORD PTR [ecx+edi*8]
	mov	ecx, DWORD PTR _i$[ebp]
	fmul	QWORD PTR _density$[ebp]
	fmul	QWORD PTR [eax+ecx*8]
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _area$[ebp]
	fdiv	QWORD PTR _web+792
	fst	QWORD PTR _factor$89360[ebp]
	je	$LN117@simplex_fo

; 418  :         { for ( m = 0 ; m < SDIM ; m++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN20@simplex_fo
$LN22@simplex_fo:

; 419  :           { tempvec1[m] = metric[0][0]*tang[i][m];

	mov	ecx, DWORD PTR tv1549[ebp]
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [ecx+eax*8]
	mov	edi, DWORD PTR [ebx]
	fmul	QWORD PTR [edi]

; 420  :             tempvec2[m] = metric[0][0]*tang[j][m];

	mov	ecx, DWORD PTR tv1454[ebp]
	inc	eax
	fstp	QWORD PTR _tempvec1$[ebp+eax*8-8]
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [ecx+eax*8-8]
	mov	edi, DWORD PTR [ebx]
	fmul	QWORD PTR [edi]
	fstp	QWORD PTR _tempvec2$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LN22@simplex_fo
$LN20@simplex_fo:

; 421  :           }
; 422  :           for ( n = 0 ; n < SDIM ; n++ )

	xor	eax, eax
	test	edx, edx
	jle	$LN105@simplex_fo

; 430  :               for ( nu = 0 ; nu < SDIM ; nu++ )

	mov	ecx, DWORD PTR _metric_partial
	mov	edi, DWORD PTR tv1504[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx]
	add	edi, esi
	lea	esi, DWORD PTR _qsum$[ebp]
	lea	edi, DWORD PTR _vv$[ebp+edi*8]
	sub	ecx, esi
$LN19@simplex_fo:

; 423  :             qsum[n] = metric_partial[0][0][n]*vv[i][j];

	lea	esi, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR _qsum$[ebp+esi]
	inc	eax
	fmul	QWORD PTR [edi]
	fstp	QWORD PTR _qsum$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LN19@simplex_fo

; 424  :         }
; 425  :         else

	mov	esi, DWORD PTR _j$[ebp]
	jmp	$LN105@simplex_fo
$LN117@simplex_fo:

; 426  :         { matvec_mul(metric,tang[i],tempvec1,SDIM,SDIM);

	mov	eax, DWORD PTR tv1549[ebp]
	fstp	ST(0)
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	edx
	lea	edx, DWORD PTR _tempvec1$[ebp]
	push	edx
	push	ecx
	push	ebx
	call	_matvec_mul

; 427  :           matvec_mul(metric,tang[j],tempvec2,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	mov	eax, DWORD PTR tv1454[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _tempvec2$[ebp]
	push	edx
	mov	edx, DWORD PTR _metric
	push	ecx
	push	edx
	call	_matvec_mul

; 428  :           for ( n = 0 ; n < SDIM ; n++ )

	mov	edx, DWORD PTR _web+616
	add	esp, 40					; 00000028H
	xor	edi, edi
	test	edx, edx
	jle	SHORT $LN100@simplex_fo
	fldz
$LN103@simplex_fo:

; 429  :             for ( qsum[n] = 0.0,mu = 0 ; mu < SDIM ; mu++ )

	xor	eax, eax
	fst	QWORD PTR _qsum$[ebp+edi*8]
	mov	DWORD PTR _mu$[ebp], eax
$LN104@simplex_fo:
	mov	ecx, DWORD PTR tv1549[ebp]
	mov	ecx, DWORD PTR [ecx]

; 430  :               for ( nu = 0 ; nu < SDIM ; nu++ )

	mov	ebx, DWORD PTR _metric_partial
	lea	esi, DWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR tv1454[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ebx+eax*4]
$LN9@simplex_fo:

; 431  :                  qsum[n] += tang[i][mu]*metric_partial[mu][nu][n]*tang[j][nu];

	mov	ebx, DWORD PTR [eax]
	fld	QWORD PTR [ebx+edi*8]
	add	eax, 4
	fmul	QWORD PTR [esi]
	add	ecx, 8
	dec	edx
	fmul	QWORD PTR [ecx-8]
	fadd	QWORD PTR _qsum$[ebp+edi*8]
	fstp	QWORD PTR _qsum$[ebp+edi*8]
	jne	SHORT $LN9@simplex_fo

; 429  :             for ( qsum[n] = 0.0,mu = 0 ; mu < SDIM ; mu++ )

	mov	eax, DWORD PTR _mu$[ebp]
	mov	edx, DWORD PTR _web+616
	inc	eax
	mov	DWORD PTR _mu$[ebp], eax
	cmp	eax, edx
	jl	SHORT $LN104@simplex_fo

; 428  :           for ( n = 0 ; n < SDIM ; n++ )

	inc	edi
	cmp	edi, edx
	jl	SHORT $LN103@simplex_fo
	mov	esi, DWORD PTR _j$[ebp]
	fstp	ST(0)
$LN100@simplex_fo:
	fld	QWORD PTR _factor$89360[ebp]
	mov	ebx, DWORD PTR _metric
$LN105@simplex_fo:

; 432  :         }
; 433  : 
; 434  :         for ( m = 0 ; m < ctrl_num ; m++ )

	xor	ecx, ecx
	cmp	DWORD PTR _ctrl_num, ecx
	jle	$LN127@simplex_fo
$LN112@simplex_fo:

; 435  :           for ( mu = 0 ; mu < SDIM ; mu++ )

	xor	eax, eax
	test	edx, edx
	jle	$LN5@simplex_fo

; 432  :         }
; 433  : 
; 434  :         for ( m = 0 ; m < ctrl_num ; m++ )

	mov	edi, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _gpolypartial
	mov	edx, DWORD PTR [edx+edi*4]
	mov	esi, DWORD PTR [edx+esi*4]
	lea	edi, DWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR _k$[ebp]
	lea	ebx, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _gpoly
	mov	edx, DWORD PTR [edx+esi*4]
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR tv619[ebp], edx
	mov	edx, DWORD PTR _forces$GSCopy$[ebp]
	mov	esi, DWORD PTR [edx+ecx*4]
$LN106@simplex_fo:

; 436  :           { forces[m][mu] -= factor* 
; 437  :                               (gpolypartial[k][j][m]*tempvec1[mu]
; 438  :                                   + gpolypartial[k][i][m]*tempvec2[mu]
; 439  :                                   + gpoly[k][m]*qsum[mu]);

	fld	QWORD PTR _tempvec2$[ebp+eax*8]
	mov	edx, DWORD PTR tv619[ebp]
	fmul	QWORD PTR [ebx]
	inc	eax
	fld	QWORD PTR _tempvec1$[ebp+eax*8-8]
	fmul	QWORD PTR [edi]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _qsum$[ebp+eax*8-8]
	fmul	QWORD PTR [edx]
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]
	mov	edx, DWORD PTR _web+616
	cmp	eax, edx
	jl	SHORT $LN106@simplex_fo

; 435  :           for ( mu = 0 ; mu < SDIM ; mu++ )

	mov	esi, DWORD PTR _j$[ebp]
$LN5@simplex_fo:

; 432  :         }
; 433  : 
; 434  :         for ( m = 0 ; m < ctrl_num ; m++ )

	inc	ecx
	cmp	ecx, DWORD PTR _ctrl_num
	jl	$LN112@simplex_fo
	mov	ebx, DWORD PTR _metric
$LN127@simplex_fo:

; 413  :       for ( j = 0 ; j < web.dimension ; j++ )

	mov	eax, DWORD PTR _web+620

; 432  :         }
; 433  : 
; 434  :         for ( m = 0 ; m < ctrl_num ; m++ )

	fstp	ST(0)
	add	DWORD PTR tv1454[ebp], 4
	inc	esi
	mov	DWORD PTR _j$[ebp], esi
	cmp	esi, eax
	jl	$LL102@simplex_fo
$LN28@simplex_fo:

; 411  : 
; 412  :     for (  i = 0 ; i < web.dimension ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	add	DWORD PTR tv1504[ebp], 6
	add	DWORD PTR tv1549[ebp], 4
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, eax
	jl	$LL107@simplex_fo
	mov	esi, DWORD PTR _tang$[ebp]
$LN58@simplex_fo:

; 365  :   REAL gpt[MAXCOORD];
; 366  :   REAL area = 0.0;  /* total */
; 367  :   REAL tempvec1[MAXCOORD],tempvec2[MAXCOORD];
; 368  :   REAL qsum[MAXCOORD];
; 369  :   REAL vv[MAXCOORD][MAXCOORD];
; 370  :   MAT2D(tang,MAXCOORD,MAXCOORD);
; 371  : 
; 372  :   /* calculate integrands at integration points and accumulate */
; 373  :   for ( k = 0 ; k < gauss2D_num ; k++ )

	mov	edi, DWORD PTR _k$[ebp]
	inc	edi
	mov	DWORD PTR _k$[ebp], edi
	cmp	edi, DWORD PTR _gauss2D_num
	jl	$LL110@simplex_fo
	pop	edi
	pop	esi
	pop	ebx

; 440  :           }
; 441  :       } 
; 442  :     }
; 443  : 
; 444  :   return;
; 445  : } // end simplex_force_metric()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN114@simplex_fo:

; 404  :     { kb_error(1581,"Zero area facet.\n",WARNING);

	push	2
	fstp	ST(0)
	push	OFFSET ??_C@_0BC@FEMFBODD@Zero?5area?5facet?4?6?$AA@
	push	1581					; 0000062dH
	call	_kb_error

; 405  :       for ( m = 0 ; m < ctrl_num ; m++ )

	xor	esi, esi
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _ctrl_num, esi
	jle	SHORT $LN33@simplex_fo
	mov	edx, DWORD PTR _web+616
	fldz
	mov	edi, DWORD PTR _forces$GSCopy$[ebp]
$LN35@simplex_fo:

; 406  :         for ( mu = 0 ; mu < SDIM ; mu++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN34@simplex_fo

; 405  :       for ( m = 0 ; m < ctrl_num ; m++ )

	mov	eax, DWORD PTR [edi+esi*4]
$LN32@simplex_fo:

; 407  :           forces[m][mu] = 0.0;

	fst	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	inc	ecx
	add	eax, 8
	cmp	ecx, edx
	jl	SHORT $LN32@simplex_fo
$LN34@simplex_fo:

; 405  :       for ( m = 0 ; m < ctrl_num ; m++ )

	inc	esi
	cmp	esi, DWORD PTR _ctrl_num
	jl	SHORT $LN35@simplex_fo
	fstp	ST(0)
$LN33@simplex_fo:

; 440  :           }
; 441  :       } 
; 442  :     }
; 443  : 
; 444  :   return;
; 445  : } // end simplex_force_metric()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_force_metric ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@HDIJLAFN@Metric?5evaluates?5to?5zero?4?6?$AA@ ; `string'
PUBLIC	_f$GSCopy$
PUBLIC	_x$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_metric_form_to_vector
EXTRN	_mat_inv:PROC
EXTRN	_klein_metric_flag:DWORD
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0BL@HDIJLAFN@Metric?5evaluates?5to?5zero?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@HDIJLAFN@Metric?5evaluates?5to?5zero?4?6?$AA@ DB 'Metric evalua'
	DB	'tes to zero.', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _metric_form_to_vector
_TEXT	SEGMENT
_rr$ = -68						; size = 8
_f$GSCopy$ = -64					; size = 4
_x$GSCopy$ = -60					; size = 4
tv381 = -56						; size = 4
_temp$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_f$ = 12						; size = 4
_metric_form_to_vector PROC				; COMDAT

; 459  : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 460  :   REAL temp[MAXCOORD];
; 461  :   REAL rr,rf;
; 462  : 
; 463  :   if ( klein_metric_flag )

	cmp	DWORD PTR _klein_metric_flag, 0
	push	esi
	mov	esi, DWORD PTR _x$[ebp]
	push	edi
	mov	edi, DWORD PTR _f$[ebp]

; 478  :     return;
; 479  :   }
; 480  : 
; 481  :   /* if here, have general metric */
; 482  :   for (  i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _x$GSCopy$[ebp], esi
	mov	DWORD PTR _f$GSCopy$[ebp], edi
	je	SHORT $LN16@metric_for

; 464  :   { /* M^-1 = (I - rxr)*(1-r^2) */
; 465  :     rr = SDIM_dot(x,x);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	esi
	push	esi
	call	_dot
	fstp	QWORD PTR _rr$[ebp]

; 466  :     rf = SDIM_dot(x,f);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	push	edi
	push	esi
	call	_dot

; 467  :     for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	add	esp, 24					; 00000018H
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN37@metric_for
	fld1
	mov	eax, edi
	fsub	QWORD PTR _rr$[ebp]
	sub	esi, edi
$LN15@metric_for:

; 468  :       f[j] = (f[j] - x[j]*rf)*(1-rr);

	fld	QWORD PTR [esi+eax]
	inc	ecx
	fmul	ST(0), ST(2)
	add	eax, 8
	fsubr	QWORD PTR [eax-8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN15@metric_for

; 467  :     for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
$LN37@metric_for:
	pop	edi

; 476  :     else for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
	pop	esi

; 488  : 
; 489  : } // end metric_form_to_vector()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@metric_for:

; 469  :     return;
; 470  :   }
; 471  : 
; 472  :   if ( web.conformal_flag )

	cmp	DWORD PTR _web+1680, 0
	je	SHORT $LN12@metric_for

; 473  :   { REAL gg = eval(&web.metric[0][0],x,NULLID,NULL);

	push	0
	push	0
	push	esi
	push	OFFSET _web+1688
	call	_eval

; 474  :     if ( gg == 0.0 )

	fld	ST(0)
	fldz
	add	esp, 16					; 00000010H
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@metric_for

; 475  :       kb_error(1343,"Metric evaluates to zero.\n",WARNING);

	push	2
	fstp	ST(0)
	push	OFFSET ??_C@_0BL@HDIJLAFN@Metric?5evaluates?5to?5zero?4?6?$AA@
	push	1343					; 0000053fH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 488  : 
; 489  : } // end metric_form_to_vector()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@metric_for:

; 476  :     else for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN37@metric_for
$LN9@metric_for:

; 477  :       f[j] /= gg;

	fld	QWORD PTR [edi+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [edi+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN9@metric_for

; 476  :     else for ( j = 0 ; j < SDIM ; j++ )

	pop	edi
	fstp	ST(0)
	pop	esi

; 488  : 
; 489  : } // end metric_form_to_vector()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@metric_for:

; 478  :     return;
; 479  :   }
; 480  : 
; 481  :   /* if here, have general metric */
; 482  :   for (  i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	push	ebx
	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN4@metric_for
	mov	DWORD PTR tv381[ebp], OFFSET _web+1688
$LL27@metric_for:

; 483  :      for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN5@metric_for
	mov	edi, DWORD PTR tv381[ebp]
$LL3@metric_for:

; 484  :          metric[i][j] = eval(&web.metric[i][j],x,NULLID,NULL);

	mov	edx, DWORD PTR _x$GSCopy$[ebp]
	push	0
	push	0
	push	edx
	push	edi
	call	_eval
	mov	eax, DWORD PTR _metric
	mov	ecx, DWORD PTR [eax+ebx*4]
	fstp	QWORD PTR [ecx+esi*8]
	mov	eax, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	add	edi, 104				; 00000068H
	cmp	esi, eax
	jl	SHORT $LL3@metric_for

; 483  :      for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _f$GSCopy$[ebp]
$LN5@metric_for:

; 478  :     return;
; 479  :   }
; 480  : 
; 481  :   /* if here, have general metric */
; 482  :   for (  i = 0 ; i < SDIM ; i++ )

	add	DWORD PTR tv381[ebp], 624		; 00000270H
	inc	ebx
	cmp	ebx, eax
	jl	SHORT $LL27@metric_for
$LN4@metric_for:

; 485  :   mat_inv(metric,SDIM);

	mov	edx, DWORD PTR _metric
	push	eax
	push	edx
	call	_mat_inv

; 486  :   matvec_mul(metric,f,temp,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _metric
	push	eax
	push	eax
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	push	edi
	push	ecx
	call	_matvec_mul

; 487  :   memcpy((char*)f,(char*)temp,SDIM*sizeof(REAL));

	mov	edx, DWORD PTR _web+616
	lea	eax, DWORD PTR [edx*8]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	push	edi
	call	_memcpy

; 488  : 
; 489  : } // end metric_form_to_vector()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 40					; 00000028H
	pop	ebx
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_metric_form_to_vector ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FF@FIEBPPJF@Cannot?5use?5metric_facet_area?5or?5@ ; `string'
PUBLIC	_metric_area_init
;	COMDAT ??_C@_0FF@FIEBPPJF@Cannot?5use?5metric_facet_area?5or?5@
CONST	SEGMENT
??_C@_0FF@FIEBPPJF@Cannot?5use?5metric_facet_area?5or?5@ DB 'Cannot use m'
	DB	'etric_facet_area or metric_edge_length method without a gener'
	DB	'al metric.', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _metric_area_init
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_metric_area_init PROC					; COMDAT

; 510  : { if ( web.conformal_flag || !web.metric_flag )

	cmp	DWORD PTR _web+1680, 0
	jne	SHORT $LN1@metric_are
	cmp	DWORD PTR _web+1676, 0
	jne	SHORT $LN2@metric_are
$LN1@metric_are:

; 511  :      kb_error(1583,"Cannot use metric_facet_area or metric_edge_length method without a general metric.\n",
; 512  :       RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0FF@FIEBPPJF@Cannot?5use?5metric_facet_area?5or?5@
	push	1583					; 0000062fH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN2@metric_are:

; 513  : } // end metric_area_init()

	ret	0
_metric_area_init ENDP
_TEXT	ENDS
PUBLIC	__real@4000000000000000
PUBLIC	??_C@_08PEEPBNBH@METRIC?4C?$AA@			; `string'
PUBLIC	??_C@_0CN@EFAJANK@Metric_area?5method?5only?5for?5edge@ ; `string'
PUBLIC	_q_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_metric_area_all
EXTRN	_free_matrix:PROC
EXTRN	_free_matrix4:PROC
EXTRN	_proc_total_area:BYTE
EXTRN	_win_get_thread_data:PROC
EXTRN	_thread_data_key:DWORD
EXTRN	_nprocs:DWORD
EXTRN	_quantities_only_flag:DWORD
EXTRN	_eval_second:PROC
EXTRN	_kb_dmatrix4:PROC
EXTRN	_kb_dmatrix:PROC
EXTRN	_meth_inst_list:DWORD
EXTRN	_mat3d_setup:PROC
EXTRN	_mat4d_setup:PROC
EXTRN	_gauss_lagrange:BYTE
EXTRN	__chkstk:PROC
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT ??_C@_08PEEPBNBH@METRIC?4C?$AA@
CONST	SEGMENT
??_C@_08PEEPBNBH@METRIC?4C?$AA@ DB 'METRIC.C', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EFAJANK@Metric_area?5method?5only?5for?5edge@
CONST	SEGMENT
??_C@_0CN@EFAJANK@Metric_area?5method?5only?5for?5edge@ DB 'Metric_area m'
	DB	'ethod only for edge and facet.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _metric_area_all
_TEXT	SEGMENT
_metric_secondqXvS$ = -25824				; size = 1032
_TDDGTqXvS$ = -24792					; size = 1032
_DGTqXvS$ = -23760					; size = 168
_adjAqXvS$ = -23592					; size = 24
_GTqXvS$ = -23568					; size = 24
_dAqXvS$ = -23544					; size = 24
_det$ = -23520						; size = 8
_value$ = -23512					; size = 8
_factor$ = -23504					; size = 8
tv4189 = -23496						; size = 4
tv4197 = -23492						; size = 4
tv4193 = -23488						; size = 4
_grad$ = -23484						; size = 4
_gl$ = -23480						; size = 4
_TDDGT$ = -23476					; size = 4
_GT$ = -23472						; size = 4
_density$ = -23468					; size = 8
_DGT$ = -23460						; size = 4
tv1404 = -23456						; size = 8
_wt$89507 = -23456					; size = 8
tv4481 = -23452						; size = 4
tv3787 = -23448						; size = 4
tv1444 = -23448						; size = 4
_gpp$ = -23444						; size = 4
_gp$ = -23440						; size = 4
tv2693 = -23436						; size = 4
tv1294 = -23436						; size = 4
_DdetA$ = -23432					; size = 4
_area$ = -23428						; size = 8
tv5388 = -23424						; size = 4
tv1432 = -23420						; size = 4
tv1282 = -23420						; size = 4
_metric_second$ = -23416				; size = 4
_dA$ = -23412						; size = 4
tv5233 = -23408						; size = 4
_gpts$ = -23408						; size = 4
tv4108 = -23404						; size = 4
tv2657 = -23404						; size = 4
_k$ = -23400						; size = 4
tv4820 = -23396						; size = 4
tv2698 = -23396						; size = 4
tv1427 = -23396						; size = 4
_adjA$ = -23392						; size = 4
_adjAdA$ = -23388					; size = 4
tv3442 = -23384						; size = 4
tv3206 = -23384						; size = 4
tv1436 = -23384						; size = 4
tv1290 = -23384						; size = 4
tv4834 = -23380						; size = 4
tv3202 = -23380						; size = 4
tv3006 = -23380						; size = 4
tv1278 = -23380						; size = 4
_q_info$GSCopy$ = -23376				; size = 4
tv4455 = -23372						; size = 4
tv3140 = -23372						; size = 4
tv3003 = -23372						; size = 4
_cpts$ = -23368						; size = 4
tv2793 = -23364						; size = 4
tv2515 = -23364						; size = 4
tv2287 = -23364						; size = 4
tv1955 = -23364						; size = 4
tv1547 = -23364						; size = 4
tv305 = -23364						; size = 4
tv3419 = -23360						; size = 4
_tang$89506 = -23360					; size = 4
tv2979 = -23356						; size = 4
_a$ = -23356						; size = 4
tv1946 = -23352						; size = 4
_m$ = -23352						; size = 4
_j$ = -23352						; size = 4
tv3545 = -23348						; size = 4
tv2764 = -23348						; size = 4
tv1544 = -23348						; size = 4
_mu$ = -23348						; size = 4
tv4172 = -23344						; size = 4
tv3181 = -23344						; size = 4
tv2561 = -23344						; size = 4
tv2436 = -23344						; size = 4
tv2273 = -23344						; size = 4
_gpt$ = -23344						; size = 4
tv2498 = -23340						; size = 4
tv2311 = -23340						; size = 4
tv2140 = -23340						; size = 4
tv1623 = -23340						; size = 4
tv522 = -23340						; size = 4
_b$ = -23340						; size = 4
_i$ = -23336						; size = 4
_metric_secondxJ$ = -23332				; size = 10368
_DGTxJ$ = -12964					; size = 1728
_TDDGTxJ$ = -11236					; size = 10368
_dAxJ$ = -868						; size = 288
_GTxJ$ = -580						; size = 288
_adjAxJ$ = -292						; size = 288
__$ArrayPad$ = -4					; size = 4
_q_info$ = 8						; size = 4
_mode$ = 12						; size = 4
_metric_area_all PROC					; COMDAT

; 537  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 25824				; 000064e0H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 538  :   REAL density=0.0;  /* surface tension of facet */
; 539  :   REAL **grad = q_info->grad;
; 540  :   int i,j,k,mu,nu,m,n;
; 541  :   REAL *gpt;
; 542  :   REAL area = 0.0;  /* total */
; 543  :   REAL value = 0.0;
; 544  :   struct gauss_lag *gl = (web.modeltype == LAGRANGE) ? 
; 545  :        &gauss_lagrange[web.dimension][web.gauss2D_order] : NULL;

	cmp	DWORD PTR _web+628, 3
	fldz
	push	ebx
	fst	QWORD PTR _density$[ebp]
	mov	ebx, DWORD PTR _q_info$[ebp]
	fstp	QWORD PTR _value$[ebp]
	mov	eax, DWORD PTR [ebx+1336]
	push	esi
	push	edi

; 580  : 
; 581  :   /* calculate integrands at integration points and accumulate */
; 582  :   for ( k = 0 ; k < gpts ; k++ )

	mov	DWORD PTR _q_info$GSCopy$[ebp], ebx
	mov	DWORD PTR _grad$[ebp], eax
	jne	SHORT $LN136@metric_are@2

; 538  :   REAL density=0.0;  /* surface tension of facet */
; 539  :   REAL **grad = q_info->grad;
; 540  :   int i,j,k,mu,nu,m,n;
; 541  :   REAL *gpt;
; 542  :   REAL area = 0.0;  /* total */
; 543  :   REAL value = 0.0;
; 544  :   struct gauss_lag *gl = (web.modeltype == LAGRANGE) ? 
; 545  :        &gauss_lagrange[web.dimension][web.gauss2D_order] : NULL;

	mov	eax, DWORD PTR _web+1596
	mov	ecx, DWORD PTR _web+620
	shl	eax, 5
	add	eax, DWORD PTR _gauss_lagrange[ecx*4]

; 546  :   int cpts = (web.modeltype == LAGRANGE) ? gl->lagpts : ctrl_num;

	mov	esi, DWORD PTR [eax+16]

; 547  :   int gpts = (web.modeltype == LAGRANGE) ? gl->gnumpts : gauss2D_num;

	mov	edi, DWORD PTR [eax+4]

; 548  :   REAL **gp = (web.modeltype == LAGRANGE) ? gl->gpoly : gpoly;

	mov	edx, DWORD PTR [eax+20]

; 549  :   REAL ***gpp = (web.modeltype == LAGRANGE) ? gl->gpolypart : gpolypartial;

	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _gl$[ebp], eax
	mov	DWORD PTR _cpts$[ebp], esi
	mov	DWORD PTR _gpts$[ebp], edi
	mov	DWORD PTR _gp$[ebp], edx
	mov	DWORD PTR _gpp$[ebp], ecx
	jmp	SHORT $LN145@metric_are@2
$LN136@metric_are@2:

; 546  :   int cpts = (web.modeltype == LAGRANGE) ? gl->lagpts : ctrl_num;

	mov	esi, DWORD PTR _ctrl_num

; 547  :   int gpts = (web.modeltype == LAGRANGE) ? gl->gnumpts : gauss2D_num;

	mov	edi, DWORD PTR _gauss2D_num

; 548  :   REAL **gp = (web.modeltype == LAGRANGE) ? gl->gpoly : gpoly;

	mov	eax, DWORD PTR _gpoly

; 549  :   REAL ***gpp = (web.modeltype == LAGRANGE) ? gl->gpolypart : gpolypartial;

	mov	edx, DWORD PTR _gpolypartial
	mov	DWORD PTR _gl$[ebp], 0
	mov	DWORD PTR _cpts$[ebp], esi
	mov	DWORD PTR _gpts$[ebp], edi
	mov	DWORD PTR _gp$[ebp], eax
	mov	DWORD PTR _gpp$[ebp], edx
$LN145@metric_are@2:

; 550  : 
; 551  :   MAT4D(metric_second,MAXCOORD,MAXCOORD,MAXCOORD,MAXCOORD);

	push	6
	push	6
	push	6
	push	6
	lea	eax, DWORD PTR _metric_secondxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _metric_secondqXvS$[ebp]
	push	ecx
	call	_mat4d_setup

; 552  :   REAL det;
; 553  :   MAT2D(adjA,MAXCOORD,MAXCOORD); /* adjoint of TGT */

	push	6
	push	6
	lea	edx, DWORD PTR _adjAxJ$[ebp]
	mov	DWORD PTR _metric_second$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _adjAqXvS$[ebp]
	push	eax
	call	_mat2d_setup

; 554  :   REAL ****adjAdA = NULL;
; 555  :   MAT2D(dA,MAXCOORD,MAXCOORD); /* derivative of TGT */

	push	6
	push	6
	lea	ecx, DWORD PTR _dAxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dAqXvS$[ebp]
	push	edx
	mov	DWORD PTR _adjA$[ebp], eax
	call	_mat2d_setup

; 556  :   REAL **DdetA = NULL; /* derivs of det */
; 557  :   MAT2D(GT,MAXCOORD,MAXCOORD); /* GT */

	push	6
	mov	DWORD PTR _dA$[ebp], eax
	push	6
	lea	eax, DWORD PTR _GTxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _GTqXvS$[ebp]
	push	ecx
	call	_mat2d_setup
	add	esp, 72					; 00000048H

; 558  :   MAT3D(DGT,MAXCOORD,MAXCOORD,MAXCOORD); /* derivative of GT */

	push	6
	push	6
	push	6
	lea	edx, DWORD PTR _DGTxJ$[ebp]
	mov	DWORD PTR _GT$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _DGTqXvS$[ebp]
	push	eax
	call	_mat3d_setup

; 559  :   MAT4D(TDDGT,MAXCOORD,MAXCOORD,MAXCOORD,MAXCOORD); /* 2nd derivative of TGT */

	push	6
	push	6
	push	6
	push	6
	lea	ecx, DWORD PTR _TDDGTxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _TDDGTqXvS$[ebp]
	push	edx
	mov	DWORD PTR _DGT$[ebp], eax
	call	_mat4d_setup

; 560  :   REAL sum,tr1,tr2,dda,factor;
; 561  :   int a,b;
; 562  : 
; 563  :   switch(id_type(q_info->id))

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR _TDDGT$[ebp], eax
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	add	esp, 44					; 0000002cH
	dec	eax
	je	SHORT $LN131@metric_are@2
	dec	eax
	je	SHORT $LN128@metric_are@2

; 572  :        else density = 1.0;
; 573  :        break;
; 574  :     default: kb_error(1584,"Metric_area method only for edge and facet.\n",
; 575  :        RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CN@EFAJANK@Metric_area?5method?5only?5for?5edge@
	push	1584					; 00000630H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN129@metric_are@2
$LN128@metric_are@2:

; 568  :        break;
; 569  :     case FACET: 
; 570  :        if ( METH_INSTANCE(q_info->method)->flags & USE_DENSITY )

	mov	eax, DWORD PTR [ebx+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	test	DWORD PTR [eax+edx+140], 536870912	; 20000000H
	je	SHORT $LN130@metric_are@2

; 571  :           density = get_facet_density(q_info->id); 

	mov	eax, DWORD PTR _web+236
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	fld	QWORD PTR [ecx+32]
	jmp	SHORT $LN379@metric_are@2
$LN131@metric_are@2:

; 564  :   { case EDGE: 
; 565  :        if ( METH_INSTANCE(q_info->method)->flags & USE_DENSITY )

	mov	eax, DWORD PTR [ebx+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	test	DWORD PTR [eax+edx+140], 536870912	; 20000000H
	je	SHORT $LN130@metric_are@2

; 566  :           density = get_edge_density(q_info->id);

	mov	eax, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	fld	QWORD PTR [ecx+40]
	jmp	SHORT $LN379@metric_are@2
$LN130@metric_are@2:

; 567  :        else density = 1.0;

	fld1
$LN379@metric_are@2:
	fstp	QWORD PTR _density$[ebp]
$LN129@metric_are@2:

; 576  :   }
; 577  : 
; 578  :   DdetA = dmatrix(0,cpts-1,0,MAXCOORD-1); /* derivs of det */

	push	578					; 00000242H
	push	OFFSET ??_C@_08PEEPBNBH@METRIC?4C?$AA@
	push	5
	push	0
	lea	edx, DWORD PTR [esi-1]
	push	edx
	push	0
	call	_kb_dmatrix

; 579  :   adjAdA = dmatrix4(cpts,cpts,MAXCOORD,MAXCOORD); /* adjoint of TGT times dA */

	push	579					; 00000243H
	push	OFFSET ??_C@_08PEEPBNBH@METRIC?4C?$AA@
	push	6
	push	6
	push	esi
	push	esi
	mov	DWORD PTR _DdetA$[ebp], eax
	call	_kb_dmatrix4

; 580  : 
; 581  :   /* calculate integrands at integration points and accumulate */
; 582  :   for ( k = 0 ; k < gpts ; k++ )

	mov	esi, DWORD PTR _web+616
	xor	ebx, ebx
	add	esp, 48					; 00000030H
	mov	DWORD PTR _adjAdA$[ebp], eax
	mov	DWORD PTR _k$[ebp], ebx
	test	edi, edi
	jle	$LN122@metric_are@2
	npad	12
$LL124@metric_are@2:

; 583  :   { REAL **tang = q_info->sides[k];
; 584  :     REAL wt = (web.modeltype == LAGRANGE) ? gl->gausswt[k] : gauss2Dwt[k];

	cmp	DWORD PTR _web+628, 3
	mov	eax, DWORD PTR _q_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax+1276]
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR _tang$89506[ebp], edx
	jne	SHORT $LN146@metric_are@2
	mov	ecx, DWORD PTR _gl$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	fld	QWORD PTR [edx+ebx*8]
	jmp	SHORT $LN380@metric_are@2
$LN146@metric_are@2:
	mov	ecx, DWORD PTR _gauss2Dwt
	fld	QWORD PTR [ecx+ebx*8]
$LN380@metric_are@2:

; 585  :     gpt = q_info->gauss_pt[k];

	mov	edx, DWORD PTR [eax+1268]
	fstp	QWORD PTR _wt$89507[ebp]
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR _gpt$[ebp], eax

; 586  : 
; 587  :     /* evaluate metric (using symmmetry) and fill in determinant */
; 588  :     for (  i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	esi, eax
	jle	$LN245@metric_are@2

; 585  :     gpt = q_info->gauss_pt[k];

	mov	DWORD PTR tv2140[ebp], eax
$LL121@metric_are@2:

; 589  :       for ( j = 0 ; j <= i ; j++ )

	xor	edi, edi
	cmp	DWORD PTR _i$[ebp], edi
	jl	$LN120@metric_are@2
	npad	2
$LL118@metric_are@2:

; 590  :       {  switch ( mode )

	mov	eax, DWORD PTR _mode$[ebp]
	cmp	eax, 1767				; 000006e7H
	je	$LN113@metric_are@2
	cmp	eax, 4321				; 000010e1H
	je	$LN112@metric_are@2
	cmp	eax, 8763				; 0000223bH
	jne	$LN117@metric_are@2

; 605  : 
; 606  :            case METHOD_HESSIAN:
; 607  :                     eval_second(&web.metric[i][j],gpt,SDIM,&metric[i][j],
; 608  :                         metric_partial[i][j],metric_second[i][j],q_info->id);

	mov	edx, DWORD PTR _q_info$GSCopy$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _metric_second$[ebp]
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [edx+edi*4]
	push	edx
	mov	edx, DWORD PTR _metric_partial
	mov	edx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [edx+edi*4]
	push	edx
	mov	edx, DWORD PTR _metric
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR tv2140[ebp]
	add	edx, edi
	imul	edx, 104				; 00000068H
	lea	ecx, DWORD PTR [edi*8]
	add	eax, ecx
	mov	ecx, DWORD PTR _gpt$[ebp]
	push	eax
	push	esi
	push	ecx
	add	edx, OFFSET _web+1688
	push	edx
	call	_eval_second
	add	esp, 28					; 0000001cH

; 609  :                     if ( i != j )

	cmp	DWORD PTR _i$[ebp], edi
	je	$LN224@metric_are@2

; 610  :                     { metric[j][i] = metric[i][j];

	mov	ecx, DWORD PTR _metric
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [ecx+edi*4]
	fld	QWORD PTR [edx+edi*8]
	fstp	QWORD PTR [ecx+eax*8]

; 611  :                       for ( mu = 0 ; mu < SDIM ; mu++ )

	mov	esi, DWORD PTR _web+616
	mov	DWORD PTR _mu$[ebp], 0
	test	esi, esi
	jle	$LN117@metric_are@2

; 610  :                     { metric[j][i] = metric[i][j];

	mov	ecx, DWORD PTR _metric_partial
	mov	eax, DWORD PTR [ecx+edi*4]
	mov	edx, DWORD PTR _i$[ebp]

; 611  :                       for ( mu = 0 ; mu < SDIM ; mu++ )

	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR [ecx+edi*4]
	sub	ecx, eax
	mov	DWORD PTR tv1946[ebp], eax
	mov	DWORD PTR tv1955[ebp], ecx
	jmp	SHORT $LN105@metric_are@2
	npad	10
$LL252@metric_are@2:
	mov	ecx, DWORD PTR tv1955[ebp]
$LN105@metric_are@2:

; 612  :                       { metric_partial[j][i][mu] = metric_partial[i][j][mu];

	fld	QWORD PTR [ecx+eax]

; 613  :                          for ( nu = 0 ; nu < SDIM ; nu++ )

	xor	ecx, ecx
	fstp	QWORD PTR [eax]
	mov	esi, DWORD PTR _web+616
	test	esi, esi
	jle	SHORT $LN104@metric_are@2

; 612  :                       { metric_partial[j][i][mu] = metric_partial[i][j][mu];

	mov	eax, DWORD PTR _metric_second$[ebp]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	esi, DWORD PTR _mu$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]

; 613  :                          for ( nu = 0 ; nu < SDIM ; nu++ )

	mov	esi, DWORD PTR _metric_second$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	esi, DWORD PTR _mu$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	sub	edx, eax
$LL102@metric_are@2:

; 614  :                             metric_second[j][i][mu][nu] = metric_second[i][j][mu][nu];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	mov	esi, DWORD PTR _web+616
	add	eax, 8
	cmp	ecx, esi
	jl	SHORT $LL102@metric_are@2

; 613  :                          for ( nu = 0 ; nu < SDIM ; nu++ )

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR tv1946[ebp]
$LN104@metric_are@2:

; 611  :                       for ( mu = 0 ; mu < SDIM ; mu++ )

	inc	DWORD PTR _mu$[ebp]
	add	eax, 8
	mov	DWORD PTR tv1946[ebp], eax
	cmp	DWORD PTR _mu$[ebp], esi
	jl	SHORT $LL252@metric_are@2

; 615  :                       }
; 616  :                     }
; 617  :                     break;

	jmp	$LN117@metric_are@2
$LN112@metric_are@2:

; 594  :                     break;
; 595  : 
; 596  :            case METHOD_GRADIENT:
; 597  :                     eval_all(&web.metric[i][j],gpt,SDIM,&metric[i][j],
; 598  :                          metric_partial[i][j],q_info->id);

	mov	eax, DWORD PTR _q_info$GSCopy$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR _i$[ebp]
	push	edx
	mov	edx, DWORD PTR _metric_partial
	mov	edx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [edx+edi*4]
	push	edx
	mov	edx, DWORD PTR _metric
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR tv2140[ebp]
	add	edx, edi
	imul	edx, 104				; 00000068H
	lea	ecx, DWORD PTR [edi*8]
	add	eax, ecx
	mov	ecx, DWORD PTR _gpt$[ebp]
	push	eax
	push	esi
	push	ecx
	add	edx, OFFSET _web+1688
	push	edx
	call	_eval_all
	add	esp, 24					; 00000018H

; 599  :                     if ( i != j )

	cmp	DWORD PTR _i$[ebp], edi
	je	$LN224@metric_are@2

; 600  :                     { metric[j][i] = metric[i][j];

	mov	ecx, DWORD PTR _metric
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [ecx+edi*4]
	fld	QWORD PTR [edx+edi*8]
	fstp	QWORD PTR [ecx+eax*8]

; 601  :                       for ( mu = 0 ; mu < SDIM ; mu++ )

	mov	esi, DWORD PTR _web+616
	xor	ecx, ecx
	test	esi, esi
	jle	$LN117@metric_are@2

; 600  :                     { metric[j][i] = metric[i][j];

	mov	esi, DWORD PTR _metric_partial
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [esi+edi*4]
	mov	eax, DWORD PTR [eax+edx*4]

; 601  :                       for ( mu = 0 ; mu < SDIM ; mu++ )

	mov	edx, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR [edx+edi*4]
	sub	edx, eax
	npad	3
$LL110@metric_are@2:

; 602  :                          metric_partial[j][i][mu] = metric_partial[i][j][mu];

	fld	QWORD PTR [eax+edx]
	inc	ecx
	fstp	QWORD PTR [eax]
	mov	esi, DWORD PTR _web+616
	add	eax, 8
	cmp	ecx, esi
	jl	SHORT $LL110@metric_are@2

; 603  :                     }
; 604  :                     break;

	jmp	SHORT $LN117@metric_are@2
$LN113@metric_are@2:

; 591  :          { case METHOD_VALUE:
; 592  :                     metric[i][j] = eval(&web.metric[i][j],gpt,q_info->id,NULL);

	mov	eax, DWORD PTR _q_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR tv2140[ebp]
	mov	edx, DWORD PTR _gpt$[ebp]
	add	eax, edi
	imul	eax, 104				; 00000068H
	push	0
	push	ecx
	push	edx
	add	eax, OFFSET _web+1688
	push	eax
	call	_eval
	mov	ecx, DWORD PTR _metric
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	add	esp, 16					; 00000010H
	fst	QWORD PTR [edx+edi*8]

; 593  :                     metric[j][i] = metric[i][j];

	mov	ecx, DWORD PTR _metric
	mov	edx, DWORD PTR [ecx+edi*4]
	fstp	QWORD PTR [edx+eax*8]
$LN224@metric_are@2:
	mov	esi, DWORD PTR _web+616
$LN117@metric_are@2:

; 589  :       for ( j = 0 ; j <= i ; j++ )

	inc	edi
	cmp	edi, DWORD PTR _i$[ebp]
	jle	$LL118@metric_are@2
$LN120@metric_are@2:

; 586  : 
; 587  :     /* evaluate metric (using symmmetry) and fill in determinant */
; 588  :     for (  i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv2140[ebp], 6
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, esi
	jl	$LL121@metric_are@2
$LN245@metric_are@2:

; 618  :          }
; 619  :        }
; 620  : 
; 621  :       for (  i = 0 ; i < web.dimension ; i++ )

	xor	eax, eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _web+620, eax
	jle	$LN97@metric_are@2
	mov	edx, DWORD PTR _adjA$[ebp]
	mov	ecx, DWORD PTR _tang$89506[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv2311[ebp], edx
	mov	DWORD PTR tv2287[ebp], ecx
	npad	5
$LL99@metric_are@2:

; 622  :         for ( j = 0 ; j <= i ; j++ )

	xor	edi, edi
	test	eax, eax
	js	SHORT $LN98@metric_are@2
	mov	eax, DWORD PTR _adjA$[ebp]
	mov	DWORD PTR tv2273[ebp], eax
	npad	14
$LL225@metric_are@2:

; 623  :            adjA[i][j] = adjA[j][i] =
; 624  :                     quadratic_form(tang[i],metric,tang[j],SDIM);

	mov	eax, DWORD PTR tv2287[ebp]
	mov	ecx, DWORD PTR tv2273[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _metric
	push	esi
	push	edx
	mov	edx, DWORD PTR tv2311[ebp]
	mov	eax, DWORD PTR [edx+eax]
	push	ecx
	push	eax
	call	_quadratic_form
	mov	ecx, DWORD PTR tv2273[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$[ebp]
	fst	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR tv2311[ebp]
	mov	edx, DWORD PTR [edx]
	fstp	QWORD PTR [edx+edi*8]
	mov	esi, DWORD PTR _web+616
	inc	edi
	add	ecx, 4
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv2273[ebp], ecx
	cmp	edi, eax
	jle	SHORT $LL225@metric_are@2
$LN98@metric_are@2:

; 618  :          }
; 619  :        }
; 620  : 
; 621  :       for (  i = 0 ; i < web.dimension ; i++ )

	add	DWORD PTR tv2311[ebp], 4
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _web+620
	jl	$LL99@metric_are@2
$LN97@metric_are@2:

; 625  : 
; 626  :       det = det_adjoint(adjA,web.dimension);

	mov	eax, DWORD PTR _web+620
	mov	ecx, DWORD PTR _adjA$[ebp]
	push	eax
	push	ecx
	call	_det_adjoint
	fst	QWORD PTR _det$[ebp]

; 627  :       if ( det <= 0.0 ) continue;

	fldz
	add	esp, 8
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 1
	je	$LN257@metric_are@2

; 628  :       area = sqrt(det);

	call	__CIsqrt
	fst	QWORD PTR _area$[ebp]

; 629  :       value += wt*area;
; 630  :       if ( mode == METHOD_VALUE ) continue;

	cmp	DWORD PTR _mode$[ebp], 1767		; 000006e7H
	fld	QWORD PTR _wt$89507[ebp]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _value$[ebp]
	fstp	QWORD PTR _value$[ebp]
	je	$LN257@metric_are@2

; 631  : 
; 632  :       /* adjA now has adjoint transpose (but assuming symmetry) */
; 633  : 
; 634  :       /* get some useful products */
; 635  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _web+616
	mov	DWORD PTR _i$[ebp], 0
	test	esi, esi
	jle	SHORT $LN227@metric_are@2
	fstp	ST(0)
$LN91@metric_are@2:

; 636  :         for ( a = 0 ; a < web.dimension ; a++ )

	xor	edi, edi
	cmp	DWORD PTR _web+620, edi
	jle	SHORT $LN90@metric_are@2
	npad	6
$LL226@metric_are@2:

; 637  :            GT[i][a] = SDIM_dot(metric[i],tang[a]);

	mov	edx, DWORD PTR _tang$89506[ebp]
	mov	eax, DWORD PTR [edx+edi*4]
	mov	ecx, DWORD PTR _metric
	mov	edx, DWORD PTR _i$[ebp]
	push	esi
	push	eax
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_dot
	mov	ecx, DWORD PTR _GT$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	fstp	QWORD PTR [eax+edi*8]
	mov	esi, DWORD PTR _web+616
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR _web+620
	jl	SHORT $LL226@metric_are@2
$LN90@metric_are@2:

; 631  : 
; 632  :       /* adjA now has adjoint transpose (but assuming symmetry) */
; 633  : 
; 634  :       /* get some useful products */
; 635  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, esi
	jl	SHORT $LN91@metric_are@2
	fld	QWORD PTR _area$[ebp]
$LN227@metric_are@2:

; 638  :       for ( i = 0 ; i < SDIM ; i++ )

	fldz
	mov	DWORD PTR _i$[ebp], 0
	test	esi, esi
	jle	$LN83@metric_are@2
	mov	edi, DWORD PTR _metric_partial
	mov	ecx, DWORD PTR _DGT$[ebp]
	sub	ecx, edi
	mov	DWORD PTR tv2498[ebp], edi
	mov	DWORD PTR tv2515[ebp], ecx
$LN85@metric_are@2:

; 639  :         for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	esi, esi
	jle	$LN84@metric_are@2
$LN82@metric_are@2:

; 640  :           for ( a = 0 ; a < web.dimension ; a++ )

	xor	eax, eax
	mov	DWORD PTR _a$[ebp], eax
	cmp	DWORD PTR _web+620, eax
	jle	SHORT $LN81@metric_are@2
	mov	ecx, DWORD PTR [ecx+edi]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv2436[ebp], ecx
$LN79@metric_are@2:

; 641  :           { for ( n = 0, sum = 0.0 ; n < SDIM ; n++ )

	fld	ST(0)
	test	esi, esi
	jle	SHORT $LN74@metric_are@2

; 640  :           for ( a = 0 ; a < web.dimension ; a++ )

	mov	ecx, DWORD PTR _tang$89506[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]

; 641  :           { for ( n = 0, sum = 0.0 ; n < SDIM ; n++ )

	mov	eax, DWORD PTR [edi]
$LN76@metric_are@2:

; 642  :                 sum += metric_partial[i][n][j]*tang[a][n];

	mov	edi, DWORD PTR [eax]
	fld	QWORD PTR [edi+edx*8]
	add	eax, 4
	fmul	QWORD PTR [ecx]
	add	ecx, 8
	dec	esi
	faddp	ST(1), ST(0)
	jne	SHORT $LN76@metric_are@2

; 641  :           { for ( n = 0, sum = 0.0 ; n < SDIM ; n++ )

	mov	edi, DWORD PTR tv2498[ebp]
	mov	eax, DWORD PTR _a$[ebp]
$LN74@metric_are@2:

; 643  :              DGT[i][j][a] = sum;

	mov	ecx, DWORD PTR tv2436[ebp]
	fstp	QWORD PTR [ecx]
	mov	esi, DWORD PTR _web+616
	inc	eax
	add	ecx, 8
	mov	DWORD PTR _a$[ebp], eax
	mov	DWORD PTR tv2436[ebp], ecx
	cmp	eax, DWORD PTR _web+620
	jl	SHORT $LN79@metric_are@2

; 640  :           for ( a = 0 ; a < web.dimension ; a++ )

	mov	ecx, DWORD PTR tv2515[ebp]
$LN81@metric_are@2:

; 639  :         for ( j = 0 ; j < SDIM ; j++ )

	inc	edx
	cmp	edx, esi
	jl	SHORT $LN82@metric_are@2
$LN84@metric_are@2:

; 638  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	edi, 4
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR tv2498[ebp], edi
	cmp	eax, esi
	jl	$LN85@metric_are@2
$LN83@metric_are@2:

; 644  :           }
; 645  : 
; 646  :       factor = wt*density/2/area/web.simplex_factorial;
; 647  :       /* get determinant gradients with respect to control pt coords */
; 648  :       for ( m = 0 ; m < cpts ; m++ )

	cmp	DWORD PTR _cpts$[ebp], 0
	fld	QWORD PTR _wt$89507[ebp]
	fmul	QWORD PTR _density$[ebp]
	mov	DWORD PTR _m$[ebp], 0
	fst	QWORD PTR tv1404[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(3)
	fdiv	QWORD PTR _web+792
	fstp	QWORD PTR _factor$[ebp]
	jle	$LN71@metric_are@2
	mov	eax, DWORD PTR _DdetA$[ebp]
	fstp	ST(0)
	mov	ecx, DWORD PTR _adjAdA$[ebp]
	fstp	ST(1)
	sub	ecx, eax
	mov	DWORD PTR tv3003[ebp], ecx
	mov	ecx, DWORD PTR _grad$[ebp]
	sub	ecx, eax
	mov	DWORD PTR tv2979[ebp], eax
	mov	DWORD PTR tv3006[ebp], ecx
$LN73@metric_are@2:

; 649  :         for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	esi, esi
	jle	$LN72@metric_are@2
$LN229@metric_are@2:

; 650  :         {  for ( a = 0 ; a < web.dimension ; a++ )

	xor	edx, edx
	cmp	DWORD PTR _web+620, edx
	jle	$LN306@metric_are@2
	mov	ecx, DWORD PTR _tang$89506[ebp]
	mov	eax, DWORD PTR _dA$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv2764[ebp], ecx
	mov	DWORD PTR tv2793[ebp], eax
$LN67@metric_are@2:

; 651  :              for ( b = 0 ; b <= a ; b++ )

	mov	DWORD PTR _b$[ebp], 0
	test	edx, edx
	js	$LN66@metric_are@2
	mov	eax, DWORD PTR _gpp$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edi, DWORD PTR tv2764[ebp]
	mov	DWORD PTR tv1427[ebp], eax
	mov	eax, DWORD PTR _m$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv1432[ebp], ecx
	mov	ecx, DWORD PTR _gp$[ebp]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR _GT$[ebp]
	mov	DWORD PTR tv1444[ebp], eax
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR tv2793[ebp]
	mov	ecx, DWORD PTR [ecx+edi]
	mov	edi, DWORD PTR _dA$[ebp]
	mov	DWORD PTR tv1436[ebp], eax
	sub	eax, ecx
	mov	DWORD PTR tv2693[ebp], eax
	mov	eax, DWORD PTR tv1427[ebp]
	sub	eax, edi
	mov	DWORD PTR tv2657[ebp], edi
	mov	DWORD PTR tv2698[ebp], eax
$LN64@metric_are@2:

; 653  :                for ( mu = 0 ; mu < SDIM ; mu++ )

	xor	eax, eax
	fld	ST(0)
	test	esi, esi
	jle	SHORT $LN243@metric_are@2

; 652  :              { sum = 0.0;

	mov	edi, DWORD PTR tv2764[ebp]
	mov	edi, DWORD PTR [edi]
	mov	DWORD PTR tv2561[ebp], edi
$LN242@metric_are@2:

; 654  :                   sum += tang[a][mu]*DGT[mu][i][b];

	mov	edi, DWORD PTR _DGT$[ebp]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	ebx, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR [edi+ebx*4]
	mov	ebx, DWORD PTR _b$[ebp]
	fld	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR tv2561[ebp]
	fmul	QWORD PTR [edi]
	inc	eax
	add	edi, 8
	mov	DWORD PTR tv2561[ebp], edi
	faddp	ST(1), ST(0)
	cmp	eax, esi
	jl	SHORT $LN242@metric_are@2

; 653  :                for ( mu = 0 ; mu < SDIM ; mu++ )

	mov	ebx, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR tv2657[ebp]
$LN243@metric_are@2:

; 655  :                dA[a][b] = dA[b][a] = sum*gp[k][m]
; 656  :                      + gpp[k][a][m]*GT[i][b]
; 657  :                      + gpp[k][b][m]*GT[i][a];

	mov	eax, DWORD PTR tv2693[ebp]
	fld	QWORD PTR [eax+ecx]
	mov	eax, DWORD PTR tv1432[ebp]
	fmul	QWORD PTR [eax]
	mov	eax, DWORD PTR tv1444[ebp]
	mov	esi, DWORD PTR _m$[ebp]
	fxch	ST(1)
	fmul	QWORD PTR [eax]
	mov	eax, DWORD PTR tv2698[ebp]
	mov	eax, DWORD PTR [eax+edi]
	add	edi, 4
	faddp	ST(1), ST(0)
	add	ecx, 8
	fld	QWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR tv1436[ebp]
	fmul	QWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR [edi-4]
	mov	DWORD PTR tv2657[ebp], edi
	faddp	ST(1), ST(0)
	fst	QWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR _b$[ebp]
	fstp	QWORD PTR [ecx-8]
	mov	esi, DWORD PTR _web+616
	inc	eax
	mov	DWORD PTR _b$[ebp], eax
	cmp	eax, edx
	jle	$LN64@metric_are@2
$LN66@metric_are@2:

; 650  :         {  for ( a = 0 ; a < web.dimension ; a++ )

	add	DWORD PTR tv2764[ebp], 4
	inc	edx
	cmp	edx, DWORD PTR _web+620
	jl	$LN67@metric_are@2
$LN306@metric_are@2:

; 658  :              }
; 659  :              mat_mult(adjA,dA,adjAdA[m][i],web.dimension,web.dimension,
; 660  :                  web.dimension);

	mov	eax, DWORD PTR _web+620
	fstp	ST(0)
	mov	ecx, DWORD PTR tv3003[ebp]
	mov	esi, DWORD PTR tv2979[ebp]
	mov	edx, DWORD PTR [ecx+esi]
	mov	edi, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _dA$[ebp]
	push	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR _adjA$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_mat_mult

; 661  :              /* gradient is trace */
; 662  :              for ( a = 0, sum = 0.0 ; a < web.dimension ; a++ )

	fldz
	mov	edx, DWORD PTR _web+620
	fld	ST(0)
	add	esp, 24					; 00000018H
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN244@metric_are@2

; 658  :              }
; 659  :              mat_mult(adjA,dA,adjAdA[m][i],web.dimension,web.dimension,
; 660  :                  web.dimension);

	mov	ecx, DWORD PTR tv3003[ebp]
	mov	ecx, DWORD PTR [ecx+esi]
	mov	ecx, DWORD PTR [ecx+edi*4]
$LN58@metric_are@2:

; 663  :                 sum += adjAdA[m][i][a][a];

	mov	esi, DWORD PTR [ecx]
	fadd	QWORD PTR [esi+eax*8]
	inc	eax
	add	ecx, 4
	cmp	eax, edx
	jl	SHORT $LN58@metric_are@2

; 661  :              /* gradient is trace */
; 662  :              for ( a = 0, sum = 0.0 ; a < web.dimension ; a++ )

	mov	esi, DWORD PTR tv2979[ebp]
$LN244@metric_are@2:

; 664  :              DdetA[m][i] = sum;

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR tv3006[ebp]
	fst	QWORD PTR [edx+edi*8]
	mov	ecx, DWORD PTR [eax+esi]

; 665  :              grad[m][i] += factor*sum;

	fmul	QWORD PTR _factor$[ebp]
	lea	eax, DWORD PTR [ecx+edi*8]
	inc	edi
	fadd	QWORD PTR [eax]
	mov	DWORD PTR _i$[ebp], edi
	fstp	QWORD PTR [eax]
	mov	esi, DWORD PTR _web+616
	cmp	edi, esi
	jl	$LN229@metric_are@2
$LN72@metric_are@2:

; 644  :           }
; 645  : 
; 646  :       factor = wt*density/2/area/web.simplex_factorial;
; 647  :       /* get determinant gradients with respect to control pt coords */
; 648  :       for ( m = 0 ; m < cpts ; m++ )

	mov	eax, DWORD PTR _m$[ebp]
	add	DWORD PTR tv2979[ebp], 4
	inc	eax
	mov	DWORD PTR _m$[ebp], eax
	cmp	eax, DWORD PTR _cpts$[ebp]
	jl	$LN73@metric_are@2
	fld	QWORD PTR tv1404[ebp]
	fld	QWORD PTR _area$[ebp]
	fxch	ST(2)
	fxch	ST(1)
$LN71@metric_are@2:

; 666  :           }
; 667  : 
; 668  :       if ( mode == METHOD_GRADIENT ) continue;

	cmp	DWORD PTR _mode$[ebp], 4321		; 000010e1H
	je	$LN311@metric_are@2

; 669  : 
; 670  :       /* now, second derivatives and Hessians */    
; 671  :         for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	mov	DWORD PTR _i$[ebp], edx
	test	esi, esi
	jle	$LN52@metric_are@2
$LN54@metric_are@2:

; 672  :          for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	mov	DWORD PTR _j$[ebp], edi
	test	esi, esi
	jle	$LN53@metric_are@2
$LN51@metric_are@2:

; 673  :           for ( a = 0 ; a < web.dimension ; a++ )

	cmp	DWORD PTR _web+620, 0
	mov	DWORD PTR _a$[ebp], 0
	jle	$LN50@metric_are@2
	mov	eax, DWORD PTR _tang$89506[ebp]
	mov	ecx, DWORD PTR _TDDGT$[ebp]
	sub	ecx, eax
	mov	DWORD PTR tv3181[ebp], eax
	mov	DWORD PTR tv3206[ebp], ecx
$LN48@metric_are@2:

; 674  :             for ( b = 0 ; b < web.dimension ; b++ )

	cmp	DWORD PTR _web+620, 0
	mov	DWORD PTR _b$[ebp], 0
	jle	$LN47@metric_are@2
	mov	eax, DWORD PTR tv3181[ebp]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [edx+edi*4]
	mov	DWORD PTR tv3140[ebp], eax
$LN45@metric_are@2:

; 675  :              { sum = 0.0;
; 676  :                for ( mu = 0 ; mu < SDIM ; mu++ )

	xor	eax, eax
	fld	ST(1)
	mov	DWORD PTR _mu$[ebp], eax
	test	esi, esi
	jle	SHORT $LN40@metric_are@2
$LN240@metric_are@2:
	mov	ecx, DWORD PTR tv3181[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _tang$89506[ebp]
	mov	DWORD PTR tv3202[ebp], ecx
	mov	ecx, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]

; 677  :                  for ( nu = 0 ; nu < SDIM ; nu++ )

	mov	edx, DWORD PTR _metric_second$[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, esi
$LN241@metric_are@2:

; 678  :                     sum += tang[a][mu]*metric_second[mu][nu][i][j]*tang[b][nu];

	mov	edi, DWORD PTR [eax]
	mov	ebx, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR [edi+ebx*4]
	mov	edi, DWORD PTR _j$[ebp]
	fld	QWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR tv3202[ebp]
	fmul	QWORD PTR [ebx]
	add	eax, 4
	add	ecx, 8
	dec	edx
	fmul	QWORD PTR [ecx-8]
	faddp	ST(1), ST(0)
	jne	SHORT $LN241@metric_are@2

; 675  :              { sum = 0.0;
; 676  :                for ( mu = 0 ; mu < SDIM ; mu++ )

	mov	eax, DWORD PTR _mu$[ebp]
	inc	eax
	mov	DWORD PTR _mu$[ebp], eax
	cmp	eax, esi
	jl	SHORT $LN240@metric_are@2
	mov	ebx, DWORD PTR _k$[ebp]
$LN40@metric_are@2:

; 679  :                TDDGT[a][i][j][b] = sum;

	mov	ecx, DWORD PTR tv3140[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fstp	QWORD PTR [ecx]
	mov	esi, DWORD PTR _web+616
	inc	eax
	add	ecx, 8
	mov	DWORD PTR _b$[ebp], eax
	mov	DWORD PTR tv3140[ebp], ecx
	cmp	eax, DWORD PTR _web+620
	jl	$LN45@metric_are@2

; 674  :             for ( b = 0 ; b < web.dimension ; b++ )

	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR tv3206[ebp]
$LN47@metric_are@2:

; 673  :           for ( a = 0 ; a < web.dimension ; a++ )

	inc	DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	add	DWORD PTR tv3181[ebp], 4
	cmp	eax, DWORD PTR _web+620
	jl	$LN48@metric_are@2
$LN50@metric_are@2:

; 672  :          for ( j = 0 ; j < SDIM ; j++ )

	inc	edi
	mov	DWORD PTR _j$[ebp], edi
	cmp	edi, esi
	jl	$LN51@metric_are@2
$LN53@metric_are@2:

; 669  : 
; 670  :       /* now, second derivatives and Hessians */    
; 671  :         for ( i = 0 ; i < SDIM ; i++ )

	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, esi
	jl	$LN54@metric_are@2
$LN52@metric_are@2:

; 680  :              }
; 681  :         factor = wt*density/4/area/det/web.simplex_factorial;

	fmul	QWORD PTR __real@3fd0000000000000

; 682  :         for ( m = 0 ; m < cpts ; m++ )

	xor	edx, edx
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	QWORD PTR _det$[ebp]
	fdiv	QWORD PTR _web+792
	fstp	QWORD PTR _factor$[ebp]
	cmp	DWORD PTR _cpts$[ebp], edx
	jle	$LN336@metric_are@2
	fld	QWORD PTR __real@4000000000000000
$LN36@metric_are@2:

; 683  :          for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	esi, esi
	jle	$LN35@metric_are@2
$LN33@metric_are@2:

; 684  :           for ( n = 0 ; n <= m ; n++ )

	xor	ecx, ecx
	test	edx, edx
	js	$LN32@metric_are@2
	mov	eax, DWORD PTR _DdetA$[ebp]
	sub	eax, DWORD PTR _adjAdA$[ebp]
	mov	DWORD PTR tv4455[ebp], eax
$LN237@metric_are@2:

; 685  :             for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	mov	DWORD PTR _j$[ebp], eax
	test	esi, esi
	jle	$LN29@metric_are@2

; 684  :           for ( n = 0 ; n <= m ; n++ )

	mov	esi, DWORD PTR _adjAdA$[ebp]
	fld	QWORD PTR _det$[ebp]
	mov	edi, DWORD PTR tv4455[ebp]
	fmul	ST(0), ST(1)
	lea	esi, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR [esi+edi]
	mov	edi, DWORD PTR _i$[ebp]
	lea	esi, DWORD PTR [esi+edi*8]
	mov	edi, DWORD PTR tv4455[ebp]
	mov	DWORD PTR tv5388[ebp], esi
	mov	esi, DWORD PTR _adjAdA$[ebp]
	lea	esi, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR [esi+edi]
	mov	DWORD PTR tv4481[ebp], esi

; 685  :             for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _DGT$[ebp]
	sub	esi, DWORD PTR _metric
	mov	DWORD PTR tv4108[ebp], esi
$LN232@metric_are@2:

; 686  :             { tr1 = 0.0;
; 687  :               tr2 = 0.0;
; 688  :               for ( a = 0 ; a < web.dimension ; a++ )

	xor	edi, edi
	fld	ST(2)
	fld	ST(3)
	mov	DWORD PTR _a$[ebp], edi
	cmp	DWORD PTR _web+620, edi
	jle	$LN249@metric_are@2
	mov	eax, DWORD PTR _TDDGT$[ebp]
	fstp	ST(3)
	sub	eax, DWORD PTR _adjA$[ebp]
	fstp	ST(3)
	mov	DWORD PTR tv3787[ebp], eax
$LN24@metric_are@2:
	mov	eax, DWORD PTR _gpp$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	esi, DWORD PTR _gp$[ebp]
	mov	esi, DWORD PTR [esi+ebx*4]
	fld	QWORD PTR [esi+ecx*8]
	mov	ebx, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv1544[ebp], eax
	mov	eax, DWORD PTR [eax+edi*4]
	fmul	QWORD PTR [eax+edx*8]
	mov	DWORD PTR tv1547[ebp], eax
	fld	QWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _metric
	lea	eax, DWORD PTR [eax+ebx*4]
	fmul	QWORD PTR [esi+edx*8]
	mov	ebx, DWORD PTR tv4108[ebp]
	fld	QWORD PTR [esi+edx*8]
	mov	ebx, DWORD PTR [eax+ebx]
	fmul	QWORD PTR [esi+ecx*8]
	mov	DWORD PTR tv1290[ebp], eax
	mov	eax, DWORD PTR _i$[ebp]

; 718  : #ifdef SHARED_MEMORY
; 719  :      if ( nprocs > 1 ) 

	mov	ebx, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR tv4172[ebp], ebx
	mov	ebx, DWORD PTR _metric
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR tv4108[ebp]
	mov	ebx, DWORD PTR [eax+ebx]
	mov	DWORD PTR tv1278[ebp], eax
	mov	eax, DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR tv4820[ebp], ebx
	mov	ebx, DWORD PTR tv1278[ebp]
	mov	ebx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv1282[ebp], eax
	mov	eax, DWORD PTR tv1290[ebp]
	mov	eax, DWORD PTR [eax]
	lea	eax, DWORD PTR [eax+ebx*8]
	mov	DWORD PTR tv1294[ebp], eax
	mov	eax, DWORD PTR _adjA$[ebp]
	lea	eax, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR tv4820[ebp]
	mov	DWORD PTR tv1623[ebp], eax
	mov	eax, DWORD PTR tv1544[ebp]
	mov	ebx, DWORD PTR tv1623[ebp]
	mov	DWORD PTR tv3419[ebp], eax
	mov	eax, DWORD PTR tv4172[ebp]
	sub	edi, eax
	mov	DWORD PTR tv4834[ebp], edi
	mov	edi, DWORD PTR tv3787[ebp]
	mov	edi, DWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR [edi+ebx*4]
	mov	ebx, DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR [edi+ebx*4]
	mov	edi, eax
	sub	ebx, edi
	mov	DWORD PTR tv4189[ebp], ebx
	mov	ebx, DWORD PTR tv1623[ebp]
	mov	ebx, DWORD PTR [ebx]
	sub	ebx, edi
	mov	edi, DWORD PTR _adjAdA$[ebp]
	lea	edi, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR [edi]
	mov	DWORD PTR tv4193[ebp], ebx
	mov	ebx, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR [edi+ebx*4]
	mov	ebx, DWORD PTR _a$[ebp]
	mov	edi, DWORD PTR [edi+ebx*4]
	mov	ebx, DWORD PTR _j$[ebp]
	sub	edi, eax
	mov	DWORD PTR tv4197[ebp], edi
	mov	edi, DWORD PTR _adjAdA$[ebp]
	lea	edi, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi+ebx*4]
	sub	edi, DWORD PTR tv1544[ebp]
	mov	DWORD PTR tv3545[ebp], edi
	mov	edi, DWORD PTR _web+620
	mov	DWORD PTR tv522[ebp], edi
	mov	edi, DWORD PTR _a$[ebp]
$LN239@metric_are@2:

; 690  :                 { dda  = gpp[k][a][m]*gp[k][n]*DGT[i][j][b];
; 691  :                   dda += gpp[k][a][n]*gp[k][m]*DGT[j][i][b];
; 692  :                   dda += gpp[k][b][n]*gp[k][m]*DGT[j][i][a];

	mov	ebx, DWORD PTR tv3419[ebp]
	mov	ebx, DWORD PTR [ebx]
	mov	DWORD PTR tv3442[ebp], ebx
	mov	ebx, DWORD PTR tv4834[ebp]
	fld	QWORD PTR [ebx+eax]
	mov	ebx, DWORD PTR tv3442[ebp]
	fmul	ST(0), ST(3)
	add	eax, 8
	fld	ST(2)
	fmul	QWORD PTR [eax-8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi+edx*8]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR tv4172[ebp]
	fmul	QWORD PTR [ebx+edi*8]

; 693  :                   dda += gpp[k][b][m]*gp[k][n]*DGT[i][j][a];

	mov	ebx, DWORD PTR tv3419[ebp]
	mov	ebx, DWORD PTR [ebx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR tv4820[ebp]
	fmul	QWORD PTR [esi+ecx*8]
	fmul	QWORD PTR [ebx+edi*8]

; 694  :                   dda += gpp[k][a][m]*gpp[k][b][n]*metric[i][j];

	mov	edi, DWORD PTR tv3419[ebp]
	mov	edi, DWORD PTR [edi]
	mov	ebx, DWORD PTR tv1547[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+ecx*8]
	fmul	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR tv1282[ebp]
	fmul	QWORD PTR [ebx]

; 695  :                   dda += gpp[k][a][n]*gpp[k][b][m]*metric[j][i];
; 696  :                   dda += gp[k][m]*gp[k][n]*TDDGT[a][i][j][b];
; 697  :                   tr2 += adjA[a][b]*dda;
; 698  :                   tr1 += adjAdA[m][i][a][b]*adjAdA[n][j][b][a];

	mov	ebx, DWORD PTR tv3419[ebp]
	add	DWORD PTR tv3419[ebp], 4
	dec	DWORD PTR tv522[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR tv1547[ebp]
	fmul	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR tv1294[ebp]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR tv4189[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax+edi-8]
	mov	edi, DWORD PTR tv4193[ebp]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fmul	QWORD PTR [eax+edi-8]
	mov	edi, DWORD PTR tv3545[ebp]
	mov	ebx, DWORD PTR [edi+ebx]
	mov	edi, DWORD PTR _a$[ebp]
	faddp	ST(5), ST(0)
	fld	QWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR tv4197[ebp]
	fmul	QWORD PTR [eax+ebx-8]
	faddp	ST(6), ST(0)
	jne	$LN239@metric_are@2

; 689  :                 for ( b = 0 ; b < web.dimension ; b++ )

	mov	ebx, DWORD PTR _k$[ebp]
	fstp	ST(2)
	inc	edi
	fstp	ST(0)
	fstp	ST(0)
	mov	DWORD PTR _a$[ebp], edi
	cmp	edi, DWORD PTR _web+620
	jl	$LN24@metric_are@2

; 686  :             { tr1 = 0.0;
; 687  :               tr2 = 0.0;
; 688  :               for ( a = 0 ; a < web.dimension ; a++ )

	fldz
	mov	eax, DWORD PTR _j$[ebp]
	fld	QWORD PTR __real@4000000000000000
	fxch	ST(1)
	fxch	ST(4)
	fxch	ST(1)
	fxch	ST(3)
$LN249@metric_are@2:

; 685  :             for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _q_info$GSCopy$[ebp]
	mov	esi, DWORD PTR [esi+1340]
	mov	esi, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	edi, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR [esi+edi*4]

; 699  :                 }
; 700  :               q_info->hess[m][n][i][j] += factor*(DdetA[m][i]*DdetA[n][j]
; 701  :                       - 2*tr1 + 2*det*tr2);

	mov	edi, DWORD PTR tv4481[ebp]
	fld	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR tv5388[ebp]
	fmul	QWORD PTR [edi]
	lea	esi, DWORD PTR [esi+eax*8]
	fxch	ST(2)
	inc	eax
	fmul	ST(0), ST(4)
	mov	DWORD PTR _j$[ebp], eax
	fsubp	ST(2), ST(0)
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fmul	QWORD PTR _factor$[ebp]
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	mov	esi, DWORD PTR _web+616
	cmp	eax, esi
	jl	$LN232@metric_are@2

; 685  :             for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
$LN29@metric_are@2:

; 684  :           for ( n = 0 ; n <= m ; n++ )

	inc	ecx
	cmp	ecx, edx
	jle	$LN237@metric_are@2
$LN32@metric_are@2:

; 683  :          for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, esi
	jl	$LN33@metric_are@2
$LN35@metric_are@2:

; 682  :         for ( m = 0 ; m < cpts ; m++ )

	inc	edx
	cmp	edx, DWORD PTR _cpts$[ebp]
	jl	$LN36@metric_are@2
	fstp	ST(0)
	jmp	SHORT $LN336@metric_are@2
$LN257@metric_are@2:
	mov	esi, DWORD PTR _web+616
	jmp	SHORT $LN336@metric_are@2
$LN311@metric_are@2:
	fstp	ST(0)
	fstp	ST(1)
$LN336@metric_are@2:
	inc	ebx
	fstp	ST(0)
	mov	DWORD PTR _k$[ebp], ebx
	cmp	ebx, DWORD PTR _gpts$[ebp]
	jl	$LL124@metric_are@2
$LN122@metric_are@2:

; 702  :             }     
; 703  :      } /* end gauss loop */
; 704  : 
; 705  :   /* fill in symmetric part */
; 706  :   if ( mode == METHOD_HESSIAN )

	cmp	DWORD PTR _mode$[ebp], 8763		; 0000223bH
	jne	$LN15@metric_are@2

; 707  :     for ( m = 0 ; m < cpts ; m++ )

	cmp	DWORD PTR _cpts$[ebp], 0
	jle	$LN15@metric_are@2
	mov	ecx, DWORD PTR _cpts$[ebp]
	mov	edx, 1
	xor	edi, edi
	mov	DWORD PTR tv5233[ebp], edx
	mov	DWORD PTR tv305[ebp], ecx
	npad	3
$LL17@metric_are@2:

; 708  :       for ( i = 0 ; i < SDIM ; i++ )

	xor	ebx, ebx
	test	esi, esi
	jle	SHORT $LN16@metric_are@2
$LL14@metric_are@2:

; 709  :         for ( n = m+1 ; n < cpts ; n++ )

	cmp	edx, DWORD PTR _cpts$[ebp]
	jge	SHORT $LN13@metric_are@2
	npad	2
$LL11@metric_are@2:

; 710  :           for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN10@metric_are@2
	npad	10
$LL250@metric_are@2:

; 711  :             q_info->hess[m][n][i][j] = q_info->hess[n][m][j][i];

	mov	ecx, DWORD PTR _q_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ecx+1340]
	mov	esi, DWORD PTR [ecx+edx*4]
	mov	esi, DWORD PTR [esi+edi]
	mov	ecx, DWORD PTR [ecx+edi]
	mov	esi, DWORD PTR [esi+eax*4]
	mov	ecx, DWORD PTR [ecx+edx*4]
	fld	QWORD PTR [esi+ebx*8]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	fstp	QWORD PTR [ecx+eax*8]
	mov	esi, DWORD PTR _web+616
	inc	eax
	cmp	eax, esi
	jl	SHORT $LL250@metric_are@2
$LN10@metric_are@2:

; 709  :         for ( n = m+1 ; n < cpts ; n++ )

	inc	edx
	cmp	edx, DWORD PTR _cpts$[ebp]
	jl	SHORT $LL11@metric_are@2
	mov	edx, DWORD PTR tv5233[ebp]
$LN13@metric_are@2:

; 708  :       for ( i = 0 ; i < SDIM ; i++ )

	inc	ebx
	cmp	ebx, esi
	jl	SHORT $LL14@metric_are@2
$LN16@metric_are@2:

; 707  :     for ( m = 0 ; m < cpts ; m++ )

	inc	edx
	add	edi, 4
	dec	DWORD PTR tv305[ebp]
	mov	DWORD PTR tv5233[ebp], edx
	jne	SHORT $LL17@metric_are@2
$LN15@metric_are@2:

; 712  : 
; 713  :   area = value/web.simplex_factorial;
; 714  :   if ( quantities_only_flag )

	cmp	DWORD PTR _quantities_only_flag, 0
	fld	QWORD PTR _value$[ebp]
	fdiv	QWORD PTR _web+792
	pop	edi
	pop	esi
	pop	ebx
	fst	QWORD PTR _area$[ebp]
	je	SHORT $LN370@metric_are@2

; 715  :   { if ( web.representation == STRING )
; 716  :       set_edge_length(q_info->id,area);

	mov	edx, DWORD PTR _q_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	eax, 1
	and	ecx, 134217727				; 07ffffffH
	cmp	DWORD PTR _web+624, eax
	jne	SHORT $LN4@metric_are@2
	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [edx+ecx*4]
	fst	QWORD PTR [ecx+48]
	jmp	SHORT $LN3@metric_are@2
$LN4@metric_are@2:

; 717  :      else set_facet_area(q_info->id,area);

	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [edx+ecx*4]
	fst	QWORD PTR [ecx+40]
$LN3@metric_are@2:

; 718  : #ifdef SHARED_MEMORY
; 719  :      if ( nprocs > 1 ) 

	cmp	DWORD PTR _nprocs, eax
	jle	SHORT $LN2@metric_are@2

; 720  :       proc_total_area[GET_THREAD_ID] += area;

	mov	edx, DWORD PTR _thread_data_key
	fstp	ST(0)
	push	edx
	call	_win_get_thread_data
	mov	eax, DWORD PTR [eax]
	fld	QWORD PTR _proc_total_area[eax*8]
	add	esp, 4
	fadd	QWORD PTR _area$[ebp]
	fstp	QWORD PTR _proc_total_area[eax*8]

; 721  :      else

	jmp	SHORT $LN1@metric_are@2
$LN2@metric_are@2:

; 722  : #endif
; 723  :      binary_tree_add(web.total_area_addends,area);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1000
	call	_binary_tree_add
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@metric_are@2
$LN370@metric_are@2:
	fstp	ST(0)
$LN1@metric_are@2:

; 724  :   }
; 725  : 
; 726  :   free_matrix4(adjAdA);

	mov	eax, DWORD PTR _adjAdA$[ebp]
	push	eax
	call	_free_matrix4

; 727  :   free_matrix(DdetA);

	mov	ecx, DWORD PTR _DdetA$[ebp]
	push	ecx
	call	_free_matrix

; 728  : 
; 729  :   return density*area;

	fld	QWORD PTR _area$[ebp]

; 730  : } /* end metric_area_all() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fmul	QWORD PTR _density$[ebp]
	xor	ecx, ebp
	add	esp, 8
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_metric_area_all ENDP
_TEXT	ENDS
PUBLIC	_metric_area_value
; Function compile flags: /Ogtp
;	COMDAT _metric_area_value
_TEXT	SEGMENT
_q_info$ = 8						; size = 4
_metric_area_value PROC					; COMDAT

; 733  : { return metric_area_all(q_info,METHOD_VALUE);

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _q_info$[ebp]
	push	1767					; 000006e7H
	push	eax
	call	_metric_area_all
	add	esp, 8

; 734  : }

	pop	ebp
	ret	0
_metric_area_value ENDP
_TEXT	ENDS
PUBLIC	_metric_area_grad
; Function compile flags: /Ogtp
;	COMDAT _metric_area_grad
_TEXT	SEGMENT
_q_info$ = 8						; size = 4
_metric_area_grad PROC					; COMDAT

; 737  : { return metric_area_all(q_info,METHOD_GRADIENT);

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _q_info$[ebp]
	push	4321					; 000010e1H
	push	eax
	call	_metric_area_all
	add	esp, 8

; 738  : }

	pop	ebp
	ret	0
_metric_area_grad ENDP
_TEXT	ENDS
PUBLIC	_metric_area_hess
; Function compile flags: /Ogtp
;	COMDAT _metric_area_hess
_TEXT	SEGMENT
_q_info$ = 8						; size = 4
_metric_area_hess PROC					; COMDAT

; 741  : { return metric_area_all(q_info,METHOD_HESSIAN);

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _q_info$[ebp]
	push	8763					; 0000223bH
	push	eax
	call	_metric_area_all
	add	esp, 8

; 742  : }

	pop	ebp
	ret	0
_metric_area_hess ENDP
_TEXT	ENDS
END
