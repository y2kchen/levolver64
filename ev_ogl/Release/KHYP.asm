; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\KHYP.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_TrMat
PUBLIC	_RotMat
PUBLIC	_id_mat
_DATA	SEGMENT
COMM	_eg:QWORD:080H
COMM	_q_init_flag:DWORD
_TrMat	DQ	04003504f333f9d10r		; 2.41421
	DQ	040019435caffa9f9r		; 2.19737
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	040019435caffa9f9r		; 2.19737
	DQ	04003504f333f9d10r		; 2.41421
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
_RotMat	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	0bfe6a09e667f3be3r		; -0.707107
	DQ	03fe6a09e667f3be3r		; 0.707107
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	0bfe6a09e667f3be3r		; -0.707107
	DQ	0bfe6a09e667f3be3r		; -0.707107
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
_id_mat	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
_DATA	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\khyp.c
;	COMDAT _copy
_TEXT	SEGMENT
_copy	PROC						; COMDAT
; _z$ = ecx
; _w$ = eax

; 96   :      int j;
; 97   : 
; 98   :      for (j=0; j<PDIM; j++)
; 99   :           w[j]=z[j];

	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [eax]
	fld	QWORD PTR [ecx+8]
	fstp	QWORD PTR [eax+8]
	fld	QWORD PTR [ecx+16]
	fstp	QWORD PTR [eax+16]
	fld	QWORD PTR [ecx+24]
	fstp	QWORD PTR [eax+24]

; 100  : } // end copy()

	ret	0
_copy	ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_w$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	_web:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _matmult
_TEXT	SEGMENT
_w$GSCopy$ = -48					; size = 4
_j$ = -44						; size = 4
tv1025 = -40						; size = 4
_t$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_z$ = 12						; size = 4
_w$ = 16						; size = 4
_matmult PROC						; COMDAT

; 107  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 114  :      copy(t,w);

	mov	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR _w$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _web+616
	xor	edx, edx
	mov	DWORD PTR _j$[ebp], edx
	test	eax, eax
	js	$LN4@matmult

; 108  :      int i,j;
; 109  :      REAL t[PDIM];
; 110  : 
; 111  :      for (j=0; j<=SDIM; j++)

	mov	ecx, DWORD PTR _m$[ebp]
	fldz
	push	ebx
	push	esi
	push	edi

; 112  :           for (i=0,t[j]=0.; i<=SDIM; i++)

	lea	esi, DWORD PTR _t$[ebp]
	mov	DWORD PTR tv1025[ebp], ecx
$LN16@matmult:
	lea	ecx, DWORD PTR [eax+1]
	fst	QWORD PTR [esi]
	xor	edi, edi
	cmp	ecx, 4
	jl	SHORT $LC14@matmult
	mov	edx, DWORD PTR _z$[ebp]
	fld	QWORD PTR [esi]
	mov	ecx, DWORD PTR tv1025[ebp]
	lea	ebx, DWORD PTR [eax+1]
	add	edx, 16					; 00000010H
	shr	ebx, 2
	lea	edi, DWORD PTR [ebx*4]
$LN15@matmult:

; 113  :                 t[j] += m[j][i] * z[i];

	fld	QWORD PTR [ecx+8]
	add	ecx, 32					; 00000020H
	fmul	QWORD PTR [edx-8]
	add	edx, 32					; 00000020H
	dec	ebx
	fld	QWORD PTR [edx-48]
	fmul	QWORD PTR [ecx-32]
	faddp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-16]
	fmul	QWORD PTR [edx-32]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-8]
	fmul	QWORD PTR [edx-24]
	faddp	ST(1), ST(0)
	jne	SHORT $LN15@matmult

; 112  :           for (i=0,t[j]=0.; i<=SDIM; i++)

	mov	edx, DWORD PTR _j$[ebp]
	fstp	QWORD PTR [esi]
$LC14@matmult:
	cmp	edi, eax
	jg	SHORT $LN5@matmult
	mov	ebx, DWORD PTR _m$[ebp]
	fld	QWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+edx*4]
	lea	ecx, DWORD PTR [ebx+ecx*8]
$LC3@matmult:

; 113  :                 t[j] += m[j][i] * z[i];

	mov	ebx, DWORD PTR _z$[ebp]
	fld	QWORD PTR [ebx+edi*8]
	inc	edi
	fmul	QWORD PTR [ecx]
	add	ecx, 8
	faddp	ST(1), ST(0)
	cmp	edi, eax
	jle	SHORT $LC3@matmult
	fstp	QWORD PTR [esi]
$LN5@matmult:

; 108  :      int i,j;
; 109  :      REAL t[PDIM];
; 110  : 
; 111  :      for (j=0; j<=SDIM; j++)

	add	DWORD PTR tv1025[ebp], 32		; 00000020H
	inc	edx
	add	esi, 8
	mov	DWORD PTR _j$[ebp], edx
	cmp	edx, eax
	jle	$LN16@matmult
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx
$LN4@matmult:

; 114  :      copy(t,w);

	mov	eax, DWORD PTR _w$GSCopy$[ebp]
	lea	ecx, DWORD PTR _t$[ebp]
	call	_copy

; 115  : } // end void matmult()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_matmult ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _copymat
_TEXT	SEGMENT
_copymat PROC						; COMDAT
; _a$ = eax
; _b$ = edx

; 141  : {

	push	esi
	push	edi

; 142  :   memcpy((char*)b,(char*)a,PDIM*PDIM*sizeof(REAL));

	mov	ecx, 32					; 00000020H
	mov	esi, eax
	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi

; 143  : } // end copymat()

	ret	0
_copymat ENDP
_TEXT	ENDS
PUBLIC	_c$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtp
;	COMDAT _matmatmult
_TEXT	SEGMENT
tv1195 = -156						; size = 4
_c$GSCopy$ = -152					; size = 4
tv1129 = -148						; size = 4
_i$ = -144						; size = 4
_k$ = -140						; size = 4
tv1189 = -136						; size = 4
_t$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_matmatmult PROC					; COMDAT

; 150  : { int i,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 151  :   REAL t[PDIM][PDIM];
; 152  :   REAL *tp;
; 153  :   for ( i = 0 ; i <=SDIM ; i++ )

	mov	edx, DWORD PTR _web+616

; 158  :         }
; 159  :   copymat(t,c);

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$GSCopy$[ebp], eax
	mov	DWORD PTR _i$[ebp], 0
	test	edx, edx
	js	$LN7@matmatmult

; 151  :   REAL t[PDIM][PDIM];
; 152  :   REAL *tp;
; 153  :   for ( i = 0 ; i <=SDIM ; i++ )

	mov	eax, DWORD PTR _a$[ebp]
	fldz
	push	ebx
	push	esi
	lea	esi, DWORD PTR _t$[ebp]
	sub	esi, eax
	push	edi

; 154  :      for ( k = 0, tp = t[i] ; k <= SDIM ; k++,tp++ )

	mov	DWORD PTR tv1189[ebp], eax
	mov	DWORD PTR tv1195[ebp], esi
	jmp	SHORT $LN9@matmatmult
$LN22@matmatmult:

; 151  :   REAL t[PDIM][PDIM];
; 152  :   REAL *tp;
; 153  :   for ( i = 0 ; i <=SDIM ; i++ )

	mov	esi, DWORD PTR tv1195[ebp]
$LN9@matmatmult:

; 154  :      for ( k = 0, tp = t[i] ; k <= SDIM ; k++,tp++ )

	mov	eax, DWORD PTR _b$[ebp]
	add	esi, DWORD PTR tv1189[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _k$[ebp], 0
	mov	ecx, eax
	mov	DWORD PTR tv1129[ebp], eax
$LN23@matmatmult:

; 156  :           for ( j = 0 ; j <= SDIM ; j++ )

	lea	eax, DWORD PTR [edx+1]
	fst	QWORD PTR [esi]
	xor	ebx, ebx
	cmp	eax, 4
	jl	SHORT $LC19@matmatmult

; 155  :         { *tp = 0.0;

	mov	eax, DWORD PTR tv1189[ebp]
	fld	QWORD PTR [esi]
	lea	edi, DWORD PTR [edx+1]
	shr	edi, 2
	lea	ebx, DWORD PTR [edi*4]

; 156  :           for ( j = 0 ; j <= SDIM ; j++ )

$LN20@matmatmult:

; 157  :              *tp += a[i][j]*b[j][k];

	fld	QWORD PTR [ecx-32]
	add	eax, 32					; 00000020H
	fmul	QWORD PTR [eax-24]
	sub	ecx, -128				; ffffff80H
	dec	edi
	fld	QWORD PTR [ecx-192]
	fmul	QWORD PTR [eax-32]
	faddp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax-16]
	fmul	QWORD PTR [ecx-128]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-96]
	fmul	QWORD PTR [eax-8]
	faddp	ST(1), ST(0)
	jne	SHORT $LN20@matmatmult
	fstp	QWORD PTR [esi]
$LC19@matmatmult:

; 156  :           for ( j = 0 ; j <= SDIM ; j++ )

	cmp	ebx, edx
	jg	SHORT $LN5@matmatmult
	mov	eax, DWORD PTR _i$[ebp]
	fld	QWORD PTR [esi]
	mov	edi, DWORD PTR _b$[ebp]
	lea	ecx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR _a$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _k$[ebp]
	lea	eax, DWORD PTR [eax+ebx*4]
	lea	edi, DWORD PTR [edi+eax*8]
	mov	eax, edx
	sub	eax, ebx
	inc	eax
$LC3@matmatmult:

; 157  :              *tp += a[i][j]*b[j][k];

	fld	QWORD PTR [ecx]
	add	ecx, 8
	fmul	QWORD PTR [edi]
	add	edi, 32					; 00000020H
	dec	eax
	faddp	ST(1), ST(0)
	jne	SHORT $LC3@matmatmult
	fstp	QWORD PTR [esi]
$LN5@matmatmult:

; 154  :      for ( k = 0, tp = t[i] ; k <= SDIM ; k++,tp++ )

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR tv1129[ebp]
	inc	eax
	add	ecx, 8
	add	esi, 8
	mov	DWORD PTR _k$[ebp], eax
	mov	DWORD PTR tv1129[ebp], ecx
	cmp	eax, edx
	jle	$LN23@matmatmult

; 151  :   REAL t[PDIM][PDIM];
; 152  :   REAL *tp;
; 153  :   for ( i = 0 ; i <=SDIM ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv1189[ebp], 32		; 00000020H
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, edx
	jle	$LN22@matmatmult
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx
$LN7@matmatmult:

; 158  :         }
; 159  :   copymat(t,c);

	mov	edx, DWORD PTR _c$GSCopy$[ebp]
	lea	eax, DWORD PTR _t$[ebp]
	call	_copymat

; 160  : } // end matmatmult()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_matmatmult ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _genmat
_TEXT	SEGMENT
_genmat	PROC						; COMDAT
; _g$ = ebx
; _t$ = esi

; 166  : {

	push	edi

; 167  :      int i;
; 168  : 
; 169  :      for (i=0;i<g;i++)

	test	ebx, ebx
	jle	SHORT $LN4@genmat
	mov	edi, ebx
$LL6@genmat:

; 170  :           matmatmult(RotMat,t,t);

	push	esi
	push	esi
	push	OFFSET _RotMat
	call	_matmatmult
	add	esp, 12					; 0000000cH
	dec	edi
	jne	SHORT $LL6@genmat
$LN4@genmat:

; 171  :      matmatmult(TrMat,t,t);

	push	esi
	push	esi
	push	OFFSET _TrMat
	call	_matmatmult

; 172  :      matmatmult(TrMat,t,t);

	push	esi
	push	esi
	push	OFFSET _TrMat
	call	_matmatmult
	add	esp, 24					; 00000018H

; 173  :      for (i=g;i<8;i++)

	cmp	ebx, 8
	jge	SHORT $LN1@genmat

; 171  :      matmatmult(TrMat,t,t);

	mov	edi, 8
	sub	edi, ebx
$LL3@genmat:

; 174  :           matmatmult(RotMat,t,t);

	push	esi
	push	esi
	push	OFFSET _RotMat
	call	_matmatmult
	add	esp, 12					; 0000000cH
	dec	edi
	jne	SHORT $LL3@genmat
$LN1@genmat:
	pop	edi

; 175  : } // end genmat()

	ret	0
_genmat	ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _q_init
_TEXT	SEGMENT
_q_init	PROC						; COMDAT

; 178  : { int i;

	push	ebx
	push	esi

; 179  :   
; 180  :   for ( i = 0 ; i < 8 ; i++ )

	xor	ebx, ebx
	mov	esi, OFFSET _eg
	npad	7
$LL3@q_init:

; 181  :     { copymat(id_mat,eg[i]);

	mov	edx, esi
	mov	eax, OFFSET _id_mat
	call	_copymat

; 182  :       genmat(i,eg[i]);

	call	_genmat
	sub	esi, -128				; ffffff80H
	inc	ebx
	cmp	esi, OFFSET _eg+1024
	jl	SHORT $LL3@q_init

; 183  :     }
; 184  : 
; 185  :   q_init_flag = 1;

	pop	esi
	mov	DWORD PTR _q_init_flag, 1
	pop	ebx

; 186  : } // end  q_init()

	ret	0
_q_init	ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	_y$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_khyp_wrap
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _khyp_wrap
_TEXT	SEGMENT
_y$GSCopy$ = -72					; size = 4
_z$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_wrap$ = 16						; size = 4
_khyp_wrap PROC						; COMDAT

; 203  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 204  :      REAL z[2][PDIM]; /* two work vectors */
; 205  :      int j,i;
; 206  :      int g1,gk, g;
; 207  : 
; 208  :      if ( q_init_flag == 0 ) q_init();

	cmp	DWORD PTR _q_init_flag, 0
	push	esi
	mov	esi, DWORD PTR _y$[ebp]

; 224  :      {
; 225  :           matmult(eg[CHOP(g)],z[j],z[1-j]);

	mov	DWORD PTR _y$GSCopy$[ebp], esi
	jne	SHORT $LN12@khyp_wrap

; 204  :      REAL z[2][PDIM]; /* two work vectors */
; 205  :      int j,i;
; 206  :      int g1,gk, g;
; 207  : 
; 208  :      if ( q_init_flag == 0 ) q_init();

	call	_q_init
$LN12@khyp_wrap:

; 209  : 
; 210  :      if (wrap==0)

	mov	eax, DWORD PTR _wrap$[ebp]
	test	eax, eax
	jne	SHORT $LN11@khyp_wrap

; 211  :      {
; 212  :           for (j=0; j<SDIM; j++)

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	$LN1@khyp_wrap
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, esi
	sub	edx, esi
$LL10@khyp_wrap:

; 213  :                 y[j]=x[j];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL10@khyp_wrap
	pop	esi

; 228  : } // end khyp_wrap()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@khyp_wrap:
	push	ebx

; 214  :           return;
; 215  :      }
; 216  : 
; 217  :      g1 = CHOP(wrap);

	mov	ebx, eax

; 218  :      gk = CHOP(wrap>>GENUS2BITS);

	sar	eax, 4
	and	eax, 7
	push	edi
	and	ebx, 7
	mov	edi, eax

; 219  :      if (gk<g1) gk += 8;

	cmp	edi, ebx
	jge	SHORT $LN21@khyp_wrap
	add	edi, 8
$LN21@khyp_wrap:

; 220  : 
; 221  :      copy(x,z[0]+1);

	mov	ecx, DWORD PTR _x$[ebp]
	lea	eax, DWORD PTR _z$[ebp+8]
	call	_copy

; 222  :      z[0][0] = 1.;

	fld1

; 223  :      for (g=gk-1,j=0; g>=g1; g--,j=1-j)

	dec	edi
	fstp	QWORD PTR _z$[ebp]
	xor	esi, esi
	cmp	edi, ebx
	jl	SHORT $LN4@khyp_wrap
	npad	2
$LL22@khyp_wrap:

; 224  :      {
; 225  :           matmult(eg[CHOP(g)],z[j],z[1-j]);

	mov	eax, esi
	shl	eax, 5
	lea	edx, DWORD PTR _z$[ebp+eax]
	lea	ecx, DWORD PTR _z$[ebp+32]
	sub	ecx, eax
	mov	eax, edi
	and	eax, 7
	push	ecx
	shl	eax, 7
	push	edx
	add	eax, OFFSET _eg
	push	eax
	call	_matmult
	mov	ecx, 1
	dec	edi
	sub	ecx, esi
	add	esp, 12					; 0000000cH
	mov	esi, ecx
	cmp	edi, ebx
	jge	SHORT $LL22@khyp_wrap
$LN4@khyp_wrap:

; 226  :      }
; 227  :     for ( i = 0 ; i < SDIM ; i++ ) y[i] = z[j][i+1]/z[j][0];

	xor	eax, eax
	pop	edi
	pop	ebx
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN1@khyp_wrap
	shl	esi, 5
	lea	edx, DWORD PTR _z$[ebp+esi]
	lea	ecx, DWORD PTR _z$[ebp+esi+8]
	npad	5
$LL3@khyp_wrap:
	fld	QWORD PTR [ecx]
	mov	esi, DWORD PTR _y$GSCopy$[ebp]
	fdiv	QWORD PTR [edx]
	inc	eax
	add	ecx, 8
	fstp	QWORD PTR [esi+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL3@khyp_wrap
$LN1@khyp_wrap:

; 228  : } // end khyp_wrap()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_khyp_wrap ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@EOELELJE@khyp?3?5Wrap?5outside?5known?5range?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@FNCHGGCA@Trying?5to?5compose?5?$CFd?9?$CFd?5and?5?$CFd?9?$CF@ ; `string'
PUBLIC	_khyp_compose
EXTRN	_kb_error:PROC
EXTRN	_sprintf:PROC
EXTRN	_msg:DWORD
;	COMDAT ??_C@_0CA@EOELELJE@khyp?3?5Wrap?5outside?5known?5range?6?$AA@
CONST	SEGMENT
??_C@_0CA@EOELELJE@khyp?3?5Wrap?5outside?5known?5range?6?$AA@ DB 'khyp: W'
	DB	'rap outside known range', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FNCHGGCA@Trying?5to?5compose?5?$CFd?9?$CFd?5and?5?$CFd?9?$CF@
CONST	SEGMENT
??_C@_0CD@FNCHGGCA@Trying?5to?5compose?5?$CFd?9?$CFd?5and?5?$CFd?9?$CF@ DB 'T'
	DB	'rying to compose %d-%d and %d-%d', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _khyp_compose
_TEXT	SEGMENT
tv346 = -4						; size = 4
_gk$ = 8						; size = 4
_gw$ = 8						; size = 4
_hw$ = 12						; size = 4
_khyp_compose PROC					; COMDAT

; 252  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 253  :      int g1,gk, h1,hk;
; 254  : 
; 255  :      if (gw==0) return hw;

	mov	eax, DWORD PTR _gw$[ebp]
	test	eax, eax
	jne	SHORT $LN9@khyp_compo
	mov	eax, DWORD PTR _hw$[ebp]

; 270  : } // end khyp_compose()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@khyp_compo:
	push	esi

; 256  :      if (hw==0) return gw;

	mov	esi, DWORD PTR _hw$[ebp]
	test	esi, esi
	je	$LN31@khyp_compo

; 257  :      g1 = CHOP(gw); gk = END(gw);

	mov	ecx, eax
	sar	eax, 4
	and	eax, 7
	push	edi
	mov	edi, eax

; 258  :      h1 = CHOP(hw); hk = END(hw);

	mov	eax, esi
	and	eax, 7
	sar	esi, 4

; 259  : 
; 260  :      TRY(g1,gk,h1,hk);  /* h nicely follows after g */

	mov	edx, eax
	sub	edx, edi
	and	ecx, 7
	and	esi, 7
	mov	DWORD PTR _gk$[ebp], edi
	test	dl, 7
	jne	SHORT $LN7@khyp_compo
	mov	eax, esi
	sub	eax, ecx
	and	eax, 7
	jne	SHORT $LN14@khyp_compo
	pop	edi
	pop	esi

; 270  : } // end khyp_compose()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@khyp_compo:

; 259  : 
; 260  :      TRY(g1,gk,h1,hk);  /* h nicely follows after g */

	cmp	eax, 7
	jne	SHORT $LN12@khyp_compo
	mov	eax, ecx
	shl	eax, 4
	sub	eax, 49					; 00000031H
	add	ecx, 3
	and	eax, 112				; 00000070H
	and	ecx, 7
	pop	edi
	or	eax, ecx
	pop	esi

; 270  : } // end khyp_compose()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@khyp_compo:

; 259  : 
; 260  :      TRY(g1,gk,h1,hk);  /* h nicely follows after g */

	and	esi, 7
	shl	esi, 4
	and	ecx, 7
	or	esi, ecx
	pop	edi
	mov	eax, esi
	pop	esi

; 270  : } // end khyp_compose()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@khyp_compo:
	push	ebx

; 261  :      if (DFF(h1,hk,1)) TRY(g1,gk,h1-3,h1-4); /* equiv string of 7 */

	mov	ebx, esi
	sub	ebx, eax
	and	ebx, 7
	cmp	ebx, 1
	jne	SHORT $LN5@khyp_compo
	add	edx, -3					; fffffffdH
	test	dl, 7
	jne	SHORT $LN5@khyp_compo
	mov	edx, eax
	sub	edx, ecx
	sub	edx, 4
	and	edx, 7
	je	$LN36@khyp_compo
	cmp	edx, 7
	jne	SHORT $LN16@khyp_compo
	mov	eax, ecx
	add	ecx, 3
$LN16@khyp_compo:
	shl	eax, 4
	sub	eax, 49					; 00000031H
	pop	ebx
	and	ecx, 7
	and	eax, 112				; 00000070H
	pop	edi
	or	eax, ecx
	pop	esi

; 270  : } // end khyp_compose()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@khyp_compo:

; 262  :      if (DFF(g1,gk,1)) TRY(g1-3,g1-4,h1,hk); /* equiv string of 7 */

	sub	edi, ecx
	and	edi, 7
	cmp	edi, 1
	jne	SHORT $LN30@khyp_compo
	mov	edx, eax
	sub	edx, ecx
	sub	edx, 4
	test	dl, 7
	jne	SHORT $LN30@khyp_compo
	mov	eax, esi
	sub	eax, ecx
	add	eax, 3
	and	eax, 7
	jne	SHORT $LN22@khyp_compo
	pop	ebx
	xor	esi, esi
	pop	edi
	mov	eax, esi
	pop	esi

; 270  : } // end khyp_compose()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@khyp_compo:

; 262  :      if (DFF(g1,gk,1)) TRY(g1-3,g1-4,h1,hk); /* equiv string of 7 */

	cmp	eax, 7
	jne	SHORT $LN20@khyp_compo
	lea	esi, DWORD PTR [ecx+1]
	shl	esi, 4
	and	esi, 112				; 00000070H
	and	ecx, eax
	pop	ebx
	or	esi, ecx
	pop	edi
	mov	eax, esi
	pop	esi

; 270  : } // end khyp_compose()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@khyp_compo:

; 262  :      if (DFF(g1,gk,1)) TRY(g1-3,g1-4,h1,hk); /* equiv string of 7 */

	and	esi, 7
	add	ecx, -3					; fffffffdH
	shl	esi, 4
	and	ecx, 7
	pop	ebx
	or	esi, ecx
	pop	edi
	mov	eax, esi
	pop	esi

; 270  : } // end khyp_compose()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@khyp_compo:

; 263  :      if (DFF(h1,hk,1) && DFF(g1,gk,1)) TRY(g1-3,g1-4,h1-3,h1-4);

	cmp	ebx, 1
	jne	SHORT $LN1@khyp_compo
	cmp	edi, ebx
	jne	SHORT $LN1@khyp_compo
	mov	edi, eax
	sub	edi, ecx
	lea	edx, DWORD PTR [edi+1]
	test	dl, 7
	jne	SHORT $LN1@khyp_compo
	lea	edx, DWORD PTR [edi-1]
	and	edx, 7
	je	SHORT $LN36@khyp_compo
	cmp	edx, 7
	jne	SHORT $LN24@khyp_compo
	lea	eax, DWORD PTR [ecx+1]
	shl	eax, 4
	pop	ebx
	and	ecx, edx
	and	eax, 112				; 00000070H
	pop	edi
	or	eax, ecx
	pop	esi

; 270  : } // end khyp_compose()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@khyp_compo:

; 263  :      if (DFF(h1,hk,1) && DFF(g1,gk,1)) TRY(g1-3,g1-4,h1-3,h1-4);

	shl	eax, 4
	sub	eax, 49					; 00000031H
	add	ecx, -3					; fffffffdH
	pop	ebx
	and	ecx, 7
	and	eax, 112				; 00000070H
	pop	edi
	or	eax, ecx
	pop	esi

; 270  : } // end khyp_compose()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@khyp_compo:

; 264  : 
; 265  :      sprintf(msg,"Trying to compose %d-%d and %d-%d\n",g1,gk,h1,hk);

	push	esi
	push	eax
	mov	eax, DWORD PTR _gk$[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _msg
	push	OFFSET ??_C@_0CD@FNCHGGCA@Trying?5to?5compose?5?$CFd?9?$CFd?5and?5?$CFd?9?$CF@
	push	ecx
	call	_sprintf

; 266  :      strcat(msg,"khyp: Wrap outside known range\n");

	mov	edi, DWORD PTR _msg
	add	esp, 24					; 00000018H
	dec	edi
$LL28@khyp_compo:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL28@khyp_compo
	mov	ecx, 8
	mov	esi, OFFSET ??_C@_0CA@EOELELJE@khyp?3?5Wrap?5outside?5known?5range?6?$AA@
	rep movsd

; 267  :      kb_error(1305,msg,WARNING);

	mov	edx, DWORD PTR _msg
	push	2
	push	edx
	push	1305					; 00000519H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN36@khyp_compo:

; 268  : 
; 269  :      return 0;

	pop	ebx
	xor	eax, eax
	pop	edi
$LN31@khyp_compo:
	pop	esi

; 270  : } // end khyp_compose()

	mov	esp, ebp
	pop	ebp
	ret	0
_khyp_compose ENDP
_TEXT	ENDS
PUBLIC	_khyp_inverse
; Function compile flags: /Ogtp
;	COMDAT _khyp_inverse
_TEXT	SEGMENT
_wrap$ = 8						; size = 4
_khyp_inverse PROC					; COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp

; 283  :     return WRAP(END(wrap),CHOP(wrap));

	mov	eax, DWORD PTR _wrap$[ebp]
	mov	edx, eax
	sar	edx, 4
	push	esi
	mov	esi, edx
	and	esi, 7
	mov	ecx, eax
	sub	ecx, esi
	and	ecx, 7
	jne	SHORT $LN5@khyp_inver
	xor	eax, eax
	pop	esi

; 284  : }

	pop	ebp
	ret	0
$LN5@khyp_inver:

; 283  :     return WRAP(END(wrap),CHOP(wrap));

	cmp	ecx, 7
	jne	SHORT $LN3@khyp_inver
	and	eax, -16				; fffffff0H
	sub	eax, 49					; 00000031H
	add	edx, 3
	and	eax, 112				; 00000070H
	and	edx, ecx
	or	eax, edx
	pop	esi

; 284  : }

	pop	ebp
	ret	0
$LN3@khyp_inver:

; 283  :     return WRAP(END(wrap),CHOP(wrap));

	and	eax, 7
	shl	eax, 4
	or	eax, esi
	pop	esi

; 284  : }

	pop	ebp
	ret	0
_khyp_inverse ENDP
_TEXT	ENDS
PUBLIC	_yform$GSCopy$
PUBLIC	_xform$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_khyp_form_pullback
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT _khyp_form_pullback
_TEXT	SEGMENT
_xform$GSCopy$ = -332					; size = 4
_yform$GSCopy$ = -328					; size = 4
_jac$ = -324						; size = 128
_y$ = -196						; size = 32
_w$ = -164						; size = 32
_trans$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_xform$ = 12						; size = 4
_yform$ = 16						; size = 4
_wrap$ = 20						; size = 4
_khyp_form_pullback PROC				; COMDAT

; 301  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 302  :   int i,j;
; 303  :   REAL trans[PDIM][PDIM];
; 304  :   REAL jac[PDIM][PDIM];  /* Jacobian matrix */
; 305  :   REAL y[PDIM];
; 306  :   REAL w[PDIM];  /* Minkowski coord of x */
; 307  :   int g1,gk,g;    /* element numbers */
; 308  : 
; 309  :   if ( wrap == 0 ) /* just copy */

	mov	eax, DWORD PTR _wrap$[ebp]
	mov	ecx, DWORD PTR _xform$[ebp]
	mov	edx, DWORD PTR _yform$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _x$[ebp]

; 327  : 
; 328  :   /* set up Jacobian */
; 329  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _xform$GSCopy$[ebp], ecx
	mov	DWORD PTR _yform$GSCopy$[ebp], edx
	test	eax, eax
	jne	SHORT $LN17@khyp_form_

; 310  :      { memcpy((char *)xform,(char*)yform,SDIM*sizeof(REAL));

	mov	eax, DWORD PTR _web+616
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	edx
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	ebx

; 337  : 
; 338  : } // end khyp_form_pullback()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@khyp_form_:
	push	esi

; 311  :         return;
; 312  :      }
; 313  : 
; 314  :   g1 = CHOP(wrap);

	mov	esi, eax

; 315  :   gk = CHOP(wrap>>GENUS2BITS);

	sar	eax, 4
	and	eax, 7
	push	edi
	and	esi, 7
	mov	edi, eax

; 316  :   if (gk<g1) gk += 8;

	cmp	edi, esi
	jge	SHORT $LN16@khyp_form_
	add	edi, 8
$LN16@khyp_form_:

; 317  : 
; 318  :   /* get total linear transformation */
; 319  :   copymat(eg[g1],trans);

	mov	eax, esi
	shl	eax, 7
	add	eax, OFFSET _eg
	lea	edx, DWORD PTR _trans$[ebp]
	call	_copymat

; 320  :   for ( g = g1+1; g < gk ; g++ )

	inc	esi
	cmp	esi, edi
	jge	SHORT $LN13@khyp_form_
$LL15@khyp_form_:

; 321  :     matmatmult(trans,eg[CHOP(g)],trans);

	mov	edx, esi
	and	edx, 7
	lea	ecx, DWORD PTR _trans$[ebp]
	shl	edx, 7
	push	ecx
	add	edx, OFFSET _eg
	push	edx
	mov	eax, ecx
	push	eax
	call	_matmatmult
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, edi
	jl	SHORT $LL15@khyp_form_
$LN13@khyp_form_:

; 322  : 
; 323  :   /* get transformed point in Minkowski */
; 324  :   memcpy((char *)(w+1),(char*)x,SDIM*sizeof(REAL));

	mov	ecx, DWORD PTR _web+616
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	lea	eax, DWORD PTR _w$[ebp+8]
	push	ebx
	push	eax
	call	_memcpy

; 325  :   w[0] = 1.0;

	fld1

; 326  :   matmult(trans,w,y);

	lea	ecx, DWORD PTR _y$[ebp]
	fstp	QWORD PTR _w$[ebp]
	push	ecx
	lea	edx, DWORD PTR _w$[ebp]
	push	edx
	lea	eax, DWORD PTR _trans$[ebp]
	push	eax
	call	_matmult

; 327  : 
; 328  :   /* set up Jacobian */
; 329  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _web+616
	add	esp, 24					; 00000018H
	xor	ebx, ebx
	test	esi, esi
	jle	$LN10@khyp_form_

; 322  : 
; 323  :   /* get transformed point in Minkowski */
; 324  :   memcpy((char *)(w+1),(char*)x,SDIM*sizeof(REAL));

	fld	QWORD PTR _y$[ebp]
	lea	edx, DWORD PTR _y$[ebp+8]
$LN34@khyp_form_:

; 330  :     for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	esi, 4
	jl	SHORT $LC31@khyp_form_

; 327  : 
; 328  :   /* set up Jacobian */
; 329  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, ebx
	lea	edi, DWORD PTR [esi-3]
	shl	eax, 5

; 330  :     for ( j = 0 ; j < SDIM ; j++ )

$LN32@khyp_form_:

; 331  :       jac[i][j] = (trans[i+1][j+1] - y[i+1]*trans[0][j+1]/y[0])/y[0];

	fld	QWORD PTR _trans$[ebp+ecx*8+8]
	add	ecx, 4
	fmul	QWORD PTR [edx]
	add	eax, 32					; 00000020H
	fdiv	ST(0), ST(1)
	fsubr	QWORD PTR _trans$[ebp+eax+8]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _jac$[ebp+eax-32]
	fld	QWORD PTR _trans$[ebp+ecx*8-16]
	fmul	QWORD PTR [edx]
	fdiv	ST(0), ST(1)
	fsubr	QWORD PTR _trans$[ebp+eax+16]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _jac$[ebp+eax-24]
	fld	QWORD PTR _trans$[ebp+ecx*8-8]
	fmul	QWORD PTR [edx]
	fdiv	ST(0), ST(1)
	fsubr	QWORD PTR _trans$[ebp+eax+24]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _jac$[ebp+eax-16]
	fld	QWORD PTR _trans$[ebp+ecx*8]
	fmul	QWORD PTR [edx]
	fdiv	ST(0), ST(1)
	fsubr	QWORD PTR _trans$[ebp+eax+32]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _jac$[ebp+eax-8]
	cmp	ecx, edi
	jl	SHORT $LN32@khyp_form_
$LC31@khyp_form_:

; 330  :     for ( j = 0 ; j < SDIM ; j++ )

	cmp	ecx, esi
	jge	SHORT $LN11@khyp_form_
	lea	eax, DWORD PTR [ecx+ebx*4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
$LC9@khyp_form_:

; 331  :       jac[i][j] = (trans[i+1][j+1] - y[i+1]*trans[0][j+1]/y[0])/y[0];

	fld	QWORD PTR _trans$[ebp+ecx*8+8]
	inc	ecx
	fmul	QWORD PTR [edx]
	add	eax, 8
	fdiv	ST(0), ST(1)
	fsubr	QWORD PTR _trans$[ebp+eax+32]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _jac$[ebp+eax-8]
	cmp	ecx, esi
	jl	SHORT $LC9@khyp_form_
$LN11@khyp_form_:

; 327  : 
; 328  :   /* set up Jacobian */
; 329  :   for ( i = 0 ; i < SDIM ; i++ )

	inc	ebx
	add	edx, 8
	cmp	ebx, esi
	jl	$LN34@khyp_form_
	fstp	ST(0)
$LN10@khyp_form_:

; 332  : 
; 333  :   /* pull back form with transpose of jacobian */
; 334  :   for ( i = 0 ; i < SDIM ; i++ )

	xor	edi, edi
	test	esi, esi
	jle	SHORT $LN35@khyp_form_
	mov	ecx, DWORD PTR _xform$GSCopy$[ebp]
	fldz
	lea	ebx, DWORD PTR _jac$[ebp]
	sub	ebx, ecx
$LN33@khyp_form_:

; 335  :      for ( j = 0, xform[i] = 0. ; j < SDIM ; j++ )

	fst	QWORD PTR [ecx]
	mov	esi, DWORD PTR _web+616
	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN5@khyp_form_

; 332  : 
; 333  :   /* pull back form with transpose of jacobian */
; 334  :   for ( i = 0 ; i < SDIM ; i++ )

	lea	edx, DWORD PTR [ebx+ecx]
$LN3@khyp_form_:

; 336  :         xform[i] += jac[j][i]*yform[j];

	mov	esi, DWORD PTR _yform$GSCopy$[ebp]
	fld	QWORD PTR [esi+eax*8]
	inc	eax
	fmul	QWORD PTR [edx]
	add	edx, 32					; 00000020H
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	esi, DWORD PTR _web+616
	cmp	eax, esi
	jl	SHORT $LN3@khyp_form_
$LN5@khyp_form_:

; 332  : 
; 333  :   /* pull back form with transpose of jacobian */
; 334  :   for ( i = 0 ; i < SDIM ; i++ )

	inc	edi
	add	ecx, 8
	cmp	edi, esi
	jl	SHORT $LN33@khyp_form_
	fstp	ST(0)
$LN35@khyp_form_:

; 337  : 
; 338  : } // end khyp_form_pullback()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_khyp_form_pullback ENDP
_TEXT	ENDS
END
