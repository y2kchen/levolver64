; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\STRINGQ.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_scoeff
PUBLIC	_gauss2pt
PUBLIC	_gauss2wt
_DATA	SEGMENT
COMM	_gcombo:QWORD:09H
COMM	_sdip:QWORD:09H
COMM	_ssimp:QWORD:09H
_scoeff	DQ	03fe0000000000000r		; 0.5
	DQ	0bfe5555555555555r		; -0.666667
	DQ	03fc5555555555555r		; 0.166667
	DQ	03fe5555555555555r		; 0.666667
	DQ	00000000000000000r		; 0
	DQ	0bfe5555555555555r		; -0.666667
	DQ	0bfc5555555555555r		; -0.166667
	DQ	03fe5555555555555r		; 0.666667
	DQ	0bfe0000000000000r		; -0.5
_gauss2pt DQ	03fccda042f0236efr		; 0.225403
	DQ	03ff0000000000000r		; 1
	DQ	03ffc64bf7a1fb922r		; 1.7746
_gauss2wt DQ	03fe1c71c71c71c72r		; 0.555556
	DQ	03fec71c71c71c71cr		; 0.888889
	DQ	03fe1c71c71c71c72r		; 0.555556
_DATA	ENDS
PUBLIC	_get_fe_edge
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_get_edge_wrap
EXTRN	_sym_inverse:DWORD
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_wrap PROC					; COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  :   WRAPTYPE wrap = *EINT(e_id,E_WRAP_ATTR) ;

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+784]
	mov	eax, DWORD PTR [eax+edx]
	pop	esi

; 165  :   return    ( inverted(e_id) ? (*sym_inverse)(wrap) : wrap );

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN4@get_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@get_edge_w:

; 166  : }

	pop	ebp
	ret	0
_get_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	__real@4000000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	_interpoly
EXTRN	__fltused:DWORD
;	COMDAT __real@4000000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\stringq.c
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _interpoly
_TEXT	SEGMENT
_k$ = 8							; size = 4
_u$ = 12						; size = 8
_interpoly PROC						; COMDAT

; 48   : {

	push	ebp
	mov	ebp, esp

; 49   :   switch ( k )

	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 0
	je	SHORT $LN3@interpoly
	dec	eax
	je	SHORT $LN2@interpoly
	dec	eax
	je	SHORT $LN1@interpoly

; 54   :     }
; 55   : 
; 56   :   return  0.0;  /* error return */

	fldz

; 57   : } // end interpoly()

	pop	ebp
	ret	0
$LN1@interpoly:

; 53   :       case  2:  return u*(u - 1)/2;

	fld	QWORD PTR _u$[ebp]
	fld	QWORD PTR __real@3ff0000000000000
	fsubr	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fe0000000000000

; 57   : } // end interpoly()

	pop	ebp
	ret	0
$LN2@interpoly:

; 52   :       case  1:  return u*(2 - u);

	fld	QWORD PTR __real@4000000000000000
	fld	QWORD PTR _u$[ebp]
	fsub	ST(1), ST(0)
	fmulp	ST(1), ST(0)

; 57   : } // end interpoly()

	pop	ebp
	ret	0
$LN3@interpoly:

; 50   :     {
; 51   :       case  0:  return (1 - u)*(2 - u)/2;

	fld1
	fld	QWORD PTR _u$[ebp]
	fsub	ST(1), ST(0)
	fsubr	QWORD PTR __real@4000000000000000
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fe0000000000000

; 57   : } // end interpoly()

	pop	ebp
	ret	0
_interpoly ENDP
_TEXT	ENDS
PUBLIC	__real@3ff8000000000000
PUBLIC	_interpolyderiv
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _interpolyderiv
_TEXT	SEGMENT
_k$ = 8							; size = 4
_u$ = 12						; size = 8
_interpolyderiv PROC					; COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp

; 68   :   switch ( k )

	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 0
	je	SHORT $LN3@interpolyd
	dec	eax
	je	SHORT $LN2@interpolyd
	dec	eax
	je	SHORT $LN1@interpolyd

; 73   :     }
; 74   : 
; 75   :   return  0.0;  /* error return */

	fldz

; 76   : } // end interpolyderiv()

	pop	ebp
	ret	0
$LN1@interpolyd:

; 72   :       case  2:  return u - 0.5;

	fld	QWORD PTR _u$[ebp]
	fsub	QWORD PTR __real@3fe0000000000000

; 76   : } // end interpolyderiv()

	pop	ebp
	ret	0
$LN2@interpolyd:

; 71   :       case  1:  return 2 - 2*u;

	fld	QWORD PTR _u$[ebp]
	fld	QWORD PTR __real@4000000000000000
	fmul	ST(1), ST(0)
	fsubrp	ST(1), ST(0)

; 76   : } // end interpolyderiv()

	pop	ebp
	ret	0
$LN3@interpolyd:

; 69   :     {
; 70   :       case  0:  return u - 1.5;

	fld	QWORD PTR _u$[ebp]
	fsub	QWORD PTR __real@3ff8000000000000

; 76   : } // end interpolyderiv()

	pop	ebp
	ret	0
_interpolyderiv ENDP
_TEXT	ENDS
PUBLIC	_scoeff_init
; Function compile flags: /Ogtp
;	COMDAT _scoeff_init
_TEXT	SEGMENT
_scoeff_init PROC					; COMDAT

; 83   : {

	push	esi

; 84   :     int i,j;
; 85   : 
; 86   :     for ( i = 0 ; i < EDGE_CTRL ;  i++ )

	xor	esi, esi
	xor	edx, edx
$LL6@scoeff_ini:

; 87   :       for ( j = 0 ; j < EDGE_INTERP ; j++ )

	xor	ecx, ecx
	npad	9
$LL3@scoeff_ini:

; 88   :          {
; 89   :             gcombo[i][j] = interpoly(i,gauss2pt[j]);

	fld	QWORD PTR _gauss2pt[ecx]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	esi
	call	_interpoly
	fstp	QWORD PTR _gcombo[edx+ecx]

; 90   :             sdip[i][j] = interpolyderiv(i,gauss2pt[j]);

	fld	QWORD PTR _gauss2pt[ecx]
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	esi
	call	_interpolyderiv
	fst	QWORD PTR _sdip[edx+ecx]

; 91   :             ssimp[i][j] = gauss2wt[j]*sdip[i][j];

	fmul	QWORD PTR _gauss2wt[ecx]
	add	ecx, 8
	add	esp, 12					; 0000000cH
	fstp	QWORD PTR _ssimp[edx+ecx-8]
	cmp	ecx, 24					; 00000018H
	jl	SHORT $LL3@scoeff_ini

; 84   :     int i,j;
; 85   : 
; 86   :     for ( i = 0 ; i < EDGE_CTRL ;  i++ )

	add	edx, 24					; 00000018H
	inc	esi
	cmp	edx, 72					; 00000048H
	jl	SHORT $LL6@scoeff_ini
	pop	esi

; 92   :          }
; 93   : } // end scoeff_init()

	ret	0
_scoeff_init ENDP
_TEXT	ENDS
PUBLIC	__real@bfe0000000000000
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_force_q
EXTRN	_edge_grav_density:PROC
EXTRN	_dot:PROC
EXTRN	_sym_wrap:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@bfe0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@bfe0000000000000 DQ 0bfe0000000000000r	; -0.5
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\stringq.c
CONST	ENDS
;	COMDAT _edge_force_q
_TEXT	SEGMENT
_density$ = -296					; size = 8
tv1409 = -288						; size = 4
tv1417 = -284						; size = 4
_e_id$GSCopy$ = -280					; size = 4
_force$ = -276						; size = 12
_x$ = -264						; size = 12
tv2527 = -252						; size = 4
tv1412 = -252						; size = 4
tv2490 = -248						; size = 4
tv1419 = -248						; size = 4
_etang$ = -244						; size = 144
_torusx$ = -100						; size = 48
_norm$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_edge_force_q PROC					; COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 104  :   REAL *x[EDGE_CTRL],*force[EDGE_CTRL],etang[EDGE_INTERP][MAXCOORD];
; 105  :   REAL norm[MAXCOORD];
; 106  :   REAL len;
; 107  :   REAL density = get_edge_density(e_id);

	mov	ecx, DWORD PTR _web+124
	push	ebx

; 108  :   vertex_id hv = get_edge_headv(e_id);

	mov	ebx, DWORD PTR _web+636
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR _e_id$GSCopy$[ebp], esi
	mov	DWORD PTR tv1409[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	fld	QWORD PTR [eax+40]
	mov	ecx, DWORD PTR _web+216
	shr	esi, 27					; 0000001bH
	fstp	QWORD PTR _density$[ebp]
	and	esi, 1
	push	edi
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR tv1412[ebp], eax
	mov	DWORD PTR tv1417[ebp], esi
	je	SHORT $LN41@edge_force
	add	ecx, edi
	mov	DWORD PTR tv1419[ebp], ecx
	mov	ecx, DWORD PTR [ecx+304]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN40@edge_force
$LN41@edge_force:
	add	ecx, edi
	mov	DWORD PTR tv1419[ebp], ecx
	mov	ecx, DWORD PTR [ecx+304]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+ebx*4]
$LN40@edge_force:

; 109  :   vertex_id mv = get_edge_midv(e_id);

	mov	edx, DWORD PTR [eax+8]

; 110  :   vertex_id tv = get_edge_tailv(e_id);

	test	esi, esi
	je	SHORT $LN45@edge_force
	mov	eax, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN44@edge_force
$LN45@edge_force:
	mov	eax, DWORD PTR [eax]
$LN44@edge_force:

; 111  :   REAL torusx[MAXCOORD];  /* for unwrapping head in torus */
; 112  : 
; 113  :   int i,j,k;
; 114  : 
; 115  :   x[0] = get_coord(tv);

	mov	esi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edi+64]
	lea	edi, DWORD PTR [eax+ebx]

; 116  :   x[1] = get_coord(mv);

	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR _x$[ebp], edi
	lea	edi, DWORD PTR [edx+eax]

; 117  :   x[2] = get_coord(hv);

	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	lea	esi, DWORD PTR [ecx+eax]

; 118  :   force[0] = get_force(tv);

	mov	eax, DWORD PTR _web+104
	mov	DWORD PTR _x$[ebp+4], edi
	mov	edi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edi+784]

; 119  :   force[1] = get_force(mv);

	add	edx, eax
	lea	edi, DWORD PTR [eax+ebx]

; 120  :   force[2] = get_force(hv);

	add	eax, ecx

; 121  :   if ( web.torus_flag ) 

	cmp	DWORD PTR _web+860, 0
	mov	DWORD PTR _x$[ebp+8], esi
	mov	DWORD PTR _force$[ebp], edi
	mov	DWORD PTR _force$[ebp+4], edx
	mov	DWORD PTR _force$[ebp+8], eax
	je	SHORT $LN37@edge_force

; 122  :     { /* unwrap head */
; 123  :       (*sym_wrap)(x[2],torusx,get_edge_wrap(e_id));

	cmp	DWORD PTR tv1417[ebp], 0
	mov	eax, DWORD PTR tv1419[ebp]
	mov	ecx, DWORD PTR [eax+784]
	mov	edx, DWORD PTR tv1412[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	je	SHORT $LN50@edge_force
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN50@edge_force:
	push	eax
	lea	eax, DWORD PTR _torusx$[ebp]
	push	eax
	push	esi
	call	DWORD PTR _sym_wrap

; 124  :       x[2] = torusx;

	lea	ecx, DWORD PTR _torusx$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _x$[ebp+8], ecx
$LN37@edge_force:

; 125  :     }
; 126  :   for ( i = 0 ; i < EDGE_INTERP ; i++ )

	fldz
	mov	ebx, DWORD PTR _web+616
	xor	esi, esi
	lea	edi, DWORD PTR _etang$[ebp]
	mov	DWORD PTR tv2490[ebp], esi
	mov	DWORD PTR tv2527[ebp], edi
$LN98@edge_force:

; 127  :      {
; 128  :         for ( j = 0 ; j < SDIM ; j ++ )

	test	ebx, ebx
	jle	SHORT $LN101@edge_force
	mov	ecx, DWORD PTR _x$[ebp+4]

; 129  :           {
; 130  :              etang[i][j] = 0.0;

	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, edi
	mov	edi, DWORD PTR _x$[ebp+8]
	sub	edx, ecx
	sub	edi, ecx
$LN97@edge_force:
	fst	QWORD PTR [eax]
	add	ecx, 8

; 131  :              for ( k = 0 ; k < EDGE_CTRL ; k++ )
; 132  :                 etang[i][j] += sdip[k][i]*x[k][j];

	fld	QWORD PTR [edx+ecx-8]
	add	eax, 8
	dec	ebx
	fmul	QWORD PTR _sdip[esi]
	fadd	QWORD PTR [eax-8]
	fst	QWORD PTR [eax-8]
	fld	QWORD PTR [ecx-8]
	fmul	QWORD PTR _sdip[esi+24]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [eax-8]
	fld	QWORD PTR [edi+ecx-8]
	fmul	QWORD PTR _sdip[esi+48]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LN97@edge_force

; 127  :      {
; 128  :         for ( j = 0 ; j < SDIM ; j ++ )

	mov	ebx, DWORD PTR _web+616
	mov	edi, DWORD PTR tv2527[ebp]
$LN101@edge_force:

; 133  :           }
; 134  :         norm[i] = sqrt(SDIM_dot(etang[i],etang[i]));

	push	ebx
	fstp	ST(0)
	push	edi
	push	edi
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fst	QWORD PTR _norm$[ebp+esi]

; 135  :         if ( norm[i] > 0.0 ) 

	fldz
	mov	ebx, DWORD PTR _web+616
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN107@edge_force

; 136  :          for ( j = 0 ; j < SDIM ; j ++ )

	xor	edx, edx
	cmp	ebx, 4
	jl	SHORT $LN113@edge_force
	lea	ecx, DWORD PTR [ebx-4]
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [edi+8]
	lea	edx, DWORD PTR [ecx*4]
$LN80@edge_force:

; 137  :           etang[i][j] /= norm[i];

	fld	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	dec	ecx
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax-32]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [eax-24]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [eax-16]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN80@edge_force
$LN113@edge_force:

; 136  :          for ( j = 0 ; j < SDIM ; j ++ )

	fstp	ST(1)
	cmp	edx, ebx
	jge	SHORT $LN35@edge_force
	mov	eax, DWORD PTR tv2490[ebp]
	add	eax, edx
	mov	ecx, ebx
	lea	eax, DWORD PTR _etang$[ebp+eax*8]
	sub	ecx, edx
$LC26@edge_force:

; 137  :           etang[i][j] /= norm[i];

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	ecx
	fdiv	QWORD PTR _norm$[ebp+esi]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC26@edge_force

; 136  :          for ( j = 0 ; j < SDIM ; j ++ )

	jmp	SHORT $LN35@edge_force
$LN107@edge_force:
	fstp	ST(1)
$LN35@edge_force:

; 125  :     }
; 126  :   for ( i = 0 ; i < EDGE_INTERP ; i++ )

	add	DWORD PTR tv2490[ebp], 6
	add	edi, 48					; 00000030H
	add	esi, 8
	mov	DWORD PTR tv2527[ebp], edi
	cmp	esi, 24					; 00000018H
	jl	$LN98@edge_force

; 138  :      }
; 139  :   for ( i = 0 ; i < EDGE_CTRL ; i++ )

	fld	QWORD PTR _density$[ebp]
	lea	edi, DWORD PTR _force$[ebp]
	mov	ecx, OFFSET _ssimp+8
$LN23@edge_force:

; 140  :      for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN22@edge_force
	mov	eax, DWORD PTR [edi]
	lea	edx, DWORD PTR _etang$[ebp+48]
	sub	edx, eax
$LN20@edge_force:

; 141  :         for ( k = 0 ; k < EDGE_INTERP ; k++ )
; 142  :           force[i][j] -= density*ssimp[i][k]*etang[k][j];

	fld	ST(0)
	inc	esi
	fmul	QWORD PTR [ecx-8]
	add	eax, 8
	fmul	QWORD PTR [edx+eax-56]
	fsubr	QWORD PTR [eax-8]
	fst	QWORD PTR [eax-8]
	fld	QWORD PTR [ecx]
	fmul	ST(0), ST(2)
	fmul	QWORD PTR [edx+eax-8]
	fsubp	ST(1), ST(0)
	fst	QWORD PTR [eax-8]
	fld	QWORD PTR [ecx+8]
	fmul	ST(0), ST(2)
	fmul	QWORD PTR [edx+eax+40]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax-8]
	mov	ebx, DWORD PTR _web+616
	cmp	esi, ebx
	jl	SHORT $LN20@edge_force
$LN22@edge_force:

; 138  :      }
; 139  :   for ( i = 0 ; i < EDGE_CTRL ; i++ )

	add	ecx, 24					; 00000018H
	add	edi, 4
	cmp	ecx, OFFSET _ssimp+80
	jl	SHORT $LN23@edge_force

; 143  : 
; 144  :   len = 0.0;
; 145  :   for ( i = 0 ; i < EDGE_INTERP ; i++ )
; 146  :      len += gauss2wt[i]*norm[i];
; 147  : 
; 148  :   set_edge_length(e_id,len);

	mov	ecx, DWORD PTR _web+124
	fstp	ST(0)
	fld	QWORD PTR _gauss2wt
	mov	eax, DWORD PTR tv1409[ebp]
	fmul	QWORD PTR _norm$[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	pop	edi
	pop	esi
	faddp	ST(1), ST(0)
	pop	ebx
	fld	QWORD PTR _gauss2wt+8
	fmul	QWORD PTR _norm$[ebp+8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _gauss2wt+16
	fmul	QWORD PTR _norm$[ebp+16]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx+48]

; 149  : 
; 150  :   /* calculate gravitational forces */
; 151  :   if ( web.gravflag && !( get_eattr(e_id) & NONCONTENT) )

	cmp	DWORD PTR _web+824, 0
	je	$LN7@edge_force
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN7@edge_force

; 152  :   { REAL z;
; 153  :     REAL gdensity = edge_grav_density(e_id);

	mov	edx, DWORD PTR _e_id$GSCopy$[ebp]
	push	edx
	call	_edge_grav_density

; 154  : 
; 155  :     if ( gdensity != 0.0 )

	fld	ST(0)
	fldz
	add	esp, 4
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	$LN127@edge_force
	fld	ST(1)

; 156  :     { for ( i = 0 ; i < EDGE_INTERP ; i++ )

	lea	ecx, DWORD PTR _etang$[ebp]
	fmul	QWORD PTR __real@bfe0000000000000
	xor	eax, eax
$LN9@edge_force:

; 157  :       { z = 0.0;
; 158  :         for ( j = 0 ; j < EDGE_CTRL ; j++ )
; 159  :           z += gcombo[j][i]*x[j][1];

	fld	QWORD PTR _gcombo[eax]
	mov	edx, DWORD PTR _x$[ebp]
	fmul	QWORD PTR [edx+8]
	mov	edx, DWORD PTR _x$[ebp+4]
	add	eax, 8
	add	ecx, 48					; 00000030H
	fadd	ST(0), ST(2)
	fld	QWORD PTR [edx+8]
	mov	edx, DWORD PTR _x$[ebp+8]
	fmul	QWORD PTR _gcombo[eax+16]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _gcombo[eax+40]
	fmul	QWORD PTR [edx+8]

; 160  :         for ( j = 0 ; j < EDGE_CTRL ; j++ )
; 161  :         { force[j][1] -= -gdensity*z*etang[i][0]*gcombo[j][i];

	mov	edx, DWORD PTR _force$[ebp]
	faddp	ST(1), ST(0)
	fld	ST(0)
	fmul	ST(0), ST(4)
	fld	QWORD PTR [ecx-48]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR _gcombo[eax-8]
	fchs
	fsubr	QWORD PTR [edx+8]
	fstp	QWORD PTR [edx+8]

; 162  :           force[j][0] -= -0.5*gdensity*z*z*sdip[j][i];

	fld	ST(2)
	fmul	ST(0), ST(2)
	fmulp	ST(2), ST(0)
	fld	QWORD PTR _sdip[eax-8]
	fmul	ST(0), ST(2)
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR _force$[ebp+4]
	fld	QWORD PTR [ecx-48]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR _gcombo[eax+16]
	fchs
	fsubr	QWORD PTR [edx+8]
	fstp	QWORD PTR [edx+8]
	fld	QWORD PTR _sdip[eax+16]
	fmul	ST(0), ST(2)
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR _force$[ebp+8]
	fmul	QWORD PTR [ecx-48]
	fmul	QWORD PTR _gcombo[eax+40]
	fchs
	fsubr	QWORD PTR [edx+8]
	fstp	QWORD PTR [edx+8]
	fmul	QWORD PTR _sdip[eax+40]
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	cmp	eax, 24					; 00000018H
	jl	$LN9@edge_force

; 156  :     { for ( i = 0 ; i < EDGE_INTERP ; i++ )

	fstp	ST(2)
$LN127@edge_force:
	fstp	ST(1)
	fstp	ST(0)
$LN7@edge_force:

; 163  :         }
; 164  :       }                  
; 165  :     }
; 166  :   }                    
; 167  : 
; 168  : } // end edge_force_q()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_force_q ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_edge_energy_q
EXTRN	_binary_tree_add:PROC
; Function compile flags: /Ogtp
;	COMDAT _edge_energy_q
_TEXT	SEGMENT
_density$ = -144					; size = 8
tv744 = -136						; size = 8
tv583 = -132						; size = 4
tv584 = -128						; size = 4
_x$ = -124						; size = 12
_len$ = -112						; size = 8
tv577 = -108						; size = 4
tv580 = -104						; size = 4
_torusx$ = -100						; size = 48
_etang$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_edge_energy_q PROC					; COMDAT

; 178  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	push	edi

; 179  :   REAL *x[EDGE_CTRL];
; 180  :   REAL etang[MAXCOORD];
; 181  :   vertex_id v[EDGE_CTRL];
; 182  :   REAL len;
; 183  :   int i,j,k;
; 184  :   REAL z;
; 185  :   REAL density = edge_grav_density(e_id);

	push	esi
	call	_edge_grav_density
	fstp	QWORD PTR _density$[ebp]

; 186  :   REAL torusx[MAXCOORD];  /* for unwrapping head in torus */
; 187  :                   
; 188  :   v[0] = get_edge_tailv(e_id);

	mov	edx, DWORD PTR _dymem
	mov	ebx, esi
	shr	ebx, 27					; 0000001bH
	add	esp, 4
	and	ebx, 1
	mov	DWORD PTR tv577[ebp], ebx
	je	SHORT $LN25@edge_energ
	mov	eax, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	DWORD PTR tv580[ebp], esi
	mov	esi, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR [eax+edx+304]
	add	eax, edx
	mov	DWORD PTR tv584[ebp], eax
	mov	eax, DWORD PTR _web+636
	add	ecx, esi
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN77@edge_energ
$LN25@edge_energ:
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR _web+216
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	add	eax, edx
	mov	DWORD PTR tv580[ebp], esi
	mov	esi, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR [eax+304]
	add	ecx, esi
	mov	DWORD PTR tv584[ebp], eax
	mov	eax, DWORD PTR [ecx]
$LN77@edge_energ:

; 189  :   v[1] = get_edge_midv(e_id);

	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR tv583[ebp], esi

; 190  :   v[2] = get_edge_headv(e_id);

	test	ebx, ebx
	je	SHORT $LN29@edge_energ
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LN28@edge_energ
$LN29@edge_energ:
	mov	esi, DWORD PTR _web+636
	mov	ecx, DWORD PTR [ecx+esi*4]
$LN28@edge_energ:

; 191  :   for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 192  :     x[i] = get_coord(v[i]);

	mov	esi, DWORD PTR _web+104
	mov	esi, DWORD PTR [esi+edx+64]
	mov	edx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edx+edi*4]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+ecx*4]
	add	eax, esi
	add	ebx, esi
	add	edi, esi

; 193  :              
; 194  :   if ( web.torus_flag ) 

	cmp	DWORD PTR _web+860, 0
	mov	DWORD PTR _x$[ebp], eax
	mov	DWORD PTR _x$[ebp+4], ebx
	mov	DWORD PTR _x$[ebp+8], edi
	je	SHORT $LN18@edge_energ

; 195  :   { /* unwrap head */
; 196  :     (*sym_wrap)(x[2],torusx,get_edge_wrap(e_id));

	cmp	DWORD PTR tv577[ebp], 0
	mov	edx, DWORD PTR tv584[ebp]
	mov	eax, DWORD PTR [edx+784]
	mov	ecx, DWORD PTR tv583[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	je	SHORT $LN34@edge_energ
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN34@edge_energ:
	push	eax
	lea	edx, DWORD PTR _torusx$[ebp]
	push	edx
	push	edi
	call	DWORD PTR _sym_wrap

; 197  :     x[2] = torusx;

	mov	eax, DWORD PTR _x$[ebp]
	lea	edi, DWORD PTR _torusx$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _x$[ebp+8], edi
$LN18@edge_energ:

; 198  :   }
; 199  :      
; 200  :   /* calculate tangents at integration points and accumulate */
; 201  :   len = 0.0;

	fldz

; 202  :   for ( i = 0 ; i < EDGE_INTERP ; i++ )

	xor	esi, esi
	fst	QWORD PTR _len$[ebp]
	jmp	SHORT $LN17@edge_energ
$LL63@edge_energ:
	fldz
	mov	eax, DWORD PTR _x$[ebp]
$LN17@edge_energ:

; 203  :   { for ( j = 0 ; j < SDIM ; j ++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN66@edge_energ

; 204  :     { etang[j] = 0.0;

	mov	edx, eax
	lea	eax, DWORD PTR _etang$[ebp]
	sub	edx, ebx
	sub	edi, ebx
	sub	ebx, eax
$LN14@edge_energ:
	fst	QWORD PTR _etang$[ebp+ecx*8]
	lea	eax, DWORD PTR [ebx+ecx*8]
	lea	eax, DWORD PTR _etang$[ebp+eax]

; 205  :       for ( k = 0 ; k < EDGE_CTRL ; k++ )
; 206  :         etang[j] += sdip[k][i]*x[k][j];

	fld	QWORD PTR [eax+edx]
	inc	ecx
	fmul	QWORD PTR _sdip[esi*8]
	fadd	QWORD PTR _etang$[ebp+ecx*8-8]
	fst	QWORD PTR _etang$[ebp+ecx*8-8]
	fld	QWORD PTR _sdip[esi*8+24]
	fmul	QWORD PTR [eax]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _etang$[ebp+ecx*8-8]
	fld	QWORD PTR [eax+edi]
	fmul	QWORD PTR _sdip[esi*8+48]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _etang$[ebp+ecx*8-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN14@edge_energ

; 203  :   { for ( j = 0 ; j < SDIM ; j ++ )

	mov	ebx, DWORD PTR _x$[ebp+4]
	mov	edi, DWORD PTR _x$[ebp+8]
$LN66@edge_energ:

; 207  :     }
; 208  :     len += gauss2wt[i]*sqrt(SDIM_dot(etang,etang));

	mov	ecx, DWORD PTR _web+616
	fstp	ST(0)
	push	ecx
	lea	edx, DWORD PTR _etang$[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fmul	QWORD PTR _gauss2wt[esi*8]

; 209  : 
; 210  :     /* calculate gravitational energy */
; 211  :     if ( web.gravflag &&  (density != 0.0) && !(get_eattr(e_id) & NONCONTENT) )

	cmp	DWORD PTR _web+824, 0
	fadd	QWORD PTR _len$[ebp]
	fstp	QWORD PTR _len$[ebp]
	je	$LN16@edge_energ
	fld	QWORD PTR _density$[ebp]
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN75@edge_energ
	mov	ecx, DWORD PTR tv580[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN75@edge_energ

; 212  :     { for ( i = 0 ; i < EDGE_INTERP ; i++ )

	fmul	QWORD PTR __real@bfe0000000000000
	xor	esi, esi
	fstp	QWORD PTR tv744[ebp]
$LL61@edge_energ:

; 213  :       { z = 0.0;
; 214  :         for ( j = 0 ; j < EDGE_CTRL ; j++ )
; 215  :         z += gcombo[j][i]*x[j][1];

	fld	QWORD PTR _gcombo[esi*8]
	mov	eax, DWORD PTR _x$[ebp]
	fmul	QWORD PTR [eax+8]

; 216  :         binary_tree_add(web.total_energy_addends,-0.5*density*z*z*etang[0]);

	sub	esp, 8
	fadd	QWORD PTR __real@0000000000000000
	fld	QWORD PTR _gcombo[esi*8+24]
	fmul	QWORD PTR [ebx+8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _gcombo[esi*8+48]
	fmul	QWORD PTR [edi+8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR tv744[ebp]
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR _etang$[ebp]
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1248
	call	_binary_tree_add
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, 3
	jl	SHORT $LL61@edge_energ

; 212  :     { for ( i = 0 ; i < EDGE_INTERP ; i++ )

	jmp	SHORT $LN16@edge_energ
$LN75@edge_energ:

; 209  : 
; 210  :     /* calculate gravitational energy */
; 211  :     if ( web.gravflag &&  (density != 0.0) && !(get_eattr(e_id) & NONCONTENT) )

	fstp	ST(0)
$LN16@edge_energ:

; 202  :   for ( i = 0 ; i < EDGE_INTERP ; i++ )

	inc	esi
	cmp	esi, 3
	jl	$LL63@edge_energ

; 217  :       }                  
; 218  :     }
; 219  :   }
; 220  :   set_edge_length(e_id,len);

	mov	ecx, DWORD PTR _web+124
	fld	QWORD PTR _len$[ebp]
	mov	eax, DWORD PTR tv580[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	fst	QWORD PTR [edx+48]

; 221  : 
; 222  :   binary_tree_add(web.total_energy_addends,len*get_edge_density(e_id));

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [eax+ecx]
	fmul	QWORD PTR [edx+40]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1248
	call	_binary_tree_add
	add	esp, 12					; 0000000cH

; 223  :   if ( web.representation == STRING ) /* don't count triple junction as area */

	cmp	DWORD PTR _web+624, 1
	pop	edi
	pop	esi
	pop	ebx
	jne	SHORT $LN1@edge_energ

; 224  :       web.total_area    += len;

	fld	QWORD PTR _web+992
	fadd	QWORD PTR _len$[ebp]
	fstp	QWORD PTR _web+992
$LN1@edge_energ:

; 225  : } // end edge_energy_q()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_energy_q ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_edge_area_q
EXTRN	_add_body_volume:PROC
EXTRN	_mat_mul_tr:PROC
EXTRN	_mat2d_setup:PROC
; Function compile flags: /Ogtp
;	COMDAT _edge_area_q
_TEXT	SEGMENT
_uqXvS$89229 = -200					; size = 12
_x$ = -188						; size = 12
_b_id2$ = -176						; size = 4
tv1126 = -172						; size = 4
_b_id1$ = -168						; size = 4
_f_id1$ = -164						; size = 4
_uxJ$89230 = -160					; size = 144
_v$ = -16						; size = 12
_area$ = -12						; size = 8
_wy$89233 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_fe_id$ = 8						; size = 4
_edge_area_q PROC					; COMDAT

; 235  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 236  :   body_id b_id1,b_id2;
; 237  :   facet_id f_id1,f_id2;
; 238  :   REAL *x[EDGE_CTRL];
; 239  :   REAL area = 0.0;
; 240  :   vertex_id v[EDGE_CTRL];
; 241  :   int i,j;
; 242  :   edge_id e_id = get_fe_edge(fe_id);

	mov	ecx, DWORD PTR _fe_id$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _web+460
	push	esi
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	esi, ecx
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [edx+20]

; 243  :                   
; 244  :   if ( get_eattr(e_id) & NONCONTENT ) return;

	mov	edx, DWORD PTR _web+124
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	edx, edx
	or	eax, edx
	jne	$LN1@edge_area_

; 245  : 
; 246  :   /* be sure have original orientation of edge so torus midpoints
; 247  :       have same wrap as tail */
; 248  :   if ( inverted(e_id) )

	test	esi, 134217728				; 08000000H
	je	SHORT $LN22@edge_area_

; 249  :   { invert(e_id); invert(fe_id); }

	xor	esi, 134217728				; 08000000H
	xor	ecx, 134217728				; 08000000H
$LN22@edge_area_:

; 250  : 
; 251  :   f_id1 = get_fe_facet(fe_id);

	mov	eax, ecx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	push	edi
	mov	edi, DWORD PTR _NULLFACET
	jne	SHORT $LN33@edge_area_
	mov	edx, edi
	mov	DWORD PTR _f_id1$[ebp], edx
	jmp	SHORT $LN34@edge_area_
$LN33@edge_area_:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR [edx+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN32@edge_area_
	xor	edx, 134217728				; 08000000H
$LN32@edge_area_:
	mov	DWORD PTR _f_id1$[ebp], edx
$LN34@edge_area_:

; 252  :   f_id2 = facet_inverse(get_fe_facet(fe_id));

	test	eax, eax
	je	SHORT $LN36@edge_area_
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	edi, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN36@edge_area_
	xor	edi, 134217728				; 08000000H
$LN36@edge_area_:

; 253  :   if ( !valid_id(f_id1) && !valid_id(f_id2) ) return; /* no facets */

	mov	eax, edx
	shr	eax, 28					; 0000001cH
	xor	edi, 134217728				; 08000000H
	and	eax, 1
	mov	DWORD PTR tv1126[ebp], eax
	jne	SHORT $LN21@edge_area_
	test	edi, 268435456				; 10000000H
	je	$LN104@edge_area_
$LN21@edge_area_:

; 254  :   b_id1 = get_facet_body(f_id1);

	push	edx
	call	_get_facet_body

; 255  :   b_id2 = get_facet_body(f_id2);

	push	edi
	mov	DWORD PTR _b_id1$[ebp], eax
	call	_get_facet_body

; 256  : 
; 257  :   v[0] = get_edge_tailv(e_id);

	push	esi
	mov	DWORD PTR _b_id2$[ebp], eax
	call	_get_edge_tailv

; 258  :   v[1] = get_edge_midv(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	mov	ebx, eax
	mov	eax, DWORD PTR _web+216
	add	edi, edi
	mov	edx, DWORD PTR [edi+ecx]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	ecx, DWORD PTR [edx+eax+8]

; 259  :   v[2] = get_edge_headv(e_id);

	push	esi
	mov	DWORD PTR _v$[ebp+4], ecx
	call	_get_edge_headv

; 260  :   for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 261  :      x[i] = get_coord(v[i]);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _web+104
	and	ebx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR _dymem
	add	ebx, DWORD PTR [edx+ecx+64]
	mov	ecx, DWORD PTR _v$[ebp+4]
	mov	DWORD PTR _x$[ebp], ebx
	mov	ebx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+ebx+64]
	mov	ebx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR _x$[ebp+4], ecx
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ebx+64]
	add	esp, 16					; 00000010H

; 262  :              
; 263  :   if ( web.torus_flag ) 

	cmp	DWORD PTR _web+860, 0
	mov	DWORD PTR _x$[ebp+8], eax
	je	$LN17@edge_area_

; 264  :   { MAT2D(u,EDGE_CTRL,MAXCOORD);

	push	6
	push	3
	lea	edx, DWORD PTR _uxJ$89230[ebp]
	push	edx
	lea	eax, DWORD PTR _uqXvS$89229[ebp]
	push	eax
	call	_mat2d_setup

; 265  :     int wy; /* wraps */
; 266  :     WRAPTYPE wrap = get_edge_wrap(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [edi+ecx]
	mov	ecx, DWORD PTR _dymem
	mov	ebx, eax
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]
	add	esp, 16					; 00000010H
	test	esi, 134217728				; 08000000H
	je	SHORT $LN42@edge_area_
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN42@edge_area_:

; 267  :     mat_mul_tr(x,web.inverse_periods,u,EDGE_CTRL,SDIM,SDIM);

	mov	ecx, DWORD PTR _web+1612
	mov	esi, eax
	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	push	3
	push	ebx
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_mat_mul_tr

; 268  :     for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 269  :       for ( j = 0 ; j < EDGE_CTRL ; j ++ )
; 270  :          area += scoeff[i][j]*u[i][1]*u[j][0];

	mov	eax, DWORD PTR [ebx]
	fld	QWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ebx+4]
	fmul	QWORD PTR _scoeff
	mov	edx, DWORD PTR [ebx+8]

; 271  :     wy = WRAPNUM((wrap>>TWRAPBITS) & WRAPMASK);

	sar	esi, 6
	and	esi, 31					; 0000001fH
	fmul	QWORD PTR [eax]
	add	esp, 24					; 00000018H
	fadd	QWORD PTR __real@0000000000000000
	fld	QWORD PTR _scoeff+8
	fmul	QWORD PTR [eax+8]
	fmul	QWORD PTR [ecx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _scoeff+16
	fmul	QWORD PTR [eax+8]
	fmul	QWORD PTR [edx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _scoeff+24
	fmul	QWORD PTR [ecx+8]
	fmul	QWORD PTR [eax]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _scoeff+32
	fmul	QWORD PTR [ecx+8]
	fmul	QWORD PTR [ecx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _scoeff+40
	fmul	QWORD PTR [ecx+8]
	fmul	QWORD PTR [edx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _scoeff+48
	fmul	QWORD PTR [edx+8]
	fmul	QWORD PTR [eax]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _scoeff+56
	fmul	QWORD PTR [edx+8]
	fmul	QWORD PTR [ecx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _scoeff+64
	fmul	QWORD PTR [edx+8]
	fmul	QWORD PTR [edx]
	faddp	ST(1), ST(0)
	cmp	esi, 16					; 00000010H
	jle	SHORT $LN26@edge_area_
	add	esi, -32				; ffffffe0H
$LN26@edge_area_:
	mov	DWORD PTR _wy$89233[ebp], esi

; 272  :     area += wy*u[2][0];
; 273  :     area *= web.torusv;

	fild	DWORD PTR _wy$89233[ebp]
	mov	eax, edx
	fmul	QWORD PTR [eax]
	faddp	ST(1), ST(0)
	fmul	QWORD PTR _web+1600

; 274  :   }
; 275  :   else 

	jmp	SHORT $LN123@edge_area_
$LN17@edge_area_:

; 276  :    for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 277  :     for ( j = 0 ; j < EDGE_CTRL ; j ++ )
; 278  :        area += scoeff[i][j]*x[i][1]*x[j][0];

	mov	edx, DWORD PTR _x$[ebp]
	fld	QWORD PTR [edx+8]
	fmul	QWORD PTR _scoeff
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR __real@0000000000000000
	fld	QWORD PTR _scoeff+8
	fmul	QWORD PTR [edx+8]
	fmul	QWORD PTR [ecx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _scoeff+16
	fmul	QWORD PTR [edx+8]
	fmul	QWORD PTR [eax]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _scoeff+24
	fmul	QWORD PTR [ecx+8]
	fmul	QWORD PTR [edx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _scoeff+32
	fmul	QWORD PTR [ecx+8]
	fmul	QWORD PTR [ecx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _scoeff+40
	fmul	QWORD PTR [ecx+8]
	fmul	QWORD PTR [eax]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _scoeff+48
	fmul	QWORD PTR [eax+8]
	fmul	QWORD PTR [edx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _scoeff+56
	fmul	QWORD PTR [eax+8]
	fmul	QWORD PTR [ecx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _scoeff+64
	fmul	QWORD PTR [eax+8]
	fmul	QWORD PTR [eax]
	faddp	ST(1), ST(0)
$LN123@edge_area_:

; 279  : 
; 280  :   /* add to body areas */
; 281  :   if ( valid_id(f_id1 ) )

	cmp	DWORD PTR tv1126[ebp], 0
	fst	QWORD PTR _area$[ebp]
	je	SHORT $LN3@edge_area_

; 282  :      add_facet_area(f_id1, area);

	mov	eax, DWORD PTR _f_id1$[ebp]
	fld	ST(0)
	test	eax, 134217728				; 08000000H
	je	SHORT $LN29@edge_area_
	fchs
$LN29@edge_area_:
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	fadd	QWORD PTR [eax+40]
	fstp	QWORD PTR [eax+40]
$LN3@edge_area_:

; 283  :   
; 284  :   if ( valid_id(b_id1 ) )

	mov	eax, DWORD PTR _b_id1$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2@edge_area_

; 285  :      add_body_volume(b_id1, area);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	call	_add_body_volume
	fld	QWORD PTR _area$[ebp]
	add	esp, 12					; 0000000cH
$LN2@edge_area_:

; 286  :   
; 287  :   if ( valid_id(b_id2 ) )

	mov	eax, DWORD PTR _b_id2$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN121@edge_area_

; 288  :      add_body_volume(b_id2, -area);

	sub	esp, 8
	fchs
	fstp	QWORD PTR [esp]
	push	eax
	call	_add_body_volume
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 289  : } // end edge_area_q()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN121@edge_area_:

; 286  :   
; 287  :   if ( valid_id(b_id2 ) )

	fstp	ST(0)
$LN104@edge_area_:
	pop	edi
$LN1@edge_area_:

; 289  : } // end edge_area_q()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_area_q ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_string_grad_q
EXTRN	_get_bv_new_vgrad:PROC
EXTRN	_mat_mult:PROC
EXTRN	_edge_ctrl:DWORD
; Function compile flags: /Ogtp
;	COMDAT _string_grad_q
_TEXT	SEGMENT
_gradqXvS$ = -528					; size = 12
_uqXvS$ = -516						; size = 12
_gqXvS$ = -504						; size = 12
_u$ = -492						; size = 4
_bj_id$ = -488						; size = 4
_g$ = -484						; size = 4
_grad$ = -480						; size = 4
_bi_id$ = -476						; size = 4
_fe_id$ = -472						; size = 4
tv3176 = -468						; size = 4
tv633 = -468						; size = 4
_x$ = -464						; size = 12
tv4678 = -452						; size = 4
_wrapnum$ = -452					; size = 4
_e_id$89289 = -452					; size = 4
_uxJ$ = -448						; size = 144
_gxJ$ = -304						; size = 144
_gradxJ$ = -160						; size = 144
_v$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_string_grad_q PROC					; COMDAT

; 299  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 528				; 00000210H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 300  :   body_id bi_id;  /* identifier for body i */
; 301  :   body_id bj_id;  /* identifier for body j */
; 302  :   facetedge_id fe_id;
; 303  :   REAL *x[EDGE_CTRL];
; 304  :   int i,j,k;
; 305  :   vertex_id v[EDGE_CTRL];
; 306  :   volgrad *vgptr;
; 307  :   MAT2D(u,EDGE_CTRL,MAXCOORD); /* affine coordinates of vertices */

	push	6
	push	3
	lea	eax, DWORD PTR _uxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _uqXvS$[ebp]
	push	ecx
	call	_mat2d_setup

; 308  :   MAT2D(g,EDGE_CTRL,MAXCOORD);

	push	6
	push	3
	lea	edx, DWORD PTR _gxJ$[ebp]
	mov	DWORD PTR _u$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _gqXvS$[ebp]
	push	eax
	call	_mat2d_setup

; 309  :   MAT2D(grad,EDGE_CTRL,MAXCOORD);

	push	6
	push	3
	lea	ecx, DWORD PTR _gradxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _gradqXvS$[ebp]
	push	edx
	mov	DWORD PTR _g$[ebp], eax
	call	_mat2d_setup

; 310  :   int wrap,wrapnum;
; 311  :   
; 312  : 
; 313  :   FOR_ALL_FACETEDGES(fe_id)

	mov	esi, DWORD PTR _web+496
	add	esp, 48					; 00000030H
	mov	DWORD PTR _grad$[ebp], eax
	mov	DWORD PTR _fe_id$[ebp], esi
	test	esi, 268435456				; 10000000H
	je	$LN40@string_gra
	push	ebx
	mov	ebx, DWORD PTR _web+460
	push	edi
	npad	2
$LL42@string_gra:
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN41@string_gra

; 314  :   {
; 315  :     edge_id e_id = get_fe_edge(fe_id);
; 316  :                   
; 317  :     if ( get_eattr(e_id) & NONCONTENT ) continue;

	mov	eax, DWORD PTR _web+124
	mov	ecx, esi
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [edx+20]
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR _e_id$89289[ebp], ecx
	jne	$LN41@string_gra

; 318  : 
; 319  :     /* be sure have original orientation of edge so torus midpoints
; 320  :        have same wrap as tail */
; 321  :     if ( inverted(e_id) )

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN36@string_gra

; 322  :     { invert(e_id); invert(fe_id); }

	xor	ecx, 134217728				; 08000000H
	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR _e_id$89289[ebp], ecx
	mov	DWORD PTR _fe_id$[ebp], esi
$LN36@string_gra:

; 323  : 
; 324  :     bi_id = get_facet_body(get_fe_facet(fe_id));

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN50@string_gra
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN49@string_gra
$LN50@string_gra:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+ecx*4]
	mov	eax, DWORD PTR [edx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN49@string_gra
	xor	eax, 134217728				; 08000000H
$LN49@string_gra:
	push	eax
	call	_get_facet_body
	mov	edi, eax

; 325  :     bj_id = get_facet_body(get_fe_facet(get_next_facet(fe_inverse(fe_id))));

	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	add	esp, 4
	mov	DWORD PTR _bi_id$[ebp], edi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN54@string_gra
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN53@string_gra
$LN54@string_gra:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [ecx+40]
$LN53@string_gra:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN58@string_gra
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN59@string_gra
$LN58@string_gra:
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+edx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN57@string_gra
	xor	ecx, 134217728				; 08000000H
$LN57@string_gra:
	mov	eax, ecx
$LN59@string_gra:
	push	eax
	call	_get_facet_body

; 326  :     if ( !(valid_id(bi_id) && (get_battr(bi_id) & (FIXEDVOL|PRESSURE))) 
; 327  :        && !(valid_id(bj_id) && (get_battr(bj_id) & (FIXEDVOL|PRESSURE))) )

	mov	ecx, edi
	shr	ecx, 28					; 0000001cH
	add	esp, 4
	and	ecx, 1
	mov	DWORD PTR _bj_id$[ebp], eax
	mov	DWORD PTR tv3176[ebp], ecx
	je	SHORT $LN159@string_gra
	mov	edx, DWORD PTR _web+348
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+edi*4]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 2080				; 00000820H
	xor	edx, edx
	or	ecx, edx
	jne	SHORT $LN35@string_gra
$LN159@string_gra:
	test	eax, 268435456				; 10000000H
	je	$LN41@string_gra
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2080				; 00000820H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN41@string_gra
$LN35@string_gra:

; 328  :          continue;
; 329  : 
; 330  :     v[0] = get_fe_tailv(fe_id);

	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+edx*4]
	mov	ecx, DWORD PTR [eax+20]
	lea	ebx, DWORD PTR [ebx+edx*4]
	and	esi, 134217728				; 08000000H
	xor	ecx, esi
	push	ecx
	call	_get_edge_tailv

; 331  :     v[1] = get_fe_midv(fe_id);

	mov	edx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR _dymem
	mov	edi, eax
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ebx+304]
	mov	ecx, DWORD PTR [ecx+edx+8]

; 332  :     v[2] = get_fe_headv(fe_id);

	xor	eax, esi
	push	eax
	mov	DWORD PTR _v$[ebp], edi
	mov	DWORD PTR _v$[ebp+4], ecx
	call	_get_edge_headv

; 333  :     for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 334  :       x[i] = get_coord(v[i]);

	mov	esi, DWORD PTR _web+12
	mov	edx, DWORD PTR _web+104
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+edi*4]
	add	ecx, DWORD PTR [edx+ebx+64]
	mov	DWORD PTR _v$[ebp+8], eax
	mov	DWORD PTR _x$[ebp], ecx
	mov	ecx, DWORD PTR _v$[ebp+4]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	add	ecx, DWORD PTR [edx+ebx+64]
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR _x$[ebp+4], ecx
	mov	eax, DWORD PTR [esi+eax*4]
	add	eax, DWORD PTR [edx+ebx+64]
	add	esp, 8

; 335  : 
; 336  :     if ( web.torus_flag ) 

	cmp	DWORD PTR _web+860, 0
	mov	DWORD PTR _x$[ebp+8], eax
	je	$LN29@string_gra

; 337  :     { /* get affine coordinates of vertices */
; 338  :       mat_mul_tr(x,web.inverse_periods,u,edge_ctrl,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _edge_ctrl
	mov	edi, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR _web+1612
	push	eax
	push	eax
	push	ecx
	push	edi
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_mat_mul_tr

; 339  :       /* main integral over edge */
; 340  :       for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 341  :         for ( j = 0 ; j < EDGE_CTRL ; j++ )
; 342  :         { REAL v = scoeff[j][i];

	fld	QWORD PTR _scoeff

; 344  :           g[i][0] += v*u[j][1];

	mov	esi, DWORD PTR _g$[ebp]
	fld	ST(0)
	fldz
	add	esp, 24					; 00000018H
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	SHORT $LN162@string_gra
	mov	eax, DWORD PTR [edi]
	fld	QWORD PTR [eax+8]
	mov	ecx, DWORD PTR [esi]
	fmul	ST(0), ST(2)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]

; 345  :           g[j][1] += v*u[i][0];

	fld	QWORD PTR [eax]
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR [ecx+8]
	fstp	QWORD PTR [ecx+8]
	jmp	SHORT $LN24@string_gra
$LN162@string_gra:

; 343  :           if ( v == 0.0 ) continue;

	fstp	ST(1)
$LN24@string_gra:

; 339  :       /* main integral over edge */
; 340  :       for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 341  :         for ( j = 0 ; j < EDGE_CTRL ; j++ )
; 342  :         { REAL v = scoeff[j][i];

	fld	QWORD PTR _scoeff+24

; 343  :           if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN166@string_gra

; 344  :           g[i][0] += v*u[j][1];

	mov	ecx, DWORD PTR [edi+4]
	fld	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR [esi]

; 345  :           g[j][1] += v*u[i][0];

	mov	edx, DWORD PTR [edi]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR [esi+4]
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	jmp	SHORT $LN99@string_gra
$LN166@string_gra:
	fstp	ST(0)
$LN99@string_gra:

; 339  :       /* main integral over edge */
; 340  :       for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 341  :         for ( j = 0 ; j < EDGE_CTRL ; j++ )
; 342  :         { REAL v = scoeff[j][i];

	fld	QWORD PTR _scoeff+48

; 343  :           if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN169@string_gra

; 344  :           g[i][0] += v*u[j][1];

	mov	ecx, DWORD PTR [edi+8]
	fld	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR [esi]

; 345  :           g[j][1] += v*u[i][0];

	mov	edx, DWORD PTR [edi]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR [esi+8]
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	jmp	SHORT $LN27@string_gra
$LN169@string_gra:
	fstp	ST(0)
$LN27@string_gra:

; 339  :       /* main integral over edge */
; 340  :       for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 341  :         for ( j = 0 ; j < EDGE_CTRL ; j++ )
; 342  :         { REAL v = scoeff[j][i];

	fld	QWORD PTR _scoeff+8

; 343  :           if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN172@string_gra

; 344  :           g[i][0] += v*u[j][1];

	mov	ecx, DWORD PTR [edi]
	fld	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR [esi+4]

; 345  :           g[j][1] += v*u[i][0];

	mov	edx, DWORD PTR [edi+4]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	jmp	SHORT $LN114@string_gra
$LN172@string_gra:
	fstp	ST(0)
$LN114@string_gra:

; 339  :       /* main integral over edge */
; 340  :       for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 341  :         for ( j = 0 ; j < EDGE_CTRL ; j++ )
; 342  :         { REAL v = scoeff[j][i];

	fld	QWORD PTR _scoeff+32

; 343  :           if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN175@string_gra

; 344  :           g[i][0] += v*u[j][1];

	mov	eax, DWORD PTR [edi+4]
	fld	QWORD PTR [eax+8]
	mov	ecx, DWORD PTR [esi+4]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]

; 345  :           g[j][1] += v*u[i][0];

	fmul	QWORD PTR [eax]
	fadd	QWORD PTR [ecx+8]
	fstp	QWORD PTR [ecx+8]
	jmp	SHORT $LN116@string_gra
$LN175@string_gra:
	fstp	ST(0)
$LN116@string_gra:

; 339  :       /* main integral over edge */
; 340  :       for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 341  :         for ( j = 0 ; j < EDGE_CTRL ; j++ )
; 342  :         { REAL v = scoeff[j][i];

	fld	QWORD PTR _scoeff+56

; 343  :           if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN178@string_gra

; 344  :           g[i][0] += v*u[j][1];

	mov	ecx, DWORD PTR [edi+8]
	fld	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR [esi+4]

; 345  :           g[j][1] += v*u[i][0];

	mov	edx, DWORD PTR [edi+4]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR [esi+8]
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	jmp	SHORT $LN118@string_gra
$LN178@string_gra:
	fstp	ST(0)
$LN118@string_gra:

; 339  :       /* main integral over edge */
; 340  :       for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 341  :         for ( j = 0 ; j < EDGE_CTRL ; j++ )
; 342  :         { REAL v = scoeff[j][i];

	fld	QWORD PTR _scoeff+16

; 343  :           if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN181@string_gra

; 344  :           g[i][0] += v*u[j][1];

	mov	ecx, DWORD PTR [edi]
	fld	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR [esi+8]

; 345  :           g[j][1] += v*u[i][0];

	mov	edx, DWORD PTR [edi+8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	jmp	SHORT $LN123@string_gra
$LN181@string_gra:
	fstp	ST(0)
$LN123@string_gra:

; 339  :       /* main integral over edge */
; 340  :       for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 341  :         for ( j = 0 ; j < EDGE_CTRL ; j++ )
; 342  :         { REAL v = scoeff[j][i];

	fld	QWORD PTR _scoeff+40

; 343  :           if ( v == 0.0 ) continue;

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN184@string_gra

; 344  :           g[i][0] += v*u[j][1];

	mov	ecx, DWORD PTR [edi+4]
	fld	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR [esi+8]

; 345  :           g[j][1] += v*u[i][0];

	mov	edx, DWORD PTR [edi+8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR [esi+4]
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	jmp	SHORT $LN125@string_gra
$LN184@string_gra:
	fstp	ST(0)
$LN125@string_gra:

; 339  :       /* main integral over edge */
; 340  :       for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 341  :         for ( j = 0 ; j < EDGE_CTRL ; j++ )
; 342  :         { REAL v = scoeff[j][i];

	fld	QWORD PTR _scoeff+64

; 343  :           if ( v == 0.0 ) continue;

	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	SHORT $LN187@string_gra

; 344  :           g[i][0] += v*u[j][1];

	mov	edi, DWORD PTR [edi+8]
	fld	QWORD PTR [edi+8]
	mov	eax, DWORD PTR [esi+8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 345  :           g[j][1] += v*u[i][0];

	fmul	QWORD PTR [edi]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	jmp	SHORT $LN127@string_gra
$LN187@string_gra:
	fstp	ST(0)
$LN127@string_gra:

; 346  :         }
; 347  : 
; 348  :       /* wrap correction */
; 349  :       wrap = (get_edge_wrap(e_id)>>TWRAPBITS) & WRAPMASK;

	mov	ecx, DWORD PTR _e_id$89289[ebp]
	mov	edx, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+edi+784]
	mov	eax, DWORD PTR [eax+edx]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN69@string_gra
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN69@string_gra:
	sar	eax, 6
	and	eax, 31					; 0000001fH

; 350  :       wrapnum = WRAPNUM(wrap);

	cmp	eax, 16					; 00000010H
	jle	SHORT $LN45@string_gra
	add	eax, -32				; ffffffe0H
$LN45@string_gra:
	mov	DWORD PTR _wrapnum$[ebp], eax

; 351  :       g[2][0] += wrapnum;

	fild	DWORD PTR _wrapnum$[ebp]
	mov	eax, DWORD PTR [esi+8]

; 352  : 
; 353  :       for ( k = 0 ; k < EDGE_CTRL ; k++ )

	xor	edi, edi
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
$LL21@string_gra:

; 354  :        for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN20@string_gra

; 352  : 
; 353  :       for ( k = 0 ; k < EDGE_CTRL ; k++ )

	mov	eax, DWORD PTR [esi+edi*4]
	npad	3
$LL18@string_gra:

; 355  :         g[k][j] *= web.torusv;

	fld	QWORD PTR [eax]
	inc	ecx
	fmul	QWORD PTR _web+1600
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jl	SHORT $LL18@string_gra
$LN20@string_gra:

; 352  : 
; 353  :       for ( k = 0 ; k < EDGE_CTRL ; k++ )

	inc	edi
	cmp	edi, 3
	jl	SHORT $LL21@string_gra

; 356  :       mat_mult(g,web.inverse_periods,grad,EDGE_CTRL,SDIM,SDIM);

	mov	ebx, DWORD PTR _grad$[ebp]
	mov	eax, DWORD PTR _web+1612
	push	edx
	push	edx
	push	3
	push	ebx
	push	eax
	push	esi
	call	_mat_mult
	add	esp, 24					; 00000018H

; 357  :     }
; 358  :     else

	jmp	$LN151@string_gra
$LN29@string_gra:

; 359  :     { for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 360  :       { grad[i][0] = grad[i][1] = 0.0;

	mov	ebx, DWORD PTR _grad$[ebp]
	fldz
	mov	eax, DWORD PTR [ebx]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax]

; 361  :         for ( k = 0 ; k < EDGE_CTRL ; k++ )
; 362  :         { grad[i][0] +=  scoeff[k][i]*x[k][1];

	mov	ecx, DWORD PTR _x$[ebp]
	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR _scoeff
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 363  :           grad[i][1] +=  scoeff[i][k]*x[k][0];

	mov	edx, DWORD PTR _x$[ebp]
	fld	QWORD PTR _scoeff
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	mov	ecx, DWORD PTR _x$[ebp+4]
	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR _scoeff+24
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _x$[ebp+4]
	fld	QWORD PTR _scoeff+8
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	mov	ecx, DWORD PTR _x$[ebp+8]
	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR _scoeff+48
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _x$[ebp+8]
	fld	QWORD PTR [edx]
	fmul	QWORD PTR _scoeff+16
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	mov	eax, DWORD PTR [ebx+4]
	fst	QWORD PTR [eax+8]
	fst	QWORD PTR [eax]
	mov	ecx, DWORD PTR _x$[ebp]
	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR _scoeff+8
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _x$[ebp]
	fld	QWORD PTR _scoeff+24
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	mov	ecx, DWORD PTR _x$[ebp+4]
	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR _scoeff+32
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _x$[ebp+4]
	fld	QWORD PTR _scoeff+32
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	mov	ecx, DWORD PTR _x$[ebp+8]
	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR _scoeff+56
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _x$[ebp+8]
	fld	QWORD PTR [edx]
	fmul	QWORD PTR _scoeff+40
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	mov	eax, DWORD PTR [ebx+8]
	fst	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR _x$[ebp]
	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR _scoeff+16
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _x$[ebp]
	fld	QWORD PTR _scoeff+48
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]

; 361  :         for ( k = 0 ; k < EDGE_CTRL ; k++ )
; 362  :         { grad[i][0] +=  scoeff[k][i]*x[k][1];

	mov	ecx, DWORD PTR _x$[ebp+4]
	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR _scoeff+40
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 363  :           grad[i][1] +=  scoeff[i][k]*x[k][0];

	mov	edx, DWORD PTR _x$[ebp+4]
	fld	QWORD PTR _scoeff+56
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	mov	ecx, DWORD PTR _x$[ebp+8]
	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR _scoeff+64
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _x$[ebp+8]
	fld	QWORD PTR [edx]
	fmul	QWORD PTR _scoeff+64
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
$LN151@string_gra:

; 364  :         }
; 365  :       }
; 366  :     }
; 367  : 
; 368  :     if ( valid_id(bi_id) && (get_battr(bi_id) & (FIXEDVOL|PRESSURE)) )

	cmp	DWORD PTR tv3176[ebp], 0
	je	$LN154@string_gra
	mov	edi, DWORD PTR _bi_id$[ebp]
	mov	eax, DWORD PTR _web+348
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2080				; 00000820H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN154@string_gra

; 369  :     { for ( i = 0 ; i < EDGE_CTRL ; i++ )

	lea	eax, DWORD PTR _v$[ebp]
	sub	eax, ebx
	mov	esi, ebx
	mov	DWORD PTR tv4678[ebp], eax
	mov	DWORD PTR tv633[ebp], 3
	jmp	SHORT $LN7@string_gra
	npad	8
$LL153@string_gra:
	mov	eax, DWORD PTR tv4678[ebp]
$LN7@string_gra:

; 370  :       { vgptr = get_bv_new_vgrad(get_body_fixnum(bi_id),v[i]);

	mov	ecx, DWORD PTR [eax+esi]
	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [edi+edx]
	push	ecx
	mov	ecx, DWORD PTR [eax+420]
	push	ecx
	call	_get_bv_new_vgrad

; 371  :         vgptr->bb_id = bi_id;

	mov	edx, DWORD PTR _bi_id$[ebp]
	mov	DWORD PTR [eax+8], edx

; 372  :         vgptr->grad[0] +=  grad[i][0];

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	fld	QWORD PTR [ecx]
	fadd	QWORD PTR [edx]
	add	esp, 8
	add	esi, 4
	dec	DWORD PTR tv633[ebp]
	fstp	QWORD PTR [edx]

; 373  :         vgptr->grad[1] +=  grad[i][1];        

	mov	eax, DWORD PTR [eax+16]
	fld	QWORD PTR [ecx+8]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	jne	SHORT $LL153@string_gra
$LN154@string_gra:

; 374  :       }
; 375  :     }
; 376  : 
; 377  :     if ( valid_id(bj_id) && !equal_id(bj_id,bi_id) && 
; 378  :                           (get_battr(bj_id) & (FIXEDVOL|PRESSURE)) )

	mov	edi, DWORD PTR _bj_id$[ebp]
	test	edi, 268435456				; 10000000H
	je	$LN156@string_gra
	cmp	edi, DWORD PTR _bi_id$[ebp]
	je	$LN156@string_gra
	mov	eax, DWORD PTR _web+348
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2080				; 00000820H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN156@string_gra

; 379  :     { for ( i = 0 ; i < EDGE_CTRL ; i++ )

	lea	eax, DWORD PTR _v$[ebp]
	sub	eax, ebx
	mov	esi, ebx
	mov	DWORD PTR tv4678[ebp], eax
	lea	ebx, DWORD PTR [ecx+3]
	jmp	SHORT $LN3@string_gra
	npad	3
$LL155@string_gra:
	mov	eax, DWORD PTR tv4678[ebp]
$LN3@string_gra:

; 380  :       { 
; 381  :         vgptr = get_bv_new_vgrad(get_body_fixnum(bj_id),v[i]);

	mov	ecx, DWORD PTR [esi+eax]
	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [edi+edx]
	push	ecx
	mov	ecx, DWORD PTR [eax+420]
	push	ecx
	call	_get_bv_new_vgrad

; 382  :         vgptr->bb_id = bj_id;
; 383  :         vgptr->grad[0] -=  grad[i][0];

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _bj_id$[ebp]
	mov	DWORD PTR [eax+8], edx
	fld	QWORD PTR [ecx]
	mov	edx, DWORD PTR [esi]
	fsub	QWORD PTR [edx]
	add	esp, 8
	add	esi, 4
	dec	ebx
	fstp	QWORD PTR [ecx]

; 384  :         vgptr->grad[1] -=  grad[i][1];

	mov	eax, DWORD PTR [eax+16]
	fld	QWORD PTR [eax+8]
	fsub	QWORD PTR [edx+8]
	fstp	QWORD PTR [eax+8]
	jne	SHORT $LL155@string_gra
$LN156@string_gra:

; 379  :     { for ( i = 0 ; i < EDGE_CTRL ; i++ )

	mov	esi, DWORD PTR _fe_id$[ebp]
	mov	ebx, DWORD PTR _web+460
$LN41@string_gra:

; 310  :   int wrap,wrapnum;
; 311  :   
; 312  : 
; 313  :   FOR_ALL_FACETEDGES(fe_id)

	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+esi*4]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _fe_id$[ebp], esi
	test	esi, 268435456				; 10000000H
	jne	$LL42@string_gra
	pop	edi
	pop	ebx
$LN40@string_gra:

; 385  :       }
; 386  :     }
; 387  :   }
; 388  : } // end string_grad_q()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_string_grad_q ENDP
_TEXT	ENDS
END
