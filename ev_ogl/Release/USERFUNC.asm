; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\USERFUNC.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_usr1_seconds
PUBLIC	_usr1_deriv
PUBLIC	_usr1
PUBLIC	_userfunc
PUBLIC	_userfunc_deriv
PUBLIC	_userfunc_seconds
_DATA	SEGMENT
_userfunc DD	FLAT:_usr1
	DD	FLAT:_usr_poly
_userfunc_deriv DD FLAT:_usr1_deriv
	DD	FLAT:_usr_poly_grad
_userfunc_seconds DD FLAT:_usr1_seconds
	DD	FLAT:_usr_poly_hess
_DATA	ENDS
PUBLIC	_userfunc_init
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\userfunc.c
;	COMDAT _userfunc_init
_TEXT	SEGMENT
_userfunc_init PROC					; COMDAT

; 41   :   /* do whatever it takes to initialize user functions */
; 42   :   
; 43   :   /*  Example of error reporting. 
; 44   :   kb_error(2201,"Error in userfunc_init\n",RECOVERABLE);
; 45   :   */
; 46   : } // end userfunc_init()

	ret	0
_userfunc_init ENDP
_TEXT	ENDS
PUBLIC	__real@4030000000000000
PUBLIC	__real@4010000000000000
EXTRN	__fltused:DWORD
;	COMDAT __real@4030000000000000
CONST	SEGMENT
__real@4030000000000000 DQ 04030000000000000r	; 16
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _usr1
_TEXT	SEGMENT
_x$ = 8							; size = 4
_usr1	PROC						; COMDAT

; 59   : { REAL denom;

	push	ebp
	mov	ebp, esp

; 60   :   
; 61   :   denom = 4+x[0]*x[0]+x[1]*x[1]+x[2]*x[2]; 

	mov	eax, DWORD PTR _x$[ebp]
	fld	QWORD PTR [eax+8]
	fld	QWORD PTR [eax]
	fld	QWORD PTR [eax+16]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR __real@4010000000000000
	fld	ST(2)
	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)

; 62   :   return 16/denom/denom;

	fld	QWORD PTR __real@4030000000000000
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)

; 63   : } // end usr1()

	pop	ebp
	ret	0
_usr1	ENDP
_TEXT	ENDS
PUBLIC	__real@c050000000000000
EXTRN	_web:BYTE
;	COMDAT __real@c050000000000000
CONST	SEGMENT
__real@c050000000000000 DQ 0c050000000000000r	; -64
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _usr1_deriv
_TEXT	SEGMENT
_x$ = 8							; size = 4
_partials$ = 12						; size = 4
_usr1_deriv PROC					; COMDAT

; 75   : { REAL denom,cube;

	push	ebp
	mov	ebp, esp

; 76   :   int i;
; 77   : 
; 78   :   denom = 4+x[0]*x[0]+x[1]*x[1]+x[2]*x[2]; 

	mov	edx, DWORD PTR _x$[ebp]
	fld	QWORD PTR [edx+8]

; 79   :   cube = denom*denom*denom;
; 80   :   for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	fld	QWORD PTR [edx]
	fld	QWORD PTR [edx+16]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR __real@4010000000000000
	fld	ST(2)
	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fld	ST(0)
	fmul	ST(0), ST(1)
	fmul	ST(0), ST(1)
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN12@usr1_deriv
	mov	eax, DWORD PTR _partials$[ebp]
	fdivr	QWORD PTR __real@c050000000000000
	sub	edx, eax
$LN3@usr1_deriv:

; 81   :      partials[i] = -64/cube*x[i]; 

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN3@usr1_deriv
$LN12@usr1_deriv:

; 79   :   cube = denom*denom*denom;
; 80   :   for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)

; 82   : 
; 83   :   return 16/denom/denom;

	fld	QWORD PTR __real@4030000000000000
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)

; 84   : } // end usr1_deriv()

	pop	ebp
	ret	0
_usr1_deriv ENDP
_TEXT	ENDS
PUBLIC	__real@4078000000000000
PUBLIC	__real@4050000000000000
;	COMDAT __real@4078000000000000
CONST	SEGMENT
__real@4078000000000000 DQ 04078000000000000r	; 384
CONST	ENDS
;	COMDAT __real@4050000000000000
CONST	SEGMENT
__real@4050000000000000 DQ 04050000000000000r	; 64
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _usr1_seconds
_TEXT	SEGMENT
_x$ = 8							; size = 4
_partials$ = 12						; size = 4
_seconds$ = 16						; size = 4
_usr1_seconds PROC					; COMDAT

; 97   : { REAL denom,cube,quart;

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 98   :   int i,j;
; 99   : 
; 100  :   denom = 4+x[0]*x[0]+x[1]*x[1]+x[2]*x[2]; 

	mov	edi, DWORD PTR _x$[ebp]
	fld	QWORD PTR [edi+8]

; 101  :   cube = denom*denom*denom;
; 102  :   quart = cube*denom;
; 103  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _web+616
	fld	QWORD PTR [edi]
	xor	ecx, ecx
	fld	QWORD PTR [edi+16]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR __real@4010000000000000
	fld	ST(2)
	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fld	ST(0)
	fmul	ST(0), ST(1)
	fmul	ST(0), ST(1)
	fld	ST(0)
	fmul	ST(0), ST(2)
	test	esi, esi
	jle	SHORT $LN7@usr1_secon
	fld	QWORD PTR __real@c050000000000000
	mov	eax, DWORD PTR _partials$[ebp]
	mov	edx, edi
	fdiv	ST(0), ST(2)
	sub	edx, eax
$LN9@usr1_secon:

; 104  :      partials[i] = -64/cube*x[i]; 

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	esi, DWORD PTR _web+616
	cmp	ecx, esi
	jl	SHORT $LN9@usr1_secon

; 101  :   cube = denom*denom*denom;
; 102  :   quart = cube*denom;
; 103  :   for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN7@usr1_secon:

; 105  :   for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN24@usr1_secon
	fld	QWORD PTR __real@4050000000000000
	push	ebx
	mov	ebx, DWORD PTR _seconds$[ebp]
	fdivrp	ST(2), ST(0)
	fld	QWORD PTR __real@4078000000000000
$LN6@usr1_secon:

; 106  :   { for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN1@usr1_secon
	mov	eax, DWORD PTR [ebx+ecx*4]
	mov	esi, edi
	sub	esi, eax
$LN3@usr1_secon:

; 107  :         seconds[i][j] = 384*x[i]*x[j]/quart;

	fld	QWORD PTR [edi+ecx*8]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fmul	QWORD PTR [esi+eax-8]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LN3@usr1_secon
$LN1@usr1_secon:

; 105  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR [ebx+ecx*4]

; 108  :      seconds[i][i] -= 64/cube;

	fld	QWORD PTR [eax+ecx*8]
	lea	eax, DWORD PTR [eax+ecx*8]
	fsub	ST(0), ST(3)
	inc	ecx
	fstp	QWORD PTR [eax]
	mov	esi, DWORD PTR _web+616
	cmp	ecx, esi
	jl	SHORT $LN6@usr1_secon

; 105  :   for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
	pop	ebx
	fstp	ST(0)
	pop	edi
	fstp	ST(0)
	pop	esi

; 109  :   }
; 110  : 
; 111  :   return 16/denom/denom;

	fld	QWORD PTR __real@4030000000000000
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)

; 112  : } // end usr1_seconds()

	pop	ebp
	ret	0
$LN24@usr1_secon:

; 105  :   for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(1)
	pop	edi
	fstp	ST(0)
	pop	esi

; 109  :   }
; 110  : 
; 111  :   return 16/denom/denom;

	fld	QWORD PTR __real@4030000000000000
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)

; 112  : } // end usr1_seconds()

	pop	ebp
	ret	0
_usr1_seconds ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _usr_poly
_TEXT	SEGMENT
_x$ = 8							; size = 4
_usr_poly PROC						; COMDAT

; 120  : { 

	push	ebp
	mov	ebp, esp

; 121  :     return x[0]*x[0] + x[1]*x[2] + x[2]*x[2]*x[2];

	mov	eax, DWORD PTR _x$[ebp]
	fld	QWORD PTR [eax]
	fld	QWORD PTR [eax+16]
	fld	QWORD PTR [eax+8]
	fmul	QWORD PTR [eax+16]
	fld	ST(2)
	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	fmul	QWORD PTR [eax+16]
	faddp	ST(1), ST(0)

; 122  : }

	pop	ebp
	ret	0
_usr_poly ENDP
_TEXT	ENDS
PUBLIC	__real@4008000000000000
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _usr_poly_grad
_TEXT	SEGMENT
_x$ = 8							; size = 4
_partials$ = 12						; size = 4
_usr_poly_grad PROC					; COMDAT

; 128  : {

	push	ebp
	mov	ebp, esp

; 129  :   partials[0] = 2*x[0];

	mov	eax, DWORD PTR _x$[ebp]
	fld	QWORD PTR [eax]
	mov	ecx, DWORD PTR _partials$[ebp]
	fadd	ST(0), ST(0)
	fstp	QWORD PTR [ecx]

; 130  :   partials[1] = x[2];

	fld	QWORD PTR [eax+16]
	fstp	QWORD PTR [ecx+8]

; 131  :   partials[2] = x[1] + 3*x[2]*x[2];

	fld	QWORD PTR [eax+16]
	fmul	QWORD PTR __real@4008000000000000
	fmul	QWORD PTR [eax+16]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [ecx+16]

; 132  : 
; 133  :   return x[0]*x[0] + x[1]*x[2] + x[2]*x[2]*x[2];

	fld	QWORD PTR [eax]
	fld	QWORD PTR [eax+16]
	fld	QWORD PTR [eax+8]
	fmul	QWORD PTR [eax+16]
	fld	ST(2)
	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	fmul	QWORD PTR [eax+16]
	faddp	ST(1), ST(0)

; 134  : }

	pop	ebp
	ret	0
_usr_poly_grad ENDP
_TEXT	ENDS
PUBLIC	__real@4018000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@4000000000000000
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _usr_poly_hess
_TEXT	SEGMENT
_x$ = 8							; size = 4
_partials$ = 12						; size = 4
_seconds$ = 16						; size = 4
_usr_poly_hess PROC					; COMDAT

; 141  : { 

	push	ebp
	mov	ebp, esp

; 142  :   partials[0] = 2*x[0];

	mov	eax, DWORD PTR _x$[ebp]
	fld	QWORD PTR [eax]
	mov	ecx, DWORD PTR _partials$[ebp]
	fld	QWORD PTR __real@4000000000000000
	push	esi
	fmul	ST(1), ST(0)

; 143  :   partials[1] = x[2];
; 144  :   partials[2] = x[1] + 3*x[2]*x[2];
; 145  : 
; 146  :   seconds[0][0] = 2.0;

	mov	esi, DWORD PTR _seconds$[ebp]

; 147  :   seconds[0][1] = seconds[1][0] = 0.0;

	mov	edx, DWORD PTR [esi+4]
	fxch	ST(1)
	fstp	QWORD PTR [ecx]
	fld	QWORD PTR [eax+16]
	fstp	QWORD PTR [ecx+8]
	fld	QWORD PTR [eax+16]
	fmul	QWORD PTR __real@4008000000000000
	fmul	QWORD PTR [eax+16]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [esi]

; 148  :   seconds[0][2] = seconds[2][0] = 0.0;

	mov	esi, DWORD PTR [esi+8]
	fstp	QWORD PTR [ecx]
	fldz
	fst	QWORD PTR [edx]
	fst	QWORD PTR [ecx+8]
	fst	QWORD PTR [esi]
	fst	QWORD PTR [ecx+16]

; 149  :   seconds[1][1] = 0.0;

	fstp	QWORD PTR [edx+8]

; 150  :   seconds[1][2] = seconds[2][1] = 1.0;

	fld1
	fst	QWORD PTR [esi+8]
	fstp	QWORD PTR [edx+16]

; 151  :   seconds[2][2] = 6*x[2];

	fld	QWORD PTR [eax+16]
	fmul	QWORD PTR __real@4018000000000000
	fstp	QWORD PTR [esi+16]
	pop	esi

; 152  : 
; 153  :   return x[0]*x[0] + x[1]*x[2] + x[2]*x[2]*x[2];

	fld	QWORD PTR [eax]
	fld	QWORD PTR [eax+16]
	fld	QWORD PTR [eax+8]
	fmul	QWORD PTR [eax+16]
	fld	ST(2)
	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	fmul	QWORD PTR [eax+16]
	faddp	ST(1), ST(0)

; 154  : }

	pop	ebp
	ret	0
_usr_poly_hess ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@EPMBGIBI@This?5Evolver?5not?5compiled?5for?5dy@ ; `string'
PUBLIC	_load_library
EXTRN	_kb_error:PROC
;	COMDAT ??_C@_0DH@EPMBGIBI@This?5Evolver?5not?5compiled?5for?5dy@
CONST	SEGMENT
??_C@_0DH@EPMBGIBI@This?5Evolver?5not?5compiled?5for?5dy@ DB 'This Evolve'
	DB	'r not compiled for dynamic load libraries.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _load_library
_TEXT	SEGMENT
_libname$ = 8						; size = 4
_load_library PROC					; COMDAT

; 189  : #ifdef ENABLE_DLL
; 190  :   int k;
; 191  :   char *env;
; 192  :   char path[200];
; 193  :   int len;
; 194  :   void *fd;
; 195  : 
; 196  :   for ( k = 0 ; k < MAX_DLL ; k++ )
; 197  :      if ( dll_list[k].name == NULL ) break;
; 198  : 
; 199  :   if ( k >= MAX_DLL )
; 200  :      kb_error(2202,"Too many dynamic load libraries.\n",DATAFILE_ERROR);
; 201  : 
; 202  : 
; 203  :   env = getenv("EVOLVERPATH");
; 204  : 
; 205  :   /* try current directory first */
; 206  :   strcpy(path,"./");
; 207  :   strncpy(path+2,libname,sizeof(path)-2);
; 208  :   while ( (fd = dlopen(path,RTLD_NOW)) == NULL)
; 209  :      { /* try paths in EVOLVERPATH */
; 210  :         if ( env == NULL ) break;
; 211  :         len = (int)strcspn(env,ENVPATHCHAR);
; 212  :         if ( len == 0 ) break;
; 213  :         strncpy(path,env,len);
; 214  :         path[len] = PATHCHAR;
; 215  :         strncpy(path+len+1,libname,sizeof(path)-len-2);
; 216  :         if ( env[len] == 0 ) env = NULL; /* end of EVOLVERPATH */
; 217  :         else env += len+1;
; 218  :      } 
; 219  :   /* try given name */
; 220  :   if ( ! fd )
; 221  :   { strncpy(path,libname,sizeof(path));
; 222  :     fd = dlopen(path,RTLD_NOW);
; 223  :   }
; 224  :   
; 225  :   if ( ! fd )
; 226  :   { sprintf(errmsg,"Cannot open dynamic library %s. Reason:\n",libname);
; 227  : #ifndef WIN32
; 228  :     strncpy(errmsg+strlen(errmsg),dlerror(),sizeof(errmsg)-strlen(errmsg)-2);
; 229  : #endif   
; 230  :     kb_error(2203,errmsg,DATAFILE_ERROR);
; 231  :   }
; 232  : 
; 233  :   dll_list[k].name = mycalloc(1,strlen(libname)+4);
; 234  :   strcpy(dll_list[k].name,libname);
; 235  : 
; 236  :   dll_list[k].handle = fd;
; 237  : 
; 238  : #else
; 239  : 
; 240  :   kb_error(2204,"This Evolver not compiled for dynamic load libraries.\n",
; 241  :      DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DH@EPMBGIBI@This?5Evolver?5not?5compiled?5for?5dy@
	push	2204					; 0000089cH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 242  : #endif
; 243  : 
; 244  : }

	ret	0
_load_library ENDP
_TEXT	ENDS
PUBLIC	_unload_libraries
EXTRN	_myfree:PROC
EXTRN	_dll_list:BYTE
; Function compile flags: /Ogtp
;	COMDAT _unload_libraries
_TEXT	SEGMENT
_unload_libraries PROC					; COMDAT

; 254  : {

	push	esi

; 255  :   int k;
; 256  : 
; 257  :   for ( k = 0 ; k < MAX_DLL ; k++ )

	mov	esi, OFFSET _dll_list
$LL4@unload_lib:

; 258  :      if ( dll_list[k].name )

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@unload_lib

; 259  :      { myfree(dll_list[k].name);

	push	eax
	call	_myfree
	add	esp, 4

; 260  :        dll_list[k].name = NULL;

	mov	DWORD PTR [esi], 0
$LN3@unload_lib:

; 255  :   int k;
; 256  : 
; 257  :   for ( k = 0 ; k < MAX_DLL ; k++ )

	add	esi, 8
	cmp	esi, OFFSET _dll_list+40
	jl	SHORT $LL4@unload_lib
	pop	esi

; 261  : #ifdef ENABLE_DLL
; 262  :        dlclose(dll_list[k].handle); 
; 263  :        dll_list[k].handle = NULL;
; 264  : #endif
; 265  :      }
; 266  : }

	ret	0
_unload_libraries ENDP
_TEXT	ENDS
PUBLIC	_search_libraries
; Function compile flags: /Ogtp
;	COMDAT _search_libraries
_TEXT	SEGMENT
_funcname$ = 8						; size = 4
_search_libraries PROC					; COMDAT

; 279  : 
; 280  : #ifdef ENABLE_DLL
; 281  :   int i;
; 282  :   dll_func_type f;
; 283  : 
; 284  :   for ( i = 0 ; i < MAX_DLL ; i++ )
; 285  :     if ( dll_list[i].handle ) 
; 286  :      { f = (dll_func_type)dlsym(dll_list[i].handle,funcname);
; 287  :         if ( f ) return f;
; 288  :      }
; 289  : #endif
; 290  :   return NULL;

	xor	eax, eax

; 291  : }

	ret	0
_search_libraries ENDP
_TEXT	ENDS
PUBLIC	__real@3fb0000000000000
PUBLIC	__real@405a000000000000
PUBLIC	__real@406a000000000000
PUBLIC	__real@4014000000000000
PUBLIC	__real@4046000000000000
PUBLIC	__real@4038000000000000
PUBLIC	__real@402c000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@3fd0000000000000
PUBLIC	_RF
EXTRN	_root8machine_eps:QWORD
EXTRN	__CIsqrt:PROC
;	COMDAT __real@3fb0000000000000
CONST	SEGMENT
__real@3fb0000000000000 DQ 03fb0000000000000r	; 0.0625
CONST	ENDS
;	COMDAT __real@405a000000000000
CONST	SEGMENT
__real@405a000000000000 DQ 0405a000000000000r	; 104
CONST	ENDS
;	COMDAT __real@406a000000000000
CONST	SEGMENT
__real@406a000000000000 DQ 0406a000000000000r	; 208
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@4046000000000000
CONST	SEGMENT
__real@4046000000000000 DQ 04046000000000000r	; 44
CONST	ENDS
;	COMDAT __real@4038000000000000
CONST	SEGMENT
__real@4038000000000000 DQ 04038000000000000r	; 24
CONST	ENDS
;	COMDAT __real@402c000000000000
CONST	SEGMENT
__real@402c000000000000 DQ 0402c000000000000r	; 14
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _RF
_TEXT	SEGMENT
tv232 = -8						; size = 8
tv230 = -8						; size = 8
_x$ = 8							; size = 8
_y$ = 16						; size = 8
tv234 = 24						; size = 8
_z$ = 24						; size = 8
_RF	PROC						; COMDAT

; 303  : {

	push	ebp
	mov	ebp, esp

; 304  :   REAL lambda;
; 305  :   if ( fabs(x-y) + fabs(y-z) < root8machine_eps)

	fld	QWORD PTR _x$[ebp]
	sub	esp, 8
	fld	ST(0)
	fld	QWORD PTR _y$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fabs
	fld	ST(1)
	fld	QWORD PTR _z$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fabs
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fcomp	QWORD PTR _root8machine_eps
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN7@RF
	fstp	ST(0)
	jmp	SHORT $LN4@RF
$LN12@RF:
	fstp	ST(1)
	fxch	ST(1)
$LN4@RF:

; 316  :   }
; 317  : 
; 318  :   lambda = sqrt(x*y) + sqrt(y*z) + sqrt(z*x);

	fmulp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR tv230[ebp]
	fld	QWORD PTR _y$[ebp]
	fmul	QWORD PTR _z$[ebp]
	call	__CIsqrt
	fadd	QWORD PTR tv230[ebp]
	fstp	QWORD PTR tv232[ebp]
	fld	QWORD PTR _x$[ebp]
	fmul	QWORD PTR _z$[ebp]
	call	__CIsqrt
	fadd	QWORD PTR tv232[ebp]

; 319  :   return RF((x+lambda)/4,(y+lambda)/4,(z+lambda)/4);

	fld	QWORD PTR _z$[ebp]
	fadd	ST(0), ST(1)
	fld	QWORD PTR __real@3fd0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _z$[ebp]
	fld	ST(2)
	fadd	QWORD PTR _y$[ebp]
	fmul	ST(0), ST(2)
	fst	QWORD PTR _y$[ebp]
	fxch	ST(3)
	fadd	QWORD PTR _x$[ebp]
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _x$[ebp]
	fld	ST(0)
	fsub	ST(0), ST(3)
	fabs
	fld	ST(3)
	fsub	ST(0), ST(3)
	fabs
	faddp	ST(1), ST(0)
	fcomp	QWORD PTR _root8machine_eps
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN12@RF

; 304  :   REAL lambda;
; 305  :   if ( fabs(x-y) + fabs(y-z) < root8machine_eps)

	fxch	ST(2)
	fxch	ST(1)
$LN7@RF:

; 306  :   { // 7th order polynomial, so 0.01 radius should give 1e-16 accuracy
; 307  :     REAL a,z1,z2,z3,ee2,ee3;
; 308  :     a = (x+y+z)/3;

	fld	ST(2)
	fadd	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fld	QWORD PTR __real@4008000000000000
	fdiv	ST(1), ST(0)

; 309  :     z1 = (a-x)/a;

	fld	ST(1)
	fsubrp	ST(5), ST(0)
	fxch	ST(4)
	fdiv	ST(0), ST(1)

; 310  :     z2 = (a-y)/a;

	fld	ST(1)
	fsubrp	ST(4), ST(0)
	fxch	ST(3)
	fdiv	ST(0), ST(1)

; 311  :     z3 = (a-z)/a;

	fld	ST(1)
	fsubrp	ST(3), ST(0)
	fxch	ST(2)
	fdiv	ST(0), ST(1)

; 312  :     ee2 = z1*z2 + z2*z3 + z3*z1;

	fld	ST(2)
	fmul	ST(0), ST(4)
	fld	ST(1)
	fmulp	ST(4), ST(0)
	fadd	ST(3), ST(0)
	fld	ST(1)
	fmulp	ST(5), ST(0)
	fxch	ST(3)
	faddp	ST(4), ST(0)

; 313  :     ee3 = z1*z2*z3;

	fmulp	ST(2), ST(0)

; 314  :     return (1 - ee2/10 + ee3/14 + ee2*ee2/24 - 3*ee2*ee3/44
; 315  :             - 5*ee2*ee2*ee2/208 + 3*ee3*ee3/104 + ee2*ee2*ee3/16)/sqrt(a);

	fld	ST(2)
	fmul	ST(0), ST(3)
	fld	ST(3)
	fdiv	QWORD PTR __real@4024000000000000
	fld1
	fsubrp	ST(1), ST(0)
	fld	ST(3)
	fdiv	QWORD PTR __real@402c000000000000
	faddp	ST(1), ST(0)
	fld	ST(1)
	fdiv	QWORD PTR __real@4038000000000000
	faddp	ST(1), ST(0)
	fld	ST(4)
	fmul	ST(0), ST(6)
	fmul	ST(0), ST(4)
	fdiv	QWORD PTR __real@4046000000000000
	fsubp	ST(1), ST(0)
	fld	ST(4)
	fmul	QWORD PTR __real@4014000000000000
	fmul	ST(0), ST(5)
	fmulp	ST(5), ST(0)
	fxch	ST(4)
	fdiv	QWORD PTR __real@406a000000000000
	fsubp	ST(4), ST(0)
	fld	ST(2)
	fmulp	ST(5), ST(0)
	fxch	ST(4)
	fmul	ST(0), ST(2)
	fdiv	QWORD PTR __real@405a000000000000
	faddp	ST(3), ST(0)
	fxch	ST(3)
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fb0000000000000
	faddp	ST(1), ST(0)
	fstp	QWORD PTR tv234[ebp]
	call	__CIsqrt
	fdivr	QWORD PTR tv234[ebp]

; 320  : 
; 321  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RF	ENDP
_TEXT	ENDS
PUBLIC	_RC
; Function compile flags: /Ogtp
;	COMDAT _RC
_TEXT	SEGMENT
_x$ = 8							; size = 8
_y$ = 16						; size = 8
_RC	PROC						; COMDAT

; 325  : {

	push	ebp
	mov	ebp, esp

; 326  :   return RF(x,y,y);

	fld	QWORD PTR _y$[ebp]
	sub	esp, 24					; 00000018H
	fst	QWORD PTR [esp+16]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _x$[ebp]
	fstp	QWORD PTR [esp]
	call	_RF
	add	esp, 24					; 00000018H

; 327  : }

	pop	ebp
	ret	0
_RC	ENDP
_TEXT	ENDS
PUBLIC	_RJ
EXTRN	_machine_eps:QWORD
; Function compile flags: /Ogtp
;	COMDAT _RJ
_TEXT	SEGMENT
tv280 = -24						; size = 8
tv278 = -24						; size = 8
tv276 = -24						; size = 8
_alpha$ = -24						; size = 8
tv286 = -16						; size = 8
tv284 = -16						; size = 8
tv282 = -16						; size = 8
_lambda$ = -16						; size = 8
tv202 = -8						; size = 8
_x$ = 8							; size = 8
_y$ = 16						; size = 8
tv274 = 24						; size = 8
_z$ = 24						; size = 8
tv228 = 32						; size = 8
_beta$ = 32						; size = 8
_p$ = 32						; size = 8
_RJ	PROC						; COMDAT

; 331  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 332  :   REAL lambda,alpha,beta;
; 333  : 
; 334  :   if ( fabs(x-y) + fabs(y-z) + fabs(z-p) < sqrt(machine_eps) )

	fld	QWORD PTR _x$[ebp]
	fld	QWORD PTR _y$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fabs
	fld	QWORD PTR _z$[ebp]
	fsub	ST(2), ST(0)
	fxch	ST(2)
	fabs
	faddp	ST(1), ST(0)
	fxch	ST(1)
	fsub	QWORD PTR _p$[ebp]
	fabs
	faddp	ST(1), ST(0)
	fstp	QWORD PTR tv286[ebp]
	fld	QWORD PTR _machine_eps
	call	__CIsqrt
	fcomp	QWORD PTR tv286[ebp]
	fnstsw	ax

; 335  :   { REAL term = sqrt(sqrt(sqrt(x*y*z*p)));

	fld	QWORD PTR _x$[ebp]
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@RJ
	fmul	QWORD PTR _y$[ebp]
	fmul	QWORD PTR _z$[ebp]
	fmul	QWORD PTR _p$[ebp]
	call	__CIsqrt
	call	__CIsqrt
	call	__CIsqrt

; 336  :     return 1/term/term/term;

	fld1
	fdiv	ST(0), ST(1)
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)

; 344  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@RJ:

; 337  :   }
; 338  :   lambda = sqrt(x*y) + sqrt(y*z) + sqrt(z*x);

	fld	QWORD PTR _y$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv202[ebp]
	fmul	QWORD PTR _z$[ebp]
	call	__CIsqrt
	fstp	QWORD PTR tv284[ebp]
	fld	QWORD PTR tv202[ebp]
	call	__CIsqrt
	fadd	QWORD PTR tv284[ebp]
	fstp	QWORD PTR tv282[ebp]
	fld	QWORD PTR _x$[ebp]
	fmul	QWORD PTR _z$[ebp]
	call	__CIsqrt
	fadd	QWORD PTR tv282[ebp]
	fstp	QWORD PTR _lambda$[ebp]

; 339  :   alpha = p*(sqrt(x)+sqrt(y)+sqrt(z)) + sqrt(x*y*z);

	fld	QWORD PTR _x$[ebp]
	call	__CIsqrt
	fstp	QWORD PTR tv280[ebp]
	fld	QWORD PTR _y$[ebp]
	call	__CIsqrt
	fadd	QWORD PTR tv280[ebp]
	fstp	QWORD PTR tv278[ebp]
	fld	QWORD PTR _z$[ebp]
	call	__CIsqrt
	fadd	QWORD PTR tv278[ebp]
	fmul	QWORD PTR _p$[ebp]
	fstp	QWORD PTR tv276[ebp]
	fld	QWORD PTR tv202[ebp]
	fmul	QWORD PTR _z$[ebp]
	call	__CIsqrt
	fadd	QWORD PTR tv276[ebp]
	fstp	QWORD PTR _alpha$[ebp]

; 340  :   beta = sqrt(p)*(p+lambda);

	fld	QWORD PTR _lambda$[ebp]
	fld	QWORD PTR _p$[ebp]
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv228[ebp]
	call	__CIsqrt
	fld	QWORD PTR tv228[ebp]
	fmul	ST(1), ST(0)

; 341  : 
; 342  :   return 0.25*RJ((x+lambda)/4,(y+lambda)/4,(z+lambda)/4,(p+lambda)/4) 
; 343  :     + 3*RC(alpha*alpha,beta*beta);

	sub	esp, 32					; 00000020H
	fxch	ST(1)
	fstp	QWORD PTR _beta$[ebp]
	fld	QWORD PTR __real@3fd0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [esp+24]
	fld	QWORD PTR _lambda$[ebp]
	fld	QWORD PTR _z$[ebp]
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR _y$[ebp]
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [esp+8]
	fadd	QWORD PTR _x$[ebp]
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR [esp]
	call	_RJ
	fmul	QWORD PTR __real@3fd0000000000000
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv274[ebp]
	fld	QWORD PTR _beta$[ebp]
	fmul	ST(0), ST(0)
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _alpha$[ebp]
	fmul	ST(0), ST(0)
	fstp	QWORD PTR [esp]
	call	_RC
	fmul	QWORD PTR __real@4008000000000000
	add	esp, 16					; 00000010H
	fadd	QWORD PTR tv274[ebp]

; 344  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RJ	ENDP
_TEXT	ENDS
PUBLIC	__real@4051000000000000
PUBLIC	__real@4071000000000000
PUBLIC	__real@4046800000000000
PUBLIC	__real@4044000000000000
PUBLIC	__real@403a000000000000
PUBLIC	__real@404a000000000000
PUBLIC	__real@4036000000000000
PUBLIC	__real@4056000000000000
PUBLIC	__real@4022000000000000
PUBLIC	_RD
;	COMDAT __real@4051000000000000
CONST	SEGMENT
__real@4051000000000000 DQ 04051000000000000r	; 68
CONST	ENDS
;	COMDAT __real@4071000000000000
CONST	SEGMENT
__real@4071000000000000 DQ 04071000000000000r	; 272
CONST	ENDS
;	COMDAT __real@4046800000000000
CONST	SEGMENT
__real@4046800000000000 DQ 04046800000000000r	; 45
CONST	ENDS
;	COMDAT __real@4044000000000000
CONST	SEGMENT
__real@4044000000000000 DQ 04044000000000000r	; 40
CONST	ENDS
;	COMDAT __real@403a000000000000
CONST	SEGMENT
__real@403a000000000000 DQ 0403a000000000000r	; 26
CONST	ENDS
;	COMDAT __real@404a000000000000
CONST	SEGMENT
__real@404a000000000000 DQ 0404a000000000000r	; 52
CONST	ENDS
;	COMDAT __real@4036000000000000
CONST	SEGMENT
__real@4036000000000000 DQ 04036000000000000r	; 22
CONST	ENDS
;	COMDAT __real@4056000000000000
CONST	SEGMENT
__real@4056000000000000 DQ 04056000000000000r	; 88
CONST	ENDS
;	COMDAT __real@4022000000000000
CONST	SEGMENT
__real@4022000000000000 DQ 04022000000000000r	; 9
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _RD
_TEXT	SEGMENT
tv445 = -32						; size = 8
tv371 = -32						; size = 8
tv141 = -32						; size = 8
tv139 = -32						; size = 8
tv354 = -24						; size = 8
tv350 = -16						; size = 8
tv344 = -8						; size = 8
tv389 = 8						; size = 8
tv365 = 8						; size = 8
tv342 = 8						; size = 8
tv147 = 8						; size = 8
_c$ = 8							; size = 8
_x$ = 8							; size = 8
tv341 = 16						; size = 8
tv280 = 16						; size = 8
tv143 = 16						; size = 8
_y$ = 16						; size = 8
tv394 = 24						; size = 8
tv348 = 24						; size = 8
tv137 = 24						; size = 8
_z$ = 24						; size = 8
_RD	PROC						; COMDAT

; 350  : {

	push	ebp
	mov	ebp, esp

; 351  :   REAL lambda;
; 352  :   REAL c;  // scaling constant to keep size in range
; 353  :  
; 354  :   // Trial of series http://dlmf.nist.gov/19.36#i 19.36.2.
; 355  :   // Restoring symmetry by triplicating z factor
; 356  :   if ( fabs(x-y) + fabs(y-z) < root8machine_eps )

	fld	QWORD PTR _x$[ebp]
	sub	esp, 32					; 00000020H
	fld	ST(0)
	fld	QWORD PTR _y$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fabs
	fld	ST(1)
	fld	QWORD PTR _z$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fabs
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fcomp	QWORD PTR _root8machine_eps
	fnstsw	ax
	test	ah, 5
	jp	$LN5@RD

; 357  :   { // 7th order polynomial, so 0.01 radius should give 1e-16 accuracy.
; 358  :     REAL a,z1,z2,z3,z4,z5,ee2,ee3,ee4,ee5;
; 359  :     a = (x+y+z+z+z)/5;

	fld	ST(2)
	fadd	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fadd	ST(0), ST(1)
	fadd	ST(0), ST(1)
	fdiv	QWORD PTR __real@4014000000000000

; 360  :     z1 = (a-x)/a;

	fld	ST(0)
	fsubrp	ST(4), ST(0)
	fdiv	ST(3), ST(0)

; 361  :     z2 = (a-y)/a;

	fld	ST(0)
	fsubrp	ST(3), ST(0)
	fdiv	ST(2), ST(0)

; 362  :     z3 = (a-z)/a;

	fld	ST(0)
	fsubrp	ST(2), ST(0)
	fdiv	ST(1), ST(0)
	fld	ST(1)

; 363  :     z4 = (a-z)/a;

	fld	ST(2)

; 364  :     z5 = (a-z)/a;
; 365  :     ee2 = z1*z2 + z1*z3 + z1*z4 + z1*z5 + z2*z3 + z2*z4 + z2*z5 
; 366  :            + z3*z4 + z3*z5 + z4*z5;

	fld	ST(1)
	fmul	ST(0), ST(6)
	fst	QWORD PTR tv341[ebp]
	fld	ST(5)
	fmul	ST(0), ST(7)
	fstp	QWORD PTR tv342[ebp]
	fld	ST(1)
	fmul	ST(0), ST(7)
	fstp	QWORD PTR tv344[ebp]
	fld	ST(2)
	fmul	ST(0), ST(6)
	fstp	QWORD PTR tv348[ebp]
	fld	ST(1)
	fmul	ST(0), ST(6)
	fstp	QWORD PTR tv350[ebp]
	fld	ST(1)
	fmul	ST(0), ST(3)
	fstp	QWORD PTR tv354[ebp]
	fadd	QWORD PTR tv342[ebp]
	fadd	QWORD PTR tv344[ebp]
	fld	ST(4)
	fmulp	ST(7), ST(0)
	faddp	ST(6), ST(0)
	fxch	ST(5)
	fadd	QWORD PTR tv348[ebp]
	fadd	QWORD PTR tv350[ebp]
	fld	ST(3)
	fmulp	ST(5), ST(0)
	faddp	ST(4), ST(0)
	fxch	ST(3)
	fadd	QWORD PTR tv354[ebp]
	fld	ST(2)
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)

; 367  :     ee3 = z1*z2*z3 + z1*z2*z4 + z1*z2*z5 + z1*z3*z4 + z1*z3*z5
; 368  :         + z1*z4*z5 + z2*z3*z4 + z2*z3*z5 + z2*z4*z5 + z3*z4*z5;

	fld	QWORD PTR tv342[ebp]
	fld	ST(0)
	fmul	ST(0), ST(6)
	fld	ST(1)
	fmulp	ST(6), ST(0)
	fld	QWORD PTR tv341[ebp]
	fmul	ST(0), ST(7)
	fstp	QWORD PTR tv365[ebp]
	fld	QWORD PTR tv348[ebp]
	fmul	ST(0), ST(7)
	fstp	QWORD PTR tv371[ebp]
	fxch	ST(1)
	fmul	ST(0), ST(4)
	fld	ST(5)
	fadd	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR tv365[ebp]
	fld	QWORD PTR tv341[ebp]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	QWORD PTR tv344[ebp]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR tv371[ebp]
	fld	QWORD PTR tv348[ebp]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	QWORD PTR tv350[ebp]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	QWORD PTR tv354[ebp]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)

; 369  :     ee4 = z1*z2*z3*z4 + z1*z2*z3*z5 + z1*z2*z4*z5 + z1*z3*z4*z5 + z2*z3*z4*z5;

	fld	ST(5)
	fmulp	ST(7), ST(0)
	fxch	ST(5)
	fmul	ST(0), ST(4)
	fadd	ST(0), ST(6)
	fxch	ST(1)
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	QWORD PTR tv365[ebp]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	QWORD PTR tv371[ebp]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)

; 370  :     ee5 = z1*z2*z3*z4*z5;

	fxch	ST(5)
	fmulp	ST(3), ST(0)

; 371  :     /*return*/
; 372  :     return  (1 - 3*ee2/14 + ee3/6 + 9*ee2*ee2/88 - 3*ee4/22 - 9*ee2*ee3/52
; 373  :              + 3*ee5/26 - ee2*ee2*ee2/16 + 3*ee3*ee3/40 + 3*ee2*ee4 
; 374  :              + 45*ee2*ee2*ee3/272 - 9*(ee3*ee4 + ee2*ee5)/68)/a/sqrt(a);

	fld	ST(0)
	fld	QWORD PTR __real@4008000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv389[ebp]
	fld	ST(1)
	fmul	QWORD PTR __real@4022000000000000
	fstp	QWORD PTR tv394[ebp]
	fld	QWORD PTR tv389[ebp]
	fdiv	QWORD PTR __real@402c000000000000
	fld1
	fsubrp	ST(1), ST(0)
	fld	ST(5)
	fdiv	QWORD PTR __real@4018000000000000
	faddp	ST(1), ST(0)
	fld	QWORD PTR tv394[ebp]
	fmul	ST(0), ST(3)
	fdiv	QWORD PTR __real@4056000000000000
	faddp	ST(1), ST(0)
	fld	ST(6)
	fmul	ST(0), ST(2)
	fdiv	QWORD PTR __real@4036000000000000
	fsubp	ST(1), ST(0)
	fld	QWORD PTR tv394[ebp]
	fmul	ST(0), ST(6)
	fdiv	QWORD PTR __real@404a000000000000
	fsubp	ST(1), ST(0)
	fld	ST(4)
	fmul	ST(0), ST(2)
	fdiv	QWORD PTR __real@403a000000000000
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmul	ST(0), ST(3)
	fmul	ST(0), ST(3)
	fmul	QWORD PTR __real@3fb0000000000000
	fsubp	ST(1), ST(0)
	fld	ST(5)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(5)
	fdiv	QWORD PTR __real@4044000000000000
	faddp	ST(1), ST(0)
	fld	QWORD PTR tv389[ebp]
	fmul	ST(0), ST(6)
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	QWORD PTR __real@4046800000000000
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(5)
	fdiv	QWORD PTR __real@4071000000000000
	faddp	ST(1), ST(0)
	fxch	ST(5)
	fmulp	ST(4), ST(0)
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	faddp	ST(1), ST(0)
	fmul	QWORD PTR __real@4022000000000000
	fdiv	QWORD PTR __real@4051000000000000
	fsubp	ST(2), ST(0)
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv137[ebp]
	call	__CIsqrt
	fdivr	QWORD PTR tv137[ebp]

; 382  :   
; 383  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@RD:

; 351  :   REAL lambda;
; 352  :   REAL c;  // scaling constant to keep size in range
; 353  :  
; 354  :   // Trial of series http://dlmf.nist.gov/19.36#i 19.36.2.
; 355  :   // Restoring symmetry by triplicating z factor
; 356  :   if ( fabs(x-y) + fabs(y-z) < root8machine_eps )

	fstp	ST(0)

; 375  :   }
; 376  : 
; 377  :   // duplication formula 19.26.20
; 378  :   lambda = sqrt(x*y) + sqrt(y*z) + sqrt(z*x);

	fmulp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR tv139[ebp]
	fld	QWORD PTR _y$[ebp]
	fmul	QWORD PTR _z$[ebp]
	call	__CIsqrt
	fadd	QWORD PTR tv139[ebp]
	fstp	QWORD PTR tv141[ebp]
	fld	QWORD PTR _x$[ebp]
	fmul	QWORD PTR _z$[ebp]
	call	__CIsqrt
	fadd	QWORD PTR tv141[ebp]

; 379  :   c = 1 + 3*lambda/(x+y+z);

	fld	QWORD PTR __real@4008000000000000

; 380  :   return 2*RD((x+lambda)/c,(y+lambda)/c,(z+lambda)/c)/sqrt(c*c*c) 
; 381  :              + 3/(z+lambda)/sqrt(z);

	sub	esp, 24					; 00000018H
	fmul	ST(0), ST(1)
	fld	QWORD PTR _x$[ebp]
	fld	ST(0)
	fld	QWORD PTR _y$[ebp]
	fadd	ST(1), ST(0)
	fld	QWORD PTR _z$[ebp]
	fadd	ST(2), ST(0)
	fxch	ST(4)
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR __real@3ff0000000000000
	fst	QWORD PTR _c$[ebp]
	fld	ST(4)
	faddp	ST(4), ST(0)
	fxch	ST(3)
	fst	QWORD PTR tv445[ebp]
	fdiv	ST(0), ST(3)
	fstp	QWORD PTR [esp+16]
	fadd	ST(0), ST(3)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [esp+8]
	faddp	ST(2), ST(0)
	fdivp	ST(1), ST(0)
	fstp	QWORD PTR [esp]
	call	_RD
	fadd	ST(0), ST(0)
	add	esp, 24					; 00000018H
	fstp	QWORD PTR tv143[ebp]
	fld	QWORD PTR _c$[ebp]
	fld	ST(0)
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	call	__CIsqrt
	fdivr	QWORD PTR tv143[ebp]
	fstp	QWORD PTR tv280[ebp]
	fld	QWORD PTR __real@4008000000000000
	fdiv	QWORD PTR tv445[ebp]
	fstp	QWORD PTR tv147[ebp]
	fld	QWORD PTR _z$[ebp]
	call	__CIsqrt
	fdivr	QWORD PTR tv147[ebp]
	fadd	QWORD PTR tv280[ebp]

; 382  :   
; 383  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RD	ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fd5555555555555
PUBLIC	_RG
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fd5555555555555
CONST	SEGMENT
__real@3fd5555555555555 DQ 03fd5555555555555r	; 0.333333
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _RG
_TEXT	SEGMENT
tv132 = -8						; size = 8
tv130 = 8						; size = 8
_x$ = 8							; size = 8
_y$ = 16						; size = 8
_z$ = 24						; size = 8
_RG	PROC						; COMDAT

; 390  : { // Formula 19.21.10

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 391  :   // Completely symmetric in x,y,z so choose good permutation,
; 392  :   // (x-z)(y-z) <= 0.
; 393  : 
; 394  :   return (z*RF(x,y,z) - 1/3.*(x - z)*(y - z)*RD(x,y,z) + sqrt(x*y/z))/2;

	fld	QWORD PTR _z$[ebp]
	sub	esp, 24					; 00000018H
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR _y$[ebp]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _x$[ebp]
	fstp	QWORD PTR [esp]
	call	_RF
	fld	QWORD PTR _z$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv132[ebp]
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR _y$[ebp]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _x$[ebp]
	fstp	QWORD PTR [esp]
	call	_RD
	fld	QWORD PTR _x$[ebp]
	add	esp, 24					; 00000018H
	fld	ST(0)
	fld	QWORD PTR _z$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3fd5555555555555
	fld	QWORD PTR _y$[ebp]
	fld	ST(0)
	fsub	ST(0), ST(3)
	fmulp	ST(2), ST(0)
	fxch	ST(4)
	fmulp	ST(1), ST(0)
	fsubr	QWORD PTR tv132[ebp]
	fstp	QWORD PTR tv130[ebp]
	fxch	ST(1)
	fmulp	ST(2), ST(0)
	fdivp	ST(1), ST(0)
	call	__CIsqrt
	fadd	QWORD PTR tv130[ebp]
	fmul	QWORD PTR __real@3fe0000000000000

; 395  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RG	ENDP
_TEXT	ENDS
PUBLIC	__real@3ff921fb54442d18
PUBLIC	??_C@_0CN@DDEMFBBI@ellipticK?5domain?5violation?0?5para@ ; `string'
PUBLIC	_ellipticK
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT ??_C@_0CN@DDEMFBBI@ellipticK?5domain?5violation?0?5para@
CONST	SEGMENT
??_C@_0CN@DDEMFBBI@ellipticK?5domain?5violation?0?5para@ DB 'ellipticK do'
	DB	'main violation, parameter >= 1.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _ellipticK
_TEXT	SEGMENT
_a$ = -8						; size = 8
_anext$ = 8						; size = 8
_m$ = 8							; size = 8
_ellipticK PROC						; COMDAT

; 444  : { REAL a,b,anext;

	push	ebp
	mov	ebp, esp

; 445  : 
; 446  :   if ( m >= 1.0 )

	fld1
	sub	esp, 8
	fcom	QWORD PTR _m$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN3@ellipticK

; 447  :      kb_error(2422,"ellipticK domain violation, parameter >= 1.\n",RECOVERABLE);

	push	1
	fstp	ST(0)
	push	OFFSET ??_C@_0CN@DDEMFBBI@ellipticK?5domain?5violation?0?5para@
	push	2422					; 00000976H
	call	_kb_error
	fld1
	add	esp, 12					; 0000000cH
$LN3@ellipticK:

; 448  : 
; 449  :   a = 1.0;

	fst	QWORD PTR _a$[ebp]

; 450  :   b = sqrt(sqrt(1 - m));

	fsub	QWORD PTR _m$[ebp]
	call	__CIsqrt
	call	__CIsqrt

; 451  : 
; 452  :   while ( fabs(a-b) > machine_eps )

	fld1
	fsub	ST(0), ST(1)
	fabs
	fcomp	QWORD PTR _machine_eps
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN14@ellipticK
	fld	QWORD PTR __real@3fe0000000000000
	fld	QWORD PTR _a$[ebp]
	jmp	SHORT $LN2@ellipticK
$LN8@ellipticK:
	fld	QWORD PTR __real@3fe0000000000000
	fxch	ST(1)
$LN2@ellipticK:

; 453  :   { anext = (a + b)/2;

	fld	ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(2)
	fstp	QWORD PTR _anext$[ebp]

; 454  :     b = sqrt(sqrt(a*b*(a*a+b*b)/2));

	fld	ST(2)
	fmul	ST(0), ST(3)
	fld	ST(1)
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fxch	ST(3)
	fmulp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	fmulp	ST(1), ST(0)
	call	__CIsqrt
	call	__CIsqrt

; 455  :     a = anext;

	fld	QWORD PTR _anext$[ebp]
	fld	ST(0)
	fxch	ST(1)
	fsub	ST(0), ST(2)
	fabs
	fcomp	QWORD PTR _machine_eps
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN8@ellipticK

; 456  :   }
; 457  : 
; 458  :   return M_PI/2/a/a;

	fstp	ST(1)
	fld	QWORD PTR __real@3ff921fb54442d18
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)

; 459  : } // end ellipticK(REAL m)

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@ellipticK:

; 451  : 
; 452  :   while ( fabs(a-b) > machine_eps )

	fstp	ST(0)
	fld	QWORD PTR _a$[ebp]

; 456  :   }
; 457  : 
; 458  :   return M_PI/2/a/a;

	fld	QWORD PTR __real@3ff921fb54442d18
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)

; 459  : } // end ellipticK(REAL m)

	mov	esp, ebp
	pop	ebp
	ret	0
_ellipticK ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@IALODEID@ellipticE?5domain?5violation?0?5para@ ; `string'
PUBLIC	_ellipticE
;	COMDAT ??_C@_0CM@IALODEID@ellipticE?5domain?5violation?0?5para@
CONST	SEGMENT
??_C@_0CM@IALODEID@ellipticE?5domain?5violation?0?5para@ DB 'ellipticE do'
	DB	'main violation, parameter > 1.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _ellipticE
_TEXT	SEGMENT
_ff$ = -16						; size = 8
_sum$ = -8						; size = 8
_anext$ = 8						; size = 8
_a$ = 8							; size = 8
_m$ = 8							; size = 8
_ellipticE PROC						; COMDAT

; 463  : { REAL a,b,anext;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 464  :   REAL K,sum = 0;

	fldz
	fstp	QWORD PTR _sum$[ebp]

; 465  :   REAL ff = 1.0;

	fld1
	fst	QWORD PTR _ff$[ebp]

; 466  : 
; 467  :   if ( m > 1.0 )

	fld	QWORD PTR _m$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@ellipticE

; 468  :      kb_error(2423,"ellipticE domain violation, parameter > 1.\n",RECOVERABLE);

	push	1
	fstp	ST(1)
	push	OFFSET ??_C@_0CM@IALODEID@ellipticE?5domain?5violation?0?5para@
	fstp	ST(0)
	push	2423					; 00000977H
	call	_kb_error
	fld1
	fld	QWORD PTR _m$[ebp]
	add	esp, 12					; 0000000cH
$LN4@ellipticE:

; 469  :   if ( m == 1.0 ) return 1.0;

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@ellipticE
	fstp	ST(0)

; 485  : } // end ellipticE()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@ellipticE:

; 470  : 
; 471  :   a = 1.0; 

	fxch	ST(1)
	fst	QWORD PTR _a$[ebp]

; 472  :   b = sqrt(sqrt(1 - m));

	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	call	__CIsqrt

; 473  : 
; 474  :   while ( fabs(a-b) > machine_eps )

	fld1
	fsub	ST(0), ST(1)
	fabs
	fcomp	QWORD PTR _machine_eps
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN18@ellipticE
	fld	QWORD PTR __real@3fe0000000000000
	fld	QWORD PTR _a$[ebp]
	jmp	SHORT $LN2@ellipticE
$LN9@ellipticE:
	fld	QWORD PTR __real@3fe0000000000000
	fxch	ST(1)
$LN2@ellipticE:

; 475  :   { REAL aa = a*a, bb = b*b;

	fld	ST(0)
	fmul	ST(0), ST(1)
	fld	ST(0)
	fld	ST(4)
	fmul	ST(0), ST(5)
	fld	ST(0)

; 476  :     sum += ff*(aa*aa - (aa+bb)*(aa+bb)/4);

	fadd	ST(0), ST(2)
	fld	ST(2)
	fmulp	ST(3), ST(0)
	fmul	ST(0), ST(0)
	fmul	QWORD PTR __real@3fd0000000000000
	fsubp	ST(2), ST(0)
	fld	QWORD PTR _ff$[ebp]
	fmul	ST(2), ST(0)
	fxch	ST(2)
	fadd	QWORD PTR _sum$[ebp]
	fstp	QWORD PTR _sum$[ebp]

; 477  :     ff *= 4;

	fxch	ST(1)
	fmul	QWORD PTR __real@4010000000000000
	fstp	QWORD PTR _ff$[ebp]

; 478  :     anext = (a + b)/2;

	fld	ST(4)
	fadd	ST(0), ST(3)
	fmul	ST(0), ST(4)
	fstp	QWORD PTR _anext$[ebp]

; 479  :     b = sqrt(sqrt(a*b*(a*a+b*b)/2));

	faddp	ST(1), ST(0)
	fxch	ST(3)
	fmulp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	fmulp	ST(1), ST(0)
	call	__CIsqrt
	call	__CIsqrt

; 480  :     a = anext;

	fld	QWORD PTR _anext$[ebp]
	fld	ST(0)
	fxch	ST(1)
	fsub	ST(0), ST(2)
	fabs
	fcomp	QWORD PTR _machine_eps
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN9@ellipticE

; 473  : 
; 474  :   while ( fabs(a-b) > machine_eps )

	fstp	ST(1)
	jmp	SHORT $LN1@ellipticE
$LN18@ellipticE:
	fstp	ST(0)
	fld	QWORD PTR _a$[ebp]
$LN1@ellipticE:

; 481  :   }
; 482  : 
; 483  :   K = M_PI/2/a/a;

	fld	QWORD PTR __real@3ff921fb54442d18
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)

; 484  :   return K*(1.0 - sum);

	fld1
	fsub	QWORD PTR _sum$[ebp]
	fmulp	ST(1), ST(0)

; 485  : } // end ellipticE()

	mov	esp, ebp
	pop	ebp
	ret	0
_ellipticE ENDP
_TEXT	ENDS
PUBLIC	__real@bfd921fb54442d18
PUBLIC	__real@465f8def8808b024
PUBLIC	_ellipticEdm
;	COMDAT __real@bfd921fb54442d18
CONST	SEGMENT
__real@bfd921fb54442d18 DQ 0bfd921fb54442d18r	; -0.392699
CONST	ENDS
;	COMDAT __real@465f8def8808b024
CONST	SEGMENT
__real@465f8def8808b024 DQ 0465f8def8808b024r	; 1e+031
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _ellipticEdm
_TEXT	SEGMENT
tv87 = -8						; size = 8
_m$ = 8							; size = 8
_ellipticEdm PROC					; COMDAT

; 489  : { if ( m == 1.0 ) return 1.0e31;

	push	ebp
	mov	ebp, esp
	fld	QWORD PTR _m$[ebp]
	sub	esp, 8
	fld	ST(0)
	fld1
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@ellipticEd
	fstp	ST(0)
	fld	QWORD PTR __real@465f8def8808b024

; 491  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@ellipticEd:

; 490  :   return m==0 ? -M_PI/8 : (ellipticE(m) - ellipticK(m))/2/m;

	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@ellipticEd
	fstp	ST(0)
	fld	QWORD PTR __real@bfd921fb54442d18

; 491  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@ellipticEd:

; 490  :   return m==0 ? -M_PI/8 : (ellipticE(m) - ellipticK(m))/2/m;

	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_ellipticE
	fstp	QWORD PTR tv87[ebp]
	fld	QWORD PTR _m$[ebp]
	fstp	QWORD PTR [esp]
	call	_ellipticK
	fsubr	QWORD PTR tv87[ebp]
	add	esp, 8
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _m$[ebp]

; 491  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ellipticEdm ENDP
_TEXT	ENDS
PUBLIC	__real@3fd921fb54442d18
PUBLIC	_ellipticKdm
;	COMDAT __real@3fd921fb54442d18
CONST	SEGMENT
__real@3fd921fb54442d18 DQ 03fd921fb54442d18r	; 0.392699
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _ellipticKdm
_TEXT	SEGMENT
tv85 = -16						; size = 8
tv129 = -8						; size = 8
_m$ = 8							; size = 8
_ellipticKdm PROC					; COMDAT

; 495  : { return m==0 ? M_PI/8 : (ellipticE(m) - (1-m)*ellipticK(m))/2/m/(1-m);

	push	ebp
	mov	ebp, esp
	fld	QWORD PTR _m$[ebp]
	sub	esp, 16					; 00000010H
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@ellipticKd
	fstp	ST(0)
	fld	QWORD PTR __real@3fd921fb54442d18

; 496  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@ellipticKd:

; 495  : { return m==0 ? M_PI/8 : (ellipticE(m) - (1-m)*ellipticK(m))/2/m/(1-m);

	fld1
	sub	esp, 8
	fsub	ST(0), ST(1)
	fstp	QWORD PTR tv129[ebp]
	fstp	QWORD PTR [esp]
	call	_ellipticE
	fstp	QWORD PTR tv85[ebp]
	fld	QWORD PTR _m$[ebp]
	fstp	QWORD PTR [esp]
	call	_ellipticK
	fld	QWORD PTR tv129[ebp]
	add	esp, 8
	fmul	ST(1), ST(0)
	fld	QWORD PTR tv85[ebp]
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _m$[ebp]
	fdivrp	ST(1), ST(0)

; 496  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ellipticKdm ENDP
_TEXT	ENDS
PUBLIC	__real@bfc2d97c7f3321d2
PUBLIC	_ellipticEdmdm
;	COMDAT __real@bfc2d97c7f3321d2
CONST	SEGMENT
__real@bfc2d97c7f3321d2 DQ 0bfc2d97c7f3321d2r	; -0.147262
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _ellipticEdmdm
_TEXT	SEGMENT
tv65 = -8						; size = 8
_m$ = 8							; size = 8
_ellipticEdmdm PROC					; COMDAT

; 500  : { return  (m==0) ? -3./64*M_PI : ((m-2)*ellipticE(m) - 2*(m-1)*ellipticK(m))

	push	ebp
	mov	ebp, esp

; 501  :             /4/m/m/(1-m);

	fld	QWORD PTR _m$[ebp]
	sub	esp, 8
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@ellipticEd@2
	fstp	ST(0)
	fld	QWORD PTR __real@bfc2d97c7f3321d2

; 502  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@ellipticEd@2:

; 501  :             /4/m/m/(1-m);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_ellipticE
	fld	QWORD PTR _m$[ebp]
	fld	QWORD PTR __real@4000000000000000
	fsubr	ST(0), ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv65[ebp]
	fstp	QWORD PTR [esp]
	call	_ellipticK
	fld	QWORD PTR _m$[ebp]
	add	esp, 8
	fld	ST(0)
	fld1
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fadd	ST(0), ST(0)
	fmulp	ST(3), ST(0)
	fld	QWORD PTR tv65[ebp]
	fsubrp	ST(3), ST(0)
	fxch	ST(2)
	fmul	QWORD PTR __real@3fd0000000000000
	fdiv	ST(0), ST(1)
	fdiv	ST(0), ST(1)
	fxch	ST(2)
	fsubrp	ST(1), ST(0)
	fdivp	ST(1), ST(0)

; 502  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ellipticEdmdm ENDP
_TEXT	ENDS
PUBLIC	__real@3fdc463abeccb2bb
PUBLIC	_ellipticKdmdm
;	COMDAT __real@3fdc463abeccb2bb
CONST	SEGMENT
__real@3fdc463abeccb2bb DQ 03fdc463abeccb2bbr	; 0.441786
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _ellipticKdmdm
_TEXT	SEGMENT
tv177 = -16						; size = 8
tv79 = -8						; size = 8
_m$ = 8							; size = 8
_ellipticKdmdm PROC					; COMDAT

; 506  : { return (m == 0) ? 9./64*M_PI : 

	push	ebp
	mov	ebp, esp

; 507  :      ((4*m-2)*ellipticE(m) + (2-5*m+3*m*m)*ellipticK(m))/4/m/m/(1-m)/(1-m);

	fld	QWORD PTR _m$[ebp]
	sub	esp, 16					; 00000010H
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@ellipticKd@2
	fstp	ST(0)
	fld	QWORD PTR __real@3fdc463abeccb2bb

; 508  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@ellipticKd@2:

; 507  :      ((4*m-2)*ellipticE(m) + (2-5*m+3*m*m)*ellipticK(m))/4/m/m/(1-m)/(1-m);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_ellipticK
	fld	QWORD PTR _m$[ebp]
	fld	QWORD PTR __real@4014000000000000
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR __real@4000000000000000
	fld	ST(1)
	fmul	QWORD PTR __real@4008000000000000
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv79[ebp]
	fld1
	fsub	ST(0), ST(1)
	fstp	QWORD PTR tv177[ebp]
	fstp	QWORD PTR [esp]
	call	_ellipticE
	fld	QWORD PTR _m$[ebp]
	add	esp, 8
	fld	QWORD PTR __real@4010000000000000
	fmul	ST(0), ST(1)
	fsub	QWORD PTR __real@4000000000000000
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR tv79[ebp]
	fmul	QWORD PTR __real@3fd0000000000000
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)
	fld	QWORD PTR tv177[ebp]
	fdiv	ST(1), ST(0)
	fdivp	ST(1), ST(0)

; 508  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ellipticKdmdm ENDP
_TEXT	ENDS
PUBLIC	_incompleteEllipticFdphi
EXTRN	__CIsin:PROC
; Function compile flags: /Ogtp
;	COMDAT _incompleteEllipticFdphi
_TEXT	SEGMENT
_phi$ = 8						; size = 8
_m$ = 16						; size = 8
_incompleteEllipticFdphi PROC				; COMDAT

; 512  : { return 1/sqrt(1 - m*sin(phi)*sin(phi));

	push	ebp
	mov	ebp, esp
	fld	QWORD PTR _phi$[ebp]
	call	__CIsin
	fld	QWORD PTR _m$[ebp]
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fld1
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fld1
	fdivrp	ST(1), ST(0)

; 513  : }

	pop	ebp
	ret	0
_incompleteEllipticFdphi ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DJ@BFDFEKAB@incompleteEllipticF?5domain?5viola@ ; `string'
PUBLIC	_incompleteEllipticF
EXTRN	__CIatan:PROC
EXTRN	__CItan:PROC
EXTRN	__CIasin:PROC
;	COMDAT ??_C@_0DJ@BFDFEKAB@incompleteEllipticF?5domain?5viola@
CONST	SEGMENT
??_C@_0DJ@BFDFEKAB@incompleteEllipticF?5domain?5viola@ DB 'incompleteElli'
	DB	'pticF domain violation, m*sin(phi)^2 > 1.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _incompleteEllipticF
_TEXT	SEGMENT
tv251 = -48						; size = 8
tv237 = -40						; size = 8
tv209 = -40						; size = 8
_poweroftwo$ = -40					; size = 8
tv226 = -32						; size = 8
_p$ = -32						; size = 8
_tanp$ = -24						; size = 8
tv246 = -16						; size = 8
tv236 = -16						; size = 8
_a$ = -8						; size = 8
_phi$ = 8						; size = 8
tv229 = 16						; size = 8
tv207 = 16						; size = 8
_b$ = 16						; size = 8
_m$ = 16						; size = 8
_incompleteEllipticF PROC				; COMDAT

; 560  : { REAL p,tanp,a,b,c,poweroftwo,csum,csinphisum,F;

	push	ebp
	mov	ebp, esp

; 561  :   REAL anext,bnext,cnext;
; 562  : 
; 563  :   if ( m == 0 ) return phi;

	fld	QWORD PTR _m$[ebp]
	sub	esp, 48					; 00000030H
	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@incomplete
	fstp	ST(1)
	fstp	ST(0)
	fld	QWORD PTR _phi$[ebp]

; 596  : 
; 597  :   return F;
; 598  : } // end incompleteEllipticF()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@incomplete:

; 564  :   if ( m < 0 ) return (incompleteEllipticF(M_PI/2+phi,-m/(1-m))

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN5@incomplete

; 565  :                           - ellipticK(-m/(1-m)))/sqrt(1-m);

	fld1
	sub	esp, 16					; 00000010H
	fsub	ST(0), ST(1)
	fst	QWORD PTR tv226[ebp]
	fdivp	ST(1), ST(0)
	fchs
	fst	QWORD PTR tv229[ebp]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _phi$[ebp]
	fadd	QWORD PTR __real@3ff921fb54442d18
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticF
	fstp	QWORD PTR tv209[ebp]
	add	esp, 8
	fld	QWORD PTR tv229[ebp]
	fstp	QWORD PTR [esp]
	call	_ellipticK
	fsubr	QWORD PTR tv209[ebp]
	add	esp, 8
	fstp	QWORD PTR tv207[ebp]
	fld	QWORD PTR tv226[ebp]
	call	__CIsqrt
	fdivr	QWORD PTR tv207[ebp]

; 596  : 
; 597  :   return F;
; 598  : } // end incompleteEllipticF()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@incomplete:

; 566  :   if ( sqrt(m)*sin(phi) > 1.0 )

	call	__CIsqrt
	fstp	QWORD PTR tv236[ebp]
	fld	QWORD PTR _phi$[ebp]
	call	__CIsin
	fmul	QWORD PTR tv236[ebp]
	fst	QWORD PTR tv237[ebp]
	fld1
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@incomplete

; 567  :      kb_error(2425,"incompleteEllipticF domain violation, m*sin(phi)^2 > 1.\n",
; 568  :         RECOVERABLE);

	push	1
	fstp	ST(1)
	push	OFFSET ??_C@_0DJ@BFDFEKAB@incompleteEllipticF?5domain?5viola@
	fstp	ST(0)
	push	2425					; 00000979H
	call	_kb_error
	fld	QWORD PTR tv237[ebp]
	fld1
	add	esp, 12					; 0000000cH
$LN4@incomplete:

; 569  :   if ( m > 1.0 )

	fld	QWORD PTR _m$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN23@incomplete

; 570  :      return incompleteEllipticF(asin(sqrt(m)*sin(phi)),1/m)/sqrt(m);

	fdivp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	__CIasin
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticF
	fdiv	QWORD PTR tv236[ebp]
	add	esp, 16					; 00000010H

; 596  : 
; 597  :   return F;
; 598  : } // end incompleteEllipticF()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@incomplete:

; 569  :   if ( m > 1.0 )

	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(0)

; 571  : 
; 572  :   p = phi; 

	fld	QWORD PTR _phi$[ebp]
	fst	QWORD PTR _p$[ebp]

; 573  :   tanp = tan(p);

	call	__CItan
	fstp	QWORD PTR _tanp$[ebp]

; 574  :   a = 1.0; 

	fld1
	fst	QWORD PTR _a$[ebp]

; 575  :   b = sqrt(1-m);

	fsub	QWORD PTR _m$[ebp]
	call	__CIsqrt
	fst	QWORD PTR _b$[ebp]

; 576  :   c = sqrt(m);
; 577  :   poweroftwo = 1.0;

	fld1
	fld	ST(0)
	fst	QWORD PTR _poweroftwo$[ebp]

; 578  :   csum = c*c;
; 579  :   csinphisum = 0;
; 580  : 
; 581  :   while ( c > machine_eps )

	fld	QWORD PTR _machine_eps
	fcomp	QWORD PTR tv236[ebp]
	fnstsw	ax
	test	ah, 5
	jp	$LN27@incomplete
	fstp	ST(0)
	fld	QWORD PTR _a$[ebp]
	jmp	SHORT $LN2@incomplete
	npad	1
$LL32@incomplete:
	fstp	ST(1)
	fld1
	fxch	ST(1)
	fxch	ST(2)
$LN2@incomplete:

; 582  :   { 
; 583  :     p = 2*p + atan((b/a - 1)*tanp/(1+b/a*tanp*tanp));

	fdivp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR tv246[ebp]
	fld	ST(0)
	fld	QWORD PTR _tanp$[ebp]
	fmul	ST(1), ST(0)
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fst	QWORD PTR tv251[ebp]
	fxch	ST(2)
	fsub	ST(0), ST(3)
	fmulp	ST(1), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fdivrp	ST(1), ST(0)
	call	__CIatan
	fld	QWORD PTR _p$[ebp]
	fadd	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _p$[ebp]

; 584  :     tanp = (1+b/a)*tanp/(1-b/a*tanp*tanp);

	fld	QWORD PTR tv246[ebp]
	fld1
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR _tanp$[ebp]
	fxch	ST(1)
	fsub	QWORD PTR tv251[ebp]
	fdivp	ST(1), ST(0)
	fstp	QWORD PTR _tanp$[ebp]

; 585  : 
; 586  :     anext = (a+b)/2;
; 587  :     bnext = sqrt(a*b);

	fld	QWORD PTR _b$[ebp]
	fmul	QWORD PTR _a$[ebp]
	call	__CIsqrt

; 588  :     cnext = (a-b)/2;

	fld	QWORD PTR _a$[ebp]
	fld	ST(0)
	fld	QWORD PTR _b$[ebp]
	fsub	ST(1), ST(0)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(2), ST(0)
	fxch	ST(1)
	faddp	ST(3), ST(0)
	fmulp	ST(2), ST(0)

; 589  :     a = anext; b = bnext; c = cnext;

	fxch	ST(1)
	fst	QWORD PTR _a$[ebp]
	fxch	ST(2)
	fst	QWORD PTR _b$[ebp]

; 590  : 
; 591  :     poweroftwo *= 2;

	fld	QWORD PTR _poweroftwo$[ebp]
	fadd	ST(0), ST(0)
	fst	QWORD PTR _poweroftwo$[ebp]
	fld	QWORD PTR _machine_eps
	fcomp	ST(3)
	fnstsw	ax
	fstp	ST(2)
	test	ah, 5
	jnp	$LL32@incomplete

; 592  :     csum += poweroftwo*c*c;
; 593  :     csinphisum += c*sin(p);
; 594  :   }
; 595  :   F = p/poweroftwo/a;

	fstp	ST(0)
	fdivr	QWORD PTR _p$[ebp]
	fdivrp	ST(1), ST(0)

; 596  : 
; 597  :   return F;
; 598  : } // end incompleteEllipticF()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@incomplete:

; 578  :   csum = c*c;
; 579  :   csinphisum = 0;
; 580  : 
; 581  :   while ( c > machine_eps )

	fstp	ST(2)
	fstp	ST(0)
	fld	QWORD PTR _a$[ebp]
	fxch	ST(1)

; 592  :     csum += poweroftwo*c*c;
; 593  :     csinphisum += c*sin(p);
; 594  :   }
; 595  :   F = p/poweroftwo/a;

	fdivr	QWORD PTR _p$[ebp]
	fdivrp	ST(1), ST(0)

; 596  : 
; 597  :   return F;
; 598  : } // end incompleteEllipticF()

	mov	esp, ebp
	pop	ebp
	ret	0
_incompleteEllipticF ENDP
_TEXT	ENDS
PUBLIC	_incompleteEllipticEdphi
; Function compile flags: /Ogtp
;	COMDAT _incompleteEllipticEdphi
_TEXT	SEGMENT
_phi$ = 8						; size = 8
_m$ = 16						; size = 8
_incompleteEllipticEdphi PROC				; COMDAT

; 602  : { return sqrt(1 - m*sin(phi)*sin(phi));

	push	ebp
	mov	ebp, esp
	fld	QWORD PTR _phi$[ebp]
	call	__CIsin
	fld	QWORD PTR _m$[ebp]
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fld1
	fsubrp	ST(1), ST(0)

; 603  : }

	pop	ebp

; 602  : { return sqrt(1 - m*sin(phi)*sin(phi));

	jmp	__CIsqrt
_incompleteEllipticEdphi ENDP
_TEXT	ENDS
PUBLIC	__real@403e000000000000
PUBLIC	__real@3f1a36e2eb1c432d
PUBLIC	??_C@_0DH@HOHKANIH@incompleteEllipticE?3?5phi?5?$CFf?5too?5@ ; `string'
PUBLIC	__real@400921fb54442d18
PUBLIC	_incompleteEllipticE
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
EXTRN	_floor:PROC
;	COMDAT __real@403e000000000000
CONST	SEGMENT
__real@403e000000000000 DQ 0403e000000000000r	; 30
CONST	ENDS
;	COMDAT __real@3f1a36e2eb1c432d
CONST	SEGMENT
__real@3f1a36e2eb1c432d DQ 03f1a36e2eb1c432dr	; 0.0001
CONST	ENDS
;	COMDAT ??_C@_0DH@HOHKANIH@incompleteEllipticE?3?5phi?5?$CFf?5too?5@
CONST	SEGMENT
??_C@_0DH@HOHKANIH@incompleteEllipticE?3?5phi?5?$CFf?5too?5@ DB 'incomple'
	DB	'teEllipticE: phi %f too large for given m %f.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _incompleteEllipticE
_TEXT	SEGMENT
_reduced_phi$ = -64					; size = 8
tv249 = -56						; size = 8
_lambda$ = -48						; size = 8
tv253 = -40						; size = 8
_period$ = -40						; size = 8
tv313 = -32						; size = 8
tv258 = -32						; size = 8
_c$ = -32						; size = 8
tv311 = -24						; size = 8
tv297 = -24						; size = 8
tv309 = -16						; size = 8
tv307 = -8						; size = 8
_phi$ = 8						; size = 8
tv261 = 16						; size = 8
tv251 = 16						; size = 8
_value$ = 16						; size = 8
_m$ = 16						; size = 8
_incompleteEllipticE PROC				; COMDAT

; 399  : { REAL c,reduced_phi,period,value,lambda;

	push	ebp
	mov	ebp, esp

; 400  : 
; 401  :   if ( m == 0 ) return phi;

	fld	QWORD PTR _m$[ebp]
	sub	esp, 64					; 00000040H
	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@incomplete@2
	fstp	ST(0)
	fstp	ST(0)
	fld	QWORD PTR _phi$[ebp]

; 433  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@incomplete@2:

; 402  :   if ( m < 0 ) return (incompleteEllipticE(M_PI/2+phi,-m/(1-m))

	fcomp	ST(1)
	fnstsw	ax

; 403  :                           - ellipticE(-m/(1-m)))*sqrt(1-m);

	fld1
	test	ah, 65					; 00000041H
	jne	SHORT $LN6@incomplete@2
	fsub	ST(0), ST(1)
	sub	esp, 16					; 00000010H
	fst	QWORD PTR tv258[ebp]
	fdivp	ST(1), ST(0)
	fchs
	fst	QWORD PTR tv261[ebp]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _phi$[ebp]
	fadd	QWORD PTR __real@3ff921fb54442d18
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticE
	fstp	QWORD PTR tv253[ebp]
	add	esp, 8
	fld	QWORD PTR tv261[ebp]
	fstp	QWORD PTR [esp]
	call	_ellipticE
	fsubr	QWORD PTR tv253[ebp]
	add	esp, 8
	fstp	QWORD PTR tv251[ebp]
	fld	QWORD PTR tv258[ebp]
	call	__CIsqrt
	fmul	QWORD PTR tv251[ebp]

; 433  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@incomplete@2:

; 404  :   if ( m >= 1 && fabs(phi) > M_PI )

	fcomp	ST(1)
	fnstsw	ax
	fld	QWORD PTR _phi$[ebp]
	test	ah, 65					; 00000041H
	jp	SHORT $LN23@incomplete@2
	fld	ST(0)
	fabs
	fcomp	QWORD PTR __real@400921fb54442d18
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN23@incomplete@2

; 405  :   { sprintf(errmsg,"incompleteEllipticE: phi %f too large for given m %f.\n",
; 406  :         phi,m);

	sub	esp, 16					; 00000010H
	fxch	ST(1)
	fstp	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0DH@HOHKANIH@incompleteEllipticE?3?5phi?5?$CFf?5too?5@
	push	OFFSET _errmsg
	call	_sprintf

; 407  :     kb_error(2663,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2663					; 00000a67H
	call	_kb_error
	fld	QWORD PTR _phi$[ebp]
	add	esp, 36					; 00000024H
	jmp	SHORT $LN5@incomplete@2
$LN23@incomplete@2:

; 404  :   if ( m >= 1 && fabs(phi) > M_PI )

	fstp	ST(1)
$LN5@incomplete@2:

; 408  :   }
; 409  : 
; 410  :   // figure period
; 411  :   period = floor( (phi+M_PI/2)/M_PI );

	fadd	QWORD PTR __real@3ff921fb54442d18
	sub	esp, 8
	fdiv	QWORD PTR __real@400921fb54442d18
	fstp	QWORD PTR [esp]
	call	_floor
	fst	QWORD PTR _period$[ebp]

; 412  :   reduced_phi = phi - period*M_PI;

	fmul	QWORD PTR __real@400921fb54442d18
	add	esp, 8
	fsubr	QWORD PTR _phi$[ebp]
	fst	QWORD PTR _reduced_phi$[ebp]

; 413  :  
; 414  :   if ( fabs(reduced_phi) < 1e-4 )

	fld	ST(0)
	fabs
	fcomp	QWORD PTR __real@3f1a36e2eb1c432d
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@incomplete@2

; 415  :     value = reduced_phi - m/6*reduced_phi*reduced_phi*reduced_phi
; 416  :         +(m/30 - m*m*m/40)*reduced_phi*reduced_phi*reduced_phi*reduced_phi*reduced_phi;

	fld	QWORD PTR _m$[ebp]
	fld	QWORD PTR __real@403e000000000000
	fdivr	ST(0), ST(1)
	fld	ST(1)
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(2)
	fdiv	QWORD PTR __real@4044000000000000
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(2)
	fld	ST(1)
	fdiv	QWORD PTR __real@4018000000000000
	fmul	ST(0), ST(3)
	fmul	ST(0), ST(3)
	fmul	ST(0), ST(3)
	fsubp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _value$[ebp]

; 417  :   else

	fldz
	jmp	$LN1@incomplete@2
$LN4@incomplete@2:

; 418  :   {
; 419  :     c = 1/sin(reduced_phi);

	call	__CIsin
	fld1
	fld	ST(0)
	fdivrp	ST(2), ST(0)

; 420  :     c *= c;

	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _c$[ebp]

; 421  :     if ( c-m < 0.0 )

	fld	ST(0)
	fld	QWORD PTR _m$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fst	QWORD PTR tv297[ebp]
	fldz
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN34@incomplete@2

; 422  :     { sprintf(errmsg,"incompleteEllipticE: phi %f too large for given m %f.\n",
; 423  :          phi,m);
; 424  :       kb_error(3039,errmsg,RECOVERABLE);

	fstp	ST(2)
	sub	esp, 16					; 00000010H
	fstp	ST(1)
	fstp	ST(1)
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _phi$[ebp]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0DH@HOHKANIH@incompleteEllipticE?3?5phi?5?$CFf?5too?5@
	push	OFFSET _errmsg
	call	_sprintf
	push	1
	push	OFFSET _errmsg
	push	3039					; 00000bdfH
	call	_kb_error
	fld	QWORD PTR _c$[ebp]
	fld1
	add	esp, 36					; 00000024H
	fld	QWORD PTR tv297[ebp]
	fxch	ST(1)
	fxch	ST(2)
	fxch	ST(1)
$LN2@incomplete@2:

; 425  :     }
; 426  :     lambda = 1/(fabs(c-1)+fabs(c-m)+fabs(c)); // get in nice range

	fld	ST(1)
	fsub	ST(0), ST(3)
	fld	ST(0)
	fabs
	fld	ST(2)
	fabs
	faddp	ST(1), ST(0)
	fld	ST(3)
	fabs
	faddp	ST(1), ST(0)
	fdivp	ST(4), ST(0)
	fxch	ST(3)
	fst	QWORD PTR _lambda$[ebp]

; 427  :     value = sqrt(lambda)*RF((c-1)*lambda,(c-m)*lambda,c*lambda) 
; 428  :              - lambda*sqrt(lambda)*m/3*RD((c-1)*lambda,(c-m)*lambda,c*lambda);

	fld	ST(0)
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR tv307[ebp]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR tv309[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv311[ebp]
	call	__CIsqrt
	fstp	QWORD PTR tv313[ebp]
	fld	QWORD PTR tv307[ebp]
	sub	esp, 24					; 00000018H
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR tv309[ebp]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR tv311[ebp]
	fstp	QWORD PTR [esp]
	call	_RF
	fmul	QWORD PTR tv313[ebp]
	fstp	QWORD PTR tv249[ebp]
	fld	QWORD PTR tv307[ebp]
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR tv309[ebp]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR tv311[ebp]
	fstp	QWORD PTR [esp]
	call	_RD
	fld	QWORD PTR tv313[ebp]
	add	esp, 24					; 00000018H
	fmul	QWORD PTR _lambda$[ebp]
	fld	QWORD PTR _m$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fdiv	QWORD PTR __real@4008000000000000
	fmulp	ST(2), ST(0)
	fld	QWORD PTR tv249[ebp]
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _value$[ebp]

; 429  :     if ( reduced_phi < 0.0 )

	fldz
	fcom	QWORD PTR _reduced_phi$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@incomplete@2

; 430  :       value = -value;

	fxch	ST(1)
	fchs
	fst	QWORD PTR _value$[ebp]
	fxch	ST(1)
$LN1@incomplete@2:

; 431  :   }
; 432  :   return value + (period ? period*2*ellipticE(m) : 0.0);

	fld	QWORD PTR _period$[ebp]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN30@incomplete@2
	fstp	ST(1)
	sub	esp, 8
	fstp	ST(0)
	fstp	QWORD PTR [esp]
	call	_ellipticE
	fld	QWORD PTR _period$[ebp]
	add	esp, 8
	fadd	ST(0), ST(0)
	fmulp	ST(1), ST(0)
	fld	QWORD PTR _value$[ebp]
	faddp	ST(1), ST(0)

; 433  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@incomplete@2:

; 422  :     { sprintf(errmsg,"incompleteEllipticE: phi %f too large for given m %f.\n",
; 423  :          phi,m);
; 424  :       kb_error(3039,errmsg,RECOVERABLE);

	fstp	ST(1)

; 421  :     if ( c-m < 0.0 )

	jmp	$LN2@incomplete@2
$LN30@incomplete@2:

; 431  :   }
; 432  :   return value + (period ? period*2*ellipticE(m) : 0.0);

	fstp	ST(2)
	faddp	ST(1), ST(0)

; 433  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_incompleteEllipticE ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@EDLPLEIN@incompleteEllipticE?5domain?5viola@ ; `string'
PUBLIC	_incompleteEllipticExx
;	COMDAT ??_C@_0DG@EDLPLEIN@incompleteEllipticE?5domain?5viola@
CONST	SEGMENT
??_C@_0DG@EDLPLEIN@incompleteEllipticE?5domain?5viola@ DB 'incompleteElli'
	DB	'pticE domain violation, parameter > 1.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _incompleteEllipticExx
_TEXT	SEGMENT
tv246 = -64						; size = 8
_cnext$ = -64						; size = 8
tv241 = -56						; size = 8
tv179 = -48						; size = 8
_csinphisum$ = -48					; size = 8
tv227 = -40						; size = 8
_poweroftwo$ = -40					; size = 8
_tanp$ = -32						; size = 8
_p$ = -24						; size = 8
_b$ = -16						; size = 8
_a$ = -8						; size = 8
_phi$ = 8						; size = 8
tv230 = 16						; size = 8
tv181 = 16						; size = 8
_csum$ = 16						; size = 8
_m$ = 16						; size = 8
_incompleteEllipticExx PROC				; COMDAT

; 518  : { REAL p,tanp,a,b,c,poweroftwo,csum,E,csinphisum,F,K,retval;

	push	ebp
	mov	ebp, esp

; 519  :   REAL anext,bnext,cnext;
; 520  : 
; 521  :   if ( m > 1.0 )

	fld1
	sub	esp, 64					; 00000040H
	fld	QWORD PTR _m$[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jne	SHORT $LN5@incomplete@3

; 522  :      kb_error(2424,"incompleteEllipticE domain violation, parameter > 1.\n",
; 523  :         RECOVERABLE);

	push	1
	fstp	ST(0)
	push	OFFSET ??_C@_0DG@EDLPLEIN@incompleteEllipticE?5domain?5viola@
	push	2424					; 00000978H
	call	_kb_error
	fld	QWORD PTR _m$[ebp]
	add	esp, 12					; 0000000cH
$LN5@incomplete@3:

; 524  :   if ( m == 0 ) return phi;

	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@incomplete@3
	fstp	ST(1)
	fstp	ST(0)
	fld	QWORD PTR _phi$[ebp]

; 555  : 
; 556  :   return retval;
; 557  : } // end incompleteEllipticE()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@incomplete@3:

; 525  :   if ( m < 0 ) return -(incompleteEllipticE(M_PI/2+phi,-m/(1-m))

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN18@incomplete@3

; 526  :                           - ellipticE(-m/(1-m)))*sqrt(1-m);

	fld1
	sub	esp, 16					; 00000010H
	fsub	ST(0), ST(1)
	fst	QWORD PTR tv227[ebp]
	fdivp	ST(1), ST(0)
	fchs
	fst	QWORD PTR tv230[ebp]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _phi$[ebp]
	fadd	QWORD PTR __real@3ff921fb54442d18
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticE
	fstp	QWORD PTR tv179[ebp]
	add	esp, 8
	fld	QWORD PTR tv230[ebp]
	fstp	QWORD PTR [esp]
	call	_ellipticE
	fsubr	QWORD PTR tv179[ebp]
	add	esp, 8
	fstp	QWORD PTR tv181[ebp]
	fld	QWORD PTR tv227[ebp]
	call	__CIsqrt
	fmul	QWORD PTR tv181[ebp]
	fchs

; 555  : 
; 556  :   return retval;
; 557  : } // end incompleteEllipticE()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@incomplete@3:

; 525  :   if ( m < 0 ) return -(incompleteEllipticE(M_PI/2+phi,-m/(1-m))

	fstp	ST(0)

; 527  : 
; 528  :   p = phi; 

	fld	QWORD PTR _phi$[ebp]
	fst	QWORD PTR _p$[ebp]

; 529  :   tanp = tan(p);

	call	__CItan
	fstp	QWORD PTR _tanp$[ebp]

; 530  :   a = 1.0; 

	fld1
	fst	QWORD PTR _a$[ebp]

; 531  :   b = sqrt(1-m);

	fsub	QWORD PTR _m$[ebp]
	call	__CIsqrt
	fstp	QWORD PTR _b$[ebp]

; 532  :   c = sqrt(m);

	fld	QWORD PTR _m$[ebp]
	call	__CIsqrt

; 533  :   poweroftwo = 1.0;

	fld1
	fst	QWORD PTR _poweroftwo$[ebp]

; 534  :   csum = c*c;

	fld	ST(1)
	fmul	ST(0), ST(2)
	fstp	QWORD PTR _csum$[ebp]

; 535  :   csinphisum = 0;

	fldz
	fst	QWORD PTR _csinphisum$[ebp]

; 536  : 
; 537  :   while ( c > machine_eps )

	fld	QWORD PTR _machine_eps
	fcomp	ST(3)
	fnstsw	ax
	fstp	ST(2)
	test	ah, 5
	jp	$LN21@incomplete@3
	fstp	ST(1)
	jmp	SHORT $LN2@incomplete@3
$LL24@incomplete@3:
	fstp	ST(0)
	fld1
$LN2@incomplete@3:

; 538  :   { 
; 539  :     p = 2*p + atan((b/a - 1)*tanp/(1+b/a*tanp*tanp));

	fld	QWORD PTR _b$[ebp]
	fdiv	QWORD PTR _a$[ebp]
	fst	QWORD PTR tv241[ebp]
	fld	ST(0)
	fld	QWORD PTR _tanp$[ebp]
	fmul	ST(1), ST(0)
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fst	QWORD PTR tv246[ebp]
	fxch	ST(2)
	fsub	ST(0), ST(3)
	fmulp	ST(1), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fdivrp	ST(1), ST(0)
	call	__CIatan
	fld	QWORD PTR _p$[ebp]
	fadd	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _p$[ebp]

; 540  :     tanp = (1+b/a)*tanp/(1-b/a*tanp*tanp);

	fld	QWORD PTR tv241[ebp]
	fld1
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR _tanp$[ebp]
	fxch	ST(1)
	fsub	QWORD PTR tv246[ebp]
	fdivp	ST(1), ST(0)
	fstp	QWORD PTR _tanp$[ebp]

; 541  : 
; 542  :     anext = (a+b)/2;
; 543  :     bnext = sqrt(a*b);

	fld	QWORD PTR _b$[ebp]
	fmul	QWORD PTR _a$[ebp]
	call	__CIsqrt

; 544  :     cnext = (a-b)/2;

	fld	QWORD PTR _a$[ebp]
	fld	ST(0)
	fld	QWORD PTR _b$[ebp]
	fsub	ST(1), ST(0)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(2), ST(0)
	fxch	ST(2)
	fst	QWORD PTR _cnext$[ebp]
	fxch	ST(1)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fmulp	ST(1), ST(0)

; 545  :     a = anext; b = bnext; c = cnext;

	fstp	QWORD PTR _a$[ebp]
	fxch	ST(1)
	fstp	QWORD PTR _b$[ebp]

; 546  : 
; 547  :     poweroftwo *= 2;

	fld	QWORD PTR _poweroftwo$[ebp]
	fadd	ST(0), ST(0)
	fst	QWORD PTR _poweroftwo$[ebp]

; 548  :     csum += poweroftwo*c*c;

	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR _csum$[ebp]
	fstp	QWORD PTR _csum$[ebp]

; 549  :     csinphisum += c*sin(p);

	fld	QWORD PTR _p$[ebp]
	call	__CIsin
	fld	QWORD PTR _cnext$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR _csinphisum$[ebp]
	fst	QWORD PTR _csinphisum$[ebp]
	fld	QWORD PTR _machine_eps
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jnp	$LL24@incomplete@3

; 536  : 
; 537  :   while ( c > machine_eps )

	jmp	SHORT $LN1@incomplete@3
$LN21@incomplete@3:
	fstp	ST(0)
$LN1@incomplete@3:

; 550  :   }
; 551  :   K = M_PI/2/a;

	fld	QWORD PTR __real@3ff921fb54442d18
	fld	QWORD PTR _a$[ebp]
	fdiv	ST(1), ST(0)

; 552  :   E = K - csum*K/2;

	fld	ST(1)
	fmul	QWORD PTR _csum$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fsubr	ST(0), ST(2)

; 553  :   F = p/poweroftwo/a;
; 554  :   retval = E/K*F + csinphisum;

	fdivrp	ST(2), ST(0)
	fld	QWORD PTR _p$[ebp]
	fdiv	QWORD PTR _poweroftwo$[ebp]
	fdivrp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)

; 555  : 
; 556  :   return retval;
; 557  : } // end incompleteEllipticE()

	mov	esp, ebp
	pop	ebp
	ret	0
_incompleteEllipticExx ENDP
_TEXT	ENDS
PUBLIC	__real@bfc0000000000000
PUBLIC	_incompleteEllipticEdm
;	COMDAT __real@bfc0000000000000
CONST	SEGMENT
__real@bfc0000000000000 DQ 0bfc0000000000000r	; -0.125
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _incompleteEllipticEdm
_TEXT	SEGMENT
tv163 = -8						; size = 8
_phi$ = 8						; size = 8
tv129 = 16						; size = 8
_m$ = 16						; size = 8
_incompleteEllipticEdm PROC				; COMDAT

; 607  : { if ( m == 0 )

	push	ebp
	mov	ebp, esp
	fld	QWORD PTR _m$[ebp]
	sub	esp, 8
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@incomplete@4
	fstp	ST(0)

; 608  :      return -(2*phi-sin(2*phi))/8;

	fld	QWORD PTR _phi$[ebp]
	fadd	ST(0), ST(0)
	fst	QWORD PTR tv129[ebp]
	call	__CIsin
	fsubr	QWORD PTR tv129[ebp]
	fmul	QWORD PTR __real@bfc0000000000000

; 610  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@incomplete@4:

; 609  :   return (incompleteEllipticE(phi,m)-incompleteEllipticF(phi,m))/2/m;

	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _phi$[ebp]
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticE
	fstp	QWORD PTR tv163[ebp]
	fld	QWORD PTR _m$[ebp]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _phi$[ebp]
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticF
	fsubr	QWORD PTR tv163[ebp]
	add	esp, 16					; 00000010H
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _m$[ebp]

; 610  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_incompleteEllipticEdm ENDP
_TEXT	ENDS
PUBLIC	__real@3fc0000000000000
PUBLIC	_incompleteEllipticFdm
;	COMDAT __real@3fc0000000000000
CONST	SEGMENT
__real@3fc0000000000000 DQ 03fc0000000000000r	; 0.125
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _incompleteEllipticFdm
_TEXT	SEGMENT
tv156 = -32						; size = 8
tv170 = -24						; size = 8
tv158 = -16						; size = 8
tv77 = -16						; size = 8
tv167 = -8						; size = 8
_phi$ = 8						; size = 8
tv161 = 16						; size = 8
_m$ = 16						; size = 8
_incompleteEllipticFdm PROC				; COMDAT

; 614  : { if ( m == 0 )

	push	ebp
	mov	ebp, esp
	fld	QWORD PTR _m$[ebp]
	sub	esp, 32					; 00000020H
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@incomplete@5
	fstp	ST(0)

; 615  :      return (2*phi-sin(2*phi))/8;

	fld	QWORD PTR _phi$[ebp]
	fadd	ST(0), ST(0)
	fst	QWORD PTR tv161[ebp]
	call	__CIsin
	fsubr	QWORD PTR tv161[ebp]
	fmul	QWORD PTR __real@3fc0000000000000

; 619  : } // end incompleteEllipticFdm()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@incomplete@5:

; 616  :   return incompleteEllipticE(phi,m)/2/(m-1)/m
; 617  :           - incompleteEllipticF(phi,m)/2/m
; 618  :               + sin(2*phi)/4/(m-1)/sqrt(1-m*sin(phi)*sin(phi));

	fsub	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR tv167[ebp]
	fld	QWORD PTR _phi$[ebp]
	call	__CIsin
	fstp	QWORD PTR tv170[ebp]
	fld	QWORD PTR _m$[ebp]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _phi$[ebp]
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticE
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR tv167[ebp]
	fld	QWORD PTR _m$[ebp]
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv77[ebp]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _phi$[ebp]
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticF
	fmul	QWORD PTR __real@3fe0000000000000
	add	esp, 16					; 00000010H
	fdiv	QWORD PTR _m$[ebp]
	fsubr	QWORD PTR tv77[ebp]
	fstp	QWORD PTR tv156[ebp]
	fld	QWORD PTR _phi$[ebp]
	fadd	ST(0), ST(0)
	call	__CIsin
	fmul	QWORD PTR __real@3fd0000000000000
	fdiv	QWORD PTR tv167[ebp]
	fstp	QWORD PTR tv158[ebp]
	fld	QWORD PTR tv170[ebp]
	fld	QWORD PTR _m$[ebp]
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fld1
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fdivr	QWORD PTR tv158[ebp]
	fadd	QWORD PTR tv156[ebp]

; 619  : } // end incompleteEllipticFdm()

	mov	esp, ebp
	pop	ebp
	ret	0
_incompleteEllipticFdm ENDP
_TEXT	ENDS
PUBLIC	__real@bfe0000000000000
PUBLIC	__real@bf80000000000000
PUBLIC	__real@4020000000000000
PUBLIC	__real@4028000000000000
PUBLIC	_incompleteEllipticEseconds
EXTRN	__CIcos:PROC
;	COMDAT __real@bfe0000000000000
CONST	SEGMENT
__real@bfe0000000000000 DQ 0bfe0000000000000r	; -0.5
CONST	ENDS
;	COMDAT __real@bf80000000000000
CONST	SEGMENT
__real@bf80000000000000 DQ 0bf80000000000000r	; -0.0078125
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@4028000000000000
CONST	SEGMENT
__real@4028000000000000 DQ 04028000000000000r	; 12
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _incompleteEllipticEseconds
_TEXT	SEGMENT
_s$ = -40						; size = 8
tv193 = -32						; size = 8
tv192 = -24						; size = 8
_E$ = -24						; size = 8
_d$ = -16						; size = 8
_s2$ = -8						; size = 8
_phi$ = 8						; size = 8
_m$ = 16						; size = 8
_dphi$ = 24						; size = 4
_dm$ = 28						; size = 4
_ddphi$ = 32						; size = 4
_ddm$ = 36						; size = 4
_dphidm$ = 40						; size = 4
_incompleteEllipticEseconds PROC			; COMDAT

; 626  : { REAL E,F;

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 627  :   REAL s = sin(phi);

	fld	QWORD PTR _phi$[ebp]
	call	__CIsin
	fst	QWORD PTR tv192[ebp]
	fstp	QWORD PTR _s$[ebp]

; 628  :   REAL s2 = sin(2*phi);

	fld	QWORD PTR _phi$[ebp]
	fadd	ST(0), ST(0)
	fst	QWORD PTR tv193[ebp]
	call	__CIsin
	fstp	QWORD PTR _s2$[ebp]

; 629  :   REAL d = sqrt(1-m*sin(phi)*sin(phi));

	fld	QWORD PTR tv192[ebp]
	fld	QWORD PTR _m$[ebp]
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fld1
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR _d$[ebp]

; 630  :   E = incompleteEllipticE(phi,m);

	fld	QWORD PTR _m$[ebp]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _phi$[ebp]
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticE
	fstp	QWORD PTR _E$[ebp]

; 631  :   F = incompleteEllipticF(phi,m);

	fld	QWORD PTR _m$[ebp]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _phi$[ebp]
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticF

; 632  :   *dphi = d;

	fld	QWORD PTR _d$[ebp]
	mov	eax, DWORD PTR _dphi$[ebp]
	fst	QWORD PTR [eax]
	add	esp, 16					; 00000010H

; 633  :   if ( m == 0 )

	fld	QWORD PTR _m$[ebp]
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@incomplete@6

; 634  :   { *dm = -(2*phi-s2)/8;

	mov	ecx, DWORD PTR _dm$[ebp]
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)
	fld	QWORD PTR tv193[ebp]
	fsub	QWORD PTR _s2$[ebp]
	fmul	QWORD PTR __real@bfc0000000000000
	fstp	QWORD PTR [ecx]

; 635  :     *ddm = -1./128*(12*phi-8*s2+sin(4*phi));

	fld	QWORD PTR _phi$[ebp]
	fmul	QWORD PTR __real@4010000000000000
	call	__CIsin
	fld	QWORD PTR _phi$[ebp]
	fmul	QWORD PTR __real@4028000000000000
	mov	edx, DWORD PTR _ddm$[ebp]
	fld	QWORD PTR _s2$[ebp]
	fmul	QWORD PTR __real@4020000000000000
	fsubp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fmul	QWORD PTR __real@bf80000000000000
	fstp	QWORD PTR [edx]

; 636  :   }
; 637  :   else

	jmp	SHORT $LN1@incomplete@6
$LN2@incomplete@6:

; 638  :   { *dm   = (E - F)/2/m;

	fld	QWORD PTR _E$[ebp]
	mov	eax, DWORD PTR _dm$[ebp]
	fld	ST(0)

; 639  :     *ddm =  -1./8/(m-1)/m/m*(2*(m-2)*E - 4*(m-1)*F + m*s2/d);

	mov	ecx, DWORD PTR _ddm$[ebp]
	fsub	ST(0), ST(4)
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [eax]
	fld	ST(1)
	fsub	QWORD PTR __real@3ff0000000000000
	fld	ST(2)
	fld	QWORD PTR __real@4000000000000000
	fsub	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	fld	QWORD PTR __real@4010000000000000
	fmul	ST(0), ST(1)
	fmulp	ST(5), ST(0)
	fxch	ST(1)
	fsubrp	ST(4), ST(0)
	fld	QWORD PTR _s2$[ebp]
	fmul	ST(0), ST(2)
	fdivrp	ST(3), ST(0)
	fxch	ST(3)
	faddp	ST(2), ST(0)
	fld	QWORD PTR __real@bfc0000000000000
	fdivrp	ST(3), ST(0)
	fdiv	ST(2), ST(0)
	fdivp	ST(2), ST(0)
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR [ecx]
$LN1@incomplete@6:

; 640  :           
; 641  :   }
; 642  :   *ddphi = -m*cos(phi)*s/d;

	fld	QWORD PTR _phi$[ebp]
	call	__CIcos
	fmul	QWORD PTR _m$[ebp]
	fld	QWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _ddphi$[ebp]

; 643  :   *dphidm = -s*s/2/d;

	mov	eax, DWORD PTR _dphidm$[ebp]
	fmul	ST(1), ST(0)
	fld	QWORD PTR _d$[ebp]
	fdiv	ST(2), ST(0)
	fxch	ST(2)
	fchs
	fstp	QWORD PTR [edx]
	fmul	ST(0), ST(0)
	fmul	QWORD PTR __real@bfe0000000000000
	fdivrp	ST(1), ST(0)
	fstp	QWORD PTR [eax]

; 644  :   return E;

	fld	QWORD PTR _E$[ebp]

; 645  : } // end incompleteEllipticEseconds()

	mov	esp, ebp
	pop	ebp
	ret	0
_incompleteEllipticEseconds ENDP
_TEXT	ENDS
PUBLIC	__real@3f98000000000000
PUBLIC	_incompleteEllipticFseconds
;	COMDAT __real@3f98000000000000
CONST	SEGMENT
__real@3f98000000000000 DQ 03f98000000000000r	; 0.0234375
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _incompleteEllipticFseconds
_TEXT	SEGMENT
_F$ = -72						; size = 8
tv280 = -64						; size = 8
tv286 = -56						; size = 8
tv284 = -48						; size = 8
tv258 = -48						; size = 8
tv283 = -40						; size = 8
tv257 = -40						; size = 8
tv256 = -32						; size = 8
_d$ = -32						; size = 8
_s$ = -24						; size = 8
_E$ = -16						; size = 8
_s2$ = -8						; size = 8
_phi$ = 8						; size = 8
_m$ = 16						; size = 8
_dphi$ = 24						; size = 4
_dm$ = 28						; size = 4
_ddphi$ = 32						; size = 4
_ddm$ = 36						; size = 4
_dphidm$ = 40						; size = 4
_incompleteEllipticFseconds PROC			; COMDAT

; 652  : { REAL E,F;

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 653  :   REAL s = sin(phi);

	fld	QWORD PTR _phi$[ebp]
	call	__CIsin
	fst	QWORD PTR tv256[ebp]
	fstp	QWORD PTR _s$[ebp]

; 654  :   REAL s2 = sin(2*phi);

	fld	QWORD PTR _phi$[ebp]
	fadd	ST(0), ST(0)
	fst	QWORD PTR tv257[ebp]
	call	__CIsin
	fst	QWORD PTR tv258[ebp]
	fstp	QWORD PTR _s2$[ebp]

; 655  :   REAL d = sqrt(1-m*sin(phi)*sin(phi));

	fld	QWORD PTR tv256[ebp]
	fld	QWORD PTR _m$[ebp]
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fld1
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR _d$[ebp]

; 656  :   E = incompleteEllipticE(phi,m);

	fld	QWORD PTR _m$[ebp]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _phi$[ebp]
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticE
	fstp	QWORD PTR _E$[ebp]

; 657  :   F = incompleteEllipticF(phi,m);

	fld	QWORD PTR _m$[ebp]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _phi$[ebp]
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticF
	fst	QWORD PTR _F$[ebp]

; 658  :   *dphi = 1/d;

	mov	eax, DWORD PTR _dphi$[ebp]
	fld1
	add	esp, 16					; 00000010H
	fld	ST(0)
	fld	QWORD PTR _d$[ebp]
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [eax]

; 659  :   if ( m == 0 )

	fld	QWORD PTR _m$[ebp]
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	fld	QWORD PTR __real@3fe0000000000000
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@incomplete@7
	fstp	ST(1)

; 660  :   { *dm = (2*phi-s2)/8;

	mov	ecx, DWORD PTR _dm$[ebp]
	fstp	ST(2)

; 661  :     *ddm = 3./128*(12*phi-8*s2+sin(2*phi));

	mov	edx, DWORD PTR _ddm$[ebp]
	fstp	ST(0)
	fstp	ST(1)
	fstp	ST(0)
	fld	QWORD PTR tv257[ebp]
	fld	QWORD PTR _s2$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3fc0000000000000
	fstp	QWORD PTR [ecx]
	fld	QWORD PTR _phi$[ebp]
	fmul	QWORD PTR __real@4028000000000000
	fxch	ST(1)
	fmul	QWORD PTR __real@4020000000000000
	fsubp	ST(1), ST(0)
	fadd	QWORD PTR tv258[ebp]
	fmul	QWORD PTR __real@3f98000000000000
	fstp	QWORD PTR [edx]

; 662  :   }
; 663  :   else

	jmp	$LN1@incomplete@7
$LN2@incomplete@7:

; 664  :   { *dm   = -E/2/(m-1)/m - F/2/m + s2/4/(m-1)/d;

	fld	ST(1)
	mov	eax, DWORD PTR _dm$[ebp]
	fsubrp	ST(4), ST(0)

; 665  :     *ddm = E/2/(m-1)/m/m + E/2/(m-1)/(m-1)/m
; 666  :           - (E-F)/4/(m-1)/m/m + F/2/m/m + s*s*s2/8/(m-1)/d/d/d
; 667  :           - s2/4/(m-1)/(m-1)/d + E/4/(m-1)/m/m
; 668  :           + F/4/m/m - s2/8/m/(m-1)/d;

	mov	ecx, DWORD PTR _ddm$[ebp]
	fld	QWORD PTR _s2$[ebp]
	fld	QWORD PTR __real@3fd0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(5)
	fst	QWORD PTR tv280[ebp]
	fld	QWORD PTR _E$[ebp]
	fmul	ST(0), ST(3)
	fdiv	ST(0), ST(6)
	fst	QWORD PTR tv283[ebp]
	fdiv	ST(0), ST(4)
	fstp	QWORD PTR tv284[ebp]
	fld	ST(6)
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	fdiv	ST(0), ST(3)
	fst	QWORD PTR tv286[ebp]
	fxch	ST(2)
	fdiv	ST(0), ST(4)
	fld	QWORD PTR tv284[ebp]
	fadd	ST(3), ST(0)
	fxch	ST(1)
	fsubrp	ST(3), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR [eax]
	fld	QWORD PTR tv283[ebp]
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(3)
	fxch	ST(2)
	fdiv	ST(0), ST(3)
	faddp	ST(2), ST(0)
	fld	QWORD PTR _E$[ebp]
	fsub	ST(0), ST(6)
	fmul	ST(0), ST(1)
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(3)
	fsubp	ST(2), ST(0)
	fld	QWORD PTR tv286[ebp]
	fdiv	ST(0), ST(3)
	faddp	ST(2), ST(0)
	fld	QWORD PTR _s$[ebp]
	fmul	ST(0), ST(0)
	fmul	QWORD PTR _s2$[ebp]
	fld	QWORD PTR __real@3fc0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(6)
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(5)
	faddp	ST(3), ST(0)
	fld	QWORD PTR tv280[ebp]
	fdiv	ST(0), ST(6)
	fdiv	ST(0), ST(5)
	fsubp	ST(3), ST(0)
	fld	QWORD PTR _E$[ebp]
	fmul	ST(0), ST(2)
	fdiv	ST(0), ST(6)
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	faddp	ST(3), ST(0)
	fxch	ST(6)
	fmulp	ST(1), ST(0)
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _s2$[ebp]
	fmulp	ST(5), ST(0)
	fxch	ST(4)
	fdivrp	ST(1), ST(0)
	fdivrp	ST(2), ST(0)
	fdivp	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ecx]
$LN1@incomplete@7:

; 669  :   }
; 670  :   *ddphi = m*cos(phi)*s/d/d/d;

	fld	QWORD PTR _phi$[ebp]
	call	__CIcos
	fmul	QWORD PTR _m$[ebp]
	fld	QWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _ddphi$[ebp]

; 671  :   *dphidm = s*s/2/d/d/d;

	mov	eax, DWORD PTR _dphidm$[ebp]
	fmul	ST(1), ST(0)
	fld	QWORD PTR _d$[ebp]
	fdiv	ST(2), ST(0)
	fdiv	ST(2), ST(0)
	fdiv	ST(2), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR [edx]
	fmul	ST(0), ST(0)
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	ST(0), ST(1)
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)
	fstp	QWORD PTR [eax]

; 672  :   return F;

	fld	QWORD PTR _F$[ebp]

; 673  : } // end incompleteEllipticFseconds(

	mov	esp, ebp
	pop	ebp
	ret	0
_incompleteEllipticFseconds ENDP
_TEXT	ENDS
END
