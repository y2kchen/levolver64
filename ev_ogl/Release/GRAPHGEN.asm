; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\GRAPHGEN.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_unset_attr
; Function compile flags: /Ogtp
;	COMDAT _unset_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_unset_attr PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 29   :   elptr(id)->attr &= ~attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	not	ecx
	and	DWORD PTR [eax+8], ecx
	not	edx
	and	DWORD PTR [eax+12], edx

; 30   : }

	pop	ebp
	ret	0
_unset_attr ENDP
_TEXT	ENDS
PUBLIC	_get_fe_edge
; Function compile flags: /Ogtp
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _get_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_facet PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp

; 84   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 85   :     return inverse_id(feptr(fe_id)->nextfacet[1]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]
	xor	eax, 134217728				; 08000000H

; 88   : }

	pop	ebp
	ret	0
$LN2@get_prev_f:

; 86   :   else 
; 87   :     return feptr(fe_id)->nextfacet[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]

; 88   : }

	pop	ebp
	ret	0
_get_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_get_edge_wrap
EXTRN	_sym_inverse:DWORD
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_wrap PROC					; COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  :   WRAPTYPE wrap = *EINT(e_id,E_WRAP_ATTR) ;

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+784]
	mov	eax, DWORD PTR [eax+edx]
	pop	esi

; 165  :   return    ( inverted(e_id) ? (*sym_inverse)(wrap) : wrap );

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN4@get_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@get_edge_w:

; 166  : }

	pop	ebp
	ret	0
_get_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_@2
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_@2:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_@2
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_@2:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_extra
; Function compile flags: /Ogtp
;	COMDAT _get_extra
_TEXT	SEGMENT
_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_extra PROC						; COMDAT

; 348  : { int type = id_type(id);

	push	ebp
	mov	ebp, esp

; 349  : 
; 350  :   return ( (char*)elptr(id) + EXTRAS(type)[n].offset);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	shr	eax, 29					; 0000001dH
	imul	esi, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, esi
	add	eax, DWORD PTR [edi+ecx+64]
	pop	edi
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_get_extra ENDP
_TEXT	ENDS
PUBLIC	__real@406fe00000000000
PUBLIC	__real@c06fe00000000000
PUBLIC	_INDEX_TO_RGBA
EXTRN	_rgb_colors:BYTE
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@406fe00000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\graphgen.c
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@c06fe00000000000
CONST	SEGMENT
__real@c06fe00000000000 DQ 0c06fe00000000000r	; -255
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _INDEX_TO_RGBA
_TEXT	SEGMENT
_c$ = 8							; size = 4
_INDEX_TO_RGBA PROC					; COMDAT

; 33   : { return 

	push	ebp
	mov	ebp, esp
	push	esi

; 34   :     ((int)(rgb_colors[c][0]*255)<<24) +
; 35   :     ((int)(rgb_colors[c][1]*255)<<16) +
; 36   :     ((int)(rgb_colors[c][2]*255)<<8)  +
; 37   :     ((int)(rgb_colors[c][3]*255));

	mov	esi, DWORD PTR _c$[ebp]
	shl	esi, 5
	fld	QWORD PTR _rgb_colors[esi]
	push	edi
	fld	QWORD PTR __real@c06fe00000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	call	__ftol2_sse
	fld	QWORD PTR _rgb_colors[esi+8]
	mov	edi, eax
	fmul	ST(0), ST(1)
	shl	edi, 8
	call	__ftol2_sse
	fmul	QWORD PTR _rgb_colors[esi+16]
	add	edi, eax
	shl	edi, 8
	call	__ftol2_sse
	fld	QWORD PTR _rgb_colors[esi+24]
	fmul	QWORD PTR __real@406fe00000000000
	add	edi, eax
	shl	edi, 8
	call	__ftol2_sse
	sub	eax, edi
	pop	edi
	pop	esi

; 38   : } // end INDEX_TO_RGBA()

	pop	ebp
	ret	0
_INDEX_TO_RGBA ENDP
_TEXT	ENDS
PUBLIC	_get_edge_color_2
EXTRN	_edge_alpha_flag:DWORD
EXTRN	_edge_rgb_color_attr:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_color_2
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_color_2 PROC					; COMDAT

; 42   : { if ( edge_rgb_color_attr > 0 )

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _edge_rgb_color_attr
	test	edx, edx
	jle	$LN2@get_edge_c

; 43   :   { REAL *c = (REAL*)get_extra(e_id,edge_rgb_color_attr);

	mov	ecx, DWORD PTR _e_id$[ebp]
	imul	edx, 240				; 000000f0H
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	push	ebx
	push	esi
	mov	esi, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, edx
	add	esi, DWORD PTR [eax+ecx+64]

; 44   :     return 
; 45   :     ((int)(c[0]*255)<<24) +
; 46   :     ((int)(c[1]*255)<<16) +
; 47   :     ((int)(c[2]*255)<<8)  +
; 48   :     (edge_alpha_flag ? ((int)(c[3]*255)) : 255);

	cmp	DWORD PTR _edge_alpha_flag, 0
	push	edi
	je	SHORT $LN5@get_edge_c
	fld	QWORD PTR [esi+24]
	fmul	QWORD PTR __real@406fe00000000000
	call	__ftol2_sse
	mov	edi, eax
	jmp	SHORT $LN6@get_edge_c
$LN5@get_edge_c:
	mov	edi, 255				; 000000ffH
$LN6@get_edge_c:
	fld	QWORD PTR [esi]
	fld	QWORD PTR __real@c06fe00000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	call	__ftol2_sse
	fld	QWORD PTR [esi+8]
	mov	ebx, eax
	fmul	ST(0), ST(1)
	shl	ebx, 8
	call	__ftol2_sse
	fmul	QWORD PTR [esi+16]
	add	ebx, eax
	shl	ebx, 8
	call	__ftol2_sse
	add	ebx, eax
	mov	eax, edi
	pop	edi
	shl	ebx, 8
	pop	esi
	sub	eax, ebx
	pop	ebx

; 51   : } // end get_edge_color_2()

	pop	ebp
	ret	0
$LN2@get_edge_c:

; 49   :   } 
; 50   :   else return get_edge_color(e_id);

	mov	edx, DWORD PTR _e_id$[ebp]
	mov	eax, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	movsx	eax, WORD PTR [ecx+56]

; 51   : } // end get_edge_color_2()

	pop	ebp
	ret	0
_get_edge_color_2 ENDP
_TEXT	ENDS
PUBLIC	_get_facet_frontcolor_2
EXTRN	_facet_alpha_flag:DWORD
EXTRN	_facet_rgb_color_attr:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_facet_frontcolor_2
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_frontcolor_2 PROC				; COMDAT

; 55   : { if ( facet_rgb_color_attr > 0 )

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _facet_rgb_color_attr
	test	edx, edx
	jle	$LN2@get_facet_@3

; 56   :   { REAL *c = (REAL*)get_extra(f_id,facet_rgb_color_attr);

	mov	ecx, DWORD PTR _f_id$[ebp]
	imul	edx, 240				; 000000f0H
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	push	ebx
	push	esi
	mov	esi, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, edx
	add	esi, DWORD PTR [eax+ecx+64]

; 57   :     return 
; 58   :     ((int)(c[0]*255)<<24) +
; 59   :     ((int)(c[1]*255)<<16) +
; 60   :     ((int)(c[2]*255)<<8)  +
; 61   :     (facet_alpha_flag ? ((int)(c[3]*255)) : 255 );

	cmp	DWORD PTR _facet_alpha_flag, 0
	push	edi
	je	SHORT $LN5@get_facet_@3
	fld	QWORD PTR [esi+24]
	fmul	QWORD PTR __real@406fe00000000000
	call	__ftol2_sse
	mov	edi, eax
	jmp	SHORT $LN6@get_facet_@3
$LN5@get_facet_@3:
	mov	edi, 255				; 000000ffH
$LN6@get_facet_@3:
	fld	QWORD PTR [esi]
	fld	QWORD PTR __real@c06fe00000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	call	__ftol2_sse
	fld	QWORD PTR [esi+8]
	mov	ebx, eax
	fmul	ST(0), ST(1)
	shl	ebx, 8
	call	__ftol2_sse
	fmul	QWORD PTR [esi+16]
	add	ebx, eax
	shl	ebx, 8
	call	__ftol2_sse
	add	ebx, eax
	mov	eax, edi
	pop	edi
	shl	ebx, 8
	pop	esi
	sub	eax, ebx
	pop	ebx

; 64   : } // end get_facet_frontcolor_2()

	pop	ebp
	ret	0
$LN2@get_facet_@3:

; 62   :   } 
; 63   :   else return get_facet_frontcolor(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN7@get_facet_@3
	mov	edx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	movsx	eax, WORD PTR [eax+50]

; 64   : } // end get_facet_frontcolor_2()

	pop	ebp
	ret	0
$LN7@get_facet_@3:

; 62   :   } 
; 63   :   else return get_facet_frontcolor(f_id);

	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	movsx	eax, WORD PTR [edx+48]

; 64   : } // end get_facet_frontcolor_2()

	pop	ebp
	ret	0
_get_facet_frontcolor_2 ENDP
_TEXT	ENDS
PUBLIC	_get_facet_color_2
; Function compile flags: /Ogtp
;	COMDAT _get_facet_color_2
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_color_2 PROC					; COMDAT

; 68   : { return get_facet_frontcolor_2(f_id);

	push	ebp
	mov	ebp, esp

; 69   : } // end get_facet_color_2()

	pop	ebp

; 68   : { return get_facet_frontcolor_2(f_id);

	jmp	_get_facet_frontcolor_2
_get_facet_color_2 ENDP
_TEXT	ENDS
PUBLIC	_get_facet_backcolor_2
EXTRN	_facetback_alpha_flag:DWORD
EXTRN	_facet_rgb_backcolor_attr:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_facet_backcolor_2
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_backcolor_2 PROC				; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :   if ( facet_rgb_color_attr > 0 )

	cmp	DWORD PTR _facet_rgb_color_attr, 0
	jle	$LN4@get_facet_@4

; 75   :   {
; 76   :     if ( facet_rgb_backcolor_attr > 0 )

	mov	edx, DWORD PTR _facet_rgb_backcolor_attr
	test	edx, edx
	jle	$LN3@get_facet_@4

; 77   :     { REAL *c = (REAL*)get_extra(f_id,facet_rgb_backcolor_attr);

	mov	ecx, DWORD PTR _f_id$[ebp]
	imul	edx, 240				; 000000f0H
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	push	ebx
	push	esi
	mov	esi, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, edx
	add	esi, DWORD PTR [eax+ecx+64]

; 78   :       return 
; 79   :       ((int)(c[0]*255)<<24) +
; 80   :       ((int)(c[1]*255)<<16) +
; 81   :       ((int)(c[2]*255)<<8)  +
; 82   :       (facetback_alpha_flag ? ((int)(c[3]*255)) : 255);

	cmp	DWORD PTR _facetback_alpha_flag, 0
	push	edi
	je	SHORT $LN7@get_facet_@4
	fld	QWORD PTR [esi+24]
	fmul	QWORD PTR __real@406fe00000000000
	call	__ftol2_sse
	mov	edi, eax
	jmp	SHORT $LN8@get_facet_@4
$LN7@get_facet_@4:
	mov	edi, 255				; 000000ffH
$LN8@get_facet_@4:
	fld	QWORD PTR [esi]
	fld	QWORD PTR __real@c06fe00000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	call	__ftol2_sse
	fld	QWORD PTR [esi+8]
	mov	ebx, eax
	fmul	ST(0), ST(1)
	shl	ebx, 8
	call	__ftol2_sse
	fmul	QWORD PTR [esi+16]
	add	ebx, eax
	shl	ebx, 8
	call	__ftol2_sse
	add	ebx, eax
	mov	eax, edi
	pop	edi
	shl	ebx, 8
	pop	esi
	sub	eax, ebx
	pop	ebx

; 87   : } // end get_facet_backcolor_2()

	pop	ebp
	ret	0
$LN3@get_facet_@4:

; 83   :     } 
; 84   :     else return INDEX_TO_RGBA(get_facet_backcolor(f_id));

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN9@get_facet_@4
	mov	edx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	movsx	eax, WORD PTR [eax+48]
	push	eax
	call	_INDEX_TO_RGBA
	add	esp, 4

; 87   : } // end get_facet_backcolor_2()

	pop	ebp
	ret	0
$LN9@get_facet_@4:

; 83   :     } 
; 84   :     else return INDEX_TO_RGBA(get_facet_backcolor(f_id));

	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	movsx	eax, WORD PTR [edx+50]
	push	eax
	call	_INDEX_TO_RGBA
	add	esp, 4

; 87   : } // end get_facet_backcolor_2()

	pop	ebp
	ret	0
$LN4@get_facet_@4:

; 85   :   }
; 86   :   else return get_facet_backcolor(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN11@get_facet_@4
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	movsx	eax, WORD PTR [edx+48]

; 87   : } // end get_facet_backcolor_2()

	pop	ebp
	ret	0
$LN11@get_facet_@4:

; 85   :   }
; 86   :   else return get_facet_backcolor(f_id);

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	movsx	eax, WORD PTR [edx+50]

; 87   : } // end get_facet_backcolor_2()

	pop	ebp
	ret	0
_get_facet_backcolor_2 ENDP
_TEXT	ENDS
PUBLIC	__real@3e112e0be826d695
PUBLIC	_torus_edge_clip
PUBLIC	_graph_edge_transforms
PUBLIC	__real@c000000000000000
PUBLIC	__real@4010000000000000
PUBLIC	__real@3ddb7cdfd9d7bdbb
PUBLIC	__real@401921fb54442d18
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@40af400000000000
PUBLIC	_m$GSCopy$
PUBLIC	_gdata$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_torus_arc_clip
EXTRN	_dot:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIcos:PROC
EXTRN	__CIsin:PROC
EXTRN	__CIatan2:PROC
EXTRN	__CIsqrt:PROC
EXTRN	_floor:PROC
;	COMDAT __real@3e112e0be826d695
CONST	SEGMENT
__real@3e112e0be826d695 DQ 03e112e0be826d695r	; 1e-009
CONST	ENDS
;	COMDAT __real@c000000000000000
CONST	SEGMENT
__real@c000000000000000 DQ 0c000000000000000r	; -2
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@3ddb7cdfd9d7bdbb
CONST	SEGMENT
__real@3ddb7cdfd9d7bdbb DQ 03ddb7cdfd9d7bdbbr	; 1e-010
CONST	ENDS
;	COMDAT __real@401921fb54442d18
CONST	SEGMENT
__real@401921fb54442d18 DQ 0401921fb54442d18r	; 6.28319
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@40af400000000000
CONST	SEGMENT
__real@40af400000000000 DQ 040af400000000000r	; 4000
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _torus_arc_clip
_TEXT	SEGMENT
tv4170 = -1100						; size = 8
_x0$ = -1092						; size = 8
tv4147 = -1088						; size = 4
_angle2$ = -1084					; size = 8
_det$ = -1084						; size = 8
_angle1$ = -1076					; size = 8
_m$GSCopy$ = -1068					; size = 4
_x2$ = -1064						; size = 8
_c$ = -1064						; size = 8
_y2$ = -1056						; size = 8
_a$ = -1056						; size = 8
_y1$ = -1048						; size = 8
_v$ = -1048						; size = 8
_per$ = -1040						; size = 4
tv4311 = -1036						; size = 8
tv4248 = -1036						; size = 8
_u$ = -1036						; size = 8
_center$ = -1028					; size = 16
tv9453 = -1012						; size = 8
tv4321 = -1012						; size = 8
tv4238 = -1012						; size = 8
_theta2$ = -1012					; size = 8
_b$ = -1012						; size = 8
_mag1$ = -1012						; size = 8
_radius$ = -1004					; size = 8
_theta1$ = -996						; size = 8
_y0$ = -996						; size = 8
tv10031 = -992						; size = 4
tv10021 = -992						; size = 4
tv9068 = -992						; size = 4
tv8524 = -992						; size = 4
tv7948 = -992						; size = 4
tv6544 = -992						; size = 4
tv6224 = -992						; size = 4
tv5904 = -992						; size = 4
tv5439 = -992						; size = 4
_x1$ = -988						; size = 8
tv9052 = -984						; size = 4
tv8476 = -984						; size = 4
tv7900 = -984						; size = 4
tv6528 = -984						; size = 4
tv6208 = -984						; size = 4
tv5888 = -984						; size = 4
_invper$ = -984						; size = 4
_gdata$GSCopy$ = -980					; size = 4
_gdata2$ = -976						; size = 432
_gdata1$ = -544						; size = 432
_w2$ = -112						; size = 48
_w1$ = -64						; size = 48
_wrap$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_gdata$ = 8						; size = 4
_m$ = 12						; size = 4
_torus_arc_clip PROC					; COMDAT

; 1643 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1100				; 0000044cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1644 :   struct graphdata gdata1[3];  /* for possible subdivided edge */
; 1645 :   struct graphdata gdata2[3];  /* for possible subdivided edge */
; 1646 :   int i,j;
; 1647 :   REAL a,b,c,h,k,u,v,x0,x1,x2,y0,y1,y2,t1,t2,discr;
; 1648 :   int wrap[3];
; 1649 :   REAL **per;
; 1650 :   REAL **invper;
; 1651 :   REAL w1[MAXCOORD],w2[MAXCOORD],mag1,mag2,w1w2,center[2],radius;
; 1652 :   REAL angle1,angle2,det,theta1,theta2;
; 1653 : 
; 1654 :   if ( web.torus_display_period )

	mov	ecx, DWORD PTR _web+1620
	mov	eax, DWORD PTR _gdata$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _m$[ebp]
	push	esi
	push	edi

; 1953 :   
; 1954 :           for ( i = 0 ; i < 3 ; i++ )

	mov	DWORD PTR _gdata$GSCopy$[ebp], eax
	mov	DWORD PTR _m$GSCopy$[ebp], ebx
	test	ecx, ecx
	je	SHORT $LN113@torus_arc_

; 1655 :   { per = web.torus_display_period;
; 1656 :     invper = web.inverse_display_periods;

	mov	DWORD PTR _per$[ebp], ecx
	mov	ecx, DWORD PTR _web+1672

; 1657 :   }
; 1658 :   else

	jmp	SHORT $LN298@torus_arc_
$LN113@torus_arc_:

; 1659 :   { per = web.torus_period;

	mov	edx, DWORD PTR _web+1608

; 1660 :     invper = web.inverse_periods;

	mov	ecx, DWORD PTR _web+1612
	mov	DWORD PTR _per$[ebp], edx
$LN298@torus_arc_:
	mov	DWORD PTR _invper$[ebp], ecx

; 1661 :   }
; 1662 : 
; 1663 :   for ( i = 0 ; i < 3 ; i++ )
; 1664 :     gdata1[i] = gdata2[i] = gdata[i]; /* flags and stuff */

	mov	ecx, 36					; 00000024H
	mov	esi, eax
	lea	edi, DWORD PTR _gdata2$[ebp]
	rep movsd
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	lea	edi, DWORD PTR _gdata1$[ebp]
	rep movsd
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR [eax+144]
	lea	edi, DWORD PTR _gdata2$[ebp+144]
	rep movsd
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR [eax+144]
	lea	edi, DWORD PTR _gdata1$[ebp+144]
	rep movsd
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR [eax+288]
	lea	edi, DWORD PTR _gdata2$[ebp+288]
	rep movsd
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR [eax+288]
	lea	edi, DWORD PTR _gdata1$[ebp+288]
	rep movsd
	add	ebx, ebx

; 1665 : 
; 1666 :   /* see where vertices are relative to cell in this coordinate */
; 1667 :   for ( i = 0 ; i < 3 ; i++ )

	xor	esi, esi
	add	ebx, ebx
	mov	edi, eax
	npad	6
$LL108@torus_arc_:

; 1668 :      wrap[i] = (int)floor(SDIM_dot(invper[m],gdata[i].x));

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _invper$[ebp]
	mov	ecx, DWORD PTR [ebx+eax]
	push	edx
	push	edi
	push	ecx
	call	_dot
	fstp	QWORD PTR [esp+4]
	add	esp, 4
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _wrap$[ebp+esi*4], eax
	inc	esi
	add	edi, 144				; 00000090H
	cmp	esi, 3
	jl	SHORT $LL108@torus_arc_

; 1669 : 
; 1670 :   /* solve for geometric parameters */
; 1671 :   for (i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR _web+616
	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	xor	ecx, ecx
	cmp	edi, 4
	jl	$LC177@torus_arc_
	lea	edx, DWORD PTR [edi-3]
	lea	eax, DWORD PTR [esi+288]
	npad	5
$LL178@torus_arc_:

; 1672 :   { w1[i] = gdata[1].x[i] - gdata[0].x[i];

	fld	QWORD PTR [eax-144]

; 1673 :     w2[i] = gdata[2].x[i] - gdata[0].x[i];

	add	ecx, 4
	fsub	QWORD PTR [eax-288]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR _w1$[ebp+ecx*8-32]
	fld	QWORD PTR [eax-32]
	fsub	QWORD PTR [eax-320]
	fstp	QWORD PTR _w2$[ebp+ecx*8-32]
	fld	QWORD PTR [eax-168]
	fsub	QWORD PTR [eax-312]
	fstp	QWORD PTR _w1$[ebp+ecx*8-24]
	fld	QWORD PTR [eax-24]
	fsub	QWORD PTR [eax-312]
	fstp	QWORD PTR _w2$[ebp+ecx*8-24]
	fld	QWORD PTR [eax-160]
	fsub	QWORD PTR [eax-304]
	fstp	QWORD PTR _w1$[ebp+ecx*8-16]
	fld	QWORD PTR [eax-16]
	fsub	QWORD PTR [eax-304]
	fstp	QWORD PTR _w2$[ebp+ecx*8-16]
	fld	QWORD PTR [eax-152]
	fsub	QWORD PTR [eax-296]
	fstp	QWORD PTR _w1$[ebp+ecx*8-8]
	fld	QWORD PTR [eax-8]
	fsub	QWORD PTR [eax-296]
	fstp	QWORD PTR _w2$[ebp+ecx*8-8]
	cmp	ecx, edx
	jl	$LL178@torus_arc_
$LC177@torus_arc_:

; 1669 : 
; 1670 :   /* solve for geometric parameters */
; 1671 :   for (i = 0 ; i < SDIM ; i++ )

	cmp	ecx, edi
	jge	SHORT $LN211@torus_arc_
	lea	edx, DWORD PTR _w2$[ebp]
	sub	edx, esi
	mov	DWORD PTR tv5439[ebp], edx
	mov	edx, DWORD PTR _web+616
	lea	edi, DWORD PTR _w1$[ebp]
	sub	edi, esi
	lea	eax, DWORD PTR [esi+ecx*8]
	sub	edx, ecx
	mov	ecx, DWORD PTR tv5439[ebp]
	npad	3
$LC105@torus_arc_:

; 1672 :   { w1[i] = gdata[1].x[i] - gdata[0].x[i];

	fld	QWORD PTR [eax+144]
	add	eax, 8
	dec	edx
	fsub	QWORD PTR [eax-8]
	fstp	QWORD PTR [edi+eax-8]

; 1673 :     w2[i] = gdata[2].x[i] - gdata[0].x[i];

	fld	QWORD PTR [eax+280]
	fsub	QWORD PTR [eax-8]
	fstp	QWORD PTR [ecx+eax-8]
	jne	SHORT $LC105@torus_arc_

; 1669 : 
; 1670 :   /* solve for geometric parameters */
; 1671 :   for (i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR _web+616
$LN211@torus_arc_:

; 1674 :   }
; 1675 :   det = w1[0]*w2[1] - w1[1]*w2[0];

	fld	QWORD PTR _w2$[ebp+8]

; 1676 :   mag1 = SDIM_dot(w1,w1); mag2 = SDIM_dot(w2,w2);

	lea	edx, DWORD PTR _w1$[ebp]
	fmul	QWORD PTR _w1$[ebp]
	push	edi
	fld	QWORD PTR _w2$[ebp]
	push	edx
	fmul	QWORD PTR _w1$[ebp+8]
	mov	eax, edx
	push	eax
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _det$[ebp]
	call	_dot
	mov	ecx, DWORD PTR _web+616
	fstp	QWORD PTR _mag1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _w2$[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot

; 1677 :   w1w2 = w1[0]*w2[0] + w1[1]*w2[1];

	fld	QWORD PTR _w1$[ebp+8]
	fld	ST(0)
	add	esp, 24					; 00000018H
	fld	QWORD PTR _w2$[ebp+8]
	fmul	ST(1), ST(0)
	fld	QWORD PTR _w2$[ebp]
	fld	QWORD PTR _w1$[ebp]
	fmul	ST(0), ST(1)
	faddp	ST(3), ST(0)

; 1678 :   if ( 4000*det*det < mag1*mag1*mag2 + mag1*mag2*mag2 - 2*mag1*w1w2*mag2 )

	fld	ST(4)
	fld	QWORD PTR _mag1$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(6)
	fld	ST(1)
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(7)
	faddp	ST(1), ST(0)
	fld	ST(1)
	fadd	ST(0), ST(0)
	fmulp	ST(5), ST(0)
	fxch	ST(4)
	fmul	ST(0), ST(6)
	fsubp	ST(4), ST(0)
	fld	QWORD PTR _det$[ebp]
	fld	QWORD PTR __real@40af400000000000
	fmul	ST(0), ST(1)
	fmul	ST(0), ST(1)
	fcomp	ST(5)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN102@torus_arc_
	fstp	ST(0)

; 1679 :   { /* practically straight line */
; 1680 :     for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	fstp	ST(0)
	fstp	ST(4)
	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN99@torus_arc_
	lea	eax, DWORD PTR [esi+144]
$LL101@torus_arc_:

; 1681 :       gdata[1].x[i] = gdata[2].x[i];

	fld	QWORD PTR [eax+144]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL101@torus_arc_
$LN99@torus_arc_:

; 1682 :     gdata[0].flags &= ~EDGE_ARC;
; 1683 :     torus_edge_clip(gdata,m);

	mov	ecx, DWORD PTR _m$GSCopy$[ebp]
	and	DWORD PTR [esi+136], -32769		; ffff7fffH
	push	ecx
	push	esi

; 1684 :     return;

	jmp	$LN299@torus_arc_
$LN102@torus_arc_:

; 1685 :   }
; 1686 :   /* circle */
; 1687 :   center[0] = gdata[0].x[0] + 0.5*(w2[1]*mag1 - w1[1]*mag2)/det;

	fld	ST(1)
	fmulp	ST(4), ST(0)
	fld	ST(6)
	fmulp	ST(6), ST(0)
	fxch	ST(3)
	fsubrp	ST(5), ST(0)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(5), ST(0)
	fxch	ST(5)
	fdiv	ST(0), ST(3)
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR _center$[ebp]

; 1688 :   center[1] = gdata[0].x[1] + 0.5*(-w2[0]*mag1 + w1[0]*mag2)/det;

	fxch	ST(5)
	fmul	QWORD PTR _w1$[ebp]
	fxch	ST(5)
	fmulp	ST(1), ST(0)
	fsubp	ST(4), ST(0)
	fxch	ST(3)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(2)
	fadd	QWORD PTR [esi+8]
	fstp	QWORD PTR _center$[ebp+8]

; 1689 :   radius =  sqrt((mag1*mag1*mag2+mag1*mag2*mag2-2*mag1*w1w2*mag2)/4/det/det);

	fmul	QWORD PTR __real@3fd0000000000000
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR _radius$[ebp]

; 1690 :   angle1 = atan2(gdata[0].x[1]-center[1],gdata[0].x[0]-center[0]);

	fld	QWORD PTR [esi+8]
	fsub	QWORD PTR _center$[ebp+8]
	fld	QWORD PTR [esi]
	fsub	QWORD PTR _center$[ebp]
	call	__CIatan2
	fstp	QWORD PTR _angle1$[ebp]

; 1691 :   angle2 = atan2(gdata[2].x[1]-center[1],gdata[2].x[0]-center[0]);

	fld	QWORD PTR [esi+296]
	fsub	QWORD PTR _center$[ebp+8]
	fld	QWORD PTR [esi+288]
	fsub	QWORD PTR _center$[ebp]
	call	__CIatan2

; 1692 :   if ( det < 0.0 ) /* swap to get counterclockwise order around circle */

	fldz
	fcomp	QWORD PTR _det$[ebp]
	fnstsw	ax

; 1693 :   { REAL temp = angle1; angle1 = angle2; angle2 = temp; 

	fld	QWORD PTR _angle1$[ebp]
	test	ah, 65					; 00000041H
	jne	SHORT $LN204@torus_arc_

; 1694 :     wrap[0] = wrap[2]; /* only one we use */
; 1695 :     temp = gdata[0].x[0]; gdata[0].x[0] = gdata[2].x[0]; gdata[2].x[0] = temp;

	fld	QWORD PTR [esi]
	fld	QWORD PTR [esi+288]
	fstp	QWORD PTR [esi]
	fstp	QWORD PTR [esi+288]

; 1696 :     temp = gdata[0].x[1]; gdata[0].x[1] = gdata[2].x[1]; gdata[2].x[1] = temp;

	fld	QWORD PTR [esi+8]
	fld	QWORD PTR [esi+296]
	fstp	QWORD PTR [esi+8]
	fstp	QWORD PTR [esi+296]
	jmp	SHORT $LN98@torus_arc_
$LN204@torus_arc_:
	fxch	ST(1)
$LN98@torus_arc_:

; 1697 :   }
; 1698 :   if ( angle2 < angle1 )

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN97@torus_arc_

; 1699 :     angle2 += 2*M_PI;

	fadd	QWORD PTR __real@401921fb54442d18
$LN97@torus_arc_:

; 1700 : 
; 1701 :   /* shrink arc a bit to avoid numerical problems */
; 1702 :   angle1 += 1e-10;

	fld	QWORD PTR __real@3ddb7cdfd9d7bdbb

; 1703 :   angle2 -= 1e-10;
; 1704 :   wrap[0] = (int)floor(invper[m][0]*(center[0]+radius*cos(angle1))
; 1705 :               + invper[m][1]*(center[1]+radius*sin(angle1)));

	mov	edx, DWORD PTR _invper$[ebp]
	mov	edi, DWORD PTR [ebx+edx]
	fadd	ST(2), ST(0)
	fxch	ST(2)
	fst	QWORD PTR _angle1$[ebp]
	fxch	ST(1)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _angle2$[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp+8]
	fmul	QWORD PTR [edi+8]
	fstp	QWORD PTR tv9453[ebp]
	fld	QWORD PTR _angle1$[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	sub	esp, 8
	fadd	QWORD PTR _center$[ebp]
	fmul	QWORD PTR [edi]
	fadd	QWORD PTR tv9453[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	edi, eax

; 1706 :   
; 1707 :   /* intersect with line for low side */
; 1708 :   h = center[0]; k = center[1]; 
; 1709 :   u = per[1-m][0]; v = per[1-m][1];

	mov	eax, DWORD PTR _per$[ebp]
	sub	eax, ebx
	add	eax, 4
	mov	DWORD PTR tv4147[ebp], eax
	mov	eax, DWORD PTR [eax]
	fld	QWORD PTR [eax]
	mov	DWORD PTR _wrap$[ebp], edi
	fst	QWORD PTR _u$[ebp]
	fld	QWORD PTR [eax+8]
	fst	QWORD PTR _v$[ebp]

; 1710 :   x0 = 0.0; y0 = 0.0;
; 1711 :   a = u*u + v*v;

	fld	ST(0)
	fmul	ST(0), ST(1)
	fld	ST(2)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _a$[ebp]

; 1712 :   b = 2*(u*(x0-h) + v*(y0-k));

	fldz
	fld	QWORD PTR _center$[ebp+8]
	fsubr	ST(0), ST(1)
	fld	ST(1)
	fsub	QWORD PTR _center$[ebp]
	fld	ST(1)
	fmulp	ST(5), ST(0)
	fld	ST(0)
	fmulp	ST(6), ST(0)
	fxch	ST(4)
	faddp	ST(5), ST(0)
	fxch	ST(4)
	fadd	ST(0), ST(0)
	fst	QWORD PTR _b$[ebp]

; 1713 :   c = (x0-h)*(x0-h) + (y0-k)*(y0-k) - radius*radius;

	fld	QWORD PTR _radius$[ebp]
	fmul	ST(0), ST(0)
	fst	QWORD PTR tv4170[ebp]
	fld	ST(4)
	fmulp	ST(5), ST(0)
	fld	ST(5)
	fmulp	ST(6), ST(0)
	fxch	ST(4)
	faddp	ST(5), ST(0)
	fxch	ST(4)
	fsubrp	ST(3), ST(0)
	fxch	ST(2)
	fst	QWORD PTR _c$[ebp]

; 1714 :   discr = b*b - 4*a*c;

	fld	ST(3)
	fmul	ST(0), ST(4)
	fxch	ST(2)
	fmul	QWORD PTR __real@4010000000000000
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)

; 1715 :   if ( discr > 0.0 )

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN226@torus_arc_

; 1716 :   { /* potential intersection */
; 1717 :     t1 = b > 0.0 ? -2*c/(b + sqrt(discr)) : (-b + sqrt(discr))/2/a;

	fxch	ST(2)
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN116@torus_arc_
	call	__CIsqrt
	fld	QWORD PTR _c$[ebp]
	fmul	QWORD PTR __real@c000000000000000
	fld	QWORD PTR _b$[ebp]
	fld	ST(0)
	fadd	ST(0), ST(3)
	fdivp	ST(2), ST(0)
	jmp	SHORT $LN117@torus_arc_
$LN116@torus_arc_:
	call	__CIsqrt
	fld	ST(0)
	fld	QWORD PTR _b$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _a$[ebp]
	fxch	ST(1)
$LN117@torus_arc_:

; 1718 :     t2 = b > 0.0 ? (-b - sqrt(discr))/2/a : -2*c/(b - sqrt(discr));

	fldz
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN118@torus_arc_
	fxch	ST(1)
	fchs
	fsubrp	ST(3), ST(0)
	fxch	ST(2)
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _a$[ebp]
	jmp	SHORT $LN119@torus_arc_
$LN118@torus_arc_:
	fld	QWORD PTR _c$[ebp]
	fmul	QWORD PTR __real@c000000000000000
	fxch	ST(2)
	fsubrp	ST(4), ST(0)
	fxch	ST(1)
	fdivrp	ST(3), ST(0)
	fxch	ST(2)
$LN119@torus_arc_:

; 1719 :     x1 = x0 + t1*u; y1 = y0 + t1*v;

	fld	ST(1)
	fld	QWORD PTR _u$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fadd	ST(0), ST(4)
	fst	QWORD PTR _x1$[ebp]
	fld	QWORD PTR _v$[ebp]
	fmul	ST(4), ST(0)
	fxch	ST(4)
	fadd	ST(0), ST(5)
	fst	QWORD PTR _y1$[ebp]

; 1720 :     x2 = x0 + t2*u; y2 = y0 + t2*v;

	fld	ST(3)
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	fadd	ST(0), ST(5)
	fstp	QWORD PTR _x2$[ebp]
	fxch	ST(2)
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR _y2$[ebp]

; 1721 :     theta1 = atan2(y1-center[1],x1-center[0]);

	fsub	QWORD PTR _center$[ebp+8]
	fxch	ST(1)
	fsub	QWORD PTR _center$[ebp]
	call	__CIatan2
	fstp	QWORD PTR _theta1$[ebp]

; 1722 :     theta2 = atan2(y2-center[1],x2-center[0]);

	fld	QWORD PTR _y2$[ebp]
	fsub	QWORD PTR _center$[ebp+8]
	fld	QWORD PTR _x2$[ebp]
	fsub	QWORD PTR _center$[ebp]
	call	__CIatan2
	fst	QWORD PTR _theta2$[ebp]

; 1723 :     if ( theta1 < angle1 )  theta1 += 2*M_PI;

	fld	QWORD PTR _angle1$[ebp]
	fld	QWORD PTR _theta1$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN205@torus_arc_
	fadd	QWORD PTR __real@401921fb54442d18
	fst	QWORD PTR _theta1$[ebp]
$LN205@torus_arc_:

; 1724 :     if ( theta2 < angle1 )  theta2 += 2*M_PI;

	fxch	ST(2)
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN94@torus_arc_
	fadd	QWORD PTR __real@401921fb54442d18
	fst	QWORD PTR _theta2$[ebp]
$LN94@torus_arc_:

; 1725 :     if ( theta1 > theta2 )

	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN206@torus_arc_

; 1726 :     { REAL temp = theta1; theta1 = theta2; theta2 = temp;

	fst	QWORD PTR _theta1$[ebp]
	fxch	ST(2)
	fst	QWORD PTR _theta2$[ebp]

; 1727 :       temp = x1; x1 = x2; x2 = temp;

	fld	QWORD PTR _x1$[ebp]
	fld	QWORD PTR _x2$[ebp]
	fstp	QWORD PTR _x1$[ebp]
	fst	QWORD PTR _x2$[ebp]

; 1728 :       temp = y1; y1 = y2; y2 = temp;

	fld	QWORD PTR _y1$[ebp]
	fld	QWORD PTR _y2$[ebp]
	fstp	QWORD PTR _y1$[ebp]
	fst	QWORD PTR _y2$[ebp]
	jmp	SHORT $LN93@torus_arc_
$LN206@torus_arc_:
	fld	QWORD PTR _x2$[ebp]
	fld	QWORD PTR _y2$[ebp]
$LN93@torus_arc_:

; 1729 :     }
; 1730 :     if ( theta1 >= angle2 )

	fld	QWORD PTR _angle2$[ebp]
	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN92@torus_arc_
	fstp	ST(3)
	fstp	ST(2)
	fstp	ST(3)
	fstp	ST(2)
	fstp	ST(1)
	fstp	ST(0)

; 1731 :     { /* no intersection, but may have to wrap */
; 1732 :       if ( wrap[0] < 0 )

	test	edi, edi
	jns	$LN207@torus_arc_

; 1733 :        for ( i = 0 ; i < 3 ; i++ )

	mov	edi, 3
	npad	7
$LL90@torus_arc_:

; 1734 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN89@torus_arc_
	mov	eax, DWORD PTR _per$[ebp]
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, esi
$LL213@torus_arc_:

; 1735 :          gdata[i].x[j] += per[m][j];

	fld	QWORD PTR [ecx]
	inc	edx
	fadd	QWORD PTR [eax]
	add	ecx, 8
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL213@torus_arc_
$LN89@torus_arc_:

; 1733 :        for ( i = 0 ; i < 3 ; i++ )

	add	esi, 144				; 00000090H
	dec	edi
	jne	SHORT $LL90@torus_arc_

; 1736 :     }
; 1737 :     else /* split in at least two */

	fldz
	jmp	$LN203@torus_arc_
$LN92@torus_arc_:

; 1738 :     { if ( theta2 > angle2 )

	fcom	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	$LN250@torus_arc_
	fstp	ST(3)
	fstp	ST(1)
	fstp	ST(0)

; 1739 :       { /* split in half, top half in gdata in case of further split on top */
; 1740 :         if ( wrap[0] >= 0 )

	test	edi, edi
	js	$LN253@torus_arc_

; 1741 :         { gdata1[0].x[0] = x1;
; 1742 :           gdata1[0].x[1] = y1;
; 1743 :           gdata1[0].flags |= EDGE_ARC;

	or	DWORD PTR _gdata1$[ebp+136], 32768	; 00008000H
	fstp	ST(1)
	fld	QWORD PTR _x1$[ebp]
	fstp	QWORD PTR _gdata1$[ebp]
	fld	QWORD PTR _y1$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+8]

; 1744 :           gdata1[1].x[0] = center[0] + radius*cos((angle2+theta1)/2);

	faddp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4238[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+144]

; 1745 :           gdata1[1].x[1] = center[1] + radius*sin((angle2+theta1)/2);

	fld	QWORD PTR tv4238[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]

; 1746 :           gdata1[2] = gdata[2];

	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	mov	ecx, 36					; 00000024H
	fadd	QWORD PTR _center$[ebp+8]
	add	esi, 288				; 00000120H
	lea	edi, DWORD PTR _gdata1$[ebp+288]
	fstp	QWORD PTR _gdata1$[ebp+152]
	rep movsd

; 1747 :   
; 1748 :           gdata[1].x[0] = center[0] + radius*cos((angle1+theta1)/2);

	fld	QWORD PTR _theta1$[ebp]
	fadd	QWORD PTR _angle1$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4248[ebp]
	call	__CIcos
	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR [eax+144]

; 1749 :           gdata[1].x[1] = center[1] + radius*sin((angle1+theta1)/2);

	fld	QWORD PTR tv4248[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]
	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	mov	edx, DWORD PTR _per$[ebp]
	fadd	QWORD PTR _center$[ebp+8]
	fstp	QWORD PTR [eax+152]

; 1750 :           gdata[2].x[0] = x1;

	fld	QWORD PTR _x1$[ebp]
	mov	DWORD PTR tv5888[ebp], 0
	fstp	QWORD PTR [eax+288]

; 1751 :           gdata[2].x[1] = y1;

	fld	QWORD PTR _y1$[ebp]
	fstp	QWORD PTR [eax+296]
	mov	esi, DWORD PTR _web+616
	lea	eax, DWORD PTR _gdata1$[ebp+8]
	mov	DWORD PTR tv5904[ebp], eax
$LL81@torus_arc_:

; 1753 :            for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	esi, 4
	jl	SHORT $LC180@torus_arc_
	npad	2
$LL181@torus_arc_:

; 1754 :             gdata1[i].x[j] += per[m][j];

	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+ecx*8]
	add	ecx, 4
	fadd	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+ecx*8-24]
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+ecx*8-16]
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+ecx*8-8]
	lea	edi, DWORD PTR [esi-3]
	fadd	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	cmp	ecx, edi
	jl	SHORT $LL181@torus_arc_
$LC180@torus_arc_:

; 1753 :            for ( j = 0 ; j < SDIM ; j++ )

	cmp	ecx, esi
	jge	SHORT $LN80@torus_arc_
	mov	eax, DWORD PTR tv5888[ebp]
	add	eax, ecx
	lea	eax, DWORD PTR _gdata1$[ebp+eax*8]
$LC78@torus_arc_:

; 1754 :             gdata1[i].x[j] += per[m][j];

	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+ecx*8]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, esi
	jl	SHORT $LC78@torus_arc_
$LN80@torus_arc_:

; 1752 :           for ( i = 0 ; i < 3 ; i++ )

	mov	ecx, DWORD PTR tv5888[ebp]
	mov	eax, DWORD PTR tv5904[ebp]
	add	ecx, 18					; 00000012H
	add	eax, 144				; 00000090H
	mov	DWORD PTR tv5904[ebp], eax
	mov	DWORD PTR tv5888[ebp], ecx
	cmp	ecx, 54					; 00000036H
	jl	$LL81@torus_arc_

; 1755 :         }
; 1756 :         else

	mov	edi, DWORD PTR _m$GSCopy$[ebp]
	jmp	$LN52@torus_arc_
$LN253@torus_arc_:

; 1757 :         { gdata1[0] = gdata[0];

	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	fstp	ST(0)

; 1758 :           gdata1[1].x[0] = center[0] + radius*cos((angle1+theta1)/2);

	faddp	ST(1), ST(0)
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata1$[ebp]
	rep movsd
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4248[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+144]

; 1759 :           gdata1[1].x[1] = center[1] + radius*sin((angle1+theta1)/2);

	fld	QWORD PTR tv4248[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]

; 1760 :           gdata1[2].x[0] = x1;
; 1761 :           gdata1[2].x[1] = y1;
; 1762 :   
; 1763 :           gdata[0].x[0] = x1;

	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	fadd	QWORD PTR _center$[ebp+8]
	fstp	QWORD PTR _gdata1$[ebp+152]
	fld	QWORD PTR _x1$[ebp]
	fst	QWORD PTR _gdata1$[ebp+288]
	fld	QWORD PTR _y1$[ebp]
	fst	QWORD PTR _gdata1$[ebp+296]
	fxch	ST(1)
	fstp	QWORD PTR [esi]

; 1764 :           gdata[0].x[1] = y1;

	fstp	QWORD PTR [esi+8]

; 1765 :           gdata[1].x[0] = center[0] + radius*cos((angle2+theta1)/2);

	fld	QWORD PTR _theta1$[ebp]
	fadd	QWORD PTR _angle2$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4238[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR [esi+144]

; 1766 :           gdata[1].x[1] = center[1] + radius*sin((angle2+theta1)/2);

	fld	QWORD PTR tv4238[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]
	mov	edx, DWORD PTR _per$[ebp]
	lea	eax, DWORD PTR _gdata1$[ebp+8]
	fadd	QWORD PTR _center$[ebp+8]
	mov	DWORD PTR tv6208[ebp], 0
	mov	DWORD PTR tv6224[ebp], eax
	fstp	QWORD PTR [esi+152]
	mov	esi, DWORD PTR _web+616
$LL74@torus_arc_:

; 1768 :            for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	esi, 4
	jl	SHORT $LC183@torus_arc_
	npad	5
$LL184@torus_arc_:

; 1769 :             gdata1[i].x[j] += per[m][j];

	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+ecx*8]
	add	ecx, 4
	fadd	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+ecx*8-24]
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+ecx*8-16]
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+ecx*8-8]
	lea	edi, DWORD PTR [esi-3]
	fadd	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	cmp	ecx, edi
	jl	SHORT $LL184@torus_arc_
$LC183@torus_arc_:

; 1768 :            for ( j = 0 ; j < SDIM ; j++ )

	cmp	ecx, esi
	jge	SHORT $LN73@torus_arc_
	mov	eax, DWORD PTR tv6208[ebp]
	add	eax, ecx
	lea	eax, DWORD PTR _gdata1$[ebp+eax*8]
$LC71@torus_arc_:

; 1769 :             gdata1[i].x[j] += per[m][j];

	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+ecx*8]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, esi
	jl	SHORT $LC71@torus_arc_
$LN73@torus_arc_:

; 1767 :           for ( i = 0 ; i < 3 ; i++ )

	mov	ecx, DWORD PTR tv6208[ebp]
	mov	eax, DWORD PTR tv6224[ebp]
	add	ecx, 18					; 00000012H
	add	eax, 144				; 00000090H
	mov	DWORD PTR tv6224[ebp], eax
	mov	DWORD PTR tv6208[ebp], ecx
	cmp	ecx, 54					; 00000036H
	jl	$LL74@torus_arc_

; 1770 :         }
; 1771 :       }
; 1772 :       else /* split in three */

	mov	edi, DWORD PTR _m$GSCopy$[ebp]
	jmp	$LN52@torus_arc_
$LN250@torus_arc_:

; 1738 :     { if ( theta2 > angle2 )

	fstp	ST(5)
	fstp	ST(3)

; 1773 :       { if ( wrap[0] >= 0 )
; 1774 :         {
; 1775 :           gdata2[0].x[0] = x2;

	fstp	QWORD PTR _gdata2$[ebp]

; 1776 :           gdata2[0].x[1] = y2;

	fxch	ST(1)
	fstp	QWORD PTR _gdata2$[ebp+8]

; 1777 :           gdata2[1].x[0] = center[0] + radius*cos((angle2+theta2)/2);

	faddp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4311[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR _gdata2$[ebp+144]

; 1778 :           gdata2[1].x[1] = center[1] + radius*sin((angle2+theta2)/2);

	fld	QWORD PTR tv4311[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]

; 1779 :           gdata2[2] = gdata[2];

	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	add	esi, 288				; 00000120H
	fadd	QWORD PTR _center$[ebp+8]
	test	edi, edi
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata2$[ebp+288]
	fstp	QWORD PTR _gdata2$[ebp+152]
	rep movsd
	js	$LN67@torus_arc_

; 1780 :           gdata2[0].flags |= EDGE_ARC;
; 1781 :   
; 1782 :           gdata1[0].flags |= EDGE_ARC;
; 1783 :           gdata1[0].x[0] = x2;

	fld	QWORD PTR _x2$[ebp]
	mov	eax, 32768				; 00008000H
	or	DWORD PTR _gdata2$[ebp+136], eax
	fstp	QWORD PTR _gdata1$[ebp]

; 1784 :           gdata1[0].x[1] = y2;

	fld	QWORD PTR _y2$[ebp]
	or	DWORD PTR _gdata1$[ebp+136], eax
	fstp	QWORD PTR _gdata1$[ebp+8]

; 1785 :           gdata1[1].x[0] = center[0] + radius*cos((theta2+theta1)/2);

	fld	QWORD PTR _theta2$[ebp]
	fadd	QWORD PTR _theta1$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4321[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+144]

; 1786 :           gdata1[1].x[1] = center[1] + radius*sin((theta2+theta1)/2);

	fld	QWORD PTR tv4321[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp+8]
	fstp	QWORD PTR _gdata1$[ebp+152]

; 1787 :           gdata1[2].x[0] = x1;

	fld	QWORD PTR _x1$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+288]

; 1788 :           gdata1[2].x[1] = y1;

	fld	QWORD PTR _y1$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+296]

; 1789 :   
; 1790 :           gdata[1].x[0] = center[0] + radius*cos((angle1+theta1)/2);

	fld	QWORD PTR _theta1$[ebp]
	fadd	QWORD PTR _angle1$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4248[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR [eax+144]

; 1791 :           gdata[1].x[1] = center[1] + radius*sin((angle1+theta1)/2);

	fld	QWORD PTR tv4248[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]
	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	mov	edx, DWORD PTR _per$[ebp]
	fadd	QWORD PTR _center$[ebp+8]
	fstp	QWORD PTR [eax+152]

; 1792 :           gdata[2].x[0] = x1;

	fld	QWORD PTR _x1$[ebp]
	mov	DWORD PTR tv6528[ebp], 0
	fstp	QWORD PTR [eax+288]

; 1793 :           gdata[2].x[1] = y1;

	fld	QWORD PTR _y1$[ebp]
	fstp	QWORD PTR [eax+296]
	mov	edi, DWORD PTR _web+616
	lea	eax, DWORD PTR _gdata1$[ebp+8]
	mov	DWORD PTR tv6544[ebp], eax
	npad	2
$LL66@torus_arc_:

; 1795 :            for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	edi, 4
	jl	SHORT $LC186@torus_arc_
$LL187@torus_arc_:

; 1796 :             gdata1[i].x[j] += per[m][j];

	mov	esi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [esi+ecx*8]
	add	ecx, 4
	fadd	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	mov	esi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [esi+ecx*8-24]
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	mov	esi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [esi+ecx*8-16]
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	mov	esi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [esi+ecx*8-8]
	lea	esi, DWORD PTR [edi-3]
	fadd	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	cmp	ecx, esi
	jl	SHORT $LL187@torus_arc_
$LC186@torus_arc_:

; 1795 :            for ( j = 0 ; j < SDIM ; j++ )

	cmp	ecx, edi
	jge	SHORT $LN65@torus_arc_
	mov	eax, DWORD PTR tv6528[ebp]
	add	eax, ecx
	lea	eax, DWORD PTR _gdata1$[ebp+eax*8]
	npad	6
$LC63@torus_arc_:

; 1796 :             gdata1[i].x[j] += per[m][j];

	mov	esi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [esi+ecx*8]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, edi
	jl	SHORT $LC63@torus_arc_
$LN65@torus_arc_:

; 1794 :           for ( i = 0 ; i < 3 ; i++ )

	mov	ecx, DWORD PTR tv6528[ebp]
	mov	eax, DWORD PTR tv6544[ebp]
	add	ecx, 18					; 00000012H
	add	eax, 144				; 00000090H
	mov	DWORD PTR tv6544[ebp], eax
	mov	DWORD PTR tv6528[ebp], ecx
	cmp	ecx, 54					; 00000036H
	jl	$LL66@torus_arc_

; 1797 :         }
; 1798 :         else

	jmp	$LN57@torus_arc_
$LN67@torus_arc_:

; 1799 :         {
; 1800 :           gdata2[0].x[0] = x2;
; 1801 :           gdata2[0].x[1] = y2;
; 1802 :           gdata2[1].x[0] = center[0] + radius*cos((angle2+theta2)/2);
; 1803 :           gdata2[1].x[1] = center[1] + radius*sin((angle2+theta2)/2);
; 1804 :           gdata2[2] = gdata[2];
; 1805 :           gdata2[0].flags |= EDGE_ARC;
; 1806 :   
; 1807 :           gdata1[0] = gdata[0];
; 1808 :           gdata1[1].x[0] = center[0] + radius*cos((angle1+theta1)/2);

	fld	QWORD PTR _theta1$[ebp]
	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	fadd	QWORD PTR _angle1$[ebp]
	or	DWORD PTR _gdata2$[ebp+136], 32768	; 00008000H
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata1$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	rep movsd
	fst	QWORD PTR tv4248[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+144]

; 1809 :           gdata1[1].x[1] = center[1] + radius*sin((angle1+theta1)/2);

	fld	QWORD PTR tv4248[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]

; 1810 :           gdata1[2].x[0] = x1;
; 1811 :           gdata1[2].x[1] = y1;
; 1812 :   
; 1813 :           gdata[0].x[0] = x2;

	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	fadd	QWORD PTR _center$[ebp+8]
	fstp	QWORD PTR _gdata1$[ebp+152]
	fld	QWORD PTR _x1$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+288]
	fld	QWORD PTR _y1$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+296]
	fld	QWORD PTR _x2$[ebp]
	fstp	QWORD PTR [esi]

; 1814 :           gdata[0].x[1] = y2;

	fld	QWORD PTR _y2$[ebp]
	fstp	QWORD PTR [esi+8]

; 1815 :           gdata[1].x[0] = center[0] + radius*cos((theta2+theta1)/2);

	fld	QWORD PTR _theta2$[ebp]
	fadd	QWORD PTR _theta1$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4321[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR [esi+144]

; 1816 :           gdata[1].x[1] = center[1] + radius*sin((theta2+theta1)/2);

	fld	QWORD PTR tv4321[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]
	mov	edx, DWORD PTR _per$[ebp]
	xor	ecx, ecx
	fadd	QWORD PTR _center$[ebp+8]
	fstp	QWORD PTR [esi+152]

; 1817 :           gdata[2].x[0] = x1;

	fld	QWORD PTR _x1$[ebp]
	fstp	QWORD PTR [esi+288]

; 1818 :           gdata[2].x[1] = y1;

	fld	QWORD PTR _y1$[ebp]
	fstp	QWORD PTR [esi+296]
	mov	edi, DWORD PTR _web+616
	npad	5
$LL59@torus_arc_:

; 1821 :            for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	edi, 4
	jl	$LC189@torus_arc_
	npad	5
$LL190@torus_arc_:

; 1822 :            { gdata1[i].x[j] += per[m][j];

	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+eax*8]

; 1823 :              gdata2[i].x[j] += per[m][j];

	lea	esi, DWORD PTR [ecx+eax*8]
	fadd	QWORD PTR _gdata1$[ebp+esi]
	lea	esi, DWORD PTR _gdata1$[ebp+esi]
	fstp	QWORD PTR [esi]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+eax*8]
	lea	esi, DWORD PTR [ecx+eax*8]
	fadd	QWORD PTR _gdata2$[ebp+esi]
	lea	esi, DWORD PTR _gdata2$[ebp+esi]
	fstp	QWORD PTR [esi]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+eax*8+8]
	lea	esi, DWORD PTR [ecx+eax*8]
	fadd	QWORD PTR _gdata1$[ebp+esi+8]
	lea	esi, DWORD PTR _gdata1$[ebp+esi+8]
	fstp	QWORD PTR [esi]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+eax*8+8]
	lea	esi, DWORD PTR [ecx+eax*8]
	fadd	QWORD PTR _gdata2$[ebp+esi+8]
	lea	esi, DWORD PTR _gdata2$[ebp+esi+8]
	fstp	QWORD PTR [esi]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+eax*8+16]
	lea	esi, DWORD PTR [ecx+eax*8]
	fadd	QWORD PTR _gdata1$[ebp+esi+16]
	lea	esi, DWORD PTR _gdata1$[ebp+esi+16]
	fstp	QWORD PTR [esi]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+eax*8+16]
	lea	esi, DWORD PTR [ecx+eax*8]
	fadd	QWORD PTR _gdata2$[ebp+esi+16]
	lea	esi, DWORD PTR _gdata2$[ebp+esi+16]
	fstp	QWORD PTR [esi]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+eax*8+24]
	lea	esi, DWORD PTR [ecx+eax*8]
	fadd	QWORD PTR _gdata1$[ebp+esi+24]
	lea	esi, DWORD PTR _gdata1$[ebp+esi+24]
	fstp	QWORD PTR [esi]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [edi+eax*8+24]
	mov	edi, DWORD PTR _web+616
	lea	esi, DWORD PTR [ecx+eax*8]
	fadd	QWORD PTR _gdata2$[ebp+esi+24]
	lea	esi, DWORD PTR _gdata2$[ebp+esi+24]
	add	eax, 4
	fstp	QWORD PTR [esi]
	lea	esi, DWORD PTR [edi-3]
	cmp	eax, esi
	jl	$LL190@torus_arc_
$LC189@torus_arc_:

; 1821 :            for ( j = 0 ; j < SDIM ; j++ )

	cmp	eax, edi
	jge	SHORT $LN58@torus_arc_
	npad	10
$LC56@torus_arc_:
	lea	esi, DWORD PTR [ecx+eax*8]
	lea	esi, DWORD PTR _gdata1$[ebp+esi]
	mov	DWORD PTR tv10021[ebp], esi

; 1822 :            { gdata1[i].x[j] += per[m][j];

	mov	esi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR tv10021[ebp]
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	lea	esi, DWORD PTR [ecx+eax*8]
	lea	esi, DWORD PTR _gdata2$[ebp+esi]
	mov	DWORD PTR tv10031[ebp], esi

; 1823 :              gdata2[i].x[j] += per[m][j];

	mov	esi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR tv10031[ebp]
	fadd	QWORD PTR [esi]
	inc	eax
	fstp	QWORD PTR [esi]
	cmp	eax, edi
	jl	SHORT $LC56@torus_arc_
$LN58@torus_arc_:

; 1819 :   
; 1820 :           for ( i = 0 ; i < 3 ; i++ )

	add	ecx, 144				; 00000090H
	cmp	ecx, 432				; 000001b0H
	jl	$LL59@torus_arc_
$LN57@torus_arc_:

; 1824 :            }
; 1825 :         }
; 1826 :         /* send on for further check, or plot */
; 1827 :         if ( m == SDIM-1 ) 

	lea	ecx, DWORD PTR [edi-1]
	mov	edi, DWORD PTR _m$GSCopy$[ebp]
	cmp	edi, ecx
	jne	SHORT $LN53@torus_arc_

; 1828 :           (*graph_edge_transforms)(gdata2,gdata[0].id);

	mov	edx, DWORD PTR _gdata$GSCopy$[ebp]
	mov	eax, DWORD PTR [edx+128]
	push	eax
	lea	ecx, DWORD PTR _gdata2$[ebp]
	push	ecx
	call	_graph_edge_transforms

; 1829 :         else

	jmp	SHORT $LN300@torus_arc_
$LN53@torus_arc_:

; 1830 :           torus_edge_clip(gdata2,m+1);

	lea	edx, DWORD PTR [edi+1]
	push	edx
	lea	eax, DWORD PTR _gdata2$[ebp]
	push	eax
	call	_torus_edge_clip
$LN300@torus_arc_:
	mov	esi, DWORD PTR _web+616
	add	esp, 8
$LN52@torus_arc_:

; 1831 :       }
; 1832 :       /* send on for further check, or plot */
; 1833 :       if ( m == SDIM-1 ) 

	dec	esi
	cmp	edi, esi
	jne	SHORT $LN51@torus_arc_

; 1834 :         (*graph_edge_transforms)(gdata1,gdata[0].id);

	mov	ecx, DWORD PTR _gdata$GSCopy$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	push	edx
	lea	eax, DWORD PTR _gdata1$[ebp]
	push	eax
	call	_graph_edge_transforms
	add	esp, 8
$LN207@torus_arc_:

; 1835 :       else

	fldz
	jmp	SHORT $LN203@torus_arc_
$LN51@torus_arc_:

; 1836 :         torus_edge_clip(gdata1,m+1);

	inc	edi
	lea	ecx, DWORD PTR _gdata1$[ebp]
	push	edi
	push	ecx
	call	_torus_edge_clip
	fldz
	add	esp, 8
	jmp	SHORT $LN203@torus_arc_
$LN226@torus_arc_:
	fstp	ST(2)
	fstp	ST(1)
$LN203@torus_arc_:

; 1837 :     }
; 1838 :   }
; 1839 : 
; 1840 :   /* intersect with line for high side */
; 1841 :   h = center[0]; k = center[1]; 
; 1842 :   u = per[1-m][0]; v = per[1-m][1];

	mov	edx, DWORD PTR tv4147[ebp]
	mov	eax, DWORD PTR [edx]
	fld	QWORD PTR [eax]
	fst	QWORD PTR _u$[ebp]
	fld	QWORD PTR [eax+8]

; 1843 :   x0 = per[m][0]; y0 = per[m][1];

	mov	eax, DWORD PTR _per$[ebp]
	mov	eax, DWORD PTR [ebx+eax]
	fst	QWORD PTR _v$[ebp]
	fld	QWORD PTR [eax]
	fst	QWORD PTR _x0$[ebp]
	fld	QWORD PTR [eax+8]
	fst	QWORD PTR _y0$[ebp]

; 1844 :   a = u*u + v*v;

	fld	ST(2)
	fmul	ST(0), ST(3)
	fld	ST(4)
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _a$[ebp]

; 1845 :   b = 2*(u*(x0-h) + v*(y0-k));

	fxch	ST(1)
	fsub	QWORD PTR _center$[ebp+8]
	fxch	ST(2)
	fsub	QWORD PTR _center$[ebp]
	fld	ST(2)
	fmulp	ST(4), ST(0)
	fld	ST(0)
	fmulp	ST(5), ST(0)
	fxch	ST(3)
	faddp	ST(4), ST(0)
	fxch	ST(3)
	fadd	ST(0), ST(0)
	fst	QWORD PTR _b$[ebp]

; 1846 :   c = (x0-h)*(x0-h) + (y0-k)*(y0-k) - radius*radius;

	fld	ST(2)
	fmulp	ST(3), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	faddp	ST(1), ST(0)
	fsub	QWORD PTR tv4170[ebp]
	fst	QWORD PTR _c$[ebp]

; 1847 :   discr = b*b - 4*a*c;

	fld	ST(1)
	fmul	ST(0), ST(2)
	fxch	ST(3)
	fmul	QWORD PTR __real@4010000000000000
	fmulp	ST(1), ST(0)
	fsubp	ST(2), ST(0)

; 1848 :   if ( discr > 0.0 )

	fxch	ST(1)
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN262@torus_arc_

; 1849 :   { /* potential intersection */
; 1850 :     t1 = b > 0.0 ? -2*c/(b + sqrt(discr)) : (-b + sqrt(discr))/2/a;

	fxch	ST(1)
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jne	SHORT $LN120@torus_arc_
	call	__CIsqrt
	fld	QWORD PTR _c$[ebp]
	fmul	QWORD PTR __real@c000000000000000
	fld	QWORD PTR _b$[ebp]
	fld	ST(0)
	fadd	ST(0), ST(3)
	fdivp	ST(2), ST(0)
	jmp	SHORT $LN121@torus_arc_
$LN120@torus_arc_:
	call	__CIsqrt
	fld	ST(0)
	fld	QWORD PTR _b$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _a$[ebp]
	fxch	ST(1)
$LN121@torus_arc_:

; 1851 :     t2 = b > 0.0 ? (-b - sqrt(discr))/2/a : -2*c/(b - sqrt(discr));

	fldz
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN122@torus_arc_
	fchs
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _a$[ebp]
	jmp	SHORT $LN123@torus_arc_
$LN122@torus_arc_:
	fld	QWORD PTR _c$[ebp]
	fmul	QWORD PTR __real@c000000000000000
	fxch	ST(1)
	fsubrp	ST(3), ST(0)
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
$LN123@torus_arc_:

; 1852 :     x1 = x0 + t1*u; y1 = y0 + t1*v;

	fld	ST(1)
	fld	QWORD PTR _u$[ebp]
	fmul	ST(1), ST(0)
	fld	QWORD PTR _x0$[ebp]
	fadd	ST(2), ST(0)
	fxch	ST(2)
	fst	QWORD PTR _x1$[ebp]
	fld	QWORD PTR _v$[ebp]
	fmul	ST(5), ST(0)
	fld	QWORD PTR _y0$[ebp]
	fadd	ST(6), ST(0)
	fxch	ST(6)
	fst	QWORD PTR _y1$[ebp]

; 1853 :     x2 = x0 + t2*u; y2 = y0 + t2*v;

	fld	ST(5)
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	faddp	ST(4), ST(0)
	fxch	ST(3)
	fstp	QWORD PTR _x2$[ebp]
	fxch	ST(3)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR _y2$[ebp]

; 1854 :     theta1 = atan2(y1-center[1],x1-center[0]) - 0.000000001;

	fxch	ST(1)
	fsub	QWORD PTR _center$[ebp+8]
	fxch	ST(1)
	fsub	QWORD PTR _center$[ebp]
	call	__CIatan2
	fsub	QWORD PTR __real@3e112e0be826d695
	fstp	QWORD PTR _theta1$[ebp]

; 1855 :     theta2 = atan2(y2-center[1],x2-center[0]);

	fld	QWORD PTR _y2$[ebp]
	fsub	QWORD PTR _center$[ebp+8]
	fld	QWORD PTR _x2$[ebp]
	fsub	QWORD PTR _center$[ebp]
	call	__CIatan2
	fst	QWORD PTR _theta2$[ebp]

; 1856 :     if ( theta1 < angle1 )  theta1 += 2*M_PI;

	fld	QWORD PTR _angle1$[ebp]
	fld	QWORD PTR _theta1$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN208@torus_arc_
	fadd	QWORD PTR __real@401921fb54442d18
	fst	QWORD PTR _theta1$[ebp]
$LN208@torus_arc_:

; 1857 :     if ( theta2 < angle1 )  theta2 += 2*M_PI;

	fxch	ST(2)
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN47@torus_arc_
	fadd	QWORD PTR __real@401921fb54442d18
	fst	QWORD PTR _theta2$[ebp]
$LN47@torus_arc_:

; 1858 :     if ( theta1 > theta2 )

	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN209@torus_arc_

; 1859 :     { REAL temp = theta1; theta1 = theta2; theta2 = temp;

	fst	QWORD PTR _theta1$[ebp]
	fxch	ST(2)
	fst	QWORD PTR _theta2$[ebp]

; 1860 :       temp = x1; x1 = x2; x2 = temp;

	fld	QWORD PTR _x1$[ebp]
	fld	QWORD PTR _x2$[ebp]
	fstp	QWORD PTR _x1$[ebp]
	fst	QWORD PTR _x2$[ebp]

; 1861 :       temp = y1; y1 = y2; y2 = temp;

	fld	QWORD PTR _y1$[ebp]
	fld	QWORD PTR _y2$[ebp]
	fstp	QWORD PTR _y1$[ebp]
	fst	QWORD PTR _y2$[ebp]
	jmp	SHORT $LN46@torus_arc_
$LN209@torus_arc_:
	fld	QWORD PTR _x2$[ebp]
	fld	QWORD PTR _y2$[ebp]
$LN46@torus_arc_:

; 1862 :     }
; 1863 :     if ( theta1 > angle2 )

	fld	QWORD PTR _angle2$[ebp]
	fcom	ST(5)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN45@torus_arc_

; 1864 :     { /* no intersection, but may have to wrap */
; 1865 :       if ( wrap[0] > 0 )

	cmp	DWORD PTR _wrap$[ebp], 0
	fstp	ST(3)
	fstp	ST(2)
	fstp	ST(3)
	fstp	ST(2)
	fstp	ST(1)
	fstp	ST(0)
	jle	$LN3@torus_arc_

; 1866 :        for ( i = 0 ; i < 3 ; i++ )

	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	mov	edi, 3
	npad	9
$LL43@torus_arc_:

; 1867 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN42@torus_arc_
	mov	ecx, DWORD PTR _per$[ebp]
	mov	ecx, DWORD PTR [ebx+ecx]
	mov	eax, esi
$LL212@torus_arc_:

; 1868 :          gdata[i].x[j] -= per[m][j];

	fld	QWORD PTR [eax]
	inc	edx
	fsub	QWORD PTR [ecx]
	add	ecx, 8
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL212@torus_arc_
$LN42@torus_arc_:

; 1866 :        for ( i = 0 ; i < 3 ; i++ )

	add	esi, 144				; 00000090H
	dec	edi
	jne	SHORT $LL43@torus_arc_

; 1869 :     }
; 1870 :     else

	jmp	$LN3@torus_arc_
$LN45@torus_arc_:

; 1871 :     { /* split in at least two */
; 1872 :       if ( theta2 > angle2 )

	fcom	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	$LN286@torus_arc_

; 1873 :       { /* split in half, bottom half in gdata */
; 1874 :         if ( wrap[0] <= 0 )

	cmp	DWORD PTR _wrap$[ebp], 0
	fstp	ST(3)
	fstp	ST(1)
	fstp	ST(0)
	jg	$LN289@torus_arc_

; 1875 :         { gdata1[0].x[0] = x1;
; 1876 :           gdata1[0].x[1] = y1;
; 1877 :           gdata1[0].flags |= EDGE_ARC;

	or	DWORD PTR _gdata1$[ebp+136], 32768	; 00008000H
	fstp	ST(1)
	fld	QWORD PTR _x1$[ebp]
	fstp	QWORD PTR _gdata1$[ebp]
	fld	QWORD PTR _y1$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+8]

; 1878 :           gdata1[1].x[0] = center[0] + radius*cos((angle2+theta1)/2);

	faddp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4238[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+144]

; 1879 :           gdata1[1].x[1] = center[1] + radius*sin((angle2+theta1)/2);

	fld	QWORD PTR tv4238[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]

; 1880 :           gdata1[2] = gdata[2];

	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	mov	ecx, 36					; 00000024H
	fadd	QWORD PTR _center$[ebp+8]
	add	esi, 288				; 00000120H
	lea	edi, DWORD PTR _gdata1$[ebp+288]
	fstp	QWORD PTR _gdata1$[ebp+152]
	rep movsd

; 1881 :   
; 1882 :           gdata[1].x[0] = center[0] + radius*cos((angle1+theta1)/2);

	fld	QWORD PTR _theta1$[ebp]
	fadd	QWORD PTR _angle1$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4248[ebp]
	call	__CIcos
	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR [eax+144]

; 1883 :           gdata[1].x[1] = center[1] + radius*sin((angle1+theta1)/2);

	fld	QWORD PTR tv4248[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]
	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	mov	edx, DWORD PTR _per$[ebp]
	fadd	QWORD PTR _center$[ebp+8]
	fstp	QWORD PTR [eax+152]

; 1884 :           gdata[2].x[0] = x1;

	fld	QWORD PTR _x1$[ebp]
	mov	DWORD PTR tv7900[ebp], 0
	fstp	QWORD PTR [eax+288]

; 1885 :           gdata[2].x[1] = y1;

	fld	QWORD PTR _y1$[ebp]
	fstp	QWORD PTR [eax+296]
	mov	esi, DWORD PTR _web+616
	lea	eax, DWORD PTR _gdata1$[ebp+8]
	mov	DWORD PTR tv7948[ebp], eax
$LL34@torus_arc_:

; 1887 :            for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	esi, 4
	jl	SHORT $LC192@torus_arc_
	npad	2
$LL193@torus_arc_:

; 1888 :             gdata1[i].x[j] -= per[m][j];

	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [eax-8]
	fsub	QWORD PTR [edi+ecx*8]
	add	ecx, 4
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [eax-32]
	fsub	QWORD PTR [edi+ecx*8-24]
	fstp	QWORD PTR [eax-32]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [eax-24]
	fsub	QWORD PTR [edi+ecx*8-16]
	fstp	QWORD PTR [eax-24]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [eax-16]
	fsub	QWORD PTR [edi+ecx*8-8]
	lea	edi, DWORD PTR [esi-3]
	fstp	QWORD PTR [eax-16]
	cmp	ecx, edi
	jl	SHORT $LL193@torus_arc_
$LC192@torus_arc_:

; 1887 :            for ( j = 0 ; j < SDIM ; j++ )

	cmp	ecx, esi
	jge	SHORT $LN33@torus_arc_
	mov	eax, DWORD PTR tv7900[ebp]
	add	eax, ecx
	lea	eax, DWORD PTR _gdata1$[ebp+eax*8]
$LC31@torus_arc_:

; 1888 :             gdata1[i].x[j] -= per[m][j];

	fld	QWORD PTR [eax]
	mov	edi, DWORD PTR [ebx+edx]
	fsub	QWORD PTR [edi+ecx*8]
	inc	ecx
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, esi
	jl	SHORT $LC31@torus_arc_
$LN33@torus_arc_:

; 1886 :           for ( i = 0 ; i < 3 ; i++ )

	mov	ecx, DWORD PTR tv7900[ebp]
	mov	eax, DWORD PTR tv7948[ebp]
	add	ecx, 18					; 00000012H
	add	eax, 144				; 00000090H
	mov	DWORD PTR tv7948[ebp], eax
	mov	DWORD PTR tv7900[ebp], ecx
	cmp	ecx, 54					; 00000036H
	jl	$LL34@torus_arc_

; 1889 :         }
; 1890 :         else

	mov	edi, DWORD PTR _m$GSCopy$[ebp]
	jmp	$LN5@torus_arc_
$LN289@torus_arc_:

; 1891 :         { gdata1[0] = gdata[0];

	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	fstp	ST(0)

; 1892 :           gdata1[1].x[0] = center[0] + radius*cos((angle1+theta1)/2);

	faddp	ST(1), ST(0)
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata1$[ebp]
	rep movsd
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4248[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+144]

; 1893 :           gdata1[1].x[1] = center[1] + radius*sin((angle1+theta1)/2);

	fld	QWORD PTR tv4248[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]

; 1894 :           gdata1[2].x[0] = x1;
; 1895 :           gdata1[2].x[1] = y1;
; 1896 :   
; 1897 :           gdata[0].x[0] = x1;

	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	fadd	QWORD PTR _center$[ebp+8]
	fstp	QWORD PTR _gdata1$[ebp+152]
	fld	QWORD PTR _x1$[ebp]
	fst	QWORD PTR _gdata1$[ebp+288]
	fld	QWORD PTR _y1$[ebp]
	fst	QWORD PTR _gdata1$[ebp+296]
	fxch	ST(1)
	fstp	QWORD PTR [esi]

; 1898 :           gdata[0].x[1] = y1;

	fstp	QWORD PTR [esi+8]

; 1899 :           gdata[1].x[0] = center[0] + radius*cos((angle2+theta1)/2);

	fld	QWORD PTR _theta1$[ebp]
	fadd	QWORD PTR _angle2$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4238[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR [esi+144]

; 1900 :           gdata[1].x[1] = center[1] + radius*sin((angle2+theta1)/2);

	fld	QWORD PTR tv4238[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]
	mov	edx, DWORD PTR _per$[ebp]
	lea	eax, DWORD PTR _gdata1$[ebp+8]
	fadd	QWORD PTR _center$[ebp+8]
	mov	DWORD PTR tv8476[ebp], 0
	mov	DWORD PTR tv8524[ebp], eax
	fstp	QWORD PTR [esi+152]
	mov	esi, DWORD PTR _web+616
$LL27@torus_arc_:

; 1902 :            for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	esi, 4
	jl	SHORT $LC195@torus_arc_
	npad	5
$LL196@torus_arc_:

; 1903 :             gdata1[i].x[j] -= per[m][j];

	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [eax-8]
	fsub	QWORD PTR [edi+ecx*8]
	add	ecx, 4
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [eax-32]
	fsub	QWORD PTR [edi+ecx*8-24]
	fstp	QWORD PTR [eax-32]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [eax-24]
	fsub	QWORD PTR [edi+ecx*8-16]
	fstp	QWORD PTR [eax-24]
	mov	edi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [eax-16]
	fsub	QWORD PTR [edi+ecx*8-8]
	lea	edi, DWORD PTR [esi-3]
	fstp	QWORD PTR [eax-16]
	cmp	ecx, edi
	jl	SHORT $LL196@torus_arc_
$LC195@torus_arc_:

; 1902 :            for ( j = 0 ; j < SDIM ; j++ )

	cmp	ecx, esi
	jge	SHORT $LN26@torus_arc_
	mov	eax, DWORD PTR tv8476[ebp]
	add	eax, ecx
	lea	eax, DWORD PTR _gdata1$[ebp+eax*8]
$LC24@torus_arc_:

; 1903 :             gdata1[i].x[j] -= per[m][j];

	fld	QWORD PTR [eax]
	mov	edi, DWORD PTR [ebx+edx]
	fsub	QWORD PTR [edi+ecx*8]
	inc	ecx
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, esi
	jl	SHORT $LC24@torus_arc_
$LN26@torus_arc_:

; 1901 :           for ( i = 0 ; i < 3 ; i++ )

	mov	ecx, DWORD PTR tv8476[ebp]
	mov	eax, DWORD PTR tv8524[ebp]
	add	ecx, 18					; 00000012H
	add	eax, 144				; 00000090H
	mov	DWORD PTR tv8524[ebp], eax
	mov	DWORD PTR tv8476[ebp], ecx
	cmp	ecx, 54					; 00000036H
	jl	$LL27@torus_arc_

; 1904 :         }
; 1905 :       }
; 1906 :       else /* split in three */

	mov	edi, DWORD PTR _m$GSCopy$[ebp]
	jmp	$LN5@torus_arc_
$LN286@torus_arc_:

; 1871 :     { /* split in at least two */
; 1872 :       if ( theta2 > angle2 )

	fstp	ST(5)
	fstp	ST(3)

; 1907 :       { if ( wrap[0] <= 0 )
; 1908 :         {
; 1909 :           gdata2[0].x[0] = x2;

	fstp	QWORD PTR _gdata2$[ebp]

; 1910 :           gdata2[0].x[1] = y2;

	fxch	ST(1)
	fstp	QWORD PTR _gdata2$[ebp+8]

; 1911 :           gdata2[1].x[0] = center[0] + radius*cos((angle2+theta2)/2);

	faddp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4311[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR _gdata2$[ebp+144]

; 1912 :           gdata2[1].x[1] = center[1] + radius*sin((angle2+theta2)/2);

	fld	QWORD PTR tv4311[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]

; 1913 :           gdata2[2] = gdata[2];

	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	add	esi, 288				; 00000120H
	cmp	DWORD PTR _wrap$[ebp], 0
	fadd	QWORD PTR _center$[ebp+8]
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata2$[ebp+288]
	fstp	QWORD PTR _gdata2$[ebp+152]
	rep movsd
	jg	$LN20@torus_arc_

; 1914 :           gdata2[0].flags |= EDGE_ARC;
; 1915 :   
; 1916 :           gdata1[0].flags |= EDGE_ARC;
; 1917 :           gdata1[0].x[0] = x2;

	fld	QWORD PTR _x2$[ebp]
	mov	eax, 32768				; 00008000H
	or	DWORD PTR _gdata2$[ebp+136], eax
	fstp	QWORD PTR _gdata1$[ebp]

; 1918 :           gdata1[0].x[1] = y2;

	fld	QWORD PTR _y2$[ebp]
	or	DWORD PTR _gdata1$[ebp+136], eax
	fstp	QWORD PTR _gdata1$[ebp+8]

; 1919 :           gdata1[1].x[0] = center[0] + radius*cos((theta2+theta1)/2);

	fld	QWORD PTR _theta2$[ebp]
	fadd	QWORD PTR _theta1$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4321[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+144]

; 1920 :           gdata1[1].x[1] = center[1] + radius*sin((theta2+theta1)/2);

	fld	QWORD PTR tv4321[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp+8]
	fstp	QWORD PTR _gdata1$[ebp+152]

; 1921 :           gdata1[2].x[0] = x1;

	fld	QWORD PTR _x1$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+288]

; 1922 :           gdata1[2].x[1] = y1;

	fld	QWORD PTR _y1$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+296]

; 1923 :   
; 1924 :           gdata[1].x[0] = center[0] + radius*cos((angle1+theta1)/2);

	fld	QWORD PTR _theta1$[ebp]
	fadd	QWORD PTR _angle1$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4248[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR [eax+144]

; 1925 :           gdata[1].x[1] = center[1] + radius*sin((angle1+theta1)/2);

	fld	QWORD PTR tv4248[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]
	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	mov	edx, DWORD PTR _per$[ebp]
	fadd	QWORD PTR _center$[ebp+8]
	fstp	QWORD PTR [eax+152]

; 1926 :           gdata[2].x[0] = x1;

	fld	QWORD PTR _x1$[ebp]
	mov	DWORD PTR tv9052[ebp], 0
	fstp	QWORD PTR [eax+288]

; 1927 :           gdata[2].x[1] = y1;

	fld	QWORD PTR _y1$[ebp]
	fstp	QWORD PTR [eax+296]
	mov	edi, DWORD PTR _web+616
	lea	eax, DWORD PTR _gdata1$[ebp+8]
	mov	DWORD PTR tv9068[ebp], eax
$LL19@torus_arc_:

; 1929 :            for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	edi, 4
	jl	SHORT $LC198@torus_arc_
$LL199@torus_arc_:

; 1930 :             gdata1[i].x[j] -= per[m][j];

	mov	esi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [eax-8]
	fsub	QWORD PTR [esi+ecx*8]
	add	ecx, 4
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	mov	esi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [eax-32]
	fsub	QWORD PTR [esi+ecx*8-24]
	fstp	QWORD PTR [eax-32]
	mov	esi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [eax-24]
	fsub	QWORD PTR [esi+ecx*8-16]
	fstp	QWORD PTR [eax-24]
	mov	esi, DWORD PTR [ebx+edx]
	fld	QWORD PTR [eax-16]
	fsub	QWORD PTR [esi+ecx*8-8]
	lea	esi, DWORD PTR [edi-3]
	fstp	QWORD PTR [eax-16]
	cmp	ecx, esi
	jl	SHORT $LL199@torus_arc_
$LC198@torus_arc_:

; 1929 :            for ( j = 0 ; j < SDIM ; j++ )

	cmp	ecx, edi
	jge	SHORT $LN18@torus_arc_
	mov	eax, DWORD PTR tv9052[ebp]
	add	eax, ecx
	lea	eax, DWORD PTR _gdata1$[ebp+eax*8]
	npad	6
$LC16@torus_arc_:

; 1930 :             gdata1[i].x[j] -= per[m][j];

	fld	QWORD PTR [eax]
	mov	esi, DWORD PTR [ebx+edx]
	fsub	QWORD PTR [esi+ecx*8]
	inc	ecx
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, edi
	jl	SHORT $LC16@torus_arc_
$LN18@torus_arc_:

; 1928 :           for ( i = 0 ; i < 3 ; i++ )

	mov	ecx, DWORD PTR tv9052[ebp]
	mov	eax, DWORD PTR tv9068[ebp]
	add	ecx, 18					; 00000012H
	add	eax, 144				; 00000090H
	mov	DWORD PTR tv9068[ebp], eax
	mov	DWORD PTR tv9052[ebp], ecx
	cmp	ecx, 54					; 00000036H
	jl	$LL19@torus_arc_

; 1931 :         }
; 1932 :         else

	jmp	$LN10@torus_arc_
$LN20@torus_arc_:

; 1933 :         {
; 1934 :           gdata2[0].x[0] = x2;
; 1935 :           gdata2[0].x[1] = y2;
; 1936 :           gdata2[1].x[0] = center[0] + radius*cos((angle2+theta2)/2);
; 1937 :           gdata2[1].x[1] = center[1] + radius*sin((angle2+theta2)/2);
; 1938 :           gdata2[2] = gdata[2];
; 1939 :           gdata2[0].flags |= EDGE_ARC;
; 1940 :   
; 1941 :           gdata1[0] = gdata[0];
; 1942 :           gdata1[1].x[0] = center[0] + radius*cos((angle1+theta1)/2);

	fld	QWORD PTR _theta1$[ebp]
	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	fadd	QWORD PTR _angle1$[ebp]
	or	DWORD PTR _gdata2$[ebp+136], 32768	; 00008000H
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata1$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	rep movsd
	fst	QWORD PTR tv4248[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+144]

; 1943 :           gdata1[1].x[1] = center[1] + radius*sin((angle1+theta1)/2);

	fld	QWORD PTR tv4248[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]

; 1944 :           gdata1[2].x[0] = x1;
; 1945 :           gdata1[2].x[1] = y1;
; 1946 :   
; 1947 :           gdata[0].x[0] = x2;

	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	fadd	QWORD PTR _center$[ebp+8]
	fstp	QWORD PTR _gdata1$[ebp+152]
	fld	QWORD PTR _x1$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+288]
	fld	QWORD PTR _y1$[ebp]
	fstp	QWORD PTR _gdata1$[ebp+296]
	fld	QWORD PTR _x2$[ebp]
	fstp	QWORD PTR [esi]

; 1948 :           gdata[0].x[1] = y2;

	fld	QWORD PTR _y2$[ebp]
	fstp	QWORD PTR [esi+8]

; 1949 :           gdata[1].x[0] = center[0] + radius*cos((theta2+theta1)/2);

	fld	QWORD PTR _theta2$[ebp]
	fadd	QWORD PTR _theta1$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR tv4321[ebp]
	call	__CIcos
	fmul	QWORD PTR _radius$[ebp]
	fadd	QWORD PTR _center$[ebp]
	fstp	QWORD PTR [esi+144]

; 1950 :           gdata[1].x[1] = center[1] + radius*sin((theta2+theta1)/2);

	fld	QWORD PTR tv4321[ebp]
	call	__CIsin
	fmul	QWORD PTR _radius$[ebp]
	mov	edx, DWORD PTR _per$[ebp]
	xor	ecx, ecx
	fadd	QWORD PTR _center$[ebp+8]
	fstp	QWORD PTR [esi+152]

; 1951 :           gdata[2].x[0] = x1;

	fld	QWORD PTR _x1$[ebp]
	fstp	QWORD PTR [esi+288]

; 1952 :           gdata[2].x[1] = y1;

	fld	QWORD PTR _y1$[ebp]
	fstp	QWORD PTR [esi+296]
	mov	edi, DWORD PTR _web+616
	npad	5
$LL12@torus_arc_:

; 1955 :            for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	edi, 4
	jl	$LC201@torus_arc_
	npad	5
$LL202@torus_arc_:

; 1956 :            { gdata1[i].x[j] -= per[m][j];

	mov	edi, DWORD PTR [ebx+edx]

; 1957 :              gdata2[i].x[j] -= per[m][j];

	lea	esi, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR _gdata1$[ebp+esi]
	lea	esi, DWORD PTR _gdata1$[ebp+esi]
	fsub	QWORD PTR [edi+eax*8]
	fstp	QWORD PTR [esi]
	mov	edi, DWORD PTR [ebx+edx]
	lea	esi, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR _gdata2$[ebp+esi]
	lea	esi, DWORD PTR _gdata2$[ebp+esi]
	fsub	QWORD PTR [edi+eax*8]
	fstp	QWORD PTR [esi]
	mov	edi, DWORD PTR [ebx+edx]
	lea	esi, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR _gdata1$[ebp+esi+8]
	lea	esi, DWORD PTR _gdata1$[ebp+esi+8]
	fsub	QWORD PTR [edi+eax*8+8]
	fstp	QWORD PTR [esi]
	mov	edi, DWORD PTR [ebx+edx]
	lea	esi, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR _gdata2$[ebp+esi+8]
	lea	esi, DWORD PTR _gdata2$[ebp+esi+8]
	fsub	QWORD PTR [edi+eax*8+8]
	fstp	QWORD PTR [esi]
	mov	edi, DWORD PTR [ebx+edx]
	lea	esi, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR _gdata1$[ebp+esi+16]
	lea	esi, DWORD PTR _gdata1$[ebp+esi+16]
	fsub	QWORD PTR [edi+eax*8+16]
	fstp	QWORD PTR [esi]
	mov	edi, DWORD PTR [ebx+edx]
	lea	esi, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR _gdata2$[ebp+esi+16]
	lea	esi, DWORD PTR _gdata2$[ebp+esi+16]
	fsub	QWORD PTR [edi+eax*8+16]
	fstp	QWORD PTR [esi]
	mov	edi, DWORD PTR [ebx+edx]
	lea	esi, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR _gdata1$[ebp+esi+24]
	lea	esi, DWORD PTR _gdata1$[ebp+esi+24]
	fsub	QWORD PTR [edi+eax*8+24]
	fstp	QWORD PTR [esi]
	mov	edi, DWORD PTR [ebx+edx]
	lea	esi, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR _gdata2$[ebp+esi+24]
	lea	esi, DWORD PTR _gdata2$[ebp+esi+24]
	fsub	QWORD PTR [edi+eax*8+24]
	mov	edi, DWORD PTR _web+616
	add	eax, 4
	fstp	QWORD PTR [esi]
	lea	esi, DWORD PTR [edi-3]
	cmp	eax, esi
	jl	$LL202@torus_arc_
$LC201@torus_arc_:

; 1955 :            for ( j = 0 ; j < SDIM ; j++ )

	cmp	eax, edi
	jge	SHORT $LN11@torus_arc_
	npad	10
$LC9@torus_arc_:

; 1956 :            { gdata1[i].x[j] -= per[m][j];

	mov	edi, DWORD PTR [ebx+edx]
	lea	esi, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR _gdata1$[ebp+esi]
	lea	esi, DWORD PTR _gdata1$[ebp+esi]
	fsub	QWORD PTR [edi+eax*8]
	fstp	QWORD PTR [esi]

; 1957 :              gdata2[i].x[j] -= per[m][j];

	mov	edi, DWORD PTR [ebx+edx]
	lea	esi, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR _gdata2$[ebp+esi]
	lea	esi, DWORD PTR _gdata2$[ebp+esi]
	fsub	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR _web+616
	inc	eax
	fstp	QWORD PTR [esi]
	cmp	eax, edi
	jl	SHORT $LC9@torus_arc_
$LN11@torus_arc_:

; 1953 :   
; 1954 :           for ( i = 0 ; i < 3 ; i++ )

	add	ecx, 144				; 00000090H
	cmp	ecx, 432				; 000001b0H
	jl	$LL12@torus_arc_
$LN10@torus_arc_:

; 1958 :            }
; 1959 :         }
; 1960 :         /* send on for further check, or plot */
; 1961 :         if ( m == SDIM-1 ) 

	lea	ecx, DWORD PTR [edi-1]
	mov	edi, DWORD PTR _m$GSCopy$[ebp]
	cmp	edi, ecx
	jne	SHORT $LN6@torus_arc_

; 1962 :           (*graph_edge_transforms)(gdata2,gdata[0].id);

	mov	edx, DWORD PTR _gdata$GSCopy$[ebp]
	mov	eax, DWORD PTR [edx+128]
	push	eax
	lea	ecx, DWORD PTR _gdata2$[ebp]
	push	ecx
	call	_graph_edge_transforms

; 1963 :         else

	jmp	SHORT $LN301@torus_arc_
$LN6@torus_arc_:

; 1964 :           torus_edge_clip(gdata2,m+1);

	lea	edx, DWORD PTR [edi+1]
	push	edx
	lea	eax, DWORD PTR _gdata2$[ebp]
	push	eax
	call	_torus_edge_clip
$LN301@torus_arc_:
	mov	esi, DWORD PTR _web+616
	add	esp, 8
$LN5@torus_arc_:

; 1965 :       }
; 1966 :       /* send on for further check, or plot */
; 1967 :       if ( m == SDIM-1 ) 

	dec	esi
	cmp	edi, esi
	jne	SHORT $LN4@torus_arc_

; 1968 :         (*graph_edge_transforms)(gdata1,gdata[0].id);

	mov	ecx, DWORD PTR _gdata$GSCopy$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	push	edx
	lea	eax, DWORD PTR _gdata1$[ebp]
	push	eax
	call	_graph_edge_transforms
	add	esp, 8

; 1969 :       else

	jmp	SHORT $LN3@torus_arc_
$LN4@torus_arc_:

; 1970 :         torus_edge_clip(gdata1,m+1);

	inc	edi
	lea	ecx, DWORD PTR _gdata1$[ebp]
	push	edi
	push	ecx
	call	_torus_edge_clip
	add	esp, 8
	jmp	SHORT $LN3@torus_arc_
$LN262@torus_arc_:
	fstp	ST(1)
	fstp	ST(0)
	fstp	ST(0)
$LN3@torus_arc_:

; 1971 :     }
; 1972 :   }
; 1973 : 
; 1974 :   /* send on original edge structure */
; 1975 :   if ( m == SDIM-1 ) 

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _m$GSCopy$[ebp]
	dec	edx
	cmp	eax, edx
	jne	SHORT $LN2@torus_arc_

; 1976 :     (*graph_edge_transforms)(gdata,gdata[0].id);

	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	push	ecx
	push	eax
	call	_graph_edge_transforms

; 1977 :   else
; 1978 :     torus_edge_clip(gdata,m+1);

	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1979 : 
; 1980 : } /* end torus_arc_clip() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@torus_arc_:

; 1977 :   else
; 1978 :     torus_edge_clip(gdata,m+1);

	mov	edx, DWORD PTR _gdata$GSCopy$[ebp]
	inc	eax
	push	eax
	push	edx
$LN299@torus_arc_:
	call	_torus_edge_clip

; 1979 : 
; 1980 : } /* end torus_arc_clip() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_torus_arc_clip ENDP
_TEXT	ENDS
PUBLIC	_bfcomp
; Function compile flags: /Ogtp
;	COMDAT _bfcomp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_bfcomp	PROC						; COMDAT

; 2217 : {

	push	ebp
	mov	ebp, esp

; 2218 :   if ( loc_ordinal(a->b_id) < loc_ordinal(b->b_id) ) return -1;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ebx
	mov	eax, ecx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	push	esi
	push	edi
	je	SHORT $LN9@bfcomp
	mov	ebx, ecx
	and	ebx, 134217727				; 07ffffffH
	jmp	SHORT $LN10@bfcomp
$LN9@bfcomp:
	or	ebx, -1
$LN10@bfcomp:
	mov	edx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	edi, edx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	je	SHORT $LN11@bfcomp
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	jmp	SHORT $LN12@bfcomp
$LN11@bfcomp:
	or	esi, -1
$LN12@bfcomp:
	cmp	ebx, esi
	jge	SHORT $LN6@bfcomp
$LN25@bfcomp:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx

; 2224 : 
; 2225 :   return 0;
; 2226 : } // end bfcomp()

	pop	ebp
	ret	0
$LN6@bfcomp:

; 2219 :   if ( loc_ordinal(a->b_id) > loc_ordinal(b->b_id) ) return 1;

	test	eax, eax
	je	SHORT $LN13@bfcomp
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN14@bfcomp
$LN13@bfcomp:
	or	ecx, -1
$LN14@bfcomp:
	test	edi, edi
	je	SHORT $LN15@bfcomp
	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN16@bfcomp
$LN15@bfcomp:
	or	edx, -1
$LN16@bfcomp:
	cmp	ecx, edx
	jle	SHORT $LN5@bfcomp
$LN26@bfcomp:
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 2224 : 
; 2225 :   return 0;
; 2226 : } // end bfcomp()

	pop	ebp
	ret	0
$LN5@bfcomp:

; 2220 :   if ( loc_ordinal(a->f_id) < loc_ordinal(b->f_id) ) return -1;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edi, ecx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	je	SHORT $LN17@bfcomp
	mov	ebx, ecx
	and	ebx, 134217727				; 07ffffffH
	jmp	SHORT $LN18@bfcomp
$LN17@bfcomp:
	or	ebx, -1
$LN18@bfcomp:
	mov	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, eax
	shr	esi, 28					; 0000001cH
	and	esi, 1
	je	SHORT $LN19@bfcomp
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN20@bfcomp
$LN19@bfcomp:
	or	edx, -1
$LN20@bfcomp:
	cmp	ebx, edx
	jl	SHORT $LN25@bfcomp

; 2221 :   if ( loc_ordinal(a->f_id) > loc_ordinal(b->f_id) ) return 1;

	test	edi, edi
	je	SHORT $LN21@bfcomp
	mov	edi, ecx
	and	edi, 134217727				; 07ffffffH
	jmp	SHORT $LN22@bfcomp
$LN21@bfcomp:
	or	edi, -1
$LN22@bfcomp:
	test	esi, esi
	je	SHORT $LN23@bfcomp
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN24@bfcomp
$LN23@bfcomp:
	or	edx, -1
$LN24@bfcomp:
	cmp	edi, edx
	jg	SHORT $LN26@bfcomp

; 2222 :   if ( inverted(a->f_id) < inverted(b->f_id) ) return -1;

	shr	ecx, 27					; 0000001bH
	shr	eax, 27					; 0000001bH
	and	ecx, 1
	and	eax, 1
	cmp	ecx, eax
	jl	$LN25@bfcomp

; 2223 :   if ( inverted(a->f_id) > inverted(b->f_id) ) return 1;

	xor	edx, edx
	cmp	ecx, eax
	setg	dl
	pop	edi
	pop	esi
	pop	ebx
	mov	eax, edx

; 2224 : 
; 2225 :   return 0;
; 2226 : } // end bfcomp()

	pop	ebp
	ret	0
_bfcomp	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@HGPDJPNI@glist?5not?5in?5order?5at?5spots?5?$CFd?0?$CF@ ; `string'
PUBLIC	??_C@_0BN@EOMEBGAJ@Cannot?5find?5?$CFd?5in?5polylist?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@ONOMPJPP@glist?5out?5of?5order?5at?5spot?5?$CFd?0?$CFd@ ; `string'
PUBLIC	??_C@_0BI@JIBGENOL@polycount?5?$CFd?5gcount?5?$CFd?6?$AA@ ; `string'
PUBLIC	_polylist_check
EXTRN	_printf:PROC
;	COMDAT ??_C@_0CD@HGPDJPNI@glist?5not?5in?5order?5at?5spots?5?$CFd?0?$CF@
CONST	SEGMENT
??_C@_0CD@HGPDJPNI@glist?5not?5in?5order?5at?5spots?5?$CFd?0?$CF@ DB 'gli'
	DB	'st not in order at spots %d,%d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EOMEBGAJ@Cannot?5find?5?$CFd?5in?5polylist?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@EOMEBGAJ@Cannot?5find?5?$CFd?5in?5polylist?4?6?$AA@ DB 'Cannot '
	DB	'find %d in polylist.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ONOMPJPP@glist?5out?5of?5order?5at?5spot?5?$CFd?0?$CFd@
CONST	SEGMENT
??_C@_0CC@ONOMPJPP@glist?5out?5of?5order?5at?5spot?5?$CFd?0?$CFd@ DB 'gli'
	DB	'st out of order at spot %d,%d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JIBGENOL@polycount?5?$CFd?5gcount?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BI@JIBGENOL@polycount?5?$CFd?5gcount?5?$CFd?6?$AA@ DB 'polycount %'
	DB	'd gcount %d', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _polylist_check
_TEXT	SEGMENT
_glist$ = 8						; size = 4
_gcount$ = 12						; size = 4
_polylist$ = 16						; size = 4
_polycount$ = 20					; size = 4
_polylist_check PROC					; COMDAT

; 3152 : { int i,j;

	push	ebp
	mov	ebp, esp

; 3153 : 
; 3154 :   if ( polycount > gcount )

	mov	eax, DWORD PTR _gcount$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _polycount$[ebp]
	cmp	edi, eax
	jle	SHORT $LN17@polylist_c

; 3155 :     printf("polycount %d gcount %d\n",polycount,gcount);

	push	eax
	push	edi
	push	OFFSET ??_C@_0BI@JIBGENOL@polycount?5?$CFd?5gcount?5?$CFd?6?$AA@
	call	_printf
	add	esp, 12					; 0000000cH
$LN17@polylist_c:

; 3156 : 
; 3157 :   // Check cyclic order of glist wrt originals
; 3158 :   for ( i = 1 ; i < polycount ; i++ )

	mov	esi, 1
	cmp	edi, esi
	jle	SHORT $LN29@polylist_c
	mov	ebx, DWORD PTR _glist$[ebp]
	add	ebx, 264				; 00000108H
$LL16@polylist_c:

; 3159 :     if ( glist[i].ecolor <= glist[i-1].ecolor )

	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR [ebx-144]
	jg	SHORT $LN15@polylist_c

; 3160 :       printf("glist out of order at spot %d,%d\n",i-1,i);

	push	esi
	lea	ecx, DWORD PTR [esi-1]
	push	ecx
	push	OFFSET ??_C@_0CC@ONOMPJPP@glist?5out?5of?5order?5at?5spot?5?$CFd?0?$CFd@
	call	_printf
	add	esp, 12					; 0000000cH
$LN15@polylist_c:

; 3156 : 
; 3157 :   // Check cyclic order of glist wrt originals
; 3158 :   for ( i = 1 ; i < polycount ; i++ )

	inc	esi
	add	ebx, 144				; 00000090H
	cmp	esi, edi
	jl	SHORT $LL16@polylist_c
$LN29@polylist_c:

; 3161 :   // check polylist has one occurrence of each index
; 3162 :   for ( i = 0 ; i < polycount ; i++ )

	mov	ebx, DWORD PTR _polylist$[ebp]
	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN10@polylist_c
$LL31@polylist_c:

; 3163 :   { for ( j = 0 ; j < polycount ; j++ )

	xor	eax, eax
$LL9@polylist_c:

; 3164 :       if ( polylist[j] == i )

	cmp	DWORD PTR [ebx+eax*4], esi
	je	SHORT $LN24@polylist_c

; 3163 :   { for ( j = 0 ; j < polycount ; j++ )

	inc	eax
	cmp	eax, edi
	jl	SHORT $LL9@polylist_c
$LN24@polylist_c:

; 3165 :         break;
; 3166 :     if ( j == polycount )

	cmp	eax, edi
	jne	SHORT $LN11@polylist_c

; 3167 :       printf("Cannot find %d in polylist.\n",i);

	push	esi
	push	OFFSET ??_C@_0BN@EOMEBGAJ@Cannot?5find?5?$CFd?5in?5polylist?4?6?$AA@
	call	_printf
	add	esp, 8
$LN11@polylist_c:

; 3161 :   // check polylist has one occurrence of each index
; 3162 :   for ( i = 0 ; i < polycount ; i++ )

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL31@polylist_c
$LN10@polylist_c:

; 3168 :   }
; 3169 :   // Check x order of vertices
; 3170 :   for ( i = 1 ; i < polycount ; i++ )

	mov	esi, 1
	cmp	edi, esi
	jle	SHORT $LN2@polylist_c
	npad	3
$LL4@polylist_c:

; 3171 :     if ( glist[polylist[i]].X[0] < glist[polylist[i-1]].X[0] )

	mov	eax, DWORD PTR [ebx+esi*4]
	lea	edx, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [ebx+esi*4-4]
	lea	ecx, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR _glist$[ebp]
	add	ecx, ecx
	fld	QWORD PTR [eax+ecx*8+56]
	add	edx, edx
	fcomp	QWORD PTR [eax+edx*8+56]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@polylist_c

; 3172 :       printf("glist not in order at spots %d,%d\n",i-1,i);

	push	esi
	lea	edx, DWORD PTR [esi-1]
	push	edx
	push	OFFSET ??_C@_0CD@HGPDJPNI@glist?5not?5in?5order?5at?5spots?5?$CFd?0?$CF@
	call	_printf
	add	esp, 12					; 0000000cH
$LN3@polylist_c:

; 3168 :   }
; 3169 :   // Check x order of vertices
; 3170 :   for ( i = 1 ; i < polycount ; i++ )

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@polylist_c
$LN2@polylist_c:
	pop	edi
	pop	esi
	pop	ebx

; 3173 : 
; 3174 : }

	pop	ebp
	ret	0
_polylist_check ENDP
_TEXT	ENDS
PUBLIC	_gsfn_comp
; Function compile flags: /Ogtp
;	COMDAT _gsfn_comp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_gsfn_comp PROC						; COMDAT

; 3276 : {

	push	ebp
	mov	ebp, esp

; 3277 :   struct graphdata *aa = *(struct graphdata **)a;
; 3278 :   struct graphdata *bb = *(struct graphdata **)b;

	mov	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]

; 3279 :   if ( aa->X[0] < bb->X[0] ) return -1;

	fld	QWORD PTR [edx+56]
	fcomp	QWORD PTR [ecx+56]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@gsfn_comp
	or	eax, -1

; 3282 : }

	pop	ebp
	ret	0
$LN2@gsfn_comp:

; 3280 :   if ( aa->X[0] > bb->X[0] ) return  1;

	fld	QWORD PTR [edx+56]
	fcomp	QWORD PTR [ecx+56]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@gsfn_comp
	mov	eax, 1

; 3282 : }

	pop	ebp
	ret	0
$LN1@gsfn_comp:

; 3281 :   return 0;

	xor	eax, eax

; 3282 : }

	pop	ebp
	ret	0
_gsfn_comp ENDP
_TEXT	ENDS
PUBLIC	_slice_edge
; Function compile flags: /Ogtp
;	COMDAT _slice_edge
_TEXT	SEGMENT
_gdata$ = 8						; size = 4
_slice_edge PROC					; COMDAT

; 3714 : }

	ret	0
_slice_edge ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	_gdata$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_slice_facet
EXTRN	_graph_facet:DWORD
EXTRN	_graph_edge:DWORD
EXTRN	_slice_coeff:BYTE
EXTRN	_memset:PROC
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _slice_facet
_TEXT	SEGMENT
_i$ = -608						; size = 4
_m$ = -604						; size = 4
tv3420 = -600						; size = 4
tv3457 = -596						; size = 4
tv3418 = -592						; size = 4
tv3455 = -588						; size = 4
_gdata$GSCopy$ = -584					; size = 4
_sliceg$ = -580						; size = 576
__$ArrayPad$ = -4					; size = 4
_gdata$ = 8						; size = 4
_slice_facet PROC					; COMDAT

; 3726 : { struct graphdata sliceg[FACET_VERTS+1];   // +1 for wraparound

	push	ebp
	mov	ebp, esp
	sub	esp, 608				; 00000260H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _gdata$[ebp]

; 3727 :   int i,j;
; 3728 :   int m = 0; /* how many plane crossings found */

	xor	ebx, ebx

; 3729 : 
; 3730 :   memset(sliceg,0,sizeof(sliceg));

	push	576					; 00000240H
	lea	eax, DWORD PTR _sliceg$[ebp]
	push	ebx
	push	eax
	mov	DWORD PTR _gdata$GSCopy$[ebp], edi
	mov	DWORD PTR _m$[ebp], ebx
	call	_memset

; 3731 :   sliceg[0].etype = REGULAR_EDGE;
; 3732 :   sliceg[0].ecolor = gdata[0].color;
; 3733 :   for ( i = 0 ; i < FACET_VERTS ; i++ )

	fldz
	mov	edx, DWORD PTR [edi+104]
	fld1
	mov	ecx, 1
	lea	eax, DWORD PTR _sliceg$[ebp+8]
	add	esp, 12					; 0000000cH
	mov	WORD PTR _sliceg$[ebp+124], cx
	mov	DWORD PTR _sliceg$[ebp+120], edx
	mov	DWORD PTR _i$[ebp], ebx

; 3734 :   { int ii = (i < FACET_VERTS-1) ? i+1 : 0 ;

	mov	DWORD PTR tv3418[ebp], ebx
	mov	DWORD PTR tv3420[ebp], ebx

; 3735 :     REAL denom=0;

	mov	DWORD PTR tv3455[ebp], edi
	mov	DWORD PTR tv3457[ebp], eax
$LN35@slice_face:

; 3734 :   { int ii = (i < FACET_VERTS-1) ? i+1 : 0 ;

	cmp	ebx, 2
	jge	SHORT $LN18@slice_face
	inc	ebx
	jmp	SHORT $LN19@slice_face
$LN18@slice_face:
	xor	ebx, ebx
$LN19@slice_face:

; 3736 :     REAL numer=slice_coeff[SDIM];

	mov	esi, DWORD PTR _web+616
	fld	ST(1)
	fld	QWORD PTR _slice_coeff[esi*8]

; 3737 :     REAL lambda;
; 3738 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	esi, 4
	jl	$LC27@slice_face

; 3735 :     REAL denom=0;

	mov	edx, DWORD PTR tv3455[ebp]
	lea	eax, DWORD PTR [ebx+ebx*8]
	shl	eax, 4
	add	eax, DWORD PTR _gdata$GSCopy$[ebp]
	lea	edi, DWORD PTR [esi-3]
$LN33@slice_face:

; 3739 :     { numer -= slice_coeff[j]*gdata[ii].x[j];

	fld	QWORD PTR [eax]

; 3740 :       denom += slice_coeff[j]*(gdata[i].x[j] - gdata[ii].x[j]);

	add	ecx, 4
	fmul	QWORD PTR _slice_coeff[ecx*8-32]
	add	edx, 32					; 00000020H
	add	eax, 32					; 00000020H
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [eax-24]
	fmul	QWORD PTR _slice_coeff[ecx*8-24]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [eax-16]
	fmul	QWORD PTR _slice_coeff[ecx*8-16]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [eax-8]
	fmul	QWORD PTR _slice_coeff[ecx*8-8]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [edx-32]
	fsub	QWORD PTR [eax-32]
	fmul	QWORD PTR _slice_coeff[ecx*8-32]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edx-24]
	fsub	QWORD PTR [eax-24]
	fmul	QWORD PTR _slice_coeff[ecx*8-24]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edx-16]
	fsub	QWORD PTR [eax-16]
	fmul	QWORD PTR _slice_coeff[ecx*8-16]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edx-8]
	fsub	QWORD PTR [eax-8]
	fmul	QWORD PTR _slice_coeff[ecx*8-8]
	faddp	ST(2), ST(0)
	cmp	ecx, edi
	jl	SHORT $LN33@slice_face
	mov	edi, DWORD PTR _gdata$GSCopy$[ebp]
$LC27@slice_face:

; 3737 :     REAL lambda;
; 3738 :     for ( j = 0 ; j < SDIM ; j++ )

	cmp	ecx, esi
	jge	SHORT $LN26@slice_face
	lea	edx, DWORD PTR [ebx+ebx*8]
	lea	eax, DWORD PTR [ecx+edx*2]
	mov	edx, DWORD PTR tv3418[ebp]
	add	edx, ecx
	lea	eax, DWORD PTR [edi+eax*8]
	lea	edx, DWORD PTR [edi+edx*8]
$LC12@slice_face:

; 3739 :     { numer -= slice_coeff[j]*gdata[ii].x[j];

	fld	QWORD PTR _slice_coeff[ecx*8]
	inc	ecx
	fmul	QWORD PTR [eax]
	add	edx, 8
	add	eax, 8
	fsubp	ST(1), ST(0)

; 3740 :       denom += slice_coeff[j]*(gdata[i].x[j] - gdata[ii].x[j]);

	fld	QWORD PTR [edx-8]
	fsub	QWORD PTR [eax-8]
	fmul	QWORD PTR _slice_coeff[ecx*8-8]
	faddp	ST(2), ST(0)
	cmp	ecx, esi
	jl	SHORT $LC12@slice_face
$LN26@slice_face:

; 3741 :     }
; 3742 :     if ( denom == 0.0 )

	fld	ST(1)
	fld	ST(4)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN52@slice_face

; 3743 :       continue;
; 3744 :     lambda = numer/denom;

	fdivrp	ST(1), ST(0)

; 3745 :     if ( (lambda < 0.0) || (lambda > 1.0) )

	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jnp	$LN58@slice_face
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN58@slice_face

; 3746 :       continue;
; 3747 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	cmp	esi, 4
	jl	SHORT $LC30@slice_face
	mov	edx, DWORD PTR tv3457[ebp]
	fld	ST(1)
	mov	ecx, DWORD PTR tv3455[ebp]
	fsub	ST(0), ST(1)
	lea	eax, DWORD PTR [ebx+ebx*8]
	add	esi, -4					; fffffffcH
	shl	eax, 4
	add	eax, DWORD PTR _gdata$GSCopy$[ebp]
	shr	esi, 2
	inc	esi
	lea	edi, DWORD PTR [esi*4]
$LN31@slice_face:

; 3748 :       sliceg[m].x[j] = lambda*gdata[i].x[j] + (1-lambda)*gdata[ii].x[j];

	fld	QWORD PTR [ecx]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(2)
	add	ecx, 32					; 00000020H
	fld	ST(1)
	add	edx, 32					; 00000020H
	dec	esi
	fmul	QWORD PTR [eax-32]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx-40]
	fld	QWORD PTR [eax-24]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [ecx-24]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx-32]
	fld	QWORD PTR [eax-16]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [ecx-16]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx-24]
	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [ecx-8]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx-16]
	jne	SHORT $LN31@slice_face

; 3746 :       continue;
; 3747 :     for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _web+616
	fstp	ST(0)
$LC30@slice_face:
	cmp	edi, esi
	jge	SHORT $LN67@slice_face
	mov	ecx, DWORD PTR tv3418[ebp]
	fld	ST(1)
	mov	edx, DWORD PTR tv3420[ebp]
	fsub	ST(0), ST(1)
	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	add	ecx, edi
	lea	ebx, DWORD PTR [ebx+ebx*8]
	add	edx, edi
	lea	ebx, DWORD PTR [edi+ebx*2]
	lea	ecx, DWORD PTR [eax+ecx*8]
	lea	edx, DWORD PTR _sliceg$[ebp+edx*8]
	lea	eax, DWORD PTR [eax+ebx*8]
	sub	esi, edi
$LC6@slice_face:

; 3748 :       sliceg[m].x[j] = lambda*gdata[i].x[j] + (1-lambda)*gdata[ii].x[j];

	fld	ST(0)
	add	eax, 8
	fmul	QWORD PTR [eax-8]
	add	ecx, 8
	fld	QWORD PTR [ecx-8]
	add	edx, 8
	dec	esi
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx-8]
	jne	SHORT $LC6@slice_face

; 3746 :       continue;
; 3747 :     for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(1)
$LN67@slice_face:

; 3749 :     m++;

	inc	DWORD PTR _m$[ebp]
	add	DWORD PTR tv3457[ebp], 144		; 00000090H
	add	DWORD PTR tv3420[ebp], 18		; 00000012H
	mov	edi, DWORD PTR _gdata$GSCopy$[ebp]
	jmp	SHORT $LN58@slice_face
$LN52@slice_face:
	fstp	ST(1)
$LN58@slice_face:

; 3731 :   sliceg[0].etype = REGULAR_EDGE;
; 3732 :   sliceg[0].ecolor = gdata[0].color;
; 3733 :   for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR tv3418[ebp]

; 3745 :     if ( (lambda < 0.0) || (lambda > 1.0) )

	fstp	ST(0)
	mov	ebx, DWORD PTR _i$[ebp]
	add	DWORD PTR tv3455[ebp], 144		; 00000090H
	add	eax, 18					; 00000012H
	inc	ebx
	mov	DWORD PTR _i$[ebp], ebx
	mov	DWORD PTR tv3418[ebp], eax
	cmp	eax, 54					; 00000036H
	jl	$LN35@slice_face

; 3750 :   }
; 3751 :   if ( m == 2 )

	mov	eax, DWORD PTR _m$[ebp]
	fstp	ST(1)
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx
	cmp	eax, 2
	jne	SHORT $LN3@slice_face

; 3752 :     (*graph_edge)(sliceg,NULLID);

	lea	edx, DWORD PTR _sliceg$[ebp]
	push	0
	push	edx
	call	DWORD PTR _graph_edge

; 3754 :     (*graph_facet)(sliceg,NULLID);

	add	esp, 8

; 3755 : 
; 3756 : } // end slice_facet()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@slice_face:

; 3753 :   else if ( m == 3 )

	cmp	eax, 3
	jne	SHORT $LN1@slice_face

; 3754 :     (*graph_facet)(sliceg,NULLID);

	lea	eax, DWORD PTR _sliceg$[ebp]
	push	0
	push	eax
	call	DWORD PTR _graph_facet
	add	esp, 8
$LN1@slice_face:

; 3755 : 
; 3756 : } // end slice_facet()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_slice_facet ENDP
_TEXT	ENDS
PUBLIC	_which$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_clip_edge
EXTRN	_clip_coeff:BYTE
; Function compile flags: /Ogtp
;	COMDAT _clip_edge
_TEXT	SEGMENT
_innies$ = -324						; size = 8
_i$ = -316						; size = 4
tv4005 = -312						; size = 4
tv3668 = -312						; size = 4
tv1616 = -308						; size = 4
_j$ = -308						; size = 4
_which$GSCopy$ = -304					; size = 4
tv3672 = -300						; size = 4
_in_count$ = -300					; size = 4
tv3676 = -296						; size = 4
tv1529 = -296						; size = 4
_clipg$ = -292						; size = 288
__$ArrayPad$ = -4					; size = 4
_gdata$ = 8						; size = 4
_id$ = 12						; size = 4
_which$ = 16						; size = 4
_clip_edge PROC						; COMDAT

; 3792 : { struct graphdata clipg[EDGE_VERTS];

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, DWORD PTR _which$[ebp]

; 3803 :       innies[in_count++] = i;

	fldz
	push	ebx
	mov	ebx, DWORD PTR _gdata$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _web+616
	xor	eax, eax
	lea	edx, DWORD PTR [edi+ecx*8]
	mov	DWORD PTR _which$GSCopy$[ebp], ecx
	mov	DWORD PTR _in_count$[ebp], eax
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR tv4005[ebp], edx
	mov	DWORD PTR tv1529[ebp], eax
	mov	DWORD PTR tv1616[ebp], ebx
$LN58@clip_edge:

; 3799 :   { REAL value = clip_coeff[which][SDIM];

	mov	eax, DWORD PTR tv4005[ebp]
	fld	QWORD PTR _clip_coeff[eax*8]

; 3800 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	cmp	edi, 4
	jl	SHORT $LN53@clip_edge

; 3799 :   { REAL value = clip_coeff[which][SDIM];

	mov	eax, ecx
	mov	ecx, DWORD PTR tv1616[ebp]
	shl	eax, 6
	lea	edx, DWORD PTR [edi-4]
	shr	edx, 2
	add	eax, OFFSET _clip_coeff+8
	inc	edx
	lea	esi, DWORD PTR [edx*4]

; 3800 :     for ( j = 0 ; j < SDIM ; j++ )

$LN43@clip_edge:

; 3801 :       value -= clip_coeff[which][j]*gdata[i].x[j];

	fld	QWORD PTR [eax-8]
	add	ecx, 32					; 00000020H
	fmul	QWORD PTR [ecx-32]
	add	eax, 32					; 00000020H
	dec	edx
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx-24]
	fmul	QWORD PTR [eax-32]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx-16]
	fmul	QWORD PTR [eax-24]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx-8]
	fmul	QWORD PTR [eax-16]
	fsubp	ST(1), ST(0)
	jne	SHORT $LN43@clip_edge

; 3799 :   { REAL value = clip_coeff[which][SDIM];

	mov	ecx, DWORD PTR _which$GSCopy$[ebp]
$LN53@clip_edge:

; 3800 :     for ( j = 0 ; j < SDIM ; j++ )

	cmp	esi, edi
	jge	SHORT $LN41@clip_edge
	lea	edx, DWORD PTR [esi+ecx*8]
	mov	ecx, DWORD PTR tv1529[ebp]
	add	ecx, esi
	mov	eax, edi
	lea	edx, DWORD PTR _clip_coeff[edx*8]
	lea	ecx, DWORD PTR [ebx+ecx*8]
	sub	eax, esi
$LC25@clip_edge:

; 3801 :       value -= clip_coeff[which][j]*gdata[i].x[j];

	fld	QWORD PTR [ecx]
	add	ecx, 8
	fmul	QWORD PTR [edx]
	add	edx, 8
	dec	eax
	fsubp	ST(1), ST(0)
	jne	SHORT $LC25@clip_edge

; 3800 :     for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _which$GSCopy$[ebp]
$LN41@clip_edge:

; 3802 :     if ( value >= 0.0 )

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN27@clip_edge

; 3803 :       innies[in_count++] = i;

	mov	eax, DWORD PTR _in_count$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _innies$[ebp+eax*4], edx
	inc	eax
	mov	DWORD PTR _in_count$[ebp], eax
$LN27@clip_edge:

; 3793 :   int i,j;
; 3794 :   int innies[EDGE_VERTS];
; 3795 :   int in_count = 0;
; 3796 :   
; 3797 :   /* Find which vertices are on which side */
; 3798 :   for ( i = 0 ; i < EDGE_VERTS ; i++ )

	mov	eax, DWORD PTR tv1529[ebp]
	inc	DWORD PTR _i$[ebp]
	add	DWORD PTR tv1616[ebp], 144		; 00000090H
	add	eax, 18					; 00000012H
	mov	DWORD PTR tv1529[ebp], eax
	cmp	eax, 36					; 00000024H
	jl	$LN58@clip_edge

; 3804 :   }
; 3805 :   
; 3806 :   if ( in_count == 0 )

	mov	eax, DWORD PTR _in_count$[ebp]
	test	eax, eax
	je	$LN79@clip_edge

; 3807 :     return; /* nothing to show */
; 3808 : 
; 3809 :   if ( in_count == EDGE_VERTS ) /* don't have to clip */

	cmp	eax, 2
	jne	SHORT $LN20@clip_edge
	fstp	ST(0)

; 3810 :   { if ( which < MAXCLIPS-1 )

	cmp	ecx, 9
	jge	SHORT $LN19@clip_edge

; 3811 :       clip_edge(gdata,id,which+1);

	mov	eax, DWORD PTR _id$[ebp]
	inc	ecx
	push	ecx
	push	eax
	push	ebx
	call	_clip_edge
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 3848 :    
; 3849 : } /* end clip_edge() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@clip_edge:

; 3812 :     else
; 3813 :       (*graph_edge)(gdata,id);

	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	push	ebx
	call	DWORD PTR _graph_edge
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 3848 :    
; 3849 : } /* end clip_edge() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@clip_edge:

; 3814 :     return;
; 3815 :   } 
; 3816 :     
; 3817 :   /* have to clip */
; 3818 :   
; 3819 :   clipg[0] = clipg[1] = gdata[0]; /* id, color, type, etc. */
; 3820 :   if ( innies[0] == 1 )

	cmp	DWORD PTR _innies$[ebp], 1

; 3821 :     for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR _web+616
	mov	ecx, 36					; 00000024H
	mov	esi, ebx
	lea	edi, DWORD PTR _clipg$[ebp+144]
	rep movsd
	mov	ecx, 36					; 00000024H
	mov	esi, ebx
	lea	edi, DWORD PTR _clipg$[ebp]
	rep movsd
	jne	SHORT $LC16@clip_edge
	xor	eax, eax
	cmp	edx, 4
	jl	SHORT $LC45@clip_edge
	lea	esi, DWORD PTR [edx-3]
	lea	ecx, DWORD PTR [ebx+152]
$LN46@clip_edge:

; 3822 :       clipg[0].x[j] = gdata[1].x[j];

	fld	QWORD PTR [ecx-8]
	add	eax, 4
	fstp	QWORD PTR _clipg$[ebp+eax*8-32]
	add	ecx, 32					; 00000020H
	fld	QWORD PTR [ecx-32]
	fstp	QWORD PTR _clipg$[ebp+eax*8-24]
	fld	QWORD PTR [ecx-24]
	fstp	QWORD PTR _clipg$[ebp+eax*8-16]
	fld	QWORD PTR [ecx-16]
	fstp	QWORD PTR _clipg$[ebp+eax*8-8]
	cmp	eax, esi
	jl	SHORT $LN46@clip_edge
$LC45@clip_edge:

; 3821 :     for ( j = 0 ; j < SDIM ; j++ )

	cmp	eax, edx
	jge	SHORT $LC16@clip_edge
	mov	ecx, edx
	sub	ecx, eax
	add	ecx, ecx
	lea	edi, DWORD PTR _clipg$[ebp+eax*8]
	lea	esi, DWORD PTR [ebx+eax*8+144]
	and	ecx, 1073741822				; 3ffffffeH
	rep movsd
$LC16@clip_edge:

; 3827 :     REAL numer=clip_coeff[which][SDIM];

	mov	eax, DWORD PTR tv4005[ebp]
	fld	ST(0)
	fld	QWORD PTR _clip_coeff[eax*8]

; 3828 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	cmp	edx, 4
	jl	SHORT $LN55@clip_edge

; 3823 :   
; 3824 :   /* find intersections of clip plane with edge */
; 3825 :   { REAL lambda;
; 3826 :     REAL denom=0;

	mov	ecx, DWORD PTR _which$GSCopy$[ebp]
	shl	ecx, 6
	lea	edi, DWORD PTR [edx-4]
	shr	edi, 2
	add	ecx, OFFSET _clip_coeff+8
	inc	edi
	lea	eax, DWORD PTR [ebx+8]
	lea	esi, DWORD PTR [edi*4]

; 3828 :     for ( j = 0 ; j < SDIM ; j++ )

$LN49@clip_edge:

; 3829 :     { numer -= clip_coeff[which][j]*gdata[0].x[j];

	fld	QWORD PTR [ecx-8]

; 3830 :       denom += clip_coeff[which][j]*(gdata[1].x[j] - gdata[0].x[j]);

	add	eax, 32					; 00000020H
	fmul	QWORD PTR [eax-40]
	add	ecx, 32					; 00000020H
	dec	edi
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [eax-32]
	fmul	QWORD PTR [ecx-32]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx-24]
	fmul	QWORD PTR [eax-24]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx-16]
	fmul	QWORD PTR [eax-16]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [eax+104]
	fsub	QWORD PTR [eax-40]
	fmul	QWORD PTR [ecx-40]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [eax+112]
	fsub	QWORD PTR [eax-32]
	fmul	QWORD PTR [ecx-32]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [eax+120]
	fsub	QWORD PTR [eax-24]
	fmul	QWORD PTR [ecx-24]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [eax+128]
	fsub	QWORD PTR [eax-16]
	fmul	QWORD PTR [ecx-16]
	faddp	ST(2), ST(0)
	jne	SHORT $LN49@clip_edge
$LN55@clip_edge:

; 3828 :     for ( j = 0 ; j < SDIM ; j++ )

	cmp	esi, edx
	jge	SHORT $LN56@clip_edge
	mov	ecx, DWORD PTR _which$GSCopy$[ebp]
	lea	eax, DWORD PTR [esi+ecx*8]
	lea	eax, DWORD PTR _clip_coeff[eax*8]
$LC13@clip_edge:

; 3829 :     { numer -= clip_coeff[which][j]*gdata[0].x[j];

	fld	QWORD PTR [ebx+esi*8]
	inc	esi
	fmul	QWORD PTR [eax]
	add	eax, 8
	fsubp	ST(1), ST(0)

; 3830 :       denom += clip_coeff[which][j]*(gdata[1].x[j] - gdata[0].x[j]);

	fld	QWORD PTR [ebx+esi*8+136]
	fsub	QWORD PTR [ebx+esi*8-8]
	fmul	QWORD PTR [eax-8]
	faddp	ST(2), ST(0)
	cmp	esi, edx
	jl	SHORT $LC13@clip_edge
$LN56@clip_edge:

; 3831 :     }
; 3832 :     if ( denom == 0.0 )

	fld	ST(1)
	fld	ST(3)
	fucompp
	fnstsw	ax
	fld1
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@clip_edge
	fstp	ST(2)
	fstp	ST(0)

; 3833 :       lambda = 0;
; 3834 :     else 

	jmp	SHORT $LN6@clip_edge
$LN10@clip_edge:

; 3835 :       lambda = numer/denom;

	fxch	ST(1)
	fdivrp	ST(2), ST(0)

; 3836 :     if ( lambda < 0.0 ) lambda = 0.0;

	fxch	ST(1)
	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN118@clip_edge
	fstp	ST(0)
	jmp	SHORT $LN6@clip_edge
$LN118@clip_edge:
	fstp	ST(2)

; 3837 :     else if ( lambda > 1.0 ) lambda = 1.0;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@clip_edge
	fstp	ST(1)
	fld	ST(0)
	fxch	ST(1)
$LN6@clip_edge:

; 3838 : 
; 3839 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	cmp	edx, 4
	jl	$LN59@clip_edge

; 3840 :       clipg[1].x[j] = lambda*gdata[1].x[j] + (1-lambda)*gdata[0].x[j];

	lea	ecx, DWORD PTR _clipg$[ebp+144]
	fld	ST(0)
	sub	ecx, ebx
	fsub	ST(0), ST(2)
	mov	DWORD PTR tv3668[ebp], ecx
	lea	ecx, DWORD PTR _clipg$[ebp+152]
	sub	ecx, ebx
	mov	DWORD PTR tv3672[ebp], ecx
	lea	ecx, DWORD PTR _clipg$[ebp+160]
	sub	ecx, ebx
	mov	DWORD PTR tv3676[ebp], ecx
	lea	ecx, DWORD PTR [edx-4]
	lea	esi, DWORD PTR _clipg$[ebp+136]
	shr	ecx, 2
	sub	esi, ebx
	inc	ecx
	lea	edi, DWORD PTR [ecx*4]
	lea	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _j$[ebp], edi
$LN52@clip_edge:
	fld	QWORD PTR [eax+136]
	mov	edi, DWORD PTR tv3668[ebp]
	fmul	ST(0), ST(3)
	add	eax, 32					; 00000020H
	dec	ecx
	fld	QWORD PTR [eax-40]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+eax-32]
	fld	QWORD PTR [eax+112]
	fmul	ST(0), ST(3)
	fld	ST(1)
	fmul	QWORD PTR [eax-32]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv3672[ebp]
	fld	QWORD PTR [eax+120]
	fmul	ST(0), ST(3)
	fld	QWORD PTR [eax-24]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv3676[ebp]
	fld	QWORD PTR [eax+128]
	fmul	ST(0), ST(3)
	fld	QWORD PTR [eax-16]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edi+eax-32]
	jne	SHORT $LN52@clip_edge

; 3838 : 
; 3839 :     for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _j$[ebp]
	fstp	ST(0)
$LN59@clip_edge:
	cmp	esi, edx
	jge	SHORT $LN116@clip_edge
	lea	ecx, DWORD PTR _clipg$[ebp+144]
	fsub	ST(0), ST(1)
	sub	ecx, ebx
	lea	eax, DWORD PTR [ebx+esi*8]
	sub	edx, esi
$LC5@clip_edge:

; 3840 :       clipg[1].x[j] = lambda*gdata[1].x[j] + (1-lambda)*gdata[0].x[j];

	fld	QWORD PTR [eax+144]
	add	eax, 8
	dec	edx
	fmul	ST(0), ST(2)
	fld	ST(1)
	fmul	QWORD PTR [eax-8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax+ecx-8]
	jne	SHORT $LC5@clip_edge
$LN116@clip_edge:

; 3841 :   }
; 3842 : 
; 3843 :  
; 3844 :   if ( which < MAXCLIPS-1 )

	mov	eax, DWORD PTR _which$GSCopy$[ebp]
	fstp	ST(1)
	fstp	ST(0)
	cmp	eax, 9
	jge	SHORT $LN2@clip_edge

; 3845 :     clip_edge(clipg,id,which+1);

	mov	edx, DWORD PTR _id$[ebp]
	inc	eax
	push	eax
	push	edx
	lea	eax, DWORD PTR _clipg$[ebp]
	push	eax
	call	_clip_edge
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 3848 :    
; 3849 : } /* end clip_edge() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@clip_edge:

; 3846 :   else
; 3847 :     (*graph_edge)(clipg,id);

	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	lea	edx, DWORD PTR _clipg$[ebp]
	push	edx
	call	DWORD PTR _graph_edge
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 3848 :    
; 3849 : } /* end clip_edge() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN79@clip_edge:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_clip_edge ENDP
_TEXT	ENDS
PUBLIC	_which$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_clip_facet
; Function compile flags: /Ogtp
;	COMDAT _clip_facet
_TEXT	SEGMENT
_pair$ = -1220						; size = 8
tv5449 = -1212						; size = 4
_which$GSCopy$ = -1208					; size = 4
tv5145 = -1204						; size = 4
tv3588 = -1204						; size = 4
_in_count$ = -1200					; size = 4
tv5385 = -1196						; size = 4
tv1921 = -1196						; size = 4
tv5213 = -1192						; size = 4
tv1885 = -1192						; size = 4
tv1860 = -1188						; size = 4
_oddie$ = -1188						; size = 4
tv5383 = -1184						; size = 4
_i$ = -1184						; size = 4
_clipg$ = -1180						; size = 1152
_outies$ = -28						; size = 12
_innies$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_gdata$ = 8						; size = 4
_f_id$ = 12						; size = 4
_which$ = 16						; size = 4
_clip_facet PROC					; COMDAT

; 3866 : { struct graphdata clipg[2][FACET_VERTS+1];  // +1 for wraparound

	push	ebp
	mov	ebp, esp
	sub	esp, 1220				; 000004c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	edx, DWORD PTR _which$[ebp]

; 3880 :     if ( value >= 0.0 )
; 3881 :       innies[in_count++] = i;

	fldz
	push	ebx
	mov	ebx, DWORD PTR _gdata$[ebp]
	push	esi
	mov	esi, DWORD PTR _web+616
	xor	eax, eax
	lea	ecx, DWORD PTR [esi+edx*8]
	mov	DWORD PTR _in_count$[ebp], eax
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR tv5449[ebp], ecx
	mov	DWORD PTR tv1860[ebp], eax
	lea	eax, DWORD PTR _outies$[ebp]
	mov	ecx, ebx
	push	edi
	mov	DWORD PTR _which$GSCopy$[ebp], edx
	mov	DWORD PTR tv1885[ebp], eax
	mov	DWORD PTR tv1921[ebp], ecx
$LN66@clip_facet:

; 3877 :   { REAL value = clip_coeff[which][SDIM];

	mov	eax, DWORD PTR tv5449[ebp]
	fld	QWORD PTR _clip_coeff[eax*8]

; 3878 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	cmp	esi, 4
	jl	SHORT $LN64@clip_facet

; 3877 :   { REAL value = clip_coeff[which][SDIM];

	mov	eax, edx
	add	esi, -4					; fffffffcH
	shl	eax, 6
	shr	esi, 2
	add	eax, OFFSET _clip_coeff+8
	inc	esi
	lea	edi, DWORD PTR [esi*4]

; 3878 :     for ( j = 0 ; j < SDIM ; j++ )

$LN57@clip_facet:

; 3879 :       value -= clip_coeff[which][j]*gdata[i].x[j];

	fld	QWORD PTR [eax-8]
	add	ecx, 32					; 00000020H
	fmul	QWORD PTR [ecx-32]
	add	eax, 32					; 00000020H
	dec	esi
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx-24]
	fmul	QWORD PTR [eax-32]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx-16]
	fmul	QWORD PTR [eax-24]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx-8]
	fmul	QWORD PTR [eax-16]
	fsubp	ST(1), ST(0)
	jne	SHORT $LN57@clip_facet

; 3877 :   { REAL value = clip_coeff[which][SDIM];

	mov	esi, DWORD PTR _web+616
$LN64@clip_facet:

; 3878 :     for ( j = 0 ; j < SDIM ; j++ )

	cmp	edi, esi
	jge	SHORT $LN55@clip_facet
	mov	ecx, DWORD PTR tv1860[ebp]
	mov	eax, DWORD PTR _web+616
	add	ecx, edi
	lea	esi, DWORD PTR [edi+edx*8]
	lea	esi, DWORD PTR _clip_coeff[esi*8]
	lea	ecx, DWORD PTR [ebx+ecx*8]
	sub	eax, edi
$LC39@clip_facet:

; 3879 :       value -= clip_coeff[which][j]*gdata[i].x[j];

	fld	QWORD PTR [esi]
	add	ecx, 8
	fmul	QWORD PTR [ecx-8]
	add	esi, 8
	dec	eax
	fsubp	ST(1), ST(0)
	jne	SHORT $LC39@clip_facet

; 3878 :     for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _web+616
$LN55@clip_facet:

; 3880 :     if ( value >= 0.0 )
; 3881 :       innies[in_count++] = i;

	mov	ecx, DWORD PTR _i$[ebp]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN36@clip_facet
	mov	eax, DWORD PTR _in_count$[ebp]
	mov	DWORD PTR _innies$[ebp+eax*4], ecx
	inc	eax
	mov	DWORD PTR _in_count$[ebp], eax

; 3882 :     else

	jmp	SHORT $LN41@clip_facet
$LN36@clip_facet:

; 3883 :       outies[out_count++] = i;

	mov	eax, DWORD PTR tv1885[ebp]
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	mov	DWORD PTR tv1885[ebp], eax
$LN41@clip_facet:

; 3867 :   int i,j;
; 3868 :   int innies[FACET_VERTS]; /* which vertices in clip space */
; 3869 :   int in_count=0;
; 3870 :   int outies[FACET_VERTS];  /* which vertices out of clip space */
; 3871 :   int out_count=0;
; 3872 :   int oddie;  /* odd vertex, in or out */
; 3873 :   int pair[2]; /* the other pair */
; 3874 : 
; 3875 :   /* Find which vertices are on which side and */
; 3876 :   for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR tv1860[ebp]
	mov	ecx, DWORD PTR tv1921[ebp]
	inc	DWORD PTR _i$[ebp]
	add	eax, 18					; 00000012H
	add	ecx, 144				; 00000090H
	mov	DWORD PTR tv1921[ebp], ecx
	mov	DWORD PTR tv1860[ebp], eax
	cmp	eax, 54					; 00000036H
	jl	$LN66@clip_facet

; 3884 :   }
; 3885 :   
; 3886 :   if ( in_count == 0 )

	mov	eax, DWORD PTR _in_count$[ebp]
	test	eax, eax
	je	$LN87@clip_facet

; 3887 :     return; /* nothing to show */
; 3888 : 
; 3889 :   if ( in_count == 3 ) /* don't have to clip */

	cmp	eax, 3
	jne	SHORT $LN33@clip_facet
	fstp	ST(0)

; 3890 :   { if ( which < MAXCLIPS-1 )

	cmp	edx, 9
	jge	SHORT $LN32@clip_facet

; 3891 :       clip_facet(gdata,f_id,which+1);

	inc	edx
	push	edx
	mov	edx, DWORD PTR _f_id$[ebp]
	push	edx
	push	ebx
	call	_clip_facet
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 4007 :   
; 4008 : } /* end clip_facet() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@clip_facet:

; 3892 :     else
; 3893 :       (*graph_facet)(gdata,f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	push	ebx
	call	DWORD PTR _graph_facet
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 4007 :   
; 4008 : } /* end clip_facet() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@clip_facet:

; 3894 :     return;
; 3895 :   } 
; 3896 :     
; 3897 :   /* have to clip, maybe 2 facets result */
; 3898 :   
; 3899 :   clipg[0][0] = clipg[0][1] = gdata[0]; /* facet id, color, normsl, etc. */

	mov	ecx, 36					; 00000024H
	mov	esi, ebx
	lea	edi, DWORD PTR _clipg$[ebp+144]
	rep movsd

; 3900 :   clipg[0][0].etype = INVISIBLE_EDGE;
; 3901 :   clipg[0][1].etype = INVISIBLE_EDGE;

	xor	eax, eax
	mov	ecx, 36					; 00000024H
	mov	esi, ebx
	lea	edi, DWORD PTR _clipg$[ebp]
	rep movsd
	xor	ecx, ecx
	mov	WORD PTR _clipg$[ebp+268], ax

; 3902 :   clipg[0][0].ecolor = CLEAR;

	or	eax, -1

; 3903 :   clipg[0][1].ecolor = CLEAR;
; 3904 :   
; 3905 :   if ( in_count == 1 )

	cmp	DWORD PTR _in_count$[ebp], 1
	mov	WORD PTR _clipg$[ebp+124], cx
	mov	DWORD PTR _clipg$[ebp+120], eax
	mov	DWORD PTR _clipg$[ebp+264], eax
	jne	SHORT $LN30@clip_facet

; 3906 :   { oddie = innies[0];
; 3907 :     pair[0] = outies[0];

	mov	eax, DWORD PTR _outies$[ebp]
	mov	ecx, DWORD PTR _innies$[ebp]
	mov	DWORD PTR _pair$[ebp], eax

; 3908 :     pair[1] = outies[1];

	mov	eax, DWORD PTR _outies$[ebp+4]

; 3909 :   }
; 3910 :   else /* in_count == 2 */

	jmp	SHORT $LN130@clip_facet
$LN30@clip_facet:

; 3911 :   { oddie = outies[0];
; 3912 :     pair[0] = innies[0];

	mov	eax, DWORD PTR _innies$[ebp]
	mov	ecx, DWORD PTR _outies$[ebp]
	mov	DWORD PTR _pair$[ebp], eax

; 3913 :     pair[1] = innies[1];

	mov	eax, DWORD PTR _innies$[ebp+4]
$LN130@clip_facet:

; 3914 :   }
; 3915 : 
; 3916 :   /* find intersections of clip plane with facet edges */
; 3917 :   for ( i = 0 ; i < 2 ; i++ )

	fld1
	mov	DWORD PTR _pair$[ebp+4], eax
	lea	eax, DWORD PTR _pair$[ebp]
	mov	DWORD PTR tv5383[ebp], eax
	lea	eax, DWORD PTR _clipg$[ebp+8]
	mov	DWORD PTR _oddie$[ebp], ecx
	mov	DWORD PTR tv5213[ebp], 0
	mov	DWORD PTR tv5385[ebp], eax
	jmp	SHORT $LN28@clip_facet
$LN65@clip_facet:
	mov	edx, DWORD PTR _which$GSCopy$[ebp]
$LN28@clip_facet:

; 3920 :     REAL numer=clip_coeff[which][SDIM];

	mov	eax, DWORD PTR tv5449[ebp]
	fld	ST(1)
	fld	QWORD PTR _clip_coeff[eax*8]

; 3921 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	cmp	DWORD PTR _web+616, 4
	jl	$LC59@clip_facet

; 3918 :   { REAL lambda;
; 3919 :     REAL denom=0;

	mov	esi, DWORD PTR _web+616
	mov	eax, edx
	lea	edx, DWORD PTR [ecx+ecx*8]
	mov	ecx, DWORD PTR tv5383[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	esi, -4					; fffffffcH
	shl	eax, 6
	shl	edx, 4
	lea	ecx, DWORD PTR [ecx+ecx*8]
	add	ecx, ecx
	shr	esi, 2
	add	eax, OFFSET _clip_coeff+8
	add	edx, ebx
	inc	esi
	lea	ecx, DWORD PTR [ebx+ecx*8+16]
	lea	edi, DWORD PTR [esi*4]

; 3921 :     for ( j = 0 ; j < SDIM ; j++ )

$LN60@clip_facet:

; 3922 :     { numer -= clip_coeff[which][j]*gdata[pair[i]].x[j];

	fld	QWORD PTR [ecx-16]

; 3923 :       denom += clip_coeff[which][j]*(gdata[oddie].x[j] - gdata[pair[i]].x[j]);

	add	edx, 32					; 00000020H
	fmul	QWORD PTR [eax-8]
	add	ecx, 32					; 00000020H
	add	eax, 32					; 00000020H
	dec	esi
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx-40]
	fmul	QWORD PTR [eax-32]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [eax-24]
	fmul	QWORD PTR [ecx-32]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx-24]
	fmul	QWORD PTR [eax-16]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [edx-32]
	fsub	QWORD PTR [ecx-48]
	fmul	QWORD PTR [eax-40]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edx-24]
	fsub	QWORD PTR [ecx-40]
	fmul	QWORD PTR [eax-32]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edx-16]
	fsub	QWORD PTR [ecx-32]
	fmul	QWORD PTR [eax-24]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edx-8]
	fsub	QWORD PTR [ecx-24]
	fmul	QWORD PTR [eax-16]
	faddp	ST(2), ST(0)
	jne	SHORT $LN60@clip_facet

; 3918 :   { REAL lambda;
; 3919 :     REAL denom=0;

	mov	ecx, DWORD PTR _oddie$[ebp]
	mov	edx, DWORD PTR _which$GSCopy$[ebp]
$LC59@clip_facet:

; 3921 :     for ( j = 0 ; j < SDIM ; j++ )

	cmp	edi, DWORD PTR _web+616
	jge	SHORT $LN58@clip_facet
	lea	esi, DWORD PTR [edi+edx*8]
	mov	edx, DWORD PTR tv5383[ebp]
	mov	eax, DWORD PTR [edx]
	lea	eax, DWORD PTR [eax+eax*8]
	lea	edx, DWORD PTR [edi+eax*2]
	lea	eax, DWORD PTR [ebx+edx*8]
	lea	edx, DWORD PTR [ecx+ecx*8]
	lea	edx, DWORD PTR [edi+edx*2]
	lea	edx, DWORD PTR [ebx+edx*8]
	mov	DWORD PTR tv3588[ebp], edx
	mov	edx, DWORD PTR _web+616
	sub	edx, edi
	mov	edi, DWORD PTR tv3588[ebp]
	lea	esi, DWORD PTR _clip_coeff[esi*8]
$LC25@clip_facet:

; 3922 :     { numer -= clip_coeff[which][j]*gdata[pair[i]].x[j];

	fld	QWORD PTR [eax]
	add	edi, 8
	fmul	QWORD PTR [esi]
	add	eax, 8
	add	esi, 8
	dec	edx
	fsubp	ST(1), ST(0)

; 3923 :       denom += clip_coeff[which][j]*(gdata[oddie].x[j] - gdata[pair[i]].x[j]);

	fld	QWORD PTR [edi-8]
	fsub	QWORD PTR [eax-8]
	fmul	QWORD PTR [esi-8]
	faddp	ST(2), ST(0)
	jne	SHORT $LC25@clip_facet
$LN58@clip_facet:

; 3924 :     }
; 3925 :     if ( denom == 0.0 )

	fld	ST(1)
	fld	ST(4)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN22@clip_facet
	fstp	ST(1)
	fstp	ST(0)

; 3926 :       lambda = 0;

	fld	ST(1)

; 3927 :     else 

	jmp	SHORT $LN18@clip_facet
$LN22@clip_facet:

; 3928 :       lambda = numer/denom;

	fdivrp	ST(1), ST(0)

; 3929 :     if ( lambda < 0.0 ) lambda = 0.0;

	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN20@clip_facet
	fstp	ST(0)
	fld	ST(1)
	jmp	SHORT $LN18@clip_facet
$LN20@clip_facet:

; 3930 :     else if ( lambda > 1.0 ) lambda = 1.0;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN18@clip_facet
	fstp	ST(0)
	fld	ST(0)
$LN18@clip_facet:

; 3931 : 
; 3932 :     for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _web+616
	xor	edx, edx
	cmp	edi, 4
	jl	$LC62@clip_facet
	mov	esi, DWORD PTR tv5385[ebp]
	fld	ST(1)
	lea	eax, DWORD PTR [ecx+ecx*8]
	fsub	ST(0), ST(1)
	mov	ecx, DWORD PTR tv5383[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	edi, -4					; fffffffcH
	shl	eax, 4
	lea	edx, DWORD PTR [ecx+ecx*8]
	add	edx, edx
	shr	edi, 2
	add	eax, ebx
	inc	edi
	lea	ecx, DWORD PTR [ebx+edx*8+16]
	lea	edx, DWORD PTR [edi*4]
$LN63@clip_facet:

; 3933 :       clipg[0][i].x[j] = lambda*gdata[oddie].x[j] + (1-lambda)*gdata[pair[i]].x[j];

	fld	QWORD PTR [ecx-16]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	ecx, 32					; 00000020H
	fld	QWORD PTR [eax-32]
	add	esi, 32					; 00000020H
	dec	edi
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi-40]
	fld	QWORD PTR [ecx-40]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [eax-24]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi-32]
	fld	QWORD PTR [eax-16]
	fmul	ST(0), ST(2)
	fld	ST(1)
	fmul	QWORD PTR [ecx-32]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi-24]
	fld	QWORD PTR [ecx-24]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi-16]
	jne	SHORT $LN63@clip_facet

; 3931 : 
; 3932 :     for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _oddie$[ebp]
	fstp	ST(0)
	mov	edi, DWORD PTR _web+616
$LC62@clip_facet:
	cmp	edx, edi
	jge	SHORT $LN118@clip_facet
	mov	eax, DWORD PTR tv5213[ebp]
	fld	ST(1)
	add	eax, edx
	fsub	ST(0), ST(1)
	lea	eax, DWORD PTR _clipg$[ebp+eax*8]
	mov	DWORD PTR tv5145[ebp], eax
	lea	eax, DWORD PTR [ecx+ecx*8]
	lea	eax, DWORD PTR [edx+eax*2]
	lea	edi, DWORD PTR [ebx+eax*8]
	mov	eax, DWORD PTR tv5383[ebp]
	mov	eax, DWORD PTR [eax]
	lea	eax, DWORD PTR [eax+eax*8]
	lea	eax, DWORD PTR [edx+eax*2]
	lea	esi, DWORD PTR [ebx+eax*8]
	mov	eax, DWORD PTR _web+616
	sub	eax, edx
$LC17@clip_facet:

; 3933 :       clipg[0][i].x[j] = lambda*gdata[oddie].x[j] + (1-lambda)*gdata[pair[i]].x[j];

	fld	QWORD PTR [edi]
	mov	edx, DWORD PTR tv5145[ebp]
	fmul	ST(0), ST(2)
	add	edx, 8
	fld	ST(1)
	add	esi, 8
	fmul	QWORD PTR [esi-8]
	add	edi, 8
	dec	eax
	mov	DWORD PTR tv5145[ebp], edx
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx-8]
	jne	SHORT $LC17@clip_facet

; 3931 : 
; 3932 :     for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(1)
$LN118@clip_facet:

; 3914 :   }
; 3915 : 
; 3916 :   /* find intersections of clip plane with facet edges */
; 3917 :   for ( i = 0 ; i < 2 ; i++ )

	mov	eax, DWORD PTR tv5213[ebp]

; 3931 : 
; 3932 :     for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
	add	DWORD PTR tv5385[ebp], 144		; 00000090H
	add	DWORD PTR tv5383[ebp], 4
	add	eax, 18					; 00000012H
	mov	DWORD PTR tv5213[ebp], eax
	cmp	eax, 36					; 00000024H
	jl	$LN65@clip_facet

; 3934 :   }
; 3935 : 
; 3936 :   if ( in_count == 1 )

	cmp	DWORD PTR _in_count$[ebp], 1
	fstp	ST(1)
	fstp	ST(0)

; 3939 :     { clipg[0][2] = clipg[0][1];

	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _clipg$[ebp+288]
	jne	$LN14@clip_facet

; 3937 :   { /* third vertex is innie */
; 3938 :     if ( innies[0] == 0 )

	mov	eax, DWORD PTR _innies$[ebp]
	test	eax, eax
	jne	SHORT $LN13@clip_facet

; 3940 :       clipg[0][1] = clipg[0][0];
; 3941 :       clipg[0][0] = gdata[0];
; 3942 :       clipg[0][2].ecolor = gdata[2].ecolor;
; 3943 :       clipg[0][2].etype = gdata[2].etype;

	mov	dx, WORD PTR [ebx+412]
	lea	esi, DWORD PTR _clipg$[ebp+144]
	rep movsd
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _clipg$[ebp]
	lea	edi, DWORD PTR _clipg$[ebp+144]
	rep movsd
	mov	ecx, 36					; 00000024H
	mov	esi, ebx
	lea	edi, DWORD PTR _clipg$[ebp]
	rep movsd
	mov	ecx, DWORD PTR [ebx+408]
	mov	DWORD PTR _clipg$[ebp+408], ecx
	mov	WORD PTR _clipg$[ebp+412], dx
	jmp	$LN3@clip_facet
$LN13@clip_facet:

; 3944 :     }
; 3945 :     else if ( innies[0] == 1 )

	cmp	eax, 1
	jne	SHORT $LN11@clip_facet

; 3946 :     { clipg[0][2] = clipg[0][1];
; 3947 :       clipg[0][1] = gdata[1];
; 3948 :       clipg[0][0].etype = gdata[0].etype;

	mov	ax, WORD PTR [ebx+124]
	lea	esi, DWORD PTR _clipg$[ebp+144]
	rep movsd
	lea	esi, DWORD PTR [ebx+144]
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _clipg$[ebp+144]
	rep movsd

; 3949 :       clipg[0][0].ecolor = gdata[0].ecolor;

	mov	ecx, DWORD PTR [ebx+120]
	mov	WORD PTR _clipg$[ebp+124], ax
	mov	DWORD PTR _clipg$[ebp+120], ecx

; 3950 :     }
; 3951 :     else

	jmp	$LN3@clip_facet
$LN11@clip_facet:

; 3952 :       clipg[0][2] = gdata[innies[0]];

	lea	esi, DWORD PTR [eax+eax*8]
	shl	esi, 4
	add	esi, ebx
	rep movsd

; 3953 : 
; 3954 :   }
; 3955 :   else /* two innies, so have to split */

	jmp	$LN3@clip_facet
$LN14@clip_facet:

; 3956 :   { clipg[1][0] = clipg[1][1] = gdata[0]; /* facet id, color, etc */
; 3957 :     clipg[1][0].etype = INVISIBLE_EDGE;
; 3958 :     clipg[1][1].etype = INVISIBLE_EDGE;
; 3959 :     clipg[1][0].ecolor = CLEAR;
; 3960 :     clipg[1][1].ecolor = CLEAR;
; 3961 :  
; 3962 :     if ( outies[0] == 0 )

	mov	eax, DWORD PTR _outies$[ebp]
	test	eax, eax
	jne	SHORT $LN8@clip_facet

; 3963 :     { clipg[0][2] = clipg[0][1];
; 3964 :       clipg[0][1] = gdata[1];
; 3965 :       clipg[0][0].etype = gdata[0].etype;

	mov	dx, WORD PTR [ebx+124]
	lea	esi, DWORD PTR _clipg$[ebp+144]
	rep movsd
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR [ebx+144]
	lea	edi, DWORD PTR _clipg$[ebp+144]
	rep movsd

; 3966 :       clipg[0][0].ecolor = gdata[0].ecolor;

	mov	ecx, DWORD PTR [ebx+120]
	mov	WORD PTR _clipg$[ebp+124], dx
	mov	DWORD PTR _clipg$[ebp+120], ecx

; 3967 :       clipg[0][1].etype = INVISIBLE_EDGE;   

	xor	edx, edx
	mov	WORD PTR _clipg$[ebp+268], dx

; 3968 :       clipg[0][1].ecolor = CLEAR;   

	mov	DWORD PTR _clipg$[ebp+264], -1

; 3969 :       clipg[1][0] = clipg[0][2];

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _clipg$[ebp+288]
	lea	edi, DWORD PTR _clipg$[ebp+576]
	rep movsd

; 3970 :       clipg[1][1] = gdata[1];

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR [ebx+144]
	lea	edi, DWORD PTR _clipg$[ebp+720]
	rep movsd

; 3971 :       clipg[1][2] = gdata[2];

	jmp	SHORT $LN131@clip_facet
$LN8@clip_facet:

; 3972 :     }
; 3973 :     else if ( outies[0] == 1 )

	cmp	eax, 1
	jne	SHORT $LN6@clip_facet

; 3974 :     { clipg[0][2] = gdata[0];
; 3975 :       clipg[1][0] = gdata[0];
; 3976 :       clipg[1][0].etype = INVISIBLE_EDGE;
; 3977 :       clipg[1][0].ecolor = CLEAR;
; 3978 :       clipg[1][1] = clipg[0][1];
; 3979 :       clipg[1][1].etype = gdata[1].etype;
; 3980 :       clipg[1][1].ecolor = gdata[1].ecolor;

	mov	edx, DWORD PTR [ebx+264]
	mov	esi, ebx
	rep movsd
	mov	ecx, 36					; 00000024H
	mov	esi, ebx
	lea	edi, DWORD PTR _clipg$[ebp+576]
	rep movsd
	xor	eax, eax
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _clipg$[ebp+144]
	lea	edi, DWORD PTR _clipg$[ebp+720]
	mov	WORD PTR _clipg$[ebp+700], ax
	mov	DWORD PTR _clipg$[ebp+696], -1
	rep movsd
	mov	cx, WORD PTR [ebx+268]
	mov	WORD PTR _clipg$[ebp+844], cx
	mov	DWORD PTR _clipg$[ebp+840], edx
$LN131@clip_facet:

; 3981 :       clipg[1][2] = gdata[2];

	lea	esi, DWORD PTR [ebx+288]
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _clipg$[ebp+864]
	rep movsd

; 3982 :     }
; 3983 :     else

	jmp	SHORT $LN5@clip_facet
$LN6@clip_facet:

; 3984 :     { 
; 3985 :       clipg[0][2] = clipg[0][1];
; 3986 :       clipg[0][1] = gdata[1];
; 3987 :       clipg[1][0] = gdata[0];
; 3988 :       clipg[1][1] = gdata[1];
; 3989 :       clipg[1][1].etype = INVISIBLE_EDGE;
; 3990 :       clipg[1][1].ecolor = CLEAR;
; 3991 :       clipg[1][2] = clipg[0][0];
; 3992 :       clipg[1][2].etype = gdata[2].etype;
; 3993 :       clipg[1][2].ecolor = gdata[2].ecolor;

	mov	edx, DWORD PTR [ebx+408]
	lea	esi, DWORD PTR _clipg$[ebp+144]
	rep movsd
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR [ebx+144]
	lea	edi, DWORD PTR _clipg$[ebp+144]
	rep movsd
	mov	ecx, 36					; 00000024H
	mov	esi, ebx
	lea	edi, DWORD PTR _clipg$[ebp+576]
	rep movsd
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR [ebx+144]
	lea	edi, DWORD PTR _clipg$[ebp+720]
	rep movsd
	xor	eax, eax
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _clipg$[ebp]
	lea	edi, DWORD PTR _clipg$[ebp+864]
	mov	WORD PTR _clipg$[ebp+844], ax
	mov	DWORD PTR _clipg$[ebp+840], -1
	rep movsd
	mov	cx, WORD PTR [ebx+412]
	mov	WORD PTR _clipg$[ebp+988], cx
	mov	DWORD PTR _clipg$[ebp+984], edx
$LN5@clip_facet:

; 3994 :     }  
; 3995 :   
; 3996 :     if ( which < MAXCLIPS-1 )

	mov	eax, DWORD PTR _which$GSCopy$[ebp]
	cmp	eax, 9
	jge	SHORT $LN4@clip_facet

; 3997 :       clip_facet(clipg[1],f_id,which+1);

	inc	eax
	push	eax
	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	lea	ecx, DWORD PTR _clipg$[ebp+576]
	push	ecx
	call	_clip_facet
	add	esp, 12					; 0000000cH

; 3998 :     else

	jmp	SHORT $LN3@clip_facet
$LN4@clip_facet:

; 3999 :       (*graph_facet)(clipg[1],f_id);

	mov	edx, DWORD PTR _f_id$[ebp]
	push	edx
	lea	eax, DWORD PTR _clipg$[ebp+576]
	push	eax
	call	DWORD PTR _graph_facet
	add	esp, 8
$LN3@clip_facet:

; 4000 : 
; 4001 :   }
; 4002 :  
; 4003 :   if ( which < MAXCLIPS-1 )

	mov	eax, DWORD PTR _which$GSCopy$[ebp]
	cmp	eax, 9
	jge	SHORT $LN2@clip_facet

; 4004 :     clip_facet(clipg[0],f_id,which+1);

	mov	ecx, DWORD PTR _f_id$[ebp]
	inc	eax
	push	eax
	push	ecx
	lea	edx, DWORD PTR _clipg$[ebp]
	push	edx
	call	_clip_facet
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 4007 :   
; 4008 : } /* end clip_facet() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@clip_facet:

; 4005 :   else
; 4006 :     (*graph_facet)(clipg[0],f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	lea	ecx, DWORD PTR _clipg$[ebp]
	push	ecx
	call	DWORD PTR _graph_facet
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 4007 :   
; 4008 : } /* end clip_facet() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN87@clip_facet:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_clip_facet ENDP
_TEXT	ENDS
PUBLIC	_graph_facet_transforms
PUBLIC	__real@4008000000000000
PUBLIC	??_C@_0DB@NNKLNLFD@Triangle?5spans?5too?5many?5periods?4@ ; `string'
PUBLIC	__real@3e45798ee2308c3a
PUBLIC	_gdata$GSCopy$
PUBLIC	_m$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_torus_clip
EXTRN	_torus_display_mode:DWORD
EXTRN	_erroutstring:PROC
EXTRN	_sprintf:PROC
EXTRN	_msg:DWORD
EXTRN	_clip_view_flag:DWORD
EXTRN	_slice_view_flag:DWORD
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT ??_C@_0DB@NNKLNLFD@Triangle?5spans?5too?5many?5periods?4@
CONST	SEGMENT
??_C@_0DB@NNKLNLFD@Triangle?5spans?5too?5many?5periods?4@ DB 'Triangle sp'
	DB	'ans too many periods. Wraps %d %d %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@3e45798ee2308c3a
CONST	SEGMENT
__real@3e45798ee2308c3a DQ 03e45798ee2308c3ar	; 1e-008
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _torus_clip
_TEXT	SEGMENT
tv2888 = -1840						; size = 8
tv2378 = -1840						; size = 8
_pair1$90794 = -1836					; size = 4
_ww$90785 = -1836					; size = 4
tv2775 = -1832						; size = 8
tv2751 = -1832						; size = 8
tv2382 = -1832						; size = 8
tv2380 = -1832						; size = 8
_a$ = -1832						; size = 8
tv981 = -1828						; size = 4
tv1587 = -1824						; size = 4
tv1507 = -1824						; size = 4
tv1046 = -1824						; size = 4
_gdata$GSCopy$ = -1820					; size = 4
_oddman$ = -1820					; size = 4
_ww$90828 = -1816					; size = 4
_per$ = -1816						; size = 4
_invper$ = -1812					; size = 4
tv2524 = -1808						; size = 4
tv2394 = -1808						; size = 4
tv2011 = -1808						; size = 4
tv476 = -1808						; size = 4
_m$GSCopy$ = -1804					; size = 4
tv2529 = -1800						; size = 4
tv2361 = -1800						; size = 4
tv1816 = -1800						; size = 4
_pair2$90795 = -1800					; size = 4
_oddflag$ = -1800					; size = 4
_cut$ = -1796						; size = 4
_mm$ = -1796						; size = 4
_oddwrap$ = -1796					; size = 4
_gdata2$ = -1792					; size = 576
_gdata1$ = -1216					; size = 576
_gdata0$ = -640						; size = 576
_orig$ = -64						; size = 48
_wrap$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_gdata$ = 8						; size = 4
_m$ = 12						; size = 4
_f_id$ = 16						; size = 4
_torus_clip PROC					; COMDAT

; 1996 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1840				; 00000730H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _gdata$[ebp]

; 1997 :   struct graphdata gdata0[FACET_VERTS+1],gdata1[FACET_VERTS+1],
; 1998 :       gdata2[FACET_VERTS+1];
; 1999 :   int i,k,mm;
; 2000 :   REAL t,d,a,b;
; 2001 :   int wrap[FACET_VERTS];
; 2002 :   int cut,oddman,oddflag;
; 2003 :   int oddwrap;
; 2004 :   REAL w;
; 2005 :   REAL **per=NULL;
; 2006 :   REAL **invper=NULL;
; 2007 :   REAL orig[MAXCOORD]; 
; 2008 : 
; 2009 :   if ( web.torus_display_period && web.torus_period )

	mov	edx, DWORD PTR _f_id$[ebp]
	push	ebx
	push	esi
	mov	DWORD PTR _m$GSCopy$[ebp], ecx
	mov	ecx, DWORD PTR _web+1620
	xor	esi, esi
	push	edi
	xor	edi, edi

; 2041 :   { 
; 2042 :     w = SDIM_dot(invper[m],gdata0[i].x) - orig[m];

	mov	DWORD PTR _gdata$GSCopy$[ebp], eax
	mov	DWORD PTR _per$[ebp], esi
	mov	DWORD PTR _invper$[ebp], edi
	cmp	ecx, esi
	je	SHORT $LN105@torus_clip

; 2012 :     invper = web.inverse_display_periods;

	mov	eax, DWORD PTR _web+1608
	mov	edi, DWORD PTR _web+1672
	mov	DWORD PTR _invper$[ebp], edi
	cmp	eax, esi
	je	SHORT $LN103@torus_clip

; 2010 :   { /* per = web.torus_display_period; */
; 2011 :     per = web.torus_period;

	mov	DWORD PTR _per$[ebp], eax

; 2012 :     invper = web.inverse_display_periods;

	jmp	SHORT $LN96@torus_clip
$LN105@torus_clip:

; 2013 :   }
; 2014 :   else if ( web.torus_period )

	mov	ecx, DWORD PTR _web+1608
	cmp	ecx, esi
	je	SHORT $LN101@torus_clip

; 2015 :   { per = web.torus_period;
; 2016 :     invper = web.inverse_periods;

	mov	edi, DWORD PTR _web+1612
	mov	DWORD PTR _per$[ebp], ecx
	mov	DWORD PTR _invper$[ebp], edi
	jmp	SHORT $LN96@torus_clip
$LN103@torus_clip:

; 2017 :   }
; 2018 :   else if ( web.torus_display_period )
; 2019 :   { per = web.torus_display_period; 

	mov	DWORD PTR _per$[ebp], ecx

; 2020 :     invper = web.inverse_display_periods;

	jmp	SHORT $LN96@torus_clip
$LN101@torus_clip:

; 2021 :   }
; 2022 :   else if ( slice_view_flag )

	cmp	DWORD PTR _slice_view_flag, esi
	je	SHORT $LN99@torus_clip

; 2023 :     slice_facet(gdata);

	push	eax
	call	_slice_facet
	add	esp, 4
	jmp	SHORT $LN96@torus_clip
$LN99@torus_clip:

; 2024 :   else if ( clip_view_flag )

	cmp	DWORD PTR _clip_view_flag, esi
	je	SHORT $LN97@torus_clip

; 2025 :     clip_facet(gdata,f_id,0);

	push	esi
	push	edx
	push	eax
	call	_clip_facet
	add	esp, 12					; 0000000cH

; 2026 :   else 

	jmp	SHORT $LN96@torus_clip
$LN97@torus_clip:

; 2027 :     (*graph_facet)(gdata,f_id);

	push	edx
	push	eax
	call	DWORD PTR _graph_facet
	add	esp, 8
$LN96@torus_clip:

; 2028 :    
; 2029 :   for ( i = 0 ; i < SDIM ; i++ )

	mov	ebx, DWORD PTR _web+616
	test	ebx, ebx
	jle	SHORT $LN93@torus_clip
$LL95@torus_clip:

; 2030 :     orig[i] = SDIM_dot(invper[i],web.display_origin);

	mov	edx, DWORD PTR [edi+esi*4]
	push	ebx
	push	OFFSET _web+1624
	push	edx
	call	_dot
	fstp	QWORD PTR _orig$[ebp+esi*8]
	mov	ebx, DWORD PTR _web+616
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, ebx
	jl	SHORT $LL95@torus_clip
$LN93@torus_clip:

; 2031 : 
; 2032 :   memset(gdata0,0,(FACET_VERTS+1)*sizeof(struct graphdata));

	push	576					; 00000240H
	lea	eax, DWORD PTR _gdata0$[ebp]
	push	0
	push	eax
	call	_memset

; 2033 :   memset(gdata1,0,(FACET_VERTS+1)*sizeof(struct graphdata));

	push	576					; 00000240H
	lea	ecx, DWORD PTR _gdata1$[ebp]
	push	0
	push	ecx
	call	_memset

; 2034 :   memset(gdata2,0,(FACET_VERTS+1)*sizeof(struct graphdata));

	push	576					; 00000240H
	lea	edx, DWORD PTR _gdata2$[ebp]
	push	0
	push	edx
	call	_memset

; 2035 : 
; 2036 :   for ( i = 0 ; i < FACET_VERTS ; i++ ) gdata0[i] = gdata[i]; /* local copy */

	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata0$[ebp]
	rep movsd
	lea	esi, DWORD PTR [eax+144]
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata0$[ebp+144]
	rep movsd
	lea	esi, DWORD PTR [eax+288]
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata0$[ebp+288]
	rep movsd
	add	esp, 36					; 00000024H

; 2037 : 
; 2038 :   /* see if any vertices outside cell in this coordinate */
; 2039 : 
; 2040 :  for ( i = 0 ; i < FACET_VERTS ; i++ )

	xor	esi, esi
	lea	edi, DWORD PTR _gdata0$[ebp]
	jmp	SHORT $LN89@torus_clip
	npad	5
$LL155@torus_clip:

; 2031 : 
; 2032 :   memset(gdata0,0,(FACET_VERTS+1)*sizeof(struct graphdata));

	mov	ebx, DWORD PTR _web+616
$LN89@torus_clip:

; 2041 :   { 
; 2042 :     w = SDIM_dot(invper[m],gdata0[i].x) - orig[m];

	mov	eax, DWORD PTR _invper$[ebp]
	mov	ecx, DWORD PTR _m$GSCopy$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	ebx
	push	edi
	push	edx
	call	_dot
	mov	eax, DWORD PTR _m$GSCopy$[ebp]
	fsub	QWORD PTR _orig$[ebp+eax*8]
	add	esp, 12					; 0000000cH

; 2043 :     wrap[i] = (w < .5) ? ((int)floor(w+.00000001)):((int)floor(w-.00000001));

	fld	QWORD PTR __real@3fe0000000000000
	sub	esp, 8
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN108@torus_clip
	fadd	QWORD PTR __real@3e45798ee2308c3a
	jmp	SHORT $LN210@torus_clip
$LN108@torus_clip:
	fsub	QWORD PTR __real@3e45798ee2308c3a
$LN210@torus_clip:
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _wrap$[ebp+esi*4], eax
	inc	esi
	add	edi, 144				; 00000090H
	cmp	esi, 3
	jl	SHORT $LL155@torus_clip

; 2044 :     /* slight shift to prevent spurious wraps due to rounding */
; 2045 :   }
; 2046 : 
; 2047 :   /* find odd vertex */
; 2048 :   oddflag = 1;  
; 2049 :   if ( (wrap[0] == wrap[1]) && (wrap[1] == wrap[2]) )

	mov	ecx, DWORD PTR _wrap$[ebp]
	mov	eax, DWORD PTR _wrap$[ebp+4]
	mov	DWORD PTR _oddflag$[ebp], 1
	cmp	ecx, eax
	jne	SHORT $LN84@torus_clip
	cmp	eax, DWORD PTR _wrap$[ebp+8]
	jne	SHORT $LN86@torus_clip

; 2050 :      { oddflag = 0;  oddman = 0; }

	xor	eax, eax
	mov	DWORD PTR _oddflag$[ebp], eax
	jmp	SHORT $LN211@torus_clip
$LN86@torus_clip:

; 2051 :   else if ( wrap[0] == wrap[1] ) oddman = 2;

	mov	eax, 2
	jmp	SHORT $LN211@torus_clip
$LN84@torus_clip:

; 2052 :   else if ( wrap[1] == wrap[2] ) oddman = 0;

	mov	edx, DWORD PTR _wrap$[ebp+8]
	cmp	eax, edx
	je	SHORT $LN212@torus_clip

; 2053 :   else if ( wrap[2] == wrap[0] ) oddman = 1;

	cmp	edx, ecx
	jne	SHORT $LN80@torus_clip
	mov	eax, 1

; 2054 :   else

	jmp	SHORT $LN211@torus_clip
$LN80@torus_clip:

; 2055 :     { sprintf(msg,"Triangle spans too many periods. Wraps %d %d %d\n",
; 2056 :             wrap[0],wrap[1],wrap[2]);

	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _msg
	push	OFFSET ??_C@_0DB@NNKLNLFD@Triangle?5spans?5too?5many?5periods?4@
	push	ecx
	call	_sprintf

; 2057 :       erroutstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_erroutstring
	add	esp, 24					; 00000018H
$LN212@torus_clip:

; 2058 :       oddman = 0;

	xor	eax, eax
$LN211@torus_clip:

; 2059 :     }
; 2060 : 
; 2061 :   /* wrap new triangle vertices properly */
; 2062 :   oddwrap = wrap[oddman];

	mov	ebx, DWORD PTR _web+616
	mov	edi, DWORD PTR _per$[ebp]
	mov	DWORD PTR _oddman$[ebp], eax
	lea	eax, DWORD PTR _wrap$[ebp+eax*4]
	mov	DWORD PTR tv981[ebp], eax
	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR _gdata0$[ebp]
	mov	DWORD PTR _oddwrap$[ebp], eax

; 2063 :   for ( i = 0 ; i < FACET_VERTS ; i++ )

	xor	edx, edx
	mov	DWORD PTR tv1507[ebp], ecx
	npad	3
$LL162@torus_clip:

; 2064 :   { 
; 2065 :     wrap[i] -= oddwrap;

	mov	eax, DWORD PTR _oddwrap$[ebp]
	sub	DWORD PTR _wrap$[ebp+edx*4], eax

; 2066 :     for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN77@torus_clip
	fild	DWORD PTR _oddwrap$[ebp]
$LN161@torus_clip:

; 2067 :     { d = oddwrap*per[m][k];

	mov	esi, DWORD PTR _m$GSCopy$[ebp]
	mov	esi, DWORD PTR [edi+esi*4]
	fld	QWORD PTR [esi+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	add	ecx, 8

; 2068 :       gdata0[i].x[k] -= d;

	fsubr	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
	cmp	eax, ebx
	jl	SHORT $LN161@torus_clip

; 2066 :     for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
$LN77@torus_clip:

; 2063 :   for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	ecx, DWORD PTR tv1507[ebp]
	inc	edx
	add	ecx, 144				; 00000090H
	mov	DWORD PTR tv1507[ebp], ecx
	cmp	edx, 3
	jl	SHORT $LL162@torus_clip

; 2069 :     }
; 2070 :   }
; 2071 : 
; 2072 :   /* kludge for display_periods to get back towards box */
; 2073 :   if ( web.torus_flag && web.torus_display_period )

	cmp	DWORD PTR _web+860, 0
	je	$LN69@torus_clip
	cmp	DWORD PTR _web+1620, 0
	je	$LN69@torus_clip

; 2074 :     for ( mm = 0 ; mm < SDIM ; mm++ )

	mov	DWORD PTR _mm$[ebp], 0
	test	ebx, ebx
	jle	$LN69@torus_clip
	mov	esi, DWORD PTR _invper$[ebp]
	sub	edi, esi
$LL71@torus_clip:

; 2075 :       if ( mm != m )

	mov	ecx, DWORD PTR _m$GSCopy$[ebp]
	cmp	DWORD PTR _mm$[ebp], ecx
	je	$LN70@torus_clip

; 2076 :       { int ww = (int)floor((SDIM_dot(invper[mm],gdata0[0].x) + 
; 2077 :                          SDIM_dot(invper[mm],gdata0[1].x) +
; 2078 :                          SDIM_dot(invper[mm],gdata0[2].x))/FACET_VERTS
; 2079 :                       - orig[mm]);

	mov	eax, DWORD PTR [esi]
	push	ebx
	lea	edx, DWORD PTR _gdata0$[ebp+144]
	push	edx
	push	eax
	call	_dot
	fstp	QWORD PTR tv2378[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [esi]
	push	ecx
	lea	edx, DWORD PTR _gdata0$[ebp]
	push	edx
	push	eax
	call	_dot
	fadd	QWORD PTR tv2378[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [esi]
	push	ecx
	fstp	QWORD PTR tv2888[ebp]
	lea	edx, DWORD PTR _gdata0$[ebp+288]
	push	edx
	push	eax
	call	_dot
	fadd	QWORD PTR tv2888[ebp]
	mov	ecx, DWORD PTR _mm$[ebp]
	add	esp, 28					; 0000001cH
	fdiv	QWORD PTR __real@4008000000000000
	fsub	QWORD PTR _orig$[ebp+ecx*8]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	ebx, DWORD PTR _web+616
	lea	ecx, DWORD PTR _gdata0$[ebp]
	mov	DWORD PTR _ww$90785[ebp], eax
	mov	DWORD PTR tv1587[ebp], ecx
	mov	DWORD PTR tv476[ebp], 3
	npad	5
$LL67@torus_clip:

; 2081 :          for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN66@torus_clip
	fild	DWORD PTR _ww$90785[ebp]
$LN64@torus_clip:

; 2082 :            gdata0[i].x[k] -= ww*per[mm][k];

	mov	edx, DWORD PTR [edi+esi]
	fld	QWORD PTR [edx+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	add	ecx, 8
	fsubr	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
	cmp	eax, ebx
	jl	SHORT $LN64@torus_clip

; 2081 :          for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
$LN66@torus_clip:

; 2080 :         for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	ecx, DWORD PTR tv1587[ebp]
	add	ecx, 144				; 00000090H
	dec	DWORD PTR tv476[ebp]
	mov	DWORD PTR tv1587[ebp], ecx
	jne	SHORT $LL67@torus_clip
$LN70@torus_clip:

; 2074 :     for ( mm = 0 ; mm < SDIM ; mm++ )

	mov	eax, DWORD PTR _mm$[ebp]
	inc	eax
	add	esi, 4
	mov	DWORD PTR _mm$[ebp], eax
	cmp	eax, ebx
	jl	$LL71@torus_clip
$LN69@torus_clip:

; 2083 :       }
; 2084 : 
; 2085 : 
; 2086 :   /* split, if necessary */
; 2087 :   if ( oddflag )

	cmp	DWORD PTR _oddflag$[ebp], 0
	je	$LN9@torus_clip

; 2088 :      {
; 2089 :         int pair1 = (oddman+1)%FACET_VERTS;

	mov	esi, DWORD PTR _oddman$[ebp]
	lea	eax, DWORD PTR [esi+1]
	cdq
	mov	ecx, 3
	idiv	ecx

; 2090 :         int pair2 = (oddman+2)%FACET_EDGES;

	lea	eax, DWORD PTR [esi+2]
	mov	esi, 3

; 2091 : 
; 2092 :         gdata0[0].flags = 0;  /* vertices the hard way */

	mov	DWORD PTR _gdata0$[ebp+136], 0
	mov	ecx, edx
	cdq
	idiv	esi

; 2093 :         /* find wrap multiple that cuts triangle */
; 2094 :         if ( wrap[oddman] < wrap[pair1] )

	mov	eax, DWORD PTR _wrap$[ebp+ecx*4]
	mov	DWORD PTR _pair1$90794[ebp], ecx
	mov	DWORD PTR tv1046[ebp], eax

; 2095 :            cut = wrap[pair1];

	mov	DWORD PTR _cut$[ebp], eax
	mov	DWORD PTR _pair2$90795[ebp], edx
	mov	edx, DWORD PTR tv981[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, eax
	jl	SHORT $LN59@torus_clip

; 2096 :         else
; 2097 :            cut = wrap[oddman];

	mov	DWORD PTR _cut$[ebp], ecx
$LN59@torus_clip:

; 2098 : 
; 2099 :         /* set up new triangles */
; 2100 :         for ( i = 0 ; i < FACET_VERTS ; i++ )
; 2101 :         { gdata2[i] = gdata0[i];
; 2102 :           gdata1[i] = gdata0[i];
; 2103 :         } 
; 2104 : 
; 2105 :         /* calculate new vertices */
; 2106 :         a = SDIM_dot(invper[m],gdata0[oddman].x)-orig[m];

	mov	eax, DWORD PTR _oddman$[ebp]
	mov	edx, DWORD PTR _m$GSCopy$[ebp]
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata0$[ebp]
	lea	edi, DWORD PTR _gdata2$[ebp]
	rep movsd
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata0$[ebp]
	lea	edi, DWORD PTR _gdata1$[ebp]
	rep movsd
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata0$[ebp+144]
	lea	edi, DWORD PTR _gdata2$[ebp+144]
	rep movsd
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata0$[ebp+144]
	lea	edi, DWORD PTR _gdata1$[ebp+144]
	rep movsd
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata0$[ebp+288]
	lea	edi, DWORD PTR _gdata2$[ebp+288]
	rep movsd
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata0$[ebp+288]
	lea	edi, DWORD PTR _gdata1$[ebp+288]
	rep movsd
	mov	ecx, DWORD PTR _invper$[ebp]
	lea	edi, DWORD PTR [eax+eax*8]
	shl	edi, 4
	push	ebx
	lea	eax, DWORD PTR _gdata0$[ebp+edi]
	push	eax
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_dot

; 2107 :         b = SDIM_dot(invper[m],gdata1[pair1].x)-orig[m];

	mov	eax, DWORD PTR _pair1$90794[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	ebx, DWORD PTR _m$GSCopy$[ebp]
	lea	esi, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR _invper$[ebp]
	fsub	QWORD PTR _orig$[ebp+ebx*8]
	push	ecx
	mov	ecx, DWORD PTR [eax+ebx*4]
	shl	esi, 4
	fstp	QWORD PTR _a$[ebp]
	lea	edx, DWORD PTR _gdata1$[ebp+esi]
	push	edx
	push	ecx
	call	_dot
	fsub	QWORD PTR _orig$[ebp+ebx*8]
	add	esp, 24					; 00000018H

; 2108 :         if ( fabs(a-b) < 0.00000001 ) t = 0.5;

	fld	QWORD PTR _a$[ebp]
	fld	ST(0)
	fsub	ST(0), ST(2)
	fabs
	fcomp	QWORD PTR __real@3e45798ee2308c3a
	fnstsw	ax
	fld1
	fldz
	test	ah, 5
	jp	SHORT $LN55@torus_clip
	fstp	ST(2)
	fstp	ST(2)
	fstp	ST(0)
	fld	QWORD PTR __real@3fe0000000000000
	jmp	SHORT $LN51@torus_clip
$LN55@torus_clip:

; 2109 :         else t = (cut - a)/(b - a);

	fild	DWORD PTR _cut$[ebp]
	fsub	ST(0), ST(3)
	fxch	ST(4)
	fsubrp	ST(3), ST(0)
	fxch	ST(3)
	fdivrp	ST(2), ST(0)

; 2110 :         if ( t < 0.0 ) t = 0.0;   /* clamp; necessary due to wiggle room above */

	fxch	ST(1)
	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	$LN182@torus_clip
	fstp	ST(0)
$LN186@torus_clip:

; 2111 :         else if ( t > 1.0 ) t = 1.0;

	fxch	ST(1)
$LN51@torus_clip:

; 2112 :         for ( k = 0 ; k < SDIM ; k++ )

	mov	edx, DWORD PTR _web+616
	test	edx, edx
	jle	SHORT $LN180@torus_clip
	fsub	ST(1), ST(0)
	mov	ecx, edi
	mov	eax, esi
	mov	ebx, edx
$LN50@torus_clip:

; 2113 :           gdata1[oddman].x[k] = gdata0[pair1].x[k] =
; 2114 :               (1 - t)*gdata0[oddman].x[k] + t*gdata1[pair1].x[k];

	fld	QWORD PTR _gdata0$[ebp+ecx]
	add	eax, 8
	fmul	ST(0), ST(2)
	add	ecx, 8
	dec	ebx
	fld	QWORD PTR _gdata1$[ebp+eax-8]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _gdata0$[ebp+eax-8]
	fstp	QWORD PTR _gdata1$[ebp+ecx-8]
	jne	SHORT $LN50@torus_clip
$LN180@torus_clip:

; 2115 :         b = SDIM_dot(invper[m],gdata2[pair2].x)-orig[m];

	mov	ebx, DWORD PTR _pair2$90795[ebp]
	fstp	ST(0)
	mov	eax, DWORD PTR _m$GSCopy$[ebp]
	fstp	ST(0)
	mov	ecx, DWORD PTR _invper$[ebp]
	push	edx
	lea	ebx, DWORD PTR [ebx+ebx*8]
	shl	ebx, 4
	lea	edx, DWORD PTR _gdata2$[ebp+ebx]
	push	edx
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_dot
	mov	eax, DWORD PTR _m$GSCopy$[ebp]
	fsub	QWORD PTR _orig$[ebp+eax*8]
	add	esp, 12					; 0000000cH

; 2116 :         if ( fabs(a-b) < 0.00000001 ) t = 0.5;

	fld	QWORD PTR _a$[ebp]
	fld	ST(0)
	fsub	ST(0), ST(2)
	fabs
	fcomp	QWORD PTR __real@3e45798ee2308c3a
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN47@torus_clip
	fstp	ST(0)
	fstp	ST(0)
	fld	QWORD PTR __real@3fe0000000000000
	jmp	SHORT $LN43@torus_clip
$LN182@torus_clip:

; 2110 :         if ( t < 0.0 ) t = 0.0;   /* clamp; necessary due to wiggle room above */

	fstp	ST(2)

; 2111 :         else if ( t > 1.0 ) t = 1.0;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	$LN186@torus_clip
	fstp	ST(1)
	fld	ST(0)
	jmp	$LN51@torus_clip
$LN47@torus_clip:

; 2117 :         else t = (cut - a)/(b - a);

	fild	DWORD PTR _cut$[ebp]
	fsub	ST(0), ST(1)
	fxch	ST(2)
	fsubrp	ST(1), ST(0)
	fdivp	ST(1), ST(0)

; 2118 :         if ( t < 0.0 ) t = 0.0;   /* clamp; necessary due to wiggle room above */

	fldz
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN192@torus_clip
	fstp	ST(1)
	jmp	SHORT $LN43@torus_clip
$LN192@torus_clip:
	fstp	ST(0)

; 2119 :         else if ( t > 1.0 ) t = 1.0;

	fld1
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN202@torus_clip
	fstp	ST(1)
	jmp	SHORT $LN43@torus_clip
$LN202@torus_clip:
	fstp	ST(0)
$LN43@torus_clip:

; 2120 :         for ( k = 0 ; k < SDIM ; k++ )

	mov	edx, DWORD PTR _web+616
	xor	eax, eax
	cmp	edx, eax
	jle	SHORT $LN196@torus_clip
	fld1
	mov	DWORD PTR tv1816[ebp], edi
	fsub	ST(0), ST(1)
	mov	eax, ebx
	mov	DWORD PTR tv2011[ebp], edx
$LN42@torus_clip:

; 2121 :           gdata2[oddman].x[k] = gdata0[pair2].x[k] = gdata1[pair2].x[k] =
; 2122 :               (1 - t)*gdata0[oddman].x[k] + t*gdata2[pair2].x[k];

	mov	ecx, DWORD PTR tv1816[ebp]
	fld	QWORD PTR _gdata0$[ebp+ecx]
	add	ecx, 8
	fmul	ST(0), ST(1)
	add	eax, 8
	dec	DWORD PTR tv2011[ebp]
	fld	QWORD PTR _gdata2$[ebp+eax-8]
	fmul	ST(0), ST(3)
	mov	DWORD PTR tv1816[ebp], ecx
	faddp	ST(1), ST(0)
	fst	QWORD PTR _gdata1$[ebp+eax-8]
	fst	QWORD PTR _gdata0$[ebp+eax-8]
	fstp	QWORD PTR _gdata2$[ebp+ecx-8]
	jne	SHORT $LN42@torus_clip

; 2120 :         for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(1)
	xor	eax, eax
$LN196@torus_clip:

; 2123 :         gdata0[pair1].v_id = NULLID;
; 2124 :         gdata0[pair2].v_id = NULLID;
; 2125 :         gdata1[oddman].v_id = NULLID;
; 2126 :         gdata1[pair2].v_id = NULLID;
; 2127 :         gdata2[oddman].v_id = NULLID;
; 2128 :         /* new edge colors are clear */
; 2129 :         gdata0[pair1].ecolor = CLEAR;

	or	ecx, -1
	fstp	ST(0)
	mov	DWORD PTR _gdata1$[ebp+edi+132], eax

; 2130 :         gdata1[pair1].ecolor = gdata1[pair2].ecolor = CLEAR;

	mov	DWORD PTR _gdata1$[ebp+ebx+120], ecx
	mov	DWORD PTR _gdata1$[ebp+ebx+132], eax
	mov	DWORD PTR _gdata0$[ebp+esi+132], eax
	mov	DWORD PTR _gdata0$[ebp+ebx+132], eax
	mov	DWORD PTR _gdata1$[ebp+esi+120], ecx

; 2131 :         gdata2[oddman].ecolor = CLEAR;

	mov	DWORD PTR _gdata2$[ebp+edi+120], ecx
	mov	DWORD PTR _gdata0$[ebp+esi+120], ecx

; 2132 :         gdata0[pair1].etype = INVISIBLE_EDGE;

	xor	ecx, ecx

; 2133 :         gdata1[pair1].etype = gdata1[pair2].etype = INVISIBLE_EDGE;

	mov	WORD PTR _gdata1$[ebp+ebx+124], cx
	mov	ebx, DWORD PTR _per$[ebp]
	mov	DWORD PTR _gdata2$[ebp+edi+132], eax

; 2134 :         gdata2[oddman].etype = INVISIBLE_EDGE;

	mov	WORD PTR _gdata2$[ebp+edi+124], cx
	mov	WORD PTR _gdata0$[ebp+esi+124], cx
	mov	WORD PTR _gdata1$[ebp+esi+124], cx
	xor	edi, edi
	npad	4
$LL39@torus_clip:

; 2138 :          for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN38@torus_clip
	fild	DWORD PTR tv1046[ebp]
	mov	esi, DWORD PTR _m$GSCopy$[ebp]
$LN36@torus_clip:

; 2139 :           { d = wrap[pair1]*per[m][k];

	mov	ecx, DWORD PTR [ebx+esi*4]
	fld	QWORD PTR [ecx+eax*8]
	lea	ecx, DWORD PTR [edi+eax*8]
	fmul	ST(0), ST(1)
	lea	ecx, DWORD PTR _gdata1$[ebp+ecx]

; 2140 :             gdata1[i].x[k] -= d;

	fld	QWORD PTR [ecx]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [ecx]
	lea	ecx, DWORD PTR [edi+eax*8]
	lea	ecx, DWORD PTR _gdata2$[ebp+ecx]

; 2141 :             gdata2[i].x[k] -= d;

	fsubr	QWORD PTR [ecx]
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, edx
	jl	SHORT $LN36@torus_clip

; 2138 :          for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
$LN38@torus_clip:

; 2135 : 
; 2136 :         /* wrap new triangle vertices properly */
; 2137 :         for ( i = 0 ; i < FACET_VERTS ; i++ )

	add	edi, 144				; 00000090H
	cmp	edi, 432				; 000001b0H
	jl	SHORT $LL39@torus_clip

; 2142 :           }
; 2143 : 
; 2144 :         /* kludge for display_periods to get back towards box */
; 2145 :         if ( web.torus_display_period )

	cmp	DWORD PTR _web+1620, 0
	je	$LN157@torus_clip

; 2146 :           for ( mm = 0 ; mm < SDIM ; mm++ )

	xor	eax, eax
	mov	DWORD PTR _mm$[ebp], eax
	test	edx, edx
	jle	$LN157@torus_clip
	mov	esi, DWORD PTR _invper$[ebp]
	mov	edi, ebx
	sub	edi, esi
$LL32@torus_clip:

; 2147 :             if ( mm != m )

	cmp	eax, DWORD PTR _m$GSCopy$[ebp]
	je	$LN31@torus_clip

; 2148 :             { int ww = (int)floor((SDIM_dot(invper[mm],gdata1[0].x) + 
; 2149 :                          SDIM_dot(invper[mm],gdata1[1].x) +
; 2150 :                          SDIM_dot(invper[mm],gdata1[2].x))/FACET_VERTS
; 2151 :                      - orig[mm]);

	mov	eax, DWORD PTR [esi]
	push	edx
	lea	edx, DWORD PTR _gdata1$[ebp+144]
	push	edx
	push	eax
	call	_dot
	fstp	QWORD PTR tv2380[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [esi]
	push	ecx
	lea	edx, DWORD PTR _gdata1$[ebp]
	push	edx
	push	eax
	call	_dot
	fadd	QWORD PTR tv2380[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [esi]
	push	ecx
	fstp	QWORD PTR tv2775[ebp]
	lea	edx, DWORD PTR _gdata1$[ebp+288]
	push	edx
	push	eax
	call	_dot
	fadd	QWORD PTR tv2775[ebp]
	mov	ecx, DWORD PTR _mm$[ebp]
	add	esp, 28					; 0000001cH
	fdiv	QWORD PTR __real@4008000000000000
	fsub	QWORD PTR _orig$[ebp+ecx*8]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	edx, DWORD PTR _web+616
	lea	ecx, DWORD PTR _gdata1$[ebp]
	mov	DWORD PTR _ww$90828[ebp], eax
	mov	DWORD PTR tv2361[ebp], ecx
	mov	DWORD PTR tv2394[ebp], 3
	npad	7
$LL28@torus_clip:

; 2153 :                for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN27@torus_clip
	fild	DWORD PTR _ww$90828[ebp]
$LN25@torus_clip:

; 2154 :                  gdata1[i].x[k] -= ww*per[mm][k];

	mov	ebx, DWORD PTR [edi+esi]
	fld	QWORD PTR [ebx+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	add	ecx, 8
	fsubr	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
	cmp	eax, edx
	jl	SHORT $LN25@torus_clip

; 2153 :                for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
$LN27@torus_clip:

; 2152 :               for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	ecx, DWORD PTR tv2361[ebp]
	add	ecx, 144				; 00000090H
	dec	DWORD PTR tv2394[ebp]
	mov	DWORD PTR tv2361[ebp], ecx
	jne	SHORT $LL28@torus_clip

; 2155 :               ww = (int)floor((SDIM_dot(invper[mm],gdata2[0].x) + 
; 2156 :                          SDIM_dot(invper[mm],gdata2[1].x) +
; 2157 :                          SDIM_dot(invper[mm],gdata2[2].x))/FACET_VERTS
; 2158 :                       - orig[mm]);

	mov	eax, DWORD PTR [esi]
	push	edx
	lea	edx, DWORD PTR _gdata2$[ebp+144]
	push	edx
	push	eax
	call	_dot
	fstp	QWORD PTR tv2382[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [esi]
	push	ecx
	lea	edx, DWORD PTR _gdata2$[ebp]
	push	edx
	push	eax
	call	_dot
	fadd	QWORD PTR tv2382[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [esi]
	push	ecx
	fstp	QWORD PTR tv2751[ebp]
	lea	edx, DWORD PTR _gdata2$[ebp+288]
	push	edx
	push	eax
	call	_dot
	fadd	QWORD PTR tv2751[ebp]
	mov	ecx, DWORD PTR _mm$[ebp]
	add	esp, 28					; 0000001cH
	fdiv	QWORD PTR __real@4008000000000000
	fsub	QWORD PTR _orig$[ebp+ecx*8]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	edx, DWORD PTR _web+616
	lea	ecx, DWORD PTR _gdata2$[ebp]
	mov	DWORD PTR _ww$90828[ebp], eax
	mov	DWORD PTR tv2529[ebp], ecx
	mov	DWORD PTR tv2524[ebp], 3
$LL22@torus_clip:

; 2160 :                for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN21@torus_clip
	fild	DWORD PTR _ww$90828[ebp]
$LN19@torus_clip:

; 2161 :                  gdata2[i].x[k] -= ww*per[mm][k];

	mov	ebx, DWORD PTR [edi+esi]
	fld	QWORD PTR [ebx+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	add	ecx, 8
	fsubr	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
	cmp	eax, edx
	jl	SHORT $LN19@torus_clip

; 2160 :                for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
$LN21@torus_clip:

; 2159 :               for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	ecx, DWORD PTR tv2529[ebp]
	add	ecx, 144				; 00000090H
	dec	DWORD PTR tv2524[ebp]
	mov	DWORD PTR tv2529[ebp], ecx
	jne	SHORT $LL22@torus_clip
	mov	eax, DWORD PTR _mm$[ebp]
$LN31@torus_clip:

; 2146 :           for ( mm = 0 ; mm < SDIM ; mm++ )

	inc	eax
	add	esi, 4
	mov	DWORD PTR _mm$[ebp], eax
	cmp	eax, edx
	jl	$LL32@torus_clip
$LN157@torus_clip:

; 2162 :             }
; 2163 : 
; 2164 :  
; 2165 :         /* send on for further check, or plot */
; 2166 :         if ( m == 0 ) 

	mov	eax, DWORD PTR _m$GSCopy$[ebp]
	test	eax, eax
	jne	$LN16@torus_clip

; 2167 :         { 
; 2168 :           if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE) )

	cmp	DWORD PTR _web+860, eax
	je	SHORT $LN15@torus_clip
	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN15@torus_clip

; 2169 :           { (*graph_facet_transforms)(gdata1,f_id);

	mov	esi, DWORD PTR _f_id$[ebp]
	lea	edx, DWORD PTR _gdata1$[ebp]
	push	esi
	push	edx
	call	_graph_facet_transforms

; 2170 :             (*graph_facet_transforms)(gdata2,f_id);

	lea	eax, DWORD PTR _gdata2$[ebp]
	push	esi
	push	eax
	call	_graph_facet_transforms
	add	esp, 16					; 00000010H
	jmp	$LN154@torus_clip
$LN15@torus_clip:

; 2171 :           }
; 2172 :           else if ( slice_view_flag )

	cmp	DWORD PTR _slice_view_flag, 0
	je	SHORT $LN13@torus_clip

; 2173 :           { slice_facet(gdata1);

	lea	ecx, DWORD PTR _gdata1$[ebp]
	push	ecx
	call	_slice_facet

; 2174 :             slice_facet(gdata2);

	lea	edx, DWORD PTR _gdata2$[ebp]
	push	edx
	call	_slice_facet
	add	esp, 8
	jmp	$LN154@torus_clip
$LN13@torus_clip:

; 2175 :           }
; 2176 :           else if ( clip_view_flag )

	cmp	DWORD PTR _clip_view_flag, 0

; 2177 :           { clip_facet(gdata1,f_id,0);

	mov	esi, DWORD PTR _f_id$[ebp]
	je	SHORT $LN11@torus_clip
	push	0
	lea	eax, DWORD PTR _gdata1$[ebp]
	push	esi
	push	eax
	call	_clip_facet

; 2178 :             clip_facet(gdata2,f_id,0);

	push	0
	lea	ecx, DWORD PTR _gdata2$[ebp]
	push	esi
	push	ecx
	call	_clip_facet
	add	esp, 24					; 00000018H

; 2179 :           }
; 2180 :           else

	jmp	SHORT $LN154@torus_clip
$LN11@torus_clip:

; 2181 :           { (*graph_facet)(gdata1,f_id);

	lea	edx, DWORD PTR _gdata1$[ebp]
	push	esi
	push	edx
	call	DWORD PTR _graph_facet

; 2182 :             (*graph_facet)(gdata2,f_id);

	lea	eax, DWORD PTR _gdata2$[ebp]
	push	esi
	push	eax
	call	DWORD PTR _graph_facet
	add	esp, 16					; 00000010H

; 2183 :           }
; 2184 :           
; 2185 :         }
; 2186 :         else

	jmp	SHORT $LN154@torus_clip
$LN16@torus_clip:

; 2187 :         { torus_clip(gdata1,m-1,f_id);

	mov	edi, DWORD PTR _f_id$[ebp]
	lea	esi, DWORD PTR [eax-1]
	push	edi
	lea	ecx, DWORD PTR _gdata1$[ebp]
	push	esi
	push	ecx
	call	_torus_clip

; 2188 :           torus_clip(gdata2,m-1,f_id);

	push	edi
	lea	edx, DWORD PTR _gdata2$[ebp]
	push	esi
	push	edx
	call	_torus_clip
	add	esp, 24					; 00000018H
$LN9@torus_clip:

; 2189 :         }
; 2190 :       }
; 2191 : 
; 2192 :     /* send on original triangle structure */
; 2193 :     if ( m == 0 ) 

	cmp	DWORD PTR _m$GSCopy$[ebp], 0
	jne	$LN8@torus_clip
$LN154@torus_clip:

; 2194 :     { if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE) )

	cmp	DWORD PTR _web+860, 0
	je	SHORT $LN7@torus_clip
	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN7@torus_clip

; 2195 :         (*graph_facet_transforms)(gdata0,f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gdata0$[ebp]
	push	ecx
	call	_graph_facet_transforms
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 2205 : 
; 2206 : } /* end torus_clip */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@torus_clip:

; 2196 :       else if ( slice_view_flag )

	cmp	DWORD PTR _slice_view_flag, 0
	je	SHORT $LN5@torus_clip

; 2197 :         slice_facet(gdata0);

	lea	edx, DWORD PTR _gdata0$[ebp]
	push	edx
	call	_slice_facet
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2205 : 
; 2206 : } /* end torus_clip */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@torus_clip:

; 2198 :       else if ( clip_view_flag )

	cmp	DWORD PTR _clip_view_flag, 0
	je	SHORT $LN3@torus_clip

; 2199 :         clip_facet(gdata0,f_id,0);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	0
	push	eax
	lea	ecx, DWORD PTR _gdata0$[ebp]
	push	ecx
	call	_clip_facet

; 2202 :     }
; 2203 :     else
; 2204 :       torus_clip(gdata0,m-1,f_id);

	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2205 : 
; 2206 : } /* end torus_clip */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@torus_clip:

; 2200 :       else
; 2201 :         (*graph_facet)(gdata0,f_id);

	mov	edx, DWORD PTR _f_id$[ebp]
	push	edx
	lea	eax, DWORD PTR _gdata0$[ebp]
	push	eax
	call	DWORD PTR _graph_facet
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 2205 : 
; 2206 : } /* end torus_clip */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@torus_clip:

; 2202 :     }
; 2203 :     else
; 2204 :       torus_clip(gdata0,m-1,f_id);

	mov	ecx, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR _m$GSCopy$[ebp]
	push	ecx
	dec	edx
	push	edx
	lea	eax, DWORD PTR _gdata0$[ebp]
	push	eax
	call	_torus_clip

; 2205 : 
; 2206 : } /* end torus_clip */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_torus_clip ENDP
_TEXT	ENDS
PUBLIC	_graph_edge_clip
; Function compile flags: /Ogtp
;	COMDAT _graph_edge_clip
_TEXT	SEGMENT
_g$ = 8							; size = 4
_id$ = 12						; size = 4
_graph_edge_clip PROC					; COMDAT

; 3768 : {

	push	ebp
	mov	ebp, esp

; 3769 :   if ( slice_view_flag )

	cmp	DWORD PTR _slice_view_flag, 0

; 3770 :     slice_edge(g);

	jne	SHORT $LN1@graph_edge

; 3771 :   else if ( clip_view_flag )

	cmp	DWORD PTR _clip_view_flag, 0
	je	SHORT $LN2@graph_edge

; 3772 :     clip_edge(g,id,0);

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	push	0
	push	eax
	push	ecx
	call	_clip_edge
	add	esp, 12					; 0000000cH
$LN1@graph_edge:

; 3775 : 
; 3776 : } // end graph_edge_clip()

	pop	ebp
	ret	0
$LN2@graph_edge:
	pop	ebp

; 3773 :   else
; 3774 :     (*graph_edge)(g,id);

	jmp	DWORD PTR _graph_edge
_graph_edge_clip ENDP
_TEXT	ENDS
PUBLIC	_f_id$GSCopy$
PUBLIC	_gdata$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	_transform_colors:DWORD
EXTRN	_opacity_attr:DWORD
EXTRN	_matvec_mul:PROC
EXTRN	_view_transforms:DWORD
EXTRN	_transform_count:DWORD
EXTRN	_geomview_facet:PROC
EXTRN	_transform_colors_flag:DWORD
EXTRN	_view_transform_det:DWORD
EXTRN	_lazy_transforms_flag:DWORD
EXTRN	_transforms_flag:DWORD
EXTRN	_bounding_box:BYTE
EXTRN	_box_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _graph_facet_transforms
_TEXT	SEGMENT
_gdata$GSCopy$ = -604					; size = 4
tv1390 = -600						; size = 4
tv1219 = -600						; size = 4
_f_id$GSCopy$ = -596					; size = 4
tv1221 = -592						; size = 4
tv1024 = -592						; size = 4
_i$ = -588						; size = 4
tv1139 = -584						; size = 4
tv1068 = -584						; size = 4
tv208 = -584						; size = 4
_gt$ = -580						; size = 576
__$ArrayPad$ = -4					; size = 4
_gdata$ = 8						; size = 4
_f_id$ = 12						; size = 4
_graph_facet_transforms PROC				; COMDAT

; 1019 : { struct graphdata gt[FACET_VERTS+1];

	push	ebp
	mov	ebp, esp
	sub	esp, 604				; 0000025cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _gdata$[ebp]
	push	edi
	mov	edi, DWORD PTR _f_id$[ebp]

; 1020 :   int i,j,k;
; 1021 : 
; 1022 :   memset(gt,0,(FACET_VERTS+1)*sizeof(struct graphdata));

	push	576					; 00000240H
	xor	ebx, ebx
	lea	eax, DWORD PTR _gt$[ebp]
	push	ebx
	push	eax

; 1045 :           matvec_mul(view_transforms[i],gdata[j].norm,gt[j].norm,
; 1046 :              SDIM,SDIM); 

	mov	DWORD PTR _gdata$GSCopy$[ebp], esi
	mov	DWORD PTR _f_id$GSCopy$[ebp], edi
	call	_memset
	fld1
	mov	ecx, DWORD PTR _web+616
	fst	QWORD PTR [esi+ecx*8]
	mov	edx, DWORD PTR _web+616
	fst	QWORD PTR [esi+edx*8+144]
	mov	eax, DWORD PTR _web+616
	fstp	QWORD PTR [esi+eax*8+288]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _box_flag, ebx
	je	SHORT $LN95@graph_face

; 1023 : 
; 1024 :   for ( i = 0 ; i < FACET_VERTS ; i++ ) 
; 1025 :      gdata[i].x[SDIM] = 1.0;  /* homogeneous coord */
; 1026 :   if ( box_flag )
; 1027 :     for ( j = 0 ; j < FACET_VERTS ; j++ )

	mov	ebx, esi
	mov	DWORD PTR tv208[ebp], 3
$LL57@graph_face:

; 1028 :       for ( k = 0 ; k < SDIM ; k++ )

	mov	eax, DWORD PTR _web+616
	test	eax, eax
	jle	SHORT $LN56@graph_face
	mov	edx, OFFSET _bounding_box+8
	mov	ecx, ebx
	mov	edi, eax
	npad	7
$LL54@graph_face:

; 1029 :       { if ( gdata[j].x[k] < bounding_box[k][0] )

	fld	QWORD PTR [edx-8]
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN51@graph_face

; 1030 :           bounding_box[k][0] = gdata[j].x[k];

	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [edx-8]
$LN51@graph_face:

; 1031 :         if ( gdata[j].x[k] > bounding_box[k][1] )

	fld	QWORD PTR [edx]
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN53@graph_face

; 1032 :           bounding_box[k][1] = gdata[j].x[k];

	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [edx]
$LN53@graph_face:

; 1028 :       for ( k = 0 ; k < SDIM ; k++ )

	add	ecx, 8
	add	edx, 16					; 00000010H
	dec	edi
	jne	SHORT $LL54@graph_face
	mov	edi, DWORD PTR _f_id$GSCopy$[ebp]
$LN56@graph_face:

; 1023 : 
; 1024 :   for ( i = 0 ; i < FACET_VERTS ; i++ ) 
; 1025 :      gdata[i].x[SDIM] = 1.0;  /* homogeneous coord */
; 1026 :   if ( box_flag )
; 1027 :     for ( j = 0 ; j < FACET_VERTS ; j++ )

	add	ebx, 144				; 00000090H
	dec	DWORD PTR tv208[ebp]
	jne	SHORT $LL57@graph_face
	xor	ebx, ebx
$LN95@graph_face:

; 1033 :       }
; 1034 :   if ( transforms_flag && (!lazy_transforms_flag || box_flag) && view_transform_det &&
; 1035 :          !(valid_id(f_id) && (get_fattr(f_id) & NO_TRANSFORM)) &&
; 1036 :              (transform_colors_flag || (graph_facet != geomview_facet) )  )

	mov	edx, DWORD PTR _graph_facet
	cmp	DWORD PTR _transforms_flag, ebx
	je	$LN100@graph_face
	cmp	DWORD PTR _lazy_transforms_flag, ebx
	je	SHORT $LN48@graph_face
	cmp	DWORD PTR _box_flag, ebx
	je	$LN100@graph_face
$LN48@graph_face:
	cmp	DWORD PTR _view_transform_det, ebx
	je	$LN100@graph_face
	test	edi, 268435456				; 10000000H
	je	SHORT $LN47@graph_face
	mov	eax, DWORD PTR _web+236
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 1
	xor	eax, eax
	or	eax, ecx
	jne	$LN100@graph_face
$LN47@graph_face:
	cmp	DWORD PTR _transform_colors_flag, ebx
	jne	SHORT $LN46@graph_face
	cmp	edx, OFFSET _geomview_facet
	je	$LN100@graph_face
$LN46@graph_face:

; 1037 :   {
; 1038 :     for ( i = 0 ;  i < transform_count ; i++ )

	mov	DWORD PTR _i$[ebp], ebx
	cmp	DWORD PTR _transform_count, ebx
	jle	$LN1@graph_face
	jmp	SHORT $LN45@graph_face
$LL92@graph_face:
	mov	esi, DWORD PTR _gdata$GSCopy$[ebp]
	xor	ebx, ebx
$LN45@graph_face:

; 1039 :     { if ( view_transform_det[i] > 0 )

	mov	ecx, DWORD PTR _view_transform_det
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], ebx
	jle	$LN42@graph_face

; 1040 :       { for ( j = 0 ; j < FACET_VERTS ; j++ )

	mov	DWORD PTR tv1024[ebp], ebx
	lea	ebx, DWORD PTR _gt$[ebp]

; 1041 :         { gt[j] = gdata[j];

	mov	eax, esi
	mov	ecx, ebx
	sub	eax, ecx
	mov	DWORD PTR tv1068[ebp], eax
	jmp	SHORT $LN41@graph_face
	npad	8
$LL93@graph_face:
	mov	eax, DWORD PTR tv1068[ebp]
$LN41@graph_face:
	lea	edx, DWORD PTR [eax+ebx]

; 1042 :           matvec_mul(view_transforms[i],gdata[j].x,gt[j].x,SDIM+1,SDIM+1); 

	mov	eax, DWORD PTR _web+616
	inc	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	push	ebx
	mov	esi, edx
	push	edx
	mov	edx, DWORD PTR _view_transforms
	mov	ecx, 36					; 00000024H
	mov	edi, ebx
	rep movsd
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_matvec_mul

; 1043 :           for ( k = 0 ; k <= SDIM ; k++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 20					; 00000014H
	test	ecx, ecx
	js	SHORT $LN96@graph_face
	mov	edx, DWORD PTR tv1024[ebp]
	lea	esi, DWORD PTR [ecx+edx]
	lea	esi, DWORD PTR _gt$[ebp+esi*8]
	mov	eax, ebx
	lea	edx, DWORD PTR [ecx+1]
$LL38@graph_face:

; 1044 :              gt[j].x[k] /= gt[j].x[SDIM]; /* normalize */

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	edx
	fdiv	QWORD PTR [esi]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LL38@graph_face
$LN96@graph_face:

; 1045 :           matvec_mul(view_transforms[i],gdata[j].norm,gt[j].norm,
; 1046 :              SDIM,SDIM); 

	mov	edx, DWORD PTR _view_transforms
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR tv1068[ebp]
	lea	eax, DWORD PTR [ebx+56]
	push	eax
	lea	eax, DWORD PTR [ecx+ebx+56]
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_matvec_mul
	mov	eax, DWORD PTR tv1024[ebp]
	add	eax, 18					; 00000012H
	add	esp, 20					; 00000014H
	add	ebx, 144				; 00000090H
	mov	DWORD PTR tv1024[ebp], eax
	cmp	eax, 54					; 00000036H
	jl	$LL93@graph_face

; 1047 :         }
; 1048 :       }
; 1049 :       else

	mov	edx, DWORD PTR _opacity_attr
	mov	ecx, DWORD PTR _gdata$GSCopy$[ebp]
	mov	esi, DWORD PTR _f_id$GSCopy$[ebp]
	jmp	$LN35@graph_face
$LN42@graph_face:

; 1050 :       { /* reverse orientation */
; 1051 :         for ( j = 0 ; j < FACET_VERTS ; j++ )

	lea	edx, DWORD PTR [esi+344]
	mov	DWORD PTR tv1219[ebp], edx
	lea	edx, DWORD PTR [esi+288]
	mov	DWORD PTR tv1139[ebp], ebx
	lea	ebx, DWORD PTR _gt$[ebp]
	mov	DWORD PTR tv1221[ebp], edx
	jmp	SHORT $LN34@graph_face
	npad	10
$LL94@graph_face:
	mov	edx, DWORD PTR tv1221[ebp]
$LN34@graph_face:

; 1052 :         { gt[j] = gdata[2-j];
; 1053 :           matvec_mul(view_transforms[i],gdata[2-j].x,gt[j].x,SDIM+1,SDIM+1); 

	mov	eax, DWORD PTR _web+616
	inc	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR _view_transforms
	mov	esi, edx
	mov	ecx, 36					; 00000024H
	mov	edi, ebx
	rep movsd
	mov	ecx, DWORD PTR _i$[ebp]
	push	ebx
	push	edx
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_matvec_mul

; 1054 :           for ( k = 0 ; k <= SDIM ; k++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 20					; 00000014H
	test	ecx, ecx
	js	SHORT $LN99@graph_face
	mov	esi, DWORD PTR tv1139[ebp]
	add	esi, ecx
	lea	esi, DWORD PTR _gt$[ebp+esi*8]
	mov	eax, ebx
	lea	edx, DWORD PTR [ecx+1]
$LL31@graph_face:

; 1055 :             gt[j].x[k] /= gt[j].x[SDIM]; /* normalize */

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	edx
	fdiv	QWORD PTR [esi]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LL31@graph_face
$LN99@graph_face:

; 1056 :           matvec_mul(view_transforms[i],gdata[2-j].norm,gt[j].norm,SDIM,SDIM); 

	mov	edx, DWORD PTR _view_transforms
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR tv1219[ebp]
	push	ecx
	push	ecx
	lea	ecx, DWORD PTR [ebx+56]
	push	ecx
	mov	ecx, DWORD PTR [edx+eax*4]
	push	esi
	push	ecx
	call	_matvec_mul
	mov	eax, DWORD PTR tv1139[ebp]
	sub	DWORD PTR tv1221[ebp], 144		; 00000090H
	add	eax, 18					; 00000012H
	sub	esi, 144				; 00000090H
	add	esp, 20					; 00000014H
	add	ebx, 144				; 00000090H
	mov	DWORD PTR tv1139[ebp], eax
	mov	DWORD PTR tv1219[ebp], esi
	cmp	eax, 54					; 00000036H
	jl	$LL94@graph_face

; 1057 :         }
; 1058 :         gt[0].color = gdata[0].color;        

	mov	ecx, DWORD PTR _gdata$GSCopy$[ebp]
	mov	edx, DWORD PTR [ecx+104]

; 1059 :         gt[0].backcolor = gdata[0].backcolor;

	mov	eax, DWORD PTR [ecx+108]

; 1060 :         if ( opacity_attr )
; 1061 :            gdata[0].opacity = *(REAL*)(get_extra(f_id,opacity_attr));

	mov	esi, DWORD PTR _f_id$GSCopy$[ebp]
	mov	DWORD PTR _gt$[ebp+104], edx
	mov	edx, DWORD PTR _opacity_attr
	mov	DWORD PTR _gt$[ebp+108], eax
	test	edx, edx
	je	SHORT $LN28@graph_face
	mov	ebx, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	mov	eax, esi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	edi, edx
	mov	edi, DWORD PTR [edi+ebx+64]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	fld	QWORD PTR [edi+edx]
	fstp	QWORD PTR [ecx+112]
	mov	edx, DWORD PTR _opacity_attr
$LN28@graph_face:

; 1062 :         // fix up edge data, since different correspondence
; 1063 :         gt[0].ecolor = gdata[1].ecolor; gt[1].ecolor = gdata[0].ecolor;

	mov	eax, DWORD PTR [ecx+264]
	mov	DWORD PTR _gt$[ebp+120], eax
	mov	eax, DWORD PTR [ecx+120]
	mov	DWORD PTR _gt$[ebp+264], eax

; 1064 :         gt[2].ecolor = gdata[2].ecolor;

	mov	eax, DWORD PTR [ecx+408]
	mov	DWORD PTR _gt$[ebp+408], eax

; 1065 :         gt[0].etype = gdata[1].etype; gt[1].etype = gdata[0].etype;

	movzx	eax, WORD PTR [ecx+268]
	mov	WORD PTR _gt$[ebp+124], ax
	movzx	eax, WORD PTR [ecx+124]
	mov	WORD PTR _gt$[ebp+268], ax

; 1066 :         gt[2].etype = gdata[2].etype;

	movzx	eax, WORD PTR [ecx+412]
	mov	WORD PTR _gt$[ebp+412], ax

; 1067 :         gt[0].id = gdata[1].id;

	mov	eax, DWORD PTR [ecx+272]
	mov	DWORD PTR _gt$[ebp+128], eax

; 1068 :         gt[1].id = gdata[0].id;

	mov	eax, DWORD PTR [ecx+128]
	mov	DWORD PTR _gt$[ebp+272], eax

; 1069 :         gt[2].id = gdata[2].id;

	mov	eax, DWORD PTR [ecx+416]
	mov	DWORD PTR _gt$[ebp+416], eax

; 1070 :         gt[0].flags = gdata[0].flags;

	mov	eax, DWORD PTR [ecx+136]
	mov	DWORD PTR _gt$[ebp+136], eax
$LN35@graph_face:

; 1071 :       }
; 1072 : 
; 1073 :       if ( transform_colors[i] == SWAP_COLORS )

	mov	eax, DWORD PTR _transform_colors
	mov	edi, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax+edi*4]
	cmp	eax, 1
	jne	SHORT $LN27@graph_face

; 1074 :       { int temp = gt[0].color;
; 1075 :         gt[0].color = gt[0].backcolor;

	mov	edi, DWORD PTR _gt$[ebp+108]
	mov	eax, DWORD PTR _gt$[ebp+104]

; 1076 :         gt[0].backcolor = temp;
; 1077 :         gt[0].flags |= COLORS_SWAPPED;

	or	DWORD PTR _gt$[ebp+136], 32768		; 00008000H
	mov	DWORD PTR _gt$[ebp+104], edi
	jmp	SHORT $LN102@graph_face
$LN27@graph_face:

; 1078 :       }
; 1079 :       else if ( transform_colors_flag && (transform_colors[i] != SAME_COLOR) ) 

	cmp	DWORD PTR _transform_colors_flag, 0
	je	SHORT $LN25@graph_face
	test	eax, eax
	je	SHORT $LN25@graph_face

; 1080 :         gt[0].color = gt[0].backcolor = transform_colors[i];

	mov	DWORD PTR _gt$[ebp+104], eax
$LN102@graph_face:
	mov	DWORD PTR _gt$[ebp+108], eax
$LN25@graph_face:

; 1081 :       if ( opacity_attr )

	test	edx, edx
	je	SHORT $LN24@graph_face

; 1082 :          gdata[0].opacity = *(REAL*)(get_extra(f_id,opacity_attr));

	mov	ebx, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	mov	eax, esi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	edi, edx
	mov	edi, DWORD PTR [edi+ebx+64]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	fld	QWORD PTR [edi+edx]
	fstp	QWORD PTR [ecx+112]
$LN24@graph_face:

; 1083 :       if ( box_flag )

	cmp	DWORD PTR _box_flag, 0
	je	SHORT $LN98@graph_face

; 1084 :       for ( j = 0 ; j < FACET_VERTS ; j++ )

	lea	edi, DWORD PTR _gt$[ebp]
	mov	DWORD PTR tv1390[ebp], 3
$LL22@graph_face:

; 1085 :         for ( k = 0 ; k < SDIM ; k++ )

	mov	ebx, DWORD PTR _web+616
	test	ebx, ebx
	jle	SHORT $LN21@graph_face
	mov	esi, OFFSET _bounding_box+8
	mov	ecx, edi
	mov	edx, ebx
$LL19@graph_face:

; 1086 :         { if ( gt[j].x[k] < bounding_box[k][0] )

	fld	QWORD PTR [esi-8]
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN16@graph_face

; 1087 :             bounding_box[k][0] = gt[j].x[k];

	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [esi-8]
$LN16@graph_face:

; 1088 :           if ( gt[j].x[k] > bounding_box[k][1] )

	fld	QWORD PTR [esi]
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN18@graph_face

; 1089 :             bounding_box[k][1] = gt[j].x[k];

	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [esi]
$LN18@graph_face:

; 1085 :         for ( k = 0 ; k < SDIM ; k++ )

	add	ecx, 8
	add	esi, 16					; 00000010H
	dec	edx
	jne	SHORT $LL19@graph_face
	mov	esi, DWORD PTR _f_id$GSCopy$[ebp]
$LN21@graph_face:

; 1084 :       for ( j = 0 ; j < FACET_VERTS ; j++ )

	add	edi, 144				; 00000090H
	dec	DWORD PTR tv1390[ebp]
	jne	SHORT $LL22@graph_face
	jmp	SHORT $LN20@graph_face
$LN98@graph_face:
	mov	ebx, DWORD PTR _web+616
$LN20@graph_face:

; 1090 :         }
; 1091 :       if ( lazy_transforms_flag && (i > 0) )

	cmp	DWORD PTR _lazy_transforms_flag, 0
	je	SHORT $LN101@graph_face
	cmp	DWORD PTR _i$[ebp], 0
	jg	SHORT $LN44@graph_face
$LN101@graph_face:

; 1092 :          continue;  // just needed bounding box
; 1093 :       if ( (torus_display_mode == TORUS_CLIPPED_MODE) &&
; 1094 :             web.torus_display_period && !web.torus_flag )

	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN13@graph_face
	cmp	DWORD PTR _web+1620, 0
	je	SHORT $LN13@graph_face
	cmp	DWORD PTR _web+860, 0
	jne	SHORT $LN13@graph_face

; 1095 :         torus_clip(gt,SDIM-1,f_id);

	push	esi
	dec	ebx
	lea	eax, DWORD PTR _gt$[ebp]
	push	ebx
	push	eax
	call	_torus_clip
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN44@graph_face
$LN13@graph_face:

; 1096 :       else if ( slice_view_flag )

	cmp	DWORD PTR _slice_view_flag, 0
	je	SHORT $LN11@graph_face

; 1097 :         slice_facet(gt);

	lea	ecx, DWORD PTR _gt$[ebp]
	push	ecx
	call	_slice_facet
	add	esp, 4
	jmp	SHORT $LN44@graph_face
$LN11@graph_face:

; 1098 :       else if ( clip_view_flag )

	cmp	DWORD PTR _clip_view_flag, 0
	je	SHORT $LN9@graph_face

; 1099 :         clip_facet(gt,f_id,0);

	push	0
	lea	edx, DWORD PTR _gt$[ebp]
	push	esi
	push	edx
	call	_clip_facet
	add	esp, 12					; 0000000cH

; 1100 :       else

	jmp	SHORT $LN44@graph_face
$LN9@graph_face:

; 1101 :         (*graph_facet)(gt,f_id);

	lea	eax, DWORD PTR _gt$[ebp]
	push	esi
	push	eax
	call	DWORD PTR _graph_facet
	add	esp, 8
$LN44@graph_face:

; 1037 :   {
; 1038 :     for ( i = 0 ;  i < transform_count ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _transform_count
	jl	$LL92@graph_face
	pop	edi
	pop	esi
	pop	ebx

; 1114 :   }
; 1115 : } // end  graph_facet_transforms()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN100@graph_face:

; 1102 :     }
; 1103 :   }
; 1104 :   else 
; 1105 :   { if ( (torus_display_mode == TORUS_CLIPPED_MODE) &&
; 1106 :             web.torus_display_period && !web.torus_flag )

	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN6@graph_face
	cmp	DWORD PTR _web+1620, ebx
	je	SHORT $LN6@graph_face
	cmp	DWORD PTR _web+860, ebx
	jne	SHORT $LN6@graph_face

; 1107 :       torus_clip(gdata,SDIM-1,f_id);

	mov	ecx, DWORD PTR _web+616
	push	edi
	dec	ecx
	push	ecx
	push	esi
	call	_torus_clip
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 1114 :   }
; 1115 : } // end  graph_facet_transforms()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@graph_face:

; 1108 :     else if ( slice_view_flag )

	cmp	DWORD PTR _slice_view_flag, ebx
	je	SHORT $LN4@graph_face

; 1109 :         slice_facet(gdata);

	push	esi
	call	_slice_facet
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1114 :   }
; 1115 : } // end  graph_facet_transforms()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@graph_face:

; 1110 :     else if ( clip_view_flag )

	cmp	DWORD PTR _clip_view_flag, ebx
	je	SHORT $LN2@graph_face

; 1111 :         clip_facet(gdata,f_id,0);

	push	ebx
	push	edi
	push	esi
	call	_clip_facet
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 1114 :   }
; 1115 : } // end  graph_facet_transforms()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@graph_face:

; 1112 :     else
; 1113 :       (*graph_facet)(gdata,f_id);

	push	edi
	push	esi
	call	edx
	add	esp, 8
$LN1@graph_face:

; 1114 :   }
; 1115 : } // end  graph_facet_transforms()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_graph_facet_transforms ENDP
_TEXT	ENDS
PUBLIC	_m$GSCopy$
PUBLIC	_gdata$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtp
;	COMDAT _torus_edge_clip
_TEXT	SEGMENT
_wrap$ = -372						; size = 8
_a$ = -364						; size = 8
_m$GSCopy$ = -360					; size = 4
tv779 = -356						; size = 8
tv833 = -352						; size = 4
tv330 = -352						; size = 4
_cut$90528 = -352					; size = 4
_per$ = -348						; size = 4
_gdata$GSCopy$ = -344					; size = 4
_gdata1$ = -340						; size = 288
_orig$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_gdata$ = 8						; size = 4
_m$ = 12						; size = 4
_torus_edge_clip PROC					; COMDAT

; 1511 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 372				; 00000174H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _m$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _gdata$[ebp]

; 1512 :   struct graphdata gdata1[2];  /* for possible subdivided edge */
; 1513 :   int i,k;
; 1514 :   REAL t,a,b;
; 1515 :   int wrap[2];
; 1516 :   REAL **per=NULL;

	xor	esi, esi

; 1517 :   REAL **invper=NULL;

	xor	ebx, ebx

; 1518 :   REAL orig[MAXCOORD];  /* cell coords of display origin */
; 1519 : 
; 1520 :   if ( gdata[0].flags & EDGE_ARC ) 

	test	DWORD PTR [edi+136], 32768		; 00008000H
	mov	DWORD PTR _gdata$GSCopy$[ebp], edi
	mov	DWORD PTR _m$GSCopy$[ebp], eax
	mov	DWORD PTR _per$[ebp], esi
	je	SHORT $LN40@torus_edge

; 1521 :   { torus_arc_clip(gdata,m);

	push	eax
	push	edi
	call	_torus_arc_clip

; 1623 :   }
; 1624 :   else
; 1625 :     torus_edge_clip(gdata,m+1);

	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1626 : 
; 1627 : } /* end torus_edge_clip() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@torus_edge:

; 1522 :     return;
; 1523 :   }
; 1524 : 
; 1525 :   memset(gdata1,0,2*sizeof(struct graphdata));

	push	288					; 00000120H
	lea	eax, DWORD PTR _gdata1$[ebp]
	push	esi
	push	eax
	call	_memset

; 1526 : 
; 1527 :   if ( web.torus_display_period && web.torus_period )

	mov	ecx, DWORD PTR _web+1620
	mov	eax, DWORD PTR _web+1608
	add	esp, 12					; 0000000cH
	cmp	ecx, esi
	je	SHORT $LN39@torus_edge

; 1530 :     invper = web.inverse_display_periods;

	mov	ebx, DWORD PTR _web+1672
	cmp	eax, esi
	je	SHORT $LN37@torus_edge

; 1528 :   { /* per = web.torus_display_period; */
; 1529 :     per = web.torus_period;

	mov	DWORD PTR _per$[ebp], eax

; 1530 :     invper = web.inverse_display_periods;

	jmp	SHORT $LN34@torus_edge
$LN39@torus_edge:

; 1531 :   }
; 1532 :   else if ( web.torus_period )

	cmp	eax, esi
	je	SHORT $LN35@torus_edge

; 1533 :   { per = web.torus_period;
; 1534 :     invper = web.inverse_periods;

	mov	ebx, DWORD PTR _web+1612
	mov	DWORD PTR _per$[ebp], eax
	jmp	SHORT $LN34@torus_edge
$LN37@torus_edge:

; 1535 :   }
; 1536 :   else if ( web.torus_display_period )
; 1537 :   { per = web.torus_display_period; 

	mov	DWORD PTR _per$[ebp], ecx

; 1538 :     invper = web.inverse_display_periods;
; 1539 :   }
; 1540 :   else 

	jmp	SHORT $LN34@torus_edge
$LN35@torus_edge:

; 1541 :     graph_edge_clip(gdata,gdata->id);

	mov	ecx, DWORD PTR [edi+128]
	push	ecx
	push	edi
	call	_graph_edge_clip
	add	esp, 8
$LN34@torus_edge:

; 1542 : 
; 1543 :   for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	test	eax, eax
	jle	SHORT $LN31@torus_edge
$LL33@torus_edge:

; 1544 :     orig[i] = SDIM_dot(invper[i],web.display_origin);

	mov	edx, DWORD PTR [ebx+esi*4]
	push	eax
	push	OFFSET _web+1624
	push	edx
	call	_dot
	fstp	QWORD PTR _orig$[ebp+esi*8]
	mov	eax, DWORD PTR _web+616
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, eax
	jl	SHORT $LL33@torus_edge
$LN31@torus_edge:

; 1545 :    
; 1546 :   /* see if any vertices outside cell in this coordinate */
; 1547 :   for ( i = 0 ; i < 2 ; i++ )

	xor	esi, esi
	jmp	SHORT $LN30@torus_edge
	npad	10
$LL59@torus_edge:
	mov	eax, DWORD PTR _web+616
$LN30@torus_edge:

; 1548 :      wrap[i] = (int)floor(SDIM_dot(invper[m],gdata[i].x)-orig[m]);

	push	eax
	mov	eax, DWORD PTR _m$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ebx+eax*4]
	push	edi
	push	ecx
	call	_dot
	mov	edx, DWORD PTR _m$GSCopy$[ebp]
	fsub	QWORD PTR _orig$[ebp+edx*8]
	add	esp, 4
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _wrap$[ebp+esi*4], eax
	inc	esi
	add	edi, 144				; 00000090H
	cmp	esi, 2
	jl	SHORT $LL59@torus_edge

; 1549 : 
; 1550 :   /* split, if necessary */
; 1551 :   if ( wrap[0] != wrap[1] )

	mov	eax, DWORD PTR _wrap$[ebp]
	mov	ecx, DWORD PTR _wrap$[ebp+4]
	cmp	eax, ecx
	je	$LN62@torus_edge

; 1552 :   { int cut = (wrap[0] > wrap[1]) ? wrap[0] : wrap[1];

	mov	DWORD PTR _cut$90528[ebp], eax
	jg	SHORT $LN44@torus_edge
	mov	DWORD PTR _cut$90528[ebp], ecx
$LN44@torus_edge:

; 1553 : 
; 1554 :     /* set up head of new edge */
; 1555 :     gdata1[1] = gdata[1];

	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]

; 1556 :     gdata1[0].id = gdata[0].id;
; 1557 :     gdata1[0].etype = gdata[0].etype;

	mov	dx, WORD PTR [eax+124]
	lea	esi, DWORD PTR [eax+144]
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata1$[ebp+144]
	rep movsd
	mov	ecx, DWORD PTR [eax+128]

; 1558 :     gdata1[0].flags = gdata[0].flags & ~LABEL_TAIL;
; 1559 :     gdata[0].flags &= ~LABEL_HEAD;
; 1560 :     gdata[1].v_id = NULLID;
; 1561 :     gdata1[0].v_id = NULLID;
; 1562 : 
; 1563 :     /* calculate new vertex */
; 1564 :     a = SDIM_dot(invper[m],gdata[0].x)-orig[m];

	mov	edi, DWORD PTR _m$GSCopy$[ebp]
	mov	DWORD PTR _gdata1$[ebp+128], ecx
	mov	ecx, DWORD PTR [eax+136]
	mov	WORD PTR _gdata1$[ebp+124], dx
	mov	edx, ecx
	and	ecx, -2049				; fffff7ffH
	xor	esi, esi
	mov	DWORD PTR [eax+136], ecx
	mov	DWORD PTR [eax+276], esi
	mov	ecx, DWORD PTR _web+616
	and	edx, -4097				; ffffefffH
	push	ecx
	mov	DWORD PTR _gdata1$[ebp+136], edx
	mov	DWORD PTR _gdata1$[ebp+132], esi
	mov	edx, DWORD PTR [ebx+edi*4]
	push	eax
	push	edx
	call	_dot

; 1565 :     b = SDIM_dot(invper[m],gdata1[1].x)-orig[m];

	mov	eax, DWORD PTR _web+616
	fsub	QWORD PTR _orig$[ebp+edi*8]
	mov	edx, DWORD PTR [ebx+edi*4]
	push	eax
	lea	ecx, DWORD PTR _gdata1$[ebp+144]
	fst	QWORD PTR _a$[ebp]
	push	ecx

; 1566 :     t = (cut - a)/(b - a);

	fisubr	DWORD PTR _cut$90528[ebp]
	push	edx
	fstp	QWORD PTR tv779[ebp]
	call	_dot
	fsub	QWORD PTR _orig$[ebp+edi*8]
	add	esp, 24					; 00000018H
	fsub	QWORD PTR _a$[ebp]
	fdivr	QWORD PTR tv779[ebp]

; 1567 :     if ( t < 0.0 ) t = 0.0;   /* clamp */

	fldz
	fcom	ST(1)
	fnstsw	ax
	fld1
	test	ah, 65					; 00000041H
	jne	SHORT $LN64@torus_edge
	fstp	ST(2)
	jmp	SHORT $LN24@torus_edge
$LN64@torus_edge:
	fstp	ST(1)

; 1568 :     else if ( t > 1.0 ) t = 1.0;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN73@torus_edge
	fstp	ST(1)
	fld	ST(0)
	jmp	SHORT $LN24@torus_edge
$LN73@torus_edge:
	fxch	ST(1)
$LN24@torus_edge:

; 1569 :     for ( k = 0 ; k < SDIM ; k++ )

	mov	edx, DWORD PTR _web+616
	xor	ecx, ecx
	cmp	edx, esi
	jle	SHORT $LN71@torus_edge
	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	fsub	ST(1), ST(0)
	lea	esi, DWORD PTR _gdata1$[ebp+144]
	lea	ebx, DWORD PTR _gdata1$[ebp]
	sub	esi, eax
	sub	ebx, eax
$LN23@torus_edge:

; 1570 :       gdata1[0].x[k] = gdata[1].x[k] =
; 1571 :           (1 - t)*gdata[0].x[k] + t*gdata1[1].x[k];

	fld	QWORD PTR [esi+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fld	ST(2)
	fmul	QWORD PTR [eax-8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [eax+136]
	mov	edx, DWORD PTR _web+616
	fstp	QWORD PTR [ebx+eax-8]
	cmp	ecx, edx
	jl	SHORT $LN23@torus_edge
$LN71@torus_edge:

; 1569 :     for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)

; 1572 : 
; 1573 :     /* wrap new edge vertices properly */
; 1574 :     for ( i = 0 ; i < 2 ; i++ )

	lea	esi, DWORD PTR _gdata1$[ebp]
	fstp	ST(0)
	mov	DWORD PTR tv330[ebp], 2
	npad	4
$LL20@torus_edge:

; 1575 :      for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN19@torus_edge
	fild	DWORD PTR _wrap$[ebp+4]
	mov	ecx, esi
$LN17@torus_edge:

; 1576 :          gdata1[i].x[k] -= wrap[1]*per[m][k];

	mov	ebx, DWORD PTR _per$[ebp]
	mov	ebx, DWORD PTR [ebx+edi*4]
	fld	QWORD PTR [ebx+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	add	ecx, 8
	fsubr	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
	cmp	eax, edx
	jl	SHORT $LN17@torus_edge

; 1575 :      for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
$LN19@torus_edge:

; 1572 : 
; 1573 :     /* wrap new edge vertices properly */
; 1574 :     for ( i = 0 ; i < 2 ; i++ )

	add	esi, 144				; 00000090H
	dec	DWORD PTR tv330[ebp]
	jne	SHORT $LL20@torus_edge

; 1577 : 
; 1578 :     /* kludge for display_periods to get back towards box */
; 1579 :     /*
; 1580 :     if ( web.torus_display_period )
; 1581 :     { int ww = (int)floor((SDIM_dot(invper[1-m],gdata1[0].x) + 
; 1582 :                          SDIM_dot(invper[1-m],gdata1[1].x))/2 - orig[1-m]);
; 1583 :       for ( i = 0 ; i < 2 ; i++ )
; 1584 :        for ( k = 0 ; k < SDIM ; k++ )
; 1585 :          gdata1[i].x[k] -= ww*per[1-m][k];
; 1586 :     }
; 1587 :     */
; 1588 : 
; 1589 :     /* send on for further check, or plot */
; 1590 :     gdata1[0].color = gdata1[0].ecolor = gdata[0].color;

	mov	ebx, DWORD PTR _gdata$GSCopy$[ebp]
	mov	eax, DWORD PTR [ebx+104]

; 1591 :     if ( m == SDIM-1 ) 

	dec	edx
	mov	DWORD PTR _gdata1$[ebp+120], eax
	mov	DWORD PTR _gdata1$[ebp+104], eax
	cmp	edi, edx
	jne	SHORT $LN14@torus_edge

; 1592 :     { if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE) )

	cmp	DWORD PTR _web+860, 0
	je	SHORT $LN61@torus_edge
	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN61@torus_edge

; 1593 :         (*graph_edge_transforms)(gdata1,gdata[0].id);

	mov	eax, DWORD PTR [ebx+128]
	push	eax
	lea	ecx, DWORD PTR _gdata1$[ebp]
	push	ecx
	call	_graph_edge_transforms
	add	esp, 8

; 1594 :       else

	jmp	SHORT $LN11@torus_edge
$LN61@torus_edge:

; 1595 :         graph_edge_clip(gdata1,gdata[0].id);

	mov	edx, DWORD PTR [ebx+128]
	push	edx
	lea	eax, DWORD PTR _gdata1$[ebp]
	push	eax
	call	_graph_edge_clip
	add	esp, 8

; 1596 :     }
; 1597 :     else

	jmp	SHORT $LN11@torus_edge
$LN14@torus_edge:

; 1598 :       torus_edge_clip(gdata1,m+1);

	lea	ecx, DWORD PTR [edi+1]
	push	ecx
	lea	edx, DWORD PTR _gdata1$[ebp]
	push	edx
	call	_torus_edge_clip
	add	esp, 8
	jmp	SHORT $LN11@torus_edge
$LN62@torus_edge:
	mov	edi, DWORD PTR _m$GSCopy$[ebp]
	mov	ebx, DWORD PTR _gdata$GSCopy$[ebp]
$LN11@torus_edge:

; 1599 :   }
; 1600 : 
; 1601 :   /* wrap vertices properly */
; 1602 :   for ( i = 0 ; i < 2 ; i++ )

	mov	esi, DWORD PTR _web+616
	mov	DWORD PTR tv833[ebp], 2
$LL10@torus_edge:

; 1603 :     for ( k = 0 ; k < SDIM ; k++ )

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN9@torus_edge
	mov	eax, DWORD PTR _per$[ebp]
	fild	DWORD PTR _wrap$[ebp]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, ebx
$LN7@torus_edge:

; 1604 :        gdata[i].x[k] -=  wrap[0]*per[m][k];

	fld	QWORD PTR [ecx]
	inc	edx
	fmul	ST(0), ST(1)
	add	ecx, 8
	add	eax, 8
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	esi, DWORD PTR _web+616
	cmp	edx, esi
	jl	SHORT $LN7@torus_edge

; 1603 :     for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
$LN9@torus_edge:

; 1599 :   }
; 1600 : 
; 1601 :   /* wrap vertices properly */
; 1602 :   for ( i = 0 ; i < 2 ; i++ )

	add	ebx, 144				; 00000090H
	dec	DWORD PTR tv833[ebp]
	jne	SHORT $LL10@torus_edge

; 1605 : 
; 1606 :   /* kludge for display_periods to get back towards box */
; 1607 :   /*
; 1608 :     if ( web.torus_display_period )
; 1609 :     { int ww = (int)floor((SDIM_dot(invper[1-m],gdata[0].x) +
; 1610 :                  SDIM_dot(invper[1-m],gdata[1].x))/2-orig[1-m]);
; 1611 :       for ( i = 0 ; i < 2 ; i++ )
; 1612 :        for ( k = 0 ; k < SDIM ; k++ )
; 1613 :          gdata[i].x[k] -= ww*per[1-m][k];
; 1614 :     }
; 1615 :     */
; 1616 : 
; 1617 :   /* send on original edge structure */
; 1618 :   if ( m == SDIM-1 ) 

	dec	esi
	cmp	edi, esi
	jne	SHORT $LN4@torus_edge

; 1619 :   { if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE) )

	cmp	DWORD PTR _web+860, 0
	je	SHORT $LN3@torus_edge
	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN3@torus_edge

; 1620 :       (*graph_edge_transforms)(gdata,gdata[0].id);

	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	push	ecx
	push	eax
	call	_graph_edge_transforms

; 1623 :   }
; 1624 :   else
; 1625 :     torus_edge_clip(gdata,m+1);

	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1626 : 
; 1627 : } /* end torus_edge_clip() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@torus_edge:

; 1621 :     else
; 1622 :       graph_edge_clip(gdata,gdata->id);

	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	mov	edx, DWORD PTR [eax+128]
	push	edx
	push	eax
	call	_graph_edge_clip

; 1623 :   }
; 1624 :   else
; 1625 :     torus_edge_clip(gdata,m+1);

	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1626 : 
; 1627 : } /* end torus_edge_clip() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@torus_edge:

; 1623 :   }
; 1624 :   else
; 1625 :     torus_edge_clip(gdata,m+1);

	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	inc	edi
	push	edi
	push	eax
	call	_torus_edge_clip

; 1626 : 
; 1627 : } /* end torus_edge_clip() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_torus_edge_clip ENDP
_TEXT	ENDS
PUBLIC	_option_facet
; Function compile flags: /Ogtp
;	COMDAT _option_facet
_TEXT	SEGMENT
_gdata$ = 8						; size = 4
_f_id$ = 12						; size = 4
_option_facet PROC					; COMDAT

; 928  : {

	push	ebp
	mov	ebp, esp

; 929  :   if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	mov	eax, DWORD PTR _gdata$[ebp]
	je	SHORT $LN3@option_fac

; 930  :   { gdata[0].flags &= ~(LIST_FACET | SIMPLE_FACET);

	and	DWORD PTR [eax+136], -4			; fffffffcH

; 931  :   }
; 932  :   if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE) )

	cmp	DWORD PTR _web+860, 0
	je	SHORT $LN3@option_fac
	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN3@option_fac

; 933  :   {  torus_clip(gdata,SDIM-1,f_id); }

	mov	ecx, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR _web+616
	push	ecx
	dec	edx
	push	edx
	push	eax
	call	_torus_clip
	add	esp, 12					; 0000000cH

; 938  :   }
; 939  : } // end option_facet()

	pop	ebp
	ret	0
$LN3@option_fac:

; 934  :   else
; 935  :   { if ( !web.symmetry_flag && (web.representation != STRING) ) 

	cmp	DWORD PTR _web+856, 0
	jne	SHORT $LN1@option_fac
	mov	ecx, 1
	cmp	DWORD PTR _web+624, ecx
	je	SHORT $LN1@option_fac

; 936  :       gdata[0].flags |= SIMPLE_FACET;

	or	DWORD PTR [eax+136], ecx
$LN1@option_fac:

; 937  :     graph_facet_transforms(gdata,f_id);

	mov	ecx, DWORD PTR _f_id$[ebp]
	push	ecx
	push	eax
	call	_graph_facet_transforms
	add	esp, 8

; 938  :   }
; 939  : } // end option_facet()

	pop	ebp
	ret	0
_option_facet ENDP
_TEXT	ENDS
PUBLIC	_gdata$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtp
;	COMDAT _graph_edge_transforms
_TEXT	SEGMENT
tv2879 = -468						; size = 4
tv2881 = -464						; size = 4
tv2689 = -460						; size = 4
_ctrl_pts$ = -456					; size = 4
tv2846 = -452						; size = 4
tv361 = -452						; size = 4
_gdata$GSCopy$ = -448					; size = 4
tv2818 = -444						; size = 4
tv2203 = -444						; size = 4
tv2219 = -440						; size = 4
_i$ = -440						; size = 4
_gt$ = -436						; size = 432
__$ArrayPad$ = -4					; size = 4
_gdata$ = 8						; size = 4
_e_id$ = 12						; size = 4
_graph_edge_transforms PROC				; COMDAT

; 953  : { int i,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 468				; 000001d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _gdata$[ebp]

; 954  :   struct graphdata gt[3];
; 955  :   int ctrl_pts = gdata[0].flags & EDGE_ARC ? 3 : 2;

	mov	esi, DWORD PTR [edi+136]
	and	esi, 32768				; 00008000H

; 956  : 
; 957  :   memset(gt,0,3*sizeof(struct graphdata));

	push	432					; 000001b0H
	or	esi, 65536				; 00010000H
	lea	eax, DWORD PTR _gt$[ebp]
	push	0
	shr	esi, 15					; 0000000fH
	push	eax
	mov	DWORD PTR _gdata$GSCopy$[ebp], edi
	mov	DWORD PTR _ctrl_pts$[ebp], esi
	call	_memset
	add	esp, 12					; 0000000cH

; 958  :   for ( i = 0 ; i < ctrl_pts ; i++ ) 

	test	esi, esi
	jle	SHORT $LN33@graph_edge@2
	fld1

; 959  :      gdata[i].x[SDIM] = 1.0;  /* homogeneous coord */

	xor	eax, eax
	mov	ecx, esi
$LN35@graph_edge@2:
	mov	edx, DWORD PTR _web+616
	add	edx, eax
	add	eax, 18					; 00000012H
	fst	QWORD PTR [edi+edx*8]
	dec	ecx
	jne	SHORT $LN35@graph_edge@2

; 958  :   for ( i = 0 ; i < ctrl_pts ; i++ ) 

	fstp	ST(0)
$LN33@graph_edge@2:

; 960  :   if ( box_flag )

	cmp	DWORD PTR _box_flag, 0
	mov	ebx, DWORD PTR _web+616
	je	$LN29@graph_edge@2

; 961  :      for ( j = 0 ; j < ctrl_pts ; j++ )

	test	esi, esi
	jle	$LN29@graph_edge@2
	mov	eax, edi
	mov	ecx, esi
	mov	DWORD PTR tv2203[ebp], 0
	mov	DWORD PTR tv2219[ebp], eax
	mov	DWORD PTR tv361[ebp], ecx
$LL31@graph_edge@2:

; 962  :        for  ( k = 0 ; k < SDIM ; k++ )

	xor	edi, edi
	cmp	ebx, 4
	jl	$LC51@graph_edge@2
	mov	ecx, DWORD PTR tv2219[ebp]
	lea	esi, DWORD PTR [ebx-4]
	shr	esi, 2
	inc	esi
	mov	edx, OFFSET _bounding_box+8
	lea	edi, DWORD PTR [esi*4]
$LL60@graph_edge@2:

; 963  :        { if ( gdata[j].x[k] < bounding_box[k][0] )

	fld	QWORD PTR [edx-8]
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN52@graph_edge@2

; 964  :            bounding_box[k][0] = gdata[j].x[k];

	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [edx-8]
$LN52@graph_edge@2:

; 965  :          if ( gdata[j].x[k] > bounding_box[k][1] )

	fld	QWORD PTR [edx]
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN53@graph_edge@2

; 966  :            bounding_box[k][1] = gdata[j].x[k];

	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [edx]
$LN53@graph_edge@2:

; 963  :        { if ( gdata[j].x[k] < bounding_box[k][0] )

	fld	QWORD PTR [edx+8]
	fcomp	QWORD PTR [ecx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN54@graph_edge@2

; 964  :            bounding_box[k][0] = gdata[j].x[k];

	fld	QWORD PTR [ecx+8]
	fstp	QWORD PTR [edx+8]
$LN54@graph_edge@2:

; 965  :          if ( gdata[j].x[k] > bounding_box[k][1] )

	fld	QWORD PTR [edx+16]
	fcomp	QWORD PTR [ecx+8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN55@graph_edge@2

; 966  :            bounding_box[k][1] = gdata[j].x[k];

	fld	QWORD PTR [ecx+8]
	fstp	QWORD PTR [edx+16]
$LN55@graph_edge@2:

; 963  :        { if ( gdata[j].x[k] < bounding_box[k][0] )

	fld	QWORD PTR [edx+24]
	fcomp	QWORD PTR [ecx+16]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN56@graph_edge@2

; 964  :            bounding_box[k][0] = gdata[j].x[k];

	fld	QWORD PTR [ecx+16]
	fstp	QWORD PTR [edx+24]
$LN56@graph_edge@2:

; 965  :          if ( gdata[j].x[k] > bounding_box[k][1] )

	fld	QWORD PTR [edx+32]
	fcomp	QWORD PTR [ecx+16]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN57@graph_edge@2

; 966  :            bounding_box[k][1] = gdata[j].x[k];

	fld	QWORD PTR [ecx+16]
	fstp	QWORD PTR [edx+32]
$LN57@graph_edge@2:

; 963  :        { if ( gdata[j].x[k] < bounding_box[k][0] )

	fld	QWORD PTR [edx+40]
	fcomp	QWORD PTR [ecx+24]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN58@graph_edge@2

; 964  :            bounding_box[k][0] = gdata[j].x[k];

	fld	QWORD PTR [ecx+24]
	fstp	QWORD PTR [edx+40]
$LN58@graph_edge@2:

; 965  :          if ( gdata[j].x[k] > bounding_box[k][1] )

	fld	QWORD PTR [edx+48]
	fcomp	QWORD PTR [ecx+24]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN59@graph_edge@2

; 966  :            bounding_box[k][1] = gdata[j].x[k];

	fld	QWORD PTR [ecx+24]
	fstp	QWORD PTR [edx+48]
$LN59@graph_edge@2:

; 962  :        for  ( k = 0 ; k < SDIM ; k++ )

	add	ecx, 32					; 00000020H
	add	edx, 64					; 00000040H
	dec	esi
	jne	$LL60@graph_edge@2
$LC51@graph_edge@2:
	cmp	edi, ebx
	jge	SHORT $LN30@graph_edge@2
	mov	edx, DWORD PTR tv2203[ebp]
	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	mov	ecx, edi
	shl	ecx, 4
	add	edx, edi
	mov	esi, ebx
	add	ecx, OFFSET _bounding_box+8
	lea	edx, DWORD PTR [eax+edx*8]
	sub	esi, edi
	npad	7
$LC28@graph_edge@2:

; 963  :        { if ( gdata[j].x[k] < bounding_box[k][0] )

	fld	QWORD PTR [ecx-8]
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN25@graph_edge@2

; 964  :            bounding_box[k][0] = gdata[j].x[k];

	fld	QWORD PTR [edx]
	fstp	QWORD PTR [ecx-8]
$LN25@graph_edge@2:

; 965  :          if ( gdata[j].x[k] > bounding_box[k][1] )

	fld	QWORD PTR [ecx]
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN27@graph_edge@2

; 966  :            bounding_box[k][1] = gdata[j].x[k];

	fld	QWORD PTR [edx]
	fstp	QWORD PTR [ecx]
$LN27@graph_edge@2:

; 962  :        for  ( k = 0 ; k < SDIM ; k++ )

	add	edx, 8
	add	ecx, 16					; 00000010H
	dec	esi
	jne	SHORT $LC28@graph_edge@2
$LN30@graph_edge@2:

; 961  :      for ( j = 0 ; j < ctrl_pts ; j++ )

	add	DWORD PTR tv2219[ebp], 144		; 00000090H
	add	DWORD PTR tv2203[ebp], 18		; 00000012H
	dec	DWORD PTR tv361[ebp]
	jne	$LL31@graph_edge@2
$LN29@graph_edge@2:

; 967  :        }
; 968  : 
; 969  :   if ( transforms_flag && (!lazy_transforms_flag || box_flag) && view_transforms &&
; 970  :          !(valid_id(e_id) && (get_eattr(e_id) & NO_TRANSFORM)) &&
; 971  :              (transform_colors_flag || (graph_facet != geomview_facet) )  )

	cmp	DWORD PTR _transforms_flag, 0
	mov	edx, DWORD PTR _e_id$[ebp]
	je	$LN23@graph_edge@2
	cmp	DWORD PTR _lazy_transforms_flag, 0
	je	SHORT $LN22@graph_edge@2
	cmp	DWORD PTR _box_flag, 0
	je	$LN23@graph_edge@2
$LN22@graph_edge@2:
	cmp	DWORD PTR _view_transforms, 0
	je	$LN23@graph_edge@2
	test	edx, 268435456				; 10000000H
	je	SHORT $LN21@graph_edge@2
	mov	eax, DWORD PTR _web+124
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 1
	xor	eax, eax
	or	eax, ecx
	jne	$LN23@graph_edge@2
$LN21@graph_edge@2:
	cmp	DWORD PTR _transform_colors_flag, 0
	jne	SHORT $LN20@graph_edge@2
	cmp	DWORD PTR _graph_facet, OFFSET _geomview_facet
	je	$LN23@graph_edge@2
$LN20@graph_edge@2:

; 972  :     for ( i = 0 ;  i < transform_count ; i++ )

	cmp	DWORD PTR _transform_count, 0
	mov	DWORD PTR _i$[ebp], 0
	jle	$LN1@graph_edge@2
$LL73@graph_edge@2:

; 973  :     { gt[0] = gdata[0];
; 974  :       gt[1].v_id = gdata[1].v_id;
; 975  :       for ( j = 0 ; j < ctrl_pts ; j++ )

	cmp	DWORD PTR _ctrl_pts$[ebp], 0
	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	lea	edi, DWORD PTR _gt$[ebp]
	rep movsd
	mov	ecx, DWORD PTR [eax+276]
	mov	DWORD PTR _gt$[ebp+276], ecx
	jle	$LN14@graph_edge@2
	mov	edx, DWORD PTR _ctrl_pts$[ebp]
	lea	ecx, DWORD PTR _gt$[ebp]
	sub	ecx, eax
	mov	DWORD PTR tv2879[ebp], ecx
	lea	ecx, DWORD PTR _gt$[ebp+8]
	sub	ecx, eax
	mov	DWORD PTR tv2818[ebp], 0
	mov	DWORD PTR tv2846[ebp], eax
	mov	DWORD PTR tv2881[ebp], ecx
	mov	DWORD PTR tv2689[ebp], edx
	npad	9
$LL72@graph_edge@2:

; 976  :         { matvec_mul(view_transforms[i],gdata[j].x,gt[j].x,
; 977  :                   SDIM+1,SDIM+1); 

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR tv2879[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	inc	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR tv2846[ebp]
	add	ecx, eax
	push	ecx
	push	eax
	mov	eax, DWORD PTR _view_transforms
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_matvec_mul

; 978  :           for ( k = 0 ; k <= SDIM ; k++ )

	xor	ebx, ebx
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _web+616, ebx
	jl	$LN15@graph_edge@2
	mov	edx, DWORD PTR _web+616
	inc	edx
	cmp	edx, 4
	jl	$LC62@graph_edge@2
	mov	esi, DWORD PTR _web+616
	mov	edi, DWORD PTR tv2818[ebp]

; 979  :           { gt[j].x[k] /= gt[j].x[SDIM]; /* normalize */

	mov	ecx, DWORD PTR tv2881[ebp]
	add	ecx, DWORD PTR tv2846[ebp]
	add	edi, esi
	inc	esi
	shr	esi, 2
	lea	edi, DWORD PTR _gt$[ebp+edi*8]
	mov	edx, OFFSET _bounding_box+8
	lea	ebx, DWORD PTR [esi*4]
	npad	2
$LL71@graph_edge@2:

; 980  :             if ( box_flag )

	cmp	DWORD PTR _box_flag, 0
	fld	QWORD PTR [ecx-8]
	fdiv	QWORD PTR [edi]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [ecx-8]
	je	SHORT $LN89@graph_edge@2

; 981  :             { if ( gt[j].x[k] < bounding_box[k][0] )

	fcom	QWORD PTR [edx-8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN63@graph_edge@2

; 982  :                  bounding_box[k][0] = gt[j].x[k];

	fst	QWORD PTR [edx-8]
$LN63@graph_edge@2:

; 983  :               if ( gt[j].x[k] > bounding_box[k][1] )

	fcom	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN89@graph_edge@2

; 984  :                  bounding_box[k][1] = gt[j].x[k];

	fstp	QWORD PTR [edx]
	jmp	SHORT $LN74@graph_edge@2
$LN89@graph_edge@2:

; 983  :               if ( gt[j].x[k] > bounding_box[k][1] )

	fstp	ST(0)
$LN74@graph_edge@2:

; 980  :             if ( box_flag )

	cmp	DWORD PTR _box_flag, 0
	fld	QWORD PTR [ecx]
	fdiv	QWORD PTR [edi]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [ecx]
	je	SHORT $LN98@graph_edge@2

; 981  :             { if ( gt[j].x[k] < bounding_box[k][0] )

	fcom	QWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN65@graph_edge@2

; 982  :                  bounding_box[k][0] = gt[j].x[k];

	fst	QWORD PTR [edx+8]
$LN65@graph_edge@2:

; 983  :               if ( gt[j].x[k] > bounding_box[k][1] )

	fcom	QWORD PTR [edx+16]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN98@graph_edge@2

; 984  :                  bounding_box[k][1] = gt[j].x[k];

	fstp	QWORD PTR [edx+16]
	jmp	SHORT $LN75@graph_edge@2
$LN98@graph_edge@2:

; 983  :               if ( gt[j].x[k] > bounding_box[k][1] )

	fstp	ST(0)
$LN75@graph_edge@2:

; 980  :             if ( box_flag )

	cmp	DWORD PTR _box_flag, 0
	fld	QWORD PTR [ecx+8]
	fdiv	QWORD PTR [edi]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [ecx+8]
	je	SHORT $LN107@graph_edge@2

; 981  :             { if ( gt[j].x[k] < bounding_box[k][0] )

	fcom	QWORD PTR [edx+24]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN67@graph_edge@2

; 982  :                  bounding_box[k][0] = gt[j].x[k];

	fst	QWORD PTR [edx+24]
$LN67@graph_edge@2:

; 983  :               if ( gt[j].x[k] > bounding_box[k][1] )

	fcom	QWORD PTR [edx+32]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN107@graph_edge@2

; 984  :                  bounding_box[k][1] = gt[j].x[k];

	fstp	QWORD PTR [edx+32]
	jmp	SHORT $LN76@graph_edge@2
$LN107@graph_edge@2:

; 983  :               if ( gt[j].x[k] > bounding_box[k][1] )

	fstp	ST(0)
$LN76@graph_edge@2:

; 980  :             if ( box_flag )

	cmp	DWORD PTR _box_flag, 0
	fld	QWORD PTR [ecx+16]
	fdiv	QWORD PTR [edi]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [ecx+16]
	je	SHORT $LN116@graph_edge@2

; 981  :             { if ( gt[j].x[k] < bounding_box[k][0] )

	fcom	QWORD PTR [edx+40]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN69@graph_edge@2

; 982  :                  bounding_box[k][0] = gt[j].x[k];

	fst	QWORD PTR [edx+40]
$LN69@graph_edge@2:

; 983  :               if ( gt[j].x[k] > bounding_box[k][1] )

	fcom	QWORD PTR [edx+48]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN116@graph_edge@2

; 984  :                  bounding_box[k][1] = gt[j].x[k];

	fstp	QWORD PTR [edx+48]
	jmp	SHORT $LN77@graph_edge@2
$LN116@graph_edge@2:

; 983  :               if ( gt[j].x[k] > bounding_box[k][1] )

	fstp	ST(0)
$LN77@graph_edge@2:

; 979  :           { gt[j].x[k] /= gt[j].x[SDIM]; /* normalize */

	add	ecx, 32					; 00000020H
	add	edx, 64					; 00000040H
	dec	esi
	jne	$LL71@graph_edge@2
$LC62@graph_edge@2:

; 978  :           for ( k = 0 ; k <= SDIM ; k++ )

	cmp	ebx, DWORD PTR _web+616
	jg	SHORT $LN15@graph_edge@2
	mov	eax, DWORD PTR tv2818[ebp]
	mov	edx, DWORD PTR _web+616
	lea	edi, DWORD PTR [eax+edx]
	mov	ecx, ebx
	shl	ecx, 4
	lea	esi, DWORD PTR [eax+ebx]
	sub	edx, ebx
	add	ecx, OFFSET _bounding_box+8
	lea	edi, DWORD PTR _gt$[ebp+edi*8]
	lea	esi, DWORD PTR _gt$[ebp+esi*8]
	inc	edx
	npad	5
$LC13@graph_edge@2:

; 980  :             if ( box_flag )

	cmp	DWORD PTR _box_flag, 0
	fld	QWORD PTR [esi]
	fdiv	QWORD PTR [edi]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [esi]
	je	SHORT $LN125@graph_edge@2

; 981  :             { if ( gt[j].x[k] < bounding_box[k][0] )

	fcom	QWORD PTR [ecx-8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@graph_edge@2

; 982  :                  bounding_box[k][0] = gt[j].x[k];

	fst	QWORD PTR [ecx-8]
$LN9@graph_edge@2:

; 983  :               if ( gt[j].x[k] > bounding_box[k][1] )

	fcom	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN125@graph_edge@2

; 984  :                  bounding_box[k][1] = gt[j].x[k];

	fstp	QWORD PTR [ecx]
	jmp	SHORT $LN12@graph_edge@2
$LN125@graph_edge@2:

; 983  :               if ( gt[j].x[k] > bounding_box[k][1] )

	fstp	ST(0)
$LN12@graph_edge@2:

; 978  :           for ( k = 0 ; k <= SDIM ; k++ )

	add	esi, 8
	add	ecx, 16					; 00000010H
	dec	edx
	jne	SHORT $LC13@graph_edge@2
$LN15@graph_edge@2:

; 973  :     { gt[0] = gdata[0];
; 974  :       gt[1].v_id = gdata[1].v_id;
; 975  :       for ( j = 0 ; j < ctrl_pts ; j++ )

	add	DWORD PTR tv2846[ebp], 144		; 00000090H
	add	DWORD PTR tv2818[ebp], 18		; 00000012H
	dec	DWORD PTR tv2689[ebp]
	jne	$LL72@graph_edge@2
$LN14@graph_edge@2:

; 985  :             }
; 986  :           }
; 987  :         }
; 988  :         if ( lazy_transforms_flag && (i > 0) )

	cmp	DWORD PTR _lazy_transforms_flag, 0
	mov	esi, DWORD PTR _i$[ebp]
	je	SHORT $LN7@graph_edge@2
	test	esi, esi
	jg	SHORT $LN18@graph_edge@2
$LN7@graph_edge@2:

; 989  :           continue;  // just needed to do box
; 990  :         if ( (web.representation == STRING) && transform_colors_flag )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN6@graph_edge@2
	cmp	DWORD PTR _transform_colors_flag, 0
	je	SHORT $LN6@graph_edge@2

; 991  :           gt[0].ecolor = transform_colors[i];

	mov	ecx, DWORD PTR _transform_colors
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR _gt$[ebp+120], edx
$LN6@graph_edge@2:

; 992  :         if ( (torus_display_mode == TORUS_CLIPPED_MODE) &&
; 993  :             web.torus_display_period && !web.torus_flag )

	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN5@graph_edge@2
	cmp	DWORD PTR _web+1620, 0
	je	SHORT $LN5@graph_edge@2
	cmp	DWORD PTR _web+860, 0
	jne	SHORT $LN5@graph_edge@2

; 994  :           torus_edge_clip(gt,0);

	lea	eax, DWORD PTR _gt$[ebp]
	push	0
	push	eax
	call	_torus_edge_clip

; 995  :         else 

	jmp	SHORT $LN127@graph_edge@2
$LN5@graph_edge@2:

; 996  :         graph_edge_clip(gt,e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	lea	edx, DWORD PTR _gt$[ebp]
	push	edx
	call	_graph_edge_clip
$LN127@graph_edge@2:
	add	esp, 8
$LN18@graph_edge@2:

; 972  :     for ( i = 0 ;  i < transform_count ; i++ )

	inc	esi
	mov	DWORD PTR _i$[ebp], esi
	cmp	esi, DWORD PTR _transform_count
	jl	$LL73@graph_edge@2
	pop	edi
	pop	esi
	pop	ebx

; 1004 :   }
; 1005 : } /* graph_edge_transforms */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@graph_edge@2:

; 997  :      }
; 998  :   else
; 999  :   { if ( (torus_display_mode == TORUS_CLIPPED_MODE) &&
; 1000 :        web.torus_display_period && !web.torus_flag )

	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN2@graph_edge@2
	cmp	DWORD PTR _web+1620, 0
	je	SHORT $LN2@graph_edge@2
	cmp	DWORD PTR _web+860, 0
	jne	SHORT $LN2@graph_edge@2

; 1001 :       torus_edge_clip(gdata,0);

	mov	eax, DWORD PTR _gdata$GSCopy$[ebp]
	push	0
	push	eax
	call	_torus_edge_clip

; 1002 :     else 
; 1003 :      graph_edge_clip(gdata,e_id);

	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1004 :   }
; 1005 : } /* graph_edge_transforms */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@graph_edge@2:

; 1002 :     else 
; 1003 :      graph_edge_clip(gdata,e_id);

	mov	ecx, DWORD PTR _gdata$GSCopy$[ebp]
	push	edx
	push	ecx
	call	_graph_edge_clip
	add	esp, 8
$LN1@graph_edge@2:

; 1004 :   }
; 1005 : } /* graph_edge_transforms */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_graph_edge_transforms ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EG@NJKMPKCL@Edge?5?$CFs?5endpoints?5are?5antipodal?$DL@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	__real@3f91df46a2529d39
PUBLIC	__real@3fb41b2f769cf0e0
PUBLIC	??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_plain_edges
EXTRN	_kb_error:PROC
EXTRN	_errmsg:BYTE
EXTRN	_elnames:BYTE
EXTRN	_lagrange_eval_1d:PROC
EXTRN	_bezier_eval_1d:PROC
EXTRN	_bezier_flag:DWORD
EXTRN	_labelflag:DWORD
EXTRN	_string_curve_tolerance:QWORD
EXTRN	_circular_arc_flag:DWORD
EXTRN	_ceil:PROC
EXTRN	_graph_capabilities:DWORD
EXTRN	_spherical_arc_flag:DWORD
EXTRN	_get_edge_verts:PROC
EXTRN	_eval:PROC
EXTRN	_show_expr:BYTE
EXTRN	_breakflag:DWORD
EXTRN	_myfree:PROC
EXTRN	_free_temp_matrix:PROC
EXTRN	_kb_temp_dmatrix:PROC
EXTRN	_kb_calloc:PROC
EXTRN	_smooth_graph_flag:DWORD
EXTRN	__CIacos:PROC
;	COMDAT ??_C@_0EG@NJKMPKCL@Edge?5?$CFs?5endpoints?5are?5antipodal?$DL@
CONST	SEGMENT
??_C@_0EG@NJKMPKCL@Edge?5?$CFs?5endpoints?5are?5antipodal?$DL@ DB 'Edge %'
	DB	's endpoints are antipodal; cannot be graphed as spherical arc'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT __real@3f91df46a2529d39
CONST	SEGMENT
__real@3f91df46a2529d39 DQ 03f91df46a2529d39r	; 0.0174533
CONST	ENDS
;	COMDAT __real@3fb41b2f769cf0e0
CONST	SEGMENT
__real@3fb41b2f769cf0e0 DQ 03fb41b2f769cf0e0r	; 0.0785398
CONST	ENDS
;	COMDAT ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
CONST	SEGMENT
??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@ DB 'GRAPHGEN.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _plain_edges
_TEXT	SEGMENT
_gdata$ = -400						; size = 4
tv1898 = -396						; size = 4
tv2089 = -392						; size = 8
_mag2$90339 = -392					; size = 8
_mag2$90283 = -392					; size = 8
_dangle$90252 = -392					; size = 8
_angle$90251 = -392					; size = 8
_rr$90247 = -392					; size = 8
_ctrlpts$ = -384					; size = 4
tv5306 = -380						; size = 8
tv5304 = -380						; size = 8
tv2099 = -380						; size = 8
tv5494 = -376						; size = 4
tv5490 = -376						; size = 4
tv5477 = -376						; size = 4
tv3185 = -376						; size = 4
tv2375 = -376						; size = 4
tv2205 = -372						; size = 8
tv3154 = -368						; size = 4
_k$ = -368						; size = 4
_verts$ = -364						; size = 4
_segs$ = -360						; size = 4
tv2350 = -356						; size = 4
_headv$90371 = -356					; size = 4
_segments$90294 = -356					; size = 4
_v$90231 = -356						; size = 4
_e_id$ = -352						; size = 4
tv2098 = -348						; size = 8
_mag1$90338 = -348					; size = 8
_mag1$90281 = -348					; size = 8
_ab$90250 = -348					; size = 8
tv5561 = -344						; size = 4
tv3143 = -344						; size = 4
tv2317 = -344						; size = 4
tv2185 = -344						; size = 4
tv1936 = -344						; size = 4
tv1473 = -344						; size = 4
_i$ = -344						; size = 4
_headx$90277 = -340					; size = 48
_midx$90279 = -292					; size = 48
_headx$90333 = -244					; size = 48
_xx$90286 = -244					; size = 48
_base$90248 = -244					; size = 48
_midx$90335 = -196					; size = 48
_tailx$90278 = -196					; size = 48
_perp$90249 = -196					; size = 48
_w2$90337 = -148					; size = 48
_w$90284 = -148						; size = 48
_w1$90336 = -100					; size = 48
_w1$90280 = -100					; size = 48
_tailx$90334 = -52					; size = 48
_w2$90282 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_plain_edges PROC					; COMDAT

; 1126 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1127 :   int i,k;
; 1128 :   edge_id e_id;
; 1129 :   REAL **verts; /* for adjusted triangle vertices */
; 1130 :   struct graphdata *gdata;
; 1131 :   int ctrlpts = web.skel[EDGE].ctrlpts;
; 1132 :   int segs = smooth_graph_flag ? 8 : ctrlpts-1;  /* for smooth plotting */

	cmp	DWORD PTR _smooth_graph_flag, 0
	mov	eax, DWORD PTR _web+120
	mov	DWORD PTR _ctrlpts$[ebp], eax
	mov	ecx, 8
	jne	SHORT $LN256@plain_edge
	lea	ecx, DWORD PTR [eax-1]
$LN256@plain_edge:
	push	ebx
	push	esi

; 1133 :   int to_alloc =  ctrlpts > (segs+1) ? ctrlpts : (segs+1);

	lea	esi, DWORD PTR [ecx+1]
	mov	DWORD PTR _segs$[ebp], ecx
	push	edi
	cmp	eax, esi
	jle	SHORT $LN130@plain_edge
	mov	esi, eax
$LN130@plain_edge:

; 1134 :   gdata = (struct graphdata *)mycalloc(to_alloc,sizeof(struct graphdata));

	push	1134					; 0000046eH
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	push	144					; 00000090H
	push	esi
	call	_kb_calloc

; 1135 : 
; 1136 :   verts = temp_dmatrix(0,to_alloc,0,SDIM);

	push	1136					; 00000470H
	mov	edi, eax
	mov	eax, DWORD PTR _web+616
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	push	eax
	push	0
	push	esi
	push	0
	mov	DWORD PTR _gdata$[ebp], edi
	call	_kb_temp_dmatrix

; 1137 :   gdata[0].etype = REGULAR_EDGE;

	mov	ecx, 1
	mov	DWORD PTR _verts$[ebp], eax
	mov	WORD PTR [edi+124], cx

; 1138 :   MFOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+160
	add	esp, 40					; 00000028H
	mov	DWORD PTR _e_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN125@plain_edge
$LN200@plain_edge:

; 1373 :          }
; 1374 :        }
; 1375 :      }
; 1376 :    }
; 1377 :   free_temp_matrix(verts);

	mov	ecx, DWORD PTR _verts$[ebp]
	push	ecx
	call	_free_temp_matrix

; 1378 :   myfree((char*)gdata);

	push	edi
	call	_myfree
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1379 : 
; 1380 : }  /* end plain_edges() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LL202@plain_edge:

; 1138 :   MFOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _e_id$[ebp]
$LN125@plain_edge:
	mov	edx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1898[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN124@plain_edge

; 1139 :   { if ( breakflag ) break;

	cmp	DWORD PTR _breakflag, ecx
	jne	SHORT $LN200@plain_edge

; 1140 : 
; 1141 :     #ifdef MPI_EVOLVER
; 1142 :     if ( !mpi_show_corona_flag && (id_task(e_id) != this_task) )
; 1143 :        continue;
; 1144 :     #endif
; 1145 : 
; 1146 :     if ( show_expr[EDGE] && show_expr[EDGE]->start )

	mov	eax, DWORD PTR _show_expr+4
	test	eax, eax
	je	SHORT $LN118@plain_edge
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN118@plain_edge

; 1147 :       if ( !eval(show_expr[EDGE],NULL,e_id,NULL) )

	push	ecx
	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	0
	push	eax
	call	_eval
	fldz
	fucompp
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN124@plain_edge
$LN118@plain_edge:

; 1148 :         continue;
; 1149 : 
; 1150 :     gdata[0].flags = 0;
; 1151 : 
; 1152 :     /* get vertices */
; 1153 :     get_edge_verts(e_id,verts,NULL);

	mov	edx, DWORD PTR _verts$[ebp]
	mov	ebx, DWORD PTR _e_id$[ebp]
	xor	esi, esi
	push	esi
	push	edx
	push	ebx
	mov	DWORD PTR [edi+136], esi
	call	_get_edge_verts
	add	esp, 12					; 0000000cH

; 1154 :     for ( i = 0 ; i < SDIM ; i++ )

	cmp	DWORD PTR _web+616, esi
	jle	$LN198@plain_edge
$LL117@plain_edge:

; 1155 :     { gdata[1].x[i] = verts[1][i];

	mov	eax, DWORD PTR _verts$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	QWORD PTR [ecx+esi*8]
	lea	ebx, DWORD PTR [edi+esi*8+288]
	fstp	QWORD PTR [ebx-144]

; 1156 :       gdata[0].x[i] = verts[0][i];

	mov	edx, DWORD PTR [eax]

; 1157 :       gdata[0].v_id = get_edge_tailv(e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	fld	QWORD PTR [edx+esi*8]
	push	eax
	fstp	QWORD PTR [ebx-288]
	call	_get_edge_tailv

; 1158 :       gdata[1].v_id = get_edge_headv(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	mov	DWORD PTR [edi+132], eax
	call	_get_edge_headv
	lea	ecx, DWORD PTR [edi+276]
	mov	DWORD PTR [ecx], eax

; 1159 :       if ( web.modeltype == QUADRATIC )

	mov	eax, DWORD PTR _web+628
	add	esp, 8
	mov	DWORD PTR tv1936[ebp], ecx
	cmp	eax, 2
	jne	SHORT $LN114@plain_edge

; 1160 :       { gdata[2].x[i] = verts[2][i];

	mov	edx, DWORD PTR _verts$[ebp]
	mov	eax, DWORD PTR [edx+8]
	fld	QWORD PTR [eax+esi*8]

; 1161 :         gdata[2].v_id = get_edge_midv(e_id);

	mov	edx, DWORD PTR tv1898[ebp]
	fstp	QWORD PTR [ebx]
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	edx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR [edi+420], edx
	jmp	$LN116@plain_edge
$LN114@plain_edge:

; 1162 :       }
; 1163 :       else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	$LN116@plain_edge

; 1164 :       { vertex_id *v = get_edge_vertices(e_id);

	mov	ecx, DWORD PTR tv1898[ebp]
	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	add	eax, DWORD PTR [edx+ecx+304]

; 1165 :         for ( k = 0 ; k < ctrlpts ; k++ )

	xor	ecx, ecx
	cmp	DWORD PTR _ctrlpts$[ebp], 4
	mov	DWORD PTR _v$90231[ebp], eax
	jl	$LN196@plain_edge

; 1164 :       { vertex_id *v = get_edge_vertices(e_id);

	mov	edx, DWORD PTR tv1936[ebp]
	mov	edi, DWORD PTR _verts$[ebp]
	mov	ecx, ebx

; 1167 :           gdata[k].v_id = v[k];

	mov	ebx, DWORD PTR _verts$[ebp]
	sub	ebx, DWORD PTR _v$90231[ebp]
	add	edi, 12					; 0000000cH
	mov	DWORD PTR tv3185[ebp], ebx
	mov	ebx, DWORD PTR _ctrlpts$[ebp]
	add	ebx, -4					; fffffffcH
	shr	ebx, 2
	inc	ebx
	mov	DWORD PTR tv1473[ebp], ebx
	add	ebx, ebx
	add	eax, 4
	add	ebx, ebx
	mov	DWORD PTR _k$[ebp], ebx
$LL180@plain_edge:

; 1166 :         { gdata[k].x[i] = verts[k][i];

	mov	ebx, DWORD PTR [edi-12]
	fld	QWORD PTR [ebx+esi*8]

; 1167 :           gdata[k].v_id = v[k];

	add	ecx, 576				; 00000240H
	fstp	QWORD PTR [ecx-864]
	mov	ebx, DWORD PTR [eax-4]
	mov	DWORD PTR [edx-144], ebx
	mov	ebx, DWORD PTR tv3185[ebp]
	mov	ebx, DWORD PTR [eax+ebx]
	fld	QWORD PTR [ebx+esi*8]
	add	eax, 16					; 00000010H
	fstp	QWORD PTR [ecx-720]
	mov	ebx, DWORD PTR [eax-16]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [edi-4]
	fld	QWORD PTR [ebx+esi*8]
	add	edi, 16					; 00000010H
	fstp	QWORD PTR [ecx-576]
	mov	ebx, DWORD PTR [eax-12]
	mov	DWORD PTR [edx+144], ebx
	mov	ebx, DWORD PTR [edi-16]
	fld	QWORD PTR [ebx+esi*8]
	add	edx, 576				; 00000240H
	dec	DWORD PTR tv1473[ebp]
	fstp	QWORD PTR [ecx-432]
	mov	ebx, DWORD PTR [eax-8]
	mov	DWORD PTR [edx-288], ebx
	jne	SHORT $LL180@plain_edge

; 1164 :       { vertex_id *v = get_edge_vertices(e_id);

	mov	eax, DWORD PTR _v$90231[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR _gdata$[ebp]
$LN196@plain_edge:

; 1165 :         for ( k = 0 ; k < ctrlpts ; k++ )

	cmp	ecx, DWORD PTR _ctrlpts$[ebp]
	jge	SHORT $LN116@plain_edge
	mov	ebx, DWORD PTR _verts$[ebp]
	sub	ebx, DWORD PTR _v$90231[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [ecx+ecx*8]
	add	eax, eax
	lea	eax, DWORD PTR [edi+eax*8+132]
	mov	DWORD PTR tv3143[ebp], eax
	lea	eax, DWORD PTR [ecx+ecx*8]
	lea	eax, DWORD PTR [esi+eax*2]
	lea	eax, DWORD PTR [edi+eax*8]
	mov	DWORD PTR tv3154[ebp], eax
	mov	eax, DWORD PTR _ctrlpts$[ebp]
	sub	eax, ecx
	mov	ecx, DWORD PTR tv3143[ebp]
	mov	DWORD PTR tv3185[ebp], ebx
	jmp	SHORT $LC111@plain_edge
$LL195@plain_edge:
	mov	ebx, DWORD PTR tv3185[ebp]
$LC111@plain_edge:

; 1166 :         { gdata[k].x[i] = verts[k][i];

	mov	ebx, DWORD PTR [ebx+edx]
	fld	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR tv3154[ebp]
	add	DWORD PTR tv3154[ebp], 144		; 00000090H
	fstp	QWORD PTR [ebx]

; 1167 :           gdata[k].v_id = v[k];

	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	add	edx, 4
	add	ecx, 144				; 00000090H
	dec	eax
	jne	SHORT $LL195@plain_edge
$LN116@plain_edge:

; 1154 :     for ( i = 0 ; i < SDIM ; i++ )

	inc	esi
	cmp	esi, DWORD PTR _web+616
	jl	$LL117@plain_edge
	mov	ebx, DWORD PTR _e_id$[ebp]
$LN198@plain_edge:

; 1168 :         }
; 1169 :       }
; 1170 :     }
; 1171 :     gdata[0].color = gdata[0].ecolor = get_edge_color_2(e_id);

	push	ebx
	call	_get_edge_color_2
	add	esp, 4
	mov	DWORD PTR [edi+120], eax
	mov	DWORD PTR [edi+104], eax

; 1172 :     gdata[0].id = e_id;

	mov	DWORD PTR [edi+128], ebx

; 1173 :     if ( inverted(e_id) ) gdata[i].etype |= LABEL_REVERSED;

	test	ebx, 134217728				; 08000000H
	je	SHORT $LN108@plain_edge
	lea	ecx, DWORD PTR [esi+esi*8]
	add	ecx, ecx
	lea	eax, DWORD PTR [edi+ecx*8+124]
	mov	edx, 16384				; 00004000H
	or	WORD PTR [eax], dx
$LN108@plain_edge:

; 1174 : 
; 1175 :     /* call device-specific routine */
; 1176 :     if ( web.modeltype == LINEAR )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	jne	$LN107@plain_edge

; 1177 :     { gdata[0].flags |= LABEL_EDGE|LABEL_HEAD|LABEL_TAIL;

	or	DWORD PTR [edi+136], 7168		; 00001c00H

; 1178 :       if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE) ) 

	cmp	DWORD PTR _web+860, 0
	mov	eax, DWORD PTR [edi+136]
	je	SHORT $LN106@plain_edge
	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN106@plain_edge

; 1179 :         torus_edge_clip(gdata,0);

	push	0
	push	edi
	call	_torus_edge_clip
	add	esp, 8
	jmp	$LN124@plain_edge
$LN106@plain_edge:

; 1180 :       else if ( spherical_arc_flag )

	cmp	DWORD PTR _spherical_arc_flag, 0
	je	SHORT $LN104@plain_edge

; 1181 :       { if ( graph_capabilities & GS_ARCS )

	test	BYTE PTR _graph_capabilities, 2
	je	SHORT $LN103@plain_edge

; 1182 :         { gdata[0].flags |= SPHERE_ARC;

	or	eax, 65536				; 00010000H
	mov	DWORD PTR [edi+136], eax
$LN104@plain_edge:

; 1183 :           (*graph_edge_transforms)(gdata,e_id);

	push	ebx
	push	edi
	call	_graph_edge_transforms
	add	esp, 8

; 1184 :         }
; 1185 :         else  /* do by hand */

	jmp	$LN124@plain_edge
$LN103@plain_edge:

; 1186 :         { REAL rr = SDIM_dot(gdata[0].x,gdata[0].x);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	edi
	push	edi
	call	_dot
	fstp	QWORD PTR _rr$90247[ebp]

; 1187 :           REAL base[MAXCOORD];
; 1188 :           REAL perp[MAXCOORD];
; 1189 :           REAL ab = SDIM_dot(gdata[0].x,gdata[1].x);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	eax, DWORD PTR [edi+144]
	push	eax
	push	edi
	call	_dot
	fst	QWORD PTR _ab$90250[ebp]

; 1190 :           REAL angle,dangle;
; 1191 :           int n;
; 1192 :           if ( ab >= rr )

	fld	QWORD PTR _rr$90247[ebp]
	add	esp, 24					; 00000018H
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	$LN209@plain_edge

; 1196 :             return;
; 1197 :           }
; 1198 :           for ( i = 0 ; i < SDIM ; i++ ) 

	mov	esi, DWORD PTR _web+616
	test	esi, esi
	jle	SHORT $LN98@plain_edge
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fdiv	ST(1), ST(0)
	fdivp	ST(1), ST(0)
	fld1
	fsubrp	ST(1), ST(0)
	call	__CIsqrt

; 1200 :             perp[i] = 1/sqrt(1-ab*ab/rr/rr)*(gdata[1].x[i] - ab/rr*gdata[0].x[i]);

	fld1
	fdivrp	ST(1), ST(0)
	lea	ecx, DWORD PTR _base$90248[ebp]
	lea	edx, DWORD PTR _perp$90249[ebp]
	sub	ecx, edi
	mov	eax, edi
	sub	edx, edi
	fld	QWORD PTR _ab$90250[ebp]
	fld	ST(0)
	fld	QWORD PTR _rr$90247[ebp]
	fdiv	ST(1), ST(0)
$LN100@plain_edge:

; 1196 :             return;
; 1197 :           }
; 1198 :           for ( i = 0 ; i < SDIM ; i++ ) 

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	esi

; 1199 :           { base[i] = gdata[0].x[i];

	fstp	QWORD PTR [ecx+eax-8]

; 1200 :             perp[i] = 1/sqrt(1-ab*ab/rr/rr)*(gdata[1].x[i] - ab/rr*gdata[0].x[i]);

	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(2)
	fsubr	QWORD PTR [eax+136]
	fmul	ST(0), ST(4)
	fstp	QWORD PTR [edx+eax-8]
	jne	SHORT $LN100@plain_edge

; 1196 :             return;
; 1197 :           }
; 1198 :           for ( i = 0 ; i < SDIM ; i++ ) 

	fstp	ST(3)
	fstp	ST(0)
	fxch	ST(1)
$LN98@plain_edge:

; 1201 :           }
; 1202 :           angle = acos(ab/rr);

	fdivp	ST(1), ST(0)
	call	__CIacos
	fst	QWORD PTR _angle$90251[ebp]

; 1203 :           dangle = M_PI/40;
; 1204 :           segs = (int)ceil(angle/dangle);

	fdiv	QWORD PTR __real@3fb41b2f769cf0e0
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_ceil
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _segs$[ebp], eax

; 1205 :           dangle = angle/segs;

	fild	DWORD PTR _segs$[ebp]

; 1206 :           for ( n = 0 ; n < segs ; n++ )

	xor	ebx, ebx
	fdivr	QWORD PTR _angle$90251[ebp]
	fstp	QWORD PTR _dangle$90252[ebp]
	test	eax, eax
	jle	$LN124@plain_edge
	npad	6
$LL190@plain_edge:

; 1207 :           { if ( n > 0 ) 

	test	ebx, ebx
	jle	SHORT $LN188@plain_edge

; 1208 :               for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN188@plain_edge
	npad	2
$LL93@plain_edge:

; 1209 :                 gdata[0].x[i] = gdata[1].x[i];

	fld	QWORD PTR [edi+eax*8+144]
	inc	eax
	fstp	QWORD PTR [edi+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL93@plain_edge
$LN188@plain_edge:

; 1210 :             for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN88@plain_edge
	lea	edx, DWORD PTR [ebx+1]
	mov	DWORD PTR tv5561[ebp], edx
	fild	DWORD PTR tv5561[ebp]
	fmul	QWORD PTR _dangle$90252[ebp]
	fst	QWORD PTR tv2098[ebp]
	call	__CIsin

; 1211 :                 gdata[1].x[i] = cos((n+1)*dangle)*base[i] + sin((n+1)*dangle)*perp[i];

	fstp	QWORD PTR tv2099[ebp]
	fld	QWORD PTR tv2098[ebp]
	call	__CIcos
	fld	QWORD PTR tv2099[ebp]
	lea	eax, DWORD PTR [edi+144]
$LN90@plain_edge:
	fld	QWORD PTR _base$90248[ebp+esi*8]
	inc	esi
	fmul	ST(0), ST(2)
	add	eax, 8
	fld	QWORD PTR _perp$90249[ebp+esi*8-8]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax-8]
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LN90@plain_edge

; 1210 :             for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(1)
	fstp	ST(0)
$LN88@plain_edge:

; 1212 :             (*graph_edge_transforms)(gdata,e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	push	eax
	push	edi
	call	_graph_edge_transforms
	inc	ebx
	add	esp, 8
	cmp	ebx, DWORD PTR _segs$[ebp]
	jl	$LL190@plain_edge

; 1215 :       }
; 1216 :       else

	jmp	$LN124@plain_edge
$LN107@plain_edge:

; 1217 :         (*graph_edge_transforms)(gdata,e_id);
; 1218 :     }
; 1219 :     else if ( (web.modeltype == QUADRATIC) && circular_arc_flag ) 

	cmp	eax, 2
	jne	$LN47@plain_edge

; 1220 :     { /* arc, so plot in segments, unless have circular arc mode */
; 1221 :       REAL headx[MAXCOORD];
; 1222 :       REAL tailx[MAXCOORD];
; 1223 :       REAL midx[MAXCOORD];
; 1224 :       REAL w1[MAXCOORD],mag1;
; 1225 :       REAL w2[MAXCOORD],mag2;
; 1226 :       REAL w[MAXCOORD],mag;
; 1227 :       REAL xx[MAXCOORD];
; 1228 :       for (i = 0 ; i < SDIM ; i++ ) 

	mov	edx, DWORD PTR _web+616
	xor	eax, eax
	cmp	DWORD PTR _circular_arc_flag, eax
	je	$LN187@plain_edge
	test	edx, edx
	jle	SHORT $LN205@plain_edge

; 1213 :           }
; 1214 :         }  

	lea	ecx, DWORD PTR [edi+144]
	npad	5
$LL84@plain_edge:

; 1229 :       { headx[i] = gdata[2].x[i]; 

	fld	QWORD PTR [ecx+144]
	inc	eax
	fst	QWORD PTR _headx$90277[ebp+eax*8-8]
	add	ecx, 8

; 1230 :         tailx[i] = gdata[0].x[i];

	fld	QWORD PTR [ecx-152]
	fst	QWORD PTR _tailx$90278[ebp+eax*8-8]

; 1231 :         midx[i] = gdata[1].x[i];

	fld	QWORD PTR [ecx-8]
	fst	QWORD PTR _midx$90279[ebp+eax*8-8]

; 1232 :         w1[i] = midx[i] - tailx[i];

	fsub	ST(0), ST(1)
	fstp	QWORD PTR _w1$90280[ebp+eax*8-8]

; 1233 :         w2[i] = headx[i] - tailx[i];

	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _w2$90282[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LL84@plain_edge
$LN205@plain_edge:

; 1234 :       }
; 1235 :       mag1 = SDIM_dot(w1,w1); mag2 = SDIM_dot(w2,w2);

	push	edx
	lea	ecx, DWORD PTR _w1$90280[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _mag1$90281[ebp]
	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _w2$90282[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fst	QWORD PTR _mag2$90283[ebp]
	add	esp, 24					; 00000018H

; 1236 :       if ( graph_capabilities & GC_ARCS )

	test	BYTE PTR _graph_capabilities, 1
	je	SHORT $LN81@plain_edge

; 1237 :       { gdata[0].flags |= EDGE_ARC;

	or	DWORD PTR [edi+136], 32768		; 00008000H
	fstp	ST(0)

; 1238 :         if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE)) 

	cmp	DWORD PTR _web+860, 0
	je	$LN104@plain_edge
	cmp	DWORD PTR _torus_display_mode, 3
	jne	$LN104@plain_edge

; 1239 :            torus_edge_clip(gdata,0);

	push	0
	push	edi
	call	_torus_edge_clip
	add	esp, 8
	jmp	$LN124@plain_edge
$LN81@plain_edge:

; 1240 :         else (*graph_edge_transforms)(gdata,e_id);
; 1241 :       }
; 1242 :       else
; 1243 :       { int segments;
; 1244 :         REAL ang;
; 1245 :         
; 1246 :         for ( i = 0 ; i < SDIM  ; i++ )

	mov	edx, DWORD PTR _web+616
	fld	QWORD PTR _mag1$90281[ebp]
	xor	eax, eax
	cmp	edx, 4
	jl	SHORT $LC182@plain_edge
	lea	ecx, DWORD PTR [edx-3]
$LN183@plain_edge:

; 1247 :         { w1[i] /= mag1; w2[i] /= mag2; }

	fld	QWORD PTR _w1$90280[ebp+eax*8]
	add	eax, 4
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _w1$90280[ebp+eax*8-32]
	fld	QWORD PTR _w2$90282[ebp+eax*8-32]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _w2$90282[ebp+eax*8-32]
	fld	QWORD PTR _w1$90280[ebp+eax*8-24]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _w1$90280[ebp+eax*8-24]
	fld	QWORD PTR _w2$90282[ebp+eax*8-24]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _w2$90282[ebp+eax*8-24]
	fld	QWORD PTR _w1$90280[ebp+eax*8-16]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _w1$90280[ebp+eax*8-16]
	fld	QWORD PTR _w2$90282[ebp+eax*8-16]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _w2$90282[ebp+eax*8-16]
	fld	QWORD PTR _w1$90280[ebp+eax*8-8]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _w1$90280[ebp+eax*8-8]
	fld	QWORD PTR _w2$90282[ebp+eax*8-8]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _w2$90282[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN183@plain_edge
$LC182@plain_edge:

; 1240 :         else (*graph_edge_transforms)(gdata,e_id);
; 1241 :       }
; 1242 :       else
; 1243 :       { int segments;
; 1244 :         REAL ang;
; 1245 :         
; 1246 :         for ( i = 0 ; i < SDIM  ; i++ )

	cmp	eax, edx
	jge	SHORT $LN230@plain_edge
$LC77@plain_edge:

; 1247 :         { w1[i] /= mag1; w2[i] /= mag2; }

	fld	QWORD PTR _w1$90280[ebp+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _w1$90280[ebp+eax*8-8]
	fld	QWORD PTR _w2$90282[ebp+eax*8-8]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _w2$90282[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC77@plain_edge
$LN230@plain_edge:

; 1240 :         else (*graph_edge_transforms)(gdata,e_id);
; 1241 :       }
; 1242 :       else
; 1243 :       { int segments;
; 1244 :         REAL ang;
; 1245 :         
; 1246 :         for ( i = 0 ; i < SDIM  ; i++ )

	fstp	ST(1)

; 1248 :         for ( i = 0 ; i < SDIM ; i++ ) gdata[0].x[i] = tailx[i];

	xor	ecx, ecx
	fstp	ST(0)
	test	edx, edx
	jle	SHORT $LN72@plain_edge
	lea	esi, DWORD PTR _tailx$90278[ebp]
	mov	eax, edi
	sub	esi, edi
$LL74@plain_edge:
	fld	QWORD PTR [esi+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	add	eax, 8
	cmp	ecx, edx
	jl	SHORT $LL74@plain_edge
$LN72@plain_edge:

; 1249 : 
; 1250 :         /* figure out how many segments to do */
; 1251 :         ang = 4*acos(SDIM_dot(w1,w2)*sqrt(mag1*mag2));

	push	edx
	lea	eax, DWORD PTR _w2$90282[ebp]
	push	eax
	lea	ecx, DWORD PTR _w1$90280[ebp]
	push	ecx
	call	_dot
	fstp	QWORD PTR tv5304[ebp]
	fld	QWORD PTR _mag2$90283[ebp]
	add	esp, 12					; 0000000cH
	fmul	QWORD PTR _mag1$90281[ebp]
	call	__CIsqrt
	fmul	QWORD PTR tv5304[ebp]
	call	__CIacos
	fmul	QWORD PTR __real@4010000000000000

; 1252 :         segments = (int)(ang/(M_PI/180*string_curve_tolerance));

	fld	QWORD PTR _string_curve_tolerance
	fmul	QWORD PTR __real@3f91df46a2529d39
	fdivp	ST(1), ST(0)
	call	__ftol2_sse
	mov	DWORD PTR _segments$90294[ebp], eax

; 1253 :         if ( segments < 2 ) 

	cmp	eax, 2
	jge	SHORT $LN71@plain_edge

; 1254 :             segments = 2;

	mov	DWORD PTR _segments$90294[ebp], 2
$LN71@plain_edge:

; 1255 : 
; 1256 :         gdata[1].v_id = NULLID;
; 1257 :         for ( k = 1 ; k <= segments ; k++ )

	mov	ebx, 1
	mov	DWORD PTR [edi+276], 0
	mov	DWORD PTR _k$[ebp], ebx
	cmp	DWORD PTR _segments$90294[ebp], ebx
	jl	$LN124@plain_edge
	mov	eax, DWORD PTR _segments$90294[ebp]
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _web+616
	sar	eax, 1
	mov	DWORD PTR tv2185[ebp], eax
$LL70@plain_edge:

; 1258 :         { if ( k == segments/2 )

	cmp	ebx, DWORD PTR tv2185[ebp]
	jne	SHORT $LN67@plain_edge

; 1259 :             gdata[0].v_id = get_edge_midv(e_id);

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR tv1898[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+304]
	mov	eax, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR [edi+132], eax
	jmp	SHORT $LN257@plain_edge
$LN67@plain_edge:

; 1260 :           else if ( k > 1 )

	cmp	ebx, 1
	jle	SHORT $LN203@plain_edge

; 1261 :             gdata[0].v_id = NULLID;

	mov	DWORD PTR [edi+132], 0
$LN257@plain_edge:
	mov	edx, DWORD PTR _web+616
$LN203@plain_edge:

; 1262 :           if ( k == segments )

	mov	esi, DWORD PTR _segments$90294[ebp]
	cmp	ebx, esi
	jne	SHORT $LN204@plain_edge

; 1263 :             gdata[1].v_id = get_edge_headv(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	call	_get_edge_headv
	mov	DWORD PTR [edi+276], eax
	mov	edx, DWORD PTR _web+616
	add	esp, 4
$LN204@plain_edge:

; 1264 : 
; 1265 :           for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	edx, 4
	jl	$LC185@plain_edge
	mov	ecx, esi
	sub	ecx, ebx

; 1266 :              w[i] = w2[i] + (segments-k)/(REAL)k*(w1[i]-w2[i]);

	mov	DWORD PTR tv5490[ebp], ecx
	fild	DWORD PTR tv5490[ebp]
	lea	ecx, DWORD PTR [edx-3]
	fidiv	DWORD PTR _k$[ebp]
$LN186@plain_edge:
	fld	QWORD PTR _w1$90280[ebp+eax*8]
	add	eax, 4
	fsub	QWORD PTR _w2$90282[ebp+eax*8-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _w2$90282[ebp+eax*8-32]
	fstp	QWORD PTR _w$90284[ebp+eax*8-32]
	fld	QWORD PTR _w1$90280[ebp+eax*8-24]
	fsub	QWORD PTR _w2$90282[ebp+eax*8-24]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _w2$90282[ebp+eax*8-24]
	fstp	QWORD PTR _w$90284[ebp+eax*8-24]
	fld	QWORD PTR _w1$90280[ebp+eax*8-16]
	fsub	QWORD PTR _w2$90282[ebp+eax*8-16]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _w2$90282[ebp+eax*8-16]
	fstp	QWORD PTR _w$90284[ebp+eax*8-16]
	fld	QWORD PTR _w1$90280[ebp+eax*8-8]
	fsub	QWORD PTR _w2$90282[ebp+eax*8-8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _w2$90282[ebp+eax*8-8]
	fstp	QWORD PTR _w$90284[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN186@plain_edge
	fstp	ST(0)
$LC185@plain_edge:

; 1264 : 
; 1265 :           for ( i = 0 ; i < SDIM ; i++ )

	cmp	eax, edx
	jge	SHORT $LN184@plain_edge
	mov	ecx, esi
	sub	ecx, ebx
	mov	DWORD PTR tv5477[ebp], ecx
	fild	DWORD PTR tv5477[ebp]
	fidiv	DWORD PTR _k$[ebp]
$LC63@plain_edge:

; 1266 :              w[i] = w2[i] + (segments-k)/(REAL)k*(w1[i]-w2[i]);

	fld	QWORD PTR _w1$90280[ebp+eax*8]
	inc	eax
	fsub	QWORD PTR _w2$90282[ebp+eax*8-8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _w2$90282[ebp+eax*8-8]
	fstp	QWORD PTR _w$90284[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC63@plain_edge

; 1264 : 
; 1265 :           for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN184@plain_edge:

; 1267 :           mag = SDIM_dot(w,w);

	push	edx
	lea	edx, DWORD PTR _w$90284[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot

; 1268 :           for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN239@plain_edge

; 1267 :           mag = SDIM_dot(w,w);

	lea	ecx, DWORD PTR [edi+144]
$LN60@plain_edge:

; 1269 :             gdata[1].x[i] = xx[i] = tailx[i] + w[i]/mag;

	fld	QWORD PTR _w$90284[ebp+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	add	ecx, 8
	fadd	QWORD PTR _tailx$90278[ebp+eax*8-8]
	fst	QWORD PTR _xx$90286[ebp+eax*8-8]
	fstp	QWORD PTR [ecx-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN60@plain_edge
$LN239@plain_edge:

; 1270 :           
; 1271 :           if ( labelflag )

	cmp	DWORD PTR _labelflag, 0
	fstp	ST(0)
	je	SHORT $LN54@plain_edge

; 1272 :           { gdata[0].flags &= ~(LABEL_EDGE|LABEL_HEAD|LABEL_TAIL);

	and	DWORD PTR [edi+136], -7169		; ffffe3ffH
	mov	eax, DWORD PTR [edi+136]

; 1273 :             if ( k == 1 ) gdata[0].flags |= LABEL_TAIL;

	cmp	ebx, 1
	jne	SHORT $LN56@plain_edge
	or	eax, 4096				; 00001000H
	mov	DWORD PTR [edi+136], eax
$LN56@plain_edge:

; 1274 :             if ( k == segments/2 ) gdata[0].flags |= LABEL_EDGE;

	cmp	ebx, DWORD PTR tv2185[ebp]
	jne	SHORT $LN55@plain_edge
	or	DWORD PTR [edi+136], 1024		; 00000400H
$LN55@plain_edge:

; 1275 :             if ( k == segments ) gdata[0].flags |= LABEL_HEAD;

	cmp	ebx, esi
	jne	SHORT $LN54@plain_edge
	or	DWORD PTR [edi+136], 2048		; 00000800H
$LN54@plain_edge:

; 1276 :           }
; 1277 :           if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE)) 

	cmp	DWORD PTR _web+860, 0
	je	SHORT $LN53@plain_edge
	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN53@plain_edge

; 1278 :              torus_edge_clip(gdata,0);

	push	0
	push	edi
	call	_torus_edge_clip
	jmp	SHORT $LN258@plain_edge
$LN53@plain_edge:

; 1279 :           else (*graph_edge_transforms)(gdata,e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	edi
	call	_graph_edge_transforms
$LN258@plain_edge:

; 1280 :           for ( i = 0 ; i < SDIM ; i++ )  /* gdata[1].x was messed up by clip */

	mov	edx, DWORD PTR _web+616
	add	esp, 8
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN69@plain_edge
	lea	esi, DWORD PTR _xx$90286[ebp]
	mov	eax, edi
	sub	esi, edi
	npad	2
$LL51@plain_edge:

; 1281 :              gdata[0].x[i] = xx[i];

	fld	QWORD PTR [esi+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	add	eax, 8
	cmp	ecx, edx
	jl	SHORT $LL51@plain_edge
$LN69@plain_edge:

; 1255 : 
; 1256 :         gdata[1].v_id = NULLID;
; 1257 :         for ( k = 1 ; k <= segments ; k++ )

	inc	ebx
	mov	DWORD PTR _k$[ebp], ebx
	cmp	ebx, DWORD PTR _segments$90294[ebp]
	jle	$LL70@plain_edge

; 1282 :         }
; 1283 :       }

	jmp	$LN124@plain_edge
$LN187@plain_edge:

; 1285 :     else if ( web.modeltype == QUADRATIC ) /* quadratic, so plot in segments */
; 1286 :       { REAL headx[MAXCOORD];
; 1287 :         REAL tailx[MAXCOORD];
; 1288 :         REAL midx[MAXCOORD];
; 1289 :         REAL w1[MAXCOORD],w2[MAXCOORD],mag1,mag2,ang;
; 1290 :         
; 1291 :         for ( i = 0 ; i < SDIM ; i++ ) 

	test	edx, edx
	jle	SHORT $LN206@plain_edge

; 1284 :     }

	lea	ecx, DWORD PTR [edi+144]
	npad	11
$LL46@plain_edge:

; 1292 :         { headx[i] = gdata[2].x[i]; tailx[i] = gdata[0].x[i];

	fld	QWORD PTR [ecx+144]
	inc	eax
	fst	QWORD PTR _headx$90333[ebp+eax*8-8]
	add	ecx, 8
	fld	QWORD PTR [ecx-152]
	fst	QWORD PTR _tailx$90334[ebp+eax*8-8]

; 1293 :           midx[i] = gdata[1].x[i];

	fld	QWORD PTR [ecx-8]
	fst	QWORD PTR _midx$90335[ebp+eax*8-8]

; 1294 :           w1[i] = midx[i] - tailx[i];

	fsub	ST(0), ST(1)
	fstp	QWORD PTR _w1$90336[ebp+eax*8-8]

; 1295 :           w2[i] = headx[i] - tailx[i];

	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _w2$90337[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LL46@plain_edge
$LN206@plain_edge:

; 1296 :         }
; 1297 :         /* figure out how many segments to do */
; 1298 :         mag1 = SDIM_dot(w1,w1); mag2 = SDIM_dot(w2,w2);

	push	edx
	lea	edx, DWORD PTR _w1$90336[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	fstp	QWORD PTR _mag1$90338[ebp]
	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _w2$90337[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	fstp	QWORD PTR _mag2$90339[ebp]

; 1299 :         ang = 4*acos(SDIM_dot(w1,w2)/sqrt(mag1*mag2));

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _w2$90337[ebp]
	push	edx
	lea	eax, DWORD PTR _w1$90336[ebp]
	push	eax
	call	_dot
	fstp	QWORD PTR tv5306[ebp]
	fld	QWORD PTR _mag2$90339[ebp]
	add	esp, 36					; 00000024H
	fmul	QWORD PTR _mag1$90338[ebp]
	call	__CIsqrt
	fdivr	QWORD PTR tv5306[ebp]
	call	__CIacos
	fmul	QWORD PTR __real@4010000000000000

; 1300 :         segs = (int)(ang/(M_PI/180*string_curve_tolerance));

	fld	QWORD PTR _string_curve_tolerance
	fmul	QWORD PTR __real@3f91df46a2529d39
	fdivp	ST(1), ST(0)
	call	__ftol2_sse
	mov	DWORD PTR _segs$[ebp], eax

; 1301 :         if ( segs < 2 ) 

	cmp	eax, 2
	jge	SHORT $LN43@plain_edge

; 1302 :             segs = 2;

	mov	eax, 2
	mov	DWORD PTR _segs$[ebp], eax
$LN43@plain_edge:

; 1303 :         for ( k = 1 ; k <= segs ; k++ )

	mov	esi, 1
	mov	DWORD PTR _k$[ebp], esi
	cmp	eax, esi
	jl	$LN124@plain_edge
	mov	ecx, DWORD PTR _web+616
	fld1
	mov	ebx, DWORD PTR _segs$[ebp]
$LN194@plain_edge:

; 1304 :         { for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN242@plain_edge
	fild	DWORD PTR _k$[ebp]
	lea	ecx, DWORD PTR [edi+144]
	fild	DWORD PTR _segs$[ebp]
	fld	ST(1)
	fadd	ST(0), ST(0)
	fdiv	ST(0), ST(1)
	fsubr	ST(0), ST(3)
	fld	ST(2)
	fdiv	ST(0), ST(2)
	fsub	ST(4), ST(0)
	fld	ST(4)
	fmul	ST(0), ST(2)
	fxch	ST(4)
	fmul	QWORD PTR __real@4010000000000000
	fdivrp	ST(3), ST(0)
	fxch	ST(2)
	fmulp	ST(4), ST(0)
	fmulp	ST(1), ST(0)
$LN39@plain_edge:

; 1305 :             gdata[1].x[i] = (1-k/(REAL)segs)*(1-k*2./segs)*tailx[i]
; 1306 :                                     + k*4./segs*(1-k/(REAL)segs)*midx[i]
; 1307 :                                     - k/(REAL)segs*(1-k*2./segs)*headx[i];

	fld	QWORD PTR _midx$90335[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(3)
	add	ecx, 8
	fld	QWORD PTR _tailx$90334[ebp+eax*8-8]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _headx$90333[ebp+eax*8-8]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ecx-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN39@plain_edge

; 1304 :         { for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(2)
	fstp	ST(1)
$LN242@plain_edge:

; 1308 :           if ( labelflag )

	cmp	DWORD PTR _labelflag, 0
	fstp	ST(0)
	je	SHORT $LN33@plain_edge

; 1309 :           { gdata[0].flags &= ~(LABEL_EDGE|LABEL_HEAD|LABEL_TAIL);

	and	DWORD PTR [edi+136], -7169		; ffffe3ffH
	mov	eax, DWORD PTR [edi+136]

; 1310 :             if ( k == 1 ) gdata[0].flags |= LABEL_TAIL;

	cmp	esi, 1
	jne	SHORT $LN35@plain_edge
	or	eax, 4096				; 00001000H
	mov	DWORD PTR [edi+136], eax
$LN35@plain_edge:

; 1311 :             if ( k == segs/2+1 ) gdata[0].flags |= LABEL_EDGE;

	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	inc	eax
	cmp	esi, eax
	jne	SHORT $LN34@plain_edge
	or	DWORD PTR [edi+136], 1024		; 00000400H
$LN34@plain_edge:

; 1312 :             if ( k == segs ) gdata[0].flags |= LABEL_HEAD;

	cmp	esi, ebx
	jne	SHORT $LN33@plain_edge
	or	DWORD PTR [edi+136], 2048		; 00000800H
$LN33@plain_edge:

; 1313 :           }
; 1314 :           if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE)) 

	cmp	DWORD PTR _web+860, 0
	je	SHORT $LN32@plain_edge
	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN32@plain_edge

; 1315 :             torus_edge_clip(gdata,0);

	push	0
	push	edi
	call	_torus_edge_clip
	jmp	SHORT $LN259@plain_edge
$LN32@plain_edge:

; 1316 :           else (*graph_edge_transforms)(gdata,e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	edi
	call	_graph_edge_transforms
$LN259@plain_edge:

; 1317 :           for ( i = 0 ; i < SDIM ; i++ )  /* gdata[1].x was messed up by clip */

	mov	ecx, DWORD PTR _web+616
	add	esp, 8
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN192@plain_edge
	fild	DWORD PTR _k$[ebp]
	fild	DWORD PTR _segs$[ebp]
	fld	ST(1)
	fadd	ST(0), ST(0)
	fdiv	ST(0), ST(1)
	fld1
	fld	ST(0)
	fsubrp	ST(2), ST(0)
	fld	ST(3)
	fdiv	ST(0), ST(3)
	fld	ST(1)
	fsub	ST(0), ST(1)
	fld	ST(0)
	fmul	ST(0), ST(4)
	fxch	ST(6)
	fmul	QWORD PTR __real@4010000000000000
	fdivrp	ST(5), ST(0)
	fmulp	ST(4), ST(0)
	fmulp	ST(2), ST(0)
$LN30@plain_edge:

; 1318 :              gdata[0].x[i] = (1-k/(REAL)segs)*(1-k*2./segs)*tailx[i]
; 1319 :                                    + k*4./segs*(1-k/(REAL)segs)*midx[i]
; 1320 :                                    - k/(REAL)segs*(1-k*2./segs)*headx[i];

	fld	QWORD PTR _midx$90335[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(3)
	fld	QWORD PTR _tailx$90334[ebp+eax*8-8]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _headx$90333[ebp+eax*8-8]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [edi+eax*8-8]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN30@plain_edge

; 1317 :           for ( i = 0 ; i < SDIM ; i++ )  /* gdata[1].x was messed up by clip */

	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(1)
	jmp	SHORT $LN41@plain_edge
$LN192@plain_edge:
	fld1
$LN41@plain_edge:

; 1303 :         for ( k = 1 ; k <= segs ; k++ )

	inc	esi
	mov	DWORD PTR _k$[ebp], esi
	cmp	esi, ebx
	jle	$LN194@plain_edge
	fstp	ST(0)

; 1321 :         }
; 1322 :      }
; 1323 :      else if ( web.modeltype == LAGRANGE )

	jmp	$LN124@plain_edge
$LN47@plain_edge:
	cmp	eax, 3
	jne	$LN124@plain_edge

; 1324 :      { /* plot subsegments */
; 1325 :        if ( smooth_graph_flag || bezier_flag )

	cmp	DWORD PTR _smooth_graph_flag, 0
	jne	$LN24@plain_edge
	cmp	DWORD PTR _bezier_flag, 0
	jne	$LN24@plain_edge

; 1356 :          }
; 1357 :        }
; 1358 :        else  /* just plot between control points */
; 1359 :        { for ( k = 0 ; k < ctrlpts-1 ; k++ )

	mov	eax, DWORD PTR _ctrlpts$[ebp]
	dec	eax
	xor	esi, esi
	test	eax, eax
	jle	$LN124@plain_edge
	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1

; 1372 :            else (*graph_edge_transforms)(gdata+k,e_id);

	mov	DWORD PTR tv2350[ebp], ebx
$LL11@plain_edge:

; 1360 :          { gdata[k].ecolor = gdata[0].ecolor;

	mov	eax, DWORD PTR [edi+120]
	lea	edx, DWORD PTR [esi+esi*8]
	shl	edx, 4
	add	edx, edi
	mov	DWORD PTR [edx+120], eax

; 1361 :            gdata[k].etype = gdata[0].etype;

	mov	cx, WORD PTR [edi+124]
	mov	WORD PTR [edx+124], cx

; 1362 :            for ( i = 0 ; i < SDIM ; i++ )  /* were messed up by clip */

	cmp	DWORD PTR _web+616, 0
	mov	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN199@plain_edge
	mov	ebx, DWORD PTR _verts$[ebp]
	mov	eax, DWORD PTR [ebx+esi*4+4]
	mov	ebx, DWORD PTR [ebx+esi*4]
	sub	ebx, eax
	mov	ecx, edx
	mov	DWORD PTR tv5494[ebp], ebx
	jmp	SHORT $LN8@plain_edge
	npad	13
$LL197@plain_edge:
	mov	ebx, DWORD PTR tv5494[ebp]
$LN8@plain_edge:

; 1363 :            { gdata[k].x[i] = verts[k][i];

	fld	QWORD PTR [ebx+eax]
	mov	ebx, DWORD PTR _i$[ebp]
	fstp	QWORD PTR [ecx]
	inc	ebx

; 1364 :              gdata[k+1].x[i] = verts[k+1][i];

	fld	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [ecx+144]
	add	ecx, 8
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, DWORD PTR _web+616
	jl	SHORT $LL197@plain_edge

; 1362 :            for ( i = 0 ; i < SDIM ; i++ )  /* were messed up by clip */

	mov	ebx, DWORD PTR tv2350[ebp]
$LN199@plain_edge:

; 1365 :            }
; 1366 :            gdata[k].flags &= ~(LABEL_EDGE|LABEL_HEAD|LABEL_TAIL);

	and	DWORD PTR [edx+136], -7169		; ffffe3ffH

; 1367 :            if ( k == 0 ) gdata[0].flags |= LABEL_TAIL;

	test	esi, esi
	jne	SHORT $LN5@plain_edge
	or	DWORD PTR [edi+136], 4096		; 00001000H
$LN5@plain_edge:

; 1368 :            if ( k == (ctrlpts-1)/2 ) gdata[k].flags |= LABEL_EDGE;

	cmp	esi, ebx
	jne	SHORT $LN4@plain_edge
	or	DWORD PTR [edx+136], 1024		; 00000400H
$LN4@plain_edge:

; 1369 :            if ( k == ctrlpts-2 ) gdata[k].flags |= LABEL_HEAD;

	mov	eax, DWORD PTR _ctrlpts$[ebp]
	add	eax, -2					; fffffffeH
	cmp	esi, eax
	jne	SHORT $LN3@plain_edge
	or	DWORD PTR [edx+136], 2048		; 00000800H
$LN3@plain_edge:

; 1370 :            if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE) ) 

	cmp	DWORD PTR _web+860, 0
	je	SHORT $LN2@plain_edge
	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN2@plain_edge

; 1371 :                 torus_edge_clip(gdata+k,0);

	push	0
	push	edx
	call	_torus_edge_clip
	jmp	SHORT $LN260@plain_edge
$LN2@plain_edge:

; 1372 :            else (*graph_edge_transforms)(gdata+k,e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	push	eax
	push	edx
	call	_graph_edge_transforms
$LN260@plain_edge:

; 1356 :          }
; 1357 :        }
; 1358 :        else  /* just plot between control points */
; 1359 :        { for ( k = 0 ; k < ctrlpts-1 ; k++ )

	mov	eax, DWORD PTR _ctrlpts$[ebp]
	inc	esi
	dec	eax

; 1372 :            else (*graph_edge_transforms)(gdata+k,e_id);

	add	esp, 8
	cmp	esi, eax
	jl	$LL11@plain_edge

; 1190 :           REAL angle,dangle;
; 1191 :           int n;
; 1192 :           if ( ab >= rr )

	jmp	$LN124@plain_edge
$LN24@plain_edge:

; 1326 :        { /* plot lots of segments */
; 1327 :          vertex_id headv = gdata[web.lagrange_order].v_id;

	mov	eax, DWORD PTR _web+632
	lea	ecx, DWORD PTR [eax+eax*8]
	add	ecx, ecx
	mov	edx, DWORD PTR [edi+ecx*8+132]

; 1328 :          for ( k = 0 ; k < segs ; k++ )

	xor	ebx, ebx
	mov	DWORD PTR _headv$90371[ebp], edx
	mov	DWORD PTR _k$[ebp], ebx
	cmp	DWORD PTR _segs$[ebp], ebx
	jle	$LN124@plain_edge
	mov	ecx, DWORD PTR _segs$[ebp]
	fild	DWORD PTR _segs$[ebp]
	mov	eax, ecx
	cdq
	sub	eax, edx
	fst	QWORD PTR tv2089[ebp]
	sar	eax, 1
	dec	ecx
	mov	DWORD PTR tv2317[ebp], eax
	mov	DWORD PTR tv2375[ebp], ecx
	jmp	SHORT $LN23@plain_edge
	npad	11
$LL193@plain_edge:
	fld	QWORD PTR tv2089[ebp]
$LN23@plain_edge:

; 1329 :          { gdata[k].ecolor = gdata[0].ecolor;

	mov	ecx, DWORD PTR [edi+120]

; 1330 :            gdata[k].etype = gdata[0].etype;
; 1331 :            /* were messed up by clip of previous segment */
; 1332 :            if ( bezier_flag )
; 1333 :            { bezier_eval_1d(web.lagrange_order,SDIM,k/(REAL)segs,verts,
; 1334 :                gdata[k].x);

	fild	DWORD PTR _k$[ebp]
	lea	esi, DWORD PTR [ebx+ebx*8]
	shl	esi, 4
	add	esi, edi
	fst	QWORD PTR tv2205[ebp]
	mov	DWORD PTR [esi+120], ecx
	fdivrp	ST(1), ST(0)
	mov	dx, WORD PTR [edi+124]
	mov	WORD PTR [esi+124], dx
	cmp	DWORD PTR _bezier_flag, 0
	push	esi
	je	SHORT $LN20@plain_edge
	mov	eax, DWORD PTR _verts$[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _web+632
	push	eax
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	push	edx
	call	_bezier_eval_1d

; 1335 :              bezier_eval_1d(web.lagrange_order,SDIM,(k+1.)/segs,verts,
; 1336 :                gdata[k+1].x);

	fld	QWORD PTR tv2205[ebp]
	fadd	QWORD PTR __real@3ff0000000000000
	mov	ecx, DWORD PTR _verts$[ebp]
	mov	edx, DWORD PTR _web+616
	add	esp, 24					; 00000018H
	fdiv	QWORD PTR tv2089[ebp]
	lea	eax, DWORD PTR [esi+144]
	push	eax
	mov	eax, DWORD PTR _web+632
	push	ecx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	push	eax
	call	_bezier_eval_1d

; 1337 :            }
; 1338 :            else

	jmp	SHORT $LN261@plain_edge
$LN20@plain_edge:

; 1339 :            { /* regular lagrange */
; 1340 :              lagrange_eval_1d(web.lagrange_order,SDIM,k/(REAL)segs,verts,
; 1341 :                gdata[k].x);

	mov	ecx, DWORD PTR _verts$[ebp]
	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _web+632
	push	ecx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	push	eax
	call	_lagrange_eval_1d

; 1342 :              lagrange_eval_1d(web.lagrange_order,SDIM,(k+1.)/segs,verts,
; 1343 :                gdata[k+1].x);

	fld	QWORD PTR tv2205[ebp]
	fadd	QWORD PTR __real@3ff0000000000000
	mov	edx, DWORD PTR _verts$[ebp]
	mov	eax, DWORD PTR _web+616
	add	esp, 24					; 00000018H
	fdiv	QWORD PTR tv2089[ebp]
	lea	ecx, DWORD PTR [esi+144]
	push	ecx
	mov	ecx, DWORD PTR _web+632
	push	edx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	push	ecx
	call	_lagrange_eval_1d
$LN261@plain_edge:

; 1344 :            }
; 1345 :            gdata[k].flags &= ~(LABEL_EDGE|LABEL_HEAD|LABEL_TAIL);

	and	DWORD PTR [esi+136], -7169		; ffffe3ffH
	add	esp, 24					; 00000018H

; 1346 :            if ( k == 0 ) gdata[0].flags |= LABEL_TAIL;

	test	ebx, ebx
	jne	SHORT $LN18@plain_edge
	or	DWORD PTR [edi+136], 4096		; 00001000H
$LN18@plain_edge:

; 1347 :            if ( k == segs/2 ) gdata[k].flags |= LABEL_EDGE;

	cmp	ebx, DWORD PTR tv2317[ebp]
	jne	SHORT $LN17@plain_edge
	or	DWORD PTR [esi+136], 1024		; 00000400H
$LN17@plain_edge:

; 1348 :            if ( k == segs-1 )

	cmp	ebx, DWORD PTR tv2375[ebp]
	jne	SHORT $LN16@plain_edge

; 1349 :            { gdata[k].flags |= LABEL_HEAD;
; 1350 :              gdata[k+1].v_id = headv;

	mov	edx, DWORD PTR _headv$90371[ebp]
	or	DWORD PTR [esi+136], 2048		; 00000800H
	mov	DWORD PTR [esi+276], edx
	jmp	SHORT $LN15@plain_edge
$LN16@plain_edge:

; 1351 :            }
; 1352 :            else gdata[k+1].v_id = NULLID;

	mov	DWORD PTR [esi+276], 0
$LN15@plain_edge:

; 1353 :            if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE) ) 

	cmp	DWORD PTR _web+860, 0
	je	SHORT $LN14@plain_edge
	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN14@plain_edge

; 1354 :                 torus_edge_clip(gdata+k,0);

	push	0
	push	esi
	call	_torus_edge_clip
	jmp	SHORT $LN262@plain_edge
$LN14@plain_edge:

; 1355 :            else (*graph_edge_transforms)(gdata+k,e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	push	eax
	push	esi
	call	_graph_edge_transforms
$LN262@plain_edge:
	inc	ebx
	add	esp, 8
	mov	DWORD PTR _k$[ebp], ebx
	cmp	ebx, DWORD PTR _segs$[ebp]
	jl	$LL193@plain_edge
$LN124@plain_edge:

; 1138 :   MFOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR tv1898[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _e_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL202@plain_edge

; 1190 :           REAL angle,dangle;
; 1191 :           int n;
; 1192 :           if ( ab >= rr )

	jmp	$LN200@plain_edge
$LN209@plain_edge:
	fstp	ST(1)
	fstp	ST(0)

; 1193 :           { sprintf(errmsg,"Edge %s endpoints are antipodal; cannot be graphed as spherical arc.\n",
; 1194 :               ELNAME(e_id));

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN132@plain_edge
	and	ebx, 134217727				; 07ffffffH
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN133@plain_edge
$LN132@plain_edge:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN133@plain_edge:
	push	eax
	push	OFFSET ??_C@_0EG@NJKMPKCL@Edge?5?$CFs?5endpoints?5are?5antipodal?$DL@
	push	OFFSET _errmsg
	call	_sprintf

; 1195 :             kb_error(3733,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	3733					; 00000e95H
	call	_kb_error

; 1379 : 
; 1380 : }  /* end plain_edges() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_plain_edges ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_bare_edges
EXTRN	_sym_wrap:DWORD
; Function compile flags: /Ogtp
;	COMDAT _bare_edges
_TEXT	SEGMENT
_verts$ = -468						; size = 12
tv557 = -456						; size = 4
tv1276 = -452						; size = 4
tv1271 = -452						; size = 4
_e_id$ = -448						; size = 4
tv1278 = -444						; size = 4
tv599 = -444						; size = 4
tv1280 = -440						; size = 4
tv572 = -440						; size = 4
_gdata$ = -436						; size = 432
__$ArrayPad$ = -4					; size = 4
_bare_edges PROC					; COMDAT

; 1392 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 468				; 000001d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1393 :   int i;
; 1394 :   edge_id e_id;
; 1395 :   REAL *verts[3]; 
; 1396 :   struct graphdata gdata[3];     
; 1397 :   facetedge_id fe;
; 1398 : 
; 1399 :   memset((char*)gdata,0,3*sizeof(struct graphdata));

	push	432					; 000001b0H
	lea	eax, DWORD PTR _gdata$[ebp]
	push	0
	push	eax
	call	_memset

; 1400 :   gdata[0].etype = BARE_EDGE;
; 1401 :   for ( i = 0 ; i < 2 ; i++ ) verts[i] = gdata[i].x;
; 1402 :   MFOR_ALL_EDGES(e_id)

	mov	esi, DWORD PTR _web+160
	add	esp, 12					; 0000000cH
	mov	ecx, 64					; 00000040H
	mov	WORD PTR _gdata$[ebp+124], cx
	mov	DWORD PTR _e_id$[ebp], esi
	test	esi, 268435456				; 10000000H
	je	$LN57@bare_edges
	push	ebx
	push	edi
	jmp	SHORT $LN19@bare_edges
$LL73@bare_edges:
	mov	esi, DWORD PTR _e_id$[ebp]
$LN19@bare_edges:
	mov	ecx, DWORD PTR _web+124
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv557[ebp], edi
	je	$LN18@bare_edges

; 1403 :      { 
; 1404 :         if ( breakflag ) break;

	cmp	DWORD PTR _breakflag, edx
	jne	$LN76@bare_edges

; 1405 : 
; 1406 :         #ifdef MPI_EVOLVER
; 1407 :         if ( !mpi_show_corona_flag && (id_task(e_id) != this_task) )
; 1408 :            continue;
; 1409 :         #endif
; 1410 : 
; 1411 :         gdata[0].id = e_id;

	mov	DWORD PTR _gdata$[ebp+128], esi

; 1412 :         fe = get_edge_fe(e_id);

	mov	eax, DWORD PTR [edi+ecx]
	test	eax, eax
	je	SHORT $LN25@bare_edges
$LN26@bare_edges:
	mov	eax, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN25@bare_edges
	xor	eax, 134217728				; 08000000H
$LN25@bare_edges:

; 1413 :         if ( valid_id(fe) && valid_id(get_fe_facet(fe)) ) continue;

	test	eax, 268435456				; 10000000H
	je	SHORT $LN13@bare_edges
	mov	ebx, DWORD PTR _web+460
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR [edx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN29@bare_edges
	xor	edx, 134217728				; 08000000H
$LN29@bare_edges:
	test	edx, 268435456				; 10000000H
	jne	$LN18@bare_edges
$LN13@bare_edges:

; 1414 :         if ( show_expr[EDGE] && show_expr[EDGE]->start )

	mov	eax, DWORD PTR _show_expr+4
	test	eax, eax
	je	SHORT $LN11@bare_edges
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN11@bare_edges

; 1415 :             if ( !eval(show_expr[EDGE],NULL,e_id,NULL) ) continue;

	push	0
	push	esi
	push	0
	push	eax
	call	_eval
	fldz
	mov	ecx, DWORD PTR _web+124
	fucompp
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN18@bare_edges
$LN11@bare_edges:

; 1416 : 
; 1417 :         /* get vertices */
; 1418 :         gdata[0].v_id = get_edge_tailv(e_id);

	mov	eax, DWORD PTR _web+216
	mov	edx, DWORD PTR [edi+ecx]
	mov	ebx, DWORD PTR _web+636
	shr	esi, 27					; 0000001bH
	and	esi, 1
	mov	DWORD PTR tv572[ebp], esi
	je	SHORT $LN34@bare_edges
	add	eax, DWORD PTR _dymem
	lea	edx, DWORD PTR [edx+ebx*4]
	mov	esi, DWORD PTR [eax+304]
	mov	edx, DWORD PTR [edx+esi]
	mov	esi, DWORD PTR tv572[ebp]
	mov	DWORD PTR tv599[ebp], eax
	jmp	SHORT $LN33@bare_edges
$LN34@bare_edges:
	add	eax, DWORD PTR _dymem
	mov	DWORD PTR tv599[ebp], eax
	mov	eax, DWORD PTR [eax+304]
	mov	edx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR tv599[ebp]
$LN33@bare_edges:
	mov	DWORD PTR _gdata$[ebp+132], edx

; 1419 :         gdata[1].v_id = get_edge_headv(e_id);

	mov	edx, DWORD PTR [edi+ecx]
	test	esi, esi
	mov	esi, DWORD PTR [eax+304]
	jne	SHORT $LN78@bare_edges
	lea	edx, DWORD PTR [edx+ebx*4]
$LN78@bare_edges:
	mov	edx, DWORD PTR [edx+esi]
	mov	DWORD PTR _gdata$[ebp+276], edx

; 1420 :         verts[0] = get_coord(get_edge_tailv(e_id));

	mov	ecx, DWORD PTR [edi+ecx]
	add	ecx, DWORD PTR [eax+304]
	cmp	DWORD PTR tv572[ebp], 0
	je	SHORT $LN42@bare_edges
	mov	eax, DWORD PTR [ecx+ebx*4]
	jmp	SHORT $LN41@bare_edges
$LN42@bare_edges:
	mov	eax, DWORD PTR [ecx]
$LN41@bare_edges:
	mov	edx, DWORD PTR _web+104
	mov	esi, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+esi+64]
	mov	ebx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	add	edx, esi

; 1421 :         verts[1] = get_coord(get_edge_headv(e_id));

	cmp	DWORD PTR tv572[ebp], 0
	mov	DWORD PTR _verts$[ebp], edx
	je	SHORT $LN46@bare_edges
	mov	eax, DWORD PTR [ecx]
	jmp	SHORT $LN45@bare_edges
$LN46@bare_edges:
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [ecx+eax*4]
$LN45@bare_edges:
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ebx+eax*4]
	add	ebx, esi

; 1422 :         for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _web+616
	xor	ecx, ecx
	mov	DWORD PTR _verts$[ebp+4], ebx
	cmp	esi, 4
	jl	SHORT $LC66@bare_edges

; 1423 :         { gdata[0].x[i] = verts[0][i];

	lea	eax, DWORD PTR [edx+16]
	neg	edx
	lea	ebx, DWORD PTR _gdata$[ebp+edx]
	lea	edx, DWORD PTR _gdata$[ebp+edx+8]
	mov	DWORD PTR tv1271[ebp], edx
	npad	15
$LL74@bare_edges:
	fld	QWORD PTR [eax-16]
	mov	edx, DWORD PTR tv1271[ebp]
	fstp	QWORD PTR _gdata$[ebp+ecx*8]
	add	ecx, 4
	fld	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR _gdata$[ebp+ecx*8-24]
	fld	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax+ebx-32]
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax+edx-32]
	lea	edx, DWORD PTR [esi-3]
	cmp	ecx, edx
	jl	SHORT $LL74@bare_edges
	mov	ebx, DWORD PTR _verts$[ebp+4]
	mov	edx, DWORD PTR _verts$[ebp]
$LC66@bare_edges:

; 1422 :         for ( i = 0 ; i < SDIM ; i++ )

	cmp	ecx, esi
	jge	SHORT $LN65@bare_edges
	lea	eax, DWORD PTR _gdata$[ebp]
	sub	edx, eax
	npad	3
$LC10@bare_edges:
	lea	eax, DWORD PTR [edx+ecx*8]

; 1423 :         { gdata[0].x[i] = verts[0][i];

	fld	QWORD PTR _gdata$[ebp+eax]
	inc	ecx
	fstp	QWORD PTR _gdata$[ebp+ecx*8-8]
	cmp	ecx, esi
	jl	SHORT $LC10@bare_edges
$LN65@bare_edges:

; 1424 :         }
; 1425 :         gdata[0].color = gdata[0].ecolor = get_edge_color_2(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	call	_get_edge_color_2
	add	esp, 4

; 1426 :         if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	mov	DWORD PTR _gdata$[ebp+120], eax
	mov	DWORD PTR _gdata$[ebp+104], eax
	je	SHORT $LN7@bare_edges

; 1427 :           (*sym_wrap)(verts[1],gdata[1].x,get_edge_wrap(e_id));

	cmp	DWORD PTR tv572[ebp], 0
	mov	edx, DWORD PTR tv599[ebp]
	mov	eax, DWORD PTR [edx+784]
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [eax+edx]
	je	SHORT $LN51@bare_edges
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN51@bare_edges:
	push	eax
	lea	eax, DWORD PTR _gdata$[ebp+144]
	push	eax
	push	ebx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH
	jmp	$LN68@bare_edges
$LN7@bare_edges:

; 1428 :         else for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	cmp	esi, 4
	jl	$LC69@bare_edges

; 1429 :           gdata[1].x[i] = verts[1][i];

	mov	ecx, ebx
	neg	ecx
	lea	edx, DWORD PTR _gdata$[ebp+ecx+136]
	lea	edi, DWORD PTR _gdata$[ebp+ecx+128]
	mov	DWORD PTR tv1276[ebp], edx
	lea	edx, DWORD PTR _gdata$[ebp+ecx+144]
	lea	ecx, DWORD PTR _gdata$[ebp+ecx+152]
	mov	DWORD PTR tv1280[ebp], ecx
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	inc	ecx
	mov	DWORD PTR tv1278[ebp], edx
	lea	eax, DWORD PTR [ebx+16]
	lea	edx, DWORD PTR [ecx*4]
	npad	6
$LL72@bare_edges:
	fld	QWORD PTR [eax-16]
	mov	ebx, DWORD PTR tv1276[ebp]
	fstp	QWORD PTR [edi+eax]
	add	eax, 32					; 00000020H
	dec	ecx
	fld	QWORD PTR [eax-40]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv1278[ebp]
	fld	QWORD PTR [eax-32]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv1280[ebp]
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [ebx+eax-32]
	jne	SHORT $LL72@bare_edges

; 1428 :         else for ( i = 0 ; i < SDIM ; i++ )

	mov	ebx, DWORD PTR _verts$[ebp+4]
	mov	edi, DWORD PTR tv557[ebp]
$LC69@bare_edges:
	cmp	edx, esi
	jge	SHORT $LN68@bare_edges
	lea	eax, DWORD PTR _gdata$[ebp+144]
	sub	ebx, eax
	npad	5
$LC5@bare_edges:
	lea	ecx, DWORD PTR [ebx+edx*8]

; 1429 :           gdata[1].x[i] = verts[1][i];

	fld	QWORD PTR _gdata$[ebp+ecx+144]
	inc	edx
	fstp	QWORD PTR _gdata$[ebp+edx*8+136]
	cmp	edx, esi
	jl	SHORT $LC5@bare_edges
$LN68@bare_edges:

; 1430 : 
; 1431 :         /* call device-specific routine */
; 1432 :         gdata[0].flags = (LABEL_EDGE|LABEL_HEAD|LABEL_TAIL);
; 1433 :         if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE) ) 

	cmp	DWORD PTR _web+860, 0
	mov	DWORD PTR _gdata$[ebp+136], 7168	; 00001c00H
	je	SHORT $LN2@bare_edges
	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN2@bare_edges

; 1434 :             torus_edge_clip(gdata,0);

	lea	edx, DWORD PTR _gdata$[ebp]
	push	0
	push	edx
	call	_torus_edge_clip
	jmp	SHORT $LN79@bare_edges
$LN2@bare_edges:

; 1435 :         else (*graph_edge_transforms)(gdata,e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gdata$[ebp]
	push	ecx
	call	_graph_edge_transforms
$LN79@bare_edges:
	mov	ecx, DWORD PTR _web+124
	add	esp, 8
$LN18@bare_edges:

; 1400 :   gdata[0].etype = BARE_EDGE;
; 1401 :   for ( i = 0 ; i < 2 ; i++ ) verts[i] = gdata[i].x;
; 1402 :   MFOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _e_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL73@bare_edges
$LN76@bare_edges:
	pop	edi
	pop	ebx
$LN57@bare_edges:

; 1436 :      }
; 1437 : } // end bare_edges()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_bare_edges ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_triple_edges
; Function compile flags: /Ogtp
;	COMDAT _triple_edges
_TEXT	SEGMENT
_verts$ = -496						; size = 12
tv1691 = -484						; size = 4
tv1687 = -480						; size = 4
tv1066 = -476						; size = 4
tv1689 = -472						; size = 4
tv636 = -468						; size = 4
tv661 = -464						; size = 4
tv1704 = -460						; size = 4
tv1697 = -460						; size = 4
tv1702 = -456						; size = 4
tv1699 = -456						; size = 4
tv1706 = -452						; size = 4
tv1695 = -452						; size = 4
_e_id$ = -448						; size = 4
tv1708 = -444						; size = 4
tv1693 = -444						; size = 4
tv621 = -440						; size = 4
_gdata$ = -436						; size = 432
__$ArrayPad$ = -4					; size = 4
_triple_edges PROC					; COMDAT

; 1449 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 496				; 000001f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	edi

; 1450 :   int i;
; 1451 :   edge_id e_id;
; 1452 :   facetedge_id fe_id;
; 1453 :   REAL *verts[3]; /* for adjusted triangle vertices */
; 1454 :   struct graphdata gdata[3];
; 1455 : 
; 1456 :   memset(gdata,0,3*sizeof(struct graphdata));

	push	432					; 000001b0H
	lea	eax, DWORD PTR _gdata$[ebp]
	push	0
	push	eax
	call	_memset

; 1457 : 
; 1458 :   gdata[0].etype = TRIPLE_EDGE;
; 1459 :   for ( i = 0 ; i < 2 ; i++ ) verts[i] = gdata[i].x;
; 1460 :   MFOR_ALL_EDGES(e_id)

	mov	edi, DWORD PTR _web+160
	add	esp, 12					; 0000000cH
	mov	ecx, 2
	mov	WORD PTR _gdata$[ebp+124], cx
	mov	DWORD PTR _e_id$[ebp], edi
	test	edi, 268435456				; 10000000H
	je	$LN53@triple_edg
	push	ebx
	push	esi
	jmp	SHORT $LN19@triple_edg
$LL70@triple_edg:
	mov	edi, DWORD PTR _e_id$[ebp]
$LN19@triple_edg:
	mov	edx, DWORD PTR _web+124
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv621[ebp], esi
	je	$LN18@triple_edg

; 1461 :      { 
; 1462 :         if ( breakflag ) break;

	cmp	DWORD PTR _breakflag, edx
	jne	$LN72@triple_edg

; 1463 : 
; 1464 :         #ifdef MPI_EVOLVER
; 1465 :         if ( !mpi_show_corona_flag && (id_task(e_id) != this_task) )
; 1466 :            continue;
; 1467 :         #endif
; 1468 : 
; 1469 :         fe_id = get_edge_fe(e_id);

	test	ecx, ecx
	jne	SHORT $LN26@triple_edg
	xor	eax, eax
	jmp	SHORT $LN25@triple_edg
$LN26@triple_edg:
	mov	eax, DWORD PTR [ecx+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN25@triple_edg
	xor	eax, 134217728				; 08000000H
$LN25@triple_edg:

; 1470 :         if ( equal_id(get_next_facet(fe_id),get_prev_facet(fe_id)) ) continue;

	mov	ecx, DWORD PTR _web+460
	mov	edx, eax
	shr	edx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	and	edx, 1
	mov	eax, DWORD PTR [ecx+eax*4]
	je	SHORT $LN30@triple_edg
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN29@triple_edg
$LN30@triple_edg:
	mov	ecx, DWORD PTR [eax+40]
$LN29@triple_edg:
	test	edx, edx
	je	SHORT $LN34@triple_edg
	mov	eax, DWORD PTR [eax+40]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN33@triple_edg
$LN34@triple_edg:
	mov	eax, DWORD PTR [eax+36]
$LN33@triple_edg:
	cmp	ecx, eax
	je	$LN18@triple_edg

; 1471 :         if ( show_expr[EDGE] && show_expr[EDGE]->start )

	mov	eax, DWORD PTR _show_expr+4
	test	eax, eax
	je	SHORT $LN11@triple_edg
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN11@triple_edg

; 1472 :             if ( !eval(show_expr[EDGE],NULL,e_id,NULL) ) continue;

	push	0
	push	edi
	push	0
	push	eax
	call	_eval
	fldz
	fucompp
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN18@triple_edg
$LN11@triple_edg:

; 1473 : 
; 1474 :         /* get vertices */
; 1475 :         verts[0] = get_coord(get_edge_tailv(e_id));

	mov	edx, DWORD PTR _dymem
	mov	eax, edi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv636[ebp], eax
	mov	eax, DWORD PTR _web+216
	je	SHORT $LN38@triple_edg
	mov	ecx, DWORD PTR [eax+edx+304]
	add	eax, edx
	mov	DWORD PTR tv661[ebp], eax
	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [esi+eax]
	add	ecx, eax
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN37@triple_edg
$LN38@triple_edg:
	mov	ecx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [esi+ecx]
	add	eax, edx
	mov	DWORD PTR tv661[ebp], eax
	mov	eax, DWORD PTR [eax+304]
	add	ecx, eax
	mov	eax, DWORD PTR [ecx]
$LN37@triple_edg:
	mov	edi, DWORD PTR _web+12
	mov	esi, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edi+eax*4]
	add	ebx, DWORD PTR [esi+edx+64]

; 1476 :         verts[1] = get_coord(get_edge_headv(e_id));

	cmp	DWORD PTR tv636[ebp], 0
	mov	DWORD PTR _verts$[ebp], ebx
	je	SHORT $LN42@triple_edg
	mov	eax, DWORD PTR [ecx]
	jmp	SHORT $LN41@triple_edg
$LN42@triple_edg:
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [ecx+eax*4]
$LN41@triple_edg:
	mov	edx, DWORD PTR [esi+edx+64]

; 1477 :         verts[2] = get_coord(get_edge_midv(e_id));

	mov	ecx, DWORD PTR [ecx+8]
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+eax*4]
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+ecx*4]
	add	esi, edx
	add	edi, edx

; 1478 :         for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	xor	ecx, ecx
	mov	DWORD PTR _verts$[ebp+4], esi
	cmp	edx, 4
	jl	$LC62@triple_edg

; 1480 :           gdata[2].x[i] = verts[2][i];

	lea	esi, DWORD PTR [ebx+24]
	sub	ebx, edi
	mov	DWORD PTR tv1066[ebp], ebx
	mov	edx, edi
	neg	edx
	lea	ebx, DWORD PTR _gdata$[ebp+edx+280]
	mov	DWORD PTR tv1687[ebp], ebx
	lea	ebx, DWORD PTR _gdata$[ebp+edx]
	mov	DWORD PTR tv1689[ebp], ebx
	lea	ebx, DWORD PTR _gdata$[ebp+edx+288]
	mov	DWORD PTR tv1691[ebp], ebx
	lea	ebx, DWORD PTR _gdata$[ebp+edx+8]
	mov	DWORD PTR tv1693[ebp], ebx
	lea	ebx, DWORD PTR _gdata$[ebp+edx+296]
	mov	DWORD PTR tv1695[ebp], ebx
	lea	ebx, DWORD PTR _gdata$[ebp+edx+16]
	lea	edx, DWORD PTR _gdata$[ebp+edx+304]
	mov	DWORD PTR tv1699[ebp], edx
	mov	edx, DWORD PTR _web+616
	lea	eax, DWORD PTR [edi+8]
	mov	DWORD PTR tv1697[ebp], ebx
	npad	13
$LL68@triple_edg:
	fld	QWORD PTR [esi-24]
	mov	ebx, DWORD PTR tv1687[ebp]
	fstp	QWORD PTR _gdata$[ebp+ecx*8]
	add	ecx, 4
	fld	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv1066[ebp]
	fld	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv1689[ebp]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv1691[ebp]
	fld	QWORD PTR [eax-32]
	add	esi, 32					; 00000020H
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv1693[ebp]
	fld	QWORD PTR [esi-40]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv1695[ebp]
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv1697[ebp]
	fld	QWORD PTR [esi-32]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv1699[ebp]
	fld	QWORD PTR [eax-16]
	fstp	QWORD PTR [ebx+eax-32]
	lea	ebx, DWORD PTR [edx-3]
	cmp	ecx, ebx
	jl	SHORT $LL68@triple_edg
	mov	ebx, DWORD PTR _verts$[ebp]
	mov	esi, DWORD PTR _verts$[ebp+4]
$LC62@triple_edg:

; 1478 :         for ( i = 0 ; i < SDIM ; i++ )

	cmp	ecx, edx
	jge	SHORT $LN61@triple_edg
	lea	eax, DWORD PTR _gdata$[ebp]
	sub	ebx, eax
	sub	edi, eax
	npad	10
$LC10@triple_edg:
	lea	eax, DWORD PTR [ebx+ecx*8]

; 1479 :         { gdata[0].x[i] = verts[0][i];

	fld	QWORD PTR _gdata$[ebp+eax]
	lea	eax, DWORD PTR [edi+ecx*8]
	fstp	QWORD PTR _gdata$[ebp+ecx*8]
	inc	ecx

; 1480 :           gdata[2].x[i] = verts[2][i];

	fld	QWORD PTR _gdata$[ebp+eax]
	fstp	QWORD PTR _gdata$[ebp+ecx*8+280]
	cmp	ecx, edx
	jl	SHORT $LC10@triple_edg
$LN61@triple_edg:

; 1481 :         }
; 1482 :         if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN7@triple_edg

; 1483 :           (*sym_wrap)(verts[1],gdata[1].x,get_edge_wrap(e_id));

	cmp	DWORD PTR tv636[ebp], 0
	mov	ecx, DWORD PTR tv661[ebp]
	mov	edx, DWORD PTR [ecx+784]
	mov	eax, DWORD PTR tv621[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+eax]
	je	SHORT $LN47@triple_edg
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN47@triple_edg:
	push	eax
	lea	ecx, DWORD PTR _gdata$[ebp+144]
	push	ecx
	push	esi
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 1484 :         else

	jmp	$LN64@triple_edg
$LN7@triple_edg:

; 1485 :           for ( i = 0 ; i < SDIM ; i++ )

	xor	edi, edi
	cmp	edx, 4
	jl	$LN71@triple_edg

; 1486 :              gdata[1].x[i] = verts[1][i];

	mov	ecx, esi
	neg	ecx
	lea	edi, DWORD PTR _gdata$[ebp+ecx+128]
	mov	DWORD PTR tv1702[ebp], edi
	lea	edi, DWORD PTR _gdata$[ebp+ecx+136]
	mov	DWORD PTR tv1704[ebp], edi
	lea	edi, DWORD PTR _gdata$[ebp+ecx+144]
	lea	ecx, DWORD PTR _gdata$[ebp+ecx+152]
	mov	DWORD PTR tv1708[ebp], ecx
	lea	ecx, DWORD PTR [edx-4]
	shr	ecx, 2
	inc	ecx
	mov	DWORD PTR tv1706[ebp], edi
	lea	eax, DWORD PTR [esi+16]
	lea	edi, DWORD PTR [ecx*4]
	npad	4
$LL69@triple_edg:
	fld	QWORD PTR [eax-16]
	mov	ebx, DWORD PTR tv1702[ebp]
	fstp	QWORD PTR [ebx+eax]
	mov	ebx, DWORD PTR tv1704[ebp]
	fld	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	dec	ecx
	fstp	QWORD PTR [ebx+eax-32]
	fld	QWORD PTR [eax-32]
	mov	ebx, DWORD PTR tv1706[ebp]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv1708[ebp]
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [ebx+eax-32]
	jne	SHORT $LL69@triple_edg
$LN71@triple_edg:

; 1485 :           for ( i = 0 ; i < SDIM ; i++ )

	cmp	edi, edx
	jge	SHORT $LN64@triple_edg
	lea	eax, DWORD PTR _gdata$[ebp+144]
	sub	esi, eax
$LC5@triple_edg:
	lea	ecx, DWORD PTR [esi+edi*8]

; 1486 :              gdata[1].x[i] = verts[1][i];

	fld	QWORD PTR _gdata$[ebp+ecx+144]
	inc	edi
	fstp	QWORD PTR _gdata$[ebp+edi*8+136]
	cmp	edi, edx
	jl	SHORT $LC5@triple_edg
$LN64@triple_edg:

; 1487 :         gdata[0].id = e_id;

	mov	esi, DWORD PTR _e_id$[ebp]

; 1488 :         gdata[0].color = gdata[0].ecolor = get_edge_color_2(e_id);

	push	esi
	mov	DWORD PTR _gdata$[ebp+128], esi
	call	_get_edge_color_2

; 1489 : 
; 1490 :         /* call device-specific routine */
; 1491 :         gdata[0].flags |= LABEL_EDGE|LABEL_HEAD|LABEL_TAIL;

	or	DWORD PTR _gdata$[ebp+136], 7168	; 00001c00H
	add	esp, 4

; 1492 :         if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE) ) 

	cmp	DWORD PTR _web+860, 0
	mov	DWORD PTR _gdata$[ebp+120], eax
	mov	DWORD PTR _gdata$[ebp+104], eax
	je	SHORT $LN2@triple_edg
	cmp	DWORD PTR _torus_display_mode, 3
	jne	SHORT $LN2@triple_edg

; 1493 :             torus_edge_clip(gdata,0);

	lea	edx, DWORD PTR _gdata$[ebp]
	push	0
	push	edx
	call	_torus_edge_clip
	jmp	SHORT $LN74@triple_edg
$LN2@triple_edg:

; 1494 :         else (*graph_edge_transforms)(gdata,e_id);

	lea	eax, DWORD PTR _gdata$[ebp]
	push	esi
	push	eax
	call	_graph_edge_transforms
$LN74@triple_edg:
	mov	esi, DWORD PTR tv621[ebp]
	add	esp, 8
$LN18@triple_edg:

; 1457 : 
; 1458 :   gdata[0].etype = TRIPLE_EDGE;
; 1459 :   for ( i = 0 ; i < 2 ; i++ ) verts[i] = gdata[i].x;
; 1460 :   MFOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _e_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL70@triple_edg
$LN72@triple_edg:
	pop	esi
	pop	ebx
$LN53@triple_edg:

; 1495 :      }
; 1496 : } // end triple_edges()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_triple_edges ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@DIJIMCCO@torus_bodies?3?5to_do_count?5exceed@ ; `string'
PUBLIC	??_C@_0EO@IGOPCPKA@INTERNAL?5ERROR?0?5torus_bodies?$CI?$CJ?3?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_torus_bodies
EXTRN	_calc_vertex_smooth_normal:PROC
EXTRN	_thickenflag:DWORD
EXTRN	_normflag:DWORD
EXTRN	_vnormal:PROC
EXTRN	_inner_clip_rad:QWORD
EXTRN	_inner_clip_flag:DWORD
EXTRN	_colorflag:DWORD
EXTRN	_get_facet_verts:PROC
EXTRN	_temp_free:PROC
EXTRN	_sym_compose:DWORD
EXTRN	_kb_temp_calloc:PROC
;	COMDAT ??_C@_0CM@DIJIMCCO@torus_bodies?3?5to_do_count?5exceed@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CM@DIJIMCCO@torus_bodies?3?5to_do_count?5exceed@ DB 'torus_bodies:'
	DB	' to_do_count exceeds facemax.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@IGOPCPKA@INTERNAL?5ERROR?0?5torus_bodies?$CI?$CJ?3?5@
CONST	SEGMENT
??_C@_0EO@IGOPCPKA@INTERNAL?5ERROR?0?5torus_bodies?$CI?$CJ?3?5@ DB 'INTER'
	DB	'NAL ERROR, torus_bodies(): face %s missing neighbor face %s o'
	DB	'n body %s.', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\graphgen.c
CONST	ENDS
;	COMDAT _torus_bodies
_TEXT	SEGMENT
_xxx$ = -756						; size = 4
_ctrlpts$ = -752					; size = 4
_to_do_list$ = -748					; size = 4
_xxwrap$ = -744						; size = 4
_counter$90969 = -744					; size = 4
_facemax$ = -740					; size = 4
_allfaces$ = -736					; size = 4
tv3559 = -732						; size = 4
_to_do_spot$ = -732					; size = 4
tv3678 = -728						; size = 4
_kk$ = -728						; size = 4
_vcount$91040 = -728					; size = 4
tv4372 = -724						; size = 4
tv4142 = -724						; size = 4
_v$91126 = -724						; size = 4
_fan$ = -724						; size = 4
_fen$ = -724						; size = 4
_ii$91268 = -720					; size = 4
_wrap$91113 = -720					; size = 4
_face$90964 = -720					; size = 4
_fe$ = -716						; size = 4
_xwrap$ = -712						; size = 4
_to_do_count$ = -712					; size = 4
_nbrspot$90968 = -708					; size = 4
_f_id$ = -708						; size = 4
tv3571 = -704						; size = 4
_jj$91269 = -704					; size = 4
_bf$ = -704						; size = 4
_gdata$ = -700						; size = 4
tv7138 = -696						; size = 4
tv4212 = -696						; size = 4
tv3684 = -696						; size = 4
tv3558 = -696						; size = 4
tv3971 = -692						; size = 8
_eattr$91229 = -692					; size = 8
tv5829 = -688						; size = 4
tv4088 = -688						; size = 4
tv3068 = -688						; size = 4
tv2179 = -688						; size = 4
$T93569 = -688						; size = 4
$T93563 = -688						; size = 4
_flags$91270 = -688					; size = 4
tv1287 = -688						; size = 4
tv986 = -688						; size = 4
_lwrap$91131 = -688					; size = 4
_cm$91041 = -688					; size = 4
_k$ = -688						; size = 4
_i$ = -688						; size = 4
tv7142 = -684						; size = 4
tv6186 = -684						; size = 4
tv5497 = -684						; size = 4
tv4209 = -684						; size = 4
tv3934 = -684						; size = 4
tv948 = -684						; size = 4
_wrapcount$91008 = -684					; size = 4
_sweep_spot$ = -684					; size = 4
tv3681 = -680						; size = 4
_fe_id$91115 = -680					; size = 4
_j$ = -680						; size = 4
_new_cm$91048 = -680					; size = 4
_b_ord$ = -680						; size = 4
_front$90933 = -680					; size = 4
_u$91042 = -676						; size = 48
_x$91047 = -628						; size = 48
_qdata$91271 = -580					; size = 576
_qdata$91250 = -580					; size = 576
__$ArrayPad$ = -4					; size = 4
_torus_bodies PROC					; COMDAT

; 2241 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 756				; 000002f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi

; 2242 :   struct bodyface *allfaces;
; 2243 :   int facemax;
; 2244 :   facetedge_id fe,fen,ff,fa,fan;
; 2245 :   int i,j,k,kk;
; 2246 :   struct bodyface *bf;
; 2247 :   struct graphdata *gdata;
; 2248 :   facet_id f_id;
; 2249 :   WRAPTYPE *xwrap; /* for centering body */
; 2250 :   int ctrlpts = web.skel[FACET].ctrlpts;

	mov	esi, DWORD PTR _web+232
	push	edi

; 2251 :   REAL **xxx; /* for LAGRANGE unwrapped vertices */
; 2252 :   struct ww **xxwrap;
; 2253 :   int b_ord;
; 2254 :   body_id bb_id;
; 2255 :   int *to_do_list;
; 2256 :   int to_do_count = 0;
; 2257 :   int to_do_spot = -1;
; 2258 :   int sweep_spot = 0;
; 2259 : 
; 2260 :   gdata = (struct graphdata *)temp_calloc(ctrlpts+1,sizeof(struct graphdata));

	push	2260					; 000008d4H
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	lea	eax, DWORD PTR [esi+1]
	xor	edi, edi
	push	144					; 00000090H
	push	eax
	mov	DWORD PTR _ctrlpts$[ebp], esi
	mov	DWORD PTR _to_do_count$[ebp], edi
	mov	DWORD PTR _to_do_spot$[ebp], -1
	mov	DWORD PTR _sweep_spot$[ebp], edi
	call	_kb_temp_calloc

; 2261 :   xxx = temp_dmatrix(0,ctrlpts,0,SDIM);

	mov	ecx, DWORD PTR _web+616
	push	2261					; 000008d5H
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	push	ecx
	push	edi
	push	esi
	push	edi
	mov	DWORD PTR _gdata$[ebp], eax
	call	_kb_temp_dmatrix

; 2262 : 
; 2263 :   facemax = 2*(web.skel[FACET].max_ord+1);

	mov	esi, DWORD PTR _web+292

; 2264 :   allfaces = (struct bodyface *) temp_calloc(facemax,sizeof(struct bodyface));

	push	2264					; 000008d8H
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	lea	esi, DWORD PTR [esi+esi+2]
	push	16					; 00000010H
	push	esi
	mov	DWORD PTR _xxx$[ebp], eax
	mov	DWORD PTR _facemax$[ebp], esi
	call	_kb_temp_calloc

; 2265 :   to_do_list = (int *)temp_calloc(facemax,sizeof(int));

	push	2265					; 000008d9H
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	push	4
	push	esi
	mov	DWORD PTR _allfaces$[ebp], eax
	call	_kb_temp_calloc

; 2266 : 
; 2267 :   /* first, get a list of all facets bounding the body,
; 2268 :      with proper orientation. Some may be included twice
; 2269 :      with opposite orientations in case the body wraps
; 2270 :      around the torus.
; 2271 :    */
; 2272 : 
; 2273 :   MFOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+272
	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	add	esp, 72					; 00000048H
	and	edx, 1
	mov	DWORD PTR _to_do_list$[ebp], eax
	je	$LN491@torus_bodi
	npad	2
$LL192@torus_bodi:
	mov	eax, DWORD PTR _web+236
	mov	ebx, ecx
	and	ebx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	mov	DWORD PTR tv3558[ebp], ebx
	je	$LN191@torus_bodi

; 2274 :   { body_id front,back;
; 2275 : 
; 2276 :     #ifdef MPI_EVOLVER
; 2277 :     if ( !mpi_show_corona_flag && (id_task(f_id) != this_task) )
; 2278 :        continue;
; 2279 :     #endif
; 2280 : 
; 2281 :     front = get_facet_body(f_id);

	xor	eax, eax
	cmp	DWORD PTR _web+400, eax
	je	SHORT $LN557@torus_bodi
	cmp	edx, eax
	je	SHORT $LN557@torus_bodi
	mov	eax, DWORD PTR _dymem
	mov	edi, DWORD PTR _web+328
	mov	eax, DWORD PTR [edi+eax+784]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN232@torus_bodi
	mov	eax, DWORD PTR [eax+esi+4]
	jmp	SHORT $LN557@torus_bodi
$LN232@torus_bodi:
	mov	eax, DWORD PTR [esi+eax]
$LN557@torus_bodi:

; 2282 :     back = get_facet_body(facet_inverse(f_id));

	mov	edi, ecx
	xor	edi, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	mov	DWORD PTR _front$90933[ebp], eax
	jne	SHORT $LN240@torus_bodi
	xor	esi, esi
	jmp	SHORT $LN237@torus_bodi
$LN240@torus_bodi:
	test	edi, 268435456				; 10000000H
	jne	SHORT $LN239@torus_bodi
	xor	esi, esi
	jmp	SHORT $LN237@torus_bodi
$LN239@torus_bodi:
	mov	esi, DWORD PTR _web+236
	mov	ebx, DWORD PTR _web+328
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _dymem
	mov	esi, DWORD PTR [ebx+esi+784]
	mov	ebx, DWORD PTR tv3558[ebp]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN238@torus_bodi
	mov	esi, DWORD PTR [eax+esi+4]
	jmp	SHORT $LN237@torus_bodi
$LN238@torus_bodi:
	mov	esi, DWORD PTR [eax+esi]
$LN237@torus_bodi:

; 2283 : 
; 2284 :     if ( valid_id(front) ) 

	test	DWORD PTR _front$90933[ebp], 268435456	; 10000000H
	je	SHORT $LN187@torus_bodi

; 2285 :     { size_t spot = 2*ordinal(f_id);

	test	edx, edx
	je	SHORT $LN195@torus_bodi
	mov	eax, ebx
	jmp	SHORT $LN196@torus_bodi
$LN195@torus_bodi:
	or	eax, -1
$LN196@torus_bodi:

; 2286 :       allfaces[spot].b_id = front;

	mov	ebx, DWORD PTR _front$90933[ebp]
	add	eax, eax
	shl	eax, 4
	add	eax, DWORD PTR _allfaces$[ebp]
	mov	DWORD PTR [eax+4], ebx

; 2287 :       allfaces[spot].f_id = f_id;   

	mov	ebx, DWORD PTR tv3558[ebp]
	mov	DWORD PTR [eax], ecx
$LN187@torus_bodi:

; 2288 :     }
; 2289 :     if ( valid_id(back) )

	test	esi, 268435456				; 10000000H
	je	SHORT $LN191@torus_bodi

; 2290 :     { size_t spot = 2*ordinal(f_id) + 1;

	test	edx, edx
	je	SHORT $LN197@torus_bodi
	mov	eax, ebx
	jmp	SHORT $LN198@torus_bodi
$LN197@torus_bodi:
	or	eax, -1
$LN198@torus_bodi:

; 2291 :       allfaces[spot].b_id = back;

	mov	ecx, DWORD PTR _allfaces$[ebp]
	lea	eax, DWORD PTR [eax+eax+1]
	add	eax, eax
	mov	DWORD PTR [ecx+eax*8+4], esi

; 2292 :       allfaces[spot].f_id = facet_inverse(f_id);

	mov	DWORD PTR [ecx+eax*8], edi
$LN191@torus_bodi:

; 2266 : 
; 2267 :   /* first, get a list of all facets bounding the body,
; 2268 :      with proper orientation. Some may be included twice
; 2269 :      with opposite orientations in case the body wraps
; 2270 :      around the torus.
; 2271 :    */
; 2272 : 
; 2273 :   MFOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	$LL192@torus_bodi
$LN491@torus_bodi:

; 2293 :     }
; 2294 :   }
; 2295 : 
; 2296 : 
; 2297 :   /* Now go through list repeatedly, marking proper wraps
; 2298 :      for facet base vertices as can.
; 2299 :    */
; 2300 :   while ( sweep_spot < facemax )

	cmp	DWORD PTR _facemax$[ebp], 0
	jle	$LN532@torus_bodi
	mov	edi, DWORD PTR _sweep_spot$[ebp]
	mov	ebx, DWORD PTR _to_do_spot$[ebp]

; 2301 :   { 
; 2302 :     // find starter for to_do_list
; 2303 :     for ( ; sweep_spot < facemax ; sweep_spot++ )

	cmp	edi, DWORD PTR _facemax$[ebp]
	jge	$LN492@torus_bodi
$LN563@torus_bodi:
	mov	edx, DWORD PTR _allfaces$[ebp]
	mov	ecx, edi
	add	ecx, ecx
	lea	esi, DWORD PTR [edx+ecx*8+4]
	npad	3
$LL183@torus_bodi:

; 2304 :     { 
; 2305 :       struct bodyface *face;
; 2306 : 
; 2307 :       face = allfaces + sweep_spot;
; 2308 : 
; 2309 :       if ( face->wrapflag )

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN182@torus_bodi

; 2310 :          continue;
; 2311 : 
; 2312 :       if ( !valid_id(face->f_id) ) 

	test	DWORD PTR [esi-4], 268435456		; 10000000H
	je	SHORT $LN182@torus_bodi

; 2313 :          continue;
; 2314 : 
; 2315 :       if ( breakflag ) break;

	cmp	DWORD PTR _breakflag, 0
	jne	SHORT $LN492@torus_bodi

; 2316 : 
; 2317 :       if ( valid_id(face->b_id) && show_expr[BODY] && show_expr[BODY]->start )

	mov	ecx, DWORD PTR [esi]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN176@torus_bodi
	mov	eax, DWORD PTR _show_expr+12
	test	eax, eax
	je	SHORT $LN176@torus_bodi
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN176@torus_bodi

; 2318 :         if ( !eval(show_expr[BODY],NULL,face->b_id,NULL) ) continue;

	push	0
	push	ecx
	push	0
	push	eax
	call	_eval
	fldz
	fucompp
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN176@torus_bodi
$LN182@torus_bodi:

; 2301 :   { 
; 2302 :     // find starter for to_do_list
; 2303 :     for ( ; sweep_spot < facemax ; sweep_spot++ )

	inc	edi
	add	esi, 16					; 00000010H
	mov	DWORD PTR _sweep_spot$[ebp], edi
	cmp	edi, DWORD PTR _facemax$[ebp]
	jl	SHORT $LL183@torus_bodi

; 2521 :     { WRAPTYPE wrap;
; 2522 :       ATTR fattr;
; 2523 :       facetedge_id fe_id;
; 2524 :       edge_id e_id;
; 2525 : 
; 2526 :       if ( breakflag ) break;

	jmp	SHORT $LN492@torus_bodi
$LN176@torus_bodi:

; 2319 : 
; 2320 :       face->wrapflag = IS_WRAPPED;
; 2321 :    
; 2322 :       to_do_spot = to_do_count;

	mov	eax, DWORD PTR _to_do_count$[ebp]

; 2323 :       to_do_list[to_do_count++] = sweep_spot;

	mov	ecx, DWORD PTR _to_do_list$[ebp]
	mov	DWORD PTR [esi+8], 1
	mov	ebx, eax
	mov	DWORD PTR [ecx+eax*4], edi
	inc	eax
	mov	DWORD PTR _to_do_spot$[ebp], ebx
	mov	DWORD PTR _to_do_count$[ebp], eax
$LN492@torus_bodi:

; 2324 : 
; 2325 :       break;
; 2326 :     }
; 2327 :      
; 2328 :     // now continue on with to-do list, marking neighbors and adding
; 2329 :     // them to the to-do list, until run out of to-do list.
; 2330 : 
; 2331 :     for ( ; to_do_spot < to_do_count ; to_do_spot++ )

	cmp	ebx, DWORD PTR _to_do_count$[ebp]
	jge	$LN173@torus_bodi
	npad	2
$LL530@torus_bodi:

; 2332 :     {   struct bodyface *face;
; 2333 : 
; 2334 :         face = allfaces + to_do_list[to_do_spot];

	mov	edx, DWORD PTR _to_do_list$[ebp]
	mov	eax, DWORD PTR [edx+ebx*4]

; 2335 :       
; 2336 :         fe = get_facet_fe( face->f_id );

	mov	ebx, DWORD PTR _web+236
	shl	eax, 4
	add	eax, DWORD PTR _allfaces$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _face$90964[ebp], eax
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN244@torus_bodi
	xor	eax, eax
	mov	DWORD PTR _fe$[ebp], eax

; 2337 :         for ( i = 0 ; i < FACET_VERTS ; i++ )  /* check for wrapped neighbor */

	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN172@torus_bodi

; 2335 :       
; 2336 :         fe = get_facet_fe( face->f_id );

$LN244@torus_bodi:
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN243@torus_bodi
	xor	eax, 134217728				; 08000000H
$LN243@torus_bodi:
	mov	DWORD PTR _fe$[ebp], eax

; 2337 :         for ( i = 0 ; i < FACET_VERTS ; i++ )  /* check for wrapped neighbor */

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN172@torus_bodi
	npad	12
$LL531@torus_bodi:
	mov	ebx, DWORD PTR _web+236
$LN172@torus_bodi:

; 2338 :         { int nbrspot;
; 2339 :           int counter;
; 2340 :           
; 2341 :           if ( equal_id(fe,get_prev_facet(fe)) )

	mov	edi, DWORD PTR _web+460
	mov	esi, eax
	shr	esi, 27					; 0000001bH
	and	esi, 1
	mov	DWORD PTR tv3678[ebp], esi
	mov	ecx, eax
	je	SHORT $LN248@torus_bodi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [ecx+edi]
	mov	DWORD PTR tv3681[ebp], ecx
	mov	ecx, DWORD PTR [edx+40]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN558@torus_bodi
$LN248@torus_bodi:
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [ecx+edi]
	mov	DWORD PTR tv3681[ebp], ecx
	mov	ecx, DWORD PTR [edx+36]
$LN558@torus_bodi:
	mov	DWORD PTR tv3684[ebp], edx
	cmp	eax, ecx
	jne	SHORT $LN169@torus_bodi

; 2342 :           { /* valence 1 edge */
; 2343 :             fe = get_next_edge(fe);

	test	esi, esi
	je	SHORT $LN252@torus_bodi
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	$LN559@torus_bodi
$LN252@torus_bodi:
	mov	eax, DWORD PTR [edx+32]

; 2344 :             continue;

	jmp	$LN559@torus_bodi
$LN169@torus_bodi:

; 2345 :           }
; 2346 :           fen = fe_inverse(get_prev_facet(fe));

	test	esi, esi
	je	SHORT $LN256@torus_bodi
	mov	ecx, DWORD PTR [edx+40]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN255@torus_bodi
$LN256@torus_bodi:
	mov	ecx, DWORD PTR [edx+36]
$LN255@torus_bodi:
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR _fen$[ebp], ecx

; 2347 :           ff = get_fe_facet(fen);

	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN260@torus_bodi
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN259@torus_bodi
$LN260@torus_bodi:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	esi, DWORD PTR [edx+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN259@torus_bodi
	xor	esi, 134217728				; 08000000H
$LN259@torus_bodi:

; 2348 :           if ( !equal_id(get_facet_body(ff),face->b_id) )

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN266@torus_bodi
	xor	edi, edi
	jmp	SHORT $LN263@torus_bodi
$LN266@torus_bodi:
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN265@torus_bodi
	xor	edi, edi
	jmp	SHORT $LN263@torus_bodi
$LN265@torus_bodi:
	mov	edi, DWORD PTR _web+328
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _dymem
	mov	edi, DWORD PTR [edi+ebx+784]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN264@torus_bodi
	mov	edi, DWORD PTR [edx+edi+4]
	jmp	SHORT $LN263@torus_bodi
$LN264@torus_bodi:
	mov	edi, DWORD PTR [edx+edi]
$LN263@torus_bodi:
	mov	edx, DWORD PTR _face$90964[ebp]
	mov	edx, DWORD PTR [edx+4]
	cmp	edi, edx
	jne	$LN171@torus_bodi

; 2349 :             continue;
; 2350 :           if ( inverted(ff) )
; 2351 :               nbrspot = 2*ordinal(ff) + 1;

	mov	ebx, esi
	shr	ebx, 28					; 0000001cH
	test	esi, 134217728				; 08000000H
	je	SHORT $LN167@torus_bodi
	and	ebx, 1
	je	SHORT $LN199@torus_bodi
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	lea	edi, DWORD PTR [edi+edi+1]

; 2352 :           else

	jmp	SHORT $LN560@torus_bodi
$LN199@torus_bodi:

; 2349 :             continue;
; 2350 :           if ( inverted(ff) )
; 2351 :               nbrspot = 2*ordinal(ff) + 1;

	or	edi, -1
	lea	edi, DWORD PTR [edi+edi+1]

; 2352 :           else

	jmp	SHORT $LN560@torus_bodi
$LN167@torus_bodi:

; 2353 :               nbrspot = 2*ordinal(ff);

	and	ebx, 1
	je	SHORT $LN201@torus_bodi
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	jmp	SHORT $LN202@torus_bodi
$LN201@torus_bodi:
	or	edi, -1
$LN202@torus_bodi:
	add	edi, edi
$LN560@torus_bodi:
	mov	DWORD PTR _nbrspot$90968[ebp], edi

; 2354 :           bf = allfaces + nbrspot;

	shl	edi, 4
	add	edi, DWORD PTR _allfaces$[ebp]

; 2355 : 
; 2356 :           if ( !valid_id(bf->f_id)  )

	test	DWORD PTR [edi], 268435456		; 10000000H
	mov	DWORD PTR _bf$[ebp], edi
	jne	$LN165@torus_bodi

; 2357 :           { sprintf(errmsg,
; 2358 :                 "INTERNAL ERROR, torus_bodies(): face %s missing neighbor face %s on body %s.\n",
; 2359 :                  ELNAME(face->f_id),ELNAME1(ff), ELNAME2(face->b_id));

	test	edx, 268435456				; 10000000H
	je	SHORT $LN203@torus_bodi
	and	edx, 134217727				; 07ffffffH
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	edi, OFFSET _elnames+60
	jmp	SHORT $LN204@torus_bodi
$LN203@torus_bodi:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN204@torus_bodi:
	test	ebx, ebx
	je	SHORT $LN205@torus_bodi
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN206@torus_bodi
$LN205@torus_bodi:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN206@torus_bodi:
	mov	ebx, DWORD PTR _face$90964[ebp]
	mov	eax, DWORD PTR [ebx]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN207@torus_bodi
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN208@torus_bodi
$LN207@torus_bodi:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN208@torus_bodi:
	push	edi
	push	esi
	push	eax
	push	OFFSET ??_C@_0EO@IGOPCPKA@INTERNAL?5ERROR?0?5torus_bodies?$CI?$CJ?3?5@
	push	OFFSET _errmsg
	call	_sprintf

; 2360 :             kb_error(1050,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1050					; 0000041aH
	call	_kb_error

; 2361 : 
; 2362 :             face->wrapflag = BAD_BAD_BAD;
; 2363 : 
; 2364 :             fe = get_next_edge(fe);

	mov	eax, DWORD PTR tv3681[ebp]
	mov	DWORD PTR [ebx+12], 2
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [eax+ecx]
	add	esp, 32					; 00000020H
	cmp	DWORD PTR tv3678[ebp], 0
	je	$LN252@torus_bodi
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN559@torus_bodi
$LN165@torus_bodi:

; 2365 :             continue;
; 2366 :           }
; 2367 :           if ( bf-> wrapflag == IS_WRAPPED) 

	cmp	DWORD PTR [edi+12], 1
	jne	$LN164@torus_bodi

; 2368 :           { fe = get_next_edge(fe);

	cmp	DWORD PTR tv3678[ebp], 0
	je	SHORT $LN274@torus_bodi
	mov	eax, DWORD PTR tv3684[ebp]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN559@torus_bodi
$LN274@torus_bodi:
	mov	ecx, DWORD PTR tv3684[ebp]
$LN561@torus_bodi:

; 2406 : 
; 2407 :           fe = get_next_edge(fe);

	mov	eax, DWORD PTR [ecx+32]
$LN559@torus_bodi:
	mov	DWORD PTR _fe$[ebp], eax
$LN171@torus_bodi:

; 2337 :         for ( i = 0 ; i < FACET_VERTS ; i++ )  /* check for wrapped neighbor */

	mov	ecx, DWORD PTR _i$[ebp]
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, 3
	jl	$LL531@torus_bodi

; 2324 : 
; 2325 :       break;
; 2326 :     }
; 2327 :      
; 2328 :     // now continue on with to-do list, marking neighbors and adding
; 2329 :     // them to the to-do list, until run out of to-do list.
; 2330 : 
; 2331 :     for ( ; to_do_spot < to_do_count ; to_do_spot++ )

	mov	ebx, DWORD PTR _to_do_spot$[ebp]
	inc	ebx
	mov	DWORD PTR _to_do_spot$[ebp], ebx
	cmp	ebx, DWORD PTR _to_do_count$[ebp]
	jl	$LL530@torus_bodi
	mov	edi, DWORD PTR _sweep_spot$[ebp]
$LN173@torus_bodi:

; 2293 :     }
; 2294 :   }
; 2295 : 
; 2296 : 
; 2297 :   /* Now go through list repeatedly, marking proper wraps
; 2298 :      for facet base vertices as can.
; 2299 :    */
; 2300 :   while ( sweep_spot < facemax )

	cmp	edi, DWORD PTR _facemax$[ebp]
	jl	$LN563@torus_bodi
$LN532@torus_bodi:

; 2408 :        } 
; 2409 :      }
; 2410 :    } // end while sweeps
; 2411 : 
; 2412 : #define MAXW 50
; 2413 :    xxwrap = (struct ww **)temp_calloc(web.skel[BODY].max_ord+3,sizeof(struct ww*));

	mov	edx, DWORD PTR _web+404
	push	2413					; 0000096dH
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	add	edx, 3
	push	4
	push	edx
	call	_kb_temp_calloc
	mov	edi, eax

; 2414 :    xxwrap[0] = (struct ww *)temp_calloc(web.skel[BODY].max_ord+3,MAXW*sizeof(struct ww));

	mov	eax, DWORD PTR _web+404
	push	2414					; 0000096eH
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	add	eax, 3
	push	400					; 00000190H
	push	eax
	mov	DWORD PTR _xxwrap$[ebp], edi
	call	_kb_temp_calloc
	mov	DWORD PTR [edi], eax

; 2415 :    for ( k = 1 ; k <= web.skel[BODY].max_ord ; k++ )

	mov	ecx, DWORD PTR _web+404
	mov	eax, 1
	add	esp, 32					; 00000020H
	cmp	ecx, eax
	jl	SHORT $LN154@torus_bodi
	npad	4
$LL156@torus_bodi:

; 2416 :        xxwrap[k] = xxwrap[k-1] + MAXW;

	mov	ecx, DWORD PTR [edi+eax*4-4]
	add	ecx, 400				; 00000190H
	mov	DWORD PTR [edi+eax*4], ecx
	mov	ecx, DWORD PTR _web+404
	inc	eax
	cmp	eax, ecx
	jle	SHORT $LL156@torus_bodi
$LN154@torus_bodi:

; 2417 :    xwrap = (WRAPTYPE *)temp_calloc(web.skel[BODY].max_ord+3,sizeof(int*));

	push	2417					; 00000971H
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	add	ecx, 3
	push	4
	push	ecx
	call	_kb_temp_calloc
	mov	DWORD PTR _xwrap$[ebp], eax

; 2418 : 
; 2419 :     /* Adjusting body wrap */
; 2420 : //    if ( !web.torus_flag || !(get_battr(b_id) & WANT_CENTEROFMASS) )  
; 2421 :     { /* try to center body in cell by finding most common wrap and 
; 2422 :          using inverse to center body */
; 2423 : 
; 2424 :       int wrapcount = 1;  /* number of different wraps */
; 2425 :       for ( k = 0 ; k < facemax ; k++ )

	mov	eax, DWORD PTR _facemax$[ebp]
	add	esp, 16					; 00000010H
	mov	esi, 1
	mov	DWORD PTR _wrapcount$91008[ebp], esi
	test	eax, eax
	jle	$LN151@torus_bodi

; 2417 :    xwrap = (WRAPTYPE *)temp_calloc(web.skel[BODY].max_ord+3,sizeof(int*));

	mov	ecx, DWORD PTR _allfaces$[ebp]
	add	ecx, 8
	mov	DWORD PTR tv5497[ebp], ecx
	mov	DWORD PTR tv3068[ebp], eax
	npad	12
$LL534@torus_bodi:

; 2426 :       { if ( !valid_id(allfaces[k].f_id) )

	test	DWORD PTR [ecx-8], 268435456		; 10000000H
	je	$LN152@torus_bodi

; 2427 :           continue;
; 2428 :         b_ord = ordinal(allfaces[k].b_id);

	mov	eax, DWORD PTR [ecx-4]
	test	eax, 268435456				; 10000000H
	je	$LN209@torus_bodi
	and	eax, 134217727				; 07ffffffH
	mov	edx, eax
	jmp	$LN210@torus_bodi
$LN164@torus_bodi:

; 2369 :             continue;
; 2370 :           }
; 2371 :                 
; 2372 :           /* now have unwrapped neighbor */ 
; 2373 :   
; 2374 :           /* start at base point of face and follow edges
; 2375 :              accumulating wraps until neighbor base point is reached */
; 2376 :   
; 2377 :           bf->wrap = face->wrap; 

	mov	edx, DWORD PTR _face$90964[ebp]
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [edi+8], esi

; 2378 : 
; 2379 :           fa = get_facet_fe(face->f_id);

	mov	edx, DWORD PTR [edx]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LN278@torus_bodi
	xor	edi, edi
	jmp	SHORT $LN277@torus_bodi
$LN278@torus_bodi:
	mov	edi, DWORD PTR _web+236
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [esi+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN277@torus_bodi
	xor	edi, 134217728				; 08000000H
$LN277@torus_bodi:

; 2380 :           counter = 0;
; 2381 :           while ( !equal_id(fa,fe) )

	cmp	edi, eax
	mov	eax, DWORD PTR _web+460
	mov	DWORD PTR _counter$90969[ebp], 0
	je	$LN494@torus_bodi
	npad	6
$LL163@torus_bodi:

; 2382 :           { /* walk around face */
; 2383 :             bf->wrap = (*sym_compose)(bf->wrap,get_fe_wrap(fa));

	mov	ebx, DWORD PTR _dymem
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+eax]
	mov	eax, edi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ebx+784]
	mov	ecx, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN285@torus_bodi
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN286@torus_bodi
$LN285@torus_bodi:
	mov	eax, ecx
$LN286@torus_bodi:
	mov	ebx, DWORD PTR _bf$[ebp]
	push	eax
	mov	eax, DWORD PTR [ebx+8]
	push	eax
	call	DWORD PTR _sym_compose
	add	esp, 8
	mov	DWORD PTR [ebx+8], eax

; 2384 :             fa = get_next_edge(fa);

	mov	eax, DWORD PTR _web+460
	test	edi, 134217728				; 08000000H
	je	SHORT $LN288@torus_bodi
	mov	ecx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [ecx+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN287@torus_bodi
$LN288@torus_bodi:
	mov	edx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [edx+32]
$LN287@torus_bodi:

; 2385 :             if ( ++counter >= FACET_VERTS ) break;  /* just in case */ 

	mov	ecx, DWORD PTR _counter$90969[ebp]
	inc	ecx
	mov	DWORD PTR _counter$90969[ebp], ecx
	cmp	ecx, 3
	jge	SHORT $LN495@torus_bodi

; 2380 :           counter = 0;
; 2381 :           while ( !equal_id(fa,fe) )

	cmp	edi, DWORD PTR _fe$[ebp]
	jne	$LL163@torus_bodi
$LN495@torus_bodi:
	mov	ecx, DWORD PTR _fen$[ebp]
$LN434@torus_bodi:

; 2386 :           }
; 2387 :  
; 2388 :           // now have bf->wrap at head of fen
; 2389 :           fan = get_facet_fe(bf->f_id);

	mov	edx, DWORD PTR [ebx]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LN292@torus_bodi
	xor	edx, edx
	mov	DWORD PTR _fan$[ebp], edx
	jmp	SHORT $LN293@torus_bodi
$LN494@torus_bodi:

; 2380 :           counter = 0;
; 2381 :           while ( !equal_id(fa,fe) )

	mov	ebx, DWORD PTR _bf$[ebp]
	jmp	SHORT $LN434@torus_bodi

; 2386 :           }
; 2387 :  
; 2388 :           // now have bf->wrap at head of fen
; 2389 :           fan = get_facet_fe(bf->f_id);

$LN292@torus_bodi:
	mov	edi, DWORD PTR _web+236
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	mov	esi, DWORD PTR [esi+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN291@torus_bodi
	xor	esi, 134217728				; 08000000H
$LN291@torus_bodi:
	mov	edx, esi
	mov	DWORD PTR _fan$[ebp], esi
$LN293@torus_bodi:

; 2390 :           fen = get_next_edge(fen);  /* so tail of fan winds up at head of fen */

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN296@torus_bodi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	esi, DWORD PTR [ecx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN295@torus_bodi
$LN296@torus_bodi:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	esi, DWORD PTR [ecx+32]
$LN295@torus_bodi:

; 2391 :           counter = 0;

	xor	edi, edi

; 2392 :           while ( !equal_id(fan,fen) )

	cmp	edx, esi
	je	$LN435@torus_bodi
	jmp	SHORT $LN160@torus_bodi
	npad	5
$LL496@torus_bodi:
	mov	eax, DWORD PTR _web+460
$LN160@torus_bodi:

; 2393 :           { /* walk backwards around neighbor */
; 2394 :             fen = get_prev_edge(fen);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN300@torus_bodi
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [edx+32]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN299@torus_bodi
$LN300@torus_bodi:
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+28]
$LN299@torus_bodi:

; 2395 :             bf->wrap = (*sym_compose)(bf->wrap,(*sym_inverse)(get_fe_wrap(fen))); 

	mov	ebx, DWORD PTR _dymem
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+ebx+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN307@torus_bodi
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN308@torus_bodi
$LN307@torus_bodi:
	mov	eax, ecx
$LN308@torus_bodi:
	push	eax
	call	DWORD PTR _sym_inverse
	mov	ebx, DWORD PTR _bf$[ebp]
	mov	edx, DWORD PTR [ebx+8]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose

; 2396 :             if ( ++counter >= 3 ) break; /* just in case */

	inc	edi
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx+8], eax
	cmp	edi, 3
	jge	SHORT $LN435@torus_bodi

; 2392 :           while ( !equal_id(fan,fen) )

	cmp	DWORD PTR _fan$[ebp], esi
	jne	$LL496@torus_bodi
$LN435@torus_bodi:

; 2397 :           }
; 2398 : 
; 2399 :           if ( to_do_count >= facemax )

	mov	eax, DWORD PTR _to_do_count$[ebp]
	cmp	eax, DWORD PTR _facemax$[ebp]
	jge	SHORT $LN436@torus_bodi

; 2401 :             return;
; 2402 :           }
; 2403 : 
; 2404 :           bf->wrapflag = IS_WRAPPED;

	mov	ecx, DWORD PTR _bf$[ebp]

; 2405 :           to_do_list[to_do_count++] = nbrspot;

	mov	edx, DWORD PTR _to_do_list$[ebp]
	mov	DWORD PTR [ecx+12], 1
	mov	ecx, DWORD PTR _nbrspot$90968[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 2406 : 
; 2407 :           fe = get_next_edge(fe);

	mov	edx, DWORD PTR tv3681[ebp]
	inc	eax
	cmp	DWORD PTR tv3678[ebp], 0
	mov	DWORD PTR _to_do_count$[ebp], eax
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edx+eax]
	je	$LN561@torus_bodi
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	$LN559@torus_bodi
$LN436@torus_bodi:

; 2400 :           { kb_error(5997,"torus_bodies: to_do_count exceeds facemax.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CM@DIJIMCCO@torus_bodies?3?5to_do_count?5exceed@
	push	5997					; 0000176dH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2791 : 
; 2792 : } /* end torus_bodies() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN209@torus_bodi:

; 2427 :           continue;
; 2428 :         b_ord = ordinal(allfaces[k].b_id);

	or	edx, -1
$LN210@torus_bodi:

; 2429 :         for ( i = 0 ; i < wrapcount ; i++ )

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN147@torus_bodi
	mov	ebx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edi+edx*4]
	npad	6
$LL149@torus_bodi:

; 2430 :           if ( xxwrap[b_ord][i].wrap == allfaces[k].wrap )

	cmp	DWORD PTR [ecx], ebx
	je	SHORT $LN437@torus_bodi

; 2429 :         for ( i = 0 ; i < wrapcount ; i++ )

	inc	eax
	add	ecx, 8
	cmp	eax, esi
	jl	SHORT $LL149@torus_bodi

; 2521 :     { WRAPTYPE wrap;
; 2522 :       ATTR fattr;
; 2523 :       facetedge_id fe_id;
; 2524 :       edge_id e_id;
; 2525 : 
; 2526 :       if ( breakflag ) break;

	jmp	SHORT $LN564@torus_bodi
$LN437@torus_bodi:

; 2431 :           { xxwrap[b_ord][i].count++;

	mov	ecx, DWORD PTR [edi+edx*4]
	inc	DWORD PTR [ecx+eax*8+4]
	lea	ecx, DWORD PTR [ecx+eax*8+4]
$LN564@torus_bodi:
	mov	ecx, DWORD PTR tv5497[ebp]
$LN147@torus_bodi:

; 2432 :             break;
; 2433 :           }
; 2434 :         if ( (i == wrapcount) && (i < MAXW-1) )

	cmp	eax, esi
	jne	SHORT $LN152@torus_bodi
	cmp	eax, 49					; 00000031H
	jge	SHORT $LN152@torus_bodi

; 2435 :         { xxwrap[b_ord][wrapcount].wrap = allfaces[k].wrap;

	mov	eax, DWORD PTR [edi+edx*4]
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+esi*8], ebx

; 2436 :           xxwrap[b_ord][wrapcount++].count = 1;

	mov	edx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [edx+esi*8+4], 1
	inc	esi
$LN152@torus_bodi:

; 2418 : 
; 2419 :     /* Adjusting body wrap */
; 2420 : //    if ( !web.torus_flag || !(get_battr(b_id) & WANT_CENTEROFMASS) )  
; 2421 :     { /* try to center body in cell by finding most common wrap and 
; 2422 :          using inverse to center body */
; 2423 : 
; 2424 :       int wrapcount = 1;  /* number of different wraps */
; 2425 :       for ( k = 0 ; k < facemax ; k++ )

	add	ecx, 16					; 00000010H
	dec	DWORD PTR tv3068[ebp]
	mov	DWORD PTR tv5497[ebp], ecx
	jne	$LL534@torus_bodi

; 2436 :           xxwrap[b_ord][wrapcount++].count = 1;

	mov	DWORD PTR _wrapcount$91008[ebp], esi
$LN151@torus_bodi:

; 2437 :         }
; 2438 :       }
; 2439 : 
; 2440 :       FOR_ALL_BODIES(bb_id)

	mov	eax, DWORD PTR _web+384
	mov	edx, eax
	shr	edx, 28					; 0000001cH
	and	edx, 1
	je	$LN528@torus_bodi
	mov	ebx, DWORD PTR _web+348
$LL144@torus_bodi:
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+edi*4]
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+12]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN143@torus_bodi

; 2441 :       { 
; 2442 :         b_ord = ordinal(bb_id);

	test	edx, edx
	je	SHORT $LN211@torus_bodi
	mov	esi, edi
	mov	DWORD PTR _b_ord$[ebp], edi
	jmp	SHORT $LN212@torus_bodi
$LN211@torus_bodi:
	or	esi, -1
	mov	DWORD PTR _b_ord$[ebp], esi
$LN212@torus_bodi:

; 2443 :         if (get_battr(bb_id) & WANT_CENTEROFMASS)

	and	ecx, 2
	xor	eax, eax
	or	eax, ecx
	jne	$LN143@torus_bodi

; 2444 :           continue;
; 2445 :         for ( k = 0, i = 0 ; i < wrapcount ; i++ )

	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR _wrapcount$91008[ebp], eax
	jle	SHORT $LN136@torus_bodi
	mov	ecx, DWORD PTR _xxwrap$[ebp]
	mov	esi, DWORD PTR [ecx+esi*4]
	xor	edx, edx
	npad	5
$LL138@torus_bodi:
	lea	ecx, DWORD PTR [eax*8]

; 2446 :           if ( xxwrap[b_ord][i].count > xxwrap[b_ord][k].count ) 

	mov	ebx, DWORD PTR [ecx+esi+4]
	cmp	ebx, DWORD PTR [esi+edx+4]
	jle	SHORT $LN137@torus_bodi

; 2447 :             k = i;

	mov	DWORD PTR _k$[ebp], eax
	mov	edx, ecx
$LN137@torus_bodi:

; 2444 :           continue;
; 2445 :         for ( k = 0, i = 0 ; i < wrapcount ; i++ )

	inc	eax
	cmp	eax, DWORD PTR _wrapcount$91008[ebp]
	jl	SHORT $LL138@torus_bodi
	mov	esi, DWORD PTR _b_ord$[ebp]
$LN136@torus_bodi:

; 2448 :         xwrap[b_ord] = (*sym_inverse)(xxwrap[b_ord][k].wrap);

	mov	edx, DWORD PTR _xxwrap$[ebp]
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	push	edx
	call	DWORD PTR _sym_inverse
	mov	ecx, DWORD PTR _xwrap$[ebp]
	mov	DWORD PTR [ecx+esi*4], eax
	mov	ebx, DWORD PTR _web+348
	add	esp, 4
$LN143@torus_bodi:

; 2437 :         }
; 2438 :       }
; 2439 : 
; 2440 :       FOR_ALL_BODIES(bb_id)

	mov	edx, DWORD PTR [ebx+edi*4]
	mov	eax, DWORD PTR [edx]
	mov	edx, eax
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	$LL144@torus_bodi
$LN528@torus_bodi:

; 2449 :       }
; 2450 :     }  // end find most common wrap
; 2451 : 
; 2452 :     // 
; 2453 :     if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	je	$LN529@torus_bodi

; 2454 :     { int *vcount;
; 2455 :       REAL *cm;
; 2456 :       REAL u[MAXCOORD];
; 2457 :       facet_id f_id;
; 2458 :       facetedge_id fe;
; 2459 :       vertex_id v_id;
; 2460 :       REAL adjust;
; 2461 :       REAL x[MAXCOORD];
; 2462 :       REAL **new_cm;
; 2463 : 
; 2464 :       new_cm = temp_dmatrix(0,web.skel[BODY].max_ord+3,0,MAXCOORD);

	mov	eax, DWORD PTR _web+404
	push	2464					; 000009a0H
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	push	6
	push	0
	add	eax, 3
	push	eax
	push	0
	call	_kb_temp_dmatrix

; 2465 :       vcount = (int*)temp_calloc(web.skel[BODY].max_ord+3,sizeof(int));

	mov	ecx, DWORD PTR _web+404
	push	2465					; 000009a1H
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	add	ecx, 3
	push	4
	push	ecx
	mov	DWORD PTR _new_cm$91048[ebp], eax
	call	_kb_temp_calloc

; 2466 : 
; 2467 :       /* get vertex-wise center of mass */
; 2468 :       FOR_ALL_BODIES(bb_id)

	fld	QWORD PTR __real@3fe0000000000000
	mov	edx, DWORD PTR _web+384
	add	esp, 40					; 00000028H
	mov	ebx, eax
	mov	DWORD PTR _vcount$91040[ebp], ebx
	test	edx, 268435456				; 10000000H
	je	$LN536@torus_bodi
$LN525@torus_bodi:
	mov	eax, DWORD PTR _web+348
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+eax]
	mov	esi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv3971[ebp+4], eax
	mov	eax, esi
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN132@torus_bodi

; 2469 :       {
; 2470 :         cm = get_body_cm(bb_id);  /* in unit cell coordinates */

	mov	eax, DWORD PTR _web+348
	mov	ebx, DWORD PTR [ecx+eax]

; 2471 :         if ( !(get_battr(bb_id) & WANT_CENTEROFMASS) ||
; 2472 :              !(get_battr(bb_id) & HAVE_CENTEROFMASS) )

	mov	edi, DWORD PTR [ebx+12]
	and	edi, 2
	xor	eax, eax
	or	eax, edi
	je	SHORT $LN127@torus_bodi
	and	esi, 32768				; 00008000H
	xor	eax, eax
	or	esi, eax
	jne	SHORT $LN132@torus_bodi
$LN127@torus_bodi:

; 2473 :         { // get body close to center
; 2474 :           for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN124@torus_bodi
$LN126@torus_bodi:

; 2475 :             cm[i] = 0.5;

	fst	QWORD PTR [ebx+eax*8+352]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN126@torus_bodi
$LN124@torus_bodi:

; 2476 :           set_attr(bb_id,HAVE_CENTEROFMASS);

	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	eax, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 32768		; 00008000H
	mov	DWORD PTR [eax+12], edx
$LN132@torus_bodi:

; 2466 : 
; 2467 :       /* get vertex-wise center of mass */
; 2468 :       FOR_ALL_BODIES(bb_id)

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx]
	test	edx, 268435456				; 10000000H
	jne	$LN525@torus_bodi
	mov	ebx, DWORD PTR _vcount$91040[ebp]
$LN536@torus_bodi:

; 2477 :         }
; 2478 :       }
; 2479 : 
; 2480 :       for ( kk = 0 ; kk < facemax ; kk++ )

	mov	eax, DWORD PTR _facemax$[ebp]
	fstp	ST(0)
	test	eax, eax
	jle	$LN535@torus_bodi
	mov	edi, DWORD PTR _allfaces$[ebp]
	add	edi, 4
	mov	DWORD PTR tv1287[ebp], eax
$LL123@torus_bodi:

; 2481 :       { f_id = allfaces[kk].f_id;

	mov	ecx, DWORD PTR [edi-4]

; 2482 :         if ( !valid_id(f_id) ) continue;

	test	ecx, 268435456				; 10000000H
	je	$LN122@torus_bodi

; 2483 :         fe = get_facet_fe(f_id);

	mov	eax, DWORD PTR _web+236
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edx+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN315@torus_bodi
	xor	eax, 134217728				; 08000000H
$LN315@torus_bodi:

; 2484 :         v_id = get_fe_tailv(fe);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+124
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+216
	test	eax, 134217728				; 08000000H
	je	SHORT $LN322@torus_bodi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+304]
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN321@torus_bodi
$LN322@torus_bodi:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	eax, DWORD PTR [eax+ecx]
$LN321@torus_bodi:

; 2485 :         b_ord = ordinal(allfaces[kk].b_id);

	mov	ecx, DWORD PTR [edi]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN213@torus_bodi
	and	ecx, 134217727				; 07ffffffH
	mov	esi, ecx
	jmp	SHORT $LN214@torus_bodi
$LN213@torus_bodi:
	or	esi, -1
$LN214@torus_bodi:

; 2486 :         (*sym_wrap)(get_coord(v_id),x,allfaces[kk].wrap);

	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	lea	ecx, DWORD PTR _x$91047[ebp]
	push	ecx
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+104
	add	eax, DWORD PTR [ecx+edx+64]
	push	eax
	call	DWORD PTR _sym_wrap

; 2487 :         for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN117@torus_bodi
	mov	edx, DWORD PTR _new_cm$91048[ebp]
	mov	eax, DWORD PTR [edx+esi*4]
	lea	edx, DWORD PTR _x$91047[ebp]
	sub	edx, eax
$LL119@torus_bodi:

; 2488 :           new_cm[b_ord][i] += x[i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL119@torus_bodi
$LN117@torus_bodi:

; 2489 :         vcount[b_ord]++;

	inc	DWORD PTR [ebx+esi*4]
$LN122@torus_bodi:

; 2477 :         }
; 2478 :       }
; 2479 : 
; 2480 :       for ( kk = 0 ; kk < facemax ; kk++ )

	add	edi, 16					; 00000010H
	dec	DWORD PTR tv1287[ebp]
	jne	$LL123@torus_bodi
$LN535@torus_bodi:

; 2490 :       }
; 2491 :      
; 2492 :       FOR_ALL_BODIES(bb_id)

	mov	eax, DWORD PTR _web+384
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	je	$LN114@torus_bodi
	mov	edi, DWORD PTR _web+616
$LL526@torus_bodi:
	mov	edx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv3934[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN115@torus_bodi

; 2493 :       { b_ord = ordinal(bb_id);

	test	ecx, ecx
	je	SHORT $LN215@torus_bodi
	mov	esi, DWORD PTR tv3934[ebp]
	jmp	SHORT $LN216@torus_bodi
$LN215@torus_bodi:
	or	esi, -1
$LN216@torus_bodi:

; 2494 :         for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _new_cm$91048[ebp]
	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN109@torus_bodi
	mov	ebx, DWORD PTR _vcount$91040[ebp]
	npad	9
$LL111@torus_bodi:

; 2495 :            if ( vcount[b_ord] > 0 )

	mov	eax, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR tv4088[ebp], eax
	test	eax, eax
	jle	SHORT $LN110@torus_bodi

; 2496 :              new_cm[b_ord][i] /= vcount[b_ord];

	mov	eax, DWORD PTR [edx+esi*4]
	fild	DWORD PTR tv4088[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]
	fdivr	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	edi, DWORD PTR _web+616
$LN110@torus_bodi:

; 2494 :         for ( i = 0 ; i < SDIM ; i++ )

	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LL111@torus_bodi
$LN109@torus_bodi:

; 2497 :         cm = get_body_cm(bb_id);  /* in unit cell coordinates */

	mov	ecx, DWORD PTR _web+348
	mov	eax, DWORD PTR tv3934[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2498 : 
; 2499 :         /* wrap to best agreement with old (which should be middle first time) */
; 2500 :         if ( get_battr(bb_id) & WANT_CENTEROFMASS )

	mov	ecx, DWORD PTR [eax+12]
	lea	ebx, DWORD PTR [eax+352]
	and	ecx, 2
	xor	eax, eax
	or	eax, ecx
	mov	DWORD PTR _cm$91041[ebp], ebx
	je	$LN107@torus_bodi

; 2501 :         { matvec_mul(web.inverse_periods,new_cm[b_ord],u,SDIM,SDIM);

	mov	edx, DWORD PTR _new_cm$91048[ebp]
	mov	eax, DWORD PTR [edx+esi*4]
	push	edi
	push	edi
	lea	ecx, DWORD PTR _u$91042[ebp]
	push	ecx
	mov	ecx, DWORD PTR _web+1612
	push	eax
	push	ecx
	call	_matvec_mul

; 2502 :           xwrap[b_ord] = 0;

	mov	edx, DWORD PTR _xwrap$[ebp]
	mov	DWORD PTR [edx+esi*4], 0

; 2503 :           for ( i = SDIM-1 ; i >= 0 ; i-- )

	mov	edi, DWORD PTR _web+616
	lea	ebx, DWORD PTR [edi-1]
	add	esp, 20					; 00000014H
	test	ebx, ebx
	js	$LN115@torus_bodi
	mov	ecx, DWORD PTR _cm$91041[ebp]
	lea	eax, DWORD PTR _u$91042[ebp]
	sub	eax, ecx
	lea	edi, DWORD PTR [ecx+ebx*8]
	mov	DWORD PTR tv5829[ebp], eax
	npad	6
$LL106@torus_bodi:

; 2504 :           { xwrap[b_ord] <<= TWRAPBITS;

	mov	eax, DWORD PTR _xwrap$[ebp]
	shl	DWORD PTR [eax+esi*4], 6

; 2505 :             adjust = floor(cm[i]-u[i]+0.5);

	fld	QWORD PTR [edi]
	mov	eax, DWORD PTR tv5829[ebp]
	fsub	QWORD PTR [eax+edi]
	sub	esp, 8
	fadd	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8

; 2506 :             xwrap[b_ord] |= (int)(adjust) & WRAPMASK;

	fld	ST(0)
	call	__ftol2_sse
	mov	ecx, DWORD PTR _xwrap$[ebp]
	and	eax, 31					; 0000001fH
	or	eax, DWORD PTR [ecx+esi*4]
	mov	edx, ecx
	mov	DWORD PTR [edx+esi*4], eax

; 2507 :             cm[i] = u[i] + adjust; /* for next time around */

	mov	eax, DWORD PTR tv5829[ebp]
	fadd	QWORD PTR [eax+edi]
	sub	edi, 8
	dec	ebx
	fstp	QWORD PTR [edi+8]
	jns	SHORT $LL106@torus_bodi

; 2508 :           }
; 2509 :         }
; 2510 :         else /* save most common wrap (for backwards compatibility) */

	jmp	SHORT $LN565@torus_bodi
$LN107@torus_bodi:

; 2511 :         { (*sym_wrap)(new_cm[b_ord],x,xwrap[b_ord]);

	mov	ecx, DWORD PTR _xwrap$[ebp]
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	edx, DWORD PTR [edx+esi*4]
	push	eax
	lea	ecx, DWORD PTR _x$91047[ebp]
	push	ecx
	push	edx
	call	DWORD PTR _sym_wrap

; 2512 :           matvec_mul(web.inverse_periods,x,cm,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _web+1612
	push	eax
	push	eax
	push	ebx
	lea	eax, DWORD PTR _x$91047[ebp]
	push	eax
	push	ecx
	call	_matvec_mul
	add	esp, 32					; 00000020H
$LN565@torus_bodi:
	mov	edi, DWORD PTR _web+616
$LN115@torus_bodi:

; 2490 :       }
; 2491 :      
; 2492 :       FOR_ALL_BODIES(bb_id)

	mov	eax, DWORD PTR _web+348
	mov	edx, DWORD PTR tv3934[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL526@torus_bodi
$LN114@torus_bodi:

; 2513 :         }
; 2514 :       } 
; 2515 :       free_temp_matrix(new_cm);

	mov	edx, DWORD PTR _new_cm$91048[ebp]
	push	edx
	call	_free_temp_matrix

; 2516 :       temp_free((char *)vcount);

	mov	eax, DWORD PTR _vcount$91040[ebp]
	push	eax
	call	_temp_free
	add	esp, 8
$LN529@torus_bodi:

; 2517 :     }  // end torus
; 2518 :      
; 2519 :     /* now plot all the facets */
; 2520 :     for ( kk = 0 ; kk < facemax ; kk++ )

	cmp	DWORD PTR _facemax$[ebp], 0
	mov	DWORD PTR _kk$[ebp], 0
	jle	$LN439@torus_bodi
	npad	12
$LL508@torus_bodi:

; 2521 :     { WRAPTYPE wrap;
; 2522 :       ATTR fattr;
; 2523 :       facetedge_id fe_id;
; 2524 :       edge_id e_id;
; 2525 : 
; 2526 :       if ( breakflag ) break;

	cmp	DWORD PTR _breakflag, 0
	jne	$LN439@torus_bodi

; 2527 : 
; 2528 :       f_id = allfaces[kk].f_id;

	mov	edi, DWORD PTR _kk$[ebp]
	shl	edi, 4
	add	edi, DWORD PTR _allfaces$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _f_id$[ebp], eax

; 2529 :       if ( !valid_id(f_id) ) continue;

	test	eax, 268435456				; 10000000H
	je	$LN101@torus_bodi

; 2530 :       b_ord = ordinal(allfaces[kk].b_id);

	mov	eax, DWORD PTR [edi+4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN217@torus_bodi
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR _b_ord$[ebp], eax
	jmp	SHORT $LN218@torus_bodi
$LN217@torus_bodi:
	mov	DWORD PTR _b_ord$[ebp], -1
$LN218@torus_bodi:

; 2531 :       fattr = get_fattr(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv3559[ebp], eax

; 2532 :       if ( fattr & NODISPLAY ) continue;

	mov	eax, DWORD PTR [ecx+8]
	and	eax, 2
	xor	edx, edx
	or	eax, edx
	jne	$LN101@torus_bodi

; 2533 :       fe = get_facet_fe(f_id);

	mov	esi, DWORD PTR _f_id$[ebp]
	mov	ebx, DWORD PTR [ecx+28]
	mov	eax, esi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv3571[ebp], eax
	je	SHORT $LN509@torus_bodi
	xor	ebx, 134217728				; 08000000H
$LN509@torus_bodi:

; 2534 :       wrap = (*sym_compose)(allfaces[kk].wrap,xwrap[b_ord]);

	mov	edx, DWORD PTR _xwrap$[ebp]
	mov	eax, DWORD PTR _b_ord$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [edi+8]
	push	ecx
	push	edx
	mov	DWORD PTR _fe$[ebp], ebx
	call	DWORD PTR _sym_compose
	mov	edi, eax

; 2535 :       if ( web.modeltype == LAGRANGE )

	mov	eax, 3
	add	esp, 8
	mov	DWORD PTR _wrap$91113[ebp], edi
	cmp	DWORD PTR _web+628, eax
	jne	$LN96@torus_bodi

; 2536 :       { vertex_id *v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR tv3559[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+304]

; 2537 :         WRAPTYPE lwrap;
; 2538 :         get_facet_verts(f_id,xxx,NULL);  /* for positive facet */

	mov	edx, DWORD PTR _xxx$[ebp]
	push	0
	push	edx
	push	esi
	mov	DWORD PTR _v$91126[ebp], eax
	call	_get_facet_verts
	add	esp, 12					; 0000000cH

; 2539 :         if ( inverted(f_id) )

	cmp	DWORD PTR tv3571[ebp], 0
	je	SHORT $LN95@torus_bodi

; 2540 :            lwrap = (*sym_compose)(get_fe_wrap(fe),wrap);

	mov	ecx, DWORD PTR _web+460
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+124
	and	ebx, 134217728				; 08000000H
	xor	ebx, DWORD PTR [edx+20]
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN333@torus_bodi
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN333@torus_bodi:
	push	edi
	push	eax
	call	DWORD PTR _sym_compose
	add	esp, 8
	mov	DWORD PTR _lwrap$91131[ebp], eax
	jmp	SHORT $LN94@torus_bodi
$LN95@torus_bodi:

; 2541 :         else lwrap = wrap;

	mov	DWORD PTR _lwrap$91131[ebp], edi
$LN94@torus_bodi:

; 2542 :         for ( i = 0 ; i < ctrlpts ; i++ )

	xor	ebx, ebx
	cmp	DWORD PTR _ctrlpts$[ebp], ebx
	jle	$LN499@torus_bodi
	mov	edi, DWORD PTR _gdata$[ebp]
	add	edi, 104				; 00000068H
	npad	5
$LL93@torus_bodi:

; 2543 :         { int ii;
; 2544 :           if ( inverted(f_id) )

	cmp	DWORD PTR tv3571[ebp], 0
	je	SHORT $LN90@torus_bodi

; 2545 :           { int row=0,col;

	xor	esi, esi

; 2546 :             int n;
; 2547 :             n = 0;

	xor	ecx, ecx

; 2548 :             while ( n + (web.lagrange_order-row)  < i )

	cmp	DWORD PTR _web+632, ebx
	jge	SHORT $LN88@torus_bodi
	mov	eax, DWORD PTR _web+632
	mov	edx, eax
	npad	4
$LL89@torus_bodi:

; 2549 :             { n += web.lagrange_order-row+1;
; 2550 :               row++;

	dec	edx
	lea	ecx, DWORD PTR [eax+1]
	lea	eax, DWORD PTR [edx+ecx]
	inc	esi
	cmp	eax, ebx
	jl	SHORT $LL89@torus_bodi
$LN88@torus_bodi:

; 2551 :             }
; 2552 :             col = i - n;
; 2553 :             ii = n + (web.lagrange_order-row-col);

	lea	eax, DWORD PTR [ecx+ecx]
	sub	eax, esi
	mov	esi, DWORD PTR _f_id$[ebp]
	sub	eax, ebx
	add	eax, DWORD PTR _web+632
	jmp	SHORT $LN87@torus_bodi
$LN90@torus_bodi:

; 2554 :           }
; 2555 :           else ii = i;

	mov	eax, ebx
$LN87@torus_bodi:

; 2556 :           gdata[i].v_id = v[ii];

	mov	ecx, DWORD PTR _v$91126[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]

; 2557 :           (*sym_wrap)(xxx[ii],gdata[i].x,lwrap);

	mov	ecx, DWORD PTR _lwrap$91131[ebp]
	mov	DWORD PTR [edi+28], edx
	push	ecx
	mov	ecx, DWORD PTR _xxx$[ebp]
	lea	edx, DWORD PTR [edi-104]
	push	edx
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 2558 :           if ( colorflag )  

	cmp	DWORD PTR _colorflag, 0
	je	SHORT $LN86@torus_bodi

; 2559 :             gdata[i].color = gdata[i].backcolor = 
; 2560 :                        (facet_rgb_color_attr > 0 ) ?
; 2561 :                          INDEX_TO_RGBA(b_ord) : b_ord;

	cmp	DWORD PTR _facet_rgb_color_attr, 0
	mov	eax, DWORD PTR _b_ord$[ebp]
	jle	SHORT $LN220@torus_bodi
	push	eax
	call	_INDEX_TO_RGBA
	add	esp, 4
$LN220@torus_bodi:
	mov	DWORD PTR [edi], eax

; 2562 :            else

	jmp	SHORT $LN566@torus_bodi
$LN86@torus_bodi:

; 2563 :            { if ( inverted(f_id) )

	cmp	DWORD PTR tv3571[ebp], 0

; 2564 :              { gdata[i].color = get_facet_backcolor_2(f_id);

	push	esi
	je	SHORT $LN84@torus_bodi
	call	_get_facet_backcolor_2

; 2565 :                gdata[i].backcolor = get_facet_frontcolor_2(f_id);

	push	esi
	mov	DWORD PTR [edi], eax
	call	_get_facet_frontcolor_2

; 2566 :              }
; 2567 :              else

	jmp	SHORT $LN567@torus_bodi
$LN84@torus_bodi:

; 2568 :              { gdata[i].color = get_facet_frontcolor_2(f_id);

	call	_get_facet_frontcolor_2

; 2569 :                gdata[i].backcolor = get_facet_backcolor_2(f_id);

	push	esi
	mov	DWORD PTR [edi], eax
	call	_get_facet_backcolor_2
$LN567@torus_bodi:
	add	esp, 8
$LN566@torus_bodi:
	mov	DWORD PTR [edi+4], eax

; 2570 :              }
; 2571 :            }
; 2572 :            if ( opacity_attr )

	mov	ecx, DWORD PTR _opacity_attr
	test	ecx, ecx
	je	SHORT $LN92@torus_bodi

; 2573 :                gdata[i].opacity = *(REAL*)(get_extra(f_id,opacity_attr));

	mov	eax, esi
	imul	ecx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	edx, ecx
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ecx+64]
	mov	ecx, DWORD PTR tv3559[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	fld	QWORD PTR [edx+eax]
	fstp	QWORD PTR [edi+8]
$LN92@torus_bodi:

; 2542 :         for ( i = 0 ; i < ctrlpts ; i++ )

	inc	ebx
	add	edi, 144				; 00000090H
	cmp	ebx, DWORD PTR _ctrlpts$[ebp]
	jl	$LL93@torus_bodi

; 2574 :          }
; 2575 :        }
; 2576 :        else

	jmp	$LN499@torus_bodi
$LN96@torus_bodi:

; 2577 :        for ( i = 0 ; i < FACET_VERTS ; i++ )    /* vertex loop */

	mov	edi, DWORD PTR _gdata$[ebp]
	add	edi, 104				; 00000068H
	mov	DWORD PTR tv2179[ebp], eax
	npad	12
$LL515@torus_bodi:

; 2578 :        { REAL *verts;
; 2579 :          vertex_id v_id;
; 2580 : 
; 2581 :           e_id = get_fe_edge(fe);

	mov	ecx, DWORD PTR _web+460
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+20]

; 2582 :           gdata[i].v_id = v_id = get_edge_tailv(e_id);

	mov	ecx, DWORD PTR _web+124
	and	ebx, 134217728				; 08000000H
	xor	eax, ebx
	mov	DWORD PTR tv4142[ebp], ebx
	mov	ebx, eax
	shr	ebx, 27					; 0000001bH
	and	ebx, 1
	mov	DWORD PTR tv4209[ebp], ebx
	je	SHORT $LN340@torus_bodi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR tv4212[ebp], eax
	mov	eax, DWORD PTR _web+216
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN339@torus_bodi
$LN340@torus_bodi:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR tv4212[ebp], eax
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]
$LN339@torus_bodi:

; 2583 :           verts = get_coord(v_id);
; 2584 :           (*sym_wrap)(verts,gdata[i].x,wrap);

	mov	ecx, DWORD PTR _wrap$91113[ebp]
	mov	DWORD PTR [edi+28], eax
	push	ecx
	mov	ecx, DWORD PTR _web+12
	lea	edx, DWORD PTR [edi-104]
	push	edx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+64]
	push	edx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 2585 :           if ( colorflag )  gdata[i].color = gdata[i].backcolor = 

	cmp	DWORD PTR _colorflag, 0
	je	SHORT $LN77@torus_bodi

; 2586 :              (facet_rgb_color_attr > 0 ) ? INDEX_TO_RGBA(b_ord) :
; 2587 :                       b_ord;

	cmp	DWORD PTR _facet_rgb_color_attr, 0
	jle	SHORT $LN221@torus_bodi
	mov	edx, DWORD PTR _b_ord$[ebp]
	push	edx
	call	_INDEX_TO_RGBA
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 2588 :           else

	jmp	SHORT $LN568@torus_bodi
$LN221@torus_bodi:

; 2586 :              (facet_rgb_color_attr > 0 ) ? INDEX_TO_RGBA(b_ord) :
; 2587 :                       b_ord;

	mov	eax, DWORD PTR _b_ord$[ebp]
	mov	DWORD PTR [edi], eax

; 2588 :           else

	jmp	SHORT $LN568@torus_bodi
$LN77@torus_bodi:

; 2589 :           { gdata[i].color = get_facet_frontcolor_2(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	call	_get_facet_frontcolor_2

; 2590 :             gdata[i].backcolor = get_facet_backcolor_2(f_id);

	mov	ecx, DWORD PTR _f_id$[ebp]
	push	ecx
	mov	DWORD PTR [edi], eax
	call	_get_facet_backcolor_2
	add	esp, 8
$LN568@torus_bodi:
	mov	DWORD PTR [edi+4], eax

; 2591 :           }
; 2592 :           if ( opacity_attr )

	mov	ecx, DWORD PTR _opacity_attr
	test	ecx, ecx
	je	SHORT $LN75@torus_bodi

; 2593 :              gdata[i].opacity = *(REAL*)(get_extra(f_id,opacity_attr));

	mov	eax, DWORD PTR _f_id$[ebp]
	imul	ecx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	edx, ecx
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ecx+64]
	mov	ecx, DWORD PTR tv3559[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	fld	QWORD PTR [edx+eax]
	fstp	QWORD PTR [edi+8]
$LN75@torus_bodi:

; 2594 :           /* wrap vertices that belong with base of edge */
; 2595 :           if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	$LN74@torus_bodi

; 2596 :           { if ( !inverted(e_id) )

	test	ebx, ebx
	jne	SHORT $LN73@torus_bodi

; 2597 :              { verts = get_coord(get_edge_midv(e_id));
; 2598 :                (*sym_wrap)(verts,gdata[FACET_VERTS+i].x,wrap);

	mov	ecx, DWORD PTR _wrap$91113[ebp]
	mov	eax, DWORD PTR _web+124
	push	ecx
	mov	ecx, DWORD PTR tv4212[ebp]
	lea	edx, DWORD PTR [edi+328]
	push	edx
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+eax+304]
	mov	edx, DWORD PTR [edx+ecx+8]
	mov	ecx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+104
	add	edx, DWORD PTR [ecx+eax+64]
	push	edx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH
$LN73@torus_bodi:

; 2599 :              }
; 2600 :              gdata[FACET_VERTS+i].color = gdata[i].color;

	mov	edx, DWORD PTR [edi]

; 2601 :              gdata[FACET_VERTS+i].backcolor = gdata[i].backcolor;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edi+432], edx

; 2602 :              gdata[FACET_VERTS+i].v_id = get_edge_midv(e_id);

	mov	edx, DWORD PTR tv4212[ebp]
	mov	DWORD PTR [edi+436], eax
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	edx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR [edi+460], edx
$LN74@torus_bodi:

; 2603 :           }
; 2604 : 
; 2605 :           wrap = (*sym_compose)(wrap,get_fe_wrap(fe));

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ecx+20]
	xor	eax, DWORD PTR tv4142[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+ebx+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN349@torus_bodi
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN350@torus_bodi
$LN349@torus_bodi:
	mov	eax, ecx
$LN350@torus_bodi:
	mov	edx, DWORD PTR _wrap$91113[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose
	add	esp, 8

; 2606 :           if ( web.modeltype == QUADRATIC && inverted(e_id) )

	cmp	DWORD PTR _web+628, 2
	mov	DWORD PTR _wrap$91113[ebp], eax
	jne	SHORT $LN516@torus_bodi
	cmp	DWORD PTR tv4209[ebp], 0
	je	SHORT $LN516@torus_bodi

; 2607 :           { verts = get_coord(get_edge_midv(e_id));

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv4212[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _web+216

; 2608 :             (*sym_wrap)(verts,gdata[FACET_VERTS+i].x,wrap);

	push	eax
	lea	eax, DWORD PTR [edi+328]
	push	eax
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+304]
	mov	ecx, DWORD PTR [ecx+edx+8]
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+104
	add	ecx, DWORD PTR [edx+eax+64]
	push	ecx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH
$LN516@torus_bodi:

; 2609 :           }
; 2610 :           fe = get_next_edge(fe);

	test	DWORD PTR _fe$[ebp], 134217728		; 08000000H
	je	SHORT $LN352@torus_bodi
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [esi+eax]
	mov	ebx, DWORD PTR [ecx+28]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN569@torus_bodi
$LN352@torus_bodi:
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [esi+edx]
	mov	ebx, DWORD PTR [eax+32]
$LN569@torus_bodi:

; 2577 :        for ( i = 0 ; i < FACET_VERTS ; i++ )    /* vertex loop */

	add	edi, 144				; 00000090H
	dec	DWORD PTR tv2179[ebp]

; 2609 :           }
; 2610 :           fe = get_next_edge(fe);

	mov	DWORD PTR _fe$[ebp], ebx
	jne	$LL515@torus_bodi

; 2574 :          }
; 2575 :        }
; 2576 :        else

	mov	esi, DWORD PTR _f_id$[ebp]
$LN499@torus_bodi:

; 2611 :         }
; 2612 : 
; 2613 :         if ( show_expr[FACET] && show_expr[FACET]->start )

	mov	eax, DWORD PTR _show_expr+8
	test	eax, eax
	je	SHORT $LN500@torus_bodi
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN500@torus_bodi

; 2614 :           if ( !eval(show_expr[FACET],NULL,f_id,NULL) ) 

	push	0
	push	esi
	push	0
	push	eax
	call	_eval
	fldz
	fucompp
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN500@torus_bodi

; 2615 :             gdata[0].color = gdata[0].backcolor = UNSHOWN; /* maybe do edges */

	mov	ecx, DWORD PTR _gdata$[ebp]
	mov	eax, -3					; fffffffdH
	mov	DWORD PTR [ecx+108], eax
	mov	DWORD PTR [ecx+104], eax
$LN500@torus_bodi:

; 2616 : 
; 2617 : 
; 2618 :         /* do inner clipping, if called for */
; 2619 :         if ( inner_clip_flag )

	cmp	DWORD PTR _inner_clip_flag, 0
	je	$LN520@torus_bodi

; 2620 :         {
; 2621 :           for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	ecx, DWORD PTR _web+976

; 2623 :             REAL *x = get_coord(web.zoom_v);

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR _web+104
	mov	edi, DWORD PTR _web+616
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+ecx*4]

; 2649 :            { calc_vertex_smooth_normal(get_fe_tailv(fe),fe,gdata[i].norm);

	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _gdata$[ebp]
	xor	ebx, ebx
	add	esi, DWORD PTR [eax+ecx+64]
	mov	DWORD PTR tv6186[ebp], edx
$LL506@torus_bodi:

; 2624 : 
; 2625 :             for ( j = 0 ; j < SDIM ; j++ )

	fldz
	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN63@torus_bodi

; 2622 :           { REAL dist = 0.0;

	mov	ecx, DWORD PTR tv6186[ebp]
$LN65@torus_bodi:

; 2626 :               dist += (x[j]-gdata[i].x[j])*(x[j]-gdata[i].x[j]);

	fld	QWORD PTR [esi+eax*8]
	inc	eax
	fsub	QWORD PTR [ecx]
	add	ecx, 8
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	cmp	eax, edi
	jl	SHORT $LN65@torus_bodi
$LN63@torus_bodi:

; 2627 :     
; 2628 :             if ( sqrt(dist) > inner_clip_rad ) break; /* it's a keeper */

	call	__CIsqrt
	fcomp	QWORD PTR _inner_clip_rad
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN527@torus_bodi

; 2620 :         {
; 2621 :           for ( i = 0 ; i < FACET_VERTS ; i++ )

	add	DWORD PTR tv6186[ebp], 144		; 00000090H
	inc	ebx
	cmp	ebx, 3
	jl	SHORT $LL506@torus_bodi
$LN527@torus_bodi:

; 2629 :           }
; 2630 :              if ( i == FACET_VERTS ) continue; /* entirely inside */

	cmp	ebx, 3
	je	$LN101@torus_bodi
$LN520@torus_bodi:
	mov	edi, DWORD PTR _gdata$[ebp]

; 2631 :         }
; 2632 : 
; 2633 :         if ( gdata[0].color != gdata[0].backcolor )

	mov	eax, DWORD PTR [edi+104]
	cmp	eax, DWORD PTR [edi+108]
	je	$LN501@torus_bodi

; 2634 :         { /* need normal for separation */ 
; 2635 :           REAL dd;
; 2636 :           if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3

; 2637 :             vnormal(gdata[0].x,gdata[web.lagrange_order].x,gdata[ctrlpts-1].x,
; 2638 :                           gdata[0].norm);

	lea	esi, DWORD PTR [edi+56]
	push	esi
	jne	SHORT $LN59@torus_bodi
	mov	eax, DWORD PTR _ctrlpts$[ebp]
	lea	ecx, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR _web+632
	add	ecx, ecx
	lea	eax, DWORD PTR [eax+eax*8]
	lea	edx, DWORD PTR [edi+ecx*8-144]
	shl	eax, 4
	push	edx
	add	eax, edi
	push	eax
	jmp	SHORT $LN570@torus_bodi
$LN59@torus_bodi:

; 2639 :           else vnormal(gdata[0].x,gdata[1].x,gdata[2].x,gdata[0].norm);

	lea	ecx, DWORD PTR [edi+288]
	push	ecx
	lea	edx, DWORD PTR [edi+144]
	push	edx
$LN570@torus_bodi:
	push	edi
	call	_vnormal

; 2640 :           dd = sqrt(SDIM_dot(gdata[0].norm,gdata[0].norm));

	mov	eax, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	push	eax
	push	esi
	push	esi
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 2641 :           for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN556@torus_bodi

; 2640 :           dd = sqrt(SDIM_dot(gdata[0].norm,gdata[0].norm));

	mov	eax, esi
$LN57@torus_bodi:

; 2642 :           gdata[0].norm[i] /= dd;

	fld	QWORD PTR [eax]
	inc	ecx
	fdiv	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN57@torus_bodi
$LN556@torus_bodi:

; 2641 :           for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN501@torus_bodi:

; 2643 :         }
; 2644 : 
; 2645 :         fe = get_facet_fe(f_id);
; 2646 :         if ( normflag || thickenflag  )

	cmp	DWORD PTR _normflag, 0
	jne	SHORT $LN519@torus_bodi
	cmp	DWORD PTR _thickenflag, 0
	je	$LN50@torus_bodi
	mov	edi, DWORD PTR _gdata$[ebp]
$LN519@torus_bodi:

; 2647 :          { fe = get_facet_fe(f_id);

	cmp	DWORD PTR tv3571[ebp], 0
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR tv3559[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	esi, DWORD PTR [eax+28]
	je	SHORT $LN359@torus_bodi
	xor	esi, 134217728				; 08000000H
$LN359@torus_bodi:

; 2648 :            for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _web+460
	lea	ebx, DWORD PTR [edi+56]
	mov	DWORD PTR tv986[ebp], 3
	npad	1
$LL502@torus_bodi:
	mov	ecx, DWORD PTR _dymem

; 2649 :            { calc_vertex_smooth_normal(get_fe_tailv(fe),fe,gdata[i].norm);

	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+eax]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN366@torus_bodi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	add	eax, DWORD PTR [edx+ecx+304]
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN365@torus_bodi
$LN366@torus_bodi:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [edx+ecx+304]
	mov	eax, DWORD PTR [eax+ecx]
$LN365@torus_bodi:
	push	ebx
	push	esi
	push	eax
	call	_calc_vertex_smooth_normal

; 2650 :              fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	add	esp, 12					; 0000000cH
	test	esi, 134217728				; 08000000H
	je	SHORT $LN370@torus_bodi
	mov	edx, DWORD PTR [edi+eax]
	mov	esi, DWORD PTR [edx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN51@torus_bodi
$LN370@torus_bodi:
	mov	ecx, DWORD PTR [edi+eax]
	mov	esi, DWORD PTR [ecx+32]
$LN51@torus_bodi:

; 2648 :            for ( i = 0 ; i < FACET_VERTS ; i++ )

	add	ebx, 144				; 00000090H
	dec	DWORD PTR tv986[ebp]
	jne	$LL502@torus_bodi
$LN50@torus_bodi:

; 2651 :            }
; 2652 :          }
; 2653 :   
; 2654 :         /* check for special edges */
; 2655 :         fe_id = get_facet_fe(f_id);

	cmp	DWORD PTR tv3571[ebp], 0
	mov	eax, DWORD PTR tv3559[ebp]
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [ecx+28]
	je	SHORT $LN510@torus_bodi
	xor	eax, 134217728				; 08000000H
$LN510@torus_bodi:

; 2656 :         for ( i = 0 ; i < 3 ; i++, fe_id = get_next_edge(fe_id) )

	mov	esi, DWORD PTR _gdata$[ebp]
	mov	DWORD PTR _fe_id$91115[ebp], eax
	add	esi, 124				; 0000007cH
	mov	DWORD PTR tv948[ebp], 3
	npad	5
$LL377@torus_bodi:

; 2657 :           {  ATTR eattr;
; 2658 :              gdata[i].etype = INVISIBLE_EDGE; /* default */
; 2659 :              gdata[i].id = e_id = get_fe_edge(fe_id);

	mov	edi, DWORD PTR _fe_id$91115[ebp]
	mov	ebx, edi
	and	ebx, 134217727				; 07ffffffH
	xor	edx, edx
	mov	WORD PTR [esi], dx
	mov	eax, DWORD PTR _web+460
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [eax+ebx]
	and	edi, 134217728				; 08000000H
	xor	edi, DWORD PTR [ecx+20]

; 2660 :              gdata[i].ecolor = get_edge_color_2(e_id);

	push	edi
	mov	DWORD PTR [esi+4], edi
	call	_get_edge_color_2
	mov	DWORD PTR [esi-4], eax

; 2661 :              eattr = get_eattr(e_id);

	mov	eax, DWORD PTR _web+124
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+8]
	add	esp, 4

; 2662 :              if ( get_edge_color(e_id) == CLEAR ) continue;

	cmp	WORD PTR [eax+56], -1
	mov	DWORD PTR _eattr$91229[ebp+4], ecx
	je	$LN48@torus_bodi

; 2663 :              if ( eattr & BOUNDARY ) gdata[i].etype |= BOUNDARY_EDGE;

	mov	eax, edx
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN45@torus_bodi
	mov	eax, 8
	mov	WORD PTR [esi], ax
$LN45@torus_bodi:

; 2664 :              if ( equal_id(get_next_facet(fe_id),fe_id) ) /* valence 1 */

	mov	eax, DWORD PTR _fe_id$91115[ebp]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv4372[ebp], eax
	je	SHORT $LN384@torus_bodi
	mov	ecx, DWORD PTR _web+460
	mov	eax, DWORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN571@torus_bodi
$LN384@torus_bodi:
	mov	eax, DWORD PTR _web+460
	mov	eax, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [eax+40]
$LN571@torus_bodi:
	mov	DWORD PTR $T93563[ebp], ecx
	mov	ecx, DWORD PTR _fe_id$91115[ebp]
	cmp	DWORD PTR $T93563[ebp], ecx
	jne	SHORT $LN44@torus_bodi

; 2665 :                 gdata[i].etype |= SINGLE_EDGE;

	or	WORD PTR [esi], 4
	jmp	SHORT $LN514@torus_bodi
$LN44@torus_bodi:

; 2666 :              else if  ( !equal_id(get_next_facet(fe_id),get_prev_facet(fe_id)) )

	cmp	DWORD PTR tv4372[ebp], 0
	je	SHORT $LN388@torus_bodi
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN572@torus_bodi
$LN388@torus_bodi:
	mov	ecx, DWORD PTR [eax+40]
$LN572@torus_bodi:
	cmp	DWORD PTR tv4372[ebp], 0
	mov	DWORD PTR $T93569[ebp], ecx
	je	SHORT $LN392@torus_bodi
	mov	eax, DWORD PTR [eax+40]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN391@torus_bodi
$LN392@torus_bodi:
	mov	eax, DWORD PTR [eax+36]
$LN391@torus_bodi:
	cmp	DWORD PTR $T93569[ebp], eax
	je	SHORT $LN514@torus_bodi

; 2667 :                 gdata[i].etype |= TRIPLE_EDGE; /* triple line at least */

	or	WORD PTR [esi], 2
$LN514@torus_bodi:

; 2668 :              if ( (eattr & HIT_WALL) )

	mov	eax, edx
	and	eax, 8192				; 00002000H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN522@torus_bodi

; 2669 :                 gdata[i].etype |= CONSTRAINT_EDGE;

	or	WORD PTR [esi], 32			; 00000020H
$LN522@torus_bodi:

; 2670 :              if ( (eattr & FIXED) )

	and	edx, 64					; 00000040H
	mov	eax, edx
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN40@torus_bodi

; 2671 :                 gdata[i].etype |= FIXED_EDGE;

	or	WORD PTR [esi], 16			; 00000010H
$LN40@torus_bodi:

; 2672 :              if ( show_expr[EDGE] && show_expr[EDGE]->start )

	mov	eax, DWORD PTR _show_expr+4
	test	eax, eax
	je	SHORT $LN48@torus_bodi
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN48@torus_bodi

; 2673 :              { if ( eval(show_expr[EDGE],NULL,e_id,NULL) ) 

	push	0
	push	edi
	push	0
	push	eax
	call	_eval
	fldz
	fucompp
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN38@torus_bodi

; 2674 :                   gdata[i].etype |= REGULAR_EDGE;

	or	WORD PTR [esi], 1
	jmp	SHORT $LN48@torus_bodi
$LN38@torus_bodi:

; 2675 :                else gdata[i].etype = INVISIBLE_EDGE;

	xor	edx, edx
	mov	WORD PTR [esi], dx
$LN48@torus_bodi:

; 2656 :         for ( i = 0 ; i < 3 ; i++, fe_id = get_next_edge(fe_id) )

	add	esi, 144				; 00000090H
	test	DWORD PTR _fe_id$91115[ebp], 134217728	; 08000000H
	je	SHORT $LN378@torus_bodi
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [eax+ebx]
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _fe_id$91115[ebp], eax
	jmp	SHORT $LN463@torus_bodi
$LN378@torus_bodi:
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [edx+ebx]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _fe_id$91115[ebp], ecx
$LN463@torus_bodi:
	dec	DWORD PTR tv948[ebp]
	jne	$LL377@torus_bodi

; 2679 :         /* call device-specific routine */
; 2680 :         if ( web.modeltype == LINEAR )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	jne	SHORT $LN36@torus_bodi

; 2681 :         { /* call option-specific routine */
; 2682 :           gdata->flags |= LABEL_FACET;
; 2683 :           option_facet(gdata,f_id);         

	mov	edx, DWORD PTR _f_id$[ebp]
	mov	eax, DWORD PTR _gdata$[ebp]
	or	DWORD PTR [eax+136], 8192		; 00002000H
	push	edx
	push	eax
	call	_option_facet
	add	esp, 8
	jmp	$LN101@torus_bodi
$LN36@torus_bodi:

; 2684 :         }
; 2685 :         else if ( web.modeltype == QUADRATIC )

	cmp	eax, 2
	jne	$LN34@torus_bodi

; 2686 :         /* plot as four subtriangles */
; 2687 :         { 
; 2688 :           struct graphdata qdata[FACET_VERTS+1];
; 2689 :           memcpy((char*)qdata,(char*)gdata,3*sizeof(struct graphdata));

	mov	ebx, DWORD PTR _gdata$[ebp]

; 2690 :           qdata[0].flags = 0;
; 2691 : 
; 2692 :           for( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR _web+616
	mov	ecx, 108				; 0000006cH
	mov	esi, ebx
	lea	edi, DWORD PTR _qdata$91250[ebp]
	rep movsd
	xor	esi, esi
	xor	eax, eax
	cmp	edx, esi
	jle	SHORT $LN513@torus_bodi

; 2676 :              }
; 2677 : 
; 2678 :            }

	lea	ecx, DWORD PTR [ebx+720]
	npad	7
$LL33@torus_bodi:

; 2693 :           { qdata[1].x[j] = gdata[3].x[j];

	fld	QWORD PTR [ecx-288]
	inc	eax
	fstp	QWORD PTR _qdata$91250[ebp+eax*8+136]
	add	ecx, 8

; 2694 :             qdata[2].x[j] = gdata[5].x[j];

	fld	QWORD PTR [ecx-8]
	fstp	QWORD PTR _qdata$91250[ebp+eax*8+280]
	cmp	eax, edx
	jl	SHORT $LL33@torus_bodi
$LN513@torus_bodi:

; 2695 :           }
; 2696 :           qdata[1].etype=INVISIBLE_EDGE;
; 2697 :           qdata[1].v_id = gdata[3].v_id;
; 2698 :           qdata[2].v_id = gdata[5].v_id;
; 2699 :           qdata[0].flags = 0;
; 2700 :           option_facet(qdata,f_id);

	mov	edi, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR [ebx+564]
	mov	edx, DWORD PTR [ebx+852]
	xor	eax, eax
	mov	WORD PTR _qdata$91250[ebp+268], ax
	lea	eax, DWORD PTR _qdata$91250[ebp]
	push	edi
	push	eax
	mov	DWORD PTR _qdata$91250[ebp+276], ecx
	mov	DWORD PTR _qdata$91250[ebp+420], edx
	mov	DWORD PTR _qdata$91250[ebp+136], esi
	call	_option_facet
	add	esp, 8

; 2701 : 
; 2702 :           for(j=0;j<SDIM;j++)

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN28@torus_bodi

; 2703 :           { qdata[0].x[j]=gdata[3].x[j];qdata[1].x[j]=gdata[1].x[j];

	lea	edx, DWORD PTR _qdata$91250[ebp]
	lea	esi, DWORD PTR _qdata$91250[ebp+144]
	sub	edx, ebx
	lea	eax, DWORD PTR [ebx+144]
	sub	esi, ebx
	npad	4
$LL523@torus_bodi:
	fld	QWORD PTR [eax+288]
	inc	ecx
	fstp	QWORD PTR _qdata$91250[ebp+ecx*8-8]
	add	eax, 8
	fld	QWORD PTR [eax-8]
	fstp	QWORD PTR [edx+eax-8]

; 2704 :             qdata[2].x[j]=gdata[4].x[j];

	fld	QWORD PTR [eax+424]
	fstp	QWORD PTR [esi+eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL523@torus_bodi

; 2701 : 
; 2702 :           for(j=0;j<SDIM;j++)

	xor	esi, esi
$LN28@torus_bodi:

; 2707 :           qdata[2].etype=INVISIBLE_EDGE;
; 2708 :           qdata[0].v_id = gdata[3].v_id;

	mov	eax, DWORD PTR [ebx+564]
	mov	cx, WORD PTR [ebx+268]
	xor	edx, edx
	mov	DWORD PTR _qdata$91250[ebp+132], eax
	mov	WORD PTR _qdata$91250[ebp+268], cx

; 2709 :           qdata[1].v_id = gdata[1].v_id;

	mov	ecx, DWORD PTR [ebx+276]
	mov	WORD PTR _qdata$91250[ebp+412], dx

; 2710 :           qdata[2].v_id = gdata[4].v_id;

	mov	edx, DWORD PTR [ebx+708]

; 2711 :           qdata[0].flags = 0;
; 2712 :           option_facet(qdata,f_id);

	lea	eax, DWORD PTR _qdata$91250[ebp]
	push	edi
	push	eax
	mov	DWORD PTR _qdata$91250[ebp+276], ecx
	mov	DWORD PTR _qdata$91250[ebp+420], edx
	mov	DWORD PTR _qdata$91250[ebp+136], esi
	call	_option_facet

; 2713 : 
; 2714 :           for(j=0;j<SDIM;j++)

	mov	edx, DWORD PTR _web+616
	add	esp, 8
	xor	eax, eax
	cmp	edx, esi
	jle	SHORT $LN25@torus_bodi

; 2705 :           }
; 2706 :           qdata[1].etype=gdata[1].etype;

	lea	ecx, DWORD PTR [ebx+576]
	npad	1
$LL27@torus_bodi:

; 2715 :           { qdata[0].x[j]=gdata[5].x[j];qdata[1].x[j]=gdata[4].x[j];

	fld	QWORD PTR [ecx+144]
	inc	eax
	fstp	QWORD PTR _qdata$91250[ebp+eax*8-8]
	add	ecx, 8
	fld	QWORD PTR [ecx-8]
	fstp	QWORD PTR _qdata$91250[ebp+eax*8+136]

; 2716 :             qdata[2].x[j]=gdata[2].x[j];

	fld	QWORD PTR [ecx-296]
	fstp	QWORD PTR _qdata$91250[ebp+eax*8+280]
	cmp	eax, edx
	jl	SHORT $LL27@torus_bodi
$LN25@torus_bodi:

; 2719 :           qdata[0].etype=INVISIBLE_EDGE;
; 2720 :           qdata[0].v_id = gdata[5].v_id;

	mov	eax, DWORD PTR [ebx+852]
	mov	cx, WORD PTR [ebx+412]
	xor	edx, edx
	mov	DWORD PTR _qdata$91250[ebp+132], eax
	mov	WORD PTR _qdata$91250[ebp+412], cx

; 2721 :           qdata[1].v_id = gdata[4].v_id;

	mov	ecx, DWORD PTR [ebx+708]
	mov	WORD PTR _qdata$91250[ebp+124], dx

; 2722 :           qdata[2].v_id = gdata[2].v_id;

	mov	edx, DWORD PTR [ebx+420]

; 2723 :           qdata[0].flags = 0;
; 2724 :           option_facet(qdata,f_id);

	lea	eax, DWORD PTR _qdata$91250[ebp]
	push	edi
	push	eax
	mov	DWORD PTR _qdata$91250[ebp+276], ecx
	mov	DWORD PTR _qdata$91250[ebp+420], edx
	mov	DWORD PTR _qdata$91250[ebp+136], esi
	call	_option_facet

; 2725 : 
; 2726 :           for(j=0;j<SDIM;j++)

	mov	edx, DWORD PTR _web+616
	add	esp, 8
	xor	eax, eax
	cmp	edx, esi
	jle	SHORT $LN22@torus_bodi

; 2717 :           }
; 2718 :           qdata[2].etype=gdata[2].etype;

	lea	ecx, DWORD PTR [ebx+576]
	npad	1
$LL24@torus_bodi:

; 2727 :           { qdata[0].x[j]=gdata[3].x[j];qdata[1].x[j]=gdata[4].x[j];

	fld	QWORD PTR [ecx-144]
	inc	eax
	fstp	QWORD PTR _qdata$91250[ebp+eax*8-8]
	add	ecx, 8
	fld	QWORD PTR [ecx-8]
	fstp	QWORD PTR _qdata$91250[ebp+eax*8+136]

; 2728 :             qdata[2].x[j]=gdata[5].x[j];

	fld	QWORD PTR [ecx+136]
	fstp	QWORD PTR _qdata$91250[ebp+eax*8+280]
	cmp	eax, edx
	jl	SHORT $LL24@torus_bodi
$LN22@torus_bodi:

; 2729 :           }
; 2730 :           qdata[0].etype=INVISIBLE_EDGE;

	xor	ecx, ecx
	mov	WORD PTR _qdata$91250[ebp+124], cx

; 2731 :           qdata[1].etype=INVISIBLE_EDGE;
; 2732 :           qdata[2].etype=INVISIBLE_EDGE;
; 2733 :           qdata[0].v_id = gdata[3].v_id;

	mov	ecx, DWORD PTR [ebx+564]
	xor	edx, edx
	xor	eax, eax
	mov	DWORD PTR _qdata$91250[ebp+132], ecx
	mov	WORD PTR _qdata$91250[ebp+268], dx

; 2734 :           qdata[1].v_id = gdata[4].v_id;

	mov	edx, DWORD PTR [ebx+708]
	mov	WORD PTR _qdata$91250[ebp+412], ax

; 2735 :           qdata[2].v_id = gdata[5].v_id;

	mov	eax, DWORD PTR [ebx+852]

; 2736 :           qdata[0].flags = LABEL_FACET;
; 2737 :           option_facet(qdata,f_id);

	lea	ecx, DWORD PTR _qdata$91250[ebp]
	push	edi
	push	ecx
	mov	DWORD PTR _qdata$91250[ebp+276], edx
	mov	DWORD PTR _qdata$91250[ebp+420], eax
	mov	DWORD PTR _qdata$91250[ebp+136], 8192	; 00002000H
	call	_option_facet
	add	esp, 8
	jmp	$LN101@torus_bodi
$LN34@torus_bodi:

; 2738 :         }
; 2739 :         else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	$LN101@torus_bodi

; 2740 :         { int ii,jj;
; 2741 :           /* plot as subtriangles */
; 2742 :           int flags = (gdata[0].flags|LIST_FACET) & ~LABEL_FACET;

	mov	esi, DWORD PTR _gdata$[ebp]
	mov	eax, DWORD PTR [esi+136]
	and	eax, -8193				; ffffdfffH

; 2743 :           struct graphdata qdata[FACET_VERTS+1];
; 2744 :           memcpy((char*)qdata,(char*)gdata,3*sizeof(struct graphdata));

	mov	ecx, 108				; 0000006cH
	lea	edi, DWORD PTR _qdata$91271[ebp]
	rep movsd

; 2745 :           for ( i = 0 ; i < FACET_VERTS ; i++ ) qdata[i].etype = INVISIBLE_EDGE;

	xor	ecx, ecx
	or	eax, 2
	xor	edx, edx
	mov	WORD PTR _qdata$91271[ebp+412], cx

; 2746 :           for ( j = 0,jj=0,ii=web.lagrange_order+1 ; 
; 2747 :                             j < web.lagrange_order ; j++,jj++ )

	mov	ecx, DWORD PTR _web+632
	mov	DWORD PTR _flags$91270[ebp], eax
	xor	eax, eax
	mov	WORD PTR _qdata$91271[ebp+124], dx
	lea	edx, DWORD PTR [ecx+1]
	mov	WORD PTR _qdata$91271[ebp+268], ax
	mov	DWORD PTR _j$[ebp], eax
	mov	DWORD PTR _jj$91269[ebp], eax
	mov	DWORD PTR _ii$91268[ebp], edx
	cmp	ecx, eax
	jle	$LN101@torus_bodi
	mov	esi, eax
	npad	6
$LL16@torus_bodi:

; 2748 :             for ( i = 0 ; i < web.lagrange_order-j ; i++,jj++,ii++ )

	mov	edi, ecx
	sub	edi, esi
	xor	ebx, ebx
	test	edi, edi
	jle	$LN15@torus_bodi
	lea	esi, DWORD PTR [edx+edx*8]
	mov	edx, DWORD PTR _gdata$[ebp]
	shl	esi, 4
	add	esi, edx
	lea	edi, DWORD PTR [esi+132]
	mov	DWORD PTR tv7138[ebp], edi
	lea	edi, DWORD PTR [eax+eax*8]
	shl	edi, 4
	add	edi, edx
	lea	eax, DWORD PTR [edi+276]
	add	esi, 8
	mov	DWORD PTR tv7142[ebp], eax
	add	edi, 144				; 00000090H
	npad	11
$LL511@torus_bodi:

; 2749 :              { 
; 2750 :                 for ( k = 0 ; k < 3 ; k++ )
; 2751 :                 { qdata[0].x[k]=gdata[jj].x[k];

	fld	QWORD PTR [edi-144]

; 2752 :                   qdata[1].x[k]=gdata[jj+1].x[k];
; 2753 :                   qdata[2].x[k]=gdata[ii].x[k];
; 2754 :                 }
; 2755 :                 qdata[0].v_id = gdata[jj].v_id;

	mov	edx, DWORD PTR [eax-144]

; 2756 :                 qdata[1].v_id = gdata[jj+1].v_id;

	mov	eax, DWORD PTR [eax]
	fstp	QWORD PTR _qdata$91271[ebp]
	fld	QWORD PTR [edi]
	mov	DWORD PTR _qdata$91271[ebp+132], edx

; 2757 :                 qdata[2].v_id = gdata[ii].v_id;

	mov	edx, DWORD PTR tv7138[ebp]
	fstp	QWORD PTR _qdata$91271[ebp+144]
	fld	QWORD PTR [esi-8]
	mov	DWORD PTR _qdata$91271[ebp+276], eax
	mov	eax, DWORD PTR [edx]
	fstp	QWORD PTR _qdata$91271[ebp+288]
	fld	QWORD PTR [edi-136]
	mov	DWORD PTR _qdata$91271[ebp+420], eax

; 2758 :                 qdata[0].etype = (j==0) ? gdata[0].etype : INVISIBLE_EDGE;

	mov	eax, DWORD PTR _j$[ebp]
	fstp	QWORD PTR _qdata$91271[ebp+8]
	fld	QWORD PTR [edi+8]
	fstp	QWORD PTR _qdata$91271[ebp+152]
	fld	QWORD PTR [esi]
	fstp	QWORD PTR _qdata$91271[ebp+296]
	fld	QWORD PTR [edi-128]
	fstp	QWORD PTR _qdata$91271[ebp+16]
	fld	QWORD PTR [edi+16]
	fstp	QWORD PTR _qdata$91271[ebp+160]
	fld	QWORD PTR [esi+8]
	fstp	QWORD PTR _qdata$91271[ebp+304]
	test	eax, eax
	jne	SHORT $LN223@torus_bodi
	mov	edx, DWORD PTR _gdata$[ebp]
	mov	dx, WORD PTR [edx+124]
	jmp	SHORT $LN573@torus_bodi
$LN223@torus_bodi:
	xor	edx, edx
$LN573@torus_bodi:

; 2759 :                 qdata[1].etype = (i+j+1==web.lagrange_order) ? gdata[1].etype : INVISIBLE_EDGE;

	lea	eax, DWORD PTR [eax+ebx+1]
	mov	WORD PTR _qdata$91271[ebp+124], dx
	cmp	eax, ecx
	jne	SHORT $LN225@torus_bodi
	mov	ecx, DWORD PTR _gdata$[ebp]
	mov	dx, WORD PTR [ecx+268]
	mov	WORD PTR _qdata$91271[ebp+268], dx
	jmp	SHORT $LN226@torus_bodi
$LN225@torus_bodi:
	xor	eax, eax
	mov	WORD PTR _qdata$91271[ebp+268], ax
$LN226@torus_bodi:

; 2760 :                 qdata[2].etype = (i==0) ? gdata[2].etype : INVISIBLE_EDGE;

	test	ebx, ebx
	jne	SHORT $LN227@torus_bodi
	mov	ecx, DWORD PTR _gdata$[ebp]
	mov	dx, WORD PTR [ecx+412]
	mov	WORD PTR _qdata$91271[ebp+412], dx
	jmp	SHORT $LN228@torus_bodi
$LN227@torus_bodi:
	xor	eax, eax
	mov	WORD PTR _qdata$91271[ebp+412], ax
$LN228@torus_bodi:

; 2761 :                 qdata[0].flags = flags;
; 2762 :                 option_facet(qdata,f_id);

	mov	edx, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR _flags$91270[ebp]
	push	edx
	lea	eax, DWORD PTR _qdata$91271[ebp]
	push	eax
	mov	DWORD PTR _qdata$91271[ebp+136], ecx
	call	_option_facet

; 2763 : 
; 2764 :                 if ( i < web.lagrange_order-j-1 )

	mov	ecx, DWORD PTR _web+632
	mov	edx, ecx
	sub	edx, DWORD PTR _j$[ebp]
	add	esp, 8
	dec	edx
	cmp	ebx, edx
	jge	$LN12@torus_bodi

; 2765 :                 { int n;
; 2766 :                   for ( k = 0 ; k < 3 ; k++ )
; 2767 :                   { qdata[0].x[k]=gdata[jj+1].x[k];
; 2768 :                      qdata[1].x[k]=gdata[ii+1].x[k];
; 2769 :                      qdata[2].x[k]=gdata[ii].x[k];
; 2770 :                   }
; 2771 :                   qdata[0].v_id = gdata[jj+1].v_id;

	mov	eax, DWORD PTR tv7142[ebp]
	fld	QWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	fstp	QWORD PTR _qdata$91271[ebp]

; 2772 :                   qdata[1].v_id = gdata[ii+1].v_id;

	mov	eax, DWORD PTR tv7138[ebp]
	fld	QWORD PTR [esi+136]
	fstp	QWORD PTR _qdata$91271[ebp+144]
	mov	DWORD PTR _qdata$91271[ebp+132], edx
	mov	edx, DWORD PTR [eax+144]
	fld	QWORD PTR [esi-8]

; 2773 :                   qdata[2].v_id = gdata[ii].v_id;

	mov	eax, DWORD PTR [eax]
	fstp	QWORD PTR _qdata$91271[ebp+288]
	fld	QWORD PTR [edi+8]
	mov	DWORD PTR _qdata$91271[ebp+420], eax
	fstp	QWORD PTR _qdata$91271[ebp+8]

; 2774 :                   qdata[0].flags = flags |
; 2775 :               (i==web.lagrange_order/3 && j==web.lagrange_order/3 ? LABEL_FACET:0);

	mov	eax, 1431655766				; 55555556H
	fld	QWORD PTR [esi+144]
	mov	DWORD PTR _qdata$91271[ebp+276], edx
	imul	ecx
	fstp	QWORD PTR _qdata$91271[ebp+152]
	fld	QWORD PTR [esi]
	fstp	QWORD PTR _qdata$91271[ebp+296]
	fld	QWORD PTR [edi+16]
	fstp	QWORD PTR _qdata$91271[ebp+16]
	fld	QWORD PTR [esi+152]
	fstp	QWORD PTR _qdata$91271[ebp+160]
	fld	QWORD PTR [esi+8]
	mov	eax, edx
	fstp	QWORD PTR _qdata$91271[ebp+304]
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	jne	SHORT $LN229@torus_bodi
	cmp	DWORD PTR _j$[ebp], eax
	jne	SHORT $LN229@torus_bodi
	mov	eax, 8192				; 00002000H
	jmp	SHORT $LN230@torus_bodi
$LN229@torus_bodi:
	xor	eax, eax
$LN230@torus_bodi:
	mov	ecx, DWORD PTR _flags$91270[ebp]
	or	ecx, eax

; 2776 :                   for ( n = 0 ; n < FACET_VERTS ; n++ ) 
; 2777 :                      qdata[n].etype = INVISIBLE_EDGE;

	xor	edx, edx
	xor	eax, eax
	mov	WORD PTR _qdata$91271[ebp+124], dx

; 2778 :                   option_facet(qdata,f_id);

	mov	edx, DWORD PTR _f_id$[ebp]
	mov	WORD PTR _qdata$91271[ebp+268], ax
	mov	DWORD PTR _qdata$91271[ebp+136], ecx
	push	edx
	lea	eax, DWORD PTR _qdata$91271[ebp]
	xor	ecx, ecx
	push	eax
	mov	WORD PTR _qdata$91271[ebp+412], cx
	call	_option_facet
	mov	ecx, DWORD PTR _web+632
	add	esp, 8
$LN12@torus_bodi:

; 2748 :             for ( i = 0 ; i < web.lagrange_order-j ; i++,jj++,ii++ )

	mov	eax, DWORD PTR tv7142[ebp]
	inc	DWORD PTR _jj$91269[ebp]
	inc	DWORD PTR _ii$91268[ebp]
	add	DWORD PTR tv7138[ebp], 144		; 00000090H
	mov	edx, ecx
	sub	edx, DWORD PTR _j$[ebp]
	inc	ebx
	add	eax, 144				; 00000090H
	add	edi, 144				; 00000090H
	add	esi, 144				; 00000090H
	mov	DWORD PTR tv7142[ebp], eax
	cmp	ebx, edx
	jl	$LL511@torus_bodi
	mov	esi, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _jj$91269[ebp]
	mov	edx, DWORD PTR _ii$91268[ebp]
$LN15@torus_bodi:

; 2746 :           for ( j = 0,jj=0,ii=web.lagrange_order+1 ; 
; 2747 :                             j < web.lagrange_order ; j++,jj++ )

	inc	esi
	inc	eax
	mov	DWORD PTR _j$[ebp], esi
	mov	DWORD PTR _jj$91269[ebp], eax
	cmp	esi, ecx
	jl	$LL16@torus_bodi
$LN101@torus_bodi:

; 2517 :     }  // end torus
; 2518 :      
; 2519 :     /* now plot all the facets */
; 2520 :     for ( kk = 0 ; kk < facemax ; kk++ )

	mov	eax, DWORD PTR _kk$[ebp]
	inc	eax
	mov	DWORD PTR _kk$[ebp], eax
	cmp	eax, DWORD PTR _facemax$[ebp]
	jl	$LL508@torus_bodi
$LN439@torus_bodi:

; 2779 :                 }
; 2780 :              }
; 2781 :         }
; 2782 : 
; 2783 :      }  /* end facets */
; 2784 :       
; 2785 :     temp_free((char *)allfaces);

	mov	eax, DWORD PTR _allfaces$[ebp]
	push	eax
	call	_temp_free

; 2786 :     temp_free((char *)gdata);

	mov	ecx, DWORD PTR _gdata$[ebp]
	push	ecx
	call	_temp_free

; 2787 :     free_temp_matrix(xxx);

	mov	edx, DWORD PTR _xxx$[ebp]
	push	edx
	call	_free_temp_matrix

; 2788 :     temp_free((char *)xxwrap[0]);

	mov	esi, DWORD PTR _xxwrap$[ebp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	_temp_free

; 2789 :     temp_free((char *)xxwrap);

	push	esi
	call	_temp_free

; 2790 :     temp_free((char *)to_do_list);

	mov	ecx, DWORD PTR _to_do_list$[ebp]
	push	ecx
	call	_temp_free

; 2791 : 
; 2792 : } /* end torus_bodies() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_torus_bodies ENDP
_TEXT	ENDS
PUBLIC	_polylist$GSCopy$
PUBLIC	_glist$GSCopy$
PUBLIC	_f_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_gsfn_stage_two
; Function compile flags: /Ogtp
;	COMDAT _gsfn_stage_two
_TEXT	SEGMENT
tv505 = -492						; size = 4
tv511 = -488						; size = 4
_pstartlow$ = -484					; size = 4
tv183 = -480						; size = 4
_f_id$GSCopy$ = -476					; size = 4
tv420 = -472						; size = 4
tv422 = -468						; size = 4
_nextsidelow$ = -464					; size = 4
_polylist$GSCopy$ = -460				; size = 4
tv834 = -456						; size = 4
_glist$GSCopy$ = -452					; size = 4
_stacktop$ = -448					; size = 4
_j$ = -444						; size = 4
tv517 = -440						; size = 4
_stacksidelow$ = -440					; size = 4
_gdata$ = -436						; size = 432
__$ArrayPad$ = -4					; size = 4
_glist$ = 8						; size = 4
_gcount$ = 12						; size = 4
_polylist$ = 16						; size = 4
_polycount$ = 20					; size = 4
_f_id$ = 24						; size = 4
_gsfn_stage_two PROC					; COMDAT

; 3628 : { int stacktop;

	push	ebp
	mov	ebp, esp
	sub	esp, 492				; 000001ecH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, DWORD PTR _polylist$[ebp]

; 3647 :   for ( polyspot = 2 ; polyspot < polycount ; polyspot++ )

	mov	eax, DWORD PTR _f_id$[ebp]
	push	ebx
	mov	ebx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR _polycount$[ebp]
	xor	edx, edx
	mov	DWORD PTR _f_id$GSCopy$[ebp], eax
	mov	eax, DWORD PTR [ecx+esi*4-4]
	cmp	ebx, eax
	setg	dl
	push	edi
	mov	edi, DWORD PTR _glist$[ebp]
	mov	DWORD PTR _glist$GSCopy$[ebp], edi
	mov	DWORD PTR _polylist$GSCopy$[ebp], ecx
	mov	DWORD PTR tv420[ebp], ebx
	mov	DWORD PTR tv422[ebp], eax
	mov	DWORD PTR _pstartlow$[ebp], edx
	mov	edx, DWORD PTR _gcount$[ebp]
	test	edx, edx
	jle	SHORT $LN20@gsfn_stage

; 3637 :     glist[j].ecolor = glist[j].etype = 0;

	lea	eax, DWORD PTR [edi+120]
	npad	3
$LL22@gsfn_stage:
	xor	ebx, ebx
	mov	WORD PTR [eax+4], bx
	mov	DWORD PTR [eax], ebx
	add	eax, 144				; 00000090H
	dec	edx
	jne	SHORT $LL22@gsfn_stage

; 3629 :   int polyspot;
; 3630 :   int pstartlow = polylist[0] > polylist[polycount-1];
; 3631 :   struct graphdata gdata[3];
; 3632 :   int j;
; 3633 :   int stacksidelow,nextsidelow;
; 3634 :   int first = polylist[0],last = polylist[polycount-1];
; 3635 : 
; 3636 :   for ( j = 0 ; j < gcount ; j++ )

	mov	ebx, DWORD PTR tv420[ebp]
$LN20@gsfn_stage:

; 3638 : 
; 3639 :   // Stack-based algorithm.  Using polylist as stack space.
; 3640 :   // Vertices on stack will either be all on lower edge or
; 3641 :   // all on upper edge, forming a concave arc.
; 3642 :   stacktop = 1;  // begin with first two vertices on stack
; 3643 :   if ( pstartlow )

	cmp	DWORD PTR _pstartlow$[ebp], 0

; 3644 :     stacksidelow = ( (polylist[stacktop] > first) || (polylist[stacktop] < last) ); 

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, 1
	mov	DWORD PTR _stacktop$[ebp], edx
	je	SHORT $LN19@gsfn_stage
	cmp	eax, ebx
	jg	SHORT $LN25@gsfn_stage
	cmp	eax, DWORD PTR tv422[ebp]
	jl	SHORT $LN25@gsfn_stage
	xor	edx, edx
	mov	DWORD PTR _stacksidelow$[ebp], edx
	jmp	SHORT $LN28@gsfn_stage
$LN19@gsfn_stage:

; 3645 :   else
; 3646 :     stacksidelow = ( (polylist[stacktop] > first) && (polylist[stacktop] < last) ); 

	cmp	eax, ebx
	jle	SHORT $LN27@gsfn_stage
	cmp	eax, DWORD PTR tv422[ebp]
	jge	SHORT $LN27@gsfn_stage
$LN25@gsfn_stage:
	mov	DWORD PTR _stacksidelow$[ebp], edx
	jmp	SHORT $LN28@gsfn_stage
$LN27@gsfn_stage:
	mov	DWORD PTR _stacksidelow$[ebp], 0
	mov	edx, DWORD PTR _stacksidelow$[ebp]
$LN28@gsfn_stage:

; 3647 :   for ( polyspot = 2 ; polyspot < polycount ; polyspot++ )

	cmp	esi, 2
	jle	$LN15@gsfn_stage
	lea	ebx, DWORD PTR [ecx+8]
	add	esi, -2					; fffffffeH
	mov	DWORD PTR tv834[ebp], ebx
	mov	DWORD PTR tv183[ebp], esi
	jmp	SHORT $LN17@gsfn_stage
$LL54@gsfn_stage:
	mov	edx, DWORD PTR _stacksidelow$[ebp]
$LN17@gsfn_stage:

; 3648 :   { // See which side next vertex is on.
; 3649 :     if ( pstartlow )
; 3650 :       nextsidelow = ( (polylist[polyspot] > first) || (polylist[polyspot] < last) ); 

	mov	eax, DWORD PTR [ebx]
	xor	esi, esi
	cmp	DWORD PTR _pstartlow$[ebp], esi
	je	SHORT $LN14@gsfn_stage
	cmp	eax, DWORD PTR tv420[ebp]
	jg	SHORT $LN29@gsfn_stage
	cmp	eax, DWORD PTR tv422[ebp]
	jge	SHORT $LN31@gsfn_stage
$LN29@gsfn_stage:
	mov	DWORD PTR _nextsidelow$[ebp], 1

; 3651 :     else

	jmp	SHORT $LN32@gsfn_stage
$LN14@gsfn_stage:

; 3652 :       nextsidelow = ( (polylist[polyspot] > first) && (polylist[polyspot] < last) ); 

	cmp	eax, DWORD PTR tv420[ebp]
	jle	SHORT $LN31@gsfn_stage
	mov	DWORD PTR _nextsidelow$[ebp], 1
	cmp	eax, DWORD PTR tv422[ebp]
	jl	SHORT $LN32@gsfn_stage
$LN31@gsfn_stage:
	mov	DWORD PTR _nextsidelow$[ebp], esi
$LN32@gsfn_stage:

; 3653 :     if ( nextsidelow == stacksidelow ) 

	cmp	DWORD PTR _nextsidelow$[ebp], edx
	jne	$LN12@gsfn_stage

; 3654 :     { // Next vertex on same side as stack arc.  Cut off ears and push vertex.
; 3655 :       for ( j = stacktop-1 ; j >= 0 ; j-- )

	mov	edx, DWORD PTR _stacktop$[ebp]
	dec	edx
	mov	DWORD PTR _j$[ebp], edx
	cmp	edx, esi
	jl	SHORT $LN50@gsfn_stage
	npad	1
$LL11@gsfn_stage:

; 3656 :       { // Convexity check by sign of area of triangle 
; 3657 :         REAL *x1,*x2,*x3,area;
; 3658 :         x1 = glist[polylist[j]].X;

	mov	eax, DWORD PTR [ecx+edx*4]
	lea	esi, DWORD PTR [eax+eax*8]

; 3659 :         x2 = glist[polylist[j+1]].X;

	mov	eax, DWORD PTR [ecx+edx*4+4]
	lea	edx, DWORD PTR [eax+eax*8]

; 3660 :         x3 = glist[polylist[polyspot]].X;

	mov	eax, DWORD PTR [ebx]
	shl	edx, 4

; 3661 :         area = (x3[0]-x1[0])*(x2[1]-x1[1]) - (x3[1]-x1[1])*(x2[0]-x1[0]);

	fld	QWORD PTR [edx+edi+64]
	add	edx, edi
	lea	ebx, DWORD PTR [eax+eax*8]
	shl	esi, 4
	fsub	QWORD PTR [esi+edi+64]
	add	esi, edi
	shl	ebx, 4
	fld	QWORD PTR [ebx+edi+56]
	add	ebx, edi

; 3662 :         if ( (stacksidelow && (area < 0)) || (!stacksidelow && (area > 0)) )

	cmp	DWORD PTR _stacksidelow$[ebp], 0
	fsub	QWORD PTR [esi+56]
	fmulp	ST(1), ST(0)
	fld	QWORD PTR [ebx+64]
	fsub	QWORD PTR [esi+64]
	fld	QWORD PTR [edx+56]
	fsub	QWORD PTR [esi+56]
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	fldz
	fcompp
	fnstsw	ax
	je	SHORT $LN49@gsfn_stage
	test	ah, 65					; 00000041H
	je	SHORT $LN7@gsfn_stage
$LN53@gsfn_stage:

; 3654 :     { // Next vertex on same side as stack arc.  Cut off ears and push vertex.
; 3655 :       for ( j = stacktop-1 ; j >= 0 ; j-- )

	mov	edx, DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR tv834[ebp]
$LN50@gsfn_stage:

; 3670 :         }
; 3671 :         else
; 3672 :         { // no ear, so done.
; 3673 :           break;
; 3674 :         }
; 3675 :       }
; 3676 :       //  Adjust stack.
; 3677 :       stacktop = j+2;

	lea	eax, DWORD PTR [edx+2]

; 3678 :       polylist[stacktop] = polylist[polyspot];

	mov	edx, DWORD PTR [ebx]
	mov	DWORD PTR _stacktop$[ebp], eax
	mov	DWORD PTR [ecx+eax*4], edx

; 3679 :     }
; 3680 :     else

	jmp	$LN16@gsfn_stage
$LN49@gsfn_stage:

; 3662 :         if ( (stacksidelow && (area < 0)) || (!stacksidelow && (area > 0)) )

	test	ah, 5
	jp	SHORT $LN53@gsfn_stage
$LN7@gsfn_stage:

; 3663 :         { // ear 
; 3664 :           gdata[0] = glist[polylist[j]];
; 3665 :           gdata[stacksidelow ? 1 : 2] = glist[polylist[j+1]];

	mov	eax, DWORD PTR _stacksidelow$[ebp]
	neg	eax
	sbb	eax, eax
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata$[ebp]
	rep movsd
	lea	edi, DWORD PTR [eax+eax*8+18]
	add	edi, edi

; 3666 :           gdata[stacksidelow ? 2 : 1] = glist[polylist[polyspot]];

	xor	eax, eax
	cmp	DWORD PTR _stacksidelow$[ebp], eax
	lea	edi, DWORD PTR _gdata$[ebp+edi*8]
	setne	al
	mov	esi, edx

; 3667 :           gdata[0].color = get_facet_frontcolor(f_id);

	mov	edx, DWORD PTR _f_id$GSCopy$[ebp]
	mov	ecx, 36					; 00000024H
	rep movsd
	lea	edi, DWORD PTR [eax+eax*8+9]
	add	edi, edi
	lea	edi, DWORD PTR _gdata$[ebp+edi*8]
	mov	ecx, 36					; 00000024H
	mov	esi, ebx
	rep movsd
	mov	esi, DWORD PTR _web+236
	mov	ecx, edx
	mov	eax, edx
	and	ecx, 134217727				; 07ffffffH
	shr	eax, 27					; 0000001bH
	and	eax, 1
	lea	ecx, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR [ecx]
	je	SHORT $LN33@gsfn_stage
	movsx	esi, WORD PTR [esi+50]
	jmp	SHORT $LN58@gsfn_stage
$LN33@gsfn_stage:
	movsx	esi, WORD PTR [esi+48]
$LN58@gsfn_stage:
	mov	DWORD PTR _gdata$[ebp+104], esi

; 3668 :           gdata[0].backcolor = get_facet_backcolor(f_id);

	test	eax, eax
	mov	eax, DWORD PTR [ecx]
	je	SHORT $LN35@gsfn_stage
	movsx	ecx, WORD PTR [eax+48]
	jmp	SHORT $LN59@gsfn_stage
$LN35@gsfn_stage:
	movsx	ecx, WORD PTR [eax+50]
$LN59@gsfn_stage:

; 3669 :           option_facet(gdata,f_id); 

	push	edx
	lea	edx, DWORD PTR _gdata$[ebp]
	push	edx
	mov	DWORD PTR _gdata$[ebp+108], ecx
	call	_option_facet
	mov	ecx, DWORD PTR _polylist$GSCopy$[ebp]
	mov	edi, DWORD PTR _glist$GSCopy$[ebp]
	mov	ebx, DWORD PTR tv834[ebp]
	add	esp, 8
	dec	DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	jns	$LL11@gsfn_stage

; 3670 :         }
; 3671 :         else
; 3672 :         { // no ear, so done.
; 3673 :           break;
; 3674 :         }
; 3675 :       }
; 3676 :       //  Adjust stack.
; 3677 :       stacktop = j+2;

	lea	eax, DWORD PTR [edx+2]

; 3678 :       polylist[stacktop] = polylist[polyspot];

	mov	edx, DWORD PTR [ebx]
	mov	DWORD PTR _stacktop$[ebp], eax
	mov	DWORD PTR [ecx+eax*4], edx

; 3679 :     }
; 3680 :     else

	jmp	$LN16@gsfn_stage
$LN12@gsfn_stage:

; 3681 :     { // On opposite side, so can triangulate with all edges in arc.
; 3682 :       for ( j = 0 ; j < stacktop ; j++ )

	mov	DWORD PTR _j$[ebp], esi
	cmp	DWORD PTR _stacktop$[ebp], esi
	jle	$LN1@gsfn_stage

; 3684 :         gdata[stacksidelow ? 1 : 2] = glist[polylist[j+1]];

	mov	eax, edx
	neg	eax
	sbb	eax, eax
	lea	eax, DWORD PTR [eax+eax*8+18]
	add	eax, eax

; 3686 :         gdata[0].color = get_facet_frontcolor(f_id);

	lea	eax, DWORD PTR _gdata$[ebp+eax*8]
	mov	DWORD PTR tv505[ebp], eax
	xor	eax, eax
	cmp	edx, esi
	setne	al
	lea	edx, DWORD PTR [eax+eax*8+9]
	add	edx, edx
	lea	eax, DWORD PTR _gdata$[ebp+edx*8]
	mov	DWORD PTR tv511[ebp], eax
	mov	eax, DWORD PTR _f_id$GSCopy$[ebp]
	mov	edx, eax
	mov	ebx, eax
	and	edx, 134217727				; 07ffffffH
	shr	ebx, 27					; 0000001bH
	add	edx, edx
	and	ebx, 1
	add	edx, edx
	mov	DWORD PTR tv517[ebp], edx
	jmp	SHORT $LN3@gsfn_stage
	npad	1
$LL52@gsfn_stage:

; 3685 :         gdata[stacksidelow ? 2 : 1] = glist[polylist[polyspot]];

	mov	edx, DWORD PTR tv517[ebp]
$LN3@gsfn_stage:

; 3683 :       { gdata[0] = glist[polylist[j]];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	esi, DWORD PTR [ecx+ecx*8]
	shl	esi, 4
	add	esi, edi
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata$[ebp]
	rep movsd

; 3684 :         gdata[stacksidelow ? 1 : 2] = glist[polylist[j+1]];

	mov	ecx, DWORD PTR _polylist$GSCopy$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+4]
	mov	edi, DWORD PTR tv505[ebp]
	lea	esi, DWORD PTR [eax+eax*8]
	shl	esi, 4
	add	esi, DWORD PTR _glist$GSCopy$[ebp]
	mov	ecx, 36					; 00000024H
	rep movsd

; 3685 :         gdata[stacksidelow ? 2 : 1] = glist[polylist[polyspot]];

	mov	ecx, DWORD PTR tv834[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR tv511[ebp]
	lea	esi, DWORD PTR [eax+eax*8]

; 3686 :         gdata[0].color = get_facet_frontcolor(f_id);

	mov	eax, DWORD PTR _web+236
	shl	esi, 4
	add	esi, DWORD PTR _glist$GSCopy$[ebp]
	mov	ecx, 36					; 00000024H
	rep movsd
	mov	ecx, DWORD PTR [edx+eax]
	test	ebx, ebx
	je	SHORT $LN37@gsfn_stage
	movsx	ecx, WORD PTR [ecx+50]
	mov	DWORD PTR _gdata$[ebp+104], ecx

; 3687 :         gdata[0].backcolor = get_facet_backcolor(f_id);

	mov	edx, DWORD PTR [edx+eax]
	movsx	eax, WORD PTR [edx+48]
	mov	DWORD PTR _gdata$[ebp+108], eax
	jmp	SHORT $LN40@gsfn_stage
$LN37@gsfn_stage:

; 3686 :         gdata[0].color = get_facet_frontcolor(f_id);

	movsx	ecx, WORD PTR [ecx+48]
	mov	DWORD PTR _gdata$[ebp+104], ecx

; 3687 :         gdata[0].backcolor = get_facet_backcolor(f_id);

	mov	ecx, DWORD PTR [edx+eax]
	movsx	edx, WORD PTR [ecx+50]
	mov	DWORD PTR _gdata$[ebp+108], edx
$LN40@gsfn_stage:

; 3688 :         option_facet(gdata,f_id); 

	mov	eax, DWORD PTR _f_id$GSCopy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gdata$[ebp]
	push	ecx
	call	_option_facet
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _polylist$GSCopy$[ebp]
	mov	edi, DWORD PTR _glist$GSCopy$[ebp]
	inc	eax
	add	esp, 8
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _stacktop$[ebp]
	jl	$LL52@gsfn_stage

; 3681 :     { // On opposite side, so can triangulate with all edges in arc.
; 3682 :       for ( j = 0 ; j < stacktop ; j++ )

	mov	ebx, DWORD PTR tv834[ebp]
$LN1@gsfn_stage:

; 3689 :       }
; 3690 :       // update stack
; 3691 :       polylist[0] = polylist[stacktop];

	mov	edx, DWORD PTR _stacktop$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx], eax

; 3692 :       polylist[1] = polylist[polyspot];

	mov	edx, DWORD PTR [ebx]

; 3693 :       stacksidelow = nextsidelow;

	mov	eax, DWORD PTR _nextsidelow$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR _stacksidelow$[ebp], eax

; 3694 :       stacktop = 1;

	mov	DWORD PTR _stacktop$[ebp], 1
$LN16@gsfn_stage:

; 3647 :   for ( polyspot = 2 ; polyspot < polycount ; polyspot++ )

	add	ebx, 4
	dec	DWORD PTR tv183[ebp]
	mov	DWORD PTR tv834[ebp], ebx
	jne	$LL54@gsfn_stage
$LN15@gsfn_stage:

; 3695 :     }
; 3696 :   }
; 3697 : 
; 3698 : } // end gsfn_stage_two()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_gsfn_stage_two ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_plain_facets
EXTRN	_free_temp_matrix3:PROC
EXTRN	_lagrange_eval_2d:PROC
EXTRN	_bezier_eval_2d:PROC
EXTRN	_NULLEDGE:DWORD
EXTRN	_triple_prod:PROC
EXTRN	_get_edge_side:PROC
EXTRN	_ridge_color_flag:DWORD
EXTRN	_markedgedrawflag:DWORD
EXTRN	_get_facet_verts_special:PROC
EXTRN	_outerflag:DWORD
EXTRN	_innerflag:DWORD
EXTRN	_no_wall_flag:DWORD
EXTRN	_bdry_showflag:DWORD
EXTRN	_kb_temp_dmatrix3:PROC
; Function compile flags: /Ogtp
;	COMDAT _plain_facets
_TEXT	SEGMENT
_t$89823 = -968						; size = 16
_t$89833 = -952						; size = 16
_fattr$89654 = -936					; size = 8
tv2989 = -928						; size = 4
_flags$89817 = -928					; size = 4
_ctrlpts$ = -924					; size = 4
_verts$ = -920						; size = 4
_points$ = -916						; size = 4
tv3308 = -912						; size = 8
_eattr$89759 = -912					; size = 8
tv4972 = -908						; size = 4
tv3109 = -908						; size = 4
tv2693 = -908						; size = 4
_flags$89800 = -908					; size = 4
_x$89732 = -908						; size = 4
tv2749 = -904						; size = 4
_f_id$ = -900						; size = 4
tv4128 = -896						; size = 4
tv1039 = -896						; size = 4
tv828 = -896						; size = 4
_ii$ = -896						; size = 4
tv706 = -896						; size = 4
_fe$ = -896						; size = 4
_gorder$ = -892						; size = 4
_gdata$ = -888						; size = 4
tv5423 = -884						; size = 4
tv5184 = -884						; size = 4
tv5110 = -884						; size = 4
tv5082 = -884						; size = 4
tv2764 = -884						; size = 4
tv5427 = -880						; size = 4
tv3080 = -880						; size = 4
tv2804 = -880						; size = 4
tv2390 = -880						; size = 4
_b1_id$ = -880						; size = 4
tv2746 = -876						; size = 4
_jj$ = -876						; size = 4
_i$ = -876						; size = 4
_fe_id$ = -872						; size = 4
_j$ = -872						; size = 4
_b0_id$ = -872						; size = 4
_otherside$89787 = -868					; size = 144
_side$89786 = -724					; size = 144
_qdata$89818 = -580					; size = 576
_qdata$89799 = -580					; size = 576
__$ArrayPad$ = -4					; size = 4
_plain_facets PROC					; COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 968				; 000003c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 355  :   int i,j,ii,jj,k;
; 356  :   facetedge_id fe,fe_id;
; 357  :   edge_id e_id;
; 358  :   facet_id f_id;
; 359  :   body_id b0_id,b1_id;
; 360  :   REAL **verts; /* for adjusted triangle vertices */
; 361  :   struct graphdata *gdata;
; 362  :   int ctrlpts = web.skel[FACET].ctrlpts;

	mov	edi, DWORD PTR _web+232

; 363  :   int segs = 8;  /* for smooth_graph */
; 364  :   int to_alloc = ctrlpts+1 > ((segs+1)*(segs+2))/2+1  ?
; 365  :                  ctrlpts+1 : ((segs+1)*(segs+2))/2+1; 

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR _ctrlpts$[ebp], edi
	mov	DWORD PTR tv2693[ebp], eax
	cmp	eax, 46					; 0000002eH
	jg	SHORT $LN164@plain_face
	mov	eax, 46					; 0000002eH
$LN164@plain_face:

; 366  :   REAL ***points = NULL;
; 367  :   int gorder = 1; /* order actually used in graphing subfacets */
; 368  : 
; 369  :   gdata = (struct graphdata *)temp_calloc(to_alloc,sizeof(struct graphdata));

	push	369					; 00000171H
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	push	144					; 00000090H
	push	eax
	mov	DWORD PTR _points$[ebp], 0
	mov	DWORD PTR _gorder$[ebp], 1
	call	_kb_temp_calloc

; 370  :   verts = (REAL **)temp_calloc(ctrlpts,sizeof(REAL *));

	push	370					; 00000172H
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	mov	ebx, eax
	push	4
	push	edi
	mov	DWORD PTR _gdata$[ebp], ebx
	call	_kb_temp_calloc
	mov	esi, eax

; 371  :   if ( web.modeltype == LAGRANGE  )

	mov	eax, DWORD PTR _web+628
	add	esp, 32					; 00000020H
	mov	DWORD PTR _verts$[ebp], esi
	mov	ecx, 2
	cmp	eax, 3
	jne	SHORT $LN160@plain_face

; 372  :   { gorder = smooth_graph_flag ? segs : web.lagrange_order;

	cmp	DWORD PTR _smooth_graph_flag, 0
	lea	eax, DWORD PTR [ecx+6]
	jne	SHORT $LN469@plain_face
	mov	eax, DWORD PTR _web+632
$LN469@plain_face:

; 373  :     points = temp_dmatrix3(gorder+1,gorder+1,SDIM);

	mov	ecx, DWORD PTR _web+616
	push	373					; 00000175H
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	mov	DWORD PTR _gorder$[ebp], eax
	inc	eax
	push	ecx
	push	eax
	push	eax
	call	_kb_temp_dmatrix3
	mov	DWORD PTR _points$[ebp], eax
	add	esp, 20					; 00000014H

; 374  :     for ( i = 0 ; i < ctrlpts ; i++ ) 

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN470@plain_face

; 373  :     points = temp_dmatrix3(gorder+1,gorder+1,SDIM);

	mov	ecx, ebx
$LL159@plain_face:

; 375  :       verts[i] = gdata[i].x;

	mov	DWORD PTR [esi+eax*4], ecx
	inc	eax
	add	ecx, 144				; 00000090H
	cmp	eax, edi
	jl	SHORT $LL159@plain_face

; 376  :   }
; 377  :   else

	jmp	SHORT $LN404@plain_face
$LN160@plain_face:

; 380  :     { verts[2*i] = gdata[i].x;

	mov	DWORD PTR [esi], ebx
	cmp	eax, ecx
	jne	SHORT $LN154@plain_face

; 381  :       verts[2*i+1] = gdata[FACET_VERTS+i].x;  

	lea	edx, DWORD PTR [ebx+432]
	mov	DWORD PTR [esi+4], edx
$LN154@plain_face:

; 378  :   for ( i = 0 ; i < FACET_VERTS ; i++ ) 
; 379  :   { if ( web.modeltype == QUADRATIC ) /* mdpts after verts in gdata */

	lea	eax, DWORD PTR [ebx+144]
	cmp	DWORD PTR _web+628, ecx
	jne	SHORT $LN400@plain_face

; 381  :       verts[2*i+1] = gdata[FACET_VERTS+i].x;  

	lea	edx, DWORD PTR [ebx+576]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edx

; 382  :     }
; 383  :     else 

	jmp	SHORT $LN401@plain_face
$LN400@plain_face:

; 384  :       verts[i] = gdata[i].x;

	mov	DWORD PTR [esi+4], eax
$LN401@plain_face:

; 378  :   for ( i = 0 ; i < FACET_VERTS ; i++ ) 
; 379  :   { if ( web.modeltype == QUADRATIC ) /* mdpts after verts in gdata */

	cmp	DWORD PTR _web+628, ecx
	jne	SHORT $LN403@plain_face

; 380  :     { verts[2*i] = gdata[i].x;

	lea	ecx, DWORD PTR [ebx+288]

; 381  :       verts[2*i+1] = gdata[FACET_VERTS+i].x;  

	lea	edx, DWORD PTR [ebx+720]
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], edx

; 382  :     }
; 383  :     else 

	jmp	SHORT $LN404@plain_face
$LN403@plain_face:

; 384  :       verts[i] = gdata[i].x;

	lea	eax, DWORD PTR [ebx+288]
	mov	DWORD PTR [esi+8], eax
$LN404@plain_face:

; 385  :   } 
; 386  : 
; 387  :   for ( i = 0 ; i <= ctrlpts ; i++ ) 

	test	edi, edi
$LN470@plain_face:
	js	SHORT $LN445@plain_face
	mov	ecx, DWORD PTR tv2693[ebp]
	fld1
	lea	eax, DWORD PTR [ebx+24]
$LN150@plain_face:

; 388  :       gdata[i].x[3] = 1.0;  /* homogeneous coord */

	fst	QWORD PTR [eax]
	add	eax, 144				; 00000090H
	dec	ecx
	jne	SHORT $LN150@plain_face

; 385  :   } 
; 386  : 
; 387  :   for ( i = 0 ; i <= ctrlpts ; i++ ) 

	fstp	ST(0)
$LN445@plain_face:

; 389  :      
; 390  :   MFOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+272
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _f_id$[ebp], eax
	mov	DWORD PTR tv2746[ebp], ecx
	je	$LN363@plain_face
	jmp	SHORT $LN147@plain_face
$LL426@plain_face:
	mov	eax, DWORD PTR _f_id$[ebp]
$LN147@plain_face:
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2749[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+12]
	mov	eax, ecx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN146@plain_face

; 391  :   { 
; 392  :     int nbrs;  /* number of neighboring bodies */
; 393  :     ATTR fattr = get_fattr(f_id);

	mov	DWORD PTR _fattr$89654[ebp], ecx
	mov	DWORD PTR _fattr$89654[ebp+4], esi

; 394  :     if ( breakflag ) break;

	cmp	DWORD PTR _breakflag, edx
	jne	$LN436@plain_face

; 395  : 
; 396  :     #ifdef MPI_EVOLVER
; 397  :     if ( !mpi_show_corona_flag && (id_task(f_id) != this_task) )
; 398  :        continue;
; 399  :     #endif
; 400  : 
; 401  :     if ( (fattr & (BOUNDARY|CONSTRAINT)) && !bdry_showflag )

	mov	eax, ecx
	and	eax, 1152				; 00000480H
	or	eax, edx
	je	SHORT $LN141@plain_face
	cmp	DWORD PTR _bdry_showflag, edx
	je	$LN146@plain_face
$LN141@plain_face:

; 402  :         continue;
; 403  :     if ( fattr & NODISPLAY )

	mov	eax, ecx
	and	eax, 2
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN146@plain_face

; 404  :         continue;
; 405  :     gdata[0].color = get_facet_color_2(f_id);

	mov	edi, DWORD PTR _gdata$[ebp]
	mov	esi, DWORD PTR _f_id$[ebp]
	lea	ebx, DWORD PTR [edi+104]
	push	esi
	mov	DWORD PTR tv2764[ebp], ebx
	call	_get_facet_color_2

; 406  :     gdata[0].backcolor = get_facet_backcolor_2(f_id);

	push	esi
	mov	DWORD PTR [ebx], eax
	call	_get_facet_backcolor_2
	mov	DWORD PTR [edi+108], eax

; 407  :     if ( opacity_attr )

	mov	ecx, DWORD PTR _opacity_attr
	add	esp, 8
	test	ecx, ecx
	je	SHORT $LN427@plain_face

; 408  :       gdata[0].opacity = *(REAL*)(get_extra(f_id,opacity_attr));

	mov	eax, esi
	imul	ecx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	edx, ecx
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ecx+64]
	mov	ecx, DWORD PTR tv2749[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	fld	QWORD PTR [edx+eax]
	fstp	QWORD PTR [edi+112]
$LN427@plain_face:

; 409  : 
; 410  :     if ( no_wall_flag )

	cmp	DWORD PTR _no_wall_flag, 0
	mov	edx, DWORD PTR _dymem
	je	$LN428@plain_face

; 411  :     { /* skip facets with all three vertices on walls */
; 412  :       fe = get_facet_fe(f_id);

	cmp	DWORD PTR tv2746[ebp], 0
	jne	SHORT $LN206@plain_face
	xor	eax, eax
	jmp	SHORT $LN205@plain_face
$LN206@plain_face:
	mov	eax, DWORD PTR tv2749[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [ecx+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN205@plain_face
	xor	eax, 134217728				; 08000000H
$LN205@plain_face:

; 413  : 
; 414  :       if ( get_vattr(get_fe_headv(fe)) & (HIT_WALL|CONSTRAINT) )

	mov	esi, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	esi, eax
	mov	DWORD PTR tv2804[ebp], ecx
	mov	DWORD PTR _fe$[ebp], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR [ecx+edx+304]
	and	esi, 134217728				; 08000000H
	xor	eax, esi
	mov	esi, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN212@plain_face
	mov	ecx, DWORD PTR [edx+ecx]
	jmp	SHORT $LN211@plain_face
$LN212@plain_face:
	mov	edi, DWORD PTR _web+636
	lea	ecx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [ecx+edx]
$LN211@plain_face:
	mov	edi, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 9216				; 00002400H
	xor	ebx, ebx
	or	ecx, ebx
	je	$LN428@plain_face

; 415  :          if ( get_vattr(get_fe_tailv(fe)) & (HIT_WALL|CONSTRAINT) ) 

	test	eax, 134217728				; 08000000H
	je	SHORT $LN218@plain_face
	mov	ecx, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+edx]
	jmp	SHORT $LN217@plain_face
$LN218@plain_face:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [edx+ecx]
$LN217@plain_face:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 9216				; 00002400H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN428@plain_face

; 416  :           { fe = get_next_edge(fe);

	test	DWORD PTR _fe$[ebp], 134217728		; 08000000H
	je	SHORT $LN222@plain_face
	mov	eax, DWORD PTR tv2804[ebp]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN221@plain_face
$LN222@plain_face:
	mov	ecx, DWORD PTR tv2804[ebp]
	mov	eax, DWORD PTR [ecx+32]
$LN221@plain_face:

; 417  :             if ( get_vattr(get_fe_headv(fe)) & (HIT_WALL|CONSTRAINT) )

	mov	ebx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN228@plain_face
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [edx+eax]
	jmp	SHORT $LN227@plain_face
$LN228@plain_face:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR _web+636
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ecx+edx]
$LN227@plain_face:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 9216				; 00002400H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN146@plain_face
$LN428@plain_face:

; 418  :                continue;
; 419  :           }
; 420  :     }      
; 421  : 
; 422  :     if ( show_expr[FACET] && show_expr[FACET]->start )

	mov	eax, DWORD PTR _show_expr+8
	test	eax, eax
	je	SHORT $LN451@plain_face
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN451@plain_face

; 423  :     { 
; 424  :       if ( !eval(show_expr[FACET],NULL,f_id,NULL) ) 

	mov	ebx, DWORD PTR _f_id$[ebp]
	push	0
	push	ebx
	push	0
	push	eax
	call	_eval
	fldz
	fucompp
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN471@plain_face

; 425  :          gdata[0].color = gdata[0].backcolor = UNSHOWN; /* maybe do edges */

	mov	edx, DWORD PTR _gdata$[ebp]
	mov	eax, DWORD PTR tv2764[ebp]
	mov	DWORD PTR [edx+108], -3			; fffffffdH
	mov	DWORD PTR [eax], -3			; fffffffdH
	jmp	SHORT $LN471@plain_face
$LN451@plain_face:
	mov	ebx, DWORD PTR _f_id$[ebp]
$LN471@plain_face:

; 426  :     }
; 427  : 
; 428  :     nbrs =  (valid_id(get_facet_body(f_id)) ? 1 : 0) 
; 429  :             + (valid_id(get_facet_body(facet_inverse(f_id))) ? 1 : 0);

	mov	ecx, DWORD PTR _web+400
	mov	edi, DWORD PTR _dymem
	mov	esi, DWORD PTR _web+328
	test	ecx, ecx
	jne	SHORT $LN234@plain_face
	xor	edx, edx
	jmp	SHORT $LN231@plain_face
$LN234@plain_face:
	cmp	DWORD PTR tv2746[ebp], 0
	jne	SHORT $LN233@plain_face
	xor	edx, edx
	jmp	SHORT $LN231@plain_face
$LN233@plain_face:
	mov	eax, DWORD PTR _web+236
	mov	edx, DWORD PTR tv2749[ebp]
	mov	edx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [esi+edi+784]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN232@plain_face
	mov	edx, DWORD PTR [edx+eax+4]
	jmp	SHORT $LN231@plain_face
$LN232@plain_face:
	mov	edx, DWORD PTR [edx+eax]
$LN231@plain_face:
	mov	eax, ebx
	xor	eax, 134217728				; 08000000H
	test	ecx, ecx
	je	SHORT $LN237@plain_face
$LN240@plain_face:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN239@plain_face
	xor	ecx, ecx
	jmp	SHORT $LN237@plain_face
$LN239@plain_face:
	mov	ebx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR [esi+edi+784]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN238@plain_face
	mov	ecx, DWORD PTR [ecx+ebx+4]
	jmp	SHORT $LN237@plain_face
$LN238@plain_face:
	mov	ecx, DWORD PTR [ecx+ebx]
$LN237@plain_face:
	shr	ecx, 28					; 0000001cH
	shr	edx, 28					; 0000001cH
	and	ecx, 1
	and	edx, 1
	add	ecx, edx

; 430  :     if ( (nbrs >= 2) && !innerflag ) continue;

	cmp	ecx, 2
	jl	SHORT $LN413@plain_face
	cmp	DWORD PTR _innerflag, 0

; 431  :     if ( (nbrs < 2) && !outerflag ) continue;

	jmp	SHORT $LN472@plain_face
$LN413@plain_face:
	cmp	DWORD PTR _outerflag, 0
$LN472@plain_face:
	je	$LN146@plain_face

; 432  :     if ( colorflag ) /* get vertex color */

	xor	ecx, ecx
	cmp	DWORD PTR _colorflag, ecx
	je	$LN431@plain_face

; 433  :     { 
; 434  :       b0_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, ecx
	jne	SHORT $LN246@plain_face
	mov	DWORD PTR _b0_id$[ebp], ecx
	jmp	SHORT $LN243@plain_face
$LN246@plain_face:
	cmp	DWORD PTR tv2746[ebp], ecx
	jne	SHORT $LN245@plain_face
	mov	DWORD PTR _b0_id$[ebp], ecx
	jmp	SHORT $LN243@plain_face
$LN245@plain_face:
	test	DWORD PTR _f_id$[ebp], 134217728	; 08000000H
	mov	ebx, DWORD PTR _web+236
	mov	edx, DWORD PTR tv2749[ebp]
	mov	edx, DWORD PTR [edx+ebx]
	mov	ebx, DWORD PTR [esi+edi+784]
	je	SHORT $LN244@plain_face
	mov	edx, DWORD PTR [edx+ebx+4]
	jmp	SHORT $LN473@plain_face
$LN244@plain_face:
	mov	edx, DWORD PTR [edx+ebx]
$LN473@plain_face:
	mov	DWORD PTR _b0_id$[ebp], edx
$LN243@plain_face:

; 435  :       b1_id = get_facet_body(facet_inverse(f_id));

	cmp	DWORD PTR _web+400, ecx
	jne	SHORT $LN252@plain_face
	mov	DWORD PTR _b1_id$[ebp], ecx
	jmp	SHORT $LN249@plain_face
$LN252@plain_face:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN251@plain_face
	mov	DWORD PTR _b1_id$[ebp], ecx
	jmp	SHORT $LN249@plain_face
$LN251@plain_face:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN250@plain_face
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [esi+edi+784]
	mov	ecx, DWORD PTR [edx+eax+4]
	mov	DWORD PTR _b1_id$[ebp], ecx
	jmp	SHORT $LN249@plain_face
$LN250@plain_face:
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [esi+edi+784]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _b1_id$[ebp], edx
$LN249@plain_face:

; 436  :       for ( i = 0 ; i < ctrlpts ; i++ )    /* vertex loop */

	mov	edi, DWORD PTR _ctrlpts$[ebp]
	test	edi, edi
	jle	$LN127@plain_face
	mov	ebx, DWORD PTR _b0_id$[ebp]
	mov	edi, DWORD PTR _b1_id$[ebp]
	mov	eax, DWORD PTR _ctrlpts$[ebp]
	mov	esi, DWORD PTR tv2764[ebp]
	shr	ebx, 28					; 0000001cH
	shr	edi, 28					; 0000001cH
	and	ebx, 1
	and	edi, 1
	mov	DWORD PTR tv1039[ebp], eax
$LL453@plain_face:

; 437  :       { if ( valid_id(b0_id) ) 

	test	ebx, ebx
	je	SHORT $LN126@plain_face

; 438  :          gdata[i].backcolor = 
; 439  :            (facet_rgb_color_attr > 0 )? INDEX_TO_RGBA(loc_ordinal(b0_id)) : 
; 440  :                  loc_ordinal(b0_id);

	cmp	DWORD PTR _facet_rgb_color_attr, 0
	jle	SHORT $LN171@plain_face
	mov	ecx, DWORD PTR _b0_id$[ebp]
	and	ecx, 134217727				; 07ffffffH
	push	ecx
	call	_INDEX_TO_RGBA
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	jmp	SHORT $LN125@plain_face
$LN171@plain_face:
	mov	eax, DWORD PTR _b0_id$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR [esi+4], eax
	jmp	SHORT $LN125@plain_face
$LN126@plain_face:

; 441  :         else  gdata[i].backcolor = 0;

	mov	DWORD PTR [esi+4], 0
$LN125@plain_face:

; 442  :         if ( valid_id(b1_id) ) 

	test	edi, edi
	je	SHORT $LN124@plain_face

; 443  :           gdata[i].color =
; 444  :            ( facet_rgb_color_attr > 0 ) ? INDEX_TO_RGBA(loc_ordinal(b1_id)): 
; 445  :                 loc_ordinal(b1_id);

	cmp	DWORD PTR _facet_rgb_color_attr, 0
	jle	SHORT $LN177@plain_face
	mov	edx, DWORD PTR _b1_id$[ebp]
	and	edx, 134217727				; 07ffffffH
	push	edx
	call	_INDEX_TO_RGBA
	add	esp, 4
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LN128@plain_face
$LN177@plain_face:
	mov	eax, DWORD PTR _b1_id$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LN128@plain_face
$LN124@plain_face:

; 446  :         else  gdata[i].color = 0;

	mov	DWORD PTR [esi], 0
$LN128@plain_face:

; 436  :       for ( i = 0 ; i < ctrlpts ; i++ )    /* vertex loop */

	add	esi, 144				; 00000090H
	dec	DWORD PTR tv1039[ebp]
	jne	$LL453@plain_face
$LN431@plain_face:
	mov	edi, DWORD PTR _ctrlpts$[ebp]
$LN127@plain_face:

; 447  :       }
; 448  :     }
; 449  :     /* get vertices; verts is list of gdata.x pointers */
; 450  :     if ( labelflag != 0 ) get_facet_verts(f_id,verts,NULL);

	cmp	DWORD PTR _labelflag, 0
	mov	esi, DWORD PTR _f_id$[ebp]
	push	0
	je	SHORT $LN122@plain_face
	mov	eax, DWORD PTR _verts$[ebp]
	push	eax
	push	esi
	call	_get_facet_verts
	jmp	SHORT $LN474@plain_face
$LN122@plain_face:

; 451  :     else get_facet_verts_special(f_id,verts,NULL);

	mov	ecx, DWORD PTR _verts$[ebp]
	push	ecx
	push	esi
	call	_get_facet_verts_special
$LN474@plain_face:

; 452  :     if ( web.modeltype == LAGRANGE )

	mov	eax, 3
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+628, eax
	jne	SHORT $LN120@plain_face

; 453  :     { vertex_id *v = get_facet_vertices(f_id);

	mov	edx, DWORD PTR tv2749[ebp]
	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+328
	add	ecx, DWORD PTR [edx+eax+304]

; 454  :       for ( i = 0 ; i < ctrlpts ; i++ ) gdata[i].v_id = v[i];

	xor	eax, eax
	test	edi, edi
	jle	$LN415@plain_face

; 453  :     { vertex_id *v = get_facet_vertices(f_id);

	mov	edx, DWORD PTR _gdata$[ebp]
	add	edx, 132				; 00000084H
	npad	5
$LL119@plain_face:

; 454  :       for ( i = 0 ; i < ctrlpts ; i++ ) gdata[i].v_id = v[i];

	mov	esi, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx], esi
	inc	eax
	add	edx, 144				; 00000090H
	cmp	eax, edi
	jl	SHORT $LL119@plain_face

; 455  :     }
; 456  :     else 

	jmp	$LN415@plain_face
$LN120@plain_face:

; 457  :     { fe = get_facet_fe(f_id);

	cmp	DWORD PTR tv2746[ebp], 0
	jne	SHORT $LN256@plain_face
	xor	edx, edx
	jmp	SHORT $LN255@plain_face
$LN256@plain_face:
	mov	edx, DWORD PTR tv2749[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR [ecx+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN255@plain_face
	xor	edx, 134217728				; 08000000H
$LN255@plain_face:

; 458  :       for ( i = 0 ; i < FACET_VERTS ; i++, fe = get_next_edge(fe) )

	mov	esi, DWORD PTR _gdata$[ebp]
	mov	ebx, DWORD PTR _web+460
	add	esi, 132				; 00000084H
	mov	DWORD PTR tv4128[ebp], esi
	mov	DWORD PTR tv2390[ebp], eax
$LL259@plain_face:

; 459  :       { e_id = get_fe_edge(fe);

	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+ebx]
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]

; 460  :         if ( web.modeltype == LINEAR ) gdata[i].v_id = get_edge_tailv(e_id);

	cmp	DWORD PTR _web+628, 1
	jne	SHORT $LN112@plain_face
	mov	edi, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	test	eax, 134217728				; 08000000H
	je	SHORT $LN266@plain_face
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	add	eax, DWORD PTR [edi+ebx+304]
	mov	edi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi], eax
	jmp	$LN475@plain_face
$LN266@plain_face:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	mov	edi, DWORD PTR [edi+ebx+304]
	mov	eax, DWORD PTR [eax+edi]
	mov	DWORD PTR [esi], eax
	jmp	$LN475@plain_face
$LN112@plain_face:

; 461  :         else if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	$LN114@plain_face

; 462  :         { gdata[i].v_id = get_edge_tailv(e_id);

	mov	esi, DWORD PTR _web+124
	mov	edi, DWORD PTR _web+216
	mov	ebx, DWORD PTR _dymem
	test	eax, 134217728				; 08000000H
	je	SHORT $LN270@plain_face
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	esi, DWORD PTR [eax+esi]
	add	esi, DWORD PTR [edi+ebx+304]
	mov	edi, DWORD PTR _web+636
	mov	edi, DWORD PTR [esi+edi*4]
	jmp	SHORT $LN269@plain_face
$LN270@plain_face:
	mov	edi, DWORD PTR [edi+ebx+304]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	esi, DWORD PTR [eax+esi]
	mov	edi, DWORD PTR [esi+edi]
$LN269@plain_face:
	mov	esi, DWORD PTR tv4128[ebp]
	mov	DWORD PTR [esi], edi

; 463  :           gdata[FACET_VERTS+i].v_id = get_edge_midv(e_id); 

	mov	edi, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+edi]
	mov	edi, DWORD PTR _web+216
	mov	ebx, DWORD PTR _dymem
	mov	edi, DWORD PTR [edi+ebx+304]
	mov	eax, DWORD PTR [eax+edi+8]
	mov	DWORD PTR [esi+432], eax
$LN475@plain_face:
	mov	ebx, DWORD PTR _web+460
$LN114@plain_face:

; 458  :       for ( i = 0 ; i < FACET_VERTS ; i++, fe = get_next_edge(fe) )

	add	esi, 144				; 00000090H
	mov	DWORD PTR tv4128[ebp], esi
	test	edx, 134217728				; 08000000H
	je	SHORT $LN260@plain_face
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	edx, DWORD PTR [ecx+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN369@plain_face
$LN260@plain_face:
	mov	edx, DWORD PTR [ecx+ebx]
	mov	edx, DWORD PTR [edx+32]
$LN369@plain_face:
	dec	DWORD PTR tv2390[ebp]
	jne	$LL259@plain_face
	mov	edi, DWORD PTR _ctrlpts$[ebp]
$LN415@plain_face:

; 464  :         }
; 465  :       }
; 466  :     }
; 467  :     /* do inner clipping, if called for */
; 468  :     if ( inner_clip_flag )

	cmp	DWORD PTR _inner_clip_flag, 0
	mov	ebx, DWORD PTR _web+616
	je	$LN101@plain_face

; 469  :     { 
; 470  :       for ( i = 0 ; i < ctrlpts ; i++ )

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN446@plain_face
	mov	eax, DWORD PTR _web+976

; 471  :       { REAL dist = 0.0;
; 472  :         REAL *x = get_coord(web.zoom_v);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]

; 480  :     }
; 481  :   
; 482  :     if ( gdata[0].color != gdata[0].backcolor )

	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+64]

; 486  :          vnormal(gdata[0].x,gdata[web.lagrange_order].x,gdata[ctrlpts-1].x,
; 487  :                    gdata[0].norm);

	mov	DWORD PTR _x$89732[ebp], eax
$LL108@plain_face:

; 473  : 
; 474  :         for ( j = 0 ; j < SDIM ; j++ )

	fldz
	test	ebx, ebx
	jle	SHORT $LN103@plain_face

; 469  :     { 
; 470  :       for ( i = 0 ; i < ctrlpts ; i++ )

	mov	edx, DWORD PTR _verts$[ebp]
	mov	eax, DWORD PTR [edx+esi*4]

; 473  : 
; 474  :         for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _x$89732[ebp]
	sub	ecx, eax
	mov	edx, ebx
$LN105@plain_face:

; 475  :            dist += (x[j]-verts[i][j])*(x[j]-verts[i][j]);

	fld	QWORD PTR [eax+ecx]
	add	eax, 8
	dec	edx
	fsub	QWORD PTR [eax-8]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LN105@plain_face
$LN103@plain_face:

; 476  : 
; 477  :         if ( sqrt(dist) > inner_clip_rad ) break; /* it's a keeper */

	call	__CIsqrt
	fcomp	QWORD PTR _inner_clip_rad
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN446@plain_face

; 469  :     { 
; 470  :       for ( i = 0 ; i < ctrlpts ; i++ )

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL108@plain_face
$LN446@plain_face:

; 478  :       }
; 479  :       if ( i == ctrlpts ) continue; /* entirely inside */

	cmp	esi, edi
	je	$LN146@plain_face
	mov	edi, DWORD PTR _ctrlpts$[ebp]
$LN101@plain_face:

; 480  :     }
; 481  :   
; 482  :     if ( gdata[0].color != gdata[0].backcolor )

	mov	eax, DWORD PTR tv2764[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _gdata$[ebp]
	cmp	ecx, DWORD PTR [edx+108]
	je	$LN94@plain_face

; 483  :     { /* need normal for separation */ 
; 484  :       REAL dd;
; 485  :       if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	jne	SHORT $LN99@plain_face

; 486  :          vnormal(gdata[0].x,gdata[web.lagrange_order].x,gdata[ctrlpts-1].x,
; 487  :                    gdata[0].norm);

	mov	ecx, edx
	lea	eax, DWORD PTR [edi+edi*8]
	add	eax, eax
	lea	edx, DWORD PTR [ecx+eax*8-144]
	mov	eax, DWORD PTR _web+632
	lea	eax, DWORD PTR [eax+eax*8]
	lea	esi, DWORD PTR [ecx+56]
	push	esi
	shl	eax, 4
	push	edx
	add	eax, ecx
	push	eax
	push	ecx
	jmp	SHORT $LN476@plain_face
$LN99@plain_face:

; 488  :       else vnormal(gdata[0].x,gdata[1].x,gdata[2].x,gdata[0].norm);

	mov	eax, DWORD PTR _gdata$[ebp]
	lea	esi, DWORD PTR [eax+56]
	push	esi
	lea	ecx, DWORD PTR [eax+288]
	push	ecx
	lea	edx, DWORD PTR [eax+144]
	push	edx
	push	eax
$LN476@plain_face:
	call	_vnormal

; 489  :       dd = sqrt(SDIM_dot(gdata[0].norm,gdata[0].norm));

	mov	eax, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	push	eax
	push	esi
	push	esi
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 490  :       if ( dd > 0.0 )

	fldz

; 491  :          for ( i = 0 ; i < SDIM ; i++ )

	mov	ebx, DWORD PTR _web+616
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN461@plain_face
	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN461@plain_face
	mov	eax, esi
$LN96@plain_face:

; 492  :            gdata[0].norm[i] /= dd;

	fld	QWORD PTR [eax]
	inc	ecx
	fdiv	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ebx, DWORD PTR _web+616
	cmp	ecx, ebx
	jl	SHORT $LN96@plain_face
$LN461@plain_face:

; 490  :       if ( dd > 0.0 )

	fstp	ST(0)
$LN94@plain_face:

; 493  :     }
; 494  :     if ( normflag || thickenflag ) 

	cmp	DWORD PTR _normflag, 0
	jne	SHORT $LN447@plain_face
	cmp	DWORD PTR _thickenflag, 0
	je	$LN89@plain_face
$LN447@plain_face:

; 495  :     {
; 496  :       fe = get_facet_fe(f_id);

	cmp	DWORD PTR tv2746[ebp], 0
	jne	SHORT $LN274@plain_face
	xor	ebx, ebx
	jmp	SHORT $LN273@plain_face
$LN274@plain_face:
	test	DWORD PTR _f_id$[ebp], 134217728	; 08000000H
	mov	ecx, DWORD PTR tv2749[ebp]
	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ecx+edx]
	mov	ebx, DWORD PTR [eax+28]
	je	SHORT $LN273@plain_face
	xor	ebx, 134217728				; 08000000H
$LN273@plain_face:

; 497  :       for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	edi, DWORD PTR _gdata$[ebp]
	mov	eax, DWORD PTR _web+460
	add	edi, 56					; 00000038H
	mov	DWORD PTR tv828[ebp], 3
	npad	6
$LL418@plain_face:
	mov	ecx, DWORD PTR _dymem

; 498  :       { calc_vertex_smooth_normal(get_fe_tailv(fe),fe,gdata[i].norm);

	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+eax]
	mov	eax, ebx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN280@plain_face
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	add	eax, DWORD PTR [edx+ecx+304]
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN279@plain_face
$LN280@plain_face:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [edx+ecx+304]
	mov	eax, DWORD PTR [eax+ecx]
$LN279@plain_face:
	push	edi
	push	ebx
	push	eax
	call	_calc_vertex_smooth_normal

; 499  :         fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	add	esp, 12					; 0000000cH
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN284@plain_face
	mov	edx, DWORD PTR [esi+eax]
	mov	ebx, DWORD PTR [edx+28]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN90@plain_face
$LN284@plain_face:
	mov	ecx, DWORD PTR [esi+eax]
	mov	ebx, DWORD PTR [ecx+32]
$LN90@plain_face:

; 497  :       for ( i = 0 ; i < FACET_VERTS ; i++ )

	add	edi, 144				; 00000090H
	dec	DWORD PTR tv828[ebp]
	jne	$LL418@plain_face
	mov	ebx, DWORD PTR _web+616
$LN89@plain_face:

; 500  :       }
; 501  :     }
; 502  :     /* check for special edges */
; 503  :     fe_id = get_facet_fe(f_id);

	cmp	DWORD PTR tv2746[ebp], 0
	jne	SHORT $LN288@plain_face
	mov	DWORD PTR _fe_id$[ebp], 0
	jmp	SHORT $LN289@plain_face
$LN288@plain_face:
	test	DWORD PTR _f_id$[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR tv2749[ebp]
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [ecx+28]
	je	SHORT $LN287@plain_face
	xor	eax, 134217728				; 08000000H
$LN287@plain_face:
	mov	DWORD PTR _fe_id$[ebp], eax
$LN289@plain_face:

; 504  :     if ( web.representation != SIMPLEX )

	mov	eax, 3
	cmp	DWORD PTR _web+624, eax
	je	$LN432@plain_face

; 505  :      for ( i = 0 ; i < 3 ; i++, fe_id = get_next_edge(fe_id) )

	mov	esi, DWORD PTR _gdata$[ebp]
	add	esi, 124				; 0000007cH
	mov	DWORD PTR tv706[ebp], eax
	npad	10
$LL291@plain_face:

; 506  :      { ATTR eattr;
; 507  :        gdata[i].etype = INVISIBLE_EDGE; /* default */
; 508  :        e_id = get_fe_edge(fe_id);

	mov	ebx, DWORD PTR _fe_id$[ebp]
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	xor	edx, edx
	mov	WORD PTR [esi], dx
	mov	eax, DWORD PTR _web+460
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [eax+edi]
	and	ebx, 134217728				; 08000000H
	xor	ebx, DWORD PTR [ecx+20]
	mov	DWORD PTR tv3080[ebp], edi

; 509  :        if ( inverted(e_id) ) gdata[i].etype |= LABEL_REVERSED;

	test	ebx, 134217728				; 08000000H
	je	SHORT $LN84@plain_face
	mov	edx, 16384				; 00004000H
	mov	WORD PTR [esi], dx
$LN84@plain_face:

; 510  :        gdata[i].ecolor = get_edge_color_2(e_id);

	push	ebx
	call	_get_edge_color_2
	mov	DWORD PTR [esi-4], eax

; 511  :        gdata[i].id = e_id;
; 512  :        eattr = get_eattr(e_id);

	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR [esi+4], ebx
	mov	ecx, DWORD PTR _web+124
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv2989[ebp], eax
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 4

; 513  :        if ( markedgedrawflag )

	cmp	DWORD PTR _markedgedrawflag, 0
	mov	DWORD PTR _eattr$89759[ebp+4], eax
	je	SHORT $LN82@plain_face

; 514  :        { if ( eattr & EDGE_DRAWN ) continue; }             

	mov	eax, edx
	xor	edi, edi
	and	eax, 67108864				; 04000000H
	or	eax, edi
	mov	edi, DWORD PTR tv3080[ebp]
	jne	$LN86@plain_face
$LN82@plain_face:

; 515  :              
; 516  :        if ( get_edge_color(e_id) == CLEAR ) continue;

	cmp	WORD PTR [ecx+56], -1
	je	$LN86@plain_face

; 517  :        if ( eattr & BOUNDARY ) gdata[i].etype |= BOUNDARY_EDGE;

	mov	eax, edx
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN80@plain_face
	or	WORD PTR [esi], 8
$LN80@plain_face:

; 518  :        if ( equal_id(get_next_facet(fe_id),fe_id) ) /* valence 1 */

	mov	eax, DWORD PTR _fe_id$[ebp]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv3109[ebp], eax
	je	SHORT $LN298@plain_face
	mov	ecx, DWORD PTR _web+460
	mov	eax, DWORD PTR [ecx+edi]
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN297@plain_face
$LN298@plain_face:
	mov	eax, DWORD PTR _web+460
	mov	eax, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [eax+40]
$LN297@plain_face:
	cmp	ecx, DWORD PTR _fe_id$[ebp]
	jne	SHORT $LN79@plain_face

; 519  :           gdata[i].etype |= SINGLE_EDGE;

	or	WORD PTR [esi], 4
	jmp	SHORT $LN439@plain_face
$LN79@plain_face:

; 520  :        else if  ( !equal_id(get_next_facet(fe_id),get_prev_facet(fe_id)) )

	mov	edi, DWORD PTR tv3109[ebp]
	test	edi, edi
	je	SHORT $LN302@plain_face
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN301@plain_face
$LN302@plain_face:
	mov	ecx, DWORD PTR [eax+40]
$LN301@plain_face:
	test	edi, edi
	je	SHORT $LN306@plain_face
	mov	eax, DWORD PTR [eax+40]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN305@plain_face
$LN306@plain_face:
	mov	eax, DWORD PTR [eax+36]
$LN305@plain_face:
	cmp	ecx, eax
	je	SHORT $LN439@plain_face

; 521  :           gdata[i].etype |= TRIPLE_EDGE; /* triple line at least */

	or	WORD PTR [esi], 2
$LN439@plain_face:

; 522  :        if ( (eattr & HIT_WALL) && !(fattr & CONSTRAINT) )

	mov	eax, edx
	and	eax, 8192				; 00002000H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN76@plain_face
	mov	eax, DWORD PTR _fattr$89654[ebp]
	and	eax, 1024				; 00000400H
	or	eax, ecx
	jne	SHORT $LN76@plain_face

; 523  :           gdata[i].etype |= CONSTRAINT_EDGE;

	or	WORD PTR [esi], 32			; 00000020H
$LN76@plain_face:

; 524  :        if ( (eattr & FIXED)  )

	and	edx, 64					; 00000040H
	mov	eax, edx
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN75@plain_face

; 525  :           gdata[i].etype |= FIXED_EDGE;

	or	WORD PTR [esi], 16			; 00000010H
$LN75@plain_face:

; 526  :        if ( show_expr[EDGE] && show_expr[EDGE]->start )

	mov	eax, DWORD PTR _show_expr+4
	test	eax, eax
	je	SHORT $LN440@plain_face
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN440@plain_face

; 527  :        { if ( eval(show_expr[EDGE],NULL,e_id,NULL) ) 

	push	0
	push	ebx
	push	0
	push	eax
	call	_eval
	fldz
	fucompp
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN73@plain_face

; 528  :             gdata[i].etype |= REGULAR_EDGE;

	or	WORD PTR [esi], 1
	jmp	SHORT $LN440@plain_face
$LN73@plain_face:

; 529  :          else gdata[i].etype &= (~EBITS) | INVISIBLE_EDGE;

	mov	ecx, -768				; fffffd00H
	and	WORD PTR [esi], cx
$LN440@plain_face:

; 530  :        }
; 531  :        if ( markedgedrawflag && ((gdata[i].etype & EBITS) != INVISIBLE_EDGE) )

	cmp	DWORD PTR _markedgedrawflag, 0
	je	SHORT $LN442@plain_face
	mov	edx, 767				; 000002ffH
	test	WORD PTR [esi], dx
	je	SHORT $LN442@plain_face

; 532  :          set_attr(e_id,EDGE_DRAWN);

	mov	ecx, DWORD PTR tv2989[ebp]
	shr	ebx, 29					; 0000001dH
	imul	ebx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ebx+12]
	mov	eax, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 67108864		; 04000000H
	mov	DWORD PTR [eax+12], edx
$LN442@plain_face:
	mov	edi, DWORD PTR tv3080[ebp]
$LN86@plain_face:

; 505  :      for ( i = 0 ; i < 3 ; i++, fe_id = get_next_edge(fe_id) )

	add	esi, 144				; 00000090H
	test	DWORD PTR _fe_id$[ebp], 134217728	; 08000000H
	je	SHORT $LN292@plain_face
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [eax+edi]
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _fe_id$[ebp], eax
	jmp	SHORT $LN374@plain_face
$LN292@plain_face:
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [edx+edi]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _fe_id$[ebp], ecx
$LN374@plain_face:
	dec	DWORD PTR tv706[ebp]
	jne	$LL291@plain_face
	mov	ebx, DWORD PTR _web+616
$LN432@plain_face:

; 533  :      }
; 534  : 
; 535  :     if ( ridge_color_flag )

	cmp	DWORD PTR _ridge_color_flag, 0
	je	$LN448@plain_face

; 536  :     {
; 537  :       REAL side[FACET_EDGES][MAXCOORD];
; 538  :       REAL otherside[FACET_EDGES][MAXCOORD];
; 539  :             
; 540  :       fe = get_facet_fe(f_id);

	cmp	DWORD PTR tv2746[ebp], 0
	jne	SHORT $LN312@plain_face
	xor	esi, esi
	jmp	SHORT $LN311@plain_face
$LN312@plain_face:
	test	DWORD PTR _f_id$[ebp], 134217728	; 08000000H
	mov	edx, DWORD PTR tv2749[ebp]
	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [edx+eax]
	mov	esi, DWORD PTR [ecx+28]
	je	SHORT $LN311@plain_face
	xor	esi, 134217728				; 08000000H
$LN311@plain_face:

; 541  :       for ( i = 0 ; i < FACET_EDGES ; i++ )

	mov	eax, DWORD PTR _web+460
	xor	edi, edi
$LL69@plain_face:

; 542  :       { get_fe_side(fe,side[i]);

	mov	ebx, esi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	eax, DWORD PTR [ebx+eax]
	mov	ecx, esi
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [eax+20]
	lea	edx, DWORD PTR _side$89786[ebp+edi]
	push	edx
	push	ecx
	call	_get_edge_side

; 543  :         get_fe_side(get_next_edge(get_next_facet(fe)),otherside[i]);

	mov	ecx, DWORD PTR _web+460
	shr	esi, 27					; 0000001bH
	add	esp, 8
	and	esi, 1
	je	SHORT $LN318@plain_face
	mov	edx, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN317@plain_face
$LN318@plain_face:
	mov	eax, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [eax+40]
$LN317@plain_face:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN322@plain_face
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN321@plain_face
$LN322@plain_face:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+32]
$LN321@plain_face:
	lea	edx, DWORD PTR _otherside$89787[ebp+edi]
	push	edx
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	push	eax
	call	_get_edge_side

; 544  :         fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	add	esp, 8
	test	esi, esi
	je	SHORT $LN328@plain_face
	mov	edx, DWORD PTR [ebx+eax]
	mov	esi, DWORD PTR [edx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN68@plain_face
$LN328@plain_face:
	mov	ecx, DWORD PTR [ebx+eax]
	mov	esi, DWORD PTR [ecx+32]
$LN68@plain_face:

; 541  :       for ( i = 0 ; i < FACET_EDGES ; i++ )

	add	edi, 48					; 00000030H
	cmp	edi, 144				; 00000090H
	jl	$LL69@plain_face

; 545  :       }
; 546  :       for ( i = 0 ; i < FACET_EDGES ; i++ )

	mov	ebx, DWORD PTR _gdata$[ebp]
	xor	eax, eax
	add	ebx, 120				; 00000078H
	xor	esi, esi
	npad	2
$LL66@plain_face:

; 547  :        if ( triple_prod(side[i],side[(i+1)%FACET_EDGES],otherside[i]) < 0.0 )

	lea	edi, DWORD PTR [eax+1]
	lea	edx, DWORD PTR _otherside$89787[ebp+esi]
	push	edx
	mov	eax, edi
	cdq
	mov	ecx, 3
	idiv	ecx
	lea	ecx, DWORD PTR _side$89786[ebp+esi]
	lea	edx, DWORD PTR [edx+edx*2]
	add	edx, edx
	lea	eax, DWORD PTR _side$89786[ebp+edx*8]
	push	eax
	push	ecx
	call	_triple_prod
	fcomp	QWORD PTR __real@0000000000000000
	add	esp, 12					; 0000000cH
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN63@plain_face

; 548  :          gdata[i].ecolor = 
; 549  :           ( edge_rgb_color_attr > 0 ) ? INDEX_TO_RGBA(RIDGE) : RIDGE;

	cmp	DWORD PTR _edge_rgb_color_attr, 0
	jle	SHORT $LN179@plain_face
	push	1
	call	_INDEX_TO_RGBA
	add	esp, 4
	jmp	SHORT $LN182@plain_face
$LN179@plain_face:
	mov	eax, 1

; 550  :        else gdata[i].ecolor = 

	jmp	SHORT $LN182@plain_face
$LN63@plain_face:

; 551  :           ( edge_rgb_color_attr > 0 ) ? INDEX_TO_RGBA(VALLEY) : VALLEY; 

	cmp	DWORD PTR _edge_rgb_color_attr, 0
	jle	SHORT $LN181@plain_face
	push	2
	call	_INDEX_TO_RGBA
	add	esp, 4
	jmp	SHORT $LN182@plain_face
$LN181@plain_face:
	mov	eax, 2
$LN182@plain_face:
	mov	DWORD PTR [ebx], eax
	add	esi, 48					; 00000030H
	add	ebx, 144				; 00000090H
	mov	eax, edi
	cmp	esi, 144				; 00000090H
	jl	$LL66@plain_face

; 545  :       }
; 546  :       for ( i = 0 ; i < FACET_EDGES ; i++ )

	mov	ebx, DWORD PTR _web+616
$LN448@plain_face:

; 553  : 
; 554  :     if ( web.modeltype == LINEAR )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	jne	SHORT $LN61@plain_face

; 555  :     { /* call option-specific routine */
; 556  :       gdata->flags |= LABEL_FACET|LABEL_EDGE|LABEL_HEAD|LABEL_TAIL;
; 557  :       option_facet(gdata,f_id);         

	mov	edx, DWORD PTR _f_id$[ebp]
	mov	eax, DWORD PTR _gdata$[ebp]
	or	DWORD PTR [eax+136], 15360		; 00003c00H
	push	edx
	push	eax
	call	_option_facet
	add	esp, 8
	jmp	$LN146@plain_face
$LN61@plain_face:

; 565  :       memcpy((char*)qdata,(char*)gdata,3*sizeof(struct graphdata));

	mov	ecx, 108				; 0000006cH
	lea	edi, DWORD PTR _qdata$89799[ebp]
	cmp	eax, 2
	jne	$LN59@plain_face

; 558  :     } 
; 559  :     else if ( web.modeltype == QUADRATIC )
; 560  :     { 
; 561  :       /* quadratic, plot as four subtriangles */
; 562  :       struct graphdata qdata[FACET_VERTS+1];
; 563  :       int flags = (gdata[0].flags | LIST_FACET) & 
; 564  :            ~(LABEL_FACET|LABEL_EDGE|LABEL_HEAD|LABEL_TAIL);

	mov	edx, DWORD PTR _gdata$[ebp]
	mov	eax, DWORD PTR [edx+136]
	and	eax, -15361				; ffffc3ffH
	or	eax, 2
	mov	DWORD PTR _flags$89800[ebp], eax

; 565  :       memcpy((char*)qdata,(char*)gdata,3*sizeof(struct graphdata));

	mov	esi, edx

; 566  : 
; 567  :       for( j=0 ; j<SDIM ; j++ )

	xor	eax, eax
	rep movsd
	test	ebx, ebx
	jle	SHORT $LN56@plain_face

; 552  :     }

	lea	ecx, DWORD PTR [edx+720]
$LL58@plain_face:

; 568  :          { qdata[1].x[j] = gdata[3].x[j]; qdata[2].x[j]=gdata[5].x[j]; }

	fld	QWORD PTR [ecx-288]
	inc	eax
	fstp	QWORD PTR _qdata$89799[ebp+eax*8+136]
	add	ecx, 8
	fld	QWORD PTR [ecx-8]
	fstp	QWORD PTR _qdata$89799[ebp+eax*8+280]
	cmp	eax, ebx
	jl	SHORT $LL58@plain_face
$LN56@plain_face:

; 569  :       qdata[1].etype=INVISIBLE_EDGE;
; 570  :       qdata[1].v_id = gdata[3].v_id;

	mov	esi, DWORD PTR _gdata$[ebp]
	mov	ecx, DWORD PTR [esi+564]

; 571  :       qdata[2].v_id = gdata[5].v_id;

	mov	edx, DWORD PTR [esi+852]

; 572  :       qdata[0].id = gdata[0].id; 
; 573  :       qdata[1].id = NULLEDGE; 
; 574  :       qdata[2].id = gdata[2].id;
; 575  :       qdata[0].flags = flags;
; 576  :       qdata[1].ecolor = BLACK;
; 577  :       option_facet(qdata,f_id);

	mov	edi, DWORD PTR _f_id$[ebp]
	mov	ebx, DWORD PTR _flags$89800[ebp]
	xor	eax, eax
	mov	WORD PTR _qdata$89799[ebp+268], ax
	mov	eax, DWORD PTR [esi+128]
	mov	DWORD PTR _qdata$89799[ebp+128], eax
	mov	DWORD PTR _qdata$89799[ebp+276], ecx
	mov	ecx, DWORD PTR _NULLEDGE
	mov	DWORD PTR _qdata$89799[ebp+420], edx
	mov	edx, DWORD PTR [esi+416]
	lea	eax, DWORD PTR _qdata$89799[ebp]
	push	edi
	push	eax
	mov	DWORD PTR _qdata$89799[ebp+272], ecx
	mov	DWORD PTR _qdata$89799[ebp+416], edx
	mov	DWORD PTR _qdata$89799[ebp+136], ebx
	mov	DWORD PTR _qdata$89799[ebp+264], 0
	call	_option_facet

; 578  : 
; 579  :       for(j=0;j<SDIM;j++)

	xor	ecx, ecx
	add	esp, 8
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN433@plain_face

; 580  :       { qdata[0].x[j]=gdata[3].x[j];

	lea	edx, DWORD PTR _qdata$89799[ebp]
	lea	edi, DWORD PTR _qdata$89799[ebp+144]
	sub	edx, esi
	lea	eax, DWORD PTR [esi+144]
	sub	edi, esi
	npad	9
$LL444@plain_face:
	fld	QWORD PTR [eax+288]
	inc	ecx
	fstp	QWORD PTR _qdata$89799[ebp+ecx*8-8]
	add	eax, 8

; 581  :         qdata[1].x[j]=gdata[1].x[j];

	fld	QWORD PTR [eax-8]
	fstp	QWORD PTR [edx+eax-8]

; 582  :         qdata[2].x[j]=gdata[4].x[j];

	fld	QWORD PTR [eax+424]
	fstp	QWORD PTR [edi+eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL444@plain_face

; 578  : 
; 579  :       for(j=0;j<SDIM;j++)

	mov	edi, DWORD PTR _f_id$[ebp]
$LN433@plain_face:

; 583  :       }
; 584  :       qdata[1].etype=gdata[1].etype;

	mov	cx, WORD PTR [esi+268]

; 585  :       qdata[2].etype=INVISIBLE_EDGE;
; 586  :       qdata[0].v_id = gdata[3].v_id;

	mov	eax, DWORD PTR [esi+564]
	mov	WORD PTR _qdata$89799[ebp+268], cx

; 587  :       qdata[1].v_id = gdata[1].v_id;

	mov	ecx, DWORD PTR [esi+276]
	xor	edx, edx
	mov	DWORD PTR _qdata$89799[ebp+276], ecx

; 588  :       qdata[2].v_id = gdata[4].v_id;
; 589  :       qdata[0].id = gdata[0].id; 
; 590  :       qdata[1].id = gdata[1].id; 

	mov	ecx, DWORD PTR [esi+272]
	mov	WORD PTR _qdata$89799[ebp+412], dx
	mov	edx, DWORD PTR [esi+708]
	mov	DWORD PTR _qdata$89799[ebp+132], eax
	mov	eax, DWORD PTR [esi+128]
	mov	DWORD PTR _qdata$89799[ebp+272], ecx
	mov	DWORD PTR _qdata$89799[ebp+420], edx

; 591  :       qdata[2].id = NULLEDGE;

	mov	edx, DWORD PTR _NULLEDGE
	mov	DWORD PTR _qdata$89799[ebp+128], eax

; 592  :       qdata[2].ecolor = BLACK;
; 593  :       qdata[0].flags = flags;
; 594  :       qdata[1].ecolor = gdata[1].ecolor;

	mov	eax, DWORD PTR [esi+264]

; 595  :       option_facet(qdata,f_id);

	lea	ecx, DWORD PTR _qdata$89799[ebp]
	push	edi
	push	ecx
	mov	DWORD PTR _qdata$89799[ebp+416], edx
	mov	DWORD PTR _qdata$89799[ebp+408], 0
	mov	DWORD PTR _qdata$89799[ebp+136], ebx
	mov	DWORD PTR _qdata$89799[ebp+264], eax
	call	_option_facet

; 596  : 
; 597  :       for(j=0;j<SDIM;j++)

	mov	edx, DWORD PTR _web+616
	add	esp, 8
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN50@plain_face

; 583  :       }
; 584  :       qdata[1].etype=gdata[1].etype;

	lea	ecx, DWORD PTR [esi+576]
	npad	3
$LL52@plain_face:

; 598  :       { qdata[0].x[j]=gdata[5].x[j];

	fld	QWORD PTR [ecx+144]
	inc	eax
	fstp	QWORD PTR _qdata$89799[ebp+eax*8-8]
	add	ecx, 8

; 599  :         qdata[1].x[j]=gdata[4].x[j];

	fld	QWORD PTR [ecx-8]
	fstp	QWORD PTR _qdata$89799[ebp+eax*8+136]

; 600  :         qdata[2].x[j]=gdata[2].x[j];

	fld	QWORD PTR [ecx-296]
	fstp	QWORD PTR _qdata$89799[ebp+eax*8+280]
	cmp	eax, edx
	jl	SHORT $LL52@plain_face
$LN50@plain_face:

; 601  :       }
; 602  :       qdata[2].etype=gdata[2].etype;

	mov	dx, WORD PTR [esi+412]

; 603  :       qdata[0].etype=INVISIBLE_EDGE;
; 604  :       qdata[0].v_id = gdata[5].v_id;

	mov	ecx, DWORD PTR [esi+852]
	mov	WORD PTR _qdata$89799[ebp+412], dx

; 605  :       qdata[1].v_id = gdata[4].v_id;

	mov	edx, DWORD PTR [esi+708]
	xor	eax, eax
	mov	DWORD PTR _qdata$89799[ebp+276], edx

; 606  :       qdata[2].v_id = gdata[2].v_id;
; 607  :       qdata[0].id = NULLEDGE; 
; 608  :       qdata[1].id = gdata[1].id; 

	mov	edx, DWORD PTR [esi+272]
	mov	WORD PTR _qdata$89799[ebp+124], ax
	mov	eax, DWORD PTR [esi+420]
	mov	DWORD PTR _qdata$89799[ebp+132], ecx
	mov	ecx, DWORD PTR _NULLEDGE
	mov	DWORD PTR _qdata$89799[ebp+272], edx
	mov	DWORD PTR _qdata$89799[ebp+420], eax

; 609  :       qdata[2].id = gdata[2].id;

	mov	eax, DWORD PTR [esi+416]
	mov	DWORD PTR _qdata$89799[ebp+128], ecx

; 610  :       qdata[0].flags = flags;
; 611  :       qdata[0].ecolor = BLACK;
; 612  :       qdata[2].ecolor = gdata[2].ecolor;

	mov	ecx, DWORD PTR [esi+408]

; 613  :       option_facet(qdata,f_id);

	lea	edx, DWORD PTR _qdata$89799[ebp]
	push	edi
	push	edx
	mov	DWORD PTR _qdata$89799[ebp+416], eax
	mov	DWORD PTR _qdata$89799[ebp+136], ebx
	mov	DWORD PTR _qdata$89799[ebp+120], 0
	mov	DWORD PTR _qdata$89799[ebp+408], ecx
	call	_option_facet

; 614  : 
; 615  :       for(j=0;j<SDIM;j++)

	mov	edx, DWORD PTR _web+616
	add	esp, 8
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN47@plain_face

; 601  :       }
; 602  :       qdata[2].etype=gdata[2].etype;

	lea	ecx, DWORD PTR [esi+576]
	npad	7
$LL49@plain_face:

; 616  :       { qdata[0].x[j]=gdata[3].x[j];

	fld	QWORD PTR [ecx-144]
	inc	eax
	fstp	QWORD PTR _qdata$89799[ebp+eax*8-8]
	add	ecx, 8

; 617  :         qdata[1].x[j]=gdata[4].x[j];

	fld	QWORD PTR [ecx-8]
	fstp	QWORD PTR _qdata$89799[ebp+eax*8+136]

; 618  :         qdata[2].x[j]=gdata[5].x[j];

	fld	QWORD PTR [ecx+136]
	fstp	QWORD PTR _qdata$89799[ebp+eax*8+280]
	cmp	eax, edx
	jl	SHORT $LL49@plain_face
$LN47@plain_face:

; 619  :       }
; 620  :       qdata[0].etype=INVISIBLE_EDGE;

	xor	eax, eax
	mov	WORD PTR _qdata$89799[ebp+124], ax

; 621  :       qdata[1].etype=INVISIBLE_EDGE;
; 622  :       qdata[2].etype=INVISIBLE_EDGE;
; 623  :       qdata[0].v_id = gdata[3].v_id;

	mov	eax, DWORD PTR [esi+564]
	mov	DWORD PTR _qdata$89799[ebp+132], eax

; 624  :       qdata[1].v_id = gdata[4].v_id;
; 625  :       qdata[2].v_id = gdata[5].v_id;
; 626  :       qdata[0].id = NULLEDGE; qdata[1].id = NULLEDGE;

	mov	eax, DWORD PTR _NULLEDGE
	mov	DWORD PTR _qdata$89799[ebp+128], eax
	mov	DWORD PTR _qdata$89799[ebp+272], eax

; 627  :       qdata[2].id = NULLEDGE;

	mov	DWORD PTR _qdata$89799[ebp+416], eax

; 628  :       qdata[0].flags = flags | LABEL_FACET;
; 629  :       qdata[1].ecolor = BLACK;

	xor	eax, eax
	xor	ecx, ecx
	xor	edx, edx
	mov	DWORD PTR _qdata$89799[ebp+264], eax

; 630  :       qdata[2].ecolor = BLACK;

	mov	DWORD PTR _qdata$89799[ebp+408], eax
	mov	WORD PTR _qdata$89799[ebp+268], cx
	mov	ecx, DWORD PTR [esi+708]
	mov	WORD PTR _qdata$89799[ebp+412], dx
	mov	edx, DWORD PTR [esi+852]

; 631  :       option_facet(qdata,f_id);

	lea	eax, DWORD PTR _qdata$89799[ebp]
	push	edi
	or	ebx, 8192				; 00002000H
	push	eax
	mov	DWORD PTR _qdata$89799[ebp+276], ecx
	mov	DWORD PTR _qdata$89799[ebp+420], edx
	mov	DWORD PTR _qdata$89799[ebp+136], ebx
	call	_option_facet
	add	esp, 8

; 632  :     } /* end quadratic */
; 633  :     else /* Lagrange */

	jmp	$LN146@plain_face
$LN59@plain_face:

; 634  :     {
; 635  :       /* plot as subtriangles */
; 636  :       int flags = (gdata[0].flags|LIST_FACET) & 
; 637  :            ~(LABEL_FACET|LABEL_EDGE|LABEL_HEAD|LABEL_TAIL);

	mov	esi, DWORD PTR _gdata$[ebp]
	mov	eax, DWORD PTR [esi+136]
	and	eax, -15361				; ffffc3ffH

; 638  :       struct graphdata qdata[FACET_VERTS+1];
; 639  :       memcpy((char*)qdata,(char*)gdata,3*sizeof(struct graphdata));

	rep movsd

; 640  :       if ( bezier_flag )

	xor	edi, edi
	or	eax, 2
	mov	DWORD PTR _flags$89817[ebp], eax

; 641  :       { REAL t[2];
; 642  :         for ( i = 0 ; i <= gorder ; i++ )

	mov	DWORD PTR _i$[ebp], edi
	cmp	DWORD PTR _bezier_flag, edi
	je	$LN45@plain_face
	mov	eax, DWORD PTR _gorder$[ebp]
	cmp	eax, edi
	jl	$LN434@plain_face
	fild	DWORD PTR _gorder$[ebp]
	mov	ecx, DWORD PTR _points$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv5082[ebp], edx
	fstp	QWORD PTR tv3308[ebp]
	npad	6
$LL424@plain_face:

; 643  :         { t[0] = i/(REAL)gorder;

	fild	DWORD PTR _i$[ebp]

; 644  :           for ( j = 0 ; i+j <= gorder ; j++ )

	mov	eax, DWORD PTR _i$[ebp]
	xor	esi, esi
	mov	DWORD PTR _j$[ebp], esi
	fdiv	QWORD PTR tv3308[ebp]
	fstp	QWORD PTR _t$89823[ebp]
	cmp	eax, DWORD PTR _gorder$[ebp]
	jg	SHORT $LN43@plain_face

; 643  :         { t[0] = i/(REAL)gorder;

	mov	edi, DWORD PTR tv5082[ebp]
	npad	2
$LL420@plain_face:

; 645  :           { t[1] = j/(REAL)gorder;

	fild	DWORD PTR _j$[ebp]

; 646  :             bezier_eval_2d(web.lagrange_order,SDIM,t,verts,
; 647  :                points[(gorder-i-j)][j]);

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR _verts$[ebp]
	fdiv	QWORD PTR tv3308[ebp]
	fstp	QWORD PTR _t$89823[ebp+8]
	mov	edx, DWORD PTR [ecx+esi*4]
	push	edx
	mov	edx, DWORD PTR _web+632
	push	eax
	lea	ecx, DWORD PTR _t$89823[ebp]
	push	ecx
	push	ebx
	push	edx
	call	_bezier_eval_2d
	mov	eax, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR _web+616
	inc	esi
	lea	ecx, DWORD PTR [esi+eax]
	add	esp, 20					; 00000014H
	sub	edi, 4
	mov	DWORD PTR _j$[ebp], esi
	cmp	ecx, DWORD PTR _gorder$[ebp]
	jle	SHORT $LL420@plain_face
$LN43@plain_face:

; 641  :       { REAL t[2];
; 642  :         for ( i = 0 ; i <= gorder ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	sub	DWORD PTR tv5082[ebp], 4
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _gorder$[ebp]
	jle	$LL424@plain_face

; 648  :           }
; 649  :         }
; 650  :       }
; 651  :       else /* regular lagrange */

	jmp	$LN434@plain_face
$LN45@plain_face:

; 652  :       { REAL t[2];
; 653  :         if ( smooth_graph_flag )

	cmp	DWORD PTR _smooth_graph_flag, edi
	je	$LN37@plain_face

; 654  :         { for ( i = 0 ; i <= gorder ; i++ )

	cmp	DWORD PTR _gorder$[ebp], edi
	jl	$LN434@plain_face
	fild	DWORD PTR _gorder$[ebp]
	mov	edx, DWORD PTR _points$[ebp]
	mov	DWORD PTR tv5110[ebp], edx
	fstp	QWORD PTR tv3308[ebp]
	npad	4
$LL425@plain_face:

; 655  :           { t[0] = i/(REAL)gorder;

	fild	DWORD PTR _i$[ebp]

; 656  :             for ( j = 0 ; i+j <= gorder ; j++ )

	xor	esi, esi
	mov	DWORD PTR _j$[ebp], esi
	fdiv	QWORD PTR tv3308[ebp]
	fstp	QWORD PTR _t$89833[ebp]
	cmp	edi, DWORD PTR _gorder$[ebp]
	jg	SHORT $LN35@plain_face
$LL421@plain_face:

; 657  :             { t[1] = j/(REAL)gorder;

	fild	DWORD PTR _j$[ebp]

; 658  :               lagrange_eval_2d(web.lagrange_order,SDIM,t,verts,points[i][j]);

	mov	eax, DWORD PTR tv5110[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _verts$[ebp]
	fdiv	QWORD PTR tv3308[ebp]
	fstp	QWORD PTR _t$89833[ebp+8]
	mov	edx, DWORD PTR [ecx+esi*4]
	push	edx
	mov	edx, DWORD PTR _web+632
	push	eax
	lea	ecx, DWORD PTR _t$89833[ebp]
	push	ecx
	push	ebx
	push	edx
	call	_lagrange_eval_2d
	mov	ebx, DWORD PTR _web+616
	inc	esi
	lea	eax, DWORD PTR [esi+edi]
	add	esp, 20					; 00000014H
	mov	DWORD PTR _j$[ebp], esi
	cmp	eax, DWORD PTR _gorder$[ebp]
	jle	SHORT $LL421@plain_face
$LN35@plain_face:

; 654  :         { for ( i = 0 ; i <= gorder ; i++ )

	add	DWORD PTR tv5110[ebp], 4
	inc	edi
	mov	DWORD PTR _i$[ebp], edi
	cmp	edi, DWORD PTR _gorder$[ebp]
	jle	$LL425@plain_face

; 659  :             }
; 660  :           }
; 661  :         }
; 662  :         else /* just copy over */

	jmp	$LN434@plain_face
$LN37@plain_face:

; 663  :           for ( j = 0,jj=0 ;  j <= web.lagrange_order ; j++ )

	mov	eax, DWORD PTR _web+632
	mov	DWORD PTR _j$[ebp], edi
	cmp	eax, edi
	jl	$LN434@plain_face
	npad	8
$LL29@plain_face:

; 664  :             for ( i = 0 ; i+j <= web.lagrange_order ; i++,jj++ )

	cmp	DWORD PTR _j$[ebp], eax
	jg	$LN28@plain_face
	mov	edi, DWORD PTR _jj$[ebp]
	mov	ecx, DWORD PTR _points$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	lea	edi, DWORD PTR [edi+edi*8]
	shl	edi, 4
	add	edi, DWORD PTR _gdata$[ebp]
	mov	DWORD PTR tv5184[ebp], ecx
$LL26@plain_face:

; 665  :               for ( k = 0 ; k < SDIM ; k++ )

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN25@plain_face
	mov	eax, DWORD PTR tv5184[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, edi
	npad	7
$LL23@plain_face:

; 666  :                  points[i][j][k]=gdata[jj].x[k];

	fld	QWORD PTR [eax]
	inc	esi
	fstp	QWORD PTR [ecx]
	mov	ebx, DWORD PTR _web+616
	add	eax, 8
	add	ecx, 8
	cmp	esi, ebx
	jl	SHORT $LL23@plain_face

; 665  :               for ( k = 0 ; k < SDIM ; k++ )

	mov	eax, DWORD PTR _web+632
$LN25@plain_face:

; 664  :             for ( i = 0 ; i+j <= web.lagrange_order ; i++,jj++ )

	add	DWORD PTR tv5184[ebp], 4
	inc	DWORD PTR _jj$[ebp]
	inc	edx
	add	edi, 144				; 00000090H
	cmp	edx, eax
	jle	SHORT $LL26@plain_face
$LN28@plain_face:

; 663  :           for ( j = 0,jj=0 ;  j <= web.lagrange_order ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, eax
	jle	$LL29@plain_face
$LN434@plain_face:

; 667  :       }
; 668  : 
; 669  :       for ( j = 0,jj=0,ii=gorder+1 ; j < gorder ; j++,jj++ )

	mov	eax, DWORD PTR _gorder$[ebp]
	xor	edi, edi
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _j$[ebp], edi
	mov	DWORD PTR _jj$[ebp], edi
	mov	DWORD PTR _ii$[ebp], ecx
	cmp	eax, edi
	jle	$LN146@plain_face
	npad	4
$LL20@plain_face:

; 670  :         for ( i = 0 ; i < gorder-j ; i++,jj++,ii++ )

	mov	eax, DWORD PTR _gorder$[ebp]
	sub	eax, edi
	xor	esi, esi
	mov	DWORD PTR tv4972[ebp], eax
	test	eax, eax
	jle	$LN19@plain_face
	mov	eax, DWORD PTR _ii$[ebp]
	lea	edx, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR _gdata$[ebp]
	add	edx, edx
	lea	ecx, DWORD PTR [eax+edx*8+132]
	mov	DWORD PTR tv5423[ebp], ecx
	mov	ecx, DWORD PTR _jj$[ebp]
	lea	edx, DWORD PTR [ecx+ecx*8]
	add	edx, edx
	lea	eax, DWORD PTR [eax+edx*8+276]
	mov	DWORD PTR tv5427[ebp], eax
	npad	2
$LL17@plain_face:

; 671  :         { /* first, lower left triangles */ 
; 672  :           for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN437@plain_face
	mov	ecx, DWORD PTR _points$[ebp]
	mov	edx, DWORD PTR [ecx+esi*4+4]
	mov	ecx, DWORD PTR [ecx+esi*4]
	lea	edx, DWORD PTR [edx+edi*4]
	lea	ecx, DWORD PTR [ecx+edi*4]
	npad	7
$LL14@plain_face:

; 673  :           { qdata[0].x[k] = points[i][j][k];

	mov	edi, DWORD PTR [ecx]
	fld	QWORD PTR [edi+eax*8]
	inc	eax
	fstp	QWORD PTR _qdata$89818[ebp+eax*8-8]

; 674  :             qdata[1].x[k] = points[i+1][j][k];

	mov	edi, DWORD PTR [edx]
	fld	QWORD PTR [edi+eax*8-8]
	fstp	QWORD PTR _qdata$89818[ebp+eax*8+136]

; 675  :             qdata[2].x[k] = points[i][j+1][k];

	mov	edi, DWORD PTR [ecx+4]
	fld	QWORD PTR [edi+eax*8-8]
	fstp	QWORD PTR _qdata$89818[ebp+eax*8+280]
	cmp	eax, ebx
	jl	SHORT $LL14@plain_face

; 671  :         { /* first, lower left triangles */ 
; 672  :           for ( k = 0 ; k < SDIM ; k++ )

	mov	edi, DWORD PTR _j$[ebp]
$LN437@plain_face:

; 676  :           }
; 677  :           qdata[0].v_id = gdata[jj].v_id; 

	mov	eax, DWORD PTR tv5427[ebp]
	mov	edx, DWORD PTR [eax-144]

; 678  :           qdata[1].v_id = gdata[jj+1].v_id;

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR _gdata$[ebp]
	mov	DWORD PTR _qdata$89818[ebp+132], edx

; 679  :           qdata[2].v_id = gdata[ii].v_id;

	mov	edx, DWORD PTR tv5423[ebp]
	mov	DWORD PTR _qdata$89818[ebp+276], eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _qdata$89818[ebp+420], eax

; 680  :           qdata[0].id = (j == 0) ? gdata[0].id : NULLEDGE;

	mov	eax, DWORD PTR _NULLEDGE
	test	edi, edi
	jne	SHORT $LN183@plain_face
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR _qdata$89818[ebp+128], edx
	jmp	SHORT $LN184@plain_face
$LN183@plain_face:
	mov	DWORD PTR _qdata$89818[ebp+128], eax
$LN184@plain_face:

; 681  :           qdata[1].id = (i == gorder-j-1) ? gdata[1].id : NULLEDGE;

	mov	ebx, DWORD PTR tv4972[ebp]
	dec	ebx
	cmp	esi, ebx
	jne	SHORT $LN185@plain_face
	mov	edx, DWORD PTR [ecx+272]
	mov	DWORD PTR _qdata$89818[ebp+272], edx
	jmp	SHORT $LN186@plain_face
$LN185@plain_face:
	mov	DWORD PTR _qdata$89818[ebp+272], eax
$LN186@plain_face:

; 682  :           qdata[2].id = (i == 0) ? gdata[2].id : NULLEDGE;

	test	esi, esi
	jne	SHORT $LN187@plain_face
	mov	eax, DWORD PTR [ecx+416]
$LN187@plain_face:
	mov	DWORD PTR _qdata$89818[ebp+416], eax

; 683  :           qdata[0].etype = (j==0) ? gdata[0].etype : INVISIBLE_EDGE;

	test	edi, edi
	jne	SHORT $LN189@plain_face
	mov	dx, WORD PTR [ecx+124]
	mov	WORD PTR _qdata$89818[ebp+124], dx
	jmp	SHORT $LN190@plain_face
$LN189@plain_face:
	xor	eax, eax
	mov	WORD PTR _qdata$89818[ebp+124], ax
$LN190@plain_face:

; 684  :           qdata[1].etype = (i+j+1==gorder) ? gdata[1].etype : INVISIBLE_EDGE;

	lea	eax, DWORD PTR [edi+esi+1]
	cmp	eax, DWORD PTR _gorder$[ebp]
	jne	SHORT $LN191@plain_face
	mov	dx, WORD PTR [ecx+268]
	jmp	SHORT $LN477@plain_face
$LN191@plain_face:
	xor	edx, edx
$LN477@plain_face:
	mov	WORD PTR _qdata$89818[ebp+268], dx

; 685  :           qdata[2].etype = (i==0) ? gdata[2].etype : INVISIBLE_EDGE;

	test	esi, esi
	jne	SHORT $LN193@plain_face
	mov	dx, WORD PTR [ecx+412]
	jmp	SHORT $LN478@plain_face
$LN193@plain_face:
	xor	edx, edx
$LN478@plain_face:
	mov	WORD PTR _qdata$89818[ebp+412], dx

; 686  :           qdata[0].ecolor = (j==0) ? gdata[0].ecolor : BLACK;

	test	edi, edi
	jne	SHORT $LN195@plain_face
	mov	edx, DWORD PTR [ecx+120]
	mov	DWORD PTR _qdata$89818[ebp+120], edx
	jmp	SHORT $LN196@plain_face
$LN195@plain_face:
	mov	DWORD PTR _qdata$89818[ebp+120], 0
$LN196@plain_face:

; 687  :           qdata[1].ecolor = (i+j+1==gorder) ? gdata[1].ecolor : BLACK;

	cmp	eax, DWORD PTR _gorder$[ebp]
	jne	SHORT $LN197@plain_face
	mov	eax, DWORD PTR [ecx+264]
	mov	DWORD PTR _qdata$89818[ebp+264], eax
	jmp	SHORT $LN198@plain_face
$LN197@plain_face:
	mov	DWORD PTR _qdata$89818[ebp+264], 0
$LN198@plain_face:

; 688  :           qdata[2].ecolor = (i==0) ? gdata[2].ecolor : BLACK;

	test	esi, esi
	jne	SHORT $LN199@plain_face
	mov	ecx, DWORD PTR [ecx+408]
	mov	DWORD PTR _qdata$89818[ebp+408], ecx
	jmp	SHORT $LN200@plain_face
$LN199@plain_face:
	mov	DWORD PTR _qdata$89818[ebp+408], 0
$LN200@plain_face:

; 689  :           qdata[0].flags = flags;
; 690  :           option_facet(qdata,f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR _flags$89817[ebp]
	push	eax
	lea	ecx, DWORD PTR _qdata$89818[ebp]
	push	ecx
	mov	DWORD PTR _qdata$89818[ebp+136], edx
	call	_option_facet
	add	esp, 8

; 691  : 
; 692  :           if ( i < gorder-j-1 )

	cmp	esi, ebx
	jge	$LN16@plain_face

; 693  :           { /* now upper right triangles */
; 694  :             int n;
; 695  :             for ( k = 0 ; k < SDIM ; k++ )

	mov	ebx, DWORD PTR _web+616
	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN438@plain_face
	mov	edx, DWORD PTR _points$[ebp]
	mov	ecx, DWORD PTR [edx+esi*4+4]
	mov	edx, DWORD PTR [edx+esi*4]
	lea	ecx, DWORD PTR [ecx+edi*4]
	lea	edx, DWORD PTR [edx+edi*4+4]
	npad	7
$LL10@plain_face:

; 696  :             { qdata[0].x[k] = points[i+1][j][k];

	mov	edi, DWORD PTR [ecx]
	fld	QWORD PTR [edi+eax*8]
	inc	eax
	fstp	QWORD PTR _qdata$89818[ebp+eax*8-8]

; 697  :               qdata[1].x[k] = points[i+1][j+1][k];

	mov	edi, DWORD PTR [ecx+4]
	fld	QWORD PTR [edi+eax*8-8]
	fstp	QWORD PTR _qdata$89818[ebp+eax*8+136]

; 698  :               qdata[2].x[k] = points[i][j+1][k];

	mov	edi, DWORD PTR [edx]
	fld	QWORD PTR [edi+eax*8-8]
	fstp	QWORD PTR _qdata$89818[ebp+eax*8+280]
	cmp	eax, ebx
	jl	SHORT $LL10@plain_face

; 693  :           { /* now upper right triangles */
; 694  :             int n;
; 695  :             for ( k = 0 ; k < SDIM ; k++ )

	mov	edi, DWORD PTR _j$[ebp]
$LN438@plain_face:

; 699  :             }
; 700  :             qdata[0].v_id = gdata[jj+1].v_id;

	mov	eax, DWORD PTR tv5427[ebp]
	mov	edx, DWORD PTR [eax]

; 701  :             qdata[1].v_id = gdata[ii+1].v_id;

	mov	eax, DWORD PTR tv5423[ebp]
	mov	DWORD PTR _qdata$89818[ebp+132], edx
	mov	edx, DWORD PTR [eax+144]

; 702  :             qdata[2].v_id = gdata[ii].v_id;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _qdata$89818[ebp+420], eax

; 703  :             for ( k = 0 ; k < FACET_EDGES ; k++ ) qdata[k].id = NULLEDGE;

	mov	eax, DWORD PTR _NULLEDGE
	mov	DWORD PTR _qdata$89818[ebp+128], eax
	mov	DWORD PTR _qdata$89818[ebp+272], eax
	mov	DWORD PTR _qdata$89818[ebp+416], eax

; 704  :             qdata[0].flags = flags |
; 705  :               (i==gorder/3 && j==gorder/3 ? LABEL_FACET:0);

	mov	eax, 1431655766				; 55555556H
	mov	DWORD PTR _qdata$89818[ebp+276], edx
	imul	DWORD PTR _gorder$[ebp]
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	cmp	esi, eax
	jne	SHORT $LN201@plain_face
	cmp	edi, eax
	jne	SHORT $LN201@plain_face
	mov	eax, 8192				; 00002000H
	jmp	SHORT $LN202@plain_face
$LN201@plain_face:
	xor	eax, eax
$LN202@plain_face:
	mov	edx, DWORD PTR _flags$89817[ebp]
	or	edx, eax
	mov	DWORD PTR _qdata$89818[ebp+136], edx

; 706  :             for ( n = 0 ; n < FACET_VERTS ; n++ ) 
; 707  :             { qdata[n].etype = INVISIBLE_EDGE;

	xor	edx, edx

; 708  :               qdata[n].ecolor = BLACK;

	mov	DWORD PTR _qdata$89818[ebp+120], ecx
	mov	DWORD PTR _qdata$89818[ebp+264], ecx
	mov	DWORD PTR _qdata$89818[ebp+408], ecx

; 709  :             }
; 710  :             option_facet(qdata,f_id);

	mov	ecx, DWORD PTR _f_id$[ebp]
	mov	WORD PTR _qdata$89818[ebp+268], dx
	xor	eax, eax
	push	ecx
	lea	edx, DWORD PTR _qdata$89818[ebp]
	push	edx
	mov	WORD PTR _qdata$89818[ebp+124], ax
	mov	WORD PTR _qdata$89818[ebp+412], ax
	call	_option_facet
	add	esp, 8
$LN16@plain_face:

; 670  :         for ( i = 0 ; i < gorder-j ; i++,jj++,ii++ )

	mov	ebx, DWORD PTR _web+616
	mov	ecx, 1
	add	DWORD PTR _jj$[ebp], ecx
	add	DWORD PTR _ii$[ebp], ecx
	mov	eax, 144				; 00000090H
	add	DWORD PTR tv5427[ebp], eax
	add	DWORD PTR tv5423[ebp], eax
	add	esi, ecx
	cmp	esi, DWORD PTR tv4972[ebp]
	jl	$LL17@plain_face
$LN19@plain_face:

; 667  :       }
; 668  : 
; 669  :       for ( j = 0,jj=0,ii=gorder+1 ; j < gorder ; j++,jj++ )

	inc	DWORD PTR _jj$[ebp]
	inc	edi
	mov	DWORD PTR _j$[ebp], edi
	cmp	edi, DWORD PTR _gorder$[ebp]
	jl	$LL20@plain_face
$LN146@plain_face:

; 389  :      
; 390  :   MFOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR tv2749[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _f_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv2746[ebp], eax
	jne	$LL426@plain_face
$LN436@plain_face:
	mov	esi, DWORD PTR _verts$[ebp]
	mov	ebx, DWORD PTR _gdata$[ebp]
$LN363@plain_face:

; 711  :           }
; 712  :        }
; 713  :     } /* end lagrange */
; 714  :   } /* end FOR_ALL_FACETS */
; 715  : 
; 716  :   temp_free((char*)gdata);

	push	ebx
	call	_temp_free

; 717  :   temp_free((char*)verts);

	push	esi
	call	_temp_free

; 718  :   if ( points ) free_temp_matrix3(points);

	mov	eax, DWORD PTR _points$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN1@plain_face
	push	eax
	call	_free_temp_matrix3
	add	esp, 4
$LN1@plain_face:

; 719  : 
; 720  : } /* end plain_facets() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_plain_facets ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@GEFKPDMA@Problem?5tessellating?5facet?5?$CFs?$DL?5m@ ; `string'
PUBLIC	??_C@_0CF@OKEFHFBE@Facet?5too?5complicated?5for?5plotti@ ; `string'
PUBLIC	__real@bff0000000000000
PUBLIC	_polycount$GSCopy$
PUBLIC	_glist$GSCopy$
PUBLIC	_gcount$GSCopy$
PUBLIC	_polylist$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_gsfn_recur_left_to_right
;	COMDAT ??_C@_0EC@GEFKPDMA@Problem?5tessellating?5facet?5?$CFs?$DL?5m@
CONST	SEGMENT
??_C@_0EC@GEFKPDMA@Problem?5tessellating?5facet?5?$CFs?$DL?5m@ DB 'Proble'
	DB	'm tessellating facet %s; maybe edges not counterclockwise?', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OKEFHFBE@Facet?5too?5complicated?5for?5plotti@
CONST	SEGMENT
??_C@_0CF@OKEFHFBE@Facet?5too?5complicated?5for?5plotti@ DB 'Facet too co'
	DB	'mplicated for plotting.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _gsfn_recur_left_to_right
_TEXT	SEGMENT
_new_polyspot$91733 = -708				; size = 4
_low_polyspot$91736 = -704				; size = 4
_i$ = -700						; size = 4
_new_polycount$91732 = -696				; size = 4
_old_visible$91730 = -692				; size = 4
tv1833 = -688						; size = 4
tv1759 = -688						; size = 4
tv1570 = -688						; size = 4
_jj$91735 = -684					; size = 4
tv1636 = -680						; size = 4
_new_polylist$91731 = -680				; size = 4
tv1106 = -676						; size = 4
tv587 = -676						; size = 4
_new_glist$91738 = -676					; size = 4
tv2962 = -672						; size = 4
_new_gcount$91737 = -672				; size = 4
tv3306 = -668						; size = 4
_j$ = -668						; size = 4
_glist$GSCopy$ = -664					; size = 4
tv3310 = -660						; size = 4
tv2958 = -660						; size = 4
tv1575 = -660						; size = 4
_nextv$91673 = -660					; size = 4
_polycount$GSCopy$ = -656				; size = 4
_gcount$GSCopy$ = -652					; size = 4
_polylist$GSCopy$ = -648				; size = 4
_these_intervals$ = -644				; size = 640
__$ArrayPad$ = -4					; size = 4
_glist$ = 8						; size = 4
_gcount$ = 12						; size = 4
_polylist$ = 16						; size = 4
_polycount$ = 20					; size = 4
_polyspot$ = 24						; size = 4
_intervals$ = 28					; size = 4
_interval_count$ = 32					; size = 4
_f_id$ = 36						; size = 4
_mode$ = 40						; size = 4
_gsfn_recur_left_to_right PROC				; COMDAT

; 3302 : { struct gsfn_interval these_intervals[MAXGSFN];

	push	ebp
	mov	ebp, esp
	sub	esp, 708				; 000002c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	edx, DWORD PTR _polylist$[ebp]
	mov	ecx, DWORD PTR _gcount$[ebp]
	mov	eax, DWORD PTR _glist$[ebp]
	push	ebx
	push	esi

; 3303 :   int i,j;
; 3304 : 
; 3305 :   // local copy of interval list
; 3306 :   if ( intervals )

	mov	esi, DWORD PTR _intervals$[ebp]

; 3471 :           these_intervals[i].visible = polylist[polyspot];

	mov	DWORD PTR _polylist$GSCopy$[ebp], edx
	mov	edx, DWORD PTR _polycount$[ebp]
	mov	DWORD PTR _gcount$GSCopy$[ebp], ecx
	mov	ecx, DWORD PTR _interval_count$[ebp]
	push	edi
	mov	DWORD PTR _glist$GSCopy$[ebp], eax
	mov	DWORD PTR _polycount$GSCopy$[ebp], edx
	test	esi, esi
	je	SHORT $LN124@gsfn_recur

; 3307 :   for ( i = 0 ; i < interval_count ; i++ )

	test	ecx, ecx
	jle	SHORT $LN124@gsfn_recur
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	lea	edi, DWORD PTR _these_intervals$[ebp]
	rep movsd
$LN124@gsfn_recur:

; 3308 :     these_intervals[i] = intervals[i];
; 3309 : 
; 3310 :   for(;;)
; 3311 :   { struct graphdata *thisv,*prev,*nextv;
; 3312 : 
; 3313 :     // next vertex
; 3314 :     polyspot++;

	mov	eax, DWORD PTR _polyspot$[ebp]
	inc	eax
	mov	DWORD PTR _polyspot$[ebp], eax

; 3315 : 
; 3316 :     if ( polyspot >= polycount )

	cmp	eax, edx
	jge	$LN163@gsfn_recur
	npad	5
$LL121@gsfn_recur:

; 3345 :         return;
; 3346 :       }
; 3347 :     }
; 3348 : 
; 3349 :     // test which way edges go
; 3350 :     thisv = glist + polylist[polyspot];

	mov	eax, DWORD PTR _polyspot$[ebp]
	mov	ecx, DWORD PTR _polylist$GSCopy$[ebp]
	mov	esi, DWORD PTR [ecx+eax*4]

; 3351 :     prev = glist + ((polylist[polyspot] + gcount - 1) % gcount);

	mov	edi, DWORD PTR _gcount$GSCopy$[ebp]
	lea	eax, DWORD PTR [esi+edi-1]
	cdq
	idiv	edi

; 3352 :     nextv = glist + ((polylist[polyspot] + 1) % gcount);  // taking advantage of wraparound

	lea	eax, DWORD PTR [esi+1]
	lea	ebx, DWORD PTR [esi+esi*8]
	shl	ebx, 4
	add	ebx, DWORD PTR _glist$GSCopy$[ebp]

; 3353 :     
; 3354 :     if ( prev->X[0] < thisv->X[0] )

	fld	QWORD PTR [ebx+56]
	lea	ecx, DWORD PTR [edx+edx*8]
	cdq
	idiv	edi
	shl	ecx, 4
	add	ecx, DWORD PTR _glist$GSCopy$[ebp]
	fcomp	QWORD PTR [ecx+56]
	fnstsw	ax

; 3355 :     { // prev edge to the left
; 3356 :       if ( nextv->X[0] < thisv->X[0] )

	fld	QWORD PTR [ebx+56]
	lea	esi, DWORD PTR [edx+edx*8]
	shl	esi, 4
	add	esi, DWORD PTR _glist$GSCopy$[ebp]
	test	ah, 65					; 00000041H
	fcomp	QWORD PTR [esi+56]
	mov	DWORD PTR _nextv$91673[ebp], esi
	fnstsw	ax
	jne	$LN110@gsfn_recur
	test	ah, 65					; 00000041H
	jne	$LN109@gsfn_recur

; 3357 :       { // prev edge left and next edge also to the left, so test slopes
; 3358 :         // to see if we have intervals merge or interval end.  The "<="
; 3359 :         // comparison means doubling back edges counted as internal
; 3360 :         // probes.
; 3361 :         if ( (prev->X[1]-thisv->X[1])*(nextv->X[0]-thisv->X[0]) <=
; 3362 :              (prev->X[0]-thisv->X[0])*(nextv->X[1]-thisv->X[1]) )

	fld	QWORD PTR [ecx+64]
	fsub	QWORD PTR [ebx+64]
	fld	QWORD PTR [esi+56]
	fsub	QWORD PTR [ebx+56]
	fmulp	ST(1), ST(0)
	fld	QWORD PTR [esi+64]
	fsub	QWORD PTR [ebx+64]
	fld	QWORD PTR [ecx+56]
	fsub	QWORD PTR [ebx+56]
	fmulp	ST(1), ST(0)
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	$LN108@gsfn_recur

; 3363 :         { // Merge two intervals and set this vertex as visible vertex.
; 3364 :           // find in interval list
; 3365 :           for ( i = 0 ; i < interval_count ; i++ )

	mov	ecx, DWORD PTR _interval_count$[ebp]
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN203@gsfn_recur

; 3512 :             }
; 3513 :             // construct new polylist
; 3514 :             for ( j = 0 ; j < polycount ; j++ )

	mov	edx, DWORD PTR _polylist$GSCopy$[ebp]
	mov	esi, DWORD PTR _polyspot$[ebp]
	mov	esi, DWORD PTR [edx+esi*4]
	lea	edx, DWORD PTR _these_intervals$[ebp+4]
	npad	1
$LL107@gsfn_recur:

; 3366 :             if ( these_intervals[i].topv == polylist[polyspot] )

	cmp	DWORD PTR [edx], esi
	je	SHORT $LN156@gsfn_recur

; 3363 :         { // Merge two intervals and set this vertex as visible vertex.
; 3364 :           // find in interval list
; 3365 :           for ( i = 0 ; i < interval_count ; i++ )

	inc	eax
	add	edx, 32					; 00000020H
	cmp	eax, ecx
	jl	SHORT $LL107@gsfn_recur

; 3459 :               break;
; 3460 :           }
; 3461 :           if ( i <= 0 )

	jmp	SHORT $LN203@gsfn_recur
$LN156@gsfn_recur:

; 3367 :             { these_intervals[i].topv = these_intervals[i+1].topv;

	shl	eax, 5
	mov	edx, DWORD PTR _these_intervals$[ebp+eax+36]
	mov	DWORD PTR _these_intervals$[ebp+eax+4], edx

; 3368 :               these_intervals[i].visible = polylist[polyspot]; 

	mov	DWORD PTR _these_intervals$[ebp+eax+24], esi
$LN203@gsfn_recur:

; 3369 :               break;
; 3370 :             }
; 3371 :           // delete other half (recall that interval list is unordered)
; 3372 :           interval_count--;

	dec	ecx

; 3373 :           for ( i = 0 ; i < interval_count ; i++ )

	xor	eax, eax
	mov	DWORD PTR _interval_count$[ebp], ecx
	test	ecx, ecx
	jle	$LN211@gsfn_recur
	mov	edx, DWORD PTR _polylist$GSCopy$[ebp]
	mov	esi, DWORD PTR _polyspot$[ebp]
	mov	esi, DWORD PTR [edx+esi*4]
	lea	edx, DWORD PTR _these_intervals$[ebp]
$LL103@gsfn_recur:

; 3374 :             if ( these_intervals[i].lowv == polylist[polyspot] )

	cmp	DWORD PTR [edx], esi
	je	SHORT $LN157@gsfn_recur

; 3373 :           for ( i = 0 ; i < interval_count ; i++ )

	inc	eax
	add	edx, 32					; 00000020H
	cmp	eax, ecx
	jl	SHORT $LL103@gsfn_recur

; 3459 :               break;
; 3460 :           }
; 3461 :           if ( i <= 0 )

	jmp	$LN211@gsfn_recur
$LN157@gsfn_recur:

; 3375 :             { for ( j = i ; j < interval_count ; j++ )

	cmp	eax, ecx
	jge	$LN211@gsfn_recur
	mov	ecx, eax
	shl	ecx, 5
	lea	edi, DWORD PTR _these_intervals$[ebp+ecx]
	lea	esi, DWORD PTR _these_intervals$[ebp+ecx+32]
	mov	ecx, DWORD PTR _interval_count$[ebp]

; 3376 :                 these_intervals[j] = these_intervals[j+1];
; 3377 :               break;
; 3378 :             }
; 3379 :         }
; 3380 :         else

	jmp	SHORT $LN241@gsfn_recur
$LN108@gsfn_recur:

; 3381 :         { // A rightmost point, an interval disappears
; 3382 :           interval_count--;

	mov	edx, DWORD PTR _interval_count$[ebp]
	dec	edx

; 3383 :           for ( i = 0 ; i < interval_count ; i++ )

	xor	eax, eax
	mov	DWORD PTR _interval_count$[ebp], edx
	test	edx, edx
	jle	$LN211@gsfn_recur
	mov	ecx, DWORD PTR _polylist$GSCopy$[ebp]
	mov	esi, DWORD PTR _polyspot$[ebp]
	mov	esi, DWORD PTR [ecx+esi*4]
	lea	ecx, DWORD PTR _these_intervals$[ebp+4]
	npad	6
$LL95@gsfn_recur:

; 3384 :             if ( these_intervals[i].topv == polylist[polyspot] )

	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN158@gsfn_recur

; 3383 :           for ( i = 0 ; i < interval_count ; i++ )

	inc	eax
	add	ecx, 32					; 00000020H
	cmp	eax, edx
	jl	SHORT $LL95@gsfn_recur

; 3459 :               break;
; 3460 :           }
; 3461 :           if ( i <= 0 )

	jmp	$LN211@gsfn_recur
$LN158@gsfn_recur:

; 3385 :             { for ( j = i ; j < interval_count-1 ; j++ )

	lea	ecx, DWORD PTR [edx-1]
	cmp	eax, ecx
	jge	$LN211@gsfn_recur
	mov	edx, eax
	shl	edx, 5
	lea	edi, DWORD PTR _these_intervals$[ebp+edx]
	lea	esi, DWORD PTR _these_intervals$[ebp+edx+32]
$LN241@gsfn_recur:
	sub	ecx, eax
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	and	ecx, 1073741816				; 3ffffff8H
	rep movsd

; 3386 :                 these_intervals[j] = these_intervals[j+1];
; 3387 :               break;
; 3388 :             }
; 3389 :         }
; 3390 :       }
; 3391 :       else

	jmp	$LN211@gsfn_recur
$LN109@gsfn_recur:

; 3392 :       { // prev edge left and next edge to the right
; 3393 :         // Replace left edge with right edge as lower end of interval and
; 3394 :         // set current vertex as the visible one for the interval.
; 3395 :           for ( i = 0 ; i < interval_count ; i++ )

	mov	edx, DWORD PTR _interval_count$[ebp]
	xor	eax, eax
	test	edx, edx
	jle	$LN211@gsfn_recur
	mov	ecx, DWORD PTR _polylist$GSCopy$[ebp]
	mov	edi, DWORD PTR _polyspot$[ebp]
	mov	edi, DWORD PTR [ecx+edi*4]
	lea	ecx, DWORD PTR _these_intervals$[ebp]
$LL87@gsfn_recur:

; 3396 :             if ( these_intervals[i].lowv == polylist[polyspot] )

	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN159@gsfn_recur

; 3392 :       { // prev edge left and next edge to the right
; 3393 :         // Replace left edge with right edge as lower end of interval and
; 3394 :         // set current vertex as the visible one for the interval.
; 3395 :           for ( i = 0 ; i < interval_count ; i++ )

	inc	eax
	add	ecx, 32					; 00000020H
	cmp	eax, edx
	jl	SHORT $LL87@gsfn_recur

; 3459 :               break;
; 3460 :           }
; 3461 :           if ( i <= 0 )

	jmp	$LN211@gsfn_recur
$LN159@gsfn_recur:

; 3397 :             { these_intervals[i].lowv = (polylist[polyspot] + 1) % gcount;

	mov	edx, DWORD PTR _polylist$GSCopy$[ebp]
	mov	ecx, DWORD PTR _polyspot$[ebp]
	mov	edi, DWORD PTR [edx+ecx*4]
	shl	eax, 5
	mov	ecx, eax
	lea	eax, DWORD PTR [edi+1]
	cdq
	idiv	DWORD PTR _gcount$GSCopy$[ebp]

; 3398 :               these_intervals[i].visible = polylist[polyspot];

	mov	DWORD PTR _these_intervals$[ebp+ecx+24], edi
	mov	DWORD PTR _these_intervals$[ebp+ecx], edx

; 3399 :               these_intervals[i].slope = (thisv->X[1]-nextv->X[1])/(thisv->X[0]-nextv->X[0]);

	fld	QWORD PTR [ebx+64]
	fsub	QWORD PTR [esi+64]
	fld	QWORD PTR [ebx+56]
	fsub	QWORD PTR [esi+56]
	fdivp	ST(1), ST(0)
	fst	QWORD PTR _these_intervals$[ebp+ecx+16]

; 3400 :               these_intervals[i].b = thisv->X[1] - these_intervals[i].slope*thisv->X[0];

	fmul	QWORD PTR [ebx+56]
	fsubr	QWORD PTR [ebx+64]
	fstp	QWORD PTR _these_intervals$[ebp+ecx+8]

; 3401 :               break;
; 3402 :             }
; 3403 :       }
; 3404 :     }
; 3405 :     else

	jmp	$LN211@gsfn_recur
$LN110@gsfn_recur:

; 3406 :     { // prev edge to the right
; 3407 :       if ( nextv->X[0] < thisv->X[0] )

	test	ah, 65					; 00000041H
	jne	SHORT $LN82@gsfn_recur

; 3408 :       { // prev edge right and next edge to the left.
; 3409 :         // Replace left edge with right edge as upper end of inteval and
; 3410 :         // set current vertex as the visible one for the interval.
; 3411 :         for ( i = 0 ; i < interval_count ; i++ )

	mov	edx, DWORD PTR _interval_count$[ebp]
	xor	ecx, ecx
	test	edx, edx
	jle	$LN211@gsfn_recur
	mov	eax, DWORD PTR _polylist$GSCopy$[ebp]

; 3484 :           { // glist starts in upper polygon
; 3485 :             // construct new vertex lists
; 3486 :             for ( j = 0, jj = 0, new_gcount = 0 ; j < gcount ; j++ )

	mov	esi, DWORD PTR _polyspot$[ebp]
	mov	esi, DWORD PTR [eax+esi*4]
	lea	eax, DWORD PTR _these_intervals$[ebp+4]
$LL81@gsfn_recur:

; 3412 :           if ( these_intervals[i].topv == polylist[polyspot] )

	cmp	DWORD PTR [eax], esi
	je	SHORT $LN160@gsfn_recur

; 3408 :       { // prev edge right and next edge to the left.
; 3409 :         // Replace left edge with right edge as upper end of inteval and
; 3410 :         // set current vertex as the visible one for the interval.
; 3411 :         for ( i = 0 ; i < interval_count ; i++ )

	inc	ecx
	add	eax, 32					; 00000020H
	cmp	ecx, edx
	jl	SHORT $LL81@gsfn_recur

; 3459 :               break;
; 3460 :           }
; 3461 :           if ( i <= 0 )

	jmp	$LN211@gsfn_recur
$LN160@gsfn_recur:

; 3413 :           { these_intervals[i].topv = (polylist[polyspot] + gcount - 1) % gcount;

	lea	eax, DWORD PTR [esi+edi-1]
	cdq
	idiv	edi
	shl	ecx, 5
	mov	DWORD PTR _these_intervals$[ebp+ecx+4], edx

; 3414 :             break;
; 3415 :           }
; 3416 :       }
; 3417 :       else

	jmp	$LN211@gsfn_recur
$LN82@gsfn_recur:

; 3418 :       { // prev edge right and next edge to the right.
; 3419 :         // Test slopes to see if we have a leftmost point or 
; 3420 :         // a re-entrant point needing interval split.
; 3421 :         if ( (prev->X[1]-thisv->X[1])*(nextv->X[0]-thisv->X[0]) >
; 3422 :              (prev->X[0]-thisv->X[0])*(nextv->X[1]-thisv->X[1]) )

	fld	QWORD PTR [ecx+64]

; 3423 :         { // Leftmost point, so create interval
; 3424 :           if ( interval_count >= MAXGSFN )

	mov	edi, DWORD PTR _interval_count$[ebp]
	fsub	QWORD PTR [ebx+64]
	fld	QWORD PTR [esi+56]
	fsub	QWORD PTR [ebx+56]
	fmulp	ST(1), ST(0)
	fld	QWORD PTR [esi+64]
	fsub	QWORD PTR [ebx+64]
	fld	QWORD PTR [ecx+56]
	fsub	QWORD PTR [ebx+56]
	fmulp	ST(1), ST(0)
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	$LN76@gsfn_recur
	cmp	edi, 20					; 00000014H
	jge	$LN164@gsfn_recur

; 3426 :             return;
; 3427 :           }
; 3428 : 
; 3429 :           // find spot to insert in interval list
; 3430 :           for ( i = 0 ; i < interval_count ; i++ )

	xor	edx, edx
	cmp	edi, 4
	jl	SHORT $LC190@gsfn_recur
	lea	ecx, DWORD PTR _these_intervals$[ebp+8]
$LL194@gsfn_recur:

; 3431 :              if ( thisv->X[1] < these_intervals[i].b + thisv->X[0]*these_intervals[i].slope )

	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR [ebx+56]
	fadd	QWORD PTR [ecx]
	fcomp	QWORD PTR [ebx+64]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN204@gsfn_recur
	fld	QWORD PTR [ecx+40]
	fmul	QWORD PTR [ebx+56]
	fadd	QWORD PTR [ecx+32]
	fcomp	QWORD PTR [ebx+64]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN191@gsfn_recur
	fld	QWORD PTR [ecx+72]
	fmul	QWORD PTR [ebx+56]
	fadd	QWORD PTR [ecx+64]
	fcomp	QWORD PTR [ebx+64]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN192@gsfn_recur
	fld	QWORD PTR [ecx+104]
	fmul	QWORD PTR [ebx+56]
	fadd	QWORD PTR [ecx+96]
	fcomp	QWORD PTR [ebx+64]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN193@gsfn_recur

; 3426 :             return;
; 3427 :           }
; 3428 : 
; 3429 :           // find spot to insert in interval list
; 3430 :           for ( i = 0 ; i < interval_count ; i++ )

	add	edx, 4
	lea	eax, DWORD PTR [edi-3]
	sub	ecx, -128				; ffffff80H
	cmp	edx, eax
	jl	SHORT $LL194@gsfn_recur
$LC190@gsfn_recur:
	cmp	edi, edx
	jle	SHORT $LN220@gsfn_recur
	mov	ecx, edx
	shl	ecx, 5
	lea	ecx, DWORD PTR _these_intervals$[ebp+ecx+8]
	npad	3
$LC74@gsfn_recur:

; 3431 :              if ( thisv->X[1] < these_intervals[i].b + thisv->X[0]*these_intervals[i].slope )

	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR [ebx+56]
	fadd	QWORD PTR [ecx]
	fcomp	QWORD PTR [ebx+64]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN204@gsfn_recur

; 3426 :             return;
; 3427 :           }
; 3428 : 
; 3429 :           // find spot to insert in interval list
; 3430 :           for ( i = 0 ; i < interval_count ; i++ )

	inc	edx
	add	ecx, 32					; 00000020H
	cmp	edx, edi
	jl	SHORT $LC74@gsfn_recur
	jmp	SHORT $LN204@gsfn_recur
$LN191@gsfn_recur:

; 3431 :              if ( thisv->X[1] < these_intervals[i].b + thisv->X[0]*these_intervals[i].slope )

	inc	edx
	jmp	SHORT $LN204@gsfn_recur
$LN192@gsfn_recur:
	add	edx, 2
	jmp	SHORT $LN204@gsfn_recur
$LN193@gsfn_recur:
	add	edx, 3
$LN204@gsfn_recur:

; 3432 :                break;
; 3433 :           for ( j = interval_count ; j > i ; j-- )

	cmp	edi, edx
	jle	SHORT $LN220@gsfn_recur
	mov	eax, DWORD PTR _interval_count$[ebp]
	shl	edi, 5
	sub	eax, edx
	lea	edi, DWORD PTR _these_intervals$[ebp+edi]
	mov	DWORD PTR tv587[ebp], eax
$LL70@gsfn_recur:
	dec	DWORD PTR tv587[ebp]

; 3434 :              these_intervals[j] = these_intervals[j-1];

	lea	eax, DWORD PTR [edi-32]
	mov	ecx, 8
	mov	esi, eax
	rep movsd
	mov	edi, eax
	jne	SHORT $LL70@gsfn_recur

; 3432 :                break;
; 3433 :           for ( j = interval_count ; j > i ; j-- )

	mov	esi, DWORD PTR _nextv$91673[ebp]
$LN220@gsfn_recur:

; 3435 :           these_intervals[i].visible = polylist[polyspot];

	mov	ecx, DWORD PTR _polylist$GSCopy$[ebp]
	mov	eax, DWORD PTR _polyspot$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edi, DWORD PTR _gcount$GSCopy$[ebp]
	shl	edx, 5
	mov	ecx, edx
	mov	DWORD PTR _these_intervals$[ebp+ecx+24], eax
	mov	DWORD PTR tv1759[ebp], eax

; 3436 :           these_intervals[i].lowv = (polylist[polyspot] + 1) % gcount;

	inc	eax
	cdq
	idiv	edi
	mov	DWORD PTR _these_intervals$[ebp+ecx], edx

; 3437 :           these_intervals[i].topv = (polylist[polyspot] + gcount - 1) % gcount;

	mov	edx, DWORD PTR tv1759[ebp]
	lea	eax, DWORD PTR [edx+edi-1]
	cdq
	idiv	edi

; 3438 :           these_intervals[i].slope = (thisv->X[1]-nextv->X[1])/(thisv->X[0]-nextv->X[0]);
; 3439 :           these_intervals[i].b = thisv->X[1] - these_intervals[i].slope*thisv->X[0];
; 3440 :           interval_count++;

	inc	DWORD PTR _interval_count$[ebp]
	mov	DWORD PTR _these_intervals$[ebp+ecx+4], edx
	fld	QWORD PTR [ebx+64]
	fsub	QWORD PTR [esi+64]
	fld	QWORD PTR [ebx+56]
	fsub	QWORD PTR [esi+56]
	fdivp	ST(1), ST(0)
	fst	QWORD PTR _these_intervals$[ebp+ecx+16]
	fmul	QWORD PTR [ebx+56]
	fsubr	QWORD PTR [ebx+64]
	fstp	QWORD PTR _these_intervals$[ebp+ecx+8]

; 3441 :         }
; 3442 :         else

	jmp	$LN211@gsfn_recur
$LN76@gsfn_recur:

; 3443 :         { // Re-entrant point, so insert "edge" between visible vertex 
; 3444 :           // and this vertex, splitting polygon into two for recursion.
; 3445 :           // Find and split interval.
; 3446 :           int old_visible;
; 3447 :           int *new_polylist;
; 3448 :           int new_polycount;
; 3449 :           int new_polyspot;
; 3450 :           int splitterv;
; 3451 :           int jj;
; 3452 :           int low_polyspot;
; 3453 :           int new_gcount;
; 3454 :           struct graphdata *new_glist;
; 3455 : 
; 3456 :           for ( i = 0 ; i < interval_count ; i++ )

	xor	edx, edx
	cmp	edi, 4
	jl	SHORT $LC195@gsfn_recur
	lea	ecx, DWORD PTR _these_intervals$[ebp+8]
$LL199@gsfn_recur:

; 3457 :           { REAL y = these_intervals[i].b + these_intervals[i].slope*thisv->X[0];

	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR [ebx+56]
	fadd	QWORD PTR [ecx]

; 3458 :             if ( thisv->X[1] < y )

	fcomp	QWORD PTR [ebx+64]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN205@gsfn_recur

; 3457 :           { REAL y = these_intervals[i].b + these_intervals[i].slope*thisv->X[0];

	fld	QWORD PTR [ecx+40]
	fmul	QWORD PTR [ebx+56]
	fadd	QWORD PTR [ecx+32]

; 3458 :             if ( thisv->X[1] < y )

	fcomp	QWORD PTR [ebx+64]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN196@gsfn_recur

; 3457 :           { REAL y = these_intervals[i].b + these_intervals[i].slope*thisv->X[0];

	fld	QWORD PTR [ecx+72]
	fmul	QWORD PTR [ebx+56]
	fadd	QWORD PTR [ecx+64]

; 3458 :             if ( thisv->X[1] < y )

	fcomp	QWORD PTR [ebx+64]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN197@gsfn_recur

; 3457 :           { REAL y = these_intervals[i].b + these_intervals[i].slope*thisv->X[0];

	fld	QWORD PTR [ecx+104]
	fmul	QWORD PTR [ebx+56]
	fadd	QWORD PTR [ecx+96]

; 3458 :             if ( thisv->X[1] < y )

	fcomp	QWORD PTR [ebx+64]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN198@gsfn_recur

; 3443 :         { // Re-entrant point, so insert "edge" between visible vertex 
; 3444 :           // and this vertex, splitting polygon into two for recursion.
; 3445 :           // Find and split interval.
; 3446 :           int old_visible;
; 3447 :           int *new_polylist;
; 3448 :           int new_polycount;
; 3449 :           int new_polyspot;
; 3450 :           int splitterv;
; 3451 :           int jj;
; 3452 :           int low_polyspot;
; 3453 :           int new_gcount;
; 3454 :           struct graphdata *new_glist;
; 3455 : 
; 3456 :           for ( i = 0 ; i < interval_count ; i++ )

	add	edx, 4
	lea	eax, DWORD PTR [edi-3]
	sub	ecx, -128				; ffffff80H
	cmp	edx, eax
	jl	SHORT $LL199@gsfn_recur
$LC195@gsfn_recur:
	cmp	edx, edi
	jge	SHORT $LN205@gsfn_recur
	mov	ecx, edx
	shl	ecx, 5
	lea	ecx, DWORD PTR _these_intervals$[ebp+ecx+8]
$LC66@gsfn_recur:

; 3457 :           { REAL y = these_intervals[i].b + these_intervals[i].slope*thisv->X[0];

	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR [ebx+56]
	fadd	QWORD PTR [ecx]

; 3458 :             if ( thisv->X[1] < y )

	fcomp	QWORD PTR [ebx+64]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN205@gsfn_recur

; 3443 :         { // Re-entrant point, so insert "edge" between visible vertex 
; 3444 :           // and this vertex, splitting polygon into two for recursion.
; 3445 :           // Find and split interval.
; 3446 :           int old_visible;
; 3447 :           int *new_polylist;
; 3448 :           int new_polycount;
; 3449 :           int new_polyspot;
; 3450 :           int splitterv;
; 3451 :           int jj;
; 3452 :           int low_polyspot;
; 3453 :           int new_gcount;
; 3454 :           struct graphdata *new_glist;
; 3455 : 
; 3456 :           for ( i = 0 ; i < interval_count ; i++ )

	inc	edx
	add	ecx, 32					; 00000020H
	cmp	edx, edi
	jl	SHORT $LC66@gsfn_recur
	jmp	SHORT $LN205@gsfn_recur
$LN196@gsfn_recur:

; 3458 :             if ( thisv->X[1] < y )

	inc	edx
	jmp	SHORT $LN205@gsfn_recur
$LN197@gsfn_recur:
	add	edx, 2
	jmp	SHORT $LN205@gsfn_recur
$LN198@gsfn_recur:
	add	edx, 3
$LN205@gsfn_recur:

; 3459 :               break;
; 3460 :           }
; 3461 :           if ( i <= 0 )

	test	edx, edx
	jle	$LN165@gsfn_recur

; 3465 :             return;
; 3466 :           }
; 3467 :           i--; // since actually detected the interval above the one we want

	dec	edx

; 3468 :           old_visible = these_intervals[i].visible;

	mov	ecx, edx
	shl	ecx, 5
	mov	eax, DWORD PTR _these_intervals$[ebp+ecx+24]
	lea	edi, DWORD PTR _these_intervals$[ebp+ecx+24]
	mov	DWORD PTR _i$[ebp], edx
	mov	DWORD PTR tv1570[ebp], ecx
	mov	DWORD PTR tv1636[ebp], edi
	mov	DWORD PTR _old_visible$91730[ebp], eax

; 3469 :           for ( j = interval_count ; j > i ; j-- )

	cmp	DWORD PTR _interval_count$[ebp], edx
	jle	SHORT $LN59@gsfn_recur

; 3465 :             return;
; 3466 :           }
; 3467 :           i--; // since actually detected the interval above the one we want

	mov	ecx, DWORD PTR _interval_count$[ebp]
	mov	eax, ecx
	shl	eax, 5
	sub	ecx, edx
	lea	eax, DWORD PTR _these_intervals$[ebp+eax]
	mov	DWORD PTR tv1106[ebp], ecx
	npad	7
$LL61@gsfn_recur:

; 3470 :             these_intervals[j] = these_intervals[j-1];

	lea	esi, DWORD PTR [eax-32]
	mov	edi, eax
	mov	ecx, 8
	add	eax, -32				; ffffffe0H
	dec	DWORD PTR tv1106[ebp]
	rep movsd
	jne	SHORT $LL61@gsfn_recur

; 3469 :           for ( j = interval_count ; j > i ; j-- )

	mov	esi, DWORD PTR _nextv$91673[ebp]
	mov	ecx, DWORD PTR tv1570[ebp]
	mov	edi, DWORD PTR tv1636[ebp]
$LN59@gsfn_recur:

; 3471 :           these_intervals[i].visible = polylist[polyspot];

	mov	edx, DWORD PTR _polylist$GSCopy$[ebp]
	mov	eax, DWORD PTR _polyspot$[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edi], eax

; 3472 :           these_intervals[i].topv = polylist[polyspot];

	mov	DWORD PTR _these_intervals$[ebp+ecx+4], eax

; 3473 :           these_intervals[i+1].visible = polylist[polyspot];

	mov	DWORD PTR _these_intervals$[ebp+ecx+56], eax

; 3474 :           these_intervals[i+1].lowv = (polylist[polyspot] + 1) % gcount;

	lea	edx, DWORD PTR _these_intervals$[ebp+ecx+32]
	inc	eax
	mov	DWORD PTR tv1833[ebp], edx
	cdq
	idiv	DWORD PTR _gcount$GSCopy$[ebp]
	mov	eax, DWORD PTR tv1833[ebp]

; 3475 :           these_intervals[i+1].slope = (thisv->X[1]-nextv->X[1])/(thisv->X[0]-nextv->X[0]);
; 3476 :           these_intervals[i+1].b = thisv->X[1] - these_intervals[i+1].slope*thisv->X[0];
; 3477 :           interval_count++; 

	inc	DWORD PTR _interval_count$[ebp]

; 3478 :           // Split vertex list 
; 3479 :           new_polylist = (int*)temp_calloc(polycount,sizeof(int));

	push	3479					; 00000d97H
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	push	4
	mov	DWORD PTR [eax], edx
	fld	QWORD PTR [ebx+64]
	fsub	QWORD PTR [esi+64]
	fld	QWORD PTR [ebx+56]
	fsub	QWORD PTR [esi+56]
	mov	esi, DWORD PTR _polycount$GSCopy$[ebp]
	push	esi
	fdivp	ST(1), ST(0)
	fst	QWORD PTR _these_intervals$[ebp+ecx+48]
	fmul	QWORD PTR [ebx+56]
	fsubr	QWORD PTR [ebx+64]
	fstp	QWORD PTR _these_intervals$[ebp+ecx+40]
	call	_kb_temp_calloc

; 3480 :           new_glist = (struct graphdata*)temp_calloc(polycount,sizeof(struct graphdata));

	push	3480					; 00000d98H
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	push	144					; 00000090H
	push	esi
	mov	DWORD PTR _new_polylist$91731[ebp], eax
	call	_kb_temp_calloc

; 3481 :           new_polycount = 0;
; 3482 :           splitterv = polylist[polyspot];

	mov	ecx, DWORD PTR _polylist$GSCopy$[ebp]
	mov	edx, DWORD PTR _polyspot$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]

; 3483 :           if ( old_visible < splitterv )

	mov	esi, DWORD PTR _old_visible$91730[ebp]

; 3484 :           { // glist starts in upper polygon
; 3485 :             // construct new vertex lists
; 3486 :             for ( j = 0, jj = 0, new_gcount = 0 ; j < gcount ; j++ )

	xor	ebx, ebx
	add	esp, 32					; 00000020H
	mov	DWORD PTR _new_glist$91738[ebp], eax
	mov	DWORD PTR _new_polycount$91732[ebp], 0
	mov	DWORD PTR _jj$91735[ebp], ebx
	mov	DWORD PTR _new_gcount$91737[ebp], ebx
	cmp	esi, edx
	jge	$LN58@gsfn_recur
	xor	ecx, ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	DWORD PTR _gcount$GSCopy$[ebp], ebx
	jle	$LN216@gsfn_recur
	mov	eax, DWORD PTR _glist$GSCopy$[ebp]
	mov	edi, DWORD PTR _new_glist$91738[ebp]
	mov	DWORD PTR tv2958[ebp], eax
	mov	DWORD PTR tv2962[ebp], edi
$LL225@gsfn_recur:

; 3487 :             { if ( j >= splitterv || j <= old_visible )

	cmp	ecx, edx
	jge	SHORT $LN53@gsfn_recur
	cmp	ecx, esi
	jg	SHORT $LN54@gsfn_recur
$LN53@gsfn_recur:

; 3488 :               { new_glist[new_gcount] = glist[j];

	mov	edi, DWORD PTR tv2962[ebp]
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	rep movsd

; 3489 :                 new_glist[new_gcount].etype = new_gcount;  // order index in new loop

	mov	ecx, DWORD PTR tv2962[ebp]

; 3490 :                 new_gcount++;

	mov	esi, DWORD PTR _old_visible$91730[ebp]
	mov	WORD PTR [ecx+124], bx
	inc	ebx
	add	ecx, 144				; 00000090H
	mov	DWORD PTR tv2962[ebp], ecx
	mov	ecx, DWORD PTR _j$[ebp]
$LN54@gsfn_recur:

; 3491 :               }
; 3492 :               if ( j <= splitterv && j >= old_visible )

	cmp	ecx, edx
	jg	SHORT $LN56@gsfn_recur
	cmp	ecx, esi
	jl	SHORT $LN56@gsfn_recur

; 3493 :               { glist[jj] = glist[j];

	mov	edi, DWORD PTR tv2958[ebp]
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	rep movsd

; 3494 :                 glist[jj].etype = jj;

	mov	ecx, DWORD PTR _jj$91735[ebp]
	mov	esi, DWORD PTR tv2958[ebp]
	mov	WORD PTR [esi+124], cx

; 3495 :                 jj++;

	inc	ecx
	add	esi, 144				; 00000090H
	mov	DWORD PTR _jj$91735[ebp], ecx
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv2958[ebp], esi
	mov	esi, DWORD PTR _old_visible$91730[ebp]
$LN56@gsfn_recur:

; 3484 :           { // glist starts in upper polygon
; 3485 :             // construct new vertex lists
; 3486 :             for ( j = 0, jj = 0, new_gcount = 0 ; j < gcount ; j++ )

	inc	ecx
	add	eax, 144				; 00000090H
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR _gcount$GSCopy$[ebp]
	jl	$LL225@gsfn_recur

; 3490 :                 new_gcount++;

	mov	DWORD PTR _new_gcount$91737[ebp], ebx
$LN216@gsfn_recur:

; 3484 :           { // glist starts in upper polygon
; 3485 :             // construct new vertex lists
; 3486 :             for ( j = 0, jj = 0, new_gcount = 0 ; j < gcount ; j++ )

	mov	edi, DWORD PTR _i$[ebp]

; 3496 :               }
; 3497 :             }
; 3498 :             gcount = jj;

	mov	eax, DWORD PTR _jj$91735[ebp]
	mov	DWORD PTR _gcount$GSCopy$[ebp], eax

; 3499 :             // fix up interval vertices
; 3500 :             for ( j = 0 ; j <= i ; j++ )

	test	edi, edi
	js	SHORT $LN229@gsfn_recur

; 3496 :               }
; 3497 :             }
; 3498 :             gcount = jj;

	lea	eax, DWORD PTR _these_intervals$[ebp+4]
	lea	ecx, DWORD PTR [edi+1]
	npad	2
$LL51@gsfn_recur:

; 3501 :             { these_intervals[j].lowv -= old_visible;

	sub	DWORD PTR [eax-4], esi

; 3502 :               these_intervals[j].topv -= old_visible;

	sub	DWORD PTR [eax], esi

; 3503 :               these_intervals[j].visible -= old_visible;

	sub	DWORD PTR [eax+20], esi
	add	eax, 32					; 00000020H
	dec	ecx
	jne	SHORT $LL51@gsfn_recur
$LN229@gsfn_recur:

; 3504 :             }
; 3505 :             for ( j = i+1 ; j < interval_count ; j++ )

	lea	ecx, DWORD PTR [edi+1]
	mov	edi, DWORD PTR _interval_count$[ebp]
	mov	DWORD PTR tv1575[ebp], ecx
	cmp	ecx, edi
	jge	SHORT $LN46@gsfn_recur
	mov	eax, ecx
	shl	eax, 5
	lea	eax, DWORD PTR _these_intervals$[ebp+eax+4]
	sub	edi, ecx
	npad	4
$LL48@gsfn_recur:

; 3506 :             { if ( these_intervals[j].lowv >= splitterv )

	mov	ecx, DWORD PTR [eax-4]
	cmp	ecx, edx
	jl	SHORT $LN45@gsfn_recur

; 3507 :                 these_intervals[j].lowv -= (splitterv-old_visible-1);

	sub	ecx, edx
	lea	ecx, DWORD PTR [ecx+esi+1]
	mov	DWORD PTR [eax-4], ecx
$LN45@gsfn_recur:

; 3508 :               if ( these_intervals[j].topv >= splitterv )

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, edx
	jl	SHORT $LN44@gsfn_recur

; 3509 :                 these_intervals[j].topv -= (splitterv-old_visible-1);

	sub	ecx, edx
	lea	ecx, DWORD PTR [ecx+esi+1]
	mov	DWORD PTR [eax], ecx
$LN44@gsfn_recur:

; 3510 :               if ( these_intervals[j].visible >= splitterv )

	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, edx
	jl	SHORT $LN47@gsfn_recur

; 3511 :                 these_intervals[j].visible -= (splitterv-old_visible-1);

	sub	ecx, edx
	lea	ecx, DWORD PTR [ecx+esi+1]
	mov	DWORD PTR [eax+20], ecx
$LN47@gsfn_recur:

; 3504 :             }
; 3505 :             for ( j = i+1 ; j < interval_count ; j++ )

	add	eax, 32					; 00000020H
	dec	edi
	jne	SHORT $LL48@gsfn_recur
$LN46@gsfn_recur:

; 3512 :             }
; 3513 :             // construct new polylist
; 3514 :             for ( j = 0 ; j < polycount ; j++ )

	xor	ecx, ecx
	mov	ebx, ecx
	cmp	DWORD PTR _polycount$GSCopy$[ebp], ecx
	jle	SHORT $LN40@gsfn_recur
$LL42@gsfn_recur:

; 3515 :               if ( polylist[j] <= old_visible )

	mov	eax, DWORD PTR _polylist$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	cmp	eax, esi
	jg	SHORT $LN39@gsfn_recur

; 3516 :               { if ( j == polyspot )

	cmp	ecx, DWORD PTR _polyspot$[ebp]
	jne	SHORT $LN221@gsfn_recur

; 3517 :                   new_polyspot = new_polycount;

	mov	DWORD PTR _new_polyspot$91733[ebp], ebx

; 3518 :                 new_polylist[new_polycount++] = polylist[j];

	jmp	SHORT $LN221@gsfn_recur
$LN39@gsfn_recur:

; 3519 :               }
; 3520 :               else if ( polylist[j] >= splitterv )

	cmp	eax, edx
	jl	SHORT $LN41@gsfn_recur

; 3521 :               { if ( j == polyspot )

	cmp	ecx, DWORD PTR _polyspot$[ebp]
	jne	SHORT $LN222@gsfn_recur

; 3522 :                   new_polyspot = new_polycount;

	mov	DWORD PTR _new_polyspot$91733[ebp], ebx
$LN222@gsfn_recur:

; 3523 :                 new_polylist[new_polycount++] = polylist[j] - (splitterv-old_visible-1);

	sub	eax, edx
	lea	eax, DWORD PTR [eax+esi+1]
$LN221@gsfn_recur:
	mov	edi, DWORD PTR _new_polylist$91731[ebp]
	mov	DWORD PTR [edi+ebx*4], eax
	inc	ebx
$LN41@gsfn_recur:

; 3512 :             }
; 3513 :             // construct new polylist
; 3514 :             for ( j = 0 ; j < polycount ; j++ )

	inc	ecx
	cmp	ecx, DWORD PTR _polycount$GSCopy$[ebp]
	jl	SHORT $LL42@gsfn_recur
$LN40@gsfn_recur:

; 3524 :               }
; 3525 : 
; 3526 :             // reconstruct lower polylist
; 3527 :             for ( j = 0, jj = 0 ; j < polycount ; j++ )

	xor	edi, edi
	xor	eax, eax
	mov	DWORD PTR _j$[ebp], edi
	cmp	DWORD PTR _polycount$GSCopy$[ebp], eax
	jle	$LN208@gsfn_recur
	npad	8
$LL223@gsfn_recur:

; 3528 :               if ( (polylist[j] <= splitterv) && (polylist[j] >= old_visible) )

	mov	ecx, DWORD PTR _polylist$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	cmp	ecx, edx
	jg	SHORT $LN33@gsfn_recur
	cmp	ecx, esi
	jl	SHORT $LN33@gsfn_recur

; 3529 :               { if ( j == polyspot )

	mov	edi, DWORD PTR _polyspot$[ebp]
	cmp	DWORD PTR _j$[ebp], edi
	jne	SHORT $LN30@gsfn_recur

; 3530 :                   low_polyspot = jj;

	mov	DWORD PTR _low_polyspot$91736[ebp], eax
$LN30@gsfn_recur:

; 3531 :                 polylist[jj++] = polylist[j] - old_visible;

	mov	edi, DWORD PTR _polylist$GSCopy$[ebp]
	sub	ecx, esi
	mov	DWORD PTR [edi+eax*4], ecx
	mov	edi, DWORD PTR _j$[ebp]
	inc	eax
$LN33@gsfn_recur:

; 3524 :               }
; 3525 : 
; 3526 :             // reconstruct lower polylist
; 3527 :             for ( j = 0, jj = 0 ; j < polycount ; j++ )

	inc	edi
	mov	DWORD PTR _j$[ebp], edi
	cmp	edi, DWORD PTR _polycount$GSCopy$[ebp]
	jl	SHORT $LL223@gsfn_recur

; 3532 :               }
; 3533 :             polycount = jj;
; 3534 :             polyspot = low_polyspot;
; 3535 :             }
; 3536 :           else

	jmp	$LN208@gsfn_recur
$LN58@gsfn_recur:

; 3537 :           { // glist starts in lower polygon
; 3538 :             // construct new vertex lists
; 3539 :             for ( j = 0, jj = 0, new_gcount = 0 ; j < gcount ; j++ )

	cmp	DWORD PTR _gcount$GSCopy$[ebp], ebx
	jle	$LN217@gsfn_recur
	mov	eax, DWORD PTR _glist$GSCopy$[ebp]
	mov	ecx, DWORD PTR _new_glist$91738[ebp]
	mov	DWORD PTR tv3306[ebp], eax
	mov	DWORD PTR tv3310[ebp], ecx
	npad	4
$LL28@gsfn_recur:

; 3540 :             { if ( j >= splitterv && j <= old_visible )            

	cmp	ebx, edx
	jl	SHORT $LN23@gsfn_recur
	cmp	ebx, esi
	jg	SHORT $LN25@gsfn_recur

; 3541 :               { new_glist[new_gcount] = glist[j];

	mov	edi, DWORD PTR tv3310[ebp]
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	rep movsd

; 3542 :                 new_glist[new_gcount].etype = new_gcount;

	mov	ecx, DWORD PTR _new_gcount$91737[ebp]
	mov	esi, DWORD PTR tv3310[ebp]
	mov	WORD PTR [esi+124], cx

; 3543 :                 new_gcount++;

	inc	ecx
	add	esi, 144				; 00000090H
	mov	DWORD PTR tv3310[ebp], esi
	mov	esi, DWORD PTR _old_visible$91730[ebp]
	mov	DWORD PTR _new_gcount$91737[ebp], ecx
$LN25@gsfn_recur:

; 3544 :               }
; 3545 :               if ( j <= splitterv || j >= old_visible )

	cmp	ebx, edx
	jle	SHORT $LN23@gsfn_recur
	cmp	ebx, esi
	jl	SHORT $LN27@gsfn_recur
$LN23@gsfn_recur:

; 3546 :               { glist[jj] = glist[j];

	mov	edi, DWORD PTR tv3306[ebp]
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	rep movsd

; 3547 :                 glist[jj].etype = jj;

	mov	ecx, DWORD PTR _jj$91735[ebp]
	mov	esi, DWORD PTR tv3306[ebp]
	mov	WORD PTR [esi+124], cx

; 3548 :                 jj++;

	inc	ecx
	add	esi, 144				; 00000090H
	mov	DWORD PTR tv3306[ebp], esi
	mov	esi, DWORD PTR _old_visible$91730[ebp]
	mov	DWORD PTR _jj$91735[ebp], ecx
$LN27@gsfn_recur:

; 3537 :           { // glist starts in lower polygon
; 3538 :             // construct new vertex lists
; 3539 :             for ( j = 0, jj = 0, new_gcount = 0 ; j < gcount ; j++ )

	inc	ebx
	add	eax, 144				; 00000090H
	cmp	ebx, DWORD PTR _gcount$GSCopy$[ebp]
	jl	$LL28@gsfn_recur
$LN217@gsfn_recur:

; 3552 :             // adjust interval vertices
; 3553 :             for ( j = 0 ; j <= i ; j++ )

	mov	ebx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _jj$91735[ebp]
	mov	DWORD PTR _gcount$GSCopy$[ebp], eax
	test	ebx, ebx
	js	SHORT $LN20@gsfn_recur

; 3549 :               }
; 3550 :             }
; 3551 :             gcount = jj;

	lea	eax, DWORD PTR _these_intervals$[ebp+4]
	lea	edi, DWORD PTR [ebx+1]
$LL22@gsfn_recur:

; 3554 :             { if ( these_intervals[j].lowv >= old_visible )

	mov	ecx, DWORD PTR [eax-4]
	cmp	ecx, esi
	jl	SHORT $LN19@gsfn_recur

; 3555 :                  these_intervals[j].lowv -= ( old_visible - splitterv - 1);

	sub	ecx, esi
	lea	ecx, DWORD PTR [ecx+edx+1]
	mov	DWORD PTR [eax-4], ecx
$LN19@gsfn_recur:

; 3556 :               if ( these_intervals[j].topv >= old_visible )

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, esi
	jl	SHORT $LN18@gsfn_recur

; 3557 :                  these_intervals[j].topv -= ( old_visible - splitterv - 1);

	sub	ecx, esi
	lea	ecx, DWORD PTR [ecx+edx+1]
	mov	DWORD PTR [eax], ecx
$LN18@gsfn_recur:

; 3558 :               if ( these_intervals[j].visible >= old_visible )

	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, esi
	jl	SHORT $LN21@gsfn_recur

; 3559 :                  these_intervals[j].visible -= ( old_visible - splitterv - 1);

	sub	ecx, esi
	lea	ecx, DWORD PTR [ecx+edx+1]
	mov	DWORD PTR [eax+20], ecx
$LN21@gsfn_recur:

; 3552 :             // adjust interval vertices
; 3553 :             for ( j = 0 ; j <= i ; j++ )

	add	eax, 32					; 00000020H
	dec	edi
	jne	SHORT $LL22@gsfn_recur
$LN20@gsfn_recur:

; 3560 :             }
; 3561 :             for ( j = i+1 ; j < interval_count ; j++ )

	mov	ecx, DWORD PTR _interval_count$[ebp]
	lea	edi, DWORD PTR [ebx+1]
	mov	DWORD PTR tv1575[ebp], edi
	cmp	edi, ecx
	jge	SHORT $LN226@gsfn_recur
	mov	eax, edi
	shl	eax, 5
	lea	eax, DWORD PTR _these_intervals$[ebp+eax+4]
	sub	ecx, edi
$LL16@gsfn_recur:

; 3562 :             { these_intervals[j].lowv -= splitterv;

	sub	DWORD PTR [eax-4], edx

; 3563 :               these_intervals[j].topv -= splitterv;

	sub	DWORD PTR [eax], edx

; 3564 :               these_intervals[j].visible -= splitterv;

	sub	DWORD PTR [eax+20], edx
	add	eax, 32					; 00000020H
	dec	ecx
	jne	SHORT $LL16@gsfn_recur
$LN226@gsfn_recur:

; 3565 :             }
; 3566 :             // construct new polylist
; 3567 :             for ( j = 0 ; j < polycount ; j++ )

	xor	ecx, ecx
	cmp	DWORD PTR _polycount$GSCopy$[ebp], ecx
	jle	SHORT $LN209@gsfn_recur
	mov	ebx, DWORD PTR _new_polylist$91731[ebp]
	mov	edi, ecx
$LL13@gsfn_recur:

; 3568 :               if (  (polylist[j] >= splitterv) && (polylist[j] <= old_visible) )

	mov	eax, DWORD PTR _polylist$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	cmp	eax, edx
	jl	SHORT $LN12@gsfn_recur
	cmp	eax, esi
	jg	SHORT $LN12@gsfn_recur

; 3569 :               { if ( j == polyspot )

	cmp	ecx, DWORD PTR _polyspot$[ebp]
	jne	SHORT $LN9@gsfn_recur

; 3570 :                   new_polyspot = new_polycount;

	mov	DWORD PTR _new_polyspot$91733[ebp], edi
$LN9@gsfn_recur:

; 3571 :                 new_polylist[new_polycount++] = polylist[j] - splitterv;

	sub	eax, edx
	mov	DWORD PTR [ebx+edi*4], eax
	inc	edi
$LN12@gsfn_recur:

; 3565 :             }
; 3566 :             // construct new polylist
; 3567 :             for ( j = 0 ; j < polycount ; j++ )

	inc	ecx
	cmp	ecx, DWORD PTR _polycount$GSCopy$[ebp]
	jl	SHORT $LL13@gsfn_recur

; 3571 :                 new_polylist[new_polycount++] = polylist[j] - splitterv;

	mov	DWORD PTR _new_polycount$91732[ebp], edi
$LN209@gsfn_recur:

; 3572 :               }
; 3573 :             // purge old polylist
; 3574 :             for ( j = 0, jj = 0 ; j < polycount ; j++ )

	xor	eax, eax
	xor	ebx, ebx
	cmp	DWORD PTR _polycount$GSCopy$[ebp], eax
	jle	SHORT $LN210@gsfn_recur
$LL8@gsfn_recur:

; 3575 :               if ( polylist[j] <= splitterv )

	mov	ecx, DWORD PTR _polylist$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	cmp	ecx, edx
	jg	SHORT $LN5@gsfn_recur

; 3576 :               { if ( j == polyspot )

	cmp	ebx, DWORD PTR _polyspot$[ebp]
	jne	SHORT $LN218@gsfn_recur

; 3577 :                   low_polyspot = jj;

	mov	DWORD PTR _low_polyspot$91736[ebp], eax

; 3578 :                 polylist[jj++] = polylist[j];

	jmp	SHORT $LN218@gsfn_recur
$LN5@gsfn_recur:

; 3579 :               }
; 3580 :               else if ( polylist[j] >= old_visible )

	cmp	ecx, esi
	jl	SHORT $LN7@gsfn_recur

; 3581 :               { if ( j == polyspot )

	cmp	ebx, DWORD PTR _polyspot$[ebp]
	jne	SHORT $LN219@gsfn_recur

; 3582 :                   low_polyspot = jj;

	mov	DWORD PTR _low_polyspot$91736[ebp], eax
$LN219@gsfn_recur:

; 3583 :                 polylist[jj++] = polylist[j] - ( old_visible - splitterv - 1);

	sub	ecx, esi
	lea	ecx, DWORD PTR [ecx+edx+1]
$LN218@gsfn_recur:
	mov	edi, DWORD PTR _polylist$GSCopy$[ebp]
	mov	DWORD PTR [edi+eax*4], ecx
	inc	eax
$LN7@gsfn_recur:

; 3572 :               }
; 3573 :             // purge old polylist
; 3574 :             for ( j = 0, jj = 0 ; j < polycount ; j++ )

	inc	ebx
	cmp	ebx, DWORD PTR _polycount$GSCopy$[ebp]
	jl	SHORT $LL8@gsfn_recur
$LN210@gsfn_recur:

; 3584 :               }
; 3585 :             polycount = jj;
; 3586 :             polyspot = low_polyspot;

	mov	ebx, DWORD PTR _new_polycount$91732[ebp]
$LN208@gsfn_recur:
	mov	edx, DWORD PTR _low_polyspot$91736[ebp]

; 3587 :           }
; 3588 : polylist_check(glist,gcount,polylist,polycount);

	mov	ecx, DWORD PTR _gcount$GSCopy$[ebp]
	push	eax
	mov	DWORD PTR _polycount$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _polylist$GSCopy$[ebp]
	push	eax
	mov	DWORD PTR _polyspot$[ebp], edx
	mov	edx, DWORD PTR _glist$GSCopy$[ebp]
	push	ecx
	push	edx
	call	_polylist_check

; 3589 : polylist_check(new_glist,new_gcount,new_polylist,new_polycount);

	mov	eax, DWORD PTR _new_polylist$91731[ebp]
	mov	edi, DWORD PTR _new_gcount$91737[ebp]
	mov	esi, DWORD PTR _new_glist$91738[ebp]
	push	ebx
	push	eax
	push	edi
	push	esi
	call	_polylist_check

; 3590 :           // recur on top polygon
; 3591 :           gsfn_recur_left_to_right(
; 3592 :            new_glist, // list of vertices
; 3593 :            new_gcount,  // length of glist
; 3594 :            new_polylist, // indices into glist of current polygon vertices
; 3595 :            new_polycount, // length of polylist
; 3596 :            new_polyspot,  // next vertex to consider in polylist
; 3597 :            these_intervals+i+1, // list of current intervals
; 3598 :            interval_count-i-1,  // number of current intervals
; 3599 :            f_id,
; 3600 :            mode
; 3601 :            );

	mov	ecx, DWORD PTR _mode$[ebp]
	mov	eax, DWORD PTR _interval_count$[ebp]
	sub	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _f_id$[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv1833[ebp]
	push	edx
	mov	edx, DWORD PTR _new_polyspot$91733[ebp]
	dec	eax
	push	eax
	push	ecx
	push	edx
	push	ebx
	mov	ebx, DWORD PTR _new_polylist$91731[ebp]
	push	ebx
	push	edi
	push	esi
	call	_gsfn_recur_left_to_right
	add	esp, 68					; 00000044H

; 3602 :           temp_free((char*)new_polylist);

	push	ebx
	call	_temp_free

; 3603 :           temp_free((char*)new_glist);

	push	esi
	call	_temp_free

; 3604 :           // And then keep going on lower polygon.
; 3605 :           interval_count = i+1;

	mov	eax, DWORD PTR tv1575[ebp]
	add	esp, 8
	mov	DWORD PTR _interval_count$[ebp], eax
$LN211@gsfn_recur:

; 3308 :     these_intervals[i] = intervals[i];
; 3309 : 
; 3310 :   for(;;)
; 3311 :   { struct graphdata *thisv,*prev,*nextv;
; 3312 : 
; 3313 :     // next vertex
; 3314 :     polyspot++;

	mov	eax, DWORD PTR _polyspot$[ebp]
	inc	eax
	mov	DWORD PTR _polyspot$[ebp], eax

; 3315 : 
; 3316 :     if ( polyspot >= polycount )

	cmp	eax, DWORD PTR _polycount$GSCopy$[ebp]
	jl	$LL121@gsfn_recur
$LN163@gsfn_recur:

; 3317 :     { if ( mode == GSFN_LEFT_TO_RIGHT )

	cmp	DWORD PTR _mode$[ebp], 1
	jne	$LN118@gsfn_recur

; 3318 :       { // Done with left-to-right regularization sweep,
; 3319 :         // so reverse sweep coordinate and go to right-to-left sweep.
; 3320 :         for ( i = 0 ; i < gcount ; i++ )

	mov	edi, DWORD PTR _gcount$GSCopy$[ebp]
	fld	QWORD PTR __real@bff0000000000000
	xor	edx, edx
	cmp	edi, 4
	jl	$LN214@gsfn_recur
	mov	eax, DWORD PTR _glist$GSCopy$[ebp]
	lea	ecx, DWORD PTR [edi-4]
	shr	ecx, 2
	add	eax, 64					; 00000040H
	inc	ecx
	lea	edx, DWORD PTR [ecx*4]
$LN202@gsfn_recur:

; 3321 :         { glist[i].X[0] *= -1;

	fld	QWORD PTR [eax-8]

; 3322 :           glist[i].X[1] *= -1;

	add	eax, 576				; 00000240H
	dec	ecx
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-584]
	fld	QWORD PTR [eax-576]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-576]
	fld	QWORD PTR [eax-440]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-440]
	fld	QWORD PTR [eax-432]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-432]
	fld	QWORD PTR [eax-296]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-296]
	fld	QWORD PTR [eax-288]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-288]
	fld	QWORD PTR [eax-152]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-152]
	fld	QWORD PTR [eax-144]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-144]
	jne	SHORT $LN202@gsfn_recur
$LN214@gsfn_recur:

; 3318 :       { // Done with left-to-right regularization sweep,
; 3319 :         // so reverse sweep coordinate and go to right-to-left sweep.
; 3320 :         for ( i = 0 ; i < gcount ; i++ )

	cmp	edx, edi
	jge	SHORT $LN238@gsfn_recur
	mov	eax, DWORD PTR _glist$GSCopy$[ebp]
	lea	ecx, DWORD PTR [edx+edx*8]
	add	ecx, ecx
	lea	eax, DWORD PTR [eax+ecx*8+64]
	mov	ecx, edi
	sub	ecx, edx
$LC117@gsfn_recur:

; 3321 :         { glist[i].X[0] *= -1;

	fld	QWORD PTR [eax-8]
	add	eax, 144				; 00000090H
	dec	ecx
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-152]

; 3322 :           glist[i].X[1] *= -1;

	fld	QWORD PTR [eax-144]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-144]
	jne	SHORT $LC117@gsfn_recur
$LN238@gsfn_recur:

; 3323 :         }
; 3324 :         for ( i = 0 ; i < polycount/2 ; i++ )

	mov	ebx, DWORD PTR _polycount$GSCopy$[ebp]
	fstp	ST(0)
	mov	esi, DWORD PTR _polylist$GSCopy$[ebp]
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN112@gsfn_recur
	lea	edx, DWORD PTR [esi+ebx*4-4]
	npad	1
$LL114@gsfn_recur:

; 3325 :         { int temp = polylist[i];
; 3326 :           polylist[i] = polylist[polycount-i-1];

	mov	ebx, DWORD PTR [edx]
	mov	edi, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [esi+ecx*4], ebx

; 3327 :           polylist[polycount-i-1] = temp;

	mov	DWORD PTR [edx], edi
	inc	ecx
	sub	edx, 4
	cmp	ecx, eax
	jl	SHORT $LL114@gsfn_recur

; 3323 :         }
; 3324 :         for ( i = 0 ; i < polycount/2 ; i++ )

	mov	ebx, DWORD PTR _polycount$GSCopy$[ebp]
	mov	edi, DWORD PTR _gcount$GSCopy$[ebp]
$LN112@gsfn_recur:

; 3328 :         }
; 3329 :         gsfn_recur_left_to_right(
; 3330 :            glist, // original full list
; 3331 :            gcount,  // length of glist
; 3332 :            polylist, // indices into glist of current polygon vertices
; 3333 :            polycount, // length of polylist
; 3334 :            -1,  // start at far right
; 3335 :            NULL, // list of current intervals
; 3336 :            0,  // number of current intervals
; 3337 :            f_id,
; 3338 :            GSFN_RIGHT_TO_LEFT
; 3339 :           );

	mov	ecx, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR _glist$GSCopy$[ebp]
	push	2
	push	ecx
	push	0
	push	0
	push	-1
	push	ebx
	push	esi
	push	edi
	push	edx
	call	_gsfn_recur_left_to_right
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi
	pop	ebx

; 3606 :      
; 3607 :         }
; 3608 :       }
; 3609 :     }
; 3610 :   }
; 3611 : } // end gsfn_recur_left_to_right()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN118@gsfn_recur:

; 3340 :         return;
; 3341 :       }
; 3342 :       else
; 3343 :       { // go to monotone triangulation
; 3344 :         gsfn_stage_two(glist,gcount,polylist,polycount,f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR _polycount$GSCopy$[ebp]
	mov	edx, DWORD PTR _polylist$GSCopy$[ebp]
	push	eax
	mov	eax, DWORD PTR _gcount$GSCopy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _glist$GSCopy$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_gsfn_stage_two
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 3606 :      
; 3607 :         }
; 3608 :       }
; 3609 :     }
; 3610 :   }
; 3611 : } // end gsfn_recur_left_to_right()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN164@gsfn_recur:

; 3425 :           { kb_error(1946,"Facet too complicated for plotting.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CF@OKEFHFBE@Facet?5too?5complicated?5for?5plotti@
	push	1946					; 0000079aH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 3606 :      
; 3607 :         }
; 3608 :       }
; 3609 :     }
; 3610 :   }
; 3611 : } // end gsfn_recur_left_to_right()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN165@gsfn_recur:

; 3462 :           { sprintf(errmsg,"Problem tessellating facet %s; maybe edges not counterclockwise?\n",
; 3463 :                 ELNAME(glist[0].id));

	mov	edx, DWORD PTR _glist$GSCopy$[ebp]
	mov	eax, DWORD PTR [edx+128]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN128@gsfn_recur
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN129@gsfn_recur
$LN128@gsfn_recur:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN129@gsfn_recur:
	push	eax
	push	OFFSET ??_C@_0EC@GEFKPDMA@Problem?5tessellating?5facet?5?$CFs?$DL?5m@
	push	OFFSET _errmsg
	call	_sprintf

; 3464 :             kb_error(6667,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	6667					; 00001a0bH
	call	_kb_error

; 3606 :      
; 3607 :         }
; 3608 :       }
; 3609 :     }
; 3610 :   }
; 3611 : } // end gsfn_recur_left_to_right()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_gsfn_recur_left_to_right ENDP
_TEXT	ENDS
PUBLIC	__real@3fce04189374bc6a
PUBLIC	__real@3bc79ca10c924223
PUBLIC	_graph_string_facet_nonconvex
EXTRN	_qsort:PROC
;	COMDAT __real@3fce04189374bc6a
CONST	SEGMENT
__real@3fce04189374bc6a DQ 03fce04189374bc6ar	; 0.2345
CONST	ENDS
;	COMDAT __real@3bc79ca10c924223
CONST	SEGMENT
__real@3bc79ca10c924223 DQ 03bc79ca10c924223r	; 1e-020
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _graph_string_facet_nonconvex
_TEXT	SEGMENT
_ss$ = -12						; size = 8
tv520 = -8						; size = 4
tv630 = -4						; size = 4
_f_id$ = 8						; size = 4
_facet_gdata$ = 12					; size = 4
_change$ = 16						; size = 4
_facet_gcount$ = 16					; size = 4
_graph_string_facet_nonconvex PROC			; COMDAT

; 3193 : { int i,j,change;  

	push	ebp
	mov	ebp, esp
	fld	QWORD PTR __real@3bc79ca10c924223
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, DWORD PTR _facet_gcount$[ebp]
	push	esi
	push	edi
$LN24@graph_stri:

; 3194 :   REAL cc,ss;
; 3195 :   struct graphdata **verlist; // vertices sorted in x order (pointers into facet_gdata)
; 3196 :   int *polylist; // integer indices, using same space as verlist
; 3197 :   REAL epsilon = 1e-20;
; 3198 : 
; 3199 :   // Get rid of doubling-back edges.  Phrased so works with
; 3200 :   // higher lagrange order.
; 3201 :   do 
; 3202 :   { REAL dx,dy,dd;
; 3203 :     change = 0;
; 3204 :     dx = (facet_gdata[0].x[0] - facet_gdata[facet_gcount-2].x[0]);

	mov	edx, DWORD PTR _facet_gdata$[ebp]
	fld	QWORD PTR [edx]
	lea	eax, DWORD PTR [ebx+ebx*8-18]
	add	eax, eax
	fsub	QWORD PTR [edx+eax*8]

; 3205 :     dy = (facet_gdata[0].x[1] - facet_gdata[facet_gcount-2].x[1]);

	lea	ecx, DWORD PTR [ebx+ebx*8]
	fld	QWORD PTR [edx+8]
	add	ecx, ecx
	fsub	QWORD PTR [edx+ecx*8-280]
	mov	DWORD PTR _change$[ebp], 0

; 3206 :     dd = dx*dx+dy*dy;

	fmul	ST(0), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)

; 3207 :     // compare first and next to last
; 3208 :     if ( dd < epsilon )

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN40@graph_stri

; 3209 :     { facet_gcount -= 2;
; 3210 :       change++;

	add	ebx, -2					; fffffffeH
	mov	DWORD PTR _change$[ebp], 1
$LN40@graph_stri:

; 3211 :     }
; 3212 :     // compare second and last
; 3213 :     dx = (facet_gdata[1].x[0] - facet_gdata[facet_gcount-1].x[0]);

	fld	QWORD PTR [edx+144]
	lea	eax, DWORD PTR [ebx+ebx*8]
	add	eax, eax
	fsub	QWORD PTR [edx+eax*8-144]

; 3214 :     dy = (facet_gdata[1].x[1] - facet_gdata[facet_gcount-1].x[1]);

	fld	QWORD PTR [edx+152]
	fsub	QWORD PTR [edx+eax*8-136]

; 3215 :     dd = dx*dx+dy*dy;

	fmul	ST(0), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)

; 3216 :     if ( dd < epsilon )  

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN20@graph_stri

; 3217 :     { facet_gdata[0] = facet_gdata[facet_gcount-2];

	lea	esi, DWORD PTR [ebx+ebx*8-18]
	shl	esi, 4
	add	esi, edx
	mov	ecx, 36					; 00000024H
	mov	edi, edx
	add	ebx, -2					; fffffffeH

; 3218 :       facet_gcount -= 2;
; 3219 :       change++;

	inc	DWORD PTR _change$[ebp]
	rep movsd
$LN20@graph_stri:

; 3220 :     }
; 3221 :     // compare in middle of list
; 3222 :     for ( i = 0 ; i < facet_gcount-2 ; i++ )

	lea	eax, DWORD PTR [ebx-2]
	test	eax, eax
	jle	SHORT $LN23@graph_stri
	mov	edi, DWORD PTR _facet_gdata$[ebp]
	mov	ecx, 1
	add	edi, 288				; 00000120H
	mov	edx, eax
	mov	DWORD PTR tv520[ebp], ecx
	mov	DWORD PTR tv630[ebp], edi
$LN19@graph_stri:

; 3223 :     { 
; 3224 :       dx = (facet_gdata[i].x[0] - facet_gdata[i+2].x[0]);

	fld	QWORD PTR [edi-288]
	fsub	QWORD PTR [edi]

; 3225 :       dy = (facet_gdata[i].x[1] - facet_gdata[i+2].x[1]);

	fld	QWORD PTR [edi-280]
	fsub	QWORD PTR [edi+8]

; 3226 :       dd = dx*dx+dy*dy;

	fmul	ST(0), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)

; 3227 :       if ( dd < epsilon )

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN18@graph_stri

; 3228 :       { for ( j = i+1 ; j < facet_gcount-2 ; j++ )

	cmp	ecx, edx
	jge	SHORT $LN15@graph_stri
	mov	eax, edx
	sub	eax, ecx
	lea	ecx, DWORD PTR [eax+eax*8]
	shl	ecx, 4
	shr	ecx, 2
	lea	esi, DWORD PTR [edi+144]
	add	edi, -144				; ffffff70H
	rep movsd
	mov	ecx, DWORD PTR tv520[ebp]
	mov	edi, DWORD PTR tv630[ebp]
$LN15@graph_stri:

; 3229 :           facet_gdata[j] = facet_gdata[j+2];
; 3230 :         facet_gcount -= 2;

	sub	ebx, 2
	sub	edx, 2

; 3231 :         change++;

	inc	DWORD PTR _change$[ebp]
$LN18@graph_stri:

; 3220 :     }
; 3221 :     // compare in middle of list
; 3222 :     for ( i = 0 ; i < facet_gcount-2 ; i++ )

	inc	ecx
	add	edi, 144				; 00000090H
	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR tv630[ebp], edi
	mov	DWORD PTR tv520[ebp], ecx
	cmp	eax, edx
	jl	SHORT $LN19@graph_stri
	mov	edx, DWORD PTR _facet_gdata$[ebp]
$LN23@graph_stri:

; 3232 :       }
; 3233 :     }
; 3234 :   } while ( change );

	cmp	DWORD PTR _change$[ebp], 0
	jne	$LN24@graph_stri

; 3235 : 
; 3236 :   // For debugging, use ecolor as order index around original facet,
; 3237 :   // and etype as order index around current facet.
; 3238 :   for ( i = 0 ; i < facet_gcount ; i++ )

	xor	eax, eax
	fstp	ST(0)
	test	ebx, ebx
	jle	SHORT $LN10@graph_stri
	lea	ecx, DWORD PTR [edx+120]
$LL12@graph_stri:

; 3239 :     facet_gdata[i].ecolor = facet_gdata[i].etype = i;

	movzx	edx, ax
	mov	WORD PTR [ecx+4], dx
	movsx	edx, dx
	mov	DWORD PTR [ecx], edx
	inc	eax
	add	ecx, 144				; 00000090H
	cmp	eax, ebx
	jl	SHORT $LL12@graph_stri
$LN10@graph_stri:

; 3240 : 
; 3241 : 
; 3242 :   // Use normal components to store rotated coordinates, for general position
; 3243 :   // to avoid exactly vertical lines and stuff.
; 3244 :   ss = sin(0.2345);

	fld	QWORD PTR __real@3fce04189374bc6a
	call	__CIsin
	fstp	QWORD PTR _ss$[ebp]

; 3245 :   cc = cos(0.2345);

	fld	QWORD PTR __real@3fce04189374bc6a
	call	__CIcos

; 3246 :   for ( i = 0 ; i < facet_gcount ; i++ )

	test	ebx, ebx
	jle	SHORT $LN64@graph_stri

; 3240 : 
; 3241 : 
; 3242 :   // Use normal components to store rotated coordinates, for general position
; 3243 :   // to avoid exactly vertical lines and stuff.
; 3244 :   ss = sin(0.2345);

	mov	eax, DWORD PTR _facet_gdata$[ebp]
	fld	QWORD PTR _ss$[ebp]
	add	eax, 8
	mov	ecx, ebx
$LN9@graph_stri:

; 3247 :   { facet_gdata[i].X[0] = cc*facet_gdata[i].x[0] - ss*facet_gdata[i].x[1];

	fld	QWORD PTR [eax-8]
	add	eax, 144				; 00000090H
	dec	ecx
	fmul	ST(0), ST(2)
	fld	ST(1)
	fmul	QWORD PTR [eax-144]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax-96]

; 3248 :     facet_gdata[i].X[1] = ss*facet_gdata[i].x[0] + cc*facet_gdata[i].x[1];

	fld	QWORD PTR [eax-152]
	fmul	ST(0), ST(1)
	fld	ST(2)
	fmul	QWORD PTR [eax-144]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax-88]
	jne	SHORT $LN9@graph_stri

; 3246 :   for ( i = 0 ; i < facet_gcount ; i++ )

	fstp	ST(1)
$LN64@graph_stri:

; 3249 :   }
; 3250 : 
; 3251 :    // Sort vertices in X
; 3252 :   verlist = (struct graphdata **)temp_calloc(facet_gcount,sizeof(struct graphdata*));

	push	3252					; 00000cb4H
	fstp	ST(0)
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	push	4
	push	ebx
	call	_kb_temp_calloc
	mov	edi, DWORD PTR _facet_gdata$[ebp]
	mov	esi, eax
	add	esp, 16					; 00000010H

; 3253 :   for ( i = 0 ; i < facet_gcount ; i++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN4@graph_stri

; 3249 :   }
; 3250 : 
; 3251 :    // Sort vertices in X
; 3252 :   verlist = (struct graphdata **)temp_calloc(facet_gcount,sizeof(struct graphdata*));

	mov	ecx, edi
$LL6@graph_stri:

; 3254 :     verlist[i] = facet_gdata+i;

	mov	DWORD PTR [esi+eax*4], ecx
	inc	eax
	add	ecx, 144				; 00000090H
	cmp	eax, ebx
	jl	SHORT $LL6@graph_stri
$LN4@graph_stri:

; 3255 :   qsort((char*)verlist,facet_gcount,sizeof(struct graphdata*),FCAST gsfn_comp);

	push	OFFSET _gsfn_comp
	push	4
	push	ebx
	push	esi
	call	_qsort
	add	esp, 16					; 00000010H

; 3256 : 
; 3257 :   // initialize interval list to start the recursion
; 3258 :   polylist = (int*)verlist;
; 3259 :   for ( i = 0 ; i < facet_gcount ; i++ )

	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN1@graph_stri
	npad	5
$LL3@graph_stri:

; 3260 :     polylist[i] = (int)(verlist[i] - facet_gdata);  

	mov	edx, DWORD PTR [esi+ecx*4]
	sub	edx, edi
	mov	eax, 954437177				; 38e38e39H
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR [esi+ecx*4], eax
	inc	ecx
	cmp	ecx, ebx
	jl	SHORT $LL3@graph_stri
$LN1@graph_stri:

; 3261 : 
; 3262 :   // start the recursion
; 3263 :   gsfn_recur_left_to_right(facet_gdata,facet_gcount,polylist,facet_gcount,-1,NULL,0,f_id,GSFN_LEFT_TO_RIGHT);

	mov	ecx, DWORD PTR _f_id$[ebp]
	push	1
	push	ecx
	push	0
	push	0
	push	-1
	push	ebx
	push	esi
	push	ebx
	push	edi
	call	_gsfn_recur_left_to_right

; 3264 : 
; 3265 :   temp_free((char*)verlist);

	push	esi
	call	_temp_free
	add	esp, 40					; 00000028H
	pop	edi
	pop	esi
	pop	ebx

; 3266 : 
; 3267 : } // end graph_string_facet_nonconvex()

	mov	esp, ebp
	pop	ebp
	ret	0
_graph_string_facet_nonconvex ENDP
_TEXT	ENDS
PUBLIC	_facet_gcount$GSCopy$
PUBLIC	_facet_gdata$GSCopy$
PUBLIC	_f_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_graph_string_facet
; Function compile flags: /Ogtp
;	COMDAT _graph_string_facet
_TEXT	SEGMENT
_f_id$GSCopy$ = -596					; size = 4
tv1674 = -592						; size = 4
tv1135 = -592						; size = 4
_facet_gcount$GSCopy$ = -588				; size = 4
_facet_gdata$GSCopy$ = -584				; size = 4
_gdata$ = -580						; size = 576
__$ArrayPad$ = -4					; size = 4
_f_id$ = 8						; size = 4
_facet_gdata$ = 12					; size = 4
_facet_gcount$ = 16					; size = 4
_graph_string_facet PROC				; COMDAT

; 3064 : { struct graphdata gdata[FACET_VERTS+1]; /* for an individual triangle, plus wrap */

	push	ebp
	mov	ebp, esp
	sub	esp, 596				; 00000254H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _f_id$[ebp]
	push	esi
	mov	esi, DWORD PTR _facet_gcount$[ebp]
	push	edi
	mov	edi, DWORD PTR _facet_gdata$[ebp]

; 3065 :   int i,n;
; 3066 : 
; 3067 :   memset((char*)gdata,0,sizeof(gdata));

	push	576					; 00000240H
	lea	eax, DWORD PTR _gdata$[ebp]
	push	0
	push	eax

; 3092 :   { gdata[1] = facet_gdata[n];

	mov	DWORD PTR _f_id$GSCopy$[ebp], ebx
	mov	DWORD PTR _facet_gdata$GSCopy$[ebp], edi
	mov	DWORD PTR _facet_gcount$GSCopy$[ebp], esi
	call	_memset
	mov	ecx, DWORD PTR _web+236
	mov	eax, ebx
	and	ebx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+ebx*4]
	shr	eax, 27					; 0000001bH
	add	esp, 12					; 0000000cH
	and	eax, 1
	lea	ecx, DWORD PTR [ecx+ebx*4]
	je	SHORT $LN19@graph_stri@2

; 3068 : 
; 3069 :   gdata[0].color = get_facet_frontcolor(f_id);

	movsx	edx, WORD PTR [edx+50]
	jmp	SHORT $LN52@graph_stri@2
$LN19@graph_stri@2:
	movsx	edx, WORD PTR [edx+48]
$LN52@graph_stri@2:
	mov	DWORD PTR _gdata$[ebp+104], edx

; 3070 :   gdata[0].backcolor = get_facet_backcolor(f_id);

	test	eax, eax
	je	SHORT $LN21@graph_stri@2
	mov	eax, DWORD PTR [ecx]
	movsx	ecx, WORD PTR [eax+48]
	mov	DWORD PTR _gdata$[ebp+108], ecx
	jmp	SHORT $LN22@graph_stri@2
$LN21@graph_stri@2:
	mov	edx, DWORD PTR [ecx]
	movsx	eax, WORD PTR [edx+50]
	mov	DWORD PTR _gdata$[ebp+108], eax
$LN22@graph_stri@2:

; 3071 :   /* first vertex to be average of others */
; 3072 :   for ( n = 0 ; n < facet_gcount ; n++ )

	test	esi, esi
	jle	$LN41@graph_stri@2
	xor	ebx, ebx
	mov	DWORD PTR tv1135[ebp], esi
$LL40@graph_stri@2:

; 3073 :   { for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _web+616
	xor	eax, eax
	cmp	esi, 4
	jl	SHORT $LC35@graph_stri@2
	lea	edx, DWORD PTR [esi-3]
	mov	ecx, edi
$LL36@graph_stri@2:

; 3074 :      gdata[0].x[i] += facet_gdata[n].x[i];

	fld	QWORD PTR _gdata$[ebp+eax*8]
	add	eax, 4
	fadd	QWORD PTR [ecx]
	add	ecx, 32					; 00000020H
	fstp	QWORD PTR _gdata$[ebp+eax*8-32]
	fld	QWORD PTR [ecx-24]
	fadd	QWORD PTR _gdata$[ebp+eax*8-24]
	fstp	QWORD PTR _gdata$[ebp+eax*8-24]
	fld	QWORD PTR [ecx-16]
	fadd	QWORD PTR _gdata$[ebp+eax*8-16]
	fstp	QWORD PTR _gdata$[ebp+eax*8-16]
	fld	QWORD PTR [ecx-8]
	fadd	QWORD PTR _gdata$[ebp+eax*8-8]
	fstp	QWORD PTR _gdata$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LL36@graph_stri@2
$LC35@graph_stri@2:

; 3073 :   { for ( i = 0 ; i < SDIM ; i++ )

	cmp	eax, esi
	jge	SHORT $LN34@graph_stri@2
	mov	edx, DWORD PTR _facet_gdata$GSCopy$[ebp]
	lea	ecx, DWORD PTR [ebx+eax]
	lea	ecx, DWORD PTR [edx+ecx*8]
$LC13@graph_stri@2:

; 3074 :      gdata[0].x[i] += facet_gdata[n].x[i];

	fld	QWORD PTR [ecx]
	inc	eax
	fadd	QWORD PTR _gdata$[ebp+eax*8-8]
	add	ecx, 8
	fstp	QWORD PTR _gdata$[ebp+eax*8-8]
	cmp	eax, esi
	jl	SHORT $LC13@graph_stri@2
$LN34@graph_stri@2:

; 3075 :     facet_gdata[n].etype = INVISIBLE_EDGE;

	xor	eax, eax
	mov	WORD PTR [edi+124], ax
	add	ebx, 18					; 00000012H
	add	edi, 144				; 00000090H
	dec	DWORD PTR tv1135[ebp]
	jne	$LL40@graph_stri@2

; 3071 :   /* first vertex to be average of others */
; 3072 :   for ( n = 0 ; n < facet_gcount ; n++ )

	mov	esi, DWORD PTR _facet_gcount$GSCopy$[ebp]
	mov	edi, DWORD PTR _facet_gdata$GSCopy$[ebp]
$LN41@graph_stri@2:

; 3076 :   }
; 3077 :   for ( i = 0 ; i < SDIM ; i++ ) 

	mov	edx, DWORD PTR _web+616
	xor	eax, eax
	cmp	edx, 4
	jl	SHORT $LC38@graph_stri@2

; 3078 :     gdata[0].x[i] /= facet_gcount;

	fild	DWORD PTR _facet_gcount$GSCopy$[ebp]
	lea	ecx, DWORD PTR [edx-3]
$LN39@graph_stri@2:
	fld	QWORD PTR _gdata$[ebp+eax*8]
	add	eax, 4
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _gdata$[ebp+eax*8-32]
	fld	QWORD PTR _gdata$[ebp+eax*8-24]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _gdata$[ebp+eax*8-24]
	fld	QWORD PTR _gdata$[ebp+eax*8-16]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _gdata$[ebp+eax*8-16]
	fld	QWORD PTR _gdata$[ebp+eax*8-8]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _gdata$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN39@graph_stri@2
	fstp	ST(0)
$LC38@graph_stri@2:

; 3076 :   }
; 3077 :   for ( i = 0 ; i < SDIM ; i++ ) 

	cmp	eax, edx
	jge	SHORT $LN37@graph_stri@2
	fild	DWORD PTR _facet_gcount$GSCopy$[ebp]
$LC10@graph_stri@2:

; 3078 :     gdata[0].x[i] /= facet_gcount;

	fld	QWORD PTR _gdata$[ebp+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _gdata$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC10@graph_stri@2

; 3076 :   }
; 3077 :   for ( i = 0 ; i < SDIM ; i++ ) 

	fstp	ST(0)
$LN37@graph_stri@2:

; 3079 : 
; 3080 :   // Test for starness
; 3081 :   for ( n = 0 ; n <  facet_gcount-1 ; n++ )

	lea	ecx, DWORD PTR [esi-1]
	xor	edx, edx
	test	ecx, ecx
	jle	$LN1@graph_stri@2
	fld	QWORD PTR _gdata$[ebp+8]
	lea	esi, DWORD PTR [edi+144]
	fld	QWORD PTR _gdata$[ebp]
	fldz
$LN7@graph_stri@2:

; 3082 :   { REAL crossproduct = (facet_gdata[n].x[0]-gdata[0].x[0])*(facet_gdata[n+1].x[1]-gdata[0].x[1])
; 3083 :        - (facet_gdata[n].x[1]-gdata[0].x[1])*(facet_gdata[n+1].x[0]-gdata[0].x[0]);

	fld	QWORD PTR [esi-144]
	fsub	ST(0), ST(2)
	fld	QWORD PTR [esi+8]
	fsub	ST(0), ST(4)
	fmulp	ST(1), ST(0)
	fld	QWORD PTR [esi-136]
	fsub	ST(0), ST(4)
	fld	QWORD PTR [esi]
	fsub	ST(0), ST(4)
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)

; 3084 :     if ( crossproduct < 0.0 )

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	$LN48@graph_stri@2

; 3079 : 
; 3080 :   // Test for starness
; 3081 :   for ( n = 0 ; n <  facet_gcount-1 ; n++ )

	inc	edx
	add	esi, 144				; 00000090H
	cmp	edx, ecx
	jl	SHORT $LN7@graph_stri@2

; 3084 :     if ( crossproduct < 0.0 )

	mov	esi, DWORD PTR _facet_gcount$GSCopy$[ebp]
	fstp	ST(2)
	mov	edi, DWORD PTR _facet_gdata$GSCopy$[ebp]
	fstp	ST(0)
	fstp	ST(0)

; 3086 :       return;
; 3087 :     }
; 3088 :   }
; 3089 :   
; 3090 :   // If here, then star-shaped, so ok to graph.
; 3091 :   for ( n = 0 ; n <  facet_gcount-1 ; n++ )

	test	ecx, ecx
	jle	SHORT $LN1@graph_stri@2
	mov	eax, edi
	mov	DWORD PTR tv1674[ebp], ecx
	npad	11
$LL3@graph_stri@2:

; 3092 :   { gdata[1] = facet_gdata[n];

	mov	esi, eax
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata$[ebp+144]
	rep movsd

; 3093 :     gdata[2] = facet_gdata[n+1];

	lea	ebx, DWORD PTR [eax+144]
	mov	ecx, 36					; 00000024H
	mov	esi, ebx
	lea	edi, DWORD PTR _gdata$[ebp+288]
	rep movsd

; 3094 :     option_facet(gdata,f_id);         

	mov	ecx, DWORD PTR _f_id$GSCopy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _gdata$[ebp]
	push	edx
	call	_option_facet
	add	esp, 8
	dec	DWORD PTR tv1674[ebp]
	mov	eax, ebx
	jne	SHORT $LL3@graph_stri@2

; 3086 :       return;
; 3087 :     }
; 3088 :   }
; 3089 :   
; 3090 :   // If here, then star-shaped, so ok to graph.
; 3091 :   for ( n = 0 ; n <  facet_gcount-1 ; n++ )

	mov	esi, DWORD PTR _facet_gcount$GSCopy$[ebp]
	mov	edi, DWORD PTR _facet_gdata$GSCopy$[ebp]
$LN1@graph_stri@2:

; 3095 :   }
; 3096 :   gdata[1] = facet_gdata[facet_gcount-1];

	lea	eax, DWORD PTR [esi+esi*8]
	add	eax, eax
	lea	esi, DWORD PTR [edi+eax*8-144]
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata$[ebp+144]
	rep movsd

; 3097 :   gdata[2] = facet_gdata[0];

	mov	esi, DWORD PTR _facet_gdata$GSCopy$[ebp]
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata$[ebp+288]
	rep movsd

; 3098 :   option_facet(gdata,f_id); 

	mov	ecx, DWORD PTR _f_id$GSCopy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _gdata$[ebp]
	push	edx
	call	_option_facet
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 3099 : 
; 3100 : } // end graph_string_facet()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@graph_stri@2:

; 3085 :     { graph_string_facet_nonconvex(f_id,facet_gdata,facet_gcount);

	mov	ecx, DWORD PTR _facet_gcount$GSCopy$[ebp]
	fstp	ST(2)
	mov	edx, DWORD PTR _facet_gdata$GSCopy$[ebp]
	fstp	ST(0)
	mov	eax, DWORD PTR _f_id$GSCopy$[ebp]
	fstp	ST(0)
	push	ecx
	push	edx
	push	eax
	call	_graph_string_facet_nonconvex

; 3099 : 
; 3100 : } // end graph_string_facet()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_graph_string_facet ENDP
_TEXT	ENDS
PUBLIC	__real@4000000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_plain_string_facets
EXTRN	_kb_temp_realloc:PROC
;	COMDAT __real@4000000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\graphgen.c
CONST	ENDS
;	COMDAT _plain_string_facets
_TEXT	SEGMENT
tv2962 = -360						; size = 8
_fattr$89896 = -360					; size = 8
_f_id$ = -352						; size = 4
tv1485 = -348						; size = 4
_mag1$89942 = -344					; size = 8
_v$90011 = -340						; size = 4
_k$89944 = -340						; size = 4
tv1482 = -336						; size = 4
_start_fe$89899 = -336					; size = 4
tv1546 = -332						; size = 4
_mag2$89943 = -328					; size = 8
tv1671 = -324						; size = 4
_tailx$90038 = -324					; size = 4
_segments$89945 = -324					; size = 4
_to_alloc$ = -320					; size = 4
_fe$89900 = -316					; size = 4
tv3338 = -312						; size = 4
tv2946 = -312						; size = 4
tv1555 = -312						; size = 4
_headx$90022 = -312					; size = 4
tv3155 = -308						; size = 4
tv2918 = -308						; size = 4
tv1556 = -308						; size = 4
_n$ = -304						; size = 4
_tailx$89934 = -304					; size = 4
_gdata$ = -300						; size = 4
_vcount$89898 = -296					; size = 4
_w$89940 = -292						; size = 48
_headx$89937 = -244					; size = 48
_midx$89936 = -196					; size = 48
_s$89927 = -148						; size = 48
_w1$89938 = -100					; size = 48
_w2$89939 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_plain_string_facets PROC				; COMDAT

; 733  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 734  :   int i,n;
; 735  :   facet_id f_id;
; 736  :   struct graphdata *gdata;
; 737  :   int to_alloc = 100;
; 738  : 
; 739  :   gdata = (struct graphdata *)temp_calloc(to_alloc,sizeof(struct graphdata));

	push	739					; 000002e3H
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	push	144					; 00000090H
	push	100					; 00000064H
	mov	DWORD PTR _to_alloc$[ebp], 100		; 00000064H
	call	_kb_temp_calloc
	fld1
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gdata$[ebp], eax
	add	eax, 124				; 0000007cH
	mov	ecx, 100				; 00000064H
$LN80@plain_stri:

; 742  :   { gdata[i].x[3] = 1.0;  /* homogeneous coord */
; 743  :     gdata[i].etype = INVISIBLE_EDGE;

	xor	edx, edx
	fst	QWORD PTR [eax-100]
	mov	WORD PTR [eax], dx
	add	eax, 144				; 00000090H
	dec	ecx
	jne	SHORT $LN80@plain_stri

; 740  : 
; 741  :   for ( i = 0 ; i < to_alloc ; i++ ) 

	push	esi
	fstp	ST(0)

; 744  :   }
; 745  :      
; 746  :   MFOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR _web+272
	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _f_id$[ebp], esi
	mov	DWORD PTR tv1482[ebp], eax
	je	$LN170@plain_stri
	push	ebx
	push	edi
	npad	5
$LL205@plain_stri:
	mov	ecx, DWORD PTR _web+236
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1485[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax+12]
	mov	eax, ecx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN76@plain_stri

; 747  :   { 
; 748  :     ATTR fattr = get_fattr(f_id);

	mov	edi, ecx
	mov	DWORD PTR _fattr$89896[ebp+4], ebx

; 749  :     int vcount;  /* number of vertices */
; 750  :     facetedge_id start_fe,fe;
; 751  :     REAL *x;
; 752  :     vertex_id midv;
; 753  : 
; 754  :     if ( breakflag ) break;

	cmp	DWORD PTR _breakflag, edx
	jne	$LN211@plain_stri

; 755  : 
; 756  :     #ifdef MPI_EVOLVER
; 757  :     if ( !mpi_show_corona_flag && (id_task(f_id) != this_task) )
; 758  :        continue;
; 759  :     #endif
; 760  : 
; 761  :     if ( !show_expr[FACET] || !show_expr[FACET]->start || 
; 762  :                            !eval(show_expr[FACET],NULL,f_id,NULL) ) 

	cmp	DWORD PTR _show_expr+8, edx
	je	$LN76@plain_stri
	mov	edx, DWORD PTR _show_expr+8
	cmp	DWORD PTR [edx], 0
	je	$LN76@plain_stri
	push	0
	push	esi
	mov	eax, edx
	push	0
	push	eax
	call	_eval
	fldz
	fucompp
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN76@plain_stri

; 763  :         continue;
; 764  : 
; 765  :     if ( (fattr & (BOUNDARY|CONSTRAINT)) && !bdry_showflag )

	mov	eax, edi
	and	eax, 1152				; 00000480H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN69@plain_stri
	cmp	DWORD PTR _bdry_showflag, ecx
	je	$LN76@plain_stri
$LN69@plain_stri:

; 766  :         continue;
; 767  :     if ( fattr & NODISPLAY )

	and	edi, 2
	xor	eax, eax
	or	edi, eax
	jne	$LN76@plain_stri

; 768  :         continue;
; 769  : 
; 770  :     gdata[0].color = get_facet_color_2(f_id);

	push	esi
	call	_get_facet_color_2
	mov	ebx, DWORD PTR _gdata$[ebp]

; 771  :     gdata[0].backcolor = get_facet_backcolor_2(f_id);

	push	esi
	mov	DWORD PTR [ebx+104], eax
	call	_get_facet_backcolor_2
	mov	DWORD PTR [ebx+108], eax

; 772  :     if ( opacity_attr )

	mov	ecx, DWORD PTR _opacity_attr
	add	esp, 8
	test	ecx, ecx
	je	SHORT $LN206@plain_stri

; 773  :       gdata[0].opacity = *(REAL*)(get_extra(f_id,opacity_attr));

	mov	eax, esi
	imul	ecx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	edx, ecx
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ecx+64]
	mov	ecx, DWORD PTR tv1485[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	fld	QWORD PTR [edx+eax]
	fstp	QWORD PTR [ebx+112]
$LN206@plain_stri:

; 774  :     gdata[0].id = f_id;
; 775  :     vcount = 0;
; 776  : 
; 777  :     /* get vertices; verts is list of gdata.x pointers */
; 778  :     fe = start_fe = get_facet_fe(f_id);

	cmp	DWORD PTR tv1482[ebp], 0
	mov	DWORD PTR [ebx+128], esi
	jne	SHORT $LN86@plain_stri
	xor	edi, edi
	jmp	SHORT $LN85@plain_stri
$LN86@plain_stri:
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR tv1485[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	edi, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN85@plain_stri
	xor	edi, 134217728				; 08000000H
$LN85@plain_stri:
	mov	DWORD PTR _start_fe$89899[ebp], edi
	mov	DWORD PTR _fe$89900[ebp], edi

; 779  :     if ( !valid_id(fe) )

	test	edi, 268435456				; 10000000H
	je	$LN76@plain_stri

; 780  :       continue;
; 781  :     gdata[vcount].v_id = get_fe_tailv(fe);

	mov	edx, DWORD PTR _web+460
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, edi
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_get_edge_tailv
	mov	DWORD PTR [ebx+132], eax

; 782  :     x = get_coord(gdata[vcount].v_id);

	mov	edx, DWORD PTR _web+12
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, DWORD PTR [ecx+esi+64]

; 783  :     for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	add	esp, 4
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN207@plain_stri
	mov	ecx, ebx
	sub	eax, ebx
	npad	1
$LL65@plain_stri:

; 784  :     { gdata[vcount].x[i] = x[i];

	fld	QWORD PTR [eax+ecx]
	inc	edx
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL65@plain_stri

; 783  :     for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _dymem
$LN207@plain_stri:

; 785  :     }
; 786  :     vcount++;

	mov	ecx, DWORD PTR _web+124
	mov	DWORD PTR _vcount$89898[ebp], 1
	npad	9
$LL62@plain_stri:

; 787  : 
; 788  :     do
; 789  :     { REAL s[MAXCOORD];
; 790  :     
; 791  :       if ( web.modeltype == LINEAR )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	jne	$LN59@plain_stri

; 792  :       {
; 793  :         gdata[vcount].v_id = get_fe_headv(fe);

	mov	eax, DWORD PTR _web+460
	mov	ebx, edi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	eax, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [eax+20]
	mov	edx, edi
	and	edx, 134217728				; 08000000H
	xor	eax, edx
	mov	DWORD PTR tv1546[ebp], ebx
	test	eax, 134217728				; 08000000H
	je	SHORT $LN94@plain_stri
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+esi+304]
	mov	eax, DWORD PTR [ecx+eax]
	jmp	SHORT $LN93@plain_stri
$LN94@plain_stri:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	add	ecx, DWORD PTR [eax+esi+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [ecx+eax*4]
$LN93@plain_stri:
	mov	ecx, DWORD PTR _vcount$89898[ebp]
	mov	esi, DWORD PTR _gdata$[ebp]
	lea	ecx, DWORD PTR [ecx+ecx*8]
	shl	ecx, 4
	add	esi, ecx
	mov	DWORD PTR [esi+132], eax

; 794  :         get_edge_side(get_fe_edge(fe),s);

	mov	ecx, DWORD PTR _web+460
	lea	eax, DWORD PTR _s$89927[ebp]
	push	eax
	mov	eax, DWORD PTR [ebx+ecx]
	mov	ecx, DWORD PTR [eax+20]
	xor	ecx, edx
	push	ecx
	call	_get_edge_side

; 795  :   
; 796  :         for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	add	esp, 8
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN204@plain_stri

; 792  :       {
; 793  :         gdata[vcount].v_id = get_fe_headv(fe);

	mov	ecx, esi
	npad	11
$LL58@plain_stri:

; 797  :           gdata[vcount].x[i] = gdata[vcount-1].x[i] + s[i]; 

	fld	QWORD PTR _s$89927[ebp+eax*8]
	inc	eax
	fadd	QWORD PTR [ecx-144]
	add	ecx, 8
	fstp	QWORD PTR [ecx-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL58@plain_stri
$LN204@plain_stri:

; 798  : 
; 799  :         vcount++;

	inc	DWORD PTR _vcount$89898[ebp]
	mov	ebx, DWORD PTR _to_alloc$[ebp]
	jmp	$LN234@plain_stri
$LN59@plain_stri:

; 800  :       }
; 801  :       else if ( web.modeltype == QUADRATIC )

	cmp	eax, 2
	jne	$LN54@plain_stri

; 802  :       { REAL *tailx = gdata[vcount-1].x,*midxp;

	mov	eax, DWORD PTR _vcount$89898[ebp]
	mov	edx, DWORD PTR _gdata$[ebp]
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 4
	add	edx, eax
	mov	DWORD PTR tv1555[ebp], eax

; 803  :         REAL midx[MAXCOORD],headx[MAXCOORD];
; 804  :         REAL w1[MAXCOORD],w2[MAXCOORD],w[MAXCOORD];
; 805  :         REAL mag,mag1,mag2;
; 806  :         int k;
; 807  :         int segments;
; 808  :         REAL ang;
; 809  :         
; 810  :         gdata[vcount+1].v_id = get_fe_headv(fe);

	mov	ebx, edi
	and	ebx, 134217727				; 07ffffffH
	lea	eax, DWORD PTR [edx-144]
	mov	DWORD PTR _tailx$89934[ebp], eax
	mov	eax, DWORD PTR _web+460
	add	ebx, ebx
	add	ebx, ebx
	mov	eax, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [eax+20]
	and	edi, 134217728				; 08000000H
	xor	eax, edi
	mov	DWORD PTR tv1556[ebp], edx
	mov	DWORD PTR tv1546[ebp], ebx
	test	eax, 134217728				; 08000000H
	je	SHORT $LN102@plain_stri
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+esi+304]
	mov	eax, DWORD PTR [ecx+eax]
	jmp	SHORT $LN101@plain_stri
$LN102@plain_stri:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	add	ecx, DWORD PTR [eax+esi+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [ecx+eax*4]
$LN101@plain_stri:
	mov	DWORD PTR [edx+276], eax

; 811  :         get_edge_side(get_fe_edge(fe),s);

	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [ebx+edx]
	lea	ecx, DWORD PTR _s$89927[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+20]
	xor	ecx, edi
	push	ecx
	call	_get_edge_side

; 812  :   
; 813  :         for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	add	esp, 8
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN51@plain_stri
	mov	esi, DWORD PTR _tailx$89934[ebp]
	lea	ecx, DWORD PTR _s$89927[ebp]
	sub	esi, ecx
$LL53@plain_stri:
	lea	ecx, DWORD PTR _s$89927[ebp+eax*8]

; 814  :           headx[i] = tailx[i] + s[i]; 

	fld	QWORD PTR [ecx+esi]
	inc	eax
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR _headx$89937[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LL53@plain_stri
$LN51@plain_stri:

; 815  :         midv = get_fe_midv(fe);

	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [ebx+edx]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]

; 816  :         midxp = get_coord(midv);

	mov	esi, DWORD PTR _web+104
	mov	edx, DWORD PTR [esi+edx+64]
	mov	esi, DWORD PTR _web+124
	mov	ebx, DWORD PTR _web+12
	mov	DWORD PTR tv1671[ebp], edx
	mov	edx, eax

; 817  :         
; 818  :         if ( inverted(get_fe_edge(fe)) )

	xor	eax, DWORD PTR _fe$89900[ebp]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR [edx+ecx+8]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	add	edx, DWORD PTR tv1671[ebp]

; 819  :         { REAL *headxp = get_coord(get_fe_headv(fe));

	mov	ebx, DWORD PTR tv1546[ebp]
	test	eax, 134217728				; 08000000H
	mov	eax, DWORD PTR _web+460
	mov	eax, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [eax+20]
	je	SHORT $LN50@plain_stri
	xor	eax, edi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN114@plain_stri
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	ecx, DWORD PTR [ecx+eax]
	jmp	SHORT $LN113@plain_stri
$LN114@plain_stri:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+esi*4]
	mov	ecx, DWORD PTR [eax+ecx]
$LN113@plain_stri:
	mov	eax, DWORD PTR _web+12

; 820  :            for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR _web+616
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	add	eax, DWORD PTR tv1671[ebp]
	test	edi, edi
	jle	$LN208@plain_stri
	lea	ecx, DWORD PTR _headx$89937[ebp]
	lea	esi, DWORD PTR _midx$89936[ebp]
	sub	ecx, eax
	sub	edx, eax
	sub	esi, eax
	mov	ebx, edi
$LL201@plain_stri:

; 821  :               midx[i] = headx[i] - (headxp[i]-midxp[i]);

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	ebx
	fsub	QWORD PTR [edx+eax-8]
	fsubr	QWORD PTR [ecx+eax-8]
	fstp	QWORD PTR [esi+eax-8]
	jne	SHORT $LL201@plain_stri

; 822  :         }
; 823  :         else 

	jmp	SHORT $LN208@plain_stri
$LN50@plain_stri:

; 824  :         { REAL *tailxp = get_coord(get_fe_tailv(fe));

	xor	eax, edi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN120@plain_stri
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+esi*4]
	mov	ecx, DWORD PTR [eax+ecx]
	jmp	SHORT $LN119@plain_stri
$LN120@plain_stri:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	ecx, DWORD PTR [ecx+eax]
$LN119@plain_stri:
	mov	eax, DWORD PTR _web+12

; 825  :           for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR _web+616
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	add	eax, DWORD PTR tv1671[ebp]
	test	edi, edi
	jle	SHORT $LN208@plain_stri
	mov	ecx, edx
	mov	edx, DWORD PTR _tailx$89934[ebp]
	lea	esi, DWORD PTR _midx$89936[ebp]
	sub	ecx, eax
	sub	edx, eax
	sub	esi, eax
	mov	ebx, edi
$LL202@plain_stri:

; 826  :               midx[i] = tailx[i] + (midxp[i]-tailxp[i]);

	fld	QWORD PTR [ecx+eax]
	add	eax, 8
	dec	ebx
	fsub	QWORD PTR [eax-8]
	fadd	QWORD PTR [edx+eax-8]
	fstp	QWORD PTR [esi+eax-8]
	jne	SHORT $LL202@plain_stri
$LN208@plain_stri:

; 825  :           for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _tailx$89934[ebp]

; 827  :         }
; 828  : 
; 829  :         for (i = 0 ; i < SDIM ; i++ ) 

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN210@plain_stri
$LL42@plain_stri:

; 830  :         { w1[i] = midx[i] - tailx[i];

	fld	QWORD PTR _midx$89936[ebp+eax*8]
	inc	eax
	fsub	QWORD PTR [ecx+eax*8-8]
	fstp	QWORD PTR _w1$89938[ebp+eax*8-8]

; 831  :           w2[i] = headx[i] - tailx[i];

	fld	QWORD PTR _headx$89937[ebp+eax*8-8]
	fsub	QWORD PTR [ecx+eax*8-8]
	fstp	QWORD PTR _w2$89939[ebp+eax*8-8]
	cmp	eax, edi
	jl	SHORT $LL42@plain_stri
$LN210@plain_stri:

; 832  :         }
; 833  :         mag1 = SDIM_dot(w1,w1); mag2 = SDIM_dot(w2,w2);

	lea	ecx, DWORD PTR _w1$89938[ebp]
	push	edi
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _mag1$89942[ebp]
	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _w2$89939[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fst	QWORD PTR _mag2$89943[ebp]

; 834  :         for ( i = 0 ; i < SDIM  ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 24					; 00000018H
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN217@plain_stri
	fld	QWORD PTR _mag1$89942[ebp]
$LN39@plain_stri:

; 835  :         { w1[i] /= mag1; w2[i] /= mag2; }

	fld	QWORD PTR _w1$89938[ebp+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _w1$89938[ebp+eax*8-8]
	fld	QWORD PTR _w2$89939[ebp+eax*8-8]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _w2$89939[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN39@plain_stri

; 834  :         for ( i = 0 ; i < SDIM  ; i++ )

	fstp	ST(1)
$LN217@plain_stri:

; 836  :           
; 837  :         /* figure out how many segments to do */
; 838  :         ang = 4*acos(SDIM_dot(w1,w2)*sqrt(mag1*mag2));

	push	ecx
	fstp	ST(0)
	lea	eax, DWORD PTR _w2$89939[ebp]
	push	eax
	lea	ecx, DWORD PTR _w1$89938[ebp]
	push	ecx
	call	_dot
	fstp	QWORD PTR tv2962[ebp]
	fld	QWORD PTR _mag2$89943[ebp]
	add	esp, 12					; 0000000cH
	fmul	QWORD PTR _mag1$89942[ebp]
	call	__CIsqrt
	fmul	QWORD PTR tv2962[ebp]
	call	__CIacos
	fmul	QWORD PTR __real@4010000000000000

; 839  :         segments = (int)(ang/(M_PI/180*string_curve_tolerance));

	fld	QWORD PTR _string_curve_tolerance
	fmul	QWORD PTR __real@3f91df46a2529d39
	fdivp	ST(1), ST(0)
	call	__ftol2_sse
	mov	edi, eax
	mov	DWORD PTR _segments$89945[ebp], eax

; 840  :         if ( segments < 2 ) 

	cmp	edi, 2
	jge	SHORT $LN36@plain_stri

; 841  :           segments = 2;

	mov	edi, 2
	mov	DWORD PTR _segments$89945[ebp], edi
$LN36@plain_stri:

; 842  :           
; 843  :         if ( vcount+segments >= to_alloc-20 )

	mov	edx, DWORD PTR _vcount$89898[ebp]
	mov	ebx, DWORD PTR _to_alloc$[ebp]
	lea	esi, DWORD PTR [edi+edx]
	lea	eax, DWORD PTR [ebx-20]
	cmp	esi, eax
	jl	SHORT $LN199@plain_stri

; 844  :         { to_alloc *= 2;
; 845  :           gdata = (struct graphdata *)temp_realloc((char*)gdata,
; 846  :             to_alloc*sizeof(struct graphdata));

	mov	edx, DWORD PTR _gdata$[ebp]
	add	ebx, ebx
	push	846					; 0000034eH
	lea	ecx, DWORD PTR [ebx+ebx*8]
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	shl	ecx, 4
	push	ecx
	push	edx
	mov	DWORD PTR _to_alloc$[ebp], ebx
	call	_kb_temp_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gdata$[ebp], eax

; 847  :           tailx = gdata[vcount-1].x; /* since it moved */

	add	eax, DWORD PTR tv1555[ebp]
	lea	edx, DWORD PTR [eax-144]
	mov	DWORD PTR _tailx$89934[ebp], edx
	jmp	SHORT $LN35@plain_stri
$LN199@plain_stri:
	mov	eax, DWORD PTR tv1556[ebp]
$LN35@plain_stri:

; 848  :         }
; 849  :         
; 850  :         for ( k = 1 ; k <= segments ; k++ )

	mov	DWORD PTR _k$89944[ebp], 1
	cmp	edi, 1
	jl	$LN191@plain_stri
	mov	ecx, DWORD PTR _web+616
	mov	ebx, eax
	mov	eax, DWORD PTR _segments$89945[ebp]
	dec	eax
	mov	DWORD PTR tv2918[ebp], 2
	mov	DWORD PTR tv2946[ebp], eax
	mov	DWORD PTR _vcount$89898[ebp], esi
	npad	2
$LL34@plain_stri:

; 851  :         { 
; 852  :           if ( circular_arc_flag )
; 853  :           { for ( i = 0 ; i < SDIM ; i++ ) /* circle as inversion of line */

	xor	eax, eax
	cmp	DWORD PTR _circular_arc_flag, eax
	je	$LN31@plain_stri
	test	ecx, ecx
	jle	SHORT $LN28@plain_stri
	fild	DWORD PTR tv2946[ebp]
	fidiv	DWORD PTR _k$89944[ebp]
$LN30@plain_stri:

; 854  :               w[i] = w2[i] + (segments-k)/(REAL)k*(w1[i]-w2[i]);

	fld	QWORD PTR _w1$89938[ebp+eax*8]
	inc	eax
	fsub	QWORD PTR _w2$89939[ebp+eax*8-8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _w2$89939[ebp+eax*8-8]
	fstp	QWORD PTR _w$89940[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN30@plain_stri

; 851  :         { 
; 852  :           if ( circular_arc_flag )
; 853  :           { for ( i = 0 ; i < SDIM ; i++ ) /* circle as inversion of line */

	fstp	ST(0)
$LN28@plain_stri:

; 855  :             mag = SDIM_dot(w,w);

	push	ecx
	lea	ecx, DWORD PTR _w$89940[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot

; 856  :             for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	xor	esi, esi
	test	ecx, ecx
	jle	$LN235@plain_stri
	mov	eax, DWORD PTR _tailx$89934[ebp]
	lea	edi, DWORD PTR _w$89940[ebp]
	mov	edx, ebx
	sub	edi, eax
$LN27@plain_stri:

; 857  :               gdata[vcount].x[i] = tailx[i] + w[i]/mag;

	fld	QWORD PTR [edi+eax]
	inc	esi
	fdiv	ST(0), ST(1)
	add	eax, 8
	add	edx, 8
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [edx-8]
	mov	ecx, DWORD PTR _web+616
	cmp	esi, ecx
	jl	SHORT $LN27@plain_stri

; 858  :           }
; 859  :           else /* quadratic spline */

	jmp	$LN235@plain_stri
$LN31@plain_stri:

; 860  :           { REAL t = 2*k/(REAL)segments;

	fild	DWORD PTR tv2918[ebp]
	fidiv	DWORD PTR _segments$89945[ebp]

; 861  :             REAL c1 = (t-1)*(t-2)/2;

	fld	QWORD PTR __real@3ff0000000000000
	fsubr	ST(0), ST(1)
	fld	ST(1)
	fld	QWORD PTR __real@4000000000000000
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)

; 862  :             REAL c2 = t*(2-t);

	fxch	ST(2)
	fsub	ST(0), ST(4)
	fmul	ST(0), ST(4)

; 863  :             REAL c3 = t*(t-1)/2; 

	fxch	ST(3)
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	fmulp	ST(1), ST(0)

; 864  :             for ( i = 0 ; i < SDIM ; i++ )

	test	ecx, ecx
	jle	SHORT $LN233@plain_stri
	mov	esi, DWORD PTR _tailx$89934[ebp]
	lea	ecx, DWORD PTR _midx$89936[ebp]
	mov	edx, ebx
	sub	esi, ecx
$LN23@plain_stri:
	lea	ecx, DWORD PTR _midx$89936[ebp+eax*8]

; 865  :               gdata[vcount].x[i] = c1*tailx[i]+c2*midx[i]+c3*headx[i];

	fld	QWORD PTR [esi+ecx]
	inc	eax
	fmul	ST(0), ST(3)
	add	edx, 8
	fld	ST(2)
	fmul	QWORD PTR [ecx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _headx$89937[ebp+eax*8-8]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx-8]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN23@plain_stri
$LN233@plain_stri:

; 864  :             for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
	fstp	ST(1)
$LN235@plain_stri:
	mov	eax, DWORD PTR _k$89944[ebp]
	fstp	ST(0)
	dec	DWORD PTR tv2946[ebp]
	add	DWORD PTR tv2918[ebp], 2
	inc	eax

; 866  :           }
; 867  :           vcount++;

	add	ebx, 144				; 00000090H
	mov	DWORD PTR _k$89944[ebp], eax
	cmp	eax, DWORD PTR _segments$89945[ebp]
	jle	$LL34@plain_stri

; 868  :         }
; 869  :         
; 870  :       }
; 871  :       else /* LAGRANGE */

	mov	ebx, DWORD PTR _to_alloc$[ebp]
$LN191@plain_stri:

; 798  : 
; 799  :         vcount++;

	mov	edi, DWORD PTR _fe$89900[ebp]
$LN234@plain_stri:
	mov	ecx, DWORD PTR _web+124
	mov	esi, DWORD PTR _dymem
$LN20@plain_stri:

; 900  :       }
; 901  :       
; 902  :       if ( vcount >= to_alloc-20 )

	lea	eax, DWORD PTR [ebx-20]
	cmp	DWORD PTR _vcount$89898[ebp], eax
	jl	SHORT $LN209@plain_stri

; 903  :       { to_alloc *= 2;
; 904  :         gdata = (struct graphdata *)temp_realloc((char*)gdata,
; 905  :            to_alloc*sizeof(struct graphdata));

	mov	edx, DWORD PTR _gdata$[ebp]
	lea	eax, DWORD PTR [ebx+ebx]
	push	905					; 00000389H
	lea	ecx, DWORD PTR [eax+eax*8]
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	shl	ecx, 4
	push	ecx
	push	edx
	mov	DWORD PTR _to_alloc$[ebp], eax
	call	_kb_temp_realloc
	mov	ecx, DWORD PTR _web+124
	mov	esi, DWORD PTR _dymem
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gdata$[ebp], eax
$LN209@plain_stri:

; 906  :       }
; 907  :       
; 908  :       fe = get_next_edge(fe);

	test	edi, 134217728				; 08000000H
	je	$LN148@plain_stri
	mov	eax, DWORD PTR tv1546[ebp]
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [eax+edx]
	mov	edi, DWORD PTR [eax+28]
	xor	edi, 134217728				; 08000000H
	jmp	$LN237@plain_stri
$LN54@plain_stri:

; 872  :       { edge_id e_id = get_fe_edge(fe);

	mov	edi, DWORD PTR _fe$89900[ebp]
	mov	edx, DWORD PTR _web+460
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+edx]

; 873  :         vertex_id *v = get_edge_vertices(e_id);

	mov	edx, DWORD PTR _web+216
	mov	ebx, DWORD PTR [edx+esi+304]
	mov	eax, DWORD PTR [eax+20]

; 874  :         REAL *midx;
; 875  :         
; 876  :         gdata[vcount+web.lagrange_order-1].v_id = get_fe_headv(fe);

	mov	esi, DWORD PTR _fe$89900[ebp]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	and	esi, 134217728				; 08000000H
	add	edx, ebx
	xor	eax, esi
	mov	DWORD PTR tv1546[ebp], edi
	mov	DWORD PTR _v$90011[ebp], edx
	test	eax, 134217728				; 08000000H
	je	SHORT $LN128@plain_stri
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ebx, DWORD PTR [ebx+eax]
	jmp	SHORT $LN127@plain_stri
$LN128@plain_stri:
	mov	edx, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ebx, DWORD PTR [eax+ebx]
$LN127@plain_stri:
	mov	eax, DWORD PTR _web+632
	add	eax, DWORD PTR _vcount$89898[ebp]
	mov	ecx, DWORD PTR _gdata$[ebp]
	lea	eax, DWORD PTR [eax+eax*8]
	add	eax, eax
	mov	DWORD PTR [ecx+eax*8-12], ebx

; 877  :         get_edge_side(get_fe_edge(fe),s);

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edi+eax]
	lea	edx, DWORD PTR _s$89927[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+20]
	xor	edx, esi
	push	edx
	call	_get_edge_side

; 878  :   
; 879  :         for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	add	esp, 8
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN17@plain_stri

; 874  :         REAL *midx;
; 875  :         
; 876  :         gdata[vcount+web.lagrange_order-1].v_id = get_fe_headv(fe);

	mov	ecx, DWORD PTR _vcount$89898[ebp]
	mov	edx, DWORD PTR _gdata$[ebp]
	lea	ecx, DWORD PTR [ecx+ecx*8]
	add	ecx, ecx
	lea	ebx, DWORD PTR [edx+ecx*8-144]
	npad	12
$LL19@plain_stri:

; 880  :           gdata[vcount+web.lagrange_order-1].x[i] = gdata[vcount-1].x[i] + s[i]; 

	mov	ecx, DWORD PTR _web+632
	fld	QWORD PTR _s$89927[ebp+eax*8]
	add	ecx, DWORD PTR _vcount$89898[ebp]
	fadd	QWORD PTR [ebx]
	add	ebx, 8
	lea	ecx, DWORD PTR [ecx+ecx*8]
	lea	edx, DWORD PTR [eax+ecx*2]
	mov	ecx, DWORD PTR _gdata$[ebp]
	fstp	QWORD PTR [ecx+edx*8-144]
	mov	edx, DWORD PTR _web+616
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL19@plain_stri
$LN17@plain_stri:

; 881  :       
; 882  :         if ( inverted(get_fe_edge(fe)) )

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx+20]

; 883  :         { REAL *headx = get_coord(get_fe_headv(fe));

	mov	edi, DWORD PTR _web+216
	mov	ecx, eax
	xor	ecx, DWORD PTR _fe$89900[ebp]
	xor	eax, esi
	mov	esi, DWORD PTR _dymem
	test	ecx, 134217728				; 08000000H
	mov	ecx, DWORD PTR _web+124
	je	$LN16@plain_stri
	test	eax, 134217728				; 08000000H
	je	SHORT $LN138@plain_stri
	mov	edi, DWORD PTR [edi+esi+304]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+edi]
	jmp	SHORT $LN137@plain_stri
$LN138@plain_stri:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	add	eax, DWORD PTR [edi+esi+304]
	mov	edi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edi*4]
$LN137@plain_stri:
	mov	edi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _web+104
	add	edi, DWORD PTR [eax+esi+64]

; 884  :           for ( n = 1 ; n < web.lagrange_order ; n++ )

	mov	ebx, 1
	mov	DWORD PTR _headx$90022[ebp], edi
	mov	DWORD PTR _n$[ebp], ebx
	cmp	DWORD PTR _web+632, ebx
	jle	$LN197@plain_stri

; 883  :         { REAL *headx = get_coord(get_fe_headv(fe));

	mov	eax, DWORD PTR _vcount$89898[ebp]
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 4
	add	eax, DWORD PTR _gdata$[ebp]
	mov	DWORD PTR tv3155[ebp], eax
	npad	8
$LL15@plain_stri:

; 885  :           { midx = get_coord(v[web.lagrange_order - n]);

	mov	ecx, DWORD PTR _web+632
	mov	eax, DWORD PTR _v$90011[ebp]
	sub	ecx, ebx
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _web+104
	add	ecx, DWORD PTR [eax+esi+64]

; 886  :             for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN14@plain_stri
	mov	esi, DWORD PTR tv3155[ebp]
	sub	edi, ecx
	npad	10
$LL190@plain_stri:

; 887  :               gdata[vcount+n-1].x[i] = gdata[vcount+web.lagrange_order-1].x[i] - (headx[i]-midx[i]);

	mov	edx, DWORD PTR _web+632
	fld	QWORD PTR [ecx+edi]
	add	edx, DWORD PTR _vcount$89898[ebp]
	fsub	QWORD PTR [ecx]
	mov	ebx, DWORD PTR _gdata$[ebp]
	lea	edx, DWORD PTR [edx+edx*8]
	lea	edx, DWORD PTR [eax+edx*2]
	fsubr	QWORD PTR [ebx+edx*8-144]
	inc	eax
	add	ecx, 8
	add	esi, 8
	fstp	QWORD PTR [esi-8]
	mov	edx, DWORD PTR _web+616
	cmp	eax, edx
	jl	SHORT $LL190@plain_stri

; 886  :             for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _dymem
	mov	ebx, DWORD PTR _n$[ebp]
	mov	edi, DWORD PTR _headx$90022[ebp]
$LN14@plain_stri:

; 884  :           for ( n = 1 ; n < web.lagrange_order ; n++ )

	add	DWORD PTR tv3155[ebp], 144		; 00000090H
	inc	ebx
	mov	DWORD PTR _n$[ebp], ebx
	cmp	ebx, DWORD PTR _web+632
	jl	$LL15@plain_stri

; 888  :           }
; 889  :         }
; 890  :         else 

	jmp	$LN236@plain_stri
$LN16@plain_stri:

; 891  :         { REAL *tailx = get_coord(get_fe_tailv(fe));

	test	eax, 134217728				; 08000000H
	je	SHORT $LN144@plain_stri
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	add	eax, DWORD PTR [edi+esi+304]
	mov	edi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN143@plain_stri
$LN144@plain_stri:
	mov	edi, DWORD PTR [edi+esi+304]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+edi]
$LN143@plain_stri:
	mov	edi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+104
	add	eax, DWORD PTR [edi+esi+64]

; 892  :           for ( n = 1 ; n < web.lagrange_order ; n++ )

	mov	edi, 1
	mov	DWORD PTR _tailx$90038[ebp], eax
	mov	DWORD PTR _n$[ebp], edi
	cmp	DWORD PTR _web+632, edi
	jle	$LN197@plain_stri

; 891  :         { REAL *tailx = get_coord(get_fe_tailv(fe));

	mov	ecx, DWORD PTR _vcount$89898[ebp]
	lea	ecx, DWORD PTR [ecx+ecx*8]
	shl	ecx, 4
	add	ecx, DWORD PTR _gdata$[ebp]
	mov	DWORD PTR tv1556[ebp], ecx
	mov	DWORD PTR tv3338[ebp], ecx
	npad	14
$LL196@plain_stri:

; 893  :           { midx = get_coord(v[n]);

	mov	edi, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _v$90011[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR _web+104
	add	ebx, DWORD PTR [ecx+esi+64]

; 894  :             for ( i = 0 ; i < SDIM ; i++ )

	xor	edi, edi
	test	edx, edx
	jle	SHORT $LN7@plain_stri

; 893  :           { midx = get_coord(v[n]);

	mov	ecx, DWORD PTR tv1556[ebp]
	mov	esi, DWORD PTR tv3338[ebp]
	add	ecx, -144				; ffffff70H

; 894  :             for ( i = 0 ; i < SDIM ; i++ )

	sub	ebx, DWORD PTR _tailx$90038[ebp]
$LL5@plain_stri:

; 895  :               gdata[vcount+n-1].x[i]  = gdata[vcount-1].x[i] + (midx[i]-tailx[i]);

	fld	QWORD PTR [ebx+eax]
	inc	edi
	fsub	QWORD PTR [eax]
	add	eax, 8
	add	ecx, 8
	add	esi, 8
	fadd	QWORD PTR [ecx-8]
	fstp	QWORD PTR [esi-8]
	mov	edx, DWORD PTR _web+616
	cmp	edi, edx
	jl	SHORT $LL5@plain_stri

; 894  :             for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR _tailx$90038[ebp]
$LN7@plain_stri:

; 892  :           for ( n = 1 ; n < web.lagrange_order ; n++ )

	mov	ecx, DWORD PTR _n$[ebp]
	add	DWORD PTR tv3338[ebp], 144		; 00000090H
	inc	ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, DWORD PTR _web+632
	jl	$LL196@plain_stri
$LN236@plain_stri:
	mov	ecx, DWORD PTR _web+124
$LN197@plain_stri:

; 896  :           }
; 897  :         }
; 898  : 
; 899  :         vcount += web.lagrange_order;

	mov	edx, DWORD PTR _web+632
	add	DWORD PTR _vcount$89898[ebp], edx
	mov	edi, DWORD PTR _fe$89900[ebp]
	mov	ebx, DWORD PTR _to_alloc$[ebp]
	jmp	$LN20@plain_stri

; 906  :       }
; 907  :       
; 908  :       fe = get_next_edge(fe);

$LN148@plain_stri:
	mov	edx, DWORD PTR tv1546[ebp]
	mov	eax, DWORD PTR _web+460
	mov	edx, DWORD PTR [edx+eax]
	mov	edi, DWORD PTR [edx+32]
$LN237@plain_stri:
	mov	DWORD PTR _fe$89900[ebp], edi

; 909  :     } while ( valid_id(fe) && !equal_id(fe,start_fe) );

	test	edi, 268435456				; 10000000H
	je	SHORT $LN1@plain_stri
	cmp	edi, DWORD PTR _start_fe$89899[ebp]
	jne	$LL62@plain_stri
$LN1@plain_stri:

; 910  :     graph_string_facet(f_id,gdata,vcount);  

	mov	eax, DWORD PTR _vcount$89898[ebp]
	mov	ecx, DWORD PTR _gdata$[ebp]
	mov	edx, DWORD PTR _f_id$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_graph_string_facet
	add	esp, 12					; 0000000cH
$LN76@plain_stri:

; 744  :   }
; 745  :      
; 746  :   MFOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR tv1485[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR [eax+ecx]
	mov	esi, DWORD PTR [edx]
	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _f_id$[ebp], esi
	mov	DWORD PTR tv1482[ebp], eax
	jne	$LL205@plain_stri
$LN211@plain_stri:
	pop	edi
	pop	ebx
$LN170@plain_stri:

; 911  : 
; 912  :   } /* end FOR_ALL_FACETS */
; 913  : 
; 914  :   temp_free((char*)gdata);

	mov	eax, DWORD PTR _gdata$[ebp]
	push	eax
	call	_temp_free

; 915  : 
; 916  : } /* end plain_facets() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 4
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_plain_string_facets ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_torus_cells
; Function compile flags: /Ogtp
;	COMDAT _torus_cells
_TEXT	SEGMENT
_invper$ = -848						; size = 4
tv2184 = -844						; size = 4
_fe_id$ = -840						; size = 4
tv4721 = -836						; size = 8
tv5024 = -832						; size = 4
_v$91450 = -832						; size = 4
_mag1$91386 = -828					; size = 8
tv4885 = -824						; size = 4
tv4870 = -824						; size = 4
tv4834 = -824						; size = 4
_fe$ = -820						; size = 4
_facet_galloc$ = -816					; size = 4
_f_id$ = -812						; size = 4
tv2295 = -808						; size = 4
_mag2$91388 = -804					; size = 8
tv5115 = -800						; size = 4
tv3295 = -800						; size = 4
tv2353 = -800						; size = 4
_k$91449 = -800						; size = 4
_k$91394 = -800						; size = 4
_show_this_facet$91327 = -796				; size = 4
tv5166 = -792						; size = 4
tv3299 = -792						; size = 4
_e_id$ = -792						; size = 4
_facet_gdata$ = -788					; size = 4
tv2302 = -784						; size = 4
_segments$91393 = -784					; size = 4
_facet_gcount$ = -780					; size = 4
_wrap$ = -776						; size = 4
_midx$91384 = -772					; size = 48
_headx$91382 = -724					; size = 48
_gdata$ = -676						; size = 432
_xx$91391 = -244					; size = 48
_w$91389 = -196						; size = 48
_tailx$91383 = -148					; size = 48
_ww$91342 = -124					; size = 24
_w1$91385 = -100					; size = 48
_w2$91387 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_torus_cells PROC					; COMDAT

; 2805 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 848				; 00000350H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2806 :   facet_id f_id;
; 2807 :   struct graphdata gdata[3];
; 2808 :   REAL *x;
; 2809 :   facetedge_id fe_id,fe;
; 2810 :   int i; 
; 2811 :   WRAPTYPE wrap = 0;

	xor	esi, esi

; 2812 :   edge_id e_id;
; 2813 :   REAL **invper;
; 2814 :   /* for showing full facets, accumulate list of vertices */
; 2815 :   struct graphdata *facet_gdata = NULL;
; 2816 :   int facet_gcount = 0;
; 2817 :   int facet_galloc = 0;
; 2818 : 
; 2819 :   memset(gdata,0,3*sizeof(struct graphdata));

	push	432					; 000001b0H
	lea	eax, DWORD PTR _gdata$[ebp]
	push	esi
	push	eax
	mov	DWORD PTR _wrap$[ebp], esi
	mov	DWORD PTR _facet_gdata$[ebp], esi
	mov	DWORD PTR _facet_galloc$[ebp], esi
	call	_memset

; 2820 : 
; 2821 :   if ( show_expr[FACET] && show_expr[FACET]->start ) 

	mov	eax, DWORD PTR _show_expr+8
	add	esp, 12					; 0000000cH
	cmp	eax, esi
	je	SHORT $LN88@torus_cell
	cmp	DWORD PTR [eax], esi
	je	SHORT $LN88@torus_cell

; 2822 :   { facet_galloc = 100;
; 2823 :     facet_gdata = (struct graphdata *)temp_calloc(facet_galloc,
; 2824 :        sizeof(struct graphdata));

	push	2824					; 00000b08H
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	push	144					; 00000090H
	push	100					; 00000064H
	mov	DWORD PTR _facet_galloc$[ebp], 100	; 00000064H
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _facet_gdata$[ebp], eax
$LN88@torus_cell:

; 2825 :   }
; 2826 :  
; 2827 : /*
; 2828 :   if ( web.torus_display_period )
; 2829 :   { 
; 2830 :     invper = web.inverse_display_periods;
; 2831 :   }
; 2832 :   else
; 2833 : */
; 2834 :   { 
; 2835 :     invper = web.inverse_periods;
; 2836 :   }
; 2837 :   MFOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+272
	mov	ecx, DWORD PTR _web+1612
	mov	edi, eax
	shr	edi, 28					; 0000001cH
	and	edi, 1
	mov	DWORD PTR _invper$[ebp], ecx
	mov	DWORD PTR _f_id$[ebp], eax
	je	$LN237@torus_cell
	mov	edx, DWORD PTR _web+616
	push	ebx
	mov	ebx, DWORD PTR _dymem
	jmp	SHORT $LN87@torus_cell
	npad	8
$LL231@torus_cell:
	mov	eax, DWORD PTR _f_id$[ebp]
$LN87@torus_cell:
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2184[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN86@torus_cell

; 2838 :   { int show_this_facet = 0;
; 2839 : 
; 2840 : 
; 2841 :     #ifdef MPI_EVOLVER
; 2842 :     if ( !mpi_show_corona_flag && (id_task(f_id) != this_task) )
; 2843 :        continue;
; 2844 :     #endif
; 2845 : 
; 2846 :     if ( show_expr[FACET] && show_expr[FACET]->start )

	mov	eax, DWORD PTR _show_expr+8
	xor	esi, esi
	mov	DWORD PTR _show_this_facet$91327[ebp], esi
	cmp	eax, esi
	je	SHORT $LN232@torus_cell
	cmp	DWORD PTR [eax], esi
	je	SHORT $LN232@torus_cell

; 2847 :     { if ( !eval(show_expr[FACET],NULL,f_id,NULL) ) continue;

	mov	edx, DWORD PTR _f_id$[ebp]
	push	esi
	push	edx
	push	esi
	push	eax
	call	_eval
	fldz

; 2848 :       else show_this_facet = 1;

	mov	edx, DWORD PTR _web+616
	fucompp
	mov	ebx, DWORD PTR _dymem
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN86@torus_cell
	mov	DWORD PTR _show_this_facet$91327[ebp], 1
$LN232@torus_cell:

; 2849 :     }
; 2850 :     
; 2851 :     if ( breakflag ) break;

	cmp	DWORD PTR _breakflag, esi
	jne	$LN248@torus_cell

; 2852 :     facet_gcount = 0;

	mov	DWORD PTR _facet_gcount$[ebp], esi

; 2853 : 
; 2854 :     fe_id = get_facet_fe(f_id);

	cmp	edi, esi
	jne	SHORT $LN92@torus_cell
	xor	eax, eax
	jmp	SHORT $LN91@torus_cell
$LN92@torus_cell:
	test	DWORD PTR _f_id$[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR tv2184[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+28]
	je	SHORT $LN91@torus_cell
	xor	eax, 134217728				; 08000000H
$LN91@torus_cell:

; 2855 :     x = get_coord(get_fe_tailv(fe_id));

	mov	edi, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR _fe_id$[ebp], eax
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN98@torus_cell
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+216
	add	eax, DWORD PTR [ecx+ebx+304]
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN97@torus_cell
$LN98@torus_cell:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+ebx+304]
	mov	eax, DWORD PTR [eax+ecx]
$LN97@torus_cell:
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	edi, DWORD PTR [eax+ebx+64]

; 2856 :     for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	cmp	edx, 4
	jl	SHORT $LN244@torus_cell

; 2857 :       gdata[0].x[i] = x[i];

	lea	esi, DWORD PTR _gdata$[ebp]
	sub	esi, edi
	mov	DWORD PTR tv3295[ebp], esi
	lea	esi, DWORD PTR _gdata$[ebp+8]
	sub	esi, edi
	lea	eax, DWORD PTR [edi+16]
	mov	DWORD PTR tv3299[ebp], esi
	npad	8
$LL243@torus_cell:
	fld	QWORD PTR [eax-16]
	mov	esi, DWORD PTR tv3295[ebp]
	fstp	QWORD PTR _gdata$[ebp+ecx*8]
	add	ecx, 4
	fld	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR _gdata$[ebp+ecx*8-24]
	fld	QWORD PTR [eax-32]
	fstp	QWORD PTR [esi+eax-32]
	mov	esi, DWORD PTR tv3299[ebp]
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [esi+eax-32]
	lea	esi, DWORD PTR [edx-3]
	cmp	ecx, esi
	jl	SHORT $LL243@torus_cell
$LN244@torus_cell:

; 2856 :     for ( i = 0 ; i < SDIM ; i++ )

	cmp	ecx, edx
	jge	SHORT $LN208@torus_cell
	mov	eax, edi
	lea	esi, DWORD PTR _gdata$[ebp]
	sub	eax, esi
	npad	7
$LC78@torus_cell:
	lea	esi, DWORD PTR [eax+ecx*8]

; 2857 :       gdata[0].x[i] = x[i];

	fld	QWORD PTR _gdata$[ebp+esi]
	inc	ecx
	fstp	QWORD PTR _gdata$[ebp+ecx*8-8]
	cmp	ecx, edx
	jl	SHORT $LC78@torus_cell
$LN208@torus_cell:

; 2858 : 
; 2859 :     /* wrap back to center */
; 2860 :     if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	je	$LN75@torus_cell

; 2861 :     { int ww[MAXCOORD];
; 2862 :       for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN72@torus_cell
	mov	ebx, DWORD PTR _invper$[ebp]
	lea	ecx, DWORD PTR _ww$91342[ebp]
	sub	ebx, ecx
$LL74@torus_cell:

; 2863 :         ww[i] = (int)floor(SDIM_dot(invper[i],gdata[0].x));

	push	edx
	lea	edx, DWORD PTR _gdata$[ebp]
	lea	eax, DWORD PTR [ebx+esi*4]
	mov	ecx, DWORD PTR _ww$91342[ebp+eax]
	push	edx
	push	ecx
	call	_dot
	fstp	QWORD PTR [esp+4]
	add	esp, 4
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR _ww$91342[ebp+esi*4], eax
	inc	esi
	cmp	esi, edx
	jl	SHORT $LL74@torus_cell
$LN72@torus_cell:

; 2864 :       for ( i = 0, wrap = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	xor	eax, eax
	mov	DWORD PTR _wrap$[ebp], ecx
	test	edx, edx
	jle	SHORT $LN69@torus_cell
	npad	6
$LL71@torus_cell:

; 2865 :       { wrap <<= TWRAPBITS;
; 2866 :         wrap |= ww[i] & WRAPMASK;

	mov	esi, DWORD PTR _ww$91342[ebp+eax*4]
	and	esi, 31					; 0000001fH
	shl	ecx, 6
	inc	eax
	or	ecx, esi
	cmp	eax, edx
	jl	SHORT $LL71@torus_cell
	mov	DWORD PTR _wrap$[ebp], ecx
$LN69@torus_cell:

; 2867 :       }
; 2868 :       (*sym_wrap)(x,gdata[0].x,wrap);

	push	ecx
	lea	edx, DWORD PTR _gdata$[ebp]
	push	edx
	push	edi
	call	DWORD PTR _sym_wrap
	mov	edx, DWORD PTR _web+616
	mov	ebx, DWORD PTR _dymem
	add	esp, 12					; 0000000cH
$LN75@torus_cell:

; 2869 :     }
; 2870 :     if ( show_this_facet )

	cmp	DWORD PTR _show_this_facet$91327[ebp], 0
	je	SHORT $LN68@torus_cell

; 2871 :     { facet_gdata[0] = gdata[0];

	mov	edi, DWORD PTR _facet_gdata$[ebp]
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata$[ebp]
	rep movsd

; 2872 :       facet_gcount = 1;

	mov	edx, DWORD PTR _web+616
	mov	ebx, DWORD PTR _dymem
	mov	DWORD PTR _facet_gcount$[ebp], 1
$LN68@torus_cell:

; 2873 :     }
; 2874 : 
; 2875 :     fe = fe_id;

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	DWORD PTR _fe$[ebp], eax
	npad	13
$LL67@torus_cell:

; 2876 :     do
; 2877 :     { /* follow edges, keeping track of wrap */
; 2878 :       if ( !valid_id(fe) ) break;

	test	DWORD PTR _fe$[ebp], 268435456		; 10000000H
	je	$LN65@torus_cell

; 2879 :       gdata[0].id = e_id = get_fe_edge(fe);

	mov	edi, DWORD PTR _fe$[ebp]
	mov	ecx, DWORD PTR _web+460
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+20]
	and	edi, 134217728				; 08000000H
	xor	eax, edi

; 2880 :       gdata[0].color = gdata[0].ecolor = get_edge_color_2(gdata[0].id);

	push	eax
	mov	DWORD PTR tv2295[ebp], esi
	mov	DWORD PTR tv2302[ebp], edi
	mov	DWORD PTR _e_id$[ebp], eax
	mov	DWORD PTR _gdata$[ebp+128], eax
	call	_get_edge_color_2

; 2881 :       gdata[0].etype = REGULAR_EDGE;
; 2882 :       gdata[0].flags = 0;
; 2883 :       gdata[0].v_id = get_fe_tailv(fe);

	mov	ecx, DWORD PTR _web+460
	mov	DWORD PTR _gdata$[ebp+120], eax
	mov	DWORD PTR _gdata$[ebp+104], eax
	mov	eax, 1
	mov	WORD PTR _gdata$[ebp+124], ax
	mov	DWORD PTR _gdata$[ebp+136], 0
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _web+124
	xor	eax, edi
	add	esp, 4
	test	eax, 134217728				; 08000000H
	je	SHORT $LN106@torus_cell
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+636
	lea	edx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN278@torus_cell
$LN106@torus_cell:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
$LN278@torus_cell:
	mov	ecx, DWORD PTR _web+216
	mov	eax, DWORD PTR [ecx+ebx+304]
	mov	eax, DWORD PTR [edx+eax]

; 2884 :       gdata[1].v_id = get_fe_headv(fe);

	mov	edx, DWORD PTR _web+460
	mov	DWORD PTR _gdata$[ebp+132], eax
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _web+124
	xor	eax, edi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN112@torus_cell
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN279@torus_cell
$LN112@torus_cell:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+edx*4]
$LN279@torus_cell:

; 2885 :       
; 2886 :       if ( show_this_facet && (facet_gcount > facet_galloc-20) )

	cmp	DWORD PTR _show_this_facet$91327[ebp], 0
	mov	edx, DWORD PTR [ecx+ebx+304]
	mov	eax, DWORD PTR [eax+edx]
	mov	DWORD PTR _gdata$[ebp+276], eax
	je	SHORT $LN240@torus_cell
	mov	eax, DWORD PTR _facet_galloc$[ebp]
	lea	edx, DWORD PTR [eax-20]
	cmp	DWORD PTR _facet_gcount$[ebp], edx
	jle	SHORT $LN240@torus_cell

; 2887 :       { facet_galloc *= 2;
; 2888 :         facet_gdata = (struct graphdata *)temp_realloc((char*)facet_gdata,
; 2889 :            facet_galloc*sizeof(struct graphdata));

	mov	ecx, DWORD PTR _facet_gdata$[ebp]
	add	eax, eax
	mov	DWORD PTR _facet_galloc$[ebp], eax
	push	2889					; 00000b49H
	lea	eax, DWORD PTR [eax+eax*8]
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	shl	eax, 4
	push	eax
	push	ecx
	call	_kb_temp_realloc
	mov	ecx, DWORD PTR _web+216
	mov	ebx, DWORD PTR _dymem
	add	esp, 16					; 00000010H
	mov	DWORD PTR _facet_gdata$[ebp], eax
$LN240@torus_cell:

; 2890 :       }
; 2891 :  
; 2892 :       if ( web.modeltype == LINEAR )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	jne	SHORT $LN62@torus_cell

; 2893 :       {
; 2894 :         wrap = (*sym_compose)(wrap,get_fe_wrap(fe)); 

	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+20]
	mov	esi, DWORD PTR _web+124
	xor	eax, edi
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	jmp	$LN285@torus_cell
$LN62@torus_cell:

; 2895 :       }
; 2896 :       else if ( web.modeltype == QUADRATIC )

	cmp	eax, 2
	jne	$LN60@torus_cell

; 2897 :       { gdata[1] = gdata[0];
; 2898 :         if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]
	shr	eax, 27					; 0000001bH
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata$[ebp]
	lea	edi, DWORD PTR _gdata$[ebp+144]
	and	eax, 1
	rep movsd
	mov	DWORD PTR tv2353[ebp], eax
	je	SHORT $LN59@torus_cell

; 2899 :            wrap = (*sym_compose)(wrap,get_fe_wrap(fe)); 

	mov	eax, DWORD PTR tv2295[ebp]
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+20]
	xor	eax, DWORD PTR tv2302[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ebx+784]
	mov	ecx, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN125@torus_cell
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN126@torus_cell
$LN125@torus_cell:
	mov	eax, ecx
$LN126@torus_cell:
	push	eax
	mov	eax, DWORD PTR _wrap$[ebp]
	push	eax
	call	DWORD PTR _sym_compose
	mov	ebx, DWORD PTR _dymem
	add	esp, 8
	mov	DWORD PTR _wrap$[ebp], eax
$LN59@torus_cell:

; 2900 :         x = get_coord(get_fe_midv(fe));
; 2901 :         (*sym_wrap)(x,gdata[1].x,wrap); 

	mov	ecx, DWORD PTR _wrap$[ebp]
	mov	eax, DWORD PTR _web+460
	mov	esi, DWORD PTR tv2295[ebp]
	push	ecx
	mov	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR _web+124
	lea	edx, DWORD PTR _gdata$[ebp+144]
	push	edx
	mov	edx, DWORD PTR [ecx+20]
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+216
	mov	eax, DWORD PTR [edx+ebx+304]
	mov	ecx, DWORD PTR [ecx+eax+8]
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+104
	add	eax, DWORD PTR [ecx+ebx+64]
	push	eax
	call	DWORD PTR _sym_wrap

; 2902 :         gdata[0].flags &= LABEL_TAIL;

	and	DWORD PTR _gdata$[ebp+136], 4096	; 00001000H
	add	esp, 12					; 0000000cH

; 2903 :         if ( circular_arc_flag && (graph_capabilities & GC_ARCS) )

	cmp	DWORD PTR _circular_arc_flag, 0
	je	$LN58@torus_cell
	test	BYTE PTR _graph_capabilities, 1
	je	$LN58@torus_cell

; 2904 :         { x = get_coord(get_fe_headv(fe));

	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+20]
	xor	eax, DWORD PTR tv2302[ebp]
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	edi, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	add	ecx, esi
	test	eax, 134217728				; 08000000H
	jne	SHORT $LN280@torus_cell
	mov	ebx, DWORD PTR _web+636
	lea	edx, DWORD PTR [edx+ebx*4]
$LN280@torus_cell:
	mov	ebx, DWORD PTR [ecx+304]
	mov	edx, DWORD PTR [edx+ebx]
	mov	ebx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR _web+104
	add	ebx, DWORD PTR [edx+esi+64]

; 2905 :           if ( !inverted(e_id) )

	cmp	DWORD PTR tv2353[ebp], 0
	jne	SHORT $LN57@torus_cell

; 2906 :             wrap = (*sym_compose)(wrap,get_fe_wrap(fe)); 

	mov	ecx, DWORD PTR [ecx+784]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN139@torus_cell
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN140@torus_cell
$LN139@torus_cell:
	mov	eax, ecx
$LN140@torus_cell:
	mov	edx, DWORD PTR _wrap$[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose
	add	esp, 8
	mov	DWORD PTR _wrap$[ebp], eax
$LN57@torus_cell:

; 2907 :           (*sym_wrap)(x,gdata[2].x,wrap); 

	mov	eax, DWORD PTR _wrap$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gdata$[ebp+288]
	push	ecx
	push	ebx
	call	DWORD PTR _sym_wrap

; 2908 :           gdata[0].flags |= EDGE_ARC;
; 2909 :           (*graph_edge_transforms)(gdata,gdata[0].id);

	mov	edx, DWORD PTR _gdata$[ebp+128]
	or	DWORD PTR _gdata$[ebp+136], 32768	; 00008000H
	push	edx
	lea	eax, DWORD PTR _gdata$[ebp]
	push	eax
	call	_graph_edge_transforms
	add	esp, 20					; 00000014H

; 2910 :           gdata[0] = gdata[2];

	lea	esi, DWORD PTR _gdata$[ebp+288]

; 2911 :           goto next_edge;

	jmp	$LN281@torus_cell
$LN58@torus_cell:

; 2912 :         }
; 2913 :         else
; 2914 :         { REAL headx[MAXCOORD];
; 2915 :           REAL tailx[MAXCOORD];
; 2916 :           REAL midx[MAXCOORD];
; 2917 :           REAL w1[MAXCOORD],mag1;
; 2918 :           REAL w2[MAXCOORD],mag2;
; 2919 :           REAL w[MAXCOORD],mag;
; 2920 :           REAL xx[MAXCOORD];
; 2921 :           REAL ang;
; 2922 :           int segments;
; 2923 :           int k;
; 2924 : 
; 2925 :           x = get_coord(get_fe_headv(fe));

	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+20]
	xor	eax, DWORD PTR tv2302[ebp]
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ebx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	add	ecx, esi
	test	eax, 134217728				; 08000000H
	jne	SHORT $LN282@torus_cell
	mov	edi, DWORD PTR _web+636
	lea	edx, DWORD PTR [edx+edi*4]
$LN282@torus_cell:
	mov	edi, DWORD PTR [ecx+304]
	mov	edx, DWORD PTR [edx+edi]
	mov	edi, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR _web+104
	add	edi, DWORD PTR [edx+esi+64]

; 2926 :           if ( !inverted(e_id) )

	cmp	DWORD PTR tv2353[ebp], 0
	jne	SHORT $LN241@torus_cell

; 2927 :             wrap = (*sym_compose)(wrap,get_fe_wrap(fe)); 

	mov	ecx, DWORD PTR [ecx+784]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN151@torus_cell
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN152@torus_cell
$LN151@torus_cell:
	mov	eax, ecx
$LN152@torus_cell:
	mov	edx, DWORD PTR _wrap$[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose
	add	esp, 8
	mov	DWORD PTR _wrap$[ebp], eax
$LN241@torus_cell:

; 2928 :           (*sym_wrap)(x,gdata[2].x,wrap); 

	mov	eax, DWORD PTR _wrap$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gdata$[ebp+288]
	push	ecx
	push	edi
	call	DWORD PTR _sym_wrap

; 2929 : 
; 2930 : 
; 2931 :           for (i = 0 ; i < SDIM ; i++ ) 

	mov	ecx, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN233@torus_cell
	npad	8
$LL54@torus_cell:

; 2932 :           { headx[i] = gdata[2].x[i]; 

	fld	QWORD PTR _gdata$[ebp+eax*8+288]
	inc	eax
	fst	QWORD PTR _headx$91382[ebp+eax*8-8]

; 2933 :             tailx[i] = gdata[0].x[i];

	fld	QWORD PTR _gdata$[ebp+eax*8-8]
	fst	QWORD PTR _tailx$91383[ebp+eax*8-8]

; 2934 :             midx[i] = gdata[1].x[i];

	fld	QWORD PTR _gdata$[ebp+eax*8+136]
	fst	QWORD PTR _midx$91384[ebp+eax*8-8]

; 2935 :             w1[i] = midx[i] - tailx[i];

	fsub	ST(0), ST(1)
	fstp	QWORD PTR _w1$91385[ebp+eax*8-8]

; 2936 :             w2[i] = headx[i] - tailx[i];

	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _w2$91387[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LL54@torus_cell
$LN233@torus_cell:

; 2937 :           }
; 2938 :           mag1 = SDIM_dot(w1,w1); mag2 = SDIM_dot(w2,w2);

	push	ecx
	lea	edx, DWORD PTR _w1$91385[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	fstp	QWORD PTR _mag1$91386[ebp]
	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _w2$91387[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	fst	QWORD PTR _mag2$91388[ebp]

; 2939 :           for ( i = 0 ; i < SDIM  ; i++ )

	mov	edx, DWORD PTR _web+616
	fld	QWORD PTR _mag1$91386[ebp]
	add	esp, 24					; 00000018H
	xor	eax, eax
	cmp	edx, 4
	jl	SHORT $LC212@torus_cell
	lea	ecx, DWORD PTR [edx-3]
$LN213@torus_cell:

; 2940 :           { w1[i] /= mag1; w2[i] /= mag2; }

	fld	QWORD PTR _w1$91385[ebp+eax*8]
	add	eax, 4
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _w1$91385[ebp+eax*8-32]
	fld	QWORD PTR _w2$91387[ebp+eax*8-32]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _w2$91387[ebp+eax*8-32]
	fld	QWORD PTR _w1$91385[ebp+eax*8-24]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _w1$91385[ebp+eax*8-24]
	fld	QWORD PTR _w2$91387[ebp+eax*8-24]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _w2$91387[ebp+eax*8-24]
	fld	QWORD PTR _w1$91385[ebp+eax*8-16]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _w1$91385[ebp+eax*8-16]
	fld	QWORD PTR _w2$91387[ebp+eax*8-16]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _w2$91387[ebp+eax*8-16]
	fld	QWORD PTR _w1$91385[ebp+eax*8-8]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _w1$91385[ebp+eax*8-8]
	fld	QWORD PTR _w2$91387[ebp+eax*8-8]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _w2$91387[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN213@torus_cell
$LC212@torus_cell:

; 2939 :           for ( i = 0 ; i < SDIM  ; i++ )

	cmp	eax, edx
	jge	SHORT $LN258@torus_cell
$LC51@torus_cell:

; 2940 :           { w1[i] /= mag1; w2[i] /= mag2; }

	fld	QWORD PTR _w1$91385[ebp+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _w1$91385[ebp+eax*8-8]
	fld	QWORD PTR _w2$91387[ebp+eax*8-8]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _w2$91387[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC51@torus_cell
$LN258@torus_cell:

; 2941 : 
; 2942 :           /* figure out how many segments to do */
; 2943 :           ang = 4*acos(SDIM_dot(w1,w2)*sqrt(mag1*mag2));

	push	edx
	fstp	ST(1)
	lea	ecx, DWORD PTR _w2$91387[ebp]
	fstp	ST(0)
	push	ecx
	lea	edx, DWORD PTR _w1$91385[ebp]
	push	edx
	call	_dot
	fstp	QWORD PTR tv4721[ebp]
	fld	QWORD PTR _mag2$91388[ebp]
	add	esp, 12					; 0000000cH
	fmul	QWORD PTR _mag1$91386[ebp]
	call	__CIsqrt
	fmul	QWORD PTR tv4721[ebp]
	call	__CIacos
	fmul	QWORD PTR __real@4010000000000000

; 2944 :           segments = (int)(ang/(M_PI/180*string_curve_tolerance));

	fld	QWORD PTR _string_curve_tolerance
	fmul	QWORD PTR __real@3f91df46a2529d39
	fdivp	ST(1), ST(0)
	call	__ftol2_sse
	mov	DWORD PTR _segments$91393[ebp], eax

; 2945 :           if ( segments < 2 ) 

	cmp	eax, 2
	jge	SHORT $LN48@torus_cell

; 2946 :             segments = 2;

	mov	DWORD PTR _segments$91393[ebp], 2
	mov	eax, DWORD PTR _segments$91393[ebp]
$LN48@torus_cell:

; 2947 :                 
; 2948 :           if ( show_this_facet )

	cmp	DWORD PTR _show_this_facet$91327[ebp], 0
	je	SHORT $LN242@torus_cell

; 2949 :             while (facet_gcount+segments > facet_galloc-20 )

	mov	ecx, DWORD PTR _facet_gcount$[ebp]
	mov	esi, DWORD PTR _facet_galloc$[ebp]
	lea	edi, DWORD PTR [eax+ecx]
	lea	edx, DWORD PTR [esi-20]
	cmp	edi, edx
	jle	SHORT $LN242@torus_cell
	mov	eax, DWORD PTR _facet_gdata$[ebp]
	npad	9
$LL46@torus_cell:

; 2950 :             { facet_galloc *= 2;

	add	esi, esi

; 2951 :               facet_gdata = (struct graphdata *)temp_realloc((char*)facet_gdata,
; 2952 :                 facet_galloc*sizeof(struct graphdata));

	push	2952					; 00000b88H
	lea	ecx, DWORD PTR [esi+esi*8]
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	shl	ecx, 4
	push	ecx
	push	eax
	call	_kb_temp_realloc
	lea	edx, DWORD PTR [esi-20]
	add	esp, 16					; 00000010H
	cmp	edi, edx
	jg	SHORT $LL46@torus_cell
	mov	DWORD PTR _facet_gdata$[ebp], eax
	mov	eax, DWORD PTR _segments$91393[ebp]
	mov	DWORD PTR _facet_galloc$[ebp], esi
$LN242@torus_cell:

; 2953 :             }
; 2954 :  
; 2955 :           for ( i = 0 ; i < SDIM ; i++ ) gdata[0].x[i] = tailx[i];

	mov	edx, DWORD PTR _web+616
	test	edx, edx
	jle	SHORT $LN44@torus_cell
	mov	ecx, edx
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	lea	esi, DWORD PTR _tailx$91383[ebp]
	lea	edi, DWORD PTR _gdata$[ebp]
	rep movsd
$LN44@torus_cell:

; 2956 :           for ( k = 1 ; k <= segments ; k++ )

	mov	ebx, 1
	mov	DWORD PTR _k$91394[ebp], ebx
	cmp	eax, ebx
	jl	$next_edge$91380
	mov	eax, DWORD PTR _facet_gcount$[ebp]
	lea	edi, DWORD PTR [eax+eax*8]
	shl	edi, 4
	add	edi, DWORD PTR _facet_gdata$[ebp]
	mov	DWORD PTR tv5024[ebp], edi
$LL41@torus_cell:

; 2957 :           { 
; 2958 :             if ( circular_arc_flag )
; 2959 :             { /* use circle as inversion of line */
; 2960 :               for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _circular_arc_flag, eax
	je	$LN38@torus_cell
	cmp	edx, 4
	jl	SHORT $LN245@torus_cell
	mov	ecx, DWORD PTR _segments$91393[ebp]
	sub	ecx, ebx

; 2961 :                 w[i] = w2[i] + (segments-k)/(REAL)k*(w1[i]-w2[i]);

	mov	DWORD PTR tv4885[ebp], ecx
	fild	DWORD PTR tv4885[ebp]
	lea	ecx, DWORD PTR [edx-3]
	fidiv	DWORD PTR _k$91394[ebp]
$LN216@torus_cell:
	fld	QWORD PTR _w1$91385[ebp+eax*8]
	add	eax, 4
	fsub	QWORD PTR _w2$91387[ebp+eax*8-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _w2$91387[ebp+eax*8-32]
	fstp	QWORD PTR _w$91389[ebp+eax*8-32]
	fld	QWORD PTR _w1$91385[ebp+eax*8-24]
	fsub	QWORD PTR _w2$91387[ebp+eax*8-24]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _w2$91387[ebp+eax*8-24]
	fstp	QWORD PTR _w$91389[ebp+eax*8-24]
	fld	QWORD PTR _w1$91385[ebp+eax*8-16]
	fsub	QWORD PTR _w2$91387[ebp+eax*8-16]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _w2$91387[ebp+eax*8-16]
	fstp	QWORD PTR _w$91389[ebp+eax*8-16]
	fld	QWORD PTR _w1$91385[ebp+eax*8-8]
	fsub	QWORD PTR _w2$91387[ebp+eax*8-8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _w2$91387[ebp+eax*8-8]
	fstp	QWORD PTR _w$91389[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN216@torus_cell
	fstp	ST(0)
$LN245@torus_cell:

; 2957 :           { 
; 2958 :             if ( circular_arc_flag )
; 2959 :             { /* use circle as inversion of line */
; 2960 :               for ( i = 0 ; i < SDIM ; i++ )

	cmp	eax, edx
	jge	SHORT $LN247@torus_cell
	mov	ecx, DWORD PTR _segments$91393[ebp]
	sub	ecx, ebx
	mov	DWORD PTR tv4870[ebp], ecx
	fild	DWORD PTR tv4870[ebp]
	fidiv	DWORD PTR _k$91394[ebp]
$LC37@torus_cell:

; 2961 :                 w[i] = w2[i] + (segments-k)/(REAL)k*(w1[i]-w2[i]);

	fld	QWORD PTR _w1$91385[ebp+eax*8]
	inc	eax
	fsub	QWORD PTR _w2$91387[ebp+eax*8-8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _w2$91387[ebp+eax*8-8]
	fstp	QWORD PTR _w$91389[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC37@torus_cell

; 2957 :           { 
; 2958 :             if ( circular_arc_flag )
; 2959 :             { /* use circle as inversion of line */
; 2960 :               for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN247@torus_cell:

; 2962 :               mag = SDIM_dot(w,w);

	push	edx
	lea	edx, DWORD PTR _w$91389[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot

; 2963 :               for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	xor	eax, eax
	cmp	ecx, 4
	jl	$LC218@torus_cell
	lea	edx, DWORD PTR [ecx-3]
$LN219@torus_cell:

; 2964 :                 gdata[1].x[i] = xx[i] = tailx[i] + w[i]/mag;

	fld	QWORD PTR _w$91389[ebp+eax*8]
	add	eax, 4
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR _tailx$91383[ebp+eax*8-32]
	fst	QWORD PTR _xx$91391[ebp+eax*8-32]
	fstp	QWORD PTR _gdata$[ebp+eax*8+112]
	fld	QWORD PTR _w$91389[ebp+eax*8-24]
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR _tailx$91383[ebp+eax*8-24]
	fst	QWORD PTR _xx$91391[ebp+eax*8-24]
	fstp	QWORD PTR _gdata$[ebp+eax*8+120]
	fld	QWORD PTR _w$91389[ebp+eax*8-16]
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR _tailx$91383[ebp+eax*8-16]
	fst	QWORD PTR _xx$91391[ebp+eax*8-16]
	fstp	QWORD PTR _gdata$[ebp+eax*8+128]
	fld	QWORD PTR _w$91389[ebp+eax*8-8]
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR _tailx$91383[ebp+eax*8-8]
	fst	QWORD PTR _xx$91391[ebp+eax*8-8]
	fstp	QWORD PTR _gdata$[ebp+eax*8+136]
	cmp	eax, edx
	jl	SHORT $LN219@torus_cell
$LC218@torus_cell:

; 2963 :               for ( i = 0 ; i < SDIM ; i++ )

	cmp	eax, ecx
	jge	$LN283@torus_cell
$LC34@torus_cell:

; 2964 :                 gdata[1].x[i] = xx[i] = tailx[i] + w[i]/mag;

	fld	QWORD PTR _w$91389[ebp+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR _tailx$91383[ebp+eax*8-8]
	fst	QWORD PTR _xx$91391[ebp+eax*8-8]
	fstp	QWORD PTR _gdata$[ebp+eax*8+136]
	cmp	eax, ecx
	jl	SHORT $LC34@torus_cell

; 2965 :             }
; 2966 :             else /* quadratic spline */

	jmp	$LN283@torus_cell
$LN38@torus_cell:

; 2967 :             { REAL t = 2*k/(REAL)segments;

	lea	ecx, DWORD PTR [ebx+ebx]
	mov	DWORD PTR tv4834[ebp], ecx
	fild	DWORD PTR tv4834[ebp]
	fidiv	DWORD PTR _segments$91393[ebp]

; 2968 :               REAL c1 = (t-1)*(t-2)/2;

	fld	QWORD PTR __real@3ff0000000000000
	fsubr	ST(0), ST(1)
	fld	ST(1)
	fld	QWORD PTR __real@4000000000000000
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)

; 2969 :               REAL c2 = t*(2-t);

	fxch	ST(2)
	fsub	ST(0), ST(4)
	fmul	ST(0), ST(4)

; 2970 :               REAL c3 = t*(t-1)/2; 

	fxch	ST(3)
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	fmulp	ST(1), ST(0)

; 2971 :               for ( i = 0 ; i < SDIM ; i++ )

	cmp	edx, 4
	jl	$LC221@torus_cell
	lea	ecx, DWORD PTR [edx-3]
$LN222@torus_cell:

; 2972 :                 gdata[1].x[i] = xx[i] = c1*tailx[i]+c2*midx[i]+c3*headx[i];

	fld	QWORD PTR _midx$91384[ebp+eax*8]
	add	eax, 4
	fmul	ST(0), ST(2)
	fld	QWORD PTR _tailx$91383[ebp+eax*8-32]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _headx$91382[ebp+eax*8-32]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _xx$91391[ebp+eax*8-32]
	fstp	QWORD PTR _gdata$[ebp+eax*8+112]
	fld	QWORD PTR _midx$91384[ebp+eax*8-24]
	fmul	ST(0), ST(2)
	fld	QWORD PTR _tailx$91383[ebp+eax*8-24]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _headx$91382[ebp+eax*8-24]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _xx$91391[ebp+eax*8-24]
	fstp	QWORD PTR _gdata$[ebp+eax*8+120]
	fld	QWORD PTR _midx$91384[ebp+eax*8-16]
	fmul	ST(0), ST(2)
	fld	QWORD PTR _tailx$91383[ebp+eax*8-16]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _headx$91382[ebp+eax*8-16]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _xx$91391[ebp+eax*8-16]
	fstp	QWORD PTR _gdata$[ebp+eax*8+128]
	fld	QWORD PTR _midx$91384[ebp+eax*8-8]
	fmul	ST(0), ST(2)
	fld	QWORD PTR _tailx$91383[ebp+eax*8-8]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _headx$91382[ebp+eax*8-8]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _xx$91391[ebp+eax*8-8]
	fstp	QWORD PTR _gdata$[ebp+eax*8+136]
	cmp	eax, ecx
	jl	$LN222@torus_cell
$LC221@torus_cell:

; 2971 :               for ( i = 0 ; i < SDIM ; i++ )

	cmp	eax, edx
	jge	SHORT $LN277@torus_cell
$LC30@torus_cell:

; 2972 :                 gdata[1].x[i] = xx[i] = c1*tailx[i]+c2*midx[i]+c3*headx[i];

	fld	QWORD PTR _midx$91384[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(2)
	fld	QWORD PTR _tailx$91383[ebp+eax*8-8]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _headx$91382[ebp+eax*8-8]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _xx$91391[ebp+eax*8-8]
	fstp	QWORD PTR _gdata$[ebp+eax*8+136]
	cmp	eax, edx
	jl	SHORT $LC30@torus_cell
$LN277@torus_cell:

; 2971 :               for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(2)
	fstp	ST(0)
$LN283@torus_cell:

; 2973 :             }
; 2974 :             if ( show_this_facet )

	cmp	DWORD PTR _show_this_facet$91327[ebp], 0
	fstp	ST(0)
	je	SHORT $LN27@torus_cell

; 2975 :                facet_gdata[facet_gcount++] = gdata[1];

	inc	DWORD PTR _facet_gcount$[ebp]
	add	DWORD PTR tv5024[ebp], 144		; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata$[ebp+144]
	rep movsd
	mov	edi, DWORD PTR tv5024[ebp]
$LN27@torus_cell:

; 2976 :             if ( labelflag )

	cmp	DWORD PTR _labelflag, 0
	je	SHORT $LN23@torus_cell

; 2977 :             {
; 2978 :               gdata[0].flags &= ~(LABEL_EDGE|LABEL_HEAD|LABEL_TAIL);

	and	DWORD PTR _gdata$[ebp+136], -7169	; ffffe3ffH

; 2979 :               if ( k == 1 ) gdata[0].flags |= LABEL_TAIL;

	cmp	ebx, 1
	jne	SHORT $LN25@torus_cell
	or	DWORD PTR _gdata$[ebp+136], 4096	; 00001000H
$LN25@torus_cell:

; 2980 :               if ( k == segments/2 ) gdata[0].flags |= LABEL_EDGE;

	mov	ecx, DWORD PTR _segments$91393[ebp]
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ebx, eax
	jne	SHORT $LN24@torus_cell
	or	DWORD PTR _gdata$[ebp+136], 1024	; 00000400H
$LN24@torus_cell:

; 2981 :               if ( k == segments ) gdata[0].flags |= LABEL_HEAD;

	cmp	ebx, ecx
	jne	SHORT $LN23@torus_cell
	or	DWORD PTR _gdata$[ebp+136], 2048	; 00000800H
$LN23@torus_cell:

; 2982 :             }
; 2983 :             (*graph_edge_transforms)(gdata,e_id);

	mov	edx, DWORD PTR _e_id$[ebp]
	push	edx
	lea	eax, DWORD PTR _gdata$[ebp]
	push	eax
	call	_graph_edge_transforms

; 2984 :             for ( i = 0 ; i < SDIM ; i++ )  /* gdata[1].x was messed by clip */

	mov	edx, DWORD PTR _web+616
	add	esp, 8
	test	edx, edx
	jle	SHORT $LN40@torus_cell

; 2982 :             }
; 2983 :             (*graph_edge_transforms)(gdata,e_id);

	mov	ecx, edx
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	lea	esi, DWORD PTR _xx$91391[ebp]
	lea	edi, DWORD PTR _gdata$[ebp]
	rep movsd
	mov	edi, DWORD PTR tv5024[ebp]
$LN40@torus_cell:

; 2956 :           for ( k = 1 ; k <= segments ; k++ )

	inc	ebx
	mov	DWORD PTR _k$91394[ebp], ebx
	cmp	ebx, DWORD PTR _segments$91393[ebp]
	jle	$LL41@torus_cell

; 2985 :                gdata[0].x[i] = xx[i];
; 2986 :           }
; 2987 :           goto next_edge;

	jmp	$next_edge$91380
$LN60@torus_cell:

; 2988 :         }
; 2989 :       }
; 2990 :       else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	$LN235@torus_cell

; 2991 :       { int k;
; 2992 :         vertex_id *v = get_edge_vertices(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	add	eax, DWORD PTR [edx+ebx+304]

; 2993 :         gdata[1] = gdata[0];
; 2994 :         if ( inverted(e_id) )

	test	DWORD PTR _e_id$[ebp], 134217728	; 08000000H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata$[ebp]
	lea	edi, DWORD PTR _gdata$[ebp+144]
	mov	DWORD PTR _v$91450[ebp], eax
	rep movsd
	je	$LN17@torus_cell

; 2995 :         { wrap = (*sym_compose)(wrap,get_fe_wrap(fe)); 

	mov	ecx, DWORD PTR _web+460
	mov	eax, DWORD PTR tv2295[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+20]
	xor	eax, DWORD PTR tv2302[ebp]
	mov	esi, DWORD PTR _web+124
	mov	edx, DWORD PTR [edx+ebx+784]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN157@torus_cell
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN158@torus_cell
$LN157@torus_cell:
	mov	eax, ecx
$LN158@torus_cell:
	push	eax
	mov	eax, DWORD PTR _wrap$[ebp]
	push	eax
	call	DWORD PTR _sym_compose

; 2996 :           for ( k = web.lagrange_order - 1; k > 0 ; k-- )

	mov	ebx, DWORD PTR _web+632
	dec	ebx
	add	esp, 8
	mov	DWORD PTR _wrap$[ebp], eax
	test	ebx, ebx
	jle	$LN227@torus_cell

; 2995 :         { wrap = (*sym_compose)(wrap,get_fe_wrap(fe)); 

	mov	eax, DWORD PTR _facet_gcount$[ebp]
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 4
	add	eax, DWORD PTR _facet_gdata$[ebp]
	mov	DWORD PTR tv5115[ebp], eax
	npad	2
$LL239@torus_cell:

; 2997 :           { x = get_coord(v[k]);
; 2998 :             (*sym_wrap)(x,gdata[1].x,wrap);

	mov	ecx, DWORD PTR _wrap$[ebp]
	mov	eax, DWORD PTR _v$91450[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+ebx*4]
	lea	edx, DWORD PTR _gdata$[ebp+144]
	push	edx
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+64]
	push	eax
	call	DWORD PTR _sym_wrap

; 2999 :              if ( k == web.lagrange_order/2 ) 

	mov	ecx, DWORD PTR _web+632
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esp, 12					; 0000000cH
	cmp	ebx, eax
	jne	SHORT $LN224@torus_cell

; 3000 :                  gdata[0].flags |= LABEL_EDGE;

	or	DWORD PTR _gdata$[ebp+136], 1024	; 00000400H
$LN224@torus_cell:

; 3001 :              if ( k == web.lagrange_order - 2 )

	add	ecx, -2					; fffffffeH
	cmp	ebx, ecx
	jne	SHORT $LN12@torus_cell

; 3002 :                  gdata[0].flags |= LABEL_HEAD;

	or	DWORD PTR _gdata$[ebp+136], 2048	; 00000800H
$LN12@torus_cell:

; 3003 :              if ( show_this_facet )

	cmp	DWORD PTR _show_this_facet$91327[ebp], 0
	je	SHORT $LN11@torus_cell

; 3004 :                facet_gdata[facet_gcount++] = gdata[1];

	mov	eax, DWORD PTR tv5115[ebp]
	inc	DWORD PTR _facet_gcount$[ebp]
	mov	edi, eax
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata$[ebp+144]
	add	eax, 144				; 00000090H
	rep movsd
	mov	DWORD PTR tv5115[ebp], eax
$LN11@torus_cell:

; 3005 :              (*graph_edge_transforms)(gdata,gdata[0].id);

	mov	eax, DWORD PTR _gdata$[ebp+128]
	push	eax
	lea	ecx, DWORD PTR _gdata$[ebp]
	push	ecx
	call	_graph_edge_transforms
	dec	ebx
	add	esp, 8

; 3006 :              gdata[0] = gdata[1];

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata$[ebp+144]
	lea	edi, DWORD PTR _gdata$[ebp]
	rep movsd
	test	ebx, ebx
	jg	$LL239@torus_cell

; 3007 :           }
; 3008 :         }
; 3009 :         else

	jmp	$LN227@torus_cell
$LN17@torus_cell:

; 3010 :         {
; 3011 :           for ( k = 1;  k < web.lagrange_order ; k++ )

	mov	eax, 1
	mov	DWORD PTR _k$91449[ebp], eax
	cmp	DWORD PTR _web+632, eax
	jle	$LN7@torus_cell
	mov	eax, DWORD PTR _facet_gcount$[ebp]
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 4
	add	eax, DWORD PTR _facet_gdata$[ebp]
	mov	DWORD PTR tv5166[ebp], eax
$LL9@torus_cell:

; 3012 :           { x = get_coord(v[k]);
; 3013 :             (*sym_wrap)(x,gdata[1].x,wrap);

	mov	edx, DWORD PTR _wrap$[ebp]
	mov	ecx, DWORD PTR _v$91450[ebp]
	mov	esi, DWORD PTR _k$91449[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+esi*4]
	lea	eax, DWORD PTR _gdata$[ebp+144]
	push	eax
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+104
	add	ecx, DWORD PTR [edx+ebx+64]
	push	ecx
	call	DWORD PTR _sym_wrap

; 3014 :             if ( k == web.lagrange_order/2 ) 

	mov	ecx, DWORD PTR _web+632
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esp, 12					; 0000000cH
	cmp	esi, eax
	jne	SHORT $LN226@torus_cell

; 3015 :                 gdata[0].flags |= LABEL_EDGE;

	or	DWORD PTR _gdata$[ebp+136], 1024	; 00000400H
$LN226@torus_cell:

; 3016 :             if ( k == web.lagrange_order - 2 )

	add	ecx, -2					; fffffffeH
	cmp	esi, ecx
	jne	SHORT $LN5@torus_cell

; 3017 :                 gdata[0].flags |= LABEL_HEAD;

	or	DWORD PTR _gdata$[ebp+136], 2048	; 00000800H
$LN5@torus_cell:

; 3018 :             if ( show_this_facet )

	cmp	DWORD PTR _show_this_facet$91327[ebp], 0
	je	SHORT $LN234@torus_cell

; 3019 :                facet_gdata[facet_gcount++] = gdata[1];

	mov	eax, DWORD PTR tv5166[ebp]
	inc	DWORD PTR _facet_gcount$[ebp]
	mov	edi, eax
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata$[ebp+144]
	add	eax, 144				; 00000090H
	rep movsd
	mov	DWORD PTR tv5166[ebp], eax
$LN234@torus_cell:

; 3020 :             (*graph_edge_transforms)(gdata,gdata[0].id);

	mov	eax, DWORD PTR _gdata$[ebp+128]
	push	eax
	lea	ecx, DWORD PTR _gdata$[ebp]
	push	ecx
	call	_graph_edge_transforms
	mov	eax, DWORD PTR _k$91449[ebp]
	mov	ebx, DWORD PTR _dymem
	inc	eax
	add	esp, 8

; 3021 :             gdata[0] = gdata[1];

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata$[ebp+144]
	lea	edi, DWORD PTR _gdata$[ebp]
	rep movsd
	mov	DWORD PTR _k$91449[ebp], eax
	cmp	eax, DWORD PTR _web+632
	jl	$LL9@torus_cell
$LN7@torus_cell:

; 3022 :           }
; 3023 :           wrap = (*sym_compose)(wrap,get_fe_wrap(fe)); 

	mov	edx, DWORD PTR tv2295[ebp]
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [ecx+20]
	xor	eax, DWORD PTR tv2302[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
$LN285@torus_cell:
	mov	ecx, DWORD PTR [ecx+ebx+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN163@torus_cell
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN164@torus_cell
$LN163@torus_cell:
	mov	eax, ecx
$LN164@torus_cell:
	mov	edx, DWORD PTR _wrap$[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose
	mov	DWORD PTR _wrap$[ebp], eax
	add	esp, 8
$LN227@torus_cell:

; 2893 :       {
; 2894 :         wrap = (*sym_compose)(wrap,get_fe_wrap(fe)); 

	mov	ebx, DWORD PTR _dymem
$LN235@torus_cell:

; 3024 :         }
; 3025 :       }
; 3026 :       /* now the head vertex for everybody */
; 3027 :       x = get_coord(get_fe_headv(fe));

	mov	eax, DWORD PTR tv2295[ebp]
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+20]
	xor	eax, DWORD PTR tv2302[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN168@torus_cell
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR [eax+ebx+304]
	mov	eax, DWORD PTR [edx+ecx]
	jmp	SHORT $LN167@torus_cell
$LN168@torus_cell:
	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR _web+216
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, DWORD PTR [ecx+ebx+304]
	mov	edx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edx*4]
$LN167@torus_cell:

; 3028 :       (*sym_wrap)(x,gdata[1].x,wrap); 

	mov	ecx, DWORD PTR _wrap$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _web+12
	lea	edx, DWORD PTR _gdata$[ebp+144]
	push	edx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+ebx+64]
	push	edx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 3029 :       if ( show_this_facet )

	cmp	DWORD PTR _show_this_facet$91327[ebp], 0
	je	SHORT $LN236@torus_cell

; 3030 :          facet_gdata[facet_gcount++] = gdata[1];

	mov	eax, DWORD PTR _facet_gcount$[ebp]
	lea	edi, DWORD PTR [eax+eax*8]
	shl	edi, 4
	add	edi, DWORD PTR _facet_gdata$[ebp]
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _gdata$[ebp+144]
	inc	eax
	rep movsd
	mov	DWORD PTR _facet_gcount$[ebp], eax
$LN236@torus_cell:

; 3031 :       gdata[0].flags |= LABEL_EDGE|LABEL_TAIL;
; 3032 :       (*graph_edge_transforms)(gdata,gdata[0].id);

	mov	ecx, DWORD PTR _gdata$[ebp+128]
	or	DWORD PTR _gdata$[ebp+136], 5120	; 00001400H
	push	ecx
	lea	edx, DWORD PTR _gdata$[ebp]
	push	edx
	call	_graph_edge_transforms
	add	esp, 8

; 3033 :       gdata[0] = gdata[1];

	lea	esi, DWORD PTR _gdata$[ebp+144]
$LN281@torus_cell:
	mov	edx, DWORD PTR _web+616
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _gdata$[ebp]
	rep movsd
$next_edge$91380:

; 3034 : next_edge:      
; 3035 :       fe = get_next_edge(fe);

	test	DWORD PTR _fe$[ebp], 134217728		; 08000000H
	je	SHORT $LN172@torus_cell
	mov	eax, DWORD PTR tv2295[ebp]
	mov	ecx, DWORD PTR _web+460
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN284@torus_cell
$LN172@torus_cell:
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR tv2295[ebp]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [ecx+32]
$LN284@torus_cell:

; 3036 :     }
; 3037 :     while ( !equal_id(fe,fe_id) );

	mov	ebx, DWORD PTR _dymem
	mov	DWORD PTR _fe$[ebp], eax
	cmp	eax, DWORD PTR _fe_id$[ebp]
	jne	$LL67@torus_cell
$LN65@torus_cell:

; 3038 : 
; 3039 :     if ( show_this_facet )

	cmp	DWORD PTR _show_this_facet$91327[ebp], 0
	je	SHORT $LN86@torus_cell

; 3040 :       graph_string_facet(f_id,facet_gdata,facet_gcount);

	mov	edx, DWORD PTR _facet_gcount$[ebp]
	mov	eax, DWORD PTR _facet_gdata$[ebp]
	mov	ecx, DWORD PTR _f_id$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_graph_string_facet
	mov	edx, DWORD PTR _web+616
	mov	ebx, DWORD PTR _dymem
	add	esp, 12					; 0000000cH
$LN86@torus_cell:

; 2825 :   }
; 2826 :  
; 2827 : /*
; 2828 :   if ( web.torus_display_period )
; 2829 :   { 
; 2830 :     invper = web.inverse_display_periods;
; 2831 :   }
; 2832 :   else
; 2833 : */
; 2834 :   { 
; 2835 :     invper = web.inverse_periods;
; 2836 :   }
; 2837 :   MFOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR tv2184[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	eax, DWORD PTR [eax+ecx]
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR _f_id$[ebp], edi
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	$LL231@torus_cell
$LN248@torus_cell:
	pop	ebx
$LN237@torus_cell:

; 3041 :   }
; 3042 :   
; 3043 :   if ( facet_gdata )

	mov	eax, DWORD PTR _facet_gdata$[ebp]
	pop	edi
	pop	esi
	test	eax, eax
	je	SHORT $LN1@torus_cell

; 3044 :     temp_free((char*)facet_gdata);

	push	eax
	call	_temp_free
	add	esp, 4
$LN1@torus_cell:

; 3045 : 
; 3046 : } /* end  torus_cells() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_torus_cells ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_raw_generate
EXTRN	_bounding_box_color:DWORD
EXTRN	_hi_dim_graph:PROC
; Function compile flags: /Ogtp
;	COMDAT _raw_generate
_TEXT	SEGMENT
tv757 = -324						; size = 4
tv605 = -320						; size = 4
tv278 = -320						; size = 4
_gdata$89494 = -316					; size = 288
_gdata$89449 = -316					; size = 288
_a$89493 = -28						; size = 24
_a$89448 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_raw_generate PROC					; COMDAT

; 99   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	edi

; 100  :   /* call appropriate facet and edge generators */
; 101  :   if ( web.symmetry_flag && (torus_display_mode==TORUS_CONNECTED_MODE) )

	xor	edi, edi
	cmp	DWORD PTR _web+856, edi
	je	SHORT $LN81@raw_genera
	cmp	DWORD PTR _torus_display_mode, 2
	jne	SHORT $LN81@raw_genera

; 102  :   { if ( web.representation == STRING ) 

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN80@raw_genera

; 103  :       torus_cells();

	call	_torus_cells
	jmp	SHORT $LN79@raw_genera
$LN80@raw_genera:

; 104  :     else torus_bodies();

	call	_torus_bodies

; 105  :     bare_edges();
; 106  :   }
; 107  :   else 

	jmp	SHORT $LN79@raw_genera
$LN81@raw_genera:

; 108  :   { if ( web.representation == SIMPLEX ) hi_dim_graph();

	mov	eax, DWORD PTR _web+624
	cmp	eax, 3
	jne	SHORT $LN77@raw_genera
	call	_hi_dim_graph
	jmp	SHORT $LN72@raw_genera
$LN77@raw_genera:

; 109  :     else if ( web.representation == STRING ) 

	cmp	eax, 1
	jne	SHORT $LN75@raw_genera

; 110  :     { if ( show_expr[FACET] && show_expr[FACET]->start )

	mov	eax, DWORD PTR _show_expr+8
	cmp	eax, edi
	je	SHORT $LN74@raw_genera
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN74@raw_genera

; 111  :         plain_string_facets(); 

	call	_plain_string_facets
$LN74@raw_genera:

; 112  :       plain_edges();  /* so edges get drawn on top */

	call	_plain_edges
	jmp	SHORT $LN72@raw_genera
$LN75@raw_genera:

; 113  :     }
; 114  :     else if ( web.representation == SOAPFILM ) 

	cmp	eax, 2
	jne	SHORT $LN72@raw_genera

; 115  :     { plain_facets();  bare_edges();

	call	_plain_facets
$LN79@raw_genera:
	call	_bare_edges
$LN72@raw_genera:

; 116  :     }
; 117  :   }
; 118  : 
; 119  :   /* bounding box (torus only) */
; 120  :   if ( box_flag && web.torus_flag )

	cmp	DWORD PTR _box_flag, edi
	je	$LN14@raw_genera
	push	ebx
	push	esi
	cmp	DWORD PTR _web+860, edi
	je	$LN71@raw_genera

; 121  :   { int k,m,n,a[MAXCOORD];
; 122  :     struct graphdata gdata[2];
; 123  :     REAL **per = web.torus_display_period ? web.torus_display_period : web.torus_period;

	mov	esi, DWORD PTR _web+1620
	cmp	esi, edi
	jne	SHORT $LN85@raw_genera
	mov	esi, DWORD PTR _web+1608
$LN85@raw_genera:

; 124  :    
; 125  :     memset(gdata,0,2*sizeof(struct graphdata));

	push	288					; 00000120H
	lea	eax, DWORD PTR _gdata$89449[ebp]
	push	edi
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 126  :     gdata[0].color = gdata[0].ecolor = 
; 127  :       (edge_rgb_color_attr > 0 ) ? INDEX_TO_RGBA(bounding_box_color) :
; 128  :            bounding_box_color;

	cmp	DWORD PTR _edge_rgb_color_attr, edi
	jle	SHORT $LN86@raw_genera
	mov	ecx, DWORD PTR _bounding_box_color
	push	ecx
	call	_INDEX_TO_RGBA
	add	esp, 4
	jmp	SHORT $LN143@raw_genera
$LN86@raw_genera:
	mov	eax, DWORD PTR _bounding_box_color
$LN143@raw_genera:

; 129  :     gdata[0].etype = BARE_EDGE;

	mov	edx, 64					; 00000040H
	mov	WORD PTR _gdata$89449[ebp+124], dx

; 130  :     
; 131  :     if ( SDIM == 2 )

	mov	edx, DWORD PTR _web+616

; 132  :      for ( a[0] = 0 ; a[0] <= 1 ; a[0]++ )

	lea	ebx, DWORD PTR _a$89448[ebp]
	sub	ebx, esi
	mov	DWORD PTR _gdata$89449[ebp+120], eax
	mov	DWORD PTR _gdata$89449[ebp+104], eax
	mov	DWORD PTR _a$89448[ebp], edi

; 134  :        for ( k = 0 ; k < 2 ; k++ )

	mov	DWORD PTR tv757[ebp], ebx
	cmp	edx, 2
	jne	$LL137@raw_genera
	npad	2
$LL136@raw_genera:

; 133  :       for ( a[1] = 0 ; a[1] <= 1 ; a[1]++ )

	mov	DWORD PTR _a$89448[ebp+4], 0
	npad	9
$LL66@raw_genera:

; 134  :        for ( k = 0 ; k < 2 ; k++ )

	mov	edi, esi
	mov	DWORD PTR tv278[ebp], 2
	npad	4
$LL63@raw_genera:

; 135  :        { if ( a[k] == 0 )

	cmp	DWORD PTR [ebx+edi], 0
	jne	SHORT $LN62@raw_genera

; 136  :          { for ( m = 0 ; m < SDIM ; m++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN57@raw_genera
	npad	4
$LL135@raw_genera:

; 137  :            { for ( n = 0, gdata[0].x[m] = web.display_origin[m] ; n < SDIM ; n++ )

	fld	QWORD PTR _web[ecx*8+1624]
	xor	eax, eax
	fstp	QWORD PTR _gdata$89449[ebp+ecx*8]
$LL56@raw_genera:

; 138  :                gdata[0].x[m] += a[n]*per[n][m];

	fild	DWORD PTR _a$89448[ebp+eax*4]
	mov	ebx, DWORD PTR [esi+eax*4]
	inc	eax
	fmul	QWORD PTR [ebx+ecx*8]
	fadd	QWORD PTR _gdata$89449[ebp+ecx*8]
	fstp	QWORD PTR _gdata$89449[ebp+ecx*8]
	cmp	eax, edx
	jl	SHORT $LL56@raw_genera

; 139  :              gdata[1].x[m] = gdata[0].x[m] + per[k][m];

	mov	eax, DWORD PTR [edi]
	fld	QWORD PTR [eax+ecx*8]
	inc	ecx
	fadd	QWORD PTR _gdata$89449[ebp+ecx*8-8]
	fstp	QWORD PTR _gdata$89449[ebp+ecx*8+136]
	cmp	ecx, edx
	jl	SHORT $LL135@raw_genera

; 136  :          { for ( m = 0 ; m < SDIM ; m++ )

	mov	ebx, DWORD PTR tv757[ebp]
$LN57@raw_genera:

; 140  :            }
; 141  :            (*graph_edge_transforms)(gdata,NULLID); 

	lea	ecx, DWORD PTR _gdata$89449[ebp]
	push	0
	push	ecx
	call	_graph_edge_transforms
	mov	edx, DWORD PTR _web+616
	add	esp, 8
$LN62@raw_genera:

; 134  :        for ( k = 0 ; k < 2 ; k++ )

	add	edi, 4
	dec	DWORD PTR tv278[ebp]
	jne	SHORT $LL63@raw_genera

; 133  :       for ( a[1] = 0 ; a[1] <= 1 ; a[1]++ )

	mov	eax, DWORD PTR _a$89448[ebp+4]
	inc	eax
	mov	DWORD PTR _a$89448[ebp+4], eax
	cmp	eax, 1
	jle	$LL66@raw_genera

; 132  :      for ( a[0] = 0 ; a[0] <= 1 ; a[0]++ )

	mov	eax, DWORD PTR _a$89448[ebp]
	inc	eax
	mov	DWORD PTR _a$89448[ebp], eax
	cmp	eax, 1
	jle	$LL136@raw_genera
	pop	esi
	pop	ebx
	pop	edi

; 193  :         }
; 194  :   }
; 195  : } // end raw_generate()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LL137@raw_genera:

; 147  :      for ( a[1] = 0 ; a[1] <= 1 ; a[1]++ )

	mov	DWORD PTR _a$89448[ebp+4], 0
$LL49@raw_genera:

; 148  :       for ( a[2] = 0 ; a[2] <= 1 ; a[2]++ )

	mov	DWORD PTR _a$89448[ebp+8], 0
	npad	2
$LL46@raw_genera:

; 149  :        for ( k = 0 ; k < 3 ; k++ )

	mov	edi, esi
	mov	DWORD PTR tv605[ebp], 3
	npad	4
$LL43@raw_genera:

; 150  :         if ( a[k] == 0 )

	cmp	DWORD PTR [edi+ebx], 0
	jne	SHORT $LN42@raw_genera

; 151  :         { for ( m = 0 ; m < SDIM ; m++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN37@raw_genera
	npad	4
$LL134@raw_genera:

; 152  :           { for ( n = 0, gdata[0].x[m] = web.display_origin[m] ; n < SDIM ; n++ )

	fld	QWORD PTR _web[ecx*8+1624]
	xor	eax, eax
	fstp	QWORD PTR _gdata$89449[ebp+ecx*8]
$LL36@raw_genera:

; 153  :               gdata[0].x[m] += a[n]*per[n][m];

	fild	DWORD PTR _a$89448[ebp+eax*4]
	mov	ebx, DWORD PTR [esi+eax*4]
	inc	eax
	fmul	QWORD PTR [ebx+ecx*8]
	fadd	QWORD PTR _gdata$89449[ebp+ecx*8]
	fstp	QWORD PTR _gdata$89449[ebp+ecx*8]
	cmp	eax, edx
	jl	SHORT $LL36@raw_genera

; 154  :             gdata[1].x[m] = gdata[0].x[m] + per[k][m];

	mov	eax, DWORD PTR [edi]
	fld	QWORD PTR [eax+ecx*8]
	inc	ecx
	fadd	QWORD PTR _gdata$89449[ebp+ecx*8-8]
	fstp	QWORD PTR _gdata$89449[ebp+ecx*8+136]
	cmp	ecx, edx
	jl	SHORT $LL134@raw_genera

; 151  :         { for ( m = 0 ; m < SDIM ; m++ )

	mov	ebx, DWORD PTR tv757[ebp]
$LN37@raw_genera:

; 155  :           }
; 156  :           (*graph_edge_transforms)(gdata,NULLID); 

	lea	ecx, DWORD PTR _gdata$89449[ebp]
	push	0
	push	ecx
	call	_graph_edge_transforms
	mov	edx, DWORD PTR _web+616
	add	esp, 8
$LN42@raw_genera:

; 149  :        for ( k = 0 ; k < 3 ; k++ )

	add	edi, 4
	dec	DWORD PTR tv605[ebp]
	jne	SHORT $LL43@raw_genera

; 148  :       for ( a[2] = 0 ; a[2] <= 1 ; a[2]++ )

	mov	eax, DWORD PTR _a$89448[ebp+8]
	inc	eax
	mov	DWORD PTR _a$89448[ebp+8], eax
	cmp	eax, 1
	jle	$LL46@raw_genera

; 147  :      for ( a[1] = 0 ; a[1] <= 1 ; a[1]++ )

	mov	eax, DWORD PTR _a$89448[ebp+4]
	inc	eax
	mov	DWORD PTR _a$89448[ebp+4], eax
	cmp	eax, 1
	jle	$LL49@raw_genera

; 142  :            /* (*graph_edge)(gdata,NULLID); */
; 143  :          }
; 144  :        }
; 145  :     else
; 146  :     for ( a[0] = 0 ; a[0] <= 1 ; a[0]++ )

	mov	eax, DWORD PTR _a$89448[ebp]
	inc	eax
	mov	DWORD PTR _a$89448[ebp], eax
	cmp	eax, 1
	jle	$LL137@raw_genera
	pop	esi
	pop	ebx
	pop	edi

; 193  :         }
; 194  :   }
; 195  : } // end raw_generate()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@raw_genera:

; 157  :           /*(*graph_edge)(gdata,NULLID);*/
; 158  :         }
; 159  :   }
; 160  :   else if ( box_flag && !lazy_transforms_flag )

	cmp	DWORD PTR _lazy_transforms_flag, edi
	jne	$LN141@raw_genera

; 161  :   { int k,m,a[MAXCOORD];
; 162  :     struct graphdata gdata[2];
; 163  : 
; 164  :     memset(gdata,0,2*sizeof(struct graphdata));

	push	288					; 00000120H
	lea	edx, DWORD PTR _gdata$89494[ebp]
	push	edi
	push	edx
	call	_memset

; 165  :     gdata[0].color = gdata[0].ecolor = 
; 166  :        (edge_rgb_color_attr > 0 ) ? INDEX_TO_RGBA(bounding_box_color) : 
; 167  :            bounding_box_color;

	mov	eax, DWORD PTR _bounding_box_color
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _edge_rgb_color_attr, edi
	jle	SHORT $LN88@raw_genera
	push	eax
	call	_INDEX_TO_RGBA
	add	esp, 4
$LN88@raw_genera:

; 168  :     gdata[0].etype = BARE_EDGE;
; 169  : 
; 170  :     if ( SDIM == 2 )

	mov	edx, DWORD PTR _web+616
	mov	ecx, 64					; 00000040H
	mov	DWORD PTR _gdata$89494[ebp+120], eax
	mov	DWORD PTR _gdata$89494[ebp+104], eax
	mov	WORD PTR _gdata$89494[ebp+124], cx

; 171  :     { for ( a[0] = 0 ; a[0] <= 1 ; a[0]++ )

	mov	DWORD PTR _a$89493[ebp], edi
	cmp	edx, 2
	jne	$LL139@raw_genera
	npad	1
$LL138@raw_genera:

; 172  :       for ( a[1] = 0 ; a[1] <= 1 ; a[1]++ )

	xor	edi, edi
	mov	DWORD PTR _a$89493[ebp+4], edi
$LL27@raw_genera:

; 173  :        for ( k = 0 ; k < 2 ; k++ )

	xor	esi, esi
$LL24@raw_genera:

; 174  :          if ( a[k] == 0 )

	cmp	DWORD PTR _a$89493[ebp+esi*4], 0
	jne	SHORT $LN23@raw_genera

; 175  :          { for ( m = 0 ; m < SDIM ; m++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN18@raw_genera
	npad	12
$LL20@raw_genera:

; 176  :            { gdata[0].x[m] = bounding_box[m][a[m]];

	mov	ecx, DWORD PTR _a$89493[ebp+eax*4]
	lea	ebx, DWORD PTR [ecx+eax*2]
	fld	QWORD PTR _bounding_box[ebx*8]
	fstp	QWORD PTR _gdata$89494[ebp+eax*8]

; 177  :              gdata[1].x[m] = bounding_box[m][m==k?1:a[m]];

	cmp	eax, esi
	jne	SHORT $LN90@raw_genera
	mov	ecx, 1
$LN90@raw_genera:
	lea	ecx, DWORD PTR [ecx+eax*2]
	fld	QWORD PTR _bounding_box[ecx*8]
	inc	eax
	fstp	QWORD PTR _gdata$89494[ebp+eax*8+136]
	cmp	eax, edx
	jl	SHORT $LL20@raw_genera
$LN18@raw_genera:

; 178  :            }
; 179  :            graph_edge_clip(gdata,NULLID);

	lea	edx, DWORD PTR _gdata$89494[ebp]
	push	0
	push	edx
	call	_graph_edge_clip
	mov	edx, DWORD PTR _web+616
	add	esp, 8
$LN23@raw_genera:

; 173  :        for ( k = 0 ; k < 2 ; k++ )

	inc	esi
	cmp	esi, 2
	jl	SHORT $LL24@raw_genera

; 172  :       for ( a[1] = 0 ; a[1] <= 1 ; a[1]++ )

	inc	edi
	mov	DWORD PTR _a$89493[ebp+4], edi
	cmp	edi, 1
	jle	SHORT $LL27@raw_genera

; 171  :     { for ( a[0] = 0 ; a[0] <= 1 ; a[0]++ )

	mov	eax, DWORD PTR _a$89493[ebp]
	inc	eax
	mov	DWORD PTR _a$89493[ebp], eax
	cmp	eax, 1
	jle	$LL138@raw_genera
	pop	esi
	pop	ebx
	pop	edi

; 193  :         }
; 194  :   }
; 195  : } // end raw_generate()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	5
$LL139@raw_genera:

; 184  :      for ( a[1] = 0 ; a[1] <= 1 ; a[1]++ )

	mov	DWORD PTR _a$89493[ebp+4], 0
$LL140@raw_genera:

; 185  :       for ( a[2] = 0 ; a[2] <= 1 ; a[2]++ )

	xor	edi, edi
	mov	DWORD PTR _a$89493[ebp+8], edi
	npad	4
$LL10@raw_genera:

; 186  :        for ( k = 0 ; k < 3 ; k++ )

	xor	esi, esi
$LL7@raw_genera:

; 187  :         if ( a[k] == 0 )

	cmp	DWORD PTR _a$89493[ebp+esi*4], 0
	jne	SHORT $LN6@raw_genera

; 188  :         { for ( m = 0 ; m < SDIM ; m++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN1@raw_genera
	npad	1
$LL3@raw_genera:

; 189  :           { gdata[0].x[m] = bounding_box[m][a[m]];

	mov	ecx, DWORD PTR _a$89493[ebp+eax*4]
	lea	ebx, DWORD PTR [ecx+eax*2]
	fld	QWORD PTR _bounding_box[ebx*8]
	fstp	QWORD PTR _gdata$89494[ebp+eax*8]

; 190  :             gdata[1].x[m] = bounding_box[m][m==k?1:a[m]];

	cmp	eax, esi
	jne	SHORT $LN92@raw_genera
	mov	ecx, 1
$LN92@raw_genera:
	lea	ecx, DWORD PTR [ecx+eax*2]
	fld	QWORD PTR _bounding_box[ecx*8]
	inc	eax
	fstp	QWORD PTR _gdata$89494[ebp+eax*8+136]
	cmp	eax, edx
	jl	SHORT $LL3@raw_genera
$LN1@raw_genera:

; 191  :           }
; 192  :           graph_edge_clip(gdata,NULLID);       

	lea	edx, DWORD PTR _gdata$89494[ebp]
	push	0
	push	edx
	call	_graph_edge_clip
	mov	edx, DWORD PTR _web+616
	add	esp, 8
$LN6@raw_genera:

; 186  :        for ( k = 0 ; k < 3 ; k++ )

	inc	esi
	cmp	esi, 3
	jl	SHORT $LL7@raw_genera

; 185  :       for ( a[2] = 0 ; a[2] <= 1 ; a[2]++ )

	inc	edi
	mov	DWORD PTR _a$89493[ebp+8], edi
	cmp	edi, 1
	jle	SHORT $LL10@raw_genera

; 184  :      for ( a[1] = 0 ; a[1] <= 1 ; a[1]++ )

	mov	eax, DWORD PTR _a$89493[ebp+4]
	inc	eax
	mov	DWORD PTR _a$89493[ebp+4], eax
	cmp	eax, 1
	jle	SHORT $LL140@raw_genera

; 180  :          }
; 181  :     }
; 182  :     else
; 183  :     for ( a[0] = 0 ; a[0] <= 1 ; a[0]++ )

	mov	eax, DWORD PTR _a$89493[ebp]
	inc	eax
	mov	DWORD PTR _a$89493[ebp], eax
	cmp	eax, 1
	jle	$LL139@raw_genera
$LN141@raw_genera:
	pop	esi
	pop	ebx
$LN14@raw_genera:

; 193  :         }
; 194  :   }
; 195  : } // end raw_generate()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_raw_generate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EF@DBFKJEGH@There?5are?5no?5bodies?5to?5display?5c@ ; `string'
PUBLIC	??_C@_0DC@IBNAIEJL@Colormap?5file?5has?5only?5?$CFd?5entrie@ ; `string'
PUBLIC	??_C@_0BA@DNLGAHKG@?$CFlf?5?$CFlf?5?$CFlf?5?$CFlf?$AA@ ; `string'
PUBLIC	??_C@_0BD@DAIMKNPL@No?5colormap?5used?4?6?$AA@	; `string'
PUBLIC	??_C@_0BO@ONMFPAEA@Enter?5name?5of?5colormap?5file?3?5?$AA@ ; `string'
PUBLIC	__real@c6293e5939a08cea
PUBLIC	__real@46293e5939a08cea
PUBLIC	??_C@_05KIAHCKKB@fbrgb?$AA@			; `string'
PUBLIC	??_C@_04PEMKDGJI@frgb?$AA@			; `string'
PUBLIC	??_C@_04LDGKEMEI@ergb?$AA@			; `string'
PUBLIC	??_C@_0CL@NJIABJBK@slice_view?5on?0?5but?5slice_coeff?$FL?$FN@ ; `string'
PUBLIC	_graphgen
EXTRN	_graph_end:DWORD
EXTRN	_fscanf:PROC
EXTRN	_colormap:DWORD
EXTRN	_perror:PROC
EXTRN	_l_evolver_mode:DWORD
EXTRN	_l_redirect:DWORD
EXTRN	_path_open:PROC
EXTRN	_outstring:PROC
EXTRN	_prompt:PROC
EXTRN	_cmapname:BYTE
EXTRN	_iterate_flag:DWORD
EXTRN	_graph_start:DWORD
EXTRN	_expand_attribute:PROC
EXTRN	_find_extra:PROC
EXTRN	_rgb_colors_flag:DWORD
;	COMDAT ??_C@_0EF@DBFKJEGH@There?5are?5no?5bodies?5to?5display?5c@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EF@DBFKJEGH@There?5are?5no?5bodies?5to?5display?5c@ DB 'There are '
	DB	'no bodies to display connectedly.  Reverting to raw mode.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@IBNAIEJL@Colormap?5file?5has?5only?5?$CFd?5entrie@
CONST	SEGMENT
??_C@_0DC@IBNAIEJL@Colormap?5file?5has?5only?5?$CFd?5entrie@ DB 'Colormap'
	DB	' file has only %d entries for %d bodies.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DNLGAHKG@?$CFlf?5?$CFlf?5?$CFlf?5?$CFlf?$AA@
CONST	SEGMENT
??_C@_0BA@DNLGAHKG@?$CFlf?5?$CFlf?5?$CFlf?5?$CFlf?$AA@ DB '%lf %lf %lf %l'
	DB	'f', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DAIMKNPL@No?5colormap?5used?4?6?$AA@
CONST	SEGMENT
??_C@_0BD@DAIMKNPL@No?5colormap?5used?4?6?$AA@ DB 'No colormap used.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ONMFPAEA@Enter?5name?5of?5colormap?5file?3?5?$AA@
CONST	SEGMENT
??_C@_0BO@ONMFPAEA@Enter?5name?5of?5colormap?5file?3?5?$AA@ DB 'Enter nam'
	DB	'e of colormap file: ', 00H			; `string'
CONST	ENDS
;	COMDAT __real@c6293e5939a08cea
CONST	SEGMENT
__real@c6293e5939a08cea DQ 0c6293e5939a08cear	; -1e+030
CONST	ENDS
;	COMDAT __real@46293e5939a08cea
CONST	SEGMENT
__real@46293e5939a08cea DQ 046293e5939a08cear	; 1e+030
CONST	ENDS
;	COMDAT ??_C@_05KIAHCKKB@fbrgb?$AA@
CONST	SEGMENT
??_C@_05KIAHCKKB@fbrgb?$AA@ DB 'fbrgb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PEMKDGJI@frgb?$AA@
CONST	SEGMENT
??_C@_04PEMKDGJI@frgb?$AA@ DB 'frgb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LDGKEMEI@ergb?$AA@
CONST	SEGMENT
??_C@_04LDGKEMEI@ergb?$AA@ DB 'ergb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NJIABJBK@slice_view?5on?0?5but?5slice_coeff?$FL?$FN@
CONST	SEGMENT
??_C@_0CL@NJIABJBK@slice_view?5on?0?5but?5slice_coeff?$FL?$FN@ DB 'slice_'
	DB	'view on, but slice_coeff[] not set.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\graphgen.c
CONST	ENDS
;	COMDAT _graphgen
_TEXT	SEGMENT
_dummy$ = -8						; size = 4
tv450 = -4						; size = 4
_three$89545 = -4					; size = 4
_graphgen PROC						; COMDAT

; 209  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 210  :   int  graphcount = 0;  /* number of facets done */
; 211  :   int b,i;
; 212  :   REAL *c;
; 213  :   FILE *mapfd = NULL;
; 214  :   int dummy;
; 215  :   struct extra *ex;
; 216  : 
; 217  :   if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE) )

	cmp	DWORD PTR _web+860, 0
	push	ebx
	push	esi
	push	edi
	mov	ebx, 3
	je	SHORT $LN47@graphgen
	cmp	DWORD PTR _torus_display_mode, ebx
	jne	SHORT $LN47@graphgen

; 218  :     lazy_transforms_flag = 0 ;

	mov	DWORD PTR _lazy_transforms_flag, 0
$LN47@graphgen:

; 219  : 
; 220  :   if ( slice_view_flag )

	cmp	DWORD PTR _slice_view_flag, 0
	je	SHORT $LN69@graphgen

; 221  :   { /* check coefficients set */
; 222  :     for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN58@graphgen
	fldz
$LN45@graphgen:

; 223  :       if ( slice_coeff[i] )

	fld	QWORD PTR _slice_coeff[ecx*8]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN80@graphgen

; 221  :   { /* check coefficients set */
; 222  :     for ( i = 0 ; i < SDIM ; i++ )

	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LN45@graphgen
$LN80@graphgen:
	fstp	ST(0)
$LN58@graphgen:

; 224  :         break;
; 225  :     if ( i == SDIM )

	cmp	ecx, edx
	jne	SHORT $LN69@graphgen

; 226  :       kb_error(1900,"slice_view on, but slice_coeff[] not set.\n",
; 227  :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CL@NJIABJBK@slice_view?5on?0?5but?5slice_coeff?$FL?$FN@
	push	1900					; 0000076cH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN69@graphgen:

; 228  :   }
; 229  : 
; 230  :   if ( rgb_colors_flag )

	cmp	DWORD PTR _rgb_colors_flag, 0
	je	$LN40@graphgen

; 231  :   { int three = 3;
; 232  :     /* see if using RGBA colors for elements */
; 233  :     edge_rgb_color_attr = find_extra("ergb",&dummy);

	lea	eax, DWORD PTR _dummy$[ebp]
	push	eax
	push	OFFSET ??_C@_04LDGKEMEI@ergb?$AA@
	mov	DWORD PTR _three$89545[ebp], ebx
	call	_find_extra
	add	esp, 8
	mov	DWORD PTR _edge_rgb_color_attr, eax

; 234  :     if ( edge_rgb_color_attr > 0 )

	test	eax, eax
	jle	SHORT $LN70@graphgen

; 235  :     { ex = EXTRAS(EDGE)+edge_rgb_color_attr;

	mov	esi, eax
	imul	esi, 240				; 000000f0H
	add	esi, DWORD PTR _web+216
	add	esi, DWORD PTR _dymem

; 236  :       if ( ex->array_spec.datacount < 3 ) 

	cmp	DWORD PTR [esi+88], ebx
	jge	SHORT $LN38@graphgen

; 237  :         expand_attribute(EDGE,edge_rgb_color_attr,&three);

	lea	ecx, DWORD PTR _three$89545[ebp]
	push	ecx
	push	eax
	push	1
	call	_expand_attribute
	add	esp, 12					; 0000000cH
$LN38@graphgen:

; 238  :       edge_alpha_flag = (ex->array_spec.datacount >= 4);

	xor	edx, edx
	mov	edi, 4
	cmp	DWORD PTR [esi+88], edi
	setge	dl
	mov	DWORD PTR _edge_alpha_flag, edx
	jmp	SHORT $LN39@graphgen
$LN70@graphgen:
	mov	edi, 4
$LN39@graphgen:

; 239  :     }
; 240  :     facet_rgb_color_attr = find_extra("frgb",&dummy);

	lea	eax, DWORD PTR _dummy$[ebp]
	push	eax
	push	OFFSET ??_C@_04PEMKDGJI@frgb?$AA@
	call	_find_extra
	add	esp, 8
	mov	DWORD PTR _facet_rgb_color_attr, eax

; 241  :     if ( facet_rgb_color_attr > 0 )

	test	eax, eax
	jle	SHORT $LN72@graphgen

; 242  :     { ex = EXTRAS(FACET)+facet_rgb_color_attr;

	mov	esi, eax
	imul	esi, 240				; 000000f0H
	add	esi, DWORD PTR _web+328
	add	esi, DWORD PTR _dymem

; 243  :       if ( ex->array_spec.datacount < 3 )

	cmp	DWORD PTR [esi+88], ebx
	jge	SHORT $LN71@graphgen

; 244  :         expand_attribute(FACET,facet_rgb_color_attr,&three);

	lea	ecx, DWORD PTR _three$89545[ebp]
	push	ecx
	push	eax
	push	2
	call	_expand_attribute
	add	esp, 12					; 0000000cH
$LN71@graphgen:

; 245  :       facet_alpha_flag = (ex->array_spec.datacount >= 4);

	xor	edx, edx
	cmp	DWORD PTR [esi+88], edi
	setge	dl
	mov	DWORD PTR _facet_alpha_flag, edx
$LN72@graphgen:

; 246  :     }
; 247  :     facet_rgb_backcolor_attr = find_extra("fbrgb",&dummy);

	lea	eax, DWORD PTR _dummy$[ebp]
	push	eax
	push	OFFSET ??_C@_05KIAHCKKB@fbrgb?$AA@
	call	_find_extra
	add	esp, 8
	mov	DWORD PTR _facet_rgb_backcolor_attr, eax

; 248  :     if ( facet_rgb_backcolor_attr > 0 )

	test	eax, eax
	jle	SHORT $LN74@graphgen

; 249  :     { ex = EXTRAS(FACET)+facet_rgb_backcolor_attr;

	mov	esi, eax
	imul	esi, 240				; 000000f0H
	add	esi, DWORD PTR _web+328
	add	esi, DWORD PTR _dymem

; 250  :       if ( ex->array_spec.datacount < 3 ) 

	cmp	DWORD PTR [esi+88], ebx
	jge	SHORT $LN73@graphgen

; 251  :         expand_attribute(FACET,facet_rgb_backcolor_attr,&three);

	lea	ecx, DWORD PTR _three$89545[ebp]
	push	ecx
	push	eax
	push	2
	call	_expand_attribute
	add	esp, 12					; 0000000cH
$LN73@graphgen:

; 252  :       facetback_alpha_flag = (ex->array_spec.datacount >= 4);

	xor	edx, edx
	cmp	DWORD PTR [esi+88], edi
	setge	dl
	mov	DWORD PTR _facetback_alpha_flag, edx

; 253  :     }
; 254  :   } else /* turn off rgb */

	jmp	SHORT $LN74@graphgen
$LN40@graphgen:

; 255  :   { edge_rgb_color_attr = -1;

	or	eax, -1
	mov	DWORD PTR _edge_rgb_color_attr, eax

; 256  :     facet_rgb_color_attr = -1;

	mov	DWORD PTR _facet_rgb_color_attr, eax

; 257  :     facet_rgb_backcolor_attr = -1;

	mov	DWORD PTR _facet_rgb_backcolor_attr, eax
$LN74@graphgen:

; 258  :   }
; 259  :   (*graph_start)();  /* device-specific initialization */

	call	DWORD PTR _graph_start

; 260  : 
; 261  :   if ( markedgedrawflag )

	cmp	DWORD PTR _markedgedrawflag, 0
	je	SHORT $LN29@graphgen

; 262  :   { edge_id e_id;
; 263  :     FOR_ALL_EDGES(e_id) unset_attr(e_id,EDGE_DRAWN);

	mov	edx, DWORD PTR _web+160
	test	edx, 268435456				; 10000000H
	je	SHORT $LN29@graphgen
	mov	edi, DWORD PTR _web+124
	mov	ebx, -67108865				; fbffffffH
	npad	7
$LL31@graphgen:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	esi, esi
	or	ecx, esi
	je	SHORT $LN30@graphgen
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx+12]
	and	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], edx
	mov	edi, DWORD PTR _web+124
$LN30@graphgen:
	mov	eax, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL31@graphgen
$LN29@graphgen:

; 264  :   }
; 265  : 
; 266  :   iterate_flag = 2;
; 267  :   if ( box_flag )

	cmp	DWORD PTR _box_flag, 0
	mov	DWORD PTR _iterate_flag, 2
	je	SHORT $LN23@graphgen

; 268  :     for ( i = 0 ; i < SDIM ; i++ ) 

	mov	ecx, DWORD PTR _web+616
	test	ecx, ecx
	jle	SHORT $LN23@graphgen
	fld	QWORD PTR __real@46293e5939a08cea
	mov	eax, OFFSET _bounding_box+8
	fld	QWORD PTR __real@c6293e5939a08cea
$LN25@graphgen:

; 269  :     {  bounding_box[i][0] = 1e30;

	fxch	ST(1)
	add	eax, 16					; 00000010H
	dec	ecx
	fst	QWORD PTR [eax-24]

; 270  :        bounding_box[i][1] = -1e30;

	fxch	ST(1)
	fst	QWORD PTR [eax-16]
	jne	SHORT $LN25@graphgen

; 268  :     for ( i = 0 ; i < SDIM ; i++ ) 

	fstp	ST(1)
	fstp	ST(0)
$LN23@graphgen:

; 271  :     }
; 272  : 
; 273  :   if ( colorflag )

	cmp	DWORD PTR _colorflag, 0
	je	$LN19@graphgen
$LL21@graphgen:

; 274  :   do 
; 275  :   {
; 276  :     if ( strlen(cmapname) == 0 )

	mov	eax, OFFSET _cmapname
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL66@graphgen:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL66@graphgen
	sub	eax, edx
	jne	SHORT $LN18@graphgen

; 277  :       prompt("Enter name of colormap file: ",cmapname,sizeof(cmapname));

	push	1000					; 000003e8H
	push	OFFSET _cmapname
	push	OFFSET ??_C@_0BO@ONMFPAEA@Enter?5name?5of?5colormap?5file?3?5?$AA@
	call	_prompt
	add	esp, 12					; 0000000cH
$LN18@graphgen:

; 278  :     if ( cmapname[0] == 0 )

	cmp	BYTE PTR _cmapname, 0
	jne	SHORT $LN75@graphgen

; 279  :     { outstring("No colormap used.\n"); colorflag = 0; }

	push	OFFSET ??_C@_0BD@DAIMKNPL@No?5colormap?5used?4?6?$AA@
	call	_outstring
	add	esp, 4
	mov	DWORD PTR _colorflag, 0
$LN75@graphgen:

; 280  :     mapfd = path_open(cmapname,NOTDATAFILENAME);

	push	0
	push	OFFSET _cmapname
	call	_path_open
	mov	ebx, eax
	add	esp, 8

; 281  :     if ( mapfd )

	test	ebx, ebx
	jne	SHORT $LN65@graphgen

; 312  :         } 
; 313  :       }
; 314  :     }
; 315  :     else 
; 316  : #ifdef __L_EVOLVER__
; 317  : 		   if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, eax
	jne	SHORT $LN5@graphgen
	cmp	DWORD PTR _l_evolver_mode, eax
	jne	SHORT $LN5@graphgen

; 319  : 		   else
; 320  : 			   perror(cmapname);

	push	OFFSET _cmapname
	call	_perror
	add	esp, 4
	jmp	$LL21@graphgen
$LN5@graphgen:

; 318  : 			   erroutstring(cmapname);

	push	OFFSET _cmapname
	call	_erroutstring
	add	esp, 4

; 321  : #else
; 322  : 		perror(cmapname);
; 323  : #endif
; 324  :   }  while ( mapfd == NULL );

	jmp	$LL21@graphgen
$LN65@graphgen:

; 282  :     {
; 283  :       colormap = (maprow *)temp_calloc(4*web.bodycount,sizeof(REAL));

	mov	ecx, DWORD PTR _web+1500
	push	283					; 0000011bH
	push	OFFSET ??_C@_0L@CNMDHOFJ@GRAPHGEN?4C?$AA@
	lea	edx, DWORD PTR [ecx*4]
	push	8
	push	edx
	call	_kb_temp_calloc

; 284  :       for ( b = 0 ; b < web.bodycount ; b++ )

	xor	esi, esi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _colormap, eax
	cmp	DWORD PTR _web+1500, esi
	jle	$LN19@graphgen

; 282  :     {
; 283  :       colormap = (maprow *)temp_calloc(4*web.bodycount,sizeof(REAL));

	xor	edi, edi
$LL68@graphgen:

; 284  :       for ( b = 0 ; b < web.bodycount ; b++ )

	mov	eax, DWORD PTR _colormap
	add	eax, edi

; 285  :       { c = colormap[b];
; 286  : #ifdef FLOAT128
; 287  :         fgets(msg,msgmax,mapfd);
; 288  :         { char *spot = msg;
; 289  :           int i;
; 290  :           for ( i = 0 ; i < 4 ; i++ )
; 291  :           { c[i] =  strtoflt128(spot,&spot);
; 292  :             if ( spot==NULL ) break;
; 293  :           }
; 294  :           if ( i < 4 ) break;
; 295  :         }
; 296  : #elif defined(LONGDOUBLE)
; 297  :         if ( fscanf(mapfd,"%Lf %Lf %Lf %Lf",
; 298  :             c,c+1,c+2,c+3) != 4 ) break;
; 299  : #else
; 300  :         if ( fscanf(mapfd,"%lf %lf %lf %lf",
; 301  :             c,c+1,c+2,c+3) != 4 ) break;

	lea	ecx, DWORD PTR [eax+24]
	push	ecx
	lea	edx, DWORD PTR [eax+16]
	push	edx
	lea	ecx, DWORD PTR [eax+8]
	push	ecx
	push	eax
	push	OFFSET ??_C@_0BA@DNLGAHKG@?$CFlf?5?$CFlf?5?$CFlf?5?$CFlf?$AA@
	push	ebx
	call	_fscanf
	add	esp, 24					; 00000018H
	cmp	eax, 4
	jne	SHORT $LN59@graphgen

; 284  :       for ( b = 0 ; b < web.bodycount ; b++ )

	inc	esi
	add	edi, 32					; 00000020H
	cmp	esi, DWORD PTR _web+1500
	jl	SHORT $LL68@graphgen

; 302  : #endif
; 303  :       }
; 304  :       if ( b < web.bodycount )

	jmp	SHORT $LN19@graphgen
$LN59@graphgen:
	mov	eax, DWORD PTR _web+1500
	cmp	esi, eax
	jge	SHORT $LN19@graphgen

; 305  :       { sprintf(errmsg,
; 306  :              "Colormap file has only %d entries for %d bodies.\n",
; 307  :               b,web.bodycount);

	push	eax
	push	esi
	push	OFFSET ??_C@_0DC@IBNAIEJL@Colormap?5file?5has?5only?5?$CFd?5entrie@
	push	OFFSET _errmsg
	call	_sprintf

; 308  :         kb_error(1046,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1046					; 00000416H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 309  :         for ( ; b < web.bodycount ; b++ )

	cmp	esi, DWORD PTR _web+1500
	jge	SHORT $LN19@graphgen

; 305  :       { sprintf(errmsg,
; 306  :              "Colormap file has only %d entries for %d bodies.\n",
; 307  :               b,web.bodycount);

	mov	eax, DWORD PTR _colormap
	fld	QWORD PTR __real@3fe0000000000000
	mov	edx, esi
	shl	edx, 5
	lea	eax, DWORD PTR [edx+eax+16]
$LN10@graphgen:

; 310  :         { c = colormap[b];
; 311  :           c[0] = c[1] = c[2] = c[3] = 0.5;

	fst	QWORD PTR [eax+8]
	inc	esi
	fst	QWORD PTR [eax]
	add	eax, 32					; 00000020H
	fst	QWORD PTR [eax-40]
	fst	QWORD PTR [eax-48]
	cmp	esi, DWORD PTR _web+1500
	jl	SHORT $LN10@graphgen

; 309  :         for ( ; b < web.bodycount ; b++ )

	fstp	ST(0)
$LN19@graphgen:

; 325  : 
; 326  : 
; 327  :   if ( web.symmetry_flag && (torus_display_mode==TORUS_CONNECTED_MODE) )

	cmp	DWORD PTR _web+856, 0
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN2@graphgen
	cmp	DWORD PTR _torus_display_mode, 2
	jne	SHORT $LN2@graphgen

; 328  :   { if ( web.skel[BODY].count <= 0 )

	cmp	DWORD PTR _web+400, 0
	jg	SHORT $LN2@graphgen

; 329  :     { kb_error(1049,
; 330  :       "There are no bodies to display connectedly.  Reverting to raw mode.\n",
; 331  :       WARNING);

	push	2
	push	OFFSET ??_C@_0EF@DBFKJEGH@There?5are?5no?5bodies?5to?5display?5c@
	push	1049					; 00000419H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 332  :       torus_display_mode = TORUS_RAW_MODE;

	mov	DWORD PTR _torus_display_mode, 1
$LN2@graphgen:

; 333  :     }
; 334  :   }
; 335  : 
; 336  :   raw_generate(); // generate the facets and edges

	call	_raw_generate

; 337  : 
; 338  :   (*graph_end)();  /* device-specific termination */

	call	DWORD PTR _graph_end

; 339  : 
; 340  :   if ( colorflag ) temp_free((char *)colormap);

	cmp	DWORD PTR _colorflag, 0
	je	SHORT $LN67@graphgen
	mov	ecx, DWORD PTR _colormap
	push	ecx
	call	_temp_free
	add	esp, 4
$LN67@graphgen:

; 341  : 
; 342  :   return  graphcount;

	xor	eax, eax

; 343  : } /* end graphgen() */

	mov	esp, ebp
	pop	ebp
	ret	0
_graphgen ENDP
_TEXT	ENDS
END
