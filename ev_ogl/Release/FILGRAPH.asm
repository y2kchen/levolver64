; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\FILGRAPH.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_OFF_eps
_DATA	SEGMENT
COMM	_OFF_facets:DWORD
COMM	_OFF_edges:DWORD
COMM	_OFF_facet_count:DWORD
COMM	_OFF_edges_alloc:DWORD
COMM	_binary_off_filename:DWORD
COMM	_OFF_edge_count:DWORD
COMM	_OFF_verts:DWORD
COMM	_OFF_facets_alloc:DWORD
COMM	_OFF_vertex_count:DWORD
COMM	_OFF_verts_alloc:DWORD
_OFF_eps DQ	03eb0c6f7a0b5ed8dr		; 1e-006
_DATA	ENDS
PUBLIC	_get_fe_edge
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _get_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_facet PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp

; 84   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 85   :     return inverse_id(feptr(fe_id)->nextfacet[1]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]
	xor	eax, 134217728				; 08000000H

; 88   : }

	pop	ebp
	ret	0
$LN2@get_prev_f:

; 86   :   else 
; 87   :     return feptr(fe_id)->nextfacet[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]

; 88   : }

	pop	ebp
	ret	0
_get_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0P@MDBHDFDD@File?5aborted?4?6?$AA@	; `string'
PUBLIC	??_C@_0BC@DHGPIODO@Enter?5file?5name?3?5?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_fil_init
EXTRN	_erroutstring:PROC
EXTRN	_perror:PROC
EXTRN	_l_evolver_mode:DWORD
EXTRN	_l_redirect:DWORD
EXTRN	_fopen:PROC
EXTRN	_kb_error:PROC
EXTRN	_prompt:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_fd	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\filgraph.c
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MDBHDFDD@File?5aborted?4?6?$AA@
CONST	SEGMENT
??_C@_0P@MDBHDFDD@File?5aborted?4?6?$AA@ DB 'File aborted.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DHGPIODO@Enter?5file?5name?3?5?$AA@
CONST	SEGMENT
??_C@_0BC@DHGPIODO@Enter?5file?5name?3?5?$AA@ DB 'Enter file name: ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _fil_init
_TEXT	SEGMENT
_file_name$ = -2004					; size = 2000
__$ArrayPad$ = -4					; size = 4
_fil_init PROC						; COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2004				; 000007d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
$LL8@fil_init:

; 31   :   char file_name[2000];
; 32   : 
; 33   :   for (;;)
; 34   :   {
; 35   :      prompt("Enter file name: ",file_name,sizeof(file_name));

	push	2000					; 000007d0H
	lea	eax, DWORD PTR _file_name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@DHGPIODO@Enter?5file?5name?3?5?$AA@
	call	_prompt
	add	esp, 12					; 0000000cH

; 36   :      if ( file_name[0] == 0 )

	cmp	BYTE PTR _file_name$[ebp], 0
	jne	SHORT $LN6@fil_init

; 37   :      { kb_error(4006,"File aborted.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0P@MDBHDFDD@File?5aborted?4?6?$AA@
	push	4006					; 00000fa6H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN6@fil_init:

; 38   :      }
; 39   : 
; 40   :      fd = fopen(file_name,"w");

	lea	ecx, DWORD PTR _file_name$[ebp]
	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fd, eax

; 41   :      if ( fd == NULL )

	test	eax, eax
	jne	SHORT $LN5@fil_init

; 42   :      { 
; 43   : #ifdef __L_EVOLVER__
; 44   : 		   if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, eax
	jne	SHORT $LN3@fil_init
	cmp	DWORD PTR _l_evolver_mode, eax
	jne	SHORT $LN3@fil_init

; 46   : 		   else
; 47   : 			   perror(file_name);

	lea	edx, DWORD PTR _file_name$[ebp]
	push	edx
	call	_perror
	add	esp, 4
	jmp	SHORT $LL8@fil_init
$LN3@fil_init:

; 45   : 			   erroutstring(file_name);

	lea	eax, DWORD PTR _file_name$[ebp]
	push	eax
	call	_erroutstring
	add	esp, 4

; 48   : #else
; 49   : 			   perror(file_name);
; 50   : #endif
; 51   :        continue;

	jmp	$LL8@fil_init
$LN5@fil_init:

; 52   :      }
; 53   :      else return;
; 54   :   }
; 55   : 
; 56   : } // end fil_init()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fil_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@DEBOKMHI@?5?50?403?5?50?403?5?50?403?5?50?40?5?6?$AA@ ; `string'
PUBLIC	??_C@_09DFCAGMMI@?5?5?$CFf?5?$CFf?5?5?$AA@	; `string'
PUBLIC	_fil_edge
EXTRN	_fprintf:PROC
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_0BK@DEBOKMHI@?5?50?403?5?50?403?5?50?403?5?50?40?5?6?$AA@
CONST	SEGMENT
??_C@_0BK@DEBOKMHI@?5?50?403?5?50?403?5?50?403?5?50?40?5?6?$AA@ DB '  0.0'
	DB	'3  0.03  0.03  0.0 ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DFCAGMMI@?5?5?$CFf?5?$CFf?5?5?$AA@
CONST	SEGMENT
??_C@_09DFCAGMMI@?5?5?$CFf?5?$CFf?5?5?$AA@ DB '  %f %f  ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _fil_edge
_TEXT	SEGMENT
_t$ = 8							; size = 4
_fil_edge PROC						; COMDAT

; 66   : {

	push	ebp
	mov	ebp, esp

; 67   :   fprintf(fd,"  %f %f  ",(DOUBLE)t->x[0][0],(DOUBLE)t->x[0][1]);

	mov	eax, DWORD PTR _fd
	push	esi
	mov	esi, DWORD PTR _t$[ebp]
	fld	DWORD PTR [esi+36]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR [esi+32]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_09DFCAGMMI@?5?5?$CFf?5?$CFf?5?5?$AA@
	push	eax
	call	_fprintf

; 68   :   fprintf(fd,"  %f %f  ",(DOUBLE)t->x[1][0],(DOUBLE)t->x[1][1]);

	fld	DWORD PTR [esi+48]
	mov	ecx, DWORD PTR _fd
	fstp	QWORD PTR [esp+16]
	fld	DWORD PTR [esi+44]
	add	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_09DFCAGMMI@?5?5?$CFf?5?$CFf?5?5?$AA@
	push	ecx
	call	_fprintf

; 69   :   fprintf(fd,"  %f %f  ",(DOUBLE)t->x[1][0],(DOUBLE)t->x[1][1]);

	fld	DWORD PTR [esi+48]
	mov	edx, DWORD PTR _fd
	fstp	QWORD PTR [esp+16]
	fld	DWORD PTR [esi+44]
	add	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_09DFCAGMMI@?5?5?$CFf?5?$CFf?5?5?$AA@
	push	edx
	call	_fprintf

; 70   :   fprintf(fd,"  0.03  0.03  0.03  0.0 \n");

	mov	eax, DWORD PTR _fd
	push	OFFSET ??_C@_0BK@DEBOKMHI@?5?50?403?5?50?403?5?50?403?5?50?40?5?6?$AA@
	push	eax
	call	_fprintf
	add	esp, 32					; 00000020H
	pop	esi

; 71   : 
; 72   : } // end fil_edge()

	pop	ebp
	ret	0
_fil_edge ENDP
_TEXT	ENDS
PUBLIC	??_C@_04NJEFCHPC@?5?$CFf?6?$AA@			; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@00000000
PUBLIC	??_C@_04ELMIFJOO@?5?$CF1d?$AA@			; `string'
PUBLIC	??_C@_06EBCOOIGB@?5?$CFf?5?$CFf?$AA@		; `string'
PUBLIC	??_C@_05KCDNKPCA@?$CFf?5?$CFf?$AA@		; `string'
PUBLIC	_fil_facet
EXTRN	_dotf:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT ??_C@_04NJEFCHPC@?5?$CFf?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_04NJEFCHPC@?5?$CFf?6?$AA@ DB ' %f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_04ELMIFJOO@?5?$CF1d?$AA@
CONST	SEGMENT
??_C@_04ELMIFJOO@?5?$CF1d?$AA@ DB ' %1d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBCOOIGB@?5?$CFf?5?$CFf?$AA@
CONST	SEGMENT
??_C@_06EBCOOIGB@?5?$CFf?5?$CFf?$AA@ DB ' %f %f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KCDNKPCA@?$CFf?5?$CFf?$AA@
CONST	SEGMENT
??_C@_05KCDNKPCA@?$CFf?5?$CFf?$AA@ DB '%f %f', 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\filgraph.c
CONST	ENDS
;	COMDAT _fil_facet
_TEXT	SEGMENT
tv243 = -8						; size = 8
tv333 = 8						; size = 4
_t$ = 8							; size = 4
_fil_facet PROC						; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 84   :   REAL cosine;
; 85   :   edge_id e_id;
; 86   :   facetedge_id fe_id;
; 87   :   int type;
; 88   :   int i;
; 89   :   
; 90   :   if ( t->color == CLEAR ) return;

	mov	ebx, DWORD PTR _t$[ebp]
	cmp	DWORD PTR [ebx+4], -1
	je	$LN14@fil_facet

; 91   : 
; 92   :   fprintf(fd,"%f %f",(DOUBLE)t->x[0][0],(DOUBLE)t->x[0][1]);

	fld	DWORD PTR [ebx+36]
	mov	eax, DWORD PTR _fd
	push	esi
	push	edi
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR [ebx+32]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_05KCDNKPCA@?$CFf?5?$CFf?$AA@
	push	eax
	call	_fprintf

; 93   :   fprintf(fd," %f %f",(DOUBLE)t->x[1][0],(DOUBLE)t->x[1][1]);

	fld	DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR _fd
	fstp	QWORD PTR [esp+16]
	fld	DWORD PTR [ebx+44]
	add	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_06EBCOOIGB@?5?$CFf?5?$CFf?$AA@
	push	ecx
	call	_fprintf

; 94   :   fprintf(fd," %f %f",(DOUBLE)t->x[2][0],(DOUBLE)t->x[2][1]);

	fld	DWORD PTR [ebx+60]
	mov	edx, DWORD PTR _fd
	fstp	QWORD PTR [esp+16]
	fld	DWORD PTR [ebx+56]
	add	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_06EBCOOIGB@?5?$CFf?5?$CFf?$AA@
	push	edx
	call	_fprintf

; 95   :   fe_id = get_facet_fe(t->f_id);

	mov	eax, DWORD PTR [ebx]
	add	esp, 24					; 00000018H
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN17@fil_facet
	xor	edi, edi
	jmp	SHORT $LN16@fil_facet
$LN17@fil_facet:
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edi, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN16@fil_facet
	xor	edi, 134217728				; 08000000H
$LN16@fil_facet:

; 96   :   for ( i = 0 ; i < 3 ; i++ )

	mov	eax, DWORD PTR _web+460
	mov	DWORD PTR tv333[ebp], 3
$LL40@fil_facet:

; 97   :      { 
; 98   :         e_id = get_fe_edge(fe_id);

	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	edx, DWORD PTR [ecx+20]

; 99   :         if ( get_eattr(e_id) & FIXED ) type = 3;

	mov	eax, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN9@fil_facet
	lea	eax, DWORD PTR [edx+3]
	jmp	SHORT $LN5@fil_facet
$LN9@fil_facet:

; 100  :         else if ( equal_id(get_next_facet(fe_id),fe_id) )

	mov	edx, edi
	shr	edx, 27					; 0000001bH
	and	edx, 1
	je	SHORT $LN23@fil_facet
	mov	eax, DWORD PTR [ecx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN22@fil_facet
$LN23@fil_facet:
	mov	eax, DWORD PTR [ecx+40]
$LN22@fil_facet:
	cmp	eax, edi
	jne	SHORT $LN7@fil_facet

; 101  :           type = 1;  /* edge of some sort */

	mov	eax, 1
	jmp	SHORT $LN5@fil_facet
$LN7@fil_facet:

; 102  :         else if ( !equal_id(get_next_facet(fe_id),get_prev_facet(fe_id)) )

	test	edx, edx
	je	SHORT $LN27@fil_facet
	mov	eax, DWORD PTR [ecx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN26@fil_facet
$LN27@fil_facet:
	mov	eax, DWORD PTR [ecx+40]
$LN26@fil_facet:
	test	edx, edx
	je	SHORT $LN31@fil_facet
	mov	ecx, DWORD PTR [ecx+40]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN30@fil_facet
$LN31@fil_facet:
	mov	ecx, DWORD PTR [ecx+36]
$LN30@fil_facet:
	sub	eax, ecx
	neg	eax
	sbb	eax, eax
	and	eax, 4
$LN5@fil_facet:

; 103  :           type = 4;  /* triple line at least */
; 104  :         else type = 0;  /* ordinary internal grid line */
; 105  : 
; 106  :         fprintf(fd," %1d",type);

	mov	ecx, DWORD PTR _fd
	push	eax
	push	OFFSET ??_C@_04ELMIFJOO@?5?$CF1d?$AA@
	push	ecx
	call	_fprintf

; 107  :         fe_id = get_next_edge(fe_id);

	mov	eax, DWORD PTR _web+460
	add	esp, 12					; 0000000cH
	test	edi, 134217728				; 08000000H
	je	SHORT $LN35@fil_facet
	mov	edx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [edx+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN11@fil_facet
$LN35@fil_facet:
	mov	ecx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [ecx+32]
$LN11@fil_facet:

; 96   :   for ( i = 0 ; i < 3 ; i++ )

	dec	DWORD PTR tv333[ebp]
	jne	$LL40@fil_facet

; 108  :      }
; 109  :   
; 110  :   if ( valid_id(t->f_id) )

	test	DWORD PTR [ebx], 268435456		; 10000000H
	pop	edi
	pop	esi
	je	SHORT $LN3@fil_facet

; 111  :      {
; 112  :         cosine = t->normal[1]/sqrt(dotf(t->normal,t->normal,3));

	fld	DWORD PTR [ebx+72]
	lea	eax, DWORD PTR [ebx+68]
	push	3
	fstp	QWORD PTR tv243[ebp]
	push	eax
	push	eax
	call	_dotf
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fdivr	QWORD PTR tv243[ebp]

; 113  :         if ( (REAL)t->normal[2] < 0.0 ) cosine = -cosine;

	fldz
	fcomp	DWORD PTR [ebx+76]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@fil_facet
	fchs

; 114  :      }
; 115  :   else cosine = 0.0;

	jmp	SHORT $LN1@fil_facet
$LN3@fil_facet:
	fldz
$LN1@fil_facet:

; 116  :   fprintf(fd," %f\n",(DOUBLE)cosine);

	mov	edx, DWORD PTR _fd
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_04NJEFCHPC@?5?$CFf?6?$AA@
	push	edx
	call	_fprintf
	add	esp, 16					; 00000010H
$LN14@fil_facet:
	pop	ebx

; 117  : 
; 118  : } // end fil_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
_fil_facet ENDP
_TEXT	ENDS
PUBLIC	_fil_finish
EXTRN	_fclose:PROC
; Function compile flags: /Ogtp
;	COMDAT _fil_finish
_TEXT	SEGMENT
_fil_finish PROC					; COMDAT

; 129  :   fclose(fd);

	mov	eax, DWORD PTR _fd
	push	eax
	call	_fclose
	pop	ecx

; 130  : }

	ret	0
_fil_finish ENDP
_TEXT	ENDS
PUBLIC	_OFF_comp
; Function compile flags: /Ogtp
;	COMDAT _OFF_comp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_OFF_comp PROC						; COMDAT

; 173  : { int i;

	push	ebp
	mov	ebp, esp

; 174  :   for ( i = 0 ; i < 3; i++ )

	mov	ecx, DWORD PTR _b$[ebp]
	fld	QWORD PTR _OFF_eps
	push	esi
	mov	esi, DWORD PTR _a$[ebp]
	xor	edx, edx
	sub	esi, ecx
$LN5@OFF_comp:

; 175  :   { if ( a->x[i] < b->x[i] - OFF_eps ) return -1;

	fld	QWORD PTR [ecx]
	fsub	ST(0), ST(1)
	fcomp	QWORD PTR [esi+ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN14@OFF_comp

; 176  :     if ( a->x[i] > b->x[i] + OFF_eps ) return  1;

	fld	QWORD PTR [ecx]
	fadd	ST(0), ST(1)
	fcomp	QWORD PTR [esi+ecx]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN17@OFF_comp

; 174  :   for ( i = 0 ; i < 3; i++ )

	inc	edx
	add	ecx, 8
	cmp	edx, 3
	jl	SHORT $LN5@OFF_comp
	fstp	ST(0)

; 177  :   }
; 178  :   return 0;

	xor	eax, eax
	pop	esi

; 179  : } // end OFF_comp()

	pop	ebp
	ret	0
$LN14@OFF_comp:

; 175  :   { if ( a->x[i] < b->x[i] - OFF_eps ) return -1;

	fstp	ST(0)
	or	eax, -1
	pop	esi

; 179  : } // end OFF_comp()

	pop	ebp
	ret	0
$LN17@OFF_comp:

; 176  :     if ( a->x[i] > b->x[i] + OFF_eps ) return  1;

	fstp	ST(0)
	mov	eax, 1
	pop	esi

; 179  : } // end OFF_comp()

	pop	ebp
	ret	0
_OFF_comp ENDP
_TEXT	ENDS
PUBLIC	_OFF_edge_comp
; Function compile flags: /Ogtp
;	COMDAT _OFF_edge_comp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_OFF_edge_comp PROC					; COMDAT

; 191  : { int i;

	push	ebp
	mov	ebp, esp

; 192  :   for ( i = 0 ; i < EDGE_VERTS ; i++ )

	mov	eax, DWORD PTR _b$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _a$[ebp]
	xor	esi, esi
	sub	edi, eax
	npad	1
$LL5@OFF_edge_c:

; 193  :   { if ( a->v[i] < b->v[i] ) return -1;

	mov	ecx, DWORD PTR [edi+eax]
	mov	edx, DWORD PTR [eax]
	cmp	ecx, edx
	jl	SHORT $LN9@OFF_edge_c

; 194  :     if ( a->v[i] > b->v[i] ) return 1;

	jg	SHORT $LN10@OFF_edge_c

; 192  :   for ( i = 0 ; i < EDGE_VERTS ; i++ )

	inc	esi
	add	eax, 4
	cmp	esi, 2
	jl	SHORT $LL5@OFF_edge_c

; 195  :   }
; 196  :   return 0;

	pop	edi
	xor	eax, eax
	pop	esi

; 197  : } // end OFF_edge_comp()

	pop	ebp
	ret	0
$LN9@OFF_edge_c:
	pop	edi

; 193  :   { if ( a->v[i] < b->v[i] ) return -1;

	or	eax, -1
	pop	esi

; 197  : } // end OFF_edge_comp()

	pop	ebp
	ret	0
$LN10@OFF_edge_c:
	pop	edi

; 194  :     if ( a->v[i] > b->v[i] ) return 1;

	mov	eax, 1
	pop	esi

; 197  : } // end OFF_edge_comp()

	pop	ebp
	ret	0
_OFF_edge_comp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_OFF_start
EXTRN	_kb_temp_calloc:PROC
;	COMDAT ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
CONST	SEGMENT
??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@ DB 'FILGRAPH.C', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _OFF_start
_TEXT	SEGMENT
_file_name$ = -2004					; size = 2000
__$ArrayPad$ = -4					; size = 4
_OFF_start PROC						; COMDAT

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2004				; 000007d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
$LL8@OFF_start:

; 208  :   char file_name[2000];
; 209  : 
; 210  :   for (;;)
; 211  :   {
; 212  :     prompt("Enter file name: ",file_name,sizeof(file_name));

	push	2000					; 000007d0H
	lea	eax, DWORD PTR _file_name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@DHGPIODO@Enter?5file?5name?3?5?$AA@
	call	_prompt
	add	esp, 12					; 0000000cH

; 213  :     if ( file_name[0] == 0 )

	cmp	BYTE PTR _file_name$[ebp], 0
	jne	SHORT $LN6@OFF_start

; 214  :     { kb_error(4005,"File aborted.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0P@MDBHDFDD@File?5aborted?4?6?$AA@
	push	4005					; 00000fa5H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN6@OFF_start:

; 215  :     }
; 216  : 
; 217  :     fd = fopen(file_name,"w");

	lea	ecx, DWORD PTR _file_name$[ebp]
	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fd, eax

; 218  :     if ( fd == NULL )

	test	eax, eax
	jne	SHORT $LN5@OFF_start

; 219  :     { 
; 220  : #ifdef __L_EVOLVER__
; 221  : 		   if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, eax
	jne	SHORT $LN3@OFF_start
	cmp	DWORD PTR _l_evolver_mode, eax
	jne	SHORT $LN3@OFF_start

; 223  : 		   else
; 224  : 			   perror(file_name);

	lea	edx, DWORD PTR _file_name$[ebp]
	push	edx
	call	_perror
	jmp	SHORT $LN12@OFF_start
$LN3@OFF_start:

; 222  : 			   erroutstring(file_name);

	lea	eax, DWORD PTR _file_name$[ebp]
	push	eax
	call	_erroutstring
$LN12@OFF_start:
	add	esp, 4

; 225  : #else
; 226  : 			   perror(file_name);
; 227  : #endif	
; 228  :       kb_error(1906,"",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	1906					; 00000772H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 229  :     }
; 230  :     else break;
; 231  :   }

	jmp	$LL8@OFF_start
$LN5@OFF_start:

; 232  :   OFF_vertex_count = 0;
; 233  :   OFF_edge_count = 0;
; 234  :   OFF_facet_count = 0;
; 235  : 
; 236  :   OFF_verts_alloc = 2*web.skel[EDGE].count + 3*web.skel[FACET].count;

	mov	eax, DWORD PTR _web+288
	mov	edx, DWORD PTR _web+176

; 237  :   OFF_verts = (struct OFF_vertex_t *)temp_calloc(OFF_verts_alloc,
; 238  :                   sizeof(struct OFF_vertex_t));

	push	238					; 000000eeH
	lea	ecx, DWORD PTR [eax+eax*2]
	push	OFFSET ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
	lea	eax, DWORD PTR [ecx+edx*2]
	push	32					; 00000020H
	push	eax
	mov	DWORD PTR _OFF_vertex_count, 0
	mov	DWORD PTR _OFF_edge_count, 0
	mov	DWORD PTR _OFF_facet_count, 0
	mov	DWORD PTR _OFF_verts_alloc, eax
	call	_kb_temp_calloc

; 239  :   OFF_facets_alloc = 3*web.skel[FACET].count;
; 240  :   OFF_facets = (struct OFF_facet_t *)temp_calloc(OFF_facets_alloc,
; 241  :                   sizeof(struct OFF_facet_t));

	push	241					; 000000f1H
	mov	DWORD PTR _OFF_verts, eax
	mov	eax, DWORD PTR _web+288
	push	OFFSET ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
	lea	eax, DWORD PTR [eax+eax*2]
	push	20					; 00000014H
	push	eax
	mov	DWORD PTR _OFF_facets_alloc, eax
	call	_kb_temp_calloc

; 242  : } // end OFF_start()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	add	esp, 32					; 00000020H
	mov	DWORD PTR _OFF_facets, eax
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_OFF_start ENDP
_TEXT	ENDS
PUBLIC	_OFF_edge
; Function compile flags: /Ogtp
;	COMDAT _OFF_edge
_TEXT	SEGMENT
_g$ = 8							; size = 4
_e_id$ = 12						; size = 4
_OFF_edge PROC						; COMDAT

; 256  :  
; 257  :   int e_color;
; 258  : 
; 259  :   e_color = g[0].ecolor;
; 260  :   if ( e_color == CLEAR ) return;
; 261  :   if ( (e_color < 0) || (e_color >= IRIS_COLOR_MAX) )
; 262  :     e_color = DEFAULT_EDGE_COLOR;
; 263  : 
; 264  : } // end OFF_edge()

	ret	0
_OFF_edge ENDP
_TEXT	ENDS
PUBLIC	_OFF_facet
EXTRN	_kb_temp_realloc:PROC
; Function compile flags: /Ogtp
;	COMDAT _OFF_facet
_TEXT	SEGMENT
_g$ = 8							; size = 4
_f_id$ = 12						; size = 4
_OFF_facet PROC						; COMDAT

; 277  : {

	push	ebp
	mov	ebp, esp

; 278  :   int i,k;
; 279  : 
; 280  :   if ( OFF_vertex_count > OFF_verts_alloc - 5 )

	mov	eax, DWORD PTR _OFF_verts_alloc
	mov	ecx, DWORD PTR _OFF_vertex_count
	lea	edx, DWORD PTR [eax-5]
	cmp	ecx, edx
	jle	SHORT $LN38@OFF_facet

; 281  :   { OFF_verts = (struct OFF_vertex_t*)temp_realloc((char*)OFF_verts,
; 282  :         2*OFF_verts_alloc*sizeof(struct OFF_vertex_t));

	push	282					; 0000011aH
	shl	eax, 6
	push	OFFSET ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
	push	eax
	mov	eax, DWORD PTR _OFF_verts
	push	eax
	call	_kb_temp_realloc

; 283  :     OFF_verts_alloc *= 2;

	mov	ecx, DWORD PTR _OFF_verts_alloc
	lea	edx, DWORD PTR [ecx+ecx]
	mov	ecx, DWORD PTR _OFF_vertex_count
	add	esp, 16					; 00000010H
	mov	DWORD PTR _OFF_verts, eax
	mov	DWORD PTR _OFF_verts_alloc, edx
$LN38@OFF_facet:

; 284  :   }
; 285  :   if ( OFF_facet_count > OFF_facets_alloc - 5 )

	mov	eax, DWORD PTR _OFF_facets_alloc
	lea	edx, DWORD PTR [eax-5]
	cmp	DWORD PTR _OFF_facet_count, edx
	jle	SHORT $LN7@OFF_facet

; 286  :   { OFF_facets = (struct OFF_facet_t*)temp_realloc((char*)OFF_facets,
; 287  :         2*OFF_facets_alloc*sizeof(struct OFF_facet_t));

	mov	ecx, DWORD PTR _OFF_facets
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	push	287					; 0000011fH
	add	eax, eax
	push	OFFSET ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
	add	eax, eax
	push	eax
	push	ecx
	call	_kb_temp_realloc

; 288  :     OFF_facets_alloc *= 2;

	mov	edx, DWORD PTR _OFF_facets_alloc
	mov	ecx, DWORD PTR _OFF_vertex_count
	mov	DWORD PTR _OFF_facets, eax
	lea	eax, DWORD PTR [edx+edx]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _OFF_facets_alloc, eax
$LN7@OFF_facet:

; 289  :   }
; 290  : 
; 291  : 
; 292  :   for ( i = 0 ; i < FACET_VERTS ; i++ )
; 293  :   { for ( k = 0 ; k < 3 ; k++ )
; 294  :       OFF_verts[OFF_vertex_count].x[k] = g[i].x[k];

	mov	edx, DWORD PTR _OFF_verts
	mov	eax, DWORD PTR _g$[ebp]
	fld	QWORD PTR [eax]
	shl	ecx, 5
	fstp	QWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [eax+8]
	mov	edx, DWORD PTR _OFF_verts
	shl	ecx, 5
	fstp	QWORD PTR [ecx+edx+8]
	mov	ecx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [eax+16]
	mov	edx, DWORD PTR _OFF_verts
	shl	ecx, 5
	fstp	QWORD PTR [ecx+edx+16]

; 295  :     OFF_facets[OFF_facet_count].v[i] = OFF_vertex_count;

	mov	ecx, DWORD PTR _OFF_facet_count
	mov	edx, DWORD PTR _OFF_vertex_count
	lea	ecx, DWORD PTR [ecx+ecx*4]
	push	esi
	mov	esi, DWORD PTR _OFF_facets
	mov	DWORD PTR [esi+ecx*4], edx

; 296  :     OFF_vertex_count++;

	mov	ecx, DWORD PTR _OFF_vertex_count
	mov	esi, DWORD PTR _OFF_verts
	mov	edx, 1
	add	ecx, edx
	mov	DWORD PTR _OFF_vertex_count, ecx
	fld	QWORD PTR [eax+144]
	shl	ecx, 5
	fstp	QWORD PTR [ecx+esi]
	mov	ecx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [eax+152]
	mov	esi, DWORD PTR _OFF_verts
	shl	ecx, 5
	fstp	QWORD PTR [ecx+esi+8]
	mov	ecx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [eax+160]
	mov	esi, DWORD PTR _OFF_verts
	shl	ecx, 5
	fstp	QWORD PTR [ecx+esi+16]
	mov	ecx, DWORD PTR _OFF_facet_count
	mov	esi, DWORD PTR _OFF_vertex_count
	lea	ecx, DWORD PTR [ecx+ecx*4]
	push	edi
	mov	edi, DWORD PTR _OFF_facets
	mov	DWORD PTR [edi+ecx*4+4], esi
	mov	ecx, DWORD PTR _OFF_vertex_count
	mov	esi, DWORD PTR _OFF_verts
	add	ecx, edx
	mov	DWORD PTR _OFF_vertex_count, ecx
	fld	QWORD PTR [eax+288]
	shl	ecx, 5
	fstp	QWORD PTR [ecx+esi]
	mov	ecx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [eax+296]
	mov	esi, DWORD PTR _OFF_verts
	shl	ecx, 5
	fstp	QWORD PTR [ecx+esi+8]
	mov	ecx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [eax+304]
	mov	eax, DWORD PTR _OFF_verts
	shl	ecx, 5
	fstp	QWORD PTR [ecx+eax+16]
	mov	eax, DWORD PTR _OFF_facet_count
	mov	esi, DWORD PTR _OFF_facets
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _OFF_vertex_count
	mov	DWORD PTR [esi+ecx*4+8], eax
	add	DWORD PTR _OFF_vertex_count, edx

; 297  :   }
; 298  :   OFF_facet_count++;

	add	DWORD PTR _OFF_facet_count, edx
	pop	edi
	pop	esi

; 299  : 
; 300  : } // end OFF_facet()

	pop	ebp
	ret	0
_OFF_facet ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@NNHAIINA@3?5?$CFd?5?$CFd?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_09MALOBAAJ@?$CFf?5?$CFf?5?$CFf?6?$AA@	; `string'
PUBLIC	??_C@_0O@KFIBBLLO@OFF?6?$CFd?5?$CFd?5?$CFd?6?$AA@ ; `string'
PUBLIC	_OFF_end
EXTRN	_temp_free:PROC
EXTRN	_qsort:PROC
;	COMDAT ??_C@_0M@NNHAIINA@3?5?$CFd?5?$CFd?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0M@NNHAIINA@3?5?$CFd?5?$CFd?5?$CFd?6?$AA@ DB '3 %d %d %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MALOBAAJ@?$CFf?5?$CFf?5?$CFf?6?$AA@
CONST	SEGMENT
??_C@_09MALOBAAJ@?$CFf?5?$CFf?5?$CFf?6?$AA@ DB '%f %f %f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KFIBBLLO@OFF?6?$CFd?5?$CFd?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0O@KFIBBLLO@OFF?6?$CFd?5?$CFd?5?$CFd?6?$AA@ DB 'OFF', 0aH, '%d %d %'
	DB	'd', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _OFF_end
_TEXT	SEGMENT
_keep$ = -20						; size = 4
tv505 = -16						; size = 4
_translate$ = -12					; size = 4
tv502 = -8						; size = 4
_i$ = -4						; size = 4
_OFF_end PROC						; COMDAT

; 311  : { int i,j,keep;

	push	ebp
	mov	ebp, esp

; 312  :   int *translate;
; 313  : 
; 314  :   /* unify vertices */
; 315  :   for ( i = 0 ; i < OFF_vertex_count ; i++ )

	mov	ecx, DWORD PTR _OFF_vertex_count
	sub	esp, 20					; 00000014H
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN19@OFF_end
	xor	edx, edx
	npad	12
$LL21@OFF_end:

; 316  :     OFF_verts[i].orig = i;

	mov	ecx, DWORD PTR _OFF_verts
	mov	DWORD PTR [edx+ecx+24], eax
	mov	ecx, DWORD PTR _OFF_vertex_count
	inc	eax
	add	edx, 32					; 00000020H
	cmp	eax, ecx
	jl	SHORT $LL21@OFF_end
$LN19@OFF_end:

; 317  :   qsort((char*)OFF_verts,OFF_vertex_count,sizeof(struct OFF_vertex_t), 
; 318  :       FCAST OFF_comp);

	mov	edx, DWORD PTR _OFF_verts
	push	ebx
	push	esi
	push	edi
	push	OFFSET _OFF_comp
	push	32					; 00000020H
	push	ecx
	push	edx
	call	_qsort

; 319  :   translate = (int*)temp_calloc(OFF_vertex_count,sizeof(int));

	mov	eax, DWORD PTR _OFF_vertex_count
	push	319					; 0000013fH
	push	OFFSET ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
	push	4
	push	eax
	call	_kb_temp_calloc

; 320  :   translate[OFF_verts[0].orig] = 0;

	mov	ecx, DWORD PTR _OFF_verts
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+edx*4], 0
	mov	DWORD PTR _translate$[ebp], eax

; 321  :   for ( i = 1, keep = 0 ; i < OFF_vertex_count ; i++ )

	mov	eax, 1
	add	esp, 32					; 00000020H
	xor	edi, edi
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _OFF_vertex_count, eax
	jle	SHORT $LN16@OFF_end
	xor	ebx, ebx
	mov	DWORD PTR tv502[ebp], 32		; 00000020H
	npad	9
$LL41@OFF_end:

; 322  :   { if ( OFF_comp(OFF_verts+i,OFF_verts+keep) != 0 )

	mov	esi, DWORD PTR _OFF_verts
	mov	eax, DWORD PTR tv502[ebp]
	lea	ecx, DWORD PTR [ebx+esi]
	add	eax, esi
	push	ecx
	push	eax
	mov	DWORD PTR tv505[ebp], eax
	call	_OFF_comp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN42@OFF_end

; 323  :       OFF_verts[++keep] = OFF_verts[i];

	inc	edi
	mov	ebx, edi
	mov	DWORD PTR _keep$[ebp], edi
	shl	ebx, 5
	lea	edi, DWORD PTR [ebx+esi]
	mov	esi, DWORD PTR tv505[ebp]
	mov	ecx, 8
	rep movsd
	mov	esi, DWORD PTR _OFF_verts
	mov	edi, DWORD PTR _keep$[ebp]
$LN42@OFF_end:

; 324  :     translate[OFF_verts[i].orig] = keep;

	mov	ecx, DWORD PTR tv502[ebp]
	mov	edx, DWORD PTR [ecx+esi+24]
	mov	eax, DWORD PTR _translate$[ebp]
	mov	DWORD PTR [eax+edx*4], edi
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	ecx, 32					; 00000020H
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR tv502[ebp], ecx
	cmp	eax, DWORD PTR _OFF_vertex_count
	jl	SHORT $LL41@OFF_end
$LN16@OFF_end:

; 327  :   for ( i = 0 ; i < OFF_facet_count ; i++ )

	mov	eax, DWORD PTR _OFF_facet_count
	xor	edx, edx
	inc	edi
	mov	DWORD PTR _OFF_vertex_count, edi
	mov	DWORD PTR _i$[ebp], edx
	cmp	eax, edx
	jle	$LN12@OFF_end

; 325  :   }
; 326  :   OFF_vertex_count = keep+1;

	mov	edi, DWORD PTR _OFF_facets
	xor	ebx, ebx
	lea	esi, DWORD PTR [edx+8]
$LL14@OFF_end:

; 328  :   { for ( j = 0 ; j < 3 ; j++ )
; 329  :       OFF_facets[i].v[j] = translate[OFF_facets[i].v[j]];

	mov	ecx, DWORD PTR [edx+edi]
	mov	eax, DWORD PTR _translate$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx+edi], ecx
	mov	ecx, DWORD PTR _OFF_facets
	mov	edi, DWORD PTR [edx+ecx+4]
	mov	edi, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [edx+ecx+4], edi
	mov	ecx, DWORD PTR _OFF_facets
	mov	edi, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+ecx], eax

; 330  :     /* test for degenerate facet */
; 331  :     if ( OFF_facets[i].v[0] == OFF_facets[i].v[1] ||
; 332  :          OFF_facets[i].v[1] == OFF_facets[i].v[2] ||
; 333  :          OFF_facets[i].v[2] == OFF_facets[i].v[0] )

	mov	edi, DWORD PTR _OFF_facets
	mov	ecx, DWORD PTR [ebx+edi]
	cmp	ecx, DWORD PTR [ebx+edi+4]
	lea	eax, DWORD PTR [ebx+edi]
	je	SHORT $LN7@OFF_end
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [eax+4], ecx
	je	SHORT $LN7@OFF_end
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN13@OFF_end
$LN7@OFF_end:

; 334  :     { /* found degenerate, so replace with last in list */
; 335  :       OFF_facets[i] = OFF_facets[--OFF_facet_count];

	mov	ecx, DWORD PTR _OFF_facet_count

; 336  :       i--;

	dec	DWORD PTR _i$[ebp]
	dec	ecx
	mov	DWORD PTR _OFF_facet_count, ecx
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edi
	mov	edi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edi, DWORD PTR _OFF_facets
	sub	edx, 20					; 00000014H
	sub	esi, 20					; 00000014H
	sub	ebx, 20					; 00000014H
$LN13@OFF_end:

; 327  :   for ( i = 0 ; i < OFF_facet_count ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _OFF_facet_count
	inc	ecx
	add	edx, 20					; 00000014H
	add	esi, 20					; 00000014H
	add	ebx, 20					; 00000014H
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, eax
	jl	$LL14@OFF_end
$LN12@OFF_end:

; 337  :     }
; 338  :   }
; 339  : 
; 340  :   fprintf(fd,"OFF\n%d %d %d\n",OFF_vertex_count,OFF_facet_count,OFF_edge_count);

	mov	edx, DWORD PTR _OFF_edge_count
	mov	ecx, DWORD PTR _fd
	push	edx
	push	eax
	mov	eax, DWORD PTR _OFF_vertex_count
	push	eax
	push	OFFSET ??_C@_0O@KFIBBLLO@OFF?6?$CFd?5?$CFd?5?$CFd?6?$AA@
	push	ecx
	call	_fprintf

; 341  :   for ( i = 0 ; i < OFF_vertex_count ; i++ )

	xor	esi, esi
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _OFF_vertex_count, esi
	jle	SHORT $LN43@OFF_end

; 337  :     }
; 338  :   }
; 339  : 
; 340  :   fprintf(fd,"OFF\n%d %d %d\n",OFF_vertex_count,OFF_facet_count,OFF_edge_count);

	xor	edi, edi
	npad	6
$LL6@OFF_end:

; 342  :     fprintf(fd,"%f %f %f\n",(DOUBLE)OFF_verts[i].x[0],
; 343  :         (DOUBLE)OFF_verts[i].x[1], (DOUBLE)OFF_verts[i].x[2]);

	mov	eax, DWORD PTR _OFF_verts
	fld	QWORD PTR [edi+eax+16]
	mov	edx, DWORD PTR _fd
	sub	esp, 24					; 00000018H
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR [edi+eax+8]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [edi+eax]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_09MALOBAAJ@?$CFf?5?$CFf?5?$CFf?6?$AA@
	push	edx
	call	_fprintf
	inc	esi
	add	esp, 32					; 00000020H
	add	edi, 32					; 00000020H
	cmp	esi, DWORD PTR _OFF_vertex_count
	jl	SHORT $LL6@OFF_end
$LN43@OFF_end:

; 344  :   for ( i = 0 ; i < OFF_facet_count ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _OFF_facet_count, esi
	jle	SHORT $LN1@OFF_end
	xor	edi, edi
	npad	6
$LL3@OFF_end:

; 345  :     fprintf(fd,"3 %d %d %d\n",OFF_facets[i].v[0],OFF_facets[i].v[1],
; 346  :         OFF_facets[i].v[2]);

	mov	eax, DWORD PTR _OFF_facets
	mov	ecx, DWORD PTR [edi+eax+8]
	mov	edx, DWORD PTR [edi+eax+4]
	mov	eax, DWORD PTR [edi+eax]
	push	ecx
	mov	ecx, DWORD PTR _fd
	push	edx
	push	eax
	push	OFFSET ??_C@_0M@NNHAIINA@3?5?$CFd?5?$CFd?5?$CFd?6?$AA@
	push	ecx
	call	_fprintf
	inc	esi
	add	esp, 20					; 00000014H
	add	edi, 20					; 00000014H
	cmp	esi, DWORD PTR _OFF_facet_count
	jl	SHORT $LL3@OFF_end
$LN1@OFF_end:

; 347  :   fclose(fd);

	mov	edx, DWORD PTR _fd
	push	edx
	call	_fclose

; 348  :   temp_free((char*)OFF_verts);

	mov	eax, DWORD PTR _OFF_verts
	push	eax
	call	_temp_free

; 349  :   temp_free((char*)OFF_facets);

	mov	ecx, DWORD PTR _OFF_facets
	push	ecx
	call	_temp_free

; 350  :   temp_free((char*)translate);

	mov	edx, DWORD PTR _translate$[ebp]
	push	edx
	call	_temp_free
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 351  : 
; 352  : } // end OFF_end()

	mov	esp, ebp
	pop	ebp
	ret	0
_OFF_end ENDP
_TEXT	ENDS
PUBLIC	__real@3eb0c6f7a0b5ed8d
PUBLIC	_binary_OFF_start
EXTRN	_overall_size:QWORD
;	COMDAT __real@3eb0c6f7a0b5ed8d
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-006
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _binary_OFF_start
_TEXT	SEGMENT
_binary_OFF_start PROC					; COMDAT

; 372  :   OFF_vertex_count = 0;
; 373  :   OFF_edge_count = 0;
; 374  :   OFF_facet_count = 0;
; 375  : 
; 376  :   OFF_verts_alloc = 2*web.skel[EDGE].count + 3*web.skel[FACET].count + 10;

	mov	ecx, DWORD PTR _web+176
	xor	eax, eax
	mov	DWORD PTR _OFF_vertex_count, eax
	mov	DWORD PTR _OFF_edge_count, eax
	mov	DWORD PTR _OFF_facet_count, eax
	mov	eax, DWORD PTR _web+288

; 377  :   OFF_verts = (struct OFF_vertex_t *)temp_calloc(OFF_verts_alloc,
; 378  :                   sizeof(struct OFF_vertex_t));

	push	378					; 0000017aH
	lea	eax, DWORD PTR [eax+eax*2]
	push	OFFSET ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
	lea	eax, DWORD PTR [eax+ecx*2+10]
	push	32					; 00000020H
	push	eax
	mov	DWORD PTR _OFF_verts_alloc, eax
	call	_kb_temp_calloc

; 379  :   OFF_edges_alloc = 2*web.skel[EDGE].count + 10;
; 380  :   OFF_edges = (struct OFF_edge_t *)temp_calloc(OFF_edges_alloc,
; 381  :                   sizeof(struct OFF_edge_t));

	push	381					; 0000017dH
	mov	DWORD PTR _OFF_verts, eax
	mov	eax, DWORD PTR _web+176
	push	OFFSET ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
	lea	eax, DWORD PTR [eax+eax+10]
	push	16					; 00000010H
	push	eax
	mov	DWORD PTR _OFF_edges_alloc, eax
	call	_kb_temp_calloc

; 382  :   OFF_facets_alloc = web.skel[FACET].count + 10;
; 383  :   OFF_facets = (struct OFF_facet_t *)temp_calloc(OFF_facets_alloc,
; 384  :                   sizeof(struct OFF_facet_t));

	push	384					; 00000180H
	mov	DWORD PTR _OFF_edges, eax
	mov	eax, DWORD PTR _web+288
	push	OFFSET ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
	add	eax, 10					; 0000000aH
	push	20					; 00000014H
	push	eax
	mov	DWORD PTR _OFF_facets_alloc, eax
	call	_kb_temp_calloc

; 385  : 
; 386  :   OFF_eps = overall_size*1e-6;

	fld	QWORD PTR _overall_size
	fmul	QWORD PTR __real@3eb0c6f7a0b5ed8d
	add	esp, 48					; 00000030H
	mov	DWORD PTR _OFF_facets, eax
	fstp	QWORD PTR _OFF_eps

; 387  : 
; 388  : } // end binary_OFF_start()

	ret	0
_binary_OFF_start ENDP
_TEXT	ENDS
PUBLIC	_binary_OFF_edge
; Function compile flags: /Ogtp
;	COMDAT _binary_OFF_edge
_TEXT	SEGMENT
_g$ = 8							; size = 4
_e_id$ = 12						; size = 4
_binary_OFF_edge PROC					; COMDAT

; 401  : {

	push	ebp
	mov	ebp, esp

; 402  :   int i,k;
; 403  :   int e_color;
; 404  : 
; 405  :   if ( OFF_vertex_count > OFF_verts_alloc - 5 )

	mov	eax, DWORD PTR _OFF_verts_alloc
	mov	ecx, DWORD PTR _OFF_vertex_count
	lea	edx, DWORD PTR [eax-5]
	cmp	ecx, edx
	jle	SHORT $LN35@binary_OFF

; 406  :   { OFF_verts = (struct OFF_vertex_t*)temp_realloc((char*)OFF_verts,
; 407  :         2*OFF_verts_alloc*sizeof(struct OFF_vertex_t));

	push	407					; 00000197H
	shl	eax, 6
	push	OFFSET ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
	push	eax
	mov	eax, DWORD PTR _OFF_verts
	push	eax
	call	_kb_temp_realloc

; 408  :     OFF_verts_alloc *= 2;

	mov	ecx, DWORD PTR _OFF_verts_alloc
	lea	edx, DWORD PTR [ecx+ecx]
	mov	ecx, DWORD PTR _OFF_vertex_count
	add	esp, 16					; 00000010H
	mov	DWORD PTR _OFF_verts, eax
	mov	DWORD PTR _OFF_verts_alloc, edx
$LN35@binary_OFF:

; 409  :   }
; 410  :   if ( OFF_edge_count > OFF_edges_alloc - 5 )

	mov	eax, DWORD PTR _OFF_edges_alloc
	lea	edx, DWORD PTR [eax-5]
	cmp	DWORD PTR _OFF_edge_count, edx
	jle	SHORT $LN10@binary_OFF

; 411  :   { OFF_edges = (struct OFF_edge_t*)temp_realloc((char*)OFF_edges,
; 412  :         2*OFF_edges_alloc*sizeof(struct OFF_edge_t));

	push	412					; 0000019cH
	shl	eax, 5
	push	OFFSET ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
	push	eax
	mov	eax, DWORD PTR _OFF_edges
	push	eax
	call	_kb_temp_realloc

; 413  :     OFF_edges_alloc *= 2;

	mov	ecx, DWORD PTR _OFF_edges_alloc
	lea	edx, DWORD PTR [ecx+ecx]
	mov	ecx, DWORD PTR _OFF_vertex_count
	add	esp, 16					; 00000010H
	mov	DWORD PTR _OFF_edges, eax
	mov	DWORD PTR _OFF_edges_alloc, edx
$LN10@binary_OFF:

; 414  :   }
; 415  : 
; 416  :   e_color = g[0].ecolor;

	mov	eax, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR [eax+120]

; 417  :   if ( e_color == CLEAR ) return;

	cmp	edx, -1
	je	$LN12@binary_OFF

; 418  :   if ( (e_color < 0) || (e_color >= IRIS_COLOR_MAX) )

	test	edx, edx
	js	SHORT $LN7@binary_OFF
	cmp	edx, 16					; 00000010H
	jl	SHORT $LN8@binary_OFF
$LN7@binary_OFF:

; 419  :     e_color = DEFAULT_EDGE_COLOR;

	xor	edx, edx
$LN8@binary_OFF:

; 420  : 
; 421  :   for ( i = 0 ; i < EDGE_VERTS ; i++ )
; 422  :   { for ( k = 0 ; k < 3 ; k++ )
; 423  :       OFF_verts[OFF_vertex_count].x[k] = g[i].x[k];

	fld	QWORD PTR [eax]
	shl	ecx, 5
	push	esi
	mov	esi, DWORD PTR _OFF_verts
	fstp	QWORD PTR [ecx+esi]
	mov	ecx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [eax+8]
	mov	esi, DWORD PTR _OFF_verts
	shl	ecx, 5
	fstp	QWORD PTR [ecx+esi+8]
	mov	ecx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [eax+16]
	mov	esi, DWORD PTR _OFF_verts
	shl	ecx, 5
	fstp	QWORD PTR [ecx+esi+16]

; 424  :     OFF_edges[OFF_edge_count].v[i] = OFF_vertex_count;

	mov	ecx, DWORD PTR _OFF_edge_count
	mov	esi, DWORD PTR _OFF_vertex_count
	add	ecx, ecx
	push	edi
	mov	edi, DWORD PTR _OFF_edges
	mov	DWORD PTR [edi+ecx*8], esi

; 425  :     OFF_vertex_count++;

	mov	ecx, DWORD PTR _OFF_vertex_count
	mov	edi, DWORD PTR _OFF_verts
	mov	esi, 1
	add	ecx, esi
	mov	DWORD PTR _OFF_vertex_count, ecx
	fld	QWORD PTR [eax+144]
	shl	ecx, 5
	fstp	QWORD PTR [ecx+edi]
	mov	ecx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [eax+152]
	mov	edi, DWORD PTR _OFF_verts
	shl	ecx, 5
	fstp	QWORD PTR [ecx+edi+8]
	mov	ecx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [eax+160]
	mov	eax, DWORD PTR _OFF_verts
	shl	ecx, 5
	fstp	QWORD PTR [ecx+eax+16]
	mov	ecx, DWORD PTR _OFF_edge_count
	mov	eax, DWORD PTR _OFF_vertex_count
	mov	edi, DWORD PTR _OFF_edges
	add	ecx, ecx
	mov	DWORD PTR [edi+ecx*8+4], eax

; 426  :   }
; 427  :   OFF_edges[OFF_facet_count].color = e_color;

	mov	ecx, DWORD PTR _OFF_facet_count
	add	DWORD PTR _OFF_vertex_count, esi
	mov	eax, DWORD PTR _OFF_edges
	add	ecx, ecx
	mov	DWORD PTR [eax+ecx*8+8], edx

; 428  :   OFF_edge_count++;

	add	DWORD PTR _OFF_edge_count, esi
	pop	edi
	pop	esi
$LN12@binary_OFF:

; 429  : 
; 430  : } // end binary_OFF_edge()

	pop	ebp
	ret	0
_binary_OFF_edge ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_binary_OFF_facet
; Function compile flags: /Ogtp
;	COMDAT _binary_OFF_facet
_TEXT	SEGMENT
tv574 = -296						; size = 4
_i$ = -296						; size = 4
_ggdata$ = -292						; size = 288
__$ArrayPad$ = -4					; size = 4
_gdata$ = 8						; size = 4
_f_id$ = 12						; size = 4
_binary_OFF_facet PROC					; COMDAT

; 443  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 444  :   int i,k;
; 445  :   struct graphdata ggdata[2];
; 446  :  
; 447  :   if ( OFF_vertex_count > OFF_verts_alloc - 5 )

	mov	ecx, DWORD PTR _OFF_verts_alloc
	mov	eax, DWORD PTR _OFF_vertex_count
	lea	edx, DWORD PTR [ecx-5]
	cmp	eax, edx
	jle	SHORT $LN46@binary_OFF@2

; 448  :   { OFF_verts = (struct OFF_vertex_t*)temp_realloc((char*)OFF_verts,
; 449  :         2*OFF_verts_alloc*sizeof(struct OFF_vertex_t));

	mov	eax, DWORD PTR _OFF_verts
	push	449					; 000001c1H
	push	OFFSET ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
	shl	ecx, 6
	push	ecx
	push	eax
	call	_kb_temp_realloc

; 450  :     OFF_verts_alloc *= 2;

	mov	ecx, DWORD PTR _OFF_verts_alloc
	lea	edx, DWORD PTR [ecx+ecx]
	mov	DWORD PTR _OFF_verts, eax
	mov	eax, DWORD PTR _OFF_vertex_count
	add	esp, 16					; 00000010H
	mov	DWORD PTR _OFF_verts_alloc, edx
$LN46@binary_OFF@2:

; 451  :   }
; 452  :   if ( OFF_facet_count > OFF_facets_alloc - 5 )

	mov	ecx, DWORD PTR _OFF_facets_alloc
	lea	edx, DWORD PTR [ecx-5]
	cmp	DWORD PTR _OFF_facet_count, edx
	jle	SHORT $LN11@binary_OFF@2

; 453  :   { OFF_facets = (struct OFF_facet_t*)temp_realloc((char*)OFF_facets,
; 454  :         2*OFF_facets_alloc*sizeof(struct OFF_facet_t));

	lea	eax, DWORD PTR [ecx+ecx*4]
	mov	ecx, DWORD PTR _OFF_facets
	add	eax, eax
	push	454					; 000001c6H
	add	eax, eax
	push	OFFSET ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
	add	eax, eax
	push	eax
	push	ecx
	call	_kb_temp_realloc

; 455  :     OFF_facets_alloc *= 2;

	mov	edx, DWORD PTR _OFF_facets_alloc
	mov	DWORD PTR _OFF_facets, eax
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR _OFF_facets_alloc, eax
	mov	eax, DWORD PTR _OFF_vertex_count
	add	esp, 16					; 00000010H
$LN11@binary_OFF@2:

; 456  :   }
; 457  : 
; 458  :   for ( i = 0 ; i < FACET_VERTS ; i++ )
; 459  :   { for ( k = 0 ; k < 3 ; k++ )
; 460  :       OFF_verts[OFF_vertex_count].x[k] = gdata[i].x[k];

	mov	ecx, DWORD PTR _OFF_verts
	shl	eax, 5
	push	ebx
	mov	ebx, DWORD PTR _gdata$[ebp]
	fld	QWORD PTR [ebx]
	push	esi
	fstp	QWORD PTR [eax+ecx]
	mov	edx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [ebx+8]
	mov	eax, DWORD PTR _OFF_verts
	shl	edx, 5
	fstp	QWORD PTR [edx+eax+8]
	mov	ecx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [ebx+16]
	mov	edx, DWORD PTR _OFF_verts
	shl	ecx, 5
	fstp	QWORD PTR [ecx+edx+16]

; 461  :     OFF_facets[OFF_facet_count].v[i] = OFF_vertex_count;

	mov	eax, DWORD PTR _OFF_facet_count
	mov	ecx, DWORD PTR _OFF_vertex_count
	mov	edx, DWORD PTR _OFF_facets
	lea	eax, DWORD PTR [eax+eax*4]
	mov	DWORD PTR [edx+eax*4], ecx

; 462  :     OFF_vertex_count++;

	mov	eax, DWORD PTR _OFF_vertex_count
	mov	ecx, DWORD PTR _OFF_verts
	inc	eax
	mov	DWORD PTR _OFF_vertex_count, eax
	fld	QWORD PTR [ebx+144]
	shl	eax, 5
	fstp	QWORD PTR [eax+ecx]
	mov	edx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [ebx+152]
	mov	eax, DWORD PTR _OFF_verts
	shl	edx, 5
	fstp	QWORD PTR [edx+eax+8]
	mov	ecx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [ebx+160]
	mov	edx, DWORD PTR _OFF_verts
	shl	ecx, 5
	fstp	QWORD PTR [ecx+edx+16]
	mov	eax, DWORD PTR _OFF_facet_count
	mov	ecx, DWORD PTR _OFF_vertex_count
	mov	edx, DWORD PTR _OFF_facets
	lea	eax, DWORD PTR [eax+eax*4]
	mov	DWORD PTR [edx+eax*4+4], ecx
	mov	eax, DWORD PTR _OFF_vertex_count
	mov	ecx, DWORD PTR _OFF_verts
	inc	eax
	mov	DWORD PTR _OFF_vertex_count, eax
	fld	QWORD PTR [ebx+288]
	shl	eax, 5
	fstp	QWORD PTR [eax+ecx]
	mov	edx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [ebx+296]
	mov	eax, DWORD PTR _OFF_verts
	shl	edx, 5
	fstp	QWORD PTR [edx+eax+8]
	mov	ecx, DWORD PTR _OFF_vertex_count
	fld	QWORD PTR [ebx+304]
	mov	edx, DWORD PTR _OFF_verts
	shl	ecx, 5
	fstp	QWORD PTR [ecx+edx+16]
	mov	eax, DWORD PTR _OFF_facet_count
	mov	ecx, DWORD PTR _OFF_vertex_count
	mov	edx, DWORD PTR _OFF_facets
	lea	eax, DWORD PTR [eax+eax*4]
	mov	DWORD PTR [edx+eax*4+8], ecx
	inc	DWORD PTR _OFF_vertex_count

; 463  :   }
; 464  :   OFF_facets[OFF_facet_count].color = gdata[0].color;

	mov	eax, DWORD PTR _OFF_facet_count
	mov	ecx, DWORD PTR [ebx+104]
	mov	edx, DWORD PTR _OFF_facets
	lea	eax, DWORD PTR [eax+eax*4]
	mov	DWORD PTR [edx+eax*4+12], ecx

; 465  :   OFF_facets[OFF_facet_count].opacity = (float)gdata[0].opacity;

	fld	QWORD PTR [ebx+112]
	mov	eax, DWORD PTR _OFF_facet_count
	fstp	DWORD PTR tv574[ebp]
	fld	DWORD PTR tv574[ebp]
	mov	ecx, DWORD PTR _OFF_facets
	lea	eax, DWORD PTR [eax+eax*4]
	fstp	DWORD PTR [ecx+eax*4+16]

; 466  :   OFF_facet_count++;

	inc	DWORD PTR _OFF_facet_count
	push	edi

; 467  : 
; 468  :   /* do edges */
; 469  :   for ( i = 0 ; i < FACET_EDGES ; i++ )

	xor	eax, eax
	mov	DWORD PTR _i$[ebp], eax
$LL4@binary_OFF@2:

; 470  :   { if ( ((gdata[i].etype&EBITS)|REGULAR_EDGE) == REGULAR_EDGE ) continue;

	lea	edx, DWORD PTR [eax+eax*8]
	shl	edx, 4
	mov	cx, WORD PTR [edx+ebx+124]
	add	edx, ebx
	mov	esi, 766				; 000002feH
	and	cx, si
	or	cx, 1
	cmp	cx, 1
	je	SHORT $LN3@binary_OFF@2

; 471  :     ggdata[0] = gdata[i];

	mov	esi, edx

; 472  :     ggdata[0].color = gdata[i].ecolor;

	mov	edx, DWORD PTR [edx+120]
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _ggdata$[ebp]
	rep movsd
	mov	DWORD PTR _ggdata$[ebp+104], edx

; 473  :     ggdata[1] = gdata[i==2 ? 0 : i+1];

	cmp	eax, 2
	jne	SHORT $LN15@binary_OFF@2
	xor	eax, eax
	jmp	SHORT $LN16@binary_OFF@2
$LN15@binary_OFF@2:
	inc	eax
$LN16@binary_OFF@2:
	lea	esi, DWORD PTR [eax+eax*8]
	shl	esi, 4

; 474  :     binary_OFF_edge(ggdata,NULLID);

	lea	eax, DWORD PTR _ggdata$[ebp]
	push	0
	add	esi, ebx
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _ggdata$[ebp+144]
	push	eax
	rep movsd
	call	_binary_OFF_edge
	mov	eax, DWORD PTR _i$[ebp]
	add	esp, 8
$LN3@binary_OFF@2:

; 467  : 
; 468  :   /* do edges */
; 469  :   for ( i = 0 ; i < FACET_EDGES ; i++ )

	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, 3
	jl	SHORT $LL4@binary_OFF@2

; 475  :   }
; 476  : }  // end binary_OFF_facet()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_binary_OFF_facet ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@IBMGINLC@OFF?5BINARY?5?$CIby?5Surface?5Evolver?0?5@ ; `string'
PUBLIC	??_C@_0DG@ECLANOFJ@OFF?5BINARY?5OPACITY?5?$CIby?5Surface?5E@ ; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_0CO@KCLFPKMG@Enter?5file?5name?5?$CIsupply?5your?5own@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_binary_OFF_end
EXTRN	_fwrite:PROC
EXTRN	_opacity_attr:DWORD
;	COMDAT ??_C@_0CO@IBMGINLC@OFF?5BINARY?5?$CIby?5Surface?5Evolver?0?5@
CONST	SEGMENT
??_C@_0CO@IBMGINLC@OFF?5BINARY?5?$CIby?5Surface?5Evolver?0?5@ DB 'OFF BIN'
	DB	'ARY (by Surface Evolver, for evmovie)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@ECLANOFJ@OFF?5BINARY?5OPACITY?5?$CIby?5Surface?5E@
CONST	SEGMENT
??_C@_0DG@ECLANOFJ@OFF?5BINARY?5OPACITY?5?$CIby?5Surface?5E@ DB 'OFF BINA'
	DB	'RY OPACITY (by Surface Evolver, for evmovie)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KCLFPKMG@Enter?5file?5name?5?$CIsupply?5your?5own@
CONST	SEGMENT
??_C@_0CO@KCLFPKMG@Enter?5file?5name?5?$CIsupply?5your?5own@ DB 'Enter fi'
	DB	'le name (supply your own extension): ', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _binary_OFF_end
_TEXT	SEGMENT
tv1069 = -2072						; size = 4
tv653 = -2068						; size = 4
_i$ = -2064						; size = 4
_tmp$89314 = -2060					; size = 4
_keep$ = -2060						; size = 4
_translate$ = -2060					; size = 4
tv1343 = -2056						; size = 4
tv1066 = -2056						; size = 4
_data$89377 = -2052					; size = 20
_data$89387 = -2032					; size = 16
_xx$89368 = -2016					; size = 12
_file_name$89341 = -2004				; size = 2000
__$ArrayPad$ = -4					; size = 4
_binary_OFF_end PROC					; COMDAT

; 486  : { int i,j,k,keep;

	push	ebp
	mov	ebp, esp
	sub	esp, 2072				; 00000818H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 487  :   int *translate;
; 488  : 
; 489  :   /* unify vertices */
; 490  :   for ( i = 0 ; i < OFF_vertex_count ; i++ )

	mov	ecx, DWORD PTR _OFF_vertex_count
	push	ebx
	push	esi
	push	edi
	xor	edi, edi
	xor	eax, eax
	cmp	ecx, edi
	jle	SHORT $LN60@binary_OFF@3
	xor	edx, edx
	npad	10
$LL62@binary_OFF@3:

; 491  :     OFF_verts[i].orig = i;

	mov	ecx, DWORD PTR _OFF_verts
	mov	DWORD PTR [edx+ecx+24], eax
	mov	ecx, DWORD PTR _OFF_vertex_count
	inc	eax
	add	edx, 32					; 00000020H
	cmp	eax, ecx
	jl	SHORT $LL62@binary_OFF@3
$LN60@binary_OFF@3:

; 492  :   qsort((char*)OFF_verts,OFF_vertex_count,sizeof(struct OFF_vertex_t), 
; 493  :       FCAST OFF_comp);

	mov	edx, DWORD PTR _OFF_verts
	push	OFFSET _OFF_comp
	push	32					; 00000020H
	push	ecx
	push	edx
	call	_qsort

; 494  :   translate = (int*)temp_calloc(OFF_vertex_count,sizeof(int));

	mov	eax, DWORD PTR _OFF_vertex_count
	push	494					; 000001eeH
	push	OFFSET ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
	push	4
	push	eax
	call	_kb_temp_calloc

; 495  :   translate[OFF_verts[0].orig] = 0;

	mov	ecx, DWORD PTR _OFF_verts
	mov	edx, DWORD PTR [ecx+24]
	mov	ebx, eax

; 496  :   for ( i = 1, keep = 0 ; i < OFF_vertex_count ; i++ )

	mov	eax, 1
	add	esp, 32					; 00000020H
	mov	DWORD PTR [ebx+edx*4], edi
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _OFF_vertex_count, eax
	jle	$LN57@binary_OFF@3
	mov	DWORD PTR tv653[ebp], edi
	mov	DWORD PTR tv1066[ebp], 32		; 00000020H
	npad	5
$LL117@binary_OFF@3:

; 497  :   { if ( OFF_comp(OFF_verts+i,OFF_verts+keep) != 0 )

	mov	esi, DWORD PTR _OFF_verts
	mov	ecx, DWORD PTR tv653[ebp]
	mov	eax, DWORD PTR tv1066[ebp]
	add	ecx, esi
	add	eax, esi
	push	ecx
	push	eax
	mov	DWORD PTR tv1069[ebp], eax
	call	_OFF_comp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN118@binary_OFF@3

; 498  :       OFF_verts[++keep] = OFF_verts[i];

	inc	edi
	mov	eax, edi
	mov	DWORD PTR _keep$[ebp], edi
	shl	eax, 5
	lea	edi, DWORD PTR [eax+esi]
	mov	esi, DWORD PTR tv1069[ebp]
	mov	ecx, 8
	rep movsd
	mov	esi, DWORD PTR _OFF_verts
	mov	edi, DWORD PTR _keep$[ebp]
	mov	DWORD PTR tv653[ebp], eax
$LN118@binary_OFF@3:

; 499  :     translate[OFF_verts[i].orig] = keep;

	mov	ecx, DWORD PTR tv1066[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [ecx+esi+24]
	inc	eax
	add	ecx, 32					; 00000020H
	mov	DWORD PTR [ebx+edx*4], edi
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR tv1066[ebp], ecx
	cmp	eax, DWORD PTR _OFF_vertex_count
	jl	$LL117@binary_OFF@3
$LN57@binary_OFF@3:

; 502  : 
; 503  :   /* renumber edge and facet vertices */
; 504  :   for ( i = 0 ; i < OFF_edge_count ; i++ )

	mov	esi, DWORD PTR _OFF_edge_count
	mov	eax, DWORD PTR _OFF_edges
	inc	edi
	mov	DWORD PTR _OFF_vertex_count, edi
	xor	edi, edi
	test	esi, esi
	jle	SHORT $LN53@binary_OFF@3

; 500  :   }
; 501  :   OFF_vertex_count = keep+1;

	xor	ecx, ecx
	xor	edx, edx
$LL115@binary_OFF@3:

; 505  :   { for ( j = 0 ; j < EDGE_VERTS ; j++ )
; 506  :       OFF_edges[i].v[j] = translate[OFF_edges[i].v[j]];

	mov	esi, DWORD PTR [edx+eax]
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [edx+eax], esi
	mov	eax, DWORD PTR _OFF_edges
	mov	esi, DWORD PTR [edx+eax+4]
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [edx+eax+4], esi

; 507  :     /* get vertices in canonical order */
; 508  :     if ( OFF_edges[i].v[0] > OFF_edges[i].v[1] )

	mov	eax, DWORD PTR _OFF_edges
	mov	esi, DWORD PTR [ecx+eax]
	cmp	esi, DWORD PTR [ecx+eax+4]
	jle	SHORT $LN54@binary_OFF@3

; 509  :     { int tmp = OFF_edges[i].v[0];

	mov	DWORD PTR _tmp$89314[ebp], esi

; 510  :       OFF_edges[i].v[0] = OFF_edges[i].v[1];

	mov	esi, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR [ecx+eax], esi

; 511  :       OFF_edges[i].v[1] = tmp;

	mov	eax, DWORD PTR _OFF_edges
	mov	esi, DWORD PTR _tmp$89314[ebp]
	mov	DWORD PTR [ecx+eax+4], esi
	mov	eax, DWORD PTR _OFF_edges
$LN54@binary_OFF@3:

; 502  : 
; 503  :   /* renumber edge and facet vertices */
; 504  :   for ( i = 0 ; i < OFF_edge_count ; i++ )

	mov	esi, DWORD PTR _OFF_edge_count
	inc	edi
	add	edx, 16					; 00000010H
	add	ecx, 16					; 00000010H
	cmp	edi, esi
	jl	SHORT $LL115@binary_OFF@3
$LN53@binary_OFF@3:

; 512  :     }
; 513  :   }
; 514  :   for ( i = 0 ; i < OFF_facet_count ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _OFF_facet_count, ecx
	jle	SHORT $LN46@binary_OFF@3
	xor	eax, eax
	npad	8
$LL48@binary_OFF@3:

; 515  :   { for ( j = 0 ; j < FACET_VERTS ; j++ )
; 516  :       OFF_facets[i].v[j] = translate[OFF_facets[i].v[j]];

	mov	edx, DWORD PTR _OFF_facets
	mov	esi, DWORD PTR [eax+edx]
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [eax+edx], esi
	mov	edx, DWORD PTR _OFF_facets
	mov	esi, DWORD PTR [eax+edx+4]
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [eax+edx+4], esi
	mov	edx, DWORD PTR _OFF_facets
	mov	esi, DWORD PTR [eax+edx+8]
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [eax+edx+8], esi
	inc	ecx
	add	eax, 20					; 00000014H
	cmp	ecx, DWORD PTR _OFF_facet_count
	jl	SHORT $LL48@binary_OFF@3

; 512  :     }
; 513  :   }
; 514  :   for ( i = 0 ; i < OFF_facet_count ; i++ )

	mov	esi, DWORD PTR _OFF_edge_count
	mov	eax, DWORD PTR _OFF_edges
$LN46@binary_OFF@3:

; 517  :   }
; 518  : 
; 519  :   /* unify edges */
; 520  :   /* sort edges */
; 521  :   for ( i = 0 ; i < OFF_edge_count ; i++ )

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN40@binary_OFF@3
	xor	edx, edx
$LL113@binary_OFF@3:

; 522  :     OFF_edges[i].orig = i;

	mov	DWORD PTR [edx+eax+12], ecx
	mov	esi, DWORD PTR _OFF_edge_count
	mov	eax, DWORD PTR _OFF_edges
	inc	ecx
	add	edx, 16					; 00000010H
	cmp	ecx, esi
	jl	SHORT $LL113@binary_OFF@3
$LN40@binary_OFF@3:

; 523  :   qsort((char*)OFF_edges,OFF_edge_count,sizeof(struct OFF_edge_t), 
; 524  :       FCAST OFF_edge_comp);

	push	OFFSET _OFF_edge_comp
	push	16					; 00000010H
	push	esi
	push	eax
	call	_qsort

; 525  :   translate = (int*)temp_realloc((char*)translate,OFF_edge_count*sizeof(int));

	mov	ecx, DWORD PTR _OFF_edge_count
	push	525					; 0000020dH
	push	OFFSET ??_C@_0L@CMKOGDFA@FILGRAPH?4C?$AA@
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	push	ebx
	call	_kb_temp_realloc
	mov	DWORD PTR _translate$[ebp], eax

; 526  :   for ( i = 1, keep = 0 ; i < OFF_edge_count ; i++ )

	mov	eax, 1
	add	esp, 32					; 00000020H
	xor	ebx, ebx
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _OFF_edge_count, eax
	jle	SHORT $LN37@binary_OFF@3
	xor	edi, edi
	mov	DWORD PTR tv1343[ebp], 16		; 00000010H
	npad	3
$LL119@binary_OFF@3:

; 527  :   { if ( OFF_edge_comp(OFF_edges+i,OFF_edges+keep) != 0 )

	mov	eax, DWORD PTR _OFF_edges
	mov	esi, DWORD PTR tv1343[ebp]
	lea	edx, DWORD PTR [edi+eax]
	add	esi, eax
	push	edx
	push	esi
	call	_OFF_edge_comp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@binary_OFF@3

; 528  :       OFF_edges[++keep] = OFF_edges[i];

	mov	eax, DWORD PTR _OFF_edges
	mov	ecx, DWORD PTR [esi]
	inc	ebx
	mov	edi, ebx
	shl	edi, 4
	add	eax, edi
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], edx
$LN38@binary_OFF@3:

; 526  :   for ( i = 1, keep = 0 ; i < OFF_edge_count ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv1343[ebp], 16		; 00000010H
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _OFF_edge_count
	jl	SHORT $LL119@binary_OFF@3
$LN37@binary_OFF@3:

; 529  :   }
; 530  :   OFF_edge_count = keep+1;
; 531  : 
; 532  :   if ( binary_off_filename == NULL ) /* prompt for file name */

	mov	eax, DWORD PTR _binary_off_filename
	inc	ebx
	xor	edi, edi
	mov	DWORD PTR _OFF_edge_count, ebx
	cmp	eax, edi
	jne	$LN35@binary_OFF@3
$LL34@binary_OFF@3:

; 533  :   for (;;)
; 534  :   { char file_name[2000];
; 535  :     prompt("Enter file name (supply your own extension): ",file_name,sizeof(file_name));

	push	2000					; 000007d0H
	lea	eax, DWORD PTR _file_name$89341[ebp]
	push	eax
	push	OFFSET ??_C@_0CO@KCLFPKMG@Enter?5file?5name?5?$CIsupply?5your?5own@
	call	_prompt
	add	esp, 12					; 0000000cH

; 536  :     if ( file_name[0] == 0 )

	cmp	BYTE PTR _file_name$89341[ebp], 0
	jne	SHORT $LN121@binary_OFF@3

; 537  :     { kb_error(1912,"File aborted.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0P@MDBHDFDD@File?5aborted?4?6?$AA@
	push	1912					; 00000778H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN121@binary_OFF@3:

; 538  :     }
; 539  : 
; 540  :     fd = fopen(file_name,"wb");

	lea	ecx, DWORD PTR _file_name$89341[ebp]
	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	push	ecx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fd, eax

; 541  :     if ( fd == NULL )

	cmp	eax, edi
	jne	$LN26@binary_OFF@3

; 542  :     { 
; 543  : #ifdef __L_EVOLVER__
; 544  : 		   if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, edi
	jne	SHORT $LN29@binary_OFF@3
	cmp	DWORD PTR _l_evolver_mode, edi
	jne	SHORT $LN29@binary_OFF@3

; 546  : 		   else
; 547  : 			   perror(file_name);

	lea	edx, DWORD PTR _file_name$89341[ebp]
	push	edx
	call	_perror
	jmp	SHORT $LN122@binary_OFF@3
$LN29@binary_OFF@3:

; 545  : 			   erroutstring(file_name);

	lea	eax, DWORD PTR _file_name$89341[ebp]
	push	eax
	call	_erroutstring
$LN122@binary_OFF@3:
	add	esp, 4

; 548  : #else
; 549  : 			   perror(file_name);
; 550  : #endif	
; 551  :       kb_error(1907,"",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	1907					; 00000773H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 552  :     }
; 553  :     else break;
; 554  :   }

	jmp	$LL34@binary_OFF@3
$LN35@binary_OFF@3:

; 555  :   else /* use supplied name */
; 556  :   {
; 557  :     fd = fopen(binary_off_filename,"wb");

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fd, eax

; 558  :     if ( fd == NULL )

	cmp	eax, edi
	jne	SHORT $LN120@binary_OFF@3

; 559  :     { 
; 560  : #ifdef __L_EVOLVER__
; 561  : 		if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, edi
	jne	SHORT $LN23@binary_OFF@3
	cmp	DWORD PTR _l_evolver_mode, edi
	jne	SHORT $LN23@binary_OFF@3

; 563  : 		else
; 564  : 		  perror(binary_off_filename);

	mov	ecx, DWORD PTR _binary_off_filename
	push	ecx
	call	_perror
	jmp	SHORT $LN123@binary_OFF@3
$LN23@binary_OFF@3:

; 562  : 		  erroutstring(binary_off_filename);

	mov	edx, DWORD PTR _binary_off_filename
	push	edx
	call	_erroutstring
$LN123@binary_OFF@3:
	add	esp, 4

; 565  : #else
; 566  : 		perror(binary_off_filename);
; 567  : #endif
; 568  :       kb_error(1034,"",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	1034					; 0000040aH
	call	_kb_error
	mov	eax, DWORD PTR _fd
	add	esp, 12					; 0000000cH
$LN120@binary_OFF@3:

; 569  :     }
; 570  :     binary_off_filename = NULL; /* for next time around */

	mov	DWORD PTR _binary_off_filename, edi
$LN26@binary_OFF@3:

; 571  :   }
; 572  :   
; 573  :   #ifdef ASCII_OFF
; 574  :   /* ASCII version, with color indexes for edges and facets */
; 575  :   fprintf(fd,"COFF\n%d %d %d\n",OFF_vertex_count,OFF_facet_count,OFF_edge_count);
; 576  :   for ( i = 0 ; i < OFF_vertex_count ; i++ )
; 577  :     fprintf(fd,"%f %f %f\n",OFF_verts[i].x[0],OFF_verts[i].x[1],
; 578  :         OFF_verts[i].x[2]);
; 579  :   for ( i = 0 ; i < OFF_facet_count ; i++ )
; 580  :     fprintf(fd,"3 %d %d %d   %d\n",OFF_facets[i].v[0],OFF_facets[i].v[1],
; 581  :         OFF_facets[i].v[2],OFF_facets[i].color);
; 582  :   for ( i = 0 ; i < OFF_edge_count ; i++ )
; 583  :     fprintf(fd,"2 %d %d   %d\n",OFF_edges[i].v[0],OFF_edges[i].v[1],
; 584  :         OFF_edges[i].color);
; 585  :   #else
; 586  :   
; 587  :   /* Binary version */
; 588  :   if ( opacity_attr )

	cmp	DWORD PTR _opacity_attr, edi
	je	SHORT $LN21@binary_OFF@3

; 589  :       fprintf(fd,"OFF BINARY OPACITY (by Surface Evolver, for evmovie)\n");

	push	OFFSET ??_C@_0DG@ECLANOFJ@OFF?5BINARY?5OPACITY?5?$CIby?5Surface?5E@

; 590  :   else 

	jmp	SHORT $LN124@binary_OFF@3
$LN21@binary_OFF@3:

; 591  :       fprintf(fd,"OFF BINARY (by Surface Evolver, for evmovie)\n");

	push	OFFSET ??_C@_0CO@IBMGINLC@OFF?5BINARY?5?$CIby?5Surface?5Evolver?0?5@
$LN124@binary_OFF@3:
	push	eax
	call	_fprintf

; 592  :   fwrite(&OFF_vertex_count,sizeof(int),1,fd);

	mov	eax, DWORD PTR _fd
	add	esp, 8
	push	eax
	push	1
	push	4
	push	OFFSET _OFF_vertex_count
	call	_fwrite

; 593  :   fwrite(&OFF_facet_count,sizeof(int),1,fd);

	mov	ecx, DWORD PTR _fd
	push	ecx
	push	1
	push	4
	push	OFFSET _OFF_facet_count
	call	_fwrite

; 594  :   fwrite(&OFF_edge_count,sizeof(int),1,fd);

	mov	edx, DWORD PTR _fd
	push	edx
	push	1
	push	4
	push	OFFSET _OFF_edge_count
	call	_fwrite
	add	esp, 48					; 00000030H

; 595  :   for ( i = 0 ; i < OFF_vertex_count ; i++ )

	cmp	DWORD PTR _OFF_vertex_count, edi
	jle	SHORT $LN17@binary_OFF@3

; 592  :   fwrite(&OFF_vertex_count,sizeof(int),1,fd);

	xor	esi, esi
	npad	5
$LL19@binary_OFF@3:

; 596  :   { float xx[3];
; 597  :     for ( k = 0 ; k < 3 ; k++ )
; 598  :       xx[k] = (float)(OFF_verts[i].x[k]/overall_size);

	mov	eax, DWORD PTR _OFF_verts
	fld	QWORD PTR [esi+eax]

; 599  :     fwrite(xx,sizeof(float),3,fd);

	lea	ecx, DWORD PTR _xx$89368[ebp]
	fld	QWORD PTR _overall_size
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _xx$89368[ebp]
	fld	QWORD PTR [esi+eax+8]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _xx$89368[ebp+4]
	fdivr	QWORD PTR [esi+eax+16]
	mov	eax, DWORD PTR _fd
	push	eax
	push	3
	push	4
	push	ecx
	fstp	DWORD PTR _xx$89368[ebp+8]
	call	_fwrite
	inc	edi
	add	esp, 16					; 00000010H
	add	esi, 32					; 00000020H
	cmp	edi, DWORD PTR _OFF_vertex_count
	jl	SHORT $LL19@binary_OFF@3
$LN17@binary_OFF@3:

; 600  :   }
; 601  :   for ( i = 0 ; i < OFF_facet_count ; i++ )

	xor	ebx, ebx
	cmp	DWORD PTR _OFF_facet_count, ebx
	jle	$LN11@binary_OFF@3
	xor	edi, edi
	xor	esi, esi
	npad	11
$LL13@binary_OFF@3:

; 602  :   { int data[5];
; 603  : 
; 604  :     data[0] = 3;
; 605  :     for ( k = 0 ; k < 3 ; k++ )
; 606  :       data[k+1] = OFF_facets[i].v[k];

	mov	eax, DWORD PTR _OFF_facets
	mov	DWORD PTR _data$89377[ebp], 3
	mov	edx, DWORD PTR [esi+eax]
	mov	DWORD PTR _data$89377[ebp+4], edx
	mov	ecx, DWORD PTR [esi+eax+4]
	mov	DWORD PTR _data$89377[ebp+8], ecx
	mov	edx, DWORD PTR [esi+eax+8]

; 607  :     data[4] = OFF_facets[i].color;
; 608  :     fwrite(data,sizeof(int),5,fd);

	mov	ecx, DWORD PTR _fd
	push	ecx
	mov	DWORD PTR _data$89377[ebp+12], edx
	mov	eax, DWORD PTR [edi+eax+12]
	push	5
	lea	edx, DWORD PTR _data$89377[ebp]
	push	4
	push	edx
	mov	DWORD PTR _data$89377[ebp+16], eax
	call	_fwrite
	add	esp, 16					; 00000010H

; 609  :     if ( opacity_attr )

	cmp	DWORD PTR _opacity_attr, 0
	je	SHORT $LN12@binary_OFF@3

; 610  :         fwrite(&OFF_facets[i].opacity,sizeof(float),1,fd);

	mov	eax, DWORD PTR _fd
	mov	ecx, DWORD PTR _OFF_facets
	push	eax
	push	1
	lea	edx, DWORD PTR [edi+ecx+16]
	push	4
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
$LN12@binary_OFF@3:

; 600  :   }
; 601  :   for ( i = 0 ; i < OFF_facet_count ; i++ )

	inc	ebx
	add	esi, 20					; 00000014H
	add	edi, 20					; 00000014H
	cmp	ebx, DWORD PTR _OFF_facet_count
	jl	$LL13@binary_OFF@3
$LN11@binary_OFF@3:

; 611  :   }
; 612  :   for ( i = 0 ; i < OFF_edge_count ; i++ )

	xor	ebx, ebx
	cmp	DWORD PTR _OFF_edge_count, ebx
	jle	SHORT $LN4@binary_OFF@3
	xor	edi, edi
	xor	esi, esi
	npad	9
$LL6@binary_OFF@3:

; 613  :   { int data[4];
; 614  :     data[0] = 2;
; 615  :     for ( k = 0 ; k < 2 ; k++ )
; 616  :       data[k+1] = OFF_edges[i].v[k];

	mov	eax, DWORD PTR _OFF_edges
	mov	DWORD PTR _data$89387[ebp], 2
	mov	ecx, DWORD PTR [esi+eax]
	mov	DWORD PTR _data$89387[ebp+4], ecx
	mov	edx, DWORD PTR [esi+eax+4]

; 617  :     data[3] = OFF_edges[i].color;
; 618  :     fwrite(data,sizeof(int),4,fd);

	mov	ecx, DWORD PTR _fd
	push	ecx
	mov	DWORD PTR _data$89387[ebp+8], edx
	mov	eax, DWORD PTR [edi+eax+8]
	push	4
	lea	edx, DWORD PTR _data$89387[ebp]
	push	4
	push	edx
	mov	DWORD PTR _data$89387[ebp+12], eax
	call	_fwrite
	inc	ebx
	add	esp, 16					; 00000010H
	add	esi, 16					; 00000010H
	add	edi, 16					; 00000010H
	cmp	ebx, DWORD PTR _OFF_edge_count
	jl	SHORT $LL6@binary_OFF@3
$LN4@binary_OFF@3:

; 619  :   }
; 620  :  
; 621  :   #endif
; 622  :   
; 623  :   fclose(fd);

	mov	eax, DWORD PTR _fd
	push	eax
	call	_fclose

; 624  :   temp_free((char*)OFF_verts);

	mov	ecx, DWORD PTR _OFF_verts
	push	ecx
	call	_temp_free

; 625  :   temp_free((char*)OFF_edges);

	mov	edx, DWORD PTR _OFF_edges
	push	edx
	call	_temp_free

; 626  :   temp_free((char*)OFF_facets);

	mov	eax, DWORD PTR _OFF_facets
	push	eax
	call	_temp_free

; 627  :   temp_free((char*)translate);

	mov	ecx, DWORD PTR _translate$[ebp]
	push	ecx
	call	_temp_free

; 628  : 
; 629  : } // end binary_OFF_end()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_binary_OFF_end ENDP
_TEXT	ENDS
END
