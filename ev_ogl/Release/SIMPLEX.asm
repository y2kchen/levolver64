; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\SIMPLEX.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_slist3	DD	00H
	DD	04H
	DD	05H
	DD	06H
	ORG $+12
	DD	01H
	DD	04H
	DD	08H
	DD	07H
	ORG $+12
	DD	02H
	DD	05H
	DD	07H
	DD	09H
	ORG $+12
	DD	03H
	DD	06H
	DD	09H
	DD	08H
	ORG $+12
	DD	04H
	DD	05H
	DD	08H
	DD	07H
	ORG $+12
	DD	04H
	DD	08H
	DD	05H
	DD	06H
	ORG $+12
	DD	06H
	DD	08H
	DD	05H
	DD	09H
	ORG $+12
	DD	05H
	DD	08H
	DD	07H
	DD	09H
	ORG $+12
_slist2	DD	00H
	DD	03H
	DD	04H
	ORG $+16
	DD	01H
	DD	05H
	DD	03H
	ORG $+16
	DD	02H
	DD	04H
	DD	05H
	ORG $+16
	DD	03H
	DD	05H
	DD	04H
	ORG $+16
_slist1	DD	00H
	DD	02H
	ORG $+20
	DD	02H
	DD	01H
	ORG $+20
_sort_vector DQ	03ff6db704ce39f79r		; 1.42857
	DQ	03fd87f9f80305476r		; 0.382789
	DQ	0bffe928e30466099r		; -1.91078
	DQ	03fe5e07946a69c32r		; 0.683652
	DQ	03fce93f133fbd323r		; 0.23889
	DQ	0bfec74eff8540706r		; -0.889275
	DQ	03fc9819a7121c88fr		; 0.199268
	DQ	04004cabb34739cd9r		; 2.59899
	DQ	03fe993dd9430e207r		; 0.7993
	ORG $+8
_DATA	ENDS
PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_extra
; Function compile flags: /Ogtp
;	COMDAT _get_extra
_TEXT	SEGMENT
_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_extra PROC						; COMDAT

; 348  : { int type = id_type(id);

	push	ebp
	mov	ebp, esp

; 349  : 
; 350  :   return ( (char*)elptr(id) + EXTRAS(type)[n].offset);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	shr	eax, 29					; 0000001dH
	imul	esi, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, esi
	add	eax, DWORD PTR [edi+ecx+64]
	pop	edi
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_get_extra ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_calc_simplex_energy
EXTRN	_binary_tree_add:PROC
EXTRN	_determinant:PROC
EXTRN	_dot:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@0000000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\simplex.c
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _calc_simplex_energy
_TEXT	SEGMENT
_mat$ = -616						; size = 24
_x$ = -616						; size = 24
tv257 = -592						; size = 4
tv581 = -588						; size = 4
tv598 = -584						; size = 4
tv525 = -584						; size = 4
_matspace$ = -580					; size = 288
_side$ = -292						; size = 288
__$ArrayPad$ = -4					; size = 4
_f_id$ = 8						; size = 4
_mode$ = 12						; size = 4
_calc_simplex_energy PROC				; COMDAT

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 616				; 00000268H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _f_id$[ebp]

; 30   :   vertex_id *v = get_facet_vertices(f_id);

	mov	ecx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	push	ebx
	push	esi
	lea	esi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _web+236
	mov	edx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR _dymem
	add	edx, DWORD PTR [ecx+eax+304]
	push	edi

; 31   :   REAL side[MAXCOORD][MAXCOORD];
; 32   :   REAL *x[MAXCOORD];
; 33   :   REAL matspace[MAXCOORD][MAXCOORD];
; 34   :   REAL *mat[MAXCOORD];
; 35   :   REAL energy;
; 36   :   REAL det;
; 37   :   int k,j;
; 38   : 
; 39   :   x[0] = get_coord(v[0]);

	mov	ecx, DWORD PTR [edx]
	mov	edi, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _web+104
	add	ecx, DWORD PTR [edi+eax+64]

; 40   :   for ( k = 1 ; k <= web.dimension ; k++ )

	mov	edi, 1
	mov	DWORD PTR _x$[ebp], ecx
	mov	ecx, DWORD PTR _web+620
	mov	DWORD PTR tv257[ebp], esi
	cmp	ecx, edi
	jl	SHORT $LN27@calc_simpl

; 41   :   { x[k] = get_coord(v[k]);

	lea	esi, DWORD PTR _side$[ebp]
	mov	DWORD PTR tv525[ebp], esi
	npad	1
$LL29@calc_simpl:
	mov	esi, DWORD PTR [edx+edi*4]
	mov	ebx, DWORD PTR _web+12
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	ebx, DWORD PTR _web+104
	mov	ebx, DWORD PTR [ebx+eax+64]
	add	esi, ebx

; 42   :     for ( j = 0 ; j < SDIM ; j++ )

	cmp	DWORD PTR _web+616, 0
	mov	DWORD PTR _x$[ebp+edi*4], esi
	jle	SHORT $LN14@calc_simpl

; 41   :   { x[k] = get_coord(v[k]);

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR tv525[ebp]
	mov	ebx, DWORD PTR _web+616

; 42   :     for ( j = 0 ; j < SDIM ; j++ )

	sub	esi, eax
$LL12@calc_simpl:

; 43   :        side[k-1][j] = x[k][j] - x[0][j];

	fld	QWORD PTR [esi+eax]
	add	eax, 8
	fsub	QWORD PTR [eax-8]
	add	ecx, 8
	dec	ebx
	fstp	QWORD PTR [ecx-8]
	jne	SHORT $LL12@calc_simpl

; 42   :     for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+620
	mov	eax, DWORD PTR _dymem
$LN14@calc_simpl:

; 40   :   for ( k = 1 ; k <= web.dimension ; k++ )

	add	DWORD PTR tv525[ebp], 48		; 00000030H
	inc	edi
	cmp	edi, ecx
	jle	SHORT $LL29@calc_simpl
	mov	esi, DWORD PTR tv257[ebp]
$LN27@calc_simpl:

; 44   :   }
; 45   :   for ( k = 0 ; k < web.dimension ; k++ )

	xor	edi, edi
	cmp	ecx, edi
	jle	$LN7@calc_simpl
	lea	edx, DWORD PTR _mat$[ebp]
	mov	DWORD PTR tv598[ebp], edx
	mov	DWORD PTR tv581[ebp], edi
	npad	3
$LL30@calc_simpl:

; 46   :   { mat[k] = matspace[k]; /* set up for matrix.c */

	mov	eax, DWORD PTR tv581[ebp]
	lea	edx, DWORD PTR _matspace$[ebp+eax]
	mov	eax, DWORD PTR tv598[ebp]

; 47   :     for ( j = 0 ; j <= k ; j++ )

	xor	esi, esi
	mov	DWORD PTR [eax], edx
	test	edi, edi
	js	SHORT $LN8@calc_simpl

; 46   :   { mat[k] = matspace[k]; /* set up for matrix.c */

	lea	ebx, DWORD PTR _side$[ebp]
$LL26@calc_simpl:

; 48   :        mat[j][k] = mat[k][j] = SDIM_dot(side[j],side[k]);

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR tv581[ebp]
	push	ecx
	lea	eax, DWORD PTR _side$[ebp+eax]
	push	eax
	push	ebx
	call	_dot
	mov	edx, DWORD PTR tv598[ebp]
	mov	eax, DWORD PTR [edx]
	fst	QWORD PTR [eax+esi*8]
	mov	ecx, DWORD PTR _mat$[ebp+esi*4]
	inc	esi
	fstp	QWORD PTR [ecx+edi*8]
	add	esp, 12					; 0000000cH
	add	ebx, 48					; 00000030H
	cmp	esi, edi
	jle	SHORT $LL26@calc_simpl

; 47   :     for ( j = 0 ; j <= k ; j++ )

	mov	ecx, DWORD PTR _web+620
$LN8@calc_simpl:

; 44   :   }
; 45   :   for ( k = 0 ; k < web.dimension ; k++ )

	add	DWORD PTR tv581[ebp], 48		; 00000030H
	add	DWORD PTR tv598[ebp], 4
	inc	edi
	cmp	edi, ecx
	jl	SHORT $LL30@calc_simpl
	mov	esi, DWORD PTR tv257[ebp]
$LN7@calc_simpl:

; 49   :   }
; 50   :   det = determinant(mat,web.dimension);

	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	_determinant

; 51   :   if ( det <= 0.0 ) energy = 0.0;

	fldz
	fcom	ST(1)
	add	esp, 8
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN32@calc_simpl
	fstp	ST(1)
	jmp	SHORT $LN2@calc_simpl
$LN32@calc_simpl:
	fstp	ST(0)

; 52   :   else energy = sqrt(det)/web.simplex_factorial;

	call	__CIsqrt
	fdiv	QWORD PTR _web+792
$LN2@calc_simpl:

; 53   : 
; 54   :   web.total_area    += energy;

	fld	QWORD PTR _web+992

; 55   : 
; 56   :   set_facet_area(f_id,energy);

	mov	eax, DWORD PTR _web+236
	fadd	ST(0), ST(1)
	pop	edi
	fstp	QWORD PTR _web+992
	mov	ecx, DWORD PTR [esi+eax]
	fst	QWORD PTR [ecx+40]

; 57   :   if ( get_fattr(f_id) & DENSITY )

	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 16					; 00000010H
	xor	edx, edx
	or	eax, edx
	pop	esi
	pop	ebx
	je	SHORT $LN1@calc_simpl

; 58   :          energy *= get_facet_density(f_id);

	fmul	QWORD PTR [ecx+32]
$LN1@calc_simpl:

; 59   :   binary_tree_add(web.total_energy_addends,energy);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1248
	call	_binary_tree_add

; 60   :       
; 61   : } // end calc_simplex_energy()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	add	esp, 12					; 0000000cH
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_calc_simplex_energy ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_calc_simplex_forces
EXTRN	_det_adjoint:PROC
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _calc_simplex_forces
_TEXT	SEGMENT
_f$ = -668						; size = 24
_mat$ = -644						; size = 24
_x$ = -644						; size = 24
tv534 = -620						; size = 4
tv1748 = -616						; size = 4
tv530 = -612						; size = 4
tv1752 = -608						; size = 4
tv2060 = -604						; size = 8
tv2058 = -604						; size = 8
tv667 = -600						; size = 4
tv513 = -600						; size = 4
tv1759 = -596						; size = 4
tv1696 = -596						; size = 4
tv1761 = -592						; size = 4
_k$ = -592						; size = 4
tv1874 = -588						; size = 4
tv1737 = -588						; size = 4
tv1857 = -584						; size = 4
tv1636 = -584						; size = 4
_matspace$ = -580					; size = 288
_side$ = -292						; size = 288
__$ArrayPad$ = -4					; size = 4
_f_id$ = 8						; size = 4
_calc_simplex_forces PROC				; COMDAT

; 72   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 668				; 0000029cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _f_id$[ebp]

; 73   :     vertex_id *v = get_facet_vertices(f_id);

	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv513[ebp], eax
	mov	eax, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+eax+304]
	push	ebx

; 74   :     REAL side[MAXCOORD][MAXCOORD];
; 75   :     REAL *x[MAXCOORD];
; 76   :     REAL *f[MAXCOORD];
; 77   :     REAL matspace[MAXCOORD][MAXCOORD];
; 78   :     REAL *mat[MAXCOORD];
; 79   :     REAL force;
; 80   :     int k,j,i;
; 81   :     REAL det;
; 82   :     REAL factor;
; 83   : 
; 84   :     x[0] = get_coord(v[0]);

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR _web+104
	mov	ebx, DWORD PTR [esi+eax+64]
	push	edi
	lea	edi, DWORD PTR [esi+eax+64]
	add	ebx, edx

; 85   :     f[0] = get_force(v[0]);

	lea	eax, DWORD PTR [esi+eax+784]
	mov	DWORD PTR _x$[ebp], ebx

; 86   :     for ( k = 1 ; k <= web.dimension ; k++ )

	mov	ebx, DWORD PTR _web+620
	mov	DWORD PTR tv534[ebp], eax
	mov	eax, DWORD PTR [eax]
	add	eax, edx
	mov	DWORD PTR tv530[ebp], edi
	mov	DWORD PTR _f$[ebp], eax
	cmp	ebx, 1
	jl	$LN45@calc_simpl@2

; 87   :       {  x[k] = get_coord(v[k]);

	lea	edx, DWORD PTR _side$[ebp+8]
	mov	DWORD PTR tv1737[ebp], edx
	lea	edx, DWORD PTR _f$[ebp]
	sub	edx, ecx
	lea	esi, DWORD PTR _x$[ebp]
	lea	eax, DWORD PTR [ecx+4]
	sub	esi, ecx
	mov	DWORD PTR tv1636[ebp], 6
	mov	DWORD PTR tv1696[ebp], eax
	mov	DWORD PTR tv1748[ebp], edx
	mov	DWORD PTR tv1752[ebp], esi
	mov	DWORD PTR tv1761[ebp], ebx
	jmp	SHORT $LN24@calc_simpl@2
	npad	7
$LL47@calc_simpl@2:

; 86   :     for ( k = 1 ; k <= web.dimension ; k++ )

	mov	edx, DWORD PTR tv1748[ebp]
	mov	edi, DWORD PTR tv530[ebp]
$LN24@calc_simpl@2:

; 87   :       {  x[k] = get_coord(v[k]);

	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR [edi]
	mov	ebx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	lea	ebx, DWORD PTR [ecx+edi]

; 88   :           f[k] = get_force(v[k]);

	mov	edi, DWORD PTR tv534[ebp]
	mov	DWORD PTR [esi+eax], ebx
	mov	edi, DWORD PTR [edi]
	add	edi, ecx
	mov	DWORD PTR [edx+eax], edi

; 89   :           for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR _x$[ebp]
	xor	edi, edi
	cmp	DWORD PTR _web+616, 4
	jl	SHORT $LC42@calc_simpl@2

; 87   :       {  x[k] = get_coord(v[k]);

	mov	ecx, DWORD PTR tv1737[ebp]
	lea	eax, DWORD PTR [edx+8]
	lea	esi, DWORD PTR [ebx+24]

; 90   :              side[k-1][j] = x[k][j] - x[0][j];

	sub	ebx, edx
	mov	edx, DWORD PTR _web+616
	add	edx, -4					; fffffffcH
	shr	edx, 2
	inc	edx
	lea	edi, DWORD PTR [edx*4]
$LL43@calc_simpl@2:
	fld	QWORD PTR [esi-24]
	add	eax, 32					; 00000020H
	fsub	QWORD PTR [eax-40]
	add	ecx, 32					; 00000020H
	add	esi, 32					; 00000020H
	dec	edx
	fstp	QWORD PTR [ecx-40]
	fld	QWORD PTR [ebx+eax-32]
	fsub	QWORD PTR [eax-32]
	fstp	QWORD PTR [ecx-32]
	fld	QWORD PTR [esi-40]
	fsub	QWORD PTR [eax-24]
	fstp	QWORD PTR [ecx-24]
	fld	QWORD PTR [esi-32]
	fsub	QWORD PTR [eax-16]
	fstp	QWORD PTR [ecx-16]
	jne	SHORT $LL43@calc_simpl@2

; 87   :       {  x[k] = get_coord(v[k]);

	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR tv1696[ebp]
	mov	esi, DWORD PTR tv1752[ebp]
$LC42@calc_simpl@2:

; 89   :           for ( j = 0 ; j < SDIM ; j++ )

	cmp	edi, DWORD PTR _web+616
	jge	SHORT $LN23@calc_simpl@2
	mov	esi, DWORD PTR [esi+eax]
	mov	ebx, DWORD PTR tv1636[ebp]
	sub	esi, edx
	mov	DWORD PTR tv1759[ebp], esi
	mov	esi, DWORD PTR _web+616
	add	ebx, edi
	lea	ecx, DWORD PTR [edx+edi*8]
	lea	ebx, DWORD PTR _side$[ebp+ebx*8-48]
	sub	esi, edi
	npad	11
$LC21@calc_simpl@2:

; 90   :              side[k-1][j] = x[k][j] - x[0][j];

	mov	edx, DWORD PTR tv1759[ebp]
	fld	QWORD PTR [edx+ecx]
	add	ecx, 8
	fsub	QWORD PTR [ecx-8]
	add	ebx, 8
	dec	esi
	fstp	QWORD PTR [ebx-8]
	jne	SHORT $LC21@calc_simpl@2

; 89   :           for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR tv1752[ebp]
$LN23@calc_simpl@2:

; 86   :     for ( k = 1 ; k <= web.dimension ; k++ )

	add	DWORD PTR tv1737[ebp], 48		; 00000030H
	add	DWORD PTR tv1636[ebp], 6
	add	eax, 4
	dec	DWORD PTR tv1761[ebp]
	mov	DWORD PTR tv1696[ebp], eax
	jne	$LL47@calc_simpl@2
	mov	ebx, DWORD PTR _web+620
$LN45@calc_simpl@2:

; 91   :       }
; 92   :     for ( k = 0 ; k < web.dimension ; k++ )

	xor	edi, edi
	cmp	ebx, edi
	jle	$LN16@calc_simpl@2
	lea	eax, DWORD PTR _mat$[ebp]
	mov	DWORD PTR tv1874[ebp], eax
	mov	DWORD PTR tv1857[ebp], edi
$LL46@calc_simpl@2:

; 93   :       { mat[k] = matspace[k]; /* set up for matrix.c */

	mov	ecx, DWORD PTR tv1857[ebp]
	mov	eax, DWORD PTR tv1874[ebp]
	lea	edx, DWORD PTR _matspace$[ebp+ecx]

; 94   :          for ( j = 0 ; j <= k ; j++ )

	xor	esi, esi
	mov	DWORD PTR [eax], edx
	test	edi, edi
	js	SHORT $LN17@calc_simpl@2

; 93   :       { mat[k] = matspace[k]; /* set up for matrix.c */

	lea	ebx, DWORD PTR _side$[ebp]
	npad	12
$LL44@calc_simpl@2:

; 95   :             mat[j][k] = mat[k][j] = SDIM_dot(side[j],side[k]);

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR tv1857[ebp]
	push	ecx
	lea	eax, DWORD PTR _side$[ebp+eax]
	push	eax
	push	ebx
	call	_dot
	mov	edx, DWORD PTR tv1874[ebp]
	mov	eax, DWORD PTR [edx]
	fst	QWORD PTR [eax+esi*8]
	mov	ecx, DWORD PTR _mat$[ebp+esi*4]
	inc	esi
	fstp	QWORD PTR [ecx+edi*8]
	add	esp, 12					; 0000000cH
	add	ebx, 48					; 00000030H
	cmp	esi, edi
	jle	SHORT $LL44@calc_simpl@2
$LN17@calc_simpl@2:

; 91   :       }
; 92   :     for ( k = 0 ; k < web.dimension ; k++ )

	add	DWORD PTR tv1857[ebp], 48		; 00000030H
	add	DWORD PTR tv1874[ebp], 4
	inc	edi
	cmp	edi, DWORD PTR _web+620
	jl	SHORT $LL46@calc_simpl@2
	mov	ebx, DWORD PTR _web+620
$LN16@calc_simpl@2:

; 96   :       }
; 97   :     det = det_adjoint(mat,web.dimension);  /* leaves mat adjoint transpose */

	lea	edx, DWORD PTR _mat$[ebp]
	push	ebx
	push	edx
	call	_det_adjoint

; 98   :     if ( det <= 0.0 ) return; /* degenerate triangle */

	fldz
	fcomp	ST(1)
	add	esp, 8
	fnstsw	ax
	test	ah, 1
	je	$LN70@calc_simpl@2

; 99   : 
; 100  :     if ( get_fattr(f_id) & DENSITY )

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR tv513[ebp]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 16					; 00000010H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN11@calc_simpl@2

; 101  :          factor = get_facet_density(f_id)/web.simplex_factorial/sqrt(det);

	fld	QWORD PTR [ecx+32]
	fdiv	QWORD PTR _web+792
	fstp	QWORD PTR tv2058[ebp]
	call	__CIsqrt
	fdivr	QWORD PTR tv2058[ebp]
	jmp	SHORT $LN10@calc_simpl@2
$LN11@calc_simpl@2:

; 102  :     else factor = 1.0/web.simplex_factorial/sqrt(det);

	fld1
	fdiv	QWORD PTR _web+792
	fstp	QWORD PTR tv2060[ebp]
	call	__CIsqrt
	fdivr	QWORD PTR tv2060[ebp]
$LN10@calc_simpl@2:

; 103  : 
; 104  :     for ( k = 0 ; k < web.dimension ; k++ )

	mov	eax, DWORD PTR _web+620
	xor	edx, edx
	mov	DWORD PTR _k$[ebp], edx
	test	eax, eax
	jle	$LN70@calc_simpl@2
$LN48@calc_simpl@2:

; 105  :      for ( i = 0 ; i < web.dimension ; i++ )

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN8@calc_simpl@2
	mov	ecx, DWORD PTR _f$[ebp+edx*4+4]
	mov	ebx, ecx
	mov	DWORD PTR tv667[ebp], ecx
	neg	ebx
$LN6@calc_simpl@2:

; 106  :      { REAL *ss,*ff,*ff0, fudge =  factor*mat[k][i];

	mov	eax, DWORD PTR _mat$[ebp+edx*4]
	fld	QWORD PTR [eax+edi*8]

; 107  :         for ( j=SDIM, ff0=f[0], ff=f[k+1],ss=side[i] ; j ; j-- )

	mov	esi, DWORD PTR _web+616
	mov	eax, DWORD PTR _f$[ebp]
	fmul	ST(0), ST(1)
	test	esi, esi
	je	SHORT $LN63@calc_simpl@2

; 106  :      { REAL *ss,*ff,*ff0, fudge =  factor*mat[k][i];

	lea	edx, DWORD PTR [ebx+ecx]
	lea	edx, DWORD PTR _side$[ebp+edx]

; 107  :         for ( j=SDIM, ff0=f[0], ff=f[k+1],ss=side[i] ; j ; j-- )

	sub	ecx, eax
$LN3@calc_simpl@2:

; 108  :          { 
; 109  :             *(ff++) -= force = fudge*(*(ss++));

	fld	QWORD PTR [edx]
	add	edx, 8
	fmul	ST(0), ST(1)

; 110  :             *(ff0++) += force;

	add	eax, 8
	dec	esi
	fld	QWORD PTR [ecx+eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [ecx+eax-8]
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LN3@calc_simpl@2

; 107  :         for ( j=SDIM, ff0=f[0], ff=f[k+1],ss=side[i] ; j ; j-- )

	mov	edx, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR tv667[ebp]
$LN63@calc_simpl@2:
	inc	edi
	fstp	ST(0)
	add	ebx, 48					; 00000030H
	cmp	edi, DWORD PTR _web+620
	jl	SHORT $LN6@calc_simpl@2

; 105  :      for ( i = 0 ; i < web.dimension ; i++ )

	mov	eax, DWORD PTR _web+620
$LN8@calc_simpl@2:

; 103  : 
; 104  :     for ( k = 0 ; k < web.dimension ; k++ )

	inc	edx
	mov	DWORD PTR _k$[ebp], edx
	cmp	edx, eax
	jl	$LN48@calc_simpl@2
$LN70@calc_simpl@2:

; 111  :          }
; 112  :      }
; 113  : 
; 114  : } // end calc_simplex_forces()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_calc_simplex_forces ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_calc_simplex_volume
EXTRN	_add_body_volume:PROC
; Function compile flags: /Ogtp
;	COMDAT _calc_simplex_volume
_TEXT	SEGMENT
_x$ = -364						; size = 24
_mat$ = -340						; size = 24
tv396 = -316						; size = 4
_b_id0$ = -312						; size = 4
_b_id1$ = -308						; size = 4
_vol$ = -304						; size = 8
tv410 = -300						; size = 4
tv241 = -300						; size = 4
tv369 = -296						; size = 4
_matspace$ = -292					; size = 288
__$ArrayPad$ = -4					; size = 4
_f_id$ = 8						; size = 4
_calc_simplex_volume PROC				; COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 128  :   vertex_id *v = get_facet_vertices(f_id);

	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+328
	push	esi
	mov	esi, DWORD PTR _f_id$[ebp]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	push	edi
	mov	edi, DWORD PTR [edx+ecx+304]
	add	edi, eax

; 129  :   REAL *x[MAXCOORD];
; 130  :   REAL matspace[MAXCOORD][MAXCOORD];
; 131  :   REAL *mat[MAXCOORD];
; 132  :   int k,j;
; 133  :   body_id b_id0,b_id1;
; 134  :   REAL vol;
; 135  :      
; 136  :   if ( get_fattr(f_id) & NONCONTENT ) return;

	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN1@calc_simpl@3

; 137  :   
; 138  :   b_id0 = get_facet_body(f_id);

	push	ebx
	push	esi
	call	_get_facet_body
	mov	ebx, eax

; 139  :   b_id1 = get_facet_body(facet_inverse(f_id));

	xor	esi, 134217728				; 08000000H
	push	esi
	mov	DWORD PTR _b_id0$[ebp], ebx
	call	_get_facet_body

; 140  :   if ( !valid_id(b_id0) && !valid_id(b_id1) ) return;

	mov	esi, ebx
	shr	esi, 28					; 0000001cH
	add	esp, 8
	and	esi, 1
	mov	DWORD PTR _b_id1$[ebp], eax
	mov	DWORD PTR tv241[ebp], esi
	jne	SHORT $LN9@calc_simpl@3
	test	eax, 268435456				; 10000000H
	je	$LN19@calc_simpl@3
$LN9@calc_simpl@3:

; 141  :      
; 142  :   for ( k = 0 ; k <= web.dimension ; k++ )

	mov	eax, DWORD PTR _web+620
	xor	edx, edx
	test	eax, eax
	js	$LN6@calc_simpl@3
	mov	esi, DWORD PTR _web+616
	lea	eax, DWORD PTR _matspace$[ebp]
	mov	DWORD PTR tv369[ebp], eax
	mov	eax, edi
	lea	ecx, DWORD PTR _x$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv396[ebp], eax
	jmp	SHORT $LN8@calc_simpl@3
$LL17@calc_simpl@3:
	mov	eax, DWORD PTR tv396[ebp]
$LN8@calc_simpl@3:

; 143  :       {  x[k] = get_coord(v[k]);

	mov	edi, DWORD PTR _web+12
	mov	ebx, DWORD PTR _dymem
	lea	ecx, DWORD PTR _x$[ebp+edx*4]
	mov	eax, DWORD PTR [eax+ecx]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+104
	add	eax, DWORD PTR [edi+ebx+64]
	mov	DWORD PTR [ecx], eax

; 144  :           mat[k] = matspace[k];

	mov	eax, DWORD PTR tv369[ebp]
	mov	DWORD PTR _mat$[ebp+edx*4], eax

; 145  :           for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN7@calc_simpl@3
	mov	ecx, DWORD PTR [ecx]
	npad	10
$LL5@calc_simpl@3:

; 146  :              mat[k][j] = x[k][j];

	mov	esi, DWORD PTR _mat$[ebp+edx*4]
	fld	QWORD PTR [ecx+eax*8]
	fstp	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR _web+616
	inc	eax
	cmp	eax, esi
	jl	SHORT $LL5@calc_simpl@3
$LN7@calc_simpl@3:

; 141  :      
; 142  :   for ( k = 0 ; k <= web.dimension ; k++ )

	mov	eax, DWORD PTR _web+620
	add	DWORD PTR tv369[ebp], 48		; 00000030H
	inc	edx
	cmp	edx, eax
	jle	SHORT $LL17@calc_simpl@3
	mov	ebx, DWORD PTR _b_id0$[ebp]
	mov	esi, DWORD PTR tv241[ebp]
$LN6@calc_simpl@3:

; 147  :       }
; 148  :   vol = determinant(mat,web.dimension+1);

	inc	eax
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	_determinant

; 149  :   vol /= web.simplex_factorial*(web.dimension+1);

	mov	edx, DWORD PTR _web+620
	inc	edx
	mov	DWORD PTR tv410[ebp], edx
	fild	DWORD PTR tv410[ebp]
	add	esp, 8
	fmul	QWORD PTR _web+792
	fdivp	ST(1), ST(0)
	fst	QWORD PTR _vol$[ebp]

; 150  : 
; 151  :   /* add to body volumes */
; 152  :   if ( valid_id(b_id0) ) 

	test	esi, esi
	je	SHORT $LN2@calc_simpl@3

; 153  :      add_body_volume(b_id0,vol);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ebx
	call	_add_body_volume
	fld	QWORD PTR _vol$[ebp]
	add	esp, 12					; 0000000cH
$LN2@calc_simpl@3:

; 154  :   if ( valid_id(b_id1) ) 

	mov	eax, DWORD PTR _b_id1$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN24@calc_simpl@3

; 155  :      add_body_volume(b_id1,-vol);

	sub	esp, 8
	fchs
	fstp	QWORD PTR [esp]
	push	eax
	call	_add_body_volume
	add	esp, 12					; 0000000cH
	pop	ebx
	pop	edi
	pop	esi

; 156  : } // end calc_simplex_volume()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@calc_simpl@3:

; 154  :   if ( valid_id(b_id1) ) 

	fstp	ST(0)
$LN19@calc_simpl@3:
	pop	ebx
$LN1@calc_simpl@3:

; 156  : } // end calc_simplex_volume()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_calc_simplex_volume ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_grad_l
EXTRN	_volume_factorial:QWORD
EXTRN	_get_bv_new_vgrad:PROC
; Function compile flags: /Ogtp
;	COMDAT _simplex_grad_l
_TEXT	SEGMENT
_x$ = -368						; size = 24
_mat$ = -344						; size = 24
tv362 = -320						; size = 8
tv369 = -316						; size = 4
tv601 = -312						; size = 4
tv356 = -308						; size = 4
_bj_id$ = -304						; size = 4
_bi_id$ = -300						; size = 4
_v$ = -296						; size = 4
_matspace$ = -292					; size = 288
__$ArrayPad$ = -4					; size = 4
_simplex_grad_l PROC					; COMDAT

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 167  :   body_id bi_id;  /* identifier for body i */
; 168  :   body_id bj_id;  /* identifier for body j */
; 169  :   vertex_id *v;
; 170  :   REAL *x[MAXCOORD];
; 171  :   REAL matspace[MAXCOORD][MAXCOORD];
; 172  :   REAL *mat[MAXCOORD];
; 173  :   int k,j,i;
; 174  :   facet_id f_id;
; 175  :      
; 176  :   volgrad *vgptr;
; 177  : 
; 178  :   FOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR _web+272
	test	esi, 268435456				; 10000000H
	je	$LN37@simplex_gr
	push	ebx
	push	edi
	npad	8
$LL27@simplex_gr:
	mov	eax, DWORD PTR _web+236
	mov	ebx, esi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	edi, DWORD PTR [ebx+eax]
	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi+12]
	mov	eax, ecx
	mov	DWORD PTR tv362[ebp+4], edx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv356[ebp], ebx
	je	$LN26@simplex_gr

; 179  :   { if ( get_fattr(f_id) & NONCONTENT ) return;

	and	ecx, 536870912				; 20000000H
	xor	eax, eax
	or	ecx, eax
	jne	$LN54@simplex_gr

; 180  :     bi_id = get_facet_body(f_id);

	push	esi
	call	_get_facet_body

; 181  :     bj_id = get_facet_body(facet_inverse(f_id));

	xor	esi, 134217728				; 08000000H
	push	esi
	mov	DWORD PTR _bi_id$[ebp], eax
	call	_get_facet_body

; 182  :     if ( !valid_id(bi_id) && !valid_id(bj_id) ) continue;

	mov	esi, DWORD PTR _bi_id$[ebp]
	shr	esi, 28					; 0000001cH
	add	esp, 8
	and	esi, 1
	mov	DWORD PTR _bj_id$[ebp], eax
	mov	DWORD PTR tv369[ebp], esi
	jne	SHORT $LN21@simplex_gr
	test	eax, 268435456				; 10000000H
	je	$LN26@simplex_gr
$LN21@simplex_gr:

; 183  :     v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	ebx, DWORD PTR [eax+ecx+304]
	add	ebx, edi

; 184  :     for ( k = 0 ; k <= web.dimension ; k++ )

	xor	edx, edx
	mov	DWORD PTR _v$[ebp], ebx
	cmp	DWORD PTR _web+620, edx
	jl	$LN18@simplex_gr
	lea	eax, DWORD PTR _x$[ebp]
	sub	ebx, eax
	lea	esi, DWORD PTR _matspace$[ebp]
	mov	DWORD PTR tv601[ebp], ebx
	jmp	SHORT $LN20@simplex_gr
$LL51@simplex_gr:
	mov	ebx, DWORD PTR tv601[ebp]
$LN20@simplex_gr:

; 185  :     { x[k] = get_coord(v[k]);

	mov	edi, DWORD PTR _web+12
	lea	ecx, DWORD PTR _x$[ebp+edx*4]
	mov	eax, DWORD PTR [ebx+ecx]
	mov	ebx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+104
	add	eax, DWORD PTR [edi+ebx+64]

; 186  :       mat[k] = matspace[k];

	mov	DWORD PTR _mat$[ebp+edx*4], esi
	mov	DWORD PTR [ecx], eax

; 187  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN19@simplex_gr
	mov	ecx, DWORD PTR [ecx]
	npad	10
$LL17@simplex_gr:

; 188  :         mat[k][j] = x[k][j];

	fld	QWORD PTR [ecx+eax*8]
	mov	edi, DWORD PTR _mat$[ebp+edx*4]
	fstp	QWORD PTR [edi+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL17@simplex_gr
$LN19@simplex_gr:

; 184  :     for ( k = 0 ; k <= web.dimension ; k++ )

	inc	edx
	add	esi, 48					; 00000030H
	cmp	edx, DWORD PTR _web+620
	jle	SHORT $LL51@simplex_gr
	mov	esi, DWORD PTR tv369[ebp]
	mov	ebx, DWORD PTR _v$[ebp]
$LN18@simplex_gr:

; 189  :     }
; 190  :     det_adjoint(mat,web.dimension+1); /* mat adjoint transpose */

	mov	ecx, DWORD PTR _web+620
	inc	ecx
	push	ecx
	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	call	_det_adjoint
	fstp	ST(0)
	add	esp, 8

; 191  : 
; 192  :     if ( valid_id(bi_id) && (get_battr(bi_id) & (PRESSURE|FIXEDVOL)) )

	test	esi, esi
	je	$LN46@simplex_gr
	mov	edi, DWORD PTR _bi_id$[ebp]
	mov	eax, DWORD PTR _web+348
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2080				; 00000820H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN46@simplex_gr

; 193  :     { for ( k = 0 ; k <= web.dimension ; k++ )

	xor	esi, esi
	cmp	DWORD PTR _web+620, ecx
	jl	SHORT $LN46@simplex_gr
	npad	1
$LL45@simplex_gr:

; 194  :       { vgptr = get_bv_new_vgrad(get_body_fixnum(bi_id),v[k]);

	mov	ecx, DWORD PTR [ebx+esi*4]
	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [edi+edx]
	push	ecx
	mov	ecx, DWORD PTR [eax+420]
	push	ecx
	call	_get_bv_new_vgrad

; 195  :         vgptr->bb_id = bi_id;

	mov	edx, DWORD PTR _bi_id$[ebp]

; 196  :         for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	add	esp, 8
	mov	DWORD PTR [eax+8], edx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN12@simplex_gr
	npad	1
$LL10@simplex_gr:

; 197  :           vgptr->grad[i] +=  mat[i][k]/volume_factorial;

	mov	ebx, DWORD PTR _mat$[ebp+ecx*4]
	fld	QWORD PTR [ebx+esi*8]
	mov	edx, DWORD PTR [eax+16]
	fdiv	QWORD PTR _volume_factorial
	lea	edx, DWORD PTR [edx+ecx*8]
	inc	ecx
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL10@simplex_gr

; 196  :         for ( i = 0 ; i < SDIM ; i++ )

	mov	ebx, DWORD PTR _v$[ebp]
$LN12@simplex_gr:

; 193  :     { for ( k = 0 ; k <= web.dimension ; k++ )

	inc	esi
	cmp	esi, DWORD PTR _web+620
	jle	SHORT $LL45@simplex_gr
$LN46@simplex_gr:

; 198  :       }
; 199  :     }
; 200  :     if ( valid_id(bj_id) && (get_battr(bj_id) & (PRESSURE|FIXEDVOL)) )

	mov	edi, DWORD PTR _bj_id$[ebp]
	test	edi, 268435456				; 10000000H
	je	$LN50@simplex_gr
	mov	eax, DWORD PTR _web+348
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2080				; 00000820H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN50@simplex_gr

; 201  :     { for ( k = 0 ; k <= web.dimension ; k++ )

	xor	esi, esi
	cmp	DWORD PTR _web+620, ecx
	jl	SHORT $LN50@simplex_gr
	npad	2
$LL49@simplex_gr:

; 202  :       { vgptr = get_bv_new_vgrad(get_body_fixnum(bj_id),v[k]);

	mov	ecx, DWORD PTR [ebx+esi*4]
	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [edi+edx]
	push	ecx
	mov	ecx, DWORD PTR [eax+420]
	push	ecx
	call	_get_bv_new_vgrad

; 203  :         vgptr->bb_id = bj_id;

	mov	edx, DWORD PTR _bj_id$[ebp]

; 204  :         for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	add	esp, 8
	mov	DWORD PTR [eax+8], edx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN5@simplex_gr
	npad	1
$LL3@simplex_gr:

; 205  :           vgptr->grad[i] -=  mat[i][k]/volume_factorial;

	mov	ebx, DWORD PTR _mat$[ebp+ecx*4]
	fld	QWORD PTR [ebx+esi*8]
	mov	edx, DWORD PTR [eax+16]
	fdiv	QWORD PTR _volume_factorial
	lea	edx, DWORD PTR [edx+ecx*8]
	inc	ecx
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL3@simplex_gr

; 204  :         for ( i = 0 ; i < SDIM ; i++ )

	mov	ebx, DWORD PTR _v$[ebp]
$LN5@simplex_gr:

; 201  :     { for ( k = 0 ; k <= web.dimension ; k++ )

	inc	esi
	cmp	esi, DWORD PTR _web+620
	jle	SHORT $LL49@simplex_gr
$LN50@simplex_gr:
	mov	ebx, DWORD PTR tv356[ebp]
$LN26@simplex_gr:

; 167  :   body_id bi_id;  /* identifier for body i */
; 168  :   body_id bj_id;  /* identifier for body j */
; 169  :   vertex_id *v;
; 170  :   REAL *x[MAXCOORD];
; 171  :   REAL matspace[MAXCOORD][MAXCOORD];
; 172  :   REAL *mat[MAXCOORD];
; 173  :   int k,j,i;
; 174  :   facet_id f_id;
; 175  :      
; 176  :   volgrad *vgptr;
; 177  : 
; 178  :   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ebx+eax]
	mov	esi, DWORD PTR [ecx]
	test	esi, 268435456				; 10000000H
	jne	$LL27@simplex_gr
$LN54@simplex_gr:
	pop	edi
	pop	ebx
$LN37@simplex_gr:

; 206  :      }
; 207  :     }
; 208  :   } /* end facet loop */
; 209  : } // end simplex_grad_l()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_grad_l ENDP
_TEXT	ENDS
PUBLIC	??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@		; `string'
PUBLIC	_refine_simplex
EXTRN	_temp_free:PROC
EXTRN	_kb_temp_calloc:PROC
;	COMDAT ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
CONST	SEGMENT
??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@ DB 'SIMPLEX.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _refine_simplex
_TEXT	SEGMENT
tv393 = -36						; size = 4
_numedges$ = -36					; size = 4
tv394 = -32						; size = 4
tv131 = -32						; size = 4
tv129 = -28						; size = 4
_basept$ = -24						; size = 4
_v2$ = -20						; size = 4
_v1$ = -16						; size = 4
tv591 = -12						; size = 4
_newelist$ = -8						; size = 4
_snum$ = -4						; size = 4
_dim$ = 8						; size = 4
_vlist$ = 12						; size = 4
_elist$ = 16						; size = 4
_slist$ = 20						; size = 4
_refine_simplex PROC					; COMDAT

; 227  : { int v1,v2;

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx

; 228  :   int basept;
; 229  :   int numedges = (dim*(dim+1))/2;

	mov	ebx, DWORD PTR _dim$[ebp]
	lea	eax, DWORD PTR [ebx+1]
	imul	eax, ebx
	push	esi
	push	edi
	cdq

; 230  :   int snum = 0;  /* simplex number */
; 231  :   int pnum;        /* point number in simplex */
; 232  :   struct divedge *newelist
; 233  :            = (struct divedge *)temp_calloc(numedges,sizeof(struct divedge));

	push	233					; 000000e9H
	sub	eax, edx
	mov	edi, eax
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	sar	edi, 1
	push	12					; 0000000cH
	push	edi
	mov	DWORD PTR _numedges$[ebp], edi
	mov	DWORD PTR _snum$[ebp], 0
	call	_kb_temp_calloc
	mov	DWORD PTR _newelist$[ebp], eax
	add	esp, 16					; 00000010H

; 234  :   int i,j;
; 235  :   int newfaces;
; 236  :   int edgenum;
; 237  :   int lowpt,lowpti=0;

	xor	ecx, ecx

; 238  : 
; 239  :   /* pick base point as lowest numbered midpoint on list  */
; 240  :   for ( i = 0 , lowpt = 0x7FFF7FFF ; i < numedges ; i++ )

	xor	eax, eax
	mov	edx, 2147450879				; 7fff7fffH
	test	edi, edi
	jle	SHORT $LN35@refine_sim

; 228  :   int basept;
; 229  :   int numedges = (dim*(dim+1))/2;

	mov	ebx, DWORD PTR _elist$[ebp]
	add	ebx, 8
	npad	2
$LL37@refine_sim:

; 241  :   { if ( elist[i].divpt < lowpt ) 

	mov	esi, DWORD PTR [ebx]
	cmp	esi, edx
	jge	SHORT $LN36@refine_sim

; 242  :     { lowpt = elist[i].divpt; lowpti = i; }

	mov	edx, esi
	mov	ecx, eax
$LN36@refine_sim:

; 238  : 
; 239  :   /* pick base point as lowest numbered midpoint on list  */
; 240  :   for ( i = 0 , lowpt = 0x7FFF7FFF ; i < numedges ; i++ )

	inc	eax
	add	ebx, 12					; 0000000cH
	cmp	eax, edi
	jl	SHORT $LL37@refine_sim
	mov	ebx, DWORD PTR _dim$[ebp]
$LN35@refine_sim:

; 243  :   }
; 244  :   v1 = elist[lowpti].endpt[0]; v2 = elist[lowpti].endpt[1];

	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR _elist$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax]

; 245  :   basept = elist[lowpti].divpt;

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _v2$[ebp], edx
	mov	edx, DWORD PTR _vlist$[ebp]
	mov	DWORD PTR _v1$[ebp], ecx
	mov	DWORD PTR _basept$[ebp], eax

; 246  : 
; 247  :   /* do simple opposite simplices */
; 248  :   /* one for each vertex not an endpoint on base edge */
; 249  :   for ( i = 0 ; i <= dim ; i++ )

	test	ebx, ebx
	js	SHORT $LN31@refine_sim

; 243  :   }
; 244  :   v1 = elist[lowpti].endpt[0]; v2 = elist[lowpti].endpt[1];

	xor	esi, esi
	inc	ebx
	mov	DWORD PTR tv591[ebp], edx
	mov	DWORD PTR tv131[ebp], ebx
$LL69@refine_sim:

; 250  :      { if ( (vlist[i] == v1) || (vlist[i] == v2) ) continue; /* on base edge */

	mov	eax, DWORD PTR tv591[ebp]
	mov	eax, DWORD PTR [eax]
	cmp	eax, ecx
	je	SHORT $LN32@refine_sim
	cmp	eax, DWORD PTR _v2$[ebp]
	je	SHORT $LN32@refine_sim

; 251  :         for ( j = 0, pnum = 0 ; j < numedges ; j++ )

	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN26@refine_sim
	mov	eax, DWORD PTR _elist$[ebp]
	add	eax, 8
	mov	DWORD PTR tv129[ebp], edi
	npad	3
$LL66@refine_sim:

; 252  :           if ( (elist[j].endpt[0]==vlist[i]) || (elist[j].endpt[1]==vlist[i]))

	mov	edx, DWORD PTR tv591[ebp]
	mov	edx, DWORD PTR [edx]
	cmp	DWORD PTR [eax-8], edx
	je	SHORT $LN24@refine_sim
	cmp	DWORD PTR [eax-4], edx
	jne	SHORT $LN27@refine_sim
$LN24@refine_sim:

; 253  :              slist[snum].pt[pnum++] = elist[j].divpt;

	mov	edi, DWORD PTR [eax]
	mov	ebx, DWORD PTR _slist$[ebp]
	lea	edx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [ebx+edx*4], edi
	mov	edi, DWORD PTR _numedges$[ebp]
	inc	ecx
$LN27@refine_sim:

; 251  :         for ( j = 0, pnum = 0 ; j < numedges ; j++ )

	add	eax, 12					; 0000000cH
	dec	DWORD PTR tv129[ebp]
	jne	SHORT $LL66@refine_sim
	mov	edx, DWORD PTR _vlist$[ebp]
$LN26@refine_sim:

; 254  :         slist[snum].pt[pnum] = basept; /* add common basepoint */

	mov	ebx, DWORD PTR _basept$[ebp]

; 255  :         snum++;

	inc	DWORD PTR _snum$[ebp]
	lea	eax, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR _slist$[ebp]
	mov	DWORD PTR [ecx+eax*4], ebx
	mov	ecx, DWORD PTR _v1$[ebp]
	add	esi, 7
$LN32@refine_sim:

; 246  : 
; 247  :   /* do simple opposite simplices */
; 248  :   /* one for each vertex not an endpoint on base edge */
; 249  :   for ( i = 0 ; i <= dim ; i++ )

	add	DWORD PTR tv591[ebp], 4
	dec	DWORD PTR tv131[ebp]
	jne	SHORT $LL69@refine_sim
	mov	ebx, DWORD PTR _dim$[ebp]
$LN31@refine_sim:

; 256  :      }
; 257  :   if ( dim <= 2 ) goto exxit; /* end recursion */

	cmp	ebx, 2
	jle	$exxit$89281

; 258  : 
; 259  :   /* now do compound opposite faces */
; 260  :   /* first, opposite v1 */
; 261  :   /* first, get edges after base not including  v2 */
; 262  :   for ( i = 0, edgenum = 0 ; i < numedges ; i++ )

	test	edi, edi
	jle	SHORT $LN20@refine_sim
	mov	ecx, DWORD PTR _newelist$[ebp]
	mov	eax, DWORD PTR _elist$[ebp]
	mov	esi, edi
	npad	1
$LL22@refine_sim:

; 263  :      if ( (elist[i].endpt[0]!=v1) && (elist[i].endpt[1]!=v1) )

	mov	edx, DWORD PTR _v1$[ebp]
	cmp	DWORD PTR [eax], edx
	je	SHORT $LN21@refine_sim
	cmp	DWORD PTR [eax+4], edx
	je	SHORT $LN21@refine_sim

; 264  :           newelist[edgenum++] = elist[i];

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	add	ecx, 12					; 0000000cH
$LN21@refine_sim:

; 258  : 
; 259  :   /* now do compound opposite faces */
; 260  :   /* first, opposite v1 */
; 261  :   /* first, get edges after base not including  v2 */
; 262  :   for ( i = 0, edgenum = 0 ; i < numedges ; i++ )

	add	eax, 12					; 0000000cH
	dec	esi
	jne	SHORT $LL22@refine_sim
	mov	edx, DWORD PTR _vlist$[ebp]
	mov	ecx, DWORD PTR _v1$[ebp]
$LN20@refine_sim:

; 265  :   /* get vertex list in good order with v1 first */
; 266  :   for ( i = 0 ; i <= dim ; i++ )

	xor	eax, eax
	test	ebx, ebx
	js	SHORT $LN16@refine_sim
$LL18@refine_sim:

; 267  :      if ( v1 == vlist[i] )

	cmp	ecx, DWORD PTR [edx+eax*4]
	je	SHORT $LN49@refine_sim

; 265  :   /* get vertex list in good order with v1 first */
; 266  :   for ( i = 0 ; i <= dim ; i++ )

	inc	eax
	cmp	eax, ebx
	jle	SHORT $LL18@refine_sim

; 283  :      if ( v2 == vlist[i] )

	jmp	SHORT $LN16@refine_sim
$LN49@refine_sim:

; 268  :         { vlist[i] = vlist[0]; vlist[0] = v1; break; }

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [edx+eax*4], esi
	mov	DWORD PTR [edx], ecx
$LN16@refine_sim:

; 269  :   /* recurse */
; 270  :   refine_simplex(dim-1,vlist+1,newelist,slist+snum);

	mov	ecx, DWORD PTR _snum$[ebp]
	lea	eax, DWORD PTR [edx+4]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	ecx, DWORD PTR _slist$[ebp]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _newelist$[ebp]
	push	edx
	push	ecx
	dec	ebx
	push	eax
	push	ebx
	mov	DWORD PTR tv393[ebp], eax
	mov	DWORD PTR tv394[ebp], ebx
	call	_refine_simplex

; 271  :   /* add base point */
; 272  :   newfaces = (1<<(dim-1))-dim;

	mov	edx, DWORD PTR _dim$[ebp]
	mov	ecx, ebx
	mov	ebx, DWORD PTR _snum$[ebp]
	mov	esi, 1
	shl	esi, cl
	add	esp, 16					; 00000010H
	sub	esi, edx

; 273  :   for ( i = 0 ; i < newfaces ; i++ )

	test	esi, esi
	jle	SHORT $LN12@refine_sim

; 269  :   /* recurse */
; 270  :   refine_simplex(dim-1,vlist+1,newelist,slist+snum);

	mov	ecx, DWORD PTR _slist$[ebp]
	lea	eax, DWORD PTR [ebx*8]
	sub	eax, ebx
	add	eax, edx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, esi

; 273  :   for ( i = 0 ; i < newfaces ; i++ )

	add	ebx, esi
	npad	7
$LL14@refine_sim:

; 274  :      slist[snum++].pt[dim] = basept;

	mov	edx, DWORD PTR _basept$[ebp]
	mov	DWORD PTR [eax], edx
	add	eax, 28					; 0000001cH
	dec	ecx
	jne	SHORT $LL14@refine_sim

; 273  :   for ( i = 0 ; i < newfaces ; i++ )

	mov	edx, DWORD PTR _dim$[ebp]
$LN12@refine_sim:

; 275  : 
; 276  :   /* second, opposite v2 */
; 277  :   /* first, get edges after base not including  v2 */
; 278  :   for ( i = 0, edgenum = 0 ; i < numedges ; i++ )

	test	edi, edi
	jle	SHORT $LN64@refine_sim
	mov	ecx, DWORD PTR _newelist$[ebp]
	mov	eax, DWORD PTR _elist$[ebp]
$LL11@refine_sim:

; 279  :      if ( (elist[i].endpt[0]!=v2) && (elist[i].endpt[1]!=v2) )

	mov	edx, DWORD PTR _v2$[ebp]
	cmp	DWORD PTR [eax], edx
	je	SHORT $LN10@refine_sim
	cmp	DWORD PTR [eax+4], edx
	je	SHORT $LN10@refine_sim

; 280  :           newelist[edgenum++] = elist[i];

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	add	ecx, 12					; 0000000cH
$LN10@refine_sim:

; 275  : 
; 276  :   /* second, opposite v2 */
; 277  :   /* first, get edges after base not including  v2 */
; 278  :   for ( i = 0, edgenum = 0 ; i < numedges ; i++ )

	add	eax, 12					; 0000000cH
	dec	edi
	jne	SHORT $LL11@refine_sim
	mov	edx, DWORD PTR _dim$[ebp]
$LN64@refine_sim:

; 281  :   /* get vertex list in good order with v2 first */
; 282  :   for ( i = 0 ; i <= dim ; i++ )

	xor	eax, eax
	test	edx, edx
	js	SHORT $LN5@refine_sim
$LL7@refine_sim:

; 283  :      if ( v2 == vlist[i] )

	mov	ecx, DWORD PTR _vlist$[ebp]
	mov	edi, DWORD PTR _v2$[ebp]
	cmp	edi, DWORD PTR [ecx+eax*4]
	je	SHORT $LN50@refine_sim

; 281  :   /* get vertex list in good order with v2 first */
; 282  :   for ( i = 0 ; i <= dim ; i++ )

	inc	eax
	cmp	eax, edx
	jle	SHORT $LL7@refine_sim

; 283  :      if ( v2 == vlist[i] )

	jmp	SHORT $LN5@refine_sim
$LN50@refine_sim:

; 284  :         { vlist[i] = vlist[0]; vlist[0] = v2; break; }

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	DWORD PTR [ecx], edi
$LN5@refine_sim:

; 285  :   /* recurse */
; 286  :   refine_simplex(dim-1,vlist+1,newelist,slist+snum);

	mov	edi, DWORD PTR _slist$[ebp]
	mov	edx, DWORD PTR _newelist$[ebp]
	lea	eax, DWORD PTR [ebx*8]
	sub	eax, ebx
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR tv393[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv394[ebp]
	push	edx
	push	eax
	push	ecx
	call	_refine_simplex
	add	esp, 16					; 00000010H

; 287  :   /* add base point */
; 288  :   newfaces = (1<<(dim-1))-dim;
; 289  :   for ( i = 0 ; i < newfaces ; i++ )

	test	esi, esi
	jle	SHORT $exxit$89281

; 285  :   /* recurse */
; 286  :   refine_simplex(dim-1,vlist+1,newelist,slist+snum);

	lea	edx, DWORD PTR [ebx*8]
	sub	edx, ebx
	add	edx, DWORD PTR _dim$[ebp]
	lea	eax, DWORD PTR [edi+edx*4]
$LL3@refine_sim:

; 290  :      slist[snum++].pt[dim] = basept;

	mov	ecx, DWORD PTR _basept$[ebp]
	mov	DWORD PTR [eax], ecx
	add	eax, 28					; 0000001cH
	dec	esi
	jne	SHORT $LL3@refine_sim
$exxit$89281:

; 291  : 
; 292  : exxit:
; 293  :   temp_free((char*)newelist);

	mov	edx, DWORD PTR _newelist$[ebp]
	push	edx
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 294  : } // end refine_simplex()

	mov	esp, ebp
	pop	ebp
	ret	0
_refine_simplex ENDP
_TEXT	ENDS
PUBLIC	_sslist$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_check_orientation
EXTRN	_mat2d_setup:PROC
_BSS	SEGMENT
_vcoord	DD	01H DUP (?)
_scount	DD	01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _check_orientation
_TEXT	SEGMENT
_matqXvS$ = -344					; size = 24
_i$ = -320						; size = 4
tv595 = -316						; size = 4
_sslist$GSCopy$ = -312					; size = 4
_mat$ = -308						; size = 4
_j$ = -304						; size = 4
tv633 = -300						; size = 4
tv643 = -296						; size = 4
_matxJ$ = -292						; size = 288
__$ArrayPad$ = -4					; size = 4
_sslist$ = 8						; size = 4
_sdim$ = 12						; size = 4
_check_orientation PROC					; COMDAT

; 403  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _sslist$[ebp]

; 404  :   int i,j,k;
; 405  :   MAT2D(mat,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _matxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _sslist$GSCopy$[ebp], esi
	call	_mat2d_setup
	mov	DWORD PTR _mat$[ebp], eax

; 406  : 
; 407  :   for ( i = 0 ; i < scount ; i++ )

	xor	eax, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _scount, eax
	jle	$LN8@check_orie

; 416  :           { j = sslist[i].pt[0]; sslist[i].pt[0] = sslist[i].pt[1];

	push	ebx
	mov	ebx, DWORD PTR _sdim$[ebp]
	push	edi
	mov	DWORD PTR tv633[ebp], eax
	npad	4
$LL25@check_orie:

; 408  :      { 
; 409  :         /* load matrix with side vectors of simplex */
; 410  :         for ( j = 0 ; j < sdim ; j++ )

	xor	edx, edx
	mov	DWORD PTR _j$[ebp], edx
	test	ebx, ebx
	jle	$LN5@check_orie
	mov	ecx, DWORD PTR _vcoord
	npad	10
$LL23@check_orie:

; 411  :           for ( k = 0 ; k < sdim ; k++ )

	xor	eax, eax
	cmp	ebx, 4
	jl	$LC20@check_orie
	mov	edi, DWORD PTR tv633[ebp]
	mov	ebx, DWORD PTR _sslist$GSCopy$[ebp]
	add	edi, edx
	lea	edi, DWORD PTR [ebx+edi*4+4]
	mov	DWORD PTR tv643[ebp], edi
	mov	edi, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [edi+edx*4]
	add	edx, 16					; 00000010H
	npad	1
$LL22@check_orie:

; 412  :              mat[j][k] = vcoord[sslist[i].pt[j+1]][k] - vcoord[sslist[i].pt[0]][k];

	mov	edi, DWORD PTR tv643[ebp]
	mov	edi, DWORD PTR [edi]
	lea	edi, DWORD PTR [edi+edi*2]
	lea	ebx, DWORD PTR [eax+edi*2]
	mov	edi, DWORD PTR [esi]
	fld	QWORD PTR [ecx+ebx*8]
	lea	edi, DWORD PTR [edi+edi*2]
	lea	edi, DWORD PTR [eax+edi*2]
	fsub	QWORD PTR [ecx+edi*8]
	mov	edi, DWORD PTR tv643[ebp]
	add	edx, 32					; 00000020H
	fstp	QWORD PTR [edx-48]
	mov	edi, DWORD PTR [edi]
	lea	edi, DWORD PTR [edi+edi*2]
	lea	ebx, DWORD PTR [eax+edi*2]
	mov	edi, DWORD PTR [esi]
	fld	QWORD PTR [ecx+ebx*8+8]
	lea	edi, DWORD PTR [edi+edi*2]
	lea	edi, DWORD PTR [eax+edi*2]
	fsub	QWORD PTR [ecx+edi*8+8]
	mov	edi, DWORD PTR tv643[ebp]
	fstp	QWORD PTR [edx-40]
	mov	edi, DWORD PTR [edi]
	lea	edi, DWORD PTR [edi+edi*2]
	lea	ebx, DWORD PTR [eax+edi*2]
	mov	edi, DWORD PTR [esi]
	fld	QWORD PTR [ecx+ebx*8+16]
	lea	edi, DWORD PTR [edi+edi*2]
	lea	edi, DWORD PTR [eax+edi*2]
	fsub	QWORD PTR [ecx+edi*8+16]
	mov	edi, DWORD PTR tv643[ebp]
	fstp	QWORD PTR [edx-32]
	mov	edi, DWORD PTR [edi]
	lea	edi, DWORD PTR [edi+edi*2]
	lea	ebx, DWORD PTR [eax+edi*2]
	mov	edi, DWORD PTR [esi]
	fld	QWORD PTR [ecx+ebx*8+24]
	mov	ebx, DWORD PTR _sdim$[ebp]
	lea	edi, DWORD PTR [edi+edi*2]
	lea	edi, DWORD PTR [eax+edi*2]
	fsub	QWORD PTR [ecx+edi*8+24]
	add	eax, 4
	lea	edi, DWORD PTR [ebx-3]
	fstp	QWORD PTR [edx-24]
	cmp	eax, edi
	jl	$LL22@check_orie
	mov	edx, DWORD PTR _j$[ebp]
$LC20@check_orie:

; 411  :           for ( k = 0 ; k < sdim ; k++ )

	cmp	eax, ebx
	jge	SHORT $LN6@check_orie
	mov	edi, DWORD PTR tv633[ebp]
	add	edi, edx
	mov	edx, DWORD PTR _sslist$GSCopy$[ebp]
	lea	edx, DWORD PTR [edx+edi*4+4]
	mov	edi, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv643[ebp], edx
	mov	edx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [edx+edi*4]
	lea	edx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR tv595[ebp], edx
$LC4@check_orie:

; 412  :              mat[j][k] = vcoord[sslist[i].pt[j+1]][k] - vcoord[sslist[i].pt[0]][k];

	mov	edx, DWORD PTR tv643[ebp]
	mov	edx, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	edi, DWORD PTR [eax+edx*2]
	mov	edx, DWORD PTR [esi]
	fld	QWORD PTR [ecx+edi*8]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [eax+edx*2]
	fsub	QWORD PTR [ecx+edx*8]
	mov	edx, DWORD PTR tv595[ebp]
	inc	eax
	add	edx, 8
	fstp	QWORD PTR [edx-8]
	mov	DWORD PTR tv595[ebp], edx
	cmp	eax, ebx
	jl	SHORT $LC4@check_orie

; 411  :           for ( k = 0 ; k < sdim ; k++ )

	mov	edx, DWORD PTR _j$[ebp]
$LN6@check_orie:

; 408  :      { 
; 409  :         /* load matrix with side vectors of simplex */
; 410  :         for ( j = 0 ; j < sdim ; j++ )

	inc	edx
	mov	DWORD PTR _j$[ebp], edx
	cmp	edx, ebx
	jl	$LL23@check_orie
$LN5@check_orie:

; 413  : 
; 414  :         /* test and exchange if necessary */
; 415  :         if ( determinant(mat,sdim) < 0.0 )

	mov	eax, DWORD PTR _mat$[ebp]
	push	ebx
	push	eax
	call	_determinant
	fcomp	QWORD PTR __real@0000000000000000
	add	esp, 8
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@check_orie

; 416  :           { j = sslist[i].pt[0]; sslist[i].pt[0] = sslist[i].pt[1];

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], ecx

; 417  :              sslist[i].pt[1] = j;

	mov	DWORD PTR [esi+4], eax
$LN9@check_orie:

; 406  : 
; 407  :   for ( i = 0 ; i < scount ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv633[ebp], 7
	inc	eax
	add	esi, 28					; 0000001cH
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _scount
	jl	$LL25@check_orie
	pop	edi
	pop	ebx
$LN8@check_orie:

; 418  :           }
; 419  :      }
; 420  : } // end check_orientation()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_check_orientation ENDP
_TEXT	ENDS
PUBLIC	_init_hash_table
EXTRN	_kb_calloc:PROC
_BSS	SEGMENT
_simhashtable DD 01H DUP (?)
_maxload DD	01H DUP (?)
_hashmask DD	01H DUP (?)
_tablesize DD	01H DUP (?)
_hashentries DD	01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _init_hash_table
_TEXT	SEGMENT
_init_hash_table PROC					; COMDAT

; 443  : {

	push	esi

; 444  :   hashentries = 0;
; 445  :   tablesize = 64; hashmask = tablesize-1; maxload = 48;
; 446  :   while ( maxload < web.skel[EDGE].count )

	mov	esi, DWORD PTR _web+176
	mov	ecx, 48					; 00000030H
	mov	eax, 64					; 00000040H
	mov	edx, 63					; 0000003fH
	mov	DWORD PTR _hashentries, 0
	mov	DWORD PTR _tablesize, eax
	mov	DWORD PTR _hashmask, edx
	mov	DWORD PTR _maxload, ecx
	cmp	esi, ecx
	jle	SHORT $LN1@init_hash_
$LL2@init_hash_:

; 447  :      { hashmask += tablesize; tablesize *= 2; maxload *= 2; }

	add	edx, eax
	add	ecx, ecx
	add	eax, eax
	cmp	ecx, esi
	jl	SHORT $LL2@init_hash_
	mov	DWORD PTR _maxload, ecx
	mov	DWORD PTR _tablesize, eax
	mov	DWORD PTR _hashmask, edx
$LN1@init_hash_:

; 448  :   simhashtable = (struct entry *)mycalloc(tablesize,sizeof(struct entry));

	push	448					; 000001c0H
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	12					; 0000000cH
	push	eax
	call	_kb_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _simhashtable, eax
	pop	esi

; 449  : }

	ret	0
_init_hash_table ENDP
_TEXT	ENDS
PUBLIC	_end_hash_table
EXTRN	_myfree:PROC
; Function compile flags: /Ogtp
;	COMDAT _end_hash_table
_TEXT	SEGMENT
_end_hash_table PROC					; COMDAT

; 503  :   myfree((char*)simhashtable);

	mov	eax, DWORD PTR _simhashtable
	push	eax
	call	_myfree
	add	esp, 4

; 504  :   simhashtable = NULL;

	mov	DWORD PTR _simhashtable, 0

; 505  : } // end end_hash_table()

	ret	0
_end_hash_table ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_hi_dim_graph
EXTRN	_graph_edge:DWORD
EXTRN	_graph_facet:DWORD
EXTRN	_slice_coeff:BYTE
EXTRN	_slice_view_flag:DWORD
EXTRN	_eval:PROC
EXTRN	_show_expr:BYTE
EXTRN	_breakflag:DWORD
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT _hi_dim_graph
_TEXT	SEGMENT
tv1061 = -1072						; size = 4
tv2243 = -1068						; size = 4
_m$ = -1064						; size = 4
_x$89629 = -1060					; size = 4
tv4448 = -1056						; size = 4
tv2973 = -1056						; size = 4
_v$89630 = -1052					; size = 4
tv4610 = -1048						; size = 4
tv3031 = -1048						; size = 4
tv4525 = -1044						; size = 4
tv4412 = -1044						; size = 4
_ii$89645 = -1044					; size = 4
tv4523 = -1040						; size = 4
tv4410 = -1040						; size = 4
_f_id$ = -1040						; size = 4
tv2812 = -1036						; size = 4
tv2306 = -1036						; size = 4
_xx$89659 = -1036					; size = 4
tv4644 = -1032						; size = 4
tv3007 = -1032						; size = 4
tv4527 = -1028						; size = 4
tv4414 = -1028						; size = 4
tv2823 = -1028						; size = 4
_j$ = -1024						; size = 4
tv4608 = -1020						; size = 4
tv4521 = -1020						; size = 4
tv2859 = -1020						; size = 4
_k$ = -1020						; size = 4
tv4483 = -1016						; size = 4
tv4481 = -1016						; size = 4
tv4479 = -1016						; size = 4
tv4477 = -1016						; size = 4
tv4473 = -1016						; size = 4
tv4470 = -1016						; size = 4
tv4468 = -1016						; size = 4
tv4466 = -1016						; size = 4
tv4464 = -1016						; size = 4
tv4460 = -1016						; size = 4
tv4456 = -1016						; size = 4
tv4454 = -1016						; size = 4
tv4452 = -1016						; size = 4
tv4450 = -1016						; size = 4
tv4445 = -1016						; size = 4
tv1086 = -1016						; size = 4
_gdata$ = -1012						; size = 1008
__$ArrayPad$ = -4					; size = 4
_hi_dim_graph PROC					; COMDAT

; 681  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1072				; 00000430H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 682  :   struct graphdata gdata[MAXCOORD+1];
; 683  :   facet_id f_id;
; 684  :   int i,j,k,m;
; 685  : 
; 686  :   memset((char*)gdata,0,sizeof(gdata));

	push	1008					; 000003f0H
	lea	eax, DWORD PTR _gdata$[ebp]
	push	0
	push	eax
	call	_memset

; 687  :   gdata[0].flags |= LIST_FACET;
; 688  :   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+272
	or	DWORD PTR _gdata$[ebp+136], 2
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	je	$LN67@hi_dim_gra
	fldz
	push	ebx
	fld1
	push	esi
	mov	esi, DWORD PTR _web+616
	mov	ebx, eax
	mov	eax, DWORD PTR _web+236
	push	edi
$LN99@hi_dim_gra:
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv1061[ebp], edi
	je	$LN47@hi_dim_gra

; 689  :   { REAL *x;
; 690  :      vertex_id *v = get_facet_vertices(f_id);

	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+304]
	add	edx, ecx

; 691  :      if ( breakflag ) break;

	cmp	DWORD PTR _breakflag, 0
	mov	DWORD PTR _v$89630[ebp], edx
	jne	$LN119@hi_dim_gra

; 692  : 
; 693  :      if ( show_expr[FACET] && show_expr[FACET]->start )

	mov	eax, DWORD PTR _show_expr+8
	test	eax, eax
	je	SHORT $LN105@hi_dim_gra
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN105@hi_dim_gra

; 694  :        if ( !eval(show_expr[FACET],NULL,f_id,NULL) ) continue;

	push	0
	fstp	ST(1)
	push	ebx
	fstp	ST(0)
	push	0
	push	eax
	call	_eval
	fldz
	mov	esi, DWORD PTR _web+616
	fld	ST(0)
	fucomp	ST(2)
	add	esp, 16					; 00000010H
	fnstsw	ax
	fstp	ST(1)
	fld1
	test	ah, 68					; 00000044H
	jnp	$LN47@hi_dim_gra
	mov	edx, DWORD PTR _v$89630[ebp]
$LN105@hi_dim_gra:
	mov	ecx, DWORD PTR _web+236

; 695  : 
; 696  :      gdata[0].id = f_id;

	mov	DWORD PTR _gdata$[ebp+128], ebx

; 697  :      gdata[0].color = get_facet_color(f_id);

	mov	eax, DWORD PTR [edi+ecx]
	movsx	eax, WORD PTR [eax+48]
	mov	DWORD PTR _gdata$[ebp+104], eax

; 698  :      gdata[0].backcolor = get_facet_backcolor(f_id);

	mov	ecx, DWORD PTR [edi+ecx]
	mov	eax, ebx
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv1086[ebp], eax
	je	SHORT $LN51@hi_dim_gra
	movsx	eax, WORD PTR [ecx+48]
	jmp	SHORT $LN216@hi_dim_gra
$LN51@hi_dim_gra:
	movsx	eax, WORD PTR [ecx+50]
$LN216@hi_dim_gra:

; 699  :      if ( slice_view_flag )

	cmp	DWORD PTR _slice_view_flag, 0
	mov	DWORD PTR _gdata$[ebp+108], eax
	je	$LN40@hi_dim_gra

; 703  :        for ( i = 0 ; i < web.dimension ; i++ )

	cmp	DWORD PTR _web+620, 0
	mov	DWORD PTR _m$[ebp], 0
	jle	$LN37@hi_dim_gra

; 700  :      { /* do slices */
; 701  :        int ii;
; 702  :        m = 0;

	mov	ecx, DWORD PTR _v$89630[ebp]
	mov	edx, DWORD PTR _web+620
	mov	DWORD PTR tv3007[ebp], 1
	mov	DWORD PTR tv3031[ebp], ecx
	mov	DWORD PTR tv2859[ebp], edx
$LN39@hi_dim_gra:

; 704  :        { x = get_coord(v[i]);

	mov	eax, DWORD PTR tv3031[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR _web+104
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, DWORD PTR [eax+ecx+64]

; 705  :          for ( ii = i+1 ; ii <= web.dimension ; ii++ )

	mov	eax, DWORD PTR tv3007[ebp]
	mov	DWORD PTR _x$89629[ebp], edi
	mov	DWORD PTR _ii$89645[ebp], eax
	cmp	eax, DWORD PTR _web+620
	jg	$LN38@hi_dim_gra

; 704  :        { x = get_coord(v[i]);

	mov	eax, DWORD PTR _m$[ebp]
	lea	ecx, DWORD PTR [eax+eax*8]
	lea	edx, DWORD PTR [eax+eax*8]
	add	ecx, ecx
	add	edx, edx
	lea	eax, DWORD PTR _gdata$[ebp+edx*8+8]
	mov	DWORD PTR tv2823[ebp], ecx
	mov	DWORD PTR tv2973[ebp], eax
$LN36@hi_dim_gra:

; 706  :          {
; 707  :            REAL denom=0.0;
; 708  :            REAL numer=slice_coeff[SDIM];
; 709  :            REAL lambda;
; 710  :            REAL *xx = get_coord(v[ii]);

	mov	ecx, DWORD PTR _v$89630[ebp]
	fld	ST(1)
	mov	edx, DWORD PTR _ii$89645[ebp]
	fld	QWORD PTR _slice_coeff[esi*8]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	add	ebx, DWORD PTR [edx+eax+64]

; 711  :            for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	mov	DWORD PTR _xx$89659[ebp], ebx
	cmp	esi, 4
	jl	$LN100@hi_dim_gra

; 713  :              denom += slice_coeff[j]*(x[j] - xx[j]);

	mov	ecx, ebx
	add	edi, 24					; 00000018H
	lea	eax, DWORD PTR [ebx+8]
	neg	ecx
$LN82@hi_dim_gra:
	fld	QWORD PTR [eax-8]
	mov	ebx, DWORD PTR _x$89629[ebp]
	fmul	QWORD PTR _slice_coeff[edx*8]
	add	ebx, ecx
	add	edx, 4
	add	eax, 32					; 00000020H
	fsubp	ST(1), ST(0)
	add	edi, 32					; 00000020H
	fld	QWORD PTR [eax-32]
	fmul	QWORD PTR _slice_coeff[ecx+eax-32]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [eax-24]
	fmul	QWORD PTR _slice_coeff[ecx+eax-24]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR _slice_coeff[ecx+eax-16]
	fmul	QWORD PTR [eax-16]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [edi-56]
	fsub	QWORD PTR [eax-40]
	fmul	QWORD PTR _slice_coeff[edx*8-32]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [ebx+eax-32]
	lea	ebx, DWORD PTR [esi-3]
	fsub	QWORD PTR [eax-32]
	fmul	QWORD PTR _slice_coeff[ecx+eax-32]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edi-40]
	fsub	QWORD PTR [eax-24]
	fmul	QWORD PTR _slice_coeff[ecx+eax-24]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [edi-32]
	fsub	QWORD PTR [eax-16]
	fmul	QWORD PTR _slice_coeff[ecx+eax-16]
	faddp	ST(2), ST(0)
	cmp	edx, ebx
	jl	$LN82@hi_dim_gra
	mov	ebx, DWORD PTR _xx$89659[ebp]
	mov	edi, DWORD PTR _x$89629[ebp]
$LN100@hi_dim_gra:

; 711  :            for ( j = 0 ; j < SDIM ; j++ )

	cmp	edx, esi
	jge	SHORT $LN106@hi_dim_gra
	mov	ecx, ebx
	neg	ecx
	add	edi, ecx
	mov	DWORD PTR tv2812[ebp], edi
	mov	edi, esi
	lea	eax, DWORD PTR [ebx+edx*8]
	sub	edi, edx
	mov	edx, DWORD PTR tv2812[ebp]
$LC33@hi_dim_gra:

; 712  :            { numer -= slice_coeff[j]*xx[j];

	fld	QWORD PTR _slice_coeff[eax+ecx]
	add	eax, 8
	dec	edi
	fmul	QWORD PTR [eax-8]
	fsubp	ST(1), ST(0)

; 713  :              denom += slice_coeff[j]*(x[j] - xx[j]);

	fld	QWORD PTR [eax+edx-8]
	fsub	QWORD PTR [eax-8]
	fmul	QWORD PTR _slice_coeff[eax+ecx-8]
	faddp	ST(2), ST(0)
	jne	SHORT $LC33@hi_dim_gra

; 711  :            for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _x$89629[ebp]
$LN106@hi_dim_gra:

; 714  :            }
; 715  :            if ( denom == 0.0 )

	fld	ST(1)
	fld	ST(4)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN155@hi_dim_gra

; 716  :              continue;
; 717  :            lambda = numer/denom;

	fdivrp	ST(1), ST(0)

; 718  :            if ( (lambda < 0.0) || (lambda > 1.0) )

	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jnp	$LN161@hi_dim_gra
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN161@hi_dim_gra

; 719  :              continue;
; 720  :            for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	esi, 4
	jl	$LN108@hi_dim_gra

; 721  :              gdata[m].x[j] = lambda*x[j] + (1-lambda)*xx[j];

	mov	edx, ebx
	fld	ST(1)
	sub	edx, edi
	fsub	ST(0), ST(1)
	mov	DWORD PTR tv2306[ebp], edx
	lea	edx, DWORD PTR [esi-4]
	shr	edx, 2
	lea	ecx, DWORD PTR [ebx+24]
	lea	eax, DWORD PTR [edi+8]
	inc	edx
	lea	edi, DWORD PTR [edx*4]
	mov	DWORD PTR tv2243[ebp], ecx
	mov	ecx, DWORD PTR tv2973[ebp]
	mov	DWORD PTR _j$[ebp], edi
	mov	edi, DWORD PTR tv2243[ebp]
$LN85@hi_dim_gra:
	fld	QWORD PTR [edi-24]
	mov	edi, DWORD PTR tv2306[ebp]
	fmul	ST(0), ST(1)
	add	eax, 32					; 00000020H
	fld	QWORD PTR [eax-40]
	add	ecx, 32					; 00000020H
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx-40]
	fld	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv2243[ebp]
	fmul	ST(0), ST(1)
	add	edi, 32					; 00000020H
	dec	edx
	fld	QWORD PTR [eax-32]
	fmul	ST(0), ST(3)
	mov	DWORD PTR tv2243[ebp], edi
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx-32]
	fld	QWORD PTR [edi-40]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [eax-24]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx-24]
	fld	QWORD PTR [eax-16]
	fmul	ST(0), ST(2)
	fld	QWORD PTR [edi-32]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx-16]
	jne	SHORT $LN85@hi_dim_gra

; 719  :              continue;
; 720  :            for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _x$89629[ebp]
	fstp	ST(0)
	mov	ecx, DWORD PTR _j$[ebp]
$LN108@hi_dim_gra:
	cmp	ecx, esi
	jge	SHORT $LN170@hi_dim_gra
	mov	edx, DWORD PTR tv2823[ebp]
	fld	ST(1)
	add	edx, ecx
	fsub	ST(0), ST(1)
	lea	eax, DWORD PTR [edi+ecx*8]
	sub	ebx, edi
	mov	ecx, esi
	sub	ecx, DWORD PTR _j$[ebp]
	lea	edx, DWORD PTR _gdata$[ebp+edx*8]
	mov	DWORD PTR tv2306[ebp], ebx
$LC27@hi_dim_gra:

; 721  :              gdata[m].x[j] = lambda*x[j] + (1-lambda)*xx[j];

	fld	QWORD PTR [eax+ebx]
	add	eax, 8
	fmul	ST(0), ST(1)
	add	edx, 8
	dec	ecx
	fld	ST(2)
	fmul	QWORD PTR [eax-8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx-8]
	jne	SHORT $LC27@hi_dim_gra

; 719  :              continue;
; 720  :            for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(1)
$LN170@hi_dim_gra:

; 722  :            m++;

	inc	DWORD PTR _m$[ebp]
	add	DWORD PTR tv2973[ebp], 144		; 00000090H
	add	DWORD PTR tv2823[ebp], 18		; 00000012H
	jmp	SHORT $LN161@hi_dim_gra
$LN155@hi_dim_gra:
	fstp	ST(1)
$LN161@hi_dim_gra:

; 705  :          for ( ii = i+1 ; ii <= web.dimension ; ii++ )

	mov	eax, DWORD PTR _ii$89645[ebp]

; 718  :            if ( (lambda < 0.0) || (lambda > 1.0) )

	fstp	ST(0)
	inc	eax
	mov	DWORD PTR _ii$89645[ebp], eax
	cmp	eax, DWORD PTR _web+620
	jle	$LN36@hi_dim_gra
$LN38@hi_dim_gra:

; 703  :        for ( i = 0 ; i < web.dimension ; i++ )

	add	DWORD PTR tv3031[ebp], 4
	mov	eax, 1
	add	DWORD PTR tv3007[ebp], eax
	sub	DWORD PTR tv2859[ebp], eax
	jne	$LN39@hi_dim_gra
$LN37@hi_dim_gra:

; 723  :          }
; 724  :        }
; 725  :        for ( i = 0 ; i <= m-FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _m$[ebp]
	add	eax, -3					; fffffffdH
	js	SHORT $LN47@hi_dim_gra
	mov	edi, DWORD PTR tv1061[ebp]
	fstp	ST(1)
	fstp	ST(0)
	lea	esi, DWORD PTR _gdata$[ebp+104]
	lea	ebx, DWORD PTR [eax+1]
$LL95@hi_dim_gra:

; 726  :        { gdata[i].id = f_id;
; 727  :          gdata[i].color = get_facet_color(f_id);
; 728  :          gdata[i].backcolor = get_facet_backcolor(f_id);

	cmp	DWORD PTR tv1086[ebp], 0
	mov	ecx, DWORD PTR _f_id$[ebp]
	mov	eax, DWORD PTR _web+236
	mov	DWORD PTR [esi+24], ecx
	mov	edx, DWORD PTR [edi+eax]
	movsx	ecx, WORD PTR [edx+48]
	mov	DWORD PTR [esi], ecx
	je	SHORT $LN53@hi_dim_gra
	mov	edx, DWORD PTR [edi+eax]
	movsx	eax, WORD PTR [edx+48]
	jmp	SHORT $LN54@hi_dim_gra
$LN53@hi_dim_gra:
	mov	eax, DWORD PTR [edi+eax]
	movsx	eax, WORD PTR [eax+50]
$LN54@hi_dim_gra:

; 729  :          (*graph_facet)(gdata+i,NULLID);

	lea	ecx, DWORD PTR [esi-104]
	push	0
	push	ecx
	mov	DWORD PTR [esi+4], eax
	call	DWORD PTR _graph_facet
	add	esp, 8
	add	esi, 144				; 00000090H
	dec	ebx
	jne	SHORT $LL95@hi_dim_gra

; 730  :        }
; 731  :      }
; 732  :      else

	fld1
	mov	esi, DWORD PTR _web+616
	fldz
	fxch	ST(1)
$LN47@hi_dim_gra:

; 687  :   gdata[0].flags |= LIST_FACET;
; 688  :   FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR tv1061[ebp]
	mov	eax, DWORD PTR _web+236
	mov	edx, DWORD PTR [ecx+eax]
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR _f_id$[ebp], ebx
	test	ebx, 268435456				; 10000000H
	jne	$LN99@hi_dim_gra
$LN119@hi_dim_gra:
	pop	edi

; 691  :      if ( breakflag ) break;

	fstp	ST(1)
	pop	esi
	fstp	ST(0)
	pop	ebx
$LN67@hi_dim_gra:

; 754  :           }
; 755  :        }
; 756  :      }
; 757  :   }
; 758  : } // end hi_dim_graph()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@hi_dim_gra:

; 733  :      /* do all combos of 3 vertices */
; 734  :      for ( i = 0 ; i <= web.dimension ; i++ ) 

	cmp	DWORD PTR _web+620, 0
	jl	SHORT $LN47@hi_dim_gra
	mov	eax, edx
	mov	DWORD PTR tv4610[ebp], 1
	mov	DWORD PTR tv4644[ebp], eax
	jmp	SHORT $LN20@hi_dim_gra
$LN103@hi_dim_gra:
	mov	eax, DWORD PTR tv4644[ebp]
$LN20@hi_dim_gra:

; 735  :      { gdata[0].v_id = v[i]; /* for those who can use it */

	mov	edx, DWORD PTR [eax]

; 736  :        x = get_coord(v[i]);

	mov	ecx, DWORD PTR _web+12
	mov	DWORD PTR _gdata$[ebp+132], edx
	mov	eax, DWORD PTR [eax]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+ecx+64]

; 737  :        for ( m = 0 ; m < SDIM ; m++ )

	xor	ecx, ecx
	cmp	esi, 4
	jl	$LC87@hi_dim_gra

; 738  :          gdata[0].x[m] = (float)x[m];

	mov	edi, edx
	neg	edi
	lea	ebx, DWORD PTR _gdata$[ebp+edi]
	lea	edi, DWORD PTR _gdata$[ebp+edi+8]
	lea	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv4608[ebp], edi
$LN109@hi_dim_gra:
	fld	QWORD PTR [eax-16]
	mov	edi, DWORD PTR tv4608[ebp]
	fstp	DWORD PTR tv4483[ebp]
	add	ecx, 4
	fld	DWORD PTR tv4483[ebp]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR _gdata$[ebp+ecx*8-32]
	fld	QWORD PTR [eax-40]
	fstp	DWORD PTR tv4481[ebp]
	fld	DWORD PTR tv4481[ebp]
	fstp	QWORD PTR _gdata$[ebp+ecx*8-24]
	fld	QWORD PTR [eax-32]
	fstp	DWORD PTR tv4479[ebp]
	fld	DWORD PTR tv4479[ebp]
	fstp	QWORD PTR [ebx+eax-32]
	fld	QWORD PTR [eax-24]
	fstp	DWORD PTR tv4477[ebp]
	fld	DWORD PTR tv4477[ebp]
	fstp	QWORD PTR [edi+eax-32]
	lea	edi, DWORD PTR [esi-3]
	cmp	ecx, edi
	jl	SHORT $LN109@hi_dim_gra
$LC87@hi_dim_gra:

; 737  :        for ( m = 0 ; m < SDIM ; m++ )

	cmp	ecx, esi
	jge	SHORT $LN86@hi_dim_gra
	lea	eax, DWORD PTR _gdata$[ebp]
	sub	edx, eax
$LC17@hi_dim_gra:
	lea	eax, DWORD PTR [edx+ecx*8]

; 738  :          gdata[0].x[m] = (float)x[m];

	fld	QWORD PTR _gdata$[ebp+eax]
	inc	ecx
	fstp	DWORD PTR tv4473[ebp]
	fld	DWORD PTR tv4473[ebp]
	fstp	QWORD PTR _gdata$[ebp+ecx*8-8]
	cmp	ecx, esi
	jl	SHORT $LC17@hi_dim_gra
$LN86@hi_dim_gra:

; 739  :        for ( j = i+1 ; j <= web.dimension ; j++ ) 

	mov	eax, DWORD PTR tv4610[ebp]
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _web+620
	jg	$LN19@hi_dim_gra
$LN14@hi_dim_gra:

; 740  :        { gdata[1].v_id = v[j]; /* for those who can use it */

	mov	eax, DWORD PTR _v$89630[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]

; 741  :           x = get_coord(v[j]);

	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR _gdata$[ebp+276], edx
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+edi+64]

; 742  :           for ( m = 0 ; m < SDIM ; m++ )

	xor	ebx, ebx
	cmp	esi, 4
	jl	$LN101@hi_dim_gra

; 743  :                gdata[1].x[m] = (float)x[m];

	mov	ecx, edx
	neg	ecx
	lea	edi, DWORD PTR _gdata$[ebp+ecx+128]
	mov	DWORD PTR tv4521[ebp], edi
	lea	edi, DWORD PTR _gdata$[ebp+ecx+136]
	mov	DWORD PTR tv4523[ebp], edi
	lea	edi, DWORD PTR _gdata$[ebp+ecx+144]
	lea	ecx, DWORD PTR _gdata$[ebp+ecx+152]
	mov	DWORD PTR tv4527[ebp], ecx
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv4525[ebp], edi
	lea	ebx, DWORD PTR [ecx*4]
$LN104@hi_dim_gra:
	fld	QWORD PTR [eax-16]
	mov	edi, DWORD PTR tv4521[ebp]
	fstp	DWORD PTR tv4470[ebp]
	add	eax, 32					; 00000020H
	dec	ecx
	fld	DWORD PTR tv4470[ebp]
	fstp	QWORD PTR [eax+edi-32]
	mov	edi, DWORD PTR tv4523[ebp]
	fld	QWORD PTR [eax-40]
	fstp	DWORD PTR tv4468[ebp]
	fld	DWORD PTR tv4468[ebp]
	fstp	QWORD PTR [eax+edi-32]
	mov	edi, DWORD PTR tv4525[ebp]
	fld	QWORD PTR [eax-32]
	fstp	DWORD PTR tv4466[ebp]
	fld	DWORD PTR tv4466[ebp]
	fstp	QWORD PTR [eax+edi-32]
	mov	edi, DWORD PTR tv4527[ebp]
	fld	QWORD PTR [eax-24]
	fstp	DWORD PTR tv4464[ebp]
	fld	DWORD PTR tv4464[ebp]
	fstp	QWORD PTR [eax+edi-32]
	jne	SHORT $LN104@hi_dim_gra

; 740  :        { gdata[1].v_id = v[j]; /* for those who can use it */

	mov	ecx, DWORD PTR _j$[ebp]
$LN101@hi_dim_gra:

; 742  :           for ( m = 0 ; m < SDIM ; m++ )

	cmp	ebx, esi
	jge	SHORT $LN110@hi_dim_gra
	lea	eax, DWORD PTR _gdata$[ebp+144]
	sub	edx, eax
$LC11@hi_dim_gra:
	lea	eax, DWORD PTR [edx+ebx*8]

; 743  :                gdata[1].x[m] = (float)x[m];

	fld	QWORD PTR _gdata$[ebp+eax+144]
	inc	ebx
	fstp	DWORD PTR tv4460[ebp]
	fld	DWORD PTR tv4460[ebp]
	fstp	QWORD PTR _gdata$[ebp+ebx*8+136]
	cmp	ebx, esi
	jl	SHORT $LC11@hi_dim_gra
$LN110@hi_dim_gra:

; 744  :           if ( web.representation == STRING ) 

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN8@hi_dim_gra

; 745  :              (*graph_edge)(gdata,NULLID);

	lea	ecx, DWORD PTR _gdata$[ebp]
	fstp	ST(1)
	push	0
	fstp	ST(0)
	push	ecx
	call	DWORD PTR _graph_edge

; 746  :           else

	mov	esi, DWORD PTR _web+616
	add	esp, 8
	jmp	$LN217@hi_dim_gra
$LN8@hi_dim_gra:

; 739  :        for ( j = i+1 ; j <= web.dimension ; j++ ) 

	lea	ebx, DWORD PTR [ecx+1]
	mov	DWORD PTR _k$[ebp], ebx

; 747  :           for ( k = j+1 ; k <= web.dimension ; k++ )

	cmp	ebx, DWORD PTR _web+620
	jg	$LN13@hi_dim_gra
	fstp	ST(1)
	fstp	ST(0)
	npad	12
$LL6@hi_dim_gra:

; 748  :           { 
; 749  :              gdata[2].v_id = v[k]; /* for those who can use it */

	mov	eax, DWORD PTR _v$89630[ebp]
	mov	edx, DWORD PTR [eax+ebx*4]

; 750  :              x = get_coord(v[k]);

	mov	ecx, DWORD PTR _web+12
	mov	DWORD PTR _gdata$[ebp+420], edx
	mov	eax, DWORD PTR [eax+ebx*4]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	add	edx, DWORD PTR [ecx+eax+64]

; 751  :              for ( m = 0 ; m < SDIM ; m++ )

	xor	edi, edi
	cmp	esi, 4
	jl	$LC93@hi_dim_gra

; 752  :                gdata[2].x[m] = (float)x[m];

	mov	ecx, edx
	neg	ecx
	lea	edi, DWORD PTR _gdata$[ebp+ecx+272]
	mov	DWORD PTR tv4410[ebp], edi
	lea	edi, DWORD PTR _gdata$[ebp+ecx+280]
	mov	DWORD PTR tv4412[ebp], edi
	lea	edi, DWORD PTR _gdata$[ebp+ecx+288]
	lea	ecx, DWORD PTR _gdata$[ebp+ecx+296]
	mov	DWORD PTR tv4448[ebp], ecx
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	inc	ecx
	mov	DWORD PTR tv4414[ebp], edi
	lea	eax, DWORD PTR [edx+16]
	lea	edi, DWORD PTR [ecx*4]
	npad	13
$LL98@hi_dim_gra:
	fld	QWORD PTR [eax-16]
	mov	ebx, DWORD PTR tv4410[ebp]
	fstp	DWORD PTR tv4456[ebp]
	add	eax, 32					; 00000020H
	dec	ecx
	fld	DWORD PTR tv4456[ebp]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv4412[ebp]
	fld	QWORD PTR [eax-40]
	fstp	DWORD PTR tv4454[ebp]
	fld	DWORD PTR tv4454[ebp]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv4414[ebp]
	fld	QWORD PTR [eax-32]
	fstp	DWORD PTR tv4452[ebp]
	fld	DWORD PTR tv4452[ebp]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv4448[ebp]
	fld	QWORD PTR [eax-24]
	fstp	DWORD PTR tv4450[ebp]
	fld	DWORD PTR tv4450[ebp]
	fstp	QWORD PTR [ebx+eax-32]
	jne	SHORT $LL98@hi_dim_gra

; 748  :           { 
; 749  :              gdata[2].v_id = v[k]; /* for those who can use it */

	mov	ebx, DWORD PTR _k$[ebp]
$LC93@hi_dim_gra:

; 751  :              for ( m = 0 ; m < SDIM ; m++ )

	cmp	edi, esi
	jge	SHORT $LN102@hi_dim_gra
	lea	eax, DWORD PTR _gdata$[ebp+288]
	sub	edx, eax
	npad	4
$LC3@hi_dim_gra:
	lea	ecx, DWORD PTR [edx+edi*8]

; 752  :                gdata[2].x[m] = (float)x[m];

	fld	QWORD PTR _gdata$[ebp+ecx+288]
	inc	edi
	fstp	DWORD PTR tv4445[ebp]
	fld	DWORD PTR tv4445[ebp]
	fstp	QWORD PTR _gdata$[ebp+edi*8+280]
	cmp	edi, esi
	jl	SHORT $LC3@hi_dim_gra
$LN102@hi_dim_gra:

; 753  :              (*graph_facet)(gdata,NULLID);

	lea	edx, DWORD PTR _gdata$[ebp]
	push	0
	push	edx
	call	DWORD PTR _graph_facet
	mov	esi, DWORD PTR _web+616
	inc	ebx
	add	esp, 8
	mov	DWORD PTR _k$[ebp], ebx
	cmp	ebx, DWORD PTR _web+620
	jle	$LL6@hi_dim_gra
$LN217@hi_dim_gra:

; 747  :           for ( k = j+1 ; k <= web.dimension ; k++ )

	fld1
	fldz
	fxch	ST(1)
$LN13@hi_dim_gra:

; 739  :        for ( j = i+1 ; j <= web.dimension ; j++ ) 

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _web+620
	jle	$LN14@hi_dim_gra
$LN19@hi_dim_gra:

; 733  :      /* do all combos of 3 vertices */
; 734  :      for ( i = 0 ; i <= web.dimension ; i++ ) 

	mov	eax, DWORD PTR tv4610[ebp]
	add	DWORD PTR tv4644[ebp], 4
	inc	eax
	mov	DWORD PTR tv4610[ebp], eax
	dec	eax
	cmp	eax, DWORD PTR _web+620
	jle	$LN103@hi_dim_gra
	jmp	$LN47@hi_dim_gra
_hi_dim_graph ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_calc_simplex_edge_energy
EXTRN	_exterior_product:PROC
EXTRN	_nullcon:QWORD
; Function compile flags: /Ogtp
;	COMDAT _calc_simplex_edge_energy
_TEXT	SEGMENT
_sides$ = -656						; size = 24
_x$ = -632						; size = 24
tv447 = -608						; size = 8
_energy$ = -600						; size = 8
_sign$ = -592						; size = 4
_conmap$ = -588						; size = 4
tv663 = -584						; size = 4
_j$ = -584						; size = 4
_side$ = -580						; size = 288
_green$ = -292						; size = 120
_kvector$ = -172					; size = 120
_midpt$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_mode$ = 12						; size = 4
_calc_simplex_edge_energy PROC				; COMDAT

; 772  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 656				; 00000290H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 773  :   struct constraint *constr;
; 774  :   int i,j,k,m;
; 775  :   REAL energy = 0.0;

	fldz

; 776  :   REAL side[MAXCOORD][MAXCOORD];
; 777  :   REAL *sides[MAXCOORD];
; 778  :   REAL green[MAXCONCOMP];
; 779  :   conmap_t *conmap;
; 780  :   REAL midpt[MAXCOORD];  /* evaluation point for integrand */
; 781  :   int sign;
; 782  :   REAL kvector[MAXCONCOMP];  /* k-vector representing simplex */
; 783  :   REAL *x[MAXCOORD];
; 784  :   vertex_id *v;
; 785  : 
; 786  :   conmap = get_e_constraint_map(e_id);

	mov	edx, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	fstp	QWORD PTR _energy$[ebp]
	cmp	DWORD PTR [edx+ecx+1048], 0
	mov	eax, DWORD PTR _web+124
	push	ebx
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	push	edi
	je	SHORT $LN28@calc_simpl@4
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+edi*4]
	add	edi, DWORD PTR [edx+ecx+1024]
	mov	DWORD PTR _conmap$[ebp], edi
	jmp	SHORT $LN29@calc_simpl@4
$LN28@calc_simpl@4:
	mov	DWORD PTR _conmap$[ebp], OFFSET _nullcon
	mov	edi, DWORD PTR _conmap$[ebp]
$LN29@calc_simpl@4:

; 787  :   if ( get_eattr(e_id) & NEGBOUNDARY ) sign = -1;

	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 256				; 00000100H
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN25@calc_simpl@4
	or	eax, -1
	jmp	SHORT $LN55@calc_simpl@4
$LN25@calc_simpl@4:

; 788  :   else sign = 1;

	mov	eax, 1
$LN55@calc_simpl@4:
	mov	DWORD PTR _sign$[ebp], eax

; 789  :   if ( inverted(e_id) ) sign = -sign;

	test	esi, 134217728				; 08000000H
	je	SHORT $LN23@calc_simpl@4
	neg	eax
	mov	DWORD PTR _sign$[ebp], eax
$LN23@calc_simpl@4:

; 790  : 
; 791  :   v = get_edge_vertices(e_id);

	mov	eax, DWORD PTR _web+216
	mov	ebx, DWORD PTR [eax+ecx+304]

; 792  :   x[0] = get_coord(v[0]);

	mov	eax, DWORD PTR _web+12
	add	ebx, edx
	mov	edx, DWORD PTR [ebx]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+ecx+64]

; 793  :   for ( k = 1 ; k < web.dimension ; k++ )

	mov	eax, DWORD PTR _web+620
	mov	esi, 1
	mov	DWORD PTR _x$[ebp], edx
	cmp	eax, esi
	jle	$LN45@calc_simpl@4

; 790  : 
; 791  :   v = get_edge_vertices(e_id);

	lea	edi, DWORD PTR _side$[ebp]
	mov	DWORD PTR tv663[ebp], edi
	npad	6
$LL47@calc_simpl@4:

; 794  :       {  x[k] = get_coord(v[k]);

	mov	edx, DWORD PTR [ebx+esi*4]
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ecx+64]
	add	edx, eax

; 795  :           for ( j = 0 ; j < SDIM ; j++ )

	cmp	DWORD PTR _web+616, 0
	mov	DWORD PTR _x$[ebp+esi*4], edx
	jle	SHORT $LN46@calc_simpl@4

; 794  :       {  x[k] = get_coord(v[k]);

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, edi
	mov	edi, DWORD PTR _web+616

; 795  :           for ( j = 0 ; j < SDIM ; j++ )

	sub	edx, eax
	npad	4
$LL19@calc_simpl@4:

; 796  :              side[k-1][j] = x[k][j] - x[0][j];

	fld	QWORD PTR [edx+eax]
	add	eax, 8
	fsub	QWORD PTR [eax-8]
	add	ecx, 8
	dec	edi
	fstp	QWORD PTR [ecx-8]
	jne	SHORT $LL19@calc_simpl@4

; 795  :           for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _dymem
	mov	edi, DWORD PTR tv663[ebp]
$LN46@calc_simpl@4:

; 797  :           sides[k-1] = side[k-1];  /* pointers for matrix routines */

	mov	eax, DWORD PTR _web+620
	mov	DWORD PTR _sides$[ebp+esi*4-4], edi
	inc	esi
	add	edi, 48					; 00000030H
	mov	DWORD PTR tv663[ebp], edi
	cmp	esi, eax
	jl	SHORT $LL47@calc_simpl@4

; 793  :   for ( k = 1 ; k < web.dimension ; k++ )

	mov	edi, DWORD PTR _conmap$[ebp]
$LN45@calc_simpl@4:

; 798  :       }
; 799  :   exterior_product(sides,kvector,web.dimension-1,SDIM);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	dec	eax
	push	eax
	lea	edx, DWORD PTR _kvector$[ebp]
	push	edx
	lea	eax, DWORD PTR _sides$[ebp]
	push	eax
	call	_exterior_product

; 800  : 
; 801  :   for ( j = 1 ; j <= (int)conmap[0]; j++ )

	mov	ebx, 1
	add	esp, 16					; 00000010H
	mov	DWORD PTR _j$[ebp], ebx
	cmp	DWORD PTR [edi], ebx
	jl	$LN44@calc_simpl@4
$LL16@calc_simpl@4:

; 802  :     {
; 803  :      constr = get_constraint(conmap[j]&CONMASK);

	mov	esi, DWORD PTR [edi+ebx*4]
	and	esi, 1073741823				; 3fffffffH
	imul	esi, 176				; 000000b0H
	add	esi, DWORD PTR _web+652

; 804  :      if ( !(constr->attr & CON_ENERGY) ) continue;

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+32]
	and	eax, 64					; 00000040H
	or	eax, ecx
	je	$LN15@calc_simpl@4
	fild	DWORD PTR _sign$[ebp]
	fstp	QWORD PTR tv447[ebp]

; 805  :      for ( k = 0 ; k < 1 /* gauss1D_num */ ; k++ )
; 806  :       {
; 807  :          for ( i = 0 ; i < SDIM ; i++ )

	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN7@calc_simpl@4
	mov	edx, DWORD PTR _web+620
	fldz
$LN9@calc_simpl@4:

; 808  :             { midpt[i] = 0.0;
; 809  :               for ( m = 0 ; m < web.dimension ; m++ )

	xor	eax, eax
	fst	QWORD PTR _midpt$[ebp+ecx*8]
	test	edx, edx
	jle	SHORT $LN8@calc_simpl@4
	fild	DWORD PTR _web+620
$LN6@calc_simpl@4:

; 810  :                  midpt[i] += x[m][i]/web.dimension;

	mov	edi, DWORD PTR _x$[ebp+eax*4]
	fld	QWORD PTR [edi+ecx*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR _midpt$[ebp+ecx*8]
	fstp	QWORD PTR _midpt$[ebp+ecx*8]
	cmp	eax, edx
	jl	SHORT $LN6@calc_simpl@4

; 808  :             { midpt[i] = 0.0;
; 809  :               for ( m = 0 ; m < web.dimension ; m++ )

	fstp	ST(0)
$LN8@calc_simpl@4:

; 805  :      for ( k = 0 ; k < 1 /* gauss1D_num */ ; k++ )
; 806  :       {
; 807  :          for ( i = 0 ; i < SDIM ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN9@calc_simpl@4
	fstp	ST(0)
$LN7@calc_simpl@4:

; 811  :             }
; 812  :          for ( i = 0 ; i < constr->compcount ; i++ )

	xor	edi, edi
	cmp	DWORD PTR [esi+44], edi
	jle	SHORT $LN1@calc_simpl@4
	lea	ebx, DWORD PTR [esi+48]
$LL3@calc_simpl@4:

; 813  :                 green[i] = eval(constr->envect[i],midpt,NULLID,NULL);

	mov	edx, DWORD PTR [ebx]
	push	0
	push	0
	lea	ecx, DWORD PTR _midpt$[ebp]
	push	ecx
	push	edx
	call	_eval
	fstp	QWORD PTR _green$[ebp+edi*8]
	inc	edi
	add	esp, 16					; 00000010H
	add	ebx, 4
	cmp	edi, DWORD PTR [esi+44]
	jl	SHORT $LL3@calc_simpl@4

; 811  :             }
; 812  :          for ( i = 0 ; i < constr->compcount ; i++ )

	mov	ebx, DWORD PTR _j$[ebp]
$LN1@calc_simpl@4:

; 814  :          energy += sign*dot(kvector,green,constr->compcount);

	mov	eax, DWORD PTR [esi+44]
	push	eax
	lea	ecx, DWORD PTR _green$[ebp]
	push	ecx
	lea	edx, DWORD PTR _kvector$[ebp]
	push	edx
	call	_dot
	fmul	QWORD PTR tv447[ebp]
	mov	edi, DWORD PTR _conmap$[ebp]
	add	esp, 12					; 0000000cH
	fadd	QWORD PTR _energy$[ebp]
	fstp	QWORD PTR _energy$[ebp]
$LN15@calc_simpl@4:

; 800  : 
; 801  :   for ( j = 1 ; j <= (int)conmap[0]; j++ )

	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, DWORD PTR [edi]
	jle	$LL16@calc_simpl@4
$LN44@calc_simpl@4:

; 815  :       }
; 816  : 
; 817  :     }
; 818  : 
; 819  :   binary_tree_add(web.total_energy_addends,
; 820  :             energy/web.simplex_factorial*web.dimension);

	fld	QWORD PTR _energy$[ebp]
	sub	esp, 8
	fdiv	QWORD PTR _web+792
	fimul	DWORD PTR _web+620
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1248
	call	_binary_tree_add

; 821  :  
; 822  : } // end calc_simplex_edge_energy()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_calc_simplex_edge_energy ENDP
_TEXT	ENDS
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_calc_simplex_edge_force
EXTRN	_identmat:DWORD
EXTRN	_eval_all:PROC
; Function compile flags: /Ogtp
;	COMDAT _calc_simplex_edge_force
_TEXT	SEGMENT
_sides$ = -1440						; size = 24
_x$ = -1416						; size = 24
_fudge$ = -1392						; size = 8
_e_id$GSCopy$ = -1384					; size = 4
_tforce$ = -1380					; size = 4
tv3666 = -1376						; size = 4
_v$ = -1372						; size = 4
_conmap$ = -1368					; size = 4
tv3826 = -1364						; size = 4
tv1640 = -1364						; size = 4
_j$ = -1364						; size = 4
tv2210 = -1360						; size = 4
_constr$ = -1360					; size = 4
tv3690 = -1356						; size = 4
tv1171 = -1356						; size = 4
_k$ = -1356						; size = 4
tv2070 = -1352						; size = 4
_m$ = -1352						; size = 4
_i$ = -1352						; size = 4
_green_deriv$ = -1348					; size = 720
_side$ = -628						; size = 288
_green$ = -340						; size = 120
_grad$ = -220						; size = 48
_kvector$ = -172					; size = 120
_midpt$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_calc_simplex_edge_force PROC				; COMDAT

; 834  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1440				; 000005a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 835  :   struct constraint *constr;
; 836  :   int i,j,k,m;
; 837  :   REAL *hforce,*tforce;
; 838  :   REAL side[MAXCOORD][MAXCOORD];
; 839  :   REAL *sides[MAXCOORD];
; 840  :   REAL green[MAXCONCOMP];
; 841  :   REAL green_deriv[MAXCONCOMP][MAXCOORD];
; 842  :   conmap_t * conmap;
; 843  :   REAL midpt[MAXCOORD];  /* evaluation point for integrand */
; 844  :   int sign;
; 845  :   REAL kvector[MAXCONCOMP];  /* k-vector representing simplex */
; 846  :   REAL *x[MAXCOORD];
; 847  :   vertex_id *v;
; 848  :   REAL fudge = web.simplex_factorial/web.dimension;

	fild	DWORD PTR _web+620

; 849  :   REAL grad[MAXCOORD];
; 850  : 
; 851  :   conmap = get_e_constraint_map(e_id);

	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	cmp	DWORD PTR [eax+ecx+1048], 0
	fdivr	QWORD PTR _web+792
	mov	edx, DWORD PTR _e_id$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _web+124
	push	edi

; 895  :             { REAL f;
; 896  :               sides[i] = identmat[m];

	mov	DWORD PTR _e_id$GSCopy$[ebp], edx
	fstp	QWORD PTR _fudge$[ebp]
	je	SHORT $LN46@calc_simpl@5

; 849  :   REAL grad[MAXCOORD];
; 850  : 
; 851  :   conmap = get_e_constraint_map(e_id);

	mov	edi, edx
	and	edi, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [esi+edi*4]
	add	ebx, DWORD PTR [eax+ecx+1024]
	mov	DWORD PTR _conmap$[ebp], ebx
	jmp	SHORT $LN47@calc_simpl@5
$LN46@calc_simpl@5:
	mov	DWORD PTR _conmap$[ebp], OFFSET _nullcon
	mov	ebx, DWORD PTR _conmap$[ebp]
$LN47@calc_simpl@5:

; 852  :   if ( get_eattr(e_id) & NEGBOUNDARY ) sign = -1;
; 853  :   else sign = 1;
; 854  :   if ( inverted(e_id) ) sign = -sign;
; 855  : 
; 856  :   v = get_edge_vertices(e_id);

	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+edx*4]
	add	esi, DWORD PTR [eax+ecx+304]

; 857  :   x[0] = get_coord(v[0]);

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [esi]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+104
	add	eax, DWORD PTR [edx+ecx+64]
	mov	DWORD PTR _v$[ebp], esi
	mov	DWORD PTR _x$[ebp], eax

; 858  :   for ( k = 1 ; k < web.dimension ; k++ )

	mov	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR _web+620, eax
	jle	$LN85@calc_simpl@5

; 852  :   if ( get_eattr(e_id) & NEGBOUNDARY ) sign = -1;
; 853  :   else sign = 1;
; 854  :   if ( inverted(e_id) ) sign = -sign;
; 855  : 
; 856  :   v = get_edge_vertices(e_id);

	lea	edx, DWORD PTR _side$[ebp]
	mov	DWORD PTR tv2070[ebp], 6
	mov	DWORD PTR tv2210[ebp], edx
	npad	7
$LL90@calc_simpl@5:

; 859  :       {  x[k] = get_coord(v[k]);

	mov	edx, DWORD PTR [esi+eax*4]
	mov	edi, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR _web+104
	mov	edi, DWORD PTR [edi+ecx+64]
	add	edx, edi

; 860  :           for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	cmp	DWORD PTR _web+616, 4
	mov	DWORD PTR _x$[ebp+eax*4], edx
	mov	ebx, DWORD PTR _x$[ebp]
	jl	SHORT $LC75@calc_simpl@5

; 859  :       {  x[k] = get_coord(v[k]);

	mov	ecx, DWORD PTR tv2210[ebp]
	lea	esi, DWORD PTR [edx+24]

; 861  :              side[k-1][j] = x[k][j] - x[0][j];

	sub	edx, ebx
	mov	DWORD PTR tv1640[ebp], edx
	mov	edx, DWORD PTR _web+616
	add	edx, -4					; fffffffcH
	shr	edx, 2
	add	ecx, 8
	inc	edx
	lea	eax, DWORD PTR [ebx+8]
	lea	edi, DWORD PTR [edx*4]
$LL76@calc_simpl@5:
	fld	QWORD PTR [esi-24]
	mov	ebx, DWORD PTR tv1640[ebp]
	fsub	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	add	ecx, 32					; 00000020H
	add	esi, 32					; 00000020H
	dec	edx
	fstp	QWORD PTR [ecx-40]
	fld	QWORD PTR [ebx+eax-32]
	fsub	QWORD PTR [eax-32]
	fstp	QWORD PTR [ecx-32]
	fld	QWORD PTR [esi-40]
	fsub	QWORD PTR [eax-24]
	fstp	QWORD PTR [ecx-24]
	fld	QWORD PTR [esi-32]
	fsub	QWORD PTR [eax-16]
	fstp	QWORD PTR [ecx-16]
	jne	SHORT $LL76@calc_simpl@5

; 859  :       {  x[k] = get_coord(v[k]);

	mov	eax, DWORD PTR _k$[ebp]
	mov	ebx, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _dymem
	mov	esi, DWORD PTR _v$[ebp]
$LC75@calc_simpl@5:

; 860  :           for ( j = 0 ; j < SDIM ; j++ )

	cmp	edi, DWORD PTR _web+616
	jge	SHORT $LN74@calc_simpl@5
	mov	esi, DWORD PTR _x$[ebp+eax*4]
	mov	ecx, DWORD PTR tv2070[ebp]
	sub	esi, ebx
	mov	DWORD PTR tv3826[ebp], esi
	mov	esi, DWORD PTR _web+616
	add	ecx, edi
	lea	edx, DWORD PTR [ebx+edi*8]
	lea	ecx, DWORD PTR _side$[ebp+ecx*8-48]
	sub	esi, edi
$LC37@calc_simpl@5:

; 861  :              side[k-1][j] = x[k][j] - x[0][j];

	mov	edi, DWORD PTR tv3826[ebp]
	fld	QWORD PTR [edx+edi]
	add	edx, 8
	fsub	QWORD PTR [edx-8]
	add	ecx, 8
	dec	esi
	fstp	QWORD PTR [ecx-8]
	jne	SHORT $LC37@calc_simpl@5

; 860  :           for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _dymem
	mov	esi, DWORD PTR _v$[ebp]
$LN74@calc_simpl@5:

; 862  :           sides[k-1] = side[k-1];  /* pointers for matrix routines */

	mov	edx, DWORD PTR tv2210[ebp]
	add	DWORD PTR tv2070[ebp], 6
	mov	DWORD PTR _sides$[ebp+eax*4-4], edx
	inc	eax
	add	edx, 48					; 00000030H
	mov	DWORD PTR _k$[ebp], eax
	mov	DWORD PTR tv2210[ebp], edx
	cmp	eax, DWORD PTR _web+620
	jl	$LL90@calc_simpl@5

; 858  :   for ( k = 1 ; k < web.dimension ; k++ )

	mov	ebx, DWORD PTR _conmap$[ebp]
$LN85@calc_simpl@5:

; 863  :       }
; 864  :   exterior_product(sides,kvector,web.dimension-1,SDIM);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _web+620
	push	edx
	dec	eax
	push	eax
	lea	ecx, DWORD PTR _kvector$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sides$[ebp]
	push	edx
	call	_exterior_product

; 865  : 
; 866  :   tforce = get_force(v[0]);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+784]

; 867  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	esi, 1
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tforce$[ebp], eax
	mov	DWORD PTR _j$[ebp], esi
	cmp	DWORD PTR [ebx], esi
	jl	$LN32@calc_simpl@5
	fldz
	mov	edx, DWORD PTR _web+616
	fld	QWORD PTR _fudge$[ebp]
$LN34@calc_simpl@5:

; 868  :     {
; 869  :      constr = get_constraint(conmap[j]&CONMASK);

	mov	edi, DWORD PTR [ebx+esi*4]
	and	edi, 1073741823				; 3fffffffH
	imul	edi, 176				; 000000b0H
	add	edi, DWORD PTR _web+652

; 870  :      if ( !(constr->attr & CON_ENERGY) ) continue;

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi+32]
	and	eax, 64					; 00000040H
	or	eax, ecx
	mov	DWORD PTR _constr$[ebp], edi
	je	$LN33@calc_simpl@5

; 871  :      for ( k = 0 ; k < 1 /* gauss1D_num */ ; k++ )
; 872  :       {
; 873  :          for ( i = 0 ; i < SDIM ; i++ )

	test	edx, edx
	jg	$LN91@calc_simpl@5
	mov	ebx, DWORD PTR _web+620

; 894  :             for ( m = 0 ; m < SDIM ; m++ )

	fxch	ST(1)
$LN25@calc_simpl@5:

; 877  :             }
; 878  :          for ( i = 0 ; i < constr->compcount ; i++ )

	cmp	DWORD PTR [edi+44], 0
	mov	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN19@calc_simpl@5
	fstp	ST(1)
	lea	ebx, DWORD PTR _green$[ebp]
	fstp	ST(0)
	lea	esi, DWORD PTR _green_deriv$[ebp]
	add	edi, 48					; 00000030H
$LL83@calc_simpl@5:

; 879  :             eval_all(constr->envect[i],midpt,SDIM,&green[i],
; 880  :                     green_deriv[i],e_id);  /* constraint value and derivs */

	mov	eax, DWORD PTR _e_id$GSCopy$[ebp]
	push	eax
	push	esi
	push	ebx
	push	edx
	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR _midpt$[ebp]
	push	ecx
	push	edx
	call	_eval_all
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _constr$[ebp]
	mov	edx, DWORD PTR _web+616
	inc	eax
	add	esp, 24					; 00000018H
	add	edi, 4
	add	esi, 48					; 00000030H
	add	ebx, 8
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [ecx+44]
	jl	SHORT $LL83@calc_simpl@5

; 877  :             }
; 878  :          for ( i = 0 ; i < constr->compcount ; i++ )

	fldz
	mov	ebx, DWORD PTR _web+620
	fld	QWORD PTR _fudge$[ebp]
	mov	edi, ecx
	fxch	ST(1)
$LN19@calc_simpl@5:

; 881  :           
; 882  :          /* part due to motion of midpoint changing integrand */
; 883  :          for ( m = 0 ; m < SDIM ; m++ )

	xor	esi, esi
	mov	DWORD PTR _m$[ebp], esi
	test	edx, edx
	jle	$LN16@calc_simpl@5
	mov	ebx, DWORD PTR [edi+44]
$LN92@calc_simpl@5:
	lea	edi, DWORD PTR _grad$[ebp+esi*8]

; 884  :             for ( i = 0 , grad[m] = 0.0 ; i < constr->compcount ; i++ )

	xor	eax, eax
	fst	QWORD PTR [edi]
	mov	DWORD PTR tv1171[ebp], edi
	cmp	ebx, 4
	jl	SHORT $LC81@calc_simpl@5

; 881  :           
; 882  :          /* part due to motion of midpoint changing integrand */
; 883  :          for ( m = 0 ; m < SDIM ; m++ )

	lea	edi, DWORD PTR [ebx-3]
	lea	ecx, DWORD PTR _green_deriv$[ebp+esi*8+48]

; 884  :             for ( i = 0 , grad[m] = 0.0 ; i < constr->compcount ; i++ )

$LN82@calc_simpl@5:

; 885  :               grad[m] += kvector[i]*green_deriv[i][m];

	fld	QWORD PTR _kvector$[ebp+eax*8]
	mov	esi, DWORD PTR tv1171[ebp]
	fmul	QWORD PTR [ecx-48]
	add	eax, 4
	add	ecx, 192				; 000000c0H
	fadd	QWORD PTR [esi]
	fld	QWORD PTR _kvector$[ebp+eax*8-24]
	fmul	QWORD PTR [ecx-192]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _kvector$[ebp+eax*8-16]
	fmul	QWORD PTR [ecx-144]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _kvector$[ebp+eax*8-8]
	fmul	QWORD PTR [ecx-96]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi]
	cmp	eax, edi
	jl	SHORT $LN82@calc_simpl@5
	mov	esi, DWORD PTR _m$[ebp]
	mov	edi, DWORD PTR tv1171[ebp]
$LC81@calc_simpl@5:

; 884  :             for ( i = 0 , grad[m] = 0.0 ; i < constr->compcount ; i++ )

	cmp	eax, ebx
	jge	SHORT $LN17@calc_simpl@5
	fld	QWORD PTR [edi]
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [esi+ecx*2]
	lea	ecx, DWORD PTR _green_deriv$[ebp+ecx*8]
$LC15@calc_simpl@5:

; 885  :               grad[m] += kvector[i]*green_deriv[i][m];

	fld	QWORD PTR _kvector$[ebp+eax*8]
	inc	eax
	fmul	QWORD PTR [ecx]
	add	ecx, 48					; 00000030H
	faddp	ST(1), ST(0)
	cmp	eax, ebx
	jl	SHORT $LC15@calc_simpl@5
	fstp	QWORD PTR [edi]
$LN17@calc_simpl@5:

; 881  :           
; 882  :          /* part due to motion of midpoint changing integrand */
; 883  :          for ( m = 0 ; m < SDIM ; m++ )

	inc	esi
	mov	DWORD PTR _m$[ebp], esi
	cmp	esi, edx
	jl	$LN92@calc_simpl@5
	mov	ebx, DWORD PTR _web+620
$LN16@calc_simpl@5:

; 886  :          for ( i = 0 ; i < web.dimension ; i++ )

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN87@calc_simpl@5
$LN89@calc_simpl@5:

; 887  :             { hforce = get_force(v[i]);

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _web+12
	mov	edi, DWORD PTR _dymem
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _web+104
	add	eax, DWORD PTR [ecx+edi+784]

; 888  :               for ( m = 0 ; m < SDIM ; m++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN11@calc_simpl@5
	lea	edi, DWORD PTR _grad$[ebp]
	sub	edi, eax
$LN9@calc_simpl@5:

; 889  :                  hforce[m] -= grad[m]/web.dimension/fudge;

	fild	DWORD PTR _web+620
	inc	ecx
	add	eax, 8
	fdivr	QWORD PTR [edi+eax-8]
	fdiv	ST(0), ST(2)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jl	SHORT $LN9@calc_simpl@5

; 888  :               for ( m = 0 ; m < SDIM ; m++ )

	mov	ebx, DWORD PTR _web+620
$LN11@calc_simpl@5:

; 886  :          for ( i = 0 ; i < web.dimension ; i++ )

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LN89@calc_simpl@5
$LN87@calc_simpl@5:

; 890  :             }
; 891  :          /* part due to changing kvector */
; 892  :          for ( i = 0 ; i < web.dimension-1 ; i++ ) /* side by side */

	xor	ecx, ecx
	dec	ebx
	mov	DWORD PTR _i$[ebp], ecx
	test	ebx, ebx
	jle	$LN29@calc_simpl@5
	lea	eax, DWORD PTR _side$[ebp]
	mov	DWORD PTR tv3666[ebp], eax
	mov	eax, DWORD PTR _v$[ebp]
	add	eax, 4
	mov	DWORD PTR tv3690[ebp], eax
$LN88@calc_simpl@5:

; 893  :          { hforce = get_force(v[i+1]);

	mov	eax, DWORD PTR tv3690[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR _web+12
	mov	edi, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+104
	add	eax, DWORD PTR [esi+edi+784]

; 894  :             for ( m = 0 ; m < SDIM ; m++ )

	xor	edi, edi
	test	edx, edx
	jle	$LN1@calc_simpl@5
	mov	esi, DWORD PTR _tforce$[ebp]
	fstp	ST(1)
	mov	ebx, eax
	sub	ebx, esi
$LL157@calc_simpl@5:

; 895  :             { REAL f;
; 896  :               sides[i] = identmat[m];

	mov	eax, DWORD PTR _identmat
	fstp	ST(0)
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _sides$[ebp+ecx*4], eax

; 897  :               exterior_product(sides,kvector,web.dimension-1,SDIM);

	mov	ecx, DWORD PTR _web+620
	push	edx
	dec	ecx
	push	ecx
	lea	edx, DWORD PTR _kvector$[ebp]
	push	edx
	lea	eax, DWORD PTR _sides$[ebp]
	push	eax
	call	_exterior_product

; 898  :               f = dot(kvector,green,constr->compcount)/fudge;

	mov	ecx, DWORD PTR _constr$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	lea	eax, DWORD PTR _green$[ebp]
	push	eax
	lea	ecx, DWORD PTR _kvector$[ebp]
	push	ecx
	call	_dot
	fld	QWORD PTR _fudge$[ebp]
	fdiv	ST(1), ST(0)
	mov	ecx, DWORD PTR _i$[ebp]
	inc	edi
	add	esp, 28					; 0000001cH
	add	esi, 8

; 899  :               hforce[m] -= f;

	fld	QWORD PTR [ebx+esi-8]
	fsub	ST(0), ST(2)
	fstp	QWORD PTR [ebx+esi-8]

; 900  :               tforce[m] += f;

	fld	QWORD PTR [esi-8]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [esi-8]
	mov	edx, DWORD PTR _web+616
	cmp	edi, edx
	jl	SHORT $LL157@calc_simpl@5

; 894  :             for ( m = 0 ; m < SDIM ; m++ )

	fldz
$LN1@calc_simpl@5:

; 901  :             }
; 902  :             sides[i] = side[i];

	mov	eax, DWORD PTR tv3666[ebp]
	add	DWORD PTR tv3690[ebp], 4
	mov	DWORD PTR _sides$[ebp+ecx*4], eax
	add	eax, 48					; 00000030H
	mov	DWORD PTR tv3666[ebp], eax
	mov	eax, DWORD PTR _web+620
	inc	ecx
	dec	eax
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, eax
	jl	$LN88@calc_simpl@5
$LN29@calc_simpl@5:

; 890  :             }
; 891  :          /* part due to changing kvector */
; 892  :          for ( i = 0 ; i < web.dimension-1 ; i++ ) /* side by side */

	mov	ebx, DWORD PTR _conmap$[ebp]

; 894  :             for ( m = 0 ; m < SDIM ; m++ )

	fxch	ST(1)
	mov	esi, DWORD PTR _j$[ebp]
$LN33@calc_simpl@5:

; 867  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	inc	esi
	mov	DWORD PTR _j$[ebp], esi
	cmp	esi, DWORD PTR [ebx]
	jle	$LN34@calc_simpl@5
	fstp	ST(0)
	fstp	ST(0)
$LN32@calc_simpl@5:

; 903  :          }          
; 904  :       }
; 905  :     }
; 906  : } // end calc_simplex_edge_force()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN111@calc_simpl@5:

; 871  :      for ( k = 0 ; k < 1 /* gauss1D_num */ ; k++ )
; 872  :       {
; 873  :          for ( i = 0 ; i < SDIM ; i++ )

	fxch	ST(1)
$LN91@calc_simpl@5:

; 874  :             { midpt[i] = 0.0;
; 875  :               for ( m = 0 ; m < web.dimension ; m++ )

	mov	ebx, DWORD PTR _web+620
	fxch	ST(1)
	xor	eax, eax
	fst	QWORD PTR _midpt$[ebp+ecx*8]
	cmp	ebx, 4
	jl	SHORT $LC78@calc_simpl@5

; 876  :                  midpt[i] += x[m][i]/web.dimension;

	fild	DWORD PTR _web+620
	lea	esi, DWORD PTR [ebx-3]
$LN79@calc_simpl@5:
	mov	ebx, DWORD PTR _x$[ebp+eax*4]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR _x$[ebp+eax*4+4]
	fdiv	ST(0), ST(1)
	add	eax, 4
	fadd	QWORD PTR _midpt$[ebp+ecx*8]
	fst	QWORD PTR _midpt$[ebp+ecx*8]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR _x$[ebp+eax*4-8]
	fdiv	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _midpt$[ebp+ecx*8]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR _x$[ebp+eax*4-4]
	fdiv	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _midpt$[ebp+ecx*8]
	fld	QWORD PTR [ebx+ecx*8]
	fdiv	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _midpt$[ebp+ecx*8]
	cmp	eax, esi
	jl	SHORT $LN79@calc_simpl@5
	mov	ebx, DWORD PTR _web+620
	fstp	ST(0)
$LC78@calc_simpl@5:

; 874  :             { midpt[i] = 0.0;
; 875  :               for ( m = 0 ; m < web.dimension ; m++ )

	cmp	eax, ebx
	jge	SHORT $LN26@calc_simpl@5
	fild	DWORD PTR _web+620
$LC24@calc_simpl@5:

; 876  :                  midpt[i] += x[m][i]/web.dimension;

	mov	esi, DWORD PTR _x$[ebp+eax*4]
	fld	QWORD PTR [esi+ecx*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR _midpt$[ebp+ecx*8]
	fstp	QWORD PTR _midpt$[ebp+ecx*8]
	cmp	eax, ebx
	jl	SHORT $LC24@calc_simpl@5

; 874  :             { midpt[i] = 0.0;
; 875  :               for ( m = 0 ; m < web.dimension ; m++ )

	fstp	ST(0)
$LN26@calc_simpl@5:

; 871  :      for ( k = 0 ; k < 1 /* gauss1D_num */ ; k++ )
; 872  :       {
; 873  :          for ( i = 0 ; i < SDIM ; i++ )

	inc	ecx
	cmp	ecx, edx
	jl	$LN111@calc_simpl@5
	jmp	$LN25@calc_simpl@5
_calc_simplex_edge_force ENDP
_TEXT	ENDS
PUBLIC	_e_id$GSCopy$
PUBLIC	_second$GSCopy$
PUBLIC	_first$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_edge_hessian
EXTRN	_vec_mat_mul:PROC
; Function compile flags: /Ogtp
;	COMDAT _simplex_edge_hessian
_TEXT	SEGMENT
_green_deriv$ = -1544					; size = 60
_x$ = -1484						; size = 24
_sides$ = -1460						; size = 24
tv4100 = -1436						; size = 4
tv4085 = -1432						; size = 4
tv4097 = -1428						; size = 4
tv4087 = -1424						; size = 4
_e_id$GSCopy$ = -1420					; size = 4
_p$ = -1416						; size = 4
tv4093 = -1412						; size = 4
_fudge$ = -1408						; size = 8
tv3910 = -1400						; size = 4
_conmap$ = -1396					; size = 4
tv3647 = -1392						; size = 4
tv1448 = -1392						; size = 4
_first$GSCopy$ = -1388					; size = 4
tv4116 = -1384						; size = 4
tv4101 = -1384						; size = 4
_second$GSCopy$ = -1380					; size = 4
tv4366 = -1376						; size = 4
_n$ = -1376						; size = 4
tv4413 = -1372						; size = 4
tv1435 = -1372						; size = 4
tv4660 = -1368						; size = 4
tv4021 = -1368						; size = 4
tv1961 = -1368						; size = 4
_j$ = -1364						; size = 4
_v$ = -1364						; size = 4
tv2199 = -1360						; size = 4
_constr$ = -1360					; size = 4
tv4423 = -1356						; size = 4
tv4118 = -1356						; size = 4
tv3621 = -1356						; size = 4
_k$ = -1356						; size = 4
tv2339 = -1352						; size = 4
_i$ = -1352						; size = 4
_green_deriv_space$ = -1348				; size = 720
_side$ = -628						; size = 288
_green$ = -340						; size = 120
_kvector$ = -220					; size = 120
_grad$ = -100						; size = 48
_midpt$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_first$ = 12						; size = 4
_second$ = 16						; size = 4
_simplex_edge_hessian PROC				; COMDAT

; 922  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1544				; 00000608H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 923  :   struct constraint *constr;
; 924  :   int i,j,k,m,n,p;
; 925  :   REAL side[MAXCOORD][MAXCOORD];
; 926  :   REAL *sides[MAXCOORD];
; 927  :   REAL green[MAXCONCOMP];
; 928  :   REAL green_deriv_space[MAXCONCOMP][MAXCOORD];
; 929  :   REAL *green_deriv[MAXCONCOMP];
; 930  :   conmap_t * conmap;
; 931  :   REAL midpt[MAXCOORD];  /* evaluation point for integrand */
; 932  :   int sign;
; 933  :   REAL kvector[MAXCONCOMP];  /* k-vector representing simplex */
; 934  :   REAL *x[MAXCOORD];
; 935  :   vertex_id *v;
; 936  :   REAL fudge = web.simplex_factorial/web.dimension;

	fild	DWORD PTR _web+620

; 956  : 
; 957  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _first$[ebp]
	mov	ecx, DWORD PTR _second$[ebp]
	mov	edx, DWORD PTR _e_id$[ebp]
	fdivr	QWORD PTR _web+792
	mov	DWORD PTR _first$GSCopy$[ebp], eax
	mov	DWORD PTR _second$GSCopy$[ebp], ecx

; 989  :                 for ( p = 0 ; p < SDIM ; p++ )

	mov	DWORD PTR _e_id$GSCopy$[ebp], edx
	xor	eax, eax
	lea	ecx, DWORD PTR _green_deriv_space$[ebp]
	fstp	QWORD PTR _fudge$[ebp]
	npad	8
$LL59@simplex_ed:

; 937  :   REAL grad[MAXCOORD];
; 938  : 
; 939  :   for ( i = 0 ; i < MAXCONCOMP ; i++ ) 

	mov	DWORD PTR _green_deriv$[ebp+eax*4], ecx
	inc	eax
	add	ecx, 48					; 00000030H
	cmp	eax, 15					; 0000000fH
	jl	SHORT $LL59@simplex_ed

; 940  :      green_deriv[i] = green_deriv_space[i];
; 941  : 
; 942  :   conmap = get_e_constraint_map(e_id);

	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _web+124
	push	ebx
	push	esi
	mov	esi, DWORD PTR _dymem
	cmp	DWORD PTR [eax+esi+1048], 0
	push	edi
	je	SHORT $LN62@simplex_ed
	mov	edi, edx
	and	edi, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+edi*4]
	add	ebx, DWORD PTR [eax+esi+1024]
	jmp	SHORT $LN155@simplex_ed
$LN62@simplex_ed:
	mov	ebx, OFFSET _nullcon
$LN155@simplex_ed:

; 943  :   if ( get_eattr(e_id) & NEGBOUNDARY ) sign = -1;
; 944  :   else sign = 1;
; 945  :   if ( inverted(e_id) ) sign = -sign;
; 946  : 
; 947  :   v = get_edge_vertices(e_id);

	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	ecx, DWORD PTR [eax+esi+304]

; 948  :   x[0] = get_coord(v[0]);

	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR [ecx]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+esi+64]

; 949  :   for ( k = 1 ; k < web.dimension ; k++ )

	mov	eax, 1
	mov	DWORD PTR _conmap$[ebp], ebx
	mov	DWORD PTR _v$[ebp], ecx
	mov	DWORD PTR _x$[ebp], edx
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR _web+620, eax
	jle	$LN113@simplex_ed

; 943  :   if ( get_eattr(e_id) & NEGBOUNDARY ) sign = -1;
; 944  :   else sign = 1;
; 945  :   if ( inverted(e_id) ) sign = -sign;
; 946  : 
; 947  :   v = get_edge_vertices(e_id);

	lea	edx, DWORD PTR _side$[ebp]
	mov	DWORD PTR tv2199[ebp], 6
	mov	DWORD PTR tv2339[ebp], edx
	npad	1
$LL53@simplex_ed:

; 950  :       {  x[k] = get_coord(v[k]);

	mov	edx, DWORD PTR [ecx+eax*4]
	mov	edi, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR _web+104
	mov	edi, DWORD PTR [edi+esi+64]
	add	edx, edi

; 951  :           for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	cmp	DWORD PTR _web+616, 4
	mov	DWORD PTR _x$[ebp+eax*4], edx
	mov	ebx, DWORD PTR _x$[ebp]
	jl	SHORT $LN111@simplex_ed

; 950  :       {  x[k] = get_coord(v[k]);

	mov	ecx, DWORD PTR tv2339[ebp]
	lea	esi, DWORD PTR [edx+24]

; 952  :              side[k-1][j] = x[k][j] - x[0][j];

	sub	edx, ebx
	mov	DWORD PTR tv1961[ebp], edx
	mov	edx, DWORD PTR _web+616
	add	edx, -4					; fffffffcH
	shr	edx, 2
	add	ecx, 8
	inc	edx
	lea	eax, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR tv1961[ebp]
	lea	edi, DWORD PTR [edx*4]
$LL102@simplex_ed:
	fld	QWORD PTR [esi-24]
	add	eax, 32					; 00000020H
	fsub	QWORD PTR [eax-40]
	add	ecx, 32					; 00000020H
	add	esi, 32					; 00000020H
	dec	edx
	fstp	QWORD PTR [ecx-40]
	fld	QWORD PTR [ebx+eax-32]
	fsub	QWORD PTR [eax-32]
	fstp	QWORD PTR [ecx-32]
	fld	QWORD PTR [esi-40]
	fsub	QWORD PTR [eax-24]
	fstp	QWORD PTR [ecx-24]
	fld	QWORD PTR [esi-32]
	fsub	QWORD PTR [eax-16]
	fstp	QWORD PTR [ecx-16]
	jne	SHORT $LL102@simplex_ed

; 950  :       {  x[k] = get_coord(v[k]);

	mov	eax, DWORD PTR _k$[ebp]
	mov	ebx, DWORD PTR _x$[ebp]
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR _v$[ebp]
$LN111@simplex_ed:

; 951  :           for ( j = 0 ; j < SDIM ; j++ )

	cmp	edi, DWORD PTR _web+616
	jge	SHORT $LN112@simplex_ed
	mov	esi, DWORD PTR _x$[ebp+eax*4]
	mov	ecx, DWORD PTR tv2199[ebp]
	sub	esi, ebx
	mov	DWORD PTR tv4660[ebp], esi
	mov	esi, DWORD PTR _web+616
	add	ecx, edi
	lea	edx, DWORD PTR [ebx+edi*8]
	sub	esi, edi
	mov	edi, DWORD PTR tv4660[ebp]
	lea	ecx, DWORD PTR _side$[ebp+ecx*8-48]
$LC50@simplex_ed:

; 952  :              side[k-1][j] = x[k][j] - x[0][j];

	fld	QWORD PTR [edi+edx]
	add	edx, 8
	fsub	QWORD PTR [edx-8]
	add	ecx, 8
	dec	esi
	fstp	QWORD PTR [ecx-8]
	jne	SHORT $LC50@simplex_ed

; 951  :           for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR _v$[ebp]
$LN112@simplex_ed:

; 953  :           sides[k-1] = side[k-1];  /* pointers for matrix routines */

	mov	edx, DWORD PTR tv2339[ebp]
	add	DWORD PTR tv2199[ebp], 6
	mov	DWORD PTR _sides$[ebp+eax*4-4], edx
	inc	eax
	add	edx, 48					; 00000030H
	mov	DWORD PTR _k$[ebp], eax
	mov	DWORD PTR tv2339[ebp], edx
	cmp	eax, DWORD PTR _web+620
	jl	$LL53@simplex_ed

; 949  :   for ( k = 1 ; k < web.dimension ; k++ )

	mov	ebx, DWORD PTR _conmap$[ebp]
$LN113@simplex_ed:

; 954  :       }
; 955  :   exterior_product(sides,kvector,web.dimension-1,SDIM);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _web+620
	push	edx
	dec	eax
	push	eax
	lea	ecx, DWORD PTR _kvector$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sides$[ebp]
	push	edx
	call	_exterior_product
	add	esp, 16					; 00000010H

; 956  : 
; 957  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	cmp	DWORD PTR [ebx], 1
	mov	DWORD PTR _j$[ebp], 1
	jl	$LN45@simplex_ed
	fldz
	mov	ecx, DWORD PTR _web+620
	mov	edx, DWORD PTR _web+616
$LN47@simplex_ed:

; 958  :     {
; 959  :      constr = get_constraint(conmap[j]&CONMASK);

	mov	eax, DWORD PTR _j$[ebp]
	mov	edi, DWORD PTR [ebx+eax*4]
	and	edi, 1073741823				; 3fffffffH
	imul	edi, 176				; 000000b0H
	add	edi, DWORD PTR _web+652

; 960  :      if ( !(constr->attr & CON_ENERGY) ) continue;

	xor	esi, esi
	mov	eax, DWORD PTR [edi+32]
	and	eax, 64					; 00000040H
	or	eax, esi
	mov	DWORD PTR _constr$[ebp], edi
	je	$LN46@simplex_ed

; 961  :      for ( k = 0 ; k < 1 /* gauss1D_num */ ; k++ )
; 962  :       {
; 963  :          for ( i = 0 ; i < SDIM ; i++ )

	test	edx, edx
	jle	$LN135@simplex_ed
$LN116@simplex_ed:

; 964  :             { midpt[i] = 0.0;
; 965  :               for ( m = 0 ; m < web.dimension ; m++ )

	xor	eax, eax
	fst	QWORD PTR _midpt$[ebp+esi*8]
	cmp	ecx, 4
	jl	SHORT $LC104@simplex_ed

; 966  :                  midpt[i] += x[m][i]/web.dimension;

	fild	DWORD PTR _web+620
	lea	edi, DWORD PTR [ecx-3]
$LN105@simplex_ed:
	mov	ebx, DWORD PTR _x$[ebp+eax*4]
	fld	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR _x$[ebp+eax*4+4]
	fdiv	ST(0), ST(1)
	add	eax, 4
	fadd	QWORD PTR _midpt$[ebp+esi*8]
	fst	QWORD PTR _midpt$[ebp+esi*8]
	fld	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR _x$[ebp+eax*4-8]
	fdiv	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _midpt$[ebp+esi*8]
	fld	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR _x$[ebp+eax*4-4]
	fdiv	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _midpt$[ebp+esi*8]
	fld	QWORD PTR [ebx+esi*8]
	fdiv	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _midpt$[ebp+esi*8]
	cmp	eax, edi
	jl	SHORT $LN105@simplex_ed
	mov	edi, DWORD PTR _constr$[ebp]
	fstp	ST(0)
$LC104@simplex_ed:

; 964  :             { midpt[i] = 0.0;
; 965  :               for ( m = 0 ; m < web.dimension ; m++ )

	cmp	eax, ecx
	jge	SHORT $LN39@simplex_ed
	fild	DWORD PTR _web+620
$LC37@simplex_ed:

; 966  :                  midpt[i] += x[m][i]/web.dimension;

	mov	ebx, DWORD PTR _x$[ebp+eax*4]
	fld	QWORD PTR [ebx+esi*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR _midpt$[ebp+esi*8]
	fstp	QWORD PTR _midpt$[ebp+esi*8]
	cmp	eax, ecx
	jl	SHORT $LC37@simplex_ed

; 964  :             { midpt[i] = 0.0;
; 965  :               for ( m = 0 ; m < web.dimension ; m++ )

	fstp	ST(0)
$LN39@simplex_ed:

; 961  :      for ( k = 0 ; k < 1 /* gauss1D_num */ ; k++ )
; 962  :       {
; 963  :          for ( i = 0 ; i < SDIM ; i++ )

	inc	esi
	cmp	esi, edx
	jl	$LN116@simplex_ed
$LN135@simplex_ed:

; 967  :             }
; 968  :          for ( i = 0 ; i < constr->compcount ; i++ )

	xor	esi, esi
	fstp	ST(0)
	cmp	DWORD PTR [edi+44], esi
	jle	SHORT $LN32@simplex_ed
	mov	edi, DWORD PTR _constr$[ebp]
	lea	ebx, DWORD PTR _green$[ebp]
	add	edi, 48					; 00000030H
	npad	4
$LL106@simplex_ed:

; 969  :             eval_all(constr->envect[i],midpt,SDIM,&green[i],
; 970  :                     green_deriv[i],e_id);  /* constraint value and derivs */

	mov	ecx, DWORD PTR _e_id$GSCopy$[ebp]
	mov	eax, DWORD PTR _green_deriv$[ebp+esi*4]
	push	ecx
	push	eax
	push	ebx
	push	edx
	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR _midpt$[ebp]
	push	ecx
	push	edx
	call	_eval_all
	mov	eax, DWORD PTR _constr$[ebp]
	mov	edx, DWORD PTR _web+616
	inc	esi
	add	esp, 24					; 00000018H
	add	edi, 4
	add	ebx, 8
	cmp	esi, DWORD PTR [eax+44]
	jl	SHORT $LL106@simplex_ed
$LN32@simplex_ed:

; 971  :           
; 972  :          /* part due to motion of midpoint changing integrand */
; 973  :          vec_mat_mul(kvector,green_deriv,grad,constr->compcount,SDIM);

	mov	ecx, DWORD PTR _constr$[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	lea	eax, DWORD PTR _grad$[ebp]
	push	eax
	lea	ecx, DWORD PTR _green_deriv$[ebp]
	push	ecx
	lea	edx, DWORD PTR _kvector$[ebp]
	push	edx
	call	_vec_mat_mul

; 974  :          for ( i = 0 ; i < web.dimension ; i++ )

	mov	ecx, DWORD PTR _web+620
	mov	edx, DWORD PTR _web+616
	mov	edi, DWORD PTR _first$GSCopy$[ebp]
	add	esp, 20					; 00000014H
	xor	ebx, ebx
	test	ecx, ecx
	jle	SHORT $LN29@simplex_ed
	fld	QWORD PTR _fudge$[ebp]
$LN115@simplex_ed:

; 975  :             { for ( m = 0 ; m < SDIM ; m++ )

	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN30@simplex_ed
	mov	eax, DWORD PTR [edi+ebx*4]
	lea	ecx, DWORD PTR _grad$[ebp]
	sub	ecx, eax
$LN28@simplex_ed:

; 976  :                  first[i][m] += grad[m]/web.dimension/fudge;

	fild	DWORD PTR _web+620
	inc	esi
	add	eax, 8
	fdivr	QWORD PTR [ecx+eax-8]
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	esi, edx
	jl	SHORT $LN28@simplex_ed

; 975  :             { for ( m = 0 ; m < SDIM ; m++ )

	mov	ecx, DWORD PTR _web+620
$LN30@simplex_ed:

; 974  :          for ( i = 0 ; i < web.dimension ; i++ )

	inc	ebx
	cmp	ebx, ecx
	jl	SHORT $LN115@simplex_ed
	fstp	ST(0)
$LN29@simplex_ed:

; 977  :             }
; 978  :          /* part due to changing kvector */
; 979  :          for ( i = 0 ; i < web.dimension-1 ; i++ ) /* side by side */

	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR _i$[ebp], 0
	test	eax, eax
	jle	$LN23@simplex_ed
	lea	esi, DWORD PTR _side$[ebp]
	mov	DWORD PTR tv3910[ebp], esi
	mov	esi, DWORD PTR _second$GSCopy$[ebp]
	sub	edi, esi
	mov	DWORD PTR tv4097[ebp], edi
	mov	edi, -4					; fffffffcH
	lea	ebx, DWORD PTR [esi+4]
	sub	edi, esi
	mov	DWORD PTR tv4021[ebp], ebx
	mov	DWORD PTR tv4100[ebp], edi
	npad	5
$LL25@simplex_ed:

; 980  :          { for ( m = 0 ; m < SDIM ; m++ )

	xor	esi, esi
	test	edx, edx
	jle	$LN20@simplex_ed
	npad	6
$LL22@simplex_ed:

; 981  :             { REAL f;
; 982  :               sides[i] = identmat[m];

	mov	ecx, DWORD PTR _identmat
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	edi, DWORD PTR _i$[ebp]

; 983  :               exterior_product(sides,kvector,web.dimension-1,SDIM);

	push	edx
	push	eax
	lea	edx, DWORD PTR _kvector$[ebp]
	push	edx
	lea	eax, DWORD PTR _sides$[ebp]
	push	eax
	mov	DWORD PTR _sides$[ebp+edi*4], ecx
	call	_exterior_product

; 984  :               f = dot(kvector,green,constr->compcount)/fudge;

	mov	edi, DWORD PTR _constr$[ebp]
	mov	ecx, DWORD PTR [edi+44]
	push	ecx
	lea	edx, DWORD PTR _green$[ebp]
	push	edx
	lea	eax, DWORD PTR _kvector$[ebp]
	push	eax
	call	_dot
	fdiv	QWORD PTR _fudge$[ebp]
	mov	ecx, DWORD PTR tv4097[ebp]
	mov	edx, DWORD PTR [ebx+ecx]
	lea	eax, DWORD PTR [edx+esi*8]

; 985  :               first[i+1][m] += f;

	fld	QWORD PTR [eax]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR _first$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]

; 986  :               first[0][m] -= f;

	fsubr	QWORD PTR [ecx+esi*8]
	lea	eax, DWORD PTR [ecx+esi*8]

; 987  :               vec_mat_mul(kvector,green_deriv,grad,constr->compcount,SDIM);

	lea	ecx, DWORD PTR _grad$[ebp]
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [edi+44]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR _green_deriv$[ebp]
	push	edx
	lea	eax, DWORD PTR _kvector$[ebp]
	push	eax
	call	_vec_mat_mul

; 988  :               for ( n = 0 ; n < web.dimension - 1 ; n++ )

	mov	ecx, DWORD PTR _web+620
	mov	edx, DWORD PTR _web+616
	xor	edi, edi
	lea	eax, DWORD PTR [ecx-1]
	add	esp, 48					; 00000030H
	mov	DWORD PTR _n$[ebp], edi
	test	eax, eax
	jle	$LN21@simplex_ed
	fld	QWORD PTR _fudge$[ebp]
$LN19@simplex_ed:

; 989  :                 for ( p = 0 ; p < SDIM ; p++ )

	mov	DWORD PTR _p$[ebp], 0
	test	edx, edx
	jle	$LN18@simplex_ed
	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edx+edi*4+4]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR _second$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ebx, DWORD PTR tv4100[ebp]
	sub	edx, eax
	mov	DWORD PTR tv4087[ebp], edx
	mov	DWORD PTR tv1435[ebp], ecx
	mov	ecx, DWORD PTR _second$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4+4]
	mov	edx, DWORD PTR tv1435[ebp]
	mov	edi, DWORD PTR [edx+edi*4+4]
	mov	edx, DWORD PTR [edx]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	DWORD PTR tv4101[ebp], ebx
	mov	DWORD PTR tv1448[ebp], edx
	mov	edx, DWORD PTR [edx+esi*4]
	sub	edx, eax
	lea	ebx, DWORD PTR _grad$[ebp]
	sub	ebx, eax
	mov	DWORD PTR tv4085[ebp], ebx
	mov	DWORD PTR tv4093[ebp], edx
	mov	edx, DWORD PTR tv4101[ebp]
	mov	ebx, ecx
	mov	ebx, DWORD PTR [ebx+edx+4]
	mov	ecx, DWORD PTR [ecx]
	sub	ebx, ecx
	mov	DWORD PTR tv4116[ebp], ebx
	mov	ebx, DWORD PTR tv1435[ebp]
	mov	edx, DWORD PTR [ebx+edx+4]
	mov	ebx, DWORD PTR _p$[ebp]
	sub	edx, ecx
	mov	DWORD PTR tv4118[ebp], edx
	mov	edx, DWORD PTR tv1448[ebp]
	sub	edi, eax
	sub	edx, ecx
	mov	DWORD PTR tv3647[ebp], edx
$LN110@simplex_ed:

; 990  :                   { f = grad[p]/web.dimension/fudge;

	fild	DWORD PTR _web+620
	mov	edx, DWORD PTR tv4085[ebp]
	inc	ebx
	add	eax, 8
	fdivr	QWORD PTR [edx+eax-8]

; 991  :                      second[i+1][n+1][m][p] += f;
; 992  :                      second[i+1][0][m][p] += f;

	mov	edx, DWORD PTR tv4087[ebp]
	add	ecx, 4
	fdiv	ST(0), ST(1)
	fld	QWORD PTR [eax-8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	fld	ST(0)
	fadd	QWORD PTR [edx+eax-8]
	fstp	QWORD PTR [edx+eax-8]

; 993  :                      second[0][n+1][m][p] -= f;
; 994  :                      second[0][0][m][p] -= f;

	mov	edx, DWORD PTR tv4093[ebp]
	fld	QWORD PTR [edi+eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edi+eax-8]
	fld	QWORD PTR [edx+eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx+eax-8]
	mov	edx, DWORD PTR tv4116[ebp]
	mov	edx, DWORD PTR [ecx+edx-4]

; 995  :                      second[n+1][i+1][p][m] += f;

	fld	QWORD PTR [edx+esi*8]
	lea	edx, DWORD PTR [edx+esi*8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [ecx-4]

; 996  :                      second[n+1][0][p][m] -= f;

	fld	QWORD PTR [edx+esi*8]
	lea	edx, DWORD PTR [edx+esi*8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR tv4118[ebp]
	mov	edx, DWORD PTR [ecx+edx-4]

; 997  :                      second[0][i+1][p][m] += f;

	fld	QWORD PTR [edx+esi*8]
	lea	edx, DWORD PTR [edx+esi*8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR tv3647[ebp]
	mov	edx, DWORD PTR [edx+ecx-4]

; 998  :                      second[0][0][p][m] -= f;

	fsubr	QWORD PTR [edx+esi*8]
	lea	edx, DWORD PTR [edx+esi*8]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR _web+616
	cmp	ebx, edx
	jl	$LN110@simplex_ed

; 989  :                 for ( p = 0 ; p < SDIM ; p++ )

	mov	ecx, DWORD PTR _web+620
	mov	edi, DWORD PTR _n$[ebp]
	mov	ebx, DWORD PTR tv4021[ebp]
$LN18@simplex_ed:

; 988  :               for ( n = 0 ; n < web.dimension - 1 ; n++ )

	inc	edi
	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR _n$[ebp], edi
	cmp	edi, eax
	jl	$LN19@simplex_ed
	fstp	ST(0)
$LN21@simplex_ed:

; 980  :          { for ( m = 0 ; m < SDIM ; m++ )

	inc	esi
	cmp	esi, edx
	jl	$LL22@simplex_ed
$LN20@simplex_ed:

; 999  :                   }
; 1000 :             }
; 1001 :             sides[i] = side[i];

	mov	eax, DWORD PTR tv3910[ebp]
	mov	esi, DWORD PTR _i$[ebp]
	mov	DWORD PTR _sides$[ebp+esi*4], eax
	add	eax, 48					; 00000030H
	inc	esi
	mov	DWORD PTR tv3910[ebp], eax
	add	ebx, 4
	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR _i$[ebp], esi
	mov	DWORD PTR tv4021[ebp], ebx
	cmp	esi, eax
	jl	$LL25@simplex_ed
$LN23@simplex_ed:

; 1002 :          }          
; 1003 :          /* part due to changing kvector - 2 components */
; 1004 :          for ( i = 0 ; i < web.dimension-1 ; i++ ) /* side by side */

	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR _i$[ebp], 0
	test	eax, eax
	jle	$LN42@simplex_ed
	lea	esi, DWORD PTR _side$[ebp]
	mov	DWORD PTR tv4413[ebp], esi
	mov	esi, DWORD PTR _second$GSCopy$[ebp]
	add	esi, 4
	mov	DWORD PTR tv4423[ebp], esi
$LL13@simplex_ed:

; 1005 :             for ( n = 0 ; n < web.dimension - 1 ; n++ )

	xor	ebx, ebx
	test	eax, eax
	jle	$LN12@simplex_ed
	lea	eax, DWORD PTR _side$[ebp]
	mov	DWORD PTR tv4366[ebp], eax
	npad	5
$LL10@simplex_ed:

; 1006 :              { if ( i == n ) continue;

	cmp	DWORD PTR _i$[ebp], ebx
	je	$LN9@simplex_ed

; 1007 :                 for ( p = 0 ; p < SDIM ; p++ )

	xor	edi, edi
	test	edx, edx
	jle	$LN9@simplex_ed
$LL6@simplex_ed:

; 1008 :                   for ( m = 0 ; m < SDIM ; m++ )

	xor	esi, esi
	test	edx, edx
	jle	$LN5@simplex_ed
$LL109@simplex_ed:

; 1009 :                     { REAL f;
; 1010 :                       sides[i] = identmat[m];

	mov	ecx, DWORD PTR _identmat
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _i$[ebp]

; 1011 :                       sides[n] = identmat[p];
; 1012 :                       exterior_product(sides,kvector,web.dimension-1,SDIM);

	push	edx
	mov	edx, DWORD PTR _web+620
	mov	DWORD PTR _sides$[ebp+ecx*4], eax
	mov	eax, DWORD PTR _identmat
	mov	ecx, DWORD PTR [eax+edi*4]
	dec	edx
	push	edx
	lea	eax, DWORD PTR _kvector$[ebp]
	mov	DWORD PTR _sides$[ebp+ebx*4], ecx
	push	eax
	lea	ecx, DWORD PTR _sides$[ebp]
	push	ecx
	call	_exterior_product

; 1013 :                       f = dot(kvector,green,constr->compcount)/fudge;

	mov	edx, DWORD PTR _constr$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	lea	ecx, DWORD PTR _green$[ebp]
	push	ecx
	lea	edx, DWORD PTR _kvector$[ebp]
	push	edx
	call	_dot
	fdiv	QWORD PTR _fudge$[ebp]

; 1014 :                       second[i+1][n+1][m][p] += f;

	mov	eax, DWORD PTR tv4423[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+ebx*4+4]
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [edx+edi*8]
	inc	esi
	add	esp, 28					; 0000001cH
	fld	QWORD PTR [ecx]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [ecx]

; 1015 :                       second[0][n+1][m][p] -= f;

	mov	ecx, DWORD PTR _second$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+ebx*4+4]
	mov	edx, DWORD PTR [edx+esi*4-4]
	fld	QWORD PTR [edx+edi*8]
	lea	edx, DWORD PTR [edx+edi*8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [eax+esi*4-4]

; 1016 :                       second[i+1][0][m][p] -= f;

	fld	QWORD PTR [edx+edi*8]
	lea	eax, DWORD PTR [edx+edi*8]

; 1017 :                       second[0][0][m][p] += f;
; 1018 :                       sides[i] = side[i];

	mov	edx, DWORD PTR tv4413[ebp]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+esi*4-4]
	fadd	QWORD PTR [ecx+edi*8]
	lea	eax, DWORD PTR [ecx+edi*8]

; 1019 :                       sides[n] = side[n];

	mov	ecx, DWORD PTR tv4366[ebp]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _sides$[ebp+eax*4], edx
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR _sides$[ebp+ebx*4], ecx
	cmp	esi, edx
	jl	$LL109@simplex_ed

; 1008 :                   for ( m = 0 ; m < SDIM ; m++ )

	mov	ecx, DWORD PTR _web+620
$LN5@simplex_ed:

; 1007 :                 for ( p = 0 ; p < SDIM ; p++ )

	inc	edi
	cmp	edi, edx
	jl	$LL6@simplex_ed
$LN9@simplex_ed:

; 1005 :             for ( n = 0 ; n < web.dimension - 1 ; n++ )

	add	DWORD PTR tv4366[ebp], 48		; 00000030H
	inc	ebx
	lea	eax, DWORD PTR [ecx-1]
	cmp	ebx, eax
	jl	$LL10@simplex_ed
$LN12@simplex_ed:

; 1002 :          }          
; 1003 :          /* part due to changing kvector - 2 components */
; 1004 :          for ( i = 0 ; i < web.dimension-1 ; i++ ) /* side by side */

	mov	esi, DWORD PTR _i$[ebp]
	add	DWORD PTR tv4413[ebp], 48		; 00000030H
	add	DWORD PTR tv4423[ebp], 4
	inc	esi
	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR _i$[ebp], esi
	cmp	esi, eax
	jl	$LL13@simplex_ed
$LN42@simplex_ed:
	fldz
	mov	ebx, DWORD PTR _conmap$[ebp]
$LN46@simplex_ed:

; 956  : 
; 957  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [ebx]
	jle	$LN47@simplex_ed
	fstp	ST(0)
$LN45@simplex_ed:

; 1020 :                     }
; 1021 :              }          
; 1022 :       }
; 1023 :     }
; 1024 : } // end simplex_edge_hessian()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_edge_hessian ENDP
_TEXT	ENDS
PUBLIC	_se_comp
; Function compile flags: /Ogtp
;	COMDAT _se_comp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_se_comp PROC						; COMDAT

; 1053 : { if ( a->f < b->f ) return -1;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+8]
	cmp	ecx, eax
	jbe	SHORT $LN5@se_comp
	or	eax, -1

; 1055 :   return 0;
; 1056 : } // end se_comp()

	pop	ebp
	ret	0
$LN5@se_comp:

; 1054 :   if ( a->f > b->f ) return 1;

	sbb	eax, eax
	neg	eax

; 1055 :   return 0;
; 1056 : } // end se_comp()

	pop	ebp
	ret	0
_se_comp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@HDGGNHOG@Edge?5has?5too?5many?5simplices?4?6?$AA@ ; `string'
PUBLIC	__real@3fe0000000000000
PUBLIC	??_C@_0CG@HILHEACP@Edge?5adjacent?5to?5too?5many?5simpli@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_long_edges
EXTRN	_kb_temp_realloc:PROC
EXTRN	_dup_facet:PROC
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	_set_v_constraint_status:PROC
EXTRN	_get_v_constraint_status:PROC
EXTRN	_set_v_constraint_map:PROC
EXTRN	_get_v_common_conmap:PROC
EXTRN	_new_vertex:PROC
EXTRN	_kb_error:PROC
EXTRN	_NULLVERTEX:DWORD
EXTRN	_qsort:PROC
;	COMDAT ??_C@_0BO@HDGGNHOG@Edge?5has?5too?5many?5simplices?4?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BO@HDGGNHOG@Edge?5has?5too?5many?5simplices?4?6?$AA@ DB 'Edge has '
	DB	'too many simplices.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT ??_C@_0CG@HILHEACP@Edge?5adjacent?5to?5too?5many?5simpli@
CONST	SEGMENT
??_C@_0CG@HILHEACP@Edge?5adjacent?5to?5too?5many?5simpli@ DB 'Edge adjace'
	DB	'nt to too many simplices.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\simplex.c
CONST	ENDS
;	COMDAT _simplex_long_edges
_TEXT	SEGMENT
_fedge_max$ = -252					; size = 4
_divcount$ = -248					; size = 4
tv1542 = -244						; size = 4
_n$ = -244						; size = 4
_edges_per$ = -240					; size = 4
tv695 = -236						; size = 4
_se_count$ = -236					; size = 4
tv712 = -232						; size = 4
_we$ = -232						; size = 4
_fedge$ = -228						; size = 4
tv1461 = -224						; size = 4
tv232 = -224						; size = 4
tv1549 = -220						; size = 4
tv814 = -216						; size = 4
_newf$90102 = -216					; size = 4
_v0$ = -212						; size = 4
_se$ = -212						; size = 4
_newv$90101 = -208					; size = 4
_we_count$ = -208					; size = 4
_j$ = -204						; size = 4
_f_id$ = -204						; size = 4
tv1182 = -200						; size = 4
_top$ = -200						; size = 4
_v1$ = -200						; size = 4
tv1529 = -196						; size = 4
tv422 = -196						; size = 4
tv372 = -196						; size = 4
tv273 = -196						; size = 4
_newx$90098 = -192					; size = 48
_conmap$90100 = -144					; size = 92
_side$90099 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_max_len$ = 8						; size = 8
_simplex_long_edges PROC				; COMDAT

; 1066 : { struct s_edge *se,*se_ptr;

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1067 :   int se_count; /* number of edges in se */
; 1068 :   struct w_edge *we,*we_ptr;
; 1069 :   int we_count; /* number of edges in we */
; 1070 :   facet_id f_id;
; 1071 : /* inverse index facet to edge list, indexed by facet ordinal */
; 1072 :   struct w_edge **fedge;
; 1073 :   int fedge_max; /* number of fedge pointers allocated */
; 1074 :   int edges_per = (web.dimension*(web.dimension+1))/2;

	mov	ecx, DWORD PTR _web+620
	lea	eax, DWORD PTR [ecx+1]
	imul	eax, ecx

; 1075 :   int divcount = 0;  /* number of edges divided */
; 1076 :   int i,j,k,m,n;
; 1077 :   vertex_id v0,v1;
; 1078 :   struct w_edge **fl,**newfl;
; 1079 :   int top;
; 1080 : 
; 1081 :   /* make initial edge list */
; 1082 :   se_count = web.skel[FACET].count*edges_per;

	mov	ecx, DWORD PTR _web+288
	cdq
	push	ebx
	sub	eax, edx
	sar	eax, 1
	push	esi
	imul	ecx, eax
	push	edi

; 1083 :   se = (struct s_edge*)temp_calloc(se_count,sizeof(struct s_edge));

	push	1083					; 0000043bH
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	12					; 0000000cH
	push	ecx
	mov	DWORD PTR _edges_per$[ebp], eax
	mov	DWORD PTR _divcount$[ebp], 0
	mov	DWORD PTR _se_count$[ebp], ecx
	call	_kb_temp_calloc

; 1084 :   se_ptr = se;
; 1085 :   FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+272
	add	esp, 16					; 00000010H
	mov	DWORD PTR _se$[ebp], eax
	mov	DWORD PTR _f_id$[ebp], ecx
	test	ecx, 268435456				; 10000000H
	je	$LN62@simplex_lo
	mov	edx, DWORD PTR _web+620
	mov	ebx, DWORD PTR _web+236
	npad	11
$LL64@simplex_lo:
	mov	ecx, DWORD PTR _f_id$[ebp]
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	esi, DWORD PTR [ecx+ebx]
	mov	DWORD PTR tv712[ebp], ecx
	mov	ecx, DWORD PTR [esi+8]
	and	ecx, 1
	xor	edi, edi
	or	ecx, edi
	je	$LN63@simplex_lo

; 1086 :     { vertex_id *v = get_facet_vertices(f_id);

	mov	ecx, DWORD PTR _dymem
	mov	edi, DWORD PTR _web+328
	mov	edi, DWORD PTR [edi+ecx+304]
	add	edi, esi

; 1087 :       for ( i = 0 ; i < web.dimension ; i++ ) /* tail vertex */

	test	edx, edx
	jle	SHORT $LN63@simplex_lo

; 1086 :     { vertex_id *v = get_facet_vertices(f_id);

	mov	DWORD PTR tv1182[ebp], 1
	mov	ebx, edi
	npad	2
$LL59@simplex_lo:

; 1088 :          for ( j = i+1 ; j <= web.dimension ; j++ ) /* head vertex */

	mov	ecx, DWORD PTR tv1182[ebp]
	cmp	ecx, edx
	jg	SHORT $LN58@simplex_lo
	npad	6
$LL56@simplex_lo:

; 1089 :             { se_ptr->f = f_id;

	mov	edx, DWORD PTR _f_id$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1090 :               if ( v[i] < v[j] )

	mov	esi, DWORD PTR [edi+ecx*4]
	mov	edx, DWORD PTR [ebx]
	cmp	edx, esi
	jae	SHORT $LN53@simplex_lo

; 1091 :                  { se_ptr->v[0] = v[i]; se_ptr->v[1] = v[j]; }

	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [edi+ecx*4]
	jmp	SHORT $LN128@simplex_lo
$LN53@simplex_lo:

; 1092 :               else  { se_ptr->v[0] = v[j]; se_ptr->v[1] = v[i]; }

	mov	DWORD PTR [eax], esi
	mov	edx, DWORD PTR [ebx]
$LN128@simplex_lo:
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _web+620
	inc	ecx

; 1093 :               se_ptr++;

	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jle	SHORT $LL56@simplex_lo
$LN58@simplex_lo:

; 1087 :       for ( i = 0 ; i < web.dimension ; i++ ) /* tail vertex */

	mov	ecx, DWORD PTR tv1182[ebp]
	inc	ecx
	mov	DWORD PTR tv1182[ebp], ecx
	dec	ecx
	add	ebx, 4
	cmp	ecx, edx
	jl	SHORT $LL59@simplex_lo
	mov	ebx, DWORD PTR _web+236
$LN63@simplex_lo:

; 1084 :   se_ptr = se;
; 1085 :   FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR tv712[ebp]
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR _f_id$[ebp], ecx
	test	ecx, 268435456				; 10000000H
	jne	$LL64@simplex_lo
$LN62@simplex_lo:

; 1094 :             }
; 1095 :     }
; 1096 :   /* sort list */
; 1097 :   qsort((char*)se,se_count,sizeof(struct s_edge),FCAST se_comp);

	mov	edi, DWORD PTR _se_count$[ebp]
	mov	esi, DWORD PTR _se$[ebp]
	push	OFFSET _se_comp
	push	12					; 0000000cH
	push	edi
	push	esi
	call	_qsort

; 1098 :   /* count edges and max facets per edge */
; 1099 :   v0 = v1 = NULLVERTEX;  /* track current edge */

	mov	eax, DWORD PTR _NULLVERTEX

; 1100 :   for ( k = 0, se_ptr = se, we_count = top = 0 ; k < se_count ; k++, se_ptr++ )

	xor	ebx, ebx
	add	esp, 16					; 00000010H
	mov	ecx, eax
	mov	DWORD PTR _top$[ebp], ebx
	mov	DWORD PTR _we_count$[ebp], ebx
	cmp	edi, ebx
	jle	SHORT $LN117@simplex_lo

; 1094 :             }
; 1095 :     }
; 1096 :   /* sort list */
; 1097 :   qsort((char*)se,se_count,sizeof(struct s_edge),FCAST se_comp);

	mov	DWORD PTR tv422[ebp], edi
$LL122@simplex_lo:

; 1101 :     { if ( (se_ptr->v[0] == v0) && (se_ptr->v[1] == v1)  ) /* same as before */

	cmp	DWORD PTR [esi], ecx
	jne	SHORT $LN48@simplex_lo
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN48@simplex_lo

; 1102 :          top++;

	inc	DWORD PTR _top$[ebp]

; 1103 :       else  /* new */

	jmp	SHORT $LN50@simplex_lo
$LN48@simplex_lo:

; 1104 :          { if ( top > MAXFACET )

	cmp	DWORD PTR _top$[ebp], 10		; 0000000aH
	jle	SHORT $LN46@simplex_lo

; 1105 :               kb_error(1549,"Edge adjacent to too many simplices.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CG@HILHEACP@Edge?5adjacent?5to?5too?5many?5simpli@
	push	1549					; 0000060dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN46@simplex_lo:

; 1106 : 
; 1107 :             v0 = se_ptr->v[0]; v1 =se_ptr->v[1];

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]

; 1108 :             we_count++;

	inc	ebx
$LN50@simplex_lo:

; 1100 :   for ( k = 0, se_ptr = se, we_count = top = 0 ; k < se_count ; k++, se_ptr++ )

	add	esi, 12					; 0000000cH
	dec	DWORD PTR tv422[ebp]
	jne	SHORT $LL122@simplex_lo

; 1108 :             we_count++;

	mov	DWORD PTR _we_count$[ebp], ebx
$LN117@simplex_lo:

; 1109 :          }
; 1110 :     }
; 1111 :   /* make working lists */
; 1112 :   we = (struct w_edge*)temp_calloc(we_count,sizeof(struct w_edge));

	mov	edx, DWORD PTR _we_count$[ebp]
	push	1112					; 00000458H
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	52					; 00000034H
	push	edx
	call	_kb_temp_calloc
	mov	esi, eax

; 1113 :   fedge_max = web.skel[FACET].max_ord+100;

	mov	eax, DWORD PTR _web+292
	add	eax, 100				; 00000064H
	mov	DWORD PTR _fedge_max$[ebp], eax

; 1114 :   fedge = (struct w_edge**)temp_calloc(fedge_max*edges_per,
; 1115 :                          sizeof(struct w_edge *));

	imul	eax, DWORD PTR _edges_per$[ebp]
	push	1115					; 0000045bH
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	4
	push	eax
	mov	DWORD PTR _we$[ebp], esi
	call	_kb_temp_calloc
	mov	DWORD PTR _fedge$[ebp], eax

; 1116 :   v0 = v1 = NULLVERTEX;  /* track current edge */

	mov	eax, DWORD PTR _NULLVERTEX
	add	esp, 32					; 00000020H
	mov	ebx, eax

; 1117 :   for ( k = 0, se_ptr = se, we_ptr = we-1 ; k < se_count ; k++, se_ptr++ )

	lea	ecx, DWORD PTR [esi-52]
	test	edi, edi
	jle	SHORT $LN121@simplex_lo

; 1109 :          }
; 1110 :     }
; 1111 :   /* make working lists */
; 1112 :   we = (struct w_edge*)temp_calloc(we_count,sizeof(struct w_edge));

	mov	esi, DWORD PTR _se$[ebp]
	add	esi, 8
	mov	DWORD PTR tv372[ebp], edi
$LL45@simplex_lo:

; 1118 :     { if ( (se_ptr->v[0] != v0) || (se_ptr->v[1] != v1)  ) /* new */

	mov	edx, DWORD PTR [esi-8]
	cmp	edx, ebx
	jne	SHORT $LN41@simplex_lo
	cmp	DWORD PTR [esi-4], eax
	je	SHORT $LN42@simplex_lo
$LN41@simplex_lo:

; 1119 :          { we_ptr++;

	add	ecx, 52					; 00000034H

; 1120 :            v0 = we_ptr->v[0] = se_ptr->v[0]; 

	mov	DWORD PTR [ecx], edx
	mov	ebx, edx

; 1121 :            v1 = we_ptr->v[1] = se_ptr->v[1];

	mov	edx, DWORD PTR [esi-4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, edx
$LN42@simplex_lo:

; 1122 :          }
; 1123 :       we_ptr->f[we_ptr->fcount++] = se_ptr->f;

	mov	edx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR [ecx+edx*4+12], edi
	inc	DWORD PTR [ecx+8]

; 1124 :       fl=fedge+edges_per*loc_ordinal(se_ptr->f) ; while ( *fl ) fl++;

	test	DWORD PTR [esi], 268435456		; 10000000H
	je	SHORT $LN67@simplex_lo
	mov	edx, DWORD PTR [esi]
	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN68@simplex_lo
$LN67@simplex_lo:
	or	edx, -1
$LN68@simplex_lo:
	imul	edx, DWORD PTR _edges_per$[ebp]
	mov	edi, DWORD PTR _fedge$[ebp]
	cmp	DWORD PTR [edi+edx*4], 0
	lea	edx, DWORD PTR [edi+edx*4]
	je	SHORT $LN39@simplex_lo
$LL40@simplex_lo:
	add	edx, 4
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LL40@simplex_lo
$LN39@simplex_lo:

; 1117 :   for ( k = 0, se_ptr = se, we_ptr = we-1 ; k < se_count ; k++, se_ptr++ )

	add	esi, 12					; 0000000cH
	dec	DWORD PTR tv372[ebp]

; 1125 :       *fl = we_ptr; /* inverse list */

	mov	DWORD PTR [edx], ecx
	jne	SHORT $LL45@simplex_lo
$LN121@simplex_lo:

; 1126 :     }
; 1127 :   temp_free((char*)se);  /* don't need anymore */

	mov	eax, DWORD PTR _se$[ebp]
	push	eax
	call	_temp_free

; 1128 : 
; 1129 :   /* go through working list, chopping long edges */
; 1130 :   for ( we_ptr = we, k = 0 ; k < we_count ; k++,we_ptr++ )

	mov	eax, DWORD PTR _we_count$[ebp]
	add	esp, 4
	test	eax, eax
	jle	$LN36@simplex_lo

; 1126 :     }
; 1127 :   temp_free((char*)se);  /* don't need anymore */

	mov	ecx, DWORD PTR _we$[ebp]
	add	ecx, 8
	mov	DWORD PTR tv1549[ebp], ecx
	mov	ecx, DWORD PTR _web+12
	mov	DWORD PTR tv695[ebp], eax
$LL38@simplex_lo:

; 1131 :      { 
; 1132 :         REAL *x1, *x2;
; 1133 :         REAL newx[MAXCOORD];
; 1134 :         REAL side[MAXCOORD];
; 1135 :         conmap_t conmap[MAXCONPER];  // for common
; 1136 :         vertex_id newv;
; 1137 :         facet_id newf;
; 1138 :         REAL len;
; 1139 : 
; 1140 :         v0 = we_ptr->v[0]; v1 = we_ptr->v[1];

	mov	eax, DWORD PTR tv1549[ebp]
	mov	ebx, DWORD PTR [eax-8]
	mov	eax, DWORD PTR [eax-4]

; 1141 :         x1 = get_coord(v0); x2 = get_coord(v1);

	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+esi+64]
	mov	DWORD PTR _v0$[ebp], ebx
	mov	DWORD PTR _v1$[ebp], eax
	and	ebx, 134217727				; 07ffffffH
	and	eax, 134217727				; 07ffffffH
	add	ebx, ebx
	add	eax, eax
	add	eax, eax
	mov	edi, DWORD PTR [eax+ecx]
	add	ebx, ebx
	mov	esi, DWORD PTR [ebx+ecx]
	add	esi, edx
	add	edi, edx

; 1142 :         for ( i = 0 ;  i < SDIM ; i++ ) side[i] = x1[i] - x2[i];

	cmp	DWORD PTR _web+616, 0
	mov	DWORD PTR tv814[ebp], eax
	jle	SHORT $LN33@simplex_lo
	mov	ecx, esi
	lea	edx, DWORD PTR _side$90099[ebp]
	sub	ecx, edi
	sub	edx, edi
	mov	DWORD PTR tv1542[ebp], edx
	mov	edx, DWORD PTR _web+616
	mov	eax, edi
	mov	DWORD PTR tv273[ebp], edx
$LL35@simplex_lo:
	fld	QWORD PTR [ecx+eax]
	mov	edx, DWORD PTR tv1542[ebp]
	fsub	QWORD PTR [eax]
	add	eax, 8
	dec	DWORD PTR tv273[ebp]
	fstp	QWORD PTR [edx+eax-8]
	jne	SHORT $LL35@simplex_lo
$LN33@simplex_lo:

; 1143 :         len = sqrt(SDIM_dot(side,side));  

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _side$90099[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 1144 :         if ( len < max_len ) continue;  

	fcomp	QWORD PTR _max_len$[ebp]
	fnstsw	ax
	test	ah, 5
	jnp	$LN115@simplex_lo

; 1145 : 
; 1146 :         /* now have long edge */
; 1147 :         /* put vertex in middle */
; 1148 :         for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	test	edx, edx
	jle	SHORT $LN29@simplex_lo
	fld	QWORD PTR __real@3fe0000000000000
	lea	ecx, DWORD PTR _newx$90098[ebp]
	sub	edi, esi
	mov	eax, esi
	sub	ecx, esi
$LN31@simplex_lo:

; 1149 :           newx[i] = (x1[i] + x2[i])/2;

	fld	QWORD PTR [edi+eax]
	add	eax, 8
	dec	edx
	fadd	QWORD PTR [eax-8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [ecx+eax-8]
	jne	SHORT $LN31@simplex_lo

; 1145 : 
; 1146 :         /* now have long edge */
; 1147 :         /* put vertex in middle */
; 1148 :         for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN29@simplex_lo:

; 1150 :         newv = new_vertex(newx,NULLID);

	lea	eax, DWORD PTR _newx$90098[ebp]
	push	0
	push	eax
	call	_new_vertex

; 1151 :         set_attr(newv,get_vattr(v0)&get_vattr(v1));

	mov	edx, DWORD PTR _web+12
	mov	esi, eax
	mov	DWORD PTR _newv$90101[ebp], eax
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [ecx+esi]
	mov	ecx, DWORD PTR tv814[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	edi, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ebx+edx]
	mov	ecx, DWORD PTR [ecx+12]
	and	ecx, DWORD PTR [edx+12]
	and	edi, DWORD PTR [edx+8]
	or	DWORD PTR [eax+12], ecx
	or	DWORD PTR [eax+8], edi

; 1152 :         get_v_common_conmap(v0,v1,conmap,MAXCONPER);

	mov	eax, DWORD PTR _v1$[ebp]
	mov	ecx, DWORD PTR _v0$[ebp]
	push	23					; 00000017H
	lea	edx, DWORD PTR _conmap$90100[ebp]
	push	edx
	push	eax
	push	ecx
	call	_get_v_common_conmap

; 1153 :         for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, 1
	add	esp, 24					; 00000018H
	mov	DWORD PTR _j$[ebp], eax
	cmp	DWORD PTR _conmap$90100[ebp], eax
	jl	SHORT $LN116@simplex_lo
	npad	5
$LL28@simplex_lo:

; 1154 :         { int c = conmap[j] & CONMASK;

	mov	edx, DWORD PTR _j$[ebp]
	mov	edi, DWORD PTR _conmap$90100[ebp+edx*4]

; 1155 :           set_v_constraint_map(newv,c);

	mov	eax, DWORD PTR _newv$90101[ebp]
	and	edi, 1073741823				; 3fffffffH
	push	edi
	push	eax
	call	_set_v_constraint_map

; 1156 :           if ( get_v_constraint_status(v0,c) && get_v_constraint_status(v1,c) )

	mov	ecx, DWORD PTR _v0$[ebp]
	push	edi
	push	ecx
	call	_get_v_constraint_status
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN27@simplex_lo
	mov	edx, DWORD PTR _v1$[ebp]
	push	edi
	push	edx
	call	_get_v_constraint_status
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@simplex_lo

; 1157 :              set_v_constraint_status(newv,c);

	mov	eax, DWORD PTR _newv$90101[ebp]
	push	edi
	push	eax
	call	_set_v_constraint_status
	add	esp, 8
$LN27@simplex_lo:

; 1153 :         for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _conmap$90100[ebp]
	jle	SHORT $LL28@simplex_lo
$LN116@simplex_lo:

; 1158 :         }
; 1159 :         if ( get_vattr(v0) & BOUNDARY )

	mov	ecx, DWORD PTR _web+12
	mov	ebx, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [ebx+8]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN114@simplex_lo

; 1160 :          if ( get_boundary(v0) == get_boundary(v1) )

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN114@simplex_lo
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	edi, DWORD PTR _web+776
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edx, DWORD PTR [eax+ebx]
	mov	ebx, DWORD PTR tv814[ebp]
	imul	edx, 136				; 00000088H
	mov	ebx, DWORD PTR [ebx+ecx]
	mov	ebx, DWORD PTR [ebx+eax]
	imul	ebx, 136				; 00000088H
	add	edx, edi
	add	edi, ebx
	cmp	edx, edi
	jne	SHORT $LN114@simplex_lo

; 1161 :           set_boundary_num(newv,get_boundary(v0)->num);

	mov	ecx, DWORD PTR [esi+ecx]
	mov	edx, DWORD PTR [edx+44]
	mov	DWORD PTR [eax+ecx], edx
	mov	ecx, DWORD PTR _web+12
$LN114@simplex_lo:

; 1162 :         /* construct new simplices */
; 1163 :         for ( n = 0 ; n < we_ptr->fcount ; n++ )

	mov	eax, DWORD PTR tv1549[ebp]
	cmp	DWORD PTR [eax], 0
	mov	DWORD PTR _n$[ebp], 0
	jle	$LN20@simplex_lo
	mov	ecx, eax
	add	ecx, 4
	mov	DWORD PTR tv1529[ebp], ecx
	npad	1
$LL22@simplex_lo:

; 1164 :           { 
; 1165 :              vertex_id *v,*oldv;
; 1166 :              f_id = we_ptr->f[n];

	mov	edx, DWORD PTR tv1529[ebp]
	mov	esi, DWORD PTR [edx]

; 1167 :              /* copy relevant properties of old facet */
; 1168 :              newf = dup_facet(f_id);

	push	esi
	mov	DWORD PTR _f_id$[ebp], esi
	call	_dup_facet

; 1169 :              v = get_facet_vertices(newf);

	mov	ecx, DWORD PTR _dymem
	mov	edi, eax
	mov	DWORD PTR _newf$90102[ebp], eax
	mov	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+236
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edi*4]

; 1170 :              oldv = get_facet_vertices(f_id);

	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+esi*4]

; 1171 :              for ( j = 0 ; j <= web.dimension ; j++ )

	xor	ebx, ebx
	add	esp, 4
	add	ecx, edx
	add	eax, edx
	cmp	DWORD PTR _web+620, ebx
	jl	SHORT $LN119@simplex_lo
	sub	ecx, eax
	mov	DWORD PTR tv1461[ebp], ecx
	npad	2
$LL19@simplex_lo:

; 1172 :              { if ( equal_id(v0,oldv[j]) ) v[j] = newv;

	mov	edx, DWORD PTR [eax]
	cmp	DWORD PTR _v0$[ebp], edx
	jne	SHORT $LN16@simplex_lo
	mov	edx, DWORD PTR tv1461[ebp]
	mov	ecx, DWORD PTR _newv$90101[ebp]
	mov	DWORD PTR [edx+eax], ecx
	jmp	SHORT $LN15@simplex_lo
$LN16@simplex_lo:

; 1173 :                else v[j] = oldv[j];

	mov	ecx, DWORD PTR tv1461[ebp]
	mov	DWORD PTR [ecx+eax], edx
$LN15@simplex_lo:

; 1174 :                if ( equal_id(v1,oldv[j]) ) oldv[j] = newv;

	mov	edx, DWORD PTR _v1$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN18@simplex_lo
	mov	ecx, DWORD PTR _newv$90101[ebp]
	mov	DWORD PTR [eax], ecx
$LN18@simplex_lo:

; 1171 :              for ( j = 0 ; j <= web.dimension ; j++ )

	inc	ebx
	add	eax, 4
	cmp	ebx, DWORD PTR _web+620
	jle	SHORT $LL19@simplex_lo
$LN119@simplex_lo:

; 1175 :              }
; 1176 :              /* update working list */
; 1177 :              if ( web.skel[FACET].max_ord >= fedge_max )

	mov	eax, DWORD PTR _web+292
	cmp	eax, DWORD PTR _fedge_max$[ebp]
	jl	SHORT $LN13@simplex_lo

; 1178 :              { fedge_max = web.skel[FACET].max_ord+100;
; 1179 :                fedge = (struct w_edge **)temp_realloc((char*)fedge,
; 1180 :                                fedge_max*edges_per*sizeof(struct w_edge *));

	mov	edx, DWORD PTR _fedge$[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR _fedge_max$[ebp], eax
	imul	eax, DWORD PTR _edges_per$[ebp]
	push	1180					; 0000049cH
	add	eax, eax
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	add	eax, eax
	push	eax
	push	edx
	call	_kb_temp_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _fedge$[ebp], eax
$LN13@simplex_lo:

; 1181 :              }
; 1182 :              fl = fedge + loc_ordinal(f_id)*edges_per;

	mov	ebx, 268435456				; 10000000H
	test	DWORD PTR _f_id$[ebp], ebx
	je	SHORT $LN77@simplex_lo
	mov	eax, esi
	jmp	SHORT $LN78@simplex_lo
$LN77@simplex_lo:
	or	eax, -1
$LN78@simplex_lo:
	mov	ecx, DWORD PTR _edges_per$[ebp]
	mov	edx, DWORD PTR _fedge$[ebp]
	imul	eax, ecx
	lea	esi, DWORD PTR [edx+eax*4]

; 1183 :              newfl = fedge + loc_ordinal(newf)*edges_per;

	test	DWORD PTR _newf$90102[ebp], ebx
	je	SHORT $LN79@simplex_lo
	mov	eax, edi
	jmp	SHORT $LN80@simplex_lo
$LN79@simplex_lo:
	or	eax, -1
$LN80@simplex_lo:
	imul	eax, ecx
	lea	edi, DWORD PTR [edx+eax*4]

; 1184 :              for ( m = 0 ; m<edges_per ; fl++,m++ )

	test	ecx, ecx
	jle	$LN21@simplex_lo

; 1183 :              newfl = fedge + loc_ordinal(newf)*edges_per;

	mov	DWORD PTR tv232[ebp], ecx
	npad	4
$LL124@simplex_lo:

; 1185 :                 { if ( !*fl || (*fl)->v[0] == v0 ) continue; /* is ok */

	mov	edx, DWORD PTR [esi]
	test	edx, edx
	je	$LN11@simplex_lo
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _v0$[ebp]
	je	$LN11@simplex_lo

; 1186 :                   if ( (*fl)->v[1] == v1 )

	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR _v1$[ebp]
	jne	SHORT $LN7@simplex_lo

; 1187 :                      { /* replace f_id with newf */
; 1188 :                         for ( j = 0 ; j < (*fl)->fcount ; j++ )

	xor	eax, eax
	cmp	DWORD PTR [edx+8], eax
	jle	SHORT $LN4@simplex_lo
	lea	ecx, DWORD PTR [edx+12]
	npad	3
$LL120@simplex_lo:

; 1189 :                           if ( f_id == (*fl)->f[j] )

	mov	ebx, DWORD PTR _f_id$[ebp]
	cmp	ebx, DWORD PTR [ecx]
	je	SHORT $LN97@simplex_lo

; 1187 :                      { /* replace f_id with newf */
; 1188 :                         for ( j = 0 ; j < (*fl)->fcount ; j++ )

	inc	eax
	add	ecx, 4
	cmp	eax, DWORD PTR [edx+8]
	jl	SHORT $LL120@simplex_lo

; 1191 :                         *(newfl++) = *fl; /* transfer edge to new facet */

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edi], edx

; 1192 :                         *fl = NULL;

	mov	DWORD PTR [esi], 0

; 1193 :                      }
; 1194 :                   else /* add newf to edge */

	jmp	SHORT $LN129@simplex_lo
$LN97@simplex_lo:

; 1190 :                              { (*fl)->f[j] = newf; break; }

	mov	ecx, DWORD PTR _newf$90102[ebp]
	mov	DWORD PTR [edx+eax*4+12], ecx
$LN4@simplex_lo:

; 1191 :                         *(newfl++) = *fl; /* transfer edge to new facet */

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edi], edx

; 1192 :                         *fl = NULL;

	mov	DWORD PTR [esi], 0

; 1193 :                      }
; 1194 :                   else /* add newf to edge */

	jmp	SHORT $LN129@simplex_lo
$LN7@simplex_lo:

; 1195 :                      { if ( (*fl)->fcount >= MAXFACET )

	cmp	DWORD PTR [edx+8], 10			; 0000000aH
	jl	SHORT $LN1@simplex_lo

; 1196 :                           kb_error(1550,"Edge has too many simplices.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BO@HDGGNHOG@Edge?5has?5too?5many?5simplices?4?6?$AA@
	push	1550					; 0000060eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@simplex_lo:

; 1197 : 
; 1198 :                         (*fl)->f[(*fl)->fcount++] = newf;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _newf$90102[ebp]
	mov	DWORD PTR [eax+ecx*4+12], edx
	mov	eax, DWORD PTR [esi]
	inc	DWORD PTR [eax+8]

; 1199 :                         *(newfl++) = *fl; /* add edge to new facet */

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
$LN129@simplex_lo:
	add	edi, 4
$LN11@simplex_lo:

; 1184 :              for ( m = 0 ; m<edges_per ; fl++,m++ )

	add	esi, 4
	dec	DWORD PTR tv232[ebp]
	jne	$LL124@simplex_lo
$LN21@simplex_lo:

; 1162 :         /* construct new simplices */
; 1163 :         for ( n = 0 ; n < we_ptr->fcount ; n++ )

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR tv1549[ebp]
	add	DWORD PTR tv1529[ebp], 4
	inc	eax
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, DWORD PTR [ecx]
	jl	$LL22@simplex_lo
	mov	ecx, DWORD PTR _web+12
$LN20@simplex_lo:

; 1200 :                      }
; 1201 :                 }
; 1202 :           }
; 1203 :       divcount++;

	inc	DWORD PTR _divcount$[ebp]
	jmp	SHORT $LN37@simplex_lo
$LN115@simplex_lo:
	mov	ecx, DWORD PTR _web+12
$LN37@simplex_lo:

; 1128 : 
; 1129 :   /* go through working list, chopping long edges */
; 1130 :   for ( we_ptr = we, k = 0 ; k < we_count ; k++,we_ptr++ )

	add	DWORD PTR tv1549[ebp], 52		; 00000034H
	dec	DWORD PTR tv695[ebp]
	jne	$LL38@simplex_lo
$LN36@simplex_lo:

; 1204 :      }
; 1205 :   temp_free((char*)we);

	mov	edx, DWORD PTR _we$[ebp]
	push	edx
	call	_temp_free

; 1206 :   temp_free((char*)fedge);

	mov	eax, DWORD PTR _fedge$[ebp]
	push	eax
	call	_temp_free

; 1207 :   return divcount;
; 1208 : } // end simplex_long_edges()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, DWORD PTR _divcount$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_long_edges ENDP
_TEXT	ENDS
PUBLIC	_v2$GSCopy$
PUBLIC	_v1$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_delete_edge
EXTRN	_free_element:PROC
EXTRN	_get_next_vertex_facet:PROC
EXTRN	_get_vertex_first_facet:PROC
; Function compile flags: /Ogtp
;	COMDAT _simplex_delete_edge
_TEXT	SEGMENT
tv340 = -432						; size = 8
_attrj$ = -432						; size = 8
_attri$ = -432						; size = 8
tv373 = -424						; size = 4
tv355 = -420						; size = 4
_conmapi$90289 = -420					; size = 4
_v2$GSCopy$ = -416					; size = 4
_n$ = -416						; size = 4
tv332 = -412						; size = 4
_m$ = -412						; size = 4
_common$90301 = -412					; size = 4
_v1$GSCopy$ = -408					; size = 4
_throwv$ = -408						; size = 4
_f_ids$ = -404						; size = 400
__$ArrayPad$ = -4					; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_simplex_delete_edge PROC				; COMDAT

; 1263 : { vertex_id keepv; /* vertex to keep */

	push	ebp
	mov	ebp, esp
	sub	esp, 432				; 000001b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _v1$[ebp]
	mov	edx, DWORD PTR _v2$[ebp]
	push	ebx

; 1264 :   vertex_id throwv; /* vertex to delete */
; 1265 :   ATTR attri,attrj;
; 1266 :   facet_id f_id,fstart,f_ids[100];
; 1267 :   int k,m,n;
; 1268 : 
; 1269 :   /* check attributes */
; 1270 :   keepv = NULLID;
; 1271 :   attri = get_vattr(v1); attrj = get_vattr(v2);

	mov	ecx, eax
	mov	DWORD PTR _v1$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _web+12
	push	esi
	and	ecx, 134217727				; 07ffffffH
	mov	DWORD PTR _v2$GSCopy$[ebp], edx
	and	edx, 134217727				; 07ffffffH
	push	edi
	mov	edi, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	esi, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR _attri$[ebp+4], esi
	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR tv332[ebp], eax

; 1272 :   if ( (attri & BOUNDARY) && (attrj & CONSTRAINT) ) return 0;

	mov	eax, ecx
	and	eax, 128				; 00000080H
	mov	DWORD PTR _attrj$[ebp+4], edx
	xor	edx, edx
	mov	ebx, eax
	or	ebx, edx
	je	SHORT $LN59@simplex_de
	mov	edx, esi
	and	edx, 1024				; 00000400H
	xor	ebx, ebx
	or	edx, ebx
	jne	$LN74@simplex_de
$LN59@simplex_de:

; 1273 :   if ( (attri & CONSTRAINT) && (attrj & BOUNDARY) ) return 0;

	and	ecx, 1024				; 00000400H
	xor	edx, edx
	mov	DWORD PTR tv340[ebp], ecx
	or	ecx, edx
	je	SHORT $LN60@simplex_de
	mov	edx, esi
	and	edx, 128				; 00000080H
	xor	ebx, ebx
	or	edx, ebx
	jne	$LN74@simplex_de
$LN60@simplex_de:

; 1274 :   if ( (attri & BOUNDARY) && (attrj & BOUNDARY)
; 1275 :          && (get_boundary(v1) != get_boundary(v2)) ) return 0;

	xor	ecx, ecx
	mov	edx, eax
	or	edx, ecx
	mov	ecx, DWORD PTR _web+104
	je	SHORT $LN32@simplex_de
	mov	edx, esi
	and	edx, 128				; 00000080H
	xor	ebx, ebx
	or	edx, ebx
	je	SHORT $LN32@simplex_de
	mov	edx, DWORD PTR _V_BOUNDARY_ATTR
	test	edx, edx
	je	SHORT $LN32@simplex_de
	imul	edx, 240				; 000000f0H
	add	edx, ecx
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ecx+64]
	mov	ebx, DWORD PTR [edx+edi]
	mov	ecx, DWORD PTR _web+776
	imul	ebx, 136				; 00000088H
	add	ebx, ecx
	mov	DWORD PTR tv355[ebp], ebx
	mov	ebx, DWORD PTR tv332[ebp]
	mov	edx, DWORD PTR [edx+ebx]
	imul	edx, 136				; 00000088H
	add	ecx, edx
	cmp	DWORD PTR tv355[ebp], ecx
	jne	$LN74@simplex_de
	mov	ecx, DWORD PTR _web+104
$LN32@simplex_de:

; 1276 :   if ( attri & BOUNDARY ) keepv = v1;

	mov	ebx, DWORD PTR _v1$GSCopy$[ebp]
	xor	edx, edx
	or	eax, edx
	jne	SHORT $LN31@simplex_de
	mov	ebx, edx
$LN31@simplex_de:

; 1277 :   else if ( attri & BOUNDARY ) keepv = v2;
; 1278 :   if ( (attri & CONSTRAINT) && (attrj & CONSTRAINT) )

	mov	edx, DWORD PTR tv340[ebp]
	xor	eax, eax
	or	edx, eax
	je	$LN28@simplex_de
	mov	eax, esi
	and	eax, 1024				; 00000400H
	xor	edx, edx
	or	eax, edx
	je	$LN28@simplex_de

; 1279 :   { conmap_t *conmapi = get_v_constraint_map(v1);

	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [ecx+edx+1288]
	test	eax, eax
	je	SHORT $LN41@simplex_de
	mov	ebx, DWORD PTR [ecx+edx+1264]
	add	ebx, edi
	jmp	SHORT $LN73@simplex_de
$LN41@simplex_de:
	mov	ebx, OFFSET _nullcon
$LN73@simplex_de:
	mov	DWORD PTR _conmapi$90289[ebp], ebx

; 1280 :      conmap_t *conmapj = get_v_constraint_map(v2);

	test	eax, eax
	je	SHORT $LN43@simplex_de
	mov	edx, DWORD PTR [ecx+edx+1264]
	add	edx, DWORD PTR tv332[ebp]
	jmp	SHORT $LN44@simplex_de
$LN43@simplex_de:
	mov	edx, OFFSET _nullcon
$LN44@simplex_de:

; 1281 :      int common,kk;
; 1282 :      for ( k = 1, common=0 ; k <= (int)conmapi[0] ; k++ )

	mov	ecx, DWORD PTR [ebx]
	mov	esi, 1
	xor	eax, eax
	mov	DWORD PTR _common$90301[ebp], eax
	mov	DWORD PTR tv373[ebp], ecx
	cmp	ecx, esi
	jl	SHORT $LN25@simplex_de
	mov	edi, DWORD PTR [edx]
	npad	1
$LL27@simplex_de:

; 1283 :         for ( kk = 1 ; kk <= (int)conmapj[0] ; kk++ )

	mov	eax, 1
	cmp	edi, eax
	jl	SHORT $LN26@simplex_de
	mov	ecx, DWORD PTR [ebx+esi*4]
	and	ecx, 1073741823				; 3fffffffH
$LL24@simplex_de:

; 1284 :           if ( (conmapi[k]&CONMASK) == (conmapj[kk]&CONMASK) )

	mov	ebx, DWORD PTR [edx+eax*4]
	and	ebx, 1073741823				; 3fffffffH
	cmp	ecx, ebx
	jne	SHORT $LN23@simplex_de

; 1285 :                         common++;

	inc	DWORD PTR _common$90301[ebp]
$LN23@simplex_de:

; 1283 :         for ( kk = 1 ; kk <= (int)conmapj[0] ; kk++ )

	inc	eax
	cmp	eax, edi
	jle	SHORT $LL24@simplex_de
	mov	ecx, DWORD PTR tv373[ebp]
	mov	ebx, DWORD PTR _conmapi$90289[ebp]
$LN26@simplex_de:

; 1281 :      int common,kk;
; 1282 :      for ( k = 1, common=0 ; k <= (int)conmapi[0] ; k++ )

	inc	esi
	cmp	esi, ecx
	jle	SHORT $LL27@simplex_de
	mov	eax, DWORD PTR _common$90301[ebp]
$LN25@simplex_de:

; 1286 :      if ( conmapi[0] < conmapj[0] )  

	mov	edx, DWORD PTR [edx]
	cmp	ecx, edx
	jae	SHORT $LN20@simplex_de

; 1287 :       { if ( common < (int)conmapi[0] ) return 0;

	cmp	eax, ecx
	jge	SHORT $LN19@simplex_de
$LN74@simplex_de:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1317 :     return 1;
; 1318 : 
; 1319 : } // end simplex_delete_edge()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@simplex_de:

; 1288 :          keepv = v2;
; 1289 :       }
; 1290 :      else { if ( common < (int)conmapj[0] ) return 0;

	cmp	eax, edx
	jge	SHORT $LN17@simplex_de
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1317 :     return 1;
; 1318 : 
; 1319 : } // end simplex_delete_edge()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@simplex_de:

; 1291 :               keepv = v1;
; 1292 :             }
; 1293 :     }
; 1294 :     else if ( attri & CONSTRAINT ) keepv = v1;

	mov	eax, DWORD PTR tv340[ebp]
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN15@simplex_de
$LN17@simplex_de:
	mov	ebx, DWORD PTR _v1$GSCopy$[ebp]
	jmp	SHORT $LN63@simplex_de
$LN15@simplex_de:

; 1295 :     else if ( attrj & CONSTRAINT ) keepv = v2;

	and	esi, 1024				; 00000400H
	xor	eax, eax
	or	esi, eax
	je	SHORT $LN63@simplex_de
$LN19@simplex_de:
	mov	ebx, DWORD PTR _v2$GSCopy$[ebp]
$LN63@simplex_de:

; 1296 :     if ( keepv == NULLID ) keepv = v1;

	test	ebx, ebx
	jne	SHORT $LN12@simplex_de
	mov	ebx, DWORD PTR _v1$GSCopy$[ebp]

; 1297 : 
; 1298 :     throwv = (keepv==v1) ? v2 : v1;

	jmp	SHORT $LN58@simplex_de
$LN12@simplex_de:
	mov	eax, DWORD PTR _v1$GSCopy$[ebp]
	cmp	ebx, eax
	jne	SHORT $LN45@simplex_de
$LN58@simplex_de:
	mov	eax, DWORD PTR _v2$GSCopy$[ebp]
$LN45@simplex_de:

; 1299 : 
; 1300 :     /* change vertex in facets around throwv */
; 1301 :     /* and delete all facets around keepv that have throwv */
; 1302 :     f_id = fstart = get_vertex_first_facet(throwv);

	mov	ecx, eax
	push	ecx
	mov	DWORD PTR _throwv$[ebp], eax
	call	_get_vertex_first_facet
	add	esp, 4
	mov	esi, eax

; 1303 :     for ( n = 0 ; n < 100 ;  )

	xor	edi, edi
	npad	4
$LL11@simplex_de:

; 1305 :       f_id =  get_next_vertex_facet(throwv,f_id);

	mov	edx, DWORD PTR _throwv$[ebp]
	push	eax
	mov	DWORD PTR _f_ids$[ebp+edi*4], eax
	push	edx
	inc	edi
	call	_get_next_vertex_facet
	add	esp, 8

; 1306 :       if ( equal_id (f_id,fstart) ) break;

	cmp	eax, esi
	je	SHORT $LN72@simplex_de

; 1303 :     for ( n = 0 ; n < 100 ;  )

	cmp	edi, 100				; 00000064H
	jl	SHORT $LL11@simplex_de
$LN72@simplex_de:

; 1304 :     { f_ids[n++] = f_id;

	mov	DWORD PTR _n$[ebp], edi

; 1307 :     }
; 1308 :     for ( m = 0 ; m < n ; m++ )

	mov	DWORD PTR _m$[ebp], 0
	test	edi, edi
	jle	$LN6@simplex_de
	npad	7
$LL70@simplex_de:

; 1309 :     { vertex_id * fv = get_facet_vertices(f_ids[m]);

	mov	eax, DWORD PTR _m$[ebp]
	mov	esi, DWORD PTR _f_ids$[ebp+eax*4]
	mov	edx, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+328
	add	eax, DWORD PTR [edx+ecx+304]

; 1310 :       for ( k = 0 ; k <= web.dimension ; k++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+620, ecx
	jl	SHORT $LN7@simplex_de
	npad	5
$LL5@simplex_de:

; 1311 :          { if ( equal_id(fv[k],keepv) )

	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	edx, ebx
	je	SHORT $LN53@simplex_de

; 1313 :             if ( equal_id(fv[k],throwv) ) fv[k] = keepv;

	cmp	edx, DWORD PTR _throwv$[ebp]
	jne	SHORT $LN4@simplex_de
	mov	DWORD PTR [eax+ecx*4], ebx
$LN4@simplex_de:

; 1311 :          { if ( equal_id(fv[k],keepv) )

	mov	edi, DWORD PTR _n$[ebp]
	inc	ecx
	cmp	ecx, DWORD PTR _web+620
	jle	SHORT $LL5@simplex_de
	jmp	SHORT $LN7@simplex_de
$LN53@simplex_de:

; 1312 :             { free_element(f_ids[m]); break; }

	push	esi
	call	_free_element
	add	esp, 4
$LN7@simplex_de:

; 1307 :     }
; 1308 :     for ( m = 0 ; m < n ; m++ )

	mov	eax, DWORD PTR _m$[ebp]
	inc	eax
	mov	DWORD PTR _m$[ebp], eax
	cmp	eax, edi
	jl	SHORT $LL70@simplex_de
$LN6@simplex_de:

; 1314 :          }
; 1315 :       } 
; 1316 :     free_element(throwv);

	mov	eax, DWORD PTR _throwv$[ebp]
	push	eax
	call	_free_element

; 1317 :     return 1;
; 1318 : 
; 1319 : } // end simplex_delete_edge()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 4
	pop	edi
	pop	esi
	xor	ecx, ebp
	mov	eax, 1
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_delete_edge ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_delete_facet
; Function compile flags: /Ogtp
;	COMDAT _simplex_delete_facet
_TEXT	SEGMENT
tv761 = -612						; size = 4
tv766 = -608						; size = 4
tv752 = -604						; size = 4
_x2$90377 = -600					; size = 4
_v$ = -596						; size = 4
tv2001 = -592						; size = 4
_m$ = -588						; size = 4
_sscount$ = -584					; size = 4
_sids$ = -580						; size = 576
__$ArrayPad$ = -4					; size = 4
_f_id$ = 8						; size = 4
_simplex_delete_facet PROC				; COMDAT

; 1328 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 612				; 00000264H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1329 :   int j,k,m,n;
; 1330 :   struct sid { vertex_id v1,v2; REAL length; } sids[MAXCOORD*MAXCOORD],*ss;
; 1331 :   int sscount;
; 1332 :   vertex_id *v;
; 1333 :   REAL sum;
; 1334 : 
; 1335 :   v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+304]

; 1336 :   for ( m = 0,ss=sids,sscount = 0 ; m < web.dimension ; m++ )

	mov	ecx, DWORD PTR _web+620
	push	ebx
	push	esi
	push	edi
	xor	edi, edi
	xor	esi, esi
	mov	DWORD PTR _v$[ebp], eax
	mov	DWORD PTR _m$[ebp], edi
	mov	DWORD PTR _sscount$[ebp], esi
	test	ecx, ecx
	jle	$LN16@simplex_de@2
	fldz

; 1337 :      for ( n = m+1 ; m <= web.dimension ; m++,ss++,sscount++ )

	cmp	edi, ecx
	jg	$LN17@simplex_de@2
$LN88@simplex_de@2:
	mov	eax, DWORD PTR [eax+edi*4+4]

; 1351 :         return 1;

	mov	edx, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
	mov	ebx, DWORD PTR [edx+ebx+64]
	mov	edx, DWORD PTR _web+12
	mov	DWORD PTR tv766[ebp], eax
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	add	edx, ebx
	add	esi, esi
	lea	eax, DWORD PTR _sids$[ebp+esi*8-16]
	mov	DWORD PTR tv761[ebp], ebx
	mov	DWORD PTR _x2$90377[ebp], edx
	mov	DWORD PTR tv2001[ebp], eax
	jmp	SHORT $LN15@simplex_de@2
$LN41@simplex_de@2:

; 1337 :      for ( n = m+1 ; m <= web.dimension ; m++,ss++,sscount++ )

	mov	edx, DWORD PTR _x2$90377[ebp]
	mov	ebx, DWORD PTR tv761[ebp]
$LN15@simplex_de@2:

; 1338 :      { REAL *x1 = get_coord(v[m]);

	mov	eax, DWORD PTR _v$[ebp]

; 1339 :         REAL *x2 = get_coord(v[n]);
; 1340 :         for (  k = 0, sum = 0.0 ; k < web.dimension ; k++ )

	fld	ST(0)
	mov	eax, DWORD PTR [eax+edi*4]
	mov	esi, DWORD PTR _web+12
	mov	DWORD PTR tv752[ebp], eax
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+eax*4]
	add	esi, ebx
	xor	ebx, ebx
	cmp	ecx, 4
	jl	SHORT $LC34@simplex_de@2

; 1341 :           sum += (x1[k]-x2[k])*(x1[k]-x2[k]);

	lea	eax, DWORD PTR [edx+8]
	mov	edi, esi
	sub	edi, edx
	mov	edx, DWORD PTR _web+620
	add	edx, -4					; fffffffcH
	shr	edx, 2
	inc	edx
	lea	ecx, DWORD PTR [esi+24]
	lea	ebx, DWORD PTR [edx*4]
$LN35@simplex_de@2:
	fld	QWORD PTR [ecx-24]
	add	eax, 32					; 00000020H
	fsub	QWORD PTR [eax-40]
	add	ecx, 32					; 00000020H
	dec	edx
	fld	QWORD PTR [eax+edi-32]
	fsub	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx-40]
	fsub	QWORD PTR [eax-24]
	fld	QWORD PTR [ecx-32]
	fsub	QWORD PTR [eax-16]
	fld	ST(3)
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	faddp	ST(4), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(3)
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LN35@simplex_de@2

; 1338 :      { REAL *x1 = get_coord(v[m]);

	mov	edi, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _x2$90377[ebp]
	mov	ecx, DWORD PTR _web+620
$LC34@simplex_de@2:

; 1339 :         REAL *x2 = get_coord(v[n]);
; 1340 :         for (  k = 0, sum = 0.0 ; k < web.dimension ; k++ )

	cmp	ebx, ecx
	jge	SHORT $LN33@simplex_de@2
	sub	esi, edx
	lea	eax, DWORD PTR [edx+ebx*8]
	sub	ecx, ebx
$LC12@simplex_de@2:

; 1341 :           sum += (x1[k]-x2[k])*(x1[k]-x2[k]);

	fld	QWORD PTR [eax+esi]
	add	eax, 8
	dec	ecx
	fsub	QWORD PTR [eax-8]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LC12@simplex_de@2
$LN33@simplex_de@2:

; 1342 :         for ( j = sscount ; j > 0 ; j-- )

	mov	esi, DWORD PTR _sscount$[ebp]
	mov	edx, esi
	cmp	esi, 4
	jl	$LC36@simplex_de@2
	mov	ecx, DWORD PTR tv2001[ebp]
$LN40@simplex_de@2:

; 1343 :           if ( sids[j-1].length < sum )  break;

	fcom	QWORD PTR [ecx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN43@simplex_de@2

; 1344 :           else sids[j] = sids[j-1];

	mov	eax, DWORD PTR [ecx]
	fcom	QWORD PTR [ecx-8]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+28], eax
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN37@simplex_de@2
	mov	eax, DWORD PTR [ecx-16]
	fcom	QWORD PTR [ecx-24]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [ecx-12]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [ecx-8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [ecx-4]
	mov	DWORD PTR [ecx+12], eax
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN38@simplex_de@2
	mov	eax, DWORD PTR [ecx-32]
	fcom	QWORD PTR [ecx-40]
	mov	DWORD PTR [ecx-16], eax
	mov	eax, DWORD PTR [ecx-28]
	mov	DWORD PTR [ecx-12], eax
	mov	eax, DWORD PTR [ecx-24]
	mov	DWORD PTR [ecx-8], eax
	mov	eax, DWORD PTR [ecx-20]
	mov	DWORD PTR [ecx-4], eax
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN39@simplex_de@2
	mov	eax, DWORD PTR [ecx-48]
	mov	DWORD PTR [ecx-32], eax
	mov	eax, DWORD PTR [ecx-44]
	mov	DWORD PTR [ecx-28], eax
	mov	eax, DWORD PTR [ecx-40]
	mov	DWORD PTR [ecx-24], eax
	mov	eax, DWORD PTR [ecx-36]
	mov	DWORD PTR [ecx-20], eax
	sub	edx, 4
	sub	ecx, 64					; 00000040H
	cmp	edx, 3
	jg	$LN40@simplex_de@2
$LC36@simplex_de@2:

; 1342 :         for ( j = sscount ; j > 0 ; j-- )

	test	edx, edx
	jle	SHORT $LN43@simplex_de@2
	mov	ecx, edx
	add	ecx, ecx
	lea	ecx, DWORD PTR _sids$[ebp+ecx*8-16]
$LC9@simplex_de@2:

; 1343 :           if ( sids[j-1].length < sum )  break;

	fcom	QWORD PTR [ecx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN43@simplex_de@2

; 1344 :           else sids[j] = sids[j-1];

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+28], eax
	dec	edx
	sub	ecx, 16					; 00000010H
	test	edx, edx
	jg	SHORT $LC9@simplex_de@2
	jmp	SHORT $LN43@simplex_de@2
$LN37@simplex_de@2:

; 1343 :           if ( sids[j-1].length < sum )  break;

	dec	edx
	jmp	SHORT $LN43@simplex_de@2
$LN38@simplex_de@2:
	sub	edx, 2
	jmp	SHORT $LN43@simplex_de@2
$LN39@simplex_de@2:
	sub	edx, 3
$LN43@simplex_de@2:

; 1345 :         sids[j].length = sum;
; 1346 :         sids[j].v1 = v[m];

	mov	ecx, DWORD PTR tv752[ebp]

; 1347 :         sids[j].v2 = v[n];

	mov	eax, DWORD PTR tv766[ebp]
	add	DWORD PTR tv2001[ebp], 16		; 00000010H
	add	edx, edx
	mov	DWORD PTR _sids$[ebp+edx*8], ecx
	fstp	QWORD PTR _sids$[ebp+edx*8+8]
	mov	ecx, DWORD PTR _web+620
	inc	edi
	inc	esi
	mov	DWORD PTR _sids$[ebp+edx*8+4], eax
	mov	DWORD PTR _m$[ebp], edi
	mov	DWORD PTR _sscount$[ebp], esi
	cmp	edi, ecx
	jle	$LN41@simplex_de@2

; 1337 :      for ( n = m+1 ; m <= web.dimension ; m++,ss++,sscount++ )

	mov	eax, DWORD PTR _v$[ebp]
$LN17@simplex_de@2:

; 1336 :   for ( m = 0,ss=sids,sscount = 0 ; m < web.dimension ; m++ )

	inc	edi
	mov	DWORD PTR _m$[ebp], edi
	cmp	edi, ecx
	jl	$LN88@simplex_de@2
	fstp	ST(0)
$LN16@simplex_de@2:

; 1348 :      }
; 1349 :   for ( k = 0 ; k < sscount ; k++ )

	xor	edi, edi
	test	esi, esi
	jle	SHORT $LN2@simplex_de@2
	lea	ebx, DWORD PTR _sids$[ebp]
$LL4@simplex_de@2:

; 1350 :      if ( simplex_delete_edge(sids[k].v1,sids[k].v2) )

	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	edx
	call	_simplex_delete_edge
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@simplex_de@2

; 1348 :      }
; 1349 :   for ( k = 0 ; k < sscount ; k++ )

	inc	edi
	add	ebx, 16					; 00000010H
	cmp	edi, esi
	jl	SHORT $LL4@simplex_de@2
$LN2@simplex_de@2:
	pop	edi
	pop	esi

; 1352 :   return 0;  

	xor	eax, eax
	pop	ebx

; 1353 : } // end simplex_delete_facet()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@simplex_de@2:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	mov	eax, 1
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_delete_facet ENDP
_TEXT	ENDS
PUBLIC	_rhs$GSCopy$
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_facet_hessian
EXTRN	_free_matrix:PROC
EXTRN	_fill_mixed_entry:PROC
EXTRN	_vhead:DWORD
EXTRN	_vhead_attr:DWORD
EXTRN	_tr_mat_mul:PROC
EXTRN	_mat_mult:PROC
EXTRN	_get_facet_verts:PROC
EXTRN	_kb_dmatrix:PROC
; Function compile flags: /Ogtp
;	COMDAT _simplex_facet_hessian
_TEXT	SEGMENT
_v$90496 = -192						; size = 28
tv676 = -164						; size = 4
tv1965 = -160						; size = 4
tv2156 = -156						; size = 4
tv1961 = -152						; size = 4
tv2191 = -148						; size = 4
_p2$ = -144						; size = 4
tv1951 = -140						; size = 4
_p1$ = -136						; size = 4
_S$GSCopy$ = -132					; size = 4
_coeff$ = -128						; size = 8
_Q$ = -128						; size = 8
tv2033 = -120						; size = 4
tv896 = -116						; size = 4
_tail$ = -112						; size = 4
_head$ = -108						; size = 4
_j$ = -104						; size = 4
_rhs$GSCopy$ = -100					; size = 4
_coord$ = -96						; size = 4
_hess$ = -92						; size = 4
_SAS$ = -88						; size = 4
_v_id$90497 = -84					; size = 4
_A$ = -80						; size = 4
_k$ = -76						; size = 4
_side$ = -72						; size = 4
tv2099 = -68						; size = 4
tv1193 = -68						; size = 4
tv1142 = -68						; size = 4
_AS$ = -64						; size = 4
tv1907 = -60						; size = 4
tv1763 = -60						; size = 4
_i$ = -56						; size = 4
_g$90540 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_rhs$ = 12						; size = 4
_simplex_facet_hessian PROC				; COMDAT

; 1440 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1539 :   if ( side ) free_matrix(side);

	mov	eax, DWORD PTR _S$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	push	1455					; 000005afH
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	5
	push	0
	push	5
	push	0
	mov	DWORD PTR _S$GSCopy$[ebp], eax
	mov	DWORD PTR _rhs$GSCopy$[ebp], ecx
	call	_kb_dmatrix
	push	1456					; 000005b0H
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	5
	push	0
	push	5
	push	0
	mov	DWORD PTR _p1$[ebp], eax
	call	_kb_dmatrix
	push	1457					; 000005b1H
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	5
	push	0
	push	5
	push	0
	mov	DWORD PTR _p2$[ebp], eax
	call	_kb_dmatrix
	add	esp, 72					; 00000048H
	push	1458					; 000005b2H
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	6
	push	0
	push	6
	push	0
	mov	DWORD PTR _hess$[ebp], eax
	call	_kb_dmatrix
	push	1459					; 000005b3H
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	5
	push	0
	push	5
	push	0
	mov	DWORD PTR _A$[ebp], eax
	call	_kb_dmatrix
	push	1460					; 000005b4H
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	5
	push	0
	push	5
	push	0
	mov	DWORD PTR _AS$[ebp], eax
	call	_kb_dmatrix
	add	esp, 72					; 00000048H
	push	1461					; 000005b5H
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	6
	push	0
	push	6
	push	0
	mov	DWORD PTR _SAS$[ebp], eax
	call	_kb_dmatrix
	push	1462					; 000005b6H
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	6
	push	0
	push	6
	push	0
	mov	DWORD PTR _coord$[ebp], eax
	call	_kb_dmatrix
	mov	ecx, DWORD PTR _web+272
	add	esp, 48					; 00000030H
	mov	DWORD PTR _side$[ebp], eax
	test	ecx, 268435456				; 10000000H
	je	$LN67@simplex_fa
	push	ebx
	push	esi
	push	edi
	npad	10
$LL69@simplex_fa:

; 1441 :   int i,j,k;
; 1442 :   int m;
; 1443 :   facet_id f_id;
; 1444 :   REAL **hess,**p1,**p2;
; 1445 :   REAL **A;  /* dots of sides matrix, and later inverse */        
; 1446 :   REAL **AS; /* sides x A inverse */
; 1447 :   REAL **SAS; /* sides x A inverse x sides */
; 1448 :   REAL **coord; /* vertex cooordinates */
; 1449 :   REAL Q;  /* determinant of A*/
; 1450 :   REAL coeff;  /* common factor */
; 1451 :   REAL **side;    /* sides of facet cone, from origin of homogenous */
; 1452 :   int head,tail;
; 1453 : 
; 1454 :   /* fill in sparse matrix rows and volume constraint rows */
; 1455 :   p1 = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);
; 1456 :   p2 = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);
; 1457 :   hess = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);
; 1458 :   A = dmatrix(0,MAXCOORD,0,MAXCOORD);
; 1459 :   AS = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);
; 1460 :   SAS = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);
; 1461 :   coord = dmatrix(0,MAXCOORD,0,MAXCOORD);
; 1462 :   side = dmatrix(0,MAXCOORD,0,MAXCOORD);
; 1463 : 
; 1464 :   FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR tv676[ebp], eax
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN68@simplex_fa

; 1465 :      {
; 1466 :         struct hess_verlist *v[MAXCOORD+1];
; 1467 :         vertex_id *v_id = get_facet_vertices(f_id);

	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+328
	mov	eax, DWORD PTR [eax+esi+304]

; 1468 : 
; 1469 :         get_facet_verts(f_id,coord,NULL);

	mov	esi, DWORD PTR _coord$[ebp]
	push	0
	add	eax, edx
	push	esi
	push	ecx
	mov	DWORD PTR _v_id$90497[ebp], eax
	call	_get_facet_verts

; 1470 :         for ( i = 0 ; i < web.dimension ; i++ )

	mov	edx, DWORD PTR _web+620
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _i$[ebp], 0
	test	edx, edx
	jle	SHORT $LN116@simplex_fa
	mov	eax, DWORD PTR _side$[ebp]
	sub	esi, eax
	mov	ebx, eax
	mov	DWORD PTR tv1142[ebp], esi
	npad	5
$LL64@simplex_fa:

; 1471 :           for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN63@simplex_fa
	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR [esi+ebx]
	mov	edi, DWORD PTR _coord$[ebp]
	sub	esi, eax
$LL115@simplex_fa:

; 1472 :              side[i][j] = coord[i][j] - coord[web.dimension][j];

	fld	QWORD PTR [esi+eax]
	mov	edx, DWORD PTR [edi+edx*4]
	fsub	QWORD PTR [edx+ecx*8]
	inc	ecx
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+620
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL115@simplex_fa

; 1471 :           for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR tv1142[ebp]
$LN63@simplex_fa:

; 1470 :         for ( i = 0 ; i < web.dimension ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	ebx, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, edx
	jl	SHORT $LL64@simplex_fa
$LN116@simplex_fa:

; 1473 : 
; 1474 :         /* matrix of inner products */
; 1475 :         for ( i = 0 ; i < web.dimension ; i++ )

	xor	esi, esi
	mov	DWORD PTR _i$[ebp], esi
	test	edx, edx
	jle	SHORT $LN56@simplex_fa
	mov	ebx, DWORD PTR _A$[ebp]
	mov	eax, DWORD PTR _side$[ebp]
	sub	eax, ebx
	mov	DWORD PTR tv1193[ebp], eax
	jmp	SHORT $LN58@simplex_fa
	npad	7
$LL124@simplex_fa:
	mov	esi, DWORD PTR _i$[ebp]
$LN58@simplex_fa:

; 1476 :           for ( j = i ; j < web.dimension ; j++ )

	cmp	esi, edx
	jge	SHORT $LN57@simplex_fa
	mov	edi, ebx
	npad	7
$LL117@simplex_fa:

; 1477 :              A[i][j] = A[j][i] = SDIM_dot(side[i],side[j]);

	mov	eax, DWORD PTR _web+616
	push	eax
	mov	eax, DWORD PTR tv1193[ebp]
	mov	ecx, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [ebx+eax]
	push	ecx
	push	edx
	call	_dot
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [ebx]
	fst	QWORD PTR [eax+ecx*8]
	fstp	QWORD PTR [edx+esi*8]
	mov	edx, DWORD PTR _web+620
	inc	esi
	add	esp, 12					; 0000000cH
	add	edi, 4
	cmp	esi, edx
	jl	SHORT $LL117@simplex_fa
$LN57@simplex_fa:

; 1473 : 
; 1474 :         /* matrix of inner products */
; 1475 :         for ( i = 0 ; i < web.dimension ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	ebx, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, edx
	jl	SHORT $LL124@simplex_fa
$LN56@simplex_fa:

; 1478 :         Q = det_adjoint(A,web.dimension);

	mov	esi, DWORD PTR _A$[ebp]
	push	edx
	push	esi
	call	_det_adjoint
	fst	QWORD PTR _Q$[ebp]

; 1479 :         if ( Q == 0.0 ) continue;

	fld	ST(0)
	add	esp, 8
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	$LN133@simplex_fa

; 1480 :         for ( i = 0 ; i < web.dimension ; i++ )

	mov	ecx, DWORD PTR _web+620
	xor	ebx, ebx
	test	ecx, ecx
	jle	SHORT $LN141@simplex_fa
$LN51@simplex_fa:

; 1481 :           for ( j = i ; j < web.dimension ; j++ )

	mov	eax, ebx
	cmp	ebx, ecx
	jge	SHORT $LN50@simplex_fa

; 1480 :         for ( i = 0 ; i < web.dimension ; i++ )

	mov	edx, DWORD PTR [esi+ebx*4]
	lea	edi, DWORD PTR [ebx*8]
	add	edx, edi
$LN48@simplex_fa:
	mov	ecx, DWORD PTR [esi+eax*4]

; 1482 :              A[i][j] = A[j][i] /= Q;  /* make adjoint into inverse */

	fld	QWORD PTR [ecx+edi]
	inc	eax
	fdiv	ST(0), ST(2)
	add	edx, 8
	fst	QWORD PTR [ecx+edi]
	fstp	QWORD PTR [edx-8]
	mov	ecx, DWORD PTR _web+620
	cmp	eax, ecx
	jl	SHORT $LN48@simplex_fa
$LN50@simplex_fa:

; 1480 :         for ( i = 0 ; i < web.dimension ; i++ )

	inc	ebx
	cmp	ebx, ecx
	jl	SHORT $LN51@simplex_fa
$LN141@simplex_fa:

; 1483 :         /* now make rows and columns of expanded A add to 0 for last vertex */
; 1484 :         A[web.dimension][web.dimension] = 0.0;

	mov	edx, DWORD PTR [esi+ecx*4]
	fstp	ST(1)
	fst	QWORD PTR [edx+ecx*8]

; 1485 :         for ( i = 0 ; i < web.dimension ; i++ )

	mov	edx, DWORD PTR _web+620
	xor	edi, edi
	test	edx, edx
	jle	SHORT $LN152@simplex_fa
$LN45@simplex_fa:

; 1486 :           { REAL sum;
; 1487 :              for ( j = 0, sum = 0.; j < web.dimension ; j++ )

	xor	ebx, ebx
	fld	ST(0)
	cmp	edx, 4
	jl	SHORT $LC113@simplex_fa
	mov	eax, DWORD PTR [esi+edi*4]
	lea	ecx, DWORD PTR [edx-4]
	shr	ecx, 2
	add	eax, 16					; 00000010H
	inc	ecx
	lea	ebx, DWORD PTR [ecx*4]
$LN114@simplex_fa:

; 1488 :                 sum += A[i][j]; 

	fadd	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	ecx
	fadd	QWORD PTR [eax-40]
	fadd	QWORD PTR [eax-32]
	fadd	QWORD PTR [eax-24]
	jne	SHORT $LN114@simplex_fa
$LC113@simplex_fa:

; 1486 :           { REAL sum;
; 1487 :              for ( j = 0, sum = 0.; j < web.dimension ; j++ )

	cmp	ebx, edx
	jge	SHORT $LN125@simplex_fa
	mov	eax, DWORD PTR [esi+edi*4]
	lea	ecx, DWORD PTR [eax+ebx*8]
	mov	eax, edx
	sub	eax, ebx
$LC42@simplex_fa:

; 1488 :                 sum += A[i][j]; 

	fadd	QWORD PTR [ecx]
	add	ecx, 8
	dec	eax
	jne	SHORT $LC42@simplex_fa
$LN125@simplex_fa:

; 1489 :              A[i][web.dimension] = A[web.dimension][i] = -sum;

	mov	ecx, DWORD PTR [esi+edx*4]
	fld	ST(0)
	mov	edx, DWORD PTR [esi+edi*4]
	fchs
	fst	QWORD PTR [ecx+edi*8]
	mov	eax, DWORD PTR _web+620
	fstp	QWORD PTR [edx+eax*8]

; 1490 :              A[web.dimension][web.dimension] += sum;

	mov	eax, DWORD PTR _web+620
	mov	ecx, DWORD PTR [esi+eax*4]
	fadd	QWORD PTR [ecx+eax*8]
	lea	eax, DWORD PTR [ecx+eax*8]
	inc	edi
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _web+620
	cmp	edi, edx
	jl	SHORT $LN45@simplex_fa
$LN152@simplex_fa:

; 1491 :           }
; 1492 :         mat_mult(A,side,AS,web.dimension+1,web.dimension,SDIM);

	mov	eax, DWORD PTR _web+616
	fstp	ST(0)
	mov	ecx, DWORD PTR _AS$[ebp]
	mov	ebx, DWORD PTR _side$[ebp]
	push	eax
	push	edx
	inc	edx
	push	edx
	push	ecx
	push	ebx
	push	esi
	call	_mat_mult

; 1493 :         tr_mat_mul(side,AS,SAS,web.dimension,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR _web+620
	mov	ecx, DWORD PTR _AS$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR _SAS$[ebp]
	push	edx
	push	eax
	push	ecx
	push	ebx
	call	_tr_mat_mul

; 1494 :         coeff = get_facet_density(v_id[i])*sqrt(Q)/web.simplex_factorial;

	fld	QWORD PTR _Q$[ebp]
	add	esp, 48					; 00000030H
	call	__CIsqrt
	mov	edx, DWORD PTR _v_id$90497[ebp]
	mov	eax, DWORD PTR [edx+edi*4]
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fmul	QWORD PTR [edx+32]

; 1495 : 
; 1496 :         for ( i = 0 ; i <= web.dimension ; i++ )

	mov	ecx, DWORD PTR _web+620
	xor	eax, eax
	fdiv	QWORD PTR _web+792
	fst	QWORD PTR _coeff$[ebp]
	test	ecx, ecx
	js	SHORT $LN126@simplex_fa
	mov	edx, DWORD PTR _vhead_attr
	mov	esi, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	edi, DWORD PTR [edx+esi+64]
	mov	edx, DWORD PTR _v_id$90497[ebp]
	lea	esi, DWORD PTR _v$90496[ebp]
	sub	edx, esi
$LN127@simplex_fa:

; 1497 :           v[i] = get_vertex_vhead(v_id[i]);

	mov	ebx, DWORD PTR _web+12
	lea	esi, DWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR _v$90496[ebp+esi]
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	esi, DWORD PTR [edi+esi]
	shl	esi, 5
	add	esi, DWORD PTR _vhead
	inc	eax
	mov	DWORD PTR _v$90496[ebp+eax*4-4], esi
	cmp	eax, ecx
	jle	SHORT $LN127@simplex_fa
$LN126@simplex_fa:

; 1498 : 
; 1499 :         /* first derivatives of area */
; 1500 :         for ( i = 0 ; i <= web.dimension ; i++ )

	xor	ebx, ebx
	mov	DWORD PTR _i$[ebp], ebx
	test	ecx, ecx
	js	$LN34@simplex_fa
	mov	eax, DWORD PTR _AS$[ebp]
	mov	edi, DWORD PTR _rhs$GSCopy$[ebp]
	lea	edx, DWORD PTR _v$90496[ebp]
	sub	eax, edx
	mov	DWORD PTR tv1763[ebp], eax
$LN36@simplex_fa:

; 1501 :           {
; 1502 :              REAL g[MAXCOORD]; /* projected to constraint */
; 1503 : 
; 1504 :              if ( v[i]->freedom == 0 ) continue;

	mov	esi, DWORD PTR _v$90496[ebp+ebx*4]
	mov	edx, DWORD PTR [esi+8]
	test	edx, edx
	je	$LN35@simplex_fa

; 1505 :              if ( v[i]->proj )

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN32@simplex_fa

; 1506 :                 { vec_mat_mul(AS[i],v[i]->proj,g,SDIM,v[i]->freedom);

	mov	ecx, DWORD PTR _web+616
	fstp	ST(0)
	push	edx
	push	ecx
	lea	edx, DWORD PTR _g$90540[ebp]
	push	edx
	push	eax
	mov	eax, DWORD PTR tv1763[ebp]
	lea	ecx, DWORD PTR [eax+ebx*4]
	mov	edx, DWORD PTR _v$90496[ebp+ecx]
	push	edx
	call	_vec_mat_mul

; 1507 :                   for ( k = 0 ; k < v[i]->freedom ; k++ )
; 1508 :                      rhs[v[i]->rownum+k] -= coeff*g[k];

	fld	QWORD PTR _coeff$[ebp]
	xor	eax, eax
	add	esp, 20					; 00000014H
	cmp	DWORD PTR [esi+8], eax
	jle	SHORT $LN118@simplex_fa
	mov	edx, esi
$LN31@simplex_fa:
	fld	QWORD PTR _g$90540[ebp+eax*8]
	mov	ecx, DWORD PTR [esi+12]
	add	ecx, eax
	fmul	ST(0), ST(1)
	lea	ecx, DWORD PTR [edi+ecx*8]
	inc	eax
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+8]
	jl	SHORT $LN31@simplex_fa

; 1509 :                 }
; 1510 :              else

	jmp	SHORT $LN118@simplex_fa
$LN32@simplex_fa:

; 1511 :                 for ( k = 0 ; k < v[i]->freedom ; k++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN35@simplex_fa

; 1498 : 
; 1499 :         /* first derivatives of area */
; 1500 :         for ( i = 0 ; i <= web.dimension ; i++ )

	mov	edx, DWORD PTR tv1763[ebp]
	lea	ecx, DWORD PTR [edx+ebx*4]

; 1511 :                 for ( k = 0 ; k < v[i]->freedom ; k++ )

	mov	edx, DWORD PTR _v$90496[ebp+ecx]
	mov	ebx, DWORD PTR _rhs$GSCopy$[ebp]
	mov	edi, esi
$LN27@simplex_fa:

; 1512 :                      rhs[v[i]->rownum+k] -= coeff*AS[i][k];

	fld	QWORD PTR [edx]
	mov	ecx, DWORD PTR [esi+12]
	add	ecx, eax
	fmul	ST(0), ST(1)
	lea	ecx, DWORD PTR [ebx+ecx*8]
	inc	eax
	fsubr	QWORD PTR [ecx]
	add	edx, 8
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR [edi+8]
	jl	SHORT $LN27@simplex_fa

; 1511 :                 for ( k = 0 ; k < v[i]->freedom ; k++ )

	mov	ebx, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR _rhs$GSCopy$[ebp]
$LN118@simplex_fa:

; 1509 :                 }
; 1510 :              else

	mov	ecx, DWORD PTR _web+620
$LN35@simplex_fa:

; 1498 : 
; 1499 :         /* first derivatives of area */
; 1500 :         for ( i = 0 ; i <= web.dimension ; i++ )

	inc	ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, ecx
	jle	$LN36@simplex_fa
$LN34@simplex_fa:

; 1513 :           }
; 1514 : 
; 1515 :         /* second derivatives */
; 1516 :         for ( i = 0 ; i <= web.dimension ; i++ )

	xor	edi, edi
	mov	DWORD PTR _i$[ebp], edi
	test	ecx, ecx
	js	$LN214@simplex_fa
	mov	eax, DWORD PTR _v_id$90497[ebp]
	lea	esi, DWORD PTR _v$90496[ebp]
	sub	esi, eax
	mov	DWORD PTR tv2099[ebp], eax
	mov	DWORD PTR tv2191[ebp], esi
$LN24@simplex_fa:

; 1517 :          for ( j = i ; j <= web.dimension ; j++ )

	mov	DWORD PTR _j$[ebp], edi
	cmp	edi, ecx
	jg	$LN23@simplex_fa
	mov	edx, DWORD PTR [esi+eax]
	mov	DWORD PTR tv2156[ebp], edx
	mov	edx, eax
	mov	DWORD PTR tv2033[ebp], eax
$LN131@simplex_fa:

; 1518 :           {
; 1519 :              if ( (v[i]->freedom==0) || (v[j]->freedom==0) ) continue;

	mov	ebx, DWORD PTR tv2156[ebp]
	cmp	DWORD PTR [ebx+8], 0
	je	$LN20@simplex_fa
	mov	ebx, DWORD PTR [edx+esi]
	cmp	DWORD PTR [ebx+8], 0
	je	$LN20@simplex_fa

; 1520 :              if ( loc_ordinal(v_id[i]) > loc_ordinal(v_id[j]) )

	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN72@simplex_fa
	and	eax, 134217727				; 07ffffffH
	mov	ecx, eax
	jmp	SHORT $LN73@simplex_fa
$LN72@simplex_fa:
	or	ecx, -1
$LN73@simplex_fa:
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN74@simplex_fa
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN75@simplex_fa
$LN74@simplex_fa:
	or	eax, -1
$LN75@simplex_fa:
	cmp	ecx, eax
	jle	SHORT $LN16@simplex_fa

; 1521 :                  { tail = i; head = j; }

	mov	esi, DWORD PTR _i$[ebp]
	mov	DWORD PTR _tail$[ebp], esi
	jmp	SHORT $LN218@simplex_fa
$LN16@simplex_fa:

; 1522 :              else { tail = j; head = i; }

	mov	esi, edi
	mov	DWORD PTR _tail$[ebp], edi
	mov	edi, DWORD PTR _i$[ebp]
$LN218@simplex_fa:

; 1523 : 
; 1524 :              for ( m = 0 ; m < SDIM ; m++ )

	mov	ebx, DWORD PTR _web+616
	xor	ecx, ecx
	mov	DWORD PTR _head$[ebp], edi
	test	ebx, ebx
	jle	$LN198@simplex_fa
	mov	edx, DWORD PTR _hess$[ebp]
	fldz
	mov	eax, DWORD PTR _SAS$[ebp]
	sub	eax, edx
	mov	DWORD PTR tv1907[ebp], edx
	mov	DWORD PTR tv1951[ebp], eax
$LN14@simplex_fa:

; 1525 :                 for ( k = 0 ; k < SDIM ; k++ )

	mov	DWORD PTR _k$[ebp], 0
	test	ebx, ebx
	jle	$LN13@simplex_fa
	mov	ebx, DWORD PTR tv1907[ebp]
	mov	eax, DWORD PTR [eax+ebx]
	mov	ebx, DWORD PTR _A$[ebp]
	mov	ebx, DWORD PTR [ebx+esi*4]
	mov	edx, DWORD PTR _AS$[ebp]
	mov	edx, DWORD PTR [edx+edi*4]
	lea	edi, DWORD PTR [ebx+edi*8]
	mov	DWORD PTR tv896[ebp], edi
	mov	edi, DWORD PTR _AS$[ebp]
	mov	esi, DWORD PTR [edi+esi*4]
	mov	ebx, edx
	sub	ebx, eax
	mov	DWORD PTR tv1961[ebp], ebx
	mov	ebx, DWORD PTR tv1907[ebp]
	mov	ebx, DWORD PTR [ebx]
	mov	edi, esi
	sub	edi, eax
	sub	ebx, eax
	mov	DWORD PTR tv1965[ebp], ebx
$LN120@simplex_fa:

; 1526 :                   hess[m][k] = coeff*((m==k?A[tail][head]:0.0) - AS[tail][k]*
; 1527 :                       AS[head][m] - SAS[m][k]*A[tail][head]
; 1528 :                       + AS[tail][m]*AS[head][k]);

	cmp	ecx, DWORD PTR _k$[ebp]
	jne	SHORT $LN76@simplex_fa
	mov	ebx, DWORD PTR tv896[ebp]
	fld	QWORD PTR [ebx]
	jmp	SHORT $LN77@simplex_fa
$LN76@simplex_fa:
	fld	ST(0)
$LN77@simplex_fa:
	fld	QWORD PTR [edi+eax]
	mov	ebx, DWORD PTR tv896[ebp]
	fmul	QWORD PTR [edx+ecx*8]
	inc	DWORD PTR _k$[ebp]
	add	eax, 8
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [eax-8]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv1961[ebp]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ebx+eax-8]
	mov	ebx, DWORD PTR tv1965[ebp]
	fmul	QWORD PTR [esi+ecx*8]
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [ebx+eax-8]
	mov	ebx, DWORD PTR _web+616
	cmp	DWORD PTR _k$[ebp], ebx
	jl	SHORT $LN120@simplex_fa

; 1525 :                 for ( k = 0 ; k < SDIM ; k++ )

	mov	edi, DWORD PTR _head$[ebp]
	mov	esi, DWORD PTR _tail$[ebp]
	mov	eax, DWORD PTR tv1951[ebp]
$LN13@simplex_fa:

; 1523 : 
; 1524 :              for ( m = 0 ; m < SDIM ; m++ )

	add	DWORD PTR tv1907[ebp], 4
	inc	ecx
	cmp	ecx, ebx
	jl	$LN14@simplex_fa

; 1526 :                   hess[m][k] = coeff*((m==k?A[tail][head]:0.0) - AS[tail][k]*
; 1527 :                       AS[head][m] - SAS[m][k]*A[tail][head]
; 1528 :                       + AS[tail][m]*AS[head][k]);

	fstp	ST(1)
$LN198@simplex_fa:

; 1529 :              fill_mixed_entry(S,v_id[tail],v_id[head],hess);

	mov	eax, DWORD PTR _hess$[ebp]
	fstp	ST(0)
	push	eax
	mov	eax, DWORD PTR _v_id$90497[ebp]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	edx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	push	ecx
	push	edx
	push	eax
	call	_fill_mixed_entry
	fld	QWORD PTR _coeff$[ebp]
	mov	ecx, DWORD PTR _web+620
	mov	edi, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR tv2033[ebp]
	mov	eax, DWORD PTR tv2099[ebp]
	mov	esi, DWORD PTR tv2191[ebp]
	add	esp, 16					; 00000010H
$LN20@simplex_fa:

; 1517 :          for ( j = i ; j <= web.dimension ; j++ )

	inc	edi
	add	edx, 4
	mov	DWORD PTR _j$[ebp], edi
	mov	DWORD PTR tv2033[ebp], edx
	cmp	edi, ecx
	jle	$LN131@simplex_fa
	mov	edi, DWORD PTR _i$[ebp]
$LN23@simplex_fa:

; 1513 :           }
; 1514 : 
; 1515 :         /* second derivatives */
; 1516 :         for ( i = 0 ; i <= web.dimension ; i++ )

	inc	edi
	add	eax, 4
	mov	DWORD PTR _i$[ebp], edi
	mov	DWORD PTR tv2099[ebp], eax
	cmp	edi, ecx
	jle	$LN24@simplex_fa
	jmp	SHORT $LN214@simplex_fa
$LN133@simplex_fa:
	fstp	ST(1)
$LN214@simplex_fa:

; 1517 :          for ( j = i ; j <= web.dimension ; j++ )

	fstp	ST(0)
$LN68@simplex_fa:

; 1441 :   int i,j,k;
; 1442 :   int m;
; 1443 :   facet_id f_id;
; 1444 :   REAL **hess,**p1,**p2;
; 1445 :   REAL **A;  /* dots of sides matrix, and later inverse */        
; 1446 :   REAL **AS; /* sides x A inverse */
; 1447 :   REAL **SAS; /* sides x A inverse x sides */
; 1448 :   REAL **coord; /* vertex cooordinates */
; 1449 :   REAL Q;  /* determinant of A*/
; 1450 :   REAL coeff;  /* common factor */
; 1451 :   REAL **side;    /* sides of facet cone, from origin of homogenous */
; 1452 :   int head,tail;
; 1453 : 
; 1454 :   /* fill in sparse matrix rows and volume constraint rows */
; 1455 :   p1 = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);
; 1456 :   p2 = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);
; 1457 :   hess = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);
; 1458 :   A = dmatrix(0,MAXCOORD,0,MAXCOORD);
; 1459 :   AS = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);
; 1460 :   SAS = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);
; 1461 :   coord = dmatrix(0,MAXCOORD,0,MAXCOORD);
; 1462 :   side = dmatrix(0,MAXCOORD,0,MAXCOORD);
; 1463 : 
; 1464 :   FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR tv676[ebp]
	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR [eax]
	test	ecx, 268435456				; 10000000H
	jne	$LL69@simplex_fa
	pop	edi
	pop	esi
	pop	ebx
$LN67@simplex_fa:

; 1530 :             }
; 1531 :      }
; 1532 :   if ( hess ) free_matrix(hess);

	mov	eax, DWORD PTR _hess$[ebp]
	test	eax, eax
	je	SHORT $LN8@simplex_fa
	push	eax
	call	_free_matrix
	add	esp, 4
$LN8@simplex_fa:

; 1533 :   if ( p1 ) free_matrix(p1);

	mov	eax, DWORD PTR _p1$[ebp]
	test	eax, eax
	je	SHORT $LN7@simplex_fa
	push	eax
	call	_free_matrix
	add	esp, 4
$LN7@simplex_fa:

; 1534 :   if ( p2 ) free_matrix(p2);

	mov	eax, DWORD PTR _p2$[ebp]
	test	eax, eax
	je	SHORT $LN6@simplex_fa
	push	eax
	call	_free_matrix
	add	esp, 4
$LN6@simplex_fa:

; 1535 :   if ( A ) free_matrix(A);

	mov	eax, DWORD PTR _A$[ebp]
	test	eax, eax
	je	SHORT $LN5@simplex_fa
	push	eax
	call	_free_matrix
	add	esp, 4
$LN5@simplex_fa:

; 1536 :   if ( AS ) free_matrix(AS);

	mov	eax, DWORD PTR _AS$[ebp]
	test	eax, eax
	je	SHORT $LN4@simplex_fa
	push	eax
	call	_free_matrix
	add	esp, 4
$LN4@simplex_fa:

; 1537 :   if ( SAS ) free_matrix(SAS);

	mov	eax, DWORD PTR _SAS$[ebp]
	test	eax, eax
	je	SHORT $LN3@simplex_fa
	push	eax
	call	_free_matrix
	add	esp, 4
$LN3@simplex_fa:

; 1538 :   if ( coord ) free_matrix(coord);

	mov	eax, DWORD PTR _coord$[ebp]
	test	eax, eax
	je	SHORT $LN2@simplex_fa
	push	eax
	call	_free_matrix
	add	esp, 4
$LN2@simplex_fa:

; 1539 :   if ( side ) free_matrix(side);

	mov	eax, DWORD PTR _side$[ebp]
	test	eax, eax
	je	SHORT $LN1@simplex_fa
	push	eax
	call	_free_matrix
	add	esp, 4
$LN1@simplex_fa:

; 1540 : }  /* end simplex_hessian() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_facet_hessian ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@BFCDBBCC@simplex_vector_integral?5method?5o@ ; `string'
PUBLIC	??_C@_0DO@KAEPEMDF@simplex_vector_integral?5method?5o@ ; `string'
PUBLIC	_simplex_vector_integral_init
;	COMDAT ??_C@_0DH@BFCDBBCC@simplex_vector_integral?5method?5o@
CONST	SEGMENT
??_C@_0DH@BFCDBBCC@simplex_vector_integral?5method?5o@ DB 'simplex_vector'
	DB	'_integral method only for LINEAR model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@KAEPEMDF@simplex_vector_integral?5method?5o@
CONST	SEGMENT
??_C@_0DO@KAEPEMDF@simplex_vector_integral?5method?5o@ DB 'simplex_vector'
	DB	'_integral method only for N-1 D facets in N D.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _simplex_vector_integral_init
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_simplex_vector_integral_init PROC			; COMDAT

; 1565 :   if ( web.dimension != SDIM-1 )

	mov	eax, DWORD PTR _web+616
	dec	eax
	cmp	DWORD PTR _web+620, eax
	je	SHORT $LN2@simplex_ve

; 1566 :      kb_error(1551,"simplex_vector_integral method only for N-1 D facets in N D.\n",
; 1567 : 
; 1568 :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DO@KAEPEMDF@simplex_vector_integral?5method?5o@
	push	1551					; 0000060fH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN2@simplex_ve:

; 1569 :   if ( web.modeltype != LINEAR ) 

	cmp	DWORD PTR _web+628, 1
	je	SHORT $LN1@simplex_ve

; 1570 :      kb_error(1552,"simplex_vector_integral method only for LINEAR model.\n",
; 1571 : 
; 1572 :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DH@BFCDBBCC@simplex_vector_integral?5method?5o@
	push	1552					; 00000610H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@simplex_ve:

; 1573 : } // end simplex_vector_integral_init()

	ret	0
_simplex_vector_integral_init ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_vector_integral
EXTRN	_gauss2Dwt:DWORD
EXTRN	_meth_inst_list:DWORD
EXTRN	_gauss2D_num:DWORD
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _simplex_vector_integral
_TEXT	SEGMENT
_matqXvS$ = -336					; size = 24
_sign$ = -312						; size = 8
_value$ = -304						; size = 8
_m$ = -296						; size = 4
_matxJ$ = -292						; size = 288
__$ArrayPad$ = -4					; size = 4
_f_info$ = 8						; size = 4
_simplex_vector_integral PROC				; COMDAT

; 1584 : { int i,m,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1585 :   REAL value=0.0;

	fldz
	push	ebx
	push	edi
	fstp	QWORD PTR _value$[ebp]
	mov	edi, DWORD PTR _f_info$[ebp]

; 1586 :   MAT2D(mat,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _matxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matqXvS$[ebp]
	push	ecx
	call	_mat2d_setup

; 1587 :   REAL sign = (get_fattr(f_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	edx, DWORD PTR [edi]
	mov	ebx, eax
	mov	eax, DWORD PTR _web+236
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	add	esp, 16					; 00000010H
	or	eax, ecx
	je	SHORT $LN15@simplex_ve@2
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN30@simplex_ve@2
$LN15@simplex_ve@2:
	fld1
$LN30@simplex_ve@2:
	fstp	QWORD PTR _sign$[ebp]

; 1588 : 
; 1589 :   for ( m = 0 ; m < gauss2D_num ; m++ )

	mov	DWORD PTR _m$[ebp], ecx
	cmp	DWORD PTR _gauss2D_num, ecx
	jle	$LN26@simplex_ve@2
	push	esi
	npad	3
$LL27@simplex_ve@2:

; 1590 :   { for ( i = 0 ; i < web.dimension ; i++ )

	mov	ecx, DWORD PTR _web+616
	xor	edx, edx
	cmp	DWORD PTR _web+620, edx
	jle	SHORT $LN7@simplex_ve@2
$LL29@simplex_ve@2:

; 1591 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN8@simplex_ve@2
	mov	esi, DWORD PTR [ebx+edx*4]
	npad	7
$LL6@simplex_ve@2:

; 1592 :           mat[i][j] = f_info->sides[0][i][j];

	mov	ecx, DWORD PTR [edi+1276]
	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+edx*4]
	fld	QWORD PTR [ecx+eax*8]
	inc	eax
	fstp	QWORD PTR [esi+eax*8-8]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LL6@simplex_ve@2
$LN8@simplex_ve@2:

; 1590 :   { for ( i = 0 ; i < web.dimension ; i++ )

	inc	edx
	cmp	edx, DWORD PTR _web+620
	jl	SHORT $LL29@simplex_ve@2
$LN7@simplex_ve@2:

; 1593 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN1@simplex_ve@2
	npad	4
$LL28@simplex_ve@2:

; 1594 :       mat[web.dimension][j] = 
; 1595 :         eval(METH_INSTANCE(f_info->method)->expr[j],f_info->gauss_pt[m],NULLID,NULL);

	mov	edx, DWORD PTR [edi+1268]
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edi+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 732				; 000002dcH
	push	0
	push	0
	add	eax, esi
	mov	eax, DWORD PTR [edx+eax*4+232]
	push	ecx
	push	eax
	call	_eval
	mov	ecx, DWORD PTR _web+620
	mov	edx, DWORD PTR [ebx+ecx*4]
	inc	esi
	fstp	QWORD PTR [edx+esi*8-8]
	mov	ecx, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	cmp	esi, ecx
	jl	SHORT $LL28@simplex_ve@2
$LN1@simplex_ve@2:

; 1596 :      value += gauss2Dwt[m]*det_adjoint(mat,SDIM);

	push	ecx
	push	ebx
	call	_det_adjoint
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _gauss2Dwt
	fmul	QWORD PTR [ecx+eax*8]
	inc	eax
	add	esp, 8
	mov	DWORD PTR _m$[ebp], eax
	fadd	QWORD PTR _value$[ebp]
	fstp	QWORD PTR _value$[ebp]
	cmp	eax, DWORD PTR _gauss2D_num
	jl	$LL27@simplex_ve@2
	pop	esi
$LN26@simplex_ve@2:

; 1597 :   }
; 1598 :   return sign*value/web.simplex_factorial; 

	fld	QWORD PTR _sign$[ebp]

; 1599 : } // end simplex_vector_integral()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fmul	QWORD PTR _value$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	ebx
	fdiv	QWORD PTR _web+792
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_vector_integral ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_vector_integral_grad
EXTRN	_gpoly:DWORD
EXTRN	_ctrl_num:DWORD
; Function compile flags: /Ogtp
;	COMDAT _simplex_vector_integral_grad
_TEXT	SEGMENT
_matqXvS$ = -692					; size = 24
_sign$ = -668						; size = 8
_weight$90638 = -660					; size = 8
tv429 = -656						; size = 4
_value$ = -652						; size = 8
_k$ = -644						; size = 4
_mat$ = -640						; size = 4
_m$ = -636						; size = 4
tv590 = -632						; size = 4
_j$ = -632						; size = 4
_matxJ$ = -628						; size = 288
_derivs$ = -340						; size = 288
_val$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_f_info$ = 8						; size = 4
_simplex_vector_integral_grad PROC			; COMDAT

; 1610 : { int i,m,j,k,jj;

	push	ebp
	mov	ebp, esp
	sub	esp, 692				; 000002b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1611 :   REAL value = 0.0;

	fldz
	push	esi
	mov	esi, DWORD PTR _f_info$[ebp]
	fstp	QWORD PTR _value$[ebp]
	push	edi

; 1612 :   REAL val[MAXCOORD];
; 1613 :   REAL derivs[MAXCOORD][MAXCOORD];
; 1614 :   MAT2D(mat,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _matxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matqXvS$[ebp]
	push	ecx
	call	_mat2d_setup

; 1615 :   REAL sign = (get_fattr(f_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	edx, DWORD PTR [esi]
	mov	edi, eax
	mov	eax, DWORD PTR _web+236
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	add	esp, 16					; 00000010H
	or	eax, ecx
	mov	DWORD PTR _mat$[ebp], edi
	je	SHORT $LN36@simplex_ve@3
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN94@simplex_ve@3
$LN36@simplex_ve@3:
	fld1
$LN94@simplex_ve@3:

; 1616 : 
; 1617 :   for ( m = 0 ; m < gauss2D_num ; m++ )

	cmp	DWORD PTR _gauss2D_num, ecx
	fstp	QWORD PTR _sign$[ebp]
	mov	DWORD PTR _m$[ebp], ecx
	mov	ecx, DWORD PTR _web+616
	jle	$LN31@simplex_ve@3
	push	ebx
	npad	7
$LL62@simplex_ve@3:

; 1618 :   { REAL weight = sign*gauss2Dwt[m];

	mov	edx, DWORD PTR _gauss2Dwt
	mov	eax, DWORD PTR _m$[ebp]
	fld	QWORD PTR [edx+eax*8]

; 1619 :      for ( i = 0 ; i < web.dimension ; i++ )

	xor	edx, edx
	fmul	QWORD PTR _sign$[ebp]
	fstp	QWORD PTR _weight$90638[ebp]
	cmp	DWORD PTR _web+620, edx
	jle	SHORT $LN28@simplex_ve@3
$LL66@simplex_ve@3:

; 1620 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN29@simplex_ve@3
	mov	ebx, DWORD PTR [edi+edx*4]
	npad	2
$LL27@simplex_ve@3:

; 1621 :           mat[i][j] = f_info->sides[0][i][j];  /* mat destroyed by det */

	mov	ecx, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+edx*4]
	fld	QWORD PTR [ecx+eax*8]
	inc	eax
	fstp	QWORD PTR [ebx+eax*8-8]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LL27@simplex_ve@3
$LN29@simplex_ve@3:

; 1619 :      for ( i = 0 ; i < web.dimension ; i++ )

	inc	edx
	cmp	edx, DWORD PTR _web+620
	jl	SHORT $LL66@simplex_ve@3
$LN28@simplex_ve@3:

; 1622 :      for ( j = 0 ; j < SDIM ; j++ )

	xor	ebx, ebx
	test	ecx, ecx
	jle	$LN22@simplex_ve@3
	lea	edx, DWORD PTR _derivs$[ebp]
	mov	DWORD PTR tv590[ebp], edx
	npad	4
$LL65@simplex_ve@3:

; 1623 :      { eval_all(METH_INSTANCE(f_info->method)->expr[j],f_info->gauss_pt[m],SDIM,val+j,
; 1624 :                                                                          derivs[j],f_info->id);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR tv590[ebp]
	push	eax
	mov	eax, DWORD PTR [esi+1268]
	push	edx
	lea	edi, DWORD PTR _val$[ebp+ebx*8]
	push	edi
	push	ecx
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _meth_inst_list
	push	edx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 732				; 000002dcH
	add	eax, ebx
	mov	edx, DWORD PTR [ecx+eax*4+232]
	push	edx
	call	_eval_all

; 1625 :         mat[web.dimension][j] = val[j];

	mov	eax, DWORD PTR _web+620
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	QWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+eax*4]
	add	DWORD PTR tv590[ebp], 48		; 00000030H
	fstp	QWORD PTR [edx+ebx*8]
	mov	ecx, DWORD PTR _web+616
	inc	ebx
	add	esp, 24					; 00000018H
	cmp	ebx, ecx
	jl	SHORT $LL65@simplex_ve@3

; 1622 :      for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _mat$[ebp]
$LN22@simplex_ve@3:

; 1626 :      }
; 1627 :      value += weight*det_adjoint(mat,SDIM);

	push	ecx
	push	edi
	call	_det_adjoint
	fld	QWORD PTR _weight$90638[ebp]

; 1628 :      for ( k = 0 ; k < ctrl_num-1; k++ )

	mov	edx, DWORD PTR _ctrl_num
	fmul	ST(1), ST(0)
	mov	ecx, DWORD PTR _web+616
	fxch	ST(1)
	lea	eax, DWORD PTR [edx-1]
	fadd	QWORD PTR _value$[ebp]
	add	esp, 8
	xor	ebx, ebx
	fstp	QWORD PTR _value$[ebp]
	test	eax, eax
	jle	SHORT $LN19@simplex_ve@3
$LN21@simplex_ve@3:

; 1629 :       for ( j = 0 ; j < SDIM ; j++ ) 

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN20@simplex_ve@3
$LN18@simplex_ve@3:

; 1628 :      for ( k = 0 ; k < ctrl_num-1; k++ )

	mov	ecx, DWORD PTR [edi+eax*4]

; 1630 :         { f_info->grad[k+1][j] += weight*mat[j][k];

	fld	ST(0)
	fmul	QWORD PTR [ecx+ebx*8]
	mov	edx, DWORD PTR [esi+1336]
	mov	edx, DWORD PTR [edx+ebx*4+4]
	lea	ecx, DWORD PTR [ecx+ebx*8]
	fadd	QWORD PTR [edx+eax*8]
	lea	edx, DWORD PTR [edx+eax*8]
	fstp	QWORD PTR [edx]

; 1631 :           f_info->grad[0][j]    -= weight*mat[j][k];

	mov	edx, DWORD PTR [esi+1336]
	mov	edx, DWORD PTR [edx]
	fld	ST(0)
	lea	edx, DWORD PTR [edx+eax*8]
	fmul	QWORD PTR [ecx]
	inc	eax
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN18@simplex_ve@3

; 1629 :       for ( j = 0 ; j < SDIM ; j++ ) 

	mov	edx, DWORD PTR _ctrl_num
$LN20@simplex_ve@3:

; 1628 :      for ( k = 0 ; k < ctrl_num-1; k++ )

	inc	ebx
	lea	eax, DWORD PTR [edx-1]
	cmp	ebx, eax
	jl	SHORT $LN21@simplex_ve@3
$LN19@simplex_ve@3:

; 1632 :         }
; 1633 :      for ( k = 0 ; k < ctrl_num ; k++ )

	xor	ebx, ebx
	mov	DWORD PTR _k$[ebp], ebx
	test	edx, edx
	jle	$LN79@simplex_ve@3
$LN64@simplex_ve@3:

; 1634 :       for ( j = 0 ; j < SDIM ; j++ ) 

	xor	edi, edi
	mov	DWORD PTR _j$[ebp], edi
	test	ecx, ecx
	jle	$LN14@simplex_ve@3
$LN67@simplex_ve@3:

; 1635 :         for ( jj = 0 ; jj < SDIM ; jj++ ) 

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN11@simplex_ve@3

; 1632 :         }
; 1633 :      for ( k = 0 ; k < ctrl_num ; k++ )

	mov	edx, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _gpoly
	mov	ecx, DWORD PTR [ecx+edx*4]
	lea	edx, DWORD PTR [ecx+ebx*8]
	mov	DWORD PTR tv429[ebp], edx

; 1634 :       for ( j = 0 ; j < SDIM ; j++ ) 

	lea	edx, DWORD PTR _derivs$[ebp+edi*8]
$LN63@simplex_ve@3:
	mov	ecx, DWORD PTR [esi+1336]
	mov	ecx, DWORD PTR [ecx+ebx*4]

; 1636 :         {
; 1637 :           f_info->grad[k][j] += weight
; 1638 :                 *gpoly[m][k]*derivs[jj][j]*mat[jj][web.dimension];

	mov	ebx, DWORD PTR tv429[ebp]
	fld	QWORD PTR [ebx]
	mov	ebx, DWORD PTR _web+620
	fmul	ST(0), ST(1)
	lea	ecx, DWORD PTR [ecx+edi*8]
	mov	edi, DWORD PTR _mat$[ebp]
	mov	edi, DWORD PTR [edi+eax*4]
	fmul	QWORD PTR [edx]
	inc	eax
	add	edx, 48					; 00000030H
	fmul	QWORD PTR [edi+ebx*8]
	mov	ebx, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR _j$[ebp]
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN63@simplex_ve@3
$LN11@simplex_ve@3:

; 1634 :       for ( j = 0 ; j < SDIM ; j++ ) 

	inc	edi
	mov	DWORD PTR _j$[ebp], edi
	cmp	edi, ecx
	jl	SHORT $LN67@simplex_ve@3
	mov	edx, DWORD PTR _ctrl_num
$LN14@simplex_ve@3:

; 1632 :         }
; 1633 :      for ( k = 0 ; k < ctrl_num ; k++ )

	inc	ebx
	mov	DWORD PTR _k$[ebp], ebx
	cmp	ebx, edx
	jl	$LN64@simplex_ve@3
	mov	edi, DWORD PTR _mat$[ebp]
$LN79@simplex_ve@3:

; 1616 : 
; 1617 :   for ( m = 0 ; m < gauss2D_num ; m++ )

	mov	eax, DWORD PTR _m$[ebp]

; 1632 :         }
; 1633 :      for ( k = 0 ; k < ctrl_num ; k++ )

	fstp	ST(0)
	inc	eax
	mov	DWORD PTR _m$[ebp], eax
	cmp	eax, DWORD PTR _gauss2D_num
	jl	$LL62@simplex_ve@3
	pop	ebx
$LN31@simplex_ve@3:

; 1639 :         }
; 1640 :   }
; 1641 :   for ( j = 0 ; j < SDIM ; j++ ) 

	xor	edi, edi
	test	ecx, ecx
	jle	SHORT $LN4@simplex_ve@3
	mov	edx, DWORD PTR [esi+12]
	npad	3
$LL6@simplex_ve@3:

; 1642 :      for ( k = 0 ; k < f_info->vcount ; k++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN5@simplex_ve@3
	npad	10
$LL3@simplex_ve@3:

; 1639 :         }
; 1640 :   }
; 1641 :   for ( j = 0 ; j < SDIM ; j++ ) 

	mov	edx, DWORD PTR [esi+1336]
	mov	ecx, DWORD PTR [edx+eax*4]

; 1643 :         f_info->grad[k][j] /= web.simplex_factorial;

	fld	QWORD PTR [ecx+edi*8]
	lea	ecx, DWORD PTR [ecx+edi*8]
	fdiv	QWORD PTR _web+792
	inc	eax
	fstp	QWORD PTR [ecx]
	mov	edx, DWORD PTR [esi+12]
	cmp	eax, edx
	jl	SHORT $LL3@simplex_ve@3

; 1642 :      for ( k = 0 ; k < f_info->vcount ; k++ )

	mov	ecx, DWORD PTR _web+616
$LN5@simplex_ve@3:

; 1639 :         }
; 1640 :   }
; 1641 :   for ( j = 0 ; j < SDIM ; j++ ) 

	inc	edi
	cmp	edi, ecx
	jl	SHORT $LL6@simplex_ve@3
$LN4@simplex_ve@3:

; 1644 :   return value/web.simplex_factorial;  
; 1645 : } // end simplex_vector_integral_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fld	QWORD PTR _value$[ebp]
	fdiv	QWORD PTR _web+792
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_vector_integral_grad ENDP
_TEXT	ENDS
PUBLIC	_f_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_vector_integral_all
EXTRN	_free_matrix4:PROC
EXTRN	_eval_second:PROC
EXTRN	_kb_dmatrix4:PROC
EXTRN	_gauss_lagrange:BYTE
EXTRN	_mat3d_setup:PROC
; Function compile flags: /Ogtp
;	COMDAT _simplex_vector_integral_all
_TEXT	SEGMENT
_secondsqXvS$ = -2648					; size = 168
_matqXvS$ = -2480					; size = 24
_sign$ = -2456						; size = 8
_weight$90709 = -2448					; size = 8
tv4412 = -2444						; size = 4
_value$ = -2440						; size = 8
tv4205 = -2432						; size = 4
_seconds$ = -2428					; size = 4
_f_info$GSCopy$ = -2424					; size = 4
tv2400 = -2420						; size = 4
_gp$ = -2416						; size = 4
_tr$ = -2412						; size = 4
tv4143 = -2408						; size = 4
_j$ = -2404						; size = 4
_ada$ = -2400						; size = 4
_m$ = -2396						; size = 4
_i$ = -2392						; size = 4
tv2343 = -2388						; size = 4
tv1840 = -2388						; size = 4
_kk$ = -2388						; size = 4
_mat$ = -2384						; size = 4
tv1835 = -2380						; size = 4
tv262 = -2380						; size = 4
tv206 = -2380						; size = 4
_ii$ = -2380						; size = 4
tv3521 = -2376						; size = 4
tv2873 = -2376						; size = 4
tv2378 = -2376						; size = 4
tv3519 = -2372						; size = 4
tv3023 = -2372						; size = 4
tv2777 = -2372						; size = 4
_cpts$ = -2368						; size = 4
_k$ = -2364						; size = 4
tv4307 = -2360						; size = 4
tv1692 = -2360						; size = 4
tv1561 = -2360						; size = 4
tv674 = -2360						; size = 4
_secondsxJ$ = -2356					; size = 1728
_matxJ$ = -628						; size = 288
_derivs$ = -340						; size = 288
_val$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_f_info$ = 8						; size = 4
_mode$ = 12						; size = 4
_simplex_vector_integral_all PROC			; COMDAT

; 1670 : { int i,m,j,k,jj,ii,kk;

	push	ebp
	mov	ebp, esp
	sub	esp, 2648				; 00000a58H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1671 :   REAL sum,value = 0.0;

	fldz
	push	ebx
	mov	ebx, DWORD PTR _f_info$[ebp]
	fstp	QWORD PTR _value$[ebp]
	push	esi

; 1672 :   REAL val[MAXCOORD];
; 1673 :   REAL derivs[MAXCOORD][MAXCOORD];
; 1674 :   MAT3D(seconds,MAXCOORD,MAXCOORD,MAXCOORD);

	push	6
	push	6
	push	6
	lea	eax, DWORD PTR _secondsxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _secondsqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _f_info$GSCopy$[ebp], ebx
	call	_mat3d_setup

; 1675 :   REAL ****ada;
; 1676 :   REAL **tr;
; 1677 :   MAT2D(mat,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	edx, DWORD PTR _matxJ$[ebp]
	mov	DWORD PTR _seconds$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _matqXvS$[ebp]
	push	eax
	call	_mat2d_setup

; 1678 :   REAL sign = (get_fattr(f_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR _web+236
	mov	DWORD PTR _mat$[ebp], eax
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	add	esp, 36					; 00000024H
	or	eax, ecx
	je	SHORT $LN74@simplex_ve@4
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN253@simplex_ve@4
$LN74@simplex_ve@4:
	fld1
$LN253@simplex_ve@4:

; 1679 :   struct gauss_lag *gl = (web.modeltype == LAGRANGE) ? 
; 1680 :        &gauss_lagrange[web.dimension][web.gauss2D_order] : NULL;

	cmp	DWORD PTR _web+628, 3
	fstp	QWORD PTR _sign$[ebp]
	jne	SHORT $LN78@simplex_ve@4
	mov	eax, DWORD PTR _web+1596
	mov	ecx, DWORD PTR _web+620
	shl	eax, 5
	add	eax, DWORD PTR _gauss_lagrange[ecx*4]

; 1681 :   int cpts = (web.modeltype == LAGRANGE) ? gl->lagpts : ctrl_num;

	mov	esi, DWORD PTR [eax+16]

; 1682 :   REAL **gp = (web.modeltype == LAGRANGE) ? gl->gpoly : gpoly;

	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _cpts$[ebp], esi
	mov	DWORD PTR _gp$[ebp], edx
	jmp	SHORT $LN81@simplex_ve@4
$LN78@simplex_ve@4:

; 1681 :   int cpts = (web.modeltype == LAGRANGE) ? gl->lagpts : ctrl_num;

	mov	esi, DWORD PTR _ctrl_num

; 1682 :   REAL **gp = (web.modeltype == LAGRANGE) ? gl->gpoly : gpoly;

	mov	eax, DWORD PTR _gpoly
	mov	DWORD PTR _cpts$[ebp], esi
	mov	DWORD PTR _gp$[ebp], eax
$LN81@simplex_ve@4:

; 1683 : 
; 1684 :   ada = dmatrix4(cpts,SDIM,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	1684					; 00000694H
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	eax
	push	eax
	push	eax
	push	esi
	call	_kb_dmatrix4

; 1685 :   tr = dmatrix(0,cpts,0,SDIM);

	mov	ecx, DWORD PTR _web+616
	push	1685					; 00000695H
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	ecx
	push	0
	push	esi
	push	0
	mov	DWORD PTR _ada$[ebp], eax
	call	_kb_dmatrix
	add	esp, 48					; 00000030H

; 1686 : 
; 1687 :   for ( m = 0 ; m < gauss2D_num ; m++ )

	cmp	DWORD PTR _gauss2D_num, 0
	mov	DWORD PTR _tr$[ebp], eax
	mov	DWORD PTR _m$[ebp], 0
	jle	$LN69@simplex_ve@4
	mov	esi, DWORD PTR _web+616
	mov	eax, DWORD PTR _m$[ebp]
	push	edi
	jmp	SHORT $LN254@simplex_ve@4
	npad	11
$LL145@simplex_ve@4:
	mov	ebx, DWORD PTR _f_info$GSCopy$[ebp]
$LN254@simplex_ve@4:

; 1688 :   { REAL det;
; 1689 :     REAL weight = sign*gauss2Dwt[m]/web.simplex_factorial;

	mov	edx, DWORD PTR _gauss2Dwt
	fld	QWORD PTR [edx+eax*8]
	mov	edi, DWORD PTR _mat$[ebp]
	fmul	QWORD PTR _sign$[ebp]

; 1690 :     for ( i = 0 ; i < web.dimension ; i++ )

	xor	ecx, ecx
	fdiv	QWORD PTR _web+792
	fstp	QWORD PTR _weight$90709[ebp]
	cmp	DWORD PTR _web+620, ecx
	jle	SHORT $LN66@simplex_ve@4
$LL151@simplex_ve@4:

; 1691 :        for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN67@simplex_ve@4
	mov	edx, DWORD PTR [edi+ecx*4]
	npad	6
$LL65@simplex_ve@4:

; 1692 :           mat[i][j] = f_info->sides[0][i][j];  /* mat destroyed by det */

	mov	esi, DWORD PTR [ebx+1276]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+ecx*4]
	fld	QWORD PTR [esi+eax*8]
	inc	eax
	fstp	QWORD PTR [edx+eax*8-8]
	mov	esi, DWORD PTR _web+616
	cmp	eax, esi
	jl	SHORT $LL65@simplex_ve@4
$LN67@simplex_ve@4:

; 1690 :     for ( i = 0 ; i < web.dimension ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR _web+620
	jl	SHORT $LL151@simplex_ve@4
$LN66@simplex_ve@4:

; 1693 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	test	esi, esi
	jle	$LN60@simplex_ve@4
	lea	eax, DWORD PTR _derivs$[ebp]
	mov	DWORD PTR tv1561[ebp], eax
	npad	4
$LL62@simplex_ve@4:

; 1694 :     { eval_second(METH_INSTANCE(f_info->method)->expr[j],f_info->gauss_pt[m],
; 1695 :         SDIM,val+j, derivs[j],seconds[j],f_info->id);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR _seconds$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR tv1561[ebp]
	push	ecx
	mov	ecx, DWORD PTR _m$[ebp]
	push	edx
	lea	eax, DWORD PTR _val$[ebp+edi*8]
	push	eax
	mov	eax, DWORD PTR [ebx+1268]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR _meth_inst_list
	push	esi
	push	edx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 732				; 000002dcH
	add	eax, edi
	mov	edx, DWORD PTR [ecx+eax*4+232]
	push	edx
	call	_eval_second

; 1696 :       mat[web.dimension][j] = val[j];

	mov	eax, DWORD PTR _web+620
	mov	ecx, DWORD PTR _mat$[ebp]
	fld	QWORD PTR _val$[ebp+edi*8]
	mov	edx, DWORD PTR [ecx+eax*4]
	add	DWORD PTR tv1561[ebp], 48		; 00000030H
	fstp	QWORD PTR [edx+edi*8]
	mov	esi, DWORD PTR _web+616
	inc	edi
	add	esp, 28					; 0000001cH
	cmp	edi, esi
	jl	SHORT $LL62@simplex_ve@4
$LN60@simplex_ve@4:

; 1697 :     }
; 1698 :     det = det_adjoint(mat,SDIM);

	mov	eax, DWORD PTR _mat$[ebp]
	push	esi
	push	eax
	call	_det_adjoint

; 1699 : 
; 1700 :     value += weight*det;

	fld	ST(0)
	fld	QWORD PTR _weight$90709[ebp]

; 1701 :     if ( mode == METHOD_VALUE ) continue;
; 1702 : 
; 1703 :     for ( k = 0 ; k < cpts ; k++ )

	mov	esi, DWORD PTR _web+616
	fmul	ST(1), ST(0)
	add	esp, 8
	cmp	DWORD PTR _mode$[ebp], 1767		; 000006e7H
	fxch	ST(1)
	fadd	QWORD PTR _value$[ebp]
	fstp	QWORD PTR _value$[ebp]
	je	$LN215@simplex_ve@4
	cmp	DWORD PTR _cpts$[ebp], 0
	mov	DWORD PTR _k$[ebp], 0
	jle	$LN56@simplex_ve@4
$LN58@simplex_ve@4:

; 1704 :       for ( j = 0 ; j < SDIM ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	test	esi, esi
	jle	$LN57@simplex_ve@4
	lea	ecx, DWORD PTR _derivs$[ebp]
	mov	DWORD PTR tv1692[ebp], ecx
$LN55@simplex_ve@4:

; 1705 :       { for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	esi, esi
	jle	SHORT $LN54@simplex_ve@4
$LN52@simplex_ve@4:

; 1706 :         { for ( jj = 0; jj < SDIM ; jj++ )

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN51@simplex_ve@4
	mov	eax, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _gp$[ebp]
	mov	esi, DWORD PTR _m$[ebp]
	mov	esi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _k$[ebp]
	lea	ebx, DWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR _ada$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR tv1692[ebp]
$LN49@simplex_ve@4:

; 1707 :             ada[k][j][i][jj] = gp[m][k]*mat[i][web.dimension]*derivs[jj][j];

	mov	esi, DWORD PTR _web+620
	fld	QWORD PTR [edi+esi*8]
	inc	edx
	fmul	QWORD PTR [ebx]
	add	eax, 48					; 00000030H
	add	ecx, 8
	fmul	QWORD PTR [eax-48]
	fstp	QWORD PTR [ecx-8]
	mov	esi, DWORD PTR _web+616
	cmp	edx, esi
	jl	SHORT $LN49@simplex_ve@4
$LN51@simplex_ve@4:

; 1705 :       { for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, esi
	jl	SHORT $LN52@simplex_ve@4
$LN54@simplex_ve@4:

; 1704 :       for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	add	DWORD PTR tv1692[ebp], 8
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, esi
	jl	$LN55@simplex_ve@4
$LN57@simplex_ve@4:

; 1701 :     if ( mode == METHOD_VALUE ) continue;
; 1702 : 
; 1703 :     for ( k = 0 ; k < cpts ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _cpts$[ebp]
	jl	$LN58@simplex_ve@4
$LN56@simplex_ve@4:

; 1708 :         }
; 1709 :       }
; 1710 :     for ( k = 1 ; k < cpts ; k++ )

	mov	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR _cpts$[ebp], eax
	jle	$LN44@simplex_ve@4
$LN46@simplex_ve@4:

; 1711 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	test	esi, esi
	jle	SHORT $LN45@simplex_ve@4
$LN43@simplex_ve@4:

; 1712 :       { for ( i = 0 ; i < SDIM ; i++ )

	xor	ebx, ebx
	test	esi, esi
	jle	SHORT $LN42@simplex_ve@4
	mov	edx, DWORD PTR _ada$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	eax, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [edx]
	sub	ecx, eax
	mov	DWORD PTR tv1835[ebp], ecx
	mov	ecx, DWORD PTR [edx+edi*4]
	sub	ecx, eax
	mov	DWORD PTR tv1840[ebp], ecx
$LN40@simplex_ve@4:

; 1711 :       for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR tv1835[ebp]
	mov	edx, DWORD PTR [ecx+eax]

; 1713 :          { ada[k][j][i][j] += mat[i][k-1];

	fld	QWORD PTR [edx+edi*8]
	mov	esi, DWORD PTR _k$[ebp]
	lea	ecx, DWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR [eax]
	fadd	QWORD PTR [edx+esi*8-8]
	lea	edx, DWORD PTR [edx+esi*8-8]
	inc	ebx
	add	eax, 4
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1840[ebp]
	mov	ecx, DWORD PTR [ecx+eax-4]

; 1714 :            ada[0][j][i][j] -= mat[i][k-1];

	fld	QWORD PTR [ecx+edi*8]
	lea	ecx, DWORD PTR [ecx+edi*8]
	fsub	QWORD PTR [edx]
	fstp	QWORD PTR [ecx]
	mov	esi, DWORD PTR _web+616
	cmp	ebx, esi
	jl	SHORT $LN40@simplex_ve@4
$LN42@simplex_ve@4:

; 1711 :       for ( j = 0 ; j < SDIM ; j++ )

	inc	edi
	cmp	edi, esi
	jl	SHORT $LN43@simplex_ve@4
$LN45@simplex_ve@4:

; 1708 :         }
; 1709 :       }
; 1710 :     for ( k = 1 ; k < cpts ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _cpts$[ebp]
	jl	$LN46@simplex_ve@4
$LN44@simplex_ve@4:

; 1715 :          }
; 1716 :       }
; 1717 :     for ( k = 0 ; k < cpts ; k++ )

	mov	eax, DWORD PTR _cpts$[ebp]
	test	eax, eax
	jle	$LN146@simplex_ve@4
	mov	ebx, DWORD PTR _ada$[ebp]
	fldz
	mov	ecx, DWORD PTR _tr$[ebp]
	sub	ecx, ebx
	mov	DWORD PTR tv2378[ebp], ebx
	mov	DWORD PTR tv2400[ebp], ecx
	mov	DWORD PTR tv674[ebp], eax
$LN37@simplex_ve@4:

; 1718 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	test	esi, esi
	jle	$LN36@simplex_ve@4
	mov	edx, DWORD PTR [ecx+ebx]
	mov	DWORD PTR tv2343[ebp], edx
$LN34@simplex_ve@4:

; 1719 :       { for ( i = 0,sum = 0.0 ; i < SDIM ; i++) sum += ada[k][j][i][i];

	xor	eax, eax
	fld	ST(0)
	cmp	esi, 4
	jl	SHORT $LN147@simplex_ve@4
	mov	ecx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ecx+edi*4]
	lea	edx, DWORD PTR [esi-3]
	add	ecx, 8
$LN130@simplex_ve@4:
	mov	ebx, DWORD PTR [ecx-8]
	fadd	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [ecx-4]
	add	eax, 4
	add	ecx, 16					; 00000010H
	fadd	QWORD PTR [ebx+eax*8-24]
	mov	ebx, DWORD PTR [ecx-16]
	fadd	QWORD PTR [ebx+eax*8-16]
	mov	ebx, DWORD PTR [ecx-12]
	fadd	QWORD PTR [ebx+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LN130@simplex_ve@4
	mov	ebx, DWORD PTR tv2378[ebp]
$LN147@simplex_ve@4:
	cmp	eax, esi
	jge	SHORT $LN152@simplex_ve@4
	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edx+edi*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
$LC31@simplex_ve@4:
	mov	edx, DWORD PTR [ecx]
	fadd	QWORD PTR [edx+eax*8]
	inc	eax
	add	ecx, 4
	cmp	eax, esi
	jl	SHORT $LC31@simplex_ve@4
$LN152@simplex_ve@4:

; 1720 :         tr[k][j] = sum;

	mov	eax, DWORD PTR tv2343[ebp]
	fstp	QWORD PTR [eax]
	mov	esi, DWORD PTR _web+616
	inc	edi
	add	eax, 8
	mov	DWORD PTR tv2343[ebp], eax
	cmp	edi, esi
	jl	SHORT $LN34@simplex_ve@4

; 1718 :       for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR tv2400[ebp]
$LN36@simplex_ve@4:

; 1715 :          }
; 1716 :       }
; 1717 :     for ( k = 0 ; k < cpts ; k++ )

	add	ebx, 4
	dec	DWORD PTR tv674[ebp]
	mov	DWORD PTR tv2378[ebp], ebx
	jne	$LN37@simplex_ve@4
	mov	eax, DWORD PTR _cpts$[ebp]
	fstp	ST(0)
$LN146@simplex_ve@4:

; 1721 :       }
; 1722 :     /* gradient */
; 1723 :     for ( k = 0 ; k < cpts; k++ )

	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN26@simplex_ve@4
	mov	ebx, DWORD PTR _f_info$GSCopy$[ebp]
$LN148@simplex_ve@4:

; 1724 :       for ( j = 0 ; j < SDIM ; j++ ) 

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN27@simplex_ve@4
	mov	ecx, DWORD PTR _tr$[ebp]
	mov	edi, DWORD PTR [ecx+edx*4]
$LN25@simplex_ve@4:

; 1725 :       {  f_info->grad[k][j] += weight*tr[k][j];

	fld	QWORD PTR [edi+eax*8]
	mov	ecx, DWORD PTR [ebx+1336]
	mov	ecx, DWORD PTR [ecx+edx*4]
	fmul	ST(0), ST(1)
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	eax
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	esi, DWORD PTR _web+616
	cmp	eax, esi
	jl	SHORT $LN25@simplex_ve@4
$LN27@simplex_ve@4:

; 1721 :       }
; 1722 :     /* gradient */
; 1723 :     for ( k = 0 ; k < cpts; k++ )

	inc	edx
	cmp	edx, DWORD PTR _cpts$[ebp]
	jl	SHORT $LN148@simplex_ve@4
$LN26@simplex_ve@4:

; 1726 :       }
; 1727 :     if ( mode == METHOD_GRADIENT ) continue;

	cmp	DWORD PTR _mode$[ebp], 4321		; 000010e1H
	je	$LN215@simplex_ve@4

; 1728 : 
; 1729 :     /* hessian */
; 1730 :     for ( k = 0 ; k < cpts  ; k++ )

	cmp	DWORD PTR _cpts$[ebp], 0
	mov	DWORD PTR _k$[ebp], 0
	jle	$LN215@simplex_ve@4
	mov	ecx, DWORD PTR _ada$[ebp]
	mov	eax, DWORD PTR _tr$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv4307[ebp], ecx
	mov	DWORD PTR tv2400[ebp], eax
$LN21@simplex_ve@4:

; 1731 :        for ( kk = 0 ; kk < cpts ; kk++ )

	mov	edx, DWORD PTR _ada$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _kk$[ebp], ebx
	mov	DWORD PTR tv4143[ebp], edx
$LN18@simplex_ve@4:

; 1732 :          for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	mov	DWORD PTR _j$[ebp], ecx
	test	esi, esi
	jle	$LN17@simplex_ve@4
$LN150@simplex_ve@4:

; 1733 :            for ( jj = 0 ; jj < SDIM ; jj++ )

	xor	edi, edi
	test	esi, esi
	jle	$LN14@simplex_ve@4

; 1690 :     for ( i = 0 ; i < web.dimension ; i++ )

	mov	edx, DWORD PTR tv4143[ebp]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR tv4205[ebp], edx

; 1732 :          for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR tv4307[ebp]
	mov	eax, DWORD PTR [eax+edx]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR tv4412[ebp], edx
$LN144@simplex_ve@4:

; 1734 :            { REAL h;
; 1735 :              h = tr[k][j]*tr[kk][jj]/det;

	mov	eax, DWORD PTR tv4205[ebp]
	mov	edx, DWORD PTR tv4412[ebp]
	fld	QWORD PTR [eax+edi*8]
	fmul	QWORD PTR [edx]

; 1736 :              for ( i = 0 ; i < SDIM ; i++ ) 

	mov	edx, DWORD PTR _web+620
	mov	DWORD PTR _i$[ebp], 0
	fdiv	ST(0), ST(2)
	cmp	esi, 4
	jl	$LC132@simplex_ve@4
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _gp$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	fld	QWORD PTR [eax+ebx*8]
	mov	edx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _seconds$[ebp]
	mov	ebx, DWORD PTR _mat$[ebp]
	lea	eax, DWORD PTR [edx+12]

; 1737 :                h += gp[m][k]*gp[m][kk]*seconds[i][j][jj]*mat[i][web.dimension];

	sub	edx, ebx
	mov	DWORD PTR tv2873[ebp], edx
	lea	edx, DWORD PTR [esi-4]
	shr	edx, 2
	inc	edx
	mov	DWORD PTR tv262[ebp], edx
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv2777[ebp], eax
	mov	DWORD PTR _i$[ebp], edx
	mov	edx, DWORD PTR _web+620
	lea	eax, DWORD PTR [ebx+4]
$LN143@simplex_ve@4:
	mov	ebx, DWORD PTR tv2777[ebp]
	mov	ebx, DWORD PTR [ebx-12]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	fld	QWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR [eax-4]
	fmul	ST(0), ST(1)
	add	eax, 16					; 00000010H
	fmul	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR tv2873[ebp]
	mov	ebx, DWORD PTR [ebx+eax-16]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR [eax-16]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR tv2777[ebp]
	mov	ebx, DWORD PTR [ebx-4]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR [eax-12]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR tv2777[ebp]
	mov	ebx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	add	DWORD PTR tv2777[ebp], 16		; 00000010H
	faddp	ST(2), ST(0)
	dec	DWORD PTR tv262[ebp]
	fld	QWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR [eax-8]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+edx*8]
	faddp	ST(2), ST(0)
	jne	SHORT $LN143@simplex_ve@4

; 1736 :              for ( i = 0 ; i < SDIM ; i++ ) 

	fstp	ST(0)
$LC132@simplex_ve@4:
	cmp	DWORD PTR _i$[ebp], esi
	jge	$LN131@simplex_ve@4
	mov	ebx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _gp$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	ebx, DWORD PTR _kk$[ebp]
	fld	QWORD PTR [eax+ebx*8]
	mov	ebx, DWORD PTR _k$[ebp]
	fmul	QWORD PTR [eax+ebx*8]
	mov	ebx, DWORD PTR _mat$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR tv3023[ebp], eax
	mov	eax, DWORD PTR _seconds$[ebp]
	sub	eax, ebx
	mov	DWORD PTR tv2873[ebp], eax
	mov	eax, esi
	sub	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv206[ebp], eax
	mov	eax, DWORD PTR tv3023[ebp]
$LC9@simplex_ve@4:

; 1737 :                h += gp[m][k]*gp[m][kk]*seconds[i][j][jj]*mat[i][web.dimension];

	mov	ebx, DWORD PTR tv2873[ebp]
	mov	ebx, DWORD PTR [eax+ebx]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	fld	QWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR [eax]
	fmul	ST(0), ST(1)
	add	eax, 4
	dec	DWORD PTR tv206[ebp]
	fmul	QWORD PTR [ebx+edx*8]
	faddp	ST(2), ST(0)
	jne	SHORT $LC9@simplex_ve@4

; 1736 :              for ( i = 0 ; i < SDIM ; i++ ) 

	fstp	ST(0)
$LN131@simplex_ve@4:

; 1738 :              for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	test	esi, esi
	jle	$LN4@simplex_ve@4
$LN6@simplex_ve@4:

; 1739 :                for ( ii = 0 ; ii < SDIM ; ii++ )

	xor	ebx, ebx
	cmp	esi, 4
	jl	$LC135@simplex_ve@4
	mov	eax, DWORD PTR tv4307[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR tv4143[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [eax+edi*4]
	add	esi, -4					; fffffffcH
	shr	esi, 2
	add	ecx, 16					; 00000010H
	add	eax, 8
	inc	esi
	lea	ebx, DWORD PTR [esi*4]
	mov	DWORD PTR _ii$[ebp], ebx
$LN136@simplex_ve@4:

; 1740 :                  h -= ada[k][j][i][ii]*ada[kk][jj][ii][i]/det;                

	mov	ebx, DWORD PTR [eax-8]
	fld	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [eax-4]
	fmul	QWORD PTR [ecx-16]
	add	eax, 16					; 00000010H
	add	ecx, 32					; 00000020H
	dec	esi
	fdiv	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ebx+edx*8]
	fmul	QWORD PTR [ecx-40]
	mov	ebx, DWORD PTR [eax-16]
	fdiv	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ebx+edx*8]
	fmul	QWORD PTR [ecx-32]
	mov	ebx, DWORD PTR [eax-12]
	fdiv	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ebx+edx*8]
	fmul	QWORD PTR [ecx-24]
	fdiv	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	jne	SHORT $LN136@simplex_ve@4

; 1739 :                for ( ii = 0 ; ii < SDIM ; ii++ )

	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _web+616
	mov	ebx, DWORD PTR _ii$[ebp]
$LC135@simplex_ve@4:
	cmp	ebx, esi
	jge	SHORT $LN5@simplex_ve@4
	mov	eax, DWORD PTR tv4307[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+edx*4]
	lea	eax, DWORD PTR [eax+ebx*8]
	mov	DWORD PTR tv3519[ebp], eax
	mov	eax, DWORD PTR tv4143[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+edi*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR tv3521[ebp], eax
	mov	eax, esi
	sub	eax, ebx
$LN141@simplex_ve@4:

; 1740 :                  h -= ada[k][j][i][ii]*ada[kk][jj][ii][i]/det;                

	mov	ebx, DWORD PTR tv3521[ebp]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR tv3519[ebp]
	fmul	QWORD PTR [ebx]
	add	DWORD PTR tv3521[ebp], 4
	add	DWORD PTR tv3519[ebp], 8
	dec	eax
	fdiv	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	jne	SHORT $LN141@simplex_ve@4
$LN5@simplex_ve@4:

; 1738 :              for ( i = 0 ; i < SDIM ; i++ )

	inc	edx
	cmp	edx, esi
	jl	$LN6@simplex_ve@4
$LN4@simplex_ve@4:

; 1733 :            for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	edx, DWORD PTR _f_info$GSCopy$[ebp]

; 1741 :              f_info->hess[k][kk][j][jj]  += weight*h;

	fmul	ST(0), ST(1)
	mov	eax, DWORD PTR [edx+1340]
	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	ebx, DWORD PTR _kk$[ebp]
	mov	edx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [edx+ecx*4]
	fadd	QWORD PTR [eax+edi*8]
	lea	eax, DWORD PTR [eax+edi*8]
	inc	edi
	fstp	QWORD PTR [eax]
	mov	esi, DWORD PTR _web+616
	cmp	edi, esi
	jl	$LN144@simplex_ve@4

; 1733 :            for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	eax, DWORD PTR tv2400[ebp]
$LN14@simplex_ve@4:

; 1732 :          for ( j = 0 ; j < SDIM ; j++ )

	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, esi
	jl	$LN150@simplex_ve@4
$LN17@simplex_ve@4:

; 1731 :        for ( kk = 0 ; kk < cpts ; kk++ )

	add	DWORD PTR tv4143[ebp], 4
	inc	ebx
	mov	DWORD PTR _kk$[ebp], ebx
	cmp	ebx, DWORD PTR _cpts$[ebp]
	jl	$LN18@simplex_ve@4

; 1728 : 
; 1729 :     /* hessian */
; 1730 :     for ( k = 0 ; k < cpts  ; k++ )

	mov	ecx, DWORD PTR _k$[ebp]
	add	DWORD PTR tv4307[ebp], 4
	inc	ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ecx, DWORD PTR _cpts$[ebp]
	jl	$LN21@simplex_ve@4
$LN215@simplex_ve@4:

; 1686 : 
; 1687 :   for ( m = 0 ; m < gauss2D_num ; m++ )

	mov	eax, DWORD PTR _m$[ebp]

; 1728 : 
; 1729 :     /* hessian */
; 1730 :     for ( k = 0 ; k < cpts  ; k++ )

	fstp	ST(1)
	inc	eax
	fstp	ST(0)
	mov	DWORD PTR _m$[ebp], eax
	cmp	eax, DWORD PTR _gauss2D_num
	jl	$LL145@simplex_ve@4
	pop	edi
$LN69@simplex_ve@4:

; 1742 :            }
; 1743 :   }
; 1744 : 
; 1745 :   free_matrix(tr);

	mov	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	_free_matrix

; 1746 :   free_matrix4(ada);

	mov	edx, DWORD PTR _ada$[ebp]
	push	edx
	call	_free_matrix4

; 1747 :   return value;  

	fld	QWORD PTR _value$[ebp]

; 1748 : } // end simplex_vector_integral_all()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 8
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_vector_integral_all ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@GIOJIHL@simplex_k_vector_integral?5method@ ; `string'
PUBLIC	_simplex_k_vector_integral_init
;	COMDAT ??_C@_0DL@GIOJIHL@simplex_k_vector_integral?5method@
CONST	SEGMENT
??_C@_0DL@GIOJIHL@simplex_k_vector_integral?5method@ DB 'simplex_k_vector'
	DB	'_integral method not for QUADRATIC model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _simplex_k_vector_integral_init
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_simplex_k_vector_integral_init PROC			; COMDAT

; 1772 :   if ( web.modeltype == QUADRATIC ) 

	cmp	DWORD PTR _web+628, 2
	jne	SHORT $LN1@simplex_k_

; 1773 :      kb_error(1553,"simplex_k_vector_integral method not for QUADRATIC model.\n",
; 1774 :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DL@GIOJIHL@simplex_k_vector_integral?5method@
	push	1553					; 00000611H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@simplex_k_:

; 1775 : } // end simplex_k_vector_integral_init()

	ret	0
_simplex_k_vector_integral_init ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_k_vector_integral
EXTRN	_lagrange_k_vector_integral:PROC
; Function compile flags: /Ogtp
;	COMDAT _simplex_k_vector_integral
_TEXT	SEGMENT
_matqXvS$ = -348					; size = 24
_sign$ = -324						; size = 8
_value$ = -316						; size = 8
_order$ = -308						; size = 4
tv412 = -304						; size = 4
_m$ = -300						; size = 4
_mat$ = -296						; size = 4
_matxJ$ = -292						; size = 288
__$ArrayPad$ = -4					; size = 4
_f_info$ = 8						; size = 4
_simplex_k_vector_integral PROC				; COMDAT

; 1786 : { int i,m,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1787 :   REAL value=0.0;

	fldz
	push	esi
	push	edi
	fstp	QWORD PTR _value$[ebp]
	mov	edi, DWORD PTR _f_info$[ebp]

; 1788 :   MAT2D(mat,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _matxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matqXvS$[ebp]
	push	ecx
	call	_mat2d_setup

; 1789 :   REAL sign = (get_fattr(f_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR _mat$[ebp], eax
	mov	eax, DWORD PTR _web+236
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	add	esp, 16					; 00000010H
	or	eax, ecx
	je	SHORT $LN19@simplex_k_@2
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN37@simplex_k_@2
$LN19@simplex_k_@2:
	fld1
$LN37@simplex_k_@2:

; 1790 :   int order = METH_INSTANCE(f_info->method)->vec_order;

	mov	eax, DWORD PTR [edi+8]
	fstp	QWORD PTR _sign$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H

; 1791 :   
; 1792 :   if ( web.modeltype == LAGRANGE ) return lagrange_k_vector_integral(f_info);

	cmp	DWORD PTR _web+628, 3
	mov	esi, DWORD PTR [eax+edx+224]
	mov	DWORD PTR _order$[ebp], esi
	jne	SHORT $LN16@simplex_k_@2
	push	edi
	call	_lagrange_k_vector_integral
	add	esp, 4
	pop	edi
	pop	esi

; 1806 : } // end simplex_k_vector_integral()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@simplex_k_@2:

; 1793 : 
; 1794 :   for ( m = 0 ; m < gauss2D_num ; m++ )

	mov	DWORD PTR _m$[ebp], ecx
	cmp	DWORD PTR _gauss2D_num, ecx
	jle	$LN34@simplex_k_@2
	push	ebx
$LL31@simplex_k_@2:

; 1795 :   { for ( i = 0 ; i < order ; i++ )

	mov	ecx, DWORD PTR _web+616
	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN10@simplex_k_@2
$LL36@simplex_k_@2:

; 1796 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN11@simplex_k_@2
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	ebx, DWORD PTR [ecx+edx*4]
	npad	1
$LL9@simplex_k_@2:

; 1797 :           mat[i][j] = f_info->sides[0][i][j];

	mov	ecx, DWORD PTR [edi+1276]
	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+edx*4]
	fld	QWORD PTR [ecx+eax*8]
	inc	eax
	fstp	QWORD PTR [ebx+eax*8-8]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LL9@simplex_k_@2
$LN11@simplex_k_@2:

; 1795 :   { for ( i = 0 ; i < order ; i++ )

	inc	edx
	cmp	edx, esi
	jl	SHORT $LL36@simplex_k_@2
$LN10@simplex_k_@2:

; 1798 :      for ( k = 0 ; k+order < SDIM ; k++ )

	xor	ebx, ebx
	cmp	esi, ecx
	jge	$LN4@simplex_k_@2
	mov	edx, DWORD PTR _mat$[ebp]
	lea	eax, DWORD PTR [edx+esi*4]
	mov	DWORD PTR tv412[ebp], eax
	npad	5
$LL35@simplex_k_@2:

; 1799 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN5@simplex_k_@2
	npad	10
$LL33@simplex_k_@2:

; 1800 :             mat[k+order][j] = 
; 1801 :               eval(METH_INSTANCE(f_info->method)->expr[j+k*SDIM],
; 1802 :                   f_info->gauss_pt[m],NULLID,NULL);

	mov	edx, DWORD PTR [edi+1268]
	imul	ecx, ebx
	mov	eax, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edi+8]
	push	0
	push	0
	push	edx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 732				; 000002dcH
	add	eax, esi
	add	ecx, eax
	mov	eax, DWORD PTR _meth_inst_list
	mov	ecx, DWORD PTR [eax+ecx*4+232]
	push	ecx
	call	_eval
	mov	edx, DWORD PTR tv412[ebp]
	mov	eax, DWORD PTR [edx]
	inc	esi
	fstp	QWORD PTR [eax+esi*8-8]
	mov	ecx, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	cmp	esi, ecx
	jl	SHORT $LL33@simplex_k_@2
$LN5@simplex_k_@2:

; 1798 :      for ( k = 0 ; k+order < SDIM ; k++ )

	mov	edx, DWORD PTR _order$[ebp]
	add	DWORD PTR tv412[ebp], 4
	inc	ebx
	lea	eax, DWORD PTR [ebx+edx]
	cmp	eax, ecx
	jl	SHORT $LL35@simplex_k_@2
	mov	esi, edx
$LN4@simplex_k_@2:

; 1803 :      value += gauss2Dwt[m]*det_adjoint(mat,SDIM);

	push	ecx
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	_det_adjoint
	mov	eax, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _gauss2Dwt
	fmul	QWORD PTR [edx+eax*8]
	inc	eax
	add	esp, 8
	mov	DWORD PTR _m$[ebp], eax
	fadd	QWORD PTR _value$[ebp]
	fstp	QWORD PTR _value$[ebp]
	cmp	eax, DWORD PTR _gauss2D_num
	jl	$LL31@simplex_k_@2
	pop	ebx
$LN34@simplex_k_@2:

; 1804 :   }
; 1805 :   return sign*value/web.simplex_factorial; 

	fld	QWORD PTR _sign$[ebp]

; 1806 : } // end simplex_k_vector_integral()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fmul	QWORD PTR _value$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	fdiv	QWORD PTR _web+792
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_k_vector_integral ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_k_vector_integral_grad
EXTRN	_lagrange_k_vector_integral_grad:PROC
; Function compile flags: /Ogtp
;	COMDAT _simplex_k_vector_integral_grad
_TEXT	SEGMENT
_matqXvS$ = -2144					; size = 24
_sign$ = -2120						; size = 8
_value$ = -2112						; size = 8
_weight$90845 = -2104					; size = 8
tv508 = -2100						; size = 4
_order$ = -2096						; size = 4
_m$ = -2092						; size = 4
_mat$ = -2088						; size = 4
tv694 = -2084						; size = 4
_jj$ = -2084						; size = 4
tv1025 = -2080						; size = 4
tv729 = -2080						; size = 4
_k$ = -2076						; size = 4
tv719 = -2072						; size = 4
_j$ = -2072						; size = 4
_derivs$ = -2068					; size = 1728
_matxJ$ = -340						; size = 288
_val$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_f_info$ = 8						; size = 4
_simplex_k_vector_integral_grad PROC			; COMDAT

; 1817 : { int i,m,j,k,jj;

	push	ebp
	mov	ebp, esp
	sub	esp, 2144				; 00000860H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1818 :   REAL value = 0.0;

	fldz
	push	ebx
	mov	ebx, DWORD PTR _f_info$[ebp]
	fstp	QWORD PTR _value$[ebp]
	push	edi

; 1819 :   REAL val[MAXCOORD];
; 1820 :   REAL derivs[MAXCOORD][MAXCOORD][MAXCOORD];
; 1821 :   MAT2D(mat,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _matxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matqXvS$[ebp]
	push	ecx
	call	_mat2d_setup

; 1822 :   REAL sign = (get_fattr(f_info->id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	edx, DWORD PTR [ebx]
	mov	DWORD PTR _mat$[ebp], eax
	mov	eax, DWORD PTR _web+236
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	add	esp, 16					; 00000010H
	or	eax, ecx
	je	SHORT $LN43@simplex_k_@3
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN111@simplex_k_@3
$LN43@simplex_k_@3:
	fld1
$LN111@simplex_k_@3:

; 1823 :   int order = METH_INSTANCE(f_info->method)->vec_order;

	mov	eax, DWORD PTR [ebx+8]
	fstp	QWORD PTR _sign$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H

; 1824 :   
; 1825 :   if ( web.modeltype == LAGRANGE ) 

	cmp	DWORD PTR _web+628, 3
	mov	edi, DWORD PTR [eax+edx+224]
	mov	DWORD PTR _order$[ebp], edi
	jne	SHORT $LN40@simplex_k_@3

; 1826 :      return lagrange_k_vector_integral_grad(f_info);

	push	ebx
	call	_lagrange_k_vector_integral_grad
	add	esp, 4
	pop	edi
	pop	ebx

; 1857 :   return value/web.simplex_factorial;  
; 1858 : } // end simplex_k_vector_integral_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@simplex_k_@3:

; 1827 : 
; 1828 :   for ( m = 0 ; m < gauss2D_num ; m++ )

	cmp	DWORD PTR _gauss2D_num, ecx
	mov	DWORD PTR _m$[ebp], ecx
	mov	ecx, DWORD PTR _web+616
	push	esi
	jle	$LN37@simplex_k_@3
	npad	6
$LL71@simplex_k_@3:

; 1829 :   { REAL weight = sign*gauss2Dwt[m];

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _gauss2Dwt
	fld	QWORD PTR [eax+edx*8]

; 1830 :      for ( i = 0 ; i < order ; i++ )

	xor	edx, edx
	fmul	QWORD PTR _sign$[ebp]
	fstp	QWORD PTR _weight$90845[ebp]
	test	edi, edi
	jle	SHORT $LN34@simplex_k_@3
$LL79@simplex_k_@3:

; 1831 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN35@simplex_k_@3
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	esi, DWORD PTR [ecx+edx*4]
	npad	1
$LL33@simplex_k_@3:

; 1832 :           mat[i][j] = f_info->sides[0][i][j];  /* mat destroyed by det */

	mov	ecx, DWORD PTR [ebx+1276]
	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+edx*4]
	fld	QWORD PTR [ecx+eax*8]
	inc	eax
	fstp	QWORD PTR [esi+eax*8-8]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LL33@simplex_k_@3
$LN35@simplex_k_@3:

; 1830 :      for ( i = 0 ; i < order ; i++ )

	inc	edx
	cmp	edx, edi
	jl	SHORT $LL79@simplex_k_@3
$LN34@simplex_k_@3:

; 1833 :      for ( k = 0 ; k+order < SDIM ; k++ )

	mov	DWORD PTR _k$[ebp], 0
	cmp	edi, ecx
	jge	$LN28@simplex_k_@3
	mov	eax, DWORD PTR _mat$[ebp]
	lea	edx, DWORD PTR _derivs$[ebp]
	mov	DWORD PTR tv719[ebp], edx
	lea	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR tv729[ebp], edx
	npad	1
$LL77@simplex_k_@3:

; 1834 :      for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	ecx, ecx
	jle	$LN29@simplex_k_@3
	mov	eax, DWORD PTR tv719[ebp]
	mov	DWORD PTR tv694[ebp], eax
$LL72@simplex_k_@3:

; 1835 :      { eval_all(METH_INSTANCE(f_info->method)->expr[j+k*SDIM],
; 1836 :          f_info->gauss_pt[m],SDIM,val+j,derivs[k][j],f_info->id);

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR tv694[ebp]
	push	edx
	mov	edx, DWORD PTR [ebx+1268]
	push	eax
	mov	eax, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ebx+8]
	lea	edi, DWORD PTR _val$[ebp+esi*8]
	push	edi
	push	ecx
	imul	ecx, DWORD PTR _k$[ebp]
	push	edx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 732				; 000002dcH
	add	eax, esi
	add	ecx, eax
	mov	eax, DWORD PTR _meth_inst_list
	mov	ecx, DWORD PTR [eax+ecx*4+232]
	push	ecx
	call	_eval_all

; 1837 :        mat[k+order][j] = val[j];

	mov	edx, DWORD PTR tv729[ebp]
	mov	eax, DWORD PTR [edx]
	fld	QWORD PTR [edi]
	add	DWORD PTR tv694[ebp], 48		; 00000030H
	fstp	QWORD PTR [eax+esi*8]
	mov	ecx, DWORD PTR _web+616
	inc	esi
	add	esp, 24					; 00000018H
	cmp	esi, ecx
	jl	SHORT $LL72@simplex_k_@3

; 1834 :      for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _order$[ebp]
$LN29@simplex_k_@3:

; 1833 :      for ( k = 0 ; k+order < SDIM ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	add	DWORD PTR tv719[ebp], 288		; 00000120H
	add	DWORD PTR tv729[ebp], 4
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	add	eax, edi
	cmp	eax, ecx
	jl	$LL77@simplex_k_@3
$LN28@simplex_k_@3:

; 1838 :      }
; 1839 :      value += weight*det_adjoint(mat,SDIM);

	push	ecx
	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	_det_adjoint
	fld	QWORD PTR _weight$90845[ebp]

; 1840 :      for ( k = 0 ; k < ctrl_num-1; k++ )

	mov	edx, DWORD PTR _ctrl_num
	fmul	ST(1), ST(0)
	mov	ecx, DWORD PTR _web+616
	fxch	ST(1)
	lea	eax, DWORD PTR [edx-1]
	fadd	QWORD PTR _value$[ebp]
	add	esp, 8
	xor	esi, esi
	fstp	QWORD PTR _value$[ebp]
	test	eax, eax
	jle	SHORT $LN22@simplex_k_@3
$LN24@simplex_k_@3:

; 1841 :       for ( j = 0 ; j < SDIM ; j++ ) 

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN23@simplex_k_@3
$LN76@simplex_k_@3:
	mov	ecx, DWORD PTR [ebx+1336]
	mov	edx, DWORD PTR [ecx+esi*4+4]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]

; 1842 :         { f_info->grad[k+1][j] += weight*mat[j][k];

	fld	QWORD PTR [edx+esi*8]
	lea	edx, DWORD PTR [edx+esi*8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]

; 1843 :           f_info->grad[0][j]    -= weight*mat[j][k];

	mov	ecx, DWORD PTR [ebx+1336]
	fld	QWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fmul	ST(0), ST(1)
	inc	eax
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN76@simplex_k_@3

; 1841 :       for ( j = 0 ; j < SDIM ; j++ ) 

	mov	edx, DWORD PTR _ctrl_num
$LN23@simplex_k_@3:

; 1840 :      for ( k = 0 ; k < ctrl_num-1; k++ )

	inc	esi
	lea	eax, DWORD PTR [edx-1]
	cmp	esi, eax
	jl	SHORT $LN24@simplex_k_@3
$LN22@simplex_k_@3:

; 1844 :         }
; 1845 :      for ( k = 0 ; k < ctrl_num ; k++ )

	xor	eax, eax
	mov	DWORD PTR _k$[ebp], eax
	test	edx, edx
	jle	$LN110@simplex_k_@3
$LN18@simplex_k_@3:

; 1846 :       for ( j = 0 ; j < SDIM ; j++ ) 

	xor	esi, esi
	mov	DWORD PTR _j$[ebp], esi
	test	ecx, ecx
	jle	$LN17@simplex_k_@3
$LN78@simplex_k_@3:

; 1847 :         for ( jj = 0 ; jj < SDIM ; jj++ ) 

	xor	edx, edx
	mov	DWORD PTR _jj$[ebp], edx
	test	ecx, ecx
	jle	$LN14@simplex_k_@3

; 1846 :       for ( j = 0 ; j < SDIM ; j++ ) 

	lea	esi, DWORD PTR _derivs$[ebp+esi*8]
	mov	DWORD PTR tv1025[ebp], esi
$LN12@simplex_k_@3:

; 1848 :          for ( i = 0 ; i+order < SDIM ; i++ )

	cmp	edi, ecx
	jge	$LN11@simplex_k_@3

; 1844 :         }
; 1845 :      for ( k = 0 ; k < ctrl_num ; k++ )

	mov	esi, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _gpoly
	mov	ecx, DWORD PTR [ecx+esi*4]
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv508[ebp], ecx

; 1848 :          for ( i = 0 ; i+order < SDIM ; i++ )

	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	esi, edi
	lea	edi, DWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR tv1025[ebp]
$LN9@simplex_k_@3:

; 1849 :          {
; 1850 :            f_info->grad[k][j] += weight
; 1851 :                 *gpoly[m][k]*derivs[i][jj][j]*mat[jj][i+order];

	mov	ecx, DWORD PTR [ebx+1336]
	fld	ST(0)
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]
	mov	ecx, DWORD PTR tv508[ebp]
	fmul	QWORD PTR [ecx]
	inc	esi
	add	edx, 288				; 00000120H
	add	edi, 8
	fmul	QWORD PTR [edx-288]
	fmul	QWORD PTR [edi-8]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR _k$[ebp]
	cmp	esi, ecx
	jl	SHORT $LN9@simplex_k_@3

; 1848 :          for ( i = 0 ; i+order < SDIM ; i++ )

	mov	edx, DWORD PTR _jj$[ebp]
	mov	edi, DWORD PTR _order$[ebp]
$LN11@simplex_k_@3:

; 1847 :         for ( jj = 0 ; jj < SDIM ; jj++ ) 

	add	DWORD PTR tv1025[ebp], 48		; 00000030H
	inc	edx
	mov	DWORD PTR _jj$[ebp], edx
	cmp	edx, ecx
	jl	$LN12@simplex_k_@3
	mov	esi, DWORD PTR _j$[ebp]
$LN14@simplex_k_@3:

; 1846 :       for ( j = 0 ; j < SDIM ; j++ ) 

	inc	esi
	mov	DWORD PTR _j$[ebp], esi
	cmp	esi, ecx
	jl	$LN78@simplex_k_@3
	mov	edx, DWORD PTR _ctrl_num
$LN17@simplex_k_@3:

; 1844 :         }
; 1845 :      for ( k = 0 ; k < ctrl_num ; k++ )

	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, edx
	jl	$LN18@simplex_k_@3
$LN110@simplex_k_@3:

; 1827 : 
; 1828 :   for ( m = 0 ; m < gauss2D_num ; m++ )

	mov	eax, DWORD PTR _m$[ebp]

; 1846 :       for ( j = 0 ; j < SDIM ; j++ ) 

	fstp	ST(0)
	inc	eax
	mov	DWORD PTR _m$[ebp], eax
	cmp	eax, DWORD PTR _gauss2D_num
	jl	$LL71@simplex_k_@3
$LN37@simplex_k_@3:

; 1852 :          }
; 1853 :   }
; 1854 :   for ( j = 0 ; j < SDIM ; j++ ) 

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN4@simplex_k_@3
	mov	edx, DWORD PTR [ebx+12]
$LL6@simplex_k_@3:

; 1855 :      for ( k = 0 ; k < f_info->vcount ; k++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN5@simplex_k_@3
	npad	6
$LL3@simplex_k_@3:

; 1852 :          }
; 1853 :   }
; 1854 :   for ( j = 0 ; j < SDIM ; j++ ) 

	mov	edx, DWORD PTR [ebx+1336]
	mov	ecx, DWORD PTR [edx+eax*4]

; 1856 :         f_info->grad[k][j] /= web.simplex_factorial;

	fld	QWORD PTR [ecx+esi*8]
	lea	ecx, DWORD PTR [ecx+esi*8]
	fdiv	QWORD PTR _web+792
	inc	eax
	fstp	QWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx+12]
	cmp	eax, edx
	jl	SHORT $LL3@simplex_k_@3

; 1855 :      for ( k = 0 ; k < f_info->vcount ; k++ )

	mov	ecx, DWORD PTR _web+616
$LN5@simplex_k_@3:

; 1852 :          }
; 1853 :   }
; 1854 :   for ( j = 0 ; j < SDIM ; j++ ) 

	inc	esi
	cmp	esi, ecx
	jl	SHORT $LL6@simplex_k_@3
$LN4@simplex_k_@3:

; 1857 :   return value/web.simplex_factorial;  
; 1858 : } // end simplex_k_vector_integral_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fld	QWORD PTR _value$[ebp]
	fdiv	QWORD PTR _web+792
	pop	esi
	pop	edi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_k_vector_integral_grad ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@PNODKEEO@simplex_k_vector_integral?5hess?5o@ ; `string'
PUBLIC	_simplex_k_vector_integral_hess
EXTRN	_lagrange_k_vector_integral_hess:PROC
;	COMDAT ??_C@_0DD@PNODKEEO@simplex_k_vector_integral?5hess?5o@
CONST	SEGMENT
??_C@_0DD@PNODKEEO@simplex_k_vector_integral?5hess?5o@ DB 'simplex_k_vect'
	DB	'or_integral hess only for LAGRANGE.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _simplex_k_vector_integral_hess
_TEXT	SEGMENT
_f_info$ = 8						; size = 4
_simplex_k_vector_integral_hess PROC			; COMDAT

; 1869 : {

	push	ebp
	mov	ebp, esp

; 1870 :   if ( web.modeltype != LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	je	SHORT $LN1@simplex_k_@4

; 1871 :      kb_error(1554,"simplex_k_vector_integral hess only for LAGRANGE.\n",
; 1872 :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DD@PNODKEEO@simplex_k_vector_integral?5hess?5o@
	push	1554					; 00000612H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@simplex_k_@4:

; 1875 : } // end simplex_k_vector_integral_hess()

	pop	ebp

; 1873 : 
; 1874 :   return lagrange_k_vector_integral_hess(f_info);

	jmp	_lagrange_k_vector_integral_hess
_simplex_k_vector_integral_hess ENDP
_TEXT	ENDS
PUBLIC	??_C@_06LLKPBPOH@mirror?$AA@			; `string'
PUBLIC	??_C@_0EA@NLLDKBNF@Can?5do?5hessian_normal?5only?5for?5h@ ; `string'
PUBLIC	_norm$GSCopy$
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_vertex_normal
EXTRN	_find_attribute:PROC
;	COMDAT ??_C@_06LLKPBPOH@mirror?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_06LLKPBPOH@mirror?$AA@ DB 'mirror', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@NLLDKBNF@Can?5do?5hessian_normal?5only?5for?5h@
CONST	SEGMENT
??_C@_0EA@NLLDKBNF@Can?5do?5hessian_normal?5only?5for?5h@ DB 'Can do hess'
	DB	'ian_normal only for hypersurfaces in simplex model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\simplex.c
CONST	ENDS
;	COMDAT _simplex_vertex_normal
_TEXT	SEGMENT
_sidesqXvS$ = -380					; size = 24
_val$90906 = -356					; size = 8
tv332 = -352						; size = 4
_v_id$GSCopy$ = -348					; size = 4
_norm$GSCopy$ = -344					; size = 4
_sidesxJ$ = -340					; size = 288
_xx$90905 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_norm$ = 12						; size = 4
_simplex_vertex_normal PROC				; COMDAT

; 1896 : { facet_id f_id,startf;

	push	ebp
	mov	ebp, esp
	sub	esp, 380				; 0000017cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1926 :   } /* end regular point */
; 1927 : 
; 1928 :   return 1;

	mov	eax, DWORD PTR _norm$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _v_id$[ebp]
	push	esi
	push	edi
	push	6
	push	6
	lea	ecx, DWORD PTR _sidesxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sidesqXvS$[ebp]
	push	edx
	mov	DWORD PTR _v_id$GSCopy$[ebp], ebx
	mov	DWORD PTR _norm$GSCopy$[ebp], eax
	call	_mat2d_setup
	mov	esi, eax
	mov	eax, DWORD PTR _web+620
	inc	eax
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN39@simplex_ve@5

; 1897 :   MAT2D(sides,MAXCOORD,MAXCOORD);
; 1898 :   int i,j;
; 1899 : 
; 1900 :   if ( SDIM > web.dimension+1 )
; 1901 :   { kb_error(2182,"Can do hessian_normal only for hypersurfaces in simplex model.\n",RECOVERABLE );

	push	1
	push	OFFSET ??_C@_0EA@NLLDKBNF@Can?5do?5hessian_normal?5only?5for?5h@
	push	2182					; 00000886H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN39@simplex_ve@5:

; 1902 :   }
; 1903 : 
; 1904 :   if ( get_vattr(v_id) & TRIPLE_PT )

	mov	ecx, DWORD PTR _web+12
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 524288				; 00080000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN21@simplex_ve@5

; 1905 :   { REAL xx[MAXCOORD],val;
; 1906 :     int at = find_attribute(VERTEX,"mirror");

	push	OFFSET ??_C@_06LLKPBPOH@mirror?$AA@
	push	ecx
	call	_find_attribute
	add	esp, 8

; 1907 :     int connum;
; 1908 :     if ( at < 0 )  return 0;

	test	eax, eax
	jns	SHORT $LN20@simplex_ve@5
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1929 : } // end simplex_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@simplex_ve@5:

; 1910 :     for ( i = 0 ; i < SDIM ; i++ ) xx[i] = 0.0;

	mov	esi, DWORD PTR _web+616
	imul	eax, 240				; 000000f0H
	mov	ecx, ebx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+104]
	add	edx, eax
	mov	eax, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ecx+64]
	mov	eax, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [edx+eax]
	test	esi, esi
	jle	SHORT $LN19@simplex_ve@5

; 1909 :     connum = *(int*)get_extra(v_id,at);

	mov	ecx, esi
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	lea	edi, DWORD PTR _xx$90905[ebp]
	rep stosd
$LN19@simplex_ve@5:

; 1911 :     eval_all(get_constraint(connum)->formula,xx,SDIM,&val,norm[0],v_id);

	mov	ecx, DWORD PTR _norm$GSCopy$[ebp]
	mov	eax, DWORD PTR [ecx]
	and	edx, 1073741823				; 3fffffffH
	push	ebx
	imul	edx, 176				; 000000b0H
	push	eax
	lea	ecx, DWORD PTR _val$90906[ebp]
	push	ecx
	mov	ecx, DWORD PTR _web+652
	mov	edx, DWORD PTR [edx+ecx+40]
	push	esi
	lea	eax, DWORD PTR _xx$90905[ebp]
	push	eax
	push	edx
	call	_eval_all
	add	esp, 24					; 00000018H

; 1912 :   }
; 1913 :   else /* regular point */

	jmp	$LN10@simplex_ve@5
$LN21@simplex_ve@5:

; 1914 :   {  
; 1915 :     for ( i = 0 ; i < SDIM ; i++ ) norm[0][i] = 0.0;

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN13@simplex_ve@5
	mov	ecx, DWORD PTR _norm$GSCopy$[ebp]
	fldz
	mov	ecx, DWORD PTR [ecx]
$LN15@simplex_ve@5:
	fst	QWORD PTR [ecx]
	inc	eax
	add	ecx, 8
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN15@simplex_ve@5
	fstp	ST(0)
$LN13@simplex_ve@5:

; 1916 :     startf = f_id = get_vertex_first_facet(v_id);

	push	ebx
	call	_get_vertex_first_facet
	add	esp, 4
	mov	ebx, eax
	or	eax, 134217728				; 08000000H

; 1924 :       f_id = get_next_vertex_facet(v_id,f_id);

	mov	DWORD PTR tv332[ebp], eax
	npad	3
$LL12@simplex_ve@5:

; 1917 :     do
; 1918 :     { get_facet_verts(f_id,sides,NULL);

	push	0
	push	esi
	push	ebx
	call	_get_facet_verts

; 1919 :       for ( i = 1 ; i <= web.dimension ; i++ )

	mov	edx, DWORD PTR _web+616
	mov	edi, 1
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+620, edi
	jl	SHORT $LN7@simplex_ve@5
	npad	1
$LL9@simplex_ve@5:

; 1920 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN8@simplex_ve@5
	mov	ecx, DWORD PTR [esi+edi*4]
	npad	7
$LL6@simplex_ve@5:

; 1921 :           sides[i][j] -= sides[0][j];

	mov	edx, DWORD PTR [esi]
	fld	QWORD PTR [ecx+eax*8]
	fsub	QWORD PTR [edx+eax*8]
	inc	eax
	fstp	QWORD PTR [ecx+eax*8-8]
	mov	edx, DWORD PTR _web+616
	cmp	eax, edx
	jl	SHORT $LL6@simplex_ve@5
$LN8@simplex_ve@5:

; 1919 :       for ( i = 1 ; i <= web.dimension ; i++ )

	inc	edi
	cmp	edi, DWORD PTR _web+620
	jle	SHORT $LL9@simplex_ve@5
$LN7@simplex_ve@5:

; 1922 :       det_adjoint(sides,SDIM);

	push	edx
	push	esi
	call	_det_adjoint
	fstp	ST(0)

; 1923 :       for ( i = 0 ; i < SDIM ; i++ ) norm[0][i] += sides[i][0];

	xor	eax, eax
	add	esp, 8
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN1@simplex_ve@5

; 1922 :       det_adjoint(sides,SDIM);

	mov	ecx, DWORD PTR _norm$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ecx]
	npad	2
$LL3@simplex_ve@5:

; 1923 :       for ( i = 0 ; i < SDIM ; i++ ) norm[0][i] += sides[i][0];

	mov	edx, DWORD PTR [esi+eax*4]
	fld	QWORD PTR [edx]
	inc	eax
	fadd	QWORD PTR [ecx]
	add	ecx, 8
	fstp	QWORD PTR [ecx-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL3@simplex_ve@5
$LN1@simplex_ve@5:

; 1924 :       f_id = get_next_vertex_facet(v_id,f_id);

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	ebx
	push	eax
	call	_get_next_vertex_facet
	mov	ebx, eax

; 1925 :     } while ( !equal_element(f_id,startf) );

	mov	ecx, ebx
	or	ecx, 134217728				; 08000000H
	add	esp, 8
	cmp	ecx, DWORD PTR tv332[ebp]
	jne	$LL12@simplex_ve@5
$LN10@simplex_ve@5:

; 1929 : } // end simplex_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	mov	eax, 1
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_vertex_normal ENDP
_TEXT	ENDS
PUBLIC	__real@4000000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_slistmake
_BSS	SEGMENT
_count	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _slistmake
_TEXT	SEGMENT
_pt$89354 = -80						; size = 4
_numedges$ = -76					; size = 4
_snum$ = -72						; size = 4
tv1849 = -68						; size = 4
_j$ = -64						; size = 4
tv1979 = -60						; size = 4
tv2157 = -56						; size = 4
_elist$ = -52						; size = 4
tv2297 = -48						; size = 4
tv1855 = -48						; size = 4
tv2322 = -44						; size = 4
tv1994 = -44						; size = 4
tv2350 = -40						; size = 4
tv2129 = -40						; size = 4
tv2375 = -36						; size = 4
tv2125 = -36						; size = 4
_vlist$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_sdim$ = 8						; size = 4
_slistmake PROC						; COMDAT

; 339  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	edi

; 345  :   struct simplex *sslist;
; 346  : 
; 347  :   vcoord = (REAL(*)[MAXCOORD])temp_calloc((MAXCOORD+1)*(MAXCOORD+2)/2*MAXCOORD,
; 348  :                   sizeof(REAL));

	push	348					; 0000015cH
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	8
	xor	edi, edi
	push	168					; 000000a8H
	mov	DWORD PTR _snum$[ebp], edi
	call	_kb_temp_calloc

; 349  : 
; 350  :   /* set up initial arrays */
; 351  :   /* outer vertices */
; 352  :   for ( i = 0 ; i <= sdim ; i++ ) 

	mov	ebx, DWORD PTR _sdim$[ebp]
	add	esp, 16					; 00000010H
	xor	ecx, ecx
	mov	DWORD PTR _vcoord, eax
	cmp	ebx, edi
	jl	SHORT $LN20@slistmake

; 340  :   int vlist[MAXCOORD+1];
; 341  :   int i,j;
; 342  :   struct divedge *elist;
; 343  :   int numedges;
; 344  :   int pnum,snum=0;

	fld	QWORD PTR __real@4000000000000000
	add	eax, -8					; fffffff8H
$LN22@slistmake:

; 353  :      { vlist[i] = i;

	mov	DWORD PTR _vlist$[ebp+ecx*4], ecx

; 354  :        if ( i > 0 ) vcoord[i][i-1] = 2.0;

	cmp	ecx, edi
	jle	SHORT $LN21@slistmake
	fst	QWORD PTR [eax]
$LN21@slistmake:

; 349  : 
; 350  :   /* set up initial arrays */
; 351  :   /* outer vertices */
; 352  :   for ( i = 0 ; i <= sdim ; i++ ) 

	inc	ecx
	add	eax, 56					; 00000038H
	cmp	ecx, ebx
	jle	SHORT $LN22@slistmake
	fstp	ST(0)
$LN20@slistmake:

; 355  :      }
; 356  :   /* edges */
; 357  :   numedges = (sdim*(sdim+1))/2;

	lea	eax, DWORD PTR [ebx+1]
	imul	eax, ebx
	push	esi
	cdq

; 358  :   elist = (struct divedge *)temp_calloc(numedges,sizeof(struct divedge));

	push	358					; 00000166H
	sub	eax, edx
	mov	esi, eax
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	sar	esi, 1
	push	12					; 0000000cH
	push	esi
	mov	DWORD PTR _numedges$[ebp], esi
	call	_kb_temp_calloc

; 359  :   for ( i = 0, count = 0 ; i < sdim ; i++ )

	xor	edx, edx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _elist$[ebp], eax
	mov	DWORD PTR _count, edx
	cmp	ebx, edi
	jle	$LN40@slistmake

; 355  :      }
; 356  :   /* edges */
; 357  :   numedges = (sdim*(sdim+1))/2;

	mov	ecx, DWORD PTR _vcoord
	fld	QWORD PTR __real@3fe0000000000000
	mov	eax, 1
	mov	DWORD PTR tv2125[ebp], edi
	mov	DWORD PTR tv2129[ebp], eax
	mov	DWORD PTR tv2157[ebp], ecx
$LN43@slistmake:

; 360  :      for ( j = i+1 ; j <= sdim ; j++ )

	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, ebx
	jg	$LN17@slistmake
	mov	esi, DWORD PTR tv2125[ebp]
	mov	edi, DWORD PTR tv2157[ebp]
	add	esi, 6
	add	edi, 48					; 00000030H
	mov	DWORD PTR tv1979[ebp], edi
	mov	edi, DWORD PTR _elist$[ebp]
	mov	DWORD PTR tv1849[ebp], esi
	lea	esi, DWORD PTR [edx+ebx+1]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [edi+edx*4+8]
	mov	edi, ebx
	sub	edi, eax
	mov	eax, DWORD PTR _count
	lea	eax, DWORD PTR [eax+edi+1]
	mov	DWORD PTR _count, eax
$LN41@slistmake:

; 361  :         { int pt,k;
; 362  :           elist[count].endpt[0] = i;

	mov	eax, DWORD PTR tv2129[ebp]
	dec	eax
	mov	DWORD PTR [edx-8], eax

; 363  :           elist[count].endpt[1] = j;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx-4], eax

; 364  :           elist[count].divpt = pt = sdim+1 + count;

	mov	eax, esi
	mov	DWORD PTR [edx], esi

; 365  :           count++;

	inc	esi
	add	edx, 12					; 0000000cH

; 366  :           for ( k = 0 ; k < sdim ; k++ )

	xor	edi, edi
	mov	DWORD PTR _pt$89354[ebp], eax
	mov	DWORD PTR tv1855[ebp], esi
	mov	DWORD PTR tv1994[ebp], edx
	cmp	ebx, 4
	jl	SHORT $LC38@slistmake

; 361  :         { int pt,k;
; 362  :           elist[count].endpt[0] = i;

	mov	edx, DWORD PTR tv2157[ebp]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	lea	esi, DWORD PTR [ebx-4]
	add	eax, ecx
	mov	ecx, DWORD PTR tv1979[ebp]
	shr	esi, 2
	inc	esi
	lea	edi, DWORD PTR [esi*4]

; 366  :           for ( k = 0 ; k < sdim ; k++ )

$LN39@slistmake:

; 367  :              vcoord[pt][k] = (vcoord[i][k] + vcoord[j][k])/2.0;

	fld	QWORD PTR [edx]
	add	ecx, 32					; 00000020H
	fadd	QWORD PTR [ecx-32]
	add	edx, 32					; 00000020H
	add	eax, 32					; 00000020H
	dec	esi
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx-24]
	fadd	QWORD PTR [edx-24]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [ecx-16]
	fadd	QWORD PTR [edx-16]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-16]
	fld	QWORD PTR [ecx-8]
	fadd	QWORD PTR [edx-8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LN39@slistmake

; 361  :         { int pt,k;
; 362  :           elist[count].endpt[0] = i;

	mov	eax, DWORD PTR _pt$89354[ebp]
	mov	edx, DWORD PTR tv1994[ebp]
	mov	esi, DWORD PTR tv1855[ebp]
	mov	ecx, DWORD PTR _vcoord
$LC38@slistmake:

; 366  :           for ( k = 0 ; k < sdim ; k++ )

	cmp	edi, ebx
	jge	SHORT $LN14@slistmake
	lea	edx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edi+edx*2]
	mov	edx, DWORD PTR tv2125[ebp]
	lea	esi, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR tv1849[ebp]
	add	edx, edi
	add	eax, edi
	lea	edx, DWORD PTR [ecx+edx*8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, ebx
	sub	eax, edi
$LC12@slistmake:

; 367  :              vcoord[pt][k] = (vcoord[i][k] + vcoord[j][k])/2.0;

	fld	QWORD PTR [edx]
	add	ecx, 8
	fadd	QWORD PTR [ecx-8]
	add	edx, 8
	add	esi, 8
	dec	eax
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi-8]
	jne	SHORT $LC12@slistmake

; 366  :           for ( k = 0 ; k < sdim ; k++ )

	mov	edx, DWORD PTR tv1994[ebp]
	mov	esi, DWORD PTR tv1855[ebp]
	mov	ecx, DWORD PTR _vcoord
$LN14@slistmake:

; 360  :      for ( j = i+1 ; j <= sdim ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	add	DWORD PTR tv1979[ebp], 48		; 00000030H
	add	DWORD PTR tv1849[ebp], 6
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, ebx
	jle	$LN41@slistmake
	mov	edx, DWORD PTR _count
	mov	eax, DWORD PTR tv2129[ebp]
	mov	esi, DWORD PTR _numedges$[ebp]
$LN17@slistmake:

; 359  :   for ( i = 0, count = 0 ; i < sdim ; i++ )

	add	DWORD PTR tv2157[ebp], 48		; 00000030H
	add	DWORD PTR tv2125[ebp], 6
	inc	eax
	lea	edi, DWORD PTR [eax-1]
	mov	DWORD PTR tv2129[ebp], eax
	cmp	edi, ebx
	jl	$LN43@slistmake
	fstp	ST(0)
$LN40@slistmake:

; 368  :         }
; 369  : 
; 370  :   scount = (1 << sdim);

	mov	ecx, ebx

; 371  :   sslist = (struct simplex *)mycalloc(scount,sizeof(struct simplex));

	push	371					; 00000173H
	mov	eax, 1
	shl	eax, cl
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	28					; 0000001cH
	push	eax
	mov	DWORD PTR _scount, eax
	call	_kb_calloc
	add	esp, 16					; 00000010H
	mov	edi, eax

; 372  : 
; 373  :   /* do simplices on corners */
; 374  :   for ( i = 0 ; i <= sdim ; i++ )

	test	ebx, ebx
	js	SHORT $LN7@slistmake

; 368  :         }
; 369  : 
; 370  :   scount = (1 << sdim);

	lea	eax, DWORD PTR [ebx+1]
	xor	edx, edx
	lea	ecx, DWORD PTR _vlist$[ebp]
	mov	DWORD PTR tv2322[ebp], edx
	mov	DWORD PTR tv2375[ebp], ecx
	mov	DWORD PTR tv2350[ebp], eax

; 372  : 
; 373  :   /* do simplices on corners */
; 374  :   for ( i = 0 ; i <= sdim ; i++ )

	mov	DWORD PTR _snum$[ebp], eax
	npad	2
$LL45@slistmake:

; 375  :      { 
; 376  :         for ( j = 0, pnum = 0 ; j < numedges ; j++ )

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN4@slistmake
	mov	eax, DWORD PTR _elist$[ebp]
	add	eax, 8
	mov	DWORD PTR tv2297[ebp], esi
	npad	1
$LL6@slistmake:

; 377  :           if ( (elist[j].endpt[0]==vlist[i]) || (elist[j].endpt[1]==vlist[i]))

	mov	esi, DWORD PTR tv2375[ebp]
	mov	esi, DWORD PTR [esi]
	cmp	DWORD PTR [eax-8], esi
	je	SHORT $LN2@slistmake
	cmp	DWORD PTR [eax-4], esi
	jne	SHORT $LN5@slistmake
$LN2@slistmake:

; 378  :              sslist[snum].pt[pnum++] = elist[j].divpt;

	mov	esi, DWORD PTR [eax]
	add	edx, ecx
	mov	DWORD PTR [edi+edx*4], esi
	mov	edx, DWORD PTR tv2322[ebp]
	inc	ecx
$LN5@slistmake:

; 375  :      { 
; 376  :         for ( j = 0, pnum = 0 ; j < numedges ; j++ )

	add	eax, 12					; 0000000cH
	dec	DWORD PTR tv2297[ebp]
	jne	SHORT $LL6@slistmake
	mov	esi, DWORD PTR _numedges$[ebp]
$LN4@slistmake:

; 379  :         sslist[snum].pt[pnum] = vlist[i]; /* add common basepoint */

	lea	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR tv2375[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	DWORD PTR tv2375[ebp], 4

; 380  :         snum++;

	add	edx, 7
	dec	DWORD PTR tv2350[ebp]
	mov	DWORD PTR [edi+eax*4], ecx
	mov	DWORD PTR tv2322[ebp], edx
	jne	SHORT $LL45@slistmake
$LN7@slistmake:
	pop	esi

; 381  :      }
; 382  :   /* do interior blob */
; 383  :   if ( sdim > 1 )

	cmp	ebx, 1
	jle	SHORT $LN46@slistmake

; 384  :      refine_simplex(sdim,vlist,elist,sslist+snum);

	mov	eax, DWORD PTR _snum$[ebp]
	mov	ecx, DWORD PTR _elist$[ebp]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	lea	eax, DWORD PTR [edi+edx*4]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _vlist$[ebp]
	push	edx
	push	ebx
	call	_refine_simplex
	add	esp, 16					; 00000010H
$LN46@slistmake:

; 385  : 
; 386  :   check_orientation(sslist,sdim);

	push	ebx
	push	edi
	call	_check_orientation

; 387  :   temp_free((char*)vcoord);

	mov	eax, DWORD PTR _vcoord
	push	eax
	call	_temp_free

; 388  :   temp_free((char*)elist);

	mov	ecx, DWORD PTR _elist$[ebp]
	push	ecx
	call	_temp_free

; 389  :     
; 390  :   return sslist;
; 391  : } // end slistmake()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 16					; 00000010H
	mov	eax, edi
	pop	edi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_slistmake ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@KLLMDHN@Hash?5table?5expansion?5error?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@EKKBMLID@Fatal?5hash?5conflict?5in?5rehash?4?6?$AA@ ; `string'
PUBLIC	_rehash
;	COMDAT ??_C@_0BN@KLLMDHN@Hash?5table?5expansion?5error?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@KLLMDHN@Hash?5table?5expansion?5error?4?6?$AA@ DB 'Hash table e'
	DB	'xpansion error.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EKKBMLID@Fatal?5hash?5conflict?5in?5rehash?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@EKKBMLID@Fatal?5hash?5conflict?5in?5rehash?4?6?$AA@ DB 'Fatal h'
	DB	'ash conflict in rehash.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _rehash
_TEXT	SEGMENT
_oldhashtable$ = -12					; size = 4
_i$ = -8						; size = 4
_recount$ = -4						; size = 4
_rehash	PROC						; COMDAT

; 457  : { struct entry *oldhashtable = simhashtable;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 458  :   int i,j;
; 459  :   struct entry *h;
; 460  :   unsigned int hash1,hash2,hash;
; 461  :   int recount=0;
; 462  : 
; 463  :   simhashtable = (struct entry *)mycalloc(2*tablesize,sizeof(struct entry));

	mov	eax, DWORD PTR _tablesize
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _simhashtable
	push	463					; 000001cfH
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	lea	ecx, DWORD PTR [eax+eax]
	push	12					; 0000000cH
	xor	esi, esi
	push	ecx
	mov	DWORD PTR _oldhashtable$[ebp], edi
	mov	DWORD PTR _recount$[ebp], esi
	call	_kb_calloc
	mov	ebx, eax

; 464  : 
; 465  :   /* rehash all entries */
; 466  :   hashmask += tablesize;

	mov	eax, DWORD PTR _tablesize
	add	DWORD PTR _hashmask, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _simhashtable, ebx

; 467  :   for ( i = 0, h = oldhashtable ; i < tablesize ; i++,h++ )

	mov	DWORD PTR _i$[ebp], esi
	cmp	eax, esi
	jle	$LN18@rehash
$LL21@rehash:

; 468  :      {
; 469  :         if ( !h->divpt ) continue;

	cmp	DWORD PTR [edi+8], 0
	je	$LN9@rehash

; 470  :         hash1 = (unsigned int)(hash_1(h->endpt[0]) + hash_1(h->endpt[1]));

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi]
	imul	eax, 701				; 000002bdH
	imul	edx, 701				; 000002bdH
	shr	edx, 7
	shr	eax, 7
	add	eax, edx

; 471  :         hash2 = (unsigned int)(hash_2(h->endpt[0]) + hash_2(h->endpt[1]));
; 472  :         hash = hash1 % hashmask;

	xor	edx, edx
	div	DWORD PTR _hashmask

; 473  :         for ( j = 0 ; j < hashentries ; j++ )

	xor	ecx, ecx
	cmp	DWORD PTR _hashentries, ecx
	jle	SHORT $LN15@rehash
	npad	9
$LL19@rehash:

; 474  :           {
; 475  :              if ( !simhashtable[hash].divpt ) break; /* empty spot */

	lea	eax, DWORD PTR [edx+edx*2]
	cmp	DWORD PTR [ebx+eax*4+8], 0
	je	SHORT $LN15@rehash

; 476  :              hash += hash2;

	lea	eax, DWORD PTR [edx+2]

; 477  :              hash %= hashmask;

	xor	edx, edx
	div	DWORD PTR _hashmask
	inc	ecx
	cmp	ecx, DWORD PTR _hashentries
	jl	SHORT $LL19@rehash
$LN15@rehash:

; 478  :           }
; 479  :   if ( simhashtable[hash].divpt )

	lea	esi, DWORD PTR [edx+edx*2]
	add	esi, esi
	add	esi, esi
	cmp	DWORD PTR [esi+ebx+8], 0
	je	SHORT $LN2@rehash

; 480  :     kb_error(1546,"Fatal hash conflict in rehash.\n",UNRECOVERABLE);

	push	0
	push	OFFSET ??_C@_0CA@EKKBMLID@Fatal?5hash?5conflict?5in?5rehash?4?6?$AA@
	push	1546					; 0000060aH
	call	_kb_error
	mov	ebx, DWORD PTR _simhashtable
	add	esp, 12					; 0000000cH
$LN2@rehash:

; 481  : 
; 482  :         simhashtable[hash] = *h;  /* move in entry */

	mov	ecx, DWORD PTR [edi]

; 483  :         recount++;

	inc	DWORD PTR _recount$[ebp]
	mov	DWORD PTR [esi+ebx], ecx
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+ebx+4], edx
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+ebx+8], eax
$LN9@rehash:

; 467  :   for ( i = 0, h = oldhashtable ; i < tablesize ; i++,h++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	edi, 12					; 0000000cH
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _tablesize
	jl	$LL21@rehash
	mov	edi, DWORD PTR _oldhashtable$[ebp]
$LN18@rehash:

; 484  :      }
; 485  :   if ( recount != hashentries )

	mov	ecx, DWORD PTR _recount$[ebp]
	cmp	ecx, DWORD PTR _hashentries
	je	SHORT $LN1@rehash

; 486  :      { end_hash_table();

	call	_end_hash_table

; 487  :         kb_error(1547,"Hash table expansion error.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BN@KLLMDHN@Hash?5table?5expansion?5error?4?6?$AA@
	push	1547					; 0000060bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@rehash:

; 488  : 
; 489  :      }
; 490  :   tablesize <<= 1;  /* REAL tablesize */

	shl	DWORD PTR _tablesize, 1

; 491  :   maxload <<= 1;

	shl	DWORD PTR _maxload, 1

; 492  :   myfree((char*)oldhashtable);

	push	edi
	call	_myfree
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 493  : } // end rehash()

	mov	esp, ebp
	pop	ebp
	ret	0
_rehash	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@GKPDKACH@Fatal?5hash?5conflict?4?6?$AA@ ; `string'
PUBLIC	_v2$GSCopy$
PUBLIC	_v1$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_edge_divide
EXTRN	_set_v_conmap:PROC
;	COMDAT ??_C@_0BG@GKPDKACH@Fatal?5hash?5conflict?4?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BG@GKPDKACH@Fatal?5hash?5conflict?4?6?$AA@ DB 'Fatal hash conflict'
	DB	'.', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\simplex.c
CONST	ENDS
;	COMDAT _simplex_edge_divide
_TEXT	SEGMENT
tv422 = -164						; size = 4
tv597 = -160						; size = 4
_v2$GSCopy$ = -156					; size = 4
_v1$GSCopy$ = -152					; size = 4
tv199 = -148						; size = 4
_newv$ = -148						; size = 4
_i$ = -148						; size = 4
_conmap$ = -144						; size = 92
_newx$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_simplex_edge_divide PROC				; COMDAT

; 514  : { vertex_id newv;

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _v2$[ebp]
	push	esi
	mov	esi, DWORD PTR _v1$[ebp]

; 552  :      set_boundary_num(newv,get_boundary(v1)->num);

	mov	DWORD PTR _v1$GSCopy$[ebp], esi
	mov	DWORD PTR _v2$GSCopy$[ebp], ebx
	cmp	esi, ebx
	jbe	SHORT $LN12@simplex_ed@2

; 515  :   REAL *x1,*x2;
; 516  :   REAL newx[MAXCOORD];
; 517  :   unsigned int hash1,hash2,hash;
; 518  :   int i;
; 519  :   conmap_t conmap[MAXCONPER]; // for common
; 520  : 
; 521  :   /* get vertices in canonical order */
; 522  :   if ( v1 > v2 ) { vertex_id temp = v1; v1 = v2; v2 = temp;}

	mov	eax, esi
	mov	esi, ebx
	mov	DWORD PTR _v1$GSCopy$[ebp], esi
	mov	ebx, eax
	mov	DWORD PTR _v2$GSCopy$[ebp], eax
$LN12@simplex_ed@2:

; 523  : 
; 524  :   /* look up in hash table */
; 525  :   hash1 = (unsigned int)(hash_1(v1) + hash_1(v2));

	mov	eax, ebx
	imul	eax, 701				; 000002bdH
	mov	ecx, esi
	imul	ecx, 701				; 000002bdH
	shr	eax, 7
	shr	ecx, 7
	add	eax, ecx

; 526  :   hash2 = (unsigned int)(hash_2(v1) + hash_2(v2));
; 527  :   hash = hash1 % hashmask;
; 528  :   for ( i = 0 ; i <= hashentries ; i++ )

	mov	ecx, DWORD PTR _simhashtable
	xor	edx, edx
	div	DWORD PTR _hashmask
	cmp	DWORD PTR _hashentries, 0
	mov	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN34@simplex_ed@2
	npad	10
$LL33@simplex_ed@2:

; 529  :   { 
; 530  :     if ( !simhashtable[hash].divpt ) break; /* missing */

	lea	eax, DWORD PTR [edx+edx*2]
	cmp	DWORD PTR [ecx+eax*4+8], 0
	lea	eax, DWORD PTR [ecx+eax*4]
	je	SHORT $LN34@simplex_ed@2

; 531  :     if ( (simhashtable[hash].endpt[0]==v1) && (simhashtable[hash].endpt[1]==v2) )

	cmp	DWORD PTR [eax], esi
	jne	SHORT $LN7@simplex_ed@2
	cmp	DWORD PTR [eax+4], ebx
	je	$LN28@simplex_ed@2
$LN7@simplex_ed@2:

; 533  :     hash += hash2;

	lea	eax, DWORD PTR [edx+2]

; 534  :     hash %= hashmask;

	xor	edx, edx
	div	DWORD PTR _hashmask
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _hashentries
	jle	SHORT $LL33@simplex_ed@2
$LN34@simplex_ed@2:
	push	edi

; 535  :   }
; 536  :   if ( simhashtable[hash].divpt )

	lea	edi, DWORD PTR [edx+edx*2]
	add	edi, edi
	add	edi, edi
	cmp	DWORD PTR [edi+ecx+8], 0
	je	SHORT $LN6@simplex_ed@2

; 537  :     kb_error(1548,"Fatal hash conflict.\n",UNRECOVERABLE);

	push	0
	push	OFFSET ??_C@_0BG@GKPDKACH@Fatal?5hash?5conflict?4?6?$AA@
	push	1548					; 0000060cH
	call	_kb_error
	mov	ecx, DWORD PTR _simhashtable
	add	esp, 12					; 0000000cH
$LN6@simplex_ed@2:

; 538  : 
; 539  :   /* need to insert new edge and dividing point */
; 540  :   simhashtable[hash].endpt[0] = v1;

	mov	DWORD PTR [edi+ecx], esi

; 541  :   simhashtable[hash].endpt[1] = v2;

	mov	DWORD PTR [edi+ecx+4], ebx

; 542  :   x1 = get_coord(v1); x2 = get_coord(v2);

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	ecx, DWORD PTR _web+12
	and	esi, 134217727				; 07ffffffH
	and	ebx, 134217727				; 07ffffffH
	add	esi, esi
	add	ebx, ebx
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+ecx]
	add	eax, edx
	add	ecx, edx

; 543  :   for ( i = 0 ; i < SDIM ; i++ )

	cmp	DWORD PTR _web+616, 0
	mov	DWORD PTR tv422[ebp], ebx
	jle	SHORT $LN3@simplex_ed@2
	fld	QWORD PTR __real@3fe0000000000000
	lea	edx, DWORD PTR _newx$[ebp]
	sub	ecx, eax
	sub	edx, eax
	mov	DWORD PTR tv597[ebp], edx
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR tv199[ebp], edx
$LN5@simplex_ed@2:

; 544  :      newx[i] = (x1[i] + x2[i])/2;

	fld	QWORD PTR [ecx+eax]
	mov	edx, DWORD PTR tv597[ebp]
	fadd	QWORD PTR [eax]
	add	eax, 8
	dec	DWORD PTR tv199[ebp]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx+eax-8]
	jne	SHORT $LN5@simplex_ed@2

; 543  :   for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN3@simplex_ed@2:

; 545  :   simhashtable[hash].divpt = newv = new_vertex(newx,NULLID);

	lea	eax, DWORD PTR _newx$[ebp]
	push	0
	push	eax
	call	_new_vertex
	mov	ecx, DWORD PTR _simhashtable
	mov	DWORD PTR [edi+ecx+8], eax

; 546  :   set_attr(newv,get_vattr(v1)&get_vattr(v2));

	mov	ecx, DWORD PTR _web+12
	mov	ebx, DWORD PTR [ebx+ecx]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	edi, eax
	mov	DWORD PTR _newv$[ebp], eax
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edx+edi]
	mov	edx, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+12]
	and	edx, DWORD PTR [ecx+8]
	and	ebx, DWORD PTR [ecx+12]
	or	DWORD PTR [eax+8], edx
	or	DWORD PTR [eax+12], ebx

; 547  : 
; 548  :   get_v_common_conmap(v1,v2,conmap,MAXCONPER);

	mov	ecx, DWORD PTR _v2$GSCopy$[ebp]
	mov	edx, DWORD PTR _v1$GSCopy$[ebp]
	push	23					; 00000017H
	lea	eax, DWORD PTR _conmap$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_get_v_common_conmap

; 549  :   set_v_conmap(newv,conmap);

	mov	ecx, DWORD PTR _newv$[ebp]
	lea	eax, DWORD PTR _conmap$[ebp]
	push	eax
	push	ecx
	call	_set_v_conmap

; 550  : 
; 551  :   if ( (get_vattr(v1)&BOUNDARY) && (get_boundary(v1) == get_boundary(v2)) )

	mov	edx, DWORD PTR _web+12
	mov	esi, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	add	esp, 32					; 00000020H
	or	eax, ecx
	je	SHORT $LN35@simplex_ed@2
	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN35@simplex_ed@2
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	ebx, DWORD PTR tv422[ebp]
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ecx, DWORD PTR [eax+esi]
	mov	ebx, DWORD PTR [ebx+edx]
	imul	ecx, 136				; 00000088H
	mov	ebx, DWORD PTR [ebx+eax]
	mov	esi, DWORD PTR _web+776
	imul	ebx, 136				; 00000088H
	add	ecx, esi
	add	esi, ebx
	cmp	ecx, esi
	jne	SHORT $LN35@simplex_ed@2

; 552  :      set_boundary_num(newv,get_boundary(v1)->num);

	mov	edx, DWORD PTR [edi+edx]
	mov	ecx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+edx], ecx
$LN35@simplex_ed@2:

; 553  :   hashentries++;

	mov	eax, DWORD PTR _hashentries
	inc	eax
	mov	DWORD PTR _hashentries, eax
	pop	edi

; 554  : 
; 555  :   /* see if simhashtable needs expanding */
; 556  :   if ( hashentries > maxload )

	cmp	eax, DWORD PTR _maxload
	jle	SHORT $LN1@simplex_ed@2

; 557  :      rehash();

	call	_rehash
$LN1@simplex_ed@2:

; 558  : 
; 559  :   return newv;

	mov	eax, DWORD PTR _newv$[ebp]
	pop	esi
	pop	ebx

; 560  : } // end simplex_edge_divide()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@simplex_ed@2:

; 532  :        return simhashtable[hash].divpt; /* found! */

	lea	edx, DWORD PTR [edx+edx*2]
	mov	eax, DWORD PTR [ecx+edx*4+8]

; 560  : } // end simplex_edge_divide()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_edge_divide ENDP
_TEXT	ENDS
PUBLIC	__real@4024000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_refine_all_simplices
EXTRN	_reflevel:DWORD
EXTRN	_set_e_conmap:PROC
EXTRN	_new_edge:PROC
EXTRN	_machine_eps:QWORD
_BSS	SEGMENT
_slist_edge DD	01H DUP (?)
_slist	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@4024000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\simplex.c
CONST	ENDS
;	COMDAT _refine_all_simplices
_TEXT	SEGMENT
_attr$ = -200						; size = 8
tv157 = -196						; size = 4
tv2065 = -192						; size = 4
tv1737 = -192						; size = 4
tv1813 = -188						; size = 4
tv1739 = -188						; size = 4
tv1092 = -188						; size = 4
tv2058 = -184						; size = 4
tv868 = -184						; size = 4
_i$ = -184						; size = 4
tv1034 = -180						; size = 4
_f_id$ = -180						; size = 4
_e_id$ = -176						; size = 4
_flip$ = -176						; size = 4
_sortval$ = -172					; size = 56
_vlist$ = -116						; size = 112
__$ArrayPad$ = -4					; size = 4
_refine_all_simplices PROC				; COMDAT

; 580  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 581  :   facet_id f_id;
; 582  :   edge_id e_id;
; 583  :   int i,j;
; 584  :   vertex_id vlist[(MAXCOORD+1)*(MAXCOORD+2)/2]; /* full list of vertices */
; 585  :   REAL sortval[MAXCOORD+1];
; 586  :   int svcount;
; 587  :   ATTR attr;
; 588  :   int flip; /* inversion counter */
; 589  : 
; 590  :   init_hash_table();  /* for subdivided edges */

	call	_init_hash_table

; 591  : 
; 592  :   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+272
	mov	edx, DWORD PTR _web+620
	mov	DWORD PTR _f_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	je	$LN50@refine_all
	npad	9
$LL104@refine_all:
	mov	esi, DWORD PTR _f_id$[ebp]
	mov	edi, DWORD PTR _web+236
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR tv868[ebp], esi
	je	$LN51@refine_all

; 593  :      {
; 594  :         vertex_id *v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR [esi+edi]
	mov	ecx, DWORD PTR _web+328
	mov	edi, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ecx+edi+304]
	add	ebx, eax

; 595  : 
; 596  :         attr = get_fattr(f_id);
; 597  :         if ( attr & NEWELEMENT ) continue;

	mov	eax, DWORD PTR [eax+8]
	and	eax, 4
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN51@refine_all

; 598  : 
; 599  :         /* transfer old vertices to start of full list */
; 600  :         /* sorting in geometric order, for adjacent subdivision consistency */
; 601  :         for ( svcount = 0,flip=0 ; svcount <= web.dimension ; svcount++ )

	xor	edi, edi
	mov	DWORD PTR _flip$[ebp], ecx
	test	edx, edx
	js	$LN135@refine_all
	lea	eax, DWORD PTR _vlist$[ebp]
	sub	eax, 8
	lea	esi, DWORD PTR _sortval$[ebp]
	sub	esi, 16					; 00000010H
	mov	DWORD PTR tv1737[ebp], eax
	mov	DWORD PTR tv1739[ebp], esi
$LL95@refine_all:

; 602  :         { /* insertion sort */
; 603  :           REAL sortv = SDIM_dot(sort_vector,get_coord(v[svcount]))
; 604  :              + 10*machine_eps * loc_ordinal(v[svcount]); 

	mov	eax, DWORD PTR [ebx+edi*4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN55@refine_all
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	DWORD PTR tv157[ebp], edx
	jmp	SHORT $LN56@refine_all
$LN55@refine_all:
	mov	DWORD PTR tv157[ebp], -1
$LN56@refine_all:
	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	push	ecx
	mov	ecx, DWORD PTR _web+104
	add	eax, DWORD PTR [ecx+edx+64]
	push	eax
	push	OFFSET _sort_vector
	call	_dot
	fld	QWORD PTR _machine_eps
	fmul	QWORD PTR __real@4024000000000000
	add	esp, 12					; 0000000cH

; 605  :           for ( i = svcount ; i > 0 ; i-- )

	mov	ecx, edi
	fimul	DWORD PTR tv157[ebp]
	faddp	ST(1), ST(0)
	cmp	edi, 4
	jl	$LC89@refine_all

; 602  :         { /* insertion sort */
; 603  :           REAL sortv = SDIM_dot(sort_vector,get_coord(v[svcount]))
; 604  :              + 10*machine_eps * loc_ordinal(v[svcount]); 

	mov	edx, esi
	mov	esi, DWORD PTR tv1737[ebp]

; 605  :           for ( i = svcount ; i > 0 ; i-- )

$LN94@refine_all:

; 606  :              if ( sortval[i-1] > sortv ) 

	fcom	QWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 5
	jp	$LN40@refine_all

; 607  :                 {vlist[i] = vlist[i-1]; sortval[i] = sortval[i-1]; flip++;}

	fld	QWORD PTR [edx+8]
	mov	eax, DWORD PTR [esi+4]
	fstp	QWORD PTR [edx+16]
	mov	DWORD PTR [esi+8], eax
	fcom	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 5
	jp	$LN91@refine_all
	fld	QWORD PTR [edx]
	mov	eax, DWORD PTR [esi]
	fstp	QWORD PTR [edx+8]
	mov	DWORD PTR [esi+4], eax
	fcom	QWORD PTR [edx-8]
	fnstsw	ax
	test	ah, 5
	jp	$LN92@refine_all
	fld	QWORD PTR [edx-8]
	mov	eax, DWORD PTR [esi-4]
	fstp	QWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	fcom	QWORD PTR [edx-16]
	fnstsw	ax
	test	ah, 5
	jp	$LN93@refine_all
	mov	eax, DWORD PTR [esi-8]
	fld	QWORD PTR [edx-16]
	add	DWORD PTR _flip$[ebp], 4
	fstp	QWORD PTR [edx-8]
	mov	DWORD PTR [esi-4], eax
	sub	ecx, 4
	sub	esi, 16					; 00000010H
	sub	edx, 32					; 00000020H
	cmp	ecx, 3
	jg	SHORT $LN94@refine_all
$LC89@refine_all:

; 605  :           for ( i = svcount ; i > 0 ; i-- )

	test	ecx, ecx
	jle	SHORT $LN40@refine_all
	mov	esi, DWORD PTR _flip$[ebp]
	lea	edx, DWORD PTR _sortval$[ebp+ecx*8-8]
$LC43@refine_all:

; 606  :              if ( sortval[i-1] > sortv ) 

	fcom	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN108@refine_all

; 607  :                 {vlist[i] = vlist[i-1]; sortval[i] = sortval[i-1]; flip++;}

	mov	eax, DWORD PTR _vlist$[ebp+ecx*4-4]
	fld	QWORD PTR [edx]
	mov	DWORD PTR _vlist$[ebp+ecx*4], eax
	fstp	QWORD PTR [edx+8]
	dec	ecx
	inc	esi
	sub	edx, 8
	test	ecx, ecx
	jg	SHORT $LC43@refine_all
$LN108@refine_all:
	mov	DWORD PTR _flip$[ebp], esi
$LN40@refine_all:

; 608  :              else break;
; 609  :           vlist[i] = v[svcount];

	mov	edx, DWORD PTR [ebx+edi*4]

; 610  :           sortval[i] = sortv;

	fstp	QWORD PTR _sortval$[ebp+ecx*8]
	mov	esi, DWORD PTR tv1739[ebp]
	add	DWORD PTR tv1737[ebp], 4
	mov	DWORD PTR _vlist$[ebp+ecx*4], edx
	mov	edx, DWORD PTR _web+620
	inc	edi
	add	esi, 8
	mov	DWORD PTR tv1739[ebp], esi
	cmp	edi, edx
	jle	$LL95@refine_all

; 611  :         }
; 612  : 
; 613  :         /* go through edges, subdividing */
; 614  :         for ( i = 0 ; i < web.dimension ; i++ )

	test	edx, edx
$LN135@refine_all:
	jle	SHORT $LN36@refine_all
	mov	esi, 1
	mov	DWORD PTR tv1813[ebp], esi
	lea	ebx, DWORD PTR _vlist$[ebp]
$LL38@refine_all:

; 615  :           for ( j = i+1 ; j <= web.dimension ; j++ )

	cmp	esi, edx
	jg	SHORT $LN37@refine_all
$LL35@refine_all:

; 616  :              vlist[svcount++] = simplex_edge_divide(vlist[i],vlist[j]);

	mov	eax, DWORD PTR _vlist$[ebp+esi*4]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	push	ecx
	call	_simplex_edge_divide
	mov	edx, DWORD PTR _web+620
	mov	DWORD PTR _vlist$[ebp+edi*4], eax
	inc	esi
	add	esp, 8
	inc	edi
	cmp	esi, edx
	jle	SHORT $LL35@refine_all

; 615  :           for ( j = i+1 ; j <= web.dimension ; j++ )

	mov	esi, DWORD PTR tv1813[ebp]
$LN37@refine_all:

; 611  :         }
; 612  : 
; 613  :         /* go through edges, subdividing */
; 614  :         for ( i = 0 ; i < web.dimension ; i++ )

	inc	esi
	lea	eax, DWORD PTR [esi-1]
	add	ebx, 4
	mov	DWORD PTR tv1813[ebp], esi
	cmp	eax, edx
	jl	SHORT $LL38@refine_all
$LN36@refine_all:

; 617  : 
; 618  :         /* construct new simplices using pre-computed decomposition */
; 619  :         /* copy relevant properties of old facet */
; 620  :         set_attr(f_id,NEWELEMENT); /* so don't repeat refinement */

	mov	ecx, DWORD PTR _f_id$[ebp]
	mov	esi, DWORD PTR tv868[ebp]
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	eax, DWORD PTR [edx+esi]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 4
	mov	DWORD PTR [eax+12], ecx

; 621  :         for ( i = 0 ; i < (1<<web.dimension) ; i++ )

	mov	edx, DWORD PTR _web+620
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	xor	edi, edi
	test	eax, eax
	jle	$LN51@refine_all
	mov	ebx, DWORD PTR _flip$[ebp]
	and	ebx, 1
$LL107@refine_all:

; 622  :           { facet_id newf;
; 623  :              if ( i == 0 ) newf = f_id;    /* re-use old facet */

	test	edi, edi
	jne	SHORT $LN29@refine_all
	mov	eax, DWORD PTR _f_id$[ebp]
	jmp	SHORT $LN28@refine_all
$LN91@refine_all:

; 606  :              if ( sortval[i-1] > sortv ) 

	dec	ecx
	inc	DWORD PTR _flip$[ebp]
	jmp	$LN40@refine_all
$LN92@refine_all:
	sub	ecx, 2
	add	DWORD PTR _flip$[ebp], 2
	jmp	$LN40@refine_all
$LN93@refine_all:
	sub	ecx, 3
	add	DWORD PTR _flip$[ebp], 3
	jmp	$LN40@refine_all
$LN29@refine_all:

; 624  :              else newf = dup_facet(f_id);

	mov	ecx, DWORD PTR _f_id$[ebp]
	push	ecx
	call	_dup_facet
	mov	edx, DWORD PTR _web+620
	add	esp, 4
$LN28@refine_all:

; 625  :              v = get_facet_vertices(newf);

	mov	ecx, DWORD PTR _web+236
	mov	esi, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [esi+ecx+304]

; 626  :              for ( j = 0 ; j <= web.dimension ; j++ )

	xor	ecx, ecx
	test	edx, edx
	js	SHORT $LN106@refine_all

; 625  :              v = get_facet_vertices(newf);

	mov	esi, DWORD PTR _slist
	lea	edx, DWORD PTR [edi*8]
	sub	edx, edi
	lea	esi, DWORD PTR [esi+edx*4]
	npad	7
$LL27@refine_all:

; 627  :                 v[j] = vlist[slist[i].pt[j]];

	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR _vlist$[ebp+edx*4]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	edx, DWORD PTR _web+620
	inc	ecx
	add	esi, 4
	cmp	ecx, edx
	jle	SHORT $LL27@refine_all
$LN106@refine_all:

; 628  :              if ( flip & 1 )  /* restore orientation */

	test	ebx, ebx
	je	SHORT $LN31@refine_all

; 629  :              { vertex_id tmpv = v[0]; v[0] = v[1]; v[1] = tmpv; }

	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR _web+620
$LN31@refine_all:

; 621  :         for ( i = 0 ; i < (1<<web.dimension) ; i++ )

	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	inc	edi
	cmp	edi, eax
	jl	$LL107@refine_all
	mov	esi, DWORD PTR tv868[ebp]
$LN51@refine_all:

; 591  : 
; 592  :   FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+236
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _f_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL104@refine_all
$LN50@refine_all:

; 630  :           }
; 631  :      }
; 632  : 
; 633  : 
; 634  :   FOR_ALL_EDGES(e_id)

	mov	esi, DWORD PTR _web+160
	mov	DWORD PTR _e_id$[ebp], esi
	test	esi, 268435456				; 10000000H
	je	$LN21@refine_all
	jmp	SHORT $LN23@refine_all
	npad	7
$LL98@refine_all:
	mov	esi, DWORD PTR _e_id$[ebp]
$LN23@refine_all:
	mov	edi, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR tv1034[ebp], esi
	je	$LN22@refine_all

; 635  :      {
; 636  :         vertex_id *v = get_edge_vertices(e_id);

	mov	eax, DWORD PTR [edi+esi]
	mov	ecx, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ecx+edi+304]

; 637  : 
; 638  :         attr = get_eattr(e_id);

	mov	ecx, DWORD PTR [eax+8]
	add	ebx, eax
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _attr$[ebp+4], eax

; 639  :         if ( attr & NEWELEMENT ) continue;

	mov	eax, ecx
	mov	DWORD PTR _attr$[ebp], ecx
	and	eax, 4
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN22@refine_all

; 640  : 
; 641  :         /* transfer old vertices to start of full list */
; 642  :         for ( svcount = 0 ; svcount < web.dimension ; svcount++ )

	xor	edi, edi
	test	edx, edx
	jle	SHORT $LN17@refine_all
	mov	ecx, edx
	mov	esi, ebx
	lea	edi, DWORD PTR _vlist$[ebp]
	rep movsd
	mov	esi, DWORD PTR tv1034[ebp]
	mov	edi, edx
$LN17@refine_all:

; 643  :           vlist[svcount] = v[svcount];
; 644  : 
; 645  :         /* go through edges, subdividing */
; 646  :         for ( i = 0 ; i < web.dimension-1 ; i++ )

	lea	ecx, DWORD PTR [edx-1]
	test	ecx, ecx
	jle	SHORT $LN12@refine_all
	mov	esi, 1
	mov	DWORD PTR tv2058[ebp], esi
	mov	DWORD PTR tv2065[ebp], ebx
$LL105@refine_all:

; 647  :           for ( j = i+1 ; j < web.dimension ; j++ )

	cmp	esi, edx
	jge	SHORT $LN13@refine_all
	npad	5
$LL101@refine_all:

; 648  :              vlist[svcount++] = simplex_edge_divide(v[i],v[j]);

	mov	edx, DWORD PTR [ebx+esi*4]
	mov	eax, DWORD PTR tv2065[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	ecx
	call	_simplex_edge_divide
	mov	edx, DWORD PTR _web+620
	mov	DWORD PTR _vlist$[ebp+edi*4], eax
	inc	esi
	add	esp, 8
	inc	edi
	cmp	esi, edx
	jl	SHORT $LL101@refine_all

; 647  :           for ( j = i+1 ; j < web.dimension ; j++ )

	mov	esi, DWORD PTR tv2058[ebp]
$LN13@refine_all:

; 643  :           vlist[svcount] = v[svcount];
; 644  : 
; 645  :         /* go through edges, subdividing */
; 646  :         for ( i = 0 ; i < web.dimension-1 ; i++ )

	add	DWORD PTR tv2065[ebp], 4
	inc	esi
	lea	eax, DWORD PTR [edx-1]
	lea	ecx, DWORD PTR [esi-1]
	mov	DWORD PTR tv2058[ebp], esi
	cmp	ecx, eax
	jl	SHORT $LL105@refine_all
	mov	esi, DWORD PTR tv1034[ebp]
$LN12@refine_all:

; 649  : 
; 650  :         /* construct new edge simplices using pre-computed decomposition */
; 651  :         /* copy relevant properties of old facet */
; 652  :         attr |= NEWELEMENT;  /* so don't repeat refinement */

	mov	eax, DWORD PTR _attr$[ebp+4]
	or	DWORD PTR _attr$[ebp], 4
	mov	DWORD PTR _attr$[ebp+4], eax

; 653  :         for ( i = 0 ; i < (1<<(web.dimension-1)) ; i++ )

	lea	ecx, DWORD PTR [edx-1]
	mov	eax, 1
	shl	eax, cl
	xor	ebx, ebx
	mov	DWORD PTR _i$[ebp], ebx
	test	eax, eax
	jle	$LN22@refine_all
	mov	eax, DWORD PTR _e_id$[ebp]
	shr	eax, 29					; 0000001dH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 4
	lea	edx, DWORD PTR _web[ecx+12]
	mov	DWORD PTR tv1092[ebp], edx
$LL100@refine_all:

; 654  :           { edge_id newedge;
; 655  :              if ( i == 0 ) newedge = e_id;    /* re-use old facet */

	test	ebx, ebx
	jne	SHORT $LN5@refine_all
	mov	eax, DWORD PTR _e_id$[ebp]
	jmp	SHORT $LN4@refine_all
$LN5@refine_all:

; 656  :              else newedge = new_edge(NULLID,NULLID,NULLID);

	push	0
	push	0
	push	0
	call	_new_edge
	add	esp, 12					; 0000000cH
$LN4@refine_all:

; 657  :              set_attr(newedge,attr);

	mov	edi, DWORD PTR _attr$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	lea	edx, DWORD PTR _web[edx+12]
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [ecx+esi]
	or	DWORD PTR [ecx+8], edi
	mov	edi, DWORD PTR _attr$[ebp+4]
	or	DWORD PTR [ecx+12], edi

; 658  :              set_original(newedge,get_original(e_id));

	mov	ecx, DWORD PTR tv1092[ebp]
	mov	edi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1034[ebp]
	mov	edi, DWORD PTR [ecx+edi]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+esi]
	mov	edi, DWORD PTR [edi+20]
	mov	DWORD PTR [edx+20], edi

; 659  :              set_e_conmap(newedge,get_e_constraint_map(e_id));

	mov	edx, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	cmp	DWORD PTR [edx+edi+1048], 0
	je	SHORT $LN57@refine_all
	mov	ebx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ebx+ecx]
	add	ecx, DWORD PTR [edx+edi+1024]
	mov	ebx, DWORD PTR _i$[ebp]
	jmp	SHORT $LN58@refine_all
$LN57@refine_all:
	mov	ecx, OFFSET _nullcon
$LN58@refine_all:
	push	ecx
	push	eax
	call	_set_e_conmap

; 660  :              v = get_edge_vertices(newedge);

	mov	eax, DWORD PTR _web+124
	mov	esi, DWORD PTR [esi+eax]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	add	esi, DWORD PTR [ecx+edx+304]

; 661  :              for ( j = 0 ; j < web.dimension ; j++ )

	mov	edx, DWORD PTR _web+620
	add	esp, 8
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN7@refine_all

; 659  :              set_e_conmap(newedge,get_e_constraint_map(e_id));

	mov	edx, DWORD PTR _slist_edge
	lea	ecx, DWORD PTR [ebx*8]
	sub	ecx, ebx
	lea	ecx, DWORD PTR [edx+ecx*4]
$LL3@refine_all:

; 662  :                 v[j] = vlist[slist_edge[i].pt[j]];

	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR _vlist$[ebp+edx*4]
	mov	DWORD PTR [esi+eax*4], edx
	mov	edx, DWORD PTR _web+620
	inc	eax
	add	ecx, 4
	cmp	eax, edx
	jl	SHORT $LL3@refine_all
$LN7@refine_all:

; 653  :         for ( i = 0 ; i < (1<<(web.dimension-1)) ; i++ )

	lea	ecx, DWORD PTR [edx-1]
	mov	eax, 1
	shl	eax, cl
	inc	ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, eax
	jl	$LL100@refine_all
	mov	esi, DWORD PTR tv1034[ebp]
$LN22@refine_all:

; 630  :           }
; 631  :      }
; 632  : 
; 633  : 
; 634  :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _e_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL98@refine_all
$LN21@refine_all:

; 663  :           }
; 664  :      }
; 665  : 
; 666  :   end_hash_table();

	call	_end_hash_table

; 667  : 
; 668  :   reflevel++;
; 669  : } // end refine_all_simplices()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	inc	DWORD PTR _reflevel
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_refine_all_simplices ENDP
_TEXT	ENDS
PUBLIC	_simplex_tiny_edges
EXTRN	_top_timestamp:DWORD
EXTRN	_global_timestamp:DWORD
; Function compile flags: /Ogtp
;	COMDAT _simplex_tiny_edges
_TEXT	SEGMENT
tv484 = -40						; size = 4
tv506 = -36						; size = 4
tv525 = -32						; size = 4
_k$ = -28						; size = 4
tv890 = -24						; size = 4
_fv$90212 = -20						; size = 4
_del$90217 = -16					; size = 4
_delcount$ = -12					; size = 4
_j$ = -8						; size = 4
tv1149 = -4						; size = 4
_min_len$ = 8						; size = 8
_simplex_tiny_edges PROC				; COMDAT

; 1219 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1220 :   int delcount = 0;  /* number of edges divided */
; 1221 :   int i,j,k;
; 1222 :   facet_id f_id;
; 1223 : 
; 1224 :   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+272
	xor	ecx, ecx
	mov	DWORD PTR _delcount$[ebp], ecx
	test	eax, 268435456				; 10000000H
	je	$LN37@simplex_ti
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _web+616
	npad	12
$LL42@simplex_ti:
	mov	esi, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR [edx+esi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR tv484[ebp], edx
	je	$LN18@simplex_ti

; 1225 :   { vertex_id *fv = get_facet_vertices(f_id);

	mov	eax, DWORD PTR [edx+esi]
	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR [ecx+edx+304]
	add	esi, eax

; 1226 :      int del;
; 1227 : 
; 1228 :      /* check it really exists */
; 1229 :      if ( !(get_fattr(f_id) & ALLOCATED) ) continue; 

	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR _fv$90212[ebp], esi
	je	$LN18@simplex_ti

; 1230 :      /* pairs of edges */
; 1231 :      del = 0;

	mov	DWORD PTR _del$90217[ebp], ecx

; 1232 :      for ( i = 0 ; i <= web.dimension ; i++ )

	mov	ecx, DWORD PTR _web+620
	xor	eax, eax
	test	ecx, ecx
	js	$LN18@simplex_ti

; 1230 :      /* pairs of edges */
; 1231 :      del = 0;

	mov	DWORD PTR tv1149[ebp], esi
$LL13@simplex_ti:

; 1232 :      for ( i = 0 ; i <= web.dimension ; i++ )

	inc	eax

; 1233 :      { for ( j = i+1 ; j <= web.dimension ; j++ )

	mov	ebx, eax
	mov	DWORD PTR tv506[ebp], eax
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, ecx
	jg	$LN35@simplex_ti
	jmp	SHORT $LN10@simplex_ti
	npad	6
$LL41@simplex_ti:
	mov	ebx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _fv$90212[ebp]
$LN10@simplex_ti:

; 1234 :           { REAL *x = get_coord(fv[i]);

	mov	eax, DWORD PTR tv1149[ebp]

; 1235 :              REAL *y = get_coord(fv[j]);
; 1236 :              REAL dist;
; 1237 :              for ( k = 0, dist = 0.0 ; k < SDIM ; k++ )

	fldz
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _web+104
	mov	ebx, DWORD PTR [esi+ebx*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax+64]
	mov	edx, ecx
	mov	ecx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+esi*4]
	add	edx, eax
	add	ecx, eax
	xor	esi, esi
	mov	DWORD PTR tv525[ebp], ebx
	cmp	edi, 4
	jl	SHORT $LC33@simplex_ti

; 1238 :                 dist += (x[k]-y[k])*(x[k]-y[k]);

	add	edi, -4					; fffffffcH
	mov	ebx, edx
	sub	ebx, ecx
	shr	edi, 2
	mov	DWORD PTR tv890[ebp], ebx
	inc	edi
	lea	ebx, DWORD PTR [edi*4]
	mov	DWORD PTR _k$[ebp], ebx
	mov	ebx, DWORD PTR tv890[ebp]
	lea	esi, DWORD PTR [edx+24]
	lea	eax, DWORD PTR [ecx+8]
$LN34@simplex_ti:
	fld	QWORD PTR [esi-24]
	add	eax, 32					; 00000020H
	fsub	QWORD PTR [eax-40]
	add	esi, 32					; 00000020H
	dec	edi
	fld	QWORD PTR [eax+ebx-32]
	fsub	QWORD PTR [eax-32]
	fld	QWORD PTR [esi-40]
	fsub	QWORD PTR [eax-24]
	fld	QWORD PTR [esi-32]
	fsub	QWORD PTR [eax-16]
	fld	ST(3)
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	faddp	ST(4), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(3)
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LN34@simplex_ti

; 1234 :           { REAL *x = get_coord(fv[i]);

	mov	esi, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR _web+616
	mov	ebx, DWORD PTR tv525[ebp]
$LC33@simplex_ti:

; 1235 :              REAL *y = get_coord(fv[j]);
; 1236 :              REAL dist;
; 1237 :              for ( k = 0, dist = 0.0 ; k < SDIM ; k++ )

	cmp	esi, edi
	jge	SHORT $LN32@simplex_ti
	lea	eax, DWORD PTR [ecx+esi*8]
	sub	edx, ecx
	mov	ecx, edi
	sub	ecx, esi
$LC7@simplex_ti:

; 1238 :                 dist += (x[k]-y[k])*(x[k]-y[k]);

	fld	QWORD PTR [eax+edx]
	add	eax, 8
	dec	ecx
	fsub	QWORD PTR [eax-8]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LC7@simplex_ti
$LN32@simplex_ti:

; 1239 :              dist = sqrt(dist);

	call	__CIsqrt

; 1240 :              if ( dist >= min_len ) continue;

	fcomp	QWORD PTR _min_len$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN9@simplex_ti

; 1241 :               /* now delete */
; 1242 :              del = simplex_delete_edge(fv[i],fv[j]);

	mov	eax, DWORD PTR tv1149[ebp]
	mov	eax, DWORD PTR [eax]
	push	ebx
	push	eax
	call	_simplex_delete_edge

; 1243 :              delcount += del;

	add	DWORD PTR _delcount$[ebp], eax

; 1244 :              if ( del ) break;

	mov	edi, DWORD PTR _web+616
	add	esp, 8
	mov	DWORD PTR _del$90217[ebp], eax
	test	eax, eax
	jne	SHORT $LN18@simplex_ti
$LN9@simplex_ti:

; 1233 :      { for ( j = i+1 ; j <= web.dimension ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _web+620
	jle	$LL41@simplex_ti

; 1245 :           }
; 1246 :          if ( del ) break;

	cmp	DWORD PTR _del$90217[ebp], 0
	jne	SHORT $LN18@simplex_ti
	mov	eax, DWORD PTR tv506[ebp]
	mov	ecx, DWORD PTR _web+620
	mov	esi, DWORD PTR _fv$90212[ebp]
$LN35@simplex_ti:

; 1232 :      for ( i = 0 ; i <= web.dimension ; i++ )

	add	DWORD PTR tv1149[ebp], 4
	cmp	eax, ecx
	jle	$LL13@simplex_ti
$LN18@simplex_ti:

; 1220 :   int delcount = 0;  /* number of edges divided */
; 1221 :   int i,j,k;
; 1222 :   facet_id f_id;
; 1223 : 
; 1224 :   FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR tv484[ebp]
	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL42@simplex_ti

; 1247 :       }
; 1248 :   }
; 1249 :   if ( delcount ) top_timestamp = ++global_timestamp;

	mov	ecx, DWORD PTR _delcount$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN37@simplex_ti
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN37@simplex_ti:

; 1250 :   return delcount;

	mov	eax, ecx

; 1251 : } // end simplex_tiny_edges()

	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_tiny_edges ENDP
_TEXT	ENDS
PUBLIC	_rhs$GSCopy$
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_hessian
; Function compile flags: /Ogtp
;	COMDAT _simplex_hessian
_TEXT	SEGMENT
_v$90419 = -120						; size = 24
_p1$ = -96						; size = 4
tv985 = -92						; size = 4
_p2$ = -88						; size = 4
_S$GSCopy$ = -84					; size = 4
tv390 = -80						; size = 4
_v_id$90420 = -76					; size = 4
_rhs$GSCopy$ = -72					; size = 4
_first$ = -68						; size = 4
_second$ = -64						; size = 4
tv919 = -60						; size = 4
tv814 = -60						; size = 4
tv994 = -56						; size = 4
tv927 = -56						; size = 4
tv419 = -56						; size = 4
_i$ = -56						; size = 4
_g$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_rhs$ = 12						; size = 4
_simplex_hessian PROC					; COMDAT

; 1367 : { REAL **first;

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR _S$[ebp]
	push	ebx
	push	esi
	push	edi

; 1368 :   REAL ****second;
; 1369 :   REAL **p1,**p2;
; 1370 :   int i,j,k;
; 1371 :   int head,tail;
; 1372 :   edge_id e_id;
; 1373 :   REAL g[MAXCOORD]; /* projected to constraint */
; 1374 : 
; 1375 :   /* do facets */
; 1376 :   simplex_facet_hessian(S,rhs);

	push	ecx
	push	eax

; 1377 : 
; 1378 :   /* do edges */
; 1379 :   first = dmatrix(0,web.dimension-1,0,SDIM-1);

	mov	DWORD PTR _S$GSCopy$[ebp], eax

; 1397 :     
; 1398 :         /* first derivatives on right hand side */
; 1399 :         for ( i = 0 ; i < web.dimension ; i++ )

	mov	DWORD PTR _rhs$GSCopy$[ebp], ecx
	call	_simplex_facet_hessian
	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _web+620
	push	1379					; 00000563H
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	dec	eax
	push	eax
	push	0
	dec	ecx
	push	ecx
	push	0
	call	_kb_dmatrix
	push	1380					; 00000564H
	mov	edi, eax
	mov	eax, DWORD PTR _web+616
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	eax
	push	eax
	mov	eax, DWORD PTR _web+620
	push	eax
	push	eax
	mov	DWORD PTR _first$[ebp], edi
	call	_kb_dmatrix4
	push	1381					; 00000565H
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	5
	push	0
	mov	ebx, eax
	push	5
	push	0
	mov	DWORD PTR _second$[ebp], ebx
	call	_kb_dmatrix
	add	esp, 80					; 00000050H
	push	1382					; 00000566H
	push	OFFSET ??_C@_09KCJNGMFK@SIMPLEX?4C?$AA@
	push	5
	push	0
	push	5
	push	0
	mov	DWORD PTR _p1$[ebp], eax
	call	_kb_dmatrix
	mov	esi, DWORD PTR _web+160
	add	esp, 24					; 00000018H
	mov	DWORD PTR _p2$[ebp], eax
	test	esi, 268435456				; 10000000H
	je	$LN31@simplex_he

; 1380 :   second = dmatrix4(web.dimension,web.dimension,SDIM,SDIM);
; 1381 :   p1 = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);
; 1382 :   p2 = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);
; 1383 : 
; 1384 :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+620
$LL33@simplex_he:
	mov	edx, DWORD PTR _web+124
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv390[ebp], edi
	je	$LN32@simplex_he

; 1385 :      {  
; 1386 :         struct hess_verlist *v[MAXCOORD];
; 1387 :         vertex_id *v_id = get_edge_vertices(e_id);

	mov	eax, DWORD PTR _web+216
	mov	ebx, DWORD PTR _dymem
	mov	edi, DWORD PTR [eax+ebx+304]
	add	edi, edx

; 1388 : 
; 1389 :         for ( i = 0 ; i < web.dimension ; i++ )

	xor	eax, eax
	mov	DWORD PTR _v_id$90420[ebp], edi
	test	ecx, ecx
	jle	SHORT $LN26@simplex_he
	mov	edx, DWORD PTR _vhead_attr
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+ebx+64]
	mov	DWORD PTR tv419[ebp], edx
	mov	edx, edi
	lea	edi, DWORD PTR _v$90419[ebp]
	sub	edx, edi
	npad	10
$LL56@simplex_he:

; 1390 :           v[i] = get_vertex_vhead(v_id[i]);

	mov	ebx, DWORD PTR _web+12
	lea	edi, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR _v$90419[ebp+edi]
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR tv419[ebp]
	mov	edi, DWORD PTR [ebx+edi]
	shl	edi, 5
	add	edi, DWORD PTR _vhead
	inc	eax
	mov	DWORD PTR _v$90419[ebp+eax*4-4], edi
	cmp	eax, ecx
	jl	SHORT $LL56@simplex_he
$LN26@simplex_he:

; 1391 : 
; 1392 :         memset((char*)first[0],0,sizeof(REAL)*web.dimension*SDIM);

	imul	ecx, DWORD PTR _web+616
	mov	edi, DWORD PTR _first$[ebp]
	mov	eax, DWORD PTR [edi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	0
	push	eax
	call	_memset

; 1393 :         memset((char*)second[0][0][0],0,sizeof(REAL)*
; 1394 :             web.dimension*web.dimension*SDIM*SDIM);

	mov	eax, DWORD PTR _web+620
	imul	eax, eax
	mov	ebx, DWORD PTR _second$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR [ebx]
	imul	ecx, eax
	imul	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	mov	ecx, DWORD PTR [eax]
	push	0
	push	ecx
	call	_memset

; 1395 : 
; 1396 :         simplex_edge_hessian(e_id,first,second);

	push	ebx
	push	edi
	push	esi
	call	_simplex_edge_hessian

; 1397 :     
; 1398 :         /* first derivatives on right hand side */
; 1399 :         for ( i = 0 ; i < web.dimension ; i++ )

	mov	ecx, DWORD PTR _web+620
	xor	ebx, ebx
	add	esp, 36					; 00000024H
	mov	DWORD PTR _i$[ebp], ebx
	test	ecx, ecx
	jle	$LN23@simplex_he
	lea	edx, DWORD PTR _v$90419[ebp]
	sub	edi, edx
	mov	DWORD PTR tv814[ebp], edi
	jmp	SHORT $LN25@simplex_he
	npad	2
$LL59@simplex_he:
	mov	edi, DWORD PTR tv814[ebp]
$LN25@simplex_he:

; 1400 :           {
; 1401 :              if ( v[i]->proj )

	mov	esi, DWORD PTR _v$90419[ebp+ebx*4]
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN22@simplex_he

; 1402 :                 { vec_mat_mul(first[i],v[i]->proj,g,SDIM,v[i]->freedom);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _web+616
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _g$[ebp]
	push	ecx
	push	eax
	lea	edx, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR _v$90419[ebp+edx]
	push	eax
	call	_vec_mat_mul

; 1403 :                   for ( k = 0 ; k < v[i]->freedom ; k++ )

	xor	eax, eax
	add	esp, 20					; 00000014H
	cmp	DWORD PTR [esi+8], eax
	jle	SHORT $LN54@simplex_he

; 1404 :                      rhs[v[i]->rownum+k] -= g[k];

	mov	edi, DWORD PTR _rhs$GSCopy$[ebp]
	mov	edx, esi
	npad	6
$LL21@simplex_he:
	mov	ecx, DWORD PTR [esi+12]
	add	ecx, eax
	fld	QWORD PTR [edi+ecx*8]
	lea	ecx, DWORD PTR [edi+ecx*8]
	fsub	QWORD PTR _g$[ebp+eax*8]
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+8]
	jl	SHORT $LL21@simplex_he

; 1405 :                 }
; 1406 :              else

	jmp	SHORT $LN54@simplex_he
$LN22@simplex_he:

; 1407 :                 for ( k = 0 ; k < v[i]->freedom ; k++ )

	xor	eax, eax
	cmp	DWORD PTR [esi+8], eax
	jle	SHORT $LN24@simplex_he

; 1397 :     
; 1398 :         /* first derivatives on right hand side */
; 1399 :         for ( i = 0 ; i < web.dimension ; i++ )

	mov	edx, DWORD PTR tv814[ebp]
	lea	ecx, DWORD PTR [edx+ebx*4]

; 1407 :                 for ( k = 0 ; k < v[i]->freedom ; k++ )

	mov	edx, DWORD PTR _v$90419[ebp+ecx]
	mov	edi, esi
	npad	4
$LL17@simplex_he:

; 1408 :                      rhs[v[i]->rownum+k] -= first[i][k];

	mov	ecx, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR _rhs$GSCopy$[ebp]
	add	ecx, eax
	fld	QWORD PTR [ebx+ecx*8]
	lea	ecx, DWORD PTR [ebx+ecx*8]
	fsub	QWORD PTR [edx]
	inc	eax
	add	edx, 8
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR [edi+8]
	jl	SHORT $LL17@simplex_he

; 1407 :                 for ( k = 0 ; k < v[i]->freedom ; k++ )

	mov	ebx, DWORD PTR _i$[ebp]
$LN54@simplex_he:

; 1405 :                 }
; 1406 :              else

	mov	ecx, DWORD PTR _web+620
$LN24@simplex_he:

; 1397 :     
; 1398 :         /* first derivatives on right hand side */
; 1399 :         for ( i = 0 ; i < web.dimension ; i++ )

	inc	ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, ecx
	jl	$LL59@simplex_he
$LN23@simplex_he:

; 1409 :           }
; 1410 :         /* second derivatives */
; 1411 :         for ( i = 0 ; i < web.dimension ; i++ )

	xor	ebx, ebx
	test	ecx, ecx
	jle	$LN55@simplex_he
	mov	eax, DWORD PTR _v_id$90420[ebp]
	lea	edx, DWORD PTR _v$90419[ebp]
	sub	edx, eax
	mov	DWORD PTR tv919[ebp], eax
	mov	DWORD PTR tv994[ebp], edx
	npad	8
$LL14@simplex_he:

; 1412 :           for ( j = i ; j < web.dimension ; j++ )

	mov	esi, ebx
	cmp	ebx, ecx
	jge	$LN13@simplex_he
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR tv985[ebp], edx
	mov	edi, eax
$LL60@simplex_he:

; 1413 :           {
; 1414 :              if ( (v[i]->freedom==0) || (v[j]->freedom==0) ) continue;

	mov	edx, DWORD PTR tv985[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN10@simplex_he
	mov	edx, DWORD PTR tv994[ebp]
	mov	edx, DWORD PTR [edx+edi]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN10@simplex_he

; 1415 :              if ( loc_ordinal(v_id[i]) > loc_ordinal(v_id[j]) )

	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN36@simplex_he
	and	eax, 134217727				; 07ffffffH
	mov	ecx, eax
	jmp	SHORT $LN37@simplex_he
$LN36@simplex_he:
	or	ecx, -1
$LN37@simplex_he:
	mov	eax, DWORD PTR [edi]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN38@simplex_he
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN39@simplex_he
$LN38@simplex_he:
	or	eax, -1
$LN39@simplex_he:
	cmp	ecx, eax
	jle	SHORT $LN6@simplex_he

; 1416 :                  { tail = i; head = j; }

	mov	eax, ebx
	mov	ecx, esi
	jmp	SHORT $LN5@simplex_he
$LN6@simplex_he:

; 1417 :              else { tail = j; head = i; }

	mov	eax, esi
	mov	ecx, ebx
$LN5@simplex_he:

; 1418 : 
; 1419 :              fill_mixed_entry(S,v_id[tail],v_id[head],second[tail][head]);

	mov	edx, DWORD PTR _second$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [edx+ecx*4]
	push	edx
	mov	edx, DWORD PTR _v_id$90420[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	push	ecx
	push	edx
	push	eax
	call	_fill_mixed_entry
	mov	ecx, DWORD PTR _web+620
	mov	eax, DWORD PTR tv919[ebp]
	add	esp, 16					; 00000010H
$LN10@simplex_he:

; 1412 :           for ( j = i ; j < web.dimension ; j++ )

	inc	esi
	add	edi, 4
	cmp	esi, ecx
	jl	SHORT $LL60@simplex_he
	mov	edx, DWORD PTR tv994[ebp]
$LN13@simplex_he:

; 1409 :           }
; 1410 :         /* second derivatives */
; 1411 :         for ( i = 0 ; i < web.dimension ; i++ )

	inc	ebx
	add	eax, 4
	mov	DWORD PTR tv919[ebp], eax
	cmp	ebx, ecx
	jl	$LL14@simplex_he
$LN55@simplex_he:
	mov	edi, DWORD PTR tv390[ebp]
$LN32@simplex_he:

; 1380 :   second = dmatrix4(web.dimension,web.dimension,SDIM,SDIM);
; 1381 :   p1 = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);
; 1382 :   p2 = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);
; 1383 : 
; 1384 :   FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [edi+edx]
	mov	esi, DWORD PTR [eax]
	test	esi, 268435456				; 10000000H
	jne	$LL33@simplex_he
	mov	ebx, DWORD PTR _second$[ebp]
	mov	edi, DWORD PTR _first$[ebp]
$LN31@simplex_he:

; 1420 :           }
; 1421 :       }
; 1422 :   if ( first ) free_matrix(first);

	test	edi, edi
	je	SHORT $LN4@simplex_he
	push	edi
	call	_free_matrix
	add	esp, 4
$LN4@simplex_he:

; 1423 :   if ( second ) free_matrix4(second);

	test	ebx, ebx
	je	SHORT $LN3@simplex_he
	push	ebx
	call	_free_matrix4
	add	esp, 4
$LN3@simplex_he:

; 1424 :   if ( p1 ) free_matrix(p1);

	mov	eax, DWORD PTR _p1$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN2@simplex_he
	push	eax
	call	_free_matrix
	add	esp, 4
$LN2@simplex_he:

; 1425 :   if ( p2 ) free_matrix(p2);

	mov	eax, DWORD PTR _p2$[ebp]
	test	eax, eax
	je	SHORT $LN1@simplex_he
	push	eax
	call	_free_matrix
	add	esp, 4
$LN1@simplex_he:

; 1426 : } // end simplex_hessian()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_hessian ENDP
_TEXT	ENDS
PUBLIC	_simplex_vector_integral_hess
; Function compile flags: /Ogtp
;	COMDAT _simplex_vector_integral_hess
_TEXT	SEGMENT
_f_info$ = 8						; size = 4
_simplex_vector_integral_hess PROC			; COMDAT

; 1656 : { return simplex_vector_integral_all(f_info,METHOD_HESSIAN);

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _f_info$[ebp]
	push	8763					; 0000223bH
	push	eax
	call	_simplex_vector_integral_all
	add	esp, 8

; 1657 : }

	pop	ebp
	ret	0
_simplex_vector_integral_hess ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@IKEACEKL@Simplex?5dimension?5must?5be?5betwee@ ; `string'
PUBLIC	_refine_simplex_init
_BSS	SEGMENT
_dim	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DD@IKEACEKL@Simplex?5dimension?5must?5be?5betwee@
CONST	SEGMENT
??_C@_0DD@IKEACEKL@Simplex?5dimension?5must?5be?5betwee@ DB 'Simplex dime'
	DB	'nsion must be between 1 and MAXCOORD.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _refine_simplex_init
_TEXT	SEGMENT
_refine_simplex_init PROC				; COMDAT

; 318  : 
; 319  :   dim = web.dimension;

	mov	eax, DWORD PTR _web+620
	mov	DWORD PTR _dim, eax

; 320  :   if ((dim < 1) || (dim > MAXCOORD) )

	cmp	eax, 1
	jl	SHORT $LN8@refine_sim@2
	cmp	eax, 6
	jle	SHORT $LN9@refine_sim@2
$LN8@refine_sim@2:

; 321  :      kb_error(1545,"Simplex dimension must be between 1 and MAXCOORD.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DD@IKEACEKL@Simplex?5dimension?5must?5be?5betwee@
	push	1545					; 00000609H
	call	_kb_error
	mov	eax, DWORD PTR _dim
	add	esp, 12					; 0000000cH
$LN9@refine_sim@2:

; 322  : 
; 323  :   switch ( web.dimension )

	mov	ecx, DWORD PTR _web+620
	dec	ecx
	cmp	ecx, 3
	ja	SHORT $LN1@refine_sim@2
	jmp	DWORD PTR $LN13@refine_sim@2[ecx*4]
$LN5@refine_sim@2:

; 324  :      { case 4: slist = slistmake(dim); slist_edge = slist3; break;

	push	eax
	call	_slistmake
	add	esp, 4
	mov	DWORD PTR _slist, eax
	mov	DWORD PTR _slist_edge, OFFSET _slist3

; 329  :      }
; 330  : }  // end refine_simplex_init()

	ret	0
$LN4@refine_sim@2:

; 325  :        case 3: slist = slist3; slist_edge = slist2; return; 

	mov	DWORD PTR _slist, OFFSET _slist3
	mov	DWORD PTR _slist_edge, OFFSET _slist2

; 329  :      }
; 330  : }  // end refine_simplex_init()

	ret	0
$LN3@refine_sim@2:

; 326  :        case 2: slist = slist2; slist_edge = slist1; return;

	mov	DWORD PTR _slist, OFFSET _slist2
	mov	DWORD PTR _slist_edge, OFFSET _slist1

; 329  :      }
; 330  : }  // end refine_simplex_init()

	ret	0
$LN2@refine_sim@2:

; 327  :        case 1: slist = slist1; slist_edge = slist1; return;

	mov	eax, OFFSET _slist1
	mov	DWORD PTR _slist, eax

; 328  :        default: slist = slistmake(dim); slist_edge = slistmake(dim-1);

	mov	DWORD PTR _slist_edge, eax

; 329  :      }
; 330  : }  // end refine_simplex_init()

	ret	0
$LN1@refine_sim@2:

; 328  :        default: slist = slistmake(dim); slist_edge = slistmake(dim-1);

	push	eax
	call	_slistmake
	mov	DWORD PTR _slist, eax
	mov	eax, DWORD PTR _dim
	dec	eax
	push	eax
	call	_slistmake
	add	esp, 8
	mov	DWORD PTR _slist_edge, eax

; 329  :      }
; 330  : }  // end refine_simplex_init()

	ret	0
	npad	1
$LN13@refine_sim@2:
	DD	$LN2@refine_sim@2
	DD	$LN3@refine_sim@2
	DD	$LN4@refine_sim@2
	DD	$LN5@refine_sim@2
_refine_simplex_init ENDP
_TEXT	ENDS
END
