; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\MODEL.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_baryhash_count:DWORD
COMM	_baryhash_table:DWORD
COMM	_baryhash_size:DWORD
COMM	_vpair_list:DWORD
COMM	_vpair_count:DWORD
_c_b19	DQ	04000000000000000r		; 2
_DATA	ENDS
PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_unset_attr
; Function compile flags: /Ogtp
;	COMDAT _unset_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_unset_attr PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 29   :   elptr(id)->attr &= ~attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	not	ecx
	and	DWORD PTR [eax+8], ecx
	not	edx
	and	DWORD PTR [eax+12], edx

; 30   : }

	pop	ebp
	ret	0
_unset_attr ENDP
_TEXT	ENDS
PUBLIC	_get_fe_edge
; Function compile flags: /Ogtp
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_prev_edge
EXTRN	_top_timestamp:DWORD
EXTRN	_global_timestamp:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_edge PROC					; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp

; 103  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_e

; 104  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_e

; 105  :     { invert(fe);
; 106  :       feptr(fe_id)->nextedge[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+32], ecx

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 111  : }

	pop	ebp
	ret	0
$LN2@set_prev_e:

; 107  :     }
; 108  :   else
; 109  :       feptr(fe_id)->nextedge[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_e:

; 111  : }

	pop	ebp
	ret	0
_set_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_set_next_edge
; Function compile flags: /Ogtp
;	COMDAT _set_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_edge PROC					; COMDAT

; 116  : {

	push	ebp
	mov	ebp, esp

; 117  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_e

; 118  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_e

; 119  :     { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 120  :       feptr(fe_id)->nextedge[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+28], ecx

; 124  : }

	pop	ebp
	ret	0
$LN2@set_next_e:

; 121  :     }
; 122  :   else
; 123  :       feptr(fe_id)->nextedge[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN1@set_next_e:

; 124  : }

	pop	ebp
	ret	0
_set_next_edge ENDP
_TEXT	ENDS
PUBLIC	_set_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _set_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_facet PROC					; COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp

; 130  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_f

; 131  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_f

; 132  :   { invert(fe);
; 133  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+40], ecx

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 138  : }

	pop	ebp
	ret	0
$LN2@set_prev_f:

; 134  :   }
; 135  :   else
; 136  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+36], eax

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_f:

; 138  : }

	pop	ebp
	ret	0
_set_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_set_next_facet
; Function compile flags: /Ogtp
;	COMDAT _set_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_facet PROC					; COMDAT

; 143  : {

	push	ebp
	mov	ebp, esp

; 144  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_f

; 145  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_f

; 146  :   { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 147  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+36], ecx

; 151  : }

	pop	ebp
	ret	0
$LN2@set_next_f:

; 148  :   }
; 149  :   else
; 150  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+40], eax
$LN1@set_next_f:

; 151  : }

	pop	ebp
	ret	0
_set_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _set_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_edge_fe PROC					; COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp

; 172  :   if ( inverted(e_id) ) invert(fe);

	mov	eax, DWORD PTR _e_id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN1@set_edge_f
	xor	DWORD PTR _fe$[ebp], 134217728		; 08000000H
$LN1@set_edge_f:

; 173  :   eptr(e_id)->fe_id = fe;

	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 174  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 175  : }

	pop	ebp
	ret	0
_set_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_set_edge_midv
; Function compile flags: /Ogtp
;	COMDAT _set_edge_midv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_v_id$ = 12						; size = 4
_set_edge_midv PROC					; COMDAT

; 241  : { get_edge_vertices(e_id)[2] = v_id;

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _e_id$[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+esi+304]
	mov	eax, DWORD PTR _v_id$[ebp]
	mov	DWORD PTR [ecx+esi+8], eax

; 242  :   set_vertex_edge(v_id,e_id);

	mov	esi, DWORD PTR _web+12
	mov	ecx, eax

; 243  :   set_attr(v_id,Q_MIDPOINT);

	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	esi, DWORD PTR [ecx+esi]
	mov	DWORD PTR [esi+28], edx
	mov	edx, DWORD PTR _web[eax+12]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 131072		; 00020000H
	mov	DWORD PTR [ecx+12], eax

; 244  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	esi

; 245  : }

	pop	ebp
	ret	0
_set_edge_midv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_adjust_integration_orders
EXTRN	_set_by_user_gauss_2D:DWORD
EXTRN	_set_by_user_gauss_1D:DWORD
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\model.c
;	COMDAT _adjust_integration_orders
_TEXT	SEGMENT
_l_order$ = 8						; size = 4
_adjust_integration_orders PROC				; COMDAT

; 26   : { int ord1,ord2;

	push	ebp
	mov	ebp, esp

; 27   :   
; 28   :   /* 2D orders actually implemented are 1,2,5,6,8,11,13,14,... */
; 29   : 
; 30   :   if ( l_order == 1 ) { ord1 = 3; ord2 = 3; }

	mov	eax, DWORD PTR _l_order$[ebp]
	cmp	eax, 1
	jne	SHORT $LN8@adjust_int
	mov	eax, 3
	jmp	SHORT $LN11@adjust_int
$LN8@adjust_int:

; 31   :   else if ( l_order == 2 ) { ord1 = 5; ord2 = 3; }

	cmp	eax, 2
	jne	SHORT $LN6@adjust_int
	mov	eax, 5
	lea	ecx, DWORD PTR [eax-2]
	jmp	SHORT $LN5@adjust_int
$LN6@adjust_int:

; 32   :   else { ord1 = 2*l_order; ord2 = 2*l_order; }

	add	eax, eax
$LN11@adjust_int:
	mov	ecx, eax
$LN5@adjust_int:

; 33   : 
; 34   :   if ( (web.gauss1D_order < ord1) || (set_by_user_gauss_1D < ord1) ) 

	cmp	DWORD PTR _web+1592, eax
	jl	SHORT $LN3@adjust_int
	cmp	DWORD PTR _set_by_user_gauss_1D, eax
	jge	SHORT $LN4@adjust_int
$LN3@adjust_int:

; 35   :         web.gauss1D_order = ord1;

	mov	DWORD PTR _web+1592, eax
$LN4@adjust_int:

; 36   :   if ( (web.gauss2D_order < ord2) || (set_by_user_gauss_2D < ord2) ) 

	cmp	DWORD PTR _web+1596, ecx
	jl	SHORT $LN1@adjust_int
	cmp	DWORD PTR _set_by_user_gauss_2D, ecx
	jge	SHORT $LN2@adjust_int
$LN1@adjust_int:

; 37   :         web.gauss2D_order = ord2;

	mov	DWORD PTR _web+1596, ecx
$LN2@adjust_int:

; 38   : } // end adjust_integration_orders()

	pop	ebp
	ret	0
_adjust_integration_orders ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_0BP@BNIHDOPC@Nonpositive?5dgamma_?5argument?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@ICDOPIJA@Noninteger?5dgamma_?5argument?4?6?$AA@ ; `string'
PUBLIC	_dgamma_
EXTRN	_kb_error:PROC
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_0BP@BNIHDOPC@Nonpositive?5dgamma_?5argument?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@BNIHDOPC@Nonpositive?5dgamma_?5argument?4?6?$AA@ DB 'Nonpositiv'
	DB	'e dgamma_ argument.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ICDOPIJA@Noninteger?5dgamma_?5argument?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@ICDOPIJA@Noninteger?5dgamma_?5argument?4?6?$AA@ DB 'Noninteger '
	DB	'dgamma_ argument.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _dgamma_
_TEXT	SEGMENT
tv264 = -4						; size = 4
tv370 = 8						; size = 4
tv367 = 8						; size = 4
tv365 = 8						; size = 4
tv363 = 8						; size = 4
tv361 = 8						; size = 4
tv359 = 8						; size = 4
_k$ = 8							; size = 4
_n$ = 8							; size = 4
_x$ = 8							; size = 4
_dgamma_ PROC						; COMDAT

; 1193 : { REAL b;

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi

; 1194 :   int n,k;
; 1195 : 
; 1196 :   n = (int)*x;

	mov	edi, DWORD PTR _x$[ebp]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	mov	esi, eax
	mov	DWORD PTR _n$[ebp], esi

; 1197 :   if ( *x != (REAL)n )

	fild	DWORD PTR _n$[ebp]
	fld	QWORD PTR [edi]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@dgamma_

; 1198 :     kb_error(1810,"Noninteger dgamma_ argument.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BO@ICDOPIJA@Noninteger?5dgamma_?5argument?4?6?$AA@
	push	1810					; 00000712H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN5@dgamma_:

; 1199 : 
; 1200 :   if ( n < 1 )

	cmp	esi, 1
	jge	SHORT $LN4@dgamma_

; 1201 :     kb_error(1811,"Nonpositive dgamma_ argument.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BP@BNIHDOPC@Nonpositive?5dgamma_?5argument?4?6?$AA@
	push	1811					; 00000713H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN4@dgamma_:

; 1202 : 
; 1203 :   for ( b = 1.0, k = 2 ; k < n ; k++ ) b *= k;

	fld1
	mov	ecx, 2
	mov	DWORD PTR _k$[ebp], ecx
	cmp	esi, ecx
	jle	SHORT $LN10@dgamma_
	lea	eax, DWORD PTR [esi-2]
	cmp	eax, 8
	jl	SHORT $LC11@dgamma_
	mov	eax, 4
	lea	edx, DWORD PTR [esi-7]
	mov	DWORD PTR tv264[ebp], eax
$LN12@dgamma_:
	fimul	DWORD PTR _k$[ebp]
	lea	edi, DWORD PTR [eax-1]
	mov	DWORD PTR tv370[ebp], edi
	fild	DWORD PTR tv370[ebp]
	lea	edi, DWORD PTR [eax+1]
	add	ecx, 8
	mov	DWORD PTR tv367[ebp], edi
	lea	edi, DWORD PTR [eax+2]
	fmulp	ST(1), ST(0)
	fimul	DWORD PTR tv264[ebp]
	fild	DWORD PTR tv367[ebp]
	mov	DWORD PTR tv365[ebp], edi
	lea	edi, DWORD PTR [eax+3]
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv365[ebp]
	mov	DWORD PTR tv363[ebp], edi
	lea	edi, DWORD PTR [eax+4]
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv363[ebp]
	mov	DWORD PTR tv361[ebp], edi
	lea	edi, DWORD PTR [eax+5]
	add	eax, 8
	fmulp	ST(1), ST(0)
	mov	DWORD PTR tv264[ebp], eax
	fild	DWORD PTR tv361[ebp]
	mov	DWORD PTR tv359[ebp], edi
	fmulp	ST(1), ST(0)
	fild	DWORD PTR tv359[ebp]
	mov	DWORD PTR _k$[ebp], ecx
	fmulp	ST(1), ST(0)
	cmp	ecx, edx
	jl	SHORT $LN12@dgamma_
$LC11@dgamma_:
	cmp	ecx, esi
	jge	SHORT $LN10@dgamma_
$LC3@dgamma_:
	fimul	DWORD PTR _k$[ebp]
	inc	ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ecx, esi
	jl	SHORT $LC3@dgamma_
$LN10@dgamma_:
	pop	edi
	pop	esi

; 1204 :   return b;
; 1205 : } // end dgamma_()

	mov	esp, ebp
	pop	ebp
	ret	0
_dgamma_ ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	_d1mach_
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _d1mach_
_TEXT	SEGMENT
_d1mach_ PROC						; COMDAT

; 1208 :   REAL eps;
; 1209 :   REAL one = 1.0;
; 1210 :   for ( eps = 1.0 ; one + eps != one ; eps /= 2.0 ) ;

	fld1
	fld	ST(0)
	fld	QWORD PTR __real@3fe0000000000000
$LN3@d1mach_:
	fmul	ST(1), ST(0)
	fld	ST(1)
	fadd	ST(0), ST(3)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@d1mach_
	fstp	ST(2)
	fstp	ST(1)

; 1211 :   return 2.0*eps;

	fadd	ST(0), ST(0)

; 1212 : } // end d1mach_()

	ret	0
_d1mach_ ENDP
_TEXT	ENDS
PUBLIC	_pow_dd
EXTRN	__CIpow:PROC
; Function compile flags: /Ogtp
;	COMDAT _pow_dd
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_pow_dd	PROC						; COMDAT

; 1215 : { REAL a =  pow(*x,*y); 

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	fld	QWORD PTR [eax]
	fld	QWORD PTR [ecx]
	fxch	ST(1)

; 1216 :   return  a;
; 1217 : } // end pow_dd()

	pop	ebp

; 1215 : { REAL a =  pow(*x,*y); 

	jmp	__CIpow
_pow_dd	ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_d_sign
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _d_sign
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_d_sign	PROC						; COMDAT

; 1220 : {

	push	ebp
	mov	ebp, esp

; 1221 :   REAL x;
; 1222 :   x = (*a >= 0. ? *a : - *a);

	fldz
	mov	ecx, DWORD PTR _a$[ebp]
	fcom	QWORD PTR [ecx]
	fnstsw	ax
	fld	QWORD PTR [ecx]
	test	ah, 65					; 00000041H
	jnp	SHORT $LN4@d_sign
	fchs
$LN4@d_sign:

; 1223 :   return( *b >= 0. ? x : -x);

	mov	eax, DWORD PTR _b$[ebp]
	fxch	ST(1)
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN6@d_sign
	fchs
$LN6@d_sign:

; 1224 : } // end d_sign()

	pop	ebp
	ret	0
_d_sign	ENDP
_TEXT	ENDS
PUBLIC	_solve_
; Function compile flags: /Ogtp
;	COMDAT _solve_
_TEXT	SEGMENT
tv645 = 8						; size = 4
_shift$ = 8						; size = 4
tv512 = 12						; size = 4
_n$ = 12						; size = 4
_a$ = 16						; size = 4
_b$ = 20						; size = 4
_solve_	PROC						; COMDAT

; 1420 : {

	push	ebp
	mov	ebp, esp

; 1421 :      /* System generated locals */
; 1422 :      integer i__1;
; 1423 :      doublereal ret_val, d__1;
; 1424 : 
; 1425 :      /* Local variables */
; 1426 :      integer i;
; 1427 :      doublereal alpha;
; 1428 :      integer nm1;
; 1429 : 
; 1430 : 
; 1431 : /*         this procedure performs elimination to solve for the */
; 1432 : /*         n-th component of the solution delta to the equation */
; 1433 : 
; 1434 : /*                 (jn - shift*identity) * delta  = en, */
; 1435 : 
; 1436 : /*         where en is the vector of all zeroes except for 1 in */
; 1437 : /*         the n-th position. */
; 1438 : 
; 1439 : /*         the matrix jn is symmetric tridiagonal, with diagonal */
; 1440 : /*         elements a(i), off-diagonal elements b(i).  this equation */
; 1441 : /*         must be solved to obtain the appropriate changes in the lower */
; 1442 : /*         2 by 2 submatrix of coefficients for orthogonal polynomials. */
; 1443 : 
; 1444 : 
; 1445 : 
; 1446 :      /* Parameter adjustments */
; 1447 :      --b;
; 1448 :      --a;
; 1449 : 
; 1450 :      /* Function Body */
; 1451 :      alpha = a[1] - *shift;
; 1452 :      nm1 = *n - 1;

	mov	eax, DWORD PTR _n$[ebp]
	sub	DWORD PTR _b$[ebp], 8
	mov	ecx, DWORD PTR _shift$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _a$[ebp]
	fld	QWORD PTR [ebx]
	push	esi
	fsub	QWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [eax]
	sub	ebx, 8
	dec	edi

; 1453 :      i__1 = nm1;
; 1454 :      for (i = 2; i <= i__1; ++i) {

	mov	esi, 2
	mov	DWORD PTR _a$[ebp], ebx
	cmp	edi, esi
	jl	$LN8@solve_
	lea	edx, DWORD PTR [edi-1]
	cmp	edx, 4
	jl	SHORT $LC9@solve_

; 1458 :           alpha = a[i] - *shift - d__1 * d__1 / alpha;

	mov	eax, DWORD PTR _b$[ebp]
	lea	edx, DWORD PTR [ebx+40]
	sub	ebx, DWORD PTR _b$[ebp]
	lea	esi, DWORD PTR [edi-1]
	add	eax, 24					; 00000018H
	shr	esi, 2
	mov	DWORD PTR tv645[ebp], esi
	mov	DWORD PTR tv512[ebp], ebx
	lea	esi, DWORD PTR [esi*4+2]
	jmp	SHORT $LN10@solve_
$LN11@solve_:
	mov	ebx, DWORD PTR tv512[ebp]

; 1453 :      i__1 = nm1;
; 1454 :      for (i = 2; i <= i__1; ++i) {

$LN10@solve_:

; 1455 : /* L10: */
; 1456 : /* Computing 2nd power */
; 1457 :           d__1 = b[i - 1];

	fld	QWORD PTR [eax-16]

; 1458 :           alpha = a[i] - *shift - d__1 * d__1 / alpha;

	add	eax, 32					; 00000020H
	fld	QWORD PTR [edx-24]
	add	edx, 32					; 00000020H
	dec	DWORD PTR tv645[ebp]
	fsub	QWORD PTR [ecx]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fdivrp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	fld	QWORD PTR [eax-40]
	fld	QWORD PTR [ebx+eax-32]
	fsub	QWORD PTR [ecx]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fdivrp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	fld	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fsub	QWORD PTR [ecx]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fdivrp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	fld	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fsub	QWORD PTR [ecx]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fdivrp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	jne	SHORT $LN11@solve_
	mov	ebx, DWORD PTR _a$[ebp]
$LC9@solve_:

; 1453 :      i__1 = nm1;
; 1454 :      for (i = 2; i <= i__1; ++i) {

	cmp	esi, edi
	jg	SHORT $LN8@solve_
	mov	eax, DWORD PTR _b$[ebp]
	lea	eax, DWORD PTR [eax+esi*8-8]
$LC3@solve_:

; 1455 : /* L10: */
; 1456 : /* Computing 2nd power */
; 1457 :           d__1 = b[i - 1];

	fld	QWORD PTR [eax]
	inc	esi

; 1458 :           alpha = a[i] - *shift - d__1 * d__1 / alpha;

	fld	QWORD PTR [ebx+esi*8-8]
	add	eax, 8
	fsub	QWORD PTR [ecx]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fdivrp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	cmp	esi, edi
	jle	SHORT $LC3@solve_
$LN8@solve_:

; 1459 :      }
; 1460 :      ret_val = 1. / alpha;

	fld1
	pop	edi
	pop	esi
	fdivrp	ST(1), ST(0)
	pop	ebx

; 1461 :      return ret_val;
; 1462 : } /* solve_ */

	pop	ebp
	ret	0
_solve_	ENDP
_TEXT	ENDS
PUBLIC	__real@4000000000000000
PUBLIC	__real@4010000000000000
PUBLIC	_class_
EXTRN	__CIsqrt:PROC
EXTRN	__CIatan:PROC
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _class_
_TEXT	SEGMENT
tv792 = -40						; size = 8
_d__3$ = -40						; size = 8
tv793 = -32						; size = 8
_d__2$ = -32						; size = 8
_ab$ = -24						; size = 8
tv364 = -16						; size = 8
_a2b2$ = -16						; size = 8
_d__1$ = -16						; size = 8
_abi$ = -8						; size = 8
tv536 = 8						; size = 4
_kind$ = 8						; size = 4
tv325 = 12						; size = 4
_n$ = 12						; size = 4
_alpha$ = 16						; size = 4
_beta$ = 20						; size = 4
_i$ = 24						; size = 4
_b$ = 24						; size = 4
_a$ = 28						; size = 4
_muzero$ = 32						; size = 4
_class_	PROC						; COMDAT

; 1475 : {

	push	ebp
	mov	ebp, esp

; 1476 :      /* System generated locals */
; 1477 :      integer i__1;
; 1478 :      doublereal d__1, d__2, d__3;
; 1479 : 
; 1480 : 
; 1481 :      /* Local variables */
; 1482 :      integer i;
; 1483 :      doublereal ab;
; 1484 :      doublereal pi;
; 1485 :      integer nm1;
; 1486 :      doublereal a2b2, abi;
; 1487 : 
; 1488 : 
; 1489 : /*              this procedure supplies the coefficients a(j), b(j) of the */
; 1490 : /*          recurrence relation */
; 1491 : 
; 1492 : /*                 b p (x) = (x - a ) p    (x) - b    p    (x) */
; 1493 : /*                  j j                j    j-1         j-1 j-2 */
; 1494 : 
; 1495 : /*          for the various classical (normalized) orthogonal polynomials, 
; 1496 : */
; 1497 : /*          and the zero-th moment */
; 1498 : 
; 1499 : /*                 muzero = integral w(x) dx */
; 1500 : 
; 1501 : /*          of the given polynomial's weight function w(x).  since the */
; 1502 : /*          polynomials are orthonormalized, the tridiagonal matrix is */
; 1503 : /*          guaranteed to be symmetric. */
; 1504 : 
; 1505 : /*              the input parameter alpha is used only for laguerre and */
; 1506 : /*          jacobi polynomials, and the parameter beta is used only for */
; 1507 : /*          jacobi polynomials.  the laguerre and jacobi polynomials */
; 1508 : /*          require the gamma function. */
; 1509 : 
; 1510 : 
; 1511 :      /* Parameter adjustments */
; 1512 :      --a;
; 1513 :      --b;
; 1514 : 
; 1515 :      /* Function Body */
; 1516 :      pi = atan(1.) * 4.;

	fld1
	sub	esp, 40					; 00000028H
	push	ebx
	mov	ebx, DWORD PTR _a$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _b$[ebp]
	sub	ebx, 8
	mov	DWORD PTR _a$[ebp], ebx
	sub	edi, 8
	call	__CIatan
	fmul	QWORD PTR __real@4010000000000000

; 1517 :      nm1 = *n - 1;
; 1518 :      switch ((int)*kind) {

	mov	eax, DWORD PTR _kind$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx]
	dec	eax
	dec	esi
	cmp	eax, 5
	ja	$LN48@class_
	jmp	DWORD PTR $LN66@class_[eax*4]
$L20$90324:

; 1541 : 
; 1542 : /*                  kind = 2:  chebyshev polynomials of the first kind t(x) */
; 1543 : /*                  on (-1, +1), w(x) = 1 / sqrt(1 - x*x) */
; 1544 : 
; 1545 : L20:
; 1546 :      *muzero = pi;

	mov	ecx, DWORD PTR _muzero$[ebp]
	fstp	QWORD PTR [ecx]

; 1547 :      i__1 = nm1;
; 1548 :      for (i = 1; i <= i__1; ++i) {

	fldz
	fld	QWORD PTR __real@3fe0000000000000
	cmp	esi, 1
	jl	SHORT $LN58@class_

; 1549 :           a[i] = 0.;

	mov	ecx, ebx
	lea	eax, DWORD PTR [edi+8]
	sub	ecx, edi
$LN15@class_:
	fxch	ST(1)
	add	eax, 8
	dec	esi
	fst	QWORD PTR [ecx+eax-8]

; 1550 : /* L21: */
; 1551 :           b[i] = .5;

	fxch	ST(1)
	fst	QWORD PTR [eax-8]
	jne	SHORT $LN15@class_
$LN58@class_:

; 1547 :      i__1 = nm1;
; 1548 :      for (i = 1; i <= i__1; ++i) {

	fstp	ST(1)

; 1552 :      }
; 1553 :      b[1] = sqrt(.5);

	call	__CIsqrt
	fstp	QWORD PTR [edi+8]

; 1554 :      a[*n] = 0.;

	mov	edx, DWORD PTR _n$[ebp]
	fldz
	mov	eax, DWORD PTR [edx]
	fstp	QWORD PTR [ebx+eax*8]
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1629 :      return 0;
; 1630 : } /* class_ */

	mov	esp, ebp
	pop	ebp
	ret	0
$L30$90326:

; 1555 :      return 0;
; 1556 : 
; 1557 : /*                  kind = 3:  chebyshev polynomials of the second kind u(x) 
; 1558 : */
; 1559 : /*                  on (-1, +1), w(x) = sqrt(1 - x*x) */
; 1560 : 
; 1561 : L30:
; 1562 :      *muzero = pi / 2.;

	fld	QWORD PTR __real@3fe0000000000000
	mov	ecx, DWORD PTR _muzero$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [ecx]

; 1563 :      i__1 = nm1;
; 1564 :      for (i = 1; i <= i__1; ++i) {

	fldz
	cmp	esi, 1
	jl	SHORT $LN60@class_

; 1565 :           a[i] = 0.;

	mov	ecx, ebx
	lea	eax, DWORD PTR [edi+8]
	sub	ecx, edi
	jmp	SHORT $LN12@class_
$LN64@class_:

; 1563 :      i__1 = nm1;
; 1564 :      for (i = 1; i <= i__1; ++i) {

	fxch	ST(1)
$LN12@class_:

; 1565 :           a[i] = 0.;

	fst	QWORD PTR [eax+ecx]
	add	eax, 8
	dec	esi

; 1566 : /* L31: */
; 1567 :           b[i] = .5;

	fxch	ST(1)
	fst	QWORD PTR [eax-8]
	jne	SHORT $LN64@class_

; 1568 :      }
; 1569 :      a[*n] = 0.;

	mov	edx, DWORD PTR [edx]
	fstp	ST(0)
	pop	edi
	fstp	QWORD PTR [ebx+edx*8]
	pop	esi
	xor	eax, eax
	pop	ebx

; 1629 :      return 0;
; 1630 : } /* class_ */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN60@class_:

; 1568 :      }
; 1569 :      a[*n] = 0.;

	mov	edx, DWORD PTR [edx]
	fstp	ST(1)
	pop	edi
	fstp	QWORD PTR [ebx+edx*8]
	pop	esi
	xor	eax, eax
	pop	ebx

; 1629 :      return 0;
; 1630 : } /* class_ */

	mov	esp, ebp
	pop	ebp
	ret	0
$L40$90328:

; 1570 :      return 0;
; 1571 : 
; 1572 : /*                  kind = 4:  hermite polynomials h(x) on (-infinity, */
; 1573 : /*                  +infinity), w(x) = exp(-x**2) */
; 1574 : 
; 1575 : L40:
; 1576 :      *muzero = sqrt(pi);

	call	__CIsqrt
	mov	eax, DWORD PTR _muzero$[ebp]
	fstp	QWORD PTR [eax]

; 1577 :      i__1 = nm1;
; 1578 :      for (i = 1; i <= i__1; ++i) {

	mov	DWORD PTR _i$[ebp], 1
	cmp	esi, 1
	jl	SHORT $LN7@class_

; 1579 :           a[i] = 0.;

	mov	eax, DWORD PTR _a$[ebp]
	sub	eax, edi
	lea	ebx, DWORD PTR [edi+8]
	mov	DWORD PTR tv536[ebp], eax
	jmp	SHORT $LN9@class_
	npad	6
$LL41@class_:
	mov	eax, DWORD PTR tv536[ebp]
$LN9@class_:
	fldz
	fstp	QWORD PTR [ebx+eax]

; 1580 : /* L41: */
; 1581 :           b[i] = sqrt(i / 2.);

	fild	DWORD PTR _i$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	call	__CIsqrt
	fstp	QWORD PTR [ebx]
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	ebx, 8
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, esi
	jle	SHORT $LL41@class_

; 1577 :      i__1 = nm1;
; 1578 :      for (i = 1; i <= i__1; ++i) {

	mov	ebx, DWORD PTR _a$[ebp]
$LN7@class_:

; 1582 :      }
; 1583 :      a[*n] = 0.;

	mov	ecx, DWORD PTR _n$[ebp]
	fldz
	mov	edx, DWORD PTR [ecx]
	fstp	QWORD PTR [ebx+edx*8]
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1629 :      return 0;
; 1630 : } /* class_ */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@class_:

; 1584 :      return 0;
; 1585 : 
; 1586 : /*                  kind = 5:  jacobi polynomials p(alpha, beta)(x) on */
; 1587 : /*                  (-1, +1), w(x) = (1-x)**alpha + (1+x)**beta, alpha and */
; 1588 : /*                  beta greater than -1 */
; 1589 : 
; 1590 : L50:
; 1591 :      ab = *alpha + *beta;

	mov	ebx, DWORD PTR _alpha$[ebp]
	fstp	ST(0)
	mov	eax, DWORD PTR _beta$[ebp]
	fld	QWORD PTR [ebx]
	fadd	QWORD PTR [eax]
$L50$90330:
	fst	QWORD PTR _ab$[ebp]

; 1592 :      abi = ab + 2.;

	fld	QWORD PTR __real@4000000000000000
	fadd	ST(0), ST(1)
	fstp	QWORD PTR _abi$[ebp]

; 1593 :      d__1 = ab + 1.;

	fld1
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _d__1$[ebp]

; 1594 :      d__2 = *alpha + 1.;

	fld	QWORD PTR [ebx]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR _d__2$[ebp]

; 1595 :      d__3 = *beta + 1.;

	fadd	QWORD PTR [eax]

; 1596 :      *muzero = pow_dd(&c_b19, &d__1) * dgamma_(&d__2) * dgamma_(&d__3) / 
; 1597 :                 dgamma_(&abi);

	lea	eax, DWORD PTR _d__1$[ebp]
	push	eax
	push	OFFSET _c_b19
	fstp	QWORD PTR _d__3$[ebp]
	call	_pow_dd
	lea	ecx, DWORD PTR _d__2$[ebp]
	fstp	QWORD PTR tv364[ebp]
	push	ecx
	call	_dgamma_
	fmul	QWORD PTR tv364[ebp]
	lea	edx, DWORD PTR _d__3$[ebp]
	push	edx
	fstp	QWORD PTR tv793[ebp]
	call	_dgamma_
	fmul	QWORD PTR tv793[ebp]
	lea	eax, DWORD PTR _abi$[ebp]
	push	eax
	fstp	QWORD PTR tv792[ebp]
	call	_dgamma_
	fdivr	QWORD PTR tv792[ebp]
	mov	ecx, DWORD PTR _muzero$[ebp]

; 1598 :      a[1] = (*beta - *alpha) / abi;

	mov	eax, DWORD PTR _beta$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	add	esp, 20					; 00000014H
	fstp	QWORD PTR [ecx]
	fld	QWORD PTR [eax]
	fsub	QWORD PTR [ebx]
	fld	QWORD PTR _abi$[ebp]
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [edx+8]

; 1599 :      b[1] = sqrt((*alpha + 1.) * 4. * (*beta + 1.) / ((abi + 1.) * abi * abi));

	fld	QWORD PTR [ebx]
	fld1
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@4010000000000000
	fld	QWORD PTR [eax]
	fadd	ST(0), ST(2)
	fmulp	ST(1), ST(0)
	fld	ST(2)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fmulp	ST(2), ST(0)
	fdivrp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR [edi+8]

; 1600 :      a2b2 = *beta * *beta - *alpha * *alpha;

	mov	eax, DWORD PTR _beta$[ebp]
	fld	QWORD PTR [eax]

; 1601 :      i__1 = nm1;
; 1602 :      for (i = 2; i <= i__1; ++i) {

	mov	DWORD PTR _i$[ebp], 2
	fld	QWORD PTR [ebx]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _a2b2$[ebp]
	cmp	esi, 2
	jl	SHORT $LN4@class_
	mov	eax, DWORD PTR _a$[ebp]
	sub	eax, edi
	lea	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR tv536[ebp], eax
	jmp	SHORT $LN6@class_
$LL42@class_:
	mov	eax, DWORD PTR tv536[ebp]
$LN6@class_:

; 1603 :           abi = i * 2. + ab;

	fild	DWORD PTR _i$[ebp]

; 1604 :           a[i] = a2b2 / ((abi - 2.) * abi);
; 1605 : /* L51: */
; 1606 :           b[i] = sqrt(i * 4. * (i + *alpha) * (i + *beta) * (i + ab) / ((abi * 
; 1607 :                      abi - 1) * abi * abi));

	mov	ecx, DWORD PTR _alpha$[ebp]
	mov	edx, DWORD PTR _beta$[ebp]
	fld	ST(0)
	fld	QWORD PTR __real@4000000000000000
	fmul	ST(1), ST(0)
	fld	QWORD PTR _ab$[ebp]
	fadd	ST(2), ST(0)
	fld	ST(2)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fdivr	QWORD PTR _a2b2$[ebp]
	fstp	QWORD PTR [ebx+eax]
	fld	QWORD PTR [ecx]
	fadd	ST(0), ST(3)
	fld	ST(3)
	fmul	QWORD PTR __real@4010000000000000
	fmulp	ST(1), ST(0)
	fld	QWORD PTR [edx]
	fadd	ST(0), ST(4)
	fmulp	ST(1), ST(0)
	fxch	ST(3)
	faddp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	fld	ST(0)
	fmul	ST(0), ST(1)
	fsub	QWORD PTR __real@3ff0000000000000
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fdivp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR [ebx]
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	ebx, 8
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, esi
	jle	SHORT $LL42@class_
$LN4@class_:

; 1608 : /* ok so far */
; 1609 :      }
; 1610 :      abi = *n * 2. + ab;

	mov	eax, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv325[ebp], eax
	fild	DWORD PTR tv325[ebp]

; 1611 :      a[*n] = a2b2 / ((abi - 2.) * abi);

	mov	ecx, DWORD PTR _a$[ebp]
	fld	QWORD PTR __real@4000000000000000
	pop	edi
	pop	esi
	fmul	ST(1), ST(0)
	pop	ebx
	fxch	ST(1)
	fadd	QWORD PTR _ab$[ebp]
	fld	ST(0)
	fsubrp	ST(2), ST(0)
	fmulp	ST(1), ST(0)
	fdivr	QWORD PTR _a2b2$[ebp]
	fstp	QWORD PTR [ecx+eax*8]
	xor	eax, eax

; 1629 :      return 0;
; 1630 : } /* class_ */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@class_:

; 1612 :      return 0;
; 1613 : 
; 1614 : /*                  kind = 6:  laguerre polynomials l(alpha)(x) on */
; 1615 : /*                  (0, +infinity), w(x) = exp(-x) * x**alpha, alpha greater 
; 1616 : */
; 1617 : /*                  than -1. */
; 1618 : 
; 1619 : L60:
; 1620 :      d__1 = *alpha + 1.;

	mov	edx, DWORD PTR _alpha$[ebp]
	fstp	ST(0)
	fld	QWORD PTR [edx]

; 1621 :      *muzero = dgamma_(&d__1);

	lea	eax, DWORD PTR _d__1$[ebp]
	fadd	QWORD PTR __real@3ff0000000000000
	push	eax
$L60$90332:
	fstp	QWORD PTR _d__1$[ebp]
	call	_dgamma_
	mov	ecx, DWORD PTR _muzero$[ebp]
	add	esp, 4
	fstp	QWORD PTR [ecx]

; 1622 :      i__1 = nm1;
; 1623 :      for (i = 1; i <= i__1; ++i) {

	mov	DWORD PTR _i$[ebp], 1
	cmp	esi, 1
	jl	SHORT $LN1@class_
	mov	ecx, DWORD PTR _a$[ebp]
	sub	ecx, edi
	lea	ebx, DWORD PTR [edi+8]
	mov	DWORD PTR tv536[ebp], ecx
	jmp	SHORT $LN3@class_
$LL43@class_:
	mov	ecx, DWORD PTR tv536[ebp]
$LN3@class_:

; 1624 :           a[i] = i * 2. - 1. + *alpha;

	fild	DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _alpha$[ebp]
	fld	ST(0)
	fadd	ST(0), ST(1)
	fsub	QWORD PTR __real@3ff0000000000000
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [ebx+ecx]

; 1625 : /* L61: */
; 1626 :           b[i] = sqrt(i * (i + *alpha));

	fld	QWORD PTR [eax]
	fadd	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR [ebx]
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	ebx, 8
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, esi
	jle	SHORT $LL43@class_

; 1622 :      i__1 = nm1;
; 1623 :      for (i = 1; i <= i__1; ++i) {

	mov	ebx, DWORD PTR _a$[ebp]
$LN1@class_:

; 1627 :      }
; 1628 :      a[*n] = *n * 2. - 1 + *alpha;

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _alpha$[ebp]
	mov	DWORD PTR tv325[ebp], eax
	fild	DWORD PTR tv325[ebp]
	pop	edi
	pop	esi
	fadd	ST(0), ST(0)
	fsub	QWORD PTR __real@3ff0000000000000
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ebx+eax*8]
	xor	eax, eax
	pop	ebx

; 1629 :      return 0;
; 1630 : } /* class_ */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@class_:

; 1519 :           case 1:  goto L10;
; 1520 :           case 2:  goto L20;
; 1521 :           case 3:  goto L30;
; 1522 :           case 4:  goto L40;
; 1523 :           case 5:  goto L50;
; 1524 :           case 6:  goto L60;
; 1525 :      }
; 1526 : 
; 1527 : /*                  kind = 1:  legendre polynomials p(x) */
; 1528 : /*                  on (-1, +1), w(x) = 1. */
; 1529 : 
; 1530 : L10:
; 1531 :      *muzero = 2.;

	mov	eax, DWORD PTR _muzero$[ebp]
	fstp	ST(0)
	fld	QWORD PTR __real@4000000000000000
$L10$90322:
	fstp	QWORD PTR [eax]

; 1532 :      i__1 = nm1;
; 1533 :      for (i = 1; i <= i__1; ++i) {

	mov	DWORD PTR _i$[ebp], 1
	cmp	esi, 1
	jl	SHORT $LN16@class_

; 1534 :           a[i] = 0.;

	mov	eax, DWORD PTR _a$[ebp]
	sub	eax, edi
	lea	ebx, DWORD PTR [edi+8]
	mov	DWORD PTR tv536[ebp], eax
	jmp	SHORT $LN18@class_
$LL44@class_:
	mov	eax, DWORD PTR tv536[ebp]
$LN18@class_:
	fldz
	fstp	QWORD PTR [ebx+eax]

; 1535 :           abi = (doublereal) i;

	fild	DWORD PTR _i$[ebp]
	fst	QWORD PTR _abi$[ebp]

; 1536 : /* L11: */
; 1537 :           b[i] = abi / sqrt(abi * 4 * abi - 1.);

	fld	QWORD PTR __real@4010000000000000
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fsub	QWORD PTR __real@3ff0000000000000
	call	__CIsqrt
	fdivr	QWORD PTR _abi$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	ebx, 8
	mov	DWORD PTR _i$[ebp], eax
	fstp	QWORD PTR [ebx-8]
	cmp	eax, esi
	jle	SHORT $LL44@class_

; 1532 :      i__1 = nm1;
; 1533 :      for (i = 1; i <= i__1; ++i) {

	mov	edx, DWORD PTR _n$[ebp]
	mov	ebx, DWORD PTR _a$[ebp]
$LN16@class_:

; 1538 :      }
; 1539 :      a[*n] = 0.;

	fldz
	mov	ecx, DWORD PTR [edx]
	pop	edi
	fstp	QWORD PTR [ebx+ecx*8]
	pop	esi

; 1540 :      return 0;

	xor	eax, eax
	pop	ebx

; 1629 :      return 0;
; 1630 : } /* class_ */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN66@class_:
	DD	$LN48@class_
	DD	$L20$90324
	DD	$L30$90326
	DD	$L40$90328
	DD	$LN50@class_
	DD	$LN49@class_
_class_	ENDP
_TEXT	ENDS
PUBLIC	_gausq2_
; Function compile flags: /Ogtp
;	COMDAT _gausq2_
_TEXT	SEGMENT
_machep$ = -76						; size = 8
_b$ = -68						; size = 8
_f$ = -60						; size = 8
_s$ = -60						; size = 8
_p$ = -52						; size = 8
_c$ = -44						; size = 8
_g$ = -44						; size = 8
_r$ = -36						; size = 8
tv1840 = -32						; size = 4
tv1850 = -28						; size = 4
tv1948 = -24						; size = 4
_i__1$ = -20						; size = 4
_j$ = -16						; size = 4
_l$ = -12						; size = 4
tv2049 = -8						; size = 4
tv1274 = -4						; size = 4
_n$ = 8							; size = 4
_d$ = 12						; size = 4
tv2633 = 16						; size = 4
_e$ = 16						; size = 4
_z$ = 20						; size = 4
tv2646 = 24						; size = 4
_ierr$ = 24						; size = 4
_gausq2_ PROC						; COMDAT

; 1641 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 1642 :      /* System generated locals */
; 1643 :      integer i__1, i__2;
; 1644 :      doublereal d__1, d__2, d__3;
; 1645 : 
; 1646 :      /* Local variables */
; 1647 :      doublereal b, c, f, g;
; 1648 :      integer i, j, k, l, m;
; 1649 :      doublereal p, r, s;
; 1650 :      integer ii;
; 1651 :      doublereal machep;
; 1652 :      integer mml;
; 1653 : 
; 1654 : 
; 1655 : /*      this subroutine is a translation of an algol procedure, */
; 1656 : /*      num. math. 12, 377-383(1968) by martin and wilkinson, */
; 1657 : /*      as modified in num. math. 15, 450(1970) by dubrulle. */
; 1658 : /*      handbook for auto. comp., vol.ii-linear algebra, 241-248(1971). */
; 1659 : /*      this is a modified version of the 'eispack' routine imtql2. */
; 1660 : 
; 1661 : /*      this subroutine finds the eigenvalues and first components of the 
; 1662 : */
; 1663 : /*      eigenvectors of a symmetric tridiagonal matrix by the implicit ql 
; 1664 : */
; 1665 : /*      method. */
; 1666 : 
; 1667 : /*      on input: */
; 1668 : 
; 1669 : /*          n is the order of the matrix; */
; 1670 : 
; 1671 : /*          d contains the diagonal elements of the input matrix; */
; 1672 : 
; 1673 : /*          e contains the subdiagonal elements of the input matrix */
; 1674 : /*             in its first n-1 positions.  e(n) is arbitrary; */
; 1675 : 
; 1676 : /*          z contains the first row of the identity matrix. */
; 1677 : 
; 1678 : /*        on output: */
; 1679 : 
; 1680 : /*          d contains the eigenvalues in ascending order.  if an */
; 1681 : /*             error exit is made, the eigenvalues are correct but */
; 1682 : /*             unordered for indices 1, 2, ..., ierr-1; */
; 1683 : 
; 1684 : /*          e has been destroyed; */
; 1685 : 
; 1686 : /*          z contains the first components of the orthonormal eigenvectors 
; 1687 : */
; 1688 : /*             of the symmetric tridiagonal matrix.  if an error exit is */
; 1689 : /*             made, z contains the eigenvectors associated with the stored 
; 1690 : */
; 1691 : /*             eigenvalues; */
; 1692 : 
; 1693 : /*          ierr is set to */
; 1694 : /*             zero         for normal return, */
; 1695 : /*             j             if the j-th eigenvalue has not been */
; 1696 : /*                            determined after 30 iterations. */
; 1697 : 
; 1698 : /*      ------------------------------------------------------------------ 
; 1699 : */
; 1700 : 
; 1701 : 
; 1702 :      /* Parameter adjustments */
; 1703 :      --z;
; 1704 :      --e;

	mov	ecx, DWORD PTR _e$[ebp]

; 1705 :      --d;

	mov	edx, DWORD PTR _d$[ebp]
	sub	DWORD PTR _z$[ebp], 8
	sub	ecx, 8
	sub	edx, 8
	push	esi
	mov	DWORD PTR _e$[ebp], ecx
	mov	DWORD PTR _d$[ebp], edx

; 1706 : 
; 1707 :      /* Function Body */
; 1708 :      machep = d1mach_();

	call	_d1mach_
	fst	QWORD PTR _machep$[ebp]

; 1709 :      *ierr = 0;

	mov	eax, DWORD PTR _ierr$[ebp]

; 1710 :      if (*n == 1) {

	mov	esi, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR [esi]
	cmp	eax, 1
	je	$LN72@gausq2_

; 1711 :           goto L1001;
; 1712 :      }
; 1713 : 
; 1714 :      e[*n] = 0.;

	fldz
	push	ebx
	fstp	QWORD PTR [ecx+eax*8]
	push	edi

; 1715 :      i__1 = *n;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _i__1$[ebp], eax

; 1716 :      for (l = 1; l <= i__1; ++l) {

	mov	DWORD PTR _l$[ebp], 1
	cmp	eax, 1
	jl	$LN75@gausq2_
	fld1
	lea	eax, DWORD PTR [edx+8]
	sub	ecx, edx
	mov	DWORD PTR tv2049[ebp], eax
	mov	DWORD PTR tv1274[ebp], ecx
$LN68@gausq2_:

; 1717 :           j = 0;

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L105$90388
$LN138@gausq2_:

; 1784 :           goto L105;

	fxch	ST(1)
$L105$90388:

; 1718 : /*      :::::::::: look for small sub-diagonal element :::::::::: */
; 1719 : L105:
; 1720 :           i__2 = *n;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [ecx]

; 1721 :           for (m = l; m <= i__2; ++m) 

	mov	edi, DWORD PTR _l$[ebp]
	cmp	edi, ecx
	jg	$L120$90393
	mov	edx, ecx
	sub	edx, edi
	inc	edx
	cmp	edx, 4
	jl	$LC41@gausq2_
	mov	edx, DWORD PTR tv2049[ebp]
	mov	eax, DWORD PTR tv1274[ebp]
	lea	esi, DWORD PTR [eax+edx+24]
	lea	ebx, DWORD PTR [edi+2]
	add	edx, 8
$LN60@gausq2_:

; 1722 :           { if (m == *n) { goto L120; }

	cmp	edi, ecx
	je	$L120$90393

; 1723 :             if ((d__1 = e[m], fabs(d__1)) <= machep * ((d__2 = d[m], fabs(d__2))
; 1724 :                             + (d__3 = d[m + 1], fabs(d__3))))

	fld	QWORD PTR [edx]
	fabs
	fld	QWORD PTR [esi-24]
	fabs
	fld	QWORD PTR [edx-8]
	fabs
	fadd	ST(0), ST(2)
	fmul	ST(0), ST(4)
	fcompp
	fnstsw	ax
	test	ah, 1
	je	$LN89@gausq2_

; 1722 :           { if (m == *n) { goto L120; }

	lea	eax, DWORD PTR [ebx-1]
	cmp	eax, ecx
	je	$LN92@gausq2_

; 1723 :             if ((d__1 = e[m], fabs(d__1)) <= machep * ((d__2 = d[m], fabs(d__2))
; 1724 :                             + (d__3 = d[m + 1], fabs(d__3))))

	fld	QWORD PTR [edx+8]
	mov	eax, DWORD PTR tv1274[ebp]
	fabs
	fld	QWORD PTR [eax+edx]
	fabs
	fld	ST(1)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fmul	ST(0), ST(4)
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 1
	je	$LN92@gausq2_

; 1722 :           { if (m == *n) { goto L120; }

	cmp	ebx, ecx
	je	$LN98@gausq2_

; 1723 :             if ((d__1 = e[m], fabs(d__1)) <= machep * ((d__2 = d[m], fabs(d__2))
; 1724 :                             + (d__3 = d[m + 1], fabs(d__3))))

	fld	QWORD PTR [edx+16]
	fabs
	fld	QWORD PTR [esi-8]
	fabs
	fld	ST(1)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fmul	ST(0), ST(4)
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 1
	je	$LN98@gausq2_

; 1722 :           { if (m == *n) { goto L120; }

	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, ecx
	je	$LN104@gausq2_

; 1723 :             if ((d__1 = e[m], fabs(d__1)) <= machep * ((d__2 = d[m], fabs(d__2))
; 1724 :                             + (d__3 = d[m + 1], fabs(d__3))))

	fld	QWORD PTR [esi]
	fabs
	fld	QWORD PTR [edx+24]
	fabs
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	fcompp
	fnstsw	ax
	test	ah, 1
	je	$LN47@gausq2_

; 1721 :           for (m = l; m <= i__2; ++m) 

	add	edi, 4
	lea	eax, DWORD PTR [ecx-3]
	add	edx, 32					; 00000020H
	add	esi, 32					; 00000020H
	add	ebx, 4
	cmp	edi, eax
	jle	$LN60@gausq2_
$LC41@gausq2_:
	cmp	edi, ecx
	jg	SHORT $L120$90393
	mov	edx, DWORD PTR _d$[ebp]
	lea	edx, DWORD PTR [edx+edi*8]
$LN172@gausq2_:

; 1722 :           { if (m == *n) { goto L120; }

	je	SHORT $L120$90393

; 1723 :             if ((d__1 = e[m], fabs(d__1)) <= machep * ((d__2 = d[m], fabs(d__2))
; 1724 :                             + (d__3 = d[m + 1], fabs(d__3))))

	mov	eax, DWORD PTR tv1274[ebp]
	fld	QWORD PTR [edx+eax]
	fabs
	fld	QWORD PTR [edx+8]
	fabs
	fld	QWORD PTR [edx]
	fabs
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(3)
	fcompp
	fnstsw	ax
	test	ah, 1
	je	SHORT $L120$90393

; 1721 :           for (m = l; m <= i__2; ++m) 

	inc	edi
	add	edx, 8
	cmp	edi, ecx
	jle	SHORT $LN172@gausq2_
	jmp	SHORT $L120$90393
$LN92@gausq2_:

; 1722 :           { if (m == *n) { goto L120; }

	inc	edi
$LN89@gausq2_:

; 1723 :             if ((d__1 = e[m], fabs(d__1)) <= machep * ((d__2 = d[m], fabs(d__2))
; 1724 :                             + (d__3 = d[m + 1], fabs(d__3))))

	fstp	ST(0)
$L120$90393:

; 1725 :             { goto L120; }
; 1726 : /* L110: */
; 1727 :           }
; 1728 : 
; 1729 : L120:
; 1730 :           p = d[l];

	mov	eax, DWORD PTR tv2049[ebp]

; 1731 :           if (m == l) {

	mov	ecx, DWORD PTR _l$[ebp]
	fld	QWORD PTR [eax]
	fst	QWORD PTR _p$[ebp]
	cmp	edi, ecx
	je	$LN119@gausq2_

; 1732 :                 goto L240;
; 1733 :           }
; 1734 :           if (j == 30) {

	cmp	DWORD PTR _j$[ebp], 30			; 0000001eH
	fstp	ST(2)
	je	$LN122@gausq2_

; 1738 : /*      :::::::::: form shift :::::::::: */
; 1739 :           g = (d[l + 1] - p) / (e[l] * 2.);

	fld	QWORD PTR [eax+8]
	mov	ecx, DWORD PTR tv1274[ebp]
	fsubrp	ST(2), ST(0)
	inc	DWORD PTR _j$[ebp]
	fld	QWORD PTR [ecx+eax]
	fadd	ST(0), ST(0)
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _g$[ebp]

; 1740 :           r = sqrt(g * g + 1.);

	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR _r$[ebp]

; 1741 :           g = d[m] - p + e[l] / (g + d_sign(&r, &g));

	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR _g$[ebp]
	push	eax
	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	lea	esi, DWORD PTR [edx+edi*8]
	call	_d_sign
	fadd	QWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR tv2049[ebp]
	mov	edx, DWORD PTR tv1274[ebp]
	fdivr	QWORD PTR [edx+ecx]

; 1742 :           s = 1.;
; 1743 :           c = 1.;
; 1744 :           p = 0.;
; 1745 :           mml = m - l;

	mov	eax, edi
	sub	eax, DWORD PTR _l$[ebp]
	add	esp, 8
	fld	QWORD PTR [esi]
	fsub	QWORD PTR _p$[ebp]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _g$[ebp]
	fld1
	fld	ST(0)
	fld	ST(1)
	fldz
	fst	QWORD PTR _p$[ebp]

; 1746 : 
; 1747 : /*      :::::::::: for i=m-1 step -1 until l do -- :::::::::: */
; 1748 :           i__2 = mml;
; 1749 :           for (ii = 1; ii <= i__2; ++ii) {

	cmp	eax, 1
	jl	$LN125@gausq2_
	mov	ecx, DWORD PTR _z$[ebp]
	fstp	ST(0)
	lea	ebx, DWORD PTR [ecx+edi*8-8]
	mov	edx, ecx
	sub	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR tv1948[ebp], eax
	mov	DWORD PTR tv1840[ebp], ecx
	mov	ecx, DWORD PTR _e$[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv1850[ebp], ecx
	jmp	SHORT $LN12@gausq2_
$LN98@gausq2_:

; 1722 :           { if (m == *n) { goto L120; }

	add	edi, 2
	jmp	$LN89@gausq2_
$LN104@gausq2_:
	add	edi, 3
	jmp	$LN89@gausq2_
$LN47@gausq2_:

; 1723 :             if ((d__1 = e[m], fabs(d__1)) <= machep * ((d__2 = d[m], fabs(d__2))
; 1724 :                             + (d__3 = d[m + 1], fabs(d__3))))

	add	edi, 3
	jmp	$L120$90393
	npad	1
$LL134@gausq2_:

; 1735 :                 goto L1000;
; 1736 :           }
; 1737 :           ++j;

	mov	ecx, DWORD PTR tv1850[ebp]

; 1746 : 
; 1747 : /*      :::::::::: for i=m-1 step -1 until l do -- :::::::::: */
; 1748 :           i__2 = mml;
; 1749 :           for (ii = 1; ii <= i__2; ++ii) {

	fstp	ST(1)
	fxch	ST(3)
$LN12@gausq2_:

; 1750 :                 i = m - ii;
; 1751 :                 f = s * e[i];

	fld	QWORD PTR [ecx+ebx]
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _f$[ebp]

; 1752 :                 b = c * e[i];

	fld	QWORD PTR [ecx+ebx]
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _b$[ebp]

; 1753 :                 if (fabs(f) < fabs(g)) {

	fld	ST(0)
	fabs
	fld	ST(3)
	fabs
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN9@gausq2_

; 1761 :                 goto L160;
; 1762 : L150:
; 1763 :                 s = f / g;

	fdivrp	ST(2), ST(0)
$L150$90403:
	fxch	ST(1)
	fst	QWORD PTR _s$[ebp]

; 1764 :                 r = sqrt(s * s + 1.);

	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt

; 1765 :                 e[i + 1] = g * r;

	fld	QWORD PTR _g$[ebp]
	mov	edx, DWORD PTR tv1274[ebp]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi+edx]

; 1766 :                 c = 1. / r;

	fld1
	fld	ST(0)
	fdivrp	ST(2), ST(0)

; 1767 :                 s *= c;

	fld	ST(1)
	fmul	QWORD PTR _s$[ebp]
	jmp	SHORT $L160$90404
$LN9@gausq2_:

; 1754 :                      goto L150;
; 1755 :                 }
; 1756 :                 c = g / f;

	fdivp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _c$[ebp]

; 1757 :                 r = sqrt(c * c + 1.);

	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt

; 1758 :                 e[i + 1] = f * r;

	fld	QWORD PTR _f$[ebp]
	mov	eax, DWORD PTR tv1274[ebp]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi+eax]

; 1759 :                 s = 1. / r;

	fld1
	fld	ST(0)
	fdivrp	ST(2), ST(0)

; 1760 :                 c *= s;

	fld	QWORD PTR _c$[ebp]
	fmul	ST(0), ST(2)
	fxch	ST(2)
$L160$90404:

; 1768 : L160:
; 1769 :                 g = d[i + 1] - p;

	fld	QWORD PTR [esi]

; 1770 :                 r = (d[i] - g) * s + c * 2. * b;
; 1771 :                 p = s * r;
; 1772 :                 d[i + 1] = g + p;
; 1773 :                 g = c * r - b;
; 1774 : /*      :::::::::: form first component of vector :::::::::: */
; 1775 :                 f = z[i + 1];

	mov	eax, DWORD PTR tv1840[ebp]
	fsub	QWORD PTR _p$[ebp]
	add	esi, -8					; fffffff8H
	fld	QWORD PTR [esi]
	sub	ebx, 8
	dec	DWORD PTR tv1948[ebp]
	fsub	ST(0), ST(1)
	fmul	ST(0), ST(2)
	fld	ST(4)
	fadd	ST(0), ST(0)
	fld	QWORD PTR _b$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(2)
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	ST(0), ST(1)
	fst	QWORD PTR _p$[ebp]
	fadd	ST(3), ST(0)
	fxch	ST(3)
	fstp	QWORD PTR [esi+8]
	fmul	ST(0), ST(5)
	fsubrp	ST(1), ST(0)
	fst	QWORD PTR _g$[ebp]
	fld	QWORD PTR [eax+esi+8]

; 1776 :                 z[i + 1] = s * z[i] + c * f;

	fld	QWORD PTR [ebx+8]
	fmul	ST(0), ST(4)
	fld	ST(1)
	fmul	ST(0), ST(7)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax+esi+8]

; 1777 : /* L200: */
; 1778 :                 z[i] = c * z[i] - s * f;

	fld	QWORD PTR [ebx+8]
	fmul	ST(0), ST(6)
	fxch	ST(1)
	fmul	ST(0), ST(4)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ebx+8]
	jne	$LL134@gausq2_

; 1746 : 
; 1747 : /*      :::::::::: for i=m-1 step -1 until l do -- :::::::::: */
; 1748 :           i__2 = mml;
; 1749 :           for (ii = 1; ii <= i__2; ++ii) {

	mov	ecx, DWORD PTR tv2049[ebp]
	fstp	ST(2)
	fstp	ST(3)
	fxch	ST(2)
$LN58@gausq2_:

; 1779 :           }
; 1780 : 
; 1781 :           d[l] -= p;

	fsubr	QWORD PTR [ecx]

; 1782 :           e[l] = g;

	mov	edx, DWORD PTR tv1274[ebp]

; 1783 :           e[m] = 0.;

	mov	eax, DWORD PTR _e$[ebp]
	fstp	QWORD PTR [ecx]
	fxch	ST(1)
	fstp	QWORD PTR [edx+ecx]
	fldz
	fstp	QWORD PTR [eax+edi*8]

; 1784 :           goto L105;

	fld	QWORD PTR _machep$[ebp]
	jmp	$LN138@gausq2_
$LN125@gausq2_:

; 1746 : 
; 1747 : /*      :::::::::: for i=m-1 step -1 until l do -- :::::::::: */
; 1748 :           i__2 = mml;
; 1749 :           for (ii = 1; ii <= i__2; ++ii) {

	fstp	ST(2)
	fstp	ST(0)
	jmp	SHORT $LN58@gausq2_
$LN119@gausq2_:

; 1716 :      for (l = 1; l <= i__1; ++l) {

	inc	ecx

; 1731 :           if (m == l) {

	fstp	ST(0)
	add	eax, 8
$L240$90396:
	mov	DWORD PTR _l$[ebp], ecx
	mov	DWORD PTR tv2049[ebp], eax
	cmp	ecx, DWORD PTR _i__1$[ebp]
	jle	$LN68@gausq2_

; 1732 :                 goto L240;
; 1733 :           }
; 1734 :           if (j == 30) {

	mov	esi, DWORD PTR _n$[ebp]
	fstp	ST(1)
	mov	edx, DWORD PTR _d$[ebp]
$LN75@gausq2_:

; 1785 : L240:
; 1786 :           ;
; 1787 :      }
; 1788 : 
; 1789 : /*      :::::::::: order eigenvalues and eigenvectors :::::::::: */
; 1790 :      i__1 = *n;

	mov	esi, DWORD PTR [esi]
	fstp	ST(0)
	mov	DWORD PTR _i__1$[ebp], esi

; 1791 :      for (ii = 2; ii <= i__1; ++ii) {

	cmp	esi, 2
	jl	$LN57@gausq2_

; 1785 : L240:
; 1786 :           ;
; 1787 :      }
; 1788 : 
; 1789 : /*      :::::::::: order eigenvalues and eigenvectors :::::::::: */
; 1790 :      i__1 = *n;

	add	edx, 32					; 00000020H
	mov	edi, 1
	mov	DWORD PTR tv2633[ebp], edx
	npad	1
$LL67@gausq2_:

; 1792 :           i = ii - 1;
; 1793 :           k = i;
; 1794 :           p = d[i];
; 1795 : 
; 1796 :           i__2 = *n;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	ebx, DWORD PTR [ecx]
	mov	eax, DWORD PTR tv2633[ebp]
	fld	QWORD PTR [eax-24]

; 1797 :           for (j = ii; j <= i__2; ++j) {

	lea	edx, DWORD PTR [edi+1]
	mov	esi, edi
	mov	DWORD PTR tv2646[ebp], edx
	mov	ecx, edx
	cmp	edx, ebx
	jg	$LN170@gausq2_
	mov	eax, ebx
	sub	eax, edx
	inc	eax
	cmp	eax, 4
	jl	SHORT $LC50@gausq2_
	mov	edx, DWORD PTR tv2633[ebp]
$LN55@gausq2_:

; 1798 :                 if (d[j] >= p) {

	fcom	QWORD PTR [edx-16]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN51@gausq2_
	fstp	ST(0)

; 1799 :                      goto L260;
; 1800 :                 }
; 1801 :                 k = j;

	mov	esi, ecx

; 1802 :                 p = d[j];

	fld	QWORD PTR [edx-16]
$LN51@gausq2_:

; 1798 :                 if (d[j] >= p) {

	fcom	QWORD PTR [edx-8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN52@gausq2_
	fstp	ST(0)
	lea	esi, DWORD PTR [ecx+1]

; 1802 :                 p = d[j];

	fld	QWORD PTR [edx-8]
$LN52@gausq2_:

; 1798 :                 if (d[j] >= p) {

	fcom	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN53@gausq2_
	fstp	ST(0)
	lea	esi, DWORD PTR [ecx+2]

; 1802 :                 p = d[j];

	fld	QWORD PTR [edx]
$LN53@gausq2_:

; 1798 :                 if (d[j] >= p) {

	fcom	QWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN54@gausq2_
	fstp	ST(0)
	lea	esi, DWORD PTR [ecx+3]

; 1802 :                 p = d[j];

	fld	QWORD PTR [edx+8]
$LN54@gausq2_:

; 1797 :           for (j = ii; j <= i__2; ++j) {

	add	ecx, 4
	lea	eax, DWORD PTR [ebx-3]
	add	edx, 32					; 00000020H
	cmp	ecx, eax
	jle	SHORT $LN55@gausq2_
	mov	edx, DWORD PTR tv2646[ebp]
$LC50@gausq2_:
	cmp	ecx, ebx
	jg	SHORT $LN49@gausq2_
$LC5@gausq2_:

; 1798 :                 if (d[j] >= p) {

	mov	edx, DWORD PTR _d$[ebp]
	fcom	QWORD PTR [edx+ecx*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $L260$90412
	fstp	ST(0)

; 1799 :                      goto L260;
; 1800 :                 }
; 1801 :                 k = j;

	mov	esi, ecx

; 1802 :                 p = d[j];

	fld	QWORD PTR [edx+ecx*8]
$L260$90412:

; 1797 :           for (j = ii; j <= i__2; ++j) {

	inc	ecx
	cmp	ecx, ebx
	jle	SHORT $LC5@gausq2_
	mov	edx, DWORD PTR tv2646[ebp]
$LN49@gausq2_:

; 1803 : L260:
; 1804 :                 ;
; 1805 :           }
; 1806 : 
; 1807 :           if (k == i) {

	cmp	esi, edi
	je	SHORT $LN170@gausq2_

; 1808 :                 goto L300;
; 1809 :           }
; 1810 :           d[k] = d[i];

	mov	eax, DWORD PTR _d$[ebp]
	fld	QWORD PTR [eax+edi*8]
	fstp	QWORD PTR [eax+esi*8]

; 1811 :           d[i] = p;

	fstp	QWORD PTR [eax+edi*8]

; 1812 :           p = z[i];

	mov	eax, DWORD PTR _z$[ebp]
	fld	QWORD PTR [eax+edi*8]

; 1813 :           z[i] = z[k];

	fld	QWORD PTR [eax+esi*8]
	fstp	QWORD PTR [eax+edi*8]

; 1814 :           z[k] = p;

	fstp	QWORD PTR [eax+esi*8]
	jmp	SHORT $L300$90414
$LN122@gausq2_:

; 1815 : L300:
; 1816 :           ;
; 1817 :      }
; 1818 : 
; 1819 :      goto L1001;
; 1820 : /*      :::::::::: set error -- no convergence to an */
; 1821 : /*                     eigenvalue after 30 iterations :::::::::: */
; 1822 : L1000:
; 1823 :      *ierr = l;

	mov	edx, DWORD PTR _ierr$[ebp]
	fstp	ST(1)
	fstp	ST(0)
$L1000$90398:
	mov	DWORD PTR [edx], ecx
$LN57@gausq2_:

; 1824 : L1001:
; 1825 :      return 0;

	pop	edi
	pop	ebx
	xor	eax, eax
$L1001$90384:
	pop	esi

; 1826 : /*      :::::::::: last card of gausq2 :::::::::: */
; 1827 : } /* gausq2_ */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN170@gausq2_:

; 1803 : L260:
; 1804 :                 ;
; 1805 :           }
; 1806 : 
; 1807 :           if (k == i) {

	fstp	ST(0)
$L300$90414:

; 1791 :      for (ii = 2; ii <= i__1; ++ii) {

	add	DWORD PTR tv2633[ebp], 8
	mov	edi, edx
	lea	ecx, DWORD PTR [edi+1]
	cmp	ecx, DWORD PTR _i__1$[ebp]
	jle	$LL67@gausq2_

; 1824 : L1001:
; 1825 :      return 0;

	pop	edi
	pop	ebx
	xor	eax, eax
$L1001_1$90384:
	pop	esi

; 1826 : /*      :::::::::: last card of gausq2 :::::::::: */
; 1827 : } /* gausq2_ */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@gausq2_:

; 1710 :      if (*n == 1) {

	fstp	ST(0)

; 1824 : L1001:
; 1825 :      return 0;

	xor	eax, eax
$L1001_2$90384:
	pop	esi

; 1826 : /*      :::::::::: last card of gausq2 :::::::::: */
; 1827 : } /* gausq2_ */

	mov	esp, ebp
	pop	ebp
	ret	0
_gausq2_ ENDP
_TEXT	ENDS
PUBLIC	_lagrange_index
EXTRN	_binom_coeff:PROC
; Function compile flags: /Ogtp
;	COMDAT _lagrange_index
_TEXT	SEGMENT
_dim$ = 8						; size = 4
_order$ = 12						; size = 4
_inx$ = 16						; size = 4
_lagrange_index PROC					; COMDAT

; 1850 : { int spot;

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 1851 :   int k;
; 1852 :   int left;
; 1853 : 
; 1854 :   spot = binom_coeff(order+dim,dim)-1;

	mov	esi, DWORD PTR _dim$[ebp]
	push	edi
	mov	edi, DWORD PTR _order$[ebp]
	lea	eax, DWORD PTR [esi+edi]
	push	esi
	push	eax
	call	_binom_coeff
	add	esp, 8
	lea	ebx, DWORD PTR [eax-1]

; 1855 :   left = order;
; 1856 :   for ( k = dim ; k > 0 ; k--  )

	test	esi, esi
	jle	SHORT $LN8@lagrange_i
$LL3@lagrange_i:

; 1857 :   { 
; 1858 :      left -= inx[k];

	mov	ecx, DWORD PTR _inx$[ebp]
	sub	edi, DWORD PTR [ecx+esi*4]

; 1859 :      spot -= binom_coeff(left-1+k,k);

	push	esi
	lea	edx, DWORD PTR [esi+edi-1]
	push	edx
	call	_binom_coeff
	dec	esi
	add	esp, 8
	sub	ebx, eax
	test	esi, esi
	jg	SHORT $LL3@lagrange_i
$LN8@lagrange_i:
	pop	edi
	pop	esi

; 1860 :   }
; 1861 :   return spot;

	mov	eax, ebx
	pop	ebx

; 1862 : } // end lagrange_index()

	pop	ebp
	ret	0
_lagrange_index ENDP
_TEXT	ENDS
PUBLIC	_increment_lagrange_index
; Function compile flags: /Ogtp
;	COMDAT _increment_lagrange_index
_TEXT	SEGMENT
_dim$ = 8						; size = 4
_inx$ = 12						; size = 4
_increment_lagrange_index PROC				; COMDAT

; 1880 : { int j;

	push	ebp
	mov	ebp, esp

; 1881 : 
; 1882 :   for ( j = 0 ; j < dim ; j++ )

	mov	edx, DWORD PTR _dim$[ebp]
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN3@increment_
	mov	ecx, DWORD PTR _inx$[ebp]
	npad	1
$LL5@increment_:

; 1883 :      if ( inx[j] > 0 ) 

	cmp	DWORD PTR [ecx+eax*4], 0
	jg	SHORT $LN9@increment_

; 1881 : 
; 1882 :   for ( j = 0 ; j < dim ; j++ )

	inc	eax
	cmp	eax, edx
	jl	SHORT $LL5@increment_
$LN3@increment_:

; 1885 :   return 0;  /* done */

	xor	eax, eax

; 1886 : } // end increment_lagrange_index()

	pop	ebp
	ret	0
$LN9@increment_:

; 1884 :      { inx[j+1]++; inx[0] = inx[j]-1; if ( j > 0 ) inx[j] = 0; return 1; }

	mov	edx, DWORD PTR [ecx+eax*4]
	inc	DWORD PTR [ecx+eax*4+4]
	dec	edx
	mov	DWORD PTR [ecx], edx
	test	eax, eax
	jle	SHORT $LN1@increment_
	mov	DWORD PTR [ecx+eax*4], 0
$LN1@increment_:
	mov	eax, 1

; 1886 : } // end increment_lagrange_index()

	pop	ebp
	ret	0
_increment_lagrange_index ENDP
_TEXT	ENDS
PUBLIC	??_C@_07KGJJPNNA@MODEL?4C?$AA@			; `string'
PUBLIC	_baryhash_init
EXTRN	_kb_temp_calloc:PROC
;	COMDAT ??_C@_07KGJJPNNA@MODEL?4C?$AA@
CONST	SEGMENT
??_C@_07KGJJPNNA@MODEL?4C?$AA@ DB 'MODEL.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _baryhash_init
_TEXT	SEGMENT
_fctrl$ = 8						; size = 4
_baryhash_init PROC					; COMDAT

; 2124 : { 

	push	ebp
	mov	ebp, esp

; 2125 :     baryhash_size = (3*fctrl/2)*web.skel[FACET].count;

	mov	eax, DWORD PTR _fctrl$[ebp]
	lea	eax, DWORD PTR [eax+eax*2]
	cdq
	sub	eax, edx
	sar	eax, 1
	imul	eax, DWORD PTR _web+288

; 2126 :     baryhash_table = (struct baryhash*)temp_calloc(baryhash_size,
; 2127 :         sizeof(struct baryhash));

	push	2127					; 0000084fH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	64					; 00000040H
	push	eax
	mov	DWORD PTR _baryhash_size, eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _baryhash_table, eax

; 2128 :     baryhash_count = 0;

	mov	DWORD PTR _baryhash_count, 0

; 2129 : }

	pop	ebp
	ret	0
_baryhash_init ENDP
_TEXT	ENDS
PUBLIC	_baryhash_end
EXTRN	_temp_free:PROC
; Function compile flags: /Ogtp
;	COMDAT _baryhash_end
_TEXT	SEGMENT
_baryhash_end PROC					; COMDAT

; 2131 : { temp_free((char*)baryhash_table);

	mov	eax, DWORD PTR _baryhash_table
	push	eax
	call	_temp_free

; 2132 :   baryhash_size = baryhash_count = 0;

	xor	eax, eax
	add	esp, 4
	mov	DWORD PTR _baryhash_count, eax
	mov	DWORD PTR _baryhash_size, eax

; 2133 : }

	ret	0
_baryhash_end ENDP
_TEXT	ENDS
PUBLIC	_baryhash_func
; Function compile flags: /Ogtp
;	COMDAT _baryhash_func
_TEXT	SEGMENT
_hash$ = -8						; size = 4
$T91612 = -4						; size = 4
_n$ = 8							; size = 4
_v$ = 12						; size = 4
_x$ = 16						; size = 4
_baryhash_func PROC					; COMDAT

; 2140 : { unsigned int hash;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 2141 :   int k;
; 2142 :   for ( k = 0, hash = 0 ; k < n ; k ++ ) 

	mov	ebx, DWORD PTR _n$[ebp]
	push	esi

; 2143 :   { hash += (unsigned int)(v[k]*1843723 + x[k]*17977); }

	xor	esi, esi
	xor	edx, edx
	xor	ecx, ecx
	push	edi
	mov	edi, DWORD PTR _v$[ebp]
	mov	DWORD PTR $T91612[ebp], esi
	mov	DWORD PTR _hash$[ebp], esi
	cmp	ebx, 2
	jl	SHORT $LC9@baryhash_f
	mov	esi, DWORD PTR _x$[ebp]
	lea	eax, DWORD PTR [edi+4]
	sub	esi, edi
	npad	8
$LL11@baryhash_f:
	mov	ebx, DWORD PTR [eax-4]
	mov	edi, DWORD PTR _x$[ebp]
	imul	ebx, 1843723				; 001c220bH
	mov	edi, DWORD PTR [edi+ecx*4]
	imul	edi, 17977				; 00004639H
	add	edx, ebx
	mov	ebx, DWORD PTR [eax]
	add	edx, edi
	imul	ebx, 1843723				; 001c220bH
	mov	edi, DWORD PTR [esi+eax]
	add	ebx, DWORD PTR $T91612[ebp]
	imul	edi, 17977				; 00004639H
	add	ebx, edi
	mov	DWORD PTR $T91612[ebp], ebx
	mov	ebx, DWORD PTR _n$[ebp]
	add	ecx, 2
	lea	edi, DWORD PTR [ebx-1]
	add	eax, 8
	cmp	ecx, edi
	jl	SHORT $LL11@baryhash_f
	mov	edi, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _hash$[ebp]
$LC9@baryhash_f:

; 2141 :   int k;
; 2142 :   for ( k = 0, hash = 0 ; k < n ; k ++ ) 

	cmp	ecx, ebx
	jge	SHORT $LN8@baryhash_f

; 2143 :   { hash += (unsigned int)(v[k]*1843723 + x[k]*17977); }

	mov	eax, DWORD PTR _x$[ebp]
	mov	esi, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edi+ecx*4]
	imul	esi, 17977				; 00004639H
	imul	ecx, 1843723				; 001c220bH
	add	esi, ecx
$LN8@baryhash_f:
	mov	eax, DWORD PTR $T91612[ebp]
	add	eax, edx
	add	eax, esi

; 2144 :   return  hash % baryhash_size;

	xor	edx, edx
	div	DWORD PTR _baryhash_size
	pop	edi
	pop	esi
	pop	ebx
	mov	eax, edx

; 2145 : } // end baryhash_func()

	mov	esp, ebp
	pop	ebp
	ret	0
_baryhash_func ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FJ@OLDJGAHM@Internal?5error?3?5Duplicate?5vertex@ ; `string'
PUBLIC	??_C@_0CF@IGJALCIE@Internal?5error?3?5Baryhash?5near?5fu@ ; `string'
PUBLIC	__real@3feccccccccccccd
PUBLIC	__$ArrayPad$
PUBLIC	_baryhash_find
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0FJ@OLDJGAHM@Internal?5error?3?5Duplicate?5vertex@
CONST	SEGMENT
??_C@_0FJ@OLDJGAHM@Internal?5error?3?5Duplicate?5vertex@ DB 'Internal err'
	DB	'or: Duplicate vertex in baryhash!', 0aH, ' nn = %d    newv = '
	DB	'%08lX  b->v_id = %08lX', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IGJALCIE@Internal?5error?3?5Baryhash?5near?5fu@
CONST	SEGMENT
??_C@_0CF@IGJALCIE@Internal?5error?3?5Baryhash?5near?5fu@ DB 'Internal er'
	DB	'ror: Baryhash near full!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@3feccccccccccccd
CONST	SEGMENT
__real@3feccccccccccccd DQ 03feccccccccccccdr	; 0.9
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _baryhash_find
_TEXT	SEGMENT
tv555 = -68						; size = 4
tv499 = -64						; size = 4
_xx$ = -60						; size = 28
_vv$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_v$ = 12						; size = 4
_x$ = 16						; size = 4
_newv$ = 20						; size = 4
_baryhash_find PROC					; COMDAT

; 2154 : { int nn;  /* number of nonzero  coords */

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2155 :   vertex_id vv[MAXCOORD+1];  /* needed vertices, in order */
; 2156 :   int xx[MAXCOORD+1];  /* needed coordinates */
; 2157 :   int spot;
; 2158 :   int i,j,k;
; 2159 :   struct baryhash *b;
; 2160 : 
; 2161 :   /* clean up key with insertion sort */
; 2162 :   for ( i = 0, j = 0 ; i < n ; i++ )

	mov	eax, DWORD PTR _n$[ebp]
	push	ebx
	push	esi
	xor	esi, esi
	push	edi
	test	eax, eax
	jle	SHORT $LN25@baryhash_f@2
	mov	edx, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv555[ebp], ecx
	mov	DWORD PTR tv499[ebp], eax
	npad	6
$LL46@baryhash_f@2:

; 2163 :   { 
; 2164 :      if ( x[i] == 0 ) continue;

	mov	ebx, DWORD PTR [edx]
	test	ebx, ebx
	je	SHORT $LN26@baryhash_f@2

; 2165 :      for ( k = j; k > 0 ; k-- )

	mov	eax, esi
	test	esi, esi
	jle	SHORT $LN20@baryhash_f@2
	mov	edi, DWORD PTR [ecx+edx]
	npad	1
$LL23@baryhash_f@2:

; 2166 :         if ( vv[k-1] > v[i] )

	mov	ecx, DWORD PTR _vv$[ebp+eax*4-4]
	cmp	ecx, edi
	jbe	SHORT $LN43@baryhash_f@2

; 2167 :         { vv[k] = vv[k-1]; xx[k] = xx[k-1]; }

	mov	DWORD PTR _vv$[ebp+eax*4], ecx
	mov	ecx, DWORD PTR _xx$[ebp+eax*4-4]
	mov	DWORD PTR _xx$[ebp+eax*4], ecx
	dec	eax
	test	eax, eax
	jg	SHORT $LL23@baryhash_f@2
$LN43@baryhash_f@2:

; 2165 :      for ( k = j; k > 0 ; k-- )

	mov	ecx, DWORD PTR tv555[ebp]
$LN20@baryhash_f@2:

; 2168 :         else break;
; 2169 :      vv[k] = v[i];

	mov	edi, DWORD PTR [ecx+edx]
	mov	DWORD PTR _vv$[ebp+eax*4], edi

; 2170 :      xx[k] = x[i];

	mov	DWORD PTR _xx$[ebp+eax*4], ebx

; 2171 :      j++;

	inc	esi
$LN26@baryhash_f@2:

; 2155 :   vertex_id vv[MAXCOORD+1];  /* needed vertices, in order */
; 2156 :   int xx[MAXCOORD+1];  /* needed coordinates */
; 2157 :   int spot;
; 2158 :   int i,j,k;
; 2159 :   struct baryhash *b;
; 2160 : 
; 2161 :   /* clean up key with insertion sort */
; 2162 :   for ( i = 0, j = 0 ; i < n ; i++ )

	add	edx, 4
	dec	DWORD PTR tv499[ebp]
	jne	SHORT $LL46@baryhash_f@2
$LN25@baryhash_f@2:

; 2172 :   }
; 2173 :   nn = j;
; 2174 :   spot = baryhash_func(nn,vv,xx);

	lea	edx, DWORD PTR _xx$[ebp]
	push	edx
	lea	eax, DWORD PTR _vv$[ebp]
	push	eax
	push	esi
	call	_baryhash_func
	add	esp, 12					; 0000000cH
$LL18@baryhash_f@2:

; 2176 :   { 
; 2177 :      if ( spot >= baryhash_size ) spot = 0;

	cmp	eax, DWORD PTR _baryhash_size
	jl	SHORT $LN15@baryhash_f@2
	xor	eax, eax
$LN15@baryhash_f@2:

; 2178 :      b = baryhash_table + spot;

	mov	edi, eax
	shl	edi, 6
	add	edi, DWORD PTR _baryhash_table

; 2179 :      if ( b->nn == 0 ) /* vacant */

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN37@baryhash_f@2

; 2180 :         break;
; 2181 :      if ( b->nn != nn ) continue;

	cmp	ecx, esi
	jne	SHORT $LN17@baryhash_f@2

; 2182 :      for ( i = 0 ; i < nn ; i++ )

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN45@baryhash_f@2
	lea	edx, DWORD PTR [edi+32]
	npad	7
$LL12@baryhash_f@2:

; 2183 :         if ( (b->vv[i] != vv[i]) || (b->xx[i] != xx[i]) )

	mov	ebx, DWORD PTR [edx-28]
	cmp	ebx, DWORD PTR _vv$[ebp+ecx*4]
	jne	SHORT $LN45@baryhash_f@2
	mov	ebx, DWORD PTR [edx]
	cmp	ebx, DWORD PTR _xx$[ebp+ecx*4]
	jne	SHORT $LN45@baryhash_f@2

; 2182 :      for ( i = 0 ; i < nn ; i++ )

	inc	ecx
	add	edx, 4
	cmp	ecx, esi
	jl	SHORT $LL12@baryhash_f@2
$LN45@baryhash_f@2:

; 2184 :           break;
; 2185 :      if ( i == nn )  /* match */

	cmp	ecx, esi
	je	SHORT $LN38@baryhash_f@2
$LN17@baryhash_f@2:

; 2175 :   for (;; spot++)

	inc	eax
	jmp	SHORT $LL18@baryhash_f@2
$LN37@baryhash_f@2:

; 2193 :      }
; 2194 :   }
; 2195 :   /* empty_spot: */
; 2196 :   if ( newv != NULLID )

	mov	edx, DWORD PTR _newv$[ebp]
	test	edx, edx
	je	SHORT $LN1@baryhash_f@2

; 2199 :      for ( k = 0 ; k < nn ; k++ )

	xor	eax, eax
	mov	DWORD PTR [edi], esi
	test	esi, esi
	jle	SHORT $LN2@baryhash_f@2

; 2197 :   { /* insert */
; 2198 :      b->nn = nn;

	lea	ecx, DWORD PTR [edi+32]
$LL4@baryhash_f@2:

; 2200 :      { b->vv[k] = vv[k];

	mov	ebx, DWORD PTR _vv$[ebp+eax*4]
	mov	DWORD PTR [ecx-28], ebx

; 2201 :         b->xx[k] = xx[k];

	mov	ebx, DWORD PTR _xx$[ebp+eax*4]
	mov	DWORD PTR [ecx], ebx
	inc	eax
	add	ecx, 4
	cmp	eax, esi
	jl	SHORT $LL4@baryhash_f@2
$LN2@baryhash_f@2:

; 2202 :      }
; 2203 :      b->v_id = newv;

	mov	DWORD PTR [edi+60], edx

; 2204 :      baryhash_count++;

	inc	DWORD PTR _baryhash_count

; 2205 :      if ( (REAL)baryhash_count > .9*baryhash_size ) 

	fild	DWORD PTR _baryhash_count
	fild	DWORD PTR _baryhash_size
	fmul	QWORD PTR __real@3feccccccccccccd
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@baryhash_f@2

; 2206 :         kb_error(1816,"Internal error: Baryhash near full!\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CF@IGJALCIE@Internal?5error?3?5Baryhash?5near?5fu@
	push	1816					; 00000718H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@baryhash_f@2:

; 2207 :   }
; 2208 :   return NULLID;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 2209 : } // end baryhash_find()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@baryhash_f@2:

; 2186 :      { if ( (newv != NULLID) && (newv != b->v_id) ) 

	mov	ecx, DWORD PTR _newv$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@baryhash_f@2
	mov	eax, DWORD PTR [edi+60]
	cmp	ecx, eax
	je	SHORT $LN6@baryhash_f@2

; 2187 :         { sprintf(errmsg,"Internal error: Duplicate vertex in baryhash!\n nn = %d    newv = %08lX  b->v_id = %08lX\n",nn,
; 2188 :              (unsigned long)newv,(unsigned long)b->v_id);

	push	eax
	push	ecx
	push	esi
	push	OFFSET ??_C@_0FJ@OLDJGAHM@Internal?5error?3?5Duplicate?5vertex@
	push	OFFSET _errmsg
	call	_sprintf

; 2189 :           kb_error(1815,errmsg,RECOVERABLE);     

	push	1
	push	OFFSET _errmsg
	push	1815					; 00000717H
	call	_kb_error
	add	esp, 32					; 00000020H
$LN6@baryhash_f@2:

; 2190 : 
; 2191 :         }
; 2192 :         return b->v_id;

	mov	eax, DWORD PTR [edi+60]

; 2209 : } // end baryhash_find()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_baryhash_find ENDP
_TEXT	ENDS
PUBLIC	_lagrange_to_bezier
EXTRN	_free_matrix:PROC
EXTRN	_bezier1invert:BYTE
EXTRN	_mat_mult:PROC
EXTRN	_bezier2invert:BYTE
EXTRN	_kb_dmatrix:PROC
; Function compile flags: /Ogtp
;	COMDAT _lagrange_to_bezier
_TEXT	SEGMENT
_oldx$ = -936						; size = 924
tv424 = -12						; size = 4
tv359 = -12						; size = 4
_i$ = -8						; size = 4
_v$ = -8						; size = 4
_newx$ = -4						; size = 4
_lagrange_to_bezier PROC				; COMDAT

; 2455 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 936				; 000003a8H

; 2456 :   int i,j;
; 2457 :   REAL *oldx[(MAXLAGRANGE+1)*(MAXLAGRANGE+2)/2];
; 2458 :   REAL **newx;
; 2459 :   edge_id e_id;
; 2460 :   facet_id f_id;
; 2461 :   vertex_id *v;
; 2462 : 
; 2463 :   if ( web.modeltype != LAGRANGE ) return;

	cmp	DWORD PTR _web+628, 3
	jne	$LN32@lagrange_t

; 2464 : 
; 2465 :   newx = dmatrix(0,web.skel[FACET].ctrlpts,0,SDIM-1);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _web+232
	push	ebx
	push	esi
	push	edi
	push	2465					; 000009a1H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	ecx
	push	0
	call	_kb_dmatrix
	add	esp, 24					; 00000018H

; 2466 : 
; 2467 :   /* do facet interiors first, so can use unchanged edge vertices */ 
; 2468 :   if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	mov	DWORD PTR _newx$[ebp], eax
	jne	$LN55@lagrange_t

; 2469 :   { MFOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+272
	test	eax, 268435456				; 10000000H
	je	$LN55@lagrange_t
	mov	esi, DWORD PTR _web+232
$LL58@lagrange_t:
	mov	edx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR tv359[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN28@lagrange_t

; 2470 :     { 
; 2471 :       v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	edi, DWORD PTR [eax+edx+304]
	add	edi, ecx

; 2472 :       for ( i = 0 ; i <= web.skel[FACET].ctrlpts ; i++ )

	xor	eax, eax
	mov	DWORD PTR _v$[ebp], edi
	test	esi, esi
	js	SHORT $LN22@lagrange_t
	mov	ecx, edi
	lea	edi, DWORD PTR _oldx$[ebp]
	sub	ecx, edi
	npad	1
$LL54@lagrange_t:

; 2473 :         oldx[i] = get_coord(v[i]);

	mov	ebx, DWORD PTR _web+12
	lea	edi, DWORD PTR [ecx+eax*4]
	mov	edi, DWORD PTR _oldx$[ebp+edi]
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR _web+104
	add	edi, DWORD PTR [ebx+edx+64]
	inc	eax
	mov	DWORD PTR _oldx$[ebp+eax*4-4], edi
	cmp	eax, esi
	jle	SHORT $LL54@lagrange_t

; 2472 :       for ( i = 0 ; i <= web.skel[FACET].ctrlpts ; i++ )

	mov	edi, DWORD PTR _v$[ebp]
$LN22@lagrange_t:

; 2474 :       mat_mult(bezier2invert[web.lagrange_order],oldx,newx,
; 2475 :   		web.skel[FACET].ctrlpts,web.skel[FACET].ctrlpts,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	ebx, DWORD PTR _newx$[ebp]
	mov	eax, DWORD PTR _web+632
	push	ecx
	mov	ecx, DWORD PTR _bezier2invert[eax*4]
	push	esi
	push	esi
	push	ebx
	lea	edx, DWORD PTR _oldx$[ebp]
	push	edx
	push	ecx
	call	_mat_mult

; 2476 :       for ( i = 1 ; i < web.skel[FACET].ctrlpts ; i++ ) 

	mov	esi, DWORD PTR _web+232
	add	esp, 24					; 00000018H
	mov	DWORD PTR _i$[ebp], 1
	cmp	esi, 1
	jle	SHORT $LN28@lagrange_t
	mov	eax, DWORD PTR _newx$[ebp]
	lea	ecx, DWORD PTR [ebx+4]
	mov	ebx, edi
	lea	edi, DWORD PTR _oldx$[ebp]
	sub	ebx, eax
	sub	edi, eax
	npad	1
$LL21@lagrange_t:

; 2477 :       { if ( get_vattr(v[i]) & Q_MIDFACET )

	mov	edx, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2097152				; 00200000H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN20@lagrange_t

; 2478 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN20@lagrange_t
	mov	edx, DWORD PTR [ecx]
	npad	5
$LL17@lagrange_t:

; 2479 :           oldx[i][j] = newx[i][j];

	fld	QWORD PTR [edx+eax*8]
	mov	esi, DWORD PTR [edi+ecx]
	fstp	QWORD PTR [esi+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL17@lagrange_t

; 2478 :         for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _web+232
$LN20@lagrange_t:

; 2476 :       for ( i = 1 ; i < web.skel[FACET].ctrlpts ; i++ ) 

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	ecx, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, esi
	jl	SHORT $LL21@lagrange_t
$LN28@lagrange_t:

; 2469 :   { MFOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR tv359[ebp]
	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL58@lagrange_t
$LN55@lagrange_t:

; 2480 :       }
; 2481 :     }
; 2482 :   }
; 2483 :  
; 2484 :   MFOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+160
	test	eax, 268435456				; 10000000H
	je	$LN12@lagrange_t
	mov	ecx, DWORD PTR _web+632
	npad	11
$LL56@lagrange_t:
	mov	edx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	ebx, DWORD PTR [eax+eax]
	mov	edx, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv424[ebp], ebx
	je	$LN13@lagrange_t

; 2485 :   { 
; 2486 :     v = get_edge_vertices(e_id);

	mov	eax, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+edi+304]
	add	esi, edx

; 2487 :     for ( i = 0 ; i <= web.lagrange_order ; i++ )

	xor	eax, eax
	test	ecx, ecx
	js	SHORT $LN7@lagrange_t
	mov	edx, esi
	lea	esi, DWORD PTR _oldx$[ebp]
	sub	edx, esi
	npad	6
$LL53@lagrange_t:

; 2488 :       oldx[i] = get_coord(v[i]);

	mov	ebx, DWORD PTR _web+12
	lea	esi, DWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR _oldx$[ebp+esi]
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	ebx, DWORD PTR _web+104
	add	esi, DWORD PTR [ebx+edi+64]
	inc	eax
	mov	DWORD PTR _oldx$[ebp+eax*4-4], esi
	cmp	eax, ecx
	jle	SHORT $LL53@lagrange_t

; 2487 :     for ( i = 0 ; i <= web.lagrange_order ; i++ )

	mov	ebx, DWORD PTR tv424[ebp]
$LN7@lagrange_t:

; 2489 :     mat_mult(bezier1invert[web.lagrange_order],oldx,newx,
; 2490 : 		web.lagrange_order+1,web.lagrange_order+1,SDIM);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR [ecx+1]
	push	eax
	push	eax
	mov	eax, DWORD PTR _newx$[ebp]
	push	eax
	mov	eax, DWORD PTR _bezier1invert[ecx*4]
	lea	edx, DWORD PTR _oldx$[ebp]
	push	edx
	push	eax
	call	_mat_mult

; 2491 :     for ( i = 1 ; i <  web.lagrange_order ; i++ ) /* no changing ends */

	mov	ecx, DWORD PTR _web+632
	mov	esi, 1
	add	esp, 24					; 00000018H
	cmp	ecx, esi
	jle	SHORT $LN13@lagrange_t

; 2489 :     mat_mult(bezier1invert[web.lagrange_order],oldx,newx,
; 2490 : 		web.lagrange_order+1,web.lagrange_order+1,SDIM);

	lea	edx, DWORD PTR _oldx$[ebp+4]
	npad	2
$LL57@lagrange_t:

; 2492 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN5@lagrange_t
	mov	ecx, DWORD PTR _newx$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
$LL3@lagrange_t:

; 2493 :         oldx[i][j] = newx[i][j];

	fld	QWORD PTR [ecx+eax*8]
	mov	edi, DWORD PTR [edx]
	fstp	QWORD PTR [edi+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL3@lagrange_t

; 2492 :       for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+632
$LN5@lagrange_t:

; 2491 :     for ( i = 1 ; i <  web.lagrange_order ; i++ ) /* no changing ends */

	inc	esi
	add	edx, 4
	cmp	esi, ecx
	jl	SHORT $LL57@lagrange_t
$LN13@lagrange_t:

; 2480 :       }
; 2481 :     }
; 2482 :   }
; 2483 :  
; 2484 :   MFOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL56@lagrange_t
$LN12@lagrange_t:

; 2494 :   }
; 2495 : 
; 2496 :   free_matrix(newx);

	mov	ecx, DWORD PTR _newx$[ebp]
	push	ecx
	call	_free_matrix
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
$LN32@lagrange_t:

; 2497 : } // end lagrange_to_bezier()

	mov	esp, ebp
	pop	ebp
	ret	0
_lagrange_to_bezier ENDP
_TEXT	ENDS
PUBLIC	_bezier_to_lagrange
EXTRN	_bezier1revert:BYTE
EXTRN	_bezier2revert:BYTE
; Function compile flags: /Ogtp
;	COMDAT _bezier_to_lagrange
_TEXT	SEGMENT
_oldx$ = -936						; size = 924
tv424 = -12						; size = 4
tv359 = -12						; size = 4
_i$ = -8						; size = 4
_v$ = -8						; size = 4
_newx$ = -4						; size = 4
_bezier_to_lagrange PROC				; COMDAT

; 2507 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 936				; 000003a8H

; 2508 :   int i,j;
; 2509 :   REAL *oldx[(MAXLAGRANGE+1)*(MAXLAGRANGE+2)/2];
; 2510 :   REAL **newx;
; 2511 :   edge_id e_id;
; 2512 :   facet_id f_id;
; 2513 :   vertex_id *v;
; 2514 : 
; 2515 :   if ( web.modeltype != LAGRANGE ) return;

	cmp	DWORD PTR _web+628, 3
	jne	$LN32@bezier_to_

; 2516 : 
; 2517 :   newx = dmatrix(0,web.skel[FACET].ctrlpts,0,SDIM-1);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _web+232
	push	ebx
	push	esi
	push	edi
	push	2517					; 000009d5H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	ecx
	push	0
	call	_kb_dmatrix
	add	esp, 24					; 00000018H

; 2518 :  
; 2519 :   /* do facet interior vertices first, so can use unchanged edge verts */
; 2520 :   if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	mov	DWORD PTR _newx$[ebp], eax
	jne	$LN55@bezier_to_

; 2521 :   { MFOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+272
	test	eax, 268435456				; 10000000H
	je	$LN55@bezier_to_
	mov	esi, DWORD PTR _web+232
$LL58@bezier_to_:
	mov	edx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR tv359[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN28@bezier_to_

; 2522 :     { 
; 2523 :       v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	edi, DWORD PTR [eax+edx+304]
	add	edi, ecx

; 2524 :       for ( i = 0 ; i <= web.skel[FACET].ctrlpts ; i++ )

	xor	eax, eax
	mov	DWORD PTR _v$[ebp], edi
	test	esi, esi
	js	SHORT $LN22@bezier_to_
	mov	ecx, edi
	lea	edi, DWORD PTR _oldx$[ebp]
	sub	ecx, edi
	npad	1
$LL54@bezier_to_:

; 2525 :         oldx[i] = get_coord(v[i]);

	mov	ebx, DWORD PTR _web+12
	lea	edi, DWORD PTR [ecx+eax*4]
	mov	edi, DWORD PTR _oldx$[ebp+edi]
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR _web+104
	add	edi, DWORD PTR [ebx+edx+64]
	inc	eax
	mov	DWORD PTR _oldx$[ebp+eax*4-4], edi
	cmp	eax, esi
	jle	SHORT $LL54@bezier_to_

; 2524 :       for ( i = 0 ; i <= web.skel[FACET].ctrlpts ; i++ )

	mov	edi, DWORD PTR _v$[ebp]
$LN22@bezier_to_:

; 2526 :       mat_mult(bezier2revert[web.lagrange_order],oldx,newx,
; 2527 :   		web.skel[FACET].ctrlpts,web.skel[FACET].ctrlpts,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	ebx, DWORD PTR _newx$[ebp]
	mov	eax, DWORD PTR _web+632
	push	ecx
	mov	ecx, DWORD PTR _bezier2revert[eax*4]
	push	esi
	push	esi
	push	ebx
	lea	edx, DWORD PTR _oldx$[ebp]
	push	edx
	push	ecx
	call	_mat_mult

; 2528 :       for ( i = 1 ; i < web.skel[FACET].ctrlpts ; i++ ) 

	mov	esi, DWORD PTR _web+232
	add	esp, 24					; 00000018H
	mov	DWORD PTR _i$[ebp], 1
	cmp	esi, 1
	jle	SHORT $LN28@bezier_to_
	mov	eax, DWORD PTR _newx$[ebp]
	lea	ecx, DWORD PTR [ebx+4]
	mov	ebx, edi
	lea	edi, DWORD PTR _oldx$[ebp]
	sub	ebx, eax
	sub	edi, eax
	npad	1
$LL21@bezier_to_:

; 2529 :       { if ( get_vattr(v[i]) & Q_MIDFACET )

	mov	edx, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2097152				; 00200000H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN20@bezier_to_

; 2530 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN20@bezier_to_
	mov	edx, DWORD PTR [ecx]
	npad	5
$LL17@bezier_to_:

; 2531 :           oldx[i][j] = newx[i][j];

	fld	QWORD PTR [edx+eax*8]
	mov	esi, DWORD PTR [edi+ecx]
	fstp	QWORD PTR [esi+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL17@bezier_to_

; 2530 :         for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _web+232
$LN20@bezier_to_:

; 2528 :       for ( i = 1 ; i < web.skel[FACET].ctrlpts ; i++ ) 

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	ecx, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, esi
	jl	SHORT $LL21@bezier_to_
$LN28@bezier_to_:

; 2521 :   { MFOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR tv359[ebp]
	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL58@bezier_to_
$LN55@bezier_to_:

; 2532 :       }
; 2533 :     }
; 2534 :   }
; 2535 : 
; 2536 :   MFOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+160
	test	eax, 268435456				; 10000000H
	je	$LN12@bezier_to_
	mov	ecx, DWORD PTR _web+632
	npad	11
$LL56@bezier_to_:
	mov	edx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	ebx, DWORD PTR [eax+eax]
	mov	edx, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv424[ebp], ebx
	je	$LN13@bezier_to_

; 2537 :   { 
; 2538 :     v = get_edge_vertices(e_id);

	mov	eax, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+edi+304]
	add	esi, edx

; 2539 :     for ( i = 0 ; i <= web.lagrange_order ; i++ )

	xor	eax, eax
	test	ecx, ecx
	js	SHORT $LN7@bezier_to_
	mov	edx, esi
	lea	esi, DWORD PTR _oldx$[ebp]
	sub	edx, esi
	npad	6
$LL53@bezier_to_:

; 2540 :       oldx[i] = get_coord(v[i]);

	mov	ebx, DWORD PTR _web+12
	lea	esi, DWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR _oldx$[ebp+esi]
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	ebx, DWORD PTR _web+104
	add	esi, DWORD PTR [ebx+edi+64]
	inc	eax
	mov	DWORD PTR _oldx$[ebp+eax*4-4], esi
	cmp	eax, ecx
	jle	SHORT $LL53@bezier_to_

; 2539 :     for ( i = 0 ; i <= web.lagrange_order ; i++ )

	mov	ebx, DWORD PTR tv424[ebp]
$LN7@bezier_to_:

; 2541 :     mat_mult(bezier1revert[web.lagrange_order],oldx,newx,
; 2542 : 		web.lagrange_order+1,web.lagrange_order+1,SDIM);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR [ecx+1]
	push	eax
	push	eax
	mov	eax, DWORD PTR _newx$[ebp]
	push	eax
	mov	eax, DWORD PTR _bezier1revert[ecx*4]
	lea	edx, DWORD PTR _oldx$[ebp]
	push	edx
	push	eax
	call	_mat_mult

; 2543 :     for ( i = 1 ; i <  web.lagrange_order ; i++ ) /* no changing ends */

	mov	ecx, DWORD PTR _web+632
	mov	esi, 1
	add	esp, 24					; 00000018H
	cmp	ecx, esi
	jle	SHORT $LN13@bezier_to_

; 2541 :     mat_mult(bezier1revert[web.lagrange_order],oldx,newx,
; 2542 : 		web.lagrange_order+1,web.lagrange_order+1,SDIM);

	lea	edx, DWORD PTR _oldx$[ebp+4]
	npad	2
$LL57@bezier_to_:

; 2544 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN5@bezier_to_
	mov	ecx, DWORD PTR _newx$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
$LL3@bezier_to_:

; 2545 :         oldx[i][j] = newx[i][j];

	fld	QWORD PTR [ecx+eax*8]
	mov	edi, DWORD PTR [edx]
	fstp	QWORD PTR [edi+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL3@bezier_to_

; 2544 :       for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+632
$LN5@bezier_to_:

; 2543 :     for ( i = 1 ; i <  web.lagrange_order ; i++ ) /* no changing ends */

	inc	esi
	add	edx, 4
	cmp	esi, ecx
	jl	SHORT $LL57@bezier_to_
$LN13@bezier_to_:

; 2532 :       }
; 2533 :     }
; 2534 :   }
; 2535 : 
; 2536 :   MFOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL56@bezier_to_
$LN12@bezier_to_:

; 2546 :   }
; 2547 :  
; 2548 :   free_matrix(newx);

	mov	ecx, DWORD PTR _newx$[ebp]
	push	ecx
	call	_free_matrix
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
$LN32@bezier_to_:

; 2549 : } // end bezier_to_lagrange()

	mov	esp, ebp
	pop	ebp
	ret	0
_bezier_to_lagrange ENDP
_TEXT	ENDS
PUBLIC	_vpaircomp
; Function compile flags: /Ogtp
;	COMDAT _vpaircomp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_vpaircomp PROC						; COMDAT

; 2563 : { if ( a->v[0] < b->v[0] ) return -1;

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [esi]
	cmp	eax, ecx
	jae	SHORT $LN7@vpaircomp
$LN9@vpaircomp:
	or	eax, -1
	pop	esi

; 2567 :   return 0;
; 2568 : } // end vpaircomp()

	pop	ebp
	ret	0
$LN7@vpaircomp:

; 2564 :   if ( a->v[0] > b->v[0] ) return  1;

	jbe	SHORT $LN3@vpaircomp
	mov	eax, 1
	pop	esi

; 2567 :   return 0;
; 2568 : } // end vpaircomp()

	pop	ebp
	ret	0
$LN3@vpaircomp:

; 2565 :   if ( a->v[1] < b->v[1] ) return -1;

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	ja	SHORT $LN9@vpaircomp

; 2566 :   if ( a->v[1] > b->v[1] ) return  1;

	sbb	eax, eax
	neg	eax
	pop	esi

; 2567 :   return 0;
; 2568 : } // end vpaircomp()

	pop	ebp
	ret	0
_vpaircomp ENDP
_TEXT	ENDS
PUBLIC	_add_to_vpair_list
; Function compile flags: /Ogtp
;	COMDAT _add_to_vpair_list
_TEXT	SEGMENT
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_add_to_vpair_list PROC					; COMDAT

; 2571 : { if ( v1 < v2 ) 

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _v1$[ebp]
	mov	edx, DWORD PTR _v2$[ebp]

; 2572 :   { vpair_list[vpair_count].v[0] = v1;

	mov	eax, DWORD PTR _vpair_count
	push	esi
	mov	esi, DWORD PTR _vpair_list
	lea	eax, DWORD PTR [eax+eax*2]
	cmp	ecx, edx
	jae	SHORT $LN2@add_to_vpa
	mov	DWORD PTR [esi+eax*4], ecx

; 2573 :     vpair_list[vpair_count].v[1] = v2;

	mov	eax, DWORD PTR _vpair_count
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _vpair_list
	mov	DWORD PTR [eax+ecx*4+4], edx

; 2578 :   }
; 2579 :   vpair_count++;

	inc	DWORD PTR _vpair_count
	pop	esi

; 2580 : } // end add_to_vpair_list()

	pop	ebp
	ret	0
$LN2@add_to_vpa:

; 2574 :   }
; 2575 :   else
; 2576 :   { vpair_list[vpair_count].v[0] = v2;

	mov	DWORD PTR [esi+eax*4], edx

; 2577 :     vpair_list[vpair_count].v[1] = v1;

	mov	eax, DWORD PTR _vpair_count
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _vpair_list
	mov	DWORD PTR [eax+edx*4+4], ecx

; 2578 :   }
; 2579 :   vpair_count++;

	inc	DWORD PTR _vpair_count
	pop	esi

; 2580 : } // end add_to_vpair_list()

	pop	ebp
	ret	0
_add_to_vpair_list ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@LOFEEHCG@simplex_to_fe?3?5could?5not?5find?5ed@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_vpair_fe
EXTRN	_new_facetedge:PROC
EXTRN	_bsearch:PROC
;	COMDAT ??_C@_0DD@LOFEEHCG@simplex_to_fe?3?5could?5not?5find?5ed@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DD@LOFEEHCG@simplex_to_fe?3?5could?5not?5find?5ed@ DB 'simplex_to_'
	DB	'fe: could not find edge in vpair_list.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\model.c
CONST	ENDS
;	COMDAT _vpair_fe
_TEXT	SEGMENT
_key$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_f_id$ = 16						; size = 4
_vpair_fe PROC						; COMDAT

; 2587 : { struct vpair key, *spot;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 2588 :   facetedge_id fe,oldfe;
; 2589 :   if ( v1 < v2 ) { key.v[0] = v1; key.v[1] = v2; }

	mov	ebx, DWORD PTR _v1$[ebp]
	push	esi
	mov	esi, DWORD PTR _v2$[ebp]
	push	edi
	cmp	ebx, esi
	jae	SHORT $LN5@vpair_fe
	mov	DWORD PTR _key$[ebp], ebx
	mov	DWORD PTR _key$[ebp+4], esi
	jmp	SHORT $LN4@vpair_fe
$LN5@vpair_fe:

; 2590 :   else { key.v[0] = v2; key.v[1] = v1; }

	mov	DWORD PTR _key$[ebp], esi
	mov	DWORD PTR _key$[ebp+4], ebx
$LN4@vpair_fe:

; 2591 :   spot = bsearch(&key,vpair_list,vpair_count,sizeof(struct vpair),
; 2592 :       FCAST vpaircomp);

	mov	eax, DWORD PTR _vpair_count
	mov	ecx, DWORD PTR _vpair_list
	push	OFFSET _vpaircomp
	push	12					; 0000000cH
	push	eax
	push	ecx
	lea	edx, DWORD PTR _key$[ebp]
	push	edx
	call	_bsearch
	mov	edi, eax
	add	esp, 20					; 00000014H

; 2593 :   if ( spot == NULL )

	test	edi, edi
	jne	SHORT $LN3@vpair_fe

; 2594 :   { kb_error(1931,"simplex_to_fe: could not find edge in vpair_list.\n",
; 2595 :        RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DD@LOFEEHCG@simplex_to_fe?3?5could?5not?5find?5ed@
	push	1931					; 0000078bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN3@vpair_fe:

; 2596 :   }
; 2597 :   fe = new_facetedge((v1 < v2) ? f_id : inverse_id(f_id),spot->e);

	mov	eax, DWORD PTR _f_id$[ebp]
	cmp	ebx, esi
	jb	SHORT $LN9@vpair_fe
	xor	eax, 134217728				; 08000000H
$LN9@vpair_fe:
	mov	ecx, DWORD PTR [edi+8]
	push	ecx
	push	eax
	call	_new_facetedge

; 2598 :   oldfe = get_edge_fe(spot->e);

	mov	ecx, DWORD PTR _web+124
	mov	esi, eax
	mov	eax, DWORD PTR [edi+8]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	esp, 8
	test	ecx, ecx
	je	SHORT $LN12@vpair_fe
$LN13@vpair_fe:
	mov	ecx, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN12@vpair_fe
	xor	ecx, 134217728				; 08000000H
$LN12@vpair_fe:

; 2599 :   if ( valid_id(oldfe) )

	test	ecx, 268435456				; 10000000H
	je	$LN2@vpair_fe

; 2600 :   { facetedge_id tempfe = get_next_facet(oldfe);

	mov	edi, DWORD PTR _web+460
	mov	edx, ecx
	mov	eax, ecx
	shr	edx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	and	edx, 1
	mov	eax, DWORD PTR [edi+eax*4]
	je	SHORT $LN17@vpair_fe
	mov	edi, DWORD PTR [eax+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN16@vpair_fe
$LN17@vpair_fe:
	mov	edi, DWORD PTR [eax+40]
$LN16@vpair_fe:

; 2601 :     set_next_facet(oldfe,fe);

	test	edx, edx
	je	SHORT $LN21@vpair_fe
	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [eax+36], edx
	jmp	SHORT $LN20@vpair_fe
$LN21@vpair_fe:
	mov	DWORD PTR [eax+40], esi
$LN20@vpair_fe:

; 2602 :     set_prev_facet(fe,oldfe);

	push	ecx
	push	esi
	call	_set_prev_facet
	add	esp, 8

; 2603 :     set_next_facet(fe,tempfe);

	test	esi, 268435456				; 10000000H
	je	SHORT $LN25@vpair_fe
	test	esi, 134217728				; 08000000H
	je	SHORT $LN26@vpair_fe
	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, edi
	xor	eax, 134217728				; 08000000H

; 2604 :     set_prev_facet(tempfe,fe);

	push	esi
	push	edi
	mov	DWORD PTR [ecx+36], eax
	call	_set_prev_facet
	add	esp, 8

; 2605 :   }
; 2606 :   else

	jmp	$LN36@vpair_fe

; 2603 :     set_next_facet(fe,tempfe);

$LN26@vpair_fe:
	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+40], edi
$LN25@vpair_fe:

; 2604 :     set_prev_facet(tempfe,fe);

	push	esi
	push	edi
	call	_set_prev_facet
	add	esp, 8

; 2605 :   }
; 2606 :   else

	jmp	SHORT $LN36@vpair_fe
$LN2@vpair_fe:

; 2607 :   { set_next_facet(fe,fe);

	test	esi, 268435456				; 10000000H
	je	SHORT $LN30@vpair_fe
	test	esi, 134217728				; 08000000H
	je	SHORT $LN31@vpair_fe
	mov	ecx, DWORD PTR _web+460
	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [eax+36], edx
	jmp	SHORT $LN30@vpair_fe
$LN31@vpair_fe:
	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+40], esi
$LN30@vpair_fe:

; 2608 :     set_prev_facet(fe,fe);

	push	esi
	push	esi
	call	_set_prev_facet

; 2609 :     set_edge_fe(spot->e,fe);

	mov	eax, DWORD PTR [edi+8]
	add	esp, 8
	mov	ecx, esi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN35@vpair_fe
	xor	ecx, 134217728				; 08000000H
$LN35@vpair_fe:
	mov	edx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+28], ecx
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN36@vpair_fe:

; 2610 :   }
; 2611 :   
; 2612 :   return (v1 < v2) ? fe : inverse_id(fe);

	cmp	ebx, DWORD PTR _v2$[ebp]
	jb	SHORT $LN38@vpair_fe
	xor	esi, 134217728				; 08000000H
$LN38@vpair_fe:

; 2613 : } // end vpair_fe()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	mov	eax, esi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_vpair_fe ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@IKMDFPKG@simplex_to_fe?3?5Surface?5is?5?$CFd?5dim@ ; `string'
PUBLIC	??_C@_0CL@BIIAFDJD@Surface?5is?5not?5in?5simplex?5repres@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_to_fe
EXTRN	_fe_reorder:PROC
EXTRN	_set_facet_fe:PROC
EXTRN	_new_edge:PROC
EXTRN	_qsort:PROC
EXTRN	_kb_calloc:PROC
EXTRN	_outstring:PROC
;	COMDAT ??_C@_0DL@IKMDFPKG@simplex_to_fe?3?5Surface?5is?5?$CFd?5dim@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DL@IKMDFPKG@simplex_to_fe?3?5Surface?5is?5?$CFd?5dim@ DB 'simplex_'
	DB	'to_fe: Surface is %d dimensional; must be 1 or 2.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BIIAFDJD@Surface?5is?5not?5in?5simplex?5repres@
CONST	SEGMENT
??_C@_0CL@BIIAFDJD@Surface?5is?5not?5in?5simplex?5repres@ DB 'Surface is '
	DB	'not in simplex representation.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\model.c
CONST	ENDS
;	COMDAT _simplex_to_fe
_TEXT	SEGMENT
tv901 = -36						; size = 4
tv775 = -32						; size = 4
tv885 = -28						; size = 4
tv869 = -24						; size = 4
_i$ = -24						; size = 4
tv1030 = -20						; size = 4
_tailv$91138 = -20					; size = 4
_f_id$ = -20						; size = 4
_keypair$91139 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_simplex_to_fe PROC					; COMDAT

; 2616 : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2617 :   facet_id f_id;
; 2618 :   edge_id e_id;
; 2619 : 
; 2620 :   /* Check surface properties */
; 2621 :   if ( web.representation != SIMPLEX ) 

	cmp	DWORD PTR _web+624, 3
	je	SHORT $LN34@simplex_to

; 2622 :   { outstring("Surface is not in simplex representation.\n");

	push	OFFSET ??_C@_0CL@BIIAFDJD@Surface?5is?5not?5in?5simplex?5repres@
	call	_outstring
	add	esp, 4

; 2691 :   }
; 2692 : 
; 2693 : } /* end simplex_to_fe */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@simplex_to:

; 2623 :     return;
; 2624 :   }
; 2625 :   if ( web.dimension > 2 )

	mov	eax, DWORD PTR _web+620
	cmp	eax, 2
	jle	SHORT $LN92@simplex_to

; 2626 :   { sprintf(errmsg,
; 2627 :      "simplex_to_fe: Surface is %d dimensional; must be 1 or 2.\n",
; 2628 :         web.dimension);

	push	eax
	push	OFFSET ??_C@_0DL@IKMDFPKG@simplex_to_fe?3?5Surface?5is?5?$CFd?5dim@
	push	OFFSET _errmsg
	call	_sprintf

; 2629 :     kb_error(5366,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5366					; 000014f6H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN92@simplex_to:

; 2630 :   }
; 2631 : 
; 2632 : 
; 2633 :   /* Create new edges that may not be represented */
; 2634 :   /* First, make list of all vertex pairs needed */
; 2635 :   vpair_list = (struct vpair *)mycalloc(3*web.skel[FACET].count,
; 2636 :         sizeof(struct vpair));

	mov	eax, DWORD PTR _web+288
	push	ebx
	push	esi
	push	edi
	push	2636					; 00000a4cH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	lea	eax, DWORD PTR [eax+eax*2]
	push	12					; 0000000cH
	push	eax
	call	_kb_calloc
	mov	DWORD PTR _vpair_list, eax

; 2637 :   vpair_count = 0;
; 2638 : 
; 2639 :   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+272
	xor	ebx, ebx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vpair_count, ebx
	test	eax, 268435456				; 10000000H
	je	SHORT $LN93@simplex_to
	mov	esi, DWORD PTR _web+236
$LL32@simplex_to:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edi, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN31@simplex_to

; 2640 :   { vertex_id *v = get_facet_vertices(f_id);

	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax+304]

; 2641 :     add_to_vpair_list(v[0],v[1]);

	mov	edx, DWORD PTR [esi+ecx]
	add	esi, ecx
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	push	edx
	call	_add_to_vpair_list

; 2642 :     add_to_vpair_list(v[1],v[2]);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	ecx
	call	_add_to_vpair_list

; 2643 :     add_to_vpair_list(v[2],v[0]);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+8]
	push	edx
	push	eax
	call	_add_to_vpair_list
	mov	esi, DWORD PTR _web+236
	add	esp, 24					; 00000018H
$LN31@simplex_to:

; 2637 :   vpair_count = 0;
; 2638 : 
; 2639 :   FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL32@simplex_to
$LN93@simplex_to:

; 2644 :   }
; 2645 :   /* Sort list and get unique edges */
; 2646 :   qsort(vpair_list,vpair_count,sizeof(struct vpair),FCAST vpaircomp);

	mov	edx, DWORD PTR _vpair_count
	mov	eax, DWORD PTR _vpair_list
	push	OFFSET _vpaircomp
	push	12					; 0000000cH
	push	edx
	push	eax
	call	_qsort

; 2647 :   for ( i = 1, j = 0 ; i < vpair_count ; i++ )

	mov	eax, 1
	add	esp, 16					; 00000010H
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _vpair_count, eax
	jle	SHORT $LN89@simplex_to
	xor	esi, esi
	mov	DWORD PTR tv1030[ebp], 12		; 0000000cH
	npad	2
$LL96@simplex_to:

; 2648 :     if ( vpaircomp(vpair_list+j,vpair_list+i) < 0 )

	mov	eax, DWORD PTR _vpair_list
	mov	ecx, DWORD PTR tv1030[ebp]
	lea	edi, DWORD PTR [eax+ecx]
	lea	edx, DWORD PTR [esi+eax]
	push	edi
	push	edx
	call	_vpaircomp
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN26@simplex_to

; 2649 :       vpair_list[++j] = vpair_list[i];

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR _vpair_list
	inc	ebx
	lea	esi, DWORD PTR [ebx+ebx*2]
	add	esi, esi
	add	esi, esi
	mov	DWORD PTR [eax+esi], ecx
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+esi+4], edx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+esi+8], ecx
$LN26@simplex_to:

; 2647 :   for ( i = 1, j = 0 ; i < vpair_count ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv1030[ebp], 12		; 0000000cH
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _vpair_count
	jl	SHORT $LL96@simplex_to
$LN89@simplex_to:

; 2650 :   vpair_count = j+1;
; 2651 : 
; 2652 :   /* Record existing edges */
; 2653 :   FOR_ALL_EDGES(e_id)

	mov	edi, DWORD PTR _web+160
	mov	ecx, DWORD PTR _web+124
	inc	ebx
	mov	DWORD PTR _vpair_count, ebx
	test	edi, 268435456				; 10000000H
	je	$LN21@simplex_to
	npad	2
$LL23@simplex_to:
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN22@simplex_to

; 2654 :   { vertex_id headv = get_edge_headv(e_id);

	mov	eax, DWORD PTR _web+216
	mov	ebx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+ebx+304]
	mov	edx, edi
	shr	edx, 27					; 0000001bH
	add	eax, ecx
	and	edx, 1
	je	SHORT $LN40@simplex_to
	mov	ebx, DWORD PTR [eax]
	jmp	SHORT $LN39@simplex_to
$LN40@simplex_to:
	mov	ecx, DWORD PTR _web+636
	mov	ebx, DWORD PTR [eax+ecx*4]
$LN39@simplex_to:

; 2655 :     vertex_id tailv = get_edge_tailv(e_id);

	test	edx, edx
	je	SHORT $LN44@simplex_to
	mov	edx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _tailv$91138[ebp], eax
	jmp	SHORT $LN43@simplex_to
$LN44@simplex_to:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _tailv$91138[ebp], eax
$LN43@simplex_to:

; 2656 :     struct vpair keypair, *spot;
; 2657 :     if ( headv < tailv ) { keypair.v[0] = headv; keypair.v[1] = tailv; }

	cmp	ebx, eax
	jae	SHORT $LN18@simplex_to
	mov	DWORD PTR _keypair$91139[ebp], ebx
	mov	DWORD PTR _keypair$91139[ebp+4], eax
	jmp	SHORT $LN17@simplex_to
$LN18@simplex_to:

; 2658 :     else { keypair.v[0] = tailv; keypair.v[1] = headv; }

	mov	DWORD PTR _keypair$91139[ebp], eax
	mov	DWORD PTR _keypair$91139[ebp+4], ebx
$LN17@simplex_to:

; 2659 :     spot = bsearch(&keypair,vpair_list,vpair_count,sizeof(struct vpair),
; 2660 :                FCAST vpaircomp );

	mov	ecx, DWORD PTR _vpair_count
	mov	edx, DWORD PTR _vpair_list
	push	OFFSET _vpaircomp
	push	12					; 0000000cH
	push	ecx
	push	edx
	lea	eax, DWORD PTR _keypair$91139[ebp]
	push	eax
	call	_bsearch
	add	esp, 20					; 00000014H

; 2661 :     if ( spot )

	test	eax, eax
	je	SHORT $LN90@simplex_to

; 2662 :        spot->e = (headv < tailv) ? inverse_id(e_id) : e_id;

	cmp	ebx, DWORD PTR _tailv$91138[ebp]
	jae	SHORT $LN37@simplex_to
	xor	edi, 134217728				; 08000000H
$LN37@simplex_to:
	mov	DWORD PTR [eax+8], edi
$LN90@simplex_to:
	mov	ecx, DWORD PTR _web+124
$LN22@simplex_to:

; 2650 :   vpair_count = j+1;
; 2651 : 
; 2652 :   /* Record existing edges */
; 2653 :   FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR [esi+ecx]
	mov	edi, DWORD PTR [edx]
	test	edi, 268435456				; 10000000H
	jne	$LL23@simplex_to
$LN21@simplex_to:

; 2663 :   }
; 2664 :   /* Create needed new edges */
; 2665 :   for ( i = 0 ; i < vpair_count ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _vpair_count, edi
	jle	SHORT $LN13@simplex_to
	xor	esi, esi
	npad	4
$LL15@simplex_to:

; 2666 :     if ( !valid_id(vpair_list[i].e) )

	mov	eax, DWORD PTR _vpair_list
	test	DWORD PTR [eax+esi+8], 268435456	; 10000000H
	jne	SHORT $LN14@simplex_to

; 2667 :       vpair_list[i].e = new_edge(vpair_list[i].v[0],vpair_list[i].v[1],NULLID);

	mov	ecx, DWORD PTR [eax+esi+4]
	mov	edx, DWORD PTR [eax+esi]
	push	0
	push	ecx
	push	edx
	call	_new_edge
	mov	ecx, DWORD PTR _vpair_list
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+esi+8], eax
$LN14@simplex_to:

; 2663 :   }
; 2664 :   /* Create needed new edges */
; 2665 :   for ( i = 0 ; i < vpair_count ; i++ )

	inc	edi
	add	esi, 12					; 0000000cH
	cmp	edi, DWORD PTR _vpair_count
	jl	SHORT $LL15@simplex_to
	mov	ecx, DWORD PTR _web+124
$LN13@simplex_to:

; 2668 : 
; 2669 :   /* Create facet-edges */
; 2670 :   FOR_ALL_FACETS(f_id)

	mov	edi, DWORD PTR _web+272
	mov	DWORD PTR _f_id$[ebp], edi
	test	edi, 268435456				; 10000000H
	je	$LN9@simplex_to
	mov	ebx, DWORD PTR _web+236
	jmp	SHORT $LN11@simplex_to
	npad	5
$LL94@simplex_to:
	mov	edi, DWORD PTR _f_id$[ebp]
$LN11@simplex_to:
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [ecx+ebx]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv775[ebp], ecx
	je	$LN10@simplex_to

; 2671 :   { vertex_id *v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+ecx+304]

; 2672 :     facetedge_id fe1 = vpair_fe(v[0],v[1],f_id);

	mov	eax, DWORD PTR [esi+edx]
	add	esi, edx
	mov	edx, DWORD PTR [esi+4]
	push	edi
	push	edx
	push	eax
	call	_vpair_fe

; 2673 :     facetedge_id fe2 = vpair_fe(v[1],v[2],f_id);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	push	edi
	push	ecx
	push	edx
	mov	ebx, eax
	call	_vpair_fe

; 2674 :     facetedge_id fe3 = vpair_fe(v[2],v[0],f_id);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+8]
	mov	edi, eax
	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_vpair_fe

; 2675 :     set_next_edge(fe1,fe2);

	mov	ecx, ebx
	shr	ecx, 28					; 0000001cH
	add	esp, 36					; 00000024H
	and	ecx, 1
	mov	DWORD PTR tv869[ebp], ecx
	je	SHORT $LN95@simplex_to
	mov	esi, DWORD PTR _web+460
	mov	edx, ebx
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN48@simplex_to
	mov	ecx, edi
	xor	ecx, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+28], ecx
	mov	ecx, DWORD PTR tv869[ebp]
	jmp	SHORT $LN95@simplex_to
$LN48@simplex_to:
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+32], edi
$LN95@simplex_to:

; 2676 :     set_next_edge(fe2,fe3);

	mov	edx, edi
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	DWORD PTR tv885[ebp], edx
	je	SHORT $LN52@simplex_to
	mov	esi, DWORD PTR _web+460
	mov	edx, edi
	test	edi, 134217728				; 08000000H
	je	SHORT $LN53@simplex_to
	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+28], ecx
	mov	ecx, DWORD PTR tv869[ebp]
	jmp	SHORT $LN52@simplex_to
$LN53@simplex_to:
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+32], eax
$LN52@simplex_to:

; 2677 :     set_next_edge(fe3,fe1);

	mov	edx, eax
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	DWORD PTR tv901[ebp], edx
	je	SHORT $LN57@simplex_to
	mov	esi, DWORD PTR _web+460
	mov	edx, eax
	test	eax, 134217728				; 08000000H
	je	SHORT $LN58@simplex_to
	mov	ecx, ebx
	xor	ecx, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+28], ecx
	mov	ecx, DWORD PTR tv869[ebp]
	jmp	SHORT $LN57@simplex_to
$LN58@simplex_to:
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+32], ebx
$LN57@simplex_to:

; 2678 :     set_prev_edge(fe1,fe3);

	test	ecx, ecx
	je	SHORT $LN98@simplex_to
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN63@simplex_to
	mov	esi, DWORD PTR _web+460
	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+32], ecx
	jmp	SHORT $LN62@simplex_to
$LN63@simplex_to:
	mov	edx, DWORD PTR _web+460
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+28], eax
$LN62@simplex_to:
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
$LN98@simplex_to:

; 2679 :     set_prev_edge(fe2,fe1);

	cmp	DWORD PTR tv885[ebp], 0
	je	SHORT $LN99@simplex_to
	test	edi, 134217728				; 08000000H
	je	SHORT $LN68@simplex_to
	mov	esi, DWORD PTR _web+460
	mov	edx, ebx
	xor	edx, 134217728				; 08000000H
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [ecx+32], edx
	jmp	SHORT $LN67@simplex_to
$LN68@simplex_to:
	mov	ecx, DWORD PTR _web+460
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edx+28], ebx
$LN67@simplex_to:
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
$LN99@simplex_to:

; 2680 :     set_prev_edge(fe3,fe2);

	cmp	DWORD PTR tv901[ebp], 0
	je	SHORT $LN75@simplex_to
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN73@simplex_to
	xor	edi, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+32], edi
	jmp	SHORT $LN72@simplex_to
$LN73@simplex_to:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+28], edi
$LN72@simplex_to:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN75@simplex_to:

; 2681 :     set_facet_fe(f_id,fe1);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	ebx
	push	eax
	call	_set_facet_fe
	mov	ebx, DWORD PTR _web+236
	mov	ecx, DWORD PTR tv775[ebp]
	add	esp, 8
$LN10@simplex_to:

; 2668 : 
; 2669 :   /* Create facet-edges */
; 2670 :   FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR [ecx+ebx]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _f_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL94@simplex_to
	mov	ecx, DWORD PTR _web+124
$LN9@simplex_to:

; 2682 :   }
; 2683 : 
; 2684 :   /* flip representation */
; 2685 :   web.representation = (web.dimension==1) ? STRING : SOAPFILM;

	xor	eax, eax
	cmp	DWORD PTR _web+620, 1
	setne	al
	inc	eax
	mov	DWORD PTR _web+624, eax

; 2686 : 
; 2687 :   /* set links around edges */
; 2688 :   if ( web.representation == SOAPFILM )

	cmp	eax, 2
	jne	SHORT $LN100@simplex_to

; 2689 :   { FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	test	edx, 268435456				; 10000000H
	je	SHORT $LN100@simplex_to
	npad	6
$LL5@simplex_to:
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN4@simplex_to

; 2690 :       fe_reorder(e_id);

	push	edx
	call	_fe_reorder
	mov	ecx, DWORD PTR _web+124
	add	esp, 4
$LN4@simplex_to:

; 2689 :   { FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR [esi+ecx]
	mov	edx, DWORD PTR [edx]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL5@simplex_to
$LN100@simplex_to:

; 2691 :   }
; 2692 : 
; 2693 : } /* end simplex_to_fe */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_to_fe ENDP
_TEXT	ENDS
PUBLIC	_gaussq_
; Function compile flags: /Ogtp
;	COMDAT _gaussq_
_TEXT	SEGMENT
_muzero$ = -28						; size = 8
tv729 = -20						; size = 8
_t1$ = -20						; size = 8
_d__1$ = -20						; size = 8
_gam$ = -12						; size = 8
tv421 = -4						; size = 4
_kind$ = 8						; size = 4
tv426 = 12						; size = 4
_n$ = 12						; size = 4
_alpha$ = 16						; size = 4
_beta$ = 20						; size = 4
tv440 = 24						; size = 4
_kpts$ = 24						; size = 4
_ierr$ = 28						; size = 4
_endpts$ = 28						; size = 4
_b$ = 32						; size = 4
_t$ = 36						; size = 4
_w$ = 40						; size = 4
_gaussq_ PROC						; COMDAT

; 1253 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1254 :      /* System generated locals */
; 1255 :      integer i__1;
; 1256 :      doublereal d__1;
; 1257 : 
; 1258 : 
; 1259 :      /* Local variables */
; 1260 :      integer ierr, i;
; 1261 :      doublereal t1;
; 1262 :      doublereal muzero, gam;
; 1263 : 
; 1264 : 
; 1265 : /*              this set of routines computes the nodes t(j) and weights */
; 1266 : /*          w(j) for gaussian-type quadrature rules with pre-assigned */
; 1267 : /*          nodes.  these are used when one wishes to approximate */
; 1268 : 
; 1269 : /*                      integral (from a to b)  f(x) w(x) dx */
; 1270 : 
; 1271 : /*                                        n */
; 1272 : /*          by                         sum w  f(t ) */
; 1273 : /*                                      j=1  j     j */
; 1274 : 
; 1275 : /*          (note w(x) and w(j) have no connection with each other.) */
; 1276 : /*          here w(x) is one of six possible non-negative weight */
; 1277 : /*          functions (listed below), and f(x) is the */
; 1278 : /*          function to be integrated.  gaussian quadrature is particularly 
; 1279 : */
; 1280 : /*          useful on infinite intervals (with appropriate weight */
; 1281 : /*          functions), since then other techniques often fail. */
; 1282 : 
; 1283 : /*              associated with each weight function w(x) is a set of */
; 1284 : /*          orthogonal polynomials.  the nodes t(j) are just the zeroes */
; 1285 : /*          of the proper n-th degree polynomial. */
; 1286 : 
; 1287 : /*      input parameters (all real numbers are in REAL precision) */
; 1288 : 
; 1289 : /*          kind      an integer between 1 and 6 giving the type of */
; 1290 : /*                      quadrature rule: */
; 1291 : 
; 1292 : /*          kind = 1:  legendre quadrature, w(x) = 1 on (-1, 1) */
; 1293 : /*          kind = 2:  chebyshev quadrature of the first kind */
; 1294 : /*                         w(x) = 1/sqrt(1 - x*x) on (-1, +1) */
; 1295 : /*          kind = 3:  chebyshev quadrature of the second kind */
; 1296 : /*                         w(x) = sqrt(1 - x*x) on (-1, 1) */
; 1297 : /*          kind = 4:  hermite quadrature, w(x) = exp(-x*x) on */
; 1298 : /*                         (-infinity, +infinity) */
; 1299 : /*          kind = 5:  jacobi quadrature, w(x) = (1-x)**alpha * (1+x)** */
; 1300 : /*                         beta on (-1, 1), alpha, beta .gt. -1. */
; 1301 : /*                         note: kind=2 and 3 are a special case of this. */
; 1302 : /*          kind = 6:  generalized laguerre quadrature, w(x) = exp(-x)* */
; 1303 : /*                         x**alpha on (0, +infinity), alpha .gt. -1 */
; 1304 : 
; 1305 : /*          n          the number of points used for the quadrature rule */
; 1306 : /*          alpha     real parameter used only for gauss-jacobi and gauss- */
; 1307 : /*                      laguerre quadrature (otherwise use 0.d0). */
; 1308 : /*          beta      real parameter used only for gauss-jacobi quadrature-- 
; 1309 : */
; 1310 : /*                      (otherwise use 0.d0) */
; 1311 : /*          kpts      (integer) normally 0, unless the left or right end- */
; 1312 : /*                      point (or both) of the interval is required to be a */
; 1313 : /*                      node (this is called gauss-radau or gauss-lobatto */
; 1314 : /*                      quadrature).  then kpts is the number of fixed */
; 1315 : /*                      endpoints (1 or 2). */
; 1316 : /*          endpts    real array of length 2.  contains the values of */
; 1317 : /*                      any fixed endpoints, if kpts = 1 or 2. */
; 1318 : /*          b          real scratch array of length n */
; 1319 : 
; 1320 : /*      output parameters (both REAL precision arrays of length n) */
; 1321 : 
; 1322 : /*          t          will contain the desired nodes. */
; 1323 : /*          w          will contain the desired weights w(j). */
; 1324 : 
; 1325 : /*      underflow may sometimes occur, but is harmless. */
; 1326 : 
; 1327 : /*      references */
; 1328 : /*          1.  golub, g. h., and welsch, j. h., 
; 1329 :                 "calculation of gaussian quadrature rules," 
; 1330 :                   mathematics of computation 23 (april, */
; 1331 : /*                1969), pp. 221-230. */
; 1332 : /*          2.  golub, g. h., "some modified matrix eigenvalue problems," */
; 1333 : /*                siam review 15 (april, 1973), pp. 318-334 (section 7). */
; 1334 : /*          3.  stroud and secrest, gaussian quadrature formulas, prentice- 
; 1335 : */
; 1336 : /*                hall, englewood cliffs, n.j., 1966. */
; 1337 : 
; 1338 : /*          original version 20 jan 1975 from stanford */
; 1339 : /*          modified 21 dec 1983 by eric grosse */
; 1340 : /*             imtql2 => gausq2 */
; 1341 : /*             hex constant => d1mach (from core library) */
; 1342 : /*             compute pi using datan */
; 1343 : /*             removed accuracy claims, description of method */
; 1344 : /*             added single precision version */
; 1345 : 
; 1346 : 
; 1347 :      /* Parameter adjustments */
; 1348 :      --w;
; 1349 :      --t;
; 1350 :      --b;
; 1351 :      --endpts;
; 1352 : 
; 1353 :      /* Function Body */
; 1354 :      class_(kind, n, alpha, beta, &b[1], &t[1], &muzero);

	mov	ecx, DWORD PTR _beta$[ebp]
	mov	edx, DWORD PTR _alpha$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _t$[ebp]
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	push	edi
	mov	edi, DWORD PTR _b$[ebp]
	mov	eax, 8
	sub	DWORD PTR _w$[ebp], eax
	sub	DWORD PTR _endpts$[ebp], eax
	sub	ebx, eax
	sub	edi, eax
	mov	DWORD PTR _t$[ebp], ebx
	add	ebx, eax
	mov	DWORD PTR _b$[ebp], edi
	add	edi, eax
	lea	eax, DWORD PTR _muzero$[ebp]
	push	eax
	mov	eax, DWORD PTR _kind$[ebp]
	push	ebx
	push	edi
	push	ecx
	push	edx
	push	esi
	push	eax
	mov	DWORD PTR tv421[ebp], edi
	call	_class_

; 1355 : 
; 1356 : /*              the matrix of coefficients is assumed to be symmetric. */
; 1357 : /*              the array t contains the diagonal elements, the array */
; 1358 : /*              b the off-diagonal elements. */
; 1359 : /*              make appropriate changes in the lower right 2 by 2 */
; 1360 : /*              submatrix. */
; 1361 : 
; 1362 :      if (*kpts == 0) {

	mov	ecx, DWORD PTR _kpts$[ebp]
	mov	eax, DWORD PTR [ecx]
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	$L100$90264

; 1374 :      goto L100;
; 1375 : 
; 1376 : /*              if kpts=2, t(n) and b(n-1) must be recomputed */
; 1377 : 
; 1378 : L50:
; 1379 :      gam = solve_(&endpts[1], n, &t[1], &b[1]);

	push	edi
	push	ebx
	push	esi
	cmp	eax, 2
	jne	SHORT $LN7@gaussq_
	mov	eax, DWORD PTR _endpts$[ebp]
	add	eax, 8
	push	eax
$L50$90266:
	mov	DWORD PTR tv426[ebp], eax
	call	_solve_
	fstp	QWORD PTR _gam$[ebp]

; 1380 :      t1 = (endpts[1] - endpts[2]) / (solve_(&endpts[2], n, &t[1], &b[1]) - gam)
; 1381 :                 ;

	mov	edx, DWORD PTR tv426[ebp]
	mov	eax, DWORD PTR _endpts$[ebp]
	fld	QWORD PTR [edx]
	fsub	QWORD PTR [eax+16]
	push	edi
	add	eax, 16					; 00000010H
	push	ebx
	push	esi
	fstp	QWORD PTR tv729[ebp]
	push	eax
	call	_solve_
	fsub	QWORD PTR _gam$[ebp]
	add	esp, 32					; 00000020H
	fdivr	QWORD PTR tv729[ebp]
	fst	QWORD PTR _t1$[ebp]

; 1382 :      b[*n - 1] = sqrt(t1);

	call	__CIsqrt
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _b$[ebp]

; 1383 :      t[*n] = endpts[1] + gam * t1;

	mov	edx, DWORD PTR tv426[ebp]
	fstp	QWORD PTR [ecx+eax*8-8]
	fld	QWORD PTR _t1$[ebp]
	mov	eax, DWORD PTR [esi]
	fmul	QWORD PTR _gam$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [ecx+eax*8]
	jmp	SHORT $L100$90264
$LN7@gaussq_:

; 1363 :           goto L100;
; 1364 :      }
; 1365 :      if (*kpts == 2) {
; 1366 :           goto L50;
; 1367 :      }
; 1368 : 
; 1369 : /*              if kpts=1, only t(n) must be changed */
; 1370 : 
; 1371 : /* Computing 2nd power */
; 1372 :      d__1 = b[*n - 1];

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR _b$[ebp]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	fld	QWORD PTR [eax+edx-8]
	mov	DWORD PTR tv440[ebp], eax

; 1373 :      t[*n] = solve_(&endpts[1], n, &t[1], &b[1]) * (d__1 * d__1) + endpts[1];

	mov	eax, DWORD PTR _endpts$[ebp]
	fstp	QWORD PTR _d__1$[ebp]
	add	eax, 8
	push	eax
	mov	DWORD PTR tv426[ebp], eax
	call	_solve_
	fld	QWORD PTR _d__1$[ebp]
	mov	eax, DWORD PTR tv426[ebp]
	fmul	ST(0), ST(0)
	mov	ecx, DWORD PTR tv440[ebp]
	mov	edx, DWORD PTR _t$[ebp]
	fmulp	ST(1), ST(0)
	add	esp, 16					; 00000010H
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [ecx+edx]
$L100$90264:

; 1384 : 
; 1385 : /*              note that the indices of the elements of b run from 1 to n-1 
; 1386 : */
; 1387 : /*              and thus the value of b(n) is arbitrary. */
; 1388 : /*              now compute the eigenvalues of the symmetric tridiagonal */
; 1389 : /*              matrix, which has been modified as necessary. */
; 1390 : /*              the method used is a ql-type method with origin shifting */
; 1391 : 
; 1392 : L100:
; 1393 :      w[1] = 1.;

	mov	ecx, DWORD PTR _w$[ebp]
	fld1
	lea	edx, DWORD PTR [ecx+8]
	fstp	QWORD PTR [edx]

; 1394 :      i__1 = *n;

	mov	eax, DWORD PTR [esi]

; 1395 :      for (i = 2; i <= i__1; ++i) {

	cmp	eax, 2
	jl	SHORT $LN6@gaussq_

; 1384 : 
; 1385 : /*              note that the indices of the elements of b run from 1 to n-1 
; 1386 : */
; 1387 : /*              and thus the value of b(n) is arbitrary. */
; 1388 : /*              now compute the eigenvalues of the symmetric tridiagonal */
; 1389 : /*              matrix, which has been modified as necessary. */
; 1390 : /*              the method used is a ql-type method with origin shifting */
; 1391 : 
; 1392 : L100:
; 1393 :      w[1] = 1.;

	lea	edi, DWORD PTR [ecx+16]
	lea	ecx, DWORD PTR [eax-1]
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	rep stosd
	mov	edi, DWORD PTR tv421[ebp]
$LN6@gaussq_:

; 1396 : /* L105: */
; 1397 :           w[i] = 0.;
; 1398 :      }
; 1399 : 
; 1400 :      gausq2_(n, &t[1], &b[1], &w[1], &ierr);

	lea	eax, DWORD PTR _ierr$[ebp]
	push	eax
	push	edx
	push	edi
	push	ebx
	push	esi
	call	_gausq2_

; 1401 : 
; 1402 :      i__1 = *n;
; 1403 :      for (i = 1; i <= i__1; ++i) {

	fld	QWORD PTR _muzero$[ebp]
	mov	esi, DWORD PTR [esi]
	mov	edi, DWORD PTR _w$[ebp]
	add	esp, 20					; 00000014H
	mov	ecx, 1
	cmp	esi, 4
	jl	SHORT $LC16@gaussq_

; 1396 : /* L105: */
; 1397 :           w[i] = 0.;
; 1398 :      }
; 1399 : 
; 1400 :      gausq2_(n, &t[1], &b[1], &w[1], &ierr);

	mov	edx, esi
	shr	edx, 2
	lea	eax, DWORD PTR [edi+24]
	lea	ecx, DWORD PTR [edx*4+1]

; 1401 : 
; 1402 :      i__1 = *n;
; 1403 :      for (i = 1; i <= i__1; ++i) {

$LN17@gaussq_:

; 1404 : /* L110: */
; 1405 :           w[i] = muzero * w[i] * w[i];

	fld	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	edx
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [eax-48]
	fstp	QWORD PTR [eax-48]
	fld	QWORD PTR [eax-40]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	ST(0)
	fmul	QWORD PTR [eax-32]
	fmul	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [eax-24]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN17@gaussq_
$LC16@gaussq_:

; 1401 : 
; 1402 :      i__1 = *n;
; 1403 :      for (i = 1; i <= i__1; ++i) {

	cmp	ecx, esi
	jg	SHORT $LN27@gaussq_
$LC3@gaussq_:

; 1404 : /* L110: */
; 1405 :           w[i] = muzero * w[i] * w[i];

	fld	QWORD PTR [edi+ecx*8]
	inc	ecx
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [edi+ecx*8-8]
	fstp	QWORD PTR [edi+ecx*8-8]
	cmp	ecx, esi
	jle	SHORT $LC3@gaussq_
$LN27@gaussq_:
	pop	edi

; 1401 : 
; 1402 :      i__1 = *n;
; 1403 :      for (i = 1; i <= i__1; ++i) {

	fstp	ST(0)
	pop	esi

; 1406 :      }
; 1407 : 
; 1408 :      return 0;

	xor	eax, eax
	pop	ebx

; 1409 : } /* gaussq_ */

	mov	esp, ebp
	pop	ebp
	ret	0
_gaussq_ ENDP
_TEXT	ENDS
PUBLIC	_gauss_jacobi
; Function compile flags: /Ogtp
;	COMDAT _gauss_jacobi
_TEXT	SEGMENT
_endpts$ = -32						; size = 16
_alpha$ = -16						; size = 8
_kind$ = -8						; size = 4
_kpts$ = -4						; size = 4
_n$ = 8							; size = 4
_beta$ = 12						; size = 8
_t$ = 20						; size = 4
_w$ = 24						; size = 4
_gauss_jacobi PROC					; COMDAT

; 1180 : { int kind = 5; /* jacobi, w(x) = (1-x)**alpha * (1+x)**beta on (-1,1) */

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1181 :   REAL alpha  = 0.0;
; 1182 :   int kpts = 0; /*  endpoint nodes */
; 1183 :   REAL endpts[2]; /* fixed endpint nodes */
; 1184 :   REAL *b; /* real scratch array of length n */
; 1185 : 
; 1186 :   b = (REAL*)temp_calloc(n,sizeof(REAL));

	mov	eax, DWORD PTR _n$[ebp]
	fldz
	push	esi
	fstp	QWORD PTR _alpha$[ebp]
	push	1186					; 000004a2H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	8
	push	eax
	mov	DWORD PTR _kind$[ebp], 5
	mov	DWORD PTR _kpts$[ebp], 0
	call	_kb_temp_calloc

; 1187 :   gaussq_(&kind, &n, &alpha, &beta, &kpts, endpts, b, t, w);

	mov	ecx, DWORD PTR _w$[ebp]
	mov	edx, DWORD PTR _t$[ebp]
	push	ecx
	push	edx
	mov	esi, eax
	push	esi
	lea	eax, DWORD PTR _endpts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _kpts$[ebp]
	push	ecx
	lea	edx, DWORD PTR _beta$[ebp]
	push	edx
	lea	eax, DWORD PTR _alpha$[ebp]
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	lea	edx, DWORD PTR _kind$[ebp]
	push	edx
	call	_gaussq_

; 1188 :   temp_free((char*)b);

	push	esi
	call	_temp_free
	add	esp, 56					; 00000038H
	pop	esi

; 1189 : } // end gauss_jacobi()

	mov	esp, ebp
	pop	ebp
	ret	0
_gauss_jacobi ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@KDCKHFBN@too?5few?5points?4?6?$AA@	; `string'
PUBLIC	_w$GSCopy$
PUBLIC	_x$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_quadrature
EXTRN	_exit:PROC
EXTRN	_puts:PROC
;	COMDAT ??_C@_0BB@KDCKHFBN@too?5few?5points?4?6?$AA@
CONST	SEGMENT
??_C@_0BB@KDCKHFBN@too?5few?5points?4?6?$AA@ DB 'too few points.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _simplex_quadrature
_TEXT	SEGMENT
_w$GSCopy$ = -436					; size = 4
_gj_w$ = -432						; size = 4
_x$GSCopy$ = -428					; size = 4
_gj_x$ = -424						; size = 4
_N$ = -420						; size = 4
tv2206 = -416						; size = 4
_count$ = -416						; size = 4
tv4181 = -412						; size = 4
tv3604 = -412						; size = 4
_n$ = -412						; size = 4
tv4541 = -408						; size = 4
tv4524 = -408						; size = 4
tv4521 = -408						; size = 4
tv4518 = -408						; size = 4
tv4516 = -408						; size = 4
tv4514 = -408						; size = 4
tv4512 = -408						; size = 4
tv4510 = -408						; size = 4
tv4050 = -408						; size = 4
tv2184 = -408						; size = 4
_iter$ = -404						; size = 400
__$ArrayPad$ = -4					; size = 4
_dim$ = 8						; size = 4
_order$ = 12						; size = 4
_maxpt$ = 16						; size = 4
_x$ = 20						; size = 4
_w$ = 24						; size = 4
_simplex_quadrature PROC				; COMDAT

; 1106 : { int N = 1+order/2;  /* points needed in 1D integration */

	push	ebp
	mov	ebp, esp
	sub	esp, 436				; 000001b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1120 : 
; 1121 :   gj_x = dmatrix(0,dim-1,0,N);

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _x$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _order$[ebp]
	push	ebx
	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1
	inc	ebx
	push	esi
	mov	esi, DWORD PTR _dim$[ebp]
	push	edi
	mov	DWORD PTR _w$GSCopy$[ebp], ecx
	mov	DWORD PTR _N$[ebp], ebx
	cmp	ebx, 2
	jge	SHORT $LN26@simplex_qu

; 1107 :   int bsize;  /* number of total points */
; 1108 :   int iter[100]; /* iteration variables */
; 1109 :   int n;
; 1110 :   int count;
; 1111 :   int depth;
; 1112 :   REAL **gj_x;  /* gauss-jacobi nodes    [alpha][j] */
; 1113 :   REAL **gj_w;  /* gauss-jacobi weights [alpha][j] */
; 1114 :   REAL coeff; /* simplex factor */
; 1115 : 
; 1116 :   if ( N < 2 ) N = 2;  /* the lowest we have */

	mov	ebx, 2
	mov	DWORD PTR _N$[ebp], ebx
$LN26@simplex_qu:

; 1117 : 
; 1118 :   for ( n = 0, bsize = 1 ; n < dim ; n++ ) bsize *= N;

	mov	eax, 1
	test	esi, esi
	jle	SHORT $LN23@simplex_qu
	mov	ecx, esi
$LL25@simplex_qu:
	imul	eax, ebx
	dec	ecx
	jne	SHORT $LL25@simplex_qu
$LN23@simplex_qu:

; 1119 :   if ( bsize > maxpt ) { puts("too few points.\n"); exit(1); }

	cmp	eax, DWORD PTR _maxpt$[ebp]
	jle	SHORT $LN22@simplex_qu
	push	OFFSET ??_C@_0BB@KDCKHFBN@too?5few?5points?4?6?$AA@
	call	_puts
	add	esp, 4
	push	1
	call	_exit
$LN99@simplex_qu:
$LN22@simplex_qu:

; 1120 : 
; 1121 :   gj_x = dmatrix(0,dim-1,0,N);

	push	1121					; 00000461H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	ebx
	push	0
	lea	edi, DWORD PTR [esi-1]
	push	edi
	push	0
	call	_kb_dmatrix

; 1122 :   gj_w = dmatrix(0,dim-1,0,N);

	push	1122					; 00000462H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	ebx
	push	0
	push	edi
	push	0
	mov	DWORD PTR _gj_x$[ebp], eax
	call	_kb_dmatrix
	add	esp, 48					; 00000030H
	mov	DWORD PTR _gj_w$[ebp], eax

; 1123 : 
; 1124 :   /* get gauss-jacobi info */
; 1125 :   for ( n = 0 ; n < dim ; n++ )

	mov	DWORD PTR _n$[ebp], 0
	test	esi, esi
	jle	SHORT $LN19@simplex_qu
	mov	edi, DWORD PTR _gj_x$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv2184[ebp], eax
	jmp	SHORT $LN21@simplex_qu
$LL56@simplex_qu:
	mov	eax, DWORD PTR tv2184[ebp]
$LN21@simplex_qu:

; 1126 :      gauss_jacobi(N,(REAL)n,gj_x[n],gj_w[n]);

	mov	edx, DWORD PTR [eax+edi]
	fild	DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edi]
	push	edx
	push	eax
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ebx
	call	_gauss_jacobi
	mov	eax, DWORD PTR _n$[ebp]
	inc	eax
	add	esp, 20					; 00000014H
	add	edi, 4
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, esi
	jl	SHORT $LL56@simplex_qu
$LN19@simplex_qu:

; 1127 : 
; 1128 :   /* overall simplex factor */
; 1129 :   coeff = (REAL)(1 << ((dim*(dim+1))/2)); 

	lea	eax, DWORD PTR [esi+1]
	imul	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	mov	edx, 1
	shl	edx, cl

; 1130 :   for ( n = 1 ; n <= dim ; n++ ) coeff /= n;

	mov	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx
	mov	DWORD PTR tv4524[ebp], edx
	fild	DWORD PTR tv4524[ebp]
	cmp	esi, 8
	jl	$LC45@simplex_qu

; 1127 : 
; 1128 :   /* overall simplex factor */
; 1129 :   coeff = (REAL)(1 << ((dim*(dim+1))/2)); 

	mov	eax, 3
	lea	edx, DWORD PTR [esi-7]
	mov	DWORD PTR tv2206[ebp], eax

; 1130 :   for ( n = 1 ; n <= dim ; n++ ) coeff /= n;

$LN46@simplex_qu:
	fidiv	DWORD PTR _n$[ebp]
	lea	edi, DWORD PTR [eax-1]
	mov	DWORD PTR tv4521[ebp], edi
	lea	edi, DWORD PTR [eax+1]
	add	ecx, 8
	mov	DWORD PTR _n$[ebp], ecx
	fild	DWORD PTR tv4521[ebp]
	mov	DWORD PTR tv4518[ebp], edi
	lea	edi, DWORD PTR [eax+2]
	fdivp	ST(1), ST(0)
	fidiv	DWORD PTR tv2206[ebp]
	fild	DWORD PTR tv4518[ebp]
	mov	DWORD PTR tv4516[ebp], edi
	lea	edi, DWORD PTR [eax+3]
	fdivp	ST(1), ST(0)
	fild	DWORD PTR tv4516[ebp]
	mov	DWORD PTR tv4514[ebp], edi
	lea	edi, DWORD PTR [eax+4]
	fdivp	ST(1), ST(0)
	fild	DWORD PTR tv4514[ebp]
	mov	DWORD PTR tv4512[ebp], edi
	lea	edi, DWORD PTR [eax+5]
	add	eax, 8
	fdivp	ST(1), ST(0)
	mov	DWORD PTR tv2206[ebp], eax
	fild	DWORD PTR tv4512[ebp]
	mov	DWORD PTR tv4510[ebp], edi
	fdivp	ST(1), ST(0)
	fild	DWORD PTR tv4510[ebp]
	fdivp	ST(1), ST(0)
	cmp	ecx, edx
	jle	$LN46@simplex_qu
$LC45@simplex_qu:
	cmp	ecx, esi
	jg	SHORT $LN44@simplex_qu
$LC18@simplex_qu:
	fidiv	DWORD PTR _n$[ebp]
	inc	ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, esi
	jle	SHORT $LC18@simplex_qu
$LN44@simplex_qu:

; 1131 : 
; 1132 :   /* iteration over all N^dim points */
; 1133 :   /* a little tricky since nesting depth is not fixed */
; 1134 :   for ( n = 0 ; n < dim ; n++ ) iter[n] = 0;

	test	esi, esi
	jle	SHORT $LN15@simplex_qu
	mov	ecx, esi
	xor	eax, eax
	lea	edi, DWORD PTR _iter$[ebp]
	rep stosd
$LN15@simplex_qu:

; 1135 : 
; 1136 :   count = 0; /* points so far */

	mov	ecx, DWORD PTR _w$GSCopy$[ebp]
	fld1
	fld	QWORD PTR __real@3fe0000000000000
	mov	DWORD PTR _count$[ebp], 0
	mov	DWORD PTR tv4541[ebp], ecx
	jmp	SHORT $LN12@simplex_qu
$LN97@simplex_qu:

; 1157 :      }
; 1158 :   } while ( depth >= 0 );

	fxch	ST(1)
$LN12@simplex_qu:

; 1137 :   do
; 1138 :   { REAL prod;
; 1139 :      /* at bottom, do some work */
; 1140 :      /* weight */
; 1141 :      for ( w[count] = 1., n = 0 ; n < dim ; n++ )

	fxch	ST(1)
	xor	eax, eax
	fst	QWORD PTR [ecx]
	cmp	esi, 4
	jl	SHORT $LC48@simplex_qu
	mov	edx, DWORD PTR _gj_w$[ebp]
	lea	edx, DWORD PTR [edx+esi*4-8]
$LN49@simplex_qu:

; 1142 :         w[count] *= gj_w[dim-1-n][iter[n]];

	mov	edi, DWORD PTR _iter$[ebp+eax*4]
	mov	ebx, DWORD PTR [edx+4]
	fld	QWORD PTR [ebx+edi*8]
	mov	edi, DWORD PTR _iter$[ebp+eax*4+4]
	fmul	QWORD PTR [ecx]
	mov	ebx, DWORD PTR [edx]
	add	eax, 4
	sub	edx, 16					; 00000010H
	fst	QWORD PTR [ecx]
	fmul	QWORD PTR [ebx+edi*8]
	mov	edi, DWORD PTR _iter$[ebp+eax*4-8]
	mov	ebx, DWORD PTR [edx+12]
	fst	QWORD PTR [ecx]
	fmul	QWORD PTR [ebx+edi*8]
	mov	edi, DWORD PTR _iter$[ebp+eax*4-4]
	mov	ebx, DWORD PTR [edx+8]
	fst	QWORD PTR [ecx]
	fmul	QWORD PTR [ebx+edi*8]
	lea	edi, DWORD PTR [esi-3]
	fstp	QWORD PTR [ecx]
	cmp	eax, edi
	jl	SHORT $LN49@simplex_qu
	mov	ebx, DWORD PTR _N$[ebp]
$LC48@simplex_qu:

; 1137 :   do
; 1138 :   { REAL prod;
; 1139 :      /* at bottom, do some work */
; 1140 :      /* weight */
; 1141 :      for ( w[count] = 1., n = 0 ; n < dim ; n++ )

	cmp	eax, esi
	jge	SHORT $LN47@simplex_qu
	mov	edi, DWORD PTR _gj_w$[ebp]
	mov	edx, esi
	sub	edx, eax
	lea	edx, DWORD PTR [edi+edx*4-4]
$LC9@simplex_qu:

; 1142 :         w[count] *= gj_w[dim-1-n][iter[n]];

	mov	edi, DWORD PTR _iter$[ebp+eax*4]
	mov	ebx, DWORD PTR [edx]
	fld	QWORD PTR [ebx+edi*8]
	inc	eax
	fmul	QWORD PTR [ecx]
	sub	edx, 4
	fstp	QWORD PTR [ecx]
	cmp	eax, esi
	jl	SHORT $LC9@simplex_qu

; 1137 :   do
; 1138 :   { REAL prod;
; 1139 :      /* at bottom, do some work */
; 1140 :      /* weight */
; 1141 :      for ( w[count] = 1., n = 0 ; n < dim ; n++ )

	mov	ebx, DWORD PTR _N$[ebp]
$LN47@simplex_qu:

; 1143 :      w[count] /= coeff;

	fld	QWORD PTR [ecx]

; 1144 :      /* coordinates */
; 1145 :      for ( prod = 1., n = 0, x[count][dim] = 1.0 ; n < dim ; n++ )

	mov	edi, DWORD PTR _x$GSCopy$[ebp]
	fdiv	ST(0), ST(3)
	mov	edx, DWORD PTR _count$[ebp]
	mov	edi, DWORD PTR [edi+edx*4]
	xor	eax, eax
	fstp	QWORD PTR [ecx]
	fld	ST(0)
	fxch	ST(1)
	fst	QWORD PTR [edi+esi*8]
	cmp	esi, 4
	jl	$LC51@simplex_qu
	mov	ecx, DWORD PTR _x$GSCopy$[ebp]
	mov	edi, DWORD PTR _gj_x$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	lea	edi, DWORD PTR [edi+esi*4-8]
	lea	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR tv3604[ebp], edi
$LN52@simplex_qu:

; 1146 :      { x[count][n] = (1-gj_x[dim-1-n][iter[n]])/2*prod;

	fld	ST(0)
	mov	ebx, DWORD PTR tv3604[ebp]
	mov	ebx, DWORD PTR [ebx+4]
	mov	edi, DWORD PTR _iter$[ebp+eax*4]
	fsub	QWORD PTR [ebx+edi*8]
	lea	edi, DWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR tv3604[ebp]
	mov	ebx, DWORD PTR [ebx]
	fmul	ST(0), ST(3)

; 1148 :         prod *= 1 - (1-gj_x[dim-1-n][iter[n]])/2;

	add	eax, 4
	add	edx, 32					; 00000020H
	fmul	ST(0), ST(2)
	fst	QWORD PTR [edx-48]
	fsubr	QWORD PTR [ecx+esi*8]
	fstp	QWORD PTR [ecx+esi*8]
	fld	ST(0)
	fsub	QWORD PTR [edi]
	mov	edi, DWORD PTR _iter$[ebp+eax*4-12]
	lea	edi, DWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR tv3604[ebp]
	fmul	ST(0), ST(3)
	mov	ebx, DWORD PTR [ebx-4]
	fsubr	ST(0), ST(1)
	fmulp	ST(2), ST(0)
	fld	ST(0)
	fsub	QWORD PTR [edi]
	fmul	ST(0), ST(3)
	fmul	ST(0), ST(2)
	fst	QWORD PTR [edx-40]
	fsubr	QWORD PTR [ecx+esi*8]
	fstp	QWORD PTR [ecx+esi*8]
	fld	ST(0)
	fsub	QWORD PTR [edi]
	mov	edi, DWORD PTR _iter$[ebp+eax*4-8]
	lea	edi, DWORD PTR [ebx+edi*8]
	mov	ebx, DWORD PTR tv3604[ebp]
	fmul	ST(0), ST(3)
	mov	ebx, DWORD PTR [ebx-8]
	sub	DWORD PTR tv3604[ebp], 16		; 00000010H
	fsubr	ST(0), ST(1)
	fmulp	ST(2), ST(0)
	fld	ST(0)
	fsub	QWORD PTR [edi]
	fmul	ST(0), ST(3)
	fmul	ST(0), ST(2)
	fst	QWORD PTR [edx-32]
	fsubr	QWORD PTR [ecx+esi*8]
	fstp	QWORD PTR [ecx+esi*8]
	fld	ST(0)
	fsub	QWORD PTR [edi]
	mov	edi, DWORD PTR _iter$[ebp+eax*4-4]
	lea	edi, DWORD PTR [ebx+edi*8]
	fmul	ST(0), ST(3)
	fsubr	ST(0), ST(1)
	fmulp	ST(2), ST(0)
	fld	ST(0)
	fsub	QWORD PTR [edi]
	fmul	ST(0), ST(3)
	fmul	ST(0), ST(2)
	fst	QWORD PTR [edx-24]
	fsubr	QWORD PTR [ecx+esi*8]
	fstp	QWORD PTR [ecx+esi*8]
	fld	ST(0)
	fsub	QWORD PTR [edi]
	lea	edi, DWORD PTR [esi-3]
	fmul	ST(0), ST(3)
	fsubr	ST(0), ST(1)
	fmulp	ST(2), ST(0)
	cmp	eax, edi
	jl	$LN52@simplex_qu
	mov	ebx, DWORD PTR _N$[ebp]
	mov	ecx, DWORD PTR tv4541[ebp]
$LC51@simplex_qu:

; 1144 :      /* coordinates */
; 1145 :      for ( prod = 1., n = 0, x[count][dim] = 1.0 ; n < dim ; n++ )

	cmp	eax, esi
	jge	SHORT $LN86@simplex_qu
	mov	edx, DWORD PTR _x$GSCopy$[ebp]
	mov	edi, DWORD PTR _count$[ebp]
	mov	edi, DWORD PTR [edx+edi*4]
	mov	ebx, DWORD PTR _gj_x$[ebp]
	lea	edx, DWORD PTR [edi+eax*8]
	mov	DWORD PTR tv4050[ebp], edx
	mov	edx, esi
	sub	edx, eax
	lea	edx, DWORD PTR [ebx+edx*4-4]
	mov	DWORD PTR tv4181[ebp], edx
$LC6@simplex_qu:

; 1146 :      { x[count][n] = (1-gj_x[dim-1-n][iter[n]])/2*prod;

	mov	ebx, DWORD PTR tv4181[ebp]
	fld	ST(0)
	mov	ebx, DWORD PTR [ebx]
	mov	edx, DWORD PTR _iter$[ebp+eax*4]
	fsub	QWORD PTR [ebx+edx*8]
	lea	edx, DWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR tv4050[ebp]
	sub	DWORD PTR tv4181[ebp], 4
	fmul	ST(0), ST(3)
	inc	eax
	add	ebx, 8
	mov	DWORD PTR tv4050[ebp], ebx
	fmul	ST(0), ST(2)
	fst	QWORD PTR [ebx-8]

; 1147 :         x[count][dim] -= x[count][n];  /* barycentric */

	fsubr	QWORD PTR [edi+esi*8]
	fstp	QWORD PTR [edi+esi*8]

; 1148 :         prod *= 1 - (1-gj_x[dim-1-n][iter[n]])/2;

	fld	ST(0)
	fsub	QWORD PTR [edx]
	fmul	ST(0), ST(3)
	fsubr	ST(0), ST(1)
	fmulp	ST(2), ST(0)
	cmp	eax, esi
	jl	SHORT $LC6@simplex_qu

; 1144 :      /* coordinates */
; 1145 :      for ( prod = 1., n = 0, x[count][dim] = 1.0 ; n < dim ; n++ )

	mov	ebx, DWORD PTR _N$[ebp]
$LN86@simplex_qu:

; 1149 :      }
; 1150 :      count++;

	inc	DWORD PTR _count$[ebp]
	fstp	ST(1)

; 1151 : 
; 1152 :      depth = dim-1;

	lea	edx, DWORD PTR [esi-1]

; 1153 :      while ( ++iter[depth] >= N ) 

	mov	eax, DWORD PTR _iter$[ebp+edx*4]
	inc	eax
	add	ecx, 8
	mov	DWORD PTR tv4541[ebp], ecx
	mov	DWORD PTR _iter$[ebp+edx*4], eax
	cmp	eax, ebx
	jl	SHORT $LN11@simplex_qu
$LN3@simplex_qu:

; 1154 :      { iter[depth] = 0;  /* prepare for next descent */
; 1155 :         depth--;  /* back up a level */

	dec	edx
	mov	DWORD PTR _iter$[ebp+edx*4+4], 0

; 1156 :         if ( depth < 0 ) break; 

	js	SHORT $LN96@simplex_qu

; 1153 :      while ( ++iter[depth] >= N ) 

	mov	eax, DWORD PTR _iter$[ebp+edx*4]
	inc	eax
	mov	DWORD PTR _iter$[ebp+edx*4], eax
	cmp	eax, ebx
	jge	SHORT $LN3@simplex_qu
$LN11@simplex_qu:

; 1157 :      }
; 1158 :   } while ( depth >= 0 );

	test	edx, edx
	jns	$LN97@simplex_qu
$LN96@simplex_qu:

; 1159 : 
; 1160 :   free_matrix(gj_x);

	mov	eax, DWORD PTR _gj_x$[ebp]
	fstp	ST(0)
	fstp	ST(0)
	push	eax
	fstp	ST(0)
	call	_free_matrix

; 1161 :   free_matrix(gj_w);

	mov	ecx, DWORD PTR _gj_w$[ebp]
	push	ecx
	call	_free_matrix

; 1162 :   return count;
; 1163 : } // end simplex_quadrature()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, DWORD PTR _count$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN98@simplex_qu:
_simplex_quadrature ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@PBNGOMIE@Dimension?5too?5low?5in?5gauss_lagra@ ; `string'
PUBLIC	??_C@_0DH@JHKFALDJ@Surface?5dimension?5too?5high?5in?5ga@ ; `string'
PUBLIC	_dim$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_gauss_lagrange_setup
EXTRN	_bezier_flag:DWORD
EXTRN	_kb_dmatrix3:PROC
EXTRN	_free_matrix3:PROC
EXTRN	_grule:PROC
EXTRN	_gauss2Dwt1:QWORD
EXTRN	_gauss2Dpt1:BYTE
EXTRN	_gauss2Dwt2:BYTE
EXTRN	_gauss2Dpt2:BYTE
EXTRN	_gauss2Dwt5:BYTE
EXTRN	_gauss2Dpt5:BYTE
EXTRN	_gauss2Dwt6:BYTE
EXTRN	_gauss2Dpt6:BYTE
EXTRN	_gauss2Dwt8:BYTE
EXTRN	_gauss2Dpt8:BYTE
EXTRN	_gauss2Dwt11:BYTE
EXTRN	_gauss2Dpt11:BYTE
EXTRN	_gauss2Dwt13:BYTE
EXTRN	_gauss2Dpt13:BYTE
EXTRN	_KB_realloc:PROC
EXTRN	_gauss_lagrange:BYTE
EXTRN	_maxgaussorder:BYTE
;	COMDAT ??_C@_0CO@PBNGOMIE@Dimension?5too?5low?5in?5gauss_lagra@
CONST	SEGMENT
??_C@_0CO@PBNGOMIE@Dimension?5too?5low?5in?5gauss_lagra@ DB 'Dimension to'
	DB	'o low in gauss_lagrange_setup().', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@JHKFALDJ@Surface?5dimension?5too?5high?5in?5ga@
CONST	SEGMENT
??_C@_0DH@JHKFALDJ@Surface?5dimension?5too?5high?5in?5ga@ DB 'Surface dim'
	DB	'ension too high in gauss_lagrange_setup().', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _gauss_lagrange_setup
_TEXT	SEGMENT
_x$90549 = -180						; size = 4
_dim$GSCopy$ = -176					; size = 4
tv5092 = -172						; size = 4
_prod$90557 = -168					; size = 8
tv6219 = -164						; size = 4
tv5193 = -164						; size = 4
tv5182 = -160						; size = 4
tv5180 = -156						; size = 4
tv6363 = -152						; size = 4
tv6329 = -152						; size = 4
tv6283 = -152						; size = 4
_mm$90560 = -148					; size = 4
_n$ = -144						; size = 4
tv5970 = -140						; size = 4
tv5058 = -140						; size = 4
_j$ = -136						; size = 4
_gl$ = -132						; size = 4
_inx$90589 = -128					; size = 28
_inx$90550 = -128					; size = 28
_prodpart$90597 = -100					; size = 48
_prodpart$90558 = -52					; size = 48
_linx$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_dim$ = 8						; size = 4
_lagrange_order$ = 12					; size = 4
_gauss_order$ = 16					; size = 4
_gauss_lagrange_setup PROC				; COMDAT

; 1904 : { struct gauss_lag *gl;

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _dim$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _gauss_order$[ebp]

; 2088 :              }
; 2089 :              prod *= ((REAL)linx[i]-j)/(inx[i]-j);

	mov	DWORD PTR _dim$GSCopy$[ebp], ebx
	cmp	ebx, 6
	jle	SHORT $LN133@gauss_lagr

; 1905 :   int i,j,k,n;
; 1906 :   REAL *temp;
; 1907 :   int linx[MAXCOORD+1];
; 1908 : 
; 1909 :   if ( dim > MAXCOORD )
; 1910 :      kb_error(1812,"Surface dimension too high in gauss_lagrange_setup().\n",
; 1911 :           RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DH@JHKFALDJ@Surface?5dimension?5too?5high?5in?5ga@
	push	1812					; 00000714H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN133@gauss_lagr:

; 1912 : 
; 1913 :   if ( dim < 1 )

	cmp	ebx, 1
	jge	SHORT $LN132@gauss_lagr

; 1914 :      kb_error(1813,"Dimension too low in gauss_lagrange_setup().\n",
; 1915 :           RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CO@PBNGOMIE@Dimension?5too?5low?5in?5gauss_lagra@
	push	1813					; 00000715H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN132@gauss_lagr:

; 1916 : 
; 1917 :   if ( gauss_order > maxgaussorder[dim] )

	cmp	edi, DWORD PTR _maxgaussorder[ebx*4]
	jle	SHORT $LN131@gauss_lagr

; 1918 :   { gauss_lagrange[dim] = (struct gauss_lag *)kb_realloc(
; 1919 :        (char*)(gauss_lagrange[dim]),
; 1920 :        (gauss_order+1)*sizeof(struct gauss_lag));

	mov	ecx, DWORD PTR _gauss_lagrange[ebx*4]
	push	1920					; 00000780H
	lea	eax, DWORD PTR [edi+1]
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	shl	eax, 5
	push	eax
	push	ecx
	call	_KB_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gauss_lagrange[ebx*4], eax

; 1921 :     maxgaussorder[dim] = gauss_order;

	mov	DWORD PTR _maxgaussorder[ebx*4], edi
$LN131@gauss_lagr:

; 1922 :   }
; 1923 :          
; 1924 :   gl = &gauss_lagrange[dim][gauss_order];

	mov	esi, edi
	shl	esi, 5
	add	esi, DWORD PTR _gauss_lagrange[ebx*4]

; 1925 :   if ( gl->gausspt ) goto do_lagrange; 

	cmp	DWORD PTR [esi+8], 0
	mov	DWORD PTR _gl$[ebp], esi
	jne	$do_lagrange$90462

; 1926 : 
; 1927 :   /* first, do gauss points and weights */
; 1928 :   switch ( dim )

	mov	eax, ebx
	dec	eax
	je	$LN127@gauss_lagr
	dec	eax
	je	SHORT $LN123@gauss_lagr

; 2006 : 
; 2007 :          default: /* over 2 */
; 2008 :          { 
; 2009 :             int npts = 1+gauss_order/2; /* per dimension */

	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	inc	eax

; 2010 :             for ( i = 0, gl->gnumpts = 1 ; i < dim ; i++ ) gl->gnumpts *= npts;

	mov	DWORD PTR [esi+4], 1
	test	ebx, ebx
	jle	SHORT $LN63@gauss_lagr

; 2006 : 
; 2007 :          default: /* over 2 */
; 2008 :          { 
; 2009 :             int npts = 1+gauss_order/2; /* per dimension */

	mov	ecx, 1
	mov	edx, ebx
	npad	2
$LL65@gauss_lagr:

; 2010 :             for ( i = 0, gl->gnumpts = 1 ; i < dim ; i++ ) gl->gnumpts *= npts;

	imul	ecx, eax
	dec	edx
	jne	SHORT $LL65@gauss_lagr
	mov	DWORD PTR [esi+4], ecx
$LN63@gauss_lagr:

; 2011 :             gl->gausspt = dmatrix(0,gl->gnumpts-1,0,dim);

	mov	edx, DWORD PTR [esi+4]
	push	2011					; 000007dbH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	ebx
	push	0
	dec	edx
	push	edx
	push	0
	call	_kb_dmatrix

; 2012 :             gl->gausswt = (REAL*)mycalloc(gl->gnumpts,sizeof(REAL));

	push	2012					; 000007dcH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [esi+4]
	push	8
	push	eax
	call	_kb_calloc

; 2013 :             simplex_quadrature(dim,gauss_order,gl->gnumpts,gl->gausspt,gl->gausswt);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	push	eax
	push	ecx
	push	edx
	push	edi
	push	ebx
	mov	DWORD PTR [esi+12], eax
	call	_simplex_quadrature
	add	esp, 60					; 0000003cH

; 2015 :          break;

	jmp	$do_lagrange$90462
$LN123@gauss_lagr:

; 1939 :             break;
; 1940 :      case 2:
; 1941 :          if ( gauss_order >=  14 ) 

	cmp	edi, 14					; 0000000eH
	jl	SHORT $LN122@gauss_lagr

; 1942 :          { /* use conical product formula */
; 1943 :             int npts = 1+gauss_order/2; /* per dimension */

	mov	eax, edi
	cdq
	sub	eax, edx
	mov	esi, eax

; 1944 :             gl->gnumpts = npts*npts;

	mov	eax, DWORD PTR _gl$[ebp]
	sar	esi, 1
	inc	esi
	imul	esi, esi

; 1945 :             gl->gausspt = dmatrix(0,gl->gnumpts-1,0,2);

	push	1945					; 00000799H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	2
	push	0
	lea	ecx, DWORD PTR [esi-1]
	push	ecx
	push	0
	mov	DWORD PTR [eax+4], esi
	call	_kb_dmatrix
	mov	edx, DWORD PTR _gl$[ebp]

; 1946 :             gl->gausswt = (REAL*)mycalloc(npts*npts,sizeof(REAL));

	push	1946					; 0000079aH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	8
	push	esi
	mov	DWORD PTR [edx+8], eax
	call	_kb_calloc
	mov	ecx, DWORD PTR _gl$[ebp]

; 1947 :             simplex_quadrature(2,gauss_order,npts*npts,gl->gausspt,gl->gausswt);

	push	eax
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [ecx+8]
	push	eax
	push	esi
	push	edi
	push	2
	call	_simplex_quadrature
	mov	esi, DWORD PTR _gl$[ebp]
	add	esp, 60					; 0000003cH
	jmp	$do_lagrange$90462
$LN122@gauss_lagr:

; 1948 :          }
; 1949 :          else if ( gauss_order >=  12 ) 

	cmp	edi, 12					; 0000000cH
	jl	SHORT $LN120@gauss_lagr

; 1951 :               gl->gausspt = dmatrix(0,gl->gnumpts-1,0,2);

	push	1951					; 0000079fH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	2
	push	0
	push	36					; 00000024H
	push	0
	mov	DWORD PTR [esi+4], 37			; 00000025H
	call	_kb_dmatrix

; 1952 :               for ( i = 0 ; i < gl->gnumpts ; i++ )

	xor	edx, edx
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN117@gauss_lagr

; 1950 :             { gl->gnumpts = 37;

	mov	ecx, OFFSET _gauss2Dpt13
	npad	2
$LL298@gauss_lagr:

; 1953 :                  for ( j = 0 ; j <= dim ; j++ )

	xor	eax, eax
$LC204@gauss_lagr:

; 1954 :                     gl->gausspt[i][j] = gauss2Dpt13[i][j];

	mov	edi, DWORD PTR [esi+8]
	fld	QWORD PTR [ecx]
	mov	edi, DWORD PTR [edi+edx*4]
	fstp	QWORD PTR [eax+edi]
	add	eax, 8
	add	ecx, 8
	cmp	eax, 16					; 00000010H
	jle	SHORT $LC204@gauss_lagr

; 1952 :               for ( i = 0 ; i < gl->gnumpts ; i++ )

	inc	edx
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LL298@gauss_lagr
$LN117@gauss_lagr:

; 1955 :               gl->gausswt = gauss2Dwt13;

	mov	DWORD PTR [esi+12], OFFSET _gauss2Dwt13
	jmp	$do_lagrange$90462
$LN120@gauss_lagr:

; 1956 :             }
; 1957 :          else if ( gauss_order >=  9 ) 

	cmp	edi, 9
	jl	SHORT $LN112@gauss_lagr

; 1959 :               gl->gausspt = dmatrix(0,gl->gnumpts-1,0,2);

	push	1959					; 000007a7H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	2
	push	0
	push	27					; 0000001bH
	push	0
	mov	DWORD PTR [esi+4], 28			; 0000001cH
	call	_kb_dmatrix

; 1960 :               for ( i = 0 ; i < gl->gnumpts ; i++ )

	xor	edx, edx
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN109@gauss_lagr

; 1958 :             { gl->gnumpts = 28;

	mov	ecx, OFFSET _gauss2Dpt11
	npad	1
$LL299@gauss_lagr:

; 1961 :                  for ( j = 0 ; j <= dim ; j++ )

	xor	eax, eax
$LC207@gauss_lagr:

; 1962 :                     gl->gausspt[i][j] = gauss2Dpt11[i][j];

	mov	edi, DWORD PTR [esi+8]
	fld	QWORD PTR [ecx]
	mov	edi, DWORD PTR [edi+edx*4]
	fstp	QWORD PTR [eax+edi]
	add	eax, 8
	add	ecx, 8
	cmp	eax, 16					; 00000010H
	jle	SHORT $LC207@gauss_lagr

; 1960 :               for ( i = 0 ; i < gl->gnumpts ; i++ )

	inc	edx
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LL299@gauss_lagr
$LN109@gauss_lagr:

; 1963 :               gl->gausswt = gauss2Dwt11;

	mov	DWORD PTR [esi+12], OFFSET _gauss2Dwt11
	jmp	$do_lagrange$90462
$LN112@gauss_lagr:

; 1964 :             }
; 1965 :          else if ( gauss_order >=  7 ) 

	cmp	edi, 7
	jl	SHORT $LN104@gauss_lagr

; 1967 :               gl->gausspt = dmatrix(0,gl->gnumpts-1,0,2);

	push	1967					; 000007afH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	2
	push	0
	push	15					; 0000000fH
	push	0
	mov	DWORD PTR [esi+4], 16			; 00000010H
	call	_kb_dmatrix

; 1968 :               for ( i = 0 ; i < gl->gnumpts ; i++ )

	xor	edx, edx
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN101@gauss_lagr

; 1966 :             { gl->gnumpts = 16;

	mov	ecx, OFFSET _gauss2Dpt8
	npad	1
$LL300@gauss_lagr:

; 1969 :                  for ( j = 0 ; j <= dim ; j++ )

	xor	eax, eax
$LC210@gauss_lagr:

; 1970 :                     gl->gausspt[i][j] = gauss2Dpt8[i][j];

	mov	edi, DWORD PTR [esi+8]
	fld	QWORD PTR [ecx]
	mov	edi, DWORD PTR [edi+edx*4]
	fstp	QWORD PTR [eax+edi]
	add	eax, 8
	add	ecx, 8
	cmp	eax, 16					; 00000010H
	jle	SHORT $LC210@gauss_lagr

; 1968 :               for ( i = 0 ; i < gl->gnumpts ; i++ )

	inc	edx
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LL300@gauss_lagr
$LN101@gauss_lagr:

; 1971 :               gl->gausswt = gauss2Dwt8;

	mov	DWORD PTR [esi+12], OFFSET _gauss2Dwt8
	jmp	$do_lagrange$90462
$LN104@gauss_lagr:

; 1972 :             }
; 1973 :          else if ( gauss_order >= 6 ) 

	cmp	edi, 6
	jl	SHORT $LN96@gauss_lagr

; 1975 :               gl->gausspt = dmatrix(0,gl->gnumpts-1,0,2);

	push	1975					; 000007b7H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	2
	push	0
	push	11					; 0000000bH
	push	0
	mov	DWORD PTR [esi+4], 12			; 0000000cH
	call	_kb_dmatrix

; 1976 :               for ( i = 0 ; i < gl->gnumpts ; i++ )

	xor	edx, edx
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN93@gauss_lagr

; 1974 :             { gl->gnumpts = 12;

	mov	ecx, OFFSET _gauss2Dpt6
	npad	1
$LL301@gauss_lagr:

; 1977 :                  for ( j = 0 ; j <= dim ; j++ )

	xor	eax, eax
$LC213@gauss_lagr:

; 1978 :                     gl->gausspt[i][j] = gauss2Dpt6[i][j];

	mov	edi, DWORD PTR [esi+8]
	fld	QWORD PTR [ecx]
	mov	edi, DWORD PTR [edi+edx*4]
	fstp	QWORD PTR [eax+edi]
	add	eax, 8
	add	ecx, 8
	cmp	eax, 16					; 00000010H
	jle	SHORT $LC213@gauss_lagr

; 1976 :               for ( i = 0 ; i < gl->gnumpts ; i++ )

	inc	edx
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LL301@gauss_lagr
$LN93@gauss_lagr:

; 1979 :               gl->gausswt = gauss2Dwt6;

	mov	DWORD PTR [esi+12], OFFSET _gauss2Dwt6
	jmp	$do_lagrange$90462
$LN96@gauss_lagr:

; 1980 :             }
; 1981 :          else if ( gauss_order >= 3 ) 

	cmp	edi, 3
	jl	SHORT $LN88@gauss_lagr

; 1983 :               gl->gausspt = dmatrix(0,gl->gnumpts-1,0,2);

	push	1983					; 000007bfH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	2
	push	0
	push	6
	push	0
	mov	DWORD PTR [esi+4], 7
	call	_kb_dmatrix

; 1984 :               for ( i = 0 ; i < gl->gnumpts ; i++ )

	xor	edx, edx
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN85@gauss_lagr

; 1982 :             { gl->gnumpts = 7;

	mov	ecx, OFFSET _gauss2Dpt5
	npad	1
$LL302@gauss_lagr:

; 1985 :                  for ( j = 0 ; j <= dim ; j++ )

	xor	eax, eax
$LC216@gauss_lagr:

; 1986 :                     gl->gausspt[i][j] = gauss2Dpt5[i][j];

	mov	edi, DWORD PTR [esi+8]
	fld	QWORD PTR [ecx]
	mov	edi, DWORD PTR [edi+edx*4]
	fstp	QWORD PTR [eax+edi]
	add	eax, 8
	add	ecx, 8
	cmp	eax, 16					; 00000010H
	jle	SHORT $LC216@gauss_lagr

; 1984 :               for ( i = 0 ; i < gl->gnumpts ; i++ )

	inc	edx
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LL302@gauss_lagr
$LN85@gauss_lagr:

; 1987 :               gl->gausswt = gauss2Dwt5;

	mov	DWORD PTR [esi+12], OFFSET _gauss2Dwt5
	jmp	$do_lagrange$90462
$LN88@gauss_lagr:

; 1988 :             }
; 1989 :          else if ( gauss_order >= 2 )

	cmp	edi, 2
	jl	SHORT $LN80@gauss_lagr

; 1991 :               gl->gausspt = dmatrix(0,gl->gnumpts-1,0,2);

	push	1991					; 000007c7H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	2
	push	0
	push	2
	push	0
	mov	DWORD PTR [esi+4], 3
	call	_kb_dmatrix

; 1992 :               for ( i = 0 ; i < gl->gnumpts ; i++ )

	xor	edx, edx
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN77@gauss_lagr

; 1990 :             { gl->gnumpts = 3;

	mov	ecx, OFFSET _gauss2Dpt2
	npad	1
$LL303@gauss_lagr:

; 1993 :                  for ( j = 0 ; j <= dim ; j++ )

	xor	eax, eax
$LC219@gauss_lagr:

; 1994 :                     gl->gausspt[i][j] = gauss2Dpt2[i][j];

	mov	edi, DWORD PTR [esi+8]
	fld	QWORD PTR [ecx]
	mov	edi, DWORD PTR [edi+edx*4]
	fstp	QWORD PTR [eax+edi]
	add	eax, 8
	add	ecx, 8
	cmp	eax, 16					; 00000010H
	jle	SHORT $LC219@gauss_lagr

; 1992 :               for ( i = 0 ; i < gl->gnumpts ; i++ )

	inc	edx
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LL303@gauss_lagr
$LN77@gauss_lagr:

; 1995 :               gl->gausswt = gauss2Dwt2;

	mov	DWORD PTR [esi+12], OFFSET _gauss2Dwt2

; 1996 :             }
; 1997 :          else

	jmp	$do_lagrange$90462
$LN80@gauss_lagr:

; 1999 :               gl->gausspt = dmatrix(0,gl->gnumpts-1,0,2);

	push	1999					; 000007cfH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	2
	push	0
	push	0
	push	0
	mov	DWORD PTR [esi+4], 1
	call	_kb_dmatrix

; 2000 :               for ( i = 0 ; i < gl->gnumpts ; i++ )

	xor	edx, edx
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN70@gauss_lagr

; 1998 :             { gl->gnumpts = 1;

	mov	ecx, OFFSET _gauss2Dpt1
	npad	6
$LL304@gauss_lagr:

; 2001 :                  for ( j = 0 ; j <= dim ; j++ )

	xor	eax, eax
$LC222@gauss_lagr:

; 2002 :                     gl->gausspt[i][j] = gauss2Dpt1[i][j];

	mov	edi, DWORD PTR [esi+8]
	fld	QWORD PTR [ecx]
	mov	edi, DWORD PTR [edi+edx*4]
	fstp	QWORD PTR [eax+edi]
	add	eax, 8
	add	ecx, 8
	cmp	eax, 16					; 00000010H
	jle	SHORT $LC222@gauss_lagr

; 2000 :               for ( i = 0 ; i < gl->gnumpts ; i++ )

	inc	edx
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LL304@gauss_lagr
$LN70@gauss_lagr:

; 2003 :               gl->gausswt = gauss2Dwt1;

	mov	DWORD PTR [esi+12], OFFSET _gauss2Dwt1

; 2004 :             }
; 2005 :          break;

	jmp	$do_lagrange$90462
$LN127@gauss_lagr:

; 1929 :   { case 1: gl->gnumpts = (abs(gauss_order)+2)/2;

	mov	eax, edi
	cdq
	xor	eax, edx
	sub	eax, edx
	add	eax, 2
	cdq

; 1930 :             gl->gausspt = dmatrix(0,gl->gnumpts-1,0,1);

	push	1930					; 0000078aH
	sub	eax, edx
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	sar	eax, 1
	push	1
	mov	DWORD PTR [esi+4], eax
	push	0
	dec	eax
	push	eax
	push	0
	call	_kb_dmatrix

; 1931 :             gl->gausswt = (REAL*)mycalloc(gl->gnumpts,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+4]
	push	1931					; 0000078bH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	8
	push	ecx
	mov	DWORD PTR [esi+8], eax
	call	_kb_calloc

; 1932 :             temp = (REAL*)temp_calloc(gl->gnumpts,sizeof(REAL));

	mov	edx, DWORD PTR [esi+4]
	push	1932					; 0000078cH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	8
	push	edx
	mov	DWORD PTR [esi+12], eax
	call	_kb_temp_calloc

; 1933 :             grule(gl->gnumpts,temp,gl->gausswt);

	mov	edi, DWORD PTR _gl$[ebp]
	mov	ecx, DWORD PTR [edi+4]
	mov	esi, eax
	mov	eax, DWORD PTR [edi+12]
	push	eax
	push	esi
	push	ecx
	call	_grule

; 1934 :             for ( i = 0 ; i < gl->gnumpts ; i++ )

	xor	eax, eax
	add	esp, 68					; 00000044H
	cmp	DWORD PTR [edi+4], eax
	jle	SHORT $LN124@gauss_lagr
	fld1
	mov	ecx, edi
$LN126@gauss_lagr:

; 1935 :             { gl->gausspt[i][0] = temp[i];

	mov	edx, DWORD PTR [ecx+8]
	fld	QWORD PTR [esi+eax*8]
	mov	edx, DWORD PTR [edx+eax*4]
	fstp	QWORD PTR [edx]

; 1936 :               gl->gausspt[i][1] = 1.0 - temp[i];

	mov	edx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [edx+eax*4]
	fld	ST(0)
	inc	eax
	fsub	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [edx+8]
	cmp	eax, DWORD PTR [ecx+4]
	jl	SHORT $LN126@gauss_lagr

; 1934 :             for ( i = 0 ; i < gl->gnumpts ; i++ )

	fstp	ST(0)
$LN124@gauss_lagr:

; 1937 :             }
; 1938 :             temp_free((char*)temp);

	push	esi
	call	_temp_free
	add	esp, 4
	mov	esi, edi
$do_lagrange$90462:

; 2016 :   }
; 2017 : do_lagrange:
; 2018 : 
; 2019 :     /* now set up lagrange to gauss interpolation matrices */
; 2020 :     /* Lagrange points are in linear array in barycentric order */
; 2021 : 
; 2022 :     if ( gl->gpoly ) free_matrix(gl->gpoly);

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN62@gauss_lagr
	push	eax
	call	_free_matrix
	add	esp, 4
$LN62@gauss_lagr:

; 2023 :     if ( gl->gpolypart ) free_matrix3(gl->gpolypart);

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN61@gauss_lagr
	push	eax
	call	_free_matrix3
	add	esp, 4
$LN61@gauss_lagr:

; 2024 :     if ( gl->lpolypart ) free_matrix3(gl->lpolypart);

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN60@gauss_lagr
	push	eax
	call	_free_matrix3
	add	esp, 4
$LN60@gauss_lagr:

; 2025 : 
; 2026 :     gl->lagrange_order = lagrange_order;

	mov	eax, DWORD PTR _lagrange_order$[ebp]

; 2027 :     gl->lagpts = binom_coeff(dim+lagrange_order,lagrange_order);

	push	eax
	mov	DWORD PTR [esi], eax
	add	eax, ebx
	push	eax
	call	_binom_coeff

; 2028 :     gl->gpoly = dmatrix(0,gl->gnumpts-1,0,gl->lagpts-1);

	mov	ecx, DWORD PTR [esi+4]
	push	2028					; 000007ecH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	mov	DWORD PTR [esi+16], eax
	dec	eax
	push	eax
	push	0
	dec	ecx
	push	ecx
	push	0
	call	_kb_dmatrix

; 2029 :     gl->gpolypart = dmatrix3(gl->gnumpts,dim,gl->lagpts);

	mov	edx, DWORD PTR [esi+16]
	push	2029					; 000007edH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	edx
	mov	DWORD PTR [esi+20], eax
	mov	eax, DWORD PTR [esi+4]
	push	ebx
	push	eax
	call	_kb_dmatrix3

; 2030 :     gl->lpolypart = dmatrix3(gl->lagpts,dim,gl->lagpts);

	push	2030					; 000007eeH
	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR [esi+16]
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	eax
	push	ebx
	push	eax
	call	_kb_dmatrix3
	add	esp, 72					; 00000048H

; 2031 : 
; 2032 :     for ( n = 0 ; n < gl->gnumpts ; n++ )

	cmp	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR _n$[ebp], 0
	jle	$LN57@gauss_lagr
	npad	4
$LL59@gauss_lagr:

; 2033 :     { REAL *x;
; 2034 :       int inx[MAXCOORD+1];
; 2035 : 
; 2036 :       x = gl->gausspt[n];  /* full barycentric coords, adding to 1 */

	mov	ecx, DWORD PTR _gl$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _x$90549[ebp], ecx

; 2037 :       for ( i = 0 ; i <= dim ; i++ ) inx[i] = 0;

	test	ebx, ebx
	js	SHORT $LN56@gauss_lagr

; 2014 :          }

	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$90550[ebp]
	rep stosd
$LN56@gauss_lagr:

; 2038 :       inx[0] = lagrange_order;

	mov	edx, DWORD PTR _lagrange_order$[ebp]
	mov	DWORD PTR _inx$90550[ebp], edx
	npad	4
$LL53@gauss_lagr:

; 2039 :       do 
; 2040 :       { REAL prod, prodpart[MAXCOORD];
; 2041 :         int ix,mm;
; 2042 :         for ( k = 0 ; k <= dim ; k++ ) prodpart[k] = 0.0;

	test	ebx, ebx
	js	SHORT $LN50@gauss_lagr

; 2014 :          }

	lea	ecx, DWORD PTR [ebx+ebx+2]
	and	ecx, 1073741822				; 3ffffffeH
	xor	eax, eax
	lea	edi, DWORD PTR _prodpart$90558[ebp]
	rep stosd
$LN50@gauss_lagr:

; 2043 :         for ( i = 0, prod = 1.0, mm = 1 ; i <= dim ; i++ )

	fld1
	xor	ecx, ecx
	fld	ST(0)
	mov	edi, 1
	fst	QWORD PTR _prod$90557[ebp]
	mov	DWORD PTR _mm$90560[ebp], edi
	test	ebx, ebx
	js	$LN312@gauss_lagr
	mov	esi, DWORD PTR _x$90549[ebp]
	lea	eax, DWORD PTR _inx$90550[ebp]
	mov	DWORD PTR tv5180[ebp], eax
	mov	DWORD PTR tv5182[ebp], esi
$LN305@gauss_lagr:

; 2044 :           for ( j = 0 ; j < inx[i] ; j++, mm++ )

	mov	edx, DWORD PTR tv5180[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _j$[ebp], 0
	test	eax, eax
	jle	$LN46@gauss_lagr
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR tv5058[ebp], eax
	mov	eax, 1
	sub	eax, edi
	mov	DWORD PTR tv5193[ebp], edx
	mov	DWORD PTR tv5092[ebp], eax
$LN44@gauss_lagr:

; 2045 :           { if ( bezier_flag )
; 2046 :             { for ( k = 0 ; k <= dim ; k++ )

	xor	eax, eax
	lea	edx, DWORD PTR [ebx+1]
	cmp	DWORD PTR _bezier_flag, eax
	je	$LN41@gauss_lagr
	cmp	edx, 4
	jl	$LN306@gauss_lagr
	fild	DWORD PTR _mm$90560[ebp]
	mov	edx, DWORD PTR tv5092[ebp]
	fld	QWORD PTR [esi]
	add	edx, edi
	mov	DWORD PTR tv6363[ebp], edx
	fmul	ST(0), ST(1)
	lea	esi, DWORD PTR [ebx-3]
	fild	DWORD PTR tv6363[ebp]
	lea	edx, DWORD PTR [eax+2]
	fdivp	ST(1), ST(0)
$LN229@gauss_lagr:

; 2047 :               { prodpart[k] *= mm*x[i]/(j+1);

	fld	ST(0)
	fmul	QWORD PTR _prodpart$90558[ebp+eax*8]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8]

; 2048 :                 if ( i == k ) prodpart[k] += prod*mm/(j+1.);

	cmp	ecx, eax
	jne	SHORT $LN327@gauss_lagr
	fld	ST(2)
	fmul	ST(0), ST(4)
	fild	DWORD PTR _j$[ebp]
	fadd	ST(0), ST(6)
	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8]
	jmp	SHORT $LN225@gauss_lagr
$LN327@gauss_lagr:
	fstp	ST(0)
$LN225@gauss_lagr:

; 2047 :               { prodpart[k] *= mm*x[i]/(j+1);

	fld	ST(0)

; 2048 :                 if ( i == k ) prodpart[k] += prod*mm/(j+1.);

	lea	edi, DWORD PTR [edx-1]
	fmul	QWORD PTR _prodpart$90558[ebp+eax*8+8]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8+8]
	cmp	ecx, edi
	jne	SHORT $LN330@gauss_lagr
	fld	ST(2)
	fmul	ST(0), ST(4)
	fild	DWORD PTR _j$[ebp]
	fadd	ST(0), ST(6)
	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8+8]
	jmp	SHORT $LN226@gauss_lagr
$LN330@gauss_lagr:
	fstp	ST(0)
$LN226@gauss_lagr:

; 2047 :               { prodpart[k] *= mm*x[i]/(j+1);

	fld	QWORD PTR _prodpart$90558[ebp+eax*8+16]
	fmul	ST(0), ST(1)
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8+16]

; 2048 :                 if ( i == k ) prodpart[k] += prod*mm/(j+1.);

	cmp	ecx, edx
	jne	SHORT $LN333@gauss_lagr
	fld	ST(2)
	fmul	ST(0), ST(4)
	fild	DWORD PTR _j$[ebp]
	fadd	ST(0), ST(6)
	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8+16]
	jmp	SHORT $LN227@gauss_lagr
$LN333@gauss_lagr:
	fstp	ST(0)
$LN227@gauss_lagr:

; 2047 :               { prodpart[k] *= mm*x[i]/(j+1);

	fld	ST(0)
	lea	edi, DWORD PTR [edx+1]
	fmul	QWORD PTR _prodpart$90558[ebp+eax*8+24]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8+24]

; 2048 :                 if ( i == k ) prodpart[k] += prod*mm/(j+1.);

	cmp	ecx, edi
	jne	SHORT $LN336@gauss_lagr
	fld	ST(2)
	fmul	ST(0), ST(4)
	fild	DWORD PTR _j$[ebp]
	fadd	ST(0), ST(6)
	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8+24]
	jmp	SHORT $LN228@gauss_lagr
$LN336@gauss_lagr:
	fstp	ST(0)
$LN228@gauss_lagr:
	add	eax, 4

; 2045 :           { if ( bezier_flag )
; 2046 :             { for ( k = 0 ; k <= dim ; k++ )

	add	edx, 4
	cmp	eax, esi
	jle	$LN229@gauss_lagr
	mov	esi, DWORD PTR tv5182[ebp]

; 2048 :                 if ( i == k ) prodpart[k] += prod*mm/(j+1.);

	fstp	ST(1)
	mov	edi, DWORD PTR _mm$90560[ebp]
	fstp	ST(0)
$LN306@gauss_lagr:

; 2045 :           { if ( bezier_flag )
; 2046 :             { for ( k = 0 ; k <= dim ; k++ )

	cmp	eax, ebx
	jg	SHORT $LN294@gauss_lagr
	fild	DWORD PTR _mm$90560[ebp]
	mov	edx, DWORD PTR tv5092[ebp]
	fld	QWORD PTR [esi]
	add	edx, edi
	mov	DWORD PTR tv6329[ebp], edx
	fmul	ST(0), ST(1)
	fild	DWORD PTR tv6329[ebp]
	fdivp	ST(1), ST(0)
$LC40@gauss_lagr:

; 2047 :               { prodpart[k] *= mm*x[i]/(j+1);

	fld	QWORD PTR _prodpart$90558[ebp+eax*8]
	fmul	ST(0), ST(1)
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8]

; 2048 :                 if ( i == k ) prodpart[k] += prod*mm/(j+1.);

	cmp	ecx, eax
	jne	SHORT $LN345@gauss_lagr
	fld	ST(2)
	fmul	ST(0), ST(4)
	fild	DWORD PTR _j$[ebp]
	fadd	ST(0), ST(6)
	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8]
	jmp	SHORT $LN39@gauss_lagr
$LN345@gauss_lagr:
	fstp	ST(0)
$LN39@gauss_lagr:
	inc	eax

; 2045 :           { if ( bezier_flag )
; 2046 :             { for ( k = 0 ; k <= dim ; k++ )

	cmp	eax, ebx
	jle	SHORT $LC40@gauss_lagr

; 2048 :                 if ( i == k ) prodpart[k] += prod*mm/(j+1.);

	fstp	ST(1)
	fstp	ST(0)
$LN294@gauss_lagr:

; 2049 :               }
; 2050 :               prod *= mm*x[i]/(j+1.);

	fild	DWORD PTR _mm$90560[ebp]
	fmul	QWORD PTR [esi]
	fild	DWORD PTR _j$[ebp]
	fadd	ST(0), ST(3)
	fdivp	ST(1), ST(0)

; 2051 :             }
; 2052 :             else /* regular Lagrange polynomials */ 

	jmp	$LN411@gauss_lagr
$LN41@gauss_lagr:

; 2053 :             { for ( k = 0 ; k <= dim ; k++ )

	cmp	edx, 4
	jl	$LN307@gauss_lagr
	fild	DWORD PTR _lagrange_order$[ebp]
	mov	edx, 2
	fild	DWORD PTR tv5058[ebp]
	fld	QWORD PTR [esi]
	lea	esi, DWORD PTR [ebx-3]
	fmul	ST(0), ST(2)
	fisub	DWORD PTR _j$[ebp]
	fdiv	ST(0), ST(1)
$LN236@gauss_lagr:

; 2054 :               { prodpart[k] *= (lagrange_order*x[i]-j)/(inx[i]-j);

	fld	ST(0)
	fmul	QWORD PTR _prodpart$90558[ebp+eax*8]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8]

; 2055 :                 if ( i == k ) prodpart[k] += prod*lagrange_order/(inx[i]-j);

	cmp	ecx, eax
	jne	SHORT $LN354@gauss_lagr
	fld	ST(3)
	fmul	ST(0), ST(5)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8]
	jmp	SHORT $LN232@gauss_lagr
$LN354@gauss_lagr:
	fstp	ST(0)
$LN232@gauss_lagr:

; 2054 :               { prodpart[k] *= (lagrange_order*x[i]-j)/(inx[i]-j);

	fld	ST(0)

; 2055 :                 if ( i == k ) prodpart[k] += prod*lagrange_order/(inx[i]-j);

	lea	edi, DWORD PTR [edx-1]
	fmul	QWORD PTR _prodpart$90558[ebp+eax*8+8]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8+8]
	cmp	ecx, edi
	jne	SHORT $LN357@gauss_lagr
	fld	ST(3)
	fmul	ST(0), ST(5)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8+8]
	jmp	SHORT $LN233@gauss_lagr
$LN357@gauss_lagr:
	fstp	ST(0)
$LN233@gauss_lagr:

; 2054 :               { prodpart[k] *= (lagrange_order*x[i]-j)/(inx[i]-j);

	fld	QWORD PTR _prodpart$90558[ebp+eax*8+16]
	fmul	ST(0), ST(1)
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8+16]

; 2055 :                 if ( i == k ) prodpart[k] += prod*lagrange_order/(inx[i]-j);

	cmp	ecx, edx
	jne	SHORT $LN360@gauss_lagr
	fld	ST(3)
	fmul	ST(0), ST(5)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8+16]
	jmp	SHORT $LN234@gauss_lagr
$LN360@gauss_lagr:
	fstp	ST(0)
$LN234@gauss_lagr:

; 2054 :               { prodpart[k] *= (lagrange_order*x[i]-j)/(inx[i]-j);

	fld	ST(0)
	lea	edi, DWORD PTR [edx+1]
	fmul	QWORD PTR _prodpart$90558[ebp+eax*8+24]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8+24]

; 2055 :                 if ( i == k ) prodpart[k] += prod*lagrange_order/(inx[i]-j);

	cmp	ecx, edi
	jne	SHORT $LN363@gauss_lagr
	fld	ST(3)
	fmul	ST(0), ST(5)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8+24]
	jmp	SHORT $LN235@gauss_lagr
$LN363@gauss_lagr:
	fstp	ST(0)
$LN235@gauss_lagr:
	add	eax, 4

; 2053 :             { for ( k = 0 ; k <= dim ; k++ )

	add	edx, 4
	cmp	eax, esi
	jle	$LN236@gauss_lagr
	mov	esi, DWORD PTR tv5182[ebp]

; 2055 :                 if ( i == k ) prodpart[k] += prod*lagrange_order/(inx[i]-j);

	fstp	ST(2)
	mov	edi, DWORD PTR _mm$90560[ebp]
	fstp	ST(0)
	fstp	ST(0)
$LN307@gauss_lagr:

; 2053 :             { for ( k = 0 ; k <= dim ; k++ )

	cmp	eax, ebx
	jg	SHORT $LN230@gauss_lagr
	mov	edx, DWORD PTR tv5180[ebp]
	fild	DWORD PTR _lagrange_order$[ebp]
	mov	edx, DWORD PTR [edx]
	sub	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv6283[ebp], edx
	fild	DWORD PTR tv6283[ebp]
	fld	QWORD PTR [esi]
	fmul	ST(0), ST(2)
	fisub	DWORD PTR _j$[ebp]
	fdiv	ST(0), ST(1)
$LC35@gauss_lagr:

; 2054 :               { prodpart[k] *= (lagrange_order*x[i]-j)/(inx[i]-j);

	fld	QWORD PTR _prodpart$90558[ebp+eax*8]
	fmul	ST(0), ST(1)
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8]

; 2055 :                 if ( i == k ) prodpart[k] += prod*lagrange_order/(inx[i]-j);

	cmp	ecx, eax
	jne	SHORT $LN372@gauss_lagr
	fld	ST(3)
	fmul	ST(0), ST(5)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90558[ebp+eax*8]
	jmp	SHORT $LN34@gauss_lagr
$LN372@gauss_lagr:
	fstp	ST(0)
$LN34@gauss_lagr:
	inc	eax

; 2053 :             { for ( k = 0 ; k <= dim ; k++ )

	cmp	eax, ebx
	jle	SHORT $LC35@gauss_lagr

; 2055 :                 if ( i == k ) prodpart[k] += prod*lagrange_order/(inx[i]-j);

	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(0)
$LN230@gauss_lagr:

; 2056 :               }
; 2057 :               prod *= (lagrange_order*x[i]-j)/(inx[i]-j);

	fild	DWORD PTR _lagrange_order$[ebp]
	fmul	QWORD PTR [esi]
	fisub	DWORD PTR _j$[ebp]
	fidiv	DWORD PTR tv5058[ebp]
$LN411@gauss_lagr:
	mov	eax, DWORD PTR _j$[ebp]
	fmulp	ST(1), ST(0)
	dec	DWORD PTR tv5058[ebp]
	inc	eax
	inc	edi
	mov	DWORD PTR _j$[ebp], eax
	mov	DWORD PTR _mm$90560[ebp], edi
	cmp	eax, DWORD PTR tv5193[ebp]
	jl	$LN44@gauss_lagr
$LN46@gauss_lagr:

; 2043 :         for ( i = 0, prod = 1.0, mm = 1 ; i <= dim ; i++ )

	add	DWORD PTR tv5180[ebp], 4
	inc	ecx
	add	esi, 8
	mov	DWORD PTR tv5182[ebp], esi
	cmp	ecx, ebx
	jle	$LN305@gauss_lagr
	fstp	ST(1)

; 2049 :               }
; 2050 :               prod *= mm*x[i]/(j+1.);

	fstp	QWORD PTR _prod$90557[ebp]
	jmp	SHORT $LN45@gauss_lagr
$LN312@gauss_lagr:
	fstp	ST(0)
	fstp	ST(0)
$LN45@gauss_lagr:

; 2058 :             }
; 2059 :           }
; 2060 :         ix = lagrange_index(dim,lagrange_order,inx);

	mov	ecx, DWORD PTR _lagrange_order$[ebp]
	lea	eax, DWORD PTR _inx$90550[ebp]
	push	eax
	push	ecx
	push	ebx
	call	_lagrange_index

; 2061 :         gl->gpoly[n][ix] = prod;

	fld	QWORD PTR _prod$90557[ebp]
	mov	edi, DWORD PTR _gl$[ebp]
	mov	edx, DWORD PTR [edi+20]
	mov	esi, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [edx+esi*4]
	fstp	QWORD PTR [ecx+eax*8]
	add	esp, 12					; 0000000cH

; 2062 :         for ( k = 0 ; k < dim ; k++ )

	xor	ecx, ecx
	cmp	ebx, 4
	jl	$LC238@gauss_lagr
	lea	edx, DWORD PTR [ebx-3]
$LL295@gauss_lagr:

; 2063 :           gl->gpolypart[n][k][ix] = -(prodpart[k] - prodpart[dim]);

	mov	edi, DWORD PTR [edi+24]
	fld	QWORD PTR _prodpart$90558[ebp+ecx*8]
	fsub	QWORD PTR _prodpart$90558[ebp+ebx*8]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi+ecx*4]
	add	ecx, 4
	fchs
	fstp	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR _gl$[ebp]
	mov	edi, DWORD PTR [edi+24]
	fld	QWORD PTR _prodpart$90558[ebp+ecx*8-24]
	fsub	QWORD PTR _prodpart$90558[ebp+ebx*8]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi+ecx*4-12]
	fchs
	fstp	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR _gl$[ebp]
	mov	edi, DWORD PTR [edi+24]
	fld	QWORD PTR _prodpart$90558[ebp+ecx*8-16]
	fsub	QWORD PTR _prodpart$90558[ebp+ebx*8]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi+ecx*4-8]
	fchs
	fstp	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR _gl$[ebp]
	mov	edi, DWORD PTR [edi+24]
	fld	QWORD PTR _prodpart$90558[ebp+ecx*8-8]
	fsub	QWORD PTR _prodpart$90558[ebp+ebx*8]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi+ecx*4-4]
	fchs
	fstp	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR _gl$[ebp]
	cmp	ecx, edx
	jl	SHORT $LL295@gauss_lagr
$LC238@gauss_lagr:

; 2062 :         for ( k = 0 ; k < dim ; k++ )

	cmp	ecx, ebx
	jge	SHORT $LN52@gauss_lagr
	npad	2
$LC31@gauss_lagr:

; 2063 :           gl->gpolypart[n][k][ix] = -(prodpart[k] - prodpart[dim]);

	fld	QWORD PTR _prodpart$90558[ebp+ecx*8]
	mov	edx, DWORD PTR [edi+24]
	fsub	QWORD PTR _prodpart$90558[ebp+ebx*8]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [edx+ecx*4]
	inc	ecx
	fchs
	fstp	QWORD PTR [edx+eax*8]
	cmp	ecx, ebx
	jl	SHORT $LC31@gauss_lagr
$LN52@gauss_lagr:

; 2064 :           /* neg since natural coord runs opposite barycentric coord */
; 2065 :       } while ( increment_lagrange_index(dim,inx) );

	lea	eax, DWORD PTR _inx$90550[ebp]
	push	eax
	push	ebx
	call	_increment_lagrange_index
	add	esp, 8
	test	eax, eax
	jne	$LL53@gauss_lagr

; 2031 : 
; 2032 :     for ( n = 0 ; n < gl->gnumpts ; n++ )

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _gl$[ebp]
	inc	eax
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, DWORD PTR [ecx+4]
	jl	$LL59@gauss_lagr
$LN57@gauss_lagr:

; 2067 : 
; 2068 :     /* partials to calculate tangents at lagrange points */
; 2069 :     for ( i = 0 ; i <= dim ; i++ ) linx[i] = 0;

	test	ebx, ebx
	js	SHORT $LN28@gauss_lagr
	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _linx$[ebp]
	rep stosd
$LN28@gauss_lagr:

; 2070 :     linx[0] = lagrange_order;
; 2071 :     for ( n = 0 ; n < gl->lagpts ; n++ )

	mov	eax, DWORD PTR _gl$[ebp]
	mov	edx, DWORD PTR _lagrange_order$[ebp]
	xor	esi, esi
	mov	DWORD PTR _linx$[ebp], edx
	mov	DWORD PTR _n$[ebp], esi
	cmp	DWORD PTR [eax+16], esi
	jle	$LN23@gauss_lagr
$LL296@gauss_lagr:

; 2072 :     { 
; 2073 :       int inx[MAXCOORD+1];
; 2074 : 
; 2075 :       for ( i = 0 ; i <= dim ; i++ ) inx[i] = 0;

	test	ebx, ebx
	js	SHORT $LN22@gauss_lagr

; 2066 :     }

	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$90589[ebp]
	rep stosd
$LN22@gauss_lagr:

; 2076 :       inx[0] = lagrange_order;

	mov	ecx, DWORD PTR _lagrange_order$[ebp]
	mov	DWORD PTR _inx$90589[ebp], ecx
	npad	5
$LL19@gauss_lagr:

; 2077 :       do 
; 2078 :       {  REAL prod, prodpart[MAXCOORD];
; 2079 :          int ix;
; 2080 :          for ( k = 0 ; k <= dim ; k++ ) prodpart[k] = 0.0;

	test	ebx, ebx
	js	SHORT $LN16@gauss_lagr

; 2066 :     }

	lea	ecx, DWORD PTR [ebx+ebx+2]
	and	ecx, 1073741822				; 3ffffffeH
	xor	eax, eax
	lea	edi, DWORD PTR _prodpart$90597[ebp]
	rep stosd
$LN16@gauss_lagr:

; 2081 :          for ( i = 0, prod = 1.0 ; i <= dim ; i++ )

	fld1
	xor	edx, edx
	test	ebx, ebx
	js	$LN410@gauss_lagr
$LN13@gauss_lagr:

; 2082 :          { 
; 2083 :            for ( j = 0 ; j < inx[i] ; j++ )

	mov	eax, DWORD PTR _inx$90589[ebp+edx*4]
	xor	edi, edi
	mov	DWORD PTR _j$[ebp], edi
	test	eax, eax
	jle	$LN12@gauss_lagr
	fild	DWORD PTR _linx$[ebp+edx*4]
	mov	DWORD PTR tv5970[ebp], eax
$LN10@gauss_lagr:

; 2084 :            { for ( k = 0 ; k <= dim ; k++ )

	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	cmp	ecx, 4
	jl	$LN297@gauss_lagr
	fild	DWORD PTR tv5970[ebp]
	lea	esi, DWORD PTR [ebx-3]
	fild	DWORD PTR _j$[ebp]
	lea	ecx, DWORD PTR [eax+2]
	fsubr	ST(0), ST(2)
	fdiv	ST(0), ST(1)
$LN246@gauss_lagr:

; 2085 :              { prodpart[k] *= ((REAL)linx[i]-j)/(inx[i]-j);

	fld	ST(0)
	fmul	QWORD PTR _prodpart$90597[ebp+eax*8]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$90597[ebp+eax*8]

; 2086 :                if ( i == k ) 

	cmp	edx, eax
	jne	SHORT $LN388@gauss_lagr

; 2087 :                   prodpart[k] += prod/(inx[i]-j);

	fld	ST(4)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90597[ebp+eax*8]
	jmp	SHORT $LN242@gauss_lagr
$LN388@gauss_lagr:
	fstp	ST(0)
$LN242@gauss_lagr:

; 2085 :              { prodpart[k] *= ((REAL)linx[i]-j)/(inx[i]-j);

	fld	ST(0)

; 2086 :                if ( i == k ) 

	lea	ebx, DWORD PTR [ecx-1]
	fmul	QWORD PTR _prodpart$90597[ebp+eax*8+8]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$90597[ebp+eax*8+8]
	cmp	edx, ebx
	jne	SHORT $LN391@gauss_lagr

; 2087 :                   prodpart[k] += prod/(inx[i]-j);

	fld	ST(4)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90597[ebp+eax*8+8]
	jmp	SHORT $LN243@gauss_lagr
$LN391@gauss_lagr:
	fstp	ST(0)
$LN243@gauss_lagr:

; 2085 :              { prodpart[k] *= ((REAL)linx[i]-j)/(inx[i]-j);

	fld	ST(0)
	fmul	QWORD PTR _prodpart$90597[ebp+eax*8+16]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$90597[ebp+eax*8+16]

; 2086 :                if ( i == k ) 

	cmp	edx, ecx
	jne	SHORT $LN394@gauss_lagr

; 2087 :                   prodpart[k] += prod/(inx[i]-j);

	fld	ST(4)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90597[ebp+eax*8+16]
	jmp	SHORT $LN244@gauss_lagr
$LN394@gauss_lagr:
	fstp	ST(0)
$LN244@gauss_lagr:

; 2085 :              { prodpart[k] *= ((REAL)linx[i]-j)/(inx[i]-j);

	fld	ST(0)
	lea	ebx, DWORD PTR [ecx+1]
	fmul	QWORD PTR _prodpart$90597[ebp+eax*8+24]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$90597[ebp+eax*8+24]

; 2086 :                if ( i == k ) 

	cmp	edx, ebx
	jne	SHORT $LN397@gauss_lagr

; 2087 :                   prodpart[k] += prod/(inx[i]-j);

	fld	ST(4)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90597[ebp+eax*8+24]
	jmp	SHORT $LN245@gauss_lagr
$LN397@gauss_lagr:
	fstp	ST(0)
$LN245@gauss_lagr:
	add	eax, 4

; 2084 :            { for ( k = 0 ; k <= dim ; k++ )

	add	ecx, 4
	cmp	eax, esi
	jle	$LN246@gauss_lagr
	mov	esi, DWORD PTR _n$[ebp]

; 2087 :                   prodpart[k] += prod/(inx[i]-j);

	fstp	ST(1)
	mov	ebx, DWORD PTR _dim$GSCopy$[ebp]
	fstp	ST(0)
$LN297@gauss_lagr:

; 2084 :            { for ( k = 0 ; k <= dim ; k++ )

	cmp	eax, ebx
	jg	SHORT $LN308@gauss_lagr
	mov	ecx, DWORD PTR _inx$90589[ebp+edx*4]
	sub	ecx, edi
	mov	DWORD PTR tv6219[ebp], ecx
	fild	DWORD PTR tv6219[ebp]
	fild	DWORD PTR _linx$[ebp+edx*4]
	fisub	DWORD PTR _j$[ebp]
	fdiv	ST(0), ST(1)
$LC7@gauss_lagr:

; 2085 :              { prodpart[k] *= ((REAL)linx[i]-j)/(inx[i]-j);

	fld	ST(0)
	fmul	QWORD PTR _prodpart$90597[ebp+eax*8]
	fst	QWORD PTR _prodpart$90597[ebp+eax*8]

; 2086 :                if ( i == k ) 

	cmp	edx, eax
	jne	SHORT $LN406@gauss_lagr

; 2087 :                   prodpart[k] += prod/(inx[i]-j);

	fld	ST(4)
	fdiv	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$90597[ebp+eax*8]
	jmp	SHORT $LN6@gauss_lagr
$LN406@gauss_lagr:
	fstp	ST(0)
$LN6@gauss_lagr:
	inc	eax

; 2084 :            { for ( k = 0 ; k <= dim ; k++ )

	cmp	eax, ebx
	jle	SHORT $LC7@gauss_lagr

; 2087 :                   prodpart[k] += prod/(inx[i]-j);

	fstp	ST(1)
	fstp	ST(0)
$LN308@gauss_lagr:

; 2088 :              }
; 2089 :              prod *= ((REAL)linx[i]-j)/(inx[i]-j);

	fild	DWORD PTR _j$[ebp]
	inc	edi
	mov	DWORD PTR _j$[ebp], edi
	fsubr	ST(0), ST(1)
	fidiv	DWORD PTR tv5970[ebp]
	dec	DWORD PTR tv5970[ebp]
	fmulp	ST(2), ST(0)
	cmp	edi, DWORD PTR _inx$90589[ebp+edx*4]
	jl	$LN10@gauss_lagr

; 2082 :          { 
; 2083 :            for ( j = 0 ; j < inx[i] ; j++ )

	fstp	ST(0)
$LN12@gauss_lagr:

; 2081 :          for ( i = 0, prod = 1.0 ; i <= dim ; i++ )

	inc	edx
	cmp	edx, ebx
	jle	$LN13@gauss_lagr
$LN410@gauss_lagr:

; 2090 :            }
; 2091 :          }
; 2092 :          ix = lagrange_index(dim,lagrange_order,inx);

	mov	eax, DWORD PTR _lagrange_order$[ebp]
	fstp	ST(0)
	lea	edx, DWORD PTR _inx$90589[ebp]
	push	edx
	push	eax
	push	ebx
	call	_lagrange_index
	add	esp, 12					; 0000000cH

; 2093 :          for ( k = 0 ; k < dim ; k++ )

	xor	ecx, ecx
	cmp	ebx, 4
	jl	$LC248@gauss_lagr
	lea	edx, DWORD PTR [ebx-3]
$LL249@gauss_lagr:

; 2094 :             gl->lpolypart[n][k][ix] = -(prodpart[k] - prodpart[dim]);

	fld	QWORD PTR _prodpart$90597[ebp+ecx*8]
	mov	edi, DWORD PTR _gl$[ebp]
	mov	edi, DWORD PTR [edi+28]
	fsub	QWORD PTR _prodpart$90597[ebp+ebx*8]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi+ecx*4]
	fchs
	add	ecx, 4
	fstp	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR _gl$[ebp]
	mov	edi, DWORD PTR [edi+28]
	fld	QWORD PTR _prodpart$90597[ebp+ecx*8-24]
	fsub	QWORD PTR _prodpart$90597[ebp+ebx*8]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi+ecx*4-12]
	fchs
	fstp	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR _gl$[ebp]
	mov	edi, DWORD PTR [edi+28]
	fld	QWORD PTR _prodpart$90597[ebp+ecx*8-16]
	fsub	QWORD PTR _prodpart$90597[ebp+ebx*8]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi+ecx*4-8]
	fchs
	fstp	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR _gl$[ebp]
	mov	edi, DWORD PTR [edi+28]
	fld	QWORD PTR _prodpart$90597[ebp+ecx*8-8]
	fsub	QWORD PTR _prodpart$90597[ebp+ebx*8]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi+ecx*4-4]
	fchs
	fstp	QWORD PTR [edi+eax*8]
	cmp	ecx, edx
	jl	SHORT $LL249@gauss_lagr
$LC248@gauss_lagr:

; 2093 :          for ( k = 0 ; k < dim ; k++ )

	cmp	ecx, ebx
	jge	SHORT $LN18@gauss_lagr
	mov	edx, DWORD PTR _gl$[ebp]
$LC3@gauss_lagr:

; 2094 :             gl->lpolypart[n][k][ix] = -(prodpart[k] - prodpart[dim]);

	fld	QWORD PTR _prodpart$90597[ebp+ecx*8]
	mov	edi, DWORD PTR [edx+28]
	fsub	QWORD PTR _prodpart$90597[ebp+ebx*8]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi+ecx*4]
	inc	ecx
	fchs
	fstp	QWORD PTR [edi+eax*8]
	cmp	ecx, ebx
	jl	SHORT $LC3@gauss_lagr
$LN18@gauss_lagr:

; 2095 :             /* neg since natural coord runs opposite barycentric coord */
; 2096 :       } while ( increment_lagrange_index(dim,inx) );

	lea	ecx, DWORD PTR _inx$90589[ebp]
	push	ecx
	push	ebx
	call	_increment_lagrange_index
	add	esp, 8
	test	eax, eax
	jne	$LL19@gauss_lagr

; 2097 :       increment_lagrange_index(dim,linx);

	lea	edx, DWORD PTR _linx$[ebp]
	push	edx
	push	ebx
	call	_increment_lagrange_index
	mov	eax, DWORD PTR _gl$[ebp]
	inc	esi
	add	esp, 8
	mov	DWORD PTR _n$[ebp], esi
	cmp	esi, DWORD PTR [eax+16]
	jl	$LL296@gauss_lagr
$LN23@gauss_lagr:

; 2098 :     }
; 2099 : 
; 2100 : } // end gauss_lagrange_setup()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_gauss_lagrange_setup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@LKKICLFJ@Can?8t?5do?5simplex?5Lagrange?5with?5b@ ; `string'
PUBLIC	??_C@_0CE@IAOGAMEJ@Lagrange?5order?5must?5be?5at?5least?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_lagrange_to_lagrange
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	_web_timestamp:DWORD
EXTRN	_change_flag:DWORD
EXTRN	_edge_ctrl:DWORD
EXTRN	_free_element:PROC
EXTRN	_get_edge_verts:PROC
EXTRN	_project_v_constr:PROC
EXTRN	_set_v_conmap:PROC
EXTRN	_get_v_common_conmap:PROC
EXTRN	_new_vertex:PROC
EXTRN	_get_facet_verts:PROC
EXTRN	_expand_attribute:PROC
EXTRN	__imp__MsgWaitForMultipleObjects@20:PROC
EXTRN	_graphmutex:DWORD
EXTRN	_locking_thread:DWORD
EXTRN	__imp__GetCurrentThreadId@0:PROC
;	COMDAT ??_C@_0DA@LKKICLFJ@Can?8t?5do?5simplex?5Lagrange?5with?5b@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DA@LKKICLFJ@Can?8t?5do?5simplex?5Lagrange?5with?5b@ DB 'Can''t do '
	DB	'simplex Lagrange with boundaries yet.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IAOGAMEJ@Lagrange?5order?5must?5be?5at?5least?5@
CONST	SEGMENT
??_C@_0CE@IAOGAMEJ@Lagrange?5order?5must?5be?5at?5least?5@ DB 'Lagrange o'
	DB	'rder must be at least 1.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\model.c
CONST	ENDS
;	COMDAT _simplex_lagrange_to_lagrange
_TEXT	SEGMENT
tv1133 = -244						; size = 8
_old_ectrl$ = -240					; size = 4
_did_graphlock_here$90731 = -236			; size = 4
tv2312 = -232						; size = 4
tv1937 = -232						; size = 4
_trans$ = -228						; size = 4
_dim$ = -224						; size = 4
_newx$ = -220						; size = 4
tv1326 = -216						; size = 4
tv1208 = -216						; size = 4
_new_ectrl$ = -212					; size = 4
_oldx$ = -208						; size = 4
_old_fctrl$ = -208					; size = 4
_i$ = -204						; size = 4
_new_fctrl$ = -200					; size = 4
tv1711 = -196						; size = 4
_k$ = -196						; size = 4
tv1987 = -192						; size = 4
_newv$90877 = -192					; size = 4
_newv$90799 = -192					; size = 4
_v$90780 = -192						; size = 4
_e_id$ = -188						; size = 4
_f_id$ = -188						; size = 4
_m$ = -188						; size = 4
tv2293 = -184						; size = 4
tv2089 = -184						; size = 4
tv1918 = -184						; size = 4
tv1608 = -184						; size = 4
_conmap$90879 = -180					; size = 92
_conmap$90800 = -180					; size = 92
_cornerv$ = -88						; size = 28
_oldinx$ = -60						; size = 28
_inx$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_l_order$ = 8						; size = 4
_simplex_lagrange_to_lagrange PROC			; COMDAT

; 2218 : { int new_ectrl,new_fctrl; /* new number of control points */ 

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2219 :   int old_ectrl = web.skel[EDGE].ctrlpts;

	mov	eax, DWORD PTR _web+120

; 2220 :   int old_fctrl = web.skel[FACET].ctrlpts;

	mov	ecx, DWORD PTR _web+232
	push	esi

; 2221 :   int i,k,m; 
; 2222 :   int old,new;
; 2223 :   int inx[MAXCOORD+1];
; 2224 :   int oldinx[MAXCOORD+1];
; 2225 :   REAL **trans; /* transformation matrix old to new points */
; 2226 :   REAL **newx;  /* new coords */
; 2227 :   REAL **oldx;  /* old coords */
; 2228 :   facet_id f_id;
; 2229 :   edge_id e_id;
; 2230 :   vertex_id v_id;
; 2231 :   int dim;
; 2232 :   vertex_id cornerv[MAXCOORD+1]; /* extreme vertices of facet */
; 2233 : 
; 2234 :   if ( web.lagrange_order == l_order ) return; /* already OK */

	mov	esi, DWORD PTR _l_order$[ebp]
	mov	DWORD PTR _old_ectrl$[ebp], eax
	mov	DWORD PTR _old_fctrl$[ebp], ecx
	cmp	DWORD PTR _web+632, esi
	je	$LN1@simplex_la

; 2235 :   if ( l_order < 1 ) 

	cmp	esi, 1
	jge	SHORT $LN119@simplex_la

; 2236 :      kb_error(1817,"Lagrange order must be at least 1.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CE@IAOGAMEJ@Lagrange?5order?5must?5be?5at?5least?5@
	push	1817					; 00000719H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN119@simplex_la:

; 2237 : 
; 2238 :   ENTER_GRAPH_MUTEX;

	push	ebx
	push	edi
	mov	edi, DWORD PTR __imp__GetCurrentThreadId@0
	call	edi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN118@simplex_la
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	edi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$90731[ebp], 1
	jmp	SHORT $LN117@simplex_la
$LN118@simplex_la:
	mov	DWORD PTR _did_graphlock_here$90731[ebp], 0
$LN117@simplex_la:

; 2239 :   
; 2240 :   MFOR_ALL_VERTICES(v_id)  

	mov	edx, DWORD PTR _web+48
	test	edx, 268435456				; 10000000H
	je	SHORT $LN114@simplex_la
	mov	ebx, DWORD PTR _web+12
	npad	4
$LL116@simplex_la:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	edi, edi
	or	ecx, edi
	je	SHORT $LN115@simplex_la

; 2241 :     unset_attr(v_id,NEWVERTEX);  /* so can tell which new */

	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [ecx+12]
	and	DWORD PTR [ecx+8], -5			; fffffffbH
	mov	DWORD PTR [ecx+12], edx
	mov	ebx, DWORD PTR _web+12
$LN115@simplex_la:

; 2239 :   
; 2240 :   MFOR_ALL_VERTICES(v_id)  

	mov	eax, DWORD PTR [eax+ebx]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL116@simplex_la
$LN114@simplex_la:

; 2242 : 
; 2243 :   new_ectrl = binom_coeff(l_order+web.dimension-1,web.dimension-1);

	mov	eax, DWORD PTR _web+620
	lea	ecx, DWORD PTR [eax-1]
	push	ecx
	lea	edx, DWORD PTR [eax+esi-1]
	push	edx
	call	_binom_coeff
	mov	DWORD PTR _new_ectrl$[ebp], eax

; 2244 :   new_fctrl = binom_coeff(l_order+web.dimension,web.dimension);

	mov	eax, DWORD PTR _web+620
	push	eax
	add	eax, esi
	push	eax
	call	_binom_coeff

; 2245 :   baryhash_init(new_fctrl);

	push	eax
	mov	DWORD PTR _new_fctrl$[ebp], eax
	call	_baryhash_init
	add	esp, 20					; 00000014H

; 2246 :   
; 2247 :   if ( l_order > web.lagrange_order )

	cmp	esi, DWORD PTR _web+632
	jle	SHORT $LN111@simplex_la

; 2248 :   { expand_attribute(EDGE,E_VERTICES_ATTR,&new_ectrl);

	lea	eax, DWORD PTR _new_ectrl$[ebp]
	push	eax
	push	1
	push	1
	call	_expand_attribute

; 2249 :     expand_attribute(FACET,F_VERTICES_ATTR,&new_fctrl);

	lea	ecx, DWORD PTR _new_fctrl$[ebp]
	push	ecx
	push	1
	push	2
	call	_expand_attribute
	add	esp, 24					; 00000018H
$LN111@simplex_la:

; 2250 :   } /* have to wait for later for shrink case */
; 2251 : 
; 2252 :   /* recalc all facet points */
; 2253 :   trans = dmatrix(0,new_fctrl,0,old_fctrl);

	mov	edx, DWORD PTR _old_fctrl$[ebp]
	mov	eax, DWORD PTR _new_fctrl$[ebp]
	push	2253					; 000008cdH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	edx
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 2254 :   newx = dmatrix(0,new_fctrl,0,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _new_fctrl$[ebp]
	push	2254					; 000008ceH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	ecx
	push	0
	push	edx
	mov	esi, eax
	push	0
	mov	DWORD PTR _trans$[ebp], esi
	call	_kb_dmatrix

; 2255 :   oldx = dmatrix(0,old_fctrl,0,SDIM);

	mov	ecx, DWORD PTR _old_fctrl$[ebp]
	push	2255					; 000008cfH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	mov	DWORD PTR _newx$[ebp], eax
	mov	eax, DWORD PTR _web+616
	push	eax
	push	0
	push	ecx
	push	0
	call	_kb_dmatrix

; 2256 :   /* calculate transition matrix */
; 2257 :   dim = web.dimension;
; 2258 :   adjust_integration_orders(l_order);

	mov	edi, DWORD PTR _l_order$[ebp]
	mov	ebx, DWORD PTR _web+620
	add	esp, 72					; 00000048H
	push	edi
	mov	DWORD PTR _oldx$[ebp], eax
	call	_adjust_integration_orders

; 2259 :   gauss_lagrange_setup(dim,l_order,web.gauss2D_order);

	mov	edx, DWORD PTR _web+1596
	push	edx
	push	edi
	push	ebx
	call	_gauss_lagrange_setup
	add	esp, 16					; 00000010H

; 2260 :   for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN110@simplex_la

; 2250 :   } /* have to wait for later for shrink case */
; 2251 : 
; 2252 :   /* recalc all facet points */
; 2253 :   trans = dmatrix(0,new_fctrl,0,old_fctrl);

	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
	mov	edi, DWORD PTR _l_order$[ebp]
$LN110@simplex_la:

; 2261 :   inx[0] = l_order;

	fld1
	mov	DWORD PTR _inx$[ebp], edi
	mov	DWORD PTR tv1711[ebp], esi
$LN107@simplex_la:

; 2265 :      for ( m = 0 ; m <= dim ; m++ ) oldinx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN104@simplex_la

; 2262 :   new = 0;
; 2263 :   do
; 2264 :    { old = 0;

	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _oldinx$[ebp]
	rep stosd
$LN104@simplex_la:

; 2266 :      oldinx[0] = web.lagrange_order;

	mov	eax, DWORD PTR _web+632
	mov	ecx, DWORD PTR tv1711[ebp]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR _oldinx$[ebp], eax
$LN101@simplex_la:

; 2267 :      do
; 2268 :      { REAL prod;
; 2269 :         for ( k = 0, prod = 1.0 ; k <= dim ; k++ )

	xor	edx, edx
	fld	ST(0)
	test	ebx, ebx
	js	SHORT $LN96@simplex_la
$LN98@simplex_la:

; 2270 :          for ( m = 0 ; m < oldinx[k] ; m++ )

	mov	ecx, DWORD PTR _oldinx$[ebp+edx*4]
	xor	eax, eax
	mov	DWORD PTR _m$[ebp], eax
	test	ecx, ecx
	jle	SHORT $LN97@simplex_la
	fild	DWORD PTR _inx$[ebp+edx*4]
	mov	esi, ecx
	mov	DWORD PTR tv1608[ebp], ecx
	fidiv	DWORD PTR _l_order$[ebp]
	fimul	DWORD PTR _web+632
$LN199@simplex_la:

; 2271 :           prod *= ((REAL)(inx[k])/l_order*web.lagrange_order - m)/(oldinx[k]-m); 

	fild	DWORD PTR _m$[ebp]
	inc	eax
	mov	DWORD PTR _m$[ebp], eax
	fsubr	ST(0), ST(1)
	fidiv	DWORD PTR tv1608[ebp]
	dec	DWORD PTR tv1608[ebp]
	fmulp	ST(2), ST(0)
	cmp	eax, esi
	jl	SHORT $LN199@simplex_la

; 2270 :          for ( m = 0 ; m < oldinx[k] ; m++ )

	fstp	ST(0)
$LN97@simplex_la:

; 2267 :      do
; 2268 :      { REAL prod;
; 2269 :         for ( k = 0, prod = 1.0 ; k <= dim ; k++ )

	inc	edx
	cmp	edx, ebx
	jle	SHORT $LN98@simplex_la
$LN96@simplex_la:

; 2272 :         trans[new][old] = prod;
; 2273 :         old++;
; 2274 :      } while ( increment_lagrange_index(dim,oldinx) );

	lea	edx, DWORD PTR _oldinx$[ebp]
	fstp	QWORD PTR [edi]
	push	edx
	push	ebx
	add	edi, 8
	call	_increment_lagrange_index
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN101@simplex_la

; 2275 :      new++;

	add	DWORD PTR tv1711[ebp], 4

; 2276 :    } while ( increment_lagrange_index(dim,inx) );

	lea	eax, DWORD PTR _inx$[ebp]
	push	eax
	push	ebx
	call	_increment_lagrange_index
	add	esp, 8
	test	eax, eax
	jne	$LN107@simplex_la
	fstp	ST(0)

; 2277 :   /* calc indices of extreme vertices; handy elsewhere */
; 2278 :   for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN92@simplex_la
	lea	ecx, DWORD PTR [ebx+1]
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN92@simplex_la:

; 2279 :   for ( k = 0 ; k <= dim ; k++ )

	xor	esi, esi
	test	ebx, ebx
	js	SHORT $LN87@simplex_la
	mov	edi, DWORD PTR _l_order$[ebp]
$LL89@simplex_la:

; 2280 :      { inx[k] = l_order;
; 2281 :        new = lagrange_index(dim,l_order,inx);

	lea	ecx, DWORD PTR _inx$[ebp]
	push	ecx
	push	edi
	push	ebx
	mov	DWORD PTR _inx$[ebp+esi*4], edi
	call	_lagrange_index

; 2282 :        inx[k] = 0;

	mov	DWORD PTR _inx$[ebp+esi*4], 0

; 2283 :        web.skel[FACET].extreme[k] = new;

	mov	DWORD PTR _web[esi*4+296], eax
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, ebx
	jle	SHORT $LL89@simplex_la
$LN87@simplex_la:

; 2284 :      }
; 2285 : 
; 2286 :   MFOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+272
	mov	DWORD PTR _f_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	je	$LN84@simplex_la
$LL86@simplex_la:
	mov	eax, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1208[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN85@simplex_la

; 2289 :      get_facet_verts(f_id,oldx,NULL);

	mov	esi, DWORD PTR _oldx$[ebp]
	mov	eax, DWORD PTR _f_id$[ebp]
	mov	ebx, DWORD PTR _web+620
	push	ecx
	push	esi
	push	eax
	mov	DWORD PTR _dim$[ebp], ebx
	call	_get_facet_verts

; 2290 :      mat_mult(trans,oldx,newx,new_fctrl,web.skel[FACET].ctrlpts,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _web+232
	mov	eax, DWORD PTR _new_fctrl$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newx$[ebp]
	push	edx
	mov	edx, DWORD PTR _trans$[ebp]
	push	eax
	push	ecx
	push	esi
	push	edx
	call	_mat_mult

; 2291 :      v = get_facet_vertices(f_id);

	mov	ecx, DWORD PTR _web+236
	mov	eax, DWORD PTR tv1208[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+304]
	add	esp, 36					; 00000024H
	mov	DWORD PTR _v$90780[ebp], eax

; 2292 : 
; 2293 :      /* take care of extreme vertices */
; 2294 :      for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN81@simplex_la

; 2287 :    { vertex_id *v;
; 2288 :      dim = web.dimension;

	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN81@simplex_la:

; 2295 :      for ( k = 0 ; k <= dim ; k++ )

	xor	esi, esi
	test	ebx, ebx
	js	SHORT $LN75@simplex_la
	mov	edi, DWORD PTR _v$90780[ebp]
$LL78@simplex_la:

; 2296 :         { inx[k] = web.lagrange_order; 

	mov	eax, DWORD PTR _web+632

; 2297 :           old = lagrange_index(dim,web.lagrange_order,inx); 

	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	push	eax
	push	ebx
	mov	DWORD PTR _inx$[ebp+esi*4], eax
	call	_lagrange_index

; 2298 :           inx[k] = 0;
; 2299 :           cornerv[k] = v[old];

	mov	eax, DWORD PTR [edi+eax*4]
	lea	ecx, DWORD PTR _cornerv$[ebp+esi*4]

; 2300 :           baryhash_find(1,&cornerv[k],&l_order,cornerv[k]);

	push	eax
	mov	DWORD PTR [ecx], eax
	lea	eax, DWORD PTR _l_order$[ebp]
	push	eax
	push	ecx
	push	1
	mov	DWORD PTR _inx$[ebp+esi*4], 0
	call	_baryhash_find
	inc	esi
	add	esp, 28					; 0000001cH
	cmp	esi, ebx
	jle	SHORT $LL78@simplex_la

; 2301 :         }
; 2302 : 
; 2303 :      /* create new interior */
; 2304 :      for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN75@simplex_la:

; 2305 :      inx[0] = l_order;
; 2306 :      for ( k = 0 ; k < new_fctrl ; k++ )

	cmp	DWORD PTR _new_fctrl$[ebp], 0
	mov	ecx, DWORD PTR _l_order$[ebp]
	mov	DWORD PTR _inx$[ebp], ecx
	mov	DWORD PTR _k$[ebp], 0
	jle	$LN85@simplex_la
	mov	ecx, DWORD PTR _v$90780[ebp]
	mov	eax, DWORD PTR _newx$[ebp]
	sub	eax, ecx
	lea	edi, DWORD PTR [ebx+1]
	mov	DWORD PTR tv1918[ebp], ecx
	mov	DWORD PTR tv1937[ebp], eax
	npad	2
$LL72@simplex_la:

; 2307 :      { int fixed;
; 2308 :         vertex_id newv;
; 2309 :         conmap_t conmap[MAXCONPER];  // for common
; 2310 :         newv = baryhash_find(dim+1,cornerv,inx,NULLID);

	push	0
	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	lea	eax, DWORD PTR _cornerv$[ebp]
	push	eax
	push	edi
	call	_baryhash_find
	mov	esi, eax
	add	esp, 16					; 00000010H

; 2311 :         if ( newv == NULLID )

	test	esi, esi
	jne	$LN69@simplex_la

; 2312 :         { newv = new_vertex(newx[k],f_id);  

	mov	ecx, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR tv1937[ebp]
	mov	eax, DWORD PTR tv1918[ebp]
	push	ecx
	mov	ecx, DWORD PTR [edx+eax]
	push	ecx
	call	_new_vertex
	mov	esi, eax

; 2313 :           set_attr(newv,Q_MIDFACET);

	mov	edx, esi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 2097152		; 00200000H
	mov	DWORD PTR [eax+12], ecx

; 2314 :           set_vertex_facet(newv,f_id);  /* since doesn't have edge */

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [edi+edx]
	mov	ecx, DWORD PTR _f_id$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 2315 :           /* set common attributes */
; 2316 :           for ( i = 0, fixed = 0; i <= dim ; i++ )

	xor	eax, eax
	add	esp, 8
	mov	DWORD PTR _newv$90799[ebp], esi
	mov	DWORD PTR _i$[ebp], eax
	test	ebx, ebx
	js	$LN189@simplex_la
$LL68@simplex_la:

; 2317 :           { if ( inx[i] == 0 ) continue; /* doesn't contribute */

	cmp	DWORD PTR _inx$[ebp+eax*4], 0
	je	$LN67@simplex_la

; 2318 :              if ( get_vattr(cornerv[i]) & FIXED ) fixed = 0;
; 2319 :              /* find centerpoint parameters for facet on boundary */
; 2320 :              if ( get_vattr(cornerv[i]) & BOUNDARY )    /* not working for torus */

	mov	edx, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR _cornerv$[ebp+edx*4]
	mov	eax, DWORD PTR _web+12
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN63@simplex_la

; 2321 :                 kb_error(1819,"Can't do simplex Lagrange with boundaries yet.\n",
; 2322 :                   RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DA@LKKICLFJ@Can?8t?5do?5simplex?5Lagrange?5with?5b@
	push	1819					; 0000071bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN63@simplex_la:

; 2323 :              if ( get_vattr(cornerv[i]) & CONSTRAINT )    

	mov	ecx, DWORD PTR _web+12
	mov	esi, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [esi+8]

; 2324 :              { get_v_common_conmap(newv,cornerv[i],conmap,MAXCONPER);

	mov	esi, DWORD PTR _newv$90799[ebp]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN195@simplex_la
	push	23					; 00000017H
	lea	edx, DWORD PTR _conmap$90800[ebp]
	push	edx
	push	ebx
	push	esi
	call	_get_v_common_conmap

; 2325 :                set_v_conmap(newv,conmap);

	lea	eax, DWORD PTR _conmap$90800[ebp]
	push	eax
	push	esi
	call	_set_v_conmap
	add	esp, 24					; 00000018H
$LN195@simplex_la:
	mov	ebx, DWORD PTR _dim$[ebp]
$LN67@simplex_la:

; 2315 :           /* set common attributes */
; 2316 :           for ( i = 0, fixed = 0; i <= dim ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, ebx
	jle	$LL68@simplex_la
$LN189@simplex_la:

; 2326 :              }
; 2327 :           }
; 2328 :           if ( fixed ) set_attr(newv,FIXED);
; 2329 :           if ( get_vattr(newv) & CONSTRAINT )

	mov	ecx, DWORD PTR _web+12
	mov	edi, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN60@simplex_la

; 2330 :              project_v_constr(newv,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	push	1
	push	1
	push	esi
	call	_project_v_constr
	add	esp, 12					; 0000000cH
$LN60@simplex_la:

; 2331 :           baryhash_find(dim+1,cornerv,inx,newv);

	push	esi
	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	lea	eax, DWORD PTR _cornerv$[ebp]
	push	eax
	lea	edi, DWORD PTR [ebx+1]
	push	edi
	call	_baryhash_find
	add	esp, 16					; 00000010H
$LN69@simplex_la:

; 2332 :         }
; 2333 :         v[k] = newv;

	mov	ecx, DWORD PTR tv1918[ebp]

; 2334 :         increment_lagrange_index(dim,inx);

	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	push	ebx
	mov	DWORD PTR [ecx], esi
	call	_increment_lagrange_index
	mov	eax, DWORD PTR _k$[ebp]
	add	DWORD PTR tv1918[ebp], 4
	inc	eax
	add	esp, 8
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _new_fctrl$[ebp]
	jl	$LL72@simplex_la
$LN85@simplex_la:

; 2284 :      }
; 2285 : 
; 2286 :   MFOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR tv1208[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _f_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL86@simplex_la
$LN84@simplex_la:

; 2341 :   gauss_lagrange_setup(dim,l_order,web.gauss1D_order);

	mov	eax, DWORD PTR _web+1592
	mov	esi, DWORD PTR _web+620
	mov	ecx, DWORD PTR _l_order$[ebp]
	push	eax
	dec	esi
	push	ecx
	push	esi
	mov	DWORD PTR _dim$[ebp], esi
	call	_gauss_lagrange_setup
	add	esp, 12					; 0000000cH

; 2342 : 
; 2343 :   for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	test	esi, esi
	js	SHORT $LN59@simplex_la

; 2335 :      }
; 2336 :    }
; 2337 : 
; 2338 :   /* do edges */
; 2339 :   /* calculate transition matrix */
; 2340 :   dim = web.dimension-1;

	lea	ecx, DWORD PTR [esi+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN59@simplex_la:

; 2344 :   inx[0] = l_order;

	mov	edx, DWORD PTR _l_order$[ebp]
	fld1
	mov	eax, DWORD PTR _trans$[ebp]
	mov	DWORD PTR _inx$[ebp], edx
	mov	DWORD PTR tv2089[ebp], eax
$LN56@simplex_la:

; 2348 :      for ( m = 0 ; m <= dim ; m++ ) oldinx[m] = 0;

	test	esi, esi
	js	SHORT $LN53@simplex_la

; 2345 :   new = 0;
; 2346 :   do
; 2347 :   { old = 0;

	lea	ecx, DWORD PTR [esi+1]
	xor	eax, eax
	lea	edi, DWORD PTR _oldinx$[ebp]
	rep stosd
$LN53@simplex_la:

; 2349 :      oldinx[0] = web.lagrange_order;

	mov	ecx, DWORD PTR _web+632
	mov	edx, DWORD PTR tv2089[ebp]
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR _oldinx$[ebp], ecx
$LN50@simplex_la:

; 2350 :      do
; 2351 :      { REAL prod;
; 2352 :         for ( k = 0, prod = 1.0 ; k <= dim ; k++ )

	xor	edx, edx
	fld	ST(0)
	test	esi, esi
	js	SHORT $LN45@simplex_la
$LN47@simplex_la:

; 2353 :          for ( m = 0 ; m < oldinx[k] ; m++ )

	mov	ecx, DWORD PTR _oldinx$[ebp+edx*4]
	xor	eax, eax
	mov	DWORD PTR _m$[ebp], eax
	test	ecx, ecx
	jle	SHORT $LN46@simplex_la
	fild	DWORD PTR _inx$[ebp+edx*4]
	mov	edi, ecx
	mov	DWORD PTR tv1987[ebp], ecx
	fidiv	DWORD PTR _l_order$[ebp]
	fimul	DWORD PTR _web+632
$LN44@simplex_la:

; 2354 :           prod *= ((REAL)(inx[k])/l_order*web.lagrange_order - m)/(oldinx[k]-m); 

	fild	DWORD PTR _m$[ebp]
	inc	eax
	mov	DWORD PTR _m$[ebp], eax
	fsubr	ST(0), ST(1)
	fidiv	DWORD PTR tv1987[ebp]
	dec	DWORD PTR tv1987[ebp]
	fmulp	ST(2), ST(0)
	cmp	eax, edi
	jl	SHORT $LN44@simplex_la

; 2353 :          for ( m = 0 ; m < oldinx[k] ; m++ )

	fstp	ST(0)
$LN46@simplex_la:

; 2350 :      do
; 2351 :      { REAL prod;
; 2352 :         for ( k = 0, prod = 1.0 ; k <= dim ; k++ )

	inc	edx
	cmp	edx, esi
	jle	SHORT $LN47@simplex_la
$LN45@simplex_la:

; 2355 :         trans[new][old] = prod;
; 2356 :         old++;
; 2357 :      } while ( increment_lagrange_index(dim,oldinx) );

	lea	eax, DWORD PTR _oldinx$[ebp]
	fstp	QWORD PTR [ebx]
	push	eax
	push	esi
	add	ebx, 8
	call	_increment_lagrange_index
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN50@simplex_la

; 2358 :      new++;

	add	DWORD PTR tv2089[ebp], 4

; 2359 :   } while ( increment_lagrange_index(dim,inx) );

	lea	ecx, DWORD PTR _inx$[ebp]
	push	ecx
	push	esi
	call	_increment_lagrange_index
	add	esp, 8
	test	eax, eax
	jne	$LN56@simplex_la

; 2360 : 
; 2361 :   /* calc indices of extreme vertices; handy elsewhere */
; 2362 :   for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	mov	ebx, DWORD PTR _l_order$[ebp]
	fstp	ST(0)
	test	esi, esi
	js	SHORT $LN41@simplex_la
	lea	ecx, DWORD PTR [esi+1]
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN41@simplex_la:

; 2363 :   for ( k = 0 ; k <= dim ; k++ )

	xor	edi, edi
	test	esi, esi
	js	SHORT $LN36@simplex_la
$LL38@simplex_la:

; 2364 :      { inx[k] = l_order;
; 2365 :         new = lagrange_index(dim,l_order,inx);

	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	push	ebx
	push	esi
	mov	DWORD PTR _inx$[ebp+edi*4], ebx
	call	_lagrange_index

; 2366 :         inx[k] = 0;

	mov	DWORD PTR _inx$[ebp+edi*4], 0

; 2367 :         web.skel[EDGE].extreme[k] = new;

	mov	DWORD PTR _web[edi*4+184], eax
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, esi
	jle	SHORT $LL38@simplex_la
$LN36@simplex_la:

; 2368 :      }
; 2369 : 
; 2370 :   MFOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+160
	mov	DWORD PTR _e_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	je	$LN33@simplex_la
	npad	2
$LL35@simplex_la:
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1326[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN34@simplex_la

; 2371 :   { vertex_id *v;
; 2372 :      get_edge_verts(e_id,oldx,NULL);

	mov	edi, DWORD PTR _oldx$[ebp]
	mov	edx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	edi
	push	edx
	call	_get_edge_verts

; 2373 :      mat_mult(trans,oldx,newx,new_ectrl,old_ectrl,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _old_ectrl$[ebp]
	mov	edx, DWORD PTR _new_ectrl$[ebp]
	push	eax
	mov	eax, DWORD PTR _newx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _trans$[ebp]
	push	edx
	push	eax
	push	edi
	push	ecx
	call	_mat_mult

; 2374 :      v = get_edge_vertices(e_id);

	mov	edx, DWORD PTR tv1326[ebp]
	mov	eax, DWORD PTR _web+124
	mov	ebx, DWORD PTR [edx+eax]
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	add	ebx, DWORD PTR [ecx+edx+304]
	add	esp, 36					; 00000024H

; 2375 : 
; 2376 :      /* take care of extreme vertices */
; 2377 :      for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	test	esi, esi
	js	SHORT $LN30@simplex_la

; 2371 :   { vertex_id *v;
; 2372 :      get_edge_verts(e_id,oldx,NULL);

	lea	ecx, DWORD PTR [esi+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN30@simplex_la:

; 2378 :      for ( k = 0 ; k <= dim ; k++ )

	xor	edi, edi
	test	esi, esi
	js	SHORT $LN24@simplex_la
$LL27@simplex_la:

; 2379 :         { inx[k] = web.lagrange_order; 

	mov	eax, DWORD PTR _web+632

; 2380 :           old = lagrange_index(dim,web.lagrange_order,inx); 

	lea	ecx, DWORD PTR _inx$[ebp]
	push	ecx
	push	eax
	push	esi
	mov	DWORD PTR _inx$[ebp+edi*4], eax
	call	_lagrange_index

; 2381 :           cornerv[k] = v[old];

	mov	eax, DWORD PTR [ebx+eax*4]

; 2382 :           baryhash_find(1,&cornerv[k],&l_order,cornerv[k]);

	push	eax
	lea	edx, DWORD PTR _l_order$[ebp]
	lea	ecx, DWORD PTR _cornerv$[ebp+edi*4]
	push	edx
	push	ecx
	push	1
	mov	DWORD PTR [ecx], eax
	call	_baryhash_find
	inc	edi
	add	esp, 28					; 0000001cH
	cmp	edi, esi
	jle	SHORT $LL27@simplex_la

; 2383 :         }
; 2384 : 
; 2385 :      /* create new interior */
; 2386 :      for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	lea	ecx, DWORD PTR [esi+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN24@simplex_la:

; 2387 :      inx[0] = l_order;
; 2388 :      for ( k = 0 ; k < new_ectrl ; k++ )

	cmp	DWORD PTR _new_ectrl$[ebp], 0
	mov	eax, DWORD PTR _l_order$[ebp]
	mov	DWORD PTR _inx$[ebp], eax
	mov	DWORD PTR _k$[ebp], 0
	jle	$LN34@simplex_la
	mov	eax, DWORD PTR _newx$[ebp]
	sub	eax, ebx
	lea	edi, DWORD PTR [esi+1]
	mov	DWORD PTR tv2293[ebp], ebx
	mov	DWORD PTR tv2312[ebp], eax
$LL21@simplex_la:

; 2389 :      { int fixed;
; 2390 :         vertex_id newv;
; 2391 :         newv = baryhash_find(dim+1,cornerv,inx,NULLID);

	push	0
	lea	ecx, DWORD PTR _inx$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cornerv$[ebp]
	push	edx
	push	edi
	call	_baryhash_find
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 2392 :         if ( newv == NULLID )

	test	ebx, ebx
	jne	$LN18@simplex_la

; 2393 :         { conmap_t conmap[MAXCONPER];
; 2394 :           newv = new_vertex(newx[k],e_id);  

	mov	eax, DWORD PTR _e_id$[ebp]
	mov	ecx, DWORD PTR tv2312[ebp]
	mov	edx, DWORD PTR tv2293[ebp]
	push	eax
	mov	eax, DWORD PTR [ecx+edx]
	push	eax
	call	_new_vertex
	mov	ebx, eax

; 2395 :           set_attr(newv,Q_MIDEDGE);

	mov	ecx, ebx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edx+edi]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 4194304		; 00400000H
	mov	DWORD PTR [eax+12], ecx

; 2396 :           set_vertex_edge(newv,e_id); 

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [edi+edx]
	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 2397 :           /* set common attributes */
; 2398 :           for ( i = 0, fixed = 0; i <= dim ; i++ )

	xor	eax, eax
	add	esp, 8
	mov	DWORD PTR _newv$90877[ebp], ebx
	mov	DWORD PTR _i$[ebp], eax
	test	esi, esi
	js	$LN190@simplex_la
$LL17@simplex_la:

; 2399 :           { if ( inx[i] == 0 ) continue; /* doesn't contribute */

	cmp	DWORD PTR _inx$[ebp+eax*4], 0
	je	$LN16@simplex_la

; 2400 :              if ( get_vattr(cornerv[i]) & FIXED ) fixed = 0;
; 2401 :              /* find centerpoint parameters for facet on boundary */
; 2402 :              if ( get_vattr(cornerv[i]) & BOUNDARY )    /* not working for torus */

	mov	edx, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR _cornerv$[ebp+edx*4]
	mov	eax, DWORD PTR _web+12
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN12@simplex_la

; 2403 :                 kb_error(1820,"Can't do simplex Lagrange with boundaries yet.\n",
; 2404 :                   RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DA@LKKICLFJ@Can?8t?5do?5simplex?5Lagrange?5with?5b@
	push	1820					; 0000071cH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN12@simplex_la:

; 2405 :              if ( get_vattr(cornerv[i]) & CONSTRAINT )    

	mov	ecx, DWORD PTR _web+12
	mov	esi, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN191@simplex_la

; 2406 :              { get_v_common_conmap(newv,cornerv[i],conmap,MAXCONPER);

	mov	esi, DWORD PTR _newv$90877[ebp]
	push	23					; 00000017H
	lea	edx, DWORD PTR _conmap$90879[ebp]
	push	edx
	push	ebx
	push	esi
	call	_get_v_common_conmap

; 2407 :                 set_v_conmap(newv,conmap);

	lea	eax, DWORD PTR _conmap$90879[ebp]
	push	eax
	push	esi
	call	_set_v_conmap
	add	esp, 24					; 00000018H
$LN191@simplex_la:
	mov	ebx, DWORD PTR _newv$90877[ebp]
	mov	esi, DWORD PTR _dim$[ebp]
$LN16@simplex_la:

; 2397 :           /* set common attributes */
; 2398 :           for ( i = 0, fixed = 0; i <= dim ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, esi
	jle	$LL17@simplex_la
$LN190@simplex_la:

; 2408 :              }
; 2409 :           }
; 2410 :           if ( fixed ) set_attr(newv,FIXED);
; 2411 :           if ( get_vattr(newv) & CONSTRAINT )

	mov	ecx, DWORD PTR _web+12
	mov	edi, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN9@simplex_la

; 2412 :              project_v_constr(newv,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	push	1
	push	1
	push	ebx
	call	_project_v_constr
	add	esp, 12					; 0000000cH
$LN9@simplex_la:

; 2413 :           baryhash_find(dim+1,cornerv,inx,newv);

	push	ebx
	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	lea	eax, DWORD PTR _cornerv$[ebp]
	push	eax
	lea	edi, DWORD PTR [esi+1]
	push	edi
	call	_baryhash_find
	add	esp, 16					; 00000010H
$LN18@simplex_la:

; 2414 :         }
; 2415 :         v[k] = newv;

	mov	ecx, DWORD PTR tv2293[ebp]

; 2416 :         increment_lagrange_index(dim,inx);

	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	push	esi
	mov	DWORD PTR [ecx], ebx
	call	_increment_lagrange_index
	mov	eax, DWORD PTR _k$[ebp]
	add	DWORD PTR tv2293[ebp], 4
	inc	eax
	add	esp, 8
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _new_ectrl$[ebp]
	jl	$LL21@simplex_la
$LN34@simplex_la:

; 2368 :      }
; 2369 : 
; 2370 :   MFOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR tv1326[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _e_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL35@simplex_la
$LN33@simplex_la:

; 2417 :      }
; 2418 :   }
; 2419 :     
; 2420 :   free_matrix(trans);

	mov	eax, DWORD PTR _trans$[ebp]
	push	eax
	call	_free_matrix

; 2421 :   free_matrix(newx);

	mov	ecx, DWORD PTR _newx$[ebp]
	push	ecx
	call	_free_matrix

; 2422 :   free_matrix(oldx);

	mov	edx, DWORD PTR _oldx$[ebp]
	push	edx
	call	_free_matrix
	add	esp, 12					; 0000000cH

; 2423 :   baryhash_end();

	call	_baryhash_end

; 2424 : 
; 2425 :   if ( l_order < web.lagrange_order )

	mov	esi, DWORD PTR _l_order$[ebp]
	cmp	esi, DWORD PTR _web+632
	jge	SHORT $LN193@simplex_la

; 2426 :   { expand_attribute(EDGE,E_VERTICES_ATTR,&new_ectrl);

	lea	eax, DWORD PTR _new_ectrl$[ebp]
	push	eax
	push	1
	push	1
	call	_expand_attribute

; 2427 :     expand_attribute(FACET,F_VERTICES_ATTR,&new_fctrl);

	lea	ecx, DWORD PTR _new_fctrl$[ebp]
	push	ecx
	push	1
	push	2
	call	_expand_attribute
	add	esp, 24					; 00000018H
$LN193@simplex_la:

; 2428 :   } /* can now shrink  */
; 2429 : 
; 2430 :   /* delete all old non-extreme vertices */
; 2431 :   MFOR_ALL_VERTICES(v_id)  

	mov	edi, DWORD PTR _web+48
	test	edi, 268435456				; 10000000H
	je	SHORT $LN194@simplex_la
	mov	ebx, DWORD PTR _web+12
	npad	7
$LL7@simplex_la:
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ebx]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	mov	DWORD PTR tv1133[ebp+4], edx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN6@simplex_la

; 2432 :   { if ( !(get_vattr(v_id) & NEWVERTEX)
; 2433 :                 && (get_vattr(v_id) & (Q_MIDFACET|Q_MIDEDGE)) )

	mov	eax, ecx
	and	eax, 4
	or	eax, edx
	jne	SHORT $LN6@simplex_la
	and	ecx, 6291456				; 00600000H
	or	ecx, eax
	je	SHORT $LN6@simplex_la

; 2434 :          free_element(v_id);

	push	edi
	call	_free_element
	mov	ebx, DWORD PTR _web+12
	add	esp, 4
$LN6@simplex_la:

; 2428 :   } /* can now shrink  */
; 2429 : 
; 2430 :   /* delete all old non-extreme vertices */
; 2431 :   MFOR_ALL_VERTICES(v_id)  

	mov	eax, DWORD PTR [esi+ebx]
	mov	edi, DWORD PTR [eax]
	test	edi, 268435456				; 10000000H
	jne	SHORT $LL7@simplex_la
	mov	esi, DWORD PTR _l_order$[ebp]
$LN194@simplex_la:

; 2435 :   }
; 2436 : 
; 2437 :   web.lagrange_order = l_order;
; 2438 :   web.skel[FACET].ctrlpts = new_fctrl;
; 2439 :   web.skel[EDGE].ctrlpts = edge_ctrl = new_ectrl;

	mov	eax, DWORD PTR _new_ectrl$[ebp]
	mov	ecx, DWORD PTR _new_fctrl$[ebp]
	mov	DWORD PTR _edge_ctrl, eax
	mov	DWORD PTR _web+120, eax

; 2440 :   change_flag = 1;
; 2441 :   web_timestamp = top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax

; 2442 :   web.headvnum = l_order;
; 2443 : 
; 2444 :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$90731[ebp], 0
	pop	edi
	mov	DWORD PTR _web+632, esi
	mov	DWORD PTR _web+232, ecx
	mov	DWORD PTR _change_flag, 1
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	DWORD PTR _web_timestamp, eax
	mov	DWORD PTR _web+636, esi
	pop	ebx
	je	SHORT $LN1@simplex_la
	mov	edx, DWORD PTR _graphmutex
	push	edx
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@simplex_la:

; 2445 : } // end simplex_lagrange_to_lagrange()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_lagrange_to_lagrange ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EI@HCOKNLCI@Vertices?5?$CFs?5and?5?$CFs?5of?5edge?5?$CFs?5ar@ ; `string'
PUBLIC	??_C@_04CGFJFPFD@none?$AA@			; `string'
PUBLIC	??_C@_0DA@LMEBNNDO@Can?8t?5do?5Lagrange?5boundaries?5in?5@ ; `string'
PUBLIC	??_C@_0DF@MOLBPHPK@Could?5not?5find?5vertex?5on?5same?5bo@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	__real@3fb999999999999a
PUBLIC	??_C@_0CE@KCBPNPDA@Lagrange?5order?5must?5be?5at?5most?5?$CF@ ; `string'
PUBLIC	_l_order$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_lagrange_to_lagrange
EXTRN	_recalc:PROC
EXTRN	_setup_q_info:PROC
EXTRN	_E_BOUNDARY_ATTR:DWORD
EXTRN	_bezier_trans_1d:PROC
EXTRN	_nullcon:QWORD
EXTRN	_b_extrapolate:PROC
EXTRN	_msg:DWORD
EXTRN	_elnames:BYTE
EXTRN	_eval:PROC
EXTRN	_NULLVERTEX:DWORD
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	_F_BOUNDARY_ATTR:DWORD
EXTRN	_bezier_trans_2d:PROC
EXTRN	_bezier_refine_2d_init:PROC
EXTRN	_bezier_refine_1d_init:PROC
;	COMDAT ??_C@_0EI@HCOKNLCI@Vertices?5?$CFs?5and?5?$CFs?5of?5edge?5?$CFs?5ar@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EI@HCOKNLCI@Vertices?5?$CFs?5and?5?$CFs?5of?5edge?5?$CFs?5ar@ DB 'V'
	DB	'ertices %s and %s of edge %s are on different boundaries, %s,'
	DB	' %s, %s.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGFJFPFD@none?$AA@
CONST	SEGMENT
??_C@_04CGFJFPFD@none?$AA@ DB 'none', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@LMEBNNDO@Can?8t?5do?5Lagrange?5boundaries?5in?5@
CONST	SEGMENT
??_C@_0DA@LMEBNNDO@Can?8t?5do?5Lagrange?5boundaries?5in?5@ DB 'Can''t do '
	DB	'Lagrange boundaries in SIMPLEX model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@MOLBPHPK@Could?5not?5find?5vertex?5on?5same?5bo@
CONST	SEGMENT
??_C@_0DF@MOLBPHPK@Could?5not?5find?5vertex?5on?5same?5bo@ DB 'Could not '
	DB	'find vertex on same boundary as facet %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT ??_C@_0CE@KCBPNPDA@Lagrange?5order?5must?5be?5at?5most?5?$CF@
CONST	SEGMENT
??_C@_0CE@KCBPNPDA@Lagrange?5order?5must?5be?5at?5most?5?$CF@ DB 'Lagrang'
	DB	'e order must be at most %d.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\model.c
CONST	ENDS
;	COMDAT _lagrange_to_lagrange
_TEXT	SEGMENT
tv2377 = -256						; size = 8
tv4155 = -252						; size = 4
_ev$89527 = -252					; size = 4
tv2662 = -248						; size = 8
tv2813 = -244						; size = 4
tv973 = -244						; size = 4
_did_graphlock_here$89176 = -240			; size = 4
_oldx$ = -236						; size = 4
_k$ = -232						; size = 4
tv946 = -228						; size = 4
_old_fctrl$ = -228					; size = 4
_newx$ = -224						; size = 4
tv4103 = -220						; size = 4
tv2371 = -220						; size = 4
_trans$ = -216						; size = 4
tv2855 = -212						; size = 4
tv2653 = -212						; size = 4
_old$ = -212						; size = 4
_new_ectrl$ = -208					; size = 4
tv3864 = -204						; size = 4
tv3674 = -204						; size = 4
tv919 = -204						; size = 4
_v$89375 = -200						; size = 4
_bdry$89276 = -200					; size = 4
_new_fctrl$ = -196					; size = 4
tv4355 = -192						; size = 4
tv4285 = -192						; size = 4
_old_ectrl$ = -192					; size = 4
_dim$ = -188						; size = 4
tv3881 = -184						; size = 4
tv3729 = -184						; size = 4
tv3373 = -184						; size = 4
_tailv$89430 = -184					; size = 4
_l_order$GSCopy$ = -180					; size = 4
tv2370 = -176						; size = 4
tv985 = -176						; size = 4
_headv$89429 = -176					; size = 4
tv4382 = -172						; size = 4
tv4312 = -172						; size = 4
tv3356 = -172						; size = 4
tv1506 = -172						; size = 4
_base_v$89428 = -172					; size = 4
_v$89526 = -168						; size = 4
_bdry$89423 = -168					; size = 4
_f_id$ = -168						; size = 4
tv3779 = -164						; size = 4
tv3270 = -164						; size = 4
tv2869 = -164						; size = 4
_e_id$ = -164						; size = 4
_base_v$89274 = -164					; size = 4
tv2655 = -160						; size = 4
tv2368 = -160						; size = 4
_fe$89528 = -160					; size = 4
_m$ = -160						; size = 4
_defaultp$89270 = -156					; size = 48
_s$89275 = -108						; size = 48
_oldinx$ = -60						; size = 28
_inx$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_l_order$ = 8						; size = 4
_lagrange_to_lagrange PROC				; COMDAT

; 209  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 210  :   int new_ectrl,new_fctrl; /* new number of control points */ 
; 211  :   int old_ectrl = web.skel[EDGE].ctrlpts;

	mov	eax, DWORD PTR _web+120
	push	ebx

; 212  :   int old_fctrl = web.skel[FACET].ctrlpts;

	mov	ebx, DWORD PTR _web+232
	push	esi
	mov	esi, DWORD PTR _l_order$[ebp]
	mov	DWORD PTR _l_order$GSCopy$[ebp], esi
	mov	DWORD PTR _old_ectrl$[ebp], eax
	mov	DWORD PTR _old_fctrl$[ebp], ebx

; 213  :   int i,k,m,spot; 
; 214  :   int old,new;
; 215  :   int inx[MAXCOORD+1];
; 216  :   int oldinx[MAXCOORD+1];
; 217  :   REAL **trans; /* transformation matrix old to new points */
; 218  :   REAL **newx;  /* new coords */
; 219  :   REAL **oldx;  /* old coords */
; 220  :   int zeros;
; 221  :   facet_id f_id;
; 222  :   edge_id e_id;
; 223  :   int dim;
; 224  : 
; 225  : 
; 226  :   if ( web.lagrange_order == l_order ) return; /* already OK */

	cmp	DWORD PTR _web+632, esi
	je	$LN190@lagrange_t@2

; 227  :   if ( l_order < 1 ) 

	cmp	esi, 1
	jge	SHORT $LN188@lagrange_t@2

; 228  :      kb_error(1799,"Lagrange order must be at least 1.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CE@IAOGAMEJ@Lagrange?5order?5must?5be?5at?5least?5@
	push	1799					; 00000707H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN188@lagrange_t@2:

; 229  :   if ( l_order > MAXLAGRANGE ) 

	cmp	esi, 20					; 00000014H
	jle	SHORT $LN187@lagrange_t@2

; 230  :   { sprintf(errmsg,"Lagrange order must be at most %d.\n",MAXLAGRANGE);

	push	20					; 00000014H
	push	OFFSET ??_C@_0CE@KCBPNPDA@Lagrange?5order?5must?5be?5at?5most?5?$CF@
	push	OFFSET _errmsg
	call	_sprintf

; 231  :     kb_error(3505,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3505					; 00000db1H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN187@lagrange_t@2:

; 232  :   }
; 233  : 
; 234  : #ifdef MPI_EVOLVER
; 235  :   if ( this_task == MASTER_TASK )
; 236  :     mpi_model(l_order,LAGRANGE);
; 237  : #endif
; 238  : 
; 239  :   ENTER_GRAPH_MUTEX;

	push	edi
	mov	edi, DWORD PTR __imp__GetCurrentThreadId@0
	call	edi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN186@lagrange_t@2
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	edi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89176[ebp], 1
	jmp	SHORT $LN185@lagrange_t@2
$LN186@lagrange_t@2:
	mov	DWORD PTR _did_graphlock_here$89176[ebp], 0
$LN185@lagrange_t@2:

; 240  : 
; 241  :   bezier_refine_1d_init(l_order);

	push	esi
	call	_bezier_refine_1d_init

; 242  :   bezier_refine_2d_init(l_order);

	push	esi
	call	_bezier_refine_2d_init

; 243  : 
; 244  :   if ( web.representation == SIMPLEX )

	mov	eax, DWORD PTR _web+624
	add	esp, 8
	cmp	eax, 3
	jne	SHORT $LN184@lagrange_t@2

; 245  :   { simplex_lagrange_to_lagrange(l_order); return; }

	push	esi
	call	_simplex_lagrange_to_lagrange
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 618  : 
; 619  : } /* end of lagrange_to_lagrange() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN184@lagrange_t@2:

; 246  : 
; 247  :   if ( web.representation == STRING )

	cmp	eax, 1

; 248  :   { new_ectrl = binom_coeff(l_order+web.dimension,web.dimension);

	mov	eax, DWORD PTR _web+620
	jne	SHORT $LN183@lagrange_t@2
	push	eax
	lea	ecx, DWORD PTR [esi+eax]
	push	ecx
	call	_binom_coeff
	mov	DWORD PTR _new_ectrl$[ebp], eax

; 249  :     new_fctrl = binom_coeff(l_order+web.dimension+1,web.dimension+1);

	mov	eax, DWORD PTR _web+620
	lea	edx, DWORD PTR [eax+1]
	push	edx
	lea	eax, DWORD PTR [esi+eax+1]

; 250  :   }
; 251  :   else 

	jmp	SHORT $LN442@lagrange_t@2
$LN183@lagrange_t@2:

; 252  :   { new_ectrl = binom_coeff(l_order+web.dimension-1,web.dimension-1);

	lea	ecx, DWORD PTR [eax-1]
	push	ecx
	lea	edx, DWORD PTR [esi+eax-1]
	push	edx
	call	_binom_coeff
	mov	DWORD PTR _new_ectrl$[ebp], eax

; 253  :     new_fctrl = binom_coeff(l_order+web.dimension,web.dimension);

	mov	eax, DWORD PTR _web+620
	push	eax
	add	eax, esi
$LN442@lagrange_t@2:
	push	eax
	call	_binom_coeff
	add	esp, 16					; 00000010H
	mov	DWORD PTR _new_fctrl$[ebp], eax

; 254  :   }
; 255  :   if ( l_order > web.lagrange_order )

	cmp	esi, DWORD PTR _web+632
	jle	SHORT $LN181@lagrange_t@2

; 256  :   { expand_attribute(EDGE,E_VERTICES_ATTR,&new_ectrl);

	lea	ecx, DWORD PTR _new_ectrl$[ebp]
	push	ecx
	push	1
	push	1
	call	_expand_attribute

; 257  :     expand_attribute(FACET,F_VERTICES_ATTR,&new_fctrl);

	lea	edx, DWORD PTR _new_fctrl$[ebp]
	push	edx
	push	1
	push	2
	call	_expand_attribute
	add	esp, 24					; 00000018H
$LN181@lagrange_t@2:

; 258  :   } /* have to wait for later for shrink case */
; 259  : 
; 260  :   /* recalc all facet interior points */
; 261  :   trans = dmatrix(0,new_fctrl,0,old_fctrl);

	mov	eax, DWORD PTR _new_fctrl$[ebp]
	push	261					; 00000105H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	ebx
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 262  :   newx = dmatrix(0,new_fctrl,0,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _new_fctrl$[ebp]
	push	262					; 00000106H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	ecx
	push	0
	push	edx
	mov	edi, eax
	push	0
	mov	DWORD PTR _trans$[ebp], edi
	call	_kb_dmatrix

; 263  :   oldx = dmatrix(0,old_fctrl,0,SDIM);

	push	263					; 00000107H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	mov	DWORD PTR _newx$[ebp], eax
	mov	eax, DWORD PTR _web+616
	push	eax
	push	0
	push	ebx
	push	0
	call	_kb_dmatrix

; 264  : 
; 265  :   /* calculate transition matrix */
; 266  :   dim = web.dimension;

	mov	ebx, DWORD PTR _web+620
	add	esp, 72					; 00000048H

; 267  :   adjust_integration_orders(l_order);

	push	esi
	mov	DWORD PTR _oldx$[ebp], eax
	call	_adjust_integration_orders

; 268  :   gauss_lagrange_setup(dim,l_order,web.gauss2D_order);

	mov	ecx, DWORD PTR _web+1596
	push	ecx
	push	esi
	push	ebx
	call	_gauss_lagrange_setup

; 269  :   if ( bezier_flag )

	fld1
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _bezier_flag, 0
	je	SHORT $LN180@lagrange_t@2

; 270  :     bezier_trans_2d(web.lagrange_order,l_order,trans);

	mov	edx, DWORD PTR _web+632
	fstp	ST(0)
	push	edi
	push	esi
	push	edx
	call	_bezier_trans_2d
	add	esp, 12					; 0000000cH

; 271  :   else

	jmp	$LN173@lagrange_t@2
$LN180@lagrange_t@2:

; 272  :   {
; 273  :     for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN178@lagrange_t@2
	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
	mov	edi, DWORD PTR _trans$[ebp]
$LN178@lagrange_t@2:

; 274  :     inx[0] = l_order;

	mov	DWORD PTR _inx$[ebp], esi
	mov	DWORD PTR tv3373[ebp], edi
$LN175@lagrange_t@2:

; 278  :       for ( m = 0 ; m <= dim ; m++ ) oldinx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN172@lagrange_t@2

; 275  :     new = 0;
; 276  :     do
; 277  :     { old = 0;

	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _oldinx$[ebp]
	rep stosd
$LN172@lagrange_t@2:

; 279  :       oldinx[0] = web.lagrange_order;

	mov	ecx, DWORD PTR tv3373[ebp]
	mov	eax, DWORD PTR _web+632
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _oldinx$[ebp], eax
	mov	DWORD PTR tv3356[ebp], edx
$LN169@lagrange_t@2:

; 280  :       do
; 281  :        { REAL prod;
; 282  :          for ( k = 0, prod = 1.0 ; k <= dim ; k++ )

	xor	edx, edx
	fld	ST(0)
	test	ebx, ebx
	js	SHORT $LN164@lagrange_t@2
$LN166@lagrange_t@2:

; 283  :           for ( m = 0 ; m < oldinx[k] ; m++ )

	mov	ecx, DWORD PTR _oldinx$[ebp+edx*4]
	xor	eax, eax
	mov	DWORD PTR _m$[ebp], eax
	test	ecx, ecx
	jle	SHORT $LN165@lagrange_t@2
	fild	DWORD PTR _inx$[ebp+edx*4]
	mov	edi, ecx
	mov	DWORD PTR tv3270[ebp], ecx
	fidiv	DWORD PTR _l_order$GSCopy$[ebp]
	fimul	DWORD PTR _web+632
$LN163@lagrange_t@2:

; 284  :            prod *= ((REAL)(inx[k])/l_order*web.lagrange_order-m)/(oldinx[k]-m);

	fild	DWORD PTR _m$[ebp]
	inc	eax
	mov	DWORD PTR _m$[ebp], eax
	fsubr	ST(0), ST(1)
	fidiv	DWORD PTR tv3270[ebp]
	dec	DWORD PTR tv3270[ebp]
	fmulp	ST(2), ST(0)
	cmp	eax, edi
	jl	SHORT $LN163@lagrange_t@2

; 283  :           for ( m = 0 ; m < oldinx[k] ; m++ )

	fstp	ST(0)
$LN165@lagrange_t@2:

; 280  :       do
; 281  :        { REAL prod;
; 282  :          for ( k = 0, prod = 1.0 ; k <= dim ; k++ )

	inc	edx
	cmp	edx, ebx
	jle	SHORT $LN166@lagrange_t@2
$LN164@lagrange_t@2:

; 285  :          trans[new][old] = prod;

	mov	eax, DWORD PTR tv3356[ebp]
	fstp	QWORD PTR [eax]

; 286  :          old++;

	add	eax, 8
	mov	DWORD PTR tv3356[ebp], eax

; 287  :        } while ( increment_lagrange_index(dim,oldinx) );

	lea	eax, DWORD PTR _oldinx$[ebp]
	push	eax
	push	ebx
	call	_increment_lagrange_index
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN169@lagrange_t@2

; 288  :       new++;

	add	DWORD PTR tv3373[ebp], 4

; 289  :     } while ( increment_lagrange_index(dim,inx) );

	lea	ecx, DWORD PTR _inx$[ebp]
	push	ecx
	push	ebx
	call	_increment_lagrange_index
	add	esp, 8
	test	eax, eax
	jne	$LN175@lagrange_t@2
	fstp	ST(0)
$LN173@lagrange_t@2:

; 290  :   }
; 291  : 
; 292  :   /* calc indices of extreme vertices; handy elsewhere */
; 293  :   for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN160@lagrange_t@2
	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN160@lagrange_t@2:

; 294  :   for ( k = 0 ; k <= dim ; k++ )

	xor	edi, edi
	test	ebx, ebx
	js	SHORT $LN155@lagrange_t@2
$LL157@lagrange_t@2:

; 295  :   { inx[k] = l_order;
; 296  :     new = lagrange_index(dim,l_order,inx);

	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	push	esi
	push	ebx
	mov	DWORD PTR _inx$[ebp+edi*4], esi
	call	_lagrange_index

; 297  :     inx[k] = 0;

	mov	DWORD PTR _inx$[ebp+edi*4], 0

; 298  :     web.skel[FACET].extreme[k] = new;

	mov	DWORD PTR _web[edi*4+296], eax
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, ebx
	jle	SHORT $LL157@lagrange_t@2
$LN155@lagrange_t@2:

; 299  :   }
; 300  : 
; 301  : 
; 302  :   if ( web.representation != STRING )

	cmp	DWORD PTR _web+624, 1
	je	$LN374@lagrange_t@2

; 303  :   { MFOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+272
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _f_id$[ebp], eax
	mov	DWORD PTR tv2368[ebp], ecx
	je	$LN151@lagrange_t@2
	jmp	SHORT $LN153@lagrange_t@2
	npad	8
$LL392@lagrange_t@2:
	mov	eax, DWORD PTR _f_id$[ebp]
$LN153@lagrange_t@2:
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv2370[ebp], eax
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN152@lagrange_t@2

; 306  :       get_facet_verts(f_id,oldx,NULL);

	mov	esi, DWORD PTR _oldx$[ebp]
	mov	edx, DWORD PTR _f_id$[ebp]
	mov	ebx, DWORD PTR _web+620
	push	ecx
	push	esi
	push	edx
	mov	DWORD PTR _dim$[ebp], ebx
	call	_get_facet_verts

; 307  :       mat_mult(trans,oldx,newx,new_fctrl,web.skel[FACET].ctrlpts,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _web+232
	mov	edx, DWORD PTR _new_fctrl$[ebp]
	push	eax
	mov	eax, DWORD PTR _newx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _trans$[ebp]
	push	edx
	push	eax
	push	esi
	push	ecx
	call	_mat_mult

; 308  :       v = get_facet_vertices(f_id);

	mov	edx, DWORD PTR tv2370[ebp]
	mov	eax, DWORD PTR _web+236
	mov	esi, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	add	esi, DWORD PTR [ecx+edx+304]
	add	esp, 36					; 00000024H

; 309  :  
; 310  :       /* free old interior */
; 311  :       for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN148@lagrange_t@2

; 304  :     { vertex_id *v;
; 305  :       dim = web.dimension;

	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN148@lagrange_t@2:

; 312  :       inx[0] = web.lagrange_order;

	mov	edx, DWORD PTR _web+632

; 313  :       for ( k = 0 ; k < old_fctrl ; k++ )

	xor	edi, edi
	mov	DWORD PTR _inx$[ebp], edx
	cmp	DWORD PTR _old_fctrl$[ebp], edi
	jle	SHORT $LN143@lagrange_t@2
$LL399@lagrange_t@2:

; 314  :       { for ( m = 0 ; m <= dim ; m++ )

	xor	eax, eax
	test	ebx, ebx
	js	SHORT $LN373@lagrange_t@2
	npad	3
$LL142@lagrange_t@2:

; 315  :            if ( inx[m] == 0 ) break;

	cmp	DWORD PTR _inx$[ebp+eax*4], 0
	je	SHORT $LN328@lagrange_t@2

; 314  :       { for ( m = 0 ; m <= dim ; m++ )

	inc	eax
	cmp	eax, ebx
	jle	SHORT $LL142@lagrange_t@2

; 316  :          if ( m > dim ) free_element(v[k]);  /* free only interior */

	jmp	SHORT $LN373@lagrange_t@2
$LN328@lagrange_t@2:
	cmp	eax, ebx
	jle	SHORT $LN138@lagrange_t@2
$LN373@lagrange_t@2:
	mov	eax, DWORD PTR [esi+edi*4]
	push	eax
	call	_free_element
	add	esp, 4
$LN138@lagrange_t@2:

; 317  :          increment_lagrange_index(dim,inx);

	lea	ecx, DWORD PTR _inx$[ebp]
	push	ecx
	push	ebx
	call	_increment_lagrange_index
	inc	edi
	add	esp, 8
	cmp	edi, DWORD PTR _old_fctrl$[ebp]
	jl	SHORT $LL399@lagrange_t@2

; 313  :       for ( k = 0 ; k < old_fctrl ; k++ )

	mov	edx, DWORD PTR _web+632
$LN143@lagrange_t@2:

; 318  :       }
; 319  :       /* move extreme vertices */
; 320  :       for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN137@lagrange_t@2
	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN137@lagrange_t@2:

; 321  :       if ( l_order < web.lagrange_order )

	cmp	DWORD PTR _l_order$GSCopy$[ebp], edx
	jge	SHORT $LN134@lagrange_t@2

; 322  :          for ( k = 0 ; k <= dim ; k++ )

	xor	edi, edi
	test	ebx, ebx
	js	$LN377@lagrange_t@2
	jmp	SHORT $LN133@lagrange_t@2
	npad	4
$LL375@lagrange_t@2:
	mov	edx, DWORD PTR _web+632
$LN133@lagrange_t@2:

; 323  :          { inx[k] = web.lagrange_order; 
; 324  :            old = lagrange_index(dim,web.lagrange_order,inx); 

	lea	eax, DWORD PTR _inx$[ebp]
	push	eax
	push	edx
	push	ebx
	mov	DWORD PTR _inx$[ebp+edi*4], edx
	call	_lagrange_index

; 325  :            inx[k] = l_order;
; 326  :            new = lagrange_index(dim,l_order,inx);

	lea	ecx, DWORD PTR _inx$[ebp]
	mov	DWORD PTR _old$[ebp], eax
	mov	eax, DWORD PTR _l_order$GSCopy$[ebp]
	push	ecx
	push	eax
	push	ebx
	mov	DWORD PTR _inx$[ebp+edi*4], eax
	call	_lagrange_index

; 327  :            inx[k] = 0;
; 328  :            v[new] = v[old];

	mov	edx, DWORD PTR _old$[ebp]
	mov	ecx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR _inx$[ebp+edi*4], 0
	inc	edi
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+eax*4], ecx
	cmp	edi, ebx
	jle	SHORT $LL375@lagrange_t@2

; 329  :          }
; 330  :       else

	jmp	SHORT $LN127@lagrange_t@2
$LN134@lagrange_t@2:

; 331  :          for ( k = dim ; k >= 0 ; k-- )

	test	ebx, ebx
	js	SHORT $LN377@lagrange_t@2
	jmp	SHORT $LN129@lagrange_t@2
	npad	12
$LL376@lagrange_t@2:
	mov	edx, DWORD PTR _web+632
$LN129@lagrange_t@2:

; 332  :          { inx[k] = web.lagrange_order; 
; 333  :            old = lagrange_index(dim,web.lagrange_order,inx); 

	mov	ecx, DWORD PTR _dim$[ebp]
	lea	eax, DWORD PTR _inx$[ebp]
	push	eax
	push	edx
	push	ecx
	mov	DWORD PTR _inx$[ebp+ebx*4], edx
	call	_lagrange_index
	mov	edi, eax

; 334  :            inx[k] = l_order;

	mov	eax, DWORD PTR _l_order$GSCopy$[ebp]

; 335  :            new = lagrange_index(dim,l_order,inx);

	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	push	eax
	mov	DWORD PTR _inx$[ebp+ebx*4], eax
	mov	eax, DWORD PTR _dim$[ebp]
	push	eax
	call	_lagrange_index

; 336  :            inx[k] = 0;
; 337  :            v[new] = v[old];

	mov	ecx, DWORD PTR [esi+edi*4]
	add	esp, 24					; 00000018H
	dec	ebx
	mov	DWORD PTR _inx$[ebp+ebx*4+4], 0
	mov	DWORD PTR [esi+eax*4], ecx
	jns	SHORT $LL376@lagrange_t@2
$LN127@lagrange_t@2:

; 338  :          }
; 339  :  
; 340  :       /* create new interior */
; 341  :       for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	mov	eax, DWORD PTR _dim$[ebp]
	test	eax, eax
	js	SHORT $LN377@lagrange_t@2
	lea	ecx, DWORD PTR [eax+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN377@lagrange_t@2:

; 342  :       inx[0] = l_order;
; 343  :       for ( k = 0 ; k < new_fctrl ; k++ )

	cmp	DWORD PTR _new_fctrl$[ebp], 0
	mov	edx, DWORD PTR _l_order$GSCopy$[ebp]
	mov	DWORD PTR _inx$[ebp], edx
	mov	DWORD PTR _k$[ebp], 0
	jle	$LN152@lagrange_t@2
	mov	eax, DWORD PTR _newx$[ebp]
	mov	edi, DWORD PTR tv2370[ebp]
	mov	ebx, esi
	sub	eax, esi
	mov	DWORD PTR tv3674[ebp], ebx
	mov	DWORD PTR tv3729[ebp], eax
	npad	4
$LL397@lagrange_t@2:
	mov	ecx, DWORD PTR _dim$[ebp]

; 344  :       { for ( m = 0 ; m <= dim ; m++ )

	xor	eax, eax
	test	ecx, ecx
	js	SHORT $LN372@lagrange_t@2
	npad	4
$LL120@lagrange_t@2:

; 345  :            if ( inx[m] == 0 ) break;

	cmp	DWORD PTR _inx$[ebp+eax*4], 0
	je	SHORT $LN329@lagrange_t@2

; 344  :       { for ( m = 0 ; m <= dim ; m++ )

	inc	eax
	cmp	eax, ecx
	jle	SHORT $LL120@lagrange_t@2

; 346  :          if ( m > dim ) /* create interior vertex */

	jmp	SHORT $LN372@lagrange_t@2
$LN329@lagrange_t@2:
	cmp	eax, ecx
	jle	$LN378@lagrange_t@2
$LN372@lagrange_t@2:

; 347  :          { v[k] = new_vertex(newx[k],f_id);  

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR tv3729[ebp]
	mov	edx, DWORD PTR [ecx+ebx]
	push	eax
	push	edx
	call	_new_vertex
	mov	DWORD PTR [ebx], eax

; 348  :            if ( get_fattr(f_id) & FIXED ) set_attr(v[k],FIXED);

	mov	ecx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 64					; 00000040H
	xor	edx, edx
	add	esp, 8
	or	ecx, edx
	je	SHORT $LN234@lagrange_t@2
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax+12], edx
$LN234@lagrange_t@2:

; 349  :            set_attr(v[k],Q_MIDFACET);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	or	DWORD PTR [eax+8], 2097152		; 00200000H
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], ecx

; 350  :            set_vertex_facet(v[k],f_id);  /* since doesn't have edge */

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _f_id$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 351  :            /* find centerpoint parameters for facet on boundary */
; 352  :            if ( get_fattr(f_id) & BOUNDARY )    /* not working for torus */

	mov	eax, DWORD PTR _web+236
	mov	edx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv2377[ebp+4], eax
	mov	eax, ecx
	and	eax, 128				; 00000080H
	xor	esi, esi
	or	eax, esi
	je	$LN114@lagrange_t@2

; 353  :            {
; 354  :               REAL defaultp[MAXCOORD];
; 355  :               REAL *paramb,*parammid,*xb;
; 356  :               vertex_id base_v;
; 357  :               REAL s[MAXCOORD];
; 358  :               struct boundary *bdry;
; 359  :               facetedge_id fe;
; 360  :  
; 361  :               set_attr(v[k],BOUNDARY);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 128			; 00000080H
	mov	DWORD PTR [eax+12], ecx

; 362  :               bdry = get_facet_boundary(f_id);

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	mov	esi, DWORD PTR _dymem
	test	eax, eax
	je	SHORT $LN192@lagrange_t@2
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR [eax+esi+64]
	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [edx+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN443@lagrange_t@2
$LN192@lagrange_t@2:
	xor	eax, eax
$LN443@lagrange_t@2:

; 363  :               set_boundary_num(v[k],bdry->num);

	mov	ecx, DWORD PTR _V_BOUNDARY_ATTR
	mov	DWORD PTR _bdry$89276[ebp], eax
	test	ecx, ecx
	je	SHORT $LN194@lagrange_t@2
	mov	edx, DWORD PTR [ebx]
	imul	ecx, 240				; 000000f0H
	mov	edi, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+44]
	and	edx, 134217727				; 07ffffffH
	add	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edi+edx*4]
	mov	ecx, DWORD PTR [ecx+esi+64]
	mov	DWORD PTR [edx+ecx], eax
	mov	esi, DWORD PTR _dymem
$LN194@lagrange_t@2:

; 364  :  
; 365  :               /* v[k] parameters extrapolate from a vertex */
; 366  :               /* try to find a vertex on same boundary */
; 367  :               base_v = NULLVERTEX;
; 368  :               fe = get_facet_fe(f_id);

	mov	ecx, DWORD PTR _f_id$[ebp]
	mov	edi, DWORD PTR _NULLVERTEX
	push	ecx
	mov	DWORD PTR _base_v$89274[ebp], edi
	call	_get_facet_fe
	mov	edx, DWORD PTR _web+216
	add	esp, 4
	mov	DWORD PTR tv1506[ebp], 3
$LL394@lagrange_t@2:

; 370  :                  { 
; 371  :                    if ( bdry == get_boundary(get_fe_tailv(fe)) )

	cmp	DWORD PTR _V_BOUNDARY_ATTR, 0
	je	$LN196@lagrange_t@2
	mov	edi, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	ecx, eax
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [edi+20]
	mov	edi, DWORD PTR _web+124
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN247@lagrange_t@2
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	add	ecx, DWORD PTR [edx+esi+304]
	mov	edx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN246@lagrange_t@2
$LN247@lagrange_t@2:
	mov	edx, DWORD PTR [edx+esi+304]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+edx]
$LN246@lagrange_t@2:
	mov	edx, DWORD PTR _V_BOUNDARY_ATTR
	mov	edi, DWORD PTR _web+12
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edx, DWORD PTR [edx+esi+64]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	edi, DWORD PTR _base_v$89274[ebp]
	imul	ecx, 136				; 00000088H
	add	ecx, DWORD PTR _web+776
	jmp	SHORT $LN197@lagrange_t@2
$LN196@lagrange_t@2:
	xor	ecx, ecx
$LN197@lagrange_t@2:
	cmp	DWORD PTR _bdry$89276[ebp], ecx
	jne	$LN395@lagrange_t@2

; 372  :                       base_v = get_fe_tailv(fe);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, eax
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _web+124
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN253@lagrange_t@2
	mov	edi, DWORD PTR _web+636
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	add	ecx, DWORD PTR [edx+esi+304]
	mov	edi, DWORD PTR [ecx+edi*4]
	mov	DWORD PTR _base_v$89274[ebp], edi
	jmp	SHORT $LN112@lagrange_t@2
$LN253@lagrange_t@2:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edi, DWORD PTR [edx+esi+304]
	mov	edi, DWORD PTR [ecx+edi]
	mov	DWORD PTR _base_v$89274[ebp], edi
	jmp	SHORT $LN112@lagrange_t@2
$LN395@lagrange_t@2:
	mov	edx, DWORD PTR _web+216
$LN112@lagrange_t@2:

; 369  :               for ( i = 0 ; i < FACET_EDGES ; i++, fe = get_next_edge(fe) )

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN241@lagrange_t@2
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN345@lagrange_t@2
$LN241@lagrange_t@2:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+32]
$LN345@lagrange_t@2:
	dec	DWORD PTR tv1506[ebp]
	jne	$LL394@lagrange_t@2

; 373  :                  }
; 374  :               if ( valid_id(base_v) )

	test	edi, 268435456				; 10000000H
	je	SHORT $LN109@lagrange_t@2

; 375  :                  { paramb = get_param(base_v);

	mov	ecx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR _web+104
	mov	edi, DWORD PTR [ecx+esi+544]

; 376  :                    xb = get_coord(base_v);

	mov	ecx, DWORD PTR [ecx+esi+64]
	add	edi, eax
	add	ecx, eax

; 377  :                    for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	$LN393@lagrange_t@2
	lea	edx, DWORD PTR _s$89275[ebp]
	sub	ecx, edx
	npad	4
$LL108@lagrange_t@2:
	lea	edx, DWORD PTR [ecx+eax*8]

; 378  :                       s[i] = xb[i];  /* displacement vector */

	fld	QWORD PTR _s$89275[ebp+edx]
	inc	eax
	fstp	QWORD PTR _s$89275[ebp+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL108@lagrange_t@2

; 379  :                  }
; 380  :               else

	jmp	$LN393@lagrange_t@2
$LN109@lagrange_t@2:

; 382  :                    defaultp[0] = defaultp[1] = defaultp[2] = 0.1;

	fld	QWORD PTR __real@3fb999999999999a

; 383  :                    for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	fst	QWORD PTR _defaultp$89270[ebp+16]
	lea	edi, DWORD PTR _defaultp$89270[ebp]
	fst	QWORD PTR _defaultp$89270[ebp+8]
	fstp	QWORD PTR _defaultp$89270[ebp]
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN102@lagrange_t@2

; 381  :                  { paramb = defaultp;

	mov	ebx, DWORD PTR _bdry$89276[ebp]
	add	ebx, 48					; 00000030H
	npad	6
$LL104@lagrange_t@2:

; 384  :                       s[i] = eval(bdry->coordf[i],defaultp,NULLID,NULL);

	mov	ecx, DWORD PTR [ebx]
	push	0
	push	0
	lea	eax, DWORD PTR _defaultp$89270[ebp]
	push	eax
	push	ecx
	call	_eval
	fstp	QWORD PTR _s$89275[ebp+esi*8]
	inc	esi
	add	esp, 16					; 00000010H
	add	ebx, 4
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL104@lagrange_t@2
$LN102@lagrange_t@2:

; 385  :                    sprintf(msg,
; 386  :                      "Could not find vertex on same boundary as facet %s.\n",
; 387  :                       ELNAME(f_id));

	cmp	DWORD PTR tv2368[ebp], 0
	je	SHORT $LN198@lagrange_t@2
	mov	edx, DWORD PTR tv2370[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN199@lagrange_t@2
$LN198@lagrange_t@2:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN199@lagrange_t@2:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0DF@MOLBPHPK@Could?5not?5find?5vertex?5on?5same?5bo@
	push	eax
	call	_sprintf
	mov	esi, DWORD PTR _dymem
	mov	ebx, DWORD PTR tv3674[ebp]
	add	esp, 12					; 0000000cH
$LN393@lagrange_t@2:

; 388  :                  }
; 389  :  
; 390  :               parammid = get_param(v[k]);
; 391  :               b_extrapolate(bdry,s,newx[k],newx[k],paramb,parammid,v[k]);

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR tv3729[ebp]
	mov	ecx, DWORD PTR [ecx+ebx]
	push	eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+104
	add	eax, DWORD PTR [edx+esi+544]
	push	eax
	push	edi
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR _bdry$89276[ebp]
	lea	eax, DWORD PTR _s$89275[ebp]
	push	eax
	push	ecx
	call	_b_extrapolate
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN444@lagrange_t@2
$LN114@lagrange_t@2:

; 392  :            }
; 393  :            else if ( get_fattr(f_id) & CONSTRAINT )    

	mov	eax, ecx
	and	eax, 1024				; 00000400H
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN378@lagrange_t@2

; 394  :            {
; 395  :               ATTR attr = get_fattr(f_id) & (BDRY_ENERGY|BDRY_CONTENT|CONSTRAINT);
; 396  :               conmap_t * conmap = get_f_constraint_map(f_id);

	mov	eax, DWORD PTR _web+328
	mov	esi, DWORD PTR _dymem
	xor	edi, edi
	and	ecx, 5632				; 00001600H
	cmp	DWORD PTR [eax+esi+88], edi
	je	SHORT $LN200@lagrange_t@2
	mov	esi, DWORD PTR [eax+esi+64]
	add	esi, edx
	jmp	SHORT $LN201@lagrange_t@2
$LN200@lagrange_t@2:
	mov	esi, OFFSET _nullcon
$LN201@lagrange_t@2:

; 397  :  
; 398  :               set_attr(v[k],attr);

	mov	eax, DWORD PTR [ebx]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edi

; 399  :               set_v_conmap(v[k],conmap);

	mov	eax, DWORD PTR [ebx]
	push	esi
	push	eax
	call	_set_v_conmap

; 400  :               project_v_constr(v[k],ACTUAL_MOVE,RESET_ONESIDEDNESS);

	mov	ecx, DWORD PTR [ebx]
	push	1
	push	1
	push	ecx
	call	_project_v_constr
	add	esp, 20					; 00000014H
$LN444@lagrange_t@2:
	mov	edi, DWORD PTR tv2370[ebp]
$LN378@lagrange_t@2:

; 401  :            }
; 402  :          }
; 403  :          increment_lagrange_index(dim,inx);

	mov	eax, DWORD PTR _dim$[ebp]
	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	push	eax
	call	_increment_lagrange_index
	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	add	ebx, 4
	add	esp, 8
	mov	DWORD PTR _k$[ebp], eax
	mov	DWORD PTR tv3674[ebp], ebx
	cmp	eax, DWORD PTR _new_fctrl$[ebp]
	jl	$LL397@lagrange_t@2
$LN152@lagrange_t@2:

; 303  :   { MFOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR tv2370[ebp]
	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _f_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv2368[ebp], eax
	jne	$LL392@lagrange_t@2
$LN151@lagrange_t@2:

; 404  :       }
; 405  :     }
; 406  :   }
; 407  : 
; 408  :   /* do edges */
; 409  :   /* calculate transition matrix */
; 410  :   dim = (web.representation==STRING)? 1 : web.dimension-1;

	cmp	DWORD PTR _web+624, 1
	mov	esi, DWORD PTR _l_order$GSCopy$[ebp]
	jne	SHORT $LN202@lagrange_t@2
$LN374@lagrange_t@2:
	mov	ebx, 1
	jmp	SHORT $LN445@lagrange_t@2
$LN202@lagrange_t@2:
	mov	ebx, DWORD PTR _web+620
	dec	ebx
$LN445@lagrange_t@2:

; 411  :   gauss_lagrange_setup(dim,l_order,web.gauss1D_order);

	mov	ecx, DWORD PTR _web+1592
	push	ecx
	push	esi
	push	ebx
	mov	DWORD PTR _dim$[ebp], ebx
	call	_gauss_lagrange_setup
	add	esp, 12					; 0000000cH

; 412  : 
; 413  :   if ( bezier_flag )

	cmp	DWORD PTR _bezier_flag, 0
	je	SHORT $LN99@lagrange_t@2

; 414  :   { bezier_trans_1d(web.lagrange_order,l_order,trans);

	mov	edx, DWORD PTR _trans$[ebp]
	mov	eax, DWORD PTR _web+632
	push	edx
	push	esi
	push	eax
	call	_bezier_trans_1d
	add	esp, 12					; 0000000cH

; 415  :   }
; 416  :   else

	jmp	$LN92@lagrange_t@2
$LN99@lagrange_t@2:

; 417  :   { /* regular lagrange stuff */
; 418  :   
; 419  :     for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN97@lagrange_t@2
	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN97@lagrange_t@2:

; 420  :     inx[0] = l_order;

	mov	ecx, DWORD PTR _trans$[ebp]
	fld1
	mov	DWORD PTR _inx$[ebp], esi
	mov	DWORD PTR tv3881[ebp], ecx
$LN94@lagrange_t@2:

; 424  :       for ( m = 0 ; m <= dim ; m++ ) oldinx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN91@lagrange_t@2

; 421  :     new = 0;
; 422  :     do
; 423  :     { old = 0;

	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _oldinx$[ebp]
	rep stosd
$LN91@lagrange_t@2:

; 425  :       oldinx[0] = web.lagrange_order;

	mov	eax, DWORD PTR tv3881[ebp]
	mov	edx, DWORD PTR _web+632
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _oldinx$[ebp], edx
	mov	DWORD PTR tv3864[ebp], ecx
$LN88@lagrange_t@2:

; 426  :       do
; 427  :       { REAL prod;
; 428  :         for ( k = 0, prod = 1.0 ; k <= dim ; k++ )

	xor	edx, edx
	fld	ST(0)
	test	ebx, ebx
	js	SHORT $LN83@lagrange_t@2
$LN85@lagrange_t@2:

; 429  :           for ( m = 0 ; m < oldinx[k] ; m++ )

	mov	ecx, DWORD PTR _oldinx$[ebp+edx*4]
	xor	eax, eax
	mov	DWORD PTR _m$[ebp], eax
	test	ecx, ecx
	jle	SHORT $LN84@lagrange_t@2
	fild	DWORD PTR _inx$[ebp+edx*4]
	mov	edi, ecx
	mov	DWORD PTR tv3779[ebp], ecx
	fidiv	DWORD PTR _l_order$GSCopy$[ebp]
	fimul	DWORD PTR _web+632
$LN82@lagrange_t@2:

; 430  :            prod *= ((REAL)(inx[k])/l_order*web.lagrange_order - m)/(oldinx[k]-m); 

	fild	DWORD PTR _m$[ebp]
	inc	eax
	mov	DWORD PTR _m$[ebp], eax
	fsubr	ST(0), ST(1)
	fidiv	DWORD PTR tv3779[ebp]
	dec	DWORD PTR tv3779[ebp]
	fmulp	ST(2), ST(0)
	cmp	eax, edi
	jl	SHORT $LN82@lagrange_t@2

; 429  :           for ( m = 0 ; m < oldinx[k] ; m++ )

	fstp	ST(0)
$LN84@lagrange_t@2:

; 426  :       do
; 427  :       { REAL prod;
; 428  :         for ( k = 0, prod = 1.0 ; k <= dim ; k++ )

	inc	edx
	cmp	edx, ebx
	jle	SHORT $LN85@lagrange_t@2
$LN83@lagrange_t@2:

; 431  :         trans[new][old] = prod;

	mov	eax, DWORD PTR tv3864[ebp]

; 432  :         old++;
; 433  :       } while ( increment_lagrange_index(dim,oldinx) );

	lea	edx, DWORD PTR _oldinx$[ebp]
	fstp	QWORD PTR [eax]
	push	edx
	add	eax, 8
	push	ebx
	mov	DWORD PTR tv3864[ebp], eax
	call	_increment_lagrange_index
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN88@lagrange_t@2

; 434  :       new++;

	add	DWORD PTR tv3881[ebp], 4

; 435  :     } while ( increment_lagrange_index(dim,inx) );

	lea	eax, DWORD PTR _inx$[ebp]
	push	eax
	push	ebx
	call	_increment_lagrange_index
	add	esp, 8
	test	eax, eax
	jne	$LN94@lagrange_t@2
	fstp	ST(0)
$LN92@lagrange_t@2:

; 436  :   }
; 437  : 
; 438  :   /* calc indices of extreme vertices; handy elsewhere */
; 439  :   for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN79@lagrange_t@2
	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN79@lagrange_t@2:

; 440  :   for ( k = 0 ; k <= dim ; k++ )

	xor	edi, edi
	test	ebx, ebx
	js	SHORT $LN74@lagrange_t@2
	npad	6
$LL76@lagrange_t@2:

; 441  :   { inx[k] = l_order;
; 442  :     new = lagrange_index(dim,l_order,inx);

	lea	ecx, DWORD PTR _inx$[ebp]
	push	ecx
	push	esi
	push	ebx
	mov	DWORD PTR _inx$[ebp+edi*4], esi
	call	_lagrange_index

; 443  :     inx[k] = 0;

	mov	DWORD PTR _inx$[ebp+edi*4], 0

; 444  :     web.skel[EDGE].extreme[k] = new;

	mov	DWORD PTR _web[edi*4+184], eax
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, ebx
	jle	SHORT $LL76@lagrange_t@2
$LN74@lagrange_t@2:

; 445  :   }
; 446  : 
; 447  :   MFOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+160
	mov	DWORD PTR _e_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv2653[ebp], eax
	je	$LN383@lagrange_t@2
$LL73@lagrange_t@2:
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv2655[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN72@lagrange_t@2

; 448  :    { vertex_id *v;
; 449  :      get_edge_verts(e_id,oldx,NULL);

	mov	edi, DWORD PTR _oldx$[ebp]
	mov	eax, DWORD PTR _e_id$[ebp]
	push	ecx
	push	edi
	push	eax
	call	_get_edge_verts

; 450  :      mat_mult(trans,oldx,newx,new_ectrl,old_ectrl,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _old_ectrl$[ebp]
	mov	eax, DWORD PTR _new_ectrl$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newx$[ebp]
	push	edx
	mov	edx, DWORD PTR _trans$[ebp]
	push	eax
	push	ecx
	push	edi
	push	edx
	call	_mat_mult

; 451  :      v = get_edge_vertices(e_id);

	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+ecx+304]
	mov	edx, DWORD PTR tv2655[ebp]
	mov	eax, DWORD PTR _web+124
	add	esi, DWORD PTR [eax+edx*4]
	add	esp, 36					; 00000024H
	mov	DWORD PTR _v$89375[ebp], esi

; 452  : 
; 453  :      /* free old interior */
; 454  :      for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN68@lagrange_t@2

; 448  :    { vertex_id *v;
; 449  :      get_edge_verts(e_id,oldx,NULL);

	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN68@lagrange_t@2:

; 455  :      inx[0] = web.lagrange_order;

	mov	edx, DWORD PTR _web+632

; 456  :      for ( k = 0 ; k < old_ectrl ; k++ )

	xor	edi, edi
	mov	DWORD PTR _inx$[ebp], edx
	cmp	DWORD PTR _old_ectrl$[ebp], edi
	jle	SHORT $LN63@lagrange_t@2
$LL400@lagrange_t@2:

; 457  :      { for ( m = 0 ; m <= dim ; m++ )

	xor	eax, eax
	test	ebx, ebx
	js	SHORT $LN371@lagrange_t@2
	npad	6
$LL62@lagrange_t@2:

; 458  :           if ( inx[m] == 0 ) break;

	cmp	DWORD PTR _inx$[ebp+eax*4], 0
	je	SHORT $LN330@lagrange_t@2

; 457  :      { for ( m = 0 ; m <= dim ; m++ )

	inc	eax
	cmp	eax, ebx
	jle	SHORT $LL62@lagrange_t@2

; 459  :         if ( m > dim ) free_element(v[k]);  /* free only interior */

	jmp	SHORT $LN371@lagrange_t@2
$LN330@lagrange_t@2:
	cmp	eax, ebx
	jle	SHORT $LN58@lagrange_t@2
$LN371@lagrange_t@2:
	mov	ecx, DWORD PTR [esi+edi*4]
	push	ecx
	call	_free_element
	add	esp, 4
$LN58@lagrange_t@2:

; 460  :         increment_lagrange_index(dim,inx);

	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	push	ebx
	call	_increment_lagrange_index
	inc	edi
	add	esp, 8
	cmp	edi, DWORD PTR _old_ectrl$[ebp]
	jl	SHORT $LL400@lagrange_t@2

; 456  :      for ( k = 0 ; k < old_ectrl ; k++ )

	mov	edx, DWORD PTR _web+632
$LN63@lagrange_t@2:

; 461  :      }
; 462  :      /* move extreme vertices */
; 463  :      for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN57@lagrange_t@2
	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN57@lagrange_t@2:

; 464  :      if ( l_order < web.lagrange_order )

	cmp	DWORD PTR _l_order$GSCopy$[ebp], edx
	jge	SHORT $LN54@lagrange_t@2

; 465  :         for ( k = 0 ; k <= dim ; k++ )

	xor	esi, esi
	test	ebx, ebx
	js	$LN381@lagrange_t@2
	jmp	SHORT $LN53@lagrange_t@2
	npad	4
$LL379@lagrange_t@2:
	mov	edx, DWORD PTR _web+632
$LN53@lagrange_t@2:

; 466  :         { inx[k] = web.lagrange_order; 
; 467  :           old = lagrange_index(dim,web.lagrange_order,inx); 

	lea	eax, DWORD PTR _inx$[ebp]
	push	eax
	push	edx
	push	ebx
	mov	DWORD PTR _inx$[ebp+esi*4], edx
	call	_lagrange_index

; 468  :           inx[k] = l_order;
; 469  :           new = lagrange_index(dim,l_order,inx);

	lea	ecx, DWORD PTR _inx$[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR _l_order$GSCopy$[ebp]
	push	ecx
	push	eax
	push	ebx
	mov	DWORD PTR _inx$[ebp+esi*4], eax
	call	_lagrange_index

; 470  :           inx[k] = 0;
; 471  :           v[new] = v[old];

	mov	ecx, DWORD PTR _v$89375[ebp]
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	DWORD PTR _inx$[ebp+esi*4], 0
	inc	esi
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ecx+eax*4], edx
	cmp	esi, ebx
	jle	SHORT $LL379@lagrange_t@2

; 472  :         }
; 473  :      else

	jmp	SHORT $LN47@lagrange_t@2
$LN54@lagrange_t@2:

; 474  :         for ( k = dim ; k >= 0 ; k-- )

	mov	esi, ebx
	test	ebx, ebx
	js	SHORT $LN381@lagrange_t@2
	jmp	SHORT $LN49@lagrange_t@2
$LL380@lagrange_t@2:
	mov	edx, DWORD PTR _web+632
$LN49@lagrange_t@2:

; 475  :         { inx[k] = web.lagrange_order; 
; 476  :           old = lagrange_index(dim,web.lagrange_order,inx); 

	lea	eax, DWORD PTR _inx$[ebp]
	push	eax
	push	edx
	push	ebx
	mov	DWORD PTR _inx$[ebp+esi*4], edx
	call	_lagrange_index

; 477  :           inx[k] = l_order;
; 478  :           new = lagrange_index(dim,l_order,inx);

	lea	ecx, DWORD PTR _inx$[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR _l_order$GSCopy$[ebp]
	push	ecx
	push	eax
	push	ebx
	mov	DWORD PTR _inx$[ebp+esi*4], eax
	call	_lagrange_index

; 479  :           inx[k] = 0;
; 480  :           v[new] = v[old];

	mov	ecx, DWORD PTR _v$89375[ebp]
	mov	edx, DWORD PTR [ecx+edi*4]
	add	esp, 24					; 00000018H
	dec	esi
	mov	DWORD PTR _inx$[ebp+esi*4+4], 0
	mov	DWORD PTR [ecx+eax*4], edx
	jns	SHORT $LL380@lagrange_t@2
$LN47@lagrange_t@2:

; 481  :         }
; 482  : 
; 483  :      /* create new interior */
; 484  :      for ( m = 0 ; m <= dim ; m++ ) inx[m] = 0;

	test	ebx, ebx
	js	SHORT $LN381@lagrange_t@2
	lea	ecx, DWORD PTR [ebx+1]
	xor	eax, eax
	lea	edi, DWORD PTR _inx$[ebp]
	rep stosd
$LN381@lagrange_t@2:

; 485  :      inx[0] = l_order;
; 486  :      for ( k = 0 ; k < new_ectrl ; k++ )

	cmp	DWORD PTR _new_ectrl$[ebp], 0
	mov	eax, DWORD PTR _l_order$GSCopy$[ebp]
	mov	DWORD PTR _inx$[ebp], eax
	mov	DWORD PTR _k$[ebp], 0
	jle	$LN72@lagrange_t@2
	mov	esi, DWORD PTR _v$89375[ebp]
	mov	edx, DWORD PTR _newx$[ebp]
	sub	edx, esi
	mov	DWORD PTR tv4103[ebp], esi
	mov	DWORD PTR tv4155[ebp], edx
	jmp	SHORT $LN43@lagrange_t@2
$LL403@lagrange_t@2:
	mov	edx, DWORD PTR tv4155[ebp]
$LN43@lagrange_t@2:

; 487  :      { for ( m = 0,zeros=0 ; m <= dim ; m++ )

	xor	eax, eax
	xor	ecx, ecx
	test	ebx, ebx
	js	SHORT $LN38@lagrange_t@2
$LL40@lagrange_t@2:

; 488  :           if ( inx[m] == 0 ) zeros++;

	cmp	DWORD PTR _inx$[ebp+eax*4], 0
	jne	SHORT $LN39@lagrange_t@2
	inc	ecx
$LN39@lagrange_t@2:

; 487  :      { for ( m = 0,zeros=0 ; m <= dim ; m++ )

	inc	eax
	cmp	eax, ebx
	jle	SHORT $LL40@lagrange_t@2
$LN38@lagrange_t@2:

; 489  :         if ( zeros != dim )

	cmp	ecx, ebx
	je	$LN382@lagrange_t@2

; 490  :         {
; 491  :           v[k] = new_vertex(newx[k],e_id); 

	mov	edi, DWORD PTR _e_id$[ebp]
	mov	ecx, DWORD PTR [edx+esi]
	push	edi
	push	ecx
	call	_new_vertex

; 492  :           if ( get_eattr(e_id) & FIXED ) 

	mov	ecx, DWORD PTR tv2655[ebp]
	mov	DWORD PTR [esi], eax
	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 64					; 00000040H
	xor	edx, edx
	add	esp, 8
	or	ecx, edx
	je	SHORT $LN385@lagrange_t@2

; 493  :              set_attr(v[k],FIXED);

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax+12], edx
$LN385@lagrange_t@2:

; 494  :           set_attr(v[k],Q_MIDEDGE);

	mov	eax, DWORD PTR [esi]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	or	DWORD PTR [eax+8], 4194304		; 00400000H
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], ecx

; 495  :           set_vertex_edge(v[k],e_id);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]

; 496  : 
; 497  :           /* for boundary edges, cannot just interpolate parameters
; 498  :               due to wrap-around of angular parameters. So tangent extrapolate
; 499  :               from one endpoint.
; 500  :          */
; 501  :           if ( get_eattr(e_id) & BOUNDARY )

	mov	eax, DWORD PTR tv2655[ebp]
	mov	DWORD PTR [ecx+28], edi
	mov	edx, DWORD PTR _web+124
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv2662[ebp+4], eax
	mov	eax, ecx
	and	eax, 128				; 00000080H
	xor	edi, edi
	or	eax, edi
	je	$LN34@lagrange_t@2

; 502  :           { 
; 503  :              struct boundary *bdry;
; 504  :              REAL *paramb,*parammid,*mu,*mv;
; 505  :              vertex_id base_v = NULLID;
; 506  :              vertex_id headv = v[l_order];

	mov	eax, DWORD PTR _v$89375[ebp]
	mov	ecx, DWORD PTR _l_order$GSCopy$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]

; 507  :              vertex_id tailv = v[0];

	mov	eax, DWORD PTR [eax]
	xor	ebx, ebx

; 508  :      
; 509  :              if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	mov	DWORD PTR _base_v$89428[ebp], ebx
	mov	DWORD PTR _headv$89429[ebp], edx
	mov	DWORD PTR _tailv$89430[ebp], eax
	jne	SHORT $LN384@lagrange_t@2

; 510  :                 kb_error(1802,"Can't do Lagrange boundaries in SIMPLEX model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DA@LMEBNNDO@Can?8t?5do?5Lagrange?5boundaries?5in?5@
	push	1802					; 0000070aH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN384@lagrange_t@2:

; 511  : 
; 512  :              bdry = get_edge_boundary(e_id);

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	mov	edx, DWORD PTR _web+776
	mov	edi, DWORD PTR _dymem
	cmp	eax, ebx
	je	SHORT $LN204@lagrange_t@2
	mov	ebx, DWORD PTR tv2655[ebp]
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR [eax+edi+64]
	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	ebx, DWORD PTR [ecx+eax]
	imul	ebx, 136				; 00000088H
	add	ebx, edx
$LN204@lagrange_t@2:

; 513  :              if ( get_boundary(headv) == bdry )

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	mov	DWORD PTR _bdry$89423[ebp], ebx
	test	eax, eax
	je	SHORT $LN206@lagrange_t@2
	mov	ecx, DWORD PTR _headv$89429[ebp]
	mov	edi, DWORD PTR _web+12
	mov	ebx, eax
	imul	ebx, 240				; 000000f0H
	add	ebx, DWORD PTR _web+104
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ebx+edi+64]
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR _bdry$89423[ebp]
	imul	ecx, 136				; 00000088H
	add	ecx, edx
	jmp	SHORT $LN207@lagrange_t@2
$LN206@lagrange_t@2:
	xor	ecx, ecx
$LN207@lagrange_t@2:
	cmp	ecx, ebx
	jne	SHORT $LN32@lagrange_t@2

; 514  :                  base_v = headv;

	mov	edx, DWORD PTR _headv$89429[ebp]
	mov	DWORD PTR _base_v$89428[ebp], edx
	jmp	$LN29@lagrange_t@2
$LN32@lagrange_t@2:

; 515  :              else if ( get_boundary(tailv) == bdry )

	test	eax, eax
	je	SHORT $LN208@lagrange_t@2
	mov	ecx, DWORD PTR _tailv$89430[ebp]
	mov	edi, DWORD PTR _web+12
	mov	ebx, eax
	imul	ebx, 240				; 000000f0H
	add	ebx, DWORD PTR _web+104
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ebx+edi+64]
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR _bdry$89423[ebp]
	imul	ecx, 136				; 00000088H
	add	ecx, edx
	jmp	SHORT $LN209@lagrange_t@2
$LN208@lagrange_t@2:
	xor	ecx, ecx
$LN209@lagrange_t@2:
	cmp	ecx, ebx
	jne	SHORT $LN30@lagrange_t@2

; 516  :                  base_v = tailv;

	mov	edx, DWORD PTR _tailv$89430[ebp]
	mov	DWORD PTR _base_v$89428[ebp], edx

; 517  :              else

	jmp	$LN29@lagrange_t@2
$LN30@lagrange_t@2:

; 518  :                 { sprintf(errmsg,
; 519  :          "Vertices %s and %s of edge %s are on different boundaries, %s, %s, %s.\n",
; 520  :                     ELNAME(headv),ELNAME1(tailv),ELNAME2(e_id),
; 521  :                      get_boundary(headv) ? get_boundary(headv)->name : "none",
; 522  :                      get_boundary(tailv) ? get_boundary(tailv)->name : "none",
; 523  :                      bdry ? bdry->name : "none");

	mov	DWORD PTR tv919[ebp], ebx
	test	ebx, ebx
	jne	SHORT $LN211@lagrange_t@2
	mov	DWORD PTR tv919[ebp], OFFSET ??_C@_04CGFJFPFD@none?$AA@
$LN211@lagrange_t@2:
	test	eax, eax
	je	SHORT $LN390@lagrange_t@2
	mov	ecx, DWORD PTR _tailv$89430[ebp]
	mov	edi, DWORD PTR _web+12
	mov	ebx, eax
	imul	ebx, 240				; 000000f0H
	add	ebx, DWORD PTR _web+104
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ebx+edi+64]
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR _headv$89429[ebp]
	imul	ecx, 136				; 00000088H
	add	ecx, edx
	je	SHORT $LN216@lagrange_t@2
	mov	DWORD PTR tv946[ebp], ecx
	jmp	SHORT $LN217@lagrange_t@2
$LN390@lagrange_t@2:
	mov	ebx, DWORD PTR _headv$89429[ebp]
$LN216@lagrange_t@2:
	mov	DWORD PTR tv946[ebp], OFFSET ??_C@_04CGFJFPFD@none?$AA@
$LN217@lagrange_t@2:
	test	eax, eax
	je	SHORT $LN222@lagrange_t@2
	mov	ecx, DWORD PTR _web+12
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	eax, DWORD PTR [eax+edi+64]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	ebx, DWORD PTR _headv$89429[ebp]
	imul	ecx, 136				; 00000088H
	add	edx, ecx
	mov	DWORD PTR tv973[ebp], edx
	jne	SHORT $LN223@lagrange_t@2
$LN222@lagrange_t@2:
	mov	DWORD PTR tv973[ebp], OFFSET ??_C@_04CGFJFPFD@none?$AA@
$LN223@lagrange_t@2:
	cmp	DWORD PTR tv2653[ebp], 0
	je	SHORT $LN224@lagrange_t@2
	mov	edx, DWORD PTR tv2655[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv985[ebp], OFFSET _elnames+60
	jmp	SHORT $LN225@lagrange_t@2
$LN224@lagrange_t@2:
	mov	DWORD PTR tv985[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN225@lagrange_t@2:
	mov	eax, DWORD PTR _tailv$89430[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN226@lagrange_t@2
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	edi, OFFSET _elnames+30
	jmp	SHORT $LN227@lagrange_t@2
$LN226@lagrange_t@2:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN227@lagrange_t@2:
	test	ebx, 268435456				; 10000000H
	je	SHORT $LN228@lagrange_t@2
	and	ebx, 134217727				; 07ffffffH
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN229@lagrange_t@2
$LN228@lagrange_t@2:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN229@lagrange_t@2:
	mov	ecx, DWORD PTR tv919[ebp]
	mov	edx, DWORD PTR tv946[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv973[ebp]
	push	edx
	mov	edx, DWORD PTR tv985[ebp]
	push	ecx
	push	edx
	push	edi
	push	eax
	push	OFFSET ??_C@_0EI@HCOKNLCI@Vertices?5?$CFs?5and?5?$CFs?5of?5edge?5?$CFs?5ar@
	push	OFFSET _errmsg
	call	_sprintf

; 524  :                   kb_error(1803,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1803					; 0000070bH
	call	_kb_error
	mov	ebx, DWORD PTR _bdry$89423[ebp]
	add	esp, 44					; 0000002cH
$LN29@lagrange_t@2:

; 525  : 
; 526  :                 }
; 527  : 
; 528  :              set_attr(v[k],BOUNDARY);

	mov	eax, DWORD PTR [esi]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 128			; 00000080H
	mov	DWORD PTR [eax+12], ecx

; 529  :              set_boundary_num(v[k],bdry->num);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN230@lagrange_t@2
	mov	edx, DWORD PTR [esi]
	imul	eax, 240				; 000000f0H
	mov	ecx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ecx, DWORD PTR [ebx+44]
	mov	DWORD PTR [edx+eax], ecx
$LN230@lagrange_t@2:

; 530  :      
; 531  :              /* projecting on tangent */
; 532  :              mv = get_coord(v[k]);

	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+12
	mov	edi, DWORD PTR _web+104
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [edi+ebx+64]

; 533  :              mu = get_coord(base_v);
; 534  :              paramb = get_param(base_v);
; 535  :              parammid = get_param(v[k]);

	mov	edi, DWORD PTR [edi+ebx+544]
	mov	ebx, DWORD PTR _web+12

; 536  :              b_extrapolate(bdry,mu,mv,mv,paramb,parammid,v[k]);

	push	eax
	mov	DWORD PTR tv2813[ebp], edi
	mov	edi, DWORD PTR _base_v$89428[ebp]
	mov	eax, DWORD PTR tv2813[ebp]
	lea	esi, DWORD PTR [edx+ecx]
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	add	ecx, eax
	push	ecx
	mov	ecx, DWORD PTR _bdry$89423[ebp]
	add	eax, edi
	push	eax
	push	esi
	push	esi
	add	edi, edx
	push	edi
	push	ecx
	call	_b_extrapolate
	mov	ebx, DWORD PTR _dim$[ebp]
	mov	esi, DWORD PTR tv4103[ebp]
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN382@lagrange_t@2
$LN34@lagrange_t@2:

; 537  : 
; 538  :           }
; 539  :           else if ( get_eattr(e_id) & CONSTRAINT )

	mov	eax, ecx
	and	eax, 1024				; 00000400H
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN382@lagrange_t@2

; 540  :           { 
; 541  :              ATTR attr = get_eattr(e_id) & (BDRY_ENERGY|BDRY_CONTENT|CONSTRAINT );
; 542  :              conmap_t * conmap = get_e_constraint_map(e_id);

	mov	eax, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	and	ecx, 5632				; 00001600H
	cmp	DWORD PTR [eax+edi+1048], 0
	je	SHORT $LN232@lagrange_t@2
	mov	edi, DWORD PTR [eax+edi+1024]
	add	edi, edx
	jmp	SHORT $LN233@lagrange_t@2
$LN232@lagrange_t@2:
	mov	edi, OFFSET _nullcon
$LN233@lagrange_t@2:

; 543  :      
; 544  :              set_attr(v[k],attr);

	mov	eax, DWORD PTR [esi]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	or	DWORD PTR [eax+8], ecx
	xor	ecx, ecx
	or	DWORD PTR [eax+12], ecx

; 545  :              set_v_conmap(v[k],conmap);

	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	call	_set_v_conmap

; 546  :              project_v_constr(v[k],ACTUAL_MOVE,RESET_ONESIDEDNESS);

	mov	ecx, DWORD PTR [esi]
	push	1
	push	1
	push	ecx
	call	_project_v_constr
	add	esp, 20					; 00000014H
$LN382@lagrange_t@2:

; 547  :           }
; 548  :         }
; 549  :         increment_lagrange_index(dim,inx);

	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	push	ebx
	call	_increment_lagrange_index
	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	add	esi, 4
	add	esp, 8
	mov	DWORD PTR _k$[ebp], eax
	mov	DWORD PTR tv4103[ebp], esi
	cmp	eax, DWORD PTR _new_ectrl$[ebp]
	jl	$LL403@lagrange_t@2
$LN72@lagrange_t@2:

; 445  :   }
; 446  : 
; 447  :   MFOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR tv2655[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _e_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv2653[ebp], eax
	jne	$LL73@lagrange_t@2
	mov	esi, DWORD PTR _l_order$GSCopy$[ebp]
$LN383@lagrange_t@2:

; 550  :      }
; 551  :    }
; 552  :   /* now install edge vertices in facets */
; 553  :   /* being careful with edge orientation */
; 554  :   if ( web.representation != STRING )

	cmp	DWORD PTR _web+624, 1
	je	$LN23@lagrange_t@2

; 555  :   { MFOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+272
	mov	eax, ecx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv2368[ebp], eax
	je	$LN23@lagrange_t@2
	npad	10
$LL25@lagrange_t@2:
	mov	eax, DWORD PTR _web+236
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	edi, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv2371[ebp], edx
	je	$LN24@lagrange_t@2

; 556  :      { vertex_id *v,*ev;
; 557  :         facetedge_id fe;
; 558  : 
; 559  :         dim = web.dimension;

	mov	edx, DWORD PTR _web+620

; 560  :         v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _web+328
	mov	DWORD PTR _dim$[ebp], edx
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+304]
	add	eax, edi
	mov	DWORD PTR _v$89526[ebp], eax

; 561  : /* just 2D facets for now */
; 562  :         fe=get_facet_fe(f_id);

	cmp	DWORD PTR tv2368[ebp], ebx
	jne	SHORT $LN267@lagrange_t@2
	xor	eax, eax
	jmp	SHORT $LN266@lagrange_t@2
$LN267@lagrange_t@2:
	mov	eax, DWORD PTR [edi+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN266@lagrange_t@2
	xor	eax, 134217728				; 08000000H
$LN266@lagrange_t@2:

; 563  :         e_id = get_fe_edge(fe);

	mov	esi, DWORD PTR _web+460

; 564  :         ev = get_edge_vertices(e_id);

	mov	edi, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	mov	DWORD PTR _fe$89528[ebp], eax
	add	edx, edx
	mov	esi, DWORD PTR [edx+esi]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [esi+20]

; 565  :         if ( inverted(f_id) == inverted(e_id) )

	shr	ecx, 27					; 0000001bH
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+esi*4]
	mov	esi, DWORD PTR _web+216
	add	edi, DWORD PTR [esi+ebx+304]

; 566  :           for ( k = 1 ; k < l_order ; k++ ) v[k] = ev[k];

	mov	esi, DWORD PTR _l_order$GSCopy$[ebp]
	shr	eax, 27					; 0000001bH
	and	ecx, 1
	and	eax, 1
	mov	DWORD PTR tv2855[ebp], ecx
	cmp	ecx, eax
	jne	SHORT $LN20@lagrange_t@2
	cmp	esi, 1
	jle	SHORT $LN387@lagrange_t@2
	mov	ecx, DWORD PTR _v$89526[ebp]
	lea	eax, DWORD PTR [ecx+4]
	sub	edi, ecx
	lea	ecx, DWORD PTR [esi-1]
$LL19@lagrange_t@2:
	mov	ebx, DWORD PTR [edi+eax]
	mov	DWORD PTR [eax], ebx
	add	eax, 4
	dec	ecx
	jne	SHORT $LL19@lagrange_t@2

; 567  :         else

	jmp	SHORT $LN387@lagrange_t@2
$LN20@lagrange_t@2:

; 568  :           for ( k = 1 ; k < l_order ; k++ ) v[k] = ev[l_order-k];

	mov	eax, 1
	cmp	esi, eax
	jle	SHORT $LN387@lagrange_t@2
	mov	ecx, DWORD PTR _v$89526[ebp]
	lea	edi, DWORD PTR [edi+esi*4-4]
$LL15@lagrange_t@2:
	mov	ebx, DWORD PTR [edi]
	mov	DWORD PTR [ecx+eax*4], ebx
	inc	eax
	sub	edi, 4
	cmp	eax, esi
	jl	SHORT $LL15@lagrange_t@2
$LN387@lagrange_t@2:

; 569  : 
; 570  :         fe=get_next_edge(fe);

	test	DWORD PTR _fe$89528[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edx+eax]
	je	SHORT $LN273@lagrange_t@2
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _fe$89528[ebp], eax
	jmp	SHORT $LN272@lagrange_t@2
$LN273@lagrange_t@2:
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _fe$89528[ebp], edx
$LN272@lagrange_t@2:

; 571  :         e_id = get_fe_edge(fe);

	mov	eax, DWORD PTR _fe$89528[ebp]
	mov	ecx, DWORD PTR _web+460

; 572  :         ev = get_edge_vertices(e_id);

	mov	edi, DWORD PTR _web+216
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ebx+ecx]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	add	ecx, DWORD PTR [edi+edx+304]

; 573  :         for ( k = 1 ; k < l_order ; k++ )

	mov	edi, 1
	mov	DWORD PTR _ev$89527[ebp], ecx
	cmp	esi, edi
	jle	$LN388@lagrange_t@2
	shr	eax, 27					; 0000001bH
	and	eax, edi
	mov	DWORD PTR tv2869[ebp], eax
	lea	eax, DWORD PTR [esi-1]
	lea	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR tv4285[ebp], eax
	mov	DWORD PTR tv4312[ebp], ecx
	npad	12
$LL12@lagrange_t@2:

; 574  :         { inx[1] = l_order-k;
; 575  :           inx[2] = k;
; 576  :           inx[0] = 0;
; 577  :           spot = lagrange_index(dim,l_order,inx);

	mov	ecx, DWORD PTR _dim$[ebp]
	mov	edx, DWORD PTR tv4285[ebp]
	lea	eax, DWORD PTR _inx$[ebp]
	push	eax
	push	esi
	push	ecx
	mov	DWORD PTR _inx$[ebp+4], edx
	mov	DWORD PTR _inx$[ebp+8], edi
	mov	DWORD PTR _inx$[ebp], 0
	call	_lagrange_index

; 578  :           if ( inverted(f_id) == inverted(e_id) )

	mov	edx, DWORD PTR tv2869[ebp]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR tv2855[ebp], edx
	jne	SHORT $LN9@lagrange_t@2

; 579  :              v[spot] = ev[k];

	mov	ecx, DWORD PTR _ev$89527[ebp]
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR _v$89526[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 580  :           else

	jmp	SHORT $LN11@lagrange_t@2
$LN9@lagrange_t@2:

; 581  :              v[spot] = ev[l_order-k];

	mov	edx, DWORD PTR tv4312[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _v$89526[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
$LN11@lagrange_t@2:

; 573  :         for ( k = 1 ; k < l_order ; k++ )

	sub	DWORD PTR tv4312[ebp], 4
	dec	DWORD PTR tv4285[ebp]
	inc	edi
	cmp	edi, esi
	jl	SHORT $LL12@lagrange_t@2
$LN388@lagrange_t@2:

; 582  :         }
; 583  :         fe=get_next_edge(fe);

	test	DWORD PTR _fe$89528[ebp], 134217728	; 08000000H
	mov	ecx, DWORD PTR _web+460
	je	SHORT $LN279@lagrange_t@2
	mov	eax, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN278@lagrange_t@2
$LN279@lagrange_t@2:
	mov	edx, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [edx+32]
$LN278@lagrange_t@2:

; 584  :         e_id = get_fe_edge(fe);

	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 585  :         ev = get_edge_vertices(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	ebx, DWORD PTR [edx+ecx+304]

; 586  :         for ( k = 1 ; k < l_order ; k++ )

	mov	edi, 1
	cmp	esi, edi
	jle	$LN389@lagrange_t@2
	shr	eax, 27					; 0000001bH
	and	eax, edi
	mov	DWORD PTR tv2869[ebp], eax
	lea	edx, DWORD PTR [esi-1]
	lea	eax, DWORD PTR [ebx+esi*4-4]
	mov	DWORD PTR tv4355[ebp], edx
	mov	DWORD PTR tv4382[ebp], eax
	npad	13
$LL7@lagrange_t@2:

; 587  :         { inx[1] = 0;
; 588  :           inx[0] = k;
; 589  :           inx[2] = l_order - k;
; 590  :           spot = lagrange_index(dim,l_order,inx);

	mov	eax, DWORD PTR _dim$[ebp]
	mov	ecx, DWORD PTR tv4355[ebp]
	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	push	esi
	push	eax
	mov	DWORD PTR _inx$[ebp+4], 0
	mov	DWORD PTR _inx$[ebp], edi
	mov	DWORD PTR _inx$[ebp+8], ecx
	call	_lagrange_index

; 591  :           if ( inverted(f_id) == inverted(e_id) )

	mov	ecx, DWORD PTR tv2869[ebp]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR tv2855[ebp], ecx
	jne	SHORT $LN4@lagrange_t@2

; 592  :              v[spot] = ev[k];

	mov	edx, DWORD PTR [ebx+edi*4]
	mov	ecx, DWORD PTR _v$89526[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 593  :           else

	jmp	SHORT $LN6@lagrange_t@2
$LN4@lagrange_t@2:

; 594  :              v[spot] = ev[l_order-k];

	mov	edx, DWORD PTR tv4382[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _v$89526[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
$LN6@lagrange_t@2:

; 586  :         for ( k = 1 ; k < l_order ; k++ )

	sub	DWORD PTR tv4382[ebp], 4
	dec	DWORD PTR tv4355[ebp]
	inc	edi
	cmp	edi, esi
	jl	SHORT $LL7@lagrange_t@2
$LN389@lagrange_t@2:
	mov	edx, DWORD PTR tv2371[ebp]
$LN24@lagrange_t@2:

; 555  :   { MFOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [edx+eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, ecx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv2368[ebp], eax
	jne	$LL25@lagrange_t@2
$LN23@lagrange_t@2:

; 595  :         }
; 596  :      }
; 597  :   }
; 598  :     
; 599  :   free_matrix(trans);

	mov	edx, DWORD PTR _trans$[ebp]
	push	edx
	call	_free_matrix

; 600  :   free_matrix(newx);

	mov	eax, DWORD PTR _newx$[ebp]
	push	eax
	call	_free_matrix

; 601  :   free_matrix(oldx);

	mov	ecx, DWORD PTR _oldx$[ebp]
	push	ecx
	call	_free_matrix
	add	esp, 12					; 0000000cH

; 602  : 
; 603  :   if ( l_order < web.lagrange_order )

	cmp	esi, DWORD PTR _web+632
	jge	SHORT $LN396@lagrange_t@2

; 604  :   { expand_attribute(EDGE,E_VERTICES_ATTR,&new_ectrl);

	lea	edx, DWORD PTR _new_ectrl$[ebp]
	push	edx
	push	1
	push	1
	call	_expand_attribute

; 605  :     expand_attribute(FACET,F_VERTICES_ATTR,&new_fctrl);

	lea	eax, DWORD PTR _new_fctrl$[ebp]
	push	eax
	push	1
	push	2
	call	_expand_attribute
	add	esp, 24					; 00000018H
$LN396@lagrange_t@2:

; 606  :   } /* can now shrink  */
; 607  : 
; 608  :   web.lagrange_order = l_order;
; 609  :   web.skel[FACET].ctrlpts = new_fctrl;
; 610  :   web.skel[EDGE].ctrlpts = edge_ctrl = new_ectrl;

	mov	eax, DWORD PTR _new_ectrl$[ebp]
	mov	ecx, DWORD PTR _new_fctrl$[ebp]
	mov	DWORD PTR _edge_ctrl, eax
	mov	DWORD PTR _web+120, eax

; 611  :   change_flag = 1;
; 612  :   web_timestamp = top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _web+632, esi
	mov	DWORD PTR _web+232, ecx
	mov	DWORD PTR _change_flag, 1
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	DWORD PTR _web_timestamp, eax

; 613  :   web.headvnum = l_order;

	mov	DWORD PTR _web+636, esi

; 614  :   setup_q_info();

	call	_setup_q_info

; 615  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89176[ebp], 0
	je	SHORT $LN1@lagrange_t@2
	mov	edx, DWORD PTR _graphmutex
	push	edx
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@lagrange_t@2:

; 616  : 
; 617  :   recalc();

	call	_recalc
	pop	edi
$LN190@lagrange_t@2:

; 618  : 
; 619  : } /* end of lagrange_to_lagrange() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_lagrange_to_lagrange ENDP
_TEXT	ENDS
PUBLIC	__real@4020000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@bff0000000000000
PUBLIC	_gauss_setup
EXTRN	_intpoly6part:PROC
EXTRN	_intpoly6:PROC
EXTRN	_gpolypartial:DWORD
EXTRN	_gpoly:DWORD
EXTRN	_gauss1polyd:DWORD
EXTRN	_gauss1poly:DWORD
EXTRN	_gauss1Dwt:DWORD
EXTRN	_gauss1Dpt:DWORD
EXTRN	_gauss2Dpt:DWORD
EXTRN	_gauss2Dwt:DWORD
EXTRN	_gauss2D_num:DWORD
EXTRN	_myfree:PROC
EXTRN	_conical_w:DWORD
EXTRN	_conical_x:DWORD
EXTRN	_gauss1D_num:DWORD
EXTRN	_ctrl_num:DWORD
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _gauss_setup
_TEXT	SEGMENT
tv1698 = -36						; size = 4
tv1882 = -32						; size = 4
tv1690 = -28						; size = 4
tv1247 = -28						; size = 4
tv2143 = -24						; size = 4
tv1663 = -24						; size = 4
tv1606 = -24						; size = 4
tv1568 = -24						; size = 4
tv1398 = -24						; size = 4
tv1451 = -20						; size = 4
tv1402 = -20						; size = 4
tv1798 = -16						; size = 4
tv1417 = -16						; size = 4
tv2183 = -12						; size = 4
tv2170 = -12						; size = 4
tv1602 = -12						; size = 4
_k$ = -12						; size = 4
_m$ = -12						; size = 4
_scale$90101 = -8					; size = 4
_j$ = -4						; size = 4
_gauss_setup PROC					; COMDAT

; 913  : { int i,j,k,m;

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 914  : 
; 915  :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN74@gauss_setu

; 916  :          gauss_lagrange_setup(1,web.lagrange_order,web.gauss1D_order);

	mov	eax, DWORD PTR _web+1592
	mov	ecx, DWORD PTR _web+632
	push	eax
	push	ecx
	push	1
	call	_gauss_lagrange_setup
	add	esp, 12					; 0000000cH

; 917  :   else

	jmp	SHORT $LN73@gauss_setu
$LN74@gauss_setu:

; 918  :   { gauss_lagrange_setup(web.dimension-1,web.lagrange_order,web.gauss1D_order);

	mov	edx, DWORD PTR _web+1592
	mov	eax, DWORD PTR _web+632
	mov	ecx, DWORD PTR _web+620
	push	edx
	push	eax
	dec	ecx
	push	ecx
	call	_gauss_lagrange_setup

; 919  :     gauss_lagrange_setup(web.dimension,web.lagrange_order,web.gauss2D_order);

	mov	edx, DWORD PTR _web+1596
	mov	eax, DWORD PTR _web+632
	mov	ecx, DWORD PTR _web+620
	push	edx
	push	eax
	push	ecx
	call	_gauss_lagrange_setup
	add	esp, 24					; 00000018H
$LN73@gauss_setu:

; 920  :   }
; 921  : 
; 922  :   /* set number of control points */
; 923  :   ctrl_num = web.dimension + 1;
; 924  :   if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	push	ebx
	push	esi
	mov	esi, DWORD PTR _web+620
	push	edi
	lea	edi, DWORD PTR [esi+1]
	mov	DWORD PTR _ctrl_num, edi
	jne	SHORT $LN72@gauss_setu

; 925  :     ctrl_num += web.dimension*(web.dimension+ 1)/2;

	mov	eax, edi
	imul	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	add	DWORD PTR _ctrl_num, eax
$LN72@gauss_setu:

; 926  : 
; 927  :   /* set number of integration points and weights */
; 928  :   gauss1D_num = (abs(web.gauss1D_order)+2)/2;

	mov	eax, DWORD PTR _web+1592
	cdq
	xor	eax, edx
	sub	eax, edx
	add	eax, 2
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	mov	DWORD PTR _gauss1D_num, ecx

; 929  :   if ( web.dimension == 2 )

	mov	ebx, 3
	cmp	esi, 2
	jne	$LN71@gauss_setu

; 930  :   { 
; 931  :     if ( web.gauss2D_order >=  14 ) 

	mov	eax, DWORD PTR _web+1596
	cmp	eax, 14					; 0000000eH
	jl	$LN70@gauss_setu

; 932  :     { /* use conical product formula */
; 933  :       int npts = 1+web.gauss2D_order/2; /* per dimension */

	cdq
	sub	eax, edx
	mov	esi, eax

; 934  :       if ( conical_x ) free_matrix(conical_x);

	mov	eax, DWORD PTR _conical_x
	sar	esi, 1
	inc	esi
	test	eax, eax
	je	SHORT $LN69@gauss_setu
	push	eax
	call	_free_matrix
	add	esp, 4
$LN69@gauss_setu:

; 935  :       if ( conical_w ) myfree((char*)conical_w);

	mov	eax, DWORD PTR _conical_w
	test	eax, eax
	je	SHORT $LN68@gauss_setu
	push	eax
	call	_myfree
	add	esp, 4
$LN68@gauss_setu:

; 936  :       conical_x = dmatrix(0,npts*npts-1,0,2);

	imul	esi, esi
	push	936					; 000003a8H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	2
	push	0
	lea	edx, DWORD PTR [esi-1]
	push	edx
	push	0
	call	_kb_dmatrix

; 937  :       conical_w = (REAL*)mycalloc(npts*npts,sizeof(REAL));

	push	937					; 000003a9H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	8
	push	esi
	mov	DWORD PTR _conical_x, eax
	call	_kb_calloc

; 938  :       simplex_quadrature(2,web.gauss2D_order,npts*npts,conical_x,conical_w);

	mov	ecx, DWORD PTR _web+1596
	push	eax
	mov	DWORD PTR _conical_w, eax
	mov	eax, DWORD PTR _conical_x
	push	eax
	push	esi
	push	ecx
	push	2
	call	_simplex_quadrature

; 939  :       gauss2D_num = npts*npts;
; 940  :       gauss2Dpt = (barytype*)(conical_x[0]);

	mov	edx, DWORD PTR _conical_x

; 941  :       gauss2Dwt = conical_w;

	mov	ecx, DWORD PTR _conical_w
	mov	DWORD PTR _gauss2D_num, esi
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _gauss2Dwt, ecx
	mov	ecx, DWORD PTR _gauss1D_num
	add	esp, 60					; 0000003cH
	mov	DWORD PTR _gauss2Dpt, eax
	jmp	$LN54@gauss_setu
$LN70@gauss_setu:

; 942  :     }
; 943  :     else if ( web.gauss2D_order >=  12 ) 

	cmp	eax, 12					; 0000000cH
	jl	SHORT $LN66@gauss_setu

; 944  :     { gauss2D_num = 37;

	mov	DWORD PTR _gauss2D_num, 37		; 00000025H

; 945  :       gauss2Dpt = gauss2Dpt13;

	mov	DWORD PTR _gauss2Dpt, OFFSET _gauss2Dpt13

; 946  :       gauss2Dwt = gauss2Dwt13;

	mov	DWORD PTR _gauss2Dwt, OFFSET _gauss2Dwt13
	jmp	$LN54@gauss_setu
$LN66@gauss_setu:

; 947  :     }
; 948  :     else if ( web.gauss2D_order >=  9 ) 

	cmp	eax, 9
	jl	SHORT $LN64@gauss_setu

; 949  :     { gauss2D_num = 28;

	mov	DWORD PTR _gauss2D_num, 28		; 0000001cH

; 950  :       gauss2Dpt = gauss2Dpt11;

	mov	DWORD PTR _gauss2Dpt, OFFSET _gauss2Dpt11

; 951  :       gauss2Dwt = gauss2Dwt11;

	mov	DWORD PTR _gauss2Dwt, OFFSET _gauss2Dwt11
	jmp	$LN54@gauss_setu
$LN64@gauss_setu:

; 952  :     }
; 953  :     else if ( web.gauss2D_order >=  7 ) 

	cmp	eax, 7
	jl	SHORT $LN62@gauss_setu

; 954  :     { gauss2D_num = 16;

	mov	DWORD PTR _gauss2D_num, 16		; 00000010H

; 955  :       gauss2Dpt = gauss2Dpt8;

	mov	DWORD PTR _gauss2Dpt, OFFSET _gauss2Dpt8

; 956  :       gauss2Dwt = gauss2Dwt8;

	mov	DWORD PTR _gauss2Dwt, OFFSET _gauss2Dwt8
	jmp	$LN54@gauss_setu
$LN62@gauss_setu:

; 957  :     }
; 958  :     else if ( web.gauss2D_order >= 6 ) 

	cmp	eax, 6
	jl	SHORT $LN60@gauss_setu

; 959  :     { gauss2D_num = 12;

	mov	DWORD PTR _gauss2D_num, 12		; 0000000cH

; 960  :       gauss2Dpt = gauss2Dpt6;

	mov	DWORD PTR _gauss2Dpt, OFFSET _gauss2Dpt6

; 961  :       gauss2Dwt = gauss2Dwt6;

	mov	DWORD PTR _gauss2Dwt, OFFSET _gauss2Dwt6
	jmp	SHORT $LN54@gauss_setu
$LN60@gauss_setu:

; 962  :     }
; 963  :     else if ( web.gauss2D_order >= 3 ) 

	cmp	eax, ebx
	jl	SHORT $LN58@gauss_setu

; 964  :     { gauss2D_num = 7;

	mov	DWORD PTR _gauss2D_num, 7

; 965  :       gauss2Dpt = gauss2Dpt5;

	mov	DWORD PTR _gauss2Dpt, OFFSET _gauss2Dpt5

; 966  :       gauss2Dwt = gauss2Dwt5;

	mov	DWORD PTR _gauss2Dwt, OFFSET _gauss2Dwt5
	jmp	SHORT $LN54@gauss_setu
$LN58@gauss_setu:

; 967  :     }
; 968  :     else if ( web.gauss2D_order >= 2 )

	cmp	eax, 2
	jl	SHORT $LN56@gauss_setu

; 969  :     { gauss2D_num = 3;

	mov	DWORD PTR _gauss2D_num, ebx

; 970  :       gauss2Dpt = gauss2Dpt2;

	mov	DWORD PTR _gauss2Dpt, OFFSET _gauss2Dpt2

; 971  :       gauss2Dwt = gauss2Dwt2;

	mov	DWORD PTR _gauss2Dwt, OFFSET _gauss2Dwt2

; 972  :     }
; 973  :     else

	jmp	SHORT $LN54@gauss_setu
$LN56@gauss_setu:

; 974  :     { gauss2D_num = 1;

	mov	DWORD PTR _gauss2D_num, 1

; 975  :       gauss2Dpt = gauss2Dpt1;

	mov	DWORD PTR _gauss2Dpt, OFFSET _gauss2Dpt1

; 976  :       gauss2Dwt = gauss2Dwt1;

	mov	DWORD PTR _gauss2Dwt, OFFSET _gauss2Dwt1

; 977  :     }

	jmp	SHORT $LN54@gauss_setu
$LN71@gauss_setu:

; 978  :   }
; 979  :   else gauss2D_num = web.dimension + 1;

	mov	DWORD PTR _gauss2D_num, edi
$LN54@gauss_setu:

; 980  : 
; 981  :   /* always have 1D integration for edges on constraints */
; 982  :   web.gauss1D_order = abs(web.gauss1D_order);

	mov	eax, DWORD PTR _web+1592
	cdq
	xor	eax, edx
	sub	eax, edx

; 983  :   gauss1Dpt = (REAL *)kb_realloc((char*)gauss1Dpt,gauss1D_num*sizeof(REAL));

	push	983					; 000003d7H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	lea	edx, DWORD PTR [ecx*8]
	mov	DWORD PTR _web+1592, eax
	mov	eax, DWORD PTR _gauss1Dpt
	push	edx
	push	eax
	call	_KB_realloc

; 984  :   gauss1Dwt = (REAL *)kb_realloc((char*)gauss1Dwt,gauss1D_num*sizeof(REAL));

	mov	ecx, DWORD PTR _gauss1D_num
	push	984					; 000003d8H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	lea	edx, DWORD PTR [ecx*8]
	mov	DWORD PTR _gauss1Dpt, eax
	mov	eax, DWORD PTR _gauss1Dwt
	push	edx
	push	eax
	call	_KB_realloc

; 985  :   grule(gauss1D_num,gauss1Dpt,gauss1Dwt);

	mov	ecx, DWORD PTR _gauss1Dpt
	mov	edx, DWORD PTR _gauss1D_num
	push	eax
	push	ecx
	push	edx
	mov	DWORD PTR _gauss1Dwt, eax
	call	_grule

; 986  :   if ( gauss1poly ) 

	mov	eax, DWORD PTR _gauss1poly
	xor	esi, esi
	add	esp, 44					; 0000002cH
	cmp	eax, esi
	je	SHORT $LN53@gauss_setu

; 987  :   { free_matrix(gauss1poly); gauss1poly = NULL;

	push	eax
	call	_free_matrix

; 988  :     free_matrix(gauss1polyd); gauss1polyd = NULL;

	mov	eax, DWORD PTR _gauss1polyd
	push	eax
	mov	DWORD PTR _gauss1poly, esi
	call	_free_matrix
	add	esp, 8
	mov	DWORD PTR _gauss1polyd, esi
$LN53@gauss_setu:

; 989  :   }
; 990  :   if ( web.modeltype == LINEAR )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	jne	$LN52@gauss_setu

; 991  :   { edge_ctrl = 2;
; 992  :     gauss1poly = dmatrix(0,edge_ctrl-1,0,gauss1D_num-1);

	mov	ecx, DWORD PTR _gauss1D_num
	push	992					; 000003e0H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	dec	ecx
	push	ecx
	push	esi
	push	eax
	push	esi
	mov	DWORD PTR _edge_ctrl, 2
	call	_kb_dmatrix

; 993  :     gauss1polyd = dmatrix(0,edge_ctrl-1,0,gauss1D_num-1);

	mov	edx, DWORD PTR _gauss1D_num
	push	993					; 000003e1H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	mov	DWORD PTR _gauss1poly, eax
	mov	eax, DWORD PTR _edge_ctrl
	dec	edx
	push	edx
	push	esi
	dec	eax
	push	eax
	push	esi
	call	_kb_dmatrix
	add	esp, 48					; 00000030H

; 994  :     for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	edx, edx
	mov	DWORD PTR _gauss1polyd, eax
	cmp	DWORD PTR _gauss1D_num, esi
	jle	$LN111@gauss_setu
	mov	edi, DWORD PTR _gauss1poly
	fld1
	mov	ecx, DWORD PTR _gauss1Dpt
	fld	QWORD PTR __real@bff0000000000000
	mov	esi, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [eax+4]
	sub	esi, ecx
	sub	edi, ecx
	sub	ebx, ecx
	sub	eax, ecx
	jmp	SHORT $LN51@gauss_setu
$LN122@gauss_setu:
	fxch	ST(1)
$LN51@gauss_setu:

; 995  :     { gauss1poly[0][m] = (1-gauss1Dpt[m]);

	fld	ST(1)
	inc	edx
	fsub	QWORD PTR [ecx]
	add	ecx, 8
	fstp	QWORD PTR [esi+ecx-8]

; 996  :       gauss1poly[1][m] = gauss1Dpt[m];

	fld	QWORD PTR [ecx-8]
	fstp	QWORD PTR [edi+ecx-8]

; 997  :       gauss1polyd[0][m] = -1.0;

	fst	QWORD PTR [ebx+ecx-8]

; 998  :       gauss1polyd[1][m] =  1.0;

	fxch	ST(1)
	fst	QWORD PTR [eax+ecx-8]
	cmp	edx, DWORD PTR _gauss1D_num
	jl	SHORT $LN122@gauss_setu

; 999  :     }
; 1000 :   }
; 1001 :   else if ( web.modeltype == QUADRATIC )

	jmp	$LN190@gauss_setu
$LN52@gauss_setu:
	cmp	eax, 2
	jne	$LN111@gauss_setu

; 1002 :   { edge_ctrl = 3;
; 1003 :     gauss1poly = dmatrix(0,edge_ctrl-1,0,gauss1D_num-1);

	mov	ecx, DWORD PTR _gauss1D_num
	push	1003					; 000003ebH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	dec	ecx
	push	ecx
	push	esi
	push	eax
	push	esi
	mov	DWORD PTR _edge_ctrl, ebx
	call	_kb_dmatrix

; 1004 :     gauss1polyd = dmatrix(0,edge_ctrl-1,0,gauss1D_num-1);

	mov	edx, DWORD PTR _gauss1D_num
	push	1004					; 000003ecH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	mov	DWORD PTR _gauss1poly, eax
	mov	eax, DWORD PTR _edge_ctrl
	dec	edx
	push	edx
	push	esi
	dec	eax
	push	eax
	push	esi
	call	_kb_dmatrix
	add	esp, 48					; 00000030H
	mov	DWORD PTR _gauss1polyd, eax

; 1005 :     for ( m = 0 ; m < gauss1D_num ; m++ )

	cmp	DWORD PTR _gauss1D_num, esi
	jle	$LN111@gauss_setu
	mov	ebx, DWORD PTR _gauss1poly
	fld	QWORD PTR __real@4010000000000000
	mov	edx, DWORD PTR [ebx+4]
	fld	QWORD PTR __real@4008000000000000
	mov	eax, DWORD PTR [eax]
	fld	QWORD PTR __real@4020000000000000
	mov	edi, DWORD PTR [ebx]
	fld1
	mov	ecx, DWORD PTR _gauss1Dpt
	fld	QWORD PTR __real@4000000000000000
	mov	ebx, DWORD PTR [ebx+8]
	sub	eax, edx
	mov	DWORD PTR tv1398[ebp], eax
	mov	eax, DWORD PTR _gauss1polyd
	mov	eax, DWORD PTR [eax+4]
	sub	eax, edx
	sub	edi, edx
	sub	ebx, edx
	mov	DWORD PTR tv1402[ebp], eax
	mov	eax, ecx
	sub	edx, eax
	mov	DWORD PTR tv1247[ebp], edx
	mov	edx, DWORD PTR _gauss1polyd
	mov	edx, DWORD PTR [edx+8]
	sub	edx, eax
	mov	DWORD PTR tv1417[ebp], edx
$LN46@gauss_setu:

; 1006 :     { gauss1poly[0][m] = (1-2*gauss1Dpt[m])*(1-gauss1Dpt[m]);

	fld	QWORD PTR [ecx]
	mov	eax, DWORD PTR tv1247[ebp]
	fmul	ST(0), ST(1)
	add	eax, ecx

; 1007 :       gauss1poly[1][m] = 4*gauss1Dpt[m]*(1-gauss1Dpt[m]);
; 1008 :       gauss1poly[2][m] = gauss1Dpt[m]*(2*gauss1Dpt[m]-1);
; 1009 :       gauss1polyd[0][m] = 4*gauss1Dpt[m]-3;

	mov	edx, DWORD PTR tv1398[ebp]
	inc	esi
	fsubr	ST(0), ST(2)
	add	ecx, 8
	fld	ST(2)
	fsub	QWORD PTR [ecx-8]
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR [eax+edi]
	fld	ST(1)
	fsub	QWORD PTR [ecx-8]
	fld	QWORD PTR [ecx-8]
	fmul	ST(0), ST(6)
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR [eax]
	fld	QWORD PTR [ecx-8]
	fmul	ST(0), ST(1)
	fsub	ST(0), ST(2)
	fmul	QWORD PTR [ecx-8]
	fstp	QWORD PTR [eax+ebx]
	fld	QWORD PTR [ecx-8]
	fmul	ST(0), ST(5)
	fsub	ST(0), ST(4)
	fstp	QWORD PTR [eax+edx]

; 1010 :       gauss1polyd[1][m] = 4 - 8*gauss1Dpt[m];

	mov	edx, DWORD PTR tv1402[ebp]
	fld	QWORD PTR [ecx-8]
	fmul	ST(0), ST(3)
	fsubr	ST(0), ST(5)
	fstp	QWORD PTR [eax+edx]

; 1011 :       gauss1polyd[2][m] = 4*gauss1Dpt[m]-1;

	mov	eax, DWORD PTR tv1417[ebp]
	fld	QWORD PTR [ecx-8]
	fmul	ST(0), ST(5)
	fsub	ST(0), ST(2)
	fstp	QWORD PTR [eax+ecx-8]
	cmp	esi, DWORD PTR _gauss1D_num
	jl	SHORT $LN46@gauss_setu

; 1005 :     for ( m = 0 ; m < gauss1D_num ; m++ )

	fstp	ST(1)
	fstp	ST(3)
	fstp	ST(2)
$LN190@gauss_setu:
	fstp	ST(0)
	fstp	ST(0)
$LN111@gauss_setu:

; 1012 :     }
; 1013 :   }
; 1014 :   /* could have more modeltypes here */
; 1015 :   /* would have to up EDGE_CTRL to max of possible edge_ctrl */
; 1016 : 
; 1017 :   if ( web.dimension == 1 )

	mov	eax, DWORD PTR _web+620
	cmp	eax, 1
	jne	SHORT $LN43@gauss_setu

; 1018 :   {  gauss2Dwt = gauss1Dwt; gauss2Dpt = (barytype*)gauss1Dpt; gauss2D_num = gauss1D_num; 

	mov	ecx, DWORD PTR _gauss1Dwt
	mov	edx, DWORD PTR _gauss1Dpt
	mov	eax, DWORD PTR _gauss1D_num
	mov	DWORD PTR _gauss2Dwt, ecx
	mov	DWORD PTR _gauss2Dpt, edx
	mov	DWORD PTR _gauss2D_num, eax
	jmp	SHORT $LN113@gauss_setu
$LN43@gauss_setu:

; 1019 :   }
; 1020 :   else if ( web.dimension > 2 )

	cmp	eax, 2
	jle	SHORT $LN113@gauss_setu

; 1021 :   { gauss2Dwt = (REAL *)mycalloc(gauss2D_num,sizeof(REAL));

	mov	ecx, DWORD PTR _gauss2D_num
	push	1021					; 000003fdH
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	8
	push	ecx
	call	_kb_calloc
	mov	DWORD PTR _gauss2Dwt, eax

; 1022 :      for ( i = 0 ; i < gauss2D_num ; i++ )

	xor	eax, eax
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _gauss2D_num, eax
	jle	SHORT $LN113@gauss_setu
	fld1
$LN112@gauss_setu:

; 1023 :         gauss2Dwt[i] = 1.0/gauss2D_num;  /* trivial points */

	fild	DWORD PTR _gauss2D_num
	mov	edx, DWORD PTR _gauss2Dwt
	inc	eax
	fdivr	ST(0), ST(1)
	fstp	QWORD PTR [edx+eax*8-8]
	cmp	eax, DWORD PTR _gauss2D_num
	jl	SHORT $LN112@gauss_setu

; 1022 :      for ( i = 0 ; i < gauss2D_num ; i++ )

	fstp	ST(0)
$LN113@gauss_setu:

; 1024 :   }
; 1025 : 
; 1026 :   /* set up interpolation polynomial values */
; 1027 :   if ( gpoly ) free_matrix(gpoly);

	mov	eax, DWORD PTR _gpoly
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN37@gauss_setu
	push	eax
	call	_free_matrix
	add	esp, 4
$LN37@gauss_setu:

; 1028 :   gpoly = dmatrix(0,gauss2D_num-1,0,ctrl_num-1);

	mov	eax, DWORD PTR _ctrl_num
	mov	ecx, DWORD PTR _gauss2D_num
	push	1028					; 00000404H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	dec	eax
	push	eax
	push	edi
	dec	ecx
	push	ecx
	push	edi
	call	_kb_dmatrix
	mov	DWORD PTR _gpoly, eax

; 1029 :   if ( gpolypartial ) free_matrix3(gpolypartial);

	mov	eax, DWORD PTR _gpolypartial
	add	esp, 24					; 00000018H
	cmp	eax, edi
	je	SHORT $LN36@gauss_setu
	push	eax
	call	_free_matrix3
	add	esp, 4
$LN36@gauss_setu:

; 1030 :   gpolypartial = dmatrix3(gauss2D_num,web.dimension,ctrl_num);

	mov	edx, DWORD PTR _ctrl_num
	mov	eax, DWORD PTR _web+620
	mov	ecx, DWORD PTR _gauss2D_num
	push	1030					; 00000406H
	push	OFFSET ??_C@_07KGJJPNNA@MODEL?4C?$AA@
	push	edx
	push	eax
	push	ecx
	call	_kb_dmatrix3

; 1031 :   if ( web.dimension == 1 )

	mov	ecx, DWORD PTR _web+620
	add	esp, 20					; 00000014H
	mov	DWORD PTR _gpolypartial, eax
	cmp	ecx, 1
	jne	$LN35@gauss_setu

; 1032 :     for ( j = 0 ; j < gauss2D_num ; j++ )

	mov	DWORD PTR _j$[ebp], edi
	cmp	DWORD PTR _gauss2D_num, edi
	jle	$LN4@gauss_setu
	mov	ecx, DWORD PTR _gpoly
	fldz
	fld1
	sub	ecx, eax
	mov	DWORD PTR tv1798[ebp], eax
	mov	DWORD PTR tv1882[ebp], ecx
$LN116@gauss_setu:

; 1033 :       for ( i = 0 ; i < ctrl_num ;  i++ )

	xor	esi, esi
	cmp	DWORD PTR _ctrl_num, esi
	jle	$LN33@gauss_setu
	mov	eax, DWORD PTR tv1798[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR tv1882[ebp]
	mov	eax, DWORD PTR [edx+eax]
	sub	eax, ecx
	mov	DWORD PTR tv1690[ebp], ecx
	mov	DWORD PTR tv1698[ebp], eax
$LN31@gauss_setu:

; 1036 :         int scale = ctrl_num - 1;

	mov	eax, DWORD PTR _ctrl_num
	fld	ST(0)

; 1037 :         for ( m = 0 ; m < ctrl_num ; m++ )

	mov	ebx, DWORD PTR _gauss1Dpt
	fld	ST(2)
	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR _scale$90101[ebp], ecx
	xor	ecx, ecx
	mov	DWORD PTR _m$[ebp], ecx
	cmp	eax, 4
	jl	$LC102@gauss_setu

; 1034 :       {
; 1035 :         REAL p=1.0,sum=0.0;

	mov	edi, 2
	lea	edx, DWORD PTR [esi-2]
	mov	DWORD PTR tv1451[ebp], edi
	mov	DWORD PTR tv1568[ebp], edx

; 1037 :         for ( m = 0 ; m < ctrl_num ; m++ )

$LN110@gauss_setu:

; 1038 :         { if ( m == i ) continue;

	cmp	ecx, esi
	je	SHORT $LN103@gauss_setu

; 1039 :           p *= (gauss1Dpt[j]*scale - m)/(i - m);

	fild	DWORD PTR _scale$90101[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	fld	QWORD PTR [ebx+eax*8]
	lea	eax, DWORD PTR [edx+2]
	fmul	ST(0), ST(1)
	fisub	DWORD PTR _m$[ebp]
	mov	DWORD PTR tv2183[ebp], eax
	fild	DWORD PTR tv2183[ebp]
	fdivr	ST(0), ST(1)
	fmulp	ST(4), ST(0)

; 1040 :           if ( p == 0.0 ) break;

	fld	ST(3)
	fld	ST(6)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN167@gauss_setu

; 1041 :           sum += scale/(gauss1Dpt[j]*scale - m);

	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
$LN103@gauss_setu:

; 1038 :         { if ( m == i ) continue;

	lea	eax, DWORD PTR [edi-1]
	mov	DWORD PTR tv1602[ebp], eax
	cmp	eax, esi
	je	SHORT $LN104@gauss_setu

; 1039 :           p *= (gauss1Dpt[j]*scale - m)/(i - m);

	fild	DWORD PTR _scale$90101[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	fld	QWORD PTR [ebx+eax*8]
	lea	eax, DWORD PTR [edx+1]
	fmul	ST(0), ST(1)
	fisub	DWORD PTR tv1602[ebp]
	mov	DWORD PTR tv2170[ebp], eax
	fild	DWORD PTR tv2170[ebp]
	fdivr	ST(0), ST(1)
	fmulp	ST(4), ST(0)

; 1040 :           if ( p == 0.0 ) break;

	fld	ST(3)
	fld	ST(6)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN167@gauss_setu

; 1041 :           sum += scale/(gauss1Dpt[j]*scale - m);

	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
$LN104@gauss_setu:

; 1038 :         { if ( m == i ) continue;

	cmp	edi, esi
	je	SHORT $LN106@gauss_setu

; 1039 :           p *= (gauss1Dpt[j]*scale - m)/(i - m);

	fild	DWORD PTR _scale$90101[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	fld	QWORD PTR [ebx+eax*8]
	fmul	ST(0), ST(1)
	fisub	DWORD PTR tv1451[ebp]
	fild	DWORD PTR tv1568[ebp]
	fdivr	ST(0), ST(1)
	fmulp	ST(4), ST(0)

; 1040 :           if ( p == 0.0 ) break;

	fld	ST(3)
	fld	ST(6)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN167@gauss_setu

; 1041 :           sum += scale/(gauss1Dpt[j]*scale - m);

	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
$LN106@gauss_setu:

; 1034 :       {
; 1035 :         REAL p=1.0,sum=0.0;

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR tv1606[ebp], eax

; 1038 :         { if ( m == i ) continue;

	cmp	eax, esi
	je	SHORT $LN118@gauss_setu

; 1039 :           p *= (gauss1Dpt[j]*scale - m)/(i - m);

	fild	DWORD PTR _scale$90101[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	fld	QWORD PTR [ebx+eax*8]
	lea	eax, DWORD PTR [edx-1]
	fmul	ST(0), ST(1)
	fisub	DWORD PTR tv1606[ebp]
	mov	DWORD PTR tv2143[ebp], eax
	fild	DWORD PTR tv2143[ebp]
	fdivr	ST(0), ST(1)
	fmulp	ST(4), ST(0)

; 1040 :           if ( p == 0.0 ) break;

	fld	ST(3)
	fld	ST(6)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN167@gauss_setu

; 1041 :           sum += scale/(gauss1Dpt[j]*scale - m);

	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
$LN118@gauss_setu:

; 1034 :       {
; 1035 :         REAL p=1.0,sum=0.0;

	mov	eax, DWORD PTR _ctrl_num
	add	ecx, 4
	add	edi, 4
	sub	edx, 4
	add	eax, -3					; fffffffdH
	mov	DWORD PTR _m$[ebp], ecx
	mov	DWORD PTR tv1451[ebp], edi
	mov	DWORD PTR tv1568[ebp], edx
	cmp	ecx, eax
	jl	$LN110@gauss_setu
$LC102@gauss_setu:

; 1037 :         for ( m = 0 ; m < ctrl_num ; m++ )

	cmp	ecx, DWORD PTR _ctrl_num
	jge	SHORT $LN115@gauss_setu
	mov	edx, esi
	sub	edx, ecx
	mov	DWORD PTR tv1663[ebp], edx
$LC28@gauss_setu:

; 1038 :         { if ( m == i ) continue;

	cmp	ecx, esi
	je	SHORT $LN27@gauss_setu

; 1039 :           p *= (gauss1Dpt[j]*scale - m)/(i - m);

	fild	DWORD PTR _scale$90101[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	fld	QWORD PTR [ebx+eax*8]
	fmul	ST(0), ST(1)
	fisub	DWORD PTR _m$[ebp]
	fild	DWORD PTR tv1663[ebp]
	fdivr	ST(0), ST(1)
	fmulp	ST(4), ST(0)

; 1040 :           if ( p == 0.0 ) break;

	fld	ST(3)
	fld	ST(6)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN167@gauss_setu

; 1041 :           sum += scale/(gauss1Dpt[j]*scale - m);

	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
$LN27@gauss_setu:

; 1037 :         for ( m = 0 ; m < ctrl_num ; m++ )

	inc	ecx
	dec	edx
	mov	DWORD PTR _m$[ebp], ecx
	mov	DWORD PTR tv1663[ebp], edx
	cmp	ecx, DWORD PTR _ctrl_num
	jl	SHORT $LC28@gauss_setu

; 1040 :           if ( p == 0.0 ) break;

	jmp	SHORT $LN115@gauss_setu
$LN167@gauss_setu:
	fstp	ST(1)
	fstp	ST(0)
$LN115@gauss_setu:

; 1042 :         }
; 1043 :         gpoly[j][i] = p;

	mov	eax, DWORD PTR tv1690[ebp]
	fxch	ST(1)
	mov	ecx, DWORD PTR tv1698[ebp]
	fst	QWORD PTR [ecx+eax]
	inc	esi

; 1044 :         gpolypartial[j][0][i] = sum*p;

	fmulp	ST(1), ST(0)
	add	eax, 8
	mov	DWORD PTR tv1690[ebp], eax
	fstp	QWORD PTR [eax-8]
	cmp	esi, DWORD PTR _ctrl_num
	jl	$LN31@gauss_setu
$LN33@gauss_setu:

; 1032 :     for ( j = 0 ; j < gauss2D_num ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	add	DWORD PTR tv1798[ebp], 4
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _gauss2D_num
	jl	$LN116@gauss_setu
	fstp	ST(1)

; 1066 :                                 /* since intpoly was on side 2 triangle */
; 1067 :                                 /* and gauss2Dpt barycentric  */
; 1068 :         }
; 1069 :      }
; 1070 :    }
; 1071 :    else /* higher dimension */
; 1072 :    { /* crude: gauss pts same as control points */
; 1073 :      for ( k = 0 ; k < gauss2D_num ; k++ )

	fstp	ST(0)

; 1079 :        }          
; 1080 :      }
; 1081 :    }
; 1082 :   setup_q_info();

	call	_setup_q_info
	pop	edi
	pop	esi
	pop	ebx

; 1083 : } // end gauss_setup()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@gauss_setu:

; 1045 :       }
; 1046 :   else if ( web.dimension == 2 )

	cmp	ecx, 2
	jne	$LN22@gauss_setu

; 1047 :   { if ( web.modeltype == LINEAR )

	cmp	DWORD PTR _web+628, 1
	jne	SHORT $LN21@gauss_setu

; 1048 :     { for ( k = 0 ; k < gauss2D_num ; k++ )

	cmp	DWORD PTR _gauss2D_num, edi
	jle	$LN4@gauss_setu
	mov	ecx, DWORD PTR _gauss2Dpt
	fld1
	mov	ebx, DWORD PTR _gpoly
	fld	QWORD PTR __real@bff0000000000000
	add	ecx, 16					; 00000010H
	mov	edx, eax
	sub	ebx, eax
	jmp	SHORT $LN20@gauss_setu
$LN174@gauss_setu:
	fxch	ST(1)
$LN20@gauss_setu:

; 1049 :       {
; 1050 :         gpoly[k][0] = gauss2Dpt[k][0];

	fld	QWORD PTR [ecx-16]
	mov	eax, DWORD PTR [edx+ebx]
	fstp	QWORD PTR [eax]
	inc	edi

; 1051 :         gpoly[k][1] = gauss2Dpt[k][1];

	fld	QWORD PTR [ecx-8]
	add	ecx, 24					; 00000018H
	fstp	QWORD PTR [eax+8]
	add	edx, 4

; 1052 :         gpoly[k][2] = gauss2Dpt[k][2];

	fld	QWORD PTR [ecx-24]
	fstp	QWORD PTR [eax+16]

; 1053 :         gpolypartial[k][0][0] = -1.0;

	mov	eax, DWORD PTR [edx-4]
	mov	esi, DWORD PTR [eax]

; 1054 :         gpolypartial[k][1][0] = -1.0;

	mov	eax, DWORD PTR [eax+4]
	fst	QWORD PTR [esi]
	fst	QWORD PTR [eax]

; 1055 :         gpolypartial[k][0][1] =  1.0;

	fxch	ST(1)
	fst	QWORD PTR [esi+8]

; 1056 :         gpolypartial[k][1][2] =  1.0;    /* others 0 */

	fst	QWORD PTR [eax+16]
	cmp	edi, DWORD PTR _gauss2D_num
	jl	SHORT $LN174@gauss_setu

; 1066 :                                 /* since intpoly was on side 2 triangle */
; 1067 :                                 /* and gauss2Dpt barycentric  */
; 1068 :         }
; 1069 :      }
; 1070 :    }
; 1071 :    else /* higher dimension */
; 1072 :    { /* crude: gauss pts same as control points */
; 1073 :      for ( k = 0 ; k < gauss2D_num ; k++ )

	fstp	ST(1)
	fstp	ST(0)

; 1079 :        }          
; 1080 :      }
; 1081 :    }
; 1082 :   setup_q_info();

	call	_setup_q_info
	pop	edi
	pop	esi
	pop	ebx

; 1083 : } // end gauss_setup()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@gauss_setu:

; 1057 :       }
; 1058 :     }
; 1059 :     else /* QUADRATIC */
; 1060 :     { for ( k = 0 ; k < gauss2D_num ; k++ )

	mov	DWORD PTR _k$[ebp], edi
	cmp	DWORD PTR _gauss2D_num, edi
	jle	$LN4@gauss_setu
	mov	ecx, DWORD PTR _ctrl_num
	fld	QWORD PTR __real@4000000000000000
	mov	ebx, 8
$LN114@gauss_setu:

; 1061 :         for ( j = 0 ; j < ctrl_num ; j++ )

	xor	edi, edi
	test	ecx, ecx
	jle	$LN15@gauss_setu
$LN13@gauss_setu:

; 1062 :         { gpoly[k][j] = intpoly6(j,2*gauss2Dpt[k][1],2*gauss2Dpt[k][2]);

	mov	eax, DWORD PTR _gauss2Dpt
	fld	QWORD PTR [ebx+eax+8]
	sub	esp, 16					; 00000010H
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esp+8]
	fmul	QWORD PTR [ebx+eax]
	fstp	QWORD PTR [esp]
	push	edi
	call	_intpoly6
	mov	edx, DWORD PTR _gpoly
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	fstp	QWORD PTR [ecx+edi*8]
	add	esp, 20					; 00000014H

; 1063 :           for ( i = 0 ; i < 2 ; i++ )

	fld	QWORD PTR __real@4000000000000000
	xor	esi, esi
$LN10@gauss_setu:

; 1064 :             gpolypartial[k][i][j] = 2*intpoly6part(j,i,
; 1065 :                              2*gauss2Dpt[k][1], 2*gauss2Dpt[k][2]);

	mov	eax, DWORD PTR _gauss2Dpt
	fld	QWORD PTR [ebx+eax+8]
	sub	esp, 16					; 00000010H
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esp+8]
	fmul	QWORD PTR [ebx+eax]
	fstp	QWORD PTR [esp]
	push	esi
	push	edi
	call	_intpoly6part
	fld	QWORD PTR __real@4000000000000000
	mov	edx, DWORD PTR _gpolypartial
	fmul	ST(1), ST(0)
	mov	eax, DWORD PTR _k$[ebp]
	fxch	ST(1)
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+esi*4]
	inc	esi
	fstp	QWORD PTR [edx+edi*8]
	add	esp, 24					; 00000018H
	cmp	esi, 2
	jl	SHORT $LN10@gauss_setu

; 1061 :         for ( j = 0 ; j < ctrl_num ; j++ )

	mov	ecx, DWORD PTR _ctrl_num
	inc	edi
	cmp	edi, ecx
	jl	$LN13@gauss_setu
$LN15@gauss_setu:

; 1057 :       }
; 1058 :     }
; 1059 :     else /* QUADRATIC */
; 1060 :     { for ( k = 0 ; k < gauss2D_num ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	add	ebx, 24					; 00000018H
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _gauss2D_num
	jl	$LN114@gauss_setu

; 1066 :                                 /* since intpoly was on side 2 triangle */
; 1067 :                                 /* and gauss2Dpt barycentric  */
; 1068 :         }
; 1069 :      }
; 1070 :    }
; 1071 :    else /* higher dimension */
; 1072 :    { /* crude: gauss pts same as control points */
; 1073 :      for ( k = 0 ; k < gauss2D_num ; k++ )

	fstp	ST(0)

; 1079 :        }          
; 1080 :      }
; 1081 :    }
; 1082 :   setup_q_info();

	call	_setup_q_info
	pop	edi
	pop	esi
	pop	ebx

; 1083 : } // end gauss_setup()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@gauss_setu:

; 1066 :                                 /* since intpoly was on side 2 triangle */
; 1067 :                                 /* and gauss2Dpt barycentric  */
; 1068 :         }
; 1069 :      }
; 1070 :    }
; 1071 :    else /* higher dimension */
; 1072 :    { /* crude: gauss pts same as control points */
; 1073 :      for ( k = 0 ; k < gauss2D_num ; k++ )

	cmp	DWORD PTR _gauss2D_num, edi
	jle	SHORT $LN4@gauss_setu
	mov	ebx, DWORD PTR _gpoly
	fld1
	fld	QWORD PTR __real@bff0000000000000
	mov	esi, eax
	sub	ebx, eax
	jmp	SHORT $LN6@gauss_setu
$LN189@gauss_setu:
	fxch	ST(1)
$LN6@gauss_setu:

; 1074 :      { gpoly[k][k] = 1.0;  /* rest 0 */

	mov	eax, DWORD PTR [ebx+esi]
	fxch	ST(1)
	fst	QWORD PTR [eax+edi*8]

; 1075 :        for ( j = 0 ; j < web.dimension ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+620, eax
	jle	SHORT $LN5@gauss_setu

; 1074 :      { gpoly[k][k] = 1.0;  /* rest 0 */

	mov	edx, DWORD PTR [esi]
$LN3@gauss_setu:

; 1076 :        {
; 1077 :          gpolypartial[k][j][0] = -1.0;

	mov	ecx, DWORD PTR [edx]
	fxch	ST(1)
	fst	QWORD PTR [ecx]
	inc	eax

; 1078 :          gpolypartial[k][j][j+1] = 1.0;

	fxch	ST(1)
	add	edx, 4
	fst	QWORD PTR [ecx+eax*8]
	cmp	eax, DWORD PTR _web+620
	jl	SHORT $LN3@gauss_setu
$LN5@gauss_setu:

; 1066 :                                 /* since intpoly was on side 2 triangle */
; 1067 :                                 /* and gauss2Dpt barycentric  */
; 1068 :         }
; 1069 :      }
; 1070 :    }
; 1071 :    else /* higher dimension */
; 1072 :    { /* crude: gauss pts same as control points */
; 1073 :      for ( k = 0 ; k < gauss2D_num ; k++ )

	inc	edi
	add	esi, 4
	cmp	edi, DWORD PTR _gauss2D_num
	jl	SHORT $LN189@gauss_setu
	fstp	ST(0)
	fstp	ST(0)
$LN4@gauss_setu:

; 1079 :        }          
; 1080 :      }
; 1081 :    }
; 1082 :   setup_q_info();

	call	_setup_q_info
	pop	edi
	pop	esi
	pop	ebx

; 1083 : } // end gauss_setup()

	mov	esp, ebp
	pop	ebp
	ret	0
_gauss_setup ENDP
_TEXT	ENDS
PUBLIC	_lagrange_to_linear
; Function compile flags: /Ogtp
;	COMDAT _lagrange_to_linear
_TEXT	SEGMENT
_lagrange_to_linear PROC				; COMDAT

; 48   : #ifdef MPI_EVOLVER
; 49   :   if ( this_task == MASTER_TASK )
; 50   :     mpi_model(1,LINEAR);
; 51   : #endif
; 52   : 
; 53   :   lagrange_to_lagrange(1);

	push	1
	call	_lagrange_to_lagrange
	add	esp, 4

; 54   :   web.headvnum = 1;

	mov	DWORD PTR _web+636, 1

; 55   :   web.modeltype = LINEAR;

	mov	DWORD PTR _web+628, 1

; 56   :   gauss_setup();    /* set up gaussian integration arrays */

	call	_gauss_setup

; 57   :   setup_q_info();

	call	_setup_q_info

; 58   :   recalc();

	jmp	_recalc
_lagrange_to_linear ENDP
_TEXT	ENDS
PUBLIC	_lagrange_to_quad
; Function compile flags: /Ogtp
;	COMDAT _lagrange_to_quad
_TEXT	SEGMENT
_did_graphlock_here$89048 = -4				; size = 4
_lagrange_to_quad PROC					; COMDAT

; 68   : { edge_id e_id;

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 69   :   vertex_id *v,vv;
; 70   : 
; 71   : #ifdef MPI_EVOLVER
; 72   :   if ( this_task == MASTER_TASK )
; 73   :     mpi_model(2,QUADRATIC);
; 74   : #endif
; 75   : 
; 76   :   lagrange_to_lagrange(2);

	push	2
	call	_lagrange_to_lagrange

; 77   : 
; 78   :   ENTER_GRAPH_MUTEX;

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	add	esp, 4
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN8@lagrange_t@3
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89048[ebp], 1
	jmp	SHORT $LN7@lagrange_t@3
$LN8@lagrange_t@3:
	mov	DWORD PTR _did_graphlock_here$89048[ebp], 0
$LN7@lagrange_t@3:

; 79   : 
; 80   :   MFOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+160
	test	eax, 268435456				; 10000000H
	je	$LN4@lagrange_t@3
	push	edi
	mov	edi, DWORD PTR _web+124
$LL6@lagrange_t@3:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN5@lagrange_t@3

; 81   :   { v = get_edge_vertices(e_id);

	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edx+304]

; 82   :     vv = v[1]; v[1] = v[2]; v[2] = vv;

	mov	edx, DWORD PTR [eax+ecx+8]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+4], edx

; 83   :     unset_attr(vv,Q_MIDEDGE);

	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	lea	edx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [edx]
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [eax+ecx]
	mov	edi, DWORD PTR [eax+12]
	and	DWORD PTR [eax+8], -4194305		; ffbfffffH
	mov	DWORD PTR [eax+12], edi

; 84   :     set_attr(vv,Q_MIDPOINT);

	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 131072		; 00020000H
	mov	DWORD PTR [eax+12], ecx
	mov	edi, DWORD PTR _web+124
$LN5@lagrange_t@3:

; 79   : 
; 80   :   MFOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	$LL6@lagrange_t@3
	pop	edi
$LN4@lagrange_t@3:

; 85   :   }
; 86   :   web.headvnum = 1;

	mov	DWORD PTR _web+636, 1

; 87   :   web.modeltype = QUADRATIC;

	mov	DWORD PTR _web+628, 2

; 88   :   gauss_setup();    /* set up gaussian integration arrays */

	call	_gauss_setup

; 89   :   setup_q_info();

	call	_setup_q_info

; 90   :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89048[ebp], 0
	pop	esi
	je	SHORT $LN1@lagrange_t@3
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@lagrange_t@3:

; 91   : 
; 92   :   recalc();

	call	_recalc

; 93   : } // end lagrange_to_quad())

	mov	esp, ebp
	pop	ebp
	ret	0
_lagrange_to_quad ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@BEBEPBE@Must?5do?5convert_to_quantities?5fo@ ; `string'
PUBLIC	_linear_to_lagrange
EXTRN	_convert_to_quantities:PROC
EXTRN	_auto_convert_flag:DWORD
EXTRN	_everything_quantities_flag:DWORD
;	COMDAT ??_C@_0DD@BEBEPBE@Must?5do?5convert_to_quantities?5fo@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DD@BEBEPBE@Must?5do?5convert_to_quantities?5fo@ DB 'Must do conver'
	DB	't_to_quantities for Lagrange model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\model.c
CONST	ENDS
;	COMDAT _linear_to_lagrange
_TEXT	SEGMENT
tv488 = -4						; size = 4
_l_order$ = 8						; size = 4
_linear_to_lagrange PROC				; COMDAT

; 102  : { int dim;

	push	ebp
	mov	ebp, esp
	push	ecx

; 103  :   facet_id f_id;
; 104  :   facetedge_id fe;
; 105  :   vertex_id *v;
; 106  : 
; 107  :   if ( web.skel[VERTEX].count > 0 )

	cmp	DWORD PTR _web+64, 0
	jle	SHORT $LN47@linear_to_

; 108  :     if ( !everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN47@linear_to_

; 109  :     {  if ( auto_convert_flag ) convert_to_quantities(); else

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN8@linear_to_
	call	_convert_to_quantities
	jmp	SHORT $LN47@linear_to_
$LN8@linear_to_:

; 110  :         kb_error(1797,"Must do convert_to_quantities for Lagrange model.\n",
; 111  :           RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DD@BEBEPBE@Must?5do?5convert_to_quantities?5fo@
	push	1797					; 00000705H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN47@linear_to_:

; 112  :     }
; 113  : 
; 114  : #ifdef MPI_EVOLVER
; 115  :   if ( this_task == MASTER_TASK )
; 116  :     mpi_model(l_order,LAGRANGE);
; 117  : #endif
; 118  : 
; 119  :   if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	push	esi
	push	edi
	jne	$LN3@linear_to_

; 120  :   {  MFOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	mov	esi, edx
	shr	esi, 28					; 0000001cH
	and	esi, 1
	je	$LN3@linear_to_
	push	ebx
	mov	ebx, DWORD PTR _web+236
$LL48@linear_to_:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ebx]
	mov	DWORD PTR tv488[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN4@linear_to_

; 121  :      { fe = get_facet_fe(f_id);

	test	esi, esi
	jne	SHORT $LN16@linear_to_
	xor	edx, edx
	jmp	SHORT $LN17@linear_to_
$LN16@linear_to_:
	mov	eax, DWORD PTR [ecx+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN15@linear_to_
	xor	eax, 134217728				; 08000000H
$LN15@linear_to_:
	mov	edx, eax
$LN17@linear_to_:

; 122  :        v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _web+328
	mov	esi, DWORD PTR _dymem
	mov	edi, DWORD PTR [eax+esi+304]

; 123  :        v[0] = get_fe_tailv(fe);

	mov	eax, DWORD PTR _web+460
	add	edi, ecx
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	ebx, DWORD PTR [ecx+eax]
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ebx+20]
	mov	ebx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN22@linear_to_
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _web+216
	add	eax, DWORD PTR [ebx+esi+304]
	mov	esi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN21@linear_to_
$LN22@linear_to_:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _web+216
	mov	esi, DWORD PTR [ebx+esi+304]
	mov	eax, DWORD PTR [eax+esi]
$LN21@linear_to_:
	mov	DWORD PTR [edi], eax

; 124  :        fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	test	edx, 134217728				; 08000000H
	je	SHORT $LN26@linear_to_
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN25@linear_to_
$LN26@linear_to_:
	mov	edx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [edx+32]
$LN25@linear_to_:

; 125  :        v[1] = get_fe_tailv(fe);

	mov	ebx, DWORD PTR _dymem
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	esi, DWORD PTR [ecx+eax]
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [esi+20]
	mov	esi, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN32@linear_to_
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+216
	add	eax, DWORD PTR [esi+ebx+304]
	mov	esi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN31@linear_to_
$LN32@linear_to_:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+216
	mov	esi, DWORD PTR [esi+ebx+304]
	mov	eax, DWORD PTR [eax+esi]
$LN31@linear_to_:
	mov	DWORD PTR [edi+4], eax

; 126  :        fe = get_next_edge(fe);

	test	edx, 134217728				; 08000000H
	mov	edx, DWORD PTR _web+460
	je	SHORT $LN36@linear_to_
	mov	ecx, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN35@linear_to_
$LN36@linear_to_:
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax+32]
$LN35@linear_to_:

; 127  :        v[2] = get_fe_tailv(fe);

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN42@linear_to_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN41@linear_to_
$LN42@linear_to_:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]
$LN41@linear_to_:
	mov	DWORD PTR [edi+8], eax
	mov	ebx, DWORD PTR _web+236
$LN4@linear_to_:

; 120  :   {  MFOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR tv488[ebp]
	mov	edx, DWORD PTR [ecx+ebx]
	mov	edx, DWORD PTR [edx]
	mov	esi, edx
	shr	esi, 28					; 0000001cH
	and	esi, 1
	jne	$LL48@linear_to_
	pop	ebx
$LN3@linear_to_:

; 128  :      }
; 129  :   }
; 130  : 
; 131  :   web.modeltype = LAGRANGE;
; 132  :   web.lagrange_order = 1;

	mov	esi, 1
	mov	DWORD PTR _web+628, 3
	mov	DWORD PTR _web+632, esi

; 133  :   dim = (web.representation==STRING)? 1 : web.dimension-1;

	cmp	DWORD PTR _web+624, esi
	je	SHORT $LN14@linear_to_
	mov	esi, DWORD PTR _web+620
	dec	esi
$LN14@linear_to_:

; 134  :   adjust_integration_orders(l_order);

	mov	edi, DWORD PTR _l_order$[ebp]
	push	edi
	call	_adjust_integration_orders

; 135  :   gauss_lagrange_setup(web.dimension,web.lagrange_order,web.gauss2D_order);

	mov	eax, DWORD PTR _web+1596
	mov	ecx, DWORD PTR _web+632
	mov	edx, DWORD PTR _web+620
	push	eax
	push	ecx
	push	edx
	call	_gauss_lagrange_setup

; 136  :   gauss_lagrange_setup(dim,web.lagrange_order,web.gauss1D_order);

	mov	eax, DWORD PTR _web+1592
	mov	ecx, DWORD PTR _web+632
	push	eax
	push	ecx
	push	esi
	call	_gauss_lagrange_setup

; 137  :   lagrange_to_lagrange(l_order);

	push	edi
	call	_lagrange_to_lagrange
	add	esp, 32					; 00000020H

; 138  :   setup_q_info();

	call	_setup_q_info

; 139  :   recalc();

	call	_recalc
	pop	edi
	pop	esi

; 140  : } // end linear_to_lagrange()

	mov	esp, ebp
	pop	ebp
	ret	0
_linear_to_lagrange ENDP
_TEXT	ENDS
PUBLIC	_quad_to_lagrange
; Function compile flags: /Ogtp
;	COMDAT _quad_to_lagrange
_TEXT	SEGMENT
tv743 = -8						; size = 4
_did_graphlock_here$89105 = -4				; size = 4
_l_order$ = 8						; size = 4
_quad_to_lagrange PROC					; COMDAT

; 149  : { int dim;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 150  :   facet_id f_id;
; 151  :   facetedge_id fe;
; 152  :   edge_id e_id;
; 153  :   vertex_id *v,vv;
; 154  : 
; 155  :   if ( !everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN66@quad_to_la

; 156  :   { if ( auto_convert_flag ) convert_to_quantities(); 

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN15@quad_to_la
	call	_convert_to_quantities

; 157  :     else

	jmp	SHORT $LN66@quad_to_la
$LN15@quad_to_la:

; 158  :      kb_error(1798,"Must do convert_to_quantities for Lagrange model.\n",
; 159  :           RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DD@BEBEPBE@Must?5do?5convert_to_quantities?5fo@
	push	1798					; 00000706H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN66@quad_to_la:

; 160  :   }
; 161  : 
; 162  : #ifdef MPI_EVOLVER
; 163  :   if ( this_task == MASTER_TASK )
; 164  :     mpi_model(l_order,LAGRANGE);
; 165  : #endif
; 166  : 
; 167  :   ENTER_GRAPH_MUTEX;

	push	esi
	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	push	edi
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN13@quad_to_la
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89105[ebp], 1
	jmp	SHORT $LN12@quad_to_la
$LN13@quad_to_la:
	mov	DWORD PTR _did_graphlock_here$89105[ebp], 0
$LN12@quad_to_la:

; 168  : 
; 169  :   MFOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	mov	edi, edx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	push	ebx
	je	$LN9@quad_to_la
	npad	9
$LL67@quad_to_la:
	mov	eax, DWORD PTR _web+236
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	esi, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv743[ebp], ecx
	je	$LN10@quad_to_la

; 170  :      { fe = get_facet_fe(f_id);

	test	edi, edi
	je	SHORT $LN21@quad_to_la
$LN22@quad_to_la:
	mov	edi, DWORD PTR [esi+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN21@quad_to_la
	xor	edi, 134217728				; 08000000H
$LN21@quad_to_la:

; 171  :        v = get_facet_vertices(f_id);

	mov	ecx, DWORD PTR _web+328
	mov	ebx, DWORD PTR _dymem
	mov	edx, DWORD PTR [ecx+ebx+304]

; 172  :        v[0] = get_fe_tailv(fe);

	mov	eax, DWORD PTR _web+460
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	edx, esi
	add	ecx, ecx
	mov	esi, DWORD PTR [ecx+eax]
	mov	eax, edi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [esi+20]
	mov	esi, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN28@quad_to_la
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+216
	add	eax, DWORD PTR [esi+ebx+304]
	mov	esi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN27@quad_to_la
$LN28@quad_to_la:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+216
	mov	esi, DWORD PTR [esi+ebx+304]
	mov	eax, DWORD PTR [eax+esi]
$LN27@quad_to_la:
	mov	DWORD PTR [edx], eax

; 173  :        v[1] = get_fe_midv(fe);

	mov	eax, DWORD PTR _web+460
	mov	eax, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [eax+20]
	mov	esi, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+216
	mov	esi, DWORD PTR [esi+ebx+304]
	mov	eax, DWORD PTR [eax+esi+8]
	mov	DWORD PTR [edx+4], eax

; 174  :        fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ecx+eax]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN34@quad_to_la
	mov	esi, DWORD PTR [ecx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN33@quad_to_la
$LN34@quad_to_la:
	mov	esi, DWORD PTR [ecx+32]
$LN33@quad_to_la:

; 175  :        v[2] = get_fe_tailv(fe);

	mov	ebx, DWORD PTR _dymem
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+eax]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]
	mov	edi, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN40@quad_to_la
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	add	eax, DWORD PTR [edi+ebx+304]
	mov	edi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN39@quad_to_la
$LN40@quad_to_la:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	mov	edi, DWORD PTR [edi+ebx+304]
	mov	eax, DWORD PTR [eax+edi]
$LN39@quad_to_la:
	mov	DWORD PTR [edx+8], eax

; 176  :        v[4] = get_fe_midv(fe);

	mov	eax, DWORD PTR _web+460
	mov	eax, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [eax+20]
	mov	edi, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	mov	edi, DWORD PTR [edi+ebx+304]
	mov	eax, DWORD PTR [eax+edi+8]
	mov	DWORD PTR [edx+16], eax

; 177  :        fe = get_next_edge(fe);

	test	esi, 134217728				; 08000000H
	mov	esi, DWORD PTR _web+460
	je	SHORT $LN46@quad_to_la
	mov	ecx, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN45@quad_to_la
$LN46@quad_to_la:
	mov	eax, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [eax+32]
$LN45@quad_to_la:

; 178  :        v[5] = get_fe_tailv(fe);

	mov	edi, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	esi, DWORD PTR [ecx+esi]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [esi+20]
	mov	esi, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN52@quad_to_la
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+216
	add	eax, DWORD PTR [esi+edi+304]
	mov	esi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN51@quad_to_la
$LN52@quad_to_la:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+216
	mov	esi, DWORD PTR [esi+edi+304]
	mov	eax, DWORD PTR [eax+esi]
$LN51@quad_to_la:
	mov	DWORD PTR [edx+20], eax

; 179  :        v[3] = get_fe_midv(fe);

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	mov	esi, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+esi+304]
	mov	eax, DWORD PTR [eax+ecx+8]
	mov	ecx, DWORD PTR tv743[ebp]
	mov	DWORD PTR [edx+12], eax
$LN10@quad_to_la:

; 168  : 
; 169  :   MFOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR [eax]
	mov	edi, edx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	$LL67@quad_to_la
$LN9@quad_to_la:

; 180  :      }
; 181  :   MFOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+160
	test	eax, 268435456				; 10000000H
	je	$LN4@quad_to_la
	mov	edi, DWORD PTR _web+124
	mov	ebx, 4194304				; 00400000H
$LL6@quad_to_la:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN5@quad_to_la

; 182  :   { v = get_edge_vertices(e_id);

	mov	edx, DWORD PTR _web+216
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax+304]

; 183  :      vv = v[1]; v[1] = v[2]; v[2] = vv; 

	mov	edx, DWORD PTR [eax+ecx+8]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+4], edx

; 184  :      unset_attr(v[1],Q_MIDPOINT);

	mov	ecx, edx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	DWORD PTR [ecx+8], -131073		; fffdffffH
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+12], edx

; 185  :      set_attr(v[1],Q_MIDEDGE);

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ecx
	mov	edi, DWORD PTR _web+124
$LN5@quad_to_la:

; 180  :      }
; 181  :   MFOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	$LL6@quad_to_la
$LN4@quad_to_la:

; 186  :   }
; 187  :   web.headvnum = 2;

	mov	eax, 2

; 188  :   web.modeltype = LAGRANGE;
; 189  :   web.lagrange_order = 2;
; 190  :   dim = (web.representation==STRING)? 1 : web.dimension-1;

	mov	esi, 1
	mov	DWORD PTR _web+636, eax
	mov	DWORD PTR _web+628, 3
	mov	DWORD PTR _web+632, eax
	pop	ebx
	cmp	DWORD PTR _web+624, esi
	je	SHORT $LN20@quad_to_la
	mov	esi, DWORD PTR _web+620
	dec	esi
$LN20@quad_to_la:

; 191  :   adjust_integration_orders(l_order);

	mov	edi, DWORD PTR _l_order$[ebp]
	push	edi
	call	_adjust_integration_orders

; 192  :   gauss_lagrange_setup(web.dimension,web.lagrange_order,web.gauss2D_order);

	mov	eax, DWORD PTR _web+1596
	mov	ecx, DWORD PTR _web+632
	mov	edx, DWORD PTR _web+620
	push	eax
	push	ecx
	push	edx
	call	_gauss_lagrange_setup

; 193  :   gauss_lagrange_setup(dim,web.lagrange_order,web.gauss1D_order);

	mov	eax, DWORD PTR _web+1592
	mov	ecx, DWORD PTR _web+632
	push	eax
	push	ecx
	push	esi
	call	_gauss_lagrange_setup
	add	esp, 28					; 0000001cH

; 194  : 
; 195  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89105[ebp], 0
	je	SHORT $LN1@quad_to_la
	mov	edx, DWORD PTR _graphmutex
	push	edx
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@quad_to_la:

; 196  : 
; 197  :   lagrange_to_lagrange(l_order);

	push	edi
	call	_lagrange_to_lagrange
	add	esp, 4

; 198  :   setup_q_info();

	call	_setup_q_info

; 199  :   recalc();

	call	_recalc
	pop	edi
	pop	esi

; 200  : } // end quad_to_lagrange()

	mov	esp, ebp
	pop	ebp
	ret	0
_quad_to_lagrange ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EK@BJNJDKAO@Vertices?5?$CFs?5and?5?$CFs?5of?5edge?5?$CFs?5ar@ ; `string'
PUBLIC	??_C@_0EA@JIJKBAAF@Do?5convert_to_quantities?5to?5do?5h@ ; `string'
PUBLIC	??_C@_0DG@EALFDPGL@Do?5convert_to_quantities?5for?5qua@ ; `string'
PUBLIC	??_C@_0DL@LNPBGBNB@Do?5convert_to_quantities?5for?5qua@ ; `string'
PUBLIC	??_C@_0DF@PEBHPLEM@Quotient?5spaces?5volume?5needs?5con@ ; `string'
PUBLIC	??_C@_0DA@KAMMBKAM@Cannot?5do?5square?5curvature?5in?5qu@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_linear_to_quad
EXTRN	_edge_force_q:PROC
EXTRN	_edge_energy_q:PROC
EXTRN	_edge_force_q_metric:PROC
EXTRN	_calc_edge_forces:DWORD
EXTRN	_edge_energy_q_metric:PROC
EXTRN	_calc_edge_energy:DWORD
EXTRN	_facet_force_q:PROC
EXTRN	_calc_facet_forces:DWORD
EXTRN	_facet_energy_q:PROC
EXTRN	_calc_facet_energy:DWORD
EXTRN	_string_grad_q:PROC
EXTRN	_string_grad:DWORD
EXTRN	_edge_area_q:PROC
EXTRN	_calc_edge_area:DWORD
EXTRN	_film_grad_q:PROC
EXTRN	_film_grad:DWORD
EXTRN	_facet_volume_q:PROC
EXTRN	_calc_facet_volume:DWORD
EXTRN	_get_edge_side:PROC
EXTRN	_square_curvature_flag:DWORD
;	COMDAT ??_C@_0EK@BJNJDKAO@Vertices?5?$CFs?5and?5?$CFs?5of?5edge?5?$CFs?5ar@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EK@BJNJDKAO@Vertices?5?$CFs?5and?5?$CFs?5of?5edge?5?$CFs?5ar@ DB 'V'
	DB	'ertices %s and %s of edge %s are on different boundaries than'
	DB	' the edge.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@JIJKBAAF@Do?5convert_to_quantities?5to?5do?5h@
CONST	SEGMENT
??_C@_0EA@JIJKBAAF@Do?5convert_to_quantities?5to?5do?5h@ DB 'Do convert_t'
	DB	'o_quantities to do high dimension space quadratic.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@EALFDPGL@Do?5convert_to_quantities?5for?5qua@
CONST	SEGMENT
??_C@_0DG@EALFDPGL@Do?5convert_to_quantities?5for?5qua@ DB 'Do convert_to'
	DB	'_quantities for quadratic metric model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@LNPBGBNB@Do?5convert_to_quantities?5for?5qua@
CONST	SEGMENT
??_C@_0DL@LNPBGBNB@Do?5convert_to_quantities?5for?5qua@ DB 'Do convert_to'
	DB	'_quantities for quadratic SYMMETRIC CONTENT.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PEBHPLEM@Quotient?5spaces?5volume?5needs?5con@
CONST	SEGMENT
??_C@_0DF@PEBHPLEM@Quotient?5spaces?5volume?5needs?5con@ DB 'Quotient spa'
	DB	'ces volume needs convert_to_quantities.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KAMMBKAM@Cannot?5do?5square?5curvature?5in?5qu@
CONST	SEGMENT
??_C@_0DA@KAMMBKAM@Cannot?5do?5square?5curvature?5in?5qu@ DB 'Cannot do s'
	DB	'quare curvature in quadratic model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\model.c
CONST	ENDS
;	COMDAT _linear_to_quad
_TEXT	SEGMENT
tv943 = -156						; size = 8
_new_v$89664 = -152					; size = 4
_three$ = -148						; size = 4
_facet_ctrl$ = -144					; size = 4
tv1033 = -140						; size = 8
_base_v$89685 = -136					; size = 4
tv985 = -132						; size = 4
tv957 = -128						; size = 4
_did_graphlock_here$89647 = -124			; size = 4
tv1020 = -120						; size = 4
_tailv$89663 = -116					; size = 4
tv959 = -112						; size = 4
tv334 = -108						; size = 4
_headv$89662 = -108					; size = 4
tv975 = -104						; size = 4
_bdry$89680 = -104					; size = 4
_x$89660 = -100						; size = 48
_side$89665 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_linear_to_quad PROC					; COMDAT

; 685  : { int three = 3,facet_ctrl = FACET_CTRL;

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 686  :   edge_id e_id;
; 687  :         
; 688  :   if ( web.modeltype == QUADRATIC ) return;

	mov	ebx, 2
	mov	DWORD PTR _three$[ebp], 3
	mov	DWORD PTR _facet_ctrl$[ebp], 6
	cmp	DWORD PTR _web+628, ebx
	je	$LN1@linear_to_@2

; 689  : 
; 690  :   if ( square_curvature_flag )

	cmp	DWORD PTR _square_curvature_flag, 0
	je	SHORT $LN90@linear_to_@2

; 691  :       kb_error(1827,"Cannot do square curvature in quadratic model.\n",
; 692  :             RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DA@KAMMBKAM@Cannot?5do?5square?5curvature?5in?5qu@
	push	1827					; 00000723H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN90@linear_to_@2:

; 693  : 
; 694  :   if ( web.symmetry_flag && (web.skel[BODY].count > web.full_flag) 
; 695  :       && !everything_quantities_flag )

	cmp	DWORD PTR _web+856, 0
	push	esi
	push	edi
	je	$LN89@linear_to_@2
	mov	eax, DWORD PTR _web+400
	cmp	eax, DWORD PTR _web+864
	jle	$LN89@linear_to_@2
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN89@linear_to_@2

; 696  :   { body_id b_id;
; 697  :     FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+384
	test	eax, 268435456				; 10000000H
	je	SHORT $LN89@linear_to_@2
	mov	edi, DWORD PTR _web+348
$LL41@linear_to_@2:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR [esi+edi]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	mov	DWORD PTR tv943[ebp+4], edx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN40@linear_to_@2

; 698  :       if ( get_battr(b_id) & FIXEDVOL )

	and	ecx, 32					; 00000020H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN40@linear_to_@2

; 699  :       { if ( auto_convert_flag ) convert_to_quantities(); else

	cmp	DWORD PTR _auto_convert_flag, eax
	je	SHORT $LN35@linear_to_@2
	call	_convert_to_quantities
	mov	edi, DWORD PTR _web+348
$LN40@linear_to_@2:

; 696  :   { body_id b_id;
; 697  :     FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL41@linear_to_@2
	jmp	SHORT $LN89@linear_to_@2
$LN35@linear_to_@2:

; 700  :         { kb_error(1804,"Quotient spaces volume needs convert_to_quantities.\n",
; 701  :             RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DF@PEBHPLEM@Quotient?5spaces?5volume?5needs?5con@
	push	1804					; 0000070cH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN89@linear_to_@2:

; 702  :           break;
; 703  :         }
; 704  :       }
; 705  :   } 
; 706  : 
; 707  :   if ( web.symmetric_content  && !everything_quantities_flag )

	cmp	DWORD PTR _web+808, 0
	je	SHORT $LN94@linear_to_@2
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN94@linear_to_@2

; 708  :   { if ( auto_convert_flag ) convert_to_quantities(); else

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN32@linear_to_@2
	call	_convert_to_quantities
	jmp	SHORT $LN94@linear_to_@2
$LN32@linear_to_@2:

; 709  :     kb_error(1805,"Do convert_to_quantities for quadratic SYMMETRIC CONTENT.\n",
; 710  :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DL@LNPBGBNB@Do?5convert_to_quantities?5for?5qua@
	push	1805					; 0000070dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN94@linear_to_@2:

; 711  :   }
; 712  : 
; 713  :   if ( web.metric_flag  && !everything_quantities_flag )

	cmp	DWORD PTR _web+1676, 0
	je	SHORT $LN95@linear_to_@2
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN95@linear_to_@2

; 714  :   { if ( auto_convert_flag ) convert_to_quantities(); else

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN29@linear_to_@2
	call	_convert_to_quantities
	jmp	SHORT $LN95@linear_to_@2
$LN29@linear_to_@2:

; 715  :     kb_error(2849,"Do convert_to_quantities for quadratic metric model.\n",
; 716  :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DG@EALFDPGL@Do?5convert_to_quantities?5for?5qua@
	push	2849					; 00000b21H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN95@linear_to_@2:

; 717  :   }
; 718  : 
; 719  :   if ( (SDIM > 3) && !(everything_quantities_flag) )

	cmp	DWORD PTR _web+616, 3
	jle	SHORT $LN96@linear_to_@2
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN96@linear_to_@2

; 720  :   { if ( auto_convert_flag ) convert_to_quantities(); else

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN26@linear_to_@2
	call	_convert_to_quantities
	jmp	SHORT $LN96@linear_to_@2
$LN26@linear_to_@2:

; 721  :      kb_error(1807,"Do convert_to_quantities to do high dimension space quadratic.\n",
; 722  :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EA@JIJKBAAF@Do?5convert_to_quantities?5to?5do?5h@
	push	1807					; 0000070fH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN96@linear_to_@2:

; 723  :   }
; 724  : 
; 725  : #ifdef MPI_EVOLVER
; 726  :   if ( this_task == MASTER_TASK )
; 727  :     mpi_model(2,QUADRATIC);
; 728  : #endif
; 729  : 
; 730  :   ENTER_GRAPH_MUTEX;

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN24@linear_to_@2
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89647[ebp], 1
	jmp	SHORT $LN23@linear_to_@2
$LN24@linear_to_@2:
	mov	DWORD PTR _did_graphlock_here$89647[ebp], 0
$LN23@linear_to_@2:

; 731  :   
; 732  :   expand_attribute(EDGE,E_VERTICES_ATTR,&three);

	lea	ecx, DWORD PTR _three$[ebp]
	push	ecx
	push	1
	push	1
	call	_expand_attribute

; 733  :   expand_attribute(FACET,F_VERTICES_ATTR,&facet_ctrl);

	lea	edx, DWORD PTR _facet_ctrl$[ebp]
	push	edx
	push	1
	push	ebx
	call	_expand_attribute

; 734  :   MFOR_ALL_EDGES(e_id)

	mov	edi, DWORD PTR _web+160
	mov	eax, edi
	shr	eax, 28					; 0000001cH
	add	esp, 24					; 00000018H
	and	eax, 1
	mov	DWORD PTR tv957[ebp], eax
	je	$LN20@linear_to_@2
	mov	ecx, DWORD PTR _web+124
$LL93@linear_to_@2:
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv959[ebp], esi
	je	$LN21@linear_to_@2

; 735  :   { REAL *t,x[MAXCOORD];
; 736  :     int i;
; 737  :     vertex_id headv,tailv;
; 738  :     vertex_id new_v;
; 739  :     REAL side[MAXCOORD];
; 740  : 
; 741  :     headv = get_edge_headv(e_id);

	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [eax+edx+304]
	mov	ebx, edi
	shr	ebx, 27					; 0000001bH
	add	eax, ecx
	and	ebx, 1
	je	SHORT $LN64@linear_to_@2
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN101@linear_to_@2
$LN64@linear_to_@2:
	mov	ecx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [eax+ecx*4]
$LN101@linear_to_@2:
	mov	DWORD PTR _headv$89662[ebp], ecx

; 742  :     tailv = get_edge_tailv(e_id);

	test	ebx, ebx
	je	SHORT $LN68@linear_to_@2
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _tailv$89663[ebp], eax
	jmp	SHORT $LN67@linear_to_@2
$LN68@linear_to_@2:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tailv$89663[ebp], ecx
$LN67@linear_to_@2:

; 743  :     t = get_coord(tailv);

	mov	ecx, DWORD PTR _web+104
	mov	ebx, DWORD PTR [ecx+edx+64]
	mov	eax, DWORD PTR _tailv$89663[ebp]
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	ebx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv985[ebp], eax

; 744  :     get_edge_side(e_id,side);

	lea	eax, DWORD PTR _side$89665[ebp]
	push	eax
	push	edi
	call	_get_edge_side

; 745  :     for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 8
	test	ecx, ecx
	jle	SHORT $LN15@linear_to_@2

; 743  :     t = get_coord(tailv);

	fld	QWORD PTR __real@3fe0000000000000
	mov	eax, ebx

; 745  :     for ( i = 0 ; i < SDIM ; i++ )

	neg	ebx
	lea	edx, DWORD PTR _side$89665[ebp+ebx]
	lea	ebx, DWORD PTR _x$89660[ebp+ebx]
$LN17@linear_to_@2:

; 746  :       x[i] = t[i] + side[i]/2;

	fld	QWORD PTR [edx+eax]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [ebx+eax-8]
	jne	SHORT $LN17@linear_to_@2

; 745  :     for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN15@linear_to_@2:

; 747  : 
; 748  :     new_v = new_vertex(x,e_id);

	lea	ecx, DWORD PTR _x$89660[ebp]
	push	edi
	push	ecx
	call	_new_vertex

; 749  :     set_edge_midv(e_id,new_v);

	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR _web+216
	mov	ebx, eax
	mov	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	DWORD PTR [eax+ecx+8], ebx
	mov	edx, DWORD PTR _web+12
	mov	ecx, ebx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+28], edi
	mov	eax, DWORD PTR _web[ecx+12]
	mov	eax, DWORD PTR [esi+eax]
	or	DWORD PTR [eax+8], 131072		; 00020000H
	lea	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR _global_timestamp

; 750  : 
; 751  :     if ( get_eattr(e_id) & FIXED ) 

	mov	ecx, DWORD PTR _web+124
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	eax, DWORD PTR tv959[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	edi, edi
	add	esp, 8
	or	eax, edi
	mov	DWORD PTR _new_v$89664[ebp], ebx
	mov	DWORD PTR tv1020[ebp], edx
	je	SHORT $LN75@linear_to_@2

; 752  :          set_attr(new_v,FIXED);

	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [esi+ecx]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _web+124
$LN75@linear_to_@2:

; 753  : 
; 754  :     /* for boundary edges, cannot just interpolate parameters
; 755  :        due to wrap-around of angular parameters. So tangent extrapolate
; 756  :        from one endpoint.
; 757  :     */
; 758  :     if ( get_eattr(e_id) & BOUNDARY )

	mov	eax, DWORD PTR tv959[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR tv975[ebp], eax
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv1033[ebp+4], eax
	mov	eax, edx
	and	eax, 128				; 00000080H
	xor	edi, edi
	or	eax, edi
	je	$LN13@linear_to_@2

; 759  :     { struct boundary *bdry;
; 760  :       REAL *paramb,*parammid,*mu,*mv;
; 761  :       vertex_id base_v = NULLID;
; 762  :      
; 763  :       bdry = get_edge_boundary(e_id);

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	mov	edx, DWORD PTR _dymem
	xor	ecx, ecx
	mov	DWORD PTR _base_v$89685[ebp], ecx
	cmp	eax, ecx
	je	SHORT $LN47@linear_to_@2
	mov	edi, DWORD PTR tv975[ebp]
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edi, DWORD PTR [eax+edi]
	imul	edi, 136				; 00000088H
	add	edi, DWORD PTR _web+776
	mov	DWORD PTR _bdry$89680[ebp], edi
	jmp	SHORT $LN48@linear_to_@2
$LN47@linear_to_@2:
	mov	DWORD PTR _bdry$89680[ebp], ecx
	mov	edi, ecx
$LN48@linear_to_@2:

; 764  :       
; 765  :       if ( get_boundary(tailv) == bdry )

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	mov	ebx, DWORD PTR _web+12
	cmp	eax, ecx
	je	SHORT $LN49@linear_to_@2
	mov	edi, DWORD PTR tv985[ebp]
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	ecx, eax
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+edx+64]
	mov	ecx, DWORD PTR [ecx+edi]
	mov	edi, DWORD PTR _bdry$89680[ebp]
	imul	ecx, 136				; 00000088H
	add	ecx, DWORD PTR _web+776
	jmp	SHORT $LN50@linear_to_@2
$LN49@linear_to_@2:
	xor	ecx, ecx
$LN50@linear_to_@2:
	cmp	ecx, edi
	jne	SHORT $LN12@linear_to_@2

; 766  :           base_v = tailv;

	mov	edx, DWORD PTR _tailv$89663[ebp]
	mov	DWORD PTR _base_v$89685[ebp], edx
	jmp	$LN6@linear_to_@2
$LN12@linear_to_@2:

; 767  :       else if ( get_boundary(headv) == bdry )

	mov	edi, DWORD PTR _headv$89662[ebp]
	test	eax, eax
	je	SHORT $LN51@linear_to_@2
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	ecx, edi
	mov	eax, DWORD PTR [eax+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN52@linear_to_@2
$LN51@linear_to_@2:
	xor	eax, eax
$LN52@linear_to_@2:
	cmp	eax, DWORD PTR _bdry$89680[ebp]
	jne	SHORT $LN10@linear_to_@2

; 768  :       {  t = get_coord(headv);  // patch up mid x, in case of torus wrap

	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	ecx, DWORD PTR [eax+edx+64]

; 769  :          for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN7@linear_to_@2
	fld	QWORD PTR __real@3fe0000000000000
	mov	ebx, ecx
	lea	ecx, DWORD PTR _side$89665[ebp]
	sub	ebx, ecx
$LN9@linear_to_@2:

; 770  :             x[i] = t[i] - side[i]/2;

	fld	QWORD PTR _side$89665[ebp+eax*8]
	lea	ecx, DWORD PTR _side$89665[ebp+eax*8]
	fmul	ST(0), ST(1)
	inc	eax
	fsubr	QWORD PTR [ecx+ebx]
	fstp	QWORD PTR _x$89660[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LN9@linear_to_@2

; 769  :          for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN7@linear_to_@2:

; 771  :          base_v = headv;

	mov	DWORD PTR _base_v$89685[ebp], edi

; 772  :       }
; 773  :       else

	jmp	$LN102@linear_to_@2
$LN10@linear_to_@2:

; 774  :          { sprintf(errmsg,
; 775  :   "Vertices %s and %s of edge %s are on different boundaries than the edge.\n",
; 776  :               ELNAME(headv),ELNAME1(tailv),ELNAME2(e_id)+1);

	cmp	DWORD PTR tv957[ebp], 0
	je	SHORT $LN53@linear_to_@2
	mov	edx, DWORD PTR tv959[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv334[ebp], OFFSET _elnames+60
	jmp	SHORT $LN54@linear_to_@2
$LN53@linear_to_@2:
	mov	DWORD PTR tv334[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN54@linear_to_@2:
	test	DWORD PTR _tailv$89663[ebp], 268435456	; 10000000H
	je	SHORT $LN55@linear_to_@2
	mov	eax, DWORD PTR tv985[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	ebx, OFFSET _elnames+30
	jmp	SHORT $LN56@linear_to_@2
$LN55@linear_to_@2:
	mov	ebx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN56@linear_to_@2:
	test	edi, 268435456				; 10000000H
	je	SHORT $LN57@linear_to_@2
	and	edi, 134217727				; 07ffffffH
	inc	edi
	push	edi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN58@linear_to_@2
$LN57@linear_to_@2:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN58@linear_to_@2:
	mov	ecx, DWORD PTR tv334[ebp]
	inc	ecx
	push	ecx
	push	ebx
	push	eax
	push	OFFSET ??_C@_0EK@BJNJDKAO@Vertices?5?$CFs?5and?5?$CFs?5of?5edge?5?$CFs?5ar@
	push	OFFSET _errmsg
	call	_sprintf

; 777  :            kb_error(1808,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1808					; 00000710H
	call	_kb_error
	add	esp, 32					; 00000020H
$LN102@linear_to_@2:
	mov	edi, DWORD PTR _bdry$89680[ebp]
$LN6@linear_to_@2:

; 778  :          }
; 779  : 
; 780  :       set_attr(new_v,BOUNDARY);

	mov	edx, DWORD PTR tv1020[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [esi+eax]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 128			; 00000080H
	mov	DWORD PTR [eax+12], ecx

; 781  :       set_boundary_num(new_v,bdry->num);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN59@linear_to_@2
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edx, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR [edi+44]
	mov	DWORD PTR [eax+edx], ecx
$LN59@linear_to_@2:

; 782  :     
; 783  :       /* projecting on tangent */
; 784  :       mv = get_coord(new_v);

	mov	edi, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR [edx+edi+64]

; 785  :       mu = get_coord(base_v);
; 786  :       paramb = get_param(base_v);
; 787  :       parammid = get_param(new_v);

	mov	edx, DWORD PTR [edx+edi+544]
	mov	ebx, DWORD PTR _web+12
	mov	edi, DWORD PTR _base_v$89685[ebp]
	mov	esi, DWORD PTR [esi+ebx]
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]

; 788  :       b_extrapolate(bdry,mu,mv,mv,paramb,parammid,new_v);

	mov	ebx, DWORD PTR _new_v$89664[ebp]
	lea	ecx, DWORD PTR [eax+esi]
	push	ebx
	add	esi, edx
	push	esi
	add	edx, edi
	push	edx
	push	ecx
	push	ecx
	add	edi, eax
	mov	eax, DWORD PTR _bdry$89680[ebp]
	push	edi
	push	eax
	call	_b_extrapolate
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN103@linear_to_@2
$LN13@linear_to_@2:

; 789  : 
; 790  :     }
; 791  :     else if ( get_eattr(e_id) & CONSTRAINT )

	mov	eax, edx
	and	eax, 1024				; 00000400H
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN92@linear_to_@2

; 792  :     { ATTR attr = get_eattr(e_id) & (BDRY_ENERGY|BDRY_CONTENT|CONSTRAINT );
; 793  :       conmap_t * conmap = get_e_constraint_map(e_id);

	mov	eax, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	xor	ecx, ecx
	and	edx, 5632				; 00001600H
	cmp	DWORD PTR [eax+edi+1048], ecx
	je	SHORT $LN61@linear_to_@2
	mov	eax, DWORD PTR [eax+edi+1024]
	add	eax, DWORD PTR tv975[ebp]
	jmp	SHORT $LN62@linear_to_@2
$LN61@linear_to_@2:
	mov	eax, OFFSET _nullcon
$LN62@linear_to_@2:

; 794  :     
; 795  :       set_attr(new_v,attr);

	mov	edi, DWORD PTR tv1020[ebp]
	mov	edi, DWORD PTR [edi]
	mov	esi, DWORD PTR [esi+edi]
	or	DWORD PTR [esi+8], edx
	or	DWORD PTR [esi+12], ecx

; 796  :       set_v_conmap(new_v,conmap);

	push	eax
	push	ebx
	call	_set_v_conmap

; 797  :       project_v_constr(new_v,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	push	1
	push	1
	push	ebx
	call	_project_v_constr
	add	esp, 20					; 00000014H
$LN103@linear_to_@2:
	mov	ecx, DWORD PTR _web+124
$LN92@linear_to_@2:
	mov	esi, DWORD PTR tv959[ebp]
$LN21@linear_to_@2:

; 734  :   MFOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR [ecx+esi*4]
	mov	edi, DWORD PTR [edx]
	mov	eax, edi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv957[ebp], eax
	jne	$LL93@linear_to_@2
	mov	ebx, 2
$LN20@linear_to_@2:

; 798  :     }
; 799  :   }
; 800  : 
; 801  :   web.modeltype = QUADRATIC;
; 802  :   web.lagrange_order = 2;
; 803  :   web.skel[EDGE].ctrlpts = edge_ctrl = 3;
; 804  :   web.skel[FACET].ctrlpts = 6;
; 805  : 
; 806  :   /* redirect functions */
; 807  :   calc_facet_volume = facet_volume_q;
; 808  :   film_grad = film_grad_q;
; 809  :   calc_edge_area = edge_area_q;
; 810  :   string_grad = string_grad_q;
; 811  :   calc_facet_energy = facet_energy_q;
; 812  :   calc_facet_forces = facet_force_q;
; 813  :   if ( web.metric_flag )

	cmp	DWORD PTR _web+1676, 0
	mov	eax, 3
	pop	edi
	mov	DWORD PTR _web+628, ebx
	mov	DWORD PTR _web+632, ebx
	mov	DWORD PTR _edge_ctrl, eax
	mov	DWORD PTR _web+120, eax
	mov	DWORD PTR _web+232, 6
	mov	DWORD PTR _calc_facet_volume, OFFSET _facet_volume_q
	mov	DWORD PTR _film_grad, OFFSET _film_grad_q
	mov	DWORD PTR _calc_edge_area, OFFSET _edge_area_q
	mov	DWORD PTR _string_grad, OFFSET _string_grad_q
	mov	DWORD PTR _calc_facet_energy, OFFSET _facet_energy_q
	mov	DWORD PTR _calc_facet_forces, OFFSET _facet_force_q
	pop	esi
	je	SHORT $LN3@linear_to_@2

; 814  :     {
; 815  :       calc_edge_energy = edge_energy_q_metric;

	mov	DWORD PTR _calc_edge_energy, OFFSET _edge_energy_q_metric

; 816  :       calc_edge_forces  = edge_force_q_metric;

	mov	DWORD PTR _calc_edge_forces, OFFSET _edge_force_q_metric

; 817  :     }
; 818  :   else

	jmp	SHORT $LN2@linear_to_@2
$LN3@linear_to_@2:

; 819  :     {
; 820  :       calc_edge_energy = edge_energy_q;

	mov	DWORD PTR _calc_edge_energy, OFFSET _edge_energy_q

; 821  :       calc_edge_forces  = edge_force_q;

	mov	DWORD PTR _calc_edge_forces, OFFSET _edge_force_q
$LN2@linear_to_@2:

; 822  :     }
; 823  : 
; 824  :   adjust_integration_orders(2);

	push	ebx
	call	_adjust_integration_orders
	add	esp, 4

; 825  :   gauss_setup();    /* set up gaussian integration arrays */

	call	_gauss_setup

; 826  :   change_flag = 1;
; 827  :   web_timestamp = top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _change_flag, 1
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	DWORD PTR _web_timestamp, eax

; 828  :   setup_q_info();

	call	_setup_q_info

; 829  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89647[ebp], 0
	je	SHORT $LN1@linear_to_@2
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@linear_to_@2:

; 830  : 
; 831  : } // end linear_to_quad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_linear_to_quad ENDP
_TEXT	ENDS
PUBLIC	_quad_to_linear
EXTRN	_string_grad_l:PROC
EXTRN	_edge_area_l:PROC
EXTRN	_edge_force_l:PROC
EXTRN	_edge_energy_l:PROC
EXTRN	_edge_force_l_metric:PROC
EXTRN	_edge_energy_l_metric:PROC
EXTRN	_film_grad_l:PROC
EXTRN	_facet_volume_l:PROC
EXTRN	_facet_force_l:PROC
EXTRN	_facet_energy_l:PROC
; Function compile flags: /Ogtp
;	COMDAT _quad_to_linear
_TEXT	SEGMENT
_did_graphlock_here$89761 = -4				; size = 4
_quad_to_linear PROC					; COMDAT

; 843  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 844  :   edge_id e_id;
; 845  : 
; 846  :   if ( web.modeltype == LINEAR ) return;

	mov	ebx, 1
	cmp	DWORD PTR _web+628, ebx
	je	$LN1@quad_to_li

; 847  : 
; 848  : #ifdef MPI_EVOLVER
; 849  :   if ( this_task == MASTER_TASK )
; 850  :     mpi_model(1,LINEAR);
; 851  : #endif
; 852  : 
; 853  :   ENTER_GRAPH_MUTEX;

	push	esi
	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN10@quad_to_li
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	ebx
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89761[ebp], ebx
	jmp	SHORT $LN9@quad_to_li
$LN10@quad_to_li:
	mov	DWORD PTR _did_graphlock_here$89761[ebp], 0
$LN9@quad_to_li:

; 854  :   
; 855  :   MFOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+160
	test	eax, 268435456				; 10000000H
	je	SHORT $LN6@quad_to_li
	push	edi
	mov	edi, DWORD PTR _web+124
$LL8@quad_to_li:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, ebx
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN7@quad_to_li

; 856  :   {
; 857  :      free_element(get_edge_midv(e_id));

	mov	eax, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+304]
	mov	ecx, DWORD PTR [eax+ecx+8]
	push	ecx
	call	_free_element
	mov	edi, DWORD PTR _web+124
	add	esp, 4
$LN7@quad_to_li:

; 854  :   
; 855  :   MFOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL8@quad_to_li
	pop	edi
$LN6@quad_to_li:

; 858  :   }
; 859  : 
; 860  :   web.modeltype = LINEAR;
; 861  :   web.lagrange_order = 1;
; 862  :   calc_facet_energy = facet_energy_l;
; 863  :   calc_facet_forces = facet_force_l;
; 864  :   calc_facet_volume = facet_volume_l;
; 865  :   film_grad = film_grad_l;
; 866  :   if ( web.metric_flag )

	cmp	DWORD PTR _web+1676, 0
	mov	DWORD PTR _web+628, ebx
	mov	DWORD PTR _web+632, ebx
	mov	DWORD PTR _calc_facet_energy, OFFSET _facet_energy_l
	mov	DWORD PTR _calc_facet_forces, OFFSET _facet_force_l
	mov	DWORD PTR _calc_facet_volume, OFFSET _facet_volume_l
	mov	DWORD PTR _film_grad, OFFSET _film_grad_l
	pop	esi
	je	SHORT $LN3@quad_to_li

; 867  :     {
; 868  :       calc_edge_energy = edge_energy_l_metric;

	mov	DWORD PTR _calc_edge_energy, OFFSET _edge_energy_l_metric

; 869  :       calc_edge_forces  = edge_force_l_metric;

	mov	DWORD PTR _calc_edge_forces, OFFSET _edge_force_l_metric

; 870  :     }
; 871  :   else

	jmp	SHORT $LN2@quad_to_li
$LN3@quad_to_li:

; 872  :     {
; 873  :       calc_edge_energy = edge_energy_l;

	mov	DWORD PTR _calc_edge_energy, OFFSET _edge_energy_l

; 874  :       calc_edge_forces  = edge_force_l;

	mov	DWORD PTR _calc_edge_forces, OFFSET _edge_force_l
$LN2@quad_to_li:

; 875  :     }
; 876  :   calc_edge_area = edge_area_l;
; 877  :   string_grad = string_grad_l;
; 878  :   web.skel[EDGE].ctrlpts = edge_ctrl = web.skel[EDGE].dimension+1;

	mov	eax, DWORD PTR _web+116
	inc	eax
	mov	DWORD PTR _edge_ctrl, eax
	mov	DWORD PTR _web+120, eax

; 879  :   web.skel[FACET].ctrlpts = web.skel[FACET].dimension+1;

	mov	eax, DWORD PTR _web+228
	inc	eax

; 880  : 
; 881  :   adjust_integration_orders(1);

	push	ebx
	mov	DWORD PTR _calc_edge_area, OFFSET _edge_area_l
	mov	DWORD PTR _string_grad, OFFSET _string_grad_l
	mov	DWORD PTR _web+232, eax
	call	_adjust_integration_orders
	add	esp, 4

; 882  :   gauss_setup();    /* set up gaussian integration arrays */

	call	_gauss_setup

; 883  :   change_flag = 1;
; 884  :   web_timestamp = top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	eax, ebx
	mov	DWORD PTR _change_flag, ebx
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	DWORD PTR _web_timestamp, eax

; 885  :   setup_q_info();

	call	_setup_q_info

; 886  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89761[ebp], 0
	je	SHORT $LN1@quad_to_li
	mov	ecx, DWORD PTR _graphmutex
	push	ecx
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@quad_to_li:
	pop	ebx

; 887  : } // end quad_to_linear()

	mov	esp, ebp
	pop	ebp
	ret	0
_quad_to_linear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@NHPBNDMO@Current?5model?5type?5is?5LAGRANGE?4?6@ ; `string'
PUBLIC	??_C@_0CC@GKHOPMPO@Current?5model?5type?5is?5QUADRATIC?4@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0DL@FLBCPOBP@Pick?5new?5model?5type?0?51?5LINEAR?0?5?5@ ; `string'
PUBLIC	??_C@_0DF@BIDHAN@Space?5dimension?5?$DO?53?5supported?5on@ ; `string'
PUBLIC	??_C@_0DD@JJNAKHLE@SYMMETRIC?5CONTENT?5supported?5only@ ; `string'
PUBLIC	??_C@_0BP@BGPILHJJ@Current?5model?5type?5is?5LINEAR?4?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_change_model
EXTRN	_fprintf:PROC
EXTRN	_logfd:DWORD
EXTRN	_prompt:PROC
;	COMDAT ??_C@_0CB@NHPBNDMO@Current?5model?5type?5is?5LAGRANGE?4?6@
CONST	SEGMENT
??_C@_0CB@NHPBNDMO@Current?5model?5type?5is?5LAGRANGE?4?6@ DB 'Current mo'
	DB	'del type is LAGRANGE.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GKHOPMPO@Current?5model?5type?5is?5QUADRATIC?4@
CONST	SEGMENT
??_C@_0CC@GKHOPMPO@Current?5model?5type?5is?5QUADRATIC?4@ DB 'Current mod'
	DB	'el type is QUADRATIC.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@FLBCPOBP@Pick?5new?5model?5type?0?51?5LINEAR?0?5?5@
CONST	SEGMENT
??_C@_0DL@FLBCPOBP@Pick?5new?5model?5type?0?51?5LINEAR?0?5?5@ DB 'Pick ne'
	DB	'w model type, 1 LINEAR,  2 QUADRATIC, >2 LAGRANGE: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BIDHAN@Space?5dimension?5?$DO?53?5supported?5on@
CONST	SEGMENT
??_C@_0DF@BIDHAN@Space?5dimension?5?$DO?53?5supported?5on@ DB 'Space dime'
	DB	'nsion > 3 supported only in linear model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JJNAKHLE@SYMMETRIC?5CONTENT?5supported?5only@
CONST	SEGMENT
??_C@_0DD@JJNAKHLE@SYMMETRIC?5CONTENT?5supported?5only@ DB 'SYMMETRIC CON'
	DB	'TENT supported only in linear model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BGPILHJJ@Current?5model?5type?5is?5LINEAR?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@BGPILHJJ@Current?5model?5type?5is?5LINEAR?4?6?$AA@ DB 'Current '
	DB	'model type is LINEAR.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _change_model
_TEXT	SEGMENT
_ans$ = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_change_model PROC					; COMDAT

; 630  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 631  :   char ans[100];
; 632  : 
; 633  :   if ( web.modeltype == LINEAR )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	jne	$LN25@change_mod

; 634  :   { outstring("Current model type is LINEAR.\n");

	push	OFFSET ??_C@_0BP@BGPILHJJ@Current?5model?5type?5is?5LINEAR?4?6?$AA@
	call	_outstring
	add	esp, 4

; 635  :     if ( web.symmetric_content )

	cmp	DWORD PTR _web+808, 0
	je	SHORT $LN24@change_mod

; 636  :     { outstring("SYMMETRIC CONTENT supported only in linear model.\n");

	push	OFFSET ??_C@_0DD@JJNAKHLE@SYMMETRIC?5CONTENT?5supported?5only@
	call	_outstring
	add	esp, 4

; 671  :     }
; 672  :   }
; 673  : } // end change_model())

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@change_mod:

; 637  :       return;
; 638  :     }
; 639  :     if ( SDIM > 3 )

	cmp	DWORD PTR _web+616, 3
	jle	SHORT $LN23@change_mod

; 640  :     { outstring("Space dimension > 3 supported only in linear model.\n");

	push	OFFSET ??_C@_0DF@BIDHAN@Space?5dimension?5?$DO?53?5supported?5on@
	call	_outstring
	add	esp, 4

; 671  :     }
; 672  :   }
; 673  : } // end change_model())

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@change_mod:

; 641  :       return;
; 642  :     }
; 643  :     prompt("Pick new model type, 1 LINEAR,  2 QUADRATIC, >2 LAGRANGE: ",
; 644  :               ans,sizeof(ans));

	push	100					; 00000064H
	lea	eax, DWORD PTR _ans$[ebp]
	push	eax
	push	OFFSET ??_C@_0DL@FLBCPOBP@Pick?5new?5model?5type?0?51?5LINEAR?0?5?5@
	call	_prompt

; 645  :     if ( logfd ) fprintf(logfd,"%s\n",ans);

	mov	eax, DWORD PTR _logfd
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN22@change_mod
	lea	ecx, DWORD PTR _ans$[ebp]
	push	ecx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN22@change_mod:

; 646  :     switch ( ans[0] )

	movsx	ecx, BYTE PTR _ans$[ebp]
	mov	eax, ecx
	sub	eax, 49					; 00000031H
	je	$LN4@change_mod
	dec	eax
	je	SHORT $LN18@change_mod

; 649  :       default : linear_to_lagrange(ans[0]-'0'); break;

	add	ecx, -48				; ffffffd0H
	push	ecx
	call	_linear_to_lagrange
	add	esp, 4

; 671  :     }
; 672  :   }
; 673  : } // end change_model())

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@change_mod:

; 647  :     { case '1': break;
; 648  :       case '2': linear_to_quad(); break;

	call	_linear_to_quad

; 671  :     }
; 672  :   }
; 673  : } // end change_model())

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@change_mod:

; 650  :     }
; 651  :   }
; 652  :   else if ( web.modeltype == QUADRATIC )

	cmp	eax, 2
	jne	SHORT $LN15@change_mod

; 653  :   { outstring("Current model type is QUADRATIC.\n");

	push	OFFSET ??_C@_0CC@GKHOPMPO@Current?5model?5type?5is?5QUADRATIC?4@
	call	_outstring

; 654  :     prompt("Pick new model type, 1 LINEAR,  2 QUADRATIC, >2 LAGRANGE: ",
; 655  :       ans,sizeof(ans));

	push	100					; 00000064H
	lea	edx, DWORD PTR _ans$[ebp]
	push	edx
	push	OFFSET ??_C@_0DL@FLBCPOBP@Pick?5new?5model?5type?0?51?5LINEAR?0?5?5@
	call	_prompt

; 656  :     if ( logfd ) fprintf(logfd,"%s\n",ans);

	mov	eax, DWORD PTR _logfd
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN14@change_mod
	lea	ecx, DWORD PTR _ans$[ebp]
	push	ecx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN14@change_mod:

; 657  :     switch ( ans[0] )

	movsx	ecx, BYTE PTR _ans$[ebp]
	mov	eax, ecx
	sub	eax, 49					; 00000031H
	je	SHORT $LN11@change_mod
	dec	eax
	je	$LN4@change_mod

; 659  :       case '2': break;
; 660  :       default : quad_to_lagrange(ans[0]-'0'); break;

	add	ecx, -48				; ffffffd0H
	push	ecx
	call	_quad_to_lagrange
	add	esp, 4

; 671  :     }
; 672  :   }
; 673  : } // end change_model())

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@change_mod:

; 658  :     { case '1': quad_to_linear(); break;

	call	_quad_to_linear

; 671  :     }
; 672  :   }
; 673  : } // end change_model())

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@change_mod:

; 661  :     }
; 662  :   }
; 663  :   else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	SHORT $LN4@change_mod

; 664  :   { outstring("Current model type is LAGRANGE.\n");

	push	OFFSET ??_C@_0CB@NHPBNDMO@Current?5model?5type?5is?5LAGRANGE?4?6@
	call	_outstring

; 665  :     prompt("Pick new model type, 1 LINEAR,  2 QUADRATIC, >2 LAGRANGE: ",ans,sizeof(ans));

	push	100					; 00000064H
	lea	edx, DWORD PTR _ans$[ebp]
	push	edx
	push	OFFSET ??_C@_0DL@FLBCPOBP@Pick?5new?5model?5type?0?51?5LINEAR?0?5?5@
	call	_prompt

; 666  :     if ( logfd ) fprintf(logfd,"%s\n",ans);

	mov	eax, DWORD PTR _logfd
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN6@change_mod
	lea	ecx, DWORD PTR _ans$[ebp]
	push	ecx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN6@change_mod:

; 667  :     switch ( ans[0] )

	movsx	ecx, BYTE PTR _ans$[ebp]
	mov	eax, ecx
	sub	eax, 49					; 00000031H
	je	SHORT $LN3@change_mod
	dec	eax
	je	SHORT $LN2@change_mod

; 670  :       default : lagrange_to_lagrange(ans[0]-'0'); break;

	add	ecx, -48				; ffffffd0H
	push	ecx
	call	_lagrange_to_lagrange
	add	esp, 4

; 671  :     }
; 672  :   }
; 673  : } // end change_model())

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@change_mod:

; 669  :       case '2': lagrange_to_quad(); break;

	call	_lagrange_to_quad

; 671  :     }
; 672  :   }
; 673  : } // end change_model())

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@change_mod:

; 668  :     { case '1': lagrange_to_linear(); break;

	call	_lagrange_to_linear
$LN4@change_mod:

; 671  :     }
; 672  :   }
; 673  : } // end change_model())

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_change_model ENDP
_TEXT	ENDS
END
