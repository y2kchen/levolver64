; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\KUSNER.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_dimf:DWORD
COMM	_conbasis:DWORD
COMM	_cb_count:DWORD
COMM	_cb_list:DWORD
_DATA	ENDS
PUBLIC	_get_fe_edge
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_kusner_energy
EXTRN	_binary_tree_add:PROC
EXTRN	_dot:PROC
EXTRN	_get_edge_side:PROC
EXTRN	_localbase:DWORD
EXTRN	_square_curvature_param:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\kusner.c
CONST	ENDS
;	COMDAT _kusner_energy
_TEXT	SEGMENT
_a2$ = -204						; size = 8
_modulus$ = -196					; size = 8
_s1s2$ = -188						; size = 8
_s1t2$ = -180						; size = 8
_a1$ = -172						; size = 8
_t2t2$ = -172						; size = 8
_s1s1$ = -164						; size = 8
tv477 = -156						; size = 8
_s2s2$ = -156						; size = 8
_t2$ = -148						; size = 48
_s2$ = -100						; size = 48
_s1$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_kusner_energy PROC					; COMDAT

; 27   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 28   :   REAL s1[MAXCOORD],s2[MAXCOORD],t2[MAXCOORD];
; 29   :   REAL s1s1,s1s2,s1t2,s2s2,t2t2,s2t2;
; 30   :   REAL a1,a2;
; 31   :   REAL det;
; 32   :   facetedge_id fe_s1,fe_s2,fe_t2;
; 33   :   edge_id e_id;
; 34   :   REAL cos_th;    /* cosine of angle between facets */
; 35   :   REAL modulus = 3*globals(square_curvature_param)->value.real;

	mov	eax, DWORD PTR _square_curvature_param
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN9@kusner_ene
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN11@kusner_ene
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN10@kusner_ene
$LN11@kusner_ene:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN9@kusner_ene
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN10@kusner_ene
$LN9@kusner_ene:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN10@kusner_ene:
	fld	QWORD PTR [eax+64]

; 36   : 
; 37   :   FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	fmul	QWORD PTR __real@4008000000000000
	fstp	QWORD PTR _modulus$[ebp]
	test	edx, 268435456				; 10000000H
	je	$LN4@kusner_ene
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _web+124
	npad	3
$LL6@kusner_ene:
	mov	ebx, edx
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+edi]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN5@kusner_ene

; 38   :     {
; 39   :       if ( get_attr(e_id) & FIXED ) continue;

	mov	eax, edx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	eax, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [eax+ebx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	or	eax, esi
	jne	$LN5@kusner_ene

; 40   : 
; 41   :       /* get edge vectors away from tail vertex */
; 42   :       fe_s1 = get_edge_fe(e_id);

	test	ecx, ecx
	je	SHORT $LN15@kusner_ene
$LN16@kusner_ene:
	mov	ecx, DWORD PTR [ecx+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN15@kusner_ene
	xor	ecx, 134217728				; 08000000H
$LN15@kusner_ene:

; 43   :       fe_s2 = get_prev_edge(get_next_facet(fe_s1));

	mov	esi, DWORD PTR _web+460
	mov	edi, ecx
	shr	edi, 27					; 0000001bH
	and	edi, 1
	je	SHORT $LN20@kusner_ene
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN19@kusner_ene
$LN20@kusner_ene:
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [edx+40]
$LN19@kusner_ene:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN24@kusner_ene
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR [eax+32]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN23@kusner_ene
$LN24@kusner_ene:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR [eax+28]
$LN23@kusner_ene:

; 44   :       fe_s2 = inverse_id(fe_s2);

	xor	esi, 134217728				; 08000000H

; 45   :       fe_t2 = get_prev_edge(fe_s1);

	test	edi, edi
	je	SHORT $LN28@kusner_ene
	mov	edi, DWORD PTR [edx+32]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN27@kusner_ene
$LN28@kusner_ene:
	mov	edi, DWORD PTR [edx+28]
$LN27@kusner_ene:

; 46   :       fe_t2 = inverse_id(fe_t2);
; 47   :       get_fe_side(fe_s1,s1);

	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [edx+20]
	lea	eax, DWORD PTR _s1$[ebp]
	push	eax
	push	ecx
	xor	edi, 134217728				; 08000000H
	call	_get_edge_side

; 48   :       get_fe_side(fe_s2,s2);

	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	lea	ecx, DWORD PTR _s2$[ebp]
	push	ecx
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [ecx+20]
	push	esi
	call	_get_edge_side

; 49   :       get_fe_side(fe_t2,t2);

	mov	ecx, DWORD PTR _web+460
	mov	eax, edi
	lea	edx, DWORD PTR _t2$[ebp]
	push	edx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	and	edi, 134217728				; 08000000H
	xor	edi, DWORD PTR [edx+20]
	push	edi
	call	_get_edge_side

; 50   : 
; 51   :       s1s1 = SDIM_dot(s1,s1);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _s1$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _s1s1$[ebp]

; 52   :       s1s2 = SDIM_dot(s1,s2);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _s2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s1$[ebp]
	push	edx
	call	_dot
	fstp	QWORD PTR _s1s2$[ebp]

; 53   :       s1t2 = SDIM_dot(s1,t2);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _t2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s1$[ebp]
	push	edx
	call	_dot
	fstp	QWORD PTR _s1t2$[ebp]

; 54   :       t2t2 = SDIM_dot(t2,t2);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _t2$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _t2t2$[ebp]

; 55   :       s2s2 = SDIM_dot(s2,s2);

	mov	eax, DWORD PTR _web+616
	add	esp, 72					; 00000048H
	push	eax
	lea	ecx, DWORD PTR _s2$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _s2s2$[ebp]

; 56   :       s2t2 = SDIM_dot(s2,t2);
; 57   : 
; 58   :       det = s1s1*t2t2 - s1t2*s1t2;

	fld	QWORD PTR _t2t2$[ebp]
	add	esp, 12					; 0000000cH
	fmul	QWORD PTR _s1s1$[ebp]
	fld	QWORD PTR _s1t2$[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)

; 59   :       a1 = sqrt(det);

	call	__CIsqrt
	fstp	QWORD PTR _a1$[ebp]

; 60   :       det = s1s1*s2s2 - s1s2*s1s2;

	fld	QWORD PTR _s2s2$[ebp]
	fmul	QWORD PTR _s1s1$[ebp]
	fld	QWORD PTR _s1s2$[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)

; 61   :       a2 = sqrt(det);

	call	__CIsqrt
	fstp	QWORD PTR _a2$[ebp]
	mov	eax, DWORD PTR _web+616

; 62   : 
; 63   :       cos_th = (s1s2*s1t2 - s2t2*s1s1)/a1/a2;

	fld	QWORD PTR _s1t2$[ebp]
	fmul	QWORD PTR _s1s2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s2$[ebp]
	fstp	QWORD PTR tv477[ebp]
	push	edx
	call	_dot
	fld	QWORD PTR _s1s1$[ebp]
	fmul	ST(1), ST(0)

; 64   : 
; 65   :       binary_tree_add(web.total_energy_addends,
; 66   :                      modulus*s1s1*(1 - cos_th)/(a1 + a2));

	add	esp, 4
	fld	QWORD PTR tv477[ebp]
	fsubrp	ST(2), ST(0)
	fld	QWORD PTR _a1$[ebp]
	fdiv	ST(2), ST(0)
	fld	QWORD PTR _a2$[ebp]
	fdiv	ST(3), ST(0)
	fld1
	fsubrp	ST(4), ST(0)
	fxch	ST(2)
	fmul	QWORD PTR _modulus$[ebp]
	fmulp	ST(3), ST(0)
	faddp	ST(1), ST(0)
	fdivp	ST(1), ST(0)
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1248
	call	_binary_tree_add
	mov	edi, DWORD PTR _web+124
	add	esp, 12					; 0000000cH
$LN5@kusner_ene:

; 36   : 
; 37   :   FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR [ebx+edi]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	$LL6@kusner_ene
	pop	edi
	pop	esi
	pop	ebx
$LN4@kusner_ene:

; 67   :     }
; 68   : } // end kusner_energy()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_kusner_energy ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_kusner_force
;	COMDAT __real@3fe0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\kusner.c
CONST	ENDS
;	COMDAT _kusner_force
_TEXT	SEGMENT
tv1272 = -620						; size = 8
tv1259 = -612						; size = 8
tv1252 = -604						; size = 8
tv1278 = -596						; size = 8
_modulus$ = -588					; size = 8
tv1232 = -580						; size = 8
_cos_th$ = -572						; size = 8
tv1266 = -564						; size = 8
tv1282 = -556						; size = 8
_t2t2$ = -548						; size = 8
_s2s2$ = -540						; size = 8
tv1242 = -532						; size = 8
_a1$ = -532						; size = 8
tv1258 = -524						; size = 8
_s2t2$ = -524						; size = 8
_s1t2$ = -516						; size = 8
tv1134 = -512						; size = 4
_s1s2$ = -508						; size = 8
tv1141 = -504						; size = 4
tv1131 = -500						; size = 4
_s2f$ = -500						; size = 4
tv1049 = -496						; size = 4
tv1238 = -492						; size = 8
_s1s1$ = -492						; size = 8
tv1147 = -488						; size = 4
_fe_s2$ = -488						; size = 4
_dcosds2$ = -484					; size = 48
_da1dt2$ = -436						; size = 48
_da2ds1$ = -388						; size = 48
_da2ds2$ = -340						; size = 48
_dcosdt2$ = -292					; size = 48
_da1ds1$ = -244						; size = 48
_dcosds1$ = -196					; size = 48
_s2$ = -148						; size = 48
_t2$ = -100						; size = 48
_s1$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_kusner_force PROC					; COMDAT

; 80   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 620				; 0000026cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 81   :   REAL s1[MAXCOORD],s2[MAXCOORD],t2[MAXCOORD];
; 82   :   REAL s1s1,s1s2,s1t2,s2s2,t2t2,s2t2;
; 83   :   REAL a1,a2;
; 84   :   REAL det;
; 85   :   facetedge_id fe_s1,fe_s2,fe_t2;
; 86   :   edge_id e_id;
; 87   :   REAL cos_th;    /* cosine of angle between facets */
; 88   :   REAL *of,*s1f,*s2f,*t2f;  /* vertex force pointers */
; 89   :   REAL dcosds1[MAXCOORD],dcosds2[MAXCOORD],dcosdt2[MAXCOORD];
; 90   :   REAL da1ds1[MAXCOORD], da1dt2[MAXCOORD];
; 91   :   REAL da2ds1[MAXCOORD], da2ds2[MAXCOORD];
; 92   :   int i;
; 93   :   REAL modulus = 3*globals(square_curvature_param)->value.real;

	mov	eax, DWORD PTR _square_curvature_param
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN15@kusner_for
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN17@kusner_for
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN16@kusner_for
$LN17@kusner_for:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN15@kusner_for
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN16@kusner_for
$LN15@kusner_for:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN16@kusner_for:
	fld	QWORD PTR [eax+64]
	push	edi
	fmul	QWORD PTR __real@4008000000000000

; 94   : 
; 95   :   FOR_ALL_EDGES(e_id)

	mov	edi, DWORD PTR _web+160
	fstp	QWORD PTR _modulus$[ebp]
	test	edi, 268435456				; 10000000H
	je	$LN10@kusner_for
	push	ebx
	push	esi
	npad	9
$LL12@kusner_for:
	mov	edx, DWORD PTR _web+124
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv1049[ebp], ecx
	je	$LN11@kusner_for

; 96   :     {
; 97   :       if ( get_attr(e_id) & FIXED ) continue;

	mov	eax, edi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	eax, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	or	eax, esi
	jne	$LN11@kusner_for

; 98   : 
; 99   :       /* get edge vectors away from tail vertex */
; 100  :       fe_s1 = get_edge_fe(e_id);

	test	edx, edx
	je	SHORT $LN23@kusner_for
$LN22@kusner_for:
	mov	edx, DWORD PTR [edx+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN21@kusner_for
	xor	edx, 134217728				; 08000000H
$LN21@kusner_for:
	mov	eax, edx
$LN23@kusner_for:

; 101  :       fe_s2 = get_prev_edge(get_next_facet(fe_s1));

	mov	ebx, DWORD PTR _web+460
	mov	esi, eax
	shr	esi, 27					; 0000001bH
	and	esi, 1
	je	SHORT $LN26@kusner_for
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [edx+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN25@kusner_for
$LN26@kusner_for:
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ecx, DWORD PTR [edx+40]
$LN25@kusner_for:
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN30@kusner_for
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR [ecx+32]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN29@kusner_for
$LN30@kusner_for:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR _fe_s2$[ebp], ecx
	mov	ebx, ecx
$LN29@kusner_for:

; 102  :       fe_s2 = inverse_id(fe_s2);

	xor	ebx, 134217728				; 08000000H
	mov	DWORD PTR _fe_s2$[ebp], ebx

; 103  :       fe_t2 = get_prev_edge(fe_s1);

	test	esi, esi
	je	SHORT $LN34@kusner_for
	mov	esi, DWORD PTR [edx+32]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN33@kusner_for
$LN34@kusner_for:
	mov	esi, DWORD PTR [edx+28]
$LN33@kusner_for:

; 104  :       fe_t2 = inverse_id(fe_t2);
; 105  :       get_fe_side(fe_s1,s1);

	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	lea	ecx, DWORD PTR _s1$[ebp]
	push	ecx
	push	eax
	xor	esi, 134217728				; 08000000H
	call	_get_edge_side

; 106  :       get_fe_side(fe_s2,s2);

	mov	ecx, DWORD PTR _web+460
	mov	eax, DWORD PTR _fe_s2$[ebp]
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	lea	edx, DWORD PTR _s2$[ebp]
	push	edx
	add	ebx, ebx
	mov	edx, DWORD PTR [ebx+ecx]
	mov	ecx, DWORD PTR [edx+20]
	and	eax, 134217728				; 08000000H
	xor	ecx, eax
	push	ecx
	mov	DWORD PTR tv1131[ebp], eax
	call	_get_edge_side

; 107  :       get_fe_side(fe_t2,t2);

	mov	ecx, DWORD PTR _web+460
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	lea	edx, DWORD PTR _t2$[ebp]
	push	edx
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv1134[ebp], eax
	mov	eax, DWORD PTR [edx+20]
	and	esi, 134217728				; 08000000H
	xor	eax, esi
	push	eax
	mov	DWORD PTR tv1141[ebp], esi
	call	_get_edge_side

; 108  :       of = get_force(get_edge_tailv(e_id));

	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	eax, DWORD PTR tv1049[ebp]
	mov	esi, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	eax, DWORD PTR [eax+esi]
	shr	edi, 27					; 0000001bH
	add	eax, ecx
	add	esp, 24					; 00000018H
	and	edi, 1
	mov	DWORD PTR tv1147[ebp], eax
	je	SHORT $LN44@kusner_for
	mov	esi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN43@kusner_for
$LN44@kusner_for:
	mov	eax, DWORD PTR [eax]
$LN43@kusner_for:
	mov	esi, DWORD PTR _web+104
	mov	edx, DWORD PTR [esi+edx+784]
	mov	esi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+eax*4]

; 109  :       s1f = get_force(get_edge_headv(e_id));

	mov	eax, DWORD PTR tv1147[ebp]
	add	esi, edx
	test	edi, edi
	je	SHORT $LN48@kusner_for
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN47@kusner_for
$LN48@kusner_for:
	mov	edi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edi*4]
$LN47@kusner_for:
	mov	edi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+eax*4]

; 110  :       s2f = get_force(get_fe_headv(fe_s2));

	mov	eax, DWORD PTR _web+460
	mov	eax, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [eax+20]
	xor	eax, DWORD PTR tv1131[ebp]
	mov	ebx, DWORD PTR _web+124
	add	edi, edx
	test	eax, 134217728				; 08000000H
	je	SHORT $LN54@kusner_for
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
	jmp	SHORT $LN53@kusner_for
$LN54@kusner_for:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN53@kusner_for:
	mov	ebx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]

; 111  :       t2f = get_force(get_fe_headv(fe_t2));

	mov	ebx, DWORD PTR _web+460
	add	eax, edx
	mov	DWORD PTR _s2f$[ebp], eax
	mov	eax, DWORD PTR tv1134[ebp]
	mov	eax, DWORD PTR [eax+ebx]
	mov	eax, DWORD PTR [eax+20]
	xor	eax, DWORD PTR tv1141[ebp]
	mov	ebx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN60@kusner_for
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
	jmp	SHORT $LN59@kusner_for
$LN60@kusner_for:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN59@kusner_for:
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+eax*4]
	add	ebx, edx

; 112  : 
; 113  : 
; 114  :       s1s1 = SDIM_dot(s1,s1);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _s1$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fstp	QWORD PTR _s1s1$[ebp]

; 115  :       s1s2 = SDIM_dot(s1,s2);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _s2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s1$[ebp]
	push	ecx
	call	_dot
	fstp	QWORD PTR _s1s2$[ebp]

; 116  :       s1t2 = SDIM_dot(s1,t2);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s1$[ebp]
	push	ecx
	call	_dot
	fstp	QWORD PTR _s1t2$[ebp]

; 117  :       t2t2 = SDIM_dot(t2,t2);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fstp	QWORD PTR _t2t2$[ebp]

; 118  :       s2s2 = SDIM_dot(s2,s2);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _s2$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fstp	QWORD PTR _s2s2$[ebp]

; 119  :       s2t2 = SDIM_dot(s2,t2);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s2$[ebp]
	push	ecx
	call	_dot
	fstp	QWORD PTR _s2t2$[ebp]

; 120  : 
; 121  :       det = s1s1*t2t2 - s1t2*s1t2;

	fld	QWORD PTR _t2t2$[ebp]
	add	esp, 72					; 00000048H
	fmul	QWORD PTR _s1s1$[ebp]
	fld	QWORD PTR _s1t2$[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)

; 122  :       a1 = sqrt(det);

	call	__CIsqrt
	fstp	QWORD PTR _a1$[ebp]

; 123  :       det = s1s1*s2s2 - s1s2*s1s2;

	fld	QWORD PTR _s2s2$[ebp]
	fmul	QWORD PTR _s1s1$[ebp]
	fld	QWORD PTR _s1s2$[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)

; 124  :       a2 = sqrt(det);

	call	__CIsqrt

; 125  : 
; 126  :       cos_th = (s1s2*s1t2 - s2t2*s1s1)/a1/a2;

	fld	QWORD PTR _s1t2$[ebp]
	fld	QWORD PTR _s1s2$[ebp]

; 127  : 
; 128  :       /* gradients of various terms */
; 129  :       for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	fmul	ST(0), ST(1)
	fld	QWORD PTR _s2t2$[ebp]
	fld	ST(0)
	fld	QWORD PTR _s1s1$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(3)
	fsubrp	ST(1), ST(0)
	fld	QWORD PTR _a1$[ebp]
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(5)
	fst	QWORD PTR _cos_th$[ebp]
	mov	ecx, DWORD PTR _web+616
	test	ecx, ecx
	jle	$LN73@kusner_for
	fld	QWORD PTR __real@4000000000000000
	fmul	ST(5), ST(0)
	fxch	ST(5)
	fst	QWORD PTR tv1232[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	fdiv	ST(0), ST(3)
	fstp	QWORD PTR tv1238[ebp]
	fld	ST(4)
	fmul	ST(0), ST(6)
	fstp	QWORD PTR tv1242[ebp]
	fld	QWORD PTR _s1s2$[ebp]
	fmul	ST(0), ST(6)
	fstp	QWORD PTR tv1252[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	fdiv	ST(0), ST(7)
	fstp	QWORD PTR tv1258[ebp]
	fxch	ST(3)
	fmul	ST(0), ST(5)
	fstp	QWORD PTR tv1272[ebp]
	fld	ST(0)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR tv1278[ebp]
	fdiv	ST(0), ST(5)
	fstp	QWORD PTR tv1282[ebp]
	jmp	SHORT $LN6@kusner_for
$LN71@kusner_for:
	fld	QWORD PTR tv1232[ebp]
	fld	QWORD PTR __real@4000000000000000
	fxch	ST(3)
$LN6@kusner_for:

; 130  :          { da1ds1[i] = 0.5/a1*(2*s1[i]*t2t2 - 2*s1t2*t2[i]);

	fld	QWORD PTR _s1$[ebp+eax*8]
	inc	eax
	fmulp	ST(4), ST(0)
	cmp	eax, ecx
	fld	ST(3)
	fmul	QWORD PTR _t2t2$[ebp]
	fld	QWORD PTR _t2$[ebp+eax*8-8]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR tv1238[ebp]
	fst	QWORD PTR _da1ds1$[ebp+eax*8-8]

; 131  :             da1dt2[i] = 0.5/a1*(2*s1s1*t2[i] - 2*s1t2*s1[i]);

	fld	QWORD PTR _t2$[ebp+eax*8-8]
	fmul	QWORD PTR tv1242[ebp]
	fld	QWORD PTR _s1$[ebp+eax*8-8]
	fmulp	ST(4), ST(0)
	fsubrp	ST(3), ST(0)
	fxch	ST(2)
	fmul	QWORD PTR tv1238[ebp]
	fst	QWORD PTR _da1dt2$[ebp+eax*8-8]

; 132  :             da2ds1[i] = 0.5/a2*(2*s1[i]*s2s2 - 2*s1s2*s2[i]);

	fxch	ST(4)
	fmul	QWORD PTR _s2s2$[ebp]
	fld	QWORD PTR _s2$[ebp+eax*8-8]
	fld	QWORD PTR tv1252[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(2)
	fsubrp	ST(1), ST(0)
	fmul	QWORD PTR tv1258[ebp]
	fst	QWORD PTR tv1259[ebp]
	fstp	QWORD PTR _da2ds1$[ebp+eax*8-8]

; 133  :             da2ds2[i] = 0.5/a2*(2*s1s1*s2[i] - 2*s1s2*s1[i]);

	fld	QWORD PTR _s2$[ebp+eax*8-8]
	fmul	QWORD PTR tv1242[ebp]
	fld	QWORD PTR _s1$[ebp+eax*8-8]
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	fmul	QWORD PTR tv1258[ebp]
	fst	QWORD PTR tv1266[ebp]
	fstp	QWORD PTR _da2ds2$[ebp+eax*8-8]

; 134  :             dcosds1[i] = (s2[i]*s1t2 + s1s2*t2[i] - 2*s2t2*s1[i])/a1/a2
; 135  :                             - cos_th/a1*da1ds1[i] - cos_th/a2*da2ds1[i];

	fld	QWORD PTR _s2$[ebp+eax*8-8]
	fmul	QWORD PTR _s1t2$[ebp]
	fld	QWORD PTR _t2$[ebp+eax*8-8]
	fmul	QWORD PTR _s1s2$[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _s1$[ebp+eax*8-8]
	fmul	QWORD PTR tv1272[ebp]
	fsubp	ST(1), ST(0)
	fdiv	ST(0), ST(1)
	fdiv	ST(0), ST(5)
	fld	QWORD PTR tv1278[ebp]
	fld	ST(0)
	fmulp	ST(4), ST(0)
	fxch	ST(1)
	fsubrp	ST(3), ST(0)
	fld	QWORD PTR tv1282[ebp]
	fld	QWORD PTR tv1259[ebp]
	fmul	ST(0), ST(1)
	fsubp	ST(4), ST(0)
	fxch	ST(3)
	fstp	QWORD PTR _dcosds1$[ebp+eax*8-8]

; 136  :             dcosdt2[i] = (s1s2*s1[i] - s2[i]*s1s1)/a1/a2
; 137  :                             - cos_th/a1*da1dt2[i];

	fld	QWORD PTR _s1$[ebp+eax*8-8]
	fmul	QWORD PTR _s1s2$[ebp]
	fld	QWORD PTR _s2$[ebp+eax*8-8]
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fdiv	ST(0), ST(2)
	fdiv	ST(0), ST(6)
	fxch	ST(1)
	fmulp	ST(5), ST(0)
	fsubrp	ST(4), ST(0)
	fxch	ST(3)
	fstp	QWORD PTR _dcosdt2$[ebp+eax*8-8]

; 138  :             dcosds2[i] = (s1[i]*s1t2 - t2[i]*s1s1)/a1/a2
; 139  :                             - cos_th/a2*da2ds2[i];

	fld	QWORD PTR _s1$[ebp+eax*8-8]
	fmul	QWORD PTR _s1t2$[ebp]
	fld	QWORD PTR _t2$[ebp+eax*8-8]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(4)
	fxch	ST(1)
	fmul	QWORD PTR tv1266[ebp]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _dcosds2$[ebp+eax*8-8]

; 127  : 
; 128  :       /* gradients of various terms */
; 129  :       for ( i = 0 ; i < SDIM ; i++ )

	jl	$LN71@kusner_for
	fld	QWORD PTR _cos_th$[ebp]
	fxch	ST(2)
$LN70@kusner_for:

; 140  :          }
; 141  : 
; 142  :       for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	test	ecx, ecx
	jle	$LN82@kusner_for
	fld	QWORD PTR _modulus$[ebp]
	fld	ST(0)
	fadd	ST(0), ST(1)
	fld1
	fsubrp	ST(5), ST(0)
	fxch	ST(3)
	fmulp	ST(1), ST(0)
	fxch	ST(4)
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmul	ST(0), ST(3)
	fdiv	ST(0), ST(1)
	fdiv	ST(0), ST(1)
$LN3@kusner_for:

; 143  :          { REAL f;  /* part of force */
; 144  : 
; 145  :             f = modulus*2*s1[i]*(1 - cos_th)/(a1 + a2);

	fld	QWORD PTR _s1$[ebp+eax*8]

; 146  :             s1f[i] -= f;
; 147  :             of[i]  += f;
; 148  : 
; 149  :             f = -modulus*s1s1*dcosds1[i]/(a1 + a2);
; 150  :             s1f[i] -= f;
; 151  :             of[i]  += f;
; 152  : 
; 153  :             f = -modulus*s1s1*(1 - cos_th)/(a1 + a2)/(a1 + a2)*da1ds1[i];
; 154  :             s1f[i] -= f;
; 155  :             of[i]  += f;
; 156  : 
; 157  :             f = -modulus*s1s1*(1 - cos_th)/(a1 + a2)/(a1 + a2)*da2ds1[i];
; 158  :             s1f[i] -= f;
; 159  :             of[i]  += f;
; 160  : 
; 161  :             f = -modulus*s1s1*dcosds2[i]/(a1 + a2);
; 162  :             s2f[i] -= f;

	mov	ecx, DWORD PTR _s2f$[ebp]
	fmul	ST(0), ST(3)
	inc	eax
	fmul	ST(0), ST(4)
	fdiv	ST(0), ST(2)
	fld	QWORD PTR [edi+eax*8-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edi+eax*8-8]
	fadd	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]
	fld	QWORD PTR _dcosds1$[ebp+eax*8-8]
	fmul	ST(0), ST(5)
	fdiv	ST(0), ST(2)
	fchs
	fld	QWORD PTR [edi+eax*8-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edi+eax*8-8]
	fadd	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]
	fld	QWORD PTR _da1ds1$[ebp+eax*8-8]
	fmul	ST(0), ST(1)
	fchs
	fld	QWORD PTR [edi+eax*8-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edi+eax*8-8]
	fadd	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]
	fld	QWORD PTR _da2ds1$[ebp+eax*8-8]
	fmul	ST(0), ST(1)
	fchs
	fld	QWORD PTR [edi+eax*8-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edi+eax*8-8]
	fadd	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]
	fld	QWORD PTR _dcosds2$[ebp+eax*8-8]
	fmul	ST(0), ST(5)
	fdiv	ST(0), ST(2)
	fchs
	fld	QWORD PTR [ecx+eax*8-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [ecx+eax*8-8]

; 163  :             of[i]  += f;

	fadd	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]

; 164  : 
; 165  :             f = -modulus*s1s1*(1 - cos_th)/(a1 + a2)/(a1 + a2)*da2ds2[i];

	fld	QWORD PTR _da2ds2$[ebp+eax*8-8]
	fmul	ST(0), ST(1)
	fchs

; 166  :             s2f[i] -= f;

	fld	QWORD PTR [ecx+eax*8-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [ecx+eax*8-8]

; 167  :             of[i]  += f;

	fadd	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]

; 168  : 
; 169  :             f = -modulus*s1s1*dcosdt2[i]/(a1 + a2);

	fld	QWORD PTR _dcosdt2$[ebp+eax*8-8]
	fmul	ST(0), ST(5)
	fdiv	ST(0), ST(2)
	fchs

; 170  :             t2f[i] -= f;

	fld	QWORD PTR [ebx+eax*8-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [ebx+eax*8-8]

; 171  :             of[i]  += f;

	fadd	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]

; 172  : 
; 173  :             f = -modulus*s1s1*(1 - cos_th)/(a1 + a2)/(a1 + a2)*da1dt2[i];

	fld	QWORD PTR _da1dt2$[ebp+eax*8-8]
	fmul	ST(0), ST(1)
	fchs

; 174  :             t2f[i] -= f;

	fld	QWORD PTR [ebx+eax*8-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [ebx+eax*8-8]

; 175  :             of[i]  += f;

	fadd	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	$LN3@kusner_for

; 140  :          }
; 141  : 
; 142  :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(1)
	fstp	ST(0)
	fstp	ST(2)
	fstp	ST(0)
	jmp	SHORT $LN87@kusner_for
$LN73@kusner_for:

; 127  : 
; 128  :       /* gradients of various terms */
; 129  :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(4)
	fstp	ST(1)
	jmp	$LN70@kusner_for
$LN82@kusner_for:

; 140  :          }
; 141  : 
; 142  :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
	fstp	ST(2)
	fstp	ST(1)
$LN87@kusner_for:
	mov	ecx, DWORD PTR tv1049[ebp]
	fstp	ST(0)
$LN11@kusner_for:

; 94   : 
; 95   :   FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [ecx+edx]
	mov	edi, DWORD PTR [eax]
	test	edi, 268435456				; 10000000H
	jne	$LL12@kusner_for
	pop	esi
	pop	ebx
$LN10@kusner_for:

; 176  :          }
; 177  :     }
; 178  : } // end kusner_force()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_kusner_force ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EA@GKBFBJOM@Internal?5error?3?5approx_curvature@ ; `string'
PUBLIC	__real@4028000000000000
PUBLIC	??_C@_08GHAIHECD@KUSNER?4C?$AA@			; `string'
PUBLIC	_approx_curvature
EXTRN	_temp_free:PROC
EXTRN	_sdrv_flag_check:PROC
EXTRN	_sdrvmd_:PROC
EXTRN	_odrv_flag_check:PROC
EXTRN	_odrv_:PROC
EXTRN	_kb_error:PROC
EXTRN	_recalc_facet_area:PROC
EXTRN	_kb_temp_calloc:PROC
;	COMDAT ??_C@_0EA@GKBFBJOM@Internal?5error?3?5approx_curvature@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EA@GKBFBJOM@Internal?5error?3?5approx_curvature@ DB 'Internal erro'
	DB	'r: approx_curvature: cannot find edge in JA list.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4028000000000000
CONST	SEGMENT
__real@4028000000000000 DQ 04028000000000000r	; 12
CONST	ENDS
;	COMDAT ??_C@_08GHAIHECD@KUSNER?4C?$AA@
CONST	SEGMENT
??_C@_08GHAIHECD@KUSNER?4C?$AA@ DB 'KUSNER.C', 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\kusner.c
CONST	ENDS
;	COMDAT _approx_curvature
_TEXT	SEGMENT
_EMAX$ = -72						; size = 8
_area1$89456 = -64					; size = 8
tv1226 = -56						; size = 4
_ISP$ = -52						; size = 4
_ESP$ = -48						; size = 4
_NSP$ = -44						; size = 4
_P$ = -40						; size = 4
_IP$ = -36						; size = 4
_j$ = -32						; size = 4
_tail$89449 = -32					; size = 4
_B$ = -28						; size = 4
_JA$ = -24						; size = 4
_FLAG$ = -20						; size = 4
_PATH$ = -16						; size = 4
_A$ = -12						; size = 4
_IA$ = -8						; size = 4
_N$ = -4						; size = 4
_approx_curvature PROC					; COMDAT

; 208  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 209  :   integer *IA, *JA, *P, *IP, NSP, *ISP;
; 210  :   doublereal *A;
; 211  :   integer i,j, PATH, FLAG;
; 212  :   integer count;
; 213  :   doublereal *B;
; 214  :   REAL *RSP;
; 215  :   integer ESP;
; 216  :   REAL EMAX;
; 217  :   integer N = web.skel[VERTEX].max_ord+1;

	mov	eax, DWORD PTR _web+68
	push	ebx
	push	esi

; 218  :   int Total_entries = web.skel[VERTEX].count + web.skel[EDGE].count;

	mov	esi, DWORD PTR _web+176
	add	esi, DWORD PTR _web+64
	push	edi

; 219  :   edge_id e_id;
; 220  : 
; 221  :   /* allocate storage for arrays to be passed to ysmp */
; 222  :   IA = (integer *)temp_calloc(N+1,sizeof(integer));

	push	222					; 000000deH
	inc	eax
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	mov	DWORD PTR _N$[ebp], eax
	inc	eax
	push	4
	push	eax
	call	_kb_temp_calloc

; 223  :   JA = (integer *)temp_calloc(Total_entries,sizeof(integer));

	push	223					; 000000dfH
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	mov	ebx, eax
	push	4
	push	esi
	mov	DWORD PTR _IA$[ebp], ebx
	call	_kb_temp_calloc

; 224  :   A = (REAL *)temp_calloc(Total_entries,sizeof(REAL));

	push	224					; 000000e0H
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	push	8
	push	esi
	mov	DWORD PTR _JA$[ebp], eax
	call	_kb_temp_calloc

; 225  :   P = (integer *)temp_calloc(N,sizeof(integer));

	push	225					; 000000e1H
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	mov	DWORD PTR _A$[ebp], eax
	mov	eax, DWORD PTR _N$[ebp]
	push	4
	push	eax
	call	_kb_temp_calloc

; 226  :   IP = (integer *)temp_calloc(N,sizeof(integer));

	mov	ecx, DWORD PTR _N$[ebp]
	add	esp, 64					; 00000040H
	push	226					; 000000e2H
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	push	4
	push	ecx
	mov	DWORD PTR _P$[ebp], eax
	call	_kb_temp_calloc

; 227  :   NSP = 8*N + 16*Total_entries;

	mov	edx, DWORD PTR _N$[ebp]
	mov	DWORD PTR _IP$[ebp], eax
	lea	eax, DWORD PTR [edx+esi*2]
	add	eax, eax

; 228  :   ISP = (integer *)temp_calloc(NSP,sizeof(integer));

	push	228					; 000000e4H
	add	eax, eax
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	add	eax, eax
	push	4
	push	eax
	mov	DWORD PTR _NSP$[ebp], eax
	call	_kb_temp_calloc

; 229  :   B  = (REAL *)temp_calloc(N,sizeof(REAL));  

	push	229					; 000000e5H
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	mov	DWORD PTR _ISP$[ebp], eax
	mov	eax, DWORD PTR _N$[ebp]
	push	8
	push	eax
	call	_kb_temp_calloc

; 230  : 
; 231  :   /* count entries needed for each row */
; 232  :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+160
	add	esp, 48					; 00000030H
	mov	DWORD PTR _B$[ebp], eax
	test	ecx, 268435456				; 10000000H
	je	$LN34@approx_cur
	npad	12
$LL36@approx_cur:
	mov	edx, DWORD PTR _web+124
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN35@approx_cur

; 233  :     {
; 234  :       int tail = loc_ordinal(get_edge_tailv(e_id));

	mov	eax, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edi+304]
	shr	ecx, 27					; 0000001bH
	mov	ebx, ecx
	and	ebx, 1
	mov	ecx, DWORD PTR _web+636
	je	SHORT $LN52@approx_cur
	add	eax, edx
	mov	edx, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN51@approx_cur
$LN52@approx_cur:
	add	eax, edx
	mov	edx, DWORD PTR [eax]
$LN51@approx_cur:
	test	edx, 268435456				; 10000000H
	je	SHORT $LN39@approx_cur
	test	ebx, ebx
	je	SHORT $LN56@approx_cur
	mov	edx, DWORD PTR [eax+ecx*4]
	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN40@approx_cur
$LN56@approx_cur:
	mov	edx, DWORD PTR [eax]
	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN40@approx_cur
$LN39@approx_cur:
	or	edx, -1
$LN40@approx_cur:

; 235  :       int head = loc_ordinal(get_edge_headv(e_id));

	test	ebx, ebx
	je	SHORT $LN60@approx_cur
	mov	edi, DWORD PTR [eax]
	jmp	SHORT $LN59@approx_cur
$LN60@approx_cur:
	mov	edi, DWORD PTR [eax+ecx*4]
$LN59@approx_cur:
	test	edi, 268435456				; 10000000H
	je	SHORT $LN41@approx_cur
	test	ebx, ebx
	je	SHORT $LN64@approx_cur
	mov	eax, DWORD PTR [eax]
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN42@approx_cur
$LN64@approx_cur:
	mov	eax, DWORD PTR [eax+ecx*4]
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN42@approx_cur
$LN41@approx_cur:
	or	eax, -1
$LN42@approx_cur:

; 236  :       if ( tail > head ) IA[head]++;

	cmp	edx, eax
	jle	SHORT $LN31@approx_cur
	mov	ecx, DWORD PTR _IA$[ebp]
	inc	DWORD PTR [ecx+eax*4]
	mov	ebx, ecx
	jmp	SHORT $LN35@approx_cur
$LN31@approx_cur:

; 237  :       else IA[tail]++;

	mov	eax, DWORD PTR _IA$[ebp]
	inc	DWORD PTR [eax+edx*4]
	mov	ebx, eax
$LN35@approx_cur:

; 230  : 
; 231  :   /* count entries needed for each row */
; 232  :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR [edx]
	test	ecx, 268435456				; 10000000H
	jne	$LL36@approx_cur
$LN34@approx_cur:

; 238  :     }
; 239  :   /* set up IA pointers */
; 240  :   count = 0;
; 241  :   for ( i = 0 ; i < N ; i++ )

	mov	ecx, DWORD PTR _N$[ebp]
	xor	edx, edx
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN27@approx_cur
	mov	esi, DWORD PTR _JA$[ebp]
	npad	2
$LL29@approx_cur:

; 242  :     { int temp = IA[i] + 1;  /* include diagonal element */

	mov	ecx, DWORD PTR [ebx+eax*4]
	inc	ecx

; 243  :       IA[i] = count + 1;  /* FORTRAN indexing */

	lea	edi, DWORD PTR [edx+1]
	mov	DWORD PTR [ebx+eax*4], edi

; 244  :       count += temp;

	add	edx, ecx

; 245  :       JA[IA[i]-1] = i+1;  /* diagonal */

	lea	ecx, DWORD PTR [eax+1]
	mov	eax, edi
	mov	DWORD PTR [esi+eax*4-4], ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR _N$[ebp]
	cmp	eax, ecx
	jl	SHORT $LL29@approx_cur
$LN27@approx_cur:

; 246  :     }
; 247  :   IA[N] = count + 1;

	inc	edx
	mov	DWORD PTR [ebx+ecx*4], edx

; 248  : 
; 249  :   /* set up JA column index list for off diagonal */
; 250  :   /* and fill in facet star areas */
; 251  :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+160
	test	ecx, 268435456				; 10000000H
	je	$LN24@approx_cur
	npad	12
$LL26@approx_cur:
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	esi, DWORD PTR [eax+edx]
	mov	DWORD PTR tv1226[ebp], eax
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN25@approx_cur

; 252  :     {
; 253  :       int tail = loc_ordinal(get_edge_tailv(e_id));

	mov	edi, DWORD PTR _web+636
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	je	SHORT $LN68@approx_cur
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edx+304]
	add	eax, esi
	mov	edx, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN67@approx_cur
$LN68@approx_cur:
	mov	edx, DWORD PTR _web+216
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax+304]
	mov	edx, DWORD PTR [eax+esi]
	add	eax, esi
$LN67@approx_cur:
	test	edx, 268435456				; 10000000H
	je	SHORT $LN43@approx_cur
	test	ecx, ecx
	je	SHORT $LN72@approx_cur
	mov	edx, DWORD PTR [eax+edi*4]
	and	edx, 134217727				; 07ffffffH
	mov	DWORD PTR _tail$89449[ebp], edx
	jmp	SHORT $LN44@approx_cur
$LN72@approx_cur:
	mov	edx, DWORD PTR [eax]
	and	edx, 134217727				; 07ffffffH
	mov	DWORD PTR _tail$89449[ebp], edx
	jmp	SHORT $LN44@approx_cur
$LN43@approx_cur:
	mov	DWORD PTR _tail$89449[ebp], -1
$LN44@approx_cur:

; 254  :       int head = loc_ordinal(get_edge_headv(e_id));

	test	ecx, ecx
	je	SHORT $LN76@approx_cur
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN75@approx_cur
$LN76@approx_cur:
	mov	edx, DWORD PTR [eax+edi*4]
$LN75@approx_cur:
	test	edx, 268435456				; 10000000H
	je	SHORT $LN45@approx_cur
	test	ecx, ecx
	je	SHORT $LN80@approx_cur
	mov	eax, DWORD PTR [eax]
	and	eax, 134217727				; 07ffffffH
	mov	ebx, eax
	jmp	SHORT $LN46@approx_cur
$LN80@approx_cur:
	mov	eax, DWORD PTR [eax+edi*4]
	and	eax, 134217727				; 07ffffffH
	mov	ebx, eax
	jmp	SHORT $LN46@approx_cur
$LN45@approx_cur:
	or	ebx, -1
$LN46@approx_cur:

; 255  :       facetedge_id fe = get_edge_fe(e_id);

	test	esi, esi
	je	SHORT $LN128@approx_cur
$LN84@approx_cur:
	mov	esi, DWORD PTR [esi+28]
	test	ecx, ecx
	je	SHORT $LN128@approx_cur
	xor	esi, 134217728				; 08000000H
$LN128@approx_cur:

; 256  :       REAL area1 = get_facet_area(get_fe_facet(fe));

	mov	edi, esi
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	SHORT $LN88@approx_cur
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN87@approx_cur
$LN88@approx_cur:
	mov	ecx, DWORD PTR _web+460
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN87@approx_cur
	xor	eax, 134217728				; 08000000H
$LN87@approx_cur:
	push	eax
	call	_recalc_facet_area
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR _NULLFACET
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN92@approx_cur
	mov	eax, edx
	jmp	SHORT $LN91@approx_cur
$LN92@approx_cur:
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN91@approx_cur
	xor	eax, 134217728				; 08000000H
$LN91@approx_cur:
	mov	edi, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [eax+40]
	fstp	QWORD PTR _area1$89456[ebp]

; 257  :       REAL area2;
; 258  :       int base,addend;
; 259  :       fe = get_next_facet(fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN96@approx_cur
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [eax+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN95@approx_cur
$LN96@approx_cur:
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [eax+40]
$LN95@approx_cur:

; 260  :       area2 = get_facet_area(get_fe_facet(fe));

	mov	edi, esi
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	SHORT $LN100@approx_cur
	mov	eax, edx
	jmp	SHORT $LN99@approx_cur
$LN100@approx_cur:
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [eax+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN99@approx_cur
	xor	eax, 134217728				; 08000000H
$LN99@approx_cur:
	push	eax
	call	_recalc_facet_area
	add	esp, 4
	test	edi, edi
	jne	SHORT $LN104@approx_cur
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN103@approx_cur
$LN104@approx_cur:
	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN103@approx_cur
	xor	eax, 134217728				; 08000000H
$LN103@approx_cur:
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]

; 261  :       
; 262  :       /* add to vertex stars */
; 263  :       A[IA[tail]-1] += (area1 + area2)/12;  /* each area will be added twice */

	mov	edi, DWORD PTR _IA$[ebp]
	fadd	QWORD PTR _area1$89456[ebp]
	mov	edx, DWORD PTR _tail$89449[ebp]
	mov	eax, DWORD PTR [edi+edx*4]
	mov	ecx, DWORD PTR _A$[ebp]
	fdiv	QWORD PTR __real@4028000000000000
	lea	eax, DWORD PTR [ecx+eax*8-8]
	fld	ST(0)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 264  :       A[IA[head]-1] += (area1 + area2)/12;  /* each area will be added twice */

	mov	eax, DWORD PTR [edi+ebx*4]
	lea	eax, DWORD PTR [ecx+eax*8-8]
	fld	ST(0)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 265  : 
; 266  :       if ( tail > head ) { base = head; addend = tail; }

	cmp	edx, ebx
	jle	SHORT $LN21@approx_cur
	mov	ecx, ebx
	jmp	SHORT $LN20@approx_cur
$LN21@approx_cur:

; 267  :       else { base = tail; addend = head; }

	mov	ecx, edx
	mov	edx, ebx
$LN20@approx_cur:

; 268  :       /* seek column, add if not already there */
; 269  :       for ( j = IA[base]-1 ; j < IA[base+1]-1 ; j++ )

	mov	eax, DWORD PTR [edi+ecx*4]
	lea	edi, DWORD PTR [edi+ecx*4+4]
	mov	ecx, DWORD PTR [edi]
	dec	eax
	dec	ecx
	cmp	eax, ecx
	jge	SHORT $LN135@approx_cur
	mov	ebx, DWORD PTR _JA$[ebp]
	lea	esi, DWORD PTR [edx+1]
$LN19@approx_cur:

; 270  :          if ( (JA[j] == addend+1) || (JA[j] == 0) )

	mov	edx, DWORD PTR [ebx+eax*4]
	cmp	edx, esi
	je	$LN114@approx_cur
	test	edx, edx
	je	$LN114@approx_cur

; 268  :       /* seek column, add if not already there */
; 269  :       for ( j = IA[base]-1 ; j < IA[base+1]-1 ; j++ )

	inc	eax
	cmp	eax, ecx
	jl	SHORT $LN19@approx_cur
$LN135@approx_cur:

; 271  :              { JA[j] = addend + 1; /* in case first time */
; 272  :                 A[j] += (area1 + area2)/12; 

	fstp	ST(0)
$LN17@approx_cur:

; 273  :                 break;
; 274  :              }
; 275  :       if ( j == IA[base+1]-1 )

	mov	ecx, DWORD PTR [edi]
	dec	ecx
	cmp	eax, ecx
	jne	SHORT $LN25@approx_cur

; 276  :          kb_error(1650,"Internal error: approx_curvature: cannot find edge in JA list.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EA@GKBFBJOM@Internal?5error?3?5approx_curvature@
	push	1650					; 00000672H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN25@approx_cur:

; 248  : 
; 249  :   /* set up JA column index list for off diagonal */
; 250  :   /* and fill in facet star areas */
; 251  :   FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR tv1226[ebp]
	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [edx+eax]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, 268435456				; 10000000H
	jne	$LL26@approx_cur
$LN24@approx_cur:

; 277  : 
; 278  :     }
; 279  :       
; 280  : 
; 281  : #ifdef GDEBUG
; 282  : /* some debug printing */
; 283  : { REAL x;
; 284  : printf("IA: ");
; 285  : for ( i = 0 ; i <= N ; i++ ) printf(" %d",IA[i]);
; 286  : printf("\nJA: ");
; 287  : for ( i = 0 ; i < count ; i++ ) printf(" %d",JA[i]);
; 288  : printf("\n");
; 289  : for ( i = 0 ; i < N ; i++ ) 
; 290  :   { int j,k,m;
; 291  :      for ( m = 0 ; m < i ; m++ ) printf("            ");
; 292  :      for ( m = i,  j = 0, k = IA[i]-1 ; m < N /* j < IA[i+1]-IA[i] */; m++ )
; 293  :         if ( (m == JA[k]-1) && (k < IA[i+1]-1) )
; 294  :           { printf(" %f",(DOUBLE)A[k]); k++; j++; }
; 295  :         else printf(" %f",0.0);
; 296  :      printf("\n");
; 297  :   }
; 298  : }
; 299  : #endif
; 300  : 
; 301  :   /*  Call ODRV to perform the reordering on A */
; 302  :         PATH = 2;          
; 303  :         odrv_( &N, IA,JA,A, P,IP, &NSP,ISP, &PATH, &FLAG );

	mov	esi, DWORD PTR _ISP$[ebp]
	mov	ebx, DWORD PTR _JA$[ebp]
	mov	edi, DWORD PTR _IA$[ebp]
	lea	edx, DWORD PTR _FLAG$[ebp]
	push	edx
	mov	edx, DWORD PTR _IP$[ebp]
	lea	eax, DWORD PTR _PATH$[ebp]
	push	eax
	mov	eax, DWORD PTR _P$[ebp]
	push	esi
	lea	ecx, DWORD PTR _NSP$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _A$[ebp]
	push	edx
	push	eax
	push	ecx
	push	ebx
	lea	edx, DWORD PTR _N$[ebp]
	push	edi
	push	edx
	mov	DWORD PTR _PATH$[ebp], 2
	call	_odrv_

; 304  :         odrv_flag_check(FLAG,N);

	mov	eax, DWORD PTR _N$[ebp]
	mov	ecx, DWORD PTR _FLAG$[ebp]
	push	eax
	push	ecx
	call	_odrv_flag_check

; 305  : 
; 306  :   /*  Call SDRVMD to compute the solution */
; 307  :        RSP = (REAL *) ISP;
; 308  :        PATH = 5; /* SSF and SNF only */
; 309  :        sdrvmd_(&N,P,IP,IA,JA,A,B,B,&NSP,ISP,RSP,&ESP, &PATH,&FLAG,&EMAX);

	lea	edx, DWORD PTR _EMAX$[ebp]
	push	edx
	lea	eax, DWORD PTR _FLAG$[ebp]
	push	eax
	lea	ecx, DWORD PTR _PATH$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _A$[ebp]
	lea	edx, DWORD PTR _ESP$[ebp]
	push	edx
	mov	edx, DWORD PTR _IP$[ebp]
	push	esi
	push	esi
	lea	eax, DWORD PTR _NSP$[ebp]
	push	eax
	mov	eax, DWORD PTR _B$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR _P$[ebp]
	push	ecx
	push	ebx
	push	edi
	push	edx
	push	eax
	lea	ecx, DWORD PTR _N$[ebp]
	push	ecx
	mov	DWORD PTR _PATH$[ebp], 5
	call	_sdrvmd_

; 310  :        sdrv_flag_check(ESP,FLAG,N);

	mov	edx, DWORD PTR _N$[ebp]
	mov	eax, DWORD PTR _FLAG$[ebp]
	mov	ecx, DWORD PTR _ESP$[ebp]
	add	esp, 108				; 0000006cH
	push	edx
	push	eax
	push	ecx
	call	_sdrv_flag_check
	add	esp, 12					; 0000000cH

; 311  : 
; 312  :   /* each coordinate gives a right side */
; 313  :   for ( j = 0 ; j < SDIM ; j++ )

	cmp	DWORD PTR _web+616, 0
	mov	DWORD PTR _j$[ebp], 0
	jle	$LN11@approx_cur
	mov	esi, DWORD PTR _web+12
	npad	2
$LL13@approx_cur:

; 314  :      { vertex_id v_id;
; 315  :         FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+48
	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	je	SHORT $LN8@approx_cur
$LL126@approx_cur:
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [esi+ecx*4]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN9@approx_cur

; 316  :           { 
; 317  :              int vnum = loc_ordinal(v_id);

	test	edx, edx
	je	SHORT $LN47@approx_cur
	mov	eax, ecx
	jmp	SHORT $LN48@approx_cur
$LN114@approx_cur:

; 271  :              { JA[j] = addend + 1; /* in case first time */
; 272  :                 A[j] += (area1 + area2)/12; 

	mov	ecx, DWORD PTR _A$[ebp]
	mov	DWORD PTR [ebx+eax*4], esi
	fadd	QWORD PTR [ecx+eax*8]
	fstp	QWORD PTR [ecx+eax*8]
	jmp	$LN17@approx_cur
$LN47@approx_cur:

; 316  :           { 
; 317  :              int vnum = loc_ordinal(v_id);

	or	eax, -1
$LN48@approx_cur:

; 311  : 
; 312  :   /* each coordinate gives a right side */
; 313  :   for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+esi+784]
	mov	esi, DWORD PTR _j$[ebp]
	lea	edx, DWORD PTR [edx+esi*8]

; 318  :              B[vnum] = get_force(v_id)[j];

	fld	QWORD PTR [edx+edi]
	mov	edx, DWORD PTR _B$[ebp]
	fstp	QWORD PTR [edx+eax*8]
	mov	esi, DWORD PTR _web+12
$LN9@approx_cur:

; 314  :      { vertex_id v_id;
; 315  :         FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	SHORT $LL126@approx_cur
$LN8@approx_cur:

; 319  :           }
; 320  :         RSP = (REAL *) ISP;
; 321  :         PATH = 3; /* SNS */
; 322  :         sdrvmd_(&N,P,IP,IA,JA,A,B,B,&NSP,ISP,RSP,&ESP, &PATH,&FLAG,&EMAX);

	lea	ecx, DWORD PTR _EMAX$[ebp]
	push	ecx
	lea	edx, DWORD PTR _FLAG$[ebp]
	push	edx
	lea	eax, DWORD PTR _PATH$[ebp]
	push	eax
	mov	eax, DWORD PTR _ISP$[ebp]
	lea	ecx, DWORD PTR _ESP$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _JA$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR _B$[ebp]
	lea	edx, DWORD PTR _NSP$[ebp]
	push	edx
	mov	edx, DWORD PTR _IA$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR _A$[ebp]
	push	eax
	mov	eax, DWORD PTR _IP$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _P$[ebp]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR _N$[ebp]
	push	edx
	mov	DWORD PTR _PATH$[ebp], 3
	call	_sdrvmd_

; 323  :         sdrv_flag_check(ESP,FLAG,N);

	mov	eax, DWORD PTR _N$[ebp]
	mov	ecx, DWORD PTR _FLAG$[ebp]
	mov	edx, DWORD PTR _ESP$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_sdrv_flag_check

; 324  :         FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	esi, DWORD PTR _web+12
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	add	esp, 72					; 00000048H
	and	ecx, 1
	je	SHORT $LN12@approx_cur
$LL124@approx_cur:
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [esi+edx*4]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN4@approx_cur

; 325  :           { 
; 326  :              int vnum = loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN49@approx_cur
	mov	eax, edx
	jmp	SHORT $LN50@approx_cur
$LN49@approx_cur:
	or	eax, -1
$LN50@approx_cur:

; 311  : 
; 312  :   /* each coordinate gives a right side */
; 313  :   for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+esi+784]
	mov	esi, DWORD PTR _j$[ebp]
	lea	ecx, DWORD PTR [ecx+esi*8]

; 327  :              get_force(v_id)[j] = B[vnum];

	mov	esi, DWORD PTR _B$[ebp]
	fld	QWORD PTR [esi+eax*8]
	fstp	QWORD PTR [ecx+edi]
	mov	esi, DWORD PTR _web+12
$LN4@approx_cur:

; 324  :         FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR [esi+edx*4]
	mov	eax, DWORD PTR [edx]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	SHORT $LL124@approx_cur
$LN12@approx_cur:

; 311  : 
; 312  :   /* each coordinate gives a right side */
; 313  :   for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _web+616
	jl	$LL13@approx_cur
$LN11@approx_cur:

; 328  :           }
; 329  :      }
; 330  : 
; 331  : 
; 332  :   /* free stuff */
; 333  :   temp_free((char *)IA);

	mov	eax, DWORD PTR _IA$[ebp]
	push	eax
	call	_temp_free

; 334  :   temp_free((char *)A);

	mov	ecx, DWORD PTR _A$[ebp]
	push	ecx
	call	_temp_free

; 335  :   temp_free((char *)JA);

	mov	edx, DWORD PTR _JA$[ebp]
	push	edx
	call	_temp_free

; 336  :   temp_free((char *)B);

	mov	eax, DWORD PTR _B$[ebp]
	push	eax
	call	_temp_free

; 337  :   temp_free((char *)ISP);

	mov	ecx, DWORD PTR _ISP$[ebp]
	push	ecx
	call	_temp_free

; 338  :   temp_free((char *)IP);

	mov	edx, DWORD PTR _IP$[ebp]
	push	edx
	call	_temp_free

; 339  :   temp_free((char *)P);

	mov	eax, DWORD PTR _P$[ebp]
	push	eax
	call	_temp_free
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 340  : } // end approx_curvature()

	mov	esp, ebp
	pop	ebp
	ret	0
_approx_curvature ENDP
_TEXT	ENDS
PUBLIC	__real@bfd0000000000000
PUBLIC	__real@4018000000000000
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_0CE@GOKGIFAG@approx_curv?5only?5for?5LINEAR?5mode@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_mobility_setup
EXTRN	_free_matrix:PROC
EXTRN	_mat_mul_tr:PROC
EXTRN	_mat_mult:PROC
EXTRN	_quadratic_form:PROC
EXTRN	_effective_area_flag:DWORD
EXTRN	_get_edge_length:PROC
EXTRN	_constr_basis:PROC
EXTRN	_bdry_basis:PROC
EXTRN	_kb_dmatrix:PROC
_BSS	SEGMENT
_RSP	DD	01H DUP (?)
_ISP	DD	01H DUP (?)
_NSP	DD	01H DUP (?)
_IA_INV	DD	01H DUP (?)
_IP	DD	01H DUP (?)
_P	DD	01H DUP (?)
_A	DD	01H DUP (?)
_JA	DD	01H DUP (?)
_IA	DD	01H DUP (?)
_mobN	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@bfd0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@bfd0000000000000 DQ 0bfd0000000000000r	; -0.25
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0CE@GOKGIFAG@approx_curv?5only?5for?5LINEAR?5mode@
CONST	SEGMENT
??_C@_0CE@GOKGIFAG@approx_curv?5only?5for?5LINEAR?5mode@ DB 'approx_curv '
	DB	'only for LINEAR model.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\kusner.c
CONST	ENDS
;	COMDAT _mobility_setup
_TEXT	SEGMENT
_EMAX$ = -200						; size = 8
tv2412 = -192						; size = 8
_Total_entries$ = -188					; size = 4
_ESP$ = -184						; size = 4
_s1s1$89781 = -180					; size = 8
tv2804 = -176						; size = 4
_s2s2$89782 = -172					; size = 8
tv1882 = -168						; size = 4
_temp$89683 = -168					; size = 4
_qqq$ = -164						; size = 4
_qq$ = -160						; size = 4
_PATH$ = -156						; size = 4
_length$89707 = -152					; size = 8
tv2781 = -148						; size = 4
_cbh$ = -148						; size = 4
_dim$89679 = -148					; size = 4
_FLAG$ = -144						; size = 4
_tail$89810 = -140					; size = 4
_hord$89700 = -140					; size = 4
_proj$ = -136						; size = 4
_area$89779 = -132					; size = 8
tv4752 = -128						; size = 4
tv4646 = -128						; size = 4
_addend$89813 = -128					; size = 4
_addend$89706 = -128					; size = 4
_head$89704 = -128					; size = 4
_count$ = -128						; size = 4
_j$ = -128						; size = 4
tv4894 = -124						; size = 4
tv4277 = -124						; size = 4
_head$89811 = -124					; size = 4
_base$89705 = -124					; size = 4
_tail$89703 = -124					; size = 4
tv4654 = -120						; size = 4
tv4037 = -120						; size = 4
tv3852 = -120						; size = 4
_ordb$89815 = -120					; size = 4
tv2488 = -116						; size = 4
_base$89812 = -116					; size = 4
_tord$89804 = -116					; size = 4
_ord$89594 = -116					; size = 4
_i$ = -112						; size = 4
tv2405 = -108						; size = 4
_fe$89784 = -108					; size = 4
_ordb$89710 = -108					; size = 4
_tord$89697 = -108					; size = 4
tv4892 = -104						; size = 4
tv4275 = -104						; size = 4
tv4134 = -104						; size = 4
tv4029 = -104						; size = 4
tv3950 = -104						; size = 4
tv3844 = -104						; size = 4
_hord$89807 = -104					; size = 4
_side1$89787 = -100					; size = 48
_side2$89788 = -52					; size = 48
_side$89708 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_mobility_setup PROC					; COMDAT

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 380  :   integer i,j,k, PATH, FLAG=0;

	xor	ebx, ebx

; 381  :   integer count;
; 382  :   integer ESP;
; 383  :   REAL EMAX;
; 384  :   int Total_entries;
; 385  :   vertex_id v_id;
; 386  :   edge_id e_id;
; 387  :   facet_id f_id;
; 388  :   REAL **proj;  /* normal projection matrix */
; 389  :   REAL **q,**qq,**qqq; /* basis product matrices */
; 390  :   struct basis *cb,*cba,*cbb,*cbh,*cbt;
; 391  :   int dim_a;
; 392  : 
; 393  :   if ( web.modeltype != LINEAR )

	cmp	DWORD PTR _web+628, 1
	push	esi
	push	edi
	mov	DWORD PTR _FLAG$[ebp], ebx
	je	SHORT $LN173@mobility_s

; 394  :      kb_error(2088,"approx_curv only for LINEAR model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CE@GOKGIFAG@approx_curv?5only?5for?5LINEAR?5mode@
	push	2088					; 00000828H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN173@mobility_s:

; 395  :   proj = dmatrix(0,SDIM-1,0,SDIM-1);

	mov	eax, DWORD PTR _web+616
	push	395					; 0000018bH
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	dec	eax
	push	eax
	push	ebx
	push	eax
	push	ebx
	call	_kb_dmatrix

; 396  :   qq = dmatrix(0,SDIM-1,0,SDIM-1);

	push	396					; 0000018cH
	mov	DWORD PTR _proj$[ebp], eax
	mov	eax, DWORD PTR _web+616
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	dec	eax
	push	eax
	push	ebx
	push	eax
	push	ebx
	call	_kb_dmatrix

; 397  :   qqq = dmatrix(0,SDIM-1,0,SDIM-1);

	push	397					; 0000018dH
	mov	DWORD PTR _qq$[ebp], eax
	mov	eax, DWORD PTR _web+616
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	dec	eax
	push	eax
	push	ebx
	push	eax
	push	ebx
	call	_kb_dmatrix
	mov	DWORD PTR _qqq$[ebp], eax

; 398  : 
; 399  :   /*************************/
; 400  :   /* set up conbasis first */
; 401  :   /*************************/
; 402  : 
; 403  :   /* count vertices on constraints and boundaries */
; 404  :   cb_count = 0;
; 405  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	add	esp, 72					; 00000048H
	mov	DWORD PTR _cb_count, ebx
	test	eax, 268435456				; 10000000H
	je	SHORT $LN170@mobility_s
	mov	edi, DWORD PTR _web+12
$LL172@mobility_s:
	and	eax, 134217727				; 07ffffffH
	lea	esi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv2412[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN171@mobility_s

; 406  :      { 
; 407  :         if ( get_vattr(v_id) & (BOUNDARY|HIT_WALL)  )

	and	ecx, 8320				; 00002080H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN171@mobility_s

; 408  :           cb_count++;

	inc	DWORD PTR _cb_count
$LN171@mobility_s:

; 398  : 
; 399  :   /*************************/
; 400  :   /* set up conbasis first */
; 401  :   /*************************/
; 402  : 
; 403  :   /* count vertices on constraints and boundaries */
; 404  :   cb_count = 0;
; 405  :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL172@mobility_s
$LN170@mobility_s:

; 409  :      }
; 410  : 
; 411  :   /* allocate space */
; 412  :   cb_list = (struct basis **)temp_calloc(web.skel[VERTEX].max_ord+1,
; 413  :                                                   sizeof(struct basis *));

	mov	edx, DWORD PTR _web+68
	push	413					; 0000019dH
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	inc	edx
	push	4
	push	edx
	call	_kb_temp_calloc

; 414  :   dimf = (int *)temp_calloc(web.skel[VERTEX].max_ord+1,sizeof(int));

	push	414					; 0000019eH
	mov	DWORD PTR _cb_list, eax
	mov	eax, DWORD PTR _web+68
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	inc	eax
	push	4
	push	eax
	call	_kb_temp_calloc

; 415  :   if ( cb_count )

	mov	ecx, DWORD PTR _cb_count
	add	esp, 32					; 00000020H
	mov	DWORD PTR _dimf, eax
	cmp	ecx, ebx
	je	SHORT $LN350@mobility_s

; 416  :   conbasis = (struct basis *)temp_calloc(cb_count,sizeof(struct basis));

	push	416					; 000001a0H
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	push	320					; 00000140H
	push	ecx
	call	_kb_temp_calloc
	mov	ecx, DWORD PTR _cb_count
	add	esp, 16					; 00000010H
	mov	DWORD PTR _conbasis, eax
	jmp	SHORT $LN166@mobility_s
$LN350@mobility_s:
	mov	eax, DWORD PTR _conbasis
$LN166@mobility_s:

; 417  :   for ( j = 0 ; j < cb_count ; j++ )

	mov	edi, DWORD PTR _web+616
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ecx, ebx
	jle	SHORT $LN163@mobility_s
$LL165@mobility_s:

; 418  :       for( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN164@mobility_s
	lea	ecx, DWORD PTR [ebx+296]
	mov	edx, ebx
	npad	2
$LL162@mobility_s:

; 419  :           conbasis[j].vec[i] = conbasis[j].vvec[i];

	lea	edi, DWORD PTR [edx+eax+8]
	mov	DWORD PTR [ecx+eax], edi
	mov	edi, DWORD PTR _web+616
	mov	eax, DWORD PTR _conbasis
	inc	esi
	add	ecx, 4
	add	edx, 48					; 00000030H
	cmp	esi, edi
	jl	SHORT $LL162@mobility_s

; 418  :       for( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _cb_count
$LN164@mobility_s:

; 417  :   for ( j = 0 ; j < cb_count ; j++ )

	mov	edx, DWORD PTR _j$[ebp]
	inc	edx
	add	ebx, 320				; 00000140H
	mov	DWORD PTR _j$[ebp], edx
	cmp	edx, ecx
	jl	SHORT $LL165@mobility_s
$LN163@mobility_s:

; 420  : 
; 421  :   /* fill in */
; 422  :   cb_count = 0;
; 423  :   mobN = 0;
; 424  :   FOR_ALL_VERTICES(v_id)

	mov	esi, DWORD PTR _web+48
	mov	ebx, esi
	xor	eax, eax
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	mov	DWORD PTR _cb_count, eax
	mov	DWORD PTR _mobN, eax
	je	$LN157@mobility_s
	npad	12
$LL159@mobility_s:
	mov	ecx, DWORD PTR _web+12
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv2405[ebp], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, edx
	mov	DWORD PTR tv2412[ebp+4], eax
	and	ecx, 1
	xor	eax, eax
	or	ecx, eax
	je	$LN158@mobility_s

; 425  :      { int ord = loc_ordinal(v_id);

	test	ebx, ebx
	je	SHORT $LN176@mobility_s
	mov	ecx, DWORD PTR tv2405[ebp]
	mov	DWORD PTR _ord$89594[ebp], ecx
	jmp	SHORT $LN177@mobility_s
$LN176@mobility_s:
	mov	DWORD PTR _ord$89594[ebp], -1
$LN177@mobility_s:

; 426  :         if ( get_vattr(v_id) & FIXED ) continue;  /* leave dimf as 0 */

	mov	ecx, edx
	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	jne	$LN158@mobility_s

; 427  :         if ( get_vattr(v_id) & BOUNDARY ) 

	mov	ecx, edx
	and	ecx, 128				; 00000080H
	or	ecx, eax
	je	SHORT $LN153@mobility_s

; 428  :           dimf[ord] = bdry_basis(v_id,conbasis[cb_count].vec);

	mov	eax, DWORD PTR _cb_count
	mov	edi, DWORD PTR _ord$89594[ebp]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _conbasis
	shl	edx, 6
	lea	ecx, DWORD PTR [edx+eax+296]
	push	ecx
	add	edi, edi
	push	esi
	add	edi, edi
	call	_bdry_basis
	mov	edx, DWORD PTR _dimf
	mov	DWORD PTR [edi+edx], eax
	jmp	SHORT $LN479@mobility_s
$LN153@mobility_s:

; 429  :         else if ( get_vattr(v_id) & HIT_WALL )

	and	edx, 8192				; 00002000H
	xor	eax, eax
	or	edx, eax
	je	$LN151@mobility_s

; 430  :          dimf[ord] = constr_basis(v_id,conbasis[cb_count].vec);

	mov	eax, DWORD PTR _cb_count
	mov	ecx, DWORD PTR _conbasis
	mov	edi, DWORD PTR _ord$89594[ebp]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 6
	lea	edx, DWORD PTR [eax+ecx+296]
	push	edx
	add	edi, edi
	push	esi
	add	edi, edi
	call	_constr_basis
	mov	ecx, DWORD PTR _dimf
	mov	DWORD PTR [edi+ecx], eax
$LN479@mobility_s:

; 432  :         conbasis[cb_count].v_id = v_id;

	mov	eax, DWORD PTR _cb_count
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _conbasis
	shl	edx, 6
	mov	DWORD PTR [edx+eax], esi

; 433  :         mobN += dimf[ord];

	mov	ecx, DWORD PTR _dimf
	mov	edx, DWORD PTR [edi+ecx]
	add	DWORD PTR _mobN, edx
	add	esp, 8

; 434  :         cb_list[loc_ordinal(v_id)] = conbasis + cb_count;

	test	ebx, ebx
	je	SHORT $LN178@mobility_s
	mov	ecx, DWORD PTR tv2405[ebp]
	jmp	SHORT $LN179@mobility_s
$LN178@mobility_s:
	or	ecx, -1
$LN179@mobility_s:
	mov	eax, DWORD PTR _cb_count
	mov	edx, DWORD PTR _cb_list
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 6
	add	eax, DWORD PTR _conbasis
	mov	DWORD PTR [edx+ecx*4], eax

; 435  :         cb_count++;

	inc	DWORD PTR _cb_count

; 436  :      }

	jmp	SHORT $LN480@mobility_s
$LN151@mobility_s:

; 431  :         else { mobN += SDIM; dimf[ord] = SDIM;  continue; }

	mov	eax, DWORD PTR _dimf
	mov	ecx, DWORD PTR _ord$89594[ebp]
	add	DWORD PTR _mobN, edi
	mov	DWORD PTR [eax+ecx*4], edi
$LN480@mobility_s:
	mov	edi, DWORD PTR _web+616
$LN158@mobility_s:

; 420  : 
; 421  :   /* fill in */
; 422  :   cb_count = 0;
; 423  :   mobN = 0;
; 424  :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR tv2405[ebp]
	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	esi, DWORD PTR [ecx]
	mov	ebx, esi
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	jne	$LL159@mobility_s
$LN157@mobility_s:

; 437  : 
; 438  :   Total_entries = (mobN*(SDIM+1))/2+SDIM*SDIM*web.skel[EDGE].count;

	mov	ecx, DWORD PTR _mobN
	lea	eax, DWORD PTR [edi+1]
	imul	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _web+176
	imul	edx, edi
	imul	edx, edi

; 439  :   /* allocate storage for arrays to be passed to ysmp */
; 440  :   IA = (integer *)temp_calloc(mobN+1,sizeof(integer));

	push	440					; 000001b8H
	mov	esi, eax
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	sar	esi, 1
	inc	ecx
	add	esi, edx
	push	4
	push	ecx
	mov	DWORD PTR _Total_entries$[ebp], esi
	call	_kb_temp_calloc

; 441  :   JA = (integer *)temp_calloc(Total_entries,sizeof(integer));

	push	441					; 000001b9H
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	push	4
	push	esi
	mov	DWORD PTR _IA, eax
	call	_kb_temp_calloc

; 442  :   A = (REAL *)temp_calloc(Total_entries,sizeof(REAL));

	push	442					; 000001baH
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	push	8
	push	esi
	mov	DWORD PTR _JA, eax
	call	_kb_temp_calloc

; 443  :   P = (integer *)temp_calloc(mobN,sizeof(integer));

	push	443					; 000001bbH
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	mov	DWORD PTR _A, eax
	mov	eax, DWORD PTR _mobN
	push	4
	push	eax
	call	_kb_temp_calloc

; 444  :   IP = (integer *)temp_calloc(mobN,sizeof(integer));

	mov	ecx, DWORD PTR _mobN
	add	esp, 64					; 00000040H
	push	444					; 000001bcH
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	push	4
	push	ecx
	mov	DWORD PTR _P, eax
	call	_kb_temp_calloc

; 445  :   IA_INV = (int *)temp_calloc(web.skel[VERTEX].max_ord+1,sizeof(integer));

	mov	edx, DWORD PTR _web+68
	push	445					; 000001bdH
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	inc	edx
	push	4
	push	edx
	mov	DWORD PTR _IP, eax
	call	_kb_temp_calloc
	add	esp, 32					; 00000020H
	mov	DWORD PTR _IA_INV, eax

; 446  : 
; 447  : #define EMPTY (-1)
; 448  :   for ( i = 0 ; i < Total_entries ; i++ ) JA[i] = EMPTY;

	test	esi, esi
	jle	SHORT $LN376@mobility_s

; 437  : 
; 438  :   Total_entries = (mobN*(SDIM+1))/2+SDIM*SDIM*web.skel[EDGE].count;

	mov	edi, DWORD PTR _JA
	mov	ecx, esi
	or	eax, -1
	rep stosd
$LN376@mobility_s:

; 449  : 
; 450  :   /* count entries needed for each row, row size accum in IA */
; 451  :   k = 0;
; 452  :   FOR_ALL_VERTICES(v_id) /* diagonal elements */

	mov	eax, DWORD PTR _web+48
	mov	ebx, DWORD PTR _IA
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	xor	edi, edi
	and	ecx, 1
	je	SHORT $LN354@mobility_s
$LL146@mobility_s:
	mov	edx, eax
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN145@mobility_s

; 453  :      { int ord = loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN180@mobility_s
	mov	eax, edx
	jmp	SHORT $LN181@mobility_s
$LN180@mobility_s:
	or	eax, -1
$LN181@mobility_s:

; 454  :        cb = cb_list[ord];
; 455  :        IA_INV[ord] = k;

	mov	ecx, DWORD PTR _IA_INV
	mov	DWORD PTR [ecx+eax*4], edi

; 456  :        dim_a = dimf[ord];

	mov	ecx, DWORD PTR _dimf
	mov	eax, DWORD PTR [ecx+eax*4]

; 457  :        for ( i = 0 ; i < dim_a ; i++ )

	test	eax, eax
	jle	SHORT $LN145@mobility_s

; 454  :        cb = cb_list[ord];
; 455  :        IA_INV[ord] = k;

	mov	ecx, eax
$LL141@mobility_s:

; 458  :          IA[k++] = dim_a - i;

	mov	DWORD PTR [ebx+edi*4], eax
	inc	edi
	dec	eax
	dec	ecx
	jne	SHORT $LL141@mobility_s
$LN145@mobility_s:

; 449  : 
; 450  :   /* count entries needed for each row, row size accum in IA */
; 451  :   k = 0;
; 452  :   FOR_ALL_VERTICES(v_id) /* diagonal elements */

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	SHORT $LL146@mobility_s
$LN354@mobility_s:

; 459  :      }
; 460  :   FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	test	edx, 268435456				; 10000000H
	je	$LN136@mobility_s
	npad	1
$LL380@mobility_s:
	mov	ecx, DWORD PTR _web+124
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv2488[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN137@mobility_s

; 461  :     { int tord = loc_ordinal(get_edge_tailv(e_id));

	mov	eax, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+esi+304]
	shr	edx, 27					; 0000001bH
	add	eax, ecx
	and	edx, 1
	je	SHORT $LN197@mobility_s
	mov	ecx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN196@mobility_s
$LN197@mobility_s:
	mov	ecx, DWORD PTR [eax]
$LN196@mobility_s:
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN182@mobility_s
	test	edx, edx
	je	SHORT $LN201@mobility_s
	mov	ecx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [eax+ecx*4]
	and	ecx, 134217727				; 07ffffffH
	mov	ebx, ecx
	jmp	SHORT $LN183@mobility_s
$LN201@mobility_s:
	mov	ecx, DWORD PTR [eax]
	and	ecx, 134217727				; 07ffffffH
	mov	ebx, ecx
	jmp	SHORT $LN183@mobility_s
$LN182@mobility_s:
	or	ebx, -1
$LN183@mobility_s:

; 462  :       int hord = loc_ordinal(get_edge_headv(e_id));

	test	edx, edx
	je	SHORT $LN205@mobility_s
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN204@mobility_s
$LN205@mobility_s:
	mov	ecx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [eax+ecx*4]
$LN204@mobility_s:
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN184@mobility_s
	test	edx, edx
	je	SHORT $LN209@mobility_s
	mov	eax, DWORD PTR [eax]
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN185@mobility_s
$LN209@mobility_s:
	mov	edx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edx*4]
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN185@mobility_s
$LN184@mobility_s:
	or	eax, -1
$LN185@mobility_s:

; 463  :       int tail = IA_INV[tord];

	mov	ecx, DWORD PTR _IA_INV
	mov	esi, DWORD PTR [ecx+ebx*4]

; 464  :       int head = IA_INV[hord];

	mov	edi, DWORD PTR [ecx+eax*4]

; 465  :       int dim_h = dimf[hord];

	mov	edx, DWORD PTR _dimf
	mov	ecx, DWORD PTR [edx+eax*4]

; 466  :       int dim_t = dimf[tord];

	mov	edx, DWORD PTR [edx+ebx*4]

; 467  :       if ( tail > head ) for ( i = 0 ; i < dim_h ; i++ ) IA[head+i] += dim_t;

	cmp	esi, edi
	jle	SHORT $LN133@mobility_s
	test	ecx, ecx
	jle	SHORT $LN137@mobility_s
	mov	eax, DWORD PTR _IA
	lea	eax, DWORD PTR [eax+edi*4]
	npad	1
$LL132@mobility_s:
	add	DWORD PTR [eax], edx
	add	eax, 4
	dec	ecx
	jne	SHORT $LL132@mobility_s

; 468  :       else for ( i = 0 ; i < dim_t ; i++ ) IA[tail+i] += dim_h;

	jmp	SHORT $LN137@mobility_s
$LN133@mobility_s:
	test	edx, edx
	jle	SHORT $LN137@mobility_s
	mov	eax, DWORD PTR _IA
	lea	eax, DWORD PTR [eax+esi*4]
$LL128@mobility_s:
	add	DWORD PTR [eax], ecx
	add	eax, 4
	dec	edx
	jne	SHORT $LL128@mobility_s
$LN137@mobility_s:

; 459  :      }
; 460  :   FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR tv2488[ebp]
	mov	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	$LL380@mobility_s
$LN136@mobility_s:

; 469  :     }
; 470  :   /* set up IA pointers */
; 471  :   count = 0;
; 472  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ecx, eax
	xor	ebx, ebx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _count$[ebp], ebx
	je	$LN123@mobility_s
$LL382@mobility_s:
	mov	edx, eax
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv2405[ebp], edx
	je	$LN124@mobility_s

; 473  :     { int ord = loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN186@mobility_s
	mov	eax, edx
	jmp	SHORT $LN187@mobility_s
$LN186@mobility_s:
	or	eax, -1
$LN187@mobility_s:

; 474  :       int dim = dimf[ord];

	mov	ecx, DWORD PTR _dimf
	mov	ecx, DWORD PTR [ecx+eax*4]

; 475  :       i = IA_INV[ord];

	mov	esi, DWORD PTR _IA_INV
	mov	eax, DWORD PTR [esi+eax*4]

; 476  :       for ( k = 0 ; k < dim ; k++ )

	xor	esi, esi
	mov	DWORD PTR _dim$89679[ebp], ecx
	mov	DWORD PTR _i$[ebp], eax
	test	ecx, ecx
	jle	SHORT $LN124@mobility_s

; 474  :       int dim = dimf[ord];

	mov	edi, DWORD PTR _IA
	mov	edx, ecx
	lea	edi, DWORD PTR [edi+eax*4]
	npad	6
$LL374@mobility_s:

; 477  :          {
; 478  :             int temp = IA[i+k];

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _temp$89683[ebp], eax

; 479  :             IA[i+k] = count + A_OFF;  /* FORTRAN indexing */

	lea	eax, DWORD PTR [ebx+1]
	mov	DWORD PTR [edi], eax

; 480  :             for ( j = 0 ; j < dim - k ; j++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN115@mobility_s

; 477  :          {
; 478  :             int temp = IA[i+k];

	mov	ecx, DWORD PTR _JA
	lea	ecx, DWORD PTR [ecx+ebx*4]
	npad	4
$LL117@mobility_s:

; 480  :             for ( j = 0 ; j < dim - k ; j++ )

	mov	ebx, DWORD PTR _i$[ebp]
	lea	ebx, DWORD PTR [ebx+esi+1]
	add	ebx, eax

; 481  :               JA[count + j] = i+k+A_OFF+j;  /* diagonal */

	mov	DWORD PTR [ecx], ebx
	inc	eax
	add	ecx, 4
	cmp	eax, edx
	jl	SHORT $LL117@mobility_s

; 480  :             for ( j = 0 ; j < dim - k ; j++ )

	mov	ebx, DWORD PTR _count$[ebp]
	mov	ecx, DWORD PTR _dim$89679[ebp]
$LN115@mobility_s:

; 482  :             count += temp;

	add	ebx, DWORD PTR _temp$89683[ebp]
	inc	esi
	add	edi, 4
	dec	edx
	mov	DWORD PTR _count$[ebp], ebx
	cmp	esi, ecx
	jl	SHORT $LL374@mobility_s

; 476  :       for ( k = 0 ; k < dim ; k++ )

	mov	edx, DWORD PTR tv2405[ebp]
$LN124@mobility_s:

; 469  :     }
; 470  :   /* set up IA pointers */
; 471  :   count = 0;
; 472  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL382@mobility_s
$LN123@mobility_s:

; 483  :          }
; 484  :     }
; 485  :   IA[mobN] = count + A_OFF;

	mov	edx, DWORD PTR _mobN
	mov	eax, DWORD PTR _IA
	inc	ebx
	mov	DWORD PTR [eax+edx*4], ebx

; 486  : 
; 487  :   /* set up JA column index list for off diagonal */
; 488  :   /* and fill in star areas */
; 489  : 
; 490  :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	$LN111@mobility_s

; 491  :   { FOR_ALL_EDGES(e_id)

	mov	esi, DWORD PTR _web+160
	test	esi, 268435456				; 10000000H
	je	$LN49@mobility_s
	mov	ecx, DWORD PTR _web+124
	npad	3
$LL113@mobility_s:
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2488[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN112@mobility_s

; 492  :     { int tord = loc_ordinal(get_edge_tailv(e_id));

	mov	edi, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edi+304]
	mov	edi, DWORD PTR tv2488[ebp]
	mov	ebx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [edi+ecx]
	mov	edx, esi
	shr	edx, 27					; 0000001bH
	and	edx, 1
	je	SHORT $LN213@mobility_s
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN212@mobility_s
$LN213@mobility_s:
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
$LN212@mobility_s:
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN188@mobility_s
	test	edx, edx
	je	SHORT $LN217@mobility_s
	mov	ecx, DWORD PTR [eax+ebx*4]
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN481@mobility_s
$LN217@mobility_s:
	mov	ecx, DWORD PTR [eax]
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN481@mobility_s
$LN188@mobility_s:
	or	ecx, -1
$LN481@mobility_s:
	mov	DWORD PTR _tord$89697[ebp], ecx

; 493  :       int hord = loc_ordinal(get_edge_headv(e_id));

	test	edx, edx
	je	SHORT $LN221@mobility_s
	mov	edi, DWORD PTR [eax]
	jmp	SHORT $LN220@mobility_s
$LN221@mobility_s:
	mov	edi, DWORD PTR [eax+ebx*4]
$LN220@mobility_s:
	test	edi, 268435456				; 10000000H
	je	SHORT $LN190@mobility_s
	test	edx, edx
	je	SHORT $LN225@mobility_s
	mov	eax, DWORD PTR [eax]
	and	eax, 134217727				; 07ffffffH
	mov	edx, eax
	mov	DWORD PTR _hord$89700[ebp], eax
	jmp	SHORT $LN191@mobility_s
$LN225@mobility_s:
	mov	eax, DWORD PTR [eax+ebx*4]
	and	eax, 134217727				; 07ffffffH
	mov	edx, eax
	mov	DWORD PTR _hord$89700[ebp], eax
	jmp	SHORT $LN191@mobility_s
$LN190@mobility_s:
	or	edx, -1
	mov	DWORD PTR _hord$89700[ebp], edx
$LN191@mobility_s:

; 494  :       int tail = IA_INV[tord];

	mov	eax, DWORD PTR _IA_INV
	mov	ecx, DWORD PTR [eax+ecx*4]

; 495  :       int head = IA_INV[hord];

	mov	edx, DWORD PTR [eax+edx*4]

; 496  :       int base,addend;
; 497  :       REAL length;
; 498  :       REAL side[MAXCOORD];
; 499  :       int orda,ordb;
; 500  :       
; 501  :       length = get_edge_length(e_id);

	push	esi
	mov	DWORD PTR _tail$89703[ebp], ecx
	mov	DWORD PTR _head$89704[ebp], edx
	call	_get_edge_length
	fstp	QWORD PTR _length$89707[ebp]

; 502  :       get_edge_side(e_id,side);

	lea	eax, DWORD PTR _side$89708[ebp]
	push	eax
	push	esi
	call	_get_edge_side

; 503  : 
; 504  :       /* figure normal projection matrix */
; 505  :       for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+616, eax
	jle	$LN106@mobility_s
	fldz
	mov	ebx, DWORD PTR _proj$[ebp]
	fld	QWORD PTR _length$89707[ebp]
$LN369@mobility_s:

; 506  :          {
; 507  :           if ( effective_area_flag )

	cmp	DWORD PTR _effective_area_flag, 0

; 508  :              for ( j = i ; j < SDIM ; j++ )

	mov	edx, eax
	je	SHORT $LN105@mobility_s
	cmp	eax, DWORD PTR _web+616
	jge	SHORT $LN98@mobility_s
	mov	edi, DWORD PTR [ebx+eax*4]
	lea	esi, DWORD PTR _side$89708[ebp]
	lea	ecx, DWORD PTR [edi+eax*8]
	sub	esi, edi
$LN104@mobility_s:

; 509  :              { /* not pure projection, to keep pos def */
; 510  :                  proj[i][j] = - /* 0.99* */ side[i]*side[j]/length; 

	fld	QWORD PTR [esi+ecx]
	inc	edx
	fmul	QWORD PTR _side$89708[ebp+eax*8]
	add	ecx, 8
	fdiv	ST(0), ST(1)
	fchs
	fstp	QWORD PTR [ecx-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LN104@mobility_s

; 511  :               }
; 512  :             else for ( j = i ; j < SDIM ; j++ ) proj[i][j] = 0.0;

	jmp	SHORT $LN98@mobility_s
$LN105@mobility_s:
	cmp	eax, DWORD PTR _web+616
	jge	SHORT $LN98@mobility_s

; 503  : 
; 504  :       /* figure normal projection matrix */
; 505  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR [ebx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*8]
$LN399@mobility_s:

; 511  :               }
; 512  :             else for ( j = i ; j < SDIM ; j++ ) proj[i][j] = 0.0;

	fxch	ST(1)
	inc	edx
	fst	QWORD PTR [ecx]
	add	ecx, 8
	fxch	ST(1)
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LN399@mobility_s
$LN98@mobility_s:

; 503  : 
; 504  :       /* figure normal projection matrix */
; 505  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR [ebx+eax*4]

; 513  :             proj[i][i] += length;  

	fld	QWORD PTR [edx+eax*8]
	lea	ecx, DWORD PTR [edx+eax*8]
	fadd	ST(0), ST(1)
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN369@mobility_s

; 503  : 
; 504  :       /* figure normal projection matrix */
; 505  :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
	fstp	ST(0)
$LN106@mobility_s:

; 514  :          }
; 515  : 
; 516  :       /* add to vertex stars */
; 517  :       cbh = cb_list[hord];

	mov	eax, DWORD PTR _cb_list
	mov	ecx, DWORD PTR _hord$89700[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]

; 518  :       if ( cbh )
; 519  :         { for ( i = 0 ; i < dimf[hord] ; i++ )

	mov	eax, DWORD PTR _dimf
	mov	DWORD PTR _cbh$[ebp], edx
	test	edx, edx
	je	$LN97@mobility_s
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _i$[ebp], 0
	test	ecx, ecx
	jle	$LN356@mobility_s
	mov	esi, DWORD PTR _head$89704[ebp]
	fld	QWORD PTR __real@4008000000000000
	add	esi, esi
	add	esi, esi
	add	edx, 296				; 00000128H
	mov	DWORD PTR tv3844[ebp], esi
	mov	DWORD PTR tv3852[ebp], edx
$LN96@mobility_s:

; 520  :             for ( j = i ; j < dimf[hord] ; j++ )

	mov	esi, DWORD PTR _i$[ebp]
	cmp	esi, ecx
	jge	SHORT $LN95@mobility_s
	mov	ebx, DWORD PTR tv3852[ebp]
	npad	2
$LL420@mobility_s:

; 521  :                  A[IA[head+i]-A_OFF+(j-i)] += 
; 522  :                   quadratic_form(cbh->vec[i],proj,cbh->vec[j],SDIM)/3; 

	mov	ecx, DWORD PTR _IA
	fstp	ST(0)
	mov	edx, DWORD PTR tv3844[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	sub	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _A
	mov	edx, DWORD PTR _web+616
	add	eax, esi
	lea	edi, DWORD PTR [ecx+eax*8-8]
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _proj$[ebp]
	push	edx
	mov	edx, DWORD PTR tv3852[ebp]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	eax
	call	_quadratic_form
	fld	QWORD PTR __real@4008000000000000
	fdiv	ST(1), ST(0)
	mov	ecx, DWORD PTR _hord$89700[ebp]
	inc	esi
	add	esp, 16					; 00000010H
	add	ebx, 4
	fxch	ST(1)
	fadd	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	mov	eax, DWORD PTR _dimf
	cmp	esi, DWORD PTR [eax+ecx*4]
	jl	SHORT $LL420@mobility_s
$LN95@mobility_s:

; 518  :       if ( cbh )
; 519  :         { for ( i = 0 ; i < dimf[hord] ; i++ )

	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, 4
	add	DWORD PTR tv3844[ebp], ecx
	add	DWORD PTR tv3852[ebp], ecx
	mov	ecx, DWORD PTR _hord$89700[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, ecx
	jl	$LN96@mobility_s

; 523  :         }
; 524  :       else

	jmp	SHORT $LN87@mobility_s
$LN97@mobility_s:

; 525  :         { for ( i = 0 ; i < dimf[hord] ; i++ )

	lea	esi, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [esi]
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN356@mobility_s
	mov	eax, DWORD PTR _IA
	fld	QWORD PTR __real@4008000000000000
	mov	edi, DWORD PTR _head$89704[ebp]
	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR tv3950[ebp], eax
$LN89@mobility_s:

; 526  :             for ( j = i ; j < dimf[hord] ; j++ )

	mov	eax, edx
	cmp	edx, ecx
	jge	SHORT $LN88@mobility_s

; 525  :         { for ( i = 0 ; i < dimf[hord] ; i++ )

	mov	ecx, DWORD PTR _proj$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	lea	edi, DWORD PTR [ecx+edx*8]
$LN364@mobility_s:

; 527  :                  A[IA[head+i]-A_OFF+(j-i)] += proj[i][j]/3;

	fld	QWORD PTR [edi]
	mov	ecx, DWORD PTR tv3950[ebp]
	mov	ecx, DWORD PTR [ecx]
	fdiv	ST(0), ST(1)
	mov	ebx, DWORD PTR _A
	sub	ecx, edx
	add	ecx, eax
	lea	ecx, DWORD PTR [ebx+ecx*8-8]
	inc	eax
	add	edi, 8
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi]
	jl	SHORT $LN364@mobility_s
$LN88@mobility_s:

; 525  :         { for ( i = 0 ; i < dimf[hord] ; i++ )

	mov	ecx, DWORD PTR [esi]
	add	DWORD PTR tv3950[ebp], 4
	inc	edx
	cmp	edx, ecx
	jl	SHORT $LN89@mobility_s
	mov	eax, DWORD PTR _dimf
	jmp	SHORT $LN87@mobility_s
$LN356@mobility_s:
	fld	QWORD PTR __real@4008000000000000
$LN87@mobility_s:

; 528  :         }
; 529  :       cbt = cb_list[tord];
; 530  :       if ( cbt )

	mov	ecx, DWORD PTR _tord$89697[ebp]
	mov	esi, DWORD PTR _cb_list
	xor	edx, edx
	cmp	DWORD PTR [esi+ecx*4], edx
	je	$LN83@mobility_s

; 531  :         { for ( i = 0 ; i < dimf[tord] ; i++ )

	mov	ecx, DWORD PTR [eax+ecx*4]
	fstp	ST(0)
	mov	DWORD PTR _i$[ebp], edx
	cmp	ecx, edx
	jle	$LN73@mobility_s
	mov	edx, DWORD PTR _tail$89703[ebp]
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv4029[ebp], edx
	mov	edx, DWORD PTR _cbh$[ebp]
	add	edx, 296				; 00000128H
	mov	DWORD PTR tv4037[ebp], edx
	npad	4
$LL82@mobility_s:

; 532  :             for ( j = i ; j < dimf[tord] ; j++ )

	mov	edi, DWORD PTR _i$[ebp]
	cmp	edi, ecx
	jge	SHORT $LN81@mobility_s
	mov	ebx, DWORD PTR tv4037[ebp]
	npad	6
$LL357@mobility_s:

; 533  :                  A[IA[tail+i]-A_OFF+(j-i)] += 
; 534  :                   quadratic_form(cbh->vec[i],proj,cbh->vec[j],SDIM)/3; 

	mov	ecx, DWORD PTR _IA
	mov	eax, DWORD PTR tv4029[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	sub	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _A
	mov	ecx, DWORD PTR _web+616
	add	edx, edi
	lea	esi, DWORD PTR [eax+edx*8-8]
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR _proj$[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv4037[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edx
	call	_quadratic_form
	fdiv	QWORD PTR __real@4008000000000000
	mov	ecx, DWORD PTR _tord$89697[ebp]
	inc	edi
	add	esp, 16					; 00000010H
	add	ebx, 4
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	mov	eax, DWORD PTR _dimf
	cmp	edi, DWORD PTR [eax+ecx*4]
	jl	SHORT $LL357@mobility_s
$LN81@mobility_s:

; 531  :         { for ( i = 0 ; i < dimf[tord] ; i++ )

	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, 4
	add	DWORD PTR tv4029[ebp], ecx
	add	DWORD PTR tv4037[ebp], ecx
	mov	ecx, DWORD PTR _tord$89697[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, ecx
	jl	SHORT $LL82@mobility_s

; 535  :         }
; 536  :       else

	jmp	SHORT $LN73@mobility_s
$LN83@mobility_s:

; 537  :         { for ( i = 0 ; i < dimf[tord] ; i++ )

	lea	esi, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, edx
	jle	SHORT $LN411@mobility_s
	mov	eax, DWORD PTR _IA
	mov	edi, DWORD PTR _tail$89703[ebp]
	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR tv4134[ebp], eax
$LN75@mobility_s:

; 538  :             for ( j = i ; j < dimf[tord] ; j++ )

	mov	eax, edx
	cmp	edx, ecx
	jge	SHORT $LN74@mobility_s

; 537  :         { for ( i = 0 ; i < dimf[tord] ; i++ )

	mov	ecx, DWORD PTR _proj$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	lea	edi, DWORD PTR [ecx+edx*8]
$LN363@mobility_s:

; 539  :                  A[IA[tail+i]-A_OFF+(j-i)] += proj[i][j]/3;

	fld	QWORD PTR [edi]
	mov	ecx, DWORD PTR tv4134[ebp]
	mov	ecx, DWORD PTR [ecx]
	fdiv	ST(0), ST(1)
	mov	ebx, DWORD PTR _A
	sub	ecx, edx
	add	ecx, eax
	lea	ecx, DWORD PTR [ebx+ecx*8-8]
	inc	eax
	add	edi, 8
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi]
	jl	SHORT $LN363@mobility_s
$LN74@mobility_s:

; 537  :         { for ( i = 0 ; i < dimf[tord] ; i++ )

	mov	ecx, DWORD PTR [esi]
	add	DWORD PTR tv4134[ebp], 4
	inc	edx
	cmp	edx, ecx
	jl	SHORT $LN75@mobility_s
	mov	eax, DWORD PTR _dimf
$LN411@mobility_s:
	fstp	ST(0)
$LN73@mobility_s:

; 540  :         }
; 541  : 
; 542  :       if ( tail > head )

	mov	ecx, DWORD PTR _tail$89703[ebp]
	mov	ebx, DWORD PTR _head$89704[ebp]
	cmp	ecx, ebx
	jle	SHORT $LN69@mobility_s

; 543  :          { base = head; addend = tail; orda = tord; ordb = hord; }

	mov	esi, DWORD PTR _tord$89697[ebp]
	mov	DWORD PTR _base$89705[ebp], ebx
	mov	ebx, ecx
	mov	DWORD PTR _addend$89706[ebp], ecx
	mov	ecx, DWORD PTR _hord$89700[ebp]

; 544  :       else

	jmp	SHORT $LN482@mobility_s
$LN69@mobility_s:

; 545  :          { base = tail; addend = head; orda = hord; ordb = tord; }

	mov	esi, DWORD PTR _hord$89700[ebp]
	mov	DWORD PTR _base$89705[ebp], ecx
	mov	ecx, DWORD PTR _tord$89697[ebp]
	mov	DWORD PTR _addend$89706[ebp], ebx
$LN482@mobility_s:

; 546  : 
; 547  :       if ( (cbb = cb_list[ordb]) == NULL )

	mov	edx, DWORD PTR _cb_list
	mov	DWORD PTR _ordb$89710[ebp], ecx
	mov	ecx, DWORD PTR [edx+ecx*4]
	test	ecx, ecx
	jne	SHORT $LN67@mobility_s

; 548  :           q = proj; 

	mov	ecx, DWORD PTR _proj$[ebp]

; 549  :       else 

	jmp	SHORT $LN66@mobility_s
$LN67@mobility_s:

; 550  :          { mat_mult(cbb->vec,proj,qq,dimf[ordb],SDIM,SDIM);

	mov	edx, DWORD PTR _web+616
	mov	edi, DWORD PTR _qq$[ebp]
	push	edx
	push	edx
	mov	edx, DWORD PTR _ordb$89710[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _proj$[ebp]
	push	eax
	push	edi
	push	edx
	add	ecx, 296				; 00000128H
	push	ecx
	call	_mat_mult

; 551  :           q = qq;

	mov	eax, DWORD PTR _dimf
	add	esp, 24					; 00000018H
	mov	ecx, edi
$LN66@mobility_s:

; 552  :          }
; 553  :       if ( (cba = cb_list[orda]) != NULL )

	mov	edx, DWORD PTR _cb_list
	mov	edx, DWORD PTR [edx+esi*4]
	test	edx, edx
	je	SHORT $LN65@mobility_s

; 554  :          { mat_mul_tr(q,cba->vec,qqq,dimf[ordb],SDIM,dimf[orda]);

	mov	edi, DWORD PTR [eax+esi*4]
	push	edi
	push	DWORD PTR _web+616
	mov	edi, DWORD PTR _ordb$89710[ebp]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR _qqq$[ebp]
	push	eax
	push	edi
	add	edx, 296				; 00000128H
	push	edx
	push	ecx
	call	_mat_mul_tr

; 555  :           q = qqq;

	mov	eax, DWORD PTR _dimf
	add	esp, 24					; 00000018H
	mov	ecx, edi
$LN65@mobility_s:

; 556  :          }
; 557  :          
; 558  :       /* seek column, add if not already there */
; 559  :       for ( i = 0 ; i < dimf[ordb] ; i++ )

	mov	edx, DWORD PTR _ordb$89710[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	mov	DWORD PTR _i$[ebp], 0
	jle	$LN358@mobility_s
	fld	QWORD PTR __real@4018000000000000
	mov	DWORD PTR tv4275[ebp], ecx
	mov	ecx, DWORD PTR _base$89705[ebp]
	lea	edx, DWORD PTR [ecx*4]
	mov	DWORD PTR tv4277[ebp], edx
$LN64@mobility_s:

; 560  :         {
; 561  :           for ( j = IA[base+i]-A_OFF ; j < IA[base+i+1]-A_OFF ; j++ )

	mov	ecx, DWORD PTR tv4277[ebp]
	mov	edx, DWORD PTR _IA
	mov	edi, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR [ecx+edx+4]
	dec	edi
	dec	edx
	cmp	edi, edx
	jge	SHORT $LN483@mobility_s
	inc	ebx
$LN377@mobility_s:

; 562  :             if ( (JA[j] == addend+A_OFF) || (JA[j] == EMPTY) ) break;

	mov	ecx, DWORD PTR _JA
	mov	ecx, DWORD PTR [ecx+edi*4]
	cmp	ecx, ebx
	je	SHORT $LN379@mobility_s
	cmp	ecx, -1
	je	SHORT $LN379@mobility_s

; 560  :         {
; 561  :           for ( j = IA[base+i]-A_OFF ; j < IA[base+i+1]-A_OFF ; j++ )

	inc	edi
	cmp	edi, edx
	jl	SHORT $LN377@mobility_s
$LN379@mobility_s:
	mov	ebx, DWORD PTR _addend$89706[ebp]

; 563  :           if ( j == IA[base+i+1]-A_OFF )

	cmp	edi, edx
$LN483@mobility_s:
	jne	SHORT $LN56@mobility_s

; 564  :             kb_error(1651,"Internal error: approx_curvature: cannot find edge in JA list.\n",RECOVERABLE);

	push	1
	fstp	ST(0)
	push	OFFSET ??_C@_0EA@GKBFBJOM@Internal?5error?3?5approx_curvature@
	push	1651					; 00000673H
	call	_kb_error
	fld	QWORD PTR __real@4018000000000000
	mov	eax, DWORD PTR _dimf
	add	esp, 12					; 0000000cH
$LN56@mobility_s:

; 565  : 
; 566  : 
; 567  :           for ( k = 0 ; k < dimf[orda] ; k++ )

	xor	ecx, ecx
	cmp	DWORD PTR [eax+esi*4], ecx
	jle	SHORT $LN63@mobility_s
	mov	edx, DWORD PTR _A
	mov	eax, DWORD PTR _JA
	lea	edx, DWORD PTR [edx+edi*8]
	lea	edi, DWORD PTR [eax+edi*4]
$LN55@mobility_s:

; 568  :                 { JA[j+k] = addend + A_OFF + k; /* in case first time */

	lea	eax, DWORD PTR [ebx+ecx+1]
	mov	DWORD PTR [edi], eax

; 569  :                   A[j+k] += q[i][k]/6;

	mov	eax, DWORD PTR tv4275[ebp]
	mov	eax, DWORD PTR [eax]
	fld	QWORD PTR [eax+ecx*8]
	inc	ecx
	fdiv	ST(0), ST(1)
	add	edi, 4
	add	edx, 8
	fadd	QWORD PTR [edx-8]
	fstp	QWORD PTR [edx-8]
	mov	eax, DWORD PTR _dimf
	cmp	ecx, DWORD PTR [eax+esi*4]
	jl	SHORT $LN55@mobility_s
$LN63@mobility_s:

; 556  :          }
; 557  :          
; 558  :       /* seek column, add if not already there */
; 559  :       for ( i = 0 ; i < dimf[ordb] ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, 4
	add	DWORD PTR tv4277[ebp], edx
	add	DWORD PTR tv4275[ebp], edx
	mov	edx, DWORD PTR _ordb$89710[ebp]
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+edx*4]
	jl	$LN64@mobility_s
	fstp	ST(0)
$LN358@mobility_s:
	mov	ecx, DWORD PTR _web+124
$LN112@mobility_s:

; 491  :   { FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR tv2488[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	mov	esi, DWORD PTR [edx]
	test	esi, 268435456				; 10000000H
	jne	$LL113@mobility_s
$LN111@mobility_s:

; 570  :                 }
; 571  :         }
; 572  :     }
; 573  :   }
; 574  : 
; 575  :   if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	jne	$LN49@mobility_s

; 576  :   { FOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR _web+272
	mov	edi, esi
	shr	edi, 28					; 0000001cH
	and	edi, 1
	je	$LN49@mobility_s
	mov	edx, DWORD PTR _web+236
$LL51@mobility_s:
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2781[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN50@mobility_s

; 577  :     {
; 578  :       REAL area = get_facet_area(f_id);

	push	esi
	call	_recalc_facet_area
	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR tv2781[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	fld	QWORD PTR [eax+40]
	add	esp, 4
	fstp	QWORD PTR _area$89779[ebp]

; 579  :       REAL s1s1,s2s2,s1s2;  /* dot products */
; 580  :       facetedge_id fe = get_facet_fe(f_id);

	test	edi, edi
	jne	SHORT $LN229@mobility_s
	xor	ecx, ecx
	mov	DWORD PTR _fe$89784[ebp], ecx
	jmp	SHORT $LN230@mobility_s
$LN229@mobility_s:
	mov	eax, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN228@mobility_s
	xor	eax, 134217728				; 08000000H
$LN228@mobility_s:
	mov	ecx, eax
	mov	DWORD PTR _fe$89784[ebp], eax
$LN230@mobility_s:

; 581  :       edge_id e_id1 = get_fe_edge(fe);

	mov	edi, DWORD PTR _web+460
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	eax, ecx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]

; 582  :       edge_id e_id2 = get_fe_edge(get_next_edge(fe));

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN235@mobility_s
	mov	esi, DWORD PTR [edx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN234@mobility_s
$LN235@mobility_s:
	mov	esi, DWORD PTR [edx+32]
$LN234@mobility_s:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [edx+20]

; 583  :       REAL side1[MAXCOORD],side2[MAXCOORD];
; 584  :       int m;
; 585  : 
; 586  :       /* calc normal projection matrix */
; 587  :       get_edge_side(e_id1,side1);

	lea	ecx, DWORD PTR _side1$89787[ebp]
	push	ecx
	push	eax
	call	_get_edge_side

; 588  :       get_edge_side(e_id2,side2);

	lea	edx, DWORD PTR _side2$89788[ebp]
	and	esi, 134217728				; 08000000H
	push	edx
	xor	esi, edi
	push	esi
	call	_get_edge_side

; 589  :       s1s1 = SDIM_dot(side1,side1);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _side1$89787[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _s1s1$89781[ebp]

; 590  :       s2s2 = SDIM_dot(side2,side2);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _side2$89788[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _s2s2$89782[ebp]

; 591  :       s1s2 = SDIM_dot(side1,side2);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _side2$89788[ebp]
	push	ecx
	lea	edx, DWORD PTR _side1$89787[ebp]
	push	edx
	call	_dot

; 592  :       for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	add	esp, 52					; 00000034H
	cmp	DWORD PTR _web+616, ecx
	jle	$LN451@mobility_s
	fld	QWORD PTR __real@bfd0000000000000
	mov	edi, DWORD PTR _proj$[ebp]
	fldz
	fld	QWORD PTR _s2s2$89782[ebp]
	fld	QWORD PTR _s1s1$89781[ebp]
	fld	QWORD PTR _area$89779[ebp]
$LN361@mobility_s:

; 593  :       { 
; 594  :          if ( effective_area_flag )

	cmp	DWORD PTR _effective_area_flag, 0
	mov	esi, DWORD PTR _web+616
	je	SHORT $LN43@mobility_s

; 595  :           for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN383@mobility_s
	mov	edx, DWORD PTR [edi+ecx*4]
$LN42@mobility_s:

; 596  :              proj[i][j] = -(s2s2*side1[i]*side1[j] - s1s2*side1[i]*side2[j] 
; 597  :                 - s1s2*side2[i]*side1[j] + s1s1*side2[i]*side2[j])/4/area;

	fld	ST(2)
	inc	eax
	fmul	QWORD PTR _side1$89787[ebp+ecx*8]
	fmul	QWORD PTR _side1$89787[ebp+eax*8-8]
	fld	ST(6)
	fmul	QWORD PTR _side1$89787[ebp+ecx*8]
	fmul	QWORD PTR _side2$89788[ebp+eax*8-8]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR _side2$89788[ebp+ecx*8]
	fmul	ST(0), ST(7)
	fmul	QWORD PTR _side1$89787[ebp+eax*8-8]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR _side2$89788[ebp+ecx*8]
	fmul	ST(0), ST(3)
	fmul	QWORD PTR _side2$89788[ebp+eax*8-8]
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(5)
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [edx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN42@mobility_s

; 598  :           else

	jmp	SHORT $LN383@mobility_s
$LN43@mobility_s:

; 599  :              for ( j = 0 ; j < SDIM ; j++ ) proj[i][j] = 0.0;

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN383@mobility_s

; 592  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR [edi+ecx*4]
$LN469@mobility_s:

; 599  :              for ( j = 0 ; j < SDIM ; j++ ) proj[i][j] = 0.0;

	fxch	ST(3)
	inc	edx
	fst	QWORD PTR [eax]
	add	eax, 8
	fxch	ST(3)
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LN469@mobility_s
$LN383@mobility_s:

; 592  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR [edi+ecx*4]

; 600  :          proj[i][i] += area;

	fld	QWORD PTR [eax+ecx*8]
	lea	eax, DWORD PTR [eax+ecx*8]
	fadd	ST(0), ST(1)
	inc	ecx
	fstp	QWORD PTR [eax]
	cmp	ecx, DWORD PTR _web+616
	jl	$LN361@mobility_s

; 592  :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(5)
	fstp	ST(4)
	fstp	ST(3)
	fstp	ST(2)
	fstp	ST(0)
$LN451@mobility_s:

; 601  :       }
; 602  :       for ( m = 0 ; m < 3 ; m++, fe = get_next_edge(fe) )

	mov	edx, DWORD PTR _dimf
	fstp	ST(0)
	mov	DWORD PTR tv1882[ebp], 3
$LL240@mobility_s:

; 603  :         { int tord = loc_ordinal(get_fe_tailv(fe));

	mov	ecx, DWORD PTR _fe$89784[ebp]
	mov	esi, DWORD PTR _web+460
	mov	edi, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2804[ebp], eax
	mov	eax, DWORD PTR [eax+esi]
	mov	eax, DWORD PTR [eax+20]
	mov	esi, DWORD PTR _dymem
	and	ecx, 134217728				; 08000000H
	xor	eax, ecx
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+esi+304]
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN247@mobility_s
	mov	ebx, DWORD PTR _web+636
	lea	esi, DWORD PTR [esi+ebx*4]
	mov	esi, DWORD PTR [esi+ecx]
	jmp	SHORT $LN246@mobility_s
$LN247@mobility_s:
	mov	esi, DWORD PTR [ecx+esi]
$LN246@mobility_s:
	test	esi, 268435456				; 10000000H
	je	SHORT $LN192@mobility_s
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN253@mobility_s
	mov	ebx, DWORD PTR _web+636
	lea	esi, DWORD PTR [esi+ebx*4]
	mov	esi, DWORD PTR [esi+ecx]
	and	esi, 134217727				; 07ffffffH
	mov	ebx, esi
	mov	DWORD PTR _tord$89804[ebp], esi
	jmp	SHORT $LN193@mobility_s
$LN253@mobility_s:
	mov	esi, DWORD PTR [ecx+esi]
	and	esi, 134217727				; 07ffffffH
	mov	ebx, esi
	mov	DWORD PTR _tord$89804[ebp], esi
	jmp	SHORT $LN193@mobility_s
$LN192@mobility_s:
	or	ebx, -1
	mov	DWORD PTR _tord$89804[ebp], ebx
$LN193@mobility_s:

; 604  :           int hord = loc_ordinal(get_fe_headv(fe));

	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN259@mobility_s
	mov	esi, DWORD PTR [ecx+esi]
	jmp	SHORT $LN258@mobility_s
$LN259@mobility_s:
	mov	edi, DWORD PTR _web+636
	lea	esi, DWORD PTR [esi+edi*4]
	mov	esi, DWORD PTR [esi+ecx]
	mov	edi, DWORD PTR _web+124
$LN258@mobility_s:
	test	esi, 268435456				; 10000000H
	je	SHORT $LN194@mobility_s
	test	eax, 134217728				; 08000000H
	je	SHORT $LN265@mobility_s
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [ecx+eax]
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN484@mobility_s
$LN265@mobility_s:
	mov	esi, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	lea	eax, DWORD PTR [eax+esi*4]
	mov	ecx, DWORD PTR [eax+ecx]
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN484@mobility_s
$LN194@mobility_s:
	or	ecx, -1
$LN484@mobility_s:

; 605  :           int tail = IA_INV[tord];

	mov	eax, DWORD PTR _IA_INV
	mov	esi, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _hord$89807[ebp], ecx

; 606  :           int head = IA_INV[hord];

	mov	ecx, DWORD PTR [eax+ecx*4]

; 607  :           int base,addend;
; 608  :           int orda,ordb;
; 609  :       
; 610  :           /* add to vertex stars */
; 611  :           cb = cb_list[tord];

	mov	eax, DWORD PTR _cb_list
	mov	DWORD PTR _head$89811[ebp], ecx
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _tail$89810[ebp], esi

; 612  :           if ( cb )

	test	ecx, ecx
	je	$LN32@mobility_s

; 613  :             { for ( i = 0 ; i < dimf[tord] ; i++ )

	mov	eax, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR _i$[ebp], 0
	test	eax, eax
	jle	$LN360@mobility_s
	add	esi, esi
	add	esi, esi
	add	ecx, 296				; 00000128H
	mov	DWORD PTR tv4646[ebp], esi
	mov	DWORD PTR tv4654[ebp], ecx
$LL31@mobility_s:

; 614  :                 for ( j = i ; j < dimf[tord] ; j++ )

	mov	edi, DWORD PTR _i$[ebp]
	cmp	edi, eax
	jge	SHORT $LN30@mobility_s
	mov	ebx, DWORD PTR tv4654[ebp]
	npad	6
$LL359@mobility_s:

; 615  :                  A[IA[tail+i]-A_OFF+(j-i)] += 
; 616  :                   quadratic_form(cb->vec[i],proj,cb->vec[j],SDIM)/6; 

	mov	edx, DWORD PTR _IA
	mov	ecx, DWORD PTR tv4646[ebp]
	mov	eax, DWORD PTR [ecx+edx]
	sub	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _A
	mov	edx, DWORD PTR _web+616
	add	eax, edi
	lea	esi, DWORD PTR [ecx+eax*8-8]
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _proj$[ebp]
	push	edx
	mov	edx, DWORD PTR tv4654[ebp]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	eax
	call	_quadratic_form
	fdiv	QWORD PTR __real@4018000000000000
	mov	ecx, DWORD PTR _tord$89804[ebp]
	inc	edi
	add	esp, 16					; 00000010H
	add	ebx, 4
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	mov	edx, DWORD PTR _dimf
	cmp	edi, DWORD PTR [edx+ecx*4]
	jl	SHORT $LL359@mobility_s
$LN30@mobility_s:

; 613  :             { for ( i = 0 ; i < dimf[tord] ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, 4
	add	DWORD PTR tv4646[ebp], eax
	add	DWORD PTR tv4654[ebp], eax
	mov	eax, DWORD PTR _tord$89804[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, eax
	jl	$LL31@mobility_s

; 617  :             }
; 618  :           else

	mov	ebx, DWORD PTR _tord$89804[ebp]
	jmp	SHORT $LN360@mobility_s
$LN32@mobility_s:

; 619  :             { for ( i = 0 ; i < dimf[tord] ; i++ )

	mov	ecx, DWORD PTR [edx+ebx*4]
	lea	edi, DWORD PTR [edx+ebx*4]
	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN360@mobility_s
	mov	edx, DWORD PTR _tail$89810[ebp]
	fld	QWORD PTR __real@4018000000000000
	mov	eax, DWORD PTR _IA
	lea	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv4752[ebp], edx
$LN24@mobility_s:

; 620  :                 for ( j = i ; j < dimf[tord] ; j++ )

	mov	eax, esi
	cmp	esi, ecx
	jge	SHORT $LN23@mobility_s

; 619  :             { for ( i = 0 ; i < dimf[tord] ; i++ )

	mov	ecx, DWORD PTR _proj$[ebp]
	mov	edx, DWORD PTR [ecx+esi*4]
	lea	edx, DWORD PTR [edx+esi*8]
$LN362@mobility_s:

; 621  :                  A[IA[tail+i]-A_OFF+(j-i)] += proj[i][j]/6;

	fld	QWORD PTR [edx]
	mov	ebx, DWORD PTR tv4752[ebp]
	fdiv	ST(0), ST(1)
	mov	ecx, eax
	sub	ecx, esi
	add	ecx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR _A
	lea	ecx, DWORD PTR [ebx+ecx*8-8]
	inc	eax
	add	edx, 8
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR [edi]
	jl	SHORT $LN362@mobility_s

; 620  :                 for ( j = i ; j < dimf[tord] ; j++ )

	mov	ebx, DWORD PTR _tord$89804[ebp]
$LN23@mobility_s:

; 619  :             { for ( i = 0 ; i < dimf[tord] ; i++ )

	mov	ecx, DWORD PTR [edi]
	add	DWORD PTR tv4752[ebp], 4
	inc	esi
	cmp	esi, ecx
	jl	SHORT $LN24@mobility_s
	mov	edx, DWORD PTR _dimf
	fstp	ST(0)
$LN360@mobility_s:

; 622  :             }
; 623  : 
; 624  :           if ( tail > head )

	mov	eax, DWORD PTR _head$89811[ebp]
	cmp	DWORD PTR _tail$89810[ebp], eax
	jle	SHORT $LN18@mobility_s

; 625  :              { base = head; addend = tail; orda = tord; ordb = hord; }

	mov	edi, ebx
	mov	ebx, DWORD PTR _hord$89807[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR _tail$89810[ebp]
	mov	DWORD PTR _ordb$89815[ebp], ebx

; 626  :           else

	jmp	SHORT $LN485@mobility_s
$LN18@mobility_s:

; 627  :              { base = tail; addend = head; orda = hord; ordb = tord; }

	mov	ecx, DWORD PTR _tail$89810[ebp]
	mov	eax, DWORD PTR _head$89811[ebp]
	mov	edi, DWORD PTR _hord$89807[ebp]
	mov	DWORD PTR _ordb$89815[ebp], ebx
$LN485@mobility_s:
	mov	DWORD PTR _base$89812[ebp], ecx

; 628  : 
; 629  :           if ( (cbb = cb_list[ordb]) == NULL )

	mov	ecx, DWORD PTR _cb_list
	mov	DWORD PTR _addend$89813[ebp], eax
	mov	eax, DWORD PTR [ecx+ebx*4]
	test	eax, eax
	jne	SHORT $LN16@mobility_s

; 630  :               q = proj; 

	mov	eax, DWORD PTR _proj$[ebp]

; 631  :           else 

	jmp	SHORT $LN15@mobility_s
$LN16@mobility_s:

; 632  :              { mat_mult(cbb->vec,proj,qq,dimf[ordb],SDIM,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	esi, DWORD PTR _qq$[ebp]
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR _proj$[ebp]
	push	edx
	push	esi
	push	ecx
	add	eax, 296				; 00000128H
	push	eax
	call	_mat_mult

; 633  :               q = qq;

	mov	edx, DWORD PTR _dimf
	add	esp, 24					; 00000018H
	mov	eax, esi
$LN15@mobility_s:

; 634  :              }
; 635  :           if ( (cba = cb_list[orda]) != NULL )

	mov	ecx, DWORD PTR _cb_list
	mov	ecx, DWORD PTR [ecx+edi*4]
	test	ecx, ecx
	je	SHORT $LN14@mobility_s

; 636  :              { mat_mul_tr(q,cba->vec,qqq,dimf[ordb],SDIM,dimf[orda]);

	mov	esi, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR [edx+ebx*4]
	push	esi
	mov	esi, DWORD PTR _web+616
	push	esi
	mov	esi, DWORD PTR _qqq$[ebp]
	push	edx
	push	esi
	add	ecx, 296				; 00000128H
	push	ecx
	push	eax
	call	_mat_mul_tr

; 637  :               q = qqq;

	mov	edx, DWORD PTR _dimf
	add	esp, 24					; 00000018H
	mov	eax, esi
$LN14@mobility_s:

; 638  :              }
; 639  : 
; 640  :           /* seek column, add if not already there */
; 641  :           if ( dimf[orda] > 0 )

	cmp	DWORD PTR [edx+edi*4], 0
	jle	$LN34@mobility_s

; 642  :             for ( i = 0 ; i < dimf[ordb] ; i++ )

	cmp	DWORD PTR [edx+ebx*4], 0
	mov	DWORD PTR _i$[ebp], 0
	jle	$LN34@mobility_s
	mov	DWORD PTR tv4892[ebp], eax
	mov	eax, DWORD PTR _base$89812[ebp]
	lea	ecx, DWORD PTR [eax*4]
	mov	DWORD PTR tv4894[ebp], ecx
	npad	10
$LL12@mobility_s:

; 643  :             {
; 644  :               for ( j = IA[base+i]-A_OFF ; j < IA[base+i+1]-A_OFF ; j++ )

	mov	ecx, DWORD PTR _IA
	mov	eax, DWORD PTR tv4894[ebp]
	mov	esi, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [eax+ecx+4]
	dec	esi
	dec	ecx
	cmp	esi, ecx
	jge	SHORT $LN486@mobility_s
	mov	ebx, DWORD PTR _addend$89813[ebp]
	inc	ebx
	npad	6
$LL365@mobility_s:

; 645  :                 if ( (JA[j] == addend+A_OFF) || (JA[j] == EMPTY) ) break;

	mov	eax, DWORD PTR _JA
	mov	eax, DWORD PTR [eax+esi*4]
	cmp	eax, ebx
	je	SHORT $LN366@mobility_s
	cmp	eax, -1
	je	SHORT $LN366@mobility_s

; 643  :             {
; 644  :               for ( j = IA[base+i]-A_OFF ; j < IA[base+i+1]-A_OFF ; j++ )

	inc	esi
	cmp	esi, ecx
	jl	SHORT $LL365@mobility_s
$LN366@mobility_s:

; 646  :               if ( j == IA[base+i+1]-A_OFF )

	cmp	esi, ecx
$LN486@mobility_s:
	jne	SHORT $LN371@mobility_s

; 647  :                 kb_error(1652,"Internal error: approx_curvature: cannot find edge in JA list.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EA@GKBFBJOM@Internal?5error?3?5approx_curvature@
	push	1652					; 00000674H
	call	_kb_error
	mov	edx, DWORD PTR _dimf
	add	esp, 12					; 0000000cH
$LN371@mobility_s:

; 648  : 
; 649  : 
; 650  :               for ( k = 0 ; k < dimf[orda] ; k++ )

	xor	eax, eax
	cmp	DWORD PTR [edx+edi*4], eax
	jle	SHORT $LN11@mobility_s
	mov	ecx, DWORD PTR _A
	mov	edx, DWORD PTR _JA
	mov	ebx, DWORD PTR _addend$89813[ebp]
	lea	ecx, DWORD PTR [ecx+esi*8]
	lea	esi, DWORD PTR [edx+esi*4]
$LL3@mobility_s:

; 651  :                     { JA[j+k] = addend + A_OFF + k; /* in case first time */

	lea	edx, DWORD PTR [ebx+eax+1]
	mov	DWORD PTR [esi], edx

; 652  :                       A[j+k] += q[i][k]/12;

	mov	edx, DWORD PTR tv4892[ebp]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [edx+eax*8]
	inc	eax
	fdiv	QWORD PTR __real@4028000000000000
	add	esi, 4
	add	ecx, 8
	fadd	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
	mov	edx, DWORD PTR _dimf
	cmp	eax, DWORD PTR [edx+edi*4]
	jl	SHORT $LL3@mobility_s
$LN11@mobility_s:

; 642  :             for ( i = 0 ; i < dimf[ordb] ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, 4
	add	DWORD PTR tv4894[ebp], ecx
	add	DWORD PTR tv4892[ebp], ecx
	mov	ecx, DWORD PTR _ordb$89815[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [edx+ecx*4]
	jl	$LL12@mobility_s
$LN34@mobility_s:

; 601  :       }
; 602  :       for ( m = 0 ; m < 3 ; m++, fe = get_next_edge(fe) )

	test	DWORD PTR _fe$89784[ebp], 134217728	; 08000000H
	je	SHORT $LN241@mobility_s
	mov	eax, DWORD PTR tv2804[ebp]
	mov	ecx, DWORD PTR _web+460
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN487@mobility_s
$LN241@mobility_s:
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR tv2804[ebp]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [ecx+32]
$LN487@mobility_s:
	dec	DWORD PTR tv1882[ebp]
	mov	DWORD PTR _fe$89784[ebp], eax
	jne	$LL240@mobility_s
	mov	edx, DWORD PTR _web+236
$LN50@mobility_s:

; 576  :   { FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR tv2781[ebp]
	mov	eax, DWORD PTR [ecx+edx]
	mov	esi, DWORD PTR [eax]
	mov	edi, esi
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	$LL51@mobility_s
$LN49@mobility_s:

; 653  :                     }
; 654  :             }
; 655  :         }
; 656  :     }
; 657  :   }
; 658  : 
; 659  : #ifdef GDEBUG
; 660  : /* some debug printing */
; 661  : { REAL x;
; 662  : printf("IA: ");
; 663  : for ( i = 0 ; i <= N ; i++ ) printf(" %d",IA[i]);
; 664  : printf("\nJA: ");
; 665  : for ( i = 0 ; i < count ; i++ ) printf(" %d",JA[i]);
; 666  : printf("\n");
; 667  : for ( i = 0 ; i < N ; i++ ) 
; 668  :   { int j,k,m;
; 669  :      for ( m = 0 ; m < i ; m++ ) printf("            ");
; 670  :      for ( m = i,  j = 0, k = IA[i]-A_OFF ; m < N /* j < IA[i+1]-IA[i] */; m++ )
; 671  :         if ( (m == JA[k]-A_OFF) && (k < IA[i+1]-A_OFF) )
; 672  :           { printf(" %8.6g",(DOUBLE)A[k]); k++; j++; }
; 673  :         else printf(" %8.6g",0.0);
; 674  :      printf("\n");
; 675  :   }
; 676  : }
; 677  : #endif
; 678  : 
; 679  : #ifdef FORT
; 680  :   NSP = 8*mobN + 16*Total_entries;

	mov	ecx, DWORD PTR _mobN
	mov	edx, DWORD PTR _Total_entries$[ebp]
	lea	eax, DWORD PTR [ecx+edx*2]
	add	eax, eax

; 681  :   ISP = (integer *)temp_calloc(NSP,sizeof(integer));

	push	681					; 000002a9H
	add	eax, eax
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	add	eax, eax
	push	4
	push	eax
	mov	DWORD PTR _NSP, eax
	call	_kb_temp_calloc

; 682  :   /*  Call ODRV to perform the reordering on A */
; 683  :         PATH = 2;          
; 684  :         odrv_( &mobN, IA,JA,A, P,IP, &NSP,ISP, &PATH, &FLAG );

	lea	ecx, DWORD PTR _FLAG$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _P
	lea	edx, DWORD PTR _PATH$[ebp]
	push	edx
	mov	edx, DWORD PTR _A
	push	eax
	push	OFFSET _NSP
	mov	DWORD PTR _ISP, eax
	mov	eax, DWORD PTR _IP
	push	eax
	mov	eax, DWORD PTR _JA
	push	ecx
	mov	ecx, DWORD PTR _IA
	push	edx
	push	eax
	push	ecx
	push	OFFSET _mobN
	mov	DWORD PTR _PATH$[ebp], 2
	call	_odrv_

; 685  :         odrv_flag_check(FLAG,mobN);

	mov	edx, DWORD PTR _mobN
	mov	eax, DWORD PTR _FLAG$[ebp]
	push	edx
	push	eax
	call	_odrv_flag_check

; 686  : 
; 687  :   /*  Call SDRVMD to compute the factorization */
; 688  :       {  RSP = (REAL *) ISP;

	mov	eax, DWORD PTR _ISP
	add	esp, 64					; 00000040H

; 689  :           PATH = 5; /* SSF and SNF only */
; 690  :           sdrvmd_(&mobN,P,IP,IA,JA,A,NULL,NULL,&NSP,ISP,RSP,&ESP, &PATH,&FLAG,&EMAX);

	lea	ecx, DWORD PTR _EMAX$[ebp]
	push	ecx
	lea	edx, DWORD PTR _FLAG$[ebp]
	push	edx
	lea	ecx, DWORD PTR _PATH$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _JA
	lea	edx, DWORD PTR _ESP$[ebp]
	push	edx
	mov	edx, DWORD PTR _IA
	push	eax
	push	eax
	push	OFFSET _NSP
	push	0
	push	0
	mov	DWORD PTR _RSP, eax
	mov	eax, DWORD PTR _A
	push	eax
	mov	eax, DWORD PTR _IP
	push	ecx
	mov	ecx, DWORD PTR _P
	push	edx
	push	eax
	push	ecx
	push	OFFSET _mobN
	mov	DWORD PTR _PATH$[ebp], 5
	call	_sdrvmd_

; 691  :           sdrv_flag_check(ESP,FLAG,mobN);

	mov	edx, DWORD PTR _mobN
	mov	eax, DWORD PTR _FLAG$[ebp]
	mov	ecx, DWORD PTR _ESP$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_sdrv_flag_check

; 692  :       }
; 693  : #else
; 694  :   kb_error(5423,"Internal error: Trying abandoned path in mobility_setup().\n",
; 695  :     RECOVERABLE);
; 696  : #endif
; 697  : 
; 698  :   free_matrix(proj);

	mov	edx, DWORD PTR _proj$[ebp]
	add	esp, 72					; 00000048H
	push	edx
	call	_free_matrix

; 699  :   free_matrix(qq);

	mov	eax, DWORD PTR _qq$[ebp]
	push	eax
	call	_free_matrix

; 700  :   free_matrix(qqq);

	mov	ecx, DWORD PTR _qqq$[ebp]
	push	ecx
	call	_free_matrix

; 701  : } /* end mobility_setup */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_mobility_setup ENDP
_TEXT	ENDS
PUBLIC	_conbasis_mult
; Function compile flags: /Ogtp
;	COMDAT _conbasis_mult
_TEXT	SEGMENT
tv288 = -8						; size = 4
_k$ = -8						; size = 4
tv259 = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_conbasis_mult PROC					; COMDAT

; 715  : {

	push	ebp
	mov	ebp, esp

; 716  :   vertex_id v_id;
; 717  :   int i=0;
; 718  :   int j;
; 719  :   int k = 0; /* place in X */
; 720  :   struct basis *cb;
; 721  : 
; 722  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	sub	esp, 8
	and	ecx, 1
	je	$LN11@conbasis_m
	push	ebx
	push	esi
	push	edi
	npad	4
$LL13@conbasis_m:
	mov	edx, eax
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv259[ebp], edx
	je	$LN12@conbasis_m

; 723  :      { int ord = loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN16@conbasis_m
	mov	ecx, edx
	jmp	SHORT $LN17@conbasis_m
$LN16@conbasis_m:
	or	ecx, -1
$LN17@conbasis_m:

; 724  :         int dim = dimf[ord];

	mov	eax, DWORD PTR _dimf
	mov	esi, DWORD PTR [eax+ecx*4]

; 725  :         k = ord*SDIM;

	mov	eax, DWORD PTR _web+616

; 726  :         i = IA_INV[ord];

	mov	edi, DWORD PTR _IA_INV
	imul	eax, ecx
	mov	ebx, DWORD PTR [edi+ecx*4]

; 727  :         if ( (cb = cb_list[ord]) != NULL )

	mov	edi, DWORD PTR _cb_list
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR _k$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN8@conbasis_m

; 728  :          { for ( j = 0 ; j < dim ; j++,i++ )

	test	esi, esi
	jle	$LN12@conbasis_m
	mov	edx, DWORD PTR _X$[ebp]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _Y$[ebp]
	mov	DWORD PTR tv288[ebp], eax
	lea	ebx, DWORD PTR [edx+ebx*8]
	lea	edi, DWORD PTR [ecx+296]
$LL27@conbasis_m:

; 729  :               Y[i] = SDIM_dot(X+k,cb->vec[j]);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR tv288[ebp]
	push	eax
	push	ecx
	push	edx
	call	_dot
	fstp	QWORD PTR [ebx]
	add	esp, 12					; 0000000cH
	add	edi, 4
	add	ebx, 8
	dec	esi
	jne	SHORT $LL27@conbasis_m

; 730  :           }
; 731  :         else /* just copy */

	mov	edx, DWORD PTR tv259[ebp]
	jmp	$LN12@conbasis_m
$LN8@conbasis_m:

; 732  :          for ( j = 0 ; j < dim ; j++,i++ )

	xor	edi, edi
	cmp	esi, 4
	jl	SHORT $LC25@conbasis_m
	mov	edx, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR _Y$[ebp]
	lea	edx, DWORD PTR [edx+eax*8]
	lea	eax, DWORD PTR [esi-4]
	shr	eax, 2
	inc	eax
	lea	edi, DWORD PTR [eax*4]
	lea	ecx, DWORD PTR [ecx+ebx*8+16]
	add	ebx, edi
$LL26@conbasis_m:

; 733  :           Y[i] = X[k+j];

	fld	QWORD PTR [edx]
	add	ecx, 32					; 00000020H
	fstp	QWORD PTR [ecx-48]
	add	edx, 32					; 00000020H
	dec	eax
	fld	QWORD PTR [edx-24]
	fstp	QWORD PTR [ecx-40]
	fld	QWORD PTR [edx-16]
	fstp	QWORD PTR [ecx-32]
	fld	QWORD PTR [edx-8]
	fstp	QWORD PTR [ecx-24]
	jne	SHORT $LL26@conbasis_m

; 732  :          for ( j = 0 ; j < dim ; j++,i++ )

	mov	eax, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR tv259[ebp]
$LC25@conbasis_m:
	cmp	edi, esi
	jge	SHORT $LN12@conbasis_m
	mov	ecx, DWORD PTR _Y$[ebp]
	lea	ecx, DWORD PTR [ecx+ebx*8]
	mov	ebx, DWORD PTR _X$[ebp]
	add	eax, edi
	lea	eax, DWORD PTR [ebx+eax*8]
	sub	esi, edi
	npad	6
$LC3@conbasis_m:

; 733  :           Y[i] = X[k+j];

	fld	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	dec	esi
	jne	SHORT $LC3@conbasis_m
$LN12@conbasis_m:

; 716  :   vertex_id v_id;
; 717  :   int i=0;
; 718  :   int j;
; 719  :   int k = 0; /* place in X */
; 720  :   struct basis *cb;
; 721  : 
; 722  :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [edx]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL13@conbasis_m
	pop	edi
	pop	esi
	pop	ebx
$LN11@conbasis_m:

; 734  :      }
; 735  : } // end void conbasis_mult()

	mov	esp, ebp
	pop	ebp
	ret	0
_conbasis_mult ENDP
_TEXT	ENDS
PUBLIC	_conbasis_tmult
; Function compile flags: /Ogtp
;	COMDAT _conbasis_tmult
_TEXT	SEGMENT
_i$ = -20						; size = 4
_dim$89912 = -16					; size = 4
_cb$ = -12						; size = 4
tv515 = -8						; size = 4
_j$ = -4						; size = 4
_k$ = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_conbasis_tmult PROC					; COMDAT

; 750  : {

	push	ebp
	mov	ebp, esp

; 751  :   vertex_id v_id;
; 752  :   int i;
; 753  :   int j,m;
; 754  :   int k = 0; /* place in Y */
; 755  :   struct basis *cb;
; 756  : 
; 757  :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	sub	esp, 20					; 00000014H
	and	ecx, 1
	je	$LN14@conbasis_t
	fldz
	push	ebx
	push	esi
	push	edi
$LN16@conbasis_t:
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv515[ebp], edx
	je	$LN15@conbasis_t

; 758  :      { int ord = loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN19@conbasis_t
	mov	eax, edx
	jmp	SHORT $LN20@conbasis_t
$LN19@conbasis_t:
	or	eax, -1
$LN20@conbasis_t:

; 759  :         int dim = dimf[ord];
; 760  :         k = ord*SDIM;

	mov	ebx, DWORD PTR _web+616
	mov	ecx, DWORD PTR _dimf
	imul	ebx, eax
	mov	edi, DWORD PTR [ecx+eax*4]

; 761  :         i = IA_INV[ord];

	mov	ecx, DWORD PTR _IA_INV
	mov	ecx, DWORD PTR [ecx+eax*4]

; 762  :         if ( (cb = cb_list[ord]) != NULL )

	mov	esi, DWORD PTR _cb_list
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR _dim$89912[ebp], edi
	mov	DWORD PTR _k$[ebp], ebx
	mov	DWORD PTR _i$[ebp], ecx
	mov	DWORD PTR _cb$[ebp], eax
	test	eax, eax
	je	$LN11@conbasis_t

; 763  :          { for ( m = 0 ; m < SDIM ; m++ )

	xor	esi, esi
	cmp	DWORD PTR _web+616, esi
	jle	$LN15@conbasis_t
	mov	edx, DWORD PTR _Y$[ebp]
	lea	eax, DWORD PTR [edx+ebx*8]
$LN35@conbasis_t:

; 765  :                 for ( j = 0 ; j < dim ; j++ )

	xor	edx, edx
	fst	QWORD PTR [eax]
	mov	DWORD PTR _j$[ebp], edx
	cmp	edi, 4
	jl	SHORT $LC30@conbasis_t

; 764  :               { Y[k+m] = 0.0; 

	mov	edx, DWORD PTR _X$[ebp]
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _cb$[ebp]
	add	edi, -4					; fffffffcH
	shr	edi, 2
	add	ecx, 300				; 0000012cH
	inc	edi
	lea	ebx, DWORD PTR [edi*4]
	mov	DWORD PTR _j$[ebp], ebx

; 765  :                 for ( j = 0 ; j < dim ; j++ )

$LN31@conbasis_t:

; 766  :                   Y[k+m] += X[i+j]*cb->vec[j][m];

	mov	ebx, DWORD PTR [ecx-4]
	fld	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR [ecx]
	fmul	QWORD PTR [edx]
	add	ecx, 16					; 00000010H
	add	edx, 32					; 00000020H
	dec	edi
	fadd	QWORD PTR [eax]
	fst	QWORD PTR [eax]
	fld	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR [ecx-12]
	fmul	QWORD PTR [edx-24]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [eax]
	fld	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR [ecx-8]
	fmul	QWORD PTR [edx-16]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [eax]
	fld	QWORD PTR [ebx+esi*8]
	fmul	QWORD PTR [edx-8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax]
	jne	SHORT $LN31@conbasis_t

; 764  :               { Y[k+m] = 0.0; 

	mov	edi, DWORD PTR _dim$89912[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
$LC30@conbasis_t:

; 765  :                 for ( j = 0 ; j < dim ; j++ )

	cmp	edx, edi
	jge	SHORT $LN9@conbasis_t
	mov	ebx, DWORD PTR _X$[ebp]
	add	ecx, edx
	lea	ecx, DWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR _cb$[ebp]
	lea	ebx, DWORD PTR [ebx+edx*4+296]
	mov	edx, edi
	sub	edx, DWORD PTR _j$[ebp]
$LC7@conbasis_t:

; 766  :                   Y[k+m] += X[i+j]*cb->vec[j][m];

	mov	edi, DWORD PTR [ebx]
	fld	QWORD PTR [edi+esi*8]
	add	ebx, 4
	fmul	QWORD PTR [ecx]
	add	ecx, 8
	dec	edx
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	jne	SHORT $LC7@conbasis_t

; 765  :                 for ( j = 0 ; j < dim ; j++ )

	mov	edi, DWORD PTR _dim$89912[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
$LN9@conbasis_t:

; 763  :          { for ( m = 0 ; m < SDIM ; m++ )

	inc	esi
	add	eax, 8
	cmp	esi, DWORD PTR _web+616
	jl	$LN35@conbasis_t

; 767  :               }
; 768  :            k += SDIM;
; 769  :          }
; 770  :         else /* just copy */

	jmp	SHORT $LN36@conbasis_t
$LN11@conbasis_t:

; 771  :          for ( j = 0 ; j < dim ; j++,i++ )

	xor	edx, edx
	cmp	edi, 4
	jl	SHORT $LC33@conbasis_t
	mov	eax, DWORD PTR _Y$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	lea	ebx, DWORD PTR [eax+ebx*8]
	lea	eax, DWORD PTR [edi-4]
	shr	eax, 2
	inc	eax
	lea	esi, DWORD PTR [edx+ecx*8+16]
	lea	edx, DWORD PTR [eax*4]
	add	ecx, edx
$LN34@conbasis_t:

; 772  :           Y[k+j] = X[i];

	fld	QWORD PTR [esi-16]
	add	esi, 32					; 00000020H
	fstp	QWORD PTR [ebx]
	add	ebx, 32					; 00000020H
	dec	eax
	fld	QWORD PTR [esi-40]
	fstp	QWORD PTR [ebx-24]
	fld	QWORD PTR [esi-32]
	fstp	QWORD PTR [ebx-16]
	fld	QWORD PTR [esi-24]
	fstp	QWORD PTR [ebx-8]
	jne	SHORT $LN34@conbasis_t

; 771  :          for ( j = 0 ; j < dim ; j++,i++ )

	mov	ebx, DWORD PTR _k$[ebp]
$LC33@conbasis_t:
	cmp	edx, edi
	jge	SHORT $LN36@conbasis_t
	mov	esi, DWORD PTR _Y$[ebp]
	lea	eax, DWORD PTR [edx+ebx]
	lea	eax, DWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR _X$[ebp]
	lea	ecx, DWORD PTR [esi+ecx*8]
	sub	edi, edx
$LC3@conbasis_t:

; 772  :           Y[k+j] = X[i];

	fld	QWORD PTR [ecx]
	add	ecx, 8
	fstp	QWORD PTR [eax]
	add	eax, 8
	dec	edi
	jne	SHORT $LC3@conbasis_t
$LN36@conbasis_t:

; 767  :               }
; 768  :            k += SDIM;
; 769  :          }
; 770  :         else /* just copy */

	mov	edx, DWORD PTR tv515[ebp]
$LN15@conbasis_t:

; 751  :   vertex_id v_id;
; 752  :   int i;
; 753  :   int j,m;
; 754  :   int k = 0; /* place in Y */
; 755  :   struct basis *cb;
; 756  : 
; 757  :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LN16@conbasis_t
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx
$LN14@conbasis_t:

; 773  :      }
; 774  : } // end conbasis_tmult()

	mov	esp, ebp
	pop	ebp
	ret	0
_conbasis_tmult ENDP
_TEXT	ENDS
PUBLIC	_mobility_mult
; Function compile flags: /Ogtp
;	COMDAT _mobility_mult
_TEXT	SEGMENT
_EMAX$ = -20						; size = 8
_ESP$ = -12						; size = 4
_PATH$ = -8						; size = 4
_FLAG$ = -4						; size = 4
_B$ = 8							; size = 4
_mobility_mult PROC					; COMDAT

; 787  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 788  :   integer PATH, FLAG=0;
; 789  :   integer ESP;
; 790  :   REAL EMAX;
; 791  :   REAL *temp = (REAL *)temp_calloc(mobN,sizeof(REAL));

	mov	eax, DWORD PTR _mobN
	push	esi
	push	edi
	push	791					; 00000317H
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	push	8
	push	eax
	mov	DWORD PTR _FLAG$[ebp], 0
	call	_kb_temp_calloc

; 792  : 
; 793  :   conbasis_mult(B,temp);

	mov	edi, DWORD PTR _B$[ebp]
	mov	esi, eax
	push	esi
	push	edi
	call	_conbasis_mult

; 794  : 
; 795  : #ifdef FORT
; 796  :   RSP = (REAL *) ISP;

	mov	eax, DWORD PTR _ISP

; 797  :   PATH = 3; /* SNS */
; 798  :   sdrvmd_(&mobN,P,IP,IA,JA,A,temp,temp,&NSP,ISP,RSP,&ESP, &PATH,&FLAG,&EMAX);

	lea	ecx, DWORD PTR _EMAX$[ebp]
	push	ecx
	lea	edx, DWORD PTR _FLAG$[ebp]
	push	edx
	lea	ecx, DWORD PTR _PATH$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _JA
	lea	edx, DWORD PTR _ESP$[ebp]
	push	edx
	mov	edx, DWORD PTR _IA
	push	eax
	push	eax
	push	OFFSET _NSP
	push	esi
	push	esi
	mov	DWORD PTR _RSP, eax
	mov	eax, DWORD PTR _A
	push	eax
	mov	eax, DWORD PTR _IP
	push	ecx
	mov	ecx, DWORD PTR _P
	push	edx
	push	eax
	push	ecx
	push	OFFSET _mobN
	mov	DWORD PTR _PATH$[ebp], 3
	call	_sdrvmd_

; 799  :   sdrv_flag_check(ESP,FLAG,mobN);

	mov	edx, DWORD PTR _mobN
	mov	eax, DWORD PTR _FLAG$[ebp]
	mov	ecx, DWORD PTR _ESP$[ebp]
	add	esp, 84					; 00000054H
	push	edx
	push	eax
	push	ecx
	call	_sdrv_flag_check

; 800  : #else
; 801  :   kb_error(5424,"Internal error: Trying abandoned path in mobility_mult().\n",
; 802  :     RECOVERABLE);
; 803  : #endif
; 804  :  
; 805  :   conbasis_tmult(temp,B);

	push	edi
	push	esi
	call	_conbasis_tmult
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi

; 806  : } // end mobility_mult()

	mov	esp, ebp
	pop	ebp
	ret	0
_mobility_mult ENDP
_TEXT	ENDS
PUBLIC	_mobility_cleanup
EXTRN	_vgev:DWORD
EXTRN	_vgef:DWORD
; Function compile flags: /Ogtp
;	COMDAT _mobility_cleanup
_TEXT	SEGMENT
_mobility_cleanup PROC					; COMDAT

; 816  :   /* free stuff */
; 817  :   free_matrix(vgef); vgef = NULL;

	mov	eax, DWORD PTR _vgef
	push	esi
	push	eax
	call	_free_matrix

; 818  :   free_matrix(vgev); vgev = NULL;

	mov	ecx, DWORD PTR _vgev
	xor	esi, esi
	push	ecx
	mov	DWORD PTR _vgef, esi
	call	_free_matrix

; 819  :   temp_free((char *)IA); IA = NULL;

	mov	edx, DWORD PTR _IA
	push	edx
	mov	DWORD PTR _vgev, esi
	call	_temp_free

; 820  :   temp_free((char *)IA_INV); IA_INV = NULL;

	mov	eax, DWORD PTR _IA_INV
	push	eax
	mov	DWORD PTR _IA, esi
	call	_temp_free

; 821  :   temp_free((char *)A);  A = NULL;

	mov	ecx, DWORD PTR _A
	push	ecx
	mov	DWORD PTR _IA_INV, esi
	call	_temp_free

; 822  :   temp_free((char *)JA); JA = NULL;

	mov	edx, DWORD PTR _JA
	push	edx
	mov	DWORD PTR _A, esi
	call	_temp_free

; 823  :   temp_free((char *)IP); IP = NULL;

	mov	eax, DWORD PTR _IP
	push	eax
	mov	DWORD PTR _JA, esi
	call	_temp_free

; 824  :   temp_free((char *)P);  P = NULL;

	mov	ecx, DWORD PTR _P
	push	ecx
	mov	DWORD PTR _IP, esi
	call	_temp_free

; 825  : #ifdef FORT
; 826  :   temp_free((char *)ISP);    ISP = NULL;

	mov	edx, DWORD PTR _ISP
	push	edx
	mov	DWORD PTR _P, esi
	call	_temp_free

; 827  : #else
; 828  :   temp_free((char *)F);  F = NULL;
; 829  :   temp_free((char *)IW);  IW = NULL;
; 830  : #endif
; 831  :   temp_free((char *)cb_list);  cb_list = NULL;

	mov	eax, DWORD PTR _cb_list
	push	eax
	mov	DWORD PTR _ISP, esi
	call	_temp_free

; 832  :   if ( conbasis ) { temp_free((char *)conbasis); conbasis = NULL; }

	mov	eax, DWORD PTR _conbasis
	add	esp, 40					; 00000028H
	mov	DWORD PTR _cb_list, esi
	cmp	eax, esi
	je	SHORT $LN1@mobility_c
	push	eax
	call	_temp_free
	add	esp, 4
	mov	DWORD PTR _conbasis, esi
$LN1@mobility_c:

; 833  :   temp_free((char*)dimf); dimf = NULL;

	mov	ecx, DWORD PTR _dimf
	push	ecx
	call	_temp_free
	add	esp, 4
	mov	DWORD PTR _dimf, esi
	pop	esi

; 834  : } // end mobility_cleanup()

	ret	0
_mobility_cleanup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@DCDMHHCI@?$CF3d?4?5ratio?5?$CFf?5?6?$AA@ ; `string'
PUBLIC	_stability_test
EXTRN	_printf:PROC
EXTRN	_drand48:PROC
;	COMDAT ??_C@_0BA@DCDMHHCI@?$CF3d?4?5ratio?5?$CFf?5?6?$AA@
CONST	SEGMENT
??_C@_0BA@DCDMHHCI@?$CF3d?4?5ratio?5?$CFf?5?6?$AA@ DB '%3d. ratio %f ', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _stability_test
_TEXT	SEGMENT
_newmag$ = -16						; size = 8
_oldmag$ = -8						; size = 8
_stability_test PROC					; COMDAT

; 846  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi

; 847  :   doublereal *B;
; 848  :   int i;
; 849  :   REAL oldmag,newmag;
; 850  : 
; 851  :   mobility_setup();

	call	_mobility_setup

; 852  :   B  = (REAL *)temp_calloc(mobN,sizeof(REAL));  

	mov	eax, DWORD PTR _mobN
	push	852					; 00000354H
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc
	mov	esi, eax

; 853  :   for ( i = 0 ; i < mobN ; i++ ) B[i] = drand48(); /* random vector */

	mov	eax, DWORD PTR _mobN
	add	esp, 16					; 00000010H
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN4@stability_
$LL6@stability_:
	call	_drand48
	fstp	QWORD PTR [esi+edi*8]
	mov	eax, DWORD PTR _mobN
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL6@stability_
$LN4@stability_:

; 854  :   oldmag = dot(B,B,mobN);

	push	eax
	push	esi
	push	esi
	call	_dot
	fstp	QWORD PTR _oldmag$[ebp]
	add	esp, 12					; 0000000cH

; 855  :   for ( i = 0 ; i < 20 ; i++ )

	xor	edi, edi
$LL3@stability_:

; 856  :     {
; 857  :         mobility_mult(B);

	push	esi
	call	_mobility_mult

; 858  :         newmag = dot(B,B,mobN);

	mov	ecx, DWORD PTR _mobN
	push	ecx
	push	esi
	push	esi
	call	_dot
	fst	QWORD PTR _newmag$[ebp]

; 859  :         printf("%3d. ratio %f \n",i,(DOUBLE)sqrt(newmag/oldmag));

	fdiv	QWORD PTR _oldmag$[ebp]
	add	esp, 16					; 00000010H
	call	__CIsqrt
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	push	OFFSET ??_C@_0BA@DCDMHHCI@?$CF3d?4?5ratio?5?$CFf?5?6?$AA@
	call	_printf

; 860  :         oldmag = newmag;

	fld	QWORD PTR _newmag$[ebp]
	inc	edi
	fstp	QWORD PTR _oldmag$[ebp]
	add	esp, 16					; 00000010H
	cmp	edi, 20					; 00000014H
	jl	SHORT $LL3@stability_

; 861  :     }
; 862  :   mobility_cleanup();

	call	_mobility_cleanup

; 863  :   temp_free((char *)B);

	push	esi
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi

; 864  : } // end stability_test()

	mov	esp, ebp
	pop	ebp
	ret	0
_stability_test ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_conf_edge_curv_energy
EXTRN	_matvec_mul:PROC
EXTRN	_det_adjoint:PROC
; Function compile flags: /Ogtp
;	COMDAT _conf_edge_curv_energy
_TEXT	SEGMENT
_t2t2$ = -152						; size = 8
_modulus$ = -144					; size = 8
_s1s1$ = -136						; size = 8
_a1$ = -128						; size = 8
_s1t2$ = -128						; size = 8
_det$ = -120						; size = 8
_s1s2$ = -120						; size = 8
_a2$ = -112						; size = 8
_s2s2$ = -112						; size = 8
tv472 = -104						; size = 4
_squares$ = -100					; size = 48
_center$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_conf_edge_curv_energy PROC				; COMDAT

; 880  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 881  :   REAL s1s1,s1s2,s1t2,s2s2,t2t2;
; 882  :   REAL det;
; 883  :   REAL a1,a2;
; 884  :   facetedge_id fe_s1,fe_s2,fe_t2;
; 885  :   edge_id e_id;
; 886  :   REAL modulus = globals(square_curvature_param)->value.real;

	mov	eax, DWORD PTR _square_curvature_param
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN13@conf_edge_
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN15@conf_edge_
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN14@conf_edge_
$LN15@conf_edge_:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN13@conf_edge_
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN14@conf_edge_
$LN13@conf_edge_:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN14@conf_edge_:
	fld	QWORD PTR [eax+64]

; 887  :   REAL **mat = dmatrix(0,SDIM,0,SDIM);

	mov	eax, DWORD PTR _web+616
	push	ebx
	fstp	QWORD PTR _modulus$[ebp]
	push	887					; 00000377H
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 888  :   REAL squares[MAXCOORD]; /* squares of edges */
; 889  :   REAL r_square;
; 890  :   REAL center[MAXCOORD];
; 891  :   int i;
; 892  : 
; 893  :   FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	add	esp, 24					; 00000018H
	mov	ebx, eax
	test	edx, 268435456				; 10000000H
	je	$LN8@conf_edge_
	push	esi
	push	edi
$LL10@conf_edge_:
	mov	ecx, DWORD PTR _web+124
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	esi, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [esi+8]
	and	ecx, 1
	xor	edi, edi
	or	ecx, edi
	mov	DWORD PTR tv472[ebp], eax
	je	$LN9@conf_edge_

; 894  :     {
; 895  :       if ( get_attr(e_id) & FIXED ) continue;

	mov	ecx, edx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 64					; 00000040H
	or	ecx, edi
	jne	$LN9@conf_edge_

; 896  : 
; 897  :       /* get edge vectors away from tail vertex */
; 898  :       fe_s1 = get_edge_fe(e_id);

	test	esi, esi
	jne	SHORT $LN20@conf_edge_
	xor	eax, eax
	jmp	SHORT $LN19@conf_edge_
$LN20@conf_edge_:
	mov	eax, DWORD PTR [esi+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN19@conf_edge_
	xor	eax, 134217728				; 08000000H
$LN19@conf_edge_:

; 899  :       fe_s2 = get_prev_edge(get_next_facet(fe_s1));

	mov	edi, DWORD PTR _web+460
	mov	esi, eax
	shr	esi, 27					; 0000001bH
	and	esi, 1
	je	SHORT $LN24@conf_edge_
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	ecx, DWORD PTR [edx+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN23@conf_edge_
$LN24@conf_edge_:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [edx+40]
$LN23@conf_edge_:
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN28@conf_edge_
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [ecx+32]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN27@conf_edge_
$LN28@conf_edge_:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [ecx+28]
$LN27@conf_edge_:

; 900  :       fe_s2 = inverse_id(fe_s2);

	xor	edi, 134217728				; 08000000H

; 901  :       fe_t2 = get_prev_edge(fe_s1);

	test	esi, esi
	je	SHORT $LN32@conf_edge_
	mov	esi, DWORD PTR [edx+32]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN31@conf_edge_
$LN32@conf_edge_:
	mov	esi, DWORD PTR [edx+28]
$LN31@conf_edge_:

; 902  :       fe_t2 = inverse_id(fe_t2);
; 903  :       get_fe_side(fe_s1,mat[0]);

	mov	ecx, DWORD PTR [ebx]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	ecx
	push	eax
	xor	esi, 134217728				; 08000000H
	call	_get_edge_side

; 904  :       get_fe_side(fe_s2,mat[1]);

	mov	edx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR _web+460
	mov	eax, edi
	push	edx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	and	edi, 134217728				; 08000000H
	xor	edi, DWORD PTR [edx+20]
	push	edi
	call	_get_edge_side

; 905  :       get_fe_side(fe_t2,mat[2]);

	mov	eax, DWORD PTR [ebx+8]
	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	push	eax
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [eax+20]
	push	esi
	call	_get_edge_side

; 906  : 
; 907  :       squares[0] = s1s1 = SDIM_dot(mat[0],mat[0]);

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [ebx]
	push	ecx
	push	eax
	push	eax
	call	_dot
	fst	QWORD PTR _s1s1$[ebp]

; 908  :       s1s2 = SDIM_dot(mat[0],mat[1]);

	mov	edx, DWORD PTR _web+616
	fstp	QWORD PTR _squares$[ebp]
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx]
	push	edx
	push	eax
	push	ecx
	call	_dot
	fstp	QWORD PTR _s1s2$[ebp]

; 909  :       s1t2 = SDIM_dot(mat[0],mat[2]);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [ebx]
	push	edx
	push	eax
	push	ecx
	call	_dot
	fstp	QWORD PTR _s1t2$[ebp]

; 910  :       squares[2] = t2t2 = SDIM_dot(mat[2],mat[2]);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [ebx+8]
	push	edx
	push	eax
	push	eax
	call	_dot
	fst	QWORD PTR _t2t2$[ebp]

; 911  :       squares[1] = s2s2 = SDIM_dot(mat[1],mat[1]);

	mov	ecx, DWORD PTR _web+616
	fstp	QWORD PTR _squares$[ebp+16]
	mov	eax, DWORD PTR [ebx+4]
	add	esp, 72					; 00000048H
	push	ecx
	push	eax
	push	eax
	call	_dot
	fst	QWORD PTR _s2s2$[ebp]
	fstp	QWORD PTR _squares$[ebp+8]
	add	esp, 12					; 0000000cH

; 912  : 
; 913  :       det = s1s1*t2t2 - s1t2*s1t2;

	fld	QWORD PTR _t2t2$[ebp]
	fmul	QWORD PTR _s1s1$[ebp]
	fld	QWORD PTR _s1t2$[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)

; 914  :       a1 = sqrt(det)/2;

	call	__CIsqrt
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR _a1$[ebp]

; 915  :       det = s1s1*s2s2 - s1s2*s1s2;

	fld	QWORD PTR _s2s2$[ebp]
	fmul	QWORD PTR _s1s1$[ebp]
	fld	QWORD PTR _s1s2$[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)

; 916  :       a2 = sqrt(det)/2;

	call	__CIsqrt
	fmul	QWORD PTR __real@3fe0000000000000

; 917  : 
; 918  :       det = det_adjoint(mat,SDIM);

	mov	edx, DWORD PTR _web+616
	push	edx
	push	ebx
	fstp	QWORD PTR _a2$[ebp]
	call	_det_adjoint
	fst	QWORD PTR _det$[ebp]

; 919  :       if ( det == 0.0 ) continue;

	fldz
	add	esp, 8
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN45@conf_edge_

; 920  :       matvec_mul(mat,squares,center,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	lea	eax, DWORD PTR _center$[ebp]
	push	eax
	lea	ecx, DWORD PTR _squares$[ebp]
	push	ecx
	push	ebx
	call	_matvec_mul

; 921  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 20					; 00000014H
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN1@conf_edge_
	fld	QWORD PTR _det$[ebp]
	fadd	ST(0), ST(0)
$LN3@conf_edge_:

; 922  :          center[i] /= 2*det;

	fld	QWORD PTR _center$[ebp+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _center$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN3@conf_edge_

; 921  :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN1@conf_edge_:

; 923  : 
; 924  :       r_square = SDIM_dot(center,center);

	push	ecx
	lea	edx, DWORD PTR _center$[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot

; 925  :       binary_tree_add(web.total_energy_addends,modulus/r_square*(a1+a2)/3);

	fld	QWORD PTR _a2$[ebp]
	fadd	QWORD PTR _a1$[ebp]
	add	esp, 4
	fld	QWORD PTR _modulus$[ebp]
	fdivrp	ST(2), ST(0)
	fmulp	ST(1), ST(0)
	fdiv	QWORD PTR __real@4008000000000000
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1248
	call	_binary_tree_add
	add	esp, 12					; 0000000cH
$LN45@conf_edge_:
	mov	eax, DWORD PTR tv472[ebp]
$LN9@conf_edge_:

; 888  :   REAL squares[MAXCOORD]; /* squares of edges */
; 889  :   REAL r_square;
; 890  :   REAL center[MAXCOORD];
; 891  :   int i;
; 892  : 
; 893  :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [edx]
	test	edx, 268435456				; 10000000H
	jne	$LL10@conf_edge_
	pop	edi
	pop	esi
$LN8@conf_edge_:

; 926  :     }
; 927  : 
; 928  :  free_matrix(mat);

	push	ebx
	call	_free_matrix

; 929  : } // end conf_edge_curv_energy()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 4
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_conf_edge_curv_energy ENDP
_TEXT	ENDS
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@c008000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_conf_edge_curv_force
EXTRN	_vec_mat_mul:PROC
;	COMDAT __real@3fd0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@c008000000000000
CONST	SEGMENT
__real@c008000000000000 DQ 0c008000000000000r	; -3
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\kusner.c
CONST	ENDS
;	COMDAT _conf_edge_curv_force
_TEXT	SEGMENT
_r_square$ = -400					; size = 8
_modulus$ = -392					; size = 8
_s2s2$ = -384						; size = 8
_t2t2$ = -376						; size = 8
_a2$ = -368						; size = 8
_s1s2$ = -360						; size = 8
_of$ = -352						; size = 4
_a1$ = -348						; size = 8
_s1t2$ = -340						; size = 8
_s1s1$ = -332						; size = 8
_det$ = -324						; size = 8
tv1103 = -320						; size = 4
_i$ = -320						; size = 4
tv1016 = -316						; size = 4
tv1090 = -312						; size = 4
$T91017 = -312						; size = 4
_s1f$ = -312						; size = 4
tv1833 = -308						; size = 4
tv1116 = -308						; size = 4
_t2f$ = -308						; size = 4
tv1987 = -304						; size = 4
tv1126 = -304						; size = 4
tv1050 = -304						; size = 4
tv1985 = -300						; size = 4
tv1141 = -300						; size = 4
_e_id$ = -300						; size = 4
tv1989 = -296						; size = 4
tv1125 = -296						; size = 4
_fe_t2$ = -296						; size = 4
_s1$ = -292						; size = 48
_s2$ = -244						; size = 48
_t2$ = -196						; size = 48
_squares$ = -148					; size = 48
_coeffs$ = -100						; size = 48
_center$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_conf_edge_curv_force PROC				; COMDAT

; 941  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 942  :   REAL s1[MAXCOORD],s2[MAXCOORD],t2[MAXCOORD];
; 943  :   REAL s1s1,s1s2,s1t2,s2s2,t2t2;
; 944  :   REAL a1,a2;
; 945  :   REAL det;
; 946  :   facetedge_id fe_s1,fe_s2,fe_t2;
; 947  :   edge_id e_id;
; 948  :   REAL *of,*s1f,*s2f,*t2f;  /* vertex force pointers */
; 949  :   int i;
; 950  :   REAL modulus = globals(square_curvature_param)->value.real;

	mov	eax, DWORD PTR _square_curvature_param
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN19@conf_edge_@2
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN21@conf_edge_@2
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN20@conf_edge_@2
$LN21@conf_edge_@2:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN19@conf_edge_@2
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN20@conf_edge_@2
$LN19@conf_edge_@2:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN20@conf_edge_@2:
	fld	QWORD PTR [eax+64]

; 951  :   REAL squares[MAXCOORD]; /* squares of edges */
; 952  :   REAL r_square;
; 953  :   REAL center[MAXCOORD];
; 954  :   REAL **mat = dmatrix(0,SDIM,0,SDIM);

	mov	eax, DWORD PTR _web+616
	push	esi
	fstp	QWORD PTR _modulus$[ebp]
	push	edi
	push	954					; 000003baH
	push	OFFSET ??_C@_08GHAIHECD@KUSNER?4C?$AA@
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 955  :   REAL coeffs[MAXCOORD];
; 956  : 
; 957  :   FOR_ALL_EDGES(e_id)

	mov	edi, DWORD PTR _web+160
	add	esp, 24					; 00000018H
	mov	esi, eax
	mov	DWORD PTR _e_id$[ebp], edi
	test	edi, 268435456				; 10000000H
	je	$LN14@conf_edge_@2
	push	ebx
	jmp	SHORT $LN16@conf_edge_@2
	npad	8
$LL83@conf_edge_@2:
	mov	edi, DWORD PTR _e_id$[ebp]
$LN16@conf_edge_@2:
	mov	ecx, DWORD PTR _web+124
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [edx+8]
	and	ecx, 1
	xor	ebx, ebx
	or	ecx, ebx
	mov	DWORD PTR tv1016[ebp], eax
	je	$LN15@conf_edge_@2

; 958  :     {
; 959  :       if ( get_attr(e_id) & FIXED ) continue;

	mov	ecx, edi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 64					; 00000040H
	or	ecx, ebx
	jne	$LN15@conf_edge_@2

; 960  : 
; 961  :       /* get edge vectors away from tail vertex */
; 962  :       fe_s1 = get_edge_fe(e_id);

	test	edx, edx
	je	SHORT $LN25@conf_edge_@2
$LN26@conf_edge_@2:
	mov	edx, DWORD PTR [edx+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN25@conf_edge_@2
	xor	edx, 134217728				; 08000000H
$LN25@conf_edge_@2:

; 963  :       fe_s2 = get_prev_edge(get_next_facet(fe_s1));

	mov	ebx, DWORD PTR _web+460
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	edi, edx
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ebx]
	shr	edi, 27					; 0000001bH
	and	edi, 1
	mov	DWORD PTR tv1050[ebp], eax
	je	SHORT $LN30@conf_edge_@2
	mov	eax, DWORD PTR [ecx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN29@conf_edge_@2
$LN30@conf_edge_@2:
	mov	eax, DWORD PTR [ecx+40]
$LN29@conf_edge_@2:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN34@conf_edge_@2
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR [eax+32]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN33@conf_edge_@2
$LN34@conf_edge_@2:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR [eax+28]
$LN33@conf_edge_@2:

; 964  :       fe_s2 = inverse_id(fe_s2);

	xor	ebx, 134217728				; 08000000H

; 965  :       fe_t2 = get_prev_edge(fe_s1);

	test	edi, edi
	je	SHORT $LN38@conf_edge_@2
	mov	eax, DWORD PTR [ecx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN37@conf_edge_@2
$LN38@conf_edge_@2:
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _fe_t2$[ebp], eax
$LN37@conf_edge_@2:

; 966  :       fe_t2 = inverse_id(fe_t2);
; 967  :       get_fe_side(fe_s1,mat[0]);

	mov	ecx, DWORD PTR [ecx+20]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _fe_t2$[ebp], eax
	mov	eax, edx
	mov	edx, DWORD PTR [esi]
	and	eax, 134217728				; 08000000H
	push	edx
	xor	ecx, eax
	push	ecx
	mov	DWORD PTR tv1090[ebp], eax
	call	_get_edge_side

; 968  :       get_fe_side(fe_s2,mat[1]);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _web+460
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+eax]
	push	edx
	mov	edx, DWORD PTR [ecx+20]
	and	ebx, 134217728				; 08000000H
	xor	edx, ebx
	push	edx
	mov	DWORD PTR tv1103[ebp], ebx
	call	_get_edge_side

; 969  :       get_fe_side(fe_t2,mat[2]);

	mov	ebx, DWORD PTR _fe_t2$[ebp]
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR _fe_t2$[ebp]
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	push	ecx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+edx]
	mov	edx, DWORD PTR [ecx+20]
	and	eax, 134217728				; 08000000H
	xor	edx, eax
	push	edx
	mov	DWORD PTR tv1116[ebp], eax
	call	_get_edge_side

; 970  :       get_fe_side(fe_s1,s1);

	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR tv1050[ebp]
	lea	eax, DWORD PTR _s1$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [eax+20]
	xor	ecx, DWORD PTR tv1090[ebp]
	push	ecx
	call	_get_edge_side

; 971  :       get_fe_side(fe_s2,s2);

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edi+eax]
	lea	edx, DWORD PTR _s2$[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+20]
	xor	edx, DWORD PTR tv1103[ebp]
	push	edx
	call	_get_edge_side

; 972  :       get_fe_side(fe_t2,t2);

	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [ebx+ecx]
	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+20]
	xor	eax, DWORD PTR tv1116[ebp]
	push	eax
	call	_get_edge_side

; 973  : 
; 974  :       squares[0] = s1s1 = SDIM_dot(mat[0],mat[0]);

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	eax
	push	eax
	call	_dot
	fst	QWORD PTR _s1s1$[ebp]

; 975  :       s1s2 = SDIM_dot(mat[0],mat[1]);

	mov	edx, DWORD PTR _web+616
	fstp	QWORD PTR _squares$[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	_dot
	add	esp, 72					; 00000048H

; 976  :       s1t2 = SDIM_dot(mat[0],mat[2]);

	mov	edx, DWORD PTR _web+616
	fstp	QWORD PTR _s1s2$[ebp]
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	_dot
	fstp	QWORD PTR _s1t2$[ebp]

; 977  :       squares[2] = t2t2 = SDIM_dot(mat[2],mat[2]);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [esi+8]
	push	edx
	push	eax
	push	eax
	call	_dot
	fst	QWORD PTR _t2t2$[ebp]

; 978  :       squares[1] = s2s2 = SDIM_dot(mat[1],mat[1]);

	mov	ecx, DWORD PTR _web+616
	fstp	QWORD PTR _squares$[ebp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	push	eax
	push	eax
	call	_dot
	fst	QWORD PTR _s2s2$[ebp]

; 979  : 
; 980  :       of = get_force(get_edge_tailv(e_id));

	mov	ecx, DWORD PTR _dymem
	fstp	QWORD PTR _squares$[ebp+8]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ecx+304]
	mov	ecx, DWORD PTR tv1016[ebp]
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR tv1125[ebp], edx
	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+edx]
	add	ecx, DWORD PTR tv1125[ebp]
	shr	eax, 27					; 0000001bH
	add	esp, 36					; 00000024H
	and	eax, 1
	mov	DWORD PTR tv1126[ebp], ecx
	je	SHORT $LN54@conf_edge_@2
	mov	edx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN94@conf_edge_@2
$LN54@conf_edge_@2:
	mov	ecx, DWORD PTR [ecx]
$LN94@conf_edge_@2:
	mov	edx, DWORD PTR _web+104
	mov	DWORD PTR $T91017[ebp], ecx
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ecx+784]
	mov	ecx, DWORD PTR $T91017[ebp]
	mov	DWORD PTR tv1141[ebp], edx
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR tv1141[ebp]
	add	ecx, edx
	mov	DWORD PTR _of$[ebp], ecx

; 981  :       s1f = get_force(get_edge_headv(e_id));

	test	eax, eax
	je	SHORT $LN58@conf_edge_@2
	mov	eax, DWORD PTR tv1126[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN57@conf_edge_@2
$LN58@conf_edge_@2:
	mov	ecx, DWORD PTR tv1126[ebp]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [ecx+eax*4]
$LN57@conf_edge_@2:
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	add	eax, edx

; 982  :       s2f = get_force(get_fe_headv(fe_s2));

	mov	edx, DWORD PTR _web+460
	mov	DWORD PTR _s1f$[ebp], eax
	mov	eax, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [eax+20]
	xor	eax, DWORD PTR tv1103[ebp]
	mov	edx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN64@conf_edge_@2
	mov	ecx, DWORD PTR tv1125[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
	jmp	SHORT $LN63@conf_edge_@2
$LN64@conf_edge_@2:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _web+636
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR tv1125[ebp]
	mov	eax, DWORD PTR [eax+ecx]
$LN63@conf_edge_@2:
	mov	edi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+eax*4]

; 983  :       t2f = get_force(get_fe_headv(fe_t2));

	mov	eax, DWORD PTR _web+460
	mov	eax, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [eax+20]
	xor	eax, DWORD PTR tv1116[ebp]
	add	edi, DWORD PTR tv1141[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN70@conf_edge_@2
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+edx]
	jmp	SHORT $LN69@conf_edge_@2
$LN70@conf_edge_@2:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN69@conf_edge_@2:

; 984  : 
; 985  :       det = s1s1*t2t2 - s1t2*s1t2;

	fld	QWORD PTR _t2t2$[ebp]
	mov	ecx, DWORD PTR _web+12
	fmul	QWORD PTR _s1s1$[ebp]
	and	eax, 134217727				; 07ffffffH
	fld	QWORD PTR _s1t2$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	add	eax, DWORD PTR tv1141[ebp]
	fmul	ST(0), ST(0)
	mov	DWORD PTR _t2f$[ebp], eax
	fsubp	ST(1), ST(0)

; 986  :       a1 = sqrt(det)/2;

	call	__CIsqrt
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR _a1$[ebp]

; 987  :       det = s1s1*s2s2 - s1s2*s1s2;

	fld	QWORD PTR _s2s2$[ebp]
	fmul	QWORD PTR _s1s1$[ebp]
	fld	QWORD PTR _s1s2$[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)

; 988  :       a2 = sqrt(det)/2;

	call	__CIsqrt
	fmul	QWORD PTR __real@3fe0000000000000

; 989  : 
; 990  :       det = det_adjoint(mat,SDIM);

	mov	edx, DWORD PTR _web+616
	push	edx
	push	esi
	fstp	QWORD PTR _a2$[ebp]
	call	_det_adjoint
	fst	QWORD PTR _det$[ebp]

; 991  :       if ( det == 0.0 ) continue;  /* flat */

	fldz
	add	esp, 8
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN81@conf_edge_@2

; 992  :       matvec_mul(mat,squares,center,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	lea	eax, DWORD PTR _center$[ebp]
	push	eax
	lea	ecx, DWORD PTR _squares$[ebp]
	push	ecx
	push	esi
	call	_matvec_mul

; 993  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 20					; 00000014H
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN7@conf_edge_@2
	fld	QWORD PTR _det$[ebp]
	fadd	ST(0), ST(0)
$LN9@conf_edge_@2:

; 994  :          center[i] /= 2*det; /* to complete inverse of mat and calc of center */

	fld	QWORD PTR _center$[ebp+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _center$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN9@conf_edge_@2

; 993  :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN7@conf_edge_@2:

; 995  : 
; 996  :       r_square = SDIM_dot(center,center);

	push	ecx
	lea	edx, DWORD PTR _center$[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	fstp	QWORD PTR _r_square$[ebp]

; 997  : 
; 998  :       /* gradients of various terms */
; 999  :       vec_mat_mul(center,mat,coeffs,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	lea	ecx, DWORD PTR _coeffs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _center$[ebp]
	push	esi
	push	edx
	call	_vec_mat_mul

; 1000 :       for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 32					; 00000020H
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN4@conf_edge_@2
	fld	QWORD PTR __real@4000000000000000
	fdiv	QWORD PTR _det$[ebp]
$LN6@conf_edge_@2:

; 1001 :          coeffs[i] *= 2/det; /* to complete inverse of mat */

	fld	QWORD PTR _coeffs$[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _coeffs$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN6@conf_edge_@2

; 1000 :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN4@conf_edge_@2:

; 1002 :       for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	ecx, ecx
	jle	$LN81@conf_edge_@2
	mov	eax, DWORD PTR _s1f$[ebp]
	fld	QWORD PTR _a2$[ebp]
	fadd	QWORD PTR _a1$[ebp]
	mov	ecx, eax
	fld	QWORD PTR __real@c008000000000000
	neg	ecx
	fld	QWORD PTR _r_square$[ebp]
	lea	edx, DWORD PTR _center$[ebp+ecx]
	fld	QWORD PTR _modulus$[ebp]
	mov	DWORD PTR tv1985[ebp], edx
	fld	QWORD PTR __real@3fd0000000000000
	lea	edx, DWORD PTR _s2$[ebp+ecx]
	fld	QWORD PTR __real@4008000000000000
	mov	DWORD PTR tv1987[ebp], edx
	lea	edx, DWORD PTR _t2$[ebp+ecx]
	mov	DWORD PTR tv1989[ebp], edx
	lea	edx, DWORD PTR _s1$[ebp+ecx]
	mov	ecx, DWORD PTR _t2f$[ebp]
	sub	ecx, eax
	mov	DWORD PTR tv1833[ebp], ecx
	mov	ecx, DWORD PTR _of$[ebp]
	sub	edi, eax
	sub	ecx, eax
	jmp	SHORT $LN3@conf_edge_@2
$LN82@conf_edge_@2:
	fld	QWORD PTR __real@c008000000000000
	fxch	ST(4)
$LN3@conf_edge_@2:

; 1003 :          { REAL f;  /* part of force */
; 1004 : 
; 1005 :             f = -modulus*coeffs[0]*(s1[i]-center[i])*(a1+a2)/3/r_square/r_square;

	fld	QWORD PTR [edx+eax]
	mov	ebx, DWORD PTR tv1985[ebp]
	fsub	QWORD PTR [ebx+eax]

; 1006 :             s1f[i] -= f;
; 1007 :             of[i]  += f;
; 1008 : 
; 1009 :             f = -modulus*coeffs[1]*(s2[i]-center[i])*(a1+a2)/3/r_square/r_square;

	mov	ebx, DWORD PTR tv1987[ebp]
	fld	QWORD PTR _coeffs$[ebp]
	fmul	ST(0), ST(4)
	fmulp	ST(1), ST(0)
	fmul	ST(0), ST(6)
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fld	QWORD PTR [eax]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax]
	fadd	QWORD PTR [ecx+eax]
	fstp	QWORD PTR [ecx+eax]
	fld	QWORD PTR [ebx+eax]
	mov	ebx, DWORD PTR tv1985[ebp]
	fsub	QWORD PTR [ebx+eax]

; 1010 :             s2f[i] -= f;
; 1011 :             of[i]  += f;
; 1012 : 
; 1013 :             f = -modulus*coeffs[2]*(t2[i]-center[i])*(a1+a2)/3/r_square/r_square;

	mov	ebx, DWORD PTR tv1989[ebp]
	fld	QWORD PTR _coeffs$[ebp+8]
	fmul	ST(0), ST(4)
	fmulp	ST(1), ST(0)
	fmul	ST(0), ST(6)
	fdiv	ST(0), ST(5)
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(4)
	fld	QWORD PTR [edi+eax]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edi+eax]
	fadd	QWORD PTR [ecx+eax]
	fstp	QWORD PTR [ecx+eax]
	fld	QWORD PTR [ebx+eax]
	mov	ebx, DWORD PTR tv1985[ebp]
	fsub	QWORD PTR [ebx+eax]

; 1014 :             t2f[i] -= f;

	mov	ebx, DWORD PTR tv1833[ebp]
	fld	QWORD PTR _coeffs$[ebp+16]
	fmul	ST(0), ST(4)
	fmulp	ST(1), ST(0)
	fmul	ST(0), ST(6)
	fdivrp	ST(5), ST(0)
	fxch	ST(4)
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(3)
	fld	QWORD PTR [ebx+eax]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [ebx+eax]

; 1015 :             of[i]  += f;
; 1016 : 
; 1017 :             f =  modulus*(s2s2*s1[i] - s1s2*s2[i])/4/a1/r_square/3;

	mov	ebx, DWORD PTR tv1987[ebp]
	fadd	QWORD PTR [ecx+eax]
	fstp	QWORD PTR [ecx+eax]
	fld	QWORD PTR [edx+eax]
	fmul	QWORD PTR _s2s2$[ebp]
	fld	QWORD PTR _s1s2$[ebp]
	fmul	QWORD PTR [ebx+eax]

; 1018 :             f += modulus*(t2t2*s1[i] - s1t2*t2[i])/4/a2/r_square/3;

	mov	ebx, DWORD PTR tv1989[ebp]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(1)
	fdiv	QWORD PTR _a1$[ebp]
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(4)
	fld	QWORD PTR [edx+eax]
	fmul	QWORD PTR _t2t2$[ebp]
	fld	QWORD PTR _s1t2$[ebp]
	fmul	QWORD PTR [ebx+eax]

; 1019 :             s1f[i] -= f;
; 1020 :             of[i]  += f;
; 1021 : 
; 1022 :             f = modulus*(s1s1*s2[i] - s1s2*s1[i])/4/a1/r_square/3;

	mov	ebx, DWORD PTR tv1987[ebp]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(3)
	fmul	ST(0), ST(2)
	fdiv	QWORD PTR _a2$[ebp]
	fdiv	ST(0), ST(4)
	fdiv	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [eax]
	fadd	QWORD PTR [ecx+eax]
	fstp	QWORD PTR [ecx+eax]
	fld	QWORD PTR _s1s1$[ebp]
	fmul	QWORD PTR [ebx+eax]
	fld	QWORD PTR [edx+eax]
	fmul	QWORD PTR _s1s2$[ebp]

; 1023 :             s2f[i] -= f;
; 1024 :             of[i]  += f;
; 1025 : 
; 1026 :             f = modulus*(s1s1*t2[i] - s1t2*s1[i])/4/a2/r_square/3;

	mov	ebx, DWORD PTR tv1989[ebp]
	add	eax, 8
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(1)
	fdiv	QWORD PTR _a1$[ebp]
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(4)
	fld	QWORD PTR [edi+eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edi+eax-8]
	fadd	QWORD PTR [ecx+eax-8]
	fstp	QWORD PTR [ecx+eax-8]
	fld	QWORD PTR _s1s1$[ebp]
	fmul	QWORD PTR [ebx+eax-8]

; 1027 :             t2f[i] -= f;

	mov	ebx, DWORD PTR tv1833[ebp]
	fld	QWORD PTR [edx+eax-8]
	fmul	QWORD PTR _s1t2$[ebp]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(1)
	fdiv	QWORD PTR _a2$[ebp]
	fdiv	ST(0), ST(3)
	fdiv	ST(0), ST(4)
	fld	QWORD PTR [ebx+eax-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [ebx+eax-8]
	mov	ebx, DWORD PTR _i$[ebp]
	inc	ebx

; 1028 :             of[i]  += f;

	fadd	QWORD PTR [ecx+eax-8]
	mov	DWORD PTR _i$[ebp], ebx
	fstp	QWORD PTR [ecx+eax-8]
	cmp	ebx, DWORD PTR _web+616
	jl	$LN82@conf_edge_@2

; 1002 :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)
$LN81@conf_edge_@2:
	mov	eax, DWORD PTR tv1016[ebp]
$LN15@conf_edge_@2:

; 955  :   REAL coeffs[MAXCOORD];
; 956  : 
; 957  :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _e_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL83@conf_edge_@2
	pop	ebx
$LN14@conf_edge_@2:

; 1029 :          }
; 1030 :     }
; 1031 : } // end conf_edge_curv_force()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_conf_edge_curv_force ENDP
_TEXT	ENDS
END
