; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\QUANTITY.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ackerman_forces
PUBLIC	_ackerman_energy
PUBLIC	_ackerman_init
PUBLIC	_null_q_grad
PUBLIC	_null_q_hess
PUBLIC	_q_facetedge_setup
PUBLIC	_q_body_setup
PUBLIC	_q_facet_setup
PUBLIC	_q_edge_setup
PUBLIC	_q_vertex_setup
PUBLIC	_compound_quant_list_head
PUBLIC	_q_setup
PUBLIC	_basic_gen_methods
PUBLIC	_el_list_timestamp
EXTRN	_bouzidi_hessian:PROC
EXTRN	_bouzidi_gradient:PROC
EXTRN	_bouzidi_value:PROC
EXTRN	_bouzidi_init:PROC
EXTRN	_sq_torsion_gradient:PROC
EXTRN	_sq_torsion_energy:PROC
EXTRN	_sq_torsion_init:PROC
EXTRN	_ddd_gamma_sq_gradient:PROC
EXTRN	_ddd_gamma_sq_energy:PROC
EXTRN	_ddd_gamma_sq_init:PROC
EXTRN	_curvature_binormal_force:PROC
EXTRN	_curvature_binormal_energy:PROC
EXTRN	_curvature_binormal_init:PROC
EXTRN	_carter_energy_gradient:PROC
EXTRN	_carter_energy:PROC
EXTRN	_carter_energy_init:PROC
EXTRN	_mughal_far_field_gradient:PROC
EXTRN	_mughal_far_field_energy:PROC
EXTRN	_mughal_far_field_init:PROC
EXTRN	_true_average_crossing:PROC
EXTRN	_true_writhe:PROC
EXTRN	_johndust_gradient:PROC
EXTRN	_johndust_energy:PROC
EXTRN	_curvature_forces:PROC
EXTRN	_curvature_forces_energy:PROC
EXTRN	_curvature_forces_init:PROC
EXTRN	_knot_local_thickness:PROC
EXTRN	_knot_thickness2:PROC
EXTRN	_knot_thickness_p2_gradient:PROC
EXTRN	_knot_thickness_p2:PROC
EXTRN	_knot_thickness_p_gradient:PROC
EXTRN	_knot_thickness_p:PROC
EXTRN	_knot_thickness:PROC
EXTRN	_knot_thickness_0_gradient:PROC
EXTRN	_knot_thickness_0:PROC
EXTRN	_sphere_knot_energy_gradient:PROC
EXTRN	_sphere_knot_energy:PROC
EXTRN	_sphere_knot_energy_init:PROC
EXTRN	_average_crossing:PROC
EXTRN	_writhe_gradient:PROC
EXTRN	_writhe:PROC
EXTRN	_twist:PROC
EXTRN	_circle_knot_energy_gradient:PROC
EXTRN	_circle_knot_energy:PROC
EXTRN	_sin_knot_energy_gradient:PROC
EXTRN	_sin_knot_energy:PROC
EXTRN	_proj_knot_energy_gradient:PROC
EXTRN	_proj_knot_energy:PROC
EXTRN	_buck_knot_energy_gradient:PROC
EXTRN	_buck_knot_energy:PROC
EXTRN	_bi_surface_gradient:PROC
EXTRN	_bi_surface_energy:PROC
EXTRN	_bi_surface_init:PROC
EXTRN	_facet_knot_energy_fix_gradient:PROC
EXTRN	_facet_knot_energy_fix:PROC
EXTRN	_facet_knot_energy_fix_init:PROC
EXTRN	_facet_knot_energy_gradient:PROC
EXTRN	_facet_knot_energy:PROC
EXTRN	_facet_knot_energy_init:PROC
EXTRN	_edge_edge_knot_energy_gradient:PROC
EXTRN	_edge_edge_knot_energy:PROC
EXTRN	_edge_min_knot_energy:PROC
EXTRN	_simon_normalization:PROC
EXTRN	_edge_normalization:PROC
EXTRN	_uniform_binormalization:PROC
EXTRN	_uniform_normalization:PROC
EXTRN	_uniform_knot_energy_gradient:PROC
EXTRN	_uniform_knot_energy:PROC
EXTRN	_uniform_knot_energy_init:PROC
EXTRN	_charge_gradient_gradient:PROC
EXTRN	_charge_gradient:PROC
EXTRN	_charge_gradient_init:PROC
EXTRN	_knot_energy_hessian:PROC
EXTRN	_knot_energy_gradient:PROC
EXTRN	_knot_energy:PROC
EXTRN	_knot_power_init:PROC
EXTRN	_Neo_Hookean_hessian:PROC
EXTRN	_Neo_Hookean_gradient:PROC
EXTRN	_Neo_Hookean_energy:PROC
EXTRN	_Neo_Hookean_init:PROC
EXTRN	_SVK_hessian:PROC
EXTRN	_SVK_gradient:PROC
EXTRN	_SVK_energy:PROC
EXTRN	_SVK_init:PROC
EXTRN	_dirichlet_elastic_hessian:PROC
EXTRN	_dirichlet_elastic_gradient:PROC
EXTRN	_dirichlet_elastic_energy:PROC
EXTRN	_dirichlet_elastic_init:PROC
EXTRN	_relaxed_elastic2_A_hessian:PROC
EXTRN	_relaxed_elastic2_A_gradient:PROC
EXTRN	_relaxed_elastic2_A_energy:PROC
EXTRN	_relaxed_elastic1_A_hessian:PROC
EXTRN	_relaxed_elastic1_A_gradient:PROC
EXTRN	_relaxed_elastic1_A_energy:PROC
EXTRN	_relaxed_elastic_A_hessian:PROC
EXTRN	_relaxed_elastic_A_gradient:PROC
EXTRN	_relaxed_elastic_A_energy:PROC
EXTRN	_relaxed_elastic_A_init:PROC
EXTRN	_relaxed_elastic2_hessian:PROC
EXTRN	_relaxed_elastic2_gradient:PROC
EXTRN	_relaxed_elastic2_energy:PROC
EXTRN	_relaxed_elastic1_hessian:PROC
EXTRN	_relaxed_elastic1_gradient:PROC
EXTRN	_relaxed_elastic1_energy:PROC
EXTRN	_relaxed_elastic_hessian:PROC
EXTRN	_relaxed_elastic_gradient:PROC
EXTRN	_relaxed_elastic_energy:PROC
EXTRN	_relaxed_elastic_init:PROC
EXTRN	_linear_elastic_B_hessian:PROC
EXTRN	_linear_elastic_B_gradient:PROC
EXTRN	_linear_elastic_B_energy:PROC
EXTRN	_linear_elastic_B_init:PROC
EXTRN	_general_linear_elastic_hessian:PROC
EXTRN	_general_linear_elastic_gradient:PROC
EXTRN	_general_linear_elastic_energy:PROC
EXTRN	_general_linear_elastic_init:PROC
EXTRN	_linear_elastic_hessian:PROC
EXTRN	_linear_elastic_gradient:PROC
EXTRN	_linear_elastic_energy:PROC
EXTRN	_linear_elastic_init:PROC
EXTRN	_dihedral_hooke_hess:PROC
EXTRN	_dihedral_hooke_grad:PROC
EXTRN	_dihedral_hooke_energy:PROC
EXTRN	_local_hooke_gradient:PROC
EXTRN	_local_hooke:PROC
EXTRN	_local_hooke_init:PROC
EXTRN	_hooke3_energy_hessian:PROC
EXTRN	_hooke3_energy_gradient:PROC
EXTRN	_hooke3_energy:PROC
EXTRN	_hooke3_energy_init:PROC
EXTRN	_hooke2_energy_hessian:PROC
EXTRN	_hooke2_energy_gradient:PROC
EXTRN	_hooke2_energy:PROC
EXTRN	_hooke2_energy_init:PROC
EXTRN	_hooke_energy_hessian:PROC
EXTRN	_hooke_energy_gradient:PROC
EXTRN	_hooke_energy:PROC
EXTRN	_hooke_energy_init:PROC
EXTRN	_stokes2d_laplacian:PROC
EXTRN	_stokes2d_hess:PROC
EXTRN	_stokes2d_grad:PROC
EXTRN	_stokes2d_value:PROC
EXTRN	_stokes2d_init:PROC
EXTRN	_laplacian_mean_curvature_grad:PROC
EXTRN	_laplacian_mean_curvature_value:PROC
EXTRN	_laplacian_mean_curvature_init:PROC
EXTRN	_circle_willmore_hess:PROC
EXTRN	_circle_willmore_grad:PROC
EXTRN	_circle_willmore_value:PROC
EXTRN	_circle_willmore_init:PROC
EXTRN	_star_sqcurve_method_hess:PROC
EXTRN	_star_sqcurve_method_grad:PROC
EXTRN	_star_sqcurve_method_value:PROC
EXTRN	_star_sqcurve_method_init:PROC
EXTRN	_sqcurve_method_cleanup:PROC
EXTRN	_sqcurve_method_grad:PROC
EXTRN	_sqcurve_method_value:PROC
EXTRN	_sqcurve_method_init:PROC
EXTRN	_star_sqgauss_method_hess:PROC
EXTRN	_star_sqgauss_method_grad:PROC
EXTRN	_star_sqgauss_method_value:PROC
EXTRN	_star_sqgauss_method_init:PROC
EXTRN	_star_gauss_method_hess:PROC
EXTRN	_star_gauss_method_grad:PROC
EXTRN	_star_gauss_method_value:PROC
EXTRN	_star_gauss_method_init:PROC
EXTRN	_levine_energy_grad:PROC
EXTRN	_levine_energy_value:PROC
EXTRN	_levine_energy_init:PROC
EXTRN	_gauss_int_gradient:PROC
EXTRN	_gauss_int_energy:PROC
EXTRN	_gauss_integral_init:PROC
EXTRN	_mean_int_a_hessian:PROC
EXTRN	_mean_int_a_gradient:PROC
EXTRN	_mean_int_a_value:PROC
EXTRN	_mean_int_a_init:PROC
EXTRN	_mean_int_hessian:PROC
EXTRN	_mean_int_gradient:PROC
EXTRN	_mean_int_value:PROC
EXTRN	_mean_int_init:PROC
EXTRN	_sq_gauss_curv_cyl_hess:PROC
EXTRN	_sq_gauss_curv_cyl_grad:PROC
EXTRN	_sq_gauss_curv_cyl_value:PROC
EXTRN	_sq_gauss_curv_cyl_init:PROC
EXTRN	_sq_mean_curv_cyl_hess:PROC
EXTRN	_sq_mean_curv_cyl_grad:PROC
EXTRN	_sq_mean_curv_cyl_value:PROC
EXTRN	_sq_mean_curv_cyl_init:PROC
EXTRN	_sqcurve3_string_hess:PROC
EXTRN	_sqcurve3_string_grad:PROC
EXTRN	_sqcurve3_string_value:PROC
EXTRN	_sqcurve3_string_init:PROC
EXTRN	_sqcurve2_string_grad:PROC
EXTRN	_sqcurve2_string_value:PROC
EXTRN	_sqcurve2_string_init:PROC
EXTRN	_sqcurve_string_marked_hess:PROC
EXTRN	_sqcurve_string_marked_grad:PROC
EXTRN	_sqcurve_string_marked_value:PROC
EXTRN	_sqcurve_string_marked_init:PROC
EXTRN	_sqcurve_string_hess:PROC
EXTRN	_sqcurve_string_grad:PROC
EXTRN	_sqcurve_string_value:PROC
EXTRN	_sqcurve_string_init:PROC
EXTRN	_full_gravity_init:PROC
EXTRN	_gravity_hessian:PROC
EXTRN	_gravity_grads:PROC
EXTRN	_gravity_energy:PROC
EXTRN	_gravity_init:PROC
EXTRN	_stress_integral_grad:PROC
EXTRN	_stress_integral:PROC
EXTRN	_stress_integral_init:PROC
EXTRN	_simplex_k_vector_integral_hess:PROC
EXTRN	_simplex_k_vector_integral_grad:PROC
EXTRN	_simplex_k_vector_integral:PROC
EXTRN	_simplex_k_vector_integral_init:PROC
EXTRN	_simplex_vector_integral_hess:PROC
EXTRN	_simplex_vector_integral_grad:PROC
EXTRN	_simplex_vector_integral:PROC
EXTRN	_simplex_vector_integral_init:PROC
EXTRN	_q_facet_torus_volume_hess:PROC
EXTRN	_q_facet_torus_volume_grad:PROC
EXTRN	_q_facet_torus_volume:PROC
EXTRN	_q_facet_volume_hess:PROC
EXTRN	_q_facet_volume_grad:PROC
EXTRN	_q_facet_volume:PROC
EXTRN	_q_facet_volume_init:PROC
EXTRN	_spherical_arc_area_s_hess:PROC
EXTRN	_spherical_arc_area_s_grad:PROC
EXTRN	_spherical_arc_area_s_value:PROC
EXTRN	_spherical_arc_area_n_hess:PROC
EXTRN	_spherical_arc_area_n_grad:PROC
EXTRN	_spherical_arc_area_n_value:PROC
EXTRN	_spherical_arc_area_init:PROC
EXTRN	_spherical_arc_length_hess:PROC
EXTRN	_spherical_arc_length_grad:PROC
EXTRN	_spherical_arc_length_value:PROC
EXTRN	_spherical_area_grad:PROC
EXTRN	_spherical_area_value:PROC
EXTRN	_metric_area_hess:PROC
EXTRN	_metric_area_grad:PROC
EXTRN	_metric_area_value:PROC
EXTRN	_metric_area_init:PROC
EXTRN	_facet_general_hi_d_hess:PROC
EXTRN	_facet_general_hi_d_grad:PROC
EXTRN	_facet_general_hi_d_value:PROC
EXTRN	_facet_general_hi_d_init:PROC
EXTRN	_facet_general_hess:PROC
EXTRN	_facet_general_grad:PROC
EXTRN	_facet_general_value:PROC
EXTRN	_facet_general_init:PROC
EXTRN	_facet_2form_sq_integral_grad:PROC
EXTRN	_facet_2form_sq_integral:PROC
EXTRN	_facet_2form_sq_integral_init:PROC
EXTRN	_facet_2form_integral_hess:PROC
EXTRN	_facet_2form_integral_grad:PROC
EXTRN	_facet_2form_integral:PROC
EXTRN	_facet_2form_integral_init:PROC
EXTRN	_facet_vector_integral_hess:PROC
EXTRN	_facet_vector_integral_grad:PROC
EXTRN	_facet_vector_integral:PROC
EXTRN	_facet_vector_integral_init:PROC
EXTRN	_facet_scalar_integral_hess:PROC
EXTRN	_facet_scalar_integral_grad:PROC
EXTRN	_facet_scalar_integral:PROC
EXTRN	_facet_scalar_integral_init:PROC
EXTRN	_klein_area_method_grad:PROC
EXTRN	_klein_area_method:PROC
EXTRN	_klein_length_method_grad:PROC
EXTRN	_klein_length_method:PROC
EXTRN	_gap_grads:PROC
EXTRN	_gap_energy:PROC
EXTRN	_string_gravity_hessian:PROC
EXTRN	_string_gravity_grads:PROC
EXTRN	_string_gravity_energy:PROC
EXTRN	_string_gravity_init:PROC
EXTRN	_circular_arc_area_hess:PROC
EXTRN	_circular_arc_area_grad:PROC
EXTRN	_circular_arc_area_value:PROC
EXTRN	_circular_arc_area_init:PROC
EXTRN	_circular_arc_length_hess:PROC
EXTRN	_circular_arc_length_grad:PROC
EXTRN	_circular_arc_length_value:PROC
EXTRN	_circular_arc_length_init:PROC
EXTRN	_q_edge_torus_area_hess:PROC
EXTRN	_q_edge_torus_area_grad:PROC
EXTRN	_q_edge_torus_area:PROC
EXTRN	_q_edge_area_hess:PROC
EXTRN	_q_edge_area_grad:PROC
EXTRN	_q_edge_area:PROC
EXTRN	_edge_general_hess:PROC
EXTRN	_edge_general_grad:PROC
EXTRN	_edge_general_value:PROC
EXTRN	_edge_general_init:PROC
EXTRN	_edge_vector_integral_hess:PROC
EXTRN	_edge_vector_integral_grad:PROC
EXTRN	_edge_vector_integral:PROC
EXTRN	_edge_scalar_integral_hess:PROC
EXTRN	_edge_scalar_integral_grad:PROC
EXTRN	_edge_scalar_integral:PROC
EXTRN	_vertex_scalar_integral_hess:PROC
EXTRN	_vertex_scalar_integral_grad:PROC
EXTRN	_vertex_scalar_integral:PROC
EXTRN	_area_square_gradient:PROC
EXTRN	_area_square_value:PROC
EXTRN	_facet_wulff_grad:PROC
EXTRN	_facet_wulff_value:PROC
EXTRN	_wulff_method_init:PROC
EXTRN	_dirichlet_area_hess:PROC
EXTRN	_dirichlet_area_init:PROC
EXTRN	_sobolev_area_hess:PROC
EXTRN	_sobolev_area_init:PROC
EXTRN	_pos_area_hess:PROC
EXTRN	_pos_area_hess_init:PROC
EXTRN	_q_facet_tension_u_hessian:PROC
EXTRN	_q_facet_tension_u_gradient:PROC
EXTRN	_q_facet_tension_u_value:PROC
EXTRN	_q_facet_tension_u_init:PROC
EXTRN	_q_facet_tension_hessian:PROC
EXTRN	_q_facet_tension_gradient:PROC
EXTRN	_q_facet_tension_value:PROC
EXTRN	_q_facet_tension_init:PROC
EXTRN	_q_edge_tension_hessian:PROC
EXTRN	_q_edge_tension_gradient:PROC
EXTRN	_q_edge_tension_value:PROC
EXTRN	_q_edge_tension_init:PROC
EXTRN	_null_area_hess:PROC
EXTRN	_null_area_grad:PROC
EXTRN	_null_area_value:PROC
EXTRN	_null_length_hess:PROC
EXTRN	_null_length_grad:PROC
EXTRN	_null_length_value:PROC
_DATA	SEGMENT
COMM	_method_instances_predicted:DWORD
COMM	_meth_inst_free_left:DWORD
COMM	_v_procnum:DWORD
COMM	_gen_quant_list:DWORD
COMM	_gen_quant_free_left:DWORD
COMM	_m_table_size:DWORD:090H
COMM	_m_hashtable:DWORD:090H
COMM	_gen_quant_free:DWORD
COMM	_meth_inst_list:DWORD
COMM	_gen_quant_list_max:DWORD
COMM	_quantities_predicted:DWORD
COMM	_meth_inst_list_max:DWORD
COMM	_meth_inst_free:DWORD
_compound_quant_list_head DD 0ffffffffH
_q_setup DD	FLAT:_q_vertex_setup
	DD	FLAT:_q_edge_setup
	DD	FLAT:_q_facet_setup
	DD	FLAT:_q_body_setup
	DD	FLAT:_q_facetedge_setup
_basic_gen_methods DB 'null_length', 00H
	ORG $+116
	DD	01H
	DD	010H
	DD	00H
	DD	00H
	DD	FLAT:_null_length_value
	DD	FLAT:_null_length_grad
	DD	FLAT:_null_length_hess
	DD	00H
	DB	'null_area', 00H
	ORG $+118
	DD	02H
	DD	010H
	DD	00H
	DD	00H
	DD	FLAT:_null_area_value
	DD	FLAT:_null_area_grad
	DD	FLAT:_null_area_hess
	DD	00H
	DB	'edge_tension', 00H
	ORG $+115
	DD	01H
	DD	010H
	DD	00H
	DD	FLAT:_q_edge_tension_init
	DD	FLAT:_q_edge_tension_value
	DD	FLAT:_q_edge_tension_gradient
	DD	FLAT:_q_edge_tension_hessian
	DD	00H
	DB	'edge_length', 00H
	ORG $+116
	DD	01H
	DD	010H
	DD	00H
	DD	FLAT:_q_edge_tension_init
	DD	FLAT:_q_edge_tension_value
	DD	FLAT:_q_edge_tension_gradient
	DD	FLAT:_q_edge_tension_hessian
	DD	00H
	DB	'density_edge_length', 00H
	ORG $+108
	DD	01H
	DD	010H
	DD	020H
	DD	FLAT:_q_edge_tension_init
	DD	FLAT:_q_edge_tension_value
	DD	FLAT:_q_edge_tension_gradient
	DD	FLAT:_q_edge_tension_hessian
	DD	00H
	DB	'facet_tension', 00H
	ORG $+114
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_q_facet_tension_init
	DD	FLAT:_q_facet_tension_value
	DD	FLAT:_q_facet_tension_gradient
	DD	FLAT:_q_facet_tension_hessian
	DD	00H
	DB	'facet_area', 00H
	ORG $+117
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_q_facet_tension_init
	DD	FLAT:_q_facet_tension_value
	DD	FLAT:_q_facet_tension_gradient
	DD	FLAT:_q_facet_tension_hessian
	DD	00H
	DB	'density_facet_area', 00H
	ORG $+109
	DD	02H
	DD	010H
	DD	020H
	DD	FLAT:_q_facet_tension_init
	DD	FLAT:_q_facet_tension_value
	DD	FLAT:_q_facet_tension_gradient
	DD	FLAT:_q_facet_tension_hessian
	DD	00H
	DB	'facet_area_u', 00H
	ORG $+115
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_q_facet_tension_u_init
	DD	FLAT:_q_facet_tension_u_value
	DD	FLAT:_q_facet_tension_u_gradient
	DD	FLAT:_q_facet_tension_u_hessian
	DD	00H
	DB	'density_facet_area_u', 00H
	ORG $+107
	DD	02H
	DD	010H
	DD	020H
	DD	FLAT:_q_facet_tension_u_init
	DD	FLAT:_q_facet_tension_u_value
	DD	FLAT:_q_facet_tension_u_gradient
	DD	FLAT:_q_facet_tension_u_hessian
	DD	00H
	DB	'pos_area_hess', 00H
	ORG $+114
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_pos_area_hess_init
	DD	FLAT:_q_facet_tension_value
	DD	FLAT:_q_facet_tension_gradient
	DD	FLAT:_pos_area_hess
	DD	00H
	DB	'sobolev_area', 00H
	ORG $+115
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_sobolev_area_init
	DD	FLAT:_q_facet_tension_value
	DD	FLAT:_q_facet_tension_gradient
	DD	FLAT:_sobolev_area_hess
	DD	00H
	DB	'dirichlet_area', 00H
	ORG $+113
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_dirichlet_area_init
	DD	FLAT:_q_facet_tension_value
	DD	FLAT:_q_facet_tension_gradient
	DD	FLAT:_dirichlet_area_hess
	DD	00H
	DB	'wulff_energy', 00H
	ORG $+115
	DD	02H
	DD	00H
	DD	00H
	DD	FLAT:_wulff_method_init
	DD	FLAT:_facet_wulff_value
	DD	FLAT:_facet_wulff_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'area_square', 00H
	ORG $+116
	DD	02H
	DD	010H
	DD	00H
	DD	00H
	DD	FLAT:_area_square_value
	DD	FLAT:_area_square_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'vertex_scalar_integral', 00H
	ORG $+105
	DD	00H
	DD	010000H
	DD	01H
	DD	00H
	DD	FLAT:_vertex_scalar_integral
	DD	FLAT:_vertex_scalar_integral_grad
	DD	FLAT:_vertex_scalar_integral_hess
	DD	00H
	DB	'edge_scalar_integral', 00H
	ORG $+107
	DD	01H
	DD	090H
	DD	01H
	DD	00H
	DD	FLAT:_edge_scalar_integral
	DD	FLAT:_edge_scalar_integral_grad
	DD	FLAT:_edge_scalar_integral_hess
	DD	00H
	DB	'edge_vector_integral', 00H
	ORG $+107
	DD	01H
	DD	010090H
	DD	02H
	DD	00H
	DD	FLAT:_edge_vector_integral
	DD	FLAT:_edge_vector_integral_grad
	DD	FLAT:_edge_vector_integral_hess
	DD	00H
	DB	'edge_general_integral', 00H
	ORG $+106
	DD	01H
	DD	090H
	DD	09H
	DD	FLAT:_edge_general_init
	DD	FLAT:_edge_general_value
	DD	FLAT:_edge_general_grad
	DD	FLAT:_edge_general_hess
	DD	00H
	DB	'edge_area', 00H
	ORG $+118
	DD	01H
	DD	010000H
	DD	00H
	DD	00H
	DD	FLAT:_q_edge_area
	DD	FLAT:_q_edge_area_grad
	DD	FLAT:_q_edge_area_hess
	DD	00H
	DB	'edge_torus_area', 00H
	ORG $+112
	DD	01H
	DD	010000H
	DD	00H
	DD	00H
	DD	FLAT:_q_edge_torus_area
	DD	FLAT:_q_edge_torus_area_grad
	DD	FLAT:_q_edge_torus_area_hess
	DD	00H
	DB	'circular_arc_length', 00H
	ORG $+108
	DD	01H
	DD	010H
	DD	00H
	DD	FLAT:_circular_arc_length_init
	DD	FLAT:_circular_arc_length_value
	DD	FLAT:_circular_arc_length_grad
	DD	FLAT:_circular_arc_length_hess
	DD	00H
	DB	'circular_arc_area', 00H
	ORG $+110
	DD	01H
	DD	010010H
	DD	00H
	DD	FLAT:_circular_arc_area_init
	DD	FLAT:_circular_arc_area_value
	DD	FLAT:_circular_arc_area_grad
	DD	FLAT:_circular_arc_area_hess
	DD	00H
	DB	'string_gravity', 00H
	ORG $+113
	DD	01H
	DD	010090H
	DD	00H
	DD	FLAT:_string_gravity_init
	DD	FLAT:_string_gravity_energy
	DD	FLAT:_string_gravity_grads
	DD	FLAT:_string_gravity_hessian
	DD	00H
	DB	'gap_energy', 00H
	ORG $+117
	DD	01H
	DD	010H
	DD	00H
	DD	00H
	DD	FLAT:_gap_energy
	DD	FLAT:_gap_grads
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'klein_length', 00H
	ORG $+115
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_klein_length_method
	DD	FLAT:_klein_length_method_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'klein_area', 00H
	ORG $+117
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_klein_area_method
	DD	FLAT:_klein_area_method_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'facet_scalar_integral', 00H
	ORG $+106
	DD	02H
	DD	090H
	DD	01H
	DD	FLAT:_facet_scalar_integral_init
	DD	FLAT:_facet_scalar_integral
	DD	FLAT:_facet_scalar_integral_grad
	DD	FLAT:_facet_scalar_integral_hess
	DD	00H
	DB	'facet_vector_integral', 00H
	ORG $+106
	DD	02H
	DD	0100b0H
	DD	02H
	DD	FLAT:_facet_vector_integral_init
	DD	FLAT:_facet_vector_integral
	DD	FLAT:_facet_vector_integral_grad
	DD	FLAT:_facet_vector_integral_hess
	DD	00H
	DB	'facet_2form_integral', 00H
	ORG $+107
	DD	02H
	DD	010090H
	DD	04H
	DD	FLAT:_facet_2form_integral_init
	DD	FLAT:_facet_2form_integral
	DD	FLAT:_facet_2form_integral_grad
	DD	FLAT:_facet_2form_integral_hess
	DD	00H
	DB	'facet_2form_sq_integral', 00H
	ORG $+104
	DD	02H
	DD	090H
	DD	04H
	DD	FLAT:_facet_2form_sq_integral_init
	DD	FLAT:_facet_2form_sq_integral
	DD	FLAT:_facet_2form_sq_integral_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'facet_general_integral', 00H
	ORG $+105
	DD	02H
	DD	0b0H
	DD	09H
	DD	FLAT:_facet_general_init
	DD	FLAT:_facet_general_value
	DD	FLAT:_facet_general_grad
	DD	FLAT:_facet_general_hess
	DD	00H
	DB	'facet_general_hi_d_integral', 00H
	ORG $+100
	DD	02H
	DD	0b0H
	DD	011H
	DD	FLAT:_facet_general_hi_d_init
	DD	FLAT:_facet_general_hi_d_value
	DD	FLAT:_facet_general_hi_d_grad
	DD	FLAT:_facet_general_hi_d_hess
	DD	00H
	DB	'metric_facet_area', 00H
	ORG $+110
	DD	02H
	DD	090H
	DD	00H
	DD	FLAT:_metric_area_init
	DD	FLAT:_metric_area_value
	DD	FLAT:_metric_area_grad
	DD	FLAT:_metric_area_hess
	DD	00H
	DB	'metric_edge_length', 00H
	ORG $+109
	DD	01H
	DD	080H
	DD	00H
	DD	FLAT:_metric_area_init
	DD	FLAT:_metric_area_value
	DD	FLAT:_metric_area_grad
	DD	FLAT:_metric_area_hess
	DD	00H
	DB	'spherical_area', 00H
	ORG $+113
	DD	02H
	DD	010H
	DD	00H
	DD	00H
	DD	FLAT:_spherical_area_value
	DD	FLAT:_spherical_area_grad
	DD	00H
	DD	00H
	DB	'spherical_arc_length', 00H
	ORG $+107
	DD	01H
	DD	010H
	DD	00H
	DD	00H
	DD	FLAT:_spherical_arc_length_value
	DD	FLAT:_spherical_arc_length_grad
	DD	FLAT:_spherical_arc_length_hess
	DD	00H
	DB	'spherical_arc_area_n', 00H
	ORG $+107
	DD	01H
	DD	010010H
	DD	00H
	DD	FLAT:_spherical_arc_area_init
	DD	FLAT:_spherical_arc_area_n_value
	DD	FLAT:_spherical_arc_area_n_grad
	DD	FLAT:_spherical_arc_area_n_hess
	DD	00H
	DB	'spherical_arc_area_s', 00H
	ORG $+107
	DD	01H
	DD	010010H
	DD	00H
	DD	FLAT:_spherical_arc_area_init
	DD	FLAT:_spherical_arc_area_s_value
	DD	FLAT:_spherical_arc_area_s_grad
	DD	FLAT:_spherical_arc_area_s_hess
	DD	00H
	DB	'facet_volume', 00H
	ORG $+115
	DD	02H
	DD	050010H
	DD	00H
	DD	FLAT:_q_facet_volume_init
	DD	FLAT:_q_facet_volume
	DD	FLAT:_q_facet_volume_grad
	DD	FLAT:_q_facet_volume_hess
	DD	00H
	DB	'facet_torus_volume', 00H
	ORG $+109
	DD	02H
	DD	050010H
	DD	00H
	DD	00H
	DD	FLAT:_q_facet_torus_volume
	DD	FLAT:_q_facet_torus_volume_grad
	DD	FLAT:_q_facet_torus_volume_hess
	DD	00H
	DB	'simplex_vector_integral', 00H
	ORG $+104
	DD	02H
	DD	010090H
	DD	02H
	DD	FLAT:_simplex_vector_integral_init
	DD	FLAT:_simplex_vector_integral
	DD	FLAT:_simplex_vector_integral_grad
	DD	FLAT:_simplex_vector_integral_hess
	DD	00H
	DB	'simplex_k_vector_integral', 00H
	ORG $+102
	DD	02H
	DD	010090H
	DD	040H
	DD	FLAT:_simplex_k_vector_integral_init
	DD	FLAT:_simplex_k_vector_integral
	DD	FLAT:_simplex_k_vector_integral_grad
	DD	FLAT:_simplex_k_vector_integral_hess
	DD	00H
	DB	'edge_k_vector_integral', 00H
	ORG $+105
	DD	01H
	DD	010090H
	DD	040H
	DD	FLAT:_simplex_k_vector_integral_init
	DD	FLAT:_simplex_k_vector_integral
	DD	FLAT:_simplex_k_vector_integral_grad
	DD	FLAT:_simplex_k_vector_integral_hess
	DD	00H
	DB	'stress_integral', 00H
	ORG $+112
	DD	02H
	DD	030H
	DD	01H
	DD	FLAT:_stress_integral_init
	DD	FLAT:_stress_integral
	DD	FLAT:_stress_integral_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'gravity_method', 00H
	ORG $+113
	DD	02H
	DD	010010H
	DD	00H
	DD	FLAT:_gravity_init
	DD	FLAT:_gravity_energy
	DD	FLAT:_gravity_grads
	DD	FLAT:_gravity_hessian
	DD	00H
	DB	'full_gravity_method', 00H
	ORG $+108
	DD	02H
	DD	010010H
	DD	00H
	DD	FLAT:_full_gravity_init
	DD	FLAT:_gravity_energy
	DD	FLAT:_gravity_grads
	DD	FLAT:_gravity_hessian
	DD	00H
	DB	'sqcurve_string', 00H
	ORG $+113
	DD	00H
	DD	040H
	DD	00H
	DD	FLAT:_sqcurve_string_init
	DD	FLAT:_sqcurve_string_value
	DD	FLAT:_sqcurve_string_grad
	DD	FLAT:_sqcurve_string_hess
	DD	00H
	DB	'sqcurve_string_marked', 00H
	ORG $+106
	DD	00H
	DD	0400H
	DD	00H
	DD	FLAT:_sqcurve_string_marked_init
	DD	FLAT:_sqcurve_string_marked_value
	DD	FLAT:_sqcurve_string_marked_grad
	DD	FLAT:_sqcurve_string_marked_hess
	DD	00H
	DB	'sqcurve2_string', 00H
	ORG $+112
	DD	00H
	DD	040H
	DD	00H
	DD	FLAT:_sqcurve2_string_init
	DD	FLAT:_sqcurve2_string_value
	DD	FLAT:_sqcurve2_string_grad
	DD	00H
	DD	00H
	DB	'sqcurve3_string', 00H
	ORG $+112
	DD	00H
	DD	040H
	DD	00H
	DD	FLAT:_sqcurve3_string_init
	DD	FLAT:_sqcurve3_string_value
	DD	FLAT:_sqcurve3_string_grad
	DD	FLAT:_sqcurve3_string_hess
	DD	00H
	DB	'sq_mean_curv_cyl', 00H
	ORG $+111
	DD	00H
	DD	040H
	DD	00H
	DD	FLAT:_sq_mean_curv_cyl_init
	DD	FLAT:_sq_mean_curv_cyl_value
	DD	FLAT:_sq_mean_curv_cyl_grad
	DD	FLAT:_sq_mean_curv_cyl_hess
	DD	00H
	DB	'sq_gaussian_curv_cyl', 00H
	ORG $+107
	DD	00H
	DD	040H
	DD	00H
	DD	FLAT:_sq_gauss_curv_cyl_init
	DD	FLAT:_sq_gauss_curv_cyl_value
	DD	FLAT:_sq_gauss_curv_cyl_grad
	DD	FLAT:_sq_gauss_curv_cyl_hess
	DD	00H
	DB	'mean_curvature_integral', 00H
	ORG $+104
	DD	01H
	DD	050H
	DD	00H
	DD	FLAT:_mean_int_init
	DD	FLAT:_mean_int_value
	DD	FLAT:_mean_int_gradient
	DD	FLAT:_mean_int_hessian
	DD	00H
	DB	'mean_curvature_integral_A', 00H
	ORG $+102
	DD	01H
	DD	050H
	DD	00H
	DD	FLAT:_mean_int_a_init
	DD	FLAT:_mean_int_a_value
	DD	FLAT:_mean_int_a_gradient
	DD	FLAT:_mean_int_a_hessian
	DD	00H
	DB	'gauss_curvature_integral', 00H
	ORG $+103
	DD	02H
	DD	00H
	DD	00H
	DD	FLAT:_gauss_integral_init
	DD	FLAT:_gauss_int_energy
	DD	FLAT:_gauss_int_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'levine_energy', 00H
	ORG $+114
	DD	00H
	DD	01000H
	DD	00H
	DD	FLAT:_levine_energy_init
	DD	FLAT:_levine_energy_value
	DD	FLAT:_levine_energy_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'star_gauss_curvature', 00H
	ORG $+107
	DD	00H
	DD	0800H
	DD	00H
	DD	FLAT:_star_gauss_method_init
	DD	FLAT:_star_gauss_method_value
	DD	FLAT:_star_gauss_method_grad
	DD	FLAT:_star_gauss_method_hess
	DD	00H
	DB	'sq_gauss_curvature', 00H
	ORG $+109
	DD	00H
	DD	01000H
	DD	00H
	DD	FLAT:_star_sqgauss_method_init
	DD	FLAT:_star_sqgauss_method_value
	DD	FLAT:_star_sqgauss_method_grad
	DD	FLAT:_star_sqgauss_method_hess
	DD	00H
	DB	'sq_mean_curvature', 00H
	ORG $+110
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_sqcurve_method_init
	DD	FLAT:_sqcurve_method_value
	DD	FLAT:_sqcurve_method_grad
	DD	FLAT:_null_q_hess
	DD	FLAT:_sqcurve_method_cleanup
	DB	'eff_area_sq_mean_curvature', 00H
	ORG $+101
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_sqcurve_method_init
	DD	FLAT:_sqcurve_method_value
	DD	FLAT:_sqcurve_method_grad
	DD	FLAT:_null_q_hess
	DD	FLAT:_sqcurve_method_cleanup
	DB	'normal_sq_mean_curvature', 00H
	ORG $+103
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_sqcurve_method_init
	DD	FLAT:_sqcurve_method_value
	DD	FLAT:_sqcurve_method_grad
	DD	FLAT:_null_q_hess
	DD	FLAT:_sqcurve_method_cleanup
	DB	'star_sq_mean_curvature', 00H
	ORG $+105
	DD	00H
	DD	0800H
	DD	00H
	DD	FLAT:_star_sqcurve_method_init
	DD	FLAT:_star_sqcurve_method_value
	DD	FLAT:_star_sqcurve_method_grad
	DD	FLAT:_star_sqcurve_method_hess
	DD	00H
	DB	'star_eff_area_sq_mean_curvature', 00H
	ORG $+96
	DD	00H
	DD	0800H
	DD	00H
	DD	FLAT:_star_sqcurve_method_init
	DD	FLAT:_star_sqcurve_method_value
	DD	FLAT:_star_sqcurve_method_grad
	DD	FLAT:_star_sqcurve_method_hess
	DD	00H
	DB	'star_normal_sq_mean_curvature', 00H
	ORG $+98
	DD	00H
	DD	0800H
	DD	00H
	DD	FLAT:_star_sqcurve_method_init
	DD	FLAT:_star_sqcurve_method_value
	DD	FLAT:_star_sqcurve_method_grad
	DD	FLAT:_star_sqcurve_method_hess
	DD	00H
	DB	'star_perp_sq_mean_curvature', 00H
	ORG $+100
	DD	00H
	DD	0800H
	DD	00H
	DD	FLAT:_star_sqcurve_method_init
	DD	FLAT:_star_sqcurve_method_value
	DD	FLAT:_star_sqcurve_method_grad
	DD	FLAT:_star_sqcurve_method_hess
	DD	00H
	DB	'circle_willmore', 00H
	ORG $+112
	DD	01H
	DD	050H
	DD	00H
	DD	FLAT:_circle_willmore_init
	DD	FLAT:_circle_willmore_value
	DD	FLAT:_circle_willmore_grad
	DD	FLAT:_circle_willmore_hess
	DD	00H
	DB	'laplacian_mean_curvature', 00H
	ORG $+103
	DD	00H
	DD	0800H
	DD	00H
	DD	FLAT:_laplacian_mean_curvature_init
	DD	FLAT:_laplacian_mean_curvature_value
	DD	FLAT:_laplacian_mean_curvature_grad
	DD	00H
	DD	00H
	DB	'stokes2d', 00H
	ORG $+119
	DD	00H
	DD	0800H
	DD	00H
	DD	FLAT:_stokes2d_init
	DD	FLAT:_stokes2d_value
	DD	FLAT:_stokes2d_grad
	DD	FLAT:_stokes2d_hess
	DD	00H
	DB	'stokes2d_laplacian', 00H
	ORG $+109
	DD	00H
	DD	0800H
	DD	00H
	DD	FLAT:_stokes2d_init
	DD	FLAT:_stokes2d_laplacian
	DD	00H
	DD	00H
	DD	00H
	DB	'hooke_energy', 00H
	ORG $+115
	DD	01H
	DD	010H
	DD	00H
	DD	FLAT:_hooke_energy_init
	DD	FLAT:_hooke_energy
	DD	FLAT:_hooke_energy_gradient
	DD	FLAT:_hooke_energy_hessian
	DD	00H
	DB	'hooke2_energy', 00H
	ORG $+114
	DD	01H
	DD	010H
	DD	00H
	DD	FLAT:_hooke2_energy_init
	DD	FLAT:_hooke2_energy
	DD	FLAT:_hooke2_energy_gradient
	DD	FLAT:_hooke2_energy_hessian
	DD	00H
	DB	'hooke3_energy', 00H
	ORG $+114
	DD	01H
	DD	010H
	DD	00H
	DD	FLAT:_hooke3_energy_init
	DD	FLAT:_hooke3_energy
	DD	FLAT:_hooke3_energy_gradient
	DD	FLAT:_hooke3_energy_hessian
	DD	00H
	DB	'local_hooke_energy', 00H
	ORG $+109
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_local_hooke_init
	DD	FLAT:_local_hooke
	DD	FLAT:_local_hooke_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'dihedral_hooke', 00H
	ORG $+113
	DD	01H
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:_dihedral_hooke_energy
	DD	FLAT:_dihedral_hooke_grad
	DD	FLAT:_dihedral_hooke_hess
	DD	00H
	DB	'linear_elastic', 00H
	ORG $+113
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_linear_elastic_init
	DD	FLAT:_linear_elastic_energy
	DD	FLAT:_linear_elastic_gradient
	DD	FLAT:_linear_elastic_hessian
	DD	00H
	DB	'general_linear_elastic', 00H
	ORG $+105
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_general_linear_elastic_init
	DD	FLAT:_general_linear_elastic_energy
	DD	FLAT:_general_linear_elastic_gradient
	DD	FLAT:_general_linear_elastic_hessian
	DD	00H
	DB	'linear_elastic_B', 00H
	ORG $+111
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_linear_elastic_B_init
	DD	FLAT:_linear_elastic_B_energy
	DD	FLAT:_linear_elastic_B_gradient
	DD	FLAT:_linear_elastic_B_hessian
	DD	00H
	DB	'relaxed_elastic', 00H
	ORG $+112
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_relaxed_elastic_init
	DD	FLAT:_relaxed_elastic_energy
	DD	FLAT:_relaxed_elastic_gradient
	DD	FLAT:_relaxed_elastic_hessian
	DD	00H
	DB	'relaxed_elastic1', 00H
	ORG $+111
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_relaxed_elastic_init
	DD	FLAT:_relaxed_elastic1_energy
	DD	FLAT:_relaxed_elastic1_gradient
	DD	FLAT:_relaxed_elastic1_hessian
	DD	00H
	DB	'relaxed_elastic2', 00H
	ORG $+111
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_relaxed_elastic_init
	DD	FLAT:_relaxed_elastic2_energy
	DD	FLAT:_relaxed_elastic2_gradient
	DD	FLAT:_relaxed_elastic2_hessian
	DD	00H
	DB	'relaxed_elastic_A', 00H
	ORG $+110
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_relaxed_elastic_A_init
	DD	FLAT:_relaxed_elastic_A_energy
	DD	FLAT:_relaxed_elastic_A_gradient
	DD	FLAT:_relaxed_elastic_A_hessian
	DD	00H
	DB	'relaxed_elastic1_A', 00H
	ORG $+109
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_relaxed_elastic_A_init
	DD	FLAT:_relaxed_elastic1_A_energy
	DD	FLAT:_relaxed_elastic1_A_gradient
	DD	FLAT:_relaxed_elastic1_A_hessian
	DD	00H
	DB	'relaxed_elastic2_A', 00H
	ORG $+109
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_relaxed_elastic_A_init
	DD	FLAT:_relaxed_elastic2_A_energy
	DD	FLAT:_relaxed_elastic2_A_gradient
	DD	FLAT:_relaxed_elastic2_A_hessian
	DD	00H
	DB	'dirichlet_elastic', 00H
	ORG $+110
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_dirichlet_elastic_init
	DD	FLAT:_dirichlet_elastic_energy
	DD	FLAT:_dirichlet_elastic_gradient
	DD	FLAT:_dirichlet_elastic_hessian
	DD	00H
	DB	'SVK_elastic', 00H
	ORG $+116
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_SVK_init
	DD	FLAT:_SVK_energy
	DD	FLAT:_SVK_gradient
	DD	FLAT:_SVK_hessian
	DD	00H
	DB	'neo_hookean', 00H
	ORG $+116
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_Neo_Hookean_init
	DD	FLAT:_Neo_Hookean_energy
	DD	FLAT:_Neo_Hookean_gradient
	DD	FLAT:_Neo_Hookean_hessian
	DD	00H
	DB	'knot_energy', 00H
	ORG $+116
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_knot_power_init
	DD	FLAT:_knot_energy
	DD	FLAT:_knot_energy_gradient
	DD	FLAT:_knot_energy_hessian
	DD	00H
	DB	'charge_gradient', 00H
	ORG $+112
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_charge_gradient_init
	DD	FLAT:_charge_gradient
	DD	FLAT:_charge_gradient_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'uniform_knot_energy', 00H
	ORG $+108
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_uniform_knot_energy_init
	DD	FLAT:_uniform_knot_energy
	DD	FLAT:_uniform_knot_energy_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'uniform_knot_energy_normalizer', 00H
	ORG $+97
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_knot_power_init
	DD	FLAT:_uniform_normalization
	DD	FLAT:_null_q_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'uniform_knot_normalizer1', 00H
	ORG $+103
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_knot_power_init
	DD	FLAT:_uniform_normalization
	DD	FLAT:_null_q_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'uniform_knot_normalizer2', 00H
	ORG $+103
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_knot_power_init
	DD	FLAT:_uniform_binormalization
	DD	FLAT:_null_q_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'edge_knot_energy_normalizer', 00H
	ORG $+100
	DD	01H
	DD	00H
	DD	00H
	DD	FLAT:_knot_power_init
	DD	FLAT:_edge_normalization
	DD	FLAT:_null_q_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'simon_knot_energy_normalizer', 00H
	ORG $+99
	DD	01H
	DD	00H
	DD	00H
	DD	FLAT:_knot_power_init
	DD	FLAT:_simon_normalization
	DD	FLAT:_null_q_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'edge_min_knot_energy', 00H
	ORG $+107
	DD	01H
	DD	00H
	DD	00H
	DD	FLAT:_knot_power_init
	DD	FLAT:_edge_min_knot_energy
	DD	FLAT:_null_q_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'edge_knot_energy', 00H
	ORG $+111
	DD	01H
	DD	00H
	DD	00H
	DD	FLAT:_knot_power_init
	DD	FLAT:_edge_edge_knot_energy
	DD	FLAT:_edge_edge_knot_energy_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'edge_edge_knot_energy', 00H
	ORG $+106
	DD	01H
	DD	00H
	DD	00H
	DD	FLAT:_knot_power_init
	DD	FLAT:_edge_edge_knot_energy
	DD	FLAT:_edge_edge_knot_energy_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'facet_knot_energy', 00H
	ORG $+110
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_facet_knot_energy_init
	DD	FLAT:_facet_knot_energy
	DD	FLAT:_facet_knot_energy_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'facet_knot_energy_fix', 00H
	ORG $+106
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_facet_knot_energy_fix_init
	DD	FLAT:_facet_knot_energy_fix
	DD	FLAT:_facet_knot_energy_fix_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'bi_surface', 00H
	ORG $+117
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:_bi_surface_init
	DD	FLAT:_bi_surface_energy
	DD	FLAT:_bi_surface_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'buck_knot_energy', 00H
	ORG $+111
	DD	01H
	DD	00H
	DD	00H
	DD	FLAT:_knot_power_init
	DD	FLAT:_buck_knot_energy
	DD	FLAT:_buck_knot_energy_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'proj_knot_energy', 00H
	ORG $+111
	DD	01H
	DD	00H
	DD	00H
	DD	FLAT:_knot_power_init
	DD	FLAT:_proj_knot_energy
	DD	FLAT:_proj_knot_energy_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'sin_knot_energy', 00H
	ORG $+112
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_sin_knot_energy
	DD	FLAT:_sin_knot_energy_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'circle_knot_energy', 00H
	ORG $+109
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_circle_knot_energy
	DD	FLAT:_circle_knot_energy_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'twist', 00H
	ORG $+122
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_twist
	DD	FLAT:_null_q_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'writhe', 00H
	ORG $+121
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_writhe
	DD	FLAT:_writhe_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'average_crossings', 00H
	ORG $+110
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_average_crossing
	DD	FLAT:_null_q_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'sphere_knot_energy', 00H
	ORG $+109
	DD	02H
	DD	00H
	DD	00H
	DD	FLAT:_sphere_knot_energy_init
	DD	FLAT:_sphere_knot_energy
	DD	FLAT:_sphere_knot_energy_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'knot_thickness_0', 00H
	ORG $+111
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_knot_power_init
	DD	FLAT:_knot_thickness_0
	DD	FLAT:_knot_thickness_0_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'knot_thickness', 00H
	ORG $+113
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_knot_thickness
	DD	FLAT:_null_q_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'knot_thickness_p', 00H
	ORG $+111
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_uniform_knot_energy_init
	DD	FLAT:_knot_thickness_p
	DD	FLAT:_knot_thickness_p_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'knot_thickness_p2', 00H
	ORG $+110
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_uniform_knot_energy_init
	DD	FLAT:_knot_thickness_p2
	DD	FLAT:_knot_thickness_p2_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'knot_thickness2', 00H
	ORG $+112
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_knot_thickness2
	DD	FLAT:_null_q_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'knot_local_thickness', 00H
	ORG $+107
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_knot_local_thickness
	DD	FLAT:_null_q_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'curvature_function', 00H
	ORG $+109
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_curvature_forces_init
	DD	FLAT:_curvature_forces_energy
	DD	FLAT:_curvature_forces
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'johndust', 00H
	ORG $+119
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_johndust_energy
	DD	FLAT:_johndust_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'true_writhe', 00H
	ORG $+116
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_true_writhe
	DD	FLAT:_null_q_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'true_average_crossings', 00H
	ORG $+105
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_true_average_crossing
	DD	FLAT:_null_q_grad
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'mughal_far_field', 00H
	ORG $+111
	DD	01H
	DD	00H
	DD	00H
	DD	FLAT:_mughal_far_field_init
	DD	FLAT:_mughal_far_field_energy
	DD	FLAT:_mughal_far_field_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'ackerman', 00H
	ORG $+119
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_ackerman_init
	DD	FLAT:_ackerman_energy
	DD	FLAT:_ackerman_forces
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'carter_energy', 00H
	ORG $+114
	DD	02H
	DD	010H
	DD	00H
	DD	FLAT:_carter_energy_init
	DD	FLAT:_carter_energy
	DD	FLAT:_carter_energy_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'curvature_binormal', 00H
	ORG $+109
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_curvature_binormal_init
	DD	FLAT:_curvature_binormal_energy
	DD	FLAT:_curvature_binormal_force
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'ddd_gamma_sq', 00H
	ORG $+115
	DD	01H
	DD	0200H
	DD	00H
	DD	FLAT:_ddd_gamma_sq_init
	DD	FLAT:_ddd_gamma_sq_energy
	DD	FLAT:_ddd_gamma_sq_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'sq_torsion', 00H
	ORG $+117
	DD	01H
	DD	0410H
	DD	00H
	DD	FLAT:_sq_torsion_init
	DD	FLAT:_sq_torsion_energy
	DD	FLAT:_sq_torsion_gradient
	DD	FLAT:_null_q_hess
	DD	00H
	DB	'bouzidi', 00H
	ORG $+120
	DD	02H
	DD	02000H
	DD	00H
	DD	FLAT:_bouzidi_init
	DD	FLAT:_bouzidi_value
	DD	FLAT:_bouzidi_gradient
	DD	FLAT:_bouzidi_hessian
	DD	00H
	DB	' ', 00H
	ORG $+126
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_el_list_timestamp DD 0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
_DATA	ENDS
PUBLIC	_get_fe_edge
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_get_edge_wrap
EXTRN	_sym_inverse:DWORD
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_wrap PROC					; COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  :   WRAPTYPE wrap = *EINT(e_id,E_WRAP_ATTR) ;

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+784]
	mov	eax, DWORD PTR [eax+edx]
	pop	esi

; 165  :   return    ( inverted(e_id) ? (*sym_inverse)(wrap) : wrap );

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN4@get_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@get_edge_w:

; 166  : }

	pop	ebp
	ret	0
_get_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_head_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_head_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_head_edge PROC				; COMDAT

; 273  : { return inverse_id(eptr(e_id)->next_vedge[inverted(e_id) ?0: 1]); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	not	ecx
	and	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4+32]
	xor	eax, 134217728				; 08000000H
	pop	ebp
	ret	0
_get_next_head_edge ENDP
_TEXT	ENDS
PUBLIC	_get_vertex_fe
; Function compile flags: /Ogtp
;	COMDAT _get_vertex_fe
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_get_vertex_fe PROC					; COMDAT

; 287  : { facet_id fe;

	push	ebp
	mov	ebp, esp

; 288  :   edge_id start_e, xx_id=vptr(v_id)->e_id;

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 289  :   // might be bare edge, so seek along edge loop
; 290  :   if ( !valid_id(xx_id) ) return NULLID;

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN4@get_vertex
	xor	eax, eax

; 299  : }

	pop	ebp
	ret	0
$LN4@get_vertex:
	push	esi

; 291  :   fe = eptr(xx_id)->fe_id;

	mov	esi, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	push	edi

; 292  :   start_e = xx_id;
; 293  :   while ( !valid_id(fe) )

	test	edx, 268435456				; 10000000H
	jne	SHORT $LN2@get_vertex
	mov	edi, eax
	or	edi, 134217728				; 08000000H
	npad	8
$LL3@get_vertex:

; 294  :   { xx_id = get_next_tail_edge(xx_id);

	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	eax, DWORD PTR [ecx+eax*4+32]

; 295  :     if ( equal_element(xx_id,start_e) ) return NULLID;

	mov	edx, eax
	or	edx, 134217728				; 08000000H
	cmp	edx, edi
	je	SHORT $LN10@get_vertex

; 296  :     fe = eptr(xx_id)->fe_id;

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	test	edx, 268435456				; 10000000H
	je	SHORT $LL3@get_vertex
$LN2@get_vertex:

; 297  :   }
; 298  :   return  same_sign(fe,xx_id);

	and	eax, 134217728				; 08000000H
	pop	edi
	xor	eax, edx
	pop	esi

; 299  : }

	pop	ebp
	ret	0
$LN10@get_vertex:
	pop	edi

; 295  :     if ( equal_element(xx_id,start_e) ) return NULLID;

	xor	eax, eax
	pop	esi

; 299  : }

	pop	ebp
	ret	0
_get_vertex_fe ENDP
_TEXT	ENDS
PUBLIC	_get_extra
; Function compile flags: /Ogtp
;	COMDAT _get_extra
_TEXT	SEGMENT
_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_extra PROC						; COMDAT

; 348  : { int type = id_type(id);

	push	ebp
	mov	ebp, esp

; 349  : 
; 350  :   return ( (char*)elptr(id) + EXTRAS(type)[n].offset);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	shr	eax, 29					; 0000001dH
	imul	esi, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, esi
	add	eax, DWORD PTR [edi+ecx+64]
	pop	edi
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_get_extra ENDP
_TEXT	ENDS
PUBLIC	_get_meth_offset
; Function compile flags: /Ogtp
;	COMDAT _get_meth_offset
_TEXT	SEGMENT
_type$ = 8						; size = 4
_get_meth_offset PROC					; COMDAT

; 376  : { int meth_offset;

	push	ebp
	mov	ebp, esp

; 377  :   meth_offset = EXTRAS(type)[web.meth_attr[type]].offset; 

	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR _web[eax*4+5664]
	imul	eax, 112				; 00000070H

; 378  :   return meth_offset;

	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR [ecx+edx+64]

; 379  : }

	pop	ebp
	ret	0
_get_meth_offset ENDP
_TEXT	ENDS
PUBLIC	_quantity_init
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\quantity.c
;	COMDAT _quantity_init
_TEXT	SEGMENT
_quantity_init PROC					; COMDAT

; 338  : 
; 339  :   /* set lists to empty; memory deallocation taken care of by global
; 340  :      permanent memory freeing at the start of each new surface */
; 341  :   gen_quant_count = 0;

	xor	eax, eax

; 342  :   gen_quant_list_max = 0;
; 343  :   gen_quant_free_head = -1;

	or	ecx, -1
	mov	DWORD PTR _web+5528, eax
	mov	DWORD PTR _gen_quant_list_max, eax
	mov	DWORD PTR _web+5536, ecx

; 344  :   gen_quant_list = NULL;

	mov	DWORD PTR _gen_quant_list, eax

; 345  : 
; 346  :   meth_inst_list = NULL;

	mov	DWORD PTR _meth_inst_list, eax

; 347  :   meth_inst_list_max = 0;

	mov	DWORD PTR _meth_inst_list_max, eax

; 348  :   meth_inst_count = 0;

	mov	DWORD PTR _web+5560, eax

; 349  :   meth_inst_free_head = -1;

	mov	DWORD PTR _web+5564, ecx

; 350  : 
; 351  :   compound_quant_list_head = -1;

	mov	DWORD PTR _compound_quant_list_head, ecx

; 352  : 
; 353  :   for ( k = 0 ; k < NUMELEMENTS ; k++ ) 
; 354  :   { quant_flags[k] = 0;

	mov	DWORD PTR _web+5628, eax

; 355  :     global_meth_inst_count[k] = 0;

	mov	DWORD PTR _web+5588, eax
	mov	DWORD PTR _web+5632, eax
	mov	DWORD PTR _web+5592, eax
	mov	DWORD PTR _web+5636, eax
	mov	DWORD PTR _web+5596, eax
	mov	DWORD PTR _web+5640, eax
	mov	DWORD PTR _web+5600, eax
	mov	DWORD PTR _web+5644, eax
	mov	DWORD PTR _web+5604, eax

; 356  :   }
; 357  :   memset((char*)global_meth_inst,0,sizeof(global_meth_inst));

	mov	DWORD PTR _web+5568, eax
	mov	DWORD PTR _web+5572, eax
	mov	DWORD PTR _web+5576, eax
	mov	DWORD PTR _web+5580, eax
	mov	DWORD PTR _web+5584, eax

; 358  : } // end quantity_init()

	ret	0
_quantity_init ENDP
_TEXT	ENDS
PUBLIC	_find_quantity
EXTRN	_lookup_global_hash:PROC
; Function compile flags: /Ogtp
;	COMDAT _find_quantity
_TEXT	SEGMENT
_name$ = 8						; size = 4
_find_quantity PROC					; COMDAT

; 370  : { int q;

	push	ebp
	mov	ebp, esp

; 371  : 
; 372  :   q = lookup_global_hash(name,0,QUANTITYNAME,HASH_LOOK);

	mov	eax, DWORD PTR _name$[ebp]
	push	0
	push	1610612736				; 60000000H
	push	0
	push	eax
	call	_lookup_global_hash

; 373  :   if ( (q & NAMETYPEMASK) == QUANTITYNAME )

	mov	ecx, eax
	and	ecx, -536870912				; e0000000H
	add	esp, 16					; 00000010H
	cmp	ecx, 1610612736				; 60000000H
	jne	SHORT $LN1@find_quant

; 374  :     return q & INDEXMASK;

	and	eax, 536870911				; 1fffffffH

; 377  : } // end find_quantity()

	pop	ebp
	ret	0
$LN1@find_quant:

; 375  : 
; 376  :   return -1;

	or	eax, -1

; 377  : } // end find_quantity()

	pop	ebp
	ret	0
_find_quantity ENDP
_TEXT	ENDS
PUBLIC	_find_method_instance
; Function compile flags: /Ogtp
;	COMDAT _find_method_instance
_TEXT	SEGMENT
_name$ = 8						; size = 4
_find_method_instance PROC				; COMDAT

; 389  : { int n;

	push	ebp
	mov	ebp, esp

; 390  :   
; 391  :   n = lookup_global_hash(name,0,METHODNAME,HASH_LOOK);

	mov	eax, DWORD PTR _name$[ebp]
	push	0
	push	1073741824				; 40000000H
	push	0
	push	eax
	call	_lookup_global_hash

; 392  :   if ( (n & NAMETYPEMASK) == METHODNAME )

	mov	ecx, eax
	and	ecx, -536870912				; e0000000H
	add	esp, 16					; 00000010H
	cmp	ecx, 1073741824				; 40000000H
	jne	SHORT $LN1@find_metho

; 393  :     return n & INDEXMASK;

	and	eax, 536870911				; 1fffffffH

; 396  : } // end find_method_instance()

	pop	ebp
	ret	0
$LN1@find_metho:

; 394  : 
; 395  :   return -1;

	or	eax, -1

; 396  : } // end find_method_instance()

	pop	ebp
	ret	0
_find_method_instance ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@		; `string'
PUBLIC	_new_quantity_alloc
EXTRN	_KB_realloc:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
CONST	SEGMENT
??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@ DB 'QUANTITY.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _new_quantity_alloc
_TEXT	SEGMENT
_new_quantity_alloc PROC				; COMDAT

; 408  : 
; 409  :   if ( gen_quant_free_head < 0 )

	cmp	DWORD PTR _web+5536, 0
	push	esi
	jge	$LN9@new_quanti

; 410  :   { int old_max = gen_quant_list_max;

	mov	esi, DWORD PTR _gen_quant_list_max

; 411  :     int i;
; 412  : 
; 413  :     if ( gen_quant_list_max == 0 )

	test	esi, esi
	jne	SHORT $LN8@new_quanti

; 414  :     { if ( quantities_predicted )

	mov	eax, DWORD PTR _quantities_predicted
	test	eax, eax

; 415  :         gen_quant_list_max = quantities_predicted;
; 416  :      else

	jne	SHORT $LN16@new_quanti

; 417  :        gen_quant_list_max = 1000;

	mov	eax, 1000				; 000003e8H

; 418  :     }
; 419  :     else gen_quant_list_max *= 2;

	jmp	SHORT $LN16@new_quanti
$LN8@new_quanti:
	lea	eax, DWORD PTR [esi+esi]
$LN16@new_quanti:
	mov	DWORD PTR _gen_quant_list_max, eax

; 420  :     gen_quant_list = (struct gen_quant*)kb_realloc((char*)gen_quant_list,
; 421  :          gen_quant_list_max*sizeof(struct gen_quant));

	imul	eax, 368				; 00000170H
	push	421					; 000001a5H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	eax
	mov	eax, DWORD PTR _gen_quant_list
	push	eax
	call	_KB_realloc

; 422  :     gen_quant_free_head = old_max;
; 423  :     for ( i = old_max ; i < gen_quant_list_max-1 ; i++ )

	mov	ecx, DWORD PTR _gen_quant_list_max
	lea	edx, DWORD PTR [ecx-1]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gen_quant_list, eax
	mov	DWORD PTR _web+5536, esi
	mov	eax, esi
	cmp	esi, edx
	jge	SHORT $LN2@new_quanti

; 420  :     gen_quant_list = (struct gen_quant*)kb_realloc((char*)gen_quant_list,
; 421  :          gen_quant_list_max*sizeof(struct gen_quant));

	imul	esi, 368				; 00000170H
	mov	edx, esi
$LL15@new_quanti:

; 424  :        GEN_QUANT(i)->next = i+1;

	mov	ecx, DWORD PTR _gen_quant_list
	inc	eax
	mov	DWORD PTR [edx+ecx+128], eax
	mov	ecx, DWORD PTR _gen_quant_list_max
	lea	esi, DWORD PTR [ecx-1]
	add	edx, 368				; 00000170H
	cmp	eax, esi
	jl	SHORT $LL15@new_quanti
$LN2@new_quanti:

; 425  :     GEN_QUANT(gen_quant_list_max-1)->next = -1;

	mov	edx, DWORD PTR _gen_quant_list
	imul	ecx, 368				; 00000170H
	mov	DWORD PTR [ecx+edx-240], -1
$LN9@new_quanti:

; 426  :   }
; 427  : 
; 428  :   retval = (int)gen_quant_free_head;

	mov	esi, DWORD PTR _web+5536

; 429  :   gen_quant_free_head = GEN_QUANT(retval)->next;

	mov	eax, esi
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list

; 430  :   memset(GEN_QUANT(retval),0,sizeof(struct gen_quant));

	push	368					; 00000170H
	mov	edx, DWORD PTR [eax+128]
	push	0
	push	eax
	mov	DWORD PTR _web+5536, edx
	call	_memset
	add	esp, 12					; 0000000cH

; 431  : 
; 432  :   if ( retval >= gen_quant_count )

	cmp	esi, DWORD PTR _web+5528
	jl	SHORT $LN14@new_quanti

; 433  :     gen_quant_count = retval+1;

	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR _web+5528, eax
$LN14@new_quanti:

; 434  : 
; 435  :   return retval;

	mov	eax, esi
	pop	esi

; 436  :  
; 437  : } // end new_quantity_alloc()

	ret	0
_new_quantity_alloc ENDP
_TEXT	ENDS
PUBLIC	_free_quantity
; Function compile flags: /Ogtp
;	COMDAT _free_quantity
_TEXT	SEGMENT
_q$ = 8							; size = 4
_free_quantity PROC					; COMDAT

; 447  : { if ( q->flags & Q_DELETED )

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _q$[ebp]
	mov	eax, 524288				; 00080000H
	test	DWORD PTR [esi+136], eax
	jne	SHORT $LN2@free_quant

; 448  :     return;
; 449  :   q->next = (int)gen_quant_free_head;

	mov	ecx, DWORD PTR _web+5536

; 450  :   q->flags = Q_DELETED;
; 451  :   lookup_global_hash(q->name,0,QUANTITYNAME,HASH_DELETE);

	push	2
	push	1610612736				; 60000000H
	push	0
	push	esi
	mov	DWORD PTR [esi+128], ecx
	mov	DWORD PTR [esi+136], eax
	call	_lookup_global_hash

; 452  :   q->name[0] = 0;

	mov	BYTE PTR [esi], 0

; 453  :   gen_quant_free_head = (int)(q - gen_quant_list);

	sub	esi, DWORD PTR _gen_quant_list
	mov	eax, -1307163959			; b21642c9H
	imul	esi
	add	edx, esi
	sar	edx, 8
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	esp, 16					; 00000010H
	add	eax, edx
	mov	DWORD PTR _web+5536, eax
$LN2@free_quant:
	pop	esi

; 454  : } // end free_quantity()

	pop	ebp
	ret	0
_free_quantity ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_0BI@LAHHFKLM@?8?$CFs?8?5already?5declared?4?6?$AA@ ; `string'
PUBLIC	_new_quantity
EXTRN	_strncpy:PROC
EXTRN	_kb_error:PROC
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
EXTRN	_addload_flag:DWORD
EXTRN	_datafile_flag:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_0BI@LAHHFKLM@?8?$CFs?8?5already?5declared?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@LAHHFKLM@?8?$CFs?8?5already?5declared?4?6?$AA@ DB '''%s'' alrea'
	DB	'dy declared.', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _new_quantity
_TEXT	SEGMENT
_name$ = 8						; size = 4
_mode$ = 12						; size = 4
_new_quantity PROC					; COMDAT

; 469  : { int q=0;  /* new structure */

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 470  :   int g;  /* hash return */
; 471  :  
; 472  :   /* check to see if name used, and add if not */
; 473  :   g = lookup_global_hash(name,0,QUANTITYNAME,0);

	mov	edi, DWORD PTR _name$[ebp]
	xor	esi, esi
	push	esi
	push	1610612736				; 60000000H
	push	esi
	push	edi
	call	_lookup_global_hash
	add	esp, 16					; 00000010H

; 474  :   if ( g != 0 )

	test	eax, eax
	je	SHORT $LN6@new_quanti@2

; 475  :   { int qq = g & INDEXMASK;

	and	eax, 536870911				; 1fffffffH

; 476  :     if ( datafile_flag == IN_DATAFILE )

	cmp	DWORD PTR _datafile_flag, 1
	jne	$LN9@new_quanti@2

; 477  :     { if ( (GEN_QUANT(qq)->flags & Q_FORWARD_DEF) || addload_flag )

	mov	edx, DWORD PTR _gen_quant_list
	mov	ecx, eax
	imul	ecx, 368				; 00000170H
	test	DWORD PTR [ecx+edx+136], 1048576	; 00100000H
	jne	SHORT $LN3@new_quanti@2
	cmp	DWORD PTR _addload_flag, esi
	jne	SHORT $LN3@new_quanti@2

; 480  :       }
; 481  :       else
; 482  :       { 
; 483  :         sprintf(errmsg,"'%s' already declared.\n",name);

	push	edi
	push	OFFSET ??_C@_0BI@LAHHFKLM@?8?$CFs?8?5already?5declared?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 484  :         kb_error(1555,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1555					; 00000613H
	call	_kb_error
	add	esp, 24					; 00000018H
	jmp	SHORT $LN9@new_quanti@2
$LN3@new_quanti@2:

; 478  :       { 
; 479  :         q = qq;

	mov	esi, eax

; 485  :       }
; 486  :     }
; 487  :   }
; 488  :   else /* need to allocate new structure */

	jmp	SHORT $LN9@new_quanti@2
$LN6@new_quanti@2:

; 489  :   { 
; 490  :     /* initialize */
; 491  :     q = new_quantity_alloc(); 

	call	_new_quantity_alloc

; 492  :     g = lookup_global_hash(name,q,QUANTITYNAME,HASH_ADD);

	push	1
	mov	esi, eax
	push	1610612736				; 60000000H
	push	esi
	push	edi
	call	_lookup_global_hash

; 493  :     GEN_QUANT(q)->num = q;
; 494  :     GEN_QUANT(q)->modulus = 1.0;

	fld1
	mov	ecx, DWORD PTR _gen_quant_list
	mov	eax, esi
	imul	eax, 368				; 00000170H
	mov	DWORD PTR [eax+ecx+132], esi
	mov	edx, DWORD PTR _gen_quant_list

; 495  :     GEN_QUANT(q)->timestamp = -1;
; 496  :     GEN_QUANT(q)->tolerance = -1.0;
; 497  :     strncpy(GEN_QUANT(q)->name,name,sizeof(GEN_QUANT(q)->name));

	push	128					; 00000080H
	push	edi
	fstp	QWORD PTR [eax+edx+176]
	mov	ecx, DWORD PTR _gen_quant_list
	fld	QWORD PTR __real@bff0000000000000
	mov	DWORD PTR [eax+ecx+364], -1
	mov	edx, DWORD PTR _gen_quant_list
	fstp	QWORD PTR [eax+edx+184]
	add	eax, DWORD PTR _gen_quant_list
	push	eax
	call	_strncpy
	add	esp, 28					; 0000001cH
$LN9@new_quanti@2:

; 498  :   }
; 499  :     
; 500  :   GEN_QUANT(q)->flags = mode;

	mov	eax, DWORD PTR _mode$[ebp]
	mov	ecx, DWORD PTR _gen_quant_list
	mov	edx, esi
	imul	edx, 368				; 00000170H
	mov	DWORD PTR [edx+ecx+136], eax
	pop	edi

; 501  :   return q;

	mov	eax, esi
	pop	esi

; 502  : } // end new_quantity()

	pop	ebp
	ret	0
_new_quantity ENDP
_TEXT	ENDS
PUBLIC	_new_method_instance_alloc
; Function compile flags: /Ogtp
;	COMDAT _new_method_instance_alloc
_TEXT	SEGMENT
_new_method_instance_alloc PROC				; COMDAT

; 514  : 
; 515  :   if ( meth_inst_free_head <= 0 )

	cmp	DWORD PTR _web+5564, 0
	push	esi
	jg	$LN18@new_method

; 516  :   { int old_max = meth_inst_list_max;

	mov	esi, DWORD PTR _meth_inst_list_max

; 517  :     int i;
; 518  : 
; 519  :     if ( meth_inst_list_max == 0 )

	test	esi, esi
	jne	SHORT $LN8@new_method

; 520  :     { if ( method_instances_predicted )

	mov	eax, DWORD PTR _method_instances_predicted
	test	eax, eax

; 521  :          meth_inst_list_max = method_instances_predicted;
; 522  :       else

	jne	SHORT $LN19@new_method

; 523  :          meth_inst_list_max = 1000;

	mov	eax, 1000				; 000003e8H

; 524  :     }
; 525  :     else meth_inst_list_max *= 2;

	jmp	SHORT $LN19@new_method
$LN8@new_method:
	lea	eax, DWORD PTR [esi+esi]
$LN19@new_method:
	mov	DWORD PTR _meth_inst_list_max, eax

; 526  :     meth_inst_list = (struct method_instance*)kb_realloc((char*)meth_inst_list,
; 527  :          meth_inst_list_max*sizeof(struct method_instance));

	imul	eax, 2928				; 00000b70H
	push	527					; 0000020fH
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	eax
	mov	eax, DWORD PTR _meth_inst_list
	push	eax
	call	_KB_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _meth_inst_list, eax

; 528  :     meth_inst_free_head = (old_max == 0) ? LOW_INST : old_max;

	mov	DWORD PTR _web+5564, 1
	test	esi, esi
	je	SHORT $LN13@new_method
	mov	DWORD PTR _web+5564, esi
$LN13@new_method:

; 529  :     for ( i = old_max ; i < meth_inst_list_max-1 ; i++ )

	mov	ecx, DWORD PTR _meth_inst_list_max
	dec	ecx
	mov	eax, esi
	cmp	esi, ecx
	jge	SHORT $LN18@new_method
$LL17@new_method:

; 530  :        METH_INSTANCE(i)->next = i+1;

	lea	ecx, DWORD PTR [eax+1]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	mov	DWORD PTR [eax+edx+128], ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR _meth_inst_list_max
	dec	ecx
	cmp	eax, ecx
	jl	SHORT $LL17@new_method
$LN18@new_method:

; 531  :   }
; 532  : 
; 533  :   retval = (int)meth_inst_free_head;

	mov	esi, DWORD PTR _web+5564

; 534  :   meth_inst_free_head = METH_INSTANCE(retval)->next;

	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 535  :   memset(METH_INSTANCE(retval),0,sizeof(struct method_instance));

	push	2928					; 00000b70H
	mov	ecx, DWORD PTR [eax+128]
	push	0
	push	eax
	mov	DWORD PTR _web+5564, ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 539  : 
; 540  :   return retval;

	mov	eax, esi
	cmp	esi, DWORD PTR _web+5560
	jl	SHORT $LN1@new_method

; 536  : 
; 537  :   if ( retval >= meth_inst_count )
; 538  :     meth_inst_count = retval+1;

	lea	edx, DWORD PTR [esi+1]
	mov	DWORD PTR _web+5560, edx
$LN1@new_method:
	pop	esi

; 541  :  
; 542  : } // end new_method_instance_alloc()

	ret	0
_new_method_instance_alloc ENDP
_TEXT	ENDS
PUBLIC	_free_method_instance
; Function compile flags: /Ogtp
;	COMDAT _free_method_instance
_TEXT	SEGMENT
_mi$ = 8						; size = 4
_free_method_instance PROC				; COMDAT

; 552  : { if ( mi->flags & Q_DELETED )

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _mi$[ebp]
	mov	eax, 524288				; 00080000H
	test	DWORD PTR [esi+140], eax
	jne	SHORT $LN3@free_metho

; 553  :     return;
; 554  :   mi->next = (int)meth_inst_free_head;
; 555  :   mi->flags = Q_DELETED;
; 556  :   if ( mi->name[0] )

	cmp	BYTE PTR [esi], 0
	mov	ecx, DWORD PTR _web+5564
	mov	DWORD PTR [esi+128], ecx
	mov	DWORD PTR [esi+140], eax
	je	SHORT $LN1@free_metho

; 557  :   { lookup_global_hash(mi->name,0,METHODNAME,HASH_DELETE);

	push	2
	push	1073741824				; 40000000H
	push	0
	push	esi
	call	_lookup_global_hash
	add	esp, 16					; 00000010H

; 558  :     mi->name[0] = 0;

	mov	BYTE PTR [esi], 0
$LN1@free_metho:

; 559  :   }
; 560  :   meth_inst_free_head = (int)(mi - meth_inst_list);

	sub	esi, DWORD PTR _meth_inst_list
	mov	eax, -1290837165			; b30f6353H
	imul	esi
	add	edx, esi
	sar	edx, 11					; 0000000bH
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _web+5564, eax
$LN3@free_metho:
	pop	esi

; 561  : }

	pop	ebp
	ret	0
_free_method_instance ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@KCNLDFIP@Method?5name?5too?5long?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@GNBBHICG@No?5method?5?8?$CFs?8?5exists?4?6?$AA@ ; `string'
PUBLIC	_new_method_instance
EXTRN	_kb_stricmp:PROC
;	COMDAT ??_C@_0BK@KCNLDFIP@Method?5name?5too?5long?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BK@KCNLDFIP@Method?5name?5too?5long?3?5?$CFs?6?$AA@ DB 'Method nam'
	DB	'e too long: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GNBBHICG@No?5method?5?8?$CFs?8?5exists?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@GNBBHICG@No?5method?5?8?$CFs?8?5exists?4?6?$AA@ DB 'No method '''
	DB	'%s'' exists.', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _new_method_instance
_TEXT	SEGMENT
_inum$89313 = -4					; size = 4
_inst_num$ = 8						; size = 4
_meth_name$ = 8						; size = 4
_inst_name$ = 12					; size = 4
_new_method_instance PROC				; COMDAT

; 578  : { struct method_instance *m; /*  new instance */

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 579  : 
; 580  :   struct gen_quant_method *gm=NULL;
; 581  :   int j,n=0,nb;
; 582  :   int inst_num; /* number of new instance */
; 583  :   int g; /* hash return */
; 584  : 
; 585  :   if ( meth_name )

	mov	ebx, DWORD PTR _meth_name$[ebp]
	push	esi
	push	edi
	xor	edi, edi
	xor	esi, esi
	test	ebx, ebx
	je	SHORT $LN12@new_method@2

; 586  :   {
; 587  :     nb =  sizeof(basic_gen_methods)/sizeof(struct gen_quant_method);
; 588  : 
; 589  :     for ( gm = basic_gen_methods,n = 0 ; n < nb ; n++,gm++ )

	mov	edi, OFFSET _basic_gen_methods
$LL16@new_method@2:

; 590  :       if ( stricmp(gm->name,meth_name) == 0 ) break;

	push	ebx
	push	edi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@new_method@2

; 586  :   {
; 587  :     nb =  sizeof(basic_gen_methods)/sizeof(struct gen_quant_method);
; 588  : 
; 589  :     for ( gm = basic_gen_methods,n = 0 ; n < nb ; n++,gm++ )

	inc	esi
	add	edi, 160				; 000000a0H
	cmp	esi, 127				; 0000007fH
	jl	SHORT $LL16@new_method@2

; 591  :     if ( n >= nb )

	jmp	SHORT $LN34@new_method@2
$LN22@new_method@2:
	cmp	esi, 127				; 0000007fH
	jl	SHORT $LN12@new_method@2
$LN34@new_method@2:

; 592  :     { sprintf(errmsg,"No method '%s' exists.\n",meth_name);

	push	ebx
	push	OFFSET ??_C@_0BI@GNBBHICG@No?5method?5?8?$CFs?8?5exists?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 593  :       kb_error(1559,errmsg,DATAFILE_ERROR); return -1; 

	push	6
	push	OFFSET _errmsg
	push	1559					; 00000617H
	call	_kb_error
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx

; 640  : 
; 641  : } // end new_method_instance()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@new_method@2:

; 594  :     }
; 595  :   }
; 596  :   
; 597  :   inst_num = new_method_instance_alloc();

	call	_new_method_instance_alloc
	mov	DWORD PTR _inst_num$[ebp], eax

; 598  :   m = METH_INSTANCE(inst_num);

	cdq
	mov	ebx, eax
	xor	ebx, edx
	sub	ebx, edx
	imul	ebx, 2928				; 00000b70H
	add	ebx, DWORD PTR _meth_inst_list

; 599  :   memset(m,0,sizeof(struct method_instance));

	push	2928					; 00000b70H
	push	0
	push	ebx
	call	_memset

; 600  :   m->self_id = METHBASE + inst_num;

	mov	eax, DWORD PTR _inst_num$[ebp]

; 601  :   m->modulus = 1.0;

	fld1

; 602  :   m->gen_method = n;

	mov	DWORD PTR [ebx+148], esi
	fstp	QWORD PTR [ebx+304]
	add	eax, 65536				; 00010000H
	mov	DWORD PTR [ebx+132], eax

; 603  :   for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 604  :     m->quants[j] = -1; /* not attached to quantity yet */

	or	eax, -1
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx+152], eax
	mov	DWORD PTR [ebx+156], eax
	mov	DWORD PTR [ebx+160], eax
	mov	DWORD PTR [ebx+164], eax
	mov	DWORD PTR [ebx+168], eax
	mov	DWORD PTR [ebx+172], eax
	mov	DWORD PTR [ebx+176], eax
	mov	DWORD PTR [ebx+180], eax

; 605  :   m->timestamp = -1;

	mov	DWORD PTR [ebx+2924], eax

; 606  :   if ( gm ) 

	test	edi, edi
	je	SHORT $LN7@new_method@2

; 607  :   { m->type = gm->type;

	mov	ecx, DWORD PTR [edi+128]
	mov	DWORD PTR [ebx+136], ecx

; 608  :     if ( gm->spec_flags & SPEC_USE_DENSITY )

	test	BYTE PTR [edi+136], 32			; 00000020H
	je	SHORT $LN7@new_method@2

; 609  :       m->flags |= USE_DENSITY;

	or	DWORD PTR [ebx+140], 536870912		; 20000000H
$LN7@new_method@2:

; 610  :    }
; 611  :   if ( strlen(inst_name) >= MNAMESIZE )

	mov	esi, DWORD PTR _inst_name$[ebp]
	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$LL35@new_method@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL35@new_method@2
	sub	eax, edx
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN36@new_method@2

; 612  :   { sprintf(errmsg,"Method name too long: %s\n",inst_name);

	push	esi
	push	OFFSET ??_C@_0BK@KCNLDFIP@Method?5name?5too?5long?3?5?$CFs?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 613  :     kb_error(2856,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2856					; 00000b28H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN36@new_method@2:

; 614  :   }
; 615  :   strncpy(m->name,inst_name,sizeof(m->name));

	push	128					; 00000080H
	push	esi
	push	ebx
	call	_strncpy

; 616  : 
; 617  :   g = lookup_global_hash(inst_name,inst_num,METHODNAME,HASH_ADD);

	mov	edx, DWORD PTR _inst_num$[ebp]
	push	1
	push	1073741824				; 40000000H
	push	edx
	push	esi
	call	_lookup_global_hash
	add	esp, 28					; 0000001cH

; 618  :   if ( g != 0 )

	test	eax, eax
	je	$LN5@new_method@2

; 619  :   { int inum = g & INDEXMASK;

	and	eax, 536870911				; 1fffffffH

; 620  :     
; 621  :     // Oops. So deallocate
; 622  : 
; 623  :     if ( datafile_flag == IN_DATAFILE )

	cmp	DWORD PTR _datafile_flag, 1
	mov	DWORD PTR _inum$89313[ebp], eax
	jne	SHORT $LN1@new_method@2

; 624  :     { if ( (METH_INSTANCE(inum)->flags & Q_FORWARD_DEF) || addload_flag )

	mov	ecx, DWORD PTR _meth_inst_list
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	test	DWORD PTR [eax+ecx+140], 1048576	; 00100000H
	lea	edi, DWORD PTR [eax+ecx]
	jne	SHORT $LN2@new_method@2
	cmp	DWORD PTR _addload_flag, 0
	jne	SHORT $LN2@new_method@2

; 628  :       }
; 629  :       else
; 630  :       { sprintf(errmsg,"'%s' already declared.\n",inst_name);

	push	esi
	push	OFFSET ??_C@_0BI@LAHHFKLM@?8?$CFs?8?5already?5declared?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 631  :         memset((char*)m,0,sizeof(struct method_instance));    

	push	2928					; 00000b70H
	push	0
	push	ebx
	call	_memset

; 632  :         kb_error(2503,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2503					; 000009c7H
	call	_kb_error
	add	esp, 36					; 00000024H
	jmp	SHORT $LN1@new_method@2
$LN2@new_method@2:

; 625  :       { *METH_INSTANCE(inum) = *m; /* copy over initialization */

	mov	ecx, 732				; 000002dcH
	mov	esi, ebx
	rep movsd

; 626  :         inst_num = inum;

	mov	ecx, DWORD PTR _inum$89313[ebp]

; 627  :         METH_INSTANCE(inum)->self_id = METHBASE + inst_num;

	mov	edx, DWORD PTR _meth_inst_list
	mov	DWORD PTR _inst_num$[ebp], ecx
	add	ecx, 65536				; 00010000H
	mov	DWORD PTR [eax+edx+132], ecx
$LN1@new_method@2:

; 633  :       }
; 634  :     }
; 635  :     m->name[0] = 0;  // so don't delete name from hash table
; 636  :     free_method_instance(m);

	push	ebx
	mov	BYTE PTR [ebx], 0
	call	_free_method_instance
	add	esp, 4
$LN5@new_method@2:

; 637  :   }
; 638  : 
; 639  :   return inst_num;

	mov	eax, DWORD PTR _inst_num$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 640  : 
; 641  : } // end new_method_instance()

	mov	esp, ebp
	pop	ebp
	ret	0
_new_method_instance ENDP
_TEXT	ENDS
PUBLIC	_dup_method_instance
; Function compile flags: /Ogtp
;	COMDAT _dup_method_instance
_TEXT	SEGMENT
_inum$89337 = -8					; size = 4
_inst_num$ = -4						; size = 4
_old_inst_name$ = 8					; size = 4
_new_inst_name$ = 12					; size = 4
_dup_method_instance PROC				; COMDAT

; 659  : { struct method_instance *m; /*  new instance */

	push	ebp
	mov	ebp, esp

; 660  :   int j;
; 661  :   int inst_num; /* number of new instance */
; 662  :   int g; /* hash return */
; 663  :   int old_inst_num;
; 664  : 
; 665  :   // find old instance
; 666  :   g = lookup_global_hash(old_inst_name,0,METHODNAME,HASH_LOOK);

	mov	eax, DWORD PTR _old_inst_name$[ebp]
	sub	esp, 8
	push	0
	push	1073741824				; 40000000H
	push	0
	push	eax
	call	_lookup_global_hash
	add	esp, 16					; 00000010H

; 667  :   if ( g != 0 )

	test	eax, eax
	je	$LN11@dup_method

; 668  :     old_inst_num = g & INDEXMASK;

	push	ebx
	push	esi
	and	eax, 536870911				; 1fffffffH
	push	edi
	mov	esi, eax

; 671  :  
; 672  :   inst_num = new_method_instance_alloc();

	call	_new_method_instance_alloc

; 673  :   m = METH_INSTANCE(inst_num);

	mov	ecx, DWORD PTR _meth_inst_list
	mov	DWORD PTR _inst_num$[ebp], eax
	cdq
	mov	ebx, eax

; 674  :   *m = *METH_INSTANCE(old_inst_num);

	mov	eax, esi
	xor	ebx, edx
	sub	ebx, edx
	cdq
	imul	ebx, 2928				; 00000b70H
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	add	ebx, ecx
	imul	esi, 2928				; 00000b70H
	add	esi, ecx
	mov	ecx, 732				; 000002dcH
	mov	edi, ebx
	rep movsd

; 675  :   m->self_id = METHBASE + inst_num;

	mov	ecx, DWORD PTR _inst_num$[ebp]

; 676  :   for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 677  :     m->quants[j] = -1; /* not attached to quantity yet */
; 678  :   m->timestamp = -1;
; 679  :   if ( strlen(new_inst_name) >= MNAMESIZE )

	mov	esi, DWORD PTR _new_inst_name$[ebp]
	add	ecx, 65536				; 00010000H
	or	eax, -1
	mov	DWORD PTR [ebx+132], ecx
	mov	DWORD PTR [ebx+152], eax
	mov	DWORD PTR [ebx+156], eax
	mov	DWORD PTR [ebx+160], eax
	mov	DWORD PTR [ebx+164], eax
	mov	DWORD PTR [ebx+168], eax
	mov	DWORD PTR [ebx+172], eax
	mov	DWORD PTR [ebx+176], eax
	mov	DWORD PTR [ebx+180], eax
	mov	DWORD PTR [ebx+2924], eax
	mov	eax, esi
	lea	edi, DWORD PTR [eax+1]
$LL25@dup_method:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL25@dup_method
	sub	eax, edi
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN26@dup_method

; 680  :   { sprintf(errmsg,"Method name too long: %s\n",new_inst_name);

	push	esi
	push	OFFSET ??_C@_0BK@KCNLDFIP@Method?5name?5too?5long?3?5?$CFs?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 681  :     kb_error(2504,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2504					; 000009c8H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN26@dup_method:

; 682  :   }
; 683  :   strncpy(m->name,new_inst_name,sizeof(m->name));

	push	128					; 00000080H
	push	esi
	push	ebx
	call	_strncpy

; 684  : 
; 685  :   g = lookup_global_hash(new_inst_name,inst_num,METHODNAME,HASH_ADD);

	mov	edx, DWORD PTR _inst_num$[ebp]
	push	1
	push	1073741824				; 40000000H
	push	edx
	push	esi
	call	_lookup_global_hash
	add	esp, 28					; 0000001cH

; 686  :   if ( g != 0 )

	test	eax, eax
	je	$LN5@dup_method

; 687  :   { int inum = g & INDEXMASK;

	and	eax, 536870911				; 1fffffffH

; 688  :     
; 689  :     // Oops. So deallocate
; 690  : 
; 691  :     if ( datafile_flag == IN_DATAFILE )

	cmp	DWORD PTR _datafile_flag, 1
	mov	DWORD PTR _inum$89337[ebp], eax
	jne	$LN1@dup_method

; 692  :     { if ( (METH_INSTANCE(inum)->flags & Q_FORWARD_DEF) || addload_flag )

	mov	ecx, DWORD PTR _meth_inst_list
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	test	DWORD PTR [eax+ecx+140], 1048576	; 00100000H
	lea	edi, DWORD PTR [eax+ecx]
	jne	SHORT $LN2@dup_method
	cmp	DWORD PTR _addload_flag, 0
	jne	SHORT $LN2@dup_method

; 696  :       }
; 697  :       else
; 698  :       { sprintf(errmsg,"'%s' already declared.\n",new_inst_name);    

	push	esi
	push	OFFSET ??_C@_0BI@LAHHFKLM@?8?$CFs?8?5already?5declared?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 699  :         kb_error(1558,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1558					; 00000616H
	call	_kb_error
	add	esp, 24					; 00000018H

; 700  :       }
; 701  :     }
; 702  :     free_method_instance(m);

	push	ebx
	call	_free_method_instance

; 703  :   }
; 704  : 
; 705  :   return inst_num;

	mov	eax, DWORD PTR _inst_num$[ebp]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 706  : 
; 707  : } // end dup_method_instance()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@dup_method:

; 693  :       { *METH_INSTANCE(inum) = *m; /* copy over initialization */

	mov	ecx, 732				; 000002dcH
	mov	esi, ebx
	rep movsd

; 694  :         inst_num = inum;

	mov	ecx, DWORD PTR _inum$89337[ebp]

; 695  :         METH_INSTANCE(inum)->self_id = METHBASE + inst_num;

	mov	edx, DWORD PTR _meth_inst_list
	mov	DWORD PTR _inst_num$[ebp], ecx
	add	ecx, 65536				; 00010000H
	mov	DWORD PTR [eax+edx+132], ecx
$LN1@dup_method:

; 700  :       }
; 701  :     }
; 702  :     free_method_instance(m);

	push	ebx
	call	_free_method_instance
	add	esp, 4
$LN5@dup_method:

; 703  :   }
; 704  : 
; 705  :   return inst_num;

	mov	eax, DWORD PTR _inst_num$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 706  : 
; 707  : } // end dup_method_instance()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@dup_method:

; 669  :   else
; 670  :     return -1;

	or	eax, -1

; 706  : 
; 707  : } // end dup_method_instance()

	mov	esp, ebp
	pop	ebp
	ret	0
_dup_method_instance ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@JNIJLDFI@Sorry?$DL?5method?5?$CFs?5does?5not?5have?5a@ ; `string'
PUBLIC	??_C@_0EN@PHOPGAJG@?$CFs?3?5Sorry?0?5but?5for?5now?0?5a?5method@ ; `string'
PUBLIC	??_C@_0DP@PHPKBPIE@Internal?5error?3?5Unknown?5method?5n@ ; `string'
PUBLIC	_attach_method_num
EXTRN	_kb_calloc:PROC
;	COMDAT ??_C@_0DG@JNIJLDFI@Sorry?$DL?5method?5?$CFs?5does?5not?5have?5a@
CONST	SEGMENT
??_C@_0DG@JNIJLDFI@Sorry?$DL?5method?5?$CFs?5does?5not?5have?5a@ DB 'Sorr'
	DB	'y; method %s does not have a gradient available.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@PHOPGAJG@?$CFs?3?5Sorry?0?5but?5for?5now?0?5a?5method@
CONST	SEGMENT
??_C@_0EN@PHOPGAJG@?$CFs?3?5Sorry?0?5but?5for?5now?0?5a?5method@ DB '%s: '
	DB	'Sorry, but for now, a method instance can only belong to %d q'
	DB	'uantities.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@PHPKBPIE@Internal?5error?3?5Unknown?5method?5n@
CONST	SEGMENT
??_C@_0DP@PHPKBPIE@Internal?5error?3?5Unknown?5method?5n@ DB 'Internal er'
	DB	'ror: Unknown method number in attach_method_num().', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _attach_method_num
_TEXT	SEGMENT
_quantnum$ = 8						; size = 4
_inst_num$ = 12						; size = 4
_attach_method_num PROC					; COMDAT

; 776  : { struct method_instance *m = METH_INSTANCE(inst_num);

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _inst_num$[ebp]
	push	ebx
	push	esi

; 777  :   struct gen_quant_method *gm;
; 778  :   struct gen_quant *quant = GEN_QUANT(quantnum);

	mov	esi, DWORD PTR _quantnum$[ebp]
	push	edi
	imul	esi, 368				; 00000170H
	add	esi, DWORD PTR _gen_quant_list
	mov	eax, ecx
	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
	imul	edi, 2928				; 00000b70H
	add	edi, DWORD PTR _meth_inst_list

; 779  :   int i;
; 780  : 
; 781  :   if ( (inst_num < 0) || (inst_num >= meth_inst_count) )

	test	ecx, ecx
	js	SHORT $LN15@attach_met
	cmp	ecx, DWORD PTR _web+5560
	jl	SHORT $LN16@attach_met
$LN15@attach_met:

; 782  :    kb_error(2446,
; 783  :     "Internal error: Unknown method number in attach_method_num().\n",
; 784  :      RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DP@PHPKBPIE@Internal?5error?3?5Unknown?5method?5n@
	push	2446					; 0000098eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN16@attach_met:

; 785  : 
; 786  :   for ( i = 0 ; i < MMAXQUANTS ; i++ )

	xor	eax, eax
	lea	ecx, DWORD PTR [edi+152]
$LL14@attach_met:

; 787  :   { if ( m->quants[i] == quantnum )

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _quantnum$[ebp]
	je	SHORT $LN27@attach_met

; 788  :       break;
; 789  :     if ( m->quants[i] == -1 )

	cmp	edx, -1
	je	SHORT $LN22@attach_met

; 785  : 
; 786  :   for ( i = 0 ; i < MMAXQUANTS ; i++ )

	inc	eax
	add	ecx, 4
	cmp	eax, 8
	jl	SHORT $LL14@attach_met

; 806  :     if ( quant->meth_inst[i] == inst_num ) 

	jmp	SHORT $LN27@attach_met
$LN22@attach_met:

; 790  :     {  m->quants[i] = quant->num;

	mov	ecx, DWORD PTR [esi+132]
	mov	DWORD PTR [edi+eax*4+152], ecx
$LN27@attach_met:

; 791  :        break;
; 792  :     }
; 793  :   }
; 794  :   if ( i == MMAXQUANTS )

	cmp	eax, 8
	jne	SHORT $LN9@attach_met

; 795  :   { sprintf(errmsg,"%s: Sorry, but for now, a method instance can only belong to %d quantities.\n",
; 796  :        m->name, MMAXQUANTS);

	push	eax
	push	edi
	push	OFFSET ??_C@_0EN@PHOPGAJG@?$CFs?3?5Sorry?0?5but?5for?5now?0?5a?5method@
	push	OFFSET _errmsg
	call	_sprintf

; 797  :     kb_error(1564,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1564					; 0000061cH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN9@attach_met:

; 798  :   }
; 799  : 
; 800  :   gm = basic_gen_methods + m->gen_method;

	mov	ebx, DWORD PTR [edi+148]
	lea	ebx, DWORD PTR [ebx+ebx*4]
	shl	ebx, 5
	add	ebx, OFFSET _basic_gen_methods

; 801  :   if ( (gm->gradient==NULL) && (quant->flags & (Q_ENERGY|Q_FIXED|Q_CONSERVED)) )

	cmp	DWORD PTR [ebx+148], 0
	jne	SHORT $LN8@attach_met
	test	BYTE PTR [esi+136], 11			; 0000000bH
	je	SHORT $LN8@attach_met

; 802  :   { sprintf(errmsg,"Sorry; method %s does not have a gradient available.\n",gm->name);

	push	ebx
	push	OFFSET ??_C@_0DG@JNIJLDFI@Sorry?$DL?5method?5?$CFs?5does?5not?5have?5a@
	push	OFFSET _errmsg
	call	_sprintf

; 803  :     kb_error(1565,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1565					; 0000061dH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN8@attach_met:

; 804  :   }
; 805  :   for ( i = 0 ; i < quant->method_count ; i++ )

	xor	eax, eax
	cmp	DWORD PTR [esi+240], eax
	jle	SHORT $LN28@attach_met
	mov	ecx, DWORD PTR [esi+244]
	npad	5
$LL7@attach_met:

; 806  :     if ( quant->meth_inst[i] == inst_num ) 

	mov	edx, DWORD PTR _inst_num$[ebp]
	cmp	DWORD PTR [ecx], edx
	je	$LN26@attach_met

; 804  :   }
; 805  :   for ( i = 0 ; i < quant->method_count ; i++ )

	inc	eax
	add	ecx, 4
	cmp	eax, DWORD PTR [esi+240]
	jl	SHORT $LL7@attach_met
$LN28@attach_met:

; 807  :       goto attach_method_num_exit;
; 808  : 
; 809  : 
; 810  :   if ( quant->method_count >= quant->meth_inst_alloc )

	mov	eax, DWORD PTR [esi+248]
	cmp	DWORD PTR [esi+240], eax
	jl	SHORT $LN1@attach_met

; 811  :   { if ( quant->meth_inst_alloc == 0 )

	test	eax, eax
	jne	SHORT $LN2@attach_met

; 812  :     { quant->meth_inst_alloc = 4;
; 813  :       quant->meth_inst = (int*)mycalloc(quant->meth_inst_alloc,sizeof(int));

	push	813					; 0000032dH
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	4
	push	4
	mov	DWORD PTR [esi+248], 4
	call	_kb_calloc

; 814  :     }
; 815  :     else

	jmp	SHORT $LN30@attach_met
$LN2@attach_met:

; 816  :     { quant->meth_inst_alloc *= 2;

	add	eax, eax

; 817  :       quant->meth_inst = (int*)kb_realloc((char*)(quant->meth_inst),
; 818  :          (quant->meth_inst_alloc)*sizeof(int));

	push	818					; 00000332H
	lea	edx, DWORD PTR [eax*4]
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	mov	DWORD PTR [esi+248], eax
	mov	eax, DWORD PTR [esi+244]
	push	edx
	push	eax
	call	_KB_realloc
$LN30@attach_met:
	mov	DWORD PTR [esi+244], eax
	add	esp, 16					; 00000010H
$LN1@attach_met:

; 819  :     }
; 820  :   }
; 821  : 
; 822  :   quant->meth_inst[quant->method_count++] = inst_num; 

	mov	edx, DWORD PTR [esi+240]
	mov	eax, DWORD PTR [esi+244]
	mov	ecx, DWORD PTR _inst_num$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	inc	DWORD PTR [esi+240]

; 823  :   quant_flags[gm->type] |= quant->flags & (Q_ENERGY|Q_FIXED|Q_INFO|Q_CONSERVED);

	mov	edx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [ebx+128]
	and	edx, 15					; 0000000fH
	or	DWORD PTR _web[eax*4+5628], edx

; 824  :   quant->flags |= (basic_gen_methods[m->gen_method].flags & TORUS_MODULO_MUNGE);

	mov	edi, DWORD PTR [edi+148]
	lea	eax, DWORD PTR [edi+edi*4]
	shl	eax, 5
	mov	edx, DWORD PTR _basic_gen_methods[eax+132]
	and	edx, 262144				; 00040000H
	or	DWORD PTR [esi+136], edx
	pop	edi
	pop	esi

; 825  : 
; 826  : attach_method_num_exit:
; 827  :   return inst_num;

	mov	eax, ecx
	pop	ebx

; 828  : } // end attach_method_num()

	pop	ebp
	ret	0
$LN26@attach_met:
	pop	edi
	pop	esi

; 825  : 
; 826  : attach_method_num_exit:
; 827  :   return inst_num;

	mov	eax, edx
$attach_method_num_exit$89385:
	pop	ebx

; 828  : } // end attach_method_num()

	pop	ebp
	ret	0
_attach_method_num ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DM@MPLJOCDH@Cannot?5apply?5signed?5method?1quant@ ; `string'
PUBLIC	??_C@_0CN@IMOHAFLA@Internal?5error?3?5Undefined?5method@ ; `string'
PUBLIC	_apply_method_num
EXTRN	_expand_attribute:PROC
;	COMDAT ??_C@_0DM@MPLJOCDH@Cannot?5apply?5signed?5method?1quant@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DM@MPLJOCDH@Cannot?5apply?5signed?5method?1quant@ DB 'Cannot apply'
	DB	' signed method/quantity to individual element.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IMOHAFLA@Internal?5error?3?5Undefined?5method@
CONST	SEGMENT
??_C@_0CN@IMOHAFLA@Internal?5error?3?5Undefined?5method@ DB 'Internal err'
	DB	'or: Undefined method instance. ', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\quantity.c
CONST	ENDS
;	COMDAT _apply_method_num
_TEXT	SEGMENT
tv367 = -20						; size = 4
tv365 = -16						; size = 4
tv360 = -12						; size = 4
_newc$89445 = -12					; size = 4
tv377 = -8						; size = 4
_meth_offset$89428 = -4					; size = 4
_id$ = 8						; size = 4
_inst_num$ = 12						; size = 4
_apply_method_num PROC					; COMDAT

; 884  : { 

	push	ebp
	mov	ebp, esp

; 885  :   struct method_instance *m;
; 886  :   struct element *e_ptr;
; 887  :   int type; /* of element */
; 888  :   struct gen_quant_method *gm;
; 889  :   int i;
; 890  : 
; 891  :   /* search for method */
; 892  :   if ( inst_num < -meth_inst_count )

	mov	eax, DWORD PTR _web+5560
	sub	esp, 20					; 00000014H
	mov	ecx, eax
	push	ebx
	mov	ebx, DWORD PTR _inst_num$[ebp]
	neg	ecx
	cmp	ebx, ecx
	jge	SHORT $LN21@apply_meth

; 893  :      { kb_error(2178,"Internal error: Undefined method instance. \n",DATAFILE_ERROR); return; }

	push	6
	push	OFFSET ??_C@_0CN@IMOHAFLA@Internal?5error?3?5Undefined?5method@
	push	2178					; 00000882H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	ebx

; 954  :     }
; 955  :   }  
; 956  : } // end apply_method_num()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@apply_meth:

; 894  :   if ( inst_num > meth_inst_count )

	cmp	ebx, eax
	jle	SHORT $LN20@apply_meth

; 895  :      { kb_error(2179,"Internal error: Undefined method instance. \n",DATAFILE_ERROR); return; }

	push	6
	push	OFFSET ??_C@_0CN@IMOHAFLA@Internal?5error?3?5Undefined?5method@
	push	2179					; 00000883H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	ebx

; 954  :     }
; 955  :   }  
; 956  : } // end apply_method_num()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@apply_meth:

; 896  :   m = METH_INSTANCE(abs(inst_num));

	mov	eax, ebx
	cdq
	xor	eax, edx
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 897  : 
; 898  :   if ( m->flags & GLOBAL_INST )

	mov	edx, DWORD PTR [eax+140]
	test	edx, 1073741824				; 40000000H
	je	SHORT $LN19@apply_meth

; 899  :   { /* trying to apply global method to single element */
; 900  :     if ( inverted(id) )

	test	DWORD PTR _id$[ebp], 134217728		; 08000000H
	je	$LN4@apply_meth

; 901  :     
; 902  :     { kb_error(4571,"Cannot apply signed method/quantity to individual element.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DM@MPLJOCDH@Cannot?5apply?5signed?5method?1quant@
	push	4571					; 000011dbH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	ebx

; 954  :     }
; 955  :   }  
; 956  : } // end apply_method_num()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@apply_meth:

; 903  :     }
; 904  :     return;
; 905  :   }
; 906  :   gm = basic_gen_methods + m->gen_method;

	mov	ecx, DWORD PTR [eax+148]
	push	esi
	lea	esi, DWORD PTR [ecx+ecx*4]

; 907  :   if ( valid_id(id) ) /* individual element */

	mov	ecx, DWORD PTR _id$[ebp]
	shl	esi, 5
	add	esi, OFFSET _basic_gen_methods
	push	edi
	test	ecx, 268435456				; 10000000H
	je	$LN17@apply_meth

; 908  :   { int *instlist,maxinst;
; 909  :     int meth_offset; 
; 910  : 
; 911  :     if ( inverted(id) && (gm->flags & ORIENTABLE_METHOD) )

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN16@apply_meth
	test	DWORD PTR [esi+132], 65536		; 00010000H
	je	SHORT $LN16@apply_meth

; 912  :        inst_num = -inst_num;

	neg	ebx
	mov	DWORD PTR _inst_num$[ebp], ebx
$LN16@apply_meth:

; 913  :     type = id_type(id);

	mov	edx, ecx
	shr	edx, 29					; 0000001dH

; 914  :     meth_offset = get_meth_offset(type); 

	mov	eax, DWORD PTR _web[edx*4+5664]
	imul	eax, 240				; 000000f0H
	mov	esi, edx
	imul	esi, 112				; 00000070H
	mov	esi, DWORD PTR _web[esi+104]
	add	esi, eax
	mov	eax, DWORD PTR _dymem
	mov	edi, DWORD PTR [eax+esi+64]
	add	eax, esi
	mov	DWORD PTR tv360[ebp], eax

; 915  :     e_ptr = elptr(id);

	mov	eax, edx
	imul	eax, 112				; 00000070H
	and	ecx, 134217727				; 07ffffffH
	lea	eax, DWORD PTR _web[eax+12]
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR tv365[ebp], eax
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+eax]

; 916  :     /* see if already there */
; 917  :     instlist = (int*)((char*)e_ptr + meth_offset); 
; 918  :     for ( i = 0 ; i < (int)e_ptr->method_count ; i++ )

	movzx	ebx, WORD PTR [eax+24]
	xor	esi, esi
	mov	DWORD PTR tv367[ebp], ecx
	mov	DWORD PTR _meth_offset$89428[ebp], edi
	lea	ecx, DWORD PTR [eax+edi]
	mov	DWORD PTR tv377[ebp], ebx
	test	ebx, ebx
	jle	SHORT $LN34@apply_meth
$LL33@apply_meth:
	mov	ebx, DWORD PTR _inst_num$[ebp]

; 919  :     {  if ( instlist[i] == inst_num ) return;

	mov	edi, DWORD PTR [ecx+esi*4]
	cmp	edi, ebx
	je	$LN37@apply_meth

; 920  :        if ( instlist[i] == -inst_num )

	neg	ebx
	cmp	edi, ebx
	je	SHORT $LN29@apply_meth

; 916  :     /* see if already there */
; 917  :     instlist = (int*)((char*)e_ptr + meth_offset); 
; 918  :     for ( i = 0 ; i < (int)e_ptr->method_count ; i++ )

	movzx	edi, WORD PTR [eax+24]
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL33@apply_meth

; 942  :       if ( global_meth_inst[type][i] == inst_num )

	mov	edi, DWORD PTR _meth_offset$89428[ebp]
	mov	ebx, DWORD PTR tv377[ebp]
$LN34@apply_meth:

; 923  :          return;
; 924  :        }
; 925  :     } 
; 926  :     /* add */ 
; 927  :     maxinst = EXTRAS(type)[web.meth_attr[type]].array_spec.datacount;

	mov	esi, DWORD PTR tv360[ebp]
	mov	esi, DWORD PTR [esi+88]

; 928  :     if ( (int)e_ptr->method_count >= maxinst )

	cmp	ebx, esi
	jl	SHORT $LN10@apply_meth

; 929  :     { int newc = maxinst+4;
; 930  :       expand_attribute(type,web.meth_attr[type],&newc);

	mov	eax, DWORD PTR _web[edx*4+5664]
	lea	ecx, DWORD PTR _newc$89445[ebp]
	push	ecx
	push	eax
	add	esi, 4
	push	edx
	mov	DWORD PTR _newc$89445[ebp], esi
	call	_expand_attribute

; 931  :       e_ptr = elptr(id);  /* since things moved */

	mov	edx, DWORD PTR tv365[ebp]
	mov	ecx, DWORD PTR tv367[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx+eax]
	add	esp, 12					; 0000000cH

; 932  :       instlist = (int*)((char*)e_ptr + meth_offset); 

	lea	ecx, DWORD PTR [eax+edi]
$LN10@apply_meth:

; 933  :     }
; 934  :     instlist[e_ptr->method_count] = inst_num;

	movzx	edx, WORD PTR [eax+24]
	mov	esi, DWORD PTR _inst_num$[ebp]
	pop	edi
	mov	DWORD PTR [ecx+edx*4], esi

; 935  :     e_ptr->method_count++;

	inc	WORD PTR [eax+24]
	pop	esi
	pop	ebx

; 954  :     }
; 955  :   }  
; 956  : } // end apply_method_num()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@apply_meth:

; 921  :        { /* cancels out */
; 922  :          instlist[i] = instlist[--e_ptr->method_count];

	movzx	edx, WORD PTR [eax+24]
	dec	edx
	mov	WORD PTR [eax+24], dx
	movzx	edx, dx
	mov	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	mov	DWORD PTR [ecx+esi*4], eax
	pop	esi
	pop	ebx

; 954  :     }
; 955  :   }  
; 956  : } // end apply_method_num()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@apply_meth:

; 936  :   }
; 937  :   else /* global */
; 938  :   { m->flags |= GLOBAL_INST;

	or	edx, 1073741824				; 40000000H
	mov	DWORD PTR [eax+140], edx

; 939  :     type = gm->type;

	mov	edi, DWORD PTR [esi+128]

; 940  :     /* see if already there */
; 941  :     for ( i = 0 ; i < global_meth_inst_count[type] ; i++ )

	mov	ecx, DWORD PTR _web[edi*4+5588]
	lea	esi, DWORD PTR _web[edi*4+5588]
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN35@apply_meth

; 936  :   }
; 937  :   else /* global */
; 938  :   { m->flags |= GLOBAL_INST;

	mov	edx, DWORD PTR _web[edi*4+5568]
$LL8@apply_meth:

; 942  :       if ( global_meth_inst[type][i] == inst_num )

	cmp	DWORD PTR [edx], ebx
	je	SHORT $LN35@apply_meth

; 940  :     /* see if already there */
; 941  :     for ( i = 0 ; i < global_meth_inst_count[type] ; i++ )

	inc	eax
	add	edx, 4
	cmp	eax, ecx
	jl	SHORT $LL8@apply_meth
$LN35@apply_meth:

; 943  :          break;
; 944  :     if ( i >= global_meth_inst_count[type] )

	cmp	eax, ecx
	jl	SHORT $LN37@apply_meth

; 945  :     { /* add it */
; 946  :       if ( global_meth_inst_count[type] >= global_meth_inst_alloc[type] )

	mov	eax, DWORD PTR _web[edi*4+5608]
	cmp	ecx, eax
	jl	SHORT $LN3@apply_meth

; 947  :       { if ( global_meth_inst_alloc[type] == 0 )

	test	eax, eax
	jne	SHORT $LN2@apply_meth

; 948  :            global_meth_inst_alloc[type] = 100;

	mov	DWORD PTR _web[edi*4+5608], 100		; 00000064H
	jmp	SHORT $LN1@apply_meth
$LN2@apply_meth:

; 949  :         else global_meth_inst_alloc[type] *= 2;

	add	eax, eax
	mov	DWORD PTR _web[edi*4+5608], eax
$LN1@apply_meth:

; 950  :         global_meth_inst[type] = (int*)kb_realloc((char*)global_meth_inst[type],
; 951  :           global_meth_inst_alloc[type]*sizeof(int));

	mov	ecx, DWORD PTR _web[edi*4+5608]
	mov	edx, DWORD PTR _web[edi*4+5568]
	push	951					; 000003b7H
	add	ecx, ecx
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	add	ecx, ecx
	push	ecx
	push	edx
	call	_KB_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _web[edi*4+5568], eax
$LN3@apply_meth:

; 952  :       }
; 953  :       global_meth_inst[type][global_meth_inst_count[type]++] = inst_num;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _web[edi*4+5568]
	mov	DWORD PTR [ecx+eax*4], ebx
	inc	DWORD PTR [esi]
$LN37@apply_meth:
	pop	edi
	pop	esi
$LN4@apply_meth:
	pop	ebx

; 954  :     }
; 955  :   }  
; 956  : } // end apply_method_num()

	mov	esp, ebp
	pop	ebp
	ret	0
_apply_method_num ENDP
_TEXT	ENDS
PUBLIC	_unapply_method
; Function compile flags: /Ogtp
;	COMDAT _unapply_method
_TEXT	SEGMENT
_id$ = 8						; size = 4
_inst_num$ = 12						; size = 4
_unapply_method PROC					; COMDAT

; 971  : { struct element *e_ptr;

	push	ebp
	mov	ebp, esp

; 972  :   int i;
; 973  :   int type = id_type(id);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	shr	eax, 29					; 0000001dH

; 974  :   int meth_offset = EXTRAS(type)[web.meth_attr[type]].offset;
; 975  :   int *methlist = (int*)((char*)elptr(id) + meth_offset);

	mov	edx, eax
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	push	esi
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	push	edi
	mov	edi, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _web[eax*4+5664]
	imul	eax, 112				; 00000070H
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax+64]
	add	esi, edi

; 976  : 
; 977  :   if ( valid_id(id) ) /* individual element */

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN2@unapply_me

; 978  :   { e_ptr = elptr(id);
; 979  :     /* see if already there */
; 980  :     for ( i = 0 ; i < (int)e_ptr->method_count ; i++ )

	movzx	eax, WORD PTR [edi+24]
	xor	edx, edx
	xor	ecx, ecx
	cmp	dx, ax
	jae	SHORT $LN2@unapply_me

; 981  :       if ( abs(methlist[i]) == abs(inst_num) ) 

	mov	eax, DWORD PTR _inst_num$[ebp]
	cdq
	push	ebx
	mov	ebx, eax
	xor	ebx, edx
	sub	ebx, edx
$LL4@unapply_me:
	mov	eax, DWORD PTR [esi+ecx*4]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, ebx
	movzx	eax, WORD PTR [edi+24]
	je	SHORT $LN9@unapply_me

; 978  :   { e_ptr = elptr(id);
; 979  :     /* see if already there */
; 980  :     for ( i = 0 ; i < (int)e_ptr->method_count ; i++ )

	inc	ecx
	cmp	ecx, eax
	jl	SHORT $LL4@unapply_me
	pop	ebx
	pop	edi
	pop	esi

; 984  :         break;
; 985  :       }
; 986  :   }
; 987  : } // end unapply_method()

	pop	ebp
	ret	0
$LN9@unapply_me:

; 982  :       { /* delete */
; 983  :         methlist[i] = methlist[--e_ptr->method_count];

	dec	eax
	movzx	edx, ax
	mov	WORD PTR [edi+24], ax
	mov	eax, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [esi+ecx*4], eax
	pop	ebx
$LN2@unapply_me:
	pop	edi
	pop	esi

; 984  :         break;
; 985  :       }
; 986  :   }
; 987  : } // end unapply_method()

	pop	ebp
	ret	0
_unapply_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@HMMLLGIO@Quantity?5?8?$CFs?8?5has?5no?5methods?5app@ ; `string'
PUBLIC	??_C@_0FA@CMJMIEDD@Compound?5quantity?5should?5have?5in@ ; `string'
PUBLIC	_apply_quantity
;	COMDAT ??_C@_0DN@HMMLLGIO@Quantity?5?8?$CFs?8?5has?5no?5methods?5app@
CONST	SEGMENT
??_C@_0DN@HMMLLGIO@Quantity?5?8?$CFs?8?5has?5no?5methods?5app@ DB 'Quanti'
	DB	'ty ''%s'' has no methods applying to this type element.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@CMJMIEDD@Compound?5quantity?5should?5have?5in@
CONST	SEGMENT
??_C@_0FA@CMJMIEDD@Compound?5quantity?5should?5have?5in@ DB 'Compound qua'
	DB	'ntity should have individual method instances applied to elem'
	DB	'ents.', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _apply_quantity
_TEXT	SEGMENT
_id$ = 8						; size = 4
_count$ = 12						; size = 4
_quantnum$ = 12						; size = 4
_apply_quantity PROC					; COMDAT

; 1000 : { struct gen_quant *g = GEN_QUANT(quantnum);

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _quantnum$[ebp]
	imul	esi, 368				; 00000170H
	add	esi, DWORD PTR _gen_quant_list
	push	edi

; 1001 :   int i;
; 1002 :   int count = 0;

	xor	edi, edi

; 1003 :   if ( g->flags & Q_COMPOUND )

	test	DWORD PTR [esi+136], 256		; 00000100H
	mov	DWORD PTR _count$[ebp], edi
	je	SHORT $LN6@apply_quan

; 1004 :      kb_error(2180,"Compound quantity should have individual method instances applied to elements.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0FA@CMJMIEDD@Compound?5quantity?5should?5have?5in@
	push	2180					; 00000884H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN6@apply_quan:

; 1005 :   for ( i = 0 ; i < g->method_count ; i++ )

	cmp	DWORD PTR [esi+240], edi
	jle	SHORT $LN11@apply_quan
	push	ebx
	mov	ebx, DWORD PTR _id$[ebp]
	shr	ebx, 29					; 0000001dH
	npad	8
$LL5@apply_quan:

; 1006 :   { struct method_instance *mi = METH_INSTANCE(g->meth_inst[i]);

	mov	eax, DWORD PTR [esi+244]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 1007 :     struct gen_quant_method *gm = basic_gen_methods + mi->gen_method;

	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	mov	eax, DWORD PTR [eax+edx+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5

; 1008 :     if ( gm->type == id_type(id) )

	cmp	DWORD PTR _basic_gen_methods[eax+128], ebx
	jne	SHORT $LN4@apply_quan

; 1009 :     { apply_method_num(id,g->meth_inst[i]);

	push	ecx
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	call	_apply_method_num
	add	esp, 8

; 1010 :       count++;

	inc	DWORD PTR _count$[ebp]
$LN4@apply_quan:

; 1005 :   for ( i = 0 ; i < g->method_count ; i++ )

	inc	edi
	cmp	edi, DWORD PTR [esi+240]
	jl	SHORT $LL5@apply_quan

; 1011 :     }
; 1012 :   }
; 1013 :   if ( count == 0 )

	cmp	DWORD PTR _count$[ebp], 0
	pop	ebx
	jne	SHORT $LN1@apply_quan
$LN11@apply_quan:

; 1014 :   { sprintf(errmsg,"Quantity '%s' has no methods applying to this type element.\n",
; 1015 :          g->name);

	push	esi
	push	OFFSET ??_C@_0DN@HMMLLGIO@Quantity?5?8?$CFs?8?5has?5no?5methods?5app@
	push	OFFSET _errmsg
	call	_sprintf

; 1016 :      kb_error(1569,errmsg, WARNING);

	push	2
	push	OFFSET _errmsg
	push	1569					; 00000621H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN1@apply_quan:
	pop	edi
	pop	esi

; 1017 :   }
; 1018 : } // end apply_quantity()

	pop	ebp
	ret	0
_apply_quantity ENDP
_TEXT	ENDS
PUBLIC	_unapply_quantity
; Function compile flags: /Ogtp
;	COMDAT _unapply_quantity
_TEXT	SEGMENT
_id$ = 8						; size = 4
_quantnum$ = 12						; size = 4
_unapply_quantity PROC					; COMDAT

; 1032 : { struct gen_quant *g = GEN_QUANT(quantnum);

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _quantnum$[ebp]
	imul	esi, 368				; 00000170H
	add	esi, DWORD PTR _gen_quant_list
	push	edi

; 1033 :   int i;
; 1034 :   for ( i = 0 ; i < g->method_count ; i++ )

	xor	edi, edi
	cmp	DWORD PTR [esi+240], edi
	jle	SHORT $LN2@unapply_qu
	push	ebx
	mov	ebx, DWORD PTR _id$[ebp]
	shr	ebx, 29					; 0000001dH
$LL4@unapply_qu:

; 1035 :     { struct method_instance *mi = METH_INSTANCE(g->meth_inst[i]);

	mov	eax, DWORD PTR [esi+244]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 1036 :       struct gen_quant_method *gm = basic_gen_methods + mi->gen_method;

	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	mov	eax, DWORD PTR [eax+edx+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5

; 1037 :       if ( gm->type == id_type(id) )

	cmp	DWORD PTR _basic_gen_methods[eax+128], ebx
	jne	SHORT $LN3@unapply_qu

; 1038 :          { unapply_method(id,g->meth_inst[i]);

	push	ecx
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	call	_unapply_method
	add	esp, 8
$LN3@unapply_qu:

; 1033 :   int i;
; 1034 :   for ( i = 0 ; i < g->method_count ; i++ )

	inc	edi
	cmp	edi, DWORD PTR [esi+240]
	jl	SHORT $LL4@unapply_qu
	pop	ebx
$LN2@unapply_qu:
	pop	edi
	pop	esi

; 1039 :          }
; 1040 :     }
; 1041 : } // end unapply_quantity()

	pop	ebp
	ret	0
_unapply_quantity ENDP
_TEXT	ENDS
PUBLIC	_q_info_free
EXTRN	_free_matrix4:PROC
EXTRN	_myfree:PROC
EXTRN	_free_matrix3:PROC
EXTRN	_free_matrix:PROC
; Function compile flags: /Ogtp
;	COMDAT _q_info_free
_TEXT	SEGMENT
_q_info$ = 8						; size = 4
_q_info_free PROC					; COMDAT

; 1125 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 1126 :   free_matrix(q_info->xx);

	mov	esi, DWORD PTR _q_info$[ebp]
	mov	eax, DWORD PTR [esi+1216]
	push	eax
	call	_free_matrix

; 1127 :   free_matrix3(q_info->sides);

	mov	ecx, DWORD PTR [esi+1276]
	push	ecx
	call	_free_matrix3

; 1128 :   free_matrix(q_info->ss);

	mov	edx, DWORD PTR [esi+1280]
	push	edx
	call	_free_matrix

; 1129 :   free_matrix(q_info->grad);

	mov	eax, DWORD PTR [esi+1336]
	push	eax
	call	_free_matrix

; 1130 :   free_matrix(q_info->gauss_pt);

	mov	ecx, DWORD PTR [esi+1268]
	push	ecx
	call	_free_matrix

; 1131 :   if ( q_info->uu[0] ) 

	mov	eax, DWORD PTR [esi+1224]
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN3@q_info_fre

; 1132 :   { myfree((char*)q_info->uu[0]);

	push	eax
	call	_myfree

; 1133 :     myfree((char*)q_info->uugrad[0]);

	mov	edx, DWORD PTR [esi+1240]
	push	edx
	call	_myfree
	add	esp, 8
$LN3@q_info_fre:

; 1134 :   }
; 1135 :   if ( q_info->uuhess[0] )

	mov	eax, DWORD PTR [esi+1256]
	test	eax, eax
	je	SHORT $LN2@q_info_fre

; 1136 :   { myfree((char*)q_info->uuhess[0][0]);

	mov	eax, DWORD PTR [eax]
	push	eax
	call	_myfree

; 1137 :     myfree((char*)q_info->uuhess[0]);

	mov	ecx, DWORD PTR [esi+1256]
	push	ecx
	call	_myfree
	add	esp, 8
$LN2@q_info_fre:

; 1138 :   }
; 1139 :   if ( q_info->u )

	mov	eax, DWORD PTR [esi+1220]
	test	eax, eax
	je	SHORT $LN1@q_info_fre

; 1140 :   { free_matrix(q_info->u);

	push	eax
	call	_free_matrix

; 1141 :     free_matrix(q_info->ugrad);

	mov	edx, DWORD PTR [esi+1236]
	push	edx
	call	_free_matrix

; 1142 :     free_matrix4(q_info->uhess);

	mov	eax, DWORD PTR [esi+1252]
	push	eax
	call	_free_matrix4
	add	esp, 12					; 0000000cH
$LN1@q_info_fre:

; 1143 :   }
; 1144 :   memset(q_info,0,sizeof(struct qinfo));

	push	1752					; 000006d8H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	pop	esi

; 1145 : } // end q_info_free()

	pop	ebp
	ret	0
_q_info_free ENDP
_TEXT	ENDS
PUBLIC	_free_all_q_info
EXTRN	_glutgraph_thread_data:BYTE
EXTRN	_thread_data_ptrs:DWORD
EXTRN	_nprocs:DWORD
EXTRN	_threadflag:DWORD
EXTRN	_default_thread_data:BYTE
; Function compile flags: /Ogtp
;	COMDAT _free_all_q_info
_TEXT	SEGMENT
_free_all_q_info PROC					; COMDAT

; 1188 : 
; 1189 :   // Main thread
; 1190 :   q_info = &(default_thread_data.q_info);
; 1191 :   memset(q_info,0,sizeof(struct qinfo));

	push	1752					; 000006d8H
	push	0
	push	OFFSET _default_thread_data+56
	call	_memset
	add	esp, 12					; 0000000cH

; 1192 :   
; 1193 :   // Worker threads
; 1194 :   if ( threadflag )

	cmp	DWORD PTR _threadflag, 0
	je	SHORT $LN1@free_all_q

; 1195 :   { int i;
; 1196 :     for ( i = 0 ; i < nprocs ; i++ )

	push	esi
	xor	esi, esi
	cmp	DWORD PTR _nprocs, esi
	jle	SHORT $LN9@free_all_q
	npad	8
$LL3@free_all_q:

; 1197 :     { q_info = &(thread_data_ptrs[i]->q_info);

	mov	eax, DWORD PTR _thread_data_ptrs
	mov	ecx, DWORD PTR [eax+esi*4]

; 1198 :       memset(q_info,0,sizeof(struct qinfo));

	push	1752					; 000006d8H
	add	ecx, 56					; 00000038H
	push	0
	push	ecx
	call	_memset
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR _nprocs
	jl	SHORT $LL3@free_all_q
$LN9@free_all_q:
	pop	esi
$LN1@free_all_q:

; 1199 :     }
; 1200 :   }
; 1201 :   
; 1202 :   // Graphics thread
; 1203 :   q_info = &(glutgraph_thread_data.q_info);
; 1204 :   memset(q_info,0,sizeof(struct qinfo));

	push	1752					; 000006d8H
	push	0
	push	OFFSET _glutgraph_thread_data+56
	call	_memset
	add	esp, 12					; 0000000cH

; 1205 : 
; 1206 : } // end setup_q_info()

	ret	0
_free_all_q_info ENDP
_TEXT	ENDS
PUBLIC	_global_meth_needs
; Function compile flags: /Ogtp
;	COMDAT _global_meth_needs
_TEXT	SEGMENT
_type$ = 8						; size = 4
_global_meth_needs PROC					; COMDAT

; 1216 : { int k;

	push	ebp
	mov	ebp, esp

; 1217 :   int needs = 0;

	mov	ecx, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR _web[ecx*4+5588]
	push	esi
	xor	esi, esi

; 1218 :  
; 1219 :   for ( k = 0 ; k < global_meth_inst_count[type]; k++ )

	test	eax, eax
	jle	SHORT $LN9@global_met

; 1217 :   int needs = 0;

	mov	ecx, DWORD PTR _web[ecx*4+5568]
	push	ebx
	push	edi
	mov	edi, DWORD PTR _meth_inst_list
	mov	ebx, eax
$LL4@global_met:

; 1220 :   { int mi = global_meth_inst[type][k];
; 1221 :     if ( (METH_INSTANCE(mi)->flags & Q_DOTHIS) 
; 1222 :                   && (METH_INSTANCE(mi)->type == type) )

	mov	eax, DWORD PTR [ecx]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	test	BYTE PTR [eax+edi+140], 16		; 00000010H
	je	SHORT $LN3@global_met
	mov	edx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+edi+136], edx
	jne	SHORT $LN3@global_met

; 1223 :        needs |= basic_gen_methods[METH_INSTANCE(mi)->gen_method].flags;

	mov	eax, DWORD PTR [eax+edi+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	or	esi, DWORD PTR _basic_gen_methods[eax+132]
$LN3@global_met:

; 1218 :  
; 1219 :   for ( k = 0 ; k < global_meth_inst_count[type]; k++ )

	add	ecx, 4
	dec	ebx
	jne	SHORT $LL4@global_met
	pop	edi
	pop	ebx
$LN9@global_met:

; 1224 :   }
; 1225 :   return needs;

	mov	eax, esi
	pop	esi

; 1226 : } // end global_meth_needs()

	pop	ebp
	ret	0
_global_meth_needs ENDP
_TEXT	ENDS
PUBLIC	_vertex_comp
; Function compile flags: /Ogtp
;	COMDAT _vertex_comp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_vertex_comp PROC					; COMDAT

; 1274 : { REAL xa = get_coord(*a)[SDIM-1];

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	edx, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _web+616
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR _web+12
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+esi*4]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	esi, ecx
	fld	QWORD PTR [esi+eax-8]

; 1275 :   REAL xb = get_coord(*b)[SDIM-1];

	mov	esi, DWORD PTR _b$[ebp]
	mov	esi, DWORD PTR [esi]
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+esi*4]
	add	edx, ecx
	fld	QWORD PTR [edx+eax-8]
	pop	esi

; 1276 :   if ( xa < xb ) return -1;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@vertex_com
	fstp	ST(1)
	or	eax, -1
	fstp	ST(0)

; 1279 : } // end vertex_comp()

	pop	ebp
	ret	0
$LN2@vertex_com:

; 1277 :   if ( xa > xb ) return 1;

	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@vertex_com
	mov	eax, 1

; 1279 : } // end vertex_comp()

	pop	ebp
	ret	0
$LN1@vertex_com:

; 1278 :   return 0;

	xor	eax, eax

; 1279 : } // end vertex_comp()

	pop	ebp
	ret	0
_vertex_comp ENDP
_TEXT	ENDS
PUBLIC	_edge_comp
; Function compile flags: /Ogtp
;	COMDAT _edge_comp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_edge_comp PROC						; COMDAT

; 1285 : { REAL xa = get_coord(get_edge_tailv(*a))[SDIM-1];

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _web+124
	push	edi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN6@edge_comp
	mov	edi, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	lea	eax, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN5@edge_comp
$LN6@edge_comp:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN5@edge_comp:
	mov	edi, DWORD PTR _web+104
	mov	edx, DWORD PTR [edi+edx+64]
	mov	edi, DWORD PTR _web+616
	mov	ebx, DWORD PTR _web+12
	add	edi, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	add	edi, edi
	add	edi, edi
	add	eax, edi
	fld	QWORD PTR [eax+edx-8]

; 1286 :   REAL xb = get_coord(get_edge_tailv(*b))[SDIM-1];

	mov	eax, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [eax]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN10@edge_comp
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+esi*4]
	mov	ecx, DWORD PTR [eax+ecx]
	jmp	SHORT $LN9@edge_comp
$LN10@edge_comp:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	ecx, DWORD PTR [ecx+eax]
$LN9@edge_comp:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	add	ecx, edi
	fld	QWORD PTR [ecx+edx-8]
	pop	edi

; 1287 :   if ( xa < xb ) return -1;

	fcom	ST(1)
	pop	esi
	pop	ebx
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@edge_comp
	fstp	ST(0)
	or	eax, -1
	fstp	ST(0)

; 1290 : } // end edge_comp()

	pop	ebp
	ret	0
$LN2@edge_comp:

; 1288 :   if ( xa > xb ) return 1;

	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@edge_comp
	mov	eax, 1

; 1290 : } // end edge_comp()

	pop	ebp
	ret	0
$LN1@edge_comp:

; 1289 :   return 0;

	xor	eax, eax

; 1290 : } // end edge_comp()

	pop	ebp
	ret	0
_edge_comp ENDP
_TEXT	ENDS
PUBLIC	_facet_comp
; Function compile flags: /Ogtp
;	COMDAT _facet_comp
_TEXT	SEGMENT
_xa$ = -8						; size = 8
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_facet_comp PROC					; COMDAT

; 1296 : { REAL xa,xb;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1297 :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	push	ebx
	push	esi
	push	edi
	jne	SHORT $LN4@facet_comp

; 1298 :   { xa = get_coord(get_facet_vertices(*a)[0])[SDIM-1];

	mov	esi, DWORD PTR _a$[ebp]
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+328
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [edx+ecx+64]
	mov	esi, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+616
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [esi+edi*4]
	mov	ebx, DWORD PTR [eax+edi]
	mov	edi, DWORD PTR _web+12
	and	ebx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edi+ebx*4]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	add	ebx, edx
	fld	QWORD PTR [ebx+ecx-8]

; 1299 :     xb = get_coord(get_facet_vertices(*b)[0])[SDIM-1];

	mov	ebx, DWORD PTR _b$[ebp]
	mov	ebx, DWORD PTR [ebx]
	and	ebx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+ebx*4]
	mov	eax, DWORD PTR [eax+esi]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	add	eax, edx
	fld	QWORD PTR [eax+ecx-8]

; 1300 :   }
; 1301 :   else

	jmp	$LN3@facet_comp
$LN4@facet_comp:

; 1302 :   { xa = get_coord(get_fe_tailv(get_facet_fe(*a)))[SDIM-1];

	mov	ecx, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN8@facet_comp
	xor	eax, eax
	jmp	SHORT $LN7@facet_comp
$LN8@facet_comp:
	mov	eax, DWORD PTR _web+236
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edx+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN7@facet_comp
	xor	eax, 134217728				; 08000000H
$LN7@facet_comp:
	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR [ecx+edx+64]
	mov	ebx, DWORD PTR _web+460
	mov	edi, DWORD PTR _web+616
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	eax
	call	_get_edge_tailv
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]

; 1303 :     xb = get_coord(get_fe_tailv(get_facet_fe(*b)))[SDIM-1];

	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	edx, esi
	fld	QWORD PTR [edx+edi*8-8]
	add	esp, 4
	fstp	QWORD PTR _xa$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN14@facet_comp
	xor	eax, eax
	jmp	SHORT $LN13@facet_comp
$LN14@facet_comp:
	mov	eax, DWORD PTR _web+236
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edx+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN13@facet_comp
	xor	eax, 134217728				; 08000000H
$LN13@facet_comp:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	eax
	call	_get_edge_tailv
	fld	QWORD PTR _xa$[ebp]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	add	esp, 4
	add	edx, esi
	fld	QWORD PTR [edx+edi*8-8]
$LN3@facet_comp:

; 1304 :   }
; 1305 :   if ( xa < xb ) return -1;

	fcom	ST(1)
	pop	edi
	pop	esi
	pop	ebx
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@facet_comp
	fstp	ST(0)
	or	eax, -1
	fstp	ST(0)

; 1308 : } // end facet_comp()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@facet_comp:

; 1306 :   if ( xa > xb ) return 1;

	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@facet_comp
	mov	eax, 1

; 1308 : } // end facet_comp()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@facet_comp:

; 1307 :   return 0;

	xor	eax, eax

; 1308 : } // end facet_comp()

	mov	esp, ebp
	pop	ebp
	ret	0
_facet_comp ENDP
_TEXT	ENDS
PUBLIC	_make_el_list
EXTRN	_top_timestamp:DWORD
EXTRN	_qsort:PROC
EXTRN	_el_list:BYTE
; Function compile flags: /Ogtp
;	COMDAT _make_el_list
_TEXT	SEGMENT
_bin$ = -4						; size = 4
_type$ = 8						; size = 4
_make_el_list PROC					; COMDAT

; 1311 : { element_id id,*tlist; 

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi

; 1312 :   int pnum,i,bin,end,start;
; 1313 :   if ( el_list[type] ) myfree((char*)el_list[type]);

	mov	edi, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR _el_list[edi*4]
	test	eax, eax
	je	SHORT $LN19@make_el_li
	push	eax
	call	_myfree
	add	esp, 4
$LN19@make_el_li:

; 1314 :   tlist = el_list[type] = (element_id*)mycalloc(web.skel[type].count,
; 1315 :                                                      sizeof(element_id));

	mov	esi, edi
	imul	esi, 112				; 00000070H
	mov	eax, DWORD PTR _web[esi+64]
	push	1315					; 00000523H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	4
	push	eax
	call	_kb_calloc

; 1316 :   FOR_ALL_ELEMENTS(type,id)

	mov	edx, DWORD PTR _web[esi+48]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _el_list[edi*4], eax
	mov	ebx, eax
	test	edx, 268435456				; 10000000H
	je	SHORT $LN33@make_el_li
$LL18@make_el_li:
	mov	ecx, edx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	lea	esi, DWORD PTR _web[ecx+12]
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN17@make_el_li

; 1317 :      *(tlist++) = id;

	mov	DWORD PTR [ebx], edx
	add	ebx, 4
$LN17@make_el_li:

; 1316 :   FOR_ALL_ELEMENTS(type,id)

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL18@make_el_li
	mov	edi, DWORD PTR _type$[ebp]
$LN33@make_el_li:

; 1318 : 
; 1319 :   switch(type)

	mov	eax, edi
	sub	eax, 0
	je	SHORT $LN11@make_el_li
	dec	eax
	je	SHORT $LN2@make_el_li
	dec	eax
	jne	$LN30@make_el_li

; 1340 :        break;
; 1341 : 
; 1342 :     case FACET: 
; 1343 :        qsort((char*)(el_list[type]),web.skel[type].count,
; 1344 :        sizeof(element_id), FCAST facet_comp); 

	mov	ecx, DWORD PTR _web+288
	mov	edx, DWORD PTR _el_list+8
	push	OFFSET _facet_comp

; 1345 :        break;

	jmp	SHORT $LN35@make_el_li
$LN2@make_el_li:

; 1334 :        }
; 1335 :        break;
; 1336 : 
; 1337 :     case EDGE: 
; 1338 :        qsort((char*)(el_list[type]),web.skel[type].count,
; 1339 :        sizeof(element_id), FCAST edge_comp); 

	mov	ecx, DWORD PTR _web+176
	mov	edx, DWORD PTR _el_list+4
	push	OFFSET _edge_comp
$LN35@make_el_li:
	push	4
	push	ecx
	push	edx
	call	_qsort

; 1346 :   }
; 1347 : 
; 1348 :   el_list_timestamp[type] = top_timestamp;

	mov	eax, DWORD PTR _top_timestamp
	add	esp, 16					; 00000010H
	mov	DWORD PTR _el_list_timestamp[edi*4], eax
	pop	edi
	pop	esi
	pop	ebx

; 1349 : } // end make_el_list()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@make_el_li:

; 1320 :   { case VERTEX: 
; 1321 :        qsort((char*)(el_list[type]),web.skel[type].count,
; 1322 :        sizeof(element_id), FCAST vertex_comp); 

	mov	ecx, DWORD PTR _web+64
	mov	edx, DWORD PTR _el_list
	push	OFFSET _vertex_comp
	push	4
	push	ecx
	push	edx
	call	_qsort

; 1323 : 
; 1324 :        /* assign processor numbers */
; 1325 :        if ( v_procnum ) myfree((char*)v_procnum);

	mov	eax, DWORD PTR _v_procnum
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN10@make_el_li
	push	eax
	call	_myfree
	add	esp, 4
$LN10@make_el_li:

; 1326 :        v_procnum = (int*)mycalloc(web.skel[VERTEX].max_ord+1,sizeof(int));

	mov	eax, DWORD PTR _web+68
	push	1326					; 0000052eH
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	inc	eax
	push	4
	push	eax
	call	_kb_calloc

; 1327 :        bin = (web.skel[type].count + nprocs - 1)/nprocs;

	mov	ecx, DWORD PTR _nprocs
	mov	ebx, DWORD PTR _web+64
	mov	DWORD PTR _v_procnum, eax
	lea	eax, DWORD PTR [ebx+ecx-1]
	cdq
	idiv	ecx
	add	esp, 16					; 00000010H

; 1328 :        for ( pnum = 0 ; pnum < nprocs ; pnum++ )

	xor	edi, edi
	mov	edx, eax
	mov	DWORD PTR _bin$[ebp], edx
	test	ecx, ecx
	jle	SHORT $LN31@make_el_li

; 1326 :        v_procnum = (int*)mycalloc(web.skel[VERTEX].max_ord+1,sizeof(int));

	xor	eax, eax
	npad	2
$LL9@make_el_li:

; 1329 :        { start = pnum*bin;
; 1330 :          end = start + bin;

	lea	esi, DWORD PTR [eax+edx]

; 1331 :          if ( end > web.skel[type].count ) end = web.skel[type].count;

	cmp	esi, ebx
	jle	SHORT $LN6@make_el_li
	mov	esi, ebx
$LN6@make_el_li:

; 1332 :          for ( i = start ; i < end ; i++ )

	mov	edx, eax
	cmp	eax, esi
	jge	SHORT $LN8@make_el_li
	npad	1
$LL32@make_el_li:

; 1333 :             v_procnum[loc_ordinal(el_list[VERTEX][i])] = pnum;

	mov	ecx, DWORD PTR _el_list
	mov	ecx, DWORD PTR [ecx+edx*4]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN22@make_el_li
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN23@make_el_li
$LN22@make_el_li:
	or	ecx, -1
$LN23@make_el_li:
	mov	ebx, DWORD PTR _v_procnum
	inc	edx
	mov	DWORD PTR [ebx+ecx*4], edi
	cmp	edx, esi
	jl	SHORT $LL32@make_el_li

; 1332 :          for ( i = start ; i < end ; i++ )

	mov	ebx, DWORD PTR _web+64
	mov	ecx, DWORD PTR _nprocs
$LN8@make_el_li:

; 1328 :        for ( pnum = 0 ; pnum < nprocs ; pnum++ )

	mov	edx, DWORD PTR _bin$[ebp]
	inc	edi
	add	eax, edx
	cmp	edi, ecx
	jl	SHORT $LL9@make_el_li
$LN31@make_el_li:

; 1346 :   }
; 1347 : 
; 1348 :   el_list_timestamp[type] = top_timestamp;

	mov	eax, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR _top_timestamp
	pop	edi
	pop	esi
	mov	DWORD PTR _el_list_timestamp[eax*4], edx
	pop	ebx

; 1349 : } // end make_el_list()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@make_el_li:

; 1346 :   }
; 1347 : 
; 1348 :   el_list_timestamp[type] = top_timestamp;

	mov	ecx, DWORD PTR _top_timestamp
	mov	DWORD PTR _el_list_timestamp[edi*4], ecx
	pop	edi
	pop	esi
	pop	ebx

; 1349 : } // end make_el_list()

	mov	esp, ebp
	pop	ebp
	ret	0
_make_el_list ENDP
_TEXT	ENDS
PUBLIC	_multi_calc_quants
EXTRN	_thread_stages:DWORD
EXTRN	_max_thread_stages:DWORD
EXTRN	_m_jumpbuf:BYTE
EXTRN	_m_breakflag:BYTE
EXTRN	_signal:PROC
EXTRN	_catcher:PROC
EXTRN	_win_get_thread_data:PROC
EXTRN	_thread_data_key:DWORD
EXTRN	__setjmp3:PROC
; Function compile flags: /Ogtp
;	COMDAT _multi_calc_quants
_TEXT	SEGMENT
_multi_calc_quants_elapsed_time$ = -72			; size = 8
_th$89758 = -64						; size = 4
_data$89759 = -60					; size = 4
_mm$89795 = -56						; size = 4
_global_needs$ = -52					; size = 4
_q_info$ = -48						; size = 4
tv612 = -44						; size = 4
tv372 = -40						; size = 4
_e_ptr$ = -36						; size = 4
_me$ = -32						; size = 4
_meth_offset$ = -28					; size = 4
_maxstage$89760 = -24					; size = 4
_idptr$89755 = -20					; size = 4
tv948 = -16						; size = 4
tv569 = -16						; size = 4
_mi$ = -16						; size = 4
_setup_flag$89773 = -12					; size = 4
_needs$89774 = -8					; size = 4
_k$ = -4						; size = 4
_type$ = 8						; size = 4
_multi_calc_quants PROC					; COMDAT

; 1362 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 1363 :   int k;
; 1364 :   struct element *e_ptr;
; 1365 :   struct gen_quant_method *gm;
; 1366 :   int mi;
; 1367 :   REAL val;
; 1368 :   struct qinfo *q_info = &(GET_THREAD_DATA->q_info);  /* data passing structure */

	mov	eax, DWORD PTR _thread_data_key
	push	ebx
	push	esi
	push	edi
	push	eax
	call	_win_get_thread_data

; 1369 :   int meth_offset = EXTRAS(type)[web.meth_attr[type]].offset; 

	mov	edx, DWORD PTR _dymem
	add	eax, 56					; 00000038H
	mov	DWORD PTR _q_info$[ebp], eax
	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR _web[eax*4+5664]
	imul	eax, 112				; 00000070H
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR [ecx+edx+64]

; 1370 :   int me = GET_THREAD_ID;  /* which process I am */

	mov	ecx, DWORD PTR _thread_data_key
	push	ecx
	mov	DWORD PTR _meth_offset$[ebp], eax
	call	_win_get_thread_data
	mov	edi, DWORD PTR [eax]

; 1371 :   int global_needs;
; 1372 : 
; 1373 : #ifdef THREADS
; 1374 :  long long int multi_calc_quants_elapsed_time = 0;

	xor	esi, esi

; 1375 : #endif
; 1376 :   
; 1377 : #ifdef SIGUSR1
; 1378 :   signal(SIGUSR1,catcher);    /* to catch user interrupt */ 
; 1379 : #endif
; 1380 :   signal(SIGINT,catcher);    /* to catch user interrupt */     

	push	OFFSET _catcher
	push	2
	mov	DWORD PTR _me$[ebp], edi
	mov	DWORD PTR _multi_calc_quants_elapsed_time$[ebp], esi
	mov	DWORD PTR _multi_calc_quants_elapsed_time$[ebp+4], esi
	call	_signal

; 1381 :   m_breakflag[me] = 0;

	mov	DWORD PTR _m_breakflag[edi*4], esi

; 1382 :   if ( setjmp(m_jumpbuf[me]) ) { return; }

	shl	edi, 6
	add	edi, OFFSET _m_jumpbuf
	push	esi
	push	edi
	call	__setjmp3
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	$LN22@multi_calc

; 1383 : 
; 1384 : PROF_START(multi_calc_quants)
; 1385 : 
; 1386 :   global_needs = global_meth_needs(type);

	mov	edi, DWORD PTR _type$[ebp]
	push	edi
	call	_global_meth_needs

; 1387 : 
; 1388 :   THREAD_FOR_ALL_NEW(type,   /* following block is macro argument! */
; 1389 :   { int setup_flag = 0;
; 1390 :     int needs;  /* particular setup needs for current mode */
; 1391 :    
; 1392 :     q_info->id = *idptr;
; 1393 :     e_ptr = elptr(q_info->id);
; 1394 :     /* get setup flags */
; 1395 :     needs = global_needs;
; 1396 :     for ( k = 0 ; k < e_ptr->method_count ; k++ )
; 1397 :     { int mm;
; 1398 :       mm = ((int*)((char*)e_ptr+meth_offset))[k];
; 1399 :       mi = abs(mm);
; 1400 :       if ( (METH_INSTANCE(mi)->flags & Q_DOTHIS) 
; 1401 :              && (METH_INSTANCE(mi)->type == type) )
; 1402 :         needs |= basic_gen_methods[METH_INSTANCE(mi)->gen_method].flags;
; 1403 :     }
; 1404 : 
; 1405 :     for ( k = 0 ; k < global_meth_inst_count[type]; k++ )
; 1406 :     { mi = global_meth_inst[type][k];
; 1407 :       if ( (METH_INSTANCE(mi)->flags & Q_DOTHIS) 
; 1408 :                   && (METH_INSTANCE(mi)->type == type) )
; 1409 :       { 
; 1410 :         if ( !setup_flag ) 
; 1411 :         { (*q_setup[type])(NULL,q_info,needs); setup_flag = 1; }
; 1412 :         q_info->method = mi;
; 1413 :         gm = basic_gen_methods + METH_INSTANCE(mi)->gen_method;
; 1414 :         val = (*gm->value)(q_info);
; 1415 :         if ( METH_INSTANCE(mi)->flags & ELEMENT_MODULUS_FLAG )
; 1416 :             val *= *(REAL*)get_extra(q_info->id,METH_INSTANCE(mi)->elmodulus);
; 1417 :         METH_INSTANCE(mi)->procvalue[me] += val;
; 1418 :         METH_INSTANCE(mi)->procabstotal[me] += fabs(val);
; 1419 :       }
; 1420 :     }
; 1421 :     for ( k = 0 ; k < e_ptr->method_count ; k++ )
; 1422 :     { int mm;
; 1423 :       mm = ((int*)((char*)e_ptr+meth_offset))[k];
; 1424 :       q_info->method = mi = abs(mm);
; 1425 :       if ( (METH_INSTANCE(mi)->flags & Q_DOTHIS) 
; 1426 :              && (METH_INSTANCE(mi)->type == type) )
; 1427 :       {
; 1428 :         if ( !setup_flag )  
; 1429 :         { (*q_setup[type])(NULL,q_info,needs); setup_flag = 1; }
; 1430 :         gm = basic_gen_methods + METH_INSTANCE(mi)->gen_method;
; 1431 :         val = (*gm->value)(q_info);
; 1432 :         if ( METH_INSTANCE(mi)->flags & ELEMENT_MODULUS_FLAG )
; 1433 :             val *= *(REAL*)get_extra(q_info->id,METH_INSTANCE(mi)->elmodulus);
; 1434 :         METH_INSTANCE(mi)->procvalue[me] += (mm < 0 ) ? -val : val;
; 1435 :         METH_INSTANCE(mi)->procabstotal[me] += fabs(val);
; 1436 :       }
; 1437 :     }
; 1438 :   }
; 1439 : ) /* end THREAD_FOR_ALL_NEW macro */

	mov	edx, DWORD PTR _thread_data_key
	push	edx
	mov	DWORD PTR _global_needs$[ebp], eax
	call	_win_get_thread_data
	mov	ebx, eax
	mov	eax, DWORD PTR _nprocs
	mov	ecx, DWORD PTR [ebx]
	dec	eax
	add	esp, 8
	mov	DWORD PTR _data$89759[ebp], ebx
	cmp	ecx, eax
	jne	SHORT $LN28@multi_calc
	xor	eax, eax
	jmp	SHORT $LN29@multi_calc
$LN28@multi_calc:
	lea	eax, DWORD PTR [ecx+1]
$LN29@multi_calc:
	mov	edx, DWORD PTR _max_thread_stages
	cmp	ecx, esi
	jne	SHORT $LN30@multi_calc
	inc	edx
$LN30@multi_calc:
	imul	ecx, 548				; 00000224H
	add	ecx, DWORD PTR _thread_stages
	mov	DWORD PTR _maxstage$89760[ebp], edx
	mov	DWORD PTR [ecx+540], esi
	mov	edx, DWORD PTR [ecx+540]
	mov	DWORD PTR _th$89758[ebp], ecx
	cmp	edx, DWORD PTR _maxstage$89760[ebp]
	jge	$LN22@multi_calc
	imul	eax, 548				; 00000224H
	add	eax, 540				; 0000021cH
	mov	DWORD PTR tv612[ebp], eax
$LN21@multi_calc:
	mov	edx, DWORD PTR tv612[ebp]
	mov	eax, DWORD PTR _thread_stages
	mov	eax, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [ecx+540]
	cmp	eax, edx
	jl	SHORT $LN21@multi_calc
	mov	esi, DWORD PTR [ecx+540]
	rdtsc
	mov	DWORD PTR [ebx+esi*8+1808], eax
	mov	DWORD PTR [ebx+esi*8+1812], edx
	mov	edx, DWORD PTR [ecx+540]
	lea	eax, DWORD PTR [edi+edi*8]
	add	eax, edx
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _idptr$89755[ebp], eax
	mov	eax, DWORD PTR [ecx+540]
	lea	edx, DWORD PTR [edi+edi*8+45]
	add	edx, eax
	mov	eax, DWORD PTR [ecx+edx*4]
	test	eax, eax
	jle	$LN17@multi_calc
	mov	ebx, DWORD PTR _q_info$[ebp]
	mov	DWORD PTR tv372[ebp], eax
$LL19@multi_calc:
	mov	ecx, DWORD PTR _idptr$89755[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	DWORD PTR [ebx], eax
	mov	ecx, DWORD PTR _web[edx+12]
	mov	edx, DWORD PTR _global_needs$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	movzx	eax, WORD PTR [ecx+24]
	mov	DWORD PTR _setup_flag$89773[ebp], 0
	mov	DWORD PTR _e_ptr$[ebp], ecx
	mov	DWORD PTR _needs$89774[ebp], edx
	test	eax, eax
	jle	SHORT $LN14@multi_calc
	mov	edx, DWORD PTR _meth_offset$[ebp]
	lea	esi, DWORD PTR [ecx+edx]
	mov	DWORD PTR tv569[ebp], eax
$LL16@multi_calc:
	mov	eax, DWORD PTR [esi]
	cdq
	xor	eax, edx
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	test	BYTE PTR [eax+edx+140], 16		; 00000010H
	je	SHORT $LN15@multi_calc
	cmp	DWORD PTR [eax+edx+136], edi
	jne	SHORT $LN15@multi_calc
	mov	eax, DWORD PTR [eax+edx+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	mov	edx, DWORD PTR _basic_gen_methods[eax+132]
	or	DWORD PTR _needs$89774[ebp], edx
$LN15@multi_calc:
	add	esi, 4
	dec	DWORD PTR tv569[ebp]
	jne	SHORT $LL16@multi_calc
$LN14@multi_calc:
	cmp	DWORD PTR _web[edi*4+5588], 0
	mov	DWORD PTR _k$[ebp], 0
	jle	$LN10@multi_calc
	npad	1
$LL12@multi_calc:
	mov	eax, DWORD PTR _web[edi*4+5568]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, ecx
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR _meth_inst_list
	xor	edi, edx
	sub	edi, edx
	mov	esi, edi
	imul	esi, 2928				; 00000b70H
	test	BYTE PTR [esi+eax+140], 16		; 00000010H
	mov	DWORD PTR _mi$[ebp], ecx
	je	$LN11@multi_calc
	mov	edx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [esi+eax+136], edx
	jne	$LN11@multi_calc
	cmp	DWORD PTR _setup_flag$89773[ebp], 0
	jne	SHORT $LN8@multi_calc
	mov	eax, DWORD PTR _needs$89774[ebp]
	mov	ecx, DWORD PTR _q_setup[edx*4]
	push	eax
	push	ebx
	push	0
	call	ecx
	mov	ecx, DWORD PTR _mi$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _setup_flag$89773[ebp], 1
$LN8@multi_calc:
	mov	DWORD PTR [ebx+8], ecx
	mov	edx, DWORD PTR _meth_inst_list
	mov	eax, DWORD PTR [esi+edx+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	add	eax, OFFSET _basic_gen_methods
	mov	eax, DWORD PTR [eax+144]
	push	ebx
	call	eax
	mov	edx, DWORD PTR _meth_inst_list
	add	esp, 4
	test	DWORD PTR [esi+edx+140], 268435456	; 10000000H
	je	SHORT $LN7@multi_calc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [esi+edx+228]
	mov	eax, ecx
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	esi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	esi, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [esi+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	fmul	QWORD PTR [edx+eax]
	mov	edx, DWORD PTR _meth_inst_list
$LN7@multi_calc:
	imul	edi, 366				; 0000016eH
	add	edi, DWORD PTR _me$[ebp]
	fld	QWORD PTR [edx+edi*8+584]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [edx+edi*8+584]
	mov	eax, DWORD PTR _meth_inst_list
	fabs
	fadd	QWORD PTR [eax+edi*8+1736]
	fstp	QWORD PTR [eax+edi*8+1736]
$LN11@multi_calc:
	mov	eax, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _type$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	mov	edi, edx
	cmp	eax, DWORD PTR _web[edx*4+5588]
	jl	$LL12@multi_calc
	mov	ecx, DWORD PTR _e_ptr$[ebp]
$LN10@multi_calc:
	xor	eax, eax
	mov	DWORD PTR _k$[ebp], 0
	cmp	ax, WORD PTR [ecx+24]
	jae	$LN18@multi_calc
	mov	edx, DWORD PTR _meth_offset$[ebp]
	lea	eax, DWORD PTR [ecx+edx]
	mov	DWORD PTR tv948[ebp], eax
$LN6@multi_calc:
	mov	edx, DWORD PTR tv948[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _mm$89795[ebp], eax
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR [ebx+8], eax
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR _meth_inst_list
	xor	edi, edx
	sub	edi, edx
	mov	esi, edi
	imul	esi, 2928				; 00000b70H
	test	BYTE PTR [esi+eax+140], 16		; 00000010H
	je	$LN5@multi_calc
	mov	edx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [esi+eax+136], edx
	jne	$LN5@multi_calc
	cmp	DWORD PTR _setup_flag$89773[ebp], 0
	jne	SHORT $LN2@multi_calc
	mov	eax, DWORD PTR _needs$89774[ebp]
	mov	ecx, DWORD PTR _q_setup[edx*4]
	push	eax
	push	ebx
	push	0
	call	ecx
	mov	eax, DWORD PTR _meth_inst_list
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _setup_flag$89773[ebp], 1
$LN2@multi_calc:
	mov	eax, DWORD PTR [esi+eax+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	add	eax, OFFSET _basic_gen_methods
	mov	edx, DWORD PTR [eax+144]
	push	ebx
	call	edx
	mov	edx, DWORD PTR _meth_inst_list
	add	esp, 4
	test	DWORD PTR [esi+edx+140], 268435456	; 10000000H
	je	SHORT $LN1@multi_calc
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [esi+edx+228]
	mov	eax, ecx
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	esi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	esi, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [esi+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	fmul	QWORD PTR [edx+eax]
	mov	edx, DWORD PTR _meth_inst_list
$LN1@multi_calc:
	cmp	DWORD PTR _mm$89795[ebp], 0
	fld	ST(0)
	jge	SHORT $LN33@multi_calc
	fchs
$LN33@multi_calc:
	mov	ecx, DWORD PTR _e_ptr$[ebp]
	imul	edi, 366				; 0000016eH
	add	edi, DWORD PTR _me$[ebp]
	fadd	QWORD PTR [edx+edi*8+584]
	fstp	QWORD PTR [edx+edi*8+584]
	mov	eax, DWORD PTR _meth_inst_list
	fabs
	fadd	QWORD PTR [eax+edi*8+1736]
	fstp	QWORD PTR [eax+edi*8+1736]
$LN5@multi_calc:
	mov	eax, DWORD PTR _k$[ebp]
	movzx	edx, WORD PTR [ecx+24]
	add	DWORD PTR tv948[ebp], 4
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, edx
	jl	$LN6@multi_calc
	mov	edi, DWORD PTR _type$[ebp]
$LN18@multi_calc:
	add	DWORD PTR _idptr$89755[ebp], 4
	dec	DWORD PTR tv372[ebp]
	jne	$LL19@multi_calc
	mov	ebx, DWORD PTR _data$89759[ebp]
	mov	ecx, DWORD PTR _th$89758[ebp]
$LN17@multi_calc:
	mov	esi, DWORD PTR [ecx+540]
	rdtsc
	mov	DWORD PTR [ebx+esi*8+1880], eax
	mov	DWORD PTR [ebx+esi*8+1884], edx
	inc	DWORD PTR [ecx+540]
	mov	eax, DWORD PTR [ecx+540]
	cmp	eax, DWORD PTR _maxstage$89760[ebp]
	jl	$LN21@multi_calc
$LN22@multi_calc:

; 1440 : 
; 1441 : PROF_FINISH(multi_calc_quants)
; 1442 : /*
; 1443 :   if ( verbose_flag )
; 1444 :   { PROF_PRINT(multi_calc_quants)
; 1445 :   }
; 1446 : */
; 1447 : } // end multi_calc_quants()

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_multi_calc_quants ENDP
_TEXT	ENDS
PUBLIC	_m_fix_grads
EXTRN	_pbase:BYTE
EXTRN	_phead:BYTE
; Function compile flags: /Ogtp
;	COMDAT _m_fix_grads
_TEXT	SEGMENT
tv306 = -4						; size = 4
_m_fix_grads PROC					; COMDAT

; 2051 : { int me = GET_THREAD_ID;

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	eax, DWORD PTR _thread_data_key
	push	ebx
	push	eax
	call	_win_get_thread_data
	mov	eax, DWORD PTR [eax]

; 2052 :   int pnum;
; 2053 :   int i,k;
; 2054 :   struct procforce *p;
; 2055 :   REAL *f;
; 2056 : 
; 2057 :   for ( pnum = 0 ; pnum < nprocs ; pnum++ )

	xor	ebx, ebx
	add	esp, 4
	cmp	DWORD PTR _nprocs, ebx
	jle	$LN7@m_fix_grad

; 2051 : { int me = GET_THREAD_ID;

	lea	ecx, DWORD PTR [eax+eax*8]
	shl	ecx, 6
	push	esi
	add	ecx, OFFSET _phead
	push	edi
	mov	edi, DWORD PTR _web+616
	mov	DWORD PTR tv306[ebp], ecx
	npad	6
$LL18@m_fix_grad:

; 2058 :   { for ( k = phead[me][pnum] ; k >= 0 ; k = p->next )

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	js	SHORT $LN8@m_fix_grad
	npad	10
$LL6@m_fix_grad:

; 2059 :      { p = pbase[pnum] + k;

	mov	edx, DWORD PTR _pbase[ebx*4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 2060 :         f = get_force(p->v_id);

	mov	eax, DWORD PTR [edx+ecx*8]
	lea	esi, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	ecx, DWORD PTR [eax+edx+784]

; 2061 :         for ( i = 0 ; i < SDIM ; i++ ) f[i] += p->f[i];

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN5@m_fix_grad

; 2059 :      { p = pbase[pnum] + k;

	lea	edx, DWORD PTR [esi+8]
	npad	1
$LL3@m_fix_grad:

; 2061 :         for ( i = 0 ; i < SDIM ; i++ ) f[i] += p->f[i];

	fld	QWORD PTR [ecx+eax*8]
	inc	eax
	fadd	QWORD PTR [edx]
	add	edx, 8
	fstp	QWORD PTR [ecx+eax*8-8]
	mov	edi, DWORD PTR _web+616
	cmp	eax, edi
	jl	SHORT $LL3@m_fix_grad
$LN5@m_fix_grad:

; 2058 :   { for ( k = phead[me][pnum] ; k >= 0 ; k = p->next )

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jns	SHORT $LL6@m_fix_grad
	mov	ecx, DWORD PTR tv306[ebp]
$LN8@m_fix_grad:

; 2052 :   int pnum;
; 2053 :   int i,k;
; 2054 :   struct procforce *p;
; 2055 :   REAL *f;
; 2056 : 
; 2057 :   for ( pnum = 0 ; pnum < nprocs ; pnum++ )

	inc	ebx
	add	ecx, 4
	mov	DWORD PTR tv306[ebp], ecx
	cmp	ebx, DWORD PTR _nprocs
	jl	SHORT $LL18@m_fix_grad
	pop	edi
	pop	esi
$LN7@m_fix_grad:
	pop	ebx

; 2062 :      }
; 2063 :   }
; 2064 : } // end m_fix_grads()

	mov	esp, ebp
	pop	ebp
	ret	0
_m_fix_grads ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@LDLDAIFO@m_Hess?5init?5alloc?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	_m_hess_hash_init
EXTRN	_temp_free:PROC
EXTRN	_outstring:PROC
EXTRN	_msg:DWORD
EXTRN	_hessian_quiet_flag:DWORD
_BSS	SEGMENT
_m_hash_extraprobes DD 01H DUP (?)
_m_hashcount DD	090H DUP (?)
_m_max_fill DD	090H DUP (?)
_m_hash_per_row DD 090H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BH@LDLDAIFO@m_Hess?5init?5alloc?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BH@LDLDAIFO@m_Hess?5init?5alloc?3?5?$CFd?6?$AA@ DB 'm_Hess init al'
	DB	'loc: %d', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _m_hess_hash_init
_TEXT	SEGMENT
_m_hess_hash_init PROC					; COMDAT

; 2972 :   int me = GET_THREAD_ID;

	mov	eax, DWORD PTR _thread_data_key
	push	ebx
	push	esi
	push	edi
	push	eax
	call	_win_get_thread_data
	mov	edi, DWORD PTR [eax]

; 2973 : 
; 2974 :   if ( m_hash_per_row[me] < 1 ) m_hash_per_row[me] = 1;

	mov	eax, 1
	add	esp, 4
	cmp	DWORD PTR _m_hash_per_row[edi*4], eax
	jge	SHORT $LN6@m_hess_has
	mov	DWORD PTR _m_hash_per_row[edi*4], eax
$LN6@m_hess_has:

; 2975 :   m_table_size[me] = m_hash_per_row[me]*SDIM*web.skel[VERTEX].max_ord/nprocs;

	mov	eax, DWORD PTR _m_hash_per_row[edi*4]
	imul	eax, DWORD PTR _web+68
	imul	eax, DWORD PTR _web+616
	cdq
	idiv	DWORD PTR _nprocs

; 2976 :   m_max_fill[me] = 4*m_table_size[me]/5;
; 2977 :   if ( !hessian_quiet_flag )

	xor	ebx, ebx
	lea	esi, DWORD PTR _m_table_size[edi*4]
	mov	ecx, eax
	lea	edx, DWORD PTR [ecx*4]
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR _m_max_fill[edi*4], eax
	cmp	DWORD PTR _hessian_quiet_flag, ebx
	jne	SHORT $LN5@m_hess_has

; 2978 :   { sprintf(msg,"m_Hess init alloc: %d\n",m_table_size[me]);

	push	ecx
	mov	ecx, DWORD PTR _msg
	push	OFFSET ??_C@_0BH@LDLDAIFO@m_Hess?5init?5alloc?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf

; 2979 :      outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN5@m_hess_has:

; 2980 :   }
; 2981 :   m_hashcount[me] = 0;
; 2982 :   if ( m_hashtable[me] ) temp_free((char*)m_hashtable[me]);

	mov	eax, DWORD PTR _m_hashtable[edi*4]
	mov	DWORD PTR _m_hashcount[edi*4], ebx
	lea	edi, DWORD PTR _m_hashtable[edi*4]
	cmp	eax, ebx
	je	SHORT $LN4@m_hess_has
	push	eax
	call	_temp_free
	add	esp, 4
$LN4@m_hess_has:

; 2983 :   m_hashtable[me] = 
; 2984 :      (struct hess_entry *)mycalloc(m_table_size[me],sizeof(struct hess_entry));

	mov	eax, DWORD PTR [esi]
	push	2984					; 00000ba8H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	16					; 00000010H
	push	eax
	call	_kb_calloc
	mov	DWORD PTR [edi], eax
	add	esp, 16					; 00000010H

; 2985 :   for ( i = 0 ; i < m_table_size[me] ; i++ ) m_hashtable[me][i].row = HASHEMPTY;

	xor	eax, eax
	cmp	DWORD PTR [esi], ebx
	jle	SHORT $LN11@m_hess_has

; 2983 :   m_hashtable[me] = 
; 2984 :      (struct hess_entry *)mycalloc(m_table_size[me],sizeof(struct hess_entry));

	xor	ecx, ecx
	or	edx, -1
	npad	2
$LL3@m_hess_has:

; 2985 :   for ( i = 0 ; i < m_table_size[me] ; i++ ) m_hashtable[me][i].row = HASHEMPTY;

	mov	ebx, DWORD PTR [edi]
	mov	DWORD PTR [ecx+ebx+12], edx
	inc	eax
	add	ecx, 16					; 00000010H
	cmp	eax, DWORD PTR [esi]
	jl	SHORT $LL3@m_hess_has

; 2986 :   m_hash_extraprobes = 0;

	pop	edi
	pop	esi
	mov	DWORD PTR _m_hash_extraprobes, 0
	pop	ebx

; 2987 : } // end m_hess_hash_init()

	ret	0
$LN11@m_hess_has:
	pop	edi
	pop	esi

; 2986 :   m_hash_extraprobes = 0;

	mov	DWORD PTR _m_hash_extraprobes, ebx
	pop	ebx

; 2987 : } // end m_hess_hash_init()

	ret	0
_m_hess_hash_init ENDP
_TEXT	ENDS
PUBLIC	_m_hess_hash_search
PUBLIC	_m_hess_hash_expand
; Function compile flags: /Ogtp
;	COMDAT _m_hess_hash_expand
_TEXT	SEGMENT
_oldsize$ = -8						; size = 4
_oldtable$ = -4						; size = 4
_m_hess_hash_expand PROC				; COMDAT

; 2997 : { struct hess_entry *newtable,*oldtable;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2998 :   int i;
; 2999 :   int me = GET_THREAD_ID;

	mov	eax, DWORD PTR _thread_data_key
	push	ebx
	push	esi
	push	edi
	push	eax
	call	_win_get_thread_data
	mov	edi, DWORD PTR [eax]

; 3000 :   struct hess_entry *e;
; 3001 :   int newsize; 
; 3002 :   int oldsize = m_table_size[me];

	mov	ecx, DWORD PTR _m_table_size[edi*4]
	add	esp, 4

; 3003 : 
; 3004 :   if ( !m_hashtable[me] ) m_hess_hash_init();

	cmp	DWORD PTR _m_hashtable[edi*4], 0
	mov	DWORD PTR _oldsize$[ebp], ecx
	jne	SHORT $LN8@m_hess_has@2
	call	_m_hess_hash_init
$LN8@m_hess_has@2:

; 3005 :   newsize = m_table_size[me]*2; 

	mov	esi, DWORD PTR _m_table_size[edi*4]

; 3006 :   oldtable = m_hashtable[me];

	mov	edx, DWORD PTR _m_hashtable[edi*4]

; 3007 :   newtable = 
; 3008 :      (struct hess_entry *)mycalloc(newsize,sizeof(struct hess_entry));

	push	3008					; 00000bc0H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	add	esi, esi
	push	16					; 00000010H
	push	esi
	mov	DWORD PTR _oldtable$[ebp], edx
	call	_kb_calloc
	add	esp, 16					; 00000010H
	mov	ebx, eax

; 3009 :   for ( i = 0 ; i < newsize ; i++ ) newtable[i].row = HASHEMPTY;

	test	esi, esi
	jle	SHORT $LN5@m_hess_has@2

; 3005 :   newsize = m_table_size[me]*2; 

	lea	eax, DWORD PTR [ebx+12]
	mov	ecx, esi
$LL7@m_hess_has@2:

; 3009 :   for ( i = 0 ; i < newsize ; i++ ) newtable[i].row = HASHEMPTY;

	mov	DWORD PTR [eax], -1
	add	eax, 16					; 00000010H
	dec	ecx
	jne	SHORT $LL7@m_hess_has@2
$LN5@m_hess_has@2:

; 3011 :   m_max_fill[me] = 4*m_table_size[me]/5;

	lea	ecx, DWORD PTR [esi*4]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _m_max_fill[edi*4], eax

; 3012 :   m_hashtable[me] = newtable;
; 3013 : 
; 3014 :   /* reinsert */
; 3015 :   m_hashcount[me] = 0;
; 3016 :   for ( i = 0, e = oldtable ; i < oldsize ; i++,e++ )

	mov	eax, DWORD PTR _oldsize$[ebp]
	mov	DWORD PTR _m_table_size[edi*4], esi
	mov	DWORD PTR _m_hashtable[edi*4], ebx
	mov	DWORD PTR _m_hashcount[edi*4], 0
	test	eax, eax
	jle	SHORT $LN15@m_hess_has@2

; 3010 :   m_table_size[me] =  newsize;

	mov	esi, DWORD PTR _oldtable$[ebp]
	add	esi, 12					; 0000000cH
	mov	ebx, eax
$LL4@m_hess_has@2:

; 3017 :      if ( e->row != HASHEMPTY )

	mov	eax, DWORD PTR [esi]
	cmp	eax, -1
	je	SHORT $LN3@m_hess_has@2

; 3018 :         m_hess_hash_search(e->col,e->row,e->value,me);

	fld	QWORD PTR [esi-12]
	mov	ecx, DWORD PTR [esi-4]
	push	edi
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	push	ecx
	call	_m_hess_hash_search
	add	esp, 20					; 00000014H
$LN3@m_hess_has@2:

; 3012 :   m_hashtable[me] = newtable;
; 3013 : 
; 3014 :   /* reinsert */
; 3015 :   m_hashcount[me] = 0;
; 3016 :   for ( i = 0, e = oldtable ; i < oldsize ; i++,e++ )

	add	esi, 16					; 00000010H
	dec	ebx
	jne	SHORT $LL4@m_hess_has@2
$LN15@m_hess_has@2:

; 3019 :   myfree((char*)oldtable);

	mov	edx, DWORD PTR _oldtable$[ebp]
	push	edx
	call	_myfree
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 3020 : } // end m_hess_hash_expand()

	mov	esp, ebp
	pop	ebp
	ret	0
_m_hess_hash_expand ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _m_hess_hash_search
_TEXT	SEGMENT
tv166 = -8						; size = 4
tv247 = -4						; size = 4
_row$ = 8						; size = 4
_col$ = 12						; size = 4
_value$ = 16						; size = 8
_tab_size$ = 24						; size = 4
_tid$ = 24						; size = 4
_m_hess_hash_search PROC				; COMDAT

; 3034 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3035 :   struct hess_entry *e;
; 3036 :   int spot;
; 3037 :   struct hess_entry *hashtab;
; 3038 :   int tab_size = m_table_size[tid];
; 3039 : 
; 3040 :   if ( row > col ) return;

	mov	eax, DWORD PTR _row$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _tid$[ebp]
	mov	esi, DWORD PTR _m_table_size[edi*4]
	mov	DWORD PTR _tab_size$[ebp], esi
	cmp	eax, DWORD PTR _col$[ebp]
	jg	$LN7@m_hess_has@3

; 3041 : 
; 3042 :   if ( m_hashcount[tid] >= m_max_fill[tid] ) m_hess_hash_expand();

	mov	ecx, DWORD PTR _m_hashcount[edi*4]
	push	ebx
	lea	ebx, DWORD PTR _m_hashcount[edi*4]
	cmp	ecx, DWORD PTR _m_max_fill[edi*4]
	jl	SHORT $LN5@m_hess_has@3
	call	_m_hess_hash_expand
$LN5@m_hess_has@3:

; 3044 : 
; 3045 :   /* search hash table */
; 3046 :   spot = hash(row,col) % tab_size;

	mov	eax, DWORD PTR _col$[ebp]
	mov	edx, DWORD PTR _row$[ebp]
	imul	eax, 99991				; 00018697H
	imul	edx, 97					; 00000061H
	add	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	cdq
	idiv	esi

; 3047 :   e = hashtab + spot;

	mov	eax, edx
	shl	eax, 4
	add	eax, DWORD PTR _m_hashtable[edi*4]

; 3048 :   while ( e->row != HASHEMPTY )

	cmp	DWORD PTR [eax+12], -1
	je	SHORT $LN13@m_hess_has@3

; 3043 :   hashtab = m_hashtable[tid];

	mov	ecx, esi
	shl	ecx, 4
	mov	DWORD PTR tv247[ebp], ecx
	lea	ecx, DWORD PTR [eax+12]
$LL4@m_hess_has@3:

; 3049 :   { if ( (e->row == row) && (e->col == col) )

	mov	esi, DWORD PTR [ecx]
	cmp	esi, DWORD PTR _row$[ebp]
	jne	SHORT $LN12@m_hess_has@3
	mov	esi, DWORD PTR [eax+8]
	cmp	esi, DWORD PTR _col$[ebp]
	je	SHORT $LN10@m_hess_has@3
$LN12@m_hess_has@3:

; 3051 :      }
; 3052 :      spot++;
; 3053 :      if ( spot >= tab_size ) spot -= tab_size;

	mov	esi, DWORD PTR _tab_size$[ebp]
	inc	edx
	add	eax, 16					; 00000010H
	add	ecx, 16					; 00000010H
	cmp	edx, esi
	jl	SHORT $LN1@m_hess_has@3
	sub	edx, esi
	mov	esi, DWORD PTR tv247[ebp]
	sub	eax, esi
	sub	ecx, esi
$LN1@m_hess_has@3:

; 3054 :      e = hashtab + spot;
; 3055 :      m_hash_extraprobes++;

	inc	DWORD PTR _m_hash_extraprobes
	cmp	DWORD PTR [ecx], -1
	jne	SHORT $LL4@m_hess_has@3
$LN13@m_hess_has@3:

; 3056 :   }
; 3057 :   /* if here, then have empty slot and need to insert */
; 3058 :   e->col = col; e->row = row;  m_hashcount[tid]++; 

	mov	ecx, DWORD PTR _col$[ebp]

; 3059 :   e->value = value;

	fld	QWORD PTR _value$[ebp]
	mov	edx, DWORD PTR _row$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	inc	DWORD PTR [ebx]
	fstp	QWORD PTR [eax]
	pop	ebx
$LN7@m_hess_has@3:
	pop	edi
	pop	esi

; 3060 : } // end m_hess_hash_search()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@m_hess_has@3:

; 3050 :      { e->value += value; return; 

	fld	QWORD PTR _value$[ebp]
	pop	ebx
	fadd	QWORD PTR [eax]
	pop	edi
	pop	esi

; 3059 :   e->value = value;

	fstp	QWORD PTR [eax]

; 3060 : } // end m_hess_hash_search()

	mov	esp, ebp
	pop	ebp
	ret	0
_m_hess_hash_search ENDP
_TEXT	ENDS
PUBLIC	_grad$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_m_fill_grad
EXTRN	_dot:PROC
EXTRN	_hess_flag:DWORD
EXTRN	_vec_mat_mul:PROC
EXTRN	_rhs_flag:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _m_fill_grad
_TEXT	SEGMENT
_grad$GSCopy$ = -60					; size = 4
tv275 = -56						; size = 4
_g$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v$ = 8							; size = 4
_grad$ = 12						; size = 4
_rhs$ = 16						; size = 4
_tid$ = 20						; size = 4
_m_fill_grad PROC					; COMDAT

; 3294 : { REAL g[MAXCOORD];

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3295 :   int k,a,b;
; 3296 : 
; 3297 :   if ( rhs_flag )

	cmp	DWORD PTR _rhs_flag, 0
	mov	edx, DWORD PTR _grad$[ebp]
	push	esi
	mov	esi, DWORD PTR _v$[ebp]
	push	edi
	mov	edi, DWORD PTR _rhs$[ebp]

; 3311 :   { 
; 3312 :      for ( a = 0 ; a < v->freedom ; a++ )

	mov	DWORD PTR _grad$GSCopy$[ebp], edx
	je	SHORT $LN8@m_fill_gra

; 3298 :   { M_LOCK(rhs);
; 3299 :      if ( v->proj )

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN15@m_fill_gra

; 3300 :      { vec_mat_mul(grad,v->proj,g,SDIM,v->freedom);

	mov	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	ecx, DWORD PTR _g$[ebp]
	push	ecx
	push	eax
	push	edx
	call	_vec_mat_mul

; 3301 :         for ( k = 0 ; k < v->freedom ; k++ )

	xor	eax, eax
	add	esp, 20					; 00000014H
	cmp	DWORD PTR [esi+8], eax
	jle	SHORT $LN8@m_fill_gra
	npad	2
$LL14@m_fill_gra:

; 3302 :             rhs[v->rownum+k] -= g[k];

	mov	edx, DWORD PTR [esi+12]
	add	edx, eax
	fld	QWORD PTR [edi+edx*8]
	lea	ecx, DWORD PTR [edi+edx*8]
	fsub	QWORD PTR _g$[ebp+eax*8]
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi+8]
	jl	SHORT $LL14@m_fill_gra

; 3303 :      }
; 3304 :      else

	jmp	SHORT $LN8@m_fill_gra
$LN15@m_fill_gra:

; 3305 :         for ( k = 0 ; k < v->freedom ; k++ )

	xor	eax, eax
	cmp	DWORD PTR [esi+8], eax
	jle	SHORT $LN8@m_fill_gra
$LL10@m_fill_gra:

; 3306 :             rhs[v->rownum+k] -= grad[k];

	mov	ecx, DWORD PTR [esi+12]
	add	ecx, eax
	fld	QWORD PTR [edi+ecx*8]
	lea	ecx, DWORD PTR [edi+ecx*8]
	fsub	QWORD PTR [edx+eax*8]
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi+8]
	jl	SHORT $LL10@m_fill_gra
$LN8@m_fill_gra:

; 3307 :      M_UNLOCK(rhs);
; 3308 :   }
; 3309 : 
; 3310 :   if ( hess_flag && v->conhess )

	cmp	DWORD PTR _hess_flag, 0
	je	SHORT $LN4@m_fill_gra
	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN4@m_fill_gra

; 3311 :   { 
; 3312 :      for ( a = 0 ; a < v->freedom ; a++ )

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+8], ebx
	jle	SHORT $LN28@m_fill_gra
	npad	3
$LL27@m_fill_gra:

; 3313 :       for ( b = 0 ; b <= a ; b++ )

	xor	edi, edi
	test	ebx, ebx
	js	SHORT $LN5@m_fill_gra
	npad	10
$LL3@m_fill_gra:

; 3314 :       { 
; 3315 :          m_hess_hash_search(v->rownum+a,v->rownum+b,
; 3316 :                   SDIM_dot(grad,v->conhess[a][b]),tid);

	mov	edx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR _tid$[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR tv275[ebp], edx
	mov	edx, DWORD PTR [esi+20]
	push	eax
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR _grad$GSCopy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	call	_dot
	fstp	QWORD PTR [esp+4]
	mov	eax, DWORD PTR tv275[ebp]
	add	esp, 4
	lea	ecx, DWORD PTR [eax+edi]
	push	ecx
	add	eax, ebx
	push	eax
	call	_m_hess_hash_search
	inc	edi
	add	esp, 20					; 00000014H
	cmp	edi, ebx
	jle	SHORT $LL3@m_fill_gra
$LN5@m_fill_gra:

; 3311 :   { 
; 3312 :      for ( a = 0 ; a < v->freedom ; a++ )

	inc	ebx
	cmp	ebx, DWORD PTR [esi+8]
	jl	SHORT $LL27@m_fill_gra
$LN28@m_fill_gra:
	pop	ebx
$LN4@m_fill_gra:

; 3317 :       }
; 3318 :   }
; 3319 : } // end m_fill_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_m_fill_grad ENDP
_TEXT	ENDS
PUBLIC	_mixed$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_m_fill_mixed_entry
EXTRN	_mat_mult:PROC
EXTRN	_tr_mat_mul:PROC
EXTRN	_vhead:DWORD
EXTRN	_vhead_attr:DWORD
EXTRN	_mat2d_setup:PROC
; Function compile flags: /Ogtp
;	COMDAT _m_fill_mixed_entry
_TEXT	SEGMENT
_temp_mat2qXvS$ = -640					; size = 24
_temp_matqXvS$ = -616					; size = 24
_temp_mat$ = -592					; size = 4
_j$ = -588						; size = 4
_temp_mat2$ = -588					; size = 4
tv382 = -584						; size = 4
tv360 = -584						; size = 4
_mixed$GSCopy$ = -584					; size = 4
_temp_matxJ$ = -580					; size = 288
_temp_mat2xJ$ = -292					; size = 288
__$ArrayPad$ = -4					; size = 4
_v_id1$ = 8						; size = 4
_v_id2$ = 12						; size = 4
_mixed$ = 16						; size = 4
_tid$ = 20						; size = 4
_m_fill_mixed_entry PROC				; COMDAT

; 3336 : { int k,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 640				; 00000280H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _mixed$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _v_id2$[ebp]
	push	esi
	mov	esi, DWORD PTR _v_id1$[ebp]
	push	edi

; 3337 :   REAL **oo;
; 3338 :   MAT2D(temp_mat,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	ecx, DWORD PTR _temp_matxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp_matqXvS$[ebp]
	push	edx
	mov	DWORD PTR _mixed$GSCopy$[ebp], eax
	call	_mat2d_setup

; 3339 :   MAT2D(temp_mat2,MAXCOORD,MAXCOORD);

	push	6
	mov	DWORD PTR _temp_mat$[ebp], eax
	push	6
	lea	eax, DWORD PTR _temp_mat2xJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp_mat2qXvS$[ebp]
	push	ecx
	call	_mat2d_setup

; 3340 :   struct hess_verlist *v1,*v2;
; 3341 :   
; 3342 :   v1 = get_vertex_vhead(v_id1); 

	mov	edx, DWORD PTR _vhead_attr
	mov	ecx, DWORD PTR _web+12
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	DWORD PTR _temp_mat2$[ebp], eax
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax+64]
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	edi, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _vhead

; 3343 :   v2 = get_vertex_vhead(v_id2);

	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	esi, DWORD PTR [eax+ecx]
	shl	edi, 5

; 3344 :   if ( v1->proj )

	mov	eax, DWORD PTR [edi+edx+16]
	add	edi, edx
	shl	esi, 5
	add	esp, 32					; 00000020H
	add	esi, edx
	test	eax, eax
	je	SHORT $LN17@m_fill_mix

; 3345 :      { tr_mat_mul(v1->proj,mixed,temp_mat,SDIM,v1->freedom,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [edi+8]
	mov	ebx, DWORD PTR _temp_mat$[ebp]
	push	ecx
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _mixed$GSCopy$[ebp]
	push	ebx
	push	ecx
	push	eax
	call	_tr_mat_mul
	add	esp, 24					; 00000018H

; 3346 :         oo = temp_mat;

	mov	ecx, ebx
	jmp	SHORT $LN16@m_fill_mix
$LN17@m_fill_mix:

; 3347 :      }
; 3348 :   else oo = mixed;

	mov	ecx, DWORD PTR _mixed$GSCopy$[ebp]
$LN16@m_fill_mix:

; 3349 :   if ( v2->proj )

	mov	eax, DWORD PTR [esi+16]
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $LN15@m_fill_mix

; 3350 :      { mat_mult(oo,v2->proj,temp_mat2,v1->freedom,SDIM,v2->freedom);

	mov	edx, DWORD PTR [esi+8]
	push	edx
	mov	edx, DWORD PTR _web+616
	push	edx
	mov	edx, DWORD PTR [edi+8]
	push	edx
	mov	edx, DWORD PTR _temp_mat2$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_mat_mult

; 3351 :         oo = temp_mat2;

	mov	ecx, DWORD PTR _temp_mat2$[ebp]
	add	esp, 24					; 00000018H
$LN15@m_fill_mix:

; 3352 :      }
; 3353 :   if ( v1->rownum < v2->rownum )

	mov	eax, DWORD PTR [edi+12]

; 3354 :   for ( j = 0 ; j < v1->freedom ; j++ )

	mov	DWORD PTR _j$[ebp], ebx
	cmp	eax, DWORD PTR [esi+12]
	jge	$LN14@m_fill_mix
	cmp	DWORD PTR [edi+8], ebx
	jle	$LN4@m_fill_mix
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR tv360[ebp], ecx
$LL30@m_fill_mix:

; 3355 :     for ( k = 0 ; k < v2->freedom ; k++ )

	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN12@m_fill_mix
	npad	7
$LL31@m_fill_mix:

; 3356 :       m_hess_hash_search(v2->rownum+k,v1->rownum+j,oo[j][k],tid);

	mov	ecx, DWORD PTR _tid$[ebp]
	mov	edx, DWORD PTR tv360[ebp]
	mov	eax, DWORD PTR [edx]
	fld	QWORD PTR [eax+ebx*8]
	mov	edx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR [edi+12]
	add	ecx, DWORD PTR _j$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	add	edx, ebx
	push	edx
	call	_m_hess_hash_search
	mov	eax, DWORD PTR [esi+8]
	inc	ebx
	add	esp, 20					; 00000014H
	cmp	ebx, eax
	jl	SHORT $LL31@m_fill_mix
$LN12@m_fill_mix:

; 3354 :   for ( j = 0 ; j < v1->freedom ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	add	DWORD PTR tv360[ebp], 4
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+8]
	jl	SHORT $LL30@m_fill_mix
	pop	edi
	pop	esi
	pop	ebx

; 3361 : } // end m_fill_mixed_entry()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@m_fill_mix:

; 3357 :   else
; 3358 :   for ( j = 0 ; j < v1->freedom ; j++ )

	cmp	DWORD PTR [edi+8], ebx
	jle	SHORT $LN4@m_fill_mix
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR tv382[ebp], ecx
	npad	3
$LL28@m_fill_mix:

; 3359 :     for ( k = 0 ; k < v2->freedom ; k++ )

	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN5@m_fill_mix
	npad	10
$LL29@m_fill_mix:

; 3360 :       m_hess_hash_search(v1->rownum+j,v2->rownum+k,oo[j][k],tid);

	mov	eax, DWORD PTR _tid$[ebp]
	mov	ecx, DWORD PTR tv382[ebp]
	mov	edx, DWORD PTR [ecx]
	fld	QWORD PTR [edx+ebx*8]
	mov	ecx, DWORD PTR [edi+12]
	add	ecx, DWORD PTR _j$[ebp]
	push	eax
	mov	eax, DWORD PTR [esi+12]
	sub	esp, 8
	add	eax, ebx
	fstp	QWORD PTR [esp]
	push	eax
	push	ecx
	call	_m_hess_hash_search
	mov	eax, DWORD PTR [esi+8]
	inc	ebx
	add	esp, 20					; 00000014H
	cmp	ebx, eax
	jl	SHORT $LL29@m_fill_mix
$LN5@m_fill_mix:

; 3357 :   else
; 3358 :   for ( j = 0 ; j < v1->freedom ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	add	DWORD PTR tv382[ebp], 4
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+8]
	jl	SHORT $LL28@m_fill_mix
$LN4@m_fill_mix:

; 3361 : } // end m_fill_mixed_entry()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_m_fill_mixed_entry ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@HKFKMCH@m_hash_extraprobes?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CL@MJEKGECE@m_hashcount?$FL?$CFd?$FN?3?5?$CFd?5?5m_table_siz@ ; `string'
PUBLIC	_m_fix_hess
EXTRN	_sp_hash_search:PROC
;	COMDAT ??_C@_0BI@HKFKMCH@m_hash_extraprobes?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BI@HKFKMCH@m_hash_extraprobes?3?5?$CFd?6?$AA@ DB 'm_hash_extraprob'
	DB	'es: %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MJEKGECE@m_hashcount?$FL?$CFd?$FN?3?5?$CFd?5?5m_table_siz@
CONST	SEGMENT
??_C@_0CL@MJEKGECE@m_hashcount?$FL?$CFd?$FN?3?5?$CFd?5?5m_table_siz@ DB 'm'
	DB	'_hashcount[%d]: %d  m_table_size[%d]: %d', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _m_fix_hess
_TEXT	SEGMENT
_S$ = 8							; size = 4
_m_fix_hess PROC					; COMDAT

; 3372 : { int p,i;

	push	ebp
	mov	ebp, esp
	push	edi

; 3373 : 
; 3374 :   for ( p = 0 ; p < nprocs ; p++ )

	xor	edi, edi
	cmp	DWORD PTR _nprocs, edi
	jle	$LN16@m_fix_hess
	push	ebx
	push	esi
	npad	12
$LL17@m_fix_hess:

; 3375 :   { struct hess_entry *e;
; 3376 :      int end = m_table_size[p];

	mov	eax, DWORD PTR _m_table_size[edi*4]

; 3377 :      for ( i = 0, e = m_hashtable[p] ; i < end ; i++,e++ )

	mov	esi, DWORD PTR _m_hashtable[edi*4]
	test	eax, eax
	jle	SHORT $LN4@m_fix_hess

; 3375 :   { struct hess_entry *e;
; 3376 :      int end = m_table_size[p];

	mov	ebx, eax
$LL6@m_fix_hess:

; 3378 :         if ( e->row != HASHEMPTY )

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, -1
	je	SHORT $LN5@m_fix_hess

; 3379 :           sp_hash_search(S,e->row,e->col,e->value);

	fld	QWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _S$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	push	eax
	push	edx
	call	_sp_hash_search
	add	esp, 20					; 00000014H
$LN5@m_fix_hess:

; 3377 :      for ( i = 0, e = m_hashtable[p] ; i < end ; i++,e++ )

	add	esi, 16					; 00000010H
	dec	ebx
	jne	SHORT $LL6@m_fix_hess
$LN4@m_fix_hess:

; 3380 :      myfree((char*)(m_hashtable[p]));  m_hashtable[p] = NULL;

	mov	eax, DWORD PTR _m_hashtable[edi*4]
	push	eax
	call	_myfree

; 3381 :      m_hash_per_row[p] = 1 + (5*m_hashcount[p])/(4*SDIM*web.skel[VERTEX].max_ord);

	mov	esi, DWORD PTR _web+68
	imul	esi, DWORD PTR _web+616
	mov	ecx, DWORD PTR _m_hashcount[edi*4]
	add	esi, esi
	lea	eax, DWORD PTR [ecx+ecx*4]
	cdq
	add	esi, esi
	idiv	esi
	add	esp, 4
	mov	DWORD PTR _m_hashtable[edi*4], 0
	inc	eax

; 3382 :        /* for next time */
; 3383 : 
; 3384 :      if ( !hessian_quiet_flag )

	cmp	DWORD PTR _hessian_quiet_flag, 0
	mov	DWORD PTR _m_hash_per_row[edi*4], eax
	jne	SHORT $LN8@m_fix_hess

; 3385 :      { sprintf(msg,"m_hashcount[%d]: %d  m_table_size[%d]: %d\n",
; 3386 :           p,m_hashcount[p],p,m_table_size[p]);

	mov	edx, DWORD PTR _m_table_size[edi*4]
	mov	eax, DWORD PTR _msg
	push	edx
	push	edi
	push	ecx
	push	edi
	push	OFFSET ??_C@_0CL@MJEKGECE@m_hashcount?$FL?$CFd?$FN?3?5?$CFd?5?5m_table_siz@
	push	eax
	call	_sprintf

; 3387 :         outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 28					; 0000001cH
$LN8@m_fix_hess:

; 3373 : 
; 3374 :   for ( p = 0 ; p < nprocs ; p++ )

	inc	edi
	cmp	edi, DWORD PTR _nprocs
	jl	$LL17@m_fix_hess
	pop	esi
	pop	ebx
$LN16@m_fix_hess:

; 3388 :      }
; 3389 :   }
; 3390 :   if ( !hessian_quiet_flag )

	cmp	DWORD PTR _hessian_quiet_flag, 0
	pop	edi
	jne	SHORT $LN1@m_fix_hess

; 3391 :   { sprintf(msg,"m_hash_extraprobes: %d\n",m_hash_extraprobes);

	mov	edx, DWORD PTR _m_hash_extraprobes
	mov	eax, DWORD PTR _msg
	push	edx
	push	OFFSET ??_C@_0BI@HKFKMCH@m_hash_extraprobes?3?5?$CFd?6?$AA@
	push	eax
	call	_sprintf

; 3392 :      outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
$LN1@m_fix_hess:

; 3393 :   }
; 3394 : } // end m_fix_hess()

	pop	ebp
	ret	0
_m_fix_hess ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EO@IKGBOHPA@Vertex?5?$CFs?5does?5not?5have?5a?5comple@ ; `string'
PUBLIC	??_C@_0DJ@IKLNNJDK@quantity_setup?3?5More?5than?5?$CFd?5ver@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	__$ArrayPad$
EXTRN	_get_edge_side:PROC
EXTRN	_sym_compose:DWORD
EXTRN	_elnames:BYTE
EXTRN	_marked_edge_attr:DWORD
EXTRN	_sym_wrap:DWORD
;	COMDAT ??_C@_0EO@IKGBOHPA@Vertex?5?$CFs?5does?5not?5have?5a?5comple@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EO@IKGBOHPA@Vertex?5?$CFs?5does?5not?5have?5a?5comple@ DB 'Vertex '
	DB	'%s does not have a complete star (as needed by some method in'
	DB	'stance).', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@IKLNNJDK@quantity_setup?3?5More?5than?5?$CFd?5ver@
CONST	SEGMENT
??_C@_0DJ@IKLNNJDK@quantity_setup?3?5More?5than?5?$CFd?5ver@ DB 'quantity'
	DB	'_setup: More than %d vertices around vertex %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\quantity.c
CONST	ENDS
;	COMDAT _q_vertex_setup
_TEXT	SEGMENT
tv1734 = -448						; size = 8
tv2757 = -444						; size = 4
tv1793 = -444						; size = 4
tv1636 = -444						; size = 4
tv1909 = -440						; size = 4
tv1633 = -440						; size = 4
_wrap0$91366 = -436					; size = 4
_startfe$91348 = -436					; size = 4
_starte$91317 = -436					; size = 4
tv2383 = -432						; size = 4
tv1912 = -432						; size = 4
_fa$91363 = -432					; size = 4
tv2303 = -428						; size = 4
_k$91351 = -428						; size = 4
tv1742 = -424						; size = 4
tv1507 = -424						; size = 4
_next_fe$91364 = -424					; size = 4
tv2741 = -420						; size = 4
_wrap$91365 = -420					; size = 4
_i$ = -420						; size = 4
_e_id$91318 = -416					; size = 400
_e_id$91297 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_v_info$ = 12						; size = 4
_needs$ = 16						; size = 4
_q_vertex_setup PROC					; COMDAT

; 3409 : { /* struct vertex *v_ptr = (struct vertex *)elptr(v_info->id); */

	push	ebp
	mov	ebp, esp
	sub	esp, 448				; 000001c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3410 :   int i,j;
; 3411 :   vertex_id q_id;
; 3412 : 
; 3413 :   /* W A R N I N G */
; 3414 :   /* Be sure to place all data consistently for all methods !!! */
; 3415 :   v_info->S = S;

	mov	eax, DWORD PTR _S$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _v_info$[ebp]
	mov	DWORD PTR [esi+1348], eax

; 3416 :   q_id = v_info->id;

	mov	eax, DWORD PTR [esi]

; 3417 :   v_info->vcount = 1;
; 3418 :   v_info->v[0] = v_info->id;

	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+12], 1

; 3419 :   v_info->x[0] = get_coord(v_info->v[0]);

	mov	ecx, DWORD PTR _web+12
	mov	DWORD PTR tv1507[ebp], eax
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR tv1636[ebp], eax
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+ecx+64]

; 3420 :   if ( needs & NEED_WINGS ) /* pair of adjacent vertices */

	test	BYTE PTR _needs$[ebp], 64		; 00000040H
	push	edi
	mov	DWORD PTR [esi+416], edx
	je	$LN182@q_vertex_s

; 3421 :   { facetedge_id right_fe;
; 3422 :     edge_id e_id[3];
; 3423 :     right_fe = get_vertex_fe(v_info->id);

	mov	edx, DWORD PTR tv1507[ebp]
	push	edx
	call	_get_vertex_fe
	add	esp, 4

; 3424 :     if ( !valid_id(right_fe) ) goto vset_exit;

	test	eax, 268435456				; 10000000H
	je	$vset_exit$91300

; 3425 :     v_info->vcount++; 
; 3426 :     v_info->v[1] = get_fe_headv(right_fe);

	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	DWORD PTR [esi+12], 2
	mov	edi, eax
	mov	eax, DWORD PTR _web+460
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+eax]
	mov	edx, DWORD PTR [ecx+20]
	and	edi, 134217728				; 08000000H
	xor	edx, edi
	push	edx
	call	_get_edge_headv
	mov	DWORD PTR [esi+20], eax

; 3427 :     e_id[1] = get_fe_edge(right_fe);

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx+20]
	xor	eax, edi

; 3428 :     e_id[2] = get_next_tail_edge(e_id[1]);

	mov	edi, DWORD PTR _web+124
	mov	edx, eax
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	ecx, DWORD PTR [ecx+edx*4+32]
	add	esp, 4
	mov	DWORD PTR _e_id$91297[ebp+4], eax
	mov	DWORD PTR _e_id$91297[ebp+8], ecx

; 3429 :     /* get incoming first, outgoing second, if possible */
; 3430 :     if ( positive_id(e_id[1]) && !positive_id(e_id[2]) )

	test	eax, -134217729				; f7ffffffH
	je	SHORT $LN50@q_vertex_s
	test	ecx, -134217729				; f7ffffffH
	jne	SHORT $LN50@q_vertex_s

; 3431 :     { edge_id etmp = e_id[1];

	mov	edx, eax

; 3432 :       e_id[1] = e_id[2];

	mov	eax, ecx

; 3433 :       e_id[2] = etmp;

	mov	ecx, edx
	mov	DWORD PTR _e_id$91297[ebp+4], eax
	mov	DWORD PTR _e_id$91297[ebp+8], ecx
$LN50@q_vertex_s:

; 3434 :     }
; 3435 :     if ( !equal_id(e_id[1],e_id[2]) ) 

	cmp	eax, ecx
	je	SHORT $LN49@q_vertex_s

; 3436 :     { v_info->vcount++; 
; 3437 :       v_info->v[2] = get_edge_headv(e_id[2]);

	push	ecx
	mov	DWORD PTR [esi+12], 3
	call	_get_edge_headv
	add	esp, 4
	mov	DWORD PTR [esi+24], eax
$LN49@q_vertex_s:

; 3438 :     }
; 3439 : 
; 3440 :     for ( i = 1 ; i < v_info->vcount ; i++ )

	mov	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR [esi+12], eax
	jle	$LN182@q_vertex_s
	mov	ecx, -416				; fffffe60H
	sub	ecx, esi
	lea	ebx, DWORD PTR [esi+420]
	mov	DWORD PTR tv2303[ebp], ecx
	npad	2
$LL48@q_vertex_s:

; 3441 :     {
; 3442 :       v_info->x[i] = get_coord(v_info->v[i]);

	mov	edx, DWORD PTR [ebx-400]
	mov	eax, DWORD PTR _web+12
	mov	edi, DWORD PTR _dymem
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+edi+64]
	mov	DWORD PTR [ebx], edx

; 3443 :       if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN187@q_vertex_s

; 3444 :       { (*sym_wrap)(v_info->x[i],v_info->xx[i],get_edge_wrap(e_id[i]));

	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _e_id$91297[ebp+ecx*4]
	mov	ecx, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edi+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN69@q_vertex_s
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN70@q_vertex_s
$LN69@q_vertex_s:
	mov	eax, ecx
$LN70@q_vertex_s:
	mov	edi, DWORD PTR tv2303[ebp]
	mov	edx, DWORD PTR [ebx]
	push	eax
	mov	eax, DWORD PTR [esi+1216]
	add	edi, ebx
	mov	ecx, DWORD PTR [eax+edi]
	push	ecx
	push	edx
	call	DWORD PTR _sym_wrap

; 3445 :          v_info->x[i] = v_info->xx[i];

	mov	eax, DWORD PTR [esi+1216]
	mov	ecx, DWORD PTR [edi+eax]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR tv2303[ebp]
	add	esp, 12					; 0000000cH
$LN187@q_vertex_s:

; 3446 :       }
; 3447 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN47@q_vertex_s
	npad	2
$LL44@q_vertex_s:

; 3448 :          v_info->sides[0][i-1][j] = v_info->x[i][j] - v_info->x[0][j];

	mov	edx, DWORD PTR [ebx]
	fld	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [esi+1276]
	mov	edi, DWORD PTR [esi+416]
	mov	edx, DWORD PTR [edx]
	fsub	QWORD PTR [edi+eax*8]
	add	edx, ecx
	mov	edx, DWORD PTR [edx+ebx-4]
	fstp	QWORD PTR [edx+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL44@q_vertex_s
$LN47@q_vertex_s:

; 3438 :     }
; 3439 : 
; 3440 :     for ( i = 1 ; i < v_info->vcount ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	ebx, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [esi+12]
	jl	$LL48@q_vertex_s
$LN182@q_vertex_s:

; 3449 :     }
; 3450 :   }
; 3451 : 
; 3452 :    if ( needs & NEED_MARKED_WINGS ) 

	mov	eax, DWORD PTR _needs$[ebp]
	and	eax, 1024				; 00000400H
	mov	DWORD PTR tv1633[ebp], eax
	je	$LN32@q_vertex_s

; 3453 :      { /* pair of marked edge vertices 
; 3454 :           for sqcurve_string_marked */
; 3455 :         edge_id thise,starte;
; 3456 :         edge_id e_id[MAXVCOUNT];
; 3457 :         memset(v_info->marked,0,sizeof(v_info->marked));

	push	400					; 00000190H
	lea	edi, DWORD PTR [esi+1352]
	push	0
	push	edi
	call	_memset

; 3458 :         starte = get_vertex_edge(v_info->id);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _web+12
	add	esp, 12					; 0000000cH
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [edx+28]
	mov	edx, DWORD PTR _web+124
	mov	DWORD PTR _starte$91317[ebp], ecx

; 3459 :         i = 1;

	mov	DWORD PTR _i$[ebp], 1
	mov	DWORD PTR tv2383[ebp], edi
	npad	6
$LL40@q_vertex_s:

; 3460 :         thise = starte;
; 3461 :         do
; 3462 :         {
; 3463 :           if ( !valid_id(thise) ) goto vset_exit;

	test	ecx, 268435456				; 10000000H
	je	$vset_exit$91300

; 3464 :           if ( (marked_edge_attr>0) && *EINT(thise,marked_edge_attr) )

	mov	edi, DWORD PTR _marked_edge_attr
	test	edi, edi
	jle	$LN186@q_vertex_s
	mov	ebx, DWORD PTR _dymem
	imul	edi, 240				; 000000f0H
	add	edi, DWORD PTR _web+216
	mov	eax, ecx
	mov	edi, DWORD PTR [edi+ebx+64]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ebx, DWORD PTR [eax+edx]
	cmp	DWORD PTR [edi+ebx], 0
	je	$LN186@q_vertex_s

; 3465 :           {
; 3466 :             e_id[i] = thise;
; 3467 :             v_info->vcount++; 

	inc	DWORD PTR [esi+12]
	mov	edx, DWORD PTR _i$[ebp]

; 3468 :             v_info->v[i] = get_edge_headv(e_id[i]);

	mov	edi, DWORD PTR _web+216
	mov	ebx, DWORD PTR _dymem
	mov	DWORD PTR _e_id$91318[ebp+edx*4], ecx
	mov	edx, DWORD PTR _web+124
	mov	edx, DWORD PTR [eax+edx]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN72@q_vertex_s
	mov	edi, DWORD PTR [edi+ebx+304]
	mov	edi, DWORD PTR [edx+edi]
	jmp	SHORT $LN71@q_vertex_s
$LN72@q_vertex_s:
	add	edx, DWORD PTR [edi+ebx+304]
	mov	edi, DWORD PTR _web+636
	mov	edi, DWORD PTR [edx+edi*4]
$LN71@q_vertex_s:
	mov	edx, DWORD PTR tv2383[ebp]
	mov	DWORD PTR [edx-1332], edi

; 3469 :             v_info->marked[i-1] = *EINT(thise,marked_edge_attr);

	mov	edi, DWORD PTR _marked_edge_attr
	mov	ebx, DWORD PTR _dymem
	imul	edi, 240				; 000000f0H
	add	edi, DWORD PTR _web+216

; 3470 :             i++;

	add	edx, 4
	mov	edi, DWORD PTR [edi+ebx+64]
	mov	ebx, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+ebx]
	mov	eax, DWORD PTR [edi+eax]
	mov	DWORD PTR [edx-4], eax
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR tv2383[ebp], edx

; 3471 :             if ( i >= MAXVCOUNT ) break;

	cmp	eax, 100				; 00000064H
	jge	SHORT $LN38@q_vertex_s
	mov	edx, DWORD PTR _web+124
$LN186@q_vertex_s:

; 3472 :           }
; 3473 :           thise = get_next_tail_edge(thise);

	mov	eax, ecx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	ecx, DWORD PTR [ecx+eax*4+32]

; 3474 :         } while ( !equal_id(thise,starte) );

	cmp	ecx, DWORD PTR _starte$91317[ebp]
	jne	$LL40@q_vertex_s
$LN38@q_vertex_s:

; 3475 : 
; 3476 :         for ( i = 1 ; i < v_info->vcount ; i++ )

	cmp	DWORD PTR [esi+12], 1
	mov	DWORD PTR _i$[ebp], 1
	jle	$LN32@q_vertex_s
	mov	eax, -416				; fffffe60H
	sub	eax, esi
	lea	ebx, DWORD PTR [esi+420]
	mov	DWORD PTR tv2303[ebp], eax
	mov	ecx, eax
$LL175@q_vertex_s:

; 3477 :         {
; 3478 :           v_info->x[i] = get_coord(v_info->v[i]);

	mov	edx, DWORD PTR [ebx-400]
	mov	eax, DWORD PTR _web+12
	mov	edi, DWORD PTR _dymem
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+edi+64]
	mov	DWORD PTR [ebx], edx

; 3479 :           if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN188@q_vertex_s

; 3480 :           { (*sym_wrap)(v_info->x[i],v_info->xx[i],get_edge_wrap(e_id[i]));

	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _e_id$91318[ebp+ecx*4]
	mov	ecx, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edi+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN79@q_vertex_s
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN80@q_vertex_s
$LN79@q_vertex_s:
	mov	eax, ecx
$LN80@q_vertex_s:
	mov	edx, DWORD PTR tv2303[ebp]
	push	eax
	mov	eax, DWORD PTR [esi+1216]
	lea	edi, DWORD PTR [ebx+edx]
	mov	ecx, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [ebx]
	push	ecx
	push	edx
	call	DWORD PTR _sym_wrap

; 3481 :              v_info->x[i] = v_info->xx[i];

	mov	eax, DWORD PTR [esi+1216]
	mov	ecx, DWORD PTR [edi+eax]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR tv2303[ebp]
	add	esp, 12					; 0000000cH
$LN188@q_vertex_s:

; 3482 :           }
; 3483 :           for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN33@q_vertex_s
$LL30@q_vertex_s:

; 3484 :              v_info->sides[0][i-1][j] = v_info->x[i][j] - v_info->x[0][j];

	mov	edx, DWORD PTR [ebx]
	fld	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [esi+1276]
	mov	edi, DWORD PTR [esi+416]
	mov	edx, DWORD PTR [edx]
	fsub	QWORD PTR [edi+eax*8]
	add	edx, ebx
	mov	edx, DWORD PTR [edx+ecx-4]
	fstp	QWORD PTR [edx+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL30@q_vertex_s
$LN33@q_vertex_s:

; 3475 : 
; 3476 :         for ( i = 1 ; i < v_info->vcount ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	ebx, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [esi+12]
	jl	$LL175@q_vertex_s
$LN32@q_vertex_s:

; 3485 :         }
; 3486 :      }
; 3487 :   if ( needs & (NEED_FULL_STAR|NEED_PART_STAR) )  /* ring of facets */

	test	DWORD PTR _needs$[ebp], 6144		; 00001800H
	je	$vset_exit$91300

; 3488 :   { facetedge_id fe,startfe,next_fe;
; 3489 :      edge_id e_id;
; 3490 :      int k=0;
; 3491 :      v_info->vcount = 1;
; 3492 :      if ( get_vattr(q_id) & BARE_NAKED ) goto nostar;

	mov	edx, DWORD PTR tv1636[ebp]
	mov	DWORD PTR [esi+12], 1
	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv1734[ebp+4], eax
	mov	eax, edi
	xor	ecx, ecx
	and	eax, 65536				; 00010000H
	or	eax, ecx
	mov	DWORD PTR _k$91351[ebp], ecx
	jne	$vset_exit$91300

; 3493 :      fe = get_vertex_fe(q_id);

	mov	ecx, DWORD PTR tv1507[ebp]
	push	ecx
	call	_get_vertex_fe
	mov	ebx, eax
	add	esp, 4

; 3494 :      if ( !valid_id(fe) ) goto nostar;

	test	ebx, 268435456				; 10000000H
	je	$vset_exit$91300

; 3495 :      if ( inverted(get_fe_facet(fe)) ) 

	mov	eax, DWORD PTR _web+460
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, ebx
	shr	eax, 27					; 0000001bH
	and	eax, 1
	je	SHORT $LN178@q_vertex_s
	xor	edx, 134217728				; 08000000H
$LN178@q_vertex_s:
	test	edx, 134217728				; 08000000H
	je	SHORT $LN185@q_vertex_s

; 3496 :           fe = inverse_id(get_prev_edge(fe));

	test	eax, eax
	je	SHORT $LN86@q_vertex_s
	mov	ebx, DWORD PTR [ecx+32]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN85@q_vertex_s
$LN86@q_vertex_s:
	mov	ebx, DWORD PTR [ecx+28]
$LN85@q_vertex_s:
	xor	ebx, 134217728				; 08000000H
$LN185@q_vertex_s:

; 3497 :      startfe = fe;
; 3498 :      if ( get_vattr(q_id) & AXIAL_POINT )

	and	edi, 8388608				; 00800000H
	mov	eax, edi
	xor	ecx, ecx
	or	eax, ecx
	mov	edx, ebx
	mov	DWORD PTR _startfe$91348[ebp], edx
	je	$LN23@q_vertex_s

; 3499 :      { /* want to walk around outside ring */
; 3500 :         facetedge_id fa,next_fe;
; 3501 :         WRAPTYPE wrap = get_fe_wrap(fe);

	mov	ecx, DWORD PTR _web+460
	mov	edi, DWORD PTR _dymem
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv1742[ebp], eax
	mov	eax, ebx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+edi+784]
	mov	ecx, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN93@q_vertex_s
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	mov	DWORD PTR _wrap$91365[ebp], eax
	jmp	SHORT $LN94@q_vertex_s
$LN93@q_vertex_s:
	mov	DWORD PTR _wrap$91365[ebp], ecx
$LN94@q_vertex_s:

; 3502 :         WRAPTYPE wrap0 = wrap;

	mov	eax, DWORD PTR _wrap$91365[ebp]

; 3503 :         REAL *y;
; 3504 :         v_info->axial_order = 0;
; 3505 :         next_fe = fa = get_next_edge(fe);

	mov	edx, DWORD PTR tv1742[ebp]
	mov	DWORD PTR [esi+1344], 0
	mov	ecx, DWORD PTR _web+460
	mov	DWORD PTR _wrap0$91366[ebp], eax
	mov	eax, DWORD PTR [edx+ecx]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN96@q_vertex_s
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _fa$91363[ebp], eax
	mov	DWORD PTR _next_fe$91364[ebp], eax

; 3526 :         } while ( (next_fe != fa) || (*sym_compose)((*sym_inverse)(wrap),wrap0));

	jmp	SHORT $LN183@q_vertex_s

; 3503 :         REAL *y;
; 3504 :         v_info->axial_order = 0;
; 3505 :         next_fe = fa = get_next_edge(fe);

$LN96@q_vertex_s:
	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR _fa$91363[ebp], eax
	mov	DWORD PTR _next_fe$91364[ebp], eax

; 3526 :         } while ( (next_fe != fa) || (*sym_compose)((*sym_inverse)(wrap),wrap0));

	jmp	SHORT $LN183@q_vertex_s
$LL176@q_vertex_s:
	mov	ecx, DWORD PTR _web+460
$LN183@q_vertex_s:

; 3506 :         do
; 3507 :         { v_info->v[k+1] = get_fe_tailv(next_fe);

	mov	edx, DWORD PTR _next_fe$91364[ebp]

; 3526 :         } while ( (next_fe != fa) || (*sym_compose)((*sym_inverse)(wrap),wrap0));

	mov	edi, DWORD PTR _k$91351[ebp]
	mov	ebx, edx
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+216
	and	edx, 134217728				; 08000000H
	xor	eax, edx
	mov	DWORD PTR tv1793[ebp], edx
	mov	edx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN102@q_vertex_s

; 3506 :         do
; 3507 :         { v_info->v[k+1] = get_fe_tailv(next_fe);

	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+304]
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN101@q_vertex_s
$LN102@q_vertex_s:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	eax, DWORD PTR [eax+ecx]
$LN101@q_vertex_s:

; 3508 :           v_info->wraps[k+1] = wrap;

	mov	ecx, DWORD PTR _wrap$91365[ebp]
	mov	DWORD PTR [esi+edi*4+20], eax
	mov	DWORD PTR [esi+edi*4+820], ecx

; 3509 :           y = get_coord(v_info->v[k+1]);
; 3510 :           (*sym_wrap)(y,v_info->sides[0][k],wrap);

	mov	edx, DWORD PTR [esi+1276]
	push	ecx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR _web+12
	push	edx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+64]
	push	edx
	call	DWORD PTR _sym_wrap

; 3511 :           for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN184@q_vertex_s
	npad	1
$LL19@q_vertex_s:

; 3512 :               v_info->sides[0][k][j] -= v_info->x[0][j];

	mov	edx, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx+edi*4]
	fld	QWORD PTR [edx+eax*8]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [esi+416]
	fsub	QWORD PTR [edx+eax*8]
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL19@q_vertex_s
$LN184@q_vertex_s:

; 3513 :           v_info->vcount++;

	inc	DWORD PTR [esi+12]

; 3514 :           k++;

	inc	edi
	mov	DWORD PTR _k$91351[ebp], edi

; 3515 :           if ( k >= MAXVCOUNT-1 )

	cmp	edi, 99					; 00000063H
	jl	SHORT $LN16@q_vertex_s

; 3516 :           { sprintf(errmsg,
; 3517 :               "quantity_setup: More than %d vertices around vertex %s.\n",
; 3518 :                   MAXVCOUNT-1, ELNAME(v_info->id));

	mov	eax, DWORD PTR [esi]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN55@q_vertex_s
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN56@q_vertex_s
$LN55@q_vertex_s:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN56@q_vertex_s:
	push	eax
	push	99					; 00000063H
	push	OFFSET ??_C@_0DJ@IKLNNJDK@quantity_setup?3?5More?5than?5?$CFd?5ver@
	push	OFFSET _errmsg
	call	_sprintf

; 3519 :             kb_error(1337,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1337					; 00000539H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN16@q_vertex_s:

; 3520 :           }
; 3521 :           wrap = (*sym_compose)(wrap,get_fe_wrap(next_fe));

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx+20]
	xor	eax, DWORD PTR tv1793[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edi+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN109@q_vertex_s
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN110@q_vertex_s
$LN109@q_vertex_s:
	mov	eax, ecx
$LN110@q_vertex_s:
	mov	edx, DWORD PTR _wrap$91365[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose

; 3522 :           next_fe = get_next_edge(next_fe);

	mov	ecx, DWORD PTR _web+460
	mov	edx, eax
	mov	eax, DWORD PTR [ebx+ecx]
	add	esp, 8
	test	DWORD PTR _next_fe$91364[ebp], 134217728 ; 08000000H
	mov	DWORD PTR _wrap$91365[ebp], edx
	je	SHORT $LN112@q_vertex_s
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN111@q_vertex_s
$LN112@q_vertex_s:
	mov	eax, DWORD PTR [eax+32]
$LN111@q_vertex_s:

; 3523 :           next_fe = inverse_id(get_next_facet(next_fe));

	test	eax, 134217728				; 08000000H
	je	SHORT $LN116@q_vertex_s
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN115@q_vertex_s
$LN116@q_vertex_s:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+40]
$LN115@q_vertex_s:
	xor	eax, 134217728				; 08000000H

; 3524 :           next_fe = get_next_edge(next_fe);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN120@q_vertex_s
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN193@q_vertex_s
$LN120@q_vertex_s:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+32]
$LN193@q_vertex_s:
	mov	DWORD PTR _next_fe$91364[ebp], eax

; 3525 :           if ( next_fe == fa ) v_info->axial_order++;

	cmp	eax, DWORD PTR _fa$91363[ebp]
	jne	$LN183@q_vertex_s

; 3526 :         } while ( (next_fe != fa) || (*sym_compose)((*sym_inverse)(wrap),wrap0));

	mov	ecx, DWORD PTR _wrap0$91366[ebp]
	inc	DWORD PTR [esi+1344]
	push	ecx
	push	edx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	push	eax
	call	DWORD PTR _sym_compose
	add	esp, 8
	test	eax, eax
	jne	$LL176@q_vertex_s

; 3527 :         v_info->flags &= ~INCOMPLETE_STAR;

	and	DWORD PTR [esi+4], -2			; fffffffeH
	pop	edi
	pop	esi
	pop	ebx

; 3577 :      }
; 3578 : nostar: ;
; 3579 :   }
; 3580 : vset_exit: ; 
; 3581 : } // end q_vertex_setup()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@q_vertex_s:

; 3528 : 
; 3529 :      }
; 3530 :      else
; 3531 :      { /* normal vertex star */
; 3532 :        /* first, see if we have partial star, and if so, start at one end */
; 3533 :        fe = startfe;
; 3534 :        v_info->flags &= ~INCOMPLETE_STAR;

	and	DWORD PTR [esi+4], -2			; fffffffeH
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _web+460
	npad	6
$LL13@q_vertex_s:

; 3535 :        do
; 3536 :        { next_fe = get_next_facet(fe);

	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN124@q_vertex_s
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN123@q_vertex_s
$LN124@q_vertex_s:
	mov	eax, DWORD PTR [eax+40]
$LN123@q_vertex_s:

; 3537 :          if ( equal_id(next_fe,fe) )

	cmp	eax, ebx
	je	SHORT $LN165@q_vertex_s

; 3544 :            }
; 3545 :            break;
; 3546 :          }
; 3547 :          fe = inverse_id(get_prev_edge(next_fe)); 

	test	eax, 134217728				; 08000000H
	je	SHORT $LN128@q_vertex_s
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ebx, DWORD PTR [eax+32]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN127@q_vertex_s
$LN128@q_vertex_s:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ebx, DWORD PTR [eax+28]
$LN127@q_vertex_s:
	xor	ebx, 134217728				; 08000000H

; 3548 :        } 
; 3549 :        while ( !equal_id(fe,startfe) );

	cmp	ebx, edx
	jne	SHORT $LL13@q_vertex_s
	jmp	SHORT $LN11@q_vertex_s
$LN165@q_vertex_s:

; 3538 :          { /* have end of star */
; 3539 :            startfe = fe;
; 3540 :            v_info->flags |= INCOMPLETE_STAR;

	or	edi, 1

; 3541 :            if ( needs & NEED_FULL_STAR )

	test	DWORD PTR _needs$[ebp], 4096		; 00001000H
	mov	DWORD PTR _startfe$91348[ebp], ebx
	mov	DWORD PTR [esi+4], edi
	je	SHORT $LN177@q_vertex_s

; 3542 :            { sprintf(errmsg,"Vertex %s does not have a complete star (as needed by some method instance).\n",ELNAME(v_info->id));

	mov	eax, DWORD PTR [esi]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN57@q_vertex_s
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN58@q_vertex_s
$LN57@q_vertex_s:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN58@q_vertex_s:
	push	eax
	push	OFFSET ??_C@_0EO@IKGBOHPA@Vertex?5?$CFs?5does?5not?5have?5a?5comple@
	push	OFFSET _errmsg
	call	_sprintf

; 3543 :             kb_error(1573,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1573					; 00000625H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN177@q_vertex_s:
	mov	ecx, DWORD PTR _web+460
$LN11@q_vertex_s:

; 3550 : 
; 3551 :        /* now do the actual work */
; 3552 : 	   if ( needs & NEED_MARKED_WINGS )

	cmp	DWORD PTR tv1633[ebp], 0
	je	SHORT $LN173@q_vertex_s

; 3553 : 		 memset(v_info->marked,0,sizeof(v_info->marked));

	push	400					; 00000190H
	lea	ecx, DWORD PTR [esi+1352]
	push	0
	push	ecx
	call	_memset
	mov	ecx, DWORD PTR _web+460
	add	esp, 12					; 0000000cH
$LN173@q_vertex_s:

; 3562 :  
; 3563 :           v_info->vcount++;
; 3564 :           k++;

	mov	eax, -820				; fffffcccH
	lea	edx, DWORD PTR [esi+820]
	sub	eax, esi
	mov	DWORD PTR tv2741[ebp], edx
	mov	DWORD PTR tv2757[ebp], eax
	npad	1
$LL7@q_vertex_s:

; 3554 :        do 
; 3555 :        { 
; 3556 :           e_id = get_fe_edge(fe);

	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1742[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]

; 3557 :           v_info->v[k+1] = get_edge_headv(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edi, ebx
	and	edi, 134217728				; 08000000H
	xor	edi, DWORD PTR [eax+20]
	mov	eax, edi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv1909[ebp], eax
	mov	eax, edi
	je	SHORT $LN134@q_vertex_s
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR tv1912[ebp], eax
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]
	jmp	SHORT $LN133@q_vertex_s
$LN134@q_vertex_s:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR tv1912[ebp], eax
	mov	eax, DWORD PTR _web+216
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
$LN133@q_vertex_s:
	mov	ecx, DWORD PTR tv2741[ebp]
	mov	DWORD PTR [ecx-800], eax

; 3558 :           if(web.symmetry_flag) v_info->wraps[k+1] = get_edge_wrap(e_id);

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN4@q_vertex_s
	cmp	DWORD PTR tv1909[ebp], 0
	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR tv1912[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+784]
	mov	eax, DWORD PTR [ecx+edx]
	je	SHORT $LN139@q_vertex_s
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN139@q_vertex_s:
	mov	ecx, DWORD PTR tv2741[ebp]
	mov	DWORD PTR [ecx], eax
$LN4@q_vertex_s:

; 3559 :           get_edge_side(e_id,v_info->sides[0][k]);

	mov	edx, DWORD PTR [esi+1276]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR tv2757[ebp]
	mov	ecx, DWORD PTR tv2741[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	push	edi
	call	_get_edge_side

; 3560 : 		  if ( (marked_edge_attr>0) && *EINT(e_id,marked_edge_attr) )

	mov	eax, DWORD PTR _marked_edge_attr
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN179@q_vertex_s
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR tv1912[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	cmp	DWORD PTR [edx+eax], 0
	je	SHORT $LN179@q_vertex_s

; 3561 : 	        v_info->marked[k] = 1;

	mov	ecx, DWORD PTR tv2741[ebp]
	mov	DWORD PTR [ecx+532], 1
$LN179@q_vertex_s:

; 3562 :  
; 3563 :           v_info->vcount++;
; 3564 :           k++;

	mov	eax, DWORD PTR _k$91351[ebp]
	inc	DWORD PTR [esi+12]
	add	DWORD PTR tv2741[ebp], 4
	inc	eax
	mov	DWORD PTR _k$91351[ebp], eax

; 3565 :           if ( k >= MAXVCOUNT-1 )

	cmp	eax, 99					; 00000063H
	jl	SHORT $LN180@q_vertex_s

; 3566 :           { sprintf(errmsg,
; 3567 :               "quantity_setup: More than %d vertices around vertex %s.\n",
; 3568 :                  MAXVCOUNT-1, ELNAME(v_info->id));

	mov	eax, DWORD PTR [esi]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN59@q_vertex_s
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN60@q_vertex_s
$LN59@q_vertex_s:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN60@q_vertex_s:
	push	eax
	push	99					; 00000063H
	push	OFFSET ??_C@_0DJ@IKLNNJDK@quantity_setup?3?5More?5than?5?$CFd?5ver@
	push	OFFSET _errmsg
	call	_sprintf

; 3569 :                kb_error(1572,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1572					; 00000624H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN180@q_vertex_s:

; 3570 :           }
; 3571 :           if ( !equal_id(fe,startfe) && equal_id(fe,get_next_facet(fe)) )

	mov	edi, DWORD PTR _startfe$91348[ebp]
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR tv1742[ebp]
	cmp	ebx, edi
	je	SHORT $LN1@q_vertex_s
	mov	eax, DWORD PTR [edx+ecx]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN142@q_vertex_s
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN141@q_vertex_s
$LN142@q_vertex_s:
	mov	eax, DWORD PTR [eax+40]
$LN141@q_vertex_s:
	cmp	ebx, eax
	je	SHORT $vset_exit$91300
$LN1@q_vertex_s:

; 3572 :             break; /* found end of partial star */
; 3573 :           fe = get_prev_edge(fe);

	test	ebx, 134217728				; 08000000H
	je	SHORT $LN146@q_vertex_s
	mov	edx, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN145@q_vertex_s
$LN146@q_vertex_s:
	mov	eax, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [eax+28]
$LN145@q_vertex_s:

; 3574 :           next_fe = get_next_facet(fe);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN150@q_vertex_s
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ebx, DWORD PTR [edx+36]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN149@q_vertex_s
$LN150@q_vertex_s:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ebx, DWORD PTR [eax+40]
$LN149@q_vertex_s:

; 3575 :           fe = inverse_id(next_fe);

	xor	ebx, 134217728				; 08000000H

; 3576 :        } while ( !equal_id(fe,startfe) );

	cmp	ebx, edi
	jne	$LL7@q_vertex_s
$nostar$91355:
$vset_exit$91300:

; 3577 :      }
; 3578 : nostar: ;
; 3579 :   }
; 3580 : vset_exit: ; 
; 3581 : } // end q_vertex_setup()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_q_vertex_setup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EN@JADPALJA@Can?8t?5do?5quadratic?5model?5with?5ed@ ; `string'
PUBLIC	__real@0000000000000000
PUBLIC	_q_edge_setup_q
EXTRN	_gauss1poly:DWORD
EXTRN	_gauss1polyd:DWORD
EXTRN	_edge_ctrl:DWORD
EXTRN	_gauss1D_num:DWORD
;	COMDAT ??_C@_0EN@JADPALJA@Can?8t?5do?5quadratic?5model?5with?5ed@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EN@JADPALJA@Can?8t?5do?5quadratic?5model?5with?5ed@ DB 'Can''t do '
	DB	'quadratic model with edge WINGS (needed for some method insta'
	DB	'nce).', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\quantity.c
CONST	ENDS
;	COMDAT _q_edge_setup_q
_TEXT	SEGMENT
tv388 = -8						; size = 4
_j$ = -4						; size = 4
_e_info$ = 8						; size = 4
tv2111 = 12						; size = 4
_needs$ = 12						; size = 4
_q_edge_setup_q PROC					; COMDAT

; 3740 : { int i,j;

	push	ebp
	mov	ebp, esp

; 3741 : 
; 3742 :   /* W A R N I N G */
; 3743 :   /* Be sure to place all data consistently for all methods !!! */
; 3744 : 
; 3745 :   e_info->vcount = (web.representation == SIMPLEX) ? web.dimension : 3;

	mov	eax, 3
	sub	esp, 8
	cmp	DWORD PTR _web+624, eax
	jne	SHORT $LN27@q_edge_set
	mov	eax, DWORD PTR _web+620
$LN27@q_edge_set:
	push	ebx
	mov	ebx, DWORD PTR _e_info$[ebp]
	mov	DWORD PTR [ebx+12], eax

; 3746 :   e_info->v[0] = get_edge_tailv(e_info->id);

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	push	edi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN30@q_edge_set
	add	ecx, DWORD PTR [edx+esi+304]
	mov	edx, DWORD PTR _web+636
	mov	edx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN29@q_edge_set
$LN30@q_edge_set:
	mov	edx, DWORD PTR [edx+esi+304]
	mov	edx, DWORD PTR [ecx+edx]
$LN29@q_edge_set:
	mov	DWORD PTR [ebx+16], edx

; 3747 :   e_info->v[1] = get_edge_midv(e_info->id);

	mov	esi, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR _web+216
	mov	esi, DWORD PTR [esi+edi+304]
	mov	ecx, DWORD PTR [ecx+esi+8]
	mov	DWORD PTR [ebx+20], ecx

; 3748 :   e_info->v[2] = get_edge_headv(e_info->id);

	mov	esi, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR _web+216
	test	eax, 134217728				; 08000000H
	je	SHORT $LN34@q_edge_set
	mov	esi, DWORD PTR [esi+edi+304]
	mov	ecx, DWORD PTR [ecx+esi]
	jmp	SHORT $LN33@q_edge_set
$LN34@q_edge_set:
	add	ecx, DWORD PTR [esi+edi+304]
	mov	esi, DWORD PTR _web+636
	mov	ecx, DWORD PTR [ecx+esi*4]
$LN33@q_edge_set:
	mov	DWORD PTR [ebx+24], ecx

; 3749 :   e_info->x[0] = get_coord(e_info->v[0]);

	mov	esi, DWORD PTR _web+12
	mov	edi, DWORD PTR _dymem
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR _web+104
	add	edx, DWORD PTR [esi+edi+64]

; 3750 :   e_info->x[1] = get_coord(e_info->v[1]);
; 3751 :   e_info->x[2] = get_coord(e_info->v[2]);

	and	ecx, 134217727				; 07ffffffH
	mov	DWORD PTR [ebx+416], edx
	mov	esi, DWORD PTR _web+12
	mov	edx, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR _dymem
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR _web+104
	add	edx, DWORD PTR [esi+edi+64]
	mov	DWORD PTR [ebx+420], edx
	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+104
	mov	esi, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+esi+64]
	mov	DWORD PTR [ebx+424], ecx

; 3752 :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	$LN22@q_edge_set

; 3753 :   { WRAPTYPE wrap = get_edge_wrap(e_info->id);

	mov	edx, DWORD PTR _web+124
	mov	esi, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+esi+784]
	mov	esi, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN39@q_edge_set
	push	esi
	call	DWORD PTR _sym_inverse
	add	esp, 4
	mov	esi, eax
$LN39@q_edge_set:

; 3754 :     if ( inverted(e_info->id) )

	test	DWORD PTR [ebx], 134217728		; 08000000H

; 3755 :     { wrap = (*sym_inverse)(wrap);

	push	esi
	je	SHORT $LN23@q_edge_set
	call	DWORD PTR _sym_inverse

; 3756 :       (*sym_wrap)(e_info->x[0],e_info->xx[2],wrap);

	mov	edx, DWORD PTR [ebx+416]
	mov	esi, eax
	mov	eax, DWORD PTR [ebx+1216]
	mov	ecx, DWORD PTR [eax+8]
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR _sym_wrap

; 3757 :       e_info->x[0] = e_info->xx[2];

	mov	eax, DWORD PTR [ebx+1216]
	mov	ecx, DWORD PTR [eax+8]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ebx+416], ecx

; 3758 :       e_info->wraps[0] = wrap;

	mov	DWORD PTR [ebx+816], esi

; 3759 :     }
; 3760 :     else 

	jmp	SHORT $LN22@q_edge_set
$LN23@q_edge_set:

; 3761 :     {
; 3762 :       (*sym_wrap)(e_info->x[2],e_info->xx[2],wrap);

	mov	edx, DWORD PTR [ebx+1216]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [ebx+424]
	push	eax
	push	ecx
	call	DWORD PTR _sym_wrap

; 3763 :       e_info->x[2] = e_info->xx[2];

	mov	edx, DWORD PTR [ebx+1216]
	mov	eax, DWORD PTR [edx+8]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx+424], eax

; 3764 :       e_info->wraps[2] = wrap;

	mov	DWORD PTR [ebx+824], esi
$LN22@q_edge_set:

; 3765 :     } 
; 3766 :   }
; 3767 :   if ( needs & NEED_SIDE ) 

	test	BYTE PTR _needs$[ebp], 16		; 00000010H
	fldz
	je	$LN59@q_edge_set

; 3768 :   { /* tangent vectors at gauss points */
; 3769 :     int m;
; 3770 :     REAL t; 
; 3771 :     for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	esi, esi
	cmp	DWORD PTR _gauss1D_num, esi
	jle	$LN59@q_edge_set
$LN66@q_edge_set:

; 3772 :       for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	$LN19@q_edge_set
$LN65@q_edge_set:

; 3773 :       { for ( j = 0, t = 0.0 ; j < edge_ctrl ; j++ )

	mov	edi, DWORD PTR _edge_ctrl
	fld	ST(0)
	xor	ecx, ecx
	cmp	edi, 4
	jl	SHORT $LC54@q_edge_set
	mov	edx, DWORD PTR _gauss1polyd
	add	edi, -4					; fffffffcH
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv388[ebp], edi
	add	edi, edi
	add	edx, 8
	add	edi, edi
	lea	ecx, DWORD PTR [ebx+420]
	mov	DWORD PTR _j$[ebp], edi
$LN55@q_edge_set:

; 3774 :             t += gauss1polyd[j][m]*e_info->x[j][i];

	mov	edi, DWORD PTR [edx-8]
	fld	QWORD PTR [edi+esi*8]
	mov	ebx, DWORD PTR [ecx-4]
	fmul	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [edx-4]
	mov	ebx, DWORD PTR [ecx]
	add	ecx, 16					; 00000010H
	faddp	ST(1), ST(0)
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv388[ebp]
	fld	QWORD PTR [edi+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [ecx-12]
	mov	ebx, DWORD PTR [edx-16]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR [edx-12]
	fmul	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR [ecx-8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	faddp	ST(1), ST(0)
	jne	SHORT $LN55@q_edge_set

; 3773 :       { for ( j = 0, t = 0.0 ; j < edge_ctrl ; j++ )

	mov	ebx, DWORD PTR _e_info$[ebp]
	mov	edi, DWORD PTR _edge_ctrl
	mov	ecx, DWORD PTR _j$[ebp]
$LC54@q_edge_set:
	cmp	ecx, edi
	jge	SHORT $LN53@q_edge_set
	lea	ebx, DWORD PTR [ebx+ecx*4+416]
$LN62@q_edge_set:

; 3774 :             t += gauss1polyd[j][m]*e_info->x[j][i];

	mov	edx, DWORD PTR _gauss1polyd
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	edi, DWORD PTR [ebx]
	fld	QWORD PTR [edx+esi*8]
	fmul	QWORD PTR [edi+eax*8]
	inc	ecx
	add	ebx, 4
	faddp	ST(1), ST(0)
	cmp	ecx, DWORD PTR _edge_ctrl
	jl	SHORT $LN62@q_edge_set

; 3773 :       { for ( j = 0, t = 0.0 ; j < edge_ctrl ; j++ )

	mov	ebx, DWORD PTR _e_info$[ebp]
$LN53@q_edge_set:

; 3775 :          e_info->sides[m][0][i] = t;

	mov	ecx, DWORD PTR [ebx+1276]
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR [edx]
	fstp	QWORD PTR [ecx+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	$LN65@q_edge_set
$LN19@q_edge_set:

; 3768 :   { /* tangent vectors at gauss points */
; 3769 :     int m;
; 3770 :     REAL t; 
; 3771 :     for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	esi
	cmp	esi, DWORD PTR _gauss1D_num
	jl	$LN66@q_edge_set
$LN59@q_edge_set:

; 3776 :       }
; 3777 :   }
; 3778 :   if ( needs & NEED_WINGS )

	test	BYTE PTR _needs$[ebp], 64		; 00000040H
	je	SHORT $LN63@q_edge_set

; 3779 :   { kb_error(1575,"Can't do quadratic model with edge WINGS (needed for some method instance).\n",RECOVERABLE);

	push	1
	fstp	ST(0)
	push	OFFSET ??_C@_0EN@JADPALJA@Can?8t?5do?5quadratic?5model?5with?5ed@
	push	1575					; 00000627H
	call	_kb_error
	fldz
	add	esp, 12					; 0000000cH
$LN63@q_edge_set:

; 3780 :   }
; 3781 : 
; 3782 :   if ( needs & NEED_GAUSS )

	test	BYTE PTR _needs$[ebp], -128		; ffffff80H
	je	$LN110@q_edge_set

; 3783 :   { int m;
; 3784 :     REAL t; 
; 3785 :     for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	esi, esi
	cmp	DWORD PTR _gauss1D_num, esi
	jle	$LN110@q_edge_set
	mov	ecx, DWORD PTR _web+616
$LN67@q_edge_set:

; 3786 :       for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	test	ecx, ecx
	jle	$LN8@q_edge_set
$LN64@q_edge_set:

; 3787 :       { for ( j = 0, t = 0.0 ; j < edge_ctrl ; j++ )

	mov	edi, DWORD PTR _edge_ctrl
	fld	ST(0)
	xor	ecx, ecx
	cmp	edi, 4
	jl	SHORT $LC57@q_edge_set
	mov	edx, DWORD PTR _gauss1poly
	add	edi, -4					; fffffffcH
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv2111[ebp], edi
	add	edi, edi
	add	edx, 8
	add	edi, edi
	lea	ecx, DWORD PTR [ebx+420]
	mov	DWORD PTR _j$[ebp], edi
$LN58@q_edge_set:

; 3788 :           t += gauss1poly[j][m]*e_info->x[j][i];

	mov	edi, DWORD PTR [edx-8]
	fld	QWORD PTR [edi+esi*8]
	mov	ebx, DWORD PTR [ecx-4]
	fmul	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [edx-4]
	mov	ebx, DWORD PTR [ecx]
	add	ecx, 16					; 00000010H
	faddp	ST(1), ST(0)
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv2111[ebp]
	fld	QWORD PTR [edi+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	mov	edi, DWORD PTR [ecx-12]
	mov	ebx, DWORD PTR [edx-16]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR [edx-12]
	fmul	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR [ecx-8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	faddp	ST(1), ST(0)
	jne	SHORT $LN58@q_edge_set

; 3787 :       { for ( j = 0, t = 0.0 ; j < edge_ctrl ; j++ )

	mov	edi, DWORD PTR _edge_ctrl
	mov	ecx, DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR _e_info$[ebp]
$LC57@q_edge_set:
	cmp	ecx, edi
	jge	SHORT $LN56@q_edge_set
	lea	edi, DWORD PTR [ebx+ecx*4+416]
$LN61@q_edge_set:

; 3788 :           t += gauss1poly[j][m]*e_info->x[j][i];

	mov	edx, DWORD PTR _gauss1poly
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [edi]
	fld	QWORD PTR [edx+esi*8]
	fmul	QWORD PTR [ebx+eax*8]
	inc	ecx
	add	edi, 4
	faddp	ST(1), ST(0)
	cmp	ecx, DWORD PTR _edge_ctrl
	jl	SHORT $LN61@q_edge_set

; 3787 :       { for ( j = 0, t = 0.0 ; j < edge_ctrl ; j++ )

	mov	ebx, DWORD PTR _e_info$[ebp]
$LN56@q_edge_set:

; 3789 :         e_info->gauss_pt[m][i] = t;

	mov	ecx, DWORD PTR [ebx+1268]
	mov	edx, DWORD PTR [ecx+esi*4]
	fstp	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _web+616
	inc	eax
	cmp	eax, ecx
	jl	$LN64@q_edge_set
$LN8@q_edge_set:

; 3783 :   { int m;
; 3784 :     REAL t; 
; 3785 :     for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	esi
	cmp	esi, DWORD PTR _gauss1D_num
	jl	$LN67@q_edge_set
$LN110@q_edge_set:
	pop	edi

; 3786 :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
	pop	esi
	pop	ebx

; 3790 :       }
; 3791 :   }
; 3792 : } // end q_edge_setup_q()

	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_setup_q ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EH@GEAHPPIP@Can?8t?5do?5Lagrange?5model?5with?5WIN@ ; `string'
PUBLIC	_q_edge_setup_lagrange
EXTRN	_gauss_lagrange:BYTE
;	COMDAT ??_C@_0EH@GEAHPPIP@Can?8t?5do?5Lagrange?5model?5with?5WIN@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EH@GEAHPPIP@Can?8t?5do?5Lagrange?5model?5with?5WIN@ DB 'Can''t do '
	DB	'Lagrange model with WINGS (needed for some method instance).', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\quantity.c
CONST	ENDS
;	COMDAT _q_edge_setup_lagrange
_TEXT	SEGMENT
tv727 = -16						; size = 4
tv331 = -16						; size = 4
tv231 = -16						; size = 4
tv625 = -12						; size = 4
_dim$ = -8						; size = 4
_gl$ = -4						; size = 4
tv575 = 8						; size = 4
_e_info$ = 8						; size = 4
_needs$ = 12						; size = 4
_q_edge_setup_lagrange PROC				; COMDAT

; 3807 : { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 3808 :   int ctrl = web.skel[EDGE].ctrlpts;
; 3809 :   int dim = (web.representation==STRING) ? 1 : web.dimension - 1 ;

	mov	eax, 1
	push	edi
	mov	edi, DWORD PTR _web+120
	cmp	DWORD PTR _web+624, eax
	je	SHORT $LN33@q_edge_set@2
	mov	eax, DWORD PTR _web+620
	dec	eax
$LN33@q_edge_set@2:

; 3810 :   struct gauss_lag *gl = &gauss_lagrange[dim][web.gauss1D_order];

	mov	edx, DWORD PTR _web+1592

; 3811 :   vertex_id *v;
; 3812 : 
; 3813 :   /* W A R N I N G */
; 3814 :   /* Be sure to place all data consistently for all methods !!! */
; 3815 : 
; 3816 :   e_info->vcount = ctrl;

	mov	ebx, DWORD PTR _e_info$[ebp]
	mov	ecx, eax
	mov	DWORD PTR _dim$[ebp], eax

; 3817 :   v = get_edge_vertices(e_info->id);

	mov	eax, DWORD PTR [ebx]
	shl	edx, 5
	add	edx, DWORD PTR _gauss_lagrange[ecx*4]
	mov	DWORD PTR [ebx+12], edi
	mov	ecx, DWORD PTR _web+124
	mov	esi, DWORD PTR _web+216
	mov	DWORD PTR tv331[ebp], eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [esi+ecx+304]

; 3818 :   if ( inverted(e_info->id) )

	test	DWORD PTR tv331[ebp], 134217728		; 08000000H
	mov	DWORD PTR _gl$[ebp], edx
	je	SHORT $LN15@q_edge_set@2

; 3819 :   for ( i = 0 ; i < ctrl ; i++ )

	test	edi, edi
	jle	$LN32@q_edge_set@2
	lea	ecx, DWORD PTR [ebx+416]
	lea	eax, DWORD PTR [eax+edi*4-4]
	mov	DWORD PTR tv575[ebp], ecx
	mov	DWORD PTR tv625[ebp], eax
	mov	DWORD PTR tv231[ebp], edi
	npad	6
$LL14@q_edge_set@2:

; 3820 :   { e_info->v[i] = v[ctrl-i-1];

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx-400], esi

; 3821 :     e_info->x[i] = get_coord(v[ctrl-i-1]);

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR _web+12
	mov	esi, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+104
	add	eax, DWORD PTR [ecx+esi+64]
	mov	ecx, DWORD PTR tv575[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR tv625[ebp]
	add	ecx, 4
	sub	eax, 4
	dec	DWORD PTR tv231[ebp]
	mov	DWORD PTR tv575[ebp], ecx
	mov	DWORD PTR tv625[ebp], eax
	jne	SHORT $LL14@q_edge_set@2

; 3822 :   }
; 3823 :   else

	jmp	SHORT $LN32@q_edge_set@2
$LN15@q_edge_set@2:

; 3824 :   for ( i = 0 ; i < ctrl ; i++ )

	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN32@q_edge_set@2
	lea	edx, DWORD PTR [ebx+416]
	mov	DWORD PTR tv727[ebp], edx
$LL30@q_edge_set@2:

; 3825 :   { e_info->v[i] = v[i];

	mov	esi, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx-400], esi

; 3826 :     e_info->x[i] = get_coord(v[i]);

	mov	edx, DWORD PTR [eax+ecx*4]
	mov	esi, DWORD PTR _web+12
	mov	ebx, DWORD PTR _dymem
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR _web+104
	add	esi, DWORD PTR [edx+ebx+64]
	mov	edx, DWORD PTR tv727[ebp]
	mov	DWORD PTR [edx], esi
	inc	ecx
	add	edx, 4
	mov	DWORD PTR tv727[ebp], edx
	cmp	ecx, edi
	jl	SHORT $LL30@q_edge_set@2

; 3824 :   for ( i = 0 ; i < ctrl ; i++ )

	mov	ebx, DWORD PTR _e_info$[ebp]
	mov	edx, DWORD PTR _gl$[ebp]
$LN32@q_edge_set@2:

; 3827 :   }
; 3828 :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN7@q_edge_set@2

; 3829 :   { WRAPTYPE wrap = get_edge_wrap(e_info->id);

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR _web+124
	mov	esi, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+esi+784]
	mov	ecx, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN22@q_edge_set@2
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	mov	esi, eax
	jmp	SHORT $LN23@q_edge_set@2
$LN22@q_edge_set@2:
	mov	esi, ecx
$LN23@q_edge_set@2:

; 3830 :     (*sym_wrap)(e_info->x[ctrl-1],e_info->xx[ctrl-1],wrap);

	mov	eax, DWORD PTR [ebx+1216]
	mov	ecx, DWORD PTR [eax+edi*4-4]
	mov	edx, DWORD PTR [ebx+edi*4+412]
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR _sym_wrap

; 3831 :     e_info->x[ctrl-1] = e_info->xx[ctrl-1];

	mov	eax, DWORD PTR [ebx+1216]
	mov	ecx, DWORD PTR [eax+edi*4-4]

; 3832 :     e_info->wraps[ctrl-1] = wrap;

	mov	edx, DWORD PTR _gl$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx+edi*4+412], ecx
	mov	DWORD PTR [ebx+edi*4+812], esi
$LN7@q_edge_set@2:

; 3833 :   }
; 3834 :   if ( needs & NEED_SIDE ) 

	test	BYTE PTR _needs$[ebp], 16		; 00000010H
	je	SHORT $LN3@q_edge_set@2

; 3835 :   { /* tangent vectors at gauss points */
; 3836 :     int m;
; 3837 :     for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	esi, esi
	cmp	DWORD PTR [edx+4], esi
	jle	SHORT $LN3@q_edge_set@2
$LL31@q_edge_set@2:

; 3838 :       mat_mult(gl->gpolypart[m],e_info->x,e_info->sides[m],dim,ctrl,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _dim$[ebp]
	mov	edx, DWORD PTR [edx+24]
	push	eax
	mov	eax, DWORD PTR [ebx+1276]
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [eax+esi*4]
	push	ecx
	lea	eax, DWORD PTR [ebx+416]
	push	eax
	mov	eax, DWORD PTR [edx+esi*4]
	push	eax
	call	_mat_mult
	mov	ecx, DWORD PTR _gl$[ebp]
	inc	esi
	add	esp, 24					; 00000018H
	mov	edx, ecx
	cmp	esi, DWORD PTR [ecx+4]
	jl	SHORT $LL31@q_edge_set@2
$LN3@q_edge_set@2:

; 3839 :   }
; 3840 :   if ( needs & NEED_WINGS )

	test	BYTE PTR _needs$[ebp], 64		; 00000040H
	je	SHORT $LN2@q_edge_set@2

; 3841 :   { kb_error(1576,
; 3842 :      "Can't do Lagrange model with WINGS (needed for some method instance).\n",
; 3843 :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EH@GEAHPPIP@Can?8t?5do?5Lagrange?5model?5with?5WIN@
	push	1576					; 00000628H
	call	_kb_error
	mov	edx, DWORD PTR _gl$[ebp]
	add	esp, 12					; 0000000cH
$LN2@q_edge_set@2:

; 3844 :   }
; 3845 :   if ( needs & NEED_GAUSS )

	test	BYTE PTR _needs$[ebp], -128		; ffffff80H
	je	SHORT $LN1@q_edge_set@2

; 3846 :      mat_mult(gl->gpoly,e_info->x,e_info->gauss_pt,gl->gnumpts,ctrl,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR [edx+4]
	push	eax
	mov	eax, DWORD PTR [ebx+1268]
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [edx+20]
	push	eax
	add	ebx, 416				; 000001a0H
	push	ebx
	push	ecx
	call	_mat_mult
	add	esp, 24					; 00000018H
$LN1@q_edge_set@2:
	pop	edi
	pop	esi
	pop	ebx

; 3847 : } // end q_edge_setup_lagrange()

	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_setup_lagrange ENDP
_TEXT	ENDS
PUBLIC	_q_facet_setup_q
EXTRN	_gpoly:DWORD
EXTRN	_gpolypartial:DWORD
EXTRN	_gauss2D_num:DWORD
EXTRN	_get_facet_verts:PROC
; Function compile flags: /Ogtp
;	COMDAT _q_facet_setup_q
_TEXT	SEGMENT
_f_info$ = 8						; size = 4
_needs$ = 12						; size = 4
_q_facet_setup_q PROC					; COMDAT

; 3955 : { facetedge_id fe_id;

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 3956 :   int i,m;
; 3957 : 
; 3958 :   /* W A R N I N G */
; 3959 :   /* Be sure to place all data consistently for all methods !!! */
; 3960 : 
; 3961 :   f_info->vcount = 6; 

	mov	esi, DWORD PTR _f_info$[ebp]

; 3962 :   fe_id = get_facet_fe(f_info->id);

	mov	eax, DWORD PTR [esi]
	push	edi
	mov	DWORD PTR [esi+12], 6
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN11@q_facet_se
	xor	edx, edx
	jmp	SHORT $LN10@q_facet_se
$LN11@q_facet_se:
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN10@q_facet_se
	xor	edx, 134217728				; 08000000H
$LN10@q_facet_se:

; 3963 :   for ( i = 0 ; i < FACET_EDGES ; i++ )
; 3964 :   { 
; 3965 :     f_info->v[2*i] = get_fe_tailv(fe_id);

	mov	eax, DWORD PTR _web+460
	mov	ebx, DWORD PTR _dymem
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+eax]
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]
	mov	edi, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN17@q_facet_se
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	add	eax, DWORD PTR [edi+ebx+304]
	mov	edi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN16@q_facet_se
$LN17@q_facet_se:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	mov	edi, DWORD PTR [edi+ebx+304]
	mov	eax, DWORD PTR [eax+edi]
$LN16@q_facet_se:
	mov	DWORD PTR [esi+16], eax

; 3966 :     f_info->x[2*i] = f_info->xx[2*i];

	mov	eax, DWORD PTR [esi+1216]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+416], eax

; 3967 :     f_info->v[2*i+1] = get_fe_midv(fe_id);

	mov	eax, DWORD PTR _web+460
	mov	eax, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [eax+20]
	mov	edi, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	mov	edi, DWORD PTR [edi+ebx+304]
	mov	eax, DWORD PTR [eax+edi+8]
	mov	DWORD PTR [esi+20], eax

; 3968 :     f_info->x[2*i+1] = f_info->xx[2*i+1];

	mov	eax, DWORD PTR [esi+1216]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+420], eax

; 3969 :     fe_id = get_next_edge(fe_id);

	mov	eax, DWORD PTR _web+460
	test	edx, 134217728				; 08000000H
	je	SHORT $LN23@q_facet_se
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN6@q_facet_se
$LN23@q_facet_se:
	mov	edx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [edx+32]
$LN6@q_facet_se:

; 3963 :   for ( i = 0 ; i < FACET_EDGES ; i++ )
; 3964 :   { 
; 3965 :     f_info->v[2*i] = get_fe_tailv(fe_id);

	mov	ebx, DWORD PTR _dymem
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+eax]
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]
	mov	edi, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN37@q_facet_se
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	add	eax, DWORD PTR [edi+ebx+304]
	mov	edi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN38@q_facet_se
$LN37@q_facet_se:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	mov	edi, DWORD PTR [edi+ebx+304]
	mov	eax, DWORD PTR [eax+edi]
$LN38@q_facet_se:
	mov	DWORD PTR [esi+24], eax

; 3966 :     f_info->x[2*i] = f_info->xx[2*i];

	mov	eax, DWORD PTR [esi+1216]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+424], eax

; 3967 :     f_info->v[2*i+1] = get_fe_midv(fe_id);

	mov	eax, DWORD PTR _web+460
	mov	eax, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [eax+20]
	mov	edi, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	mov	edi, DWORD PTR [edi+ebx+304]
	mov	eax, DWORD PTR [eax+edi+8]
	mov	DWORD PTR [esi+28], eax

; 3968 :     f_info->x[2*i+1] = f_info->xx[2*i+1];

	mov	eax, DWORD PTR [esi+1216]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+428], eax

; 3969 :     fe_id = get_next_edge(fe_id);

	test	edx, 134217728				; 08000000H
	mov	edx, DWORD PTR _web+460
	je	SHORT $LN39@q_facet_se
	mov	ecx, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN40@q_facet_se
$LN39@q_facet_se:
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax+32]
$LN40@q_facet_se:

; 3963 :   for ( i = 0 ; i < FACET_EDGES ; i++ )
; 3964 :   { 
; 3965 :     f_info->v[2*i] = get_fe_tailv(fe_id);

	mov	edi, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [ecx+edx]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN42@q_facet_se
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	add	eax, DWORD PTR [edx+edi+304]
	mov	edx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN43@q_facet_se
$LN42@q_facet_se:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+edi+304]
	mov	eax, DWORD PTR [eax+edx]
$LN43@q_facet_se:
	mov	DWORD PTR [esi+32], eax

; 3966 :     f_info->x[2*i] = f_info->xx[2*i];

	mov	eax, DWORD PTR [esi+1216]
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+432], edx

; 3967 :     f_info->v[2*i+1] = get_fe_midv(fe_id);

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+304]
	mov	eax, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR [esi+36], eax

; 3968 :     f_info->x[2*i+1] = f_info->xx[2*i+1];

	mov	ecx, DWORD PTR [esi+1216]
	mov	edx, DWORD PTR [ecx+20]

; 3970 :   } 
; 3971 :   get_facet_verts(f_info->id,f_info->x,f_info->wraps);  /* in tail order */

	lea	eax, DWORD PTR [esi+816]
	push	eax
	mov	DWORD PTR [esi+436], edx
	mov	ecx, DWORD PTR [esi]
	lea	ebx, DWORD PTR [esi+416]
	push	ebx
	push	ecx
	call	_get_facet_verts

; 3972 : 
; 3973 :   /* tangents at gauss points */
; 3974 :   for ( m = 0 ; m < gauss2D_num ; m++ )

	mov	eax, DWORD PTR _gauss2D_num
	add	esp, 12					; 0000000cH
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN46@q_facet_se
	npad	3
$LL4@q_facet_se:

; 3975 :       mat_mult(gpolypartial[m],f_info->x,f_info->sides[m],
; 3976 :                    web.dimension,FACET_CTRL,SDIM);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _web+620
	mov	ecx, DWORD PTR [esi+1276]
	push	edx
	mov	edx, DWORD PTR [ecx+edi*4]
	push	6
	push	eax
	mov	eax, DWORD PTR _gpolypartial
	mov	ecx, DWORD PTR [eax+edi*4]
	push	edx
	push	ebx
	push	ecx
	call	_mat_mult
	mov	eax, DWORD PTR _gauss2D_num
	inc	edi
	add	esp, 24					; 00000018H
	cmp	edi, eax
	jl	SHORT $LL4@q_facet_se
$LN46@q_facet_se:

; 3977 : 
; 3978 :   /* if ( needs & NEED_NORMAL ) */
; 3979 : 
; 3980 :   if ( needs & NEED_GAUSS )

	test	BYTE PTR _needs$[ebp], -128		; ffffff80H
	je	SHORT $LN1@q_facet_se

; 3981 :      mat_mult(gpoly,f_info->x,f_info->gauss_pt,gauss2D_num,FACET_CTRL,SDIM);

	mov	edx, DWORD PTR _web+616
	mov	ecx, DWORD PTR _gpoly
	push	edx
	push	6
	push	eax
	mov	eax, DWORD PTR [esi+1268]
	push	eax
	push	ebx
	push	ecx
	call	_mat_mult
	add	esp, 24					; 00000018H
$LN1@q_facet_se:
	pop	edi
	pop	esi
	pop	ebx

; 3982 : } // end q_facet_setup_q()

	pop	ebp
	ret	0
_q_facet_setup_q ENDP
_TEXT	ENDS
PUBLIC	_q_facet_setup_lagrange
; Function compile flags: /Ogtp
;	COMDAT _q_facet_setup_lagrange
_TEXT	SEGMENT
_dim$ = -24						; size = 4
tv553 = -20						; size = 4
_gl$ = -20						; size = 4
tv510 = -16						; size = 4
tv488 = -12						; size = 4
_v$ = -8						; size = 4
_ctrl$ = -4						; size = 4
_f_info$ = 8						; size = 4
_needs$ = 12						; size = 4
_q_facet_setup_lagrange PROC				; COMDAT

; 3997 : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3998 :   int ctrl = web.skel[FACET].ctrlpts;
; 3999 :   int dim = web.dimension;

	mov	ecx, DWORD PTR _web+620
	mov	eax, DWORD PTR _web+232

; 4000 :   struct gauss_lag *gl = &gauss_lagrange[dim][web.gauss2D_order];
; 4001 :   vertex_id *v;
; 4002 : 
; 4003 :   /* W A R N I N G */
; 4004 :   /* Be sure to place all data consistently for all methods !!! */
; 4005 : 
; 4006 :   f_info->vcount = ctrl;

	mov	edx, DWORD PTR _f_info$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _web+1596
	shl	ebx, 5
	add	ebx, DWORD PTR _gauss_lagrange[ecx*4]
	mov	DWORD PTR [edx+12], eax
	mov	DWORD PTR _ctrl$[ebp], eax

; 4007 :   v = get_facet_vertices(f_info->id);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _dim$[ebp], ecx
	push	esi
	mov	esi, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR _web+328
	push	edi
	mov	edi, DWORD PTR _dymem
	add	esi, DWORD PTR [ecx+edi+304]
	mov	DWORD PTR _gl$[ebp], ebx
	mov	DWORD PTR _v$[ebp], esi

; 4008 :   if ( inverted(f_info->id) )  /* invert orientation of vertices */

	test	eax, 134217728				; 08000000H
	je	$LN15@q_facet_se@2

; 4009 :     for ( j = 0 ; j <= web.lagrange_order ; j++ )

	mov	edi, DWORD PTR _web+632
	xor	esi, esi
	test	edi, edi
	js	$LN5@q_facet_se@2
	npad	9
$LL29@q_facet_se@2:

; 4010 :       for ( i = 0 ; i+j <= web.lagrange_order ; i++ )

	xor	ecx, ecx
	cmp	esi, edi
	jg	$LN13@q_facet_se@2
	lea	eax, DWORD PTR [esi-1]
	imul	eax, esi
	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1

; 4011 :       { f_info->v[j*(web.lagrange_order+1)-j*(j-1)/2+i] =
; 4012 :           v[i*(web.lagrange_order+1)-i*(i-1)/2+j];

	mov	DWORD PTR tv488[ebp], ebx
	npad	6
$LL26@q_facet_se@2:
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	cdq
	sub	eax, edx
	lea	edx, DWORD PTR [edi+1]
	mov	edi, edx
	imul	edx, esi
	imul	edi, ecx
	sub	edx, ebx
	mov	ebx, DWORD PTR _v$[ebp]
	sar	eax, 1
	sub	edi, eax
	add	edi, esi
	mov	ebx, DWORD PTR [ebx+edi*4]
	mov	edi, DWORD PTR _f_info$[ebp]
	add	edx, ecx
	mov	DWORD PTR [edi+edx*4+16], ebx

; 4013 :         f_info->x[j*(web.lagrange_order+1)-j*(j-1)/2+i] = 
; 4014 :           f_info->xx[i*(web.lagrange_order+1)-i*(i-1)/2+j];

	mov	edx, DWORD PTR _web+632
	inc	edx
	mov	ebx, edx
	imul	edx, esi
	imul	ebx, ecx
	sub	ebx, eax
	mov	eax, DWORD PTR [edi+1216]
	add	ebx, esi
	mov	edi, ebx
	mov	ebx, DWORD PTR tv488[ebp]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR _f_info$[ebp]
	sub	edx, ebx
	add	edx, ecx
	inc	ecx
	mov	DWORD PTR [edi+edx*4+416], eax
	mov	edi, DWORD PTR _web+632
	lea	edx, DWORD PTR [esi+ecx]
	cmp	edx, edi
	jle	SHORT $LL26@q_facet_se@2

; 4010 :       for ( i = 0 ; i+j <= web.lagrange_order ; i++ )

	mov	ebx, DWORD PTR _gl$[ebp]
	mov	edx, DWORD PTR _f_info$[ebp]
$LN13@q_facet_se@2:

; 4009 :     for ( j = 0 ; j <= web.lagrange_order ; j++ )

	inc	esi
	cmp	esi, edi
	jle	$LL29@q_facet_se@2

; 4015 :       }
; 4016 :   else 

	jmp	SHORT $LN5@q_facet_se@2
$LN15@q_facet_se@2:

; 4017 :     for ( i = 0 ; i < ctrl ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _ctrl$[ebp], ecx
	jle	SHORT $LN5@q_facet_se@2
	mov	edi, -416				; fffffe60H
	sub	edi, edx
	lea	eax, DWORD PTR [edx+416]
	mov	DWORD PTR tv553[ebp], edi
$LL28@q_facet_se@2:

; 4018 :     { f_info->v[i] = v[i];

	mov	edi, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [eax-400], edi

; 4019 :       f_info->x[i] = f_info->xx[i];

	mov	edx, DWORD PTR [edx+1216]
	add	edx, DWORD PTR tv553[ebp]
	inc	ecx
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR _f_info$[ebp]
	add	eax, 4
	cmp	ecx, DWORD PTR _ctrl$[ebp]
	jl	SHORT $LL28@q_facet_se@2
$LN5@q_facet_se@2:

; 4020 :     }
; 4021 :   get_facet_verts(f_info->id,f_info->x,f_info->wraps);  

	mov	ecx, DWORD PTR [edx]
	lea	eax, DWORD PTR [edx+816]
	push	eax
	lea	edi, DWORD PTR [edx+416]
	push	edi
	push	ecx
	call	_get_facet_verts
	add	esp, 12					; 0000000cH

; 4022 :   if ( needs & NEED_SIDE ) 

	test	BYTE PTR _needs$[ebp], 16		; 00000010H
	je	SHORT $LN1@q_facet_se@2

; 4023 :   { /* tangent vectors at gauss points */
; 4024 :     int m;
; 4025 :     for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	esi, esi
	cmp	DWORD PTR [ebx+4], esi
	jle	SHORT $LN1@q_facet_se@2
	npad	7
$LL3@q_facet_se@2:

; 4026 :       mat_mult(gl->gpolypart[m],f_info->x,f_info->sides[m],dim,ctrl,SDIM);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _ctrl$[ebp]
	mov	ecx, DWORD PTR _dim$[ebp]
	push	edx
	mov	edx, DWORD PTR _f_info$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+1276]
	mov	edx, DWORD PTR [ebx+24]
	push	ecx
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [edx+esi*4]
	push	ecx
	push	edi
	push	eax
	call	_mat_mult
	inc	esi
	add	esp, 24					; 00000018H
	cmp	esi, DWORD PTR [ebx+4]
	jl	SHORT $LL3@q_facet_se@2
$LN1@q_facet_se@2:

; 4027 :   }
; 4028 :   /* always need gauss */
; 4029 :   mat_mult(gl->gpoly,f_info->x,f_info->gauss_pt,gl->gnumpts,ctrl,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [ebx+4]
	push	ecx
	mov	ecx, DWORD PTR _f_info$[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+1268]
	push	eax
	mov	eax, DWORD PTR [ebx+20]
	push	edx
	push	edi
	push	eax
	call	_mat_mult
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 4030 : 
; 4031 : } // end q_facet_setup_lagrange()

	mov	esp, ebp
	pop	ebp
	ret	0
_q_facet_setup_lagrange ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _q_body_setup
_TEXT	SEGMENT
_S$ = 8							; size = 4
_b_info$ = 12						; size = 4
_needs$ = 16						; size = 4
_q_body_setup PROC					; COMDAT

; 4046 : } // end q_body_setup()

	ret	0
_q_body_setup ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _q_facetedge_setup
_TEXT	SEGMENT
_S$ = 8							; size = 4
_fe_info$ = 12						; size = 4
_needs$ = 16						; size = 4
_q_facetedge_setup PROC					; COMDAT

; 4062 : } // end q_facetedge_setup()

	ret	0
_q_facetedge_setup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@MGDLENLK@Method?5value?5function?5not?5implem@ ; `string'
PUBLIC	_null_q_value
;	COMDAT ??_C@_0CP@MGDLENLK@Method?5value?5function?5not?5implem@
CONST	SEGMENT
??_C@_0CP@MGDLENLK@Method?5value?5function?5not?5implem@ DB 'Method value'
	DB	' function not implemented for %s.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _null_q_value
_TEXT	SEGMENT
_q_info$ = 8						; size = 4
_null_q_value PROC					; COMDAT

; 4072 : { sprintf(errmsg,"Method value function not implemented for %s.\n",

	push	ebp
	mov	ebp, esp

; 4073 :      basic_gen_methods[METH_INSTANCE(q_info->method)->gen_method].name);

	mov	eax, DWORD PTR _q_info$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _meth_inst_list
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	mov	eax, DWORD PTR [eax+ecx+148]
	lea	edx, DWORD PTR [eax+eax*4]
	shl	edx, 5
	add	edx, OFFSET _basic_gen_methods
	push	edx
	push	OFFSET ??_C@_0CP@MGDLENLK@Method?5value?5function?5not?5implem@
	push	OFFSET _errmsg
	call	_sprintf

; 4074 :   kb_error(1577,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1577					; 00000629H
	call	_kb_error

; 4075 : 
; 4076 :   return 0.0;

	fldz
	add	esp, 24					; 00000018H

; 4077 : } // end null_q_value()

	pop	ebp
	ret	0
_null_q_value ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@OGFICDLC@Method?5gradient?5function?5not?5imp@ ; `string'
;	COMDAT ??_C@_0DC@OGFICDLC@Method?5gradient?5function?5not?5imp@
CONST	SEGMENT
??_C@_0DC@OGFICDLC@Method?5gradient?5function?5not?5imp@ DB 'Method gradi'
	DB	'ent function not implemented for %s.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _null_q_grad
_TEXT	SEGMENT
_q_info$ = 8						; size = 4
_null_q_grad PROC					; COMDAT

; 4080 : { sprintf(errmsg,"Method gradient function not implemented for %s.\n",

	push	ebp
	mov	ebp, esp

; 4081 :      basic_gen_methods[METH_INSTANCE(q_info->method)->gen_method].name);

	mov	eax, DWORD PTR _q_info$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _meth_inst_list
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	mov	eax, DWORD PTR [eax+ecx+148]
	lea	edx, DWORD PTR [eax+eax*4]
	shl	edx, 5
	add	edx, OFFSET _basic_gen_methods
	push	edx
	push	OFFSET ??_C@_0DC@OGFICDLC@Method?5gradient?5function?5not?5imp@
	push	OFFSET _errmsg
	call	_sprintf

; 4082 :   kb_error(1578,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1578					; 0000062aH
	call	_kb_error

; 4083 : 
; 4084 :   return 0.0;

	fldz
	add	esp, 24					; 00000018H

; 4085 : } // end null_q_grad()

	pop	ebp
	ret	0
_null_q_grad ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@IHNKMCKM@Quantity?5hessian?5function?5not?5im@ ; `string'
;	COMDAT ??_C@_0DD@IHNKMCKM@Quantity?5hessian?5function?5not?5im@
CONST	SEGMENT
??_C@_0DD@IHNKMCKM@Quantity?5hessian?5function?5not?5im@ DB 'Quantity hes'
	DB	'sian function not implemented for %s.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _null_q_hess
_TEXT	SEGMENT
_q_info$ = 8						; size = 4
_null_q_hess PROC					; COMDAT

; 4088 : { sprintf(errmsg,"Quantity hessian function not implemented for %s.\n",

	push	ebp
	mov	ebp, esp

; 4089 :      basic_gen_methods[METH_INSTANCE(q_info->method)->gen_method].name);

	mov	eax, DWORD PTR _q_info$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _meth_inst_list
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	mov	eax, DWORD PTR [eax+ecx+148]
	lea	edx, DWORD PTR [eax+eax*4]
	shl	edx, 5
	add	edx, OFFSET _basic_gen_methods
	push	edx
	push	OFFSET ??_C@_0DD@IHNKMCKM@Quantity?5hessian?5function?5not?5im@
	push	OFFSET _errmsg
	call	_sprintf

; 4090 :   kb_error(1579,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1579					; 0000062bH
	call	_kb_error

; 4091 : 
; 4092 :   return 0.0;

	fldz
	add	esp, 24					; 00000018H

; 4093 : } // end null_q_hess()

	pop	ebp
	ret	0
_null_q_hess ENDP
_TEXT	ENDS
PUBLIC	_zerohess
; Function compile flags: /Ogtp
;	COMDAT _zerohess
_TEXT	SEGMENT
_q_info$ = 8						; size = 4
_zerohess PROC						; COMDAT

; 4097 : { int m,i,j,k;

	push	ebp
	mov	ebp, esp

; 4098 :   for ( m = 0 ; m < q_info->vcount ; m++ )

	fldz
	mov	ecx, DWORD PTR _web+616
	push	ebx
	push	esi
	mov	esi, DWORD PTR _q_info$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [esi+12], edx
	jle	SHORT $LN16@zerohess
$LN18@zerohess:

; 4099 :      for ( j = 0 ; j < SDIM ; j++ ) 

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN17@zerohess
$LN15@zerohess:

; 4100 :         q_info->grad[m][j] = 0.0;

	mov	ecx, DWORD PTR [esi+1336]
	mov	ecx, DWORD PTR [ecx+edx*4]
	fst	QWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR _web+616
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LN15@zerohess
$LN17@zerohess:

; 4098 :   for ( m = 0 ; m < q_info->vcount ; m++ )

	inc	edx
	cmp	edx, DWORD PTR [esi+12]
	jl	SHORT $LN18@zerohess
$LN16@zerohess:

; 4101 :   for ( m = 0 ; m < q_info->vcount ; m++ )

	mov	eax, DWORD PTR [esi+12]
	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN47@zerohess
	push	edi
$LN36@zerohess:

; 4102 :     for ( i = 0 ; i < q_info->vcount ; i++ )

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN11@zerohess
$LN35@zerohess:

; 4103 :      for ( j = 0 ; j < SDIM ; j++ ) 

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN8@zerohess
$LN6@zerohess:

; 4104 :       for ( k = 0 ; k < SDIM ; k++ ) 

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN5@zerohess
$LN3@zerohess:

; 4105 :           q_info->hess[m][i][j][k] = 0.0;

	mov	ecx, DWORD PTR [esi+1340]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [ecx+edx*4]
	fst	QWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR _web+616
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LN3@zerohess
$LN5@zerohess:

; 4103 :      for ( j = 0 ; j < SDIM ; j++ ) 

	inc	edx
	cmp	edx, ecx
	jl	SHORT $LN6@zerohess
$LN8@zerohess:

; 4102 :     for ( i = 0 ; i < q_info->vcount ; i++ )

	inc	edi
	cmp	edi, DWORD PTR [esi+12]
	jl	SHORT $LN35@zerohess
$LN11@zerohess:

; 4101 :   for ( m = 0 ; m < q_info->vcount ; m++ )

	mov	eax, DWORD PTR [esi+12]
	inc	ebx
	cmp	ebx, eax
	jl	SHORT $LN36@zerohess
	pop	edi
$LN47@zerohess:
	pop	esi
	fstp	ST(0)
	pop	ebx

; 4106 : } // end zerohess()

	pop	ebp
	ret	0
_zerohess ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@NEMEJMGO@ackerman?5method?3?5Dimension?5too?5h@ ; `string'
EXTRN	_ackerman_flag:DWORD
;	COMDAT ??_C@_0DN@NEMEJMGO@ackerman?5method?3?5Dimension?5too?5h@
CONST	SEGMENT
??_C@_0DN@NEMEJMGO@ackerman?5method?3?5Dimension?5too?5h@ DB 'ackerman me'
	DB	'thod: Dimension too high for phase space motion.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _ackerman_init
_TEXT	SEGMENT
_sdim2$ = -4						; size = 4
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_ackerman_init PROC					; COMDAT

; 4128 : { int sdim2=2*SDIM;

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	eax, DWORD PTR _web+616
	add	eax, eax
	mov	DWORD PTR _sdim2$[ebp], eax

; 4129 :   if ( 2*SDIM > MAXCOORD )

	cmp	eax, 6
	jle	SHORT $LN1@ackerman_i

; 4130 :      kb_error(1580,"ackerman method: Dimension too high for phase space motion.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DN@NEMEJMGO@ackerman?5method?3?5Dimension?5too?5h@
	push	1580					; 0000062cH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@ackerman_i:

; 4131 : 
; 4132 :   expand_attribute(VERTEX,V_COORD_ATTR,&sdim2);

	lea	eax, DWORD PTR _sdim2$[ebp]
	push	eax
	push	0
	push	0
	call	_expand_attribute

; 4133 :   expand_attribute(VERTEX,V_OLDCOORD_ATTR,&sdim2);

	lea	ecx, DWORD PTR _sdim2$[ebp]
	push	ecx
	push	1
	push	0
	call	_expand_attribute

; 4134 :   expand_attribute(VERTEX,V_FORCE_ATTR,&sdim2);

	lea	edx, DWORD PTR _sdim2$[ebp]
	push	edx
	push	3
	push	0
	call	_expand_attribute

; 4135 :   expand_attribute(VERTEX,V_VELOCITY_ATTR,&sdim2);

	lea	eax, DWORD PTR _sdim2$[ebp]
	push	eax
	push	4
	push	0
	call	_expand_attribute
	add	esp, 48					; 00000030H

; 4136 :   ackerman_flag = 1;

	mov	DWORD PTR _ackerman_flag, 1

; 4137 : } // end ackerman_init()

	mov	esp, ebp
	pop	ebp
	ret	0
_ackerman_init ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _ackerman_energy
_TEXT	SEGMENT
_v_info$ = 8						; size = 4
_ackerman_energy PROC					; COMDAT

; 4147 : { return 0.0;

	fldz

; 4148 : }

	ret	0
_ackerman_energy ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _ackerman_forces
_TEXT	SEGMENT
_v_info$ = 8						; size = 4
_ackerman_forces PROC					; COMDAT

; 4158 : { REAL *f = get_force(v_info->id);

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _web+12

; 4159 :   REAL *x = get_coord(v_info->id);
; 4160 : /*  REAL star = get_vertex_star(v_info->id); */
; 4161 :   int i;
; 4162 : 
; 4163 :   /* modify first order forces to second order */
; 4164 :   for ( i = 0 ; i < SDIM ; i++ )

	fldz
	mov	edx, DWORD PTR _web+104
	push	esi
	mov	esi, DWORD PTR _dymem
	push	edi
	mov	edi, DWORD PTR _v_info$[ebp]
	mov	eax, DWORD PTR [edi]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [edx+esi+784]
	mov	edx, DWORD PTR [edx+esi+64]
	mov	esi, DWORD PTR _web+616
	add	ecx, eax
	add	edx, eax
	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN1@ackerman_f
$LN3@ackerman_f:

; 4165 :     {
; 4166 :       f[i+SDIM] = f[i];

	fld	QWORD PTR [ecx+eax*8]
	add	esi, eax
	fstp	QWORD PTR [ecx+esi*8]

; 4167 :       f[i] = 0.0;

	fst	QWORD PTR [ecx+eax*8]

; 4168 :       v_info->grad[0][i] = -x[i+SDIM];

	mov	esi, DWORD PTR _web+616
	add	esi, eax
	fld	QWORD PTR [edx+esi*8]
	mov	esi, DWORD PTR [edi+1336]
	mov	esi, DWORD PTR [esi]
	fchs
	fstp	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR _web+616
	inc	eax
	cmp	eax, esi
	jl	SHORT $LN3@ackerman_f
$LN1@ackerman_f:
	pop	edi
	pop	esi

; 4169 :     }
; 4170 :   return 0.0;
; 4171 : } // end ackerman_forces()

	pop	ebp
	ret	0
_ackerman_forces ENDP
_TEXT	ENDS
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_add_vgrads_to_update
EXTRN	_get_vertex_vgrad:PROC
; Function compile flags: /Ogtp
;	COMDAT _add_vgrads_to_update
_TEXT	SEGMENT
tv331 = -68						; size = 4
_S$GSCopy$ = -64					; size = 4
tv260 = -60						; size = 4
_vgptr$91825 = -56					; size = 4
_tempvec$91833 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_add_vgrads_to_update PROC				; COMDAT

; 4183 : { vertex_id v_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4184 : 
; 4185 :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+48
	mov	eax, DWORD PTR _S$[ebp]
	mov	DWORD PTR _S$GSCopy$[ebp], eax
	test	ecx, 268435456				; 10000000H
	je	$LN15@add_vgrads
	push	ebx
	push	esi
	push	edi
	npad	5
$LL17@add_vgrads:
	mov	edx, DWORD PTR _web+12
	mov	edi, ecx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv260[ebp], edi
	je	$LN16@add_vgrads

; 4186 :   { struct hess_verlist *v1 = get_vertex_vhead(v_id);

	mov	eax, DWORD PTR _vhead_attr
	mov	esi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104

; 4187 :     struct volgrad *vgptr = get_vertex_vgrad(v_id);

	push	ecx
	mov	eax, DWORD PTR [eax+esi+64]
	mov	edi, DWORD PTR [edx+eax]
	shl	edi, 5
	add	edi, DWORD PTR _vhead
	call	_get_vertex_vgrad
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _vgptr$91825[ebp], eax

; 4188 : 	for ( ; vgptr ; vgptr = vgptr->chain )

	test	ebx, ebx
	je	$LN29@add_vgrads
	npad	11
$LL12@add_vgrads:

; 4189 : 	{ struct method_instance *mi;
; 4190 : 	  int j;
; 4191 : 	  if ( !(vgptr->qnum & METHBASE ) ) continue;

	mov	eax, DWORD PTR [ebx+4]
	test	eax, 65536				; 00010000H
	je	$LN11@add_vgrads

; 4192 : 	  mi = METH_INSTANCE(vgptr->qnum - METHBASE);

	add	eax, -65536				; ffff0000H
	cdq
	mov	esi, eax

; 4193 :       if ( v1->proj )

	mov	eax, DWORD PTR [edi+16]
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list
	test	eax, eax
	je	SHORT $LN8@add_vgrads

; 4194 :       { REAL tempvec[MAXCOORD];
; 4195 :         vec_mat_mul(vgptr->grad,v1->proj,tempvec,SDIM,v1->freedom);

	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR _web+616
	push	ecx
	push	edx
	mov	edx, DWORD PTR [ebx+16]
	lea	ecx, DWORD PTR _tempvec$91833[ebp]
	push	ecx
	push	eax
	push	edx
	call	_vec_mat_mul

; 4196 :         for ( j = 0 ; j < v1->freedom ; j++ )

	xor	eax, eax
	add	esp, 20					; 00000014H
	cmp	DWORD PTR [edi+8], eax
	jle	$LN11@add_vgrads
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	mov	edx, DWORD PTR [ecx+216]
	npad	3
$LL7@add_vgrads:

; 4197 :             S->low_rank_vectors[mi->global_low_rank][v1->rownum+j]
; 4198 :                         += tempvec[j];

	mov	ecx, DWORD PTR [esi+220]
	fld	QWORD PTR _tempvec$91833[ebp+eax*8]
	mov	ebx, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edx+ecx*4]
	add	ebx, eax
	fadd	QWORD PTR [ecx+ebx*8]
	lea	ecx, DWORD PTR [ecx+ebx*8]
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR [edi+8]
	jl	SHORT $LL7@add_vgrads

; 4199 :        }
; 4200 :        else

	mov	ebx, DWORD PTR _vgptr$91825[ebp]
	jmp	SHORT $LN11@add_vgrads
$LN8@add_vgrads:

; 4201 :        { for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN11@add_vgrads
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	mov	ecx, DWORD PTR [edx+216]
	mov	DWORD PTR tv331[ebp], ecx
	npad	5
$LL30@add_vgrads:

; 4202 :            S->low_rank_vectors[mi->global_low_rank][v1->rownum+j]
; 4203 :               += vgptr->grad[j];

	mov	edx, DWORD PTR [esi+220]
	mov	ecx, DWORD PTR [edi+12]
	mov	ebx, DWORD PTR tv331[ebp]
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _vgptr$91825[ebp]
	add	ecx, eax
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR [ebx+16]
	fld	QWORD PTR [edx+eax*8]
	inc	eax
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL30@add_vgrads
$LN11@add_vgrads:

; 4188 : 	for ( ; vgptr ; vgptr = vgptr->chain )

	mov	ebx, DWORD PTR [ebx+12]
	mov	DWORD PTR _vgptr$91825[ebp], ebx
	test	ebx, ebx
	jne	$LL12@add_vgrads
$LN29@add_vgrads:
	mov	edi, DWORD PTR tv260[ebp]
$LN16@add_vgrads:

; 4184 : 
; 4185 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, 268435456				; 10000000H
	jne	$LL17@add_vgrads
	pop	edi
	pop	esi
	pop	ebx
$LN15@add_vgrads:

; 4204 :        }
; 4205 :      }
; 4206 :    }
; 4207 : } // end add_vgrads_to_update()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_add_vgrads_to_update ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@MFBLOJLJ@Undefined?5method?5instance?5?8?$CFs?8?4?5@ ; `string'
PUBLIC	_attach_method
;	COMDAT ??_C@_0CC@MFBLOJLJ@Undefined?5method?5instance?5?8?$CFs?8?4?5@
CONST	SEGMENT
??_C@_0CC@MFBLOJLJ@Undefined?5method?5instance?5?8?$CFs?8?4?5@ DB 'Undefi'
	DB	'ned method instance ''%s''. ', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _attach_method
_TEXT	SEGMENT
_quantnum$ = 8						; size = 4
_meth_name$ = 12					; size = 4
_attach_method PROC					; COMDAT

; 753  : { 

	push	ebp
	mov	ebp, esp
	push	esi

; 754  :   int inst_num;
; 755  : 
; 756  :   inst_num = find_method_instance(meth_name);

	mov	esi, DWORD PTR _meth_name$[ebp]
	push	esi
	call	_find_method_instance
	add	esp, 4

; 757  :   if ( inst_num < 0 )

	test	eax, eax
	jns	SHORT $LN1@attach_met@2

; 758  :   { sprintf(errmsg,"Undefined method instance '%s'. \n",meth_name);

	push	esi
	push	OFFSET ??_C@_0CC@MFBLOJLJ@Undefined?5method?5instance?5?8?$CFs?8?4?5@
	push	OFFSET _errmsg
	call	_sprintf

; 759  :     kb_error(1562,errmsg,DATAFILE_ERROR); return -1; 

	push	6
	push	OFFSET _errmsg
	push	1562					; 0000061aH
	call	_kb_error
	add	esp, 24					; 00000018H
	or	eax, -1
	pop	esi

; 762  : } // end attach_method()

	pop	ebp
	ret	0
$LN1@attach_met@2:

; 760  :   }
; 761  :   return attach_method_num(quantnum,inst_num);

	push	eax
	mov	eax, DWORD PTR _quantnum$[ebp]
	push	eax
	call	_attach_method_num
	add	esp, 8
	pop	esi

; 762  : } // end attach_method()

	pop	ebp
	ret	0
_attach_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@FLNNNBK@Undefined?5method?5instance?5?8?$CFs?8?5o@ ; `string'
PUBLIC	_apply_method
EXTRN	_typenames:BYTE
;	COMDAT ??_C@_0CL@FLNNNBK@Undefined?5method?5instance?5?8?$CFs?8?5o@
CONST	SEGMENT
??_C@_0CL@FLNNNBK@Undefined?5method?5instance?5?8?$CFs?8?5o@ DB 'Undefine'
	DB	'd method instance ''%s'' on %s %s. ', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _apply_method
_TEXT	SEGMENT
_id$ = 8						; size = 4
_method_name$ = 12					; size = 4
_apply_method PROC					; COMDAT

; 844  : { 

	push	ebp
	mov	ebp, esp
	push	edi

; 845  :   int inst_num;
; 846  : 
; 847  :   /* search for method */
; 848  :   inst_num = find_method_instance(method_name);

	mov	edi, DWORD PTR _method_name$[ebp]
	push	edi
	call	_find_method_instance
	add	esp, 4

; 849  :   if ( inst_num < 0 )

	test	eax, eax
	jns	SHORT $LN1@apply_meth@2

; 850  :   { sprintf(errmsg, "Undefined method instance '%s' on %s %s. \n",
; 851  :          method_name,typenames[id_type(id)],ELNAME(id));

	push	esi
	mov	esi, DWORD PTR _id$[ebp]
	test	esi, 268435456				; 10000000H
	je	SHORT $LN4@apply_meth@2
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN5@apply_meth@2
$LN4@apply_meth@2:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN5@apply_meth@2:
	push	eax
	shr	esi, 29					; 0000001dH
	mov	ecx, DWORD PTR _typenames[esi*4]
	push	ecx
	push	edi
	push	OFFSET ??_C@_0CL@FLNNNBK@Undefined?5method?5instance?5?8?$CFs?8?5o@
	push	OFFSET _errmsg
	call	_sprintf

; 852  :     kb_error(1566, errmsg,DATAFILE_ERROR); 

	push	6
	push	OFFSET _errmsg
	push	1566					; 0000061eH
	call	_kb_error
	add	esp, 32					; 00000020H
	pop	esi
	pop	edi

; 865  : } // end apply_method()

	pop	ebp
	ret	0
$LN1@apply_meth@2:

; 853  :     return; 
; 854  :   }
; 855  : 
; 856  : /* really annoying in case of compound quantity
; 857  :   if ( valid_id(id) && (m->quant == -1) )
; 858  :   { sprintf(errmsg,"Method instance '%s' not attached to a quantity.\n",
; 859  :           method_name);
; 860  :     kb_error(1567,errmsg,WARNING);
; 861  :   }
; 862  : */
; 863  : 
; 864  :   apply_method_num(id,inst_num);

	mov	edx, DWORD PTR _id$[ebp]
	push	eax
	push	edx
	call	_apply_method_num
	add	esp, 8
	pop	edi

; 865  : } // end apply_method()

	pop	ebp
	ret	0
_apply_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@NGMEDPFF@Vertices?5in?5facet?5exceed?5MAXVCOU@ ; `string'
PUBLIC	_q_info_init
EXTRN	_kb_dmatrix3:PROC
EXTRN	_kb_dmatrix4:PROC
EXTRN	_kb_dmatrix:PROC
;	COMDAT ??_C@_0CF@NGMEDPFF@Vertices?5in?5facet?5exceed?5MAXVCOU@
CONST	SEGMENT
??_C@_0CF@NGMEDPFF@Vertices?5in?5facet?5exceed?5MAXVCOU@ DB 'Vertices in '
	DB	'facet exceed MAXVCOUNT.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _q_info_init
_TEXT	SEGMENT
tv672 = -12						; size = 4
tv348 = -8						; size = 4
tv661 = -4						; size = 4
tv467 = 8						; size = 4
_q_info$ = 8						; size = 4
tv663 = 12						; size = 4
_mode$ = 12						; size = 4
_q_info_init PROC					; COMDAT

; 1055 : { int m,i;

	push	ebp
	mov	ebp, esp

; 1056 :   int maxgauss = (gauss1D_num > gauss2D_num) ? gauss1D_num : gauss2D_num;

	mov	eax, DWORD PTR _gauss1D_num
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _gauss2D_num
	cmp	eax, edi
	jle	SHORT $LN30@q_info_ini
	mov	edi, eax
$LN30@q_info_ini:

; 1057 : 
; 1058 :   if ( q_info->xx )

	mov	esi, DWORD PTR _q_info$[ebp]
	cmp	DWORD PTR [esi+1216], 0
	je	SHORT $LN27@q_info_ini

; 1059 :     q_info_free(q_info);

	push	esi
	call	_q_info_free
	add	esp, 4
$LN27@q_info_ini:

; 1060 : 
; 1061 :   if ( web.dimension >= SOAPFILM )

	mov	eax, DWORD PTR _web+620

; 1062 :   {
; 1063 :   if ( gauss_lagrange[web.dimension][web.gauss2D_order].gnumpts > maxgauss )

	mov	edx, DWORD PTR _gauss_lagrange[eax*4]
	cmp	eax, 2
	jl	SHORT $LN26@q_info_ini
	mov	ecx, DWORD PTR _web+1596
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+edx+4]
	cmp	ecx, edi
	jle	SHORT $LN25@q_info_ini

; 1064 :     maxgauss = gauss_lagrange[web.dimension][web.gauss2D_order].gnumpts; 

	mov	edi, ecx
$LN25@q_info_ini:

; 1065 :   if ( gauss_lagrange[web.dimension-1][web.gauss1D_order].gnumpts > maxgauss )

	mov	edx, DWORD PTR _gauss_lagrange[eax*4-4]
$LN26@q_info_ini:

; 1066 :     maxgauss = gauss_lagrange[web.dimension-1][web.gauss1D_order].gnumpts; 
; 1067 :   }
; 1068 :   else 
; 1069 :   if ( gauss_lagrange[web.dimension][web.gauss1D_order].gnumpts > maxgauss )

	mov	ecx, DWORD PTR _web+1592
	shl	ecx, 5
	mov	eax, DWORD PTR [edx+ecx+4]
	cmp	eax, edi
	jle	SHORT $LN22@q_info_ini

; 1070 :     maxgauss = gauss_lagrange[web.dimension][web.gauss1D_order].gnumpts; 

	mov	edi, eax
$LN22@q_info_ini:

; 1071 : 
; 1072 :   if ( web.skel[FACET].ctrlpts > MAXVCOUNT )

	cmp	DWORD PTR _web+232, 100			; 00000064H
	jle	SHORT $LN38@q_info_ini

; 1073 :      kb_error(1570,"Vertices in facet exceed MAXVCOUNT.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CF@NGMEDPFF@Vertices?5in?5facet?5exceed?5MAXVCOU@
	push	1570					; 00000622H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN38@q_info_ini:

; 1074 : 
; 1075 : 
; 1076 :   memset((char*)q_info,0,sizeof(struct qinfo));

	push	1752					; 000006d8H
	push	0
	push	esi
	call	_memset

; 1077 :   /* set up matrices in qinfo with lots of room */
; 1078 :   q_info->xx = dmatrix(0,MAXVCOUNT,0,SDIM);

	mov	eax, DWORD PTR _web+616
	push	1078					; 00000436H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	eax
	push	0
	push	100					; 00000064H
	push	0
	call	_kb_dmatrix
	add	esp, 36					; 00000024H
	mov	DWORD PTR [esi+1216], eax

; 1079 :   if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	je	$LN40@q_info_ini

; 1080 :   { q_info->u = dmatrix(0,MAXVCOUNT,0,SDIM);

	mov	ecx, DWORD PTR _web+616
	push	1080					; 00000438H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	ecx
	push	0
	push	100					; 00000064H
	push	0
	call	_kb_dmatrix

; 1081 :      if ( (mode == METHOD_GRADIENT) || (mode == METHOD_HESSIAN) )

	mov	ebx, DWORD PTR _mode$[ebp]
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+1220], eax
	cmp	ebx, 4321				; 000010e1H
	je	SHORT $LN39@q_info_ini
	cmp	ebx, 8763				; 0000223bH
	jne	SHORT $LN17@q_info_ini
$LN39@q_info_ini:

; 1082 :         q_info->ugrad = dmatrix(0,MAXVCOUNT,0,SDIM);

	mov	edx, DWORD PTR _web+616
	push	1082					; 0000043aH
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	edx
	push	0
	push	100					; 00000064H
	push	0
	call	_kb_dmatrix
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+1236], eax

; 1083 :      if ( mode == METHOD_HESSIAN )

	cmp	ebx, 8763				; 0000223bH
	jne	SHORT $LN17@q_info_ini

; 1084 :         q_info->uhess = dmatrix4(MAXVCOUNT,MAXVCOUNT,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	1084					; 0000043cH
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	eax
	push	eax
	push	100					; 00000064H
	push	100					; 00000064H
	call	_kb_dmatrix4
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+1252], eax
	jmp	SHORT $LN17@q_info_ini
$LN40@q_info_ini:
	mov	ebx, DWORD PTR _mode$[ebp]
$LN17@q_info_ini:

; 1085 :   }
; 1086 :   q_info->sides = dmatrix3(maxgauss,MAXVCOUNT,SDIM);

	mov	eax, DWORD PTR _web+616
	push	1086					; 0000043eH
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	eax
	push	100					; 00000064H
	push	edi
	call	_kb_dmatrix3
	mov	DWORD PTR [esi+1276], eax

; 1087 :   if ( web.modeltype == LINEAR )

	mov	eax, 1
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _web+628, eax
	jne	SHORT $LN13@q_info_ini

; 1088 :      for ( m = 1 ; m < maxgauss ; m++ )

	cmp	edi, eax
	jle	SHORT $LN13@q_info_ini
	npad	9
$LL15@q_info_ini:

; 1089 :         q_info->sides[m] = q_info->sides[0];  /* since all the same */

	mov	ecx, DWORD PTR [esi+1276]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+eax*4], edx
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL15@q_info_ini
$LN13@q_info_ini:

; 1090 :   q_info->ss = dmatrix(0,2*SDIM,0,2*SDIM);

	mov	eax, DWORD PTR _web+616
	push	1090					; 00000442H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	add	eax, eax
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+1280], eax

; 1091 :   if ( (mode == METHOD_GRADIENT) || (mode == METHOD_HESSIAN) )

	cmp	ebx, 4321				; 000010e1H
	je	SHORT $LN11@q_info_ini
	cmp	ebx, 8763				; 0000223bH
	jne	SHORT $LN42@q_info_ini
$LN11@q_info_ini:

; 1092 :      q_info->grad = dmatrix(0,MAXVCOUNT,0,SDIM);

	mov	eax, DWORD PTR _web+616
	push	1092					; 00000444H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	eax
	push	0
	push	100					; 00000064H
	push	0
	call	_kb_dmatrix
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+1336], eax
$LN42@q_info_ini:

; 1093 :   q_info->gauss_pt = dmatrix(0,maxgauss,0,2*SDIM); /* extra for point number */

	mov	ecx, DWORD PTR _web+616
	push	1093					; 00000445H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	lea	edx, DWORD PTR [ecx+ecx]
	push	edx
	push	0
	push	edi
	push	0
	call	_kb_dmatrix
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+1268], eax

; 1094 :   if ( web.torus_flag && (web.representation == SOAPFILM) )

	cmp	DWORD PTR _web+860, 0
	je	$LN4@q_info_ini
	cmp	DWORD PTR _web+624, 2
	jne	$LN4@q_info_ini

; 1095 :   { /* allocate some working space for facet_volume method */
; 1096 :     int ectrl = web.lagrange_order + 1;

	mov	ebx, DWORD PTR _web+632

; 1097 :     q_info->uu[0] = (REAL **)mycalloc(ectrl*3,sizeof(REAL*));

	push	1097					; 00000449H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	inc	ebx
	lea	eax, DWORD PTR [ebx+ebx*2]
	push	4
	push	eax
	call	_kb_calloc
	mov	DWORD PTR [esi+1224], eax

; 1098 :     q_info->uu[1] = q_info->uu[0]+ectrl; q_info->uu[2] = q_info->uu[1]+ectrl;

	lea	edi, DWORD PTR [ebx*4]
	add	eax, edi
	mov	DWORD PTR [esi+1228], eax
	add	eax, edi
	mov	DWORD PTR [esi+1232], eax

; 1099 :     if ( (mode == METHOD_GRADIENT) || (mode == METHOD_HESSIAN) )

	mov	eax, DWORD PTR _mode$[ebp]
	add	esp, 16					; 00000010H
	cmp	eax, 4321				; 000010e1H
	je	SHORT $LN8@q_info_ini
	cmp	eax, 8763				; 0000223bH
	jne	$LN4@q_info_ini
$LN8@q_info_ini:

; 1100 :     { q_info->uugrad[0] = (REAL **)mycalloc(ectrl*3,sizeof(REAL*));

	push	1100					; 0000044cH
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	lea	eax, DWORD PTR [ebx+ebx*2]
	push	4
	push	eax
	call	_kb_calloc
	mov	DWORD PTR [esi+1240], eax

; 1101 :       q_info->uugrad[1] = q_info->uugrad[0]+ectrl; 

	add	eax, edi
	mov	DWORD PTR [esi+1244], eax

; 1102 :       q_info->uugrad[2] = q_info->uugrad[1]+ectrl;

	add	eax, edi
	add	esp, 16					; 00000010H

; 1103 :     }
; 1104 :     if ( mode == METHOD_HESSIAN )

	cmp	DWORD PTR _mode$[ebp], 8763		; 0000223bH
	mov	DWORD PTR [esi+1248], eax
	jne	$LN4@q_info_ini

; 1105 :     { q_info->uuhess[0] = (REAL ****)mycalloc(ectrl*3,sizeof(REAL***));

	push	1105					; 00000451H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	lea	eax, DWORD PTR [ebx+ebx*2]
	push	4
	push	eax
	call	_kb_calloc
	lea	ecx, DWORD PTR [esi+1256]
	mov	DWORD PTR [ecx], eax

; 1106 :       q_info->uuhess[1] = q_info->uuhess[0]+ectrl; 

	add	eax, edi
	mov	DWORD PTR [esi+1260], eax

; 1107 :       q_info->uuhess[2] = q_info->uuhess[1]+ectrl;

	add	eax, edi
	mov	DWORD PTR [esi+1264], eax

; 1108 :       q_info->uuhess[0][0] = (REAL***)mycalloc(3*ectrl*ectrl,sizeof(REAL**));

	mov	esi, ebx
	imul	esi, ebx
	push	1108					; 00000454H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	lea	eax, DWORD PTR [esi+esi*2]
	push	4
	push	eax
	mov	DWORD PTR tv467[ebp], ecx
	call	_kb_calloc
	mov	edx, DWORD PTR tv467[ebp]
	mov	ecx, DWORD PTR [edx]
	add	esp, 32					; 00000020H
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR tv663[ebp], edx
	xor	ecx, ecx
	lea	edx, DWORD PTR [esi*4]
	mov	DWORD PTR tv661[ebp], ecx
	mov	DWORD PTR tv672[ebp], edx
	mov	DWORD PTR tv348[ebp], 3
$LL43@q_info_ini:

; 1110 :         for ( m = 0 ; m < ectrl ; m++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN5@q_info_ini
	npad	7
$LL41@q_info_ini:

; 1111 :            q_info->uuhess[i][m] = q_info->uuhess[0][0] + i*ectrl*ectrl + m*ectrl;

	mov	edx, DWORD PTR tv467[ebp]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx]
	mov	esi, DWORD PTR tv663[ebp]
	mov	esi, DWORD PTR [esi]
	add	edx, ecx
	mov	DWORD PTR [esi+eax*4], edx
	inc	eax
	add	ecx, edi
	cmp	eax, ebx
	jl	SHORT $LL41@q_info_ini
$LN5@q_info_ini:

; 1109 :       for ( i = 0 ; i < 3 ; i++ )

	mov	ecx, DWORD PTR tv661[ebp]
	add	ecx, DWORD PTR tv672[ebp]
	add	DWORD PTR tv663[ebp], 4
	dec	DWORD PTR tv348[ebp]
	mov	DWORD PTR tv661[ebp], ecx
	jne	SHORT $LL43@q_info_ini
$LN4@q_info_ini:
	pop	edi
	pop	esi
	pop	ebx

; 1112 :     }
; 1113 :   }     
; 1114 : } // end q_info_init()

	mov	esp, ebp
	pop	ebp
	ret	0
_q_info_init ENDP
_TEXT	ENDS
PUBLIC	_setup_q_info
; Function compile flags: /Ogtp
;	COMDAT _setup_q_info
_TEXT	SEGMENT
_setup_q_info PROC					; COMDAT

; 1157 : 
; 1158 :   // Main thread
; 1159 :   q_info = &(default_thread_data.q_info);
; 1160 :   q_info_init(q_info,METHOD_HESSIAN);

	push	8763					; 0000223bH
	push	OFFSET _default_thread_data+56
	call	_q_info_init
	add	esp, 8

; 1161 :   
; 1162 :   // Worker threads
; 1163 :   if ( threadflag )

	cmp	DWORD PTR _threadflag, 0
	je	SHORT $LN2@setup_q_in

; 1164 :   { int i;
; 1165 :     for ( i = 0 ; i < nprocs ; i++ )

	push	edi
	xor	edi, edi
	cmp	DWORD PTR _nprocs, edi
	jle	SHORT $LN10@setup_q_in
	push	esi
	npad	9
$LL4@setup_q_in:

; 1166 :     { q_info = &(thread_data_ptrs[i]->q_info);

	mov	eax, DWORD PTR _thread_data_ptrs
	mov	esi, DWORD PTR [eax+edi*4]
	add	esi, 56					; 00000038H

; 1167 :       if ( q_info->xx )

	cmp	DWORD PTR [esi+1216], 0
	je	SHORT $LN1@setup_q_in

; 1168 :         q_info_free(q_info);

	push	esi
	call	_q_info_free
	add	esp, 4
$LN1@setup_q_in:

; 1169 :       q_info_init(q_info,METHOD_HESSIAN);

	push	8763					; 0000223bH
	push	esi
	call	_q_info_init
	inc	edi
	add	esp, 8
	cmp	edi, DWORD PTR _nprocs
	jl	SHORT $LL4@setup_q_in
	pop	esi
$LN10@setup_q_in:
	pop	edi
$LN2@setup_q_in:

; 1170 :     }
; 1171 :   }
; 1172 :    
; 1173 :   // Graphics thread thread, for "show" evaluation
; 1174 :   q_info = &(glutgraph_thread_data.q_info);
; 1175 :   q_info_init(q_info,METHOD_VALUE);

	push	1767					; 000006e7H
	push	OFFSET _glutgraph_thread_data+56
	call	_q_info_init
	add	esp, 8

; 1176 : 
; 1177 : } // end setup_q_info()

	ret	0
_setup_q_info ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	_calc_quants
EXTRN	_set_body_volume:PROC
EXTRN	_everything_quantities_flag:DWORD
EXTRN	_eval:PROC
EXTRN	_thread_launch:PROC
EXTRN	_m_type:DWORD
EXTRN	_proc_total_area:BYTE
EXTRN	_binary_tree_add:PROC
EXTRN	_global_timestamp:DWORD
EXTRN	_calc_quant_flag:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@3fe0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\quantity.c
CONST	ENDS
;	COMDAT _calc_quants
_TEXT	SEGMENT
_energy$ = -60						; size = 8
_value$89889 = -52					; size = 8
tv3423 = -44						; size = 4
_mm$89914 = -44						; size = 4
_global_needs$ = -40					; size = 4
_meth_offset$89848 = -36				; size = 4
tv3069 = -32						; size = 4
_todo$ = -32						; size = 4
tv1661 = -28						; size = 4
tv2686 = -24						; size = 4
_needs$89890 = -20					; size = 4
tv2559 = -16						; size = 4
_setup_flag$89888 = -16					; size = 4
_q_info$ = -12						; size = 4
_type$ = -8						; size = 4
_k$ = -4						; size = 4
_mode$ = 8						; size = 4
_calc_quants PROC					; COMDAT

; 1460 : { int k,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 1461 :   struct element *e_ptr;
; 1462 :   struct gen_quant *q = NULL;
; 1463 :   int type; /* element type */
; 1464 :   struct method_instance * mi;
; 1465 :   struct gen_quant_method *gm;
; 1466 :   REAL energy = 0.0;
; 1467 :   struct qinfo *q_info = &(GET_THREAD_DATA->q_info);  /* data passing structure */

	mov	eax, DWORD PTR _thread_data_key
	fldz
	push	edi
	fstp	QWORD PTR _energy$[ebp]
	push	eax
	call	_win_get_thread_data

; 1468 :   int todo = 0; /* whether any to do */

	xor	edi, edi
	add	eax, 56					; 00000038H
	add	esp, 4
	mov	DWORD PTR _q_info$[ebp], eax
	mov	DWORD PTR _todo$[ebp], edi

; 1469 :   int global_needs;
; 1470 : #ifdef PROFILING_ENABLED
; 1471 :   __int64 value_elapsed_time;
; 1472 : #endif
; 1473 : 
; 1474 :   PROF_START(calc_quants);
; 1475 : 
; 1476 :   if ( calc_quant_flag ) return 0.0;

	cmp	DWORD PTR _calc_quant_flag, edi
	je	SHORT $LN135@calc_quant
	fldz
	pop	edi

; 1738 : 
; 1739 :   PROF_FINISH(calc_quants)
; 1740 : 
; 1741 :   return energy;
; 1742 : } /* end calc_quants() */ 

	mov	esp, ebp
	pop	ebp
	ret	0
$LN135@calc_quant:
	push	esi

; 1477 :   calc_quant_flag = 1; /* so no recursive evaluation */

	mov	esi, 1
	mov	DWORD PTR _calc_quant_flag, esi

; 1478 : 
; 1479 :   if ( q_info->xx == NULL )

	cmp	DWORD PTR [eax+1216], edi
	jne	SHORT $LN134@calc_quant

; 1480 :     q_info_init(q_info,METHOD_VALUE);

	push	1767					; 000006e7H
	push	eax
	call	_q_info_init
	add	esp, 8
$LN134@calc_quant:

; 1484 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	fldz
	push	ebx
	mov	DWORD PTR _web+5628, edi
	mov	DWORD PTR _web+5632, edi
	mov	DWORD PTR _web+5636, edi
	mov	DWORD PTR _web+5640, edi
	mov	DWORD PTR _web+5644, edi
	mov	eax, esi
	mov	DWORD PTR _k$[ebp], esi
	cmp	DWORD PTR _web+5560, esi
	jle	$add_to_quantities$89843
$LN250@calc_quant:

; 1485 :   { mi = METH_INSTANCE(k); /* since some init may move things */

	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list

; 1486 :     if ( mi->flags & Q_DELETED ) continue;

	mov	eax, DWORD PTR [esi+140]
	test	eax, 524288				; 00080000H
	jne	$LN129@calc_quant

; 1487 :     gm = basic_gen_methods + mi->gen_method;

	mov	ecx, DWORD PTR [esi+148]
	lea	ebx, DWORD PTR [ecx+ecx*4]
	shl	ebx, 5

; 1488 :     mi->flags |= Q_DOTHIS;

	or	eax, 16					; 00000010H
	lea	ecx, DWORD PTR [esi+152]
	add	ebx, OFFSET _basic_gen_methods
	mov	DWORD PTR [esi+140], eax

; 1489 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )

	xor	edi, edi
	mov	DWORD PTR tv2559[ebp], ecx
$LN235@calc_quant:

; 1490 :     { if ( mi->quants[j] == -1 )

	mov	edx, DWORD PTR tv2559[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, -1
	je	SHORT $LN125@calc_quant

; 1491 :         continue;
; 1492 :       q = GEN_QUANT(mi->quants[j]);
; 1493 :       if ( (!(mi->flags&Q_COMPOUND) &&  
; 1494 :                    ((q->modulus == 0.0) || !(q->flags & mode)))
; 1495 :           || (mi->modulus == 0.0) /* || (mi->timestamp == global_timestamp) */ )

	mov	ecx, DWORD PTR [esi+140]
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list
	mov	edx, eax
	test	ecx, 256				; 00000100H
	jne	SHORT $LN120@calc_quant
	fld	QWORD PTR [edx+176]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN232@calc_quant
	mov	eax, DWORD PTR _mode$[ebp]
	test	DWORD PTR [edx+136], eax
	je	SHORT $LN232@calc_quant
$LN120@calc_quant:
	fld	QWORD PTR [esi+304]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN122@calc_quant
$LN232@calc_quant:

; 1496 :       { mi->flags &= ~Q_DOTHIS;

	and	ecx, -17				; ffffffefH
	mov	DWORD PTR [esi+140], ecx

; 1497 :         if ( q->flags & mode ) 

	mov	ecx, DWORD PTR _mode$[ebp]
	test	DWORD PTR [edx+136], ecx
	je	SHORT $LN125@calc_quant

; 1498 :            mi->timestamp = global_timestamp;

	mov	edx, DWORD PTR _global_timestamp
	mov	DWORD PTR [esi+2924], edx
$LN125@calc_quant:

; 1489 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )

	add	DWORD PTR tv2559[ebp], 4
	inc	edi
	cmp	edi, 8
	jl	SHORT $LN235@calc_quant

; 1481 : 
; 1482 :   /* method initialization */
; 1483 :   for ( type = 0 ; type < NUMELEMENTS ; type++ ) quant_flags[type] = 0;

	jmp	SHORT $LN129@calc_quant
$LN122@calc_quant:

; 1499 :       }
; 1500 :       else
; 1501 :       { int kk;
; 1502 : 	    mi->flags |= Q_DOTHIS;

	or	DWORD PTR [esi+140], 16			; 00000010H

; 1503 :         mi->newvalue = 0.0;

	fst	QWORD PTR [esi+328]

; 1504 :         for ( kk = 0 ; kk < MAXADDENDS ; kk++ ) 
; 1505 :            mi->value_addends[kk] = 0.0;
; 1506 :         mi->abstotal = 0.0;
; 1507 :         mi->timestamp = global_timestamp;
; 1508 :         quant_flags[basic_gen_methods[mi->gen_method].type] |= mode;

	mov	edx, DWORD PTR _mode$[ebp]
	xor	eax, eax
	lea	edi, DWORD PTR [esi+344]
	mov	ecx, 60					; 0000003cH
	rep stosd
	fst	QWORD PTR [esi+336]
	mov	eax, DWORD PTR _global_timestamp
	mov	DWORD PTR [esi+2924], eax
	mov	eax, DWORD PTR [esi+148]
	lea	ecx, DWORD PTR [eax+eax*4]
	shl	ecx, 5
	mov	eax, DWORD PTR _basic_gen_methods[ecx+128]
	or	DWORD PTR _web[eax*4+5628], edx

; 1509 :         if ( gm->init ) 

	mov	eax, DWORD PTR [ebx+140]
	test	eax, eax
	je	SHORT $LN114@calc_quant

; 1510 :            (*gm->init)(METHOD_VALUE,mi);

	push	esi
	fstp	ST(0)
	push	1767					; 000006e7H
	call	eax
	fldz
	add	esp, 8
$LN114@calc_quant:

; 1511 :         todo = 1;

	mov	DWORD PTR _todo$[ebp], 1
$LN129@calc_quant:

; 1484 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _web+5560
	jl	$LN250@calc_quant

; 1512 :         break;
; 1513 :       }
; 1514 :     }
; 1515 :   }
; 1516 : 
; 1517 :   if ( !todo ) goto add_to_quantities;

	cmp	DWORD PTR _todo$[ebp], 0
	je	$add_to_quantities$89843

; 1518 : 
; 1519 :   for ( type = VERTEX ; type <= BODY ; type++ )

	mov	ecx, DWORD PTR _nprocs
	xor	ebx, ebx
	mov	DWORD PTR _type$[ebp], ebx
	mov	DWORD PTR tv3069[ebp], OFFSET _web+48
$LN251@calc_quant:

; 1520 :   if ( quant_flags[type] & mode )

	mov	eax, DWORD PTR _mode$[ebp]
	test	DWORD PTR _web[ebx*4+5628], eax
	je	$LN111@calc_quant

; 1521 :   { int meth_offset = get_meth_offset(type); 

	mov	edx, DWORD PTR _web[ebx*4+5664]
	mov	esi, DWORD PTR tv3069[ebp]
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR [esi+56]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+64]
	mov	DWORD PTR _meth_offset$89848[ebp], edx

; 1522 : #if defined(SHARED_MEMORY)
; 1523 :     if ( (nprocs > 1) || threadflag ) 

	cmp	ecx, 1
	jg	$LN254@calc_quant
	cmp	DWORD PTR _threadflag, 0
	jne	$LN254@calc_quant

; 1563 :     }
; 1564 :     else
; 1565 : #endif
; 1566 :   {
; 1567 :     global_needs = global_meth_needs(type);

	push	ebx
	call	_global_meth_needs

; 1568 :     FOR_ALL_ELEMENTS(type,q_info->id)

	mov	ecx, DWORD PTR _q_info$[ebp]
	mov	DWORD PTR _global_needs$[ebp], eax
	mov	eax, DWORD PTR [esi]
	add	esp, 4
	mov	DWORD PTR [ecx], eax
	test	eax, 268435456				; 10000000H
	je	$LN227@calc_quant
$LN81@calc_quant:
	mov	edx, DWORD PTR _q_info$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR tv1661[ebp], edx
	je	$LN241@calc_quant

; 1570 :       REAL value;
; 1571 :       int needs;
; 1572 :       e_ptr = elptr(q_info->id);
; 1573 :       /* get setup flags */
; 1574 :       needs = global_needs;
; 1575 :       for ( k = 0 ; k < e_ptr->method_count ; k++ )

	movzx	eax, WORD PTR [edx+24]
	mov	esi, DWORD PTR _global_needs$[ebp]
	mov	edi, DWORD PTR _meth_inst_list
	mov	DWORD PTR _setup_flag$89888[ebp], ecx
	mov	DWORD PTR _needs$89890[ebp], esi
	test	eax, eax
	jle	SHORT $LN239@calc_quant

; 1569 :     { int setup_flag = 0;

	mov	ecx, DWORD PTR _meth_offset$89848[ebp]
	add	ecx, edx
	mov	ebx, eax
$LN76@calc_quant:

; 1576 :       { int mm;
; 1577 :         mm = ((int*)((char*)e_ptr+meth_offset))[k];
; 1578 :         mi = METH_INSTANCE(abs(mm));

	mov	eax, DWORD PTR [ecx]
	cdq
	xor	eax, edx
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H

; 1579 :         if ( (mi->flags & Q_DOTHIS) && (mi->type == type) )

	test	BYTE PTR [eax+edi+140], 16		; 00000010H
	je	SHORT $LN75@calc_quant
	mov	edx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+edi+136], edx
	jne	SHORT $LN75@calc_quant

; 1580 :           needs |= basic_gen_methods[mi->gen_method].flags;

	mov	eax, DWORD PTR [eax+edi+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	or	esi, DWORD PTR _basic_gen_methods[eax+132]
$LN75@calc_quant:

; 1570 :       REAL value;
; 1571 :       int needs;
; 1572 :       e_ptr = elptr(q_info->id);
; 1573 :       /* get setup flags */
; 1574 :       needs = global_needs;
; 1575 :       for ( k = 0 ; k < e_ptr->method_count ; k++ )

	add	ecx, 4
	dec	ebx
	jne	SHORT $LN76@calc_quant

; 1580 :           needs |= basic_gen_methods[mi->gen_method].flags;

	mov	DWORD PTR _needs$89890[ebp], esi
$LN239@calc_quant:

; 1581 :       }
; 1582 :       for ( k = 0 ; k < global_meth_inst_count[type] ; k++ )

	mov	ecx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR _web[ecx*4+5588], 0
	mov	ebx, DWORD PTR _q_info$[ebp]
	mov	DWORD PTR _k$[ebp], 0
	jle	$LN70@calc_quant
$LN72@calc_quant:

; 1583 :       { int m =  global_meth_inst[type][k];

	mov	edx, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR _web[edx*4+5568]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]

; 1584 :         mi = METH_INSTANCE(m);

	mov	eax, ecx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H

; 1585 :         if ( (mi->flags & Q_DOTHIS) && (mi->type == type) )

	test	BYTE PTR [esi+edi+140], 16		; 00000010H
	je	$LN71@calc_quant
	mov	edx, DWORD PTR [esi+edi+136]
	cmp	edx, DWORD PTR _type$[ebp]
	jne	$LN71@calc_quant

; 1586 :         { q_info->method = m;
; 1587 :           PROF_START(element_setup);
; 1588 :           if ( !setup_flag ) 

	cmp	DWORD PTR _setup_flag$89888[ebp], 0
	fstp	ST(0)
	mov	DWORD PTR [ebx+8], ecx
	jne	SHORT $LN68@calc_quant

; 1589 :           { (*q_setup[type])(NULL,q_info,needs); setup_flag = 1; }

	mov	eax, DWORD PTR _needs$89890[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR _q_setup[ecx*4]
	push	eax
	push	ebx
	push	0
	call	edx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _setup_flag$89888[ebp], 1
$LN68@calc_quant:

; 1590 :           PROF_FINISH(element_setup);
; 1591 :           mi = METH_INSTANCE(m);  /* may have changed */

	add	esi, DWORD PTR _meth_inst_list

; 1592 :           METHOD_PROFILING_START(mi,value);
; 1593 :           gm = basic_gen_methods + mi->gen_method;
; 1594 :           value = (*gm->value)(q_info);

	push	ebx
	mov	eax, DWORD PTR [esi+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	add	eax, OFFSET _basic_gen_methods
	mov	ecx, DWORD PTR [eax+144]
	call	ecx
	fst	QWORD PTR _value$89889[ebp]
	add	esp, 4

; 1595 :            if ( mi->flags & ELEMENT_MODULUS_FLAG )

	test	DWORD PTR [esi+140], 268435456		; 10000000H
	je	SHORT $LN67@calc_quant

; 1596 :             value *= *(REAL*)get_extra(q_info->id,mi->elmodulus);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [esi+228]
	mov	eax, ecx
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	edi, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edi+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	fmul	QWORD PTR [edx+eax]
	fst	QWORD PTR _value$89889[ebp]
$LN67@calc_quant:

; 1597 :           binary_tree_add(mi->value_addends,value);

	sub	esp, 8
	lea	ecx, DWORD PTR [esi+344]
	fstp	QWORD PTR [esp]
	push	ecx
	call	_binary_tree_add

; 1598 :           mi->abstotal += fabs(value);

	fld	QWORD PTR _value$89889[ebp]
	fabs
	add	esp, 12					; 0000000cH
	fadd	QWORD PTR [esi+336]
	fstp	QWORD PTR [esi+336]
	mov	edi, DWORD PTR _meth_inst_list
	fldz
$LN71@calc_quant:

; 1581 :       }
; 1582 :       for ( k = 0 ; k < global_meth_inst_count[type] ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _type$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _web[edx*4+5588]
	jl	$LN72@calc_quant
$LN70@calc_quant:

; 1599 :           METHOD_PROFILING_END(mi,value);
; 1600 :         }
; 1601 :      }
; 1602 :       for ( k = 0 ; k < (int)e_ptr->method_count ; k++ )

	mov	ecx, DWORD PTR tv1661[ebp]
	xor	eax, eax
	mov	DWORD PTR _k$[ebp], 0
	cmp	ax, WORD PTR [ecx+24]
	jae	$LN80@calc_quant
	mov	eax, ecx
	add	eax, DWORD PTR _meth_offset$89848[ebp]
	mov	DWORD PTR tv2686[ebp], eax
$LN66@calc_quant:

; 1603 :       { int m,mm;
; 1604 :         mm = ((int*)((char*)e_ptr+meth_offset))[k];

	mov	ecx, DWORD PTR tv2686[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _mm$89914[ebp], eax

; 1605 :         m = abs(mm);

	cdq
	xor	eax, edx
	sub	eax, edx

; 1606 :         q_info->method = m;

	mov	DWORD PTR [ebx+8], eax

; 1607 :         mi = METH_INSTANCE(m);

	cdq
	mov	esi, eax
	mov	eax, DWORD PTR _meth_inst_list
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H

; 1608 :         if ( (mi->flags & Q_DOTHIS) && (mi->type == type) )

	test	BYTE PTR [esi+eax+140], 16		; 00000010H
	je	$LN65@calc_quant
	mov	edx, DWORD PTR [esi+eax+136]
	cmp	edx, DWORD PTR _type$[ebp]
	jne	$LN65@calc_quant

; 1609 :         { gm = basic_gen_methods + mi->gen_method;

	mov	ecx, DWORD PTR [esi+eax+148]
	fstp	ST(0)

; 1610 :           PROF_START(element_setup);
; 1611 :           if ( !setup_flag ) 
; 1612 :           { (*q_setup[type])(NULL,q_info,needs); setup_flag = 1; }

	mov	ebx, DWORD PTR _q_info$[ebp]
	lea	edi, DWORD PTR [ecx+ecx*4]
	shl	edi, 5
	add	edi, OFFSET _basic_gen_methods
	cmp	DWORD PTR _setup_flag$89888[ebp], 0
	jne	SHORT $LN62@calc_quant
	mov	eax, DWORD PTR _needs$89890[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR _q_setup[ecx*4]
	push	eax
	push	ebx
	push	0
	call	edx
	mov	eax, DWORD PTR _meth_inst_list
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _setup_flag$89888[ebp], 1
$LN62@calc_quant:

; 1613 :           PROF_FINISH(element_setup);
; 1614 :           mi = METH_INSTANCE(m);

	add	esi, eax

; 1615 :           METHOD_PROFILING_START(mi,value);
; 1616 :           value =  (*gm->value)(q_info);

	mov	eax, DWORD PTR [edi+144]
	push	ebx
	call	eax
	fst	QWORD PTR _value$89889[ebp]
	add	esp, 4

; 1617 :            if ( mi->flags & ELEMENT_MODULUS_FLAG )

	test	DWORD PTR [esi+140], 268435456		; 10000000H
	je	SHORT $LN61@calc_quant

; 1618 :             value *= *(REAL*)get_extra(q_info->id,mi->elmodulus);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [esi+228]
	mov	eax, ecx
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	edi, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edi+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	fmul	QWORD PTR [edx+eax]
	fst	QWORD PTR _value$89889[ebp]
$LN61@calc_quant:

; 1619 :           if (mm < 0) value = -value;

	cmp	DWORD PTR _mm$89914[ebp], 0
	jge	SHORT $LN60@calc_quant
	fchs
	fst	QWORD PTR _value$89889[ebp]
$LN60@calc_quant:

; 1620 :           binary_tree_add(mi->value_addends,value);

	sub	esp, 8
	lea	ecx, DWORD PTR [esi+344]
	fstp	QWORD PTR [esp]
	push	ecx
	call	_binary_tree_add

; 1621 :           mi->abstotal += fabs(value);

	fld	QWORD PTR _value$89889[ebp]
	mov	ebx, DWORD PTR _q_info$[ebp]
	fabs
	fadd	QWORD PTR [esi+336]
	add	esp, 12					; 0000000cH
	fstp	QWORD PTR [esi+336]
	fldz
$LN65@calc_quant:

; 1599 :           METHOD_PROFILING_END(mi,value);
; 1600 :         }
; 1601 :      }
; 1602 :       for ( k = 0 ; k < (int)e_ptr->method_count ; k++ )

	mov	edx, DWORD PTR tv1661[ebp]
	mov	eax, DWORD PTR _k$[ebp]
	movzx	ecx, WORD PTR [edx+24]
	add	DWORD PTR tv2686[ebp], 4
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, ecx
	jl	$LN66@calc_quant
	jmp	SHORT $LN80@calc_quant
$LN241@calc_quant:
	mov	ebx, DWORD PTR _q_info$[ebp]
$LN80@calc_quant:

; 1568 :     FOR_ALL_ELEMENTS(type,q_info->id)

	mov	eax, DWORD PTR [ebx]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ebx], eax
	test	eax, 268435456				; 10000000H
	jne	$LN81@calc_quant

; 1481 : 
; 1482 :   /* method initialization */
; 1483 :   for ( type = 0 ; type < NUMELEMENTS ; type++ ) quant_flags[type] = 0;

	mov	ecx, DWORD PTR _nprocs
	mov	ebx, DWORD PTR _type$[ebp]
	jmp	$LN111@calc_quant
$LN254@calc_quant:

; 1524 :     { int i;
; 1525 :       if ( el_list_timestamp[VERTEX] < top_timestamp )

	mov	edx, DWORD PTR _el_list_timestamp
	cmp	edx, DWORD PTR _top_timestamp
	jge	SHORT $LN246@calc_quant

; 1526 :          make_el_list(VERTEX);  /* need for force */

	push	0
	fstp	ST(0)
	call	_make_el_list
	fldz
	mov	ecx, DWORD PTR _nprocs
	add	esp, 4
$LN246@calc_quant:

; 1527 :       if ( el_list_timestamp[type] < top_timestamp )

	mov	eax, DWORD PTR _top_timestamp
	cmp	DWORD PTR _el_list_timestamp[ebx*4], eax
	jge	SHORT $LN105@calc_quant

; 1528 :          make_el_list(type);

	push	ebx
	fstp	ST(0)
	call	_make_el_list
	fldz
	mov	ecx, DWORD PTR _nprocs
	add	esp, 4
$LN105@calc_quant:

; 1529 :       for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	esi, 1
	cmp	DWORD PTR _web+5560, esi
	jle	SHORT $LN351@calc_quant
$LN104@calc_quant:

; 1530 :       { mi = METH_INSTANCE(k); 

	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 1531 :         if ( mi->flags & Q_DELETED ) continue;

	mov	edx, DWORD PTR [eax+140]
	test	edx, 524288				; 00080000H
	jne	SHORT $LN103@calc_quant

; 1532 :         if ( mi->flags & Q_DOTHIS )

	test	dl, 16					; 00000010H
	je	SHORT $LN103@calc_quant

; 1533 :           for ( i = 0 ; i < nprocs ; i++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN103@calc_quant
	add	eax, 1736				; 000006c8H
$LN99@calc_quant:

; 1534 :           {  mi->procvalue[i] = 0.0;

	fst	QWORD PTR [eax-1152]
	inc	edx

; 1535 :              mi->procabstotal[i] = 0.0;

	fst	QWORD PTR [eax]
	mov	ecx, DWORD PTR _nprocs
	add	eax, 8
	cmp	edx, ecx
	jl	SHORT $LN99@calc_quant
$LN103@calc_quant:

; 1529 :       for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	esi
	cmp	esi, DWORD PTR _web+5560
	jl	SHORT $LN104@calc_quant
$LN351@calc_quant:

; 1533 :           for ( i = 0 ; i < nprocs ; i++ )

	fstp	ST(0)

; 1536 :           }
; 1537 :       }
; 1538 :       for ( i = 0 ; i < nprocs ; i++ ) proc_total_area[i] = 0.0;

	test	ecx, ecx
	jle	SHORT $LN247@calc_quant
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	mov	edi, OFFSET _proc_total_area
	rep stosd
$LN247@calc_quant:

; 1539 : #ifdef SGI_MULTI
; 1540 :       if ( mpflag == M_INACTIVE ) m_rele_procs();  /* resume parked procs */
; 1541 :       mpflag = M_ACTIVE;
; 1542 :       m_fork(multi_calc_quants,type,mode);
; 1543 :       m_park_procs();
; 1544 :       mpflag = M_INACTIVE; 
; 1545 : #endif
; 1546 : #ifdef THREADS
; 1547 :       m_type = type;
; 1548 :       thread_launch(TH_MULTI_CALC_QUANT,type);

	push	ebx
	push	5
	mov	DWORD PTR _m_type, ebx
	call	_thread_launch

; 1549 : #endif
; 1550 : 
; 1551 :       /* sum separate process values */
; 1552 :       for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	ecx, DWORD PTR _nprocs
	mov	edi, 1
	add	esp, 8
	cmp	DWORD PTR _web+5560, edi
	jle	SHORT $LN91@calc_quant
	npad	3
$LL93@calc_quant:

; 1553 :       { mi = METH_INSTANCE(k); 

	mov	eax, edi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 1554 :         if ( mi->flags & Q_DELETED ) continue;

	mov	edx, DWORD PTR [eax+140]
	test	edx, 524288				; 00080000H
	jne	SHORT $LN92@calc_quant

; 1555 :         if ( mi->flags & Q_DOTHIS )

	test	dl, 16					; 00000010H
	je	SHORT $LN92@calc_quant

; 1556 :           for ( i = 0 ; i < nprocs ; i++ )

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN92@calc_quant
	lea	edx, DWORD PTR [eax+1736]
$LL88@calc_quant:

; 1557 :           { mi->newvalue += mi->procvalue[i];

	fld	QWORD PTR [edx-1152]
	inc	esi
	fadd	QWORD PTR [eax+328]
	add	edx, 8
	fstp	QWORD PTR [eax+328]

; 1558 :             mi->abstotal += mi->procabstotal[i];

	fld	QWORD PTR [eax+336]
	fadd	QWORD PTR [edx-8]
	fstp	QWORD PTR [eax+336]
	mov	ecx, DWORD PTR _nprocs
	cmp	esi, ecx
	jl	SHORT $LL88@calc_quant
$LN92@calc_quant:

; 1549 : #endif
; 1550 : 
; 1551 :       /* sum separate process values */
; 1552 :       for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	edi
	cmp	edi, DWORD PTR _web+5560
	jl	SHORT $LL93@calc_quant
$LN91@calc_quant:

; 1559 :           }
; 1560 :       }
; 1561 :       for ( i = 0 ; i < nprocs ; i++ )

	fld	QWORD PTR _web+992
	xor	eax, eax
	cmp	ecx, 4
	jl	SHORT $LC205@calc_quant
	lea	edx, DWORD PTR [ecx-3]
$LN206@calc_quant:

; 1562 :          web.total_area += proc_total_area[i];

	fadd	QWORD PTR _proc_total_area[eax*8]
	add	eax, 4
	fadd	QWORD PTR _proc_total_area[eax*8-24]
	fadd	QWORD PTR _proc_total_area[eax*8-16]
	fadd	QWORD PTR _proc_total_area[eax*8-8]
	cmp	eax, edx
	jl	SHORT $LN206@calc_quant
	fst	QWORD PTR _web+992
$LC205@calc_quant:

; 1559 :           }
; 1560 :       }
; 1561 :       for ( i = 0 ; i < nprocs ; i++ )

	cmp	eax, ecx
	jge	SHORT $LN450@calc_quant
$LC85@calc_quant:

; 1562 :          web.total_area += proc_total_area[i];

	fadd	QWORD PTR _proc_total_area[eax*8]
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LC85@calc_quant
	fstp	QWORD PTR _web+992

; 1481 : 
; 1482 :   /* method initialization */
; 1483 :   for ( type = 0 ; type < NUMELEMENTS ; type++ ) quant_flags[type] = 0;

	jmp	SHORT $LN479@calc_quant
$LN227@calc_quant:
	mov	ecx, DWORD PTR _nprocs
	jmp	SHORT $LN111@calc_quant
$LN450@calc_quant:

; 1559 :           }
; 1560 :       }
; 1561 :       for ( i = 0 ; i < nprocs ; i++ )

	fstp	ST(0)
$LN479@calc_quant:

; 1481 : 
; 1482 :   /* method initialization */
; 1483 :   for ( type = 0 ; type < NUMELEMENTS ; type++ ) quant_flags[type] = 0;

	fldz
$LN111@calc_quant:

; 1518 : 
; 1519 :   for ( type = VERTEX ; type <= BODY ; type++ )

	mov	eax, DWORD PTR tv3069[ebp]
	add	eax, 112				; 00000070H
	inc	ebx
	mov	DWORD PTR _type$[ebp], ebx
	mov	DWORD PTR tv3069[ebp], eax
	cmp	eax, OFFSET _web+384
	jle	$LN251@calc_quant

; 1622 :           METHOD_PROFILING_END(mi,value);
; 1623 :        }
; 1624 :       }
; 1625 :     }
; 1626 :   }
; 1627 :  }
; 1628 : 
; 1629 : 
; 1630 :   /* finish off binary tree addition */
; 1631 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	esi, 1
	cmp	DWORD PTR _web+5560, esi
	jle	$add_to_quantities$89843
$LN59@calc_quant:

; 1632 :   { int kk;
; 1633 :     mi = METH_INSTANCE(k);

	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 1634 :     if ( mi->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax+140]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN58@calc_quant

; 1635 :     if ( mi->flags & Q_DOTHIS )

	test	cl, 16					; 00000010H
	je	SHORT $LN58@calc_quant

; 1636 :       for ( kk = 0 ; kk < MAXADDENDS ; kk++ )

	lea	ecx, DWORD PTR [eax+352]
	mov	edx, 3
$LN54@calc_quant:

; 1637 :         mi->newvalue += mi->value_addends[kk];

	fld	QWORD PTR [ecx-8]
	add	ecx, 80					; 00000050H
	dec	edx
	fadd	QWORD PTR [eax+328]
	fst	QWORD PTR [eax+328]
	fadd	QWORD PTR [ecx-80]
	fst	QWORD PTR [eax+328]
	fadd	QWORD PTR [ecx-72]
	fst	QWORD PTR [eax+328]
	fadd	QWORD PTR [ecx-64]
	fst	QWORD PTR [eax+328]
	fadd	QWORD PTR [ecx-56]
	fst	QWORD PTR [eax+328]
	fadd	QWORD PTR [ecx-48]
	fst	QWORD PTR [eax+328]
	fadd	QWORD PTR [ecx-40]
	fst	QWORD PTR [eax+328]
	fadd	QWORD PTR [ecx-32]
	fst	QWORD PTR [eax+328]
	fadd	QWORD PTR [ecx-24]
	fst	QWORD PTR [eax+328]
	fadd	QWORD PTR [ecx-16]
	fstp	QWORD PTR [eax+328]
	jne	SHORT $LN54@calc_quant
$LN58@calc_quant:

; 1622 :           METHOD_PROFILING_END(mi,value);
; 1623 :        }
; 1624 :       }
; 1625 :     }
; 1626 :   }
; 1627 :  }
; 1628 : 
; 1629 : 
; 1630 :   /* finish off binary tree addition */
; 1631 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	esi
	cmp	esi, DWORD PTR _web+5560
	jl	$LN59@calc_quant
$add_to_quantities$89843:

; 1638 :   }
; 1639 : 
; 1640 :   add_to_quantities:
; 1641 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	esi, 1
	cmp	DWORD PTR _web+5560, esi
	jle	SHORT $LN49@calc_quant
$LN51@calc_quant:

; 1642 :   { mi = METH_INSTANCE(k);

	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 1643 :     if ( mi->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax+140]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN50@calc_quant

; 1644 :     if ( mi->flags & Q_DOTHIS )

	test	cl, 16					; 00000010H
	je	SHORT $LN50@calc_quant

; 1645 :       mi->value = mi->modulus*mi->newvalue;

	fld	QWORD PTR [eax+328]
	fmul	QWORD PTR [eax+304]
	fstp	QWORD PTR [eax+312]
$LN50@calc_quant:

; 1638 :   }
; 1639 : 
; 1640 :   add_to_quantities:
; 1641 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	esi
	cmp	esi, DWORD PTR _web+5560
	jl	SHORT $LN51@calc_quant
$LN49@calc_quant:

; 1646 :   }
; 1647 : 
; 1648 :   /* combine methods to quantities */
; 1649 :   for ( k = 0 ; k < gen_quant_count ; k++ )

	mov	edi, DWORD PTR _gen_quant_list
	xor	edx, edx
	cmp	DWORD PTR _web+5528, edx
	jle	SHORT $LN44@calc_quant
	xor	esi, esi
$LN46@calc_quant:

; 1650 :   { q = GEN_QUANT(k);
; 1651 :     if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [esi+edi+136]
	lea	eax, DWORD PTR [esi+edi]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN45@calc_quant

; 1652 :     if ( q->flags & mode ) 

	test	ecx, DWORD PTR _mode$[ebp]
	je	SHORT $LN45@calc_quant

; 1653 :     { 
; 1654 :       #ifdef MPI_EVOLVER
; 1655 :       q->value = 0.0;
; 1656 :       #else
; 1657 :       q->value = q->volconst;

	fld	QWORD PTR [eax+208]
	fstp	QWORD PTR [eax+152]

; 1658 :       #endif
; 1659 :       q->abstotal = 0.0;

	fst	QWORD PTR [eax+168]

; 1660 :       q->timestamp = global_timestamp;

	mov	ecx, DWORD PTR _global_timestamp
	mov	DWORD PTR [eax+364], ecx
	mov	edi, DWORD PTR _gen_quant_list
$LN45@calc_quant:

; 1646 :   }
; 1647 : 
; 1648 :   /* combine methods to quantities */
; 1649 :   for ( k = 0 ; k < gen_quant_count ; k++ )

	inc	edx
	add	esi, 368				; 00000170H
	cmp	edx, DWORD PTR _web+5528
	jl	SHORT $LN46@calc_quant
$LN44@calc_quant:

; 1661 :     }
; 1662 :   }
; 1663 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	esi, 1
	cmp	DWORD PTR _web+5560, esi
	jle	$LN236@calc_quant
$LN41@calc_quant:

; 1664 :   { mi = METH_INSTANCE(k);

	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 1665 :     if ( mi->flags & Q_DELETED ) continue;

	test	DWORD PTR [eax+140], 524288		; 00080000H
	jne	$LN40@calc_quant

; 1666 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 1667 :     {
; 1668 :       if ( mi->quants[j] < 0 ) continue;

	mov	ecx, DWORD PTR [eax+152]

; 1670 :       if ( q->flags & mode )

	mov	edx, DWORD PTR _mode$[ebp]
	test	ecx, ecx
	js	SHORT $LN36@calc_quant

; 1669 :       q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, edi

; 1670 :       if ( q->flags & mode )

	test	DWORD PTR [ecx+136], edx
	je	SHORT $LN36@calc_quant

; 1671 :       { q->value += mi->value;

	fld	QWORD PTR [eax+312]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 1672 :         q->abstotal += mi->abstotal;

	fld	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN36@calc_quant:

; 1666 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 1667 :     {
; 1668 :       if ( mi->quants[j] < 0 ) continue;

	mov	ecx, DWORD PTR [eax+156]
	test	ecx, ecx
	js	SHORT $LN212@calc_quant

; 1669 :       q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, edi

; 1670 :       if ( q->flags & mode )

	test	DWORD PTR [ecx+136], edx
	je	SHORT $LN212@calc_quant

; 1671 :       { q->value += mi->value;

	fld	QWORD PTR [eax+312]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 1672 :         q->abstotal += mi->abstotal;

	fld	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN212@calc_quant:

; 1666 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 1667 :     {
; 1668 :       if ( mi->quants[j] < 0 ) continue;

	mov	ecx, DWORD PTR [eax+160]
	test	ecx, ecx
	js	SHORT $LN214@calc_quant

; 1669 :       q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, edi

; 1670 :       if ( q->flags & mode )

	test	DWORD PTR [ecx+136], edx
	je	SHORT $LN214@calc_quant

; 1671 :       { q->value += mi->value;

	fld	QWORD PTR [eax+312]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 1672 :         q->abstotal += mi->abstotal;

	fld	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN214@calc_quant:

; 1666 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 1667 :     {
; 1668 :       if ( mi->quants[j] < 0 ) continue;

	mov	ecx, DWORD PTR [eax+164]
	test	ecx, ecx
	js	SHORT $LN216@calc_quant

; 1669 :       q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, edi

; 1670 :       if ( q->flags & mode )

	test	DWORD PTR [ecx+136], edx
	je	SHORT $LN216@calc_quant

; 1671 :       { q->value += mi->value;

	fld	QWORD PTR [eax+312]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 1672 :         q->abstotal += mi->abstotal;

	fld	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN216@calc_quant:

; 1666 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 1667 :     {
; 1668 :       if ( mi->quants[j] < 0 ) continue;

	mov	ecx, DWORD PTR [eax+168]
	test	ecx, ecx
	js	SHORT $LN218@calc_quant

; 1669 :       q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, edi

; 1670 :       if ( q->flags & mode )

	test	DWORD PTR [ecx+136], edx
	je	SHORT $LN218@calc_quant

; 1671 :       { q->value += mi->value;

	fld	QWORD PTR [eax+312]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 1672 :         q->abstotal += mi->abstotal;

	fld	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN218@calc_quant:

; 1666 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 1667 :     {
; 1668 :       if ( mi->quants[j] < 0 ) continue;

	mov	ecx, DWORD PTR [eax+172]
	test	ecx, ecx
	js	SHORT $LN220@calc_quant

; 1669 :       q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, edi

; 1670 :       if ( q->flags & mode )

	test	DWORD PTR [ecx+136], edx
	je	SHORT $LN220@calc_quant

; 1671 :       { q->value += mi->value;

	fld	QWORD PTR [eax+312]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 1672 :         q->abstotal += mi->abstotal;

	fld	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN220@calc_quant:

; 1666 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 1667 :     {
; 1668 :       if ( mi->quants[j] < 0 ) continue;

	mov	ecx, DWORD PTR [eax+176]
	test	ecx, ecx
	js	SHORT $LN222@calc_quant

; 1669 :       q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, edi

; 1670 :       if ( q->flags & mode )

	test	DWORD PTR [ecx+136], edx
	je	SHORT $LN222@calc_quant

; 1671 :       { q->value += mi->value;

	fld	QWORD PTR [eax+312]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 1672 :         q->abstotal += mi->abstotal;

	fld	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN222@calc_quant:

; 1666 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 1667 :     {
; 1668 :       if ( mi->quants[j] < 0 ) continue;

	mov	ecx, DWORD PTR [eax+180]
	test	ecx, ecx
	js	SHORT $LN40@calc_quant

; 1669 :       q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, edi

; 1670 :       if ( q->flags & mode )

	test	DWORD PTR [ecx+136], edx
	je	SHORT $LN40@calc_quant

; 1671 :       { q->value += mi->value;

	fld	QWORD PTR [eax+312]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 1672 :         q->abstotal += mi->abstotal;

	fld	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN40@calc_quant:

; 1661 :     }
; 1662 :   }
; 1663 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	esi
	cmp	esi, DWORD PTR _web+5560
	jl	$LN41@calc_quant
$LN236@calc_quant:

; 1673 :       }
; 1674 :     }
; 1675 :   }
; 1676 :   
; 1677 :   for ( k = compound_quant_list_head ; k >= 0 ; k = q->next_compound )

	mov	eax, DWORD PTR _compound_quant_list_head
	test	eax, eax
	js	SHORT $LN436@calc_quant
$LN32@calc_quant:

; 1678 :   { q = GEN_QUANT(k);

	imul	eax, 368				; 00000170H
	lea	esi, DWORD PTR [edi+eax]

; 1679 :     if ( (q->flags & mode) && ( q->flags & Q_COMPOUND ) && ( q->modulus != 0.0 ) )

	mov	eax, DWORD PTR [esi+136]
	test	DWORD PTR _mode$[ebp], eax
	je	SHORT $LN31@calc_quant
	test	eax, 256				; 00000100H
	je	SHORT $LN31@calc_quant
	fld	QWORD PTR [esi+176]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN31@calc_quant

; 1680 :     {  q->value = eval(&q->expr,NULL,NULLID,NULL);

	push	0
	fstp	ST(0)
	push	0
	lea	edx, DWORD PTR [esi+256]
	push	0
	push	edx
	call	_eval
	fstp	QWORD PTR [esi+152]

; 1681 :        q->abstotal = 1.0;  /* best I can think of for the moment */

	fld1
	add	esp, 16					; 00000010H
	fstp	QWORD PTR [esi+168]
	mov	edi, DWORD PTR _gen_quant_list
	fldz
$LN31@calc_quant:

; 1673 :       }
; 1674 :     }
; 1675 :   }
; 1676 :   
; 1677 :   for ( k = compound_quant_list_head ; k >= 0 ; k = q->next_compound )

	mov	eax, DWORD PTR [esi+360]
	test	eax, eax
	jns	SHORT $LN32@calc_quant
$LN436@calc_quant:

; 1682 :     }
; 1683 :   }
; 1684 :   
; 1685 :   /* set up body volumes */
; 1686 :   if ( (mode & Q_FIXED) && web.torus_flag )

	test	BYTE PTR _mode$[ebp], 2
	fstp	ST(0)
	je	$LN25@calc_quant
	cmp	DWORD PTR _web+860, 0
	je	$LN25@calc_quant

; 1687 :   { /* munge fixed volumes modulo torus volume */
; 1688 :     for ( k = 0 ; k < gen_quant_count ; k++ )

	cmp	DWORD PTR _web+5528, 0
	mov	DWORD PTR _k$[ebp], 0
	jle	$LN25@calc_quant
	fld	QWORD PTR __real@3fe0000000000000
	xor	esi, esi
$LN27@calc_quant:

; 1689 :     { q = GEN_QUANT(k);
; 1690 :       if ( q->flags & Q_DELETED ) continue;

	mov	eax, DWORD PTR [esi+edi+136]
	test	eax, 524288				; 00080000H
	jne	SHORT $LN26@calc_quant

; 1691 :       if ( (q->flags & Q_FIXED) && (q->flags & TORUS_MODULO_MUNGE) ) 

	test	al, 2
	je	SHORT $LN26@calc_quant
	test	eax, 262144				; 00040000H
	je	SHORT $LN26@calc_quant

; 1692 :           q->value -= web.torusv*
; 1693 :                   (int)(0.5+(q->value - q->target)/(q->modulus*web.torusv));

	fld	QWORD PTR [esi+edi+152]
	lea	ebx, DWORD PTR [esi+edi+152]
	fld	ST(0)
	fsub	QWORD PTR [esi+edi+144]
	fld	QWORD PTR [esi+edi+176]
	fld	QWORD PTR _web+1600
	fmul	ST(1), ST(0)
	fxch	ST(2)
	fdivrp	ST(1), ST(0)
	fadd	ST(0), ST(3)
	call	__ftol2_sse
	mov	DWORD PTR tv3423[ebp], eax
	fild	DWORD PTR tv3423[ebp]
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ebx]
	mov	edi, DWORD PTR _gen_quant_list
$LN26@calc_quant:

; 1687 :   { /* munge fixed volumes modulo torus volume */
; 1688 :     for ( k = 0 ; k < gen_quant_count ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	add	esi, 368				; 00000170H
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _web+5528
	jl	SHORT $LN27@calc_quant
	fstp	ST(0)
$LN25@calc_quant:

; 1694 :     }
; 1695 :   }
; 1696 :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN19@calc_quant

; 1697 :   { body_id b_id;
; 1698 :     FOR_ALL_BODIES(b_id)

	mov	edx, DWORD PTR _web+384
	test	edx, 268435456				; 10000000H
	je	SHORT $LN19@calc_quant
$LL21@calc_quant:
	mov	eax, DWORD PTR _web+348
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN20@calc_quant

; 1699 :     { q = GEN_QUANT(get_body_volquant(b_id));

	mov	eax, DWORD PTR [ecx+404]

; 1700 :       if ( q->flags & mode )

	mov	ecx, DWORD PTR _mode$[ebp]
	imul	eax, 368				; 00000170H
	test	DWORD PTR [eax+edi+136], ecx
	je	SHORT $LN20@calc_quant

; 1701 :          set_body_volume(b_id,q->value,SETSTAMP);

	fld	QWORD PTR [eax+edi+152]
	push	1
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	call	_set_body_volume
	mov	edi, DWORD PTR _gen_quant_list
	add	esp, 16					; 00000010H
$LN20@calc_quant:

; 1697 :   { body_id b_id;
; 1698 :     FOR_ALL_BODIES(b_id)

	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [esi+edx]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL21@calc_quant
$LN19@calc_quant:

; 1702 :     }
; 1703 :   }
; 1704 :   
; 1705 :   /* multiply by quantity modulus */
; 1706 :   for ( k = 0 ; k < gen_quant_count ; k++ )

	mov	eax, DWORD PTR _web+5528
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN243@calc_quant
	xor	esi, esi
	npad	9
$LL15@calc_quant:

; 1707 :   { q = GEN_QUANT(k);
; 1708 :     if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [esi+edi+136]
	lea	eax, DWORD PTR [esi+edi]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN14@calc_quant

; 1709 :     if ( q->flags & mode ) 

	test	ecx, DWORD PTR _mode$[ebp]
	je	SHORT $LN14@calc_quant

; 1710 :     {     
; 1711 :       q->value *= q->modulus;    

	fld	QWORD PTR [eax+152]
	fmul	QWORD PTR [eax+176]
	fstp	QWORD PTR [eax+152]

; 1712 :       q->abstotal *= fabs(q->modulus);

	fld	QWORD PTR [eax+176]
	fabs
	fmul	QWORD PTR [eax+168]
	fstp	QWORD PTR [eax+168]

; 1713 :       q->timestamp = global_timestamp;

	mov	ecx, DWORD PTR _global_timestamp
	mov	DWORD PTR [eax+364], ecx
	mov	edi, DWORD PTR _gen_quant_list
$LN14@calc_quant:

; 1702 :     }
; 1703 :   }
; 1704 :   
; 1705 :   /* multiply by quantity modulus */
; 1706 :   for ( k = 0 ; k < gen_quant_count ; k++ )

	mov	eax, DWORD PTR _web+5528
	inc	edx
	add	esi, 368				; 00000170H
	cmp	edx, eax
	jl	SHORT $LL15@calc_quant
$LN243@calc_quant:

; 1714 :     }
; 1715 :   }
; 1716 : 
; 1717 :   /* add to total energy, if needed */
; 1718 :   if ( mode & Q_ENERGY )

	test	BYTE PTR _mode$[ebp], 1
	pop	ebx
	je	SHORT $LN255@calc_quant

; 1719 :   {
; 1720 :      for ( k = 0 ; k < gen_quant_count ; k++ )

	test	eax, eax
	jle	SHORT $LN255@calc_quant
	fld	QWORD PTR _energy$[ebp]
	add	edi, 152				; 00000098H
$LN9@calc_quant:

; 1721 :      { q = GEN_QUANT(k);
; 1722 :        if ( q->flags & Q_ENERGY ) 

	test	BYTE PTR [edi-16], 1
	je	SHORT $LN8@calc_quant

; 1723 :           energy += q->value;

	fadd	QWORD PTR [edi]
$LN8@calc_quant:

; 1719 :   {
; 1720 :      for ( k = 0 ; k < gen_quant_count ; k++ )

	add	edi, 368				; 00000170H
	dec	eax
	jne	SHORT $LN9@calc_quant

; 1723 :           energy += q->value;

	fst	QWORD PTR _energy$[ebp]

; 1719 :   {
; 1720 :      for ( k = 0 ; k < gen_quant_count ; k++ )

	jmp	SHORT $LN7@calc_quant
$LN255@calc_quant:
	fld	QWORD PTR _energy$[ebp]
$LN7@calc_quant:

; 1724 :      }
; 1725 :   }
; 1726 : 
; 1727 :   
; 1728 : 
; 1729 :   /* take care of any cleanup */
; 1730 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	esi, 1
	cmp	DWORD PTR _web+5560, esi
	jle	SHORT $LN257@calc_quant
$LN5@calc_quant:

; 1731 :   { mi = METH_INSTANCE(k); /* since some init may move things */

	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 1732 :     if ( mi->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax+140]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN4@calc_quant

; 1733 :     gm = basic_gen_methods + mi->gen_method;

	mov	eax, DWORD PTR [eax+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	add	eax, OFFSET _basic_gen_methods

; 1734 :     if ( gm->cleanup && mi->flags & Q_DOTHIS ) gm->cleanup();

	mov	eax, DWORD PTR [eax+156]
	test	eax, eax
	je	SHORT $LN4@calc_quant
	test	cl, 16					; 00000010H
	je	SHORT $LN4@calc_quant
	fstp	ST(0)
	call	eax
	fld	QWORD PTR _energy$[ebp]
$LN4@calc_quant:

; 1724 :      }
; 1725 :   }
; 1726 : 
; 1727 :   
; 1728 : 
; 1729 :   /* take care of any cleanup */
; 1730 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	esi
	cmp	esi, DWORD PTR _web+5560
	jl	SHORT $LN5@calc_quant
$LN257@calc_quant:
	pop	esi

; 1735 :   }
; 1736 : 
; 1737 :   calc_quant_flag = 0;

	mov	DWORD PTR _calc_quant_flag, 0
	pop	edi

; 1738 : 
; 1739 :   PROF_FINISH(calc_quants)
; 1740 : 
; 1741 :   return energy;
; 1742 : } /* end calc_quants() */ 

	mov	esp, ebp
	pop	ebp
	ret	0
_calc_quants ENDP
_TEXT	ENDS
PUBLIC	_quantity_attribute
; Function compile flags: /Ogtp
;	COMDAT _quantity_attribute
_TEXT	SEGMENT
_retval$ = -32						; size = 8
_methlist$ = -24					; size = 4
tv471 = -20						; size = 4
_mm$90039 = -20						; size = 4
tv433 = -16						; size = 4
_e_ptr$ = -16						; size = 4
_needs$ = -12						; size = 4
tv416 = -8						; size = 4
_q_info$ = -4						; size = 4
_k$ = 8							; size = 4
_id$ = 8						; size = 4
_qnum$ = 12						; size = 4
_quantity_attribute PROC				; COMDAT

; 1757 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1758 :   int k;
; 1759 :   struct element *e_ptr;
; 1760 :   struct gen_quant *q;
; 1761 :   int type = id_type(id); /* element type */
; 1762 :   struct method_instance *mi;
; 1763 :   struct gen_quant_method *gm;
; 1764 :   REAL retval = 0.0,value;
; 1765 :   struct qinfo *q_info = &(GET_THREAD_DATA->q_info);  /* data passing structure */

	mov	eax, DWORD PTR _thread_data_key
	fldz
	push	ebx
	fstp	QWORD PTR _retval$[ebp]
	push	esi
	mov	esi, DWORD PTR _id$[ebp]
	push	edi
	mov	edi, esi
	shr	edi, 29					; 0000001dH
	push	eax
	mov	DWORD PTR tv416[ebp], edi
	call	_win_get_thread_data

; 1766 :   int meth_offset = EXTRAS(type)[web.meth_attr[type]].offset;

	mov	edx, DWORD PTR _web[edi*4+5664]

; 1767 :   int *methlist = (int*)((char*)elptr(id) + meth_offset);

	mov	ecx, edi
	imul	edx, 240				; 000000f0H
	imul	ecx, 112				; 00000070H
	lea	ebx, DWORD PTR [eax+56]
	lea	eax, DWORD PTR _web[ecx+12]
	mov	ecx, edi
	imul	ecx, 112				; 00000070H
	add	edx, DWORD PTR _web[ecx+104]
	mov	ecx, DWORD PTR [eax]
	and	esi, 134217727				; 07ffffffH
	mov	DWORD PTR tv433[ebp], eax
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax+64]
	add	esi, esi
	add	esi, esi
	add	eax, DWORD PTR [esi+ecx]
	add	esp, 4

; 1768 :   int needs = 0;
; 1769 :     
; 1770 :   if ( q_info->xx == NULL )

	cmp	DWORD PTR [ebx+1216], 0
	mov	DWORD PTR _q_info$[ebp], ebx
	mov	DWORD PTR _methlist$[ebp], eax
	mov	DWORD PTR _needs$[ebp], 0
	jne	SHORT $LN26@quantity_a

; 1771 :     q_info_init(q_info,METHOD_VALUE);

	push	1767					; 000006e7H
	push	ebx
	call	_q_info_init
	add	esp, 8
$LN26@quantity_a:

; 1772 : 
; 1773 :   q_info->id = id;

	mov	ecx, DWORD PTR _id$[ebp]

; 1774 :   e_ptr = elptr(q_info->id);

	mov	edx, DWORD PTR tv433[ebp]
	mov	DWORD PTR [ebx], ecx
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [esi+eax]

; 1775 :   (*q_setup[type])(NULL,q_info,needs);

	mov	edx, DWORD PTR _q_setup[edi*4]
	push	0
	push	ebx
	push	0
	mov	DWORD PTR _e_ptr$[ebp], ecx
	call	edx

; 1776 :   for ( k = 0 ; k < global_meth_inst_count[type] ; k++ )

	xor	eax, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR _web[edi*4+5588], eax
	jle	$LN44@quantity_a
	npad	1
$LL48@quantity_a:

; 1777 :   { int j;
; 1778 :     mi = METH_INSTANCE(global_meth_inst[type][k]);

	mov	ecx, DWORD PTR _web[edi*4+5568]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv471[ebp], eax
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list

; 1779 :     if ( mi->flags & Q_DELETED ) continue;

	test	DWORD PTR [esi+140], 524288		; 00080000H
	jne	$LN24@quantity_a

; 1780 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )

	xor	eax, eax
	lea	ecx, DWORD PTR [esi+152]
$LL21@quantity_a:

; 1781 :       if ( mi->quants[j] == qnum )

	mov	edx, DWORD PTR _qnum$[ebp]
	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN37@quantity_a

; 1780 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )

	inc	eax
	add	ecx, 4
	cmp	eax, 8
	jl	SHORT $LL21@quantity_a
$LN37@quantity_a:

; 1782 :         break;
; 1783 :     if ( j == MMAXQUANTS ) continue;

	cmp	eax, 8
	je	$LN24@quantity_a

; 1784 :     if ( mi->type != type ) continue;

	cmp	DWORD PTR [esi+136], edi
	jne	$LN24@quantity_a

; 1785 :     q =  GEN_QUANT(qnum);
; 1786 :     q_info->method = global_meth_inst[type][k];
; 1787 :     gm = basic_gen_methods + mi->gen_method;
; 1788 :     if ( (gm->flags & ALL_NEEDS) & ~needs )

	mov	ecx, DWORD PTR _needs$[ebp]
	mov	edi, edx
	mov	edx, DWORD PTR tv471[ebp]
	imul	edi, 368				; 00000170H
	add	edi, DWORD PTR _gen_quant_list
	mov	DWORD PTR [ebx+8], edx
	mov	ebx, DWORD PTR [esi+148]
	lea	ebx, DWORD PTR [ebx+ebx*4]
	shl	ebx, 5
	add	ebx, OFFSET _basic_gen_methods
	mov	eax, DWORD PTR [ebx+132]
	mov	edx, ecx
	not	edx
	and	edx, eax
	test	edx, 65520				; 0000fff0H
	je	SHORT $LN15@quantity_a

; 1789 :     { needs |= gm->flags; (*q_setup[type])(NULL,q_info,needs); }

	or	ecx, eax
	mov	eax, DWORD PTR _q_info$[ebp]
	push	ecx
	mov	DWORD PTR _needs$[ebp], ecx
	mov	ecx, DWORD PTR tv416[ebp]
	mov	edx, DWORD PTR _q_setup[ecx*4]
	push	eax
	push	0
	call	edx
	add	esp, 12					; 0000000cH
$LN15@quantity_a:

; 1790 :     value = q->modulus*mi->modulus*(*gm->value)(q_info);

	mov	eax, DWORD PTR _q_info$[ebp]
	mov	ecx, DWORD PTR [ebx+144]
	push	eax
	call	ecx
	fld	QWORD PTR [esi+304]
	fmul	QWORD PTR [edi+176]
	add	esp, 4

; 1791 :     if ( mi->flags & ELEMENT_MODULUS_FLAG )

	test	DWORD PTR [esi+140], 268435456		; 10000000H
	fmulp	ST(1), ST(0)
	je	SHORT $LN14@quantity_a

; 1792 :        value *= *(REAL*)get_extra(q_info->id,mi->elmodulus);

	mov	edx, DWORD PTR _q_info$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [esi+228]
	mov	eax, ecx
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	esi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	esi, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [esi+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	fmul	QWORD PTR [edx+eax]
$LN14@quantity_a:

; 1793 :     retval += value;

	fadd	QWORD PTR _retval$[ebp]
	mov	edi, DWORD PTR tv416[ebp]
	mov	ebx, DWORD PTR _q_info$[ebp]
	fstp	QWORD PTR _retval$[ebp]
$LN24@quantity_a:

; 1776 :   for ( k = 0 ; k < global_meth_inst_count[type] ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _web[edi*4+5588]
	jl	$LL48@quantity_a
$LN44@quantity_a:

; 1794 :   }
; 1795 :   for ( k = 0 ; k < (int)e_ptr->method_count ; k++ )

	mov	edx, DWORD PTR _e_ptr$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _k$[ebp], 0
	cmp	cx, WORD PTR [edx+24]
	jae	$LN43@quantity_a
$LL47@quantity_a:

; 1796 :   { int mm = methlist[k];

	mov	ecx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _methlist$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _mm$90039[ebp], eax

; 1797 :     int m = abs(mm);

	cdq
	xor	eax, edx
	sub	eax, edx

; 1798 :     int j;
; 1799 :     q_info->method =  m;

	mov	DWORD PTR [ebx+8], eax

; 1800 :     mi = METH_INSTANCE(m);

	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list

; 1801 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )

	xor	eax, eax
	lea	ecx, DWORD PTR [esi+152]
$LL10@quantity_a:

; 1802 :       if ( mi->quants[j] == qnum )

	mov	edx, DWORD PTR _qnum$[ebp]
	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN38@quantity_a

; 1801 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )

	inc	eax
	add	ecx, 4
	cmp	eax, 8
	jl	SHORT $LL10@quantity_a
$LN38@quantity_a:

; 1803 :         break;
; 1804 :     if ( j == MMAXQUANTS ) continue;

	cmp	eax, 8
	je	$LN12@quantity_a

; 1805 :     if ( mi->type != type ) continue;

	cmp	DWORD PTR [esi+136], edi
	jne	$LN12@quantity_a

; 1806 :     q =  GEN_QUANT(qnum);
; 1807 :     gm = basic_gen_methods + mi->gen_method;

	mov	ebx, DWORD PTR [esi+148]

; 1808 :     if ( (gm->flags & ALL_NEEDS) & ~needs )

	mov	ecx, DWORD PTR _needs$[ebp]
	mov	edi, edx
	imul	edi, 368				; 00000170H
	add	edi, DWORD PTR _gen_quant_list
	lea	ebx, DWORD PTR [ebx+ebx*4]
	shl	ebx, 5
	add	ebx, OFFSET _basic_gen_methods
	mov	eax, DWORD PTR [ebx+132]
	mov	edx, ecx
	not	edx
	and	edx, eax
	test	edx, 65520				; 0000fff0H
	je	SHORT $LN4@quantity_a

; 1809 :     { needs |= gm->flags; (*q_setup[type])(NULL,q_info,needs); }

	or	ecx, eax
	mov	eax, DWORD PTR _q_info$[ebp]
	push	ecx
	mov	DWORD PTR _needs$[ebp], ecx
	mov	ecx, DWORD PTR tv416[ebp]
	mov	edx, DWORD PTR _q_setup[ecx*4]
	push	eax
	push	0
	call	edx
	add	esp, 12					; 0000000cH
$LN4@quantity_a:

; 1810 :     value = q->modulus*mi->modulus*(*gm->value)(q_info);

	mov	eax, DWORD PTR _q_info$[ebp]
	mov	ecx, DWORD PTR [ebx+144]
	push	eax
	call	ecx
	fld	QWORD PTR [esi+304]
	fmul	QWORD PTR [edi+176]
	add	esp, 4

; 1811 :     if ( mi->flags & ELEMENT_MODULUS_FLAG )

	test	DWORD PTR [esi+140], 268435456		; 10000000H
	fmulp	ST(1), ST(0)
	je	SHORT $LN3@quantity_a

; 1812 :        value *= *(REAL*)get_extra(q_info->id,mi->elmodulus);

	mov	edx, DWORD PTR _q_info$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [esi+228]
	mov	eax, ecx
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	esi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	esi, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [esi+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	fmul	QWORD PTR [edx+eax]
$LN3@quantity_a:

; 1813 :     if ( mm < 0 ) retval -= value;

	cmp	DWORD PTR _mm$90039[ebp], 0
	mov	edi, DWORD PTR tv416[ebp]
	mov	ebx, DWORD PTR _q_info$[ebp]
	jge	SHORT $LN2@quantity_a
	fsubr	QWORD PTR _retval$[ebp]
	jmp	SHORT $LN58@quantity_a
$LN2@quantity_a:

; 1814 :     else  retval += value;

	fadd	QWORD PTR _retval$[ebp]
$LN58@quantity_a:
	fstp	QWORD PTR _retval$[ebp]
$LN12@quantity_a:

; 1794 :   }
; 1795 :   for ( k = 0 ; k < (int)e_ptr->method_count ; k++ )

	mov	ecx, DWORD PTR _e_ptr$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
	movzx	edx, WORD PTR [ecx+24]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, edx
	jl	$LL47@quantity_a
$LN43@quantity_a:

; 1815 :   }
; 1816 : 
; 1817 :   return retval;

	fld	QWORD PTR _retval$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 1818 : } // end quantity_attribute()

	mov	esp, ebp
	pop	ebp
	ret	0
_quantity_attribute ENDP
_TEXT	ENDS
PUBLIC	_instance_attribute
; Function compile flags: /Ogtp
;	COMDAT _instance_attribute
_TEXT	SEGMENT
_retval$ = -36						; size = 8
_mm$90092 = -28						; size = 4
_methlist$ = -24					; size = 4
tv336 = -20						; size = 4
tv362 = -16						; size = 4
_needs$ = -12						; size = 4
_e_ptr$ = -8						; size = 4
tv341 = -4						; size = 4
tv533 = 8						; size = 4
_gm$ = 8						; size = 4
_k$ = 8							; size = 4
_id$ = 8						; size = 4
_qnum$ = 12						; size = 4
_instance_attribute PROC				; COMDAT

; 1834 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1835 :   int k;
; 1836 :   struct element *e_ptr;
; 1837 :   int type = id_type(id); /* element type */
; 1838 :   struct method_instance *mi=NULL;
; 1839 :   struct gen_quant_method *gm;
; 1840 :   REAL retval = 0.0;
; 1841 :   struct qinfo *q_info = &(GET_THREAD_DATA->q_info);  /* data passing structure */

	mov	eax, DWORD PTR _thread_data_key
	fldz
	push	ebx
	fstp	QWORD PTR _retval$[ebp]
	mov	ebx, DWORD PTR _id$[ebp]
	push	esi
	push	edi
	push	eax
	shr	ebx, 29					; 0000001dH
	xor	esi, esi
	call	_win_get_thread_data

; 1842 :   int meth_offset = EXTRAS(type)[web.meth_attr[type]].offset;
; 1843 :   int *methlist = (int*)((char*)elptr(id) + meth_offset);

	mov	ecx, DWORD PTR _id$[ebp]
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	lea	edi, DWORD PTR [eax+56]
	mov	DWORD PTR tv341[ebp], ecx
	mov	ecx, DWORD PTR _web[ebx*4+5664]
	imul	ecx, 240				; 000000f0H
	mov	edx, ebx
	imul	edx, 112				; 00000070H
	add	ecx, DWORD PTR _web[edx+104]
	mov	eax, ebx
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	mov	DWORD PTR tv336[ebp], eax
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [ecx+eax+64]
	mov	ecx, DWORD PTR tv341[ebp]
	add	eax, DWORD PTR [ecx+edx]
	add	esp, 4
	mov	DWORD PTR _methlist$[ebp], eax

; 1844 :   int needs = 0;

	mov	DWORD PTR _needs$[ebp], esi

; 1845 : 
; 1846 :   if ( q_info->xx == NULL )

	cmp	DWORD PTR [edi+1216], esi
	jne	SHORT $LN16@instance_a

; 1847 :     q_info_init(q_info,METHOD_VALUE);

	push	1767					; 000006e7H
	push	edi
	call	_q_info_init
	add	esp, 8
$LN16@instance_a:

; 1848 : 
; 1849 :   q_info->id = id;

	mov	edx, DWORD PTR _id$[ebp]

; 1850 :   e_ptr = elptr(q_info->id);

	mov	eax, DWORD PTR tv336[ebp]
	mov	DWORD PTR [edi], edx
	mov	ecx, DWORD PTR _web[eax+12]
	mov	edx, DWORD PTR tv341[ebp]
	mov	eax, DWORD PTR [edx+ecx]

; 1851 :   (*q_setup[type])(NULL,q_info,needs);

	mov	ecx, DWORD PTR _q_setup[ebx*4]
	push	0
	mov	DWORD PTR _e_ptr$[ebp], eax
	lea	eax, DWORD PTR _q_setup[ebx*4]
	push	edi
	push	0
	mov	DWORD PTR tv362[ebp], eax
	call	ecx

; 1852 :   for ( k = 0 ; k < global_meth_inst_count[type] ; k++ )

	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web[ebx*4+5588], ecx
	jle	SHORT $LN27@instance_a

; 1848 : 
; 1849 :   q_info->id = id;

	mov	edx, DWORD PTR _web[ebx*4+5568]
	mov	DWORD PTR tv533[ebp], edx
	npad	1
$LL15@instance_a:

; 1853 :   { if ( qnum != global_meth_inst[type][k] ) continue;

	mov	eax, DWORD PTR tv533[ebp]
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR _qnum$[ebp], eax
	jne	SHORT $LN14@instance_a

; 1854 :     mi = METH_INSTANCE(global_meth_inst[type][k]);

	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list

; 1855 :     if ( mi->type != type ) continue;

	cmp	DWORD PTR [esi+136], ebx
	je	SHORT $LN11@instance_a
$LN14@instance_a:

; 1852 :   for ( k = 0 ; k < global_meth_inst_count[type] ; k++ )

	add	DWORD PTR tv533[ebp], 4
	inc	ecx
	cmp	ecx, DWORD PTR _web[ebx*4+5588]
	jl	SHORT $LL15@instance_a
$LN27@instance_a:

; 1860 :     retval += mi->modulus*(*gm->value)(q_info);

	fld	QWORD PTR _retval$[ebp]
$LN13@instance_a:

; 1861 :     break;
; 1862 :   }
; 1863 :   for ( k = 0 ; k < (int)e_ptr->method_count ; k++ )

	mov	eax, DWORD PTR _e_ptr$[ebp]
	xor	edx, edx
	mov	DWORD PTR _k$[ebp], 0
	cmp	dx, WORD PTR [eax+24]
	jae	$LN2@instance_a
$LN28@instance_a:

; 1864 :   { int mm = methlist[k];

	mov	ecx, DWORD PTR _methlist$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _mm$90092[ebp], eax

; 1865 :     int m = abs(mm);

	cdq
	mov	ecx, eax
	xor	ecx, edx
	sub	ecx, edx

; 1866 :     if ( qnum != m ) continue;

	cmp	DWORD PTR _qnum$[ebp], ecx
	jne	SHORT $LN8@instance_a

; 1867 :     mi = METH_INSTANCE(m);

	mov	eax, ecx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list

; 1868 :     q_info->method = m;

	mov	DWORD PTR [edi+8], ecx

; 1869 :     if ( mi->type != type ) continue;

	cmp	DWORD PTR [esi+136], ebx
	je	SHORT $LN36@instance_a
$LN8@instance_a:

; 1861 :     break;
; 1862 :   }
; 1863 :   for ( k = 0 ; k < (int)e_ptr->method_count ; k++ )

	mov	ecx, DWORD PTR _e_ptr$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
	movzx	edx, WORD PTR [ecx+24]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, edx
	jl	SHORT $LN28@instance_a

; 1852 :   for ( k = 0 ; k < global_meth_inst_count[type] ; k++ )

	jmp	$LN2@instance_a
$LN11@instance_a:

; 1856 :     q_info->method = global_meth_inst[type][k];

	mov	eax, DWORD PTR _web[ebx*4+5568]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 1857 :     gm = basic_gen_methods + mi->gen_method;

	mov	eax, DWORD PTR [esi+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	add	eax, OFFSET _basic_gen_methods

; 1858 :     if ( (gm->flags & ALL_NEEDS) & ~needs )

	mov	ecx, DWORD PTR [eax+132]
	mov	DWORD PTR _gm$[ebp], eax
	test	ecx, 65520				; 0000fff0H
	je	SHORT $LN10@instance_a

; 1859 :     { needs |= gm->flags; (*q_setup[type])(NULL,q_info,needs); }

	mov	edx, DWORD PTR tv362[ebp]
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	edi
	push	0
	mov	DWORD PTR _needs$[ebp], ecx
	call	eax
	mov	eax, DWORD PTR _gm$[ebp]
	add	esp, 12					; 0000000cH
$LN10@instance_a:

; 1860 :     retval += mi->modulus*(*gm->value)(q_info);

	mov	ecx, DWORD PTR [eax+144]
	push	edi
	call	ecx
	fmul	QWORD PTR [esi+304]
	add	esp, 4
	fadd	QWORD PTR __real@0000000000000000
	fst	QWORD PTR _retval$[ebp]
	jmp	$LN13@instance_a
$LN36@instance_a:

; 1870 :     gm = basic_gen_methods + mi->gen_method;

	mov	eax, DWORD PTR [esi+148]
	fstp	ST(0)

; 1871 :     if ( (gm->flags & ALL_NEEDS) & ~needs )

	mov	ecx, DWORD PTR _needs$[ebp]
	lea	ebx, DWORD PTR [eax+eax*4]
	shl	ebx, 5
	add	ebx, OFFSET _basic_gen_methods
	mov	eax, DWORD PTR [ebx+132]
	mov	edx, ecx
	not	edx
	and	edx, eax
	test	edx, 65520				; 0000fff0H
	je	SHORT $LN29@instance_a

; 1872 :     { needs |= gm->flags; (*q_setup[type])(NULL,q_info,needs); }

	or	eax, ecx
	push	eax
	mov	eax, DWORD PTR tv362[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edi
	push	0
	call	ecx
	add	esp, 12					; 0000000cH
$LN29@instance_a:

; 1873 :     if ( mm < 0 ) retval -=  mi->modulus*(*gm->value)(q_info);

	cmp	DWORD PTR _mm$90092[ebp], 0
	push	edi
	jge	SHORT $LN3@instance_a
	mov	edx, DWORD PTR [ebx+144]
	call	edx
	fmul	QWORD PTR [esi+304]
	fsubr	QWORD PTR _retval$[ebp]
	jmp	SHORT $LN45@instance_a
$LN3@instance_a:

; 1874 :     else retval +=  mi->modulus*(*gm->value)(q_info);

	mov	eax, DWORD PTR [ebx+144]
	call	eax
	fmul	QWORD PTR [esi+304]
	fadd	QWORD PTR _retval$[ebp]
$LN45@instance_a:
	add	esp, 4
$LN2@instance_a:

; 1875 :     break;
; 1876 :   } 
; 1877 :   if ( mi && (mi->flags & ELEMENT_MODULUS_FLAG) )

	test	esi, esi
	je	SHORT $LN1@instance_a
	test	DWORD PTR [esi+140], 268435456		; 10000000H
	je	SHORT $LN1@instance_a

; 1878 :        retval *= *(REAL*)get_extra(id,METH_INSTANCE(qnum)->elmodulus);

	mov	eax, DWORD PTR _qnum$[ebp]
	mov	ecx, DWORD PTR _meth_inst_list
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	mov	edx, DWORD PTR [eax+ecx+228]
	mov	eax, DWORD PTR tv336[ebp]
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web[eax+104]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ecx+64]
	mov	eax, DWORD PTR _web[eax+12]
	mov	ecx, DWORD PTR tv341[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	fmul	QWORD PTR [edx+eax]
$LN1@instance_a:
	pop	edi
	pop	esi
	pop	ebx

; 1879 : 
; 1880 :   return retval;
; 1881 : } // end instance_attribute()

	mov	esp, ebp
	pop	ebp
	ret	0
_instance_attribute ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EM@PPNKPFOK@Too?5many?5vertices?5in?5method?5for?5@ ; `string'
PUBLIC	_type$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_m_calc_quant_grads
EXTRN	_get_bv_new_vgrad:PROC
EXTRN	_pmax:BYTE
EXTRN	_ptop:BYTE
EXTRN	_vector_add_smul:PROC
EXTRN	_sym_form_pullback:DWORD
;	COMDAT ??_C@_0EM@PPNKPFOK@Too?5many?5vertices?5in?5method?5for?5@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EM@PPNKPFOK@Too?5many?5vertices?5in?5method?5for?5@ DB 'Too many v'
	DB	'ertices in method for compound quantity, due to lazy programm'
	DB	'er.', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\quantity.c
CONST	ENDS
;	COMDAT _m_calc_quant_grads
_TEXT	SEGMENT
tv869 = -184						; size = 8
_meth_offset$93288 = -176				; size = 4
_c$90216 = -172						; size = 8
_data$90138 = -164					; size = 4
_q$90210 = -160						; size = 4
tv712 = -156						; size = 4
tv1240 = -152						; size = 4
_th$90137 = -148					; size = 4
_global_needs$ = -144					; size = 4
_meth_offset$ = -140					; size = 4
_i$ = -136						; size = 4
_maxstage$90139 = -132					; size = 4
_needs$90154 = -128					; size = 4
tv327 = -124						; size = 4
tv1463 = -120						; size = 4
_e_ptr$ = -116						; size = 4
tv524 = -112						; size = 4
_setup_flag$90153 = -108				; size = 4
_mi$ = -104						; size = 4
tv1440 = -100						; size = 4
_idptr$90134 = -96					; size = 4
_inum$ = -92						; size = 4
_flag$ = -88						; size = 4
_ff$90218 = -84						; size = 4
_k$90152 = -80						; size = 4
_me$ = -76						; size = 4
tv695 = -72						; size = 4
tv1511 = -68						; size = 4
_sign$90171 = -68					; size = 4
_type$GSCopy$ = -64					; size = 4
_j$ = -60						; size = 4
_q_info$ = -56						; size = 4
_wforce$90217 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_type$ = 8						; size = 4
_m_calc_quant_grads PROC				; COMDAT

; 1897 : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1898 :   struct element *e_ptr;
; 1899 :   volgrad *vgptr;  /* constraint gradients */
; 1900 :   int flag;  /* 0 if doing global quantities, 1 for local */
; 1901 :   vertex_id v;
; 1902 :   struct gen_quant_method *gm;
; 1903 :   struct method_instance  *mi;
; 1904 :   REAL val;
; 1905 :   REAL *f;
; 1906 :   int inum;
; 1907 :   struct qinfo *q_info = &(GET_THREAD_DATA->q_info);  /* data passing structure */

	mov	eax, DWORD PTR _thread_data_key
	push	ebx
	push	esi
	mov	esi, DWORD PTR _type$[ebp]
	push	edi
	push	eax
	mov	DWORD PTR _type$GSCopy$[ebp], esi
	call	_win_get_thread_data

; 1908 :   int meth_offset = get_meth_offset(type); 

	mov	ecx, DWORD PTR _web[esi*4+5664]
	imul	esi, 112				; 00000070H
	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web[esi+104]
	add	eax, 56					; 00000038H
	mov	DWORD PTR _q_info$[ebp], eax
	mov	eax, DWORD PTR [ecx+edx+64]
	mov	DWORD PTR _meth_offset$93288[ebp], eax
	mov	DWORD PTR _meth_offset$[ebp], eax

; 1909 :   int me = GET_THREAD_ID;

	mov	eax, DWORD PTR _thread_data_key
	push	eax
	call	_win_get_thread_data
	mov	esi, DWORD PTR [eax]

; 1910 :   int global_needs;
; 1911 : 
; 1912 : #ifdef SIGUSR1
; 1913 :   signal(SIGUSR1,catcher);    /* to catch user interrupt */   
; 1914 : #endif
; 1915 :   signal(SIGINT,catcher);    /* to catch user interrupt */     

	push	OFFSET _catcher
	push	2
	mov	DWORD PTR _me$[ebp], esi
	call	_signal

; 1916 :   m_breakflag[me] = 0;

	mov	DWORD PTR _m_breakflag[esi*4], 0

; 1917 :   if ( setjmp(m_jumpbuf[me]) ) { return; }

	shl	esi, 6
	add	esi, OFFSET _m_jumpbuf
	push	0
	push	esi
	call	__setjmp3
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	$LN60@m_calc_qua

; 1918 : 
; 1919 :   if ( q_info->grad == NULL )

	mov	ecx, DWORD PTR _q_info$[ebp]
	cmp	DWORD PTR [ecx+1336], 0
	lea	eax, DWORD PTR [ecx+1336]
	mov	DWORD PTR tv695[ebp], eax
	jne	SHORT $LN63@m_calc_qua

; 1920 :     q_info_init(q_info,METHOD_GRADIENT);

	push	4321					; 000010e1H
	push	ecx
	call	_q_info_init
	add	esp, 8
$LN63@m_calc_qua:

; 1921 : 
; 1922 : 
; 1923 :   global_needs = global_meth_needs(type);

	mov	ecx, DWORD PTR _type$GSCopy$[ebp]
	push	ecx
	call	_global_meth_needs

; 1924 : 
; 1925 :   THREAD_FOR_ALL_NEW(type,  /* following block is macro argument! */
; 1926 :   { int k;
; 1927 :     int setup_flag = 0;
; 1928 :     int needs;
; 1929 : 
; 1930 :     q_info->id = *idptr;
; 1931 :     e_ptr = elptr(q_info->id);
; 1932 : 
; 1933 :     /* get setup flags */
; 1934 :     needs = global_needs;
; 1935 :     for ( k = 0 ; k < e_ptr->method_count ; k++ )
; 1936 :     { int mm;
; 1937 :       mm = ((int*)((char*)e_ptr+meth_offset))[k];
; 1938 :       mi = METH_INSTANCE(abs(mm));
; 1939 :       if ( (mi->flags & Q_DOTHIS) && (mi->type == type) )
; 1940 :         needs |= basic_gen_methods[mi->gen_method].flags;
; 1941 :     }
; 1942 : 
; 1943 :     inum = global_meth_inst_count[type];
; 1944 :     for ( flag = 0 ; flag < 2 ; flag++,inum = e_ptr->method_count,k=0 )
; 1945 :      for ( k = 0 ; k < inum ; k++ )
; 1946 :      { int mm;
; 1947 :        int sign = 1;
; 1948 :        if ( flag ) 
; 1949 :        { mm = ((int*)((char*)e_ptr+meth_offset))[k];
; 1950 :          q_info->method = abs(mm);
; 1951 :          if ( mm < 0 ) sign = -1;
; 1952 :        }
; 1953 :        else  q_info->method = global_meth_inst[type][k];
; 1954 :        mi = METH_INSTANCE(q_info->method);
; 1955 : 
; 1956 :        if ( (mi->flags & Q_DOTHIS) && (mi->type == type) )
; 1957 :        { int m;
; 1958 :          REAL *p;
; 1959 :          REAL **pp;
; 1960 :          gm = basic_gen_methods + mi->gen_method;
; 1961 :          if ( !setup_flag ) 
; 1962 :          { (*q_setup[type])(NULL,q_info,needs); setup_flag = 1; }
; 1963 :          for ( i = 0, pp = q_info->grad ; i < q_info->vcount ; i++,pp++ )
; 1964 :            for ( j = 0, p = *pp ; j < SDIM ; j++,p++ ) *p = 0.0;
; 1965 :          val = (*gm->gradient)(q_info);
; 1966 :          mi = METH_INSTANCE(q_info->method);
; 1967 :          if ( mi->flags & ELEMENT_MODULUS_FLAG )
; 1968 :          { REAL emdls = *(REAL*)get_extra(q_info->id,mi->elmodulus);
; 1969 :            val *= emdls;
; 1970 :            for ( i = 0 ; i < q_info->vcount ; i++ )
; 1971 :                for ( j = 0 ; j < SDIM ; j++ )
; 1972 :                     q_info->grad[i][j] *= emdls;
; 1973 :          }
; 1974 :          mi->procvalue[me] += sign*val;
; 1975 :          mi->procabstotal[me] += fabs(val);
; 1976 :          if ( mi->flags & Q_COMPOUND )
; 1977 :          { if ( q_info->vcount > MAXCOORD+2 )
; 1978 :              kb_error(2181,
; 1979 : "Too many vertices in method for compound quantity, due to lazy programmer.\n",
; 1980 : RECOVERABLE);
; 1981 :            for ( i = 0 ; i < q_info->vcount ; i++ )
; 1982 :              for ( j = 0 ; j < SDIM ; j++ )
; 1983 :                mi->grad[i][j] = q_info->grad[i][j];
; 1984 :          }
; 1985 :          for ( m = 0 ; m < MMAXQUANTS ; m++ )
; 1986 :          { struct gen_quant *q;
; 1987 :            if ( mi->quants[m] < 0 )
; 1988 :               continue;
; 1989 :            q = GEN_QUANT(mi->quants[m]);
; 1990 :            if ( !(mi->flags & Q_COMPOUND) )
; 1991 :            for ( i = 0 ; i < q_info->vcount ; i++ )
; 1992 :            { REAL c;
; 1993 :              REAL wforce[MAXCOORD];  /* unwrapped forces */
; 1994 :              REAL *ff;
; 1995 :              v = q_info->v[i];
; 1996 :              if ( q_info->wraps[i] )
; 1997 :              {  (*sym_form_pullback)(q_info->x[i],wforce,q_info->grad[i],
; 1998 :                               q_info->wraps[i]);
; 1999 :                 ff = wforce;
; 2000 :              }
; 2001 :              else ff = q_info->grad[i];
; 2002 :              
; 2003 :              c = sign*mi->modulus*q->modulus;
; 2004 :              if ( q->flags & Q_ENERGY )
; 2005 :              { int procnum = v_procnum[loc_ordinal(v)]; 
; 2006 :                if ( procnum == me )
; 2007 :                { /* no conflicts */
; 2008 :                  f = get_force(v);
; 2009 :                  vector_add_smul(f,ff,-c, SDIM);
; 2010 :                }
; 2011 :                else /* have to save */
; 2012 :                { int newp = ptop[me]++;
; 2013 :                  struct procforce *pf;
; 2014 :                  if ( newp >= pmax[me] )
; 2015 :                  { pbase[me] = (struct procforce *)kb_realloc(
; 2016 :                        (char*)(pbase[me]),2*pmax[me]*sizeof(struct procforce));
; 2017 :                    pmax[me] = 2*pmax[me];
; 2018 :                  }
; 2019 :                  pf = pbase[me] + newp;
; 2020 :                  pf->v_id = v;
; 2021 :                  pf->next = phead[procnum][me];
; 2022 :                  phead[procnum][me] = newp;
; 2023 :                  for ( j = 0 ; j < SDIM ; j++ )
; 2024 :                     pf->f[j] = -c*ff[j];
; 2025 :                }
; 2026 :              }
; 2027 :              else 
; 2028 :              { M_LOCK(vgradbase);
; 2029 :                vgptr = get_bv_new_vgrad(q->fixnum,v);
; 2030 :                vgptr->bb_id = q->b_id;
; 2031 :                vgptr->qnum = mi->quants[j];
; 2032 :                vector_add_smul(vgptr->grad,ff, c, SDIM);
; 2033 :                M_UNLOCK(vgradbase);
; 2034 :              }
; 2035 :            }
; 2036 :         } // end for quants loop
; 2037 :      } // end if
; 2038 :    }
; 2039 :   }
; 2040 :  ) /* end of macro */

	mov	edx, DWORD PTR _thread_data_key
	push	edx
	mov	DWORD PTR _global_needs$[ebp], eax
	call	_win_get_thread_data
	mov	edi, eax
	mov	eax, DWORD PTR _nprocs
	mov	ecx, DWORD PTR [edi]
	dec	eax
	add	esp, 8
	mov	DWORD PTR _data$90138[ebp], edi
	cmp	ecx, eax
	jne	SHORT $LN67@m_calc_qua
	xor	eax, eax
	jmp	SHORT $LN68@m_calc_qua
$LN67@m_calc_qua:
	lea	eax, DWORD PTR [ecx+1]
$LN68@m_calc_qua:
	mov	ebx, DWORD PTR _max_thread_stages
	test	ecx, ecx
	jne	SHORT $LN69@m_calc_qua
	inc	ebx
$LN69@m_calc_qua:
	imul	ecx, 548				; 00000224H
	add	ecx, DWORD PTR _thread_stages
	mov	DWORD PTR _maxstage$90139[ebp], ebx
	mov	DWORD PTR [ecx+540], 0
	mov	edx, DWORD PTR [ecx+540]
	mov	DWORD PTR _th$90137[ebp], ecx
	cmp	edx, ebx
	jge	$LN60@m_calc_qua
	fldz
	imul	eax, 548				; 00000224H
	add	eax, 540				; 0000021cH
	mov	DWORD PTR tv712[ebp], eax
$LN59@m_calc_qua:
	mov	edx, DWORD PTR tv712[ebp]
	mov	eax, DWORD PTR _thread_stages
	mov	eax, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [ecx+540]
	cmp	eax, edx
	jl	SHORT $LN59@m_calc_qua
	mov	esi, DWORD PTR [ecx+540]
	rdtsc
	mov	DWORD PTR [edi+esi*8+1808], eax
	mov	eax, DWORD PTR _type$GSCopy$[ebp]
	mov	DWORD PTR [edi+esi*8+1812], edx
	mov	edx, DWORD PTR [ecx+540]
	lea	eax, DWORD PTR [eax+eax*8]
	add	eax, edx
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [ecx+540]
	mov	DWORD PTR _idptr$90134[ebp], eax
	mov	eax, DWORD PTR _type$GSCopy$[ebp]
	lea	eax, DWORD PTR [eax+eax*8+45]
	add	edx, eax
	mov	eax, DWORD PTR [ecx+edx*4]
	test	eax, eax
	jle	$LN55@m_calc_qua
	mov	esi, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv327[ebp], eax
$LN57@m_calc_qua:
	mov	eax, DWORD PTR _idptr$90134[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR _q_info$[ebp]
	mov	ebx, DWORD PTR _global_needs$[ebp]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	movzx	ecx, WORD PTR [eax+24]
	mov	DWORD PTR _setup_flag$90153[ebp], 0
	mov	DWORD PTR _e_ptr$[ebp], eax
	mov	DWORD PTR _needs$90154[ebp], ebx
	test	ecx, ecx
	jle	SHORT $LN52@m_calc_qua
	mov	edx, DWORD PTR _meth_offset$[ebp]
	lea	edi, DWORD PTR [eax+edx]
$LN54@m_calc_qua:
	mov	eax, DWORD PTR [edi]
	cdq
	xor	eax, edx
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list
	test	BYTE PTR [eax+140], 16			; 00000010H
	je	SHORT $LN53@m_calc_qua
	mov	edx, DWORD PTR _type$GSCopy$[ebp]
	cmp	DWORD PTR [eax+136], edx
	jne	SHORT $LN53@m_calc_qua
	mov	eax, DWORD PTR [eax+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	or	ebx, DWORD PTR _basic_gen_methods[eax+132]
$LN53@m_calc_qua:
	add	edi, 4
	dec	ecx
	jne	SHORT $LN54@m_calc_qua
	mov	DWORD PTR _needs$90154[ebp], ebx
$LN52@m_calc_qua:
	mov	ecx, DWORD PTR _type$GSCopy$[ebp]
	mov	edx, DWORD PTR _web[ecx*4+5588]
	mov	DWORD PTR _inum$[ebp], edx
	mov	DWORD PTR _flag$[ebp], 0
$LN50@m_calc_qua:
	cmp	DWORD PTR _inum$[ebp], 0
	mov	DWORD PTR _k$90152[ebp], 0
	jle	$LN49@m_calc_qua
	mov	eax, DWORD PTR _e_ptr$[ebp]
	add	eax, DWORD PTR _meth_offset$[ebp]
	mov	DWORD PTR tv1240[ebp], eax
$LN47@m_calc_qua:
	cmp	DWORD PTR _flag$[ebp], 0
	mov	eax, DWORD PTR _k$90152[ebp]
	mov	DWORD PTR _sign$90171[ebp], 1
	je	SHORT $LN44@m_calc_qua
	mov	edx, DWORD PTR tv1240[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, ecx
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR _q_info$[ebp]
	xor	edi, edx
	sub	edi, edx
	mov	DWORD PTR [eax+8], edi
	test	ecx, ecx
	jns	SHORT $LN42@m_calc_qua
	mov	DWORD PTR _sign$90171[ebp], -1
	jmp	SHORT $LN42@m_calc_qua
$LN44@m_calc_qua:
	mov	ecx, DWORD PTR _type$GSCopy$[ebp]
	mov	edx, DWORD PTR _web[ecx*4+5568]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _q_info$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN42@m_calc_qua:
	mov	eax, DWORD PTR [eax+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list
	test	BYTE PTR [eax+140], 16			; 00000010H
	je	$LN46@m_calc_qua
	mov	edx, DWORD PTR _type$GSCopy$[ebp]
	cmp	DWORD PTR [eax+136], edx
	jne	$LN46@m_calc_qua
	mov	eax, DWORD PTR [eax+148]
	lea	ebx, DWORD PTR [eax+eax*4]
	shl	ebx, 5
	add	ebx, OFFSET _basic_gen_methods
	cmp	DWORD PTR _setup_flag$90153[ebp], 0
	jne	SHORT $LN40@m_calc_qua
	mov	eax, DWORD PTR _needs$90154[ebp]
	fstp	ST(0)
	mov	ecx, DWORD PTR _q_info$[ebp]
	push	eax
	mov	eax, DWORD PTR _q_setup[edx*4]
	push	ecx
	push	0
	call	eax
	fldz
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _setup_flag$90153[ebp], 1
$LN40@m_calc_qua:
	mov	eax, DWORD PTR _q_info$[ebp]
	mov	ecx, DWORD PTR tv695[ebp]
	mov	edx, DWORD PTR [ecx]
	xor	edi, edi
	cmp	DWORD PTR [eax+12], edi
	jle	SHORT $LN155@m_calc_qua
	mov	ecx, DWORD PTR _web+616
$LN39@m_calc_qua:
	mov	eax, DWORD PTR [edx]
	xor	esi, esi
	mov	DWORD PTR _j$[ebp], esi
	test	ecx, ecx
	jle	SHORT $LN38@m_calc_qua
$LN36@m_calc_qua:
	fst	QWORD PTR [eax]
	mov	ecx, DWORD PTR _web+616
	inc	esi
	add	eax, 8
	cmp	esi, ecx
	jl	SHORT $LN36@m_calc_qua
	mov	DWORD PTR _j$[ebp], esi
$LN38@m_calc_qua:
	mov	eax, DWORD PTR _q_info$[ebp]
	inc	edi
	add	edx, 4
	cmp	edi, DWORD PTR [eax+12]
	jl	SHORT $LN39@m_calc_qua
$LN155@m_calc_qua:
	mov	edi, DWORD PTR _q_info$[ebp]
	fstp	ST(0)
	mov	ecx, DWORD PTR [ebx+148]
	push	edi
	call	ecx
	mov	eax, DWORD PTR [edi+8]
	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
	imul	edi, 2928				; 00000b70H
	add	edi, DWORD PTR _meth_inst_list
	add	esp, 4
	test	DWORD PTR [edi+140], 268435456		; 10000000H
	mov	DWORD PTR _mi$[ebp], edi
	je	$LN112@m_calc_qua
	mov	edx, DWORD PTR _q_info$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edi+228]
	mov	eax, ecx
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ebx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	ebx, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [ebx+edx+64]
	mov	ebx, DWORD PTR _q_info$[ebp]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	fld	QWORD PTR [edx+eax]
	xor	edx, edx
	fld	ST(0)
	fmulp	ST(2), ST(0)
	cmp	DWORD PTR [ebx+12], edx
	jle	SHORT $LN174@m_calc_qua
	mov	ecx, DWORD PTR _web+616
$LN32@m_calc_qua:
	xor	esi, esi
	mov	DWORD PTR _j$[ebp], esi
	test	ecx, ecx
	jle	SHORT $LN31@m_calc_qua
	mov	ecx, DWORD PTR tv695[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+edx*4]
$LN29@m_calc_qua:
	fld	QWORD PTR [eax]
	inc	esi
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	esi, ecx
	jl	SHORT $LN29@m_calc_qua
	mov	DWORD PTR _j$[ebp], esi
$LN31@m_calc_qua:
	inc	edx
	cmp	edx, DWORD PTR [ebx+12]
	jl	SHORT $LN32@m_calc_qua
$LN174@m_calc_qua:
	fstp	ST(0)
	jmp	SHORT $LN30@m_calc_qua
$LN112@m_calc_qua:
	mov	ebx, DWORD PTR _q_info$[ebp]
$LN30@m_calc_qua:
	fild	DWORD PTR _sign$90171[ebp]
	mov	eax, DWORD PTR _me$[ebp]
	fst	QWORD PTR tv869[ebp]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [edi+eax*8+584]
	fstp	QWORD PTR [edi+eax*8+584]
	fabs
	fadd	QWORD PTR [edi+eax*8+1736]
	fstp	QWORD PTR [edi+eax*8+1736]
	test	DWORD PTR [edi+140], 256		; 00000100H
	je	SHORT $LN22@m_calc_qua
	cmp	DWORD PTR [ebx+12], 8
	jle	SHORT $LN25@m_calc_qua
	push	1
	push	OFFSET ??_C@_0EM@PPNKPFOK@Too?5many?5vertices?5in?5method?5for?5@
	push	2181					; 00000885H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN25@m_calc_qua:
	xor	eax, eax
	cmp	DWORD PTR [ebx+12], eax
	jle	SHORT $LN22@m_calc_qua
$LN24@m_calc_qua:
	xor	esi, esi
	mov	DWORD PTR _j$[ebp], esi
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN23@m_calc_qua
	mov	ecx, DWORD PTR tv695[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+eax*4]
	npad	10
$LL21@m_calc_qua:
	mov	edx, DWORD PTR [edi+2896]
	fld	QWORD PTR [ecx+esi*8]
	mov	edx, DWORD PTR [edx+eax*4]
	fstp	QWORD PTR [edx+esi*8]
	inc	esi
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL21@m_calc_qua
	mov	DWORD PTR _j$[ebp], esi
$LN23@m_calc_qua:
	inc	eax
	cmp	eax, DWORD PTR [ebx+12]
	jl	SHORT $LN24@m_calc_qua
$LN22@m_calc_qua:
	add	edi, 152				; 00000098H
	mov	DWORD PTR tv1511[ebp], edi
	mov	DWORD PTR tv524[ebp], 8
$LL18@m_calc_qua:
	mov	eax, DWORD PTR tv1511[ebp]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	js	$LN17@m_calc_qua
	mov	ecx, DWORD PTR _mi$[ebp]
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list
	test	DWORD PTR [ecx+140], 256		; 00000100H
	mov	DWORD PTR _q$90210[ebp], eax
	jne	$LN17@m_calc_qua
	mov	edx, DWORD PTR _q_info$[ebp]
	cmp	DWORD PTR [edx+12], 0
	mov	DWORD PTR _i$[ebp], 0
	jle	$LN17@m_calc_qua
	mov	ecx, edx
	lea	eax, DWORD PTR [ecx+816]
	mov	DWORD PTR tv1440[ebp], eax
	mov	eax, -816				; fffffcd0H
	sub	eax, ecx
	mov	DWORD PTR tv1463[ebp], eax
	npad	1
$LL13@m_calc_qua:
	mov	eax, DWORD PTR tv1440[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax-800]
	test	ecx, ecx
	je	SHORT $LN10@m_calc_qua
	push	ecx
	mov	ecx, DWORD PTR tv695[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR tv1463[ebp]
	mov	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [eax-400]
	push	ecx
	lea	edx, DWORD PTR _wforce$90217[ebp]
	push	edx
	push	eax
	call	DWORD PTR _sym_form_pullback
	lea	ecx, DWORD PTR _wforce$90217[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ff$90218[ebp], ecx
	jmp	SHORT $LN9@m_calc_qua
$LN10@m_calc_qua:
	mov	edx, DWORD PTR tv695[ebp]
	mov	ecx, DWORD PTR [edx]
	add	ecx, DWORD PTR tv1463[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _ff$90218[ebp], edx
$LN9@m_calc_qua:
	fld	QWORD PTR tv869[ebp]
	mov	eax, DWORD PTR _mi$[ebp]
	fmul	QWORD PTR [eax+304]
	mov	ebx, DWORD PTR _q$90210[ebp]
	test	BYTE PTR [ebx+136], 1
	fmul	QWORD PTR [ebx+176]
	fst	QWORD PTR _c$90216[ebp]
	je	$LN187@m_calc_qua
	test	edi, 268435456				; 10000000H
	je	SHORT $LN71@m_calc_qua
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN72@m_calc_qua
$LN71@m_calc_qua:
	or	eax, -1
$LN72@m_calc_qua:
	mov	ecx, DWORD PTR _v_procnum
	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _me$[ebp]
	cmp	ebx, ecx
	jne	SHORT $LN7@m_calc_qua
	mov	edx, DWORD PTR _web+616
	fchs
	mov	ecx, DWORD PTR _web+12
	mov	eax, DWORD PTR _ff$90218[ebp]
	push	edx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	mov	eax, DWORD PTR _web+104
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+784]
	push	edx
	call	_vector_add_smul
	add	esp, 20					; 00000014H
	jmp	$LN12@m_calc_qua
$LN7@m_calc_qua:
	mov	esi, DWORD PTR _ptop[ecx*4]
	mov	eax, DWORD PTR _pmax[ecx*4]
	lea	edx, DWORD PTR [esi+1]
	mov	DWORD PTR _ptop[ecx*4], edx
	cmp	esi, eax
	jl	SHORT $LN5@m_calc_qua
	imul	eax, 112				; 00000070H
	fstp	ST(0)
	push	2040					; 000007f8H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	eax
	mov	eax, DWORD PTR _me$[ebp]
	mov	ecx, DWORD PTR _pbase[eax*4]
	push	ecx
	call	_KB_realloc
	mov	ecx, DWORD PTR _me$[ebp]
	mov	edx, DWORD PTR _pmax[ecx*4]
	fld	QWORD PTR _c$90216[ebp]
	add	esp, 16					; 00000010H
	add	edx, edx
	mov	DWORD PTR _pbase[ecx*4], eax
	mov	DWORD PTR _pmax[ecx*4], edx
$LN5@m_calc_qua:
	mov	edx, DWORD PTR _pbase[ecx*4]
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	eax, DWORD PTR [edx+eax*8]
	lea	edx, DWORD PTR [ebx+ebx*8]
	shl	edx, 4
	add	edx, ecx
	lea	ecx, DWORD PTR _phead[edx*4]
	mov	DWORD PTR [eax], edi
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [ecx], esi
	xor	esi, esi
	mov	DWORD PTR _j$[ebp], esi
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN200@m_calc_qua
	mov	ecx, DWORD PTR _ff$90218[ebp]
	add	eax, 8
$LN4@m_calc_qua:
	fld	QWORD PTR [ecx+esi*8]
	inc	esi
	fmul	ST(0), ST(1)
	add	eax, 8
	fchs
	fstp	QWORD PTR [eax-8]
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LN4@m_calc_qua
	mov	DWORD PTR _j$[ebp], esi
$LN200@m_calc_qua:
	fstp	ST(0)
$LN12@m_calc_qua:
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _q_info$[ebp]
	add	DWORD PTR tv1440[ebp], 4
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [ecx+12]
	jl	$LL13@m_calc_qua
$LN17@m_calc_qua:
	add	DWORD PTR tv1511[ebp], 4
	dec	DWORD PTR tv524[ebp]
	jne	$LL18@m_calc_qua
	fldz
$LN46@m_calc_qua:
	mov	eax, DWORD PTR _k$90152[ebp]
	inc	eax
	mov	DWORD PTR _k$90152[ebp], eax
	cmp	eax, DWORD PTR _inum$[ebp]
	jl	$LN47@m_calc_qua
$LN49@m_calc_qua:
	mov	eax, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _e_ptr$[ebp]
	movzx	ecx, WORD PTR [edx+24]
	inc	eax
	mov	DWORD PTR _flag$[ebp], eax
	mov	DWORD PTR _inum$[ebp], ecx
	cmp	eax, 2
	jl	$LN50@m_calc_qua
	add	DWORD PTR _idptr$90134[ebp], 4
	dec	DWORD PTR tv327[ebp]
	jne	$LN57@m_calc_qua
	mov	edi, DWORD PTR _data$90138[ebp]
	mov	ecx, DWORD PTR _th$90137[ebp]
	mov	ebx, DWORD PTR _maxstage$90139[ebp]
$LN55@m_calc_qua:
	mov	esi, DWORD PTR [ecx+540]
	rdtsc
	mov	DWORD PTR [edi+esi*8+1880], eax
	mov	DWORD PTR [edi+esi*8+1884], edx
	inc	DWORD PTR [ecx+540]
	mov	edx, DWORD PTR [ecx+540]
	cmp	edx, ebx
	jl	$LN59@m_calc_qua
	fstp	ST(0)
$LN60@m_calc_qua:

; 2041 : 
; 2042 : } /* m_calc_quant_grads */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN187@m_calc_qua:

; 1924 : 
; 1925 :   THREAD_FOR_ALL_NEW(type,  /* following block is macro argument! */
; 1926 :   { int k;
; 1927 :     int setup_flag = 0;
; 1928 :     int needs;
; 1929 : 
; 1930 :     q_info->id = *idptr;
; 1931 :     e_ptr = elptr(q_info->id);
; 1932 : 
; 1933 :     /* get setup flags */
; 1934 :     needs = global_needs;
; 1935 :     for ( k = 0 ; k < e_ptr->method_count ; k++ )
; 1936 :     { int mm;
; 1937 :       mm = ((int*)((char*)e_ptr+meth_offset))[k];
; 1938 :       mi = METH_INSTANCE(abs(mm));
; 1939 :       if ( (mi->flags & Q_DOTHIS) && (mi->type == type) )
; 1940 :         needs |= basic_gen_methods[mi->gen_method].flags;
; 1941 :     }
; 1942 : 
; 1943 :     inum = global_meth_inst_count[type];
; 1944 :     for ( flag = 0 ; flag < 2 ; flag++,inum = e_ptr->method_count,k=0 )
; 1945 :      for ( k = 0 ; k < inum ; k++ )
; 1946 :      { int mm;
; 1947 :        int sign = 1;
; 1948 :        if ( flag ) 
; 1949 :        { mm = ((int*)((char*)e_ptr+meth_offset))[k];
; 1950 :          q_info->method = abs(mm);
; 1951 :          if ( mm < 0 ) sign = -1;
; 1952 :        }
; 1953 :        else  q_info->method = global_meth_inst[type][k];
; 1954 :        mi = METH_INSTANCE(q_info->method);
; 1955 : 
; 1956 :        if ( (mi->flags & Q_DOTHIS) && (mi->type == type) )
; 1957 :        { int m;
; 1958 :          REAL *p;
; 1959 :          REAL **pp;
; 1960 :          gm = basic_gen_methods + mi->gen_method;
; 1961 :          if ( !setup_flag ) 
; 1962 :          { (*q_setup[type])(NULL,q_info,needs); setup_flag = 1; }
; 1963 :          for ( i = 0, pp = q_info->grad ; i < q_info->vcount ; i++,pp++ )
; 1964 :            for ( j = 0, p = *pp ; j < SDIM ; j++,p++ ) *p = 0.0;
; 1965 :          val = (*gm->gradient)(q_info);
; 1966 :          mi = METH_INSTANCE(q_info->method);
; 1967 :          if ( mi->flags & ELEMENT_MODULUS_FLAG )
; 1968 :          { REAL emdls = *(REAL*)get_extra(q_info->id,mi->elmodulus);
; 1969 :            val *= emdls;
; 1970 :            for ( i = 0 ; i < q_info->vcount ; i++ )
; 1971 :                for ( j = 0 ; j < SDIM ; j++ )
; 1972 :                     q_info->grad[i][j] *= emdls;
; 1973 :          }
; 1974 :          mi->procvalue[me] += sign*val;
; 1975 :          mi->procabstotal[me] += fabs(val);
; 1976 :          if ( mi->flags & Q_COMPOUND )
; 1977 :          { if ( q_info->vcount > MAXCOORD+2 )
; 1978 :              kb_error(2181,
; 1979 : "Too many vertices in method for compound quantity, due to lazy programmer.\n",
; 1980 : RECOVERABLE);
; 1981 :            for ( i = 0 ; i < q_info->vcount ; i++ )
; 1982 :              for ( j = 0 ; j < SDIM ; j++ )
; 1983 :                mi->grad[i][j] = q_info->grad[i][j];
; 1984 :          }
; 1985 :          for ( m = 0 ; m < MMAXQUANTS ; m++ )
; 1986 :          { struct gen_quant *q;
; 1987 :            if ( mi->quants[m] < 0 )
; 1988 :               continue;
; 1989 :            q = GEN_QUANT(mi->quants[m]);
; 1990 :            if ( !(mi->flags & Q_COMPOUND) )
; 1991 :            for ( i = 0 ; i < q_info->vcount ; i++ )
; 1992 :            { REAL c;
; 1993 :              REAL wforce[MAXCOORD];  /* unwrapped forces */
; 1994 :              REAL *ff;
; 1995 :              v = q_info->v[i];
; 1996 :              if ( q_info->wraps[i] )
; 1997 :              {  (*sym_form_pullback)(q_info->x[i],wforce,q_info->grad[i],
; 1998 :                               q_info->wraps[i]);
; 1999 :                 ff = wforce;
; 2000 :              }
; 2001 :              else ff = q_info->grad[i];
; 2002 :              
; 2003 :              c = sign*mi->modulus*q->modulus;
; 2004 :              if ( q->flags & Q_ENERGY )
; 2005 :              { int procnum = v_procnum[loc_ordinal(v)]; 
; 2006 :                if ( procnum == me )
; 2007 :                { /* no conflicts */
; 2008 :                  f = get_force(v);
; 2009 :                  vector_add_smul(f,ff,-c, SDIM);
; 2010 :                }
; 2011 :                else /* have to save */
; 2012 :                { int newp = ptop[me]++;
; 2013 :                  struct procforce *pf;
; 2014 :                  if ( newp >= pmax[me] )
; 2015 :                  { pbase[me] = (struct procforce *)kb_realloc(
; 2016 :                        (char*)(pbase[me]),2*pmax[me]*sizeof(struct procforce));
; 2017 :                    pmax[me] = 2*pmax[me];
; 2018 :                  }
; 2019 :                  pf = pbase[me] + newp;
; 2020 :                  pf->v_id = v;
; 2021 :                  pf->next = phead[procnum][me];
; 2022 :                  phead[procnum][me] = newp;
; 2023 :                  for ( j = 0 ; j < SDIM ; j++ )
; 2024 :                     pf->f[j] = -c*ff[j];
; 2025 :                }
; 2026 :              }
; 2027 :              else 
; 2028 :              { M_LOCK(vgradbase);
; 2029 :                vgptr = get_bv_new_vgrad(q->fixnum,v);
; 2030 :                vgptr->bb_id = q->b_id;
; 2031 :                vgptr->qnum = mi->quants[j];
; 2032 :                vector_add_smul(vgptr->grad,ff, c, SDIM);
; 2033 :                M_UNLOCK(vgradbase);
; 2034 :              }
; 2035 :            }
; 2036 :         } // end for quants loop
; 2037 :      } // end if
; 2038 :    }
; 2039 :   }
; 2040 :  ) /* end of macro */

	mov	eax, DWORD PTR [ebx+224]
	fstp	ST(0)
	push	edi
	push	eax
	call	_get_bv_new_vgrad
	fld	QWORD PTR _c$90216[ebp]
	mov	ecx, DWORD PTR [ebx+216]
	mov	edx, DWORD PTR _mi$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+esi*4+152]
	add	esp, 8
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR _web+616
	mov	ecx, DWORD PTR _ff$90218[ebp]
	push	edx
	mov	edx, DWORD PTR [eax+16]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	push	edx
	call	_vector_add_smul
	add	esp, 20					; 00000014H
	jmp	$LN12@m_calc_qua
_m_calc_quant_grads ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_calc_quant_grads
EXTRN	_eval_all:PROC
EXTRN	_comp_quant_vertex:DWORD
EXTRN	_vgrad_init:PROC
EXTRN	_vgradbase:DWORD
EXTRN	_comp_quant_stamp:DWORD
; Function compile flags: /Ogtp
;	COMDAT _calc_quant_grads
_TEXT	SEGMENT
_dummy$90441 = -144					; size = 8
_c$90387 = -136						; size = 8
tv1925 = -128						; size = 8
_global_needs$ = -120					; size = 4
tv1258 = -116						; size = 4
_meth_offset$90311 = -112				; size = 4
tv3322 = -108						; size = 4
_setup_flag$90362 = -104				; size = 4
_needs$90363 = -100					; size = 4
tv3129 = -96						; size = 4
tv3067 = -96						; size = 4
_flag$ = -92						; size = 4
_v$ = -88						; size = 4
tv1812 = -84						; size = 4
tv1631 = -84						; size = 4
tv3208 = -80						; size = 4
_i$ = -76						; size = 4
tv3299 = -72						; size = 4
_sign$90380 = -72					; size = 4
tv2777 = -68						; size = 4
_ff$90417 = -68						; size = 4
tv3415 = -64						; size = 4
_inum$ = -64						; size = 4
_todo$ = -64						; size = 4
_type$ = -60						; size = 4
_k$ = -56						; size = 4
_partials$90442 = -52					; size = 48
_wforce$90416 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_mode$ = 8						; size = 4
_calc_quant_grads PROC					; COMDAT

; 2081 : { int i,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2082 :   struct element *e_ptr;
; 2083 :   struct gen_quant *q = NULL;
; 2084 :   volgrad *vgptr;  /* constraint gradients */
; 2085 :   int flag;  /* 0 if doing global quantities, 1 for local */
; 2086 :   vertex_id v;
; 2087 :   int type;  /* element type */
; 2088 :   struct method_instance  *mi;
; 2089 :   struct gen_quant_method *gm;
; 2090 :   int inum;
; 2091 :   struct qinfo *q_info = &(GET_THREAD_DATA->q_info);  /* data passing structure */

	mov	eax, DWORD PTR _thread_data_key
	push	ebx
	push	esi
	push	eax
	call	_win_get_thread_data

; 2092 :   int todo = 0; /* whether any to do */

	xor	esi, esi
	lea	ebx, DWORD PTR [eax+56]
	add	esp, 4
	mov	DWORD PTR _todo$[ebp], esi

; 2093 :   int global_needs;
; 2094 : #ifdef PROFILING_ENABLED
; 2095 :   __int64 grad_elapsed_time;
; 2096 : #endif
; 2097 : 
; 2098 :   PROF_START(calc_quant_grads);
; 2099 : 
; 2100 :   if ( q_info->grad == NULL )

	cmp	DWORD PTR [ebx+1336], esi
	jne	SHORT $LN167@calc_quant@2

; 2101 :     q_info_init(q_info,METHOD_GRADIENT);

	push	4321					; 000010e1H
	push	ebx
	call	_q_info_init
	add	esp, 8
$LN167@calc_quant@2:

; 2107 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	eax, 1
	mov	DWORD PTR _comp_quant_stamp, esi
	mov	DWORD PTR _web+5628, esi
	mov	DWORD PTR _web+5632, esi
	mov	DWORD PTR _web+5636, esi
	mov	DWORD PTR _web+5640, esi
	mov	DWORD PTR _web+5644, esi
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR _web+5560, eax
	jle	$LN3@calc_quant@2
	fldz
	push	edi
$LN163@calc_quant@2:

; 2108 :   { int j;
; 2109 :     mi = METH_INSTANCE(k); /* since some init may have moved things */

	cdq
	mov	ecx, eax
	xor	ecx, edx
	sub	ecx, edx
	imul	ecx, 2928				; 00000b70H
	add	ecx, DWORD PTR _meth_inst_list

; 2110 :     if ( mi->flags & Q_DELETED ) continue;

	mov	eax, DWORD PTR [ecx+140]
	test	eax, 524288				; 00080000H
	jne	$LN162@calc_quant@2

; 2111 :     mi->stamp = 0;  /* so only current methods used in eval_all() */
; 2112 :     gm = basic_gen_methods + mi->gen_method;

	mov	edx, DWORD PTR [ecx+148]
	fst	QWORD PTR [ecx+2888]
	lea	edx, DWORD PTR [edx+edx*4]
	shl	edx, 5

; 2113 :     mi->flags |= Q_DOTHIS;

	or	eax, 16					; 00000010H
	mov	DWORD PTR tv1631[ebp], edx
	mov	DWORD PTR [ecx+140], eax

; 2114 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )

	xor	edx, edx
	lea	esi, DWORD PTR [ecx+152]
$LN159@calc_quant@2:

; 2115 :     { 
; 2116 :       if ( mi->quants[j] >= 0 ) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	js	SHORT $LN285@calc_quant@2

; 2117 :         q = GEN_QUANT(mi->quants[j]); 

	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list
	mov	edi, eax

; 2118 :       else 
; 2119 :         q = NULL;
; 2120 :       if ( !q || (q->modulus==0.0) || !(q->flags & mode & ~Q_COMPOUND) ||
; 2121 :             (mi->modulus==0.0) )

	je	SHORT $LN285@calc_quant@2
	fld	QWORD PTR [edi+176]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN285@calc_quant@2
	mov	eax, DWORD PTR [edi+136]
	and	eax, DWORD PTR _mode$[ebp]
	test	eax, -257				; fffffeffH
	je	SHORT $LN285@calc_quant@2
	fld	QWORD PTR [ecx+304]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN154@calc_quant@2
$LN285@calc_quant@2:

; 2122 :         mi->flags &= ~Q_DOTHIS;

	and	DWORD PTR [ecx+140], -17		; ffffffefH
	inc	edx
	add	esi, 4
	cmp	edx, 8
	jl	SHORT $LN159@calc_quant@2

; 2102 : 
; 2103 : 
; 2104 :   /* method initialization */
; 2105 :   comp_quant_stamp = 0;
; 2106 :   for ( type = 0 ; type < NUMELEMENTS ; type++ ) quant_flags[type] = 0;

	jmp	SHORT $LN533@calc_quant@2
$LN154@calc_quant@2:

; 2123 :       else
; 2124 :       { mi->flags |= Q_DOTHIS;

	or	DWORD PTR [ecx+140], 16			; 00000010H

; 2125 :         mi->newvalue = 0.0;

	fst	QWORD PTR [ecx+328]

; 2126 :         mi->abstotal = 0.0;
; 2127 :         mi->timestamp = global_timestamp;
; 2128 :         quant_flags[basic_gen_methods[mi->gen_method].type] |= mode;

	mov	esi, DWORD PTR _mode$[ebp]
	fst	QWORD PTR [ecx+336]
	mov	edx, DWORD PTR _global_timestamp
	mov	DWORD PTR [ecx+2924], edx
	mov	edx, DWORD PTR tv1631[ebp]
	mov	eax, DWORD PTR _basic_gen_methods[edx+128]
	or	DWORD PTR _web[eax*4+5628], esi

; 2129 :         if ( gm->init ) 

	mov	eax, DWORD PTR _basic_gen_methods[edx+140]
	test	eax, eax
	je	SHORT $LN151@calc_quant@2

; 2130 :               (*gm->init)(METHOD_GRADIENT,mi);

	push	ecx
	fstp	ST(0)
	push	4321					; 000010e1H
	call	eax
	fldz
	add	esp, 8
$LN151@calc_quant@2:

; 2131 :         todo = 1;

	mov	DWORD PTR _todo$[ebp], 1
$LN533@calc_quant@2:
	xor	esi, esi
$LN162@calc_quant@2:

; 2107 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _web+5560
	jl	$LN163@calc_quant@2

; 2132 :         break;
; 2133 :       }
; 2134 :     }
; 2135 :   }
; 2136 :   if ( !todo ) 

	cmp	DWORD PTR _todo$[ebp], esi
	je	$LN318@calc_quant@2

; 2137 :   { PROF_FINISH(calc_quant_grads);
; 2138 :     return;
; 2139 :   }
; 2140 :   
; 2141 :   if ( compound_quant_list_head >= 0 )

	cmp	DWORD PTR _compound_quant_list_head, esi
	jl	SHORT $LN145@calc_quant@2

; 2142 :   { if ( !vgradbase ) vgrad_init();

	cmp	DWORD PTR _vgradbase, 0
	jne	SHORT $LN148@calc_quant@2
	fstp	ST(0)
	call	_vgrad_init
	fldz
$LN148@calc_quant@2:

; 2143 :     for (  k=LOW_INST ; k < meth_inst_count ; k++ )

	mov	edi, 1
	cmp	DWORD PTR _web+5560, edi
	jle	SHORT $LN145@calc_quant@2
$LN147@calc_quant@2:

; 2144 :     { mi = METH_INSTANCE(k);

	mov	eax, edi
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list

; 2145 :       if ( mi->flags & Q_COMPOUND )

	test	DWORD PTR [esi+140], 256		; 00000100H
	je	SHORT $LN146@calc_quant@2

; 2146 :       { mi->grad = dmatrix(0,MAXVCOUNT,0,SDIM);

	mov	eax, DWORD PTR _web+616
	fstp	ST(0)
	push	2146					; 00000862H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	eax
	push	0
	push	100					; 00000064H
	push	0
	call	_kb_dmatrix
	fldz
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+2896], eax
$LN146@calc_quant@2:

; 2143 :     for (  k=LOW_INST ; k < meth_inst_count ; k++ )

	inc	edi
	cmp	edi, DWORD PTR _web+5560
	jl	SHORT $LN147@calc_quant@2
$LN145@calc_quant@2:

; 2147 :       }
; 2148 :     }
; 2149 :   }
; 2150 : 
; 2151 :   for ( type = VERTEX ; type <= BODY ; type++ )

	mov	esi, DWORD PTR _nprocs
	mov	DWORD PTR _type$[ebp], 0
$LN143@calc_quant@2:

; 2152 :   if ( quant_flags[type] & mode )

	mov	ecx, DWORD PTR _mode$[ebp]
	mov	edx, DWORD PTR _type$[ebp]
	test	DWORD PTR _web[edx*4+5628], ecx
	je	$LN142@calc_quant@2

; 2153 :   { int meth_offset = get_meth_offset(type); 

	mov	eax, edx
	mov	ecx, DWORD PTR _web[eax*4+5664]
	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	mov	edi, eax
	imul	edi, 112				; 00000070H
	add	ecx, DWORD PTR _web[edi+104]

; 2154 :   
; 2155 :     global_needs = global_meth_needs(type);

	push	eax
	mov	ecx, DWORD PTR [ecx+edx+64]
	mov	DWORD PTR _meth_offset$90311[ebp], ecx
	call	_global_meth_needs
	add	esp, 4

; 2156 :     
; 2157 : #if defined(SHARED_MEMORY)
; 2158 :     if ((compound_quant_list_head == -1) && ((nprocs > 1) || threadflag) ) 

	cmp	DWORD PTR _compound_quant_list_head, -1
	mov	DWORD PTR _global_needs$[ebp], eax
	jne	$LN139@calc_quant@2
	cmp	esi, 1
	jg	SHORT $LN280@calc_quant@2
	cmp	DWORD PTR _threadflag, 0
	je	$LN139@calc_quant@2
$LN280@calc_quant@2:

; 2159 :     { 
; 2160 :       if ( el_list_timestamp[VERTEX] < top_timestamp )

	mov	edx, DWORD PTR _el_list_timestamp
	cmp	edx, DWORD PTR _top_timestamp
	jge	SHORT $LN137@calc_quant@2

; 2161 :          make_el_list(VERTEX);  /* need for force */

	push	0
	fstp	ST(0)
	call	_make_el_list
	fldz
	mov	esi, DWORD PTR _nprocs
	add	esp, 4
$LN137@calc_quant@2:

; 2162 :       if ( el_list_timestamp[type] < top_timestamp )

	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR _top_timestamp
	cmp	DWORD PTR _el_list_timestamp[eax*4], ecx
	jge	SHORT $LN136@calc_quant@2

; 2163 :          make_el_list(type);

	mov	edx, eax
	fstp	ST(0)
	push	edx
	call	_make_el_list
	fldz
	mov	esi, DWORD PTR _nprocs
	add	esp, 4
$LN136@calc_quant@2:

; 2164 :       for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	edi, 1
	cmp	DWORD PTR _web+5560, edi
	jle	SHORT $LN356@calc_quant@2
$LN135@calc_quant@2:

; 2165 :       { mi = METH_INSTANCE(k); 

	mov	eax, edi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2166 :         if ( mi->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax+140]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN134@calc_quant@2

; 2167 :         if ( mi->flags & Q_DOTHIS )

	test	cl, 16					; 00000010H
	je	SHORT $LN134@calc_quant@2

; 2168 :           for ( i = 0 ; i < nprocs ; i++ )

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN134@calc_quant@2
	add	eax, 1736				; 000006c8H
$LN130@calc_quant@2:

; 2169 :           {  mi->procvalue[i] = 0.0;

	fst	QWORD PTR [eax-1152]
	inc	ecx

; 2170 :              mi->procabstotal[i] = 0.0;

	fst	QWORD PTR [eax]
	mov	esi, DWORD PTR _nprocs
	add	eax, 8
	cmp	ecx, esi
	jl	SHORT $LN130@calc_quant@2
$LN134@calc_quant@2:

; 2164 :       for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	edi
	cmp	edi, DWORD PTR _web+5560
	jl	SHORT $LN135@calc_quant@2
$LN356@calc_quant@2:

; 2168 :           for ( i = 0 ; i < nprocs ; i++ )

	fstp	ST(0)

; 2171 :           }
; 2172 :       }
; 2173 :       for ( i = 0 ; i < nprocs ; i++ ) proc_total_area[i] = 0.0;

	test	esi, esi
	jle	SHORT $LN281@calc_quant@2
	mov	ecx, esi
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	mov	edi, OFFSET _proc_total_area
	rep stosd
$LN281@calc_quant@2:

; 2174 :       for ( i = 0 ; i < nprocs ; i++ )

	xor	edi, edi
	mov	DWORD PTR _i$[ebp], edi
	test	esi, esi
	jle	SHORT $LN122@calc_quant@2
	mov	DWORD PTR tv2777[ebp], OFFSET _phead
	npad	6
$LL290@calc_quant@2:

; 2175 :       { int j;
; 2176 :          ptop[i] = 0 ;
; 2177 :          if ( pbase[i] == NULL )

	cmp	DWORD PTR _pbase[edi*4], 0
	mov	DWORD PTR _ptop[edi*4], 0
	jne	SHORT $LN121@calc_quant@2

; 2178 :          { pmax[i] = 1000;
; 2179 :            pbase[i] = (struct procforce *)mycalloc(pmax[i],
; 2180 :               sizeof(struct procforce));

	push	2180					; 00000884H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	56					; 00000038H
	push	1000					; 000003e8H
	mov	DWORD PTR _pmax[edi*4], 1000		; 000003e8H
	call	_kb_calloc
	mov	esi, DWORD PTR _nprocs
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pbase[edi*4], eax
$LN121@calc_quant@2:

; 2181 :          }
; 2182 :          for ( j = 0 ; j < nprocs ; j++ ) phead[i][j] = -1;

	test	esi, esi
	jle	SHORT $LN123@calc_quant@2
	mov	edi, DWORD PTR tv2777[ebp]
	mov	ecx, esi
	or	eax, -1
	rep stosd
	mov	edi, DWORD PTR _i$[ebp]
$LN123@calc_quant@2:

; 2174 :       for ( i = 0 ; i < nprocs ; i++ )

	add	DWORD PTR tv2777[ebp], 576		; 00000240H
	inc	edi
	mov	DWORD PTR _i$[ebp], edi
	cmp	edi, esi
	jl	SHORT $LL290@calc_quant@2
$LN122@calc_quant@2:

; 2183 :       }
; 2184 : #ifdef SGI_MULTI
; 2185 :       if ( mpflag == M_INACTIVE ) m_rele_procs();  /* resume parked procs */
; 2186 :       mpflag = M_ACTIVE;
; 2187 :       m_fork(m_calc_quant_grads,type,mode);
; 2188 :       m_fork(m_fix_grads,0,0);
; 2189 :       m_park_procs();
; 2190 :       mpflag = M_INACTIVE; 
; 2191 : #endif
; 2192 : #ifdef THREADS
; 2193 :       m_type = type;

	mov	eax, DWORD PTR _type$[ebp]

; 2194 :       thread_launch(TH_MULTI_QUANT_GRADS,type);

	push	eax
	push	6
	mov	DWORD PTR _m_type, eax
	call	_thread_launch

; 2195 :       thread_launch(TH_FIX_GRADS,0);

	push	0
	push	8
	call	_thread_launch

; 2196 : #endif
; 2197 : 
; 2198 :       /* sum separate process values */
; 2199 :       for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	esi, DWORD PTR _nprocs
	mov	edi, 1
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _web+5560, edi
	jle	SHORT $LN115@calc_quant@2
$LL117@calc_quant@2:

; 2200 :       { mi = METH_INSTANCE(k); 

	mov	eax, edi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2201 :         if ( mi->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax+140]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN116@calc_quant@2

; 2202 :         if ( mi->flags & Q_DOTHIS )

	test	cl, 16					; 00000010H
	je	SHORT $LN116@calc_quant@2

; 2203 :           for ( i = 0 ; i < nprocs ; i++ )

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN116@calc_quant@2
	lea	ecx, DWORD PTR [eax+1736]
	npad	9
$LL112@calc_quant@2:

; 2204 :           { mi->newvalue += mi->procvalue[i];

	fld	QWORD PTR [ecx-1152]
	inc	edx
	fadd	QWORD PTR [eax+328]
	add	ecx, 8
	fstp	QWORD PTR [eax+328]

; 2205 :             mi->abstotal += mi->procabstotal[i];

	fld	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx-8]
	fstp	QWORD PTR [eax+336]
	mov	esi, DWORD PTR _nprocs
	cmp	edx, esi
	jl	SHORT $LL112@calc_quant@2
$LN116@calc_quant@2:

; 2196 : #endif
; 2197 : 
; 2198 :       /* sum separate process values */
; 2199 :       for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	edi
	cmp	edi, DWORD PTR _web+5560
	jl	SHORT $LL117@calc_quant@2
$LN115@calc_quant@2:

; 2206 :           }
; 2207 :       }
; 2208 :       for ( i = 0 ; i < nprocs ; i++ )

	fld	QWORD PTR _web+992
	xor	eax, eax
	cmp	esi, 4
	jl	SHORT $LC251@calc_quant@2
	lea	ecx, DWORD PTR [esi-3]
$LN252@calc_quant@2:

; 2209 :          web.total_area += proc_total_area[i];

	fadd	QWORD PTR _proc_total_area[eax*8]
	add	eax, 4
	fadd	QWORD PTR _proc_total_area[eax*8-24]
	fadd	QWORD PTR _proc_total_area[eax*8-16]
	fadd	QWORD PTR _proc_total_area[eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN252@calc_quant@2
	fst	QWORD PTR _web+992
$LC251@calc_quant@2:

; 2206 :           }
; 2207 :       }
; 2208 :       for ( i = 0 ; i < nprocs ; i++ )

	cmp	eax, esi
	jge	$LN497@calc_quant@2
$LC109@calc_quant@2:

; 2209 :          web.total_area += proc_total_area[i];

	fadd	QWORD PTR _proc_total_area[eax*8]
	inc	eax
	cmp	eax, esi
	jl	SHORT $LC109@calc_quant@2
	fstp	QWORD PTR _web+992

; 2210 :     }
; 2211 :     else

	jmp	$LN534@calc_quant@2
$LN139@calc_quant@2:

; 2212 : #endif
; 2213 :     /* Don't put anything here; non-shared falls through!! */
; 2214 :     
; 2215 :     FOR_ALL_ELEMENTS(type,q_info->id)

	mov	edi, DWORD PTR _web[edi+48]
	mov	DWORD PTR [ebx], edi
	test	edi, 268435456				; 10000000H
	je	$LN273@calc_quant@2
$LN105@calc_quant@2:
	mov	eax, DWORD PTR [ebx]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv1812[ebp], ecx
	je	$LN104@calc_quant@2

; 2218 :       int needs;
; 2219 : 
; 2220 :       e_ptr = elptr(q_info->id);
; 2221 :       /* get setup flags */
; 2222 :       needs = global_needs;
; 2223 :       for ( k = 0 ; k < e_ptr->method_count ; k++ )

	movzx	eax, WORD PTR [ecx+24]
	mov	esi, DWORD PTR _global_needs$[ebp]
	mov	DWORD PTR _setup_flag$90362[ebp], edx
	mov	DWORD PTR _needs$90363[ebp], esi
	test	eax, eax
	jle	SHORT $LN278@calc_quant@2

; 2216 :     { int j;
; 2217 :       int setup_flag = 0;

	add	ecx, DWORD PTR _meth_offset$90311[ebp]
	mov	edi, eax
$LN100@calc_quant@2:

; 2224 :       { int mm;
; 2225 :         mm = ((int*)((char*)e_ptr+meth_offset))[k];
; 2226 :         mi = METH_INSTANCE(abs(mm));

	mov	eax, DWORD PTR [ecx]
	cdq
	xor	eax, edx
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2227 :         if ( (mi->flags & Q_DOTHIS) && (mi->type == type) )

	test	BYTE PTR [eax+140], 16			; 00000010H
	je	SHORT $LN99@calc_quant@2
	mov	edx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+136], edx
	jne	SHORT $LN99@calc_quant@2

; 2228 :           needs |= basic_gen_methods[mi->gen_method].flags;

	mov	eax, DWORD PTR [eax+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	or	esi, DWORD PTR _basic_gen_methods[eax+132]
$LN99@calc_quant@2:

; 2218 :       int needs;
; 2219 : 
; 2220 :       e_ptr = elptr(q_info->id);
; 2221 :       /* get setup flags */
; 2222 :       needs = global_needs;
; 2223 :       for ( k = 0 ; k < e_ptr->method_count ; k++ )

	add	ecx, 4
	dec	edi
	jne	SHORT $LN100@calc_quant@2

; 2228 :           needs |= basic_gen_methods[mi->gen_method].flags;

	mov	DWORD PTR _needs$90363[ebp], esi
$LN278@calc_quant@2:

; 2229 :       }
; 2230 :       inum = global_meth_inst_count[type];

	mov	ecx, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR _web[ecx*4+5588]

; 2231 :       ++comp_quant_stamp;

	inc	DWORD PTR _comp_quant_stamp
	mov	DWORD PTR _inum$[ebp], edx

; 2232 :       for ( flag = 0 ; flag < 2 ; flag++,inum = e_ptr->method_count,k=0 )

	mov	DWORD PTR _flag$[ebp], 0
$LN96@calc_quant@2:

; 2233 :       { for ( k = 0 ; k < inum ; k++ )

	cmp	DWORD PTR _inum$[ebp], 0
	mov	DWORD PTR _k$[ebp], 0
	jle	$LN95@calc_quant@2
	mov	eax, DWORD PTR tv1812[ebp]
	add	eax, DWORD PTR _meth_offset$90311[ebp]
	mov	DWORD PTR tv3067[ebp], eax
$LN93@calc_quant@2:

; 2234 :         { int mm;
; 2235 :           int sign = 1;
; 2236 :           if ( flag ) 

	cmp	DWORD PTR _flag$[ebp], 0

; 2237 :           { mm = ((int*)((char*)e_ptr+meth_offset))[k];

	mov	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR _sign$90380[ebp], 1
	je	SHORT $LN90@calc_quant@2
	mov	edx, DWORD PTR tv3067[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]

; 2238 :             q_info->method = abs(mm);

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR [ebx+8], eax

; 2239 :             if ( mm < 0 ) sign = -1;

	test	ecx, ecx
	jns	SHORT $LN88@calc_quant@2
	mov	DWORD PTR _sign$90380[ebp], -1

; 2240 :           }
; 2241 :           else  q_info->method = global_meth_inst[type][k];

	jmp	SHORT $LN88@calc_quant@2
$LN90@calc_quant@2:
	mov	ecx, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR _web[ecx*4+5568]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ebx+8], ecx
$LN88@calc_quant@2:

; 2242 :           mi = METH_INSTANCE(q_info->method);

	mov	eax, DWORD PTR [ebx+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2243 :  
; 2244 :           if ( (mi->flags & Q_DOTHIS) && (mi->type == type) )

	test	BYTE PTR [eax+140], 16			; 00000010H
	je	$LN92@calc_quant@2
	mov	edx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+136], edx
	jne	$LN92@calc_quant@2

; 2245 :           { REAL c = 0;  /* net coefficient */
; 2246 :             REAL value;
; 2247 :             gm = basic_gen_methods + mi->gen_method;

	mov	eax, DWORD PTR [eax+148]
	lea	esi, DWORD PTR [eax+eax*4]
	shl	esi, 5
	add	esi, OFFSET _basic_gen_methods

; 2248 :             PROF_START(element_setup);
; 2249 :             if ( !setup_flag ) 

	cmp	DWORD PTR _setup_flag$90362[ebp], 0
	jne	SHORT $LN86@calc_quant@2

; 2250 :             { (*q_setup[type])(NULL,q_info,needs); setup_flag = 1; }

	mov	eax, DWORD PTR _needs$90363[ebp]
	fstp	ST(0)
	push	eax
	mov	ecx, edx
	mov	edx, DWORD PTR _q_setup[ecx*4]
	push	ebx
	push	0
	call	edx
	fldz
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _setup_flag$90362[ebp], 1
$LN86@calc_quant@2:

; 2251 :             PROF_FINISH(element_setup);
; 2252 :             mi = METH_INSTANCE(q_info->method);

	mov	eax, DWORD PTR [ebx+8]
	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
	imul	edi, 2928				; 00000b70H
	add	edi, DWORD PTR _meth_inst_list

; 2253 :             METHOD_PROFILING_START(mi,grad);
; 2254 :             for ( i = 0 ; i < q_info->vcount ; i++ ) /* methods don't know */

	xor	ecx, ecx
	cmp	DWORD PTR [ebx+12], ecx
	jle	SHORT $LN398@calc_quant@2
	mov	edx, DWORD PTR _web+616
$LN85@calc_quant@2:

; 2255 :               for ( j = 0 ; j < SDIM ; j++ )          /* how many */

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN84@calc_quant@2
$LN82@calc_quant@2:

; 2256 :                   q_info->grad[i][j] = 0.0;

	mov	edx, DWORD PTR [ebx+1336]
	mov	edx, DWORD PTR [edx+ecx*4]
	fst	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _web+616
	inc	eax
	cmp	eax, edx
	jl	SHORT $LN82@calc_quant@2
$LN84@calc_quant@2:

; 2253 :             METHOD_PROFILING_START(mi,grad);
; 2254 :             for ( i = 0 ; i < q_info->vcount ; i++ ) /* methods don't know */

	inc	ecx
	cmp	ecx, DWORD PTR [ebx+12]
	jl	SHORT $LN85@calc_quant@2
$LN398@calc_quant@2:

; 2257 :             value = (*gm->gradient)(q_info);

	mov	eax, DWORD PTR [esi+148]
	fstp	ST(0)
	push	ebx
	call	eax
	add	esp, 4

; 2258 :             if ( mi->flags & ELEMENT_MODULUS_FLAG )

	test	DWORD PTR [edi+140], 268435456		; 10000000H
	je	SHORT $LN277@calc_quant@2

; 2259 :             { REAL emdls = *(REAL*)get_extra(q_info->id,mi->elmodulus);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [edi+228]
	mov	eax, ecx
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	esi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	esi, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [esi+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	fld	QWORD PTR [edx+eax]

; 2260 :               value *= emdls;
; 2261 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	xor	edx, edx
	fld	ST(0)
	fmulp	ST(2), ST(0)
	cmp	DWORD PTR [ebx+12], edx
	jle	SHORT $LN510@calc_quant@2
	mov	ecx, DWORD PTR _web+616
$LN78@calc_quant@2:

; 2262 :                 for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN77@calc_quant@2
$LN75@calc_quant@2:
	mov	ecx, DWORD PTR [ebx+1336]
	mov	ecx, DWORD PTR [ecx+edx*4]

; 2263 :                   q_info->grad[i][j] *= emdls;

	fld	QWORD PTR [ecx+eax*8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fmul	ST(0), ST(1)
	inc	eax
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN75@calc_quant@2
$LN77@calc_quant@2:

; 2260 :               value *= emdls;
; 2261 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	inc	edx
	cmp	edx, DWORD PTR [ebx+12]
	jl	SHORT $LN78@calc_quant@2
$LN510@calc_quant@2:

; 2262 :                 for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
$LN277@calc_quant@2:

; 2264 :             }
; 2265 :             mi->newvalue += sign*value;
; 2266 :             mi->abstotal += fabs(value);
; 2267 :             if ( mi->flags & Q_COMPOUND ) 

	test	DWORD PTR [edi+140], 256		; 00000100H
	fild	DWORD PTR _sign$90380[ebp]
	fst	QWORD PTR tv1925[ebp]
	fld	ST(0)
	fmul	ST(0), ST(2)
	fadd	QWORD PTR [edi+328]
	fstp	QWORD PTR [edi+328]
	fxch	ST(1)
	fabs
	fadd	QWORD PTR [edi+336]
	fstp	QWORD PTR [edi+336]
	je	SHORT $LN512@calc_quant@2

; 2268 :             {
; 2269 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR [ebx+12], ecx
	jle	SHORT $LN520@calc_quant@2
	mov	edx, DWORD PTR _web+616
$LN71@calc_quant@2:

; 2270 :               { for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN70@calc_quant@2
$LN68@calc_quant@2:

; 2271 :                   mi->grad[i][j] = sign*mi->modulus*q_info->grad[i][j];

	mov	edx, DWORD PTR [ebx+1336]
	fld	ST(0)
	mov	edx, DWORD PTR [edx+ecx*4]
	fmul	QWORD PTR [edi+304]
	inc	eax
	fmul	QWORD PTR [edx+eax*8-8]
	mov	edx, DWORD PTR [edi+2896]
	mov	edx, DWORD PTR [edx+ecx*4]
	fstp	QWORD PTR [edx+eax*8-8]
	mov	edx, DWORD PTR _web+616
	cmp	eax, edx
	jl	SHORT $LN68@calc_quant@2
$LN70@calc_quant@2:

; 2268 :             {
; 2269 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR [ebx+12]
	jl	SHORT $LN71@calc_quant@2
$LN520@calc_quant@2:

; 2270 :               { for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)

; 2272 :               }
; 2273 :               mi->stamp = comp_quant_stamp;

	fild	DWORD PTR _comp_quant_stamp
	fstp	QWORD PTR [edi+2888]
	jmp	SHORT $LN292@calc_quant@2
$LN512@calc_quant@2:
	fstp	ST(0)
$LN292@calc_quant@2:

; 2274 :             }
; 2275 : 
; 2276 : 
; 2277 :             for ( i = 0 ; i < q_info->vcount ; i++ )

	cmp	DWORD PTR [ebx+12], 0
	mov	DWORD PTR _i$[ebp], 0
	jle	$LN276@calc_quant@2
	lea	eax, DWORD PTR [ebx+816]
	mov	DWORD PTR tv3299[ebp], eax
	mov	eax, -816				; fffffcd0H
	sub	eax, ebx
	mov	DWORD PTR tv3322[ebp], eax
	npad	6
$LL65@calc_quant@2:

; 2278 :             { 
; 2279 :               REAL wforce[MAXCOORD];  /* unwrapped forces */
; 2280 :               REAL *ff;
; 2281 :               v = q_info->v[i];

	mov	eax, DWORD PTR tv3299[ebp]
	mov	ecx, DWORD PTR [eax-800]

; 2282 :               if ( q_info->wraps[i] )
; 2283 :               { (*sym_form_pullback)(q_info->x[i],wforce,q_info->grad[i],
; 2284 :                                  q_info->wraps[i]);

	mov	edx, DWORD PTR [ebx+1336]
	add	edx, DWORD PTR tv3322[ebp]
	mov	DWORD PTR _v$[ebp], ecx
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN62@calc_quant@2
	push	ecx
	mov	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [eax-400]
	push	ecx
	lea	edx, DWORD PTR _wforce$90416[ebp]
	push	edx
	push	eax
	call	DWORD PTR _sym_form_pullback

; 2285 :                 ff = wforce;

	lea	ecx, DWORD PTR _wforce$90416[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ff$90417[ebp], ecx
	jmp	SHORT $LN61@calc_quant@2
$LN62@calc_quant@2:

; 2286 :               }
; 2287 :               else ff = q_info->grad[i];

	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _ff$90417[ebp], eax
$LN61@calc_quant@2:

; 2288 :               for ( j = 0 ; j < MMAXQUANTS ; j++ )

	lea	eax, DWORD PTR [edi+152]
	mov	DWORD PTR tv3208[ebp], eax
	mov	DWORD PTR tv1258[ebp], 8
$LL60@calc_quant@2:

; 2289 :               { if ( mi->quants[j] < 0 )

	mov	ecx, DWORD PTR tv3208[ebp]
	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	js	$LN59@calc_quant@2

; 2290 :                   continue;
; 2291 :                 q = GEN_QUANT(mi->quants[j]);

	imul	esi, 368				; 00000170H
	add	esi, DWORD PTR _gen_quant_list

; 2292 :                 if ( !(mi->flags & Q_COMPOUND) )

	test	DWORD PTR [edi+140], 256		; 00000100H
	jne	$LN59@calc_quant@2

; 2293 :                 { c = sign*mi->modulus*q->modulus;

	fld	QWORD PTR [edi+304]

; 2294 :                   if ( q->flags & Q_ENERGY & mode )

	mov	eax, DWORD PTR [esi+136]
	fmul	QWORD PTR tv1925[ebp]
	and	eax, DWORD PTR _mode$[ebp]
	fmul	QWORD PTR [esi+176]
	fst	QWORD PTR _c$90387[ebp]
	test	al, 1
	je	SHORT $LN522@calc_quant@2

; 2295 :                   { REAL *f = get_force(v);
; 2296 :                     vector_add_smul(f,ff, -c, SDIM);

	mov	edx, DWORD PTR _web+616
	fchs
	mov	eax, DWORD PTR _ff$90417[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	push	edx
	mov	edx, DWORD PTR _web+12
	sub	esp, 8
	and	ecx, 134217727				; 07ffffffH
	fstp	QWORD PTR [esp]
	push	eax
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+784]
	jmp	SHORT $LN535@calc_quant@2
$LN522@calc_quant@2:

; 2294 :                   if ( q->flags & Q_ENERGY & mode )

	fstp	ST(0)

; 2297 :                   }
; 2298 :                   else if ( q->flags & (Q_FIXED|Q_CONSERVED) & mode )

	test	al, 10					; 0000000aH
	je	SHORT $LN59@calc_quant@2

; 2299 :                   { vgptr = get_bv_new_vgrad(q->fixnum,v);

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [esi+224]
	push	eax
	push	ecx
	call	_get_bv_new_vgrad

; 2300 :                     vgptr->bb_id = q->b_id;
; 2301 :                     vgptr->qnum = mi->quants[j];
; 2302 :                     vector_add_smul(vgptr->grad,ff, c, SDIM);

	fld	QWORD PTR _c$90387[ebp]
	mov	edx, DWORD PTR [esi+216]
	mov	ecx, DWORD PTR tv3208[ebp]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _ff$90417[ebp]
	mov	eax, DWORD PTR [eax+16]
	add	esp, 8
	push	ecx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
$LN535@calc_quant@2:
	push	eax
	call	_vector_add_smul
	add	esp, 20					; 00000014H
$LN59@calc_quant@2:

; 2288 :               for ( j = 0 ; j < MMAXQUANTS ; j++ )

	add	DWORD PTR tv3208[ebp], 4
	dec	DWORD PTR tv1258[ebp]
	jne	$LL60@calc_quant@2

; 2303 :                   }
; 2304 :                 } 
; 2305 :               }
; 2306 :               if ( mode && (mi->flags & Q_COMPOUND) )

	cmp	DWORD PTR _mode$[ebp], 0
	je	SHORT $LN64@calc_quant@2
	test	DWORD PTR [edi+140], 256		; 00000100H
	je	SHORT $LN64@calc_quant@2

; 2307 :               { 
; 2308 :                   vgptr = get_bv_new_vgrad(mi->self_id,v);

	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [edi+132]
	push	ecx
	push	edx
	call	_get_bv_new_vgrad

; 2309 :                   vgptr->bb_id = mi->self_id;

	mov	ecx, DWORD PTR [edi+132]
	mov	DWORD PTR [eax+8], ecx

; 2310 :                   vgptr->qnum = mi->self_id;

	mov	edx, DWORD PTR [edi+132]
	mov	DWORD PTR [eax+4], edx

; 2311 :                   vector_add_smul(vgptr->grad,ff, sign*mi->modulus, SDIM);                 

	fld	QWORD PTR [edi+304]
	mov	ecx, DWORD PTR _web+616
	fmul	QWORD PTR tv1925[ebp]
	mov	edx, DWORD PTR _ff$90417[ebp]
	mov	eax, DWORD PTR [eax+16]
	add	esp, 8
	push	ecx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	push	eax
	call	_vector_add_smul
	add	esp, 20					; 00000014H
$LN64@calc_quant@2:

; 2274 :             }
; 2275 : 
; 2276 : 
; 2277 :             for ( i = 0 ; i < q_info->vcount ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv3299[ebp], 4
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [ebx+12]
	jl	$LL65@calc_quant@2
$LN276@calc_quant@2:
	fldz
$LN92@calc_quant@2:

; 2233 :       { for ( k = 0 ; k < inum ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _inum$[ebp]
	jl	$LN93@calc_quant@2
$LN95@calc_quant@2:

; 2232 :       for ( flag = 0 ; flag < 2 ; flag++,inum = e_ptr->method_count,k=0 )

	mov	eax, DWORD PTR _flag$[ebp]
	mov	ecx, DWORD PTR tv1812[ebp]
	movzx	edx, WORD PTR [ecx+24]
	inc	eax
	mov	DWORD PTR _flag$[ebp], eax
	mov	DWORD PTR _inum$[ebp], edx
	cmp	eax, 2
	jl	$LN96@calc_quant@2

; 2312 :               }
; 2313 :             }
; 2314 :             METHOD_PROFILING_END(mi,grad);
; 2315 :           }
; 2316 :         }
; 2317 :       }  /* end calculation of all method instances */
; 2318 : 
; 2319 :       /* check out compound quantities */
; 2320 :       for ( k = compound_quant_list_head ; k >= 0 ; k = q->next_compound )

	mov	eax, DWORD PTR _compound_quant_list_head
	mov	DWORD PTR _k$[ebp], eax
	test	eax, eax
	js	$LN104@calc_quant@2
$LN51@calc_quant@2:

; 2321 :       { q = GEN_QUANT(k);

	mov	edi, DWORD PTR _k$[ebp]
	imul	edi, 368				; 00000170H
	add	edi, DWORD PTR _gen_quant_list

; 2322 :         if ( (q->flags & mode) && (q->flags & Q_COMPOUND) ) 

	mov	eax, DWORD PTR [edi+136]
	test	eax, DWORD PTR _mode$[ebp]
	je	$LN50@calc_quant@2
	test	eax, 256				; 00000100H
	je	$LN50@calc_quant@2

; 2323 :         { for ( i = 0 ; i < q_info->vcount ; i++ )

	xor	esi, esi
	cmp	DWORD PTR [ebx+12], esi
	jle	$LN50@calc_quant@2
	lea	edx, DWORD PTR [ebx+16]
	fstp	ST(0)
	mov	DWORD PTR tv3415[ebp], edx
	npad	6
$LL47@calc_quant@2:

; 2324 :           { REAL dummy,partials[MAXCOORD];
; 2325 :             comp_quant_vertex = i; /* so eval_all knows */ 
; 2326 :             eval_all(&q->expr,NULL,SDIM,&dummy,partials,NULLID);

	mov	edx, DWORD PTR _web+616
	push	0
	lea	eax, DWORD PTR _partials$90442[ebp]
	push	eax
	lea	ecx, DWORD PTR _dummy$90441[ebp]
	push	ecx
	push	edx
	lea	eax, DWORD PTR [edi+256]
	push	0
	push	eax
	mov	DWORD PTR _comp_quant_vertex, esi
	call	_eval_all

; 2327 :             v = q_info->v[i];

	mov	eax, DWORD PTR tv3415[ebp]
	mov	eax, DWORD PTR [eax]
	add	esp, 24					; 00000018H

; 2328 :             if ( q->flags & Q_ENERGY )

	test	BYTE PTR [edi+136], 1
	je	SHORT $LN44@calc_quant@2

; 2329 :             { REAL *f = get_force(v);
; 2330 :               vector_add_smul(f,partials, -q->modulus, SDIM);

	mov	ecx, DWORD PTR _web+616
	fld	QWORD PTR [edi+176]
	push	ecx
	fchs
	mov	ecx, DWORD PTR _web+12
	sub	esp, 8
	lea	edx, DWORD PTR _partials$90442[ebp]
	fstp	QWORD PTR [esp]
	and	eax, 134217727				; 07ffffffH
	push	edx
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+784]
	push	edx

; 2331 :             }
; 2332 :             else 

	jmp	SHORT $LN536@calc_quant@2
$LN44@calc_quant@2:

; 2333 :             { 
; 2334 :               vgptr = get_bv_new_vgrad(q->fixnum,v);

	mov	edx, DWORD PTR [edi+224]
	push	eax
	push	edx
	call	_get_bv_new_vgrad

; 2335 :               vgptr->bb_id = q->b_id;

	mov	ecx, DWORD PTR [edi+216]

; 2336 :               vgptr->qnum = k;

	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [eax+4], edx
	add	esp, 8
	mov	DWORD PTR [eax+8], ecx

; 2337 :               vector_add_smul(vgptr->grad,partials, q->modulus, SDIM);

	fld	QWORD PTR [edi+176]
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [eax+16]
	push	ecx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	edx, DWORD PTR _partials$90442[ebp]
	push	edx
	push	eax
$LN536@calc_quant@2:
	call	_vector_add_smul
	add	DWORD PTR tv3415[ebp], 4
	inc	esi
	add	esp, 20					; 00000014H
	cmp	esi, DWORD PTR [ebx+12]
	jl	$LL47@calc_quant@2

; 2323 :         { for ( i = 0 ; i < q_info->vcount ; i++ )

	fldz
$LN50@calc_quant@2:

; 2312 :               }
; 2313 :             }
; 2314 :             METHOD_PROFILING_END(mi,grad);
; 2315 :           }
; 2316 :         }
; 2317 :       }  /* end calculation of all method instances */
; 2318 : 
; 2319 :       /* check out compound quantities */
; 2320 :       for ( k = compound_quant_list_head ; k >= 0 ; k = q->next_compound )

	mov	edi, DWORD PTR [edi+360]
	mov	DWORD PTR _k$[ebp], edi
	test	edi, edi
	jns	$LN51@calc_quant@2
$LN104@calc_quant@2:

; 2212 : #endif
; 2213 :     /* Don't put anything here; non-shared falls through!! */
; 2214 :     
; 2215 :     FOR_ALL_ELEMENTS(type,q_info->id)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ebx], ecx
	test	ecx, 268435456				; 10000000H
	jne	$LN105@calc_quant@2
$LN273@calc_quant@2:
	mov	esi, DWORD PTR _nprocs
	jmp	SHORT $LN537@calc_quant@2
$LN497@calc_quant@2:

; 2206 :           }
; 2207 :       }
; 2208 :       for ( i = 0 ; i < nprocs ; i++ )

	fstp	ST(0)
$LN534@calc_quant@2:

; 2210 :     }
; 2211 :     else

	fldz
$LN537@calc_quant@2:
	mov	ecx, DWORD PTR _mode$[ebp]
$LN142@calc_quant@2:

; 2147 :       }
; 2148 :     }
; 2149 :   }
; 2150 : 
; 2151 :   for ( type = VERTEX ; type <= BODY ; type++ )

	mov	eax, DWORD PTR _type$[ebp]
	inc	eax
	mov	DWORD PTR _type$[ebp], eax
	cmp	eax, 3
	jle	$LN143@calc_quant@2

; 2338 :             }
; 2339 :           }
; 2340 :         }
; 2341 :       }
; 2342 :     }
; 2343 :   }
; 2344 : 
; 2345 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	esi, 1
	cmp	DWORD PTR _web+5560, esi
	jle	SHORT $LN282@calc_quant@2
$LN42@calc_quant@2:

; 2346 :   { mi = METH_INSTANCE(k);

	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2347 :     if ( mi->flags & Q_DELETED ) continue;

	mov	edx, DWORD PTR [eax+140]
	test	edx, 524288				; 00080000H
	jne	SHORT $LN41@calc_quant@2

; 2348 :     if ( mi->flags & Q_DOTHIS )

	test	dl, 16					; 00000010H
	je	SHORT $LN41@calc_quant@2

; 2349 :     {  mi->value = mi->modulus*mi->newvalue;

	fld	QWORD PTR [eax+328]
	fmul	QWORD PTR [eax+304]
	fstp	QWORD PTR [eax+312]

; 2350 :        mi->abstotal *= fabs(mi->modulus);

	fld	QWORD PTR [eax+304]
	fabs
	fmul	QWORD PTR [eax+336]
	fstp	QWORD PTR [eax+336]
$LN41@calc_quant@2:

; 2338 :             }
; 2339 :           }
; 2340 :         }
; 2341 :       }
; 2342 :     }
; 2343 :   }
; 2344 : 
; 2345 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	esi
	cmp	esi, DWORD PTR _web+5560
	jl	SHORT $LN42@calc_quant@2
$LN282@calc_quant@2:

; 2351 :     }
; 2352 :   }
; 2353 : 
; 2354 :   /* combine methods to quantities */
; 2355 :   for ( k = 0 ; k < gen_quant_count ; k++ )

	mov	edi, DWORD PTR _gen_quant_list
	xor	ebx, ebx
	cmp	DWORD PTR _web+5528, ebx
	jle	SHORT $LN35@calc_quant@2
	xor	esi, esi
$LN37@calc_quant@2:

; 2356 :   { q = GEN_QUANT(k);
; 2357 :     if ( q->flags & Q_DELETED ) continue;

	mov	edx, DWORD PTR [esi+edi+136]
	lea	eax, DWORD PTR [esi+edi]
	test	edx, 524288				; 00080000H
	jne	SHORT $LN36@calc_quant@2

; 2358 :     if ( q->flags & mode ) 

	test	edx, ecx

; 2361 :       q->timestamp = global_timestamp;

	mov	ecx, DWORD PTR _mode$[ebp]
	je	SHORT $LN36@calc_quant@2

; 2359 :     { q->value = q->volconst;

	fld	QWORD PTR [eax+208]
	fstp	QWORD PTR [eax+152]

; 2360 :       q->abstotal = 0.0;

	fst	QWORD PTR [eax+168]

; 2361 :       q->timestamp = global_timestamp;

	mov	edx, DWORD PTR _global_timestamp
	mov	DWORD PTR [eax+364], edx
	mov	edi, DWORD PTR _gen_quant_list
$LN36@calc_quant@2:

; 2351 :     }
; 2352 :   }
; 2353 : 
; 2354 :   /* combine methods to quantities */
; 2355 :   for ( k = 0 ; k < gen_quant_count ; k++ )

	inc	ebx
	add	esi, 368				; 00000170H
	cmp	ebx, DWORD PTR _web+5528
	jl	SHORT $LN37@calc_quant@2
$LN35@calc_quant@2:

; 2362 :     }
; 2363 :   }
; 2364 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	esi, 1
	cmp	DWORD PTR _web+5560, esi
	jle	$LN289@calc_quant@2
	mov	ebx, 524288				; 00080000H
$LN32@calc_quant@2:

; 2365 :   { int j;
; 2366 :     mi = METH_INSTANCE(k);

	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2367 :     if ( mi->flags & Q_DELETED ) continue;

	test	DWORD PTR [eax+140], ebx
	jne	$LN31@calc_quant@2

; 2368 :     
; 2369 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2370 :     { if ( mi->quants[j] < 0 )

	mov	edx, DWORD PTR [eax+152]
	test	edx, edx
	js	SHORT $LN27@calc_quant@2

; 2371 :          continue;
; 2372 :       q = GEN_QUANT(mi->quants[j]);

	imul	edx, 368				; 00000170H
	add	edx, edi

; 2373 :       if ( q->flags & mode ) 

	test	DWORD PTR [edx+136], ecx
	je	SHORT $LN27@calc_quant@2

; 2374 :       { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [edx+176]
	fadd	QWORD PTR [edx+152]
	fstp	QWORD PTR [edx+152]

; 2375 :         q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [edx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [edx+168]
	fstp	QWORD PTR [edx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN27@calc_quant@2:

; 2368 :     
; 2369 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2370 :     { if ( mi->quants[j] < 0 )

	mov	edx, DWORD PTR [eax+156]
	test	edx, edx
	js	SHORT $LN257@calc_quant@2

; 2371 :          continue;
; 2372 :       q = GEN_QUANT(mi->quants[j]);

	imul	edx, 368				; 00000170H
	add	edx, edi

; 2373 :       if ( q->flags & mode ) 

	test	DWORD PTR [edx+136], ecx
	je	SHORT $LN257@calc_quant@2

; 2374 :       { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [edx+176]
	fadd	QWORD PTR [edx+152]
	fstp	QWORD PTR [edx+152]

; 2375 :         q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [edx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [edx+168]
	fstp	QWORD PTR [edx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN257@calc_quant@2:

; 2368 :     
; 2369 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2370 :     { if ( mi->quants[j] < 0 )

	mov	edx, DWORD PTR [eax+160]
	test	edx, edx
	js	SHORT $LN259@calc_quant@2

; 2371 :          continue;
; 2372 :       q = GEN_QUANT(mi->quants[j]);

	imul	edx, 368				; 00000170H
	add	edx, edi

; 2373 :       if ( q->flags & mode ) 

	test	DWORD PTR [edx+136], ecx
	je	SHORT $LN259@calc_quant@2

; 2374 :       { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [edx+176]
	fadd	QWORD PTR [edx+152]
	fstp	QWORD PTR [edx+152]

; 2375 :         q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [edx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [edx+168]
	fstp	QWORD PTR [edx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN259@calc_quant@2:

; 2368 :     
; 2369 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2370 :     { if ( mi->quants[j] < 0 )

	mov	edx, DWORD PTR [eax+164]
	test	edx, edx
	js	SHORT $LN261@calc_quant@2

; 2371 :          continue;
; 2372 :       q = GEN_QUANT(mi->quants[j]);

	imul	edx, 368				; 00000170H
	add	edx, edi

; 2373 :       if ( q->flags & mode ) 

	test	DWORD PTR [edx+136], ecx
	je	SHORT $LN261@calc_quant@2

; 2374 :       { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [edx+176]
	fadd	QWORD PTR [edx+152]
	fstp	QWORD PTR [edx+152]

; 2375 :         q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [edx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [edx+168]
	fstp	QWORD PTR [edx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN261@calc_quant@2:

; 2368 :     
; 2369 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2370 :     { if ( mi->quants[j] < 0 )

	mov	edx, DWORD PTR [eax+168]
	test	edx, edx
	js	SHORT $LN263@calc_quant@2

; 2371 :          continue;
; 2372 :       q = GEN_QUANT(mi->quants[j]);

	imul	edx, 368				; 00000170H
	add	edx, edi

; 2373 :       if ( q->flags & mode ) 

	test	DWORD PTR [edx+136], ecx
	je	SHORT $LN263@calc_quant@2

; 2374 :       { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [edx+176]
	fadd	QWORD PTR [edx+152]
	fstp	QWORD PTR [edx+152]

; 2375 :         q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [edx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [edx+168]
	fstp	QWORD PTR [edx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN263@calc_quant@2:

; 2368 :     
; 2369 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2370 :     { if ( mi->quants[j] < 0 )

	mov	edx, DWORD PTR [eax+172]
	test	edx, edx
	js	SHORT $LN265@calc_quant@2

; 2371 :          continue;
; 2372 :       q = GEN_QUANT(mi->quants[j]);

	imul	edx, 368				; 00000170H
	add	edx, edi

; 2373 :       if ( q->flags & mode ) 

	test	DWORD PTR [edx+136], ecx
	je	SHORT $LN265@calc_quant@2

; 2374 :       { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [edx+176]
	fadd	QWORD PTR [edx+152]
	fstp	QWORD PTR [edx+152]

; 2375 :         q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [edx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [edx+168]
	fstp	QWORD PTR [edx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN265@calc_quant@2:

; 2368 :     
; 2369 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2370 :     { if ( mi->quants[j] < 0 )

	mov	edx, DWORD PTR [eax+176]
	test	edx, edx
	js	SHORT $LN267@calc_quant@2

; 2371 :          continue;
; 2372 :       q = GEN_QUANT(mi->quants[j]);

	imul	edx, 368				; 00000170H
	add	edx, edi

; 2373 :       if ( q->flags & mode ) 

	test	DWORD PTR [edx+136], ecx
	je	SHORT $LN267@calc_quant@2

; 2374 :       { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [edx+176]
	fadd	QWORD PTR [edx+152]
	fstp	QWORD PTR [edx+152]

; 2375 :         q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [edx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [edx+168]
	fstp	QWORD PTR [edx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN267@calc_quant@2:

; 2368 :     
; 2369 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2370 :     { if ( mi->quants[j] < 0 )

	mov	edx, DWORD PTR [eax+180]
	test	edx, edx
	js	SHORT $LN31@calc_quant@2

; 2371 :          continue;
; 2372 :       q = GEN_QUANT(mi->quants[j]);

	imul	edx, 368				; 00000170H
	add	edx, edi

; 2373 :       if ( q->flags & mode ) 

	test	DWORD PTR [edx+136], ecx
	je	SHORT $LN31@calc_quant@2

; 2374 :       { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [edx+176]
	fadd	QWORD PTR [edx+152]
	fstp	QWORD PTR [edx+152]

; 2375 :         q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [edx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [edx+168]
	fstp	QWORD PTR [edx+168]
	mov	edi, DWORD PTR _gen_quant_list
$LN31@calc_quant@2:

; 2362 :     }
; 2363 :   }
; 2364 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	esi
	cmp	esi, DWORD PTR _web+5560
	jl	$LN32@calc_quant@2
$LN289@calc_quant@2:

; 2376 :       }
; 2377 :     }
; 2378 :   }
; 2379 : 
; 2380 :   for ( k = 0 ; k < gen_quant_count ; k++ )

	xor	ebx, ebx
	mov	DWORD PTR _k$[ebp], ebx
	cmp	DWORD PTR _web+5528, ebx
	jle	SHORT $LN492@calc_quant@2
$LN23@calc_quant@2:

; 2381 :   { q = GEN_QUANT(k);
; 2382 :     if ( q->flags & Q_DELETED ) continue;

	mov	eax, DWORD PTR [ebx+edi+136]
	lea	esi, DWORD PTR [ebx+edi]
	test	eax, 524288				; 00080000H
	jne	SHORT $LN22@calc_quant@2

; 2383 :     if ( q->flags & mode ) 

	test	eax, ecx
	je	SHORT $LN22@calc_quant@2

; 2384 :       if ( (q->flags & Q_COMPOUND) && (q->modulus != 0.0) )

	test	eax, 256				; 00000100H
	je	SHORT $LN22@calc_quant@2
	fld	QWORD PTR [esi+176]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN22@calc_quant@2

; 2385 :       {  q->value = q->modulus*eval(&q->expr,NULL,NULLID,NULL);

	push	0
	fstp	ST(0)
	push	0
	lea	eax, DWORD PTR [esi+256]
	push	0
	push	eax
	call	_eval
	fmul	QWORD PTR [esi+176]

; 2386 :          q->abstotal = 1.0;

	mov	ecx, DWORD PTR _mode$[ebp]
	add	esp, 16					; 00000010H
	fstp	QWORD PTR [esi+152]
	fld1
	fstp	QWORD PTR [esi+168]
	mov	edi, DWORD PTR _gen_quant_list
	fldz
$LN22@calc_quant@2:

; 2376 :       }
; 2377 :     }
; 2378 :   }
; 2379 : 
; 2380 :   for ( k = 0 ; k < gen_quant_count ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	add	ebx, 368				; 00000170H
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _web+5528
	jl	SHORT $LN23@calc_quant@2
$LN492@calc_quant@2:

; 2384 :       if ( (q->flags & Q_COMPOUND) && (q->modulus != 0.0) )

	fstp	ST(0)

; 2387 :       }
; 2388 :   }
; 2389 : 
; 2390 :   if ( (mode & Q_FIXED) && web.torus_flag )

	test	cl, 2
	je	$LN14@calc_quant@2
	cmp	DWORD PTR _web+860, 0
	je	$LN14@calc_quant@2

; 2391 :   { /* munge fixed volumes modulo torus volume */
; 2392 :     for (  k = 0 ; k < gen_quant_count ; k++ )

	cmp	DWORD PTR _web+5528, 0
	mov	DWORD PTR _k$[ebp], 0
	jle	SHORT $LN14@calc_quant@2
	fld	QWORD PTR __real@3fe0000000000000
	xor	esi, esi
$LN16@calc_quant@2:

; 2393 :     { q = GEN_QUANT(k);
; 2394 :       if ( q->flags & Q_DELETED ) continue;

	mov	eax, DWORD PTR [esi+edi+136]
	test	eax, 524288				; 00080000H
	jne	SHORT $LN15@calc_quant@2

; 2395 :       if ( (q->flags & Q_FIXED) && (q->flags & TORUS_MODULO_MUNGE) ) 

	test	al, 2
	je	SHORT $LN15@calc_quant@2
	test	eax, 262144				; 00040000H
	je	SHORT $LN15@calc_quant@2

; 2396 :           q->value -= q->modulus*web.torusv*
; 2397 :                   (int)(0.5+(q->value - q->target)/(q->modulus*web.torusv));

	fld	QWORD PTR [esi+edi+152]
	lea	ebx, DWORD PTR [esi+edi+152]
	fld	QWORD PTR [esi+edi+176]
	fmul	QWORD PTR _web+1600
	fld	ST(1)
	fsub	QWORD PTR [esi+edi+144]
	fdiv	ST(0), ST(1)
	fadd	ST(0), ST(3)
	call	__ftol2_sse
	mov	DWORD PTR tv3129[ebp], eax
	fild	DWORD PTR tv3129[ebp]
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ebx]
	mov	edi, DWORD PTR _gen_quant_list
$LN15@calc_quant@2:

; 2391 :   { /* munge fixed volumes modulo torus volume */
; 2392 :     for (  k = 0 ; k < gen_quant_count ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	add	esi, 368				; 00000170H
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _web+5528
	jl	SHORT $LN16@calc_quant@2
	fstp	ST(0)
$LN14@calc_quant@2:

; 2398 :     }
; 2399 :   }
; 2400 : 
; 2401 :   /* take care of any cleanup */
; 2402 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	ebx, DWORD PTR _web+5560
	mov	esi, 1
	cmp	ebx, esi
	jle	SHORT $LN284@calc_quant@2
$LL11@calc_quant@2:

; 2403 :   { mi = METH_INSTANCE(k); /* since some init may move things */

	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2404 :     if ( mi->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax+140]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN10@calc_quant@2

; 2405 :     gm = basic_gen_methods + mi->gen_method;

	mov	eax, DWORD PTR [eax+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	add	eax, OFFSET _basic_gen_methods

; 2406 :     if ( gm->cleanup && mi->flags & Q_DOTHIS ) gm->cleanup();

	mov	eax, DWORD PTR [eax+156]
	test	eax, eax
	je	SHORT $LN10@calc_quant@2
	test	cl, 16					; 00000010H
	je	SHORT $LN10@calc_quant@2
	call	eax
	mov	ebx, DWORD PTR _web+5560
$LN10@calc_quant@2:

; 2398 :     }
; 2399 :   }
; 2400 : 
; 2401 :   /* take care of any cleanup */
; 2402 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL11@calc_quant@2
$LN284@calc_quant@2:

; 2407 :   }
; 2408 : 
; 2409 :   if ( compound_quant_list_head >= 0 )

	cmp	DWORD PTR _compound_quant_list_head, 0
	jl	SHORT $LN294@calc_quant@2

; 2410 :     for ( k = LOW_INST ; k < meth_inst_count ; k++ )

	mov	edi, 1
	cmp	ebx, edi
	jle	SHORT $LN294@calc_quant@2
$LL5@calc_quant@2:

; 2411 :     { mi = METH_INSTANCE(k);

	mov	eax, edi
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list

; 2412 :       if ( mi->flags & Q_DELETED ) continue;

	mov	eax, DWORD PTR [esi+140]
	test	eax, 524288				; 00080000H
	jne	SHORT $LN4@calc_quant@2

; 2413 :       if ( mi->flags & Q_COMPOUND )

	test	eax, 256				; 00000100H
	je	SHORT $LN4@calc_quant@2

; 2414 :       { free_matrix(mi->grad); mi->grad = NULL;

	mov	ecx, DWORD PTR [esi+2896]
	push	ecx
	call	_free_matrix
	mov	DWORD PTR [esi+2896], 0
	mov	ebx, DWORD PTR _web+5560
	add	esp, 4
$LN4@calc_quant@2:

; 2410 :     for ( k = LOW_INST ; k < meth_inst_count ; k++ )

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL5@calc_quant@2
	pop	edi
	pop	esi
	pop	ebx

; 2415 :       }
; 2416 :     }
; 2417 :     
; 2418 :   PROF_FINISH(calc_quant_grads);
; 2419 : } /* end calc_quant_grads() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN318@calc_quant@2:

; 2132 :         break;
; 2133 :       }
; 2134 :     }
; 2135 :   }
; 2136 :   if ( !todo ) 

	fstp	ST(0)
$LN294@calc_quant@2:
	pop	edi
$LN3@calc_quant@2:

; 2415 :       }
; 2416 :     }
; 2417 :     
; 2418 :   PROF_FINISH(calc_quant_grads);
; 2419 : } /* end calc_quant_grads() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_calc_quant_grads ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@EDKDDKLP@Method?5?$CFs?5has?5no?5Hessian?5availab@ ; `string'
PUBLIC	_rhs$GSCopy$
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_calc_quant_hess
EXTRN	_vgrad_end:PROC
EXTRN	_comp_quant_vertexi:DWORD
EXTRN	_comp_quant_vertexj:DWORD
EXTRN	_fill_grad:PROC
EXTRN	_comp_quant_type:DWORD
EXTRN	_sym_flags:DWORD
EXTRN	_m_rhs:DWORD
EXTRN	_m_mode:DWORD
EXTRN	_m_rhs_mode:DWORD
EXTRN	_m_hess_mode:DWORD
EXTRN	_fill_mixed_entry:PROC
EXTRN	_comp_quant_vj:DWORD
EXTRN	_comp_quant_vi:DWORD
EXTRN	_eval_second:PROC
EXTRN	_compound_hess_flag:DWORD
EXTRN	_quantity_function_sparse_flag:DWORD
;	COMDAT ??_C@_0CF@EDKDDKLP@Method?5?$CFs?5has?5no?5Hessian?5availab@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CF@EDKDDKLP@Method?5?$CFs?5has?5no?5Hessian?5availab@ DB 'Method %'
	DB	's has no Hessian available.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\quantity.c
CONST	ENDS
;	COMDAT _calc_quant_hess
_TEXT	SEGMENT
_secondsqXvS$ = -1848					; size = 48
_dummy$90832 = -1800					; size = 8
_dummy$90551 = -1792					; size = 8
_ccoeff$ = -1792					; size = 8
_p1$ = -1784						; size = 4
_global_needs$ = -1780					; size = 4
tv3246 = -1776						; size = 8
tv2992 = -1776						; size = 8
_dummy$90572 = -1768					; size = 8
tv6235 = -1764						; size = 4
_p2$ = -1764						; size = 4
_meth_offset$90627 = -1760				; size = 4
_setup_flag$90659 = -1756				; size = 4
_rhs$GSCopy$ = -1752					; size = 4
_needs$90660 = -1748					; size = 4
_flag$ = -1744						; size = 4
_seconds$ = -1740					; size = 4
tv6568 = -1736						; size = 4
_currentrow$90844 = -1736				; size = 4
_currentrow$90819 = -1736				; size = 4
tv6567 = -1732						; size = 4
_inum$ = -1732						; size = 4
_type$ = -1728						; size = 4
tv6280 = -1724						; size = 4
_e_ptr$ = -1724						; size = 4
_todo$ = -1724						; size = 4
_coeff$ = -1720						; size = 8
_coeff$90548 = -1720					; size = 8
tv4945 = -1712						; size = 4
tv3376 = -1712						; size = 4
tv3363 = -1712						; size = 4
tv1912 = -1712						; size = 4
_transpose$90879 = -1712				; size = 4
_S$GSCopy$ = -1708					; size = 4
_va$ = -1704						; size = 4
_j$ = -1704						; size = 4
_mi$ = -1700						; size = 4
_q$ = -1700						; size = 4
tv6537 = -1696						; size = 4
_k$ = -1696						; size = 4
tv4526 = -1692						; size = 4
tv4484 = -1692						; size = 4
_ggg$ = -1692						; size = 4
_transpose$90806 = -1692				; size = 4
_jj$ = -1692						; size = 4
tv5934 = -1688						; size = 4
_sign$90677 = -1688					; size = 4
_i$ = -1688						; size = 4
_secondsxJ$ = -1684					; size = 1152
_transposexJ$90878 = -532				; size = 288
_transposexJ$90805 = -532				; size = 288
_partials$90573 = -244					; size = 96
_partials$90552 = -244					; size = 96
_dummy$90854 = -196					; size = 48
_g$ = -148						; size = 48
_partials$90855 = -100					; size = 48
_partials$90833 = -100					; size = 48
_grad$90772 = -100					; size = 48
_tmp$90735 = -100					; size = 48
_grad$90834 = -52					; size = 48
_grad$90716 = -52					; size = 48
_transposeqXvS$90877 = -28				; size = 24
_transposeqXvS$90804 = -28				; size = 24
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_rhs_mode$ = 12						; size = 4
_hess_mode$ = 16					; size = 4
_rhs$ = 20						; size = 4
_calc_quant_hess PROC					; COMDAT

; 2436 : { int i,ii,k,j,jj,m,n;

	push	ebp
	mov	ebp, esp
	sub	esp, 1848				; 00000738H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2437 :   struct element *e_ptr;
; 2438 :   struct gen_quant *q = NULL;
; 2439 :   int flag;  /* 0 if doing global quantities, 1 for local */
; 2440 :   int type;  /* element type */
; 2441 :   struct method_instance  *mi;
; 2442 :   struct gen_quant_method *gm;
; 2443 :   int inum; 
; 2444 :   REAL g[MAXCOORD],*ggg;
; 2445 :   REAL **p1,**p2;
; 2446 :   struct hess_verlist *va,*vb;
; 2447 :   int mode = Q_ENERGY|Q_FIXED|Q_CONSERVED;
; 2448 :   REAL coeff; /* net modulus, including pressure if fixed quant */
; 2449 :   REAL ccoeff=0.0; /* net modulus */
; 2450 :   struct qinfo *q_info = &(GET_THREAD_DATA->q_info);  /* data passing structure */

	mov	edx, DWORD PTR _thread_data_key

; 2504 :           }
; 2505 :         }
; 2506 : 
; 2507 :       }
; 2508 :     }
; 2509 :   }
; 2510 :   compound_hess_flag = 0;
; 2511 :   comp_quant_stamp = 0;
; 2512 : 
; 2513 :   /* method initialization */
; 2514 :   for ( type = 0 ; type < NUMELEMENTS ; type++ ) quant_flags[type] = 0;
; 2515 :   for ( k = LOW_INST  ; k < meth_inst_count  ;k++ )

	mov	eax, DWORD PTR _S$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	push	ebx
	push	esi
	push	edi
	push	edx
	mov	DWORD PTR _S$GSCopy$[ebp], eax
	mov	DWORD PTR _rhs$GSCopy$[ebp], ecx
	call	_win_get_thread_data
	push	12					; 0000000cH
	lea	esi, DWORD PTR [eax+56]
	push	12					; 0000000cH
	lea	eax, DWORD PTR _secondsxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _secondsqXvS$[ebp]
	xor	edi, edi
	push	ecx
	mov	DWORD PTR _todo$[ebp], edi
	call	_mat2d_setup
	add	esp, 20					; 00000014H
	mov	ebx, eax
	mov	DWORD PTR _seconds$[ebp], ebx
	cmp	DWORD PTR [esi+1340], edi
	jne	SHORT $LN300@calc_quant@3

; 2451 :   int todo = 0;
; 2452 :   MAT2D(seconds,2*MAXCOORD,2*MAXCOORD);
; 2453 :   int global_needs;
; 2454 : #ifdef PROFILING_ENABLED
; 2455 :   __int32 hess_elapsed_time[2];
; 2456 : #endif
; 2457 : 
; 2458 :   PROF_START(calc_quant_hess);
; 2459 : 
; 2460 :   if ( q_info->hess == NULL )
; 2461 :     q_info_init(q_info,METHOD_HESSIAN);

	push	8763					; 0000223bH
	push	esi
	call	_q_info_init
	add	esp, 8
$LN300@calc_quant@3:

; 2462 : 
; 2463 :   if ( compound_quant_list_head >= 0 )

	cmp	DWORD PTR _compound_quant_list_head, edi
	jl	$LN541@calc_quant@3

; 2464 :   {
; 2465 :     /* get total gradients for compound quantities */
; 2466 :     vgrad_init();

	call	_vgrad_init

; 2467 :     calc_quant_grads(Q_COMPOUND|Q_FIXED|Q_ENERGY|Q_CONSERVED);

	push	267					; 0000010bH
	call	_calc_quant_grads
	add	esp, 4

; 2468 : 	if ( quantity_function_sparse_flag )

	cmp	DWORD PTR _quantity_function_sparse_flag, edi
	je	SHORT $LN298@calc_quant@3

; 2469 : 		add_vgrads_to_update(S);

	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	push	edx
	call	_add_vgrads_to_update
	add	esp, 4
$LN298@calc_quant@3:

; 2470 :     compound_hess_flag = CH_GRADS;

	mov	DWORD PTR _compound_hess_flag, 1

; 2471 :     for ( k = 0 ; k < gen_quant_count ; k++ )

	mov	DWORD PTR _k$[ebp], edi
	cmp	DWORD PTR _web+5528, edi
	jle	$LN541@calc_quant@3

; 2470 :     compound_hess_flag = CH_GRADS;

	mov	edx, DWORD PTR _web+48
	mov	DWORD PTR tv4484[ebp], edi
$LL297@calc_quant@3:

; 2472 :     { q = GEN_QUANT(k);

	mov	edi, DWORD PTR tv4484[ebp]
	add	edi, DWORD PTR _gen_quant_list

; 2473 :       if ( q->flags & Q_DELETED ) continue;

	mov	eax, DWORD PTR [edi+136]
	mov	DWORD PTR _q$[ebp], edi
	test	eax, 524288				; 00080000H
	jne	$LN296@calc_quant@3

; 2474 :       if ( !(q->flags & Q_COMPOUND ) ) continue;

	test	eax, 256				; 00000100H
	je	$LN296@calc_quant@3

; 2475 :       if ( q->flags & (Q_ENERGY|Q_FIXED|Q_CONSERVED) )

	test	al, 11					; 0000000bH
	je	$LN296@calc_quant@3

; 2476 :       { REAL coeff = q->modulus;

	fld	QWORD PTR [edi+176]
	fst	QWORD PTR _coeff$90548[ebp]

; 2477 :         if ( q->flags & (Q_FIXED|Q_CONSERVED) ) coeff *= -q->pressure; 

	test	al, 10					; 0000000aH
	je	SHORT $LN560@calc_quant@3
	fmul	QWORD PTR [edi+192]
	fchs
	fstp	QWORD PTR _coeff$90548[ebp]
	jmp	SHORT $LN291@calc_quant@3
$LN560@calc_quant@3:
	fstp	ST(0)
$LN291@calc_quant@3:

; 2478 : 
; 2479 :         if ( quantity_function_sparse_flag )

	cmp	DWORD PTR _quantity_function_sparse_flag, 0
	je	$LN290@calc_quant@3

; 2480 :         { /* second partials of quantity wrt methods */
; 2481 :           REAL dummy,partials[2*MAXCOORD];
; 2482 : 		  eval_second(&q->expr,NULL,q->method_count,&dummy,partials,seconds,NULLID);

	mov	ecx, DWORD PTR [edi+240]
	push	0
	push	ebx
	lea	edx, DWORD PTR _partials$90552[ebp]
	push	edx
	lea	eax, DWORD PTR _dummy$90551[ebp]
	push	eax
	push	ecx
	lea	edx, DWORD PTR [edi+256]
	push	0
	push	edx
	call	_eval_second

; 2483 :           for ( i = 0 ; i < q->method_count ; i++ )

	mov	edi, DWORD PTR [edi+240]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _i$[ebp], 0
	test	edi, edi
	jle	$LN496@calc_quant@3
	fld	QWORD PTR _coeff$90548[ebp]
$LN289@calc_quant@3:

; 2484 :           { int ii = METH_INSTANCE(q->meth_inst[i])->global_low_rank;

	mov	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _meth_inst_list
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	mov	ebx, DWORD PTR [eax+ecx+220]

; 2485 :             for ( j = 0 ; j < q->method_count ; j++ )   

	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN288@calc_quant@3

; 2484 :           { int ii = METH_INSTANCE(q->meth_inst[i])->global_low_rank;

	mov	edx, DWORD PTR _seconds$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR [edx+eax*4]
$LN495@calc_quant@3:

; 2486 :             { int jj = METH_INSTANCE(q->meth_inst[j])->global_low_rank;

	mov	edx, DWORD PTR _q$[ebp]

; 2487 :               S->low_rank_form[ii][jj] += coeff*seconds[i][j];

	fld	QWORD PTR [edi]
	mov	eax, DWORD PTR [edx+244]
	fmul	ST(0), ST(1)
	mov	eax, DWORD PTR [eax+ecx*4]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	mov	eax, DWORD PTR [eax+edx+220]
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	mov	edx, DWORD PTR [edx+220]
	mov	edx, DWORD PTR [edx+ebx*4]
	lea	eax, DWORD PTR [edx+eax*8]
	inc	ecx
	add	edi, 8
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR _q$[ebp]
	cmp	ecx, DWORD PTR [eax+240]
	jl	SHORT $LN495@calc_quant@3
$LN288@calc_quant@3:

; 2483 :           for ( i = 0 ; i < q->method_count ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	edi, DWORD PTR [ecx+240]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, edi
	jl	$LN289@calc_quant@3

; 2488 :             }
; 2489 :           }
; 2490 :         }
; 2491 :         else /* old dense way */

	mov	ebx, DWORD PTR _seconds$[ebp]
	fstp	ST(0)
$LN496@calc_quant@3:
	mov	edx, DWORD PTR _web+48
$LN296@calc_quant@3:

; 2471 :     for ( k = 0 ; k < gen_quant_count ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	add	DWORD PTR tv4484[ebp], 368		; 00000170H
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _web+5528
	jl	$LL297@calc_quant@3
	xor	edi, edi
$LN541@calc_quant@3:

; 2504 :           }
; 2505 :         }
; 2506 : 
; 2507 :       }
; 2508 :     }
; 2509 :   }
; 2510 :   compound_hess_flag = 0;
; 2511 :   comp_quant_stamp = 0;
; 2512 : 
; 2513 :   /* method initialization */
; 2514 :   for ( type = 0 ; type < NUMELEMENTS ; type++ ) quant_flags[type] = 0;
; 2515 :   for ( k = LOW_INST  ; k < meth_inst_count  ;k++ )

	mov	eax, 1
	mov	DWORD PTR _compound_hess_flag, edi
	mov	DWORD PTR _comp_quant_stamp, edi
	mov	DWORD PTR _web+5628, edi
	mov	DWORD PTR _web+5632, edi
	mov	DWORD PTR _web+5636, edi
	mov	DWORD PTR _web+5640, edi
	mov	DWORD PTR _web+5644, edi
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR _web+5560, eax
	jle	$LN301@calc_quant@3
	fldz
$LN260@calc_quant@3:

; 2516 :     { mi = METH_INSTANCE(k);

	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
	imul	edi, 2928				; 00000b70H
	add	edi, DWORD PTR _meth_inst_list

; 2517 :       if ( mi->flags & Q_DELETED ) continue;

	mov	eax, DWORD PTR [edi+140]
	test	eax, 524288				; 00080000H
	jne	$LN259@calc_quant@3

; 2518 :       mi->stamp = 0;  /* so only current methods used in eval_all() */
; 2519 :       gm = basic_gen_methods + mi->gen_method;

	mov	ebx, DWORD PTR [edi+148]
	fst	QWORD PTR [edi+2888]
	lea	ebx, DWORD PTR [ebx+ebx*4]
	shl	ebx, 5
	add	ebx, OFFSET _basic_gen_methods

; 2520 :       mi->flags |= Q_DOTHIS;

	or	eax, 16					; 00000010H
	lea	ecx, DWORD PTR [edi+152]
	mov	DWORD PTR [edi+140], eax

; 2521 :       for ( j = 0 ; j < MMAXQUANTS ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR tv4526[ebp], ecx
$LN555@calc_quant@3:

; 2522 :       { if ( mi->quants[j] < 0 )

	mov	edx, DWORD PTR tv4526[ebp]
	mov	eax, DWORD PTR [edx]
	test	eax, eax
	js	SHORT $LN255@calc_quant@3

; 2523 :            continue;
; 2524 :         q = GEN_QUANT(mi->quants[j]);
; 2525 :         if ( (!(mi->flags&Q_COMPOUND)  &&  
; 2526 :                         ((q->modulus == 0.0) || !(q->flags & mode)))
; 2527 :                   || (mi->modulus == 0.0) || 
; 2528 :              ( q->flags & Q_REDUNDANT ) )

	mov	ecx, DWORD PTR [edi+140]
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list
	mov	edx, eax
	test	ecx, 256				; 00000100H
	jne	SHORT $LN250@calc_quant@3
	fld	QWORD PTR [edx+176]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN251@calc_quant@3
	test	BYTE PTR [edx+136], 11			; 0000000bH
	je	SHORT $LN251@calc_quant@3
$LN250@calc_quant@3:
	fld	QWORD PTR [edi+304]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN251@calc_quant@3
	test	DWORD PTR [edx+136], 65536		; 00010000H
	je	$LN252@calc_quant@3
$LN251@calc_quant@3:

; 2529 :           mi->flags &= ~Q_DOTHIS;

	and	ecx, -17				; ffffffefH
	mov	DWORD PTR [edi+140], ecx
$LN255@calc_quant@3:

; 2521 :       for ( j = 0 ; j < MMAXQUANTS ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	add	DWORD PTR tv4526[ebp], 4
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, 8
	jl	$LN555@calc_quant@3

; 2485 :             for ( j = 0 ; j < q->method_count ; j++ )   

	jmp	$LN259@calc_quant@3
$LN290@calc_quant@3:

; 2492 :         FOR_ALL_VERTICES(comp_quant_vi)

	mov	DWORD PTR _comp_quant_vi, edx
	test	edx, 268435456				; 10000000H
	je	$LN296@calc_quant@3
	npad	9
$LL282@calc_quant@3:
	mov	eax, DWORD PTR _comp_quant_vi
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN281@calc_quant@3

; 2493 :         { REAL dummy,partials[2*MAXCOORD];
; 2494 :           if ( get_vattr(comp_quant_vi) & FIXED ) continue;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN281@calc_quant@3

; 2495 :           FOR_ALL_VERTICES(comp_quant_vj)

	mov	DWORD PTR _comp_quant_vj, edx
	test	edx, 268435456				; 10000000H
	je	$LN281@calc_quant@3
	npad	7
$LL276@calc_quant@3:
	mov	ecx, DWORD PTR _web+12
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv2992[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN275@calc_quant@3

; 2496 :           { 
; 2497 :             if ( comp_quant_vi > comp_quant_vj ) continue;

	cmp	DWORD PTR _comp_quant_vi, edx
	ja	$LN275@calc_quant@3

; 2498 :             if ( get_vattr(comp_quant_vj) & FIXED ) continue;

	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	jne	$LN275@calc_quant@3

; 2499 :             eval_second(&q->expr,NULL,2*SDIM,&dummy,partials,seconds,NULLID);

	mov	eax, DWORD PTR _web+616
	push	ecx
	push	ebx
	lea	ecx, DWORD PTR _partials$90573[ebp]
	push	ecx
	lea	edx, DWORD PTR _dummy$90572[ebp]
	push	edx
	mov	edx, DWORD PTR _q$[ebp]
	lea	ecx, DWORD PTR [eax+eax]
	push	ecx
	add	edx, 256				; 00000100H
	push	edi
	push	edx
	call	_eval_second

; 2500 :             for ( m = 0 ; m < SDIM ; m++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 28					; 0000001cH
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN267@calc_quant@3
	fld	QWORD PTR _coeff$90548[ebp]
$LN269@calc_quant@3:

; 2501 :              for ( n = 0 ; n < SDIM ; n++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN268@calc_quant@3
$LN266@calc_quant@3:
	add	ecx, edx
	mov	ecx, DWORD PTR [ebx+ecx*4]

; 2502 :               seconds[m+SDIM][n] *= coeff;

	fld	QWORD PTR [ecx+eax*8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fmul	ST(0), ST(1)
	inc	eax
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN266@calc_quant@3
$LN268@calc_quant@3:

; 2500 :             for ( m = 0 ; m < SDIM ; m++ )

	inc	edx
	cmp	edx, ecx
	jl	SHORT $LN269@calc_quant@3
	fstp	ST(0)
$LN267@calc_quant@3:

; 2503 :             fill_mixed_entry(S,comp_quant_vj,comp_quant_vi,seconds+SDIM);

	mov	eax, DWORD PTR _comp_quant_vi
	lea	edx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR _comp_quant_vj
	push	edx
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_fill_mixed_entry
	mov	edx, DWORD PTR _comp_quant_vj
	add	esp, 16					; 00000010H
$LN275@calc_quant@3:

; 2495 :           FOR_ALL_VERTICES(comp_quant_vj)

	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _comp_quant_vj, edx
	test	edx, 268435456				; 10000000H
	jne	$LL276@calc_quant@3
	mov	edx, DWORD PTR _web+48
$LN281@calc_quant@3:

; 2492 :         FOR_ALL_VERTICES(comp_quant_vi)

	mov	eax, DWORD PTR _comp_quant_vi
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _comp_quant_vi, eax
	test	eax, 268435456				; 10000000H
	jne	$LL282@calc_quant@3
	jmp	$LN296@calc_quant@3
$LN252@calc_quant@3:

; 2530 :         else
; 2531 :         { mi->flags |= Q_DOTHIS;

	or	DWORD PTR [edi+140], 16			; 00000010H

; 2532 :           if ( (gm->hessian == NULL) || (gm->hessian == null_q_hess) )

	mov	eax, DWORD PTR [ebx+152]
	test	eax, eax
	je	SHORT $LN593@calc_quant@3
	cmp	eax, OFFSET _null_q_hess
	jne	SHORT $LN248@calc_quant@3
$LN593@calc_quant@3:

; 2533 :           { sprintf(errmsg,"Method %s has no Hessian available.\n",gm->name);

	push	ebx
	fstp	ST(0)
	push	OFFSET ??_C@_0CF@EDKDDKLP@Method?5?$CFs?5has?5no?5Hessian?5availab@
	push	OFFSET _errmsg
	call	_sprintf

; 2534 :             kb_error(1571,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1571					; 00000623H
	call	_kb_error
	fldz
	add	esp, 24					; 00000018H
$LN248@calc_quant@3:

; 2535 :           }
; 2536 :           mi->newvalue = 0.0;

	fst	QWORD PTR [edi+328]

; 2537 :           mi->abstotal = 0.0;

	fst	QWORD PTR [edi+336]

; 2538 :           mi->timestamp = global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	mov	DWORD PTR [edi+2924], eax

; 2539 :           quant_flags[basic_gen_methods[mi->gen_method].type] |= mode;

	mov	eax, DWORD PTR [edi+148]

; 2540 :           if ( gm->init ) 

	mov	ebx, DWORD PTR [ebx+140]
	lea	ecx, DWORD PTR [eax+eax*4]
	shl	ecx, 5
	mov	eax, DWORD PTR _basic_gen_methods[ecx+128]
	or	DWORD PTR _web[eax*4+5628], 11		; 0000000bH
	test	ebx, ebx
	je	SHORT $LN246@calc_quant@3

; 2541 :               (*gm->init)(METHOD_HESSIAN,mi);

	push	edi
	fstp	ST(0)
	push	8763					; 0000223bH
	call	ebx
	fldz
	add	esp, 8
$LN246@calc_quant@3:

; 2542 :           todo = 1;

	mov	DWORD PTR _todo$[ebp], 1
$LN259@calc_quant@3:

; 2504 :           }
; 2505 :         }
; 2506 : 
; 2507 :       }
; 2508 :     }
; 2509 :   }
; 2510 :   compound_hess_flag = 0;
; 2511 :   comp_quant_stamp = 0;
; 2512 : 
; 2513 :   /* method initialization */
; 2514 :   for ( type = 0 ; type < NUMELEMENTS ; type++ ) quant_flags[type] = 0;
; 2515 :   for ( k = LOW_INST  ; k < meth_inst_count  ;k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _web+5560
	jl	$LN260@calc_quant@3

; 2543 :           break;
; 2544 :         }
; 2545 :       }
; 2546 :     }
; 2547 :   if ( !todo )

	cmp	DWORD PTR _todo$[ebp], 0
	fstp	ST(0)
	je	$LN301@calc_quant@3

; 2548 :   { PROF_FINISH(calc_quant_hess);
; 2549 :     return;
; 2550 :   }
; 2551 : 
; 2552 :   /* set up matrices in qinfo with lots of room */
; 2553 :   q_info->hess = dmatrix4(MAXVCOUNT,MAXVCOUNT,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	2553					; 000009f9H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	eax
	push	eax
	push	100					; 00000064H
	push	100					; 00000064H
	call	_kb_dmatrix4

; 2554 :   p1 = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);

	push	2554					; 000009faH
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	5
	push	0
	push	5
	push	0
	mov	DWORD PTR [esi+1340], eax
	call	_kb_dmatrix

; 2555 :   p2 = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);

	push	2555					; 000009fbH
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	5
	push	0
	push	5
	push	0
	mov	DWORD PTR _p1$[ebp], eax
	call	_kb_dmatrix
	add	esp, 72					; 00000048H

; 2556 : 
; 2557 :   if ( compound_quant_list_head >= 0 )

	cmp	DWORD PTR _compound_quant_list_head, 0
	mov	DWORD PTR _p2$[ebp], eax
	jl	SHORT $LN498@calc_quant@3

; 2558 :     {  
; 2559 :       for (  k=LOW_INST ; k < meth_inst_count ; k++ )

	mov	ebx, 1
	cmp	DWORD PTR _web+5560, ebx
	jle	SHORT $LN498@calc_quant@3
$LL243@calc_quant@3:

; 2560 :       { mi = METH_INSTANCE(k);

	mov	eax, ebx
	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
	imul	edi, 2928				; 00000b70H
	add	edi, DWORD PTR _meth_inst_list

; 2561 :         if ( mi->flags & Q_COMPOUND )

	test	DWORD PTR [edi+140], 256		; 00000100H
	je	SHORT $LN242@calc_quant@3

; 2562 :         { mi->grad = dmatrix(0,MAXVCOUNT,0,SDIM);

	mov	edx, DWORD PTR _web+616
	push	2562					; 00000a02H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	edx
	push	0
	push	100					; 00000064H
	push	0
	call	_kb_dmatrix

; 2563 :           mi->hess = dmatrix4(MAXVCOUNT,MAXVCOUNT,SDIM,SDIM);

	push	2563					; 00000a03H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	mov	DWORD PTR [edi+2896], eax
	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	push	100					; 00000064H
	push	100					; 00000064H
	call	_kb_dmatrix4
	add	esp, 48					; 00000030H
	mov	DWORD PTR [edi+2900], eax
$LN242@calc_quant@3:

; 2558 :     {  
; 2559 :       for (  k=LOW_INST ; k < meth_inst_count ; k++ )

	inc	ebx
	cmp	ebx, DWORD PTR _web+5560
	jl	SHORT $LL243@calc_quant@3
$LN498@calc_quant@3:

; 2564 :         }
; 2565 :       }
; 2566 :     }
; 2567 : 
; 2568 :   for ( type = VERTEX ; type <= BODY ; type++ )

	xor	ebx, ebx
	mov	DWORD PTR _type$[ebp], ebx
	npad	6
$LL239@calc_quant@3:

; 2569 :   if ( quant_flags[type] & mode )

	test	BYTE PTR _web[ebx*4+5628], 11		; 0000000bH
	je	$LN238@calc_quant@3

; 2570 :   { int meth_offset = get_meth_offset(type); 

	mov	eax, DWORD PTR _web[ebx*4+5664]
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	mov	edi, ebx
	imul	edi, 112				; 00000070H
	add	eax, DWORD PTR _web[edi+104]

; 2571 : #if defined(SHARED_MEMORY)
; 2572 :     if ( (compound_quant_list_head == -1) && ((nprocs > 1) || threadflag) ) 

	cmp	DWORD PTR _compound_quant_list_head, -1
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	DWORD PTR _meth_offset$90627[ebp], edx
	jne	$LN544@calc_quant@3
	cmp	DWORD PTR _nprocs, 1
	jg	SHORT $LN542@calc_quant@3
	cmp	DWORD PTR _threadflag, 0
	je	$LN544@calc_quant@3
$LN542@calc_quant@3:

; 2573 :     { 
; 2574 :       if ( el_list_timestamp[VERTEX] < top_timestamp )

	mov	eax, DWORD PTR _el_list_timestamp
	cmp	eax, DWORD PTR _top_timestamp
	jge	SHORT $LN543@calc_quant@3

; 2575 :          make_el_list(VERTEX);  /* need for force */

	push	0
	call	_make_el_list
	add	esp, 4
$LN543@calc_quant@3:

; 2576 :       if ( el_list_timestamp[type] < top_timestamp )

	mov	ecx, DWORD PTR _top_timestamp
	cmp	DWORD PTR _el_list_timestamp[ebx*4], ecx
	jge	SHORT $LN232@calc_quant@3

; 2577 :          make_el_list(type);

	push	ebx
	call	_make_el_list
	add	esp, 4
$LN232@calc_quant@3:

; 2578 :       for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	edi, 1
	cmp	DWORD PTR _web+5560, edi
	jle	SHORT $LN229@calc_quant@3
	fldz
$LN231@calc_quant@3:

; 2579 :       { mi = METH_INSTANCE(k); 

	mov	eax, edi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2580 :         if ( mi->flags & Q_DOTHIS )

	test	BYTE PTR [eax+140], 16			; 00000010H
	je	SHORT $LN230@calc_quant@3

; 2581 :           for ( i = 0 ; i < nprocs ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _nprocs, ecx
	jle	SHORT $LN230@calc_quant@3
	add	eax, 1736				; 000006c8H
$LN227@calc_quant@3:

; 2582 :           {  mi->procvalue[i] = 0.0;

	fst	QWORD PTR [eax-1152]
	inc	ecx

; 2583 :              mi->procabstotal[i] = 0.0;

	fst	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _nprocs
	jl	SHORT $LN227@calc_quant@3
$LN230@calc_quant@3:

; 2578 :       for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	edi
	cmp	edi, DWORD PTR _web+5560
	jl	SHORT $LN231@calc_quant@3
	fstp	ST(0)
$LN229@calc_quant@3:

; 2584 :           }
; 2585 :       }
; 2586 :       m_hess_mode = hess_mode;

	mov	edx, DWORD PTR _hess_mode$[ebp]

; 2587 :       m_rhs_mode  = rhs_mode;

	mov	eax, DWORD PTR _rhs_mode$[ebp]

; 2588 : #ifdef SGI_MULTI
; 2589 :       if ( mpflag == M_INACTIVE ) m_rele_procs();  /* resume parked procs */
; 2590 :       mpflag = M_ACTIVE;
; 2591 :       m_quanrowstart = S->quanrowstart;
; 2592 :       m_fork(m_calc_quant_hess,type,mode,rhs);
; 2593 :       m_park_procs();
; 2594 :       mpflag = M_INACTIVE; 
; 2595 : #endif
; 2596 : #ifdef THREADS
; 2597 :       m_type = type;
; 2598 :       m_mode = mode;
; 2599 :       m_rhs  = rhs;

	mov	ecx, DWORD PTR _rhs$GSCopy$[ebp]

; 2600 :       thread_launch(TH_MULTI_QUANT_HESS,type);

	push	ebx
	push	7
	mov	DWORD PTR _m_hess_mode, edx
	mov	DWORD PTR _m_rhs_mode, eax
	mov	DWORD PTR _m_type, ebx
	mov	DWORD PTR _m_mode, 11			; 0000000bH
	mov	DWORD PTR _m_rhs, ecx
	call	_thread_launch

; 2601 : #endif
; 2602 :       m_fix_hess(S);

	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	push	edx
	call	_m_fix_hess

; 2603 :       /* sum separate process values */
; 2604 :       for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	edi, 1
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+5560, edi
	jle	$LN238@calc_quant@3
$LL224@calc_quant@3:

; 2605 :       { mi = METH_INSTANCE(k); 

	mov	eax, edi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2606 :         if ( mi->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax+140]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN223@calc_quant@3

; 2607 :         if ( mi->flags & Q_DOTHIS )

	test	cl, 16					; 00000010H
	je	SHORT $LN223@calc_quant@3

; 2608 :           for ( i = 0 ; i < nprocs ; i++ )

	xor	edx, edx
	cmp	DWORD PTR _nprocs, edx
	jle	SHORT $LN223@calc_quant@3
	lea	ecx, DWORD PTR [eax+1736]
	npad	4
$LL540@calc_quant@3:

; 2609 :           { mi->newvalue += mi->procvalue[i];

	fld	QWORD PTR [ecx-1152]
	inc	edx
	fadd	QWORD PTR [eax+328]
	add	ecx, 8
	fstp	QWORD PTR [eax+328]

; 2610 :             mi->abstotal += mi->procabstotal[i];

	fld	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx-8]
	fstp	QWORD PTR [eax+336]
	cmp	edx, DWORD PTR _nprocs
	jl	SHORT $LL540@calc_quant@3
$LN223@calc_quant@3:

; 2603 :       /* sum separate process values */
; 2604 :       for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	edi
	cmp	edi, DWORD PTR _web+5560
	jl	SHORT $LL224@calc_quant@3

; 2611 :           }
; 2612 :       }
; 2613 :     }
; 2614 :     else

	jmp	$LN732@calc_quant@3
$LN544@calc_quant@3:

; 2615 : #endif
; 2616 :    {
; 2617 :    
; 2618 :     global_needs = global_meth_needs(type);

	push	ebx
	call	_global_meth_needs

; 2619 :     FOR_ALL_ELEMENTS(type,q_info->id)

	mov	edi, DWORD PTR _web[edi+48]
	add	esp, 4
	mov	DWORD PTR _global_needs$[ebp], eax
	mov	DWORD PTR [esi], edi
	test	edi, 268435456				; 10000000H
	je	$LN238@calc_quant@3
	npad	2
$LL215@calc_quant@3:
	mov	eax, DWORD PTR [esi]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN214@calc_quant@3

; 2621 :       int needs;
; 2622 :       ++comp_quant_stamp;

	inc	DWORD PTR _comp_quant_stamp

; 2623 :       e_ptr = elptr(q_info->id);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _setup_flag$90659[ebp], ecx
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]

; 2624 :       /* get setup flags */
; 2625 :       needs = global_needs;

	mov	ecx, DWORD PTR _global_needs$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _e_ptr$[ebp], eax

; 2626 :       for ( k = 0 ; k < e_ptr->method_count ; k++ )

	movzx	eax, WORD PTR [eax+24]
	mov	DWORD PTR _needs$90660[ebp], ecx
	test	eax, eax
	jle	SHORT $LN208@calc_quant@3

; 2620 :     { int setup_flag = 0;

	mov	ecx, DWORD PTR _meth_offset$90627[ebp]
	add	ecx, DWORD PTR _e_ptr$[ebp]
	mov	ebx, DWORD PTR _meth_inst_list
	mov	edi, eax
	npad	6
$LL210@calc_quant@3:

; 2627 :       { int mm;
; 2628 :         mm = ((int*)((char*)e_ptr+meth_offset))[k];
; 2629 :         mi = METH_INSTANCE(abs(mm));

	mov	eax, DWORD PTR [ecx]
	cdq
	xor	eax, edx
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H

; 2630 :         if ( (mi->flags & Q_DOTHIS) && (mi->type == type) )

	test	BYTE PTR [eax+ebx+140], 16		; 00000010H
	je	SHORT $LN209@calc_quant@3
	mov	edx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+ebx+136], edx
	jne	SHORT $LN209@calc_quant@3

; 2631 :         needs |= basic_gen_methods[mi->gen_method].flags;

	mov	eax, DWORD PTR [eax+ebx+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	mov	edx, DWORD PTR _basic_gen_methods[eax+132]
	or	DWORD PTR _needs$90660[ebp], edx
$LN209@calc_quant@3:

; 2626 :       for ( k = 0 ; k < e_ptr->method_count ; k++ )

	add	ecx, 4
	dec	edi
	jne	SHORT $LL210@calc_quant@3
$LN208@calc_quant@3:

; 2632 :       }
; 2633 :       inum = global_meth_inst_count[type];

	mov	eax, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR _web[eax*4+5588]

; 2634 :       for ( flag = 0 ; flag < 2 ; flag++,inum = e_ptr->method_count,k=0 )

	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR _inum$[ebp], edx
	mov	DWORD PTR _flag$[ebp], 0
	npad	3
$LL206@calc_quant@3:

; 2635 :         for ( k = 0 ; k < inum ; k++ )

	xor	eax, eax
	mov	DWORD PTR _k$[ebp], eax
	test	edx, edx
	jle	$LN205@calc_quant@3
$LL549@calc_quant@3:

; 2636 :         { int mm;
; 2637 :           int sign = 1;
; 2638 :           if ( flag ) 

	cmp	DWORD PTR _flag$[ebp], 0
	mov	DWORD PTR _sign$90677[ebp], 1
	je	SHORT $LN200@calc_quant@3

; 2639 :           { mm = ((int*)((char*)e_ptr+meth_offset))[k];

	mov	ecx, DWORD PTR _e_ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _meth_offset$90627[ebp]
	mov	ecx, DWORD PTR [edx+eax]

; 2640 :             q_info->method = abs(mm);

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR [esi+8], eax

; 2641 :             if ( mm < 0 ) sign = -1;

	test	ecx, ecx
	jns	SHORT $LN198@calc_quant@3
	mov	DWORD PTR _sign$90677[ebp], -1

; 2642 :           }
; 2643 :           else  q_info->method = global_meth_inst[type][k];

	jmp	SHORT $LN198@calc_quant@3
$LN200@calc_quant@3:
	mov	ecx, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR _web[ecx*4+5568]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [esi+8], eax
$LN198@calc_quant@3:

; 2644 :           mi = METH_INSTANCE(q_info->method);

	mov	eax, DWORD PTR [esi+8]
	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
	imul	edi, 2928				; 00000b70H
	add	edi, DWORD PTR _meth_inst_list

; 2645 :           if ( (mi->flags & Q_DOTHIS) && (mi->type == type) )

	test	BYTE PTR [edi+140], 16			; 00000010H
	mov	DWORD PTR _mi$[ebp], edi
	je	$LN507@calc_quant@3
	mov	eax, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [edi+136], eax
	jne	$LN507@calc_quant@3

; 2646 :           { REAL value;
; 2647 : 
; 2648 :             PROF_START(element_setup);
; 2649 :             if ( !setup_flag ) 

	cmp	DWORD PTR _setup_flag$90659[ebp], 0
	jne	SHORT $LN196@calc_quant@3

; 2650 :             { (*q_setup[type])(S,q_info,needs); setup_flag = 1; }

	mov	ecx, DWORD PTR _needs$90660[ebp]
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	mov	eax, DWORD PTR _q_setup[eax*4]
	push	ecx
	push	esi
	push	edx
	call	eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _setup_flag$90659[ebp], 1
$LN196@calc_quant@3:

; 2651 :             PROF_FINISH(element_setup);
; 2652 :             
; 2653 :             coeff = ccoeff = 0.0;

	fldz

; 2654 :             for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2655 :             { 
; 2656 :               if ( mi->quants[j] < 0 ) 

	mov	eax, DWORD PTR [edi+152]
	mov	ecx, DWORD PTR _gen_quant_list
	fld	ST(0)
	fst	QWORD PTR _coeff$[ebp]
	test	eax, eax
	js	SHORT $LN611@calc_quant@3

; 2657 :                 continue;
; 2658 :               q = GEN_QUANT(mi->quants[j]);

	imul	eax, 368				; 00000170H

; 2664 :                 coeff += sign*q->modulus*mi->modulus;      

	fstp	ST(0)
	fild	DWORD PTR _sign$90677[ebp]
	add	eax, ecx
	test	BYTE PTR [eax+136], 10			; 0000000aH
	je	SHORT $LN191@calc_quant@3

; 2659 :               if ( q->flags & (Q_FIXED|Q_CONSERVED) )
; 2660 :               { ccoeff += sign*q->modulus*mi->modulus; 
; 2661 :                 coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	fsubp	ST(1), ST(0)
	fst	QWORD PTR _coeff$[ebp]

; 2662 :               }
; 2663 :               else 

	jmp	SHORT $LN194@calc_quant@3
$LN191@calc_quant@3:

; 2664 :                 coeff += sign*q->modulus*mi->modulus;      

	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _coeff$[ebp]
	jmp	SHORT $LN194@calc_quant@3
$LN611@calc_quant@3:
	fstp	ST(1)
$LN194@calc_quant@3:

; 2654 :             for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2655 :             { 
; 2656 :               if ( mi->quants[j] < 0 ) 

	mov	eax, DWORD PTR [edi+156]
	test	eax, eax
	js	SHORT $LN459@calc_quant@3

; 2659 :               if ( q->flags & (Q_FIXED|Q_CONSERVED) )
; 2660 :               { ccoeff += sign*q->modulus*mi->modulus; 
; 2661 :                 coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fild	DWORD PTR _sign$90677[ebp]
	imul	eax, 368				; 00000170H
	add	eax, ecx
	test	BYTE PTR [eax+136], 10			; 0000000aH
	je	SHORT $LN458@calc_quant@3
	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	fsubp	ST(1), ST(0)

; 2662 :               }
; 2663 :               else 

	jmp	SHORT $LN733@calc_quant@3
$LN458@calc_quant@3:

; 2664 :                 coeff += sign*q->modulus*mi->modulus;      

	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	faddp	ST(1), ST(0)
$LN733@calc_quant@3:
	fst	QWORD PTR _coeff$[ebp]
$LN459@calc_quant@3:

; 2654 :             for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2655 :             { 
; 2656 :               if ( mi->quants[j] < 0 ) 

	mov	eax, DWORD PTR [edi+160]
	test	eax, eax
	js	SHORT $LN462@calc_quant@3

; 2659 :               if ( q->flags & (Q_FIXED|Q_CONSERVED) )
; 2660 :               { ccoeff += sign*q->modulus*mi->modulus; 
; 2661 :                 coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fild	DWORD PTR _sign$90677[ebp]
	imul	eax, 368				; 00000170H
	add	eax, ecx
	test	BYTE PTR [eax+136], 10			; 0000000aH
	je	SHORT $LN461@calc_quant@3
	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	fsubp	ST(1), ST(0)

; 2662 :               }
; 2663 :               else 

	jmp	SHORT $LN734@calc_quant@3
$LN461@calc_quant@3:

; 2664 :                 coeff += sign*q->modulus*mi->modulus;      

	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	faddp	ST(1), ST(0)
$LN734@calc_quant@3:
	fst	QWORD PTR _coeff$[ebp]
$LN462@calc_quant@3:

; 2654 :             for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2655 :             { 
; 2656 :               if ( mi->quants[j] < 0 ) 

	mov	eax, DWORD PTR [edi+164]
	test	eax, eax
	js	SHORT $LN465@calc_quant@3

; 2659 :               if ( q->flags & (Q_FIXED|Q_CONSERVED) )
; 2660 :               { ccoeff += sign*q->modulus*mi->modulus; 
; 2661 :                 coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fild	DWORD PTR _sign$90677[ebp]
	imul	eax, 368				; 00000170H
	add	eax, ecx
	test	BYTE PTR [eax+136], 10			; 0000000aH
	je	SHORT $LN464@calc_quant@3
	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	fsubp	ST(1), ST(0)

; 2662 :               }
; 2663 :               else 

	jmp	SHORT $LN735@calc_quant@3
$LN464@calc_quant@3:

; 2664 :                 coeff += sign*q->modulus*mi->modulus;      

	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	faddp	ST(1), ST(0)
$LN735@calc_quant@3:
	fst	QWORD PTR _coeff$[ebp]
$LN465@calc_quant@3:

; 2654 :             for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2655 :             { 
; 2656 :               if ( mi->quants[j] < 0 ) 

	mov	eax, DWORD PTR [edi+168]
	test	eax, eax
	js	SHORT $LN468@calc_quant@3

; 2659 :               if ( q->flags & (Q_FIXED|Q_CONSERVED) )
; 2660 :               { ccoeff += sign*q->modulus*mi->modulus; 
; 2661 :                 coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fild	DWORD PTR _sign$90677[ebp]
	imul	eax, 368				; 00000170H
	add	eax, ecx
	test	BYTE PTR [eax+136], 10			; 0000000aH
	je	SHORT $LN467@calc_quant@3
	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	fsubp	ST(1), ST(0)

; 2662 :               }
; 2663 :               else 

	jmp	SHORT $LN736@calc_quant@3
$LN467@calc_quant@3:

; 2664 :                 coeff += sign*q->modulus*mi->modulus;      

	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	faddp	ST(1), ST(0)
$LN736@calc_quant@3:
	fst	QWORD PTR _coeff$[ebp]
$LN468@calc_quant@3:

; 2654 :             for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2655 :             { 
; 2656 :               if ( mi->quants[j] < 0 ) 

	mov	eax, DWORD PTR [edi+172]
	test	eax, eax
	js	SHORT $LN471@calc_quant@3

; 2659 :               if ( q->flags & (Q_FIXED|Q_CONSERVED) )
; 2660 :               { ccoeff += sign*q->modulus*mi->modulus; 
; 2661 :                 coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fild	DWORD PTR _sign$90677[ebp]
	imul	eax, 368				; 00000170H
	add	eax, ecx
	test	BYTE PTR [eax+136], 10			; 0000000aH
	je	SHORT $LN470@calc_quant@3
	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	fsubp	ST(1), ST(0)

; 2662 :               }
; 2663 :               else 

	jmp	SHORT $LN737@calc_quant@3
$LN470@calc_quant@3:

; 2664 :                 coeff += sign*q->modulus*mi->modulus;      

	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	faddp	ST(1), ST(0)
$LN737@calc_quant@3:
	fst	QWORD PTR _coeff$[ebp]
$LN471@calc_quant@3:

; 2654 :             for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2655 :             { 
; 2656 :               if ( mi->quants[j] < 0 ) 

	mov	eax, DWORD PTR [edi+176]
	test	eax, eax
	js	SHORT $LN474@calc_quant@3

; 2659 :               if ( q->flags & (Q_FIXED|Q_CONSERVED) )
; 2660 :               { ccoeff += sign*q->modulus*mi->modulus; 
; 2661 :                 coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fild	DWORD PTR _sign$90677[ebp]
	imul	eax, 368				; 00000170H
	add	eax, ecx
	test	BYTE PTR [eax+136], 10			; 0000000aH
	je	SHORT $LN473@calc_quant@3
	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	fsubp	ST(1), ST(0)

; 2662 :               }
; 2663 :               else 

	jmp	SHORT $LN738@calc_quant@3
$LN473@calc_quant@3:

; 2664 :                 coeff += sign*q->modulus*mi->modulus;      

	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	faddp	ST(1), ST(0)
$LN738@calc_quant@3:
	fst	QWORD PTR _coeff$[ebp]
$LN474@calc_quant@3:

; 2654 :             for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2655 :             { 
; 2656 :               if ( mi->quants[j] < 0 ) 

	mov	eax, DWORD PTR [edi+180]
	test	eax, eax
	js	SHORT $LN653@calc_quant@3

; 2659 :               if ( q->flags & (Q_FIXED|Q_CONSERVED) )
; 2660 :               { ccoeff += sign*q->modulus*mi->modulus; 
; 2661 :                 coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fild	DWORD PTR _sign$90677[ebp]
	imul	eax, 368				; 00000170H
	add	eax, ecx
	test	BYTE PTR [eax+136], 10			; 0000000aH
	je	SHORT $LN476@calc_quant@3
	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _coeff$[ebp]

; 2662 :               }
; 2663 :               else 

	jmp	SHORT $LN477@calc_quant@3
$LN476@calc_quant@3:

; 2664 :                 coeff += sign*q->modulus*mi->modulus;      

	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [edi+304]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _coeff$[ebp]
	jmp	SHORT $LN477@calc_quant@3
$LN653@calc_quant@3:
	fstp	ST(0)
$LN477@calc_quant@3:

; 2665 :             }
; 2666 :              
; 2667 :             METHOD_PROFILING_START(mi,hess);
; 2668 :             gm = basic_gen_methods + mi->gen_method;

	mov	eax, DWORD PTR [edi+148]
	lea	ebx, DWORD PTR [eax+eax*4]
	shl	ebx, 5

; 2669 :             zerohess(q_info);

	push	esi
	add	ebx, OFFSET _basic_gen_methods
	call	_zerohess
	add	esp, 4

; 2670 :             if ( hess_mode ) value = (*gm->hessian)(q_info);

	cmp	DWORD PTR _hess_mode$[ebp], 0
	push	esi
	je	SHORT $LN189@calc_quant@3
	mov	ecx, DWORD PTR [ebx+152]
	call	ecx
	jmp	SHORT $LN739@calc_quant@3
$LN189@calc_quant@3:

; 2671 :             else value = (*gm->gradient)(q_info);

	mov	edx, DWORD PTR [ebx+148]
	call	edx
$LN739@calc_quant@3:
	add	esp, 4

; 2672 :             if ( mi->flags & ELEMENT_MODULUS_FLAG )

	test	DWORD PTR [edi+140], 268435456		; 10000000H
	je	$LN178@calc_quant@3

; 2673 :             { REAL emdls = *(REAL*)get_extra(q_info->id,mi->elmodulus);

	mov	ecx, DWORD PTR [esi]
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	mov	edx, edi
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR [edx+228]
	mov	edi, DWORD PTR _web[eax+104]
	imul	edx, 240				; 000000f0H
	mov	eax, DWORD PTR _web[eax+12]
	add	edi, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edi+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]

; 2674 :               value *= emdls;
; 2675 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	mov	ecx, DWORD PTR _web+616
	fld	QWORD PTR [edx+eax]
	xor	edx, edx
	fld	ST(0)
	fmulp	ST(2), ST(0)
	cmp	DWORD PTR [esi+12], edx
	jle	SHORT $LN184@calc_quant@3
$LN186@calc_quant@3:

; 2676 :                 for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN185@calc_quant@3
$LN183@calc_quant@3:
	mov	ecx, DWORD PTR [esi+1336]
	mov	ecx, DWORD PTR [ecx+edx*4]

; 2677 :                   q_info->grad[i][j] *= emdls;

	fld	QWORD PTR [ecx+eax*8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fmul	ST(0), ST(1)
	inc	eax
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN183@calc_quant@3
$LN185@calc_quant@3:

; 2674 :               value *= emdls;
; 2675 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	inc	edx
	cmp	edx, DWORD PTR [esi+12]
	jl	SHORT $LN186@calc_quant@3
$LN184@calc_quant@3:

; 2678 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	xor	edi, edi
	cmp	DWORD PTR [esi+12], edi
	jle	SHORT $LN679@calc_quant@3
$LN180@calc_quant@3:

; 2679 :                for ( ii = 0 ; ii < q_info->vcount ; ii++ )

	xor	ebx, ebx
	cmp	DWORD PTR [esi+12], ebx
	jle	SHORT $LN179@calc_quant@3
$LN177@calc_quant@3:

; 2680 :                 for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN176@calc_quant@3
$LN174@calc_quant@3:

; 2681 :                  for ( jj = 0 ; jj < SDIM ; jj++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN173@calc_quant@3
$LN171@calc_quant@3:
	mov	ecx, DWORD PTR [esi+1340]
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [ecx+edx*4]

; 2682 :                    q_info->hess[i][ii][j][jj] *= emdls;

	fld	QWORD PTR [ecx+eax*8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fmul	ST(0), ST(1)
	inc	eax
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN171@calc_quant@3
$LN173@calc_quant@3:

; 2680 :                 for ( j = 0 ; j < SDIM ; j++ )

	inc	edx
	cmp	edx, ecx
	jl	SHORT $LN174@calc_quant@3
$LN176@calc_quant@3:

; 2679 :                for ( ii = 0 ; ii < q_info->vcount ; ii++ )

	inc	ebx
	cmp	ebx, DWORD PTR [esi+12]
	jl	SHORT $LN177@calc_quant@3
$LN179@calc_quant@3:

; 2678 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	inc	edi
	cmp	edi, DWORD PTR [esi+12]
	jl	SHORT $LN180@calc_quant@3
$LN679@calc_quant@3:

; 2681 :                  for ( jj = 0 ; jj < SDIM ; jj++ )

	fstp	ST(0)
$LN178@calc_quant@3:

; 2684 :             mi->newvalue += sign*value;

	fild	DWORD PTR _sign$90677[ebp]
	mov	edx, DWORD PTR _mi$[ebp]
	fst	QWORD PTR tv3246[ebp]
	fld	ST(1)
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [edx+328]
	fstp	QWORD PTR [edx+328]

; 2685 :             mi->abstotal += fabs(value);

	fxch	ST(1)
	fabs
	fadd	QWORD PTR [edx+336]
	fstp	QWORD PTR [edx+336]

; 2686 : 
; 2687 :             /* unwrap */
; 2688 :             if ( sym_flags & NEED_FORM_UNWRAPPING )

	test	BYTE PTR _sym_flags, 2
	mov	ecx, DWORD PTR _web+616
	je	$LN157@calc_quant@3

; 2689 :             { /* gradient */
; 2690 :               REAL grad[MAXCOORD];
; 2691 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	cmp	DWORD PTR [esi+12], 0
	mov	DWORD PTR _i$[ebp], 0
	jle	$LN165@calc_quant@3
	mov	edi, -816				; fffffcd0H
	fstp	ST(0)
	sub	edi, esi
	lea	ebx, DWORD PTR [esi+816]
	mov	DWORD PTR tv4945[ebp], edi
	jmp	SHORT $LN167@calc_quant@3
	npad	8
$LL550@calc_quant@3:

; 2683 :             }

	mov	edi, DWORD PTR tv4945[ebp]
$LN167@calc_quant@3:

; 2692 :               { if ( q_info->wraps[i] )

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN166@calc_quant@3

; 2693 :                 { (*sym_form_pullback)(q_info->x[i],grad,q_info->grad[i],
; 2694 :                                   q_info->wraps[i]);

	mov	edx, DWORD PTR [esi+1336]
	push	eax
	add	edi, ebx
	mov	eax, DWORD PTR [edi+edx]
	mov	edx, DWORD PTR [ebx-400]
	push	eax
	lea	ecx, DWORD PTR _grad$90716[ebp]
	push	ecx
	push	edx
	call	DWORD PTR _sym_form_pullback

; 2695 :                   for ( j = 0 ; j < SDIM ; j++ ) q_info->grad[i][j] = grad[j];

	mov	ecx, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN166@calc_quant@3
	npad	7
$LL163@calc_quant@3:
	mov	ecx, DWORD PTR [esi+1336]
	fld	QWORD PTR _grad$90716[ebp+eax*8]
	mov	edx, DWORD PTR [edi+ecx]
	fstp	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _web+616
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL163@calc_quant@3
$LN166@calc_quant@3:

; 2689 :             { /* gradient */
; 2690 :               REAL grad[MAXCOORD];
; 2691 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	ebx, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [esi+12]
	jl	SHORT $LL550@calc_quant@3
	fld	QWORD PTR tv3246[ebp]
	mov	edx, DWORD PTR _mi$[ebp]
$LN165@calc_quant@3:

; 2696 :                 }
; 2697 :               }
; 2698 :               if ( hess_mode )

	cmp	DWORD PTR _hess_mode$[ebp], 0
	je	$LN157@calc_quant@3

; 2699 :               { for ( i = 0 ; i < q_info->vcount ; i++ )

	xor	ebx, ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	DWORD PTR [esi+12], ebx
	jle	$LN157@calc_quant@3
$LN159@calc_quant@3:

; 2700 :                 for ( ii = 0 ; ii < q_info->vcount ; ii++ )

	xor	edi, edi
	cmp	DWORD PTR [esi+12], edi
	jle	$LN158@calc_quant@3
	fstp	ST(0)
$LN156@calc_quant@3:

; 2701 :                 { if ( q_info->wraps[i] )

	cmp	DWORD PTR [esi+ebx*4+816], 0
	je	$LN150@calc_quant@3

; 2702 :                     for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	DWORD PTR _jj$[ebp], 0
	test	ecx, ecx
	jle	$LN150@calc_quant@3
$LL152@calc_quant@3:

; 2703 :                     { REAL tmp[MAXCOORD];
; 2704 :                       for ( j = 0 ; j < SDIM ; j++ ) 

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN147@calc_quant@3

; 2699 :               { for ( i = 0 ; i < q_info->vcount ; i++ )

	mov	edx, DWORD PTR [esi+1340]
	lea	edx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv3376[ebp], edx
	mov	edx, DWORD PTR _jj$[ebp]
	npad	1
$LL517@calc_quant@3:

; 2705 :                             tmp[j]=q_info->hess[i][ii][j][jj];

	mov	ebx, DWORD PTR tv3376[ebp]
	mov	ebx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR [ebx+eax*4]
	fld	QWORD PTR [ebx+edx*8]
	inc	eax
	fstp	QWORD PTR _tmp$90735[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LL517@calc_quant@3

; 2703 :                     { REAL tmp[MAXCOORD];
; 2704 :                       for ( j = 0 ; j < SDIM ; j++ ) 

	mov	ebx, DWORD PTR _i$[ebp]
$LN147@calc_quant@3:

; 2706 :                       (*sym_form_pullback)(q_info->x[i],grad,tmp,q_info->wraps[i]);

	mov	eax, DWORD PTR [esi+ebx*4+816]
	push	eax
	mov	eax, DWORD PTR [esi+ebx*4+416]
	lea	ecx, DWORD PTR _tmp$90735[ebp]
	push	ecx
	lea	edx, DWORD PTR _grad$90716[ebp]
	push	edx
	push	eax
	call	DWORD PTR _sym_form_pullback

; 2707 :                       for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _jj$[ebp]
	add	esp, 16					; 00000010H
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN151@calc_quant@3
$LL146@calc_quant@3:

; 2708 :                         q_info->hess[i][ii][j][jj] = grad[j];

	mov	ecx, DWORD PTR [esi+1340]
	fld	QWORD PTR _grad$90716[ebp+eax*8]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _web+616
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL146@calc_quant@3
$LN151@calc_quant@3:

; 2702 :                     for ( jj = 0 ; jj < SDIM ; jj++ )

	inc	edx
	mov	DWORD PTR _jj$[ebp], edx
	cmp	edx, ecx
	jl	$LL152@calc_quant@3
$LN150@calc_quant@3:

; 2709 :                     }
; 2710 :                   if ( q_info->wraps[ii] )

	cmp	DWORD PTR [esi+edi*4+816], 0
	je	$LN155@calc_quant@3

; 2711 :                     for ( j = 0 ; j < SDIM ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	test	ecx, ecx
	jle	SHORT $LN155@calc_quant@3
	npad	1
$LL142@calc_quant@3:

; 2712 :                     { (*sym_form_pullback)(q_info->x[ii],grad,
; 2713 :                            q_info->hess[i][ii][j],q_info->wraps[ii]);

	mov	eax, DWORD PTR [esi+1340]
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	edx, DWORD PTR [esi+edi*4+816]
	mov	eax, DWORD PTR _j$[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [esi+edi*4+416]
	push	ecx
	lea	edx, DWORD PTR _grad$90716[ebp]
	push	edx
	push	eax
	call	DWORD PTR _sym_form_pullback

; 2714 :                       for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _j$[ebp]
	add	esp, 16					; 00000010H
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN141@calc_quant@3
	npad	11
$LL139@calc_quant@3:

; 2715 :                          q_info->hess[i][ii][j][jj] = grad[jj];

	mov	ecx, DWORD PTR [esi+1340]
	fld	QWORD PTR _grad$90716[ebp+eax*8]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [ecx+edx*4]
	fstp	QWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR _web+616
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL139@calc_quant@3
$LN141@calc_quant@3:

; 2711 :                     for ( j = 0 ; j < SDIM ; j++ )

	inc	edx
	mov	DWORD PTR _j$[ebp], edx
	cmp	edx, ecx
	jl	SHORT $LL142@calc_quant@3
$LN155@calc_quant@3:

; 2700 :                 for ( ii = 0 ; ii < q_info->vcount ; ii++ )

	inc	edi
	cmp	edi, DWORD PTR [esi+12]
	jl	$LN156@calc_quant@3
	fld	QWORD PTR tv3246[ebp]
$LN158@calc_quant@3:

; 2699 :               { for ( i = 0 ; i < q_info->vcount ; i++ )

	inc	ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, DWORD PTR [esi+12]
	jl	$LN159@calc_quant@3
	mov	edx, DWORD PTR _mi$[ebp]
$LN157@calc_quant@3:

; 2716 :                     }
; 2717 :                  }
; 2718 :                }
; 2719 :              }
; 2720 : 
; 2721 :                 
; 2722 :             if ( mi->flags & Q_COMPOUND ) 

	test	DWORD PTR [edx+140], 256		; 00000100H
	je	$LN696@calc_quant@3

; 2723 :             { mi->vlist = q_info->v; /* for eval_sec */

	lea	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+2920], eax

; 2724 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	mov	ebx, DWORD PTR _web+616
	xor	ecx, ecx
	cmp	DWORD PTR [esi+12], ecx
	jle	SHORT $LN133@calc_quant@3
$LN135@calc_quant@3:

; 2725 :                  for ( m = 0 ; m < SDIM ; m++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN134@calc_quant@3
$LN132@calc_quant@3:

; 2726 :                     mi->grad[i][m] = sign*mi->modulus*q_info->grad[i][m];

	mov	edi, DWORD PTR [esi+1336]
	fld	ST(0)
	fmul	QWORD PTR [edx+304]
	mov	edi, DWORD PTR [edi+ecx*4]
	inc	eax
	fmul	QWORD PTR [edi+eax*8-8]
	mov	edi, DWORD PTR [edx+2896]
	mov	edi, DWORD PTR [edi+ecx*4]
	fstp	QWORD PTR [edi+eax*8-8]
	mov	ebx, DWORD PTR _web+616
	cmp	eax, ebx
	jl	SHORT $LN132@calc_quant@3
$LN134@calc_quant@3:

; 2724 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR [esi+12]
	jl	SHORT $LN135@calc_quant@3
$LN133@calc_quant@3:

; 2727 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	xor	edi, edi
	mov	DWORD PTR _i$[ebp], edi
	cmp	DWORD PTR [esi+12], edi
	jle	SHORT $LN715@calc_quant@3
$LN129@calc_quant@3:

; 2728 :                 for ( j = 0 ; j < q_info->vcount ; j++ )

	xor	edx, edx
	cmp	DWORD PTR [esi+12], edx
	jle	SHORT $LN128@calc_quant@3
$LN126@calc_quant@3:

; 2729 :                  for ( m = 0 ; m < SDIM ; m++ )

	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN125@calc_quant@3
$LN123@calc_quant@3:

; 2730 :                   for ( n = 0 ; n < SDIM ; n++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN122@calc_quant@3
$LN120@calc_quant@3:

; 2731 :                     mi->hess[i][j][m][n] = sign*mi->modulus*q_info->hess[i][j][m][n];

	mov	ebx, DWORD PTR [esi+1340]
	fld	ST(0)
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	edi, DWORD PTR [edi+edx*4]
	mov	ebx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _mi$[ebp]
	fmul	QWORD PTR [edi+304]
	inc	eax
	fmul	QWORD PTR [ebx+eax*8-8]
	mov	ebx, DWORD PTR [edi+2900]
	mov	edi, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	fstp	QWORD PTR [ebx+eax*8-8]
	mov	ebx, DWORD PTR _web+616
	cmp	eax, ebx
	jl	SHORT $LN120@calc_quant@3
$LN122@calc_quant@3:

; 2729 :                  for ( m = 0 ; m < SDIM ; m++ )

	inc	ecx
	cmp	ecx, ebx
	jl	SHORT $LN123@calc_quant@3
$LN125@calc_quant@3:

; 2728 :                 for ( j = 0 ; j < q_info->vcount ; j++ )

	inc	edx
	cmp	edx, DWORD PTR [esi+12]
	jl	SHORT $LN126@calc_quant@3
$LN128@calc_quant@3:

; 2727 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	inc	edi
	mov	DWORD PTR _i$[ebp], edi
	cmp	edi, DWORD PTR [esi+12]
	jl	SHORT $LN129@calc_quant@3
$LN715@calc_quant@3:

; 2732 :               mi->stamp = comp_quant_stamp;

	mov	ecx, DWORD PTR _mi$[ebp]
	fstp	ST(0)
	fild	DWORD PTR _comp_quant_stamp
	fstp	QWORD PTR [ecx+2888]
$LN507@calc_quant@3:

; 2733 :             }
; 2734 :            else

	mov	ecx, DWORD PTR _web+616
$LN202@calc_quant@3:

; 2635 :         for ( k = 0 ; k < inum ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _inum$[ebp]
	jl	$LL549@calc_quant@3
$LN205@calc_quant@3:

; 2634 :       for ( flag = 0 ; flag < 2 ; flag++,inum = e_ptr->method_count,k=0 )

	mov	eax, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _e_ptr$[ebp]
	movzx	edx, WORD PTR [edx+24]
	inc	eax
	mov	DWORD PTR _flag$[ebp], eax
	mov	DWORD PTR _inum$[ebp], edx
	cmp	eax, 2
	jl	$LL206@calc_quant@3

; 2785 :                      }
; 2786 :                    }
; 2787 :                  } /* end second derivatives */
; 2788 :                } /* end non-compound */
; 2789 :                METHOD_PROFILING_END(mi,hess);
; 2790 :             } /* end if */ 
; 2791 :         } /* end method instance loop */
; 2792 : 
; 2793 :         /* Here we take care of compound quantities */
; 2794 :         for ( k = compound_quant_list_head ; k >= 0 ; k = q->next_compound )

	mov	edx, DWORD PTR _compound_quant_list_head
	mov	DWORD PTR _k$[ebp], edx
	test	edx, edx
	js	$LN214@calc_quant@3
	npad	6
$LL78@calc_quant@3:

; 2795 :         { q = GEN_QUANT(k);

	imul	edx, 368				; 00000170H
	add	edx, DWORD PTR _gen_quant_list

; 2796 :           if ( (q->flags & mode) && (q->flags & Q_COMPOUND) && (q->modulus != 0.0) ) 

	mov	eax, DWORD PTR [edx+136]
	mov	DWORD PTR _q$[ebp], edx
	test	al, 11					; 0000000bH
	je	$LN77@calc_quant@3
	test	eax, 256				; 00000100H
	je	$LN77@calc_quant@3
	fld	QWORD PTR [edx+176]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN77@calc_quant@3

; 2797 :           {
; 2798 :             for ( i = 0 ; i < q_info->vcount ; i++ )

	cmp	DWORD PTR [esi+12], 0
	mov	DWORD PTR _i$[ebp], 0
	jle	$LN72@calc_quant@3
	lea	eax, DWORD PTR [esi+16]
	mov	DWORD PTR tv6280[ebp], eax
	npad	3
$LL74@calc_quant@3:

; 2799 :             { REAL dummy,partials[MAXCOORD];
; 2800 :               REAL grad[MAXCOORD];
; 2801 :               comp_quant_vertex = i; /* so eval_all knows */ 

	mov	edx, DWORD PTR _i$[ebp]

; 2802 :               comp_quant_type = type;

	mov	eax, DWORD PTR _type$[ebp]

; 2803 :               eval_all(&q->expr,NULL,SDIM,&dummy,partials,NULLID);

	mov	ebx, DWORD PTR _q$[ebp]
	push	0
	mov	DWORD PTR _comp_quant_vertex, edx
	mov	DWORD PTR _comp_quant_type, eax
	lea	edx, DWORD PTR _partials$90833[ebp]
	push	edx
	lea	eax, DWORD PTR _dummy$90832[ebp]
	push	eax
	push	ecx
	lea	eax, DWORD PTR [ebx+256]
	push	0
	push	eax
	call	_eval_all

; 2804 :               va = get_vertex_vhead(q_info->v[i]);

	mov	eax, DWORD PTR _vhead_attr
	mov	ecx, DWORD PTR tv6280[ebp]
	imul	eax, 240				; 000000f0H
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+12
	add	eax, DWORD PTR _web+104
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	edi, DWORD PTR [edx+eax]

; 2805 :               for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	shl	edi, 5
	add	edi, DWORD PTR _vhead
	add	esp, 24					; 00000018H
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN69@calc_quant@3
	npad	10
$LL71@calc_quant@3:

; 2806 :                    grad[j] = q->modulus*partials[j];

	fld	QWORD PTR _partials$90833[ebp+eax*8]
	inc	eax
	fmul	QWORD PTR [ebx+176]
	fstp	QWORD PTR _grad$90834[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LL71@calc_quant@3
$LN69@calc_quant@3:

; 2807 :               fill_grad(S,va,grad,rhs);

	mov	ecx, DWORD PTR _rhs$GSCopy$[ebp]
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _grad$90834[ebp]
	push	edx
	push	edi
	push	eax
	call	_fill_grad
	add	esp, 16					; 00000010H

; 2808 : 
; 2809 :               /* fixed quantity gradients for left side */
; 2810 :               if ( (q->flags & (Q_FIXED|Q_CONSERVED)) && hess_mode )

	test	BYTE PTR [ebx+136], 10			; 0000000aH
	je	$LN73@calc_quant@3
	cmp	DWORD PTR _hess_mode$[ebp], 0
	je	$LN73@calc_quant@3

; 2811 :               { /* find entry */
; 2812 :                 int currentrow;
; 2813 :                 if ( va->proj )

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	$LN67@calc_quant@3

; 2814 :                 { vec_mat_mul(grad,va->proj,g,SDIM, va->freedom);

	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR _web+616
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _g$[ebp]
	push	ecx
	push	eax
	lea	edx, DWORD PTR _grad$90834[ebp]
	push	edx
	call	_vec_mat_mul

; 2815 :                   ggg = g;

	lea	eax, DWORD PTR _g$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ggg$[ebp], eax
	jmp	$LN66@calc_quant@3
$LN696@calc_quant@3:

; 2735 :            {
; 2736 :              for ( i = 0 ; i < q_info->vcount ; i++ )

	xor	edi, edi
	fstp	ST(0)
	cmp	DWORD PTR [esi+12], edi
	jle	$LN114@calc_quant@3
	npad	3
$LL116@calc_quant@3:

; 2737 :              { REAL grad[MAXCOORD];
; 2738 :                va = get_vertex_vhead(q_info->v[i]);

	mov	eax, DWORD PTR _vhead_attr
	mov	edx, DWORD PTR [esi+edi*4+16]
	imul	eax, 240				; 000000f0H
	mov	ebx, DWORD PTR _web+12
	add	eax, DWORD PTR _web+104
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	edx, DWORD PTR [edx+eax]
	shl	edx, 5
	add	edx, DWORD PTR _vhead

; 2739 :                for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN537@calc_quant@3

; 2735 :            {
; 2736 :              for ( i = 0 ; i < q_info->vcount ; i++ )

	mov	ebx, DWORD PTR [esi+1336]
	fld	QWORD PTR _coeff$[ebp]
	lea	ebx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR tv3363[ebp], ebx
$LN536@calc_quant@3:

; 2740 :                     grad[j] = coeff*q_info->grad[i][j];

	mov	ebx, DWORD PTR tv3363[ebp]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _grad$90772[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN536@calc_quant@3

; 2739 :                for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
$LN537@calc_quant@3:

; 2741 :                fill_grad(S,va,grad,rhs);

	mov	ecx, DWORD PTR _rhs$GSCopy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	lea	eax, DWORD PTR _grad$90772[ebp]
	push	eax
	push	edx
	push	ecx
	call	_fill_grad
	mov	ecx, DWORD PTR _web+616
	inc	edi
	add	esp, 16					; 00000010H
	cmp	edi, DWORD PTR [esi+12]
	jl	$LL116@calc_quant@3
$LN114@calc_quant@3:

; 2742 :              }
; 2743 : 
; 2744 :              /* second derivatives */
; 2745 :              if ( hess_mode && (mode & (Q_FIXED|Q_ENERGY|Q_CONSERVED))  )

	cmp	DWORD PTR _hess_mode$[ebp], 0
	je	$LN202@calc_quant@3

; 2746 :                for ( i = 0 ; i < q_info->vcount ; i++ )

	xor	ebx, ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	DWORD PTR [esi+12], ebx
	jle	$LN202@calc_quant@3
	npad	13
$LL109@calc_quant@3:

; 2747 :                  { va = get_vertex_vhead(q_info->v[i]);

	mov	eax, DWORD PTR _vhead_attr
	mov	edx, DWORD PTR [esi+ebx*4+16]
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	edi, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edi+64]
	mov	eax, DWORD PTR [edx+eax]
	shl	eax, 5
	add	eax, DWORD PTR _vhead

; 2748 :                    if ( va->freedom == 0 ) continue;

	cmp	DWORD PTR [eax+8], 0
	mov	DWORD PTR _va$[ebp], eax
	je	$LN108@calc_quant@3

; 2749 : 
; 2750 :                    for ( j = i ; j < q_info->vcount ; j++ )

	mov	edi, ebx
	cmp	ebx, DWORD PTR [esi+12]
	jge	$LN525@calc_quant@3
	npad	11
$LL518@calc_quant@3:

; 2751 :                    { vb = get_vertex_vhead(q_info->v[j]);

	mov	eax, DWORD PTR _vhead_attr
	mov	edx, DWORD PTR [esi+edi*4+16]
	imul	eax, 240				; 000000f0H
	mov	ebx, DWORD PTR _web+12
	add	eax, DWORD PTR _web+104
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	edx, DWORD PTR [edx+eax]

; 2752 :                      if ( vb->freedom == 0 ) continue;

	mov	eax, DWORD PTR _vhead

; 2753 :                      for ( n = 0 ; n < SDIM ; n++ )

	mov	ebx, DWORD PTR _i$[ebp]
	shl	edx, 5
	cmp	DWORD PTR [edx+eax+8], 0
	je	$LN104@calc_quant@3
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN99@calc_quant@3
	fld	QWORD PTR _coeff$[ebp]
$LN101@calc_quant@3:

; 2754 :                        for ( m = 0 ; m < SDIM ; m++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN100@calc_quant@3
$LN98@calc_quant@3:

; 2753 :                      for ( n = 0 ; n < SDIM ; n++ )

	mov	ecx, DWORD PTR [esi+1340]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [ecx+eax*4]

; 2755 :                          q_info->hess[i][j][m][n] *= coeff;

	fld	QWORD PTR [ecx+edx*8]
	lea	ecx, DWORD PTR [ecx+edx*8]
	fmul	ST(0), ST(1)
	inc	eax
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN98@calc_quant@3
$LN100@calc_quant@3:

; 2753 :                      for ( n = 0 ; n < SDIM ; n++ )

	inc	edx
	cmp	edx, ecx
	jl	SHORT $LN101@calc_quant@3
	fstp	ST(0)
$LN99@calc_quant@3:

; 2756 :                      fill_mixed_entry(S,q_info->v[i],q_info->v[j],q_info->hess[i][j]);

	mov	edx, DWORD PTR [esi+1340]
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	edx, DWORD PTR [esi+edi*4+16]
	mov	eax, DWORD PTR [esi+ebx*4+16]
	push	ecx
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_fill_mixed_entry
	add	esp, 16					; 00000010H

; 2757 : 
; 2758 :                      if ( (i != j) && (q_info->v[i] == q_info->v[j]) ) /* also transpose */

	cmp	ebx, edi
	je	$LN505@calc_quant@3
	mov	edx, DWORD PTR [esi+ebx*4+16]
	cmp	edx, DWORD PTR [esi+edi*4+16]
	jne	$LN505@calc_quant@3

; 2759 :                      { MAT2D(transpose,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _transposexJ$90805[ebp]
	push	eax
	lea	ecx, DWORD PTR _transposeqXvS$90804[ebp]
	push	ecx
	call	_mat2d_setup
	mov	DWORD PTR _transpose$90806[ebp], eax

; 2760 :                        for ( n = 0 ; n < SDIM ; n++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN92@calc_quant@3
	npad	5
$LL94@calc_quant@3:

; 2761 :                          for ( m = 0 ; m < SDIM ; m++ )

	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN93@calc_quant@3
	npad	10
$LL523@calc_quant@3:

; 2762 :                            transpose[m][n] = q_info->hess[i][j][n][m];

	mov	eax, DWORD PTR [esi+1340]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	ebx, DWORD PTR _transpose$90806[ebp]
	fld	QWORD PTR [eax+ecx*8]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	fstp	QWORD PTR [ebx+edx*8]
	mov	eax, DWORD PTR _web+616
	mov	ebx, DWORD PTR _i$[ebp]
	inc	ecx
	cmp	ecx, eax
	jl	SHORT $LL523@calc_quant@3
$LN93@calc_quant@3:

; 2760 :                        for ( n = 0 ; n < SDIM ; n++ )

	inc	edx
	cmp	edx, eax
	jl	SHORT $LL94@calc_quant@3
$LN92@calc_quant@3:

; 2763 :                        fill_mixed_entry(S,q_info->v[i],q_info->v[j],transpose);

	mov	ecx, DWORD PTR _transpose$90806[ebp]
	mov	edx, DWORD PTR [esi+edi*4+16]
	mov	eax, DWORD PTR [esi+ebx*4+16]
	push	ecx
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_fill_mixed_entry
	add	esp, 16					; 00000010H
$LN505@calc_quant@3:
	mov	ecx, DWORD PTR _web+616
$LN104@calc_quant@3:

; 2749 : 
; 2750 :                    for ( j = i ; j < q_info->vcount ; j++ )

	inc	edi
	cmp	edi, DWORD PTR [esi+12]
	jl	$LL518@calc_quant@3
$LN525@calc_quant@3:

; 2764 :                      }
; 2765 :                    } /* end inner vertex loop */
; 2766 : 
; 2767 :                    /* fixed quantity gradients for left side */
; 2768 :                    for ( j = 0 ; j < MMAXQUANTS ; j++ )

	mov	eax, DWORD PTR _mi$[ebp]
	add	eax, 152				; 00000098H
	mov	DWORD PTR tv5934[ebp], eax
	mov	DWORD PTR tv1912[ebp], 8
	npad	2
$LL527@calc_quant@3:

; 2769 :                    { if ( mi->quants[j] < 0 )

	mov	edx, DWORD PTR tv5934[ebp]
	mov	eax, DWORD PTR [edx]
	test	eax, eax
	js	$LN87@calc_quant@3

; 2770 :                        continue;
; 2771 :                      q = GEN_QUANT(mi->quants[j]);

	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list
	mov	edi, eax

; 2772 :                      if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	test	BYTE PTR [edi+136], 10			; 0000000aH
	je	$LN87@calc_quant@3

; 2773 :                      { /* find entry */
; 2774 :                        int currentrow;
; 2775 :                        if ( va->proj )

	mov	eax, DWORD PTR _va$[ebp]
	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	SHORT $LN83@calc_quant@3

; 2776 :                        { vec_mat_mul(q_info->grad[i],va->proj,g,SDIM,
; 2777 :                                     va->freedom);

	mov	edx, DWORD PTR _va$[ebp]
	mov	edx, DWORD PTR [edx+8]
	push	edx
	mov	edx, DWORD PTR [esi+1336]
	push	ecx
	lea	ecx, DWORD PTR _g$[ebp]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [edx+ebx*4]
	push	eax
	call	_vec_mat_mul

; 2778 :                          ggg = g;

	lea	ecx, DWORD PTR _g$[ebp]
	mov	DWORD PTR _ggg$[ebp], ecx
	mov	ecx, DWORD PTR _web+616
	add	esp, 20					; 00000014H
	jmp	SHORT $LN82@calc_quant@3
$LN83@calc_quant@3:

; 2779 :                        }
; 2780 :                        else ggg = q_info->grad[i];

	mov	edx, DWORD PTR [esi+1336]
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR _ggg$[ebp], eax
$LN82@calc_quant@3:

; 2781 :                        currentrow = S->quanrowstart + mi->quants[j];

	mov	edx, DWORD PTR _S$GSCopy$[ebp]

; 2782 :                        ccoeff = sign*q->modulus*mi->modulus;

	fld	QWORD PTR [edi+176]
	mov	eax, DWORD PTR [edx+24]
	fmul	QWORD PTR tv3246[ebp]
	mov	edx, DWORD PTR tv5934[ebp]
	add	eax, DWORD PTR [edx]

; 2783 :                        for ( m = 0 ; m < va->freedom ; m++ )

	mov	edx, DWORD PTR _va$[ebp]
	mov	DWORD PTR _currentrow$90819[ebp], eax
	mov	eax, DWORD PTR _mi$[ebp]
	fmul	QWORD PTR [eax+304]
	xor	edi, edi
	fstp	QWORD PTR _ccoeff$[ebp]
	cmp	DWORD PTR [edx+8], edi
	jle	SHORT $LN87@calc_quant@3
	npad	14
$LL516@calc_quant@3:

; 2784 :                          sp_hash_search(S,va->rownum+m,currentrow,ccoeff*ggg[m]);

	mov	eax, DWORD PTR _ggg$[ebp]
	fld	QWORD PTR [eax+edi*8]
	mov	edx, DWORD PTR _va$[ebp]
	fmul	QWORD PTR _ccoeff$[ebp]
	mov	ecx, DWORD PTR _currentrow$90819[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	add	eax, edi
	push	eax
	push	ecx
	call	_sp_hash_search
	mov	edx, DWORD PTR _va$[ebp]
	inc	edi
	add	esp, 20					; 00000014H
	cmp	edi, DWORD PTR [edx+8]
	jl	SHORT $LL516@calc_quant@3

; 2783 :                        for ( m = 0 ; m < va->freedom ; m++ )

	mov	ecx, DWORD PTR _web+616
$LN87@calc_quant@3:

; 2764 :                      }
; 2765 :                    } /* end inner vertex loop */
; 2766 : 
; 2767 :                    /* fixed quantity gradients for left side */
; 2768 :                    for ( j = 0 ; j < MMAXQUANTS ; j++ )

	add	DWORD PTR tv5934[ebp], 4
	dec	DWORD PTR tv1912[ebp]
	jne	$LL527@calc_quant@3
$LN108@calc_quant@3:

; 2746 :                for ( i = 0 ; i < q_info->vcount ; i++ )

	inc	ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, DWORD PTR [esi+12]
	jl	$LL109@calc_quant@3
	jmp	$LN202@calc_quant@3
$LN67@calc_quant@3:

; 2816 :                 }
; 2817 :                 else ggg = grad;

	lea	ecx, DWORD PTR _grad$90834[ebp]
	mov	DWORD PTR _ggg$[ebp], ecx
$LN66@calc_quant@3:

; 2818 :                 currentrow = S->quanrowstart + k;

	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, DWORD PTR _k$[ebp]

; 2819 :                 for ( m = 0 ; m < va->freedom ; m++ )

	xor	ebx, ebx
	mov	DWORD PTR _currentrow$90844[ebp], eax
	cmp	DWORD PTR [edi+8], ebx
	jle	SHORT $LN73@calc_quant@3
	npad	10
$LL65@calc_quant@3:

; 2820 :                 { sp_hash_search(S,va->rownum+m,currentrow,q->modulus*ggg[m]);

	mov	eax, DWORD PTR _ggg$[ebp]
	fld	QWORD PTR [eax+ebx*8]
	mov	ecx, DWORD PTR _q$[ebp]
	fmul	QWORD PTR [ecx+176]
	mov	edx, DWORD PTR _currentrow$90844[ebp]
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	add	eax, ebx
	push	eax
	push	ecx
	call	_sp_hash_search
	inc	ebx
	add	esp, 20					; 00000014H
	cmp	ebx, DWORD PTR [edi+8]
	jl	SHORT $LL65@calc_quant@3
$LN73@calc_quant@3:

; 2797 :           {
; 2798 :             for ( i = 0 ; i < q_info->vcount ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv6280[ebp], 4
	mov	ecx, DWORD PTR _web+616
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [esi+12]
	jl	$LL74@calc_quant@3
$LN72@calc_quant@3:

; 2821 :                 }
; 2822 :               }
; 2823 :             }
; 2824 : 
; 2825 :             /* second derivatives */
; 2826 :             compound_hess_flag = CH_HESS;
; 2827 :             if ( hess_mode )

	cmp	DWORD PTR _hess_mode$[ebp], 0
	mov	DWORD PTR _compound_hess_flag, 2
	je	$LN59@calc_quant@3

; 2828 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	xor	edi, edi
	cmp	DWORD PTR [esi+12], edi
	jle	$LN59@calc_quant@3
	npad	1
$LL528@calc_quant@3:

; 2829 :               { REAL dummy[MAXCOORD];
; 2830 :                 REAL partials[MAXCOORD];
; 2831 :                 va = get_vertex_vhead(q_info->v[i]);

	mov	eax, DWORD PTR _vhead_attr
	mov	edx, DWORD PTR [esi+edi*4+16]
	imul	eax, 240				; 000000f0H
	mov	ebx, DWORD PTR _web+12
	add	eax, DWORD PTR _web+104
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	edx, DWORD PTR [edx+eax]

; 2832 :                 if ( va->freedom == 0 ) continue;

	mov	eax, DWORD PTR _vhead
	shl	edx, 5
	cmp	DWORD PTR [edx+eax+8], 0
	je	$LN60@calc_quant@3

; 2833 : 
; 2834 :                 for ( j = i ; j < q_info->vcount ; j++ )

	mov	DWORD PTR _j$[ebp], edi
	cmp	edi, DWORD PTR [esi+12]
	jge	$LN60@calc_quant@3
	lea	eax, DWORD PTR [esi+edi*4+16]
	mov	DWORD PTR tv6537[ebp], eax
	mov	eax, -16				; fffffff0H
	sub	eax, esi
	mov	DWORD PTR tv6567[ebp], eax
	npad	6
$LL551@calc_quant@3:

; 2835 :                 { vb = get_vertex_vhead(q_info->v[j]);

	mov	edx, DWORD PTR _vhead_attr
	mov	eax, DWORD PTR tv6537[ebp]
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax]
	mov	ebx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ebx+64]
	mov	ebx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	edx, DWORD PTR [edx+eax]

; 2836 :                   if ( vb->freedom == 0 ) continue;

	mov	eax, DWORD PTR _vhead
	shl	edx, 5
	cmp	DWORD PTR [edx+eax+8], 0
	je	$LN56@calc_quant@3

; 2837 :                   comp_quant_vertexi = i; /* so eval_all knows */ 
; 2838 :                   comp_quant_vertexj = j; /* so eval_all knows */ 

	mov	edx, DWORD PTR _j$[ebp]

; 2839 :                   eval_second(&q->expr,NULL,SDIM,dummy,partials,seconds,NULLID);

	mov	eax, DWORD PTR _seconds$[ebp]
	push	0
	push	eax
	mov	DWORD PTR _comp_quant_vertexj, edx
	lea	edx, DWORD PTR _partials$90855[ebp]
	push	edx
	lea	eax, DWORD PTR _dummy$90854[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _q$[ebp]
	add	ecx, 256				; 00000100H
	push	0
	push	ecx
	mov	DWORD PTR _comp_quant_vertexi, edi
	call	_eval_second

; 2840 :                   for ( n = 0 ; n < SDIM ; n++ )

	mov	edx, DWORD PTR _web+616
	add	esp, 28					; 0000001cH
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN530@calc_quant@3
$LL53@calc_quant@3:

; 2841 :                     for ( m = 0 ; m < SDIM ; m++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN52@calc_quant@3
	npad	8
$LL529@calc_quant@3:

; 2842 :                       q_info->hess[i][j][m][n] = q->modulus*seconds[m][n];

	mov	edx, DWORD PTR _seconds$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	fld	QWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _q$[ebp]
	fmul	QWORD PTR [edx+176]
	mov	edx, DWORD PTR [esi+1340]
	mov	edx, DWORD PTR [edx+edi*4]
	add	edx, DWORD PTR tv6567[ebp]
	mov	ebx, DWORD PTR tv6537[ebp]
	mov	edx, DWORD PTR [edx+ebx]
	mov	edx, DWORD PTR [edx+eax*4]
	fstp	QWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _web+616
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL529@calc_quant@3
$LN52@calc_quant@3:

; 2840 :                   for ( n = 0 ; n < SDIM ; n++ )

	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL53@calc_quant@3
$LN530@calc_quant@3:

; 2843 :                   fill_mixed_entry(S,q_info->v[i],q_info->v[j],q_info->hess[i][j]);

	mov	ebx, DWORD PTR tv6537[ebp]
	mov	ecx, DWORD PTR [esi+1340]
	mov	eax, DWORD PTR tv6567[ebp]
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [ebx]
	add	eax, ebx
	mov	DWORD PTR tv6568[ebp], eax
	mov	eax, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [esi+edi*4+16]
	push	eax
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	push	ecx
	push	edx
	push	eax
	call	_fill_mixed_entry
	add	esp, 16					; 00000010H

; 2844 : 
; 2845 :                   if ( (i != j) && (q_info->v[i] == q_info->v[j]) ) /* also transpose */

	cmp	edi, DWORD PTR _j$[ebp]
	je	$LN509@calc_quant@3
	mov	ecx, DWORD PTR [esi+edi*4+16]
	cmp	ecx, DWORD PTR [ebx]
	jne	$LN509@calc_quant@3

; 2846 :                   { MAT2D(transpose,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	edx, DWORD PTR _transposexJ$90878[ebp]
	push	edx
	lea	eax, DWORD PTR _transposeqXvS$90877[ebp]
	push	eax
	call	_mat2d_setup
	mov	DWORD PTR _transpose$90879[ebp], eax

; 2847 :                     for ( n = 0 ; n < SDIM ; n++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN44@calc_quant@3
	npad	2
$LL46@calc_quant@3:

; 2848 :                       for ( m = 0 ; m < SDIM ; m++ )

	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN45@calc_quant@3
	npad	10
$LL531@calc_quant@3:

; 2849 :                         transpose[m][n] = q_info->hess[i][j][n][m];

	mov	eax, DWORD PTR [esi+1340]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	ebx, DWORD PTR tv6568[ebp]
	mov	eax, DWORD PTR [eax+ebx]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	ebx, DWORD PTR _transpose$90879[ebp]
	fld	QWORD PTR [eax+ecx*8]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	fstp	QWORD PTR [ebx+edx*8]
	mov	eax, DWORD PTR _web+616
	inc	ecx
	cmp	ecx, eax
	jl	SHORT $LL531@calc_quant@3
$LN45@calc_quant@3:

; 2847 :                     for ( n = 0 ; n < SDIM ; n++ )

	inc	edx
	cmp	edx, eax
	jl	SHORT $LL46@calc_quant@3
	mov	ebx, DWORD PTR tv6537[ebp]
$LN44@calc_quant@3:

; 2850 :                     fill_mixed_entry(S,q_info->v[i],q_info->v[j],transpose);

	mov	ecx, DWORD PTR _transpose$90879[ebp]
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+edi*4+16]
	push	ecx
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_fill_mixed_entry
	add	esp, 16					; 00000010H
$LN509@calc_quant@3:
	mov	ecx, DWORD PTR _web+616
$LN56@calc_quant@3:

; 2833 : 
; 2834 :                 for ( j = i ; j < q_info->vcount ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	add	DWORD PTR tv6537[ebp], 4
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [esi+12]
	jl	$LL551@calc_quant@3
$LN60@calc_quant@3:

; 2828 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	inc	edi
	cmp	edi, DWORD PTR [esi+12]
	jl	$LL528@calc_quant@3
$LN59@calc_quant@3:

; 2851 :                   }
; 2852 :                 } /* end inner vertex loop */
; 2853 : 
; 2854 :               } /* end second derivatives */
; 2855 :               compound_hess_flag = 0;

	mov	edx, DWORD PTR _q$[ebp]
	mov	DWORD PTR _compound_hess_flag, 0
$LN77@calc_quant@3:

; 2785 :                      }
; 2786 :                    }
; 2787 :                  } /* end second derivatives */
; 2788 :                } /* end non-compound */
; 2789 :                METHOD_PROFILING_END(mi,hess);
; 2790 :             } /* end if */ 
; 2791 :         } /* end method instance loop */
; 2792 : 
; 2793 :         /* Here we take care of compound quantities */
; 2794 :         for ( k = compound_quant_list_head ; k >= 0 ; k = q->next_compound )

	mov	edx, DWORD PTR [edx+360]
	mov	DWORD PTR _k$[ebp], edx
	test	edx, edx
	jns	$LL78@calc_quant@3
$LN214@calc_quant@3:

; 2619 :     FOR_ALL_ELEMENTS(type,q_info->id)

	mov	eax, DWORD PTR [esi]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	test	eax, 268435456				; 10000000H
	jne	$LL215@calc_quant@3
$LN732@calc_quant@3:
	mov	ebx, DWORD PTR _type$[ebp]
$LN238@calc_quant@3:

; 2564 :         }
; 2565 :       }
; 2566 :     }
; 2567 : 
; 2568 :   for ( type = VERTEX ; type <= BODY ; type++ )

	inc	ebx
	mov	DWORD PTR _type$[ebp], ebx
	cmp	ebx, 3
	jle	$LL239@calc_quant@3

; 2856 :            }
; 2857 :          } /* end compound quantities */
; 2858 :       } /* end all element loop */
; 2859 :    }
; 2860 :   }  /* end single thread */
; 2861 :   
; 2862 :   /* free stuff */
; 2863 :   free_matrix4(q_info->hess);

	mov	ecx, DWORD PTR [esi+1340]
	push	ecx
	call	_free_matrix4

; 2864 :   free_matrix(p1);

	mov	edx, DWORD PTR _p1$[ebp]
	push	edx
	call	_free_matrix

; 2865 :   free_matrix(p2);

	mov	eax, DWORD PTR _p2$[ebp]
	push	eax
	call	_free_matrix

; 2866 : 
; 2867 :   if ( compound_quant_list_head >= 0 )

	xor	ebx, ebx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _compound_quant_list_head, ebx
	jl	SHORT $LN512@calc_quant@3

; 2868 :   for ( k = LOW_INST ; k < meth_inst_count ; k++ )

	mov	edi, 1
	cmp	DWORD PTR _web+5560, edi
	jle	SHORT $LN512@calc_quant@3
$LL39@calc_quant@3:

; 2869 :   { mi = METH_INSTANCE(k);

	mov	eax, edi
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list

; 2870 :     if ( mi->flags & Q_COMPOUND )

	test	DWORD PTR [esi+140], 256		; 00000100H
	je	SHORT $LN38@calc_quant@3

; 2871 :     { free_matrix(mi->grad); mi->grad = NULL;

	mov	ecx, DWORD PTR [esi+2896]
	push	ecx
	call	_free_matrix

; 2872 :       free_matrix4(mi->hess); mi->hess = NULL;

	mov	edx, DWORD PTR [esi+2900]
	push	edx
	mov	DWORD PTR [esi+2896], ebx
	call	_free_matrix4
	add	esp, 8
	mov	DWORD PTR [esi+2900], ebx
$LN38@calc_quant@3:

; 2868 :   for ( k = LOW_INST ; k < meth_inst_count ; k++ )

	inc	edi
	cmp	edi, DWORD PTR _web+5560
	jl	SHORT $LL39@calc_quant@3
$LN512@calc_quant@3:

; 2873 :     }
; 2874 :   }
; 2875 : 
; 2876 :   for ( k = LOW_INST ; k < meth_inst_count ; k++ )

	mov	esi, 1
	cmp	DWORD PTR _web+5560, esi
	jle	SHORT $LN547@calc_quant@3
$LL35@calc_quant@3:

; 2877 :   { mi = METH_INSTANCE(k);

	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2878 :     if ( mi->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax+140]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN34@calc_quant@3

; 2879 :     if ( mi->flags & Q_DOTHIS )

	test	cl, 16					; 00000010H
	je	SHORT $LN34@calc_quant@3

; 2880 :     {  mi->value = mi->modulus*mi->newvalue;

	fld	QWORD PTR [eax+328]
	fmul	QWORD PTR [eax+304]
	fstp	QWORD PTR [eax+312]

; 2881 :        mi->abstotal *= fabs(mi->modulus);

	fld	QWORD PTR [eax+304]
	fabs
	fmul	QWORD PTR [eax+336]
	fstp	QWORD PTR [eax+336]
$LN34@calc_quant@3:

; 2873 :     }
; 2874 :   }
; 2875 : 
; 2876 :   for ( k = LOW_INST ; k < meth_inst_count ; k++ )

	inc	esi
	cmp	esi, DWORD PTR _web+5560
	jl	SHORT $LL35@calc_quant@3
$LN547@calc_quant@3:

; 2882 :     }
; 2883 :   }
; 2884 : 
; 2885 :   /* combine methods to quantities */
; 2886 :   for (  k = 0 ; k < gen_quant_count ; k++ )

	mov	esi, DWORD PTR _gen_quant_list
	xor	edi, edi
	cmp	DWORD PTR _web+5528, ebx
	jle	SHORT $LN28@calc_quant@3
	xor	edx, edx
	npad	8
$LL30@calc_quant@3:

; 2887 :   { q = GEN_QUANT(k);
; 2888 :     if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [edx+esi+136]
	lea	eax, DWORD PTR [edx+esi]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN29@calc_quant@3

; 2889 :     if ( q->flags & mode ) 

	test	cl, 11					; 0000000bH
	je	SHORT $LN29@calc_quant@3

; 2890 :     { q->value = q->volconst;

	fld	QWORD PTR [eax+208]
	fstp	QWORD PTR [eax+152]

; 2891 :       q->abstotal = 0.0;

	fldz
	fstp	QWORD PTR [eax+168]

; 2892 :       q->timestamp = global_timestamp;

	mov	ecx, DWORD PTR _global_timestamp
	mov	DWORD PTR [eax+364], ecx
	mov	esi, DWORD PTR _gen_quant_list
$LN29@calc_quant@3:

; 2882 :     }
; 2883 :   }
; 2884 : 
; 2885 :   /* combine methods to quantities */
; 2886 :   for (  k = 0 ; k < gen_quant_count ; k++ )

	inc	edi
	add	edx, 368				; 00000170H
	cmp	edi, DWORD PTR _web+5528
	jl	SHORT $LL30@calc_quant@3
$LN28@calc_quant@3:

; 2893 :     }
; 2894 :   }
; 2895 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	edi, 1
	cmp	DWORD PTR _web+5560, edi
	jle	$LN23@calc_quant@3
	npad	3
$LL25@calc_quant@3:

; 2896 :     { mi = METH_INSTANCE(k);

	mov	eax, edi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2897 :       if ( mi->flags & Q_DELETED ) continue;

	test	DWORD PTR [eax+140], 524544		; 00080100H
	jne	$LN24@calc_quant@3

; 2898 :       if ( mi->flags & Q_COMPOUND ) continue;
; 2899 :       gm = basic_gen_methods + mi->gen_method;
; 2900 :       for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2901 :       { if ( mi->quants[j] < 0 ) 

	mov	ecx, DWORD PTR [eax+152]
	cmp	ecx, ebx
	jl	SHORT $LN19@calc_quant@3

; 2902 :           continue;
; 2903 :         q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, esi

; 2904 :         if ( q->flags & mode ) 

	test	BYTE PTR [ecx+136], 11			; 0000000bH
	je	SHORT $LN19@calc_quant@3

; 2905 :         { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [ecx+176]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 2906 :           q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [ecx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	esi, DWORD PTR _gen_quant_list
$LN19@calc_quant@3:

; 2898 :       if ( mi->flags & Q_COMPOUND ) continue;
; 2899 :       gm = basic_gen_methods + mi->gen_method;
; 2900 :       for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2901 :       { if ( mi->quants[j] < 0 ) 

	mov	ecx, DWORD PTR [eax+156]
	cmp	ecx, ebx
	jl	SHORT $LN482@calc_quant@3

; 2902 :           continue;
; 2903 :         q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, esi

; 2904 :         if ( q->flags & mode ) 

	test	BYTE PTR [ecx+136], 11			; 0000000bH
	je	SHORT $LN482@calc_quant@3

; 2905 :         { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [ecx+176]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 2906 :           q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [ecx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	esi, DWORD PTR _gen_quant_list
$LN482@calc_quant@3:

; 2898 :       if ( mi->flags & Q_COMPOUND ) continue;
; 2899 :       gm = basic_gen_methods + mi->gen_method;
; 2900 :       for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2901 :       { if ( mi->quants[j] < 0 ) 

	mov	ecx, DWORD PTR [eax+160]
	cmp	ecx, ebx
	jl	SHORT $LN484@calc_quant@3

; 2902 :           continue;
; 2903 :         q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, esi

; 2904 :         if ( q->flags & mode ) 

	test	BYTE PTR [ecx+136], 11			; 0000000bH
	je	SHORT $LN484@calc_quant@3

; 2905 :         { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [ecx+176]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 2906 :           q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [ecx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	esi, DWORD PTR _gen_quant_list
$LN484@calc_quant@3:

; 2898 :       if ( mi->flags & Q_COMPOUND ) continue;
; 2899 :       gm = basic_gen_methods + mi->gen_method;
; 2900 :       for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2901 :       { if ( mi->quants[j] < 0 ) 

	mov	ecx, DWORD PTR [eax+164]
	cmp	ecx, ebx
	jl	SHORT $LN486@calc_quant@3

; 2902 :           continue;
; 2903 :         q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, esi

; 2904 :         if ( q->flags & mode ) 

	test	BYTE PTR [ecx+136], 11			; 0000000bH
	je	SHORT $LN486@calc_quant@3

; 2905 :         { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [ecx+176]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 2906 :           q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [ecx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	esi, DWORD PTR _gen_quant_list
$LN486@calc_quant@3:

; 2898 :       if ( mi->flags & Q_COMPOUND ) continue;
; 2899 :       gm = basic_gen_methods + mi->gen_method;
; 2900 :       for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2901 :       { if ( mi->quants[j] < 0 ) 

	mov	ecx, DWORD PTR [eax+168]
	cmp	ecx, ebx
	jl	SHORT $LN488@calc_quant@3

; 2902 :           continue;
; 2903 :         q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, esi

; 2904 :         if ( q->flags & mode ) 

	test	BYTE PTR [ecx+136], 11			; 0000000bH
	je	SHORT $LN488@calc_quant@3

; 2905 :         { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [ecx+176]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 2906 :           q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [ecx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	esi, DWORD PTR _gen_quant_list
$LN488@calc_quant@3:

; 2898 :       if ( mi->flags & Q_COMPOUND ) continue;
; 2899 :       gm = basic_gen_methods + mi->gen_method;
; 2900 :       for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2901 :       { if ( mi->quants[j] < 0 ) 

	mov	ecx, DWORD PTR [eax+172]
	cmp	ecx, ebx
	jl	SHORT $LN490@calc_quant@3

; 2902 :           continue;
; 2903 :         q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, esi

; 2904 :         if ( q->flags & mode ) 

	test	BYTE PTR [ecx+136], 11			; 0000000bH
	je	SHORT $LN490@calc_quant@3

; 2905 :         { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [ecx+176]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 2906 :           q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [ecx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	esi, DWORD PTR _gen_quant_list
$LN490@calc_quant@3:

; 2898 :       if ( mi->flags & Q_COMPOUND ) continue;
; 2899 :       gm = basic_gen_methods + mi->gen_method;
; 2900 :       for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2901 :       { if ( mi->quants[j] < 0 ) 

	mov	ecx, DWORD PTR [eax+176]
	cmp	ecx, ebx
	jl	SHORT $LN492@calc_quant@3

; 2902 :           continue;
; 2903 :         q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, esi

; 2904 :         if ( q->flags & mode ) 

	test	BYTE PTR [ecx+136], 11			; 0000000bH
	je	SHORT $LN492@calc_quant@3

; 2905 :         { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [ecx+176]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 2906 :           q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [ecx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	esi, DWORD PTR _gen_quant_list
$LN492@calc_quant@3:

; 2898 :       if ( mi->flags & Q_COMPOUND ) continue;
; 2899 :       gm = basic_gen_methods + mi->gen_method;
; 2900 :       for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 2901 :       { if ( mi->quants[j] < 0 ) 

	mov	ecx, DWORD PTR [eax+180]
	cmp	ecx, ebx
	jl	SHORT $LN24@calc_quant@3

; 2902 :           continue;
; 2903 :         q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, esi

; 2904 :         if ( q->flags & mode ) 

	test	BYTE PTR [ecx+136], 11			; 0000000bH
	je	SHORT $LN24@calc_quant@3

; 2905 :         { q->value += q->modulus*mi->value;

	fld	QWORD PTR [eax+312]
	fmul	QWORD PTR [ecx+176]
	fadd	QWORD PTR [ecx+152]
	fstp	QWORD PTR [ecx+152]

; 2906 :           q->abstotal += fabs(q->modulus)*mi->abstotal;

	fld	QWORD PTR [ecx+176]
	fabs
	fmul	QWORD PTR [eax+336]
	fadd	QWORD PTR [ecx+168]
	fstp	QWORD PTR [ecx+168]
	mov	esi, DWORD PTR _gen_quant_list
$LN24@calc_quant@3:

; 2893 :     }
; 2894 :   }
; 2895 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	edi
	cmp	edi, DWORD PTR _web+5560
	jl	$LL25@calc_quant@3
$LN23@calc_quant@3:

; 2907 :         }
; 2908 :       }
; 2909 :     }
; 2910 :   for ( k = compound_quant_list_head ; k >= 0 ; k = q->next_compound )

	mov	eax, DWORD PTR _compound_quant_list_head
	cmp	eax, ebx
	jl	SHORT $LN13@calc_quant@3
$LL15@calc_quant@3:

; 2911 :   { q = GEN_QUANT(k);

	imul	eax, 368				; 00000170H
	lea	edi, DWORD PTR [esi+eax]

; 2912 :     if ( (q->flags & mode) && ( q->flags & Q_COMPOUND ) && ( q->modulus != 0) )

	mov	eax, DWORD PTR [edi+136]
	test	al, 11					; 0000000bH
	je	SHORT $LN14@calc_quant@3
	test	eax, 256				; 00000100H
	je	SHORT $LN14@calc_quant@3
	fld	QWORD PTR [edi+176]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN14@calc_quant@3

; 2913 :     {  q->value = q->modulus*eval(&q->expr,NULL,NULLID,NULL);

	push	ebx
	push	ebx
	lea	edx, DWORD PTR [edi+256]
	push	ebx
	push	edx
	call	_eval
	fmul	QWORD PTR [edi+176]
	add	esp, 16					; 00000010H
	fstp	QWORD PTR [edi+152]

; 2914 :        q->abstotal = 1.0;

	fld1
	fstp	QWORD PTR [edi+168]
	mov	esi, DWORD PTR _gen_quant_list
$LN14@calc_quant@3:

; 2907 :         }
; 2908 :       }
; 2909 :     }
; 2910 :   for ( k = compound_quant_list_head ; k >= 0 ; k = q->next_compound )

	mov	eax, DWORD PTR [edi+360]
	cmp	eax, ebx
	jge	SHORT $LL15@calc_quant@3
$LN13@calc_quant@3:

; 2915 :     }
; 2916 :   }
; 2917 : 
; 2918 :   if ( (mode & Q_FIXED) && web.torus_flag )

	cmp	DWORD PTR _web+860, ebx
	je	$LN558@calc_quant@3

; 2919 :   { /* munge fixed volumes modulo torus volume */
; 2920 :     for ( k = 0 ; k < gen_quant_count ; k++ )

	mov	DWORD PTR _k$[ebp], ebx
	cmp	DWORD PTR _web+5528, ebx
	jle	$LN558@calc_quant@3
	fld	QWORD PTR __real@3fe0000000000000
	xor	edi, edi
$LN10@calc_quant@3:

; 2921 :     { q = GEN_QUANT(k);
; 2922 :       if ( q->flags & Q_DELETED ) continue;

	mov	eax, DWORD PTR [edi+esi+136]
	test	eax, 524288				; 00080000H
	jne	SHORT $LN9@calc_quant@3

; 2923 :       if ( (q->flags & Q_FIXED) 
; 2924 :              && (q->flags & TORUS_MODULO_MUNGE) ) 

	test	al, 2
	je	SHORT $LN9@calc_quant@3
	test	eax, 262144				; 00040000H
	je	SHORT $LN9@calc_quant@3

; 2925 :           q->value -= q->modulus*web.torusv*
; 2926 :                     (int)(0.5+(q->value - q->target)/(q->modulus*web.torusv));

	fld	QWORD PTR [edi+esi+152]
	lea	ebx, DWORD PTR [edi+esi+152]
	fld	QWORD PTR [edi+esi+176]
	fmul	QWORD PTR _web+1600
	fld	ST(1)
	fsub	QWORD PTR [edi+esi+144]
	fdiv	ST(0), ST(1)
	fadd	ST(0), ST(3)
	call	__ftol2_sse
	mov	DWORD PTR tv6235[ebp], eax
	fild	DWORD PTR tv6235[ebp]
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ebx]
	mov	esi, DWORD PTR _gen_quant_list
	xor	ebx, ebx
$LN9@calc_quant@3:

; 2919 :   { /* munge fixed volumes modulo torus volume */
; 2920 :     for ( k = 0 ; k < gen_quant_count ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	add	edi, 368				; 00000170H
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _web+5528
	jl	SHORT $LN10@calc_quant@3
	fstp	ST(0)
$LN558@calc_quant@3:

; 2927 :     }
; 2928 :   }
; 2929 : 
; 2930 :   /* take care of any cleanup */
; 2931 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	esi, 1
	cmp	DWORD PTR _web+5560, esi
	jle	SHORT $LN3@calc_quant@3
$LL5@calc_quant@3:

; 2932 :   { mi = METH_INSTANCE(k); /* since some init may move things */

	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2933 :     if ( mi->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax+140]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN4@calc_quant@3

; 2934 :     gm = basic_gen_methods + mi->gen_method;

	mov	eax, DWORD PTR [eax+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	add	eax, OFFSET _basic_gen_methods

; 2935 :     if ( gm->cleanup && mi->flags & Q_DOTHIS ) gm->cleanup();

	mov	eax, DWORD PTR [eax+156]
	cmp	eax, ebx
	je	SHORT $LN4@calc_quant@3
	test	cl, 16					; 00000010H
	je	SHORT $LN4@calc_quant@3
	call	eax
$LN4@calc_quant@3:

; 2927 :     }
; 2928 :   }
; 2929 : 
; 2930 :   /* take care of any cleanup */
; 2931 :   for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	inc	esi
	cmp	esi, DWORD PTR _web+5560
	jl	SHORT $LL5@calc_quant@3
$LN3@calc_quant@3:

; 2936 :   }
; 2937 : 
; 2938 :   vgrad_end();

	call	_vgrad_end
$LN301@calc_quant@3:

; 2939 :  
; 2940 :   PROF_FINISH(calc_quant_hess);
; 2941 : } // end calc_quant_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_calc_quant_hess ENDP
_TEXT	ENDS
PUBLIC	_rhs$GSCopy$
PUBLIC	_type$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_m_calc_quant_hess
_BSS	SEGMENT
_m_quanrowstart DD 01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _m_calc_quant_hess
_TEXT	SEGMENT
tv1666 = -308						; size = 8
_p2$ = -300						; size = 4
_q_info$ = -296						; size = 4
_rhs$GSCopy$ = -292					; size = 4
_p1$ = -288						; size = 4
_global_needs$ = -284					; size = 4
_ccoeff$ = -280						; size = 8
tv3281 = -276						; size = 4
_meth_offset$ = -272					; size = 4
_end$ = -268						; size = 4
_needs$91045 = -264					; size = 4
_setup_flag$91044 = -260				; size = 4
_e_ptr$ = -256						; size = 4
_inum$ = -252						; size = 4
_nn$ = -248						; size = 4
_flag$ = -244						; size = 4
_k$91043 = -240						; size = 4
_mi$ = -236						; size = 4
_me$ = -232						; size = 4
tv3113 = -228						; size = 4
tv381 = -228						; size = 4
_type$GSCopy$ = -224					; size = 4
_coeff$ = -220						; size = 8
tv3251 = -212						; size = 4
tv2874 = -212						; size = 4
tv2617 = -212						; size = 4
tv1786 = -212						; size = 4
_ggg$ = -212						; size = 4
tv3356 = -208						; size = 4
_j$ = -208						; size = 4
_i$ = -204						; size = 4
_va$ = -200						; size = 4
_ii$91104 = -200					; size = 4
_sign$91064 = -200					; size = 4
_grad$91142 = -196					; size = 48
_tmp$91125 = -148					; size = 48
_g$ = -100						; size = 48
_grad$91106 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_type$ = 8						; size = 4
_mode$ = 12						; size = 4
_rhs$ = 16						; size = 4
_m_calc_quant_hess PROC					; COMDAT

; 3076 : { int i,n,j,m,nn;

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3077 :   struct element *e_ptr;
; 3078 :   struct gen_quant *q;
; 3079 :   int flag;  /* 0 if doing global quantities, 1 for local */
; 3080 :   struct gen_quant_method *gm;
; 3081 :   struct method_instance  *mi;
; 3082 :   int inum;
; 3083 :   struct qinfo *q_info = &(GET_THREAD_DATA->q_info);  /* data passing structure */

	mov	ecx, DWORD PTR _thread_data_key

; 3084 :   int meth_offset = get_meth_offset(type); 

	mov	eax, DWORD PTR _rhs$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _type$[ebp]
	push	edi
	push	ecx
	mov	DWORD PTR _type$GSCopy$[ebp], esi
	mov	DWORD PTR _rhs$GSCopy$[ebp], eax
	call	_win_get_thread_data
	mov	edx, DWORD PTR _web[esi*4+5664]
	imul	esi, 112				; 00000070H
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web[esi+104]
	add	eax, 56					; 00000038H
	mov	DWORD PTR _q_info$[ebp], eax
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+eax+64]

; 3085 :   int me = GET_THREAD_ID;

	mov	edx, DWORD PTR _thread_data_key
	push	edx
	mov	DWORD PTR _meth_offset$[ebp], ecx
	call	_win_get_thread_data
	mov	esi, DWORD PTR [eax]

; 3086 :   int start,end,bin;
; 3087 :   REAL **p1,**p2;
; 3088 :   REAL coeff,ccoeff=0.0;
; 3089 :   struct hess_verlist *va,*vb;
; 3090 :   REAL g[MAXCOORD],*ggg;
; 3091 :   int global_needs;
; 3092 : 
; 3093 : #ifdef SIGUSR1
; 3094 :   signal(SIGUSR1,catcher);    /* to catch user interrupt */ 
; 3095 : #endif
; 3096 :   signal(SIGINT,catcher);    /* to catch user interrupt */     

	push	OFFSET _catcher
	push	2
	mov	DWORD PTR _me$[ebp], esi
	call	_signal

; 3097 :   m_breakflag[me] = 0;

	mov	DWORD PTR _m_breakflag[esi*4], 0

; 3098 :   if ( setjmp(m_jumpbuf[me]) ) { return; }

	shl	esi, 6
	add	esi, OFFSET _m_jumpbuf
	push	0
	push	esi
	call	__setjmp3
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	$LN113@m_calc_qua@2

; 3099 : 
; 3100 :   /* set up matrices in qinfo with lots of room */
; 3101 : 
; 3102 :   if ( q_info->grad == NULL )

	mov	esi, DWORD PTR _q_info$[ebp]
	cmp	DWORD PTR [esi+1336], eax
	jne	SHORT $LN111@m_calc_qua@2

; 3103 :     q_info_init(q_info,METHOD_HESSIAN);

	push	8763					; 0000223bH
	push	esi
	call	_q_info_init
	add	esp, 8
$LN111@m_calc_qua@2:

; 3104 : 
; 3105 :   q_info->hess = dmatrix4(MAXVCOUNT,MAXVCOUNT,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	push	3105					; 00000c21H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	eax
	push	eax
	push	100					; 00000064H
	push	100					; 00000064H
	call	_kb_dmatrix4

; 3106 :   p1 = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);

	push	3106					; 00000c22H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	5
	push	0
	push	5
	push	0
	mov	DWORD PTR [esi+1340], eax
	call	_kb_dmatrix

; 3107 :   p2 = dmatrix(0,MAXCOORD-1,0,MAXCOORD-1);

	push	3107					; 00000c23H
	push	OFFSET ??_C@_0L@OKFHAOGP@QUANTITY?4C?$AA@
	push	5
	push	0
	push	5
	push	0
	mov	DWORD PTR _p1$[ebp], eax
	call	_kb_dmatrix
	add	esp, 72					; 00000048H
	mov	DWORD PTR _p2$[ebp], eax

; 3108 : 
; 3109 :   /* initialize local list */
; 3110 :   m_hess_hash_init();

	call	_m_hess_hash_init

; 3111 : 
; 3112 :   global_needs = global_meth_needs(type);

	mov	edi, DWORD PTR _type$GSCopy$[ebp]
	push	edi
	call	_global_meth_needs

; 3113 :   bin = (web.skel[type].count + nprocs - 1)/nprocs;

	imul	edi, 112				; 00000070H
	mov	ecx, DWORD PTR _nprocs
	mov	edi, DWORD PTR _web[edi+64]
	mov	DWORD PTR _global_needs$[ebp], eax
	lea	eax, DWORD PTR [edi+ecx-1]
	cdq
	idiv	ecx
	add	esp, 4

; 3114 :   start = me*bin;

	mov	ecx, eax
	imul	ecx, DWORD PTR _me$[ebp]

; 3115 :   end = start + bin;

	add	eax, ecx
	mov	DWORD PTR _end$[ebp], eax

; 3116 :   if ( end > web.skel[type].count ) end = web.skel[type].count;

	cmp	eax, edi
	jle	SHORT $LN110@m_calc_qua@2
	mov	eax, edi
	mov	DWORD PTR _end$[ebp], edi
$LN110@m_calc_qua@2:

; 3117 :   for ( nn = start ; nn < end ; nn++ )

	mov	DWORD PTR _nn$[ebp], ecx
	cmp	ecx, eax
	jge	$LN107@m_calc_qua@2
	fldz
$LN109@m_calc_qua@2:

; 3120 :     int needs;
; 3121 : 
; 3122 :     q_info->id = el_list[type][nn]; 

	mov	eax, DWORD PTR _type$GSCopy$[ebp]
	mov	ecx, DWORD PTR _el_list[eax*4]
	mov	edx, DWORD PTR _nn$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 3123 :     e_ptr = elptr(q_info->id);
; 3124 : 
; 3125 :     /* get setup flags */
; 3126 :     needs = global_needs;

	mov	ebx, DWORD PTR _global_needs$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	DWORD PTR [esi], eax
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 3127 :     for ( k = 0 ; k < e_ptr->method_count ; k++ )

	movzx	ecx, WORD PTR [eax+24]
	mov	DWORD PTR _setup_flag$91044[ebp], 0
	mov	DWORD PTR _e_ptr$[ebp], eax
	mov	DWORD PTR _needs$91045[ebp], ebx
	test	ecx, ecx
	jle	SHORT $LN104@m_calc_qua@2

; 3118 :   { int k;
; 3119 :     int setup_flag = 0;

	mov	edx, DWORD PTR _meth_offset$[ebp]
	lea	edi, DWORD PTR [eax+edx]
$LN106@m_calc_qua@2:

; 3128 :     { int mm;
; 3129 :       mm = ((int*)((char*)e_ptr+meth_offset))[k];
; 3130 :       mi = METH_INSTANCE(abs(mm));

	mov	eax, DWORD PTR [edi]
	cdq
	xor	eax, edx
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 3131 :       if ( (mi->flags & Q_DOTHIS) && (mi->type == type) )

	test	BYTE PTR [eax+140], 16			; 00000010H
	je	SHORT $LN105@m_calc_qua@2
	mov	edx, DWORD PTR _type$GSCopy$[ebp]
	cmp	DWORD PTR [eax+136], edx
	jne	SHORT $LN105@m_calc_qua@2

; 3132 :         needs |= basic_gen_methods[mi->gen_method].flags;

	mov	eax, DWORD PTR [eax+148]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 5
	or	ebx, DWORD PTR _basic_gen_methods[eax+132]
$LN105@m_calc_qua@2:

; 3127 :     for ( k = 0 ; k < e_ptr->method_count ; k++ )

	add	edi, 4
	dec	ecx
	jne	SHORT $LN106@m_calc_qua@2

; 3132 :         needs |= basic_gen_methods[mi->gen_method].flags;

	mov	DWORD PTR _needs$91045[ebp], ebx
$LN104@m_calc_qua@2:

; 3133 :     }
; 3134 : 
; 3135 :     inum = global_meth_inst_count[type];

	mov	ecx, DWORD PTR _type$GSCopy$[ebp]
	mov	edx, DWORD PTR _web[ecx*4+5588]
	mov	DWORD PTR _inum$[ebp], edx

; 3136 :     for ( flag = 0 ; flag < 2 ; flag++,inum = e_ptr->method_count,k=0 )

	mov	DWORD PTR _flag$[ebp], 0
$LN102@m_calc_qua@2:

; 3137 :      for ( k = 0 ; k < inum ; k++ )

	cmp	DWORD PTR _inum$[ebp], 0
	mov	DWORD PTR _k$91043[ebp], 0
	jle	$LN101@m_calc_qua@2
	npad	5
$LL99@m_calc_qua@2:

; 3138 :      { int mm,ii,jj;
; 3139 :        int sign = 1;
; 3140 :        REAL value;
; 3141 :        if ( flag ) 

	cmp	DWORD PTR _flag$[ebp], 0
	mov	DWORD PTR _sign$91064[ebp], 1
	je	SHORT $LN96@m_calc_qua@2

; 3142 :        { mm = ((int*)((char*)e_ptr+meth_offset))[k];

	mov	eax, DWORD PTR _e_ptr$[ebp]
	mov	ecx, DWORD PTR _k$91043[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _meth_offset$[ebp]
	mov	ecx, DWORD PTR [edx+eax]

; 3143 :          q_info->method = abs(mm);

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR [esi+8], eax

; 3144 :          if ( mm < 0 ) sign = -1;

	test	ecx, ecx
	jns	SHORT $LN94@m_calc_qua@2
	mov	DWORD PTR _sign$91064[ebp], -1

; 3145 :        }
; 3146 :        else  q_info->method = global_meth_inst[type][k];

	jmp	SHORT $LN94@m_calc_qua@2
$LN96@m_calc_qua@2:
	mov	ecx, DWORD PTR _type$GSCopy$[ebp]
	mov	edx, DWORD PTR _web[ecx*4+5568]
	mov	eax, DWORD PTR _k$91043[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [esi+8], ecx
$LN94@m_calc_qua@2:

; 3147 :        mi = METH_INSTANCE(q_info->method);

	mov	eax, DWORD PTR [esi+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 3148 :        if ( (mi->flags & Q_DOTHIS) && (mi->type == type) )

	test	BYTE PTR [eax+140], 16			; 00000010H
	mov	DWORD PTR _mi$[ebp], eax
	je	$LN247@m_calc_qua@2
	mov	edx, DWORD PTR _type$GSCopy$[ebp]
	cmp	DWORD PTR [eax+136], edx
	jne	$LN247@m_calc_qua@2

; 3149 :         { coeff = 0.0;
; 3150 :           for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 3151 :           { if ( mi->quants[j] < 0 )

	mov	ecx, DWORD PTR _gen_quant_list
	fld	ST(0)
	mov	ebx, eax
	fst	QWORD PTR _coeff$[ebp]
	mov	eax, DWORD PTR [ebx+152]
	test	eax, eax
	js	SHORT $LN250@m_calc_qua@2

; 3152 :               continue;
; 3153 :             q = GEN_QUANT(mi->quants[j]);

	imul	eax, 368				; 00000170H

; 3158 :               coeff += sign*q->modulus*mi->modulus;

	fstp	ST(0)
	fild	DWORD PTR _sign$91064[ebp]
	fld	QWORD PTR [eax+ecx+176]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+304]
	add	eax, ecx
	test	BYTE PTR [eax+136], 10			; 0000000aH
	fld	ST(0)
	faddp	ST(3), ST(0)
	je	SHORT $LN253@m_calc_qua@2

; 3156 :               coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fstp	ST(0)
	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [ebx+304]
	fsubp	ST(1), ST(0)
	fst	QWORD PTR _coeff$[ebp]

; 3157 :             else

	jmp	SHORT $LN91@m_calc_qua@2
$LN253@m_calc_qua@2:

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	fstp	ST(1)

; 3158 :               coeff += sign*q->modulus*mi->modulus;

	faddp	ST(1), ST(0)
	fst	QWORD PTR _coeff$[ebp]
	jmp	SHORT $LN91@m_calc_qua@2
$LN250@m_calc_qua@2:
	fstp	ST(1)
$LN91@m_calc_qua@2:

; 3149 :         { coeff = 0.0;
; 3150 :           for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 3151 :           { if ( mi->quants[j] < 0 )

	mov	eax, DWORD PTR [ebx+156]
	test	eax, eax
	js	SHORT $LN181@m_calc_qua@2

; 3154 :             coeff += sign*q->modulus*mi->modulus;

	fild	DWORD PTR _sign$91064[ebp]
	imul	eax, 368				; 00000170H
	fld	QWORD PTR [eax+ecx+176]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+304]
	add	eax, ecx

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	test	BYTE PTR [eax+136], 10			; 0000000aH
	fld	ST(0)
	faddp	ST(3), ST(0)
	je	SHORT $LN259@m_calc_qua@2
	fstp	ST(0)

; 3156 :               coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [ebx+304]
	fsubp	ST(1), ST(0)

; 3157 :             else

	jmp	SHORT $LN337@m_calc_qua@2
$LN259@m_calc_qua@2:

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	fstp	ST(1)

; 3158 :               coeff += sign*q->modulus*mi->modulus;

	faddp	ST(1), ST(0)
$LN337@m_calc_qua@2:
	fst	QWORD PTR _coeff$[ebp]
$LN181@m_calc_qua@2:

; 3149 :         { coeff = 0.0;
; 3150 :           for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 3151 :           { if ( mi->quants[j] < 0 )

	mov	eax, DWORD PTR [ebx+160]
	test	eax, eax
	js	SHORT $LN184@m_calc_qua@2

; 3154 :             coeff += sign*q->modulus*mi->modulus;

	fild	DWORD PTR _sign$91064[ebp]
	imul	eax, 368				; 00000170H
	fld	QWORD PTR [eax+ecx+176]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+304]
	add	eax, ecx

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	test	BYTE PTR [eax+136], 10			; 0000000aH
	fld	ST(0)
	faddp	ST(3), ST(0)
	je	SHORT $LN265@m_calc_qua@2
	fstp	ST(0)

; 3156 :               coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [ebx+304]
	fsubp	ST(1), ST(0)

; 3157 :             else

	jmp	SHORT $LN338@m_calc_qua@2
$LN265@m_calc_qua@2:

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	fstp	ST(1)

; 3158 :               coeff += sign*q->modulus*mi->modulus;

	faddp	ST(1), ST(0)
$LN338@m_calc_qua@2:
	fst	QWORD PTR _coeff$[ebp]
$LN184@m_calc_qua@2:

; 3149 :         { coeff = 0.0;
; 3150 :           for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 3151 :           { if ( mi->quants[j] < 0 )

	mov	eax, DWORD PTR [ebx+164]
	test	eax, eax
	js	SHORT $LN187@m_calc_qua@2

; 3154 :             coeff += sign*q->modulus*mi->modulus;

	fild	DWORD PTR _sign$91064[ebp]
	imul	eax, 368				; 00000170H
	fld	QWORD PTR [eax+ecx+176]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+304]
	add	eax, ecx

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	test	BYTE PTR [eax+136], 10			; 0000000aH
	fld	ST(0)
	faddp	ST(3), ST(0)
	je	SHORT $LN271@m_calc_qua@2
	fstp	ST(0)

; 3156 :               coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [ebx+304]
	fsubp	ST(1), ST(0)

; 3157 :             else

	jmp	SHORT $LN339@m_calc_qua@2
$LN271@m_calc_qua@2:

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	fstp	ST(1)

; 3158 :               coeff += sign*q->modulus*mi->modulus;

	faddp	ST(1), ST(0)
$LN339@m_calc_qua@2:
	fst	QWORD PTR _coeff$[ebp]
$LN187@m_calc_qua@2:

; 3149 :         { coeff = 0.0;
; 3150 :           for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 3151 :           { if ( mi->quants[j] < 0 )

	mov	eax, DWORD PTR [ebx+168]
	test	eax, eax
	js	SHORT $LN190@m_calc_qua@2

; 3154 :             coeff += sign*q->modulus*mi->modulus;

	fild	DWORD PTR _sign$91064[ebp]
	imul	eax, 368				; 00000170H
	fld	QWORD PTR [eax+ecx+176]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+304]
	add	eax, ecx

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	test	BYTE PTR [eax+136], 10			; 0000000aH
	fld	ST(0)
	faddp	ST(3), ST(0)
	je	SHORT $LN277@m_calc_qua@2
	fstp	ST(0)

; 3156 :               coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [ebx+304]
	fsubp	ST(1), ST(0)

; 3157 :             else

	jmp	SHORT $LN340@m_calc_qua@2
$LN277@m_calc_qua@2:

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	fstp	ST(1)

; 3158 :               coeff += sign*q->modulus*mi->modulus;

	faddp	ST(1), ST(0)
$LN340@m_calc_qua@2:
	fst	QWORD PTR _coeff$[ebp]
$LN190@m_calc_qua@2:

; 3149 :         { coeff = 0.0;
; 3150 :           for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 3151 :           { if ( mi->quants[j] < 0 )

	mov	eax, DWORD PTR [ebx+172]
	test	eax, eax
	js	SHORT $LN193@m_calc_qua@2

; 3154 :             coeff += sign*q->modulus*mi->modulus;

	fild	DWORD PTR _sign$91064[ebp]
	imul	eax, 368				; 00000170H
	fld	QWORD PTR [eax+ecx+176]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+304]
	add	eax, ecx

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	test	BYTE PTR [eax+136], 10			; 0000000aH
	fld	ST(0)
	faddp	ST(3), ST(0)
	je	SHORT $LN283@m_calc_qua@2
	fstp	ST(0)

; 3156 :               coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [ebx+304]
	fsubp	ST(1), ST(0)

; 3157 :             else

	jmp	SHORT $LN341@m_calc_qua@2
$LN283@m_calc_qua@2:

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	fstp	ST(1)

; 3158 :               coeff += sign*q->modulus*mi->modulus;

	faddp	ST(1), ST(0)
$LN341@m_calc_qua@2:
	fst	QWORD PTR _coeff$[ebp]
$LN193@m_calc_qua@2:

; 3149 :         { coeff = 0.0;
; 3150 :           for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 3151 :           { if ( mi->quants[j] < 0 )

	mov	eax, DWORD PTR [ebx+176]
	test	eax, eax
	js	SHORT $LN196@m_calc_qua@2

; 3154 :             coeff += sign*q->modulus*mi->modulus;

	fild	DWORD PTR _sign$91064[ebp]
	imul	eax, 368				; 00000170H
	fld	QWORD PTR [eax+ecx+176]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+304]
	add	eax, ecx

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	test	BYTE PTR [eax+136], 10			; 0000000aH
	fld	ST(0)
	faddp	ST(3), ST(0)
	je	SHORT $LN289@m_calc_qua@2
	fstp	ST(0)

; 3156 :               coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [ebx+304]
	fsubp	ST(1), ST(0)

; 3157 :             else

	jmp	SHORT $LN342@m_calc_qua@2
$LN289@m_calc_qua@2:

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	fstp	ST(1)

; 3158 :               coeff += sign*q->modulus*mi->modulus;

	faddp	ST(1), ST(0)
$LN342@m_calc_qua@2:
	fst	QWORD PTR _coeff$[ebp]
$LN196@m_calc_qua@2:

; 3149 :         { coeff = 0.0;
; 3150 :           for ( j = 0 ; j < MMAXQUANTS ; j++ )
; 3151 :           { if ( mi->quants[j] < 0 )

	mov	eax, DWORD PTR [ebx+180]
	test	eax, eax
	js	SHORT $LN292@m_calc_qua@2

; 3154 :             coeff += sign*q->modulus*mi->modulus;

	fild	DWORD PTR _sign$91064[ebp]
	imul	eax, 368				; 00000170H
	fld	QWORD PTR [eax+ecx+176]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [ebx+304]
	add	eax, ecx

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	test	BYTE PTR [eax+136], 10			; 0000000aH
	fld	ST(0)
	faddp	ST(3), ST(0)
	je	SHORT $LN295@m_calc_qua@2
	fstp	ST(0)

; 3156 :               coeff += -q->pressure*sign*q->modulus*mi->modulus; 

	fmul	QWORD PTR [eax+192]
	fmul	QWORD PTR [eax+176]
	fmul	QWORD PTR [ebx+304]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _coeff$[ebp]

; 3157 :             else

	jmp	SHORT $LN199@m_calc_qua@2
$LN295@m_calc_qua@2:

; 3155 :             if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	fstp	ST(1)

; 3158 :               coeff += sign*q->modulus*mi->modulus;

	faddp	ST(1), ST(0)
	fstp	QWORD PTR _coeff$[ebp]
	jmp	SHORT $LN199@m_calc_qua@2
$LN292@m_calc_qua@2:
	fstp	ST(0)
$LN199@m_calc_qua@2:

; 3159 :           }
; 3160 :            
; 3161 :           if ( !setup_flag ) 

	cmp	DWORD PTR _setup_flag$91044[ebp], 0
	jne	SHORT $LN86@m_calc_qua@2

; 3162 :           { (*q_setup[type])(NULL,q_info,needs); setup_flag = 1; }

	mov	ecx, DWORD PTR _needs$91045[ebp]
	mov	edx, DWORD PTR _type$GSCopy$[ebp]
	mov	eax, DWORD PTR _q_setup[edx*4]
	push	ecx
	push	esi
	push	0
	call	eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _setup_flag$91044[ebp], 1
$LN86@m_calc_qua@2:

; 3163 :           gm = basic_gen_methods + mi->gen_method;

	mov	eax, DWORD PTR [ebx+148]
	lea	edi, DWORD PTR [eax+eax*4]
	shl	edi, 5

; 3164 :           zerohess(q_info);

	push	esi
	add	edi, OFFSET _basic_gen_methods
	call	_zerohess
	add	esp, 4

; 3165 : 
; 3166 :           if ( m_hess_mode ) value = (*gm->hessian)(q_info);

	cmp	DWORD PTR _m_hess_mode, 0
	push	esi
	je	SHORT $LN85@m_calc_qua@2
	mov	ecx, DWORD PTR [edi+152]
	call	ecx
	jmp	SHORT $LN343@m_calc_qua@2
$LN85@m_calc_qua@2:

; 3167 :           else value = (*gm->gradient)(q_info); 

	mov	edx, DWORD PTR [edi+148]
	call	edx
$LN343@m_calc_qua@2:
	add	esp, 4

; 3168 :           if ( mi->flags & ELEMENT_MODULUS_FLAG )

	test	DWORD PTR [ebx+140], 268435456		; 10000000H
	je	$LN74@m_calc_qua@2

; 3169 :           { REAL emdls = *(REAL*)get_extra(q_info->id,mi->elmodulus);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ebx+228]
	mov	eax, ecx
	imul	edx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edi, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	add	edi, edx
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edi+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]

; 3170 :             value *= emdls;
; 3171 :             for ( i = 0 ; i < q_info->vcount ; i++ )

	xor	edi, edi
	fld	QWORD PTR [edx+eax]
	mov	edx, DWORD PTR _web+616
	fld	ST(0)
	fmulp	ST(2), ST(0)
	cmp	DWORD PTR [esi+12], edi
	jle	SHORT $LN80@m_calc_qua@2
$LN82@m_calc_qua@2:

; 3172 :               for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN81@m_calc_qua@2
	mov	edx, DWORD PTR [esi+1336]
	mov	eax, DWORD PTR [edx+edi*4]
$LN79@m_calc_qua@2:

; 3173 :                 q_info->grad[i][j] *= emdls;

	fld	QWORD PTR [eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jl	SHORT $LN79@m_calc_qua@2
$LN81@m_calc_qua@2:

; 3170 :             value *= emdls;
; 3171 :             for ( i = 0 ; i < q_info->vcount ; i++ )

	inc	edi
	cmp	edi, DWORD PTR [esi+12]
	jl	SHORT $LN82@m_calc_qua@2
$LN80@m_calc_qua@2:

; 3174 :             for ( i = 0 ; i < q_info->vcount ; i++ )

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR _i$[ebp], 0
	test	eax, eax
	jle	SHORT $LN316@m_calc_qua@2
$LN76@m_calc_qua@2:

; 3175 :                  for ( ii = 0 ; ii < q_info->vcount ; ii++ )

	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN75@m_calc_qua@2
$LN73@m_calc_qua@2:

; 3176 :               for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	test	edx, edx
	jle	SHORT $LN72@m_calc_qua@2
$LN70@m_calc_qua@2:

; 3177 :                for ( jj = 0 ; jj < SDIM ; jj++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN69@m_calc_qua@2
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [esi+1340]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [edx+edi*4]
$LN67@m_calc_qua@2:

; 3178 :                  q_info->hess[i][ii][j][jj] *= emdls;

	fld	ST(0)
	inc	ecx
	fmul	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jl	SHORT $LN67@m_calc_qua@2
$LN69@m_calc_qua@2:

; 3176 :               for ( j = 0 ; j < SDIM ; j++ )

	inc	edi
	cmp	edi, edx
	jl	SHORT $LN70@m_calc_qua@2
$LN72@m_calc_qua@2:

; 3175 :                  for ( ii = 0 ; ii < q_info->vcount ; ii++ )

	inc	ebx
	cmp	ebx, DWORD PTR [esi+12]
	jl	SHORT $LN73@m_calc_qua@2
$LN75@m_calc_qua@2:

; 3174 :             for ( i = 0 ; i < q_info->vcount ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [esi+12]
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, eax
	jl	SHORT $LN76@m_calc_qua@2
	mov	ebx, DWORD PTR _mi$[ebp]
$LN316@m_calc_qua@2:
	fstp	ST(0)
$LN74@m_calc_qua@2:

; 3180 :           mi->newvalue += sign*value;

	fild	DWORD PTR _sign$91064[ebp]
	fst	QWORD PTR tv1666[ebp]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ebx+328]
	fstp	QWORD PTR [ebx+328]

; 3181 :           mi->abstotal += fabs(value);

	fabs
	fadd	QWORD PTR [ebx+336]
	fstp	QWORD PTR [ebx+336]

; 3182 : 
; 3183 :           /* unwrap */
; 3184 :           if ( sym_flags & NEED_FORM_UNWRAPPING )

	test	BYTE PTR _sym_flags, 2
	je	$LN202@m_calc_qua@2

; 3185 :           { /* gradient */
; 3186 :             int ii,jj;
; 3187 :             REAL grad[MAXCOORD];
; 3188 :             for ( i = 0 ; i < q_info->vcount ; i++ )

	cmp	DWORD PTR [esi+12], 0
	mov	DWORD PTR _i$[ebp], 0
	jle	$LN201@m_calc_qua@2

; 3179 :           }

	mov	eax, -816				; fffffcd0H
	sub	eax, esi
	mov	DWORD PTR tv2617[ebp], eax
	mov	eax, DWORD PTR _web+616
	lea	ebx, DWORD PTR [esi+816]
$LL63@m_calc_qua@2:

; 3189 :             {
; 3190 :                if ( q_info->wraps[i] )

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN62@m_calc_qua@2

; 3191 :                { (*sym_form_pullback)(q_info->x[i],grad,q_info->grad[i],
; 3192 :                                 q_info->wraps[i]);

	mov	edi, DWORD PTR tv2617[ebp]
	push	ecx
	mov	ecx, DWORD PTR [esi+1336]
	add	edi, ebx
	mov	edx, DWORD PTR [ecx+edi]
	mov	ecx, DWORD PTR [ebx-400]
	push	edx
	lea	eax, DWORD PTR _grad$91106[ebp]
	push	eax
	push	ecx
	call	DWORD PTR _sym_form_pullback

; 3193 :                   for ( j = 0 ; j < SDIM ; j++ ) q_info->grad[i][j] = grad[j];

	mov	eax, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN62@m_calc_qua@2

; 3191 :                { (*sym_form_pullback)(q_info->x[i],grad,q_info->grad[i],
; 3192 :                                 q_info->wraps[i]);

	mov	eax, DWORD PTR [esi+1336]
	mov	ecx, DWORD PTR [edi+eax]

; 3193 :                   for ( j = 0 ; j < SDIM ; j++ ) q_info->grad[i][j] = grad[j];

	lea	edi, DWORD PTR _grad$91106[ebp]
	sub	edi, ecx
$LL59@m_calc_qua@2:
	fld	QWORD PTR [edi+ecx]
	inc	edx
	fstp	QWORD PTR [ecx]
	mov	eax, DWORD PTR _web+616
	add	ecx, 8
	cmp	edx, eax
	jl	SHORT $LL59@m_calc_qua@2
$LN62@m_calc_qua@2:

; 3185 :           { /* gradient */
; 3186 :             int ii,jj;
; 3187 :             REAL grad[MAXCOORD];
; 3188 :             for ( i = 0 ; i < q_info->vcount ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	inc	ecx
	add	ebx, 4
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, DWORD PTR [esi+12]
	jl	SHORT $LL63@m_calc_qua@2
	jmp	SHORT $LN61@m_calc_qua@2
$LN201@m_calc_qua@2:
	mov	eax, DWORD PTR _web+616
$LN61@m_calc_qua@2:

; 3194 :                }
; 3195 :             }
; 3196 :             if ( m_hess_mode )

	cmp	DWORD PTR _m_hess_mode, 0
	je	$LN53@m_calc_qua@2

; 3197 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	mov	ecx, DWORD PTR [esi+12]
	xor	ebx, ebx
	mov	DWORD PTR _i$[ebp], ebx
	test	ecx, ecx
	jle	$LN53@m_calc_qua@2
$LL55@m_calc_qua@2:

; 3198 :                for ( ii = 0 ; ii < q_info->vcount ; ii++ )

	mov	DWORD PTR _ii$91104[ebp], 0
	test	ecx, ecx
	jle	$LN54@m_calc_qua@2
	npad	10
$LL52@m_calc_qua@2:

; 3199 :                { if ( q_info->wraps[i] )

	cmp	DWORD PTR [esi+ebx*4+816], 0
	je	$LN46@m_calc_qua@2

; 3200 :                    for ( jj = 0 ; jj < SDIM ; jj++ )

	xor	edi, edi
	test	eax, eax
	jle	$LN46@m_calc_qua@2
$LL48@m_calc_qua@2:

; 3201 :                    { REAL tmp[MAXCOORD];
; 3202 :                       for ( j = 0 ; j < SDIM ; j++ ) 

	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN43@m_calc_qua@2
	npad	2
$LL209@m_calc_qua@2:

; 3203 :                         tmp[j]=q_info->hess[i][ii][j][jj];

	mov	edx, DWORD PTR [esi+1340]
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	ebx, DWORD PTR _ii$91104[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [edx+ecx*4]
	fld	QWORD PTR [edx+edi*8]
	mov	ebx, DWORD PTR _i$[ebp]
	fstp	QWORD PTR _tmp$91125[ebp+ecx*8]
	inc	ecx
	cmp	ecx, eax
	jl	SHORT $LL209@m_calc_qua@2
$LN43@m_calc_qua@2:

; 3204 :                       (*sym_form_pullback)(q_info->x[i],grad,tmp,q_info->wraps[i]);

	mov	eax, DWORD PTR [esi+ebx*4+816]
	push	eax
	mov	eax, DWORD PTR [esi+ebx*4+416]
	lea	ecx, DWORD PTR _tmp$91125[ebp]
	push	ecx
	lea	edx, DWORD PTR _grad$91106[ebp]
	push	edx
	push	eax
	call	DWORD PTR _sym_form_pullback

; 3205 :                       for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN47@m_calc_qua@2

; 3204 :                       (*sym_form_pullback)(q_info->x[i],grad,tmp,q_info->wraps[i]);

	mov	edx, DWORD PTR [esi+1340]
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR _ii$91104[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	npad	5
$LL42@m_calc_qua@2:

; 3206 :                         q_info->hess[i][ii][j][jj] = grad[j];

	mov	eax, DWORD PTR [edx]
	fld	QWORD PTR _grad$91106[ebp+ecx*8]
	fstp	QWORD PTR [eax+edi*8]
	mov	eax, DWORD PTR _web+616
	inc	ecx
	add	edx, 4
	cmp	ecx, eax
	jl	SHORT $LL42@m_calc_qua@2
$LN47@m_calc_qua@2:

; 3200 :                    for ( jj = 0 ; jj < SDIM ; jj++ )

	inc	edi
	cmp	edi, eax
	jl	$LL48@m_calc_qua@2
$LN46@m_calc_qua@2:

; 3207 :                     }
; 3208 :                   if ( q_info->wraps[ii] )

	mov	ecx, DWORD PTR _ii$91104[ebp]
	cmp	DWORD PTR [esi+ecx*4+816], 0
	je	$LN51@m_calc_qua@2

; 3209 :                    for ( j = 0 ; j < SDIM ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	test	eax, eax
	jle	$LN51@m_calc_qua@2

; 3198 :                for ( ii = 0 ; ii < q_info->vcount ; ii++ )

	mov	edx, ecx
	lea	eax, DWORD PTR [esi+edx*4+416]
	mov	DWORD PTR tv2874[ebp], eax
	npad	12
$LL212@m_calc_qua@2:
	mov	eax, DWORD PTR _ii$91104[ebp]

; 3210 :                    { 
; 3211 :                       (*sym_form_pullback)(q_info->x[ii],grad,q_info->hess[i][ii][j],
; 3212 :                                                    q_info->wraps[ii]);

	mov	ecx, DWORD PTR [esi+eax*4+816]
	mov	edx, DWORD PTR [esi+1340]
	push	ecx
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR tv2874[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _grad$91106[ebp]
	push	edx
	push	ecx
	call	DWORD PTR _sym_form_pullback

; 3213 :                        for ( jj = 0 ; jj < SDIM ; jj++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN37@m_calc_qua@2

; 3210 :                    { 
; 3211 :                       (*sym_form_pullback)(q_info->x[ii],grad,q_info->hess[i][ii][j],
; 3212 :                                                    q_info->wraps[ii]);

	mov	eax, DWORD PTR [esi+1340]
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR _ii$91104[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]

; 3213 :                        for ( jj = 0 ; jj < SDIM ; jj++ )

	lea	edi, DWORD PTR _grad$91106[ebp]
	sub	edi, ecx
$LL35@m_calc_qua@2:

; 3214 :                            q_info->hess[i][ii][j][jj] = grad[jj];

	fld	QWORD PTR [edi+ecx]
	inc	edx
	fstp	QWORD PTR [ecx]
	mov	eax, DWORD PTR _web+616
	add	ecx, 8
	cmp	edx, eax
	jl	SHORT $LL35@m_calc_qua@2
$LN37@m_calc_qua@2:

; 3209 :                    for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, eax
	jl	$LL212@m_calc_qua@2
$LN51@m_calc_qua@2:

; 3198 :                for ( ii = 0 ; ii < q_info->vcount ; ii++ )

	mov	ecx, DWORD PTR _ii$91104[ebp]
	inc	ecx
	mov	DWORD PTR _ii$91104[ebp], ecx
	cmp	ecx, DWORD PTR [esi+12]
	jl	$LL52@m_calc_qua@2
$LN54@m_calc_qua@2:

; 3197 :               for ( i = 0 ; i < q_info->vcount ; i++ )

	mov	ecx, DWORD PTR [esi+12]
	inc	ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, ecx
	jl	$LL55@m_calc_qua@2
	jmp	SHORT $LN53@m_calc_qua@2
$LN202@m_calc_qua@2:
	mov	eax, DWORD PTR _web+616
$LN53@m_calc_qua@2:

; 3215 :                    }
; 3216 :                }
; 3217 :           }
; 3218 : 
; 3219 :           for ( i = 0 ; i < q_info->vcount ; i++ )

	xor	edi, edi
	cmp	DWORD PTR [esi+12], edi
	jle	$LN30@m_calc_qua@2
	npad	10
$LL32@m_calc_qua@2:

; 3220 :             { REAL grad[MAXCOORD];
; 3221 :                va = get_vertex_vhead(q_info->v[i]);

	mov	edx, DWORD PTR _vhead_attr
	mov	ecx, DWORD PTR [esi+edi*4+16]
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	ebx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ebx+64]
	mov	edx, DWORD PTR [ecx+edx]
	shl	edx, 5
	add	edx, DWORD PTR _vhead

; 3222 :                for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN27@m_calc_qua@2
	fld	QWORD PTR _coeff$[ebp]
$LN29@m_calc_qua@2:

; 3223 :                   grad[j] = coeff*q_info->grad[i][j];

	mov	ebx, DWORD PTR [esi+1336]
	mov	ebx, DWORD PTR [ebx+edi*4]
	fld	QWORD PTR [ebx+ecx*8]
	inc	ecx
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _grad$91142[ebp+ecx*8-8]
	cmp	ecx, eax
	jl	SHORT $LN29@m_calc_qua@2

; 3222 :                for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
$LN27@m_calc_qua@2:

; 3224 :                m_fill_grad(va,grad,rhs,me);

	mov	eax, DWORD PTR _me$[ebp]
	mov	ecx, DWORD PTR _rhs$GSCopy$[ebp]
	push	eax
	push	ecx
	lea	eax, DWORD PTR _grad$91142[ebp]
	push	eax
	push	edx
	call	_m_fill_grad
	mov	eax, DWORD PTR _web+616
	inc	edi
	add	esp, 16					; 00000010H
	cmp	edi, DWORD PTR [esi+12]
	jl	$LL32@m_calc_qua@2
$LN30@m_calc_qua@2:

; 3225 :             }
; 3226 :           /* second derivatives */
; 3227 :           if ( m_hess_mode )

	cmp	DWORD PTR _m_hess_mode, 0
	je	$LN98@m_calc_qua@2

; 3228 :            for ( i = 0 ; i < q_info->vcount ; i++ )

	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR tv1786[ebp], ecx
	test	ecx, ecx
	jle	$LN98@m_calc_qua@2
$LN25@m_calc_qua@2:
	mov	ecx, DWORD PTR _i$[ebp]

; 3229 :             { va = get_vertex_vhead(q_info->v[i]);

	mov	edx, DWORD PTR [esi+ecx*4+16]
	mov	edi, DWORD PTR _web+12
	lea	ebx, DWORD PTR [esi+ecx*4+16]
	mov	ecx, DWORD PTR _vhead_attr
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+104
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edi+64]
	mov	ecx, DWORD PTR [edx+ecx]
	shl	ecx, 5
	add	ecx, DWORD PTR _vhead
	mov	DWORD PTR tv3113[ebp], ebx

; 3230 :                if ( va->freedom == 0 ) continue;

	cmp	DWORD PTR [ecx+8], 0
	mov	DWORD PTR _va$[ebp], ecx
	je	$LN24@m_calc_qua@2

; 3231 : 
; 3232 :                for ( j = i ; j < q_info->vcount ; j++ )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR tv1786[ebp]
	jge	$LN19@m_calc_qua@2
	mov	ecx, -16				; fffffff0H
	sub	ecx, esi
	mov	DWORD PTR tv3251[ebp], ebx
	mov	DWORD PTR tv3281[ebp], ecx
	npad	2
$LL21@m_calc_qua@2:

; 3233 :                { vb = get_vertex_vhead(q_info->v[j]);

	mov	ecx, DWORD PTR _vhead_attr
	mov	edx, DWORD PTR [ebx]
	imul	ecx, 240				; 000000f0H
	mov	edi, DWORD PTR _web+12
	add	ecx, DWORD PTR _web+104
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edi+64]
	mov	edx, DWORD PTR [edx+ecx]

; 3234 :                  if ( vb->freedom == 0 ) continue;

	mov	ecx, DWORD PTR _vhead
	shl	edx, 5
	cmp	DWORD PTR [edx+ecx+8], 0
	je	$LN20@m_calc_qua@2

; 3235 :                  for ( n = 0 ; n < SDIM ; n++ )

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN15@m_calc_qua@2
	fld	QWORD PTR _coeff$[ebp]
$LN17@m_calc_qua@2:

; 3236 :                     for ( m = 0 ; m < SDIM ; m++ )

	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN16@m_calc_qua@2
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [esi+1340]
	mov	eax, DWORD PTR [eax+ecx*4]
	add	eax, DWORD PTR tv3281[ebp]
	mov	ecx, DWORD PTR [eax+ebx]
$LN14@m_calc_qua@2:

; 3237 :                        q_info->hess[i][j][m][n] *= coeff;

	mov	eax, DWORD PTR [ecx]
	fld	QWORD PTR [eax+edi*8]
	lea	eax, DWORD PTR [eax+edi*8]
	fmul	ST(0), ST(1)
	inc	edx
	add	ecx, 4
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR _web+616
	cmp	edx, eax
	jl	SHORT $LN14@m_calc_qua@2
$LN16@m_calc_qua@2:

; 3235 :                  for ( n = 0 ; n < SDIM ; n++ )

	inc	edi
	cmp	edi, eax
	jl	SHORT $LN17@m_calc_qua@2
	fstp	ST(0)
$LN15@m_calc_qua@2:

; 3238 :                  m_fill_mixed_entry(q_info->v[i],q_info->v[j],
; 3239 :                       q_info->hess[i][j],me);

	mov	edx, DWORD PTR _me$[ebp]
	mov	eax, DWORD PTR [esi+1340]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR tv3281[ebp]
	push	edx
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [ebx]
	add	edi, ebx
	mov	eax, DWORD PTR [edx+edi]
	mov	edx, DWORD PTR tv3113[ebp]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	eax
	call	_m_fill_mixed_entry

; 3240 :                  if ( (i != j) && (q_info->v[i] == q_info->v[j]) )

	mov	ecx, DWORD PTR _j$[ebp]
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _i$[ebp], ecx
	je	SHORT $LN204@m_calc_qua@2
	mov	edx, DWORD PTR tv3113[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ebx]
	cmp	eax, ecx
	jne	SHORT $LN204@m_calc_qua@2

; 3241 :                     m_fill_mixed_entry(q_info->v[i],q_info->v[j],
; 3242 :                        q_info->hess[i][j],me);

	mov	edx, DWORD PTR _me$[ebp]
	mov	ebx, DWORD PTR _i$[ebp]
	push	edx
	mov	edx, DWORD PTR [esi+1340]
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [edx+edi]
	push	edx
	push	ecx
	push	eax
	call	_m_fill_mixed_entry
	mov	ebx, DWORD PTR tv3251[ebp]
	add	esp, 16					; 00000010H
$LN204@m_calc_qua@2:
	mov	eax, DWORD PTR _web+616
$LN20@m_calc_qua@2:

; 3231 : 
; 3232 :                for ( j = i ; j < q_info->vcount ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	inc	ecx
	add	ebx, 4
	mov	DWORD PTR _j$[ebp], ecx
	mov	DWORD PTR tv3251[ebp], ebx
	cmp	ecx, DWORD PTR [esi+12]
	jl	$LL21@m_calc_qua@2
$LN19@m_calc_qua@2:

; 3243 : 
; 3244 :                } /* end inner vertex loop */
; 3245 : 
; 3246 :                /* fixed quantity gradients for left side */
; 3247 :                for ( j = 0 ; j < MMAXQUANTS ; j++ )

	mov	ecx, DWORD PTR _mi$[ebp]
	add	ecx, 152				; 00000098H
	mov	DWORD PTR tv3356[ebp], ecx
	mov	DWORD PTR tv381[ebp], 8
	npad	6
$LL10@m_calc_qua@2:

; 3248 :                { if ( mi->quants[j] < 0 ) 

	mov	ecx, DWORD PTR tv3356[ebp]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	js	$LN9@m_calc_qua@2

; 3249 :                     continue;
; 3250 :                  q = GEN_QUANT(mi->quants[j]);

	imul	ecx, 368				; 00000170H
	add	ecx, DWORD PTR _gen_quant_list
	mov	edi, ecx

; 3251 :                  if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	test	BYTE PTR [edi+136], 10			; 0000000aH
	je	$LN9@m_calc_qua@2

; 3252 :                  { /* find entry */
; 3253 :                    int currentrow;
; 3254 :                    if ( va->proj )

	mov	edx, DWORD PTR _va$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	test	ecx, ecx
	je	SHORT $LN5@m_calc_qua@2

; 3255 :                    { vec_mat_mul(q_info->grad[i],va->proj,g,SDIM,
; 3256 :                                 va->freedom);

	mov	edx, DWORD PTR [edx+8]
	push	edx
	mov	edx, DWORD PTR _i$[ebp]
	push	eax
	lea	eax, DWORD PTR _g$[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+1336]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_vec_mat_mul

; 3257 :                      ggg = g;

	mov	eax, DWORD PTR _web+616
	lea	ecx, DWORD PTR _g$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ggg$[ebp], ecx
	jmp	SHORT $LN4@m_calc_qua@2
$LN5@m_calc_qua@2:

; 3258 :                    }
; 3259 :                    else ggg = q_info->grad[i];

	mov	edx, DWORD PTR [esi+1336]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _ggg$[ebp], edx
$LN4@m_calc_qua@2:

; 3260 :                    currentrow = m_quanrowstart + mi->quants[j];
; 3261 :                    ccoeff = sign*q->modulus*mi->modulus;

	fld	QWORD PTR [edi+176]
	mov	ecx, DWORD PTR tv3356[ebp]
	fmul	QWORD PTR tv1666[ebp]
	mov	edx, DWORD PTR _mi$[ebp]
	mov	ebx, DWORD PTR [ecx]

; 3262 :                    for ( m = 0 ; m < va->freedom ; m++ )

	mov	ecx, DWORD PTR _va$[ebp]
	fmul	QWORD PTR [edx+304]
	add	ebx, DWORD PTR _m_quanrowstart
	xor	edi, edi
	fstp	QWORD PTR _ccoeff$[ebp]
	cmp	DWORD PTR [ecx+8], edi
	jle	SHORT $LN9@m_calc_qua@2
$LN3@m_calc_qua@2:

; 3263 :                       m_hess_hash_search(currentrow,va->rownum+m,
; 3264 :                            ccoeff*ggg[m],me);

	mov	eax, DWORD PTR _ggg$[ebp]
	mov	edx, DWORD PTR _me$[ebp]
	fld	QWORD PTR [eax+edi*8]
	mov	ecx, DWORD PTR _va$[ebp]
	fmul	QWORD PTR _ccoeff$[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+12]
	sub	esp, 8
	add	edx, edi
	fstp	QWORD PTR [esp]
	push	edx
	push	ebx
	call	_m_hess_hash_search
	mov	eax, DWORD PTR _va$[ebp]
	inc	edi
	add	esp, 20					; 00000014H
	cmp	edi, DWORD PTR [eax+8]
	jl	SHORT $LN3@m_calc_qua@2

; 3262 :                    for ( m = 0 ; m < va->freedom ; m++ )

	mov	eax, DWORD PTR _web+616
$LN9@m_calc_qua@2:

; 3243 : 
; 3244 :                } /* end inner vertex loop */
; 3245 : 
; 3246 :                /* fixed quantity gradients for left side */
; 3247 :                for ( j = 0 ; j < MMAXQUANTS ; j++ )

	add	DWORD PTR tv3356[ebp], 4
	dec	DWORD PTR tv381[ebp]
	jne	$LL10@m_calc_qua@2
$LN24@m_calc_qua@2:

; 3228 :            for ( i = 0 ; i < q_info->vcount ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [esi+12]
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	mov	DWORD PTR tv1786[ebp], edx
	cmp	ecx, edx
	jl	$LN25@m_calc_qua@2
	jmp	SHORT $LN98@m_calc_qua@2
$LN247@m_calc_qua@2:

; 3148 :        if ( (mi->flags & Q_DOTHIS) && (mi->type == type) )

	fstp	ST(0)
$LN98@m_calc_qua@2:

; 3137 :      for ( k = 0 ; k < inum ; k++ )

	mov	eax, DWORD PTR _k$91043[ebp]
	fldz
	inc	eax
	mov	DWORD PTR _k$91043[ebp], eax
	cmp	eax, DWORD PTR _inum$[ebp]
	jl	$LL99@m_calc_qua@2
$LN101@m_calc_qua@2:

; 3136 :     for ( flag = 0 ; flag < 2 ; flag++,inum = e_ptr->method_count,k=0 )

	mov	eax, DWORD PTR _flag$[ebp]
	mov	ecx, DWORD PTR _e_ptr$[ebp]
	movzx	edx, WORD PTR [ecx+24]
	inc	eax
	mov	DWORD PTR _flag$[ebp], eax
	mov	DWORD PTR _inum$[ebp], edx
	cmp	eax, 2
	jl	$LN102@m_calc_qua@2

; 3117 :   for ( nn = start ; nn < end ; nn++ )

	mov	eax, DWORD PTR _nn$[ebp]
	inc	eax
	mov	DWORD PTR _nn$[ebp], eax
	cmp	eax, DWORD PTR _end$[ebp]
	jl	$LN109@m_calc_qua@2
	fstp	ST(0)
$LN107@m_calc_qua@2:

; 3265 :                  }
; 3266 :                }
; 3267 :             } /* end second derivatives */
; 3268 :          } /* end if */ 
; 3269 :       } /* end method instance loop */
; 3270 :    } /* end all element loop */
; 3271 : 
; 3272 :   /* free stuff */
; 3273 :   free_matrix4(q_info->hess);

	mov	eax, DWORD PTR [esi+1340]
	push	eax
	call	_free_matrix4

; 3274 :   free_matrix(p1);

	mov	ecx, DWORD PTR _p1$[ebp]
	push	ecx
	call	_free_matrix

; 3275 :   free_matrix(p2);

	mov	edx, DWORD PTR _p2$[ebp]
	push	edx
	call	_free_matrix
	add	esp, 12					; 0000000cH
$LN113@m_calc_qua@2:

; 3276 : 
; 3277 : } // end m_calc_quant_hess()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_m_calc_quant_hess ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@IKIONKLA@sq_torsion?5method?3?5Must?5be?5exact@ ; `string'
EXTRN	_sqtor_marked_edge_attr:DWORD
;	COMDAT ??_C@_0EC@IKIONKLA@sq_torsion?5method?3?5Must?5be?5exact@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EC@IKIONKLA@sq_torsion?5method?3?5Must?5be?5exact@ DB 'sq_torsion '
	DB	'method: Must be exactly two marked edges at vertex %s', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\quantity.c
CONST	ENDS
;	COMDAT _q_edge_setup
_TEXT	SEGMENT
tv1789 = -12						; size = 4
$T94619 = -12						; size = 4
$T94610 = -12						; size = 4
_ee_id$91449 = -12					; size = 4
_right_fe$91434 = -12					; size = 4
tv1896 = -8						; size = 4
tv1883 = -8						; size = 4
tv1777 = -8						; size = 4
tv1196 = -8						; size = 4
_found$91448 = -4					; size = 4
_S$ = 8							; size = 4
_e_info$ = 12						; size = 4
_needs$ = 16						; size = 4
_q_edge_setup PROC					; COMDAT

; 3595 : { int i,j;

	push	ebp
	mov	ebp, esp

; 3596 : 
; 3597 :   if ( web.modeltype == QUADRATIC ) 

	mov	eax, DWORD PTR _web+628
	sub	esp, 12					; 0000000cH
	cmp	eax, 2
	jne	SHORT $LN49@q_edge_set@3

; 3598 :   { q_edge_setup_q(e_info,needs); return; }

	mov	eax, DWORD PTR _needs$[ebp]
	mov	ecx, DWORD PTR _e_info$[ebp]
	push	eax
	push	ecx
	call	_q_edge_setup_q
	add	esp, 8

; 3725 :   }
; 3726 : } // end q_edge_setup()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@q_edge_set@3:

; 3599 :   if ( web.modeltype == LAGRANGE ) 

	cmp	eax, 3
	jne	SHORT $LN48@q_edge_set@3

; 3600 :   { q_edge_setup_lagrange(e_info,needs); return; }

	mov	edx, DWORD PTR _needs$[ebp]
	mov	eax, DWORD PTR _e_info$[ebp]
	push	edx
	push	eax
	call	_q_edge_setup_lagrange
	add	esp, 8

; 3725 :   }
; 3726 : } // end q_edge_setup()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@q_edge_set@3:

; 3601 : 
; 3602 : 
; 3603 :   /* W A R N I N G */
; 3604 :   /* Be sure to place all data consistently for all methods !!! */
; 3605 :   e_info->S = S;

	mov	ecx, DWORD PTR _S$[ebp]
	push	esi
	mov	esi, DWORD PTR _e_info$[ebp]
	mov	DWORD PTR [esi+1348], ecx

; 3606 :   e_info->vcount = (web.representation == SIMPLEX) ? web.dimension : 2;

	cmp	DWORD PTR _web+624, 3
	mov	eax, DWORD PTR _web+620
	je	SHORT $LN53@q_edge_set@3
	mov	eax, 2
$LN53@q_edge_set@3:
	push	ebx

; 3607 :   e_info->v[0] = get_edge_tailv(e_info->id);

	mov	ebx, DWORD PTR [esi]
	push	edi
	push	ebx
	mov	DWORD PTR [esi+12], eax
	call	_get_edge_tailv
	mov	edi, eax

; 3608 :   e_info->v[1] = get_edge_headv(e_info->id);

	push	ebx
	mov	DWORD PTR [esi+16], edi
	call	_get_edge_headv
	mov	DWORD PTR [esi+20], eax

; 3609 :   e_info->x[0] = get_coord(e_info->v[0]);

	mov	edx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR _web+104
	mov	edi, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+edi+64]

; 3610 :   e_info->x[1] = get_coord(e_info->v[1]);

	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR [esi+416], ecx
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+64]
	add	esp, 8
	mov	DWORD PTR [esi+420], edx

; 3611 :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN191@q_edge_set@3

; 3612 :   { WRAPTYPE wrap = get_edge_wrap(e_info->id);

	mov	eax, DWORD PTR _web+124
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+216
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+784]
	mov	edi, DWORD PTR [ecx+edx]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN60@q_edge_set@3
	push	edi
	call	DWORD PTR _sym_inverse
	add	esp, 4
	mov	edi, eax
$LN60@q_edge_set@3:

; 3613 :     (*sym_wrap)(e_info->x[1],e_info->xx[1],wrap);

	mov	eax, DWORD PTR [esi+1216]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [esi+420]
	push	edi
	push	ecx
	push	edx
	call	DWORD PTR _sym_wrap

; 3614 :     e_info->x[1] = e_info->xx[1];

	mov	eax, DWORD PTR [esi+1216]
	mov	ecx, DWORD PTR [eax+4]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+420], ecx

; 3615 :     e_info->wraps[1] = wrap;

	mov	DWORD PTR [esi+820], edi
$LN191@q_edge_set@3:

; 3616 :   }
; 3617 :   if ( needs & NEED_SIDE )

	mov	ebx, DWORD PTR _needs$[ebp]
	test	bl, 16					; 00000010H
	je	SHORT $LN177@q_edge_set@3

; 3618 :      for ( i = 0 ; i < SDIM ; i++ ) 

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN177@q_edge_set@3
	npad	9
$LL45@q_edge_set@3:

; 3619 :         e_info->sides[0][0][i] = e_info->x[1][i] - e_info->x[0][i];

	mov	edx, DWORD PTR [esi+420]
	fld	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR [esi+416]
	mov	edx, DWORD PTR [esi+1276]
	fsub	QWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx]
	fstp	QWORD PTR [edx+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL45@q_edge_set@3
$LN177@q_edge_set@3:

; 3620 :   if ( needs & NEED_WINGS )

	test	bl, 64					; 00000040H
	je	$LN38@q_edge_set@3

; 3621 :   { facetedge_id fe,left_fe,right_fe;
; 3622 :     e_info->vcount = 4; /* need wing vertices, also */
; 3623 :     fe = get_edge_fe(e_info->id);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi+12], 4
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	test	eax, eax
	je	SHORT $LN62@q_edge_set@3
$LN63@q_edge_set@3:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN62@q_edge_set@3
	xor	eax, 134217728				; 08000000H
$LN62@q_edge_set@3:

; 3624 :     left_fe = inverse_id(get_prev_edge(fe));

	mov	edx, DWORD PTR _web+460
	mov	edi, eax
	shr	edi, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	and	edi, 1
	mov	eax, DWORD PTR [edx+eax*4]
	je	SHORT $LN67@q_edge_set@3
	mov	ecx, DWORD PTR [eax+32]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN66@q_edge_set@3
$LN67@q_edge_set@3:
	mov	ecx, DWORD PTR [eax+28]
$LN66@q_edge_set@3:
	xor	ecx, 134217728				; 08000000H

; 3625 :     right_fe = inverse_id(get_prev_edge(get_next_facet(fe)));

	test	edi, edi
	je	SHORT $LN71@q_edge_set@3
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN70@q_edge_set@3
$LN71@q_edge_set@3:
	mov	eax, DWORD PTR [eax+40]
$LN70@q_edge_set@3:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN75@q_edge_set@3
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN74@q_edge_set@3
$LN75@q_edge_set@3:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]
$LN74@q_edge_set@3:

; 3626 :     e_info->v[2] = get_fe_headv(left_fe);

	mov	edi, ecx
	xor	eax, 134217728				; 08000000H
	and	edi, 134217727				; 07ffffffH
	mov	ebx, eax
	add	edi, edi
	mov	eax, ecx
	add	edi, edi
	mov	ecx, DWORD PTR [edi+edx]
	mov	edx, DWORD PTR [ecx+20]
	and	eax, 134217728				; 08000000H
	xor	edx, eax
	push	edx
	mov	DWORD PTR _right_fe$91434[ebp], ebx
	mov	DWORD PTR tv1777[ebp], eax
	call	_get_edge_headv
	mov	DWORD PTR [esi+24], eax

; 3627 :     e_info->v[3] = get_fe_headv(right_fe);

	mov	ecx, DWORD PTR _web+460
	mov	eax, DWORD PTR _right_fe$91434[ebp]
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ebx+ecx]
	mov	ecx, DWORD PTR [edx+20]
	and	eax, 134217728				; 08000000H
	xor	ecx, eax
	push	ecx
	mov	DWORD PTR tv1789[ebp], eax
	call	_get_edge_headv
	add	esp, 8
	mov	DWORD PTR [esi+28], eax

; 3628 :     if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	$LN41@q_edge_set@3

; 3629 :     { e_info->wraps[2] = get_edge_wrap(get_fe_edge(left_fe));

	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [eax+20]
	xor	eax, DWORD PTR tv1777[ebp]
	mov	edx, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+edi+784]
	mov	ecx, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN86@q_edge_set@3
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN87@q_edge_set@3
$LN86@q_edge_set@3:
	mov	eax, ecx
$LN87@q_edge_set@3:
	mov	DWORD PTR [esi+824], eax

; 3630 :       e_info->wraps[3] = get_edge_wrap(get_fe_edge(right_fe));

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx+20]
	xor	eax, DWORD PTR tv1789[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edi+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN92@q_edge_set@3
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN93@q_edge_set@3
$LN92@q_edge_set@3:
	mov	eax, ecx
$LN93@q_edge_set@3:
	mov	DWORD PTR [esi+828], eax
$LN41@q_edge_set@3:

; 3631 :     }
; 3632 :     for ( i = 2 ; i <= 3 ; i++ )

	mov	ebx, -416				; fffffe60H
	lea	edi, DWORD PTR [esi+424]
	sub	ebx, esi
	mov	DWORD PTR tv1196[ebp], 2
$LL40@q_edge_set@3:

; 3633 :     {
; 3634 :       e_info->x[i] = get_coord(e_info->v[i]);

	mov	edx, DWORD PTR [edi-400]
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+64]
	add	ecx, edx
	mov	DWORD PTR [edi], ecx

; 3635 :       if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN37@q_edge_set@3

; 3636 :       { (*sym_wrap)(e_info->x[i],e_info->xx[i],e_info->wraps[i]);

	mov	edx, DWORD PTR [edi+400]
	push	edx
	mov	edx, DWORD PTR [esi+1216]
	lea	eax, DWORD PTR [ebx+edi]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	push	ecx
	call	DWORD PTR _sym_wrap

; 3637 :         e_info->x[i] = e_info->xx[i];

	mov	ecx, DWORD PTR [esi+1216]
	lea	eax, DWORD PTR [ebx+edi]
	mov	edx, DWORD PTR [eax+ecx]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi], edx
$LN37@q_edge_set@3:

; 3638 :       }
; 3639 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN39@q_edge_set@3
	npad	9
$LL36@q_edge_set@3:

; 3640 :          e_info->sides[0][i-1][j] = e_info->x[i][j] - e_info->x[0][j];

	mov	ecx, DWORD PTR [edi]
	fld	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR [esi+416]
	fsub	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR [esi+1276]
	mov	edx, DWORD PTR [ecx]
	add	edx, ebx
	mov	ecx, DWORD PTR [edx+edi-4]
	fstp	QWORD PTR [ecx+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL36@q_edge_set@3
$LN39@q_edge_set@3:

; 3631 :     }
; 3632 :     for ( i = 2 ; i <= 3 ; i++ )

	add	edi, 4
	dec	DWORD PTR tv1196[ebp]
	jne	$LL40@q_edge_set@3
	mov	ebx, DWORD PTR _needs$[ebp]
$LN38@q_edge_set@3:

; 3641 :     }
; 3642 :   }
; 3643 :   if ( needs & NEED_MARKED_WINGS )

	test	ebx, 1024				; 00000400H
	je	$LN15@q_edge_set@3

; 3644 :   { int found;
; 3645 :     edge_id ee_id;
; 3646 : 
; 3647 :     ee_id = get_next_tail_edge(e_info->id);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR _web+124
	mov	edx, ecx
	shr	edx, 27					; 0000001bH
	mov	edi, ecx
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+edi*4]
	and	edx, 1
	mov	edx, DWORD PTR [edi+edx*4+32]
	mov	DWORD PTR _ee_id$91449[ebp], edx

; 3648 :     found = 0;

	mov	DWORD PTR _found$91448[ebp], 0

; 3649 :     while ( !equal_id(ee_id,e_info->id) )

	cmp	edx, ecx
	je	$LN179@q_edge_set@3
	npad	13
$LL32@q_edge_set@3:

; 3650 :     { 
; 3651 :       if ( (sqtor_marked_edge_attr>0) && *EINT(ee_id,sqtor_marked_edge_attr) )

	mov	edi, DWORD PTR _sqtor_marked_edge_attr
	test	edi, edi
	jle	$LN182@q_edge_set@3
	mov	ebx, DWORD PTR _dymem
	imul	edi, 240				; 000000f0H
	add	edi, DWORD PTR _web+216
	mov	ecx, edx
	mov	edi, DWORD PTR [edi+ebx+64]
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	ebx, DWORD PTR [ecx+eax]
	cmp	DWORD PTR [ebx+edi], 0
	je	$LN182@q_edge_set@3

; 3652 :       { int i = e_info->vcount;            

	mov	edi, DWORD PTR [esi+12]

; 3653 :         e_info->v[i] = get_edge_headv(ee_id);

	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	DWORD PTR tv1896[ebp], edx
	je	SHORT $LN97@q_edge_set@3
	mov	eax, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+304]
	mov	eax, DWORD PTR [ebx+eax]
	jmp	SHORT $LN96@q_edge_set@3
$LN97@q_edge_set@3:
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+304]
	mov	eax, DWORD PTR _web+636
	lea	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+ebx]
$LN96@q_edge_set@3:
	mov	DWORD PTR [esi+edi*4+16], eax

; 3654 :         e_info->marked[i] = *EINT(ee_id,sqtor_marked_edge_attr);

	mov	edx, DWORD PTR _sqtor_marked_edge_attr
	mov	ebx, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+216

; 3655 :         e_info->x[i] = get_coord(e_info->v[i]);

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ebx+64]
	mov	ebx, DWORD PTR _web+124
	mov	ebx, DWORD PTR [ecx+ebx]
	mov	edx, DWORD PTR [edx+ebx]
	mov	DWORD PTR [esi+edi*4+1352], edx
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ebx+64]
	mov	DWORD PTR [esi+edi*4+416], eax

; 3656 :         if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN29@q_edge_set@3

; 3657 :         { (*sym_wrap)(e_info->x[i],e_info->xx[i],get_edge_wrap(ee_id));

	cmp	DWORD PTR tv1896[ebp], 0
	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+784]
	mov	eax, DWORD PTR [ecx+edx]
	je	SHORT $LN102@q_edge_set@3
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN102@q_edge_set@3:
	mov	edx, DWORD PTR [esi+edi*4+416]
	push	eax
	mov	eax, DWORD PTR [esi+1216]
	mov	ecx, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	call	DWORD PTR _sym_wrap

; 3658 :           e_info->x[i] = e_info->xx[i];

	mov	eax, DWORD PTR [esi+1216]
	mov	ecx, DWORD PTR [eax+edi*4]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+edi*4+416], ecx
$LN29@q_edge_set@3:

; 3659 :         }
; 3660 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN181@q_edge_set@3
	npad	13
$LL28@q_edge_set@3:

; 3661 :            e_info->sides[0][i][j] = e_info->x[i][j] - e_info->x[0][j];

	mov	edx, DWORD PTR [esi+edi*4+416]
	fld	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR [esi+416]
	mov	edx, DWORD PTR [esi+1276]
	fsub	QWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx+edi*4]
	fstp	QWORD PTR [edx+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL28@q_edge_set@3
$LN181@q_edge_set@3:

; 3662 :         e_info->vcount++;

	mov	ecx, 1
	add	DWORD PTR [esi+12], ecx

; 3663 :         found++;

	add	DWORD PTR _found$91448[ebp], ecx

; 3664 :         if ( e_info->vcount >= MAXVCOUNT ) break;

	cmp	DWORD PTR [esi+12], 100			; 00000064H
	mov	eax, DWORD PTR _web+124
	jge	SHORT $LN193@q_edge_set@3
	mov	edx, DWORD PTR _ee_id$91449[ebp]
$LN182@q_edge_set@3:

; 3665 :       }
; 3666 :       ee_id = get_next_tail_edge(ee_id);

	mov	ecx, edx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	edx, DWORD PTR [edx+ecx*4+32]
	mov	DWORD PTR _ee_id$91449[ebp], edx
	cmp	edx, DWORD PTR [esi]
	jne	$LL32@q_edge_set@3
$LN193@q_edge_set@3:

; 3667 :     };
; 3668 :     if ( found != 1 )

	cmp	DWORD PTR _found$91448[ebp], 1
	je	$LN24@q_edge_set@3
$LN179@q_edge_set@3:

; 3669 :     { sprintf(errmsg,"sq_torsion method: Must be exactly two marked edges at vertex %s\n",
; 3670 :         ELNAME(get_edge_tailv(e_info->id)));

	mov	ecx, DWORD PTR [esi]
	mov	edi, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+edi+304]
	mov	ebx, DWORD PTR _web+636
	mov	edi, ecx
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN107@q_edge_set@3
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+edi*4]
	lea	edi, DWORD PTR [edi+ebx*4]
	mov	edi, DWORD PTR [edi+edx]
	jmp	SHORT $LN106@q_edge_set@3
$LN107@q_edge_set@3:
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR [edx+edi]
$LN106@q_edge_set@3:
	test	edi, 268435456				; 10000000H
	je	SHORT $LN54@q_edge_set@3
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN111@q_edge_set@3
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	ecx, DWORD PTR [eax+ebx*4]
	mov	edx, DWORD PTR [ecx+edx]
	jmp	SHORT $LN110@q_edge_set@3
$LN111@q_edge_set@3:
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR [edx+eax]
$LN110@q_edge_set@3:
	and	edx, 134217727				; 07ffffffH
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN55@q_edge_set@3
$LN54@q_edge_set@3:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN55@q_edge_set@3:
	push	eax
	push	OFFSET ??_C@_0EC@IKIONKLA@sq_torsion?5method?3?5Must?5be?5exact@
	push	OFFSET _errmsg
	call	_sprintf

; 3671 :       kb_error(6589,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	6589					; 000019bdH
	call	_kb_error
	mov	eax, DWORD PTR _web+124
	add	esp, 24					; 00000018H
$LN24@q_edge_set@3:

; 3672 :     }
; 3673 : 
; 3674 :     ee_id = get_next_head_edge(e_info->id);

	mov	ecx, DWORD PTR [esi]
	mov	edx, ecx
	shr	edx, 27					; 0000001bH
	mov	edi, ecx
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+edi*4]
	not	edx
	and	edx, 1
	mov	ebx, DWORD PTR [edi+edx*4+32]
	xor	ebx, 134217728				; 08000000H

; 3675 :     found = 0;

	mov	DWORD PTR _found$91448[ebp], 0

; 3676 :     while ( !equal_id(ee_id,e_info->id) )

	cmp	ebx, ecx
	je	$LN187@q_edge_set@3
	npad	5
$LL23@q_edge_set@3:

; 3677 :     { 
; 3678 :       if ( (sqtor_marked_edge_attr>0) && *EINT(ee_id,sqtor_marked_edge_attr) )

	mov	edx, DWORD PTR _sqtor_marked_edge_attr
	test	edx, edx
	jle	$LN186@q_edge_set@3
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+216
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+eax]
	mov	DWORD PTR tv1883[ebp], edi
	mov	edi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+edi+64]
	mov	edi, DWORD PTR tv1883[ebp]
	cmp	DWORD PTR [edi+edx], 0
	je	$LN186@q_edge_set@3

; 3679 :       { int i = e_info->vcount;           
; 3680 :         e_info->v[i] = get_edge_tailv(ee_id);

	mov	eax, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	edi, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax+edx+304]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN117@q_edge_set@3
	mov	edx, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR tv1883[ebp]
	mov	eax, DWORD PTR [eax+edx]
	jmp	SHORT $LN201@q_edge_set@3
$LN117@q_edge_set@3:
	mov	edx, DWORD PTR tv1883[ebp]
	mov	eax, DWORD PTR [edx+eax]
$LN201@q_edge_set@3:
	mov	DWORD PTR [esi+edi*4+16], eax

; 3681 :         e_info->marked[i] = *EINT(ee_id,sqtor_marked_edge_attr);      

	mov	edx, DWORD PTR _dymem
	mov	DWORD PTR $T94610[ebp], eax
	mov	eax, DWORD PTR _sqtor_marked_edge_attr
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR [eax+ecx]

; 3682 :         e_info->x[i] = get_coord(e_info->v[i]);

	mov	eax, DWORD PTR $T94610[ebp]
	mov	DWORD PTR [esi+edi*4+1352], edx
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+64]
	mov	DWORD PTR [esi+edi*4+416], edx

; 3683 :         if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN20@q_edge_set@3

; 3684 :         { (*sym_wrap)(e_info->x[i],e_info->xx[i],get_edge_wrap(inverse_id(ee_id)));

	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR _web+216
	mov	eax, ebx
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR $T94619[ebp], eax
	and	eax, 134217727				; 07ffffffH
	test	DWORD PTR $T94619[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	eax, DWORD PTR [eax+ecx]
	je	SHORT $LN122@q_edge_set@3
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN122@q_edge_set@3:
	mov	edx, DWORD PTR [esi+1216]
	mov	ecx, DWORD PTR [esi+edi*4+416]
	push	eax
	mov	eax, DWORD PTR [edx+edi*4]
	push	eax
	push	ecx
	call	DWORD PTR _sym_wrap

; 3685 :           e_info->x[i] = e_info->xx[i];

	mov	edx, DWORD PTR [esi+1216]
	mov	eax, DWORD PTR [edx+edi*4]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+edi*4+416], eax
$LN20@q_edge_set@3:

; 3686 :         }
; 3687 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN185@q_edge_set@3
	npad	13
$LL19@q_edge_set@3:

; 3688 :            e_info->sides[0][i][j] = e_info->x[i][j] - e_info->x[1][j];

	mov	ecx, DWORD PTR [esi+edi*4+416]
	fld	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR [esi+420]
	mov	ecx, DWORD PTR [esi+1276]
	fsub	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+edi*4]
	fstp	QWORD PTR [ecx+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL19@q_edge_set@3
$LN185@q_edge_set@3:

; 3689 :         e_info->vcount++;

	mov	ecx, 1
	add	DWORD PTR [esi+12], ecx

; 3690 :         found++;

	add	DWORD PTR _found$91448[ebp], ecx

; 3691 :         if ( e_info->vcount >= MAXVCOUNT ) break;

	cmp	DWORD PTR [esi+12], 100			; 00000064H
	mov	eax, DWORD PTR _web+124
	jge	SHORT $LN194@q_edge_set@3
$LN186@q_edge_set@3:

; 3692 :       }
; 3693 :       ee_id = get_next_head_edge(ee_id);

	mov	edx, ebx
	shr	edx, 27					; 0000001bH
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ebx*4]
	not	edx
	and	edx, 1
	mov	ebx, DWORD PTR [ecx+edx*4+32]
	xor	ebx, 134217728				; 08000000H
	cmp	ebx, DWORD PTR [esi]
	jne	$LL23@q_edge_set@3
$LN194@q_edge_set@3:

; 3694 :     };
; 3695 :     if ( found != 1 )

	cmp	DWORD PTR _found$91448[ebp], 1
	je	$LN189@q_edge_set@3
$LN187@q_edge_set@3:

; 3696 :     { sprintf(errmsg,"sq_torsion method: Must be exactly two marked edges at vertex %s\n",
; 3697 :         ELNAME(get_edge_tailv(e_info->id)));

	mov	ecx, DWORD PTR [esi]
	mov	edi, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+edi+304]
	mov	ebx, DWORD PTR _web+636
	mov	edi, ecx
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN127@q_edge_set@3
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+edi*4]
	lea	edi, DWORD PTR [edi+ebx*4]
	mov	edi, DWORD PTR [edi+edx]
	jmp	SHORT $LN126@q_edge_set@3
$LN127@q_edge_set@3:
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR [edx+edi]
$LN126@q_edge_set@3:
	test	edi, 268435456				; 10000000H
	je	SHORT $LN56@q_edge_set@3
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN131@q_edge_set@3
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	ecx, DWORD PTR [eax+ebx*4]
	mov	edx, DWORD PTR [ecx+edx]
	jmp	SHORT $LN130@q_edge_set@3
$LN131@q_edge_set@3:
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR [edx+eax]
$LN130@q_edge_set@3:
	and	edx, 134217727				; 07ffffffH
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN57@q_edge_set@3
$LN56@q_edge_set@3:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN57@q_edge_set@3:
	push	eax
	push	OFFSET ??_C@_0EC@IKIONKLA@sq_torsion?5method?3?5Must?5be?5exact@
	push	OFFSET _errmsg
	call	_sprintf

; 3698 :       kb_error(6590,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	6590					; 000019beH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN189@q_edge_set@3:
	mov	ebx, DWORD PTR _needs$[ebp]
$LN15@q_edge_set@3:

; 3699 :     }
; 3700 :   } // end NEED_MARKED_WINGS
; 3701 : 
; 3702 :   if ( needs & NEED_STRING_STAR )

	test	ebx, 512				; 00000200H
	je	$LN188@q_edge_set@3

; 3703 :   { edge_id e_id1,e_id2 = e_info->id,e_id3;

	mov	eax, DWORD PTR [esi]

; 3704 :      /* careful of weird packaging */
; 3705 :      e_info->vcount = 4;  /* need vertices of adjacent edges also */
; 3706 :      e_id1 = inverse_id(get_next_tail_edge(e_id2));

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	DWORD PTR [esi+12], 4
	mov	edi, DWORD PTR _web+124
	mov	edx, DWORD PTR [edi+ecx*4]
	shr	eax, 27					; 0000001bH
	mov	ecx, eax
	and	ecx, 1
	mov	ecx, DWORD PTR [edx+ecx*4+32]

; 3707 :      e_id3 = inverse_id(get_next_head_edge(e_id2));

	not	eax
	xor	ecx, 134217728				; 08000000H
	and	eax, 1
	mov	eax, DWORD PTR [edx+eax*4+32]

; 3708 :      /* have to leave first two vertices in place for other methods */
; 3709 :      e_info->v[2] = get_edge_tailv(e_id1);                                     

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN139@q_edge_set@3
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	add	edx, DWORD PTR [ecx+edi+304]
	mov	ecx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN138@q_edge_set@3
$LN139@q_edge_set@3:
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edi+304]
	mov	ecx, DWORD PTR [edx+ecx]
$LN138@q_edge_set@3:
	mov	DWORD PTR [esi+24], ecx

; 3710 :      e_info->v[3] = get_edge_headv(e_id3);

	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR _web+216
	test	eax, 134217728				; 08000000H
	je	SHORT $LN143@q_edge_set@3
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN142@q_edge_set@3
$LN143@q_edge_set@3:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+304]
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
$LN142@q_edge_set@3:
	mov	DWORD PTR [esi+28], eax

; 3711 :      for ( j = 0 ; j < 4  ; j++ ) e_info->x[j] = get_coord(e_info->v[j]);

	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR [esi+16]
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+eax+64]
	mov	DWORD PTR [esi+416], ecx
	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR [esi+20]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+64]
	mov	DWORD PTR [esi+420], eax
	mov	ecx, DWORD PTR _web+12
	mov	eax, DWORD PTR [esi+24]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+64]
	mov	DWORD PTR [esi+424], edx
	mov	edx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+eax+64]

; 3712 :      for ( j = 0 ; j < SDIM ; j++ ) 

	xor	eax, eax
	mov	DWORD PTR [esi+428], ecx
	mov	edx, DWORD PTR _web+616
	test	edx, edx
	jle	SHORT $LN8@q_edge_set@3
$LL10@q_edge_set@3:

; 3713 :      { 
; 3714 :         e_info->sides[0][0][j] = e_info->x[1][j] - e_info->x[0][j];

	mov	ecx, DWORD PTR [esi+420]
	fld	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR [esi+416]
	fsub	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR [esi+1276]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	fstp	QWORD PTR [ecx+eax*8]

; 3715 :         e_info->sides[0][1][j] = e_info->x[0][j] - e_info->x[2][j];

	mov	edx, DWORD PTR [esi+416]
	fld	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR [esi+424]
	fsub	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR [esi+1276]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx+4]
	fstp	QWORD PTR [edx+eax*8]

; 3716 :         e_info->sides[0][2][j] = e_info->x[3][j] - e_info->x[1][j];

	mov	ecx, DWORD PTR [esi+428]
	fld	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR [esi+420]
	fsub	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR [esi+1276]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+8]
	fstp	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR _web+616
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL10@q_edge_set@3

; 3712 :      for ( j = 0 ; j < SDIM ; j++ ) 

	jmp	SHORT $LN8@q_edge_set@3
$LN188@q_edge_set@3:
	mov	edx, DWORD PTR _web+616
$LN8@q_edge_set@3:

; 3717 :      }
; 3718 :   }
; 3719 :   if ( needs & NEED_GAUSS )

	test	bl, bl
	jns	SHORT $LN199@q_edge_set@3

; 3720 :   { int m;
; 3721 :     for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	ecx, ecx
	cmp	DWORD PTR _gauss1D_num, ecx
	jle	SHORT $LN199@q_edge_set@3
$LL197@q_edge_set@3:

; 3722 :       for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN5@q_edge_set@3

; 3720 :   { int m;
; 3721 :     for ( m = 0 ; m < gauss1D_num ; m++ )

	mov	edx, DWORD PTR _gauss1poly
	mov	edi, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [edx]
	lea	edi, DWORD PTR [edi+ecx*8]
	lea	ebx, DWORD PTR [edx+ecx*8]
	npad	8
$LL3@q_edge_set@3:

; 3723 :          e_info->gauss_pt[m][i] = gauss1poly[0][m]*e_info->x[0][i]
; 3724 :                                 + gauss1poly[1][m]*e_info->x[1][i];

	mov	edx, DWORD PTR [esi+420]
	fld	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [esi+416]
	fmul	QWORD PTR [edi]
	inc	eax
	fld	QWORD PTR [edx+eax*8-8]
	mov	edx, DWORD PTR [esi+1268]
	fmul	QWORD PTR [ebx]
	mov	edx, DWORD PTR [edx+ecx*4]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx+eax*8-8]
	mov	edx, DWORD PTR _web+616
	cmp	eax, edx
	jl	SHORT $LL3@q_edge_set@3
$LN5@q_edge_set@3:

; 3720 :   { int m;
; 3721 :     for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	ecx
	cmp	ecx, DWORD PTR _gauss1D_num
	jl	SHORT $LL197@q_edge_set@3
$LN199@q_edge_set@3:
	pop	edi
	pop	ebx
	pop	esi

; 3725 :   }
; 3726 : } // end q_edge_setup()

	mov	esp, ebp
	pop	ebp
	ret	0
_q_edge_setup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EH@MHOJLAC@Facet?5?$CFs?5has?5too?5many?5neighbors?5@ ; `string'
PUBLIC	??_C@_0EI@HBNLEBNM@Facet?5?$CFs?5missing?5neighbor?5needed@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	_ctrl_num:DWORD
EXTRN	_cross_prod:PROC
;	COMDAT ??_C@_0EH@MHOJLAC@Facet?5?$CFs?5has?5too?5many?5neighbors?5@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EH@MHOJLAC@Facet?5?$CFs?5has?5too?5many?5neighbors?5@ DB 'Facet %s'
	DB	' has too many neighbors for NEED_SURROUNDING_VERTICES method.'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@HBNLEBNM@Facet?5?$CFs?5missing?5neighbor?5needed@
CONST	SEGMENT
??_C@_0EI@HBNLEBNM@Facet?5?$CFs?5missing?5neighbor?5needed@ DB 'Facet %s '
	DB	'missing neighbor needed for NEED_SURROUNDING_VERTICES method.'
	DB	0aH, 00H					; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\quantity.c
CONST	ENDS
;	COMDAT _q_facet_setup
_TEXT	SEGMENT
tv1249 = -72						; size = 4
tv945 = -68						; size = 4
tv165 = -64						; size = 4
tv1448 = -60						; size = 4
tv968 = -56						; size = 4
_fe$91657 = -56						; size = 4
_xx$91658 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_f_info$ = 12						; size = 4
_needs$ = 16						; size = 4
_q_facet_setup PROC					; COMDAT

; 3861 : { facetedge_id fe_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3862 :   int i,j;
; 3863 : 
; 3864 :   f_info->S = S;

	mov	eax, DWORD PTR _S$[ebp]
	push	edi
	mov	edi, DWORD PTR _f_info$[ebp]
	mov	DWORD PTR [edi+1348], eax

; 3865 :   if ( web.modeltype == QUADRATIC ) 

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	SHORT $LN33@q_facet_se@3

; 3866 :   { q_facet_setup_q (f_info,needs); return; }

	mov	ecx, DWORD PTR _needs$[ebp]
	push	ecx
	push	edi
	call	_q_facet_setup_q
	add	esp, 8
	pop	edi

; 3938 :     }
; 3939 :   } // end NEED_SURROUNDING_VERTICES
; 3940 : 
; 3941 : } // end q_facet_setup()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@q_facet_se@3:

; 3867 :   if ( web.modeltype == LAGRANGE )  

	cmp	eax, 3
	jne	SHORT $LN32@q_facet_se@3

; 3868 :   { q_facet_setup_lagrange(f_info,needs); return;}

	mov	edx, DWORD PTR _needs$[ebp]
	push	edx
	push	edi
	call	_q_facet_setup_lagrange
	add	esp, 8
	pop	edi

; 3938 :     }
; 3939 :   } // end NEED_SURROUNDING_VERTICES
; 3940 : 
; 3941 : } // end q_facet_setup()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@q_facet_se@3:

; 3869 : 
; 3870 :   /* W A R N I N G */
; 3871 :   /* Be sure to place all data consistently for all methods !!! */
; 3872 : 
; 3873 :   f_info->vcount = web.dimension+1;

	mov	eax, DWORD PTR _web+620
	inc	eax
	push	ebx
	mov	DWORD PTR [edi+12], eax

; 3874 :   if ( web.representation == SIMPLEX )

	mov	ebx, DWORD PTR _web+624
	push	esi
	cmp	ebx, 3
	jne	SHORT $LN31@q_facet_se@3

; 3875 :   { vertex_id *vv = get_facet_vertices(f_info->id);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR _web+328
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]

; 3876 :     for ( i = 0 ; i <= web.dimension ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+620, ecx
	jl	$LN110@q_facet_se@3

; 3875 :   { vertex_id *vv = get_facet_vertices(f_info->id);

	mov	esi, -416				; fffffe60H
	lea	eax, DWORD PTR [edi+416]
	sub	esi, edi
	npad	8
$LL30@q_facet_se@3:

; 3877 :     { f_info->v[i] = vv[i];

	mov	ebx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax-400], ebx

; 3878 :       f_info->x[i] = f_info->xx[i];

	mov	ebx, DWORD PTR [edi+1216]
	add	ebx, esi
	mov	ebx, DWORD PTR [ebx+eax]
	mov	DWORD PTR [eax], ebx
	inc	ecx
	add	eax, 4
	cmp	ecx, DWORD PTR _web+620
	jle	SHORT $LL30@q_facet_se@3

; 3879 :     }
; 3880 :   }
; 3881 :   else

	jmp	$LN110@q_facet_se@3
$LN31@q_facet_se@3:

; 3882 :   { 
; 3883 :     fe_id = get_facet_fe(f_info->id);

	mov	edx, DWORD PTR [edi]
	push	edx
	call	_get_facet_fe
	add	esp, 4
	mov	esi, eax

; 3884 :     if ( web.representation == SOAPFILM )

	cmp	ebx, 2
	jne	$LN110@q_facet_se@3

; 3885 :     { for ( i = 0 ; i < FACET_VERTS ; i++ )
; 3886 :         f_info->x[i] = f_info->xx[i];

	mov	ecx, DWORD PTR [edi+1216]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edi+416], edx
	mov	ecx, DWORD PTR [edi+1216]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edi+416]
	mov	DWORD PTR [edi+420], edx
	mov	ecx, DWORD PTR [edi+1216]
	mov	edx, DWORD PTR [ecx+8]

; 3887 :       get_facet_verts(f_info->id,f_info->x,f_info->wraps);  /* in tail order */

	lea	ecx, DWORD PTR [edi+816]
	push	ecx
	mov	DWORD PTR [edi+424], edx
	mov	edx, DWORD PTR [edi]
	push	eax
	push	edx
	call	_get_facet_verts

; 3888 :       for ( i = 0 ; i < FACET_EDGES ; i++ )
; 3889 :       { 
; 3890 :         f_info->v[i] = get_fe_tailv(fe_id);

	mov	eax, DWORD PTR _web+460
	mov	ebx, DWORD PTR _dymem
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _web+124
	add	esp, 12					; 0000000cH
	test	eax, 134217728				; 08000000H
	je	SHORT $LN43@q_facet_se@3
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	add	eax, DWORD PTR [edx+ebx+304]
	mov	edx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN42@q_facet_se@3
$LN43@q_facet_se@3:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ebx+304]
	mov	eax, DWORD PTR [eax+edx]
$LN42@q_facet_se@3:
	mov	DWORD PTR [edi+16], eax

; 3891 :         fe_id = get_next_edge(fe_id);

	mov	eax, DWORD PTR _web+460
	test	esi, 134217728				; 08000000H
	je	SHORT $LN47@q_facet_se@3
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN21@q_facet_se@3
$LN47@q_facet_se@3:
	mov	edx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [edx+32]
$LN21@q_facet_se@3:

; 3888 :       for ( i = 0 ; i < FACET_EDGES ; i++ )
; 3889 :       { 
; 3890 :         f_info->v[i] = get_fe_tailv(fe_id);

	mov	ebx, DWORD PTR _dymem
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	esi, DWORD PTR [ecx+eax]
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [esi+20]
	mov	esi, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN101@q_facet_se@3
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+216
	add	eax, DWORD PTR [esi+ebx+304]
	mov	esi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN102@q_facet_se@3
$LN101@q_facet_se@3:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+216
	mov	esi, DWORD PTR [esi+ebx+304]
	mov	eax, DWORD PTR [eax+esi]
$LN102@q_facet_se@3:
	mov	DWORD PTR [edi+20], eax

; 3891 :         fe_id = get_next_edge(fe_id);

	test	edx, 134217728				; 08000000H
	mov	edx, DWORD PTR _web+460
	je	SHORT $LN103@q_facet_se@3
	mov	ecx, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN104@q_facet_se@3
$LN103@q_facet_se@3:
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax+32]
$LN104@q_facet_se@3:

; 3888 :       for ( i = 0 ; i < FACET_EDGES ; i++ )
; 3889 :       { 
; 3890 :         f_info->v[i] = get_fe_tailv(fe_id);

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN106@q_facet_se@3
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN107@q_facet_se@3
$LN106@q_facet_se@3:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]
$LN107@q_facet_se@3:
	mov	DWORD PTR [edi+24], eax
$LN110@q_facet_se@3:

; 3892 :       } 
; 3893 :     }
; 3894 :   }
; 3895 :  
; 3896 :   /* fan of sides from v0 */
; 3897 :   if ( needs & NEED_SIDE )

	mov	ebx, DWORD PTR _needs$[ebp]
	test	bl, 16					; 00000010H
	je	SHORT $LN115@q_facet_se@3

; 3898 :   { for ( i = 0 ; i < web.dimension ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+620, ecx
	jle	SHORT $LN115@q_facet_se@3
	npad	3
$LL114@q_facet_se@3:

; 3899 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN17@q_facet_se@3
	mov	edx, DWORD PTR [edi+ecx*4+420]
$LL15@q_facet_se@3:

; 3900 :         f_info->sides[0][i][j] = f_info->x[i+1][j] - f_info->x[0][j];

	mov	esi, DWORD PTR [edi+416]
	fld	QWORD PTR [edx+eax*8]
	fsub	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR [edi+1276]
	mov	esi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+ecx*4]
	fstp	QWORD PTR [esi+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL15@q_facet_se@3
$LN17@q_facet_se@3:

; 3898 :   { for ( i = 0 ; i < web.dimension ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR _web+620
	jl	SHORT $LL114@q_facet_se@3
$LN115@q_facet_se@3:

; 3901 :   }
; 3902 : 
; 3903 :   if ( needs & NEED_NORMAL )

	test	bl, 32					; 00000020H
	je	SHORT $LN12@q_facet_se@3

; 3904 :   { cross_prod(f_info->sides[0][0],f_info->sides[0][1],f_info->normal);

	mov	ecx, DWORD PTR [edi+1276]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [edi+1288]
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	_cross_prod
	add	esp, 12					; 0000000cH
$LN12@q_facet_se@3:

; 3905 :   }
; 3906 : 
; 3907 :   if ( needs & NEED_GAUSS )

	test	bl, bl
	jns	SHORT $LN11@q_facet_se@3

; 3908 :     mat_mult(gpoly,f_info->x,f_info->gauss_pt,gauss2D_num,ctrl_num,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _ctrl_num
	mov	edx, DWORD PTR _gauss2D_num
	push	eax
	mov	eax, DWORD PTR [edi+1268]
	push	ecx
	push	edx
	mov	edx, DWORD PTR _gpoly
	push	eax
	lea	ecx, DWORD PTR [edi+416]
	push	ecx
	push	edx
	call	_mat_mult
	add	esp, 24					; 00000018H
$LN11@q_facet_se@3:

; 3909 : 
; 3910 :   if ( needs & NEED_SURROUNDING_VERTICES )

	test	ebx, 8192				; 00002000H
	je	$LN116@q_facet_se@3

; 3911 :   { // For soapfilm model, add outer vertices of neighbor facets.
; 3912 :     // Linear model only.  Error if missing neighbor facets.
; 3913 :     // Error if multiple neighbors.  Originally for Rabah Bouzidi.
; 3914 :     facetedge_id fe;
; 3915 :     REAL xx[MAXCOORD];
; 3916 :     f_info->vcount = 2*FACET_EDGES;  // 6 total
; 3917 :     fe = get_facet_fe(f_info->id);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [edi+12], 6
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN51@q_facet_se@3
	xor	edx, edx
	mov	DWORD PTR _fe$91657[ebp], edx
	jmp	SHORT $LN52@q_facet_se@3
$LN51@q_facet_se@3:
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN50@q_facet_se@3
	xor	ecx, 134217728				; 08000000H
$LN50@q_facet_se@3:
	mov	DWORD PTR _fe$91657[ebp], ecx
	mov	edx, ecx
$LN52@q_facet_se@3:

; 3918 :     for ( i = 0 ; i < FACET_EDGES ; i++ )

	lea	eax, DWORD PTR [edi+428]
	mov	DWORD PTR tv1448[ebp], eax
	mov	eax, -416				; fffffe60H
	sub	eax, edi
	mov	DWORD PTR tv1249[ebp], eax
	mov	eax, DWORD PTR _web+460
	mov	DWORD PTR tv165[ebp], 3
	jmp	SHORT $LN9@q_facet_se@3
	npad	1
$LL113@q_facet_se@3:
	mov	edx, DWORD PTR _fe$91657[ebp]
$LN9@q_facet_se@3:

; 3919 :     { edge_id e_id;
; 3920 :       facetedge_id ffe = get_next_facet(fe);

	mov	ecx, edx
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR tv945[ebp], ecx
	mov	ebx, edx
	je	SHORT $LN55@q_facet_se@3
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+eax]
	mov	esi, DWORD PTR [ecx+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN54@q_facet_se@3
$LN55@q_facet_se@3:
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+eax]
	mov	esi, DWORD PTR [ecx+40]
$LN54@q_facet_se@3:

; 3921 :       if ( !valid_id(ffe) || equal_id(fe,ffe) )

	test	esi, 268435456				; 10000000H
	je	SHORT $LN5@q_facet_se@3
	cmp	edx, esi
	jne	SHORT $LN6@q_facet_se@3
$LN5@q_facet_se@3:

; 3922 :       { sprintf(errmsg,"Facet %s missing neighbor needed for NEED_SURROUNDING_VERTICES method.\n",
; 3923 :              ELNAME(f_info->id));

	mov	eax, DWORD PTR [edi]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN36@q_facet_se@3
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN37@q_facet_se@3
$LN36@q_facet_se@3:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN37@q_facet_se@3:
	push	eax
	push	OFFSET ??_C@_0EI@HBNLEBNM@Facet?5?$CFs?5missing?5neighbor?5needed@
	push	OFFSET _errmsg
	call	_sprintf

; 3924 :         kb_error(4572,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4572					; 000011dcH
	call	_kb_error
	mov	eax, DWORD PTR _web+460
	mov	edx, DWORD PTR _fe$91657[ebp]
	add	esp, 24					; 00000018H
$LN6@q_facet_se@3:

; 3925 :       }
; 3926 :       if ( !equal_id(fe,get_next_facet(ffe)) )

	mov	ecx, esi
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR tv968[ebp], ecx
	je	SHORT $LN59@q_facet_se@3
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN58@q_facet_se@3
$LN59@q_facet_se@3:
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [eax+40]
$LN58@q_facet_se@3:
	cmp	edx, eax
	je	SHORT $LN4@q_facet_se@3

; 3927 :       { sprintf(errmsg,"Facet %s has too many neighbors for NEED_SURROUNDING_VERTICES method.\n",
; 3928 :              ELNAME(f_info->id));

	mov	eax, DWORD PTR [edi]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN38@q_facet_se@3
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN39@q_facet_se@3
$LN38@q_facet_se@3:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN39@q_facet_se@3:
	push	eax
	push	OFFSET ??_C@_0EH@MHOJLAC@Facet?5?$CFs?5has?5too?5many?5neighbors?5@
	push	OFFSET _errmsg
	call	_sprintf

; 3929 :         kb_error(4579,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4579					; 000011e3H
	call	_kb_error
	mov	ecx, DWORD PTR tv968[ebp]
	add	esp, 24					; 00000018H
$LN4@q_facet_se@3:

; 3930 :       }
; 3931 :       f_info->x[FACET_EDGES+i] = f_info->xx[FACET_EDGES+i];

	mov	edx, DWORD PTR [edi+1216]
	add	edx, DWORD PTR tv1448[ebp]
	mov	eax, DWORD PTR tv1249[ebp]
	mov	edx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR tv1448[ebp]
	mov	DWORD PTR [eax], edx

; 3932 :       e_id = get_fe_edge(get_prev_edge(ffe));

	test	ecx, ecx
	mov	ecx, DWORD PTR _web+460
	je	SHORT $LN63@q_facet_se@3
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN62@q_facet_se@3
$LN63@q_facet_se@3:
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+28]
$LN62@q_facet_se@3:

; 3933 :       f_info->v[FACET_EDGES+i] = get_edge_tailv(e_id);

	mov	esi, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	test	eax, 134217728				; 08000000H
	je	SHORT $LN69@q_facet_se@3
	add	edx, DWORD PTR [ecx+esi+304]
	mov	ecx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN68@q_facet_se@3
$LN69@q_facet_se@3:
	mov	ecx, DWORD PTR [ecx+esi+304]
	mov	ecx, DWORD PTR [edx+ecx]
$LN68@q_facet_se@3:
	mov	esi, DWORD PTR tv1448[ebp]

; 3934 :       get_edge_side(e_id,xx);

	lea	edx, DWORD PTR _xx$91658[ebp]
	push	edx
	push	eax
	mov	DWORD PTR [esi-400], ecx
	call	_get_edge_side

; 3935 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	add	esp, 8
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN1@q_facet_se@3
$LL3@q_facet_se@3:

; 3936 :         f_info->x[FACET_EDGES+i][j] = f_info->x[i][j] - xx[j];

	mov	ecx, DWORD PTR [esi-12]
	fld	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR [esi]
	fsub	QWORD PTR _xx$91658[ebp+eax*8]
	inc	eax
	fstp	QWORD PTR [edx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL3@q_facet_se@3
$LN1@q_facet_se@3:

; 3937 :       fe = get_next_edge(fe);

	cmp	DWORD PTR tv945[ebp], 0
	mov	eax, DWORD PTR _web+460
	je	SHORT $LN73@q_facet_se@3
	mov	ecx, DWORD PTR [ebx+eax]
	mov	ecx, DWORD PTR [ecx+28]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN118@q_facet_se@3
$LN73@q_facet_se@3:
	mov	edx, DWORD PTR [ebx+eax]
	mov	ecx, DWORD PTR [edx+32]
$LN118@q_facet_se@3:

; 3918 :     for ( i = 0 ; i < FACET_EDGES ; i++ )

	add	esi, 4
	dec	DWORD PTR tv165[ebp]

; 3937 :       fe = get_next_edge(fe);

	mov	DWORD PTR _fe$91657[ebp], ecx
	mov	DWORD PTR tv1448[ebp], esi
	jne	$LL113@q_facet_se@3
$LN116@q_facet_se@3:

; 3938 :     }
; 3939 :   } // end NEED_SURROUNDING_VERTICES
; 3940 : 
; 3941 : } // end q_facet_setup()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	pop	ebx
	xor	ecx, ebp
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_q_facet_setup ENDP
_TEXT	ENDS
PUBLIC	??_C@_05OBNKBLIJ@_inst?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_add_standard_quantity
;	COMDAT ??_C@_05OBNKBLIJ@_inst?$AA@
CONST	SEGMENT
??_C@_05OBNKBLIJ@_inst?$AA@ DB '_inst', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _add_standard_quantity
_TEXT	SEGMENT
_inst_name$ = -44					; size = 40
__$ArrayPad$ = -4					; size = 4
_meth_name$ = 8						; size = 4
_modulus$ = 12						; size = 8
_add_standard_quantity PROC				; COMDAT

; 721  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _meth_name$[ebp]
	push	edi

; 722  :   int mi;
; 723  :   int q;
; 724  :   char inst_name[40];
; 725  : 
; 726  :   strncpy(inst_name,meth_name,25);

	push	25					; 00000019H
	lea	eax, DWORD PTR _inst_name$[ebp]
	push	esi
	push	eax
	call	_strncpy

; 727  :   strcat(inst_name,"_inst");

	lea	eax, DWORD PTR _inst_name$[ebp]
	add	esp, 12					; 0000000cH
	dec	eax
$LL3@add_standa:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@add_standa
	mov	ecx, DWORD PTR ??_C@_05OBNKBLIJ@_inst?$AA@
	mov	dx, WORD PTR ??_C@_05OBNKBLIJ@_inst?$AA@+4
	mov	DWORD PTR [eax], ecx
	mov	WORD PTR [eax+4], dx

; 728  :   mi = new_method_instance(meth_name,inst_name);

	lea	eax, DWORD PTR _inst_name$[ebp]
	push	eax
	push	esi
	call	_new_method_instance

; 729  :   q = new_quantity(meth_name,Q_ENERGY);

	push	1
	push	esi
	mov	edi, eax
	call	_new_quantity
	mov	esi, eax

; 730  :   attach_method_num(q,mi);

	push	edi
	push	esi
	call	_attach_method_num

; 731  :   apply_method(NULLID,inst_name);

	lea	ecx, DWORD PTR _inst_name$[ebp]
	push	ecx
	push	0
	call	_apply_method

; 732  :   METH_INSTANCE(mi)->modulus = 1.0;

	fld1
	mov	eax, edi
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	add	esp, 32					; 00000020H
	fstp	QWORD PTR [eax+edx+304]

; 733  :   GEN_QUANT(q)->modulus = modulus;

	mov	ecx, DWORD PTR _gen_quant_list
	fld	QWORD PTR _modulus$[ebp]
	mov	eax, esi
	imul	eax, 368				; 00000170H
	pop	edi
	fstp	QWORD PTR [eax+ecx+176]

; 734  :   GEN_QUANT(q)->flags |= STANDARD_QUANTITY;

	mov	ecx, DWORD PTR _gen_quant_list
	or	DWORD PTR [eax+ecx+136], 4096		; 00001000H

; 735  :  
; 736  :   return q;
; 737  : } // end add_standard_quantity()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_add_standard_quantity ENDP
_TEXT	ENDS
END
