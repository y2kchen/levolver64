; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\HELP.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@PNDFAEDB@evhelp?4txt?$AA@		; `string'
PUBLIC	??_C@_0BI@KCJEPLLJ@?5x?0q?5Exit?5to?5main?5menu?4?$AA@ ; `string'
PUBLIC	??_C@_0BJ@GACCJADA@?5?$DP?0h?5help?5?$CIthis?5display?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CD@HGCHLFGM@?5t?5?5?5?5Set?5clipping?5mode?5for?5toru@ ; `string'
PUBLIC	??_C@_0CF@ONDAPFKM@?5H?5?5?5?5Toggle?5hidden?5surface?5remo@ ; `string'
PUBLIC	??_C@_0CG@PFFLHNIP@?5?$CL?0?9?5Increment?0?5decrement?5fill?5c@ ; `string'
PUBLIC	??_C@_0BJ@BJJNMBPC@?5b?5?5?5?5Draw?5bounding?5box?4?$AA@ ; `string'
PUBLIC	??_C@_0DI@EALAPEAO@?5w?5?5?5?5Toggle?5facets?5with?5three?5v@ ; `string'
PUBLIC	??_C@_0CI@KIIJHJHK@?5v?5?5?5?5Toggle?5ridge?5and?5valley?5co@ ; `string'
PUBLIC	??_C@_0CJ@EOGPKHIE@?5B?5?5?5?5Toggle?5display?5of?5boundary@ ; `string'
PUBLIC	??_C@_0CB@PNCFIKED@?5e?5?5?5?5Toggle?5facet?5edge?5drawing?4@ ; `string'
PUBLIC	??_C@_0CM@IDBCPEOJ@?5T?5?5?5?5Toggle?5additional?5viewing?5@ ; `string'
PUBLIC	??_C@_0CA@JLFEIPBH@?5R?5?5?5?5Reset?5viewing?5parameters?4?$AA@ ; `string'
PUBLIC	??_C@_0BE@GODBGHA@?5m?5?5?5?5Center?5image?4?$AA@ ; `string'
PUBLIC	??_C@_0BP@GFOENCPO@?5arrow?5keys?5?9?5Translate?5image?4?$AA@ ; `string'
PUBLIC	??_C@_0BP@GPJNBCKH@?5s?5?5?5?5Shrink?5by?5factor?5of?51?42?4?$AA@ ; `string'
PUBLIC	??_C@_0BN@EGIAPNCD@?5z?5?5?5?5Zoom?5by?5factor?5of?51?42?4?$AA@ ; `string'
PUBLIC	??_C@_0CJ@FLOLGKMO@?5C?5?5?5?5Rotate?5counterclockwise?56?5@ ; `string'
PUBLIC	??_C@_0CC@ELFGICMB@?5c?5?5?5?5Rotate?5clockwise?56?5degrees@ ; `string'
PUBLIC	??_C@_0BN@FDOPEBBM@?5l?5?5?5?5Rotate?5left?56?5degrees?4?$AA@ ; `string'
PUBLIC	??_C@_0BO@DGLCHNOL@?5r?5?5?5?5Rotate?5right?56?5degrees?4?$AA@ ; `string'
PUBLIC	??_C@_0BM@NAIGJLGJ@?5d?5?5?5?5Rotate?5down?56?5degrees?$AA@ ; `string'
PUBLIC	??_C@_0BL@COFAJKBG@?5u?5?5?5?5Rotate?5up?56?5degrees?4?$AA@ ; `string'
PUBLIC	??_C@_0DH@HANPMDCM@or?5a?5real?5value?5?$CIif?5appropriate?$DL@ ; `string'
PUBLIC	??_C@_0EG@FEAJEGBF@causes?5an?5action?5and?5may?5be?5prec@ ; `string'
PUBLIC	??_C@_0EC@FFFEHFEE@View?5transformation?5commands?5are@ ; `string'
PUBLIC	??_C@_0CA@CIGPMICE@?5?5show?5facets?5where?5area?5?$DM?5?401?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@NAPCNACO@?5?5list?5vertices?5where?5x?$FO2?5?$CL?5y?$FO2?5@ ; `string'
PUBLIC	??_C@_0DO@JDDIPCIA@?5?5set?5facet?5color?5green?5where?5or@ ; `string'
PUBLIC	??_C@_0DB@MLLLADNG@?5?5refine?5edges?5where?5not?5fixed?5a@ ; `string'
PUBLIC	??_C@_0DE@FEPCDCJH@?5?5list?5edges?5?$HM?5?$CCmore?$CC?$DL?5list?5topi@ ; `string'
PUBLIC	??_C@_0CI@DEFBLCOP@Examples?5of?5the?5full?5command?5lan@ ; `string'
PUBLIC	??_C@_0EF@HHMJJDFL@?5lightblue?0lightgreen?0lightred?0l@ ; `string'
PUBLIC	??_C@_0EF@MNCAIDKL@Colors?3?5black?0red?0green?0blue?0cya@ ; `string'
PUBLIC	??_C@_0DO@GPDLKFAA@Operators?3?5?$CL?0?9?0?$CK?0?1?0?$FOn?0?$CK?$CK?0?$DN?$DN?0?$CB?$DN?0?$DO@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0BO@FOCBMIDB@?5w?5?5Weed?5out?5small?5triangles?4?$AA@ ; `string'
PUBLIC	??_C@_0BE@OFDLFKFO@?5v?5?5Report?5volumes?4?$AA@ ; `string'
PUBLIC	??_C@_0BG@DALGOAJA@?5V?5?5Vertex?5averaging?4?$AA@ ; `string'
PUBLIC	??_C@_0BC@ELJCEIPM@?5u?5?5Equiangulate?4?$AA@	; `string'
PUBLIC	??_C@_0CG@CLCKPGMC@?5U?5?5Toggle?5conjugate?5gradient?5me@ ; `string'
PUBLIC	??_C@_0BH@IDKMGEPF@?5t?5?5Remove?5tiny?5edges?4?$AA@ ; `string'
PUBLIC	??_C@_0BO@HGOOCIFF@?5s?5?5Built?9in?5screen?5graphics?4?$AA@ ; `string'
PUBLIC	??_C@_0BK@IBBMFEML@?5r?5?5Refine?5triangulation?4?$AA@ ; `string'
PUBLIC	??_C@_0O@KOBJOFGP@?5q?0x?5?5?5?5Exit?4?$AA@	; `string'
PUBLIC	??_C@_0CF@NLEHHDBF@?5P?5?5Graphics?5display?5file?0?5geomv@ ; `string'
PUBLIC	??_C@_0BP@CBPNFLLI@?5m?5?5Toggle?5fixed?5motion?5scale?4?$AA@ ; `string'
PUBLIC	??_C@_0BK@PMOOCDPI@?5l?5?5Subdivide?5long?5edges?4?$AA@ ; `string'
PUBLIC	??_C@_0BL@KAMMIDCI@?5i?5?5Information?5on?5status?4?$AA@ ; `string'
PUBLIC	??_C@_0BJ@JPMLBABO@?5H?0h?0?$DP?5This?5help?5screen?4?$AA@ ; `string'
PUBLIC	??_C@_0BO@FADDDHKK@?5g?5nnn?5?5?5?5?5Go?5nnn?5iterations?4?$AA@ ; `string'
PUBLIC	??_C@_0BB@INBHLNHO@?5G?5?5Set?5gravity?4?$AA@	; `string'
PUBLIC	??_C@_0BO@KIDNKDLC@?5d?5?5Dump?5surface?5to?5datafile?4?$AA@ ; `string'
PUBLIC	??_C@_0CE@CDECDEIN@?5D?5?5Toggle?5display?5every?5iterati@ ; `string'
PUBLIC	??_C@_0BO@MNINPCFK@?5c?5?5Report?5count?5of?5elements?4?$AA@ ; `string'
PUBLIC	??_C@_0BM@EHCCEILG@?5C?5?5Run?5consistency?5checks?4?$AA@ ; `string'
PUBLIC	??_C@_0CD@LIMCJAJG@?5b?5?5Set?5body?5volumes?5or?5pressure@ ; `string'
PUBLIC	??_C@_0BP@CCEHJHBL@?5A?5?5Set?5adjustable?5parameters?4?$AA@ ; `string'
PUBLIC	_help_strings
PUBLIC	_qhelp
PUBLIC	_ghelp_strings
PUBLIC	_text_help_file
;	COMDAT ??_C@_0L@PNDFAEDB@evhelp?4txt?$AA@
CONST	SEGMENT
??_C@_0L@PNDFAEDB@evhelp?4txt?$AA@ DB 'evhelp.txt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KCJEPLLJ@?5x?0q?5Exit?5to?5main?5menu?4?$AA@
CONST	SEGMENT
??_C@_0BI@KCJEPLLJ@?5x?0q?5Exit?5to?5main?5menu?4?$AA@ DB ' x,q Exit to m'
	DB	'ain menu.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GACCJADA@?5?$DP?0h?5help?5?$CIthis?5display?$CJ?$AA@
CONST	SEGMENT
??_C@_0BJ@GACCJADA@?5?$DP?0h?5help?5?$CIthis?5display?$CJ?$AA@ DB ' ?,h h'
	DB	'elp (this display)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HGCHLFGM@?5t?5?5?5?5Set?5clipping?5mode?5for?5toru@
CONST	SEGMENT
??_C@_0CD@HGCHLFGM@?5t?5?5?5?5Set?5clipping?5mode?5for?5toru@ DB ' t    S'
	DB	'et clipping mode for torus.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@ONDAPFKM@?5H?5?5?5?5Toggle?5hidden?5surface?5remo@
CONST	SEGMENT
??_C@_0CF@ONDAPFKM@?5H?5?5?5?5Toggle?5hidden?5surface?5remo@ DB ' H    To'
	DB	'ggle hidden surface removal.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PFFLHNIP@?5?$CL?0?9?5Increment?0?5decrement?5fill?5c@
CONST	SEGMENT
??_C@_0CG@PFFLHNIP@?5?$CL?0?9?5Increment?0?5decrement?5fill?5c@ DB ' +,- '
	DB	'Increment, decrement fill color.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BJJNMBPC@?5b?5?5?5?5Draw?5bounding?5box?4?$AA@
CONST	SEGMENT
??_C@_0BJ@BJJNMBPC@?5b?5?5?5?5Draw?5bounding?5box?4?$AA@ DB ' b    Draw b'
	DB	'ounding box.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@EALAPEAO@?5w?5?5?5?5Toggle?5facets?5with?5three?5v@
CONST	SEGMENT
??_C@_0DI@EALAPEAO@?5w?5?5?5?5Toggle?5facets?5with?5three?5v@ DB ' w    T'
	DB	'oggle facets with three vertices on constraints.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KIIJHJHK@?5v?5?5?5?5Toggle?5ridge?5and?5valley?5co@
CONST	SEGMENT
??_C@_0CI@KIIJHJHK@?5v?5?5?5?5Toggle?5ridge?5and?5valley?5co@ DB ' v    T'
	DB	'oggle ridge and valley coloring.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EOGPKHIE@?5B?5?5?5?5Toggle?5display?5of?5boundary@
CONST	SEGMENT
??_C@_0CJ@EOGPKHIE@?5B?5?5?5?5Toggle?5display?5of?5boundary@ DB ' B    To'
	DB	'ggle display of boundary facets.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PNCFIKED@?5e?5?5?5?5Toggle?5facet?5edge?5drawing?4@
CONST	SEGMENT
??_C@_0CB@PNCFIKED@?5e?5?5?5?5Toggle?5facet?5edge?5drawing?4@ DB ' e    T'
	DB	'oggle facet edge drawing.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IDBCPEOJ@?5T?5?5?5?5Toggle?5additional?5viewing?5@
CONST	SEGMENT
??_C@_0CM@IDBCPEOJ@?5T?5?5?5?5Toggle?5additional?5viewing?5@ DB ' T    To'
	DB	'ggle additional viewing transforms.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JLFEIPBH@?5R?5?5?5?5Reset?5viewing?5parameters?4?$AA@
CONST	SEGMENT
??_C@_0CA@JLFEIPBH@?5R?5?5?5?5Reset?5viewing?5parameters?4?$AA@ DB ' R   '
	DB	' Reset viewing parameters.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GODBGHA@?5m?5?5?5?5Center?5image?4?$AA@
CONST	SEGMENT
??_C@_0BE@GODBGHA@?5m?5?5?5?5Center?5image?4?$AA@ DB ' m    Center image.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GFOENCPO@?5arrow?5keys?5?9?5Translate?5image?4?$AA@
CONST	SEGMENT
??_C@_0BP@GFOENCPO@?5arrow?5keys?5?9?5Translate?5image?4?$AA@ DB ' arrow '
	DB	'keys - Translate image.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GPJNBCKH@?5s?5?5?5?5Shrink?5by?5factor?5of?51?42?4?$AA@
CONST	SEGMENT
??_C@_0BP@GPJNBCKH@?5s?5?5?5?5Shrink?5by?5factor?5of?51?42?4?$AA@ DB ' s '
	DB	'   Shrink by factor of 1.2.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EGIAPNCD@?5z?5?5?5?5Zoom?5by?5factor?5of?51?42?4?$AA@
CONST	SEGMENT
??_C@_0BN@EGIAPNCD@?5z?5?5?5?5Zoom?5by?5factor?5of?51?42?4?$AA@ DB ' z   '
	DB	' Zoom by factor of 1.2.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FLOLGKMO@?5C?5?5?5?5Rotate?5counterclockwise?56?5@
CONST	SEGMENT
??_C@_0CJ@FLOLGKMO@?5C?5?5?5?5Rotate?5counterclockwise?56?5@ DB ' C    Ro'
	DB	'tate counterclockwise 6 degrees.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ELFGICMB@?5c?5?5?5?5Rotate?5clockwise?56?5degrees@
CONST	SEGMENT
??_C@_0CC@ELFGICMB@?5c?5?5?5?5Rotate?5clockwise?56?5degrees@ DB ' c    Ro'
	DB	'tate clockwise 6 degrees.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FDOPEBBM@?5l?5?5?5?5Rotate?5left?56?5degrees?4?$AA@
CONST	SEGMENT
??_C@_0BN@FDOPEBBM@?5l?5?5?5?5Rotate?5left?56?5degrees?4?$AA@ DB ' l    R'
	DB	'otate left 6 degrees.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DGLCHNOL@?5r?5?5?5?5Rotate?5right?56?5degrees?4?$AA@
CONST	SEGMENT
??_C@_0BO@DGLCHNOL@?5r?5?5?5?5Rotate?5right?56?5degrees?4?$AA@ DB ' r    '
	DB	'Rotate right 6 degrees.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NAIGJLGJ@?5d?5?5?5?5Rotate?5down?56?5degrees?$AA@
CONST	SEGMENT
??_C@_0BM@NAIGJLGJ@?5d?5?5?5?5Rotate?5down?56?5degrees?$AA@ DB ' d    Rot'
	DB	'ate down 6 degrees', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@COFAJKBG@?5u?5?5?5?5Rotate?5up?56?5degrees?4?$AA@
CONST	SEGMENT
??_C@_0BL@COFAJKBG@?5u?5?5?5?5Rotate?5up?56?5degrees?4?$AA@ DB ' u    Rot'
	DB	'ate up 6 degrees.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@HANPMDCM@or?5a?5real?5value?5?$CIif?5appropriate?$DL@
CONST	SEGMENT
??_C@_0DH@HANPMDCM@or?5a?5real?5value?5?$CIif?5appropriate?$DL@ DB 'or a '
	DB	'real value (if appropriate; use a decimal point):', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@FEAJEGBF@causes?5an?5action?5and?5may?5be?5prec@
CONST	SEGMENT
??_C@_0EG@FEAJEGBF@causes?5an?5action?5and?5may?5be?5prec@ DB 'causes an '
	DB	'action and may be preceded by an integer repetition count, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@FFFEHFEE@View?5transformation?5commands?5are@
CONST	SEGMENT
??_C@_0EC@FFFEHFEE@View?5transformation?5commands?5are@ DB 'View transfor'
	DB	'mation commands are strings of letters. Each letter ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CIGPMICE@?5?5show?5facets?5where?5area?5?$DM?5?401?6?$AA@
CONST	SEGMENT
??_C@_0CA@CIGPMICE@?5?5show?5facets?5where?5area?5?$DM?5?401?6?$AA@ DB ' '
	DB	' show facets where area < .01', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NAPCNACO@?5?5list?5vertices?5where?5x?$FO2?5?$CL?5y?$FO2?5@
CONST	SEGMENT
??_C@_0CF@NAPCNACO@?5?5list?5vertices?5where?5x?$FO2?5?$CL?5y?$FO2?5@ DB ' '
	DB	' list vertices where x^2 + y^2 > 1', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@JDDIPCIA@?5?5set?5facet?5color?5green?5where?5or@
CONST	SEGMENT
??_C@_0DO@JDDIPCIA@?5?5set?5facet?5color?5green?5where?5or@ DB '  set fac'
	DB	'et color green where original == 1 or original == 2', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MLLLADNG@?5?5refine?5edges?5where?5not?5fixed?5a@
CONST	SEGMENT
??_C@_0DB@MLLLADNG@?5?5refine?5edges?5where?5not?5fixed?5a@ DB '  refine '
	DB	'edges where not fixed and length > .23', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FEPCDCJH@?5?5list?5edges?5?$HM?5?$CCmore?$CC?$DL?5list?5topi@
CONST	SEGMENT
??_C@_0DE@FEPCDCJH@?5?5list?5edges?5?$HM?5?$CCmore?$CC?$DL?5list?5topi@ DB ' '
	DB	' list edges | "more"; list topinfo >>> "topstuff"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DEFBLCOP@Examples?5of?5the?5full?5command?5lan@
CONST	SEGMENT
??_C@_0CI@DEFBLCOP@Examples?5of?5the?5full?5command?5lan@ DB 'Examples of'
	DB	' the full command language:', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@HHMJJDFL@?5lightblue?0lightgreen?0lightred?0l@
CONST	SEGMENT
??_C@_0EF@HHMJJDFL@?5lightblue?0lightgreen?0lightred?0l@ DB ' lightblue,l'
	DB	'ightgreen,lightred,lightcyan,lightmagenta,yellow,white.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@MNCAIDKL@Colors?3?5black?0red?0green?0blue?0cya@
CONST	SEGMENT
??_C@_0EF@MNCAIDKL@Colors?3?5black?0red?0green?0blue?0cya@ DB 'Colors: bl'
	DB	'ack,red,green,blue,cyan,magenta,brown,darkgray,lightgray,', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@GPDLKFAA@Operators?3?5?$CL?0?9?0?$CK?0?1?0?$FOn?0?$CK?$CK?0?$DN?$DN?0?$CB?$DN?0?$DO@
CONST	SEGMENT
??_C@_0DO@GPDLKFAA@Operators?3?5?$CL?0?9?0?$CK?0?1?0?$FOn?0?$CK?$CK?0?$DN?$DN?0?$CB?$DN?0?$DO@ DB 'O'
	DB	'perators: +,-,*,/,^n,**,==,!=,>,<,>=,<=,NOT,!,AND,&&,OR,||.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_help_strings DD FLAT:??_C@_0BP@CCEHJHBL@?5A?5?5Set?5adjustable?5parameters?4?$AA@
	DD	FLAT:??_C@_0CD@LIMCJAJG@?5b?5?5Set?5body?5volumes?5or?5pressure@
	DD	FLAT:??_C@_0BM@EHCCEILG@?5C?5?5Run?5consistency?5checks?4?$AA@
	DD	FLAT:??_C@_0BO@MNINPCFK@?5c?5?5Report?5count?5of?5elements?4?$AA@
	DD	FLAT:??_C@_0CE@CDECDEIN@?5D?5?5Toggle?5display?5every?5iterati@
	DD	FLAT:??_C@_0BO@KIDNKDLC@?5d?5?5Dump?5surface?5to?5datafile?4?$AA@
	DD	FLAT:??_C@_0BB@INBHLNHO@?5G?5?5Set?5gravity?4?$AA@
	DD	FLAT:??_C@_0BO@FADDDHKK@?5g?5nnn?5?5?5?5?5Go?5nnn?5iterations?4?$AA@
	DD	FLAT:??_C@_0BJ@JPMLBABO@?5H?0h?0?$DP?5This?5help?5screen?4?$AA@
	DD	FLAT:??_C@_0BL@KAMMIDCI@?5i?5?5Information?5on?5status?4?$AA@
	DD	FLAT:??_C@_0BK@PMOOCDPI@?5l?5?5Subdivide?5long?5edges?4?$AA@
	DD	FLAT:??_C@_0BP@CBPNFLLI@?5m?5?5Toggle?5fixed?5motion?5scale?4?$AA@
	DD	FLAT:??_C@_0CF@NLEHHDBF@?5P?5?5Graphics?5display?5file?0?5geomv@
	DD	FLAT:??_C@_0O@KOBJOFGP@?5q?0x?5?5?5?5Exit?4?$AA@
	DD	FLAT:??_C@_0BK@IBBMFEML@?5r?5?5Refine?5triangulation?4?$AA@
	DD	FLAT:??_C@_0BO@HGOOCIFF@?5s?5?5Built?9in?5screen?5graphics?4?$AA@
	DD	FLAT:??_C@_0BH@IDKMGEPF@?5t?5?5Remove?5tiny?5edges?4?$AA@
	DD	FLAT:??_C@_0CG@CLCKPGMC@?5U?5?5Toggle?5conjugate?5gradient?5me@
	DD	FLAT:??_C@_0BC@ELJCEIPM@?5u?5?5Equiangulate?4?$AA@
	DD	FLAT:??_C@_0BG@DALGOAJA@?5V?5?5Vertex?5averaging?4?$AA@
	DD	FLAT:??_C@_0BE@OFDLFKFO@?5v?5?5Report?5volumes?4?$AA@
	DD	FLAT:??_C@_0BO@FOCBMIDB@?5w?5?5Weed?5out?5small?5triangles?4?$AA@
_qhelp	DD	FLAT:??_C@_01EEMJAFIK@?6?$AA@
	DD	FLAT:??_C@_0DO@GPDLKFAA@Operators?3?5?$CL?0?9?0?$CK?0?1?0?$FOn?0?$CK?$CK?0?$DN?$DN?0?$CB?$DN?0?$DO@
	DD	FLAT:??_C@_0EF@MNCAIDKL@Colors?3?5black?0red?0green?0blue?0cya@
	DD	FLAT:??_C@_0EF@HHMJJDFL@?5lightblue?0lightgreen?0lightred?0l@
	DD	FLAT:??_C@_0CI@DEFBLCOP@Examples?5of?5the?5full?5command?5lan@
	DD	FLAT:??_C@_0DE@FEPCDCJH@?5?5list?5edges?5?$HM?5?$CCmore?$CC?$DL?5list?5topi@
	DD	FLAT:??_C@_0DB@MLLLADNG@?5?5refine?5edges?5where?5not?5fixed?5a@
	DD	FLAT:??_C@_0DO@JDDIPCIA@?5?5set?5facet?5color?5green?5where?5or@
	DD	FLAT:??_C@_0CF@NAPCNACO@?5?5list?5vertices?5where?5x?$FO2?5?$CL?5y?$FO2?5@
	DD	FLAT:??_C@_0CA@CIGPMICE@?5?5show?5facets?5where?5area?5?$DM?5?401?6?$AA@
	DD	FLAT:??_C@_01EEMJAFIK@?6?$AA@
	DD	00H
_ghelp_strings DD FLAT:??_C@_0EC@FFFEHFEE@View?5transformation?5commands?5are@
	DD	FLAT:??_C@_0EG@FEAJEGBF@causes?5an?5action?5and?5may?5be?5prec@
	DD	FLAT:??_C@_0DH@HANPMDCM@or?5a?5real?5value?5?$CIif?5appropriate?$DL@
	DD	FLAT:??_C@_0BL@COFAJKBG@?5u?5?5?5?5Rotate?5up?56?5degrees?4?$AA@
	DD	FLAT:??_C@_0BM@NAIGJLGJ@?5d?5?5?5?5Rotate?5down?56?5degrees?$AA@
	DD	FLAT:??_C@_0BO@DGLCHNOL@?5r?5?5?5?5Rotate?5right?56?5degrees?4?$AA@
	DD	FLAT:??_C@_0BN@FDOPEBBM@?5l?5?5?5?5Rotate?5left?56?5degrees?4?$AA@
	DD	FLAT:??_C@_0CC@ELFGICMB@?5c?5?5?5?5Rotate?5clockwise?56?5degrees@
	DD	FLAT:??_C@_0CJ@FLOLGKMO@?5C?5?5?5?5Rotate?5counterclockwise?56?5@
	DD	FLAT:??_C@_0BN@EGIAPNCD@?5z?5?5?5?5Zoom?5by?5factor?5of?51?42?4?$AA@
	DD	FLAT:??_C@_0BP@GPJNBCKH@?5s?5?5?5?5Shrink?5by?5factor?5of?51?42?4?$AA@
	DD	FLAT:??_C@_0BP@GFOENCPO@?5arrow?5keys?5?9?5Translate?5image?4?$AA@
	DD	FLAT:??_C@_0BE@GODBGHA@?5m?5?5?5?5Center?5image?4?$AA@
	DD	FLAT:??_C@_0CA@JLFEIPBH@?5R?5?5?5?5Reset?5viewing?5parameters?4?$AA@
	DD	FLAT:??_C@_0CM@IDBCPEOJ@?5T?5?5?5?5Toggle?5additional?5viewing?5@
	DD	FLAT:??_C@_0CB@PNCFIKED@?5e?5?5?5?5Toggle?5facet?5edge?5drawing?4@
	DD	FLAT:??_C@_0CJ@EOGPKHIE@?5B?5?5?5?5Toggle?5display?5of?5boundary@
	DD	FLAT:??_C@_0CI@KIIJHJHK@?5v?5?5?5?5Toggle?5ridge?5and?5valley?5co@
	DD	FLAT:??_C@_0DI@EALAPEAO@?5w?5?5?5?5Toggle?5facets?5with?5three?5v@
	DD	FLAT:??_C@_0BJ@BJJNMBPC@?5b?5?5?5?5Draw?5bounding?5box?4?$AA@
	DD	FLAT:??_C@_0CG@PFFLHNIP@?5?$CL?0?9?5Increment?0?5decrement?5fill?5c@
	DD	FLAT:??_C@_0CF@ONDAPFKM@?5H?5?5?5?5Toggle?5hidden?5surface?5remo@
	DD	FLAT:??_C@_0CD@HGCHLFGM@?5t?5?5?5?5Set?5clipping?5mode?5for?5toru@
	DD	FLAT:??_C@_0BJ@GACCJADA@?5?$DP?0h?5help?5?$CIthis?5display?$CJ?$AA@
	DD	FLAT:??_C@_0BI@KCJEPLLJ@?5x?0q?5Exit?5to?5main?5menu?4?$AA@
_text_help_file DD FLAT:??_C@_0L@PNDFAEDB@evhelp?4txt?$AA@
_name	DB	'name="', 00H
	ORG $+93
_DATA	ENDS
;	COMDAT ??_C@_0BO@FOCBMIDB@?5w?5?5Weed?5out?5small?5triangles?4?$AA@
CONST	SEGMENT
??_C@_0BO@FOCBMIDB@?5w?5?5Weed?5out?5small?5triangles?4?$AA@ DB ' w  Weed'
	DB	' out small triangles.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OFDLFKFO@?5v?5?5Report?5volumes?4?$AA@
CONST	SEGMENT
??_C@_0BE@OFDLFKFO@?5v?5?5Report?5volumes?4?$AA@ DB ' v  Report volumes.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DALGOAJA@?5V?5?5Vertex?5averaging?4?$AA@
CONST	SEGMENT
??_C@_0BG@DALGOAJA@?5V?5?5Vertex?5averaging?4?$AA@ DB ' V  Vertex averagi'
	DB	'ng.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ELJCEIPM@?5u?5?5Equiangulate?4?$AA@
CONST	SEGMENT
??_C@_0BC@ELJCEIPM@?5u?5?5Equiangulate?4?$AA@ DB ' u  Equiangulate.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CLCKPGMC@?5U?5?5Toggle?5conjugate?5gradient?5me@
CONST	SEGMENT
??_C@_0CG@CLCKPGMC@?5U?5?5Toggle?5conjugate?5gradient?5me@ DB ' U  Toggle'
	DB	' conjugate gradient method.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IDKMGEPF@?5t?5?5Remove?5tiny?5edges?4?$AA@
CONST	SEGMENT
??_C@_0BH@IDKMGEPF@?5t?5?5Remove?5tiny?5edges?4?$AA@ DB ' t  Remove tiny '
	DB	'edges.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HGOOCIFF@?5s?5?5Built?9in?5screen?5graphics?4?$AA@
CONST	SEGMENT
??_C@_0BO@HGOOCIFF@?5s?5?5Built?9in?5screen?5graphics?4?$AA@ DB ' s  Buil'
	DB	't-in screen graphics.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IBBMFEML@?5r?5?5Refine?5triangulation?4?$AA@
CONST	SEGMENT
??_C@_0BK@IBBMFEML@?5r?5?5Refine?5triangulation?4?$AA@ DB ' r  Refine tri'
	DB	'angulation.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KOBJOFGP@?5q?0x?5?5?5?5Exit?4?$AA@
CONST	SEGMENT
??_C@_0O@KOBJOFGP@?5q?0x?5?5?5?5Exit?4?$AA@ DB ' q,x    Exit.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NLEHHDBF@?5P?5?5Graphics?5display?5file?0?5geomv@
CONST	SEGMENT
??_C@_0CF@NLEHHDBF@?5P?5?5Graphics?5display?5file?0?5geomv@ DB ' P  Graph'
	DB	'ics display file, geomview.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CBPNFLLI@?5m?5?5Toggle?5fixed?5motion?5scale?4?$AA@
CONST	SEGMENT
??_C@_0BP@CBPNFLLI@?5m?5?5Toggle?5fixed?5motion?5scale?4?$AA@ DB ' m  Tog'
	DB	'gle fixed motion scale.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PMOOCDPI@?5l?5?5Subdivide?5long?5edges?4?$AA@
CONST	SEGMENT
??_C@_0BK@PMOOCDPI@?5l?5?5Subdivide?5long?5edges?4?$AA@ DB ' l  Subdivide'
	DB	' long edges.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KAMMIDCI@?5i?5?5Information?5on?5status?4?$AA@
CONST	SEGMENT
??_C@_0BL@KAMMIDCI@?5i?5?5Information?5on?5status?4?$AA@ DB ' i  Informat'
	DB	'ion on status.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JPMLBABO@?5H?0h?0?$DP?5This?5help?5screen?4?$AA@
CONST	SEGMENT
??_C@_0BJ@JPMLBABO@?5H?0h?0?$DP?5This?5help?5screen?4?$AA@ DB ' H,h,? Thi'
	DB	's help screen.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FADDDHKK@?5g?5nnn?5?5?5?5?5Go?5nnn?5iterations?4?$AA@
CONST	SEGMENT
??_C@_0BO@FADDDHKK@?5g?5nnn?5?5?5?5?5Go?5nnn?5iterations?4?$AA@ DB ' g nn'
	DB	'n     Go nnn iterations.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@INBHLNHO@?5G?5?5Set?5gravity?4?$AA@
CONST	SEGMENT
??_C@_0BB@INBHLNHO@?5G?5?5Set?5gravity?4?$AA@ DB ' G  Set gravity.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KIDNKDLC@?5d?5?5Dump?5surface?5to?5datafile?4?$AA@
CONST	SEGMENT
??_C@_0BO@KIDNKDLC@?5d?5?5Dump?5surface?5to?5datafile?4?$AA@ DB ' d  Dump'
	DB	' surface to datafile.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CDECDEIN@?5D?5?5Toggle?5display?5every?5iterati@
CONST	SEGMENT
??_C@_0CE@CDECDEIN@?5D?5?5Toggle?5display?5every?5iterati@ DB ' D  Toggle'
	DB	' display every iteration.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MNINPCFK@?5c?5?5Report?5count?5of?5elements?4?$AA@
CONST	SEGMENT
??_C@_0BO@MNINPCFK@?5c?5?5Report?5count?5of?5elements?4?$AA@ DB ' c  Repo'
	DB	'rt count of elements.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EHCCEILG@?5C?5?5Run?5consistency?5checks?4?$AA@
CONST	SEGMENT
??_C@_0BM@EHCCEILG@?5C?5?5Run?5consistency?5checks?4?$AA@ DB ' C  Run con'
	DB	'sistency checks.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LIMCJAJG@?5b?5?5Set?5body?5volumes?5or?5pressure@
CONST	SEGMENT
??_C@_0CD@LIMCJAJG@?5b?5?5Set?5body?5volumes?5or?5pressure@ DB ' b  Set b'
	DB	'ody volumes or pressures.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CCEHJHBL@?5A?5?5Set?5adjustable?5parameters?4?$AA@
CONST	SEGMENT
??_C@_0BP@CCEHJHBL@?5A?5?5Set?5adjustable?5parameters?4?$AA@ DB ' A  Set '
	DB	'adjustable parameters.', 00H		; `string'
CONST	ENDS
PUBLIC	??_C@_09BEJBMNJP@?$CF?938?438s?6?$AA@		; `string'
PUBLIC	??_C@_09HLPKABLH@?$CF?938?438s?5?$AA@		; `string'
PUBLIC	??_C@_0CE@OLFIKCNG@?6Some?5common?5one?9letter?5commands@ ; `string'
PUBLIC	??_C@_0CM@HGBLGIB@Use?5quotes?5around?5your?5topic?5if?5@ ; `string'
PUBLIC	??_C@_0DI@MJIBNGPJ@give?5a?5list?5of?5help?5topics?5conta@ ; `string'
PUBLIC	??_C@_0DH@GOGCLKHK@?6For?5detailed?5help?0?5use?5?$CChelp?5to@ ; `string'
PUBLIC	_main_help
EXTRN	_sprintf:PROC
EXTRN	_msg:DWORD
EXTRN	_outstring:PROC
;	COMDAT ??_C@_09BEJBMNJP@?$CF?938?438s?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\help.c
CONST	SEGMENT
??_C@_09BEJBMNJP@?$CF?938?438s?6?$AA@ DB '%-38.38s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HLPKABLH@?$CF?938?438s?5?$AA@
CONST	SEGMENT
??_C@_09HLPKABLH@?$CF?938?438s?5?$AA@ DB '%-38.38s ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OLFIKCNG@?6Some?5common?5one?9letter?5commands@
CONST	SEGMENT
??_C@_0CE@OLFIKCNG@?6Some?5common?5one?9letter?5commands@ DB 0aH, 'Some c'
	DB	'ommon one-letter commands: ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HGBLGIB@Use?5quotes?5around?5your?5topic?5if?5@
CONST	SEGMENT
??_C@_0CM@HGBLGIB@Use?5quotes?5around?5your?5topic?5if?5@ DB 'Use quotes '
	DB	'around your topic if necessary.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MJIBNGPJ@give?5a?5list?5of?5help?5topics?5conta@
CONST	SEGMENT
??_C@_0DI@MJIBNGPJ@give?5a?5list?5of?5help?5topics?5conta@ DB 'give a lis'
	DB	't of help topics containing your topic word.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@GOGCLKHK@?6For?5detailed?5help?0?5use?5?$CChelp?5to@
CONST	SEGMENT
??_C@_0DH@GOGCLKHK@?6For?5detailed?5help?0?5use?5?$CChelp?5to@ DB 0aH, 'F'
	DB	'or detailed help, use "help topic".  This will also', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _main_help
_TEXT	SEGMENT
_main_help PROC						; COMDAT

; 74   : {

	push	esi

; 75   :   int n = sizeof(help_strings)/sizeof(char *);
; 76   :   int i,j;
; 77   : 
; 78   :   outstring("\nFor detailed help, use \"help topic\".  This will also\n");

	push	OFFSET ??_C@_0DH@GOGCLKHK@?6For?5detailed?5help?0?5use?5?$CChelp?5to@
	call	_outstring

; 79   :   outstring("give a list of help topics containing your topic word.\n");

	push	OFFSET ??_C@_0DI@MJIBNGPJ@give?5a?5list?5of?5help?5topics?5conta@
	call	_outstring

; 80   :   outstring("Use quotes around your topic if necessary.\n");

	push	OFFSET ??_C@_0CM@HGBLGIB@Use?5quotes?5around?5your?5topic?5if?5@
	call	_outstring

; 81   :   outstring("\nSome common one-letter commands: \n");

	push	OFFSET ??_C@_0CE@OLFIKCNG@?6Some?5common?5one?9letter?5commands@
	call	_outstring
	add	esp, 16					; 00000010H

; 82   :   for ( i = 0, j = (n+1)/2 ; i < (n+1)/2 ; i++,j++ )

	xor	esi, esi
	npad	2
$LL8@main_help:

; 83   :      { sprintf(msg,"%-38.38s ",help_strings[i]);

	mov	eax, DWORD PTR _help_strings[esi*4]
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_09HLPKABLH@?$CF?938?438s?5?$AA@
	push	ecx
	call	_sprintf

; 84   :         outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 85   :         if ( j < n )

	lea	eax, DWORD PTR [esi+11]
	add	esp, 16					; 00000010H
	cmp	eax, 22					; 00000016H
	jge	SHORT $LN5@main_help

; 86   :           sprintf(msg,"%-38.38s\n",help_strings[j]);

	mov	ecx, DWORD PTR _help_strings[esi*4+44]
	mov	edx, DWORD PTR _msg
	push	ecx
	push	OFFSET ??_C@_09BEJBMNJP@?$CF?938?438s?6?$AA@
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN4@main_help
$LN5@main_help:

; 87   :         else sprintf(msg,"\n");

	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	push	eax
	call	_sprintf
	add	esp, 8
$LN4@main_help:

; 88   :         outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	inc	esi
	add	esp, 4
	cmp	esi, 11					; 0000000bH
	jl	SHORT $LL8@main_help

; 89   :      }
; 90   : 
; 91   : #ifdef NOPIPE
; 92   :   /* fake `more' */
; 93   :   for ( i = 0 ; qhelp[i] ; )
; 94   :   {  outstring("Hit RETURN for more.");
; 95   :       getstring(msg,msgmax);
; 96   :       for ( j = 0 ; qhelp[i] && (j<23) ; i++,j++ )
; 97   :          outstring(qhelp[i]);
; 98   :   }
; 99   : #else
; 100  :   for ( i = 0 ; qhelp[i] ; i++ )

	mov	eax, DWORD PTR _qhelp
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN1@main_help
$LL3@main_help:

; 101  :      outstring(qhelp[i]);

	push	eax
	call	_outstring
	mov	eax, DWORD PTR _qhelp[esi*4+4]
	inc	esi
	add	esp, 4
	test	eax, eax
	jne	SHORT $LL3@main_help
$LN1@main_help:
	pop	esi

; 102  : #endif
; 103  : } // end main_help()

	ret	0
_main_help ENDP
_TEXT	ENDS
PUBLIC	_graph_help
; Function compile flags: /Ogtp
;	COMDAT _graph_help
_TEXT	SEGMENT
_graph_help PROC					; COMDAT

; 142  : {

	push	esi

; 143  :   int n = sizeof(ghelp_strings)/sizeof(char *);
; 144  :   int i;
; 145  : 
; 146  :   for ( i = 0 ; i < n ; i++ )

	mov	esi, OFFSET _ghelp_strings
$LL3@graph_help:

; 147  :      { outstring(ghelp_strings[i]); outstring("\n"); }

	mov	eax, DWORD PTR [esi]
	push	eax
	call	_outstring
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring
	add	esi, 4
	add	esp, 8
	cmp	esi, OFFSET _ghelp_strings+100
	jl	SHORT $LL3@graph_help
	pop	esi

; 148  : 
; 149  : } // end graph_help()

	ret	0
_graph_help ENDP
_TEXT	ENDS
PUBLIC	??_C@_05LDHOCHGG@quot?$DL?$AA@			; `string'
PUBLIC	??_C@_04DMIAPOKJ@amp?$DL?$AA@			; `string'
PUBLIC	??_C@_03BHAAMAON@gt?$DL?$AA@			; `string'
PUBLIC	??_C@_03MAABEHOM@lt?$DL?$AA@			; `string'
PUBLIC	_printbuff
EXTRN	_kb_strnicmp:PROC
EXTRN	_strchr:PROC
_BSS	SEGMENT
_pre_flag DD	01H DUP (?)
_buff	DB	07530H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_05LDHOCHGG@quot?$DL?$AA@
CONST	SEGMENT
??_C@_05LDHOCHGG@quot?$DL?$AA@ DB 'quot;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DMIAPOKJ@amp?$DL?$AA@
CONST	SEGMENT
??_C@_04DMIAPOKJ@amp?$DL?$AA@ DB 'amp;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BHAAMAON@gt?$DL?$AA@
CONST	SEGMENT
??_C@_03BHAAMAON@gt?$DL?$AA@ DB 'gt;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MAABEHOM@lt?$DL?$AA@
CONST	SEGMENT
??_C@_03MAABEHOM@lt?$DL?$AA@ DB 'lt;', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _printbuff
_TEXT	SEGMENT
_printbuff PROC						; COMDAT

; 166  :   /* do HTML special characters */
; 167  :   if ( buff[0] == 0 ) return;

	cmp	BYTE PTR _buff, 0
	je	$LN39@printbuff

; 168  :   spot = buff;
; 169  :   while ( (spot = strchr(spot,'&')) != NULL )

	push	ebx
	push	esi
	push	edi
	push	38					; 00000026H
	push	OFFSET _buff
	call	_strchr
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	je	$LN36@printbuff
	npad	7
$LL37@printbuff:

; 170  :   { s = spot + 1;
; 171  :      if ( kb_strnicmp(spot+1,"lt;",3) == 0 ) { *spot = '<'; s = spot+4; }

	push	3
	lea	edi, DWORD PTR [esi+1]
	push	OFFSET ??_C@_03MAABEHOM@lt?$DL?$AA@
	push	edi
	mov	ebx, edi
	call	_kb_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN35@printbuff
	mov	BYTE PTR [esi], 60			; 0000003cH
	lea	ebx, DWORD PTR [esi+4]
$LN35@printbuff:

; 172  :      if ( kb_strnicmp(spot+1,"gt;",3) == 0 ) { *spot = '>'; s = spot+4; }

	push	3
	push	OFFSET ??_C@_03BHAAMAON@gt?$DL?$AA@
	push	edi
	call	_kb_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN34@printbuff
	mov	BYTE PTR [esi], 62			; 0000003eH
	lea	ebx, DWORD PTR [esi+4]
$LN34@printbuff:

; 173  :      if ( kb_strnicmp(spot+1,"amp;",4) == 0 ) { *spot = '&'; s = spot+5; }

	push	4
	push	OFFSET ??_C@_04DMIAPOKJ@amp?$DL?$AA@
	push	edi
	call	_kb_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN33@printbuff
	mov	BYTE PTR [esi], 38			; 00000026H
	lea	ebx, DWORD PTR [esi+5]
$LN33@printbuff:

; 174  :      if ( kb_strnicmp(spot+1,"quot;",5) == 0 ) { *spot = '"'; s = spot+6; }

	push	5
	push	OFFSET ??_C@_05LDHOCHGG@quot?$DL?$AA@
	push	edi
	call	_kb_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN32@printbuff
	mov	BYTE PTR [esi], 34			; 00000022H
	lea	ebx, DWORD PTR [esi+6]
$LN32@printbuff:

; 175  :      for ( d = spot+1 ; *s ; s++,d++ ) *d = *s;

	mov	cl, BYTE PTR [ebx]
	mov	eax, edi
	test	cl, cl
	je	SHORT $LN29@printbuff
	sub	ebx, edi
$LL31@printbuff:
	mov	BYTE PTR [eax], cl
	mov	cl, BYTE PTR [ebx+eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL31@printbuff
$LN29@printbuff:

; 168  :   spot = buff;
; 169  :   while ( (spot = strchr(spot,'&')) != NULL )

	push	38					; 00000026H
	push	edi

; 176  :      *d = 0;

	mov	BYTE PTR [eax], 0
	call	_strchr
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	$LL37@printbuff
$LN36@printbuff:

; 177  :      spot++;
; 178  :   }
; 179  :   if ( pre_flag ) { outstring(buff); outstring("\n"); }

	cmp	DWORD PTR _pre_flag, 0
	je	SHORT $LN58@printbuff
	push	OFFSET _buff
	call	_outstring
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring
	add	esp, 8
	pop	edi
	pop	esi

; 216  :      }
; 217  :   }
; 218  :   buff[0] = 0;

	mov	BYTE PTR _buff, 0
	pop	ebx

; 219  : 
; 220  : } // end printbuff()

	ret	0
$LN58@printbuff:

; 180  :   else
; 181  :   { char *cur;  /* cursor */
; 182  :      char *b; /* searching for blank */
; 183  : 
; 184  :      char *src,*dest;
; 185  : 
; 186  :      /* compress whitespace */
; 187  :      if ( pre_flag == 0 )
; 188  :      {
; 189  :         for ( src = buff; *src ; src++ ) if ( *src == '\t' ) *src = ' ';

	mov	cl, BYTE PTR _buff
	mov	eax, OFFSET _buff
	mov	bl, 32					; 00000020H
	test	cl, cl
	je	SHORT $LN23@printbuff
$LL25@printbuff:
	cmp	BYTE PTR [eax], 9
	jne	SHORT $LN24@printbuff
	mov	BYTE PTR [eax], bl
$LN24@printbuff:
	inc	eax
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL25@printbuff
	mov	cl, BYTE PTR _buff
$LN23@printbuff:

; 190  :         src = buff; while ( *src == ' ' ) src++ ;

	mov	eax, OFFSET _buff
	cmp	cl, bl
	jne	SHORT $LN20@printbuff
$LL21@printbuff:
	inc	eax
	cmp	BYTE PTR [eax], bl
	je	SHORT $LL21@printbuff
$LN20@printbuff:

; 191  :         for ( dest = buff, src = buff; *src ; src++ )

	mov	edi, OFFSET _buff
	mov	eax, edi
	test	cl, cl
	je	SHORT $LN17@printbuff
$LL19@printbuff:

; 192  :         { if ( (*src == ' ') && (dest[-1] == ' ') ) continue;

	mov	cl, BYTE PTR [eax]
	cmp	cl, bl
	jne	SHORT $LN16@printbuff
	cmp	BYTE PTR [edi-1], bl
	je	SHORT $LN18@printbuff
$LN16@printbuff:

; 193  :           else *(dest++) = *src;

	mov	BYTE PTR [edi], cl
	inc	edi
$LN18@printbuff:

; 191  :         for ( dest = buff, src = buff; *src ; src++ )

	inc	eax
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL19@printbuff
$LN17@printbuff:

; 194  :         }
; 195  :      } else dest = buff + strlen(buff);
; 196  :      *dest = 0; dest[1] = 0;

	mov	WORD PTR [edi], 0

; 197  : 
; 198  :      /* print lines */
; 199  :      for ( cur = buff; *cur ; cur = b+1 )

	cmp	BYTE PTR _buff, 0
	mov	eax, OFFSET _buff
	je	SHORT $LN11@printbuff
	npad	7
$LL13@printbuff:

; 200  :      { /* first, scan for newline */ 
; 201  :         for ( b = cur; *b && (b < cur+LINESIZE) ; b++ )

	cmp	BYTE PTR [eax], 0
	mov	esi, eax
	je	SHORT $LN49@printbuff
	lea	ecx, DWORD PTR [eax+75]
	npad	6
$LL10@printbuff:
	cmp	esi, ecx
	jae	SHORT $LN49@printbuff

; 202  :           if ( *b == '\n' ) break;

	cmp	BYTE PTR [esi], 10			; 0000000aH
	je	SHORT $LN1@printbuff

; 200  :      { /* first, scan for newline */ 
; 201  :         for ( b = cur; *b && (b < cur+LINESIZE) ; b++ )

	inc	esi
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LL10@printbuff
$LN49@printbuff:

; 203  :         if ( *b == '\n' )

	cmp	BYTE PTR [esi], 10			; 0000000aH

; 204  :         { *b = 0; outstring(cur); outstring("\n"); continue; }

	je	SHORT $LN1@printbuff

; 205  : 
; 206  :         /* now get chunk small enough to fit on a line */                    
; 207  :         b = cur + LINESIZE;

	lea	esi, DWORD PTR [eax+75]

; 208  :         if ( b < dest ) 

	cmp	esi, edi
	jae	SHORT $LN5@printbuff

; 209  :         {
; 210  :           while ( (*b != ' ') && (b > cur) ) b--;

	cmp	BYTE PTR [esi], bl
	je	SHORT $LN3@printbuff
	npad	1
$LL4@printbuff:
	cmp	esi, eax
	jbe	SHORT $LN61@printbuff
	dec	esi
	cmp	BYTE PTR [esi], bl
	jne	SHORT $LL4@printbuff
$LN3@printbuff:

; 211  :           if ( b == cur ) { b = cur + LINESIZE; }

	cmp	esi, eax
$LN61@printbuff:
	jne	SHORT $LN1@printbuff
	lea	esi, DWORD PTR [eax+75]
	jmp	SHORT $LN1@printbuff
$LN5@printbuff:

; 212  :         }
; 213  :         else b = dest;

	mov	esi, edi
$LN1@printbuff:

; 214  :         *b = 0;
; 215  :         outstring(cur); outstring("\n");

	push	eax
	mov	BYTE PTR [esi], 0
	call	_outstring
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring
	lea	eax, DWORD PTR [esi+1]
	add	esp, 8
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL13@printbuff
$LN11@printbuff:
	pop	edi
	pop	esi

; 216  :      }
; 217  :   }
; 218  :   buff[0] = 0;

	mov	BYTE PTR _buff, 0
	pop	ebx
$LN39@printbuff:

; 219  : 
; 220  : } // end printbuff()

	ret	0
_printbuff ENDP
_TEXT	ENDS
PUBLIC	??_C@_02EOEPPNBF@tr?$AA@			; `string'
PUBLIC	??_C@_04FOIMDDHH@?1pre?$AA@			; `string'
PUBLIC	??_C@_03PKHLKDKD@pre?$AA@			; `string'
PUBLIC	??_C@_03KAHMNINM@?1dl?$AA@			; `string'
PUBLIC	??_C@_03KMCJDHDN@?1ol?$AA@			; `string'
PUBLIC	??_C@_03LNJIBBJL@?1ul?$AA@			; `string'
PUBLIC	??_C@_02JLMMKIPN@ul?$AA@			; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_C@_02EOPBOLLC@dd?$AA@			; `string'
PUBLIC	??_C@_02EDDPJOD@dt?$AA@				; `string'
PUBLIC	??_C@_02LLMPMKNF@?$DO?5?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_02PFEMMEEH@li?$AA@			; `string'
PUBLIC	??_C@_02JOILMGJP@?1h?$AA@			; `string'
PUBLIC	??_C@_01JBBJJEPG@p?$AA@				; `string'
PUBLIC	??_C@_01JKBOJNNK@?$FO?$AA@			; `string'
PUBLIC	??_C@_03NKDEPMNM@sup?$AA@			; `string'
PUBLIC	??_C@_01IDAFKMJL@_?$AA@				; `string'
PUBLIC	??_C@_03KCMAIMAP@sub?$AA@			; `string'
PUBLIC	??_C@_02FGOECCNH@br?$AA@			; `string'
PUBLIC	_do_line
EXTRN	_kb_stricmp:PROC
_BSS	SEGMENT
_ul_level DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_02EOEPPNBF@tr?$AA@
CONST	SEGMENT
??_C@_02EOEPPNBF@tr?$AA@ DB 'tr', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FOIMDDHH@?1pre?$AA@
CONST	SEGMENT
??_C@_04FOIMDDHH@?1pre?$AA@ DB '/pre', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PKHLKDKD@pre?$AA@
CONST	SEGMENT
??_C@_03PKHLKDKD@pre?$AA@ DB 'pre', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KAHMNINM@?1dl?$AA@
CONST	SEGMENT
??_C@_03KAHMNINM@?1dl?$AA@ DB '/dl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KMCJDHDN@?1ol?$AA@
CONST	SEGMENT
??_C@_03KMCJDHDN@?1ol?$AA@ DB '/ol', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LNJIBBJL@?1ul?$AA@
CONST	SEGMENT
??_C@_03LNJIBBJL@?1ul?$AA@ DB '/ul', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JLMMKIPN@ul?$AA@
CONST	SEGMENT
??_C@_02JLMMKIPN@ul?$AA@ DB 'ul', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EOPBOLLC@dd?$AA@
CONST	SEGMENT
??_C@_02EOPBOLLC@dd?$AA@ DB 'dd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EDDPJOD@dt?$AA@
CONST	SEGMENT
??_C@_02EDDPJOD@dt?$AA@ DB 'dt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LLMPMKNF@?$DO?5?$AA@
CONST	SEGMENT
??_C@_02LLMPMKNF@?$DO?5?$AA@ DB '> ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PFEMMEEH@li?$AA@
CONST	SEGMENT
??_C@_02PFEMMEEH@li?$AA@ DB 'li', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JOILMGJP@?1h?$AA@
CONST	SEGMENT
??_C@_02JOILMGJP@?1h?$AA@ DB '/h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JBBJJEPG@p?$AA@
CONST	SEGMENT
??_C@_01JBBJJEPG@p?$AA@ DB 'p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JKBOJNNK@?$FO?$AA@
CONST	SEGMENT
??_C@_01JKBOJNNK@?$FO?$AA@ DB '^', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NKDEPMNM@sup?$AA@
CONST	SEGMENT
??_C@_03NKDEPMNM@sup?$AA@ DB 'sup', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IDAFKMJL@_?$AA@
CONST	SEGMENT
??_C@_01IDAFKMJL@_?$AA@ DB '_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCMAIMAP@sub?$AA@
CONST	SEGMENT
??_C@_03KCMAIMAP@sub?$AA@ DB 'sub', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGOECCNH@br?$AA@
CONST	SEGMENT
??_C@_02FGOECCNH@br?$AA@ DB 'br', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _do_line
_TEXT	SEGMENT
_b$ = 8							; size = 4
_line$ = 8						; size = 4
_do_line PROC						; COMDAT

; 233  : { 

	push	ebp
	mov	ebp, esp
	push	edi

; 234  :   char *spot,*c,*b,*bb;
; 235  : 
; 236  :   spot = line; 

	mov	edi, DWORD PTR _line$[ebp]
	push	ebx
	push	esi
	npad	7
$LL44@do_line:

; 237  :   do
; 238  :   { 
; 239  :      b = strchr(spot,'<'); 

	push	60					; 0000003cH
	push	edi
	call	_strchr
	mov	ebx, eax
	add	esp, 8

; 240  :      if ( b ) 

	test	ebx, ebx
	je	SHORT $LN65@do_line

; 241  :      { bb = strchr(b+1,'>');

	lea	esi, DWORD PTR [ebx+1]
	push	62					; 0000003eH
	push	esi
	call	_strchr
	add	esp, 8

; 242  :         if ( bb == NULL ) b = NULL;

	test	eax, eax
	jne	SHORT $LN40@do_line
	xor	ebx, ebx
	jmp	SHORT $LN65@do_line
$LN40@do_line:

; 243  :         else if ( pre_flag && b[1] == ' ' ) b = NULL;  /* inequality sign */

	cmp	DWORD PTR _pre_flag, 0
	je	SHORT $LN38@do_line
	cmp	BYTE PTR [esi], 32			; 00000020H
	jne	SHORT $LN38@do_line
	xor	ebx, ebx
	jmp	SHORT $LN65@do_line
$LN38@do_line:

; 244  :         else *b = 0;

	mov	BYTE PTR [ebx], 0
$LN65@do_line:

; 245  :      }
; 246  :      strcat(buff,spot);

	mov	eax, edi
	mov	esi, edi
$LL51@do_line:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL51@do_line
	mov	edi, OFFSET _buff
	sub	eax, esi
	dec	edi
	npad	1
$LL52@do_line:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL52@do_line
	mov	ecx, eax
	shr	ecx, 2
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb

; 247  :      if ( b == NULL ) break;

	test	ebx, ebx
	je	$LN42@do_line

; 248  :      spot = b + 1;

	lea	esi, DWORD PTR [ebx+1]

; 249  :      b = strchr(spot,'>'); 

	push	62					; 0000003eH
	push	esi
	call	_strchr
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _b$[ebp], ebx

; 250  :      if ( b ) 

	test	ebx, ebx
	je	SHORT $LN35@do_line

; 251  :        *b = 0;

	mov	BYTE PTR [ebx], 0
$LN35@do_line:

; 252  :      c = strchr(spot,' ');

	push	32					; 00000020H
	push	esi
	call	_strchr
	add	esp, 8

; 253  :      if ( c ) *c = 0;

	test	eax, eax
	je	SHORT $LN34@do_line
	mov	BYTE PTR [eax], 0
$LN34@do_line:

; 254  :      if ( kb_stricmp(spot,"br") == 0 ) printbuff();

	push	OFFSET ??_C@_02FGOECCNH@br?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	$LN68@do_line

; 255  :      else if (kb_stricmp(spot,"sub") == 0 ) {strcat(buff,"_"); }

	push	OFFSET ??_C@_03KCMAIMAP@sub?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN31@do_line
	mov	edi, OFFSET _buff
	dec	edi
$LL53@do_line:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL53@do_line
	mov	ax, WORD PTR ??_C@_01IDAFKMJL@_?$AA@
	mov	WORD PTR [edi], ax
	jmp	$LN66@do_line
$LN31@do_line:

; 256  :      else if (kb_stricmp(spot,"sup") == 0 ) {strcat(buff,"^"); }

	push	OFFSET ??_C@_03NKDEPMNM@sup?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN29@do_line
	mov	edi, OFFSET _buff
	dec	edi
$LL54@do_line:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL54@do_line
	mov	cx, WORD PTR ??_C@_01JKBOJNNK@?$FO?$AA@
	mov	WORD PTR [edi], cx
	jmp	$LN66@do_line
$LN29@do_line:

; 257  :      else if (kb_stricmp(spot,"p") == 0 ) {strcat(buff,"\n"); printbuff();}

	push	OFFSET ??_C@_01JBBJJEPG@p?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN27@do_line
	mov	edi, OFFSET _buff
	dec	edi
$LL55@do_line:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL55@do_line
	mov	dx, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@
	mov	WORD PTR [edi], dx
	jmp	$LN68@do_line
$LN27@do_line:

; 258  :      else if (kb_strnicmp(spot,"/h",2) == 0 ) {strcat(buff,"\n"); printbuff();}

	push	2
	push	OFFSET ??_C@_02JOILMGJP@?1h?$AA@
	push	esi
	call	_kb_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@do_line
	mov	edi, OFFSET _buff
	dec	edi
$LL56@do_line:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL56@do_line
	mov	ax, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@
	mov	WORD PTR [edi], ax
	jmp	$LN68@do_line
$LN25@do_line:

; 259  :      else if (kb_stricmp(spot,"li") == 0 ) 

	push	OFFSET ??_C@_02PFEMMEEH@li?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@do_line

; 260  :      { int n; 
; 261  :        printbuff(); 

	call	_printbuff

; 262  :        strcat(buff,"  "); 

	mov	eax, OFFSET _buff
	dec	eax
	npad	7
$LL57@do_line:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL57@do_line
	mov	cx, WORD PTR ??_C@_02KNHHEEKP@?5?5?$AA@
	mov	dl, BYTE PTR ??_C@_02KNHHEEKP@?5?5?$AA@+2
	mov	WORD PTR [eax], cx
	mov	BYTE PTR [eax+2], dl

; 263  :        for ( n = 0 ; n < ul_level ; n++ ) 

	mov	eax, DWORD PTR _ul_level
	test	eax, eax
	jle	$LN66@do_line

; 260  :      { int n; 
; 261  :        printbuff(); 

	mov	bl, BYTE PTR ??_C@_02LLMPMKNF@?$DO?5?$AA@+2
	mov	si, WORD PTR ??_C@_02LLMPMKNF@?$DO?5?$AA@
	mov	edx, eax
$LL22@do_line:

; 264  :          strcat(buff,"> ");

	mov	eax, OFFSET _buff
	dec	eax
	npad	3
$LL58@do_line:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL58@do_line
	dec	edx
	mov	WORD PTR [eax], si
	mov	BYTE PTR [eax+2], bl
	jne	SHORT $LL22@do_line

; 265  :      }
; 266  :      else if (kb_stricmp(spot,"dt") == 0 ) {printbuff();}

	mov	ebx, DWORD PTR _b$[ebp]
	jmp	$LN66@do_line
$LN23@do_line:
	push	OFFSET ??_C@_02EDDPJOD@dt?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	$LN68@do_line

; 267  :      else if (kb_stricmp(spot,"dd") == 0 ) {strcat(buff,": ");}

	push	OFFSET ??_C@_02EOPBOLLC@dd?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@do_line
	mov	eax, OFFSET _buff
	dec	eax
$LL59@do_line:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL59@do_line
	mov	cx, WORD PTR ??_C@_02LMMGGCAJ@?3?5?$AA@
	mov	dl, BYTE PTR ??_C@_02LMMGGCAJ@?3?5?$AA@+2
	mov	WORD PTR [eax], cx
	mov	BYTE PTR [eax+2], dl
	jmp	$LN66@do_line
$LN16@do_line:

; 268  :      else if (kb_stricmp(spot,"ul") == 0 ) {ul_level++;}

	push	OFFSET ??_C@_02JLMMKIPN@ul?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@do_line
	inc	DWORD PTR _ul_level
	jmp	$LN66@do_line
$LN14@do_line:

; 269  :      else if (kb_stricmp(spot,"/ul") == 0 ) 

	push	OFFSET ??_C@_03LNJIBBJL@?1ul?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@do_line

; 270  :          {ul_level--; strcat(buff,"\n"); printbuff();}

	dec	DWORD PTR _ul_level
	mov	edi, OFFSET _buff
	dec	edi
$LL60@do_line:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL60@do_line
	mov	ax, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@
	mov	WORD PTR [edi], ax
	jmp	$LN68@do_line
$LN12@do_line:

; 271  :      else if (kb_stricmp(spot,"/ol") == 0 ) {strcat(buff,"\n"); printbuff();}

	push	OFFSET ??_C@_03KMCJDHDN@?1ol?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@do_line
	mov	edi, OFFSET _buff
	dec	edi
$LL61@do_line:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL61@do_line
	mov	cx, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@
	mov	WORD PTR [edi], cx
	jmp	$LN68@do_line
$LN10@do_line:

; 272  :      else if (kb_stricmp(spot,"/dl") == 0 ) {strcat(buff,"\n"); printbuff();}

	push	OFFSET ??_C@_03KAHMNINM@?1dl?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@do_line
	mov	edi, OFFSET _buff
	dec	edi
	npad	1
$LL62@do_line:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL62@do_line
	mov	dx, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@
	mov	WORD PTR [edi], dx
	jmp	SHORT $LN68@do_line
$LN8@do_line:

; 273  :      else if ( kb_stricmp(spot,"pre") == 0 )

	push	OFFSET ??_C@_03PKHLKDKD@pre?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@do_line

; 274  :      { strcat(buff,"\n");

	mov	edi, OFFSET _buff
	dec	edi
	npad	4
$LL63@do_line:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL63@do_line
	mov	ax, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@
	mov	WORD PTR [edi], ax

; 275  :         printbuff();

	call	_printbuff

; 276  :         pre_flag = 1;

	mov	DWORD PTR _pre_flag, 1
	jmp	SHORT $LN66@do_line
$LN6@do_line:

; 277  :      }
; 278  :      else if ( kb_stricmp(spot,"/pre") == 0 )

	push	OFFSET ??_C@_04FOIMDDHH@?1pre?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@do_line

; 279  :      { printbuff(); pre_flag = 0; }

	call	_printbuff
	mov	DWORD PTR _pre_flag, 0
	jmp	SHORT $LN66@do_line
$LN4@do_line:

; 280  :      else if ( kb_stricmp(spot,"tr") == 0 ) printbuff();

	push	OFFSET ??_C@_02EOEPPNBF@tr?$AA@
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN66@do_line
$LN68@do_line:
	call	_printbuff
$LN66@do_line:

; 281  :      spot = b+1;
; 282  :   }
; 283  :   while ( *spot );

	cmp	BYTE PTR [ebx+1], 0
	lea	edi, DWORD PTR [ebx+1]
	jne	$LL44@do_line
$LN42@do_line:

; 284  :   if ( pre_flag ) strcat(buff,"\n");

	cmp	DWORD PTR _pre_flag, 0
	pop	esi
	pop	ebx
	je	SHORT $LN1@do_line
	mov	edi, OFFSET _buff
	dec	edi
	npad	6
$LL64@do_line:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL64@do_line
	mov	cx, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@
	mov	WORD PTR [edi], cx
$LN1@do_line:
	pop	edi

; 285  : 
; 286  : }  // end do_line()

	pop	ebp
	ret	0
_do_line ENDP
_TEXT	ENDS
PUBLIC	??_C@_08GGNMGCGB@?5?$CF?932s?5?6?$AA@		; `string'
PUBLIC	??_C@_0L@ILFDLNKF@?5?$CF?932s?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0BL@LEDJDIOB@Possibly?5related?5entries?3?6?$AA@ ; `string'
PUBLIC	??_C@_08HJBLBPFC@?$DMa?5name?$DN?$AA@		; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6?$AA@			; `string'
PUBLIC	??_C@_07IPJACHDE@EndName?$AA@			; `string'
PUBLIC	??_C@_05MEELDJIK@?$DM?1dd?$DO?$AA@		; `string'
PUBLIC	??_C@_02BFGPPPBE@?$DMH?$AA@			; `string'
PUBLIC	??_C@_02IAOLNLLG@?$DMh?$AA@			; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC?$AA@			; `string'
PUBLIC	??_C@_0CD@OKIHNBIK@Cannot?5find?5help?5entry?5for?5?$CC?$CFs?$CC?4@ ; `string'
PUBLIC	??_C@_0N@BEDEOLKJ@?$DMa?5name?$DN?$CCA?$CC?$DO?$AA@ ; `string'
PUBLIC	??_C@_0EB@CBDGNMAD@Cannot?5open?5index?4htm?4?5?5Are?5the?5@ ; `string'
PUBLIC	_keyword$GSCopy$
PUBLIC	??_C@_09MMLADLEF@index?4htm?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_old_html_help
EXTRN	_strtok:PROC
EXTRN	_perror:PROC
EXTRN	_l_evolver_mode:DWORD
EXTRN	_l_redirect:DWORD
EXTRN	_fclose:PROC
EXTRN	_kb_strstr:PROC
EXTRN	_fgets:PROC
EXTRN	_erroutstring:PROC
EXTRN	_path_open:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_info	DB	01770H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_08GGNMGCGB@?5?$CF?932s?5?6?$AA@
CONST	SEGMENT
??_C@_08GGNMGCGB@?5?$CF?932s?5?6?$AA@ DB ' %-32s ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ILFDLNKF@?5?$CF?932s?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0L@ILFDLNKF@?5?$CF?932s?5?$CFs?6?$AA@ DB ' %-32s %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LEDJDIOB@Possibly?5related?5entries?3?6?$AA@
CONST	SEGMENT
??_C@_0BL@LEDJDIOB@Possibly?5related?5entries?3?6?$AA@ DB 'Possibly relat'
	DB	'ed entries:', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08HJBLBPFC@?$DMa?5name?$DN?$AA@
CONST	SEGMENT
??_C@_08HJBLBPFC@?$DMa?5name?$DN?$AA@ DB '<a name=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IPJACHDE@EndName?$AA@
CONST	SEGMENT
??_C@_07IPJACHDE@EndName?$AA@ DB 'EndName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEELDJIK@?$DM?1dd?$DO?$AA@
CONST	SEGMENT
??_C@_05MEELDJIK@?$DM?1dd?$DO?$AA@ DB '</dd>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02BFGPPPBE@?$DMH?$AA@
CONST	SEGMENT
??_C@_02BFGPPPBE@?$DMH?$AA@ DB '<H', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02IAOLNLLG@?$DMh?$AA@
CONST	SEGMENT
??_C@_02IAOLNLLG@?$DMh?$AA@ DB '<h', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC?$AA@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OKIHNBIK@Cannot?5find?5help?5entry?5for?5?$CC?$CFs?$CC?4@
CONST	SEGMENT
??_C@_0CD@OKIHNBIK@Cannot?5find?5help?5entry?5for?5?$CC?$CFs?$CC?4@ DB 'C'
	DB	'annot find help entry for "%s". ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BEDEOLKJ@?$DMa?5name?$DN?$CCA?$CC?$DO?$AA@
CONST	SEGMENT
??_C@_0N@BEDEOLKJ@?$DMa?5name?$DN?$CCA?$CC?$DO?$AA@ DB '<a name="A">', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@CBDGNMAD@Cannot?5open?5index?4htm?4?5?5Are?5the?5@
CONST	SEGMENT
??_C@_0EB@CBDGNMAD@Cannot?5open?5index?4htm?4?5?5Are?5the?5@ DB 'Cannot o'
	DB	'pen index.htm.  Are the *.htm doc files on EVOLVERPATH?', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09MMLADLEF@index?4htm?$AA@
CONST	SEGMENT
??_C@_09MMLADLEF@index?4htm?$AA@ DB 'index.htm', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _old_html_help
_TEXT	SEGMENT
_linecount$ = -2024					; size = 4
_fd$ = -2020						; size = 4
_printflag$ = -2016					; size = 4
_keyword$GSCopy$ = -2012				; size = 4
_relcount$ = -2008					; size = 4
_helpfilename$ = -2004					; size = 1000
_line$ = -1004						; size = 1000
__$ArrayPad$ = -4					; size = 4
_keyword$ = 8						; size = 4
_found$ = 12						; size = 4
_old_html_help PROC					; COMDAT

; 306  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 2024				; 000007e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _keyword$[ebp]

; 307  :   int printflag = 0;

	xor	ebx, ebx
	push	edi

; 308  :   int relcount = 0;
; 309  :   int linecount = 0;
; 310  :   char helpfilename[PATHSIZE];
; 311  :   FILE *fd;
; 312  :   char line[1000];
; 313  :   int n;
; 314  : 
; 315  :   /* now check html doc files */ 
; 316  : 
; 317  :   helpfilename[0] = 0;
; 318  :   fd = path_open("index.htm",NOTDATAFILENAME);

	push	ebx
	push	OFFSET ??_C@_09MMLADLEF@index?4htm?$AA@
	mov	DWORD PTR _keyword$GSCopy$[ebp], esi
	mov	DWORD PTR _printflag$[ebp], ebx
	mov	DWORD PTR _relcount$[ebp], ebx
	mov	DWORD PTR _linecount$[ebp], ebx
	mov	BYTE PTR _helpfilename$[ebp], bl
	call	_path_open
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR _fd$[ebp], edi

; 319  :   if ( fd == NULL )

	cmp	edi, ebx
	jne	SHORT $LN40@old_html_h

; 320  :   { erroutstring(
; 321  :      "Cannot open index.htm.  Are the *.htm doc files on EVOLVERPATH?\n");

	push	OFFSET ??_C@_0EB@CBDGNMAD@Cannot?5open?5index?4htm?4?5?5Are?5the?5@
	call	_erroutstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 395  :      }
; 396  :   }
; 397  : }  // end old_html_help()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@old_html_h:

; 322  :     return; 
; 323  :   }
; 324  : 
; 325  :   /* skip header stuff */
; 326  :   while ( fgets(line,sizeof(line)-1,fd) )

	push	edi
	lea	eax, DWORD PTR _line$[ebp]
	push	999					; 000003e7H
	push	eax
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN48@old_html_h
	npad	6
$LL31@old_html_h:

; 327  :      if ( strstr(line,"<a name=\"A\">") ) break;

	lea	ecx, DWORD PTR _line$[ebp]
	push	OFFSET ??_C@_0N@BEDEOLKJ@?$DMa?5name?$DN?$CCA?$CC?$DO?$AA@
	push	ecx
	call	_kb_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN48@old_html_h

; 322  :     return; 
; 323  :   }
; 324  : 
; 325  :   /* skip header stuff */
; 326  :   while ( fgets(line,sizeof(line)-1,fd) )

	push	edi
	lea	edx, DWORD PTR _line$[ebp]
	push	999					; 000003e7H
	push	edx
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LL31@old_html_h
$LN48@old_html_h:

; 328  : 
; 329  :   while ( fgets(line,sizeof(line)-1,fd)  )

	push	edi
	lea	eax, DWORD PTR _line$[ebp]
	push	999					; 000003e7H
	push	eax
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN27@old_html_h
	mov	ebx, OFFSET _info+20
$LL28@old_html_h:

; 330  :   { char *sharp = strchr(line,'#');

	lea	ecx, DWORD PTR _line$[ebp]
	push	35					; 00000023H
	push	ecx
	call	_strchr
	mov	esi, eax
	add	esp, 8

; 331  :     if ( sharp == NULL ) continue;

	test	esi, esi
	je	$LN23@old_html_h

; 332  :     *strchr(sharp,'"') = 0;

	push	34					; 00000022H
	push	esi
	call	_strchr

; 333  :     if ( stricmp(sharp+1,keyword) == 0 )

	mov	edx, DWORD PTR _keyword$GSCopy$[ebp]
	push	edx
	lea	edi, DWORD PTR [esi+1]
	push	edi
	mov	BYTE PTR [eax], 0
	call	_kb_stricmp
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN25@old_html_h

; 334  :     { 
; 335  :       *sharp = 0;

	mov	BYTE PTR [esi], al

; 336  :       strcpy(helpfilename,strchr(line,'"')+1);

	lea	eax, DWORD PTR _line$[ebp]
	push	34					; 00000022H
	push	eax
	call	_strchr
	inc	eax
	lea	edx, DWORD PTR _helpfilename$[ebp]
	add	esp, 8
	sub	edx, eax
	npad	4
$LL35@old_html_h:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL35@old_html_h
	jmp	SHORT $LN53@old_html_h
$LN25@old_html_h:

; 337  :     }
; 338  :     else if ( strstr(sharp+1,keyword) && (relcount < RELMAX) )

	mov	ecx, DWORD PTR _keyword$GSCopy$[ebp]
	push	ecx
	push	edi
	call	_kb_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN53@old_html_h
	cmp	DWORD PTR _relcount$[ebp], 100		; 00000064H
	jge	SHORT $LN53@old_html_h

; 339  :     { strcpy(info[relcount].filename,strchr(line,'"')+1);

	lea	edx, DWORD PTR _line$[ebp]
	push	34					; 00000022H
	push	edx
	call	_strchr
	inc	eax
	mov	edx, ebx
	add	esp, 8
	sub	edx, eax
	npad	1
$LL36@old_html_h:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax-20], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL36@old_html_h

; 340  :       strcpy(info[relcount].name,sharp+1);

	mov	edx, ebx
	mov	eax, edi
	sub	edx, edi
$LL37@old_html_h:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL37@old_html_h

; 341  :       relcount++;

	inc	DWORD PTR _relcount$[ebp]
	add	ebx, 60					; 0000003cH
$LN53@old_html_h:
	mov	edi, DWORD PTR _fd$[ebp]
$LN23@old_html_h:

; 328  : 
; 329  :   while ( fgets(line,sizeof(line)-1,fd)  )

	push	edi
	lea	edx, DWORD PTR _line$[ebp]
	push	999					; 000003e7H
	push	edx
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LL28@old_html_h
	mov	esi, DWORD PTR _keyword$GSCopy$[ebp]
$LN27@old_html_h:

; 342  :     }
; 343  :   }
; 344  :   fclose(fd);

	push	edi
	call	_fclose
	add	esp, 4

; 345  :   if ( found ) goto print_related;

	cmp	DWORD PTR _found$[ebp], 0
	jne	$print_related$89625

; 346  :   if ( helpfilename[0] == 0 )

	cmp	BYTE PTR _helpfilename$[ebp], 0
	jne	SHORT $LN21@old_html_h

; 347  :   { sprintf(msg,"Cannot find help entry for \"%s\". \n", keyword);

	mov	eax, DWORD PTR _msg
	push	esi
	push	OFFSET ??_C@_0CD@OKIHNBIK@Cannot?5find?5help?5entry?5for?5?$CC?$CFs?$CC?4@
	push	eax
	call	_sprintf

; 348  :     outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H

; 349  :     goto print_related;

	jmp	$print_related$89625
$LN21@old_html_h:

; 350  :   }
; 351  : 
; 352  : 
; 353  :   fd = path_open(helpfilename,NOTDATAFILENAME);

	lea	edx, DWORD PTR _helpfilename$[ebp]
	push	0
	push	edx
	call	_path_open
	mov	ebx, eax
	add	esp, 8

; 354  :   if ( fd == NULL )

	test	ebx, ebx
	jne	SHORT $LN20@old_html_h

; 355  :   { 
; 356  : #ifdef __L_EVOLVER__
; 357  : 		   if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, eax
	jne	SHORT $LN18@old_html_h
	cmp	DWORD PTR _l_evolver_mode, eax
	jne	SHORT $LN18@old_html_h

; 359  : 		   else
; 360  : 			   perror(helpfilename);

	lea	eax, DWORD PTR _helpfilename$[ebp]
	push	eax
	call	_perror
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 395  :      }
; 396  :   }
; 397  : }  // end old_html_help()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@old_html_h:

; 358  : 			   erroutstring(helpfilename);

	lea	ecx, DWORD PTR _helpfilename$[ebp]
	push	ecx
	call	_erroutstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 395  :      }
; 396  :   }
; 397  : }  // end old_html_help()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@old_html_h:

; 361  : #else
; 362  : 		perror(helpfilename);
; 363  : #endif
; 364  :     return; 
; 365  :   }
; 366  :   ul_level = 0;
; 367  :   strcpy(name+6,keyword); strcat(name,"\"");

	mov	edx, OFFSET _name+6
	mov	DWORD PTR _ul_level, 0
	mov	eax, esi
	sub	edx, esi
$LL38@old_html_h:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL38@old_html_h
	mov	edi, OFFSET _name
	dec	edi
$LL50@old_html_h:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL50@old_html_h
	mov	dx, WORD PTR ??_C@_01BJJEKLCA@?$CC?$AA@

; 368  :   while ( fgets(line,sizeof(line)-1,fd)  )

	push	ebx
	lea	eax, DWORD PTR _line$[ebp]
	push	999					; 000003e7H
	push	eax
	mov	WORD PTR [edi], dx
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN11@old_html_h
	npad	9
$LL16@old_html_h:

; 369  :   {
; 370  :      if ( strstr(line,name) ) printflag = 1;

	lea	ecx, DWORD PTR _line$[ebp]
	push	OFFSET _name
	push	ecx
	call	_kb_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@old_html_h
	mov	DWORD PTR _printflag$[ebp], 1

; 371  :      else if ( (printflag==1) && 

	jmp	SHORT $LN55@old_html_h
$LN14@old_html_h:

; 372  :         ( ((strstr(line,"<h") || strstr(line,"<H")) && (linecount>2) )
; 373  :               || strstr(line,"</dd>") || strstr(line,"EndName") ))

	cmp	DWORD PTR _printflag$[ebp], 1
	jne	SHORT $LN55@old_html_h
	lea	edx, DWORD PTR _line$[ebp]
	push	OFFSET ??_C@_02IAOLNLLG@?$DMh?$AA@
	push	edx
	call	_kb_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@old_html_h
	lea	eax, DWORD PTR _line$[ebp]
	push	OFFSET ??_C@_02BFGPPPBE@?$DMH?$AA@
	push	eax
	call	_kb_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN54@old_html_h
$LN9@old_html_h:
	cmp	DWORD PTR _linecount$[ebp], 2
	jg	$LN11@old_html_h
$LN54@old_html_h:
	lea	ecx, DWORD PTR _line$[ebp]
	push	OFFSET ??_C@_05MEELDJIK@?$DM?1dd?$DO?$AA@
	push	ecx
	call	_kb_strstr
	add	esp, 8
	test	eax, eax
	jne	$LN11@old_html_h
	lea	edx, DWORD PTR _line$[ebp]
	push	OFFSET ??_C@_07IPJACHDE@EndName?$AA@
	push	edx
	call	_kb_strstr
	add	esp, 8
	test	eax, eax
	jne	$LN11@old_html_h
$LN55@old_html_h:

; 374  :      { break; }
; 375  : 
; 376  :      strtok(line,"\r\n"); /* remove trailing newline */

	lea	eax, DWORD PTR _line$[ebp]
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	push	eax
	call	_strtok

; 377  :      strcat(line," ");

	lea	edi, DWORD PTR _line$[ebp]
	add	esp, 8
	dec	edi
	npad	3
$LL51@old_html_h:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL51@old_html_h

; 378  :      if ( printflag )

	cmp	DWORD PTR _printflag$[ebp], 0
	mov	cx, WORD PTR ??_C@_01CLKCMJKC@?5?$AA@
	mov	WORD PTR [edi], cx
	je	SHORT $LN8@old_html_h

; 379  :      { if ( !strstr(line,"<a name=") ) linecount++; 

	lea	edx, DWORD PTR _line$[ebp]
	push	OFFSET ??_C@_08HJBLBPFC@?$DMa?5name?$DN?$AA@
	push	edx
	call	_kb_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@old_html_h
	inc	DWORD PTR _linecount$[ebp]
$LN7@old_html_h:

; 380  :         do_line(line); 

	lea	eax, DWORD PTR _line$[ebp]
	push	eax
	call	_do_line
	add	esp, 4
$LN8@old_html_h:

; 368  :   while ( fgets(line,sizeof(line)-1,fd)  )

	push	ebx
	lea	ecx, DWORD PTR _line$[ebp]
	push	999					; 000003e7H
	push	ecx
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LL16@old_html_h
$LN11@old_html_h:

; 381  :      }
; 382  :   }
; 383  :   printbuff();

	call	_printbuff

; 384  :   fclose(fd);

	push	ebx
	call	_fclose
	mov	esi, DWORD PTR _keyword$GSCopy$[ebp]
	add	esp, 4
$print_related$89625:

; 385  : 
; 386  : print_related:
; 387  : 
; 388  :   if ( relcount && (strlen(keyword) > 1) )

	cmp	DWORD PTR _relcount$[ebp], 0
	je	$LN3@old_html_h
	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL52@old_html_h:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL52@old_html_h
	sub	eax, edx
	cmp	eax, 1
	jbe	SHORT $LN3@old_html_h

; 389  :   { outstring("Possibly related entries:\n");

	push	OFFSET ??_C@_0BL@LEDJDIOB@Possibly?5related?5entries?3?6?$AA@
	call	_outstring

; 390  :      for ( n = 0 ; n < relcount ; n+=2 ) 

	mov	ebx, DWORD PTR _relcount$[ebp]
	add	esp, 4
	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN3@old_html_h

; 389  :   { outstring("Possibly related entries:\n");

	dec	ebx
	mov	esi, OFFSET _info+20
	npad	3
$LL5@old_html_h:

; 391  :      { if ( n < relcount-1 )

	cmp	edi, ebx
	jge	SHORT $LN2@old_html_h

; 392  :           sprintf(msg," %-32s %s\n",info[n].name,info[n+1].name);

	mov	eax, DWORD PTR _msg
	lea	edx, DWORD PTR [esi+60]
	push	edx
	push	esi
	push	OFFSET ??_C@_0L@ILFDLNKF@?5?$CF?932s?5?$CFs?6?$AA@
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@old_html_h
$LN2@old_html_h:

; 393  :        else sprintf(msg," %-32s \n",info[n].name);

	mov	ecx, DWORD PTR _msg
	push	esi
	push	OFFSET ??_C@_08GGNMGCGB@?5?$CF?932s?5?6?$AA@
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1@old_html_h:

; 394  :        outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	edi, 2
	add	esp, 4
	add	esi, 120				; 00000078H
	cmp	edi, DWORD PTR _relcount$[ebp]
	jl	SHORT $LL5@old_html_h
$LN3@old_html_h:

; 395  :      }
; 396  :   }
; 397  : }  // end old_html_help()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_old_html_help ENDP
_TEXT	ENDS
PUBLIC	??_C@_02NEKEAGPN@?$DO?6?$AA@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
PUBLIC	??_C@_02HONKNKME@?6?$DM?$AA@			; `string'
PUBLIC	??_C@_0M@OEOCBPMH@MPI?5Evolver?$AA@		; `string'
PUBLIC	??_C@_04BPOLKFNK@?$DM?9?9?9?$AA@		; `string'
PUBLIC	??_C@_0CJ@ICDCMBEC@Is?5the?5doc?5subdirectory?5on?5EVOLV@ ; `string'
PUBLIC	_keyword$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_new_text_help
EXTRN	_strncmp:PROC
EXTRN	_kb_error:PROC
EXTRN	_kb_lower_array:BYTE
;	COMDAT ??_C@_02NEKEAGPN@?$DO?6?$AA@
CONST	SEGMENT
??_C@_02NEKEAGPN@?$DO?6?$AA@ DB '>', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HONKNKME@?6?$DM?$AA@
CONST	SEGMENT
??_C@_02HONKNKME@?6?$DM?$AA@ DB 0aH, '<', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OEOCBPMH@MPI?5Evolver?$AA@
CONST	SEGMENT
??_C@_0M@OEOCBPMH@MPI?5Evolver?$AA@ DB 'MPI Evolver', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BPOLKFNK@?$DM?9?9?9?$AA@
CONST	SEGMENT
??_C@_04BPOLKFNK@?$DM?9?9?9?$AA@ DB '<---', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@ICDCMBEC@Is?5the?5doc?5subdirectory?5on?5EVOLV@
CONST	SEGMENT
??_C@_0CJ@ICDCMBEC@Is?5the?5doc?5subdirectory?5on?5EVOLV@ DB 'Is the doc '
	DB	'subdirectory on EVOLVERPATH?', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _new_text_help
_TEXT	SEGMENT
tv747 = -2124						; size = 4
_keylen$ = -2120					; size = 4
_keyword$GSCopy$ = -2116				; size = 4
_fd$ = -2112						; size = 4
_relcount$ = -2108					; size = 4
_line_lowercase$ = -2104				; size = 1000
_line$ = -1104						; size = 1000
_keyword_lowercase$ = -104				; size = 100
__$ArrayPad$ = -4					; size = 4
_keyword$ = 8						; size = 4
_found$ = 12						; size = 4
_new_text_help PROC					; COMDAT

; 415  : { FILE *fd;

	push	ebp
	mov	ebp, esp
	sub	esp, 2128				; 00000850H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _keyword$[ebp]
	push	esi

; 416  :   int keylen = (int)strlen(keyword);

	mov	eax, ebx
	push	edi

; 483  :       
; 484  :       /* read and echo info */
; 485  :       while ( fgets(line,sizeof(line)-1,fd)  )

	mov	DWORD PTR _keyword$GSCopy$[ebp], ebx
	lea	edx, DWORD PTR [eax+1]
$LL81@new_text_h:

; 416  :   int keylen = (int)strlen(keyword);

	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL81@new_text_h
	sub	eax, edx
	mov	ecx, eax

; 417  :   char line[1000];
; 418  :   char line_lowercase[1000];  // for case-insensitive matching
; 419  :   char keyword_lowercase[100];
; 420  :   int i=0,n;

	xor	esi, esi
	mov	DWORD PTR _keylen$[ebp], ecx

; 421  :   int relcount = 0;

	mov	DWORD PTR _relcount$[ebp], esi

; 422  : 
; 423  :   if ( keylen == 1 )

	cmp	ecx, 1
	jne	SHORT $LN54@new_text_h

; 424  :   { keyword_lowercase[0] = keyword[0];

	mov	al, BYTE PTR [ebx]
	mov	BYTE PTR _keyword_lowercase$[ebp], al

; 425  :   }
; 426  :   else

	jmp	SHORT $LN50@new_text_h
$LN54@new_text_h:

; 427  :   {
; 428  :     for ( i = 0 ; i < keylen ; i++ )

	cmp	ecx, esi
	jle	SHORT $LN50@new_text_h
	mov	eax, ebx
	lea	edx, DWORD PTR _keyword_lowercase$[ebp]
	sub	eax, edx
	npad	12
$LL52@new_text_h:
	lea	edx, DWORD PTR [eax+esi]

; 429  :       keyword_lowercase[i] = tolower(keyword[i]);

	movsx	edx, BYTE PTR _keyword_lowercase$[ebp+edx]
	mov	dl, BYTE PTR _kb_lower_array[edx]
	mov	BYTE PTR _keyword_lowercase$[ebp+esi], dl
	inc	esi
	cmp	esi, ecx
	jl	SHORT $LL52@new_text_h
$LN50@new_text_h:

; 430  :   }
; 431  :   keyword_lowercase[keylen] = 0;
; 432  : 
; 433  :   /* now check text doc file */ 
; 434  : 
; 435  :   fd = path_open(text_help_file,NOTDATAFILENAME);

	mov	eax, DWORD PTR _text_help_file
	push	0
	push	eax
	mov	BYTE PTR _keyword_lowercase$[ebp+ecx], 0
	call	_path_open
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR _fd$[ebp], edi

; 436  :   if ( fd == NULL )

	test	edi, edi
	jne	SHORT $LN63@new_text_h

; 437  :   { 
; 438  : #ifdef __L_EVOLVER__
; 439  : 		   if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, eax
	jne	SHORT $LN47@new_text_h
	cmp	DWORD PTR _l_evolver_mode, eax
	jne	SHORT $LN47@new_text_h

; 441  : 		   else
; 442  : 			   perror(text_help_file);

	mov	ecx, DWORD PTR _text_help_file
	push	ecx
	call	_perror
	jmp	SHORT $LN90@new_text_h
$LN47@new_text_h:

; 440  : 			   erroutstring(text_help_file);

	mov	edx, DWORD PTR _text_help_file
	push	edx
	call	_erroutstring
$LN90@new_text_h:
	add	esp, 4

; 443  : #else
; 444  : 		perror(text_help_file);
; 445  : #endif
; 446  :     kb_error(1902,"Is the doc subdirectory on EVOLVERPATH?\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CJ@ICDCMBEC@Is?5the?5doc?5subdirectory?5on?5EVOLV@
	push	1902					; 0000076eH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 447  :     return 0; 

	xor	eax, eax
	pop	ebx

; 554  :   return 1;
; 555  : } // end new_text_help()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@new_text_h:

; 448  :   }
; 449  : 
; 450  :   /* Find keyword in  <--- keyword ---> line */
; 451  :   while ( fgets(line,sizeof(line)-1,fd)  )

	push	edi
	lea	eax, DWORD PTR _line$[ebp]
	push	999					; 000003e7H
	push	eax
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN84@new_text_h
	mov	DWORD PTR tv747[ebp], 0
$LL45@new_text_h:

; 452  :   { char *keyspot,*c,*cc;
; 453  :     if ( strncmp(line,"<---",4) != 0 ) continue;

	push	4
	lea	ecx, DWORD PTR _line$[ebp]
	push	OFFSET ??_C@_04BPOLKFNK@?$DM?9?9?9?$AA@
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN19@new_text_h

; 454  : #ifndef MPI_EVOLVER
; 455  :     if ( strstr(line,"MPI Evolver") )

	lea	edx, DWORD PTR _line$[ebp]
	push	OFFSET ??_C@_0M@OEOCBPMH@MPI?5Evolver?$AA@
	push	edx
	call	_kb_strstr
	add	esp, 8
	test	eax, eax
	jne	$LN19@new_text_h

; 456  :       continue;
; 457  : #endif
; 458  : 
; 459  : 
; 460  :     for ( c = line, cc = line_lowercase ; *c ; c++,cc++ ) 

	mov	cl, BYTE PTR _line$[ebp]
	lea	eax, DWORD PTR _line_lowercase$[ebp]
	test	cl, cl
	je	SHORT $LN39@new_text_h
	mov	edi, eax
	lea	edx, DWORD PTR _line$[ebp]
	sub	edx, edi
	mov	edi, DWORD PTR _keylen$[ebp]
	npad	3
$LL41@new_text_h:

; 461  :       *cc = (keylen == 1) ? *c : tolower(*c);

	movsx	ecx, cl
	cmp	edi, 1
	je	SHORT $LN58@new_text_h
	movsx	ecx, BYTE PTR _kb_lower_array[ecx]
$LN58@new_text_h:
	mov	BYTE PTR [eax], cl
	mov	cl, BYTE PTR [edx+eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL41@new_text_h
$LN39@new_text_h:

; 462  :     *cc = 0;
; 463  : 
; 464  :     keyspot = strstr(line_lowercase,keyword_lowercase);

	lea	edx, DWORD PTR _keyword_lowercase$[ebp]
	mov	BYTE PTR [eax], 0
	push	edx
	lea	eax, DWORD PTR _line_lowercase$[ebp]
	push	eax
	call	_kb_strstr
	add	esp, 8

; 465  :     if ( keyspot == NULL ) continue;

	test	eax, eax
	je	$LN19@new_text_h

; 466  : 
; 467  :     if ( (keyspot[-2] == '-') && (keyspot[keylen+1] == '-') )

	cmp	BYTE PTR [eax-2], 45			; 0000002dH
	jne	$LN83@new_text_h
	mov	ecx, DWORD PTR _keylen$[ebp]
	cmp	BYTE PTR [eax+ecx+1], 45		; 0000002dH
	jne	$LN83@new_text_h

; 469  :       int blanklines = 0;
; 470  :       /* found exact match */
; 471  :       found = 1;   
; 472  : 
; 473  :       /* print nice title bar */
; 474  :       outstring("\n<");

	push	OFFSET ??_C@_02HONKNKME@?6?$DM?$AA@
	xor	ebx, ebx
	mov	DWORD PTR _found$[ebp], 1
	call	_outstring

; 475  :       for ( i = 1 ; i < (70 - keylen)/2 ; i++ )

	mov	edi, DWORD PTR _keylen$[ebp]
	mov	eax, 70					; 00000046H
	sub	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esp, 4
	cmp	eax, 1
	jle	SHORT $LN34@new_text_h

; 468  :     { int lines_done = 0;

	lea	esi, DWORD PTR [eax-1]
$LL36@new_text_h:

; 476  :         outstring("-");

	push	OFFSET ??_C@_01JOAMLHOP@?9?$AA@
	call	_outstring
	add	esp, 4
	dec	esi
	jne	SHORT $LL36@new_text_h
$LN34@new_text_h:

; 477  :       outstring(" ");

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	call	_outstring

; 478  :       outstring(keyword);

	mov	edx, DWORD PTR _keyword$GSCopy$[ebp]
	push	edx
	call	_outstring

; 479  :       outstring(" ");

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	call	_outstring

; 480  :       for ( i = (70 + keylen)/2 ; i < 70 ;  i++ )

	lea	eax, DWORD PTR [edi+70]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	add	esp, 12					; 0000000cH
	cmp	esi, 70					; 00000046H
	jge	SHORT $LN31@new_text_h

; 477  :       outstring(" ");

	mov	edi, 70					; 00000046H
	sub	edi, esi

; 480  :       for ( i = (70 + keylen)/2 ; i < 70 ;  i++ )

	add	esi, edi
	npad	2
$LL33@new_text_h:

; 481  :         outstring("-");

	push	OFFSET ??_C@_01JOAMLHOP@?9?$AA@
	call	_outstring
	add	esp, 4
	dec	edi
	jne	SHORT $LL33@new_text_h
$LN31@new_text_h:

; 482  :       outstring(">\n");

	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6?$AA@
	call	_outstring

; 483  :       
; 484  :       /* read and echo info */
; 485  :       while ( fgets(line,sizeof(line)-1,fd)  )

	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _line$[ebp]
	push	999					; 000003e7H
	push	ecx
	call	_fgets
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN83@new_text_h
	mov	edi, ebx
	npad	5
$LL30@new_text_h:

; 486  :       { if ( line[0] != '<' )       

	mov	cl, BYTE PTR _line$[ebp]
	cmp	cl, 60					; 0000003cH
	je	SHORT $LN28@new_text_h

; 487  :         { if ( line[1] == 0 )

	cmp	BYTE PTR _line$[ebp+1], 0
	jne	SHORT $LN27@new_text_h

; 488  :           { blanklines++;

	inc	ebx

; 489  :             if ( blanklines < 2 )

	cmp	ebx, 2
	jge	SHORT $LN25@new_text_h

; 490  :                outstring(line);

	lea	edx, DWORD PTR _line$[ebp]
	push	edx
	call	_outstring
	add	esp, 4

; 495  :           }
; 496  :           lines_done++;

	inc	edi

; 497  :         }
; 498  :         else 

	jmp	SHORT $LN23@new_text_h
$LN27@new_text_h:

; 491  :           }
; 492  :           else 
; 493  :           { outstring(line);

	lea	eax, DWORD PTR _line$[ebp]
	push	eax
	call	_outstring
	add	esp, 4

; 494  :             blanklines = 0;

	xor	ebx, ebx
$LN25@new_text_h:

; 495  :           }
; 496  :           lines_done++;

	inc	edi

; 497  :         }
; 498  :         else 

	jmp	SHORT $LN23@new_text_h
$LN28@new_text_h:

; 499  :         { /* skip if just extra title */
; 500  :           if ( lines_done > 0 )

	test	edi, edi
	jg	SHORT $LN87@new_text_h
$LN23@new_text_h:

; 483  :       
; 484  :       /* read and echo info */
; 485  :       while ( fgets(line,sizeof(line)-1,fd)  )

	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	lea	edx, DWORD PTR _line$[ebp]
	push	999					; 000003e7H
	push	edx
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LL30@new_text_h
$LN83@new_text_h:
	mov	cl, BYTE PTR _line$[ebp]
$LN87@new_text_h:

; 501  :              break;
; 502  :         }        
; 503  :       }
; 504  : 
; 505  :       /* next title line falls through to relevance recording */
; 506  :     }
; 507  :     
; 508  :     for ( c = line, cc = line_lowercase ; *c ; c++,cc++ ) 

	lea	eax, DWORD PTR _line_lowercase$[ebp]
	test	cl, cl
	je	SHORT $LN88@new_text_h
	lea	edx, DWORD PTR _line$[ebp]
	mov	edi, eax
	sub	edx, edi
	npad	3
$LL22@new_text_h:

; 509  :       *cc = tolower(*c);

	movsx	ecx, cl
	movzx	ecx, BYTE PTR _kb_lower_array[ecx]
	mov	BYTE PTR [eax], cl
	mov	cl, BYTE PTR [edx+eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL22@new_text_h
$LN88@new_text_h:

; 510  :     *cc = 0;
; 511  : 
; 512  :     if ( strstr(line_lowercase,keyword_lowercase) && (relcount < RELMAX) )

	lea	edx, DWORD PTR _keyword_lowercase$[ebp]
	mov	BYTE PTR [eax], 0
	push	edx
	lea	eax, DWORD PTR _line_lowercase$[ebp]
	push	eax
	call	_kb_strstr
	add	esp, 8
	test	eax, eax
	je	$LN19@new_text_h
	cmp	DWORD PTR _relcount$[ebp], 100		; 00000064H
	jge	$LN19@new_text_h

; 513  :     { char *spot = strchr(line,' '); 

	lea	ecx, DWORD PTR _line$[ebp]
	push	32					; 00000020H
	push	ecx
	call	_strchr
	add	esp, 8

; 514  :       int spaceflag = 0;

	xor	edx, edx

; 515  :       if ( spot )

	test	eax, eax
	je	$LN85@new_text_h

; 516  :          for ( spot++, i = 0 ; *spot && !(((spot[0] == ' ')||(spot[0] == '-')) && (spot[1] == '-')) ; spot++, i++ )

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	xor	esi, esi
	test	cl, cl
	je	$LN85@new_text_h
	mov	edi, DWORD PTR tv747[ebp]
	npad	1
$LL17@new_text_h:
	cmp	cl, 32					; 00000020H
	je	SHORT $LN13@new_text_h
	cmp	cl, 45					; 0000002dH
	jne	SHORT $LN14@new_text_h
$LN13@new_text_h:
	cmp	BYTE PTR [eax+1], 45			; 0000002dH
	je	SHORT $LN15@new_text_h
$LN14@new_text_h:

; 517  :          { info[relcount].name[i] = *spot;

	mov	BYTE PTR _info[edi+esi+20], cl

; 518  :            if ( *spot == ' ' ) 

	cmp	BYTE PTR [eax], 32			; 00000020H
	jne	SHORT $LN16@new_text_h

; 519  :              spaceflag = 1;

	mov	edx, 1
$LN16@new_text_h:

; 516  :          for ( spot++, i = 0 ; *spot && !(((spot[0] == ' ')||(spot[0] == '-')) && (spot[1] == '-')) ; spot++, i++ )

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	inc	esi
	test	cl, cl
	jne	SHORT $LL17@new_text_h
$LN15@new_text_h:

; 520  :          }
; 521  :       if ( spaceflag ) /* enclose in quotes */

	test	edx, edx
	je	SHORT $LN11@new_text_h

; 522  :       { char c;
; 523  :         c = info[relcount].name[0];

	mov	cl, BYTE PTR _info[edi+20]

; 524  :         info[relcount].name[0] = '"';
; 525  :         for ( n = 1 ; n < i ; n++ )

	mov	eax, 1
	mov	BYTE PTR _info[edi+20], 34		; 00000022H
	cmp	esi, eax
	jle	SHORT $LN8@new_text_h
	npad	12
$LL10@new_text_h:

; 526  :         { char cc = info[relcount].name[n];

	mov	dl, BYTE PTR _info[edi+eax+20]

; 527  :           info[relcount].name[n] = c;

	mov	BYTE PTR _info[edi+eax+20], cl
	inc	eax

; 528  :           c = cc;

	mov	cl, dl
	cmp	eax, esi
	jl	SHORT $LL10@new_text_h
$LN8@new_text_h:

; 529  :         }
; 530  :         info[relcount].name[i] = c;

	mov	BYTE PTR _info[edi+esi+20], cl

; 531  :         info[relcount].name[i+1] = '"';

	mov	BYTE PTR _info[edi+esi+21], 34		; 00000022H

; 532  :         i += 2;

	add	esi, 2
	jmp	SHORT $LN11@new_text_h
$LN85@new_text_h:
	mov	edi, DWORD PTR tv747[ebp]
$LN11@new_text_h:

; 533  :       }
; 534  :       info[relcount].name[i] = 0;
; 535  :       relcount++;

	inc	DWORD PTR _relcount$[ebp]
	mov	BYTE PTR _info[edi+esi+20], 0
	add	edi, 60					; 0000003cH
	mov	DWORD PTR tv747[ebp], edi
$LN19@new_text_h:

; 448  :   }
; 449  : 
; 450  :   /* Find keyword in  <--- keyword ---> line */
; 451  :   while ( fgets(line,sizeof(line)-1,fd)  )

	mov	edx, DWORD PTR _fd$[ebp]
	push	edx
	lea	eax, DWORD PTR _line$[ebp]
	push	999					; 000003e7H
	push	eax
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LL45@new_text_h
	mov	edi, DWORD PTR _fd$[ebp]
	mov	ebx, DWORD PTR _keyword$GSCopy$[ebp]
$LN84@new_text_h:

; 536  :     }
; 537  :   }
; 538  :   fclose(fd);

	push	edi
	call	_fclose
	add	esp, 4

; 539  :   if ( !found ) 

	cmp	DWORD PTR _found$[ebp], 0
	jne	SHORT $LN7@new_text_h

; 540  :   { sprintf(msg,"Cannot find help entry for \"%s\". \n", keyword);

	mov	ecx, DWORD PTR _msg
	push	ebx
	push	OFFSET ??_C@_0CD@OKIHNBIK@Cannot?5find?5help?5entry?5for?5?$CC?$CFs?$CC?4@
	push	ecx
	call	_sprintf

; 541  :     outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN7@new_text_h:

; 542  :   }
; 543  : 
; 544  :   if ( relcount && (strlen(keyword) > 1) )

	cmp	DWORD PTR _relcount$[ebp], 0
	je	$LN3@new_text_h
	mov	eax, DWORD PTR _keyword$GSCopy$[ebp]
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL82@new_text_h:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL82@new_text_h
	sub	eax, edx
	cmp	eax, 1
	jbe	SHORT $LN3@new_text_h

; 545  :   { outstring("Possibly related entries:\n");

	push	OFFSET ??_C@_0BL@LEDJDIOB@Possibly?5related?5entries?3?6?$AA@
	call	_outstring

; 546  :     for ( n = 0 ; n < relcount ; n+=2 ) 

	mov	ebx, DWORD PTR _relcount$[ebp]
	add	esp, 4
	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN3@new_text_h

; 545  :   { outstring("Possibly related entries:\n");

	mov	esi, OFFSET _info+20
	npad	4
$LL5@new_text_h:

; 547  :      { if ( n < relcount-1 )

	lea	eax, DWORD PTR [ebx-1]
	cmp	edi, eax
	jge	SHORT $LN2@new_text_h

; 548  :           sprintf(msg," %-32s %s\n",info[n].name,info[n+1].name);

	mov	ecx, DWORD PTR _msg
	lea	eax, DWORD PTR [esi+60]
	push	eax
	push	esi
	push	OFFSET ??_C@_0L@ILFDLNKF@?5?$CF?932s?5?$CFs?6?$AA@
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@new_text_h
$LN2@new_text_h:

; 549  :        else sprintf(msg," %-32s \n",info[n].name);

	mov	edx, DWORD PTR _msg
	push	esi
	push	OFFSET ??_C@_08GGNMGCGB@?5?$CF?932s?5?6?$AA@
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1@new_text_h:

; 550  :        outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	edi, 2
	add	esp, 4
	add	esi, 120				; 00000078H
	cmp	edi, ebx
	jl	SHORT $LL5@new_text_h
$LN3@new_text_h:

; 551  :      }
; 552  :   }
; 553  :   fclose(fd);

	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	_fclose

; 554  :   return 1;
; 555  : } // end new_text_help()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 4
	pop	edi
	pop	esi
	xor	ecx, ebp
	mov	eax, 1
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_new_text_help ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@ECBDIBPA@Help?5by?5error?5number?5not?5availab@ ; `string'
PUBLIC	_error_help
;	COMDAT ??_C@_0CF@ECBDIBPA@Help?5by?5error?5number?5not?5availab@
CONST	SEGMENT
??_C@_0CF@ECBDIBPA@Help?5by?5error?5number?5not?5availab@ DB 'Help by err'
	DB	'or number not available.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _error_help
_TEXT	SEGMENT
_keyword$ = 8						; size = 4
_error_help PROC					; COMDAT

; 818  :   outstring("Help by error number not available.\n");

	push	OFFSET ??_C@_0CF@ECBDIBPA@Help?5by?5error?5number?5not?5availab@
	call	_outstring
	pop	ecx

; 819  : #ifdef HAVEHLP
; 820  :   FILE *fd;
; 821  :   char line[200];
; 822  :   int errnum = atoi(keyword);
; 823  :   int flag = 0; /* if found */
; 824  : 
; 825  :   fd = path_open("error.hlp",NOTDATAFILENAME);
; 826  :   if ( fd == NULL )
; 827  :   { erroutstring("Cannot open error.hlp. Is error.hlp on EVOLVERPATH?\n");
; 828  :      return;
; 829  :   }
; 830  : 
; 831  :   while ( fgets(line,sizeof(line)-1,fd)  )
; 832  :     if ( (strncmp(line,"Error ",6) == 0) && (atoi(line+6) == errnum) )
; 833  :     { flag = 1;    break;
; 834  :     }
; 835  :   if ( flag )
; 836  :   { outstring(line);
; 837  :      while ( fgets(line,sizeof(line)-1,fd)  )
; 838  :      if ( strncmp(line,"Error ",6) == 0 )
; 839  :         break;
; 840  :      else outstring(line);
; 841  :   }
; 842  :   else kb_error(1862,"Illegal error number.\n",WARNING);
; 843  :   
; 844  :   fclose(fd);
; 845  : #endif
; 846  : } // end error_help()

	ret	0
_error_help ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@DDPJLACN@?6?$CFs?3?5reserved?5type?5name?4?6?6?$AA@ ; `string'
PUBLIC	??_C@_02PHMGELLB@?6?6?$AA@			; `string'
PUBLIC	??_C@_0M@BCFGJIHC@?5dimension?5?$AA@		; `string'
PUBLIC	??_C@_06LAMNDLOG@scalar?$AA@			; `string'
PUBLIC	??_C@_0BN@KCKIKKMB@?6?$CFs?3?5?$CFs?5attribute?0?5type?5?$CFs?0?5?$AA@ ; `string'
PUBLIC	??_C@_0DL@KOLEEAHE@?6?$CFs?3?5permanent?5user?9defined?5para@ ; `string'
PUBLIC	??_C@_0CE@HLENMJDA@?6?$CFs?3?5permanent?5internal?5variable@ ; `string'
PUBLIC	??_C@_0CE@EMGPALPA@?6?$CFs?3?5permanent?5internal?5?$CFs?5array@ ; `string'
PUBLIC	??_C@_0CP@MINGMLNL@?6?$CFs?3?5permanent?5user?9defined?5stri@ ; `string'
PUBLIC	??_C@_0DG@LKFBKHPF@?6?$CFs?3?5permanent?5user?9defined?5func@ ; `string'
PUBLIC	??_C@_0DH@NNPMACJK@?6?$CFs?3?5permanent?5user?9defined?5proc@ ; `string'
PUBLIC	??_C@_0DB@OBNKECPP@?6?$CFs?3?5user?9defined?5parameter?5?$CInum@ ; `string'
PUBLIC	??_C@_0CJ@OJMAHFLK@?6?$CFs?3?5user?9defined?5parameter?5of?5t@ ; `string'
PUBLIC	??_C@_0CJ@HAGBOHPB@?6?$CFs?3?5user?9defined?5optimizing?5par@ ; `string'
PUBLIC	??_C@_0DJ@CFLONIME@?6?$CFs?3?5user?9defined?5array?$DL?5declara@ ; `string'
PUBLIC	??_C@_03GJCOJFLC@?4?6?6?$AA@			; `string'
PUBLIC	??_C@_04KBDJOJNB@?$FL?$CFd?$FN?$AA@		; `string'
PUBLIC	??_C@_0CD@MDJKEPJP@?6?$CFs?3?5user?9defined?5array?5of?5type?5@ ; `string'
PUBLIC	??_C@_0CG@OKFMCOAL@?6?$CFs?3?5dynamic?5load?5library?5functi@ ; `string'
PUBLIC	??_C@_0CE@BJAGKIDO@?6?$CFs?3?5user?9defined?5named?5boundary@ ; `string'
PUBLIC	??_C@_0CG@KKLEFMEE@?6?$CFs?3?5user?9defined?5named?5constrai@ ; `string'
PUBLIC	??_C@_0CC@IBEGJBLE@?6?$CFs?3?5user?9defined?5named?5method?4?6@ ; `string'
PUBLIC	??_C@_0CE@JJJBLGLO@?6?$CFs?3?5user?9defined?5named?5quantity@ ; `string'
PUBLIC	??_C@_0CF@EKAJKACG@?6?$CFs?3?5user?9defined?5string?5variabl@ ; `string'
PUBLIC	??_C@_0CN@KIDDBPFA@?6?$CFs?3?5user?9defined?5function?4?5?5Pro@ ; `string'
PUBLIC	??_C@_0CO@FEADMEOP@?6?$CFs?3?5user?9defined?5procedure?4?5?5Pr@ ; `string'
PUBLIC	??_C@_0CD@JOMEIOP@?6?$CFs?3?5user?9defined?5subroutine?4?6?6?5@ ; `string'
PUBLIC	??_C@_0DK@FCLBOJDM@?6?$CFs?3?5user?9defined?5named?5method?0?5@ ; `string'
PUBLIC	??_C@_0CC@BGKHHHDJ@?6?$CFs?3?5user?9defined?5element?5name?4?6@ ; `string'
PUBLIC	??_C@_0CH@BFNDKDDK@Usage?3?5help?5keyword?5or?5help?5?$CCphr@ ; `string'
PUBLIC	??_C@_04HEMFHPJH@more?$AA@			; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	_keyword_help
EXTRN	__pclose:PROC
EXTRN	_typenames:BYTE
EXTRN	_datatype_name:BYTE
EXTRN	_list_function_proto:PROC
EXTRN	_list_procedure_proto:PROC
EXTRN	_dymem:DWORD
EXTRN	_web:BYTE
EXTRN	_localbase:DWORD
EXTRN	_gen_quant_list:DWORD
EXTRN	_meth_inst_list:DWORD
EXTRN	_lookup_global_hash:PROC
EXTRN	_symbol_lookup:PROC
EXTRN	_isdigit:PROC
EXTRN	__popen:PROC
EXTRN	_outfd:DWORD
EXTRN	___iob_func:PROC
;	COMDAT ??_C@_0BL@DDPJLACN@?6?$CFs?3?5reserved?5type?5name?4?6?6?$AA@
CONST	SEGMENT
??_C@_0BL@DDPJLACN@?6?$CFs?3?5reserved?5type?5name?4?6?6?$AA@ DB 0aH, '%s'
	DB	': reserved type name.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02PHMGELLB@?6?6?$AA@
CONST	SEGMENT
??_C@_02PHMGELLB@?6?6?$AA@ DB 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BCFGJIHC@?5dimension?5?$AA@
CONST	SEGMENT
??_C@_0M@BCFGJIHC@?5dimension?5?$AA@ DB ' dimension ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LAMNDLOG@scalar?$AA@
CONST	SEGMENT
??_C@_06LAMNDLOG@scalar?$AA@ DB 'scalar', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KCKIKKMB@?6?$CFs?3?5?$CFs?5attribute?0?5type?5?$CFs?0?5?$AA@
CONST	SEGMENT
??_C@_0BN@KCKIKKMB@?6?$CFs?3?5?$CFs?5attribute?0?5type?5?$CFs?0?5?$AA@ DB 0aH
	DB	'%s: %s attribute, type %s, ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@KOLEEAHE@?6?$CFs?3?5permanent?5user?9defined?5para@
CONST	SEGMENT
??_C@_0DL@KOLEEAHE@?6?$CFs?3?5permanent?5user?9defined?5para@ DB 0aH, '%s'
	DB	': permanent user-defined parameter (numeric variable)', 0aH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HLENMJDA@?6?$CFs?3?5permanent?5internal?5variable@
CONST	SEGMENT
??_C@_0CE@HLENMJDA@?6?$CFs?3?5permanent?5internal?5variable@ DB 0aH, '%s:'
	DB	' permanent internal variable.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EMGPALPA@?6?$CFs?3?5permanent?5internal?5?$CFs?5array@
CONST	SEGMENT
??_C@_0CE@EMGPALPA@?6?$CFs?3?5permanent?5internal?5?$CFs?5array@ DB 0aH, '%'
	DB	's: permanent internal %s array.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MINGMLNL@?6?$CFs?3?5permanent?5user?9defined?5stri@
CONST	SEGMENT
??_C@_0CP@MINGMLNL@?6?$CFs?3?5permanent?5user?9defined?5stri@ DB 0aH, '%s'
	DB	': permanent user-defined string variable.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@LKFBKHPF@?6?$CFs?3?5permanent?5user?9defined?5func@
CONST	SEGMENT
??_C@_0DG@LKFBKHPF@?6?$CFs?3?5permanent?5user?9defined?5func@ DB 0aH, '%s'
	DB	': permanent user-defined function. Prototype:', 0aH, 0aH, '  '
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@NNPMACJK@?6?$CFs?3?5permanent?5user?9defined?5proc@
CONST	SEGMENT
??_C@_0DH@NNPMACJK@?6?$CFs?3?5permanent?5user?9defined?5proc@ DB 0aH, '%s'
	DB	': permanent user-defined procedure. Prototype:', 0aH, 0aH, ' '
	DB	'  ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OBNKECPP@?6?$CFs?3?5user?9defined?5parameter?5?$CInum@
CONST	SEGMENT
??_C@_0DB@OBNKECPP@?6?$CFs?3?5user?9defined?5parameter?5?$CInum@ DB 0aH, '%'
	DB	's: user-defined parameter (numeric variable)', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OJMAHFLK@?6?$CFs?3?5user?9defined?5parameter?5of?5t@
CONST	SEGMENT
??_C@_0CJ@OJMAHFLK@?6?$CFs?3?5user?9defined?5parameter?5of?5t@ DB 0aH, '%'
	DB	's: user-defined parameter of type %s', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HAGBOHPB@?6?$CFs?3?5user?9defined?5optimizing?5par@
CONST	SEGMENT
??_C@_0CJ@HAGBOHPB@?6?$CFs?3?5user?9defined?5optimizing?5par@ DB 0aH, '%s'
	DB	': user-defined optimizing parameter', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@CFLONIME@?6?$CFs?3?5user?9defined?5array?$DL?5declara@
CONST	SEGMENT
??_C@_0DJ@CFLONIME@?6?$CFs?3?5user?9defined?5array?$DL?5declara@ DB 0aH, '%'
	DB	's: user-defined array; declaration not yet executed.', 0aH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJCOJFLC@?4?6?6?$AA@
CONST	SEGMENT
??_C@_03GJCOJFLC@?4?6?6?$AA@ DB '.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04KBDJOJNB@?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_04KBDJOJNB@?$FL?$CFd?$FN?$AA@ DB '[%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MDJKEPJP@?6?$CFs?3?5user?9defined?5array?5of?5type?5@
CONST	SEGMENT
??_C@_0CD@MDJKEPJP@?6?$CFs?3?5user?9defined?5array?5of?5type?5@ DB 0aH, '%'
	DB	's: user-defined array of type %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OKFMCOAL@?6?$CFs?3?5dynamic?5load?5library?5functi@
CONST	SEGMENT
??_C@_0CG@OKFMCOAL@?6?$CFs?3?5dynamic?5load?5library?5functi@ DB 0aH, '%s'
	DB	': dynamic load library function.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BJAGKIDO@?6?$CFs?3?5user?9defined?5named?5boundary@
CONST	SEGMENT
??_C@_0CE@BJAGKIDO@?6?$CFs?3?5user?9defined?5named?5boundary@ DB 0aH, '%s'
	DB	': user-defined named boundary.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KKLEFMEE@?6?$CFs?3?5user?9defined?5named?5constrai@
CONST	SEGMENT
??_C@_0CG@KKLEFMEE@?6?$CFs?3?5user?9defined?5named?5constrai@ DB 0aH, '%s'
	DB	': user-defined named constraint.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IBEGJBLE@?6?$CFs?3?5user?9defined?5named?5method?4?6@
CONST	SEGMENT
??_C@_0CC@IBEGJBLE@?6?$CFs?3?5user?9defined?5named?5method?4?6@ DB 0aH, '%'
	DB	's: user-defined named method.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JJJBLGLO@?6?$CFs?3?5user?9defined?5named?5quantity@
CONST	SEGMENT
??_C@_0CE@JJJBLGLO@?6?$CFs?3?5user?9defined?5named?5quantity@ DB 0aH, '%s'
	DB	': user-defined named quantity.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@EKAJKACG@?6?$CFs?3?5user?9defined?5string?5variabl@
CONST	SEGMENT
??_C@_0CF@EKAJKACG@?6?$CFs?3?5user?9defined?5string?5variabl@ DB 0aH, '%s'
	DB	': user-defined string variable.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KIDDBPFA@?6?$CFs?3?5user?9defined?5function?4?5?5Pro@
CONST	SEGMENT
??_C@_0CN@KIDDBPFA@?6?$CFs?3?5user?9defined?5function?4?5?5Pro@ DB 0aH, '%'
	DB	's: user-defined function.  Prototype:', 0aH, 0aH, '   ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FEADMEOP@?6?$CFs?3?5user?9defined?5procedure?4?5?5Pr@
CONST	SEGMENT
??_C@_0CO@FEADMEOP@?6?$CFs?3?5user?9defined?5procedure?4?5?5Pr@ DB 0aH, '%'
	DB	's: user-defined procedure.  Prototype:', 0aH, 0aH, '   ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JOMEIOP@?6?$CFs?3?5user?9defined?5subroutine?4?6?6?5@
CONST	SEGMENT
??_C@_0CD@JOMEIOP@?6?$CFs?3?5user?9defined?5subroutine?4?6?6?5@ DB 0aH, '%'
	DB	's: user-defined subroutine.', 0aH, 0aH, '   ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@FCLBOJDM@?6?$CFs?3?5user?9defined?5named?5method?0?5@
CONST	SEGMENT
??_C@_0DK@FCLBOJDM@?6?$CFs?3?5user?9defined?5named?5method?0?5@ DB 0aH, '%'
	DB	's: user-defined named method, belongs to quantity %s.', 0aH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BGKHHHDJ@?6?$CFs?3?5user?9defined?5element?5name?4?6@
CONST	SEGMENT
??_C@_0CC@BGKHHHDJ@?6?$CFs?3?5user?9defined?5element?5name?4?6@ DB 0aH, '%'
	DB	's: user-defined element name.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BFNDKDDK@Usage?3?5help?5keyword?5or?5help?5?$CCphr@
CONST	SEGMENT
??_C@_0CH@BFNDKDDK@Usage?3?5help?5keyword?5or?5help?5?$CCphr@ DB 'Usage: '
	DB	'help keyword or help "phrase" ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HEMFHPJH@more?$AA@
CONST	SEGMENT
??_C@_04HEMFHPJH@more?$AA@ DB 'more', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _keyword_help
_TEXT	SEGMENT
tv944 = -8						; size = 4
_type$ = -8						; size = 4
_found$ = -4						; size = 4
_keyword$ = 8						; size = 4
_keyword_help PROC					; COMDAT

; 565  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 566  :   int type;
; 567  :   int found = 0;

	xor	esi, esi
	push	edi
	mov	DWORD PTR _found$[ebp], esi

; 568  :   int entry;
; 569  :   int i;
; 570  :  
; 571  : #ifndef NOPIPE
; 572  :   if ( outfd == stdout )

	call	___iob_func
	add	eax, 32					; 00000020H
	cmp	DWORD PTR _outfd, eax
	jne	SHORT $LN76@keyword_he

; 573  :   { outfd = popen("more","w");

	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	OFFSET ??_C@_04HEMFHPJH@more?$AA@
	call	__popen
	add	esp, 8
	mov	DWORD PTR _outfd, eax

; 574  :     if ( outfd == NULL )

	test	eax, eax
	jne	SHORT $LN76@keyword_he

; 575  :     { 
; 576  : #ifdef __L_EVOLVER__
; 577  : 		   if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, esi
	jne	SHORT $LN74@keyword_he
	cmp	DWORD PTR _l_evolver_mode, esi
	jne	SHORT $LN74@keyword_he

; 579  : 		   else
; 580  : 			   perror("more");

	push	OFFSET ??_C@_04HEMFHPJH@more?$AA@
	call	_perror
	jmp	SHORT $LN114@keyword_he
$LN74@keyword_he:

; 578  : 			   erroutstring("more");

	push	OFFSET ??_C@_04HEMFHPJH@more?$AA@
	call	_erroutstring
$LN114@keyword_he:
	add	esp, 4

; 581  : #else
; 582  : 		perror("more");
; 583  : #endif
; 584  :       outfd = stdout;

	call	___iob_func
	add	eax, 32					; 00000020H
	mov	DWORD PTR _outfd, eax
$LN76@keyword_he:

; 585  :     }
; 586  :   }
; 587  : #endif
; 588  : 
; 589  :   if ( keyword == NULL ) 

	mov	edi, DWORD PTR _keyword$[ebp]
	test	edi, edi
	jne	SHORT $LN72@keyword_he

; 590  :   { erroutstring("Usage: help keyword or help \"phrase\" \n"); 

	push	OFFSET ??_C@_0CH@BFNDKDDK@Usage?3?5help?5keyword?5or?5help?5?$CCphr@
	call	_erroutstring
	add	esp, 4

; 591  :      goto help_exit; 

	jmp	$help_exit$89769
$LN72@keyword_he:

; 592  :   }
; 593  :   if ( isdigit(keyword[0]) ) { error_help(keyword); goto help_exit; }

	movsx	eax, BYTE PTR [edi]
	push	eax
	call	_isdigit
	add	esp, 4
	push	edi
	test	eax, eax
	je	SHORT $LN71@keyword_he
	call	_error_help
	add	esp, 4
	jmp	$help_exit$89769
$LN71@keyword_he:

; 594  : 
; 595  :   /* check for user-defined names */
; 596  : 
; 597  :   /* search symbol table */
; 598  :   if ( symbol_lookup(keyword) )

	call	_symbol_lookup
	add	esp, 4
	test	eax, eax
	je	SHORT $LN70@keyword_he

; 599  :   { sprintf(msg,"\n%s: user-defined element name.\n\n",keyword);

	mov	ecx, DWORD PTR _msg
	push	edi
	push	OFFSET ??_C@_0CC@BGKHHHDJ@?6?$CFs?3?5user?9defined?5element?5name?4?6@
	push	ecx
	call	_sprintf

; 600  :     outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H

; 601  :     found = 1;

	mov	esi, 1

; 602  :     goto help_exit;

	jmp	$help_exit$89769
$LN70@keyword_he:
	push	ebx

; 603  :   } 
; 604  : 
; 605  :   /* search parameter names */
; 606  :   entry = lookup_global_hash(keyword,0,0,HASH_LOOK);

	push	0
	push	0
	push	0
	push	edi
	call	_lookup_global_hash
	add	esp, 16					; 00000010H

; 607  :   if ( entry )

	test	eax, eax
	je	$LN67@keyword_he

; 608  :     switch   ( entry & NAMETYPEMASK )

	mov	ecx, eax
	and	ecx, -536870912				; e0000000H
	cmp	ecx, 1610612736				; 60000000H
	ja	$LN92@keyword_he
	je	$LN23@keyword_he
	cmp	ecx, 536870912				; 20000000H
	je	SHORT $LN66@keyword_he
	cmp	ecx, 1073741824				; 40000000H
	jne	$LN67@keyword_he

; 736  :       } 
; 737  :       break;
; 738  : 
; 739  :       case METHODNAME:
; 740  :       { struct method_instance *mi = METH_INSTANCE(entry & INDEXMASK);

	and	eax, 536870911				; 1fffffffH
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list
	mov	ebx, 8
	lea	edi, DWORD PTR [eax+152]
	mov	esi, edi
$LL21@keyword_he:

; 743  :         { if ( mi->quants[j] < 0 )

	cmp	DWORD PTR [esi], 0
	jl	SHORT $LN20@keyword_he

; 744  :             continue;
; 745  :           sprintf(msg,"\n%s: user-defined named method, belongs to quantity %s.\n\n",   
; 746  :             keyword, GEN_QUANT(mi->quants[0])->name);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _keyword$[ebp]
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list
	mov	edx, DWORD PTR _msg
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DK@FCLBOJDM@?6?$CFs?3?5user?9defined?5named?5method?0?5@
	push	edx
	call	_sprintf

; 747  :           outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H
$LN20@keyword_he:

; 741  :         int j;
; 742  :         for ( j = 0 ; j < MMAXQUANTS ; j++ )

	add	esi, 4
	dec	ebx
	jne	SHORT $LL21@keyword_he

; 748  :         }
; 749  :         found = 1;
; 750  :         goto help_exit;

	mov	edi, DWORD PTR _keyword$[ebp]
	lea	esi, DWORD PTR [ebx+1]
	jmp	$LN113@keyword_he
$LN66@keyword_he:

; 609  :     { 
; 610  :       case VARIABLENAME:
; 611  :       { struct global *gp = globals((entry & INDEXMASK)|EPHGLOBAL);

	mov	ecx, eax
	and	ecx, 251658240				; 0f000000H
	or	ecx, 268435456				; 10000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN80@keyword_he
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN82@keyword_he
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	mov	esi, eax
	jmp	SHORT $LN81@keyword_he
$LN82@keyword_he:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN80@keyword_he
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN81@keyword_he
$LN80@keyword_he:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax]
$LN81@keyword_he:

; 612  :         if ( gp->flags & SUBROUTINE )

	mov	eax, DWORD PTR [esi+192]
	test	al, 4
	je	SHORT $LN65@keyword_he

; 613  :         {  sprintf(msg,"\n%s: user-defined subroutine.\n\n   ",keyword);

	push	edi
	push	OFFSET ??_C@_0CD@JOMEIOP@?6?$CFs?3?5user?9defined?5subroutine?4?6?6?5@

; 614  :            outstring(msg);

	jmp	$LN122@keyword_he
$LN65@keyword_he:

; 615  :         } 
; 616  :         else if ( gp->flags & PROCEDURE_NAME )

	test	eax, 2097152				; 00200000H
	je	SHORT $LN63@keyword_he

; 617  :         {  sprintf(msg,"\n%s: user-defined procedure.  Prototype:\n\n   ",keyword);

	mov	eax, DWORD PTR _msg
	push	edi
	push	OFFSET ??_C@_0CO@FEADMEOP@?6?$CFs?3?5user?9defined?5procedure?4?5?5Pr@
	push	eax
	call	_sprintf

; 618  :            outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring

; 619  :            list_procedure_proto(gp);

	push	esi
	call	_list_procedure_proto

; 620  :            outstring("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring
	add	esp, 24					; 00000018H

; 683  :         }
; 684  :         found = 1;

	mov	esi, 1

; 685  :         goto help_exit;

	jmp	$LN113@keyword_he
$LN63@keyword_he:

; 621  :         } 
; 622  :         else if ( gp->flags & FUNCTION_NAME )

	test	eax, 1048576				; 00100000H
	je	SHORT $LN61@keyword_he

; 623  :         {  sprintf(msg,"\n%s: user-defined function.  Prototype:\n\n   ",keyword);

	mov	edx, DWORD PTR _msg
	push	edi
	push	OFFSET ??_C@_0CN@KIDDBPFA@?6?$CFs?3?5user?9defined?5function?4?5?5Pro@
	push	edx
	call	_sprintf

; 624  :            outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 625  :            list_function_proto(gp);

	push	esi
	call	_list_function_proto

; 626  :            outstring("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring
	add	esp, 24					; 00000018H

; 683  :         }
; 684  :         found = 1;

	mov	esi, 1

; 685  :         goto help_exit;

	jmp	$LN113@keyword_he
$LN61@keyword_he:

; 627  :         } 
; 628  :         else if ( gp->flags & STRINGVAL )

	test	eax, 8192				; 00002000H
	je	SHORT $LN59@keyword_he

; 629  :         {  sprintf(msg,"\n%s: user-defined string variable.\n\n",keyword);

	push	edi
	push	OFFSET ??_C@_0CF@EKAJKACG@?6?$CFs?3?5user?9defined?5string?5variabl@

; 630  :            outstring(msg);

	jmp	SHORT $LN122@keyword_he
$LN59@keyword_he:

; 631  :         } 
; 632  :         else if ( gp->flags & QUANTITY_NAME )

	test	al, al
	jns	SHORT $LN57@keyword_he

; 633  :         {  sprintf(msg,"\n%s: user-defined named quantity.\n\n",keyword);

	push	edi
	push	OFFSET ??_C@_0CE@JJJBLGLO@?6?$CFs?3?5user?9defined?5named?5quantity@

; 634  :            outstring(msg);

	jmp	SHORT $LN121@keyword_he
$LN57@keyword_he:

; 635  :         } 
; 636  :         else if ( gp->flags & METHOD_NAME )

	test	eax, 1024				; 00000400H
	je	SHORT $LN55@keyword_he

; 637  :         {  sprintf(msg,"\n%s: user-defined named method.\n\n",keyword);

	push	edi
	push	OFFSET ??_C@_0CC@IBEGJBLE@?6?$CFs?3?5user?9defined?5named?5method?4?6@

; 638  :            outstring(msg);

	jmp	$LN117@keyword_he
$LN55@keyword_he:

; 639  :         } 
; 640  :         else if ( gp->flags & CONSTRAINT_NAME )

	test	eax, 131072				; 00020000H
	je	SHORT $LN53@keyword_he

; 641  :         {  sprintf(msg,"\n%s: user-defined named constraint.\n\n",keyword);

	push	edi
	push	OFFSET ??_C@_0CG@KKLEFMEE@?6?$CFs?3?5user?9defined?5named?5constrai@
$LN122@keyword_he:
	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_sprintf

; 642  :            outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx

; 670  :             outstring(msg);

	call	_outstring
	add	esp, 16					; 00000010H

; 683  :         }
; 684  :         found = 1;

	mov	esi, 1

; 685  :         goto help_exit;

	jmp	$LN113@keyword_he
$LN53@keyword_he:

; 643  :         } 
; 644  :         else if ( gp->flags & BOUNDARY_NAME )

	test	eax, 262144				; 00040000H
	je	SHORT $LN51@keyword_he

; 645  :         {  sprintf(msg,"\n%s: user-defined named boundary.\n\n",keyword);

	push	edi
	push	OFFSET ??_C@_0CE@BJAGKIDO@?6?$CFs?3?5user?9defined?5named?5boundary@
$LN121@keyword_he:
	mov	eax, DWORD PTR _msg
	push	eax
	call	_sprintf

; 646  :            outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx

; 670  :             outstring(msg);

	call	_outstring
	add	esp, 16					; 00000010H

; 683  :         }
; 684  :         found = 1;

	mov	esi, 1

; 685  :         goto help_exit;

	jmp	$LN113@keyword_he
$LN51@keyword_he:

; 647  :         } 
; 648  :         else if ( gp->flags & DYNAMIC_LOAD_FUNC )

	test	eax, 65536				; 00010000H
	je	SHORT $LN49@keyword_he

; 649  :         {  sprintf(msg,"\n%s: dynamic load library function.\n\n",keyword);

	push	edi
	push	OFFSET ??_C@_0CG@OKFMCOAL@?6?$CFs?3?5dynamic?5load?5library?5functi@

; 650  :            outstring(msg);

	jmp	$LN117@keyword_he
$LN49@keyword_he:

; 651  :         } 
; 652  :         else if ( gp->flags & ARRAY_PARAM )

	test	eax, 2048				; 00000800H
	je	$LN47@keyword_he

; 653  :         { struct array *a = gp->attr.arrayptr;

	mov	esi, DWORD PTR [esi+168]

; 654  :           if ( a )

	test	esi, esi
	je	$LN46@keyword_he

; 655  :           { sprintf(msg,"\n%s: user-defined array of type %s",
; 656  :                      keyword,datatype_name[a->datatype]);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _datatype_name[ecx*4]
	mov	eax, DWORD PTR _msg
	push	edx
	push	edi
	push	OFFSET ??_C@_0CD@MDJKEPJP@?6?$CFs?3?5user?9defined?5array?5of?5type?5@
	push	eax
	call	_sprintf

; 657  :             outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring

; 658  :             if ( a->dim > 1 || a->sizes[0] > 1 )

	mov	eax, DWORD PTR [esi+4]
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jg	SHORT $LN112@keyword_he
	cmp	DWORD PTR [esi+24], 1
	jle	SHORT $LN41@keyword_he
$LN112@keyword_he:

; 659  :             { int i;
; 660  :               for ( i = 0 ; i < a->dim ; i++ )

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN41@keyword_he
	lea	ebx, DWORD PTR [esi+24]
$LL43@keyword_he:

; 661  :               { sprintf(msg,"[%d]",a->sizes[i]);

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR _msg
	push	edx
	push	OFFSET ??_C@_04KBDJOJNB@?$FL?$CFd?$FN?$AA@
	push	eax
	call	_sprintf

; 662  :                 outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	inc	edi
	add	esp, 16					; 00000010H
	add	ebx, 4
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL43@keyword_he
$LN41@keyword_he:

; 663  :               }
; 664  :             }
; 665  :             outstring(".\n\n");

	push	OFFSET ??_C@_03GJCOJFLC@?4?6?6?$AA@
	call	_outstring

; 666  :           }
; 667  :           else

	mov	edi, DWORD PTR _keyword$[ebp]

; 682  :           outstring(msg);

	add	esp, 4

; 683  :         }
; 684  :         found = 1;

	mov	esi, 1

; 685  :         goto help_exit;

	jmp	$LN113@keyword_he
$LN46@keyword_he:

; 668  :           { sprintf(msg,"\n%s: user-defined array; declaration not yet executed.\n\n",
; 669  :                      keyword);

	push	edi
	push	OFFSET ??_C@_0DJ@CFLONIME@?6?$CFs?3?5user?9defined?5array?$DL?5declara@
$LN117@keyword_he:
	mov	edx, DWORD PTR _msg
	push	edx
	call	_sprintf

; 670  :             outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H

; 683  :         }
; 684  :         found = 1;

	mov	esi, 1

; 685  :         goto help_exit;

	jmp	$LN113@keyword_he
$LN47@keyword_he:

; 671  :           }
; 672  :         } 
; 673  :         else 
; 674  :         { if ( gp->flags & OPTIMIZING_PARAMETER )

	test	eax, 32768				; 00008000H
	je	SHORT $LN38@keyword_he

; 675  :            sprintf(msg,"\n%s: user-defined optimizing parameter\n\n", keyword);

	push	edi
	push	OFFSET ??_C@_0CJ@HAGBOHPB@?6?$CFs?3?5user?9defined?5optimizing?5par@
	jmp	SHORT $LN116@keyword_he
$LN38@keyword_he:

; 676  :           else if ( gp->type )

	mov	esi, DWORD PTR [esi+200]
	test	esi, esi
	je	SHORT $LN36@keyword_he

; 677  :            sprintf(msg,"\n%s: user-defined parameter of type %s\n\n", keyword,
; 678  :                 datatype_name[gp->type]);

	mov	edx, DWORD PTR _datatype_name[esi*4]
	mov	eax, DWORD PTR _msg
	push	edx
	push	edi
	push	OFFSET ??_C@_0CJ@OJMAHFLK@?6?$CFs?3?5user?9defined?5parameter?5of?5t@
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 679  :           else

	jmp	SHORT $LN35@keyword_he
$LN36@keyword_he:

; 680  :            sprintf(msg,"\n%s: user-defined parameter (numeric variable)\n\n", 
; 681  :               keyword);

	push	edi
	push	OFFSET ??_C@_0DB@OBNKECPP@?6?$CFs?3?5user?9defined?5parameter?5?$CInum@
$LN116@keyword_he:
	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN35@keyword_he:

; 682  :           outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 4

; 683  :         }
; 684  :         found = 1;

	mov	esi, 1

; 685  :         goto help_exit;

	jmp	$LN113@keyword_he
$LN23@keyword_he:

; 727  :         }
; 728  :         break;
; 729  : 
; 730  :       case QUANTITYNAME:
; 731  :       { struct gen_quant *g = GEN_QUANT(entry & INDEXMASK);

	and	eax, 536870911				; 1fffffffH
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list

; 732  :         sprintf(msg,"\n%s: user-defined named quantity.\n\n",g->name);

	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0CE@JJJBLGLO@?6?$CFs?3?5user?9defined?5named?5quantity@
	push	eax
	call	_sprintf

; 733  :         outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring

; 734  :         found = 1;

	mov	esi, 1

; 735  :         goto help_exit;

	jmp	$LN119@keyword_he
$LN92@keyword_he:

; 608  :     switch   ( entry & NAMETYPEMASK )

	cmp	ecx, -2147483648			; 80000000H
	jne	$LN67@keyword_he

; 686  :       }
; 687  : 
; 688  :         break;
; 689  :       
; 690  :       case PERM_NAME:
; 691  :         { struct global *gg = globals((entry & INDEXMASK)|PERMGLOBAL);

	mov	ecx, eax
	and	ecx, 520093696				; 1f000000H
	or	ecx, 536870912				; 20000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN86@keyword_he
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN88@keyword_he
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	mov	esi, eax
	jmp	SHORT $LN87@keyword_he
$LN88@keyword_he:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN86@keyword_he
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN87@keyword_he
$LN86@keyword_he:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR [eax+ecx]
$LN87@keyword_he:

; 692  :           if ( gg->flags & (SUBROUTINE|PROCEDURE_NAME) )

	mov	eax, DWORD PTR [esi+192]
	test	eax, 2097156				; 00200004H
	je	SHORT $LN33@keyword_he

; 693  :           {  sprintf(msg,"\n%s: permanent user-defined procedure. Prototype:\n\n   ",
; 694  :                keyword);

	mov	edx, DWORD PTR _msg
	push	edi
	push	OFFSET ??_C@_0DH@NNPMACJK@?6?$CFs?3?5permanent?5user?9defined?5proc@
	push	edx
	call	_sprintf

; 695  :              outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 696  :              list_procedure_proto(gg);

	push	esi
	call	_list_procedure_proto

; 697  :              outstring("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring
	add	esp, 24					; 00000018H

; 724  :           }
; 725  :           found = 1;

	mov	esi, 1

; 726  :           goto help_exit;

	jmp	$LN113@keyword_he
$LN33@keyword_he:

; 698  :           } 
; 699  :           else if ( gg->flags & FUNCTION_NAME )

	test	eax, 1048576				; 00100000H
	je	SHORT $LN31@keyword_he

; 700  :           {  sprintf(msg,"\n%s: permanent user-defined function. Prototype:\n\n   ",
; 701  :                keyword);

	mov	ecx, DWORD PTR _msg
	push	edi
	push	OFFSET ??_C@_0DG@LKFBKHPF@?6?$CFs?3?5permanent?5user?9defined?5func@
	push	ecx
	call	_sprintf

; 702  :              outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 703  :              list_function_proto(gg);

	push	esi
	call	_list_function_proto

; 704  :              outstring("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring
	add	esp, 24					; 00000018H

; 724  :           }
; 725  :           found = 1;

	mov	esi, 1

; 726  :           goto help_exit;

	jmp	$LN113@keyword_he
$LN31@keyword_he:

; 705  :           } 
; 706  :           else if ( gg->flags & STRINGVAL )

	test	eax, 8192				; 00002000H
	je	SHORT $LN29@keyword_he

; 707  :           {  sprintf(msg,"\n%s: permanent user-defined string variable.\n\n",keyword);

	mov	eax, DWORD PTR _msg
	push	edi
	push	OFFSET ??_C@_0CP@MINGMLNL@?6?$CFs?3?5permanent?5user?9defined?5stri@
	push	eax
	call	_sprintf

; 708  :              outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx

; 723  :             outstring(msg);

	call	_outstring
	add	esp, 16					; 00000010H

; 724  :           }
; 725  :           found = 1;

	mov	esi, 1

; 726  :           goto help_exit;

	jmp	$LN113@keyword_he
$LN29@keyword_he:

; 709  :           } 
; 710  :           else if ( gg->flags & INTERNAL_NAME )

	test	eax, 4194304				; 00400000H
	je	SHORT $LN27@keyword_he

; 711  :           {  
; 712  :              if ( gg->flags & ARRAY_PARAM )

	test	eax, 2048				; 00000800H
	je	SHORT $LN26@keyword_he

; 713  :              sprintf(msg,"\n%s: permanent internal %s array.\n\n",keyword,
; 714  :                     datatype_name[gg->attr.arrayptr->datatype]);

	mov	edx, DWORD PTR [esi+168]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _datatype_name[eax*4]
	mov	edx, DWORD PTR _msg
	push	ecx
	push	edi
	push	OFFSET ??_C@_0CE@EMGPALPA@?6?$CFs?3?5permanent?5internal?5?$CFs?5array@
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN25@keyword_he
$LN26@keyword_he:

; 715  :              else sprintf(msg,"\n%s: permanent internal variable.\n\n",keyword);

	mov	eax, DWORD PTR _msg
	push	edi
	push	OFFSET ??_C@_0CE@HLENMJDA@?6?$CFs?3?5permanent?5internal?5variable@
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN25@keyword_he:

; 716  :              outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 4

; 717  :              found = 0; /* so prints out regular documentation */

	xor	esi, esi

; 718  :              goto help_exit;

	jmp	$LN113@keyword_he
$LN27@keyword_he:

; 719  :           } 
; 720  :           else 
; 721  :           { sprintf(msg,"\n%s: permanent user-defined parameter (numeric variable)\n\n",
; 722  :                keyword);

	mov	edx, DWORD PTR _msg
	push	edi
	push	OFFSET ??_C@_0DL@KOLEEAHE@?6?$CFs?3?5permanent?5user?9defined?5para@
	push	edx
	call	_sprintf

; 723  :             outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H

; 724  :           }
; 725  :           found = 1;

	mov	esi, 1

; 726  :           goto help_exit;

	jmp	$LN113@keyword_he
$LN67@keyword_he:

; 751  :       } 
; 752  :       break;
; 753  :     }
; 754  :   
; 755  :     /* search extra attributes */
; 756  :   for ( type = 0 ; type <= BODY ; type++ )

	mov	DWORD PTR _type$[ebp], esi
	mov	edi, OFFSET _web+108
	npad	4
$LL17@keyword_he:

; 757  :   { struct extra *ex;
; 758  :     int k;
; 759  : 
; 760  :     for ( i = 0, ex = EXTRAS(type) ;
; 761  :              i < web.skel[type].extra_count ; i++ , ex++ )

	mov	esi, DWORD PTR [edi-4]
	add	esi, DWORD PTR _dymem
	xor	ebx, ebx
	cmp	DWORD PTR [edi], ebx
	jle	SHORT $LN16@keyword_he
	npad	1
$LL14@keyword_he:

; 762  :       if ( stricmp(keyword, ex->name) == 0 )

	mov	ecx, DWORD PTR _keyword$[ebp]
	push	esi
	push	ecx
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN99@keyword_he

; 757  :   { struct extra *ex;
; 758  :     int k;
; 759  : 
; 760  :     for ( i = 0, ex = EXTRAS(type) ;
; 761  :              i < web.skel[type].extra_count ; i++ , ex++ )

	inc	ebx
	add	esi, 240				; 000000f0H
	cmp	ebx, DWORD PTR [edi]
	jl	SHORT $LL14@keyword_he
$LN16@keyword_he:

; 751  :       } 
; 752  :       break;
; 753  :     }
; 754  :   
; 755  :     /* search extra attributes */
; 756  :   for ( type = 0 ; type <= BODY ; type++ )

	inc	DWORD PTR _type$[ebp]
	add	edi, 112				; 00000070H
	cmp	edi, OFFSET _web+444
	jle	SHORT $LL17@keyword_he

; 773  :       } 
; 774  :   }
; 775  :    
; 776  :   /* search built-in datatypes */
; 777  :   for ( i = 0 ; i < sizeof(datatype_name)/sizeof(char*) ; i++ )

	mov	edi, DWORD PTR _keyword$[ebp]
	xor	esi, esi
	npad	1
$LL5@keyword_he:

; 778  :     if ( stricmp(keyword,datatype_name[i]) == 0 )

	mov	eax, DWORD PTR _datatype_name[esi]
	push	eax
	push	edi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	$LN100@keyword_he

; 773  :       } 
; 774  :   }
; 775  :    
; 776  :   /* search built-in datatypes */
; 777  :   for ( i = 0 ; i < sizeof(datatype_name)/sizeof(char*) ; i++ )

	add	esi, 4
	cmp	esi, 100				; 00000064H
	jb	SHORT $LL5@keyword_he

; 778  :     if ( stricmp(keyword,datatype_name[i]) == 0 )

	mov	esi, DWORD PTR _found$[ebp]
	jmp	$LN113@keyword_he
$LN99@keyword_he:

; 763  :       { sprintf(msg,"\n%s: %s attribute, type %s, ",
; 764  :               keyword,typenames[type],datatype_name[ex->type]);

	mov	edx, DWORD PTR [esi+68]
	mov	eax, DWORD PTR _datatype_name[edx*4]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR _typenames[ecx*4]
	mov	ecx, DWORD PTR _msg
	push	eax
	mov	eax, DWORD PTR _keyword$[ebp]
	push	edx
	push	eax
	push	OFFSET ??_C@_0BN@KCKIKKMB@?6?$CFs?3?5?$CFs?5attribute?0?5type?5?$CFs?0?5?$AA@
	push	ecx
	call	_sprintf

; 765  :         if ( ex->array_spec.dim == 0 ) strcat(msg,"scalar");

	mov	eax, DWORD PTR _msg
	add	esp, 20					; 00000014H
	dec	eax
	cmp	DWORD PTR [esi+76], 0
	jne	SHORT $LL108@keyword_he
$LL107@keyword_he:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL107@keyword_he
	mov	edx, DWORD PTR ??_C@_06LAMNDLOG@scalar?$AA@
	mov	DWORD PTR [eax], edx
	mov	cx, WORD PTR ??_C@_06LAMNDLOG@scalar?$AA@+4
	mov	WORD PTR [eax+4], cx
	mov	dl, BYTE PTR ??_C@_06LAMNDLOG@scalar?$AA@+6
	mov	BYTE PTR [eax+6], dl
	jmp	SHORT $LN9@keyword_he
$LL108@keyword_he:

; 766  :         else strcat(msg," dimension ");

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL108@keyword_he
	mov	ecx, DWORD PTR ??_C@_0M@BCFGJIHC@?5dimension?5?$AA@
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ??_C@_0M@BCFGJIHC@?5dimension?5?$AA@+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ??_C@_0M@BCFGJIHC@?5dimension?5?$AA@+8
	mov	DWORD PTR [eax+8], ecx
$LN9@keyword_he:

; 767  :         for ( k = 0 ; k < ex->array_spec.dim ; k++ )

	xor	edi, edi
	cmp	DWORD PTR [esi+76], edi
	jle	SHORT $LN111@keyword_he
	lea	ebx, DWORD PTR [esi+96]
$LL8@keyword_he:

; 768  :            sprintf(msg+strlen(msg),"[%d]",ex->array_spec.sizes[k]);

	mov	edx, DWORD PTR _msg
	mov	eax, edx
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR tv944[ebp], ecx
$LL109@keyword_he:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL109@keyword_he
	mov	ecx, DWORD PTR [ebx]
	sub	eax, DWORD PTR tv944[ebp]
	push	ecx
	add	eax, edx
	push	OFFSET ??_C@_04KBDJOJNB@?$FL?$CFd?$FN?$AA@
	push	eax
	call	_sprintf
	inc	edi
	add	esp, 12					; 0000000cH
	add	ebx, 4
	cmp	edi, DWORD PTR [esi+76]
	jl	SHORT $LL8@keyword_he
$LN111@keyword_he:

; 769  :         strcat(msg,"\n\n");

	mov	eax, DWORD PTR _msg
	dec	eax
	npad	2
$LL110@keyword_he:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL110@keyword_he
	mov	dx, WORD PTR ??_C@_02PHMGELLB@?6?6?$AA@
	mov	WORD PTR [eax], dx
	mov	cl, BYTE PTR ??_C@_02PHMGELLB@?6?6?$AA@+2
	mov	BYTE PTR [eax+2], cl

; 770  :         outstring(msg); 

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 771  :         found = 1;
; 772  :         goto help_exit;

	mov	edi, DWORD PTR _keyword$[ebp]
	mov	DWORD PTR _found$[ebp], 1
	mov	esi, DWORD PTR _found$[ebp]
	add	esp, 4
	jmp	SHORT $LN113@keyword_he
$LN100@keyword_he:

; 779  :     { sprintf(msg,"\n%s: reserved type name.\n\n",keyword);

	mov	ecx, DWORD PTR _msg
	push	edi
	push	OFFSET ??_C@_0BL@DDPJLACN@?6?$CFs?3?5reserved?5type?5name?4?6?6?$AA@
	push	ecx
	call	_sprintf

; 780  :       outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 781  :       found = 1;

	mov	DWORD PTR _found$[ebp], 1
	mov	esi, DWORD PTR _found$[ebp]
$LN119@keyword_he:

; 780  :       outstring(msg);

	add	esp, 16					; 00000010H
$LN113@keyword_he:
	pop	ebx
$help_exit$89769:

; 782  :       goto help_exit;
; 783  :     }
; 784  :  
; 785  : 
; 786  : help_exit:
; 787  : 
; 788  : 
; 789  : /* find_related: */
; 790  : 
; 791  :   /* Go to help file, even if found, for related entries */
; 792  :  // if ( !found )
; 793  :     if ( !new_text_help(keyword,found) && !found )

	push	esi
	push	edi
	call	_new_text_help
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@keyword_he
	test	esi, esi
	jne	SHORT $LN1@keyword_he

; 794  :       old_html_help(keyword,found);

	push	esi
	push	edi
	call	_old_html_help
	add	esp, 8
$LN1@keyword_he:

; 795  : 
; 796  : 
; 797  : #ifndef NOPIPE
; 798  :     pclose(outfd);

	mov	eax, DWORD PTR _outfd
	push	eax
	call	__pclose
	add	esp, 4

; 799  :     outfd = stdout;

	call	___iob_func
	add	eax, 32					; 00000020H
	pop	edi
	mov	DWORD PTR _outfd, eax
	pop	esi

; 800  : #else
; 801  :   ;
; 802  : #endif
; 803  : 
; 804  : } /* end keyword_help() */

	mov	esp, ebp
	pop	ebp
	ret	0
_keyword_help ENDP
_TEXT	ENDS
END
