; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\ITERATE.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_volgrads_changed_flag:DWORD
COMM	_thread_scale:QWORD
_DATA	ENDS
PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_get_fe_edge
; Function compile flags: /Ogtp
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	_get_vertex_fe
; Function compile flags: /Ogtp
;	COMDAT _get_vertex_fe
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_get_vertex_fe PROC					; COMDAT

; 287  : { facet_id fe;

	push	ebp
	mov	ebp, esp

; 288  :   edge_id start_e, xx_id=vptr(v_id)->e_id;

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 289  :   // might be bare edge, so seek along edge loop
; 290  :   if ( !valid_id(xx_id) ) return NULLID;

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN4@get_vertex
	xor	eax, eax

; 299  : }

	pop	ebp
	ret	0
$LN4@get_vertex:
	push	esi

; 291  :   fe = eptr(xx_id)->fe_id;

	mov	esi, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	push	edi

; 292  :   start_e = xx_id;
; 293  :   while ( !valid_id(fe) )

	test	edx, 268435456				; 10000000H
	jne	SHORT $LN2@get_vertex
	mov	edi, eax
	or	edi, 134217728				; 08000000H
	npad	8
$LL3@get_vertex:

; 294  :   { xx_id = get_next_tail_edge(xx_id);

	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	eax, DWORD PTR [ecx+eax*4+32]

; 295  :     if ( equal_element(xx_id,start_e) ) return NULLID;

	mov	edx, eax
	or	edx, 134217728				; 08000000H
	cmp	edx, edi
	je	SHORT $LN10@get_vertex

; 296  :     fe = eptr(xx_id)->fe_id;

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	test	edx, 268435456				; 10000000H
	je	SHORT $LL3@get_vertex
$LN2@get_vertex:

; 297  :   }
; 298  :   return  same_sign(fe,xx_id);

	and	eax, 134217728				; 08000000H
	pop	edi
	xor	eax, edx
	pop	esi

; 299  : }

	pop	ebp
	ret	0
$LN10@get_vertex:
	pop	edi

; 295  :     if ( equal_element(xx_id,start_e) ) return NULLID;

	xor	eax, eax
	pop	esi

; 299  : }

	pop	ebp
	ret	0
_get_vertex_fe ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_get_body_volume
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_body_volume
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volume PROC					; COMDAT

; 308  :     { return    ( valid_id(b_id) ?  bptr(b_id)->volume : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]
	pop	ebp
	ret	0
$LN3@get_body_v:
	fldz
	pop	ebp
	ret	0
_get_body_volume ENDP
_TEXT	ENDS
PUBLIC	_get_body_pressure
; Function compile flags: /Ogtp
;	COMDAT _get_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_pressure PROC					; COMDAT

; 317  :     { return  ( valid_id(b_id) ?    bptr(b_id)->pressure : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_p
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+312]
	pop	ebp
	ret	0
$LN3@get_body_p:
	fldz
	pop	ebp
	ret	0
_get_body_pressure ENDP
_TEXT	ENDS
PUBLIC	_get_body_volconst
; Function compile flags: /Ogtp
;	COMDAT _get_body_volconst
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volconst PROC					; COMDAT

; 320  :   { return    ( valid_id(b_id) ?  bptr(b_id)->volconst : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v@2
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+328]
	pop	ebp
	ret	0
$LN3@get_body_v@2:
	fldz
	pop	ebp
	ret	0
_get_body_volconst ENDP
_TEXT	ENDS
PUBLIC	_set_body_pressure
; Function compile flags: /Ogtp
;	COMDAT _set_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_pressure PROC					; COMDAT

; 326  :       {         ( valid_id(b_id) ?  bptr(b_id)->pressure = (v) : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@set_body_p
	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+312]
$LN3@set_body_p:
	pop	ebp
	ret	0
_set_body_pressure ENDP
_TEXT	ENDS
PUBLIC	_set_body_volconst
EXTRN	_gen_quant_list:DWORD
EXTRN	_everything_quantities_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_body_volconst
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_volconst PROC					; COMDAT

; 329  : { if ( !valid_id(b_id) ) return;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_body_v

; 330  :   bptr(b_id)->volconst = v;

	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	fst	QWORD PTR [edx+328]

; 331  :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN6@set_body_v

; 332  :   { struct gen_quant *q = GEN_QUANT(get_body_volquant(b_id));

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+404]

; 333  :     q->volconst = v;

	mov	ecx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	fstp	QWORD PTR [eax+ecx+208]

; 334  :   }
; 335  : }

	pop	ebp
	ret	0
$LN6@set_body_v:

; 333  :     q->volconst = v;

	fstp	ST(0)
$LN1@set_body_v:

; 334  :   }
; 335  : }

	pop	ebp
	ret	0
_set_body_volconst ENDP
_TEXT	ENDS
PUBLIC	_get_extra
; Function compile flags: /Ogtp
;	COMDAT _get_extra
_TEXT	SEGMENT
_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_extra PROC						; COMDAT

; 348  : { int type = id_type(id);

	push	ebp
	mov	ebp, esp

; 349  : 
; 350  :   return ( (char*)elptr(id) + EXTRAS(type)[n].offset);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	shr	eax, 29					; 0000001dH
	imul	esi, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, esi
	add	eax, DWORD PTR [edi+ecx+64]
	pop	edi
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_get_extra ENDP
_TEXT	ENDS
PUBLIC	_thread_move_vertices
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	_thread_stages:DWORD
EXTRN	_max_thread_stages:DWORD
EXTRN	_nprocs:DWORD
EXTRN	_win_get_thread_data:PROC
EXTRN	_thread_data_key:DWORD
EXTRN	_ackerman_flag:DWORD
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\iterate.c
;	COMDAT _thread_move_vertices
_TEXT	SEGMENT
_data$89438 = -40					; size = 4
tv1386 = -36						; size = 4
_pcount$89475 = -36					; size = 4
tv971 = -32						; size = 4
tv559 = -28						; size = 4
tv1634 = -24						; size = 4
_maxstage$89439 = -20					; size = 4
_idptr$89434 = -16					; size = 4
_i$ = -12						; size = 4
_th$89437 = -8						; size = 4
_dim$ = -4						; size = 4
_thread_move_vertices PROC				; COMDAT

; 622  : { int i; 

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 623  :   int dim = ackerman_flag ? 2*SDIM : SDIM;

	cmp	DWORD PTR _ackerman_flag, 0
	je	SHORT $LN20@thread_mov
	mov	eax, DWORD PTR _web+616
	lea	ecx, DWORD PTR [eax+eax]
	mov	DWORD PTR _dim$[ebp], ecx
	jmp	SHORT $LN21@thread_mov
$LN20@thread_mov:
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR _dim$[ebp], edx
$LN21@thread_mov:

; 624  :   
; 625  :   THREAD_FOR_ALL_NEW(VERTEX,  /* following block is macro argument */
; 626  :   { vertex_id v_id = *idptr;
; 627  :     REAL *velocity;
; 628  :     REAL *x;
; 629  : 
; 630  :     if ( get_vattr(v_id) & FIXED ) continue ;
; 631  :     velocity = get_velocity(v_id);
; 632  :     x = get_coord(v_id);
; 633  :     if ( get_vattr(v_id) & BOUNDARY )
; 634  :     {
; 635  :       struct boundary *boundary = get_boundary(v_id);
; 636  :       int pcount = boundary->pcount;
; 637  :       REAL *param = get_param(v_id);
; 638  : 
; 639  :       for ( i = 0 ; i < pcount ; i++ )
; 640  :         param[i] += thread_scale*velocity[i];
; 641  :     }
; 642  :     else
; 643  :     {
; 644  :       for ( i = 0 ; i < dim ; i++ )
; 645  :         x[i] += thread_scale*velocity[i];
; 646  :     }
; 647  :   }
; 648  :  ) /* end of macro argument */

	mov	eax, DWORD PTR _thread_data_key
	push	esi
	push	edi
	push	eax
	call	_win_get_thread_data
	mov	ecx, DWORD PTR _nprocs
	mov	edi, eax
	mov	esi, DWORD PTR [edi]
	dec	ecx
	add	esp, 4
	mov	DWORD PTR _data$89438[ebp], edi
	cmp	esi, ecx
	jne	SHORT $LN22@thread_mov
	xor	eax, eax
	jmp	SHORT $LN23@thread_mov
$LN22@thread_mov:
	lea	eax, DWORD PTR [esi+1]
$LN23@thread_mov:
	test	esi, esi
	jne	SHORT $LN24@thread_mov
	mov	edx, DWORD PTR _max_thread_stages
	inc	edx
	mov	DWORD PTR _maxstage$89439[ebp], edx
	jmp	SHORT $LN25@thread_mov
$LN24@thread_mov:
	mov	ecx, DWORD PTR _max_thread_stages
	mov	DWORD PTR _maxstage$89439[ebp], ecx
$LN25@thread_mov:
	imul	esi, 548				; 00000224H
	add	esi, DWORD PTR _thread_stages
	mov	DWORD PTR [esi+540], 0
	mov	edx, DWORD PTR [esi+540]
	mov	DWORD PTR _th$89437[ebp], esi
	cmp	edx, DWORD PTR _maxstage$89439[ebp]
	jge	$LN15@thread_mov
	imul	eax, 548				; 00000224H
	add	eax, 540				; 0000021cH
	mov	DWORD PTR tv559[ebp], eax
	push	ebx
	npad	2
$LL14@thread_mov:
	mov	eax, DWORD PTR _thread_stages
	mov	ecx, DWORD PTR tv559[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [esi+540]
	cmp	edx, eax
	jl	SHORT $LL14@thread_mov
	mov	ecx, DWORD PTR [esi+540]
	rdtsc
	mov	DWORD PTR [edi+ecx*8+1808], eax
	mov	DWORD PTR [edi+ecx*8+1812], edx
	mov	ecx, DWORD PTR [esi+540]
	mov	eax, DWORD PTR [esi+540]
	mov	eax, DWORD PTR [esi+eax*4+180]
	mov	edx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR _idptr$89434[ebp], edx
	test	eax, eax
	jle	$LN10@thread_mov
	mov	DWORD PTR tv1634[ebp], eax
	npad	1
$LL12@thread_mov:
	mov	ecx, DWORD PTR _idptr$89434[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edx+eax*4]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ebx+8]
	and	eax, 64					; 00000040H
	xor	edx, edx
	or	eax, edx
	jne	$LN11@thread_mov
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	mov	edi, DWORD PTR [ecx+edx+1024]
	mov	esi, DWORD PTR [ecx+edx+64]
	mov	eax, ebx
	add	edi, eax
	add	esi, eax
	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	$LN8@thread_mov
	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN26@thread_mov
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, ecx
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [eax+ebx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN27@thread_mov
$LN26@thread_mov:
	xor	eax, eax
$LN27@thread_mov:
	mov	edx, DWORD PTR [eax+40]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [ecx+eax+544]
	add	esi, ebx
	xor	ecx, ecx
	mov	DWORD PTR _pcount$89475[ebp], edx
	cmp	edx, 4
	jl	SHORT $LC38@thread_mov
	add	edx, -4					; fffffffcH
	mov	ebx, edi
	sub	ebx, esi
	shr	edx, 2
	mov	DWORD PTR tv971[ebp], ebx
	inc	edx
	lea	ebx, DWORD PTR [edx*4]
	mov	DWORD PTR _i$[ebp], ebx
	mov	ebx, DWORD PTR tv971[ebp]
	lea	ecx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR [esi+8]
	npad	1
$LL39@thread_mov:
	fld	QWORD PTR [ecx-24]
	add	eax, 32					; 00000020H
	fmul	QWORD PTR _thread_scale
	add	ecx, 32					; 00000020H
	dec	edx
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [ebx+eax-32]
	fmul	QWORD PTR _thread_scale
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx-40]
	fmul	QWORD PTR _thread_scale
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR _thread_scale
	fmul	QWORD PTR [ecx-32]
	fadd	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LL39@thread_mov
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pcount$89475[ebp]
$LC38@thread_mov:
	cmp	ecx, edx
	jge	$LN45@thread_mov
	sub	edi, esi
	lea	eax, DWORD PTR [esi+ecx*8]
	sub	edx, ecx
	npad	5
$LC7@thread_mov:
	fld	QWORD PTR [edi+eax]
	add	eax, 8
	dec	edx
	fmul	QWORD PTR _thread_scale
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC7@thread_mov
	jmp	$LN45@thread_mov
$LN8@thread_mov:
	mov	edx, DWORD PTR _dim$[ebp]
	xor	ebx, ebx
	cmp	edx, 4
	jl	SHORT $LN46@thread_mov
	add	edx, -4					; fffffffcH
	mov	ebx, edi
	sub	ebx, esi
	shr	edx, 2
	mov	DWORD PTR tv1386[ebp], ebx
	inc	edx
	lea	ebx, DWORD PTR [edx*4]
	mov	DWORD PTR _i$[ebp], ebx
	mov	ebx, DWORD PTR tv1386[ebp]
	lea	ecx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR [esi+8]
	npad	11
$LL42@thread_mov:
	fld	QWORD PTR [ecx-24]
	add	eax, 32					; 00000020H
	fmul	QWORD PTR _thread_scale
	add	ecx, 32					; 00000020H
	dec	edx
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [ebx+eax-32]
	fmul	QWORD PTR _thread_scale
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx-40]
	fmul	QWORD PTR _thread_scale
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [ecx-32]
	fmul	QWORD PTR _thread_scale
	fadd	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LL42@thread_mov
	mov	ebx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _dim$[ebp]
$LN46@thread_mov:
	cmp	ebx, edx
	jge	SHORT $LN45@thread_mov
	mov	ecx, DWORD PTR _dim$[ebp]
	sub	edi, esi
	lea	eax, DWORD PTR [esi+ebx*8]
	sub	ecx, ebx
	npad	6
$LC3@thread_mov:
	fld	QWORD PTR [eax+edi]
	add	eax, 8
	dec	ecx
	fmul	QWORD PTR _thread_scale
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC3@thread_mov
$LN45@thread_mov:
	mov	esi, DWORD PTR _th$89437[ebp]
$LN11@thread_mov:
	add	DWORD PTR _idptr$89434[ebp], 4
	dec	DWORD PTR tv1634[ebp]
	jne	$LL12@thread_mov
	mov	edi, DWORD PTR _data$89438[ebp]
$LN10@thread_mov:
	mov	ecx, DWORD PTR [esi+540]
	rdtsc
	mov	DWORD PTR [edi+ecx*8+1880], eax
	mov	DWORD PTR [edi+ecx*8+1884], edx
	inc	DWORD PTR [esi+540]
	mov	ecx, DWORD PTR [esi+540]
	cmp	ecx, DWORD PTR _maxstage$89439[ebp]
	jl	$LL14@thread_mov
	pop	ebx
$LN15@thread_mov:
	pop	edi
	pop	esi

; 649  : }  // end thread_move_vertices()

	mov	esp, ebp
	pop	ebp
	ret	0
_thread_move_vertices ENDP
_TEXT	ENDS
PUBLIC	_thread_project_all
EXTRN	_eval:PROC
EXTRN	_project_v_constr:PROC
; Function compile flags: /Ogtp
;	COMDAT _thread_project_all
_TEXT	SEGMENT
_attr$89594 = -40					; size = 8
_data$89580 = -32					; size = 4
_one_sided_mode$ = -28					; size = 4
tv270 = -24						; size = 4
tv183 = -20						; size = 4
_th$89579 = -16						; size = 4
_maxstage$89581 = -12					; size = 4
tv422 = -8						; size = 4
tv292 = -8						; size = 4
_idptr$89576 = -4					; size = 4
_mode2$ = 8						; size = 4
_thread_project_all PROC				; COMDAT

; 762  : { int one_sided_mode = (mode2==TEST_MOVE) ? KEEP_ONESIDEDNESS : RESET_ONESIDEDNESS;

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 763  :   /* project to constraints and boundaries */ 
; 764  :   THREAD_FOR_ALL_NEW(VERTEX,
; 765  :     { ATTR attr = get_vattr(*idptr);
; 766  :       if ( attr & CONSTRAINT )
; 767  :          project_v_constr(*idptr,mode2,one_sided_mode);
; 768  :       else if ( attr & BOUNDARY )
; 769  :       { int i;
; 770  :         struct boundary *boundary = get_boundary(*idptr);
; 771  :         REAL *param = get_param(*idptr);
; 772  :         REAL *x = get_coord(*idptr);
; 773  : 
; 774  :         for ( i = 0 ; i < SDIM ; i++ )
; 775  :            x[i] = eval(boundary->coordf[i],param,*idptr,NULL);
; 776  :       }
; 777  :     }
; 778  :   ) /* end of THREAD_FOR_ALL macro  */

	mov	ecx, DWORD PTR _thread_data_key
	xor	eax, eax
	cmp	DWORD PTR _mode2$[ebp], eax
	push	ebx
	setne	al
	push	ecx
	mov	DWORD PTR _one_sided_mode$[ebp], eax
	call	_win_get_thread_data
	mov	edx, DWORD PTR _nprocs
	mov	ecx, eax
	mov	ebx, DWORD PTR [ecx]
	dec	edx
	add	esp, 4
	mov	DWORD PTR _data$89580[ebp], ecx
	cmp	ebx, edx
	jne	SHORT $LN17@thread_pro
	xor	eax, eax
	jmp	SHORT $LN18@thread_pro
$LN17@thread_pro:
	lea	eax, DWORD PTR [ebx+1]
$LN18@thread_pro:
	mov	edx, DWORD PTR _max_thread_stages
	test	ebx, ebx
	jne	SHORT $LN19@thread_pro
	inc	edx
$LN19@thread_pro:
	imul	ebx, 548				; 00000224H
	add	ebx, DWORD PTR _thread_stages
	mov	DWORD PTR _maxstage$89581[ebp], edx
	mov	DWORD PTR [ebx+540], 0
	mov	edx, DWORD PTR [ebx+540]
	mov	DWORD PTR _th$89579[ebp], ebx
	cmp	edx, DWORD PTR _maxstage$89581[ebp]
	jge	$LN12@thread_pro
	imul	eax, 548				; 00000224H
	add	eax, 540				; 0000021cH
	push	esi
	mov	DWORD PTR tv270[ebp], eax
	push	edi
$LL11@thread_pro:
	mov	edx, DWORD PTR tv270[ebp]
	mov	eax, DWORD PTR _thread_stages
	mov	eax, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [ebx+540]
	cmp	eax, edx
	jl	SHORT $LL11@thread_pro
	mov	esi, DWORD PTR [ebx+540]
	rdtsc
	mov	DWORD PTR [ecx+esi*8+1808], eax
	mov	DWORD PTR [ecx+esi*8+1812], edx
	mov	eax, DWORD PTR [ebx+540]
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [ebx+540]
	mov	eax, DWORD PTR [ebx+eax*4+180]
	mov	DWORD PTR _idptr$89576[ebp], edx
	test	eax, eax
	jle	$LN7@thread_pro
	mov	DWORD PTR tv183[ebp], eax
	npad	1
$LL32@thread_pro:
	mov	ecx, DWORD PTR _idptr$89576[ebp]
	mov	edi, DWORD PTR [ecx]
	mov	eax, DWORD PTR _web+12
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR tv292[ebp], eax
	mov	eax, ecx
	mov	DWORD PTR _attr$89594[ebp+4], edx
	and	eax, 1024				; 00000400H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN6@thread_pro
	mov	eax, DWORD PTR _one_sided_mode$[ebp]
	mov	ecx, DWORD PTR _mode2$[ebp]
	push	eax
	push	ecx
	push	edi
	call	_project_v_constr
	add	esp, 12					; 0000000cH
	jmp	$LN8@thread_pro
$LN6@thread_pro:
	and	ecx, 128				; 00000080H
	xor	eax, eax
	or	ecx, eax
	je	$LN8@thread_pro
	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	mov	edx, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
	test	eax, eax
	je	SHORT $LN21@thread_pro
	imul	eax, 240				; 000000f0H
	add	eax, edx
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	eax, DWORD PTR [eax+esi]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN22@thread_pro
$LN21@thread_pro:
	xor	eax, eax
$LN22@thread_pro:
	mov	edi, DWORD PTR [edx+ebx+544]
	mov	ecx, DWORD PTR tv292[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [edx+ebx+64]
	xor	esi, esi
	add	edi, ecx
	add	ebx, ecx
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN31@thread_pro
	add	eax, 48					; 00000030H
	mov	DWORD PTR tv422[ebp], eax
	npad	1
$LL30@thread_pro:
	mov	edx, DWORD PTR _idptr$89576[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv422[ebp]
	mov	edx, DWORD PTR [ecx]
	push	0
	push	eax
	push	edi
	push	edx
	call	_eval
	fstp	QWORD PTR [ebx+esi*8]
	add	DWORD PTR tv422[ebp], 4
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL30@thread_pro
$LN31@thread_pro:
	mov	ebx, DWORD PTR _th$89579[ebp]
$LN8@thread_pro:
	add	DWORD PTR _idptr$89576[ebp], 4
	dec	DWORD PTR tv183[ebp]
	jne	$LL32@thread_pro
	mov	ecx, DWORD PTR _data$89580[ebp]
$LN7@thread_pro:
	mov	esi, DWORD PTR [ebx+540]
	rdtsc
	mov	DWORD PTR [ecx+esi*8+1880], eax
	mov	DWORD PTR [ecx+esi*8+1884], edx
	inc	DWORD PTR [ebx+540]
	mov	eax, DWORD PTR [ebx+540]
	cmp	eax, DWORD PTR _maxstage$89581[ebp]
	jl	$LL11@thread_pro
	pop	edi
	pop	esi
$LN12@thread_pro:
	pop	ebx

; 779  : } // end thread_project_all()

	mov	esp, ebp
	pop	ebp
	ret	0
_thread_project_all ENDP
_TEXT	ENDS
PUBLIC	??_C@_09MIIJPAGP@ITERATE?4C?$AA@		; `string'
PUBLIC	_local_save_coords
EXTRN	_localbase:DWORD
EXTRN	_optparam:BYTE
EXTRN	_optparamcount:DWORD
EXTRN	_meth_inst_list:DWORD
EXTRN	_kb_temp_calloc:PROC
EXTRN	_temp_free:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_09MIIJPAGP@ITERATE?4C?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_09MIIJPAGP@ITERATE?4C?$AA@ DB 'ITERATE.C', 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\iterate.c
CONST	ENDS
;	COMDAT _local_save_coords
_TEXT	SEGMENT
tv623 = -8						; size = 8
tv669 = 8						; size = 4
_saver$ = 8						; size = 4
_mode$ = 12						; size = 4
_local_save_coords PROC					; COMDAT

; 820  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 821  :   vertex_id v_id;
; 822  :   body_id b_id;
; 823  :   int n;
; 824  : 
; 825  :   if ( mode == SAVE_SEPARATE ) 

	cmp	DWORD PTR _mode$[ebp], 2
	push	ebx
	mov	ebx, DWORD PTR _saver$[ebp]
	push	esi
	push	edi
	jne	$LN31@local_save

; 826  :   {
; 827  :     if ( saver->coord )

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN30@local_save

; 828  :       temp_free((char *)saver->coord);    /* in case somebody forgot */

	push	eax
	call	_temp_free
	add	esp, 4
$LN30@local_save:

; 829  :     saver->coord = (REAL (*)[MAXCOORD])temp_calloc(web.skel[VERTEX].max_ord+1,
; 830  :                                                   sizeof(REAL)*MAXCOORD);

	mov	eax, DWORD PTR _web+68
	push	830					; 0000033eH
	push	OFFSET ??_C@_09MIIJPAGP@ITERATE?4C?$AA@
	inc	eax
	push	48					; 00000030H
	push	eax
	call	_kb_temp_calloc
	mov	DWORD PTR [ebx], eax

; 831  : 
; 832  :     FOR_ALL_VERTICES(v_id)

	mov	edi, DWORD PTR _web+48
	mov	esi, edi
	shr	esi, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	esi, 1
	je	$LN72@local_save
	npad	10
$LL70@local_save:
	mov	ecx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv623[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	$LN71@local_save

; 833  :     { if ( get_vattr(v_id) & BOUNDARY )

	and	ecx, 128				; 00000080H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN24@local_save

; 834  :         memcpy((char *)(saver->coord+loc_ordinal(v_id)),(char *)get_param(v_id),
; 835  :                                            sizeof(REAL)*web.maxparam);

	test	esi, esi
	je	SHORT $LN34@local_save
	mov	eax, edi
	jmp	SHORT $LN35@local_save
$LN34@local_save:
	or	eax, -1
$LN35@local_save:
	mov	ecx, DWORD PTR _web+640
	mov	esi, DWORD PTR _dymem
	mov	ebx, DWORD PTR _saver$[ebp]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	mov	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+esi+544]
	add	ecx, edx
	lea	edx, DWORD PTR [eax+eax*2]
	shl	edx, 4
	add	edx, DWORD PTR [ebx]
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 836  :       else

	jmp	SHORT $LN28@local_save
$LN24@local_save:

; 837  :         memcpy((char *)(saver->coord+loc_ordinal(v_id)),(char *)get_coord(v_id),
; 838  :                                            sizeof(REAL)*SDIM);

	test	esi, esi
	je	SHORT $LN36@local_save
	mov	eax, edi
	jmp	SHORT $LN37@local_save
$LN36@local_save:
	or	eax, -1
$LN37@local_save:
	mov	ecx, DWORD PTR _web+616
	mov	esi, DWORD PTR _dymem
	mov	ebx, DWORD PTR _saver$[ebp]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	mov	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+esi+64]
	add	ecx, edx
	lea	edx, DWORD PTR [eax+eax*2]
	shl	edx, 4
	add	edx, DWORD PTR [ebx]
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN28@local_save
$LN71@local_save:
	mov	ebx, DWORD PTR _saver$[ebp]
$LN28@local_save:

; 831  : 
; 832  :     FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR [ecx]
	mov	esi, edi
	shr	esi, 28					; 0000001cH
	and	esi, 1
	jne	$LL70@local_save

; 839  :     }
; 840  : 
; 841  :   }
; 842  :   else

	jmp	$LN72@local_save
$LN31@local_save:

; 843  :   {
; 844  :     FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	$LN72@local_save
	mov	edx, DWORD PTR _web+12
	npad	2
$LL21@local_save:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR [esi+edx]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv623[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN20@local_save

; 845  :     { if ( get_vattr(v_id) & BOUNDARY )
; 846  :         memcpy((char *)(get_oldcoord(v_id)),(char *)get_param(v_id),
; 847  :                                            sizeof(REAL)*web.maxparam);

	mov	edx, DWORD PTR [esi+edx]
	and	ecx, 128				; 00000080H
	xor	eax, eax
	or	ecx, eax
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	je	SHORT $LN16@local_save
	mov	edi, DWORD PTR _web+640
	add	edi, edi
	add	edi, edi
	add	edi, edi
	push	edi
	mov	edi, DWORD PTR [eax+ecx+544]
	mov	ecx, DWORD PTR [eax+ecx+304]
	add	edi, edx
	push	edi
	add	ecx, edx
	push	ecx

; 848  :       else

	jmp	SHORT $LN97@local_save
$LN16@local_save:

; 849  :         memcpy((char *)(get_oldcoord(v_id)),(char *)get_coord(v_id),
; 850  :                                            sizeof(REAL)*SDIM);

	mov	edi, DWORD PTR _web+616
	add	edi, edi
	add	edi, edi
	add	edi, edi
	push	edi
	mov	edi, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR [eax+ecx+304]
	add	edi, edx
	push	edi
	add	eax, edx
	push	eax
$LN97@local_save:
	call	_memcpy
	mov	edx, DWORD PTR _web+12
	add	esp, 12					; 0000000cH
$LN20@local_save:

; 843  :   {
; 844  :     FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	jne	$LL21@local_save
$LN72@local_save:

; 851  :     }
; 852  : 
; 853  :   }
; 854  : 
; 855  :   /* also save old energy and quantities */
; 856  :   /* always saving separately since in-structure save being used elsewhere */
; 857  :   saver->energy = web.total_energy;

	fld	QWORD PTR _web+1240

; 858  :   saver->bod = (REAL*)temp_calloc(web.skel[BODY].max_ord+1,3*sizeof(REAL));

	push	858					; 0000035aH
	fstp	QWORD PTR [ebx+8]
	mov	edx, DWORD PTR _web+404
	push	OFFSET ??_C@_09MIIJPAGP@ITERATE?4C?$AA@
	inc	edx
	push	24					; 00000018H
	push	edx
	call	_kb_temp_calloc
	mov	DWORD PTR [ebx+16], eax

; 859  :   FOR_ALL_BODIES(b_id) 

	mov	edx, DWORD PTR _web+384
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	ecx, 1
	je	$LN73@local_save
	fldz
	mov	edi, DWORD PTR _web+348
$LN74@local_save:
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN13@local_save

; 860  :   { int spot = 3*loc_ordinal(b_id);

	test	ecx, ecx
	je	SHORT $LN38@local_save
	mov	eax, edx
	jmp	SHORT $LN39@local_save
$LN38@local_save:
	or	eax, -1
$LN39@local_save:
	lea	eax, DWORD PTR [eax+eax*2]

; 861  :     saver->bod[spot] = get_body_volume(b_id);

	test	ecx, ecx
	je	SHORT $LN48@local_save
	mov	esi, DWORD PTR [edi+edx*4]
	fld	QWORD PTR [esi+40]
	jmp	SHORT $LN49@local_save
$LN48@local_save:
	fld	ST(0)
$LN49@local_save:
	mov	esi, DWORD PTR [ebx+16]
	fstp	QWORD PTR [esi+eax*8]

; 862  :     saver->bod[spot+1] = get_body_pressure(b_id);

	test	ecx, ecx
	je	SHORT $LN52@local_save
	mov	esi, DWORD PTR _web+348
	mov	esi, DWORD PTR [esi+edx*4]
	fld	QWORD PTR [esi+312]
	jmp	SHORT $LN53@local_save
$LN52@local_save:
	fld	ST(0)
$LN53@local_save:
	mov	esi, DWORD PTR [ebx+16]
	fstp	QWORD PTR [esi+eax*8+8]

; 863  :     saver->bod[spot+2] = get_body_volconst(b_id);

	test	ecx, ecx
	je	SHORT $LN56@local_save
	mov	ecx, DWORD PTR _web+348
	mov	ecx, DWORD PTR [ecx+edx*4]
	fld	QWORD PTR [ecx+328]
	jmp	SHORT $LN57@local_save
$LN56@local_save:
	fld	ST(0)
$LN57@local_save:
	mov	ecx, DWORD PTR [ebx+16]
	fstp	QWORD PTR [ecx+eax*8+16]
	mov	edi, DWORD PTR _web+348
$LN13@local_save:

; 859  :   FOR_ALL_BODIES(b_id) 

	mov	edx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LN74@local_save
	fstp	ST(0)
$LN73@local_save:

; 864  :   }
; 865  :   saver->meth = (REAL*)temp_calloc(meth_inst_count,sizeof(REAL));

	mov	eax, DWORD PTR _web+5560
	push	865					; 00000361H
	push	OFFSET ??_C@_09MIIJPAGP@ITERATE?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc

; 866  :   for ( n = LOW_INST ; n < meth_inst_count ; n++ )

	mov	ecx, 1
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ebx+20], eax
	cmp	DWORD PTR _web+5560, ecx
	jle	SHORT $LN7@local_save
$LL9@local_save:

; 867  :      saver->meth[n] = METH_INSTANCE(n)->value;

	mov	esi, DWORD PTR _meth_inst_list
	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+20]
	imul	eax, 2928				; 00000b70H
	inc	ecx
	fld	QWORD PTR [eax+esi+312]
	fstp	QWORD PTR [edx+ecx*8-8]
	cmp	ecx, DWORD PTR _web+5560
	jl	SHORT $LL9@local_save
$LN7@local_save:

; 868  :   saver->quant = (REAL*)temp_calloc(gen_quant_count,2*sizeof(REAL));

	mov	eax, DWORD PTR _web+5528
	push	868					; 00000364H
	push	OFFSET ??_C@_09MIIJPAGP@ITERATE?4C?$AA@
	push	16					; 00000010H
	push	eax
	call	_kb_temp_calloc

; 869  :   for ( n = 0 ; n < gen_quant_count ; n++ )

	xor	edx, edx
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ebx+24], eax
	cmp	DWORD PTR _web+5528, edx
	jle	SHORT $LN4@local_save

; 868  :   saver->quant = (REAL*)temp_calloc(gen_quant_count,2*sizeof(REAL));

	mov	eax, DWORD PTR _gen_quant_list
	xor	ecx, ecx
	add	eax, 192				; 000000c0H
$LL6@local_save:

; 870  :   { 
; 871  :     saver->quant[2*n] = GEN_QUANT(n)->value;

	mov	esi, DWORD PTR [ebx+24]
	fld	QWORD PTR [eax-40]
	fstp	QWORD PTR [ecx+esi]

; 872  :     saver->quant[2*n+1] = GEN_QUANT(n)->pressure;

	mov	esi, DWORD PTR [ebx+24]
	fld	QWORD PTR [eax]
	inc	edx
	fstp	QWORD PTR [ecx+esi+8]
	add	eax, 368				; 00000170H
	add	ecx, 16					; 00000010H
	cmp	edx, DWORD PTR _web+5528
	jl	SHORT $LL6@local_save
$LN4@local_save:

; 873  :   }
; 874  : 
; 875  :   /* save optimizing parameters */
; 876  :   for ( n = 0 ; n < optparamcount ; n++ )

	xor	esi, esi
	cmp	DWORD PTR _optparamcount, esi
	jle	$LN1@local_save
	mov	edx, OFFSET _optparam
	add	ebx, 32					; 00000020H
	npad	4
$LL3@local_save:

; 877  :      saver->optparam_values[n] = globals(optparam[n].pnum)->value.real;

	mov	eax, DWORD PTR [edx]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN40@local_save
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN42@local_save
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN41@local_save
$LN42@local_save:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN40@local_save
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN41@local_save
$LN40@local_save:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx]
$LN41@local_save:
	fld	QWORD PTR [eax+64]
	inc	esi
	fstp	QWORD PTR [ebx]
	add	ebx, 8
	add	edx, 56					; 00000038H
	cmp	esi, DWORD PTR _optparamcount
	jl	SHORT $LL3@local_save
$LN1@local_save:
	pop	edi
	pop	esi
	pop	ebx

; 878  : 
; 879  : } /* end save_coords() */

	mov	esp, ebp
	pop	ebp
	ret	0
_local_save_coords ENDP
_TEXT	ENDS
PUBLIC	_restore_vertex
; Function compile flags: /Ogtp
;	COMDAT _restore_vertex
_TEXT	SEGMENT
_x$ = -8						; size = 4
tv292 = -4						; size = 4
_v_id$ = 8						; size = 4
_saver$ = 12						; size = 4
_mode$ = 16						; size = 4
_restore_vertex PROC					; COMDAT

; 968  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 969  :   int i;
; 970  :   REAL *p,*x;
; 971  :   struct boundary *bdry;
; 972  : 
; 973  :   if ( get_vattr(v_id) & BOUNDARY )

	mov	ebx, DWORD PTR _v_id$[ebp]
	push	esi
	mov	ecx, ebx
	push	edi
	mov	edi, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 128				; 00000080H
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv292[ebp], edx
	je	$LN9@restore_ve

; 974  :   { p = get_param(v_id);

	mov	eax, DWORD PTR [edi+ecx*4]
	mov	edx, DWORD PTR _web+104
	mov	esi, DWORD PTR _dymem
	mov	edi, DWORD PTR [edx+esi+544]

; 975  :     x = get_coord(v_id);

	mov	ebx, DWORD PTR [edx+esi+64]
	add	ebx, eax
	add	edi, eax

; 976  :     bdry = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	mov	DWORD PTR _x$[ebp], ebx
	test	eax, eax
	je	SHORT $LN12@restore_ve
	mov	ebx, DWORD PTR tv292[ebp]
	imul	eax, 240				; 000000f0H
	add	eax, edx
	mov	eax, DWORD PTR [eax+esi+64]
	mov	ebx, DWORD PTR [eax+ebx]
	imul	ebx, 136				; 00000088H
	add	ebx, DWORD PTR _web+776
	jmp	SHORT $LN13@restore_ve
$LN12@restore_ve:
	xor	ebx, ebx
$LN13@restore_ve:

; 977  :     if ( mode == SAVE_SEPARATE )

	cmp	DWORD PTR _mode$[ebp], 2
	jne	SHORT $LN8@restore_ve

; 978  :       memcpy((char *)p,(char *)(saver->coord+loc_ordinal(v_id)),
; 979  :                                   sizeof(REAL)*web.maxparam);

	test	DWORD PTR _v_id$[ebp], 268435456	; 10000000H
	jne	SHORT $LN15@restore_ve
	or	ecx, -1
$LN15@restore_ve:
	mov	edx, DWORD PTR _web+640
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [edx*8]
	mov	edx, DWORD PTR _saver$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR [edx]
	push	eax
	push	ecx

; 980  :     else

	jmp	SHORT $LN20@restore_ve
$LN8@restore_ve:

; 981  :       memcpy((char *)p,(char *)(get_oldcoord(v_id)),
; 982  :                                   sizeof(REAL)*web.maxparam);

	mov	eax, DWORD PTR _web+640
	mov	edx, DWORD PTR [edx+esi+304]
	add	edx, DWORD PTR tv292[ebp]
	lea	ecx, DWORD PTR [eax*8]
	push	ecx
	push	edx
$LN20@restore_ve:
	push	edi
	call	_memcpy

; 983  :     for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+616, esi
	jle	$LN1@restore_ve
	add	ebx, 48					; 00000030H
	npad	2
$LL6@restore_ve:

; 984  :        x[i] = eval(bdry->coordf[i],p,v_id,NULL);

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR [ebx]
	push	0
	push	eax
	push	edi
	push	ecx
	call	_eval
	mov	edx, DWORD PTR _x$[ebp]
	fstp	QWORD PTR [edx+esi*8]
	inc	esi
	add	esp, 16					; 00000010H
	add	ebx, 4
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL6@restore_ve
	pop	edi
	pop	esi
	pop	ebx

; 993  :   }
; 994  : } /* end restore_vertex() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@restore_ve:

; 985  :   }
; 986  :   else
; 987  :   { if ( mode == SAVE_SEPARATE )

	cmp	DWORD PTR _mode$[ebp], 2
	jne	SHORT $LN2@restore_ve

; 988  :       memcpy((char *)get_coord(v_id),(char *)(saver->coord+loc_ordinal(v_id)),
; 989  :                                                          sizeof(REAL)*SDIM);

	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN17@restore_ve
	or	ecx, -1
$LN17@restore_ve:
	mov	eax, DWORD PTR _web+616
	add	eax, eax
	add	eax, eax
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	eax, eax
	push	eax
	mov	eax, DWORD PTR _saver$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _dymem
	push	ecx
	mov	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+eax+64]
	add	ecx, edx
	push	ecx

; 990  :     else
; 991  :       memcpy((char *)get_coord(v_id),(char *)(get_oldcoord(v_id)),
; 992  :                                                          sizeof(REAL)*SDIM);

	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 993  :   }
; 994  : } /* end restore_vertex() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@restore_ve:

; 990  :     else
; 991  :       memcpy((char *)get_coord(v_id),(char *)(get_oldcoord(v_id)),
; 992  :                                                          sizeof(REAL)*SDIM);

	mov	esi, DWORD PTR _web+616
	mov	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edi+ecx*4]
	add	esi, esi
	add	esi, esi
	add	esi, esi
	push	esi
	mov	esi, DWORD PTR [eax+edx+304]
	mov	edx, DWORD PTR [eax+edx+64]
	add	esi, ecx
	add	edx, ecx
	push	esi
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@restore_ve:
	pop	edi
	pop	esi
	pop	ebx

; 993  :   }
; 994  : } /* end restore_vertex() */

	mov	esp, ebp
	pop	ebp
	ret	0
_restore_vertex ENDP
_TEXT	ENDS
PUBLIC	_local_unsave_coords
; Function compile flags: /Ogtp
;	COMDAT _local_unsave_coords
_TEXT	SEGMENT
_saver$ = 8						; size = 4
_mode$ = 12						; size = 4
_local_unsave_coords PROC				; COMDAT

; 1027 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 1028 :     if ( saver->coord )

	mov	esi, DWORD PTR _saver$[ebp]
	mov	eax, DWORD PTR [esi]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN4@local_unsa

; 1029 :       temp_free( (char *)saver->coord );

	push	eax
	call	_temp_free
	add	esp, 4
$LN4@local_unsa:

; 1030 :     saver->coord = NULL;
; 1031 :     if ( saver->bod )

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi], edi
	cmp	eax, edi
	je	SHORT $LN3@local_unsa

; 1032 :       temp_free( (char *)saver->bod );

	push	eax
	call	_temp_free
	add	esp, 4
$LN3@local_unsa:

; 1033 :     saver->bod = NULL;
; 1034 :     if ( saver->quant )

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+16], edi
	cmp	eax, edi
	je	SHORT $LN2@local_unsa

; 1035 :       temp_free( (char *)saver->quant );

	push	eax
	call	_temp_free
	add	esp, 4
$LN2@local_unsa:

; 1036 :     saver->quant = NULL;
; 1037 :     if ( saver->meth )

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+24], edi
	cmp	eax, edi
	je	SHORT $LN7@local_unsa

; 1038 :       temp_free( (char *)saver->meth );

	push	eax
	call	_temp_free
	add	esp, 4
$LN7@local_unsa:

; 1039 :     saver->meth = NULL;

	mov	DWORD PTR [esi+20], edi
	pop	edi
	pop	esi

; 1040 :   
; 1041 : } // end local_unsave_coords()

	pop	ebp
	ret	0
_local_unsave_coords ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@NFCADAGI@One?5long?5jiggle?5done?4?6?$AA@ ; `string'
PUBLIC	__real@401921fb54442d18
PUBLIC	??_C@_0BP@HDOOBOAE@Enter?5amplitude?5?$CI?$CFf?0?$CFf?0?$CFf?$DLr?$CJ?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BF@HPGGJMHB@Enter?5phase?5?$CI?$CFf?$DLr?$CJ?3?5?$AA@ ; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40dfffc000000000
PUBLIC	??_C@_0BN@PMCKGDPJ@Wrong?5number?5of?5components?4?6?$AA@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0CB@KADMLKFG@Enter?5wave?5vector?5?$CI?$CFf?0?$CFf?0?$CFf?$DLr?$CJ?3?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_long_jiggle
EXTRN	_const_expr:PROC
EXTRN	_dot:PROC
EXTRN	_rand:PROC
EXTRN	_srand:PROC
EXTRN	_atoi:PROC
EXTRN	_outstring:PROC
EXTRN	_read_const:PROC
EXTRN	_cmdptr:DWORD
EXTRN	_isalpha:PROC
EXTRN	_fprintf:PROC
EXTRN	_logfd:DWORD
EXTRN	_prompt:PROC
EXTRN	_sprintf:PROC
EXTRN	_msg:DWORD
EXTRN	_resize:PROC
EXTRN	_overall_size:QWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIsin:PROC
_BSS	SEGMENT
_amp	DQ	06H DUP (?)
_phase	DQ	01H DUP (?)
_wavev	DQ	06H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BH@NFCADAGI@One?5long?5jiggle?5done?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@NFCADAGI@One?5long?5jiggle?5done?4?6?$AA@ DB 'One long jiggle d'
	DB	'one.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@401921fb54442d18
CONST	SEGMENT
__real@401921fb54442d18 DQ 0401921fb54442d18r	; 6.28319
CONST	ENDS
;	COMDAT ??_C@_0BP@HDOOBOAE@Enter?5amplitude?5?$CI?$CFf?0?$CFf?0?$CFf?$DLr?$CJ?3?5?$AA@
CONST	SEGMENT
??_C@_0BP@HDOOBOAE@Enter?5amplitude?5?$CI?$CFf?0?$CFf?0?$CFf?$DLr?$CJ?3?5?$AA@ DB 'E'
	DB	'nter amplitude (%f,%f,%f;r): ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HPGGJMHB@Enter?5phase?5?$CI?$CFf?$DLr?$CJ?3?5?$AA@
CONST	SEGMENT
??_C@_0BF@HPGGJMHB@Enter?5phase?5?$CI?$CFf?$DLr?$CJ?3?5?$AA@ DB 'Enter ph'
	DB	'ase (%f;r): ', 00H				; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@40dfffc000000000
CONST	SEGMENT
__real@40dfffc000000000 DQ 040dfffc000000000r	; 32767
CONST	ENDS
;	COMDAT ??_C@_0BN@PMCKGDPJ@Wrong?5number?5of?5components?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@PMCKGDPJ@Wrong?5number?5of?5components?4?6?$AA@ DB 'Wrong numbe'
	DB	'r of components.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KADMLKFG@Enter?5wave?5vector?5?$CI?$CFf?0?$CFf?0?$CFf?$DLr?$CJ?3?5@
CONST	SEGMENT
??_C@_0CB@KADMLKFG@Enter?5wave?5vector?5?$CI?$CFf?0?$CFf?0?$CFf?$DLr?$CJ?3?5@ DB 'E'
	DB	'nter wave vector (%f,%f,%f;r): ', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _long_jiggle
_TEXT	SEGMENT
tv705 = -160						; size = 8
_val$89961 = -160					; size = 8
tv1264 = -156						; size = 4
tv1235 = -156						; size = 4
tv1222 = -156						; size = 4
_val$89984 = -152					; size = 48
_val$89942 = -152					; size = 48
_response$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_long_jiggle PROC					; COMDAT

; 1097 : { REAL mag;

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1098 :   REAL ww; 
; 1099 :   int j;
; 1100 :   vertex_id v_id;
; 1101 :   REAL *x;
; 1102 :   char response[100];
; 1103 : 
; 1104 :   if ( overall_size <= 0 ) resize();

	fldz
	fcomp	QWORD PTR _overall_size
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN171@long_jiggl
	call	_resize

; 1105 :   if ( overall_size <= 0 ) return;

	fldz
	fcomp	QWORD PTR _overall_size
	fnstsw	ax
	test	ah, 1
	je	$LN65@long_jiggl
$LN171@long_jiggl:
	push	esi
	push	edi
	npad	4
$get_wv$89921:

; 1106 : 
; 1107 :   /* get wave vector */
; 1108 : get_wv:
; 1109 : #ifdef FLOAT128
; 1110 :   sprintf(msg,"Enter wave vector (%Qf,%Qf,%Qf;r): ",wavev[0],wavev[1],wavev[2]);
; 1111 : #elif defined(LONGDOUBLE)
; 1112 :   sprintf(msg,"Enter wave vector (%Lf,%Lf,%Lf;r): ",wavev[0],wavev[1],wavev[2]);
; 1113 : #else
; 1114 :   sprintf(msg,"Enter wave vector (%f,%f,%f;r): ",wavev[0],wavev[1],wavev[2]);

	fld	QWORD PTR _wavev+16
	mov	eax, DWORD PTR _msg
	sub	esp, 24					; 00000018H
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR _wavev+8
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _wavev
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CB@KADMLKFG@Enter?5wave?5vector?5?$CI?$CFf?0?$CFf?0?$CFf?$DLr?$CJ?3?5@
	push	eax
	call	_sprintf

; 1115 : #endif
; 1116 :   prompt(msg,response,sizeof(response));

	mov	edx, DWORD PTR _msg
	push	100					; 00000064H
	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	push	edx
	call	_prompt

; 1117 :   if ( logfd ) fprintf(logfd,"%s\n",response);

	mov	eax, DWORD PTR _logfd
	add	esp, 44					; 0000002cH
	test	eax, eax
	je	SHORT $LN62@long_jiggl
	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN62@long_jiggl:

; 1118 :   if ( response[0] == 'r' )

	mov	al, BYTE PTR _response$[ebp]
	cmp	al, 114					; 00000072H
	je	SHORT $LN85@long_jiggl

; 1134 :     }
; 1135 :   else if ( isalpha(response[0]) ) return; /* escape without jiggle */

	movsx	edx, al
	push	edx
	call	_isalpha
	add	esp, 4
	test	eax, eax
	jne	$LN186@long_jiggl

; 1136 :   else if ( response[0] )

	cmp	BYTE PTR _response$[ebp], al
	je	$get_phase$89951

; 1137 :     { REAL val[MAXCOORD];
; 1138 :       cmdptr = response;

	lea	eax, DWORD PTR _response$[ebp]
	mov	DWORD PTR _cmdptr, eax

; 1139 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi

; 1140 :          if ( read_const(val+j) <= 0 )

	lea	edi, DWORD PTR _val$89942[ebp]
	npad	12
$LL172@long_jiggl:

; 1139 :       for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	cmp	esi, ecx
	jge	$LN43@long_jiggl

; 1140 :          if ( read_const(val+j) <= 0 )

	push	edi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN84@long_jiggl

; 1139 :       for ( j = 0 ; j < SDIM ; j++ )

	inc	esi
	add	edi, 8
	jmp	SHORT $LL172@long_jiggl
$LN84@long_jiggl:

; 1141 :          { outstring("Wrong number of components.\n");

	push	OFFSET ??_C@_0BN@PMCKGDPJ@Wrong?5number?5of?5components?4?6?$AA@
	call	_outstring
	add	esp, 4
	jmp	$get_wv$89921
$LN85@long_jiggl:

; 1119 :     { /* random */
; 1120 :       prompt(msg,response,sizeof(response));

	mov	edx, DWORD PTR _msg
	push	100					; 00000064H
	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	push	edx
	call	_prompt

; 1121 :       if ( logfd ) fprintf(logfd,"%s\n",response);

	mov	eax, DWORD PTR _logfd
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN60@long_jiggl
	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN60@long_jiggl:

; 1122 :       if ( atoi(response) != 0 ) srand(atoi(response));

	lea	edx, DWORD PTR _response$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	test	eax, eax
	je	SHORT $LN58@long_jiggl
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	call	_atoi
	push	eax
	call	_srand
	add	esp, 8
	jmp	SHORT $LN58@long_jiggl
$LL190@long_jiggl:
	fstp	ST(0)
$LN58@long_jiggl:

; 1123 : 
; 1124 :       /* pick random wavelength in unit sphere */
; 1125 :       do 
; 1126 :          { for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN53@long_jiggl
$LL174@long_jiggl:

; 1127 :               wavev[j] = 1 - 2*(REAL)(rand()&0x7FFF)/0x7FFFL;

	call	_rand
	and	eax, 32767				; 00007fffH
	mov	DWORD PTR tv1264[ebp], eax
	fild	DWORD PTR tv1264[ebp]
	mov	eax, DWORD PTR _web+616
	inc	esi
	fadd	ST(0), ST(0)
	fdiv	QWORD PTR __real@40dfffc000000000
	fld1
	fsubrp	ST(1), ST(0)
	fstp	QWORD PTR _wavev[esi*8-8]
	cmp	esi, eax
	jl	SHORT $LL174@long_jiggl
$LN53@long_jiggl:

; 1128 :               ww = SDIM_dot(wavev,wavev);

	push	eax
	push	OFFSET _wavev
	push	OFFSET _wavev
	call	_dot

; 1129 :          }
; 1130 :       while ( ww > 1.0 );

	fld1
	fcomp	ST(1)
	add	esp, 12					; 0000000cH
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LL190@long_jiggl

; 1131 :       /* invert to wavevector and scale to surface size */
; 1132 :       for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR _web+616
	fld	QWORD PTR _overall_size
	xor	eax, eax
	cmp	edx, 4
	jl	SHORT $LC100@long_jiggl
	fld	ST(0)
	lea	ecx, DWORD PTR [edx-3]
	fmul	ST(0), ST(2)
$LN175@long_jiggl:

; 1133 :          wavev[j] /= ww*overall_size;

	fld	QWORD PTR _wavev[eax*8]
	add	eax, 4
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _wavev[eax*8-32]
	fld	QWORD PTR _wavev[eax*8-24]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _wavev[eax*8-24]
	fld	QWORD PTR _wavev[eax*8-16]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _wavev[eax*8-16]
	fld	QWORD PTR _wavev[eax*8-8]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _wavev[eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN175@long_jiggl

; 1131 :       /* invert to wavevector and scale to surface size */
; 1132 :       for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
$LC100@long_jiggl:
	cmp	eax, edx
	jge	SHORT $LL198@long_jiggl
	fmulp	ST(1), ST(0)
$LC176@long_jiggl:

; 1133 :          wavev[j] /= ww*overall_size;

	fld	QWORD PTR _wavev[eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _wavev[eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC176@long_jiggl

; 1134 :     }
; 1135 :   else if ( isalpha(response[0]) ) return; /* escape without jiggle */

	jmp	SHORT $LN219@long_jiggl
$LN43@long_jiggl:

; 1142 :             goto get_wv;
; 1143 :          }
; 1144 :       for ( j = 0 ; j < SDIM ; j++ ) wavev[j] = val[j];

	test	ecx, ecx
	jle	SHORT $get_phase$89951
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	lea	esi, DWORD PTR _val$89942[ebp]
	mov	edi, OFFSET _wavev
	rep movsd
	jmp	SHORT $get_phase$89951
$LL198@long_jiggl:
	fstp	ST(1)
$LN219@long_jiggl:
	fstp	ST(0)
$get_phase$89951:

; 1145 :     }
; 1146 : 
; 1147 :   /* pick random phase */
; 1148 : get_phase:
; 1149 :   sprintf(msg,"Enter phase (%f;r): ",(DOUBLE)phase);

	fld	QWORD PTR _phase
	mov	ecx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BF@HPGGJMHB@Enter?5phase?5?$CI?$CFf?$DLr?$CJ?3?5?$AA@
	push	ecx
	call	_sprintf

; 1150 :   prompt(msg,response,sizeof(response));

	mov	eax, DWORD PTR _msg
	push	100					; 00000064H
	lea	edx, DWORD PTR _response$[ebp]
	push	edx
	push	eax
	call	_prompt

; 1151 :   if ( logfd ) fprintf(logfd,"%s\n",response);

	mov	eax, DWORD PTR _logfd
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN38@long_jiggl
	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN38@long_jiggl:

; 1152 :   if ( response[0] == 'r' )

	mov	al, BYTE PTR _response$[ebp]
	cmp	al, 114					; 00000072H
	je	$LN87@long_jiggl

; 1154 :   else if ( isalpha(response[0]) ) return; /* escape without jiggle */

	movsx	edx, al
	push	edx
	call	_isalpha
	add	esp, 4
	test	eax, eax
	jne	$LN186@long_jiggl

; 1155 :   else if ( response[0] )

	cmp	BYTE PTR _response$[ebp], al
	je	SHORT $LN178@long_jiggl

; 1156 :      { REAL val;
; 1157 :         if ( const_expr(response,&val) <= 0 )

	lea	eax, DWORD PTR _val$89961[ebp]
	push	eax
	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	call	_const_expr
	add	esp, 8
	test	eax, eax
	jle	$get_phase$89951

; 1158 :           goto get_phase;
; 1159 :         phase = val;

	fld	QWORD PTR _val$89961[ebp]
$LN220@long_jiggl:
	fstp	QWORD PTR _phase
$LN178@long_jiggl:
	push	ebx
	npad	4
$get_amp$89963:

; 1160 :      }
; 1161 : 
; 1162 :   /* amplitude */  
; 1163 : get_amp:
; 1164 :   sprintf(msg,"Enter amplitude (%f,%f,%f;r): ",(DOUBLE)amp[0],(DOUBLE)amp[1],(DOUBLE)amp[2]);

	fld	QWORD PTR _amp+16
	mov	edx, DWORD PTR _msg
	sub	esp, 24					; 00000018H
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR _amp+8
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _amp
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BP@HDOOBOAE@Enter?5amplitude?5?$CI?$CFf?0?$CFf?0?$CFf?$DLr?$CJ?3?5?$AA@
	push	edx
	call	_sprintf

; 1165 :   prompt(msg,response,sizeof(response));

	mov	ecx, DWORD PTR _msg
	push	100					; 00000064H
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	push	ecx
	call	_prompt

; 1166 :   if ( logfd ) fprintf(logfd,"%s\n",response);

	mov	eax, DWORD PTR _logfd
	add	esp, 44					; 0000002cH
	test	eax, eax
	je	SHORT $LN31@long_jiggl
	lea	edx, DWORD PTR _response$[ebp]
	push	edx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN31@long_jiggl:

; 1167 :   if ( response[0] == 'r' )

	mov	al, BYTE PTR _response$[ebp]
	cmp	al, 114					; 00000072H
	je	$LL29@long_jiggl

; 1176 :     }  
; 1177 :   else if ( isalpha(response[0]) ) return; /* escape without jiggle */

	movsx	eax, al
	push	eax
	call	_isalpha
	add	esp, 4
	test	eax, eax
	jne	$LN188@long_jiggl

; 1178 :   else if ( response[0] )

	cmp	BYTE PTR _response$[ebp], al
	je	$LN168@long_jiggl

; 1179 :     { REAL val[MAXCOORD];
; 1180 :       cmdptr = response;

	lea	ecx, DWORD PTR _response$[ebp]
	mov	DWORD PTR _cmdptr, ecx

; 1181 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	lea	edi, DWORD PTR _val$89984[ebp]
	npad	6
$LL179@long_jiggl:
	mov	ebx, DWORD PTR _web+616
	cmp	esi, ebx
	jge	$LN14@long_jiggl

; 1182 :          if ( read_const(val+j) <= 0 )

	push	edi
	call	_read_const
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN89@long_jiggl

; 1181 :       for ( j = 0 ; j < SDIM ; j++ )

	inc	esi
	add	edi, 8
	jmp	SHORT $LL179@long_jiggl
$LN87@long_jiggl:

; 1153 :      phase = 2*M_PI*(REAL)(rand()&0x7FFF)/0x7FFFL;

	call	_rand
	and	eax, 32767				; 00007fffH
	mov	DWORD PTR tv1235[ebp], eax
	fild	DWORD PTR tv1235[ebp]
	fmul	QWORD PTR __real@401921fb54442d18
	fdiv	QWORD PTR __real@40dfffc000000000
	jmp	$LN220@long_jiggl
$LN89@long_jiggl:

; 1183 :          { outstring("Wrong number of components.\n");

	push	OFFSET ??_C@_0BN@PMCKGDPJ@Wrong?5number?5of?5components?4?6?$AA@
	call	_outstring
	add	esp, 4
	jmp	$get_amp$89963
	npad	6
$LL29@long_jiggl:

; 1168 :     { /* random */
; 1169 :       /* pick random amplitude */
; 1170 :       do 
; 1171 :          for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN28@long_jiggl
	npad	5
$LL181@long_jiggl:

; 1172 :             amp[j] = 1 - 2*(REAL)(rand()&0x7FFF)/0x7FFFL;

	call	_rand
	and	eax, 32767				; 00007fffH
	mov	DWORD PTR tv1222[ebp], eax
	fild	DWORD PTR tv1222[ebp]
	mov	eax, DWORD PTR _web+616
	inc	esi
	fadd	ST(0), ST(0)
	fdiv	QWORD PTR __real@40dfffc000000000
	fld1
	fsubrp	ST(1), ST(0)
	fstp	QWORD PTR _amp[esi*8-8]
	cmp	esi, eax
	jl	SHORT $LL181@long_jiggl
$LN28@long_jiggl:

; 1173 :       while ( SDIM_dot(amp,amp) > 1.0 );

	push	eax
	push	OFFSET _amp
	push	OFFSET _amp
	call	_dot
	fcomp	QWORD PTR __real@3ff0000000000000
	add	esp, 12					; 0000000cH
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LL29@long_jiggl

; 1174 :       for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _web+616
	fld	QWORD PTR _overall_size
	fld	QWORD PTR _web+1576
	xor	eax, eax
	cmp	ebx, 4
	jl	SHORT $LC103@long_jiggl
	fld	ST(0)
	lea	ecx, DWORD PTR [ebx-3]
	fmul	ST(0), ST(2)
$LN182@long_jiggl:

; 1175 :          amp[j] *= web.temperature*overall_size;

	fld	ST(0)
	add	eax, 4
	fmul	QWORD PTR _amp[eax*8-32]
	fstp	QWORD PTR _amp[eax*8-32]
	fld	ST(0)
	fmul	QWORD PTR _amp[eax*8-24]
	fstp	QWORD PTR _amp[eax*8-24]
	fld	QWORD PTR _amp[eax*8-16]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _amp[eax*8-16]
	fld	ST(0)
	fmul	QWORD PTR _amp[eax*8-8]
	fstp	QWORD PTR _amp[eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN182@long_jiggl

; 1174 :       for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
$LC103@long_jiggl:
	cmp	eax, ebx
	jge	SHORT $LN209@long_jiggl
	fmulp	ST(1), ST(0)
$LC183@long_jiggl:

; 1175 :          amp[j] *= web.temperature*overall_size;

	fld	ST(0)
	inc	eax
	fmul	QWORD PTR _amp[eax*8-8]
	fstp	QWORD PTR _amp[eax*8-8]
	cmp	eax, ebx
	jl	SHORT $LC183@long_jiggl

; 1176 :     }  
; 1177 :   else if ( isalpha(response[0]) ) return; /* escape without jiggle */

	jmp	SHORT $LN221@long_jiggl
$LN14@long_jiggl:

; 1184 :             goto get_amp;
; 1185 :          }
; 1186 :       for ( j = 0 ; j < SDIM ; j++ ) amp[j] = val[j];

	test	ebx, ebx
	jle	SHORT $LN12@long_jiggl
	mov	ecx, ebx
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	lea	esi, DWORD PTR _val$89984[ebp]
	mov	edi, OFFSET _amp
	rep movsd
	jmp	SHORT $LN12@long_jiggl
$LN168@long_jiggl:
	mov	ebx, DWORD PTR _web+616
	jmp	SHORT $LN12@long_jiggl
$LN209@long_jiggl:
	fstp	ST(1)
$LN221@long_jiggl:
	fstp	ST(0)
$LN12@long_jiggl:

; 1187 :     }
; 1188 : 
; 1189 :   /* move vertices */
; 1190 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	$LN7@long_jiggl
$LL184@long_jiggl:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edi, DWORD PTR [eax+eax]
	mov	edx, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv705[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN8@long_jiggl

; 1191 :      { if ( get_vattr(v_id) & FIXED ) continue;

	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN8@long_jiggl

; 1192 :         x = get_coord(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [ecx+eax+64]
	add	esi, edx

; 1193 :         mag = sin(SDIM_dot(wavev,x) + phase);

	push	ebx
	push	esi
	push	OFFSET _wavev
	call	_dot
	fadd	QWORD PTR _phase
	add	esp, 12					; 0000000cH
	call	__CIsin

; 1194 :         for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _web+616
	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN218@long_jiggl
	mov	edx, OFFSET _amp
	mov	eax, esi
	sub	edx, esi
$LN185@long_jiggl:

; 1195 :           x[j] += amp[j]*mag;

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	ebx, DWORD PTR _web+616
	cmp	ecx, ebx
	jl	SHORT $LN185@long_jiggl
$LN218@long_jiggl:

; 1194 :         for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
$LN8@long_jiggl:

; 1187 :     }
; 1188 : 
; 1189 :   /* move vertices */
; 1190 :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	$LL184@long_jiggl
$LN7@long_jiggl:

; 1196 :      }
; 1197 :   outstring("One long jiggle done.\n");

	push	OFFSET ??_C@_0BH@NFCADAGI@One?5long?5jiggle?5done?4?6?$AA@
	call	_outstring
	add	esp, 4
$LN188@long_jiggl:
	pop	ebx
$LN186@long_jiggl:
	pop	edi
	pop	esi
$LN65@long_jiggl:

; 1198 : } /* end long_jiggle() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_long_jiggle ENDP
_TEXT	ENDS
PUBLIC	__real@4014000000000000
PUBLIC	__real@4004000000000000
PUBLIC	__real@4003333333333333
PUBLIC	_gaussian
EXTRN	__CIsqrt:PROC
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@4004000000000000
CONST	SEGMENT
__real@4004000000000000 DQ 04004000000000000r	; 2.5
CONST	ENDS
;	COMDAT __real@4003333333333333
CONST	SEGMENT
__real@4003333333333333 DQ 04003333333333333r	; 2.4
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _gaussian
_TEXT	SEGMENT
_sum$ = -12						; size = 8
tv143 = -4						; size = 4
_gaussian PROC						; COMDAT

; 1209 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1210 :   int k;
; 1211 :   REAL sum = 0.0;

	fldz
	push	esi
	fstp	QWORD PTR _sum$[ebp]
	mov	esi, 5
$LL3@gaussian:

; 1212 : 
; 1213 :   for ( k = 0 ; k < 5 ; k++ ) sum += (REAL)(rand()&0x7FFF);

	call	_rand
	and	eax, 32767				; 00007fffH
	dec	esi
	mov	DWORD PTR tv143[ebp], eax
	fild	DWORD PTR tv143[ebp]
	fadd	QWORD PTR _sum$[ebp]
	fstp	QWORD PTR _sum$[ebp]
	jne	SHORT $LL3@gaussian

; 1214 :   return (sum/0x7FFFL - 2.5)/5*sqrt(12.0/5);

	fld	QWORD PTR __real@4003333333333333
	call	__CIsqrt
	fld	QWORD PTR _sum$[ebp]
	fdiv	QWORD PTR __real@40dfffc000000000
	pop	esi
	fsub	QWORD PTR __real@4004000000000000
	fdiv	QWORD PTR __real@4014000000000000
	fmulp	ST(1), ST(0)

; 1215 : } // end gaussian()

	mov	esp, ebp
	pop	ebp
	ret	0
_gaussian ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_v_estimate
EXTRN	_eval_all:PROC
; Function compile flags: /Ogtp
;	COMDAT _v_estimate
_TEXT	SEGMENT
_dummy$90057 = -96					; size = 8
_change$ = -88						; size = 8
tv330 = -80						; size = 8
_delta$ = -80						; size = 8
tv324 = -72						; size = 4
_pcount$90064 = -68					; size = 4
_v_id$ = -64						; size = 4
tv759 = -60						; size = 4
_param$90065 = -60					; size = 4
tv522 = -56						; size = 4
_i$ = -56						; size = 4
_temp$90056 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_v_estimate PROC					; COMDAT

; 1255 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1256 :   vertex_id v_id;
; 1257 :   REAL *force;
; 1258 :   REAL *velocity;
; 1259 :   int i,j;
; 1260 :   REAL change = 0.0;
; 1261 :   REAL delta;
; 1262 : 
; 1263 :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+48
	fldz
	fst	QWORD PTR _change$[ebp]
	mov	DWORD PTR _v_id$[ebp], ecx
	test	ecx, 268435456				; 10000000H
	je	$LN12@v_estimate
	fld	QWORD PTR _web+1512
	mov	edx, DWORD PTR _web+616
	push	ebx
	push	esi
	push	edi
	jmp	SHORT $LN14@v_estimate
$LN29@v_estimate:
	mov	ecx, DWORD PTR _v_id$[ebp]
$LN14@v_estimate:
	mov	ebx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+ebx]
	mov	esi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv330[ebp+4], eax
	mov	eax, esi
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	mov	DWORD PTR tv324[ebp], ecx
	je	$LN13@v_estimate

; 1264 :   { if ( get_vattr(v_id) & FIXED ) continue;

	and	esi, 64					; 00000040H
	xor	eax, eax
	or	esi, eax
	jne	$LN13@v_estimate

; 1265 :     force = get_force(v_id);

	mov	eax, DWORD PTR [ecx+ebx]

; 1266 :     velocity = get_velocity(v_id);
; 1267 :     delta = 0.0;

	fldz
	mov	esi, DWORD PTR _web+104
	fst	QWORD PTR _delta$[ebp]
	mov	edi, DWORD PTR _dymem
	mov	ebx, DWORD PTR [esi+edi+784]
	mov	edi, DWORD PTR [esi+edi+1024]
	add	ebx, eax
	add	edi, eax

; 1268 :     if ( get_vattr(v_id) & BOUNDARY )

	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	esi, esi
	or	eax, esi
	je	$LN8@v_estimate

; 1269 :     { REAL temp[MAXCOORD],dummy;
; 1270 :       struct boundary *boundary = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN17@v_estimate
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edx, DWORD PTR _web+12
	mov	edx, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax+edx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN18@v_estimate
$LN17@v_estimate:
	xor	eax, eax
$LN18@v_estimate:

; 1271 :       int pcount = boundary->pcount;

	mov	edx, DWORD PTR [eax+40]

; 1272 :       REAL *param = get_param(v_id);

	mov	esi, DWORD PTR _dymem
	mov	DWORD PTR _pcount$90064[ebp], edx
	mov	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+esi+544]
	mov	esi, DWORD PTR _web+12
	add	edx, DWORD PTR [ecx+esi]

; 1273 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	mov	DWORD PTR _param$90065[ebp], edx
	mov	edx, DWORD PTR _web+616
	test	edx, edx
	jle	SHORT $LN31@v_estimate
	add	eax, 48					; 00000030H
	fstp	ST(0)
	mov	DWORD PTR tv522[ebp], eax
$LL65@v_estimate:

; 1274 :       { eval_all(boundary->coordf[j],param,pcount,&dummy,temp,v_id);

	mov	eax, DWORD PTR _v_id$[ebp]
	fstp	ST(0)
	push	eax
	fstp	ST(0)
	mov	eax, DWORD PTR _pcount$90064[ebp]
	lea	ecx, DWORD PTR _temp$90056[ebp]
	push	ecx
	mov	ecx, DWORD PTR _param$90065[ebp]
	lea	edx, DWORD PTR _dummy$90057[ebp]
	push	edx
	mov	edx, DWORD PTR tv522[ebp]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	eax
	call	_eval_all

; 1275 :         delta += web.scale*force[j]*dot(temp,velocity,pcount);

	mov	ecx, DWORD PTR _pcount$90064[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp$90056[ebp]
	push	edi
	push	edx
	call	_dot
	fld	QWORD PTR [ebx+esi*8]
	fld	QWORD PTR _web+1512
	mov	edx, DWORD PTR _web+616
	add	DWORD PTR tv522[ebp], 4
	fmul	ST(1), ST(0)
	fxch	ST(2)
	inc	esi
	add	esp, 36					; 00000024H
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR _delta$[ebp]
	fst	QWORD PTR _delta$[ebp]
	cmp	esi, edx
	jl	SHORT $LL65@v_estimate

; 1276 :       }
; 1277 :     }
; 1278 :     else

	fld	QWORD PTR _change$[ebp]
	mov	ecx, DWORD PTR tv324[ebp]
	fxch	ST(2)
	fxch	ST(1)
$LN31@v_estimate:

; 1281 :     }
; 1282 :     change += delta;

	mov	ebx, DWORD PTR _web+12
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _change$[ebp]
	fxch	ST(1)
$LN13@v_estimate:

; 1256 :   vertex_id v_id;
; 1257 :   REAL *force;
; 1258 :   REAL *velocity;
; 1259 :   int i,j;
; 1260 :   REAL change = 0.0;
; 1261 :   REAL delta;
; 1262 : 
; 1263 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [ecx+ebx]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _v_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LN29@v_estimate
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx
$LN12@v_estimate:

; 1283 :   }
; 1284 :   return change;
; 1285 : } /* end v_estimate() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@v_estimate:

; 1279 :     { for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	edx, 4
	jl	SHORT $LC26@v_estimate

; 1280 :         delta += web.scale*force[i]*velocity[i];

	mov	esi, ebx
	sub	esi, edi
	mov	DWORD PTR tv759[ebp], esi
	lea	esi, DWORD PTR [edx-4]
	shr	esi, 2
	inc	esi
	lea	edx, DWORD PTR [esi*4]
	mov	DWORD PTR _i$[ebp], edx
	mov	edx, DWORD PTR tv759[ebp]
	lea	ecx, DWORD PTR [ebx+24]
	lea	eax, DWORD PTR [edi+8]
$LN27@v_estimate:
	fld	QWORD PTR [ecx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(2)
	add	ecx, 32					; 00000020H
	dec	esi
	fmul	QWORD PTR [eax-40]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx+eax-32]
	fmul	ST(0), ST(2)
	fmul	QWORD PTR [eax-32]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-40]
	fmul	ST(0), ST(2)
	fmul	QWORD PTR [eax-24]
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	QWORD PTR [ecx-32]
	fmul	QWORD PTR [eax-16]
	faddp	ST(1), ST(0)
	jne	SHORT $LN27@v_estimate

; 1279 :     { for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR tv324[ebp]
	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _i$[ebp]
$LC26@v_estimate:
	cmp	eax, edx
	jge	$LN31@v_estimate
	mov	esi, edx
	sub	ebx, edi
	sub	esi, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [edi+eax*8]
$LC3@v_estimate:

; 1280 :         delta += web.scale*force[i]*velocity[i];

	fld	QWORD PTR [eax+ebx]
	add	eax, 8
	dec	esi
	fmul	ST(0), ST(2)
	fmul	QWORD PTR [eax-8]
	faddp	ST(1), ST(0)
	jne	SHORT $LC3@v_estimate

; 1279 :     { for ( i = 0 ; i < SDIM ; i++ )

	jmp	$LN31@v_estimate
_v_estimate ENDP
_TEXT	ENDS
PUBLIC	__real@3fd5555555555555
PUBLIC	_homothety
EXTRN	_calc_content:PROC
EXTRN	_homothety_target:QWORD
EXTRN	_square_curvature_flag:DWORD
EXTRN	__CIpow:PROC
;	COMDAT __real@3fd5555555555555
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3fd5555555555555 DQ 03fd5555555555555r	; 0.333333
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\iterate.c
CONST	ENDS
;	COMDAT _homothety
_TEXT	SEGMENT
_vol$ = -8						; size = 8
_homothety PROC						; COMDAT

; 1296 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1297 :   body_id b_id;
; 1298 :   vertex_id v_id;
; 1299 :   REAL vol = 0.0;
; 1300 :   REAL *x;
; 1301 :   REAL scale;
; 1302 :   int i;
; 1303 : 
; 1304 :   if ( square_curvature_flag )

	cmp	DWORD PTR _square_curvature_flag, 0
	fldz
	push	esi
	fstp	QWORD PTR _vol$[ebp]
	push	edi
	je	SHORT $LN17@homothety@2

; 1305 :      scale = 1/pow(web.total_area/homothety_target,1.0/web.dimension);

	fld	QWORD PTR _web+992
	fdiv	QWORD PTR _homothety_target
	fild	DWORD PTR _web+620
	fld1
	fdivrp	ST(1), ST(0)

; 1306 :   else

	jmp	SHORT $LN59@homothety@2
$LN17@homothety@2:

; 1307 :   {
; 1308 :     /* be sure to have current volumes */
; 1309 :     calc_content(Q_FIXED); 

	push	2
	call	_calc_content
	fstp	ST(0)

; 1310 :     FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+384
	fld	QWORD PTR _vol$[ebp]
	mov	edx, eax
	shr	edx, 28					; 0000001cH
	add	esp, 4
	and	edx, 1
	je	SHORT $LN13@homothety@2
	mov	edi, DWORD PTR _web+348
	fldz
$LN31@homothety@2:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN14@homothety@2

; 1311 :         vol += get_body_volume(b_id);

	test	edx, edx
	je	SHORT $LN22@homothety@2
	fld	QWORD PTR [ecx+40]
	jmp	SHORT $LN23@homothety@2
$LN22@homothety@2:
	fld	ST(0)
$LN23@homothety@2:
	faddp	ST(2), ST(0)
$LN14@homothety@2:

; 1310 :     FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR [ecx]
	mov	edx, eax
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	SHORT $LN31@homothety@2
	fstp	ST(0)
$LN13@homothety@2:

; 1312 :     if ( web.representation == STRING ) scale = 1/sqrt(vol/homothety_target);

	cmp	DWORD PTR _web+624, 1
	fdiv	QWORD PTR _homothety_target
	jne	SHORT $LN10@homothety@2
	call	__CIsqrt
	jmp	SHORT $LN60@homothety@2
$LN10@homothety@2:

; 1313 :     else scale = 1/pow(vol/homothety_target,1/3.0);

	fld	QWORD PTR __real@3fd5555555555555
$LN59@homothety@2:
	call	__CIpow
$LN60@homothety@2:
	fld1

; 1314 :   }
; 1315 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	fdivrp	ST(1), ST(0)
	test	eax, 268435456				; 10000000H
	je	SHORT $LN34@homothety@2
	mov	edi, DWORD PTR _web+12
	push	ebx
	mov	ebx, DWORD PTR _web+616
$LN8@homothety@2:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	edx, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN7@homothety@2

; 1316 :   {  x = get_coord(v_id);

	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+eax+64]
	add	ecx, edx

; 1317 :      for ( i = 0 ; i < SDIM ; i++ ) x[i] *= scale;

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN7@homothety@2
$LN3@homothety@2:
	fld	ST(0)
	inc	eax
	fmul	QWORD PTR [ecx+eax*8-8]
	fstp	QWORD PTR [ecx+eax*8-8]
	mov	ebx, DWORD PTR _web+616
	cmp	eax, ebx
	jl	SHORT $LN3@homothety@2
	mov	edi, DWORD PTR _web+12
$LN7@homothety@2:

; 1314 :   }
; 1315 :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN8@homothety@2
	pop	ebx
$LN34@homothety@2:
	pop	edi
	fstp	ST(0)
	pop	esi

; 1318 :   }
; 1319 : } // end homothety()

	mov	esp, ebp
	pop	ebp
	ret	0
_homothety ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@NGCABKIE@Internal?5error?3?5Forces?5not?5saved@ ; `string'
PUBLIC	??_C@_0BC@PMHAOABE@old_force_ribiere?$AA@	; `string'
PUBLIC	_ribiere_calc
EXTRN	_kb_error:PROC
EXTRN	_find_attribute:PROC
;	COMDAT ??_C@_0DC@NGCABKIE@Internal?5error?3?5Forces?5not?5saved@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DC@NGCABKIE@Internal?5error?3?5Forces?5not?5saved@ DB 'Internal er'
	DB	'ror: Forces not saved for Ribiere CG.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PMHAOABE@old_force_ribiere?$AA@
CONST	SEGMENT
??_C@_0BC@PMHAOABE@old_force_ribiere?$AA@ DB 'old_force_ribiere', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\iterate.c
CONST	ENDS
;	COMDAT _ribiere_calc
_TEXT	SEGMENT
_rsum$ = -16						; size = 8
_f$90144 = -8						; size = 4
_r_attr$ = -4						; size = 4
_ribiere_calc PROC					; COMDAT

; 1378 : { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1379 :   REAL rsum = 0.0;

	fldz

; 1380 :   vertex_id v_id;
; 1381 : 
; 1382 :   int r_attr = find_attribute(VERTEX,RIBIERE_ATTR_NAME);

	push	OFFSET ??_C@_0BC@PMHAOABE@old_force_ribiere?$AA@
	push	0
	fstp	QWORD PTR _rsum$[ebp]
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _r_attr$[ebp], eax

; 1383 :   if ( r_attr < 0 )

	test	eax, eax
	jns	SHORT $LN10@ribiere_ca

; 1384 :       kb_error(1058,"Internal error: Forces not saved for Ribiere CG.\n",
; 1385 :           RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DC@NGCABKIE@Internal?5error?3?5Forces?5not?5saved@
	push	1058					; 00000422H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN10@ribiere_ca:

; 1386 : 
; 1387 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	$LN19@ribiere_ca
	push	ebx
	push	esi
	push	edi
	npad	8
$LL23@ribiere_ca:
	mov	edi, DWORD PTR _web+12
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+edi]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	edx, edx
	or	ecx, edx
	je	$LN8@ribiere_ca

; 1388 :   { REAL *f = get_force(v_id);

	mov	ecx, DWORD PTR [esi+edi]
	mov	edi, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edi+ebx+784]
	add	edx, ecx

; 1389 :     REAL *v = get_velocity(v_id);
; 1390 :     REAL *g = (REAL*)get_extra(v_id,r_attr);

	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	DWORD PTR _f$90144[ebp], edx
	mov	edx, DWORD PTR [edi+ebx+1024]
	mov	edi, DWORD PTR _r_attr$[ebp]
	mov	ebx, DWORD PTR _web[eax+104]
	imul	edi, 240				; 000000f0H
	mov	eax, DWORD PTR _web[eax+12]
	add	ebx, edi
	mov	edi, DWORD PTR _dymem
	mov	edi, DWORD PTR [ebx+edi+64]
	add	edi, DWORD PTR [eax+esi]

; 1391 : 
; 1392 :     if ( get_vattr(v_id) & (FIXED|BOUNDARY) ) continue;

	mov	eax, DWORD PTR [ecx+8]
	add	edx, ecx
	and	eax, 192				; 000000c0H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN8@ribiere_ca

; 1393 :     rsum += SDIM_dot(v,g);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	push	edi
	push	edx
	call	_dot
	fadd	QWORD PTR _rsum$[ebp]

; 1394 :     for ( i = 0 ; i < SDIM ; i++ ) g[i] = f[i]; 

	xor	eax, eax
	add	esp, 12					; 0000000cH
	fstp	QWORD PTR _rsum$[ebp]
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN8@ribiere_ca
	mov	ecx, DWORD PTR _f$90144[ebp]
	sub	ecx, edi
$LL3@ribiere_ca:
	fld	QWORD PTR [ecx+edi]
	inc	eax
	fstp	QWORD PTR [edi]
	add	edi, 8
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL3@ribiere_ca
$LN8@ribiere_ca:

; 1386 : 
; 1387 :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL23@ribiere_ca
	pop	edi
	pop	esi
	pop	ebx
$LN19@ribiere_ca:

; 1395 :   }
; 1396 :   return rsum;

	fld	QWORD PTR _rsum$[ebp]

; 1397 : } // end ribiere_calc()

	mov	esp, ebp
	pop	ebp
	ret	0
_ribiere_calc ENDP
_TEXT	ENDS
PUBLIC	_cg_sum_calc
; Function compile flags: /Ogtp
;	COMDAT _cg_sum_calc
_TEXT	SEGMENT
_sum$ = -8						; size = 8
_cg_sum_calc PROC					; COMDAT

; 1406 : { vertex_id v_id; 

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1407 :   REAL sum = 0.0;

	fldz

; 1408 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	fst	QWORD PTR _sum$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@cg_sum_cal
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _web+12
$LN6@cg_sum_cal:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN5@cg_sum_cal

; 1409 :   { REAL *f = get_force(v_id);

	mov	ebx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [edx+ebx+784]
	mov	eax, DWORD PTR [esi+edi]

; 1410 :     REAL *v = get_velocity(v_id);

	mov	edx, DWORD PTR [edx+ebx+1024]
	add	ecx, eax
	add	edx, eax

; 1411 :     if ( get_vattr(v_id) & (FIXED |BOUNDARY) ) continue;

	mov	eax, DWORD PTR [eax+8]
	and	eax, 192				; 000000c0H
	xor	ebx, ebx
	or	eax, ebx
	jne	SHORT $LN5@cg_sum_cal

; 1412 :     sum += SDIM_dot(v,f);

	mov	eax, DWORD PTR _web+616
	fstp	ST(0)
	push	eax
	push	ecx
	push	edx
	call	_dot
	fadd	QWORD PTR _sum$[ebp]
	mov	edi, DWORD PTR _web+12
	add	esp, 12					; 0000000cH
	fst	QWORD PTR _sum$[ebp]
$LN5@cg_sum_cal:

; 1408 :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN6@cg_sum_cal
	pop	edi
	pop	esi
	pop	ebx
$LN4@cg_sum_cal:

; 1413 :   }
; 1414 :   return sum;
; 1415 : } // end cg_sum_calc()

	mov	esp, ebp
	pop	ebp
	ret	0
_cg_sum_calc ENDP
_TEXT	ENDS
PUBLIC	_cg_direction_local
EXTRN	_cg_gamma:QWORD
EXTRN	_kb_calloc:PROC
EXTRN	_cg_hvector:DWORD
; Function compile flags: /Ogtp
;	COMDAT _cg_direction_local
_TEXT	SEGMENT
tv242 = -8						; size = 8
_cg_direction_local PROC				; COMDAT

; 1448 : { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1449 :   vertex_id v_id;
; 1450 :   REAL *v,*h;
; 1451 : 
; 1452 :   if ( cg_hvector == NULL )

	cmp	DWORD PTR _cg_hvector, 0
	jne	SHORT $LN10@cg_directi

; 1453 :   { /* reinitialize */
; 1454 :     cg_hvector = (REAL (*)[MAXCOORD])mycalloc(web.skel[VERTEX].max_ord+1,
; 1455 :                                          sizeof(REAL [MAXCOORD]));

	mov	eax, DWORD PTR _web+68
	push	1455					; 000005afH
	push	OFFSET ??_C@_09MIIJPAGP@ITERATE?4C?$AA@
	inc	eax
	push	48					; 00000030H
	push	eax
	call	_kb_calloc

; 1456 :     for ( i = 0 ; i < optparamcount ; i++ ) optparam[i].cg = 0.0;

	mov	ecx, DWORD PTR _optparamcount
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cg_hvector, eax
	test	ecx, ecx
	jle	SHORT $LN10@cg_directi

; 1453 :   { /* reinitialize */
; 1454 :     cg_hvector = (REAL (*)[MAXCOORD])mycalloc(web.skel[VERTEX].max_ord+1,
; 1455 :                                          sizeof(REAL [MAXCOORD]));

	fldz
	mov	eax, OFFSET _optparam+24
$LN12@cg_directi:

; 1456 :     for ( i = 0 ; i < optparamcount ; i++ ) optparam[i].cg = 0.0;

	fst	QWORD PTR [eax]
	add	eax, 56					; 00000038H
	dec	ecx
	jne	SHORT $LN12@cg_directi
	fstp	ST(0)
$LN10@cg_directi:

; 1457 :   }
; 1458 : 
; 1459 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	push	edi
	mov	edi, eax
	shr	edi, 28					; 0000001cH
	and	edi, 1
	je	$LN7@cg_directi
	push	ebx
	push	esi
$LL24@cg_directi:
	mov	ecx, DWORD PTR _web+12
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv242[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN8@cg_directi

; 1460 :   { if ( get_vattr(v_id) & (FIXED|BOUNDARY) ) continue;

	and	ecx, 192				; 000000c0H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN8@cg_directi

; 1461 :     h = cg_hvector[loc_ordinal(v_id)];

	test	edi, edi
	je	SHORT $LN16@cg_directi
	mov	eax, ebx
	jmp	SHORT $LN17@cg_directi
$LN16@cg_directi:
	or	eax, -1
$LN17@cg_directi:

; 1462 :     v = get_velocity(v_id);

	mov	ecx, DWORD PTR _dymem
	mov	esi, DWORD PTR _web+104
	mov	ecx, DWORD PTR [esi+ecx+1024]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, DWORD PTR _cg_hvector
	add	ecx, edx

; 1463 :     for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN8@cg_directi
	sub	ecx, eax
	npad	7
$LL3@cg_directi:

; 1464 :       h[i] = v[i] += cg_gamma*h[i];

	fld	QWORD PTR [eax]
	inc	edx
	fmul	QWORD PTR _cg_gamma
	add	eax, 8
	fadd	QWORD PTR [ecx+eax-8]
	fst	QWORD PTR [ecx+eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL3@cg_directi
$LN8@cg_directi:

; 1457 :   }
; 1458 : 
; 1459 :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	eax, DWORD PTR [eax]
	mov	edi, eax
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	$LL24@cg_directi
	pop	esi
	pop	ebx
$LN7@cg_directi:
	pop	edi

; 1465 :   }
; 1466 : } // end cg_direction_local()

	mov	esp, ebp
	pop	ebp
	ret	0
_cg_direction_local ENDP
_TEXT	ENDS
PUBLIC	_cg_restart
EXTRN	_cg_oldsum:QWORD
EXTRN	_myfree:PROC
; Function compile flags: /Ogtp
;	COMDAT _cg_restart
_TEXT	SEGMENT
_cg_restart PROC					; COMDAT

; 1477 : #ifdef MPI_EVOLVER
; 1478 :    if ( this_task == MASTER_TASK )
; 1479 :    { struct mpi_command message;
; 1480 :      message.cmd = mpi_CG_RESTART;
; 1481 :      MPI_Bcast(&message,sizeof(struct mpi_command),MPI_BYTE,MASTER_TASK,
; 1482 :          MPI_COMM_WORLD);
; 1483 :    }
; 1484 : #endif
; 1485 :    { myfree((char *)cg_hvector); cg_hvector = NULL; cg_oldsum = 0.0;}

	mov	eax, DWORD PTR _cg_hvector
	push	eax
	call	_myfree
	fldz
	fstp	QWORD PTR _cg_oldsum
	add	esp, 4
	mov	DWORD PTR _cg_hvector, 0

; 1486 : } // end cg_restart()

	ret	0
_cg_restart ENDP
_TEXT	ENDS
PUBLIC	__real@4008000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	??_C@_0DN@HFACPEJG@Can?5do?5h_inverse_metric?5only?5in?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_apply_h_inverse_metric
EXTRN	_free_matrix:PROC
EXTRN	_get_edge_side:PROC
EXTRN	_get_vertex_area_star:PROC
EXTRN	_kb_dmatrix:PROC
EXTRN	_effective_area_flag:DWORD
EXTRN	_calc_vertex_normal:PROC
EXTRN	_get_edge_length:PROC
;	COMDAT __real@4008000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT ??_C@_0DN@HFACPEJG@Can?5do?5h_inverse_metric?5only?5in?5@
CONST	SEGMENT
??_C@_0DN@HFACPEJG@Can?5do?5h_inverse_metric?5only?5in?5@ DB 'Can do h_in'
	DB	'verse_metric only in STRING and SOAPFILM models.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\iterate.c
CONST	ENDS
;	COMDAT _apply_h_inverse_metric
_TEXT	SEGMENT
_s11$90468 = -236					; size = 8
_h$90453 = -228						; size = 8
_s12$90469 = -220					; size = 8
_h1$90452 = -212					; size = 8
_len1$90390 = -204					; size = 8
_f$90444 = -200						; size = 4
tv1320 = -196						; size = 8
_h2$90454 = -196					; size = 8
_lap$90455 = -188					; size = 8
_lap$90397 = -188					; size = 8
_h$90395 = -188						; size = 8
_stars$ = -180						; size = 4
_star$90428 = -176					; size = 8
_h1$90394 = -176					; size = 8
_len$90370 = -176					; size = 8
_norm$90449 = -172					; size = 4
tv1163 = -168						; size = 4
_start_fe$90459 = -168					; size = 4
_norm$90429 = -168					; size = 4
_f$90385 = -168						; size = 4
_scalarh$ = -164					; size = 4
tv138 = -160						; size = 4
_normals$ = -160					; size = 4
_v_id$ = -160						; size = 4
tv1159 = -156						; size = 4
tv287 = -156						; size = 4
_f$90362 = -156						; size = 4
tv1157 = -152						; size = 4
_f$90420 = -152						; size = 4
_normal$ = -148						; size = 48
_side1$90456 = -100					; size = 48
_side2$90457 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_apply_h_inverse_metric PROC				; COMDAT

; 1579 : { REAL *scalarh;  /* scalar curvature in normal direction */

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1580 :   REAL **normals; /* for soapfilm model */
; 1581 :   REAL *stars;     /* vertex areas */
; 1582 :   edge_id e_id;
; 1583 :   vertex_id v_id;
; 1584 :   int i;
; 1585 :   REAL normal[MAXCOORD];
; 1586 : 
; 1587 :   if ( (web.representation != STRING)  && (web.representation != SOAPFILM) )

	mov	eax, DWORD PTR _web+624
	cmp	eax, 1
	je	SHORT $LN34@apply_h_in
	cmp	eax, 2
	je	SHORT $LN34@apply_h_in

; 1588 :      kb_error(2085,"Can do h_inverse_metric only in STRING and SOAPFILM models.\n",
; 1589 :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DN@HFACPEJG@Can?5do?5h_inverse_metric?5only?5in?5@
	push	2085					; 00000825H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN34@apply_h_in:

; 1590 : 
; 1591 :   scalarh = (REAL*)temp_calloc(web.skel[VERTEX].max_ord+5,sizeof(REAL));

	mov	eax, DWORD PTR _web+68
	push	ebx
	push	esi
	push	edi
	push	1591					; 00000637H
	push	OFFSET ??_C@_09MIIJPAGP@ITERATE?4C?$AA@
	add	eax, 5
	push	8
	push	eax
	call	_kb_temp_calloc

; 1592 :   stars = (REAL*)temp_calloc(web.skel[VERTEX].max_ord+5,sizeof(REAL));

	mov	ecx, DWORD PTR _web+68
	push	1592					; 00000638H
	push	OFFSET ??_C@_09MIIJPAGP@ITERATE?4C?$AA@
	add	ecx, 5
	push	8
	push	ecx
	mov	DWORD PTR _scalarh$[ebp], eax
	call	_kb_temp_calloc
	add	esp, 32					; 00000020H

; 1593 : 
; 1594 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	mov	DWORD PTR _stars$[ebp], eax
	jne	$LN24@apply_h_in

; 1595 :   {
; 1596 :      /* gather scalar curvatures */
; 1597 :      FOR_ALL_VERTICES(v_id)

	mov	edi, DWORD PTR _web+48
	mov	edx, edi
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	DWORD PTR tv1157[ebp], edx
	je	$LN118@apply_h_in
	npad	12
$LL32@apply_h_in:
	mov	eax, DWORD PTR _web+12
	mov	ebx, edi
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN31@apply_h_in

; 1598 :      { REAL *f = get_force(v_id);

	mov	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+esi+784]
	add	eax, ecx
	mov	DWORD PTR _f$90362[ebp], eax

; 1599 :         REAL *vel = scalarh+loc_ordinal(v_id);

	mov	DWORD PTR tv138[ebp], ebx
	test	edx, edx
	jne	SHORT $LN38@apply_h_in
	mov	DWORD PTR tv138[ebp], -1
$LN38@apply_h_in:

; 1600 :         REAL len,star;
; 1601 :         e_id = get_vertex_edge(v_id);

	mov	esi, DWORD PTR [ecx+28]

; 1602 :         len = get_edge_length(e_id)/2;

	push	esi
	call	_get_edge_length
	fmul	QWORD PTR __real@3fe0000000000000

; 1603 :         e_id = get_next_tail_edge(e_id);

	mov	edx, DWORD PTR _web+124
	mov	ecx, esi
	shr	ecx, 27					; 0000001bH
	fstp	QWORD PTR _len$90370[ebp]
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	and	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4+32]

; 1604 :         len += get_edge_length(e_id)/2;

	push	eax
	call	_get_edge_length
	fmul	QWORD PTR __real@3fe0000000000000

; 1605 :         /* *vel = sqrt(SDIM_dot(f,f))/len; */
; 1606 :         star = calc_vertex_normal(v_id,NULLID,normal)/2;

	lea	ecx, DWORD PTR _normal$[ebp]
	push	ecx
	fadd	QWORD PTR _len$90370[ebp]
	push	0
	push	edi
	fstp	QWORD PTR _len$90370[ebp]
	call	_calc_vertex_normal
	fmul	QWORD PTR __real@3fe0000000000000
	add	esp, 20					; 00000014H

; 1607 :         if ( effective_area_flag ) len = star;

	cmp	DWORD PTR _effective_area_flag, 0
	je	SHORT $LN128@apply_h_in
	fstp	QWORD PTR _len$90370[ebp]
	jmp	SHORT $LN122@apply_h_in
$LN128@apply_h_in:
	fstp	ST(0)
$LN122@apply_h_in:

; 1608 :         stars[loc_ordinal(v_id)] = len;

	cmp	DWORD PTR tv1157[ebp], 0
	je	SHORT $LN39@apply_h_in
	mov	eax, ebx
	jmp	SHORT $LN40@apply_h_in
$LN39@apply_h_in:
	or	eax, -1
$LN40@apply_h_in:
	mov	edx, DWORD PTR _stars$[ebp]
	fld	QWORD PTR _len$90370[ebp]
	fstp	QWORD PTR [edx+eax*8]

; 1609 :         *vel = -SDIM_dot(f,normal)/len;

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR _f$90362[ebp]
	push	eax
	lea	ecx, DWORD PTR _normal$[ebp]
	push	ecx
	push	edx
	call	_dot
	fdiv	QWORD PTR _len$90370[ebp]
	mov	eax, DWORD PTR _scalarh$[ebp]
	mov	ecx, DWORD PTR tv138[ebp]
	add	esp, 12					; 0000000cH
	fchs
	fstp	QWORD PTR [eax+ecx*8]
$LN31@apply_h_in:

; 1595 :   {
; 1596 :      /* gather scalar curvatures */
; 1597 :      FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	edi, DWORD PTR [eax]
	mov	edx, edi
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	DWORD PTR tv1157[ebp], edx
	jne	$LL32@apply_h_in
$LN118@apply_h_in:

; 1610 :      }
; 1611 : 
; 1612 :      /* compute Laplacian and multiply by normal */
; 1613 :      FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _v_id$[ebp], eax
	mov	DWORD PTR tv1157[ebp], ecx
	je	$LN24@apply_h_in
	mov	ecx, DWORD PTR _web+12
	jmp	SHORT $LN26@apply_h_in
	npad	7
$LL126@apply_h_in:
	mov	eax, DWORD PTR _v_id$[ebp]
$LN26@apply_h_in:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv1159[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN25@apply_h_in

; 1614 :      { REAL *f = get_velocity(v_id);

	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+1024]
	add	eax, ecx

; 1615 :         REAL len1,len2;
; 1616 :         vertex_id v1,v2;
; 1617 :         REAL h1,h,h2;
; 1618 :         REAL lap;
; 1619 :         h = scalarh[loc_ordinal(v_id)];

	cmp	DWORD PTR tv1157[ebp], 0
	mov	DWORD PTR _f$90385[ebp], eax
	je	SHORT $LN41@apply_h_in
	mov	eax, DWORD PTR tv1159[ebp]
	jmp	SHORT $LN42@apply_h_in
$LN41@apply_h_in:
	or	eax, -1
$LN42@apply_h_in:
	mov	esi, DWORD PTR _scalarh$[ebp]
	fld	QWORD PTR [esi+eax*8]

; 1620 :         e_id = get_vertex_edge(v_id);

	mov	ecx, DWORD PTR [ecx+28]

; 1621 :         v1 = get_edge_headv(e_id);

	mov	eax, DWORD PTR _web+124
	fstp	QWORD PTR _h$90395[ebp]
	mov	edi, DWORD PTR _web+216
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	ebx, ecx
	add	esi, esi
	shr	ebx, 27					; 0000001bH
	add	esi, esi
	and	ebx, 1
	mov	eax, DWORD PTR [esi+eax]
	je	SHORT $LN68@apply_h_in
	mov	edx, DWORD PTR [edi+edx+304]
	mov	edi, DWORD PTR [eax+edx]
	jmp	SHORT $LN67@apply_h_in
$LN68@apply_h_in:
	add	eax, DWORD PTR [edi+edx+304]
	mov	edx, DWORD PTR _web+636
	mov	edi, DWORD PTR [eax+edx*4]
$LN67@apply_h_in:

; 1622 :         len1 = get_edge_length(e_id);

	push	ecx
	call	_get_edge_length
	fstp	QWORD PTR _len1$90390[ebp]
	add	esp, 4

; 1623 :         h1 = scalarh[loc_ordinal(v1)];

	test	edi, 268435456				; 10000000H
	je	SHORT $LN43@apply_h_in
	and	edi, 134217727				; 07ffffffH
	mov	eax, edi
	jmp	SHORT $LN44@apply_h_in
$LN43@apply_h_in:
	or	eax, -1
$LN44@apply_h_in:
	mov	edi, DWORD PTR _scalarh$[ebp]
	fld	QWORD PTR [edi+eax*8]

; 1624 :         e_id = get_next_tail_edge(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [esi+ecx]
	fstp	QWORD PTR _h1$90394[ebp]
	mov	eax, DWORD PTR [eax+ebx*4+32]

; 1625 :         v2 = get_edge_headv(e_id);

	mov	esi, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _web+216
	test	eax, 134217728				; 08000000H
	je	SHORT $LN74@apply_h_in
	mov	edx, DWORD PTR [edx+esi+304]
	mov	esi, DWORD PTR [ecx+edx]
	jmp	SHORT $LN73@apply_h_in
$LN74@apply_h_in:
	add	ecx, DWORD PTR [edx+esi+304]
	mov	edx, DWORD PTR _web+636
	mov	esi, DWORD PTR [ecx+edx*4]
$LN73@apply_h_in:

; 1626 :         len2 = get_edge_length(e_id);

	push	eax
	call	_get_edge_length
	add	esp, 4

; 1627 :         h2 = scalarh[loc_ordinal(v2)];

	test	esi, 268435456				; 10000000H
	je	SHORT $LN45@apply_h_in
	and	esi, 134217727				; 07ffffffH
	jmp	SHORT $LN46@apply_h_in
$LN45@apply_h_in:
	or	esi, -1
$LN46@apply_h_in:

; 1628 :         lap = ((h1-h)/len1 + (h2-h)/len2)/stars[loc_ordinal(v_id)];

	cmp	DWORD PTR tv1157[ebp], 0
	fld	QWORD PTR [edi+esi*8]
	je	SHORT $LN47@apply_h_in
	mov	eax, DWORD PTR tv1159[ebp]
	jmp	SHORT $LN48@apply_h_in
$LN47@apply_h_in:
	or	eax, -1
$LN48@apply_h_in:
	fld	QWORD PTR _h$90395[ebp]
	mov	ecx, DWORD PTR _stars$[ebp]
	fsub	ST(1), ST(0)

; 1629 : 
; 1630 :         /* now multiply be normal */
; 1631 :         calc_vertex_normal(v_id,NULLID,normal);

	lea	edx, DWORD PTR _normal$[ebp]
	fxch	ST(1)
	push	edx
	push	0
	fdivrp	ST(2), ST(0)
	fsubr	QWORD PTR _h1$90394[ebp]
	fdiv	QWORD PTR _len1$90390[ebp]
	faddp	ST(1), ST(0)
	fdiv	QWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _v_id$[ebp]
	push	eax
	fstp	QWORD PTR _lap$90397[ebp]
	call	_calc_vertex_normal
	fstp	ST(0)

; 1632 :         for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN25@apply_h_in
	mov	eax, DWORD PTR _f$90385[ebp]
	fld	QWORD PTR _lap$90397[ebp]
	lea	edx, DWORD PTR _normal$[ebp]
	sub	edx, eax
$LN21@apply_h_in:

; 1633 :           f[i] = lap*normal[i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN21@apply_h_in

; 1632 :         for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN25@apply_h_in:

; 1610 :      }
; 1611 : 
; 1612 :      /* compute Laplacian and multiply by normal */
; 1613 :      FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR tv1159[ebp]
	mov	ecx, DWORD PTR _web+12
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _v_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv1157[ebp], eax
	jne	$LL126@apply_h_in
$LN24@apply_h_in:

; 1634 :      }
; 1635 :   }
; 1636 : 
; 1637 :   if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	jne	$LN124@apply_h_in

; 1638 :   {
; 1639 :      normals = dmatrix(0,web.skel[VERTEX].max_ord+1,0,MAXCOORD-1);

	mov	ecx, DWORD PTR _web+68
	push	1639					; 00000667H
	push	OFFSET ??_C@_09MIIJPAGP@ITERATE?4C?$AA@
	push	5
	push	0
	inc	ecx
	push	ecx
	push	0
	call	_kb_dmatrix

; 1640 :      /* gather scalar curvatures */
; 1641 :      FOR_ALL_VERTICES(v_id)

	mov	edi, DWORD PTR _web+48
	mov	ecx, DWORD PTR _web+12
	mov	esi, edi
	shr	esi, 28					; 0000001cH
	add	esp, 24					; 00000018H
	and	esi, 1
	mov	DWORD PTR _normals$[ebp], eax
	je	$LN15@apply_h_in
	npad	2
$LL17@apply_h_in:
	mov	ebx, edi
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR tv1163[ebp], eax
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN16@apply_h_in

; 1642 :      { REAL *f = get_force(v_id);

	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax+784]
	add	eax, DWORD PTR tv1163[ebp]

; 1643 :         REAL *vel = scalarh+loc_ordinal(v_id);

	mov	DWORD PTR tv287[ebp], ebx
	mov	DWORD PTR _f$90420[ebp], eax
	test	esi, esi
	jne	$LN162@apply_h_in
	mov	DWORD PTR tv287[ebp], -1

; 1644 :         REAL star;
; 1645 :         REAL *norm = normals[loc_ordinal(v_id)];

	or	eax, -1
$LN52@apply_h_in:
	mov	ecx, DWORD PTR _normals$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]

; 1646 :         star = calc_vertex_normal(v_id,get_vertex_fe(v_id),norm)/3;

	push	eax
	push	edi
	mov	DWORD PTR _norm$90429[ebp], eax
	call	_get_vertex_fe
	add	esp, 4
	push	eax
	push	edi
	call	_calc_vertex_normal
	fdiv	QWORD PTR __real@4008000000000000
	add	esp, 12					; 0000000cH

; 1647 :         if ( !effective_area_flag )

	cmp	DWORD PTR _effective_area_flag, 0
	fstp	QWORD PTR _star$90428[ebp]
	jne	SHORT $LN12@apply_h_in

; 1648 :               star = get_vertex_area_star(v_id)/3;

	push	edi
	call	_get_vertex_area_star
	fdiv	QWORD PTR __real@4008000000000000
	add	esp, 4
	fstp	QWORD PTR _star$90428[ebp]
$LN12@apply_h_in:

; 1649 :         *vel = SDIM_dot(f,norm)/star;

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _norm$90429[ebp]
	mov	ecx, DWORD PTR _f$90420[ebp]
	push	edx
	push	eax
	push	ecx
	call	_dot
	fld	QWORD PTR _star$90428[ebp]
	fdiv	ST(1), ST(0)
	mov	edx, DWORD PTR _scalarh$[ebp]
	mov	eax, DWORD PTR tv287[ebp]
	add	esp, 12					; 0000000cH
	fxch	ST(1)
	fstp	QWORD PTR [edx+eax*8]

; 1650 :         stars[loc_ordinal(v_id)] = star;

	test	esi, esi
	je	SHORT $LN53@apply_h_in
	mov	eax, ebx
	jmp	SHORT $LN54@apply_h_in
$LN162@apply_h_in:

; 1644 :         REAL star;
; 1645 :         REAL *norm = normals[loc_ordinal(v_id)];

	mov	eax, ebx
	jmp	$LN52@apply_h_in
$LN53@apply_h_in:

; 1650 :         stars[loc_ordinal(v_id)] = star;

	or	eax, -1
$LN54@apply_h_in:
	mov	ecx, DWORD PTR _stars$[ebp]
	fstp	QWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR _web+12
$LN16@apply_h_in:

; 1640 :      /* gather scalar curvatures */
; 1641 :      FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	edi, DWORD PTR [edx]
	mov	esi, edi
	shr	esi, 28					; 0000001cH
	and	esi, 1
	jne	$LL17@apply_h_in
$LN15@apply_h_in:

; 1651 :      }
; 1652 : 
; 1653 :      /* compute Laplacian and multiply by normal */
; 1654 :      FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	mov	eax, edx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv1157[ebp], eax
	je	$LN123@apply_h_in
	mov	ebx, DWORD PTR _web+460
$LL11@apply_h_in:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv1159[ebp], eax
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN10@apply_h_in

; 1655 :      { REAL *f = get_velocity(v_id);

	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+esi+1024]
	mov	esi, DWORD PTR tv1159[ebp]
	add	eax, DWORD PTR [ecx+esi*4]

; 1656 :         REAL *norm = normals[loc_ordinal(v_id)];

	mov	ecx, DWORD PTR tv1157[ebp]
	mov	DWORD PTR _f$90444[ebp], eax
	test	ecx, ecx
	je	SHORT $LN55@apply_h_in
	mov	eax, esi
	jmp	SHORT $LN56@apply_h_in
$LN55@apply_h_in:
	or	eax, -1
$LN56@apply_h_in:
	mov	edi, DWORD PTR _normals$[ebp]
	mov	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR _norm$90449[ebp], eax

; 1657 :         REAL h1,h,h2;
; 1658 :         REAL lap;
; 1659 :         REAL side1[MAXCOORD],side2[MAXCOORD];
; 1660 :         facetedge_id fe,start_fe,next_fe;
; 1661 :         edge_id e1,e2;
; 1662 : 
; 1663 :         h = scalarh[loc_ordinal(v_id)];

	test	ecx, ecx
	je	SHORT $LN57@apply_h_in
	mov	eax, esi
	jmp	SHORT $LN58@apply_h_in
$LN57@apply_h_in:
	or	eax, -1
$LN58@apply_h_in:
	mov	ecx, DWORD PTR _scalarh$[ebp]
	fld	QWORD PTR [ecx+eax*8]

; 1664 : 
; 1665 :         lap = 0.0;
; 1666 :         fe = start_fe = get_vertex_fe(v_id);

	push	edx
	fstp	QWORD PTR _h$90453[ebp]
	fldz
	fstp	QWORD PTR _lap$90455[ebp]
	call	_get_vertex_fe
	add	esp, 4
	mov	DWORD PTR _start_fe$90459[ebp], eax
	jmp	SHORT $LN6@apply_h_in
$LL149@apply_h_in:
	fstp	ST(0)
$LN6@apply_h_in:

; 1667 :         do
; 1668 :         { REAL s11,s12,s22,det;
; 1669 :           next_fe = inverse_id(get_prev_edge(fe));

	test	eax, 134217728				; 08000000H
	je	SHORT $LN78@apply_h_in
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ecx, DWORD PTR [edx+32]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN77@apply_h_in
$LN78@apply_h_in:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [edx+28]
$LN77@apply_h_in:

; 1670 :           e1 = get_fe_edge(fe);

	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]

; 1671 :           get_edge_side(e1,side1);

	lea	edx, DWORD PTR _side1$90456[ebp]
	mov	esi, eax
	push	edx
	xor	ecx, 134217728				; 08000000H
	push	esi
	mov	ebx, ecx
	call	_get_edge_side

; 1672 :           h1 = scalarh[loc_ordinal(get_edge_headv(e1))];

	mov	edi, DWORD PTR _web+636
	mov	eax, esi
	shr	eax, 27					; 0000001bH
	add	esp, 8
	and	eax, 1
	je	SHORT $LN84@apply_h_in
	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+esi+304]
	add	ecx, edx
	mov	edx, DWORD PTR [ecx]
	jmp	SHORT $LN83@apply_h_in
$LN84@apply_h_in:
	mov	edx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+304]
	add	ecx, edx
	mov	edx, DWORD PTR [ecx+edi*4]
$LN83@apply_h_in:
	test	edx, 268435456				; 10000000H
	je	SHORT $LN59@apply_h_in
	test	eax, eax
	je	SHORT $LN88@apply_h_in
	mov	eax, DWORD PTR [ecx]
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN60@apply_h_in
$LN88@apply_h_in:
	mov	eax, DWORD PTR [ecx+edi*4]
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN60@apply_h_in
$LN59@apply_h_in:
	or	eax, -1
$LN60@apply_h_in:
	mov	ecx, DWORD PTR _scalarh$[ebp]
	fld	QWORD PTR [ecx+eax*8]

; 1673 : 
; 1674 :           e2 = get_fe_edge(next_fe);

	mov	edx, DWORD PTR _web+460
	mov	edi, ebx
	fstp	QWORD PTR _h1$90452[ebp]
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+edx]
	mov	esi, ebx
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [eax+20]

; 1675 :           get_edge_side(e2,side2);

	lea	ecx, DWORD PTR _side2$90457[ebp]
	push	ecx
	push	esi
	call	_get_edge_side

; 1676 :           h2 = scalarh[loc_ordinal(get_edge_headv(e2))];

	mov	eax, esi
	shr	eax, 27					; 0000001bH
	add	esp, 8
	and	esi, 134217727				; 07ffffffH
	and	eax, 1
	je	SHORT $LN94@apply_h_in
	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+304]
	add	ecx, edx
	mov	edx, DWORD PTR [ecx]
	jmp	SHORT $LN93@apply_h_in
$LN94@apply_h_in:
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+esi+304]
	add	ecx, edx
	mov	edx, DWORD PTR _web+636
	mov	edx, DWORD PTR [ecx+edx*4]
$LN93@apply_h_in:
	test	edx, 268435456				; 10000000H
	je	SHORT $LN61@apply_h_in
	test	eax, eax
	je	SHORT $LN98@apply_h_in
	mov	ecx, DWORD PTR [ecx]
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN62@apply_h_in
$LN98@apply_h_in:
	mov	eax, DWORD PTR _web+636
	mov	ecx, DWORD PTR [ecx+eax*4]
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN62@apply_h_in
$LN61@apply_h_in:
	or	ecx, -1
$LN62@apply_h_in:
	mov	edx, DWORD PTR _scalarh$[ebp]
	fld	QWORD PTR [edx+ecx*8]

; 1677 :           s11 = SDIM_dot(side1,side1);

	mov	eax, DWORD PTR _web+616
	push	eax
	fstp	QWORD PTR _h2$90454[ebp]
	lea	ecx, DWORD PTR _side1$90456[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _s11$90468[ebp]

; 1678 :           s12 = SDIM_dot(side1,side2);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _side2$90457[ebp]
	push	ecx
	lea	edx, DWORD PTR _side1$90456[ebp]
	push	edx
	call	_dot
	fstp	QWORD PTR _s12$90469[ebp]

; 1679 :           s22 = SDIM_dot(side2,side2);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _side2$90457[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot

; 1680 :           det = sqrt(s11*s22 - s12*s12);
; 1681 :           lap += ((s11-2*s12+s22)*h + (s12-s22)*h1 + (s12-s11)*h2)/det;

	fld	QWORD PTR _s12$90469[ebp]
	fld	ST(0)
	add	esp, 36					; 00000024H
	fadd	ST(0), ST(1)
	fld	QWORD PTR _s11$90468[ebp]
	fld	ST(0)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fadd	ST(0), ST(3)
	fmul	QWORD PTR _h$90453[ebp]
	fld	ST(2)
	fsub	ST(0), ST(4)
	fmul	QWORD PTR _h1$90452[ebp]
	faddp	ST(1), ST(0)
	fld	ST(2)
	fsub	ST(0), ST(2)
	fmul	QWORD PTR _h2$90454[ebp]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR tv1320[ebp]
	fmulp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)
	call	__CIsqrt
	fdivr	QWORD PTR tv1320[ebp]

; 1682 :           fe = get_next_facet(next_fe);

	test	ebx, 134217728				; 08000000H
	mov	ebx, DWORD PTR _web+460
	fadd	QWORD PTR _lap$90455[ebp]
	fst	QWORD PTR _lap$90455[ebp]
	je	SHORT $LN102@apply_h_in
	mov	eax, DWORD PTR [edi+ebx]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN5@apply_h_in
$LN102@apply_h_in:
	mov	ecx, DWORD PTR [edi+ebx]
	mov	eax, DWORD PTR [ecx+40]
$LN5@apply_h_in:

; 1683 :         } while ( !equal_id(fe,start_fe) );

	cmp	eax, DWORD PTR _start_fe$90459[ebp]
	jne	$LL149@apply_h_in

; 1684 :         lap /= 2*stars[loc_ordinal(v_id)];

	cmp	DWORD PTR tv1157[ebp], 0
	je	SHORT $LN63@apply_h_in
	mov	eax, DWORD PTR tv1159[ebp]
	jmp	SHORT $LN64@apply_h_in
$LN63@apply_h_in:
	or	eax, -1
$LN64@apply_h_in:
	mov	edx, DWORD PTR _stars$[ebp]
	fld	QWORD PTR [edx+eax*8]

; 1685 : 
; 1686 :         /* now multiply by unit normal */
; 1687 :         for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	fadd	ST(0), ST(0)
	fdivp	ST(1), ST(0)
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN156@apply_h_in
	mov	eax, DWORD PTR _f$90444[ebp]
	mov	edx, DWORD PTR _norm$90449[ebp]
	sub	edx, eax
$LN3@apply_h_in:

; 1688 :           f[i] = lap*norm[i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN3@apply_h_in

; 1685 : 
; 1686 :         /* now multiply by unit normal */
; 1687 :         for ( i = 0 ; i < SDIM ; i++ )

	mov	ebx, DWORD PTR _web+460
$LN156@apply_h_in:
	mov	ecx, DWORD PTR _web+12
	fstp	ST(0)
$LN10@apply_h_in:

; 1651 :      }
; 1652 : 
; 1653 :      /* compute Laplacian and multiply by normal */
; 1654 :      FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR tv1159[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [edx]
	mov	eax, edx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv1157[ebp], eax
	jne	$LL11@apply_h_in
$LN123@apply_h_in:

; 1689 :      }
; 1690 :      free_matrix(normals);

	mov	eax, DWORD PTR _normals$[ebp]
	push	eax
	call	_free_matrix
	add	esp, 4
$LN124@apply_h_in:

; 1691 :   }
; 1692 : 
; 1693 :   temp_free((char*)scalarh);

	mov	ecx, DWORD PTR _scalarh$[ebp]
	push	ecx
	call	_temp_free

; 1694 :   temp_free((char*)stars);

	mov	edx, DWORD PTR _stars$[ebp]
	push	edx
	call	_temp_free

; 1695 : } /* end apply_h_inverse_metric() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_apply_h_inverse_metric ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@CJBOIBLK@__volvelocity?$AA@		; `string'
PUBLIC	??_C@_09DDNGGDCP@__volgrad?$AA@			; `string'
PUBLIC	??_C@_0DP@MEAFNNPA@Vertex?5?$CFs?5is?5on?5more?5constraints@ ; `string'
PUBLIC	??_C@_0CC@GAAKDFFE@Zero?5area?5star?5around?5vertex?5?$CFs?4@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	__real@4010000000000000
PUBLIC	__real@4018000000000000
PUBLIC	??_C@_0CF@FKMFLFBL@Conformal?5metric?5evaluates?5to?5ze@ ; `string'
PUBLIC	??_C@_0M@GPOBHEAO@zener_coeff?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_local_convert_forms_to_vectors
EXTRN	_find_extra:PROC
EXTRN	_b_proj:PROC
EXTRN	_constr_proj:PROC
EXTRN	_raw_velocity_attr:DWORD
EXTRN	_nullcon:QWORD
EXTRN	_check_pinning_flag:DWORD
EXTRN	_vertex_normals:DWORD
EXTRN	_normal_motion_flag:DWORD
EXTRN	_mobility_formula:BYTE
EXTRN	_errmsg:BYTE
EXTRN	_elnames:BYTE
EXTRN	_star_fraction:QWORD
EXTRN	_mobility_tensor:BYTE
EXTRN	_mobility_tensor_flag:DWORD
EXTRN	_mobility_flag:DWORD
EXTRN	_matvec_mul:PROC
EXTRN	_metric:DWORD
EXTRN	_klein_metric_flag:DWORD
EXTRN	_metric_convert_flag:DWORD
EXTRN	_get_vertex_fvalence:PROC
EXTRN	_get_vertex_evalence:PROC
EXTRN	_get_vertex_vgrad:PROC
EXTRN	_get_vertex_length_star:PROC
EXTRN	_mat_inv:PROC
EXTRN	_gauss_lagrange:BYTE
EXTRN	_mobility_cleanup:PROC
EXTRN	_approx_curv_calc:PROC
EXTRN	_mobility_setup:PROC
EXTRN	_approx_curve_flag:DWORD
EXTRN	_lookup_global:PROC
EXTRN	_zener_drag_flag:DWORD
EXTRN	_mat2d_setup:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0O@CJBOIBLK@__volvelocity?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0O@CJBOIBLK@__volvelocity?$AA@ DB '__volvelocity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DDNGGDCP@__volgrad?$AA@
CONST	SEGMENT
??_C@_09DDNGGDCP@__volgrad?$AA@ DB '__volgrad', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@MEAFNNPA@Vertex?5?$CFs?5is?5on?5more?5constraints@
CONST	SEGMENT
??_C@_0DP@MEAFNNPA@Vertex?5?$CFs?5is?5on?5more?5constraints@ DB 'Vertex %'
	DB	's is on more constraints than the dimension of space.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GAAKDFFE@Zero?5area?5star?5around?5vertex?5?$CFs?4@
CONST	SEGMENT
??_C@_0CC@GAAKDFFE@Zero?5area?5star?5around?5vertex?5?$CFs?4@ DB 'Zero ar'
	DB	'ea star around vertex %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT ??_C@_0CF@FKMFLFBL@Conformal?5metric?5evaluates?5to?5ze@
CONST	SEGMENT
??_C@_0CF@FKMFLFBL@Conformal?5metric?5evaluates?5to?5ze@ DB 'Conformal me'
	DB	'tric evaluates to zero.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPOBHEAO@zener_coeff?$AA@
CONST	SEGMENT
??_C@_0M@GPOBHEAO@zener_coeff?$AA@ DB 'zener_coeff', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\iterate.c
CONST	ENDS
;	COMDAT _local_convert_forms_to_vectors
_TEXT	SEGMENT
_aqXvS$ = -872						; size = 24
_con$90966 = -848					; size = 28
_zener_coeff$ = -820					; size = 8
_eltype$ = -812						; size = 4
tv6897 = -808						; size = 8
tv3422 = -808						; size = 8
_attr$91075 = -808					; size = 8
_ss$90751 = -808					; size = 8
_fudge$90619 = -808					; size = 8
_fudge$90567 = -808					; size = 8
_attr$90646 = -800					; size = 8
tv3807 = -796						; size = 4
_f$90604 = -796						; size = 4
_vgptr0$90557 = -796					; size = 4
_maxgradbody$91102 = -792				; size = 4
_a$ = -792						; size = 4
_ff$90737 = -788					; size = 8
tv7401 = -784						; size = 4
tv4579 = -784						; size = 4
_maxvelbody$91106 = -784				; size = 4
_vgptr0$90609 = -784					; size = 4
_vgptri0$90569 = -784					; size = 4
_weights$ = -780					; size = 4
_area$90817 = -776					; size = 8
_fs$90752 = -776					; size = 8
_rr$90684 = -776					; size = 8
_area$90603 = -776					; size = 8
_area$90551 = -776					; size = 8
_area$90736 = -768					; size = 8
tv7383 = -764						; size = 4
tv7380 = -764						; size = 4
tv7372 = -764						; size = 4
tv3798 = -764						; size = 4
tv3030 = -764						; size = 4
_x$90876 = -764						; size = 4
_start_e$90800 = -764					; size = 4
_vgptri0$90621 = -764					; size = 4
tv5868 = -760						; size = 4
tv2586 = -760						; size = 4
tv1465 = -760						; size = 4
_vgrad_attr$ = -760					; size = 4
tv3092 = -756						; size = 4
_maxgraddim$91103 = -756				; size = 4
_force$ = -756						; size = 4
tv3076 = -752						; size = 4
_maxveldim$91107 = -752					; size = 4
tv4576 = -748						; size = 4
tv3217 = -748						; size = 4
tv1670 = -748						; size = 4
tv1469 = -748						; size = 4
tv1357 = -748						; size = 4
tv1084 = -748						; size = 4
_one_sided_flag$90969 = -748				; size = 4
_v_ptr$90595 = -748					; size = 4
_v_ptr$90543 = -748					; size = 4
tv7381 = -744						; size = 4
tv5870 = -744						; size = 4
tv5418 = -744						; size = 4
tv5145 = -744						; size = 4
tv4866 = -744						; size = 4
_vvelocity_attr$ = -744					; size = 4
_e_id$90799 = -744					; size = 4
_k$ = -744						; size = 4
_velex$91104 = -740					; size = 4
_velocity$ = -740					; size = 4
_ctrl$90518 = -740					; size = 4
tv3132 = -736						; size = 4
_v_id$ = -736						; size = 4
_f$90552 = -736						; size = 4
_gradex$91100 = -732					; size = 4
_vgptr0$90648 = -732					; size = 4
_j$ = -732						; size = 4
tv5081 = -728						; size = 4
tv4802 = -728						; size = 4
tv3214 = -728						; size = 4
_vg$91120 = -728					; size = 4
_oncount$90965 = -728					; size = 4
_vgptr$90649 = -728					; size = 4
_i$ = -728						; size = 4
_axJ$ = -724						; size = 288
_mob$90882 = -436					; size = 288
_perp$90968 = -148					; size = 48
_perp$91020 = -100					; size = 48
_dummy$90762 = -100					; size = 48
_dummy$90745 = -100					; size = 48
_tmp$91072 = -52					; size = 48
_newv$90881 = -52					; size = 48
_side$90753 = -52					; size = 48
_conlist$90967 = -32					; size = 28
__$ArrayPad$ = -4					; size = 4
_mode$ = 8						; size = 4
_local_convert_forms_to_vectors PROC			; COMDAT

; 1735 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 872				; 00000368H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1736 :   vertex_id v_id;
; 1737 :   REAL *force,*velocity;
; 1738 :   int i,j,k,m;
; 1739 :   REAL **weights=NULL;
; 1740 :   REAL zener_coeff=0.0;

	fldz
	push	ebx
	push	edi
	fstp	QWORD PTR _zener_coeff$[ebp]

; 1741 :   MAT2D(a,MAXPARAM,MAXCOORD); 

	push	6
	push	6
	lea	eax, DWORD PTR _axJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _aqXvS$[ebp]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR _weights$[ebp], ebx
	call	_mat2d_setup
	add	esp, 16					; 00000010H
	mov	DWORD PTR _a$[ebp], eax

; 1742 :   int vgrad_attr,vvelocity_attr; /* for debug save of vgrads to attr */
; 1743 :   int eltype;
; 1744 : 
; 1745 :   if ( zener_drag_flag )

	cmp	DWORD PTR _zener_drag_flag, ebx
	je	$LN628@local_conv

; 1746 :   { int zd;
; 1747 :     zd = lookup_global(ZENER_COEFF_NAME);

	push	OFFSET ??_C@_0M@GPOBHEAO@zener_coeff?$AA@
	call	_lookup_global

; 1748 :     if ( zd >= 0 ) zener_coeff = globals(zd)->value.real;

	mov	edi, DWORD PTR _web+5652
	add	esp, 4
	cmp	eax, ebx
	jl	SHORT $LN377@local_conv
	mov	edx, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN381@local_conv
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN383@local_conv
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	fld	QWORD PTR [eax+64]
	fstp	QWORD PTR _zener_coeff$[ebp]
	jmp	SHORT $LN377@local_conv
$LN383@local_conv:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN381@local_conv
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	fld	QWORD PTR [eax+64]
	fstp	QWORD PTR _zener_coeff$[ebp]
	jmp	SHORT $LN377@local_conv
$LN381@local_conv:
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+edx]
	fld	QWORD PTR [eax+64]
	fstp	QWORD PTR _zener_coeff$[ebp]
	jmp	SHORT $LN377@local_conv
$LN628@local_conv:
	mov	edi, DWORD PTR _web+5652
$LN377@local_conv:

; 1749 :   }
; 1750 :   if ( approx_curve_flag )

	cmp	DWORD PTR _approx_curve_flag, ebx
	je	SHORT $LN376@local_conv

; 1751 :   { /* approx_curvature();*/  /* Dzuik and Schmidt version */
; 1752 :     mobility_setup();

	call	_mobility_setup

; 1753 :     approx_curv_calc(mode); /* convert form to vector */

	mov	ecx, DWORD PTR _mode$[ebp]
	push	ecx
	call	_approx_curv_calc
	add	esp, 4

; 1754 :     mobility_cleanup();

	call	_mobility_cleanup
	pop	edi
	pop	ebx

; 2285 : } /* end convert_forms_to_vectors() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN376@local_conv:

; 1755 :     return;
; 1756 :   }
; 1757 : 
; 1758 :   if ( (web.modeltype == LAGRANGE) && web.area_norm_flag )

	cmp	DWORD PTR _web+628, 3
	push	esi
	jne	$LN632@local_conv
	cmp	DWORD PTR _web+876, ebx
	je	$LN632@local_conv

; 1759 :   { /* set up weight matrix and invert */
; 1760 :      int ctrl;
; 1761 :      struct gauss_lag *gl;
; 1762 :      edge_id e_id;
; 1763 :      facet_id f_id;
; 1764 : 
; 1765 :      /* Notes: This tries to approximate the inverse of the linear interpolation
; 1766 :          metric.    The inverse metric used here has diagonal sum of blocks which
; 1767 :          are the inverses of the single element metric, with premultiplication
; 1768 :          of the form by diagonal 1/star, and postmultiplication of the vector
; 1769 :          by 1/valence. This results in uniform volume gradient for a flat
; 1770 :          surface, regardless of triangulation.  Drawback is that inverse metric
; 1771 :          is not symmetric if elements not equal size.  But probably still 
; 1772 :          positive definite (in sense of guaranteeing downhill in energy)
; 1773 :      */
; 1774 : 
; 1775 :      if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN374@local_conv

; 1776 :      { gl = &gauss_lagrange[web.dimension][web.gauss1D_order];

	mov	esi, DWORD PTR _web+1592
	mov	edx, DWORD PTR _web+620

; 1777 :        ctrl = web.skel[EDGE].ctrlpts;

	mov	edi, DWORD PTR _web+120
	shl	esi, 5
	add	esi, DWORD PTR _gauss_lagrange[edx*4]

; 1778 :      } else

	jmp	SHORT $LN1018@local_conv
$LN374@local_conv:

; 1779 :      { gl = &gauss_lagrange[web.dimension][web.gauss2D_order];

	mov	esi, DWORD PTR _web+1596
	mov	eax, DWORD PTR _web+620

; 1780 :        ctrl = web.skel[FACET].ctrlpts;

	mov	edi, DWORD PTR _web+232
	shl	esi, 5
	add	esi, DWORD PTR _gauss_lagrange[eax*4]
$LN1018@local_conv:

; 1781 :      }
; 1782 :      weights = dmatrix(0,ctrl,0,ctrl);

	push	1782					; 000006f6H
	push	OFFSET ??_C@_09MIIJPAGP@ITERATE?4C?$AA@
	push	edi
	push	ebx
	push	edi
	push	ebx
	mov	DWORD PTR _ctrl$90518[ebp], edi
	call	_kb_dmatrix
	add	esp, 24					; 00000018H
	mov	DWORD PTR _weights$[ebp], eax

; 1783 :      for ( i = 0 ; i < ctrl ; i++ )

	cmp	edi, ebx
	jle	$LN703@local_conv

; 1781 :      }
; 1782 :      weights = dmatrix(0,ctrl,0,ctrl);

	fldz
	mov	ecx, eax
	mov	DWORD PTR tv4576[ebp], ecx
	mov	edx, edi
$LN372@local_conv:

; 1856 :     if ( mode & CALC_FORCE )

	mov	eax, DWORD PTR [ecx]
	xor	edi, edi
	mov	DWORD PTR _j$[ebp], edi
	mov	DWORD PTR tv4579[ebp], eax
$LN704@local_conv:

; 1785 :        { weights[i][j] = 0.0;

	mov	eax, DWORD PTR tv4579[ebp]
	fst	QWORD PTR [eax+edi*8]

; 1786 :          for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN368@local_conv

; 1784 :        for ( j = 0 ; j < ctrl ; j++ ) 

	mov	ecx, DWORD PTR [ecx]
	lea	edx, DWORD PTR [ecx+edi*8]
$LN366@local_conv:

; 1787 :             weights[i][j] += gl->gausswt[m]*gl->gpoly[m][i]*gl->gpoly[m][j];

	mov	ecx, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	edi, DWORD PTR [esi+12]
	fld	QWORD PTR [ecx+ebx*8]
	fmul	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR _j$[ebp]
	inc	eax
	fmul	QWORD PTR [ecx+edi*8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LN366@local_conv

; 1786 :          for ( m = 0 ; m < gl->gnumpts ; m++ )

	mov	ecx, DWORD PTR tv4576[ebp]
	mov	edx, DWORD PTR _ctrl$90518[ebp]
$LN368@local_conv:

; 1784 :        for ( j = 0 ; j < ctrl ; j++ ) 

	inc	edi
	mov	DWORD PTR _j$[ebp], edi
	cmp	edi, edx
	jl	SHORT $LN704@local_conv

; 1783 :      for ( i = 0 ; i < ctrl ; i++ )

	inc	ebx
	add	ecx, 4
	mov	DWORD PTR tv4576[ebp], ecx
	cmp	ebx, edx
	jl	SHORT $LN372@local_conv
	mov	edi, DWORD PTR _ctrl$90518[ebp]
	fstp	ST(0)
$LN703@local_conv:

; 1788 :        }
; 1789 :      mat_inv(weights,ctrl);

	mov	edx, DWORD PTR _weights$[ebp]
	push	edi
	push	edx
	call	_mat_inv

; 1790 : 
; 1791 :      if ( web.representation == STRING )
; 1792 :      { FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+616
	add	esp, 8
	cmp	DWORD PTR _web+624, 1
	jne	$LN363@local_conv
	mov	eax, DWORD PTR _web+160
	test	eax, 268435456				; 10000000H
	je	$LN633@local_conv
	mov	edi, DWORD PTR _web+124
	npad	2
$LL362@local_conv:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+edi]
	mov	DWORD PTR tv3030[ebp], eax
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN361@local_conv

; 1793 :         { vertex_id *v_ptr = get_edge_vertices(e_id);

	mov	eax, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+esi+304]
	add	eax, edx
	mov	DWORD PTR _v_ptr$90543[ebp], eax

; 1794 :           ctrl = web.skel[EDGE].ctrlpts;

	mov	eax, DWORD PTR _web+120
	mov	DWORD PTR _ctrl$90518[ebp], eax

; 1795 :           for ( i = 0 ; i < ctrl ; i++ )

	test	eax, eax
	jle	$LN361@local_conv
	mov	eax, DWORD PTR _mode$[ebp]
	mov	ecx, eax
	and	ecx, 1
	and	eax, 2
	mov	DWORD PTR tv3076[ebp], ecx
	mov	ecx, DWORD PTR _v_ptr$90543[ebp]
	mov	DWORD PTR tv3092[ebp], eax
	mov	eax, DWORD PTR _weights$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv4802[ebp], ecx
	mov	ecx, DWORD PTR _ctrl$90518[ebp]
	mov	DWORD PTR tv4866[ebp], eax
	mov	DWORD PTR tv2586[ebp], ecx
	npad	4
$LL357@local_conv:

; 1796 :           { REAL area = get_vertex_length_star(v_ptr[i]);

	mov	esi, DWORD PTR tv4802[ebp]
	mov	edx, DWORD PTR [esi]
	push	edx
	call	_get_vertex_length_star
	fstp	QWORD PTR _area$90551[ebp]

; 1797 :              REAL *f = get_force(v_ptr[i]);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR _web+12
	mov	esi, DWORD PTR _web+104
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	add	ecx, DWORD PTR [esi+edx+784]

; 1798 :              volgrad *vgptr0 = get_vertex_vgrad(v_ptr[i]);

	push	eax
	mov	DWORD PTR _f$90552[ebp], ecx
	call	_get_vertex_vgrad
	add	esp, 8
	mov	DWORD PTR _vgptr0$90557[ebp], eax

; 1799 :              volgrad *vgptr;
; 1800 :              for ( j = 0 ; j < ctrl ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	npad	7
$LL354@local_conv:

; 1801 :              { REAL *vel = get_velocity(v_ptr[j]);

	mov	ebx, DWORD PTR _v_ptr$90543[ebp]
	mov	edi, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ebx+edi*4]
	mov	edx, DWORD PTR _web+12
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	add	esi, DWORD PTR [edx+ecx+1024]

; 1802 :                 REAL fudge = 1.0/get_vertex_evalence(v_ptr[j]);

	push	eax
	call	_get_vertex_evalence
	mov	DWORD PTR tv7401[ebp], eax
	fild	DWORD PTR tv7401[ebp]

; 1803 :                 volgrad *vgptri;
; 1804 :                 volgrad *vgptri0 = get_vertex_vgrad(v_ptr[j]);

	mov	eax, DWORD PTR [ebx+edi*4]
	fld1
	push	eax
	fdivrp	ST(1), ST(0)
	fstp	QWORD PTR _fudge$90567[ebp]
	call	_get_vertex_vgrad

; 1805 :                 if ( mode & CALC_FORCE )
; 1806 :                  for ( k = 0 ; k < SDIM ; k++ )

	fld	QWORD PTR _area$90551[ebp]
	mov	ecx, DWORD PTR _web+616
	add	esp, 8
	cmp	DWORD PTR tv3076[ebp], 0
	mov	DWORD PTR _vgptri0$90569[ebp], eax
	je	SHORT $LN348@local_conv
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN348@local_conv

; 1799 :              volgrad *vgptr;
; 1800 :              for ( j = 0 ; j < ctrl ; j++ )

	mov	edx, DWORD PTR tv4802[ebp]
	mov	ecx, DWORD PTR tv4866[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	edx, edi

; 1805 :                 if ( mode & CALC_FORCE )
; 1806 :                  for ( k = 0 ; k < SDIM ; k++ )

	mov	edi, DWORD PTR _f$90552[ebp]
	lea	ebx, DWORD PTR [ecx+edx*8]
	mov	edx, esi
	sub	edi, esi
$LN350@local_conv:

; 1807 :                     vel[k] += weights[i][j]*f[k]/area;

	fld	QWORD PTR [edi+edx]
	inc	eax
	fmul	QWORD PTR [ebx]
	add	edx, 8
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR [edx-8]
	fstp	QWORD PTR [edx-8]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN350@local_conv
$LN348@local_conv:

; 1808 :                 if ( mode & CALC_VOLGRADS )

	cmp	DWORD PTR tv3092[ebp], 0
	je	SHORT $LN733@local_conv

; 1809 :                  for ( vgptri=vgptri0; vgptri ; vgptri = vgptri->chain )

	mov	edi, DWORD PTR _vgptri0$90569[ebp]
	test	edi, edi
	je	SHORT $LN733@local_conv
	fld	QWORD PTR _fudge$90567[ebp]
$LN346@local_conv:

; 1810 :                   for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edx, DWORD PTR _vgptr0$90557[ebp]
	test	edx, edx
	je	SHORT $LN345@local_conv
$LN343@local_conv:

; 1811 :                   { if ( vgptr->fixnum == vgptri->fixnum )

	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [edi]
	jne	SHORT $LN342@local_conv

; 1812 :                       for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN342@local_conv

; 1799 :              volgrad *vgptr;
; 1800 :              for ( j = 0 ; j < ctrl ; j++ )

	mov	esi, DWORD PTR tv4802[ebp]
	mov	ecx, DWORD PTR tv4866[ebp]
	mov	ecx, DWORD PTR [ecx+esi]
	mov	esi, DWORD PTR _j$[ebp]
	lea	esi, DWORD PTR [ecx+esi*8]
$LN339@local_conv:

; 1813 :                         vgptri->velocity[k] += fudge*weights[i][j]*vgptr->grad[k]/area;

	fld	QWORD PTR [esi]
	mov	ebx, DWORD PTR [edx+16]
	fmul	ST(0), ST(1)
	mov	ecx, DWORD PTR [edi+20]
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	eax
	fmul	QWORD PTR [ebx+eax*8-8]
	fdiv	ST(0), ST(2)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN339@local_conv
$LN342@local_conv:

; 1810 :                   for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edx, DWORD PTR [edx+12]
	test	edx, edx
	jne	SHORT $LN343@local_conv
$LN345@local_conv:

; 1809 :                  for ( vgptri=vgptri0; vgptri ; vgptri = vgptri->chain )

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	jne	SHORT $LN346@local_conv

; 1812 :                       for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(1)
$LN733@local_conv:

; 1799 :              volgrad *vgptr;
; 1800 :              for ( j = 0 ; j < ctrl ; j++ )

	mov	eax, DWORD PTR _j$[ebp]

; 1812 :                       for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _ctrl$90518[ebp]
	jl	$LL354@local_conv

; 1795 :           for ( i = 0 ; i < ctrl ; i++ )

	add	DWORD PTR tv4802[ebp], 4
	dec	DWORD PTR tv2586[ebp]
	jne	$LL357@local_conv
	mov	edi, DWORD PTR _web+124
$LN361@local_conv:

; 1790 : 
; 1791 :      if ( web.representation == STRING )
; 1792 :      { FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR tv3030[ebp]
	mov	eax, DWORD PTR [edx+edi]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL362@local_conv
$LN633@local_conv:

; 1814 :                   }
; 1815 :               }
; 1816 :             }
; 1817 :          }
; 1818 :       } /* end string */
; 1819 :      else /* soapfilm */

	mov	edi, DWORD PTR _web+5652
$LN1019@local_conv:

; 1842 :                  }
; 1843 :             }
; 1844 :           }
; 1845 :         }
; 1846 :       } /* end soapfilm */
; 1847 :     }  /* end Lagrange area_normalization */
; 1848 : 
; 1849 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ebx, DWORD PTR _dymem
	mov	DWORD PTR _v_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv3214[ebp], eax
	je	$LN658@local_conv
$LL309@local_conv:
	mov	ebx, DWORD PTR _v_id$[ebp]
	mov	edx, DWORD PTR _web+12
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+12]
	mov	eax, edx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN308@local_conv

; 1850 :   { ATTR attr = get_vattr(v_id);
; 1851 :     volgrad *vgptr0 = get_vertex_vgrad(v_id);

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	edi, edx
	push	eax
	mov	DWORD PTR _attr$90646[ebp], edi
	mov	DWORD PTR _attr$90646[ebp+4], esi
	call	_get_vertex_vgrad

; 1852 :     volgrad *vgptr;
; 1853 : 
; 1854 :     force = get_force(v_id);

	mov	ecx, DWORD PTR _web+12
	mov	esi, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	DWORD PTR _vgptr0$90648[ebp], eax
	mov	eax, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [esi+edx+784]
	add	ecx, eax
	mov	DWORD PTR _force$[ebp], ecx

; 1855 :     velocity = get_velocity(v_id);

	mov	ecx, DWORD PTR [esi+edx+1024]
	add	ecx, eax

; 1856 :     if ( mode & CALC_FORCE )

	mov	eax, DWORD PTR _mode$[ebp]
	add	esp, 4
	and	eax, 1
	mov	DWORD PTR _velocity$[ebp], ecx
	mov	DWORD PTR tv3076[ebp], eax
	je	$LN696@local_conv

; 1857 :       if ( attr & FIXED )

	mov	eax, edi
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN696@local_conv

; 1858 :       { memset((char*)velocity,0,SDIM*sizeof(REAL));

	mov	edx, DWORD PTR _web+616
	lea	eax, DWORD PTR [edx*8]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _velocity$[ebp]
	push	ecx
	call	_memset

; 1859 :         for ( vgptr=vgptr0 ; vgptr ; vgptr = vgptr->chain )

	mov	esi, DWORD PTR _vgptr0$90648[ebp]
	mov	ecx, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	test	esi, esi
	je	$LN308@local_conv
	fldz
$LN302@local_conv:

; 1860 :           for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN301@local_conv
	mov	edx, DWORD PTR [esi+20]
$LN299@local_conv:

; 1861 :             vgptr->velocity[i] = 0.0;

	fst	QWORD PTR [edx]
	mov	ecx, DWORD PTR _web+616
	inc	eax
	add	edx, 8
	cmp	eax, ecx
	jl	SHORT $LN299@local_conv
$LN301@local_conv:

; 1859 :         for ( vgptr=vgptr0 ; vgptr ; vgptr = vgptr->chain )

	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	jne	SHORT $LN302@local_conv

; 1862 :              continue;

	jmp	$LN1026@local_conv
$LN363@local_conv:

; 1820 :      { FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+272
	test	eax, 268435456				; 10000000H
	je	$LN633@local_conv
	mov	edi, DWORD PTR _web+236
$LL335@local_conv:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [edi+eax]
	mov	DWORD PTR tv3132[ebp], eax
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN334@local_conv

; 1821 :         { vertex_id *v_ptr = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _web+328
	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+esi+304]
	add	eax, edx
	mov	DWORD PTR _v_ptr$90595[ebp], eax

; 1822 :           ctrl = web.skel[FACET].ctrlpts;

	mov	eax, DWORD PTR _web+232
	mov	DWORD PTR _ctrl$90518[ebp], eax

; 1823 :           for ( i = 0 ; i < ctrl ; i++ )

	test	eax, eax
	jle	$LN334@local_conv
	mov	eax, DWORD PTR _mode$[ebp]
	mov	ecx, eax
	and	ecx, 1
	and	eax, 2
	mov	DWORD PTR tv3076[ebp], ecx
	mov	ecx, DWORD PTR _v_ptr$90595[ebp]
	mov	DWORD PTR tv3092[ebp], eax
	mov	eax, DWORD PTR _weights$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv5081[ebp], ecx
	mov	ecx, DWORD PTR _ctrl$90518[ebp]
	mov	DWORD PTR tv5145[ebp], eax
	mov	DWORD PTR tv1465[ebp], ecx
	npad	3
$LL330@local_conv:

; 1824 :           { REAL area = get_vertex_area_star(v_ptr[i]);

	mov	esi, DWORD PTR tv5081[ebp]
	mov	edx, DWORD PTR [esi]
	push	edx
	call	_get_vertex_area_star
	fstp	QWORD PTR _area$90603[ebp]

; 1825 :             REAL *f = get_force(v_ptr[i]);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR _web+12
	mov	esi, DWORD PTR _web+104
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	add	ecx, DWORD PTR [esi+edx+784]

; 1826 :             volgrad *vgptr0 = get_vertex_vgrad(v_ptr[i]);

	push	eax
	mov	DWORD PTR _f$90604[ebp], ecx
	call	_get_vertex_vgrad
	add	esp, 8
	mov	DWORD PTR _vgptr0$90609[ebp], eax

; 1827 :             volgrad *vgptr;
; 1828 :             for ( j = 0 ; j < ctrl ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	npad	7
$LL327@local_conv:

; 1829 :             { REAL *vel = get_velocity(v_ptr[j]);

	mov	ebx, DWORD PTR _v_ptr$90595[ebp]
	mov	edi, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ebx+edi*4]
	mov	edx, DWORD PTR _web+12
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	add	esi, DWORD PTR [edx+ecx+1024]

; 1830 :               REAL fudge = 1.0/get_vertex_fvalence(v_ptr[j]);

	push	eax
	call	_get_vertex_fvalence
	mov	DWORD PTR tv7372[ebp], eax
	fild	DWORD PTR tv7372[ebp]

; 1831 :               volgrad *vgptri;
; 1832 :               volgrad *vgptri0 = get_vertex_vgrad(v_ptr[j]);

	mov	eax, DWORD PTR [ebx+edi*4]
	fld1
	push	eax
	fdivrp	ST(1), ST(0)
	fstp	QWORD PTR _fudge$90619[ebp]
	call	_get_vertex_vgrad

; 1833 :               if ( mode & CALC_FORCE )
; 1834 :                 for ( k = 0 ; k < SDIM ; k++ )

	fld	QWORD PTR _area$90603[ebp]
	mov	ecx, DWORD PTR _web+616
	add	esp, 8
	cmp	DWORD PTR tv3076[ebp], 0
	mov	DWORD PTR _vgptri0$90621[ebp], eax
	je	SHORT $LN321@local_conv
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN321@local_conv

; 1827 :             volgrad *vgptr;
; 1828 :             for ( j = 0 ; j < ctrl ; j++ )

	mov	edx, DWORD PTR tv5145[ebp]
	mov	ecx, DWORD PTR tv5081[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	edx, edi

; 1833 :               if ( mode & CALC_FORCE )
; 1834 :                 for ( k = 0 ; k < SDIM ; k++ )

	mov	edi, DWORD PTR _f$90604[ebp]
	lea	ebx, DWORD PTR [ecx+edx*8]
	mov	edx, esi
	sub	edi, esi
$LN323@local_conv:

; 1835 :                   vel[k] += weights[i][j]*f[k]/area;

	fld	QWORD PTR [edi+edx]
	inc	eax
	fmul	QWORD PTR [ebx]
	add	edx, 8
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR [edx-8]
	fstp	QWORD PTR [edx-8]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN323@local_conv
$LN321@local_conv:

; 1836 :               if ( mode & CALC_VOLGRADS )

	cmp	DWORD PTR tv3092[ebp], 0
	je	SHORT $LN753@local_conv

; 1837 :                 for ( vgptri=vgptri0; vgptri ; vgptri = vgptri->chain )

	mov	edi, DWORD PTR _vgptri0$90621[ebp]
	test	edi, edi
	je	SHORT $LN753@local_conv
	fld	QWORD PTR _fudge$90619[ebp]
$LN319@local_conv:

; 1838 :                  for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edx, DWORD PTR _vgptr0$90609[ebp]
	test	edx, edx
	je	SHORT $LN318@local_conv
$LN316@local_conv:

; 1839 :                  { if ( vgptr->fixnum == vgptri->fixnum )

	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [edi]
	jne	SHORT $LN315@local_conv

; 1840 :                      for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN315@local_conv

; 1827 :             volgrad *vgptr;
; 1828 :             for ( j = 0 ; j < ctrl ; j++ )

	mov	esi, DWORD PTR tv5145[ebp]
	mov	ecx, DWORD PTR tv5081[ebp]
	mov	ecx, DWORD PTR [ecx+esi]
	mov	esi, DWORD PTR _j$[ebp]
	lea	esi, DWORD PTR [ecx+esi*8]
$LN312@local_conv:

; 1841 :                         vgptri->velocity[k] += fudge*weights[i][j]*vgptr->grad[k]/area;

	fld	QWORD PTR [esi]
	mov	ebx, DWORD PTR [edx+16]
	fmul	ST(0), ST(1)
	mov	ecx, DWORD PTR [edi+20]
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	eax
	fmul	QWORD PTR [ebx+eax*8-8]
	fdiv	ST(0), ST(2)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN312@local_conv
$LN315@local_conv:

; 1838 :                  for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edx, DWORD PTR [edx+12]
	test	edx, edx
	jne	SHORT $LN316@local_conv
$LN318@local_conv:

; 1837 :                 for ( vgptri=vgptri0; vgptri ; vgptri = vgptri->chain )

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	jne	SHORT $LN319@local_conv

; 1840 :                      for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(1)
$LN753@local_conv:

; 1827 :             volgrad *vgptr;
; 1828 :             for ( j = 0 ; j < ctrl ; j++ )

	mov	eax, DWORD PTR _j$[ebp]

; 1840 :                      for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _ctrl$90518[ebp]
	jl	$LL327@local_conv

; 1823 :           for ( i = 0 ; i < ctrl ; i++ )

	add	DWORD PTR tv5081[ebp], 4
	dec	DWORD PTR tv1465[ebp]
	jne	$LL330@local_conv
	mov	edi, DWORD PTR _web+236
$LN334@local_conv:

; 1820 :      { FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR tv3132[ebp]
	mov	eax, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL335@local_conv
	jmp	$LN633@local_conv
$LN632@local_conv:

; 1814 :                   }
; 1815 :               }
; 1816 :             }
; 1817 :          }
; 1818 :       } /* end string */
; 1819 :      else /* soapfilm */

	mov	ecx, DWORD PTR _web+616
	jmp	$LN1019@local_conv
$LN696@local_conv:

; 1863 :       }
; 1864 :         
; 1865 :     /* convert form to vector */
; 1866 : 
; 1867 :     if ( web.metric_flag && metric_convert_flag )

	cmp	DWORD PTR _web+1676, 0
	je	$LN296@local_conv
	cmp	DWORD PTR _metric_convert_flag, 0
	je	$LN296@local_conv

; 1868 :       FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR _v_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	je	$LN647@local_conv
	npad	2
$LL295@local_conv:
	mov	eax, DWORD PTR _v_id$[ebp]
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR tv3217[ebp], eax
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN294@local_conv

; 1869 :       { REAL *x = get_coord(v_id);

	mov	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR _dymem
	mov	edi, DWORD PTR [eax+esi+64]
	add	edi, edx

; 1870 :         REAL rr,rf;
; 1871 : 
; 1872 :         if ( klein_metric_flag )

	cmp	DWORD PTR _klein_metric_flag, 0
	je	$LN290@local_conv

; 1873 :         { /* M^-1 = (I - rxr)*(1-r^2) */
; 1874 :           rr = SDIM_dot(x,x);

	push	ecx
	push	edi
	push	edi
	call	_dot
	fstp	QWORD PTR _rr$90684[ebp]

; 1875 :           rf = SDIM_dot(x,force);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _force$[ebp]
	push	ecx
	push	edx
	push	edi
	call	_dot

; 1876 :           if ( mode & CALC_FORCE )
; 1877 :              for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 24					; 00000018H
	cmp	DWORD PTR tv3076[ebp], 0
	je	SHORT $LN779@local_conv
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN779@local_conv
	fld1
	mov	esi, DWORD PTR _force$[ebp]
	mov	ebx, DWORD PTR _velocity$[ebp]
	fsub	QWORD PTR _rr$90684[ebp]
	mov	ecx, edi
	neg	ecx
	add	esi, ecx
	mov	eax, edi
	add	ebx, ecx
$LN288@local_conv:

; 1878 :                velocity[j] = (force[j] - x[j]*rf)*(1-rr);

	fld	QWORD PTR [eax]
	inc	edx
	fmul	ST(0), ST(2)
	add	eax, 8
	fsubr	QWORD PTR [esi+eax-8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [ebx+eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN288@local_conv

; 1876 :           if ( mode & CALC_FORCE )
; 1877 :              for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
$LN779@local_conv:

; 1879 :           if ( mode & CALC_VOLGRADS )

	test	BYTE PTR _mode$[ebp], 2
	fstp	ST(0)
	je	$LN294@local_conv

; 1880 :             for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	eax, DWORD PTR _vgptr0$90648[ebp]
	mov	DWORD PTR _vgptr$90649[ebp], eax
	test	eax, eax
	je	$LN294@local_conv
$LL284@local_conv:

; 1881 :             { rf = SDIM_dot(x,vgptr->grad);

	mov	eax, DWORD PTR _vgptr$90649[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	edi
	call	_dot

; 1882 :               for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN785@local_conv
	mov	ecx, DWORD PTR _vgptr$90649[ebp]
	fld1
	mov	esi, DWORD PTR [ecx+16]
	fsub	QWORD PTR _rr$90684[ebp]
	mov	ebx, DWORD PTR [ecx+20]
	sub	esi, edi
	mov	eax, edi
	sub	ebx, edi
$LN281@local_conv:

; 1883 :                 vgptr->velocity[i] = (vgptr->grad[i] - x[i]*rf)*(1-rr);

	fld	ST(1)
	inc	edx
	fmul	QWORD PTR [eax]
	add	eax, 8
	fsubr	QWORD PTR [esi+eax-8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [ebx+eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN281@local_conv

; 1882 :               for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN785@local_conv:

; 1880 :             for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edx, DWORD PTR _vgptr$90649[ebp]

; 1882 :               for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _vgptr$90649[ebp], eax
	test	eax, eax
	jne	SHORT $LL284@local_conv

; 1884 :             }
; 1885 :          }
; 1886 :          else if ( web.conformal_flag )

	jmp	$LN294@local_conv
$LN290@local_conv:
	cmp	DWORD PTR _web+1680, 0
	je	$LN277@local_conv

; 1887 :          { REAL gg = eval(&web.metric[0][0],x,NULLID,NULL);

	push	0
	push	0
	push	edi
	push	OFFSET _web+1688
	call	_eval

; 1888 :            if ( gg == 0.0 )

	fld	ST(0)
	fldz
	add	esp, 16					; 00000010H
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN276@local_conv

; 1889 :              kb_error(1582,"Conformal metric evaluates to zero.\n",WARNING);

	push	2
	fstp	ST(0)
	push	OFFSET ??_C@_0CF@FKMFLFBL@Conformal?5metric?5evaluates?5to?5ze@
	push	1582					; 0000062eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN636@local_conv:

; 1890 :            else 

	mov	ecx, DWORD PTR _web+616
	jmp	SHORT $LN294@local_conv
$LN276@local_conv:

; 1891 :            { if ( mode & CALC_FORCE )

	cmp	DWORD PTR tv3076[ebp], 0

; 1892 :                for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	je	SHORT $LN708@local_conv
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN708@local_conv
	mov	eax, DWORD PTR _velocity$[ebp]
	mov	esi, DWORD PTR _force$[ebp]
	sub	esi, eax
$LN273@local_conv:

; 1893 :                  velocity[j] = force[j]/gg;

	fld	QWORD PTR [esi+eax]
	inc	edx
	fdiv	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN273@local_conv
$LN708@local_conv:

; 1894 :              if ( mode & CALC_VOLGRADS )

	test	BYTE PTR _mode$[ebp], 2
	je	SHORT $LN804@local_conv

; 1895 :                for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR _vgptr0$90648[ebp]
	test	edi, edi
	je	SHORT $LN804@local_conv
$LN269@local_conv:

; 1896 :                  for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN268@local_conv
	mov	eax, DWORD PTR [edi+20]
	mov	esi, DWORD PTR [edi+16]
	sub	esi, eax
$LN266@local_conv:

; 1897 :                    vgptr->velocity[j] = vgptr->grad[j]/gg;

	fld	QWORD PTR [esi+eax]
	inc	edx
	fdiv	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN266@local_conv
$LN268@local_conv:

; 1895 :                for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	jne	SHORT $LN269@local_conv
$LN804@local_conv:
	fstp	ST(0)
$LN294@local_conv:

; 1868 :       FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR tv3217[ebp]
	mov	edx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _v_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL295@local_conv

; 1911 :          }
; 1912 : 
; 1913 :       }
; 1914 :       else

	jmp	$LN647@local_conv
$LN277@local_conv:

; 1898 :            }
; 1899 :          }
; 1900 :          else
; 1901 :          { /* if here, have general metric */
; 1902 :            for (  i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	ecx, ecx
	jle	SHORT $LN260@local_conv
	mov	DWORD PTR tv5418[ebp], OFFSET _web+1688
$LL262@local_conv:

; 1903 :              for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN261@local_conv
	mov	ebx, DWORD PTR tv5418[ebp]
	npad	1
$LL259@local_conv:

; 1904 :                 metric[i][j] = eval(&web.metric[i][j],x,NULLID,NULL);

	push	0
	push	0
	push	edi
	push	ebx
	call	_eval
	mov	eax, DWORD PTR _metric
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	fstp	QWORD PTR [edx+esi*8]
	mov	ecx, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	add	ebx, 104				; 00000068H
	cmp	esi, ecx
	jl	SHORT $LL259@local_conv
$LN261@local_conv:

; 1898 :            }
; 1899 :          }
; 1900 :          else
; 1901 :          { /* if here, have general metric */
; 1902 :            for (  i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv5418[ebp], 624		; 00000270H
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, ecx
	jl	SHORT $LL262@local_conv
$LN260@local_conv:

; 1905 :            mat_inv(metric,SDIM);

	mov	eax, DWORD PTR _metric
	push	ecx
	push	eax
	call	_mat_inv
	add	esp, 8

; 1906 :            if ( mode & CALC_FORCE )

	cmp	DWORD PTR tv3076[ebp], 0
	je	SHORT $LN256@local_conv

; 1907 :               matvec_mul(metric,force,velocity,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _velocity$[ebp]
	mov	edx, DWORD PTR _force$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR _metric
	push	ecx
	push	edx
	push	eax
	call	_matvec_mul
	add	esp, 20					; 00000014H
$LN256@local_conv:

; 1908 :            if ( mode & CALC_VOLGRADS )

	test	BYTE PTR _mode$[ebp], 2
	je	$LN636@local_conv

; 1909 :               for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	esi, DWORD PTR _vgptr0$90648[ebp]
	test	esi, esi
	je	$LN636@local_conv
	npad	5
$LL254@local_conv:

; 1910 :                 matvec_mul(metric,vgptr->grad,vgptr->velocity,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi+16]
	push	eax
	push	eax
	mov	eax, DWORD PTR _metric
	push	ecx
	push	edx
	push	eax
	call	_matvec_mul
	mov	esi, DWORD PTR [esi+12]
	add	esp, 20					; 00000014H
	test	esi, esi
	jne	SHORT $LL254@local_conv

; 1909 :               for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	ecx, DWORD PTR _web+616
	jmp	$LN294@local_conv
$LN296@local_conv:

; 1915 :       if ( web.area_norm_flag && !approx_curve_flag) 

	cmp	DWORD PTR _web+876, 0
	je	$LN250@local_conv
	cmp	DWORD PTR _approx_curve_flag, 0
	jne	$LN250@local_conv

; 1916 :         switch ( web.modeltype )

	mov	eax, DWORD PTR _web+628
	mov	edi, 1
	sub	eax, edi
	je	$LN247@local_conv
	sub	eax, edi
	jne	$LN644@local_conv

; 1985 :              }
; 1986 : 
; 1987 :             }
; 1988 :             break;
; 1989 : 
; 1990 :             case QUADRATIC:
; 1991 :             /* area weights carefully chosen to make volume grad vector 
; 1992 :                 constant for flat surface */
; 1993 :               { edge_id e_id, start_e;
; 1994 : 
; 1995 :                  if ( get_vattr(v_id) & Q_MIDPOINT )

	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 131072				; 00020000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN204@local_conv

; 1996 :                  { REAL area = (web.representation==STRING) ?
; 1997 :                                 get_vertex_length_star(v_id)*2/3.:
; 1998 :                                 get_vertex_area_star(v_id)*2/3.;

	cmp	DWORD PTR _web+624, edi
	jne	SHORT $LN391@local_conv
	mov	ecx, DWORD PTR _v_id$[ebp]
	push	ecx
	call	_get_vertex_length_star
	jmp	SHORT $LN1020@local_conv
$LN391@local_conv:
	mov	edx, DWORD PTR _v_id$[ebp]
	push	edx
	call	_get_vertex_area_star
$LN1020@local_conv:

; 1999 :                     if ( mode & CALC_FORCE )
; 2000 :                      for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	fadd	ST(0), ST(0)
	add	esp, 4
	cmp	DWORD PTR tv3076[ebp], 0
	fdiv	QWORD PTR __real@4008000000000000
	je	SHORT $LN684@local_conv
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN684@local_conv
	mov	eax, DWORD PTR _velocity$[ebp]
	mov	esi, DWORD PTR _force$[ebp]
	sub	esi, eax
$LN202@local_conv:

; 2001 :                       velocity[i] = force[i]/area;

	fld	QWORD PTR [eax+esi]
	add	edx, edi
	fdiv	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN202@local_conv
$LN684@local_conv:

; 2002 :                     if ( mode & CALC_VOLGRADS )

	test	BYTE PTR _mode$[ebp], 2
	je	SHORT $LN914@local_conv

; 2003 :                      for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR _vgptr0$90648[ebp]
	test	edi, edi
	je	SHORT $LN914@local_conv
$LN198@local_conv:

; 2004 :                       for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN197@local_conv
	mov	eax, DWORD PTR [edi+20]
	mov	esi, DWORD PTR [edi+16]
	sub	esi, eax
$LN195@local_conv:

; 2005 :                          vgptr->velocity[i] = vgptr->grad[i]/area;

	fld	QWORD PTR [eax+esi]
	inc	edx
	fdiv	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN195@local_conv
$LN197@local_conv:

; 2003 :                      for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	jne	SHORT $LN198@local_conv
$LN914@local_conv:

; 1982 :                 for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	fstp	ST(0)
$LN647@local_conv:

; 2063 :           }
; 2064 : 
; 2065 : 
; 2066 :     /* apply mobility */
; 2067 :     if ( mobility_flag )

	cmp	DWORD PTR _mobility_flag, 0
	je	$LN650@local_conv

; 2068 :     { if ( mobility_tensor_flag )

	cmp	DWORD PTR _mobility_tensor_flag, 0
	je	$LN147@local_conv

; 2069 :       { REAL *x = get_coord(v_id);

	mov	edx, DWORD PTR _v_id$[ebp]
	mov	eax, DWORD PTR _web+12
	mov	esi, DWORD PTR _dymem
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+104
	add	eax, DWORD PTR [edx+esi+64]

; 2070 :         REAL newv[MAXCOORD];
; 2071 :         REAL mob[MAXCOORD][MAXCOORD];
; 2072 : 
; 2073 :         for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _x$90876[ebp], eax
	test	ecx, ecx
	jle	SHORT $LN144@local_conv

; 2044 :                     }
; 2045 :                  }
; 2046 :               }

	lea	eax, DWORD PTR _mob$90882[ebp]
	mov	DWORD PTR tv5868[ebp], OFFSET _mobility_tensor
	mov	DWORD PTR tv5870[ebp], eax
	npad	7
$LL146@local_conv:

; 2074 :           for ( j = 0 ; j < SDIM ; j++ ) 

	xor	ebx, ebx
	test	ecx, ecx
	jle	SHORT $LN145@local_conv
	mov	edi, DWORD PTR tv5870[ebp]
	mov	esi, DWORD PTR tv5868[ebp]
$LL143@local_conv:

; 2075 :             mob[i][j] = eval(&mobility_tensor[i][j],x,v_id,NULL);

	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	edx, DWORD PTR _x$90876[ebp]
	push	0
	push	ecx
	push	edx
	push	esi
	call	_eval
	fstp	QWORD PTR [edi]
	mov	ecx, DWORD PTR _web+616
	inc	ebx
	add	esp, 16					; 00000010H
	add	esi, 104				; 00000068H
	add	edi, 8
	cmp	ebx, ecx
	jl	SHORT $LL143@local_conv
$LN145@local_conv:

; 2070 :         REAL newv[MAXCOORD];
; 2071 :         REAL mob[MAXCOORD][MAXCOORD];
; 2072 : 
; 2073 :         for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv5870[ebp], 48		; 00000030H
	add	DWORD PTR tv5868[ebp], 624		; 00000270H
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, ecx
	jl	SHORT $LL146@local_conv
$LN144@local_conv:

; 2076 : 
; 2077 :         if ( mode & CALC_FORCE )

	cmp	DWORD PTR tv3076[ebp], 0

; 2078 :         { for ( i = 0 ; i < SDIM ; i++ )

	fldz
	je	SHORT $LN712@local_conv
	mov	edi, DWORD PTR _velocity$[ebp]
	test	ecx, ecx
	jle	SHORT $LN137@local_conv
	lea	ebx, DWORD PTR _mob$90882[ebp]
	lea	edx, DWORD PTR _newv$90881[ebp]
	mov	DWORD PTR tv1469[ebp], ecx
$LN139@local_conv:

; 2079 :             for ( newv[i] = 0.0, j = 0; j < SDIM ; j++ )

	fst	QWORD PTR [edx]
	xor	eax, eax
	fld	QWORD PTR [edx]
	mov	esi, ebx
$LN136@local_conv:

; 2080 :               newv[i] += mob[i][j]*velocity[j];

	fld	QWORD PTR [edi+eax*8]
	inc	eax
	fmul	QWORD PTR [esi]
	add	esi, 8
	faddp	ST(1), ST(0)
	cmp	eax, ecx
	jl	SHORT $LN136@local_conv

; 2078 :         { for ( i = 0 ; i < SDIM ; i++ )

	fstp	QWORD PTR [edx]
	add	edx, 8
	add	ebx, 48					; 00000030H
	dec	DWORD PTR tv1469[ebp]
	jne	SHORT $LN139@local_conv
$LN137@local_conv:

; 2081 :           for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN712@local_conv
	lea	esi, DWORD PTR _newv$90881[ebp]
	mov	eax, edi
	sub	esi, edi
$LN133@local_conv:

; 2082 :             velocity[i] = newv[i];

	fld	QWORD PTR [esi+eax]
	inc	edx
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR _web+616
	add	eax, 8
	cmp	edx, ecx
	jl	SHORT $LN133@local_conv
$LN712@local_conv:

; 2083 :         }
; 2084 : 
; 2085 :         if ( mode & CALC_VOLGRADS )

	test	BYTE PTR _mode$[ebp], 2
	je	$LN978@local_conv

; 2086 :           for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	eax, DWORD PTR _vgptr0$90648[ebp]
	mov	DWORD PTR _vgptr$90649[ebp], eax
	test	eax, eax
	je	$LN978@local_conv
$LN690@local_conv:

; 2087 :           { for ( i = 0 ; i < SDIM ; i++ )

	test	ecx, ecx
	jle	SHORT $LN124@local_conv
	lea	ebx, DWORD PTR _mob$90882[ebp]
	lea	eax, DWORD PTR _newv$90881[ebp]
	mov	DWORD PTR tv1357[ebp], ecx
$LN126@local_conv:

; 2088 :               for ( newv[i] = 0.0, j = 0; j < SDIM ; j++ )

	mov	edx, DWORD PTR _vgptr$90649[ebp]
	fst	QWORD PTR [eax]
	mov	edx, DWORD PTR [edx+20]
	fld	QWORD PTR [eax]
	mov	esi, ebx
	mov	edi, ecx
$LN123@local_conv:

; 2089 :                 newv[i] += mob[i][j]*vgptr->velocity[j];

	fld	QWORD PTR [edx]
	add	edx, 8
	fmul	QWORD PTR [esi]
	add	esi, 8
	dec	edi
	faddp	ST(1), ST(0)
	jne	SHORT $LN123@local_conv

; 2087 :           { for ( i = 0 ; i < SDIM ; i++ )

	fstp	QWORD PTR [eax]
	add	eax, 8
	add	ebx, 48					; 00000030H
	dec	DWORD PTR tv1357[ebp]
	jne	SHORT $LN126@local_conv
$LN124@local_conv:

; 2090 :             for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN128@local_conv

; 2164 :           { REAL *raw_velocity = VREAL(v_id,raw_velocity_attr);

	mov	eax, DWORD PTR _vgptr$90649[ebp]
	mov	eax, DWORD PTR [eax+20]
	lea	esi, DWORD PTR _newv$90881[ebp]
	sub	esi, eax
$LN120@local_conv:

; 2090 :             for ( i = 0 ; i < SDIM ; i++ )

	fld	QWORD PTR [esi+eax]
	inc	edx

; 2091 :               vgptr->velocity[i] = newv[i];

	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR _web+616
	add	eax, 8
	cmp	edx, ecx
	jl	SHORT $LN120@local_conv
$LN128@local_conv:

; 2086 :           for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edx, DWORD PTR _vgptr$90649[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _vgptr$90649[ebp], eax
	test	eax, eax
	jne	SHORT $LN690@local_conv

; 2092 :           }
; 2093 :       } /* end mobility_tensor */
; 2094 :       else

	jmp	$LN978@local_conv
$LN204@local_conv:

; 2006 :                  }
; 2007 :                  else /* corner vertex */
; 2008 :                  { REAL area;
; 2009 :                  
; 2010 :                     /* first, self term */
; 2011 :                     area = (web.representation==STRING) ?
; 2012 :                                 get_vertex_length_star(v_id)/6:
; 2013 :                                 get_vertex_area_star(v_id)/5.;

	cmp	DWORD PTR _web+624, edi
	jne	SHORT $LN393@local_conv
	mov	eax, DWORD PTR _v_id$[ebp]
	push	eax
	call	_get_vertex_length_star
	fdiv	QWORD PTR __real@4018000000000000
	jmp	SHORT $LN1021@local_conv
$LN393@local_conv:
	mov	ecx, DWORD PTR _v_id$[ebp]
	push	ecx
	call	_get_vertex_area_star
	fdiv	QWORD PTR __real@4014000000000000
$LN1021@local_conv:

; 2014 :                     if ( mode & CALC_FORCE )
; 2015 :                      for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 4
	cmp	DWORD PTR tv3076[ebp], 0
	je	SHORT $LN685@local_conv
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN685@local_conv
	mov	eax, DWORD PTR _velocity$[ebp]
	mov	esi, DWORD PTR _force$[ebp]
	sub	esi, eax
$LN190@local_conv:

; 2016 :                       velocity[i] = force[i]/area;

	fld	QWORD PTR [eax+esi]
	add	edx, edi
	fdiv	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN190@local_conv
$LN685@local_conv:

; 2017 :                     if ( mode & CALC_VOLGRADS )

	mov	eax, DWORD PTR _mode$[ebp]
	and	eax, 2
	mov	DWORD PTR tv3092[ebp], eax
	je	SHORT $LN852@local_conv

; 2018 :                      for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR _vgptr0$90648[ebp]
	test	edi, edi
	je	SHORT $LN852@local_conv
$LN186@local_conv:

; 2019 :                       for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN185@local_conv
	mov	eax, DWORD PTR [edi+20]
	mov	esi, DWORD PTR [edi+16]
	sub	esi, eax
$LN183@local_conv:

; 2020 :                          vgptr->velocity[i] = vgptr->grad[i]/area;

	fld	QWORD PTR [eax+esi]
	inc	edx
	fdiv	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN183@local_conv
$LN185@local_conv:

; 2018 :                      for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	jne	SHORT $LN186@local_conv
$LN852@local_conv:

; 2021 : 
; 2022 :                     /* next, neighboring midpoints */
; 2023 :                     if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	fstp	ST(0)
	jne	$LN647@local_conv

; 2024 :                     { start_e = e_id = get_vertex_edge(v_id);

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	eax, DWORD PTR [eax+28]

; 2025 :                       area = get_vertex_area_star(v_id)*4/3;

	mov	ecx, DWORD PTR _v_id$[ebp]
	push	ecx
	mov	DWORD PTR _e_id$90799[ebp], eax
	mov	DWORD PTR _start_e$90800[ebp], eax
	call	_get_vertex_area_star
	fmul	QWORD PTR __real@4010000000000000
	mov	eax, DWORD PTR _web+124
	add	esp, 4
	fdiv	QWORD PTR __real@4008000000000000
	fstp	QWORD PTR _area$90817[ebp]
	npad	10
$LL179@local_conv:

; 2026 :                       do 
; 2027 :                       { vertex_id vv_id = get_edge_midv(e_id);

	mov	ebx, DWORD PTR _e_id$90799[ebp]
	mov	ecx, DWORD PTR _dymem

; 2028 :                          REAL *ff = get_force(vv_id);

	mov	esi, DWORD PTR _web+12
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax+8]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR _web+104
	add	edi, DWORD PTR [edx+ecx+784]

; 2029 :                          volgrad *vgptri;
; 2030 :                          volgrad *vgptri0 = get_vertex_vgrad(vv_id);

	push	eax
	call	_get_vertex_vgrad

; 2031 : 
; 2032 :                          if ( mode & CALC_FORCE )
; 2033 :                           for ( i = 0 ; i < SDIM ; i++ )

	fld	QWORD PTR _area$90817[ebp]
	mov	ecx, DWORD PTR _web+616
	add	esp, 4
	cmp	DWORD PTR tv3076[ebp], 0
	je	SHORT $LN173@local_conv
	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN173@local_conv
	mov	edx, DWORD PTR _velocity$[ebp]
	sub	edi, edx
$LN175@local_conv:

; 2034 :                             velocity[i] += ff[i]/area;

	fld	QWORD PTR [edi+edx]
	inc	esi
	fdiv	ST(0), ST(1)
	add	edx, 8
	fadd	QWORD PTR [edx-8]
	fstp	QWORD PTR [edx-8]
	mov	ecx, DWORD PTR _web+616
	cmp	esi, ecx
	jl	SHORT $LN175@local_conv
$LN173@local_conv:

; 2035 :                          if ( mode & CALC_VOLGRADS )

	cmp	DWORD PTR tv3092[ebp], 0
	je	SHORT $LN868@local_conv

; 2036 :                           for ( vgptri=vgptri0; vgptri ; vgptri = vgptri->chain )

	mov	esi, eax
	test	eax, eax
	je	SHORT $LN868@local_conv
$LN171@local_conv:

; 2037 :                             for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edx, DWORD PTR _vgptr0$90648[ebp]
	test	edx, edx
	je	SHORT $LN170@local_conv
$LN168@local_conv:

; 2038 :                             { if ( vgptr->fixnum == vgptri->fixnum )

	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN167@local_conv

; 2039 :                                  for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN167@local_conv
$LN164@local_conv:

; 2040 :                                     vgptr->velocity[i] += vgptri->grad[i]/area;

	mov	edi, DWORD PTR [esi+16]
	fld	QWORD PTR [edi+eax*8]
	mov	ecx, DWORD PTR [edx+20]
	fdiv	ST(0), ST(1)
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	eax
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN164@local_conv
$LN167@local_conv:

; 2037 :                             for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edx, DWORD PTR [edx+12]
	test	edx, edx
	jne	SHORT $LN168@local_conv
$LN170@local_conv:

; 2036 :                           for ( vgptri=vgptri0; vgptri ; vgptri = vgptri->chain )

	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	jne	SHORT $LN171@local_conv
$LN868@local_conv:

; 2041 :                             }
; 2042 :                          e_id = get_next_tail_edge(e_id);

	mov	edx, DWORD PTR _e_id$90799[ebp]
	fstp	ST(0)
	mov	eax, DWORD PTR _web+124
	mov	esi, DWORD PTR [ebx+eax]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	edx, DWORD PTR [esi+edx*4+32]
	mov	DWORD PTR _e_id$90799[ebp], edx

; 2043 :                       } while ( !equal_id(start_e,e_id) );

	cmp	DWORD PTR _start_e$90800[ebp], edx
	jne	$LL179@local_conv

; 2047 :               break;

	jmp	$LN647@local_conv
$LN247@local_conv:

; 1917 :         { case LINEAR:
; 1918 :           { REAL area=((web.representation==STRING)?get_vertex_length_star(v_id):
; 1919 :                               get_vertex_area_star(v_id))/star_fraction;

	mov	esi, DWORD PTR _v_id$[ebp]
	push	esi
	cmp	DWORD PTR _web+624, edi
	jne	SHORT $LN387@local_conv
	call	_get_vertex_length_star
	jmp	SHORT $LN1022@local_conv
$LN387@local_conv:
	call	_get_vertex_area_star
$LN1022@local_conv:
	fdiv	QWORD PTR _star_fraction

; 1920 :             REAL ff;
; 1921 :             if ( get_vattr(v_id) & FIXED ) continue;

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	add	esp, 4
	or	eax, ecx
	fst	QWORD PTR _area$90736[ebp]
	jne	$LN871@local_conv

; 1922 :             if ( effective_area_flag && (web.representation == STRING) )

	cmp	DWORD PTR _effective_area_flag, ecx
	je	$LN692@local_conv
	mov	eax, DWORD PTR _web+624
	cmp	eax, edi
	jne	$LN245@local_conv

; 1923 :             { /* calculate effective area */
; 1924 :               int valence = get_vertex_evalence(v_id);

	push	esi
	fstp	ST(0)
	call	_get_vertex_evalence
	add	esp, 4

; 1925 :               if ( (valence == 2) || (valence==1) )

	cmp	eax, 2
	je	$LN243@local_conv
	cmp	eax, edi
	je	$LN243@local_conv

; 1928 :               }
; 1929 :               else if ( valence == 0 )

	test	eax, eax
	jne	SHORT $LN241@local_conv

; 1930 :                 area = 1.0;  /* disconnected pt; no force anyway */

	fld1

; 1931 :               else /* triple point at least */

	jmp	$LN229@local_conv
$LN241@local_conv:

; 1932 :               { edge_id e_id,start_e;
; 1933 :                 REAL ss,fs,side[MAXCOORD];
; 1934 :                 area = 0.0;
; 1935 :                 e_id = start_e = get_vertex_edge(v_id);

	mov	eax, DWORD PTR _web+12
	fldz
	mov	ecx, DWORD PTR [eax+ebx*4]
	fstp	QWORD PTR _area$90736[ebp]
	mov	edi, DWORD PTR [ecx+28]
	mov	esi, edi
	jmp	SHORT $LN239@local_conv
$LL927@local_conv:
	fstp	ST(0)
$LN239@local_conv:

; 1936 :                 do
; 1937 :                 { double det;
; 1938 :                   get_edge_side(e_id,side);

	lea	edx, DWORD PTR _side$90753[ebp]
	push	edx
	push	esi
	call	_get_edge_side

; 1939 :                   ss = SDIM_dot(side,side);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _side$90753[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _ss$90751[ebp]

; 1940 :                   fs = SDIM_dot(force,side);

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR _force$[ebp]
	push	eax
	lea	ecx, DWORD PTR _side$90753[ebp]
	push	ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _fs$90752[ebp]

; 1941 :                   ff = SDIM_dot(force,force);

	mov	eax, DWORD PTR _web+616
	push	eax
	mov	eax, DWORD PTR _force$[ebp]
	push	eax
	push	eax
	call	_dot
	fst	QWORD PTR _ff$90737[ebp]

; 1942 :                   det = ff*ss - fs*fs;

	fmul	QWORD PTR _ss$90751[ebp]
	add	esp, 44					; 0000002cH
	fld	QWORD PTR _fs$90752[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)

; 1943 :                   if ( det > 0.0 )

	fldz
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN923@local_conv

; 1944 :                      area += 0.5*sqrt(det)/sqrt(ff);

	call	__CIsqrt
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR tv6897[ebp]
	fld	QWORD PTR _ff$90737[ebp]
	call	__CIsqrt
	fdivr	QWORD PTR tv6897[ebp]
	fadd	QWORD PTR _area$90736[ebp]
	fst	QWORD PTR _area$90736[ebp]
	jmp	SHORT $LN236@local_conv
$LN923@local_conv:

; 1943 :                   if ( det > 0.0 )

	fstp	ST(0)

; 1944 :                      area += 0.5*sqrt(det)/sqrt(ff);

	fld	QWORD PTR _area$90736[ebp]
$LN236@local_conv:

; 1945 :                    e_id = get_next_tail_edge(e_id);

	mov	edx, DWORD PTR _web+124
	mov	ecx, esi
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	esi, DWORD PTR [eax+ecx*4+32]

; 1946 :                  }
; 1947 :                  while ( !equal_id(e_id,start_e) );

	cmp	esi, edi
	jne	$LL927@local_conv
	jmp	$LN692@local_conv
$LN243@local_conv:

; 1926 :               { REAL dummy[MAXCOORD];;
; 1927 :                 area = calc_vertex_normal(v_id,get_vertex_fe(v_id),dummy)/2;

	lea	ecx, DWORD PTR _dummy$90745[ebp]
	push	ecx
	push	esi
	call	_get_vertex_fe
	add	esp, 4
	push	eax
	push	esi
	call	_calc_vertex_normal
	fmul	QWORD PTR __real@3fe0000000000000

; 1948 :                }

	jmp	SHORT $LN1023@local_conv
$LN245@local_conv:

; 1949 :              }
; 1950 :              else if ( effective_area_flag && (web.representation == SOAPFILM) )

	cmp	eax, 2
	jne	SHORT $LN692@local_conv

; 1951 :              { /* crude correction for triple edges and tetra points */
; 1952 :                 REAL dummy[MAXCOORD];
; 1953 :                 if ( get_vattr(v_id) & TRIPLE_PT )

	mov	eax, DWORD PTR [edx+ebx*4]
	fstp	ST(0)
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	mov	DWORD PTR tv3422[ebp+4], edx
	and	eax, 524288				; 00080000H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN233@local_conv

; 1954 :                 { area /= sqrt(3.);

	fld	QWORD PTR __real@4008000000000000
	call	__CIsqrt
	fdivr	QWORD PTR _area$90736[ebp]
	jmp	SHORT $LN692@local_conv
$LN233@local_conv:

; 1955 :                 }
; 1956 :                 else if ( get_vattr(v_id) & TETRA_PT )

	and	ecx, 262144				; 00040000H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN231@local_conv

; 1957 :                 { area /= sqrt(6.);

	fld	QWORD PTR __real@4018000000000000
	call	__CIsqrt
	fdivr	QWORD PTR _area$90736[ebp]

; 1958 :                 }
; 1959 :                 else area = calc_vertex_normal(v_id,get_vertex_fe(v_id),dummy)

	jmp	SHORT $LN692@local_conv
$LN231@local_conv:

; 1960 :                                               /star_fraction;

	lea	eax, DWORD PTR _dummy$90762[ebp]
	push	eax
	push	esi
	call	_get_vertex_fe
	add	esp, 4
	push	eax
	push	esi
	call	_calc_vertex_normal
	fdiv	QWORD PTR _star_fraction
$LN1023@local_conv:
	add	esp, 12					; 0000000cH
$LN692@local_conv:

; 1961 :              }
; 1962 :              if ( area == 0.0 )  

	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	$LN882@local_conv

; 1963 :              { 
; 1964 :                if ( mode & CALC_FORCE )

	cmp	DWORD PTR tv3076[ebp], 0
	fstp	ST(1)

; 1965 :                 for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	je	SHORT $LN710@local_conv
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN710@local_conv
$LN227@local_conv:

; 1966 :                   velocity[i] = 0.0;

	mov	ecx, DWORD PTR _velocity$[ebp]
	fst	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR _web+616
	inc	eax
	cmp	eax, edx
	jl	SHORT $LN227@local_conv
$LN710@local_conv:

; 1967 :                if ( mode & CALC_VOLGRADS )

	test	BYTE PTR _mode$[ebp], 2
	je	SHORT $LN900@local_conv

; 1968 :                 for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	esi, DWORD PTR _vgptr0$90648[ebp]
	test	esi, esi
	je	SHORT $LN900@local_conv
$LN223@local_conv:

; 1969 :                    for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN222@local_conv
	mov	ecx, DWORD PTR [esi+20]
$LN220@local_conv:

; 1970 :                       vgptr->velocity[i] = 0.0;

	fst	QWORD PTR [ecx]
	mov	edx, DWORD PTR _web+616
	inc	eax
	add	ecx, 8
	cmp	eax, edx
	jl	SHORT $LN220@local_conv
$LN222@local_conv:

; 1968 :                 for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	jne	SHORT $LN223@local_conv
$LN900@local_conv:

; 1971 : 
; 1972 :                sprintf(errmsg,"Zero area star around vertex %s.\n",
; 1973 :                  ELNAME(v_id));

	cmp	DWORD PTR tv3214[ebp], 0
	fstp	ST(0)
	je	SHORT $LN389@local_conv
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN390@local_conv
$LN389@local_conv:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN390@local_conv:
	push	eax
	push	OFFSET ??_C@_0CC@GAAKDFFE@Zero?5area?5star?5around?5vertex?5?$CFs?4@
	push	OFFSET _errmsg
	call	_sprintf

; 1974 :                kb_error(1775,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1775					; 000006efH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN644@local_conv:

; 1975 :              }
; 1976 :              else

	mov	ecx, DWORD PTR _web+616
	jmp	$LN647@local_conv
$LN882@local_conv:

; 1961 :              }
; 1962 :              if ( area == 0.0 )  

	fstp	ST(0)

; 1975 :              }
; 1976 :              else

	mov	edi, 1
$LN229@local_conv:

; 1977 :              {
; 1978 :                if ( mode & CALC_FORCE )

	cmp	DWORD PTR tv3076[ebp], 0

; 1979 :                 for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	je	SHORT $LN687@local_conv
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN687@local_conv
	mov	eax, DWORD PTR _velocity$[ebp]
	mov	esi, DWORD PTR _force$[ebp]
	sub	esi, eax
$LN215@local_conv:

; 1980 :                   velocity[i] = force[i]/area;

	fld	QWORD PTR [eax+esi]
	add	edx, edi
	fdiv	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN215@local_conv
$LN687@local_conv:

; 1981 :                if ( mode & CALC_VOLGRADS )

	test	BYTE PTR _mode$[ebp], 2
	je	$LN914@local_conv

; 1982 :                 for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR _vgptr0$90648[ebp]
	test	edi, edi
	je	$LN914@local_conv
$LN211@local_conv:

; 1983 :                    for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN210@local_conv
	mov	eax, DWORD PTR [edi+20]
	mov	esi, DWORD PTR [edi+16]
	sub	esi, eax
$LN208@local_conv:

; 1984 :                       vgptr->velocity[i] = vgptr->grad[i]/area;

	fld	QWORD PTR [eax+esi]
	inc	edx
	fdiv	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN208@local_conv
$LN210@local_conv:

; 1982 :                 for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	jne	SHORT $LN211@local_conv

; 2048 : 
; 2049 :             case LAGRANGE: /* did earlier */
; 2050 :             break;
; 2051 : 
; 2052 :           } /* end area_normalization */
; 2053 : 
; 2054 :           else /* not any special mobility */

	jmp	$LN914@local_conv
$LN250@local_conv:

; 2055 :           {
; 2056 :              if ( mode & CALC_FORCE )

	cmp	DWORD PTR tv3076[ebp], 0

; 2057 :               for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	je	SHORT $LN688@local_conv
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN688@local_conv
	mov	eax, DWORD PTR _velocity$[ebp]
	mov	esi, DWORD PTR _force$[ebp]
	sub	esi, eax
$LL158@local_conv:

; 2058 :                 velocity[i] = force[i]; /* identity metric */

	fld	QWORD PTR [eax+esi]
	inc	edx
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR _web+616
	add	eax, 8
	cmp	edx, ecx
	jl	SHORT $LL158@local_conv
$LN688@local_conv:

; 2059 :              if ( mode & CALC_VOLGRADS )

	test	BYTE PTR _mode$[ebp], 2
	je	$LN647@local_conv

; 2060 :               for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR _vgptr0$90648[ebp]
	test	edi, edi
	je	$LN647@local_conv
	npad	3
$LL154@local_conv:

; 2061 :                 for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN153@local_conv
	mov	eax, DWORD PTR [edi+20]
	mov	esi, DWORD PTR [edi+16]
	sub	esi, eax
	npad	2
$LL151@local_conv:

; 2062 :                   vgptr->velocity[i] = vgptr->grad[i];

	fld	QWORD PTR [eax+esi]
	inc	edx
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR _web+616
	add	eax, 8
	cmp	edx, ecx
	jl	SHORT $LL151@local_conv
$LN153@local_conv:

; 2060 :               for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	jne	SHORT $LL154@local_conv
	jmp	$LN647@local_conv
$LN147@local_conv:

; 2095 :       { REAL mobility = eval(&mobility_formula,get_coord(v_id),v_id,NULL);

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR _web+12
	push	0
	push	eax
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+64]
	push	edx
	push	OFFSET _mobility_formula
	call	_eval

; 2096 :         if ( mode & CALC_FORCE )
; 2097 :           for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	cmp	DWORD PTR tv3076[ebp], 0
	je	SHORT $LN714@local_conv
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN714@local_conv
	mov	edx, DWORD PTR _velocity$[ebp]
$LN115@local_conv:

; 2098 :             velocity[j] *= mobility;

	fld	ST(0)
	inc	eax
	fmul	QWORD PTR [edx+eax*8-8]
	fstp	QWORD PTR [edx+eax*8-8]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN115@local_conv
$LN714@local_conv:

; 2099 :         if ( mode & CALC_VOLGRADS )

	test	BYTE PTR _mode$[ebp], 2
	je	SHORT $LN978@local_conv

; 2100 :           for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	esi, DWORD PTR _vgptr0$90648[ebp]
	test	esi, esi
	je	SHORT $LN978@local_conv
$LN111@local_conv:

; 2101 :             for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN110@local_conv
	mov	eax, DWORD PTR [esi+20]
$LN108@local_conv:

; 2102 :               vgptr->velocity[i] *= mobility;

	fld	QWORD PTR [eax]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN108@local_conv
$LN110@local_conv:

; 2100 :           for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	jne	SHORT $LN111@local_conv
$LN978@local_conv:

; 2101 :             for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN650@local_conv:

; 2103 :       }
; 2104 :     } /* end mobility */
; 2105 :     
; 2106 : 
; 2107 : 
; 2108 :         /* project vector to pointwise constraints */
; 2109 : 
; 2110 :         if ( normal_motion_flag && !(attr & BOUNDARY) )  

	cmp	DWORD PTR _normal_motion_flag, 0
	je	$LN676@local_conv
	mov	eax, DWORD PTR _attr$90646[ebp]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	jne	$LN676@local_conv

; 2111 :         { /* project to normal */
; 2112 :           REAL d;
; 2113 :           REAL *normal = vertex_normals[loc_ordinal(v_id)];

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	esi, eax
	shr	esi, 28					; 0000001cH
	and	esi, 1
	mov	DWORD PTR tv3214[ebp], esi
	je	SHORT $LN395@local_conv
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN396@local_conv
$LN395@local_conv:
	or	eax, -1
$LN396@local_conv:
	lea	ebx, DWORD PTR [eax+eax*2]
	shl	ebx, 4
	add	ebx, DWORD PTR _vertex_normals

; 2114 :           REAL *h;
; 2115 : 
; 2116 :           if ( mode & CALC_FORCE )

	cmp	DWORD PTR tv3076[ebp], edx
	je	$LN651@local_conv

; 2117 :           { d = SDIM_dot(velocity,normal);

	mov	edi, DWORD PTR _velocity$[ebp]
	push	ecx
	push	ebx
	push	edi
	call	_dot

; 2118 :             for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN980@local_conv
	mov	esi, ebx
	mov	eax, edi
	sub	esi, edi
$LN103@local_conv:

; 2119 :               velocity[j] = d*normal[j];

	fld	QWORD PTR [esi+eax]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN103@local_conv

; 2118 :             for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR tv3214[ebp]
$LN980@local_conv:

; 2120 : 
; 2121 :             if ( cg_hvector ) /* conjugate gradient history vector also */

	mov	eax, DWORD PTR _cg_hvector
	fstp	ST(0)
	test	eax, eax
	je	SHORT $LN651@local_conv

; 2122 :             { h = cg_hvector[loc_ordinal(v_id)];

	test	esi, esi
	je	SHORT $LN397@local_conv
	mov	esi, DWORD PTR _v_id$[ebp]
	and	esi, 134217727				; 07ffffffH
	jmp	SHORT $LN398@local_conv
$LN397@local_conv:
	or	esi, -1
$LN398@local_conv:
	lea	esi, DWORD PTR [esi+esi*2]

; 2123 :               d = SDIM_dot(h,normal);

	push	ecx
	shl	esi, 4
	add	esi, eax
	push	ebx
	push	esi
	call	_dot

; 2124 :               for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN989@local_conv
	mov	edx, ebx
	sub	edx, esi
$LN99@local_conv:

; 2125 :                 h[j] = d*normal[j];

	fld	QWORD PTR [edx+esi]
	inc	eax
	fmul	ST(0), ST(1)
	add	esi, 8
	fstp	QWORD PTR [esi-8]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN99@local_conv
$LN989@local_conv:

; 2124 :               for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
$LN651@local_conv:

; 2126 :             }
; 2127 :           }
; 2128 :           if ( mode & CALC_VOLGRADS )

	test	BYTE PTR _mode$[ebp], 2
	je	SHORT $LN676@local_conv

; 2129 :             for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR _vgptr0$90648[ebp]
	test	edi, edi
	je	SHORT $LN676@local_conv
	npad	2
$LL95@local_conv:

; 2130 :             { d = SDIM_dot(vgptr->velocity,normal);

	mov	edx, DWORD PTR [edi+20]
	push	ecx
	push	ebx
	push	edx
	call	_dot

; 2131 :               for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN994@local_conv
	mov	eax, DWORD PTR [edi+20]
	mov	esi, ebx
	sub	esi, eax
$LN92@local_conv:

; 2132 :                  vgptr->velocity[i] = d*normal[i];

	fld	QWORD PTR [esi+eax]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN92@local_conv
$LN994@local_conv:

; 2129 :             for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR [edi+12]

; 2131 :               for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
	test	edi, edi
	jne	SHORT $LL95@local_conv
$LN676@local_conv:

; 2133 :             }
; 2134 :         } /* end normal motion */
; 2135 : 
; 2136 :         if ( (attr & CONSTRAINT) && (!check_pinning_flag || (attr & PINNED_V)) )

	mov	edx, DWORD PTR _attr$90646[ebp]
	mov	eax, edx
	and	eax, 1024				; 00000400H
	xor	esi, esi
	xor	ebx, ebx
	or	eax, esi
	je	$LN308@local_conv
	cmp	DWORD PTR _check_pinning_flag, ebx
	je	SHORT $LN689@local_conv
	and	edx, 8
	mov	eax, edx
	xor	edx, edx
	or	eax, edx
	je	$LN308@local_conv
$LN689@local_conv:

; 2137 :         { conmap_t * conmap = get_v_constraint_map(v_id);

	mov	esi, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	cmp	DWORD PTR [esi+eax+1288], ebx
	je	SHORT $LN399@local_conv
	mov	edx, DWORD PTR _v_id$[ebp]
	mov	edi, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	add	edx, DWORD PTR [esi+eax+1264]
	jmp	SHORT $LN400@local_conv
$LN399@local_conv:
	mov	edx, OFFSET _nullcon
$LN400@local_conv:

; 2138 :           int oncount = 0;
; 2139 :           struct constraint *con[MAXCONHIT];
; 2140 :           int conlist[MAXCONHIT];
; 2141 :           REAL perp[MAXCOORD];
; 2142 :           int one_sided_flag = 0;
; 2143 : 
; 2144 :           for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	esi, 1
	mov	DWORD PTR _oncount$90965[ebp], ebx
	mov	DWORD PTR _one_sided_flag$90969[ebp], ebx
	cmp	DWORD PTR [edx], esi
	jl	SHORT $LN506@local_conv
	npad	4
$LL87@local_conv:

; 2145 :           { if ( conmap[j] & CON_HIT_BIT )

	test	DWORD PTR [edx+esi*4], -2147483648	; 80000000H
	je	SHORT $LN86@local_conv

; 2146 :             { conlist[oncount] = conmap[j] & CONMASK;

	mov	eax, DWORD PTR [edx+esi*4]
	and	eax, 1073741823				; 3fffffffH
	mov	DWORD PTR _conlist$90967[ebp+ebx*4], eax

; 2147 :               con[oncount] = get_constraint(conmap[j]);

	mov	eax, DWORD PTR [edx+esi*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 2148 :               if ( con[oncount]->attr & (NONPOSITIVE|NONNEGATIVE) )

	xor	edi, edi
	mov	DWORD PTR _con$90966[ebp+ebx*4], eax
	mov	eax, DWORD PTR [eax+32]
	and	eax, 3
	or	eax, edi
	je	SHORT $LN697@local_conv

; 2149 :                 one_sided_flag = 1;

	mov	DWORD PTR _one_sided_flag$90969[ebp], 1
$LN697@local_conv:

; 2150 :               oncount++; 

	inc	ebx

; 2151 :               if ( oncount > SDIM ) break;

	cmp	ebx, ecx
	jg	SHORT $LN626@local_conv
$LN86@local_conv:

; 2138 :           int oncount = 0;
; 2139 :           struct constraint *con[MAXCONHIT];
; 2140 :           int conlist[MAXCONHIT];
; 2141 :           REAL perp[MAXCOORD];
; 2142 :           int one_sided_flag = 0;
; 2143 : 
; 2144 :           for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	inc	esi
	cmp	esi, DWORD PTR [edx]
	jle	SHORT $LL87@local_conv

; 2150 :               oncount++; 

	mov	DWORD PTR _oncount$90965[ebp], ebx
$LN506@local_conv:

; 2152 :             }
; 2153 :           }
; 2154 : 
; 2155 :           if ( oncount > SDIM ) 

	cmp	ebx, ecx
	jle	SHORT $LN679@local_conv
$LN626@local_conv:

; 2156 :           { sprintf(errmsg,
; 2157 :               "Vertex %s is on more constraints than the dimension of space.\n",
; 2158 :                       ELNAME(v_id));

	mov	eax, DWORD PTR _v_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN401@local_conv
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN402@local_conv
$LN401@local_conv:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN402@local_conv:
	push	eax
	push	OFFSET ??_C@_0DP@MEAFNNPA@Vertex?5?$CFs?5is?5on?5more?5constraints@
	push	OFFSET _errmsg
	call	_sprintf

; 2159 :             kb_error(2086,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2086					; 00000826H
	call	_kb_error

; 2160 :             oncount = SDIM;

	mov	ecx, DWORD PTR _web+616
	mov	ebx, ecx
	add	esp, 24					; 00000018H
	mov	DWORD PTR _oncount$90965[ebp], ebx
$LN679@local_conv:

; 2161 :           }
; 2162 : 
; 2163 :           if ( one_sided_flag )

	cmp	DWORD PTR _one_sided_flag$90969[ebp], 0
	je	$LN695@local_conv

; 2164 :           { REAL *raw_velocity = VREAL(v_id,raw_velocity_attr);

	mov	edx, DWORD PTR _raw_velocity_attr
	mov	eax, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	esi, DWORD PTR _v_id$[ebp]
	mov	eax, DWORD PTR [edx+eax+64]
	mov	edx, DWORD PTR _web+12
	and	esi, 134217727				; 07ffffffH
	add	eax, DWORD PTR [edx+esi*4]

; 2165 :             for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN694@local_conv
	mov	esi, DWORD PTR _velocity$[ebp]
	sub	esi, eax
	npad	7
$LL79@local_conv:

; 2166 :               raw_velocity[j] = velocity[j];

	fld	QWORD PTR [esi+eax]
	inc	edx
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR _web+616
	add	eax, 8
	cmp	edx, ecx
	jl	SHORT $LL79@local_conv
$LN694@local_conv:

; 2167 :             for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR _vgptr0$90648[ebp]
	test	edi, edi
	je	SHORT $LN695@local_conv
	npad	3
$LL76@local_conv:

; 2168 :               for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN75@local_conv
	mov	eax, DWORD PTR [edi+24]
	mov	esi, DWORD PTR [edi+20]
	sub	esi, eax
	npad	2
$LL73@local_conv:

; 2169 :                 vgptr->raw_velocity[j] = vgptr->velocity[j];

	fld	QWORD PTR [esi+eax]
	inc	edx
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR _web+616
	add	eax, 8
	cmp	edx, ecx
	jl	SHORT $LL73@local_conv
$LN75@local_conv:

; 2167 :             for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	jne	SHORT $LL76@local_conv
$LN695@local_conv:

; 2170 :           }
; 2171 : 
; 2172 :           if ( oncount )

	test	ebx, ebx
	je	$LN308@local_conv

; 2173 :           { if ( mode & CALC_FORCE )

	cmp	DWORD PTR tv3076[ebp], 0
	je	$LN654@local_conv

; 2174 :             { constr_proj(TANGPROJ,oncount,con,get_coord(v_id),
; 2175 :                                  velocity,perp,conlist,DETECT,v_id);

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	edi, DWORD PTR _velocity$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR _conlist$90967[ebp]
	push	ecx
	mov	ecx, DWORD PTR _web+12
	lea	edx, DWORD PTR _perp$90968[ebp]
	push	edx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+64]
	push	edi
	push	edx
	lea	edx, DWORD PTR _con$90966[ebp]
	push	edx
	push	ebx
	push	2
	call	_constr_proj

; 2176 :               for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 36					; 00000024H
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN66@local_conv
	lea	esi, DWORD PTR _perp$90968[ebp]
	mov	eax, edi
	sub	esi, edi
$LL68@local_conv:

; 2177 :                 velocity[j] -= perp[j];

	fld	QWORD PTR [eax]
	inc	edx
	fsub	QWORD PTR [esi+eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LL68@local_conv
$LN66@local_conv:

; 2178 : 
; 2179 :               if ( web.area_norm_flag && (web.representation==STRING) )

	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN654@local_conv
	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN654@local_conv

; 2180 :               { /* correction factor for moving vertex along constraint
; 2181 :                    is to divide projected force by sin^2 of contact angle,
; 2182 :                    here crudely estimated. */
; 2183 :                 REAL sinsq = SDIM_dot(perp,perp);

	push	ecx
	lea	eax, DWORD PTR _perp$90968[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot

; 2184 :                 if ( (sinsq != 0.0) && (sinsq < 1.0) )

	fld	ST(0)
	fldz
	add	esp, 12					; 0000000cH
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN999@local_conv
	fld1
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN999@local_conv

; 2185 :                 for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN1001@local_conv
$LN63@local_conv:

; 2186 :                   velocity[j] /= sinsq;

	fld	QWORD PTR [edi+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [edi+eax*8-8]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN63@local_conv

; 2185 :                 for ( j = 0 ; j < SDIM ; j++ )

	jmp	SHORT $LN1001@local_conv
$LN999@local_conv:
	mov	ecx, DWORD PTR _web+616
$LN1001@local_conv:

; 2184 :                 if ( (sinsq != 0.0) && (sinsq < 1.0) )

	fstp	ST(0)
$LN654@local_conv:

; 2187 :               }
; 2188 :             }
; 2189 : 
; 2190 :             if ( mode & CALC_VOLGRADS )

	test	BYTE PTR _mode$[ebp], 2
	je	$LN308@local_conv

; 2191 :               for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR _vgptr0$90648[ebp]
	test	edi, edi
	je	$LN308@local_conv
	mov	ebx, DWORD PTR _v_id$[ebp]
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
$LL655@local_conv:

; 2192 :               { REAL perp[MAXCOORD];
; 2193 :                constr_proj(TANGPROJ,oncount,con,get_coord(v_id),
; 2194 :                                vgptr->velocity,perp,NULL,NO_DETECT,v_id);

	mov	edx, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR [edi+20]
	push	edx
	mov	edx, DWORD PTR _web+12
	push	0
	push	0
	lea	eax, DWORD PTR _perp$91020[ebp]
	push	eax
	mov	eax, DWORD PTR [ebx+edx]
	mov	edx, DWORD PTR _dymem
	push	ecx
	mov	ecx, DWORD PTR _web+104
	add	eax, DWORD PTR [ecx+edx+64]
	mov	ecx, DWORD PTR _oncount$90965[ebp]
	push	eax
	lea	eax, DWORD PTR _con$90966[ebp]
	push	eax
	push	ecx
	push	2
	call	_constr_proj

; 2195 :                 for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 36					; 00000024H
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN58@local_conv
	mov	eax, DWORD PTR [edi+20]
	lea	esi, DWORD PTR _perp$91020[ebp]
	sub	esi, eax
	npad	2
$LL56@local_conv:

; 2196 :                   vgptr->velocity[j] -= perp[j];

	fld	QWORD PTR [eax]
	inc	edx
	fsub	QWORD PTR [esi+eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LL56@local_conv
$LN58@local_conv:

; 2191 :               for ( vgptr=vgptr0; vgptr ; vgptr = vgptr->chain )

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi
	jne	SHORT $LL655@local_conv
	jmp	SHORT $LN308@local_conv
$LN871@local_conv:

; 1862 :              continue;

	mov	ecx, DWORD PTR _web+616
$LN1026@local_conv:

; 1920 :             REAL ff;
; 1921 :             if ( get_vattr(v_id) & FIXED ) continue;

	fstp	ST(0)
$LN308@local_conv:

; 1842 :                  }
; 1843 :             }
; 1844 :           }
; 1845 :         }
; 1846 :       } /* end soapfilm */
; 1847 :     }  /* end Lagrange area_normalization */
; 1848 : 
; 1849 :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _v_id$[ebp]
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _v_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv3214[ebp], eax
	jne	$LL309@local_conv
	mov	edi, DWORD PTR _web+5652
	mov	ebx, DWORD PTR _dymem
$LN658@local_conv:

; 2197 :               }
; 2198 : 
; 2199 :            }
; 2200 :          }
; 2201 :      } /* end for all vertices */
; 2202 : 
; 2203 :   for ( k = 0 ; k < optparamcount ; k++ )

	cmp	DWORD PTR _optparamcount, 4
	mov	DWORD PTR _k$[ebp], 0
	jl	$LC591@local_conv
	mov	eax, DWORD PTR _optparamcount
	add	eax, -4					; fffffffcH
	shr	eax, 2
	inc	eax
	mov	DWORD PTR tv1084[ebp], eax
	add	eax, eax
	add	eax, eax
	mov	edx, OFFSET _optparam
	mov	DWORD PTR _k$[ebp], eax
	npad	7
$LL616@local_conv:

; 2204 :     optparam[k].velocity = 
; 2205 :         globals(optparam[k].pnum)->attr.varstuff.pscale*optparam[k].grad;

	mov	eax, DWORD PTR [edx]
	mov	esi, eax
	and	esi, -16777216				; ff000000H
	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN594@local_conv
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN593@local_conv
	mov	esi, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [esi]
	jmp	SHORT $LN595@local_conv
$LN593@local_conv:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN594@local_conv
	mov	esi, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	jmp	SHORT $LN595@local_conv
$LN594@local_conv:
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+ebx]
$LN595@local_conv:
	fld	QWORD PTR [edx+8]
	fmul	QWORD PTR [eax+176]
	mov	eax, DWORD PTR [edx+56]
	mov	esi, eax
	and	esi, -16777216				; ff000000H
	fstp	QWORD PTR [edx+16]
	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN600@local_conv
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN599@local_conv
	mov	esi, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [esi]
	jmp	SHORT $LN601@local_conv
$LN599@local_conv:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN600@local_conv
	mov	esi, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	jmp	SHORT $LN601@local_conv
$LN600@local_conv:
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+ebx]
$LN601@local_conv:
	fld	QWORD PTR [edx+64]
	fmul	QWORD PTR [eax+176]
	mov	eax, DWORD PTR [edx+112]
	mov	esi, eax
	and	esi, -16777216				; ff000000H
	fstp	QWORD PTR [edx+72]
	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN606@local_conv
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN605@local_conv
	mov	esi, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [esi]
	jmp	SHORT $LN607@local_conv
$LN605@local_conv:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN606@local_conv
	mov	esi, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	jmp	SHORT $LN607@local_conv
$LN606@local_conv:
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+ebx]
$LN607@local_conv:
	fld	QWORD PTR [edx+120]
	fmul	QWORD PTR [eax+176]
	mov	eax, DWORD PTR [edx+168]
	mov	esi, eax
	and	esi, -16777216				; ff000000H
	fstp	QWORD PTR [edx+128]
	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN612@local_conv
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN611@local_conv
	mov	esi, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [esi]
	jmp	SHORT $LN613@local_conv
$LN611@local_conv:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN612@local_conv
	mov	esi, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	jmp	SHORT $LN613@local_conv
$LN612@local_conv:
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+ebx]
$LN613@local_conv:
	fld	QWORD PTR [edx+176]
	add	edx, 224				; 000000e0H
	dec	DWORD PTR tv1084[ebp]
	fmul	QWORD PTR [eax+176]
	fstp	QWORD PTR [edx-40]
	jne	$LL616@local_conv
$LC591@local_conv:

; 2197 :               }
; 2198 : 
; 2199 :            }
; 2200 :          }
; 2201 :      } /* end for all vertices */
; 2202 : 
; 2203 :   for ( k = 0 ; k < optparamcount ; k++ )

	mov	edx, DWORD PTR _optparamcount
	cmp	DWORD PTR _k$[ebp], edx
	jge	$LN590@local_conv
	mov	eax, DWORD PTR _k$[ebp]
	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	sub	edx, eax
	lea	esi, DWORD PTR _optparam[esi*8]
	mov	DWORD PTR tv1670[ebp], edx
$LC53@local_conv:

; 2204 :     optparam[k].velocity = 
; 2205 :         globals(optparam[k].pnum)->attr.varstuff.pscale*optparam[k].grad;

	mov	eax, DWORD PTR [esi]
	mov	edx, eax
	and	edx, -16777216				; ff000000H
	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN403@local_conv
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN405@local_conv
	and	eax, 16777215				; 00ffffffH
	mov	edx, eax
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	mov	edx, DWORD PTR _localbase
	shl	eax, 5
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN404@local_conv
$LN405@local_conv:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN403@local_conv
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN404@local_conv
$LN403@local_conv:
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+ebx]
$LN404@local_conv:
	fld	QWORD PTR [esi+8]
	add	esi, 56					; 00000038H
	dec	DWORD PTR tv1670[ebp]
	fmul	QWORD PTR [eax+176]
	fstp	QWORD PTR [esi-40]
	jne	SHORT $LC53@local_conv
$LN590@local_conv:

; 2206 : 
; 2207 :   if ( zener_drag_flag )

	cmp	DWORD PTR _zener_drag_flag, 0
	je	$LN47@local_conv

; 2208 :   { FOR_ALL_VERTICES(v_id) 

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	$LN47@local_conv
	npad	12
$LL49@local_conv:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edi, DWORD PTR [eax+eax]
	mov	edx, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN48@local_conv

; 2209 :     { REAL *v = get_velocity(v_id);

	mov	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR [eax+ebx+1024]
	add	esi, edx

; 2210 :       REAL mag = sqrt(SDIM_dot(v,v));

	push	ecx
	push	esi
	push	esi
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 2211 :       for ( k = 0 ; k < SDIM ; k++ )

	mov	ecx, DWORD PTR _web+616
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN1006@local_conv
	fldz
	fld	QWORD PTR _zener_coeff$[ebp]
$LN44@local_conv:

; 2212 :         if ( mag > zener_coeff )

	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN41@local_conv

; 2213 :            v[k] = (mag - zener_coeff)*v[k]/mag;

	fld	ST(2)
	fsub	ST(0), ST(1)
	fmul	QWORD PTR [esi+edx*8]
	fdiv	ST(0), ST(3)
	fstp	QWORD PTR [esi+edx*8]
	jmp	SHORT $LN43@local_conv
$LN41@local_conv:

; 2214 :         else v[k] = 0.0;

	fxch	ST(1)
	fst	QWORD PTR [esi+edx*8]
	fxch	ST(1)
$LN43@local_conv:

; 2211 :       for ( k = 0 ; k < SDIM ; k++ )

	mov	ecx, DWORD PTR _web+616
	inc	edx
	cmp	edx, ecx
	jl	SHORT $LN44@local_conv
	fstp	ST(2)
	fstp	ST(1)
$LN1006@local_conv:
	mov	ebx, DWORD PTR _dymem
	fstp	ST(0)
$LN48@local_conv:

; 2208 :   { FOR_ALL_VERTICES(v_id) 

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL49@local_conv
$LN47@local_conv:

; 2215 :     }
; 2216 :   }
; 2217 : 
; 2218 :   if ( web.h_inverse_metric_flag ) apply_h_inverse_metric();

	cmp	DWORD PTR _web+812, 0
	je	SHORT $LN39@local_conv
	call	_apply_h_inverse_metric
$LN39@local_conv:

; 2219 : 
; 2220 :   /* project to parameter space for boundary points */   
; 2221 :   if ( (mode & CALC_FORCE) && web.bdrymax )

	test	BYTE PTR _mode$[ebp], 1
	je	$LN35@local_conv
	cmp	DWORD PTR _web+768, 0
	je	$LN35@local_conv

; 2222 :   { FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	test	edx, 268435456				; 10000000H
	je	$LN35@local_conv
	npad	13
$LL37@local_conv:
	mov	ecx, DWORD PTR _web+12
	mov	edi, edx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN36@local_conv

; 2223 :     {
; 2224 :      int pcount;
; 2225 :      REAL *v = get_velocity(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [edi+eax]
	mov	esi, DWORD PTR _dymem
	mov	esi, DWORD PTR [ecx+esi+1024]

; 2226 :      REAL tmp[MAXCOORD];
; 2227 :      struct boundary *bdry;
; 2228 :      int m;
; 2229 :      ATTR attr = get_vattr(v_id);

	mov	ecx, DWORD PTR [eax+8]
	add	esi, eax
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _attr$91075[ebp+4], eax

; 2230 : 
; 2231 :      if ( attr & FIXED ) continue;

	mov	eax, ecx
	and	eax, 64					; 00000040H
	xor	ebx, ebx
	or	eax, ebx
	jne	$LN36@local_conv

; 2232 :      if ( !(attr & BOUNDARY) ) continue;

	and	ecx, 128				; 00000080H
	or	ecx, eax
	je	$LN36@local_conv

; 2233 :      bdry = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN409@local_conv
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ecx, DWORD PTR _web+12
	mov	ecx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN410@local_conv
$LN409@local_conv:
	xor	eax, eax
$LN410@local_conv:

; 2234 :      pcount = bdry->pcount;
; 2235 :      b_proj(bdry,get_param(v_id),a,PARAMPROJ,v_id);

	mov	ecx, DWORD PTR _web+104
	mov	ebx, DWORD PTR [eax+40]
	push	edx
	mov	edx, DWORD PTR _a$[ebp]
	push	1
	push	edx
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+544]
	mov	edx, DWORD PTR _web+12
	add	ecx, DWORD PTR [edi+edx]
	push	ecx
	push	eax
	call	_b_proj

; 2236 :      matvec_mul(a,v,tmp,pcount,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR _a$[ebp]
	push	eax
	push	ebx
	lea	ecx, DWORD PTR _tmp$91072[ebp]
	push	ecx
	push	esi
	push	edx
	call	_matvec_mul
	add	esp, 40					; 00000028H

; 2237 :      for ( m = 0 ; m < pcount ; m++ ) v[m] = tmp[m];

	xor	ecx, ecx
	cmp	ebx, 4
	jl	SHORT $LC618@local_conv
	mov	edx, esi
	neg	edx
	mov	DWORD PTR tv7380[ebp], edx
	lea	edx, DWORD PTR _tmp$91072[ebp+edx]
	mov	DWORD PTR tv7381[ebp], edx
	mov	edx, DWORD PTR tv7380[ebp]
	lea	edx, DWORD PTR _tmp$91072[ebp+edx+8]
	lea	eax, DWORD PTR [esi+16]
	mov	DWORD PTR tv7383[ebp], edx
	npad	1
$LL619@local_conv:
	fld	QWORD PTR _tmp$91072[ebp+ecx*8]
	mov	edx, DWORD PTR tv7381[ebp]
	fstp	QWORD PTR [eax-16]
	add	ecx, 4
	fld	QWORD PTR _tmp$91072[ebp+ecx*8-24]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [edx+eax-32]
	mov	edx, DWORD PTR tv7383[ebp]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx+eax-32]
	lea	edx, DWORD PTR [ebx-3]
	fstp	QWORD PTR [eax-24]
	cmp	ecx, edx
	jl	SHORT $LL619@local_conv
$LC618@local_conv:
	cmp	ecx, ebx
	jge	SHORT $LN683@local_conv
	lea	edx, DWORD PTR _tmp$91072[ebp]
	sub	edx, esi
	mov	DWORD PTR tv7381[ebp], edx
	mov	edx, ebx
	lea	eax, DWORD PTR [esi+ecx*8]
	sub	edx, ecx
	mov	ecx, DWORD PTR tv7381[ebp]
$LC30@local_conv:
	fld	QWORD PTR [ecx+eax]
	add	eax, 8
	dec	edx
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC30@local_conv
$LN683@local_conv:

; 2238 :      for ( m = pcount ; m < SDIM ; m++ ) v[m] = 0.0;    

	cmp	ebx, DWORD PTR _web+616
	jge	SHORT $LN36@local_conv
	fldz
$LN27@local_conv:
	fst	QWORD PTR [esi+ebx*8]
	inc	ebx
	cmp	ebx, DWORD PTR _web+616
	jl	SHORT $LN27@local_conv
	fstp	ST(0)
$LN36@local_conv:

; 2222 :   { FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [edi+eax]
	mov	edx, DWORD PTR [ecx]
	test	edx, 268435456				; 10000000H
	jne	$LL37@local_conv
$LN35@local_conv:

; 2239 :    }
; 2240 :   }
; 2241 : 
; 2242 :   /* For debugging, transfer volgrads to vertex attribute,
; 2243 :      if the user has defined __volgrad and __volvelocity 
; 2244 :      vertex attributes.
; 2245 :   */
; 2246 :   vgrad_attr = find_extra("__volgrad",&eltype);

	lea	edx, DWORD PTR _eltype$[ebp]
	push	edx
	push	OFFSET ??_C@_09DDNGGDCP@__volgrad?$AA@
	call	_find_extra
	mov	esi, eax

; 2247 :   vvelocity_attr = find_extra("__volvelocity",&eltype);

	lea	eax, DWORD PTR _eltype$[ebp]
	push	eax
	push	OFFSET ??_C@_0O@CJBOIBLK@__volvelocity?$AA@
	mov	DWORD PTR _vgrad_attr$[ebp], esi
	call	_find_extra
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vvelocity_attr$[ebp], eax

; 2248 :   if ( (vgrad_attr >= 0) || (vvelocity_attr >= 0) )

	test	esi, esi
	jns	SHORT $LN23@local_conv
	test	eax, eax
	js	$LN699@local_conv
$LN23@local_conv:

; 2249 :   { /* user should expand so each vertex has volgrad for each body */
; 2250 :     struct extra *gradex = EXTRAS(VERTEX)+vgrad_attr;

	mov	eax, DWORD PTR _vgrad_attr$[ebp]
	mov	edi, DWORD PTR _web+104
	imul	eax, 240				; 000000f0H
	mov	esi, DWORD PTR _dymem
	mov	DWORD PTR tv3798[ebp], eax
	add	eax, edi

; 2251 :     int maxgradbody = gradex->array_spec.sizes[0];

	mov	ecx, DWORD PTR [eax+esi+96]
	add	eax, esi
	mov	DWORD PTR _maxgradbody$91102[ebp], ecx

; 2252 :     int maxgraddim = gradex->array_spec.sizes[1];
; 2253 :     struct extra *velex = EXTRAS(VERTEX)+vvelocity_attr;

	mov	ecx, DWORD PTR _vvelocity_attr$[ebp]
	imul	ecx, 240				; 000000f0H
	mov	DWORD PTR tv3807[ebp], ecx
	add	ecx, edi

; 2254 :     int maxvelbody = velex->array_spec.sizes[0];

	mov	edx, DWORD PTR [ecx+esi+96]
	add	ecx, esi
	mov	DWORD PTR _gradex$91100[ebp], eax
	mov	eax, DWORD PTR [eax+100]
	mov	DWORD PTR _velex$91104[ebp], ecx

; 2255 :     int maxveldim = gradex->array_spec.sizes[1];
; 2256 :     if ( maxveldim > SDIM ) maxveldim = SDIM;

	mov	ecx, DWORD PTR _web+616
	mov	ebx, eax
	mov	DWORD PTR _maxgraddim$91103[ebp], eax
	mov	DWORD PTR _maxvelbody$91106[ebp], edx
	mov	DWORD PTR _maxveldim$91107[ebp], ebx
	cmp	ebx, ecx
	jle	SHORT $LN22@local_conv
	mov	ebx, ecx
	mov	DWORD PTR _maxveldim$91107[ebp], ecx
$LN22@local_conv:

; 2257 :     if ( maxgraddim > SDIM ) maxgraddim = SDIM;

	cmp	eax, ecx
	jle	SHORT $LN21@local_conv
	mov	DWORD PTR _maxgraddim$91103[ebp], ecx
$LN21@local_conv:

; 2258 :     FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	DWORD PTR _v_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	je	$LN699@local_conv
	npad	11
$LL20@local_conv:
	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv3217[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN19@local_conv

; 2259 :     { struct volgrad *vgptr;
; 2260 :       REAL *vg = (vgrad_attr >= 0 ) ? VREAL(v_id,vgrad_attr) : NULL;

	cmp	DWORD PTR _vgrad_attr$[ebp], edx
	jl	SHORT $LN411@local_conv
	mov	edx, DWORD PTR tv3798[ebp]
	add	edx, edi
	mov	eax, DWORD PTR [edx+esi+64]
	add	eax, ecx
	jmp	SHORT $LN1025@local_conv
$LN411@local_conv:
	xor	eax, eax
$LN1025@local_conv:

; 2261 :       REAL *vv = (vvelocity_attr >= 0 ) ? VREAL(v_id,vvelocity_attr) : NULL;

	cmp	DWORD PTR _vvelocity_attr$[ebp], 0
	mov	DWORD PTR _vg$91120[ebp], eax
	jl	SHORT $LN413@local_conv
	mov	edx, DWORD PTR tv3807[ebp]
	add	edx, edi
	mov	esi, DWORD PTR [edx+esi+64]
	add	esi, ecx
	jmp	SHORT $LN414@local_conv
$LN413@local_conv:
	xor	esi, esi
$LN414@local_conv:

; 2262 :       if ( vgrad_attr >= 0 )

	cmp	DWORD PTR _vgrad_attr$[ebp], 0
	jl	SHORT $LN15@local_conv

; 2263 :          memset((char*)vg,0,maxgradbody*maxgraddim*sizeof(REAL));

	mov	ecx, DWORD PTR _maxgraddim$91103[ebp]
	imul	ecx, DWORD PTR _maxgradbody$91102[ebp]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN15@local_conv:

; 2264 :       if ( vvelocity_attr >= 0 )

	cmp	DWORD PTR _vvelocity_attr$[ebp], 0
	jl	SHORT $LN700@local_conv

; 2265 :          memset((char*)vv,0,maxvelbody*maxveldim*sizeof(REAL));

	mov	edx, ebx
	imul	edx, DWORD PTR _maxvelbody$91106[ebp]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
$LN700@local_conv:

; 2266 :       for ( vgptr=get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	eax, DWORD PTR _v_id$[ebp]
	push	eax
	call	_get_vertex_vgrad
	add	esp, 4
	test	eax, eax
	je	$LN661@local_conv
	npad	4
$LL13@local_conv:

; 2267 :       { if ( valid_id(vgptr->bb_id) ) /* just doing bodies */

	mov	edx, DWORD PTR [eax+8]
	test	edx, 268435456				; 10000000H
	je	$LN12@local_conv

; 2268 :         { int bnum = loc_ordinal(vgptr->bb_id);

	and	edx, 134217727				; 07ffffffH

; 2269 :           if ( (vgrad_attr >= 0) && (bnum < maxgradbody) )

	cmp	DWORD PTR _vgrad_attr$[ebp], 0
	jl	$LN698@local_conv
	cmp	edx, DWORD PTR _maxgradbody$91102[ebp]
	jge	$LN698@local_conv

; 2270 :           { 
; 2271 :             for ( i = 0 ; i < maxgraddim ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _maxgraddim$91103[ebp], 4
	jl	$LN701@local_conv
	npad	3
$LL670@local_conv:

; 2272 :               vg[bnum*gradex->array_spec.sizes[1]+i] = vgptr->grad[i];

	mov	ebx, DWORD PTR _gradex$91100[ebp]
	mov	ebx, DWORD PTR [ebx+100]
	mov	edi, DWORD PTR [eax+16]
	imul	ebx, edx
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR _vg$91120[ebp]
	add	ebx, ecx
	fstp	QWORD PTR [edi+ebx*8]
	mov	ebx, DWORD PTR _gradex$91100[ebp]
	mov	ebx, DWORD PTR [ebx+100]
	mov	edi, DWORD PTR [eax+16]
	imul	ebx, edx
	fld	QWORD PTR [edi+ecx*8+8]
	mov	edi, DWORD PTR _vg$91120[ebp]
	add	ebx, ecx
	fstp	QWORD PTR [edi+ebx*8+8]
	mov	ebx, DWORD PTR _gradex$91100[ebp]
	mov	ebx, DWORD PTR [ebx+100]
	mov	edi, DWORD PTR [eax+16]
	imul	ebx, edx
	fld	QWORD PTR [edi+ecx*8+16]
	mov	edi, DWORD PTR _vg$91120[ebp]
	add	ebx, ecx
	fstp	QWORD PTR [edi+ebx*8+16]
	mov	ebx, DWORD PTR _gradex$91100[ebp]
	mov	ebx, DWORD PTR [ebx+100]
	mov	edi, DWORD PTR [eax+16]
	imul	ebx, edx
	fld	QWORD PTR [edi+ecx*8+24]
	mov	edi, DWORD PTR _vg$91120[ebp]
	add	ebx, ecx
	add	ecx, 4
	fstp	QWORD PTR [edi+ebx*8+24]
	mov	edi, DWORD PTR _maxgraddim$91103[ebp]
	add	edi, -3					; fffffffdH
	cmp	ecx, edi
	jl	$LL670@local_conv
	mov	ebx, DWORD PTR _maxveldim$91107[ebp]
$LN701@local_conv:

; 2270 :           { 
; 2271 :             for ( i = 0 ; i < maxgraddim ; i++ )

	cmp	ecx, DWORD PTR _maxgraddim$91103[ebp]
	jge	SHORT $LN698@local_conv
	npad	4
$LL671@local_conv:

; 2272 :               vg[bnum*gradex->array_spec.sizes[1]+i] = vgptr->grad[i];

	mov	ebx, DWORD PTR _gradex$91100[ebp]
	mov	ebx, DWORD PTR [ebx+100]
	mov	edi, DWORD PTR [eax+16]
	imul	ebx, edx
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR _vg$91120[ebp]
	add	ebx, ecx
	inc	ecx
	fstp	QWORD PTR [edi+ebx*8]
	cmp	ecx, DWORD PTR _maxgraddim$91103[ebp]
	jl	SHORT $LL671@local_conv

; 2270 :           { 
; 2271 :             for ( i = 0 ; i < maxgraddim ; i++ )

	mov	ebx, DWORD PTR _maxveldim$91107[ebp]
$LN698@local_conv:

; 2273 :           }
; 2274 :           if ( (vvelocity_attr >= 0) && (bnum < maxvelbody) )

	cmp	DWORD PTR _vvelocity_attr$[ebp], 0
	jl	$LN12@local_conv
	cmp	edx, DWORD PTR _maxvelbody$91106[ebp]
	jge	$LN12@local_conv

; 2275 :           { 
; 2276 :             for ( i = 0 ; i < maxveldim ; i++ )

	xor	ecx, ecx
	cmp	ebx, 4
	jl	SHORT $LC624@local_conv
	npad	4
$LL672@local_conv:

; 2277 :               vv[bnum*velex->array_spec.sizes[1]+i] = vgptr->velocity[i];

	mov	ebx, DWORD PTR _velex$91104[ebp]
	mov	ebx, DWORD PTR [ebx+100]
	mov	edi, DWORD PTR [eax+20]
	imul	ebx, edx
	fld	QWORD PTR [edi+ecx*8]
	add	ebx, ecx
	fstp	QWORD PTR [esi+ebx*8]
	mov	ebx, DWORD PTR _velex$91104[ebp]
	mov	ebx, DWORD PTR [ebx+100]
	mov	edi, DWORD PTR [eax+20]
	imul	ebx, edx
	fld	QWORD PTR [edi+ecx*8+8]
	add	ebx, ecx
	fstp	QWORD PTR [esi+ebx*8+8]
	mov	ebx, DWORD PTR _velex$91104[ebp]
	mov	ebx, DWORD PTR [ebx+100]
	mov	edi, DWORD PTR [eax+20]
	imul	ebx, edx
	fld	QWORD PTR [edi+ecx*8+16]
	add	ebx, ecx
	fstp	QWORD PTR [esi+ebx*8+16]
	mov	ebx, DWORD PTR _velex$91104[ebp]
	mov	ebx, DWORD PTR [ebx+100]
	mov	edi, DWORD PTR [eax+20]
	imul	ebx, edx
	fld	QWORD PTR [edi+ecx*8+24]
	add	ebx, ecx
	add	ecx, 4
	fstp	QWORD PTR [esi+ebx*8+24]
	mov	ebx, DWORD PTR _maxveldim$91107[ebp]
	lea	edi, DWORD PTR [ebx-3]
	cmp	ecx, edi
	jl	SHORT $LL672@local_conv
$LC624@local_conv:

; 2275 :           { 
; 2276 :             for ( i = 0 ; i < maxveldim ; i++ )

	cmp	ecx, ebx
	jge	SHORT $LN12@local_conv
	npad	10
$LL673@local_conv:

; 2277 :               vv[bnum*velex->array_spec.sizes[1]+i] = vgptr->velocity[i];

	mov	ebx, DWORD PTR _velex$91104[ebp]
	mov	ebx, DWORD PTR [ebx+100]
	mov	edi, DWORD PTR [eax+20]
	imul	ebx, edx
	fld	QWORD PTR [edi+ecx*8]
	add	ebx, ecx
	inc	ecx
	fstp	QWORD PTR [esi+ebx*8]
	mov	ebx, DWORD PTR _maxveldim$91107[ebp]
	cmp	ecx, ebx
	jl	SHORT $LL673@local_conv
$LN12@local_conv:

; 2266 :       for ( vgptr=get_vertex_vgrad(v_id) ; vgptr ; vgptr = vgptr->chain )

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jne	$LL13@local_conv
$LN661@local_conv:
	mov	edi, DWORD PTR _web+104
	mov	esi, DWORD PTR _dymem
$LN19@local_conv:

; 2258 :     FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR tv3217[ebp]
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _v_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL20@local_conv
$LN699@local_conv:

; 2278 :           }
; 2279 :         }
; 2280 :       }
; 2281 :     }
; 2282 :   }
; 2283 : 
; 2284 :   if ( weights ) free_matrix(weights);

	mov	eax, DWORD PTR _weights$[ebp]
	pop	esi
	test	eax, eax
	je	SHORT $LN1@local_conv
	push	eax
	call	_free_matrix
	add	esp, 4
$LN1@local_conv:

; 2285 : } /* end convert_forms_to_vectors() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_local_convert_forms_to_vectors ENDP
_TEXT	ENDS
PUBLIC	_check_pinning
; Function compile flags: /Ogtp
;	COMDAT _check_pinning
_TEXT	SEGMENT
tv570 = -12						; size = 4
tv596 = -8						; size = 4
_tstat$91188 = -8					; size = 4
_j$ = -4						; size = 4
_check_pinning PROC					; COMDAT

; 2296 : { edge_id e_id;

	push	ebp
	mov	ebp, esp

; 2297 :   vertex_id v_id;
; 2298 :   int i,j;
; 2299 : 
; 2300 :   FOR_ALL_VERTICES(v_id) /* clear pinning flag */

	mov	eax, DWORD PTR _web+48
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	test	eax, 268435456				; 10000000H
	je	SHORT $LN66@check_pinn
	mov	esi, -9					; fffffff7H
	npad	6
$LL30@check_pinn:
	mov	edi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR [ecx+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN29@check_pinn

; 2301 :      vptr(v_id)->attr &= ~PINNED_V;

	mov	eax, DWORD PTR [ecx+edi]
	mov	edx, DWORD PTR [eax+12]
	and	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], edx
$LN29@check_pinn:

; 2297 :   vertex_id v_id;
; 2298 :   int i,j;
; 2299 : 
; 2300 :   FOR_ALL_VERTICES(v_id) /* clear pinning flag */

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL30@check_pinn
$LN66@check_pinn:

; 2302 :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+160
	test	ecx, 268435456				; 10000000H
	je	$LN67@check_pinn
	npad	2
$LL25@check_pinn:
	mov	edx, DWORD PTR _web+124
	mov	edi, ecx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv570[ebp], edi
	je	$LN24@check_pinn

; 2303 :   { 
; 2304 :     vertex_id headv = get_edge_headv(e_id);

	mov	eax, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	je	SHORT $LN40@check_pinn
	mov	eax, DWORD PTR [eax+edi+304]
	mov	esi, DWORD PTR [eax+edx]
	add	eax, edx
	jmp	SHORT $LN39@check_pinn
$LN40@check_pinn:
	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+esi+304]
	add	eax, edx
	mov	edx, DWORD PTR _web+636
	mov	esi, DWORD PTR [eax+edx*4]
$LN39@check_pinn:

; 2305 :     vertex_id tailv = get_edge_tailv(e_id);

	test	ecx, ecx
	je	SHORT $LN44@check_pinn
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN43@check_pinn
$LN44@check_pinn:
	mov	eax, DWORD PTR [eax]
$LN43@check_pinn:

; 2306 :     conmap_t * hstat = get_v_constraint_map(headv);

	mov	ecx, DWORD PTR _web+104
	mov	ebx, DWORD PTR [ecx+edi+1288]
	test	ebx, ebx
	je	SHORT $LN33@check_pinn
	mov	ebx, DWORD PTR _web+12
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	add	edx, DWORD PTR [ecx+edi+1264]
	mov	ebx, DWORD PTR [ecx+edi+1288]
	jmp	SHORT $LN34@check_pinn
$LN33@check_pinn:
	mov	edx, OFFSET _nullcon
$LN34@check_pinn:

; 2307 :     conmap_t * tstat = get_v_constraint_map(tailv);

	test	ebx, ebx
	je	SHORT $LN35@check_pinn
	mov	ebx, DWORD PTR _web+12
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR _web+104
	add	ebx, DWORD PTR [ecx+edi+1264]
	jmp	SHORT $LN73@check_pinn
$LN35@check_pinn:
	mov	ebx, OFFSET _nullcon
$LN73@check_pinn:
	mov	edi, DWORD PTR [edx]

; 2308 :     for ( i=1, j=0 ;  i <= (int)hstat[0] ; i++ ) 

	mov	ecx, 1
	mov	DWORD PTR _tstat$91188[ebp], ebx
	mov	DWORD PTR _j$[ebp], 0
	cmp	edi, ecx
	jl	SHORT $LN68@check_pinn
$LL20@check_pinn:

; 2309 :        if (hstat[i] & CON_HIT_BIT) j++;

	test	DWORD PTR [edx+ecx*4], -2147483648	; 80000000H
	je	SHORT $LN19@check_pinn
	inc	DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR _tstat$91188[ebp]
$LN19@check_pinn:

; 2308 :     for ( i=1, j=0 ;  i <= (int)hstat[0] ; i++ ) 

	inc	ecx
	cmp	ecx, edi
	jle	SHORT $LL20@check_pinn

; 2310 :     if ( j == 1 )

	cmp	DWORD PTR _j$[ebp], 1
	jne	SHORT $LN68@check_pinn

; 2311 :        set_attr(tailv,PINNED_V);

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax+12], edx
$LN68@check_pinn:

; 2312 :     for ( i=1, j=0 ;  i <= (int)tstat[0] ; i++ ) 

	mov	ecx, DWORD PTR [ebx]
	mov	eax, 1
	xor	edx, edx
	cmp	ecx, eax
	jl	SHORT $LN71@check_pinn
	npad	2
$LL15@check_pinn:

; 2313 :        if (tstat[i] & CON_HIT_BIT) j++;

	test	DWORD PTR [ebx+eax*4], -2147483648	; 80000000H
	je	SHORT $LN14@check_pinn
	inc	edx
$LN14@check_pinn:

; 2312 :     for ( i=1, j=0 ;  i <= (int)tstat[0] ; i++ ) 

	inc	eax
	cmp	eax, ecx
	jle	SHORT $LL15@check_pinn

; 2314 :     if ( j == 1 )

	cmp	edx, 1
	jne	SHORT $LN71@check_pinn

; 2315 :        set_attr(headv,PINNED_V);

	mov	eax, esi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax+12], edx
$LN71@check_pinn:
	mov	edi, DWORD PTR tv570[ebp]
$LN24@check_pinn:

; 2302 :   FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, 268435456				; 10000000H
	jne	$LL25@check_pinn
$LN67@check_pinn:

; 2316 :   }
; 2317 :   FOR_ALL_VERTICES(v_id) /* see if 2 con vertex has 2 con nbrs */

	mov	edx, DWORD PTR _web+48
	test	edx, 268435456				; 10000000H
	je	$LN8@check_pinn
	mov	eax, DWORD PTR _web+12
$LL10@check_pinn:
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN9@check_pinn

; 2318 :     { conmap_t * hit = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR _dymem
	cmp	DWORD PTR [eax+esi+1288], 0
	je	SHORT $LN37@check_pinn
	mov	esi, DWORD PTR [eax+esi+1264]
	add	esi, edi
	jmp	SHORT $LN38@check_pinn
$LN37@check_pinn:
	mov	esi, OFFSET _nullcon
$LN38@check_pinn:
	mov	edi, DWORD PTR [esi]

; 2319 :       for ( i = 1, j = 0 ; i <= (int)hit[0] ; i++ ) 

	mov	eax, 1
	xor	ebx, ebx
	cmp	edi, eax
	jl	SHORT $LN65@check_pinn
$LL5@check_pinn:

; 2320 :          if ( hit[i] & CON_HIT_BIT ) j++;

	test	DWORD PTR [esi+eax*4], -2147483648	; 80000000H
	je	SHORT $LN4@check_pinn
	inc	ebx
$LN4@check_pinn:

; 2319 :       for ( i = 1, j = 0 ; i <= (int)hit[0] ; i++ ) 

	inc	eax
	cmp	eax, edi
	jle	SHORT $LL5@check_pinn

; 2321 :       if ( j != 2 )

	cmp	ebx, 2
	je	SHORT $LN9@check_pinn
$LN65@check_pinn:

; 2322 :          set_attr(v_id,PINNED_V);

	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	eax, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax+12], edx
$LN9@check_pinn:

; 2316 :   }
; 2317 :   FOR_ALL_VERTICES(v_id) /* see if 2 con vertex has 2 con nbrs */

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx]
	test	edx, 268435456				; 10000000H
	jne	$LL10@check_pinn
$LN8@check_pinn:
	pop	edi
	pop	esi
	pop	ebx

; 2323 :     }
; 2324 : } /* end check_pinning() */

	mov	esp, ebp
	pop	ebp
	ret	0
_check_pinning ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DJ@GCMOMCKE@fix_vertices?$CI?$CJ?3?5project?5forces?5t@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_fix_vertices
EXTRN	_itdebug:DWORD
;	COMDAT ??_C@_0DJ@GCMOMCKE@fix_vertices?$CI?$CJ?3?5project?5forces?5t@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DJ@GCMOMCKE@fix_vertices?$CI?$CJ?3?5project?5forces?5t@ DB 'fix_ve'
	DB	'rtices(): project forces to level-set constraints', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\iterate.c
CONST	ENDS
;	COMDAT _fix_vertices
_TEXT	SEGMENT
_con$89317 = -144					; size = 28
_attr$89259 = -116					; size = 8
_x$89272 = -108						; size = 4
_force$ = -104						; size = 4
tv918 = -100						; size = 4
_i$ = -100						; size = 4
tv1342 = -96						; size = 4
tv892 = -96						; size = 4
tv869 = -92						; size = 4
tv867 = -88						; size = 4
_tstat$89202 = -88					; size = 4
_j$ = -84						; size = 4
_v_id$ = -84						; size = 4
_conlist$89318 = -80					; size = 28
_perp$89319 = -52					; size = 48
_new_force$89271 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_fix_vertices PROC					; COMDAT

; 387  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 388  :   vertex_id v_id;
; 389  :   REAL *force;
; 390  :   int i,j;
; 391  : 
; 392  :   if ( itdebug )

	cmp	DWORD PTR _itdebug, 0
	je	SHORT $LN75@fix_vertic

; 393  :     outstring("fix_vertices(): project forces to level-set constraints\n");

	push	OFFSET ??_C@_0DJ@GCMOMCKE@fix_vertices?$CI?$CJ?3?5project?5forces?5t@
	call	_outstring
	add	esp, 4
$LN75@fix_vertic:

; 394  : 
; 395  :   if ( check_pinning_flag )

	cmp	DWORD PTR _check_pinning_flag, 0
	push	ebx
	push	esi
	push	edi
	je	$LN137@fix_vertic

; 396  :   { edge_id e_id;
; 397  :     /* check for vertices that can't move because adjacent
; 398  :        vertices are not on same constraint when they could be */
; 399  :     FOR_ALL_VERTICES(v_id) /* clear pinning flag */

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	SHORT $LN135@fix_vertic
	mov	esi, DWORD PTR _web+12
	mov	edi, -9					; fffffff7H
$LL73@fix_vertic:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN72@fix_vertic

; 400  :       vptr(v_id)->attr &= ~PINNED_V;

	mov	eax, DWORD PTR [ecx+esi]
	mov	edx, DWORD PTR [eax+12]
	and	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edx
	mov	esi, DWORD PTR _web+12
$LN72@fix_vertic:

; 396  :   { edge_id e_id;
; 397  :     /* check for vertices that can't move because adjacent
; 398  :        vertices are not on same constraint when they could be */
; 399  :     FOR_ALL_VERTICES(v_id) /* clear pinning flag */

	mov	eax, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL73@fix_vertic
$LN135@fix_vertic:

; 401  :     FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	test	edx, 268435456				; 10000000H
	je	$LN136@fix_vertic
	mov	ecx, DWORD PTR _web+124
	npad	1
$LL149@fix_vertic:
	mov	ebx, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv892[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN67@fix_vertic

; 402  :     { 
; 403  :       vertex_id headv = get_edge_headv(e_id);

	mov	eax, DWORD PTR [ebx+edi+304]
	shr	edx, 27					; 0000001bH
	add	eax, ecx
	and	edx, 1
	je	SHORT $LN91@fix_vertic
	mov	esi, DWORD PTR [eax]
	jmp	SHORT $LN90@fix_vertic
$LN91@fix_vertic:
	mov	ecx, DWORD PTR _web+636
	mov	esi, DWORD PTR [eax+ecx*4]
$LN90@fix_vertic:

; 404  :       vertex_id tailv = get_edge_tailv(e_id);

	test	edx, edx
	je	SHORT $LN95@fix_vertic
	mov	edx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN94@fix_vertic
$LN95@fix_vertic:
	mov	eax, DWORD PTR [eax]
$LN94@fix_vertic:

; 405  :       conmap_t * hstat = get_v_constraint_map(headv);

	mov	ecx, DWORD PTR _web+104
	mov	ebx, DWORD PTR [ecx+edi+1288]
	test	ebx, ebx
	je	SHORT $LN78@fix_vertic
	mov	ebx, DWORD PTR _web+12
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	add	edx, DWORD PTR [ecx+edi+1264]
	mov	ebx, DWORD PTR [ecx+edi+1288]
	jmp	SHORT $LN79@fix_vertic
$LN78@fix_vertic:
	mov	edx, OFFSET _nullcon
$LN79@fix_vertic:

; 406  :       conmap_t * tstat = get_v_constraint_map(tailv);

	test	ebx, ebx
	je	SHORT $LN80@fix_vertic
	mov	ebx, DWORD PTR _web+12
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR _web+104
	add	ebx, DWORD PTR [ecx+edi+1264]
	jmp	SHORT $LN172@fix_vertic
$LN80@fix_vertic:
	mov	ebx, OFFSET _nullcon
$LN172@fix_vertic:
	mov	edi, DWORD PTR [edx]

; 407  :       for ( i=1, j=0 ;  i <= (int)hstat[0] ; i++ ) 

	mov	ecx, 1
	mov	DWORD PTR _tstat$89202[ebp], ebx
	mov	DWORD PTR _j$[ebp], 0
	cmp	edi, ecx
	jl	SHORT $LN150@fix_vertic
$LL63@fix_vertic:

; 408  :          if (hstat[i] & CON_HIT_BIT) j++;

	test	DWORD PTR [edx+ecx*4], -2147483648	; 80000000H
	je	SHORT $LN62@fix_vertic
	inc	DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR _tstat$89202[ebp]
$LN62@fix_vertic:

; 407  :       for ( i=1, j=0 ;  i <= (int)hstat[0] ; i++ ) 

	inc	ecx
	cmp	ecx, edi
	jle	SHORT $LL63@fix_vertic

; 409  :       if ( j == 1 )

	cmp	DWORD PTR _j$[ebp], 1
	jne	SHORT $LN150@fix_vertic

; 410  :              set_attr(tailv,PINNED_V);

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax+12], edx
$LN150@fix_vertic:

; 411  :       for ( i=1, j=0 ;  i <= (int)tstat[0] ; i++ ) 

	mov	ecx, DWORD PTR [ebx]
	mov	eax, 1
	xor	edx, edx
	cmp	ecx, eax
	jl	SHORT $LN67@fix_vertic
	npad	8
$LL58@fix_vertic:

; 412  :          if (tstat[i] & CON_HIT_BIT) j++;

	test	DWORD PTR [ebx+eax*4], -2147483648	; 80000000H
	je	SHORT $LN57@fix_vertic
	inc	edx
$LN57@fix_vertic:

; 411  :       for ( i=1, j=0 ;  i <= (int)tstat[0] ; i++ ) 

	inc	eax
	cmp	eax, ecx
	jle	SHORT $LL58@fix_vertic

; 413  :       if ( j == 1 )

	cmp	edx, 1
	jne	SHORT $LN67@fix_vertic

; 414  :          set_attr(headv,PINNED_V);

	mov	eax, esi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax+12], edx
$LN67@fix_vertic:

; 401  :     FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR tv892[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [edx]
	test	edx, 268435456				; 10000000H
	jne	$LL149@fix_vertic
$LN136@fix_vertic:

; 415  :     }
; 416  :     FOR_ALL_VERTICES(v_id) /* see if 2 con vertex has 2 con nbrs */

	mov	edx, DWORD PTR _web+48
	test	edx, 268435456				; 10000000H
	je	$LN137@fix_vertic
	mov	eax, DWORD PTR _web+12
	npad	10
$LL151@fix_vertic:
	mov	ebx, DWORD PTR _web+104
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN52@fix_vertic

; 417  :     { conmap_t * hit = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _dymem
	cmp	DWORD PTR [ebx+eax+1288], esi
	je	SHORT $LN82@fix_vertic
	mov	esi, DWORD PTR [ebx+eax+1264]
	add	esi, edi
	jmp	SHORT $LN83@fix_vertic
$LN82@fix_vertic:
	mov	esi, OFFSET _nullcon
$LN83@fix_vertic:
	mov	edi, DWORD PTR [esi]

; 418  :       for ( i = 1, j = 0 ; i <= (int)hit[0] ; i++ ) 

	mov	eax, 1
	xor	ebx, ebx
	cmp	edi, eax
	jl	SHORT $LN134@fix_vertic
	npad	4
$LL48@fix_vertic:

; 419  :         if ( hit[i] & CON_HIT_BIT ) j++;

	test	DWORD PTR [esi+eax*4], -2147483648	; 80000000H
	je	SHORT $LN47@fix_vertic
	inc	ebx
$LN47@fix_vertic:

; 418  :       for ( i = 1, j = 0 ; i <= (int)hit[0] ; i++ ) 

	inc	eax
	cmp	eax, edi
	jle	SHORT $LL48@fix_vertic

; 420  :       if ( j != 2 )

	cmp	ebx, 2
	je	SHORT $LN52@fix_vertic
$LN134@fix_vertic:

; 421  :          set_attr(v_id,PINNED_V);

	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _web[edx+12]
	mov	eax, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax+12], edx
$LN52@fix_vertic:

; 415  :     }
; 416  :     FOR_ALL_VERTICES(v_id) /* see if 2 con vertex has 2 con nbrs */

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx]
	test	edx, 268435456				; 10000000H
	jne	$LL151@fix_vertic
$LN137@fix_vertic:

; 424  : 
; 425  : 
; 426  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	DWORD PTR _v_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv867[ebp], eax
	je	$LN41@fix_vertic
	mov	eax, DWORD PTR _web+616
	mov	ebx, DWORD PTR _v_id$[ebp]
$LL143@fix_vertic:
	mov	edx, DWORD PTR _web+12
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv869[ebp], ecx
	mov	ecx, DWORD PTR [edi+8]
	and	ecx, 1
	xor	edx, edx
	or	ecx, edx
	je	$LN42@fix_vertic

; 427  :   {
; 428  :     ATTR attr = get_vattr(v_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR tv869[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [edx+8]

; 429  : 
; 430  :     force = get_force(v_id);

	mov	esi, DWORD PTR _dymem
	mov	DWORD PTR _attr$89259[ebp], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _attr$89259[ebp+4], ecx
	mov	ecx, DWORD PTR _web+104
	mov	esi, DWORD PTR [ecx+esi+784]

; 431  :     if ( attr & FIXED )

	mov	ecx, DWORD PTR _attr$89259[ebp]
	add	esi, edx
	and	ecx, 64					; 00000040H
	xor	edx, edx
	or	ecx, edx
	mov	DWORD PTR _force$[ebp], esi
	je	SHORT $LN38@fix_vertic

; 432  :     { memset((char*)force,0,SDIM*sizeof(REAL));

	lea	edx, DWORD PTR [eax*8]
	push	edx
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 433  :       continue;

	jmp	$LN141@fix_vertic
$LN38@fix_vertic:

; 434  :     }
; 435  :         
; 436  :     if ( mobility_flag )

	cmp	DWORD PTR _mobility_flag, edx
	je	$LN138@fix_vertic

; 437  :     { if ( mobility_tensor_flag )

	cmp	DWORD PTR _mobility_tensor_flag, edx
	je	$LN36@fix_vertic

; 438  :       { REAL new_force[MAXCOORD];
; 439  :         REAL *x = get_coord(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+64]
	add	ecx, edi
	mov	DWORD PTR _x$89272[ebp], ecx

; 440  :         for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	eax, eax
	jle	SHORT $LN33@fix_vertic

; 422  :     }
; 423  :   }

	mov	DWORD PTR tv1342[ebp], OFFSET _mobility_tensor
	lea	edi, DWORD PTR _new_force$89271[ebp]
	npad	4
$LL144@fix_vertic:

; 441  :           for ( j = 0, new_force[i] = 0.0 ; j < SDIM ; j++ ) 

	fldz
	xor	esi, esi
	fstp	QWORD PTR [edi]
	test	eax, eax
	jle	SHORT $LN34@fix_vertic
	mov	ebx, DWORD PTR tv1342[ebp]
	npad	3
$LL32@fix_vertic:

; 442  :             new_force[i] += force[j]*eval(&mobility_tensor[i][j],x,v_id,NULL);

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR _x$89272[ebp]
	push	0
	push	eax
	push	ecx
	push	ebx
	call	_eval
	mov	edx, DWORD PTR _force$[ebp]
	fmul	QWORD PTR [edx+esi*8]
	mov	eax, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	fadd	QWORD PTR [edi]
	add	ebx, 104				; 00000068H
	fstp	QWORD PTR [edi]
	cmp	esi, eax
	jl	SHORT $LL32@fix_vertic
$LN34@fix_vertic:

; 440  :         for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	add	DWORD PTR tv1342[ebp], 624		; 00000270H
	inc	ecx
	add	edi, 8
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, eax
	jl	SHORT $LL144@fix_vertic
$LN33@fix_vertic:

; 443  :         for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN138@fix_vertic
	mov	ecx, DWORD PTR _force$[ebp]
	lea	esi, DWORD PTR _new_force$89271[ebp]
	sub	esi, ecx
	npad	3
$LL29@fix_vertic:

; 444  :           force[j] = new_force[j];

	fld	QWORD PTR [esi+ecx]
	inc	edx
	fstp	QWORD PTR [ecx]
	mov	eax, DWORD PTR _web+616
	add	ecx, 8
	cmp	edx, eax
	jl	SHORT $LL29@fix_vertic

; 445  :       }
; 446  :       else

	jmp	SHORT $LN138@fix_vertic
$LN36@fix_vertic:

; 447  :       { REAL mobility = eval(&mobility_formula,get_coord(v_id),v_id,NULL);

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [eax+ecx+64]
	push	0
	push	ebx
	add	edx, edi
	push	edx
	push	OFFSET _mobility_formula
	call	_eval

; 448  :         for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN155@fix_vertic
$LN25@fix_vertic:

; 449  :         force[j] *= mobility;

	fld	QWORD PTR [esi+ecx*8]
	inc	ecx
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi+ecx*8-8]
	mov	eax, DWORD PTR _web+616
	cmp	ecx, eax
	jl	SHORT $LN25@fix_vertic
$LN155@fix_vertic:

; 448  :         for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
$LN138@fix_vertic:

; 450  :       }
; 451  :     }
; 452  : 
; 453  :     if ( normal_motion_flag )

	cmp	DWORD PTR _normal_motion_flag, 0
	je	SHORT $LN145@fix_vertic

; 454  :     { /* project to normal */
; 455  :       REAL d;
; 456  :       int vnum = loc_ordinal(v_id);

	cmp	DWORD PTR tv867[ebp], 0
	je	SHORT $LN84@fix_vertic
	mov	esi, DWORD PTR tv869[ebp]
	jmp	SHORT $LN85@fix_vertic
$LN84@fix_vertic:
	or	esi, -1
$LN85@fix_vertic:

; 457  :       REAL *normal = vertex_normals[vnum];
; 458  : 
; 459  :       d = SDIM_dot(force,normal);

	mov	edi, DWORD PTR _force$[ebp]
	lea	esi, DWORD PTR [esi+esi*2]
	shl	esi, 4
	add	esi, DWORD PTR _vertex_normals
	push	eax
	push	esi
	push	edi
	call	_dot

; 460  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN157@fix_vertic
	mov	ecx, edi
	sub	esi, edi
$LN21@fix_vertic:

; 461  :          force[j] = d*normal[j];

	fld	QWORD PTR [esi+ecx]
	inc	edx
	fmul	ST(0), ST(1)
	add	ecx, 8
	fstp	QWORD PTR [ecx-8]
	mov	eax, DWORD PTR _web+616
	cmp	edx, eax
	jl	SHORT $LN21@fix_vertic
$LN157@fix_vertic:

; 460  :       for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
	jmp	SHORT $LN19@fix_vertic
$LN145@fix_vertic:
	mov	edi, DWORD PTR _force$[ebp]
$LN19@fix_vertic:

; 462  :     }
; 463  : 
; 464  :     if ( (attr & CONSTRAINT) && (!check_pinning_flag || (attr & PINNED_V)) )

	mov	edx, DWORD PTR _attr$89259[ebp]
	mov	ecx, edx
	and	ecx, 1024				; 00000400H
	xor	esi, esi
	or	ecx, esi
	je	$LN42@fix_vertic
	cmp	DWORD PTR _check_pinning_flag, esi
	je	SHORT $LN17@fix_vertic
	and	edx, 8
	mov	ecx, edx
	xor	edx, edx
	or	ecx, edx
	je	$LN42@fix_vertic
$LN17@fix_vertic:

; 465  :     {
; 466  :       conmap_t * conmap = get_v_constraint_map(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	esi, DWORD PTR _dymem
	cmp	DWORD PTR [ecx+esi+1288], 0
	je	SHORT $LN86@fix_vertic
	mov	edx, DWORD PTR _web+12
	mov	ebx, DWORD PTR tv869[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	add	edx, DWORD PTR [ecx+esi+1264]
	jmp	SHORT $LN87@fix_vertic
$LN86@fix_vertic:
	mov	edx, OFFSET _nullcon
$LN87@fix_vertic:

; 467  :       int oncount = 0;
; 468  :       struct constraint *con[MAXCONHIT];
; 469  :       int conlist[MAXCONHIT];
; 470  :       REAL perp[MAXCOORD];
; 471  : 
; 472  :       for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	esi, 1
	xor	ecx, ecx
	cmp	DWORD PTR [edx], esi
	jl	SHORT $LN14@fix_vertic
	npad	7
$LL16@fix_vertic:

; 473  :       { 
; 474  :         if ( conmap[j] & CON_HIT_BIT )

	test	DWORD PTR [edx+esi*4], -2147483648	; 80000000H
	je	SHORT $LN15@fix_vertic

; 475  :         { if ( oncount >= web.sdim ) { oncount++; continue; }

	cmp	ecx, eax
	jge	SHORT $LN173@fix_vertic

; 476  :           conlist[oncount] = conmap[j] & CONMASK;

	mov	ebx, DWORD PTR [edx+esi*4]
	and	ebx, 1073741823				; 3fffffffH
	mov	DWORD PTR _conlist$89318[ebp+ecx*4], ebx

; 477  :           con[oncount] = get_constraint(conmap[j]);

	mov	ebx, DWORD PTR [edx+esi*4]
	and	ebx, 1073741823				; 3fffffffH
	imul	ebx, 176				; 000000b0H
	add	ebx, DWORD PTR _web+652
	mov	DWORD PTR _con$89317[ebp+ecx*4], ebx
$LN173@fix_vertic:

; 478  : /*          if ( !(con[oncount]->attr & (NONNEGATIVE|NONPOSITIVE) ) ) */
; 479  :             oncount++;  

	inc	ecx
$LN15@fix_vertic:

; 467  :       int oncount = 0;
; 468  :       struct constraint *con[MAXCONHIT];
; 469  :       int conlist[MAXCONHIT];
; 470  :       REAL perp[MAXCOORD];
; 471  : 
; 472  :       for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	inc	esi
	cmp	esi, DWORD PTR [edx]
	jle	SHORT $LL16@fix_vertic
$LN14@fix_vertic:

; 480  :         }
; 481  :       }
; 482  : 
; 483  :       if ( oncount > SDIM ) 

	cmp	ecx, eax
	jle	SHORT $LN146@fix_vertic

; 484  :       { sprintf(errmsg,
; 485  :         "Vertex %s is on more constraints than the dimension of space.\n",
; 486  :            ELNAME(v_id));

	cmp	DWORD PTR tv867[ebp], 0
	je	SHORT $LN88@fix_vertic
	mov	eax, DWORD PTR tv869[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN89@fix_vertic
$LN88@fix_vertic:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN89@fix_vertic:
	push	eax
	push	OFFSET ??_C@_0DP@MEAFNNPA@Vertex?5?$CFs?5is?5on?5more?5constraints@
	push	OFFSET _errmsg
	call	_sprintf

; 487  :         kb_error(2084,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2084					; 00000824H
	call	_kb_error

; 488  :         oncount = SDIM;

	mov	eax, DWORD PTR _web+616
	add	esp, 24					; 00000018H
	mov	ecx, eax
$LN146@fix_vertic:

; 489  :       }
; 490  :       if ( oncount )

	test	ecx, ecx
	je	$LN42@fix_vertic

; 491  :       { constr_proj(TANGPROJ,oncount,con,get_coord(v_id),
; 492  :                                force,perp,conlist,DETECT,v_id);

	mov	edx, DWORD PTR _v_id$[ebp]
	mov	esi, DWORD PTR _dymem
	push	edx
	push	1
	lea	eax, DWORD PTR _conlist$89318[ebp]
	push	eax
	mov	eax, DWORD PTR _web+12
	lea	edx, DWORD PTR _perp$89319[ebp]
	push	edx
	mov	edx, DWORD PTR tv869[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+104
	add	eax, DWORD PTR [edx+esi+64]
	push	edi
	push	eax
	lea	eax, DWORD PTR _con$89317[ebp]
	push	eax
	push	ecx
	push	2
	call	_constr_proj

; 493  :         for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 36					; 00000024H
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN7@fix_vertic
	lea	esi, DWORD PTR _perp$89319[ebp]
	mov	ecx, edi
	sub	esi, edi
	npad	5
$LL9@fix_vertic:

; 494  :           force[j] -= perp[j];

	fld	QWORD PTR [ecx]
	inc	edx
	fsub	QWORD PTR [esi+ecx]
	add	ecx, 8
	fstp	QWORD PTR [ecx-8]
	mov	eax, DWORD PTR _web+616
	cmp	edx, eax
	jl	SHORT $LL9@fix_vertic
$LN7@fix_vertic:

; 495  :         if ( web.area_norm_flag && (web.representation==STRING) )

	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN42@fix_vertic
	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN42@fix_vertic

; 496  :         { /* correction factor for moving vertex along constraint
; 497  :              is to divide projected force by sin^2 of contact angle,
; 498  :              here crudely estimated. */
; 499  :           REAL sinsq = SDIM_dot(perp,perp);

	push	eax
	lea	ecx, DWORD PTR _perp$89319[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot

; 500  :           if ( (sinsq != 0.0) && (sinsq < 1.0) )

	fld	ST(0)
	fldz
	add	esp, 12					; 0000000cH
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN166@fix_vertic
	fld1
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN166@fix_vertic

; 501  :             for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN168@fix_vertic
$LN4@fix_vertic:

; 502  :               force[j] /= sinsq;

	fld	QWORD PTR [edi+ecx*8]
	inc	ecx
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [edi+ecx*8-8]
	mov	eax, DWORD PTR _web+616
	cmp	ecx, eax
	jl	SHORT $LN4@fix_vertic
$LN168@fix_vertic:

; 501  :             for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
	jmp	SHORT $LN42@fix_vertic
$LN166@fix_vertic:

; 500  :           if ( (sinsq != 0.0) && (sinsq < 1.0) )

	fstp	ST(0)
$LN141@fix_vertic:

; 433  :       continue;

	mov	eax, DWORD PTR _web+616
$LN42@fix_vertic:

; 424  : 
; 425  : 
; 426  :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR tv869[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	ebx, DWORD PTR [ecx]
	mov	ecx, ebx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _v_id$[ebp], ebx
	mov	DWORD PTR tv867[ebp], ecx
	jne	$LL143@fix_vertic
$LN41@fix_vertic:

; 503  :         }
; 504  :       }
; 505  :     }
; 506  :   }
; 507  :   if ( web.h_inverse_metric_flag ) apply_h_inverse_metric();

	cmp	DWORD PTR _web+812, 0
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN1@fix_vertic
	call	_apply_h_inverse_metric
$LN1@fix_vertic:

; 508  : } /* end fix_vertices() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fix_vertices ENDP
_TEXT	ENDS
PUBLIC	_save_coords
; Function compile flags: /Ogtp
;	COMDAT _save_coords
_TEXT	SEGMENT
_saver$ = 8						; size = 4
_mode$ = 12						; size = 4
_save_coords PROC					; COMDAT

; 795  : {

	push	ebp
	mov	ebp, esp

; 801  :   #endif
; 802  :   
; 803  : } // end save_coords()

	pop	ebp

; 796  :   #ifdef MPI_EVOLVER
; 797  :   if ( this_task != 0 ) return;
; 798  :   mpi_save_coords(mode);
; 799  :   #else
; 800  :   local_save_coords(saver,mode);

	jmp	_local_save_coords
_save_coords ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EI@NOJNALMO@Internal?5error?3?5Cannot?5restore?5o@ ; `string'
PUBLIC	_local_restore_coords
EXTRN	_global_timestamp:DWORD
EXTRN	_set_body_volume:PROC
;	COMDAT ??_C@_0EI@NOJNALMO@Internal?5error?3?5Cannot?5restore?5o@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EI@NOJNALMO@Internal?5error?3?5Cannot?5restore?5o@ DB 'Internal er'
	DB	'ror: Cannot restore old coordinates since there aren''t any!', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\iterate.c
CONST	ENDS
;	COMDAT _local_restore_coords
_TEXT	SEGMENT
_saver$ = 8						; size = 4
_mode$ = 12						; size = 4
_local_restore_coords PROC				; COMDAT

; 913  : {

	push	ebp
	mov	ebp, esp

; 914  :   vertex_id v_id;
; 915  :   body_id b_id;
; 916  :   int n;
; 917  : 
; 918  :   if ( mode == SAVE_SEPARATE )

	cmp	DWORD PTR _mode$[ebp], 2
	jne	SHORT $LN59@local_rest

; 919  :   { if ( saver->coord == NULL )

	mov	eax, DWORD PTR _saver$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN59@local_rest

; 920  :      kb_error(1056,
; 921  :     "Internal error: Cannot restore old coordinates since there aren't any!\n",
; 922  :                         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EI@NOJNALMO@Internal?5error?3?5Cannot?5restore?5o@
	push	1056					; 00000420H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN59@local_rest:

; 923  :   }
; 924  : 
; 925  :   /* restore optimizing parameters */
; 926  :   for ( n = 0 ; n < optparamcount ; n++ )

	push	ebx
	xor	ebx, ebx
	push	esi
	push	edi
	cmp	DWORD PTR _optparamcount, ebx
	jle	$LN63@local_rest
	mov	edi, DWORD PTR _saver$[ebp]
	mov	esi, OFFSET _optparam
	add	edi, 32					; 00000020H
$LL20@local_rest:

; 927  :   {  struct global *g = globals(optparam[n].pnum);

	mov	eax, DWORD PTR [esi]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN25@local_rest
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN27@local_rest
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN26@local_rest
$LN27@local_rest:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN25@local_rest
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN26@local_rest
$LN25@local_rest:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN26@local_rest:

; 928  :      g->value.real = saver->optparam_values[n];

	fld	QWORD PTR [edi]
	fstp	QWORD PTR [eax+64]

; 929  :      if ( g->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [eax+188]
	test	eax, eax
	je	SHORT $LN19@local_rest

; 930  :      { struct  global *gg = globals(g->attr.varstuff.on_assign_call);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN31@local_rest
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN33@local_rest
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN32@local_rest
$LN33@local_rest:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN31@local_rest
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN32@local_rest
$LN31@local_rest:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN32@local_rest:

; 931  :        eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	add	esp, 16					; 00000010H
$LN19@local_rest:

; 923  :   }
; 924  : 
; 925  :   /* restore optimizing parameters */
; 926  :   for ( n = 0 ; n < optparamcount ; n++ )

	inc	ebx
	add	edi, 8
	add	esi, 56					; 00000038H
	cmp	ebx, DWORD PTR _optparamcount
	jl	$LL20@local_rest
$LN63@local_rest:

; 932  :      }
; 933  :   }
; 934  : 
; 935  :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+48
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN61@local_rest
	mov	edi, DWORD PTR _web+12
$LL16@local_rest:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN15@local_rest

; 936  :      restore_vertex(v_id,saver,mode);

	mov	edx, DWORD PTR _mode$[ebp]
	mov	eax, DWORD PTR _saver$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_restore_vertex
	mov	edi, DWORD PTR _web+12
	add	esp, 12					; 0000000cH
$LN15@local_rest:

; 932  :      }
; 933  :   }
; 934  : 
; 935  :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [esi+edi]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL16@local_rest
$LN61@local_rest:

; 937  : 
; 938  :   web.total_energy = saver->energy;
; 939  : 
; 940  :     FOR_ALL_BODIES(b_id) 

	mov	ecx, DWORD PTR _web+384
	mov	edx, DWORD PTR _saver$[ebp]
	fld	QWORD PTR [edx+8]
	mov	edi, ecx
	shr	edi, 28					; 0000001cH
	fstp	QWORD PTR _web+1240
	and	edi, 1
	je	$LN9@local_rest
$LL11@local_rest:
	mov	eax, DWORD PTR _web+348
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN10@local_rest

; 941  :     { int spot = 3*loc_ordinal(b_id);

	test	edi, edi
	je	SHORT $LN37@local_rest
	mov	ebx, esi
	jmp	SHORT $LN38@local_rest
$LN37@local_rest:
	or	ebx, -1
$LN38@local_rest:

; 942  :       set_body_volume(b_id,saver->bod[spot],NOSETSTAMP);

	mov	edx, DWORD PTR _saver$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	0
	lea	ebx, DWORD PTR [ebx+ebx*2]
	fld	QWORD PTR [eax+ebx*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	call	_set_body_volume
	add	esp, 16					; 00000010H

; 943  :       set_body_pressure(b_id,saver->bod[spot+1]);

	test	edi, edi
	je	SHORT $LN62@local_rest
	mov	ecx, DWORD PTR _saver$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _web+348
	fld	QWORD PTR [edx+ebx*8+8]
	mov	ecx, DWORD PTR [eax+esi*4]
	fstp	QWORD PTR [ecx+312]
$LN62@local_rest:

; 944  :       set_body_volconst(b_id,saver->bod[spot+2]);

	mov	edx, DWORD PTR _saver$[ebp]
	mov	eax, DWORD PTR [edx+16]
	fld	QWORD PTR [eax+ebx*8+16]
	test	edi, edi
	je	SHORT $LN68@local_rest
	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+esi*4]
	fst	QWORD PTR [edx+328]
	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN68@local_rest
	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	edx, DWORD PTR [ecx+404]
	mov	eax, DWORD PTR _gen_quant_list
	imul	edx, 368				; 00000170H
	fstp	QWORD PTR [edx+eax+208]
	jmp	SHORT $LN10@local_rest
$LN68@local_rest:
	fstp	ST(0)
$LN10@local_rest:

; 937  : 
; 938  :   web.total_energy = saver->energy;
; 939  : 
; 940  :     FOR_ALL_BODIES(b_id) 

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR [edx]
	mov	edi, ecx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	$LL11@local_rest
$LN9@local_rest:

; 945  :     }
; 946  :     for ( n = LOW_INST ; n < meth_inst_count ; n++ )

	mov	esi, 1
	mov	ecx, esi
	cmp	DWORD PTR _web+5560, esi
	jle	SHORT $LN4@local_rest
	npad	8
$LL6@local_rest:

; 947  :        METH_INSTANCE(n)->value = saver->meth[n];

	mov	eax, DWORD PTR _saver$[ebp]
	mov	edi, DWORD PTR [eax+20]
	fld	QWORD PTR [edi+ecx*8]
	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	add	ecx, esi
	fstp	QWORD PTR [eax+edx+312]
	cmp	ecx, DWORD PTR _web+5560
	jl	SHORT $LL6@local_rest
$LN4@local_rest:

; 948  :     for ( n = 0 ; n < gen_quant_count ; n++ )

	xor	edx, edx
	cmp	DWORD PTR _web+5528, edx
	jle	SHORT $LN57@local_rest
	xor	ecx, ecx
	xor	eax, eax
	npad	5
$LL3@local_rest:

; 949  :     { GEN_QUANT(n)->value = saver->quant[2*n];

	mov	esi, DWORD PTR _saver$[ebp]
	mov	edi, DWORD PTR [esi+24]
	fld	QWORD PTR [eax+edi]
	mov	edi, DWORD PTR _gen_quant_list
	fstp	QWORD PTR [ecx+edi+152]

; 950  :       GEN_QUANT(n)->pressure = saver->quant[2*n+1];

	mov	esi, DWORD PTR [esi+24]
	fld	QWORD PTR [eax+esi+8]
	mov	esi, DWORD PTR _gen_quant_list
	fstp	QWORD PTR [ecx+esi+192]
	inc	edx
	add	eax, 16					; 00000010H
	add	ecx, 368				; 00000170H
	cmp	edx, DWORD PTR _web+5528
	jl	SHORT $LL3@local_rest

; 951  :     }
; 952  : 
; 953  :   global_timestamp++;

	inc	DWORD PTR _global_timestamp
	pop	edi
	pop	esi
	pop	ebx

; 954  : } /* end restore_coords() */

	pop	ebp
	ret	0
$LN57@local_rest:

; 951  :     }
; 952  : 
; 953  :   global_timestamp++;

	add	DWORD PTR _global_timestamp, esi
	pop	edi
	pop	esi
	pop	ebx

; 954  : } /* end restore_coords() */

	pop	ebp
	ret	0
_local_restore_coords ENDP
_TEXT	ENDS
PUBLIC	_unsave_coords
; Function compile flags: /Ogtp
;	COMDAT _unsave_coords
_TEXT	SEGMENT
_saver$ = 8						; size = 4
_mode$ = 12						; size = 4
_unsave_coords PROC					; COMDAT

; 1007 : {

	push	ebp
	mov	ebp, esp

; 1013 :   #endif
; 1014 : } // end unsave_coords()

	pop	ebp

; 1008 :   #ifdef MPI_EVOLVER
; 1009 :   if ( this_task != 0 ) return;
; 1010 :   mpi_unsave_coords(mode);
; 1011 :   #else
; 1012 :   local_unsave_coords(saver,mode);

	jmp	_local_unsave_coords
_unsave_coords ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@JPGHHMFC@One?5jiggle?5done?4?6?$AA@	; `string'
PUBLIC	__real@3fb999999999999a
PUBLIC	_jiggle
;	COMDAT ??_C@_0BC@JPGHHMFC@One?5jiggle?5done?4?6?$AA@
CONST	SEGMENT
??_C@_0BC@JPGHHMFC@One?5jiggle?5done?4?6?$AA@ DB 'One jiggle done.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _jiggle
_TEXT	SEGMENT
tv204 = -8						; size = 8
_jiggle	PROC						; COMDAT

; 1059 : {

	push	ebp
	mov	ebp, esp

; 1060 :   vertex_id v_id;
; 1061 :   REAL *x;
; 1062 :   int j;
; 1063 : 
; 1064 :   if ( web.max_len == 0.0 ) web.max_len = .1;

	fld	QWORD PTR _web+1560
	sub	esp, 8
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@jiggle
	fld	QWORD PTR __real@3fb999999999999a
	fstp	QWORD PTR _web+1560
$LN11@jiggle:

; 1065 :   if ( overall_size <= 0.0 ) resize();

	fcomp	QWORD PTR _overall_size
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN10@jiggle
	call	_resize
$LN10@jiggle:

; 1066 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	$LN7@jiggle
	push	ebx
	push	esi
	push	edi
	npad	4
$LL9@jiggle:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	ebx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv204[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN8@jiggle

; 1067 :      { if ( get_vattr(v_id) & FIXED ) continue;

	and	ecx, 64					; 00000040H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN8@jiggle

; 1068 :         x = get_coord(v_id);

	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	edi, DWORD PTR [eax+ecx+64]
	add	edi, edx

; 1069 :         for ( j = 0 ; j < SDIM ; j++ )

	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN8@jiggle
$LL3@jiggle:

; 1070 :           x[j] += gaussian()*web.temperature*web.max_len*overall_size;

	call	_gaussian
	fmul	QWORD PTR _web+1576
	inc	esi
	fmul	QWORD PTR _web+1560
	fmul	QWORD PTR _overall_size
	fadd	QWORD PTR [edi+esi*8-8]
	fstp	QWORD PTR [edi+esi*8-8]
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL3@jiggle
$LN8@jiggle:

; 1066 :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	$LL9@jiggle
	pop	edi
	pop	esi
	pop	ebx
$LN7@jiggle:

; 1071 :      }
; 1072 :   outstring("One jiggle done.\n");

	push	OFFSET ??_C@_0BC@JPGHHMFC@One?5jiggle?5done?4?6?$AA@
	call	_outstring
	add	esp, 4

; 1073 : } // end jiggle()

	mov	esp, ebp
	pop	ebp
	ret	0
_jiggle	ENDP
_TEXT	ENDS
PUBLIC	_estimate_decrease
EXTRN	_estimated_change:QWORD
; Function compile flags: /Ogtp
;	COMDAT _estimate_decrease
_TEXT	SEGMENT
_change$ = -8						; size = 8
_estimate_decrease PROC					; COMDAT

; 1230 : { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1231 :   REAL change = 0.0;

	fldz
	push	esi

; 1232 : 
; 1233 :   for ( i = 0 ; i < optparamcount ; i++ ) 

	mov	esi, DWORD PTR _optparamcount
	fst	QWORD PTR _change$[ebp]
	fld	QWORD PTR _web+1512
	xor	edx, edx
	cmp	esi, 4
	jl	SHORT $LC9@estimate_d

; 1231 :   REAL change = 0.0;

	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	inc	ecx
	mov	eax, OFFSET _optparam+16
	lea	edx, DWORD PTR [ecx*4]

; 1232 : 
; 1233 :   for ( i = 0 ; i < optparamcount ; i++ ) 

$LN10@estimate_d:

; 1234 :     change += web.scale*optparam[i].grad*optparam[i].velocity;

	fld	QWORD PTR [eax+48]
	add	eax, 224				; 000000e0H
	dec	ecx
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [eax-168]
	fld	QWORD PTR [eax-232]
	fmul	ST(0), ST(2)
	fmul	QWORD PTR [eax-224]
	faddp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fld	QWORD PTR [eax-120]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [eax-112]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [eax-64]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [eax-56]
	faddp	ST(2), ST(0)
	jne	SHORT $LN10@estimate_d
	fxch	ST(1)
	fst	QWORD PTR _change$[ebp]
	fxch	ST(1)
$LC9@estimate_d:

; 1232 : 
; 1233 :   for ( i = 0 ; i < optparamcount ; i++ ) 

	cmp	edx, esi
	jge	SHORT $LN19@estimate_d
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	lea	eax, DWORD PTR _optparam[eax*8+16]
	sub	esi, edx
$LC3@estimate_d:

; 1234 :     change += web.scale*optparam[i].grad*optparam[i].velocity;

	fld	QWORD PTR [eax-8]
	add	eax, 56					; 00000038H
	dec	esi
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [eax-56]
	faddp	ST(2), ST(0)
	jne	SHORT $LC3@estimate_d
	fstp	ST(0)
	fstp	QWORD PTR _change$[ebp]
	jmp	SHORT $LN8@estimate_d
$LN19@estimate_d:
	fstp	ST(0)
	fstp	ST(0)
$LN8@estimate_d:

; 1235 : 
; 1236 : #ifdef MPI_EVOLVER
; 1237 :   change += mpi_v_estimate();
; 1238 : #else
; 1239 :   change += v_estimate();

	call	_v_estimate
	fadd	QWORD PTR _change$[ebp]
	pop	esi

; 1240 : #endif
; 1241 : 
; 1242 :   estimated_change = -change;  /* for estimated_change internal variable */

	fchs
	fst	QWORD PTR _estimated_change

; 1243 :   return -change;  /* negative since forces are opposite gradients */
; 1244 :   
; 1245 : } // end estimate_decrease()

	mov	esp, ebp
	pop	ebp
	ret	0
_estimate_decrease ENDP
_TEXT	ENDS
PUBLIC	__real@4024000000000000
PUBLIC	__real@3cd203af9ee75616
PUBLIC	_cg_calc_gamma
EXTRN	_ribiere_flag:DWORD
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3cd203af9ee75616
CONST	SEGMENT
__real@3cd203af9ee75616 DQ 03cd203af9ee75616r	; 1e-015
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _cg_calc_gamma
_TEXT	SEGMENT
_rsum$ = -8						; size = 8
_cg_calc_gamma PROC					; COMDAT

; 1330 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1331 : 
; 1332 :   REAL sum = 0.0;
; 1333 :   REAL rsum = 0.0;
; 1334 :   int i;
; 1335 : 
; 1336 :   if ( ribiere_flag )

	cmp	DWORD PTR _ribiere_flag, 0
	fldz
	fstp	QWORD PTR _rsum$[ebp]
	push	esi
	je	$LN17@cg_calc_ga

; 1337 :   { 
; 1338 : #ifdef MPI_EVOLVER
; 1339 :     rsum = mpi_ribiere_calc();
; 1340 : #else
; 1341 :     rsum = ribiere_calc();

	call	_ribiere_calc
	fst	QWORD PTR _rsum$[ebp]

; 1342 : #endif
; 1343 : 
; 1344 :     for ( i = 0 ; i < optparamcount ; i++ ) 

	mov	esi, DWORD PTR _optparamcount
	xor	edx, edx
	cmp	esi, 4
	jl	SHORT $LC18@cg_calc_ga

; 1337 :   { 
; 1338 : #ifdef MPI_EVOLVER
; 1339 :     rsum = mpi_ribiere_calc();
; 1340 : #else
; 1341 :     rsum = ribiere_calc();

	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	inc	ecx
	mov	eax, OFFSET _optparam+40
	lea	edx, DWORD PTR [ecx*4]

; 1342 : #endif
; 1343 : 
; 1344 :     for ( i = 0 ; i < optparamcount ; i++ ) 

$LN19@cg_calc_ga:

; 1345 :     { rsum += optparam[i].grad*optparam[i].oldgrad;

	fld	QWORD PTR [eax]

; 1346 :       optparam[i].oldgrad = optparam[i].grad;

	add	eax, 224				; 000000e0H
	dec	ecx
	fmul	QWORD PTR [eax-256]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax-256]
	fstp	QWORD PTR [eax-224]
	fld	QWORD PTR [eax-200]
	fmul	QWORD PTR [eax-168]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax-200]
	fstp	QWORD PTR [eax-168]
	fld	QWORD PTR [eax-144]
	fmul	QWORD PTR [eax-112]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax-144]
	fstp	QWORD PTR [eax-112]
	fld	QWORD PTR [eax-88]
	fmul	QWORD PTR [eax-56]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax-88]
	fstp	QWORD PTR [eax-56]
	jne	SHORT $LN19@cg_calc_ga

; 1345 :     { rsum += optparam[i].grad*optparam[i].oldgrad;

	fst	QWORD PTR _rsum$[ebp]
$LC18@cg_calc_ga:

; 1342 : #endif
; 1343 : 
; 1344 :     for ( i = 0 ; i < optparamcount ; i++ ) 

	cmp	edx, esi
	jge	SHORT $LN34@cg_calc_ga
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	lea	eax, DWORD PTR _optparam[eax*8+40]
	sub	esi, edx
$LC9@cg_calc_ga:

; 1345 :     { rsum += optparam[i].grad*optparam[i].oldgrad;

	fld	QWORD PTR [eax]
	add	eax, 56					; 00000038H
	dec	esi
	fmul	QWORD PTR [eax-88]
	faddp	ST(1), ST(0)

; 1346 :       optparam[i].oldgrad = optparam[i].grad;

	fld	QWORD PTR [eax-88]
	fstp	QWORD PTR [eax-56]
	jne	SHORT $LC9@cg_calc_ga

; 1345 :     { rsum += optparam[i].grad*optparam[i].oldgrad;

	fstp	QWORD PTR _rsum$[ebp]
	jmp	SHORT $LN17@cg_calc_ga
$LN34@cg_calc_ga:
	fstp	ST(0)
$LN17@cg_calc_ga:

; 1347 :     }
; 1348 :   }
; 1349 : 
; 1350 : #ifdef MPI_EVOLVER
; 1351 :     sum = mpi_cg_sum_calc();
; 1352 : #else
; 1353 :     sum = cg_sum_calc();

	call	_cg_sum_calc

; 1354 : #endif
; 1355 : 
; 1356 :   for ( i = 0 ; i < optparamcount ; i++ ) 

	mov	esi, DWORD PTR _optparamcount
	xor	edx, edx
	cmp	esi, 4
	jl	SHORT $LC21@cg_calc_ga

; 1347 :     }
; 1348 :   }
; 1349 : 
; 1350 : #ifdef MPI_EVOLVER
; 1351 :     sum = mpi_cg_sum_calc();
; 1352 : #else
; 1353 :     sum = cg_sum_calc();

	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	inc	ecx
	mov	eax, OFFSET _optparam+8
	lea	edx, DWORD PTR [ecx*4]

; 1354 : #endif
; 1355 : 
; 1356 :   for ( i = 0 ; i < optparamcount ; i++ ) 

$LN22@cg_calc_ga:

; 1357 :       sum += optparam[i].velocity*optparam[i].grad;

	fld	QWORD PTR [eax+64]
	add	eax, 224				; 000000e0H
	dec	ecx
	fmul	QWORD PTR [eax-168]
	fld	QWORD PTR [eax-216]
	fmul	QWORD PTR [eax-224]
	faddp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax-104]
	fmul	QWORD PTR [eax-112]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax-48]
	fmul	QWORD PTR [eax-56]
	faddp	ST(1), ST(0)
	jne	SHORT $LN22@cg_calc_ga
$LC21@cg_calc_ga:

; 1354 : #endif
; 1355 : 
; 1356 :   for ( i = 0 ; i < optparamcount ; i++ ) 

	cmp	edx, esi
	jge	SHORT $LN20@cg_calc_ga
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	lea	eax, DWORD PTR _optparam[eax*8+8]
	sub	esi, edx
$LC6@cg_calc_ga:

; 1357 :       sum += optparam[i].velocity*optparam[i].grad;

	fld	QWORD PTR [eax+8]
	add	eax, 56					; 00000038H
	dec	esi
	fmul	QWORD PTR [eax-56]
	faddp	ST(1), ST(0)
	jne	SHORT $LC6@cg_calc_ga
$LN20@cg_calc_ga:

; 1358 : 
; 1359 :   if ( cg_oldsum >= 1e-15 )

	fld	QWORD PTR __real@3cd203af9ee75616
	pop	esi
	fld	QWORD PTR _cg_oldsum
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 1
	jne	SHORT $LN48@cg_calc_ga

; 1360 :      cg_gamma = (sum-rsum)/cg_oldsum;

	fld	ST(1)
	fsub	QWORD PTR _rsum$[ebp]
	fdivrp	ST(1), ST(0)
	fst	QWORD PTR _cg_gamma
	jmp	SHORT $LN3@cg_calc_ga
$LN48@cg_calc_ga:

; 1358 : 
; 1359 :   if ( cg_oldsum >= 1e-15 )

	fstp	ST(0)

; 1360 :      cg_gamma = (sum-rsum)/cg_oldsum;

	fld	QWORD PTR _cg_gamma
$LN3@cg_calc_ga:

; 1361 : 
; 1362 :   if ( cg_gamma > 10.0 ) /* something probably changed too much */

	fld	QWORD PTR __real@4024000000000000
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN26@cg_calc_ga
	fstp	ST(0)

; 1363 :       cg_gamma = 0.0;

	fldz
	fld	ST(0)
	fst	QWORD PTR _cg_gamma
	jmp	SHORT $LN2@cg_calc_ga
$LN26@cg_calc_ga:
	fldz
	fxch	ST(1)
$LN2@cg_calc_ga:

; 1364 : 
; 1365 :   /* guarantee convergence, (Shewchuk notes, p. 42)  */
; 1366 :   if ( ribiere_flag && (cg_gamma < 0.0) ) cg_gamma = 0.0;

	cmp	DWORD PTR _ribiere_flag, 0
	je	SHORT $LN56@cg_calc_ga
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN59@cg_calc_ga
	fstp	QWORD PTR _cg_gamma

; 1367 : 
; 1368 :   cg_oldsum = sum; return;

	fstp	QWORD PTR _cg_oldsum

; 1369 : } /* end cg_calc_gamma() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@cg_calc_ga:

; 1364 : 
; 1365 :   /* guarantee convergence, (Shewchuk notes, p. 42)  */
; 1366 :   if ( ribiere_flag && (cg_gamma < 0.0) ) cg_gamma = 0.0;

	fstp	ST(0)
$LN59@cg_calc_ga:
	fstp	ST(0)

; 1367 : 
; 1368 :   cg_oldsum = sum; return;

	fstp	QWORD PTR _cg_oldsum

; 1369 : } /* end cg_calc_gamma() */

	mov	esp, ebp
	pop	ebp
	ret	0
_cg_calc_gamma ENDP
_TEXT	ENDS
PUBLIC	_cg_direction
; Function compile flags: /Ogtp
;	COMDAT _cg_direction
_TEXT	SEGMENT
_cg_direction PROC					; COMDAT

; 1426 : {

	push	esi

; 1427 :   int i;
; 1428 : 
; 1429 : #ifdef MPI_EVOLVER
; 1430 :   mpi_cg_direction();  /* do vertices */
; 1431 : #else
; 1432 :   cg_direction_local();

	call	_cg_direction_local

; 1433 : #endif
; 1434 : 
; 1435 :   for ( i = 0 ; i < optparamcount ; i++ ) 

	fld	QWORD PTR _cg_gamma
	mov	esi, DWORD PTR _optparamcount
	xor	edx, edx
	cmp	esi, 4
	jl	SHORT $LC9@cg_directi@2

; 1427 :   int i;
; 1428 : 
; 1429 : #ifdef MPI_EVOLVER
; 1430 :   mpi_cg_direction();  /* do vertices */
; 1431 : #else
; 1432 :   cg_direction_local();

	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	inc	ecx
	mov	eax, OFFSET _optparam+24
	lea	edx, DWORD PTR [ecx*4]

; 1433 : #endif
; 1434 : 
; 1435 :   for ( i = 0 ; i < optparamcount ; i++ ) 

$LN10@cg_directi@2:

; 1436 :   { optparam[i].grad += cg_gamma*optparam[i].cg;

	fld	QWORD PTR [eax]

; 1437 :     optparam[i].cg = optparam[i].grad;

	add	eax, 224				; 000000e0H
	dec	ecx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-240]
	fst	QWORD PTR [eax-240]
	fstp	QWORD PTR [eax-224]
	fld	ST(0)
	fmul	QWORD PTR [eax-168]
	fadd	QWORD PTR [eax-184]
	fst	QWORD PTR [eax-184]
	fstp	QWORD PTR [eax-168]
	fld	QWORD PTR [eax-112]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-128]
	fst	QWORD PTR [eax-128]
	fstp	QWORD PTR [eax-112]
	fld	ST(0)
	fmul	QWORD PTR [eax-56]
	fadd	QWORD PTR [eax-72]
	fst	QWORD PTR [eax-72]
	fstp	QWORD PTR [eax-56]
	jne	SHORT $LN10@cg_directi@2
$LC9@cg_directi@2:

; 1433 : #endif
; 1434 : 
; 1435 :   for ( i = 0 ; i < optparamcount ; i++ ) 

	cmp	edx, esi
	jge	SHORT $LN19@cg_directi@2
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	lea	eax, DWORD PTR _optparam[eax*8+24]
	sub	esi, edx
$LC3@cg_directi@2:

; 1436 :   { optparam[i].grad += cg_gamma*optparam[i].cg;

	fld	QWORD PTR [eax]
	add	eax, 56					; 00000038H
	dec	esi
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-72]
	fst	QWORD PTR [eax-72]

; 1437 :     optparam[i].cg = optparam[i].grad;

	fstp	QWORD PTR [eax-56]
	jne	SHORT $LC3@cg_directi@2
$LN19@cg_directi@2:

; 1433 : #endif
; 1434 : 
; 1435 :   for ( i = 0 ; i < optparamcount ; i++ ) 

	fstp	ST(0)
	pop	esi

; 1438 :   }
; 1439 : } // end cg_direction()

	ret	0
_cg_direction ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@LAJGMGIH@convert_forms_to_vectors?$CI?$CFs?5?$CFs?$CJ?6@ ; `string'
PUBLIC	??_C@_0L@HNPHJIDJ@CALC_FORCE?$AA@		; `string'
PUBLIC	??_C@_0O@KGCGABHK@CALC_VOLGRADS?$AA@		; `string'
PUBLIC	_convert_forms_to_vectors
;	COMDAT ??_C@_0CB@LAJGMGIH@convert_forms_to_vectors?$CI?$CFs?5?$CFs?$CJ?6@
CONST	SEGMENT
??_C@_0CB@LAJGMGIH@convert_forms_to_vectors?$CI?$CFs?5?$CFs?$CJ?6@ DB 'co'
	DB	'nvert_forms_to_vectors(%s %s)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HNPHJIDJ@CALC_FORCE?$AA@
CONST	SEGMENT
??_C@_0L@HNPHJIDJ@CALC_FORCE?$AA@ DB 'CALC_FORCE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KGCGABHK@CALC_VOLGRADS?$AA@
CONST	SEGMENT
??_C@_0O@KGCGABHK@CALC_VOLGRADS?$AA@ DB 'CALC_VOLGRADS', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _convert_forms_to_vectors
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_convert_forms_to_vectors PROC				; COMDAT

; 1707 : {

	push	ebp
	mov	ebp, esp

; 1708 :   if ( itdebug ) 

	cmp	DWORD PTR _itdebug, 0
	push	ebx
	mov	ebx, DWORD PTR _mode$[ebp]
	je	SHORT $LN1@convert_fo

; 1709 :   { sprintf(msg,"convert_forms_to_vectors(%s %s)\n",
; 1710 :        (mode&CALC_FORCE)?"CALC_FORCE":"",(mode&CALC_VOLGRADS)?"CALC_VOLGRADS":"");

	mov	ecx, OFFSET ??_C@_0O@KGCGABHK@CALC_VOLGRADS?$AA@
	test	bl, 2
	jne	SHORT $LN5@convert_fo
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN5@convert_fo:
	mov	eax, OFFSET ??_C@_0L@HNPHJIDJ@CALC_FORCE?$AA@
	test	bl, 1
	jne	SHORT $LN7@convert_fo
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN7@convert_fo:
	push	ecx
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0CB@LAJGMGIH@convert_forms_to_vectors?$CI?$CFs?5?$CFs?$CJ?6@
	push	eax
	call	_sprintf

; 1711 :     outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 20					; 00000014H
$LN1@convert_fo:

; 1712 :   }
; 1713 : 
; 1714 :   #ifdef MPI_EVOLVER
; 1715 :   if ( this_task != 0 ) return;
; 1716 :   mpi_convert_forms_to_vectors(mode);
; 1717 :   #else
; 1718 :   local_convert_forms_to_vectors(mode);

	push	ebx
	call	_local_convert_forms_to_vectors
	add	esp, 4
	pop	ebx

; 1719 :   #endif
; 1720 : } // end convert_forms_to_vectors()

	pop	ebp
	ret	0
_convert_forms_to_vectors ENDP
_TEXT	ENDS
PUBLIC	_calc_all_grads
EXTRN	_pressure_set_flag:DWORD
EXTRN	_lagrange_adjust:PROC
EXTRN	_calc_lagrange:PROC
EXTRN	_partner_shift_grads:PROC
EXTRN	_pressure_forces:PROC
EXTRN	_calc_force:PROC
EXTRN	_calc_volgrads:PROC
EXTRN	_find_fixed:PROC
; Function compile flags: /Ogtp
;	COMDAT _calc_all_grads
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_calc_all_grads PROC					; COMDAT

; 323  : { find_fixed();

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	call	_find_fixed

; 324  :  
; 325  : 
; 326  :   if ( mode & CALC_VOLGRADS ) 

	mov	ebx, DWORD PTR _mode$[ebp]
	test	bl, 2
	je	SHORT $LN3@calc_all_g

; 327  :     calc_volgrads(DO_OPTS);

	push	1
	call	_calc_volgrads
	add	esp, 4
$LN3@calc_all_g:

; 328  :   if ( mode & CALC_FORCE )

	mov	esi, ebx
	and	esi, 1
	je	SHORT $LN2@calc_all_g

; 329  :   { calc_force();

	call	_calc_force

; 330  :     pressure_forces();

	call	_pressure_forces
$LN2@calc_all_g:

; 331  :   }
; 332  : 
; 333  :   partner_shift_grads(mode);  /* in case doing partners */

	push	ebx
	call	_partner_shift_grads

; 334  : 
; 335  :   /* Now have energy and constraint gradients as forms. 
; 336  :       Next convert to vectors using current metric. */
; 337  : /* lagrange_recalc: */
; 338  :   convert_forms_to_vectors(mode);  /* using current metric */

	push	ebx
	call	_convert_forms_to_vectors
	add	esp, 8

; 339  :   /*one_sided_adjust(mode);*/ /* modify forces and grads on one-sided constraints */
; 340  : 
; 341  :   if ( mode & CALC_FORCE )

	test	esi, esi
	pop	esi
	pop	ebx
	je	SHORT $LN1@calc_all_g

; 342  :   { calc_lagrange();     /* calculate Lagrange multipliers */

	call	_calc_lagrange

; 343  :     lagrange_adjust();   /* adjust forces using Lagrange multipliers */

	call	_lagrange_adjust

; 344  :     pressure_set_flag = 1;

	mov	DWORD PTR _pressure_set_flag, 1
$LN1@calc_all_g:

; 345  : 
; 346  :   }
; 347  : } /* end calc_all_grads() */

	pop	ebp
	ret	0
_calc_all_grads ENDP
_TEXT	ENDS
PUBLIC	_restore_coords
; Function compile flags: /Ogtp
;	COMDAT _restore_coords
_TEXT	SEGMENT
_saver$ = 8						; size = 4
_mode$ = 12						; size = 4
_restore_coords PROC					; COMDAT

; 892  : {

	push	ebp
	mov	ebp, esp

; 898  :   #endif
; 899  : } // end restore_coords()

	pop	ebp

; 893  :   #ifdef MPI_EVOLVER
; 894  :   if ( this_task != 0 ) return;
; 895  :   mpi_restore_coords(mode);
; 896  :   #else
; 897  :   local_restore_coords(saver,mode);

	jmp	_local_restore_coords
_restore_coords ENDP
_TEXT	ENDS
PUBLIC	??_C@_0GG@DJAOMLDF@Volume?5or?5quantity?5constraints?5d@ ; `string'
PUBLIC	??_C@_0FN@EDEJHGCA@Total?5constraint?5difference?5woul@ ; `string'
PUBLIC	??_C@_0P@NEGIMGBL@Next?5diff?3?5?$CFg?6?$AA@	; `string'
PUBLIC	??_C@_0BJ@MMHJJIIM@Recalculating?5volgrads?4?6?$AA@ ; `string'
PUBLIC	__real@4059000000000000
PUBLIC	??_C@_0CD@MDOABHPG@Diff?5increased?4?5Restoring?5coords@ ; `string'
PUBLIC	__real@3ff028f5c28f5c29
PUBLIC	??_C@_0BK@LCIHGHLM@Diff?3?5?$CFg?5?5?5?5Old_diff?3?5?$CFg?6?$AA@ ; `string'
PUBLIC	??_C@_0DH@FDOBAEKH@project_all?$CI?$CJ?3?5to?5level?5set?5and?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_project_all
EXTRN	_reset_conj_grad:PROC
EXTRN	_volume_restore:PROC
EXTRN	_calc_leftside:PROC
EXTRN	_volgrads_every_flag:DWORD
EXTRN	_printf:PROC
EXTRN	_fixed_constraint_flag:DWORD
EXTRN	_detect_bdry_hits:PROC
EXTRN	_thread_launch:PROC
EXTRN	_threadflag:DWORD
;	COMDAT ??_C@_0GG@DJAOMLDF@Volume?5or?5quantity?5constraints?5d@
CONST	SEGMENT
??_C@_0GG@DJAOMLDF@Volume?5or?5quantity?5constraints?5d@ DB 'Volume or qu'
	DB	'antity constraints don''t converge in 10 projections.', 0aH, 'T'
	DB	'otal difference %g times tolerance', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@EDEJHGCA@Total?5constraint?5difference?5woul@
CONST	SEGMENT
??_C@_0FN@EDEJHGCA@Total?5constraint?5difference?5woul@ DB 'Total constra'
	DB	'int difference would increase by factor of %f.', 0aH, 'Aborti'
	DB	'ng constraint adjustment.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NEGIMGBL@Next?5diff?3?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0P@NEGIMGBL@Next?5diff?3?5?$CFg?6?$AA@ DB 'Next diff: %g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MMHJJIIM@Recalculating?5volgrads?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@MMHJJIIM@Recalculating?5volgrads?4?6?$AA@ DB 'Recalculating vol'
	DB	'grads.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT ??_C@_0CD@MDOABHPG@Diff?5increased?4?5Restoring?5coords@
CONST	SEGMENT
??_C@_0CD@MDOABHPG@Diff?5increased?4?5Restoring?5coords@ DB 'Diff increas'
	DB	'ed. Restoring coords.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@3ff028f5c28f5c29
CONST	SEGMENT
__real@3ff028f5c28f5c29 DQ 03ff028f5c28f5c29r	; 1.01
CONST	ENDS
;	COMDAT ??_C@_0BK@LCIHGHLM@Diff?3?5?$CFg?5?5?5?5Old_diff?3?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BK@LCIHGHLM@Diff?3?5?$CFg?5?5?5?5Old_diff?3?5?$CFg?6?$AA@ DB 'Diff'
	DB	': %g    Old_diff: %g', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FDOBAEKH@project_all?$CI?$CJ?3?5to?5level?5set?5and?5@
CONST	SEGMENT
??_C@_0DH@FDOBAEKH@project_all?$CI?$CJ?3?5to?5level?5set?5and?5@ DB 'proj'
	DB	'ect_all(): to level set and extensive constraints', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _project_all
_TEXT	SEGMENT
_stepsize$89542 = -872					; size = 8
tv296 = -868						; size = 4
_diff$89541 = -864					; size = 8
_one_sided_mode$ = -860					; size = 4
_v_id$ = -856						; size = 4
_old_diff$89540 = -852					; size = 8
_attr$89509 = -852					; size = 8
tv442 = -848						; size = 4
_psaved$89543 = -844					; size = 840
__$ArrayPad$ = -4					; size = 4
_mode$ = 8						; size = 4
_mode2$ = 12						; size = 4
_project_all PROC					; COMDAT

; 664  : { vertex_id v_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 872				; 00000368H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi

; 665  :   int one_sided_mode = (mode2==TEST_MOVE) ? KEEP_ONESIDEDNESS : RESET_ONESIDEDNESS;

	xor	eax, eax
	push	edi
	mov	edi, DWORD PTR _mode2$[ebp]
	test	edi, edi
	setne	al

; 666  :   /* project to constraints and boundaries */
; 667  : 
; 668  :   if ( itdebug )

	cmp	DWORD PTR _itdebug, 0
	mov	DWORD PTR _one_sided_mode$[ebp], eax
	je	SHORT $LN31@project_al

; 669  :     outstring("project_all(): to level set and extensive constraints\n");

	push	OFFSET ??_C@_0DH@FDOBAEKH@project_all?$CI?$CJ?3?5to?5level?5set?5and?5@
	call	_outstring
	add	esp, 4
$LN31@project_al:

; 670  : 
; 671  :   if ( threadflag )

	cmp	DWORD PTR _threadflag, 0
	je	SHORT $LN30@project_al

; 672  :   { int task = mode2==TEST_MOVE ? TH_PROJECT_ALL_TEST : TH_PROJECT_ALL_ACTUAL;

	xor	ecx, ecx
	test	edi, edi
	setne	cl

; 673  :     thread_launch(task,VERTEX);

	push	0
	inc	ecx
	push	ecx
	call	_thread_launch
	add	esp, 8

; 674  :   }
; 675  :   else

	jmp	$LN49@project_al
$LN30@project_al:

; 676  :   FOR_ALL_VERTICES(v_id)

	mov	esi, DWORD PTR _web+48
	mov	DWORD PTR _v_id$[ebp], esi
	test	esi, 268435456				; 10000000H
	je	$LN49@project_al
	jmp	SHORT $LN28@project_al
	npad	9
$LL46@project_al:
	mov	esi, DWORD PTR _v_id$[ebp]
$LN28@project_al:
	mov	edx, DWORD PTR _web+12
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+edx]
	mov	edi, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, edi
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv296[ebp], esi
	je	$LN27@project_al

; 677  :   { ATTR attr = get_vattr(v_id);
; 678  :     if ( attr & CONSTRAINT )

	mov	eax, edi
	mov	DWORD PTR _attr$89509[ebp+4], edx
	and	eax, 1024				; 00000400H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN23@project_al

; 679  :        project_v_constr(v_id,mode2,one_sided_mode);

	mov	eax, DWORD PTR _one_sided_mode$[ebp]
	mov	ecx, DWORD PTR _mode2$[ebp]
	mov	edx, DWORD PTR _v_id$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_project_v_constr
	add	esp, 12					; 0000000cH
	jmp	$LN27@project_al
$LN23@project_al:

; 680  :     else if ( attr & BOUNDARY )

	and	edi, 128				; 00000080H
	xor	eax, eax
	or	edi, eax
	je	$LN27@project_al

; 681  :     { int i;
; 682  :       struct boundary *boundary = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	mov	edx, DWORD PTR _dymem
	test	eax, eax
	je	SHORT $LN34@project_al
	mov	edi, eax
	mov	eax, DWORD PTR _web+104
	imul	edi, 240				; 000000f0H
	add	edi, eax
	mov	edi, DWORD PTR [edi+edx+64]
	mov	ecx, DWORD PTR [edi+ecx]
	imul	ecx, 136				; 00000088H
	add	ecx, DWORD PTR _web+776
	jmp	SHORT $LN35@project_al
$LN34@project_al:
	mov	eax, DWORD PTR _web+104
	xor	ecx, ecx
$LN35@project_al:

; 683  :       REAL *param = get_param(v_id);

	mov	edi, DWORD PTR _web+12
	mov	esi, DWORD PTR [esi+edi]
	mov	edi, DWORD PTR [eax+edx+544]

; 684  :       REAL *x = get_coord(v_id);

	mov	ebx, DWORD PTR [eax+edx+64]
	add	edi, esi
	add	ebx, esi

; 685  : 
; 686  :       for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN48@project_al

; 683  :       REAL *param = get_param(v_id);

	add	ecx, 48					; 00000030H
	mov	DWORD PTR tv442[ebp], ecx
	npad	5
$LL47@project_al:

; 687  :          x[i] = eval(boundary->coordf[i],param,v_id,NULL);

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR tv442[ebp]
	mov	edx, DWORD PTR [ecx]
	push	0
	push	eax
	push	edi
	push	edx
	call	_eval
	fstp	QWORD PTR [ebx+esi*8]
	add	DWORD PTR tv442[ebp], 4
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL47@project_al
$LN48@project_al:

; 685  : 
; 686  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR tv296[ebp]
$LN27@project_al:

; 676  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _v_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL46@project_al
	mov	edi, DWORD PTR _mode2$[ebp]
$LN49@project_al:

; 688  :     }
; 689  :   }
; 690  : 
; 691  :   /* TESTING new feature */
; 692  :   detect_bdry_hits();

	call	_detect_bdry_hits

; 693  :  
; 694  :   /* enforce volume constraints also; keep conjugate gradient under control */
; 695  :   if ( mode && fixed_constraint_flag ) 

	cmp	DWORD PTR _mode$[ebp], 0
	je	$LN45@project_al
	cmp	DWORD PTR _fixed_constraint_flag, 0
	je	$LN45@project_al

; 696  :   { int calc_count;
; 697  :     REAL orig_diff = calc_content(Q_FIXED);

	push	2
	call	_calc_content

; 698  :     REAL old_diff = orig_diff;

	fst	QWORD PTR _old_diff$89540[ebp]

; 699  :     REAL diff=old_diff;  /* total relative constraint diff */

	fstp	QWORD PTR _diff$89541[ebp]

; 700  :     REAL stepsize = 1.0;
; 701  :     struct oldcoord psaved;
; 702  :     calc_count = 1;
; 703  :     psaved.coord = NULL;
; 704  :     save_coords(&psaved,SAVE_SEPARATE);

	lea	edx, DWORD PTR _psaved$89543[ebp]
	fld1
	push	2
	mov	ebx, 1
	fstp	QWORD PTR _stepsize$89542[ebp]
	push	edx
	mov	esi, ebx
	mov	DWORD PTR _psaved$89543[ebp], 0
	call	_save_coords
	fld	QWORD PTR _diff$89541[ebp]
	add	esp, 12					; 0000000cH
$LN16@project_al:

; 705  :     do 
; 706  :     { if ( diff == 0.0 ) break; 

	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN57@project_al

; 707  :       if ( itdebug ) printf("Diff: %g    Old_diff: %g\n",

	cmp	DWORD PTR _itdebug, 0
	je	SHORT $LN12@project_al

; 708  :            (double)diff,(double)old_diff);

	fld	QWORD PTR _old_diff$89540[ebp]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BK@LCIHGHLM@Diff?3?5?$CFg?5?5?5?5Old_diff?3?5?$CFg?6?$AA@
	call	_printf
	fld	QWORD PTR _diff$89541[ebp]
	add	esp, 20					; 00000014H
$LN12@project_al:

; 709  :       if ( diff > 1.01*old_diff )

	fld	QWORD PTR _old_diff$89540[ebp]
	fld	QWORD PTR __real@3ff028f5c28f5c29
	fmul	ST(0), ST(1)
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN11@project_al

; 710  :       { 
; 711  :         if ( itdebug ) printf("Diff increased. Restoring coords.\n");

	cmp	DWORD PTR _itdebug, 0
	fstp	ST(1)
	fstp	ST(0)
	je	SHORT $LN10@project_al
	push	OFFSET ??_C@_0CD@MDOABHPG@Diff?5increased?4?5Restoring?5coords@
	call	_printf
	add	esp, 4
$LN10@project_al:

; 712  :         restore_coords(&psaved,SAVE_SEPARATE); 

	lea	eax, DWORD PTR _psaved$89543[ebp]
	push	2
	push	eax
	call	_restore_coords

; 713  :         if ( diff > 100*old_diff )

	fld	QWORD PTR _old_diff$89540[ebp]
	fld	QWORD PTR __real@4059000000000000
	add	esp, 8
	fmul	ST(0), ST(1)
	fld	QWORD PTR _diff$89541[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	je	$LN40@project_al

; 717  :         } 
; 718  :        /*   calc_content(Q_FIXED); taken care of by restore_coords */
; 719  :           stepsize *= 0.5;

	fld	QWORD PTR _stepsize$89542[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR _stepsize$89542[ebp]
	fxch	ST(1)
$LN8@project_al:

; 722  :       if ((volgrads_every_flag || (diff > 0.5*old_diff)) && (calc_count > 1))

	cmp	DWORD PTR _volgrads_every_flag, 0
	jne	SHORT $LN67@project_al
	fmul	QWORD PTR __real@3fe0000000000000
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN7@project_al
	jmp	SHORT $LN6@project_al
$LN11@project_al:

; 720  :       }
; 721  :       else stepsize = 1.0;

	fld1
	fstp	QWORD PTR _stepsize$89542[ebp]
	jmp	SHORT $LN8@project_al
$LN67@project_al:

; 722  :       if ((volgrads_every_flag || (diff > 0.5*old_diff)) && (calc_count > 1))

	fstp	ST(1)
	fstp	ST(0)
$LN6@project_al:
	cmp	esi, ebx
	jle	SHORT $LN7@project_al

; 723  :       { /* not good improvement, so recalculate */
; 724  :         if ( itdebug ) printf("Recalculating volgrads.\n");

	cmp	DWORD PTR _itdebug, 0
	je	SHORT $LN5@project_al
	push	OFFSET ??_C@_0BJ@MMHJJIIM@Recalculating?5volgrads?4?6?$AA@
	call	_printf
	add	esp, 4
$LN5@project_al:

; 725  :         calc_all_grads(CALC_VOLGRADS);

	push	2
	call	_calc_all_grads
	add	esp, 4

; 726  :         calc_leftside();

	call	_calc_leftside

; 727  :         volgrads_changed_flag = 1;

	mov	DWORD PTR _volgrads_changed_flag, ebx
$LN7@project_al:

; 728  :       }
; 729  :       volume_restore(stepsize,mode2);

	fld	QWORD PTR _stepsize$89542[ebp]
	push	edi
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_volume_restore

; 730  :       global_timestamp++;

	add	DWORD PTR _global_timestamp, ebx

; 737  :         break;
; 738  :       }
; 739  :       old_diff = diff;

	fld	QWORD PTR _diff$89541[ebp]
	mov	ecx, esi
	add	esp, 12					; 0000000cH
	add	esi, ebx
	cmp	ecx, 10					; 0000000aH
	jg	$LN41@project_al

; 740  :       diff = calc_content(Q_FIXED);

	push	2
	fstp	QWORD PTR _old_diff$89540[ebp]
	call	_calc_content
	fst	QWORD PTR _diff$89541[ebp]
	add	esp, 4

; 741  :       if ( itdebug ) printf("Next diff: %g\n",(double)diff);

	cmp	DWORD PTR _itdebug, 0
	je	SHORT $LN15@project_al
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0P@NEGIMGBL@Next?5diff?3?5?$CFg?6?$AA@
	call	_printf
	fld	QWORD PTR _diff$89541[ebp]
	add	esp, 12					; 0000000cH
$LN15@project_al:

; 742  :     } while ( mode && (diff > 1) ); 

	fld1
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	$LN16@project_al
$LN57@project_al:

; 705  :     do 
; 706  :     { if ( diff == 0.0 ) break; 

	fstp	ST(0)
$LN14@project_al:

; 743  : 
; 744  :     unsave_coords(&psaved,SAVE_SEPARATE);

	lea	ecx, DWORD PTR _psaved$89543[ebp]
	push	2
	push	ecx
	call	_unsave_coords
	add	esp, 8

; 745  :   } /* end enforcing volume constraints */
; 746  : 
; 747  :   global_timestamp++;

	add	DWORD PTR _global_timestamp, ebx
	pop	edi
	pop	esi
	pop	ebx

; 748  : 
; 749  :   return;
; 750  : } /* end project_all() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@project_al:

; 714  :         { sprintf(msg,"Total constraint difference would increase by factor of %f.\nAborting constraint adjustment.\n",(DOUBLE)fabs(diff/old_diff) );

	fdivrp	ST(1), ST(0)
	mov	edx, DWORD PTR _msg
	sub	esp, 8
	fabs
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0FN@EDEJHGCA@Total?5constraint?5difference?5woul@
	push	edx
	call	_sprintf

; 715  :           outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H

; 716  :           break;

	jmp	SHORT $LN14@project_al
$LN41@project_al:

; 731  :       if ( calc_count++ > 10 ) 
; 732  :       { 
; 733  :         sprintf(errmsg,"Volume or quantity constraints don't converge in 10 projections.\nTotal difference %g times tolerance\n",(DOUBLE)diff);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0GG@DJAOMLDF@Volume?5or?5quantity?5constraints?5d@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 16					; 00000010H

; 734  :         if ( mode2 == ACTUAL_MOVE )

	cmp	edi, ebx
	jne	SHORT $LN52@project_al

; 735  :            kb_error(1055,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1055					; 0000041fH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN52@project_al:

; 736  :         reset_conj_grad();

	call	_reset_conj_grad
	jmp	$LN14@project_al
$LN45@project_al:

; 748  : 
; 749  :   return;
; 750  : } /* end project_all() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	inc	DWORD PTR _global_timestamp
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_project_all ENDP
_TEXT	ENDS
PUBLIC	_local_move_vertices
; Function compile flags: /Ogtp
;	COMDAT _local_move_vertices
_TEXT	SEGMENT
tv678 = -24						; size = 8
tv1515 = -20						; size = 4
_pcount$89418 = -20					; size = 4
tv1196 = -16						; size = 4
tv672 = -12						; size = 4
_i$ = -8						; size = 4
_dim$ = -4						; size = 4
_mode$ = 8						; size = 4
_scale$ = 12						; size = 8
_local_move_vertices PROC				; COMDAT

; 564  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 565  :   REAL *velocity;
; 566  :   REAL *x;
; 567  :   int i;
; 568  :   vertex_id v_id;
; 569  :   int dim = ackerman_flag ? 2*SDIM : SDIM;

	cmp	DWORD PTR _ackerman_flag, 0
	je	SHORT $LN24@local_move
	mov	eax, DWORD PTR _web+616
	lea	ecx, DWORD PTR [eax+eax]
	mov	DWORD PTR _dim$[ebp], ecx
	jmp	SHORT $LN25@local_move
$LN24@local_move:
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR _dim$[ebp], edx
$LN25@local_move:

; 570  : 
; 571  :   if ( optparamcount > 0 )

	mov	eax, DWORD PTR _optparamcount
	fld	QWORD PTR _scale$[ebp]
	push	esi
	push	edi
	test	eax, eax
	jle	$LN55@local_move

; 572  :   { for ( i = 0 ; i < optparamcount ; i++ )

	xor	edi, edi
	test	eax, eax
	jle	$LN71@local_move
	mov	esi, OFFSET _optparam
$LN20@local_move:

; 573  :     { struct global *g =  globals(optparam[i].pnum);

	mov	eax, DWORD PTR [esi]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN26@local_move
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN28@local_move
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN27@local_move
$LN28@local_move:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN26@local_move
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN27@local_move
$LN26@local_move:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN27@local_move:

; 574  :       g->value.real -= scale*g->attr.varstuff.pscale*optparam[i].velocity;

	fld	QWORD PTR [eax+176]
	fmul	ST(0), ST(1)
	fmul	QWORD PTR [esi+16]
	fsubr	QWORD PTR [eax+64]
	fstp	QWORD PTR [eax+64]

; 575  :       if ( g->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [eax+188]
	test	eax, eax
	je	SHORT $LN19@local_move

; 576  :       { struct  global *gg = globals(g->attr.varstuff.on_assign_call);

	mov	ecx, eax
	fstp	ST(0)
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN32@local_move
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN34@local_move
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN33@local_move
$LN34@local_move:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN32@local_move
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN33@local_move
$LN32@local_move:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN33@local_move:

; 577  :         eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	fld	QWORD PTR _scale$[ebp]
	add	esp, 16					; 00000010H
$LN19@local_move:

; 572  :   { for ( i = 0 ; i < optparamcount ; i++ )

	inc	edi
	add	esi, 56					; 00000038H
	cmp	edi, DWORD PTR _optparamcount
	jl	$LN20@local_move
$LN71@local_move:

; 578  :       }
; 579  :     }
; 580  :     project_all(0,TEST_MOVE);  /* force vertices to constraints */

	push	0
	fstp	ST(0)
	push	0
	call	_project_all
	fld	QWORD PTR _scale$[ebp]
	add	esp, 8
$LN55@local_move:

; 581  :   }
; 582  : 
; 583  :   /* move by multiple of velocity */
; 584  :   if ( threadflag )

	cmp	DWORD PTR _threadflag, 0
	je	SHORT $LN16@local_move

; 585  :   { thread_scale = scale;
; 586  :     thread_launch(TH_MOVE_VERTICES,VERTEX);

	push	0
	fstp	QWORD PTR _thread_scale
	push	9
	call	_thread_launch
	add	esp, 8
	pop	edi
	pop	esi

; 607  :     }
; 608  :   }
; 609  :   
; 610  :   return;
; 611  : } /* end local_move_vertices() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@local_move:

; 587  :   }
; 588  :   else
; 589  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	$LN82@local_move
	push	ebx
$LN14@local_move:
	mov	edi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	ebx, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [ebx+edi]
	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv678[ebp+4], eax
	mov	eax, edx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv672[ebp], ebx
	je	$LN13@local_move

; 590  :   {
; 591  :     if ( get_vattr(v_id) & FIXED ) continue ;

	and	edx, 64					; 00000040H
	xor	eax, eax
	or	edx, eax
	jne	$LN13@local_move

; 592  :     velocity = get_velocity(v_id);

	mov	edx, DWORD PTR _web+104
	mov	esi, DWORD PTR _dymem
	mov	edi, DWORD PTR [edx+esi+1024]

; 593  :     x = get_coord(v_id);

	mov	esi, DWORD PTR [edx+esi+64]
	mov	eax, ecx
	add	edi, eax
	add	esi, eax

; 594  :     if ( get_vattr(v_id) & BOUNDARY )

	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	$LN8@local_move

; 595  :     {
; 596  :       struct boundary *boundary = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN38@local_move
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN39@local_move
$LN38@local_move:
	xor	eax, eax
$LN39@local_move:

; 597  :       int pcount = boundary->pcount;

	mov	edx, DWORD PTR [eax+40]

; 598  :       REAL *param = get_param(v_id);

	mov	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+esi+544]
	add	esi, ecx

; 599  : 
; 600  :       for ( i = 0 ; i < pcount ; i++ )

	xor	ecx, ecx
	mov	DWORD PTR _pcount$89418[ebp], edx
	cmp	edx, 4
	jl	SHORT $LC49@local_move

; 601  :         param[i] += scale*velocity[i];

	add	edx, -4					; fffffffcH
	mov	ebx, edi
	sub	ebx, esi
	shr	edx, 2
	mov	DWORD PTR tv1196[ebp], ebx
	inc	edx
	lea	ebx, DWORD PTR [edx*4]
	mov	DWORD PTR _i$[ebp], ebx
	mov	ebx, DWORD PTR tv1196[ebp]
	lea	ecx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR [esi+8]
$LN50@local_move:
	fld	QWORD PTR [ecx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	ecx, 32					; 00000020H
	dec	edx
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [ebx+eax-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx-40]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [ecx-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN50@local_move

; 597  :       int pcount = boundary->pcount;

	mov	edx, DWORD PTR _pcount$89418[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR tv672[ebp]
$LC49@local_move:

; 599  : 
; 600  :       for ( i = 0 ; i < pcount ; i++ )

	cmp	ecx, edx
	jge	$LN13@local_move
	sub	edi, esi
	lea	eax, DWORD PTR [esi+ecx*8]
	sub	edx, ecx
$LC7@local_move:

; 601  :         param[i] += scale*velocity[i];

	fld	QWORD PTR [eax+edi]
	add	eax, 8
	dec	edx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC7@local_move

; 602  :     }
; 603  :     else

	jmp	$LN13@local_move
$LN8@local_move:

; 604  :     {
; 605  :       for ( i = 0 ; i < dim ; i++ )

	xor	edx, edx
	cmp	DWORD PTR _dim$[ebp], 4
	jl	SHORT $LC52@local_move

; 606  :         x[i] += scale*velocity[i];

	mov	edx, edi
	sub	edx, esi
	mov	DWORD PTR tv1515[ebp], edx
	mov	edx, DWORD PTR _dim$[ebp]
	add	edx, -4					; fffffffcH
	shr	edx, 2
	inc	edx
	lea	ebx, DWORD PTR [edx*4]
	mov	DWORD PTR _i$[ebp], ebx
	mov	ebx, DWORD PTR tv1515[ebp]
	lea	ecx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR [esi+8]
$LN53@local_move:
	fld	QWORD PTR [ecx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	ecx, 32					; 00000020H
	dec	edx
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [ebx+eax-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx-40]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	ST(0)
	fmul	QWORD PTR [ecx-32]
	fadd	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN53@local_move

; 604  :     {
; 605  :       for ( i = 0 ; i < dim ; i++ )

	mov	ebx, DWORD PTR tv672[ebp]
	mov	edx, DWORD PTR _i$[ebp]
$LC52@local_move:
	cmp	edx, DWORD PTR _dim$[ebp]
	jge	SHORT $LN13@local_move
	mov	ecx, DWORD PTR _dim$[ebp]
	sub	edi, esi
	lea	eax, DWORD PTR [esi+edx*8]
	sub	ecx, edx
$LC3@local_move:

; 606  :         x[i] += scale*velocity[i];

	fld	QWORD PTR [eax+edi]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC3@local_move
$LN13@local_move:

; 587  :   }
; 588  :   else
; 589  :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	$LN14@local_move
	pop	ebx
$LN82@local_move:
	pop	edi
	fstp	ST(0)
	pop	esi

; 607  :     }
; 608  :   }
; 609  :   
; 610  :   return;
; 611  : } /* end local_move_vertices() */

	mov	esp, ebp
	pop	ebp
	ret	0
_local_move_vertices ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@NEFFFOLC@move_vertices?$CI?$CJ?3?5by?5scale?5factor@ ; `string'
PUBLIC	_move_vertices
EXTRN	_calc_energy:PROC
EXTRN	_calc_pressure:PROC
EXTRN	_partner_move:PROC
;	COMDAT ??_C@_0DB@NEFFFOLC@move_vertices?$CI?$CJ?3?5by?5scale?5factor@
CONST	SEGMENT
??_C@_0DB@NEFFFOLC@move_vertices?$CI?$CJ?3?5by?5scale?5factor@ DB 'move_v'
	DB	'ertices(): by scale factor times velocity', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _move_vertices
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_scale$ = 12						; size = 8
_move_vertices PROC					; COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp

; 521  :   if ( itdebug )

	cmp	DWORD PTR _itdebug, 0
	je	SHORT $LN4@move_verti

; 522  :     outstring("move_vertices(): by scale factor times velocity\n");

	push	OFFSET ??_C@_0DB@NEFFFOLC@move_vertices?$CI?$CJ?3?5by?5scale?5factor@
	call	_outstring
	add	esp, 4
$LN4@move_verti:

; 523  : 
; 524  :   #ifdef MPI_EVOLVER
; 525  :   if ( this_task != 0 ) return;
; 526  :   mpi_move_vertices(mode,scale);
; 527  :   #else
; 528  :   local_move_vertices(mode,scale);

	fld	QWORD PTR _scale$[ebp]
	push	esi
	mov	esi, DWORD PTR _mode$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	esi
	call	_local_move_vertices
	add	esp, 12					; 0000000cH

; 529  :   #endif
; 530  :   
; 531  :   if ( web.homothety )

	cmp	DWORD PTR _web+904, 0
	je	SHORT $LN3@move_verti

; 532  :      homothety();

	call	_homothety
$LN3@move_verti:

; 533  : 
; 534  :   global_timestamp++;

	inc	DWORD PTR _global_timestamp

; 535  : 
; 536  :   partner_move(); /* in case doing partners */

	call	_partner_move

; 537  : 
; 538  :   project_all(1, mode);

	push	esi
	push	1
	call	_project_all
	add	esp, 8

; 539  :  
; 540  : 
; 541  :   if ( fixed_constraint_flag || web.pressure_flag || web.pressflag ) 

	cmp	DWORD PTR _fixed_constraint_flag, 0
	pop	esi
	jne	SHORT $LN1@move_verti
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN1@move_verti
	cmp	DWORD PTR _web+844, 0
	je	SHORT $LN2@move_verti
$LN1@move_verti:

; 542  :      calc_pressure();

	call	_calc_pressure
$LN2@move_verti:

; 545  : 
; 546  : } // end move_vertices()

	pop	ebp

; 543  : 
; 544  :   calc_energy();  /* energy after motion */

	jmp	_calc_energy
_move_vertices ENDP
_TEXT	ENDS
PUBLIC	__real@4000000000000000
PUBLIC	_runge_kutta
EXTRN	_saved:BYTE
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _runge_kutta
_TEXT	SEGMENT
tv548 = -24						; size = 4
_k4$ = -20						; size = 4
_k3$ = -16						; size = 4
_k2$ = -12						; size = 4
_k1$ = -8						; size = 4
_i$ = -4						; size = 4
_runge_kutta PROC					; COMDAT

; 1502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1503 :   REAL **k1,**k2,**k3, **k4;  /* saved motions */
; 1504 :   int i;
; 1505 :   vertex_id v_id;
; 1506 : 
; 1507 :   k1 = dmatrix(0,web.skel[VERTEX].max_ord,0,SDIM-1);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _web+68
	push	ebx
	push	esi
	push	edi
	push	1507					; 000005e3H
	push	OFFSET ??_C@_09MIIJPAGP@ITERATE?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	ecx
	push	0
	call	_kb_dmatrix

; 1508 :   k2 = dmatrix(0,web.skel[VERTEX].max_ord,0,SDIM-1);

	mov	edx, DWORD PTR _web+616
	push	1508					; 000005e4H
	push	OFFSET ??_C@_09MIIJPAGP@ITERATE?4C?$AA@
	dec	edx
	push	edx
	mov	DWORD PTR _k1$[ebp], eax
	mov	eax, DWORD PTR _web+68
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 1509 :   k3 = dmatrix(0,web.skel[VERTEX].max_ord,0,SDIM-1);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _web+68
	push	1509					; 000005e5H
	push	OFFSET ??_C@_09MIIJPAGP@ITERATE?4C?$AA@
	dec	ecx
	push	ecx
	push	0
	push	edx
	push	0
	mov	DWORD PTR _k2$[ebp], eax
	call	_kb_dmatrix

; 1510 :   k4 = dmatrix(0,web.skel[VERTEX].max_ord,0,SDIM-1);

	mov	ecx, DWORD PTR _web+68
	add	esp, 72					; 00000048H
	push	1510					; 000005e6H
	mov	DWORD PTR _k3$[ebp], eax
	mov	eax, DWORD PTR _web+616
	push	OFFSET ??_C@_09MIIJPAGP@ITERATE?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	ecx
	push	0
	call	_kb_dmatrix
	mov	DWORD PTR _k4$[ebp], eax

; 1511 : 
; 1512 :   /* save first motion */
; 1513 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	add	esp, 24					; 00000018H
	and	ecx, 1
	je	SHORT $LN75@runge_kutt
	mov	edi, DWORD PTR _web+12
$LL40@runge_kutt:
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN39@runge_kutt

; 1514 :      { int k = loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN43@runge_kutt
	mov	eax, ebx
	jmp	SHORT $LN44@runge_kutt
$LN43@runge_kutt:
	or	eax, -1
$LN44@runge_kutt:

; 1515 :         REAL *f = get_force(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [ecx+edx+784]

; 1516 :         for ( i = 0 ; i < SDIM ; i++ ) k1[k][i] = f[i];

	xor	ecx, ecx
	add	edx, esi
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN39@runge_kutt
	mov	esi, DWORD PTR _k1$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	sub	edx, eax
	npad	2
$LL35@runge_kutt:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL35@runge_kutt
	mov	edi, DWORD PTR _web+12
$LN39@runge_kutt:

; 1511 : 
; 1512 :   /* save first motion */
; 1513 :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [edx]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	SHORT $LL40@runge_kutt
$LN75@runge_kutt:

; 1517 :      }
; 1518 : 
; 1519 :   /* second motion */
; 1520 :   web.scale /= 2;

	fld	QWORD PTR _web+1512

; 1521 :   move_vertices(ACTUAL_MOVE,web.scale);

	sub	esp, 8
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR _web+1512
	fstp	QWORD PTR [esp]
	push	1
	call	_move_vertices

; 1522 :   calc_all_grads(CALC_FORCE|CALC_VOLGRADS);

	push	3
	call	_calc_all_grads

; 1523 :   volume_restore(1.0,ACTUAL_MOVE);

	fld1
	add	esp, 16					; 00000010H
	push	1
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_volume_restore

; 1524 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	add	esp, 12					; 0000000cH
	and	ecx, 1
	je	$LN30@runge_kutt
	mov	edi, DWORD PTR _web+12
	npad	6
$LL32@runge_kutt:
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN31@runge_kutt

; 1525 :      { int k = loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN45@runge_kutt
	mov	eax, ebx
	jmp	SHORT $LN46@runge_kutt
$LN45@runge_kutt:
	or	eax, -1
$LN46@runge_kutt:

; 1526 :         REAL *f = get_force(v_id);

	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+ecx+784]

; 1527 :         for ( i = 0 ; i < SDIM ; i++ ) k2[k][i] = f[i];

	xor	ecx, ecx
	add	edx, esi
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN31@runge_kutt
	mov	esi, DWORD PTR _k2$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	sub	edx, eax
	npad	7
$LL27@runge_kutt:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL27@runge_kutt
	mov	edi, DWORD PTR _web+12
$LN31@runge_kutt:

; 1524 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	SHORT $LL32@runge_kutt
$LN30@runge_kutt:

; 1528 :      }
; 1529 : 
; 1530 :   /* third motion */
; 1531 :   restore_coords(&saved,SAVE_IN_ATTR);

	push	1
	push	OFFSET _saved
	call	_restore_coords

; 1532 :   move_vertices(ACTUAL_MOVE,web.scale);

	fld	QWORD PTR _web+1512
	fstp	QWORD PTR [esp]
	push	1
	call	_move_vertices

; 1533 :   calc_all_grads(CALC_FORCE|CALC_VOLGRADS);

	push	3
	call	_calc_all_grads

; 1534 :   volume_restore(1.0,ACTUAL_MOVE);

	fld1
	add	esp, 16					; 00000010H
	push	1
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_volume_restore

; 1535 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	add	esp, 12					; 0000000cH
	and	ecx, 1
	je	SHORT $LN22@runge_kutt
	mov	edi, DWORD PTR _web+12
$LL24@runge_kutt:
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN23@runge_kutt

; 1536 :   { int k = loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN47@runge_kutt
	mov	eax, ebx
	jmp	SHORT $LN48@runge_kutt
$LN47@runge_kutt:
	or	eax, -1
$LN48@runge_kutt:

; 1537 :     REAL *f = get_force(v_id);

	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+ecx+784]

; 1538 :     for ( i = 0 ; i < SDIM ; i++ ) k3[k][i] = f[i];

	xor	ecx, ecx
	add	edx, esi
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN23@runge_kutt
	mov	esi, DWORD PTR _k3$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	sub	edx, eax
	npad	4
$LL19@runge_kutt:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL19@runge_kutt
	mov	edi, DWORD PTR _web+12
$LN23@runge_kutt:

; 1535 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	SHORT $LL24@runge_kutt
$LN22@runge_kutt:

; 1539 :   }
; 1540 : 
; 1541 :   /* fourth motion */
; 1542 :   restore_coords(&saved,SAVE_IN_ATTR);

	push	1
	push	OFFSET _saved
	call	_restore_coords

; 1543 :   web.scale *= 2;

	fld	QWORD PTR _web+1512
	fadd	ST(0), ST(0)
	fst	QWORD PTR _web+1512

; 1544 :   move_vertices(ACTUAL_MOVE,web.scale);

	fstp	QWORD PTR [esp]
	push	1
	call	_move_vertices

; 1545 :   calc_all_grads(CALC_FORCE|CALC_VOLGRADS);

	push	3
	call	_calc_all_grads

; 1546 :   volume_restore(1.0,ACTUAL_MOVE);

	fld1
	add	esp, 16					; 00000010H
	push	1
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_volume_restore

; 1547 : 
; 1548 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ebx, DWORD PTR _web+616
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	add	esp, 12					; 0000000cH
	and	ecx, 1
	je	$LN14@runge_kutt
	npad	1
$LL16@runge_kutt:
	mov	edx, DWORD PTR _web+12
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN15@runge_kutt

; 1549 :   { int k = loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN49@runge_kutt
	mov	eax, edi
	jmp	SHORT $LN50@runge_kutt
$LN49@runge_kutt:
	or	eax, -1
$LN50@runge_kutt:

; 1550 :     REAL *f = get_force(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [ecx+edx+784]
	add	edx, esi

; 1551 :     for ( i = 0 ; i < SDIM ; i++ ) k4[k][i] = f[i];

	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN15@runge_kutt
	mov	esi, DWORD PTR _k4$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	sub	edx, eax
	npad	5
$LL11@runge_kutt:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	mov	ebx, DWORD PTR _web+616
	add	eax, 8
	cmp	ecx, ebx
	jl	SHORT $LL11@runge_kutt
$LN15@runge_kutt:

; 1547 : 
; 1548 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	SHORT $LL16@runge_kutt
$LN14@runge_kutt:

; 1552 :   }
; 1553 : 
; 1554 :   /* runge-kutta combination */
; 1555 :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	je	$LN6@runge_kutt
	fld	QWORD PTR __real@4018000000000000
	fld	QWORD PTR __real@4000000000000000
$LN76@runge_kutt:
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	mov	DWORD PTR tv548[ebp], edx
	je	$LN7@runge_kutt

; 1556 :      { int k = loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN51@runge_kutt
	mov	ecx, edx
	jmp	SHORT $LN52@runge_kutt
$LN51@runge_kutt:
	or	ecx, -1
$LN52@runge_kutt:

; 1557 :         REAL *f = get_force(v_id);

	mov	eax, DWORD PTR _web+104
	mov	edi, DWORD PTR _dymem
	mov	edi, DWORD PTR [eax+edi+784]
	add	edi, esi

; 1558 :         for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	ebx, ebx
	jle	SHORT $LN7@runge_kutt
	mov	edx, DWORD PTR _k1$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _k2$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	esi, DWORD PTR _k3$[ebp]
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	ebx, DWORD PTR _k4$[ebp]
	mov	ecx, DWORD PTR [ebx+ecx*4]
	sub	edx, eax
	sub	esi, eax
	sub	ecx, eax
	sub	edi, eax
$LN74@runge_kutt:

; 1559 :           f[i] = (k1[k][i] + 2*k2[k][i] + 2*k3[k][i] + k4[k][i])/6;

	fld	QWORD PTR [edx+eax]
	inc	DWORD PTR _i$[ebp]
	fmul	ST(0), ST(1)
	add	eax, 8
	fadd	QWORD PTR [eax-8]
	fld	QWORD PTR [esi+eax-8]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fadd	QWORD PTR [ecx+eax-8]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [edi+eax-8]
	mov	ebx, DWORD PTR _web+616
	cmp	DWORD PTR _i$[ebp], ebx
	jl	SHORT $LN74@runge_kutt

; 1558 :         for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR tv548[ebp]
$LN7@runge_kutt:

; 1552 :   }
; 1553 : 
; 1554 :   /* runge-kutta combination */
; 1555 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LN76@runge_kutt
	fstp	ST(0)
	fstp	ST(0)
$LN6@runge_kutt:

; 1560 :      }
; 1561 :   restore_coords(&saved,SAVE_IN_ATTR);

	push	1
	push	OFFSET _saved
	call	_restore_coords

; 1562 : 
; 1563 :   free_matrix(k1);

	mov	edx, DWORD PTR _k1$[ebp]
	push	edx
	call	_free_matrix

; 1564 :   free_matrix(k2);

	mov	eax, DWORD PTR _k2$[ebp]
	push	eax
	call	_free_matrix

; 1565 :   free_matrix(k3);

	mov	ecx, DWORD PTR _k3$[ebp]
	push	ecx
	call	_free_matrix

; 1566 :   free_matrix(k4);

	mov	edx, DWORD PTR _k4$[ebp]
	push	edx
	call	_free_matrix
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 1567 : } /* end runge_kutta() */

	mov	esp, ebp
	pop	ebp
	ret	0
_runge_kutta ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DM@EPAJDMFA@Motion?5would?5cause?5infinite?5ener@ ; `string'
PUBLIC	??_C@_0DA@CLPAALJF@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@ ; `string'
PUBLIC	??_C@_0CD@LLNDMBBM@Actual?5energy?5change?5?5?5?3?5?$CF?$CD20?415@ ; `string'
PUBLIC	??_C@_0CD@FHDGCLDO@Estimated?5energy?5change?3?5?$CF?$CD20?415@ ; `string'
PUBLIC	??_C@_0DA@JPFNKEJN@Max?5normal?5change?3?5?$CFf?4?5?5Restorin@ ; `string'
PUBLIC	??_C@_0DM@EGFBFKCD@Motion?5would?5have?5increased?5ener@ ; `string'
PUBLIC	??_C@_0BB@BGMGHNEP@Final?5scale?3?5?$CFg?6?$AA@	; `string'
PUBLIC	??_C@_0CJ@MCAKEKD@Infinite?5energy?4?5Restoring?5coord@ ; `string'
PUBLIC	??_C@_0BM@ECNBLAOK@scale1?5?$CFg?5energy1?5?$CF20?415g?5?6?$AA@ ; `string'
PUBLIC	__real@3d719799812dea11
PUBLIC	??_C@_0BJ@LGLILMBM@Halving?5scale?0?5scale?5?$CFg?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@EDKKFLCH@scale2?5?$CFg?5energy2?5?$CF20?415g?5?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@KFFBDKNH@Doubling?5scale?0?5scale?5?$CFg?6?$AA@ ; `string'
PUBLIC	??_C@_0CG@FPBJNCOJ@0th?5move?3?6scale1?5?$CFg?5energy1?5?$CF20?4@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0CI@DEOKHBKC@first?5move?3?6scale1?5?$CFg?5energy1?5?$CF2@ ; `string'
PUBLIC	__real@47d2ced32a16a1b1
PUBLIC	__real@7e37e43c8800759c
PUBLIC	__real@fe37e43c8800759c
PUBLIC	??_C@_0BG@CJFALBDG@First?5move?0?5scale?5?$CFg?6?$AA@ ; `string'
PUBLIC	__real@3eb0c6f7a0b5ed8d
PUBLIC	??_C@_0DA@GGIOIDMO@No?5vertices?4?5Did?5you?5forget?5to?5l@ ; `string'
PUBLIC	_iterate
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	_breakflag:DWORD
EXTRN	_count_fixed_vol:PROC
EXTRN	_update_display:PROC
EXTRN	_vgrad_end:PROC
EXTRN	_quiet_go_flag:DWORD
EXTRN	_gocount:DWORD
EXTRN	_areaname:DWORD
EXTRN	_estimate_flag:DWORD
EXTRN	_normal_change_check:PROC
EXTRN	_total_time:QWORD
EXTRN	_check_increase_flag:DWORD
EXTRN	_autopop_cleanup:PROC
EXTRN	_autochop_chop:PROC
EXTRN	_autopop_pop:PROC
EXTRN	_autochop_count:DWORD
EXTRN	_autopop_count:DWORD
EXTRN	_autopop_detect:PROC
EXTRN	_autochop_flag:DWORD
EXTRN	_autopop_flag:DWORD
EXTRN	_runge_kutta_flag:DWORD
EXTRN	_show_volumes:PROC
EXTRN	__imp__MsgWaitForMultipleObjects@20:PROC
EXTRN	_graphmutex:DWORD
EXTRN	_locking_thread:DWORD
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	_conj_grad_flag:DWORD
EXTRN	_begin_normal_motion:PROC
EXTRN	_diffuse:PROC
EXTRN	_iterate_flag:DWORD
;	COMDAT ??_C@_0DM@EPAJDMFA@Motion?5would?5cause?5infinite?5ener@
CONST	SEGMENT
??_C@_0DM@EPAJDMFA@Motion?5would?5cause?5infinite?5ener@ DB 'Motion would'
	DB	' cause infinite energy. Restoring coordinates.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CLPAALJF@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@
CONST	SEGMENT
??_C@_0DA@CLPAALJF@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@ DB '%'
	DB	'3d. %s: %#17.15g energy: %#17.15g  scale: %#g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LLNDMBBM@Actual?5energy?5change?5?5?5?3?5?$CF?$CD20?415@
CONST	SEGMENT
??_C@_0CD@LLNDMBBM@Actual?5energy?5change?5?5?5?3?5?$CF?$CD20?415@ DB 'Ac'
	DB	'tual energy change   : %#20.15g', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FHDGCLDO@Estimated?5energy?5change?3?5?$CF?$CD20?415@
CONST	SEGMENT
??_C@_0CD@FHDGCLDO@Estimated?5energy?5change?3?5?$CF?$CD20?415@ DB 'Estim'
	DB	'ated energy change: %#20.15g', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JPFNKEJN@Max?5normal?5change?3?5?$CFf?4?5?5Restorin@
CONST	SEGMENT
??_C@_0DA@JPFNKEJN@Max?5normal?5change?3?5?$CFf?4?5?5Restorin@ DB 'Max no'
	DB	'rmal change: %f.  Restoring coordinates.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EGFBFKCD@Motion?5would?5have?5increased?5ener@
CONST	SEGMENT
??_C@_0DM@EGFBFKCD@Motion?5would?5have?5increased?5ener@ DB 'Motion would'
	DB	' have increased energy. Restoring coordinates.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BGMGHNEP@Final?5scale?3?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BB@BGMGHNEP@Final?5scale?3?5?$CFg?6?$AA@ DB 'Final scale: %g', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MCAKEKD@Infinite?5energy?4?5Restoring?5coord@
CONST	SEGMENT
??_C@_0CJ@MCAKEKD@Infinite?5energy?4?5Restoring?5coord@ DB 'Infinite ener'
	DB	'gy. Restoring coordinates.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@ECNBLAOK@scale1?5?$CFg?5energy1?5?$CF20?415g?5?6?$AA@
CONST	SEGMENT
??_C@_0BM@ECNBLAOK@scale1?5?$CFg?5energy1?5?$CF20?415g?5?6?$AA@ DB 'scale'
	DB	'1 %g energy1 %20.15g ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@3d719799812dea11
CONST	SEGMENT
__real@3d719799812dea11 DQ 03d719799812dea11r	; 1e-012
CONST	ENDS
;	COMDAT ??_C@_0BJ@LGLILMBM@Halving?5scale?0?5scale?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BJ@LGLILMBM@Halving?5scale?0?5scale?5?$CFg?6?$AA@ DB 'Halving scal'
	DB	'e, scale %g', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EDKKFLCH@scale2?5?$CFg?5energy2?5?$CF20?415g?5?6?$AA@
CONST	SEGMENT
??_C@_0BM@EDKKFLCH@scale2?5?$CFg?5energy2?5?$CF20?415g?5?6?$AA@ DB 'scale'
	DB	'2 %g energy2 %20.15g ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KFFBDKNH@Doubling?5scale?0?5scale?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BK@KFFBDKNH@Doubling?5scale?0?5scale?5?$CFg?6?$AA@ DB 'Doubling sc'
	DB	'ale, scale %g', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FPBJNCOJ@0th?5move?3?6scale1?5?$CFg?5energy1?5?$CF20?4@
CONST	SEGMENT
??_C@_0CG@FPBJNCOJ@0th?5move?3?6scale1?5?$CFg?5energy1?5?$CF20?4@ DB '0th'
	DB	' move:', 0aH, 'scale1 %g energy1 %20.15g ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DEOKHBKC@first?5move?3?6scale1?5?$CFg?5energy1?5?$CF2@
CONST	SEGMENT
??_C@_0CI@DEOKHBKC@first?5move?3?6scale1?5?$CFg?5energy1?5?$CF2@ DB 'firs'
	DB	't move:', 0aH, 'scale1 %g energy1 %20.15g ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@47d2ced32a16a1b1
CONST	SEGMENT
__real@47d2ced32a16a1b1 DQ 047d2ced32a16a1b1r	; 1e+038
CONST	ENDS
;	COMDAT __real@7e37e43c8800759c
CONST	SEGMENT
__real@7e37e43c8800759c DQ 07e37e43c8800759cr	; 1e+300
CONST	ENDS
;	COMDAT __real@fe37e43c8800759c
CONST	SEGMENT
__real@fe37e43c8800759c DQ 0fe37e43c8800759cr	; -1e+300
CONST	ENDS
;	COMDAT ??_C@_0BG@CJFALBDG@First?5move?0?5scale?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BG@CJFALBDG@First?5move?0?5scale?5?$CFg?6?$AA@ DB 'First move, sca'
	DB	'le %g', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@3eb0c6f7a0b5ed8d
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-006
CONST	ENDS
;	COMDAT ??_C@_0DA@GGIOIDMO@No?5vertices?4?5Did?5you?5forget?5to?5l@
CONST	SEGMENT
??_C@_0DA@GGIOIDMO@No?5vertices?4?5Did?5you?5forget?5to?5l@ DB 'No vertic'
	DB	'es. Did you forget to load a surface?', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _iterate
_TEXT	SEGMENT
_old_energy$ = -64					; size = 8
_tempscale$89051 = -56					; size = 8
_scale2$ = -48						; size = 8
_scale1$ = -40						; size = 8
_energy2$ = -32						; size = 8
_energy0$ = -24						; size = 8
_energy1$ = -16						; size = 8
_did_graphlock_here$89047 = -8				; size = 4
_old_flag$ = -4						; size = 4
_iterate PROC						; COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 26   :   REAL energy0,energy1,energy2=0.0;

	fldz

; 27   :   int seekcount = 0;  /* to prevent infinite loop */
; 28   :   REAL denom;  /* denominator of interpolation expression */
; 29   :   REAL scale0,scale1=0.0,scale2=0.0;  /* for interpolation */
; 30   :   int old_flag = iterate_flag;

	mov	eax, DWORD PTR _iterate_flag
	fst	QWORD PTR _energy2$[ebp]
	push	ebx
	fst	QWORD PTR _scale1$[ebp]
	push	edi
	fstp	QWORD PTR _scale2$[ebp]
	xor	ebx, ebx

; 31   :   REAL old_energy = web.total_energy; /* for estimate */

	fld	QWORD PTR _web+1240
	xor	edi, edi
	fstp	QWORD PTR _old_energy$[ebp]
	mov	DWORD PTR _old_flag$[ebp], eax

; 32   : 
; 33   : #ifndef MPI_EVOLVER
; 34   :   if ( web.skel[VERTEX].count == 0 )

	cmp	DWORD PTR _web+64, ebx
	jne	SHORT $LN73@iterate

; 35   :   { kb_error(1051,"No vertices. Did you forget to load a surface?\n",WARNING);

	push	2
	push	OFFSET ??_C@_0DA@GGIOIDMO@No?5vertices?4?5Did?5you?5forget?5to?5l@
	push	1051					; 0000041bH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx

; 310  : }  /* end iterate() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@iterate:

; 36   :     return;
; 37   :   }
; 38   : #endif
; 39   : 
; 40   :   iterate_flag = 1;  /* for interrupt handler */

	mov	DWORD PTR _iterate_flag, 1

; 41   : 
; 42   :   if ( web.diffusion_flag ) 

	cmp	DWORD PTR _web+780, ebx
	je	SHORT $LN72@iterate

; 43   :      diffuse();

	call	_diffuse
$LN72@iterate:

; 44   :   
; 45   :   energy0 = web.total_energy;

	fld	QWORD PTR _web+1240
	fstp	QWORD PTR _energy0$[ebp]

; 46   :   if ( check_pinning_flag ) check_pinning();

	cmp	DWORD PTR _check_pinning_flag, ebx
	je	SHORT $LN71@iterate
	call	_check_pinning
$LN71@iterate:

; 47   :   if ( normal_motion_flag ) begin_normal_motion();

	cmp	DWORD PTR _normal_motion_flag, ebx
	je	SHORT $LN70@iterate
	call	_begin_normal_motion
$LN70@iterate:

; 48   :   calc_all_grads(CALC_FORCE|CALC_VOLGRADS);

	push	3
	call	_calc_all_grads

; 49   :   volgrads_changed_flag = 0;
; 50   : 
; 51   :   save_coords(&saved,SAVE_IN_ATTR); /* in case of disaster */

	push	1
	push	OFFSET _saved
	mov	DWORD PTR _volgrads_changed_flag, ebx
	call	_save_coords
	add	esp, 12					; 0000000cH

; 52   :   if ( conj_grad_flag )

	cmp	DWORD PTR _conj_grad_flag, ebx
	je	SHORT $LN69@iterate

; 53   :   { cg_calc_gamma(); /* find adjustment factor  */

	call	_cg_calc_gamma

; 54   :     cg_direction();  /* fix up motion direction */

	call	_cg_direction
$LN69@iterate:

; 55   :   }
; 56   : 
; 57   :   ENTER_GRAPH_MUTEX;

	push	esi
	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN68@iterate
	push	ebx
	push	100000					; 000186a0H
	push	ebx
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89047[ebp], 1
	jmp	SHORT $LN67@iterate
$LN68@iterate:
	mov	DWORD PTR _did_graphlock_here$89047[ebp], ebx
$LN67@iterate:

; 58   : 
; 59   :   if ( !web.motion_flag )  /* want to seek minimum energy along gradient */

	cmp	DWORD PTR _web+852, ebx
	jne	$LN66@iterate

; 60   :   { REAL tempscale;
; 61   :      
; 62   :     if ( web.scale > web.maxscale ) web.scale = web.maxscale;

	fld	QWORD PTR _web+1528
	fld	QWORD PTR _web+1512
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN65@iterate
	fstp	ST(0)
	fld	ST(0)
$LN65@iterate:

; 63   :     tempscale = web.scale <= 0.0 ? web.maxscale*1e-6 : web.scale;

	fldz
	fcom	ST(1)
	fnstsw	ax
	fld	QWORD PTR __real@3eb0c6f7a0b5ed8d
	test	ah, 1
	jne	SHORT $LN76@iterate
	fstp	ST(2)
	fld	ST(2)
	fmul	ST(0), ST(2)
	jmp	SHORT $LN208@iterate
$LN76@iterate:
	fxch	ST(2)
$LN208@iterate:
	fst	QWORD PTR _tempscale$89051[ebp]

; 64   : 
; 65   :     if ( tempscale <= 0.0  ) web.scale = web.maxscale*1e-6;

	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jp	SHORT $LN104@iterate
	fstp	ST(0)
	fmulp	ST(1), ST(0)
	jmp	SHORT $LN209@iterate
$LN104@iterate:
	fstp	ST(2)
	fstp	ST(0)
$LN209@iterate:

; 66   :     else web.scale = tempscale;

	fst	QWORD PTR _web+1512

; 67   :     if ( itdebug ) printf("First move, scale %g\n",(double)web.scale);

	cmp	DWORD PTR _itdebug, ebx
	je	SHORT $LN62@iterate
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BG@CJFALBDG@First?5move?0?5scale?5?$CFg?6?$AA@
	call	_printf
	fld	QWORD PTR _web+1512
	add	esp, 12					; 0000000cH
$LN62@iterate:

; 68   :     move_vertices(TEST_MOVE,web.scale);  /* moving by current scale */

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ebx
	call	_move_vertices

; 69   :     energy1 = web.total_energy;

	fld	QWORD PTR _web+1240
	fst	QWORD PTR _energy1$[ebp]
	add	esp, 12					; 0000000cH

; 70   :     if ( !is_finite(energy1) ) energy1 = MAXDOUBLE;

	fld	QWORD PTR __real@fe37e43c8800759c
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN113@iterate
	fld	QWORD PTR __real@7e37e43c8800759c
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN61@iterate
$LN113@iterate:
	fstp	ST(0)
	fld	QWORD PTR __real@47d2ced32a16a1b1
	fst	QWORD PTR _energy1$[ebp]
$LN61@iterate:

; 71   :     scale1 = web.scale;

	fld	QWORD PTR _web+1512

; 72   :     if ( itdebug )

	mov	esi, 10					; 0000000aH
	fst	QWORD PTR _scale1$[ebp]
	cmp	DWORD PTR _itdebug, ebx
	je	SHORT $LN116@iterate

; 73   :     { printf("first move:\nscale1 %g energy1 %20.15g \n",
; 74   :           (DOUBLE)scale1,(DOUBLE)energy1);

	sub	esp, 16					; 00000010H
	fxch	ST(1)
	fstp	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CI@DEOKHBKC@first?5move?3?6scale1?5?$CFg?5energy1?5?$CF2@
	call	_printf
	add	esp, 20					; 00000014H

; 75   :       if ( web.skel[BODY].count < 10  ) show_volumes();

	cmp	DWORD PTR _web+400, esi
	jge	SHORT $LN58@iterate
	call	_show_volumes
$LN58@iterate:

; 76   :       printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	add	esp, 4
	jmp	SHORT $LN59@iterate
$LN116@iterate:
	fstp	ST(1)
	fstp	ST(0)
$LN59@iterate:

; 77   :     }
; 78   : 
; 79   :     restore_coords(&saved,SAVE_IN_ATTR);

	push	1
	push	OFFSET _saved
	call	_restore_coords
	add	esp, 8

; 80   :     if ( volgrads_changed_flag )

	cmp	DWORD PTR _volgrads_changed_flag, ebx
	je	SHORT $LN57@iterate

; 81   :     {  calc_all_grads(CALC_VOLGRADS);

	push	2
	call	_calc_all_grads
	add	esp, 4

; 82   :        calc_leftside();

	call	_calc_leftside

; 83   :        volgrads_changed_flag = 0;

	mov	DWORD PTR _volgrads_changed_flag, ebx
$LN57@iterate:

; 84   :     }
; 85   :     web.scale = 0.0; /* to do restoring force */

	fldz

; 86   :     move_vertices(TEST_MOVE,web.scale);  /* moving by current scale */

	sub	esp, 8
	fst	QWORD PTR _web+1512
	fstp	QWORD PTR [esp]
	push	ebx
	call	_move_vertices

; 87   :     energy0 = web.total_energy;

	fld	QWORD PTR _web+1240
	add	esp, 12					; 0000000cH
	fst	QWORD PTR _energy0$[ebp]

; 88   :     if ( itdebug )

	cmp	DWORD PTR _itdebug, ebx
	je	SHORT $LN56@iterate

; 89   :     { printf("0th move:\nscale1 %g energy1 %20.15g \n",0.0,(DOUBLE)energy0);

	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fldz
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CG@FPBJNCOJ@0th?5move?3?6scale1?5?$CFg?5energy1?5?$CF20?4@
	call	_printf
	add	esp, 20					; 00000014H

; 90   :       if ( web.skel[BODY].count < 10 )

	cmp	DWORD PTR _web+400, esi
	jge	SHORT $LN55@iterate

; 91   :         show_volumes();

	call	_show_volumes
$LN55@iterate:

; 92   :       printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	fld	QWORD PTR _energy0$[ebp]
	add	esp, 4
$LN56@iterate:

; 93   :     }
; 94   : 
; 95   :     if ( !is_finite(energy0) )

	fld	QWORD PTR __real@fe37e43c8800759c
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	$LN122@iterate
	fcomp	QWORD PTR __real@7e37e43c8800759c
	fnstsw	ax
	test	ah, 5
	jp	$LN53@iterate

; 98   :       }
; 99   :     scale0 = 0.0;
; 100  :     restore_coords(&saved,SAVE_IN_ATTR); 

	push	1
	push	OFFSET _saved
	call	_restore_coords
	add	esp, 8

; 101  :     if ( volgrads_changed_flag )

	cmp	DWORD PTR _volgrads_changed_flag, ebx
	je	SHORT $LN52@iterate

; 102  :     {  calc_all_grads(CALC_VOLGRADS);

	push	2
	call	_calc_all_grads
	add	esp, 4

; 103  :        calc_leftside();

	call	_calc_leftside

; 104  :        volgrads_changed_flag = 0;

	mov	DWORD PTR _volgrads_changed_flag, ebx
$LN52@iterate:

; 105  :     }
; 106  : 
; 107  :     web.scale = tempscale;

	fld	QWORD PTR _tempscale$89051[ebp]

; 108  :  
; 109  :     if ( energy1 < energy0 )

	fld	QWORD PTR _energy0$[ebp]
	fld	QWORD PTR _energy1$[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	$LN39@iterate
$LN210@iterate:
	fstp	ST(0)

; 110  :     { do
; 111  :       {
; 112  :         web.scale *= 2;

	fadd	ST(0), ST(0)
	fst	QWORD PTR _web+1512

; 113  :         if ( itdebug ) printf("Doubling scale, scale %g\n",(double)web.scale);

	cmp	DWORD PTR _itdebug, ebx
	je	SHORT $LN47@iterate
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BK@KFFBDKNH@Doubling?5scale?0?5scale?5?$CFg?6?$AA@
	call	_printf
	fld	QWORD PTR _web+1512
	add	esp, 12					; 0000000cH
$LN47@iterate:

; 114  :         move_vertices(TEST_MOVE,web.scale);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ebx
	call	_move_vertices

; 115  :         energy2 = web.total_energy;

	fld	QWORD PTR _web+1240
	fst	QWORD PTR _energy2$[ebp]
	add	esp, 12					; 0000000cH

; 116  :         scale2 = web.scale;

	fld	QWORD PTR _web+1512
	fst	QWORD PTR _scale2$[ebp]

; 117  :         if ( itdebug )

	cmp	DWORD PTR _itdebug, ebx
	je	SHORT $LN130@iterate

; 118  :         { printf("scale2 %g energy2 %20.15g \n",(DOUBLE)scale2,(DOUBLE)energy2);

	sub	esp, 16					; 00000010H
	fxch	ST(1)
	fstp	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BM@EDKKFLCH@scale2?5?$CFg?5energy2?5?$CF20?415g?5?6?$AA@
	call	_printf
	add	esp, 20					; 00000014H

; 119  :           if ( web.skel[BODY].count < 10 ) show_volumes();

	cmp	DWORD PTR _web+400, esi
	jge	SHORT $LN45@iterate
	call	_show_volumes
$LN45@iterate:

; 120  :           printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	add	esp, 4
	jmp	SHORT $LN46@iterate
$LN130@iterate:
	fstp	ST(1)
	fstp	ST(0)
$LN46@iterate:

; 121  :         }
; 122  :         restore_coords(&saved,SAVE_IN_ATTR);

	push	1
	push	OFFSET _saved
	call	_restore_coords
	add	esp, 8

; 123  :         if ( volgrads_changed_flag )

	cmp	DWORD PTR _volgrads_changed_flag, ebx
	je	SHORT $LN92@iterate

; 124  :         {  calc_all_grads(CALC_VOLGRADS);

	push	2
	call	_calc_all_grads
	add	esp, 4

; 125  :            calc_leftside();

	call	_calc_leftside

; 126  :            volgrads_changed_flag = 0;

	mov	DWORD PTR _volgrads_changed_flag, ebx
$LN92@iterate:

; 127  :         }
; 128  :         if ( !is_finite(energy2) ) 

	fld	QWORD PTR __real@fe37e43c8800759c
	fld	QWORD PTR _energy2$[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jne	$LN176@iterate
	fld	QWORD PTR __real@7e37e43c8800759c
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN176@iterate

; 130  :         if ( energy2 > energy1 ) 

	fld	QWORD PTR _energy1$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN81@iterate
	fstp	ST(0)

; 132  :         energy1 = energy2;  scale1 = scale2;

	fld	ST(0)
	fst	QWORD PTR _energy1$[ebp]
	fld	QWORD PTR _scale2$[ebp]
	fstp	QWORD PTR _scale1$[ebp]

; 133  :       }
; 134  :       while ( (web.scale < web.maxscale)  /* || conj_grad_flag */ );

	fld	QWORD PTR _web+1528
	fld	QWORD PTR _web+1512
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN86@iterate
	fstp	ST(2)
	jmp	$LN210@iterate
$LN81@iterate:

; 131  :            { web.scale = web.scale/2; break; }

	fld	QWORD PTR _web+1512
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR _web+1512
$LN86@iterate:

; 135  :     }
; 136  :     else /* have to come down in scale */

	fldz
	fxch	ST(1)
$LN40@iterate:

; 165  :     }
; 166  : 
; 167  :     if ( web.scale > web.maxscale ) 

	fld	QWORD PTR _web+1528
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	$LN153@iterate
	fstp	ST(1)
	fstp	ST(3)
	fstp	ST(0)
	fstp	ST(0)

; 168  :       web.scale = web.maxscale;

	fst	QWORD PTR _web+1512
	jmp	$have_scale$89091
$LN176@iterate:

; 127  :         }
; 128  :         if ( !is_finite(energy2) ) 

	fstp	ST(0)

; 129  :            { web.scale /= 2; goto have_scale;} /* use finite motion */ 

	fld	QWORD PTR _web+1512
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR _web+1512
	jmp	$have_scale$89091
$LN189@iterate:

; 161  :          }
; 162  :       }
; 163  :       while ( energy1 > energy0 );

	fxch	ST(1)
$LN39@iterate:

; 137  :     {
; 138  :       do
; 139  :       { 
; 140  :          seekcount++;

	inc	edi

; 141  :          if ( seekcount > 20 ) /* looks like energy won't decrease */

	cmp	edi, 20					; 00000014H
	jg	$LN133@iterate

; 143  :          energy2 = energy1; scale2 = scale1;

	fld	ST(0)
	fst	QWORD PTR _energy2$[ebp]
	fld	QWORD PTR _scale1$[ebp]
	fstp	QWORD PTR _scale2$[ebp]

; 144  :          web.scale /= 2;

	fxch	ST(2)
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR _web+1512

; 145  :          if ( itdebug ) printf("Halving scale, scale %g\n",(double)web.scale);

	cmp	DWORD PTR _itdebug, ebx
	je	SHORT $LN35@iterate
	fstp	ST(2)
	sub	esp, 8
	fstp	ST(0)
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BJ@LGLILMBM@Halving?5scale?0?5scale?5?$CFg?6?$AA@
	call	_printf
	fld	QWORD PTR _web+1512
	fld	QWORD PTR _energy1$[ebp]
	add	esp, 12					; 0000000cH
	fld	QWORD PTR _energy2$[ebp]
	fxch	ST(2)
$LN35@iterate:

; 146  :          if  ( web.scale < 1e-12*web.maxscale ) { web.scale = 0.0; break; }

	fld	QWORD PTR _web+1528
	fmul	QWORD PTR __real@3d719799812dea11
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN140@iterate
	fstp	ST(2)

; 147  :          move_vertices(TEST_MOVE,web.scale);

	sub	esp, 8
	fstp	ST(0)
	fstp	QWORD PTR [esp]
	push	ebx
	call	_move_vertices

; 148  :          energy1 = web.total_energy;

	fld	QWORD PTR _web+1240
	fst	QWORD PTR _energy1$[ebp]
	add	esp, 12					; 0000000cH

; 149  :          if ( !is_finite(energy1) ) energy1 = MAXDOUBLE;

	fld	QWORD PTR __real@fe37e43c8800759c
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN145@iterate
	fld	QWORD PTR __real@7e37e43c8800759c
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN33@iterate
$LN145@iterate:
	fstp	ST(0)
	fld	QWORD PTR __real@47d2ced32a16a1b1
	fst	QWORD PTR _energy1$[ebp]
$LN33@iterate:

; 150  :          scale1 = web.scale;

	fld	QWORD PTR _web+1512
	fst	QWORD PTR _scale1$[ebp]

; 151  :          if ( itdebug ) 

	cmp	DWORD PTR _itdebug, ebx
	je	SHORT $LN148@iterate

; 152  :          { printf("scale1 %g energy1 %20.15g \n",(DOUBLE)scale1,(DOUBLE)energy1);

	sub	esp, 16					; 00000010H
	fxch	ST(1)
	fstp	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BM@ECNBLAOK@scale1?5?$CFg?5energy1?5?$CF20?415g?5?6?$AA@
	call	_printf
	add	esp, 20					; 00000014H

; 153  :            if ( web.skel[BODY].count < 10 ) show_volumes();

	cmp	DWORD PTR _web+400, esi
	jge	SHORT $LN30@iterate
	call	_show_volumes
$LN30@iterate:

; 154  :            printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	add	esp, 4
	jmp	SHORT $LN31@iterate
$LN148@iterate:
	fstp	ST(1)
	fstp	ST(0)
$LN31@iterate:

; 155  :          }
; 156  :          restore_coords(&saved,SAVE_IN_ATTR);

	push	1
	push	OFFSET _saved
	call	_restore_coords
	add	esp, 8

; 157  :          if ( volgrads_changed_flag )

	cmp	DWORD PTR _volgrads_changed_flag, ebx
	je	SHORT $LN38@iterate

; 158  :          { calc_all_grads(CALC_VOLGRADS);

	push	2
	call	_calc_all_grads
	add	esp, 4

; 159  :            calc_leftside();

	call	_calc_leftside

; 160  :            volgrads_changed_flag = 0;

	mov	DWORD PTR _volgrads_changed_flag, ebx
$LN38@iterate:

; 161  :          }
; 162  :       }
; 163  :       while ( energy1 > energy0 );

	fld	QWORD PTR _energy0$[ebp]
	fld	QWORD PTR _energy1$[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	fld	QWORD PTR _web+1512
	test	ah, 65					; 00000041H
	je	$LN189@iterate

; 142  :             { web.scale = 0.0; break; }

	fld	QWORD PTR _energy2$[ebp]
	fldz
	fxch	ST(1)
	fxch	ST(3)
	fxch	ST(2)

; 164  :       web.scale *= 2;

	fadd	ST(0), ST(0)
	fst	QWORD PTR _web+1512
	jmp	$LN40@iterate
$LN133@iterate:

; 141  :          if ( seekcount > 20 ) /* looks like energy won't decrease */

	fstp	ST(1)

; 142  :             { web.scale = 0.0; break; }

	fldz
	fld	ST(0)
	fld	QWORD PTR _energy2$[ebp]
	fxch	ST(3)
	fxch	ST(2)
	fxch	ST(1)

; 164  :       web.scale *= 2;

	fadd	ST(0), ST(0)
	fst	QWORD PTR _web+1512
	jmp	$LN40@iterate
$LN140@iterate:

; 146  :          if  ( web.scale < 1e-12*web.maxscale ) { web.scale = 0.0; break; }

	fstp	ST(0)
	fldz
	fld	ST(0)

; 164  :       web.scale *= 2;

	fadd	ST(0), ST(0)
	fst	QWORD PTR _web+1512
	jmp	$LN40@iterate
$LN153@iterate:

; 165  :     }
; 166  : 
; 167  :     if ( web.scale > web.maxscale ) 

	fstp	ST(0)

; 169  :     else if ( web.scale > 0.0 )

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN166@iterate
	fstp	ST(0)

; 170  :     {
; 171  :       /* now quadratic interpolation for minimum energy */
; 172  :       denom = energy0*(scale1-scale2)+energy1*(scale2-scale0)
; 173  :                      + energy2*(scale0 - scale1);

	fld	QWORD PTR _scale1$[ebp]
	fld	ST(0)
	fld	QWORD PTR _scale2$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR _energy0$[ebp]
	fld	ST(1)
	fsub	ST(0), ST(4)
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	ST(3)
	fsub	ST(0), ST(3)
	fmul	ST(0), ST(6)
	faddp	ST(1), ST(0)

; 174  :       if ( denom == 0.0 ) web.scale = 0.0;

	fld	ST(0)
	fld	ST(4)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN25@iterate
	fstp	ST(0)
	fstp	ST(4)
	fstp	ST(2)
	fstp	ST(1)
	fstp	ST(1)
	fst	QWORD PTR _web+1512

; 175  :       else

	jmp	SHORT $have_scale$89091
$LN25@iterate:

; 176  :       { web.scale = ((energy0-energy2)*scale1*scale1
; 177  :                 +(energy1-energy0)*scale2*scale2
; 178  :                 +(energy2-energy1)*scale0*scale0)/2/denom;

	fld	ST(4)
	fld	QWORD PTR _energy0$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	fmulp	ST(3), ST(0)
	fsub	ST(0), ST(6)
	fmul	ST(0), ST(3)
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(4)
	fsubrp	ST(3), ST(0)
	fxch	ST(2)
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fe0000000000000
	fdivrp	ST(1), ST(0)
	fst	QWORD PTR _web+1512

; 179  :       }
; 180  :       /* else leave scale as is */
; 181  :     }

	jmp	SHORT $have_scale$89091
$LN122@iterate:

; 93   :     }
; 94   : 
; 95   :     if ( !is_finite(energy0) )

	fstp	ST(0)
$LN53@iterate:

; 96   :       { kb_error(1863,"Infinite energy. Restoring coordinates.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CJ@MCAKEKD@Infinite?5energy?4?5Restoring?5coord@
	push	1863					; 00000747H

; 97   :         goto iterate_error_exit;

	jmp	$LN211@iterate
$LN66@iterate:

; 182  :   }
; 183  :   else if ( runge_kutta_flag )

	cmp	DWORD PTR _runge_kutta_flag, ebx
	je	SHORT $LN87@iterate

; 184  :   { /* only for fixed scale */
; 185  :     runge_kutta(); 

	call	_runge_kutta
$LN87@iterate:
	fld	QWORD PTR _web+1512
	jmp	SHORT $have_scale$89091
$LN166@iterate:

; 169  :     else if ( web.scale > 0.0 )

	fstp	ST(3)
	fstp	ST(0)
	fstp	ST(0)
$have_scale$89091:

; 186  :   }
; 187  : 
; 188  : have_scale:
; 189  :   if ( !web.motion_flag )

	cmp	DWORD PTR _web+852, ebx
	jne	SHORT $LN20@iterate

; 190  :     if ( web.scale > web.maxscale ) 

	fld	QWORD PTR _web+1528
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN160@iterate
	fstp	ST(1)

; 191  :       web.scale = web.maxscale; /* max on movement */

	fst	QWORD PTR _web+1512
	jmp	SHORT $LN20@iterate
$LN160@iterate:

; 190  :     if ( web.scale > web.maxscale ) 

	fstp	ST(0)
$LN20@iterate:

; 192  : 
; 193  :   if ( itdebug ) printf("Final scale: %g\n",(double)web.scale);

	cmp	DWORD PTR _itdebug, ebx
	je	SHORT $LN19@iterate
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BB@BGMGHNEP@Final?5scale?3?5?$CFg?6?$AA@
	call	_printf
	fld	QWORD PTR _web+1512
	add	esp, 12					; 0000000cH
$LN19@iterate:

; 194  :   move_vertices(ACTUAL_MOVE,web.scale_scale*web.scale);

	fmul	QWORD PTR _web+1520
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	1
	call	_move_vertices
	add	esp, 12					; 0000000cH

; 195  : 
; 196  : 
; 197  :   if ( web.jiggle_flag )  jiggle(); 

	cmp	DWORD PTR _web+900, ebx
	je	SHORT $LN18@iterate
	call	_jiggle
$LN18@iterate:

; 198  :   if( autopop_flag || autochop_flag ) 

	cmp	DWORD PTR _autopop_flag, ebx
	jne	SHORT $LN16@iterate
	cmp	DWORD PTR _autochop_flag, ebx
	je	SHORT $LN17@iterate
$LN16@iterate:

; 199  :   { 
; 200  :     autopop_detect(web.scale);

	fld	QWORD PTR _web+1512
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_autopop_detect
	add	esp, 8

; 201  :     if ( autopop_count || autochop_count )

	cmp	DWORD PTR _autopop_count, ebx
	jne	SHORT $LN14@iterate
	cmp	DWORD PTR _autochop_count, ebx
	je	SHORT $LN15@iterate
$LN14@iterate:

; 202  :     { autopop_pop();

	call	_autopop_pop

; 203  :       autochop_chop();

	call	_autochop_chop
$LN15@iterate:

; 204  :     }
; 205  :     autopop_cleanup();   

	call	_autopop_cleanup
$LN17@iterate:

; 206  :   }
; 207  : 
; 208  :   if ( fixed_constraint_flag ) calc_content(Q_FIXED);

	cmp	DWORD PTR _fixed_constraint_flag, ebx
	je	SHORT $LN93@iterate
	push	2
	call	_calc_content
	fstp	ST(0)
	add	esp, 4
$LN93@iterate:

; 209  : 
; 210  :   if ( !is_finite(web.total_energy ))

	fld	QWORD PTR __real@fe37e43c8800759c
	fld	QWORD PTR _web+1240
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jne	$LN195@iterate
	fld	QWORD PTR __real@7e37e43c8800759c
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN195@iterate

; 213  :         goto iterate_error_exit;
; 214  :      }     
; 215  :   if ( check_increase_flag && (web.total_energy > energy0) )

	cmp	DWORD PTR _check_increase_flag, ebx
	je	SHORT $LN91@iterate
	fld	QWORD PTR _energy0$[ebp]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN91@iterate

; 216  :   { kb_error(1865,
; 217  :      "Motion would have increased energy. Restoring coordinates.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0DM@EGFBFKCD@Motion?5would?5have?5increased?5ener@
	push	1865					; 00000749H

; 218  :         goto iterate_error_exit;

	jmp	$LN212@iterate
$LN91@iterate:

; 219  :   }
; 220  :   if ( !web.motion_flag && (web.total_energy > energy0) )

	cmp	DWORD PTR _web+852, ebx
	jne	SHORT $LN203@iterate
	fcomp	QWORD PTR _energy0$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN89@iterate

; 221  :   { /* go back and use scale1 */
; 222  :     restore_coords(&saved,SAVE_IN_ATTR);

	push	1
	push	OFFSET _saved
	call	_restore_coords

; 223  :     web.scale = scale1; /* known to decrease energy */

	fld	QWORD PTR _scale1$[ebp]
	fst	QWORD PTR _web+1512

; 224  :     move_vertices(ACTUAL_MOVE,web.scale);

	fstp	QWORD PTR [esp]
	push	1
	call	_move_vertices
	add	esp, 12					; 0000000cH

; 225  :     if ( cg_hvector ) /* restart conjugate gradient */

	cmp	DWORD PTR _cg_hvector, ebx
	je	SHORT $LN89@iterate

; 226  :        cg_restart();

	call	_cg_restart
	jmp	SHORT $LN89@iterate
$LN203@iterate:
	fstp	ST(0)
$LN89@iterate:

; 227  :   }
; 228  :   total_time += web.scale;

	fld	QWORD PTR _total_time
	fadd	QWORD PTR _web+1512
	fstp	QWORD PTR _total_time

; 229  :   if ( web.area_norm_flag && web.norm_check_flag &&
; 230  :                (web.representation==SOAPFILM) )

	cmp	DWORD PTR _web+876, ebx
	je	SHORT $LN90@iterate
	cmp	DWORD PTR _web+880, ebx
	je	SHORT $LN90@iterate
	cmp	DWORD PTR _web+624, 2
	jne	SHORT $LN90@iterate

; 231  :   { REAL delta = normal_change_check();

	call	_normal_change_check

; 232  :     if ( delta  > web.norm_check_max )

	fld	QWORD PTR _web+888
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN206@iterate

; 233  :     { sprintf(msg,"Max normal change: %f.  Restoring coordinates.\n",
; 234  :                             (DOUBLE) delta);

	mov	ecx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0DA@JPFNKEJN@Max?5normal?5change?3?5?$CFf?4?5?5Restorin@
	push	ecx
	call	_sprintf

; 235  :       kb_error(1866,msg,WARNING);

	mov	edx, DWORD PTR _msg
	push	2
	push	edx
	push	1866					; 0000074aH
	call	_kb_error
	add	esp, 28					; 0000001cH

; 236  :       goto iterate_error_exit;

	jmp	$iterate_error_exit$89074
$LN206@iterate:

; 232  :     if ( delta  > web.norm_check_max )

	fstp	ST(0)
$LN90@iterate:

; 237  :     }
; 238  :   }
; 239  :      
; 240  : /* if chop here, then instabilities have a chance to get out of control */
; 241  : /*  if ( autopop_flag ) autopop_pop();
; 242  :   if ( autochop_flag ) autochop_chop();
; 243  : */
; 244  : /* following good for debugging to see if energy gradients really give
; 245  :     change in energy.  Estimated decrease should be approx exact for
; 246  :     scale much less than optimum; at optimum scale, estimate is twice
; 247  :     actual (if energy shape true parabola )
; 248  :     But note estimate does not work if form-to-vector has messed things up.
; 249  : */
; 250  : 
; 251  :   if ( estimate_flag )

	cmp	DWORD PTR _estimate_flag, ebx
	je	SHORT $LN5@iterate

; 252  :      {
; 253  : #ifdef FLOAT128
; 254  :         sprintf(msg,"Estimated energy change: %#*.*Qg\n",DWIDTH,DPREC,
; 255  :             estimate_decrease());
; 256  :         outstring(msg);
; 257  :         sprintf(msg,"Actual energy change   : %#*.*Qg\n",DWIDTH,DPREC,
; 258  :             web.total_energy-old_energy);
; 259  :         outstring(msg);
; 260  : #elif defined(LONGDOUBLE)
; 261  :         sprintf(msg,"Estimated energy change: %#*.*Lg\n",DWIDTH,DPREC,
; 262  :             estimate_decrease());
; 263  :         outstring(msg);
; 264  :         sprintf(msg,"Actual energy change   : %#*.*Lg\n",DWIDTH,DPREC,
; 265  :             web.total_energy-old_energy);
; 266  :         outstring(msg);
; 267  : #else
; 268  :         sprintf(msg,"Estimated energy change: %#20.15g\n",estimate_decrease());

	call	_estimate_decrease
	mov	eax, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CD@FHDGCLDO@Estimated?5energy?5change?3?5?$CF?$CD20?415@
	push	eax
	call	_sprintf

; 269  :         outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring

; 270  :         sprintf(msg,"Actual energy change   : %#20.15g\n",
; 271  :             web.total_energy-old_energy);

	fld	QWORD PTR _web+1240
	fsub	QWORD PTR _old_energy$[ebp]
	mov	edx, DWORD PTR _msg
	add	esp, 12					; 0000000cH
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CD@LLNDMBBM@Actual?5energy?5change?5?5?5?3?5?$CF?$CD20?415@
	push	edx
	call	_sprintf

; 272  :         outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H
$LN5@iterate:

; 273  : #endif
; 274  :      }
; 275  : 
; 276  : #ifdef FLOAT128
; 277  :   sprintf(msg,"%3d. energy: %#*.*Qg  scale: %#Qg\n",gocount,DWIDTH,DPREC,
; 278  :                 web.total_energy,web.scale);
; 279  : #elif defined(LONGDOUBLE)
; 280  :   sprintf(msg,"%3d. energy: %#*.*Lg  scale: %#Lg\n",gocount,DWIDTH,DPREC,
; 281  :                 web.total_energy,web.scale);
; 282  : #else
; 283  :   sprintf(msg,"%3d. %s: %#17.15g energy: %#17.15g  scale: %#g\n",gocount,
; 284  :                 areaname,web.total_area,web.total_energy,web.scale);

	fld	QWORD PTR _web+1512
	mov	ecx, DWORD PTR _areaname
	mov	edx, DWORD PTR _gocount
	mov	eax, DWORD PTR _msg
	sub	esp, 24					; 00000018H
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR _web+1240
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _web+992
	fstp	QWORD PTR [esp]
	push	ecx
	push	edx
	push	OFFSET ??_C@_0DA@CLPAALJF@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@
	push	eax
	call	_sprintf
	add	esp, 40					; 00000028H

; 285  : #endif
; 286  :   if ( !quiet_go_flag ) outstring(msg);

	cmp	DWORD PTR _quiet_go_flag, ebx
	jne	SHORT $LN4@iterate
	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 4
$LN4@iterate:

; 287  : 
; 288  :   vgrad_end();

	call	_vgrad_end

; 289  :   unsave_coords(&saved,SAVE_IN_ATTR);

	push	1
	push	OFFSET _saved
	call	_unsave_coords
	add	esp, 8

; 290  :   update_display();

	call	_update_display

; 291  :   iterate_flag = old_flag; /* for interrupt handler */

	mov	edx, DWORD PTR _old_flag$[ebp]
	mov	DWORD PTR _iterate_flag, edx

; 292  :   goto iterate_exit;

	jmp	SHORT $iterate_exit$89145
$LN195@iterate:

; 211  :   { kb_error(1864,
; 212  :      "Motion would cause infinite energy. Restoring coordinates.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0DM@EPAJDMFA@Motion?5would?5cause?5infinite?5ener@
	push	1864					; 00000748H
$LN212@iterate:

; 209  : 
; 210  :   if ( !is_finite(web.total_energy ))

	fstp	ST(0)
$LN211@iterate:

; 211  :   { kb_error(1864,
; 212  :      "Motion would cause infinite energy. Restoring coordinates.\n",WARNING);

	call	_kb_error
	add	esp, 12					; 0000000cH
$iterate_error_exit$89074:

; 293  : 
; 294  : iterate_error_exit:
; 295  :   /* in case optimizing scale didn't work */
; 296  : 
; 297  :   vgrad_end();

	call	_vgrad_end

; 298  : 
; 299  :   restore_coords(&saved,SAVE_IN_ATTR);

	push	1
	push	OFFSET _saved
	call	_restore_coords
	add	esp, 8

; 300  :   if ( count_fixed_vol() || web.pressure_flag ) calc_content(Q_FIXED);

	call	_count_fixed_vol
	test	eax, eax
	jne	SHORT $LN2@iterate
	cmp	DWORD PTR _web+868, ebx
	je	SHORT $LN3@iterate
$LN2@iterate:
	push	2
	call	_calc_content
	fstp	ST(0)
	add	esp, 4
$LN3@iterate:

; 301  :   calc_pressure();

	call	_calc_pressure

; 302  :   calc_energy();  /* energy after motion */

	call	_calc_energy

; 303  :   unsave_coords(&saved,SAVE_IN_ATTR);

	push	1
	push	OFFSET _saved
	call	_unsave_coords

; 304  :   iterate_flag = old_flag; /* for interrupt handler */

	mov	eax, DWORD PTR _old_flag$[ebp]
	add	esp, 8
	mov	DWORD PTR _iterate_flag, eax

; 305  :   update_display();

	call	_update_display

; 306  :   breakflag = BREAKREPEAT; /* break repeat loop */

	mov	DWORD PTR _breakflag, 3
$iterate_exit$89145:

; 307  : 
; 308  : iterate_exit:
; 309  :   LEAVE_GRAPH_MUTEX;

	pop	esi
	cmp	DWORD PTR _did_graphlock_here$89047[ebp], ebx
	je	SHORT $LN1@iterate
	mov	ecx, DWORD PTR _graphmutex
	push	ecx
	mov	DWORD PTR _locking_thread, ebx
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@iterate:
	pop	edi
	pop	ebx

; 310  : }  /* end iterate() */

	mov	esp, ebp
	pop	ebp
	ret	0
_iterate ENDP
_TEXT	ENDS
PUBLIC	_burchard
; Function compile flags: /Ogtp
;	COMDAT _burchard
_TEXT	SEGMENT
tv132 = -16						; size = 8
_old_scale$ = -8					; size = 8
tv146 = 8						; size = 4
tv141 = 8						; size = 4
_maxsteps$ = 8						; size = 4
_burchard PROC						; COMDAT

; 362  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 363  :   REAL old_scale = web.scale;

	fld	QWORD PTR _web+1512
	push	ebx

; 364  :   int old_motion_flag = web.motion_flag;

	mov	ebx, DWORD PTR _web+852
	fstp	QWORD PTR _old_scale$[ebp]
	push	esi
	push	edi

; 365  :   int i;
; 366  : 
; 367  :   web.motion_flag = 1;
; 368  :   for ( i = 0 ; i < maxsteps ; i++ )

	mov	edi, DWORD PTR _maxsteps$[ebp]
	xor	esi, esi
	mov	DWORD PTR _web+852, 1
	test	edi, edi
	jle	SHORT $LN1@burchard
	mov	eax, edi
	imul	eax, edi
	mov	DWORD PTR tv146[ebp], eax
	fild	DWORD PTR tv146[ebp]
	fstp	QWORD PTR tv132[ebp]
	npad	7
$LL8@burchard:

; 369  :     { web.scale =old_scale /(1 - (i*i)/(REAL)(maxsteps*maxsteps));

	mov	ecx, esi
	imul	ecx, esi
	mov	DWORD PTR tv141[ebp], ecx
	fild	DWORD PTR tv141[ebp]
	fdiv	QWORD PTR tv132[ebp]
	fld1
	fsubrp	ST(1), ST(0)
	fdivr	QWORD PTR _old_scale$[ebp]
	fstp	QWORD PTR _web+1512

; 370  :       iterate();

	call	_iterate
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL8@burchard
$LN1@burchard:

; 371  :     }
; 372  :   web.scale = old_scale;

	fld	QWORD PTR _old_scale$[ebp]
	pop	edi
	pop	esi
	fstp	QWORD PTR _web+1512

; 373  :   web.motion_flag = old_motion_flag;

	mov	DWORD PTR _web+852, ebx
	pop	ebx

; 374  : } // end burchard()

	mov	esp, ebp
	pop	ebp
	ret	0
_burchard ENDP
_TEXT	ENDS
END
