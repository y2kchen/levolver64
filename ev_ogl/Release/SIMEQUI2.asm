; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\SIMEQUI2.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_facelist:DWORD
_DATA	ENDS
PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_unset_attr
; Function compile flags: /Ogtp
;	COMDAT _unset_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_unset_attr PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 29   :   elptr(id)->attr &= ~attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	not	ecx
	and	DWORD PTR [eax+8], ecx
	not	edx
	and	DWORD PTR [eax+12], edx

; 30   : }

	pop	ebp
	ret	0
_unset_attr ENDP
_TEXT	ENDS
PUBLIC	_scomp
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\simequi2.c
;	COMDAT _scomp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_scomp	PROC						; COMDAT

; 34   : { int i;

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 35   :   for ( i = 0 ; i < web.dimension ; i++,a++,b++ )

	mov	edi, DWORD PTR _web+620
	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN4@scomp
	mov	ebx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	sub	ebx, eax
	npad	6
$LL6@scomp:

; 36   :      if ( *a < *b ) return -1;

	mov	ecx, DWORD PTR [ebx+eax]
	mov	edx, DWORD PTR [eax]
	cmp	ecx, edx
	jb	SHORT $LN10@scomp

; 37   :      else if ( *a > *b ) return 1;

	ja	SHORT $LN11@scomp

; 35   :   for ( i = 0 ; i < web.dimension ; i++,a++,b++ )

	inc	esi
	add	eax, 4
	cmp	esi, edi
	jl	SHORT $LL6@scomp
$LN4@scomp:
	pop	edi
	pop	esi

; 38   :   return 0; /* equal */

	xor	eax, eax
	pop	ebx

; 39   : } // end scomp()

	pop	ebp
	ret	0
$LN10@scomp:
	pop	edi
	pop	esi

; 36   :      if ( *a < *b ) return -1;

	or	eax, -1
	pop	ebx

; 39   : } // end scomp()

	pop	ebp
	ret	0
$LN11@scomp:
	pop	edi
	pop	esi

; 37   :      else if ( *a > *b ) return 1;

	mov	eax, 1
	pop	ebx

; 39   : } // end scomp()

	pop	ebp
	ret	0
_scomp	ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ddb7cdfd9d7bdbb
PUBLIC	__real@3fe0000000000000
PUBLIC	_fp$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_void_test2
EXTRN	_vec_mat_mul:PROC
EXTRN	_matvec_mul:PROC
EXTRN	_mat_inv:PROC
EXTRN	_dot:PROC
EXTRN	_dymem:DWORD
EXTRN	_mat2d_setup:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@3ddb7cdfd9d7bdbb
CONST	SEGMENT
__real@3ddb7cdfd9d7bdbb DQ 03ddb7cdfd9d7bdbbr	; 1e-010
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _void_test2
_TEXT	SEGMENT
_matqXvS$ = -948					; size = 24
_sideqXvS$ = -924					; size = 24
_rr$ = -900						; size = 8
tv2381 = -896						; size = 4
_side$ = -892						; size = 4
tv2324 = -888						; size = 4
tv1758 = -888						; size = 4
_mat$ = -884						; size = 4
tv2373 = -880						; size = 4
tv1744 = -880						; size = 4
_fp$GSCopy$ = -880					; size = 4
tv2377 = -876						; size = 4
tv1749 = -876						; size = 4
tv1203 = -876						; size = 4
tv1132 = -876						; size = 4
tv1753 = -872						; size = 4
tv1243 = -872						; size = 4
_retval$ = -872						; size = 4
_sidexJ$ = -868						; size = 288
_matxJ$ = -580						; size = 288
_lam$ = -292						; size = 48
_s$89308 = -244						; size = 48
_ss$ = -196						; size = 48
_z$ = -148						; size = 48
_q$89307 = -100						; size = 48
_x$ = -80						; size = 28
_center$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_fp$ = 8						; size = 4
_void_test2 PROC					; COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 948				; 000003b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _fp$[ebp]

; 234  :     REAL *x[MAXCOORD+1];
; 235  :     REAL ss[MAXCOORD];  /* squares of sides */
; 236  :     int k,j;
; 237  :     REAL rr;  /* square radius of void */
; 238  :     REAL center[MAXCOORD];
; 239  :     REAL lam[MAXCOORD];
; 240  :     MAT2D(mat,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _matxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _fp$GSCopy$[ebp], edi
	call	_mat2d_setup

; 241  :     MAT2D(side,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	edx, DWORD PTR _sidexJ$[ebp]
	mov	DWORD PTR _mat$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _sideqXvS$[ebp]
	push	eax
	call	_mat2d_setup

; 242  :     int retval;  /* result to return */
; 243  :     REAL *y;
; 244  :     REAL z[MAXCOORD];
; 245  : 
; 246  :     /* first, calculate center of void */
; 247  :     x[0] = get_coord(fp->opp[0]);

	mov	edx, DWORD PTR [edi+24]
	mov	ecx, eax
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	add	ebx, DWORD PTR [eax+edx+64]

; 248  :     for ( k = 0 ; k < web.dimension ; k++ )

	mov	eax, DWORD PTR _web+620
	add	esp, 32					; 00000020H
	xor	edx, edx
	mov	DWORD PTR _side$[ebp], ecx
	mov	DWORD PTR _x$[ebp], ebx
	test	eax, eax
	jle	$LN65@void_test2
	lea	esi, DWORD PTR _x$[ebp+4]
	sub	edi, esi
	sub	ecx, esi
	mov	DWORD PTR tv1132[ebp], ecx
	npad	3
$LL69@void_test2:

; 249  :       {  x[k+1] = get_coord(fp->v[k]);

	mov	esi, DWORD PTR _web+12
	mov	ebx, DWORD PTR _dymem
	lea	ecx, DWORD PTR [edi+edx*4]
	mov	ecx, DWORD PTR _x$[ebp+ecx+4]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR _web+104
	mov	esi, DWORD PTR [esi+ebx+64]
	add	esi, ecx

; 250  :           for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	mov	DWORD PTR _x$[ebp+edx*4+4], esi
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN27@void_test2

; 249  :       {  x[k+1] = get_coord(fp->v[k]);

	mov	ebx, DWORD PTR tv1132[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	lea	ebx, DWORD PTR [ebx+edx*4]

; 250  :           for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _x$[ebp+ebx+4]
	sub	esi, eax
	sub	ebx, eax
	npad	6
$LL25@void_test2:

; 251  :              side[k][j] = x[k+1][j] - x[0][j];

	fld	QWORD PTR [esi+eax]
	inc	ecx
	fsub	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [ebx+eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL25@void_test2

; 250  :           for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+620
$LN27@void_test2:

; 248  :     for ( k = 0 ; k < web.dimension ; k++ )

	inc	edx
	cmp	edx, eax
	jl	SHORT $LL69@void_test2
	mov	ebx, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _side$[ebp]
$LN65@void_test2:

; 252  :       }
; 253  :     for ( k = 0 ; k < web.dimension ; k++ )

	xor	esi, esi
	test	eax, eax
	jle	$LN20@void_test2
	mov	edx, DWORD PTR _mat$[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv1243[ebp], edx
	mov	DWORD PTR tv1203[ebp], ecx
$LL68@void_test2:

; 254  :       { 
; 255  :          for ( j = 0 ; j <= k ; j++ )

	xor	edi, edi
	test	esi, esi
	js	SHORT $LN17@void_test2
	mov	ebx, DWORD PTR _mat$[ebp]
$LL19@void_test2:

; 256  :             mat[j][k] = mat[k][j] = SDIM_dot(side[j],side[k]);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR tv1243[ebp]
	push	edx
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [ecx+ebx]
	push	edx
	push	eax
	call	_dot
	mov	ecx, DWORD PTR tv1243[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ebx]
	fst	QWORD PTR [edx+edi*8]
	mov	ecx, DWORD PTR tv1203[ebp]
	fstp	QWORD PTR [eax+esi*8]
	inc	edi
	add	esp, 12					; 0000000cH
	add	ebx, 4
	cmp	edi, esi
	jle	SHORT $LL19@void_test2

; 254  :       { 
; 255  :          for ( j = 0 ; j <= k ; j++ )

	mov	eax, DWORD PTR _web+620
	mov	ebx, DWORD PTR _x$[ebp]
$LN17@void_test2:

; 257  :          ss[k] = mat[k][k]/2;

	mov	edx, DWORD PTR tv1243[ebp]
	mov	edi, DWORD PTR [edx]
	fld	QWORD PTR [edi+esi*8]
	inc	esi
	fmul	QWORD PTR __real@3fe0000000000000
	add	edx, 4
	mov	DWORD PTR tv1243[ebp], edx
	fstp	QWORD PTR _ss$[ebp+esi*8-8]
	cmp	esi, eax
	jl	SHORT $LL68@void_test2
$LN20@void_test2:

; 258  :       }
; 259  :     mat_inv(mat,web.dimension);

	mov	esi, DWORD PTR _mat$[ebp]
	push	eax
	push	esi
	call	_mat_inv

; 260  :     matvec_mul(mat,ss,lam,web.dimension,web.dimension);

	mov	eax, DWORD PTR _web+620
	push	eax
	push	eax
	lea	ecx, DWORD PTR _lam$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ss$[ebp]
	push	edx
	push	esi
	call	_matvec_mul

; 261  :     vec_mat_mul(lam,side,center,web.dimension,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _web+620
	push	eax
	mov	eax, DWORD PTR _side$[ebp]
	push	ecx
	lea	edx, DWORD PTR _center$[ebp]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _lam$[ebp]
	push	ecx
	call	_vec_mat_mul

; 262  :     rr = dot(center,center,web.dimension);

	mov	edx, DWORD PTR _web+620
	push	edx
	lea	eax, DWORD PTR _center$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fstp	QWORD PTR _rr$[ebp]

; 263  :     for ( k = 0 ; k < SDIM ; k++ )

	mov	edx, DWORD PTR _web+616
	add	esp, 60					; 0000003cH
	xor	ecx, ecx
	cmp	edx, 4
	jl	SHORT $LC48@void_test2

; 264  :       center[k] += x[0][k];

	lea	edi, DWORD PTR [edx-3]
	lea	edx, DWORD PTR _center$[ebp]
	lea	esi, DWORD PTR _center$[ebp+8]
	sub	edx, ebx
	lea	eax, DWORD PTR [ebx+16]
	sub	esi, ebx
$LL67@void_test2:
	fld	QWORD PTR [eax-16]
	add	ecx, 4
	fadd	QWORD PTR _center$[ebp+ecx*8-32]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR _center$[ebp+ecx*8-32]
	fld	QWORD PTR [eax-40]
	fadd	QWORD PTR _center$[ebp+ecx*8-24]
	fstp	QWORD PTR _center$[ebp+ecx*8-24]
	fld	QWORD PTR [eax-32]
	fadd	QWORD PTR [edx+eax-32]
	fstp	QWORD PTR [edx+eax-32]
	fld	QWORD PTR [eax-24]
	fadd	QWORD PTR [esi+eax-32]
	fstp	QWORD PTR [esi+eax-32]
	cmp	ecx, edi
	jl	SHORT $LL67@void_test2
	mov	edx, DWORD PTR _web+616
$LC48@void_test2:

; 263  :     for ( k = 0 ; k < SDIM ; k++ )

	cmp	ecx, edx
	jge	SHORT $LN47@void_test2
	mov	eax, ebx
	lea	esi, DWORD PTR _center$[ebp]
	sub	eax, esi
$LC16@void_test2:
	lea	esi, DWORD PTR [eax+ecx*8]

; 264  :       center[k] += x[0][k];

	fld	QWORD PTR _center$[ebp+esi]
	inc	ecx
	fadd	QWORD PTR _center$[ebp+ecx*8-8]
	fstp	QWORD PTR _center$[ebp+ecx*8-8]
	cmp	ecx, edx
	jl	SHORT $LC16@void_test2
$LN47@void_test2:

; 265  : 
; 266  :     /* now see if other vertex is in the void */
; 267  :     y = get_coord(fp->opp[1]);

	mov	eax, DWORD PTR _fp$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	esi, DWORD PTR [ecx+eax+64]

; 268  :     for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	edx, 4
	jl	$LC51@void_test2

; 269  :             z[j] = y[j] - center[j];

	lea	edi, DWORD PTR _center$[ebp]
	sub	edi, esi
	mov	DWORD PTR tv1744[ebp], edi
	lea	edi, DWORD PTR _z$[ebp]
	sub	edi, esi
	mov	DWORD PTR tv1749[ebp], edi
	lea	edi, DWORD PTR _center$[ebp+8]
	sub	edi, esi
	mov	DWORD PTR tv1753[ebp], edi
	lea	edi, DWORD PTR _z$[ebp+8]
	sub	edi, esi
	lea	eax, DWORD PTR [esi+16]
	mov	DWORD PTR tv1758[ebp], edi
$LL52@void_test2:
	fld	QWORD PTR [eax-16]
	mov	edi, DWORD PTR tv1744[ebp]
	fsub	QWORD PTR _center$[ebp+ecx*8]
	add	ecx, 4
	add	eax, 32					; 00000020H
	fstp	QWORD PTR _z$[ebp+ecx*8-32]
	fld	QWORD PTR [eax-40]
	fsub	QWORD PTR _center$[ebp+ecx*8-24]
	fstp	QWORD PTR _z$[ebp+ecx*8-24]
	fld	QWORD PTR [eax-32]
	fsub	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv1749[ebp]
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv1753[ebp]
	fld	QWORD PTR [eax-24]
	fsub	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv1758[ebp]
	fstp	QWORD PTR [edi+eax-32]
	lea	edi, DWORD PTR [edx-3]
	cmp	ecx, edi
	jl	SHORT $LL52@void_test2
$LC51@void_test2:

; 268  :     for ( j = 0 ; j < SDIM ; j++ )

	cmp	ecx, edx
	jge	SHORT $LN50@void_test2
	mov	edi, esi
	lea	eax, DWORD PTR _center$[ebp]
	sub	edi, eax
$LC13@void_test2:
	lea	eax, DWORD PTR _center$[ebp+ecx*8]

; 269  :             z[j] = y[j] - center[j];

	fld	QWORD PTR [edi+eax]
	inc	ecx
	fsub	QWORD PTR [eax]
	fstp	QWORD PTR _z$[ebp+ecx*8-8]
	cmp	ecx, edx
	jl	SHORT $LC13@void_test2
$LN50@void_test2:

; 270  :     if ( SDIM_dot(z,z) < rr - 1e-10 ) retval = 1;

	push	edx
	lea	ecx, DWORD PTR _z$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fld	QWORD PTR _rr$[ebp]
	fsub	QWORD PTR __real@3ddb7cdfd9d7bdbb
	add	esp, 12					; 0000000cH
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN10@void_test2

; 271  :     else retval = 0;
; 272  : 
; 273  :     if ( retval )
; 274  :     { /* see if connecting segment passes through facet */
; 275  :       REAL q[MAXCOORD]; /* relative coord of opposite point */
; 276  :       REAL s[MAXCOORD];
; 277  :       for ( j = 0 ; j < SDIM ; j++ ) z[j] = y[j] - x[0][j];

	mov	ecx, DWORD PTR _web+616
	xor	edx, edx
	mov	DWORD PTR _retval$[ebp], 1
	cmp	ecx, 4
	jl	$LC54@void_test2
	mov	edi, esi
	sub	edi, ebx
	mov	DWORD PTR tv2324[ebp], edi
	lea	edi, DWORD PTR _z$[ebp]
	sub	edi, ebx
	mov	DWORD PTR tv2373[ebp], edi
	lea	edi, DWORD PTR _z$[ebp+8]
	sub	edi, ebx
	mov	DWORD PTR tv2377[ebp], edi
	lea	edi, DWORD PTR _z$[ebp+16]
	sub	edi, ebx
	lea	ecx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR tv2381[ebp], edi
	npad	7
$LL55@void_test2:
	fld	QWORD PTR [ecx-24]
	mov	edi, DWORD PTR tv2324[ebp]
	fsub	QWORD PTR [eax-8]
	add	edx, 4
	add	eax, 32					; 00000020H
	add	ecx, 32					; 00000020H
	fstp	QWORD PTR _z$[ebp+edx*8-32]
	fld	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv2373[ebp]
	fsub	QWORD PTR [eax-32]
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv2377[ebp]
	fld	QWORD PTR [ecx-40]
	fsub	QWORD PTR [eax-24]
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv2381[ebp]
	fld	QWORD PTR [ecx-32]
	fsub	QWORD PTR [eax-16]
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR _web+616
	add	edi, -3					; fffffffdH
	cmp	edx, edi
	jl	SHORT $LL55@void_test2
	mov	ecx, DWORD PTR _web+616
$LC54@void_test2:
	cmp	edx, ecx
	jge	SHORT $LN53@void_test2
	lea	edi, DWORD PTR _z$[ebp]
	sub	esi, ebx
	sub	edi, ebx
	lea	eax, DWORD PTR [ebx+edx*8]
	sub	ecx, edx
$LC7@void_test2:
	fld	QWORD PTR [eax+esi]
	add	eax, 8
	dec	ecx
	fsub	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax+edi-8]
	jne	SHORT $LC7@void_test2
	mov	ecx, DWORD PTR _web+616
$LN53@void_test2:

; 278  :       matvec_mul(side,z,s,web.dimension,SDIM);

	mov	eax, DWORD PTR _web+620
	push	ecx
	push	eax
	mov	eax, DWORD PTR _side$[ebp]
	lea	ecx, DWORD PTR _s$89308[ebp]
	push	ecx
	lea	edx, DWORD PTR _z$[ebp]
	push	edx
	push	eax
	call	_matvec_mul

; 279  :       matvec_mul(mat,s,q,web.dimension,web.dimension);

	mov	eax, DWORD PTR _web+620
	push	eax
	push	eax
	mov	eax, DWORD PTR _mat$[ebp]
	lea	ecx, DWORD PTR _q$89307[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$89308[ebp]
	push	edx
	push	eax
	call	_matvec_mul

; 280  :       for ( j = 0 ; j < web.dimension ; j++ )

	fldz
	mov	edx, DWORD PTR _web+620
	add	esp, 40					; 00000028H
	xor	ecx, ecx
	cmp	edx, 4
	jl	SHORT $LC57@void_test2
	lea	esi, DWORD PTR [edx-3]
$LN62@void_test2:

; 281  :          if ( q[j] < 0.0 ) retval = 2+j;

	fcom	QWORD PTR _q$89307[ebp+ecx*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN58@void_test2

; 278  :       matvec_mul(side,z,s,web.dimension,SDIM);

	lea	eax, DWORD PTR [ecx+2]
	mov	DWORD PTR _retval$[ebp], eax
$LN58@void_test2:

; 281  :          if ( q[j] < 0.0 ) retval = 2+j;

	fcom	QWORD PTR _q$89307[ebp+ecx*8+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN59@void_test2

; 278  :       matvec_mul(side,z,s,web.dimension,SDIM);

	lea	eax, DWORD PTR [ecx+3]
	mov	DWORD PTR _retval$[ebp], eax
$LN59@void_test2:

; 281  :          if ( q[j] < 0.0 ) retval = 2+j;

	fcom	QWORD PTR _q$89307[ebp+ecx*8+16]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN60@void_test2

; 278  :       matvec_mul(side,z,s,web.dimension,SDIM);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _retval$[ebp], eax
$LN60@void_test2:

; 281  :          if ( q[j] < 0.0 ) retval = 2+j;

	fcom	QWORD PTR _q$89307[ebp+ecx*8+24]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN61@void_test2

; 278  :       matvec_mul(side,z,s,web.dimension,SDIM);

	lea	eax, DWORD PTR [ecx+5]
	mov	DWORD PTR _retval$[ebp], eax
$LN61@void_test2:
	add	ecx, 4
	cmp	ecx, esi
	jl	SHORT $LN62@void_test2
$LC57@void_test2:

; 280  :       for ( j = 0 ; j < web.dimension ; j++ )

	cmp	ecx, edx
	jge	SHORT $LN86@void_test2
$LC4@void_test2:

; 281  :          if ( q[j] < 0.0 ) retval = 2+j;

	fcom	QWORD PTR _q$89307[ebp+ecx*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@void_test2
	lea	eax, DWORD PTR [ecx+2]
	mov	DWORD PTR _retval$[ebp], eax
$LN3@void_test2:

; 280  :       for ( j = 0 ; j < web.dimension ; j++ )

	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LC4@void_test2
$LN86@void_test2:

; 282  :     }
; 283  :     return retval;

	mov	eax, DWORD PTR _retval$[ebp]
	fstp	ST(0)
	pop	edi
	pop	esi
	pop	ebx

; 284  : 
; 285  : } // end void_test2()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@void_test2:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	xor	eax, eax
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_void_test2 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@LFEJPIND@Void?5violation?5by?5?$CFg?6?$AA@ ; `string'
PUBLIC	__real@3fd0000000000000
PUBLIC	_v$GSCopy$
PUBLIC	??_C@_0L@GGIMPHPM@SIMEQUI2?4C?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_void_test
EXTRN	_free_matrix:PROC
EXTRN	_erroutstring:PROC
EXTRN	_sprintf:PROC
EXTRN	_msg:DWORD
EXTRN	_kb_dmatrix:PROC
;	COMDAT ??_C@_0BG@LFEJPIND@Void?5violation?5by?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BG@LFEJPIND@Void?5violation?5by?5?$CFg?6?$AA@ DB 'Void violation b'
	DB	'y %g', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT ??_C@_0L@GGIMPHPM@SIMEQUI2?4C?$AA@
CONST	SEGMENT
??_C@_0L@GGIMPHPM@SIMEQUI2?4C?$AA@ DB 'SIMEQUI2.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _void_test
_TEXT	SEGMENT
_rr$ = -240						; size = 8
tv700 = -232						; size = 4
tv2033 = -228						; size = 4
tv2029 = -224						; size = 4
_bad_v$ = -220						; size = 4
_v$GSCopy$ = -216					; size = 4
_side$ = -212						; size = 4
_mat$ = -208						; size = 4
tv1011 = -204						; size = 4
_v_id$ = -204						; size = 4
tv2027 = -200						; size = 4
tv1049 = -200						; size = 4
_ss$ = -196						; size = 48
_lam$ = -148						; size = 48
_center$ = -100						; size = 48
_z$89391 = -52						; size = 48
_x$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_v$ = 8							; size = 4
_dim$ = 12						; size = 4
_void_test PROC						; COMDAT

; 320  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 321  :     REAL *x[MAXCOORD+1];
; 322  :     REAL ss[MAXCOORD];  /* squares of sides */
; 323  :     int k,j;
; 324  :     REAL rr;  /* square radius of void */
; 325  :     REAL center[MAXCOORD];
; 326  :     REAL lam[MAXCOORD];
; 327  :     vertex_id v_id,bad_v = NULLID;
; 328  :     REAL **mat = dmatrix(0,web.dimension-1,0,web.dimension-1);

	mov	eax, DWORD PTR _web+620
	push	ebx
	push	esi
	mov	esi, DWORD PTR _v$[ebp]
	push	edi
	push	328					; 00000148H
	push	OFFSET ??_C@_0L@GGIMPHPM@SIMEQUI2?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	eax
	push	0
	mov	DWORD PTR _v$GSCopy$[ebp], esi
	mov	DWORD PTR _bad_v$[ebp], 0
	call	_kb_dmatrix

; 329  :     REAL **side = dmatrix(0,SDIM-1,0,SDIM-1);

	push	329					; 00000149H
	mov	DWORD PTR _mat$[ebp], eax
	mov	eax, DWORD PTR _web+616
	push	OFFSET ??_C@_0L@GGIMPHPM@SIMEQUI2?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 330  : 
; 331  :     /* first, calculate center of void */
; 332  :     x[0] = get_coord(v[0]);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _web+12

; 333  :     for ( k = 1 ; k <= dim ; k++ )

	mov	edi, DWORD PTR _dim$[ebp]
	and	ecx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	add	ebx, DWORD PTR [ecx+edx+64]
	mov	edx, 1
	add	esp, 48					; 00000030H
	mov	DWORD PTR _side$[ebp], eax
	mov	DWORD PTR _x$[ebp], ebx
	cmp	edi, edx
	jl	SHORT $LN56@void_test
	mov	ebx, eax
	lea	eax, DWORD PTR _x$[ebp+4]
	sub	ebx, eax
	jmp	SHORT $LN29@void_test
	npad	9
$LL61@void_test:
	mov	esi, DWORD PTR _v$GSCopy$[ebp]
$LN29@void_test:

; 334  :       {  x[k] = get_coord(v[k]);

	mov	ecx, DWORD PTR [esi+edx*4]
	mov	eax, DWORD PTR _web+12
	mov	esi, DWORD PTR _dymem
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+esi+64]
	lea	esi, DWORD PTR [ecx+eax]

; 335  :           for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	mov	DWORD PTR _x$[ebp+edx*4], esi
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN28@void_test

; 333  :     for ( k = 1 ; k <= dim ; k++ )

	mov	eax, DWORD PTR _x$[ebp]
	lea	edi, DWORD PTR [ebx+edx*4]

; 335  :           for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _x$[ebp+edi]
	sub	esi, eax
	sub	edi, eax
$LL26@void_test:

; 336  :              side[k-1][j] = x[k][j] - x[0][j];

	fld	QWORD PTR [esi+eax]
	inc	ecx
	fsub	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax+edi-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL26@void_test

; 335  :           for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _dim$[ebp]
$LN28@void_test:

; 333  :     for ( k = 1 ; k <= dim ; k++ )

	inc	edx
	cmp	edx, edi
	jle	SHORT $LL61@void_test
	mov	ebx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _side$[ebp]
$LN56@void_test:

; 337  :       }
; 338  :     for ( k = 0 ; k < dim ; k++ )

	xor	esi, esi
	test	edi, edi
	jle	$LN21@void_test
	mov	ecx, DWORD PTR _mat$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv1049[ebp], ecx
	mov	DWORD PTR tv1011[ebp], eax
	npad	7
$LL59@void_test:

; 339  :       { 
; 340  :          for ( j = 0 ; j <= k ; j++ )

	xor	edi, edi
	test	esi, esi
	js	SHORT $LN18@void_test
	mov	ebx, DWORD PTR _mat$[ebp]
	npad	4
$LL57@void_test:

; 341  :             mat[j][k] = mat[k][j] = SDIM_dot(side[j],side[k]);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR tv1049[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR [eax+ebx]
	push	ecx
	push	edx
	call	_dot
	mov	eax, DWORD PTR tv1049[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ebx]
	fst	QWORD PTR [ecx+edi*8]
	mov	eax, DWORD PTR tv1011[ebp]
	fstp	QWORD PTR [edx+esi*8]
	inc	edi
	add	esp, 12					; 0000000cH
	add	ebx, 4
	cmp	edi, esi
	jle	SHORT $LL57@void_test

; 339  :       { 
; 340  :          for ( j = 0 ; j <= k ; j++ )

	mov	ebx, DWORD PTR _x$[ebp]
$LN18@void_test:

; 342  :          ss[k] = mat[k][k];

	mov	ecx, DWORD PTR tv1049[ebp]
	mov	edx, DWORD PTR [ecx]
	fld	QWORD PTR [edx+esi*8]
	inc	esi
	fstp	QWORD PTR _ss$[ebp+esi*8-8]
	add	ecx, 4
	mov	DWORD PTR tv1049[ebp], ecx
	cmp	esi, DWORD PTR _dim$[ebp]
	jl	SHORT $LL59@void_test

; 337  :       }
; 338  :     for ( k = 0 ; k < dim ; k++ )

	mov	edi, DWORD PTR _dim$[ebp]
$LN21@void_test:

; 343  :       }
; 344  :     mat_inv(mat,dim);

	mov	esi, DWORD PTR _mat$[ebp]
	push	edi
	push	esi
	call	_mat_inv

; 345  :     matvec_mul(mat,ss,lam,dim,dim);

	push	edi
	push	edi
	lea	eax, DWORD PTR _lam$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ss$[ebp]
	push	ecx
	push	esi
	call	_matvec_mul

; 346  :     rr = dot(lam,ss,dim)/4;

	push	edi
	lea	edx, DWORD PTR _ss$[ebp]
	push	edx
	lea	eax, DWORD PTR _lam$[ebp]
	push	eax
	call	_dot
	fmul	QWORD PTR __real@3fd0000000000000

; 347  :     vec_mat_mul(lam,side,center,dim,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR _side$[ebp]
	push	ecx
	fstp	QWORD PTR _rr$[ebp]
	push	edi
	lea	edx, DWORD PTR _center$[ebp]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _lam$[ebp]
	push	ecx
	call	_vec_mat_mul

; 348  :     for ( k = 0 ; k < SDIM ; k++ )

	fld	QWORD PTR __real@3fe0000000000000
	mov	eax, DWORD PTR _web+616
	add	esp, 60					; 0000003cH
	xor	ecx, ecx
	cmp	eax, 4
	jl	SHORT $LC50@void_test

; 349  :       center[k] = x[0][k] + center[k]/2;

	lea	edx, DWORD PTR _center$[ebp]
	lea	esi, DWORD PTR _center$[ebp+8]
	lea	edi, DWORD PTR [eax-3]
	sub	edx, ebx
	lea	eax, DWORD PTR [ebx+16]
	sub	esi, ebx
$LN60@void_test:
	fld	QWORD PTR _center$[ebp+ecx*8]
	add	ecx, 4
	fmul	ST(0), ST(1)
	add	eax, 32					; 00000020H
	fadd	QWORD PTR [eax-48]
	fstp	QWORD PTR _center$[ebp+ecx*8-32]
	fld	QWORD PTR _center$[ebp+ecx*8-24]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR _center$[ebp+ecx*8-24]
	fld	QWORD PTR [edx+eax-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [edx+eax-32]
	fld	QWORD PTR [esi+eax-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [esi+eax-32]
	cmp	ecx, edi
	jl	SHORT $LN60@void_test
	mov	eax, DWORD PTR _web+616
$LC50@void_test:

; 348  :     for ( k = 0 ; k < SDIM ; k++ )

	cmp	ecx, eax
	jge	SHORT $LN74@void_test
	lea	edx, DWORD PTR _center$[ebp]
	sub	ebx, edx
$LC17@void_test:

; 349  :       center[k] = x[0][k] + center[k]/2;

	fld	QWORD PTR _center$[ebp+ecx*8]
	lea	edx, DWORD PTR [ebx+ecx*8]
	fmul	ST(0), ST(1)
	inc	ecx
	fadd	QWORD PTR _center$[ebp+edx]
	fstp	QWORD PTR _center$[ebp+ecx*8-8]
	cmp	ecx, eax
	jl	SHORT $LC17@void_test
$LN74@void_test:

; 350  : 
; 351  :     /* now see if any other vertices are in the void */
; 352  :     FOR_ALL_VERTICES(v_id)

	mov	ebx, DWORD PTR _web+48
	fstp	ST(0)
	mov	DWORD PTR _v_id$[ebp], ebx
	test	ebx, 268435456				; 10000000H
	je	$LN12@void_test
	mov	edx, DWORD PTR _web+12
	npad	2
$LL14@void_test:
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR tv700[ebp], edi
	je	$LN13@void_test

; 353  :       { REAL *y;
; 354  :          REAL z[MAXCOORD];
; 355  : 
; 356  :          for ( k = 0 ; k <= dim ; k++ )

	mov	ecx, DWORD PTR _dim$[ebp]
	xor	eax, eax
	test	ecx, ecx
	js	SHORT $LN55@void_test
	npad	2
$LL9@void_test:

; 357  :             if ( equal_id(v_id,v[k]) ) break;

	mov	esi, DWORD PTR _v$GSCopy$[ebp]
	cmp	ebx, DWORD PTR [esi+eax*4]
	je	SHORT $LN40@void_test

; 353  :       { REAL *y;
; 354  :          REAL z[MAXCOORD];
; 355  : 
; 356  :          for ( k = 0 ; k <= dim ; k++ )

	inc	eax
	cmp	eax, ecx
	jle	SHORT $LL9@void_test

; 358  :          if ( k <= dim ) continue;  /* skip vertices in facet */

	jmp	SHORT $LN55@void_test
$LN40@void_test:
	cmp	eax, ecx
	jle	$LN13@void_test
$LN55@void_test:

; 359  : 
; 360  :          y = get_coord(v_id);

	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR [eax+ecx+64]
	add	esi, DWORD PTR [edi+edx]

; 361  :          for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR _web+616
	xor	ecx, ecx
	cmp	edx, 4
	jl	$LC53@void_test

; 362  :             z[j] = y[j] - center[j];

	lea	edi, DWORD PTR [edx-3]
	mov	edx, esi
	neg	edx
	lea	ebx, DWORD PTR _center$[ebp+edx]
	mov	DWORD PTR tv2027[ebp], ebx
	lea	ebx, DWORD PTR _z$89391[ebp+edx]
	mov	DWORD PTR tv2029[ebp], ebx
	lea	ebx, DWORD PTR _center$[ebp+edx+8]
	lea	edx, DWORD PTR _z$89391[ebp+edx+8]
	lea	eax, DWORD PTR [esi+16]
	mov	DWORD PTR tv2033[ebp], edx
	npad	7
$LL58@void_test:
	fld	QWORD PTR [eax-16]
	mov	edx, DWORD PTR tv2027[ebp]
	fsub	QWORD PTR _center$[ebp+ecx*8]
	add	ecx, 4
	add	eax, 32					; 00000020H
	fstp	QWORD PTR _z$89391[ebp+ecx*8-32]
	fld	QWORD PTR [eax-40]
	fsub	QWORD PTR _center$[ebp+ecx*8-24]
	fstp	QWORD PTR _z$89391[ebp+ecx*8-24]
	fld	QWORD PTR [eax-32]
	fsub	QWORD PTR [edx+eax-32]
	mov	edx, DWORD PTR tv2029[ebp]
	fstp	QWORD PTR [edx+eax-32]
	mov	edx, DWORD PTR tv2033[ebp]
	fld	QWORD PTR [eax-24]
	fsub	QWORD PTR [ebx+eax-32]
	fstp	QWORD PTR [edx+eax-32]
	cmp	ecx, edi
	jl	SHORT $LL58@void_test
	mov	edi, DWORD PTR tv700[ebp]
	mov	ebx, DWORD PTR _v_id$[ebp]
	mov	edx, DWORD PTR _web+616
$LC53@void_test:

; 361  :          for ( j = 0 ; j < SDIM ; j++ )

	cmp	ecx, edx
	jge	SHORT $LN52@void_test
	lea	eax, DWORD PTR _center$[ebp]
	sub	esi, eax
$LC4@void_test:
	lea	eax, DWORD PTR _center$[ebp+ecx*8]

; 362  :             z[j] = y[j] - center[j];

	fld	QWORD PTR [esi+eax]
	inc	ecx
	fsub	QWORD PTR [eax]
	fstp	QWORD PTR _z$89391[ebp+ecx*8-8]
	cmp	ecx, edx
	jl	SHORT $LC4@void_test
$LN52@void_test:

; 363  :          if ( SDIM_dot(z,z) >= rr - 1e-10 ) continue;

	push	edx
	lea	ecx, DWORD PTR _z$89391[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fld	QWORD PTR _rr$[ebp]
	fsub	QWORD PTR __real@3ddb7cdfd9d7bdbb
	add	esp, 12					; 0000000cH
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN1@void_test
	mov	edx, DWORD PTR _web+12
$LN13@void_test:

; 350  : 
; 351  :     /* now see if any other vertices are in the void */
; 352  :     FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [edi+edx]
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR _v_id$[ebp], ebx
	test	ebx, 268435456				; 10000000H
	jne	$LL14@void_test

; 357  :             if ( equal_id(v_id,v[k]) ) break;

	jmp	SHORT $LN12@void_test
$LN1@void_test:

; 364  : #if 1        
; 365  : sprintf(msg,"Void violation by %g\n",(DOUBLE)(-SDIM_dot(z,z) + rr));

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _z$89391[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	fsubr	QWORD PTR _rr$[ebp]
	mov	ecx, DWORD PTR _msg
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BG@LFEJPIND@Void?5violation?5by?5?$CFg?6?$AA@
	push	ecx
	call	_sprintf

; 366  : erroutstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_erroutstring
	add	esp, 20					; 00000014H

; 367  : #endif
; 368  :          bad_v = v_id;

	mov	DWORD PTR _bad_v$[ebp], ebx
$LN12@void_test:

; 369  :          break;
; 370  :       }
; 371  :   free_matrix(side);

	mov	eax, DWORD PTR _side$[ebp]
	push	eax
	call	_free_matrix

; 372  :   free_matrix(mat);

	mov	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	call	_free_matrix

; 373  :   return bad_v;
; 374  : } // end void_test()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, DWORD PTR _bad_v$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_void_test ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@CAKPIPLA@Face?5doesn?8t?5have?5valid?5opposite@ ; `string'
PUBLIC	??_C@_0EE@LGLDLGEN@Simplex?5consolidation?5equiangula@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_simplex_equiangulate
EXTRN	_top_timestamp:DWORD
EXTRN	_global_timestamp:DWORD
EXTRN	_outstring:PROC
EXTRN	_dup_facet:PROC
EXTRN	_free_element:PROC
EXTRN	_F_BOUNDARY_ATTR:DWORD
EXTRN	_equal_constr:PROC
EXTRN	_bsearch:PROC
EXTRN	_kb_error:PROC
EXTRN	_valid_element:PROC
EXTRN	_qsort:PROC
EXTRN	_kb_temp_calloc:PROC
;	COMDAT ??_C@_0CK@CAKPIPLA@Face?5doesn?8t?5have?5valid?5opposite@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CK@CAKPIPLA@Face?5doesn?8t?5have?5valid?5opposite@ DB 'Face doesn'''
	DB	't have valid opposite facets.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@LGLDLGEN@Simplex?5consolidation?5equiangula@
CONST	SEGMENT
??_C@_0EE@LGLDLGEN@Simplex?5consolidation?5equiangula@ DB 'Simplex consol'
	DB	'idation equiangulation only for surface dimension 3.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\simequi2.c
CONST	ENDS
;	COMDAT _simplex_equiangulate
_TEXT	SEGMENT
tv1301 = -104						; size = 8
tv1821 = -100						; size = 4
tv1230 = -100						; size = 4
tv1220 = -100						; size = 4
tv1094 = -100						; size = 4
_flipcount$ = -96					; size = 4
tv2000 = -92						; size = 4
tv1289 = -92						; size = 4
_f_id$ = -92						; size = 4
tv769 = -88						; size = 4
_fcount$ = -88						; size = 4
tv1813 = -84						; size = 4
tv1286 = -84						; size = 4
_fl$ = -84						; size = 4
tv1779 = -80						; size = 4
_ff_id$ = -80						; size = 4
_same$ = -80						; size = 4
_j$ = -76						; size = 4
tv1811 = -72						; size = 4
_i$ = -72						; size = 4
_opp$89076 = -72					; size = 4
_tetra_tmp$ = -68					; size = 40
_newf$89116 = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_simplex_equiangulate PROC				; COMDAT

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 43   :   int i,j,k;
; 44   :   facet_id f_id,ff_id;
; 45   :   struct fstruct *fl,*f1;  /* pointer into face list */
; 46   :   struct fstruct tetra_tmp;
; 47   :   int fcount;
; 48   :   int same;
; 49   :   int flipcount = 0;
; 50   :   vertex_id *v;
; 51   : 
; 52   :     /* create face list with pairs of opposite vertices */
; 53   :     fcount = web.skel[FACET].count*(web.dimension+1);

	mov	ebx, DWORD PTR _web+620
	push	esi
	inc	ebx
	imul	ebx, DWORD PTR _web+288
	push	edi

; 54   :     facelist = (struct fstruct *)temp_calloc(fcount,sizeof(struct fstruct));

	push	54					; 00000036H
	push	OFFSET ??_C@_0L@GGIMPHPM@SIMEQUI2?4C?$AA@
	push	40					; 00000028H
	push	ebx
	mov	DWORD PTR _flipcount$[ebp], 0
	mov	DWORD PTR _fcount$[ebp], ebx
	call	_kb_temp_calloc

; 55   :     fl = facelist;
; 56   :     FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	add	esp, 16					; 00000010H
	mov	DWORD PTR _facelist, eax
	mov	DWORD PTR _fl$[ebp], eax
	mov	DWORD PTR _f_id$[ebp], edx
	test	edx, 268435456				; 10000000H
	je	$LN79@simplex_eq
	npad	6
$LL81@simplex_eq:
	mov	eax, DWORD PTR _web+236
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	esi, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	mov	DWORD PTR tv1094[ebp], ecx
	je	$LN80@simplex_eq

; 57   :       {
; 58   :          int opp; /* which vertex opposite */
; 59   :          vertex_id *fv = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _web+328
	mov	edi, DWORD PTR _dymem
	mov	edi, DWORD PTR [eax+edi+304]

; 60   : 
; 61   :          unset_attr(f_id,NEWFACET); /* clear marks */

	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	eax, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR [eax+12]
	and	DWORD PTR [eax+8], -5			; fffffffbH
	mov	DWORD PTR [eax+12], edx

; 62   :          for ( opp = 0 ; opp <= web.dimension ; opp++ )

	mov	eax, DWORD PTR _web+620
	add	edi, esi
	mov	DWORD PTR _opp$89076[ebp], 0
	test	eax, eax
	js	$LN80@simplex_eq
	mov	ecx, DWORD PTR _opp$89076[ebp]
	mov	edx, DWORD PTR _fl$[ebp]
	npad	2
$LL76@simplex_eq:

; 64   :               /* copy face in sorted order vertices */
; 65   :               for ( i = 0,j = 0 ; i <= web.dimension ; i++ )

	xor	esi, esi
	mov	ebx, ecx
	mov	DWORD PTR _j$[ebp], esi
	test	eax, eax
	js	SHORT $LN148@simplex_eq

; 63   :             { int flips = opp;  /* track orientation */

	lea	ecx, DWORD PTR [edx-4]
	mov	DWORD PTR tv1779[ebp], ecx
	mov	ecx, DWORD PTR _opp$89076[ebp]
$LL73@simplex_eq:

; 66   :                  { if ( i == opp ) continue;

	cmp	esi, ecx
	je	SHORT $LN72@simplex_eq

; 67   :                     k = j;

	mov	ecx, DWORD PTR _j$[ebp]

; 68   :                     while ( (k > 0) && (fv[i] < fl->v[k-1]) )

	test	ecx, ecx
	jle	SHORT $LN68@simplex_eq

; 67   :                     k = j;

	mov	eax, DWORD PTR tv1779[ebp]
$LL69@simplex_eq:

; 68   :                     while ( (k > 0) && (fv[i] < fl->v[k-1]) )

	mov	edx, DWORD PTR [eax]
	cmp	DWORD PTR [edi+esi*4], edx
	jae	SHORT $LN146@simplex_eq

; 69   :                       { fl->v[k] = fl->v[k-1];

	mov	DWORD PTR [eax+4], edx

; 70   :                          k--; flips++;

	dec	ecx
	sub	eax, 4
	inc	ebx
	test	ecx, ecx
	jg	SHORT $LL69@simplex_eq
$LN146@simplex_eq:

; 68   :                     while ( (k > 0) && (fv[i] < fl->v[k-1]) )

	mov	edx, DWORD PTR _fl$[ebp]
$LN68@simplex_eq:

; 71   :                       }
; 72   :                     fl->v[k] = fv[i];

	mov	eax, DWORD PTR [edi+esi*4]

; 73   :                     j++;

	inc	DWORD PTR _j$[ebp]
	add	DWORD PTR tv1779[ebp], 4
	mov	DWORD PTR [edx+ecx*4], eax
	mov	eax, DWORD PTR _web+620
	mov	ecx, DWORD PTR _opp$89076[ebp]
$LN72@simplex_eq:

; 64   :               /* copy face in sorted order vertices */
; 65   :               for ( i = 0,j = 0 ; i <= web.dimension ; i++ )

	inc	esi
	cmp	esi, eax
	jle	SHORT $LL73@simplex_eq
	jmp	SHORT $LN71@simplex_eq
$LN148@simplex_eq:
	mov	ecx, DWORD PTR _opp$89076[ebp]
$LN71@simplex_eq:

; 74   :                  }
; 75   :               /* add opposite vertex in appropriate slot */
; 76   :               fl->opp[flips & 1] = fv[opp];

	mov	esi, DWORD PTR [edi+ecx*4]
	mov	eax, ebx
	and	eax, 1
	mov	DWORD PTR [edx+eax*4+24], esi

; 77   :               fl->f_id[flips & 1] = f_id;

	mov	esi, DWORD PTR _f_id$[ebp]
	mov	DWORD PTR [edx+eax*4+32], esi
	mov	eax, DWORD PTR _web+620
	inc	ecx

; 78   :               fl++;

	add	edx, 40					; 00000028H
	mov	DWORD PTR _fl$[ebp], edx
	mov	DWORD PTR _opp$89076[ebp], ecx
	cmp	ecx, eax
	jle	SHORT $LL76@simplex_eq

; 62   :          for ( opp = 0 ; opp <= web.dimension ; opp++ )

	mov	ecx, DWORD PTR tv1094[ebp]
	mov	ebx, DWORD PTR _fcount$[ebp]
$LN80@simplex_eq:

; 55   :     fl = facelist;
; 56   :     FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _f_id$[ebp], edx
	test	edx, 268435456				; 10000000H
	jne	$LL81@simplex_eq
	mov	eax, DWORD PTR _facelist
$LN79@simplex_eq:

; 79   :             }
; 80   :       }
; 81   : 
; 82   :     /* sort face list */
; 83   :     qsort((char*)facelist,fcount,sizeof(struct fstruct),FCAST scomp);

	push	OFFSET _scomp
	push	40					; 00000028H
	push	ebx
	push	eax
	call	_qsort
	mov	esi, DWORD PTR _facelist

; 84   : 
; 85   :     /* join pairs of faces */
; 86   :     /* saving those faces with exactly two neighbors */
; 87   :     same = 1; /* number of facets face j has so far */
; 88   :     for ( i = 1, j = 0 ; i < fcount ; i++ )

	xor	eax, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _same$[ebp], 1
	mov	DWORD PTR _j$[ebp], eax
	cmp	ebx, 1
	jle	$LN65@simplex_eq

; 79   :             }
; 80   :       }
; 81   : 
; 82   :     /* sort face list */
; 83   :     qsort((char*)facelist,fcount,sizeof(struct fstruct),FCAST scomp);

	mov	ecx, DWORD PTR _fcount$[ebp]
	mov	edi, 32					; 00000020H
	dec	ecx
	mov	DWORD PTR tv1811[ebp], eax
	mov	DWORD PTR tv1813[ebp], 40		; 00000028H
	mov	DWORD PTR tv2000[ebp], edi
	lea	ebx, DWORD PTR [eax+64]
	mov	DWORD PTR tv769[ebp], ecx
	npad	6
$LL67@simplex_eq:

; 89   :       { 
; 90   :          if ( scomp((vertex_id *)(facelist+j),(vertex_id *)(facelist+i)) == 0 )

	mov	eax, DWORD PTR tv1813[ebp]
	add	eax, esi
	push	eax
	mov	DWORD PTR tv1821[ebp], eax
	mov	eax, DWORD PTR tv1811[ebp]
	add	eax, esi
	push	eax
	call	_scomp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN64@simplex_eq

; 91   :             { /* same face */
; 92   :               for ( k = 0 ; k < 2 ; k++ )
; 93   :                  if ( valid_id(facelist[i].opp[k]) )

	mov	eax, DWORD PTR [ebx+esi]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN62@simplex_eq

; 94   :                  {  facelist[j].opp[k] = facelist[i].opp[k];

	mov	DWORD PTR [edi+esi-8], eax

; 95   :                      facelist[j].f_id[k] = facelist[i].f_id[k];

	mov	eax, DWORD PTR _facelist
	mov	ecx, DWORD PTR [ebx+eax+8]
	mov	DWORD PTR [edi+eax], ecx
	mov	esi, DWORD PTR _facelist
$LN62@simplex_eq:

; 91   :             { /* same face */
; 92   :               for ( k = 0 ; k < 2 ; k++ )
; 93   :                  if ( valid_id(facelist[i].opp[k]) )

	mov	eax, DWORD PTR [ebx+esi+4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN136@simplex_eq

; 94   :                  {  facelist[j].opp[k] = facelist[i].opp[k];

	mov	DWORD PTR [edi+esi-4], eax

; 95   :                      facelist[j].f_id[k] = facelist[i].f_id[k];

	mov	eax, DWORD PTR _facelist
	mov	edx, DWORD PTR [ebx+eax+12]
	mov	DWORD PTR [edi+eax+4], edx
	mov	esi, DWORD PTR _facelist
$LN136@simplex_eq:

; 96   :                  }
; 97   :               same++;

	inc	DWORD PTR _same$[ebp]

; 98   :             }
; 99   :          else /* new face */

	jmp	SHORT $LN66@simplex_eq
$LN64@simplex_eq:

; 100  :          { if ( same==2 ) j++;

	cmp	DWORD PTR _same$[ebp], 2
	jne	SHORT $LN58@simplex_eq
	inc	DWORD PTR _j$[ebp]
	add	edi, 40					; 00000028H
	add	DWORD PTR tv1811[ebp], 40		; 00000028H
	mov	DWORD PTR tv2000[ebp], edi
$LN58@simplex_eq:

; 101  :             facelist[j] = facelist[i];

	mov	edi, DWORD PTR tv1811[ebp]
	add	edi, esi
	mov	esi, DWORD PTR tv1821[ebp]
	mov	ecx, 10					; 0000000aH
	rep movsd

; 102  :             same = 1;

	mov	esi, DWORD PTR _facelist
	mov	edi, DWORD PTR tv2000[ebp]
	mov	DWORD PTR _same$[ebp], 1
$LN66@simplex_eq:

; 84   : 
; 85   :     /* join pairs of faces */
; 86   :     /* saving those faces with exactly two neighbors */
; 87   :     same = 1; /* number of facets face j has so far */
; 88   :     for ( i = 1, j = 0 ; i < fcount ; i++ )

	add	DWORD PTR tv1813[ebp], 40		; 00000028H
	add	ebx, 40					; 00000028H
	dec	DWORD PTR tv769[ebp]
	jne	$LL67@simplex_eq
	mov	eax, DWORD PTR _j$[ebp]
$LN65@simplex_eq:

; 103  :          }
; 104  :       }
; 105  :     fcount = j;  /* number of unique faces */

	mov	DWORD PTR _fcount$[ebp], eax

; 106  : 
; 107  :     /* look for all void-violating opposite vertices */
; 108  :     for ( fl = facelist, i = 0 ; i < fcount ; i++,fl++ )

	mov	DWORD PTR _i$[ebp], 0
	test	eax, eax
	jle	$LN141@simplex_eq
	npad	7
$LL57@simplex_eq:

; 109  :       { int retval;
; 110  :          facet_id newf[MAXCOORD];
; 111  : 
; 112  :          /* see if facets involved are legit */
; 113  :          if ( !valid_element(fl->f_id[0]) ) continue;

	mov	ecx, DWORD PTR [esi+32]
	push	ecx
	call	_valid_element
	add	esp, 4
	test	eax, eax
	je	$LN56@simplex_eq

; 114  :          if ( !valid_element(fl->f_id[1]) ) continue;

	mov	edx, DWORD PTR [esi+36]
	push	edx
	call	_valid_element
	add	esp, 4
	test	eax, eax
	je	$LN56@simplex_eq

; 115  :          if ( get_fattr(fl->f_id[0]) & (NEWFACET|FIXED) ) continue;

	mov	edi, DWORD PTR [esi+32]
	mov	edx, DWORD PTR _web+236
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 68					; 00000044H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN56@simplex_eq

; 116  :          if ( get_fattr(fl->f_id[1]) & (NEWFACET|FIXED) ) continue;

	mov	ecx, DWORD PTR [esi+36]
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 68					; 00000044H
	xor	edx, edx
	or	eax, edx
	jne	$LN56@simplex_eq

; 117  : 
; 118  :          if ( !valid_id(fl->f_id[0]) || !valid_id(fl->f_id[1]) )

	test	edi, 268435456				; 10000000H
	je	$LN49@simplex_eq
	test	ecx, 268435456				; 10000000H
	je	$LN49@simplex_eq

; 121  :               continue;
; 122  :             }
; 123  : 
; 124  :          retval = void_test2(fl);

	push	esi
	call	_void_test2

; 125  :          switch ( retval )

	mov	ecx, eax
	add	esp, 4
	sub	ecx, 0
	je	$LN56@simplex_eq
	dec	ecx
	je	$LN45@simplex_eq

; 152  :                   break;
; 153  :             default: /* outside side j, retval = 2 + j */
; 154  :                   if ( web.dimension != 3 )

	cmp	DWORD PTR _web+620, 3
	je	SHORT $LN29@simplex_eq

; 155  :                   { kb_error(1875,"Simplex consolidation equiangulation only for surface dimension 3.\n",
; 156  :                         WARNING);

	push	2
	push	OFFSET ??_C@_0EE@LGLDLGEN@Simplex?5consolidation?5equiangula@
	push	1875					; 00000753H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 157  :                      break;

	jmp	$LN56@simplex_eq
$LN29@simplex_eq:

; 158  :                   }
; 159  :                   j = retval-2;

	lea	edx, DWORD PTR [eax-2]
	mov	DWORD PTR _j$[ebp], edx

; 160  :                   /* look for third tetra on edge */
; 161  :                   for ( i = k = 0 ; i < web.dimension ; i++ ) 

	xor	eax, eax
	lea	ecx, DWORD PTR _tetra_tmp$[ebp]
$LL28@simplex_eq:

; 162  :                      if ( i != j ) tetra_tmp.v[k++] = fl->v[i];

	cmp	eax, edx
	je	SHORT $LN27@simplex_eq
	mov	edi, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx], edi
	add	ecx, 4
$LN27@simplex_eq:

; 160  :                   /* look for third tetra on edge */
; 161  :                   for ( i = k = 0 ; i < web.dimension ; i++ ) 

	inc	eax
	cmp	eax, 3
	jl	SHORT $LL28@simplex_eq

; 163  :                   for ( i = web.dimension-1 ; i > 0 ; i-- )

	mov	ecx, 2
	lea	eax, DWORD PTR _tetra_tmp$[ebp+4]
$LL24@simplex_eq:

; 164  :                      if ( fl->opp[0] > tetra_tmp.v[i-1] ) break; 

	mov	edx, DWORD PTR [eax]
	cmp	DWORD PTR [esi+24], edx
	ja	SHORT $LN157@simplex_eq

; 165  :                      else tetra_tmp.v[i] = tetra_tmp.v[i-1];

	mov	DWORD PTR [eax+4], edx
	dec	ecx
	sub	eax, 4
	test	ecx, ecx
	jg	SHORT $LL24@simplex_eq
$LN157@simplex_eq:

; 166  :                   tetra_tmp.v[i] = fl->opp[0]; 

	mov	edx, DWORD PTR [esi+24]

; 167  :                   f1 = (struct fstruct *)bsearch((char*)&tetra_tmp,(char*)facelist,fcount,
; 168  :                                 sizeof(struct fstruct), FCAST scomp);

	mov	eax, DWORD PTR _fcount$[ebp]
	push	OFFSET _scomp
	push	40					; 00000028H
	mov	DWORD PTR _tetra_tmp$[ebp+ecx*4], edx
	mov	DWORD PTR _i$[ebp], ecx
	mov	ecx, DWORD PTR _facelist
	push	eax
	push	ecx
	lea	edx, DWORD PTR _tetra_tmp$[ebp]
	push	edx
	call	_bsearch
	add	esp, 20					; 00000014H

; 169  :                   if ( f1 == NULL ) break;

	test	eax, eax
	je	$LN56@simplex_eq

; 170  : 
; 171  :                   ff_id = f1->f_id[0];

	mov	ecx, DWORD PTR [eax+32]
	mov	edx, ecx
	mov	DWORD PTR _ff_id$[ebp], ecx

; 172  :                   if ( equal_id(ff_id,fl->f_id[0]) ) ff_id = f1->f_id[1];

	cmp	edx, DWORD PTR [esi+32]
	jne	SHORT $LN18@simplex_eq
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _ff_id$[ebp], edx
$LN18@simplex_eq:

; 173  :                   if ( equal_id(ff_id,fl->f_id[1]) ) ff_id = f1->f_id[0];

	cmp	edx, DWORD PTR [esi+36]
	jne	SHORT $LN17@simplex_eq
	mov	edx, ecx
	mov	DWORD PTR _ff_id$[ebp], edx
$LN17@simplex_eq:

; 174  :                   v = get_facet_vertices(ff_id);

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR _web+328
	mov	ebx, DWORD PTR _dymem
	mov	edi, edx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+eax]
	add	eax, DWORD PTR [ecx+ebx+304]

; 175  :                   for ( i = 0 ; i <= web.dimension ; i++ )

	cmp	DWORD PTR _web+620, 0
	mov	DWORD PTR tv1286[ebp], edi
	mov	DWORD PTR _i$[ebp], 0
	jl	$LN56@simplex_eq
	mov	ecx, DWORD PTR _i$[ebp]
$LL16@simplex_eq:

; 176  :                      if ( equal_id(v[i],fl->opp[1]) ) break;

	mov	ebx, DWORD PTR [esi+28]
	cmp	DWORD PTR [eax+ecx*4], ebx
	je	SHORT $LN118@simplex_eq

; 175  :                   for ( i = 0 ; i <= web.dimension ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR _web+620
	jle	SHORT $LL16@simplex_eq
	mov	DWORD PTR _i$[ebp], ecx

; 177  :                   if ( i > web.dimension ) break; /* third tetra doesn't fill wedge */

	jmp	$LN56@simplex_eq
$LN118@simplex_eq:

; 175  :                   for ( i = 0 ; i <= web.dimension ; i++ )

	mov	DWORD PTR _i$[ebp], ecx

; 177  :                   if ( i > web.dimension ) break; /* third tetra doesn't fill wedge */

	cmp	ecx, DWORD PTR _web+620
	jg	$LN56@simplex_eq

; 178  : 
; 179  :                   /* now have third tetra */
; 180  :                   if ( !valid_element(ff_id) ) continue;  /* test for contamination */

	push	edx
	call	_valid_element
	add	esp, 4
	test	eax, eax
	je	$LN56@simplex_eq

; 181  :                   if ( get_fattr(ff_id) & (NEWFACET|FIXED) ) continue;

	mov	ecx, DWORD PTR _web+236
	mov	eax, DWORD PTR [edi+ecx]
	mov	edx, DWORD PTR [eax+12]
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR tv1289[ebp], eax
	mov	eax, edi
	mov	DWORD PTR tv1301[ebp+4], edx
	and	eax, 68					; 00000044H
	xor	edx, edx
	or	eax, edx
	jne	$LN56@simplex_eq

; 182  :                   /* check equality of facet constraints and stuff  */
; 183  :                   /* test for equal density */
; 184  :                   if ( (get_fattr(fl->f_id[0])&DENSITY) || (get_fattr(fl->f_id[1])&DENSITY)
; 185  :                      ||  (get_fattr(ff_id)&DENSITY) )

	mov	eax, DWORD PTR [esi+32]
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ebx+8]
	and	eax, 16					; 00000010H
	or	eax, edx
	mov	DWORD PTR tv1230[ebp], ebx
	jne	SHORT $LN151@simplex_eq
	mov	edx, DWORD PTR [esi+36]
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 16					; 00000010H
	xor	ebx, ebx
	or	eax, ebx
	jne	SHORT $LN149@simplex_eq
	and	edi, 16					; 00000010H
	or	edi, eax
	je	SHORT $LN150@simplex_eq
$LN149@simplex_eq:
	mov	ebx, DWORD PTR tv1230[ebp]
$LN151@simplex_eq:

; 186  :                      if ( (fabs(get_facet_density(fl->f_id[0]) - get_facet_density(fl->f_id[1])) > 1e-10) 
; 187  :                         || (fabs(get_facet_density(fl->f_id[0]) - get_facet_density(ff_id)) > 1e-10)  )

	mov	edx, DWORD PTR [esi+36]
	fld	QWORD PTR [ebx+32]
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	fsub	QWORD PTR [ecx+32]
	fabs
	fld	QWORD PTR __real@3ddb7cdfd9d7bdbb
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jnp	$LN159@simplex_eq
	mov	eax, DWORD PTR tv1289[ebp]
	fld	QWORD PTR [ebx+32]
	fsub	QWORD PTR [eax+32]
	fabs
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN56@simplex_eq
$LN150@simplex_eq:

; 188  :                          break;
; 189  :                   /* test for equal constraints */
; 190  :                   if ( !equal_constr(fl->f_id[0],fl->f_id[1]) ) break;

	mov	eax, DWORD PTR [esi+32]
	push	edx
	push	eax
	call	_equal_constr
	add	esp, 8
	test	eax, eax
	je	$LN56@simplex_eq

; 191  :                   if ( !equal_constr(fl->f_id[0],ff_id) ) break;

	mov	ecx, DWORD PTR _ff_id$[ebp]
	mov	edx, DWORD PTR [esi+32]
	push	ecx
	push	edx
	call	_equal_constr
	add	esp, 8
	test	eax, eax
	je	$LN56@simplex_eq

; 192  :                   /* test for equal boundary */
; 193  :                   if (  get_facet_boundary(fl->f_id[0]) != get_facet_boundary(fl->f_id[1]) )

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN153@simplex_eq
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ebx, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR _web+236
	and	ebx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+ebx*4]
	mov	ebx, DWORD PTR [ebx+eax]
	and	edx, 134217727				; 07ffffffH
	imul	ebx, 136				; 00000088H
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	edi, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR _web+776
	imul	edi, 136				; 00000088H
	add	edi, edx
	add	ebx, edx
	cmp	edi, ebx
	jne	$LN56@simplex_eq

; 194  :                     break;
; 195  :                   if (  get_facet_boundary(fl->f_id[0]) != get_facet_boundary(ff_id) )

	mov	ebx, DWORD PTR tv1286[ebp]
	mov	ecx, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [ecx+eax]
	imul	eax, 136				; 00000088H
	add	eax, edx
	cmp	edi, eax
	jne	$LN56@simplex_eq
$LN153@simplex_eq:

; 196  :                     break;
; 197  : 
; 198  :                   free_element(ff_id);

	mov	ecx, DWORD PTR _ff_id$[ebp]
	mov	ebx, DWORD PTR _j$[ebp]
	push	ecx
	call	_free_element

; 199  :                   v = get_facet_vertices(fl->f_id[0]);

	mov	edx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR _web+236

; 200  :                   v[0] = fl->v[(j+web.dimension-1) % web.dimension];

	mov	edi, DWORD PTR _web+620
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+eax+304]
	lea	eax, DWORD PTR [edi+ebx-1]
	cdq
	idiv	edi
	add	esp, 4
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx], edx

; 201  :                   v[1] = fl->v[j];

	mov	eax, DWORD PTR [esi+ebx*4]
	mov	DWORD PTR [ecx+4], eax

; 202  :                   v[2] = fl->opp[0];

	mov	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+8], edx

; 203  :                   v[3] = fl->opp[1];

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [ecx+12], eax

; 204  :                   v = get_facet_vertices(fl->f_id[1]);

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR _web+328
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	add	ecx, DWORD PTR [eax+edx+304]

; 205  :                   v[0] = fl->v[(j+1) % web.dimension];

	lea	eax, DWORD PTR [ebx+1]
	cdq
	idiv	DWORD PTR _web+620
	mov	eax, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx], eax

; 206  :                   v[1] = fl->v[j];

	mov	edx, DWORD PTR [esi+ebx*4]
	mov	DWORD PTR [ecx+4], edx

; 207  :                   v[2] = fl->opp[1];

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [ecx+8], eax

; 208  :                   v[3] = fl->opp[0];

	mov	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+12], edx

; 209  : 
; 210  :                   set_attr(fl->f_id[0],NEWFACET); /* mark as contaminated */

	mov	eax, DWORD PTR [esi+32]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, 4
	or	DWORD PTR [eax+8], ecx

; 211  :                   set_attr(fl->f_id[1],NEWFACET);

	mov	eax, DWORD PTR [esi+36]
	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	or	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+12]

; 212  :                   flipcount++;

	inc	DWORD PTR _flipcount$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 213  :                   break;

	jmp	$LN56@simplex_eq
$LN45@simplex_eq:

; 126  :          { case 0: break;
; 127  :             case 1: /* inside, want split along central axis */
; 128  :                   /* check equality of facet constraints and stuff  */
; 129  :                   /* test for equal density */
; 130  :                   if ( (get_fattr(fl->f_id[0])&DENSITY) || (get_fattr(fl->f_id[1])&DENSITY) )

	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 16					; 00000010H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN43@simplex_eq
	mov	ecx, DWORD PTR [esi+36]
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 16					; 00000010H
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN154@simplex_eq
$LN43@simplex_eq:

; 131  :                      if ( fabs(get_facet_density(fl->f_id[0]) - get_facet_density(fl->f_id[1])) > 1e-10 )

	mov	ecx, DWORD PTR [esi+36]
	fld	QWORD PTR [edi+32]
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	fsub	QWORD PTR [edx+32]
	fabs
	fcomp	QWORD PTR __real@3ddb7cdfd9d7bdbb
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN56@simplex_eq
$LN154@simplex_eq:

; 132  :                          break;
; 133  :                   /* test for equal constraints */
; 134  :                   if ( !equal_constr(fl->f_id[0],fl->f_id[1]) ) break;

	mov	eax, DWORD PTR [esi+32]
	push	ecx
	push	eax
	call	_equal_constr
	add	esp, 8
	test	eax, eax
	je	$LN56@simplex_eq

; 135  :                   /* test for equal boundary */
; 136  :                   if (  get_facet_boundary(fl->f_id[0]) != get_facet_boundary(fl->f_id[1]) )

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	mov	edi, DWORD PTR _web+236
	test	eax, eax
	je	SHORT $LN139@simplex_eq
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ebx, DWORD PTR [esi+36]
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR _web+776
	imul	edx, 136				; 00000088H
	and	ebx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [edi+eax]
	imul	eax, 136				; 00000088H
	add	edx, ecx
	add	ecx, eax
	cmp	edx, ecx
	jne	$LN56@simplex_eq
$LN139@simplex_eq:

; 137  :                     break;
; 138  : 
; 139  :                   newf[0] = fl->f_id[0];
; 140  :                   newf[1] = fl->f_id[1];
; 141  :                   for ( j = 2; j < web.dimension ; j++ )

	mov	eax, DWORD PTR _web+620
	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [esi+36]
	mov	edi, 2
	mov	DWORD PTR _newf$89116[ebp], ecx
	mov	DWORD PTR _newf$89116[ebp+4], edx
	cmp	eax, edi
	jle	SHORT $LN37@simplex_eq
	npad	5
$LL144@simplex_eq:

; 142  :                       newf[j] = dup_facet(newf[0]);

	mov	eax, DWORD PTR _newf$89116[ebp]
	push	eax
	call	_dup_facet
	mov	DWORD PTR _newf$89116[ebp+edi*4], eax
	mov	eax, DWORD PTR _web+620
	inc	edi
	add	esp, 4
	cmp	edi, eax
	jl	SHORT $LL144@simplex_eq
$LN37@simplex_eq:

; 143  :                   for ( j = 0 ; j < web.dimension ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	test	eax, eax
	jle	$LN34@simplex_eq
	npad	7
$LL145@simplex_eq:

; 144  :                   { v = get_facet_vertices(newf[j]);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR _newf$89116[ebp+ecx*4]
	mov	ecx, DWORD PTR _web+236
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+328
	add	edi, DWORD PTR [edx+ecx+304]

; 145  :                      for ( k = 0 ; k < web.dimension-1 ; k++ )

	dec	eax
	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN31@simplex_eq
$LL33@simplex_eq:

; 146  :                         v[k] = fl->v[(k+j) % web.dimension];

	mov	edx, DWORD PTR _j$[ebp]
	lea	eax, DWORD PTR [ecx+edx]
	cdq
	idiv	DWORD PTR _web+620
	inc	ecx
	mov	eax, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edi+ecx*4-4], eax
	mov	edx, DWORD PTR _web+620
	dec	edx
	cmp	ecx, edx
	jl	SHORT $LL33@simplex_eq
$LN31@simplex_eq:

; 147  :                      v[k++] = fl->opp[0];

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi+ecx*4], eax

; 148  :                      v[k] = fl->opp[1];

	mov	edx, DWORD PTR [esi+28]

; 149  :                      set_attr(newf[j],NEWFACET); /* so others won't try to flip */

	mov	eax, ebx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	DWORD PTR [edi+ecx*4+4], edx
	mov	ecx, DWORD PTR _web[eax+12]
	and	ebx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+ebx*4]
	mov	edx, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR _j$[ebp]
	or	DWORD PTR [ebx+8], 4
	mov	DWORD PTR [ebx+12], edx
	mov	eax, DWORD PTR _web+620
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, eax
	jl	$LL145@simplex_eq
$LN34@simplex_eq:

; 150  :                   }
; 151  :                   flipcount++;

	inc	DWORD PTR _flipcount$[ebp]

; 214  :          }
; 215  :       }

	jmp	SHORT $LN56@simplex_eq
$LN49@simplex_eq:

; 119  :             { sprintf(msg,"Face doesn't have valid opposite facets.\n");

	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0CK@CAKPIPLA@Face?5doesn?8t?5have?5valid?5opposite@
	push	eax
	call	_sprintf

; 120  :               outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN56@simplex_eq
$LN159@simplex_eq:
	fstp	ST(0)
$LN56@simplex_eq:

; 106  : 
; 107  :     /* look for all void-violating opposite vertices */
; 108  :     for ( fl = facelist, i = 0 ; i < fcount ; i++,fl++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	esi, 40					; 00000028H
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _fcount$[ebp]
	jl	$LL57@simplex_eq

; 216  :   if ( flipcount > 0 ) top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _flipcount$[ebp]
	test	eax, eax
	jle	SHORT $LN1@simplex_eq
	mov	ecx, DWORD PTR _global_timestamp
	pop	edi
	inc	ecx
	pop	esi
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
	pop	ebx

; 218  : } // end simplex_equiangulate()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN141@simplex_eq:

; 217  :   return flipcount;

	mov	eax, DWORD PTR _flipcount$[ebp]
$LN1@simplex_eq:

; 218  : } // end simplex_equiangulate()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_equiangulate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@LFBAGJKE@Vertex?5?$CFs?5inside?5void?5of?5facet?5?$CF@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	_simplex_delaunay_test
EXTRN	_elnames:BYTE
;	COMDAT ??_C@_0CD@LFBAGJKE@Vertex?5?$CFs?5inside?5void?5of?5facet?5?$CF@
CONST	SEGMENT
??_C@_0CD@LFBAGJKE@Vertex?5?$CFs?5inside?5void?5of?5facet?5?$CF@ DB 'Vert'
	DB	'ex %s inside void of facet %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _simplex_delaunay_test
_TEXT	SEGMENT
_simplex_delaunay_test PROC				; COMDAT

; 293  : {

	push	ebx
	push	edi

; 294  :   facet_id f_id;
; 295  :   
; 296  :   FOR_ALL_FACETS(f_id)

	mov	edi, DWORD PTR _web+272
	mov	ebx, edi
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	je	$LN4@simplex_de
	push	esi
	npad	9
$LL6@simplex_de:
	mov	eax, DWORD PTR _web+236
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN5@simplex_de

; 297  :   {
; 298  :     vertex_id v_id, *v = get_facet_vertices(f_id);

	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax+304]
	add	eax, ecx

; 299  :     v_id = void_test(v,web.dimension);

	mov	ecx, DWORD PTR _web+620
	push	ecx
	push	eax
	call	_void_test
	mov	esi, eax
	add	esp, 8

; 300  :     if ( valid_id(v_id) )

	test	esi, 268435456				; 10000000H
	je	SHORT $LN5@simplex_de

; 301  :     { sprintf(msg,"Vertex %s inside void of facet %s\n",ELNAME(v_id),
; 302  :               ELNAME2(f_id));

	test	ebx, ebx
	je	SHORT $LN9@simplex_de
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	ebx, OFFSET _elnames+60
	jmp	SHORT $LN10@simplex_de
$LN9@simplex_de:
	mov	ebx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN10@simplex_de:
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	ebx
	push	OFFSET _elnames
	push	OFFSET ??_C@_0CD@LFBAGJKE@Vertex?5?$CFs?5inside?5void?5of?5facet?5?$CF@
	push	eax
	call	_sprintf

; 303  :       erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring
	add	esp, 32					; 00000020H
$LN5@simplex_de:

; 294  :   facet_id f_id;
; 295  :   
; 296  :   FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [edx+edi*4]
	mov	edi, DWORD PTR [eax]
	mov	ebx, edi
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	jne	$LL6@simplex_de
	pop	esi
$LN4@simplex_de:
	pop	edi
	pop	ebx

; 304  :     }
; 305  :   }
; 306  : 
; 307  : } // end simplex_delaunay_test()

	ret	0
_simplex_delaunay_test ENDP
_TEXT	ENDS
END
