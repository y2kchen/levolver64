; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\DISPLAY.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_trans_max DD	01f4H
_DATA	ENDS
PUBLIC	??_C@_0BB@IGAGMKCN@Invalid?5choice?4?6?$AA@	; `string'
PUBLIC	??_C@_0CM@DEDFDEAL@Will?5do?5OOGL?5file?5only?5for?5SOAPF@ ; `string'
PUBLIC	??_C@_0CN@OMFKBMDI@Will?5do?5Pixar?5file?5only?5for?5SOAP@ ; `string'
PUBLIC	_do_gfile
EXTRN	_inner_clip_flag:DWORD
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	_outstring:PROC
EXTRN	_End_geomview:PROC
EXTRN	_geompipe_flag:DWORD
EXTRN	_geomview_flag:DWORD
EXTRN	_go_display_flag:DWORD
EXTRN	_Begin_geomview:PROC
EXTRN	_detorus_end:PROC
EXTRN	_detorus_facet:PROC
EXTRN	_detorus_edge:PROC
EXTRN	_detorus_start:PROC
EXTRN	_binary_OFF_end:PROC
EXTRN	_binary_OFF_facet:PROC
EXTRN	_binary_OFF_edge:PROC
EXTRN	_binary_OFF_start:PROC
EXTRN	_binary_off_filename:DWORD
EXTRN	_OFF_end:PROC
EXTRN	_OFF_facet:PROC
EXTRN	_OFF_edge:PROC
EXTRN	_OFF_start:PROC
EXTRN	_softimage:PROC
EXTRN	_fil_facet:PROC
EXTRN	_fil_edge:PROC
EXTRN	_fil_finish:PROC
EXTRN	_fil_init:PROC
EXTRN	_graph_capabilities:DWORD
EXTRN	_pswidths:BYTE
EXTRN	_ps_facet:PROC
EXTRN	_ps_edge:PROC
EXTRN	_ps_finish:PROC
EXTRN	_ps_init:PROC
EXTRN	_pix_end:PROC
EXTRN	_pix_facet:PROC
EXTRN	_pix_start:PROC
EXTRN	_kb_error:PROC
EXTRN	_web:BYTE
EXTRN	_graphgen:PROC
EXTRN	_otherwidths:BYTE
EXTRN	_edgewidths:DWORD
EXTRN	_need_bounding_box:DWORD
EXTRN	_painter_end:PROC
EXTRN	_painter_facet:PROC
EXTRN	_painter_edge:PROC
EXTRN	_painter_start:PROC
EXTRN	_null_function:PROC
EXTRN	_graph_facet:DWORD
EXTRN	_graph_edge:DWORD
EXTRN	_display_edge:DWORD
EXTRN	_finish_graphics:DWORD
EXTRN	_init_graphics:DWORD
EXTRN	_graph_end:DWORD
EXTRN	_display_facet:DWORD
EXTRN	_graph_start:DWORD
EXTRN	_kb_upper_array:BYTE
EXTRN	__imp__MsgWaitForMultipleObjects@20:PROC
EXTRN	_graphmutex:DWORD
EXTRN	_locking_thread:DWORD
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	_ask_wrap_display:PROC
EXTRN	_torus_display_mode:DWORD
;	COMDAT ??_C@_0BB@IGAGMKCN@Invalid?5choice?4?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\display.c
CONST	SEGMENT
??_C@_0BB@IGAGMKCN@Invalid?5choice?4?6?$AA@ DB 'Invalid choice.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DEDFDEAL@Will?5do?5OOGL?5file?5only?5for?5SOAPF@
CONST	SEGMENT
??_C@_0CM@DEDFDEAL@Will?5do?5OOGL?5file?5only?5for?5SOAPF@ DB 'Will do OO'
	DB	'GL file only for SOAPFILM model.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@OMFKBMDI@Will?5do?5Pixar?5file?5only?5for?5SOAP@
CONST	SEGMENT
??_C@_0CN@OMFKBMDI@Will?5do?5Pixar?5file?5only?5for?5SOAP@ DB 'Will do Pi'
	DB	'xar file only for SOAPFILM model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _do_gfile
_TEXT	SEGMENT
_did_graphlock_here$89080 = -20				; size = 4
_old_gfacet$ = -16					; size = 4
_old_end$ = -12						; size = 4
_old_start$ = -8					; size = 4
_old_facet$ = -4					; size = 4
_old_gedge$ = 8						; size = 4
_choice$ = 8						; size = 4
_fname$ = 12						; size = 4
_do_gfile PROC						; COMDAT

; 82   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx

; 83   :   /* for saving old graphics state */
; 84   :   void (*old_edge)(struct tsort *); 
; 85   :   void (*old_facet)(struct tsort *);
; 86   :   void (*old_gfacet)(struct graphdata *,facet_id); 
; 87   :   void (*old_gedge)(struct graphdata *,edge_id);
; 88   :   void (*old_init)(void);
; 89   :   void (*old_finish)(void);
; 90   :   void (*old_start)(void);
; 91   :   void (*old_end)(void);  
; 92   : 
; 93   :   if ( torus_display_mode == TORUS_DEFAULT_MODE ) ask_wrap_display();

	xor	ebx, ebx
	push	esi
	push	edi
	cmp	DWORD PTR _torus_display_mode, ebx
	jne	SHORT $LN27@do_gfile
	call	_ask_wrap_display
$LN27@do_gfile:

; 94   : 
; 95   :   ENTER_GRAPH_MUTEX      

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	mov	edi, 1
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN26@do_gfile
	push	ebx
	push	100000					; 000186a0H
	push	ebx
	push	OFFSET _graphmutex
	push	edi
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89080[ebp], edi
	jmp	SHORT $LN25@do_gfile
$LN26@do_gfile:
	mov	DWORD PTR _did_graphlock_here$89080[ebp], ebx
$LN25@do_gfile:

; 96   :   switch ( toupper(choice) )

	mov	eax, DWORD PTR _choice$[ebp]
	movsx	eax, BYTE PTR _kb_upper_array[eax]
	cmp	eax, 113				; 00000071H
	ja	$LN2@do_gfile
	movzx	ecx, BYTE PTR $LN30@do_gfile[eax]
	mov	esi, 2
	jmp	DWORD PTR $LN35@do_gfile[ecx*4]
$LN22@do_gfile:

; 97   :   {
; 98   :     case 0: /* null file with painter, for bounding box */
; 99   :        /* save old graphics functions */
; 100  :        old_init = init_graphics;
; 101  :        old_finish = finish_graphics;
; 102  :        old_edge = display_edge;
; 103  :        old_facet = display_facet;
; 104  :        old_start = graph_start;

	mov	eax, DWORD PTR _graph_start
	mov	edx, DWORD PTR _display_facet

; 105  :        old_end    = graph_end;

	mov	ecx, DWORD PTR _graph_end
	mov	esi, DWORD PTR _init_graphics
	mov	edi, DWORD PTR _finish_graphics
	mov	ebx, DWORD PTR _display_edge
	mov	DWORD PTR _old_start$[ebp], eax

; 106  :        old_gfacet = graph_facet;
; 107  :        old_gedge  = graph_edge;

	mov	eax, DWORD PTR _graph_edge
	mov	DWORD PTR _old_facet$[ebp], edx
	mov	edx, DWORD PTR _graph_facet
	mov	DWORD PTR _old_gedge$[ebp], eax

; 108  : 
; 109  :        /* set null graphics functions */
; 110  :        init_graphics = null_function;

	mov	eax, OFFSET _null_function
	mov	DWORD PTR _old_end$[ebp], ecx
	mov	DWORD PTR _old_gfacet$[ebp], edx
	mov	DWORD PTR _init_graphics, eax

; 111  :        finish_graphics = null_function;

	mov	DWORD PTR _finish_graphics, eax

; 112  :        graph_start = painter_start;

	mov	DWORD PTR _graph_start, OFFSET _painter_start

; 113  :        graph_edge  = painter_edge;

	mov	DWORD PTR _graph_edge, OFFSET _painter_edge

; 114  :        display_edge = (void (*)(struct tsort *)) null_function;

	mov	DWORD PTR _display_edge, eax

; 115  :        graph_facet = painter_facet;

	mov	DWORD PTR _graph_facet, OFFSET _painter_facet

; 116  :        display_facet =  (void (*)(struct tsort *))null_function;

	mov	DWORD PTR _display_facet, eax

; 117  :        graph_end = painter_end;

	mov	DWORD PTR _graph_end, OFFSET _painter_end

; 118  :        need_bounding_box = 1;

	mov	DWORD PTR _need_bounding_box, 1

; 119  :        edgewidths = otherwidths;

	mov	DWORD PTR _edgewidths, OFFSET _otherwidths

; 120  : 
; 121  :        /* do output */
; 122  :        graphgen();

	call	_graphgen

; 123  : 
; 124  :        /* restore old graphics */
; 125  :        init_graphics = old_init;
; 126  :        finish_graphics = old_finish;
; 127  :        display_edge = old_edge;
; 128  :        display_facet = old_facet;

	mov	ecx, DWORD PTR _old_facet$[ebp]

; 129  :        graph_start = old_start;

	mov	edx, DWORD PTR _old_start$[ebp]

; 130  :        graph_end    = old_end;

	mov	eax, DWORD PTR _old_end$[ebp]
	mov	DWORD PTR _display_facet, ecx

; 131  :        graph_facet = old_gfacet;

	mov	ecx, DWORD PTR _old_gfacet$[ebp]
	mov	DWORD PTR _graph_start, edx

; 132  :        graph_edge  = old_gedge;

	mov	edx, DWORD PTR _old_gedge$[ebp]
	mov	DWORD PTR _init_graphics, esi
	mov	DWORD PTR _finish_graphics, edi
	mov	DWORD PTR _display_edge, ebx
	mov	DWORD PTR _graph_end, eax
	mov	DWORD PTR _graph_facet, ecx
	mov	DWORD PTR _graph_edge, edx

; 133  :        need_bounding_box = 0;

	mov	DWORD PTR _need_bounding_box, 0

; 134  : 
; 135  :        break;

	jmp	$LN23@do_gfile
$LN21@do_gfile:

; 136  :  
; 137  :   case '1':
; 138  :   case 'P':  /* Pixar */
; 139  :        if ( web.representation != SOAPFILM )

	cmp	DWORD PTR _web+624, esi
	je	SHORT $LN18@do_gfile

; 140  :           kb_error(1001,"Will do Pixar file only for SOAPFILM model.\n",
; 141  :                 RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0CN@OMFKBMDI@Will?5do?5Pixar?5file?5only?5for?5SOAP@
	push	1001					; 000003e9H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN20@do_gfile:

; 142  :        /* fall through, since MinneView same as Pixar */
; 143  :   case '2':
; 144  :   case 'M':  /* OOGL file */
; 145  :        if ( web.representation != SOAPFILM )

	cmp	DWORD PTR _web+624, esi
	je	SHORT $LN18@do_gfile

; 146  :           kb_error(1002,"Will do OOGL file only for SOAPFILM model.\n",
; 147  :                 RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0CM@DEDFDEAL@Will?5do?5OOGL?5file?5only?5for?5SOAPF@
	push	1002					; 000003eaH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN18@do_gfile:

; 148  :        old_start = graph_start;

	mov	esi, DWORD PTR _graph_start

; 149  :        old_end    = graph_end;

	mov	edi, DWORD PTR _graph_end

; 150  :        old_gfacet = graph_facet;

	mov	ebx, DWORD PTR _graph_facet

; 151  :        graph_start = pix_start;

	mov	DWORD PTR _graph_start, OFFSET _pix_start

; 152  :        graph_facet = pix_facet;

	mov	DWORD PTR _graph_facet, OFFSET _pix_facet

; 153  :        graph_end    = pix_end;

	mov	DWORD PTR _graph_end, OFFSET _pix_end

; 154  : 
; 155  :        /* do output */
; 156  :        graphgen();

	call	_graphgen

; 157  : 
; 158  :        /* restore old graphics */
; 159  :        graph_start = old_start;

	mov	DWORD PTR _graph_start, esi

; 160  :        graph_end    = old_end;

	mov	DWORD PTR _graph_end, edi

; 161  :        graph_facet = old_gfacet;

	mov	DWORD PTR _graph_facet, ebx

; 162  :        break;

	jmp	$LN23@do_gfile
$LN17@do_gfile:

; 163  :  
; 164  :   case '3':
; 165  :   case 'S': /* PostScript */
; 166  :        /* save old graphics functions */
; 167  :        old_init = init_graphics;
; 168  :        old_finish = finish_graphics;
; 169  :        old_edge = display_edge;
; 170  :        old_facet = display_facet;
; 171  :        old_start = graph_start;
; 172  :        old_end    = graph_end;

	mov	edx, DWORD PTR _graph_end
	mov	eax, DWORD PTR _display_facet
	mov	ecx, DWORD PTR _graph_start
	mov	esi, DWORD PTR _init_graphics
	mov	edi, DWORD PTR _finish_graphics
	mov	ebx, DWORD PTR _display_edge
	mov	DWORD PTR _old_end$[ebp], edx

; 173  :        old_gfacet = graph_facet;
; 174  :        old_gedge  = graph_edge;
; 175  : 
; 176  :        /* set PostScript functions */
; 177  :        init_graphics = ps_init;
; 178  :        finish_graphics = ps_finish;
; 179  :        graph_start = painter_start;
; 180  :        graph_edge  = painter_edge;
; 181  :        display_edge = ps_edge;
; 182  :        graph_facet = painter_facet;
; 183  :        display_facet = ps_facet;
; 184  :        graph_end = painter_end;
; 185  :        need_bounding_box = 1;
; 186  :        edgewidths = pswidths;
; 187  :        graph_capabilities = web.torus_display_period ? 0 : GC_ARCS;

	xor	edx, edx
	cmp	DWORD PTR _web+1620, edx
	mov	DWORD PTR _old_facet$[ebp], eax
	mov	eax, DWORD PTR _graph_facet
	sete	dl
	mov	DWORD PTR _old_start$[ebp], ecx
	mov	ecx, DWORD PTR _graph_edge
	mov	DWORD PTR _old_gfacet$[ebp], eax
	mov	DWORD PTR _old_gedge$[ebp], ecx
	mov	DWORD PTR _init_graphics, OFFSET _ps_init
	mov	DWORD PTR _finish_graphics, OFFSET _ps_finish
	mov	DWORD PTR _graph_start, OFFSET _painter_start
	mov	DWORD PTR _graph_edge, OFFSET _painter_edge
	mov	DWORD PTR _display_edge, OFFSET _ps_edge
	mov	DWORD PTR _graph_facet, OFFSET _painter_facet
	mov	DWORD PTR _display_facet, OFFSET _ps_facet
	mov	DWORD PTR _graph_end, OFFSET _painter_end
	mov	DWORD PTR _need_bounding_box, 1
	mov	DWORD PTR _edgewidths, OFFSET _pswidths
	mov	DWORD PTR _graph_capabilities, edx

; 188  : 
; 189  :        /* do output */
; 190  :        graphgen();

	call	_graphgen

; 191  : 
; 192  :        /* restore old graphics */
; 193  :        init_graphics = old_init;
; 194  :        finish_graphics = old_finish;
; 195  :        display_edge = old_edge;
; 196  :        display_facet = old_facet;

	mov	eax, DWORD PTR _old_facet$[ebp]

; 197  :        graph_start = old_start;

	mov	ecx, DWORD PTR _old_start$[ebp]

; 198  :        graph_end    = old_end;

	mov	edx, DWORD PTR _old_end$[ebp]
	mov	DWORD PTR _display_facet, eax

; 199  :        graph_facet = old_gfacet;

	mov	eax, DWORD PTR _old_gfacet$[ebp]
	mov	DWORD PTR _graph_start, ecx

; 200  :        graph_edge  = old_gedge;

	mov	ecx, DWORD PTR _old_gedge$[ebp]
	mov	DWORD PTR _graph_facet, eax

; 201  :        need_bounding_box = 0;

	xor	eax, eax
	mov	DWORD PTR _init_graphics, esi
	mov	DWORD PTR _finish_graphics, edi
	mov	DWORD PTR _display_edge, ebx
	mov	DWORD PTR _graph_end, edx
	mov	DWORD PTR _graph_edge, ecx
	mov	DWORD PTR _need_bounding_box, eax

; 202  :        graph_capabilities = 0;

	mov	DWORD PTR _graph_capabilities, eax

; 203  : 
; 204  :        break;

	jmp	$LN23@do_gfile
$LN16@do_gfile:

; 205  :  
; 206  :   case '4':
; 207  :   case 'F': /* triangle file output */
; 208  :        /* save old graphics functions */
; 209  :        old_init = init_graphics;
; 210  :        old_finish = finish_graphics;
; 211  :        old_edge = display_edge;
; 212  :        old_facet = display_facet;
; 213  :        old_start = graph_start;
; 214  :        old_end    = graph_end;
; 215  :        old_gfacet = graph_facet;
; 216  :        old_gedge  = graph_edge;
; 217  : 
; 218  :        /* set functions */
; 219  :        init_graphics = fil_init;
; 220  :        finish_graphics = fil_finish;
; 221  :        if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	mov	eax, DWORD PTR _graph_start
	mov	edx, DWORD PTR _display_facet
	mov	ecx, DWORD PTR _graph_end
	mov	esi, DWORD PTR _init_graphics
	mov	edi, DWORD PTR _finish_graphics
	mov	ebx, DWORD PTR _display_edge
	mov	DWORD PTR _old_start$[ebp], eax
	mov	eax, DWORD PTR _graph_edge
	mov	DWORD PTR _old_facet$[ebp], edx
	mov	edx, DWORD PTR _graph_facet
	mov	DWORD PTR _old_end$[ebp], ecx
	mov	DWORD PTR _old_gedge$[ebp], eax
	mov	ecx, OFFSET _fil_init
	mov	eax, OFFSET _fil_finish
	mov	DWORD PTR _old_gfacet$[ebp], edx
	mov	DWORD PTR _init_graphics, ecx
	mov	DWORD PTR _finish_graphics, eax
	jne	SHORT $LN15@do_gfile

; 222  :           {
; 223  :             graph_start = fil_init;

	mov	DWORD PTR _graph_start, ecx

; 224  :             graph_edge  = painter_edge;

	mov	DWORD PTR _graph_edge, OFFSET _painter_edge

; 225  :             display_edge = fil_edge;

	mov	DWORD PTR _display_edge, OFFSET _fil_edge

; 226  :             graph_end    = fil_finish;

	mov	DWORD PTR _graph_end, eax

; 227  :           }
; 228  :        else

	jmp	SHORT $LN14@do_gfile
$LN15@do_gfile:

; 229  :           { 
; 230  :             graph_start = painter_start;

	mov	DWORD PTR _graph_start, OFFSET _painter_start

; 231  :             graph_facet = painter_facet;

	mov	DWORD PTR _graph_facet, OFFSET _painter_facet

; 232  :             display_facet = fil_facet;

	mov	DWORD PTR _display_facet, OFFSET _fil_facet

; 233  :             graph_end = painter_end;

	mov	DWORD PTR _graph_end, OFFSET _painter_end
$LN14@do_gfile:

; 234  :           }
; 235  :        edgewidths = otherwidths;

	mov	DWORD PTR _edgewidths, OFFSET _otherwidths

; 236  : 
; 237  :        /* do output */
; 238  :        graphgen();

	call	_graphgen

; 239  : 
; 240  :        /* restore old graphics */
; 241  :        init_graphics = old_init;
; 242  :        finish_graphics = old_finish;
; 243  :        display_edge = old_edge;
; 244  :        display_facet = old_facet;

	mov	ecx, DWORD PTR _old_facet$[ebp]

; 245  :        graph_start = old_start;

	mov	edx, DWORD PTR _old_start$[ebp]

; 246  :        graph_end    = old_end;

	mov	eax, DWORD PTR _old_end$[ebp]
	mov	DWORD PTR _display_facet, ecx

; 247  :        graph_facet = old_gfacet;

	mov	ecx, DWORD PTR _old_gfacet$[ebp]
	mov	DWORD PTR _graph_start, edx

; 248  :        graph_edge  = old_gedge;

	mov	edx, DWORD PTR _old_gedge$[ebp]
	mov	DWORD PTR _init_graphics, esi
	mov	DWORD PTR _finish_graphics, edi
	mov	DWORD PTR _display_edge, ebx
	mov	DWORD PTR _graph_end, eax
	mov	DWORD PTR _graph_facet, ecx
	mov	DWORD PTR _graph_edge, edx

; 249  :        break;

	jmp	$LN23@do_gfile
$LN13@do_gfile:

; 250  : 
; 251  :     case '5': /* Softimage file */
; 252  :        softimage();

	call	_softimage

; 253  :        break;

	jmp	$LN23@do_gfile
$LN12@do_gfile:

; 254  : 
; 255  :     case '6': /* OFF format file */
; 256  :        old_start = graph_start;

	mov	esi, DWORD PTR _graph_start

; 257  :        old_end    = graph_end;

	mov	edi, DWORD PTR _graph_end

; 258  :        old_gfacet = graph_facet;

	mov	ebx, DWORD PTR _graph_facet

; 259  :        old_gedge = graph_edge;

	mov	eax, DWORD PTR _graph_edge

; 260  :        graph_start = OFF_start;

	mov	DWORD PTR _graph_start, OFFSET _OFF_start

; 261  :        graph_edge = OFF_edge;

	mov	DWORD PTR _graph_edge, OFFSET _OFF_edge

; 262  :        graph_facet = OFF_facet;

	mov	DWORD PTR _graph_facet, OFFSET _OFF_facet

; 263  :        graph_end    = OFF_end;

	mov	DWORD PTR _graph_end, OFFSET _OFF_end
$LN34@do_gfile:

; 264  : 
; 265  :        /* do output */
; 266  :        graphgen();

	mov	DWORD PTR _old_gedge$[ebp], eax
	call	_graphgen

; 267  : 
; 268  :        /* restore old graphics */
; 269  :        graph_start = old_start;
; 270  :        graph_end    = old_end;
; 271  :        graph_facet = old_gfacet;
; 272  :        graph_edge = old_gedge;

	mov	ecx, DWORD PTR _old_gedge$[ebp]
	mov	DWORD PTR _graph_start, esi
	mov	DWORD PTR _graph_end, edi
	mov	DWORD PTR _graph_facet, ebx
	mov	DWORD PTR _graph_edge, ecx

; 273  :        break;

	jmp	$LN23@do_gfile
$LN11@do_gfile:

; 274  :  
; 275  :     case '7': /* binary OFF format file, for evmovie*/
; 276  :        binary_off_filename = fname;

	mov	edx, DWORD PTR _fname$[ebp]

; 277  :        old_start = graph_start;

	mov	esi, DWORD PTR _graph_start

; 278  :        old_end    = graph_end;

	mov	edi, DWORD PTR _graph_end

; 279  :        old_gfacet = graph_facet;

	mov	ebx, DWORD PTR _graph_facet

; 280  :        old_gedge = graph_edge;

	mov	eax, DWORD PTR _graph_edge
	mov	DWORD PTR _binary_off_filename, edx

; 281  :        graph_start = binary_OFF_start;

	mov	DWORD PTR _graph_start, OFFSET _binary_OFF_start

; 282  :        graph_edge = binary_OFF_edge;

	mov	DWORD PTR _graph_edge, OFFSET _binary_OFF_edge

; 283  :        graph_facet = binary_OFF_facet;

	mov	DWORD PTR _graph_facet, OFFSET _binary_OFF_facet

; 284  :        graph_end    = binary_OFF_end;

	mov	DWORD PTR _graph_end, OFFSET _binary_OFF_end

; 285  : 
; 286  :        /* do output */
; 287  :        graphgen();
; 288  : 
; 289  :        /* restore old graphics */
; 290  :        graph_start = old_start;
; 291  :        graph_end    = old_end;
; 292  :        graph_facet = old_gfacet;
; 293  :        graph_edge = old_gedge;
; 294  :        break;

	jmp	SHORT $LN34@do_gfile
$LN10@do_gfile:

; 295  : 
; 296  :  
; 297  :     case 'D': /* for detorus() */
; 298  :        old_start   = graph_start;
; 299  :        old_end     = graph_end;
; 300  :        old_gfacet  = graph_facet;
; 301  :        old_gedge   = graph_edge;

	mov	edx, DWORD PTR _graph_edge
	mov	esi, DWORD PTR _graph_start
	mov	edi, DWORD PTR _graph_end
	mov	ebx, DWORD PTR _graph_facet
	mov	DWORD PTR _old_gedge$[ebp], edx

; 302  :        graph_start = detorus_start;

	mov	DWORD PTR _graph_start, OFFSET _detorus_start

; 303  :        graph_edge  = detorus_edge;

	mov	DWORD PTR _graph_edge, OFFSET _detorus_edge

; 304  :        graph_facet = detorus_facet;

	mov	DWORD PTR _graph_facet, OFFSET _detorus_facet

; 305  :        graph_end   = detorus_end;

	mov	DWORD PTR _graph_end, OFFSET _detorus_end

; 306  : 
; 307  :        /* do output */
; 308  :        graphgen();

	call	_graphgen

; 309  : 
; 310  :        /* restore old graphics */
; 311  :        graph_start = old_start;
; 312  :        graph_end   = old_end;
; 313  :        graph_facet = old_gfacet;
; 314  :        graph_edge  = old_gedge;

	mov	eax, DWORD PTR _old_gedge$[ebp]
	mov	DWORD PTR _graph_start, esi
	mov	DWORD PTR _graph_end, edi
	mov	DWORD PTR _graph_facet, ebx
	mov	DWORD PTR _graph_edge, eax

; 315  :        break;

	jmp	SHORT $LN23@do_gfile
$LN9@do_gfile:

; 316  : 
; 317  :     case '8': /* interactive geomview */
; 318  :        Begin_geomview(fname);

	mov	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	call	_Begin_geomview

; 319  :        go_display_flag = 1;  /* default autodisplay */

	mov	DWORD PTR _go_display_flag, edi

; 320  :        break;

	jmp	SHORT $LN32@do_gfile
$LN8@do_gfile:

; 321  : 
; 322  :     case '9': /* end geomview */
; 323  :     case 'B': /* end geomview */
; 324  :        if ( geomview_flag || geompipe_flag ) End_geomview();

	cmp	DWORD PTR _geomview_flag, ebx
	jne	SHORT $LN6@do_gfile
	cmp	DWORD PTR _geompipe_flag, ebx
	je	SHORT $LN7@do_gfile
$LN6@do_gfile:
	call	_End_geomview
$LN7@do_gfile:

; 325  :        go_display_flag = 0;  /* autodisplay off */

	mov	DWORD PTR _go_display_flag, ebx

; 326  :        geompipe_flag = GEOM_TO_GEOMVIEW;

	mov	DWORD PTR _geompipe_flag, ebx

; 327  :        break;

	jmp	SHORT $LN23@do_gfile
$LN5@do_gfile:

; 328  : 
; 329  :     case 'A': /* geomview to named pipe */
; 330  :        geompipe_flag = GEOM_NAMED_PIPE;
; 331  :        Begin_geomview(fname);

	mov	edx, DWORD PTR _fname$[ebp]
	push	edx
	mov	DWORD PTR _geompipe_flag, edi
	call	_Begin_geomview

; 332  :        go_display_flag = 1;  /* default autodisplay */

	mov	DWORD PTR _go_display_flag, edi

; 333  :        break;

	jmp	SHORT $LN32@do_gfile
$LN4@do_gfile:

; 334  : 
; 335  :     case 'C': /* geomview to command */
; 336  :        geompipe_flag = GEOM_PIPE_COMMAND;
; 337  :        Begin_geomview(fname);

	mov	eax, DWORD PTR _fname$[ebp]
	push	eax
	mov	DWORD PTR _geompipe_flag, esi
	call	_Begin_geomview

; 338  :        go_display_flag = 1;  /* default autodisplay */

	mov	DWORD PTR _go_display_flag, edi

; 339  :        break;

	jmp	SHORT $LN32@do_gfile
$LN2@do_gfile:

; 340  :     case 'q':
; 341  :     case '0': break;
; 342  : 
; 343  :     default: outstring("Invalid choice.\n"); break;

	push	OFFSET ??_C@_0BB@IGAGMKCN@Invalid?5choice?4?6?$AA@
	call	_outstring
$LN32@do_gfile:
	add	esp, 4
$LN23@do_gfile:

; 344  :   }
; 345  :   LEAVE_GRAPH_MUTEX 

	xor	esi, esi
	cmp	DWORD PTR _did_graphlock_here$89080[ebp], esi
	je	SHORT $LN31@do_gfile
	mov	ecx, DWORD PTR _graphmutex
	push	ecx
	mov	DWORD PTR _locking_thread, esi
	call	DWORD PTR __imp__ReleaseMutex@4
$LN31@do_gfile:

; 346  :   inner_clip_flag = 0; /* turn off inner clipping */

	pop	edi
	mov	DWORD PTR _inner_clip_flag, esi
	pop	esi
	pop	ebx

; 347  : 
; 348  : } // end do_gfile()

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN35@do_gfile:
	DD	$LN22@do_gfile
	DD	$LN23@do_gfile
	DD	$LN21@do_gfile
	DD	$LN20@do_gfile
	DD	$LN17@do_gfile
	DD	$LN16@do_gfile
	DD	$LN13@do_gfile
	DD	$LN12@do_gfile
	DD	$LN11@do_gfile
	DD	$LN9@do_gfile
	DD	$LN8@do_gfile
	DD	$LN5@do_gfile
	DD	$LN4@do_gfile
	DD	$LN10@do_gfile
	DD	$LN2@do_gfile
$LN30@do_gfile:
	DB	0
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	11					; 0000000bH
	DB	10					; 0000000aH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	5
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	3
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	2
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	4
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	1
_do_gfile ENDP
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	__real@3feccccccccccccd
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	_gray_level
EXTRN	_brightness:QWORD
EXTRN	_view:DWORD
EXTRN	_rotate_lights_flag:DWORD
EXTRN	_dotf:PROC
EXTRN	__fltused:DWORD
EXTRN	__CIsqrt:PROC
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3feccccccccccccd
CONST	SEGMENT
__real@3feccccccccccccd DQ 03feccccccccccccdr	; 0.9
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _gray_level
_TEXT	SEGMENT
tv251 = -8						; size = 8
_normal$ = 8						; size = 4
_gray_level PROC					; COMDAT

; 361  : { REAL cosine;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 362  :   REAL denom;
; 363  :   denom = sqrt(dotf(normal,normal,3));

	mov	esi, DWORD PTR _normal$[ebp]
	push	3
	push	esi
	push	esi
	call	_dotf
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 364  :   if ( denom == 0.0 ) return 0.0;

	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@gray_level
	fstp	ST(1)
	pop	esi

; 377  : 
; 378  : } // end gray_level()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@gray_level:

; 365  :   if ( rotate_lights_flag )

	cmp	DWORD PTR _rotate_lights_flag, 0
	fstp	ST(0)
	je	SHORT $LN3@gray_level

; 366  :   { REAL mag = sqrt(view[0][2]*view[0][2]+view[1][2]*view[1][2]
; 367  :                   + view[2][2]*view[2][2]);
; 368  :     cosine = (normal[2]*view[0][2]+normal[0]*view[1][2]+normal[1]*view[2][2])
; 369  :                /denom/mag;

	mov	eax, DWORD PTR _view
	mov	edx, DWORD PTR [eax+4]
	fld	QWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+8]
	fld	QWORD PTR [ecx+16]
	fld	QWORD PTR [edx+16]
	mov	edx, DWORD PTR [eax+4]

; 370  :     return brightness + 0.9*(1-brightness)*fabs(cosine);

	fld	DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+8]
	fmul	QWORD PTR [edx+16]
	fld	DWORD PTR [esi+8]
	fmul	QWORD PTR [ecx+16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [esi+4]
	fmul	QWORD PTR [eax+16]
	faddp	ST(1), ST(0)
	fdivrp	ST(4), ST(0)
	fxch	ST(3)
	fstp	QWORD PTR tv251[ebp]
	fmul	ST(0), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fdivr	QWORD PTR tv251[ebp]
	fabs
$LN1@gray_level:

; 376  :   return brightness + 0.9*(1-brightness)*cosine;

	fld1
	pop	esi
	fld	QWORD PTR _brightness
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3feccccccccccccd
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)

; 377  : 
; 378  : } // end gray_level()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@gray_level:

; 371  :   }
; 372  :   else
; 373  :     cosine = normal[1]/denom;

	fdivr	DWORD PTR [esi+4]

; 374  :   if ( (REAL)normal[2] < 0.0 ) 

	fldz
	fcomp	DWORD PTR [esi+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@gray_level

; 375  :     return brightness - 0.9*(1-brightness)*cosine;

	fld1
	pop	esi
	fld	QWORD PTR _brightness
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3feccccccccccccd
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)

; 377  : 
; 378  : } // end gray_level()

	mov	esp, ebp
	pop	ebp
	ret	0
_gray_level ENDP
_TEXT	ENDS
PUBLIC	__real@3eb0c6f7a0b5ed8d
PUBLIC	__$ArrayPad$
PUBLIC	_matcomp
EXTRN	_dt_eps:QWORD
EXTRN	_matvec_mul:PROC
EXTRN	_view_transforms_unique_point:DWORD
EXTRN	_view_transforms_unique_point_flag:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT __real@3eb0c6f7a0b5ed8d
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-006
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _matcomp
_TEXT	SEGMENT
tv387 = -108						; size = 4
_i$ = -104						; size = 4
_image_new$89206 = -100					; size = 48
_image_old$89207 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_matcomp PROC						; COMDAT

; 504  : { int i,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 505  :   REAL *aa,*bb;
; 506  :   
; 507  :    /* see if give same image of user-chosen point */
; 508  :   if ( view_transforms_unique_point_flag )

	cmp	DWORD PTR _view_transforms_unique_point_flag, 0
	mov	ecx, DWORD PTR _a$[ebp]
	push	esi
	mov	esi, DWORD PTR _b$[ebp]
	je	$LN15@matcomp

; 509  :   { /* lexicographical comparison of image of unique point */
; 510  :     REAL image_new[MAXCOORD],image_old[MAXCOORD];
; 511  :     view_transforms_unique_point[SDIM] = 1.0; /* homogeneous */

	mov	eax, DWORD PTR _web+616
	fld1
	mov	edx, DWORD PTR _view_transforms_unique_point
	fstp	QWORD PTR [edx+eax*8]

; 512  :     matvec_mul(*a,view_transforms_unique_point,image_new,SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR _view_transforms_unique_point
	inc	eax
	push	eax
	push	eax
	lea	eax, DWORD PTR _image_new$89206[ebp]
	push	eax
	mov	eax, DWORD PTR [ecx]
	push	edx
	push	eax
	call	_matvec_mul

; 513  :     matvec_mul(*b,view_transforms_unique_point,image_old,SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR _view_transforms_unique_point
	inc	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _image_old$89207[ebp]
	push	ecx
	push	edx
	push	eax
	call	_matvec_mul

; 514  :     for ( k = 0 ; k < SDIM ; k++ )

	mov	edx, DWORD PTR _web+616
	add	esp, 40					; 00000028H
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN12@matcomp
	fld	QWORD PTR _dt_eps
$LN14@matcomp:

; 515  :     { if ( (image_old[k]/image_old[SDIM]-image_new[k]/image_new[SDIM]) > dt_eps ) return -1;

	fld	QWORD PTR _image_old$89207[ebp+ecx*8]
	fdiv	QWORD PTR _image_old$89207[ebp+edx*8]
	fld	QWORD PTR _image_new$89206[ebp+ecx*8]
	fdiv	QWORD PTR _image_new$89206[ebp+edx*8]
	fsubp	ST(1), ST(0)
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN33@matcomp

; 516  :       if ( (image_old[k]/image_old[SDIM]-image_new[k]/image_new[SDIM]) < -dt_eps ) return 1;

	fld	ST(1)
	fchs
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN36@matcomp

; 514  :     for ( k = 0 ; k < SDIM ; k++ )

	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LN14@matcomp
	fstp	ST(0)
$LN12@matcomp:

; 517  :     }  
; 518  :     return 0;

	xor	eax, eax
	pop	esi

; 528  : 
; 529  : } // end matcomp()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@matcomp:

; 515  :     { if ( (image_old[k]/image_old[SDIM]-image_new[k]/image_new[SDIM]) > dt_eps ) return -1;

	fstp	ST(0)
	or	eax, -1
	fstp	ST(0)
	pop	esi

; 528  : 
; 529  : } // end matcomp()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@matcomp:

; 516  :       if ( (image_old[k]/image_old[SDIM]-image_new[k]/image_new[SDIM]) < -dt_eps ) return 1;

	fstp	ST(0)
	mov	eax, 1
	pop	esi

; 528  : 
; 529  : } // end matcomp()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@matcomp:
	push	ebx

; 519  :   }
; 520  :    
; 521  :   for ( i = 0 ; i <= SDIM ; i++ )

	mov	ebx, DWORD PTR _web+616
	push	edi
	mov	DWORD PTR _i$[ebp], 0
	test	ebx, ebx
	js	SHORT $LN7@matcomp
	mov	edi, DWORD PTR [ecx]
	fld	QWORD PTR __real@3eb0c6f7a0b5ed8d
	mov	eax, DWORD PTR [esi]
	sub	eax, edi
	mov	DWORD PTR tv387[ebp], eax
	jmp	SHORT $LN9@matcomp
$LN28@matcomp:
	mov	eax, DWORD PTR tv387[ebp]
$LN9@matcomp:

; 522  :     for ( j = 0,aa = a[0][i],bb = b[0][i] ; j <= SDIM ; j++,aa++,bb++ )

	mov	ecx, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax+edi]
	xor	edx, edx
	sub	esi, ecx
$LN6@matcomp:

; 523  :     { if ( *aa < *bb-1e-6 ) return -1;

	fld	QWORD PTR [esi+ecx]
	fsub	ST(0), ST(1)
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN43@matcomp

; 524  :       else if ( *aa > *bb+1e-6 ) return 1;

	fld	QWORD PTR [esi+ecx]
	fadd	ST(0), ST(1)
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN46@matcomp

; 522  :     for ( j = 0,aa = a[0][i],bb = b[0][i] ; j <= SDIM ; j++,aa++,bb++ )

	inc	edx
	add	ecx, 8
	cmp	edx, ebx
	jle	SHORT $LN6@matcomp

; 519  :   }
; 520  :    
; 521  :   for ( i = 0 ; i <= SDIM ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	edi, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, ebx
	jle	SHORT $LN28@matcomp
	fstp	ST(0)
$LN7@matcomp:
	pop	edi
	pop	ebx

; 525  :     }
; 526  :     
; 527  :   return 0; /* equal, within error */

	xor	eax, eax
	pop	esi

; 528  : 
; 529  : } // end matcomp()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@matcomp:
	pop	edi

; 523  :     { if ( *aa < *bb-1e-6 ) return -1;

	fstp	ST(0)
	pop	ebx
	or	eax, -1
	pop	esi

; 528  : 
; 529  : } // end matcomp()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@matcomp:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	pop	edi
	pop	ebx
	xor	ecx, ebp
	mov	eax, 1
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_matcomp ENDP
_TEXT	ENDS
PUBLIC	_mat_simplify
EXTRN	_qsort:PROC
; Function compile flags: /Ogtp
;	COMDAT _mat_simplify
_TEXT	SEGMENT
_mats$ = 8						; size = 4
tv192 = 12						; size = 4
_count$ = 12						; size = 4
_mat_simplify PROC					; COMDAT

; 786  : { int newcount;

	push	ebp
	mov	ebp, esp
	push	ebx

; 787  :   int i;
; 788  : 
; 789  :   qsort((char*)mats,count,sizeof(REAL**), FCAST matcomp);

	mov	ebx, DWORD PTR _mats$[ebp]
	push	esi
	mov	esi, DWORD PTR _count$[ebp]
	push	edi
	push	OFFSET _matcomp
	push	4
	push	esi
	push	ebx
	call	_qsort

; 790  :   /* eliminate duplicates */
; 791  :   for ( newcount = 1, i = 1 ; i < count ; i++ )

	mov	edi, 1
	add	esp, 16					; 00000010H
	cmp	esi, edi
	jle	SHORT $LN9@mat_simpli

; 787  :   int i;
; 788  : 
; 789  :   qsort((char*)mats,count,sizeof(REAL**), FCAST matcomp);

	mov	eax, DWORD PTR _count$[ebp]
	dec	eax
	lea	esi, DWORD PTR [ebx+4]
	mov	DWORD PTR tv192[ebp], eax
$LL4@mat_simpli:

; 792  :      { if ( matcomp(mats+newcount-1,mats+i) != 0 ) 

	lea	ecx, DWORD PTR [ebx+edi*4-4]
	push	esi
	push	ecx
	call	_matcomp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@mat_simpli

; 793  :           mats[newcount++] = mats[i];

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ebx+edi*4], edx
	inc	edi
$LN3@mat_simpli:

; 790  :   /* eliminate duplicates */
; 791  :   for ( newcount = 1, i = 1 ; i < count ; i++ )

	add	esi, 4
	dec	DWORD PTR tv192[ebp]
	jne	SHORT $LL4@mat_simpli
$LN9@mat_simpli:

; 794  :      }
; 795  :   return newcount;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 796  : } /* end mat_simplify() */

	pop	ebp
	ret	0
_mat_simplify ENDP
_TEXT	ENDS
PUBLIC	??_C@_08MBPAEDEL@Choice?3?5?$AA@		; `string'
PUBLIC	??_C@_0N@OIPCBIPH@0?4?5cancel?5?5?6?$AA@	; `string'
PUBLIC	??_C@_0BC@FGPFIGPL@B?4?5End?5OOGL?5pipe?6?$AA@	; `string'
PUBLIC	??_C@_0CO@DBGPLAIP@A?4?5Start?5OOGL?5pipe?5?$CIyou?5must?5sta@ ; `string'
PUBLIC	??_C@_0CD@EIOAPIDP@7?4?5binary?5OFF?5file?5?$CIfor?5evmovie?$CJ@ ; `string'
PUBLIC	??_C@_0O@PLBGIDMI@6?4?5OFF?5file?5?6?$AA@	; `string'
PUBLIC	??_C@_0BE@NEHJCOEI@5?4?5Softimage?5file?5?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@BJBNBIPH@4?4?5Triangle?5file?5?6?$AA@	; `string'
PUBLIC	??_C@_0BE@KLOAIEPG@3?4?5PostScript?5file?6?$AA@	; `string'
PUBLIC	??_C@_0O@JLKEPLOJ@2?4?5OOGL?5file?6?$AA@	; `string'
PUBLIC	??_C@_0BA@FAHFBOKE@1?4?5Pixar?5file?5?6?$AA@	; `string'
PUBLIC	??_C@_0CB@KGBHJIMN@Choose?5output?5graphics?5format?3?5?6@ ; `string'
PUBLIC	??_C@_0BJ@MELMANBJ@Inner?5clip?5radius?5?$CI?$CFg?$CJ?3?5?$AA@ ; `string'
PUBLIC	__real@40c1940000000000
PUBLIC	__$ArrayPad$
PUBLIC	_display_file
EXTRN	_ps_colorflag:DWORD
EXTRN	_gridflag:DWORD
EXTRN	_labelflag:DWORD
EXTRN	_crossingflag:DWORD
EXTRN	_const_expr:PROC
EXTRN	_prompt:PROC
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
EXTRN	_inner_clip_rad:QWORD
;	COMDAT ??_C@_08MBPAEDEL@Choice?3?5?$AA@
CONST	SEGMENT
??_C@_08MBPAEDEL@Choice?3?5?$AA@ DB 'Choice: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OIPCBIPH@0?4?5cancel?5?5?6?$AA@
CONST	SEGMENT
??_C@_0N@OIPCBIPH@0?4?5cancel?5?5?6?$AA@ DB '0. cancel  ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FGPFIGPL@B?4?5End?5OOGL?5pipe?6?$AA@
CONST	SEGMENT
??_C@_0BC@FGPFIGPL@B?4?5End?5OOGL?5pipe?6?$AA@ DB 'B. End OOGL pipe', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DBGPLAIP@A?4?5Start?5OOGL?5pipe?5?$CIyou?5must?5sta@
CONST	SEGMENT
??_C@_0CO@DBGPLAIP@A?4?5Start?5OOGL?5pipe?5?$CIyou?5must?5sta@ DB 'A. Sta'
	DB	'rt OOGL pipe (you must start reader)  ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EIOAPIDP@7?4?5binary?5OFF?5file?5?$CIfor?5evmovie?$CJ@
CONST	SEGMENT
??_C@_0CD@EIOAPIDP@7?4?5binary?5OFF?5file?5?$CIfor?5evmovie?$CJ@ DB '7. b'
	DB	'inary OFF file (for evmovie) ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PLBGIDMI@6?4?5OFF?5file?5?6?$AA@
CONST	SEGMENT
??_C@_0O@PLBGIDMI@6?4?5OFF?5file?5?6?$AA@ DB '6. OFF file ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NEHJCOEI@5?4?5Softimage?5file?5?6?$AA@
CONST	SEGMENT
??_C@_0BE@NEHJCOEI@5?4?5Softimage?5file?5?6?$AA@ DB '5. Softimage file ', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BJBNBIPH@4?4?5Triangle?5file?5?6?$AA@
CONST	SEGMENT
??_C@_0BD@BJBNBIPH@4?4?5Triangle?5file?5?6?$AA@ DB '4. Triangle file ', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KLOAIEPG@3?4?5PostScript?5file?6?$AA@
CONST	SEGMENT
??_C@_0BE@KLOAIEPG@3?4?5PostScript?5file?6?$AA@ DB '3. PostScript file', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JLKEPLOJ@2?4?5OOGL?5file?6?$AA@
CONST	SEGMENT
??_C@_0O@JLKEPLOJ@2?4?5OOGL?5file?6?$AA@ DB '2. OOGL file', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FAHFBOKE@1?4?5Pixar?5file?5?6?$AA@
CONST	SEGMENT
??_C@_0BA@FAHFBOKE@1?4?5Pixar?5file?5?6?$AA@ DB '1. Pixar file ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KGBHJIMN@Choose?5output?5graphics?5format?3?5?6@
CONST	SEGMENT
??_C@_0CB@KGBHJIMN@Choose?5output?5graphics?5format?3?5?6@ DB 'Choose out'
	DB	'put graphics format: ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MELMANBJ@Inner?5clip?5radius?5?$CI?$CFg?$CJ?3?5?$AA@
CONST	SEGMENT
??_C@_0BJ@MELMANBJ@Inner?5clip?5radius?5?$CI?$CFg?$CJ?3?5?$AA@ DB 'Inner '
	DB	'clip radius (%g): ', 00H			; `string'
CONST	ENDS
;	COMDAT __real@40c1940000000000
CONST	SEGMENT
__real@40c1940000000000 DQ 040c1940000000000r	; 9000
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _display_file
_TEXT	SEGMENT
_val$ = -1012						; size = 8
_response$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_arg$ = 8						; size = 4
_display_file PROC					; COMDAT

; 27   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1012				; 000003f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 28   :   char response[1000];
; 29   :   REAL val;
; 30   : 
; 31   :   if ( web.zoom_radius < 9000.0 ) 

	fld	QWORD PTR __real@40c1940000000000
	fcomp	QWORD PTR _web+984
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN5@display_fi

; 32   :      { sprintf(errmsg,"Inner clip radius (%g): ",(DOUBLE)inner_clip_rad);

	fld	QWORD PTR _inner_clip_rad
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BJ@MELMANBJ@Inner?5clip?5radius?5?$CI?$CFg?$CJ?3?5?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 33   :         prompt(errmsg,response,sizeof(response));

	push	1000					; 000003e8H
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	push	OFFSET _errmsg
	call	_prompt

; 34   :         if ( const_expr(response,&val) > 0 )

	lea	ecx, DWORD PTR _val$[ebp]
	push	ecx
	lea	edx, DWORD PTR _response$[ebp]
	push	edx
	call	_const_expr
	add	esp, 36					; 00000024H
	test	eax, eax
	jle	SHORT $LN5@display_fi

; 35   :           { inner_clip_rad = val;

	fld	QWORD PTR _val$[ebp]

; 36   :              inner_clip_flag = 1;

	mov	DWORD PTR _inner_clip_flag, 1
	fstp	QWORD PTR _inner_clip_rad
$LN5@display_fi:

; 37   :           }
; 38   :      }
; 39   : 
; 40   :   /* get user choice */
; 41   :   if ( arg < 0 )

	mov	eax, DWORD PTR _arg$[ebp]
	test	eax, eax
	jns	$LN4@display_fi

; 42   :   {
; 43   :      outstring("Choose output graphics format: \n");

	push	OFFSET ??_C@_0CB@KGBHJIMN@Choose?5output?5graphics?5format?3?5?6@
	call	_outstring

; 44   :      outstring("1. Pixar file \n");

	push	OFFSET ??_C@_0BA@FAHFBOKE@1?4?5Pixar?5file?5?6?$AA@
	call	_outstring

; 45   :      outstring("2. OOGL file\n");

	push	OFFSET ??_C@_0O@JLKEPLOJ@2?4?5OOGL?5file?6?$AA@
	call	_outstring

; 46   :      outstring("3. PostScript file\n");

	push	OFFSET ??_C@_0BE@KLOAIEPG@3?4?5PostScript?5file?6?$AA@
	call	_outstring

; 47   :      outstring("4. Triangle file \n");

	push	OFFSET ??_C@_0BD@BJBNBIPH@4?4?5Triangle?5file?5?6?$AA@
	call	_outstring

; 48   :      outstring("5. Softimage file \n");

	push	OFFSET ??_C@_0BE@NEHJCOEI@5?4?5Softimage?5file?5?6?$AA@
	call	_outstring

; 49   :      outstring("6. OFF file \n");

	push	OFFSET ??_C@_0O@PLBGIDMI@6?4?5OFF?5file?5?6?$AA@
	call	_outstring

; 50   :      outstring("7. binary OFF file (for evmovie) \n");

	push	OFFSET ??_C@_0CD@EIOAPIDP@7?4?5binary?5OFF?5file?5?$CIfor?5evmovie?$CJ@
	call	_outstring

; 51   : #if defined(OOGL) && !defined(WIN32)
; 52   :      outstring("8. Start simultaneous geomview  \n");
; 53   :      outstring("9. End simultaneous geomview  \n");
; 54   : #endif
; 55   :      outstring("A. Start OOGL pipe (you must start reader)  \n");

	push	OFFSET ??_C@_0CO@DBGPLAIP@A?4?5Start?5OOGL?5pipe?5?$CIyou?5must?5sta@
	call	_outstring

; 56   :      outstring("B. End OOGL pipe\n");

	push	OFFSET ??_C@_0BC@FGPFIGPL@B?4?5End?5OOGL?5pipe?6?$AA@
	call	_outstring

; 57   :      outstring("0. cancel  \n");

	push	OFFSET ??_C@_0N@OIPCBIPH@0?4?5cancel?5?5?6?$AA@
	call	_outstring

; 58   :      prompt("Choice: ",response,sizeof(response));

	push	1000					; 000003e8H
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	push	OFFSET ??_C@_08MBPAEDEL@Choice?3?5?$AA@
	call	_prompt

; 59   :      if ( response[0] == '3' )

	mov	al, BYTE PTR _response$[ebp]
	add	esp, 56					; 00000038H
	cmp	al, 51					; 00000033H
	jne	SHORT $LN3@display_fi

; 60   :      { ps_colorflag = gridflag = labelflag = crossingflag = -1; }

	or	ecx, -1
	mov	DWORD PTR _crossingflag, ecx
	mov	DWORD PTR _labelflag, ecx
	mov	DWORD PTR _gridflag, ecx
	mov	DWORD PTR _ps_colorflag, ecx
$LN3@display_fi:

; 61   :      do_gfile(response[0],NULL);

	movsx	ecx, al
	push	0
	push	ecx

; 62   :   }
; 63   :   else 

	jmp	SHORT $LN9@display_fi
$LN4@display_fi:

; 64   :   { if ( arg == 3 )

	cmp	eax, 3
	jne	SHORT $LN1@display_fi

; 65   :      { ps_colorflag = gridflag = labelflag = crossingflag = -1; }

	or	ecx, -1
	mov	DWORD PTR _crossingflag, ecx
	mov	DWORD PTR _labelflag, ecx
	mov	DWORD PTR _gridflag, ecx
	mov	DWORD PTR _ps_colorflag, ecx
$LN1@display_fi:

; 66   :     do_gfile('0'+arg,NULL);

	push	0
	add	eax, 48					; 00000030H
	push	eax
$LN9@display_fi:
	call	_do_gfile

; 67   :   }
; 68   : } // end display_file()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	add	esp, 8
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_display_file ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_09EDOCBEHH@DISPLAY?4C?$AA@		; `string'
PUBLIC	_depth$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_generate_transforms
EXTRN	_determinant:PROC
EXTRN	_transform_colors_flag:DWORD
EXTRN	_transform_colors:DWORD
EXTRN	_transform_parity:DWORD
EXTRN	_allocate_transform_colors:PROC
EXTRN	_set_view_transforms_global:PROC
EXTRN	_kb_calloc:PROC
EXTRN	_myfree:PROC
EXTRN	_view_transform_det:DWORD
EXTRN	_mat_mult:PROC
EXTRN	_view_transform_gens:DWORD
EXTRN	_transform_gen_count:DWORD
EXTRN	_free_matrix3:PROC
EXTRN	_matcopy:PROC
EXTRN	_identmat:DWORD
EXTRN	_kb_dmatrix3:PROC
EXTRN	_transform_depth:DWORD
EXTRN	_transform_count:DWORD
EXTRN	_view_transforms:DWORD
EXTRN	_mat2d_setup:PROC
_BSS	SEGMENT
_work_transforms DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_09EDOCBEHH@DISPLAY?4C?$AA@
CONST	SEGMENT
??_C@_09EDOCBEHH@DISPLAY?4C?$AA@ DB 'DISPLAY.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _generate_transforms
_TEXT	SEGMENT
_temp_matqXvS$ = -440					; size = 28
_temp_mat$ = -412					; size = 4
_depth$GSCopy$ = -408					; size = 4
_did_graphlock_here$89146 = -404			; size = 4
_level$ = -400						; size = 4
_temp_matxJ$ = -396					; size = 392
__$ArrayPad$ = -4					; size = 4
_depth$ = 8						; size = 4
_generate_transforms PROC				; COMDAT

; 392  : { int start,stop; /* range of transforms to apply gens to */

	push	ebp
	mov	ebp, esp
	sub	esp, 440				; 000001b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	edi
	mov	edi, DWORD PTR _depth$[ebp]

; 393  :   int i,j,k,n,level;
; 394  :   MAT2D(temp_mat,MAXCOORD+1,MAXCOORD+1);

	push	7
	push	7
	lea	eax, DWORD PTR _temp_matxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp_matqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _depth$GSCopy$[ebp], edi
	call	_mat2d_setup

; 395  : 
; 396  :   /* clean up old stuff */
; 397  :   view_transforms = NULL;

	xor	ebx, ebx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _temp_mat$[ebp], eax
	mov	DWORD PTR _view_transforms, ebx

; 398  :   transform_count = 0;

	mov	DWORD PTR _transform_count, ebx

; 399  :   transform_depth = depth;

	mov	DWORD PTR _transform_depth, edi

; 400  :   if ( depth < 1 ) return;

	cmp	edi, 1
	jl	$LN34@generate_t

; 401  :   trans_max = 50;
; 402  : 
; 403  :   /* new stuff */
; 404  :   work_transforms = dmatrix3(depth+1,SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	push	esi
	push	404					; 00000194H
	inc	eax
	push	OFFSET ??_C@_09EDOCBEHH@DISPLAY?4C?$AA@
	push	eax
	push	eax
	lea	edx, DWORD PTR [edi+1]
	push	edx
	mov	DWORD PTR _trans_max, 50		; 00000032H
	call	_kb_dmatrix3

; 405  :   matcopy(work_transforms[0],identmat,SDIM+1,SDIM+1);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [eax]
	inc	ecx
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR _identmat
	push	ecx
	push	edx
	mov	DWORD PTR _work_transforms, eax
	call	_matcopy

; 406  : 
; 407  :    ENTER_GRAPH_MUTEX;

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	add	esp, 36					; 00000024H
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN32@generate_t
	push	ebx
	push	100000					; 000186a0H
	push	ebx
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89146[ebp], 1
	jmp	SHORT $restart$89149
$LN32@generate_t:
	mov	DWORD PTR _did_graphlock_here$89146[ebp], ebx
	npad	2
$restart$89149:

; 408  : restart:
; 409  :   if ( view_transforms ) free_matrix3(view_transforms);

	mov	eax, DWORD PTR _view_transforms
	test	eax, eax
	je	SHORT $LN30@generate_t
	push	eax
	call	_free_matrix3
	add	esp, 4
$LN30@generate_t:

; 410  :   view_transforms = dmatrix3(trans_max,SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	push	410					; 0000019aH
	inc	eax
	push	OFFSET ??_C@_09EDOCBEHH@DISPLAY?4C?$AA@
	push	eax
	push	eax
	mov	eax, DWORD PTR _trans_max
	push	eax
	call	_kb_dmatrix3

; 411  :   matcopy(view_transforms[0],identmat,SDIM+1,SDIM+1);

	mov	ecx, DWORD PTR _web+616
	inc	ecx
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR _identmat
	mov	DWORD PTR _view_transforms, eax
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	_matcopy

; 412  : 
; 413  :   /* initialize generation */
; 414  :   for ( k = 0 ; k < transform_gen_count ; k++ )

	mov	ecx, DWORD PTR _transform_gen_count
	add	esp, 36					; 00000024H
	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN71@generate_t
	npad	5
$LL73@generate_t:

; 415  :      matcopy(view_transforms[k+1],view_transform_gens[k],SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR _view_transforms
	inc	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR _view_transform_gens
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [edx+esi*4+4]
	push	ecx
	push	eax
	call	_matcopy
	mov	ecx, DWORD PTR _transform_gen_count
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, ecx
	jl	SHORT $LL73@generate_t
$LN71@generate_t:

; 416  :   transform_count = 1+transform_gen_count;

	lea	eax, DWORD PTR [ecx+1]

; 417  : 
; 418  :   /* apply all generators to transforms of last generation */
; 419  :   stop = 1;

	mov	ebx, 1

; 420  :   for ( level = 2 ; level <= depth ; level++ )

	mov	DWORD PTR _level$[ebp], 2
$LN97@generate_t:
	mov	DWORD PTR _transform_count, eax
	cmp	DWORD PTR _level$[ebp], edi
	jg	$LN24@generate_t

; 421  :   { start = stop; stop = transform_count;

	mov	edi, ebx
	mov	ebx, eax

; 422  :     for ( n = start ; n < stop ; n++ )

	cmp	edi, ebx
	jge	SHORT $LN21@generate_t
	npad	6
$LL75@generate_t:

; 423  :     { for ( i = 0 ; i < transform_gen_count ; i++ )

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN22@generate_t
$LL76@generate_t:

; 424  :       { mat_mult(view_transform_gens[i],view_transforms[n],
; 425  :           view_transforms[transform_count],SDIM+1,SDIM+1,SDIM+1);

	mov	ecx, DWORD PTR _web+616
	inc	ecx
	push	ecx
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR _view_transforms
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR _view_transform_gens
	push	edx
	mov	edx, DWORD PTR [ecx+esi*4]
	push	eax
	push	edx
	call	_mat_mult

; 426  :         transform_count++;

	mov	eax, DWORD PTR _transform_count

; 427  :         if ( transform_count >= trans_max ) { trans_max *= 2; goto restart; }

	mov	ecx, DWORD PTR _trans_max
	inc	eax
	add	esp, 24					; 00000018H
	mov	DWORD PTR _transform_count, eax
	cmp	eax, ecx
	jge	SHORT $LN45@generate_t

; 423  :     { for ( i = 0 ; i < transform_gen_count ; i++ )

	mov	ecx, DWORD PTR _transform_gen_count
	inc	esi
	cmp	esi, ecx
	jl	SHORT $LL76@generate_t
$LN22@generate_t:

; 422  :     for ( n = start ; n < stop ; n++ )

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL75@generate_t
$LN21@generate_t:

; 428  :       }
; 429  :     }
; 430  :     transform_count = mat_simplify(view_transforms,transform_count);

	push	eax
	mov	eax, DWORD PTR _view_transforms
	push	eax
	call	_mat_simplify
	mov	ecx, DWORD PTR _transform_gen_count
	mov	edi, DWORD PTR _depth$GSCopy$[ebp]
	add	esp, 8
	inc	DWORD PTR _level$[ebp]
	jmp	$LN97@generate_t
$LN45@generate_t:

; 412  : 
; 413  :   /* initialize generation */
; 414  :   for ( k = 0 ; k < transform_gen_count ; k++ )

	mov	edi, DWORD PTR _depth$GSCopy$[ebp]

; 427  :         if ( transform_count >= trans_max ) { trans_max *= 2; goto restart; }

	add	ecx, ecx
	mov	DWORD PTR _trans_max, ecx
	jmp	$restart$89149
$LN24@generate_t:

; 431  :   }
; 432  :   if ( view_transform_det ) myfree((char*)view_transform_det);

	mov	ecx, DWORD PTR _view_transform_det
	test	ecx, ecx
	je	SHORT $LN16@generate_t
	push	ecx
	call	_myfree
	mov	eax, DWORD PTR _transform_count
	add	esp, 4
$LN16@generate_t:

; 433  :   view_transform_det = (int*)mycalloc(transform_count,sizeof(int));

	push	433					; 000001b1H
	push	OFFSET ??_C@_09EDOCBEHH@DISPLAY?4C?$AA@
	push	4
	push	eax
	call	_kb_calloc
	mov	DWORD PTR _view_transform_det, eax

; 434  : 
; 435  :   set_view_transforms_global();

	call	_set_view_transforms_global

; 436  :   allocate_transform_colors(transform_count);

	mov	edx, DWORD PTR _transform_count
	push	edx
	call	_allocate_transform_colors

; 437  : 
; 438  :   if ( transform_parity ) myfree((char*)transform_parity);

	mov	eax, DWORD PTR _transform_parity
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN15@generate_t
	push	eax
	call	_myfree
	add	esp, 4
$LN15@generate_t:

; 439  :   transform_parity = (int*)mycalloc(transform_count,sizeof(int));

	mov	eax, DWORD PTR _transform_count
	push	439					; 000001b7H
	push	OFFSET ??_C@_09EDOCBEHH@DISPLAY?4C?$AA@
	push	4
	push	eax
	call	_kb_calloc

; 440  :   for ( n = 0 ; n < transform_count ; n++ )

	xor	esi, esi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _transform_parity, eax
	cmp	DWORD PTR _transform_count, esi
	jle	$LN12@generate_t
	fldz
$LN68@generate_t:

; 441  :   {
; 442  :     if ( view_transforms[n][SDIM][SDIM] < 0.0 )

	mov	ecx, DWORD PTR _view_transforms
	fld	QWORD PTR __real@bff0000000000000
	mov	eax, DWORD PTR _web+616
	fxch	ST(1)
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR [edx+eax*4]
	fcomp	QWORD PTR [ecx+eax*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN81@generate_t

; 443  :     { transform_colors[n] = SWAP_COLORS;

	mov	edx, DWORD PTR _transform_colors
	mov	DWORD PTR [edx+esi*4], 1

; 444  :       transform_colors_flag = 1;   
; 445  :       for ( i = 0 ; i <= SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	xor	edi, edi
	mov	DWORD PTR _transform_colors_flag, 1
	test	edx, edx
	js	SHORT $LN83@generate_t
$LN77@generate_t:

; 446  :         for ( j = 0 ; j <= SDIM ; j++ )

	xor	ecx, ecx
	test	edx, edx
	js	SHORT $LN9@generate_t
	mov	eax, DWORD PTR _view_transforms
	mov	edx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [edx+edi*4]
$LN78@generate_t:

; 447  :           view_transforms[n][i][j] *= -1;

	fld	QWORD PTR [eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jle	SHORT $LN78@generate_t
$LN9@generate_t:

; 444  :       transform_colors_flag = 1;   
; 445  :       for ( i = 0 ; i <= SDIM ; i++ )

	inc	edi
	cmp	edi, edx
	jle	SHORT $LN77@generate_t

; 448  :     }
; 449  :     else transform_colors[n] = SAME_COLOR;

	jmp	SHORT $LN83@generate_t
$LN81@generate_t:
	mov	eax, DWORD PTR _transform_colors
	mov	DWORD PTR [eax+esi*4], 0
	mov	edx, DWORD PTR _web+616
$LN83@generate_t:

; 450  : 
; 451  :     matcopy(temp_mat,view_transforms[n],SDIM+1,SDIM+1);

	mov	ecx, DWORD PTR _view_transforms
	fstp	ST(0)
	mov	edi, DWORD PTR _temp_mat$[ebp]
	lea	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR [ecx+esi*4]
	push	eax
	push	eax
	push	edx
	push	edi
	call	_matcopy

; 452  :     if ( determinant(temp_mat,SDIM+1) > 0.0 )

	mov	eax, DWORD PTR _web+616
	inc	eax
	push	eax
	push	edi
	call	_determinant
	fldz
	fcom	ST(1)
	add	esp, 24					; 00000018H
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN3@generate_t

; 453  :        view_transform_det[n] = 1;

	mov	ecx, DWORD PTR _view_transform_det
	mov	DWORD PTR [ecx+esi*4], 1
	jmp	SHORT $LN13@generate_t
$LN3@generate_t:

; 454  :     else  view_transform_det[n] = -1;

	mov	edx, DWORD PTR _view_transform_det
	mov	DWORD PTR [edx+esi*4], -1
$LN13@generate_t:

; 440  :   for ( n = 0 ; n < transform_count ; n++ )

	inc	esi
	cmp	esi, DWORD PTR _transform_count
	jl	$LN68@generate_t
	fstp	ST(0)
$LN12@generate_t:

; 455  :   }
; 456  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89146[ebp], 0
	pop	esi
	je	SHORT $LN1@generate_t
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@generate_t:

; 457  :   free_matrix3(work_transforms);

	mov	ecx, DWORD PTR _work_transforms
	push	ecx
	call	_free_matrix3
	add	esp, 4
$LN34@generate_t:

; 458  : } /* end generate_transforms() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_generate_transforms ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@BJKPGBLC@Illegal?5character?5?8?$CFc?8?5in?5transf@ ; `string'
PUBLIC	??_C@_0BE@EIHIGIAL@No?5generator?5?8?$CFc?8?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DB@GGOPANPP@Transform?5expression?5has?5unmatch@ ; `string'
PUBLIC	??_C@_0CJ@EIMLHGKK@Illegal?5transform?5expression?5syn@ ; `string'
PUBLIC	_expr$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_transform_gen_expr
EXTRN	_strncpy:PROC
EXTRN	_transform_expr:BYTE
EXTRN	_atoi:PROC
EXTRN	_isdigit:PROC
EXTRN	_transform_gen_swap:DWORD
EXTRN	_isalpha:PROC
;	COMDAT ??_C@_0DB@BJKPGBLC@Illegal?5character?5?8?$CFc?8?5in?5transf@
CONST	SEGMENT
??_C@_0DB@BJKPGBLC@Illegal?5character?5?8?$CFc?8?5in?5transf@ DB 'Illegal'
	DB	' character ''%c'' in transform expression.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EIHIGIAL@No?5generator?5?8?$CFc?8?4?6?$AA@
CONST	SEGMENT
??_C@_0BE@EIHIGIAL@No?5generator?5?8?$CFc?8?4?6?$AA@ DB 'No generator ''%'
	DB	'c''.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GGOPANPP@Transform?5expression?5has?5unmatch@
CONST	SEGMENT
??_C@_0DB@GGOPANPP@Transform?5expression?5has?5unmatch@ DB 'Transform exp'
	DB	'ression has unmatched parentheses.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EIMLHGKK@Illegal?5transform?5expression?5syn@
CONST	SEGMENT
??_C@_0CJ@EIMLHGKK@Illegal?5transform?5expression?5syn@ DB 'Illegal trans'
	DB	'form expression syntax: %s', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _transform_gen_expr
_TEXT	SEGMENT
_temp_matqXvS$ = -2480					; size = 28
tv555 = -2452						; size = 4
_temp_mat$ = -2448					; size = 4
tv597 = -2444						; size = 4
_expr$GSCopy$ = -2440					; size = 4
tv1018 = -2436						; size = 4
_old_mats$ = -2436					; size = 4
_new_count$ = -2432					; size = 4
tv1584 = -2428						; size = 4
tv1118 = -2428						; size = 4
tv1069 = -2428						; size = 4
tv1054 = -2428						; size = 4
_c$ = -2424						; size = 4
tv984 = -2420						; size = 4
_new_mats$ = -2420					; size = 4
tv1613 = -2416						; size = 4
tv989 = -2416						; size = 4
_j$ = -2416						; size = 4
tv1543 = -2412						; size = 4
tv964 = -2412						; size = 4
_k$ = -2408						; size = 4
_m$ = -2408						; size = 4
tv1091 = -2404						; size = 4
tv1008 = -2404						; size = 4
tv1000 = -2404						; size = 4
tv558 = -2404						; size = 4
tv493 = -2404						; size = 4
tv442 = -2404						; size = 4
_did_graphlock_here$89343 = -2404			; size = 4
tv665 = -2400						; size = 4
_stacktop$ = -2400					; size = 4
_temp_matxJ$ = -2396					; size = 392
_stack$ = -2004						; size = 2000
__$ArrayPad$ = -4					; size = 4
_expr$ = 8						; size = 4
_transform_gen_expr PROC				; COMDAT

; 533  : {   int errnum = 0;

	push	ebp
	mov	ebp, esp
	sub	esp, 2480				; 000009b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _expr$[ebp]
	push	edi

; 534  :     struct stack stack[SMAX];
; 535  :     int stacktop;
; 536  :     char *c;  /* next character */
; 537  :     int new_count;
; 538  :     REAL ***new_mats;
; 539  :     int i,j,k,n,m;
; 540  :     int old_count;
; 541  :     REAL ***old_mats;
; 542  :     MAT2D(temp_mat,MAXCOORD+1,MAXCOORD+1);

	push	7
	push	7
	lea	eax, DWORD PTR _temp_matxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp_matqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _expr$GSCopy$[ebp], esi
	call	_mat2d_setup
	mov	DWORD PTR _temp_mat$[ebp], eax

; 543  : 
; 544  :     if ( expr[0] == 0 ) /* empty transform string */

	xor	eax, eax
	add	esp, 16					; 00000010H
	cmp	BYTE PTR [esi], al
	jne	SHORT $LN113@transform_

; 545  :     { stacktop = 1 ; stack[1].count = 1; 
; 546  :       stack[stacktop].mats = dmatrix3(1,SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	push	546					; 00000222H
	inc	eax
	push	OFFSET ??_C@_09EDOCBEHH@DISPLAY?4C?$AA@
	push	eax
	push	eax
	push	1
	mov	DWORD PTR _stack$[ebp+28], 1
	call	_kb_dmatrix3

; 547  :       matcopy(stack[stacktop].mats[0],identmat,SDIM+1,SDIM+1);

	mov	edx, DWORD PTR _identmat
	mov	esi, eax
	mov	eax, DWORD PTR _web+616
	inc	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR [esi]
	push	edx
	push	eax
	call	_matcopy
	add	esp, 36					; 00000024H

; 548  :       goto skip_stuff;

	jmp	$skip_stuff$89243
$LN113@transform_:

; 549  :     }
; 550  : 
; 551  :     stacktop = 0;
; 552  :     stack[stacktop].type = G_START;
; 553  :     c =  expr;

	mov	DWORD PTR _c$[ebp], esi
	mov	DWORD PTR _stacktop$[ebp], eax
	mov	DWORD PTR _stack$[ebp], eax
	mov	esi, eax
	npad	3
$LL166@transform_:

; 695  : 
; 696  :         c++;

	mov	edi, DWORD PTR _web+616
	npad	10
$LL112@transform_:

; 554  : 
; 555  :     while ( *c || (stacktop > 1) )

	mov	ebx, DWORD PTR _c$[ebp]
	cmp	BYTE PTR [ebx], 0
	jne	SHORT $LN170@transform_
	cmp	esi, 1
	jle	$LN219@transform_
$LN170@transform_:

; 556  :     { /* test first for reduction */
; 557  :       if ( stack[stacktop].type == G_SET )

	lea	ecx, DWORD PTR [esi+esi*4]
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR _stack$[ebp+ecx]
	lea	eax, DWORD PTR _stack$[ebp+ecx]
	mov	DWORD PTR tv964[ebp], ecx
	cmp	edx, 2
	jne	$LN109@transform_

; 558  :       {  switch ( stack[stacktop-1].type )

	mov	edx, DWORD PTR [eax-20]
	dec	edx
	cmp	edx, 7
	ja	$LN173@transform_
	jmp	DWORD PTR $LN222@transform_[edx*4]
$LN106@transform_:

; 559  :          { 
; 560  :              case G_SET:  /* form product */
; 561  :                 new_count = stack[stacktop].count*stack[stacktop-1].count;

	mov	eax, DWORD PTR tv964[ebp]
	mov	ecx, DWORD PTR _stack$[ebp+eax-12]
	mov	eax, DWORD PTR _stack$[ebp+eax+8]
	mov	DWORD PTR tv989[ebp], eax
	imul	eax, ecx

; 562  :                 new_mats = dmatrix3(new_count+1,SDIM+1,SDIM+1);

	push	562					; 00000232H
	push	OFFSET ??_C@_09EDOCBEHH@DISPLAY?4C?$AA@
	inc	edi
	push	edi
	mov	DWORD PTR _new_count$[ebp], eax
	inc	eax
	push	edi
	push	eax
	call	_kb_dmatrix3

; 563  :                 for ( m = 0, k = 0 ; k < stack[stacktop-1].count ; k++ )

	mov	ecx, DWORD PTR tv964[ebp]
	xor	ebx, ebx
	add	esp, 20					; 00000014H
	mov	DWORD PTR _new_mats$[ebp], eax
	mov	DWORD PTR _k$[ebp], ebx
	cmp	DWORD PTR _stack$[ebp+ecx-12], ebx
	jle	$LN103@transform_
	mov	edx, ecx
	mov	eax, DWORD PTR _stack$[ebp+edx-12]
	mov	DWORD PTR tv1018[ebp], eax
$LL180@transform_:

; 564  :                  for ( j = 0 ; j < stack[stacktop].count ; j++,m++ )

	cmp	DWORD PTR tv989[ebp], 0
	jle	SHORT $LN104@transform_
	mov	eax, DWORD PTR tv964[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _stack$[ebp+eax-8]
	mov	edi, DWORD PTR _stack$[ebp+eax+12]
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _stack$[ebp+eax+8]
	mov	DWORD PTR tv1008[ebp], ecx
	mov	DWORD PTR tv665[ebp], edx
	npad	1
$LL181@transform_:

; 565  :                     mat_mult(stack[stacktop-1].mats[k],stack[stacktop].mats[j],
; 566  :                         new_mats[m],SDIM+1,SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR [edi]
	inc	eax
	push	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR _new_mats$[ebp]
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR tv1008[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	ecx
	call	_mat_mult
	add	esp, 24					; 00000018H
	add	edi, 4
	inc	ebx
	dec	DWORD PTR tv665[ebp]
	jne	SHORT $LL181@transform_
$LN104@transform_:

; 563  :                 for ( m = 0, k = 0 ; k < stack[stacktop-1].count ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR tv1018[ebp]
	jl	$LL180@transform_
$LN103@transform_:

; 567  :                 free_matrix3(stack[stacktop-1].mats);

	mov	edi, DWORD PTR tv964[ebp]
	mov	edx, DWORD PTR _stack$[ebp+edi-8]
	lea	edi, DWORD PTR _stack$[ebp+edi+12]
	push	edx
	call	_free_matrix3

; 568  :                 free_matrix3(stack[stacktop].mats);

	mov	eax, DWORD PTR [edi]
	push	eax
	call	_free_matrix3

; 569  :                 stacktop--;
; 570  :                 stack[stacktop].count = mat_simplify(new_mats,new_count);

	mov	ecx, DWORD PTR _new_count$[ebp]
	mov	ebx, DWORD PTR _new_mats$[ebp]
	dec	esi
	lea	edi, DWORD PTR [esi+esi*4]
	push	ecx
	add	edi, edi
	push	ebx
	mov	DWORD PTR _stacktop$[ebp], esi
	add	edi, edi
	call	_mat_simplify
	add	esp, 16					; 00000010H
	mov	DWORD PTR _stack$[ebp+edi+8], eax

; 571  :                 stack[stacktop].mats = new_mats;

	mov	DWORD PTR _stack$[ebp+edi+12], ebx

; 572  :                 stack[stacktop].type = G_SET;

	mov	DWORD PTR _stack$[ebp+edi], 2

; 573  :                 continue;

	jmp	$LL166@transform_
$LN99@transform_:

; 574  : 
; 575  :              case G_SINGLE:  /* single matrix in [...] */
; 576  :                 mat_mult(stack[stacktop-1].mats[1],stack[stacktop].mats[1],
; 577  :                      temp_mat,SDIM+1,SDIM+1,SDIM+1);

	mov	ebx, DWORD PTR _stack$[ebp+ecx+12]
	mov	edx, DWORD PTR [ebx+4]
	inc	edi
	push	edi
	push	edi
	lea	eax, DWORD PTR _stack$[ebp+ecx+12]
	mov	eax, DWORD PTR [eax-20]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR _temp_mat$[ebp]
	push	edi
	push	edx
	push	ecx
	call	_mat_mult

; 578  :                 free_matrix3(stack[stacktop].mats);

	push	ebx
	call	_free_matrix3

; 579  :                 stacktop--;
; 580  :                 matcopy(stack[stacktop].mats[1],temp_mat,SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	inc	eax
	push	eax
	dec	esi
	push	eax
	lea	edx, DWORD PTR [esi+esi*4]
	mov	eax, DWORD PTR _stack$[ebp+edx*4+12]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	push	ecx
	mov	DWORD PTR _stacktop$[ebp], esi
	call	_matcopy
	add	esp, 44					; 0000002cH

; 581  :                 continue;

	jmp	$LL166@transform_
$LN98@transform_:

; 582  :                 
; 583  :              case G_LBRACKET: /* convert to single */
; 584  :                 stack[stacktop].type = G_SINGLE;

	mov	DWORD PTR [eax], 7

; 585  :                 continue;

	jmp	$LL112@transform_
$LN97@transform_:

; 586  : 
; 587  :              case G_NUM: /* form powers */
; 588  :                 if ( stack[stacktop-1].num < 2 )

	lea	edx, DWORD PTR _stack$[ebp+ecx-16]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, 2
	jge	SHORT $LN96@transform_

; 589  :                   { stack[stacktop-1] = stack[stacktop]; stacktop--; continue;}

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax-20], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax-16], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax-12], edx
	mov	edx, DWORD PTR [eax+16]
	dec	esi
	mov	DWORD PTR [eax-8], ecx
	mov	DWORD PTR [eax-4], edx
	mov	DWORD PTR _stacktop$[ebp], esi
	jmp	$LL112@transform_
$LN96@transform_:

; 590  :                 new_mats = stack[stacktop].mats;

	mov	eax, DWORD PTR tv964[ebp]
	mov	ebx, DWORD PTR _stack$[ebp+eax+12]

; 591  :                 new_count = stack[stacktop].count;

	lea	eax, DWORD PTR _stack$[ebp+eax+8]
	mov	DWORD PTR tv984[ebp], eax
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv1000[ebp], ebx
	mov	DWORD PTR tv989[ebp], eax
	mov	esi, eax

; 592  :                 for ( k = 1 ; k < stack[stacktop-1].num ; k++ )

	mov	DWORD PTR _k$[ebp], 1
	cmp	ecx, 1
	jle	$LN93@transform_

; 590  :                 new_mats = stack[stacktop].mats;

	mov	DWORD PTR tv1054[ebp], ecx

; 592  :                 for ( k = 1 ; k < stack[stacktop-1].num ; k++ )

	jmp	SHORT $LN95@transform_
$LL167@transform_:
	mov	edi, DWORD PTR _web+616
$LN95@transform_:

; 594  :                   old_mats = new_mats;
; 595  :                   new_count = new_count * stack[stacktop].count;

	mov	ecx, DWORD PTR tv989[ebp]
	imul	ecx, esi

; 596  :                   new_mats = dmatrix3(new_count+1,SDIM+1,SDIM+1);

	push	596					; 00000254H
	lea	eax, DWORD PTR [edi+1]
	push	OFFSET ??_C@_09EDOCBEHH@DISPLAY?4C?$AA@
	push	eax
	mov	DWORD PTR _new_count$[ebp], ecx
	push	eax
	inc	ecx
	push	ecx
	mov	DWORD PTR _old_mats$[ebp], ebx
	call	_kb_dmatrix3
	add	esp, 20					; 00000014H

; 597  :                   for ( m =0, n = 0 ; n < old_count ; n++ )

	xor	edi, edi
	mov	ebx, eax
	test	esi, esi
	jle	SHORT $LN90@transform_

; 593  :                 { old_count = new_count;

	mov	ecx, DWORD PTR _old_mats$[ebp]
	mov	DWORD PTR tv1543[ebp], ecx
	mov	DWORD PTR tv555[ebp], esi
	npad	1
$LL182@transform_:

; 598  :                     for ( j = 0 ; j < stack[stacktop].count ; j++,m++ )

	cmp	DWORD PTR tv989[ebp], 0
	jle	SHORT $LN91@transform_
	mov	edx, DWORD PTR tv984[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR tv1000[ebp]
	mov	DWORD PTR tv597[ebp], eax
	npad	3
$LL183@transform_:

; 599  :                      mat_mult(old_mats[n],stack[stacktop].mats[j],
; 600  :                         new_mats[m],SDIM+1,SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR [ebx+edi*4]
	mov	edx, DWORD PTR [esi]
	inc	eax
	push	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR tv1543[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	ecx
	call	_mat_mult
	add	esp, 24					; 00000018H
	add	esi, 4
	inc	edi
	dec	DWORD PTR tv597[ebp]
	jne	SHORT $LL183@transform_
$LN91@transform_:

; 597  :                   for ( m =0, n = 0 ; n < old_count ; n++ )

	add	DWORD PTR tv1543[ebp], 4
	dec	DWORD PTR tv555[ebp]
	jne	SHORT $LL182@transform_
$LN90@transform_:

; 601  :                   if ( k > 1 ) free_matrix3(old_mats);

	mov	edi, DWORD PTR _k$[ebp]
	cmp	edi, 1
	jle	SHORT $LN86@transform_
	mov	edx, DWORD PTR _old_mats$[ebp]
	push	edx
	call	_free_matrix3
	add	esp, 4
$LN86@transform_:

; 602  :                   new_count = mat_simplify(new_mats,new_count);

	mov	eax, DWORD PTR _new_count$[ebp]
	push	eax
	push	ebx
	call	_mat_simplify
	inc	edi
	add	esp, 8
	mov	esi, eax
	mov	DWORD PTR _k$[ebp], edi
	cmp	edi, DWORD PTR tv1054[ebp]
	jl	$LL167@transform_
$LN93@transform_:

; 603  :                 }
; 604  :                 free_matrix3(stack[stacktop].mats);

	mov	ecx, DWORD PTR tv1000[ebp]
	push	ecx
	call	_free_matrix3

; 605  :                 stacktop--;

	mov	eax, DWORD PTR _stacktop$[ebp]
	dec	eax
	mov	DWORD PTR _stacktop$[ebp], eax

; 606  :                 stack[stacktop].count = new_count;

	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	add	esp, 4
	add	eax, eax
	mov	DWORD PTR _stack$[ebp+eax+8], esi

; 607  :                 stack[stacktop].mats = new_mats;
; 608  :                 stack[stacktop].type = G_SET;
; 609  :                 continue;

	mov	esi, DWORD PTR _stacktop$[ebp]
	mov	DWORD PTR _stack$[ebp+eax+12], ebx
	mov	DWORD PTR _stack$[ebp+eax], 2
	jmp	$LL166@transform_
$LN85@transform_:

; 610  : 
; 611  :              case G_OR: /* form union */     
; 612  :                 if ( *c & (*c != '|') & (*c != ')') ) break; /* go to accept next */

	mov	al, BYTE PTR [ebx]
	xor	edx, edx
	cmp	al, 124					; 0000007cH
	setne	dl
	xor	ecx, ecx
	cmp	al, 41					; 00000029H
	setne	cl
	movsx	eax, al
	and	edx, ecx
	test	edx, eax
	jne	$LN173@transform_

; 613  :                 new_count = stack[stacktop].count+stack[stacktop-2].count;

	mov	ecx, DWORD PTR tv964[ebp]
	mov	ecx, DWORD PTR _stack$[ebp+ecx+8]
	lea	ebx, DWORD PTR [esi+esi*4-10]
	add	ebx, ebx

; 614  :                 new_mats = dmatrix3(new_count+1,SDIM+1,SDIM+1);

	push	614					; 00000266H
	add	ebx, ebx
	mov	eax, DWORD PTR _stack$[ebp+ebx+8]
	mov	DWORD PTR tv1069[ebp], eax
	push	OFFSET ??_C@_09EDOCBEHH@DISPLAY?4C?$AA@
	add	eax, ecx
	inc	edi
	push	edi
	mov	DWORD PTR _new_count$[ebp], eax
	inc	eax
	push	edi
	push	eax
	call	_kb_dmatrix3
	add	esp, 20					; 00000014H

; 615  :                 for ( m = 0, k = 0 ; k < stack[stacktop-2].count ; k++,m++ )

	cmp	DWORD PTR tv1069[ebp], 0
	mov	DWORD PTR _new_mats$[ebp], eax
	mov	DWORD PTR _m$[ebp], 0
	jle	SHORT $LN171@transform_
	mov	edi, eax
	mov	eax, DWORD PTR _stack$[ebp+ebx+12]
	sub	eax, edi
	mov	DWORD PTR tv1584[ebp], eax
	mov	eax, DWORD PTR _stack$[ebp+ebx+8]
	mov	DWORD PTR tv493[ebp], eax
	mov	DWORD PTR _m$[ebp], eax
	npad	3
$LL184@transform_:

; 616  :                   matcopy(new_mats[m],stack[stacktop-2].mats[k],SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR tv1584[ebp]
	mov	ecx, DWORD PTR [edi]
	inc	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR [edx+edi]
	push	eax
	push	ecx
	call	_matcopy
	add	esp, 16					; 00000010H
	add	edi, 4
	dec	DWORD PTR tv493[ebp]
	jne	SHORT $LL184@transform_
$LN171@transform_:

; 617  :                 for ( j = 0 ; j < stack[stacktop].count ; j++,m++ )

	mov	eax, DWORD PTR tv964[ebp]
	cmp	DWORD PTR _stack$[ebp+eax+8], 0
	jle	SHORT $LN78@transform_
	mov	edx, DWORD PTR _new_mats$[ebp]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edi, DWORD PTR _stack$[ebp+eax+12]
	mov	eax, DWORD PTR _stack$[ebp+eax+8]
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv1613[ebp], edx
	mov	DWORD PTR tv442[ebp], eax
$LL185@transform_:

; 618  :                   matcopy(new_mats[m],stack[stacktop].mats[j],SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR tv1613[ebp]
	inc	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	eax
	call	_matcopy
	add	DWORD PTR tv1613[ebp], 4
	add	esp, 16					; 00000010H
	add	edi, 4
	dec	DWORD PTR tv442[ebp]
	jne	SHORT $LL185@transform_
$LN78@transform_:

; 619  :                 free_matrix3(stack[stacktop-2].mats);

	mov	ecx, DWORD PTR _stack$[ebp+ebx+12]
	push	ecx
	call	_free_matrix3

; 620  :                 free_matrix3(stack[stacktop].mats);

	mov	edx, DWORD PTR tv964[ebp]
	mov	eax, DWORD PTR _stack$[ebp+edx+12]
	push	eax
	call	_free_matrix3

; 621  :                 stacktop -= 2;
; 622  :                 stack[stacktop].count = mat_simplify(new_mats,new_count);

	mov	ecx, DWORD PTR _new_count$[ebp]
	mov	edi, DWORD PTR _new_mats$[ebp]
	add	esi, -2					; fffffffeH
	lea	ebx, DWORD PTR [esi+esi*4]
	push	ecx
	add	ebx, ebx
	push	edi
	mov	DWORD PTR _stacktop$[ebp], esi
	add	ebx, ebx
	call	_mat_simplify
	add	esp, 16					; 00000010H
	mov	DWORD PTR _stack$[ebp+ebx+8], eax

; 623  :                 stack[stacktop].mats = new_mats;

	mov	DWORD PTR _stack$[ebp+ebx+12], edi

; 624  :                 stack[stacktop].type = G_SET;

	mov	DWORD PTR _stack$[ebp+ebx], 2

; 625  :                 continue;

	jmp	$LL166@transform_
$LN77@transform_:

; 626  : 
; 627  :              case G_NO_IDENTITY: /* strip out identity matrix */
; 628  :                 /* move set down in stack */
; 629  :                 stacktop -= 1;

	dec	esi

; 630  :                 stack[stacktop].type = G_SET;

	lea	eax, DWORD PTR [esi+esi*4]
	add	eax, eax
	add	eax, eax

; 631  :                 stack[stacktop].count = stack[stacktop+1].count;

	mov	ecx, DWORD PTR _stack$[ebp+eax+28]
	lea	edx, DWORD PTR _stack$[ebp+eax+8]
	mov	DWORD PTR tv984[ebp], edx
	mov	DWORD PTR [edx], ecx

; 632  :                 stack[stacktop].mats = stack[stacktop+1].mats;

	mov	edx, DWORD PTR _stack$[ebp+eax+32]

; 633  :                 /* search for and remove identity */
; 634  :                 for ( j = 0 ; j < stack[stacktop].count ; j++ )

	xor	ebx, ebx
	mov	DWORD PTR _stacktop$[ebp], esi
	mov	DWORD PTR _stack$[ebp+eax], 2
	mov	DWORD PTR tv1091[ebp], edx
	mov	DWORD PTR _stack$[ebp+eax+12], edx
	mov	DWORD PTR _j$[ebp], ebx
	test	ecx, ecx
	jle	$LL112@transform_
	npad	10
$LL186@transform_:

; 635  :                 { for ( m = 0 ; m <= SDIM ; m++ )

	mov	DWORD PTR _m$[ebp], 0
	test	edi, edi
	js	SHORT $LN71@transform_
	npad	2
$LL73@transform_:

; 758  :     if ( determinant(temp_mat,SDIM+1) > 0.0 )

	mov	eax, DWORD PTR _identmat
	mov	ecx, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR tv1091[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	ebx, DWORD PTR _m$[ebp]
	mov	ebx, DWORD PTR [eax+ebx*4]
	xor	edx, edx
	sub	ebx, ecx
$LL187@transform_:

; 637  :                       if ( stack[stacktop].mats[j][m][n] != identmat[m][n] )

	fld	QWORD PTR [ebx+ecx]
	fld	QWORD PTR [ecx]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN144@transform_

; 636  :                     for ( n = 0 ; n <= SDIM ; n++ )

	inc	edx
	add	ecx, 8
	cmp	edx, edi
	jle	SHORT $LL187@transform_

; 731  :       if ( matcomp(stack[1].mats+n,&identmat) == 0 )

	mov	eax, DWORD PTR _m$[ebp]
	jmp	SHORT $LN72@transform_
$LN144@transform_:

; 638  :                       { n = m = 100;

	mov	eax, 100				; 00000064H
$LN72@transform_:

; 635  :                 { for ( m = 0 ; m <= SDIM ; m++ )

	mov	ebx, DWORD PTR _j$[ebp]
	inc	eax
	mov	DWORD PTR _m$[ebp], eax
	cmp	eax, edi
	jle	SHORT $LL73@transform_
$LN71@transform_:

; 639  :                         break;
; 640  :                       }
; 641  :                   if ( m == SDIM+1 )

	lea	eax, DWORD PTR [edi+1]
	cmp	DWORD PTR _m$[ebp], eax
	jne	SHORT $LN75@transform_

; 642  :                   { // remove matrix by replacing with last one
; 643  :                     if ( j < stack[stacktop].count-1 )

	mov	ecx, DWORD PTR tv984[ebp]
	mov	ecx, DWORD PTR [ecx]
	lea	edx, DWORD PTR [ecx-1]
	mov	DWORD PTR tv1118[ebp], edx
	cmp	ebx, edx
	jge	SHORT $LN178@transform_

; 644  :                       matcopy(stack[stacktop].mats[j],stack[stacktop].mats[stack[stacktop].count-1],SDIM+1,SDIM+1);

	push	eax
	push	eax
	mov	eax, DWORD PTR tv1091[ebp]
	mov	edx, DWORD PTR [eax+ecx*4-4]
	mov	eax, DWORD PTR [eax+ebx*4]
	push	edx
	push	eax
	call	_matcopy
	mov	edi, DWORD PTR _web+616
	mov	edx, DWORD PTR tv1118[ebp]
	add	esp, 16					; 00000010H
$LN178@transform_:

; 645  :                     stack[stacktop].count--;

	mov	ecx, DWORD PTR tv984[ebp]
	mov	DWORD PTR [ecx], edx
$LN75@transform_:

; 633  :                 /* search for and remove identity */
; 634  :                 for ( j = 0 ; j < stack[stacktop].count ; j++ )

	mov	edx, DWORD PTR tv984[ebp]
	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, DWORD PTR [edx]
	jl	$LL186@transform_

; 646  :                   }
; 647  :                 }
; 648  :                 continue;

	jmp	$LL112@transform_
$LN109@transform_:

; 649  : 
; 650  :  
; 651  :              } /* end switch */
; 652  :          }
; 653  :          else if ( stack[stacktop].type == G_RIGHT )

	cmp	edx, 5
	jne	SHORT $LN173@transform_

; 654  :          { if ( ((stack[stacktop-1].type != G_SET) && 
; 655  :                      (stack[stacktop-1].type != G_SINGLE)) ||
; 656  :                      ((stack[stacktop-2].type != G_LEFT)  &&
; 657  :                      (stack[stacktop-2].type != G_LBRACKET)) )

	mov	eax, DWORD PTR [eax-20]
	cmp	eax, 2
	je	SHORT $LN60@transform_
	cmp	eax, 7
	jne	$LN61@transform_
$LN60@transform_:
	lea	eax, DWORD PTR [esi+esi*4-10]
	mov	eax, DWORD PTR _stack$[ebp+eax*4]
	cmp	eax, 4
	je	SHORT $LN62@transform_
	cmp	eax, 6
	jne	$LN61@transform_
$LN62@transform_:
	add	esi, -2					; fffffffeH

; 662  :            }
; 663  :            stacktop -= 2;
; 664  :            stack[stacktop].type = G_SET;

	lea	eax, DWORD PTR [esi+esi*4]
	add	eax, eax
	add	eax, eax

; 665  :            stack[stacktop].count = stack[stacktop+1].count;

	mov	ecx, DWORD PTR _stack$[ebp+eax+28]

; 666  :            stack[stacktop].mats = stack[stacktop+1].mats;

	mov	edx, DWORD PTR _stack$[ebp+eax+32]
	mov	DWORD PTR _stacktop$[ebp], esi
	mov	DWORD PTR _stack$[ebp+eax], 2
	mov	DWORD PTR _stack$[ebp+eax+8], ecx
	mov	DWORD PTR _stack$[ebp+eax+12], edx

; 667  :            continue;

	jmp	$LL112@transform_
$LN173@transform_:

; 668  :          }
; 669  : 
; 670  :       /* shift */
; 671  :       if ( *c == 0 )

	mov	al, BYTE PTR [ebx]
	test	al, al
	je	$LN145@transform_

; 675  :       }
; 676  :       if ( isalpha(*c) )

	movsx	eax, al
	push	eax
	call	_isalpha

; 677  :       { n = toupper(*c) - 'A';  /* number of generator */

	movsx	ecx, BYTE PTR [ebx]
	add	esp, 4
	test	eax, eax
	je	$LN58@transform_
	movsx	edi, BYTE PTR _kb_upper_array[ecx]
	sub	edi, 65					; 00000041H

; 678  :         if ( n >= transform_gen_count )

	cmp	edi, DWORD PTR _transform_gen_count
	jge	$LN146@transform_

; 682  :         }
; 683  :         /* set up set */
; 684  :         stack[++stacktop].type = G_SET;

	inc	esi
	lea	ebx, DWORD PTR [esi+esi*4]
	add	ebx, ebx
	mov	eax, 2
	add	ebx, ebx
	mov	DWORD PTR _stack$[ebp+ebx], eax

; 685  :         /* include identity */
; 686  :         stack[stacktop].count = 2;

	mov	DWORD PTR _stack$[ebp+ebx+8], eax

; 687  :         stack[stacktop].mats = dmatrix3(2+1,SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	push	687					; 000002afH
	inc	eax
	push	OFFSET ??_C@_09EDOCBEHH@DISPLAY?4C?$AA@
	push	eax
	push	eax
	push	3
	mov	DWORD PTR _stacktop$[ebp], esi
	call	_kb_dmatrix3

; 688  :         matcopy(stack[stacktop].mats[0],identmat,SDIM+1,SDIM+1);

	mov	edx, DWORD PTR _identmat
	mov	ecx, eax
	mov	eax, DWORD PTR _web+616
	inc	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR [ecx]
	push	edx
	push	eax
	mov	DWORD PTR tv558[ebp], ecx
	mov	DWORD PTR _stack$[ebp+ebx+12], ecx
	call	_matcopy

; 689  :         matcopy(stack[stacktop].mats[1],view_transform_gens[n],SDIM+1,SDIM+1);      

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _view_transform_gens
	mov	edx, DWORD PTR [ecx+edi*4]
	inc	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR tv558[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	_matcopy

; 690  : 
; 691  :         if ( transform_gen_swap[n] )

	mov	edx, DWORD PTR _transform_gen_swap
	add	esp, 52					; 00000034H
	cmp	DWORD PTR [edx+edi*4], 0

; 692  :           for ( i = 0 ; i <= SDIM ; i++ )

	mov	edi, DWORD PTR _web+616
	je	SHORT $LN53@transform_
	xor	edx, edx
	test	edi, edi
	js	SHORT $LN53@transform_
	fld	QWORD PTR __real@bff0000000000000
	mov	ebx, DWORD PTR tv558[ebp]
$LN188@transform_:

; 693  :             for ( j = 0 ; j <= SDIM ; j++ )

	xor	ecx, ecx
	test	edi, edi
	js	SHORT $LN54@transform_
	mov	eax, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax+edx*4]
$LN189@transform_:

; 694  :               stack[stacktop].mats[1][i][j] *= -1;

	fld	QWORD PTR [eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edi, DWORD PTR _web+616
	cmp	ecx, edi
	jle	SHORT $LN189@transform_
$LN54@transform_:

; 692  :           for ( i = 0 ; i <= SDIM ; i++ )

	inc	edx
	cmp	edx, edi
	jle	SHORT $LN188@transform_
	fstp	ST(0)
$LN53@transform_:

; 695  : 
; 696  :         c++;

	inc	DWORD PTR _c$[ebp]
	jmp	$LL112@transform_
$LN58@transform_:

; 697  :       }
; 698  :       else if ( isdigit(*c) )

	push	ecx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN48@transform_

; 699  :       { stack[++stacktop].type = G_NUM;

	inc	esi
	lea	edi, DWORD PTR [esi+esi*4]
	add	edi, edi
	add	edi, edi

; 700  :         stack[stacktop].num = atoi(c);

	push	ebx
	mov	DWORD PTR _stacktop$[ebp], esi
	mov	DWORD PTR _stack$[ebp+edi], 1
	call	_atoi

; 701  :         while ( isdigit(*c) ) c++;

	movsx	edx, BYTE PTR [ebx]
	push	edx
	mov	DWORD PTR _stack$[ebp+edi+4], eax
	call	_isdigit
	add	esp, 8
	test	eax, eax
	je	$LL166@transform_
$LL47@transform_:
	movsx	eax, BYTE PTR [ebx+1]
	inc	ebx
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LL47@transform_

; 707  :       else if ( *c == ']' ) { stack[++stacktop].type = G_RIGHT; c++; }

	mov	DWORD PTR _c$[ebp], ebx
	jmp	$LL166@transform_
$LN48@transform_:

; 702  :       }
; 703  :       else if ( *c == '(' ) { stack[++stacktop].type = G_LEFT; c++; }

	mov	al, BYTE PTR [ebx]
	cmp	al, 40					; 00000028H
	jne	SHORT $LN44@transform_
	inc	esi
	lea	ecx, DWORD PTR [esi+esi*4]

; 707  :       else if ( *c == ']' ) { stack[++stacktop].type = G_RIGHT; c++; }

	inc	ebx
	mov	DWORD PTR _stack$[ebp+ecx*4], 4
	mov	DWORD PTR _stacktop$[ebp], esi
	mov	DWORD PTR _c$[ebp], ebx
	jmp	$LL166@transform_
$LN44@transform_:

; 704  :       else if ( *c == ')' ) { stack[++stacktop].type = G_RIGHT; c++; }

	cmp	al, 41					; 00000029H
	je	SHORT $LN216@transform_

; 705  :       else if ( *c == '|' ) { stack[++stacktop].type = G_OR; c++; }

	cmp	al, 124					; 0000007cH
	jne	SHORT $LN40@transform_
	inc	esi
	lea	eax, DWORD PTR [esi+esi*4]
	inc	ebx
	mov	DWORD PTR _stacktop$[ebp], esi
	mov	DWORD PTR _stack$[ebp+eax*4], 3
	mov	DWORD PTR _c$[ebp], ebx
	jmp	$LL166@transform_
$LN40@transform_:

; 706  :       else if ( *c == '[' ) { stack[++stacktop].type = G_LBRACKET; c++; }

	cmp	al, 91					; 0000005bH
	jne	SHORT $LN38@transform_
	inc	esi
	lea	ecx, DWORD PTR [esi+esi*4]
	inc	ebx
	mov	DWORD PTR _stacktop$[ebp], esi
	mov	DWORD PTR _stack$[ebp+ecx*4], 6
	mov	DWORD PTR _c$[ebp], ebx
	jmp	$LL166@transform_
$LN38@transform_:

; 707  :       else if ( *c == ']' ) { stack[++stacktop].type = G_RIGHT; c++; }

	cmp	al, 93					; 0000005dH
	jne	SHORT $LN36@transform_
$LN216@transform_:
	inc	esi
	lea	edx, DWORD PTR [esi+esi*4]
	inc	ebx
	mov	DWORD PTR _stack$[ebp+edx*4], 5
	mov	DWORD PTR _stacktop$[ebp], esi
	mov	DWORD PTR _c$[ebp], ebx
	jmp	$LL166@transform_
$LN36@transform_:

; 708  :       else if ( *c == '!' ) { stack[++stacktop].type = G_NO_IDENTITY; c++; }

	cmp	al, 33					; 00000021H
	jne	SHORT $LN34@transform_
	inc	esi
	lea	eax, DWORD PTR [esi+esi*4]
	inc	ebx
	mov	DWORD PTR _stacktop$[ebp], esi
	mov	DWORD PTR _stack$[ebp+eax*4], 8
	mov	DWORD PTR _c$[ebp], ebx
	jmp	$LL166@transform_
$LN34@transform_:

; 709  :       else if ( (*c==' ')||(*c=='\t') ) c++ ;

	cmp	al, 32					; 00000020H
	je	SHORT $LN31@transform_
	cmp	al, 9
	jne	$LN32@transform_
$LN31@transform_:
	inc	ebx
	mov	DWORD PTR _c$[ebp], ebx

; 713  :              goto err_exit;
; 714  :            }
; 715  :     }

	jmp	$LL166@transform_
$LN219@transform_:

; 716  : 
; 717  :   /* normal exit */
; 718  :   if ( (stacktop != 1) || (stack[1].type != G_SET) )

	jne	$LN175@transform_
	cmp	DWORD PTR _stack$[ebp+20], 2
	jne	$LN175@transform_
	mov	esi, DWORD PTR _stack$[ebp+32]
$skip_stuff$89243:

; 722  :   }
; 723  : 
; 724  : skip_stuff:
; 725  :     
; 726  :   strncpy(transform_expr,expr,sizeof(transform_expr));

	mov	ecx, DWORD PTR _expr$GSCopy$[ebp]
	push	100					; 00000064H
	push	ecx
	push	OFFSET _transform_expr
	call	_strncpy

; 727  : 
; 728  :   // Make sure identity matrix is first, if present
; 729  :   if ( matcomp(stack[1].mats+0,&identmat) != 0 )

	push	OFFSET _identmat
	push	esi
	call	_matcomp
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN174@transform_

; 730  :   { for ( n = 1 ; n < stack[1].count ; n++ )

	mov	edi, 1
	cmp	DWORD PTR _stack$[ebp+28], edi
	jle	SHORT $LN174@transform_
	lea	ebx, DWORD PTR [esi+4]
$LL191@transform_:

; 731  :       if ( matcomp(stack[1].mats+n,&identmat) == 0 )

	push	OFFSET _identmat
	push	ebx
	call	_matcomp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN147@transform_

; 730  :   { for ( n = 1 ; n < stack[1].count ; n++ )

	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR _stack$[ebp+28]
	jl	SHORT $LL191@transform_

; 731  :       if ( matcomp(stack[1].mats+n,&identmat) == 0 )

	jmp	SHORT $LN174@transform_
$LN147@transform_:

; 732  :       { matcopy(stack[1].mats[n],stack[1].mats[0],SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR [esi]
	inc	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR [esi+edi*4]
	push	edx
	push	eax
	call	_matcopy

; 733  :         matcopy(stack[1].mats[0],identmat,SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _identmat
	mov	edx, DWORD PTR [esi]
	inc	eax
	push	eax
	push	eax
	push	ecx
	push	edx
	call	_matcopy
	add	esp, 32					; 00000020H
$LN174@transform_:

; 734  :         break;
; 735  :       }        
; 736  :   }
; 737  : 
; 738  :   // Install
; 739  :   ENTER_GRAPH_MUTEX;

	mov	edi, DWORD PTR __imp__GetCurrentThreadId@0
	call	edi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN22@transform_
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	edi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89343[ebp], 1
	jmp	SHORT $LN21@transform_
$LN22@transform_:
	mov	DWORD PTR _did_graphlock_here$89343[ebp], 0
$LN21@transform_:

; 740  :   transform_count = stack[1].count;

	mov	eax, DWORD PTR _stack$[ebp+28]
	mov	DWORD PTR _transform_count, eax

; 741  :   if ( view_transforms ) free_matrix3(view_transforms);

	mov	eax, DWORD PTR _view_transforms
	test	eax, eax
	je	SHORT $LN20@transform_
	push	eax
	call	_free_matrix3
	add	esp, 4
$LN20@transform_:

; 742  :   view_transforms = stack[1].mats;

	mov	DWORD PTR _view_transforms, esi

; 743  :   set_view_transforms_global();

	call	_set_view_transforms_global

; 744  :   if ( view_transform_det ) myfree((char*)view_transform_det);

	mov	eax, DWORD PTR _view_transform_det
	test	eax, eax
	je	SHORT $LN19@transform_
	push	eax
	call	_myfree
	add	esp, 4
$LN19@transform_:

; 745  :   view_transform_det = (int*)mycalloc(transform_count,sizeof(int));

	mov	ecx, DWORD PTR _transform_count
	push	745					; 000002e9H
	push	OFFSET ??_C@_09EDOCBEHH@DISPLAY?4C?$AA@
	push	4
	push	ecx
	call	_kb_calloc

; 746  :   allocate_transform_colors(transform_count);

	mov	edx, DWORD PTR _transform_count
	push	edx
	mov	DWORD PTR _view_transform_det, eax
	call	_allocate_transform_colors

; 747  :   for ( n = 0 ; n < transform_count ; n++ )

	xor	esi, esi
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _transform_count, esi
	jle	$LN16@transform_
	fldz
	mov	ebx, DWORD PTR _temp_mat$[ebp]
$LN192@transform_:

; 748  :   { if ( view_transforms[n][SDIM][SDIM] < 0.0 )

	mov	eax, DWORD PTR _view_transforms
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR [ecx+eax*4]
	fcomp	QWORD PTR [edx+eax*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN15@transform_

; 749  :     { transform_colors[n] = SWAP_COLORS;

	mov	eax, DWORD PTR _transform_colors
	mov	DWORD PTR [eax+esi*4], 1

; 750  :       transform_colors_flag = 1;   
; 751  :       for ( i = 0 ; i <= SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	xor	edi, edi
	mov	DWORD PTR _transform_colors_flag, 1
	test	edx, edx
	js	SHORT $LN8@transform_
	fld	QWORD PTR __real@bff0000000000000
$LN193@transform_:

; 752  :         for ( j = 0 ; j <= SDIM ; j++ )

	xor	ecx, ecx
	test	edx, edx
	js	SHORT $LN13@transform_
	mov	edx, DWORD PTR _view_transforms
	mov	eax, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [eax+edi*4]
$LN194@transform_:

; 753  :           view_transforms[n][i][j] *= -1;

	fld	QWORD PTR [eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jle	SHORT $LN194@transform_
$LN13@transform_:

; 750  :       transform_colors_flag = 1;   
; 751  :       for ( i = 0 ; i <= SDIM ; i++ )

	inc	edi
	cmp	edi, edx
	jle	SHORT $LN193@transform_
	fstp	ST(0)

; 754  :     }
; 755  :     else transform_colors[n] = SAME_COLOR; 

	jmp	SHORT $LN8@transform_
$LN15@transform_:
	mov	ecx, DWORD PTR _transform_colors
	mov	DWORD PTR [ecx+esi*4], 0
	mov	edx, DWORD PTR _web+616
$LN8@transform_:

; 756  : 
; 757  :     matcopy(temp_mat,view_transforms[n],SDIM+1,SDIM+1);

	inc	edx
	push	edx
	push	edx
	mov	edx, DWORD PTR _view_transforms
	mov	eax, DWORD PTR [edx+esi*4]
	push	eax
	push	ebx
	call	_matcopy

; 758  :     if ( determinant(temp_mat,SDIM+1) > 0.0 )

	mov	ecx, DWORD PTR _web+616
	inc	ecx
	push	ecx
	push	ebx
	call	_determinant
	fldz
	fcom	ST(1)
	add	esp, 24					; 00000018H
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN7@transform_

; 759  :                view_transform_det[n] = 1;

	mov	edx, DWORD PTR _view_transform_det
	mov	DWORD PTR [edx+esi*4], 1
	jmp	SHORT $LN17@transform_
$LN7@transform_:

; 760  :     else  view_transform_det[n] = -1;

	mov	eax, DWORD PTR _view_transform_det
	mov	DWORD PTR [eax+esi*4], -1
$LN17@transform_:

; 747  :   for ( n = 0 ; n < transform_count ; n++ )

	inc	esi
	cmp	esi, DWORD PTR _transform_count
	jl	$LN192@transform_
	fstp	ST(0)
$LN16@transform_:

; 761  :   }
; 762  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89343[ebp], 0
	je	$LN114@transform_
	mov	ecx, DWORD PTR _graphmutex
	push	ecx
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
	pop	edi
	pop	esi
	pop	ebx

; 769  : 
; 770  : } /* end transform_gen_expr()  */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN175@transform_:

; 719  :   { sprintf(errmsg,"Illegal transform expression syntax: %s\n",expr);

	mov	edx, DWORD PTR _expr$GSCopy$[ebp]
	push	edx
	push	OFFSET ??_C@_0CJ@EIMLHGKK@Illegal?5transform?5expression?5syn@
	push	OFFSET _errmsg
	call	_sprintf

; 720  :     errnum = 2604;

	mov	ebx, 2604				; 00000a2cH

; 721  :     goto err_exit;

	jmp	SHORT $LN221@transform_
$LN61@transform_:

; 658  :            { sprintf(errmsg,
; 659  :                        "Transform expression has unmatched parentheses.\n");

	push	OFFSET ??_C@_0DB@GGOPANPP@Transform?5expression?5has?5unmatch@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 8

; 660  :              errnum = 2600;

	mov	ebx, 2600				; 00000a28H

; 661  :              goto err_exit;

	jmp	SHORT $err_exit$89301
$LN145@transform_:

; 672  :       { sprintf(errmsg,"Illegal transform expression syntax: %s\n",expr);

	mov	eax, DWORD PTR _expr$GSCopy$[ebp]
	push	eax
	push	OFFSET ??_C@_0CJ@EIMLHGKK@Illegal?5transform?5expression?5syn@
	push	OFFSET _errmsg
	call	_sprintf

; 673  :         errnum = 2601;

	mov	ebx, 2601				; 00000a29H

; 674  :         goto err_exit;

	jmp	SHORT $LN221@transform_
$LN146@transform_:

; 679  :         { sprintf(errmsg,"No generator '%c'.\n",*c);

	movsx	ecx, BYTE PTR [ebx]
	push	ecx
	push	OFFSET ??_C@_0BE@EIHIGIAL@No?5generator?5?8?$CFc?8?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 680  :           errnum = 2602;

	mov	ebx, 2602				; 00000a2aH

; 681  :           goto err_exit; /* clean up */

	jmp	SHORT $LN221@transform_
$LN32@transform_:

; 710  :       else { sprintf(errmsg,"Illegal character '%c' in transform expression.\n",
; 711  :                     *c);

	movsx	edx, BYTE PTR [ebx]
	push	edx
	push	OFFSET ??_C@_0DB@BJKPGBLC@Illegal?5character?5?8?$CFc?8?5in?5transf@
	push	OFFSET _errmsg
	call	_sprintf

; 712  :              errnum = 2603;

	mov	ebx, 2603				; 00000a2bH
$LN221@transform_:

; 710  :       else { sprintf(errmsg,"Illegal character '%c' in transform expression.\n",
; 711  :                     *c);

	add	esp, 12					; 0000000cH
$err_exit$89301:

; 763  :   return;
; 764  : 
; 765  : err_exit:
; 766  :   for ( i = 0 ; i <= stacktop ; i++ )

	test	esi, esi
	js	SHORT $LN177@transform_
	lea	edi, DWORD PTR _stack$[ebp+12]
	inc	esi
	npad	6
$LL195@transform_:

; 767  :       if ( stack[i].type ==  G_SET ) free_matrix3(stack[i].mats);

	cmp	DWORD PTR [edi-12], 2
	jne	SHORT $LN3@transform_
	mov	eax, DWORD PTR [edi]
	push	eax
	call	_free_matrix3
	add	esp, 4
$LN3@transform_:

; 763  :   return;
; 764  : 
; 765  : err_exit:
; 766  :   for ( i = 0 ; i <= stacktop ; i++ )

	add	edi, 20					; 00000014H
	dec	esi
	jne	SHORT $LL195@transform_
$LN177@transform_:

; 768  :   kb_error(errnum,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	ebx
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN114@transform_:

; 769  : 
; 770  : } /* end transform_gen_expr()  */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN222@transform_:
	DD	$LN97@transform_
	DD	$LN106@transform_
	DD	$LN85@transform_
	DD	$LN173@transform_
	DD	$LN173@transform_
	DD	$LN98@transform_
	DD	$LN99@transform_
	DD	$LN77@transform_
_transform_gen_expr ENDP
_TEXT	ENDS
END
