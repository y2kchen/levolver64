; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\MODIFY.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_unset_attr
; Function compile flags: /Ogtp
;	COMDAT _unset_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_unset_attr PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 29   :   elptr(id)->attr &= ~attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	not	ecx
	and	DWORD PTR [eax+8], ecx
	not	edx
	and	DWORD PTR [eax+12], edx

; 30   : }

	pop	ebp
	ret	0
_unset_attr ENDP
_TEXT	ENDS
PUBLIC	_set_fe_edge
EXTRN	_top_timestamp:DWORD
EXTRN	_global_timestamp:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_e_id$ = 12						; size = 4
_set_fe_edge PROC					; COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp

; 36   :   if ( inverted(fe_id) ) invert(e_id);

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN1@set_fe_edg
	xor	DWORD PTR _e_id$[ebp], 134217728	; 08000000H
$LN1@set_fe_edg:

; 37   :   feptr(fe_id)->fe_edge_id = e_id;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR [edx+20], eax

; 38   :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 39   : }

	pop	ebp
	ret	0
_set_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_edge
; Function compile flags: /Ogtp
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _get_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_facet PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp

; 84   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 85   :     return inverse_id(feptr(fe_id)->nextfacet[1]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]
	xor	eax, 134217728				; 08000000H

; 88   : }

	pop	ebp
	ret	0
$LN2@get_prev_f:

; 86   :   else 
; 87   :     return feptr(fe_id)->nextfacet[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]

; 88   : }

	pop	ebp
	ret	0
_get_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _set_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_edge PROC					; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp

; 103  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_e

; 104  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_e

; 105  :     { invert(fe);
; 106  :       feptr(fe_id)->nextedge[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+32], ecx

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 111  : }

	pop	ebp
	ret	0
$LN2@set_prev_e:

; 107  :     }
; 108  :   else
; 109  :       feptr(fe_id)->nextedge[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_e:

; 111  : }

	pop	ebp
	ret	0
_set_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_set_next_edge
; Function compile flags: /Ogtp
;	COMDAT _set_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_edge PROC					; COMDAT

; 116  : {

	push	ebp
	mov	ebp, esp

; 117  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_e

; 118  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_e

; 119  :     { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 120  :       feptr(fe_id)->nextedge[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+28], ecx

; 124  : }

	pop	ebp
	ret	0
$LN2@set_next_e:

; 121  :     }
; 122  :   else
; 123  :       feptr(fe_id)->nextedge[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN1@set_next_e:

; 124  : }

	pop	ebp
	ret	0
_set_next_edge ENDP
_TEXT	ENDS
PUBLIC	_set_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _set_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_facet PROC					; COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp

; 130  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_f

; 131  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_f

; 132  :   { invert(fe);
; 133  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+40], ecx

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 138  : }

	pop	ebp
	ret	0
$LN2@set_prev_f:

; 134  :   }
; 135  :   else
; 136  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+36], eax

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_f:

; 138  : }

	pop	ebp
	ret	0
_set_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_set_next_facet
; Function compile flags: /Ogtp
;	COMDAT _set_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_facet PROC					; COMDAT

; 143  : {

	push	ebp
	mov	ebp, esp

; 144  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_f

; 145  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_f

; 146  :   { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 147  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+36], ecx

; 151  : }

	pop	ebp
	ret	0
$LN2@set_next_f:

; 148  :   }
; 149  :   else
; 150  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+40], eax
$LN1@set_next_f:

; 151  : }

	pop	ebp
	ret	0
_set_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_edge_wrap
EXTRN	_dymem:DWORD
EXTRN	_sym_inverse:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_wrap$ = 12						; size = 4
_set_edge_wrap PROC					; COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp

; 158  :  *EINT(e_id,E_WRAP_ATTR) =  inverted(e_id)  ? (*sym_inverse)(wrap) : wrap ;

	mov	eax, DWORD PTR _wrap$[ebp]
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN4@set_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@set_edge_w:
	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+esi+784]
	mov	DWORD PTR [edx+ecx], eax
	pop	esi

; 159  : }

	pop	ebp
	ret	0
_set_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_get_edge_wrap
; Function compile flags: /Ogtp
;	COMDAT _get_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_wrap PROC					; COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  :   WRAPTYPE wrap = *EINT(e_id,E_WRAP_ATTR) ;

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+784]
	mov	eax, DWORD PTR [eax+edx]
	pop	esi

; 165  :   return    ( inverted(e_id) ? (*sym_inverse)(wrap) : wrap );

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN4@get_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@get_edge_w:

; 166  : }

	pop	ebp
	ret	0
_get_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_set_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _set_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_edge_fe PROC					; COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp

; 172  :   if ( inverted(e_id) ) invert(fe);

	mov	eax, DWORD PTR _e_id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN1@set_edge_f
	xor	DWORD PTR _fe$[ebp], 134217728		; 08000000H
$LN1@set_edge_f:

; 173  :   eptr(e_id)->fe_id = fe;

	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 174  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 175  : }

	pop	ebp
	ret	0
_set_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_set_edge_tailv
EXTRN	_insert_vertex_edge:PROC
EXTRN	_remove_vertex_edge:PROC
; Function compile flags: /Ogtp
;	COMDAT _set_edge_tailv
_TEXT	SEGMENT
tv225 = -4						; size = 4
_e_id$ = 8						; size = 4
_v_id$ = 12						; size = 4
_set_edge_tailv PROC					; COMDAT

; 210  : { vertex_id oldv;

	push	ebp
	mov	ebp, esp
	push	ecx

; 211  : 
; 212  :   /* make sure edge not in loop of old vertex */
; 213  :   oldv = get_edge_tailv(e_id);

	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR _web+216
	push	ebx
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	mov	eax, esi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	push	edi
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR tv225[ebp], eax
	je	SHORT $LN7@set_edge_t
	mov	ebx, DWORD PTR _web+636
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	add	eax, DWORD PTR [ecx+edi+304]
	mov	eax, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN6@set_edge_t
$LN7@set_edge_t:
	mov	ebx, DWORD PTR [ecx+edi+304]
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+ebx]
$LN6@set_edge_t:

; 214  :   if ( valid_id(oldv) && !equal_id(oldv,v_id) )

	mov	ebx, DWORD PTR _v_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN10@set_edge_t
	cmp	eax, ebx
	je	SHORT $LN10@set_edge_t

; 215  :     remove_vertex_edge(oldv,e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	eax
	call	_remove_vertex_edge
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	add	esp, 8
$LN10@set_edge_t:

; 216  : 
; 217  :   if ( inverted(e_id) )

	cmp	DWORD PTR tv225[ebp], 0

; 218  :      get_edge_vertices(e_id)[web.headvnum] = v_id;

	mov	edx, DWORD PTR [esi+edx]
	je	SHORT $LN2@set_edge_t
	add	edx, DWORD PTR [ecx+edi+304]
	mov	eax, DWORD PTR _web+636
	mov	DWORD PTR [edx+eax*4], ebx

; 219  :   else

	jmp	SHORT $LN1@set_edge_t
$LN2@set_edge_t:

; 220  :      get_edge_vertices(e_id)[0] = v_id;

	mov	eax, DWORD PTR [ecx+edi+304]
	mov	DWORD PTR [edx+eax], ebx
$LN1@set_edge_t:

; 221  :   insert_vertex_edge(v_id,e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	ebx
	call	_insert_vertex_edge

; 222  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	esp, 8
	pop	edi
	inc	eax
	pop	esi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	ebx

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_set_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_set_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _set_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_v_id$ = 12						; size = 4
_set_edge_headv PROC					; COMDAT

; 229  : {

	push	ebp
	mov	ebp, esp

; 230  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]
	push	esi

; 231  :      get_edge_vertices(e_id)[0] = v_id;

	mov	esi, DWORD PTR _dymem
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_edge_h
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+216
	mov	esi, DWORD PTR [ecx+esi+304]
	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	DWORD PTR [edx+esi], ecx

; 232  :   else

	jmp	SHORT $LN1@set_edge_h
$LN2@set_edge_h:

; 233  :      get_edge_vertices(e_id)[web.headvnum] = v_id;

	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	add	edx, DWORD PTR [ecx+esi+304]
	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	esi, DWORD PTR _web+636
	mov	DWORD PTR [edx+esi*4], ecx
$LN1@set_edge_h:

; 234  :   insert_vertex_edge(v_id,inverse_id(e_id));

	xor	eax, 134217728				; 08000000H
	push	eax
	push	ecx
	call	_insert_vertex_edge

; 235  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	esp, 8
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	esi

; 236  : }

	pop	ebp
	ret	0
_set_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_set_edge_midv
; Function compile flags: /Ogtp
;	COMDAT _set_edge_midv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_v_id$ = 12						; size = 4
_set_edge_midv PROC					; COMDAT

; 241  : { get_edge_vertices(e_id)[2] = v_id;

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _e_id$[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+esi+304]
	mov	eax, DWORD PTR _v_id$[ebp]
	mov	DWORD PTR [ecx+esi+8], eax

; 242  :   set_vertex_edge(v_id,e_id);

	mov	esi, DWORD PTR _web+12
	mov	ecx, eax

; 243  :   set_attr(v_id,Q_MIDPOINT);

	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	esi, DWORD PTR [ecx+esi]
	mov	DWORD PTR [esi+28], edx
	mov	edx, DWORD PTR _web[eax+12]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 131072		; 00020000H
	mov	DWORD PTR [ecx+12], eax

; 244  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	esi

; 245  : }

	pop	ebp
	ret	0
_set_edge_midv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_@2
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_@2:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_@2
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_@2:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_head_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_head_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_head_edge PROC				; COMDAT

; 273  : { return inverse_id(eptr(e_id)->next_vedge[inverted(e_id) ?0: 1]); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	not	ecx
	and	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4+32]
	xor	eax, 134217728				; 08000000H
	pop	ebp
	ret	0
_get_next_head_edge ENDP
_TEXT	ENDS
PUBLIC	_get_body_facet
; Function compile flags: /Ogtp
;	COMDAT _get_body_facet
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_facet PROC					; COMDAT

; 279  : { return ( valid_id(b_id) ? bptr(b_id)->f_id : NULLID ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+400]
	pop	ebp
	ret	0
$LN3@get_body_f:
	xor	eax, eax
	pop	ebp
	ret	0
_get_body_facet ENDP
_TEXT	ENDS
PUBLIC	_get_body_fe
; Function compile flags: /Ogtp
;	COMDAT _get_body_fe
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_fe PROC					; COMDAT

; 282  : { facet_id f_id =  valid_id(b_id) ? bptr(b_id)->f_id : NULLID ;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f@2
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [edx+400]
	jmp	SHORT $LN4@get_body_f@2
$LN3@get_body_f@2:
	xor	ecx, ecx
$LN4@get_body_f@2:

; 283  :   return valid_id(f_id) ? get_facet_fe(f_id) : NULLID;

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN5@get_body_f@2
	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN6@get_body_f@2
	xor	eax, 134217728				; 08000000H

; 284  : }

	pop	ebp
	ret	0
$LN5@get_body_f@2:

; 283  :   return valid_id(f_id) ? get_facet_fe(f_id) : NULLID;

	xor	eax, eax
$LN6@get_body_f@2:

; 284  : }

	pop	ebp
	ret	0
_get_body_fe ENDP
_TEXT	ENDS
PUBLIC	_set_body_facet
; Function compile flags: /Ogtp
;	COMDAT _set_body_facet
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_f_id$ = 12						; size = 4
_set_body_facet PROC					; COMDAT

; 302  : {  if ( valid_id(b_id) )  bptr(b_id)->f_id = (f_id); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _f_id$[ebp]
	mov	DWORD PTR [edx+400], eax
$LN1@set_body_f:
	pop	ebp
	ret	0
_set_body_facet ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_get_body_volconst
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_body_volconst
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volconst PROC					; COMDAT

; 320  :   { return    ( valid_id(b_id) ?  bptr(b_id)->volconst : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+328]
	pop	ebp
	ret	0
$LN3@get_body_v:
	fldz
	pop	ebp
	ret	0
_get_body_volconst ENDP
_TEXT	ENDS
PUBLIC	_get_extra
; Function compile flags: /Ogtp
;	COMDAT _get_extra
_TEXT	SEGMENT
_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_extra PROC						; COMDAT

; 348  : { int type = id_type(id);

	push	ebp
	mov	ebp, esp

; 349  : 
; 350  :   return ( (char*)elptr(id) + EXTRAS(type)[n].offset);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	shr	eax, 29					; 0000001dH
	imul	esi, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, esi
	add	eax, DWORD PTR [edi+ecx+64]
	pop	edi
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_get_extra ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@JOHCIHEB@Can?8t?5unstar?5at?5vertex?5?$CFs?5due?5to@ ; `string'
PUBLIC	??_C@_0CL@JIOENPHF@Unstarring?5failed?0?5triple?5valenc@ ; `string'
PUBLIC	??_C@_0CN@LBAIDHJO@Unstarring?5failed?0?5vertex?5?$CFs?5has@ ; `string'
PUBLIC	??_C@_0CI@PBJACFDO@Unstarring?5failed?0?5vertex?5?$CFs?5is?5@ ; `string'
PUBLIC	??_C@_0BG@NFDNLGJK@Unstarring?5vertex?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	_unstar
EXTRN	_free_element:PROC
EXTRN	_set_facet_fe:PROC
EXTRN	_set_fe_facet:PROC
EXTRN	_compare_edge_facet_attr:PROC
EXTRN	_get_vertex_evalence:PROC
EXTRN	_outstring:PROC
EXTRN	_msg:DWORD
EXTRN	_sprintf:PROC
EXTRN	_elnames:BYTE
EXTRN	_verbose_flag:DWORD
;	COMDAT ??_C@_0CP@JOHCIHEB@Can?8t?5unstar?5at?5vertex?5?$CFs?5due?5to@
CONST	SEGMENT
??_C@_0CP@JOHCIHEB@Can?8t?5unstar?5at?5vertex?5?$CFs?5due?5to@ DB 'Can''t'
	DB	' unstar at vertex %s due to constraints.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JIOENPHF@Unstarring?5failed?0?5triple?5valenc@
CONST	SEGMENT
??_C@_0CL@JIOENPHF@Unstarring?5failed?0?5triple?5valenc@ DB 'Unstarring f'
	DB	'ailed, triple valence edge %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LBAIDHJO@Unstarring?5failed?0?5vertex?5?$CFs?5has@
CONST	SEGMENT
??_C@_0CN@LBAIDHJO@Unstarring?5failed?0?5vertex?5?$CFs?5has@ DB 'Unstarri'
	DB	'ng failed, vertex %s has valence %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PBJACFDO@Unstarring?5failed?0?5vertex?5?$CFs?5is?5@
CONST	SEGMENT
??_C@_0CI@PBJACFDO@Unstarring?5failed?0?5vertex?5?$CFs?5is?5@ DB 'Unstarr'
	DB	'ing failed, vertex %s is fixed.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NFDNLGJK@Unstarring?5vertex?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BG@NFDNLGJK@Unstarring?5vertex?5?$CFs?6?$AA@ DB 'Unstarring vertex'
	DB	' %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _unstar
_TEXT	SEGMENT
tv909 = -44						; size = 4
_ccomp$ = -44						; size = 4
_fe_d$ = -40						; size = 4
tv897 = -36						; size = 4
_acomp$ = -36						; size = 4
_fe_g$ = -32						; size = 4
_fkeep$ = -28						; size = 4
tv979 = -24						; size = 4
_fe_i$ = -20						; size = 4
_fe_c$ = -16						; size = 4
_fe_b$ = -12						; size = 4
_fe_f$ = -8						; size = 4
_v_id$ = -4						; size = 4
_fe_a$ = 8						; size = 4
_unstar	PROC						; COMDAT

; 221  : { vertex_id v_id = get_fe_tailv(fe_a);

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR _web+124
	sub	esp, 44					; 0000002cH
	push	ebx
	mov	ebx, DWORD PTR _dymem
	push	esi
	mov	esi, DWORD PTR _fe_a$[ebp]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	push	edi
	mov	edi, DWORD PTR [ecx+eax*4]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN42@unstar
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	add	eax, DWORD PTR [edx+ebx+304]
	mov	edx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN87@unstar
$LN42@unstar:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ebx+304]
	mov	eax, DWORD PTR [eax+edx]
$LN87@unstar:
	mov	DWORD PTR _v_id$[ebp], eax

; 222  :   facet_id fkeep = get_fe_facet(fe_a);

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN46@unstar
	mov	edx, DWORD PTR _NULLFACET
	mov	DWORD PTR _fkeep$[ebp], edx
	jmp	SHORT $LN47@unstar
$LN46@unstar:
	mov	eax, DWORD PTR [edi+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN45@unstar
	xor	eax, 134217728				; 08000000H
$LN45@unstar:
	mov	DWORD PTR _fkeep$[ebp], eax
$LN47@unstar:

; 223  :   facetedge_id fe_b = get_next_edge(fe_a);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN50@unstar
	mov	eax, DWORD PTR [edi+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN88@unstar
$LN50@unstar:
	mov	eax, DWORD PTR [edi+32]
$LN88@unstar:
	mov	DWORD PTR _fe_b$[ebp], eax

; 224  :   facetedge_id fe_c = get_next_edge(fe_b);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN54@unstar
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN89@unstar
$LN54@unstar:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
$LN89@unstar:
	mov	DWORD PTR _fe_c$[ebp], eax

; 225  :   facetedge_id fe_d = get_next_facet(fe_c);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN58@unstar
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv897[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN90@unstar
$LN58@unstar:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv897[ebp], eax
	mov	eax, DWORD PTR [edx+40]
$LN90@unstar:

; 226  :   facetedge_id fe_e = get_next_edge(fe_d);

	mov	esi, eax
	shr	esi, 27					; 0000001bH
	and	esi, 1
	mov	DWORD PTR _fe_d$[ebp], eax
	mov	DWORD PTR tv909[ebp], esi
	mov	edi, eax
	je	SHORT $LN62@unstar
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ecx]
	mov	ebx, DWORD PTR [eax+28]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN61@unstar
$LN62@unstar:
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+ecx]
	mov	ebx, DWORD PTR [edx+32]
$LN61@unstar:

; 227  :   facetedge_id fe_f = get_next_edge(fe_e);

	mov	edx, ebx
	mov	eax, ebx
	shr	edx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	and	edx, 1
	mov	eax, DWORD PTR [ecx+eax*4]
	je	SHORT $LN66@unstar
	mov	esi, DWORD PTR [eax+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN91@unstar
$LN66@unstar:
	mov	esi, DWORD PTR [eax+32]
$LN91@unstar:
	mov	DWORD PTR _fe_f$[ebp], esi

; 228  :   facetedge_id fe_g = get_next_facet(fe_e);

	test	edx, edx
	je	SHORT $LN70@unstar
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN92@unstar
$LN70@unstar:
	mov	eax, DWORD PTR [eax+40]
$LN92@unstar:
	mov	DWORD PTR _fe_g$[ebp], eax

; 229  :   facetedge_id fe_h = get_next_edge(fe_g);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN74@unstar
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	esi, DWORD PTR [edx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN73@unstar
$LN74@unstar:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	esi, DWORD PTR [eax+32]
$LN73@unstar:

; 230  :   facetedge_id fe_i = get_next_edge(fe_h);

	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edx*4]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN78@unstar
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _fe_i$[ebp], eax
	jmp	SHORT $LN77@unstar
$LN78@unstar:
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _fe_i$[ebp], ecx
$LN77@unstar:

; 231  :   facet_id f_id;
; 232  :   body_id b_id;
; 233  :   int acomp,ccomp,ecomp;
; 234  : 
; 235  :   if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN20@unstar

; 236  :   { sprintf(msg,"Unstarring vertex %s\n",ELNAME(v_id));

	test	DWORD PTR _v_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN23@unstar
	mov	edx, DWORD PTR _v_id$[ebp]
	and	edx, 134217727				; 07ffffffH
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN24@unstar
$LN23@unstar:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN24@unstar:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BG@NFDNLGJK@Unstarring?5vertex?5?$CFs?6?$AA@
	push	eax
	call	_sprintf

; 237  :     outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
$LN20@unstar:

; 238  :   }
; 239  : 
; 240  :   /* some checks on legality */
; 241  :   if ( get_vattr(v_id) & FIXED )  /* fixed vertex */

	mov	edx, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR _web+12
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv979[ebp], eax
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN19@unstar

; 242  :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, ecx
	je	SHORT $LN18@unstar

; 243  :     { sprintf(msg,"Unstarring failed, vertex %s is fixed.\n",
; 244  :                 ELNAME(v_id));

	test	edx, 268435456				; 10000000H
	je	SHORT $LN25@unstar
	mov	edx, DWORD PTR tv979[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN26@unstar
$LN25@unstar:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN26@unstar:
	push	eax
	push	OFFSET ??_C@_0CI@PBJACFDO@Unstarring?5failed?0?5vertex?5?$CFs?5is?5@
$LN93@unstar:
	mov	eax, DWORD PTR _msg
	push	eax
	call	_sprintf

; 245  :       outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
$LN18@unstar:

; 246  :     }
; 247  :     return -1;

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx

; 338  : } /* end unstar() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@unstar:

; 248  :   }
; 249  :   if ( get_vertex_evalence(v_id) != 3 )  /* not lonesome star */

	mov	edx, DWORD PTR _v_id$[ebp]
	push	edx
	call	_get_vertex_evalence
	add	esp, 4
	cmp	eax, 3
	je	SHORT $LN17@unstar

; 250  :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN16@unstar

; 251  :     { sprintf(msg,"Unstarring failed, vertex %s has valence %d\n",
; 252  :                 ELNAME(v_id),get_vertex_evalence(v_id));

	mov	edi, DWORD PTR _v_id$[ebp]
	test	edi, 268435456				; 10000000H
	je	SHORT $LN27@unstar
	mov	eax, DWORD PTR tv979[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames
	jmp	SHORT $LN28@unstar
$LN27@unstar:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN28@unstar:
	push	edi
	call	_get_vertex_evalence
	mov	ecx, DWORD PTR _msg
	push	eax
	push	esi
	push	OFFSET ??_C@_0CN@LBAIDHJO@Unstarring?5failed?0?5vertex?5?$CFs?5has@
	push	ecx
	call	_sprintf

; 253  :       outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 24					; 00000018H
$LN16@unstar:

; 254  :     }
; 255  :     return -1;

	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx

; 338  : } /* end unstar() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@unstar:

; 256  :   }
; 257  :   if ( !equal_id(fe_c,get_next_facet(fe_d)) ) 

	cmp	DWORD PTR tv909[ebp], 0
	mov	ecx, DWORD PTR _web+460
	je	SHORT $LN82@unstar
	mov	eax, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN81@unstar
$LN82@unstar:
	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edx+40]
$LN81@unstar:
	cmp	DWORD PTR _fe_c$[ebp], eax
	je	SHORT $LN15@unstar

; 258  :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN18@unstar

; 259  :     { sprintf(msg,"Unstarring failed, triple valence edge %s\n",
; 260  :                 ELNAME(get_fe_edge(fe_c)));

	mov	eax, DWORD PTR tv897[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	test	DWORD PTR [ecx+20], 268435456		; 10000000H
	je	SHORT $LN29@unstar
	mov	edx, DWORD PTR _fe_c$[ebp]
	push	edx
$LN95@unstar:
	call	_get_fe_edge
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 16					; 00000010H
	mov	eax, OFFSET _elnames
	push	eax
	push	OFFSET ??_C@_0CL@JIOENPHF@Unstarring?5failed?0?5triple?5valenc@

; 261  :       outstring(msg);
; 262  :     }
; 263  :     return -1;

	jmp	$LN93@unstar
$LN29@unstar:

; 259  :     { sprintf(msg,"Unstarring failed, triple valence edge %s\n",
; 260  :                 ELNAME(get_fe_edge(fe_c)));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0CL@JIOENPHF@Unstarring?5failed?0?5triple?5valenc@

; 261  :       outstring(msg);
; 262  :     }
; 263  :     return -1;

	jmp	$LN93@unstar
$LN15@unstar:

; 264  :   }
; 265  :   if ( !equal_id(fe_e,get_next_facet(fe_g))  )

	mov	edx, DWORD PTR _fe_g$[ebp]
	push	edx
	call	_get_next_facet
	add	esp, 4
	cmp	ebx, eax
	je	SHORT $LN13@unstar

; 266  :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN18@unstar

; 267  :     { sprintf(msg,"Unstarring failed, triple valence edge %s\n",
; 268  :              ELNAME(get_fe_edge(fe_e)));

	push	ebx
	call	_get_fe_edge
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN29@unstar
	push	ebx
	jmp	SHORT $LN95@unstar
$LN13@unstar:

; 269  :       outstring(msg);
; 270  :     }
; 271  :     return -1;
; 272  :   }
; 273  :   if ( !equal_id(inverse_id(fe_a),get_next_facet(fe_i)) ) 

	mov	edx, DWORD PTR _fe_i$[ebp]
	mov	edi, DWORD PTR _fe_a$[ebp]
	push	edx
	xor	edi, 134217728				; 08000000H
	call	_get_next_facet
	add	esp, 4
	cmp	edi, eax
	je	SHORT $LN11@unstar
$LN96@unstar:

; 274  :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN18@unstar

; 275  :     { sprintf(msg,"Unstarring failed, triple valence edge %s\n",
; 276  :               ELNAME(get_fe_edge(fe_a)));

	mov	esi, DWORD PTR _fe_a$[ebp]
	push	esi
	call	_get_fe_edge
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN29@unstar
	push	esi
	jmp	$LN95@unstar
$LN11@unstar:

; 277  :       outstring(msg);
; 278  :     }
; 279  :     return -1;
; 280  :   }
; 281  :   if ( !equal_id(inverse_id(fe_a),get_prev_facet(fe_i)) )

	mov	edx, DWORD PTR _fe_i$[ebp]
	push	edx
	call	_get_prev_facet
	add	esp, 4
	cmp	edi, eax

; 282  :   { if ( verbose_flag )
; 283  :     { sprintf(msg,"Unstarring failed, triple valence edge %s\n",
; 284  :             ELNAME(get_fe_edge(fe_a)));

	jne	SHORT $LN96@unstar

; 285  :       outstring(msg);
; 286  :     }
; 287  :     return -1;
; 288  :   }
; 289  : 
; 290  :   // Check compatibility of constraints
; 291  :   acomp = compare_edge_facet_attr(get_fe_edge(fe_a),fkeep);

	mov	edi, DWORD PTR _fkeep$[ebp]
	mov	edx, DWORD PTR _fe_a$[ebp]
	push	edi
	push	edx
	call	_get_fe_edge
	add	esp, 4
	push	eax
	call	_compare_edge_facet_attr
	add	esp, 8
	mov	DWORD PTR _acomp$[ebp], eax

; 292  :   ccomp = compare_edge_facet_attr(get_fe_edge(fe_c),fkeep);

	mov	eax, DWORD PTR _fe_c$[ebp]
	push	edi
	push	eax
	call	_get_fe_edge
	add	esp, 4
	push	eax
	call	_compare_edge_facet_attr
	add	esp, 8

; 293  :   ecomp = compare_edge_facet_attr(get_fe_edge(fe_e),fkeep);

	push	edi
	push	ebx
	mov	DWORD PTR _ccomp$[ebp], eax
	call	_get_fe_edge
	add	esp, 4
	push	eax
	call	_compare_edge_facet_attr
	add	esp, 8

; 294  :   if ( !(acomp==A_SUB_B || acomp==A_EQ_B) || !(ccomp==A_SUB_B || ccomp==A_EQ_B) 
; 295  :        || !(ecomp==A_SUB_B || ecomp==A_EQ_B) )

	cmp	DWORD PTR _acomp$[ebp], 1
	je	SHORT $LN5@unstar
	cmp	DWORD PTR _acomp$[ebp], 2
	jne	SHORT $LN6@unstar
$LN5@unstar:
	mov	ecx, DWORD PTR _ccomp$[ebp]
	cmp	ecx, 1
	je	SHORT $LN4@unstar
	cmp	ecx, 2
	jne	SHORT $LN6@unstar
$LN4@unstar:
	cmp	eax, 1
	je	SHORT $LN7@unstar
	cmp	eax, 2
	je	SHORT $LN7@unstar
$LN6@unstar:

; 296  :           { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN18@unstar

; 297  :             { sprintf(msg,
; 298  :              "Can't unstar at vertex %s due to constraints.\n",ELNAME(v_id));

	test	DWORD PTR _v_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN37@unstar
	mov	ecx, DWORD PTR tv979[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN38@unstar
$LN37@unstar:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN38@unstar:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0CP@JOHCIHEB@Can?8t?5unstar?5at?5vertex?5?$CFs?5due?5to@
	push	edx
	call	_sprintf

; 299  :                outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx

; 338  : } /* end unstar() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@unstar:

; 300  :             }
; 301  :             return -1; 
; 302  :           }
; 303  : 
; 304  :   /* fix up body links */
; 305  :   f_id = get_fe_facet(fe_e);

	push	ebx
	call	_get_fe_facet
	mov	edi, eax

; 306  :   b_id = get_facet_body(f_id);

	push	edi
	call	_get_facet_body
	add	esp, 8

; 307  :   if ( valid_id(b_id) ) set_body_facet(b_id,f_id);

	test	eax, 268435456				; 10000000H
	je	SHORT $LN2@unstar
	push	edi
	push	eax
	call	_set_body_facet
	add	esp, 8
$LN2@unstar:

; 308  :   b_id = get_facet_body(inverse_id(f_id));

	xor	edi, 134217728				; 08000000H
	push	edi
	call	_get_facet_body
	add	esp, 4

; 309  :   if ( valid_id(b_id) ) set_body_facet(b_id,inverse_id(f_id));

	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@unstar
	push	edi
	push	eax
	call	_set_body_facet
	add	esp, 8
$LN1@unstar:

; 310  : 
; 311  :   /* fix up fe's around edges of new big facet */
; 312  :   set_fe_facet(fe_f,inverse_id(fkeep));

	mov	edi, DWORD PTR _fkeep$[ebp]
	mov	edx, DWORD PTR _fe_f$[ebp]
	mov	ecx, edi
	xor	ecx, 134217728				; 08000000H
	push	ecx
	push	edx
	call	_set_fe_facet

; 313  :   set_fe_facet(fe_h,fkeep);

	push	edi
	push	esi
	call	_set_fe_facet

; 314  :   set_facet_fe(fkeep,fe_b);

	mov	eax, DWORD PTR _fe_b$[ebp]
	push	eax
	push	edi
	call	_set_facet_fe

; 315  :   set_next_edge(fe_b,inverse_id(fe_f));

	mov	edi, DWORD PTR _fe_f$[ebp]
	mov	ecx, DWORD PTR _fe_b$[ebp]
	xor	edi, 134217728				; 08000000H
	push	edi
	push	ecx
	call	_set_next_edge

; 316  :   set_next_edge(fe_f,inverse_id(fe_b));

	mov	edx, DWORD PTR _fe_b$[ebp]
	mov	eax, DWORD PTR _fe_f$[ebp]
	xor	edx, 134217728				; 08000000H
	push	edx
	push	eax
	call	_set_next_edge

; 317  :   set_prev_edge(fe_f,inverse_id(fe_h));

	mov	edx, DWORD PTR _fe_f$[ebp]
	mov	ecx, esi
	xor	ecx, 134217728				; 08000000H
	push	ecx
	push	edx
	call	_set_prev_edge

; 318  :   set_prev_edge(fe_h,inverse_id(fe_f));

	push	edi
	push	esi
	call	_set_prev_edge

; 319  :   set_next_edge(fe_h,fe_b);

	mov	edi, DWORD PTR _fe_b$[ebp]
	push	edi
	push	esi
	call	_set_next_edge
	add	esp, 64					; 00000040H

; 320  :   set_prev_edge(fe_b,fe_h);

	push	esi
	push	edi
	call	_set_prev_edge

; 321  : 
; 322  :   /* discard */
; 323  :   free_element(get_fe_facet(fe_e));

	push	ebx
	call	_get_fe_facet
	push	eax
	call	_free_element

; 324  :   free_element(get_fe_facet(fe_i));

	mov	esi, DWORD PTR _fe_i$[ebp]
	push	esi
	call	_get_fe_facet
	push	eax
	call	_free_element

; 325  :   free_element(get_fe_edge(fe_a));

	mov	eax, DWORD PTR _fe_a$[ebp]
	push	eax
	call	_get_fe_edge
	push	eax
	call	_free_element

; 326  :   free_element(get_fe_edge(fe_d));

	mov	edi, DWORD PTR _fe_d$[ebp]
	push	edi
	call	_get_fe_edge
	push	eax
	call	_free_element

; 327  :   free_element(get_fe_edge(fe_e));

	push	ebx
	call	_get_fe_edge
	push	eax
	call	_free_element

; 328  :   free_element(fe_a);

	mov	ecx, DWORD PTR _fe_a$[ebp]
	push	ecx
	call	_free_element

; 329  :   free_element(fe_c);

	mov	edx, DWORD PTR _fe_c$[ebp]
	push	edx
	call	_free_element

; 330  :   free_element(fe_d);

	push	edi
	call	_free_element

; 331  :   free_element(fe_e);

	push	ebx
	call	_free_element

; 332  :   free_element(fe_g);

	mov	eax, DWORD PTR _fe_g$[ebp]
	add	esp, 64					; 00000040H
	push	eax
	call	_free_element

; 333  :   free_element(fe_i);

	push	esi
	call	_free_element

; 334  :   free_element(v_id);

	mov	ecx, DWORD PTR _v_id$[ebp]
	push	ecx
	call	_free_element

; 335  : 
; 336  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	esp, 12					; 0000000cH
	inc	eax
	pop	edi
	pop	esi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 337  :   return 1;

	mov	eax, 1
	pop	ebx

; 338  : } /* end unstar() */

	mov	esp, ebp
	pop	ebp
	ret	0
_unstar	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EH@DAGLDMDM@Edge?5?$CFs?5not?5deleted?5due?5to?5adjac@ ; `string'
PUBLIC	_simple_unstar
EXTRN	_kb_error:PROC
EXTRN	_errmsg:BYTE
;	COMDAT ??_C@_0EH@DAGLDMDM@Edge?5?$CFs?5not?5deleted?5due?5to?5adjac@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EH@DAGLDMDM@Edge?5?$CFs?5not?5deleted?5due?5to?5adjac@ DB 'Edge %s'
	DB	' not deleted due to adjacent configuration involving facet %s'
	DB	'.', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _simple_unstar
_TEXT	SEGMENT
tv502 = -8						; size = 4
_facet$ = -4						; size = 4
_base_fe$ = 8						; size = 4
_simple_unstar PROC					; COMDAT

; 351  : {

	push	ebp
	mov	ebp, esp

; 352  :       facetedge_id aa,bb;   
; 353  :       facetedge_id a=0;  /* for edge to be merged */
; 354  :       facetedge_id b=0;  /* for edge to be merged with */
; 355  :       facetedge_id a_next=0,b_next=0;
; 356  :                  /* facet chain links around edges a,b */
; 357  :       edge_id  a_edge=0; /* edge of side a */
; 358  :       edge_id  b_edge=0; /* edge of side b */
; 359  :       facet_id  facet;  /* facet to be eliminated */ 
; 360  :       int retval = 1;
; 361  : 
; 362  :       /* check we really have a facet */
; 363  :       facet = get_fe_facet(base_fe);

	mov	eax, DWORD PTR _base_fe$[ebp]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR _web+460
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN15@simple_uns
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN14@simple_uns
$LN15@simple_uns:
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+edx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN14@simple_uns
	xor	ecx, 134217728				; 08000000H
$LN14@simple_uns:
	mov	DWORD PTR _facet$[ebp], ecx

; 364  :       if ( !valid_id(facet) ) return 1;

	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN57@simple_uns
	mov	eax, 1
	pop	ebx

; 398  :      
; 399  : } /* end simple_unstar() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@simple_uns:
	push	esi
	push	edi
$LL6@simple_uns:

; 365  : 
; 366  :       /* label relevant edges and */
; 367  :       /* see if we have an adjacent starred triangle which will give
; 368  :           trouble if we don't unstar it */
; 369  :       for(;;)  /* may take multiple passes for total unstarring */
; 370  :       { 
; 371  :         int unstar_count = 0;
; 372  : 
; 373  :           a = get_next_edge(base_fe);

	push	eax
	call	_get_next_edge

; 374  :           a_edge = get_fe_edge(a);
; 375  :           if ( get_vattr(get_edge_headv(a_edge)) & AXIAL_POINT ) return 1;

	mov	edi, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR _web+124
	mov	esi, eax
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR tv502[ebp], ecx
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	add	esp, 4
	test	esi, 134217728				; 08000000H
	je	SHORT $LN21@simple_uns
	mov	edx, DWORD PTR [edx+edi+304]
	mov	ecx, DWORD PTR [ecx+edx]
	jmp	SHORT $LN20@simple_uns
$LN21@simple_uns:
	add	ecx, DWORD PTR [edx+edi+304]
	mov	edx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [ecx+edx*4]
$LN20@simple_uns:
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 8388608				; 00800000H
	xor	edx, edx
	or	ecx, edx
	jne	$LN54@simple_uns

; 376  :           a_next = get_next_facet(a);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN25@simple_uns
	mov	eax, DWORD PTR tv502[ebp]
	mov	edi, DWORD PTR [eax+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN24@simple_uns
$LN25@simple_uns:
	mov	ecx, DWORD PTR tv502[ebp]
	mov	edi, DWORD PTR [ecx+40]
$LN24@simple_uns:

; 377  :           b = get_prev_edge(base_fe);

	mov	edx, DWORD PTR _base_fe$[ebp]
	push	edx
	call	_get_prev_edge

; 378  :           b_edge = get_fe_edge(b);

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+ecx*4]
	mov	ecx, eax
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [edx+20]
	add	esp, 4

; 379  :           b_next = get_next_facet(b);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN31@simple_uns
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN30@simple_uns
$LN31@simple_uns:
	mov	eax, DWORD PTR [edx+40]
$LN30@simple_uns:

; 380  :           if ( equal_element(a_edge,b_edge) ) return 1;

	or	ecx, 134217728				; 08000000H
	or	esi, 134217728				; 08000000H
	cmp	esi, ecx
	je	$LN54@simple_uns

; 381  :           aa = get_next_edge(a_next);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN35@simple_uns
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edi*4]
	mov	ecx, DWORD PTR [edx+28]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN34@simple_uns
$LN35@simple_uns:
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+edi*4]
	mov	ecx, DWORD PTR [ecx+32]
$LN34@simple_uns:

; 382  :           bb = get_prev_edge(b_next);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN39@simple_uns
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN38@simple_uns
$LN39@simple_uns:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+28]
$LN38@simple_uns:

; 383  : 
; 384  :           if ( !equal_id(get_next_facet(aa),inverse_id(bb)) )

	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN43@simple_uns
	mov	edx, DWORD PTR [edx+36]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN42@simple_uns
$LN43@simple_uns:
	mov	edx, DWORD PTR [edx+40]
$LN42@simple_uns:
	xor	eax, 134217728				; 08000000H
	cmp	edx, eax
	jne	SHORT $LN54@simple_uns

; 386  :          
; 387  :           retval  = unstar(aa); 

	push	ecx
	call	_unstar
	add	esp, 4

; 388  :           if ( retval < 0 )

	test	eax, eax
	js	SHORT $LN55@simple_uns

; 394  :           }
; 395  :             unstar_count++;
; 396  :   
; 397  :         } /* end for loop */

	mov	ebx, DWORD PTR _web+460
	mov	eax, DWORD PTR _base_fe$[ebp]
	jmp	$LL6@simple_uns
$LN54@simple_uns:
	pop	edi
	pop	esi

; 385  :             return 1; /* no star */

	mov	eax, 1
	pop	ebx

; 398  :      
; 399  : } /* end simple_unstar() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@simple_uns:

; 389  :           { sprintf(errmsg,
; 390  :             "Edge %s not deleted due to adjacent configuration involving facet %s.\n",
; 391  :                                  ELNAME(get_fe_edge(base_fe)),ELNAME1(facet));

	mov	eax, DWORD PTR _facet$[ebp]
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	mov	eax, DWORD PTR _base_fe$[ebp]
	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+20]
	add	esp, 12					; 0000000cH
	test	eax, 268435456				; 10000000H
	je	SHORT $LN12@simple_uns
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN13@simple_uns
$LN12@simple_uns:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN13@simple_uns:
	push	OFFSET _elnames+30
	push	eax
	push	OFFSET ??_C@_0EH@DAGLDMDM@Edge?5?$CFs?5not?5deleted?5due?5to?5adjac@
	push	OFFSET _errmsg
	call	_sprintf

; 392  :               kb_error(1903,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1903					; 0000076fH
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi

; 393  :               return -1;

	or	eax, -1
	pop	ebx

; 398  :      
; 399  : } /* end simple_unstar() */

	mov	esp, ebp
	pop	ebp
	ret	0
_simple_unstar ENDP
_TEXT	ENDS
PUBLIC	_finagle_comp
; Function compile flags: /Ogtp
;	COMDAT _finagle_comp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_finagle_comp PROC					; COMDAT

; 418  : { if ( a->v_id < b->v_id ) return -1;

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	esi
	mov	esi, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	eax, ecx
	jae	SHORT $LN7@finagle_co
$LN9@finagle_co:
	or	eax, -1
	pop	esi

; 422  :   return 0;
; 423  : }

	pop	ebp
	ret	0
$LN7@finagle_co:

; 419  :   if ( a->v_id > b->v_id ) return  1;

	jbe	SHORT $LN3@finagle_co
	mov	eax, 1
	pop	esi

; 422  :   return 0;
; 423  : }

	pop	ebp
	ret	0
$LN3@finagle_co:

; 420  :   if ( a->e_id < b->e_id ) return -1;

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, eax
	ja	SHORT $LN9@finagle_co

; 421  :   if ( a->e_id > b->e_id ) return  1;

	sbb	eax, eax
	neg	eax
	pop	esi

; 422  :   return 0;
; 423  : }

	pop	ebp
	ret	0
_finagle_comp ENDP
_TEXT	ENDS
PUBLIC	__real@3fe999999999999a
PUBLIC	??_C@_0EM@PDLKAJMH@Internal?5error?3?5star_finagle?$CI?$CJ?5e@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_star_finagle
EXTRN	_edge_refine:PROC
EXTRN	_dot:PROC
EXTRN	_get_edge_side:PROC
EXTRN	_sym_compose:DWORD
EXTRN	_qsort:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@3fe999999999999a
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3fe999999999999a DQ 03fe999999999999ar	; 0.8
CONST	ENDS
;	COMDAT ??_C@_0EM@PDLKAJMH@Internal?5error?3?5star_finagle?$CI?$CJ?5e@
CONST	SEGMENT
??_C@_0EM@PDLKAJMH@Internal?5error?3?5star_finagle?$CI?$CJ?5e@ DB 'Intern'
	DB	'al error: star_finagle() edge %s: head_valence %d != tail_val'
	DB	'ence %d', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _star_finagle
_TEXT	SEGMENT
_aa$ = -1832						; size = 8
tv1165 = -1824						; size = 8
_ab$ = -1816						; size = 8
tv1355 = -1808						; size = 8
_bc$ = -1808						; size = 8
_bb$ = -1800						; size = 8
_flatflag$89424 = -1792					; size = 4
tv1357 = -1788						; size = 8
_ac$ = -1788						; size = 8
tv1397 = -1784						; size = 4
_start_fe$ = -1780					; size = 4
tv1532 = -1776						; size = 4
tv1057 = -1776						; size = 4
tv1536 = -1772						; size = 4
tv1016 = -1772						; size = 4
_w1$89399 = -1768					; size = 4
_i$ = -1768						; size = 4
tv1534 = -1764						; size = 4
tv1484 = -1764						; size = 4
_w2$89400 = -1764					; size = 4
tv1530 = -1760						; size = 4
tv1486 = -1760						; size = 4
_keeps$ = -1760						; size = 4
_head_valence$ = -1756					; size = 4
_tail_valence$ = -1752					; size = 4
_tail_edges$ = -1748					; size = 800
_head_edges$ = -948					; size = 800
_side1$ = -148						; size = 48
_side2$ = -100						; size = 48
_side3$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_star_finagle PROC					; COMDAT

; 426  : { struct finagle tail_edges[100];  /* tails into e_id tail */

	push	ebp
	mov	ebp, esp
	sub	esp, 1832				; 00000728H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 428  :   struct finagle head_edges[100];  /* heads into e_id head */
; 429  :   int head_valence = 0;
; 430  :   int i,j;
; 431  :   edge_id ee_id;
; 432  :   int keeps;
; 433  :   facetedge_id start_fe,fe_id;
; 434  :   REAL side1[MAXCOORD],side2[MAXCOORD],side3[MAXCOORD];
; 435  :   REAL aa,bb,cc,ab,ac,bc;
; 436  : 
; 437  :   /* get edge lists from the two vertices */
; 438  :   ee_id = e_id;

	mov	eax, DWORD PTR _e_id$[ebp]
	mov	ecx, DWORD PTR _web+124
	push	ebx
	push	esi
	mov	esi, DWORD PTR _web+216
	xor	ebx, ebx
	push	edi
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR _head_valence$[ebp], ebx
$LN159@star_finag:

; 427  :   int tail_valence = 0;

	mov	DWORD PTR _tail_valence$[ebp], ebx
	npad	7
$LL50@star_finag:

; 439  :   do
; 440  :   { ee_id = get_next_tail_edge(ee_id); 

	mov	edx, eax
	shr	edx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	and	edx, 1
	mov	eax, DWORD PTR [eax+edx*4+32]

; 441  :     if ( !equal_id(e_id,ee_id) && tail_valence < 99 )

	mov	edx, DWORD PTR _e_id$[ebp]
	cmp	edx, eax
	je	SHORT $LN143@star_finag
	cmp	ebx, 99					; 00000063H
	jge	SHORT $LL50@star_finag

; 442  :     { tail_edges[tail_valence].e_id = ee_id;
; 443  :       tail_edges[tail_valence++].v_id = get_edge_headv(ee_id);

	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	DWORD PTR _tail_edges$[ebp+ebx*8], eax
	mov	edx, DWORD PTR [ecx+edx*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN58@star_finag
	mov	ebx, DWORD PTR [esi+edi+304]
	mov	edx, DWORD PTR [edx+ebx]
	mov	ebx, DWORD PTR _tail_valence$[ebp]
	mov	DWORD PTR _tail_edges$[ebp+ebx*8+4], edx
	inc	ebx

; 444  :     }
; 445  :   } while ( !equal_id(e_id,ee_id) );

	jmp	SHORT $LN159@star_finag

; 442  :     { tail_edges[tail_valence].e_id = ee_id;
; 443  :       tail_edges[tail_valence++].v_id = get_edge_headv(ee_id);

$LN58@star_finag:
	add	edx, DWORD PTR [esi+edi+304]
	mov	ebx, DWORD PTR _web+636
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	ebx, DWORD PTR _tail_valence$[ebp]
	mov	DWORD PTR _tail_edges$[ebp+ebx*8+4], edx
	inc	ebx

; 444  :     }
; 445  :   } while ( !equal_id(e_id,ee_id) );

	jmp	SHORT $LN159@star_finag
$LN143@star_finag:

; 446  : 
; 447  :   ee_id = e_id;

	mov	eax, edx
$LL46@star_finag:

; 448  :   do
; 449  :   { ee_id = get_next_head_edge(ee_id); 

	mov	edx, eax
	shr	edx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	not	edx
	and	edx, 1
	mov	eax, DWORD PTR [eax+edx*4+32]
	xor	eax, 134217728				; 08000000H

; 450  :     if ( !equal_id(e_id,ee_id) && head_valence < 99 )

	cmp	DWORD PTR _e_id$[ebp], eax
	je	SHORT $LN142@star_finag
	mov	edx, DWORD PTR _head_valence$[ebp]
	cmp	edx, 99					; 00000063H
	jge	SHORT $LL46@star_finag

; 451  :     { head_edges[head_valence].e_id = ee_id;

	mov	DWORD PTR _head_edges$[ebp+edx*8], eax

; 452  :       head_edges[head_valence++].v_id = get_edge_tailv(ee_id);

	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN64@star_finag
	add	edx, DWORD PTR [esi+edi+304]
	mov	ebx, DWORD PTR _web+636
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	ebx, DWORD PTR _head_valence$[ebp]
	mov	DWORD PTR _head_edges$[ebp+ebx*8+4], edx
	inc	ebx
	mov	DWORD PTR _head_valence$[ebp], ebx

; 453  :     }
; 454  :   } while ( !equal_id(e_id,ee_id) );

	mov	ebx, DWORD PTR _tail_valence$[ebp]
	jmp	SHORT $LL46@star_finag

; 452  :       head_edges[head_valence++].v_id = get_edge_tailv(ee_id);

$LN64@star_finag:
	mov	ebx, DWORD PTR [esi+edi+304]
	mov	edx, DWORD PTR [edx+ebx]
	mov	ebx, DWORD PTR _head_valence$[ebp]
	mov	DWORD PTR _head_edges$[ebp+ebx*8+4], edx
	inc	ebx
	mov	DWORD PTR _head_valence$[ebp], ebx

; 453  :     }
; 454  :   } while ( !equal_id(e_id,ee_id) );

	mov	ebx, DWORD PTR _tail_valence$[ebp]
	jmp	$LL46@star_finag
$LN142@star_finag:

; 455  : 
; 456  :   /* sort by other endpoint */
; 457  :   qsort(tail_edges,tail_valence,sizeof(struct finagle),FCAST finagle_comp);

	push	OFFSET _finagle_comp
	push	8
	lea	eax, DWORD PTR _tail_edges$[ebp]
	push	ebx
	push	eax
	call	_qsort

; 458  :   qsort(head_edges,head_valence,sizeof(struct finagle),FCAST finagle_comp);

	mov	ecx, DWORD PTR _head_valence$[ebp]
	push	OFFSET _finagle_comp
	push	8
	push	ecx
	lea	edx, DWORD PTR _head_edges$[ebp]
	push	edx
	call	_qsort

; 459  : 
; 460  :   /* keep only pairs of edges with same endpoints */
; 461  :   for ( i = j = keeps = 0 ; i < tail_valence && j < head_valence ;  )

	xor	ecx, ecx
	add	esp, 32					; 00000020H
	xor	edi, edi
	xor	esi, esi
	mov	DWORD PTR _keeps$[ebp], ecx
	test	ebx, ebx
	jle	$LN131@star_finag
$LL42@star_finag:
	cmp	edi, DWORD PTR _head_valence$[ebp]
	jge	$LN131@star_finag

; 462  :   { if ( tail_edges[i].v_id < head_edges[j].v_id )

	mov	eax, DWORD PTR _head_edges$[ebp+edi*8+4]
	mov	edx, DWORD PTR _tail_edges$[ebp+esi*8+4]
	cmp	edx, eax
	jae	SHORT $LN160@star_finag
$LL39@star_finag:

; 463  :       while ( tail_edges[i].v_id < head_edges[j].v_id ) i++;

	inc	esi
	cmp	DWORD PTR _tail_edges$[ebp+esi*8+4], eax
	jb	SHORT $LL39@star_finag

; 464  :     else

	jmp	SHORT $LN35@star_finag
$LN160@star_finag:

; 465  :       while ( tail_edges[i].v_id > head_edges[j].v_id ) j++;

	jbe	SHORT $LN35@star_finag
	mov	eax, edx
$LL36@star_finag:
	inc	edi
	cmp	eax, DWORD PTR _head_edges$[ebp+edi*8+4]
	ja	SHORT $LL36@star_finag
$LN35@star_finag:

; 466  :     if ( (i >= tail_valence) || (j >= head_valence) )

	cmp	esi, ebx
	jge	$LN131@star_finag
	cmp	edi, DWORD PTR _head_valence$[ebp]
	jge	$LN131@star_finag

; 467  :       break;
; 468  :     if ( tail_edges[i].v_id == head_edges[j].v_id ) 

	mov	eax, DWORD PTR _tail_edges$[ebp+esi*8+4]
	cmp	eax, DWORD PTR _head_edges$[ebp+edi*8+4]
	jne	$LN32@star_finag

; 469  :     { /* skip if nonzero wrap */
; 470  :       if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	$LN30@star_finag

; 471  :       { WRAPTYPE w1 = get_edge_wrap(inverse_id(tail_edges[i].e_id));

	mov	eax, DWORD PTR _tail_edges$[ebp+esi*8]
	mov	edx, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	xor	eax, 134217728				; 08000000H
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ebx+784]
	mov	ecx, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN69@star_finag
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	mov	DWORD PTR _w1$89399[ebp], eax
	jmp	SHORT $LN70@star_finag
$LN69@star_finag:
	mov	DWORD PTR _w1$89399[ebp], ecx
$LN70@star_finag:

; 472  :         WRAPTYPE w2 = get_edge_wrap(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ebx+784]
	mov	eax, DWORD PTR [eax+edx]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN73@star_finag
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN73@star_finag:

; 473  :         WRAPTYPE w3 = get_edge_wrap(head_edges[j].e_id);

	mov	edx, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	mov	DWORD PTR _w2$89400[ebp], eax
	mov	eax, DWORD PTR _head_edges$[ebp+edi*8]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ebx+784]
	mov	ecx, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN77@star_finag
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	mov	ebx, eax
	jmp	SHORT $LN78@star_finag
$LN77@star_finag:
	mov	ebx, ecx
$LN78@star_finag:

; 474  :         WRAPTYPE netwrap = (sym_compose)(w1,w2);

	mov	eax, DWORD PTR _w2$89400[ebp]
	mov	ecx, DWORD PTR _w1$89399[ebp]
	push	eax
	push	ecx
	call	DWORD PTR _sym_compose

; 475  :         netwrap = (*sym_compose)(netwrap,w3);

	push	ebx
	push	eax
	call	DWORD PTR _sym_compose

; 476  :         if ( netwrap != 0 )
; 477  :         { i++; j++;  continue;

	mov	ecx, DWORD PTR _keeps$[ebp]
	mov	ebx, DWORD PTR _tail_valence$[ebp]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN30@star_finag
	inc	esi
	inc	edi
	jmp	SHORT $LN32@star_finag
$LN30@star_finag:

; 478  :         }
; 479  :       }
; 480  :       tail_edges[keeps] = tail_edges[i]; i++;

	mov	edx, DWORD PTR _tail_edges$[ebp+esi*8]
	mov	DWORD PTR _tail_edges$[ebp+ecx*8], edx
	mov	eax, DWORD PTR _tail_edges$[ebp+esi*8+4]

; 481  :       head_edges[keeps] = head_edges[j]; j++;

	mov	edx, DWORD PTR _head_edges$[ebp+edi*8]
	mov	DWORD PTR _tail_edges$[ebp+ecx*8+4], eax
	mov	DWORD PTR _head_edges$[ebp+ecx*8], edx
	mov	eax, DWORD PTR _head_edges$[ebp+edi*8+4]
	inc	esi
	mov	DWORD PTR _head_edges$[ebp+ecx*8+4], eax
	inc	edi

; 482  :       keeps++;

	inc	ecx
	mov	DWORD PTR _keeps$[ebp], ecx
$LN32@star_finag:

; 459  : 
; 460  :   /* keep only pairs of edges with same endpoints */
; 461  :   for ( i = j = keeps = 0 ; i < tail_valence && j < head_valence ;  )

	cmp	esi, ebx
	jl	$LL42@star_finag
$LN131@star_finag:

; 483  :     }
; 484  :   }
; 485  :   tail_valence = head_valence = keeps;
; 486  : 
; 487  :   /* remove edges that are facet-adjacent to elim edge */
; 488  :   start_fe = fe_id = get_edge_fe(e_id);

	mov	edx, DWORD PTR _e_id$[ebp]
	mov	esi, DWORD PTR _web+124
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv1016[ebp], eax
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR _head_valence$[ebp], ecx
	mov	DWORD PTR _tail_valence$[ebp], ecx
	test	eax, eax
	je	SHORT $LN79@star_finag
$LN80@star_finag:
	mov	eax, DWORD PTR [eax+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN79@star_finag
	xor	eax, 134217728				; 08000000H
$LN79@star_finag:
	mov	edi, DWORD PTR _web+460
	lea	edx, DWORD PTR _head_edges$[ebp+ecx*8]
	lea	ecx, DWORD PTR _tail_edges$[ebp+ecx*8]
	mov	DWORD PTR _start_fe$[ebp], eax
	mov	DWORD PTR tv1484[ebp], edx
	mov	DWORD PTR tv1486[ebp], ecx
$LL29@star_finag:

; 489  :   do
; 490  :   { edge_id e_a = get_fe_edge(get_prev_edge(fe_id));

	mov	edx, eax
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	DWORD PTR tv1057[ebp], edx
	je	SHORT $LN84@star_finag
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+eax*4]
	lea	esi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ecx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN83@star_finag
$LN84@star_finag:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+eax*4]
	lea	esi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ecx+28]
$LN83@star_finag:
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edi+ebx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ebx+20]

; 491  :     edge_id e_b = get_fe_edge(get_next_edge(fe_id));

	test	edx, edx
	je	SHORT $LN90@star_finag
	mov	ecx, DWORD PTR [ecx+28]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN89@star_finag
$LN90@star_finag:
	mov	ecx, DWORD PTR [ecx+32]
$LN89@star_finag:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [edx+20]

; 492  :     for ( i = 0 ; i < tail_valence ; i++ )

	xor	edx, edx
	cmp	DWORD PTR _tail_valence$[ebp], edx
	jle	SHORT $LN146@star_finag
	or	eax, 134217728				; 08000000H
	npad	2
$LL26@star_finag:

; 493  :     { if ( equal_element(e_a,tail_edges[i].e_id) )

	mov	ebx, DWORD PTR _tail_edges$[ebp+edx*8]
	or	ebx, 134217728				; 08000000H
	cmp	eax, ebx
	je	SHORT $LN132@star_finag

; 492  :     for ( i = 0 ; i < tail_valence ; i++ )

	inc	edx
	cmp	edx, DWORD PTR _tail_valence$[ebp]
	jl	SHORT $LL26@star_finag

; 499  :     { if ( equal_element(e_b,head_edges[i].e_id) )

	jmp	SHORT $LN146@star_finag
$LN132@star_finag:

; 494  :       { tail_edges[i] = tail_edges[--tail_valence];

	mov	eax, DWORD PTR tv1486[ebp]
	dec	DWORD PTR _tail_valence$[ebp]
	mov	ebx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR tv1486[ebp], eax
	mov	DWORD PTR _tail_edges$[ebp+edx*8], ebx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _tail_edges$[ebp+edx*8+4], eax
$LN146@star_finag:

; 495  :         break;
; 496  :       }
; 497  :     }
; 498  :     for ( i = 0 ; i < head_valence ; i++ )

	mov	ebx, DWORD PTR _head_valence$[ebp]
	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN150@star_finag
	or	ecx, 134217728				; 08000000H
	npad	9
$LL22@star_finag:

; 499  :     { if ( equal_element(e_b,head_edges[i].e_id) )

	mov	edx, DWORD PTR _head_edges$[ebp+eax*8]
	or	edx, 134217728				; 08000000H
	cmp	ecx, edx
	je	SHORT $LN133@star_finag

; 495  :         break;
; 496  :       }
; 497  :     }
; 498  :     for ( i = 0 ; i < head_valence ; i++ )

	inc	eax
	cmp	eax, ebx
	jl	SHORT $LL22@star_finag

; 499  :     { if ( equal_element(e_b,head_edges[i].e_id) )

	jmp	SHORT $LN150@star_finag
$LN133@star_finag:

; 500  :       { head_edges[i] = head_edges[--head_valence];

	mov	ecx, DWORD PTR tv1484[ebp]
	mov	edx, DWORD PTR [ecx-8]
	dec	ebx
	sub	ecx, 8
	mov	DWORD PTR tv1484[ebp], ecx
	mov	DWORD PTR _head_edges$[ebp+eax*8], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR _head_valence$[ebp], ebx
	mov	DWORD PTR _head_edges$[ebp+eax*8+4], ecx
$LN150@star_finag:

; 501  :         break;
; 502  :       }
; 503  :     }
; 504  :     fe_id = get_next_facet(fe_id);

	cmp	DWORD PTR tv1057[ebp], 0
	je	SHORT $LN96@star_finag
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN28@star_finag
$LN96@star_finag:
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+40]
$LN28@star_finag:

; 505  :   } while ( !equal_id(fe_id,start_fe) );

	cmp	eax, DWORD PTR _start_fe$[ebp]
	jne	$LL29@star_finag

; 506  : 
; 507  :   if ( head_valence != tail_valence )

	mov	esi, DWORD PTR _tail_valence$[ebp]
	cmp	ebx, esi
	je	SHORT $LN147@star_finag

; 508  :   { sprintf(errmsg,"Internal error: star_finagle() edge %s: head_valence %d != tail_valence %d\n",
; 509  :        ELNAME(e_id),head_valence,tail_valence);

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN53@star_finag
	mov	ecx, DWORD PTR tv1016[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN54@star_finag
$LN53@star_finag:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN54@star_finag:
	push	esi
	push	ebx
	push	eax
	push	OFFSET ??_C@_0EM@PDLKAJMH@Internal?5error?3?5star_finagle?$CI?$CJ?5e@
	push	OFFSET _errmsg
	call	_sprintf

; 510  :     kb_error(3982,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3982					; 00000f8eH
	call	_kb_error
	add	esp, 32					; 00000020H
$LN147@star_finag:

; 511  :   }
; 512  :   /* Remove edges that have facets at large angle from */
; 513  :   /*  triangle plane, indicating neck pinch */
; 514  :   get_edge_side(e_id,side1);

	mov	eax, DWORD PTR _e_id$[ebp]
	lea	edx, DWORD PTR _side1$[ebp]
	push	edx
	push	eax
	call	_get_edge_side

; 515  :   aa = dot(side1,side1,SDIM);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _side1$[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	fstp	QWORD PTR _aa$[ebp]
	add	esp, 20					; 00000014H

; 516  :   for ( i = 0 ; i < head_valence ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	ebx, ebx
	jle	$LN15@star_finag

; 511  :   }
; 512  :   /* Remove edges that have facets at large angle from */
; 513  :   /*  triangle plane, indicating neck pinch */
; 514  :   get_edge_side(e_id,side1);

	mov	edx, DWORD PTR _tail_valence$[ebp]
	lea	eax, DWORD PTR _tail_edges$[ebp+edx*8]
	mov	edx, DWORD PTR _head_valence$[ebp]
	lea	ecx, DWORD PTR _tail_edges$[ebp]
	mov	DWORD PTR tv1530[ebp], ecx
	mov	DWORD PTR tv1532[ebp], eax
	lea	ecx, DWORD PTR _head_edges$[ebp]
	lea	eax, DWORD PTR _head_edges$[ebp+edx*8]
	mov	DWORD PTR tv1534[ebp], ecx
	mov	DWORD PTR tv1536[ebp], eax
	npad	10
$LL17@star_finag:

; 517  :   { int flatflag = 0;
; 518  :     /* calculate triangle normal */
; 519  :     get_edge_side(tail_edges[i].e_id,side2);

	mov	esi, DWORD PTR tv1530[ebp]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR _side2$[ebp]
	push	ecx
	xor	ebx, ebx
	push	edx
	mov	DWORD PTR _flatflag$89424[ebp], ebx
	call	_get_edge_side

; 520  :     ab = dot(side1,side2,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _side2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _side1$[ebp]
	push	edx
	call	_dot
	fst	QWORD PTR _ab$[ebp]

; 521  :  
; 522  :     start_fe = fe_id = get_edge_fe(tail_edges[i].e_id);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	add	esp, 20					; 00000014H
	cmp	eax, ebx
	jne	SHORT $LN100@star_finag
	xor	eax, eax
	jmp	SHORT $LN99@star_finag
$LN100@star_finag:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN99@star_finag
	xor	eax, 134217728				; 08000000H
$LN99@star_finag:

; 523  :     for ( j = 0 ; j < 2 ; j++ ) /* check both head and tail edges */

	mov	edx, DWORD PTR _web+460
	fmul	ST(0), ST(0)
	mov	DWORD PTR _start_fe$[ebp], eax
	fstp	QWORD PTR tv1165[ebp]
	npad	9
$LL11@star_finag:

; 524  :     {
; 525  :       do
; 526  :       { REAL numer,denom;
; 527  :         facetedge_id ffe = inverse_id(get_prev_edge(fe_id));

	mov	edi, eax
	and	eax, 134217727				; 07ffffffH
	shr	edi, 27					; 0000001bH
	add	eax, eax
	and	edi, 1
	lea	esi, DWORD PTR [eax+eax]
	je	SHORT $LN104@star_finag
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN103@star_finag
$LN104@star_finag:
	mov	ecx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [ecx+28]
$LN103@star_finag:
	xor	eax, 134217728				; 08000000H

; 528  :         edge_id ee_id = get_fe_edge(ffe);
; 529  :         get_edge_side(ee_id,side3);

	lea	ecx, DWORD PTR _side3$[ebp]
	push	ecx
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	eax
	call	_get_edge_side

; 530  :         ac = dot(side1,side3,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _side3$[ebp]
	push	ecx
	lea	edx, DWORD PTR _side1$[ebp]
	push	edx
	call	_dot
	fstp	QWORD PTR _ac$[ebp]

; 531  :         bb = dot(side2,side2,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _side2$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fstp	QWORD PTR _bb$[ebp]

; 532  :         bc = dot(side2,side3,SDIM);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _side3$[ebp]
	push	ecx
	lea	edx, DWORD PTR _side2$[ebp]
	push	edx
	call	_dot
	fst	QWORD PTR _bc$[ebp]

; 533  :         cc = dot(side3,side3,SDIM);
; 534  :         numer = (j?-1:1)*(ac*bb - ab*bc);

	fld	QWORD PTR _bb$[ebp]
	mov	ecx, DWORD PTR _web+616
	fmul	QWORD PTR _ac$[ebp]
	xor	eax, eax
	test	ebx, ebx
	fxch	ST(1)
	fmul	QWORD PTR _ab$[ebp]
	sete	al
	push	ecx
	lea	edx, DWORD PTR _side3$[ebp]
	fsubp	ST(1), ST(0)
	push	edx
	lea	eax, DWORD PTR [eax+eax-1]

; 535  :         denom = sqrt(aa*bb-ab*ab)*sqrt(bb*cc-bc*bc);
; 536  :         if ( numer > .8*denom ) 

	mov	DWORD PTR tv1397[ebp], eax
	fild	DWORD PTR tv1397[ebp]
	mov	eax, edx
	push	eax
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR tv1357[ebp]
	call	_dot
	fmul	QWORD PTR _bb$[ebp]
	add	esp, 56					; 00000038H
	fld	QWORD PTR _bc$[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR tv1355[ebp]
	fld	QWORD PTR _bb$[ebp]
	fmul	QWORD PTR _aa$[ebp]
	fsub	QWORD PTR tv1165[ebp]
	call	__CIsqrt
	fmul	QWORD PTR tv1355[ebp]
	fmul	QWORD PTR __real@3fe999999999999a
	fcomp	QWORD PTR tv1357[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN8@star_finag

; 537  :           flatflag = 1;

	mov	DWORD PTR _flatflag$89424[ebp], 1
$LN8@star_finag:

; 538  :         fe_id = get_next_facet(fe_id);

	mov	edx, DWORD PTR _web+460
	test	edi, edi
	je	SHORT $LN110@star_finag
	mov	ecx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [ecx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN10@star_finag
$LN110@star_finag:
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+40]
$LN10@star_finag:

; 539  :       } while ( !equal_id(fe_id,start_fe) );

	cmp	eax, DWORD PTR _start_fe$[ebp]
	jne	$LL11@star_finag

; 540  :       /* set up to try the head side */
; 541  :       start_fe = fe_id = inverse_id(get_edge_fe(head_edges[i].e_id));

	mov	ecx, DWORD PTR tv1534[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	test	eax, eax
	je	SHORT $LN113@star_finag
$LN114@star_finag:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN113@star_finag
	xor	eax, 134217728				; 08000000H
$LN113@star_finag:
	xor	eax, 134217728				; 08000000H
	inc	ebx
	mov	DWORD PTR _start_fe$[ebp], eax
	cmp	ebx, 2
	jl	$LL11@star_finag

; 542  :     }
; 543  : 
; 544  :     if ( !flatflag )

	cmp	DWORD PTR _flatflag$89424[ebp], 0

; 545  :     { /* probably a neck, so let it be deleted */
; 546  :       head_edges[i] = head_edges[--head_valence];

	mov	eax, DWORD PTR tv1534[ebp]
	mov	esi, 1
	jne	SHORT $LN148@star_finag
	mov	ecx, DWORD PTR tv1536[ebp]
	mov	edx, DWORD PTR [ecx-8]
	sub	DWORD PTR _head_valence$[ebp], esi

; 547  :       tail_edges[i] = tail_edges[--tail_valence];

	sub	DWORD PTR _tail_valence$[ebp], esi

; 548  :       i--;

	sub	DWORD PTR _i$[ebp], esi
	sub	ecx, 8
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR tv1532[ebp]
	mov	edi, DWORD PTR [edx-8]
	mov	DWORD PTR tv1536[ebp], ecx
	mov	ecx, DWORD PTR [ecx+4]
	sub	edx, 8
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR tv1530[ebp]
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR tv1532[ebp], edx
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx
	sub	eax, 8
	sub	ecx, 8
	jmp	SHORT $LN16@star_finag
$LN148@star_finag:
	mov	ecx, DWORD PTR tv1530[ebp]
$LN16@star_finag:

; 516  :   for ( i = 0 ; i < head_valence ; i++ )

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, esi
	add	eax, 8
	add	ecx, 8
	mov	DWORD PTR _i$[ebp], edx
	mov	DWORD PTR tv1534[ebp], eax
	mov	DWORD PTR tv1530[ebp], ecx
	cmp	edx, DWORD PTR _head_valence$[ebp]
	jl	$LL17@star_finag
$LN15@star_finag:

; 549  :     }
; 550  :     
; 551  :   }
; 552  :   
; 553  :   /* refine remaining edges */
; 554  :   for ( i = 0 ; i < tail_valence ; i++ )

	mov	ebx, DWORD PTR _tail_valence$[ebp]
	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN149@star_finag
	npad	10
$LL6@star_finag:

; 555  :     edge_refine(tail_edges[i].e_id);

	mov	eax, DWORD PTR _tail_edges$[ebp+esi*8]
	push	eax
	call	_edge_refine
	inc	esi
	add	esp, 4
	cmp	esi, ebx
	jl	SHORT $LL6@star_finag
$LN149@star_finag:

; 556  :   for ( i = 0 ; i < head_valence ; i++ )

	mov	edi, DWORD PTR _head_valence$[ebp]
	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN144@star_finag
$LL3@star_finag:

; 557  :     edge_refine(head_edges[i].e_id);

	mov	ecx, DWORD PTR _head_edges$[ebp+esi*8]
	push	ecx
	call	_edge_refine
	inc	esi
	add	esp, 4
	cmp	esi, edi
	jl	SHORT $LL3@star_finag
$LN144@star_finag:

; 558  : 
; 559  :   return tail_valence;
; 560  : 
; 561  : } /* end star_finagle */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	mov	eax, ebx
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_star_finagle ENDP
_TEXT	ENDS
PUBLIC	__real@3fb999999999999a
PUBLIC	??_C@_0DP@KEJAHAKK@Vertices?5?$CFs?5and?5?$CFs?5are?5on?5differ@ ; `string'
PUBLIC	__real@3ff3333333333333
PUBLIC	__real@3fc0000000000000
PUBLIC	__real@3fd8000000000000
PUBLIC	__real@3fe8000000000000
PUBLIC	__real@4010000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@c000000000000000
PUBLIC	__real@40f86a0000000000
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	??_C@_0BC@EHDAIHOF@Refining?5edge?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0DJ@JPKFJHHP@Edge?5divide?5not?5implemented?5for?5@ ; `string'
PUBLIC	??_C@_0EA@EJNIPAFM@extra_boundary_param?5attribute?5d@ ; `string'
PUBLIC	??_C@_0EA@DOFMKFEH@extra_boundary?5attribute?5defined@ ; `string'
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_edge_divide
EXTRN	_check_edge_vol_methods:PROC
EXTRN	_everything_quantities_flag:DWORD
EXTRN	_new_facetedge:PROC
EXTRN	_clear_v_conmap:PROC
EXTRN	_project_v_constr:PROC
EXTRN	_set_v_conmap:PROC
EXTRN	_set_e_conmap:PROC
EXTRN	_nullcon:QWORD
EXTRN	_eval:PROC
EXTRN	_b_extrapolate:PROC
EXTRN	_interp_bdry_param:DWORD
EXTRN	_mat_mult:PROC
EXTRN	_bezier_refine_1d:BYTE
EXTRN	_mat2d_setup:PROC
EXTRN	_bezier_flag:DWORD
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	_E_BOUNDARY_ATTR:DWORD
EXTRN	_get_edge_length:PROC
EXTRN	_calc_edge:PROC
EXTRN	_dup_edge:PROC
EXTRN	_circular_arc_flag:DWORD
EXTRN	_new_vertex:PROC
EXTRN	_sym_wrap:DWORD
EXTRN	_valid_element:PROC
EXTRN	_extra_bdry_param_attr:DWORD
EXTRN	_extra_bdry_attr:DWORD
;	COMDAT __real@3fb999999999999a
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT ??_C@_0DP@KEJAHAKK@Vertices?5?$CFs?5and?5?$CFs?5are?5on?5differ@
CONST	SEGMENT
??_C@_0DP@KEJAHAKK@Vertices?5?$CFs?5and?5?$CFs?5are?5on?5differ@ DB 'Vert'
	DB	'ices %s and %s are on different boundaries from edge %s .', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __real@3ff3333333333333
CONST	SEGMENT
__real@3ff3333333333333 DQ 03ff3333333333333r	; 1.2
CONST	ENDS
;	COMDAT __real@3fc0000000000000
CONST	SEGMENT
__real@3fc0000000000000 DQ 03fc0000000000000r	; 0.125
CONST	ENDS
;	COMDAT __real@3fd8000000000000
CONST	SEGMENT
__real@3fd8000000000000 DQ 03fd8000000000000r	; 0.375
CONST	ENDS
;	COMDAT __real@3fe8000000000000
CONST	SEGMENT
__real@3fe8000000000000 DQ 03fe8000000000000r	; 0.75
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@c000000000000000
CONST	SEGMENT
__real@c000000000000000 DQ 0c000000000000000r	; -2
CONST	ENDS
;	COMDAT __real@40f86a0000000000
CONST	SEGMENT
__real@40f86a0000000000 DQ 040f86a0000000000r	; 100000
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT ??_C@_0BC@EHDAIHOF@Refining?5edge?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BC@EHDAIHOF@Refining?5edge?5?$CFs?6?$AA@ DB 'Refining edge %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@JPKFJHHP@Edge?5divide?5not?5implemented?5for?5@
CONST	SEGMENT
??_C@_0DJ@JPKFJHHP@Edge?5divide?5not?5implemented?5for?5@ DB 'Edge divide'
	DB	' not implemented for simplex representation.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@EJNIPAFM@extra_boundary_param?5attribute?5d@
CONST	SEGMENT
??_C@_0EA@EJNIPAFM@extra_boundary_param?5attribute?5d@ DB 'extra_boundary'
	DB	'_param attribute defined but not extra_boundary.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@DOFMKFEH@extra_boundary?5attribute?5defined@
CONST	SEGMENT
??_C@_0EA@DOFMKFEH@extra_boundary?5attribute?5defined@ DB 'extra_boundary'
	DB	' attribute defined but not extra_boundary_param.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _edge_divide
_TEXT	SEGMENT
_e_id$GSCopy$ = -1864					; size = 4
_tailv$ = -1860						; size = 4
_new_mid$ = -1856					; size = 4
_old_mid$ = -1852					; size = 4
_headv$ = -1848						; size = 4
tv4076 = -1844						; size = 4
_y1$89526 = -1840					; size = 8
tv5741 = -1836						; size = 4
tv4133 = -1836						; size = 4
tv4086 = -1832						; size = 4
_yp$89531 = -1828					; size = 8
tv6121 = -1824						; size = 4
tv6043 = -1824						; size = 4
tv6022 = -1824						; size = 4
tv4809 = -1824						; size = 4
_b$89537 = -1820					; size = 8
tv4928 = -1816						; size = 4
tv4354 = -1816						; size = 4
tv4340 = -1816						; size = 4
_x1$89525 = -1812					; size = 8
tv4425 = -1808						; size = 4
tv4129 = -1808						; size = 4
tv4093 = -1808						; size = 4
_old_fe$ = -1808					; size = 4
_new_e$ = -1804						; size = 4
tv5810 = -1800						; size = 4
tv4074 = -1800						; size = 4
_wrap2$ = -1796						; size = 4
_wrap$ = -1796						; size = 4
tv6925 = -1792						; size = 4
_mv$ = -1792						; size = 4
_mu$ = -1792						; size = 4
tv6136 = -1788						; size = 8
tv6134 = -1788						; size = 8
tv6132 = -1788						; size = 8
tv6130 = -1788						; size = 8
tv6128 = -1788						; size = 8
tv6126 = -1788						; size = 8
tv6124 = -1788						; size = 8
tv6122 = -1788						; size = 8
tv5784 = -1784						; size = 4
tv4344 = -1784						; size = 4
_pa$89860 = -1780					; size = 4
_n$ = -1780						; size = 4
_oldv$ = -1780						; size = 4
tv4142 = -1776						; size = 8
_attr$89905 = -1776					; size = 8
_rear$89584 = -1776					; size = 8
_xp$89530 = -1776					; size = 8
tv6235 = -1772						; size = 4
tv6105 = -1772						; size = 4
tv6046 = -1772						; size = 4
tv5951 = -1772						; size = 4
tv4812 = -1772						; size = 4
tv4746 = -1772						; size = 4
tv4708 = -1772						; size = 4
tv4632 = -1772						; size = 4
tv4623 = -1772						; size = 4
tv1791 = -1768						; size = 4
_parama$89687 = -1768					; size = 4
_xm$89587 = -1768					; size = 4
tv4917 = -1764						; size = 4
_paramb$89689 = -1764					; size = 4
_divider$ = -1764					; size = 4
tv4927 = -1760						; size = 4
tv4905 = -1760						; size = 4
tv4629 = -1760						; size = 4
tv4620 = -1760						; size = 4
tv4528 = -1760						; size = 4
tv1088 = -1760						; size = 4
_oldc$89642 = -1760					; size = 4
_newv$ = -1760						; size = 4
_j$ = -1760						; size = 4
_t$ = -1760						; size = 4
_first_fe$ = -1756					; size = 4
_parammid$89685 = -1756					; size = 4
_i$ = -1756						; size = 4
_h$ = -1756						; size = 4
_oldcxJ$89641 = -1752					; size = 1008
_prod1$ = -744						; size = 168
_newx$89644 = -740					; size = 164
_oldcqXvS$89640 = -576					; size = 84
_hh$89586 = -540					; size = 48
_s$ = -492						; size = 48
_tt$89585 = -444					; size = 48
_w$ = -396						; size = 48
_q1$ = -348						; size = 48
_allv$ = -300						; size = 164
_m$ = -136						; size = 48
_oldx$ = -88						; size = 84
_defaultp$89686 = -52					; size = 48
_q3$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_edge_divide PROC					; COMDAT

; 584  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1864				; 00000748H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 585  :   REAL s[MAXCOORD],*t,*mu=NULL,*mv,*h,m[MAXCOORD],q1[MAXCOORD],q3[MAXCOORD];

	xor	esi, esi
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]

; 995  :         { REAL *pa = get_param(allv[i-1]);
; 996  :           REAL *p  = get_param(allv[i]);
; 997  :           mu = get_coord(allv[i-1]);             
; 998  :           mv = get_coord(allv[i]);

	mov	DWORD PTR _e_id$GSCopy$[ebp], edi
	mov	DWORD PTR _mu$[ebp], esi
	mov	DWORD PTR _divider$[ebp], esi
	mov	DWORD PTR _old_mid$[ebp], esi
	mov	DWORD PTR _new_mid$[ebp], esi
	mov	DWORD PTR _wrap2$[ebp], esi
	mov	DWORD PTR _oldv$[ebp], esi
	cmp	DWORD PTR _extra_bdry_attr, esi
	je	SHORT $LN463@edge_divid

; 586  :   edge_id  new_e;
; 587  :   vertex_id divider=NULLID,old_mid=0,new_mid=0,headv,tailv;
; 588  :   int i,j,k,n;
; 589  :   facetedge_id new_fe,old_fe;
; 590  :   int wrap = 0,wrap1=0,wrap2=0;
; 591  :   REAL w[MAXCOORD];
; 592  :   vertex_id *oldv=NULL,*newv;
; 593  :   REAL *oldx[MAXLAGRANGE+1];
; 594  :   REAL prod1[MAXLAGRANGE+1],prod2;
; 595  :   facetedge_id first_fe;
; 596  :   vertex_id allv[2*MAXLAGRANGE+1];
; 597  :   
; 598  : 
; 599  :   if ( extra_bdry_attr && !extra_bdry_param_attr )

	cmp	DWORD PTR _extra_bdry_param_attr, esi
	jne	SHORT $LN163@edge_divid

; 600  :     kb_error(2841,
; 601  :      "extra_boundary attribute defined but not extra_boundary_param.\n",
; 602  :         RECOVERABLE); 

	push	1
	push	OFFSET ??_C@_0EA@DOFMKFEH@extra_boundary?5attribute?5defined@
	push	2841					; 00000b19H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN163@edge_divid:

; 603  : 
; 604  :   if ( !extra_bdry_attr && extra_bdry_param_attr )

	cmp	DWORD PTR _extra_bdry_attr, esi
	jne	SHORT $LN162@edge_divid
$LN463@edge_divid:
	cmp	DWORD PTR _extra_bdry_param_attr, esi
	je	SHORT $LN162@edge_divid

; 605  :     kb_error(3367,
; 606  :      "extra_boundary_param attribute defined but not extra_boundary.\n",
; 607  :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EA@EJNIPAFM@extra_boundary_param?5attribute?5d@
	push	3367					; 00000d27H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN162@edge_divid:

; 608  : 
; 609  :   if ( !valid_element(e_id) ) 

	push	edi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN161@edge_divid
	pop	edi
	pop	esi

; 1086 : 
; 1087 :  return new_e;
; 1088 : 
; 1089 : } /* end edge_divide() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN161@edge_divid:

; 610  :      return NULLID;
; 611  : 
; 612  :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN160@edge_divid

; 613  :      kb_error(1239,"Edge divide not implemented for simplex representation.\n",
; 614  :         COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DJ@JPKFJHHP@Edge?5divide?5not?5implemented?5for?5@
	push	1239					; 000004d7H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN160@edge_divid:

; 615  : 
; 616  :   if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, esi
	je	SHORT $LN159@edge_divid

; 617  :   { sprintf(msg,"Refining edge %s\n",ELNAME(e_id));

	test	edi, 268435456				; 10000000H
	je	SHORT $LN166@edge_divid
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN167@edge_divid
$LN166@edge_divid:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN167@edge_divid:
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BC@EHDAIHOF@Refining?5edge?5?$CFs?6?$AA@
	push	ecx
	call	_sprintf

; 618  :     outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN159@edge_divid:

; 619  :   }
; 620  : 
; 621  :   headv = get_edge_headv(e_id);

	push	ebx
	push	edi
	call	_get_edge_headv
	mov	ebx, eax

; 622  :   tailv = get_edge_tailv(e_id);

	push	edi
	mov	DWORD PTR _headv$[ebp], ebx
	call	_get_edge_tailv

; 623  :   t = get_coord(tailv);

	mov	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx+64]
	mov	edx, DWORD PTR _web+12
	mov	DWORD PTR _tailv$[ebp], eax
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv4076[ebp], eax

; 624  :   h = get_coord(headv);

	and	ebx, 134217727				; 07ffffffH
	mov	eax, edx
	mov	eax, DWORD PTR [eax+ebx*4]
	add	esi, ecx
	add	eax, ecx
	add	esp, 8

; 625  :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	mov	DWORD PTR _t$[ebp], esi
	mov	DWORD PTR tv4086[ebp], ebx
	mov	DWORD PTR _h$[ebp], eax
	je	$LN464@edge_divid

; 626  :   { wrap = get_edge_wrap(e_id);

	mov	edx, DWORD PTR _web+124
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [edx+ecx+784]
	mov	eax, DWORD PTR [eax+ecx]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN220@edge_divid
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN220@edge_divid:
	mov	DWORD PTR _wrap$[ebp], eax

; 627  :     /* always use tail as base, for predictability */
; 628  :     if ( wrap ) /* see which endpoint closer to origin, to use as base */

	test	eax, eax
	je	SHORT $LN157@edge_divid

; 629  :     { /* use tail as base */
; 630  :       (*sym_wrap)(get_coord(headv),w,wrap);

	mov	ecx, DWORD PTR _web+104
	mov	edx, eax
	push	edx
	mov	edx, DWORD PTR _dymem
	lea	eax, DWORD PTR _w$[ebp]
	push	eax
	mov	eax, DWORD PTR [ecx+edx+64]
	mov	ecx, DWORD PTR _web+12
	add	eax, DWORD PTR [ecx+ebx*4]
	push	eax
	call	DWORD PTR _sym_wrap

; 631  :       h = w;
; 632  :       wrap1 = 0; wrap2 = wrap;

	mov	eax, DWORD PTR _wrap$[ebp]
	lea	edx, DWORD PTR _w$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _h$[ebp], edx
	mov	DWORD PTR _wrap2$[ebp], eax
	jmp	SHORT $LN464@edge_divid
$LN157@edge_divid:

; 633  :     }
; 634  :     else wrap1 = wrap2 = 0;

	mov	DWORD PTR _wrap2$[ebp], 0
$LN464@edge_divid:

; 635  :   }
; 636  :   if ( web.modeltype == LINEAR )

	mov	eax, DWORD PTR _web+628
	fldz
	fld	QWORD PTR __real@3fe0000000000000
	fld1
	cmp	eax, 1
	jne	$LN155@edge_divid

; 637  :   { 
; 638  :     for ( k = 0 ; k < SDIM ; k++ ) m[k] = (t[k] + h[k])/2;

	mov	edx, DWORD PTR _web+616
	fstp	ST(0)
	fstp	ST(1)
	test	edx, edx
	jle	SHORT $LN517@edge_divid
	mov	eax, DWORD PTR _h$[ebp]
	lea	ecx, DWORD PTR _m$[ebp]
	sub	eax, esi
	sub	ecx, esi
$LN154@edge_divid:
	fld	QWORD PTR [eax+esi]
	add	esi, 8
	dec	edx
	fadd	QWORD PTR [esi-8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [ecx+esi-8]
	jne	SHORT $LN154@edge_divid
$LN517@edge_divid:

; 639  :     divider = new_vertex(m,e_id);

	lea	ecx, DWORD PTR _m$[ebp]
	fstp	ST(0)
	push	edi
	push	ecx
	call	_new_vertex

; 640  :     set_attr(divider,get_eattr(e_id) & (FIXED|BARE_NAKED));

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	mov	DWORD PTR _divider$[ebp], eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+124
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 65600				; 00010040H
	add	esp, 8
	or	DWORD PTR [eax+8], edx
	jmp	$LN125@edge_divid
$LN155@edge_divid:

; 641  :   }
; 642  :   else if ( web.modeltype == QUADRATIC )

	cmp	eax, 2
	jne	$LN519@edge_divid

; 643  :   { 
; 644  :     divider = get_edge_midv(e_id);  /* use old midpoint */

	mov	ecx, DWORD PTR _web+124
	fstp	ST(1)
	mov	eax, edi
	fstp	ST(0)
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+216
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [ecx+eax+304]
	mov	ecx, DWORD PTR [edx+eax+8]

; 645  :     unset_attr(divider,Q_MIDPOINT);

	mov	eax, ecx
	mov	DWORD PTR _divider$[ebp], ecx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [ecx+eax]
	and	DWORD PTR [ecx+8], -131073		; fffdffffH
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+12], edx

; 646  :     set_vertex_edge(divider,NULLID); /* so set_vertex_edge works */

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+28], 0

; 647  :     /* get coordinates of new midpoint(s) */
; 648  :     mu = get_coord(divider);

	mov	ecx, DWORD PTR _web+12
	mov	ebx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	ebx, DWORD PTR [edx+eax+64]

; 649  :     if ( circular_arc_flag  && (SDIM == 2))

	cmp	DWORD PTR _circular_arc_flag, 0
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR _mu$[ebp], ebx
	je	$LN525@edge_divid
	cmp	edx, 2
	jne	$LN525@edge_divid

; 650  :     { /* using facts that midpoint is on perpendicular bisector and
; 651  :          inversions with tail center lie on a straight line */
; 652  :       REAL x1 = mu[0] - t[0];

	fld	QWORD PTR [ebx]

; 653  :       REAL y1 = mu[1] - t[1];
; 654  :       REAL x2 = h[0] - t[0];

	mov	eax, DWORD PTR _h$[ebp]
	fsub	QWORD PTR [esi]
	fst	QWORD PTR _x1$89525[ebp]
	fld	QWORD PTR [ebx+8]
	fsub	QWORD PTR [esi+8]
	fst	QWORD PTR _y1$89526[ebp]
	fld	QWORD PTR [eax]
	fsub	QWORD PTR [esi]

; 655  :       REAL y2 = h[1] - t[1];

	fld	QWORD PTR [eax+8]
	fsub	QWORD PTR [esi+8]

; 656  :       REAL det = x2*y1 - y2*x1;

	fld	ST(1)
	fmul	ST(0), ST(3)
	fld	ST(1)
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)

; 657  :       REAL xp = det > 0 ? -y1 : y1;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN168@edge_divid
	fld	ST(3)
	fchs
	fstp	QWORD PTR _xp$89530[ebp]
	jmp	SHORT $LN169@edge_divid
$LN168@edge_divid:
	fxch	ST(3)
	fst	QWORD PTR _xp$89530[ebp]
	fxch	ST(3)
$LN169@edge_divid:

; 658  :       REAL yp = det > 0 ?  x1 : -x1;

	fcomp	ST(5)
	fnstsw	ax
	fstp	ST(4)
	fld	ST(2)
	test	ah, 65					; 00000041H
	je	SHORT $LN757@edge_divid
	fchs
$LN757@edge_divid:
	fst	QWORD PTR _yp$89531[ebp]

; 659  :       REAL rr1 = x1*x1 + y1*y1;

	fld	ST(2)
	fmul	ST(0), ST(3)
	fld	ST(4)
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)

; 660  :       REAL rr2 = x2*x2 + y2*y2;

	fld	ST(5)
	fmul	ST(0), ST(6)
	fld	ST(3)
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)

; 661  :       REAL xx = x2/rr2 - x1/rr1;

	fdiv	ST(3), ST(0)
	fld	ST(5)
	fdiv	ST(0), ST(2)
	fsubp	ST(4), ST(0)

; 662  :       REAL yy = y2/rr2 - y1/rr1;

	fdivp	ST(6), ST(0)
	fdivr	ST(0), ST(3)
	fsubp	ST(5), ST(0)

; 663  :       REAL a = -x1*yy + y1*xx;  /* lambda^2 coeff */

	fld	ST(1)
	fmul	ST(0), ST(3)
	fld	ST(5)
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)

; 664  :       REAL b = xp*yy - yp*xx;  /* lambda coeff */

	fld	ST(5)
	fmul	QWORD PTR _xp$89530[ebp]
	fld	ST(3)
	fmulp	ST(3), ST(0)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _b$89537[ebp]

; 665  :       REAL c = x1/4*yy - y1/4*xx;  /* const coeff */

	fld	QWORD PTR __real@3fd0000000000000
	fmul	ST(5), ST(0)
	fxch	ST(5)
	fmulp	ST(6), ST(0)
	fxch	ST(3)
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	fmulp	ST(1), ST(0)
	fsubp	ST(3), ST(0)

; 666  :       REAL lambda = (fabs(c) < fabs(b)/100000) ?
; 667  :       ( (b > 0.0) ? (-2*c/(b + sqrt(b*b-4*a*c))) : (2*c/(-b + sqrt(b*b-4*a*c))) )
; 668  :       : (( c > 0 ) ? (2*c/(-b + sqrt(b*b-4*a*c))) : 
; 669  :                                (-2*c/(b + sqrt(b*b-4*a*c)))) ;

	fld	ST(2)
	fabs
	fld	ST(1)
	fabs
	fdiv	QWORD PTR __real@40f86a0000000000
	fcompp
	fnstsw	ax
	fld	QWORD PTR __real@c000000000000000
	fld	QWORD PTR __real@4000000000000000
	fldz
	test	ah, 65					; 00000041H
	jne	SHORT $LN176@edge_divid
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN539@edge_divid
	fstp	ST(0)
	fmul	ST(0), ST(3)
	fstp	QWORD PTR tv6122[ebp]
	fmul	ST(0), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@4010000000000000
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fadd	QWORD PTR _b$89537[ebp]
	fdivr	QWORD PTR tv6122[ebp]
	jmp	$LN175@edge_divid
$LN539@edge_divid:
	fstp	ST(1)
	fmul	ST(0), ST(3)
	fstp	QWORD PTR tv6124[ebp]
	fmul	ST(0), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@4010000000000000
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fsub	QWORD PTR _b$89537[ebp]
	fdivr	QWORD PTR tv6124[ebp]
	jmp	SHORT $LN175@edge_divid
$LN176@edge_divid:
	fcomp	ST(5)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN562@edge_divid
	fstp	ST(1)
	fmul	ST(0), ST(3)
	fstp	QWORD PTR tv6126[ebp]
	fmul	ST(0), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@4010000000000000
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fsub	QWORD PTR _b$89537[ebp]
	fdivr	QWORD PTR tv6126[ebp]
	jmp	SHORT $LN175@edge_divid
$LN562@edge_divid:
	fstp	ST(0)
	fmul	ST(0), ST(3)
	fstp	QWORD PTR tv6128[ebp]
	fmul	ST(0), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@4010000000000000
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fadd	QWORD PTR _b$89537[ebp]
	fdivr	QWORD PTR tv6128[ebp]
$LN175@edge_divid:

; 670  :       q1[0] = t[0] + x1/2 + lambda*xp;

	fld	QWORD PTR _x1$89525[ebp]

; 671  :       q1[1] = t[1] + y1/2 + lambda*yp;
; 672  : 
; 673  :       /* turn it all around for other midpoint */
; 674  :       x1 = mu[0] - h[0];

	mov	eax, DWORD PTR _h$[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR [esi]
	fld	ST(2)
	fmul	QWORD PTR _xp$89530[ebp]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _q1$[ebp]
	fmul	QWORD PTR _y1$89526[ebp]
	fadd	QWORD PTR [esi+8]
	fxch	ST(1)
	fmul	QWORD PTR _yp$89531[ebp]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _q1$[ebp+8]
	fld	QWORD PTR [ebx]
	fsub	QWORD PTR [eax]
	fst	QWORD PTR _x1$89525[ebp]

; 675  :       y1 = mu[1] - h[1];

	fld	QWORD PTR [ebx+8]
	fsub	QWORD PTR [eax+8]
	fst	QWORD PTR _y1$89526[ebp]

; 676  :       x2 = t[0] - h[0];

	fld	QWORD PTR [esi]
	fsub	QWORD PTR [eax]

; 677  :       y2 = t[1] - h[1];

	fld	QWORD PTR [esi+8]
	fsub	QWORD PTR [eax+8]

; 678  :       det = x2*y1 - y2*x1;

	fld	ST(1)
	fmul	ST(0), ST(3)
	fld	ST(1)
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)

; 679  :       xp = det > 0 ? -y1 : y1;

	fldz
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN178@edge_divid
	fld	ST(4)
	fchs
	fstp	QWORD PTR _xp$89530[ebp]
	jmp	SHORT $LN179@edge_divid
$LN178@edge_divid:
	fxch	ST(4)
	fst	QWORD PTR _xp$89530[ebp]
	fxch	ST(4)
$LN179@edge_divid:

; 680  :       yp = det > 0 ?  x1 : -x1;

	fcompp
	fnstsw	ax
	fld	ST(3)
	test	ah, 5
	jnp	SHORT $LN758@edge_divid
	fchs
$LN758@edge_divid:
	fst	QWORD PTR _yp$89531[ebp]

; 681  :       rr1 = x1*x1 + y1*y1;

	fld	ST(3)
	fmul	ST(0), ST(4)
	fld	ST(5)
	fmul	ST(0), ST(6)
	faddp	ST(1), ST(0)

; 682  :       rr2 = x2*x2 + y2*y2;

	fld	ST(2)
	fmul	ST(0), ST(3)
	fld	ST(4)
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)

; 683  :       xx = x2/rr2 - x1/rr1;

	fdiv	ST(4), ST(0)
	fld	ST(6)
	fdiv	ST(0), ST(2)
	fsubp	ST(5), ST(0)

; 684  :       yy = y2/rr2 - y1/rr1;

	fdivp	ST(3), ST(0)
	fdivr	ST(0), ST(4)
	fsubp	ST(2), ST(0)

; 685  :       a = -x1*yy + y1*xx;  /* lambda^2 coeff */

	fld	ST(2)
	fmul	ST(0), ST(4)
	fld	ST(2)
	fmul	ST(0), ST(6)
	fsubp	ST(1), ST(0)

; 686  :       b = xp*yy - yp*xx;  /* lambda coeff */

	fld	ST(2)
	fmul	QWORD PTR _xp$89530[ebp]
	fld	ST(4)
	fmulp	ST(3), ST(0)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _b$89537[ebp]

; 687  :       c = x1/4*yy - y1/4*xx;  /* const coeff */

	fld	QWORD PTR __real@3fd0000000000000
	fmul	ST(6), ST(0)
	fxch	ST(6)
	fmulp	ST(3), ST(0)
	fxch	ST(4)
	fmulp	ST(5), ST(0)
	fxch	ST(4)
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)

; 688  :       lambda = (fabs(c) < fabs(b)/100000) ?
; 689  :       ( (b > 0.0) ? (-2*c/(b + sqrt(b*b-4*a*c))) : (2*c/(-b + sqrt(b*b-4*a*c))) )
; 690  :       : (( c > 0 ) ? (2*c/(-b + sqrt(b*b-4*a*c))) : 
; 691  :                                (-2*c/(b + sqrt(b*b-4*a*c)))) ;

	fld	ST(0)
	fabs
	fld	ST(2)
	fabs
	fdiv	QWORD PTR __real@40f86a0000000000
	fcompp
	fnstsw	ax
	fldz
	test	ah, 65					; 00000041H
	jne	SHORT $LN186@edge_divid
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN182@edge_divid
	fld	QWORD PTR __real@c000000000000000
	fmul	ST(0), ST(1)
	fstp	QWORD PTR tv6130[ebp]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	fmul	QWORD PTR __real@4010000000000000
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fadd	QWORD PTR _b$89537[ebp]
	fdivr	QWORD PTR tv6130[ebp]
	jmp	$LN185@edge_divid
$LN182@edge_divid:
	fld	ST(0)
	fadd	ST(0), ST(1)
	fstp	QWORD PTR tv6132[ebp]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	fmul	QWORD PTR __real@4010000000000000
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fsub	QWORD PTR _b$89537[ebp]
	fdivr	QWORD PTR tv6132[ebp]
	jmp	SHORT $LN185@edge_divid
$LN186@edge_divid:
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN184@edge_divid
	fld	ST(0)
	fadd	ST(0), ST(1)
	fstp	QWORD PTR tv6134[ebp]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	fmul	QWORD PTR __real@4010000000000000
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fsub	QWORD PTR _b$89537[ebp]
	fdivr	QWORD PTR tv6134[ebp]
	jmp	SHORT $LN185@edge_divid
$LN184@edge_divid:
	fld	QWORD PTR __real@c000000000000000
	fmul	ST(0), ST(1)
	fstp	QWORD PTR tv6136[ebp]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	fmul	QWORD PTR __real@4010000000000000
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fadd	QWORD PTR _b$89537[ebp]
	fdivr	QWORD PTR tv6136[ebp]
$LN185@edge_divid:

; 692  :       q3[0] = h[0] + x1/2 + lambda*xp;

	fld	QWORD PTR _x1$89525[ebp]
	mov	eax, DWORD PTR _h$[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR [eax]
	fld	ST(2)
	fmul	QWORD PTR _xp$89530[ebp]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _q3$[ebp]

; 693  :       q3[1] = h[1] + y1/2 + lambda*yp;

	fmul	QWORD PTR _y1$89526[ebp]
	fadd	QWORD PTR [eax+8]
	fxch	ST(1)
	fmul	QWORD PTR _yp$89531[ebp]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _q3$[ebp+8]

; 694  :     }
; 695  :     else

	jmp	SHORT $LN125@edge_divid
$LN525@edge_divid:

; 696  :     { for ( k = 0 ; k < SDIM ; k++ ) 

	xor	eax, eax
	fstp	ST(0)
	test	edx, edx
	jle	SHORT $LN125@edge_divid
	fld	QWORD PTR __real@3fe8000000000000
	mov	ecx, DWORD PTR _h$[ebp]
	fld	QWORD PTR __real@3fd8000000000000
	fld	QWORD PTR __real@3fc0000000000000
$LN147@edge_divid:

; 697  :       { q1[k] = 0.375*t[k] + 0.75*mu[k] - 0.125*h[k];

	fld	QWORD PTR [ebx+eax*8]
	inc	eax
	fmul	ST(0), ST(3)
	fld	QWORD PTR [esi+eax*8-8]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx+eax*8-8]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _q1$[ebp+eax*8-8]

; 698  :         m[k] = mu[k];

	fld	QWORD PTR [ebx+eax*8-8]
	fstp	QWORD PTR _m$[ebp+eax*8-8]

; 699  :         q3[k] = 0.375*h[k] + 0.75*mu[k] - 0.125*t[k];

	fld	QWORD PTR [ebx+eax*8-8]
	fmul	ST(0), ST(3)
	fld	QWORD PTR [ecx+eax*8-8]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi+eax*8-8]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _q3$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LN147@edge_divid

; 696  :     { for ( k = 0 ; k < SDIM ; k++ ) 

	fstp	ST(2)
$LN566@edge_divid:

; 728  :       oldv[web.lagrange_order/2] = new_vertex(NULL,e_id);

	fstp	ST(0)
	fstp	ST(0)
$LN125@edge_divid:

; 729  :     }
; 730  : 
; 731  :   }
; 732  : 
; 733  :   /* make refine() work properly */
; 734  :   set_attr(divider,NEWVERTEX);

	mov	ebx, DWORD PTR _divider$[ebp]
	mov	edx, ebx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	lea	eax, DWORD PTR _web[edx+12]
	and	ebx, 134217727				; 07ffffffH
	mov	DWORD PTR tv4129[ebp], eax
	mov	eax, DWORD PTR [eax]
	add	ebx, ebx
	add	ebx, ebx
	mov	eax, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 4

; 735  : 
; 736  :   remove_vertex_edge(headv,inverse_id(e_id));

	mov	edx, edi
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR _headv$[ebp]
	push	edx
	push	eax
	mov	DWORD PTR tv4133[ebp], ebx
	call	_remove_vertex_edge

; 737  :   new_e = dup_edge(e_id);

	push	edi
	call	_dup_edge

; 738  :   insert_vertex_edge(headv,inverse_id(new_e));

	mov	edx, DWORD PTR _headv$[ebp]
	mov	esi, eax
	mov	ecx, esi
	xor	ecx, 134217728				; 08000000H
	push	ecx
	push	edx
	mov	DWORD PTR _new_e$[ebp], esi
	call	_insert_vertex_edge

; 739  :   set_edge_tailv(new_e,divider);

	mov	eax, DWORD PTR _divider$[ebp]
	push	eax
	push	esi
	call	_set_edge_tailv

; 740  :   set_edge_headv(e_id,divider);

	mov	ecx, DWORD PTR _divider$[ebp]
	push	ecx
	push	edi
	call	_set_edge_headv

; 741  :   set_attr(new_e,NEWEDGE | get_eattr(e_id));

	mov	ecx, DWORD PTR _web+124
	mov	edx, esi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	and	esi, 134217727				; 07ffffffH
	lea	eax, DWORD PTR _web[edx+12]
	add	esi, esi
	add	esi, esi
	mov	DWORD PTR tv4340[ebp], eax
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR tv4344[ebp], esi
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+12]
	or	DWORD PTR [eax+12], ecx
	or	edx, 4
	or	DWORD PTR [eax+8], edx
	add	esp, 36					; 00000024H

; 742  :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	mov	DWORD PTR tv4074[ebp], esi
	je	$LN238@edge_divid

; 743  :   { set_edge_wrap(e_id,wrap1);  /* new vertex in same unit cell as tail */

	test	edi, 134217728				; 08000000H
	je	$LN236@edge_divid
	push	0
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	$LN237@edge_divid
$LN519@edge_divid:

; 641  :   }
; 642  :   else if ( web.modeltype == QUADRATIC )

	fstp	ST(2)

; 700  :       }
; 701  :     }
; 702  :     if ( wrap1 )
; 703  :     { (*sym_wrap)(q1,w,wrap1);
; 704  :       for ( k = 0 ; k < SDIM ; k++ ) q1[k] = w[k];
; 705  :     }
; 706  :   }
; 707  :   else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	$LN566@edge_divid

; 708  :   { oldv = get_edge_vertices(e_id);

	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ecx+304]
	mov	eax, DWORD PTR _web+124
	mov	ebx, edi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	add	edx, DWORD PTR [ebx+eax]

; 709  : 
; 710  :     /* get old vertex coordinates */
; 711  :     for ( i = 0 ; i <= web.lagrange_order ; i++ )

	mov	eax, DWORD PTR _web+632
	xor	ecx, ecx
	mov	DWORD PTR tv4093[ebp], ebx
	mov	DWORD PTR _oldv$[ebp], edx
	test	eax, eax
	js	$LN569@edge_divid

; 708  :   { oldv = get_edge_vertices(e_id);

	lea	ebx, DWORD PTR _prod1$[ebp]
	mov	DWORD PTR tv5784[ebp], ebx

; 713  :       else oldx[i] = h;  /* in case of unwrapping */

	lea	ebx, DWORD PTR _oldx$[ebp]
	sub	edx, ebx
	mov	DWORD PTR tv5810[ebp], edx
	jmp	SHORT $LN138@edge_divid
$LN496@edge_divid:
	mov	edx, DWORD PTR tv5810[ebp]
	fxch	ST(1)
$LN138@edge_divid:

; 712  :     { if ( i < web.lagrange_order ) oldx[i] = get_coord(oldv[i]);

	cmp	ecx, eax
	jge	SHORT $LN135@edge_divid
	mov	ebx, DWORD PTR _web+104
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR _oldx$[ebp+edx]
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ebx+edx+64]
	mov	DWORD PTR _oldx$[ebp+ecx*4], eax
	mov	eax, DWORD PTR _web+632
	jmp	SHORT $LN134@edge_divid
$LN135@edge_divid:

; 713  :       else oldx[i] = h;  /* in case of unwrapping */

	mov	edx, DWORD PTR _h$[ebp]
	mov	DWORD PTR _oldx$[ebp+ecx*4], edx
$LN134@edge_divid:

; 714  :       for ( j = 0, prod1[i] = 1.0 ; j <= web.lagrange_order ; j++ )

	mov	ebx, DWORD PTR tv5784[ebp]
	fxch	ST(1)
	fst	QWORD PTR [ebx]
	xor	edx, edx
	mov	DWORD PTR tv5741[ebp], ecx
$LN133@edge_divid:

; 715  :         if ( i != j )  prod1[i] *= i-j;

	cmp	ecx, edx
	je	SHORT $LN132@edge_divid
	fild	DWORD PTR tv5741[ebp]
	mov	ebx, DWORD PTR tv5784[ebp]
	fmul	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]
$LN132@edge_divid:

; 714  :       for ( j = 0, prod1[i] = 1.0 ; j <= web.lagrange_order ; j++ )

	dec	DWORD PTR tv5741[ebp]
	inc	edx
	cmp	edx, eax
	jle	SHORT $LN133@edge_divid

; 709  : 
; 710  :     /* get old vertex coordinates */
; 711  :     for ( i = 0 ; i <= web.lagrange_order ; i++ )

	add	DWORD PTR tv5784[ebp], 8
	inc	ecx
	cmp	ecx, eax
	jle	$LN496@edge_divid
	mov	ebx, DWORD PTR tv4093[ebp]
	fstp	ST(0)
	jmp	SHORT $LN491@edge_divid
$LN569@edge_divid:
	fstp	ST(1)
$LN491@edge_divid:

; 716  :     }
; 717  : 
; 718  :     /* figure out divider vertex */
; 719  :     for ( k = 0 ; k < SDIM ; k++ ) m[k] = (t[k] + h[k])/2;

	cmp	DWORD PTR _web+616, 0
	jle	SHORT $LN587@edge_divid
	mov	ecx, DWORD PTR _h$[ebp]
	mov	ebx, DWORD PTR _web+616
	lea	edx, DWORD PTR _m$[ebp]
	sub	ecx, esi
	sub	edx, esi
$LN129@edge_divid:
	fld	QWORD PTR [esi+ecx]
	add	esi, 8
	dec	ebx
	fadd	QWORD PTR [esi-8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi+edx-8]
	jne	SHORT $LN129@edge_divid
	mov	ebx, DWORD PTR tv4093[ebp]
$LN587@edge_divid:
	fstp	ST(0)

; 720  :     if ( web.lagrange_order & 1 )  /* odd order */
; 721  :     { divider = new_vertex(m,e_id);

	push	edi
	test	al, 1
	je	SHORT $LN126@edge_divid
	lea	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_new_vertex

; 722  :       set_attr(divider,get_eattr(e_id) & (FIXED|BARE_NAKED));

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _web+124
	mov	ebx, DWORD PTR [ebx+ecx]
	mov	DWORD PTR _divider$[ebp], eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ebx+8]
	and	edx, 65600				; 00010040H
	add	esp, 8
	or	DWORD PTR [eax+8], edx

; 723  :     }
; 724  :     else  /* even order */

	jmp	$LN125@edge_divid
$LN126@edge_divid:

; 725  :     { divider = oldv[web.lagrange_order/2];

	mov	esi, DWORD PTR _oldv$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR [esi+eax*4]

; 726  :       unset_attr(divider,Q_MIDEDGE);

	mov	eax, ecx
	mov	DWORD PTR _divider$[ebp], ecx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx+12]
	and	DWORD PTR [ecx+8], -4194305		; ffbfffffH
	mov	DWORD PTR [ecx+12], edx

; 727  :       set_vertex_edge(divider,NULLID); /* so set_vertex_edge works */

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+ecx]

; 728  :       oldv[web.lagrange_order/2] = new_vertex(NULL,e_id);

	push	0
	mov	DWORD PTR [edx+28], 0
	call	_new_vertex
	mov	ecx, eax
	mov	eax, DWORD PTR _web+632
	cdq
	sub	eax, edx
	add	esp, 8
	sar	eax, 1
	mov	DWORD PTR [esi+eax*4], ecx
	jmp	$LN125@edge_divid

; 743  :   { set_edge_wrap(e_id,wrap1);  /* new vertex in same unit cell as tail */

$LN236@edge_divid:
	xor	eax, eax
$LN237@edge_divid:

; 744  :     set_edge_wrap(new_e,wrap2); 

	test	DWORD PTR _new_e$[ebp], 134217728	; 08000000H
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ecx+784]
	mov	ecx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [edx+ecx], eax
	je	SHORT $LN240@edge_divid
	mov	edx, DWORD PTR _wrap2$[ebp]
	push	edx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN759@edge_divid
$LN240@edge_divid:
	mov	eax, DWORD PTR _wrap2$[ebp]
$LN759@edge_divid:
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv4344[ebp]
	mov	DWORD PTR tv1791[ebp], eax
	mov	eax, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	edx, DWORD PTR tv1791[ebp]
	mov	DWORD PTR [eax+ecx], edx
$LN238@edge_divid:

; 745  :   }
; 746  :   if ( (web.modeltype == LINEAR) && web.metric_flag )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	jne	$LN482@edge_divid
	cmp	DWORD PTR _web+1676, 0
	je	$LN468@edge_divid

; 747  :   { /* get midpoint in metric middle */
; 748  :     REAL front,rear;  /* edge lengths */
; 749  :     REAL tt[MAXCOORD],hh[MAXCOORD];
; 750  :     REAL *xm = get_coord(divider);

	mov	eax, DWORD PTR _web+12
	mov	ebx, DWORD PTR [ebx+eax]
	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	add	ebx, DWORD PTR [ecx+edx+64]
	mov	DWORD PTR _xm$89587[ebp], ebx
$LL122@edge_divid:

; 751  :     for(;;)  /* binary search for reasonable endpoint */ 
; 752  :     {
; 753  :       calc_edge(e_id);

	push	edi
	call	_calc_edge

; 754  :       rear = get_edge_length(e_id);

	push	edi
	call	_get_edge_length
	fstp	QWORD PTR _rear$89584[ebp]

; 755  :       calc_edge(new_e);

	mov	eax, DWORD PTR _new_e$[ebp]
	push	eax
	call	_calc_edge

; 756  :       front = get_edge_length(new_e);

	mov	ecx, DWORD PTR _new_e$[ebp]
	push	ecx
	call	_get_edge_length

; 757  :       if ( rear < 0.8*front )

	fld	QWORD PTR __real@3fe999999999999a
	fmul	ST(0), ST(1)
	add	esp, 16					; 00000010H
	fld	QWORD PTR _rear$89584[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN120@edge_divid

; 758  :       { /* bisect high end */
; 759  :         t = tt;

	lea	edx, DWORD PTR _tt$89585[ebp]
	fstp	ST(1)
	mov	DWORD PTR _t$[ebp], edx
	fstp	ST(0)

; 760  :         for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LL122@edge_divid
	fld	QWORD PTR __real@3fe0000000000000
	mov	eax, ebx
	mov	ebx, DWORD PTR _h$[ebp]
	lea	ecx, DWORD PTR _tt$89585[ebp]
	sub	ecx, ebx
	mov	DWORD PTR tv6043[ebp], ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR _xm$89587[ebp]
	mov	ebx, DWORD PTR tv6043[ebp]
	mov	DWORD PTR tv5951[ebp], ecx
	jmp	SHORT $LN119@edge_divid
$LN485@edge_divid:
	mov	ecx, DWORD PTR tv5951[ebp]
$LN119@edge_divid:

; 761  :         { t[i] = xm[i];

	fld	QWORD PTR [eax]
	add	ecx, eax
	fst	QWORD PTR [ebx+ecx]
	inc	edx

; 762  :           xm[i] = (t[i] + h[i])/2;

	fadd	QWORD PTR [ecx]
	add	eax, 8
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LN485@edge_divid

; 763  :         }
; 764  :       }
; 765  :       else if ( rear > 1.2*front )

	mov	ebx, DWORD PTR _xm$89587[ebp]
	fstp	ST(0)
	jmp	$LL122@edge_divid
$LN120@edge_divid:
	fxch	ST(1)
	fmul	QWORD PTR __real@3ff3333333333333
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN465@edge_divid

; 766  :       { /* bisect low end */
; 767  :         h = hh;
; 768  :         for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	lea	eax, DWORD PTR _hh$89586[ebp]
	mov	DWORD PTR _h$[ebp], eax
	cmp	DWORD PTR _web+616, edx
	jle	$LL122@edge_divid
	fld	QWORD PTR __real@3fe0000000000000
	mov	eax, ebx
	mov	ebx, DWORD PTR _t$[ebp]
	lea	ecx, DWORD PTR _hh$89586[ebp]
	sub	ecx, ebx
	mov	DWORD PTR tv6046[ebp], ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR _xm$89587[ebp]
	mov	ebx, DWORD PTR tv6046[ebp]
	mov	DWORD PTR tv6022[ebp], ecx
	jmp	SHORT $LN114@edge_divid
$LN484@edge_divid:
	mov	ecx, DWORD PTR tv6022[ebp]
$LN114@edge_divid:

; 769  :         { h[i] = xm[i];

	fld	QWORD PTR [eax]
	add	ecx, eax
	fst	QWORD PTR [ebx+ecx]
	inc	edx

; 770  :           xm[i] = (t[i] + h[i])/2;

	fadd	QWORD PTR [ecx]
	add	eax, 8
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LN484@edge_divid

; 771  :         }
; 772  :       }
; 773  :       else break;
; 774  :     } 

	mov	ebx, DWORD PTR _xm$89587[ebp]
	fstp	ST(0)
	jmp	$LL122@edge_divid
$LN465@edge_divid:
	mov	eax, DWORD PTR _web+628
$LN482@edge_divid:

; 775  :   }
; 776  : 
; 777  :      
; 778  :   if ( web.modeltype == QUADRATIC )

	cmp	eax, 2
	jne	$LN110@edge_divid

; 779  :   { /* new midpoint for old edge */
; 780  :     old_mid = new_vertex(q1,e_id);

	lea	ecx, DWORD PTR _q1$[ebp]
	push	edi
	push	ecx
	call	_new_vertex

; 781  :     set_edge_midv(e_id,old_mid);

	mov	edx, DWORD PTR _web+216
	mov	ecx, eax
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+304]
	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [edx+eax+8], ecx
	mov	edx, DWORD PTR _web+12
	mov	eax, ecx
	mov	DWORD PTR _old_mid$[ebp], ecx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [edx+28], edi
	lea	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax]
	or	DWORD PTR [ecx+8], 131072		; 00020000H
	mov	edi, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+12], edi

; 782  :     set_attr(old_mid,get_eattr(e_id) & (FIXED|BARE_NAKED));

	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
	mov	eax, DWORD PTR [edx+eax]
	mov	ecx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 65600				; 00010040H
	or	DWORD PTR [eax+8], edx
	xor	edi, edi
	or	DWORD PTR [eax+12], edi

; 783  : 
; 784  :     /* set up midpoint of new edge */
; 785  :     new_mid = get_edge_midv(new_e);

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR tv4344[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR _dymem
	mov	ebx, DWORD PTR _web+216
	mov	eax, DWORD PTR [ebx+eax+304]
	mov	ecx, DWORD PTR [ecx+eax+8]

; 786  :     set_attr(new_mid,get_eattr(e_id) & (FIXED|BARE_NAKED));

	mov	edx, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [edx+8]
	mov	eax, ecx
	mov	DWORD PTR _new_mid$[ebp], ecx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [ecx+eax]
	or	DWORD PTR [ecx+12], edi
	and	edx, 65600				; 00010040H
	or	DWORD PTR [ecx+8], edx

; 787  :     mv = get_coord(new_mid);

	mov	ecx, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+64]
	add	esp, 8

; 788  :     for ( k = 0 ; k < SDIM ; k++ ) mv[k] = q3[k];

	xor	edx, edx
	cmp	DWORD PTR _web+616, edi
	jle	SHORT $LN469@edge_divid
	lea	ecx, DWORD PTR _q3$[ebp]
	sub	ecx, eax
	npad	7
$LL109@edge_divid:
	fld	QWORD PTR [ecx+eax]
	inc	edx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL109@edge_divid
$LN468@edge_divid:

; 829  :     }
; 830  :     else

	mov	ecx, DWORD PTR _dymem
$LN469@edge_divid:

; 789  : 
; 790  :   }
; 791  :   else if ( web.modeltype == LAGRANGE )

	mov	ebx, DWORD PTR _web+632
$LN760@edge_divid:
	fld	QWORD PTR __real@3fe0000000000000
$LN85@edge_divid:

; 843  :       }
; 844  :     }
; 845  :   }
; 846  : 
; 847  :   /* for free boundary edges, cannot just interpolate parameters
; 848  :      due to wrap-around of periodic parameters. So tangent extrapolate
; 849  :      from one endpoint.
; 850  :    */
; 851  :   if ( get_eattr(e_id) & BOUNDARY )

	mov	eax, DWORD PTR _web+124
	mov	esi, DWORD PTR [eax+esi*4]
	mov	edi, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+12]
	mov	eax, edi
	mov	DWORD PTR tv4142[ebp+4], edx
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	$LN608@edge_divid

; 852  :   { struct boundary *bdry;
; 853  :     REAL *parammid;
; 854  :     REAL  defaultp[MAXCOORD];
; 855  :     REAL *parama=NULL; /* tail */
; 856  :     REAL *paramb=NULL; /* head */
; 857  : 
; 858  :     bdry = get_edge_boundary(e_id);

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	mov	DWORD PTR _parama$89687[ebp], edx
	mov	DWORD PTR _paramb$89689[ebp], edx
	cmp	eax, edx
	je	$LN188@edge_divid
	mov	edx, DWORD PTR tv4074[ebp]
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR _web+124
	mov	edx, DWORD PTR [eax+edx*4]
	mov	edi, DWORD PTR [edx+ecx]

; 859  :     set_edge_boundary_num(new_e,bdry->num);

	mov	edx, DWORD PTR tv4344[ebp]
	imul	edi, 136				; 00000088H
	add	edi, DWORD PTR _web+776
	mov	eax, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [edi+44]
	mov	DWORD PTR [ecx+eax], edx
	mov	ebx, DWORD PTR _web+632
	mov	ecx, DWORD PTR _dymem
$LN190@edge_divid:

; 860  : 
; 861  : 
; 862  :     if ( get_boundary(tailv) == bdry )

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	$LN192@edge_divid
	mov	edx, DWORD PTR tv4076[ebp]
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR _web+12
	mov	edx, DWORD PTR [esi+edx*4]
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	edx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	imul	edx, 136				; 00000088H
	add	edx, DWORD PTR _web+776
	jmp	$LN193@edge_divid
$LN110@edge_divid:

; 789  : 
; 790  :   }
; 791  :   else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	$LN468@edge_divid

; 792  :   { /* calculate new vertex coordinates */
; 793  : 
; 794  :     /* get vertices in right order */
; 795  :     newv = get_edge_vertices(new_e);

	mov	eax, DWORD PTR tv4344[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]

; 796  :     for ( n = 0 ; n < web.lagrange_order ; n++ )

	mov	ebx, DWORD PTR _web+632
	xor	eax, eax
	mov	DWORD PTR _newv$[ebp], edx
	test	ebx, ebx
	jle	SHORT $LN102@edge_divid

; 797  :     { allv[2*n] = oldv[n];

	mov	esi, DWORD PTR _oldv$[ebp]
	sub	esi, edx
	mov	DWORD PTR tv6105[ebp], edx
	mov	DWORD PTR tv6121[ebp], esi
	jmp	SHORT $LN104@edge_divid
$LL480@edge_divid:
	mov	esi, DWORD PTR tv6121[ebp]
$LN104@edge_divid:
	mov	esi, DWORD PTR [esi+edx]
	mov	DWORD PTR _allv$[ebp+eax*8], esi

; 798  :       allv[2*n+1] = newv[n];

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR _allv$[ebp+eax*8+4], esi
	inc	eax
	add	edx, 4
	cmp	eax, ebx
	jl	SHORT $LL480@edge_divid

; 796  :     for ( n = 0 ; n < web.lagrange_order ; n++ )

	mov	edx, DWORD PTR _newv$[ebp]
$LN102@edge_divid:

; 799  :     }
; 800  :     allv[2*n] = newv[n]; /* last one */

	mov	esi, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _allv$[ebp+eax*8], esi

; 801  : 
; 802  :     /* get divider back into order */
; 803  :     allv[1] = allv[web.lagrange_order];

	mov	eax, DWORD PTR _allv$[ebp+ebx*4]
	mov	DWORD PTR _allv$[ebp+4], eax

; 804  :     allv[web.lagrange_order] = divider;

	mov	eax, DWORD PTR _divider$[ebp]

; 805  :      
; 806  :     for ( n = 1 ; n < web.lagrange_order ; n++ )

	mov	esi, 1
	mov	DWORD PTR _allv$[ebp+ebx*4], eax
	cmp	ebx, esi
	jle	$LN99@edge_divid
	mov	ecx, DWORD PTR _oldv$[ebp]
	lea	ebx, DWORD PTR _allv$[ebp]
	sub	ebx, ecx
	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR tv6235[ebp], ebx
	sub	edx, ecx
$LL101@edge_divid:

; 807  :     {
; 808  :       oldv[n] = allv[n];

	mov	ecx, DWORD PTR tv6235[ebp]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	DWORD PTR [eax], ecx

; 809  :       newv[n] = allv[web.lagrange_order + n];

	mov	ecx, DWORD PTR _web+632
	add	ecx, esi
	mov	ecx, DWORD PTR _allv$[ebp+ecx*4]
	mov	DWORD PTR [edx+eax], ecx

; 810  :       set_vertex_edge(oldv[n],e_id);

	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR [ecx+28], edi

; 811  :       set_vertex_edge(newv[n],new_e);

	mov	ecx, DWORD PTR [edx+eax]
	mov	ebx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _new_e$[ebp]
	mov	DWORD PTR [ecx+28], ebx

; 812  :       set_attr(oldv[n],Q_MIDEDGE);

	mov	ecx, DWORD PTR [eax]
	mov	ebx, ecx
	shr	ebx, 29					; 0000001dH
	imul	ebx, 112				; 00000070H
	mov	ebx, DWORD PTR _web[ebx+12]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	or	DWORD PTR [ecx+8], 4194304		; 00400000H
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+12], ebx

; 813  :       set_attr(newv[n],Q_MIDEDGE);

	mov	ecx, DWORD PTR [edx+eax]
	mov	ebx, ecx
	shr	ebx, 29					; 0000001dH
	imul	ebx, 112				; 00000070H
	mov	ebx, DWORD PTR _web[ebx+12]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 4194304		; 00400000H
	mov	DWORD PTR [ecx+12], ebx
	mov	ebx, DWORD PTR _web+632
	inc	esi
	add	eax, 4
	cmp	esi, ebx
	jl	$LL101@edge_divid

; 805  :      
; 806  :     for ( n = 1 ; n < web.lagrange_order ; n++ )

	mov	ecx, DWORD PTR _dymem
$LN99@edge_divid:

; 814  :     }
; 815  : 
; 816  :     /* set coordinates of new vertices */
; 817  :     if ( bezier_flag )

	cmp	DWORD PTR _bezier_flag, 0
	je	$LN98@edge_divid

; 818  :     { 
; 819  :       /* have to change all control points */
; 820  :       MAT2D(oldc,MAXLAGRANGE+1,MAXCOORD);

	push	6
	push	21					; 00000015H
	lea	edx, DWORD PTR _oldcxJ$89641[ebp]
	push	edx
	lea	eax, DWORD PTR _oldcqXvS$89640[ebp]
	push	eax
	call	_mat2d_setup

; 821  :       REAL *newx[2*MAXLAGRANGE+1];
; 822  :       for ( i = 0 ; i <= web.lagrange_order ; i++ )

	mov	esi, DWORD PTR _web+632
	add	esp, 16					; 00000010H
	xor	ebx, ebx
	mov	DWORD PTR _oldc$89642[ebp], eax
	test	esi, esi
	js	SHORT $LN466@edge_divid
	mov	edi, eax
	lea	eax, DWORD PTR _oldx$[ebp]
	sub	eax, edi
$LL97@edge_divid:

; 823  :         for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN96@edge_divid
	mov	ecx, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax+edi]
	sub	esi, ecx
$LL502@edge_divid:

; 824  :           oldc[i][j] = oldx[i][j]; 

	fld	QWORD PTR [esi+ecx]
	inc	edx
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL502@edge_divid

; 823  :         for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _web+632
$LN96@edge_divid:

; 821  :       REAL *newx[2*MAXLAGRANGE+1];
; 822  :       for ( i = 0 ; i <= web.lagrange_order ; i++ )

	inc	ebx
	add	edi, 4
	cmp	ebx, esi
	jle	SHORT $LL97@edge_divid
$LN466@edge_divid:

; 825  :       for ( i = 0 ; i <= 2*web.lagrange_order ; i++ )

	lea	edx, DWORD PTR [esi+esi]
	xor	ecx, ecx
	test	edx, edx
	js	SHORT $LN504@edge_divid
	mov	eax, DWORD PTR _web+104
$LL495@edge_divid:

; 826  :         newx[i] = get_coord(allv[i]);

	mov	edi, DWORD PTR _allv$[ebp+ecx*4]
	mov	ebx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR _dymem
	add	edi, DWORD PTR [eax+ebx+64]
	inc	ecx
	mov	DWORD PTR _newx$89644[ebp+ecx*4-4], edi
	cmp	ecx, edx
	jle	SHORT $LL495@edge_divid
$LN504@edge_divid:

; 827  :       mat_mult(bezier_refine_1d[web.lagrange_order],oldc,newx,
; 828  :          2*web.lagrange_order+1,web.lagrange_order+1,SDIM); 

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	eax, DWORD PTR [esi+1]
	push	eax
	mov	eax, DWORD PTR _bezier_refine_1d[esi*4]
	inc	edx
	push	edx
	mov	edx, DWORD PTR _oldc$89642[ebp]
	lea	ecx, DWORD PTR _newx$89644[ebp]
	push	ecx
	push	edx
	push	eax
	call	_mat_mult

; 829  :     }
; 830  :     else

	mov	esi, DWORD PTR tv4074[ebp]
	add	esp, 24					; 00000018H
	jmp	$LN468@edge_divid
$LN98@edge_divid:

; 831  :     for ( n = 0 ; n < web.lagrange_order ; n++ )

	mov	DWORD PTR _n$[ebp], 0
	test	ebx, ebx
	jle	$LN467@edge_divid
	fld1
	mov	esi, DWORD PTR _web+616
	fldz
	fld	QWORD PTR __real@3fe0000000000000
$LN87@edge_divid:

; 832  :     { REAL coeff;
; 833  :       REAL x;
; 834  :       REAL *newx = get_coord(allv[2*n+1]);

	mov	edx, DWORD PTR _n$[ebp]

; 835  :       x = n + 0.5;

	fild	DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _allv$[ebp+edx*8+4]
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	fadd	ST(0), ST(1)
	mov	edi, DWORD PTR [edx+eax*4]

; 836  :       for ( j = 0, prod2 = 1.0 ; j <= web.lagrange_order ; j++ )

	fld	ST(3)
	mov	eax, DWORD PTR _web+104
	add	edi, DWORD PTR [eax+ecx+64]
	xor	eax, eax
	mov	DWORD PTR _j$[ebp], eax
	test	ebx, ebx
	js	SHORT $LN489@edge_divid
$LN84@edge_divid:

; 837  :          prod2 *= x - j;

	fild	DWORD PTR _j$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	fsubr	ST(0), ST(2)
	fmulp	ST(1), ST(0)
	cmp	eax, ebx
	jle	SHORT $LN84@edge_divid
$LN489@edge_divid:

; 838  :       for ( k = 0 ; k < SDIM ; k++ ) newx[k] = 0.0;

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN79@edge_divid
$LN81@edge_divid:
	fxch	ST(3)
	inc	eax
	fst	QWORD PTR [edi+eax*8-8]
	mov	esi, DWORD PTR _web+616
	fxch	ST(3)
	cmp	eax, esi
	jl	SHORT $LN81@edge_divid
	mov	ebx, DWORD PTR _web+632
	mov	ecx, DWORD PTR _dymem
$LN79@edge_divid:

; 839  :       for ( i = 0 ; i <= web.lagrange_order ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	ebx, ebx
	js	SHORT $LN745@edge_divid
$LN78@edge_divid:

; 840  :       { coeff = prod2/(x-i)/prod1[i];

	fild	DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	fsubr	ST(0), ST(2)
	fdivr	ST(0), ST(1)
	fdiv	QWORD PTR _prod1$[ebp+ecx*8]

; 841  :         for ( k = 0 ; k < SDIM ; k++ )

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN748@edge_divid
	mov	edx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _oldx$[ebp+edx*4]
	mov	eax, edi
	sub	edx, edi
$LN75@edge_divid:

; 842  :            newx[k] += coeff*oldx[i][k];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	esi, DWORD PTR _web+616
	cmp	ecx, esi
	jl	SHORT $LN75@edge_divid

; 841  :         for ( k = 0 ; k < SDIM ; k++ )

	mov	ebx, DWORD PTR _web+632
$LN748@edge_divid:

; 839  :       for ( i = 0 ; i <= web.lagrange_order ; i++ )

	mov	eax, DWORD PTR _i$[ebp]

; 841  :         for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, ebx
	jle	SHORT $LN78@edge_divid

; 839  :       for ( i = 0 ; i <= web.lagrange_order ; i++ )

	mov	ecx, DWORD PTR _dymem
$LN745@edge_divid:

; 831  :     for ( n = 0 ; n < web.lagrange_order ; n++ )

	mov	eax, DWORD PTR _n$[ebp]

; 839  :       for ( i = 0 ; i <= web.lagrange_order ; i++ )

	fstp	ST(0)
	inc	eax
	fstp	ST(0)
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, ebx
	jl	$LN87@edge_divid

; 831  :     for ( n = 0 ; n < web.lagrange_order ; n++ )

	mov	esi, DWORD PTR tv4074[ebp]
	fstp	ST(2)
	fstp	ST(0)
	jmp	$LN85@edge_divid
$LN467@edge_divid:
	mov	esi, DWORD PTR tv4074[ebp]
	jmp	$LN760@edge_divid
$LN188@edge_divid:

; 852  :   { struct boundary *bdry;
; 853  :     REAL *parammid;
; 854  :     REAL  defaultp[MAXCOORD];
; 855  :     REAL *parama=NULL; /* tail */
; 856  :     REAL *paramb=NULL; /* head */
; 857  : 
; 858  :     bdry = get_edge_boundary(e_id);

	xor	edi, edi

; 859  :     set_edge_boundary_num(new_e,bdry->num);

	jmp	$LN190@edge_divid
$LN192@edge_divid:

; 860  : 
; 861  : 
; 862  :     if ( get_boundary(tailv) == bdry )

	xor	edx, edx
$LN193@edge_divid:
	cmp	edx, edi
	jne	SHORT $LN71@edge_divid

; 863  :       parama = get_param(tailv);

	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ecx+544]
	mov	edx, DWORD PTR tv4076[ebp]
	mov	esi, DWORD PTR _web+12
	add	eax, DWORD PTR [esi+edx*4]
	mov	DWORD PTR _parama$89687[ebp], eax
	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	jmp	$LN474@edge_divid
$LN71@edge_divid:

; 864  :     else if ( extra_bdry_attr && extra_bdry_param_attr)

	cmp	DWORD PTR _extra_bdry_attr, 0
	je	$LN474@edge_divid
	cmp	DWORD PTR _extra_bdry_param_attr, 0
	je	$LN474@edge_divid

; 865  :     { int bnum = *(int*)get_extra(tailv,extra_bdry_attr);

	mov	edx, DWORD PTR _tailv$[ebp]
	mov	esi, DWORD PTR tv4076[ebp]
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	DWORD PTR tv4623[ebp], edx
	mov	edx, DWORD PTR _web[edx+12]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR _extra_bdry_attr
	imul	esi, 240				; 000000f0H
	mov	DWORD PTR tv4629[ebp], edx
	mov	edx, DWORD PTR tv4623[ebp]
	mov	edx, DWORD PTR _web[edx+104]
	add	esi, edx
	mov	DWORD PTR tv4632[ebp], edx

; 866  :       if ( bnum == bdry->num )

	mov	edx, DWORD PTR [esi+ecx+64]
	mov	esi, DWORD PTR tv4629[ebp]
	mov	edx, DWORD PTR [esi+edx]
	cmp	edx, DWORD PTR [edi+44]
	jne	SHORT $LN474@edge_divid

; 867  :          parama = (REAL*)get_extra(tailv,extra_bdry_param_attr);

	mov	edx, DWORD PTR _extra_bdry_param_attr
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR tv4632[ebp]
	mov	edx, DWORD PTR [edx+ecx+64]
	add	edx, esi
	mov	DWORD PTR _parama$89687[ebp], edx
$LN474@edge_divid:

; 868  :     }
; 869  :     
; 870  :     if ( get_boundary(headv) == bdry )

	test	eax, eax
	je	SHORT $LN194@edge_divid
	mov	edx, DWORD PTR tv4086[ebp]
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	eax, DWORD PTR [eax+edx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN195@edge_divid
$LN194@edge_divid:
	xor	eax, eax
$LN195@edge_divid:
	cmp	eax, edi
	jne	SHORT $LN67@edge_divid

; 871  :         paramb = get_param(headv);

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR [eax+ecx+544]
	mov	edx, DWORD PTR tv4086[ebp]
	mov	eax, DWORD PTR _web+12
	add	ecx, DWORD PTR [eax+edx*4]

; 872  :     else if ( extra_bdry_attr && extra_bdry_param_attr &&

	jmp	SHORT $LN761@edge_divid
$LN67@edge_divid:

; 873  :            (*(int*)get_extra(headv,extra_bdry_attr) == bdry->num) )

	cmp	DWORD PTR _extra_bdry_attr, 0
	je	SHORT $LN475@edge_divid
	cmp	DWORD PTR _extra_bdry_param_attr, 0
	je	SHORT $LN475@edge_divid
	mov	eax, DWORD PTR _headv$[ebp]
	mov	esi, DWORD PTR tv4086[ebp]
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	mov	esi, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _extra_bdry_attr
	mov	eax, DWORD PTR _web[eax+104]
	imul	edx, 240				; 000000f0H
	add	edx, eax
	mov	edx, DWORD PTR [edx+ecx+64]
	mov	edx, DWORD PTR [esi+edx]
	cmp	edx, DWORD PTR [edi+44]
	jne	SHORT $LN475@edge_divid

; 874  :         paramb = (REAL*)get_extra(headv,extra_bdry_param_attr);

	mov	edx, DWORD PTR _extra_bdry_param_attr
	imul	edx, 240				; 000000f0H
	add	edx, eax
	mov	ecx, DWORD PTR [edx+ecx+64]
	add	ecx, esi
$LN761@edge_divid:
	mov	DWORD PTR _paramb$89689[ebp], ecx
$LN475@edge_divid:

; 875  : 
; 876  : 
; 877  :     if ( (web.modeltype == LINEAR) || 
; 878  :          ((web.modeltype==LAGRANGE) && (web.lagrange_order == 1)) )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	je	$LN63@edge_divid
	cmp	eax, 3
	jne	$LN64@edge_divid
	cmp	ebx, 1
	je	$LN63@edge_divid

; 973  :     }
; 974  :     else if ( web.modeltype == LAGRANGE )
; 975  :     { set_attr(divider,BOUNDARY);

	mov	eax, DWORD PTR tv4129[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR tv4133[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 128			; 00000080H
	mov	DWORD PTR [ecx+12], eax

; 976  :       set_boundary_num(divider,bdry->num);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN210@edge_divid
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [edi+44]
	mov	DWORD PTR [eax+edx], ecx
$LN210@edge_divid:

; 977  :       oldv = get_edge_vertices(e_id);
; 978  :       newv = get_edge_vertices(new_e);
; 979  : 
; 980  :       /* calculate new parameter values */
; 981  :       if ( interp_bdry_param && parama && paramb )

	cmp	DWORD PTR _interp_bdry_param, 0
	je	$LN650@edge_divid
	cmp	DWORD PTR _parama$89687[ebp], 0
	je	$LN650@edge_divid
	cmp	DWORD PTR _paramb$89689[ebp], 0
	je	$LN650@edge_divid

; 982  :       { 
; 983  :          for ( i = 1; i < 2*web.lagrange_order ; i += 2 ) /* tail half */

	mov	edx, DWORD PTR _web+632
	mov	ecx, 1
	add	edx, edx
	mov	DWORD PTR _i$[ebp], ecx
	mov	DWORD PTR tv4528[ebp], edx
	cmp	edx, ecx
	jle	$LN719@edge_divid
	mov	esi, DWORD PTR [edi+40]
	mov	eax, DWORD PTR _web+104
$LN35@edge_divid:

; 984  :          { REAL *pa = (i==1) ? parama : get_param(allv[i-1]);

	cmp	ecx, 1
	jne	$LN212@edge_divid
	mov	ebx, DWORD PTR _parama$89687[ebp]
	mov	DWORD PTR _pa$89860[ebp], ebx
	jmp	$LN213@edge_divid
$LN64@edge_divid:

; 933  :       }
; 934  :     }  /* end linear */
; 935  :     else if ( web.modeltype == QUADRATIC )

	cmp	eax, 2
	jne	$LN719@edge_divid

; 936  :     { REAL *paramc; 
; 937  :       set_attr(old_mid,BOUNDARY);

	mov	ecx, DWORD PTR _old_mid$[ebp]
	mov	eax, ecx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx+12]
	mov	esi, 128				; 00000080H
	or	DWORD PTR [ecx+8], esi
	mov	DWORD PTR [ecx+12], edx

; 938  :       set_boundary_num(old_mid,bdry->num);

	mov	ecx, DWORD PTR _V_BOUNDARY_ATTR
	test	ecx, ecx
	je	SHORT $LN206@edge_divid
	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+104
	mov	ebx, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR [ecx+edx+64]
	mov	edx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [ecx+edx], ebx
$LN206@edge_divid:

; 939  :       set_attr(new_mid,BOUNDARY);

	mov	edx, DWORD PTR _new_mid$[ebp]
	mov	ecx, edx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [edx+ecx]
	or	DWORD PTR [edx+8], esi
	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+12], esi

; 940  :       set_boundary_num(new_mid,bdry->num);

	mov	edx, DWORD PTR _V_BOUNDARY_ATTR
	mov	DWORD PTR tv4425[ebp], ecx
	test	edx, edx
	je	SHORT $LN208@edge_divid
	mov	esi, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+esi+64]
	mov	esi, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ecx+esi]
	mov	esi, DWORD PTR [edi+44]
	mov	DWORD PTR [edx+ecx], esi
$LN208@edge_divid:

; 941  : 
; 942  :       paramc = get_param(divider);

	mov	edx, DWORD PTR tv4133[ebp]
	mov	ecx, DWORD PTR _web+12
	mov	ebx, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR [ecx+edx+544]
	mov	DWORD PTR tv4708[ebp], ebx
	add	ebx, esi

; 943  : 
; 944  :       if ( interp_bdry_param && parama )

	cmp	DWORD PTR _interp_bdry_param, 0
	mov	DWORD PTR tv4620[ebp], esi
	je	SHORT $LN686@edge_divid
	cmp	DWORD PTR _parama$89687[ebp], 0
	je	SHORT $LN686@edge_divid

; 945  :       { 
; 946  :         parammid = get_param(old_mid);             

	mov	esi, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+esi]
	add	eax, DWORD PTR tv4620[ebp]

; 947  :         for ( i = 0 ; i < bdry->pcount ; i++ )

	xor	esi, esi
	mov	DWORD PTR _parammid$89685[ebp], eax
	cmp	DWORD PTR [edi+40], esi
	jle	SHORT $LN476@edge_divid
	mov	ecx, DWORD PTR _parama$89687[ebp]
	mov	edx, DWORD PTR _parammid$89685[ebp]
	sub	ecx, ebx
	mov	eax, ebx
	sub	edx, ebx
$LN47@edge_divid:

; 948  :           parammid[i] = (parama[i] + paramc[i])/2;

	fld	QWORD PTR [ecx+eax]
	inc	esi
	fadd	QWORD PTR [eax]
	add	eax, 8
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx+eax-8]
	cmp	esi, DWORD PTR [edi+40]
	jl	SHORT $LN47@edge_divid

; 949  :       }
; 950  :       else

	jmp	SHORT $LN762@edge_divid
$LN686@edge_divid:

; 951  :       { mu = get_coord(divider);

	mov	ecx, DWORD PTR [ecx+edx+64]
	fstp	ST(0)

; 952  : 
; 953  :         /* find new parameters of old edge midpoint */
; 954  :         /* projecting on tangent */
; 955  :         parammid = get_param(old_mid);             
; 956  :         mv = get_coord(old_mid);

	mov	esi, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+esi]
	mov	edx, DWORD PTR tv4708[ebp]

; 957  :         b_extrapolate(bdry,mu,mv,mv,paramc,parammid,old_mid);

	mov	esi, DWORD PTR _old_mid$[ebp]
	add	edx, ecx
	add	ecx, eax
	add	eax, DWORD PTR tv4620[ebp]
	push	esi
	push	eax
	push	ebx
	push	ecx
	push	ecx
	push	edx
	push	edi
	mov	DWORD PTR _mu$[ebp], edx
	call	_b_extrapolate
	fld	QWORD PTR __real@3fe0000000000000
	add	esp, 28					; 0000001cH
$LN762@edge_divid:
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
$LN476@edge_divid:

; 958  :       }
; 959  :       if ( interp_bdry_param && paramb )

	cmp	DWORD PTR _interp_bdry_param, 0
	je	SHORT $LN698@edge_divid
	cmp	DWORD PTR _paramb$89689[ebp], 0
	je	SHORT $LN698@edge_divid

; 960  :       {
; 961  :         parammid = get_param(new_mid);             

	mov	eax, DWORD PTR tv4425[ebp]
	mov	esi, DWORD PTR _web+12
	mov	esi, DWORD PTR [eax+esi]
	add	esi, DWORD PTR [ecx+edx+544]

; 962  :         for ( i = 0 ; i < bdry->pcount ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR [edi+40], ecx
	jle	SHORT $LN719@edge_divid
	mov	edx, DWORD PTR _paramb$89689[ebp]
	sub	edx, ebx
	mov	eax, ebx
	sub	esi, ebx
$LN42@edge_divid:

; 963  :           parammid[i] = (paramb[i] + paramc[i])/2;

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax+esi-8]
	cmp	ecx, DWORD PTR [edi+40]
	jl	SHORT $LN42@edge_divid
$LN719@edge_divid:

; 886  :       { for (  i = 0 ; i < bdry->pcount ; i++ )

	fstp	ST(0)
$LN470@edge_divid:

; 1024 :       }
; 1025 :       /* this should have been taken care of for Lagrange in dup_edge */
; 1026 :     }
; 1027 :   }
; 1028 : 
; 1029 :   old_fe = first_fe = get_edge_fe(e_id);

	mov	eax, DWORD PTR tv4074[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	jne	$LN279@edge_divid
	mov	DWORD PTR _first_fe$[ebp], eax
	jmp	$LN280@edge_divid
$LN698@edge_divid:

; 964  :       }
; 965  :       else
; 966  :       {
; 967  :         /* find parameters of new edge midpoint */
; 968  :         /* projecting on tangent */
; 969  :         parammid = get_param(new_mid);             
; 970  :         mv = get_coord(new_mid);

	mov	eax, DWORD PTR tv4425[ebp]
	fstp	ST(0)
	mov	esi, DWORD PTR _web+12
	mov	esi, DWORD PTR [eax+esi]
	mov	eax, DWORD PTR [ecx+edx+64]
	mov	ecx, DWORD PTR [ecx+edx+544]

; 971  :         b_extrapolate(bdry,mu,mv,mv,paramc,parammid,new_mid);

	mov	edx, DWORD PTR _mu$[ebp]
	add	eax, esi
	mov	DWORD PTR tv4746[ebp], esi
	mov	esi, DWORD PTR _new_mid$[ebp]
	add	ecx, DWORD PTR tv4746[ebp]
	push	esi
	push	ecx
	push	ebx
	push	eax
	push	eax
	push	edx
	push	edi
	call	_b_extrapolate
	add	esp, 28					; 0000001cH

; 972  :       }

	jmp	SHORT $LN470@edge_divid
$LN212@edge_divid:

; 984  :          { REAL *pa = (i==1) ? parama : get_param(allv[i-1]);

	mov	edx, DWORD PTR _allv$[ebp+ecx*4-4]
	mov	ebx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ebx+544]
	mov	DWORD PTR _pa$89860[ebp], edx
	mov	edx, DWORD PTR tv4528[ebp]
$LN213@edge_divid:

; 985  :            REAL *pb = (i==2*web.lagrange_order-1)? get_param(allv[1])
; 986  :                               : paramb;

	dec	edx
	cmp	ecx, edx
	jne	SHORT $LN214@edge_divid
	mov	edx, DWORD PTR _allv$[ebp+4]
	mov	ebx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR _dymem
	add	ebx, DWORD PTR [eax+edx+544]
	jmp	SHORT $LN215@edge_divid
$LN214@edge_divid:
	mov	ebx, DWORD PTR _paramb$89689[ebp]
$LN215@edge_divid:

; 987  :            REAL *p  = get_param(allv[i]);

	mov	ecx, DWORD PTR _allv$[ebp+ecx*4]
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+544]

; 988  :            for (  k = 0 ; k < bdry->pcount ; k++ )

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN490@edge_divid
	mov	eax, DWORD PTR _pa$89860[ebp]
	sub	ebx, eax
	sub	edx, eax
$LN486@edge_divid:

; 989  :                p[k] = (pa[k] + pb[k])/2;

	fld	QWORD PTR [ebx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx+eax-8]
	mov	esi, DWORD PTR [edi+40]
	cmp	ecx, esi
	jl	SHORT $LN486@edge_divid

; 988  :            for (  k = 0 ; k < bdry->pcount ; k++ )

	mov	eax, DWORD PTR _web+104
$LN490@edge_divid:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _web+632
	add	ecx, 2
	add	edx, edx
	mov	DWORD PTR _i$[ebp], ecx
	mov	DWORD PTR tv4528[ebp], edx
	cmp	ecx, edx
	jl	$LN35@edge_divid

; 990  :          }
; 991  :       }
; 992  :       else /* interpolate */

	jmp	$LN719@edge_divid
$LN650@edge_divid:

; 993  :       { oldv = get_edge_vertices(e_id);
; 994  :         for ( i = 1; i < 2*web.lagrange_order ; i += 2 )

	mov	edx, DWORD PTR _web+632
	fstp	ST(0)
	mov	esi, 1
	lea	eax, DWORD PTR [edx+edx]
	cmp	eax, esi
	jle	$LN470@edge_divid
	npad	9
$LL473@edge_divid:

; 995  :         { REAL *pa = get_param(allv[i-1]);
; 996  :           REAL *p  = get_param(allv[i]);
; 997  :           mu = get_coord(allv[i-1]);             
; 998  :           mv = get_coord(allv[i]);

	mov	eax, DWORD PTR _allv$[ebp+esi*4]
	mov	edx, DWORD PTR _web+12
	mov	ebx, DWORD PTR _web+104
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ebx+edx+64]
	mov	DWORD PTR tv4809[ebp], ebx
	add	ebx, ecx
	mov	DWORD PTR _mv$[ebp], ebx
	mov	ebx, DWORD PTR _web+104
	mov	edx, DWORD PTR [ebx+edx+544]
	mov	ebx, DWORD PTR _web+12

; 999  :           b_extrapolate(bdry,mu,mv,mv,pa,p,allv[i]);

	push	eax
	mov	DWORD PTR tv4812[ebp], edx
	mov	edx, DWORD PTR _allv$[ebp+esi*4-4]
	mov	eax, DWORD PTR tv4812[ebp]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	add	ecx, eax
	push	ecx
	add	eax, edx
	add	edx, DWORD PTR tv4809[ebp]
	push	eax
	mov	eax, DWORD PTR _mv$[ebp]
	push	eax
	push	eax
	push	edx
	push	edi
	call	_b_extrapolate
	mov	edx, DWORD PTR _web+632
	add	esi, 2
	lea	eax, DWORD PTR [edx+edx]
	add	esp, 28					; 0000001cH
	cmp	esi, eax
	jl	$LL473@edge_divid

; 637  :   { 
; 638  :     for ( k = 0 ; k < SDIM ; k++ ) m[k] = (t[k] + h[k])/2;

	jmp	$LN470@edge_divid
$LN63@edge_divid:

; 879  :     { set_attr(divider,BOUNDARY);

	mov	ecx, DWORD PTR tv4129[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR tv4133[ebp]
	mov	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 128			; 00000080H
	mov	DWORD PTR [ecx+12], edx

; 880  :       set_boundary_num(divider,bdry->num);

	mov	ecx, DWORD PTR _V_BOUNDARY_ATTR
	test	ecx, ecx
	je	SHORT $LN196@edge_divid
	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+104
	mov	esi, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR [ecx+edx+64]
	mov	edx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [ecx+edx], esi
$LN196@edge_divid:

; 881  : 
; 882  :       /* find parameters of new midpoint */
; 883  :       mv = get_coord(divider);

	mov	ecx, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+ecx]
	mov	esi, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [esi+eax+64]

; 884  :       parammid = get_param(divider);

	mov	esi, DWORD PTR [esi+eax+544]
	lea	ebx, DWORD PTR [ecx+edx]
	add	ecx, esi

; 885  :       if ( interp_bdry_param && parama && paramb )

	cmp	DWORD PTR _interp_bdry_param, 0
	mov	DWORD PTR _mv$[ebp], ebx
	mov	DWORD PTR _parammid$89685[ebp], ecx
	je	SHORT $LN716@edge_divid
	cmp	DWORD PTR _parama$89687[ebp], 0
	je	$LN713@edge_divid
	cmp	DWORD PTR _paramb$89689[ebp], 0
	je	SHORT $LN716@edge_divid

; 886  :       { for (  i = 0 ; i < bdry->pcount ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR [edi+40], ecx
	jle	$LN719@edge_divid
	mov	eax, DWORD PTR _parama$89687[ebp]
	mov	edx, DWORD PTR _paramb$89689[ebp]
	mov	esi, DWORD PTR _parammid$89685[ebp]
	sub	edx, eax
	sub	esi, eax
$LN61@edge_divid:

; 887  :           parammid[i] = (parama[i] + paramb[i])/2;

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi+eax-8]
	cmp	ecx, DWORD PTR [edi+40]
	jl	SHORT $LN61@edge_divid

; 888  :       }
; 889  :       else

	jmp	$LN719@edge_divid
$LN716@edge_divid:

; 890  :       if ( !parama && !paramb )

	cmp	DWORD PTR _parama$89687[ebp], 0
	fstp	ST(0)
	je	SHORT $LN494@edge_divid
$LN57@edge_divid:

; 904  : #ifdef PARAMAVG
; 905  :          if ( (get_boundary(headv) == bdry) && (get_boundary(tailv) == bdry) )
; 906  :               {
; 907  :                  mu = get_coord(tailv);
; 908  :                  parama = get_param(tailv);
; 909  :                  paramb = get_param(headv);
; 910  :                  /* projecting on tangent */
; 911  :                  b_extrapolate(bdry,mu,mv,mv,parama,parammid,tailv);
; 912  :                  /* if not wrapped, take average parameter */
; 913  :                  for (  i = 0 ; i < bdry->pcount ; i++ )
; 914  :                     { if ( ((parama[i] < parammid[i]) && (parammid[i] < paramb[i]))
; 915  :                       || ((parama[i] > parammid[i]) && (parammid[i] > paramb[i])))
; 916  :                       parammid[i] = (parama[i] + paramb[i])/2;
; 917  :                     }
; 918  : 
; 919  :               }
; 920  :              else
; 921  : #endif
; 922  :       if ( (get_boundary(headv) == bdry) && !wrap2 )

	mov	ecx, DWORD PTR _V_BOUNDARY_ATTR
	test	ecx, ecx
	je	$LN204@edge_divid
	mov	ebx, DWORD PTR _web+12
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+eax+64]
	mov	eax, DWORD PTR tv4086[ebp]
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
	mov	ebx, DWORD PTR _mv$[ebp]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	$LN205@edge_divid
$LN713@edge_divid:

; 890  :       if ( !parama && !paramb )

	fstp	ST(0)
$LN494@edge_divid:
	cmp	DWORD PTR _paramb$89689[ebp], 0
	jne	SHORT $LN57@edge_divid

; 891  :       { sprintf(errmsg,
; 892  :           "Vertices %s and %s are on different boundaries from edge %s .\n",
; 893  :                    ELNAME(headv),ELNAME1(tailv),ELNAME2(e_id));

	test	DWORD PTR _e_id$GSCopy$[ebp], 268435456	; 10000000H
	je	SHORT $LN198@edge_divid
	mov	edx, DWORD PTR tv4074[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1088[ebp], OFFSET _elnames+60
	jmp	SHORT $LN199@edge_divid
$LN198@edge_divid:
	mov	DWORD PTR tv1088[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN199@edge_divid:
	test	DWORD PTR _tailv$[ebp], 268435456	; 10000000H
	je	SHORT $LN200@edge_divid
	mov	eax, DWORD PTR tv4076[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN201@edge_divid
$LN200@edge_divid:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN201@edge_divid:
	test	DWORD PTR _headv$[ebp], 268435456	; 10000000H
	je	SHORT $LN202@edge_divid
	mov	ecx, DWORD PTR tv4086[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN203@edge_divid
$LN202@edge_divid:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN203@edge_divid:
	mov	edx, DWORD PTR tv1088[ebp]
	push	edx
	push	esi
	push	eax
	push	OFFSET ??_C@_0DP@KEJAHAKK@Vertices?5?$CFs?5and?5?$CFs?5are?5on?5differ@
	push	OFFSET _errmsg
	call	_sprintf

; 894  :         kb_error(1240,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1240					; 000004d8H
	call	_kb_error

; 895  :         paramb = defaultp;
; 896  :         defaultp[0] = defaultp[1] = defaultp[2] = 0.1;

	fld	QWORD PTR __real@3fb999999999999a
	fst	QWORD PTR _defaultp$89686[ebp+16]

; 897  :         for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	add	esp, 32					; 00000020H
	fst	QWORD PTR _defaultp$89686[ebp+8]
	fstp	QWORD PTR _defaultp$89686[ebp]
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN54@edge_divid

; 891  :       { sprintf(errmsg,
; 892  :           "Vertices %s and %s are on different boundaries from edge %s .\n",
; 893  :                    ELNAME(headv),ELNAME1(tailv),ELNAME2(e_id));

	lea	eax, DWORD PTR [edi+48]
	mov	DWORD PTR tv6925[ebp], eax
	npad	2
$LL56@edge_divid:

; 898  :           s[i] = eval(bdry->coordf[i],defaultp,NULLID,NULL);

	mov	edx, DWORD PTR tv6925[ebp]
	mov	eax, DWORD PTR [edx]
	push	0
	push	0
	lea	ecx, DWORD PTR _defaultp$89686[ebp]
	push	ecx
	push	eax
	call	_eval
	fstp	QWORD PTR _s$[ebp+esi*8]
	add	DWORD PTR tv6925[ebp], 4
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL56@edge_divid
$LN54@edge_divid:

; 899  :         mu = s;
; 900  :         /* projecting on tangent */
; 901  :         b_extrapolate(bdry,mu,mv,mv,paramb,parammid,NULLID);

	mov	ecx, DWORD PTR _parammid$89685[ebp]
	push	0
	push	ecx
	lea	edx, DWORD PTR _defaultp$89686[ebp]
	push	edx
	push	ebx
	push	ebx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	push	edi
	call	_b_extrapolate
	add	esp, 28					; 0000001cH

; 902  :       }
; 903  :       else

	jmp	$LN470@edge_divid
$LN204@edge_divid:

; 904  : #ifdef PARAMAVG
; 905  :          if ( (get_boundary(headv) == bdry) && (get_boundary(tailv) == bdry) )
; 906  :               {
; 907  :                  mu = get_coord(tailv);
; 908  :                  parama = get_param(tailv);
; 909  :                  paramb = get_param(headv);
; 910  :                  /* projecting on tangent */
; 911  :                  b_extrapolate(bdry,mu,mv,mv,parama,parammid,tailv);
; 912  :                  /* if not wrapped, take average parameter */
; 913  :                  for (  i = 0 ; i < bdry->pcount ; i++ )
; 914  :                     { if ( ((parama[i] < parammid[i]) && (parammid[i] < paramb[i]))
; 915  :                       || ((parama[i] > parammid[i]) && (parammid[i] > paramb[i])))
; 916  :                       parammid[i] = (parama[i] + paramb[i])/2;
; 917  :                     }
; 918  : 
; 919  :               }
; 920  :              else
; 921  : #endif
; 922  :       if ( (get_boundary(headv) == bdry) && !wrap2 )

	xor	eax, eax
$LN205@edge_divid:
	cmp	eax, edi
	jne	SHORT $LN52@edge_divid
	cmp	DWORD PTR _wrap2$[ebp], 0
	jne	SHORT $LN52@edge_divid

; 923  :       { mu = get_coord(headv);
; 924  :         paramb = get_param(headv);

	mov	ecx, DWORD PTR tv4086[ebp]
	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+ecx*4]

; 925  :         /* projecting on tangent */
; 926  :         b_extrapolate(bdry,mu,mv,mv,paramb,parammid,headv);

	mov	ecx, DWORD PTR _headv$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _parammid$89685[ebp]
	push	ecx
	lea	ecx, DWORD PTR [eax+esi]
	push	ecx
	push	ebx
	push	ebx
	add	eax, edx
	push	eax
	push	edi
	call	_b_extrapolate
	add	esp, 28					; 0000001cH

; 927  :       }
; 928  :       else

	jmp	$LN470@edge_divid
$LN52@edge_divid:

; 929  :       { mu = get_coord(tailv);
; 930  :         paramb = get_param(tailv);

	mov	ecx, DWORD PTR _web+12
	mov	eax, DWORD PTR tv4076[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]

; 931  :         /* projecting on tangent */
; 932  :         b_extrapolate(bdry,mu,mv,mv,paramb,parammid,tailv);

	mov	ecx, DWORD PTR _tailv$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _parammid$89685[ebp]
	push	ecx
	lea	ecx, DWORD PTR [eax+esi]
	push	ecx
	push	ebx
	push	ebx
	add	eax, edx
	push	eax
	push	edi
	call	_b_extrapolate
	add	esp, 28					; 0000001cH

; 1000 :         }
; 1001 :       }
; 1002 : 
; 1003 :     }
; 1004 :   }
; 1005 :   else

	jmp	$LN470@edge_divid
$LN608@edge_divid:

; 1006 :   { ATTR attr = get_eattr(e_id) & (BDRY_ENERGY | BDRY_CONTENT | CONSTRAINT );
; 1007 :     conmap_t * conmap = get_e_constraint_map(e_id);

	mov	eax, DWORD PTR _web+216
	fstp	ST(0)
	and	edi, 5632				; 00001600H
	xor	edx, edx
	mov	DWORD PTR _attr$89905[ebp], edi
	cmp	DWORD PTR [eax+ecx+1048], edx
	je	SHORT $LN216@edge_divid
	mov	ebx, DWORD PTR [eax+ecx+1024]
	add	ebx, esi
	jmp	SHORT $LN217@edge_divid
$LN216@edge_divid:
	mov	ebx, OFFSET _nullcon
$LN217@edge_divid:

; 1008 : 
; 1009 :     set_attr(new_e,attr);

	mov	eax, DWORD PTR tv4340[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR tv4344[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	or	DWORD PTR [eax+8], edi
	or	DWORD PTR [eax+12], edx

; 1010 :     set_attr(divider,attr);

	mov	ecx, DWORD PTR tv4129[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv4133[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	or	DWORD PTR [eax+8], edi
	or	DWORD PTR [eax+12], edx

; 1011 :     if ( conmap || attr )

	test	ebx, ebx
	jne	SHORT $LN483@edge_divid
	mov	eax, edi
	or	eax, edx
	je	$LN470@edge_divid
$LN483@edge_divid:

; 1012 :     { set_e_conmap(new_e,conmap);

	mov	ecx, DWORD PTR _new_e$[ebp]
	push	ebx
	push	ecx
	call	_set_e_conmap

; 1013 :       set_v_conmap(divider,conmap);

	mov	esi, DWORD PTR _divider$[ebp]
	push	ebx
	push	esi
	call	_set_v_conmap

; 1014 :       project_v_constr(divider,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	push	1
	push	1
	push	esi
	call	_project_v_constr
	add	esp, 28					; 0000001cH

; 1015 :       if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	$LN470@edge_divid

; 1016 :       { set_attr(old_mid,attr);

	mov	esi, DWORD PTR _old_mid$[ebp]
	mov	edx, esi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	or	DWORD PTR [eax+8], edi

; 1017 :         set_attr(new_mid,attr);

	mov	edi, DWORD PTR _new_mid$[ebp]
	mov	edx, edi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	xor	ecx, ecx
	or	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR _web[edx+12]
	mov	edx, DWORD PTR _attr$89905[ebp]
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	or	DWORD PTR [eax+8], edx
	xor	ecx, ecx
	or	DWORD PTR [eax+12], ecx

; 1018 :         clear_v_conmap(old_mid);

	push	esi
	call	_clear_v_conmap

; 1019 :         clear_v_conmap(new_mid);

	push	edi
	call	_clear_v_conmap

; 1020 :         set_v_conmap(old_mid,conmap);

	push	ebx
	push	esi
	call	_set_v_conmap

; 1021 :         set_v_conmap(new_mid,conmap);

	push	ebx
	push	edi
	call	_set_v_conmap

; 1022 :         project_v_constr(old_mid,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	push	1
	push	1
	push	esi
	call	_project_v_constr

; 1023 :         project_v_constr(new_mid,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	push	1
	push	1
	push	edi
	call	_project_v_constr
	add	esp, 48					; 00000030H
	jmp	$LN470@edge_divid

; 1024 :       }
; 1025 :       /* this should have been taken care of for Lagrange in dup_edge */
; 1026 :     }
; 1027 :   }
; 1028 : 
; 1029 :   old_fe = first_fe = get_edge_fe(e_id);

$LN279@edge_divid:
	test	DWORD PTR _e_id$GSCopy$[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR [eax+28]
	je	SHORT $LN278@edge_divid
	xor	eax, 134217728				; 08000000H
$LN278@edge_divid:
	mov	DWORD PTR _first_fe$[ebp], eax
$LN280@edge_divid:
	mov	ebx, eax

; 1030 :   new_fe = NULLID;
; 1031 :   if ( valid_id(old_fe) ) do

	shr	eax, 28					; 0000001cH
	xor	edi, edi
	mov	DWORD PTR _old_fe$[ebp], ebx
	test	al, 1
	je	$LN18@edge_divid
	mov	ecx, DWORD PTR _web+460
$LL20@edge_divid:

; 1032 :   { /* create new facetedge and splice into edge net */
; 1033 :     facetedge_id next;
; 1034 :     new_fe = new_facetedge(get_fe_facet(old_fe),new_e);

	and	eax, 1
	mov	DWORD PTR tv4905[ebp], eax
	jne	SHORT $LN283@edge_divid
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN282@edge_divid
$LN283@edge_divid:
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [eax+24]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN282@edge_divid
	xor	eax, 134217728				; 08000000H
$LN282@edge_divid:
	mov	ecx, DWORD PTR _new_e$[ebp]
	push	ecx
	push	eax
	call	_new_facetedge

; 1035 :     set_next_edge(new_fe,get_next_edge(old_fe));

	mov	ecx, DWORD PTR _web+460
	mov	edi, eax
	mov	eax, ebx
	shr	eax, 27					; 0000001bH
	add	esp, 8
	and	eax, 1
	mov	DWORD PTR tv4917[ebp], eax
	mov	esi, ebx
	je	SHORT $LN287@edge_divid
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN286@edge_divid
$LN287@edge_divid:
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+32]
$LN286@edge_divid:
	mov	edx, edi
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	DWORD PTR tv4928[ebp], edx
	je	SHORT $LN290@edge_divid
	mov	edx, edi
	test	edi, 134217728				; 08000000H
	je	SHORT $LN291@edge_divid
	xor	eax, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN764@edge_divid
$LN291@edge_divid:
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+32], eax
$LN764@edge_divid:
	mov	ecx, DWORD PTR _web+460
$LN290@edge_divid:

; 1036 :     next = get_next_edge(old_fe);

	cmp	DWORD PTR tv4917[ebp], 0
	mov	eax, DWORD PTR [esi+ecx]
	je	SHORT $LN296@edge_divid
	mov	edx, DWORD PTR [eax+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN295@edge_divid
$LN296@edge_divid:
	mov	edx, DWORD PTR [eax+32]
$LN295@edge_divid:

; 1037 :     if ( valid_id(next) )

	test	edx, 268435456				; 10000000H
	je	SHORT $LN500@edge_divid

; 1038 :       set_prev_edge(get_next_edge(old_fe),new_fe);

	cmp	DWORD PTR tv4917[ebp], 0
	je	SHORT $LN300@edge_divid
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN299@edge_divid
$LN300@edge_divid:
	mov	eax, DWORD PTR [eax+32]
$LN299@edge_divid:
	test	eax, 268435456				; 10000000H
	je	SHORT $LN500@edge_divid
	test	eax, 134217728				; 08000000H
	je	SHORT $LN304@edge_divid
	mov	edx, edi
	xor	edx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [eax+32], edx
	jmp	SHORT $LN303@edge_divid
$LN304@edge_divid:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+28], edi
$LN303@edge_divid:
	mov	eax, DWORD PTR _global_timestamp
	mov	ecx, DWORD PTR _web+460
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN500@edge_divid:

; 1039 :     set_next_edge(old_fe,new_fe);

	cmp	DWORD PTR tv4905[ebp], 0
	je	SHORT $LN507@edge_divid
	cmp	DWORD PTR tv4917[ebp], 0
	je	SHORT $LN309@edge_divid
	mov	eax, DWORD PTR [esi+ecx]
	mov	edx, edi
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [eax+28], edx
	jmp	SHORT $LN765@edge_divid
$LN309@edge_divid:
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [ecx+32], edi
$LN765@edge_divid:
	mov	ecx, DWORD PTR _web+460
$LN507@edge_divid:

; 1040 :     set_prev_edge(new_fe,old_fe);

	cmp	DWORD PTR tv4928[ebp], 0
	je	SHORT $LN508@edge_divid
	test	edi, 134217728				; 08000000H
	je	SHORT $LN314@edge_divid
	mov	edx, ebx
	xor	edx, 134217728				; 08000000H
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+32], edx
	jmp	SHORT $LN313@edge_divid
$LN314@edge_divid:
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [eax+28], ebx
$LN313@edge_divid:
	mov	eax, DWORD PTR _global_timestamp
	mov	ecx, DWORD PTR _web+460
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN508@edge_divid:

; 1041 :     if ( web.representation == STRING ) /* keep facet fe at start of arc */

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN471@edge_divid

; 1042 :     { facet_id ff_id = get_fe_facet(old_fe);

	cmp	DWORD PTR tv4905[ebp], 0
	jne	SHORT $LN319@edge_divid
	mov	edx, DWORD PTR _NULLFACET
	jmp	SHORT $LN318@edge_divid
$LN319@edge_divid:
	cmp	DWORD PTR tv4917[ebp], 0
	mov	edx, DWORD PTR [esi+ecx]
	mov	edx, DWORD PTR [edx+24]
	je	SHORT $LN318@edge_divid
	xor	edx, 134217728				; 08000000H
$LN318@edge_divid:

; 1043 :       if ( inverted(ff_id) && equal_id(old_fe,get_facet_fe(ff_id)) )

	test	edx, 134217728				; 08000000H
	je	SHORT $LN471@edge_divid
	test	edx, 268435456				; 10000000H
	jne	SHORT $LN323@edge_divid
	xor	eax, eax
	jmp	SHORT $LN324@edge_divid
$LN323@edge_divid:
	mov	ebx, DWORD PTR _web+236
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+28]
	mov	ebx, DWORD PTR _old_fe$[ebp]
	xor	eax, 134217728				; 08000000H
$LN324@edge_divid:
	cmp	ebx, eax
	jne	SHORT $LN471@edge_divid

; 1044 :          set_facet_fe(ff_id,new_fe);

	push	edi
	push	edx
	call	_set_facet_fe
	mov	ecx, DWORD PTR _web+460
	add	esp, 8
$LN471@edge_divid:

; 1045 :     }
; 1046 :     old_fe = get_next_facet(old_fe);

	cmp	DWORD PTR tv4917[ebp], 0
	je	SHORT $LN327@edge_divid
	mov	edx, DWORD PTR [esi+ecx]
	mov	ebx, DWORD PTR [edx+36]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN766@edge_divid
$LN327@edge_divid:
	mov	eax, DWORD PTR [esi+ecx]
	mov	ebx, DWORD PTR [eax+40]
$LN766@edge_divid:

; 1047 :   } while ( valid_id(old_fe) && !equal_id(old_fe,first_fe) );

	mov	eax, ebx
	shr	eax, 28					; 0000001cH
	mov	DWORD PTR _old_fe$[ebp], ebx
	test	al, 1
	je	SHORT $LN18@edge_divid
	cmp	ebx, DWORD PTR _first_fe$[ebp]
	jne	$LL20@edge_divid
$LN18@edge_divid:

; 1048 :   set_edge_fe(new_e,new_fe);

	mov	edx, DWORD PTR _new_e$[ebp]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	DWORD PTR tv4354[ebp], edx
	je	SHORT $LN509@edge_divid
	xor	edi, 134217728				; 08000000H
$LN509@edge_divid:
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR tv4344[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR [ecx+28], edi
	mov	eax, DWORD PTR _global_timestamp

; 1049 : 
; 1050 :   old_fe = first_fe = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _web+124
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	eax, DWORD PTR tv4074[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN333@edge_divid
$LN334@edge_divid:
	test	DWORD PTR _e_id$GSCopy$[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR [eax+28]
	je	SHORT $LN333@edge_divid
	xor	eax, 134217728				; 08000000H
$LN333@edge_divid:

; 1051 :   if ( valid_id(old_fe) )  do

	mov	ecx, DWORD PTR _web+460
	mov	DWORD PTR _first_fe$[ebp], eax
	test	eax, 268435456				; 10000000H
	je	$LN10@edge_divid
	npad	1
$LL12@edge_divid:

; 1052 :     { /* copy over facet chain */
; 1053 :       facetedge_id fe,nfe;
; 1054 : 
; 1055 :       fe = get_next_edge(old_fe);

	mov	ebx, eax
	shr	ebx, 27					; 0000001bH
	and	ebx, 1
	mov	DWORD PTR tv4917[ebp], ebx
	je	SHORT $LN338@edge_divid
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	esi, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [esi+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN337@edge_divid
$LN338@edge_divid:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	esi, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [esi+32]
$LN337@edge_divid:

; 1056 :       nfe = get_next_facet(old_fe);

	test	ebx, ebx
	je	SHORT $LN342@edge_divid
	mov	esi, DWORD PTR [esi+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN341@edge_divid
$LN342@edge_divid:
	mov	esi, DWORD PTR [esi+40]
$LN341@edge_divid:

; 1057 :       set_next_facet(fe,get_next_edge(nfe));

	test	esi, 134217728				; 08000000H
	je	SHORT $LN346@edge_divid
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [esi+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN345@edge_divid
$LN346@edge_divid:
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [esi+32]
$LN345@edge_divid:
	mov	edi, edx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	je	SHORT $LN349@edge_divid
	mov	ebx, edx
	test	edx, 134217728				; 08000000H
	je	SHORT $LN350@edge_divid
	xor	esi, 134217728				; 08000000H
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR [ecx+36], esi
	jmp	SHORT $LN767@edge_divid
$LN350@edge_divid:
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR [ecx+40], esi
$LN767@edge_divid:
	mov	ebx, DWORD PTR tv4917[ebp]
	mov	ecx, DWORD PTR _web+460
$LN349@edge_divid:

; 1058 :       nfe = get_prev_facet(old_fe);

	mov	esi, DWORD PTR [eax+ecx]
	test	ebx, ebx
	je	SHORT $LN355@edge_divid
	mov	esi, DWORD PTR [esi+40]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN354@edge_divid
$LN355@edge_divid:
	mov	esi, DWORD PTR [esi+36]
$LN354@edge_divid:

; 1059 :         set_prev_facet(fe,get_next_edge(nfe));

	test	esi, 134217728				; 08000000H
	je	SHORT $LN359@edge_divid
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [esi+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN358@edge_divid
$LN359@edge_divid:
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [esi+32]
$LN358@edge_divid:
	test	edi, edi
	je	SHORT $LN506@edge_divid
	test	edx, 134217728				; 08000000H
	je	SHORT $LN363@edge_divid
	xor	esi, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edx+40], esi
	jmp	SHORT $LN362@edge_divid
$LN363@edge_divid:
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+36], esi
$LN362@edge_divid:
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
	mov	ecx, DWORD PTR _web+460
$LN506@edge_divid:

; 1060 :       old_fe = get_next_facet(old_fe);

	test	ebx, ebx
	je	SHORT $LN368@edge_divid
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN11@edge_divid
$LN368@edge_divid:
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+40]
$LN11@edge_divid:

; 1061 :     } while ( valid_id(old_fe) && !equal_id(old_fe,first_fe) );

	test	eax, 268435456				; 10000000H
	je	SHORT $LN9@edge_divid
	cmp	eax, DWORD PTR _first_fe$[ebp]
	jne	$LL12@edge_divid
$LN9@edge_divid:
	mov	edx, DWORD PTR tv4354[ebp]
$LN10@edge_divid:

; 1062 : 
; 1063 :   /* check for dangling ends with loopback fe */
; 1064 :   new_fe = first_fe = get_edge_fe(new_e);

	mov	eax, DWORD PTR tv4344[ebp]
	mov	esi, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+esi]
	test	eax, eax
	jne	SHORT $LN372@edge_divid
	mov	DWORD PTR _first_fe$[ebp], eax
	jmp	SHORT $LN373@edge_divid
$LN372@edge_divid:
	mov	eax, DWORD PTR [eax+28]
	test	edx, edx
	je	SHORT $LN371@edge_divid
	xor	eax, 134217728				; 08000000H
$LN371@edge_divid:
	mov	DWORD PTR _first_fe$[ebp], eax
$LN373@edge_divid:
	mov	esi, eax

; 1065 :   if ( valid_id(new_fe) )  do

	shr	eax, 28					; 0000001cH
	mov	DWORD PTR tv4927[ebp], eax
	test	al, 1
	je	$LN5@edge_divid
$LL7@edge_divid:

; 1066 :   { if ( valid_id(get_next_edge(new_fe)) )

	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ebx, esi
	add	eax, eax
	shr	ebx, 27					; 0000001bH
	add	eax, eax
	and	ebx, 1
	mov	edi, DWORD PTR [eax+ecx]
	je	SHORT $LN376@edge_divid
	mov	edx, DWORD PTR [edi+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN375@edge_divid
$LN376@edge_divid:
	mov	edx, DWORD PTR [edi+32]
$LN375@edge_divid:
	test	edx, 268435456				; 10000000H
	je	$LN505@edge_divid

; 1067 :       if ( !equal_id(get_prev_edge(get_next_edge(new_fe)),new_fe ) )

	test	ebx, ebx
	je	SHORT $LN380@edge_divid
	mov	edx, DWORD PTR [edi+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN379@edge_divid
$LN380@edge_divid:
	mov	edx, DWORD PTR [edi+32]
$LN379@edge_divid:
	test	edx, 134217728				; 08000000H
	je	SHORT $LN384@edge_divid
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [edx+32]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN383@edge_divid
$LN384@edge_divid:
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [edx+28]
$LN383@edge_divid:
	cmp	edx, esi
	je	SHORT $LN505@edge_divid

; 1068 :          set_next_edge(new_fe,get_prev_edge(get_next_edge(new_fe)));

	test	ebx, ebx
	je	SHORT $LN388@edge_divid
	mov	edx, DWORD PTR [edi+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN387@edge_divid
$LN388@edge_divid:
	mov	edx, DWORD PTR [edi+32]
$LN387@edge_divid:
	test	edx, 134217728				; 08000000H
	je	SHORT $LN392@edge_divid
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	esi, DWORD PTR [edx+32]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN391@edge_divid
$LN392@edge_divid:
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	esi, DWORD PTR [edx+28]
$LN391@edge_divid:
	test	BYTE PTR tv4927[ebp], 1
	je	SHORT $LN505@edge_divid
	test	ebx, ebx
	je	SHORT $LN396@edge_divid
	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR [edi+28], esi
	jmp	SHORT $LN768@edge_divid
$LN396@edge_divid:
	mov	DWORD PTR [edi+32], esi
$LN768@edge_divid:
	mov	ecx, DWORD PTR _web+460
$LN505@edge_divid:

; 1069 :     new_fe = get_next_facet(new_fe);

	test	ebx, ebx
	je	SHORT $LN401@edge_divid
	mov	eax, DWORD PTR [eax+ecx]
	mov	esi, DWORD PTR [eax+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN6@edge_divid
$LN401@edge_divid:
	mov	edx, DWORD PTR [eax+ecx]
	mov	esi, DWORD PTR [edx+40]
$LN6@edge_divid:

; 1070 :   } while (  valid_id(new_fe) &&!equal_id(new_fe,first_fe) );

	mov	eax, esi
	shr	eax, 28					; 0000001cH
	mov	DWORD PTR tv4927[ebp], eax
	test	al, 1
	je	SHORT $LN5@edge_divid
	cmp	esi, DWORD PTR _first_fe$[ebp]
	jne	$LL7@edge_divid
$LN5@edge_divid:

; 1071 : 
; 1072 :  #ifdef MPI_EVOLVER
; 1073 :  { unsigned short *nbr = mpi_export_eattr_ptr(e_id);
; 1074 :    for (i = 0 ; i < MPI_EXPORT_MAX ; i++ )
; 1075 :    { if ( nbr[i] == 0 ) break;
; 1076 :      if ( nbr[i] != this_task )
; 1077 :         mpi_refine_edge(e_id,divider,new_e,(int)nbr[i]);
; 1078 :     }
; 1079 :  }
; 1080 :  #endif
; 1081 : 
; 1082 :  if ( (web.representation==STRING) && everything_quantities_flag )

	cmp	DWORD PTR _web+624, 1
	pop	ebx
	jne	SHORT $LN479@edge_divid
	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN479@edge_divid

; 1083 :     check_edge_vol_methods(new_e);

	mov	eax, DWORD PTR _new_e$[ebp]
	push	eax
	call	_check_edge_vol_methods
	add	esp, 4
$LN479@edge_divid:

; 1084 : 
; 1085 :  top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp

; 1086 : 
; 1087 :  return new_e;
; 1088 : 
; 1089 : } /* end edge_divide() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	inc	eax
	pop	edi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	eax, DWORD PTR _new_e$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_divide ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DO@FKBHOCNE@Vertices?5?$CFs?5and?5?$CFs?5are?5on?5differ@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_cross_cut
EXTRN	_F_BOUNDARY_ATTR:DWORD
EXTRN	_set_f_phase_density:PROC
EXTRN	_phase_flag:DWORD
EXTRN	_set_facet_body:PROC
EXTRN	_dup_facet:PROC
EXTRN	_new_edge:PROC
;	COMDAT ??_C@_0DO@FKBHOCNE@Vertices?5?$CFs?5and?5?$CFs?5are?5on?5differ@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DO@FKBHOCNE@Vertices?5?$CFs?5and?5?$CFs?5are?5on?5differ@ DB 'Vert'
	DB	'ices %s and %s are on different boundaries from edge %s.', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _cross_cut
_TEXT	SEGMENT
tv2000 = -112						; size = 4
_headv$ = -108						; size = 4
_attr$ = -104						; size = 8
_new_e$ = -96						; size = 4
tv2299 = -92						; size = 4
tv1985 = -92						; size = 4
tv1826 = -92						; size = 4
tv2055 = -88						; size = 4
tv2307 = -84						; size = 4
tv2148 = -84						; size = 4
tv1996 = -84						; size = 4
tv2008 = -80						; size = 4
_parammid$90038 = -80					; size = 4
tv2071 = -76						; size = 4
_tailv$ = -72						; size = 4
tv2406 = -68						; size = 4
tv1988 = -68						; size = 4
tv2402 = -64						; size = 4
tv2278 = -64						; size = 4
_wrap$ = -64						; size = 4
tv2262 = -60						; size = 4
_mv$90040 = -60						; size = 4
_new_fe_old$ = -60					; size = 4
_bdry$90032 = -56					; size = 4
_new_fe_new$ = -56					; size = 4
_temp$90007 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_first_fe$ = 8						; size = 4
_last_fe$ = 12						; size = 4
_cross_cut PROC						; COMDAT

; 1112 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 1113 :   facet_id old_f,new_f;
; 1114 :   edge_id  new_e;
; 1115 :   facetedge_id fe,new_fe_new,new_fe_old;
; 1116 :   int wrap;
; 1117 :   ATTR attr;
; 1118 :   vertex_id headv,tailv;
; 1119 :   int i,k;
; 1120 : 
; 1121 :   old_f = get_fe_facet(first_fe);

	mov	ebx, DWORD PTR _web+460
	push	esi
	push	edi
	mov	edi, DWORD PTR _first_fe$[ebp]
	mov	eax, edi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv1985[ebp], eax
	jne	SHORT $LN52@cross_cut
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN51@cross_cut
$LN52@cross_cut:
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	esi, DWORD PTR [ecx+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN51@cross_cut
	xor	esi, 134217728				; 08000000H
$LN51@cross_cut:

; 1122 :   attr = get_fattr(old_f);

	mov	edx, DWORD PTR _web+236
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2000[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _attr$[ebp], ecx

; 1123 : 
; 1124 :   tailv = get_fe_headv(last_fe);

	mov	ecx, DWORD PTR _last_fe$[ebp]
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR _attr$[ebp+4], edx
	mov	edx, DWORD PTR [eax+ebx]
	mov	DWORD PTR tv2008[ebp], eax
	mov	eax, ecx
	mov	ecx, DWORD PTR _web+216
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	edx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN58@cross_cut
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
	jmp	SHORT $LN201@cross_cut
$LN58@cross_cut:
	mov	ebx, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
	mov	ebx, DWORD PTR _web+460
$LN201@cross_cut:
	mov	DWORD PTR _tailv$[ebp], eax

; 1125 :   headv = get_fe_tailv(first_fe);

	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ebx, DWORD PTR [eax+ebx]
	mov	DWORD PTR tv1988[ebp], eax
	mov	eax, edi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ebx+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN64@cross_cut
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _web+636
	lea	edx, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [edx+ecx]
	jmp	SHORT $LN202@cross_cut
$LN64@cross_cut:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [ecx+eax]
$LN202@cross_cut:

; 1126 :   if ( get_vattr(headv) & AXIAL_POINT )

	mov	edx, DWORD PTR _web+12
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv2055[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR _headv$[ebp], ecx

; 1127 :      new_e = inverse_id(new_edge(headv,tailv,old_f));

	push	esi
	je	SHORT $LN28@cross_cut
	mov	eax, DWORD PTR _tailv$[ebp]
	push	eax
	push	ecx
	call	_new_edge
	mov	edi, eax
	add	esp, 12					; 0000000cH
	xor	edi, 134217728				; 08000000H
	mov	DWORD PTR _new_e$[ebp], edi
	jmp	SHORT $LN27@cross_cut
$LN28@cross_cut:

; 1128 :   else new_e = new_edge(tailv,headv,old_f);

	push	ecx
	mov	ecx, DWORD PTR _tailv$[ebp]
	push	ecx
	call	_new_edge
	add	esp, 12					; 0000000cH
	mov	edi, eax
	mov	DWORD PTR _new_e$[ebp], eax
$LN27@cross_cut:

; 1129 :   if ( attr & FIXED )

	mov	eax, DWORD PTR _attr$[ebp]
	mov	edx, 64					; 00000040H
	and	eax, edx
	xor	ecx, ecx
	or	eax, ecx
	je	$LN194@cross_cut

; 1130 :   { set_attr(new_e,FIXED);

	mov	ecx, edi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ecx+12]
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [ecx+eax]
	mov	ebx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], edx
	mov	DWORD PTR [ecx+12], ebx

; 1131 :      if ( web.modeltype == QUADRATIC ) 

	mov	ecx, DWORD PTR _web+628
	cmp	ecx, 2
	jne	SHORT $LN25@cross_cut

; 1132 :         set_attr(get_edge_midv(new_e),FIXED);

	mov	ebx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+ebx+304]
	mov	ebx, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+ebx]
	mov	eax, DWORD PTR [ecx+eax+8]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	or	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN194@cross_cut
$LN25@cross_cut:

; 1133 :      else if ( web.modeltype == LAGRANGE ) 

	cmp	ecx, 3
	jne	SHORT $LN194@cross_cut

; 1134 :      { vertex_id *v = get_edge_vertices(new_e);

	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [ecx+edx+304]
	mov	ecx, DWORD PTR _web+124
	add	edx, DWORD PTR [eax+ecx]

; 1135 :         for ( i = 1 ; i < web.lagrange_order ; i++ )

	mov	ecx, 1
	cmp	DWORD PTR _web+632, ecx
	jle	SHORT $LN194@cross_cut
	npad	3
$LL22@cross_cut:

; 1136 :           set_attr(v[i],FIXED);

	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ebx, eax
	shr	ebx, 29					; 0000001dH
	imul	ebx, 112				; 00000070H
	mov	ebx, DWORD PTR _web[ebx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 64			; 00000040H
	inc	ecx
	mov	DWORD PTR [eax+12], ebx
	cmp	ecx, DWORD PTR _web+632
	jl	SHORT $LL22@cross_cut
$LN194@cross_cut:

; 1137 :      }
; 1138 :   }
; 1139 :   if ( attr & NO_REFINE ) set_attr(new_e,NO_REFINE);

	mov	eax, DWORD PTR _attr$[ebp]
	and	eax, 16777216				; 01000000H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN73@cross_cut
	mov	edx, edi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 16777216		; 01000000H
	mov	DWORD PTR [eax+12], edx
$LN73@cross_cut:

; 1140 : 
; 1141 :   /* for QUADRATIC model, midpoint of new edge is left as the 
; 1142 :       linear interpolation given by new_edge() since triangular
; 1143 :       facets may not yet be established yet */
; 1144 : 
; 1145 :   new_f = dup_facet(old_f); /* copy facet data */

	push	esi
	call	_dup_facet

; 1146 :   /* if ( inverted(old_f) ) invert(new_f);*/    /* same orientation */
; 1147 :   set_attr(old_f,NEWFACET);

	mov	edx, DWORD PTR tv2000[ebp]
	mov	ebx, eax
	mov	eax, esi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 4

; 1148 : 
; 1149 : 
; 1150 :   new_fe_new = new_facetedge(new_f,new_e);

	push	edi
	push	ebx
	mov	DWORD PTR [eax+12], ecx
	call	_new_facetedge

; 1151 :   new_fe_old = new_facetedge(old_f,edge_inverse(new_e));

	mov	edx, edi
	xor	edx, 134217728				; 08000000H
	push	edx
	push	esi
	mov	DWORD PTR _new_fe_new$[ebp], eax
	call	_new_facetedge

; 1152 :   set_edge_fe(new_e,new_fe_new);

	mov	ecx, DWORD PTR _new_fe_new$[ebp]
	mov	DWORD PTR _new_fe_old$[ebp], eax
	mov	eax, edi
	shr	eax, 27					; 0000001bH
	add	esp, 20					; 00000014H
	and	eax, 1
	mov	DWORD PTR tv2148[ebp], eax
	je	SHORT $LN77@cross_cut
	xor	ecx, 134217728				; 08000000H
$LN77@cross_cut:
	mov	eax, DWORD PTR _web+124
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [edx+28], ecx
	mov	eax, DWORD PTR _global_timestamp
	inc	eax

; 1153 :   set_facet_body(new_f,get_facet_body(old_f));

	push	esi
	mov	DWORD PTR tv2071[ebp], edi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	call	_get_facet_body
	push	eax
	push	ebx
	call	_set_facet_body

; 1154 :   set_facet_body(facet_inverse(new_f),get_facet_body(facet_inverse(old_f)));

	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	push	eax
	call	_get_facet_body
	mov	ecx, ebx
	push	eax
	xor	ecx, 134217728				; 08000000H
	push	ecx
	call	_set_facet_body
	add	esp, 24					; 00000018H

; 1155 :   if ( phase_flag ) set_f_phase_density(new_f);

	cmp	DWORD PTR _phase_flag, 0
	je	SHORT $LN18@cross_cut
	push	ebx
	call	_set_f_phase_density
	add	esp, 4
$LN18@cross_cut:

; 1156 :   set_facet_fe(new_f,last_fe); /* preserves starting point of a facet */

	mov	edx, DWORD PTR _last_fe$[ebp]
	push	edx
	push	ebx
	call	_set_facet_fe

; 1157 : 
; 1158 :   set_facet_fe(old_f,new_fe_old);

	mov	eax, DWORD PTR _new_fe_old$[ebp]
	push	eax
	push	esi
	call	_set_facet_fe

; 1159 : 
; 1160 :   /* install new facet into its facet-edges */
; 1161 :   /* and set torus wrap flags if needed */
; 1162 :   fe = first_fe;

	mov	esi, DWORD PTR _first_fe$[ebp]
	add	esp, 16					; 00000010H

; 1163 :   wrap = 0;

	xor	edi, edi
	mov	DWORD PTR _wrap$[ebp], edi
	npad	5
$LL17@cross_cut:

; 1164 :   for(;;)
; 1165 :   { set_fe_facet(fe,new_f);

	push	ebx
	push	esi
	call	_set_fe_facet
	add	esp, 8

; 1166 :     if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN15@cross_cut

; 1167 :        wrap = (*sym_compose)(wrap,get_fe_wrap(fe));

	mov	edx, DWORD PTR _web+460
	mov	edi, DWORD PTR _dymem
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edi+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN84@cross_cut
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN85@cross_cut
$LN84@cross_cut:
	mov	eax, ecx
$LN85@cross_cut:
	mov	edx, DWORD PTR _wrap$[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR _wrap$[ebp], edi
$LN15@cross_cut:

; 1168 :     if ( equal_id(fe,last_fe) ) break;

	cmp	esi, DWORD PTR _last_fe$[ebp]
	je	SHORT $LN182@cross_cut

; 1169 :     fe = get_next_edge(fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN87@cross_cut
	mov	eax, DWORD PTR _web+460
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+28]
	xor	esi, 134217728				; 08000000H
	jmp	$LL17@cross_cut
$LN87@cross_cut:
	mov	edx, DWORD PTR _web+460
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [eax+32]

; 1170 :   }

	jmp	$LL17@cross_cut
$LN182@cross_cut:

; 1171 :   if ( wrap )

	test	edi, edi
	je	$LN9@cross_cut

; 1172 :   { set_edge_wrap(new_e,(*sym_inverse)(wrap));

	mov	ecx, DWORD PTR _wrap$[ebp]
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	cmp	DWORD PTR tv2148[ebp], 0
	je	SHORT $LN92@cross_cut
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN92@cross_cut:
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ecx+784]
	mov	ecx, DWORD PTR _web+124
	mov	esi, DWORD PTR tv2071[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [edx+ecx], eax

; 1173 :     if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	$LN9@cross_cut

; 1174 :     { /* have to adjust coordinates of midpoint */
; 1175 :       REAL temp[MAXCOORD];
; 1176 :       REAL *mv,*tv,*hv;
; 1177 :       tv = get_coord(tailv);

	mov	ecx, DWORD PTR _web+12
	mov	esi, DWORD PTR _tailv$[ebp]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]

; 1178 :       mv = get_coord(get_edge_midv(new_e));

	mov	ebx, DWORD PTR tv2071[ebp]
	and	esi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR _web+216
	mov	edx, DWORD PTR [esi+edx+304]
	mov	esi, DWORD PTR _web+124
	mov	esi, DWORD PTR [esi+ebx*4]
	mov	edx, DWORD PTR [edx+esi+8]
	and	edx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+edx*4]

; 1179 :       hv = get_coord(headv);

	mov	edx, DWORD PTR tv2055[ebp]
	mov	esi, DWORD PTR [ecx+edx*4]
	add	edi, eax
	add	ebx, eax
	add	esi, eax

; 1180 :       (*sym_wrap)(hv,temp,(*sym_inverse)(wrap));

	mov	eax, DWORD PTR _wrap$[ebp]
	push	eax
	call	DWORD PTR _sym_inverse
	push	eax
	lea	ecx, DWORD PTR _temp$90007[ebp]
	push	ecx
	push	esi
	call	DWORD PTR _sym_wrap

; 1181 :       for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN9@cross_cut
	fld	QWORD PTR __real@3fe0000000000000
	lea	edx, DWORD PTR _temp$90007[ebp]
	mov	ecx, edx
	sub	edi, edx
	sub	ebx, ecx
$LN11@cross_cut:
	lea	edx, DWORD PTR [edi+eax*8]

; 1182 :         mv[k] = (tv[k] + temp[k])/2;

	fld	QWORD PTR _temp$90007[ebp+edx]
	lea	ecx, DWORD PTR [ebx+eax*8]
	fadd	QWORD PTR _temp$90007[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _temp$90007[ebp+ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN11@cross_cut

; 1181 :       for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
$LN9@cross_cut:

; 1183 :     }
; 1184 :   }
; 1185 : 
; 1186 :   /* link up facet-edges */
; 1187 :   set_next_edge(get_prev_edge(first_fe),new_fe_old);

	mov	ebx, DWORD PTR _first_fe$[ebp]
	mov	eax, DWORD PTR _web+460
	mov	edi, DWORD PTR tv1988[ebp]
	shr	ebx, 27					; 0000001bH
	and	ebx, 1
	mov	DWORD PTR tv1996[ebp], ebx
	je	SHORT $LN95@cross_cut
	mov	edx, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [edx+32]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN94@cross_cut
$LN95@cross_cut:
	mov	ecx, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [ecx+28]
$LN94@cross_cut:
	mov	esi, DWORD PTR _new_fe_old$[ebp]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN98@cross_cut
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN99@cross_cut
	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [eax+28], edx
	jmp	SHORT $LN213@cross_cut
$LN99@cross_cut:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ecx+32], esi
$LN213@cross_cut:
	mov	eax, DWORD PTR _web+460
$LN98@cross_cut:

; 1188 :   set_prev_edge(new_fe_old,get_prev_edge(first_fe));

	test	ebx, ebx
	je	SHORT $LN104@cross_cut
	mov	edx, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [edx+32]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN103@cross_cut
$LN104@cross_cut:
	mov	ecx, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [ecx+28]
$LN103@cross_cut:
	mov	edx, esi
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	DWORD PTR tv2262[ebp], edx
	je	SHORT $LN187@cross_cut
	mov	edx, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN108@cross_cut
	xor	ecx, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [eax+32], ecx
	jmp	SHORT $LN107@cross_cut
$LN108@cross_cut:
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [eax+28], ecx
$LN107@cross_cut:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	eax, DWORD PTR _web+460
$LN187@cross_cut:

; 1189 :   set_prev_edge(get_next_edge(last_fe),new_fe_old);

	mov	edi, DWORD PTR _last_fe$[ebp]
	mov	ebx, DWORD PTR tv2008[ebp]
	shr	edi, 27					; 0000001bH
	and	edi, 1
	mov	DWORD PTR tv2278[ebp], edi
	je	SHORT $LN113@cross_cut
	mov	ecx, DWORD PTR [ebx+eax]
	mov	ecx, DWORD PTR [ecx+28]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN112@cross_cut
$LN113@cross_cut:
	mov	edx, DWORD PTR [ebx+eax]
	mov	ecx, DWORD PTR [edx+32]
$LN112@cross_cut:
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN197@cross_cut
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN117@cross_cut
	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [eax+32], edx
	jmp	SHORT $LN116@cross_cut
$LN117@cross_cut:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ecx+28], esi
$LN116@cross_cut:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	eax, DWORD PTR _web+460
$LN197@cross_cut:

; 1190 :   set_next_edge(new_fe_old,get_next_edge(last_fe));

	test	edi, edi
	je	SHORT $LN122@cross_cut
	mov	edx, DWORD PTR [ebx+eax]
	mov	ecx, DWORD PTR [edx+28]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN121@cross_cut
$LN122@cross_cut:
	mov	ecx, DWORD PTR [ebx+eax]
	mov	ecx, DWORD PTR [ecx+32]
$LN121@cross_cut:
	cmp	DWORD PTR tv2262[ebp], 0
	je	SHORT $LN125@cross_cut
	mov	edx, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN126@cross_cut
	xor	ecx, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [eax+28], ecx
	jmp	SHORT $LN203@cross_cut
$LN126@cross_cut:
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [eax+32], ecx
$LN203@cross_cut:
	mov	eax, DWORD PTR _web+460
$LN125@cross_cut:

; 1191 :   set_prev_edge(first_fe,new_fe_new);

	cmp	DWORD PTR tv1985[ebp], 0
	je	SHORT $LN190@cross_cut
	cmp	DWORD PTR tv1996[ebp], 0
	je	SHORT $LN131@cross_cut
	mov	ecx, DWORD PTR _new_fe_new$[ebp]
	mov	edi, DWORD PTR tv1988[ebp]
	mov	eax, DWORD PTR [edi+eax]
	mov	edx, ecx
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [eax+32], edx
	jmp	SHORT $LN130@cross_cut
$LN131@cross_cut:
	mov	ecx, DWORD PTR tv1988[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR _new_fe_new$[ebp]
	mov	DWORD PTR [edx+28], ecx
$LN130@cross_cut:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	eax, DWORD PTR _web+460
	jmp	SHORT $LN133@cross_cut
$LN190@cross_cut:
	mov	ecx, DWORD PTR _new_fe_new$[ebp]
$LN133@cross_cut:

; 1192 :   set_next_edge(new_fe_new,first_fe);

	mov	edi, ecx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	mov	DWORD PTR tv2307[ebp], edi
	je	SHORT $LN135@cross_cut
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN136@cross_cut
	mov	edx, DWORD PTR _first_fe$[ebp]
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR tv1826[ebp], edx
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR tv1826[ebp]
	mov	DWORD PTR [eax+28], edx
	jmp	SHORT $LN204@cross_cut
$LN136@cross_cut:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _first_fe$[ebp]
	mov	DWORD PTR [eax+32], edx
$LN204@cross_cut:
	mov	eax, DWORD PTR _web+460
$LN135@cross_cut:

; 1193 :   set_next_edge(last_fe,new_fe_new);

	mov	edx, DWORD PTR _last_fe$[ebp]
	test	edx, 268435456				; 10000000H
	je	SHORT $LN140@cross_cut
	cmp	DWORD PTR tv2278[ebp], 0
	je	SHORT $LN141@cross_cut
	mov	eax, DWORD PTR [ebx+eax]
	mov	edx, ecx
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [eax+28], edx
	jmp	SHORT $LN205@cross_cut
$LN141@cross_cut:
	mov	edx, DWORD PTR [ebx+eax]
	mov	DWORD PTR [edx+32], ecx
$LN205@cross_cut:
	mov	edx, DWORD PTR _last_fe$[ebp]
	mov	eax, DWORD PTR _web+460
$LN140@cross_cut:

; 1194 :   set_prev_edge(new_fe_new,last_fe);

	test	edi, edi
	je	SHORT $LN148@cross_cut
	mov	ebx, ecx
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN146@cross_cut
	xor	edx, 134217728				; 08000000H
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [eax+32], edx
	jmp	SHORT $LN145@cross_cut
$LN146@cross_cut:
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [eax+28], edx
$LN145@cross_cut:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	eax, DWORD PTR _web+460
$LN148@cross_cut:

; 1195 :   set_next_facet(new_fe_new,fe_inverse(new_fe_old));

	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	test	edi, edi
	je	SHORT $LN198@cross_cut
	mov	ebx, ecx
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN151@cross_cut
	mov	edi, edx
	xor	edi, 134217728				; 08000000H
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [eax+36], edi
	mov	edi, DWORD PTR tv2307[ebp]
	jmp	SHORT $LN207@cross_cut
$LN151@cross_cut:
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [eax+40], edx
$LN207@cross_cut:
	mov	eax, DWORD PTR _web+460

; 1196 :   set_prev_facet(new_fe_new,fe_inverse(new_fe_old));

	test	edi, edi
	je	SHORT $LN198@cross_cut
	mov	edi, ecx
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN156@cross_cut
	xor	edx, 134217728				; 08000000H
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [eax+40], edx
	jmp	SHORT $LN155@cross_cut
$LN156@cross_cut:
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [eax+36], edx
$LN155@cross_cut:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	eax, DWORD PTR _web+460
$LN198@cross_cut:

; 1197 :   set_next_facet(new_fe_old,fe_inverse(new_fe_new));

	mov	edx, DWORD PTR tv2262[ebp]
	xor	ecx, 134217728				; 08000000H
	test	edx, edx
	je	SHORT $LN168@cross_cut
	test	esi, 134217728				; 08000000H
	je	SHORT $LN161@cross_cut
	mov	edi, ecx
	xor	edi, 134217728				; 08000000H
	mov	ebx, esi
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [eax+36], edi
	jmp	SHORT $LN209@cross_cut
$LN161@cross_cut:
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [eax+40], ecx
$LN209@cross_cut:
	mov	eax, DWORD PTR _web+460

; 1198 :   set_prev_facet(new_fe_old,fe_inverse(new_fe_new));

	test	edx, edx
	je	SHORT $LN168@cross_cut
	test	esi, 134217728				; 08000000H
	je	SHORT $LN166@cross_cut
	xor	ecx, 134217728				; 08000000H
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [edx+40], ecx
	jmp	SHORT $LN165@cross_cut
$LN166@cross_cut:
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [eax+36], ecx
$LN165@cross_cut:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN168@cross_cut:

; 1199 : 
; 1200 :   if ( attr & BOUNDARY )

	mov	ebx, DWORD PTR _attr$[ebp]
	mov	eax, ebx
	mov	esi, 128				; 00000080H
	and	eax, esi
	xor	ecx, ecx
	or	eax, ecx
	je	$LN188@cross_cut

; 1201 :   { struct boundary *bdry = get_facet_boundary(old_f);

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN31@cross_cut
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR tv2000[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [edx+eax]
	imul	edx, 136				; 00000088H
	add	edx, DWORD PTR _web+776
	jmp	SHORT $LN210@cross_cut
$LN31@cross_cut:
	xor	edx, edx
$LN210@cross_cut:

; 1202 :     REAL *paramb,*parammid;
; 1203 :     REAL *mu,*mv;
; 1204 : 
; 1205 :     set_attr(new_e,BOUNDARY);

	mov	ecx, DWORD PTR _new_e$[ebp]
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR tv2071[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	edi, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], edi

; 1206 :     set_edge_boundary_num(new_e,bdry->num);

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	mov	DWORD PTR _bdry$90032[ebp], edx
	test	eax, eax
	je	SHORT $LN195@cross_cut
	mov	edi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edi+64]
	mov	edi, DWORD PTR _web+124
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [edx+44]
	mov	DWORD PTR [eax+ecx], edi
	mov	ecx, DWORD PTR tv2071[ebp]
$LN195@cross_cut:

; 1207 :     if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	$LN188@cross_cut

; 1208 :     { vertex_id divider = get_edge_midv(new_e); 

	mov	edi, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edi+304]
	mov	edi, DWORD PTR _web+124
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	eax, DWORD PTR [eax+ecx+8]

; 1209 :       set_attr(divider,BOUNDARY);

	mov	ecx, eax
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	eax, DWORD PTR _web[eax+12]
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [eax+ecx]
	or	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], esi

; 1210 :       set_boundary_num(divider,bdry->num);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN35@cross_cut
	mov	esi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [eax+esi+64]
	mov	esi, DWORD PTR _web+12
	mov	esi, DWORD PTR [ecx+esi]
	mov	DWORD PTR [eax+esi], edx
	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
$LN35@cross_cut:

; 1211 : 
; 1212 :       /* find parameters of new midpoint */
; 1213 :       mv = get_coord(divider);

	mov	edi, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+12
	mov	esi, DWORD PTR [edi+ebx+64]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR tv2402[ebp], esi
	add	esi, ecx
	mov	DWORD PTR _mv$90040[ebp], esi

; 1214 :       parammid = get_param(divider);

	mov	esi, DWORD PTR [edi+ebx+544]
	mov	DWORD PTR tv2406[ebp], esi
	add	esi, ecx
	mov	DWORD PTR _parammid$90038[ebp], esi

; 1215 :       if ( (get_boundary(headv) != bdry) && (get_boundary(tailv) != bdry) )

	test	eax, eax
	je	SHORT $LN37@cross_cut
	mov	esi, DWORD PTR tv2055[ebp]
	mov	esi, DWORD PTR [edx+esi*4]
	mov	ecx, eax
	imul	ecx, 240				; 000000f0H
	add	ecx, edi
	mov	ecx, DWORD PTR [ecx+ebx+64]
	mov	ecx, DWORD PTR [ecx+esi]
	imul	ecx, 136				; 00000088H
	add	ecx, DWORD PTR _web+776
	jmp	SHORT $LN38@cross_cut
$LN37@cross_cut:
	xor	ecx, ecx
$LN38@cross_cut:
	mov	esi, DWORD PTR _tailv$[ebp]
	cmp	ecx, DWORD PTR _bdry$90032[ebp]
	je	$LN193@cross_cut
	test	eax, eax
	je	SHORT $LN39@cross_cut
	mov	ebx, eax
	imul	ebx, 240				; 000000f0H
	add	ebx, edi
	mov	edi, ebx
	mov	ebx, DWORD PTR _dymem
	mov	edi, DWORD PTR [edi+ebx+64]
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+edi]
	mov	edi, DWORD PTR _web+104
	imul	ecx, 136				; 00000088H
	add	ecx, DWORD PTR _web+776
	jmp	SHORT $LN40@cross_cut
$LN39@cross_cut:
	xor	ecx, ecx
$LN40@cross_cut:
	cmp	ecx, DWORD PTR _bdry$90032[ebp]
	je	$LN193@cross_cut

; 1216 :       { sprintf(errmsg,
; 1217 :            "Vertices %s and %s are on different boundaries from edge %s.\n",
; 1218 :               ELNAME(headv),ELNAME1(tailv),ELNAME2(new_e));

	mov	ebx, 268435456				; 10000000H
	test	DWORD PTR _new_e$[ebp], ebx
	je	SHORT $LN41@cross_cut
	mov	edx, DWORD PTR tv2071[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	edi, OFFSET _elnames+60
	jmp	SHORT $LN42@cross_cut
$LN41@cross_cut:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN42@cross_cut:
	test	esi, ebx
	je	SHORT $LN43@cross_cut
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN44@cross_cut
$LN43@cross_cut:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN44@cross_cut:
	test	DWORD PTR _headv$[ebp], ebx
	je	SHORT $LN45@cross_cut
	mov	eax, DWORD PTR tv2055[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN46@cross_cut
$LN45@cross_cut:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN46@cross_cut:
	push	edi
	push	esi
	push	eax
	push	OFFSET ??_C@_0DO@FKBHOCNE@Vertices?5?$CFs?5and?5?$CFs?5are?5on?5differ@
	push	OFFSET _errmsg
	call	_sprintf

; 1219 :         kb_error(1939,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1939					; 00000793H
	call	_kb_error
	add	esp, 32					; 00000020H

; 1220 :       }
; 1221 :       else

	jmp	SHORT $LN211@cross_cut
$LN193@cross_cut:

; 1222 : #ifdef PARAMAVG
; 1223 :       if ( (get_boundary(headv) == bdry) && (get_boundary(tailv) == bdry) )
; 1224 :       { mu = get_coord(tailv);
; 1225 :         parama = get_param(tailv);
; 1226 :         paramb = get_param(headv);
; 1227 :         /* projecting on tangent */
; 1228 :         b_extrapolate(bdry,mu,mv,mv,parama,parammid,tailv);
; 1229 :         /* if not wrapped, take average parameter */
; 1230 :         for (  i = 0 ; i < bdry->pcount ; i++ )
; 1231 :         { if ( ((parama[i] < parammid[i]) && (parammid[i] < paramb[i]))
; 1232 :              || ((parama[i] > parammid[i]) && (parammid[i] > paramb[i])))
; 1233 :              parammid[i] = (parama[i] + paramb[i])/2;
; 1234 :         }
; 1235 :       }
; 1236 :       else
; 1237 : #endif
; 1238 :       if ( get_boundary(headv) == bdry )

	test	eax, eax
	je	SHORT $LN47@cross_cut
	imul	eax, 240				; 000000f0H
	add	eax, edi
	mov	ecx, DWORD PTR [eax+ebx+64]
	mov	eax, DWORD PTR tv2055[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN48@cross_cut
$LN47@cross_cut:
	xor	eax, eax
$LN48@cross_cut:
	cmp	eax, DWORD PTR _bdry$90032[ebp]
	jne	SHORT $LN4@cross_cut

; 1239 :       { mu = get_coord(headv);
; 1240 :         paramb = get_param(headv);

	mov	ecx, DWORD PTR tv2055[ebp]

; 1241 :         /* projecting on tangent */
; 1242 :         b_extrapolate(bdry,mu,mv,mv,paramb,parammid,headv);

	mov	eax, DWORD PTR _headv$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	push	eax

; 1243 :       }
; 1244 :       else

	jmp	SHORT $LN212@cross_cut
$LN4@cross_cut:

; 1245 :       { mu = get_coord(tailv);
; 1246 :         paramb = get_param(tailv);

	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]

; 1247 :         /* projecting on tangent */
; 1248 :         b_extrapolate(bdry,mu,mv,mv,paramb,parammid,tailv);

	push	esi
$LN212@cross_cut:
	mov	ecx, DWORD PTR _parammid$90038[ebp]
	mov	eax, DWORD PTR tv2406[ebp]
	push	ecx
	lea	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _mv$90040[ebp]
	add	edx, DWORD PTR tv2402[ebp]
	push	ecx
	mov	ecx, DWORD PTR _bdry$90032[ebp]
	push	eax
	push	eax
	push	edx
	push	ecx
	call	_b_extrapolate
	add	esp, 28					; 0000001cH
$LN211@cross_cut:
	mov	ebx, DWORD PTR _attr$[ebp]
$LN188@cross_cut:

; 1249 :       }
; 1250 :     }
; 1251 :   }
; 1252 :   if ( attr & CONSTRAINT )    

	mov	eax, ebx
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN186@cross_cut

; 1253 :   { ATTR cattr = attr & (BDRY_ENERGY | BDRY_CONTENT | CONSTRAINT );
; 1254 :     conmap_t * conmap = get_f_constraint_map(old_f);

	mov	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	and	ebx, 5632				; 00001600H
	cmp	DWORD PTR [eax+edx+88], ecx
	je	SHORT $LN49@cross_cut
	mov	esi, DWORD PTR _web+236
	mov	edi, DWORD PTR tv2000[ebp]
	mov	edi, DWORD PTR [edi+esi]
	add	edi, DWORD PTR [eax+edx+64]
	jmp	SHORT $LN50@cross_cut
$LN49@cross_cut:
	mov	edi, OFFSET _nullcon
$LN50@cross_cut:

; 1255 : 
; 1256 :     set_attr(new_e,cattr);

	mov	edx, DWORD PTR _new_e$[ebp]
	mov	esi, DWORD PTR tv2071[ebp]
	mov	eax, edx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	eax, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [eax+esi*4]
	or	DWORD PTR [eax+8], ebx
	or	DWORD PTR [eax+12], ecx

; 1257 :     set_e_conmap(new_e,conmap);

	push	edi
	push	edx
	call	_set_e_conmap
	add	esp, 8

; 1258 :     if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	SHORT $LN186@cross_cut

; 1259 :     { vertex_id mid = get_edge_midv(new_e);

	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [ecx+edx+304]
	mov	ecx, DWORD PTR _web+124
	mov	edx, esi
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	esi, DWORD PTR [eax+ecx+8]

; 1260 :       set_attr(mid,cattr);

	mov	edx, esi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	or	DWORD PTR [eax+8], ebx
	xor	ecx, ecx
	or	DWORD PTR [eax+12], ecx

; 1261 :       set_v_conmap(mid,conmap);

	push	edi
	push	esi
	call	_set_v_conmap

; 1262 :       project_v_constr(mid,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	push	1
	push	1
	push	esi
	call	_project_v_constr
	add	esp, 20					; 00000014H
$LN186@cross_cut:

; 1263 :     }
; 1264 :   }
; 1265 :  top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp

; 1266 : 
; 1267 : } /* end cross_cut() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	inc	eax
	pop	esi
	xor	ecx, ebp
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_cross_cut ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@IDMKIDAH@facet_crosscut?3?5vertices?5?$CFs?0?$CFs?5n@ ; `string'
PUBLIC	_old_f$GSCopy$
PUBLIC	_headv$GSCopy$
PUBLIC	_tailv$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_facet_crosscut
;	COMDAT ??_C@_0DA@IDMKIDAH@facet_crosscut?3?5vertices?5?$CFs?0?$CFs?5n@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DA@IDMKIDAH@facet_crosscut?3?5vertices?5?$CFs?0?$CFs?5n@ DB 'facet'
	DB	'_crosscut: vertices %s,%s not on facet %s', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _facet_crosscut
_TEXT	SEGMENT
_attr$ = -120						; size = 8
tv2600 = -112						; size = 4
_tailv$GSCopy$ = -108					; size = 4
tv2432 = -104						; size = 4
_headv$GSCopy$ = -100					; size = 4
tv2486 = -96						; size = 4
_bdry$90300 = -92					; size = 4
_new_fe_old$ = -92					; size = 4
tv2718 = -88						; size = 4
tv2517 = -88						; size = 4
_parammid$90306 = -88					; size = 4
_head_fe_neg$ = -84					; size = 4
_tail_fe_neg$ = -80					; size = 4
tv2612 = -76						; size = 4
_tail_fe$ = -76						; size = 4
tv2886 = -72						; size = 4
_new_f$ = -72						; size = 4
_new_e$ = -68						; size = 4
_start_fe$ = -68					; size = 4
_head_fe$ = -64						; size = 4
tv2890 = -60						; size = 4
tv2702 = -60						; size = 4
tv2559 = -60						; size = 4
_start_e$ = -60						; size = 4
_old_f$GSCopy$ = -56					; size = 4
_mv$90308 = -56						; size = 4
_wrap$ = -56						; size = 4
_temp$90274 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_old_f$ = 8						; size = 4
_tailv$ = 12						; size = 4
_headv$ = 16						; size = 4
_facet_crosscut PROC					; COMDAT

; 1283 : { facetedge_id tail_fe,tail_fe_neg,head_fe,head_fe_neg;

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _tailv$[ebp]

; 1284 :   edge_id start_e,e_id,new_e;
; 1285 :   facetedge_id fe,start_fe;
; 1286 :   facet_id new_f;
; 1287 :   facet_id new_fe_old,new_fe_new;
; 1288 :   ATTR attr;
; 1289 :   int wrap;
; 1290 : 
; 1291 :   // find appropriate fe so cross_cut can be used.
; 1292 :   // tail
; 1293 :   start_e = get_vertex_edge(tailv);

	mov	edx, DWORD PTR _headv$[ebp]
	mov	ecx, DWORD PTR _old_f$[ebp]
	mov	DWORD PTR _tailv$GSCopy$[ebp], eax
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR _headv$GSCopy$[ebp], edx
	mov	edx, DWORD PTR _web+12
	push	ebx

; 1294 :   e_id = start_e;
; 1295 :   tail_fe = NULLID;

	mov	ebx, DWORD PTR _web+460
	push	esi
	mov	DWORD PTR tv2432[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+28]
	mov	esi, ecx
	push	edi

; 1434 :       set_facet_fe(new_f,new_fe_new);

	mov	DWORD PTR _old_f$GSCopy$[ebp], ecx
	mov	DWORD PTR _start_e$[ebp], edx
	mov	DWORD PTR _tail_fe$[ebp], 0
	or	esi, 134217728				; 08000000H
$LL84@facet_cros:

; 1296 :   do
; 1297 :   { fe = start_fe = get_edge_fe(e_id);

	mov	eax, DWORD PTR _web+124
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+ecx*4]
	test	edi, edi
	jne	SHORT $LN114@facet_cros
	xor	eax, eax
	jmp	SHORT $LN113@facet_cros
$LN114@facet_cros:
	mov	eax, DWORD PTR [edi+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN113@facet_cros
	xor	eax, 134217728				; 08000000H
$LN113@facet_cros:
	mov	DWORD PTR _start_fe$[ebp], eax
	npad	4
$LL115@facet_cros:

; 1298 :     do
; 1299 :     { if ( equal_element(get_fe_facet(fe),old_f) )

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN118@facet_cros
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN117@facet_cros
$LN118@facet_cros:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN117@facet_cros
	xor	ecx, 134217728				; 08000000H
$LN117@facet_cros:
	or	ecx, 134217728				; 08000000H
	cmp	ecx, esi
	je	SHORT $LN266@facet_cros

; 1301 :         break;
; 1302 :       }
; 1303 :       fe = get_next_facet(fe);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN122@facet_cros
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN80@facet_cros
$LN122@facet_cros:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [ecx+40]
$LN80@facet_cros:

; 1304 :     } while ( !equal_id(fe,start_fe));

	cmp	eax, DWORD PTR _start_fe$[ebp]
	jne	SHORT $LL115@facet_cros
	jmp	SHORT $LN79@facet_cros
$LN266@facet_cros:

; 1300 :       { tail_fe = fe;

	mov	DWORD PTR _tail_fe$[ebp], eax
$LN79@facet_cros:

; 1305 :     e_id = get_next_tail_edge(e_id);

	shr	edx, 27					; 0000001bH
	and	edx, 1

; 1306 :   } while ( (tail_fe == NULLID ) && !equal_id(e_id,start_e));

	cmp	DWORD PTR _tail_fe$[ebp], 0
	mov	edx, DWORD PTR [edi+edx*4+32]
	jne	SHORT $LN77@facet_cros
	cmp	edx, DWORD PTR _start_e$[ebp]
	jne	$LL84@facet_cros
$LN77@facet_cros:

; 1307 : 
; 1308 :   // head
; 1309 :   start_e = get_vertex_edge(headv);

	mov	eax, DWORD PTR _headv$GSCopy$[ebp]
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv2486[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+28]
	mov	DWORD PTR _start_e$[ebp], edx

; 1310 :   e_id = start_e;
; 1311 :   head_fe = NULLID;

	mov	DWORD PTR _head_fe$[ebp], 0
	npad	4
$LL76@facet_cros:

; 1312 :   do
; 1313 :   { fe = start_fe = get_edge_fe(e_id);

	mov	eax, DWORD PTR _web+124
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+ecx*4]
	test	edi, edi
	jne	SHORT $LN128@facet_cros
	xor	eax, eax
	jmp	SHORT $LN127@facet_cros
$LN128@facet_cros:
	mov	eax, DWORD PTR [edi+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN127@facet_cros
	xor	eax, 134217728				; 08000000H
$LN127@facet_cros:
	mov	DWORD PTR _start_fe$[ebp], eax
	npad	5
$LL129@facet_cros:

; 1314 :     do
; 1315 :     { if ( equal_element(get_fe_facet(fe),old_f) )

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN132@facet_cros
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN131@facet_cros
$LN132@facet_cros:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN131@facet_cros
	xor	ecx, 134217728				; 08000000H
$LN131@facet_cros:
	or	ecx, 134217728				; 08000000H
	cmp	ecx, esi
	je	SHORT $LN267@facet_cros

; 1317 :         break;
; 1318 :       }
; 1319 :       fe = get_next_facet(fe);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN136@facet_cros
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN72@facet_cros
$LN136@facet_cros:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [ecx+40]
$LN72@facet_cros:

; 1320 :     } while ( !equal_id(fe,start_fe));

	cmp	eax, DWORD PTR _start_fe$[ebp]
	jne	SHORT $LL129@facet_cros
	jmp	SHORT $LN71@facet_cros
$LN267@facet_cros:

; 1316 :       { head_fe = fe;

	mov	DWORD PTR _head_fe$[ebp], eax
$LN71@facet_cros:

; 1321 :     e_id = get_next_tail_edge(e_id);

	shr	edx, 27					; 0000001bH
	and	edx, 1

; 1322 :   } while ( (head_fe == NULLID ) && !equal_id(e_id,start_e));

	cmp	DWORD PTR _head_fe$[ebp], 0
	mov	edx, DWORD PTR [edi+edx*4+32]
	jne	SHORT $LN69@facet_cros
	cmp	edx, DWORD PTR _start_e$[ebp]
	jne	$LL76@facet_cros
$LN69@facet_cros:

; 1323 : 
; 1324 :   // see what we found
; 1325 :   if ( (tail_fe == NULLID) && (head_fe == NULLID) )

	mov	esi, DWORD PTR _tail_fe$[ebp]
	test	esi, esi
	jne	$LN284@facet_cros
	cmp	DWORD PTR _head_fe$[ebp], esi
	jne	$LN284@facet_cros

; 1326 :   { sprintf(errmsg,"facet_crosscut: vertices %s,%s not on facet %s\n",
; 1327 :        ELNAME(tailv),ELNAME2(headv),ELNAME3(old_f));

	test	DWORD PTR _old_f$GSCopy$[ebp], 268435456 ; 10000000H
	je	SHORT $LN87@facet_cros
	mov	edx, DWORD PTR _old_f$GSCopy$[ebp]
	and	edx, 134217727				; 07ffffffH
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+90
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	edi, OFFSET _elnames+90
	jmp	SHORT $LN88@facet_cros
$LN87@facet_cros:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN88@facet_cros:
	test	DWORD PTR _headv$GSCopy$[ebp], 268435456 ; 10000000H
	je	SHORT $LN89@facet_cros
	mov	eax, DWORD PTR tv2486[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	ebx, OFFSET _elnames+60
	jmp	SHORT $LN90@facet_cros
$LN89@facet_cros:
	mov	ebx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN90@facet_cros:
	test	DWORD PTR _tailv$GSCopy$[ebp], 268435456 ; 10000000H
	je	SHORT $LN91@facet_cros
	mov	ecx, DWORD PTR tv2432[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN92@facet_cros
$LN91@facet_cros:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN92@facet_cros:
	push	edi
	push	ebx
	push	eax
	push	OFFSET ??_C@_0DA@IDMKIDAH@facet_crosscut?3?5vertices?5?$CFs?0?$CFs?5n@
	push	OFFSET _errmsg
	call	_sprintf

; 1328 :     kb_error(5678,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5678					; 0000162eH
	call	_kb_error
	mov	ebx, DWORD PTR _web+460
	add	esp, 32					; 00000020H
$LN284@facet_cros:

; 1329 :   }
; 1330 :   if ( valid_id(tail_fe) )

	test	esi, 268435456				; 10000000H
	je	SHORT $LN67@facet_cros

; 1331 :   { facet_id tailfpos = get_fe_facet(tail_fe);

	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, esi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	je	SHORT $LN285@facet_cros
	xor	edx, 134217728				; 08000000H
$LN285@facet_cros:

; 1332 :     tail_fe_neg = get_prev_edge(tail_fe);
; 1333 :     if ( inverted(tailfpos) )

	test	edx, 134217728				; 08000000H
	je	SHORT $LN66@facet_cros

; 1334 :     { tail_fe_neg = inverse_id(tail_fe);

	xor	esi, 134217728				; 08000000H
	mov	eax, esi
	mov	DWORD PTR _tail_fe_neg$[ebp], eax

; 1335 :       tail_fe = get_next_edge(tail_fe_neg);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN150@facet_cros
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _tail_fe$[ebp], eax
	jmp	SHORT $LN64@facet_cros
$LN150@facet_cros:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _tail_fe$[ebp], edx

; 1336 :     }
; 1337 :     else

	jmp	SHORT $LN64@facet_cros
$LN66@facet_cros:

; 1338 :       tail_fe_neg = get_prev_edge(tail_fe);

	test	eax, eax
	je	SHORT $LN154@facet_cros
	mov	ecx, DWORD PTR [ecx+32]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR _tail_fe_neg$[ebp], ecx
	jmp	SHORT $LN64@facet_cros
$LN154@facet_cros:
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _tail_fe_neg$[ebp], eax

; 1339 :   }
; 1340 :   else

	jmp	SHORT $LN64@facet_cros
$LN67@facet_cros:

; 1341 :   { tail_fe_neg = NULLID;

	mov	DWORD PTR _tail_fe_neg$[ebp], 0
$LN64@facet_cros:

; 1342 :   }
; 1343 :   if ( valid_id(head_fe) )

	mov	eax, DWORD PTR _head_fe$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN63@facet_cros

; 1344 :   { facet_id headfpos = get_fe_facet(head_fe);

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	edx, DWORD PTR [ecx+24]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	je	SHORT $LN289@facet_cros
	xor	edx, 134217728				; 08000000H
$LN289@facet_cros:

; 1345 :     head_fe_neg = get_prev_edge(head_fe);
; 1346 :     if ( inverted(headfpos) )

	test	edx, 134217728				; 08000000H
	je	SHORT $LN62@facet_cros

; 1347 :     { head_fe_neg = inverse_id(head_fe);

	mov	edi, DWORD PTR _head_fe$[ebp]
	xor	edi, 134217728				; 08000000H
	mov	DWORD PTR _head_fe_neg$[ebp], edi

; 1348 :       head_fe = get_next_edge(head_fe_neg);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN166@facet_cros
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+edx*4]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _head_fe$[ebp], eax
	jmp	SHORT $LN60@facet_cros
$LN166@facet_cros:
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+ecx*4]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _head_fe$[ebp], eax

; 1349 :     }
; 1350 :     else

	jmp	SHORT $LN60@facet_cros
$LN62@facet_cros:

; 1351 :       head_fe_neg = get_prev_edge(head_fe);

	test	eax, eax
	je	SHORT $LN170@facet_cros
	mov	edi, DWORD PTR [ecx+32]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN294@facet_cros
$LN170@facet_cros:
	mov	edi, DWORD PTR [ecx+28]

; 1352 :   }
; 1353 :   else

	jmp	SHORT $LN294@facet_cros
$LN63@facet_cros:

; 1354 :   { head_fe_neg = NULLID;

	xor	edi, edi
$LN294@facet_cros:
	mov	DWORD PTR _head_fe_neg$[ebp], edi
$LN60@facet_cros:

; 1355 :   }
; 1356 : 
; 1357 :   // stuff modified from cross_cut()
; 1358 :   attr = get_fattr(old_f);

	mov	ecx, DWORD PTR _old_f$GSCopy$[ebp]
	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax

; 1359 :   new_e = new_edge(tailv,headv,old_f);

	push	ecx
	mov	ecx, DWORD PTR _headv$GSCopy$[ebp]
	mov	DWORD PTR tv2600[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	mov	ebx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _tailv$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax+12]
	push	ecx
	push	edx
	mov	DWORD PTR _attr$[ebp], ebx
	mov	DWORD PTR _attr$[ebp+4], eax
	call	_new_edge
	mov	esi, eax

; 1360 :   if ( attr & FIXED )

	mov	eax, ebx
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	or	eax, ecx
	mov	DWORD PTR _new_e$[ebp], esi
	je	$LN281@facet_cros

; 1361 :   { set_attr(new_e,FIXED);

	mov	ecx, esi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 64			; 00000040H
	mov	DWORD PTR [ecx+12], edx

; 1362 :     if ( web.modeltype == QUADRATIC )

	mov	ecx, DWORD PTR _web+628
	cmp	ecx, 2
	jne	SHORT $LN58@facet_cros

; 1363 :         set_attr(get_edge_midv(new_e),FIXED);

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax+8]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax+12], ecx
	jmp	SHORT $LN281@facet_cros
$LN58@facet_cros:

; 1364 :     else if ( web.modeltype == LAGRANGE )

	cmp	ecx, 3
	jne	SHORT $LN281@facet_cros

; 1365 :     { int i;
; 1366 :       vertex_id *v = get_edge_vertices(new_e);

	mov	edx, DWORD PTR _web+124
	mov	edx, DWORD PTR [eax+edx]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	add	edx, DWORD PTR [eax+ecx+304]

; 1367 :       for ( i = 1 ; i < web.lagrange_order ; i++ )

	mov	ecx, 1
	cmp	DWORD PTR _web+632, ecx
	jle	SHORT $LN281@facet_cros
	npad	5
$LL55@facet_cros:

; 1368 :           set_attr(v[i],FIXED);

	mov	eax, DWORD PTR [edx+ecx*4]
	mov	edi, eax
	shr	edi, 29					; 0000001dH
	imul	edi, 112				; 00000070H
	mov	edi, DWORD PTR _web[edi+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 64			; 00000040H
	inc	ecx
	mov	DWORD PTR [eax+12], edi
	cmp	ecx, DWORD PTR _web+632
	jl	SHORT $LL55@facet_cros

; 1367 :       for ( i = 1 ; i < web.lagrange_order ; i++ )

	mov	edi, DWORD PTR _head_fe_neg$[ebp]
$LN281@facet_cros:

; 1369 :     }
; 1370 :   }
; 1371 :   if ( attr & NO_REFINE ) set_attr(new_e,NO_REFINE);

	mov	eax, ebx
	and	eax, 16777216				; 01000000H
	xor	ecx, ecx
	xor	ebx, ebx
	or	eax, ecx
	je	SHORT $LN179@facet_cros
	mov	edx, esi
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+12]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 16777216		; 01000000H
	mov	DWORD PTR [eax+12], edx
$LN179@facet_cros:

; 1372 : 
; 1373 :   // see if we need a new facet
; 1374 :   if ( (valid_id(tail_fe) || valid_id(head_fe_neg))
; 1375 :     && (valid_id(head_fe) || valid_id(tail_fe_neg)) )

	mov	eax, DWORD PTR _tail_fe$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv2517[ebp], eax
	jne	SHORT $LN290@facet_cros
	test	edi, 268435456				; 10000000H
	je	SHORT $LN288@facet_cros
$LN290@facet_cros:
	mov	eax, DWORD PTR _head_fe$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv2559[ebp], eax
	jne	SHORT $LN49@facet_cros
	test	DWORD PTR _tail_fe_neg$[ebp], 268435456	; 10000000H
	jne	SHORT $LN49@facet_cros
$LN288@facet_cros:

; 1383 : 
; 1384 :   }
; 1385 :   else
; 1386 :   { new_f = NULLID;
; 1387 :     new_fe_new = NULLID;
; 1388 :     if ( !valid_id(head_fe) && !valid_id(tail_fe_neg) )

	mov	eax, DWORD PTR _head_fe$[ebp]
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _new_f$[ebp], ebx
	mov	DWORD PTR tv2559[ebp], eax
	jne	SHORT $LN46@facet_cros
	test	DWORD PTR _tail_fe_neg$[ebp], 268435456	; 10000000H
	jne	SHORT $LN46@facet_cros

; 1389 :     { // reverse order of head and tail
; 1390 :       new_fe_old = new_facetedge(inverse_id(old_f),new_e);

	mov	eax, DWORD PTR _old_f$GSCopy$[ebp]
	xor	eax, 134217728				; 08000000H
	push	esi
	push	eax
	call	_new_facetedge
	mov	edi, eax

; 1391 :       set_edge_fe(new_e,new_fe_old);

	push	edi
	push	esi
	mov	DWORD PTR _new_fe_old$[ebp], edi
	call	_set_edge_fe
	add	esp, 16					; 00000010H

; 1392 :     }
; 1393 :     else

	jmp	$LN185@facet_cros
$LN46@facet_cros:

; 1394 :     { new_fe_old = new_facetedge(old_f,new_e);

	mov	ecx, DWORD PTR _old_f$GSCopy$[ebp]
	push	esi
	push	ecx
	call	_new_facetedge
	add	esp, 8
	mov	edi, eax
	mov	DWORD PTR _new_fe_old$[ebp], edi

; 1395 :       set_edge_fe(new_e,new_fe_old);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN274@facet_cros
	xor	eax, 134217728				; 08000000H
$LN274@facet_cros:
	mov	edx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN295@facet_cros
$LN49@facet_cros:

; 1376 :   { new_fe_old = new_facetedge(old_f,new_e); 

	mov	ebx, DWORD PTR _old_f$GSCopy$[ebp]
	push	esi
	push	ebx
	call	_new_facetedge
	mov	edi, eax

; 1377 :     new_f = dup_facet(old_f); /* copy facet data */

	push	ebx
	mov	DWORD PTR _new_fe_old$[ebp], edi
	call	_dup_facet

; 1378 :     new_fe_new = new_facetedge(new_f,inverse_id(new_e));

	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	push	edx
	push	eax
	mov	DWORD PTR _new_f$[ebp], eax
	call	_new_facetedge
	add	esp, 20					; 00000014H

; 1379 : //    set_facet_body(new_f,get_facet_body(old_f));
; 1380 : //    set_facet_body(facet_inverse(new_f),get_facet_body(facet_inverse(old_f)));
; 1381 :     if ( phase_flag ) set_f_phase_density(new_f);

	cmp	DWORD PTR _phase_flag, 0
	mov	ebx, eax
	je	SHORT $LN48@facet_cros
	mov	eax, DWORD PTR _new_f$[ebp]
	push	eax
	call	_set_f_phase_density
	add	esp, 4
$LN48@facet_cros:

; 1382 :     set_edge_fe(new_e,new_fe_old);

	mov	eax, edi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN181@facet_cros
	xor	eax, 134217728				; 08000000H
$LN181@facet_cros:
	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [edx+28], eax
$LN295@facet_cros:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _top_timestamp, eax
	mov	DWORD PTR _global_timestamp, eax

; 1395 :       set_edge_fe(new_e,new_fe_old);

$LN185@facet_cros:

; 1396 :     }
; 1397 :   }
; 1398 : 
; 1399 :   /* install new facet into its facet-edges */
; 1400 :   /* link up facet-edges */
; 1401 :   if ( valid_id(new_f) )

	mov	edx, 268435456				; 10000000H
	test	DWORD PTR _new_f$[ebp], edx
	je	$LN44@facet_cros

; 1402 :   {
; 1403 :     if ( valid_id(tail_fe_neg) )

	mov	ecx, DWORD PTR _tail_fe_neg$[ebp]
	test	ecx, edx
	je	SHORT $LN187@facet_cros

; 1404 :       set_next_edge(tail_fe_neg,new_fe_old);

	mov	edx, DWORD PTR _web+460
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN188@facet_cros
	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN187@facet_cros
$LN188@facet_cros:
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+32], edi
$LN187@facet_cros:

; 1405 :     set_prev_edge(new_fe_old,tail_fe_neg);

	mov	ecx, DWORD PTR _tail_fe_neg$[ebp]
	push	ecx
	push	edi
	call	_set_prev_edge

; 1406 :     if ( valid_id(head_fe) )
; 1407 :       set_prev_edge(head_fe,new_fe_old);

	mov	esi, DWORD PTR _head_fe$[ebp]
	add	esp, 8
	cmp	DWORD PTR tv2559[ebp], 0
	je	SHORT $LN42@facet_cros
	push	edi
	push	esi
	call	_set_prev_edge
	add	esp, 8
$LN42@facet_cros:

; 1408 :     set_next_edge(new_fe_old,head_fe);

	mov	eax, edi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv2702[ebp], eax
	je	SHORT $LN276@facet_cros
	mov	eax, DWORD PTR _web+460
	mov	edx, edi
	test	edi, 134217728				; 08000000H
	je	SHORT $LN193@facet_cros
	xor	esi, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+28], esi
	jmp	SHORT $LN276@facet_cros
$LN193@facet_cros:
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+32], esi
$LN276@facet_cros:

; 1409 :     if ( valid_id(tail_fe) )

	cmp	DWORD PTR tv2517[ebp], 0

; 1410 :       set_prev_edge(tail_fe,new_fe_new);

	mov	esi, DWORD PTR _tail_fe$[ebp]
	je	SHORT $LN41@facet_cros
	push	ebx
	push	esi
	call	_set_prev_edge
	add	esp, 8
$LN41@facet_cros:

; 1411 :     set_next_edge(new_fe_new,tail_fe);

	mov	eax, ebx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv2718[ebp], eax
	je	SHORT $LN291@facet_cros
	mov	eax, DWORD PTR _web+460
	mov	edx, ebx
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN198@facet_cros
	xor	esi, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+28], esi
	jmp	SHORT $LN291@facet_cros
$LN198@facet_cros:
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+32], esi
$LN291@facet_cros:

; 1412 :     if ( valid_id(head_fe_neg) )

	mov	eax, DWORD PTR _head_fe_neg$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN202@facet_cros

; 1413 :       set_next_edge(head_fe_neg,new_fe_new);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN203@facet_cros
	mov	esi, DWORD PTR _web+460
	mov	ecx, ebx
	xor	ecx, 134217728				; 08000000H
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+28], ecx
	jmp	SHORT $LN202@facet_cros
$LN203@facet_cros:
	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+32], ebx
$LN202@facet_cros:

; 1414 :     set_prev_edge(new_fe_new,head_fe_neg);

	push	eax
	push	ebx
	call	_set_prev_edge

; 1415 :     set_next_facet(new_fe_new,fe_inverse(new_fe_old));

	mov	eax, edi
	add	esp, 8
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR tv2718[ebp], 0
	je	SHORT $LN280@facet_cros
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN208@facet_cros
	mov	esi, DWORD PTR _web+460
	mov	edx, eax
	xor	edx, 134217728				; 08000000H
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [ecx+36], edx
	jmp	SHORT $LN280@facet_cros
$LN208@facet_cros:
	mov	ecx, DWORD PTR _web+460
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edx+40], eax
$LN280@facet_cros:

; 1416 :     set_prev_facet(new_fe_new,fe_inverse(new_fe_old));

	push	eax
	push	ebx
	call	_set_prev_facet

; 1417 :     set_next_facet(new_fe_old,fe_inverse(new_fe_new));

	mov	eax, ebx
	add	esp, 8
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR tv2702[ebp], 0
	je	SHORT $LN212@facet_cros
	test	edi, 134217728				; 08000000H
	je	SHORT $LN213@facet_cros
	mov	esi, DWORD PTR _web+460
	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx+36], ecx
	jmp	SHORT $LN212@facet_cros
$LN213@facet_cros:
	mov	edx, DWORD PTR _web+460
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+40], eax
$LN212@facet_cros:

; 1418 :     set_prev_facet(new_fe_old,fe_inverse(new_fe_new));

	push	eax
	push	edi
	call	_set_prev_facet
	add	esp, 8

; 1419 :     // fix up loop of facet edges on new facet
; 1420 :     fe = new_fe_new;

	mov	esi, ebx
$LL39@facet_cros:

; 1421 :     do
; 1422 :     { set_fe_facet(fe,new_f);

	mov	edx, DWORD PTR _new_f$[ebp]
	push	edx
	push	esi
	call	_set_fe_facet
	add	esp, 8

; 1423 :       fe = get_next_edge(fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN218@facet_cros
	mov	eax, DWORD PTR _web+460
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN38@facet_cros
$LN218@facet_cros:
	mov	edx, DWORD PTR _web+460
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [eax+32]
$LN38@facet_cros:

; 1424 :     } while ( valid_id(fe) && !equal_id(fe,new_fe_new));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN297@facet_cros
	cmp	esi, ebx
	jne	SHORT $LL39@facet_cros

; 1425 :     if ( !valid_id(fe) )

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN35@facet_cros
$LN297@facet_cros:

; 1426 :     { fe = new_fe_new;

	mov	esi, ebx
$LL34@facet_cros:

; 1427 :       do // go the other way
; 1428 :       { set_fe_facet(fe,new_f);

	mov	ecx, DWORD PTR _new_f$[ebp]
	push	ecx
	push	esi
	call	_set_fe_facet

; 1429 :         set_facet_fe(new_f,fe);

	mov	edx, DWORD PTR _new_f$[ebp]
	push	esi
	push	edx
	call	_set_facet_fe
	add	esp, 16					; 00000010H

; 1430 :         fe = get_prev_edge(fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN222@facet_cros
	mov	eax, DWORD PTR _web+460
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+32]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN33@facet_cros
$LN222@facet_cros:
	mov	edx, DWORD PTR _web+460
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [eax+28]
$LN33@facet_cros:

; 1431 :       } while ( valid_id(fe) && !equal_id(fe,new_fe_new));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN30@facet_cros
	cmp	esi, ebx
	jne	SHORT $LL34@facet_cros

; 1432 :     }
; 1433 :     else

	jmp	SHORT $LN30@facet_cros
$LN35@facet_cros:

; 1434 :       set_facet_fe(new_f,new_fe_new);

	mov	ecx, DWORD PTR _new_f$[ebp]
	push	ebx
	push	ecx
	call	_set_facet_fe
	add	esp, 8
$LN30@facet_cros:

; 1435 :     set_facet_fe(old_f,new_fe_old);

	mov	esi, DWORD PTR _old_f$GSCopy$[ebp]
	push	edi
	push	esi
	call	_set_facet_fe

; 1436 :     set_facet_body(new_f,get_facet_body(old_f));

	push	esi
	call	_get_facet_body
	mov	ebx, DWORD PTR _new_f$[ebp]
	push	eax
	push	ebx
	call	_set_facet_body

; 1437 :     set_facet_body(facet_inverse(new_f),get_facet_body(facet_inverse(old_f)));

	xor	esi, 134217728				; 08000000H
	push	esi
	call	_get_facet_body
	push	eax
	xor	ebx, 134217728				; 08000000H
	push	ebx
	call	_set_facet_body
	add	esp, 32					; 00000020H

; 1438 :   }
; 1439 :   else // no new facet, just adding edge to old

	jmp	$LN29@facet_cros
$LN44@facet_cros:

; 1440 :   { if ( valid_id(tail_fe) || valid_id(head_fe_neg) )

	cmp	DWORD PTR tv2517[ebp], 0
	mov	eax, DWORD PTR _head_fe_neg$[ebp]
	jne	SHORT $LN27@facet_cros
	test	eax, edx
	jne	SHORT $LN299@facet_cros

; 1447 :     }
; 1448 :     else if ( valid_id(head_fe) || valid_id(tail_fe_neg) )

	cmp	DWORD PTR tv2559[ebp], 0
	jne	SHORT $LN301@facet_cros
	test	DWORD PTR _tail_fe_neg$[ebp], edx
	je	$LN25@facet_cros

; 1449 :     { if ( valid_id(head_fe) )

	cmp	DWORD PTR tv2559[ebp], 0
	je	SHORT $LN278@facet_cros
$LN301@facet_cros:

; 1450 :          set_prev_edge(head_fe,new_fe_old);

	mov	edx, DWORD PTR _head_fe$[ebp]
	push	edi
	push	edx
	call	_set_prev_edge
	add	esp, 8
$LN278@facet_cros:

; 1451 :       set_next_edge(new_fe_old,head_fe);

	mov	eax, DWORD PTR _head_fe$[ebp]
	push	eax
	push	edi
	call	_set_next_edge

; 1452 :       set_prev_edge(new_fe_old,tail_fe_neg);

	mov	esi, DWORD PTR _tail_fe_neg$[ebp]
	push	esi
	push	edi
	call	_set_prev_edge
	add	esp, 16					; 00000010H

; 1453 :       if ( valid_id(tail_fe_neg) )

	test	esi, 268435456				; 10000000H
	je	$LN25@facet_cros

; 1454 :         set_next_edge(tail_fe_neg,new_fe_old);

	mov	ecx, esi
	push	edi
	push	ecx
	call	_set_next_edge
	jmp	$LN302@facet_cros
$LN27@facet_cros:

; 1441 :     { if ( valid_id(head_fe_neg) )

	test	eax, edx
	je	SHORT $LN26@facet_cros
$LN299@facet_cros:

; 1442 :         set_next_edge(head_fe_neg,inverse_id(new_fe_old));

	mov	edx, DWORD PTR _head_fe_neg$[ebp]
	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	push	eax
	push	edx
	call	_set_next_edge
	mov	eax, DWORD PTR _head_fe_neg$[ebp]
	add	esp, 8
$LN26@facet_cros:

; 1443 :       set_next_edge(new_fe_old,inverse_id(head_fe_neg));

	xor	eax, 134217728				; 08000000H
	test	edi, 268435456				; 10000000H
	je	SHORT $LN225@facet_cros
	test	edi, 134217728				; 08000000H
	je	SHORT $LN226@facet_cros
	mov	edx, DWORD PTR _web+460
	xor	eax, 134217728				; 08000000H
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN225@facet_cros
$LN226@facet_cros:
	mov	ecx, DWORD PTR _web+460
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edx+32], eax
$LN225@facet_cros:

; 1444 :       set_prev_edge(new_fe_old,inverse_id(tail_fe));

	mov	esi, DWORD PTR _tail_fe$[ebp]
	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	push	eax
	push	edi
	call	_set_prev_edge
	add	esp, 8

; 1445 :       if ( valid_id(tail_fe) )

	cmp	DWORD PTR tv2517[ebp], 0
	je	SHORT $LN25@facet_cros

; 1446 :         set_prev_edge(tail_fe,inverse_id(new_fe_old));

	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	push	eax
	push	esi
	call	_set_prev_edge
$LN302@facet_cros:
	add	esp, 8
$LN25@facet_cros:

; 1455 :     }
; 1456 :     set_next_facet(new_fe_old,new_fe_old);

	test	edi, 268435456				; 10000000H
	je	SHORT $LN230@facet_cros
	test	edi, 134217728				; 08000000H
	je	SHORT $LN231@facet_cros
	mov	edx, DWORD PTR _web+460
	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+36], eax
	jmp	SHORT $LN230@facet_cros
$LN231@facet_cros:
	mov	eax, DWORD PTR _web+460
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+40], edi
$LN230@facet_cros:

; 1457 :     set_prev_facet(new_fe_old,new_fe_old);

	push	edi
	push	edi
	call	_set_prev_facet
	add	esp, 8
$LN29@facet_cros:

; 1458 :   }
; 1459 : 
; 1460 :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN19@facet_cros

; 1461 :      check_edge_vol_methods(new_e);

	mov	edx, DWORD PTR _new_e$[ebp]
	push	edx
	call	_check_edge_vol_methods
	add	esp, 4
$LN19@facet_cros:

; 1462 : 
; 1463 :   /* and set torus wrap flags if needed */
; 1464 :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	$LN15@facet_cros

; 1465 :   { fe = new_fe_old;
; 1466 :     wrap = 0;

	mov	eax, DWORD PTR _web+460
	mov	DWORD PTR _wrap$[ebp], 0
	npad	6
$LL17@facet_cros:

; 1467 :     do
; 1468 :     {
; 1469 :        wrap = (*sym_compose)(wrap,get_fe_wrap(fe));

	mov	ebx, DWORD PTR _dymem
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	eax, edi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+ebx+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN239@facet_cros
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN240@facet_cros
$LN239@facet_cros:
	mov	eax, ecx
$LN240@facet_cros:
	mov	edx, DWORD PTR _wrap$[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose
	add	esp, 8
	mov	DWORD PTR _wrap$[ebp], eax

; 1470 :        fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	test	edi, 134217728				; 08000000H
	je	SHORT $LN242@facet_cros
	mov	ecx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [ecx+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN16@facet_cros
$LN242@facet_cros:
	mov	edx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [edx+32]
$LN16@facet_cros:

; 1471 :     } while ( valid_id(fe) && !equal_id(fe,new_fe_old) );

	test	edi, 268435456				; 10000000H
	je	SHORT $LN15@facet_cros
	cmp	edi, DWORD PTR _new_fe_old$[ebp]
	jne	$LL17@facet_cros
$LN15@facet_cros:

; 1472 :   }
; 1473 :   if ( wrap )

	cmp	DWORD PTR _wrap$[ebp], 0
	je	$LN9@facet_cros

; 1474 :   { set_edge_wrap(new_e,(*sym_inverse)(wrap));

	mov	eax, DWORD PTR _wrap$[ebp]
	push	eax
	call	DWORD PTR _sym_inverse
	mov	esi, DWORD PTR _new_e$[ebp]
	add	esp, 4
	test	esi, 134217728				; 08000000H
	je	SHORT $LN247@facet_cros
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN247@facet_cros:
	mov	ecx, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	mov	edx, esi
	mov	esi, DWORD PTR _web+216
	mov	esi, DWORD PTR [esi+edi+784]
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [ecx+esi], eax

; 1475 :     if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	$LN9@facet_cros

; 1476 :     { /* have to adjust coordinates of midpoint */
; 1477 :       REAL temp[MAXCOORD];
; 1478 :       REAL *mv,*tv,*hv;
; 1479 :       int k;
; 1480 :       tv = get_coord(tailv);
; 1481 :       mv = get_coord(get_edge_midv(new_e));

	mov	ebx, DWORD PTR _web+124
	mov	edx, DWORD PTR [edx+ebx]
	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+esi+64]
	mov	ebx, DWORD PTR _web+216
	mov	esi, DWORD PTR [ebx+esi+304]
	mov	edx, DWORD PTR [edx+esi+8]
	mov	ecx, DWORD PTR _web+12
	mov	edi, DWORD PTR tv2432[ebp]
	mov	edi, DWORD PTR [ecx+edi*4]
	and	edx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+edx*4]

; 1482 :       hv = get_coord(headv);

	mov	edx, DWORD PTR tv2486[ebp]
	mov	esi, DWORD PTR [ecx+edx*4]
	add	edi, eax
	add	ebx, eax
	add	esi, eax

; 1483 :       (*sym_wrap)(hv,temp,(*sym_inverse)(wrap));

	mov	eax, DWORD PTR _wrap$[ebp]
	push	eax
	call	DWORD PTR _sym_inverse
	push	eax
	lea	ecx, DWORD PTR _temp$90274[ebp]
	push	ecx
	push	esi
	call	DWORD PTR _sym_wrap

; 1484 :       for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN9@facet_cros
	fld	QWORD PTR __real@3fe0000000000000
	lea	edx, DWORD PTR _temp$90274[ebp]
	mov	ecx, edx
	sub	edi, edx
	sub	ebx, ecx
$LN11@facet_cros:
	lea	edx, DWORD PTR [edi+eax*8]

; 1485 :         mv[k] = (tv[k] + temp[k])/2;

	fld	QWORD PTR _temp$90274[ebp+edx]
	lea	ecx, DWORD PTR [ebx+eax*8]
	fadd	QWORD PTR _temp$90274[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _temp$90274[ebp+ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN11@facet_cros

; 1484 :       for ( k = 0 ; k < SDIM ; k++ )

	fstp	ST(0)
$LN9@facet_cros:

; 1486 :     }
; 1487 :   }
; 1488 : 
; 1489 :   if ( attr & BOUNDARY )

	mov	eax, DWORD PTR _attr$[ebp]
	mov	esi, 128				; 00000080H
	and	eax, esi
	xor	ecx, ecx
	or	eax, ecx
	je	$LN3@facet_cros

; 1490 :   { struct boundary *bdry = get_facet_boundary(old_f);

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN93@facet_cros
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _web+236
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edx, DWORD PTR tv2600[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR [eax+ecx]
	imul	edx, 136				; 00000088H
	add	edx, DWORD PTR _web+776
	jmp	SHORT $LN303@facet_cros
$LN93@facet_cros:
	xor	edx, edx
$LN303@facet_cros:

; 1491 :     REAL *paramb,*parammid;
; 1492 :     REAL *mu,*mv;
; 1493 : 
; 1494 :     set_attr(new_e,BOUNDARY);

	mov	eax, DWORD PTR _new_e$[ebp]
	mov	ecx, eax
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	eax, DWORD PTR _web[eax+12]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	edi, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], edi

; 1495 :     set_edge_boundary_num(new_e,bdry->num);

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	mov	DWORD PTR _bdry$90300[ebp], edx
	mov	DWORD PTR tv2612[ebp], ecx
	test	eax, eax
	je	SHORT $LN95@facet_cros
	mov	edi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	ebx, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [eax+edi+64]
	mov	edi, DWORD PTR _web+124
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [eax+edi], ebx
$LN95@facet_cros:

; 1496 :     if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	$LN3@facet_cros

; 1497 :     { vertex_id divider = get_edge_midv(new_e); 

	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edi+304]
	mov	eax, DWORD PTR [ecx+eax+8]

; 1498 :       set_attr(divider,BOUNDARY);

	mov	ecx, eax
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	eax, DWORD PTR _web[eax+12]
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [eax+ecx]
	or	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], esi

; 1499 :       set_boundary_num(divider,bdry->num);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN97@facet_cros
	mov	esi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [eax+esi+64]
	mov	esi, DWORD PTR _web+12
	mov	esi, DWORD PTR [ecx+esi]
	mov	DWORD PTR [eax+esi], edx
	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
$LN97@facet_cros:

; 1500 : 
; 1501 :       /* find parameters of new midpoint */
; 1502 :       mv = get_coord(divider);

	mov	esi, DWORD PTR _web+104
	mov	edi, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+12
	mov	ebx, DWORD PTR [esi+edi+64]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR tv2886[ebp], ebx
	add	ebx, ecx
	mov	DWORD PTR _mv$90308[ebp], ebx

; 1503 :       parammid = get_param(divider);

	mov	ebx, DWORD PTR [esi+edi+544]
	add	ebx, ecx
	mov	DWORD PTR _parammid$90306[ebp], ebx

; 1504 :       if ( (get_boundary(headv) != bdry) && (get_boundary(tailv) != bdry) )

	test	eax, eax
	je	SHORT $LN99@facet_cros
	mov	ebx, DWORD PTR tv2486[ebp]
	mov	ebx, DWORD PTR [edx+ebx*4]
	mov	ecx, eax
	imul	ecx, 240				; 000000f0H
	add	ecx, esi
	mov	ecx, DWORD PTR [ecx+edi+64]
	mov	ecx, DWORD PTR [ecx+ebx]
	imul	ecx, 136				; 00000088H
	add	ecx, DWORD PTR _web+776
	jmp	SHORT $LN100@facet_cros
$LN99@facet_cros:
	xor	ecx, ecx
$LN100@facet_cros:
	mov	ebx, DWORD PTR _bdry$90300[ebp]
	cmp	ecx, ebx
	je	$LN272@facet_cros
	test	eax, eax
	je	SHORT $LN101@facet_cros
	mov	ebx, DWORD PTR tv2432[ebp]
	mov	ebx, DWORD PTR [edx+ebx*4]
	mov	ecx, eax
	imul	ecx, 240				; 000000f0H
	add	ecx, esi
	mov	ecx, DWORD PTR [ecx+edi+64]
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR _bdry$90300[ebp]
	imul	ecx, 136				; 00000088H
	add	ecx, DWORD PTR _web+776
	jmp	SHORT $LN102@facet_cros
$LN101@facet_cros:
	xor	ecx, ecx
$LN102@facet_cros:
	cmp	ecx, ebx
	je	$LN272@facet_cros

; 1505 :       { sprintf(errmsg,
; 1506 :            "Vertices %s and %s are on different boundaries from edge %s.\n",
; 1507 :               ELNAME(headv),ELNAME1(tailv),ELNAME2(new_e));

	mov	ebx, 268435456				; 10000000H
	test	DWORD PTR _new_e$[ebp], ebx
	je	SHORT $LN103@facet_cros
	mov	edx, DWORD PTR tv2612[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	edi, OFFSET _elnames+60
	jmp	SHORT $LN104@facet_cros
$LN103@facet_cros:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN104@facet_cros:
	test	DWORD PTR _tailv$GSCopy$[ebp], ebx
	je	SHORT $LN105@facet_cros
	mov	eax, DWORD PTR tv2432[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN106@facet_cros
$LN105@facet_cros:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN106@facet_cros:
	test	DWORD PTR _headv$GSCopy$[ebp], ebx
	je	SHORT $LN107@facet_cros
	mov	ecx, DWORD PTR tv2486[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN108@facet_cros
$LN107@facet_cros:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN108@facet_cros:
	push	edi
	push	esi
	push	eax
	push	OFFSET ??_C@_0DO@FKBHOCNE@Vertices?5?$CFs?5and?5?$CFs?5are?5on?5differ@
	push	OFFSET _errmsg
	call	_sprintf

; 1508 :         kb_error(1242,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1242					; 000004daH
	call	_kb_error
	add	esp, 32					; 00000020H

; 1509 :       }
; 1510 :       else

	jmp	SHORT $LN3@facet_cros
$LN272@facet_cros:

; 1511 : #ifdef PARAMAVG
; 1512 :       if ( (get_boundary(headv) == bdry) && (get_boundary(tailv) == bdry) )
; 1513 :       { mu = get_coord(tailv);
; 1514 :         parama = get_param(tailv);
; 1515 :         paramb = get_param(headv);
; 1516 :         /* projecting on tangent */
; 1517 :         b_extrapolate(bdry,mu,mv,mv,parama,parammid,tailv);
; 1518 :         /* if not wrapped, take average parameter */
; 1519 :         for (  i = 0 ; i < bdry->pcount ; i++ )
; 1520 :         { if ( ((parama[i] < parammid[i]) && (parammid[i] < paramb[i]))
; 1521 :              || ((parama[i] > parammid[i]) && (parammid[i] > paramb[i])))
; 1522 :              parammid[i] = (parama[i] + paramb[i])/2;
; 1523 :         }
; 1524 :       }
; 1525 :       else
; 1526 : #endif
; 1527 :       if ( get_boundary(headv) == bdry )

	test	eax, eax
	je	SHORT $LN109@facet_cros
	mov	ecx, DWORD PTR tv2486[ebp]
	imul	eax, 240				; 000000f0H
	mov	ecx, DWORD PTR [edx+ecx*4]
	add	eax, esi
	mov	eax, DWORD PTR [eax+edi+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN110@facet_cros
$LN109@facet_cros:
	xor	eax, eax
$LN110@facet_cros:
	cmp	eax, ebx
	jne	SHORT $LN4@facet_cros

; 1528 :       { mu = get_coord(headv);
; 1529 :         paramb = get_param(headv);

	mov	eax, DWORD PTR tv2486[ebp]

; 1530 :         /* projecting on tangent */
; 1531 :         b_extrapolate(bdry,mu,mv,mv,paramb,parammid,headv);

	mov	ecx, DWORD PTR _headv$GSCopy$[ebp]

; 1532 :       }
; 1533 :       else

	jmp	SHORT $LN304@facet_cros
$LN4@facet_cros:

; 1534 :       { mu = get_coord(tailv);
; 1535 :         paramb = get_param(tailv);

	mov	eax, DWORD PTR tv2432[ebp]

; 1536 :         /* projecting on tangent */
; 1537 :         b_extrapolate(bdry,mu,mv,mv,paramb,parammid,tailv);

	mov	ecx, DWORD PTR _tailv$GSCopy$[ebp]
$LN304@facet_cros:
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _parammid$90306[ebp]
	push	ecx
	mov	ecx, DWORD PTR [esi+edi+544]
	push	eax
	lea	eax, DWORD PTR [edx+ecx]
	add	edx, DWORD PTR tv2886[ebp]
	push	eax
	mov	eax, DWORD PTR _mv$90308[ebp]
	push	eax
	push	eax
	push	edx
	push	ebx
	call	_b_extrapolate
	add	esp, 28					; 0000001cH
$LN3@facet_cros:

; 1538 :       }
; 1539 :     }
; 1540 :   }
; 1541 :   if ( attr & CONSTRAINT )    

	mov	eax, DWORD PTR _attr$[ebp]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN1@facet_cros

; 1542 :   { ATTR cattr = attr & (BDRY_ENERGY | BDRY_CONTENT | CONSTRAINT );

	mov	ebx, DWORD PTR _attr$[ebp]

; 1543 :     conmap_t * conmap = get_f_constraint_map(old_f);

	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	xor	edx, edx
	and	ebx, 5632				; 00001600H
	cmp	DWORD PTR [eax+ecx+88], edx
	je	SHORT $LN111@facet_cros
	mov	esi, DWORD PTR _web+236
	mov	edi, DWORD PTR tv2600[ebp]
	mov	edi, DWORD PTR [edi+esi]
	add	edi, DWORD PTR [eax+ecx+64]
	jmp	SHORT $LN112@facet_cros
$LN111@facet_cros:
	mov	edi, OFFSET _nullcon
$LN112@facet_cros:

; 1544 : 
; 1545 :     set_attr(new_e,cattr);

	mov	ecx, DWORD PTR _new_e$[ebp]
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	eax, DWORD PTR _web[eax+12]
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [eax+esi]
	or	DWORD PTR [eax+8], ebx
	or	DWORD PTR [eax+12], edx

; 1546 :     set_e_conmap(new_e,conmap);

	push	edi
	push	ecx
	call	_set_e_conmap
	add	esp, 8

; 1547 :     if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	SHORT $LN1@facet_cros

; 1548 :     { vertex_id mid = get_edge_midv(new_e);

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	esi, DWORD PTR [edx+eax+8]

; 1549 :       set_attr(mid,cattr);

	mov	ecx, esi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	or	DWORD PTR [eax+8], ebx
	xor	ecx, ecx
	or	DWORD PTR [eax+12], ecx

; 1550 :       set_v_conmap(mid,conmap);

	push	edi
	push	esi
	call	_set_v_conmap

; 1551 :       project_v_constr(mid,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	push	1
	push	1
	push	esi
	call	_project_v_constr
	add	esp, 20					; 00000014H
$LN1@facet_cros:

; 1552 :     }
; 1553 :   }
; 1554 :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp

; 1555 : 
; 1556 :   return new_e;
; 1557 : } // end facet_crosscut()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	inc	eax
	pop	edi
	pop	esi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	mov	eax, DWORD PTR _new_e$[ebp]
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_facet_crosscut ENDP
_TEXT	ENDS
PUBLIC	??_C@_08NGLEEPGD@MODIFY?4C?$AA@			; `string'
PUBLIC	_merge_bodies
EXTRN	_temp_free:PROC
EXTRN	_kb_temp_calloc:PROC
;	COMDAT ??_C@_08NGLEEPGD@MODIFY?4C?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_08NGLEEPGD@MODIFY?4C?$AA@ DB 'MODIFY.C', 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _merge_bodies
_TEXT	SEGMENT
tv1008 = -16						; size = 4
_merge_count$ = -12					; size = 4
tv995 = -8						; size = 4
_f_id$ = -8						; size = 4
_merge_body$ = -4					; size = 4
_merge_bodies PROC					; COMDAT

; 1570 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1571 :   body_id *merge_body;  /* final destination of body */
; 1572 :   body_id b_id,bb_id;
; 1573 :   facetedge_id fe_id,next_fe;
; 1574 :   facet_id f_id,ff_id;
; 1575 :   int merge_count=0;
; 1576 : 
; 1577 :   merge_body = (body_id *)temp_calloc(web.skel[BODY].max_ord+5,sizeof(body_id));

	mov	eax, DWORD PTR _web+404
	push	ebx
	push	esi
	push	edi
	push	1577					; 00000629H
	push	OFFSET ??_C@_08NGLEEPGD@MODIFY?4C?$AA@
	add	eax, 5
	push	4
	push	eax
	mov	DWORD PTR _merge_count$[ebp], 0
	call	_kb_temp_calloc

; 1578 :   FOR_ALL_BODIES(b_id)

	mov	esi, DWORD PTR _web+384
	mov	edi, DWORD PTR _web+348
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	ecx, 1
	mov	DWORD PTR _merge_body$[ebp], eax
	je	SHORT $LN47@merge_bodi
	npad	10
$LL132@merge_bodi:
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN48@merge_bodi

; 1579 :     merge_body[loc_ordinal(b_id)] = b_id;

	test	ecx, ecx
	je	SHORT $LN52@merge_bodi
	mov	eax, edx
	jmp	SHORT $LN53@merge_bodi
$LN52@merge_bodi:
	or	eax, -1
$LN53@merge_bodi:
	mov	ecx, DWORD PTR _merge_body$[ebp]
	mov	DWORD PTR [ecx+eax*4], esi
	mov	edi, DWORD PTR _web+348
$LN48@merge_bodi:

; 1578 :   FOR_ALL_BODIES(b_id)

	mov	edx, DWORD PTR [edi+edx*4]
	mov	esi, DWORD PTR [edx]
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	SHORT $LL132@merge_bodi
$LN47@merge_bodi:

; 1580 : 
; 1581 :   /* Find junctions between bodies */
; 1582 :   if ( web.representation == STRING )

	mov	eax, DWORD PTR _web+624
	cmp	eax, 1
	jne	$LN44@merge_bodi

; 1583 :   { /* test for distinct facets joining at vertex */
; 1584 :     FOR_ALL_FACETEDGES(fe_id)

	mov	ecx, DWORD PTR _web+496
	mov	ebx, ecx
	shr	ebx, 28					; 0000001cH
	and	ebx, eax
	je	$LN28@merge_bodi
	npad	2
$LL136@merge_bodi:
	mov	eax, DWORD PTR _web+460
	mov	edi, ecx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN42@merge_bodi

; 1585 :     { next_fe = get_next_edge(fe_id);

	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR tv995[ebp], ecx
	je	SHORT $LN77@merge_bodi
	mov	esi, DWORD PTR [edx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN76@merge_bodi
$LN77@merge_bodi:
	mov	esi, DWORD PTR [edx+32]
$LN76@merge_bodi:

; 1586 :       if ( equal_element(get_fe_edge(fe_id),get_fe_edge(next_fe)) )

	mov	eax, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv1008[ebp], eax
	mov	eax, DWORD PTR [edx+20]
	or	ecx, 134217728				; 08000000H
	or	eax, 134217728				; 08000000H
	cmp	eax, ecx
	je	$LN42@merge_bodi

; 1587 :         continue;
; 1588 :       f_id = get_fe_facet(fe_id);

	test	ebx, ebx
	jne	SHORT $LN85@merge_bodi
	mov	edx, DWORD PTR _NULLFACET
	jmp	SHORT $LN138@merge_bodi
$LN85@merge_bodi:
	cmp	DWORD PTR tv995[ebp], 0
	mov	edx, DWORD PTR [edx+24]
	je	SHORT $LN138@merge_bodi
	xor	edx, 134217728				; 08000000H
$LN138@merge_bodi:
	mov	DWORD PTR _f_id$[ebp], edx

; 1589 :       if ( !valid_id(f_id) ) 

	test	edx, 268435456				; 10000000H
	je	SHORT $LN42@merge_bodi

; 1590 :         continue;
; 1591 :       ff_id = get_fe_facet(next_fe);

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN89@merge_bodi
	mov	ebx, DWORD PTR _NULLFACET
	jmp	SHORT $LN88@merge_bodi
$LN89@merge_bodi:
	mov	ecx, DWORD PTR tv1008[ebp]
	mov	ebx, DWORD PTR [ecx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN88@merge_bodi
	xor	ebx, 134217728				; 08000000H
$LN88@merge_bodi:

; 1592 :       if ( !valid_id(ff_id) ) 

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN42@merge_bodi

; 1593 :         continue;
; 1594 :       if ( equal_id(f_id,ff_id)) 

	cmp	DWORD PTR _f_id$[ebp], ebx
	je	SHORT $LN42@merge_bodi

; 1595 :         continue;
; 1596 :       /* now ready to merge */
; 1597 :       while ( equal_id(ff_id,get_fe_facet(next_fe)) )

	push	esi
	call	_get_fe_facet
	add	esp, 4
	cmp	ebx, eax
	jne	SHORT $LN33@merge_bodi
	npad	3
$LL34@merge_bodi:

; 1598 :         set_fe_facet(next_fe,f_id);

	mov	edx, DWORD PTR _f_id$[ebp]
	push	edx
	push	esi
	call	_set_fe_facet
	push	esi
	call	_get_fe_facet
	add	esp, 12					; 0000000cH
	cmp	ebx, eax
	je	SHORT $LL34@merge_bodi
$LN33@merge_bodi:

; 1599 :       free_element(ff_id); 

	push	ebx
	call	_free_element
	add	esp, 4
$LN42@merge_bodi:

; 1583 :   { /* test for distinct facets joining at vertex */
; 1584 :     FOR_ALL_FACETEDGES(fe_id)

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [ecx]
	mov	ebx, ecx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	jne	$LL136@merge_bodi

; 1600 :     }
; 1601 :   }
; 1602 :   else if ( web.representation == SOAPFILM )

	jmp	$LN141@merge_bodi
$LN44@merge_bodi:
	cmp	eax, 2
	jne	$LN28@merge_bodi

; 1603 :   { FOR_ALL_FACETEDGES(fe_id)

	mov	ecx, DWORD PTR _web+496
	mov	ebx, ecx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	je	$LN28@merge_bodi
	mov	eax, DWORD PTR _web+460
	npad	1
$LL30@merge_bodi:
	mov	edi, ecx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN29@merge_bodi

; 1604 :     { next_fe = get_next_facet(fe_id);

	mov	eax, ecx
	shr	eax, 27					; 0000001bH
	and	eax, 1
	je	SHORT $LN93@merge_bodi
	mov	esi, DWORD PTR [edx+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN92@merge_bodi
$LN93@merge_bodi:
	mov	esi, DWORD PTR [edx+40]
$LN92@merge_bodi:

; 1605 :       if ( equal_id(fe_id,next_fe) ) 

	cmp	ecx, esi
	je	$LN29@merge_bodi

; 1606 :          continue; /* ok to disagree on valence 1 */
; 1607 :       f_id = get_fe_facet(fe_id);

	test	ebx, ebx
	jne	SHORT $LN97@merge_bodi
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN98@merge_bodi
$LN97@merge_bodi:
	mov	edx, DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $LN137@merge_bodi
	xor	edx, 134217728				; 08000000H
$LN137@merge_bodi:
	mov	eax, edx
$LN98@merge_bodi:

; 1608 :       ff_id = get_fe_facet(next_fe);

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN101@merge_bodi
	mov	ebx, DWORD PTR _NULLFACET
	jmp	SHORT $LN100@merge_bodi
$LN101@merge_bodi:
	mov	ecx, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ebx, DWORD PTR [edx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN100@merge_bodi
	xor	ebx, 134217728				; 08000000H
$LN100@merge_bodi:

; 1609 :       b_id = get_facet_body(inverse_id(f_id));

	xor	eax, 134217728				; 08000000H
	push	eax
	call	_get_facet_body

; 1610 :       bb_id = get_facet_body(ff_id);

	push	ebx
	mov	esi, eax
	call	_get_facet_body
	add	esp, 8

; 1611 :       if ( valid_id(b_id) && valid_id(bb_id) && !equal_id(b_id,bb_id) )

	test	esi, 268435456				; 10000000H
	je	SHORT $LN29@merge_bodi
	test	eax, 268435456				; 10000000H
	je	SHORT $LN29@merge_bodi
	cmp	esi, eax
	je	SHORT $LN29@merge_bodi

; 1612 :       { /* merge higher number body to lower */
; 1613 :         if ( loc_ordinal(b_id) > loc_ordinal(bb_id) )

	mov	ecx, esi
	mov	edx, eax
	and	ecx, 134217727				; 07ffffffH
	and	edx, 134217727				; 07ffffffH
	cmp	ecx, edx
	jle	SHORT $LN23@merge_bodi

; 1614 :           merge_body[loc_ordinal(b_id)] = bb_id;

	mov	edx, DWORD PTR _merge_body$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 1615 :         else

	jmp	SHORT $LN29@merge_bodi
$LN23@merge_bodi:

; 1616 :           merge_body[loc_ordinal(bb_id)] = b_id;

	mov	eax, DWORD PTR _merge_body$[ebp]
	mov	DWORD PTR [eax+edx*4], esi
$LN29@merge_bodi:

; 1603 :   { FOR_ALL_FACETEDGES(fe_id)

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [ecx]
	mov	ebx, ecx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	jne	$LL30@merge_bodi
$LN141@merge_bodi:
	mov	edi, DWORD PTR _web+348
$LN28@merge_bodi:

; 1617 :       }
; 1618 :     }
; 1619 :   }
; 1620 : 
; 1621 :   /* find net merge destinations */
; 1622 :   FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR _web+384
	mov	ebx, ecx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	je	$LN19@merge_bodi
	npad	8
$LL21@merge_bodi:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN20@merge_bodi

; 1623 :   { if ( b_id != merge_body[loc_ordinal(b_id)] )

	test	ebx, ebx
	je	SHORT $LN62@merge_bodi
	mov	eax, esi
	jmp	SHORT $LN63@merge_bodi
$LN62@merge_bodi:
	or	eax, -1
$LN63@merge_bodi:
	mov	edx, DWORD PTR _merge_body$[ebp]
	cmp	ecx, DWORD PTR [edx+eax*4]
	je	SHORT $LN20@merge_bodi

; 1624 :     { bb_id = b_id;

	mov	eax, ecx
	mov	edi, edx
	npad	2
$LL15@merge_bodi:

; 1625 :       while ( bb_id != merge_body[loc_ordinal(bb_id)] )

	mov	edx, eax
	shr	edx, 28					; 0000001cH
	and	edx, 1
	je	SHORT $LN64@merge_bodi
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN65@merge_bodi
$LN64@merge_bodi:
	or	ecx, -1
$LN65@merge_bodi:
	cmp	eax, DWORD PTR [edi+ecx*4]
	je	SHORT $LN14@merge_bodi

; 1626 :         bb_id = merge_body[loc_ordinal(bb_id)];

	test	edx, edx
	je	SHORT $LN66@merge_bodi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	jmp	SHORT $LL15@merge_bodi
$LN66@merge_bodi:
	or	eax, -1
	mov	eax, DWORD PTR [edi+eax*4]
	jmp	SHORT $LL15@merge_bodi
$LN14@merge_bodi:

; 1627 :       merge_body[loc_ordinal(b_id)] = bb_id;

	test	ebx, ebx
	je	SHORT $LN68@merge_bodi
	mov	ecx, esi
	jmp	SHORT $LN69@merge_bodi
$LN68@merge_bodi:
	or	ecx, -1
$LN69@merge_bodi:

; 1628 :       merge_count++;

	inc	DWORD PTR _merge_count$[ebp]
	mov	edx, edi
	mov	DWORD PTR [edx+ecx*4], eax
	mov	edi, DWORD PTR _web+348
$LN20@merge_bodi:

; 1617 :       }
; 1618 :     }
; 1619 :   }
; 1620 : 
; 1621 :   /* find net merge destinations */
; 1622 :   FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR [edi+esi*4]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, ecx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	jne	$LL21@merge_bodi
$LN19@merge_bodi:

; 1629 :     }
; 1630 :   }
; 1631 : 
; 1632 :   /* reset all facets appropriately */
; 1633 :   FOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR _web+272
	mov	edx, esi
	shr	edx, 28					; 0000001cH
	and	edx, 1
	je	$LN11@merge_bodi
$LL13@merge_bodi:
	mov	ecx, DWORD PTR _web+236
	mov	ebx, esi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN12@merge_bodi

; 1634 :   { b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, edi
	jne	SHORT $LN107@merge_bodi
	xor	ecx, ecx
	jmp	SHORT $LN104@merge_bodi
$LN107@merge_bodi:
	test	edx, edx
	jne	SHORT $LN106@merge_bodi
	xor	ecx, ecx
	jmp	SHORT $LN104@merge_bodi
$LN106@merge_bodi:
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+328
	test	esi, 134217728				; 08000000H
	je	SHORT $LN105@merge_bodi
	mov	edx, DWORD PTR [eax+edx+784]
	mov	ecx, DWORD PTR [edx+ecx+4]
	jmp	SHORT $LN104@merge_bodi
$LN105@merge_bodi:
	mov	eax, DWORD PTR [eax+edx+784]
	mov	ecx, DWORD PTR [ecx+eax]
$LN104@merge_bodi:

; 1635 :     bb_id = merge_body[loc_ordinal(b_id)];

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN70@merge_bodi
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN71@merge_bodi
$LN70@merge_bodi:
	or	eax, -1
$LN71@merge_bodi:
	mov	edi, DWORD PTR _merge_body$[ebp]
	mov	eax, DWORD PTR [edi+eax*4]

; 1636 :     if ( valid_id(bb_id) && !equal_id(b_id,bb_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN139@merge_bodi
	cmp	ecx, eax
	je	SHORT $LN139@merge_bodi

; 1637 :       set_facet_body(f_id,bb_id);

	push	eax
	push	esi
	call	_set_facet_body
	add	esp, 8
$LN139@merge_bodi:

; 1638 :     b_id = get_facet_body(inverse_id(f_id));

	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN113@merge_bodi
	xor	ecx, ecx
	jmp	SHORT $LN110@merge_bodi
$LN113@merge_bodi:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN112@merge_bodi
	xor	ecx, ecx
	jmp	SHORT $LN110@merge_bodi
$LN112@merge_bodi:
	mov	edx, DWORD PTR _web+236
	mov	esi, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+328
	mov	edx, DWORD PTR [edx+esi+784]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN111@merge_bodi
	mov	ecx, DWORD PTR [ecx+edx+4]
	jmp	SHORT $LN110@merge_bodi
$LN111@merge_bodi:
	mov	ecx, DWORD PTR [ecx+edx]
$LN110@merge_bodi:

; 1639 :     bb_id = merge_body[loc_ordinal(b_id)];

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN72@merge_bodi
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN73@merge_bodi
$LN72@merge_bodi:
	or	edx, -1
$LN73@merge_bodi:
	mov	edx, DWORD PTR [edi+edx*4]

; 1640 :     if ( valid_id(bb_id) && !equal_id(b_id,bb_id) )

	test	edx, 268435456				; 10000000H
	je	SHORT $LN12@merge_bodi
	cmp	ecx, edx
	je	SHORT $LN12@merge_bodi

; 1641 :       set_facet_body(inverse_id(f_id),bb_id);

	push	edx
	push	eax
	call	_set_facet_body
	add	esp, 8
$LN12@merge_bodi:

; 1629 :     }
; 1630 :   }
; 1631 : 
; 1632 :   /* reset all facets appropriately */
; 1633 :   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ebx+eax]
	mov	esi, DWORD PTR [ecx]
	mov	edx, esi
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	$LL13@merge_bodi
	mov	edi, DWORD PTR _web+348
$LN11@merge_bodi:

; 1642 :   }
; 1643 : 
; 1644 :   /* get rid of unneeded bodies */
; 1645 :   FOR_ALL_BODIES(b_id)

	mov	edx, DWORD PTR _web+384
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	je	SHORT $LN4@merge_bodi
$LL134@merge_bodi:
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN5@merge_bodi

; 1646 :   { if ( b_id != merge_body[loc_ordinal(b_id)] )

	test	ecx, ecx
	je	SHORT $LN74@merge_bodi
	mov	eax, esi
	jmp	SHORT $LN75@merge_bodi
$LN74@merge_bodi:
	or	eax, -1
$LN75@merge_bodi:
	mov	ecx, DWORD PTR _merge_body$[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4]
	je	SHORT $LN5@merge_bodi

; 1647 :       free_element(b_id);

	push	edx
	call	_free_element
	mov	edi, DWORD PTR _web+348
	add	esp, 4
$LN5@merge_bodi:

; 1642 :   }
; 1643 : 
; 1644 :   /* get rid of unneeded bodies */
; 1645 :   FOR_ALL_BODIES(b_id)

	mov	edx, DWORD PTR [edi+esi*4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	SHORT $LL134@merge_bodi
$LN4@merge_bodi:

; 1648 :   }
; 1649 : 
; 1650 :   temp_free((char*)merge_body);

	mov	eax, DWORD PTR _merge_body$[ebp]
	push	eax
	call	_temp_free

; 1651 : 
; 1652 :   return merge_count;

	mov	eax, DWORD PTR _merge_count$[ebp]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1653 : 
; 1654 : } // end merge_bodies()

	mov	esp, ebp
	pop	ebp
	ret	0
_merge_bodies ENDP
_TEXT	ENDS
PUBLIC	_ffcomp
; Function compile flags: /Ogtp
;	COMDAT _ffcomp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_ffcomp	PROC						; COMDAT

; 1665 : {

	push	ebp
	mov	ebp, esp

; 1666 :   if ( loc_ordinal(*a) < loc_ordinal(*b) ) return -1;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ebx
	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	push	esi
	push	edi
	je	SHORT $LN7@ffcomp
	mov	edi, ecx
	and	edi, 134217727				; 07ffffffH
	jmp	SHORT $LN8@ffcomp
$LN7@ffcomp:
	or	edi, -1
$LN8@ffcomp:
	mov	eax, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ebx, eax
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	je	SHORT $LN9@ffcomp
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	jmp	SHORT $LN10@ffcomp
$LN9@ffcomp:
	or	esi, -1
$LN10@ffcomp:
	cmp	edi, esi
	jge	SHORT $LN4@ffcomp
$LN15@ffcomp:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx

; 1670 : 
; 1671 :   return 0;
; 1672 : } // end ffcomp()

	pop	ebp
	ret	0
$LN4@ffcomp:

; 1667 :   if ( loc_ordinal(*a) > loc_ordinal(*b) ) return 1;

	test	edx, edx
	je	SHORT $LN11@ffcomp
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	jmp	SHORT $LN12@ffcomp
$LN11@ffcomp:
	or	esi, -1
$LN12@ffcomp:
	test	ebx, ebx
	je	SHORT $LN13@ffcomp
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN14@ffcomp
$LN13@ffcomp:
	or	edx, -1
$LN14@ffcomp:
	cmp	esi, edx
	jle	SHORT $LN3@ffcomp
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 1670 : 
; 1671 :   return 0;
; 1672 : } // end ffcomp()

	pop	ebp
	ret	0
$LN3@ffcomp:

; 1668 :   if ( inverted(*a) < inverted(*b) ) return -1;

	shr	ecx, 27					; 0000001bH
	shr	eax, 27					; 0000001bH
	and	ecx, 1
	and	eax, 1
	cmp	ecx, eax
	jl	SHORT $LN15@ffcomp

; 1669 :   if ( inverted(*a) > inverted(*b) ) return 1;

	xor	edx, edx
	cmp	ecx, eax
	setg	dl
	pop	edi
	pop	esi
	pop	ebx
	mov	eax, edx

; 1670 : 
; 1671 :   return 0;
; 1672 : } // end ffcomp()

	pop	ebp
	ret	0
_ffcomp	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EH@PKLFEFCC@Internal?5error?3?5string_rebody?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0FB@OHKOJJDG@Internal?5error?3?5string_rebody?$CI?$CJ?5@ ; `string'
PUBLIC	_string_rebody
EXTRN	_dup_body:PROC
EXTRN	_bsearch:PROC
;	COMDAT ??_C@_0EH@PKLFEFCC@Internal?5error?3?5string_rebody?$CI?$CJ?5@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EH@PKLFEFCC@Internal?5error?3?5string_rebody?$CI?$CJ?5@ DB 'Intern'
	DB	'al error: string_rebody() cannot find edge on stack (old body'
	DB	').', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@OHKOJJDG@Internal?5error?3?5string_rebody?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0FB@OHKOJJDG@Internal?5error?3?5string_rebody?$CI?$CJ?5@ DB 'Intern'
	DB	'al error: string_rebody() cannot find the facetedge for body '
	DB	'%s on stack.', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _string_rebody
_TEXT	SEGMENT
_new_bodies$ = -32					; size = 4
_f_id$93643 = -28					; size = 4
_edgetop$ = -28						; size = 4
_ff_id$ = -28						; size = 4
_stack$ = -24						; size = 4
_felist$ = -20						; size = 4
tv1189 = -16						; size = 4
_f_id$ = -16						; size = 4
_ffe$ = -12						; size = 4
_fe$ = -8						; size = 4
_edges_left$ = -4					; size = 4
_string_rebody PROC					; COMDAT

; 1851 : { body_id b_id,old_b;

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1852 :   int edges_left;
; 1853 :   int new_bodies = 0;
; 1854 :   int i;
; 1855 :   struct bodyface *felist, *be;
; 1856 :   facetedge_id *stack;  /* of known faces */
; 1857 :   int stacktop;
; 1858 :   int edgetop;  /* length of flist */
; 1859 :   facet_id f_id,ff_id,new_f;
; 1860 :   edge_id e_id;
; 1861 :   facetedge_id fe,ffe;
; 1862 : 
; 1863 :   /* working list of edges */
; 1864 :   felist = (struct bodyface *)temp_calloc(2*web.skel[EDGE].count,
; 1865 :                 sizeof(struct bodyface));

	mov	eax, DWORD PTR _web+176
	push	ebx
	push	esi
	push	edi
	push	1865					; 00000749H
	push	OFFSET ??_C@_08NGLEEPGD@MODIFY?4C?$AA@
	lea	ecx, DWORD PTR [eax+eax]
	push	16					; 00000010H
	xor	esi, esi
	push	ecx
	mov	DWORD PTR _new_bodies$[ebp], esi
	call	_kb_temp_calloc

; 1866 :   stack = (facet_id *)temp_calloc(2*web.skel[EDGE].count,sizeof(edge_id*));

	mov	edx, DWORD PTR _web+176
	push	1866					; 0000074aH
	mov	edi, eax
	push	OFFSET ??_C@_08NGLEEPGD@MODIFY?4C?$AA@
	lea	eax, DWORD PTR [edx+edx]
	push	4
	push	eax
	mov	DWORD PTR _felist$[ebp], edi
	call	_kb_temp_calloc

; 1867 :   edges_left = 0; 
; 1868 :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+160
	add	esp, 32					; 00000020H
	mov	DWORD PTR _stack$[ebp], eax
	mov	DWORD PTR _edges_left$[ebp], esi
	test	ecx, 268435456				; 10000000H
	je	$LN174@string_reb
$LL56@string_reb:
	mov	eax, DWORD PTR _web+124
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	esi, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv1189[ebp], edx
	je	$LN55@string_reb

; 1869 :      { fe = get_edge_fe(e_id);

	test	esi, esi
	je	SHORT $LN61@string_reb
$LN62@string_reb:
	mov	esi, DWORD PTR [esi+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN61@string_reb
	xor	esi, 134217728				; 08000000H
$LN61@string_reb:
	mov	DWORD PTR _fe$[ebp], esi

; 1870 :         if ( !valid_id(fe) ) continue;

	test	esi, 268435456				; 10000000H
	je	$LN55@string_reb

; 1871 :         f_id = get_fe_facet(fe);

	mov	eax, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR _f_id$93643[ebp], eax
	test	esi, 134217728				; 08000000H
	je	SHORT $LN65@string_reb
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _f_id$93643[ebp], eax
$LN65@string_reb:

; 1872 :         if ( !valid_id(f_id) ) continue;

	test	eax, 268435456				; 10000000H
	je	$LN55@string_reb

; 1873 : 
; 1874 :         if ( valid_id(get_facet_body(f_id)))

	push	eax
	call	_get_facet_body
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN199@string_reb

; 1875 :              felist[edges_left++].f_id = fe;

	inc	DWORD PTR _edges_left$[ebp]
	mov	DWORD PTR [edi], esi
	mov	esi, DWORD PTR _fe$[ebp]
	add	edi, 16					; 00000010H
$LN199@string_reb:

; 1876 :         ff_id = facet_inverse(f_id);

	mov	ebx, DWORD PTR _f_id$93643[ebp]
	mov	edx, ebx
	xor	edx, 134217728				; 08000000H

; 1877 :         if ( valid_id(get_facet_body(ff_id)) )

	push	edx
	call	_get_facet_body
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN209@string_reb

; 1878 :              felist[edges_left++].f_id = inverse_id(fe);

	inc	DWORD PTR _edges_left$[ebp]
	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR [edi], esi
	mov	esi, DWORD PTR _fe$[ebp]
	add	edi, 16					; 00000010H
$LN209@string_reb:
	mov	eax, DWORD PTR _web+460

; 1879 : 
; 1880 :         fe = get_next_facet(fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN70@string_reb
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN69@string_reb
$LN70@string_reb:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [edx+40]
$LN69@string_reb:
	mov	DWORD PTR _fe$[ebp], esi

; 1881 :         ff_id = get_fe_facet(fe);

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN74@string_reb
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN73@string_reb
$LN74@string_reb:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN73@string_reb
	xor	eax, 134217728				; 08000000H
$LN73@string_reb:

; 1882 :         if ( equal_element(f_id,ff_id) ) continue;

	mov	ecx, eax
	or	ebx, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	mov	DWORD PTR _ff_id$[ebp], eax
	cmp	ebx, ecx
	je	SHORT $LN207@string_reb

; 1883 : 
; 1884 :         if ( valid_id(get_facet_body(ff_id)))

	push	eax
	call	_get_facet_body
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN206@string_reb

; 1885 :              felist[edges_left++].f_id = fe;

	inc	DWORD PTR _edges_left$[ebp]
	mov	DWORD PTR [edi], esi
	mov	esi, DWORD PTR _fe$[ebp]
	add	edi, 16					; 00000010H
$LN206@string_reb:

; 1886 :         ff_id = facet_inverse(ff_id);

	mov	eax, DWORD PTR _ff_id$[ebp]
	xor	eax, 134217728				; 08000000H

; 1887 :         if ( valid_id(get_facet_body(ff_id)) )

	push	eax
	call	_get_facet_body
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN207@string_reb

; 1888 :              felist[edges_left++].f_id = inverse_id(fe);

	inc	DWORD PTR _edges_left$[ebp]
	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR [edi], esi
	add	edi, 16					; 00000010H
$LN207@string_reb:
	mov	edx, DWORD PTR tv1189[ebp]
$LN55@string_reb:

; 1867 :   edges_left = 0; 
; 1868 :   FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [edx+eax]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, 268435456				; 10000000H
	jne	$LL56@string_reb

; 1889 : 
; 1890 :       }
; 1891 :   if ( edges_left == 0 ) return 0;

	cmp	DWORD PTR _edges_left$[ebp], 0
	jne	SHORT $LN44@string_reb
$LN174@string_reb:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 2035 : } // end string_rebody()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@string_reb:

; 1892 :   edgetop = edges_left;

	mov	eax, DWORD PTR _edges_left$[ebp]

; 1893 : 
; 1894 :   /* sort in edge order, so can find edges quickly */
; 1895 :   qsort((char *)felist,edges_left,sizeof(struct bodyface),FCAST ffcomp);

	mov	edx, DWORD PTR _felist$[ebp]
	push	OFFSET _ffcomp
	push	16					; 00000010H
	push	eax
	push	edx
	mov	DWORD PTR _edgetop$[ebp], eax
	call	_qsort

; 1896 : 
; 1897 :   /* initialize stack with body edges */
; 1898 :   stacktop = 0;
; 1899 :   FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+384
	mov	esi, eax
	shr	esi, 28					; 0000001cH
	add	esp, 16					; 00000010H
	xor	ebx, ebx
	and	esi, 1
	je	$LL193@string_reb
	npad	3
$LL43@string_reb:
	mov	edi, eax
	mov	eax, DWORD PTR _web+348
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN42@string_reb

; 1900 :     { fe = get_body_fe(b_id);

	test	esi, esi
	je	SHORT $LN79@string_reb
	mov	ecx, DWORD PTR [ecx+400]
	jmp	SHORT $LN80@string_reb
$LN79@string_reb:
	xor	ecx, ecx
$LN80@string_reb:
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN81@string_reb
	mov	eax, DWORD PTR _web+236
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edx+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN82@string_reb
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN82@string_reb
$LN81@string_reb:
	xor	eax, eax
$LN82@string_reb:

; 1901 :       stack[stacktop++] = fe;

	mov	ecx, DWORD PTR _stack$[ebp]

; 1902 :       be = (struct bodyface *)bsearch((char *)&fe,(char *)felist,
; 1903 :                         edgetop, sizeof(struct bodyface),FCAST ffcomp);

	mov	edx, DWORD PTR _edgetop$[ebp]
	push	OFFSET _ffcomp
	mov	DWORD PTR _fe$[ebp], eax
	mov	DWORD PTR [ecx+ebx*4], eax
	mov	eax, DWORD PTR _felist$[ebp]
	push	16					; 00000010H
	push	edx
	push	eax
	lea	ecx, DWORD PTR _fe$[ebp]
	push	ecx
	inc	ebx
	call	_bsearch
	add	esp, 20					; 00000014H

; 1904 :       if ( be == NULL ) 

	test	eax, eax
	jne	SHORT $LN38@string_reb

; 1905 :       { sprintf(errmsg,
; 1906 :              "Internal error: string_rebody() cannot find the facetedge for body %s on stack.\n",
; 1907 :               ELNAME(b_id));

	test	esi, esi
	je	SHORT $LN59@string_reb
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN60@string_reb
$LN59@string_reb:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN60@string_reb:
	push	eax
	push	OFFSET ??_C@_0FB@OHKOJJDG@Internal?5error?3?5string_rebody?$CI?$CJ?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1908 :         kb_error(1246,errmsg, WARNING); 

	push	2
	push	OFFSET _errmsg
	push	1246					; 000004deH
	call	_kb_error
	add	esp, 24					; 00000018H

; 1909 :         continue; 

	jmp	SHORT $LN42@string_reb
$LN38@string_reb:

; 1910 :       }
; 1911 : 
; 1912 :       be->wrapflag = 1;

	mov	ecx, 1

; 1913 :       edges_left--;

	sub	DWORD PTR _edges_left$[ebp], ecx
	mov	DWORD PTR [eax+12], ecx
$LN42@string_reb:

; 1896 : 
; 1897 :   /* initialize stack with body edges */
; 1898 :   stacktop = 0;
; 1899 :   FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [ecx]
	mov	esi, eax
	shr	esi, 28					; 0000001cH
	and	esi, 1
	jne	$LL43@string_reb
$LL193@string_reb:

; 1867 :   edges_left = 0; 
; 1868 :   FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+460
$LL37@string_reb:

; 1914 :     } 
; 1915 : 
; 1916 :   /* pull stuff off stack till empty */
; 1917 :   while (stacktop > 0 )

	test	ebx, ebx
	jle	$LL27@string_reb

; 1918 :     { fe = stack[--stacktop];

	mov	eax, DWORD PTR _stack$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4-4]
	dec	ebx
	mov	DWORD PTR _fe$[ebp], eax

; 1919 :       f_id = get_fe_facet(fe);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN88@string_reb
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN87@string_reb
$LN88@string_reb:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN87@string_reb
	xor	ecx, 134217728				; 08000000H
$LN87@string_reb:
	mov	DWORD PTR _f_id$[ebp], ecx

; 1920 : 
; 1921 :       ffe = get_prev_edge(fe);

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN92@string_reb
	mov	ecx, DWORD PTR [ecx+32]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN91@string_reb
$LN92@string_reb:
	mov	ecx, DWORD PTR [ecx+28]
$LN91@string_reb:
	mov	DWORD PTR _ffe$[ebp], ecx

; 1922 :       if ( !valid_id(ffe) ) goto otherend;

	test	ecx, 268435456				; 10000000H
	je	$otherend$90740

; 1923 :       ff_id = get_fe_facet(ffe);

	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [esi+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN95@string_reb
	xor	esi, 134217728				; 08000000H
$LN95@string_reb:

; 1924 :       if ( !equal_id(ff_id,f_id) ) goto otherend;

	cmp	esi, DWORD PTR _f_id$[ebp]
	jne	$otherend$90740

; 1925 :       be = (struct bodyface *)bsearch((char *)&ffe,(char *)felist,
; 1926 :                   edgetop, sizeof(struct bodyface),FCAST ffcomp);

	mov	edx, DWORD PTR _edgetop$[ebp]
	mov	eax, DWORD PTR _felist$[ebp]
	push	OFFSET _ffcomp
	push	16					; 00000010H
	push	edx
	push	eax
	lea	ecx, DWORD PTR _ffe$[ebp]
	push	ecx
	call	_bsearch
	add	esp, 20					; 00000014H

; 1927 :       if ( be == NULL ) 

	test	eax, eax
	jne	SHORT $LN33@string_reb

; 1928 :         { kb_error(1247,"Internal error: string_rebody() cannot find edge on stack (old body).\n",WARNING);

	push	2
	push	OFFSET ??_C@_0EH@PKLFEFCC@Internal?5error?3?5string_rebody?$CI?$CJ?5@
	push	1247					; 000004dfH

; 1929 : 
; 1930 :            goto otherend;

	jmp	$LN220@string_reb
$LN33@string_reb:

; 1931 :         }
; 1932 :       if ( !be->wrapflag )

	cmp	DWORD PTR [eax+12], 0
	jne	$LN197@string_reb

; 1933 :       { be->wrapflag = 1; /* mark as part of original body */

	mov	ecx, 1
	mov	DWORD PTR [eax+12], ecx

; 1934 :         stack[stacktop++] = ffe;

	mov	edx, DWORD PTR _ffe$[ebp]
	mov	eax, DWORD PTR _stack$[ebp]
	mov	DWORD PTR [eax+ebx*4], edx
	add	ebx, ecx

; 1935 :         edges_left--;

	sub	DWORD PTR _edges_left$[ebp], ecx
	jmp	$LN197@string_reb
$LL27@string_reb:

; 1952 :       }
; 1953 :     }
; 1954 : 
; 1955 :   /* now have to create new bodies */
; 1956 :   while ( edges_left > 0 )

	cmp	DWORD PTR _edges_left$[ebp], 0
	jle	$LN212@string_reb

; 1957 :     { /* find undone edge */
; 1958 :       for ( i  =  0 ; i < edgetop ; i++ )

	mov	esi, DWORD PTR _edgetop$[ebp]
	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN210@string_reb
	mov	ecx, DWORD PTR _felist$[ebp]
	add	ecx, 12					; 0000000cH
	npad	6
$LL25@string_reb:

; 1959 :          if ( felist[i].wrapflag == 0 ) break;

	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN210@string_reb

; 1957 :     { /* find undone edge */
; 1958 :       for ( i  =  0 ; i < edgetop ; i++ )

	inc	eax
	add	ecx, 16					; 00000010H
	cmp	eax, esi
	jl	SHORT $LL25@string_reb
$LN210@string_reb:

; 1960 :       if ( i == edgetop ) break;

	cmp	eax, esi
	je	$LN212@string_reb

; 1961 :       felist[i].wrapflag = 1;

	mov	ecx, DWORD PTR _felist$[ebp]
	add	eax, eax
	mov	DWORD PTR [ecx+eax*8+12], 1

; 1962 :       fe = felist[i].f_id;

	mov	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _fe$[ebp], eax

; 1963 :       f_id = get_fe_facet(fe);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN108@string_reb
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN107@string_reb
$LN108@string_reb:
	mov	ecx, DWORD PTR _web+460
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [edx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN107@string_reb
	xor	ecx, 134217728				; 08000000H
$LN107@string_reb:

; 1964 :       old_b = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	mov	DWORD PTR _f_id$[ebp], ecx
	jne	SHORT $LN114@string_reb
	xor	eax, eax
	jmp	SHORT $LN111@string_reb
$LN114@string_reb:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN113@string_reb
	xor	eax, eax
	jmp	SHORT $LN111@string_reb
$LN113@string_reb:
	mov	eax, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+328
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN112@string_reb
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+784]
	mov	eax, DWORD PTR [ecx+edx+4]
	jmp	SHORT $LN111@string_reb
$LN112@string_reb:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+784]
	mov	eax, DWORD PTR [ecx+edx]
$LN111@string_reb:

; 1965 :       b_id = dup_body(old_b);

	push	eax
	call	_dup_body
	mov	esi, eax

; 1966 :       new_f = dup_facet(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	call	_dup_facet

; 1967 :       new_bodies++;

	inc	DWORD PTR _new_bodies$[ebp]
	add	esp, 8
	mov	edi, eax

; 1968 :       set_body_facet(b_id,f_id);

	test	esi, 268435456				; 10000000H
	je	SHORT $LN117@string_reb
	mov	edx, DWORD PTR _web+348
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _f_id$[ebp]
	mov	DWORD PTR [eax+400], ecx
$LN117@string_reb:

; 1969 :       set_facet_body(new_f,b_id);

	push	esi
	push	edi
	call	_set_facet_body

; 1970 :       set_facet_fe(new_f,fe);

	mov	edx, DWORD PTR _fe$[ebp]
	push	edx
	push	edi
	call	_set_facet_fe

; 1971 :       set_fe_facet(fe,new_f);

	mov	eax, DWORD PTR _fe$[ebp]
	push	edi
	push	eax
	call	_set_fe_facet

; 1972 :       stack[stacktop++] = fe;

	mov	edx, DWORD PTR _stack$[ebp]
	mov	ecx, DWORD PTR _fe$[ebp]

; 1973 :       edges_left--;

	dec	DWORD PTR _edges_left$[ebp]
	mov	DWORD PTR [edx+ebx*4], ecx

; 1974 :       /* pull stuff off stack till empty */
; 1975 :       while (stacktop > 0 )

	mov	edx, DWORD PTR _web+460
	inc	ebx
	add	esp, 24					; 00000018H
	test	ebx, ebx
	jle	$LL27@string_reb
	npad	2
$LL20@string_reb:

; 1976 :       { fe = stack[--stacktop];

	mov	eax, DWORD PTR _stack$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4-4]
	dec	ebx

; 1977 : 
; 1978 :         ffe = get_prev_edge(fe);

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	DWORD PTR _fe$[ebp], eax
	mov	ecx, DWORD PTR [edx+ecx*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN121@string_reb
	mov	ecx, DWORD PTR [ecx+32]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN120@string_reb
$LN121@string_reb:
	mov	ecx, DWORD PTR [ecx+28]
$LN120@string_reb:
	mov	DWORD PTR _ffe$[ebp], ecx

; 1979 :         if ( !valid_id(ffe) ) goto anotherend;

	test	ecx, 268435456				; 10000000H
	je	$LN211@string_reb

; 1980 :         ff_id = get_fe_facet(ffe);

	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [esi+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN124@string_reb
	xor	esi, 134217728				; 08000000H
$LN124@string_reb:

; 1981 :         if ( !equal_id(ff_id,f_id) ) goto otherend;

	cmp	esi, DWORD PTR _f_id$[ebp]
	jne	$otherend$90740

; 1982 :         be = (struct bodyface *)bsearch((char *)&ffe,(char *)felist,
; 1983 :                     edgetop, sizeof(struct bodyface),FCAST ffcomp);

	mov	edx, DWORD PTR _edgetop$[ebp]
	mov	eax, DWORD PTR _felist$[ebp]
	push	OFFSET _ffcomp
	push	16					; 00000010H
	push	edx
	push	eax
	lea	ecx, DWORD PTR _ffe$[ebp]
	push	ecx
	call	_bsearch
	add	esp, 20					; 00000014H

; 1984 :         if ( be == NULL ) 

	test	eax, eax
	je	$LN161@string_reb

; 1986 :             goto otherend;
; 1987 :           }
; 1988 :         if ( !be->wrapflag )

	cmp	DWORD PTR [eax+12], 0

; 1989 :         { be->wrapflag = 1; /* mark as part of original body */

	mov	esi, 1
	jne	SHORT $LN195@string_reb

; 1990 :           stack[stacktop++] = ffe;
; 1991 :           edges_left--;

	sub	DWORD PTR _edges_left$[ebp], esi
	mov	DWORD PTR [eax+12], esi
	mov	edx, DWORD PTR _ffe$[ebp]
	mov	eax, DWORD PTR _stack$[ebp]
	mov	DWORD PTR [eax+ebx*4], edx

; 1992 :           set_fe_facet(ffe,new_f);

	mov	ecx, DWORD PTR _ffe$[ebp]
	push	edi
	push	ecx
	add	ebx, esi
	call	_set_fe_facet
	add	esp, 8
$LN195@string_reb:
	mov	eax, DWORD PTR _fe$[ebp]
	mov	edx, DWORD PTR _web+460
	jmp	SHORT $anotherend$90779
$LN211@string_reb:
	mov	esi, 1
$anotherend$90779:

; 1993 :         }
; 1994 : anotherend:
; 1995 :         ffe = get_next_edge(fe);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN129@string_reb
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN128@string_reb
$LN129@string_reb:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+32]
$LN128@string_reb:
	mov	DWORD PTR _ffe$[ebp], eax

; 1996 :         if ( !valid_id(ffe) ) continue;

	test	eax, 268435456				; 10000000H
	je	$LN213@string_reb

; 1997 :         ff_id = get_fe_facet(ffe);

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN132@string_reb
	xor	ecx, 134217728				; 08000000H
$LN132@string_reb:

; 1998 :         if ( !equal_id(ff_id,f_id) ) continue;

	cmp	ecx, DWORD PTR _f_id$[ebp]
	jne	SHORT $LN213@string_reb

; 1999 :         be = (struct bodyface *)bsearch((char *)&ffe,(char *)felist,
; 2000 :                     edgetop, sizeof(struct bodyface),FCAST ffcomp);

	mov	edx, DWORD PTR _edgetop$[ebp]
	mov	eax, DWORD PTR _felist$[ebp]
	push	OFFSET _ffcomp
	push	16					; 00000010H
	push	edx
	push	eax
	lea	ecx, DWORD PTR _ffe$[ebp]
	push	ecx
	call	_bsearch
	add	esp, 20					; 00000014H

; 2001 :         if ( be == NULL ) 

	test	eax, eax
	jne	SHORT $LN12@string_reb

; 2002 :           { kb_error(1250,"Internal error: string_rebody() cannot find edge on stack (old body).\n",WARNING);

	push	2
	push	OFFSET ??_C@_0EH@PKLFEFCC@Internal?5error?3?5string_rebody?$CI?$CJ?5@
	push	1250					; 000004e2H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2003 :             continue;

	jmp	SHORT $LN196@string_reb
$LN12@string_reb:

; 2004 :           }
; 2005 :         if ( !be->wrapflag )

	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN196@string_reb

; 2006 :         { be->wrapflag = 1; /* mark as part of original body */
; 2007 :           stack[stacktop++] = ffe;
; 2008 :           edges_left--;

	sub	DWORD PTR _edges_left$[ebp], esi
	mov	DWORD PTR [eax+12], esi
	mov	edx, DWORD PTR _ffe$[ebp]
	mov	eax, DWORD PTR _stack$[ebp]
	mov	DWORD PTR [eax+ebx*4], edx

; 2009 :           set_fe_facet(ffe,new_f);

	mov	ecx, DWORD PTR _ffe$[ebp]
	push	edi
	push	ecx
	add	ebx, esi
	call	_set_fe_facet
	add	esp, 8
$LN196@string_reb:
	mov	edx, DWORD PTR _web+460
$LN213@string_reb:

; 1974 :       /* pull stuff off stack till empty */
; 1975 :       while (stacktop > 0 )

	test	ebx, ebx
	jg	$LL20@string_reb

; 2010 :         }
; 2011 :      }
; 2012 :   }

	jmp	$LL27@string_reb
$LN161@string_reb:

; 1985 :           { kb_error(1249,"Internal error: string_rebody() cannot find edge on stack (old body).\n",WARNING);

	push	2
	push	OFFSET ??_C@_0EH@PKLFEFCC@Internal?5error?3?5string_rebody?$CI?$CJ?5@
	push	1249					; 000004e1H
$LN220@string_reb:
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN197@string_reb:

; 1929 : 
; 1930 :            goto otherend;

	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR _fe$[ebp]
$otherend$90740:

; 1936 :       }
; 1937 : otherend:
; 1938 :       ffe = get_next_edge(fe);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN100@string_reb
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN99@string_reb
$LN100@string_reb:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+32]
$LN99@string_reb:
	mov	DWORD PTR _ffe$[ebp], eax

; 1939 :       if ( !valid_id(ffe) ) continue;

	test	eax, 268435456				; 10000000H
	je	$LL37@string_reb

; 1940 :       ff_id = get_fe_facet(ffe);

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN103@string_reb
	xor	ecx, 134217728				; 08000000H
$LN103@string_reb:

; 1941 :       if ( !equal_id(ff_id,f_id) ) continue;

	cmp	ecx, DWORD PTR _f_id$[ebp]
	jne	$LL37@string_reb

; 1942 :       be = (struct bodyface *)bsearch((char *)&ffe,(char *)felist,
; 1943 :                   edgetop, sizeof(struct bodyface),FCAST ffcomp);

	mov	edx, DWORD PTR _edgetop$[ebp]
	mov	eax, DWORD PTR _felist$[ebp]
	push	OFFSET _ffcomp
	push	16					; 00000010H
	push	edx
	push	eax
	lea	ecx, DWORD PTR _ffe$[ebp]
	push	ecx
	call	_bsearch
	add	esp, 20					; 00000014H

; 1944 :       if ( be == NULL ) 

	test	eax, eax
	jne	SHORT $LN29@string_reb

; 1945 :         { kb_error(1248,"Internal error: string_rebody() cannot find edge on stack (old body).\n",WARNING);

	push	2
	push	OFFSET ??_C@_0EH@PKLFEFCC@Internal?5error?3?5string_rebody?$CI?$CJ?5@
	push	1248					; 000004e0H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1946 :           continue;

	jmp	$LL193@string_reb
$LN29@string_reb:

; 1947 :         }
; 1948 :       if ( !be->wrapflag )

	cmp	DWORD PTR [eax+12], 0
	jne	$LL193@string_reb

; 1949 :       { be->wrapflag = 1; /* mark as part of original body */

	mov	ecx, 1
	mov	DWORD PTR [eax+12], ecx

; 1950 :         stack[stacktop++] = ffe;

	mov	edx, DWORD PTR _ffe$[ebp]
	mov	eax, DWORD PTR _stack$[ebp]
	mov	DWORD PTR [eax+ebx*4], edx
	add	ebx, ecx

; 1951 :         edges_left--;

	sub	DWORD PTR _edges_left$[ebp], ecx
	jmp	$LL193@string_reb
$LN212@string_reb:

; 2013 : 
; 2014 :   // Make sure facet facetedge is first in open facet
; 2015 :   FOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR _web+272
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _f_id$[ebp], esi
	je	$LN8@string_reb
$LL10@string_reb:
	mov	eax, DWORD PTR _web+236
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edi, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	$LN9@string_reb

; 2016 :   { facetedge_id start_fe;
; 2017 :     start_fe = get_facet_fe(f_id);

	test	ecx, ecx
	jne	SHORT $LN137@string_reb
	xor	edi, edi
	jmp	SHORT $LN136@string_reb
$LN137@string_reb:
	test	DWORD PTR _f_id$[ebp], 134217728	; 08000000H
	mov	edi, DWORD PTR [edi+28]
	je	SHORT $LN136@string_reb
	xor	edi, 134217728				; 08000000H
$LN136@string_reb:

; 2018 :     if ( !valid_id(start_fe) ) continue;

	test	edi, 268435456				; 10000000H
	je	SHORT $LN9@string_reb

; 2019 :     fe = start_fe;

	mov	ecx, edi
	mov	DWORD PTR _fe$[ebp], ecx
	npad	7
$LL4@string_reb:

; 2020 :     do
; 2021 :     { 
; 2022 :       ffe = get_prev_edge(fe);

	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN141@string_reb
	mov	eax, DWORD PTR [eax+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN140@string_reb
$LN141@string_reb:
	mov	eax, DWORD PTR [eax+28]
$LN140@string_reb:
	mov	DWORD PTR _ffe$[ebp], eax

; 2023 :       if ( !valid_id(ffe) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN163@string_reb

; 2025 :         break;
; 2026 :       }
; 2027 :       fe = ffe;

	mov	ecx, eax
	mov	DWORD PTR _fe$[ebp], ecx

; 2028 :     } while ( !equal_id(fe,start_fe) );

	cmp	eax, edi
	jne	SHORT $LL4@string_reb
	jmp	SHORT $LN9@string_reb
$LN163@string_reb:

; 2024 :       { set_facet_fe(f_id,fe);

	push	ecx
	mov	ecx, DWORD PTR _f_id$[ebp]
	push	ecx
	call	_set_facet_fe
	mov	edx, DWORD PTR _web+460
	add	esp, 8
$LN9@string_reb:

; 2013 : 
; 2014 :   // Make sure facet facetedge is first in open facet
; 2015 :   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [esi+eax]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _f_id$[ebp], esi
	jne	$LL10@string_reb
$LN8@string_reb:

; 2029 :   }
; 2030 : 
; 2031 :   temp_free((char*)felist);

	mov	edx, DWORD PTR _felist$[ebp]
	push	edx
	call	_temp_free

; 2032 :   temp_free((char*)stack);

	mov	eax, DWORD PTR _stack$[ebp]
	push	eax
	call	_temp_free

; 2033 :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	esp, 8
	inc	eax
	pop	edi
	pop	esi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 2034 :   return new_bodies;

	mov	eax, DWORD PTR _new_bodies$[ebp]
	pop	ebx

; 2035 : } // end string_rebody()

	mov	esp, ebp
	pop	ebp
	ret	0
_string_rebody ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@NDFCKKON@Dissolving?5vertex?5?$CFs?6?$AA@ ; `string'
PUBLIC	_dissolve_vertex
;	COMDAT ??_C@_0BG@NDFCKKON@Dissolving?5vertex?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BG@NDFCKKON@Dissolving?5vertex?5?$CFs?6?$AA@ DB 'Dissolving vertex'
	DB	' %s', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _dissolve_vertex
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_dissolve_vertex PROC					; COMDAT

; 2047 : { edge_id e_id;

	push	ebp
	mov	ebp, esp
	push	edi

; 2048 : 
; 2049 :   if ( !valid_element(v_id) ) return 0;

	mov	edi, DWORD PTR _v_id$[ebp]
	push	edi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@dissolve_v
$LN12@dissolve_v:
	xor	eax, eax
	pop	edi

; 2064 : } // end dissolve_vertex()

	pop	ebp
	ret	0
$LN6@dissolve_v:

; 2050 :   if ( ( web.representation == SIMPLEX ) || ( web.modeltype == LAGRANGE ) )

	mov	eax, DWORD PTR _web+12
	mov	ecx, 3
	cmp	DWORD PTR _web+624, ecx
	je	SHORT $LN4@dissolve_v
	cmp	DWORD PTR _web+628, ecx
	jne	SHORT $LN3@dissolve_v
$LN4@dissolve_v:

; 2051 :   { if ( valid_id(get_vertex_facet(v_id)) ) 

	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	test	DWORD PTR [edx+32], 268435456		; 10000000H

; 2052 :       return 0;

	jne	SHORT $LN12@dissolve_v
$LN3@dissolve_v:
	push	esi

; 2053 :   }
; 2054 :   e_id = get_vertex_edge(v_id);

	mov	esi, edi
	and	esi, 134217727				; 07ffffffH

; 2055 :   if ( valid_id(e_id) ) return 0;

	mov	eax, DWORD PTR [eax+esi*4]
	test	DWORD PTR [eax+28], 268435456		; 10000000H
	je	SHORT $LN2@dissolve_v
	pop	esi
	xor	eax, eax
	pop	edi

; 2064 : } // end dissolve_vertex()

	pop	ebp
	ret	0
$LN2@dissolve_v:

; 2056 :   free_element(v_id);

	push	edi
	call	_free_element

; 2057 :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	add	esp, 4

; 2058 :   if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	je	SHORT $LN1@dissolve_v

; 2059 :   { sprintf(msg,"Dissolving vertex %s\n",ELNAME(v_id));

	test	edi, 268435456				; 10000000H
	je	SHORT $LN9@dissolve_v
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN10@dissolve_v
$LN9@dissolve_v:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN10@dissolve_v:
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BG@NDFCKKON@Dissolving?5vertex?5?$CFs?6?$AA@
	push	ecx
	call	_sprintf

; 2060 :     outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN1@dissolve_v:

; 2061 :   }
; 2062 : 
; 2063 :   return 1;

	pop	esi
	mov	eax, 1
	pop	edi

; 2064 : } // end dissolve_vertex()

	pop	ebp
	ret	0
_dissolve_vertex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@NKBMCHKF@Assumed?5edge?5tip?5is?5not?5a?5tip?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@FIECCNCA@Dissolving?5edge?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0DA@BBKKGIPB@Not?5dissolving?5edge?5?$CFs?5since?5sti@ ; `string'
PUBLIC	??_C@_0EI@LHGDLMLL@Not?5dissolving?5edge?5?$CFs?5since?5tha@ ; `string'
PUBLIC	??_C@_0CI@FBCNJDKE@Dissolving?5edge?5?$CFs?5between?5two?5f@ ; `string'
PUBLIC	??_C@_0ED@IHAJMPMO@Not?5dissolving?5edge?5?$CFs?5since?5tha@ ; `string'
PUBLIC	_dissolve_edge
EXTRN	_assure_v_constraints:PROC
EXTRN	_get_edge_valence:PROC
;	COMDAT ??_C@_0CA@NKBMCHKF@Assumed?5edge?5tip?5is?5not?5a?5tip?4?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CA@NKBMCHKF@Assumed?5edge?5tip?5is?5not?5a?5tip?4?6?$AA@ DB 'Assum'
	DB	'ed edge tip is not a tip.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FIECCNCA@Dissolving?5edge?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BE@FIECCNCA@Dissolving?5edge?5?$CFs?6?$AA@ DB 'Dissolving edge %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BBKKGIPB@Not?5dissolving?5edge?5?$CFs?5since?5sti@
CONST	SEGMENT
??_C@_0DA@BBKKGIPB@Not?5dissolving?5edge?5?$CFs?5since?5sti@ DB 'Not diss'
	DB	'olving edge %s since still on a facet.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@LHGDLMLL@Not?5dissolving?5edge?5?$CFs?5since?5tha@
CONST	SEGMENT
??_C@_0EI@LHGDLMLL@Not?5dissolving?5edge?5?$CFs?5since?5tha@ DB 'Not diss'
	DB	'olving edge %s since that would separate facet into two loops'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FBCNJDKE@Dissolving?5edge?5?$CFs?5between?5two?5f@
CONST	SEGMENT
??_C@_0CI@FBCNJDKE@Dissolving?5edge?5?$CFs?5between?5two?5f@ DB 'Dissolvi'
	DB	'ng edge %s between two facets.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@IHAJMPMO@Not?5dissolving?5edge?5?$CFs?5since?5tha@
CONST	SEGMENT
??_C@_0ED@IHAJMPMO@Not?5dissolving?5edge?5?$CFs?5since?5tha@ DB 'Not diss'
	DB	'olving edge %s since that would make facet into two arcs.', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _dissolve_edge
_TEXT	SEGMENT
tv1509 = -36						; size = 4
tv1506 = -32						; size = 4
_start_fe$ = -32					; size = 4
tv1315 = -28						; size = 4
_ff_id$90928 = -28					; size = 4
_next$90930 = -24					; size = 4
_evalence$ = -24					; size = 4
_ffe$90926 = -20					; size = 4
_baddies$90853 = -20					; size = 4
_prev$90931 = -16					; size = 4
_loopers$90854 = -16					; size = 4
tv1516 = -12						; size = 4
tv1368 = -12						; size = 4
_prevfe$90859 = -8					; size = 4
_fe$ = -8						; size = 4
_f_id$ = -4						; size = 4
_e_id$ = 8						; size = 4
_dissolve_edge PROC					; COMDAT

; 2076 : { facetedge_id fe,fe_id,start_fe;

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi

; 2077 :   vertex_id head,tail;
; 2078 :   int evalence;
; 2079 :   facet_id f_id=NULLID;
; 2080 : 
; 2081 :   if ( !valid_element(e_id) ) return 0;

	mov	esi, DWORD PTR _e_id$[ebp]
	push	edi
	xor	edi, edi
	push	esi
	mov	DWORD PTR _f_id$[ebp], edi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN93@dissolve_e
	pop	edi
	pop	esi

; 2360 : } // end dissolve_edge()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN93@dissolve_e:
	push	ebx

; 2082 : 
; 2083 :   evalence = get_edge_valence(e_id);

	push	esi
	call	_get_edge_valence
	add	esp, 4

; 2084 : 
; 2085 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	mov	DWORD PTR _evalence$[ebp], eax
	jne	$LN92@dissolve_e

; 2086 :   {
; 2087 : #ifdef CODDLING
; 2088 :     /* check for at most one facet */
; 2089 :     if ( evalence > 1 )
; 2090 :     { if ( verbose_flag )
; 2091 :       { sprintf(msg,"Not dissolving edge %s since still on two facets.\n",
; 2092 :           ELNAME(e_id));
; 2093 :         outstring(msg);
; 2094 :       }
; 2095 :       return 0;
; 2096 :     }
; 2097 : #endif
; 2098 :   
; 2099 :     /* check for being at beginning or end of edge arc for all facets */
; 2100 :     if ( evalence > 0 )

	cmp	eax, edi
	jle	$LN199@dissolve_e

; 2101 :     { int baddies = 0;  // number of facets split into two arcs
; 2102 :       int loopers = 0;  // number of full loop facets
; 2103 :       start_fe = fe_id = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv1315[ebp], eax
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _baddies$90853[ebp], edi
	mov	DWORD PTR _loopers$90854[ebp], edi
	cmp	eax, edi
	jne	SHORT $LN107@dissolve_e
	xor	esi, esi
	jmp	SHORT $LN108@dissolve_e
$LN107@dissolve_e:
	mov	eax, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN106@dissolve_e
	xor	eax, 134217728				; 08000000H
$LN106@dissolve_e:
	mov	esi, eax
$LN108@dissolve_e:
	mov	ebx, DWORD PTR _web+460
	mov	DWORD PTR _start_fe$[ebp], esi
$LL90@dissolve_e:

; 2104 :       do
; 2105 :       { facetedge_id nextfe,prevfe,flipfe;
; 2106 : 
; 2107 :         fe = fe_id;
; 2108 :         nextfe = get_next_edge(fe);

	mov	ecx, esi
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	eax, esi
	mov	DWORD PTR tv1368[ebp], ecx
	je	SHORT $LN111@dissolve_e
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR [edi+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN110@dissolve_e
$LN111@dissolve_e:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+ecx*4]
	mov	edx, DWORD PTR [edi+32]
$LN110@dissolve_e:

; 2109 :         prevfe = get_prev_edge(fe);

	cmp	DWORD PTR tv1368[ebp], 0
	je	SHORT $LN115@dissolve_e
	mov	ecx, DWORD PTR [edi+32]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN210@dissolve_e
$LN115@dissolve_e:
	mov	ecx, DWORD PTR [edi+28]
$LN210@dissolve_e:

; 2110 :         flipfe = inverse_id(get_next_facet(fe));

	cmp	DWORD PTR tv1368[ebp], 0
	mov	DWORD PTR _prevfe$90859[ebp], ecx
	je	SHORT $LN119@dissolve_e
	mov	ecx, DWORD PTR [edi+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN118@dissolve_e
$LN119@dissolve_e:
	mov	ecx, DWORD PTR [edi+40]
$LN118@dissolve_e:
	xor	ecx, 134217728				; 08000000H

; 2111 :         if ( valid_id(nextfe) && valid_id(prevfe) &&
; 2112 :            !( equal_id(nextfe,flipfe) || equal_id(prevfe,flipfe) ) )

	test	edx, 268435456				; 10000000H
	je	SHORT $LN203@dissolve_e
	test	DWORD PTR _prevfe$90859[ebp], 268435456	; 10000000H
	je	SHORT $LN203@dissolve_e
	cmp	edx, ecx
	je	SHORT $LN203@dissolve_e
	cmp	DWORD PTR _prevfe$90859[ebp], ecx
	je	SHORT $LN203@dissolve_e
	npad	1
$LL86@dissolve_e:

; 2113 :         {
; 2114 :           /* check for full loop */
; 2115 :           do { fe = get_next_edge(fe); }

	test	eax, 134217728				; 08000000H
	je	SHORT $LN123@dissolve_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN85@dissolve_e
$LN123@dissolve_e:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+32]
$LN85@dissolve_e:

; 2116 :           while ( valid_id(fe) && !equal_id(fe,fe_id) );

	test	eax, 268435456				; 10000000H
	je	SHORT $LN212@dissolve_e
	cmp	eax, esi
	jne	SHORT $LL86@dissolve_e

; 2117 :           if ( !valid_id(fe) )

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN82@dissolve_e
$LN212@dissolve_e:

; 2118 :             baddies++;

	inc	DWORD PTR _baddies$90853[ebp]

; 2119 :           else 

	jmp	SHORT $LN203@dissolve_e
$LN82@dissolve_e:

; 2120 :             loopers++;

	inc	DWORD PTR _loopers$90854[ebp]
$LN203@dissolve_e:

; 2121 :         }
; 2122 :         fe_id = get_next_facet(fe_id);

	cmp	DWORD PTR tv1368[ebp], 0
	je	SHORT $LN127@dissolve_e
	mov	esi, DWORD PTR [edi+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN89@dissolve_e
$LN127@dissolve_e:
	mov	esi, DWORD PTR [edi+40]
$LN89@dissolve_e:

; 2123 :       } while ( fe_id != start_fe );

	cmp	esi, DWORD PTR _start_fe$[ebp]
	jne	$LL90@dissolve_e

; 2124 : 
; 2125 :       if ( baddies > loopers ) // second full loop can rescue split arc

	mov	ecx, DWORD PTR _loopers$90854[ebp]
	cmp	DWORD PTR _baddies$90853[ebp], ecx
	jle	SHORT $LN80@dissolve_e

; 2126 :       { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN71@dissolve_e

; 2127 :             { sprintf(msg,
; 2128 :                "Not dissolving edge %s since that would make facet into two arcs.\n",
; 2129 :                    ELNAME(e_id));

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN96@dissolve_e
	mov	edx, DWORD PTR tv1315[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	push	eax
	push	OFFSET ??_C@_0ED@IHAJMPMO@Not?5dissolving?5edge?5?$CFs?5since?5tha@

; 2130 :               outstring(msg);
; 2131 :             }
; 2132 :         return 0;

	jmp	$LN222@dissolve_e
$LN96@dissolve_e:

; 2127 :             { sprintf(msg,
; 2128 :                "Not dissolving edge %s since that would make facet into two arcs.\n",
; 2129 :                    ELNAME(e_id));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0ED@IHAJMPMO@Not?5dissolving?5edge?5?$CFs?5since?5tha@

; 2130 :               outstring(msg);
; 2131 :             }
; 2132 :         return 0;

	jmp	$LN222@dissolve_e
$LN80@dissolve_e:

; 2133 :       }
; 2134 : 
; 2135 :       if ( evalence > 1 )

	cmp	DWORD PTR _evalence$[ebp], 1
	jle	SHORT $LN199@dissolve_e

; 2136 :       { sprintf(msg,"Dissolving edge %s between two facets.\n",ELNAME(e_id));

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN98@dissolve_e
	mov	edx, DWORD PTR tv1315[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN99@dissolve_e
$LN98@dissolve_e:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN99@dissolve_e:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0CI@FBCNJDKE@Dissolving?5edge?5?$CFs?5between?5two?5f@
	push	eax
	call	_sprintf

; 2137 :         kb_error(2172,msg,WARNING);

	mov	ecx, DWORD PTR _msg
	push	2
	push	ecx
	push	2172					; 0000087cH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN199@dissolve_e:

; 2138 :       }
; 2139 :     }
; 2140 : 
; 2141 :     // check it won't divide one facet loop into two by doubling back
; 2142 :     if ( evalence==2 )

	cmp	DWORD PTR _evalence$[ebp], 2
	jne	$LN206@dissolve_e

; 2143 :     { fe_id = get_edge_fe(e_id);

	mov	edx, DWORD PTR _e_id$[ebp]
	push	edx
	call	_get_edge_fe
	mov	esi, eax

; 2144 :       fe = get_next_facet(fe_id);

	push	esi
	call	_get_next_facet
	mov	edi, eax

; 2145 :       if ( equal_element(get_fe_facet(fe_id),get_fe_facet(fe)) ) 

	push	edi
	call	_get_fe_facet
	mov	ebx, eax
	push	esi
	or	ebx, 134217728				; 08000000H
	call	_get_fe_facet
	or	eax, 134217728				; 08000000H
	add	esp, 16					; 00000010H
	cmp	eax, ebx
	jne	$LN206@dissolve_e

; 2146 :       { // ok if at tip with immediate double-back
; 2147 :         if ( !equal_element(fe,get_next_edge(fe_id)) && 
; 2148 :              !equal_element(fe,get_prev_edge(fe_id)) )

	push	esi
	or	edi, 134217728				; 08000000H
	call	_get_next_edge
	or	eax, 134217728				; 08000000H
	add	esp, 4
	cmp	edi, eax
	je	$LN206@dissolve_e
	push	esi
	call	_get_prev_edge
	or	eax, 134217728				; 08000000H
	add	esp, 4
	cmp	edi, eax
	je	$LN206@dissolve_e

; 2149 :         { // have a problem
; 2150 :           if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN71@dissolve_e

; 2151 :           { sprintf(msg,"Not dissolving edge %s since that would separate facet into two loops.\n",
; 2152 :                ELNAME(e_id));

	mov	eax, DWORD PTR _e_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN100@dissolve_e
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN101@dissolve_e
$LN100@dissolve_e:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN101@dissolve_e:
	push	eax
	push	OFFSET ??_C@_0EI@LHGDLMLL@Not?5dissolving?5edge?5?$CFs?5since?5tha@
$LN222@dissolve_e:
	mov	eax, DWORD PTR _msg
	push	eax
	call	_sprintf

; 2153 :             outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
	pop	ebx
	pop	edi

; 2154 :           }
; 2155 :           return 0;

	xor	eax, eax
	pop	esi

; 2360 : } // end dissolve_edge()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN92@dissolve_e:

; 2156 :         }
; 2157 :       }
; 2158 :     } // end split check
; 2159 :   }
; 2160 :   else if ( evalence > 0 ) 

	cmp	eax, edi
	jle	SHORT $LN72@dissolve_e

; 2161 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, edi
	je	SHORT $LN71@dissolve_e

; 2162 :     { sprintf(msg,"Not dissolving edge %s since still on a facet.\n",
; 2163 :          ELNAME(e_id));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN102@dissolve_e
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN103@dissolve_e
$LN102@dissolve_e:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN103@dissolve_e:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0DA@BBKKGIPB@Not?5dissolving?5edge?5?$CFs?5since?5sti@
	push	edx
	call	_sprintf

; 2164 :       outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
$LN71@dissolve_e:

; 2165 :     }
; 2166 :     return 0;

	pop	ebx
	pop	edi
	xor	eax, eax
	pop	esi

; 2360 : } // end dissolve_edge()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN206@dissolve_e:

; 2165 :     }
; 2166 :     return 0;

	mov	esi, DWORD PTR _e_id$[ebp]
$LN72@dissolve_e:

; 2167 :   }
; 2168 : 
; 2169 :   if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN208@dissolve_e

; 2170 :   { sprintf(msg,"Dissolving edge %s\n",ELNAME(e_id));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN104@dissolve_e
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN105@dissolve_e
$LN104@dissolve_e:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN105@dissolve_e:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BE@FIECCNCA@Dissolving?5edge?5?$CFs?6?$AA@
	push	edx
	call	_sprintf

; 2171 :     outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
$LN208@dissolve_e:

; 2172 :   }
; 2173 : 
; 2174 :   fe = get_edge_fe(e_id);

	mov	edx, DWORD PTR _web+124
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	test	eax, eax
	jne	SHORT $LN131@dissolve_e
	xor	edi, edi
	mov	DWORD PTR _fe$[ebp], edi
	jmp	SHORT $LN132@dissolve_e
$LN131@dissolve_e:
	mov	eax, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN130@dissolve_e
	xor	eax, 134217728				; 08000000H
$LN130@dissolve_e:
	mov	edi, eax
	mov	DWORD PTR _fe$[ebp], eax
$LN132@dissolve_e:

; 2175 :   if ( !valid_id(fe) )

	test	edi, 268435456				; 10000000H
	jne	SHORT $LN69@dissolve_e

; 2176 :   { free_element(e_id); return 1; }

	mov	eax, DWORD PTR _e_id$[ebp]
	push	eax
	call	_free_element
	add	esp, 4
	pop	ebx
	pop	edi

; 2359 :   return 1;

	mov	eax, 1
	pop	esi

; 2360 : } // end dissolve_edge()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN69@dissolve_e:

; 2177 : 
; 2178 :   head = get_edge_headv(e_id);

	mov	ebx, DWORD PTR _e_id$[ebp]
	push	ebx
	call	_get_edge_headv
	add	esp, 4

; 2179 :   tail = get_edge_tailv(e_id);
; 2180 : 
; 2181 :   /* reset vertex-edge links */
; 2182 :   remove_vertex_edge(tail,e_id);

	push	ebx
	push	ebx
	mov	esi, eax
	call	_get_edge_tailv
	add	esp, 4
	push	eax
	call	_remove_vertex_edge

; 2183 :   remove_vertex_edge(head,inverse_id(e_id));

	xor	ebx, 134217728				; 08000000H
	push	ebx
	push	esi
	call	_remove_vertex_edge

; 2184 : 
; 2185 :   /* reset facet facetedges */
; 2186 :   if ( web.representation == STRING )
; 2187 :   { facetedge_id ffe = fe, next_fe;

	mov	esi, DWORD PTR _web+460
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _web+624, 1
	jne	$LN50@dissolve_e
$LL67@dissolve_e:

; 2188 :     do // loop over all facets on edge
; 2189 :     {
; 2190 :         f_id = get_fe_facet(ffe);  

	test	edi, 268435456				; 10000000H
	jne	SHORT $LN135@dissolve_e
	mov	ebx, DWORD PTR _NULLFACET
	mov	DWORD PTR _f_id$[ebp], ebx
	jmp	SHORT $LN136@dissolve_e
$LN135@dissolve_e:
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+ecx*4]
	mov	eax, DWORD PTR [edx+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN134@dissolve_e
	xor	eax, 134217728				; 08000000H
$LN134@dissolve_e:
	mov	ebx, eax
	mov	DWORD PTR _f_id$[ebp], eax
$LN136@dissolve_e:

; 2191 :         if ( valid_id(f_id) ) 

	test	ebx, 268435456				; 10000000H
	je	$LN207@dissolve_e

; 2192 :         { // need to reset first edge in facetedge chain
; 2193 :           if ( inverted(f_id) ) 

	test	ebx, 134217728				; 08000000H
	je	SHORT $LN63@dissolve_e

; 2194 :           { next_fe = get_prev_edge(ffe);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN139@dissolve_e
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [ecx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN138@dissolve_e
$LN139@dissolve_e:
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	eax, DWORD PTR [ecx+28]
$LN138@dissolve_e:

; 2195 :             if ( valid_id(next_fe) )

	test	eax, 268435456				; 10000000H
	je	$LN56@dissolve_e

; 2196 :             { // test for double-back
; 2197 :               if ( equal_element(get_fe_edge(ffe),get_fe_edge(next_fe)) )

	mov	ecx, DWORD PTR [ecx+20]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR [edx+20]
	or	edx, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	ecx, edx
	jne	SHORT $LN61@dissolve_e

; 2198 :                 next_fe = get_prev_edge(next_fe);

	push	eax
	call	_get_prev_edge
	add	esp, 4
$LN61@dissolve_e:

; 2199 :               if ( equal_id(next_fe,ffe) )

	cmp	eax, edi
	jne	SHORT $LN60@dissolve_e

; 2200 :                 next_fe = NULLID;

	xor	eax, eax
$LN60@dissolve_e:

; 2201 :                set_facet_fe(f_id,next_fe);

	push	eax

; 2202 :             }
; 2203 :             else 

	jmp	SHORT $LN214@dissolve_e
$LN63@dissolve_e:

; 2204 :               if ( equal_id(ffe,get_facet_fe(f_id)) )
; 2205 :               { // was only edge in facet
; 2206 :                 set_facet_fe(f_id,NULLID); 
; 2207 :               }
; 2208 :           } 
; 2209 :           else // not inverted facet
; 2210 :           { next_fe = get_next_edge(ffe);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN147@dissolve_e
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+edx*4]
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN146@dissolve_e
$LN147@dissolve_e:
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [ecx+32]
$LN146@dissolve_e:

; 2211 :             if ( valid_id(next_fe) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN56@dissolve_e

; 2212 :             { // test for double-back
; 2213 :               if ( equal_element(get_fe_edge(ffe),get_fe_edge(next_fe)) )

	mov	ecx, DWORD PTR [ecx+20]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR [edx+20]
	or	edx, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	ecx, edx
	jne	SHORT $LN55@dissolve_e

; 2214 :                 next_fe = get_next_edge(next_fe);

	push	eax
	call	_get_next_edge
	add	esp, 4
$LN55@dissolve_e:

; 2215 :               if ( equal_id(next_fe,ffe) )

	cmp	eax, edi
	jne	SHORT $LN60@dissolve_e

; 2216 :                 next_fe = NULLID;

	xor	eax, eax

; 2217 :               set_facet_fe(f_id,next_fe);

	push	eax

; 2218 :             }
; 2219 :             else 

	jmp	SHORT $LN214@dissolve_e
$LN56@dissolve_e:

; 2220 :               if ( equal_id(ffe,get_facet_fe(f_id)) )

	push	ebx
	call	_get_facet_fe
	add	esp, 4
	cmp	edi, eax
	jne	SHORT $LN207@dissolve_e

; 2221 :               { // was only edge in facet
; 2222 :                 set_facet_fe(f_id,NULLID); 

	push	0
$LN214@dissolve_e:
	push	ebx
	call	_set_facet_fe
	mov	esi, DWORD PTR _web+460
	add	esp, 8
$LN207@dissolve_e:

; 2223 :               }
; 2224 :           }       
; 2225 :       }
; 2226 :       ffe = get_next_facet(ffe);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN155@dissolve_e
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edi*4]
	mov	edi, DWORD PTR [edx+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN66@dissolve_e
$LN155@dissolve_e:
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+edi*4]
	mov	edi, DWORD PTR [eax+40]
$LN66@dissolve_e:

; 2227 :     } while ( valid_id(ffe) && !equal_id(ffe,fe) );

	test	edi, 268435456				; 10000000H
	je	SHORT $LN51@dissolve_e
	cmp	edi, DWORD PTR _fe$[ebp]
	jne	$LL67@dissolve_e
$LN51@dissolve_e:

; 2228 :   }
; 2229 : 
; 2230 :   if ( (web.representation == STRING) && (evalence == 2) )

	cmp	DWORD PTR _web+624, 1
	jne	$LN50@dissolve_e
	cmp	DWORD PTR _evalence$[ebp], 2
	jne	$LN50@dissolve_e

; 2231 :   { // merge the two facets/bodies
; 2232 :     facetedge_id ffe = get_next_facet(fe),fffe;

	mov	ebx, DWORD PTR _fe$[ebp]
	push	ebx
	call	_get_next_facet
	mov	esi, eax

; 2233 :     facet_id ff_id = inverse_id(get_fe_facet(ffe));

	push	esi
	mov	DWORD PTR _ffe$90926[ebp], esi
	call	_get_fe_facet
	mov	edi, eax
	xor	edi, 134217728				; 08000000H

; 2234 :     body_id b_id; 
; 2235 :     facetedge_id next,prev,nnext,pprev;
; 2236 : 
; 2237 :     f_id = get_fe_facet(fe); 

	push	ebx
	mov	DWORD PTR _ff_id$90928[ebp], edi
	call	_get_fe_facet
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f_id$[ebp], ebx

; 2238 : 
; 2239 :     if ( equal_id(f_id,ff_id) )

	cmp	ebx, edi
	jne	$LN49@dissolve_e

; 2240 :     { // eliminating a tip
; 2241 :       if ( equal_id(inverse_id(ffe),get_next_edge(fe)) )

	mov	edi, DWORD PTR _fe$[ebp]
	push	edi
	xor	esi, 134217728				; 08000000H
	call	_get_next_edge
	add	esp, 4

; 2242 :       { prev = get_prev_edge(fe);

	push	edi
	cmp	esi, eax
	jne	SHORT $LN48@dissolve_e
	call	_get_prev_edge

; 2243 :         next = get_next_edge(inverse_id(ffe));

	push	esi
	mov	edi, eax
	call	_get_next_edge
	mov	esi, eax

; 2244 :         set_prev_edge(next,prev);

	push	edi
	push	esi
	call	_set_prev_edge

; 2245 :         set_next_edge(prev,next);

	push	esi
	push	edi
	call	_set_next_edge
	add	esp, 24					; 00000018H
	jmp	$LN12@dissolve_e
$LN48@dissolve_e:

; 2246 :       }
; 2247 :       else  if ( equal_id(inverse_id(ffe),get_prev_edge(fe)) )

	call	_get_prev_edge
	add	esp, 4
	cmp	esi, eax
	jne	SHORT $LN46@dissolve_e

; 2248 :       { prev = get_prev_edge(inverse_id(ffe));

	push	esi
	call	_get_prev_edge

; 2249 :         next = get_next_edge(fe);

	push	edi
	mov	esi, eax
	call	_get_next_edge
	mov	edi, eax

; 2250 :         set_prev_edge(next,prev);

	push	esi
	push	edi
	call	_set_prev_edge

; 2251 :         set_next_edge(prev,next);

	push	edi
	push	esi
	call	_set_next_edge
	add	esp, 24					; 00000018H

; 2252 :       }
; 2253 :       else

	jmp	$LN12@dissolve_e
$LN46@dissolve_e:

; 2254 :         kb_error(1948,"Assumed edge tip is not a tip.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CA@NKBMCHKF@Assumed?5edge?5tip?5is?5not?5a?5tip?4?6?$AA@
	push	1948					; 0000079cH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2255 :     } // end tip
; 2256 :     else

	jmp	$LN12@dissolve_e
$LN49@dissolve_e:

; 2257 :     { // different facets
; 2258 :       b_id = get_facet_body(f_id); 

	push	ebx
	call	_get_facet_body

; 2259 :       set_facet_body(ff_id,b_id);          

	push	eax
	push	edi
	call	_set_facet_body

; 2260 :       b_id = get_facet_body(inverse_id(f_id));

	mov	ecx, ebx
	xor	ecx, 134217728				; 08000000H
	push	ecx
	call	_get_facet_body

; 2261 :       set_facet_body(inverse_id(ff_id),b_id);

	mov	edx, edi
	push	eax
	xor	edx, 134217728				; 08000000H
	push	edx
	call	_set_facet_body

; 2262 : 
; 2263 :       start_fe = get_facet_fe(ff_id);

	push	edi
	call	_get_facet_fe
	mov	edi, eax
	add	esp, 28					; 0000001cH

; 2264 :       fffe = start_fe;

	mov	esi, edi
$LL43@dissolve_e:

; 2265 :       do
; 2266 :       { set_fe_facet(fffe,f_id);

	push	ebx
	push	esi
	call	_set_fe_facet
	add	esp, 8

; 2267 :         fffe = get_next_edge(fffe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN159@dissolve_e
	mov	eax, DWORD PTR _web+460
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN42@dissolve_e
$LN159@dissolve_e:
	mov	edx, DWORD PTR _web+460
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [eax+32]
$LN42@dissolve_e:

; 2268 :       } while ( valid_id(fffe) && !equal_id(fffe,start_fe) );

	test	esi, 268435456				; 10000000H
	je	SHORT $LN217@dissolve_e
	cmp	esi, edi
	jne	SHORT $LL43@dissolve_e

; 2269 :       if ( !valid_id(fffe) )

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN36@dissolve_e
$LN217@dissolve_e:

; 2270 :       { // go backwards to be sure we get all 
; 2271 :         fffe = start_fe;

	mov	esi, edi
	npad	7
$LL38@dissolve_e:

; 2272 :         do
; 2273 :         { set_fe_facet(fffe,f_id);

	push	ebx
	push	esi
	call	_set_fe_facet

; 2274 :           fffe = get_prev_edge(fffe);

	push	esi
	call	_get_prev_edge
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 2275 :         } while ( valid_id(fffe) && !equal_id(fffe,start_fe) );

	test	esi, 268435456				; 10000000H
	je	SHORT $LN36@dissolve_e
	cmp	esi, edi
	jne	SHORT $LL38@dissolve_e
$LN36@dissolve_e:

; 2276 :       }
; 2277 :       // In case of content constraints
; 2278 :       if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN30@dissolve_e

; 2279 :       { fffe = start_fe;
; 2280 :         while ( valid_id(get_prev_edge(fffe)) && !equal_id(start_fe,get_prev_edge(fffe)) )

	push	edi
	mov	esi, edi
	call	_get_prev_edge
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN32@dissolve_e
	npad	3
$LL33@dissolve_e:
	push	esi
	call	_get_prev_edge
	add	esp, 4
	cmp	edi, eax
	je	SHORT $LN32@dissolve_e

; 2281 :           fffe = get_prev_edge(fffe);

	push	esi
	call	_get_prev_edge
	mov	esi, eax
	push	esi
	call	_get_prev_edge
	add	esp, 8
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL33@dissolve_e
$LN32@dissolve_e:

; 2282 :         start_fe = fffe;
; 2283 :         assure_v_constraints(get_fe_tailv(start_fe));

	push	esi
	mov	edi, esi
	call	_get_fe_edge
	push	eax
	call	_get_edge_tailv
	push	eax
	call	_assure_v_constraints
	add	esp, 12					; 0000000cH

; 2284 :         while ( valid_id(fffe) && !equal_id(fffe,start_fe) )

	test	esi, 268435456				; 10000000H
	je	SHORT $LN30@dissolve_e
$LL31@dissolve_e:
	cmp	esi, edi
	je	SHORT $LN30@dissolve_e

; 2285 :         {  assure_v_constraints(get_fe_headv(fffe));

	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, esi
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_get_edge_headv
	push	eax
	call	_assure_v_constraints

; 2286 :            fffe = get_next_edge(fffe);

	push	esi
	call	_get_next_edge
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, 268435456				; 10000000H
	jne	SHORT $LL31@dissolve_e
$LN30@dissolve_e:

; 2287 :         }
; 2288 :       }
; 2289 : 
; 2290 :       prev = get_prev_edge(fe);

	mov	edx, DWORD PTR _fe$[ebp]
	push	edx
	call	_get_prev_edge
	mov	esi, eax

; 2291 :       pprev = inverse_id(get_prev_edge(ffe));

	mov	eax, DWORD PTR _ffe$90926[ebp]
	push	eax
	mov	DWORD PTR _prev$90931[ebp], esi
	call	_get_prev_edge
	mov	ebx, eax

; 2292 :       if ( valid_id(prev) )

	mov	eax, esi
	shr	eax, 28					; 0000001cH
	add	esp, 8
	xor	ebx, 134217728				; 08000000H
	and	eax, 1
	mov	DWORD PTR tv1506[ebp], eax
	je	SHORT $LN29@dissolve_e

; 2293 :         set_next_edge(prev,pprev);

	push	ebx
	push	esi
	call	_set_next_edge
	add	esp, 8
$LN29@dissolve_e:

; 2294 :       if ( valid_id(pprev) )

	mov	eax, ebx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv1509[ebp], eax
	je	SHORT $LN28@dissolve_e

; 2295 :         set_prev_edge(pprev,prev);

	push	esi
	push	ebx
	call	_set_prev_edge
	add	esp, 8
$LN28@dissolve_e:

; 2296 :       next = get_next_edge(fe);

	mov	ecx, DWORD PTR _fe$[ebp]
	push	ecx
	call	_get_next_edge

; 2297 :       nnext = inverse_id(get_next_edge(ffe));

	mov	edx, DWORD PTR _ffe$90926[ebp]
	mov	edi, eax
	push	edx
	mov	DWORD PTR _next$90930[ebp], edi
	call	_get_next_edge
	mov	esi, eax

; 2298 :       if ( valid_id(next) )

	shr	edi, 28					; 0000001cH
	add	esp, 8
	xor	esi, 134217728				; 08000000H
	and	edi, 1
	je	SHORT $LN27@dissolve_e

; 2299 :         set_prev_edge(next,nnext);

	mov	eax, DWORD PTR _next$90930[ebp]
	push	esi
	push	eax
	call	_set_prev_edge
	add	esp, 8
$LN27@dissolve_e:

; 2300 :       if ( valid_id(nnext) )

	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv1516[ebp], eax
	je	SHORT $LN26@dissolve_e

; 2301 :         set_next_edge(nnext,next);

	mov	ecx, DWORD PTR _next$90930[ebp]
	push	ecx
	push	esi
	call	_set_next_edge
	add	esp, 8
$LN26@dissolve_e:

; 2302 : 
; 2303 :       if ( !equal_id(f_id,ff_id) )
; 2304 :       { set_facet_fe(ff_id,NULLID); // so freeing doesn't do other things

	mov	edx, DWORD PTR _ff_id$90928[ebp]
	push	0
	push	edx
	call	_set_facet_fe

; 2305 :         free_element(ff_id);

	mov	eax, DWORD PTR _ff_id$90928[ebp]
	push	eax
	call	_free_element

; 2306 :       }
; 2307 :     
; 2308 :       start_fe = get_facet_fe(f_id);

	mov	ecx, DWORD PTR _f_id$[ebp]
	push	ecx
	call	_get_facet_fe
	add	esp, 16					; 00000010H

; 2309 :       if ( !valid_id(start_fe) || equal_id(fe,start_fe) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN23@dissolve_e
	cmp	DWORD PTR _fe$[ebp], eax
	jne	SHORT $LN15@dissolve_e
$LN23@dissolve_e:

; 2310 :       { if ( valid_id(next) )

	test	edi, edi
	je	SHORT $LN22@dissolve_e

; 2311 :           set_facet_fe(f_id,next);  // make sure facet has valid fe

	mov	edx, DWORD PTR _next$90930[ebp]
	mov	eax, DWORD PTR _f_id$[ebp]
	push	edx
	push	eax
	jmp	SHORT $LN218@dissolve_e
$LN22@dissolve_e:

; 2312 :         else if ( valid_id(prev) )

	cmp	DWORD PTR tv1506[ebp], 0
	je	SHORT $LN20@dissolve_e

; 2313 :           set_facet_fe(f_id,prev);

	mov	ecx, DWORD PTR _prev$90931[ebp]
	push	ecx
	jmp	SHORT $LN219@dissolve_e
$LN20@dissolve_e:

; 2314 :         else if (valid_id(nnext) )

	cmp	DWORD PTR tv1516[ebp], 0
	je	SHORT $LN18@dissolve_e

; 2315 :           set_facet_fe(f_id,nnext);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	esi
	push	eax
	jmp	SHORT $LN218@dissolve_e
$LN18@dissolve_e:

; 2316 :         else if ( valid_id(pprev) )

	cmp	DWORD PTR tv1509[ebp], 0
	je	SHORT $LN16@dissolve_e

; 2317 :           set_facet_fe(f_id,pprev);

	mov	ecx, DWORD PTR _f_id$[ebp]
	push	ebx
	push	ecx

; 2318 :         else 

	jmp	SHORT $LN218@dissolve_e
$LN16@dissolve_e:

; 2319 :           set_facet_fe(f_id,NULLID);

	push	0
$LN219@dissolve_e:
	mov	edx, DWORD PTR _f_id$[ebp]
	push	edx
$LN218@dissolve_e:
	call	_set_facet_fe
	add	esp, 8
$LN15@dissolve_e:

; 2320 :       }
; 2321 : 
; 2322 :       // make sure facet fe is first in loop
; 2323 :       f_id = positive_id(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	and	eax, -134217729				; f7ffffffH

; 2324 :       fffe = start_fe = get_facet_fe(f_id);

	push	eax
	mov	DWORD PTR _f_id$[ebp], eax
	call	_get_facet_fe
	mov	esi, DWORD PTR _web+460
	add	esp, 4
	mov	edx, eax
	npad	2
$LL14@dissolve_e:

; 2325 :       do
; 2326 :       { facetedge_id prev_fe = get_prev_edge(fffe);

	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN165@dissolve_e
	mov	ecx, DWORD PTR [ecx+32]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN164@dissolve_e
$LN165@dissolve_e:
	mov	ecx, DWORD PTR [ecx+28]
$LN164@dissolve_e:

; 2327 :         if ( !valid_id(prev_fe) )

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN195@dissolve_e

; 2329 :           break;
; 2330 :         }
; 2331 :         fffe = prev_fe;

	mov	edx, ecx

; 2332 :       } while ( !equal_id(fffe,start_fe));

	cmp	ecx, eax
	jne	SHORT $LL14@dissolve_e
	jmp	SHORT $LN12@dissolve_e
$LN195@dissolve_e:

; 2328 :         { set_facet_fe(f_id,fffe);

	push	edx
	mov	edx, DWORD PTR _f_id$[ebp]
	push	edx
	call	_set_facet_fe
	add	esp, 8
$LN12@dissolve_e:

; 2333 : 
; 2334 :     } // end different facets
; 2335 :     free_element(fe);

	mov	eax, DWORD PTR _fe$[ebp]
	push	eax
	call	_free_element

; 2336 :     free_element(ffe);

	mov	ecx, DWORD PTR _ffe$90926[ebp]
	push	ecx
	call	_free_element
	add	esp, 8

; 2337 :   }
; 2338 :   else

	jmp	$LN196@dissolve_e
$LN50@dissolve_e:

; 2339 :   for ( fe_id = fe ; ; )

	mov	ebx, DWORD PTR _fe$[ebp]
	npad	5
$LL9@dissolve_e:

; 2340 :   { facetedge_id  prev,next;
; 2341 :     prev = get_prev_edge(fe_id);

	mov	ecx, ebx
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR tv1368[ebp], ecx
	mov	edi, ebx
	je	SHORT $LN169@dissolve_e
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN168@dissolve_e
$LN169@dissolve_e:
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [eax+28]
$LN168@dissolve_e:

; 2342 :     if ( valid_id(prev) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN202@dissolve_e

; 2343 :     { if ( valid_id(f_id) ) set_next_edge(prev,NULLID);

	test	DWORD PTR _f_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN6@dissolve_e
	test	eax, 134217728				; 08000000H
	je	SHORT $LN173@dissolve_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+28], 134217728		; 08000000H
	jmp	SHORT $LN220@dissolve_e
$LN173@dissolve_e:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [eax+32], 0
	jmp	SHORT $LN220@dissolve_e
$LN6@dissolve_e:

; 2344 :       else set_next_edge(prev,inverse_id(prev));

	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	push	ecx
	push	eax
	call	_set_next_edge
	mov	ecx, DWORD PTR tv1368[ebp]
	add	esp, 8
$LN220@dissolve_e:
	mov	esi, DWORD PTR _web+460
$LN202@dissolve_e:

; 2345 :     }
; 2346 :     next = get_next_edge(fe_id);

	test	ecx, ecx
	je	SHORT $LN178@dissolve_e
	mov	edx, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN177@dissolve_e
$LN178@dissolve_e:
	mov	eax, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [eax+32]
$LN177@dissolve_e:

; 2347 :     if ( valid_id(next) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN2@dissolve_e

; 2348 :     { if ( valid_id(f_id) ) set_prev_edge(next,NULLID);

	test	DWORD PTR _f_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN3@dissolve_e
	push	0
	jmp	SHORT $LN221@dissolve_e
$LN3@dissolve_e:

; 2349 :       else set_prev_edge(next,inverse_id(next));

	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	push	ecx
$LN221@dissolve_e:
	push	eax
	call	_set_prev_edge
	add	esp, 8
$LN2@dissolve_e:

; 2350 :     }
; 2351 : 
; 2352 :     free_element(fe_id);

	push	ebx
	call	_free_element

; 2353 :     fe_id = get_next_facet(fe_id);

	mov	esi, DWORD PTR _web+460
	add	esp, 4
	cmp	DWORD PTR tv1368[ebp], 0
	je	SHORT $LN182@dissolve_e
	mov	edx, DWORD PTR [edi+esi]
	mov	ebx, DWORD PTR [edx+36]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN181@dissolve_e
$LN182@dissolve_e:
	mov	eax, DWORD PTR [edi+esi]
	mov	ebx, DWORD PTR [eax+40]
$LN181@dissolve_e:

; 2354 :     if ( equal_id(fe_id,fe) ) break;

	cmp	ebx, DWORD PTR _fe$[ebp]
	jne	$LL9@dissolve_e
$LN196@dissolve_e:

; 2355 :   }
; 2356 : 
; 2357 :   free_element(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ecx
	call	_free_element

; 2358 :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	esp, 4
	inc	eax
	pop	ebx
	pop	edi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 2359 :   return 1;

	mov	eax, 1
	pop	esi

; 2360 : } // end dissolve_edge()

	mov	esp, ebp
	pop	ebp
	ret	0
_dissolve_edge ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@OIKLMOJ@Dissolving?5facet?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0DH@PJNNNPN@Not?5dissolving?5facet?5?$CFs?5since?5on@ ; `string'
PUBLIC	_dissolve_facet
;	COMDAT ??_C@_0BF@OIKLMOJ@Dissolving?5facet?5?$CFs?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BF@OIKLMOJ@Dissolving?5facet?5?$CFs?6?$AA@ DB 'Dissolving facet %s'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PJNNNPN@Not?5dissolving?5facet?5?$CFs?5since?5on@
CONST	SEGMENT
??_C@_0DH@PJNNNPN@Not?5dissolving?5facet?5?$CFs?5since?5on@ DB 'Not disso'
	DB	'lving facet %s since on two different bodies', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _dissolve_facet
_TEXT	SEGMENT
tv513 = -16						; size = 4
_fe_id$ = -12						; size = 4
_next_fe$91035 = -8					; size = 4
_fe$ = -4						; size = 4
_f_id$ = 8						; size = 4
_dissolve_facet PROC					; COMDAT

; 2372 : { facetedge_id fe,fe_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	edi

; 2373 :   edge_id e_id;
; 2374 :   body_id b1,b2;
; 2375 : 
; 2376 :   if ( !valid_element(f_id) ) return 0;

	mov	edi, DWORD PTR _f_id$[ebp]
	push	edi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@dissolve_f
	pop	edi

; 2436 : } // end dissolve_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@dissolve_f:
	push	ebx
	push	esi

; 2377 : 
; 2378 :   b1 = get_facet_body(f_id);

	push	edi
	call	_get_facet_body

; 2379 :   b2 = get_facet_body(inverse_id(f_id));

	mov	ebx, edi
	xor	ebx, 134217728				; 08000000H
	push	ebx
	mov	esi, eax
	mov	DWORD PTR tv513[ebp], ebx
	call	_get_facet_body
	add	esp, 8

; 2380 : 
; 2381 :   if ( !equal_id(b1,b2) && valid_id(b1) && valid_id(b2) )

	cmp	esi, eax
	je	SHORT $LN59@dissolve_f
	test	esi, 268435456				; 10000000H
	je	SHORT $LN59@dissolve_f
	test	eax, 268435456				; 10000000H
	je	SHORT $LN59@dissolve_f

; 2382 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN14@dissolve_f

; 2383 :     { sprintf(msg,"Not dissolving facet %s since on two different bodies\n",ELNAME(f_id));

	test	edi, 268435456				; 10000000H
	je	SHORT $LN19@dissolve_f
	and	edi, 134217727				; 07ffffffH
	inc	edi
	push	edi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN20@dissolve_f
$LN19@dissolve_f:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN20@dissolve_f:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0DH@PJNNNPN@Not?5dissolving?5facet?5?$CFs?5since?5on@
	push	eax
	call	_sprintf

; 2384 :       outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
$LN14@dissolve_f:

; 2385 :     }
; 2386 :     return 0;

	pop	esi
	pop	ebx
	xor	eax, eax
	pop	edi

; 2436 : } // end dissolve_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@dissolve_f:

; 2387 :   }
; 2388 : 
; 2389 :   if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN60@dissolve_f

; 2390 :   { sprintf(msg,"Dissolving facet %s\n",ELNAME(f_id));

	test	edi, 268435456				; 10000000H
	je	SHORT $LN21@dissolve_f
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN22@dissolve_f
$LN21@dissolve_f:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN22@dissolve_f:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BF@OIKLMOJ@Dissolving?5facet?5?$CFs?6?$AA@
	push	eax
	call	_sprintf

; 2391 :     outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
$LN60@dissolve_f:

; 2392 :   }
; 2393 : 
; 2394 :   if ( web.representation != SIMPLEX )

	mov	esi, 3
	cmp	DWORD PTR _web+624, esi
	je	$LN56@dissolve_f

; 2395 :   { /* Identify the edges, but not the facets yet.
; 2396 :        delete_facet() will take care of the second 
; 2397 :        facet and patch up its facetedges. */
; 2398 :     fe = get_facet_fe(f_id);

	test	edi, 268435456				; 10000000H
	jne	SHORT $LN24@dissolve_f
	mov	DWORD PTR _fe$[ebp], 0
	jmp	SHORT $LN25@dissolve_f
$LN24@dissolve_f:
	mov	eax, DWORD PTR _web+236
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN23@dissolve_f
	xor	eax, 134217728				; 08000000H
$LN23@dissolve_f:
	mov	DWORD PTR _fe$[ebp], eax
$LN25@dissolve_f:

; 2399 :     for ( fe_id = fe ; ; )

	mov	ebx, DWORD PTR _fe$[ebp]
	mov	DWORD PTR _fe_id$[ebp], ebx
$LL11@dissolve_f:

; 2400 :     { facetedge_id prev,next,next_fe;
; 2401 :       prev = get_prev_facet(fe_id);

	mov	ecx, DWORD PTR _web+460
	mov	edx, ebx
	mov	eax, ebx
	shr	edx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	and	edx, 1
	mov	eax, DWORD PTR [ecx+eax*4]
	je	SHORT $LN28@dissolve_f
	mov	ecx, DWORD PTR [eax+40]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN27@dissolve_f
$LN28@dissolve_f:
	mov	ecx, DWORD PTR [eax+36]
$LN27@dissolve_f:

; 2402 :       next = get_next_facet(fe_id);

	test	edx, edx
	je	SHORT $LN32@dissolve_f
	mov	edi, DWORD PTR [eax+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN31@dissolve_f
$LN32@dissolve_f:
	mov	edi, DWORD PTR [eax+40]
$LN31@dissolve_f:

; 2403 :       e_id = get_fe_edge(fe_id);

	mov	esi, ebx
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [eax+20]

; 2404 :       next_fe = get_next_edge(fe_id);

	test	edx, edx
	je	SHORT $LN38@dissolve_f
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _next_fe$91035[ebp], eax
	jmp	SHORT $LN37@dissolve_f
$LN38@dissolve_f:
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR _next_fe$91035[ebp], edx
$LN37@dissolve_f:

; 2405 :       if ( !equal_id(prev,fe_id) )

	cmp	ecx, ebx
	je	SHORT $LN9@dissolve_f

; 2406 :       { set_next_facet(prev,next);

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN41@dissolve_f
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN42@dissolve_f
	mov	ebx, DWORD PTR _web+460
	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _fe_id$[ebp]
	mov	DWORD PTR [edx+36], eax
	jmp	SHORT $LN41@dissolve_f
$LN42@dissolve_f:
	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+40], edi
$LN41@dissolve_f:

; 2407 :         set_prev_facet(next,prev);

	push	ecx
	push	edi
	call	_set_prev_facet
	add	esp, 8

; 2408 :         set_edge_fe(e_id,next);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN46@dissolve_f
	xor	edi, 134217728				; 08000000H
$LN46@dissolve_f:
	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [edx+28], edi

; 2409 :         free_element(fe_id);
; 2410 :       }
; 2411 :       else

	jmp	SHORT $LN66@dissolve_f
$LN9@dissolve_f:

; 2412 :       {
; 2413 :         set_attr(e_id,BARE_NAKED);

	mov	ecx, esi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 65536		; 00010000H
	mov	DWORD PTR [ecx+12], edx

; 2414 :         set_edge_fe(e_id,NULLID);

	xor	ecx, ecx
	test	esi, 134217728				; 08000000H
	je	SHORT $LN51@dissolve_f
	mov	ecx, 134217728				; 08000000H
$LN51@dissolve_f:
	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+edx]
	mov	DWORD PTR [eax+28], ecx
$LN66@dissolve_f:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax

; 2415 :         free_element(fe_id);

	push	ebx
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	call	_free_element

; 2416 :       }
; 2417 :       fe_id = next_fe;

	mov	ebx, DWORD PTR _next_fe$91035[ebp]
	add	esp, 4
	mov	DWORD PTR _fe_id$[ebp], ebx

; 2418 :       if ( !valid_id(fe_id) ) break;  /* open facet in string model */

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN62@dissolve_f

; 2419 :       if ( equal_id(fe_id,fe) ) break;

	cmp	ebx, DWORD PTR _fe$[ebp]

; 2420 :     }

	jne	$LL11@dissolve_f
$LN62@dissolve_f:
	mov	ebx, DWORD PTR tv513[ebp]
	mov	edi, DWORD PTR _f_id$[ebp]
	mov	esi, 3
$LN56@dissolve_f:

; 2421 :   }
; 2422 : 
; 2423 :   set_facet_body(f_id,NULLID);

	push	0
	push	edi
	call	_set_facet_body

; 2424 :   set_facet_body(inverse_id(f_id),NULLID);

	push	0
	push	ebx
	call	_set_facet_body
	add	esp, 16					; 00000010H

; 2425 : 
; 2426 :   if ( (web.modeltype == LAGRANGE) && (web.lagrange_order >= 3) )

	cmp	DWORD PTR _web+628, esi
	jne	SHORT $LN63@dissolve_f
	cmp	DWORD PTR _web+632, esi
	jl	SHORT $LN63@dissolve_f

; 2427 :   { vertex_id *v = get_facet_vertices(f_id);

	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR _web+328
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	ebx, DWORD PTR [eax+ecx+304]

; 2428 :     int i;
; 2429 :     for ( i = 0 ; i < web.skel[FACET].ctrlpts ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _web+232, esi
	jle	SHORT $LN63@dissolve_f
	npad	1
$LL4@dissolve_f:

; 2430 :       if ( get_vattr(v[i]) & Q_MIDFACET )

	mov	ecx, DWORD PTR [ebx+esi*4]
	mov	eax, DWORD PTR _web+12
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2097152				; 00200000H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN3@dissolve_f

; 2431 :         free_element(v[i]);

	push	ecx
	call	_free_element
	add	esp, 4
$LN3@dissolve_f:

; 2428 :     int i;
; 2429 :     for ( i = 0 ; i < web.skel[FACET].ctrlpts ; i++ )

	inc	esi
	cmp	esi, DWORD PTR _web+232
	jl	SHORT $LL4@dissolve_f
$LN63@dissolve_f:

; 2432 :   }
; 2433 :   free_element(f_id);

	push	edi
	call	_free_element

; 2434 :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	esp, 4
	inc	eax
	pop	esi
	pop	ebx
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 2435 :   return 1;

	mov	eax, 1
	pop	edi

; 2436 : } // end dissolve_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
_dissolve_facet ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@CELFIEMC@Dissolving?5body?5?$CFs?6?$AA@ ; `string'
PUBLIC	_dissolve_body
EXTRN	_free_method_instance:PROC
EXTRN	_free_quantity:PROC
EXTRN	_gen_quant_list:DWORD
EXTRN	_meth_inst_list:DWORD
EXTRN	_NULLBODY:DWORD
;	COMDAT ??_C@_0BE@CELFIEMC@Dissolving?5body?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BE@CELFIEMC@Dissolving?5body?5?$CFs?6?$AA@ DB 'Dissolving body %s', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _dissolve_body
_TEXT	SEGMENT
_mi$91080 = -16						; size = 4
tv196 = -12						; size = 4
_k$ = -8						; size = 4
tv417 = -4						; size = 4
_b_id$ = 8						; size = 4
_dissolve_body PROC					; COMDAT

; 2448 : { facet_id f_id,ff_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx

; 2449 :   int i,j,k;
; 2450 :    
; 2451 :   if ( !valid_element(b_id) ) return 0;

	mov	ebx, DWORD PTR _b_id$[ebp]
	push	ebx
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN21@dissolve_b
	pop	ebx

; 2488 : } // end dissolve_body()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@dissolve_b:

; 2452 : 
; 2453 :   if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN34@dissolve_b

; 2454 :   { sprintf(msg,"Dissolving body %s\n",ELNAME(b_id));

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN24@dissolve_b
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN25@dissolve_b
$LN24@dissolve_b:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN25@dissolve_b:
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BE@CELFIEMC@Dissolving?5body?5?$CFs?6?$AA@
	push	ecx
	call	_sprintf

; 2455 :      outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN34@dissolve_b:

; 2456 :   }
; 2457 : 
; 2458 :   FOR_ALL_FACETS(f_id)

	push	esi
	push	edi
	mov	edi, DWORD PTR _web+272
	test	edi, 268435456				; 10000000H
	je	SHORT $LN17@dissolve_b
	npad	11
$LL19@dissolve_b:
	mov	eax, DWORD PTR _web+236
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN18@dissolve_b

; 2459 :   { if ( equal_id(b_id,get_facet_body(f_id)) ) 

	push	edi
	call	_get_facet_body
	add	esp, 4
	cmp	ebx, eax
	jne	SHORT $LN14@dissolve_b

; 2460 :        set_facet_body(f_id,NULLBODY);

	mov	ecx, DWORD PTR _NULLBODY
	push	ecx
	push	edi
	call	_set_facet_body
	add	esp, 8
$LN14@dissolve_b:

; 2461 :     ff_id = inverse_id(f_id);

	xor	edi, 134217728				; 08000000H

; 2462 :     if ( equal_id(b_id,get_facet_body(ff_id)) ) 

	push	edi
	call	_get_facet_body
	add	esp, 4
	cmp	ebx, eax
	jne	SHORT $LN18@dissolve_b

; 2463 :        set_facet_body(ff_id,NULLBODY);

	mov	edx, DWORD PTR _NULLBODY
	push	edx
	push	edi
	call	_set_facet_body
	add	esp, 8
$LN18@dissolve_b:

; 2456 :   }
; 2457 : 
; 2458 :   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [ecx]
	test	edi, 268435456				; 10000000H
	jne	SHORT $LL19@dissolve_b
$LN17@dissolve_b:

; 2464 :   }
; 2465 : 
; 2466 :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN12@dissolve_b

; 2467 :   { struct method_instance *mi = METH_INSTANCE(get_body_volmeth(b_id));

	mov	eax, DWORD PTR _web+348
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx+412]
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list
	mov	DWORD PTR tv196[ebp], 8
	lea	edx, DWORD PTR [esi+152]
	mov	DWORD PTR _mi$91080[ebp], esi
	mov	DWORD PTR tv417[ebp], edx
	npad	5
$LL11@dissolve_b:

; 2471 :     { if ( mi->quants[j] < 0 )

	mov	eax, DWORD PTR tv417[ebp]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	js	SHORT $LN10@dissolve_b

; 2472 :          continue;
; 2473 :       q = GEN_QUANT(mi->quants[j]);

	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list

; 2474 :       free_quantity(q);

	push	eax
	call	_free_quantity

; 2475 :     
; 2476 :       for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	eax, 1
	add	esp, 4
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR _web+5560, eax
	jle	SHORT $LN10@dissolve_b
	npad	2
$LL35@dissolve_b:

; 2477 :       { struct method_instance *mm = METH_INSTANCE(k);

	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list
	mov	ebx, 8
	lea	edi, DWORD PTR [esi+152]
	npad	2
$LL4@dissolve_b:

; 2479 :           if ( mm->quants[i] == mi->quants[j] )

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR tv417[ebp]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN3@dissolve_b

; 2480 :             free_method_instance(mm);

	push	esi
	call	_free_method_instance
	add	esp, 4
$LN3@dissolve_b:

; 2478 :         for ( i = 0 ; i < MMAXQUANTS ; i++ )

	add	edi, 4
	dec	ebx
	jne	SHORT $LL4@dissolve_b

; 2475 :     
; 2476 :       for ( k = LOW_INST  ; k < meth_inst_count  ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _web+5560
	jl	SHORT $LL35@dissolve_b
	mov	ebx, DWORD PTR _b_id$[ebp]
	mov	esi, DWORD PTR _mi$91080[ebp]
$LN10@dissolve_b:

; 2468 :     struct gen_quant *q;
; 2469 : 
; 2470 :     for ( j = 0 ; j < MMAXQUANTS ; j++ )

	add	DWORD PTR tv417[ebp], 4
	dec	DWORD PTR tv196[ebp]
	jne	$LL11@dissolve_b

; 2481 :       }
; 2482 :     }
; 2483 :     free_method_instance(mi);

	push	esi
	call	_free_method_instance
	add	esp, 4
$LN12@dissolve_b:

; 2484 :   }
; 2485 :   free_element(b_id);

	push	ebx
	call	_free_element

; 2486 :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	add	esp, 4
	inc	eax
	pop	edi
	pop	esi
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 2487 :   return 1;

	mov	eax, 1
	pop	ebx

; 2488 : } // end dissolve_body()

	mov	esp, ebp
	pop	ebp
	ret	0
_dissolve_body ENDP
_TEXT	ENDS
PUBLIC	_divide_quad
; Function compile flags: /Ogtp
;	COMDAT _divide_quad
_TEXT	SEGMENT
tv1062 = -52						; size = 4
tv921 = -52						; size = 4
tv967 = -48						; size = 4
tv943 = -44						; size = 4
tv936 = -40						; size = 4
tv876 = -36						; size = 4
_new_f$ = -32						; size = 4
tv984 = -28						; size = 4
_old_conmap$ = -28					; size = 4
tv988 = -24						; size = 4
$T94126 = -24						; size = 4
tv924 = -20						; size = 4
_feb$ = -16						; size = 4
tv868 = -12						; size = 4
_fea$ = -8						; size = 4
tv996 = -4						; size = 4
_old_f$ = -4						; size = 4
tv1043 = 8						; size = 4
_wrap$91115 = 8						; size = 4
_fe$ = 8						; size = 4
_divide_quad PROC					; COMDAT

; 2499 : { facetedge_id fea,feb,fec,new_fe,new_fe2;

	push	ebp
	mov	ebp, esp

; 2500 :   facet_id old_f,new_f;
; 2501 :   edge_id new_e;
; 2502 :   conmap_t *old_conmap;
; 2503 : 
; 2504 :   old_f = get_fe_facet(fe);

	mov	ecx, DWORD PTR _web+460
	sub	esp, 52					; 00000034H
	push	ebx
	mov	ebx, DWORD PTR _fe$[ebp]
	push	esi
	push	edi
	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN8@divide_qua
	mov	edx, DWORD PTR _NULLFACET
	mov	DWORD PTR _old_f$[ebp], edx
	jmp	SHORT $LN9@divide_qua
$LN8@divide_qua:
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+24]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN7@divide_qua
	xor	eax, 134217728				; 08000000H
$LN7@divide_qua:
	mov	DWORD PTR _old_f$[ebp], eax
	mov	edx, eax
$LN9@divide_qua:

; 2505 :   old_conmap = get_f_constraint_map(old_f);

	mov	esi, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	cmp	DWORD PTR [esi+eax+88], 0
	je	SHORT $LN5@divide_qua
	mov	edi, DWORD PTR _web+236
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _dymem
	add	eax, DWORD PTR [esi+edi+64]
	mov	DWORD PTR _old_conmap$[ebp], eax
	jmp	SHORT $LN6@divide_qua
$LN5@divide_qua:
	mov	DWORD PTR _old_conmap$[ebp], OFFSET _nullcon
$LN6@divide_qua:

; 2506 :   if ( inverted(old_f) )

	test	edx, 134217728				; 08000000H
	je	SHORT $LN2@divide_qua

; 2507 :   { fe = inverse_id(fe);

	xor	ebx, 134217728				; 08000000H

; 2508 :     old_f = inverse_id(old_f);

	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR _fe$[ebp], ebx
	mov	DWORD PTR _old_f$[ebp], edx
$LN2@divide_qua:

; 2509 :   }
; 2510 :   fea = get_next_edge(fe);

	mov	eax, ebx
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv876[ebp], eax
	je	SHORT $LN12@divide_qua
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR tv868[ebp], edi
	mov	DWORD PTR _fea$[ebp], eax
	jmp	SHORT $LN11@divide_qua
$LN12@divide_qua:
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv868[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [eax+32]
	mov	edi, DWORD PTR tv868[ebp]
	mov	DWORD PTR _fea$[ebp], edx
	mov	eax, edx
$LN11@divide_qua:

; 2511 :   feb = get_next_edge(fea);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN16@divide_qua
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _feb$[ebp], eax
	jmp	SHORT $LN15@divide_qua
$LN16@divide_qua:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _feb$[ebp], eax
$LN15@divide_qua:

; 2512 :   fec = get_next_edge(feb);

	mov	edx, eax
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	DWORD PTR tv921[ebp], edx
	je	SHORT $LN20@divide_qua
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	mov	esi, DWORD PTR [ecx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN87@divide_qua
$LN20@divide_qua:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	mov	esi, DWORD PTR [edx+32]
$LN87@divide_qua:
	mov	DWORD PTR tv924[ebp], eax

; 2513 : 
; 2514 :   new_f = dup_facet(old_f);

	mov	eax, DWORD PTR _old_f$[ebp]
	push	eax
	call	_dup_facet

; 2515 :   new_e = new_edge(get_fe_headv(fe),get_fe_tailv(fec),old_f);

	mov	edx, DWORD PTR _web+460
	mov	DWORD PTR _new_f$[ebp], eax
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv936[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _web+216
	mov	ecx, esi
	and	ecx, 134217728				; 08000000H
	xor	eax, ecx
	mov	DWORD PTR tv943[ebp], ecx
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx+304]
	mov	edx, DWORD PTR _web+124
	add	esp, 4
	test	eax, 134217728				; 08000000H
	je	SHORT $LN26@divide_qua
	mov	ebx, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
	mov	ebx, DWORD PTR _fe$[ebp]
	jmp	SHORT $LN88@divide_qua
$LN26@divide_qua:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN88@divide_qua:
	mov	DWORD PTR $T94126[ebp], eax
	mov	eax, DWORD PTR _web+460
	mov	eax, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [eax+20]
	and	ebx, 134217728				; 08000000H
	xor	eax, ebx
	mov	DWORD PTR tv967[ebp], ebx
	test	eax, 134217728				; 08000000H
	je	SHORT $LN32@divide_qua
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [ecx+edx]
	jmp	SHORT $LN31@divide_qua
$LN32@divide_qua:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR [eax+ecx]
$LN31@divide_qua:
	mov	edi, DWORD PTR _old_f$[ebp]
	mov	edx, DWORD PTR $T94126[ebp]
	push	edi
	push	edx
	push	ecx
	call	_new_edge
	mov	ebx, eax

; 2516 :   set_e_conmap(new_e,old_conmap);

	mov	eax, DWORD PTR _old_conmap$[ebp]
	push	eax
	push	ebx
	call	_set_e_conmap

; 2517 :   new_fe = new_facetedge(old_f,new_e);

	push	ebx
	push	edi
	call	_new_facetedge
	mov	edi, eax

; 2518 :   set_edge_fe(new_e,new_fe);

	mov	eax, ebx
	shr	eax, 27					; 0000001bH
	add	esp, 28					; 0000001cH
	and	eax, 1
	mov	ecx, edi
	mov	DWORD PTR tv984[ebp], eax
	je	SHORT $LN35@divide_qua
	xor	ecx, 134217728				; 08000000H
$LN35@divide_qua:
	mov	edx, DWORD PTR _web+124
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv988[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	mov	DWORD PTR [eax+28], ecx
	mov	eax, DWORD PTR _global_timestamp

; 2519 :   set_facet_fe(old_f,new_fe);

	mov	ecx, DWORD PTR _old_f$[ebp]
	inc	eax
	push	edi
	push	ecx
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	call	_set_facet_fe

; 2520 :   set_next_edge(new_fe,fec);

	mov	eax, edi
	shr	eax, 28					; 0000001cH
	add	esp, 8
	and	eax, 1
	mov	DWORD PTR tv996[ebp], eax
	je	SHORT $LN38@divide_qua
	test	edi, 134217728				; 08000000H
	je	SHORT $LN39@divide_qua
	mov	ecx, DWORD PTR _web+460
	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [eax+28], edx
	jmp	SHORT $LN38@divide_qua
$LN39@divide_qua:
	mov	edx, DWORD PTR _web+460
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+32], esi
$LN38@divide_qua:

; 2521 :   set_prev_edge(fec,new_fe);

	push	edi
	push	esi
	call	_set_prev_edge

; 2522 :   set_next_edge(fe,new_fe);

	mov	ecx, DWORD PTR _fe$[ebp]
	add	esp, 8
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN84@divide_qua
	cmp	DWORD PTR tv876[ebp], 0
	je	SHORT $LN44@divide_qua
	mov	edx, DWORD PTR _web+460
	mov	esi, DWORD PTR tv868[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR [edx+28], eax
	jmp	SHORT $LN84@divide_qua
$LN44@divide_qua:
	mov	eax, DWORD PTR _web+460
	mov	edx, DWORD PTR tv868[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR [eax+32], edi
$LN84@divide_qua:

; 2523 :   set_prev_edge(new_fe,fe);

	push	ecx
	push	edi
	call	_set_prev_edge
	add	esp, 8

; 2524 :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	$LN60@divide_qua

; 2525 :   { WRAPTYPE wrap = get_fe_wrap(fec);

	mov	ecx, DWORD PTR tv936[ebp]
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax+20]
	xor	eax, DWORD PTR tv943[ebp]
	mov	edx, DWORD PTR _web+124
	mov	esi, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+esi+784]
	mov	ecx, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN52@divide_qua
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	mov	DWORD PTR _wrap$91115[ebp], eax
	jmp	SHORT $LN53@divide_qua
$LN52@divide_qua:
	mov	DWORD PTR _wrap$91115[ebp], ecx
$LN53@divide_qua:

; 2526 :     wrap = (*sym_compose)(wrap,get_fe_wrap(fe));

	mov	eax, DWORD PTR tv868[ebp]
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+20]
	xor	eax, DWORD PTR tv967[ebp]
	mov	edx, DWORD PTR _web+124
	mov	esi, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+esi+784]
	mov	ecx, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN58@divide_qua
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN59@divide_qua
$LN58@divide_qua:
	mov	eax, ecx
$LN59@divide_qua:
	push	eax
	mov	eax, DWORD PTR _wrap$91115[ebp]
	push	eax
	call	DWORD PTR _sym_compose

; 2527 :     wrap = (*sym_inverse)(wrap);

	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 12					; 0000000cH

; 2528 :     set_edge_wrap(new_e,wrap);

	cmp	DWORD PTR tv984[ebp], 0
	je	SHORT $LN62@divide_qua
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN62@divide_qua:
	mov	edx, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx+784]
	mov	edx, DWORD PTR _web+124
	mov	esi, DWORD PTR tv988[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+edx], eax
$LN60@divide_qua:

; 2529 :   }
; 2530 :   new_fe2 = new_facetedge(new_f,inverse_id(new_e));

	xor	ebx, 134217728				; 08000000H
	push	ebx
	mov	ebx, DWORD PTR _new_f$[ebp]
	push	ebx
	call	_new_facetedge
	mov	esi, eax

; 2531 :   set_facet_fe(new_f,new_fe2);

	push	esi
	push	ebx
	call	_set_facet_fe

; 2532 :   set_next_edge(new_fe2,fea);

	mov	eax, esi
	shr	eax, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	eax, 1
	mov	DWORD PTR tv1043[ebp], eax
	je	SHORT $LN85@divide_qua
	test	esi, 134217728				; 08000000H
	je	SHORT $LN65@divide_qua
	mov	eax, DWORD PTR _fea$[ebp]
	mov	edx, DWORD PTR _web+460
	xor	eax, 134217728				; 08000000H
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN85@divide_qua
$LN65@divide_qua:
	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _fea$[ebp]
	mov	DWORD PTR [ecx+32], edx
$LN85@divide_qua:

; 2533 :   set_prev_edge(fea,new_fe2);

	mov	eax, DWORD PTR _fea$[ebp]
	push	esi
	push	eax
	call	_set_prev_edge

; 2534 :   set_next_edge(feb,new_fe2);

	mov	ecx, DWORD PTR _feb$[ebp]
	add	esp, 8
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN86@divide_qua
	cmp	DWORD PTR tv921[ebp], 0
	je	SHORT $LN70@divide_qua
	mov	edx, DWORD PTR _web+460
	mov	ebx, DWORD PTR tv924[ebp]
	mov	edx, DWORD PTR [ebx+edx]
	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR [edx+28], eax
	jmp	SHORT $LN86@divide_qua
$LN70@divide_qua:
	mov	eax, DWORD PTR _web+460
	mov	edx, DWORD PTR tv924[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR [eax+32], esi
$LN86@divide_qua:

; 2535 :   set_prev_edge(new_fe2,feb);

	push	ecx
	push	esi
	call	_set_prev_edge

; 2536 :   set_next_facet(new_fe,inverse_id(new_fe2));

	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	add	esp, 8
	cmp	DWORD PTR tv996[ebp], 0
	mov	DWORD PTR tv1062[ebp], eax
	je	SHORT $LN74@divide_qua
	test	edi, 134217728				; 08000000H
	je	SHORT $LN75@divide_qua
	mov	ebx, DWORD PTR _web+460
	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [edx+36], ecx
	jmp	SHORT $LN74@divide_qua
$LN75@divide_qua:
	mov	edx, DWORD PTR _web+460
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+40], eax
$LN74@divide_qua:

; 2537 :   set_next_facet(new_fe2,inverse_id(new_fe));

	mov	ebx, edi
	xor	ebx, 134217728				; 08000000H
	cmp	DWORD PTR tv1043[ebp], 0
	je	SHORT $LN79@divide_qua
	test	esi, 134217728				; 08000000H
	je	SHORT $LN80@divide_qua
	mov	ecx, DWORD PTR _web+460
	mov	edx, ebx
	xor	edx, 134217728				; 08000000H
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [eax+36], edx
	mov	eax, DWORD PTR tv1062[ebp]
	jmp	SHORT $LN79@divide_qua
$LN80@divide_qua:
	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+40], ebx
$LN79@divide_qua:

; 2538 :   set_prev_facet(new_fe,inverse_id(new_fe2));

	push	eax
	push	edi
	call	_set_prev_facet

; 2539 :   set_prev_facet(new_fe2,inverse_id(new_fe));

	push	ebx
	push	esi
	call	_set_prev_facet

; 2540 :   set_fe_facet(fea,new_f);

	mov	esi, DWORD PTR _new_f$[ebp]
	mov	edx, DWORD PTR _fea$[ebp]
	push	esi
	push	edx
	call	_set_fe_facet

; 2541 :   set_fe_facet(feb,new_f);

	mov	eax, DWORD PTR _feb$[ebp]
	push	esi
	push	eax
	call	_set_fe_facet
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebx

; 2542 : } // end divide_quad()

	mov	esp, ebp
	pop	ebp
	ret	0
_divide_quad ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@LMDDHND@Edge?5?$CFs?5not?5t1_swapped?5due?5to?5fi@ ; `string'
PUBLIC	??_C@_0DG@KKHIOEIA@Edge?5?$CFs?5not?5t1_swapped?5due?5to?5di@ ; `string'
PUBLIC	??_C@_0DF@GHCFABCF@Edge?5?$CFs?5not?5t1_swapped?5due?5to?5di@ ; `string'
PUBLIC	??_C@_0EA@FBNOLBBK@Edge?5?$CFs?5not?5t1_swapped?5since?5it?5@ ; `string'
PUBLIC	??_C@_0EC@MGCCNDH@Edge?5?$CFs?5not?5t1_swapped?5since?5hea@ ; `string'
PUBLIC	??_C@_0CA@CIMCFIGG@fe_f?5edge?5?$CF08X?5?5fe_g?5edge?5?$CF08X?6?$AA@ ; `string'
PUBLIC	??_C@_0EC@NBNNPMCI@Edge?5?$CFs?5not?5t1_swapped?5since?5tai@ ; `string'
PUBLIC	??_C@_0DO@JFJDLNIO@Edge?5?$CFs?5not?5t1_swapped?5since?5it?5@ ; `string'
PUBLIC	??_C@_0CK@JBMCJKOO@t1_edgeswap?5valid?5only?5for?5STRIN@ ; `string'
PUBLIC	_t1_edgeswap
EXTRN	_wrap_vertex:PROC
EXTRN	_torus_unwrap_edge:PROC
EXTRN	_printf:PROC
EXTRN	_compare_vertex_edge_attr:PROC
;	COMDAT ??_C@_0CK@LMDDHND@Edge?5?$CFs?5not?5t1_swapped?5due?5to?5fi@
CONST	SEGMENT
??_C@_0CK@LMDDHND@Edge?5?$CFs?5not?5t1_swapped?5due?5to?5fi@ DB 'Edge %s '
	DB	'not t1_swapped due to fixedness.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KKHIOEIA@Edge?5?$CFs?5not?5t1_swapped?5due?5to?5di@
CONST	SEGMENT
??_C@_0DG@KKHIOEIA@Edge?5?$CFs?5not?5t1_swapped?5due?5to?5di@ DB 'Edge %s'
	DB	' not t1_swapped due to differing constraints.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GHCFABCF@Edge?5?$CFs?5not?5t1_swapped?5due?5to?5di@
CONST	SEGMENT
??_C@_0DF@GHCFABCF@Edge?5?$CFs?5not?5t1_swapped?5due?5to?5di@ DB 'Edge %s'
	DB	' not t1_swapped due to differing boundaries.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@FBNOLBBK@Edge?5?$CFs?5not?5t1_swapped?5since?5it?5@
CONST	SEGMENT
??_C@_0EA@FBNOLBBK@Edge?5?$CFs?5not?5t1_swapped?5since?5it?5@ DB 'Edge %s'
	DB	' not t1_swapped since it does not have adjacent facets.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@MGCCNDH@Edge?5?$CFs?5not?5t1_swapped?5since?5hea@
CONST	SEGMENT
??_C@_0EC@MGCCNDH@Edge?5?$CFs?5not?5t1_swapped?5since?5hea@ DB 'Edge %s n'
	DB	'ot t1_swapped since head vertex doesn''t have valence 3.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CIMCFIGG@fe_f?5edge?5?$CF08X?5?5fe_g?5edge?5?$CF08X?6?$AA@
CONST	SEGMENT
??_C@_0CA@CIMCFIGG@fe_f?5edge?5?$CF08X?5?5fe_g?5edge?5?$CF08X?6?$AA@ DB 'f'
	DB	'e_f edge %08X  fe_g edge %08X', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@NBNNPMCI@Edge?5?$CFs?5not?5t1_swapped?5since?5tai@
CONST	SEGMENT
??_C@_0EC@NBNNPMCI@Edge?5?$CFs?5not?5t1_swapped?5since?5tai@ DB 'Edge %s '
	DB	'not t1_swapped since tail vertex doesn''t have valence 3.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@JFJDLNIO@Edge?5?$CFs?5not?5t1_swapped?5since?5it?5@
CONST	SEGMENT
??_C@_0DO@JFJDLNIO@Edge?5?$CFs?5not?5t1_swapped?5since?5it?5@ DB 'Edge %s'
	DB	' not t1_swapped since it has only one adjacent facet.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JBMCJKOO@t1_edgeswap?5valid?5only?5for?5STRIN@
CONST	SEGMENT
??_C@_0CK@JBMCJKOO@t1_edgeswap?5valid?5only?5for?5STRIN@ DB 't1_edgeswap '
	DB	'valid only for STRING model.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _t1_edgeswap
_TEXT	SEGMENT
tv822 = -68						; size = 4
_v$91241 = -68						; size = 4
tv1081 = -64						; size = 4
tv812 = -64						; size = 4
tv1128 = -60						; size = 4
tv887 = -60						; size = 4
_f_d$ = -60						; size = 4
_f_c$ = -56						; size = 4
_pos_e$91211 = -52					; size = 4
_fe_d$ = -48						; size = 4
_fe_e$ = -44						; size = 4
_f_b$ = -40						; size = 4
_f_a$ = -36						; size = 4
_headv$ = -32						; size = 4
tv169 = -28						; size = 4
_fe_h$ = -28						; size = 4
_fe_j$ = -24						; size = 4
_fe_i$ = -20						; size = 4
_tx$ = -16						; size = 4
_tailv$ = -16						; size = 4
_fe_f$ = -12						; size = 4
_j$ = -8						; size = 4
_fe_g$ = -8						; size = 4
tv801 = -4						; size = 4
_e_id$ = 8						; size = 4
_t1_edgeswap PROC					; COMDAT

; 2557 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 2558 :   facetedge_id fe_a,fe_b,fe_c,fe_d,fe_e,fe_f,fe_g,fe_gg,fe_h,fe_i,fe_j;
; 2559 :   vertex_id headv,tailv;
; 2560 :   facet_id f_a,f_b,f_c,f_d;
; 2561 :   REAL *hx,*tx,newhx[MAXCOORD],newtx[MAXCOORD];
; 2562 :   int i,j;
; 2563 : 
; 2564 :   if ( web.dimension != STRING )

	cmp	DWORD PTR _web+620, 1
	je	SHORT $LN38@t1_edgeswa

; 2565 :   { kb_error(3665,"t1_edgeswap valid only for STRING model.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CK@JBMCJKOO@t1_edgeswap?5valid?5only?5for?5STRIN@
	push	3665					; 00000e51H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2566 :     return 0;

	xor	eax, eax

; 2731 : } // end t1_edgeswap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@t1_edgeswa:
	push	ebx

; 2567 :   }  
; 2568 :  
; 2569 :   /* check fixedness and boundary */
; 2570 :   headv = get_edge_headv(e_id);

	mov	ebx, DWORD PTR _e_id$[ebp]
	push	esi
	push	edi
	push	ebx
	call	_get_edge_headv
	mov	esi, eax

; 2571 :   tailv = get_edge_tailv(e_id);

	push	ebx
	mov	DWORD PTR _headv$[ebp], esi
	call	_get_edge_tailv
	mov	DWORD PTR _tailv$[ebp], eax

; 2572 :   if ( (get_eattr(e_id) & FIXED) 
; 2573 :     || (get_vattr(headv) & FIXED) 
; 2574 :     || (get_vattr(tailv) & FIXED) )

	mov	eax, DWORD PTR _web+124
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	edx, edx
	add	esp, 8
	or	eax, edx
	mov	DWORD PTR tv801[ebp], ecx
	jne	$LN74@t1_edgeswa
	mov	edx, DWORD PTR _web+12
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	edi, edi
	or	eax, edi
	mov	DWORD PTR tv812[ebp], esi
	jne	$LN74@t1_edgeswa
	mov	edi, DWORD PTR _tailv$[ebp]
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR tv822[ebp], edi
	jne	$LN73@t1_edgeswa

; 2582 :   }
; 2583 :   /* check constraints */
; 2584 :   if ( compare_vertex_edge_attr(headv,e_id) != A_EQ_B  ||
; 2585 :        compare_vertex_edge_attr(tailv,e_id) != A_EQ_B ) 

	mov	ecx, DWORD PTR _headv$[ebp]
	push	ebx
	push	ecx
	call	_compare_vertex_edge_attr
	add	esp, 8
	cmp	eax, 2
	jne	$LN33@t1_edgeswa
	mov	edx, DWORD PTR _tailv$[ebp]
	push	ebx
	push	edx
	call	_compare_vertex_edge_attr
	add	esp, 8
	cmp	eax, 2
	jne	$LN33@t1_edgeswa

; 2593 :   }
; 2594 :   /* check boundaries */
; 2595 :   if ( get_vertex_boundary_num(headv) != get_edge_boundary_num(e_id) ||
; 2596 :        get_vertex_boundary_num(tailv) != get_edge_boundary_num(e_id) ) 

	mov	ecx, DWORD PTR _V_BOUNDARY_ATTR
	mov	edx, DWORD PTR _dymem
	test	ecx, ecx
	je	SHORT $LN45@t1_edgeswa
	mov	ebx, DWORD PTR _web+12
	mov	esi, DWORD PTR [esi+ebx]
	mov	eax, ecx
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [eax+esi]
	mov	DWORD PTR tv169[ebp], eax
	jmp	SHORT $LN46@t1_edgeswa
$LN45@t1_edgeswa:
	mov	DWORD PTR tv169[ebp], 0
$LN46@t1_edgeswa:
	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN47@t1_edgeswa
	mov	ebx, DWORD PTR tv801[ebp]
	mov	esi, eax
	imul	esi, 240				; 000000f0H
	add	esi, DWORD PTR _web+216
	mov	edx, DWORD PTR [esi+edx+64]
	mov	esi, DWORD PTR _web+124
	mov	esi, DWORD PTR [esi+ebx*4]
	mov	esi, DWORD PTR [edx+esi]
	mov	edx, DWORD PTR _dymem
	jmp	SHORT $LN48@t1_edgeswa
$LN47@t1_edgeswa:
	xor	esi, esi
$LN48@t1_edgeswa:
	cmp	DWORD PTR tv169[ebp], esi
	jne	$LN72@t1_edgeswa
	test	ecx, ecx
	je	SHORT $LN49@t1_edgeswa
	mov	esi, DWORD PTR _web+12
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+104
	mov	esi, DWORD PTR [edi+esi]
	mov	ecx, DWORD PTR [ecx+edx+64]
	mov	ecx, DWORD PTR [ecx+esi]
	jmp	SHORT $LN50@t1_edgeswa
$LN49@t1_edgeswa:
	xor	ecx, ecx
$LN50@t1_edgeswa:
	mov	ebx, DWORD PTR tv801[ebp]
	test	eax, eax
	je	SHORT $LN51@t1_edgeswa
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	edx, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [edx+eax]
	jmp	SHORT $LN52@t1_edgeswa
$LN51@t1_edgeswa:
	xor	eax, eax
$LN52@t1_edgeswa:
	cmp	ecx, eax
	jne	$LN76@t1_edgeswa

; 2604 :   }
; 2605 : 
; 2606 :   /* gather facet edges and check topology */
; 2607 :   fe_a = get_edge_fe(e_id);

	mov	edi, DWORD PTR _e_id$[ebp]
	push	edi
	call	_get_edge_fe
	mov	esi, eax
	add	esp, 4

; 2608 :   if ( !valid_id(fe_a) || !valid_id(get_fe_facet(fe_a)) ) 

	test	esi, 268435456				; 10000000H
	je	$LN77@t1_edgeswa
	push	esi
	call	_get_fe_facet
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	$LN77@t1_edgeswa

; 2616 :   }
; 2617 :   fe_b = get_next_facet(fe_a);

	push	esi
	call	_get_next_facet
	mov	edi, eax
	add	esp, 4

; 2618 :   if ( equal_id(fe_a,fe_b) ) 

	cmp	esi, edi
	jne	SHORT $LN25@t1_edgeswa

; 2619 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN35@t1_edgeswa

; 2620 :     { sprintf(msg,
; 2621 :        "Edge %s not t1_swapped since it has only one adjacent facet.\n",
; 2622 :           ELNAME(e_id));

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN57@t1_edgeswa
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN58@t1_edgeswa
$LN57@t1_edgeswa:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN58@t1_edgeswa:
	push	eax
	push	OFFSET ??_C@_0DO@JFJDLNIO@Edge?5?$CFs?5not?5t1_swapped?5since?5it?5@
$LN98@t1_edgeswa:
	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_sprintf

; 2623 :       outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 2731 : } // end t1_edgeswap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@t1_edgeswa:

; 2624 :     }
; 2625 :     return 0;
; 2626 :   }
; 2627 :   fe_c = get_prev_edge(fe_a);

	push	esi
	call	_get_prev_edge

; 2628 :   fe_d = get_next_edge(fe_a);

	push	esi
	mov	ebx, eax
	call	_get_next_edge

; 2629 :   fe_e = get_next_facet(fe_c);

	push	ebx
	mov	DWORD PTR _fe_d$[ebp], eax
	call	_get_next_facet

; 2630 :   fe_f = inverse_id(get_next_edge(fe_e));

	push	eax
	mov	DWORD PTR _fe_e$[ebp], eax
	call	_get_next_edge
	xor	eax, 134217728				; 08000000H

; 2631 :   fe_g = get_prev_edge(fe_b);

	push	edi
	mov	DWORD PTR _fe_f$[ebp], eax
	call	_get_prev_edge
	mov	DWORD PTR _fe_g$[ebp], eax

; 2632 :   fe_gg = get_next_facet(fe_f);

	mov	eax, DWORD PTR _fe_f$[ebp]
	push	eax
	call	_get_next_facet
	add	esp, 24					; 00000018H

; 2633 :   if ( !equal_id(fe_g,fe_gg) )

	cmp	DWORD PTR _fe_g$[ebp], eax
	je	$LN23@t1_edgeswa

; 2634 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN35@t1_edgeswa

; 2635 :     { sprintf(msg,
; 2636 :        "Edge %s not t1_swapped since tail vertex doesn't have valence 3.\n",
; 2637 :           ELNAME(e_id));

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN59@t1_edgeswa
	mov	ecx, DWORD PTR tv801[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN60@t1_edgeswa
$LN59@t1_edgeswa:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN60@t1_edgeswa:
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0EC@NBNNPMCI@Edge?5?$CFs?5not?5t1_swapped?5since?5tai@
	push	edx
	call	_sprintf

; 2638 :       outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 2639 : printf("fe_f edge %08X  fe_g edge %08X\n",get_fe_edge(fe_g),get_fe_edge(fe_f));

	mov	ecx, DWORD PTR _fe_f$[ebp]
	push	ecx
	call	_get_fe_edge
	mov	edx, DWORD PTR _fe_g$[ebp]
	add	esp, 20					; 00000014H
	push	eax
	push	edx
	call	_get_fe_edge
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CA@CIMCFIGG@fe_f?5edge?5?$CF08X?5?5fe_g?5edge?5?$CF08X?6?$AA@
	call	_printf
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 2731 : } // end t1_edgeswap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@t1_edgeswa:

; 2640 :     }
; 2641 :     return 0;
; 2642 :   }
; 2643 :   fe_j = get_next_facet(fe_d);

	mov	eax, DWORD PTR _fe_d$[ebp]
	push	eax
	call	_get_next_facet

; 2644 :   fe_i = inverse_id(get_prev_edge(fe_j));

	push	eax
	mov	DWORD PTR _fe_j$[ebp], eax
	call	_get_prev_edge
	xor	eax, 134217728				; 08000000H

; 2645 :   fe_h = get_next_edge(fe_b);

	push	edi
	mov	DWORD PTR _fe_i$[ebp], eax
	call	_get_next_edge

; 2646 :   if ( !equal_id(fe_i,get_next_facet(fe_h)) )

	push	eax
	mov	DWORD PTR _fe_h$[ebp], eax
	call	_get_next_facet
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _fe_i$[ebp], eax
	je	SHORT $LN21@t1_edgeswa

; 2647 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN35@t1_edgeswa

; 2648 :     { sprintf(msg,
; 2649 :        "Edge %s not t1_swapped since head vertex doesn't have valence 3.\n",
; 2650 :           ELNAME(e_id));

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN61@t1_edgeswa
	mov	ecx, DWORD PTR tv801[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN62@t1_edgeswa
$LN61@t1_edgeswa:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN62@t1_edgeswa:
	push	eax
	push	OFFSET ??_C@_0EC@MGCCNDH@Edge?5?$CFs?5not?5t1_swapped?5since?5hea@
$LN99@t1_edgeswa:
	mov	edx, DWORD PTR _msg
	push	edx
	call	_sprintf

; 2651 :       outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 2731 : } // end t1_edgeswap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@t1_edgeswa:

; 2652 :     }
; 2653 :     return 0;
; 2654 :   }
; 2655 :   f_a = inverse_id(get_fe_facet(fe_a));

	push	esi
	call	_get_fe_facet
	xor	eax, 134217728				; 08000000H

; 2656 :   f_b = get_fe_facet(fe_b);

	push	edi
	mov	DWORD PTR _f_a$[ebp], eax
	call	_get_fe_facet

; 2657 :   f_c = get_fe_facet(fe_e);

	mov	ecx, DWORD PTR _fe_e$[ebp]
	push	ecx
	mov	DWORD PTR _f_b$[ebp], eax
	call	_get_fe_facet

; 2658 :   f_d = get_fe_facet(fe_j);

	mov	edx, DWORD PTR _fe_j$[ebp]
	push	edx
	mov	DWORD PTR _f_c$[ebp], eax
	call	_get_fe_facet
	add	esp, 16					; 00000010H

; 2659 :   
; 2660 :   /* adjust wrapping so swapped edge is not wrapped */
; 2661 :   if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	mov	DWORD PTR _f_d$[ebp], eax
	je	SHORT $LN19@t1_edgeswa

; 2662 :     torus_unwrap_edge(e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	push	eax
	call	_torus_unwrap_edge
	add	esp, 4
	jmp	SHORT $LN16@t1_edgeswa
$LN19@t1_edgeswa:

; 2663 :   else if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN16@t1_edgeswa

; 2664 :   { edge_id pos_e = positive_id(e_id);  /* in case of quadratic */

	mov	eax, DWORD PTR _e_id$[ebp]
	and	eax, -134217729				; f7ffffffH

; 2665 :     int wrap = get_edge_wrap(pos_e);

	push	eax
	mov	DWORD PTR _pos_e$91211[ebp], eax
	call	_get_edge_wrap
	add	esp, 4

; 2666 :     if ( wrap ) 

	test	eax, eax
	je	SHORT $LN16@t1_edgeswa

; 2667 :       wrap_vertex(get_edge_headv(pos_e),wrap);

	mov	ecx, DWORD PTR _pos_e$91211[ebp]
	push	eax
	push	ecx
	call	_get_edge_headv
	add	esp, 4
	push	eax
	call	_wrap_vertex
	add	esp, 8
$LN16@t1_edgeswa:

; 2668 :   }
; 2669 :     
; 2670 :   /* Now the actual swapping */
; 2671 : 
; 2672 :   /* kludge to get quantity body integrals attached */
; 2673 :   set_fe_facet(fe_a,inverse_id(f_c));

	mov	eax, DWORD PTR _f_c$[ebp]
	xor	eax, 134217728				; 08000000H
	push	eax
	push	esi
	call	_set_fe_facet

; 2674 :   set_fe_facet(fe_b,f_d);

	mov	edx, DWORD PTR _f_d$[ebp]
	push	edx
	push	edi
	call	_set_fe_facet

; 2675 :   if ( equal_element(fe_a,get_facet_fe(f_a)) )

	mov	eax, DWORD PTR _f_a$[ebp]
	push	eax
	call	_get_facet_fe
	mov	ecx, esi
	or	eax, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	add	esp, 20					; 00000014H
	cmp	ecx, eax
	jne	SHORT $LN15@t1_edgeswa

; 2676 :     set_facet_fe(f_a,inverse_id(fe_c));

	mov	eax, DWORD PTR _f_a$[ebp]
	mov	edx, ebx
	xor	edx, 134217728				; 08000000H
	push	edx
	push	eax
	call	_set_facet_fe
	add	esp, 8
$LN15@t1_edgeswa:

; 2677 :   if ( equal_element(fe_b,get_facet_fe(f_b)) )

	mov	ecx, DWORD PTR _f_b$[ebp]
	push	ecx
	call	_get_facet_fe
	mov	edx, edi
	or	eax, 134217728				; 08000000H
	or	edx, 134217728				; 08000000H
	add	esp, 4
	cmp	edx, eax
	jne	SHORT $LN14@t1_edgeswa

; 2678 :     set_facet_fe(f_b,fe_g);

	mov	eax, DWORD PTR _fe_g$[ebp]
	mov	ecx, DWORD PTR _f_b$[ebp]
	push	eax
	push	ecx
	call	_set_facet_fe
	add	esp, 8
$LN14@t1_edgeswa:

; 2679 : 
; 2680 :   set_next_edge(fe_a,inverse_id(fe_e));

	mov	eax, DWORD PTR _fe_e$[ebp]
	xor	eax, 134217728				; 08000000H
	push	eax
	push	esi
	mov	DWORD PTR tv887[ebp], eax
	call	_set_next_edge

; 2681 :   set_prev_edge(inverse_id(fe_e),fe_a);

	mov	edx, DWORD PTR tv887[ebp]
	push	esi
	push	edx
	call	_set_prev_edge

; 2682 :   set_prev_edge(fe_a,fe_f);

	mov	eax, DWORD PTR _fe_f$[ebp]
	push	eax
	push	esi
	call	_set_prev_edge

; 2683 :   set_next_edge(fe_f,fe_a);

	mov	ecx, DWORD PTR _fe_f$[ebp]
	push	esi
	push	ecx
	call	_set_next_edge

; 2684 :   set_next_edge(fe_g,fe_h);

	mov	edx, DWORD PTR _fe_h$[ebp]
	mov	eax, DWORD PTR _fe_g$[ebp]
	push	edx
	push	eax
	call	_set_next_edge

; 2685 :   set_prev_edge(fe_h,fe_g);

	mov	ecx, DWORD PTR _fe_g$[ebp]
	mov	edx, DWORD PTR _fe_h$[ebp]
	push	ecx
	push	edx
	call	_set_prev_edge

; 2686 :   set_prev_edge(fe_b,inverse_id(fe_i));

	mov	eax, DWORD PTR _fe_i$[ebp]
	xor	eax, 134217728				; 08000000H
	push	eax
	push	edi
	call	_set_prev_edge

; 2687 :   set_prev_edge(fe_i,inverse_id(fe_b));

	mov	edx, DWORD PTR _fe_i$[ebp]
	mov	ecx, edi
	xor	ecx, 134217728				; 08000000H
	push	ecx
	push	edx
	call	_set_prev_edge

; 2688 :   set_next_edge(fe_b,fe_j);

	mov	eax, DWORD PTR _fe_j$[ebp]
	add	esp, 64					; 00000040H
	push	eax
	push	edi
	call	_set_next_edge

; 2689 :   set_prev_edge(fe_j,fe_b);

	mov	ecx, DWORD PTR _fe_j$[ebp]
	push	edi
	push	ecx
	call	_set_prev_edge

; 2690 :   set_next_edge(fe_c,fe_d);

	mov	edi, DWORD PTR _fe_d$[ebp]
	push	edi
	push	ebx
	call	_set_next_edge

; 2691 :   set_prev_edge(fe_d,fe_c);

	push	ebx
	push	edi
	call	_set_prev_edge

; 2692 :   remove_vertex_edge(tailv,get_fe_edge(inverse_id(fe_c)));

	mov	edx, ebx
	xor	edx, 134217728				; 08000000H
	push	edx
	call	_get_fe_edge
	push	eax
	mov	eax, DWORD PTR _tailv$[ebp]
	push	eax
	call	_remove_vertex_edge

; 2693 :   remove_vertex_edge(headv,get_fe_edge(fe_h));

	mov	edi, DWORD PTR _fe_h$[ebp]
	push	edi
	call	_get_fe_edge
	mov	ecx, DWORD PTR _headv$[ebp]
	push	eax
	push	ecx
	call	_remove_vertex_edge

; 2694 :   set_edge_headv(get_fe_edge(fe_c),headv);

	mov	edx, DWORD PTR _headv$[ebp]
	add	esp, 56					; 00000038H
	push	edx
	push	ebx
	call	_get_fe_edge
	add	esp, 4
	push	eax
	call	_set_edge_headv

; 2695 :   set_edge_tailv(get_fe_edge(fe_h),tailv);

	mov	eax, DWORD PTR _tailv$[ebp]
	add	esp, 8
	push	eax
	push	edi
	call	_get_fe_edge
	add	esp, 4
	push	eax
	call	_set_edge_tailv

; 2696 : 
; 2697 :   /* move vertices (note that edge was unwrapped earlier */
; 2698 :   hx = get_coord(headv);

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [ecx+edx+64]
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR tv812[ebp]
	mov	edi, DWORD PTR [edx+ecx]

; 2699 :   tx = get_coord(tailv);

	mov	edx, DWORD PTR tv822[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	add	ecx, eax

; 2700 :   if ( inverted(get_fe_facet(fe_a)) )

	push	esi
	add	edi, eax
	mov	DWORD PTR _tx$[ebp], ecx
	call	_get_fe_facet
	add	esp, 12					; 0000000cH
	test	eax, 134217728				; 08000000H
	je	SHORT $LN13@t1_edgeswa

; 2701 :   { newtx[0] = (hx[0]+tx[0])/2 - (hx[1]-tx[1])/2;  

	mov	edx, DWORD PTR _tx$[ebp]
	fld	QWORD PTR [edx]
	fadd	QWORD PTR [edi]
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fld	QWORD PTR [edi+8]
	fsub	QWORD PTR [edx+8]
	fmul	ST(0), ST(1)
	fld	ST(2)
	fsub	ST(0), ST(1)

; 2702 :     newhx[0] = (hx[0]+tx[0])/2 + (hx[1]-tx[1])/2;  

	fxch	ST(1)
	faddp	ST(3), ST(0)

; 2703 :     newtx[1] = (hx[1]+tx[1])/2 + (hx[0]-tx[0])/2;  

	fld	QWORD PTR [edx+8]
	fadd	QWORD PTR [edi+8]
	fmul	ST(0), ST(2)
	fld	QWORD PTR [edi]
	fsub	QWORD PTR [edx]
	fmul	ST(0), ST(3)
	fld	ST(0)
	fadd	ST(0), ST(2)

; 2704 :     newhx[1] = (hx[1]+tx[1])/2 - (hx[0]-tx[0])/2;  

	fxch	ST(2)
	fsubrp	ST(1), ST(0)

; 2705 :   }
; 2706 :   else

	jmp	SHORT $LN12@t1_edgeswa
$LN13@t1_edgeswa:

; 2707 :   { newtx[0] = (hx[0]+tx[0])/2 + (hx[1]-tx[1])/2;  

	mov	eax, DWORD PTR _tx$[ebp]
	fld	QWORD PTR [edi+8]
	fsub	QWORD PTR [eax+8]

; 2708 :     newhx[0] = (hx[0]+tx[0])/2 - (hx[1]-tx[1])/2;  
; 2709 :     newtx[1] = (hx[1]+tx[1])/2 - (hx[0]-tx[0])/2;  
; 2710 :     newhx[1] = (hx[1]+tx[1])/2 + (hx[0]-tx[0])/2;  

	mov	edx, eax
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fld	QWORD PTR [eax]
	fadd	QWORD PTR [edi]
	fmul	ST(0), ST(1)
	fld	ST(2)
	fadd	ST(0), ST(1)
	fxch	ST(1)
	fsubrp	ST(3), ST(0)
	fld	QWORD PTR [eax+8]
	fadd	QWORD PTR [edi+8]
	fmul	ST(0), ST(2)
	fld	QWORD PTR [edi]
	fsub	QWORD PTR [eax]
	fmul	ST(0), ST(3)
	fld	ST(1)
	fsub	ST(0), ST(1)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
$LN12@t1_edgeswa:

; 2711 :   }
; 2712 :   hx[0] = newhx[0];

	fxch	ST(4)
	fstp	QWORD PTR [edi]

; 2713 :   hx[1] = newhx[1];

	fxch	ST(3)
	fstp	QWORD PTR [edi+8]

; 2714 :   tx[0] = newtx[0];

	fstp	QWORD PTR [edx]

; 2715 :   tx[1] = newtx[1];

	fxch	ST(1)
	fstp	QWORD PTR [edx+8]

; 2716 :   if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	SHORT $LN83@t1_edgeswa

; 2717 :   { REAL *midx = get_coord(get_edge_midv(e_id));

	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR tv801[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR _web+216
	mov	esi, DWORD PTR [esi+eax+304]
	mov	ecx, DWORD PTR [ecx+esi+8]
	mov	esi, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR _web+104
	add	esi, DWORD PTR [ecx+eax+64]

; 2718 :     for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	$LN86@t1_edgeswa
	sub	edx, edi
	mov	eax, edi
	sub	esi, edi
$LN10@t1_edgeswa:

; 2719 :       midx[i] = (hx[i] + tx[i])/2;

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi+eax-8]
	mov	ebx, DWORD PTR _web+616
	cmp	ecx, ebx
	jl	SHORT $LN10@t1_edgeswa

; 2718 :     for ( i = 0 ; i < SDIM ; i++ )

	jmp	SHORT $LN97@t1_edgeswa
$LN83@t1_edgeswa:
	mov	ebx, DWORD PTR _web+616
$LN97@t1_edgeswa:

; 2720 :   }
; 2721 :   if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	fstp	ST(0)
	jne	$LN4@t1_edgeswa

; 2722 :   { vertex_id *v = get_edge_vertices(e_id);

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR tv801[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+304]

; 2723 :     for ( j = 1 ; j < web.lagrange_order ; j++ )

	mov	ecx, DWORD PTR _web+632
	mov	DWORD PTR _v$91241[ebp], eax
	mov	DWORD PTR _j$[ebp], 1
	cmp	ecx, 1
	jle	$LN4@t1_edgeswa
	jmp	SHORT $LN6@t1_edgeswa
	npad	1
$LL75@t1_edgeswa:
	mov	eax, DWORD PTR _v$91241[ebp]
$LN6@t1_edgeswa:

; 2724 :     { REAL *x = get_coord(v[j]);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	add	esi, DWORD PTR [eax+edx+64]

; 2725 :       for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	test	ebx, ebx
	jle	SHORT $LN5@t1_edgeswa
	mov	ebx, DWORD PTR _tx$[ebp]
	fild	DWORD PTR _j$[ebp]
	sub	ebx, edi
	mov	eax, edi
	mov	DWORD PTR tv1128[ebp], ebx
	sub	esi, edi
$LN3@t1_edgeswa:

; 2726 :         x[i] = (j*hx[i] + (web.lagrange_order-j)*tx[i])/web.lagrange_order;

	sub	ecx, DWORD PTR _j$[ebp]
	inc	edx
	mov	DWORD PTR tv1081[ebp], ecx
	fild	DWORD PTR tv1081[ebp]
	mov	ecx, DWORD PTR tv1128[ebp]
	add	eax, 8
	fmul	QWORD PTR [eax+ecx-8]
	fld	ST(1)
	fmul	QWORD PTR [eax-8]
	faddp	ST(1), ST(0)
	fidiv	DWORD PTR _web+632
	fstp	QWORD PTR [esi+eax-8]
	mov	ebx, DWORD PTR _web+616
	mov	ecx, DWORD PTR _web+632
	cmp	edx, ebx
	jl	SHORT $LN3@t1_edgeswa

; 2725 :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN5@t1_edgeswa:

; 2723 :     for ( j = 1 ; j < web.lagrange_order ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, ecx
	jl	SHORT $LL75@t1_edgeswa

; 2727 :     }
; 2728 :   }
; 2729 : 
; 2730 :   return 1;

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 2731 : } // end t1_edgeswap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN86@t1_edgeswa:

; 2723 :     for ( j = 1 ; j < web.lagrange_order ; j++ )

	fstp	ST(0)
$LN4@t1_edgeswa:
	pop	edi
	pop	esi

; 2727 :     }
; 2728 :   }
; 2729 : 
; 2730 :   return 1;

	mov	eax, 1
	pop	ebx

; 2731 : } // end t1_edgeswap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN77@t1_edgeswa:

; 2609 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN35@t1_edgeswa

; 2610 :     { sprintf(msg,
; 2611 :        "Edge %s not t1_swapped since it does not have adjacent facets.\n",
; 2612 :           ELNAME(e_id));

	test	edi, 268435456				; 10000000H
	je	SHORT $LN55@t1_edgeswa
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	push	eax
	push	OFFSET ??_C@_0EA@FBNOLBBK@Edge?5?$CFs?5not?5t1_swapped?5since?5it?5@

; 2613 :       outstring(msg);
; 2614 :     }
; 2615 :     return 0;

	jmp	$LN99@t1_edgeswa
$LN55@t1_edgeswa:

; 2610 :     { sprintf(msg,
; 2611 :        "Edge %s not t1_swapped since it does not have adjacent facets.\n",
; 2612 :           ELNAME(e_id));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0EA@FBNOLBBK@Edge?5?$CFs?5not?5t1_swapped?5since?5it?5@

; 2613 :       outstring(msg);
; 2614 :     }
; 2615 :     return 0;

	jmp	$LN99@t1_edgeswa
$LN72@t1_edgeswa:

; 2610 :     { sprintf(msg,
; 2611 :        "Edge %s not t1_swapped since it does not have adjacent facets.\n",
; 2612 :           ELNAME(e_id));

	mov	ebx, DWORD PTR tv801[ebp]
$LN76@t1_edgeswa:

; 2597 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN35@t1_edgeswa

; 2598 :     { sprintf(msg,
; 2599 :        "Edge %s not t1_swapped due to differing boundaries.\n",
; 2600 :           ELNAME(e_id));

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN53@t1_edgeswa
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	push	eax
	push	OFFSET ??_C@_0DF@GHCFABCF@Edge?5?$CFs?5not?5t1_swapped?5due?5to?5di@

; 2601 :       outstring(msg);
; 2602 :     }
; 2603 :     return 0;

	jmp	$LN98@t1_edgeswa
$LN53@t1_edgeswa:

; 2598 :     { sprintf(msg,
; 2599 :        "Edge %s not t1_swapped due to differing boundaries.\n",
; 2600 :           ELNAME(e_id));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0DF@GHCFABCF@Edge?5?$CFs?5not?5t1_swapped?5due?5to?5di@

; 2601 :       outstring(msg);
; 2602 :     }
; 2603 :     return 0;

	jmp	$LN98@t1_edgeswa
$LN33@t1_edgeswa:

; 2586 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN35@t1_edgeswa

; 2587 :     { sprintf(msg,
; 2588 :        "Edge %s not t1_swapped due to differing constraints.\n",
; 2589 :           ELNAME(e_id));

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN43@t1_edgeswa
	mov	eax, DWORD PTR tv801[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	push	eax
	push	OFFSET ??_C@_0DG@KKHIOEIA@Edge?5?$CFs?5not?5t1_swapped?5due?5to?5di@

; 2590 :       outstring(msg);
; 2591 :     }
; 2592 :     return 0;

	jmp	$LN98@t1_edgeswa
$LN43@t1_edgeswa:

; 2587 :     { sprintf(msg,
; 2588 :        "Edge %s not t1_swapped due to differing constraints.\n",
; 2589 :           ELNAME(e_id));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ??_C@_0DG@KKHIOEIA@Edge?5?$CFs?5not?5t1_swapped?5due?5to?5di@

; 2590 :       outstring(msg);
; 2591 :     }
; 2592 :     return 0;

	jmp	$LN98@t1_edgeswa
$LN73@t1_edgeswa:

; 2587 :     { sprintf(msg,
; 2588 :        "Edge %s not t1_swapped due to differing constraints.\n",
; 2589 :           ELNAME(e_id));

	mov	ecx, DWORD PTR tv801[ebp]
$LN74@t1_edgeswa:

; 2575 :   { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN35@t1_edgeswa

; 2576 :     { sprintf(msg,
; 2577 :        "Edge %s not t1_swapped due to fixedness.\n",
; 2578 :           ELNAME(e_id));

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN41@t1_edgeswa
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN42@t1_edgeswa
$LN41@t1_edgeswa:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN42@t1_edgeswa:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0CK@LMDDHND@Edge?5?$CFs?5not?5t1_swapped?5due?5to?5fi@
	push	eax
	call	_sprintf

; 2579 :       outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
$LN35@t1_edgeswa:

; 2580 :     }
; 2581 :     return 0;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 2731 : } // end t1_edgeswap()

	mov	esp, ebp
	pop	ebp
	ret	0
_t1_edgeswap ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@LJEGLNGI@Internal?5error?5?9?5unclosed?5facete@ ; `string'
PUBLIC	??_C@_0CN@CGONHFJB@Internal?5error?3?5Bad?5edge?5loop?5on@ ; `string'
PUBLIC	??_C@_0DK@ELKKFNHN@vertex_merge?5can?8t?5handle?5wraps?5@ ; `string'
PUBLIC	??_C@_0CO@EDCGJOAK@vertex_merge?5called?5with?5identic@ ; `string'
PUBLIC	??_C@_0DI@PFHJLOBH@vertex_merge?5only?5in?5LINEAR?5or?5Q@ ; `string'
PUBLIC	??_C@_0DJ@PHFIMEGN@vertex_merge?3?5Cannot?5merge?5?$CFs?5si@ ; `string'
PUBLIC	_throwv$GSCopy$
PUBLIC	_keepv$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_merge_vertex
EXTRN	_matvec_mul:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_floor:PROC
;	COMDAT ??_C@_0CK@LJEGLNGI@Internal?5error?5?9?5unclosed?5facete@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CK@LJEGLNGI@Internal?5error?5?9?5unclosed?5facete@ DB 'Internal er'
	DB	'ror - unclosed facetedge loop', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CGONHFJB@Internal?5error?3?5Bad?5edge?5loop?5on@
CONST	SEGMENT
??_C@_0CN@CGONHFJB@Internal?5error?3?5Bad?5edge?5loop?5on@ DB 'Internal e'
	DB	'rror: Bad edge loop on vertex %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@ELKKFNHN@vertex_merge?5can?8t?5handle?5wraps?5@
CONST	SEGMENT
??_C@_0DK@ELKKFNHN@vertex_merge?5can?8t?5handle?5wraps?5@ DB 'vertex_merg'
	DB	'e can''t handle wraps in non-torus symmetries.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@EDCGJOAK@vertex_merge?5called?5with?5identic@
CONST	SEGMENT
??_C@_0CO@EDCGJOAK@vertex_merge?5called?5with?5identic@ DB 'vertex_merge '
	DB	'called with identical vertices.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@PFHJLOBH@vertex_merge?5only?5in?5LINEAR?5or?5Q@
CONST	SEGMENT
??_C@_0DI@PFHJLOBH@vertex_merge?5only?5in?5LINEAR?5or?5Q@ DB 'vertex_merg'
	DB	'e only in LINEAR or QUADRATIC model so far.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@PHFIMEGN@vertex_merge?3?5Cannot?5merge?5?$CFs?5si@
CONST	SEGMENT
??_C@_0DJ@PHFIMEGN@vertex_merge?3?5Cannot?5merge?5?$CFs?5si@ DB 'vertex_m'
	DB	'erge: Cannot merge %s since not at end of edge.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _merge_vertex
_TEXT	SEGMENT
tv1628 = -172						; size = 4
tv1652 = -168						; size = 4
tv1596 = -168						; size = 4
_keep_e$91314 = -164					; size = 4
_throwv$GSCopy$ = -160					; size = 4
tv1797 = -156						; size = 4
_keep_e_start$91316 = -156				; size = 4
tv2268 = -152						; size = 4
_throw_e$91315 = -152					; size = 4
tv2272 = -148						; size = 4
tv1593 = -148						; size = 4
tv1788 = -144						; size = 4
tv1750 = -144						; size = 4
_keepv$GSCopy$ = -144					; size = 4
tv1472 = -140						; size = 4
_throw_fe_1$91312 = -140				; size = 4
_match_f$ = -136					; size = 4
tv2264 = -132						; size = 4
tv1765 = -132						; size = 4
_throw_e_start$91317 = -132				; size = 4
_match_tfe$ = -128					; size = 4
_newf$91406 = -124					; size = 4
_found$91385 = -124					; size = 4
_nn$ = -124						; size = 4
_prev_k$91381 = -120					; size = 4
_wrap$ = -120						; size = 4
tv2247 = -116						; size = 4
tv1768 = -116						; size = 4
tv710 = -116						; size = 4
_keep_fe$91311 = -116					; size = 4
_fe_counter_max$91387 = -112				; size = 4
_throw_fe_2$91313 = -112				; size = 4
_match_kfe$ = -108					; size = 4
tv1826 = -104						; size = 4
tv1486 = -104						; size = 4
_u$91302 = -100						; size = 48
_z$91301 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_keepv$ = 8						; size = 4
_throwv$ = 12						; size = 4
_merge_vertex PROC					; COMDAT

; 2747 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2748 :   edge_id e_id;
; 2749 :   int nn = 0;
; 2750 :   int i,wrap=0;
; 2751 :   facet_id match_f=NULLID;
; 2752 :   facetedge_id match_kfe=NULLID,match_tfe=NULLID;
; 2753 : 
; 2754 :   if ( get_vattr(keepv) & (Q_MIDPOINT|Q_MIDEDGE|Q_MIDFACET) )

	mov	eax, DWORD PTR _web+12
	push	ebx
	push	esi
	mov	esi, DWORD PTR _keepv$[ebp]
	mov	ebx, esi
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+8]
	xor	ecx, ecx
	push	edi
	mov	edi, DWORD PTR _throwv$[ebp]
	and	eax, 6422528				; 00620000H
	or	eax, ecx
	mov	DWORD PTR _keepv$GSCopy$[ebp], esi
	mov	DWORD PTR _throwv$GSCopy$[ebp], edi
	mov	DWORD PTR _nn$[ebp], ecx
	mov	DWORD PTR _wrap$[ebp], ecx
	mov	DWORD PTR _match_f$[ebp], ecx
	mov	DWORD PTR _match_kfe$[ebp], ecx
	mov	DWORD PTR _match_tfe$[ebp], ecx
	mov	DWORD PTR tv1472[ebp], ebx
	je	SHORT $LN64@merge_vert

; 2755 :   { sprintf(errmsg,"vertex_merge: Cannot merge %s since not at end of edge.\n",
; 2756 :        ELNAME(keepv));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN67@merge_vert
	lea	ecx, DWORD PTR [ebx+1]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN68@merge_vert
$LN67@merge_vert:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN68@merge_vert:
	push	eax
	push	OFFSET ??_C@_0DJ@PHFIMEGN@vertex_merge?3?5Cannot?5merge?5?$CFs?5si@
	push	OFFSET _errmsg
	call	_sprintf

; 2757 :     kb_error(4321,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4321					; 000010e1H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN64@merge_vert:

; 2758 :   }
; 2759 :   if ( get_vattr(throwv) & (Q_MIDPOINT|Q_MIDEDGE|Q_MIDFACET) )

	mov	edx, DWORD PTR _web+12
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 6422528				; 00620000H
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv1486[ebp], ecx
	je	SHORT $LN63@merge_vert

; 2760 :   { sprintf(errmsg,"vertex_merge: Cannot merge %s since not at end of edge.\n",
; 2761 :        ELNAME(throwv));

	test	edi, 268435456				; 10000000H
	je	SHORT $LN69@merge_vert
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN70@merge_vert
$LN69@merge_vert:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN70@merge_vert:
	push	eax
	push	OFFSET ??_C@_0DJ@PHFIMEGN@vertex_merge?3?5Cannot?5merge?5?$CFs?5si@
	push	OFFSET _errmsg
	call	_sprintf

; 2762 :     kb_error(4324,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4324					; 000010e4H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN63@merge_vert:

; 2763 :   }
; 2764 : 
; 2765 :   if ( (web.modeltype != LINEAR) && (web.modeltype != QUADRATIC) )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	je	SHORT $LN62@merge_vert
	cmp	eax, 2
	je	SHORT $LN62@merge_vert

; 2766 :     kb_error(3913,"vertex_merge only in LINEAR or QUADRATIC model so far.\n",
; 2767 :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DI@PFHJLOBH@vertex_merge?5only?5in?5LINEAR?5or?5Q@
	push	3913					; 00000f49H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN62@merge_vert:

; 2768 :   
; 2769 :   if ( equal_id(keepv,throwv) )

	cmp	esi, edi
	jne	SHORT $LN61@merge_vert

; 2770 :   { kb_error(3882,"vertex_merge called with identical vertices.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CO@EDCGJOAK@vertex_merge?5called?5with?5identic@
	push	3882					; 00000f2aH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2976 :   
; 2977 : } // end merge_vertex()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@merge_vert:

; 2771 :     return;
; 2772 :   }
; 2773 :  
; 2774 :   if ( web.symmetry_flag && !web.torus_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN60@merge_vert
	cmp	DWORD PTR _web+860, 0
	jne	SHORT $LN207@merge_vert

; 2775 :   { kb_error(3883,"vertex_merge can't handle wraps in non-torus symmetries.\n",
; 2776 :       RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DK@ELKKFNHN@vertex_merge?5can?8t?5handle?5wraps?5@
	push	3883					; 00000f2bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN60@merge_vert:

; 2777 :   }
; 2778 :    
; 2779 : 
; 2780 :   /* no checks on constraints or fixedness; let the user beware! */
; 2781 : 
; 2782 :   /* maybe have wrapping in torus mode */
; 2783 :   if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	je	$LN209@merge_vert
$LN207@merge_vert:

; 2784 :   { REAL *x = get_coord(keepv);

	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	edx, DWORD PTR _web+12

; 2785 :     REAL *y = get_coord(throwv);

	mov	esi, DWORD PTR tv1486[ebp]
	mov	edi, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR [edx+ebx*4]
	add	ecx, eax
	add	edi, eax

; 2786 :     REAL z[MAXCOORD];
; 2787 :     REAL u[MAXCOORD];
; 2788 :    
; 2789 :     for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	xor	esi, esi
	cmp	eax, 4
	jl	$LN212@merge_vert

; 2790 :       z[i] = y[i] - x[i];

	mov	ebx, edi
	sub	ebx, ecx
	mov	DWORD PTR tv2247[ebp], ebx
	lea	ebx, DWORD PTR _z$91301[ebp]
	sub	ebx, ecx
	mov	DWORD PTR tv2264[ebp], ebx
	lea	ebx, DWORD PTR _z$91301[ebp+8]
	sub	ebx, ecx
	mov	DWORD PTR tv2268[ebp], ebx
	lea	ebx, DWORD PTR _z$91301[ebp+16]
	sub	ebx, ecx
	lea	edx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR tv2272[ebp], ebx
	npad	7
$LL206@merge_vert:
	fld	QWORD PTR [edx-24]
	mov	ebx, DWORD PTR tv2247[ebp]
	fsub	QWORD PTR [eax-8]
	add	esi, 4
	add	eax, 32					; 00000020H
	add	edx, 32					; 00000020H
	fstp	QWORD PTR _z$91301[ebp+esi*8-32]
	fld	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv2264[ebp]
	fsub	QWORD PTR [eax-32]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv2268[ebp]
	fld	QWORD PTR [edx-40]
	fsub	QWORD PTR [eax-24]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv2272[ebp]
	fld	QWORD PTR [edx-32]
	fsub	QWORD PTR [eax-16]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR _web+616
	add	ebx, -3					; fffffffdH
	cmp	esi, ebx
	jl	SHORT $LL206@merge_vert
	mov	ebx, DWORD PTR tv1472[ebp]
	mov	eax, DWORD PTR _web+616
$LN212@merge_vert:

; 2786 :     REAL z[MAXCOORD];
; 2787 :     REAL u[MAXCOORD];
; 2788 :    
; 2789 :     for ( i = 0 ; i < SDIM ; i++ )

	cmp	esi, eax
	jge	SHORT $LN204@merge_vert
	lea	edx, DWORD PTR _z$91301[ebp]
	lea	eax, DWORD PTR [ecx+esi*8]
	sub	edi, ecx
	sub	edx, ecx
	mov	ecx, DWORD PTR _web+616
	sub	ecx, esi
$LC58@merge_vert:

; 2790 :       z[i] = y[i] - x[i];

	fld	QWORD PTR [eax+edi]
	add	eax, 8
	dec	ecx
	fsub	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax+edx-8]
	jne	SHORT $LC58@merge_vert

; 2786 :     REAL z[MAXCOORD];
; 2787 :     REAL u[MAXCOORD];
; 2788 :    
; 2789 :     for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
$LN204@merge_vert:

; 2791 :     matvec_mul(web.inverse_periods,z,u,SDIM,SDIM);

	mov	ecx, DWORD PTR _web+1612
	push	eax
	push	eax
	lea	edx, DWORD PTR _u$91302[ebp]
	push	edx
	lea	eax, DWORD PTR _z$91301[ebp]
	push	eax
	push	ecx
	call	_matvec_mul

; 2792 :     for ( i = SDIM-1, wrap = 0 ; i >= 0 ; i-- )

	mov	esi, DWORD PTR _web+616
	add	esp, 20					; 00000014H
	dec	esi
	mov	DWORD PTR _wrap$[ebp], 0
	js	SHORT $LN209@merge_vert
	mov	edi, DWORD PTR _wrap$[ebp]
	npad	10
$LL211@merge_vert:

; 2793 :     { wrap <<= TWRAPBITS;
; 2794 :       wrap |= (int)(floor(u[i]+0.5)) & WRAPMASK;      

	fld	QWORD PTR _u$91302[ebp+esi*8]
	sub	esp, 8
	fadd	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	and	eax, 31					; 0000001fH
	shl	edi, 6
	or	edi, eax
	dec	esi
	jns	SHORT $LL211@merge_vert
	mov	DWORD PTR _wrap$[ebp], edi
$LN209@merge_vert:

; 2795 :     }
; 2796 :   }
; 2797 :   
; 2798 :   /* for later fixup in string model */
; 2799 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	$found_match$91335

; 2800 :   { /* find common face four of the facetedges have in common */
; 2801 :     facetedge_id keep_fe;
; 2802 :     facetedge_id throw_fe_1,throw_fe_2;
; 2803 :     edge_id keep_e, throw_e, keep_e_start, throw_e_start;
; 2804 :     facet_id kf,tf;
; 2805 : 
; 2806 :     match_kfe = match_tfe = NULLID;

	xor	eax, eax
	mov	DWORD PTR _match_tfe$[ebp], eax
	mov	DWORD PTR _match_kfe$[ebp], eax

; 2807 :     match_f = NULLID;

	mov	DWORD PTR _match_f$[ebp], eax

; 2808 :     keep_e = keep_e_start = get_vertex_edge(keepv);

	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+ebx*4]
	mov	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR _keep_e_start$91316[ebp], ecx
	mov	DWORD PTR _keep_e$91314[ebp], ecx

; 2809 :     do
; 2810 :     {
; 2811 :       throw_e = throw_e_start = get_vertex_edge(throwv);

	mov	ecx, DWORD PTR tv1486[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _throw_e_start$91317[ebp], eax
	npad	4
$LL51@merge_vert:
	mov	ebx, DWORD PTR _throw_e_start$91317[ebp]
	mov	DWORD PTR _throw_e$91315[ebp], ebx
	npad	4
$LL48@merge_vert:

; 2812 :       do
; 2813 :       {
; 2814 :         /* see if facetedges match up */
; 2815 :         keep_fe = get_edge_fe(keep_e);

	mov	ecx, DWORD PTR _keep_e$91314[ebp]
	push	ecx
	call	_get_edge_fe
	add	esp, 4
	mov	DWORD PTR _keep_fe$91311[ebp], eax

; 2816 :         if ( valid_id(keep_fe) && valid_id(get_fe_facet(keep_fe)) )

	test	eax, 268435456				; 10000000H
	je	$LN40@merge_vert
	mov	ecx, DWORD PTR _web+460
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv1593[ebp], ecx
	mov	ecx, DWORD PTR [ecx+24]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv1596[ebp], ecx
	je	SHORT $LN73@merge_vert
	xor	ecx, 134217728				; 08000000H
$LN73@merge_vert:
	test	ecx, 268435456				; 10000000H
	je	$LN40@merge_vert

; 2817 :         {
; 2818 :           throw_fe_1 = get_edge_fe(throw_e);

	mov	ecx, DWORD PTR _web+124
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	test	ecx, ecx
	jne	SHORT $LN78@merge_vert
	xor	esi, esi
	mov	DWORD PTR _throw_fe_1$91312[ebp], esi
	jmp	SHORT $LN79@merge_vert
$LN78@merge_vert:
	mov	ecx, DWORD PTR [ecx+28]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN77@merge_vert
	xor	ecx, 134217728				; 08000000H
$LN77@merge_vert:
	mov	esi, ecx
	mov	DWORD PTR _throw_fe_1$91312[ebp], ecx
$LN79@merge_vert:

; 2819 :           if ( valid_id(throw_fe_1) && valid_id(get_fe_facet(throw_fe_1)) )

	test	esi, 268435456				; 10000000H
	je	$LN40@merge_vert
	mov	ecx, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edi, DWORD PTR [ecx+24]
	shr	esi, 27					; 0000001bH
	and	esi, 1
	mov	DWORD PTR tv1628[ebp], edi
	mov	edx, edi
	je	SHORT $LN81@merge_vert
	xor	edx, 134217728				; 08000000H
$LN81@merge_vert:
	test	edx, 268435456				; 10000000H
	je	$LN40@merge_vert

; 2820 :           {
; 2821 :             throw_fe_2 = get_next_facet(throw_fe_1);

	test	esi, esi
	je	SHORT $LN86@merge_vert
	mov	ecx, DWORD PTR [ecx+36]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR _throw_fe_2$91313[ebp], ecx
	jmp	SHORT $LN85@merge_vert
$LN86@merge_vert:
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _throw_fe_2$91313[ebp], edx
$LN85@merge_vert:

; 2822 :             kf = get_fe_facet(keep_fe);

	mov	edx, DWORD PTR tv1596[ebp]
	test	eax, eax
	je	SHORT $LN223@merge_vert
	xor	edx, 134217728				; 08000000H
$LN223@merge_vert:

; 2823 :             tf = get_fe_facet(throw_fe_1);

	mov	ecx, edi
	test	esi, esi
	je	SHORT $LN93@merge_vert
	xor	ecx, 134217728				; 08000000H
$LN93@merge_vert:

; 2824 :             if ( equal_element(kf,tf) && !like_sign(kf,tf) )

	mov	ebx, edx
	mov	edi, ecx
	or	ebx, 134217728				; 08000000H
	or	edi, 134217728				; 08000000H
	cmp	ebx, edi
	jne	SHORT $LN43@merge_vert
	xor	ecx, edx
	test	ecx, 134217728				; 08000000H
	jne	$LN188@merge_vert
$LN43@merge_vert:

; 2829 :             }
; 2830 :             tf = get_fe_facet(throw_fe_2);

	mov	edi, DWORD PTR _throw_fe_2$91313[ebp]
	mov	ecx, edi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR tv1652[ebp], ecx
	jne	SHORT $LN98@merge_vert
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN97@merge_vert
$LN98@merge_vert:
	mov	ecx, DWORD PTR _web+460
	and	edi, 134217727				; 07ffffffH
	test	DWORD PTR _throw_fe_2$91313[ebp], 134217728 ; 08000000H
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [ecx+24]
	je	SHORT $LN97@merge_vert
	xor	ecx, 134217728				; 08000000H
$LN97@merge_vert:

; 2831 :             if ( equal_element(kf,tf) && !like_sign(kf,tf) )

	mov	edi, ecx
	or	edi, 134217728				; 08000000H
	cmp	ebx, edi
	jne	SHORT $LN217@merge_vert
	mov	edi, edx
	xor	edi, ecx
	test	edi, 134217728				; 08000000H
	jne	$LN190@merge_vert
$LN217@merge_vert:

; 2836 :             }
; 2837 :   
; 2838 :             keep_fe = get_next_facet(keep_fe);

	test	eax, eax
	je	SHORT $LN102@merge_vert
	mov	edx, DWORD PTR tv1593[ebp]
	mov	ebx, DWORD PTR [edx+36]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN101@merge_vert
$LN102@merge_vert:
	mov	eax, DWORD PTR tv1593[ebp]
	mov	ebx, DWORD PTR [eax+40]
$LN101@merge_vert:

; 2839 :             kf = get_fe_facet(keep_fe);

	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN106@merge_vert
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN105@merge_vert
$LN106@merge_vert:
	mov	edx, DWORD PTR _web+460
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+24]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN105@merge_vert
	xor	ecx, 134217728				; 08000000H
$LN105@merge_vert:

; 2840 :             tf = get_fe_facet(throw_fe_1);

	mov	eax, DWORD PTR tv1628[ebp]
	test	esi, esi
	je	SHORT $LN224@merge_vert
	xor	eax, 134217728				; 08000000H
$LN224@merge_vert:

; 2841 :             if ( equal_element(kf,tf) && !like_sign(kf,tf) )

	mov	edx, ecx
	mov	esi, eax
	or	edx, 134217728				; 08000000H
	or	esi, 134217728				; 08000000H
	cmp	edx, esi
	jne	SHORT $LN41@merge_vert
	xor	eax, ecx
	test	eax, 134217728				; 08000000H
	jne	$LN191@merge_vert
$LN41@merge_vert:

; 2846 :             }
; 2847 :             tf = get_fe_facet(throw_fe_2);

	cmp	DWORD PTR tv1652[ebp], 0
	mov	esi, DWORD PTR _throw_fe_2$91313[ebp]
	jne	SHORT $LN114@merge_vert
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN113@merge_vert
$LN114@merge_vert:
	mov	edi, DWORD PTR _web+460
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN113@merge_vert
	xor	eax, 134217728				; 08000000H
$LN113@merge_vert:

; 2848 :             if ( equal_element(kf,tf) && !like_sign(kf,tf) )

	mov	edi, eax
	or	edi, 134217728				; 08000000H
	cmp	edx, edi
	jne	SHORT $LN218@merge_vert
	xor	eax, ecx
	test	eax, 134217728				; 08000000H
	jne	$LN192@merge_vert
$LN218@merge_vert:
	mov	ebx, DWORD PTR _throw_e$91315[ebp]
$LN40@merge_vert:

; 2852 :               goto found_match;
; 2853 :             }
; 2854 :           }
; 2855 :         }
; 2856 :         throw_e = get_next_tail_edge(throw_e);

	mov	edx, DWORD PTR _web+124
	mov	ecx, ebx
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ebx*4]
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	ebx, DWORD PTR [eax+ecx*4+32]
	mov	DWORD PTR _throw_e$91315[ebp], ebx

; 2857 :       } while ( !equal_id(throw_e,throw_e_start) );

	cmp	ebx, DWORD PTR _throw_e_start$91317[ebp]
	jne	$LL48@merge_vert

; 2858 :       keep_e = get_next_tail_edge(keep_e);

	mov	eax, DWORD PTR _keep_e$91314[ebp]
	mov	ecx, eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4+32]
	mov	DWORD PTR _keep_e$91314[ebp], eax

; 2859 :     } while ( !equal_id(keep_e,keep_e_start) );

	cmp	eax, DWORD PTR _keep_e_start$91316[ebp]
	jne	$LL51@merge_vert
	jmp	SHORT $found_match$91335
$LN188@merge_vert:

; 2825 :             { match_f = kf;
; 2826 :               match_kfe = keep_fe;

	mov	ecx, DWORD PTR _keep_fe$91311[ebp]
	mov	DWORD PTR _match_f$[ebp], edx

; 2827 :               match_tfe = throw_fe_1;

	mov	edx, DWORD PTR _throw_fe_1$91312[ebp]
	mov	DWORD PTR _match_kfe$[ebp], ecx
	mov	DWORD PTR _match_tfe$[ebp], edx

; 2828 :               goto found_match;

	jmp	SHORT $found_match$91335
$LN190@merge_vert:

; 2832 :             { match_f = kf;
; 2833 :               match_kfe = keep_fe;

	mov	eax, DWORD PTR _keep_fe$91311[ebp]

; 2834 :               match_tfe = throw_fe_2;

	mov	ecx, DWORD PTR _throw_fe_2$91313[ebp]
	mov	DWORD PTR _match_f$[ebp], edx
	mov	DWORD PTR _match_kfe$[ebp], eax
	mov	DWORD PTR _match_tfe$[ebp], ecx

; 2835 :               goto found_match;

	jmp	SHORT $found_match$91335
$LN191@merge_vert:

; 2842 :             { match_f = kf;
; 2843 :               match_kfe = keep_fe;
; 2844 :               match_tfe = throw_fe_1;

	mov	edx, DWORD PTR _throw_fe_1$91312[ebp]
	mov	DWORD PTR _match_tfe$[ebp], edx

; 2845 :               goto found_match;

	jmp	SHORT $LN225@merge_vert
$LN192@merge_vert:

; 2851 :               match_tfe = throw_fe_2;

	mov	DWORD PTR _match_tfe$[ebp], esi
$LN225@merge_vert:

; 2849 :             { match_f = kf;
; 2850 :               match_kfe = keep_fe;

	mov	DWORD PTR _match_kfe$[ebp], ebx
	mov	DWORD PTR _match_f$[ebp], ecx
$found_match$91335:

; 2860 :  found_match: ;
; 2861 : 
; 2862 : 
; 2863 :   }
; 2864 :    /* change all references to the eliminated vertex to the kept vertex. */
; 2865 :    for (;;)
; 2866 :    { e_id = get_vertex_edge(throwv);

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR tv1486[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	esi, DWORD PTR [edx+28]

; 2867 :      if ( !valid_id(e_id) ) break;

	test	esi, 268435456				; 10000000H
	je	$LN219@merge_vert
$LL39@merge_vert:

; 2868 :      remove_vertex_edge(throwv,e_id);

	mov	eax, DWORD PTR _throwv$GSCopy$[ebp]
	push	esi
	push	eax
	call	_remove_vertex_edge

; 2869 :      set_edge_tailv(e_id,keepv);

	mov	ecx, DWORD PTR _keepv$GSCopy$[ebp]
	push	ecx
	push	esi
	call	_set_edge_tailv
	add	esp, 16					; 00000010H

; 2870 :      if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	je	$LN29@merge_vert

; 2871 :      { WRAPTYPE invwrap = (*sym_inverse)(wrap);

	mov	edx, DWORD PTR _wrap$[ebp]
	push	edx
	call	DWORD PTR _sym_inverse

; 2872 :        set_edge_wrap(e_id,(*sym_compose)(invwrap,get_edge_wrap(e_id)));

	mov	edx, DWORD PTR _web+216
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	mov	ebx, eax
	mov	eax, DWORD PTR _web+124
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+784]
	mov	eax, DWORD PTR [ecx+edx]
	shr	esi, 27					; 0000001bH
	add	esp, 4
	and	esi, 1
	je	SHORT $LN123@merge_vert
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN123@merge_vert:
	push	eax
	push	ebx
	call	DWORD PTR _sym_compose
	add	esp, 8
	test	esi, esi
	je	SHORT $LN127@merge_vert
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN127@merge_vert:
	mov	edx, DWORD PTR _web+216
	mov	DWORD PTR tv710[ebp], eax
	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+784]
	mov	eax, DWORD PTR tv710[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 2873 :        if ( !inverted(e_id) ) /* keep interior vertices with tail */

	test	esi, esi
	jne	$LN29@merge_vert

; 2874 :        { if ( web.modeltype == QUADRATIC )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	SHORT $LN34@merge_vert

; 2875 :          { vertex_id midv = get_edge_midv(e_id);
; 2876 :            REAL *midx = get_coord(midv);

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [edi+ecx]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	edx, DWORD PTR [edx+eax+8]
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+104
	add	eax, DWORD PTR [edx+ecx+64]

; 2877 :            (*sym_wrap)(midx,midx,invwrap);

	push	ebx
	push	eax
	push	eax
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN29@merge_vert
$LN34@merge_vert:

; 2878 :          }
; 2879 :          else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	SHORT $LN29@merge_vert

; 2880 :          { vertex_id *v = get_edge_vertices(e_id);

	mov	eax, DWORD PTR _web+124
	mov	edi, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	add	edi, DWORD PTR [ecx+edx+304]

; 2881 :            for ( i = 1 ; i < web.lagrange_order ; i++ )

	mov	esi, 1
	cmp	DWORD PTR _web+632, esi
	jle	SHORT $LN29@merge_vert
	npad	4
$LL210@merge_vert:

; 2882 :            { REAL *vx = get_coord(v[i]);

	mov	eax, DWORD PTR [edi+esi*4]
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+64]

; 2883 :              (*sym_wrap)(vx,vx,invwrap);

	push	ebx
	push	eax
	push	eax
	call	DWORD PTR _sym_wrap
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR _web+632
	jl	SHORT $LL210@merge_vert
$LN29@merge_vert:

; 2884 :            }
; 2885 :          }
; 2886 :        }
; 2887 :      }
; 2888 :      if ( ++nn > web.skel[EDGE].count )

	mov	eax, DWORD PTR _nn$[ebp]
	inc	eax
	mov	DWORD PTR _nn$[ebp], eax
	cmp	eax, DWORD PTR _web+176
	jg	SHORT $LN194@merge_vert

; 2860 :  found_match: ;
; 2861 : 
; 2862 : 
; 2863 :   }
; 2864 :    /* change all references to the eliminated vertex to the kept vertex. */
; 2865 :    for (;;)
; 2866 :    { e_id = get_vertex_edge(throwv);

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR tv1486[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR [ecx+28]

; 2867 :      if ( !valid_id(e_id) ) break;

	test	esi, 268435456				; 10000000H
	jne	$LL39@merge_vert
	jmp	SHORT $LN219@merge_vert
$LN194@merge_vert:

; 2889 :      { sprintf(errmsg,"Internal error: Bad edge loop on vertex %s.\n",
; 2890 :           ELNAME(throwv));

	test	DWORD PTR _throwv$GSCopy$[ebp], 268435456 ; 10000000H
	je	SHORT $LN71@merge_vert
	mov	edx, DWORD PTR tv1486[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN72@merge_vert
$LN71@merge_vert:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN72@merge_vert:
	push	eax
	push	OFFSET ??_C@_0CN@CGONHFJB@Internal?5error?3?5Bad?5edge?5loop?5on@
	push	OFFSET _errmsg
	call	_sprintf

; 2891 :        kb_error(3884,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	3884					; 00000f2cH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN219@merge_vert:

; 2892 :        break;
; 2893 :      }
; 2894 :    }
; 2895 :  
; 2896 :    /* fix up facetedge links in string model */
; 2897 :    if ( (web.representation == STRING) && valid_id(match_f) )

	cmp	DWORD PTR _web+624, 1
	mov	esi, DWORD PTR _web+460
	jne	$LN3@merge_vert
	test	DWORD PTR _match_f$[ebp], 268435456	; 10000000H
	je	$LN3@merge_vert

; 2898 :    { /* find common face four of the facetedges have in common */
; 2899 :      facetedge_id prev_k = get_prev_edge(match_kfe);

	mov	eax, DWORD PTR _match_kfe$[ebp]
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR tv1750[ebp], ecx
	je	SHORT $LN130@merge_vert
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN226@merge_vert
$LN130@merge_vert:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [edx+28]
$LN226@merge_vert:

; 2900 :      facetedge_id prev_t = get_prev_edge(match_tfe);

	mov	ebx, DWORD PTR _match_tfe$[ebp]
	mov	DWORD PTR _prev_k$91381[ebp], eax
	mov	eax, ebx
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv1765[ebp], eax
	mov	edi, ebx
	je	SHORT $LN134@merge_vert
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+esi]
	mov	ecx, DWORD PTR [ecx+32]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN227@merge_vert
$LN134@merge_vert:
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+esi]
	mov	ecx, DWORD PTR [eax+28]
$LN227@merge_vert:

; 2901 :      facetedge_id next_fe,next_ffe;
; 2902 :      int found;
; 2903 :      int fe_counter; /* to prevent infinite loop in case of error */
; 2904 :      int fe_counter_max = 2*web.skel[FACETEDGE].count;

	mov	eax, DWORD PTR _web+512
	add	eax, eax
	mov	DWORD PTR _fe_counter_max$91387[ebp], eax

; 2905 : 
; 2906 :      set_prev_edge(match_kfe,inverse_id(match_tfe));

	mov	eax, ebx
	xor	eax, 134217728				; 08000000H
	test	DWORD PTR _match_kfe$[ebp], 268435456	; 10000000H
	mov	DWORD PTR tv1768[ebp], edi
	je	SHORT $LN215@merge_vert
	cmp	DWORD PTR tv1750[ebp], 0
	je	SHORT $LN138@merge_vert
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR [edx+32], eax
	jmp	SHORT $LN137@merge_vert
$LN138@merge_vert:
	mov	DWORD PTR [edx+28], eax
$LN137@merge_vert:
	mov	eax, DWORD PTR _global_timestamp
	mov	esi, DWORD PTR _web+460
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN215@merge_vert:

; 2907 :      set_prev_edge(match_tfe,inverse_id(match_kfe));

	mov	eax, DWORD PTR _match_kfe$[ebp]
	mov	edx, ebx
	shr	edx, 28					; 0000001cH
	xor	eax, 134217728				; 08000000H
	and	edx, 1
	mov	DWORD PTR tv1788[ebp], edx
	je	SHORT $LN220@merge_vert
	cmp	DWORD PTR tv1765[ebp], 0
	mov	edx, DWORD PTR [edi+esi]
	je	SHORT $LN143@merge_vert
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR [edx+32], eax
	jmp	SHORT $LN142@merge_vert
$LN143@merge_vert:
	mov	DWORD PTR [edx+28], eax
$LN142@merge_vert:
	mov	eax, DWORD PTR _global_timestamp
	mov	esi, DWORD PTR _web+460
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN220@merge_vert:

; 2908 :      if ( valid_id(prev_k) && valid_id(prev_t) )

	mov	edx, DWORD PTR _prev_k$91381[ebp]
	test	edx, 268435456				; 10000000H
	je	$LN3@merge_vert
	test	ecx, 268435456				; 10000000H
	je	$LN3@merge_vert

; 2909 :      {
; 2910 :        set_next_edge(prev_k,inverse_id(prev_t));

	mov	eax, ecx
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR tv1797[ebp], eax
	mov	edi, edx
	test	edx, 134217728				; 08000000H
	je	SHORT $LN148@merge_vert
	xor	eax, 134217728				; 08000000H
	and	edi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+edi*4]
	mov	DWORD PTR [esi+28], eax
	jmp	SHORT $LN147@merge_vert
$LN148@merge_vert:
	and	edi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+edi*4]
	mov	DWORD PTR [esi+32], eax
$LN147@merge_vert:

; 2911 :        set_next_edge(prev_t,inverse_id(prev_k));

	mov	eax, edx
	mov	edx, DWORD PTR _web+460
	xor	eax, 134217728				; 08000000H
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN153@merge_vert
	xor	eax, 134217728				; 08000000H
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN152@merge_vert
$LN153@merge_vert:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+32], eax
$LN152@merge_vert:

; 2912 :     
; 2913 :        /* see if we need to make a new facet */
; 2914 :        next_fe = match_kfe;
; 2915 :        found = 0;
; 2916 :        fe_counter = 0;

	mov	edx, DWORD PTR _prev_k$91381[ebp]
	mov	edi, DWORD PTR _match_kfe$[ebp]
	mov	ecx, DWORD PTR _web+460
	xor	ebx, ebx
	or	edx, 134217728				; 08000000H
	mov	DWORD PTR _found$91385[ebp], ebx
	mov	DWORD PTR tv1826[ebp], edx
$LL25@merge_vert:

; 2917 :        do
; 2918 :        { if ( equal_element(next_fe,prev_k) )

	mov	eax, edi
	or	eax, 134217728				; 08000000H
	cmp	eax, edx
	je	SHORT $LN195@merge_vert

; 2920 :          next_ffe = get_next_edge(next_fe);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN158@merge_vert
	and	edi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR [esi+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN157@merge_vert
$LN158@merge_vert:
	and	edi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR [esi+32]
$LN157@merge_vert:

; 2921 :          if ( equal_element(next_fe,next_ffe) ) 

	mov	esi, edi
	or	esi, 134217728				; 08000000H
	cmp	eax, esi
	je	SHORT $LN23@merge_vert

; 2922 :            break;
; 2923 :          next_fe = next_ffe;
; 2924 :          if ( fe_counter++ > fe_counter_max )

	mov	eax, ebx
	inc	ebx
	cmp	eax, DWORD PTR _fe_counter_max$91387[ebp]
	jle	SHORT $LN24@merge_vert

; 2925 :                kb_error(3616,"Internal error - unclosed facetedge loop\n",
; 2926 :                                RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CK@LJEGLNGI@Internal?5error?5?9?5unclosed?5facete@
	push	3616					; 00000e20H
	call	_kb_error
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR tv1826[ebp]
	add	esp, 12					; 0000000cH
$LN24@merge_vert:

; 2927 :        } while ( !equal_element(next_fe,match_kfe) );

	mov	eax, DWORD PTR _match_kfe$[ebp]
	or	eax, 134217728				; 08000000H
	cmp	esi, eax
	jne	SHORT $LL25@merge_vert
	jmp	SHORT $LN23@merge_vert
$LN195@merge_vert:

; 2919 :          { found = 1;  break; }

	mov	DWORD PTR _found$91385[ebp], 1
$LN23@merge_vert:

; 2928 :        next_fe = match_tfe; /* try the other way */

	mov	edi, DWORD PTR _match_tfe$[ebp]

; 2929 :        fe_counter = 0;

	xor	ebx, ebx

; 2930 :        if ( !found )

	cmp	DWORD PTR _found$91385[ebp], ebx
	jne	$LN3@merge_vert
	npad	2
$LL18@merge_vert:

; 2931 :        do
; 2932 :        { if ( equal_element(next_fe,prev_k) )

	mov	eax, edi
	or	eax, 134217728				; 08000000H
	cmp	eax, edx
	je	$LN3@merge_vert

; 2933 :          { found = 1;  break; }
; 2934 :          next_ffe = get_next_edge(next_fe);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN162@merge_vert
	and	edi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR [esi+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN161@merge_vert
$LN162@merge_vert:
	and	edi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR [esi+32]
$LN161@merge_vert:

; 2935 :          if ( equal_element(next_fe,next_ffe) ) 

	mov	esi, edi
	or	esi, 134217728				; 08000000H
	cmp	eax, esi
	je	SHORT $LN208@merge_vert

; 2936 :            break;
; 2937 :          next_fe = next_ffe;
; 2938 :          if ( fe_counter++ > fe_counter_max )

	mov	eax, ebx
	inc	ebx
	cmp	eax, DWORD PTR _fe_counter_max$91387[ebp]
	jle	SHORT $LN17@merge_vert

; 2939 :                kb_error(3613,"Internal error - unclosed facetedge loop\n",
; 2940 :                                RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CK@LJEGLNGI@Internal?5error?5?9?5unclosed?5facete@
	push	3613					; 00000e1dH
	call	_kb_error
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR tv1826[ebp]
	add	esp, 12					; 0000000cH
$LN17@merge_vert:

; 2941 :        } while ( !equal_element(next_fe,match_kfe) );

	mov	eax, DWORD PTR _match_kfe$[ebp]
	or	eax, 134217728				; 08000000H
	cmp	esi, eax
	jne	SHORT $LL18@merge_vert
$LN208@merge_vert:

; 2942 :        if ( !found )
; 2943 :        { /* have to create new facet */
; 2944 :          facet_id newf = dup_facet(match_f);

	mov	ecx, DWORD PTR _match_f$[ebp]
	push	ecx
	call	_dup_facet

; 2945 :          set_facet_fe(newf,prev_k);

	mov	esi, DWORD PTR _prev_k$91381[ebp]
	push	esi
	push	eax
	mov	DWORD PTR _newf$91406[ebp], eax
	call	_set_facet_fe
	add	esp, 12					; 0000000cH

; 2946 :          set_facet_fe(get_fe_facet(match_tfe),match_tfe); /*make sure match_f has valid fe */

	cmp	DWORD PTR tv1788[ebp], 0
	jne	SHORT $LN166@merge_vert
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN165@merge_vert
$LN166@merge_vert:
	cmp	DWORD PTR tv1765[ebp], 0
	mov	eax, DWORD PTR tv1768[ebp]
	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [ecx+24]
	je	SHORT $LN165@merge_vert
	xor	eax, 134217728				; 08000000H
$LN165@merge_vert:
	mov	edx, DWORD PTR _match_tfe$[ebp]
	push	edx
	push	eax
	call	_set_facet_fe
	add	esp, 8

; 2947 :          next_fe = prev_k;
; 2948 :          fe_counter = 0;

	xor	ebx, ebx
	npad	4
$LL11@merge_vert:

; 2949 :          do
; 2950 :          { set_fe_facet(next_fe,newf);

	mov	eax, DWORD PTR _newf$91406[ebp]
	push	eax
	push	esi
	call	_set_fe_facet

; 2951 :            next_ffe = get_prev_edge(next_fe);

	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN170@merge_vert
	mov	eax, DWORD PTR [eax+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN169@merge_vert
$LN170@merge_vert:
	mov	eax, DWORD PTR [eax+28]
$LN169@merge_vert:

; 2952 :            if ( equal_element(next_ffe,next_fe) ) 

	mov	edi, eax
	mov	ecx, esi
	or	edi, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	edi, ecx
	je	SHORT $LN9@merge_vert

; 2953 :              break;
; 2954 :            next_fe = next_ffe;
; 2955 :            if ( fe_counter++ > fe_counter_max )

	mov	edx, ebx
	inc	ebx
	mov	esi, eax
	cmp	edx, DWORD PTR _fe_counter_max$91387[ebp]
	jle	SHORT $LN10@merge_vert

; 2956 :                kb_error(2873,"Internal error - unclosed facetedge loop\n",
; 2957 :                                RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CK@LJEGLNGI@Internal?5error?5?9?5unclosed?5facete@
	push	2873					; 00000b39H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN10@merge_vert:

; 2958 :          } while ( !equal_element(next_fe,prev_k));

	cmp	edi, DWORD PTR tv1826[ebp]
	jne	SHORT $LL11@merge_vert
$LN9@merge_vert:

; 2959 :          if ( !equal_element(next_fe,prev_k) )

	mov	eax, esi
	or	eax, 134217728				; 08000000H
	cmp	eax, DWORD PTR tv1826[ebp]
	je	SHORT $LN6@merge_vert

; 2960 :          next_fe = inverse_id(prev_t);

	mov	esi, DWORD PTR tv1797[ebp]
$LN6@merge_vert:

; 2961 :          fe_counter = 0;

	xor	ebx, ebx
	npad	2
$LL5@merge_vert:

; 2962 :          do
; 2963 :          { set_fe_facet(next_fe,newf);

	mov	ecx, DWORD PTR _newf$91406[ebp]
	push	ecx
	push	esi
	call	_set_fe_facet

; 2964 :            next_ffe = get_next_edge(next_fe);

	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN174@merge_vert
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN173@merge_vert
$LN174@merge_vert:
	mov	eax, DWORD PTR [ecx+32]
$LN173@merge_vert:

; 2965 :            if ( equal_element(next_ffe,next_fe) ) 

	mov	edi, eax
	or	edi, 134217728				; 08000000H
	or	esi, 134217728				; 08000000H
	cmp	edi, esi
	je	SHORT $LN3@merge_vert

; 2966 :              break;
; 2967 :            next_fe = next_ffe;
; 2968 :            if ( fe_counter++ > fe_counter_max )

	mov	edx, ebx
	inc	ebx
	mov	esi, eax
	cmp	edx, DWORD PTR _fe_counter_max$91387[ebp]
	jle	SHORT $LN4@merge_vert

; 2969 :                kb_error(3621,"Internal error - unclosed facetedge loop\n",
; 2970 :                                RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CK@LJEGLNGI@Internal?5error?5?9?5unclosed?5facete@
	push	3621					; 00000e25H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN4@merge_vert:

; 2971 :          } while ( !equal_element(next_fe,prev_k));

	cmp	edi, DWORD PTR tv1826[ebp]
	jne	SHORT $LL5@merge_vert
$LN3@merge_vert:

; 2972 :        }
; 2973 :      }
; 2974 :    }
; 2975 :    free_element(throwv);

	mov	eax, DWORD PTR _throwv$GSCopy$[ebp]
	push	eax
	call	_free_element

; 2976 :   
; 2977 : } // end merge_vertex()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 4
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_merge_vertex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@EFDMLKJL@merge_edge?5called?5with?5identical@ ; `string'
PUBLIC	??_C@_0CJ@DECLFGI@merge_edge?5only?5in?5LINEAR?5model?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_merge_edge
EXTRN	_raw_fe_reorder:PROC
;	COMDAT ??_C@_0CJ@EFDMLKJL@merge_edge?5called?5with?5identical@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CJ@EFDMLKJL@merge_edge?5called?5with?5identical@ DB 'merge_edge ca'
	DB	'lled with identical edges.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DECLFGI@merge_edge?5only?5in?5LINEAR?5model?5@
CONST	SEGMENT
??_C@_0CJ@DECLFGI@merge_edge?5only?5in?5LINEAR?5model?5@ DB 'merge_edge o'
	DB	'nly in LINEAR model so far.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _merge_edge
_TEXT	SEGMENT
_ffe$ = -104						; size = 4
_side1$ = -100						; size = 48
_side2$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id1$ = 8						; size = 4
_e_id2$ = 12						; size = 4
_merge_edge PROC					; COMDAT

; 3001 : { facetedge_id fe_start,fe,ffe,fep,ffep;

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3002 :   vertex_id t1,t2,h1,h2;
; 3003 :   REAL side1[MAXCOORD],side2[MAXCOORD];
; 3004 : 
; 3005 :   if ( web.modeltype != LINEAR )

	cmp	DWORD PTR _web+628, 1
	je	SHORT $LN18@merge_edge

; 3006 :     kb_error(2894,"merge_edge only in LINEAR model so far.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CJ@DECLFGI@merge_edge?5only?5in?5LINEAR?5model?5@
	push	2894					; 00000b4eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN18@merge_edge:

; 3007 :   
; 3008 :   if ( equal_id(e_id1,e_id2) )

	push	ebx
	mov	ebx, DWORD PTR _e_id2$[ebp]
	push	edi
	mov	edi, DWORD PTR _e_id1$[ebp]
	cmp	edi, ebx
	jne	SHORT $LN17@merge_edge

; 3009 :   { kb_error(3887,"merge_edge called with identical edges.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CJ@EFDMLKJL@merge_edge?5called?5with?5identical@
	push	3887					; 00000f2fH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx

; 3069 : } // end merge_edge()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@merge_edge:

; 3010 :     return;
; 3011 :   }
; 3012 :  
; 3013 :   if ( web.symmetry_flag && !web.torus_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN16@merge_edge
	cmp	DWORD PTR _web+860, 0
	jne	SHORT $LN16@merge_edge

; 3014 :   { kb_error(3888,"vertex_merge can't handle wraps in non-torus symmetries.\n",
; 3015 :       RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DK@ELKKFNHN@vertex_merge?5can?8t?5handle?5wraps?5@
	push	3888					; 00000f30H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN16@merge_edge:

; 3016 :   }
; 3017 : 
; 3018 :   /* orient as parallel as possible */
; 3019 :   if ( equal_id(get_edge_tailv(e_id1),get_edge_tailv(e_id2))
; 3020 :     || equal_id(get_edge_headv(e_id1),get_edge_headv(e_id2)) )

	push	esi
	push	edi
	call	_get_edge_tailv
	push	ebx
	mov	esi, eax
	call	_get_edge_tailv
	add	esp, 8
	cmp	esi, eax
	je	$LN49@merge_edge
	push	edi
	call	_get_edge_headv
	push	ebx
	mov	esi, eax
	call	_get_edge_headv
	add	esp, 8
	cmp	esi, eax
	je	SHORT $LN49@merge_edge

; 3021 :   { /* ok */
; 3022 :   }
; 3023 :   else 
; 3024 :   if ( equal_id(get_edge_tailv(e_id1),get_edge_headv(e_id2))
; 3025 :     || equal_id(get_edge_headv(e_id1),get_edge_tailv(e_id2)) )

	push	edi
	call	_get_edge_tailv
	push	ebx
	mov	esi, eax
	call	_get_edge_headv
	add	esp, 8
	cmp	esi, eax
	je	SHORT $LN11@merge_edge
	push	edi
	call	_get_edge_headv
	push	ebx
	mov	esi, eax
	call	_get_edge_tailv
	add	esp, 8
	cmp	esi, eax
	je	SHORT $LN11@merge_edge

; 3027 :   }
; 3028 :   else 
; 3029 :   { /* try geometric alignment */
; 3030 :     get_edge_side(e_id1,side1);

	lea	eax, DWORD PTR _side1$[ebp]
	push	eax
	push	edi
	call	_get_edge_side

; 3031 :     get_edge_side(e_id2,side2);

	lea	ecx, DWORD PTR _side2$[ebp]
	push	ecx
	push	ebx
	call	_get_edge_side

; 3032 :     if ( dot(side1,side2,SDIM) < 0 )

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _side2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _side1$[ebp]
	push	ecx
	call	_dot
	fcomp	QWORD PTR __real@0000000000000000
	add	esp, 28					; 0000001cH
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN49@merge_edge
$LN11@merge_edge:

; 3026 :   { invert(e_id2);

	xor	ebx, 134217728				; 08000000H
	mov	DWORD PTR _e_id2$[ebp], ebx
$LN49@merge_edge:

; 3033 :       invert(e_id2);
; 3034 :   }
; 3035 : 
; 3036 :    
; 3037 :   t1 = get_edge_tailv(e_id1);

	push	edi
	call	_get_edge_tailv

; 3038 :   t2 = get_edge_tailv(e_id2);

	push	ebx
	mov	esi, eax
	call	_get_edge_tailv
	add	esp, 8

; 3039 :   if ( !equal_id(t1,t2) )

	cmp	esi, eax
	je	SHORT $LN8@merge_edge

; 3040 :     merge_vertex(t1,t2);

	push	eax
	push	esi
	call	_merge_vertex
	add	esp, 8
$LN8@merge_edge:

; 3041 :   h1 = get_edge_headv(e_id1);

	push	edi
	call	_get_edge_headv

; 3042 :   h2 = get_edge_headv(e_id2);

	push	ebx
	mov	esi, eax
	call	_get_edge_headv
	add	esp, 8

; 3043 :   if ( !equal_id(h1,h2) )

	cmp	esi, eax
	je	SHORT $LN7@merge_edge

; 3044 :     merge_vertex(h1,h2);

	push	eax
	push	esi
	call	_merge_vertex
	add	esp, 8
$LN7@merge_edge:

; 3045 : 
; 3046 :   /* now transfer facetedges */
; 3047 :   fe = fe_start = get_edge_fe(e_id2);

	mov	eax, DWORD PTR _web+124
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	jne	SHORT $LN22@merge_edge
	xor	ebx, ebx
	jmp	SHORT $LN23@merge_edge
$LN22@merge_edge:
	mov	eax, DWORD PTR [eax+28]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN21@merge_edge
	xor	eax, 134217728				; 08000000H
$LN21@merge_edge:
	mov	ebx, eax
$LN23@merge_edge:

; 3048 :   if ( valid_id(fe_start) )

	mov	edx, DWORD PTR _web+460
	mov	esi, ebx
	test	ebx, 268435456				; 10000000H
	je	SHORT $LN3@merge_edge
$LL5@merge_edge:

; 3049 :     do 
; 3050 :     { set_fe_edge(fe,e_id1);

	mov	eax, esi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	ecx, edi
	je	SHORT $LN25@merge_edge
	xor	ecx, 134217728				; 08000000H
$LN25@merge_edge:
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [edx+20], ecx
	mov	ecx, DWORD PTR _global_timestamp

; 3051 :       fe = get_next_facet(fe);

	mov	edx, DWORD PTR _web+460
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
	test	eax, eax
	je	SHORT $LN29@merge_edge
	mov	eax, DWORD PTR [esi+edx]
	mov	esi, DWORD PTR [eax+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN4@merge_edge
$LN29@merge_edge:
	mov	ecx, DWORD PTR [esi+edx]
	mov	esi, DWORD PTR [ecx+40]
$LN4@merge_edge:

; 3052 :     } while ( !equal_id(fe,fe_start) );

	cmp	esi, ebx
	jne	SHORT $LL5@merge_edge
$LN3@merge_edge:

; 3053 : 
; 3054 :   ffe = get_edge_fe(e_id1);

	mov	ecx, DWORD PTR _web+124
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	test	ecx, ecx
	jne	SHORT $LN33@merge_edge
	xor	eax, eax
	mov	DWORD PTR _ffe$[ebp], eax
	jmp	SHORT $LN34@merge_edge
$LN33@merge_edge:
	mov	eax, DWORD PTR [ecx+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN32@merge_edge
	xor	eax, 134217728				; 08000000H
$LN32@merge_edge:
	mov	DWORD PTR _ffe$[ebp], eax
$LN34@merge_edge:

; 3055 :   if ( valid_id(ffe) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN2@merge_edge

; 3056 :   { fep = get_next_facet(fe);

	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN37@merge_edge
	mov	ebx, DWORD PTR [ecx+36]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN36@merge_edge
$LN37@merge_edge:
	mov	ebx, DWORD PTR [ecx+40]
$LN36@merge_edge:

; 3057 :     ffep = get_prev_facet(ffe);

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN41@merge_edge
	mov	edi, DWORD PTR [edx+40]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN40@merge_edge
$LN41@merge_edge:
	mov	edi, DWORD PTR [edx+36]
$LN40@merge_edge:

; 3058 :     set_next_facet(fe,ffe);

	push	eax
	push	esi
	call	_set_next_facet

; 3059 :     set_prev_facet(ffe,fe);

	mov	eax, DWORD PTR _ffe$[ebp]
	push	esi
	push	eax
	call	_set_prev_facet

; 3060 :     set_next_facet(ffep,fep);

	push	ebx
	push	edi
	call	_set_next_facet

; 3061 :     set_prev_facet(fep,ffep);

	push	edi
	push	ebx
	call	_set_prev_facet

; 3062 :   }
; 3063 :   else

	mov	edi, DWORD PTR _e_id1$[ebp]
	add	esp, 32					; 00000020H
	jmp	SHORT $LN45@merge_edge
$LN2@merge_edge:

; 3064 :     set_edge_fe(e_id1,fe_start);

	mov	eax, ebx
	test	edi, 134217728				; 08000000H
	je	SHORT $LN44@merge_edge
	xor	ebx, 134217728				; 08000000H
	mov	eax, ebx
$LN44@merge_edge:
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN45@merge_edge:

; 3065 : 
; 3066 :   raw_fe_reorder(e_id1);  /* for proper geometrical order */

	push	edi
	call	_raw_fe_reorder

; 3067 : 
; 3068 :   free_element(e_id2);  /* also removes from vertex lists */

	mov	ecx, DWORD PTR _e_id2$[ebp]
	push	ecx
	call	_free_element

; 3069 : } // end merge_edge()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 8
	pop	esi
	pop	edi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_merge_edge ENDP
_TEXT	ENDS
PUBLIC	__real@46293e5939a08cea
PUBLIC	??_C@_0EG@KHGMFCDA@Cannot?5get?5body?5agreement?5for?5me@ ; `string'
PUBLIC	??_C@_0DJ@GEGBFFIN@facet_merge?5can?8t?5handle?5wraps?5i@ ; `string'
PUBLIC	??_C@_0CL@CNLICOFC@facet_merge?5called?5with?5identica@ ; `string'
PUBLIC	??_C@_0CK@FDBHDHLM@facet_merge?5only?5in?5LINEAR?5model@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_merge_facet
EXTRN	_torus_wrap:PROC
EXTRN	_get_facet_verts:PROC
;	COMDAT __real@46293e5939a08cea
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@46293e5939a08cea DQ 046293e5939a08cear	; 1e+030
CONST	ENDS
;	COMDAT ??_C@_0EG@KHGMFCDA@Cannot?5get?5body?5agreement?5for?5me@
CONST	SEGMENT
??_C@_0EG@KHGMFCDA@Cannot?5get?5body?5agreement?5for?5me@ DB 'Cannot get '
	DB	'body agreement for merging facets %s and %s; not merging.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@GEGBFFIN@facet_merge?5can?8t?5handle?5wraps?5i@
CONST	SEGMENT
??_C@_0DJ@GEGBFFIN@facet_merge?5can?8t?5handle?5wraps?5i@ DB 'facet_merge'
	DB	' can''t handle wraps in non-torus symmetries.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CNLICOFC@facet_merge?5called?5with?5identica@
CONST	SEGMENT
??_C@_0CL@CNLICOFC@facet_merge?5called?5with?5identica@ DB 'facet_merge c'
	DB	'alled with identical facets.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FDBHDHLM@facet_merge?5only?5in?5LINEAR?5model@
CONST	SEGMENT
??_C@_0CK@FDBHDHLM@facet_merge?5only?5in?5LINEAR?5model@ DB 'facet_merge '
	DB	'only in LINEAR model so far.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _merge_facet
_TEXT	SEGMENT
_f2xqXvS$ = -632					; size = 12
_tempxqXvS$ = -620					; size = 12
_f1xqXvS$ = -608					; size = 12
_bestdistt$91559 = -596					; size = 8
tv1611 = -592						; size = 4
_bestdist$ = -588					; size = 8
tv2557 = -584						; size = 4
tv1618 = -584						; size = 4
tv1592 = -584						; size = 4
_f2x$ = -580						; size = 4
_dist$91563 = -576					; size = 8
_dist$91547 = -576					; size = 8
tv2561 = -572						; size = 4
tv1575 = -572						; size = 4
tv479 = -572						; size = 4
tv321 = -572						; size = 4
_f1x$ = -568						; size = 4
_e_id2$91583 = -564					; size = 4
_cor$91568 = -564					; size = 4
_cor$91552 = -564					; size = 4
_tempx$ = -564						; size = 4
tv3410 = -560						; size = 4
tv1637 = -560						; size = 4
_edge_match$ = -560					; size = 4
tv1608 = -556						; size = 4
_body_restricted$ = -556				; size = 4
_besti$ = -552						; size = 4
tv1704 = -548						; size = 4
_j$ = -548						; size = 4
_b1_front$ = -544					; size = 4
_fe2$ = -544						; size = 4
_b2_front$ = -540					; size = 4
_i$ = -540						; size = 4
_b1_back$ = -536					; size = 4
_fe1$ = -536						; size = 4
_f1xxJ$ = -532						; size = 144
_f2xxJ$ = -388						; size = 144
_tempxxJ$ = -244					; size = 144
_u$91531 = -100						; size = 48
_z$91530 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_f_id1$ = 8						; size = 4
_f_id2$ = 12						; size = 4
_merge_facet PROC					; COMDAT

; 3087 : { MAT2D(f1x,FACET_VERTS,MAXCOORD);

	push	ebp
	mov	ebp, esp
	sub	esp, 632				; 00000278H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	6
	push	3
	lea	eax, DWORD PTR _f1xxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _f1xqXvS$[ebp]
	push	ecx
	call	_mat2d_setup

; 3088 :   MAT2D(f2x,FACET_VERTS,MAXCOORD);

	push	6
	push	3
	lea	edx, DWORD PTR _f2xxJ$[ebp]
	mov	DWORD PTR _f1x$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _f2xqXvS$[ebp]
	push	eax
	call	_mat2d_setup

; 3089 :   MAT2D(tempx,FACET_VERTS,MAXCOORD);

	push	6
	push	3
	lea	ecx, DWORD PTR _tempxxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tempxqXvS$[ebp]
	push	edx
	mov	DWORD PTR _f2x$[ebp], eax
	call	_mat2d_setup

; 3090 :   int wrap,i;
; 3091 :   facetedge_id fe1,fe2;
; 3092 :   body_id b_id;
; 3093 :   REAL bestdist;
; 3094 :   int besti,edge_match;
; 3095 :   int j,k;
; 3096 :   body_id b1_front,b1_back,b2_front,b2_back;
; 3097 :   int  body_restricted = 0;  /* 1 if only one way to match bodies */

	xor	esi, esi
	add	esp, 48					; 00000030H

; 3098 :   
; 3099 :   if ( web.modeltype != LINEAR )

	cmp	DWORD PTR _web+628, 1
	mov	DWORD PTR _tempx$[ebp], eax
	mov	DWORD PTR _body_restricted$[ebp], esi
	je	SHORT $LN74@merge_face

; 3100 :     kb_error(3881,"facet_merge only in LINEAR model so far.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CK@FDBHDHLM@facet_merge?5only?5in?5LINEAR?5model@
	push	3881					; 00000f29H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN74@merge_face:

; 3101 :   
; 3102 :   if ( equal_element(f_id1,f_id2) )

	mov	edi, DWORD PTR _f_id1$[ebp]
	mov	ecx, DWORD PTR _f_id2$[ebp]
	mov	eax, edi
	or	eax, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	eax, ecx
	jne	SHORT $LN73@merge_face

; 3103 :   { kb_error(3889,"facet_merge called with identical facets.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CL@CNLICOFC@facet_merge?5called?5with?5identica@
	push	3889					; 00000f31H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 3286 : 
; 3287 : }  /* end merge_facet() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@merge_face:

; 3104 :     return;
; 3105 :   }
; 3106 :  
; 3107 :   if ( web.symmetry_flag && !web.torus_flag )

	cmp	DWORD PTR _web+856, esi
	je	SHORT $LN72@merge_face
	cmp	DWORD PTR _web+860, esi
	jne	SHORT $LN72@merge_face

; 3108 :   { kb_error(3915,"facet_merge can't handle wraps in non-torus symmetries.\n",
; 3109 :       RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DJ@GEGBFFIN@facet_merge?5can?8t?5handle?5wraps?5i@
	push	3915					; 00000f4bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN72@merge_face:

; 3110 :   }
; 3111 : 
; 3112 :   /* figure best correspondence of vertices */
; 3113 :   /* First, see if any identical vertices */
; 3114 :   besti = -1;
; 3115 :   edge_match = 0;
; 3116 :   fe1 = get_facet_fe(f_id1);

	mov	eax, edi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv1575[ebp], eax
	mov	eax, DWORD PTR _web+236
	mov	DWORD PTR _besti$[ebp], -1
	mov	DWORD PTR _edge_match$[ebp], esi
	jne	SHORT $LN86@merge_face
	xor	edx, edx
	jmp	SHORT $LN85@merge_face
$LN86@merge_face:
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN85@merge_face
	xor	edx, 134217728				; 08000000H
$LN85@merge_face:
	mov	DWORD PTR _fe1$[ebp], edx
	push	ebx

; 3117 :   for ( i = 0 ; (i < FACET_VERTS) && !edge_match ; i++ )

	mov	DWORD PTR _i$[ebp], esi
	npad	11
$LL301@merge_face:
	cmp	DWORD PTR _edge_match$[ebp], 0
	mov	esi, DWORD PTR _dymem
	mov	ebx, DWORD PTR _web+216
	jne	$LN69@merge_face

; 3118 :   { fe2 = get_facet_fe(f_id2); 

	mov	ecx, DWORD PTR _f_id2$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN90@merge_face
	xor	eax, eax
	jmp	SHORT $LN89@merge_face
$LN90@merge_face:
	mov	edi, ecx
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN89@merge_face
	xor	eax, 134217728				; 08000000H
$LN89@merge_face:

; 3119 :     for ( j = 0 ; j < FACET_VERTS ; j++ )

	mov	edi, DWORD PTR _web+460
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _web+124
	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR tv1611[ebp], ecx

; 3120 :     { if ( equal_id(get_fe_tailv(fe1),get_fe_tailv(fe2)) )

	mov	ecx, edx
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR _fe2$[ebp], eax
	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR tv1618[ebp], ecx
	jmp	SHORT $LN68@merge_face
	npad	7
$LL260@merge_face:

; 3118 :   { fe2 = get_facet_fe(f_id2); 

	mov	ecx, DWORD PTR tv1618[ebp]
	mov	ebx, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
$LN68@merge_face:

; 3120 :     { if ( equal_id(get_fe_tailv(fe1),get_fe_tailv(fe2)) )

	test	ecx, ecx
	mov	ecx, DWORD PTR [ebx+esi+304]
	mov	esi, edx
	je	SHORT $LN96@merge_face
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR _web+636
	lea	esi, DWORD PTR [esi+edi*4]
	mov	ebx, DWORD PTR [esi+ecx]
	jmp	SHORT $LN95@merge_face
$LN96@merge_face:
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	mov	ebx, DWORD PTR [ecx+esi]
$LN95@merge_face:
	mov	edi, DWORD PTR _web+460
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR _web+124
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [esi+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN102@merge_face
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+edi*4]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	edi, DWORD PTR _web+124
	jmp	SHORT $LN101@merge_face
$LN102@merge_face:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [ecx+eax]
$LN101@merge_face:
	cmp	ebx, ecx
	je	SHORT $LN224@merge_face

; 3133 :         break;
; 3134 :       }
; 3135 :       fe2 = get_next_edge(fe2);

	test	DWORD PTR _fe2$[ebp], 134217728		; 08000000H
	je	SHORT $LN106@merge_face
	mov	eax, DWORD PTR [esi+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN302@merge_face
$LN106@merge_face:
	mov	eax, DWORD PTR [esi+32]
$LN302@merge_face:

; 3119 :     for ( j = 0 ; j < FACET_VERTS ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	inc	ecx

; 3133 :         break;
; 3134 :       }
; 3135 :       fe2 = get_next_edge(fe2);

	mov	DWORD PTR _fe2$[ebp], eax
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, 3
	jl	$LL260@merge_face

; 3120 :     { if ( equal_id(get_fe_tailv(fe1),get_fe_tailv(fe2)) )

	mov	ecx, DWORD PTR _i$[ebp]
	jmp	SHORT $LN261@merge_face
$LN224@merge_face:

; 3121 :       { int newbesti =  j >= i ? j - i : j - i + 3;

	mov	esi, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, esi
	sub	eax, ecx
	cmp	esi, ecx
	jge	SHORT $LN78@merge_face
	add	eax, 3
$LN78@merge_face:

; 3122 :         if ( besti >= 0 )

	mov	edx, DWORD PTR _besti$[ebp]
	test	edx, edx
	js	SHORT $LN64@merge_face

; 3123 :         { edge_match = 1;

	mov	DWORD PTR _edge_match$[ebp], 1

; 3124 :           if ( besti != newbesti )

	cmp	edx, eax
	je	SHORT $LN261@merge_face

; 3125 :           /* have to reverse relative facet orientation */
; 3126 :           { invert(f_id2);
; 3127 :             j = (4 - j) % 3;

	mov	eax, 4
	sub	eax, esi
	cdq
	mov	esi, 3
	idiv	esi
	xor	DWORD PTR _f_id2$[ebp], 134217728	; 08000000H

; 3128 :             besti =  j >= i ? j - i : j - i + 3;

	cmp	edx, ecx
	jl	SHORT $LN79@merge_face
	sub	edx, ecx
	mov	DWORD PTR _besti$[ebp], edx
	jmp	SHORT $LN261@merge_face
$LN79@merge_face:
	sub	edx, ecx
	add	edx, esi
	mov	DWORD PTR _besti$[ebp], edx

; 3129 :           }
; 3130 :         }
; 3131 :         else 

	jmp	SHORT $LN261@merge_face
$LN64@merge_face:

; 3132 :            besti = newbesti;

	mov	DWORD PTR _besti$[ebp], eax
$LN261@merge_face:

; 3136 :     }
; 3137 :     fe1 = get_next_edge(fe1);

	test	DWORD PTR _fe1$[ebp], 134217728		; 08000000H
	je	SHORT $LN110@merge_face
	mov	edx, DWORD PTR tv1611[ebp]
	mov	edx, DWORD PTR [edx+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN303@merge_face
$LN110@merge_face:
	mov	eax, DWORD PTR tv1611[ebp]
	mov	edx, DWORD PTR [eax+32]
$LN303@merge_face:

; 3117 :   for ( i = 0 ; (i < FACET_VERTS) && !edge_match ; i++ )

	mov	edi, DWORD PTR _f_id1$[ebp]
	mov	eax, DWORD PTR _web+236
	inc	ecx

; 3136 :     }
; 3137 :     fe1 = get_next_edge(fe1);

	mov	DWORD PTR _fe1$[ebp], edx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, 3
	jl	$LL301@merge_face

; 3117 :   for ( i = 0 ; (i < FACET_VERTS) && !edge_match ; i++ )

	mov	esi, DWORD PTR _dymem
$LN69@merge_face:

; 3138 :   }
; 3139 : 
; 3140 :   /* see if body information is enough to specify direction */
; 3141 :   b1_front = get_facet_body(f_id1);

	mov	ebx, DWORD PTR _web+328
	xor	ecx, ecx
	cmp	DWORD PTR _web+400, ecx
	jne	SHORT $LN116@merge_face
	mov	DWORD PTR _b1_front$[ebp], ecx
	jmp	SHORT $LN113@merge_face
$LN116@merge_face:
	cmp	DWORD PTR tv1575[ebp], ecx
	jne	SHORT $LN115@merge_face
	mov	DWORD PTR _b1_front$[ebp], ecx
	jmp	SHORT $LN113@merge_face
$LN115@merge_face:
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [ebx+esi+784]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN114@merge_face
	mov	edx, DWORD PTR [edx+ecx+4]
	jmp	SHORT $LN304@merge_face
$LN114@merge_face:
	mov	edx, DWORD PTR [edx+ecx]
$LN304@merge_face:
	mov	DWORD PTR _b1_front$[ebp], edx
$LN113@merge_face:

; 3142 :   b1_back = get_facet_body(inverse_id(f_id1));

	mov	ecx, edi
	xor	ecx, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	mov	DWORD PTR tv1704[ebp], ecx
	jne	SHORT $LN122@merge_face
	xor	ecx, ecx
	mov	DWORD PTR _b1_back$[ebp], ecx

; 3143 :   b2_front = get_facet_body(f_id2);

	mov	DWORD PTR _b2_front$[ebp], ecx
	jmp	$LN125@merge_face

; 3142 :   b1_back = get_facet_body(inverse_id(f_id1));

$LN122@merge_face:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN121@merge_face
	mov	DWORD PTR _b1_back$[ebp], 0
	jmp	SHORT $LN128@merge_face
$LN121@merge_face:
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN120@merge_face
	mov	edx, DWORD PTR [ebx+esi+784]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [ecx+edx+4]
	mov	DWORD PTR _b1_back$[ebp], ecx
	jmp	SHORT $LN128@merge_face
$LN120@merge_face:
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [ebx+esi+784]
	mov	edx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _b1_back$[ebp], edx

; 3143 :   b2_front = get_facet_body(f_id2);

$LN128@merge_face:
	mov	ecx, DWORD PTR _f_id2$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN127@merge_face
	mov	DWORD PTR _b2_front$[ebp], 0
	jmp	SHORT $LN125@merge_face
$LN127@merge_face:
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN126@merge_face
	mov	edx, DWORD PTR [ebx+esi+784]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [ecx+edx+4]
	mov	DWORD PTR _b2_front$[ebp], ecx
	jmp	SHORT $LN125@merge_face
$LN126@merge_face:
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [ebx+esi+784]
	mov	edx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _b2_front$[ebp], edx
$LN125@merge_face:

; 3144 :   b2_back = get_facet_body(inverse_id(f_id2));

	mov	ecx, DWORD PTR _f_id2$[ebp]
	xor	ecx, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN134@merge_face
	xor	eax, eax
	jmp	SHORT $LN131@merge_face
$LN134@merge_face:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN133@merge_face
	xor	eax, eax
	jmp	SHORT $LN131@merge_face
$LN133@merge_face:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ebx+esi+784]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN132@merge_face
	mov	eax, DWORD PTR [eax+edx+4]
	jmp	SHORT $LN131@merge_face
$LN132@merge_face:
	mov	eax, DWORD PTR [eax+edx]
$LN131@merge_face:

; 3145 :   if ( !equal_id(b1_front,b2_back) )

	mov	edx, DWORD PTR _b1_front$[ebp]
	cmp	edx, eax
	je	$LN61@merge_face

; 3146 :   { if ( equal_id(b1_front,b2_front) && !edge_match ) 

	mov	esi, DWORD PTR _b2_front$[ebp]
	cmp	edx, esi
	jne	SHORT $LN262@merge_face
	cmp	DWORD PTR _edge_match$[ebp], 0
	jne	SHORT $LN262@merge_face

; 3147 :     {  invert(f_id2);

	mov	DWORD PTR _f_id2$[ebp], ecx

; 3148 :        if ( !equal_id(b1_back,b2_back) )

	cmp	DWORD PTR _b1_back$[ebp], eax
	je	$LN48@merge_face

; 3149 :          body_restricted = 1;
; 3150 :     }  
; 3151 :     else if ( equal_id(b1_back,b2_back) && !edge_match )

	jmp	$LN47@merge_face
$LN262@merge_face:
	mov	ebx, DWORD PTR _b1_back$[ebp]
	cmp	ebx, eax
	jne	SHORT $LN266@merge_face
	cmp	DWORD PTR _edge_match$[ebp], 0
	jne	SHORT $LN266@merge_face

; 3152 :     {  invert(f_id1);

	mov	edi, DWORD PTR tv1704[ebp]
	mov	DWORD PTR _f_id1$[ebp], edi

; 3153 :        if ( !equal_id(b1_front,b2_front) ) 

	cmp	edx, esi
	je	$LN48@merge_face

; 3154 :          body_restricted = 1;
; 3155 :     }
; 3156 :     else if ( equal_id(b1_back,b2_front) ) 

	jmp	$LN47@merge_face
$LN266@merge_face:
	cmp	ebx, esi

; 3166 :       return; 
; 3167 :     }

	je	$LN307@merge_face

; 3157 :     {  invert(f_id1); invert(f_id2); 
; 3158 :        if ( besti >= 0 )
; 3159 :          besti = (3 - besti) % 3;
; 3160 :        body_restricted = 1;
; 3161 :     }
; 3162 :     else
; 3163 :     { sprintf(errmsg,"Cannot get body agreement for merging facets %s and %s; not merging.\n",
; 3164 :            ELNAME(f_id1),ELNAME1(f_id2));

	test	DWORD PTR _f_id2$[ebp], 268435456	; 10000000H
	je	SHORT $LN81@merge_face
	mov	eax, DWORD PTR _f_id2$[ebp]
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN82@merge_face
$LN81@merge_face:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN82@merge_face:
	cmp	DWORD PTR tv1575[ebp], 0
	je	SHORT $LN83@merge_face
	and	edi, 134217727				; 07ffffffH
	inc	edi
	push	edi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN84@merge_face
$LN83@merge_face:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN84@merge_face:
	push	esi
	push	eax
	push	OFFSET ??_C@_0EG@KHGMFCDA@Cannot?5get?5body?5agreement?5for?5me@
	push	OFFSET _errmsg
	call	_sprintf

; 3165 :       kb_error(3896,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	3896					; 00000f38H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	ebx
	pop	edi
	pop	esi

; 3286 : 
; 3287 : }  /* end merge_facet() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@merge_face:

; 3168 :   }
; 3169 :   else if ( !equal_id(b1_back,b2_front) )

	mov	eax, DWORD PTR _b1_back$[ebp]
	cmp	eax, DWORD PTR _b2_front$[ebp]

; 3170 :     body_restricted = 1;

	jne	SHORT $LN47@merge_face

; 3171 :   else if ( !valid_id(b1_back) && valid_id(b1_front) )

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN48@merge_face
	test	edx, 268435456				; 10000000H
	je	SHORT $LN48@merge_face
$LN307@merge_face:

; 3172 :   { invert(f_id1); 
; 3173 :     invert(f_id2); 
; 3174 :     if ( besti >= 0 )

	cmp	DWORD PTR _besti$[ebp], 0
	mov	edi, DWORD PTR tv1704[ebp]
	mov	DWORD PTR _f_id2$[ebp], ecx
	mov	DWORD PTR _f_id1$[ebp], edi
	jl	SHORT $LN47@merge_face

; 3175 :        besti = (3 - besti) % 3;

	mov	eax, 3
	sub	eax, DWORD PTR _besti$[ebp]
	mov	ecx, 3
	cdq
	idiv	ecx
	mov	DWORD PTR _besti$[ebp], edx
$LN47@merge_face:

; 3176 :     body_restricted = 1;

	mov	DWORD PTR _body_restricted$[ebp], 1
$LN48@merge_face:

; 3177 :   }
; 3178 :     
; 3179 :   /* need vertex coordinates for orientation matching and vertex matching */
; 3180 :   get_facet_verts(f_id1,f1x,NULL);  /* follows facet orientation */

	mov	edx, DWORD PTR _f1x$[ebp]
	push	0
	push	edx
	push	edi
	call	_get_facet_verts

; 3181 :   get_facet_verts(f_id2,f2x,NULL);

	mov	eax, DWORD PTR _f2x$[ebp]
	mov	ecx, DWORD PTR _f_id2$[ebp]
	push	0
	push	eax
	push	ecx
	call	_get_facet_verts
	add	esp, 24					; 00000018H

; 3182 :   if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	je	$LN248@merge_face

; 3183 :   { REAL z[MAXCOORD];
; 3184 :     REAL u[MAXCOORD];
; 3185 :   
; 3186 :     for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	cmp	DWORD PTR _web+616, 4
	jl	$LC239@merge_face
	mov	ecx, DWORD PTR _f1x$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	eax, DWORD PTR _f2x$[ebp]
	mov	ebx, DWORD PTR [eax]

; 3187 :       z[i] = f2x[0][i] - f1x[0][i];

	lea	edi, DWORD PTR _z$91530[ebp]
	sub	edi, esi
	mov	DWORD PTR tv2557[ebp], edi
	lea	edi, DWORD PTR _z$91530[ebp+8]
	sub	edi, esi
	mov	DWORD PTR tv2561[ebp], edi
	lea	ecx, DWORD PTR [ebx+24]
	lea	edi, DWORD PTR _z$91530[ebp+16]
	sub	ebx, esi
	lea	eax, DWORD PTR [esi+8]
	sub	edi, esi
	npad	8
$LL240@merge_face:
	fld	QWORD PTR [ecx-24]
	mov	esi, DWORD PTR tv2557[ebp]
	fsub	QWORD PTR [eax-8]
	add	edx, 4
	add	eax, 32					; 00000020H
	add	ecx, 32					; 00000020H
	fstp	QWORD PTR _z$91530[ebp+edx*8-32]
	fld	QWORD PTR [ebx+eax-32]
	fsub	QWORD PTR [eax-32]
	fstp	QWORD PTR [esi+eax-32]
	mov	esi, DWORD PTR tv2561[ebp]
	fld	QWORD PTR [ecx-40]
	fsub	QWORD PTR [eax-24]
	fstp	QWORD PTR [esi+eax-32]
	mov	esi, DWORD PTR _web+616
	fld	QWORD PTR [ecx-32]
	add	esi, -3					; fffffffdH
	fsub	QWORD PTR [eax-16]
	fstp	QWORD PTR [edi+eax-32]
	cmp	edx, esi
	jl	SHORT $LL240@merge_face
$LC239@merge_face:

; 3183 :   { REAL z[MAXCOORD];
; 3184 :     REAL u[MAXCOORD];
; 3185 :   
; 3186 :     for ( i = 0 ; i < SDIM ; i++ )

	mov	ebx, DWORD PTR _web+616
	cmp	edx, ebx
	jge	SHORT $LN238@merge_face
	mov	eax, DWORD PTR _f1x$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR _f2x$[ebp]
	mov	esi, DWORD PTR [esi]
	lea	edi, DWORD PTR _z$91530[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	sub	esi, ecx
	sub	edi, ecx
	mov	ecx, ebx
	sub	ecx, edx
$LC45@merge_face:

; 3187 :       z[i] = f2x[0][i] - f1x[0][i];

	fld	QWORD PTR [eax+esi]
	add	eax, 8
	dec	ecx
	fsub	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax+edi-8]
	jne	SHORT $LC45@merge_face
$LN238@merge_face:

; 3188 :     matvec_mul(web.inverse_periods,z,u,SDIM,SDIM);

	mov	eax, DWORD PTR _web+1612
	push	ebx
	push	ebx
	lea	ecx, DWORD PTR _u$91531[ebp]
	push	ecx
	lea	edx, DWORD PTR _z$91530[ebp]
	push	edx
	push	eax
	call	_matvec_mul

; 3189 :     for ( i = SDIM-1, wrap = 0 ; i >= 0 ; i-- )

	mov	ebx, DWORD PTR _web+616
	lea	esi, DWORD PTR [ebx-1]
	add	esp, 20					; 00000014H
	xor	edi, edi
	test	esi, esi
	js	SHORT $LN39@merge_face
	npad	6
$LL249@merge_face:

; 3190 :     { wrap <<= TWRAPBITS;
; 3191 :       wrap |= (int)(floor(u[i]+0.5)) & WRAPMASK;        

	fld	QWORD PTR _u$91531[ebp+esi*8]
	sub	esp, 8
	fadd	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	and	eax, 31					; 0000001fH
	shl	edi, 6
	or	edi, eax
	dec	esi
	jns	SHORT $LL249@merge_face

; 3192 :     } 
; 3193 :     if ( wrap )

	test	edi, edi
	je	SHORT $LN39@merge_face

; 3194 :     { for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	esi, DWORD PTR _f1x$[ebp]
	mov	ebx, DWORD PTR _tempx$[ebp]
	sub	ebx, esi
	mov	DWORD PTR tv321[ebp], 3
$LL38@merge_face:

; 3195 :         torus_wrap(f1x[i],tempx[i],wrap); 

	mov	ecx, DWORD PTR [ebx+esi]
	mov	edx, DWORD PTR [esi]
	push	edi
	push	ecx
	push	edx
	call	_torus_wrap
	add	esp, 12					; 0000000cH
	add	esi, 4
	dec	DWORD PTR tv321[ebp]
	jne	SHORT $LL38@merge_face

; 3196 :       f1x = tempx;

	mov	eax, DWORD PTR _tempx$[ebp]
	mov	DWORD PTR _f1x$[ebp], eax
$LN248@merge_face:
	mov	ebx, DWORD PTR _web+616
$LN39@merge_face:

; 3197 :     }
; 3198 :   }
; 3199 : 
; 3200 :   if ( besti < 0 )

	cmp	DWORD PTR _besti$[ebp], 0
	jge	$LN12@merge_face

; 3201 :   { /* no identical vertices, so try minimizing distance */
; 3202 :     /* calculate sum of distances for various matchings */
; 3203 :     for ( i = 0, bestdist = 1e30, besti = -1 ; i < FACET_VERTS ; i++ )

	fld	QWORD PTR __real@46293e5939a08cea
	mov	DWORD PTR _i$[ebp], 0
	fstp	QWORD PTR _bestdist$[ebp]
	mov	DWORD PTR _besti$[ebp], -1
	npad	2
$LL250@merge_face:

; 3204 :     { REAL dist = 0.0;

	fldz

; 3205 :       for ( j = 0 ; j < FACET_VERTS ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	fstp	QWORD PTR _dist$91547[ebp]
	jmp	SHORT $LN251@merge_face
$LL279@merge_face:
	fstp	ST(0)
$LN251@merge_face:

; 3206 :       { REAL s;
; 3207 :         int cor = (i+j)%3;

	mov	edx, DWORD PTR _i$[ebp]

; 3208 :         for ( k = 0, s = 0.0 ; k < SDIM ; k++ )

	fldz
	mov	eax, DWORD PTR _j$[ebp]
	lea	eax, DWORD PTR [eax+edx]
	cdq
	mov	ecx, 3
	idiv	ecx
	xor	edi, edi
	mov	DWORD PTR _cor$91552[ebp], edx
	cmp	ebx, 4
	jl	SHORT $LC242@merge_face
	mov	edx, DWORD PTR _f1x$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _f2x$[ebp]
	mov	eax, DWORD PTR _cor$91552[ebp]
	mov	edi, DWORD PTR [edx+eax*4]

; 3210 :           s += d*d;

	mov	edx, ecx
	lea	esi, DWORD PTR [ecx+24]
	lea	ecx, DWORD PTR [ebx-4]
	sub	edx, edi
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [edi+8]
	lea	edi, DWORD PTR [ecx*4]
$LN243@merge_face:
	fld	QWORD PTR [esi-24]
	add	eax, 32					; 00000020H
	fsub	QWORD PTR [eax-40]
	add	esi, 32					; 00000020H
	dec	ecx
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx+eax-32]
	fsub	QWORD PTR [eax-32]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi-40]
	fsub	QWORD PTR [eax-24]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi-32]
	fsub	QWORD PTR [eax-16]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LN243@merge_face
$LC242@merge_face:

; 3208 :         for ( k = 0, s = 0.0 ; k < SDIM ; k++ )

	cmp	edi, ebx
	jge	SHORT $LN253@merge_face
	mov	edx, DWORD PTR _cor$91552[ebp]
	mov	ecx, DWORD PTR _f2x$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _f1x$[ebp]
	mov	esi, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	lea	eax, DWORD PTR [ecx+edi*8]
	sub	edx, ecx
	mov	ecx, ebx
	sub	ecx, edi
$LC28@merge_face:

; 3209 :         { REAL d = (f1x[j][k] - f2x[cor][k]);

	fld	QWORD PTR [eax+edx]
	add	eax, 8
	dec	ecx
	fsub	QWORD PTR [eax-8]

; 3210 :           s += d*d;

	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LC28@merge_face
$LN253@merge_face:

; 3211 :         }
; 3212 :         dist += sqrt(s);

	call	__CIsqrt
	fadd	QWORD PTR _dist$91547[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	fst	QWORD PTR _dist$91547[ebp]
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, 3
	jl	$LL279@merge_face

; 3213 :       }
; 3214 :       if ( dist < bestdist ) 

	fld	QWORD PTR _bestdist$[ebp]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN282@merge_face

; 3215 :       { bestdist = dist;
; 3216 :         besti = i;

	mov	eax, DWORD PTR _i$[ebp]
	fstp	QWORD PTR _bestdist$[ebp]
	mov	DWORD PTR _besti$[ebp], eax
	jmp	SHORT $LN33@merge_face
$LN282@merge_face:
	fstp	ST(0)
$LN33@merge_face:

; 3201 :   { /* no identical vertices, so try minimizing distance */
; 3202 :     /* calculate sum of distances for various matchings */
; 3203 :     for ( i = 0, bestdist = 1e30, besti = -1 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, 3
	jl	$LL250@merge_face

; 3217 :       }
; 3218 :     }
; 3219 : 
; 3220 :     if ( !body_restricted )

	cmp	DWORD PTR _body_restricted$[ebp], 0
	jne	$LN12@merge_face

; 3221 :     { REAL bestdistt;
; 3222 :       for ( i = 0, bestdistt = 1e30, besti = -1 ; i < FACET_VERTS ; i++ )

	fld	QWORD PTR __real@46293e5939a08cea
	mov	DWORD PTR _i$[ebp], 0
	fstp	QWORD PTR _bestdistt$91559[ebp]
	mov	DWORD PTR _besti$[ebp], -1
	jmp	SHORT $LN23@merge_face
$LL299@merge_face:
	fstp	ST(0)
$LN23@merge_face:

; 3223 :       { REAL dist = 0.0;

	mov	ecx, DWORD PTR _i$[ebp]
	fldz
	add	ecx, 3
	fstp	QWORD PTR _dist$91563[ebp]

; 3224 :         for ( j = 0 ; j < FACET_VERTS ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR tv3410[ebp], ecx
	jmp	SHORT $LN252@merge_face
$LL293@merge_face:

; 3223 :       { REAL dist = 0.0;

	fstp	ST(0)
$LN252@merge_face:

; 3225 :         { REAL s;
; 3226 :           int cor = (i-j+3)%3;

	mov	eax, DWORD PTR tv3410[ebp]

; 3227 :           for ( k = 0, s = 0.0 ; k < SDIM ; k++ )

	fldz
	cdq
	mov	ecx, 3
	idiv	ecx
	xor	edi, edi
	mov	DWORD PTR _cor$91568[ebp], edx
	cmp	ebx, 4
	jl	SHORT $LC245@merge_face
	mov	edx, DWORD PTR _f1x$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _f2x$[ebp]
	mov	eax, DWORD PTR _cor$91568[ebp]
	mov	edi, DWORD PTR [edx+eax*4]

; 3229 :             s += d*d;

	mov	edx, ecx
	lea	esi, DWORD PTR [ecx+24]
	lea	ecx, DWORD PTR [ebx-4]
	sub	edx, edi
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [edi+8]
	lea	edi, DWORD PTR [ecx*4]
$LN246@merge_face:
	fld	QWORD PTR [esi-24]
	add	eax, 32					; 00000020H
	fsub	QWORD PTR [eax-40]
	add	esi, 32					; 00000020H
	dec	ecx
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx+eax-32]
	fsub	QWORD PTR [eax-32]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi-40]
	fsub	QWORD PTR [eax-24]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi-32]
	fsub	QWORD PTR [eax-16]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LN246@merge_face
$LC245@merge_face:

; 3227 :           for ( k = 0, s = 0.0 ; k < SDIM ; k++ )

	cmp	edi, ebx
	jge	SHORT $LN255@merge_face
	mov	edx, DWORD PTR _cor$91568[ebp]
	mov	ecx, DWORD PTR _f2x$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _f1x$[ebp]
	mov	esi, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	lea	eax, DWORD PTR [ecx+edi*8]
	sub	edx, ecx
	mov	ecx, ebx
	sub	ecx, edi
$LC17@merge_face:

; 3228 :           { REAL d = (f1x[j][k] - f2x[cor][k]);

	fld	QWORD PTR [eax+edx]
	add	eax, 8
	dec	ecx
	fsub	QWORD PTR [eax-8]

; 3229 :             s += d*d;

	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LC17@merge_face
$LN255@merge_face:

; 3230 :           }
; 3231 :           dist += sqrt(s);

	call	__CIsqrt
	fadd	QWORD PTR _dist$91563[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	dec	DWORD PTR tv3410[ebp]
	inc	eax
	fst	QWORD PTR _dist$91563[ebp]
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, 3
	jl	$LL293@merge_face

; 3232 :         }
; 3233 :         if ( dist < bestdistt ) 

	fld	QWORD PTR _bestdistt$91559[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN296@merge_face

; 3234 :         { bestdistt = dist;
; 3235 :           besti = i;

	mov	eax, DWORD PTR _i$[ebp]
	fstp	ST(0)
	fst	QWORD PTR _bestdistt$91559[ebp]
	mov	DWORD PTR _besti$[ebp], eax
	jmp	SHORT $LN22@merge_face
$LN296@merge_face:
	fstp	ST(1)
$LN22@merge_face:

; 3221 :     { REAL bestdistt;
; 3222 :       for ( i = 0, bestdistt = 1e30, besti = -1 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, 3
	jl	$LL299@merge_face

; 3236 :         }
; 3237 :       }
; 3238 :       if ( bestdistt < bestdist )

	fcomp	QWORD PTR _bestdist$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN12@merge_face

; 3239 :       { invert(f_id1); 
; 3240 :         invert(f_id2); 
; 3241 :         if ( besti >= 0 )

	mov	ecx, DWORD PTR _besti$[ebp]
	mov	eax, 134217728				; 08000000H
	xor	DWORD PTR _f_id1$[ebp], eax
	xor	DWORD PTR _f_id2$[ebp], eax
	test	ecx, ecx
	js	SHORT $LN12@merge_face

; 3242 :           besti = (3 - besti) % 3;

	mov	eax, 3
	sub	eax, ecx
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _besti$[ebp], edx
$LN12@merge_face:

; 3243 :       }
; 3244 :     }
; 3245 :   }     
; 3246 : 
; 3247 :   /* Merge vertices and edges.  Doing own edge merge since
; 3248 :    * can't pass enough info to merge_edge()
; 3249 :    */
; 3250 :   fe1 = get_facet_fe(f_id1);

	mov	eax, DWORD PTR _f_id1$[ebp]
	mov	edx, DWORD PTR _web+236
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN138@merge_face
	xor	esi, esi
	jmp	SHORT $LN137@merge_face
$LN138@merge_face:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	esi, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN137@merge_face
	xor	esi, 134217728				; 08000000H
$LN137@merge_face:

; 3251 :   fe2 = get_facet_fe(f_id2);

	mov	ecx, DWORD PTR _f_id2$[ebp]
	mov	eax, ecx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _fe1$[ebp], esi
	mov	DWORD PTR tv1592[ebp], eax
	jne	SHORT $LN142@merge_face
	xor	eax, eax
	jmp	SHORT $LN141@merge_face
$LN142@merge_face:
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN141@merge_face
	xor	eax, 134217728				; 08000000H
$LN141@merge_face:

; 3252 :   for ( i = 0 ; i < besti ; i++ )

	mov	edx, DWORD PTR _besti$[ebp]
	mov	ecx, DWORD PTR _web+460
	mov	DWORD PTR _fe2$[ebp], eax
	test	edx, edx
	jle	SHORT $LN268@merge_face
$LL11@merge_face:

; 3253 :       fe2 = get_next_edge(fe2);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN146@merge_face
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN10@merge_face
$LN146@merge_face:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+32]
$LN10@merge_face:

; 3252 :   for ( i = 0 ; i < besti ; i++ )

	dec	edx
	jne	SHORT $LL11@merge_face

; 3253 :       fe2 = get_next_edge(fe2);

	mov	DWORD PTR _fe2$[ebp], eax
$LN268@merge_face:

; 3254 :   for ( i = 0 ; i < FACET_EDGES ; i++ )

	mov	DWORD PTR tv479[ebp], 3
	mov	ebx, 134217728				; 08000000H
$LL267@merge_face:

; 3255 :   { edge_id e_id1 = get_fe_edge(fe1);

	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv1608[ebp], edx
	mov	edx, DWORD PTR [edx+ecx]
	and	esi, ebx
	xor	esi, DWORD PTR [edx+20]

; 3256 :     edge_id e_id2 = get_fe_edge(fe2);

	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv1637[ebp], edx
	mov	edx, DWORD PTR [edx+ecx]
	mov	edi, eax

; 3257 :     vertex_id tail1 = get_edge_tailv(e_id1);

	mov	eax, DWORD PTR _web+216
	and	edi, ebx
	xor	edi, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+304]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	test	esi, ebx
	mov	ebx, DWORD PTR _web+124
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR _e_id2$91583[ebp], edi
	je	SHORT $LN154@merge_face
	mov	ebx, DWORD PTR _web+636
	lea	edx, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [edx+eax]
	jmp	SHORT $LN153@merge_face
$LN154@merge_face:
	mov	edx, DWORD PTR [eax+edx]
$LN153@merge_face:

; 3258 :     vertex_id tail2 = get_edge_tailv(e_id2);

	mov	ebx, DWORD PTR _web+124
	test	edi, 134217728				; 08000000H
	je	SHORT $LN158@merge_face
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR _web+636
	lea	edi, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [edi+eax]
	jmp	SHORT $LN157@merge_face
$LN158@merge_face:
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	eax, DWORD PTR [eax+edi]
$LN157@merge_face:

; 3259 :     facetedge_id fe_next;
; 3260 :     facetedge_id next_fe2,prev_fe1;
; 3261 :     if ( !equal_element(tail1,tail2) )

	mov	edi, eax
	mov	ebx, edx
	or	edi, 134217728				; 08000000H
	or	ebx, 134217728				; 08000000H
	cmp	ebx, edi
	je	SHORT $LN257@merge_face

; 3262 :        merge_vertex(tail1,tail2);

	push	eax
	push	edx
	call	_merge_vertex
	mov	ecx, DWORD PTR _web+460
	add	esp, 8
$LN257@merge_face:

; 3263 :     if ( !equal_id(e_id1,e_id2) )

	cmp	esi, DWORD PTR _e_id2$91583[ebp]
	je	$LN258@merge_face

; 3264 :     { fe_next = fe2;

	mov	ebx, DWORD PTR _fe2$[ebp]
	mov	eax, ebx
	npad	3
$LL3@merge_face:

; 3265 :       do
; 3266 :       { set_fe_edge(fe_next,e_id1);

	mov	edx, eax
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	edi, esi
	je	SHORT $LN161@merge_face
	xor	edi, 134217728				; 08000000H
$LN161@merge_face:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR [ecx+20], edi
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx

; 3267 :         fe_next = get_next_facet(fe_next);

	mov	ecx, DWORD PTR _web+460
	test	edx, edx
	je	SHORT $LN165@merge_face
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN2@merge_face
$LN165@merge_face:
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+40]
$LN2@merge_face:

; 3268 :       } while ( !equal_id(fe2,fe_next) );

	cmp	ebx, eax
	jne	SHORT $LL3@merge_face

; 3269 :       next_fe2 = get_next_facet(fe2);

	shr	ebx, 27					; 0000001bH
	and	ebx, 1
	je	SHORT $LN169@merge_face
	mov	edx, DWORD PTR tv1637[ebp]
	mov	esi, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [esi+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN168@merge_face
$LN169@merge_face:
	mov	eax, DWORD PTR tv1637[ebp]
	mov	esi, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [esi+40]
$LN168@merge_face:

; 3270 :       prev_fe1 = get_prev_facet(fe1);

	mov	edi, DWORD PTR _fe1$[ebp]
	mov	edx, DWORD PTR tv1608[ebp]
	mov	edx, DWORD PTR [edx+ecx]
	shr	edi, 27					; 0000001bH
	and	edi, 1
	je	SHORT $LN173@merge_face
	mov	edx, DWORD PTR [edx+40]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN172@merge_face
$LN173@merge_face:
	mov	edx, DWORD PTR [edx+36]
$LN172@merge_face:

; 3271 :       set_next_facet(fe2,fe1);

	test	DWORD PTR _fe2$[ebp], 268435456		; 10000000H
	je	SHORT $LN263@merge_face
	mov	ecx, DWORD PTR _fe1$[ebp]
	test	ebx, ebx
	je	SHORT $LN177@merge_face
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [esi+36], ecx
	jmp	SHORT $LN308@merge_face
$LN177@merge_face:
	mov	DWORD PTR [esi+40], ecx
$LN308@merge_face:
	mov	ecx, DWORD PTR _web+460
$LN263@merge_face:

; 3272 :       set_prev_facet(fe1,fe2);

	test	DWORD PTR _fe1$[ebp], 268435456		; 10000000H
	je	SHORT $LN264@merge_face
	test	edi, edi
	je	SHORT $LN182@merge_face
	mov	esi, DWORD PTR _fe2$[ebp]
	mov	edi, DWORD PTR tv1608[ebp]
	mov	ecx, DWORD PTR [edi+ecx]
	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR [ecx+40], esi
	jmp	SHORT $LN181@merge_face
$LN182@merge_face:
	mov	esi, DWORD PTR tv1608[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	esi, DWORD PTR _fe2$[ebp]
	mov	DWORD PTR [ecx+36], esi
$LN181@merge_face:
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
	mov	ecx, DWORD PTR _web+460
$LN264@merge_face:

; 3273 :       set_next_facet(prev_fe1,next_fe2);

	test	edx, 268435456				; 10000000H
	je	SHORT $LN265@merge_face
	test	edx, 134217728				; 08000000H
	je	SHORT $LN187@merge_face
	mov	esi, eax
	xor	esi, 134217728				; 08000000H
	mov	edi, edx
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	DWORD PTR [ecx+36], esi
	jmp	SHORT $LN309@merge_face
$LN187@merge_face:
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [ecx+40], eax
$LN309@merge_face:
	mov	ecx, DWORD PTR _web+460
$LN265@merge_face:

; 3274 :       set_prev_facet(next_fe2,prev_fe1);

	test	eax, 268435456				; 10000000H
	je	SHORT $LN194@merge_face
	test	eax, 134217728				; 08000000H
	je	SHORT $LN192@merge_face
	xor	edx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [eax+40], edx
	jmp	SHORT $LN191@merge_face
$LN192@merge_face:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+36], edx
$LN191@merge_face:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN194@merge_face:

; 3275 :       free_element(e_id2);   

	mov	edx, DWORD PTR _e_id2$91583[ebp]
	push	edx
	call	_free_element
	mov	ecx, DWORD PTR _web+460
	add	esp, 4
$LN258@merge_face:

; 3276 :     }
; 3277 :     fe1 = get_next_edge(fe1);

	mov	eax, DWORD PTR tv1608[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	mov	ebx, 134217728				; 08000000H
	test	DWORD PTR _fe1$[ebp], ebx
	je	SHORT $LN197@merge_face
	mov	esi, DWORD PTR [edx+28]
	xor	esi, ebx
	jmp	SHORT $LN310@merge_face
$LN197@merge_face:
	mov	esi, DWORD PTR [edx+32]
$LN310@merge_face:

; 3278 :     fe2 = get_next_edge(fe2) ;

	mov	eax, DWORD PTR tv1637[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _fe1$[ebp], esi
	test	DWORD PTR _fe2$[ebp], ebx
	je	SHORT $LN201@merge_face
	mov	eax, DWORD PTR [edx+28]
	xor	eax, ebx
	jmp	SHORT $LN311@merge_face
$LN201@merge_face:
	mov	eax, DWORD PTR [edx+32]
$LN311@merge_face:

; 3254 :   for ( i = 0 ; i < FACET_EDGES ; i++ )

	dec	DWORD PTR tv479[ebp]

; 3278 :     fe2 = get_next_edge(fe2) ;

	mov	DWORD PTR _fe2$[ebp], eax
	jne	$LL267@merge_face

; 3279 :   }
; 3280 : 
; 3281 :   b_id = get_facet_body(f_id2);

	cmp	DWORD PTR _web+400, 0
	mov	edi, DWORD PTR _f_id2$[ebp]
	jne	SHORT $LN207@merge_face
$LN312@merge_face:
	xor	esi, esi
	jmp	SHORT $LN204@merge_face
$LN207@merge_face:
	cmp	DWORD PTR tv1592[ebp], 0
	je	SHORT $LN312@merge_face
	test	edi, ebx
	je	SHORT $LN205@merge_face
	mov	ecx, DWORD PTR _web+236
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	esi, DWORD PTR [edx+eax+4]
	jmp	SHORT $LN204@merge_face
$LN205@merge_face:
	mov	edx, DWORD PTR _web+236
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	esi, DWORD PTR [eax+ecx]
$LN204@merge_face:

; 3282 :   set_facet_body(f_id1,b_id);

	mov	edx, DWORD PTR _f_id1$[ebp]
	push	esi
	push	edx
	call	_set_facet_body

; 3283 :  
; 3284 :   set_facet_body(inverse_id(f_id2),b_id); /* so dissolve_facet() works */

	mov	eax, edi
	xor	eax, ebx
	push	esi
	push	eax
	call	_set_facet_body

; 3285 :   dissolve_facet(f_id2);

	push	edi
	call	_dissolve_facet

; 3286 : 
; 3287 : }  /* end merge_facet() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 20					; 00000014H
	pop	ebx
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_merge_facet ENDP
_TEXT	ENDS
PUBLIC	_reverse_orientation_edge
; Function compile flags: /Ogtp
;	COMDAT _reverse_orientation_edge
_TEXT	SEGMENT
_v_id$ = -32						; size = 8
_start_fe$ = -28					; size = 4
_fenext$91626 = -24					; size = 4
tv888 = -20						; size = 4
tv903 = -16						; size = 4
tv891 = -12						; size = 4
tv899 = -8						; size = 4
tv836 = -4						; size = 4
tv833 = 8						; size = 4
_e_id$ = 8						; size = 4
_reverse_orientation_edge PROC				; COMDAT

; 3298 : { vertex_id v_id[2],*v;

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 3299 :   facetedge_id start_fe;
; 3300 :   int i;
; 3301 :   struct edge *e_ptr;
; 3302 : 
; 3303 :   v_id[0] = get_edge_tailv(e_id);

	mov	edx, DWORD PTR _web+636
	push	ebx
	mov	ebx, DWORD PTR _dymem
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	mov	ecx, esi
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	push	edi
	mov	edi, DWORD PTR _web+124
	mov	DWORD PTR tv833[ebp], ecx
	mov	eax, esi
	je	SHORT $LN17@reverse_or
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv836[ebp], eax
	mov	eax, DWORD PTR [eax+edi]
	mov	edi, DWORD PTR _web+216
	mov	edi, DWORD PTR [edi+ebx+304]
	add	eax, edi
	mov	ebx, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN16@reverse_or
$LN17@reverse_or:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv836[ebp], eax
	mov	eax, DWORD PTR [eax+edi]
	mov	edi, DWORD PTR _web+216
	mov	edi, DWORD PTR [edi+ebx+304]
	mov	ebx, DWORD PTR [eax+edi]
	add	eax, edi
$LN16@reverse_or:

; 3304 :   v_id[1] = get_edge_headv(e_id);

	test	ecx, ecx
	je	SHORT $LN21@reverse_or
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR _v_id$[ebp+4], edi
	jmp	SHORT $LN20@reverse_or
$LN21@reverse_or:
	mov	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _v_id$[ebp+4], edx
	mov	edi, edx
$LN20@reverse_or:

; 3305 :   /* swap endpoints */
; 3306 :   switch ( web.modeltype )

	mov	eax, DWORD PTR _web+628
	dec	eax
	je	$LN11@reverse_or
	dec	eax
	je	$LN10@reverse_or
	dec	eax
	jne	$LN12@reverse_or

; 3319 :     case LAGRANGE:
; 3320 :        remove_vertex_edge(v_id[0],e_id);

	push	esi
	push	ebx
	call	_remove_vertex_edge

; 3321 :        remove_vertex_edge(v_id[1],inverse_id(e_id));

	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	push	eax
	push	edi
	call	_remove_vertex_edge

; 3322 :        set_edge_headv(e_id,v_id[0]);

	push	ebx
	push	esi
	call	_set_edge_headv

; 3323 :        set_edge_tailv(e_id,v_id[1]);

	push	edi
	push	esi
	call	_set_edge_tailv

; 3324 :        v = get_edge_vertices(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv836[ebp]
	mov	edi, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edi, DWORD PTR [eax+ecx+304]

; 3325 :        for ( i = 1 ; i <= web.lagrange_order/2 ; i++ )

	mov	eax, DWORD PTR _web+632
	cdq
	sub	eax, edx
	mov	ecx, 1
	sar	eax, 1
	add	esp, 32					; 00000020H
	cmp	eax, ecx
	jl	SHORT $LN90@reverse_or
$LL8@reverse_or:

; 3326 :        { vertex_id vv = v[i];
; 3327 :          v[i] = v[web.lagrange_order - i];

	mov	edx, DWORD PTR _web+632
	mov	eax, DWORD PTR [edi+ecx*4]
	sub	edx, ecx
	mov	edx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [edi+ecx*4], edx

; 3328 :          v[web.lagrange_order - i] = vv;

	mov	edx, DWORD PTR _web+632
	sub	edx, ecx
	mov	DWORD PTR [edi+edx*4], eax
	mov	eax, DWORD PTR _web+632
	cdq
	sub	eax, edx
	inc	ecx
	sar	eax, 1
	cmp	ecx, eax
	jle	SHORT $LL8@reverse_or
$LN90@reverse_or:

; 3329 :        }
; 3330 :        break;

	mov	edi, DWORD PTR _v_id$[ebp+4]
$LN97@reverse_or:
	mov	ecx, DWORD PTR tv833[ebp]
$LN12@reverse_or:

; 3331 :   }
; 3332 :   set_vertex_edge(v_id[1],e_id);

	mov	edx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+edi*4]
	mov	DWORD PTR [eax+28], esi

; 3333 :   set_vertex_edge(v_id[0],inverse_id(e_id));

	mov	edx, DWORD PTR _web+12
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ebx*4]
	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR [eax+28], esi

; 3334 : 
; 3335 :   /* reverse id in facet-edges */
; 3336 :   start_fe = get_edge_fe(e_id);

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR tv836[ebp]
	mov	eax, DWORD PTR [eax+edx]
	test	eax, eax
	jne	SHORT $LN25@reverse_or
	xor	esi, esi
	mov	DWORD PTR _start_fe$[ebp], esi
	jmp	SHORT $LN26@reverse_or
$LN10@reverse_or:

; 3312 :        break;
; 3313 :     case QUADRATIC:
; 3314 :        remove_vertex_edge(v_id[0],e_id);

	push	esi
	push	ebx
	call	_remove_vertex_edge

; 3315 :        remove_vertex_edge(v_id[1],inverse_id(e_id));

	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	push	eax
	push	edi
	call	_remove_vertex_edge

; 3316 :        set_edge_headv(e_id,v_id[0]);

	push	ebx
	push	esi
	call	_set_edge_headv

; 3317 :        set_edge_tailv(e_id,v_id[1]);

	push	edi
	push	esi
	call	_set_edge_tailv
	add	esp, 32					; 00000020H

; 3318 :        break;

	jmp	SHORT $LN97@reverse_or
$LN11@reverse_or:

; 3307 :   { case LINEAR:
; 3308 :        remove_vertex_edge(v_id[0],e_id);

	push	esi
	push	ebx
	call	_remove_vertex_edge

; 3309 :        remove_vertex_edge(v_id[1],inverse_id(e_id));

	mov	ecx, esi
	xor	ecx, 134217728				; 08000000H
	push	ecx
	push	edi
	call	_remove_vertex_edge

; 3310 :        set_edge_headv(e_id,v_id[0]);

	push	ebx
	push	esi
	call	_set_edge_headv

; 3311 :        set_edge_tailv(e_id,v_id[1]);

	push	edi
	push	esi
	call	_set_edge_tailv
	add	esp, 32					; 00000020H
	jmp	$LN97@reverse_or

; 3334 : 
; 3335 :   /* reverse id in facet-edges */
; 3336 :   start_fe = get_edge_fe(e_id);

$LN25@reverse_or:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN24@reverse_or
	xor	eax, 134217728				; 08000000H
$LN24@reverse_or:
	mov	esi, eax
	mov	DWORD PTR _start_fe$[ebp], eax
$LN26@reverse_or:

; 3337 :   if ( valid_id(start_fe) )

	test	esi, 268435456				; 10000000H
	je	$LN2@reverse_or

; 3338 :   { facetedge_id fe = start_fe;

	mov	ecx, DWORD PTR _web+460
	npad	2
$LL4@reverse_or:

; 3339 :     do 
; 3340 :     { facet_id feprev,fenext,fe_fore,fe_aft;
; 3341 :       facet_id f_id = get_fe_facet(fe);

	mov	ebx, esi
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	mov	DWORD PTR tv888[ebp], ebx
	jne	SHORT $LN29@reverse_or
	mov	edi, DWORD PTR _NULLFACET
	jmp	SHORT $LN28@reverse_or
$LN29@reverse_or:
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	edi, DWORD PTR [eax+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN28@reverse_or
	xor	edi, 134217728				; 08000000H
$LN28@reverse_or:

; 3342 :       set_fe_facet(fe,inverse_id(f_id));

	mov	ecx, edi
	xor	ecx, 134217728				; 08000000H
	push	ecx
	push	esi
	call	_set_fe_facet

; 3343 :       set_facet_fe(f_id,inverse_id(fe));

	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	push	eax
	push	edi
	mov	DWORD PTR tv903[ebp], eax
	call	_set_facet_fe

; 3344 :       fenext = get_next_facet(fe);

	mov	ecx, DWORD PTR _web+460
	mov	edx, esi
	shr	edx, 27					; 0000001bH
	add	esp, 16					; 00000010H
	and	edx, 1
	mov	DWORD PTR tv899[ebp], edx
	je	SHORT $LN33@reverse_or
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	edi, DWORD PTR [eax+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN98@reverse_or
$LN33@reverse_or:
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	edi, DWORD PTR [eax+40]
$LN98@reverse_or:
	mov	DWORD PTR _fenext$91626[ebp], edi
	mov	DWORD PTR tv891[ebp], esi

; 3345 :       feprev = get_prev_facet(fe);

	test	edx, edx
	je	SHORT $LN37@reverse_or
	mov	edx, DWORD PTR [eax+40]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN36@reverse_or
$LN37@reverse_or:
	mov	edx, DWORD PTR [eax+36]
$LN36@reverse_or:

; 3346 :       set_next_facet(fe,feprev);

	test	ebx, ebx
	mov	ebx, DWORD PTR tv899[ebp]
	je	SHORT $LN40@reverse_or
	test	ebx, ebx
	je	SHORT $LN41@reverse_or
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [eax+36], edx
	jmp	SHORT $LN101@reverse_or
$LN41@reverse_or:
	mov	DWORD PTR [eax+40], edx
$LN101@reverse_or:
	mov	ecx, DWORD PTR _web+460
$LN40@reverse_or:

; 3347 :       set_prev_facet(fe,fenext);

	cmp	DWORD PTR tv888[ebp], 0
	je	SHORT $LN96@reverse_or
	test	ebx, ebx
	je	SHORT $LN46@reverse_or
	mov	edx, DWORD PTR [esi+ecx]
	xor	edi, 134217728				; 08000000H
	mov	DWORD PTR [edx+40], edi
	jmp	SHORT $LN45@reverse_or
$LN46@reverse_or:
	mov	eax, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+36], edi
$LN45@reverse_or:
	mov	eax, DWORD PTR _global_timestamp
	mov	ecx, DWORD PTR _web+460
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN96@reverse_or:

; 3348 :       fe_fore = get_next_edge(fe);

	mov	esi, DWORD PTR [esi+ecx]
	test	ebx, ebx
	je	SHORT $LN51@reverse_or
	mov	eax, DWORD PTR [esi+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN50@reverse_or
$LN51@reverse_or:
	mov	eax, DWORD PTR [esi+32]
$LN50@reverse_or:

; 3349 :       fe_aft = get_prev_edge(fe);

	test	ebx, ebx
	je	SHORT $LN55@reverse_or
	mov	edi, DWORD PTR [esi+32]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN54@reverse_or
$LN55@reverse_or:
	mov	edi, DWORD PTR [esi+28]
$LN54@reverse_or:

; 3350 :       set_next_edge(fe,inverse_id(fe_aft));

	mov	ebx, DWORD PTR tv888[ebp]
	mov	edx, edi
	xor	edx, 134217728				; 08000000H
	test	ebx, ebx
	je	SHORT $LN92@reverse_or
	cmp	DWORD PTR tv899[ebp], 0
	je	SHORT $LN59@reverse_or
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [esi+28], edx
	jmp	SHORT $LN99@reverse_or
$LN59@reverse_or:
	mov	DWORD PTR [esi+32], edx
$LN99@reverse_or:
	mov	ecx, DWORD PTR _web+460
$LN92@reverse_or:

; 3351 :       set_prev_edge(fe,inverse_id(fe_fore));

	mov	edx, eax
	xor	edx, 134217728				; 08000000H
	test	ebx, ebx
	je	SHORT $LN93@reverse_or
	cmp	DWORD PTR tv899[ebp], 0
	mov	esi, DWORD PTR tv891[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	je	SHORT $LN64@reverse_or
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR [ecx+32], edx
	jmp	SHORT $LN63@reverse_or
$LN64@reverse_or:
	mov	DWORD PTR [ecx+28], edx
$LN63@reverse_or:
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
	mov	ecx, DWORD PTR _web+460
$LN93@reverse_or:

; 3352 :       set_prev_edge(fe_fore,inverse_id(fe));

	mov	edx, DWORD PTR tv903[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN71@reverse_or
	test	eax, 134217728				; 08000000H
	je	SHORT $LN69@reverse_or
	mov	esi, edx
	xor	esi, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [eax+32], esi
	jmp	SHORT $LN68@reverse_or
$LN69@reverse_or:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+28], edx
$LN68@reverse_or:
	mov	eax, DWORD PTR _global_timestamp
	mov	ecx, DWORD PTR _web+460
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN71@reverse_or:

; 3353 :       set_next_edge(fe_aft,inverse_id(fe));

	test	edi, 268435456				; 10000000H
	je	SHORT $LN73@reverse_or
	test	edi, 134217728				; 08000000H
	je	SHORT $LN74@reverse_or
	xor	edx, 134217728				; 08000000H
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edi*4]
	mov	DWORD PTR [eax+28], edx
	jmp	SHORT $LN100@reverse_or
$LN74@reverse_or:
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	DWORD PTR [ecx+32], edx
$LN100@reverse_or:
	mov	ecx, DWORD PTR _web+460
$LN73@reverse_or:

; 3354 :       fe = fenext;

	mov	esi, DWORD PTR _fenext$91626[ebp]

; 3355 :     } while ( !equal_id(fe,start_fe) );

	cmp	esi, DWORD PTR _start_fe$[ebp]
	jne	$LL4@reverse_or
	mov	ecx, DWORD PTR tv833[ebp]
$LN2@reverse_or:

; 3356 :   }
; 3357 : 
; 3358 :   /* reverse symmetry wraps */
; 3359 :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN82@reverse_or

; 3360 :     set_edge_wrap(e_id,(*sym_inverse)(get_edge_wrap(e_id)));

	mov	eax, DWORD PTR _web+124
	mov	edx, DWORD PTR tv836[ebp]
	mov	edx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+esi+784]
	mov	eax, DWORD PTR [edx+eax]
	test	ecx, ecx
	je	SHORT $LN80@reverse_or
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN80@reverse_or:
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
	cmp	DWORD PTR tv833[ebp], 0
	je	SHORT $LN84@reverse_or
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN84@reverse_or:
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv836[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+784]
	mov	DWORD PTR [ecx+edx], eax
$LN82@reverse_or:

; 3361 :     
; 3362 :    
; 3363 :   /* reverse "orientation" for methods and constraint integrals */
; 3364 :   e_ptr = eptr(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR tv836[ebp]
	mov	eax, DWORD PTR [eax+ecx]

; 3365 :   e_ptr->attr ^= NEGBOUNDARY;

	xor	DWORD PTR [eax+8], 256			; 00000100H
	xor	DWORD PTR [eax+12], 0
	pop	edi
	pop	esi
	pop	ebx

; 3366 :   
; 3367 : } /* end reverse_orientation_edge(() */

	mov	esp, ebp
	pop	ebp
	ret	0
_reverse_orientation_edge ENDP
_TEXT	ENDS
PUBLIC	_reverse_orientation_facet
; Function compile flags: /Ogtp
;	COMDAT _reverse_orientation_facet
_TEXT	SEGMENT
_v$91651 = -12						; size = 4
_row$91656 = -8						; size = 4
_spot$91657 = -4					; size = 4
_start_fe$ = -4						; size = 4
_f_id$ = 8						; size = 4
_reverse_orientation_facet PROC				; COMDAT

; 3377 : { facetedge_id start_fe,fe,last_fe;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 3378 :   body_id b_id,bb_id;
; 3379 :   struct facet *e_ptr;
; 3380 :   
; 3381 :    /* reverse body attachments (before reversing edges!!) */
; 3382 :   b_id = get_facet_body(f_id);

	mov	edi, DWORD PTR _f_id$[ebp]
	push	edi
	call	_get_facet_body

; 3383 :   bb_id = get_facet_body(inverse_id(f_id));

	mov	ebx, edi
	xor	ebx, 134217728				; 08000000H
	push	ebx
	mov	esi, eax
	call	_get_facet_body

; 3384 :   set_facet_body(f_id,bb_id);

	push	eax
	push	edi
	call	_set_facet_body

; 3385 :   set_facet_body(inverse_id(f_id),b_id);

	push	esi
	push	ebx
	call	_set_facet_body
	add	esp, 24					; 00000018H

; 3386 : 
; 3387 :   /* reverse fe */
; 3388 :   fe = start_fe = get_facet_fe(f_id);

	test	edi, 268435456				; 10000000H
	jne	SHORT $LN17@reverse_or@2
	mov	DWORD PTR _start_fe$[ebp], 0
	jmp	SHORT $LN18@reverse_or@2
$LN17@reverse_or@2:
	mov	ecx, DWORD PTR _web+236
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN16@reverse_or@2
	xor	eax, 134217728				; 08000000H
$LN16@reverse_or@2:
	mov	DWORD PTR _start_fe$[ebp], eax
$LN18@reverse_or@2:
	mov	esi, DWORD PTR _start_fe$[ebp]
	npad	6
$LL13@reverse_or@2:

; 3389 :   do
; 3390 :   { set_fe_facet(fe,inverse_id(f_id));

	push	ebx
	push	esi
	call	_set_fe_facet

; 3391 :     last_fe = fe;
; 3392 :     fe = get_next_edge(fe);

	mov	ecx, DWORD PTR _web+460
	add	esp, 8
	mov	eax, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN21@reverse_or@2
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [edx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN12@reverse_or@2
$LN21@reverse_or@2:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [edx+32]
$LN12@reverse_or@2:

; 3393 :   } while (valid_id(fe) && !equal_id(fe,start_fe));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN33@reverse_or@2
	cmp	esi, DWORD PTR _start_fe$[ebp]
	jne	SHORT $LL13@reverse_or@2

; 3394 :   if (!valid_id(fe)) /* in case of open string facet */

	test	esi, 268435456				; 10000000H

; 3395 :     set_facet_fe(f_id,inverse_id(last_fe));
; 3396 :   else

	je	SHORT $LN33@reverse_or@2

; 3397 :     set_facet_fe(f_id,inverse_id(start_fe));

	mov	eax, DWORD PTR _start_fe$[ebp]
$LN33@reverse_or@2:
	xor	eax, 134217728				; 08000000H
	push	eax
	push	edi
	call	_set_facet_fe
	add	esp, 8

; 3398 :     
; 3399 :   /* invert Lagrange vertices */
; 3400 :   if ( (web.representation == SOAPFILM) && (web.modeltype == LAGRANGE) )

	cmp	DWORD PTR _web+624, 2
	jne	$LN4@reverse_or@2
	cmp	DWORD PTR _web+628, 3
	jne	$LN4@reverse_or@2

; 3401 :   { vertex_id *v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+328

; 3402 :     int row,spot = web.lagrange_order+1;

	mov	esi, DWORD PTR _web+632
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+eax+304]

; 3403 :     for ( row = 1 ; row < web.lagrange_order ; row++ )

	mov	ebx, 1
	lea	edi, DWORD PTR [esi+1]
	mov	DWORD PTR _v$91651[ebp], ecx
	mov	DWORD PTR _spot$91657[ebp], edi
	mov	DWORD PTR _row$91656[ebp], ebx
	cmp	esi, ebx
	jle	SHORT $LN31@reverse_or@2
	jmp	SHORT $LN6@reverse_or@2
	npad	8
$LL30@reverse_or@2:
	mov	esi, DWORD PTR _web+632
$LN6@reverse_or@2:

; 3404 :     { int rowsize = web.lagrange_order+1-row;

	sub	esi, ebx
	inc	esi

; 3405 :       int i,mid = rowsize/2;

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1

; 3406 :       for ( i = 1 ; i < mid ; i++ )

	cmp	eax, 1
	jle	SHORT $LN1@reverse_or@2

; 3404 :     { int rowsize = web.lagrange_order+1-row;

	lea	edx, DWORD PTR [ecx+edi*4+4]
	add	edi, esi
	lea	ecx, DWORD PTR [ecx+edi*4-4]
	lea	edi, DWORD PTR [eax-1]
$LL3@reverse_or@2:

; 3407 :       { vertex_id vv = v[spot+i];

	mov	eax, DWORD PTR [edx]

; 3408 :         v[spot+i] = v[spot+rowsize-i-1];

	mov	ebx, DWORD PTR [ecx-4]
	mov	DWORD PTR [edx], ebx

; 3409 :         v[spot+rowsize-i] = vv;

	mov	DWORD PTR [ecx], eax
	add	edx, 4
	add	ecx, -4					; fffffffcH
	dec	edi
	jne	SHORT $LL3@reverse_or@2

; 3406 :       for ( i = 1 ; i < mid ; i++ )

	mov	ecx, DWORD PTR _v$91651[ebp]
	mov	edi, DWORD PTR _spot$91657[ebp]
	mov	ebx, DWORD PTR _row$91656[ebp]
$LN1@reverse_or@2:

; 3410 :       }
; 3411 :       spot += rowsize;

	inc	ebx
	add	edi, esi
	mov	DWORD PTR _spot$91657[ebp], edi
	mov	DWORD PTR _row$91656[ebp], ebx
	cmp	ebx, DWORD PTR _web+632
	jl	SHORT $LL30@reverse_or@2
$LN31@reverse_or@2:

; 3403 :     for ( row = 1 ; row < web.lagrange_order ; row++ )

	mov	edi, DWORD PTR _f_id$[ebp]
$LN4@reverse_or@2:

; 3412 :     }
; 3413 :   }
; 3414 :   
; 3415 :   /* reverse method orientations */
; 3416 :   e_ptr = fptr(f_id);

	mov	ecx, DWORD PTR _web+236
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+edi*4]

; 3417 :   e_ptr->attr ^= NEGBOUNDARY;

	xor	DWORD PTR [edi+8], 256			; 00000100H
	xor	DWORD PTR [edi+12], 0
	pop	edi
	pop	esi
	pop	ebx

; 3418 : } // end reverse_orientation_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
_reverse_orientation_facet ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@MOLBPHPK@Could?5not?5find?5vertex?5on?5same?5bo@ ; `string'
PUBLIC	_f_id$GSCopy$
PUBLIC	??_C@_0CN@JFIPCNGB@Can?8t?5face_triangulate?$CI?$CJ?5in?5Lagr@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_face_triangulate
EXTRN	_NULLVERTEX:DWORD
;	COMDAT ??_C@_0DF@MOLBPHPK@Could?5not?5find?5vertex?5on?5same?5bo@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DF@MOLBPHPK@Could?5not?5find?5vertex?5on?5same?5bo@ DB 'Could not '
	DB	'find vertex on same boundary as facet %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JFIPCNGB@Can?8t?5face_triangulate?$CI?$CJ?5in?5Lagr@
CONST	SEGMENT
??_C@_0CN@JFIPCNGB@Can?8t?5face_triangulate?$CI?$CJ?5in?5Lagr@ DB 'Can''t'
	DB	' face_triangulate() in Lagrange model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _face_triangulate
_TEXT	SEGMENT
tv2418 = -208						; size = 4
tv2441 = -204						; size = 4
tv2409 = -200						; size = 8
tv2913 = -196						; size = 4
tv2512 = -196						; size = 4
_no_interp$89092 = -196					; size = 4
_i$ = -196						; size = 4
tv2564 = -192						; size = 4
_f_id$GSCopy$ = -188					; size = 4
_center$ = -184						; size = 4
tv2848 = -180						; size = 4
tv2574 = -180						; size = 4
_paramb$89086 = -180					; size = 4
tv2454 = -176						; size = 4
_base_v$89089 = -176					; size = 4
tv2402 = -172						; size = 4
tv2895 = -168						; size = 4
_first_fe$ = -168					; size = 4
_bdry$ = -164						; size = 4
tv2831 = -160						; size = 4
_centerx$ = -160					; size = 4
tv2862 = -156						; size = 4
_vercount$89093 = -156					; size = 4
_wrap$ = -156						; size = 4
_fe$ = -152						; size = 4
_s$89090 = -148						; size = 48
_defaultp$89085 = -100					; size = 48
_w$89068 = -100						; size = 48
_midp$89091 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_f_id$ = 8						; size = 4
_edgecount$ = 12					; size = 4
_face_triangulate PROC					; COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 31   :   int i,k;
; 32   :   vertex_id center; 
; 33   :   facetedge_id fe,pre_fe;
; 34   :   vertex_id rimv;
; 35   :   edge_id spoke;
; 36   :   facetedge_id fe_in,fe_out,next_fe;
; 37   :   REAL *centerx,*x;
; 38   :   struct boundary *bdry;
; 39   :   WRAPTYPE wrap = 0;
; 40   :   facetedge_id first_fe;
; 41   : 
; 42   :   if ( web.modeltype == LAGRANGE ) 

	cmp	DWORD PTR _web+628, 3
	push	ebx
	push	esi
	mov	esi, DWORD PTR _f_id$[ebp]
	push	edi
	mov	DWORD PTR _wrap$[ebp], 0
	jne	SHORT $LN77@face_trian

; 43   :      kb_error(1237,"Can't face_triangulate() in Lagrange model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CN@JFIPCNGB@Can?8t?5face_triangulate?$CI?$CJ?5in?5Lagr@
	push	1237					; 000004d5H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN77@face_trian:

; 44   : 
; 45   :   f_id = positive_id(f_id);  /* axial points like positive orientation here */

	and	esi, -134217729				; f7ffffffH

; 46   :   
; 47   :   /* put a new vertex in the center */
; 48   :   center = new_vertex(NULL,f_id);

	push	esi
	push	0
	mov	DWORD PTR _f_id$GSCopy$[ebp], esi
	call	_new_vertex
	mov	ecx, eax

; 49   :   if ( get_fattr(f_id) & FIXED )

	mov	eax, DWORD PTR _web+236
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	edx, edx
	add	esp, 8
	or	eax, edx
	mov	DWORD PTR _center$[ebp], ecx
	mov	DWORD PTR tv2402[ebp], edi
	je	SHORT $LN96@face_trian

; 50   :      set_attr(center,FIXED);

	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax+12], edx
$LN96@face_trian:

; 51   : 
; 52   :   /* center coordinates are average of vertices */
; 53   :   centerx = get_coord(center);

	mov	edx, DWORD PTR _dymem

; 54   :   for ( i = 0 ; i < SDIM ; i++ ) centerx[i] = 0.0;

	fldz
	mov	eax, ecx
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2418[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _web+104
	add	eax, DWORD PTR [ecx+edx+64]
	xor	ecx, ecx
	mov	DWORD PTR _centerx$[ebp], eax
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN321@face_trian
$LN75@face_trian:
	fst	QWORD PTR [eax+ecx*8]
	inc	ecx
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN75@face_trian
	mov	edx, DWORD PTR _dymem
$LN321@face_trian:

; 55   :   fe = first_fe = get_facet_fe(f_id);

	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR tv2441[ebp], ecx
	jne	SHORT $LN99@face_trian
	xor	ecx, ecx
	jmp	SHORT $LN98@face_trian
$LN99@face_trian:
	mov	ecx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [ecx+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN98@face_trian
	xor	ecx, 134217728				; 08000000H
$LN98@face_trian:
	mov	DWORD PTR _first_fe$[ebp], ecx
	mov	DWORD PTR _fe$[ebp], ecx

; 56   :   if ( valid_id(fe) ) do

	test	ecx, 268435456				; 10000000H
	je	$LN69@face_trian
$LN71@face_trian:

; 57   :   { REAL w[MAXCOORD];
; 58   : 
; 59   :     x = get_coord(get_fe_tailv(fe));

	mov	edi, DWORD PTR _fe$[ebp]
	mov	eax, DWORD PTR _web+460
	mov	ebx, edi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	and	edi, 134217728				; 08000000H
	xor	eax, edi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN105@face_trian
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+216
	add	eax, DWORD PTR [ecx+edx+304]
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN104@face_trian
$LN105@face_trian:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	eax, DWORD PTR [eax+ecx]
$LN104@face_trian:
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	esi, DWORD PTR [eax+edx+64]

; 60   :     if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	$LN317@face_trian

; 61   :     { (*sym_wrap)(x,w,wrap);

	mov	ecx, DWORD PTR _wrap$[ebp]
	fstp	ST(0)
	push	ecx
	lea	edx, DWORD PTR _w$89068[ebp]
	push	edx
	push	esi
	call	DWORD PTR _sym_wrap

; 62   :       x = w;
; 63   :       wrap = (*sym_compose)(wrap,get_fe_wrap(fe));

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	xor	eax, edi
	mov	edi, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edi+784]
	mov	ecx, DWORD PTR [edx+ecx]
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR _w$89068[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN112@face_trian
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN113@face_trian
$LN112@face_trian:
	mov	eax, ecx
$LN113@face_trian:
	mov	edx, DWORD PTR _wrap$[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose
	fldz
	mov	edx, DWORD PTR _dymem
	add	esp, 8
	mov	DWORD PTR _wrap$[ebp], eax
$LN317@face_trian:

; 64   :     }
; 65   :     for ( i = 0 ; i < SDIM ; i++ ) 

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN65@face_trian
	mov	eax, DWORD PTR _centerx$[ebp]
	sub	esi, eax
$LN67@face_trian:

; 66   :       centerx[i] += x[i];

	fld	QWORD PTR [esi+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN67@face_trian

; 64   :     }
; 65   :     for ( i = 0 ; i < SDIM ; i++ ) 

	mov	edx, DWORD PTR _dymem
$LN65@face_trian:

; 67   :     fe = get_next_edge(fe);

	test	DWORD PTR _fe$[ebp], 134217728		; 08000000H
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [ebx+eax]
	je	SHORT $LN115@face_trian
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN480@face_trian
$LN115@face_trian:
	mov	eax, DWORD PTR [ecx+32]
$LN480@face_trian:
	mov	DWORD PTR _fe$[ebp], eax

; 68   :   } while ( valid_id(fe) && !equal_id(fe,first_fe) );

	test	eax, 268435456				; 10000000H
	je	SHORT $LN64@face_trian
	cmp	eax, DWORD PTR _first_fe$[ebp]
	jne	$LN71@face_trian
$LN64@face_trian:
	mov	edi, DWORD PTR tv2402[ebp]
	mov	eax, DWORD PTR _centerx$[ebp]
$LN69@face_trian:

; 69   :   for ( i = 0 ; i < SDIM ; i++ ) centerx[i] /= edgecount;

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN322@face_trian
	fild	DWORD PTR _edgecount$[ebp]
$LN63@face_trian:
	fld	QWORD PTR [eax+ecx*8]
	inc	ecx
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax+ecx*8-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN63@face_trian
	mov	edx, DWORD PTR _dymem
	fstp	ST(0)
$LN322@face_trian:

; 70   : 
; 71   :   /* find centerpoint parameters for facet on boundary */
; 72   :   if ( get_fattr(f_id) & BOUNDARY )    /* not working for torus */

	mov	eax, DWORD PTR _web+236
	mov	edi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN370@face_trian

; 73   :   { REAL defaultp[MAXCOORD];
; 74   :     REAL *paramb,*parammid,*xb;
; 75   :     vertex_id base_v;
; 76   :     REAL s[MAXCOORD];
; 77   :     REAL midp[MAXCOORD];
; 78   :     int no_interp = 0;
; 79   :     int vercount = 0;
; 80   : 
; 81   :     set_attr(center,BOUNDARY);

	mov	ecx, DWORD PTR _center$[ebp]
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR tv2418[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 128			; 00000080H
	xor	edi, edi
	mov	DWORD PTR [eax+12], edx

; 82   :     bdry = get_facet_boundary(f_id);

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	mov	edx, DWORD PTR _dymem
	mov	DWORD PTR _no_interp$89092[ebp], edi
	mov	DWORD PTR _vercount$89093[ebp], edi
	cmp	eax, edi
	je	SHORT $LN80@face_trian
	mov	esi, DWORD PTR _web+236
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	ebx, DWORD PTR tv2402[ebp]
	mov	eax, DWORD PTR [eax+edx+64]
	mov	esi, DWORD PTR [esi+ebx*4]
	mov	eax, DWORD PTR [eax+esi]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN481@face_trian
$LN80@face_trian:
	xor	eax, eax
$LN481@face_trian:

; 83   :     set_boundary_num(center,bdry->num);

	mov	esi, DWORD PTR _V_BOUNDARY_ATTR
	mov	DWORD PTR _bdry$[ebp], eax
	cmp	esi, edi
	je	SHORT $LN82@face_trian
	imul	esi, 240				; 000000f0H
	add	esi, DWORD PTR _web+104
	mov	edx, DWORD PTR [esi+edx+64]
	mov	esi, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ecx+esi]
	mov	esi, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+ecx], esi
	mov	edx, DWORD PTR _dymem
$LN82@face_trian:

; 84   :     for ( i = 0 ; i < bdry->pcount ; i++ ) midp[i] = 0.;

	mov	ebx, DWORD PTR [eax+40]
	mov	DWORD PTR tv2564[ebp], ebx
	cmp	ebx, edi
	jle	SHORT $LN59@face_trian
	mov	ecx, ebx
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	lea	edi, DWORD PTR _midp$89091[ebp]
	rep stosd
$LN59@face_trian:

; 85   : 
; 86   :     /* center parameters extrapolate from a vertex */
; 87   :     /* try to find a vertex on same boundary */
; 88   :     base_v = NULLVERTEX;
; 89   :     fe = first_fe = get_facet_fe(f_id);

	cmp	DWORD PTR tv2441[ebp], 0
	mov	esi, DWORD PTR _NULLVERTEX
	jne	SHORT $LN121@face_trian
	xor	eax, eax
	jmp	SHORT $LN120@face_trian
$LN121@face_trian:
	test	DWORD PTR _f_id$GSCopy$[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR tv2402[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+28]
	je	SHORT $LN120@face_trian
	xor	eax, 134217728				; 08000000H
$LN120@face_trian:
	mov	DWORD PTR _first_fe$[ebp], eax
	mov	DWORD PTR _fe$[ebp], eax

; 90   :     if ( valid_id(fe) ) do

	test	eax, 268435456				; 10000000H
	je	$LN53@face_trian
$LN55@face_trian:

; 91   :     { base_v = get_fe_tailv(fe);

	mov	esi, DWORD PTR _web+460
	mov	edi, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	esi, eax
	mov	eax, DWORD PTR [ecx+20]
	and	esi, 134217728				; 08000000H
	xor	eax, esi
	mov	DWORD PTR tv2574[ebp], ecx
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN127@face_trian
	mov	ebx, DWORD PTR _web+636
	lea	esi, DWORD PTR [esi+ebx*4]
	mov	esi, DWORD PTR [esi+ecx]
	jmp	SHORT $LN482@face_trian
$LN127@face_trian:
	mov	esi, DWORD PTR [ecx+esi]
$LN482@face_trian:

; 92   :       if ( bdry == get_boundary(get_fe_tailv(fe)) )

	mov	ebx, DWORD PTR _V_BOUNDARY_ATTR
	mov	DWORD PTR _base_v$89089[ebp], esi
	test	ebx, ebx
	je	SHORT $LN84@face_trian
	test	eax, 134217728				; 08000000H
	je	SHORT $LN133@face_trian
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+edi*4]
	mov	ecx, DWORD PTR [eax+ecx]
	jmp	SHORT $LN132@face_trian
$LN133@face_trian:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [ecx+eax]
$LN132@face_trian:
	mov	eax, DWORD PTR _web+12
	imul	ebx, 240				; 000000f0H
	add	ebx, DWORD PTR _web+104
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [ebx+edx+64]
	mov	eax, DWORD PTR [ecx+eax]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN85@face_trian
$LN84@face_trian:
	xor	eax, eax
$LN85@face_trian:
	cmp	DWORD PTR _bdry$[ebp], eax
	jne	$LN52@face_trian

; 93   :       { REAL *p = get_param(base_v);

	mov	eax, DWORD PTR _web+12

; 94   :         for ( i = 0 ; i < bdry->pcount ; i++ ) 

	mov	ebx, DWORD PTR tv2564[ebp]
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _web+104
	add	edi, DWORD PTR [ecx+edx+544]
	xor	ecx, ecx
	cmp	ebx, 4
	jl	SHORT $LN319@face_trian

; 95   :           midp[i] += p[i];

	mov	esi, edi
	add	ebx, -3					; fffffffdH
	neg	esi
	lea	edx, DWORD PTR _midp$89091[ebp+esi]
	lea	eax, DWORD PTR [edi+16]
	lea	esi, DWORD PTR _midp$89091[ebp+esi+8]
$LN307@face_trian:
	fld	QWORD PTR [eax-16]
	add	ecx, 4
	fadd	QWORD PTR _midp$89091[ebp+ecx*8-32]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR _midp$89091[ebp+ecx*8-32]
	fld	QWORD PTR [eax-40]
	fadd	QWORD PTR _midp$89091[ebp+ecx*8-24]
	fstp	QWORD PTR _midp$89091[ebp+ecx*8-24]
	fld	QWORD PTR [eax-32]
	fadd	QWORD PTR [edx+eax-32]
	fstp	QWORD PTR [edx+eax-32]
	fld	QWORD PTR [eax-24]
	fadd	QWORD PTR [esi+eax-32]
	fstp	QWORD PTR [esi+eax-32]
	cmp	ecx, ebx
	jl	SHORT $LN307@face_trian
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR _base_v$89089[ebp]
	mov	ebx, DWORD PTR tv2564[ebp]
$LN319@face_trian:

; 94   :         for ( i = 0 ; i < bdry->pcount ; i++ ) 

	cmp	ecx, ebx
	jge	$LN309@face_trian
	lea	eax, DWORD PTR _midp$89091[ebp]
	sub	edi, eax
$LC51@face_trian:
	lea	eax, DWORD PTR [edi+ecx*8]

; 95   :           midp[i] += p[i];

	fld	QWORD PTR _midp$89091[ebp+eax]
	inc	ecx
	fadd	QWORD PTR _midp$89091[ebp+ecx*8-8]
	fstp	QWORD PTR _midp$89091[ebp+ecx*8-8]
	cmp	ecx, ebx
	jl	SHORT $LC51@face_trian

; 96   :       }
; 97   :       else if ( extra_bdry_attr && 

	jmp	$LN309@face_trian
$LN52@face_trian:

; 98   :          (*(int*)get_extra(base_v,extra_bdry_attr) == bdry->num) )

	mov	edi, DWORD PTR _extra_bdry_attr
	test	edi, edi
	je	$LN320@face_trian
	mov	eax, esi
	imul	edi, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ebx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	mov	ecx, esi
	add	edi, eax
	mov	edi, DWORD PTR [edi+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _bdry$[ebp]
	mov	edi, DWORD PTR [ecx+edi]
	cmp	edi, DWORD PTR [ebx+44]

; 100  :         for ( i = 0 ; i < bdry->pcount ; i++ ) 

	mov	ebx, DWORD PTR tv2564[ebp]
	jne	$LN47@face_trian

; 99   :       { REAL *p = (REAL*)get_extra(base_v,extra_bdry_param_attr);

	mov	edi, DWORD PTR _extra_bdry_param_attr
	imul	edi, 240				; 000000f0H
	add	edi, eax
	mov	edi, DWORD PTR [edi+edx+64]
	add	edi, ecx

; 100  :         for ( i = 0 ; i < bdry->pcount ; i++ ) 

	xor	ecx, ecx
	cmp	ebx, 4
	jl	SHORT $LN311@face_trian

; 101  :           midp[i] += p[i];

	mov	esi, edi
	add	ebx, -3					; fffffffdH
	neg	esi
	lea	edx, DWORD PTR _midp$89091[ebp+esi]
	lea	eax, DWORD PTR [edi+16]
	lea	esi, DWORD PTR _midp$89091[ebp+esi+8]
$LN308@face_trian:
	fld	QWORD PTR [eax-16]
	add	ecx, 4
	fadd	QWORD PTR _midp$89091[ebp+ecx*8-32]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR _midp$89091[ebp+ecx*8-32]
	fld	QWORD PTR [eax-40]
	fadd	QWORD PTR _midp$89091[ebp+ecx*8-24]
	fstp	QWORD PTR _midp$89091[ebp+ecx*8-24]
	fld	QWORD PTR [eax-32]
	fadd	QWORD PTR [edx+eax-32]
	fstp	QWORD PTR [edx+eax-32]
	fld	QWORD PTR [eax-24]
	fadd	QWORD PTR [esi+eax-32]
	fstp	QWORD PTR [esi+eax-32]
	cmp	ecx, ebx
	jl	SHORT $LN308@face_trian
	mov	ebx, DWORD PTR tv2564[ebp]
	mov	esi, DWORD PTR _base_v$89089[ebp]
	mov	edx, DWORD PTR _dymem
$LN311@face_trian:

; 100  :         for ( i = 0 ; i < bdry->pcount ; i++ ) 

	cmp	ecx, ebx
	jge	SHORT $LN309@face_trian
	lea	eax, DWORD PTR _midp$89091[ebp]
	sub	edi, eax
$LC46@face_trian:
	lea	eax, DWORD PTR [edi+ecx*8]

; 101  :           midp[i] += p[i];

	fld	QWORD PTR _midp$89091[ebp+eax]
	inc	ecx
	fadd	QWORD PTR _midp$89091[ebp+ecx*8-8]
	fstp	QWORD PTR _midp$89091[ebp+ecx*8-8]
	cmp	ecx, ebx
	jl	SHORT $LC46@face_trian

; 102  :       }
; 103  :       else no_interp = 1;

	jmp	SHORT $LN309@face_trian
$LN320@face_trian:
	mov	ebx, DWORD PTR tv2564[ebp]
$LN47@face_trian:
	mov	DWORD PTR _no_interp$89092[ebp], 1
$LN309@face_trian:

; 104  :       vercount++;

	inc	DWORD PTR _vercount$89093[ebp]

; 105  :       fe = get_next_edge(fe);

	test	DWORD PTR _fe$[ebp], 134217728		; 08000000H
	je	SHORT $LN141@face_trian
	mov	ecx, DWORD PTR tv2574[ebp]
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN483@face_trian
$LN141@face_trian:
	mov	eax, DWORD PTR tv2574[ebp]
	mov	eax, DWORD PTR [eax+32]
$LN483@face_trian:
	mov	DWORD PTR _fe$[ebp], eax

; 106  :     } while ( valid_id(fe) && !equal_id(fe,first_fe) );

	test	eax, 268435456				; 10000000H
	je	SHORT $LN53@face_trian
	cmp	eax, DWORD PTR _first_fe$[ebp]
	jne	$LN55@face_trian
$LN53@face_trian:

; 107  :     if ( valid_id(base_v) && (bdry == get_boundary(base_v)) )

	test	esi, 268435456				; 10000000H
	je	$LN323@face_trian
	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN86@face_trian
	mov	edi, DWORD PTR _web+12
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	ecx, esi
	mov	eax, DWORD PTR [eax+edx+64]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	eax, DWORD PTR [ecx+eax]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN87@face_trian
$LN86@face_trian:
	xor	eax, eax
$LN87@face_trian:
	mov	ecx, DWORD PTR _bdry$[ebp]
	cmp	ecx, eax
	jne	SHORT $LN41@face_trian

; 108  :     { paramb = get_param(base_v);

	mov	ecx, DWORD PTR _web+12
	mov	ebx, DWORD PTR _web+104
	mov	eax, DWORD PTR [ebx+edx+544]

; 109  :       xb = get_coord(base_v);

	mov	edi, DWORD PTR [ebx+edx+64]
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+esi*4]

; 110  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	eax, esi
	mov	DWORD PTR _paramb$89086[ebp], eax
	add	edi, esi
	xor	eax, eax
	test	ecx, ecx
	jle	$LN37@face_trian
	lea	esi, DWORD PTR _s$89090[ebp]
	sub	edi, esi
$LN40@face_trian:
	lea	esi, DWORD PTR [edi+eax*8]

; 111  :         s[i] = xb[i];  /* displacement vector */

	fld	QWORD PTR _s$89090[ebp+esi]
	inc	eax
	fstp	QWORD PTR _s$89090[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN40@face_trian

; 112  :     }
; 113  :     else

	jmp	$LN37@face_trian
$LN323@face_trian:
	mov	ecx, DWORD PTR _bdry$[ebp]
$LN41@face_trian:

; 114  :     { paramb = defaultp;

	lea	edx, DWORD PTR _defaultp$89085[ebp]

; 115  :       for ( i = 0 ; i < bdry->pcount ; i++ ) 

	xor	eax, eax
	mov	DWORD PTR _paramb$89086[ebp], edx
	test	ebx, ebx
	jle	SHORT $LN470@face_trian
$LN36@face_trian:

; 116  : 		 defaultp[i] = 0.0;

	fst	QWORD PTR _defaultp$89085[ebp+eax*8]
	inc	eax
	cmp	eax, DWORD PTR [ecx+40]
	jl	SHORT $LN36@face_trian
$LN470@face_trian:

; 117  :       for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	fstp	ST(0)
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN31@face_trian
	mov	edi, DWORD PTR _bdry$[ebp]
	add	edi, 48					; 00000030H
$LL33@face_trian:

; 118  :         s[i] = eval(bdry->coordf[i],defaultp,NULLID,NULL);

	mov	ecx, DWORD PTR [edi]
	push	0
	push	0
	lea	eax, DWORD PTR _defaultp$89085[ebp]
	push	eax
	push	ecx
	call	_eval
	fstp	QWORD PTR _s$89090[ebp+esi*8]
	inc	esi
	add	esp, 16					; 00000010H
	add	edi, 4
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL33@face_trian
$LN31@face_trian:

; 119  :       sprintf(msg,"Could not find vertex on same boundary as facet %s.\n",
; 120  :         ELNAME(f_id)); /* not sure if we want to output this or not */

	cmp	DWORD PTR tv2441[ebp], 0
	je	SHORT $LN88@face_trian
	mov	edx, DWORD PTR tv2402[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN89@face_trian
$LN88@face_trian:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN89@face_trian:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0DF@MOLBPHPK@Could?5not?5find?5vertex?5on?5same?5bo@
	push	eax
	call	_sprintf
	fldz
	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _dymem
	mov	ebx, DWORD PTR _web+104
	add	esp, 12					; 0000000cH
$LN37@face_trian:

; 121  :     }
; 122  : 
; 123  :     parammid = get_param(center);

	mov	eax, DWORD PTR tv2418[ebp]
	mov	esi, DWORD PTR _web+12
	mov	edi, DWORD PTR [eax+esi]

; 124  :     if ( (bdry->pcount <  2) && (vercount == 0) )

	mov	eax, DWORD PTR _bdry$[ebp]
	mov	esi, DWORD PTR [eax+40]
	add	edi, DWORD PTR [ebx+edx+544]
	cmp	esi, 2
	jge	SHORT $LN460@face_trian
	cmp	DWORD PTR _vercount$89093[ebp], 0
	jne	SHORT $LN460@face_trian

; 125  :     { for ( i = 0 ; i < bdry->pcount ; i++ )

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN463@face_trian
	mov	ecx, DWORD PTR _bdry$[ebp]
$LN29@face_trian:

; 126  :          parammid[i] = 0;

	fst	QWORD PTR [edi+eax*8]
	inc	eax
	cmp	eax, DWORD PTR [ecx+40]
	jl	SHORT $LN29@face_trian

; 125  :     { for ( i = 0 ; i < bdry->pcount ; i++ )

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _dymem
$LN463@face_trian:

; 127  :       for ( k = 0 ; k < SDIM ; k++ )

	xor	esi, esi
	fstp	ST(0)
	test	ecx, ecx
	jle	SHORT $LN24@face_trian
	mov	ebx, DWORD PTR _bdry$[ebp]
	add	ebx, 48					; 00000030H
$LL26@face_trian:

; 128  :         centerx[k] = eval(bdry->coordf[k],parammid,center,NULL);

	mov	ecx, DWORD PTR _center$[ebp]
	mov	edx, DWORD PTR [ebx]
	push	0
	push	ecx
	push	edi
	push	edx
	call	_eval
	mov	eax, DWORD PTR _centerx$[ebp]
	fstp	QWORD PTR [eax+esi*8]
	mov	ecx, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	add	ebx, 4
	cmp	esi, ecx
	jl	SHORT $LL26@face_trian

; 127  :       for ( k = 0 ; k < SDIM ; k++ )

	mov	edx, DWORD PTR _dymem
	jmp	SHORT $LN24@face_trian
$LN460@face_trian:

; 124  :     if ( (bdry->pcount <  2) && (vercount == 0) )

	fstp	ST(0)
$LN24@face_trian:

; 129  :     } 
; 130  :     if ( (bdry->pcount < 2) || (interp_bdry_param && !no_interp) )

	mov	ebx, DWORD PTR _bdry$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	cmp	eax, 2
	jl	SHORT $LN315@face_trian
	cmp	DWORD PTR _interp_bdry_param, 0
	je	SHORT $LN23@face_trian
	cmp	DWORD PTR _no_interp$89092[ebp], 0
	je	SHORT $LN315@face_trian
$LN23@face_trian:

; 135  :     } 
; 136  :     else b_extrapolate(bdry,s,centerx,centerx,paramb,parammid,center);

	mov	ecx, DWORD PTR _center$[ebp]
	mov	edx, DWORD PTR _paramb$89086[ebp]
	mov	eax, DWORD PTR _centerx$[ebp]
	push	ecx
	push	edi
	push	edx
	push	eax
	push	eax
	lea	eax, DWORD PTR _s$89090[ebp]
	push	eax
	push	ebx
	call	_b_extrapolate
	mov	edx, DWORD PTR _dymem
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN324@face_trian
$LN315@face_trian:

; 131  :     { for ( i = 0 ; i < bdry->pcount ; i++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN316@face_trian
	fild	DWORD PTR _vercount$89093[ebp]
	lea	ecx, DWORD PTR _midp$89091[ebp]
	mov	eax, edi
	sub	ecx, edi
$LN21@face_trian:

; 132  :          parammid[i] = midp[i]/vercount;

	fld	QWORD PTR [ecx+eax]
	inc	esi
	fdiv	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	esi, DWORD PTR [ebx+40]
	jl	SHORT $LN21@face_trian

; 131  :     { for ( i = 0 ; i < bdry->pcount ; i++ )

	mov	ecx, DWORD PTR _web+616
	fstp	ST(0)
	mov	edx, DWORD PTR _dymem
$LN316@face_trian:

; 133  :       for ( k = 0 ; k < SDIM ; k++ )

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN324@face_trian
	add	ebx, 48					; 00000030H
$LL18@face_trian:

; 134  :         centerx[k] = eval(bdry->coordf[k],parammid,center,NULL);

	mov	ecx, DWORD PTR _center$[ebp]
	mov	edx, DWORD PTR [ebx]
	push	0
	push	ecx
	push	edi
	push	edx
	call	_eval
	mov	eax, DWORD PTR _centerx$[ebp]
	fstp	QWORD PTR [eax+esi*8]
	inc	esi
	add	esp, 16					; 00000010H
	add	ebx, 4
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL18@face_trian

; 133  :       for ( k = 0 ; k < SDIM ; k++ )

	mov	edx, DWORD PTR _dymem
	jmp	SHORT $LN324@face_trian
$LN370@face_trian:
	fstp	ST(0)
$LN324@face_trian:

; 137  :   }
; 138  : 
; 139  :   /* install edge from rim to center */
; 140  :   fe = get_facet_fe(f_id);  /* canonical starting point */

	cmp	DWORD PTR tv2441[ebp], 0
	mov	esi, DWORD PTR tv2402[ebp]
	jne	SHORT $LN145@face_trian
	xor	eax, eax
	jmp	SHORT $LN144@face_trian
$LN145@face_trian:
	test	DWORD PTR _f_id$GSCopy$[ebp], 134217728	; 08000000H
	mov	ecx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [eax+28]
	je	SHORT $LN144@face_trian
	xor	eax, 134217728				; 08000000H
$LN144@face_trian:

; 141  :   pre_fe = get_prev_edge(fe);

	mov	edi, DWORD PTR _web+460
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR tv2512[ebp], ecx
	mov	DWORD PTR _fe$[ebp], eax
	mov	ecx, eax
	je	SHORT $LN149@face_trian
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR tv2454[ebp], ecx
	mov	ecx, DWORD PTR [ecx+edi]
	mov	ebx, DWORD PTR [ecx+32]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN148@face_trian
$LN149@face_trian:
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR tv2454[ebp], ecx
	mov	ecx, DWORD PTR [ecx+edi]
	mov	ebx, DWORD PTR [ecx+28]
$LN148@face_trian:

; 142  :   rimv = get_fe_tailv(fe);

	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN155@face_trian
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+216
	add	eax, DWORD PTR [ecx+edx+304]
	mov	edx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN154@face_trian
$LN155@face_trian:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR [ecx+edx+304]
	mov	eax, DWORD PTR [eax+edx]
$LN154@face_trian:

; 143  :   spoke = new_edge(rimv,center,f_id);

	mov	ecx, DWORD PTR _f_id$GSCopy$[ebp]
	mov	edx, DWORD PTR _center$[ebp]
	push	ecx
	push	edx
	push	eax
	call	_new_edge
	mov	edi, eax

; 144  :   if ( get_fattr(f_id) & FIXED )

	mov	eax, DWORD PTR _web+236
	mov	eax, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	or	eax, ecx
	je	SHORT $LN332@face_trian

; 145  :      set_attr(spoke,FIXED);

	mov	ecx, edi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax+12], ecx
$LN332@face_trian:

; 146  :   if ( get_fattr(f_id) & NO_REFINE )

	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 16777216				; 01000000H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN160@face_trian

; 147  :      set_attr(spoke,NO_REFINE);

	mov	eax, edi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 16777216		; 01000000H
	mov	DWORD PTR [eax+12], ecx
$LN160@face_trian:

; 148  :      
; 149  :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN162@face_trian

; 150  :     set_edge_wrap(spoke,0);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN164@face_trian
	push	0
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN165@face_trian
$LN164@face_trian:
	xor	eax, eax
$LN165@face_trian:
	mov	ecx, DWORD PTR _web+124
	mov	esi, DWORD PTR _dymem
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+esi+784]
	mov	DWORD PTR [edx+ecx], eax
$LN162@face_trian:

; 151  :   fe_in = new_facetedge(f_id,spoke);

	mov	edx, DWORD PTR _f_id$GSCopy$[ebp]
	push	edi
	push	edx
	call	_new_facetedge
	mov	esi, eax

; 152  :   set_edge_fe(spoke,fe_in);

	mov	eax, edi
	shr	eax, 27					; 0000001bH
	add	esp, 8
	and	eax, 1
	mov	ecx, esi
	mov	DWORD PTR tv2848[ebp], eax
	je	SHORT $LN327@face_trian
	xor	ecx, 134217728				; 08000000H
$LN327@face_trian:
	mov	edx, DWORD PTR _web+124
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2831[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	mov	DWORD PTR [eax+28], ecx
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 153  :   set_prev_edge(fe_in,pre_fe);

	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv2862[ebp], eax
	je	SHORT $LN331@face_trian
	test	esi, 134217728				; 08000000H
	je	SHORT $LN170@face_trian
	mov	eax, DWORD PTR _web+460
	mov	ecx, ebx
	xor	ecx, 134217728				; 08000000H
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [edx+32], ecx
	jmp	SHORT $LN169@face_trian
$LN170@face_trian:
	mov	ecx, DWORD PTR _web+460
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+28], ebx
$LN169@face_trian:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN331@face_trian:

; 154  :   set_next_edge(pre_fe,fe_in);

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN174@face_trian
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN175@face_trian
	mov	ecx, DWORD PTR _web+460
	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	and	ebx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR [edx+28], eax
	jmp	SHORT $LN174@face_trian
$LN175@face_trian:
	mov	eax, DWORD PTR _web+460
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [ecx+32], esi
$LN174@face_trian:

; 155  :   fe_out = new_facetedge(f_id,edge_inverse(spoke));

	mov	eax, DWORD PTR _f_id$GSCopy$[ebp]
	mov	edx, edi
	xor	edx, 134217728				; 08000000H
	push	edx
	push	eax
	call	_new_facetedge

; 156  :   set_prev_edge(fe_out,fe_in);

	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	add	esp, 8
	and	ecx, 1
	mov	DWORD PTR tv2895[ebp], ecx
	je	SHORT $LN328@face_trian
	test	eax, 134217728				; 08000000H
	je	SHORT $LN180@face_trian
	mov	ebx, DWORD PTR _web+460
	mov	ecx, esi
	xor	ecx, 134217728				; 08000000H
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [edx+32], ecx
	jmp	SHORT $LN179@face_trian
$LN180@face_trian:
	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+28], esi
$LN179@face_trian:
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
$LN328@face_trian:

; 157  :   set_next_edge(fe_in,fe_out);

	cmp	DWORD PTR tv2862[ebp], 0
	je	SHORT $LN184@face_trian
	test	esi, 134217728				; 08000000H
	je	SHORT $LN185@face_trian
	mov	ebx, DWORD PTR _web+460
	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [edx+28], ecx
	jmp	SHORT $LN184@face_trian
$LN185@face_trian:
	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+32], eax
$LN184@face_trian:

; 158  :   set_prev_edge(fe,fe_out);

	mov	ecx, DWORD PTR _fe$[ebp]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN192@face_trian
	cmp	DWORD PTR tv2512[ebp], 0
	mov	edx, DWORD PTR _web+460
	mov	ebx, DWORD PTR tv2454[ebp]
	mov	edx, DWORD PTR [ebx+edx]
	je	SHORT $LN190@face_trian
	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [edx+32], ecx
	mov	ecx, DWORD PTR _fe$[ebp]
	jmp	SHORT $LN189@face_trian
$LN190@face_trian:
	mov	DWORD PTR [edx+28], eax
$LN189@face_trian:
	mov	edx, DWORD PTR _global_timestamp
	inc	edx
	mov	DWORD PTR _global_timestamp, edx
	mov	DWORD PTR _top_timestamp, edx
$LN192@face_trian:

; 159  :   set_next_edge(fe_out,fe);

	cmp	DWORD PTR tv2895[ebp], 0
	je	SHORT $LN329@face_trian
	mov	ebx, DWORD PTR _web+460
	mov	edx, eax
	test	eax, 134217728				; 08000000H
	je	SHORT $LN195@face_trian
	xor	ecx, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [edx+28], ecx
	jmp	SHORT $LN329@face_trian
$LN195@face_trian:
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [edx+32], ecx
$LN329@face_trian:

; 160  :   set_next_facet(fe_in,fe_inverse(fe_out));

	mov	ecx, eax
	xor	ecx, 134217728				; 08000000H
	cmp	DWORD PTR tv2862[ebp], 0
	mov	DWORD PTR tv2913[ebp], ecx
	je	$LN207@face_trian
	mov	ebx, DWORD PTR _web+460
	mov	edx, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN200@face_trian
	xor	ecx, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [edx+36], ecx
	mov	ecx, DWORD PTR tv2913[ebp]
	jmp	SHORT $LN199@face_trian
$LN200@face_trian:
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [edx+40], ecx
$LN199@face_trian:

; 161  :   set_prev_facet(fe_in,fe_inverse(fe_out));

	cmp	DWORD PTR tv2862[ebp], 0
	je	SHORT $LN207@face_trian
	mov	ebx, DWORD PTR _web+460
	mov	edx, esi
	test	esi, 134217728				; 08000000H
	je	SHORT $LN205@face_trian
	xor	ecx, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [edx+40], ecx
	jmp	SHORT $LN204@face_trian
$LN205@face_trian:
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [edx+36], ecx
$LN204@face_trian:
	mov	ecx, DWORD PTR _global_timestamp
	inc	ecx
	mov	DWORD PTR _global_timestamp, ecx
	mov	DWORD PTR _top_timestamp, ecx
$LN207@face_trian:

; 162  :   set_next_facet(fe_out,fe_inverse(fe_in));

	xor	esi, 134217728				; 08000000H
	cmp	DWORD PTR tv2895[ebp], 0
	je	$LN217@face_trian
	test	eax, 134217728				; 08000000H
	je	SHORT $LN210@face_trian
	mov	ebx, DWORD PTR _web+460
	mov	ecx, esi
	xor	ecx, 134217728				; 08000000H
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [edx+36], ecx
	jmp	SHORT $LN209@face_trian
$LN210@face_trian:
	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+40], esi
$LN209@face_trian:

; 163  :   set_prev_facet(fe_out,fe_inverse(fe_in));

	cmp	DWORD PTR tv2895[ebp], 0
	je	SHORT $LN217@face_trian
	test	eax, 134217728				; 08000000H
	je	SHORT $LN215@face_trian
	mov	edx, DWORD PTR _web+460
	xor	esi, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+40], esi
	jmp	SHORT $LN214@face_trian
$LN215@face_trian:
	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+36], esi
$LN214@face_trian:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN217@face_trian:

; 164  :   
; 165  :   if ( get_fattr(f_id) & BOUNDARY )    

	mov	eax, DWORD PTR _web+236
	mov	ebx, DWORD PTR tv2402[ebp]
	mov	edx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv2409[ebp+4], eax
	mov	eax, ecx
	and	eax, 128				; 00000080H
	xor	esi, esi
	or	eax, esi
	je	$LN11@face_trian

; 166  :   { set_attr(spoke,BOUNDARY);

	mov	edx, DWORD PTR tv2831[ebp]
	shr	edi, 29					; 0000001dH
	imul	edi, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edi+12]
	mov	eax, DWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 128			; 00000080H
	mov	DWORD PTR [eax+12], ecx

; 167  :     bdry = get_facet_boundary(f_id);

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	mov	edx, DWORD PTR _dymem
	test	eax, eax
	je	SHORT $LN90@face_trian
	mov	ecx, DWORD PTR _web+236
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN91@face_trian
$LN90@face_trian:
	xor	eax, eax
$LN91@face_trian:

; 168  :     set_edge_boundary_num(spoke,bdry->num);

	mov	ecx, DWORD PTR _E_BOUNDARY_ATTR
	test	ecx, ecx
	je	$LN326@face_trian
	mov	esi, DWORD PTR tv2831[ebp]
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+edx+64]
	mov	ecx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+ecx], eax

; 169  :   }
; 170  :   else if ( get_fattr(f_id) & CONSTRAINT )    

	jmp	$LN326@face_trian
$LN11@face_trian:
	mov	eax, ecx
	and	eax, 1024				; 00000400H
	xor	esi, esi
	or	eax, esi
	je	$LN326@face_trian

; 171  :   { ATTR attr = get_fattr(f_id) & (BDRY_ENERGY | BDRY_CONTENT | CONSTRAINT );
; 172  :     conmap_t * conmap = get_f_constraint_map(f_id);

	mov	eax, DWORD PTR _web+328
	and	ecx, 5632				; 00001600H
	mov	ebx, ecx
	mov	ecx, DWORD PTR _dymem
	cmp	DWORD PTR [eax+ecx+88], esi
	je	SHORT $LN94@face_trian
	mov	esi, DWORD PTR [eax+ecx+64]
	add	esi, edx
	jmp	SHORT $LN95@face_trian
$LN94@face_trian:
	mov	esi, OFFSET _nullcon
$LN95@face_trian:

; 173  : 
; 174  :     set_attr(spoke,attr);

	mov	eax, DWORD PTR tv2831[ebp]
	mov	ecx, edi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	eax, DWORD PTR [edx+eax]

; 175  :     set_attr(center,attr);

	mov	edx, DWORD PTR _center$[ebp]
	or	DWORD PTR [eax+8], ebx
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	xor	ecx, ecx
	or	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR _web[edx+12]
	mov	edx, DWORD PTR tv2418[ebp]
	mov	eax, DWORD PTR [eax+edx]
	or	DWORD PTR [eax+8], ebx
	or	DWORD PTR [eax+12], ecx

; 176  :     set_e_conmap(spoke,conmap);

	push	esi
	push	edi
	call	_set_e_conmap

; 177  :     set_v_conmap(center,conmap);

	mov	edi, DWORD PTR _center$[ebp]
	push	esi
	push	edi
	call	_set_v_conmap

; 178  :     project_v_constr(center,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	push	1
	push	1
	push	edi
	call	_project_v_constr
	add	esp, 28					; 0000001cH

; 179  :     if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	SHORT $LN326@face_trian

; 180  :     { vertex_id mid = get_edge_midv(spoke);

	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR tv2831[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	edi, DWORD PTR [edx+eax+8]

; 181  :       set_attr(mid,attr);

	mov	ecx, edi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+12]
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	or	DWORD PTR [eax+8], ebx
	xor	ecx, ecx
	or	DWORD PTR [eax+12], ecx

; 182  :       set_v_conmap(mid,conmap);

	push	esi
	push	edi
	call	_set_v_conmap

; 183  :       project_v_constr(mid,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	push	1
	push	1
	push	edi
	call	_project_v_constr
	add	esp, 20					; 00000014H
$LN326@face_trian:

; 184  :     }
; 185  :   }
; 186  : 
; 187  :   /* now go around cutting off triangles */
; 188  :   fe_in = get_edge_fe(spoke);

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv2831[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN228@face_trian
	xor	ebx, ebx
	jmp	SHORT $LN303@face_trian
$LN228@face_trian:
	cmp	DWORD PTR tv2848[ebp], 0
	mov	eax, DWORD PTR [eax+28]
	je	SHORT $LN330@face_trian
	xor	eax, 134217728				; 08000000H
$LN330@face_trian:
	mov	ebx, eax
$LN303@face_trian:
	mov	edx, DWORD PTR _fe$[ebp]
	npad	1
$LL7@face_trian:

; 189  :   while ( !equal_id(get_next_edge(fe),fe_in) )

	mov	ecx, DWORD PTR _web+460
	mov	edi, edx
	mov	eax, edx
	shr	edi, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	and	edi, 1
	mov	eax, DWORD PTR [ecx+eax*4]
	je	SHORT $LN232@face_trian
	mov	ecx, DWORD PTR [eax+28]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN231@face_trian
$LN232@face_trian:
	mov	ecx, DWORD PTR [eax+32]
$LN231@face_trian:
	cmp	ecx, ebx
	je	SHORT $LN6@face_trian

; 190  :   { next_fe = get_next_edge(fe);

	test	edi, edi
	je	SHORT $LN236@face_trian
	mov	esi, DWORD PTR [eax+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN235@face_trian
$LN236@face_trian:
	mov	esi, DWORD PTR [eax+32]
$LN235@face_trian:

; 191  :     cross_cut(get_prev_edge(fe),fe);

	test	edi, edi
	je	SHORT $LN240@face_trian
	mov	eax, DWORD PTR [eax+32]
	xor	eax, 134217728				; 08000000H
	push	edx
	push	eax
	call	_cross_cut
	add	esp, 8

; 192  :     fe = next_fe;

	mov	edx, esi

; 193  :   }    

	jmp	SHORT $LL7@face_trian

; 191  :     cross_cut(get_prev_edge(fe),fe);

$LN240@face_trian:
	mov	eax, DWORD PTR [eax+28]
	push	edx
	push	eax
	call	_cross_cut
	add	esp, 8

; 192  :     fe = next_fe;

	mov	edx, esi

; 193  :   }    

	jmp	SHORT $LL7@face_trian
$LN6@face_trian:

; 194  : 
; 195  :  if ( web.symmetry_flag ) /* check for axial vertices */

	cmp	DWORD PTR _web+856, 0
	je	$LN305@face_trian

; 196  :  { fe = get_facet_fe(f_id);

	cmp	DWORD PTR tv2441[ebp], 0
	jne	SHORT $LN244@face_trian
	xor	edx, edx
	jmp	SHORT $LN243@face_trian
$LN244@face_trian:
	test	DWORD PTR _f_id$GSCopy$[ebp], 134217728	; 08000000H
	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR tv2402[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+28]
	je	SHORT $LN243@face_trian
	xor	edx, 134217728				; 08000000H
$LN243@face_trian:

; 197  :    for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	edi, DWORD PTR _web+216
	mov	ebx, DWORD PTR _web+124
	mov	DWORD PTR _i$[ebp], 0
	npad	3
$LL4@face_trian:

; 198  :    { if ( get_vattr(get_fe_tailv(fe)) & AXIAL_POINT )

	mov	ecx, DWORD PTR _web+460
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [esi+20]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN250@face_trian
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	add	eax, DWORD PTR [edi+ecx+304]
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN249@face_trian
$LN250@face_trian:
	mov	ecx, DWORD PTR [edi+ecx+304]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN249@face_trian:
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN274@face_trian

; 200  :      fe = get_next_edge(fe);

	test	edx, 134217728				; 08000000H
	je	SHORT $LN254@face_trian
	mov	edx, DWORD PTR [esi+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN3@face_trian
$LN254@face_trian:
	mov	edx, DWORD PTR [esi+32]
$LN3@face_trian:

; 197  :    for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, 3
	jl	$LL4@face_trian

; 198  :    { if ( get_vattr(get_fe_tailv(fe)) & AXIAL_POINT )

	jmp	SHORT $LN305@face_trian
$LN274@face_trian:

; 199  :      { set_facet_fe(f_id,fe); break; }

	push	edx
	mov	edx, DWORD PTR _f_id$GSCopy$[ebp]
	push	edx
	call	_set_facet_fe
	add	esp, 8
$LN305@face_trian:

; 201  :    }
; 202  :  }
; 203  : 
; 204  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp

; 205  : } /* end face_triangulate */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	inc	eax
	pop	esi
	xor	ecx, ebp
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_face_triangulate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EB@CHHAIOMC@Nonzero?5VOLCONST?5on?5body?5?$CFs?4?5?5Ma@ ; `string'
PUBLIC	??_C@_0EB@FHOHHAJP@Internal?5error?3?5rebody?$CI?$CJ?5cannot?5@ ; `string'
PUBLIC	??_C@_0EB@HLJGDIJO@Internal?5error?3?5rebody?$CI?$CJ?5cannot?5@ ; `string'
PUBLIC	??_C@_0DG@DPJIENAK@Internal?5error?3?5rebody?$CI?$CJ?5cannot?5@ ; `string'
PUBLIC	??_C@_0DB@ELLMBCDL@?$CCrebody?$CC?5not?5implemented?5for?5the@ ; `string'
PUBLIC	_rebody
;	COMDAT ??_C@_0EB@CHHAIOMC@Nonzero?5VOLCONST?5on?5body?5?$CFs?4?5?5Ma@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EB@CHHAIOMC@Nonzero?5VOLCONST?5on?5body?5?$CFs?4?5?5Ma@ DB 'Nonzer'
	DB	'o VOLCONST on body %s.  May need adjusting due to rebody.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@FHOHHAJP@Internal?5error?3?5rebody?$CI?$CJ?5cannot?5@
CONST	SEGMENT
??_C@_0EB@FHOHHAJP@Internal?5error?3?5rebody?$CI?$CJ?5cannot?5@ DB 'Inter'
	DB	'nal error: rebody() cannot find facet on stack (new body).', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@HLJGDIJO@Internal?5error?3?5rebody?$CI?$CJ?5cannot?5@
CONST	SEGMENT
??_C@_0EB@HLJGDIJO@Internal?5error?3?5rebody?$CI?$CJ?5cannot?5@ DB 'Inter'
	DB	'nal error: rebody() cannot find facet on stack (old body).', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@DPJIENAK@Internal?5error?3?5rebody?$CI?$CJ?5cannot?5@
CONST	SEGMENT
??_C@_0DG@DPJIENAK@Internal?5error?3?5rebody?$CI?$CJ?5cannot?5@ DB 'Inter'
	DB	'nal error: rebody() cannot find facet on stack.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@ELLMBCDL@?$CCrebody?$CC?5not?5implemented?5for?5the@
CONST	SEGMENT
??_C@_0DB@ELLMBCDL@?$CCrebody?$CC?5not?5implemented?5for?5the@ DB '"rebod'
	DB	'y" not implemented for the simplex model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\modify.c
CONST	ENDS
;	COMDAT _rebody
_TEXT	SEGMENT
_b_id$ = -40						; size = 4
tv1064 = -36						; size = 4
tv888 = -36						; size = 4
_new_bodies$ = -32					; size = 4
tv563 = -28						; size = 4
_stacktop$ = -28					; size = 4
_facetop$ = -24						; size = 4
_stack$ = -20						; size = 4
_ff_id$ = -16						; size = 4
_flist$ = -12						; size = 4
_f_id$ = -8						; size = 4
_faces_left$ = -4					; size = 4
_rebody	PROC						; COMDAT

; 1689 : { body_id b_id,old_b;

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	ebx

; 1690 :   int faces_left;
; 1691 :   int new_bodies = 0;

	xor	ebx, ebx

; 1692 :   int i;
; 1693 :   struct fface { facet_id f_id; int wrapflag; } *flist, *bf;
; 1694 :   facet_id *stack;  /* of known faces */
; 1695 :   int stacktop;
; 1696 :   int facetop;  /* length of flist */
; 1697 :   facet_id f_id,ff_id;
; 1698 :   facetedge_id fe;
; 1699 : 
; 1700 :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	mov	DWORD PTR _new_bodies$[ebp], ebx
	jne	SHORT $LN50@rebody

; 1701 :   { kb_error(3032,"\"rebody\" not implemented for the simplex model.\n",
; 1702 :        RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DB@ELLMBCDL@?$CCrebody?$CC?5not?5implemented?5for?5the@
	push	3032					; 00000bd8H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN50@rebody:

; 1703 :   }
; 1704 :   if ( web.representation == STRING ) return string_rebody();

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN49@rebody
	call	_string_rebody
	pop	ebx

; 1833 : 
; 1834 : }  // end rebody()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@rebody:

; 1705 : 
; 1706 :   /* working list of facets */
; 1707 :   flist = (struct fface *)temp_calloc(2*web.skel[FACET].count,
; 1708 :                 sizeof(struct fface));

	mov	eax, DWORD PTR _web+288
	push	esi
	push	edi
	push	1708					; 000006acH
	push	OFFSET ??_C@_08NGLEEPGD@MODIFY?4C?$AA@
	lea	ecx, DWORD PTR [eax+eax]
	push	8
	push	ecx
	call	_kb_temp_calloc

; 1709 :   stack = (facet_id *)temp_calloc(2*web.skel[FACET].count,sizeof(facet_id*));

	mov	edx, DWORD PTR _web+288
	push	1709					; 000006adH
	push	OFFSET ??_C@_08NGLEEPGD@MODIFY?4C?$AA@
	mov	DWORD PTR _flist$[ebp], eax
	lea	eax, DWORD PTR [edx+edx]
	push	4
	push	eax
	call	_kb_temp_calloc

; 1710 :   faces_left = 0; 
; 1711 :   FOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR _web+272
	add	esp, 32					; 00000020H
	mov	DWORD PTR _stack$[ebp], eax
	mov	DWORD PTR _f_id$[ebp], esi
	test	esi, 268435456				; 10000000H
	je	$LN139@rebody
$LL154@rebody:
	mov	edx, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN47@rebody

; 1712 :   { if ( valid_id(get_facet_body(f_id)))

	push	esi
	call	_get_facet_body
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN43@rebody

; 1713 :        flist[faces_left++].f_id = f_id;

	mov	eax, DWORD PTR _flist$[ebp]
	mov	DWORD PTR [eax+ebx*8], esi
	mov	esi, DWORD PTR _f_id$[ebp]
	inc	ebx
$LN43@rebody:

; 1714 :     ff_id = facet_inverse(f_id);

	mov	edi, esi
	xor	edi, 134217728				; 08000000H

; 1715 :     if ( valid_id(get_facet_body(ff_id)) )

	push	edi
	mov	DWORD PTR _ff_id$[ebp], edi
	call	_get_facet_body
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN47@rebody

; 1716 :        flist[faces_left++].f_id = ff_id;

	mov	ecx, DWORD PTR _flist$[ebp]
	mov	DWORD PTR [ecx+ebx*8], edi
	mov	esi, DWORD PTR _f_id$[ebp]
	inc	ebx
$LN47@rebody:

; 1710 :   faces_left = 0; 
; 1711 :   FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+236
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _f_id$[ebp], esi
	test	esi, 268435456				; 10000000H
	jne	SHORT $LL154@rebody

; 1713 :        flist[faces_left++].f_id = f_id;

	mov	DWORD PTR _faces_left$[ebp], ebx

; 1717 :   }
; 1718 :   if ( faces_left == 0 ) return 0;

	test	ebx, ebx
	jne	SHORT $LN41@rebody
$LN139@rebody:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1833 : 
; 1834 : }  // end rebody()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@rebody:

; 1719 :   facetop = faces_left;

	mov	eax, DWORD PTR _faces_left$[ebp]

; 1720 : 
; 1721 :   /* sort in facet order, so can find facets quickly */
; 1722 :   qsort((char *)flist,faces_left,sizeof(struct fface),FCAST ffcomp);

	mov	ecx, DWORD PTR _flist$[ebp]
	push	OFFSET _ffcomp
	push	8
	push	eax
	push	ecx
	mov	DWORD PTR _facetop$[ebp], eax
	call	_qsort

; 1723 : 
; 1724 :   /* initialize stack with body facets */
; 1725 :   stacktop = 0;
; 1726 :   FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+384
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	add	esp, 16					; 00000010H
	xor	ebx, ebx
	and	ecx, 1
	je	$LN126@rebody
	npad	8
$LL40@rebody:
	mov	edx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edi, DWORD PTR [eax+eax]
	mov	edx, DWORD PTR [edx+edi]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN39@rebody

; 1727 :   { 
; 1728 :     f_id = get_body_facet(b_id);

	test	ecx, ecx
	je	SHORT $LN57@rebody
	mov	edx, DWORD PTR [edx+400]
	jmp	SHORT $LN157@rebody
$LN57@rebody:
	xor	edx, edx
$LN157@rebody:
	mov	DWORD PTR _f_id$[ebp], edx

; 1729 :     if ( !valid_id(f_id) )

	test	edx, 268435456				; 10000000H
	je	SHORT $LN39@rebody

; 1730 :       continue;
; 1731 :     stack[stacktop++] = f_id;

	mov	eax, DWORD PTR _stack$[ebp]

; 1732 :     bf = (struct fface *)bsearch((char *)&f_id,(char *)flist,
; 1733 :                       facetop, sizeof(struct fface),FCAST ffcomp);

	mov	ecx, DWORD PTR _facetop$[ebp]
	push	OFFSET _ffcomp
	mov	DWORD PTR [eax+ebx*4], edx
	mov	edx, DWORD PTR _flist$[ebp]
	push	8
	push	ecx
	push	edx
	lea	eax, DWORD PTR _f_id$[ebp]
	mov	esi, 1
	push	eax
	add	ebx, esi
	call	_bsearch
	add	esp, 20					; 00000014H

; 1734 :     if ( bf == NULL ) 

	test	eax, eax
	jne	SHORT $LN34@rebody

; 1735 :     { kb_error(1243,
; 1736 :            "Internal error: rebody() cannot find facet on stack.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0DG@DPJIENAK@Internal?5error?3?5rebody?$CI?$CJ?5cannot?5@
	push	1243					; 000004dbH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1737 :       continue; 

	jmp	SHORT $LN39@rebody
$LN34@rebody:

; 1738 :     }
; 1739 : 
; 1740 :     bf->wrapflag = 1;
; 1741 :     faces_left--;

	sub	DWORD PTR _faces_left$[ebp], esi
	mov	DWORD PTR [eax+4], esi
$LN39@rebody:

; 1723 : 
; 1724 :   /* initialize stack with body facets */
; 1725 :   stacktop = 0;
; 1726 :   FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+edi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL40@rebody

; 1742 :   }
; 1743 : 
; 1744 :   /* Mark existing body contiguous facets; pull stuff off stack till empty */
; 1745 :   while (stacktop > 0 )

	test	ebx, ebx
	jle	$LN126@rebody
	mov	edx, DWORD PTR _web+460
$LL33@rebody:

; 1746 :   { f_id = stack[--stacktop];

	mov	eax, DWORD PTR _stack$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4-4]
	dec	ebx
	mov	DWORD PTR _stacktop$[ebp], ebx
	mov	DWORD PTR _f_id$[ebp], eax

; 1747 :     b_id = get_facet_body(f_id);
; 1748 :     for ( i = 0, fe = get_facet_fe(f_id); i < 3 ; i++,fe = get_next_edge(fe))

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN66@rebody
	xor	ecx, ecx
	jmp	SHORT $LN65@rebody
$LN66@rebody:
	mov	esi, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN65@rebody
	xor	ecx, 134217728				; 08000000H
$LN65@rebody:

; 1749 :      {  facetedge_id prev_fe = get_prev_facet(fe);

	mov	DWORD PTR tv888[ebp], 3
	npad	8
$LL140@rebody:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	mov	edi, ecx
	add	esi, esi
	shr	edi, 27					; 0000001bH
	add	esi, esi
	and	edi, 1
	mov	eax, DWORD PTR [esi+edx]
	je	SHORT $LN74@rebody
	mov	eax, DWORD PTR [eax+40]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN73@rebody
$LN74@rebody:
	mov	eax, DWORD PTR [eax+36]
$LN73@rebody:

; 1750 : 
; 1751 :         // Single valence edge marks body boundary
; 1752 :         if ( equal_id(prev_fe,fe) )

	cmp	eax, ecx
	je	$LN30@rebody

; 1753 :            continue;
; 1754 : 
; 1755 :         ff_id = get_fe_facet(prev_fe);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN78@rebody
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN79@rebody
$LN78@rebody:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN77@rebody
	xor	ecx, 134217728				; 08000000H
$LN77@rebody:
	mov	eax, ecx
$LN79@rebody:
	mov	DWORD PTR _ff_id$[ebp], eax

; 1756 :         if ( !valid_id(ff_id) ) continue;

	test	eax, 268435456				; 10000000H
	je	$LN30@rebody

; 1757 :         
; 1758 :         ff_id = facet_inverse(ff_id);

	xor	eax, 134217728				; 08000000H

; 1759 : //        if ( !equal_id(get_facet_body(ff_id),b_id) ) continue;
; 1760 :         if ( !valid_id(get_facet_body(ff_id)) )

	cmp	DWORD PTR _web+400, 0
	mov	DWORD PTR _ff_id$[ebp], eax
	jne	SHORT $LN84@rebody
	xor	eax, eax
	jmp	SHORT $LN81@rebody
$LN84@rebody:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN83@rebody
	xor	eax, eax
	jmp	SHORT $LN81@rebody
$LN83@rebody:
	mov	ecx, DWORD PTR _web+236
	mov	ebx, DWORD PTR _dymem
	test	eax, 134217728				; 08000000H
	je	SHORT $LN82@rebody
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+ebx+784]
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN158@rebody
$LN82@rebody:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+ebx+784]
	mov	eax, DWORD PTR [eax+ecx]
$LN158@rebody:
	mov	ebx, DWORD PTR _stacktop$[ebp]
$LN81@rebody:
	test	eax, 268435456				; 10000000H
	je	SHORT $LN30@rebody

; 1761 :            continue; /* only do previously bodied facets */
; 1762 :     
; 1763 :         bf = (struct fface *)bsearch((char *)&ff_id,(char *)flist,
; 1764 :                         facetop, sizeof(struct fface),FCAST ffcomp);

	mov	edx, DWORD PTR _facetop$[ebp]
	mov	eax, DWORD PTR _flist$[ebp]
	push	OFFSET _ffcomp
	push	8
	push	edx
	push	eax
	lea	ecx, DWORD PTR _ff_id$[ebp]
	push	ecx
	call	_bsearch
	add	esp, 20					; 00000014H

; 1765 :         if ( bf == NULL ) 

	test	eax, eax
	jne	SHORT $LN25@rebody

; 1766 :         { kb_error(1244,
; 1767 :            "Internal error: rebody() cannot find facet on stack (old body).\n",
; 1768 :                WARNING);

	push	2
	push	OFFSET ??_C@_0EB@HLJGDIJO@Internal?5error?3?5rebody?$CI?$CJ?5cannot?5@
	push	1244					; 000004dcH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1769 :           continue;

	jmp	SHORT $LN148@rebody
$LN25@rebody:

; 1770 :         }
; 1771 :         if ( bf->wrapflag ) continue;

	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN148@rebody

; 1772 :         bf->wrapflag = 1; /* mark as part of original body */

	mov	ecx, 1
	mov	DWORD PTR [eax+4], ecx

; 1773 :         stack[stacktop++] = ff_id;

	mov	edx, DWORD PTR _ff_id$[ebp]
	mov	eax, DWORD PTR _stack$[ebp]
	mov	DWORD PTR [eax+ebx*4], edx
	add	ebx, ecx

; 1774 :         faces_left--;

	sub	DWORD PTR _faces_left$[ebp], ecx
	mov	DWORD PTR _stacktop$[ebp], ebx
$LN148@rebody:

; 1769 :           continue;

	mov	edx, DWORD PTR _web+460
$LN30@rebody:

; 1747 :     b_id = get_facet_body(f_id);
; 1748 :     for ( i = 0, fe = get_facet_fe(f_id); i < 3 ; i++,fe = get_next_edge(fe))

	test	edi, edi
	je	SHORT $LN70@rebody
	mov	ecx, DWORD PTR [esi+edx]
	mov	ecx, DWORD PTR [ecx+28]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN135@rebody
$LN70@rebody:
	mov	eax, DWORD PTR [esi+edx]
	mov	ecx, DWORD PTR [eax+32]
$LN135@rebody:
	dec	DWORD PTR tv888[ebp]
	jne	$LL140@rebody

; 1742 :   }
; 1743 : 
; 1744 :   /* Mark existing body contiguous facets; pull stuff off stack till empty */
; 1745 :   while (stacktop > 0 )

	test	ebx, ebx
	jg	$LL33@rebody
$LN126@rebody:

; 1775 :       }
; 1776 :     }
; 1777 : 
; 1778 :   /* now have to create new bodies */
; 1779 :   while ( faces_left > 0 )

	cmp	DWORD PTR _faces_left$[ebp], 0
	jle	$LN152@rebody
$LL23@rebody:

; 1780 :   { /* find undone face */
; 1781 :     for ( i  =  0 ; i < facetop ; i++ )

	mov	edx, DWORD PTR _facetop$[ebp]
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN131@rebody
	mov	ecx, DWORD PTR _flist$[ebp]
	add	ecx, 4
$LL21@rebody:

; 1782 :        if ( flist[i].wrapflag == 0 ) break;

	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN131@rebody

; 1780 :   { /* find undone face */
; 1781 :     for ( i  =  0 ; i < facetop ; i++ )

	inc	eax
	add	ecx, 8
	cmp	eax, edx
	jl	SHORT $LL21@rebody
$LN131@rebody:

; 1783 :     if ( i == facetop ) break;

	cmp	eax, edx
	je	$LN152@rebody

; 1784 :     flist[i].wrapflag = 1; 

	mov	ecx, DWORD PTR _flist$[ebp]
	mov	esi, 1
	mov	DWORD PTR [ecx+eax*8+4], esi

; 1785 :     f_id = flist[i].f_id;
; 1786 :     old_b = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	mov	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _f_id$[ebp], eax
	jne	SHORT $LN90@rebody
	xor	eax, eax
	jmp	SHORT $LN87@rebody
$LN90@rebody:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN89@rebody
	xor	eax, eax
	jmp	SHORT $LN87@rebody
$LN89@rebody:
	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN88@rebody
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]
	jmp	SHORT $LN87@rebody
$LN88@rebody:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]
$LN87@rebody:

; 1787 :     b_id = dup_body(old_b);

	push	eax
	call	_dup_body

; 1788 :     new_bodies++; 

	add	DWORD PTR _new_bodies$[ebp], esi
	add	esp, 4
	mov	DWORD PTR _b_id$[ebp], eax

; 1789 :     set_body_facet(b_id,NULLID);  /* clear dup'ed value */

	test	eax, 268435456				; 10000000H
	je	SHORT $LN93@rebody
	mov	edx, DWORD PTR _web+348
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+400], 0
$LN93@rebody:

; 1790 :     set_facet_body(f_id,b_id);  /* takes care of set_body_facet() for first one */

	mov	edx, DWORD PTR _f_id$[ebp]
	push	eax
	push	edx
	call	_set_facet_body

; 1791 :     stack[stacktop++] = f_id;

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR _stack$[ebp]

; 1792 :     faces_left--;

	sub	DWORD PTR _faces_left$[ebp], esi
	mov	DWORD PTR [ecx+ebx*4], eax
	add	ebx, esi
	add	esp, 8

; 1793 :     /* pull stuff off stack till empty */
; 1794 :     while (stacktop > 0 )

	test	ebx, ebx
	jle	$LN15@rebody
	mov	edx, DWORD PTR _web+460
$LL16@rebody:

; 1795 :     { f_id = stack[--stacktop];

	mov	eax, DWORD PTR _stack$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4-4]
	dec	ebx
	mov	DWORD PTR _f_id$[ebp], eax

; 1796 :       for ( i=0, fe = get_facet_fe(f_id); i < 3 ; i++,fe = get_next_edge(fe))

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN97@rebody
	xor	ecx, ecx
	jmp	SHORT $LN96@rebody
$LN97@rebody:
	mov	esi, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN96@rebody
	xor	ecx, 134217728				; 08000000H
$LN96@rebody:

; 1797 :       { facetedge_id prev_fe = get_prev_facet(fe);

	mov	DWORD PTR tv563[ebp], 3
$LL141@rebody:
	mov	edi, ecx
	shr	edi, 27					; 0000001bH
	and	edi, 1
	mov	DWORD PTR tv1064[ebp], edi
	mov	esi, ecx
	je	SHORT $LN105@rebody
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+40]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN104@rebody
$LN105@rebody:
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+36]
$LN104@rebody:

; 1798 :         if ( equal_id(prev_fe,fe) )

	cmp	eax, ecx
	je	$LN13@rebody

; 1799 :           continue;  /* valence 1 edge is barrier */
; 1800 :         ff_id = facet_inverse(get_fe_facet(prev_fe));

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN109@rebody
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN110@rebody
$LN109@rebody:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN108@rebody
	xor	ecx, 134217728				; 08000000H
$LN108@rebody:
	mov	eax, ecx
$LN110@rebody:
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _ff_id$[ebp], eax

; 1801 :         if (!valid_id(ff_id) || !valid_id(get_facet_body(ff_id))) continue;

	test	eax, 268435456				; 10000000H
	je	$LN13@rebody
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN115@rebody
	xor	eax, eax
	jmp	SHORT $LN112@rebody
$LN115@rebody:
	mov	ecx, DWORD PTR _web+236
	mov	edi, DWORD PTR _dymem
	test	eax, 134217728				; 08000000H
	je	SHORT $LN113@rebody
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+edi+784]
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN159@rebody
$LN113@rebody:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+edi+784]
	mov	eax, DWORD PTR [eax+ecx]
$LN159@rebody:
	mov	edi, DWORD PTR tv1064[ebp]
$LN112@rebody:
	test	eax, 268435456				; 10000000H
	je	SHORT $LN13@rebody

; 1802 : //          if ( !equal_id(get_facet_body(ff_id),old_b) ) continue;
; 1803 :         bf = (struct fface *)bsearch((char *)&ff_id,(char *)flist,
; 1804 :                   facetop, sizeof(struct fface),FCAST ffcomp);

	mov	edx, DWORD PTR _facetop$[ebp]
	mov	eax, DWORD PTR _flist$[ebp]
	push	OFFSET _ffcomp
	push	8
	push	edx
	push	eax
	lea	ecx, DWORD PTR _ff_id$[ebp]
	push	ecx
	call	_bsearch
	add	esp, 20					; 00000014H

; 1805 :         if ( bf == NULL )

	test	eax, eax
	jne	SHORT $LN8@rebody

; 1806 :         { kb_error(1245,
; 1807 :             "Internal error: rebody() cannot find facet on stack (new body).\n",
; 1808 :                WARNING);

	push	2
	push	OFFSET ??_C@_0EB@FHOHHAJP@Internal?5error?3?5rebody?$CI?$CJ?5cannot?5@
	push	1245					; 000004ddH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1809 :            continue;

	jmp	SHORT $LN149@rebody
$LN8@rebody:

; 1810 :         }
; 1811 :         if ( bf->wrapflag ) continue;

	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN149@rebody

; 1812 :         bf->wrapflag = 1; /* mark as part of original body */
; 1813 :         set_facet_body(ff_id,b_id);

	mov	edx, DWORD PTR _b_id$[ebp]
	mov	DWORD PTR [eax+4], 1
	mov	eax, DWORD PTR _ff_id$[ebp]
	push	edx
	push	eax
	call	_set_facet_body

; 1814 :         stack[stacktop++] = ff_id;

	mov	ecx, DWORD PTR _ff_id$[ebp]
	mov	edx, DWORD PTR _stack$[ebp]
	mov	DWORD PTR [edx+ebx*4], ecx
	add	esp, 8
	inc	ebx

; 1815 :         faces_left--;

	dec	DWORD PTR _faces_left$[ebp]
$LN149@rebody:

; 1809 :            continue;

	mov	edx, DWORD PTR _web+460
$LN13@rebody:

; 1796 :       for ( i=0, fe = get_facet_fe(f_id); i < 3 ; i++,fe = get_next_edge(fe))

	test	edi, edi
	je	SHORT $LN101@rebody
	mov	eax, DWORD PTR [esi+edx]
	mov	ecx, DWORD PTR [eax+28]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN137@rebody
$LN101@rebody:
	mov	ecx, DWORD PTR [esi+edx]
	mov	ecx, DWORD PTR [ecx+32]
$LN137@rebody:
	dec	DWORD PTR tv563[ebp]
	jne	$LL141@rebody

; 1793 :     /* pull stuff off stack till empty */
; 1794 :     while (stacktop > 0 )

	test	ebx, ebx
	jg	$LL16@rebody
$LN15@rebody:

; 1775 :       }
; 1776 :     }
; 1777 : 
; 1778 :   /* now have to create new bodies */
; 1779 :   while ( faces_left > 0 )

	cmp	DWORD PTR _faces_left$[ebp], 0
	jg	$LL23@rebody
$LN152@rebody:

; 1816 :       }
; 1817 :     }
; 1818 :   }
; 1819 : 
; 1820 :   temp_free((char*)flist);

	mov	edx, DWORD PTR _flist$[ebp]
	push	edx
	call	_temp_free

; 1821 :   temp_free((char*)stack);

	mov	eax, DWORD PTR _stack$[ebp]
	push	eax
	call	_temp_free

; 1822 :   top_timestamp = ++global_timestamp;
; 1823 : 
; 1824 :   FOR_ALL_BODIES(b_id)

	mov	esi, DWORD PTR _web+384
	mov	eax, DWORD PTR _global_timestamp
	mov	ecx, esi
	inc	eax
	shr	ecx, 28					; 0000001cH
	add	esp, 8
	and	ecx, 1
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
	je	$LN4@rebody
	mov	ebx, DWORD PTR _web+348
$LL6@rebody:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+esi*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN5@rebody

; 1825 :   { if ( get_body_volconst(b_id) != 0.0 )

	test	ecx, ecx
	je	SHORT $LN5@rebody
	fld	QWORD PTR [edx+328]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@rebody

; 1826 :     { sprintf(msg,
; 1827 :        "Nonzero VOLCONST on body %s.  May need adjusting due to rebody.\n",
; 1828 :          ELNAME(b_id));

	lea	ecx, DWORD PTR [esi+1]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0EB@CHHAIOMC@Nonzero?5VOLCONST?5on?5body?5?$CFs?4?5?5Ma@
	push	edx
	call	_sprintf

; 1829 :       kb_error(2171,msg,WARNING);

	mov	eax, DWORD PTR _msg
	push	2
	push	eax
	push	2171					; 0000087bH
	call	_kb_error
	mov	ebx, DWORD PTR _web+348
	add	esp, 36					; 00000024H
$LN5@rebody:

; 1822 :   top_timestamp = ++global_timestamp;
; 1823 : 
; 1824 :   FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR [ebx+esi*4]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	SHORT $LL6@rebody
$LN4@rebody:

; 1830 :     }
; 1831 :   }
; 1832 :   return new_bodies;

	mov	eax, DWORD PTR _new_bodies$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 1833 : 
; 1834 : }  // end rebody()

	mov	esp, ebp
	pop	ebp
	ret	0
_rebody	ENDP
_TEXT	ENDS
END
