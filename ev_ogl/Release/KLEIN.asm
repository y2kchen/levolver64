; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\KLEIN.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	_kb_acosh
EXTRN	__fltused:DWORD
EXTRN	__CIlog:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@0000000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\klein.c
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _kb_acosh
_TEXT	SEGMENT
_value$ = 8						; size = 8
_kb_acosh PROC						; COMDAT

; 26   : {

	push	ebp
	mov	ebp, esp

; 27   :   if(value>=1)

	fld1
	fld	QWORD PTR _value$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN6@kb_acosh

; 28   :      return(log(value + sqrt(SQR(value) - 1)));

	fmul	ST(0), ST(0)
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fadd	QWORD PTR _value$[ebp]

; 31   : } // end kb_acosh()

	pop	ebp

; 28   :      return(log(value + sqrt(SQR(value) - 1)));

	jmp	__CIlog
$LN6@kb_acosh:

; 27   :   if(value>=1)

	fstp	ST(0)
	fstp	ST(0)

; 29   :   else
; 30   :      return(0);

	fldz

; 31   : } // end kb_acosh()

	pop	ebp
	ret	0
_kb_acosh ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@BKANFHMO@Points?5outside?5unit?5disk?5in?5Klei@ ; `string'
PUBLIC	_coshKleinLength
EXTRN	_kb_error:PROC
EXTRN	_dot:PROC
EXTRN	_web:BYTE
;	COMDAT ??_C@_0CK@BKANFHMO@Points?5outside?5unit?5disk?5in?5Klei@
CONST	SEGMENT
??_C@_0CK@BKANFHMO@Points?5outside?5unit?5disk?5in?5Klei@ DB 'Points outs'
	DB	'ide unit disk in Klein model.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _coshKleinLength
_TEXT	SEGMENT
_num$ = -16						; size = 8
_retval$ = -8						; size = 8
_den$ = -8						; size = 8
_head$ = 8						; size = 4
_tail$ = 12						; size = 4
_coshKleinLength PROC					; COMDAT

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 43   :   REAL num;     /* numerator and den0minator of returned value */
; 44   :   REAL den;
; 45   :   REAL temp;
; 46   :   REAL retval;
; 47   : 
; 48   :   num = 1 - SDIM_dot(head,tail);

	mov	eax, DWORD PTR _web+616
	push	esi
	mov	esi, DWORD PTR _tail$[ebp]
	push	edi
	mov	edi, DWORD PTR _head$[ebp]
	push	eax
	push	esi
	push	edi
	call	_dot
	fld1

; 49   :   den = 1 - SDIM_dot(head,head);

	mov	ecx, DWORD PTR _web+616
	fsubrp	ST(1), ST(0)
	push	ecx
	push	edi
	push	edi
	fstp	QWORD PTR _num$[ebp]
	call	_dot

; 50   :   temp = 1 - SDIM_dot(tail,tail);

	mov	edx, DWORD PTR _web+616
	fld1
	push	edx
	fsubrp	ST(1), ST(0)
	push	esi
	push	esi
	fstp	QWORD PTR _den$[ebp]
	call	_dot
	fld1
	add	esp, 36					; 00000024H
	fsubrp	ST(1), ST(0)
	pop	edi
	pop	esi

; 51   :   if((den*=temp)>0)

	fmul	QWORD PTR _den$[ebp]
	fldz
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@coshKleinL
	fstp	ST(0)

; 52   :   { den = sqrt(den);

	call	__CIsqrt

; 53   :      retval = num/den;

	fdivr	QWORD PTR _num$[ebp]
	fst	QWORD PTR _retval$[ebp]

; 57   : 
; 58   :   if ( retval < 1.0 )

	fld1
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@coshKleinL
	fstp	ST(0)
$LN6@coshKleinL:

; 59   :      kb_error(2087,"Points outside unit disk in Klein model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CK@BKANFHMO@Points?5outside?5unit?5disk?5in?5Klei@
	push	2087					; 00000827H
	call	_kb_error

; 60   :   return(retval);

	fld	QWORD PTR _retval$[ebp]
	add	esp, 12					; 0000000cH
$LN1@coshKleinL:

; 61   : } // end coshKleinLength()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@coshKleinL:

; 51   :   if((den*=temp)>0)

	fstp	ST(1)

; 54   :   }
; 55   :   else
; 56   :      retval = 0.0;

	fstp	QWORD PTR _retval$[ebp]

; 57   : 
; 58   :   if ( retval < 1.0 )

	jmp	SHORT $LN6@coshKleinL
_coshKleinLength ENDP
_TEXT	ENDS
PUBLIC	_klein_length
; Function compile flags: /Ogtp
;	COMDAT _klein_length
_TEXT	SEGMENT
_head$ = 8						; size = 4
_tail$ = 12						; size = 4
_klein_length PROC					; COMDAT

; 71   : {

	push	ebp
	mov	ebp, esp

; 72   :   return(kb_acosh(coshKleinLength(head, tail)));

	mov	eax, DWORD PTR _tail$[ebp]
	mov	ecx, DWORD PTR _head$[ebp]
	push	eax
	push	ecx
	call	_coshKleinLength
	fstp	QWORD PTR [esp]
	call	_kb_acosh
	add	esp, 8

; 73   : }

	pop	ebp
	ret	0
_klein_length ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@BOPLHBK@Vertices?5outside?5Klein?5disk?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DD@BJGEAABG@Vertices?5outside?5Klein?5disk?0?5or?5@ ; `string'
PUBLIC	_klein_length_grad
;	COMDAT ??_C@_0BO@BOPLHBK@Vertices?5outside?5Klein?5disk?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@BOPLHBK@Vertices?5outside?5Klein?5disk?4?6?$AA@ DB 'Vertices ou'
	DB	'tside Klein disk.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BJGEAABG@Vertices?5outside?5Klein?5disk?0?5or?5@
CONST	SEGMENT
??_C@_0DD@BJGEAABG@Vertices?5outside?5Klein?5disk?0?5or?5@ DB 'Vertices o'
	DB	'utside Klein disk, or zero length edge.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _klein_length_grad
_TEXT	SEGMENT
_ab$ = -24						; size = 8
_bb$ = -16						; size = 8
_aa$ = -8						; size = 8
_head$ = 8						; size = 4
_tail$ = 12						; size = 4
_head_grad$ = 16					; size = 4
_tail_grad$ = 20					; size = 4
_klein_length_grad PROC					; COMDAT

; 86   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 87   :   int i;
; 88   :   REAL aa,bb,ab,den,disc;
; 89   :   aa = 1 - SDIM_dot(head,head);

	mov	eax, DWORD PTR _web+616
	push	esi
	mov	esi, DWORD PTR _head$[ebp]
	push	edi
	push	eax
	push	esi
	push	esi
	call	_dot
	fld1

; 90   :   bb = 1 - SDIM_dot(tail,tail);

	mov	ecx, DWORD PTR _web+616
	fsubrp	ST(1), ST(0)
	mov	edi, DWORD PTR _tail$[ebp]
	push	ecx
	push	edi
	push	edi
	fstp	QWORD PTR _aa$[ebp]
	call	_dot
	fld1

; 91   :   ab = 1 - SDIM_dot(head,tail);

	mov	edx, DWORD PTR _web+616
	fsubrp	ST(1), ST(0)
	push	edx
	push	edi
	push	esi
	fstp	QWORD PTR _bb$[ebp]
	call	_dot
	fld1
	add	esp, 36					; 00000024H
	fsubrp	ST(1), ST(0)
	fst	QWORD PTR _ab$[ebp]

; 92   :   disc = ab*ab - aa*bb;

	fmul	ST(0), ST(0)
	fld	QWORD PTR _bb$[ebp]
	fmul	QWORD PTR _aa$[ebp]
	fsubp	ST(1), ST(0)

; 93   :   if ( disc == 0.0 ) 

	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@klein_leng

; 94   :   { kb_error(3107,"Vertices outside Klein disk, or zero length edge.\n",
; 95   :          WARNING); return;

	push	2
	fstp	ST(1)
	push	OFFSET ??_C@_0DD@BJGEAABG@Vertices?5outside?5Klein?5disk?0?5or?5@
	fstp	ST(0)
	push	3107					; 00000c23H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 104  :   }
; 105  : } // end klein_length_grad()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@klein_leng:

; 96   :   }
; 97   :   if ( disc < 0.0 ) 

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@klein_leng

; 98   :   { kb_error(1664,"Vertices outside Klein disk.\n",WARNING); return; }

	push	2
	fstp	ST(0)
	push	OFFSET ??_C@_0BO@BOPLHBK@Vertices?5outside?5Klein?5disk?4?6?$AA@
	push	1664					; 00000680H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 104  :   }
; 105  : } // end klein_length_grad()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@klein_leng:
	push	ebx

; 99   : 
; 100  :   den = sqrt(disc);

	call	__CIsqrt

; 101  :   for ( i = 0 ; i < SDIM ; i++ )

	xor	ebx, ebx
	cmp	DWORD PTR _web+616, ebx
	jle	SHORT $LN18@klein_leng
	mov	ecx, DWORD PTR _head_grad$[ebp]
	fld	QWORD PTR _ab$[ebp]
	fld	QWORD PTR _aa$[ebp]
	mov	edx, esi
	mov	esi, DWORD PTR _tail_grad$[ebp]
	fld	QWORD PTR _bb$[ebp]
	sub	ecx, edi
	sub	edx, edi
	mov	eax, edi
	sub	esi, edi
$LN3@klein_leng:

; 102  :   { head_grad[i] -= (ab*head[i]/aa- tail[i])/den;

	fld	QWORD PTR [edx+eax]
	inc	ebx
	fmul	ST(0), ST(3)
	add	eax, 8
	fdiv	ST(0), ST(2)
	fsub	QWORD PTR [eax-8]
	fdiv	ST(0), ST(4)
	fsubr	QWORD PTR [ecx+eax-8]
	fstp	QWORD PTR [ecx+eax-8]

; 103  :     tail_grad[i] -= (ab*tail[i]/bb - head[i])/den;

	fld	ST(2)
	fmul	QWORD PTR [eax-8]
	fdiv	ST(0), ST(1)
	fsub	QWORD PTR [edx+eax-8]
	fdiv	ST(0), ST(4)
	fsubr	QWORD PTR [esi+eax-8]
	fstp	QWORD PTR [esi+eax-8]
	cmp	ebx, DWORD PTR _web+616
	jl	SHORT $LN3@klein_leng

; 101  :   for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(3)
	fstp	ST(1)
	fstp	ST(0)
$LN18@klein_leng:
	pop	ebx
	fstp	ST(0)
	pop	edi
	pop	esi

; 104  :   }
; 105  : } // end klein_length_grad()

	mov	esp, ebp
	pop	ebp
	ret	0
_klein_length_grad ENDP
_TEXT	ENDS
PUBLIC	__real@400921fb54442d18
PUBLIC	_triangle$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_klein_area
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIacos:PROC
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _klein_area
_TEXT	SEGMENT
_area$ = -108						; size = 8
_triangle$GSCopy$ = -104				; size = 4
_sinhs$ = -100						; size = 48
_coss$ = -52						; size = 48
_coshs$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_triangle$ = 8						; size = 4
_klein_area PROC					; COMDAT

; 117  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _triangle$[ebp]
	push	ebx
	push	esi
	push	edi

; 118  :   REAL area;         /* returned area */
; 119  :   int i;             /* loop iterator */
; 120  :   int     v;          /* loop iterator */
; 121  :   int     s;         /* side opposite vertex */
; 122  : 
; 123  :   REAL coshs[MAXCOORD],          /* the coshs of the sides */
; 124  :         sinhs[MAXCOORD],          /* the sinhs of the sides */
; 125  :         coss[MAXCOORD];        /* cosines of vertices */
; 126  : 
; 127  :   for ( s = 0 ; s < 3 ; s++ )

	mov	DWORD PTR _triangle$GSCopy$[ebp], eax
	mov	ecx, 1
	xor	esi, esi
$LL10@klein_area:

; 128  :   { coshs[s] = coshKleinLength(triangle[(s+1)%3], triangle[(s+2)%3]);

	lea	edi, DWORD PTR [ecx+1]
	mov	eax, edi
	cdq
	mov	ebx, 3
	idiv	ebx
	mov	ebx, DWORD PTR _triangle$GSCopy$[ebp]
	mov	eax, ecx
	mov	ecx, 3
	mov	edx, DWORD PTR [ebx+edx*4]
	push	edx
	cdq
	idiv	ecx
	mov	edx, DWORD PTR [ebx+edx*4]
	push	edx
	call	_coshKleinLength
	fst	QWORD PTR _coshs$[ebp+esi]

; 129  :     sinhs[s] = sqrt(coshs[s]*coshs[s] - 1);

	fmul	ST(0), ST(0)
	add	esp, 8
	fsub	QWORD PTR __real@3ff0000000000000
	call	__CIsqrt
	fst	QWORD PTR _sinhs$[ebp+esi]

; 130  :     if ( sinhs[s] == 0.0  ) return 0.0;

	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@klein_area
	mov	ecx, edi
	fstp	ST(0)
	lea	eax, DWORD PTR [ecx-1]
	add	esi, 8
	cmp	eax, 3
	jl	SHORT $LL10@klein_area

; 131  :   }
; 132  :   for(v=0;v<3;v++) 
; 133  :       coss[v] = (coshs[(v+1)%3]*coshs[(v+2)%3] - coshs[v]) /
; 134  :              sinhs[(v+1)%3]/sinhs[(v+2)%3];

	fld	QWORD PTR _coshs$[ebp+8]

; 135  : 
; 136  :   area = M_PI;
; 137  :   for(i=0;i<3;i++)

	xor	esi, esi
	fld	ST(0)
	fld	QWORD PTR _coshs$[ebp+16]
	fmul	ST(1), ST(0)
	fld	QWORD PTR _coshs$[ebp]
	fsub	ST(2), ST(0)
	fld	QWORD PTR _sinhs$[ebp+8]
	fdiv	ST(3), ST(0)
	fld	QWORD PTR _sinhs$[ebp+16]
	fdiv	ST(4), ST(0)
	fxch	ST(4)
	fstp	QWORD PTR _coss$[ebp]
	fld	ST(1)
	fmul	ST(0), ST(3)
	fsub	ST(0), ST(5)
	fdivrp	ST(4), ST(0)
	fld	QWORD PTR _sinhs$[ebp]
	fdiv	ST(4), ST(0)
	fxch	ST(4)
	fstp	QWORD PTR _coss$[ebp+8]
	fxch	ST(1)
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	fsubrp	ST(1), ST(0)
	fdivrp	ST(1), ST(0)
	fdivrp	ST(1), ST(0)
	fstp	QWORD PTR _coss$[ebp+16]
	fld	QWORD PTR __real@400921fb54442d18
	fstp	QWORD PTR _area$[ebp]
	jmp	SHORT $LN3@klein_area
	npad	7
$LL28@klein_area:
	fstp	ST(0)
$LN3@klein_area:

; 138  :      area -= acos(coss[i]);

	fld	QWORD PTR _coss$[ebp+esi*8]
	call	__CIacos
	fsubr	QWORD PTR _area$[ebp]
	inc	esi
	fst	QWORD PTR _area$[ebp]
	cmp	esi, 3
	jl	SHORT $LL28@klein_area
$LN11@klein_area:

; 139  : 
; 140  :   return(area);
; 141  : } // end klein_area()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_klein_area ENDP
_TEXT	ENDS
PUBLIC	_triangle$GSCopy$
PUBLIC	_force$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_klein_area_grad
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT _klein_area_grad
_TEXT	SEGMENT
_force$GSCopy$ = -660					; size = 4
_vb$89126 = -656					; size = 4
_vc$89127 = -652					; size = 4
tv1135 = -648						; size = 4
tv1295 = -644						; size = 4
_j$ = -640						; size = 4
tv1137 = -636						; size = 4
_triangle$GSCopy$ = -636				; size = 4
tv1133 = -632						; size = 4
tv209 = -632						; size = 4
tv179 = -632						; size = 4
_ngrad$ = -628						; size = 432
_coss$ = -196						; size = 48
_sins$ = -148						; size = 48
_sinhs$ = -100						; size = 48
_coshs$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_triangle$ = 8						; size = 4
_force$ = 12						; size = 4
_klein_area_grad PROC					; COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 660				; 00000294H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 176  : 
; 177  :   for ( v = 0 ; v < 3 ; v++ ) /* vertex angle */

	mov	ecx, DWORD PTR _force$[ebp]
	mov	eax, DWORD PTR _triangle$[ebp]
	push	ebx
	push	esi
	mov	DWORD PTR _force$GSCopy$[ebp], ecx
	push	edi
	mov	DWORD PTR _triangle$GSCopy$[ebp], eax
	mov	ecx, 1
	xor	esi, esi
	npad	1
$LL19@klein_area@2:

; 162  :   { coshs[s] = coshKleinLength(triangle[(s+1)%3], triangle[(s+2)%3]);

	lea	edi, DWORD PTR [ecx+1]
	mov	eax, edi
	cdq
	mov	ebx, 3
	idiv	ebx
	mov	ebx, DWORD PTR _triangle$GSCopy$[ebp]
	mov	eax, ecx
	mov	ecx, 3
	mov	edx, DWORD PTR [ebx+edx*4]
	push	edx
	cdq
	idiv	ecx
	mov	edx, DWORD PTR [ebx+edx*4]
	push	edx
	call	_coshKleinLength
	fst	QWORD PTR _coshs$[ebp+esi]

; 163  :     sinhs[s] = sqrt(coshs[s]*coshs[s] - 1);

	fmul	ST(0), ST(0)
	add	esp, 8
	fsub	QWORD PTR __real@3ff0000000000000
	call	__CIsqrt
	fst	QWORD PTR _sinhs$[ebp+esi]

; 164  :     if ( sinhs[s] == 0.0  ) return ;

	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN7@klein_area@2

; 151  :   int     v;          /* loop iterator */
; 152  :   int     s;         /* side opposite vertex */
; 153  :   int      k,j;      /* indices */
; 154  : 
; 155  :   REAL coshs[MAXCOORD],          /* the coshs of the sides */
; 156  :        sinhs[MAXCOORD],          /* the sinhs of the sides */
; 157  :        coss[MAXCOORD],        /* cosines of vertices */
; 158  :        sins[MAXCOORD],        /* sines of vertices */
; 159  :        ngrad[3][3][MAXCOORD];      /* neg grad of side wrt vertex */
; 160  : 
; 161  :   for ( s = 0 ; s < 3 ; s++ )

	mov	ecx, edi
	lea	eax, DWORD PTR [ecx-1]
	add	esi, 8
	cmp	eax, 3
	jl	SHORT $LL19@klein_area@2

; 165  :   }
; 166  :   for(v=0;v<3;v++) 

	mov	edi, 1
	xor	esi, esi
	mov	DWORD PTR tv209[ebp], 3
	npad	1
$LL15@klein_area@2:

; 167  :   {
; 168  :     coss[v] = (coshs[(v+1)%3]*coshs[(v+2)%3] - coshs[v]);

	lea	ebx, DWORD PTR [edi+1]
	mov	eax, ebx
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, edi
	mov	edi, 3
	mov	ecx, edx
	cdq
	idiv	edi
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	fld	QWORD PTR _coshs$[ebp+ecx]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	fmul	QWORD PTR _coshs$[ebp+edx]
	fsub	QWORD PTR _coshs$[ebp+esi]

; 169  :     coss[v] /=     sinhs[(v+1)%3]*sinhs[(v+2)%3];

	fld	QWORD PTR _sinhs$[ebp+ecx]
	fmul	QWORD PTR _sinhs$[ebp+edx]
	fdivp	ST(1), ST(0)
	fst	QWORD PTR _coss$[ebp+esi]

; 170  :     sins[v] = sqrt(1 - coss[v]*coss[v]);

	fmul	ST(0), ST(0)
	fld1
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR _sins$[ebp+esi]
	add	esi, 8
	dec	DWORD PTR tv209[ebp]
	mov	edi, ebx
	jne	SHORT $LL15@klein_area@2

; 171  :   }
; 172  :   memset((char*)ngrad,0,sizeof(ngrad));

	push	432					; 000001b0H
	lea	edx, DWORD PTR _ngrad$[ebp]
	push	0
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
	mov	ecx, 1
	xor	esi, esi
	mov	DWORD PTR tv179[ebp], 3
$LL12@klein_area@2:

; 173  :   for ( s = 0 ; s < 3 ; s++ )
; 174  :      klein_length_grad(triangle[(s+1)%3],triangle[(s+2)%3],
; 175  :       ngrad[s][(s+1)%3],ngrad[s][(s+2)%3]);

	lea	edi, DWORD PTR [ecx+1]
	mov	eax, edi
	cdq
	mov	ebx, 3
	idiv	ebx
	mov	eax, ecx
	mov	ecx, 3
	mov	ebx, edx
	cdq
	idiv	ecx
	lea	eax, DWORD PTR [ebx+esi]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	lea	ecx, DWORD PTR _ngrad$[ebp+eax*8]
	push	ecx
	lea	eax, DWORD PTR [edx+esi]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	lea	ecx, DWORD PTR _ngrad$[ebp+eax*8]
	mov	eax, DWORD PTR _triangle$GSCopy$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	ecx, DWORD PTR [eax+ebx*4]
	push	ecx
	push	edx
	call	_klein_length_grad
	add	esp, 16					; 00000010H
	add	esi, 3
	dec	DWORD PTR tv179[ebp]
	mov	ecx, edi
	jne	SHORT $LL12@klein_area@2

; 176  : 
; 177  :   for ( v = 0 ; v < 3 ; v++ ) /* vertex angle */

	xor	ecx, ecx
	mov	esi, 2
	mov	DWORD PTR tv1133[ebp], ecx
	mov	DWORD PTR tv1137[ebp], esi
	mov	DWORD PTR tv1135[ebp], ecx
	mov	DWORD PTR tv1295[ebp], 3
	jmp	SHORT $LN9@klein_area@2
	npad	7
$LL36@klein_area@2:
	mov	esi, DWORD PTR tv1137[ebp]
$LN9@klein_area@2:

; 178  :   { int vb = (v+1)%3;

	lea	eax, DWORD PTR [esi-1]
	cdq
	mov	edi, 3
	idiv	edi

; 179  :     int vc = (v+2)%3;

	mov	eax, esi
	mov	esi, 3
	mov	edi, edx
	cdq
	idiv	esi
	mov	DWORD PTR _vb$89126[ebp], edi

; 180  :     REAL denom = sinhs[vb]*sinhs[vc]*sins[v];
; 181  :     REAL coeffa=sinhs[v]/denom; 
; 182  :     REAL coeffb=(coshs[vc]-coshs[v]*coshs[vb])/sinhs[vb]/denom;
; 183  :     REAL coeffc=(coshs[vb]-coshs[v]*coshs[vc])/sinhs[vc]/denom;
; 184  :     for ( k = 0 ; k < 3 ; k++ ) /* variable vertex */

	xor	esi, esi
	mov	ebx, edx
	fld	QWORD PTR _sinhs$[ebp+ebx*8]
	mov	DWORD PTR _vc$89127[ebp], ebx
	fmul	QWORD PTR _sinhs$[ebp+edi*8]
	fmul	QWORD PTR _sins$[ebp+ecx]
	fld	QWORD PTR _sinhs$[ebp+ecx]
	fdiv	ST(0), ST(1)
	fld	QWORD PTR _coshs$[ebp+ecx]
	fmul	QWORD PTR _coshs$[ebp+edi*8]
	fsubr	QWORD PTR _coshs$[ebp+ebx*8]
	fdiv	QWORD PTR _sinhs$[ebp+edi*8]
	fdiv	ST(0), ST(2)
	fld	QWORD PTR _coshs$[ebp+ebx*8]
	fmul	QWORD PTR _coshs$[ebp+ecx]
	fsubr	QWORD PTR _coshs$[ebp+edi*8]
	fdiv	QWORD PTR _sinhs$[ebp+ebx*8]
	fdivrp	ST(3), ST(0)
$LN6@klein_area@2:

; 185  :     for ( j = 0 ; j < SDIM ; j++ ) /* coordinate */

	cmp	DWORD PTR _web+616, 0
	mov	DWORD PTR _j$[ebp], 0
	jle	$LN5@klein_area@2
	mov	ecx, DWORD PTR tv1133[ebp]
	mov	eax, DWORD PTR _force$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	add	ecx, esi
	lea	edx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [esi+edi*2]
	add	ecx, edi
	lea	edi, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [esi+ebx*2]
	add	ecx, ebx
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edi, edi
	add	ecx, ecx
	lea	edx, DWORD PTR _ngrad$[ebp+edx*8]
	lea	edi, DWORD PTR _ngrad$[ebp+edi*8]
	lea	ecx, DWORD PTR _ngrad$[ebp+ecx*8]
$LN35@klein_area@2:

; 186  :     { 
; 187  :       force[k][j] -= coeffb*ngrad[vb][k][j] + coeffc*ngrad[vc][k][j]
; 188  :          + coeffa*ngrad[v][k][j];

	fld	QWORD PTR [ecx]
	inc	DWORD PTR _j$[ebp]
	fmul	ST(0), ST(3)
	add	ecx, 8
	fld	ST(1)
	add	edi, 8
	fmul	QWORD PTR [edi-8]
	add	edx, 8
	add	eax, 8
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx-8]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	ebx, DWORD PTR _web+616
	cmp	DWORD PTR _j$[ebp], ebx
	jl	SHORT $LN35@klein_area@2

; 185  :     for ( j = 0 ; j < SDIM ; j++ ) /* coordinate */

	mov	ebx, DWORD PTR _vc$89127[ebp]
	mov	edi, DWORD PTR _vb$89126[ebp]
	mov	ecx, DWORD PTR tv1135[ebp]
$LN5@klein_area@2:

; 180  :     REAL denom = sinhs[vb]*sinhs[vc]*sins[v];
; 181  :     REAL coeffa=sinhs[v]/denom; 
; 182  :     REAL coeffb=(coshs[vc]-coshs[v]*coshs[vb])/sinhs[vb]/denom;
; 183  :     REAL coeffc=(coshs[vb]-coshs[v]*coshs[vc])/sinhs[vc]/denom;
; 184  :     for ( k = 0 ; k < 3 ; k++ ) /* variable vertex */

	inc	esi
	cmp	esi, 3
	jl	$LN6@klein_area@2
	add	DWORD PTR tv1133[ebp], 3
	fstp	ST(2)
	mov	eax, 1
	fstp	ST(0)
	add	DWORD PTR tv1137[ebp], eax
	fstp	ST(0)
	add	ecx, 8
	sub	DWORD PTR tv1295[ebp], eax
	mov	DWORD PTR tv1135[ebp], ecx
	jne	$LL36@klein_area@2
$LN7@klein_area@2:

; 189  :     }
; 190  :   }
; 191  : } // end klein_area_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_klein_area_grad ENDP
_TEXT	ENDS
PUBLIC	_klein_length_method
EXTRN	_default_area_quant_num:DWORD
EXTRN	_meth_inst_list:DWORD
EXTRN	_everything_quantities_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _klein_length_method
_TEXT	SEGMENT
_e_info$ = 8						; size = 4
_klein_length_method PROC				; COMDAT

; 204  : { REAL area;

	push	ebp
	mov	ebp, esp
	push	esi

; 205  :   area = kb_acosh(coshKleinLength(e_info->x[1], e_info->x[0]));

	mov	esi, DWORD PTR _e_info$[ebp]
	mov	eax, DWORD PTR [esi+416]
	mov	ecx, DWORD PTR [esi+420]
	push	eax
	push	ecx
	call	_coshKleinLength
	fstp	QWORD PTR [esp]
	call	_kb_acosh
	add	esp, 8

; 206  :   if ( everything_quantities_flag  && 
; 207  :       (METH_INSTANCE(e_info->method)->quants[0] == default_area_quant_num) )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN1@klein_leng@2
	mov	eax, DWORD PTR [esi+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	mov	eax, DWORD PTR [eax+edx+152]
	cmp	eax, DWORD PTR _default_area_quant_num
	jne	SHORT $LN1@klein_leng@2

; 208  :      area *= get_edge_density(e_info->id);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	fmul	QWORD PTR [eax+40]
$LN1@klein_leng@2:
	pop	esi

; 209  : 
; 210  :   return(area);
; 211  : } // end klein_length_method()

	pop	ebp
	ret	0
_klein_length_method ENDP
_TEXT	ENDS
PUBLIC	_klein_length_method_grad
; Function compile flags: /Ogtp
;	COMDAT _klein_length_method_grad
_TEXT	SEGMENT
_ab$ = -32						; size = 8
_aa$ = -24						; size = 8
_bb$ = -16						; size = 8
_fudge$ = -8						; size = 8
_tail$ = 8						; size = 4
_e_info$ = 8						; size = 4
_klein_length_method_grad PROC				; COMDAT

; 218  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 219  :   int i;
; 220  :   REAL aa,bb,ab,den,disc;
; 221  :   REAL *head = e_info->x[1];
; 222  :   REAL *tail = e_info->x[0];
; 223  :   REAL fudge;
; 224  :   if ( everything_quantities_flag  && 
; 225  :       (METH_INSTANCE(e_info->method)->quants[0] == default_area_quant_num) )

	cmp	DWORD PTR _everything_quantities_flag, 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR _e_info$[ebp]
	mov	ebx, DWORD PTR [esi+420]
	push	edi
	mov	edi, DWORD PTR [esi+416]
	mov	DWORD PTR _tail$[ebp], edi
	je	SHORT $LN7@klein_leng@3
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _meth_inst_list
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	mov	edx, DWORD PTR [eax+ecx+152]
	cmp	edx, DWORD PTR _default_area_quant_num
	jne	SHORT $LN7@klein_leng@3

; 226  :      fudge = get_edge_density(e_info->id);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]
	jmp	SHORT $LN24@klein_leng@3
$LN7@klein_leng@3:

; 227  :   else fudge = 1.0;

	fld1
$LN24@klein_leng@3:

; 228  : 
; 229  : 
; 230  :   aa = 1 - SDIM_dot(head,head);

	mov	eax, DWORD PTR _web+616
	fstp	QWORD PTR _fudge$[ebp]
	push	eax
	push	ebx
	push	ebx
	call	_dot
	fld1

; 231  :   bb = 1 - SDIM_dot(tail,tail);

	mov	ecx, DWORD PTR _web+616
	fsubrp	ST(1), ST(0)
	push	ecx
	push	edi
	push	edi
	fstp	QWORD PTR _aa$[ebp]
	call	_dot

; 232  :   ab = 1 - SDIM_dot(head,tail);

	mov	edx, DWORD PTR _web+616
	fld1
	push	edx
	fsubrp	ST(1), ST(0)
	push	edi
	push	ebx
	fstp	QWORD PTR _bb$[ebp]
	call	_dot
	fld1
	add	esp, 36					; 00000024H
	fsubrp	ST(1), ST(0)
	fst	QWORD PTR _ab$[ebp]

; 233  :   disc = ab*ab - aa*bb;

	fmul	ST(0), ST(0)
	fld	QWORD PTR _bb$[ebp]
	fmul	QWORD PTR _aa$[ebp]
	fsubp	ST(1), ST(0)

; 234  :   if ( disc == 0.0 ) 

	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@klein_leng@3

; 235  :   { kb_error(3359,"Vertices outside Klein disk, or zero length edge.\n",
; 236  :          WARNING); return 0.0;

	push	2
	fstp	ST(1)
	push	OFFSET ??_C@_0DD@BJGEAABG@Vertices?5outside?5Klein?5disk?0?5or?5@
	fstp	ST(0)
	push	3359					; 00000d1fH
	call	_kb_error
	fldz
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 247  : } // end klein_length_method_grad()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@klein_leng@3:

; 237  :   }
; 238  :   if ( disc < 0.0 ) 

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@klein_leng@3

; 239  :   { kb_error(1665,"Vertices outside Klein disk.\n",WARNING); return 0.0; }

	push	2
	fstp	ST(0)
	push	OFFSET ??_C@_0BO@BOPLHBK@Vertices?5outside?5Klein?5disk?4?6?$AA@
	push	1665					; 00000681H
	call	_kb_error
	fldz
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 247  : } // end klein_length_method_grad()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@klein_leng@3:

; 240  : 
; 241  :   den = sqrt(disc);

	call	__CIsqrt

; 242  :   for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN19@klein_leng@3
	fld	QWORD PTR _bb$[ebp]
	sub	edi, ebx
	fld	QWORD PTR _fudge$[ebp]
	fld	QWORD PTR _aa$[ebp]
	fld	QWORD PTR _ab$[ebp]
$LN3@klein_leng@3:

; 243  :   { e_info->grad[1][i] += fudge*(ab*head[i]/aa - tail[i])/den;

	fld	QWORD PTR [ebx+ecx*8]
	lea	eax, DWORD PTR [ebx+ecx*8]
	fmul	ST(0), ST(1)
	mov	edx, DWORD PTR [esi+1336]
	mov	edx, DWORD PTR [edx+4]
	lea	edx, DWORD PTR [edx+ecx*8]
	fdiv	ST(0), ST(2)
	fsub	QWORD PTR [edi+eax]
	fmul	ST(0), ST(3)
	fdiv	ST(0), ST(5)
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]

; 244  :     e_info->grad[0][i] += fudge*(ab*tail[i]/bb - head[i])/den;

	mov	edx, DWORD PTR [esi+1336]
	fld	QWORD PTR [edi+eax]
	mov	edx, DWORD PTR [edx]
	fmul	ST(0), ST(1)
	lea	edx, DWORD PTR [edx+ecx*8]
	inc	ecx
	fdiv	ST(0), ST(4)
	fsub	QWORD PTR [eax]
	fmul	ST(0), ST(3)
	fdiv	ST(0), ST(5)
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN3@klein_leng@3

; 242  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR _tail$[ebp]
	fstp	ST(4)
	fstp	ST(3)
	fstp	ST(0)
	fstp	ST(1)
$LN19@klein_leng@3:

; 245  :   }
; 246  :   return(fudge*kb_acosh(coshKleinLength(head, tail)));

	push	edi
	fstp	ST(0)
	push	ebx
	call	_coshKleinLength
	fstp	QWORD PTR [esp]
	call	_kb_acosh
	fmul	QWORD PTR _fudge$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 247  : } // end klein_length_method_grad()

	mov	esp, ebp
	pop	ebp
	ret	0
_klein_length_method_grad ENDP
_TEXT	ENDS
PUBLIC	_f_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_klein_area_method
; Function compile flags: /Ogtp
;	COMDAT _klein_area_method
_TEXT	SEGMENT
_area$ = -108						; size = 8
_f_info$GSCopy$ = -104					; size = 4
_sinhs$ = -100						; size = 48
_coss$ = -52						; size = 48
_coshs$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_f_info$ = 8						; size = 4
_klein_area_method PROC					; COMDAT

; 255  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _f_info$[ebp]
	push	ebx
	push	esi
	push	edi

; 256  :   REAL area;         /* returned area */
; 257  :   int i;             /* loop iterator */
; 258  :   int     v;          /* loop iterator */
; 259  :   int     s;         /* side opposite vertex */
; 260  :   REAL **triangle = f_info->x;
; 261  : 
; 262  :   REAL coshs[MAXCOORD],          /* the coshs of the sides */
; 263  :        sinhs[MAXCOORD],          /* the sinhs of the sides */
; 264  :        coss[MAXCOORD];        /* cosines of vertices */
; 265  : 
; 266  :   for ( s = 0 ; s < 3 ; s++ )

	mov	DWORD PTR _f_info$GSCopy$[ebp], eax
	mov	ecx, 1
	xor	esi, esi
$LL11@klein_area@3:

; 267  :   { coshs[s] = coshKleinLength(triangle[(s+1)%3], triangle[(s+2)%3]);

	lea	edi, DWORD PTR [ecx+1]
	mov	eax, edi
	cdq
	mov	ebx, 3
	idiv	ebx
	mov	ebx, DWORD PTR _f_info$GSCopy$[ebp]
	mov	eax, ecx
	mov	ecx, 3
	mov	edx, DWORD PTR [ebx+edx*4+416]
	push	edx
	cdq
	idiv	ecx
	mov	edx, DWORD PTR [ebx+edx*4+416]
	push	edx
	call	_coshKleinLength
	fst	QWORD PTR _coshs$[ebp+esi]

; 268  :     sinhs[s] = sqrt(coshs[s]*coshs[s] - 1);

	fmul	ST(0), ST(0)
	add	esp, 8
	fsub	QWORD PTR __real@3ff0000000000000
	call	__CIsqrt
	fst	QWORD PTR _sinhs$[ebp+esi]

; 269  :     if ( sinhs[s] == 0.0  ) return 0.0;

	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	$LN12@klein_area@3
	mov	ecx, edi
	fstp	ST(0)
	lea	eax, DWORD PTR [ecx-1]
	add	esi, 8
	cmp	eax, 3
	jl	SHORT $LL11@klein_area@3

; 270  :   }
; 271  :   for(v=0;v<3;v++) 
; 272  :       coss[v] = (coshs[(v+1)%3]*coshs[(v+2)%3] - coshs[v]) /
; 273  :              sinhs[(v+1)%3]/sinhs[(v+2)%3];

	fld	QWORD PTR _coshs$[ebp+8]

; 274  : 
; 275  :   area = M_PI;
; 276  :   for(i=0;i<3;i++)

	xor	esi, esi
	fld	ST(0)
	fld	QWORD PTR _coshs$[ebp+16]
	fmul	ST(1), ST(0)
	fld	QWORD PTR _coshs$[ebp]
	fsub	ST(2), ST(0)
	fld	QWORD PTR _sinhs$[ebp+8]
	fdiv	ST(3), ST(0)
	fld	QWORD PTR _sinhs$[ebp+16]
	fdiv	ST(4), ST(0)
	fxch	ST(4)
	fstp	QWORD PTR _coss$[ebp]
	fld	ST(1)
	fmul	ST(0), ST(3)
	fsub	ST(0), ST(5)
	fdivrp	ST(4), ST(0)
	fld	QWORD PTR _sinhs$[ebp]
	fdiv	ST(4), ST(0)
	fxch	ST(4)
	fstp	QWORD PTR _coss$[ebp+8]
	fxch	ST(1)
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	fsubrp	ST(1), ST(0)
	fdivrp	ST(1), ST(0)
	fdivrp	ST(1), ST(0)
	fstp	QWORD PTR _coss$[ebp+16]
	fld	QWORD PTR __real@400921fb54442d18
	fstp	QWORD PTR _area$[ebp]
	jmp	SHORT $LN4@klein_area@3
$LL29@klein_area@3:
	fstp	ST(0)
$LN4@klein_area@3:

; 277  :      area -= acos(coss[i]);

	fld	QWORD PTR _coss$[ebp+esi*8]
	call	__CIacos
	fsubr	QWORD PTR _area$[ebp]
	inc	esi
	fst	QWORD PTR _area$[ebp]
	cmp	esi, 3
	jl	SHORT $LL29@klein_area@3

; 278  : 
; 279  :   if ( everything_quantities_flag  && 
; 280  :       (METH_INSTANCE(f_info->method)->quants[0] == default_area_quant_num) )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN12@klein_area@3
	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR _meth_inst_list
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	mov	edx, DWORD PTR [eax+ecx+152]
	cmp	edx, DWORD PTR _default_area_quant_num
	jne	SHORT $LN12@klein_area@3

; 281  :      area *= get_facet_density(f_info->id);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fmul	QWORD PTR [edx+32]
$LN12@klein_area@3:

; 282  : 
; 283  :   return(area);
; 284  : } // end klein_area_method()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_klein_area_method ENDP
_TEXT	ENDS
PUBLIC	_f_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_klein_area_method_grad
; Function compile flags: /Ogtp
;	COMDAT _klein_area_method_grad
_TEXT	SEGMENT
_vc$89221 = -668					; size = 4
_fudge$ = -664						; size = 8
_area$ = -656						; size = 8
_vb$89220 = -652					; size = 4
tv1200 = -648						; size = 4
tv1358 = -644						; size = 4
_f_info$GSCopy$ = -640					; size = 4
tv1202 = -636						; size = 4
tv1198 = -632						; size = 4
tv236 = -632						; size = 4
tv209 = -632						; size = 4
_ngrad$ = -628						; size = 432
_sins$ = -196						; size = 48
_coss$ = -148						; size = 48
_sinhs$ = -100						; size = 48
_coshs$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_f_info$ = 8						; size = 4
_klein_area_method_grad PROC				; COMDAT

; 290  : { REAL area;

	push	ebp
	mov	ebp, esp
	sub	esp, 668				; 0000029cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 291  :   int     v;          /* loop iterator */
; 292  :   int     s;         /* side opposite vertex */
; 293  :   int     i, k,j;      /* indices */
; 294  :   REAL **triangle = f_info->x;
; 295  : 
; 296  :   REAL coshs[MAXCOORD],          /* the coshs of the sides */
; 297  :        sinhs[MAXCOORD],          /* the sinhs of the sides */
; 298  :        coss[MAXCOORD],        /* cosines of vertices */
; 299  :        sins[MAXCOORD],        /* sines of vertices */
; 300  :        ngrad[3][3][MAXCOORD];      /* neg grad of side wrt vertex */
; 301  :   REAL fudge;
; 302  :   if ( everything_quantities_flag  && 
; 303  :       (METH_INSTANCE(f_info->method)->quants[0] == default_area_quant_num) )

	cmp	DWORD PTR _everything_quantities_flag, 0
	mov	ecx, DWORD PTR _f_info$[ebp]

; 331  :     for ( j = 0 ; j < SDIM ; j++ ) /* coordinate */

	mov	DWORD PTR _f_info$GSCopy$[ebp], ecx
	je	SHORT $LN24@klein_area@4

; 291  :   int     v;          /* loop iterator */
; 292  :   int     s;         /* side opposite vertex */
; 293  :   int     i, k,j;      /* indices */
; 294  :   REAL **triangle = f_info->x;
; 295  : 
; 296  :   REAL coshs[MAXCOORD],          /* the coshs of the sides */
; 297  :        sinhs[MAXCOORD],          /* the sinhs of the sides */
; 298  :        coss[MAXCOORD],        /* cosines of vertices */
; 299  :        sins[MAXCOORD],        /* sines of vertices */
; 300  :        ngrad[3][3][MAXCOORD];      /* neg grad of side wrt vertex */
; 301  :   REAL fudge;
; 302  :   if ( everything_quantities_flag  && 
; 303  :       (METH_INSTANCE(f_info->method)->quants[0] == default_area_quant_num) )

	mov	eax, DWORD PTR [ecx+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	mov	eax, DWORD PTR [eax+edx+152]
	cmp	eax, DWORD PTR _default_area_quant_num
	jne	SHORT $LN24@klein_area@4

; 304  :      fudge = get_facet_density(f_info->id);

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR _web+236
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	fld	QWORD PTR [eax+32]
	jmp	SHORT $LN64@klein_area@4
$LN24@klein_area@4:

; 305  :   else fudge = 1.0;

	fld1
$LN64@klein_area@4:
	push	ebx
	fstp	QWORD PTR _fudge$[ebp]
	push	esi
	push	edi

; 306  : 
; 307  :   for ( s = 0 ; s < 3 ; s++ )

	mov	ecx, 1
	xor	esi, esi
$LL22@klein_area@4:

; 308  :   { coshs[s] = coshKleinLength(triangle[(s+1)%3], triangle[(s+2)%3]);

	lea	edi, DWORD PTR [ecx+1]
	mov	eax, edi
	cdq
	mov	ebx, 3
	idiv	ebx
	mov	ebx, DWORD PTR _f_info$GSCopy$[ebp]
	mov	eax, ecx
	mov	ecx, 3
	mov	edx, DWORD PTR [ebx+edx*4+416]
	push	edx
	cdq
	idiv	ecx
	mov	edx, DWORD PTR [ebx+edx*4+416]
	push	edx
	call	_coshKleinLength
	fst	QWORD PTR _coshs$[ebp+esi]

; 309  :     sinhs[s] = sqrt(coshs[s]*coshs[s] - 1);

	fmul	ST(0), ST(0)
	add	esp, 8
	fsub	QWORD PTR __real@3ff0000000000000
	call	__CIsqrt
	fst	QWORD PTR _sinhs$[ebp+esi]

; 310  :     if ( sinhs[s] == 0.0  ) return 0.0 ;

	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	$LN25@klein_area@4
	mov	ecx, edi
	fstp	ST(0)
	lea	eax, DWORD PTR [ecx-1]
	add	esi, 8
	cmp	eax, 3
	jl	SHORT $LL22@klein_area@4

; 311  :   }
; 312  :   for(v=0;v<3;v++) 

	mov	edi, 1
	xor	esi, esi
	mov	DWORD PTR tv236[ebp], 3
	npad	3
$LL18@klein_area@4:

; 313  :   {
; 314  :     coss[v] = (coshs[(v+1)%3]*coshs[(v+2)%3] - coshs[v]);

	lea	ebx, DWORD PTR [edi+1]
	mov	eax, ebx
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, edi
	mov	edi, 3
	mov	ecx, edx
	cdq
	idiv	edi
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	fld	QWORD PTR _coshs$[ebp+ecx]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	fmul	QWORD PTR _coshs$[ebp+edx]
	fsub	QWORD PTR _coshs$[ebp+esi]

; 315  :     coss[v] /=     sinhs[(v+1)%3]*sinhs[(v+2)%3];

	fld	QWORD PTR _sinhs$[ebp+ecx]
	fmul	QWORD PTR _sinhs$[ebp+edx]
	fdivp	ST(1), ST(0)
	fst	QWORD PTR _coss$[ebp+esi]

; 316  :     sins[v] = sqrt(1 - coss[v]*coss[v]);

	fmul	ST(0), ST(0)
	fld1
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR _sins$[ebp+esi]
	add	esi, 8
	dec	DWORD PTR tv236[ebp]
	mov	edi, ebx
	jne	SHORT $LL18@klein_area@4

; 317  :   }
; 318  :   memset((char*)ngrad,0,sizeof(ngrad));

	push	432					; 000001b0H
	lea	edx, DWORD PTR _ngrad$[ebp]
	push	0
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
	mov	ecx, 1
	xor	esi, esi
	mov	DWORD PTR tv209[ebp], 3
$LL15@klein_area@4:

; 319  :   for ( s = 0 ; s < 3 ; s++ )
; 320  :      klein_length_grad(triangle[(s+1)%3],triangle[(s+2)%3],
; 321  :       ngrad[s][(s+1)%3],ngrad[s][(s+2)%3]);

	lea	edi, DWORD PTR [ecx+1]
	mov	eax, edi
	cdq
	mov	ebx, 3
	idiv	ebx
	mov	eax, ecx
	mov	ecx, 3
	mov	ebx, edx
	cdq
	idiv	ecx
	lea	eax, DWORD PTR [ebx+esi]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	lea	ecx, DWORD PTR _ngrad$[ebp+eax*8]
	push	ecx
	lea	eax, DWORD PTR [edx+esi]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	lea	ecx, DWORD PTR _ngrad$[ebp+eax*8]
	mov	eax, DWORD PTR _f_info$GSCopy$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+416]
	push	ecx
	mov	ecx, DWORD PTR [eax+ebx*4+416]
	push	ecx
	push	edx
	call	_klein_length_grad
	add	esp, 16					; 00000010H
	add	esi, 3
	dec	DWORD PTR tv209[ebp]
	mov	ecx, edi
	jne	SHORT $LL15@klein_area@4

; 322  : 
; 323  :   for ( v = 0 ; v < 3 ; v++ ) /* vertex angle */

	mov	ecx, DWORD PTR _web+616
	fld	QWORD PTR _fudge$[ebp]
	xor	ebx, ebx
	mov	esi, 2
	mov	DWORD PTR tv1198[ebp], ebx
	mov	DWORD PTR tv1202[ebp], esi
	mov	DWORD PTR tv1200[ebp], ebx
	mov	DWORD PTR tv1358[ebp], 3
	jmp	SHORT $LN12@klein_area@4
$LN43@klein_area@4:
	mov	esi, DWORD PTR tv1202[ebp]
$LN12@klein_area@4:

; 324  :   { int vb = (v+1)%3;

	lea	eax, DWORD PTR [esi-1]
	cdq
	mov	edi, 3
	idiv	edi

; 325  :     int vc = (v+2)%3;

	mov	eax, esi
	mov	esi, 3
	mov	edi, edx
	cdq
	idiv	esi

; 326  :     REAL denom = sinhs[vb]*sinhs[vc]*sins[v];

	fld	QWORD PTR _sinhs$[ebp+edx*8]
	fmul	QWORD PTR _sinhs$[ebp+edi*8]
	fmul	QWORD PTR _sins$[ebp+ebx]

; 327  :     REAL coeffa=sinhs[v]/denom; 

	fld	QWORD PTR _sinhs$[ebp+ebx]
	fdiv	ST(0), ST(1)
	mov	DWORD PTR _vb$89220[ebp], edi

; 328  :     REAL coeffb=(coshs[vc]-coshs[v]*coshs[vb])/sinhs[vb]/denom;

	fld	QWORD PTR _coshs$[ebp+edi*8]
	fmul	QWORD PTR _coshs$[ebp+ebx]
	lea	eax, DWORD PTR _sinhs$[ebp+edx*8]
	mov	DWORD PTR _vc$89221[ebp], edx
	lea	edx, DWORD PTR _coshs$[ebp+edx*8]
	fsubr	QWORD PTR [edx]
	fdiv	QWORD PTR _sinhs$[ebp+edi*8]
	fdiv	ST(0), ST(2)

; 329  :     REAL coeffc=(coshs[vb]-coshs[v]*coshs[vc])/sinhs[vc]/denom;

	fld	QWORD PTR [edx]
	fmul	QWORD PTR _coshs$[ebp+ebx]
	fsubr	QWORD PTR _coshs$[ebp+edi*8]
	fdiv	QWORD PTR [eax]

; 330  :     for ( k = 0 ; k < 3 ; k++ ) /* variable vertex */

	xor	eax, eax
	fdivrp	ST(3), ST(0)
$LN44@klein_area@4:

; 331  :     for ( j = 0 ; j < SDIM ; j++ ) /* coordinate */

	xor	esi, esi
	test	ecx, ecx
	jle	$LN8@klein_area@4
	mov	ecx, DWORD PTR tv1198[ebp]
	add	ecx, eax
	lea	ebx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [eax+edi*2]
	add	ecx, edi
	mov	edi, DWORD PTR _vc$89221[ebp]
	lea	edx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [eax+edi*2]
	add	ecx, edi
	add	ebx, ebx
	add	edx, edx
	lea	edi, DWORD PTR [ecx+ecx*2]
	add	edi, edi
	lea	ebx, DWORD PTR _ngrad$[ebp+ebx*8]
	lea	edx, DWORD PTR _ngrad$[ebp+edx*8]
	lea	edi, DWORD PTR _ngrad$[ebp+edi*8]
$LN42@klein_area@4:

; 332  :     { 
; 333  :       f_info->grad[k][j] += fudge*(coeffb*ngrad[vb][k][j]
; 334  :          + coeffc*ngrad[vc][k][j]
; 335  :          + coeffa*ngrad[v][k][j]);

	fld	QWORD PTR [edx]
	mov	ecx, DWORD PTR _f_info$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ecx+1336]
	fmul	ST(0), ST(1)
	mov	ecx, DWORD PTR [ecx+eax*4]
	fld	ST(3)
	fmul	QWORD PTR [edi]
	lea	ecx, DWORD PTR [ecx+esi*8]
	inc	esi
	add	edi, 8
	faddp	ST(1), ST(0)
	add	edx, 8
	fld	ST(2)
	add	ebx, 8
	fmul	QWORD PTR [ebx-8]
	faddp	ST(1), ST(0)
	fmul	ST(0), ST(4)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	esi, ecx
	jl	SHORT $LN42@klein_area@4

; 331  :     for ( j = 0 ; j < SDIM ; j++ ) /* coordinate */

	mov	ebx, DWORD PTR tv1200[ebp]
	mov	edi, DWORD PTR _vb$89220[ebp]
$LN8@klein_area@4:

; 330  :     for ( k = 0 ; k < 3 ; k++ ) /* variable vertex */

	inc	eax
	cmp	eax, 3
	jl	$LN44@klein_area@4
	add	DWORD PTR tv1198[ebp], 3
	fstp	ST(1)
	mov	eax, 1
	fstp	ST(0)
	add	DWORD PTR tv1202[ebp], eax
	fstp	ST(0)
	add	ebx, 8
	sub	DWORD PTR tv1358[ebp], eax
	mov	DWORD PTR tv1200[ebp], ebx
	jne	$LN43@klein_area@4

; 336  :     }
; 337  :   }
; 338  : 
; 339  :   area = M_PI;
; 340  :   for(i=0;i<3;i++)

	fstp	ST(0)
	xor	esi, esi
	fld	QWORD PTR __real@400921fb54442d18
	fstp	QWORD PTR _area$[ebp]
	jmp	SHORT $LN3@klein_area@4
	npad	5
$LL62@klein_area@4:
	fstp	ST(0)
$LN3@klein_area@4:

; 341  :      area -= acos(coss[i]);

	fld	QWORD PTR _coss$[ebp+esi*8]
	call	__CIacos
	fsubr	QWORD PTR _area$[ebp]
	inc	esi
	fst	QWORD PTR _area$[ebp]
	cmp	esi, 3
	jl	SHORT $LL62@klein_area@4

; 342  : 
; 343  :   return(fudge*area);

	fmul	QWORD PTR _fudge$[ebp]
$LN25@klein_area@4:

; 344  : } // end klein_area_method_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_klein_area_method_grad ENDP
_TEXT	ENDS
END
