; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\HESSIAN2.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_evalues:DWORD
_DATA	ENDS
PUBLIC	_get_fe_edge
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_get_body_volume
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_body_volume
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volume PROC					; COMDAT

; 308  :     { return    ( valid_id(b_id) ?  bptr(b_id)->volume : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]
	pop	ebp
	ret	0
$LN3@get_body_v:
	fldz
	pop	ebp
	ret	0
_get_body_volume ENDP
_TEXT	ENDS
PUBLIC	_get_body_pressure
; Function compile flags: /Ogtp
;	COMDAT _get_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_pressure PROC					; COMDAT

; 317  :     { return  ( valid_id(b_id) ?    bptr(b_id)->pressure : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_p
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+312]
	pop	ebp
	ret	0
$LN3@get_body_p:
	fldz
	pop	ebp
	ret	0
_get_body_pressure ENDP
_TEXT	ENDS
PUBLIC	_difference_lagrangian
EXTRN	_gen_quant_list:DWORD
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\hessian2.c
;	COMDAT _difference_lagrangian
_TEXT	SEGMENT
tv266 = -8						; size = 8
_difference_lagrangian PROC				; COMDAT

; 30   : { REAL sum;

	push	ebp
	mov	ebp, esp

; 31   :   body_id b_id;
; 32   :   struct gen_quant *q;
; 33   :   int k;
; 34   : 
; 35   :   sum = web.total_energy;
; 36   :   FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+384
	fld	QWORD PTR _web+1240
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, eax
	shr	esi, 28					; 0000001cH
	and	esi, 1
	push	edi
	je	SHORT $LN9@difference
	mov	ebx, DWORD PTR _web+348
	fldz
$LN34@difference:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv266[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN10@difference

; 37   :     if ( get_battr(b_id) & FIXEDVOL )

	and	ecx, 32					; 00000020H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN10@difference

; 38   :       sum -= get_body_pressure(b_id)*get_body_volume(b_id);

	test	esi, esi
	je	SHORT $LN16@difference
	fld	QWORD PTR [edx+312]
	fld	QWORD PTR [edx+40]
	jmp	SHORT $LN21@difference
$LN16@difference:
	fld	ST(0)
	fld	ST(1)
$LN21@difference:
	fmulp	ST(1), ST(0)
	fsubp	ST(2), ST(0)
$LN10@difference:

; 31   :   body_id b_id;
; 32   :   struct gen_quant *q;
; 33   :   int k;
; 34   : 
; 35   :   sum = web.total_energy;
; 36   :   FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR [edx]
	mov	esi, eax
	shr	esi, 28					; 0000001cH
	and	esi, 1
	jne	SHORT $LN34@difference

; 38   :       sum -= get_body_pressure(b_id)*get_body_volume(b_id);

	fstp	ST(0)
$LN9@difference:

; 39   :   for ( k = 0 ; k < gen_quant_count ; k++ )

	mov	esi, DWORD PTR _web+5528
	mov	ebx, DWORD PTR _gen_quant_list
	xor	edi, edi
	cmp	esi, 4
	jl	$LC27@difference
	lea	edx, DWORD PTR [esi-4]
	shr	edx, 2
	inc	edx
	lea	eax, DWORD PTR [ebx+504]
	lea	edi, DWORD PTR [edx*4]
$LN32@difference:

; 40   :   { q = GEN_QUANT(k);
; 41   :     if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax-368]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN28@difference

; 42   :     if ( q->flags & Q_FIXED )

	test	cl, 2
	je	SHORT $LN28@difference

; 43   :       sum -= q->pressure*q->value;

	fld	QWORD PTR [eax-352]
	fmul	QWORD PTR [eax-312]
	fsubp	ST(1), ST(0)
$LN28@difference:

; 40   :   { q = GEN_QUANT(k);
; 41   :     if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN29@difference

; 42   :     if ( q->flags & Q_FIXED )

	test	cl, 2
	je	SHORT $LN29@difference

; 43   :       sum -= q->pressure*q->value;

	fld	QWORD PTR [eax+56]
	fmul	QWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
$LN29@difference:

; 40   :   { q = GEN_QUANT(k);
; 41   :     if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax+368]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN30@difference

; 42   :     if ( q->flags & Q_FIXED )

	test	cl, 2
	je	SHORT $LN30@difference

; 43   :       sum -= q->pressure*q->value;

	fld	QWORD PTR [eax+424]
	fmul	QWORD PTR [eax+384]
	fsubp	ST(1), ST(0)
$LN30@difference:

; 40   :   { q = GEN_QUANT(k);
; 41   :     if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax+736]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN31@difference

; 42   :     if ( q->flags & Q_FIXED )

	test	cl, 2
	je	SHORT $LN31@difference

; 43   :       sum -= q->pressure*q->value;

	fld	QWORD PTR [eax+792]
	fmul	QWORD PTR [eax+752]
	fsubp	ST(1), ST(0)
$LN31@difference:

; 39   :   for ( k = 0 ; k < gen_quant_count ; k++ )

	add	eax, 1472				; 000005c0H
	dec	edx
	jne	$LN32@difference
$LC27@difference:
	cmp	edi, esi
	jge	SHORT $LN26@difference
	mov	ecx, edi
	imul	ecx, 368				; 00000170H
	sub	esi, edi
	lea	eax, DWORD PTR [ecx+ebx+136]
	mov	edx, esi
$LC5@difference:

; 40   :   { q = GEN_QUANT(k);
; 41   :     if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN4@difference

; 42   :     if ( q->flags & Q_FIXED )

	test	cl, 2
	je	SHORT $LN4@difference

; 43   :       sum -= q->pressure*q->value;

	fld	QWORD PTR [eax+56]
	fmul	QWORD PTR [eax+16]
	fsubp	ST(1), ST(0)
$LN4@difference:

; 39   :   for ( k = 0 ; k < gen_quant_count ; k++ )

	add	eax, 368				; 00000170H
	dec	edx
	jne	SHORT $LC5@difference
$LN26@difference:
	pop	edi
	pop	esi
	pop	ebx

; 44   :   }
; 45   :   return sum;
; 46   : 
; 47   : } // end difference_lagrangian()

	mov	esp, ebp
	pop	ebp
	ret	0
_difference_lagrangian ENDP
_TEXT	ENDS
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3ef4f8b588e368f1
PUBLIC	__real@3ee4f8b588e368f1
PUBLIC	_rhs$GSCopy$
PUBLIC	_verhead$GSCopy$
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_difference_hessian
EXTRN	_fill_mixed_entry:PROC
EXTRN	_fill_self_entry:PROC
EXTRN	_hess_flag:DWORD
EXTRN	_fill_grad:PROC
EXTRN	_calc_content:PROC
EXTRN	_calc_energy:PROC
EXTRN	_global_timestamp:DWORD
EXTRN	_mat2d_setup:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3ef4f8b588e368f1
CONST	SEGMENT
__real@3ef4f8b588e368f1 DQ 03ef4f8b588e368f1r	; 2e-005
CONST	ENDS
;	COMDAT __real@3ee4f8b588e368f1
CONST	SEGMENT
__real@3ee4f8b588e368f1 DQ 03ee4f8b588e368f1r	; 1e-005
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _difference_hessian
_TEXT	SEGMENT
_secondqXvS$ = -436					; size = 24
_energyuu$ = -412					; size = 8
tv598 = -408						; size = 4
_e2$ = -404						; size = 8
_energyud$ = -404					; size = 8
_e1$ = -396						; size = 8
_energydd$ = -396					; size = 8
tv862 = -388						; size = 8
_e3$ = -388						; size = 8
_S$GSCopy$ = -380					; size = 4
tv515 = -376						; size = 4
_rhs$GSCopy$ = -372					; size = 4
_x$89131 = -372						; size = 4
_verhead$GSCopy$ = -368					; size = 4
_vv_id$ = -364						; size = 4
_v$89103 = -364						; size = 4
_second$ = -360						; size = 4
_i$ = -356						; size = 4
_v_id$ = -352						; size = 4
tv858 = -348						; size = 4
_ord$89127 = -348					; size = 4
tv942 = -344						; size = 4
tv867 = -344						; size = 4
_secondxJ$ = -340					; size = 288
_first$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_verhead$ = 12						; size = 4
_rhs$ = 16						; size = 4
_difference_hessian PROC				; COMDAT

; 64   : { REAL dx = 0.00001;  /* wiggle size */

	push	ebp
	mov	ebp, esp
	sub	esp, 436				; 000001b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 65   :   REAL first[MAXCOORD];
; 66   :   MAT2D(second,MAXCOORD,MAXCOORD);

	mov	eax, DWORD PTR _S$[ebp]

; 105  :   { FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _verhead$[ebp]
	mov	edx, DWORD PTR _rhs$[ebp]
	push	ebx
	push	esi
	push	edi
	push	6
	mov	DWORD PTR _S$GSCopy$[ebp], eax
	push	6
	lea	eax, DWORD PTR _secondxJ$[ebp]
	mov	DWORD PTR _verhead$GSCopy$[ebp], ecx
	push	eax
	lea	ecx, DWORD PTR _secondqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _rhs$GSCopy$[ebp], edx
	call	_mat2d_setup
	fld	QWORD PTR __real@3ee4f8b588e368f1
	mov	esi, DWORD PTR _web+48
	mov	edi, DWORD PTR _web+12
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	ecx, 1
	mov	DWORD PTR _second$[ebp], eax
	mov	DWORD PTR _v_id$[ebp], esi
	je	$LN31@difference@2

; 67   :   REAL e1,e2,e3,e4;
; 68   :   vertex_id v_id,vv_id;
; 69   :   int i,j;
; 70   :   REAL energyuu,energyud,energydu,energydd; /* really Lagrangians */
; 71   : 
; 72   :   /* right hand side and self second derivatives */
; 73   :   /* move vertices 1 by 1 */
; 74   :   FOR_ALL_VERTICES(v_id)

	jmp	SHORT $LN33@difference@2
$LN60@difference@2:
	mov	esi, DWORD PTR _v_id$[ebp]
$LN33@difference@2:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv515[ebp], esi
	je	$LN32@difference@2

; 75   :   {
; 76   :      int ord = loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN36@difference@2
	mov	eax, esi
	jmp	SHORT $LN37@difference@2
$LN36@difference@2:
	or	eax, -1
$LN37@difference@2:

; 77   :      struct hess_verlist *v = verhead+ord;
; 78   :      REAL *x = get_coord(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ecx+ebx+64]
	shl	eax, 5
	add	eax, DWORD PTR _verhead$GSCopy$[ebp]
	add	ebx, edx

; 79   : 
; 80   :      if ( v->freedom == 0 ) continue;

	cmp	DWORD PTR [eax+8], 0
	mov	DWORD PTR _v$89103[ebp], eax
	je	$LN32@difference@2

; 81   :      for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR _web+616, ecx
	jle	$LN79@difference@2
	mov	edx, DWORD PTR _second$[ebp]
	mov	DWORD PTR tv858[ebp], edx
	mov	eax, ebx
	lea	edx, DWORD PTR _first$[ebp]
	sub	eax, edx
	mov	DWORD PTR tv867[ebp], eax
$LN62@difference@2:

; 82   :       for ( j = 0 ; j <= i ; j++ )

	xor	esi, esi
	test	ecx, ecx
	js	$LN26@difference@2

; 81   :      for ( i = 0 ; i < SDIM ; i++ )

	lea	edi, DWORD PTR _first$[ebp+ecx*8]
$LN61@difference@2:

; 83   :       { 
; 84   :          x[i] += dx; 

	fld	QWORD PTR [eax+edi]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax+edi]

; 85   :          x[j] += dx; global_timestamp++; calc_energy(); calc_content(Q_FIXED);

	fadd	QWORD PTR [ebx+esi*8]
	fstp	QWORD PTR [ebx+esi*8]
	inc	DWORD PTR _global_timestamp
	call	_calc_energy
	push	2
	call	_calc_content
	fstp	ST(0)

; 86   :          energyuu = difference_lagrangian();

	call	_difference_lagrangian
	fstp	QWORD PTR _energyuu$[ebp]

; 87   :          x[j] -= 2*dx; global_timestamp++; calc_energy(); calc_content(Q_FIXED);

	fld	QWORD PTR [ebx+esi*8]
	fsub	QWORD PTR __real@3ef4f8b588e368f1
	fstp	QWORD PTR [ebx+esi*8]
	inc	DWORD PTR _global_timestamp
	call	_calc_energy
	push	2
	call	_calc_content
	fstp	ST(0)

; 88   :          energyud = difference_lagrangian();

	call	_difference_lagrangian
	fstp	QWORD PTR _energyud$[ebp]

; 89   :          x[i] -= 2*dx; global_timestamp++; calc_energy(); calc_content(Q_FIXED);

	mov	eax, DWORD PTR tv867[ebp]
	fld	QWORD PTR [eax+edi]
	fsub	QWORD PTR __real@3ef4f8b588e368f1
	fstp	QWORD PTR [eax+edi]
	inc	DWORD PTR _global_timestamp
	call	_calc_energy
	push	2
	call	_calc_content
	fstp	ST(0)

; 90   :          energydd = difference_lagrangian();

	call	_difference_lagrangian
	fstp	QWORD PTR _energydd$[ebp]

; 91   :          x[j] += 2*dx; global_timestamp++; calc_energy(); calc_content(Q_FIXED);

	fld	QWORD PTR [ebx+esi*8]
	fadd	QWORD PTR __real@3ef4f8b588e368f1
	fstp	QWORD PTR [ebx+esi*8]
	inc	DWORD PTR _global_timestamp
	call	_calc_energy
	push	2
	call	_calc_content
	fstp	ST(0)
	add	esp, 16					; 00000010H

; 92   :          energydu = difference_lagrangian();

	call	_difference_lagrangian

; 93   :          x[i] += dx; x[j] -= dx; /* back to normal */

	mov	eax, DWORD PTR tv867[ebp]
	fld	QWORD PTR [eax+edi]

; 94   :          first[i] = (energyuu - energydu + energyud - energydd)/4/dx;
; 95   :          second[i][j] = second[j][i] =
; 96   :             (energyuu - energyud - energydu + energydd)/4/dx/dx;

	mov	edx, DWORD PTR tv858[ebp]
	fld	QWORD PTR __real@3ee4f8b588e368f1
	inc	esi
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [eax+edi]
	mov	eax, DWORD PTR _second$[ebp]
	fld	QWORD PTR [ebx+esi*8-8]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [ebx+esi*8-8]
	fld	QWORD PTR _energyuu$[ebp]
	fld	ST(0)
	fsub	ST(0), ST(3)
	fld	QWORD PTR _energyud$[ebp]
	fadd	ST(1), ST(0)
	fld	QWORD PTR _energydd$[ebp]
	fsub	ST(2), ST(0)
	fld	QWORD PTR __real@3fd0000000000000
	fmul	ST(3), ST(0)
	fxch	ST(3)
	fdiv	ST(0), ST(5)
	fstp	QWORD PTR [edi]
	fxch	ST(3)
	fsubrp	ST(1), ST(0)
	mov	ecx, DWORD PTR [eax+esi*4-4]
	mov	eax, DWORD PTR _i$[ebp]
	fsubrp	ST(4), ST(0)
	fxch	ST(3)
	faddp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	fdiv	ST(1), ST(0)
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fst	QWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR [edx]
	fstp	QWORD PTR [ecx+esi*8-8]

; 82   :       for ( j = 0 ; j <= i ; j++ )

	cmp	esi, eax
	mov	eax, DWORD PTR tv867[ebp]
	jle	$LN61@difference@2
	mov	ecx, DWORD PTR _i$[ebp]
$LN26@difference@2:

; 81   :      for ( i = 0 ; i < SDIM ; i++ )

	add	DWORD PTR tv858[ebp], 4
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, DWORD PTR _web+616
	jl	$LN62@difference@2
	mov	esi, DWORD PTR tv515[ebp]
	mov	eax, DWORD PTR _v$89103[ebp]
$LN79@difference@2:

; 97   :       }
; 98   :      fill_grad(S,v,first,rhs);

	mov	edx, DWORD PTR _rhs$GSCopy$[ebp]
	fstp	ST(0)
	mov	edi, DWORD PTR _S$GSCopy$[ebp]
	push	edx
	lea	ecx, DWORD PTR _first$[ebp]
	push	ecx
	push	eax
	push	edi
	call	_fill_grad
	add	esp, 16					; 00000010H

; 99   :      if ( hess_flag )

	cmp	DWORD PTR _hess_flag, 0
	je	SHORT $LN56@difference@2

; 100  :         fill_self_entry(S,v_id,second);

	mov	edx, DWORD PTR _second$[ebp]
	mov	eax, DWORD PTR _v_id$[ebp]
	push	edx
	push	eax
	push	edi
	call	_fill_self_entry
	add	esp, 12					; 0000000cH
$LN56@difference@2:
	fld	QWORD PTR __real@3ee4f8b588e368f1
	mov	edi, DWORD PTR _web+12
$LN32@difference@2:

; 67   :   REAL e1,e2,e3,e4;
; 68   :   vertex_id v_id,vv_id;
; 69   :   int i,j;
; 70   :   REAL energyuu,energyud,energydu,energydd; /* really Lagrangians */
; 71   : 
; 72   :   /* right hand side and self second derivatives */
; 73   :   /* move vertices 1 by 1 */
; 74   :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [edi+esi*4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR _v_id$[ebp], ecx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LN60@difference@2
$LN31@difference@2:

; 101  :   }
; 102  : 
; 103  :   /* second derivatives, go through all pairs of vertices */
; 104  :   if ( hess_flag )

	cmp	DWORD PTR _hess_flag, 0
	je	$LN136@difference@2

; 105  :   { FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _v_id$[ebp], edx
	je	$LN136@difference@2
	jmp	SHORT $LN19@difference@2
$LN58@difference@2:
	mov	edx, DWORD PTR _v_id$[ebp]
$LN19@difference@2:
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+edx*4]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv515[ebp], edx
	je	$LN18@difference@2

; 106  :     {
; 107  :        int ord = loc_ordinal(v_id);

	mov	DWORD PTR _ord$89127[ebp], edx
	test	ecx, ecx
	jne	SHORT $LN39@difference@2
	mov	DWORD PTR _ord$89127[ebp], -1
$LN39@difference@2:

; 108  :        struct hess_verlist *v = verhead+ord;
; 109  :        REAL *x = get_coord(v_id);

	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ecx+64]

; 110  :   
; 111  :        if ( v->freedom == 0 ) continue;

	mov	ecx, DWORD PTR _verhead$GSCopy$[ebp]
	add	eax, esi
	mov	DWORD PTR _x$89131[ebp], eax
	mov	eax, DWORD PTR _ord$89127[ebp]
	shl	eax, 5
	cmp	DWORD PTR [eax+ecx+8], ebx
	je	$LN18@difference@2

; 112  :        
; 113  :        FOR_ALL_VERTICES(vv_id)

	mov	esi, DWORD PTR _web+48
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR _vv_id$[ebp], esi
	je	$LN18@difference@2
	jmp	SHORT $LN13@difference@2
$LN59@difference@2:
	mov	esi, DWORD PTR _vv_id$[ebp]
$LN13@difference@2:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv598[ebp], esi
	je	$LN12@difference@2

; 114  :        {
; 115  :           int ordd = loc_ordinal(vv_id);

	test	ecx, ecx
	je	SHORT $LN40@difference@2
	mov	eax, esi
	jmp	SHORT $LN41@difference@2
$LN40@difference@2:
	or	eax, -1
$LN41@difference@2:

; 116  :           struct hess_verlist *vv = verhead+ordd;
; 117  :           REAL *xx = get_coord(vv_id);

	mov	ecx, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ecx+ebx+64]

; 118  :   
; 119  :           if ( vv->freedom == 0 ) continue;

	mov	ecx, DWORD PTR _verhead$GSCopy$[ebp]
	add	ebx, edx
	mov	edx, eax
	shl	edx, 5
	cmp	DWORD PTR [edx+ecx+8], 0
	je	$LN12@difference@2

; 120  :           if ( ord <= ordd ) continue; /* hessian is lower triangular */ 

	cmp	DWORD PTR _ord$89127[ebp], eax
	jle	$LN12@difference@2

; 121  :         
; 122  :           for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	mov	DWORD PTR _i$[ebp], 0
	test	eax, eax
	jle	$LN126@difference@2
	mov	edx, DWORD PTR _second$[ebp]
	mov	edi, DWORD PTR _x$89131[ebp]
	mov	DWORD PTR tv942[ebp], edx
$LN6@difference@2:

; 123  :             for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	eax, eax
	jle	$LN5@difference@2
$LN3@difference@2:

; 124  :                {
; 125  :                   x[i] += dx; 

	fld	QWORD PTR [edi]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [edi]

; 126  :                   xx[j] += dx; global_timestamp++; calc_energy(); calc_content(Q_FIXED);

	fadd	QWORD PTR [ebx+esi*8]
	fstp	QWORD PTR [ebx+esi*8]
	inc	DWORD PTR _global_timestamp
	call	_calc_energy
	push	2
	call	_calc_content
	fstp	ST(0)

; 127  :                   e1 = difference_lagrangian();

	call	_difference_lagrangian
	fstp	QWORD PTR _e1$[ebp]

; 128  :                   x[i] -= 2*dx; global_timestamp++; calc_energy(); calc_content(Q_FIXED);

	fld	QWORD PTR [edi]
	fsub	QWORD PTR __real@3ef4f8b588e368f1
	fstp	QWORD PTR [edi]
	inc	DWORD PTR _global_timestamp
	call	_calc_energy
	push	2
	call	_calc_content
	fstp	ST(0)

; 129  :                   e2 = difference_lagrangian();

	call	_difference_lagrangian
	fstp	QWORD PTR _e2$[ebp]

; 130  :                   xx[j] -= 2*dx; global_timestamp++; calc_energy(); calc_content(Q_FIXED);

	fld	QWORD PTR [ebx+esi*8]
	fsub	QWORD PTR __real@3ef4f8b588e368f1
	fstp	QWORD PTR [ebx+esi*8]
	inc	DWORD PTR _global_timestamp
	call	_calc_energy
	push	2
	call	_calc_content
	fstp	ST(0)

; 131  :                   e3 = difference_lagrangian();

	call	_difference_lagrangian
	fstp	QWORD PTR _e3$[ebp]

; 132  :                   x[i] += 2*dx; global_timestamp++; calc_energy(); calc_content(Q_FIXED);

	fld	QWORD PTR [edi]
	fadd	QWORD PTR __real@3ef4f8b588e368f1
	fstp	QWORD PTR [edi]
	inc	DWORD PTR _global_timestamp
	call	_calc_energy
	push	2
	call	_calc_content
	fstp	ST(0)

; 133  :                   e4 = difference_lagrangian();
; 134  :                   second[i][j] = (e1 - e2 + e3 - e4)/4/dx/dx;

	fld	QWORD PTR _e1$[ebp]
	add	esp, 16					; 00000010H
	fsub	QWORD PTR _e2$[ebp]
	fadd	QWORD PTR _e3$[ebp]
	fstp	QWORD PTR tv862[ebp]
	call	_difference_lagrangian
	fsubr	QWORD PTR tv862[ebp]
	mov	eax, DWORD PTR tv942[ebp]
	mov	ecx, DWORD PTR [eax]
	inc	esi
	fmul	QWORD PTR __real@3fd0000000000000
	fld	QWORD PTR __real@3ee4f8b588e368f1
	fdiv	ST(1), ST(0)
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [ecx+esi*8-8]

; 135  :                   x[i] -= dx; xx[j] += dx;

	fld	QWORD PTR [edi]
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [edi]
	fld	QWORD PTR [ebx+esi*8-8]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [ebx+esi*8-8]
	mov	eax, DWORD PTR _web+616
	cmp	esi, eax
	jl	$LN3@difference@2
$LN5@difference@2:

; 121  :         
; 122  :           for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	add	DWORD PTR tv942[ebp], 4
	inc	ecx
	add	edi, 8
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, eax
	jl	$LN6@difference@2
	mov	esi, DWORD PTR tv598[ebp]
$LN126@difference@2:

; 136  :                }
; 137  :           fill_mixed_entry(S,v_id,vv_id,second);

	mov	edx, DWORD PTR _second$[ebp]
	fstp	ST(0)
	mov	eax, DWORD PTR _vv_id$[ebp]
	mov	ecx, DWORD PTR _v_id$[ebp]
	push	edx
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_fill_mixed_entry
	fld	QWORD PTR __real@3ee4f8b588e368f1
	mov	edi, DWORD PTR _web+12
	add	esp, 16					; 00000010H
$LN12@difference@2:

; 112  :        
; 113  :        FOR_ALL_VERTICES(vv_id)

	mov	eax, DWORD PTR [edi+esi*4]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vv_id$[ebp], ecx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LN59@difference@2
	mov	edx, DWORD PTR tv515[ebp]
$LN18@difference@2:

; 105  :   { FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [edi+edx*4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR _v_id$[ebp], ecx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LN58@difference@2
$LN136@difference@2:

; 112  :        
; 113  :        FOR_ALL_VERTICES(vv_id)

	fstp	ST(0)

; 138  :        }
; 139  :     }
; 140  :   }
; 141  :   calc_energy(); calc_content(Q_FIXED); /* cleanup */

	call	_calc_energy
	push	2
	call	_calc_content
	fstp	ST(0)

; 142  : } /* end difference_hessian */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 4
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_difference_hessian ENDP
_TEXT	ENDS
PUBLIC	__real@4010000000000000
PUBLIC	__real@4008000000000000
PUBLIC	??_C@_0BJ@DPGPLKJJ@scale?5?$CFf?5energy?5?$CF20?415f?6?$AA@ ; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@bfe0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@		; `string'
PUBLIC	??_C@_0CH@EFDDFDKP@Cannot?5do?5dirichlet?5with?5constra@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_dirichlet
EXTRN	_hessian_exit:PROC
EXTRN	_free_system:PROC
EXTRN	_free_matrix:PROC
EXTRN	_restore_coords:PROC
EXTRN	_printf:PROC
EXTRN	_itdebug:DWORD
EXTRN	_hess_debug:DWORD
EXTRN	_save_coords:PROC
EXTRN	_saved:BYTE
EXTRN	_sp_hessian_solve:PROC
EXTRN	_sp_hess_project_setup_func:DWORD
EXTRN	_sp_factor:PROC
EXTRN	_sp_ordering_func:DWORD
EXTRN	_sp_constraint_setup_func:DWORD
EXTRN	_sp_AIJ_setup_func:DWORD
EXTRN	_sp_hash_end:PROC
EXTRN	_sp_hash_search:PROC
EXTRN	_vhead:DWORD
EXTRN	_vhead_attr:DWORD
EXTRN	_dot:PROC
EXTRN	_get_edge_side:PROC
EXTRN	_kb_dmatrix:PROC
EXTRN	_hessian_init:PROC
EXTRN	_hmode:DWORD
EXTRN	_kb_error:PROC
EXTRN	_fixed_constraint_flag:DWORD
EXTRN	_memset:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@4010000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT ??_C@_0BJ@DPGPLKJJ@scale?5?$CFf?5energy?5?$CF20?415f?6?$AA@
CONST	SEGMENT
??_C@_0BJ@DPGPLKJJ@scale?5?$CFf?5energy?5?$CF20?415f?6?$AA@ DB 'scale %f '
	DB	'energy %20.15f', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@bfe0000000000000
CONST	SEGMENT
__real@bfe0000000000000 DQ 0bfe0000000000000r	; -0.5
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
CONST	SEGMENT
??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@ DB 'HESSIAN2.C', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EFDDFDKP@Cannot?5do?5dirichlet?5with?5constra@
CONST	SEGMENT
??_C@_0CH@EFDDFDKP@Cannot?5do?5dirichlet?5with?5constra@ DB 'Cannot do di'
	DB	'richlet with constraints.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\hessian2.c
CONST	ENDS
;	COMDAT _dirichlet
_TEXT	SEGMENT
_S$ = -516						; size = 232
_area$ = -284						; size = 8
_cota$ = -276						; size = 8
_s$ = -268						; size = 4
_r$ = -264						; size = 4
tv1661 = -260						; size = 4
_y$ = -256						; size = 4
_xx$ = -252						; size = 4
tv1158 = -248						; size = 4
tv1093 = -248						; size = 4
tv870 = -248						; size = 4
tv769 = -244						; size = 4
_k$89263 = -244						; size = 4
tv1686 = -240						; size = 4
_i$ = -240						; size = 4
_rs$ = -236						; size = 4
tv1010 = -232						; size = 8
_scale$ = -232						; size = 8
_best_scale$ = -232					; size = 8
tv1293 = -224						; size = 4
_x$ = -224						; size = 4
_side$ = -220						; size = 144
_ss$ = -76						; size = 24
_sd$ = -52						; size = 24
_energies$89261 = -28					; size = 24
_v$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_seekmode$ = 8						; size = 4
_dirichlet PROC						; COMDAT

; 172  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 516				; 00000204H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 173  :   REAL side[FACET_EDGES][MAXCOORD];
; 174  :   REAL *x,*y;
; 175  :   int r,s;
; 176  :   REAL area;
; 177  :   REAL cota;
; 178  :   int i,j;
; 179  :   facet_id f_id;
; 180  :   edge_id e_id;
; 181  :   vertex_id v[3];
; 182  :   facetedge_id fe;
; 183  :   REAL ss[FACET_VERTS],sd[FACET_VERTS];
; 184  :   int ii,iii;
; 185  :   REAL **rs;  /* one right side for each coordinate */
; 186  :   REAL **xx;  /* one solution vector for each coordinate */
; 187  :   struct hess_verlist *vc;              /* current  vertex */
; 188  :   struct hess_verlist *rv,*sv;
; 189  :   REAL scale;
; 190  :   REAL best_scale;
; 191  :   struct linsys S;
; 192  :   vertex_id v_id;
; 193  : 
; 194  :   if ( fixed_constraint_flag ) 

	cmp	DWORD PTR _fixed_constraint_flag, 0
	je	SHORT $LN108@dirichlet

; 195  :      kb_error(2081,"Cannot do dirichlet with constraints.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CH@EFDDFDKP@Cannot?5do?5dirichlet?5with?5constra@
	push	2081					; 00000821H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN108@dirichlet:

; 196  :   hmode = SINGLE_DEGREE; /* same hessian for each coordinate */
; 197  :   hessian_init(&S,NULL);

	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _S$[ebp]
	push	0
	push	eax
	mov	DWORD PTR _hmode, 2
	call	_hessian_init

; 198  :   rs = dmatrix(0,SDIM-1,0,S.A_rows); /* right side for each coord */

	mov	ecx, DWORD PTR _S$[ebp+12]
	mov	edx, DWORD PTR _web+616
	push	198					; 000000c6H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	push	ecx
	push	0
	dec	edx
	push	edx
	push	0
	call	_kb_dmatrix

; 199  :   xx = dmatrix(0,SDIM-1,0,S.A_rows); /* solution vector for each coord */

	mov	ecx, DWORD PTR _web+616
	push	199					; 000000c7H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	mov	DWORD PTR _rs$[ebp], eax
	mov	eax, DWORD PTR _S$[ebp+12]
	push	eax
	push	0
	dec	ecx
	push	ecx
	push	0
	call	_kb_dmatrix

; 200  :                       /*  differences from current */
; 201  :                                       
; 202  :   /* fill in */
; 203  :   FOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR _web+272
	mov	edx, esi
	shr	edx, 28					; 0000001cH
	add	esp, 56					; 00000038H
	and	edx, 1
	mov	DWORD PTR _xx$[ebp], eax
	je	$LN109@dirichlet
$LL113@dirichlet:
	mov	eax, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv870[ebp], ecx
	je	$LN61@dirichlet

; 204  :     { fe = get_facet_fe(f_id);

	test	edx, edx
	je	SHORT $LN68@dirichlet
$LN67@dirichlet:
	mov	edi, DWORD PTR [edi+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN66@dirichlet
	xor	edi, 134217728				; 08000000H
$LN66@dirichlet:
	mov	ebx, edi
$LN68@dirichlet:

; 205  :       for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _web+460
	lea	ecx, DWORD PTR _side$[ebp]
	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR tv1293[ebp], ecx
	npad	2
$LL110@dirichlet:

; 206  :          { e_id = get_fe_edge(fe);

	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+eax]

; 207  :             get_edge_side(e_id,side[i]);

	mov	eax, DWORD PTR tv1293[ebp]
	mov	esi, ebx
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [edx+20]
	push	eax
	push	esi
	call	_get_edge_side

; 208  :             v[i] = get_edge_tailv(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR _web+216
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN73@dirichlet
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN72@dirichlet
$LN73@dirichlet:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]
$LN72@dirichlet:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _v$[ebp+ecx*4], eax

; 209  :             fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	mov	edx, DWORD PTR [edi+eax]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN77@dirichlet
	mov	ebx, DWORD PTR [edx+28]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN56@dirichlet
$LN77@dirichlet:
	mov	ebx, DWORD PTR [edx+32]
$LN56@dirichlet:

; 205  :       for ( i = 0 ; i < FACET_VERTS ; i++ )

	add	DWORD PTR tv1293[ebp], 48		; 00000030H
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, 3
	jl	$LL110@dirichlet

; 210  :          }
; 211  : 
; 212  :       for ( i = 0 ; i < FACET_VERTS ; i++ )

	xor	esi, esi
	lea	edi, DWORD PTR _side$[ebp]
	npad	3
$LL54@dirichlet:

; 213  :         { ss[i] = SDIM_dot(side[i],side[i]);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	edi
	push	edi
	call	_dot
	fstp	QWORD PTR _ss$[ebp+esi*8]

; 214  :           sd[i] = SDIM_dot(side[i],side[(i+2)%FACET_VERTS]);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	eax, DWORD PTR [esi+2]
	cdq
	mov	ecx, 3
	idiv	ecx
	lea	edx, DWORD PTR [edx+edx*2]
	add	edx, edx
	lea	eax, DWORD PTR _side$[ebp+edx*8]
	push	eax
	push	edi
	call	_dot
	fstp	QWORD PTR _sd$[ebp+esi*8]
	inc	esi
	add	esp, 24					; 00000018H
	add	edi, 48					; 00000030H
	cmp	esi, 3
	jl	SHORT $LL54@dirichlet

; 215  :         }
; 216  : 
; 217  :       area = sqrt(ss[0]*ss[2] - sd[0]*sd[0]);

	fld	QWORD PTR _ss$[ebp+16]
	fmul	QWORD PTR _ss$[ebp]
	fld	QWORD PTR _sd$[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR _area$[ebp]
	mov	esi, 2
	lea	ecx, DWORD PTR _sd$[ebp]
	mov	DWORD PTR tv1661[ebp], esi
	mov	DWORD PTR tv1686[ebp], ecx
	mov	DWORD PTR tv769[ebp], 3
	jmp	SHORT $LN51@dirichlet
	npad	2
$LL107@dirichlet:
	mov	esi, DWORD PTR tv1661[ebp]
$LN51@dirichlet:

; 219  :         { ii = (i+1)%FACET_VERTS; iii = (i+2)%FACET_VERTS;

	lea	eax, DWORD PTR [esi-1]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, esi
	mov	esi, 3

; 220  :           x = get_coord(v[ii]);

	mov	ebx, DWORD PTR _web+12
	mov	ecx, edx
	cdq
	idiv	esi
	mov	eax, DWORD PTR _v$[ebp+ecx*4]
	mov	esi, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [esi+ecx+64]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	lea	edi, DWORD PTR [ecx+eax]
	mov	DWORD PTR _x$[ebp], edi

; 221  :           y = get_coord(v[iii]);

	mov	edx, DWORD PTR _v$[ebp+edx*4]
	and	edx, 134217727				; 07ffffffH
	lea	ebx, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR [ebx]
	add	ecx, edx
	mov	DWORD PTR _y$[ebp], ecx

; 222  :           rv = get_vertex_vhead(v[ii]);

	mov	ecx, DWORD PTR _vhead_attr
	imul	ecx, 240				; 000000f0H
	add	ecx, esi
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+esi+64]
	mov	esi, DWORD PTR [ecx+eax]

; 223  :           sv = get_vertex_vhead(v[iii]);

	mov	edi, DWORD PTR [ecx+edx]
	shl	esi, 5
	add	esi, DWORD PTR _vhead

; 224  :           r = rv->rownum;
; 225  :           s = sv->rownum;
; 226  :           cota = -sd[i]/area;
; 227  :           if ( get_vattr(v[ii]) & FIXED )

	mov	eax, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR _r$[ebp], edx
	mov	edx, DWORD PTR tv1686[ebp]

; 228  :              if ( get_vattr(v[iii]) & FIXED )

	mov	ebx, DWORD PTR [ebx]
	shl	edi, 5
	fld	QWORD PTR [edx]
	add	edi, DWORD PTR _vhead
	fdiv	QWORD PTR _area$[ebp]
	and	eax, 64					; 00000040H
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR _s$[ebp], ecx
	xor	ecx, ecx
	or	eax, ecx
	mov	eax, DWORD PTR [ebx+8]
	fchs
	fst	QWORD PTR _cota$[ebp]
	je	$LN48@dirichlet
	and	eax, 64					; 00000040H
	or	eax, ecx
	jne	$LN132@dirichlet

; 229  :                 continue;
; 230  :              else /* rhs contribution */
; 231  :              { 
; 232  :                 sp_hash_search(&S,sv->rownum,sv->rownum,0.5*cota);

	fmul	QWORD PTR __real@3fe0000000000000
	mov	edi, DWORD PTR [edi+12]
	sub	esp, 8
	lea	eax, DWORD PTR _S$[ebp]
	fst	QWORD PTR tv1010[ebp]
	fstp	QWORD PTR [esp]
	push	edi
	push	edi
	push	eax
	call	_sp_hash_search

; 233  :                 for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _web+616, ecx
	jle	$LN50@dirichlet
	mov	eax, DWORD PTR _x$[ebp]
	fld	QWORD PTR tv1010[ebp]
	mov	esi, DWORD PTR _y$[ebp]
	sub	esi, eax
$LN45@dirichlet:

; 234  :                   rs[j][s] += 0.5*cota*(y[j] - x[j]);

	fld	QWORD PTR [esi+eax]
	mov	edx, DWORD PTR _rs$[ebp]
	fsub	QWORD PTR [eax]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	edi, DWORD PTR _s$[ebp]
	lea	edx, DWORD PTR [edx+edi*8]
	fmul	ST(0), ST(1)
	inc	ecx
	add	eax, 8
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN45@dirichlet

; 235  :              }
; 236  :           else

	jmp	$LN132@dirichlet
$LN48@dirichlet:

; 237  :              if ( get_vattr(v[iii]) & FIXED )
; 238  :              { /* rhs contribution */
; 239  :                 sp_hash_search(&S,rv->rownum,rv->rownum,0.5*cota);

	fmul	QWORD PTR __real@3fe0000000000000
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	sub	esp, 8
	or	eax, ecx
	fst	QWORD PTR tv1010[ebp]
	fstp	QWORD PTR [esp]
	je	SHORT $LN41@dirichlet
	mov	esi, DWORD PTR [esi+12]
	push	esi
	lea	eax, DWORD PTR _S$[ebp]
	push	esi
	push	eax
	call	_sp_hash_search

; 240  :                 for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _web+616, ecx
	jle	$LN50@dirichlet
	mov	eax, DWORD PTR _y$[ebp]
	fld	QWORD PTR tv1010[ebp]
	mov	esi, DWORD PTR _x$[ebp]
	sub	esi, eax
$LN40@dirichlet:

; 241  :                   rs[j][r] += 0.5*cota*(x[j] - y[j]);

	fld	QWORD PTR [esi+eax]
	mov	edx, DWORD PTR _rs$[ebp]
	fsub	QWORD PTR [eax]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	edi, DWORD PTR _r$[ebp]
	lea	edx, DWORD PTR [edx+edi*8]
	fmul	ST(0), ST(1)
	inc	ecx
	add	eax, 8
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN40@dirichlet

; 242  :               }
; 243  :              else /* main hessian contribution */

	jmp	$LN132@dirichlet
$LN41@dirichlet:

; 244  :               {
; 245  :                  sp_hash_search(&S,rv->rownum,rv->rownum,0.5*cota);

	mov	eax, DWORD PTR [esi+12]
	push	eax
	push	eax
	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	call	_sp_hash_search

; 246  :                  sp_hash_search(&S,sv->rownum,sv->rownum,0.5*cota);

	fld	QWORD PTR tv1010[ebp]
	mov	eax, DWORD PTR [edi+12]
	fstp	QWORD PTR [esp+12]
	add	esp, 12					; 0000000cH
	push	eax
	push	eax
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_sp_hash_search

; 247  :                  if ( sv->rownum < rv->rownum )
; 248  :                    sp_hash_search(&S,sv->rownum,rv->rownum,-0.5*cota);

	fld	QWORD PTR _cota$[ebp]
	fmul	QWORD PTR __real@bfe0000000000000
	mov	edi, DWORD PTR [edi+12]
	mov	esi, DWORD PTR [esi+12]
	add	esp, 20					; 00000014H
	sub	esp, 8
	fstp	QWORD PTR [esp]
	cmp	edi, esi
	jge	SHORT $LN36@dirichlet
	push	esi
	push	edi
	lea	edx, DWORD PTR _S$[ebp]
	push	edx

; 249  :                  else

	jmp	SHORT $LN168@dirichlet
$LN36@dirichlet:

; 250  :                    sp_hash_search(&S,rv->rownum,sv->rownum,-0.5*cota);

	push	edi
	push	esi
	lea	eax, DWORD PTR _S$[ebp]
	push	eax
$LN168@dirichlet:
	call	_sp_hash_search

; 251  :                  for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN50@dirichlet
	mov	eax, DWORD PTR _x$[ebp]
	fld	QWORD PTR tv1010[ebp]
	mov	esi, DWORD PTR _y$[ebp]
	sub	esi, eax
$LN34@dirichlet:

; 252  :                     { rs[j][r] += cota/2*(x[j] - y[j]);

	fld	QWORD PTR [eax]
	mov	ecx, DWORD PTR _rs$[ebp]
	fsub	QWORD PTR [eax+esi]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edi, DWORD PTR _r$[ebp]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fadd	QWORD PTR [ecx+edi*8]
	fstp	QWORD PTR [ecx+edi*8]

; 253  :                       rs[j][s] += cota/2*(y[j] - x[j]);

	mov	edi, DWORD PTR _s$[ebp]
	fld	QWORD PTR [eax+esi-8]
	fsub	QWORD PTR [eax-8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx+edi*8]
	fstp	QWORD PTR [ecx+edi*8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LN34@dirichlet
$LN132@dirichlet:

; 251  :                  for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
$LN50@dirichlet:

; 218  :       for ( i = 0 ; i < FACET_VERTS ; i++ )

	add	DWORD PTR tv1686[ebp], 8
	mov	eax, 1
	add	DWORD PTR tv1661[ebp], eax
	sub	DWORD PTR tv769[ebp], eax
	jne	$LL107@dirichlet
	mov	ecx, DWORD PTR tv870[ebp]
$LN61@dirichlet:

; 200  :                       /*  differences from current */
; 201  :                                       
; 202  :   /* fill in */
; 203  :   FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ecx+edx]
	mov	esi, DWORD PTR [eax]
	mov	edx, esi
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	$LL113@dirichlet
$LN109@dirichlet:

; 254  :                     }
; 255  : 
; 256  :               }
; 257  :          }
; 258  :      }
; 259  :      
; 260  :   /* extract stuff from hash table */
; 261  :   sp_hash_end(&S,S.A_rows,S.total_rows,A_OFF);

	mov	ecx, DWORD PTR _S$[ebp+28]
	mov	edx, DWORD PTR _S$[ebp+12]
	push	1
	push	ecx
	push	edx
	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	call	_sp_hash_end

; 262  : 
; 263  :   /* solve system */
; 264  :   memset((char*)&S,0,sizeof(struct linsys));

	push	232					; 000000e8H
	lea	ecx, DWORD PTR _S$[ebp]
	push	0
	push	ecx
	call	_memset

; 265  :   (*sp_AIJ_setup_func)(S.A_rows,&S);

	mov	eax, DWORD PTR _S$[ebp+12]
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	push	eax
	call	DWORD PTR _sp_AIJ_setup_func

; 266  :   (*sp_constraint_setup_func)
; 267  :             (web.skel[BODY].max_ord+1 + gen_quant_count,&S);

	mov	edx, DWORD PTR _web+404
	mov	eax, DWORD PTR _web+5528
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	lea	ecx, DWORD PTR [eax+edx+1]
	push	ecx
	call	DWORD PTR _sp_constraint_setup_func

; 268  :   if ( sp_ordering_func ) (*sp_ordering_func)(&S);

	mov	eax, DWORD PTR _sp_ordering_func
	add	esp, 44					; 0000002cH
	test	eax, eax
	je	SHORT $LN31@dirichlet
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	eax
	add	esp, 4
$LN31@dirichlet:

; 269  :   sp_factor(&S,MKL_POS_DEF);

	lea	eax, DWORD PTR _S$[ebp]
	push	2
	push	eax
	call	_sp_factor

; 270  :   (*sp_hess_project_setup_func)(&S);

	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	DWORD PTR _sp_hess_project_setup_func

; 271  :   for ( i = 0 ; i < SDIM ; i++ )

	xor	edi, edi
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+616, edi
	jle	SHORT $LN28@dirichlet
	mov	esi, DWORD PTR _rs$[ebp]
	mov	ebx, DWORD PTR _xx$[ebp]
	sub	ebx, esi
	npad	2
$LL30@dirichlet:

; 272  :       sp_hessian_solve(&S,rs[i],xx[i],NO_SET_PRESSURE);

	mov	edx, DWORD PTR [ebx+esi]
	mov	eax, DWORD PTR [esi]
	push	0
	push	edx
	push	eax
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_sp_hessian_solve
	inc	edi
	add	esp, 16					; 00000010H
	add	esi, 4
	cmp	edi, DWORD PTR _web+616
	jl	SHORT $LL30@dirichlet
$LN28@dirichlet:

; 273  : 
; 274  :   /* move vertices */
; 275  :   if ( seekmode == 0 ) { best_scale = 1.0; }

	cmp	DWORD PTR _seekmode$[ebp], 0
	jne	SHORT $LN27@dirichlet
	fld1

; 276  :   else

	jmp	$LN169@dirichlet
$LN27@dirichlet:

; 277  :   { REAL energies[3]; 
; 278  :     REAL denom;
; 279  :     int k;
; 280  :     vertex_id v_id;
; 281  :     
; 282  :      save_coords(&saved,SAVE_IN_ATTR);  /* in case this doesn't work */

	push	1
	push	OFFSET _saved
	call	_save_coords

; 283  :      energies[0] = web.total_energy;

	fld	QWORD PTR _web+1240
	fstp	QWORD PTR _energies$89261[ebp]

; 284  :      for ( scale = 1.0, k = 1 ; k < 3 ; scale += 1.0, k++ ) 

	mov	esi, 1
	fld1
	add	esp, 8
	fst	QWORD PTR _scale$[ebp]
	mov	DWORD PTR _k$89263[ebp], esi
	jmp	SHORT $LN25@dirichlet
$LN163@dirichlet:
	fstp	ST(1)
$LN25@dirichlet:

; 285  :      { 
; 286  :        FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	$LN149@dirichlet
	mov	edi, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
$LN111@dirichlet:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	esi, DWORD PTR [eax+edx]
	mov	DWORD PTR tv1093[ebp], eax
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN21@dirichlet

; 287  :         { REAL *coord;
; 288  : 
; 289  :           vc = get_vertex_vhead(v_id);

	mov	eax, DWORD PTR _vhead_attr
	imul	eax, 240				; 000000f0H
	add	eax, edi
	mov	ecx, DWORD PTR [eax+ebx+64]
	mov	edx, DWORD PTR [esi+ecx]
	shl	edx, 5
	add	edx, DWORD PTR _vhead

; 290  :           if ( vc->freedom == 0 ) continue;

	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN21@dirichlet

; 291  :           coord = get_coord(v_id);

	mov	ecx, DWORD PTR [edi+ebx+64]

; 292  :           for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	add	ecx, esi
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN21@dirichlet
$LN16@dirichlet:

; 293  :              coord[j] = coord[j] - scale*xx[j][vc->rownum];

	mov	edi, DWORD PTR _xx$[ebp]
	mov	esi, DWORD PTR [edx+12]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+esi*8]
	inc	eax
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [ecx+eax*8-8]
	fstp	QWORD PTR [ecx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN16@dirichlet

; 292  :           for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
$LN21@dirichlet:

; 285  :      { 
; 286  :        FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR tv1093[ebp]
	mov	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	jne	$LN111@dirichlet
	mov	esi, DWORD PTR _k$89263[ebp]
$LN149@dirichlet:

; 294  :         }
; 295  :         global_timestamp++;

	inc	DWORD PTR _global_timestamp
	fstp	ST(0)

; 296  :         calc_energy();  /* energy after motion */

	call	_calc_energy

; 297  :         if ( hess_debug || itdebug )

	cmp	DWORD PTR _hess_debug, 0
	jne	SHORT $LN12@dirichlet
	cmp	DWORD PTR _itdebug, 0
	je	SHORT $LN13@dirichlet
$LN12@dirichlet:

; 298  : #ifdef FLOAT128
; 299  :           printf("scale %f energy %*.*Qf\n",(DOUBLE)scale,DWIDTH,DPREC,web.total_energy);
; 300  : #elif defined(LONGDOUBLE)
; 301  :           printf("scale %f energy %*.*Lf\n",(DOUBLE)scale,DWIDTH,DPREC,web.total_energy);
; 302  : #else
; 303  :           printf("scale %f energy %20.15f\n",(DOUBLE)scale,web.total_energy);

	fld	QWORD PTR _web+1240
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _scale$[ebp]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BJ@DPGPLKJJ@scale?5?$CFf?5energy?5?$CF20?415f?6?$AA@
	call	_printf
	add	esp, 20					; 00000014H
$LN13@dirichlet:

; 304  : #endif 
; 305  :         energies[k] = web.total_energy;

	fld	QWORD PTR _web+1240

; 306  :         restore_coords(&saved,SAVE_IN_ATTR);

	push	1
	push	OFFSET _saved
	fstp	QWORD PTR _energies$89261[ebp+esi*8]
	call	_restore_coords
	fld	QWORD PTR _scale$[ebp]
	fld1
	inc	esi
	fadd	ST(1), ST(0)
	add	esp, 8
	fxch	ST(1)
	mov	DWORD PTR _k$89263[ebp], esi
	fst	QWORD PTR _scale$[ebp]
	cmp	esi, 3
	jl	$LN163@dirichlet

; 307  :      }
; 308  :      denom = energies[0] - 2*energies[1] + energies[2];

	fstp	ST(0)
	fld	QWORD PTR _energies$89261[ebp+8]
	fld	ST(0)
	fadd	ST(0), ST(1)
	fld	QWORD PTR _energies$89261[ebp]
	fld	ST(0)
	fsubrp	ST(2), ST(0)
	fld	QWORD PTR _energies$89261[ebp+16]
	fadd	ST(2), ST(0)

; 309  :      if ( denom <= 0.0 ) 

	fldz
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN166@dirichlet
	fstp	ST(2)
	fstp	ST(2)
	fstp	ST(1)
	fstp	ST(0)

; 310  :         best_scale = 1.0;  /* energy not convex */

	jmp	SHORT $LN169@dirichlet
$LN166@dirichlet:

; 309  :      if ( denom <= 0.0 ) 

	fstp	ST(4)

; 311  :      else best_scale = 0.5*(3*energies[0]-4*energies[1]+energies[2])/denom;

	fmul	QWORD PTR __real@4008000000000000
	fxch	ST(2)
	fmul	QWORD PTR __real@4010000000000000
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3fe0000000000000
	fdivrp	ST(1), ST(0)
$LN169@dirichlet:

; 312  :             
; 313  :   }
; 314  :   scale = best_scale;
; 315  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	fst	QWORD PTR _best_scale$[ebp]
	test	eax, 268435456				; 10000000H
	je	$LN146@dirichlet
	mov	edi, DWORD PTR _web+104
	mov	esi, DWORD PTR _web+12
	mov	ebx, DWORD PTR _dymem
$LN9@dirichlet:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+esi]
	mov	DWORD PTR tv1158[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN8@dirichlet

; 316  :   { REAL *coord;
; 317  :     vc = get_vertex_vhead(v_id);

	mov	edx, DWORD PTR _vhead_attr
	imul	edx, 240				; 000000f0H
	add	edx, edi
	mov	eax, DWORD PTR [edx+ebx+64]
	mov	ecx, DWORD PTR [ecx+eax]
	shl	ecx, 5
	add	ecx, DWORD PTR _vhead

; 318  :     if ( vc->freedom == 0 ) continue;

	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN8@dirichlet

; 319  :     coord = get_coord(vc->v_id);

	mov	edx, DWORD PTR [ecx]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	add	edx, DWORD PTR [edi+ebx+64]

; 320  :     for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN8@dirichlet
$LN3@dirichlet:

; 321  :       coord[j] = coord[j] - scale*xx[j][vc->rownum];

	mov	edi, DWORD PTR _xx$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+esi*8]
	inc	eax
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [edx+eax*8-8]
	fstp	QWORD PTR [edx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@dirichlet

; 320  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _web+104
	mov	esi, DWORD PTR _web+12
	mov	ebx, DWORD PTR _dymem
$LN8@dirichlet:

; 312  :             
; 313  :   }
; 314  :   scale = best_scale;
; 315  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR tv1158[ebp]
	mov	ecx, DWORD PTR [eax+esi]
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	jne	$LN9@dirichlet
$LN146@dirichlet:

; 322  :   }
; 323  : 
; 324  :   free_matrix(rs);

	mov	edx, DWORD PTR _rs$[ebp]
	fstp	ST(0)
	push	edx
	call	_free_matrix

; 325  :   free_matrix(xx);

	mov	eax, DWORD PTR _xx$[ebp]
	push	eax
	call	_free_matrix

; 326  :   free_system(&S);

	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_free_system

; 327  :   hessian_exit(NULL);

	push	0
	call	_hessian_exit

; 328  : 
; 329  :   return best_scale;

	fld	QWORD PTR _best_scale$[ebp]

; 330  : } /* end dirichlet() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_dirichlet ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@NCCFEMD@Dot?5with?5gradient?3?5?$CFf?6?$AA@ ; `string'
PUBLIC	??_C@_07EEKPMPFH@n?3?5?$CFd?5?5?$AA@		; `string'
PUBLIC	??_C@_09EAELABLM@Motion?3?5?6?$AA@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_03JAIJOMNP@?$CFf?5?$AA@			; `string'
PUBLIC	??_C@_07IJGBKAHB@n?3?5?$CFs?5?5?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0M@CMIHHFGD@Gradient?3?5?6?$AA@		; `string'
PUBLIC	??_C@_0BP@FLFADNPN@Sobolev?5not?5working?5properly?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@COHOFLGL@Cannot?5do?5sobolev?5with?5constrain@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_sobolev
EXTRN	_temp_free:PROC
EXTRN	_vhead_count:DWORD
EXTRN	_sprintf:PROC
EXTRN	_elnames:BYTE
EXTRN	_kb_temp_calloc:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0BH@NCCFEMD@Dot?5with?5gradient?3?5?$CFf?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BH@NCCFEMD@Dot?5with?5gradient?3?5?$CFf?6?$AA@ DB 'Dot with gradie'
	DB	'nt: %f', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EEKPMPFH@n?3?5?$CFd?5?5?$AA@
CONST	SEGMENT
??_C@_07EEKPMPFH@n?3?5?$CFd?5?5?$AA@ DB 'n: %d  ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EAELABLM@Motion?3?5?6?$AA@
CONST	SEGMENT
??_C@_09EAELABLM@Motion?3?5?6?$AA@ DB 'Motion: ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JAIJOMNP@?$CFf?5?$AA@
CONST	SEGMENT
??_C@_03JAIJOMNP@?$CFf?5?$AA@ DB '%f ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IJGBKAHB@n?3?5?$CFs?5?5?$AA@
CONST	SEGMENT
??_C@_07IJGBKAHB@n?3?5?$CFs?5?5?$AA@ DB 'n: %s  ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CMIHHFGD@Gradient?3?5?6?$AA@
CONST	SEGMENT
??_C@_0M@CMIHHFGD@Gradient?3?5?6?$AA@ DB 'Gradient: ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FLFADNPN@Sobolev?5not?5working?5properly?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@FLFADNPN@Sobolev?5not?5working?5properly?4?6?$AA@ DB 'Sobolev n'
	DB	'ot working properly.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@COHOFLGL@Cannot?5do?5sobolev?5with?5constrain@
CONST	SEGMENT
??_C@_0CF@COHOFLGL@Cannot?5do?5sobolev?5with?5constrain@ DB 'Cannot do so'
	DB	'bolev with constraints.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\hessian2.c
CONST	ENDS
;	COMDAT _sobolev
_TEXT	SEGMENT
_S$ = -524						; size = 232
tv1769 = -292						; size = 8
tv997 = -284						; size = 4
_r$ = -280						; size = 4
tv1100 = -276						; size = 4
_rstmp$ = -272						; size = 4
tv1125 = -268						; size = 4
tv1080 = -264						; size = 4
_rs_save$ = -260					; size = 4
_rv$ = -256						; size = 4
_iii$ = -252						; size = 4
tv1751 = -248						; size = 4
_k$89465 = -244						; size = 4
tv285 = -244						; size = 4
tv1775 = -240						; size = 4
tv1749 = -236						; size = 4
_scale$ = -232						; size = 8
_best_scale$ = -232					; size = 8
_area$ = -232						; size = 8
tv1747 = -224						; size = 4
tv1405 = -224						; size = 4
_rs$ = -220						; size = 4
tv1794 = -216						; size = 4
tv1206 = -216						; size = 4
_i$ = -216						; size = 4
tv1605 = -212						; size = 4
tv1556 = -212						; size = 4
tv1490 = -212						; size = 4
_side$ = -208						; size = 144
_sd$ = -64						; size = 24
_v$ = -40						; size = 12
_energies$89463 = -28					; size = 24
_ss$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_seekmode$ = 8						; size = 4
_sobolev PROC						; COMDAT

; 356  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 524				; 0000020cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 357  :   REAL side[FACET_EDGES][MAXCOORD];
; 358  :   int r;
; 359  :   REAL area;
; 360  :   int i,j,k,n;
; 361  :   facet_id f_id;
; 362  :   edge_id e_id;
; 363  :   vertex_id v[3];
; 364  :   vertex_id v_id;
; 365  :   facetedge_id fe;
; 366  :   REAL ss[FACET_VERTS],sd[FACET_VERTS];
; 367  :   int ii,iii;
; 368  :   REAL *rs,*rstmp;  /* one right side for each coordinate */
; 369  :   REAL *rs_save;
; 370  :   struct hess_verlist *vc;              /* current  vertex */
; 371  :   struct hess_verlist *rv,*sv;
; 372  :   REAL scale;
; 373  :   REAL best_scale;
; 374  :   struct linsys S;
; 375  : 
; 376  :   if ( fixed_constraint_flag ) 

	cmp	DWORD PTR _fixed_constraint_flag, 0
	je	SHORT $LN87@sobolev

; 377  :      kb_error(2082,"Cannot do sobolev with constraints.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CF@COHOFLGL@Cannot?5do?5sobolev?5with?5constrain@
	push	2082					; 00000822H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN87@sobolev:

; 378  : 
; 379  : kb_error(2083,"Sobolev not working properly.\n",WARNING);

	push	ebx
	push	esi
	push	edi
	push	2
	push	OFFSET ??_C@_0BP@FLFADNPN@Sobolev?5not?5working?5properly?4?6?$AA@
	push	2083					; 00000823H
	call	_kb_error

; 380  : 
; 381  :   hmode = UNRESTRICTED; /* full hessian needed */
; 382  :   hessian_init(&S,NULL);

	lea	eax, DWORD PTR _S$[ebp]
	push	0
	push	eax
	mov	DWORD PTR _hmode, 0
	call	_hessian_init

; 383  :   rs = (REAL*)temp_calloc(S.A_rows,sizeof(REAL)); /* right side for each coord */

	mov	ecx, DWORD PTR _S$[ebp+12]
	push	383					; 0000017fH
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	push	8
	push	ecx
	call	_kb_temp_calloc

; 384  :   rs_save = (REAL*)temp_calloc(S.A_rows,sizeof(REAL)); /* right side for each coord */

	mov	edx, DWORD PTR _S$[ebp+12]
	push	384					; 00000180H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	push	8
	push	edx
	mov	DWORD PTR _rs$[ebp], eax
	call	_kb_temp_calloc

; 385  :   rstmp = (REAL*)temp_calloc(S.A_rows,sizeof(REAL)); /* right side for each coord */

	push	385					; 00000181H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	mov	DWORD PTR _rs_save$[ebp], eax
	mov	eax, DWORD PTR _S$[ebp+12]
	push	8
	push	eax
	call	_kb_temp_calloc

; 386  : 
; 387  :   /* fill in */
; 388  :   FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	add	esp, 68					; 00000044H
	and	ecx, 1
	mov	DWORD PTR _rstmp$[ebp], eax
	je	$LN84@sobolev
	mov	ebx, DWORD PTR _web+236
$LL86@sobolev:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	esi, DWORD PTR [eax+ebx]
	mov	DWORD PTR tv997[ebp], eax
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN85@sobolev

; 389  :   { fe = get_facet_fe(f_id);

	test	ecx, ecx
	jne	SHORT $LN93@sobolev
	xor	ebx, ebx
	jmp	SHORT $LN94@sobolev
$LN93@sobolev:
	mov	esi, DWORD PTR [esi+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN92@sobolev
	xor	esi, 134217728				; 08000000H
$LN92@sobolev:
	mov	ebx, esi
$LN94@sobolev:

; 390  :     for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _web+460
	lea	ecx, DWORD PTR _side$[ebp]
	mov	DWORD PTR _i$[ebp], edi
	mov	DWORD PTR tv1405[ebp], ecx
	npad	7
$LL81@sobolev:

; 391  :     { e_id = get_fe_edge(fe);

	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+eax]

; 392  :       get_edge_side(e_id,side[i]);

	mov	eax, DWORD PTR tv1405[ebp]
	mov	esi, ebx
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [edx+20]
	push	eax
	push	esi
	call	_get_edge_side

; 393  :       v[i] = get_edge_tailv(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR _web+216
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN99@sobolev
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN98@sobolev
$LN99@sobolev:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]
$LN98@sobolev:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _v$[ebp+ecx*4], eax

; 394  :       fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	mov	edx, DWORD PTR [edi+eax]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN103@sobolev
	mov	ebx, DWORD PTR [edx+28]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN80@sobolev
$LN103@sobolev:
	mov	ebx, DWORD PTR [edx+32]
$LN80@sobolev:

; 390  :     for ( i = 0 ; i < FACET_VERTS ; i++ )

	add	DWORD PTR tv1405[ebp], 48		; 00000030H
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, 3
	jl	$LL81@sobolev

; 395  :     }
; 396  : 
; 397  :     for ( i = 0 ; i < FACET_VERTS ; i++ )

	xor	esi, esi
	lea	edi, DWORD PTR _side$[ebp]
	npad	3
$LL78@sobolev:

; 398  :     { ss[i] = SDIM_dot(side[i],side[i]);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	edi
	push	edi
	call	_dot
	fstp	QWORD PTR _ss$[ebp+esi*8]

; 399  :       sd[i] = SDIM_dot(side[i],side[(i+2)%FACET_VERTS]);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	eax, DWORD PTR [esi+2]
	cdq
	mov	ecx, 3
	idiv	ecx
	lea	edx, DWORD PTR [edx+edx*2]
	add	edx, edx
	lea	eax, DWORD PTR _side$[ebp+edx*8]
	push	eax
	push	edi
	call	_dot
	fstp	QWORD PTR _sd$[ebp+esi*8]
	inc	esi
	add	esp, 24					; 00000018H
	add	edi, 48					; 00000030H
	cmp	esi, 3
	jl	SHORT $LL78@sobolev

; 400  :     }
; 401  : 
; 402  :     area = sqrt(ss[0]*ss[2] - sd[0]*sd[0]);

	fld	QWORD PTR _ss$[ebp+16]
	fmul	QWORD PTR _ss$[ebp]
	fld	QWORD PTR _sd$[ebp]
	fmul	ST(0), ST(0)
	fsubp	ST(1), ST(0)
	call	__CIsqrt
	fst	QWORD PTR _area$[ebp]
	lea	ecx, DWORD PTR _side$[ebp]
	xor	eax, eax
	mov	DWORD PTR tv1794[ebp], ecx
	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR tv1749[ebp], eax
	mov	DWORD PTR tv1751[ebp], 2

; 403  :     for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	DWORD PTR tv1747[ebp], eax
	mov	DWORD PTR tv285[ebp], 3
$LN152@sobolev:

; 404  :     { ii = (i+1)%FACET_VERTS; iii = (i+2)%FACET_VERTS;

	mov	edi, DWORD PTR tv1751[ebp]
	lea	eax, DWORD PTR [edi-1]
	cdq
	mov	esi, 3
	idiv	esi
	mov	eax, edi
	mov	edi, 3
	mov	ebx, DWORD PTR _web+12
	mov	esi, edx
	cdq
	idiv	edi

; 405  :       rv = get_vertex_vhead(v[ii]);

	mov	eax, DWORD PTR _v$[ebp+esi*4]
	mov	esi, DWORD PTR _vhead_attr
	mov	edi, DWORD PTR _dymem
	imul	esi, 240				; 000000f0H
	add	esi, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+edi+64]
	mov	edi, DWORD PTR _vhead
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1080[ebp], eax
	mov	eax, DWORD PTR [eax+ebx]
	mov	eax, DWORD PTR [esi+eax]
	shl	eax, 5
	add	eax, edi
	mov	DWORD PTR _iii$[ebp], edx

; 406  :       sv = get_vertex_vhead(v[iii]);

	mov	edx, DWORD PTR _v$[ebp+edx*4]
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR _rv$[ebp], eax

; 407  :       r = rv->rownum;

	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv1100[ebp], edx
	mov	edx, DWORD PTR [edx+ebx]
	mov	esi, DWORD PTR [edx+esi]
	mov	DWORD PTR _r$[ebp], eax

; 408  :       /* vertex self-term */
; 409  :       if ( !(get_vattr(v[iii]) & FIXED) )

	mov	eax, DWORD PTR [edx+8]
	shl	esi, 5
	and	eax, 64					; 00000040H
	xor	edx, edx
	add	esi, edi
	or	eax, edx
	jne	$LN163@sobolev

; 410  :       { 
; 411  :         for ( j = 0 ; j < SDIM ; j++ )

	xor	ebx, ebx
	test	ecx, ecx
	jle	$LN163@sobolev
	mov	ecx, DWORD PTR tv1747[ebp]
	fdivr	QWORD PTR _ss$[ebp+ecx]
	fstp	QWORD PTR tv1769[ebp]
$LL146@sobolev:

; 412  :         {
; 413  :           sp_hash_search(&S,sv->rownum+j,sv->rownum+j,ss[i]/area);

	mov	eax, DWORD PTR [esi+12]
	fld	QWORD PTR tv1769[ebp]
	sub	esp, 8
	add	eax, ebx
	fstp	QWORD PTR [esp]
	push	eax
	push	eax
	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	call	_sp_hash_search

; 414  :           for ( k = j+1 ; k < SDIM ; k++ )

	mov	ecx, DWORD PTR _web+616
	lea	edi, DWORD PTR [ebx+1]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv1125[ebp], edi
	cmp	edi, ecx
	jge	SHORT $LN70@sobolev
	mov	eax, DWORD PTR tv1749[ebp]
	lea	ecx, DWORD PTR [eax+ebx]
	lea	edx, DWORD PTR _side$[ebp+ecx*8]
	add	eax, edi
	mov	DWORD PTR tv1775[ebp], edx
	lea	edx, DWORD PTR _side$[ebp+eax*8]
	mov	DWORD PTR tv1490[ebp], edx
	npad	3
$LL68@sobolev:

; 415  :              sp_hash_search(&S,sv->rownum+j,sv->rownum+k,
; 416  :                 -side[i][j]*side[i][k]/area);

	mov	ecx, DWORD PTR tv1775[ebp]
	fld	QWORD PTR [ecx]
	mov	edx, DWORD PTR tv1490[ebp]
	fmul	QWORD PTR [edx]
	mov	eax, DWORD PTR [esi+12]
	sub	esp, 8
	lea	ecx, DWORD PTR [eax+edi]
	fdiv	QWORD PTR _area$[ebp]
	add	eax, ebx
	lea	edx, DWORD PTR _S$[ebp]
	fchs
	fstp	QWORD PTR [esp]
	push	ecx
	push	eax
	push	edx
	call	_sp_hash_search
	mov	ecx, DWORD PTR _web+616
	add	DWORD PTR tv1490[ebp], 8
	inc	edi
	add	esp, 20					; 00000014H
	cmp	edi, ecx
	jl	SHORT $LL68@sobolev
$LN70@sobolev:

; 410  :       { 
; 411  :         for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR tv1125[ebp]
	cmp	ebx, ecx
	jl	$LL146@sobolev
	jmp	SHORT $LN69@sobolev
$LN163@sobolev:
	fstp	ST(0)
$LN69@sobolev:

; 417  :          }
; 418  :       }
; 419  :       /* edge cross-term */
; 420  :       if ( !(get_vattr(v[iii]) & FIXED) && !(get_vattr(v[ii]) & FIXED) )

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR tv1100[ebp]
	mov	eax, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	edx, edx
	or	eax, edx
	jne	$LN62@sobolev
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR tv1080[ebp]
	mov	eax, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	edx, edx
	or	eax, edx
	jne	$LN62@sobolev

; 421  :         for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	test	ecx, ecx
	jle	$LN62@sobolev
$LL64@sobolev:

; 422  :         { 
; 423  :           if ( rv->rownum > sv->rownum )

	mov	eax, DWORD PTR _rv$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [esi+12]
	cmp	eax, edx
	jle	$LN61@sobolev

; 424  :           { sp_hash_search(&S,sv->rownum+j,rv->rownum+j,sd[i]/area);

	mov	ecx, DWORD PTR tv1747[ebp]
	fld	QWORD PTR _sd$[ebp+ecx]
	sub	esp, 8
	fdiv	QWORD PTR _area$[ebp]
	add	eax, edi
	add	edx, edi
	fstp	QWORD PTR [esp]
	push	eax
	push	edx
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	_sp_hash_search

; 425  :             for ( k = 0 ; k < SDIM ; k++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 20					; 00000014H
	xor	ebx, ebx
	test	ecx, ecx
	jle	$LN63@sobolev
	mov	eax, DWORD PTR tv1749[ebp]
	add	eax, edi
	lea	ecx, DWORD PTR _side$[ebp+eax*8]
	mov	eax, DWORD PTR _iii$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	add	edx, edx
	lea	eax, DWORD PTR _side$[ebp+edx*8]
	mov	DWORD PTR tv1775[ebp], ecx
	mov	DWORD PTR tv1556[ebp], eax
	npad	1
$LL60@sobolev:

; 426  :                sp_hash_search(&S,sv->rownum+k,rv->rownum+j,
; 427  :                    -side[i][j]*side[iii][k]/area);

	mov	ecx, DWORD PTR tv1775[ebp]
	fld	QWORD PTR [ecx]
	mov	edx, DWORD PTR tv1556[ebp]
	fmul	QWORD PTR [edx]
	mov	eax, DWORD PTR _rv$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [esi+12]
	fdiv	QWORD PTR _area$[ebp]
	sub	esp, 8
	add	ecx, edi
	add	edx, ebx
	lea	eax, DWORD PTR _S$[ebp]
	fchs
	fstp	QWORD PTR [esp]
	push	ecx
	push	edx
	push	eax
	call	_sp_hash_search
	mov	ecx, DWORD PTR _web+616
	add	DWORD PTR tv1556[ebp], 8
	inc	ebx
	add	esp, 20					; 00000014H
	cmp	ebx, ecx
	jl	SHORT $LL60@sobolev

; 428  :           }
; 429  :           else 

	jmp	$LN63@sobolev
$LN61@sobolev:

; 430  :           {
; 431  :             for ( k = 0 ; k < SDIM ; k++ )

	xor	ebx, ebx
	test	ecx, ecx
	jle	$LN63@sobolev
	mov	eax, DWORD PTR _iii$[ebp]
	mov	ecx, DWORD PTR tv1749[ebp]
	add	ecx, edi
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR _side$[ebp+ecx*8]
	add	eax, eax
	lea	ecx, DWORD PTR _side$[ebp+eax*8]
	mov	DWORD PTR tv1775[ebp], edx
	mov	DWORD PTR tv1605[ebp], ecx
	npad	3
$LL147@sobolev:

; 432  :               sp_hash_search(&S,rv->rownum+k,sv->rownum+j,
; 433  :                   -side[i][j]*side[iii][k]/area);

	mov	edx, DWORD PTR tv1775[ebp]
	fld	QWORD PTR [edx]
	mov	eax, DWORD PTR tv1605[ebp]
	fmul	QWORD PTR [eax]
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR _rv$[ebp]
	mov	eax, DWORD PTR [edx+12]
	fdiv	QWORD PTR _area$[ebp]
	sub	esp, 8
	add	ecx, edi
	add	eax, ebx
	fchs
	fstp	QWORD PTR [esp]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_sp_hash_search
	mov	ecx, DWORD PTR _web+616
	add	DWORD PTR tv1605[ebp], 8
	inc	ebx
	add	esp, 20					; 00000014H
	cmp	ebx, ecx
	jl	SHORT $LL147@sobolev
$LN63@sobolev:

; 421  :         for ( j = 0 ; j < SDIM ; j++ )

	inc	edi
	cmp	edi, ecx
	jl	$LL64@sobolev
$LN62@sobolev:

; 434  :           }
; 435  :         }
; 436  :       /* right side */ 
; 437  :       if ( !(get_vattr(v[ii]) & FIXED) )

	mov	edx, DWORD PTR tv1080[ebp]
	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	edx, edx
	or	eax, edx
	jne	SHORT $LN149@sobolev

; 438  :         for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	test	ecx, ecx
	jle	SHORT $LN149@sobolev
	mov	edx, DWORD PTR _rs$[ebp]
	fld	QWORD PTR _area$[ebp]
	mov	ecx, DWORD PTR _iii$[ebp]
	mov	eax, DWORD PTR _r$[ebp]
	mov	esi, DWORD PTR tv1794[ebp]
	lea	eax, DWORD PTR [edx+eax*8]
	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	lea	ebx, DWORD PTR _ss$[ebp+ecx*8]
	lea	edx, DWORD PTR _side$[ebp+edx*8]
$LN52@sobolev:

; 439  :           rs[r+j] -= (sd[i]*side[iii][j] - ss[iii]*side[i][j])/area;

	fld	QWORD PTR [edx]
	mov	ecx, DWORD PTR tv1747[ebp]
	fmul	QWORD PTR _sd$[ebp+ecx]
	inc	edi
	fld	QWORD PTR [esi]
	add	edx, 8
	fmul	QWORD PTR [ebx]
	add	esi, 8
	add	eax, 8
	fsubp	ST(1), ST(0)
	fdiv	ST(0), ST(1)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edi, ecx
	jl	SHORT $LN52@sobolev

; 438  :         for ( j = 0 ; j < SDIM ; j++ )

	jmp	SHORT $LN74@sobolev
$LN149@sobolev:
	fld	QWORD PTR _area$[ebp]
$LN74@sobolev:

; 403  :     for ( i = 0 ; i < FACET_VERTS ; i++ )

	add	DWORD PTR tv1749[ebp], 6
	add	DWORD PTR tv1747[ebp], 8
	add	DWORD PTR tv1794[ebp], 48		; 00000030H
	mov	eax, 1
	add	DWORD PTR tv1751[ebp], eax
	sub	DWORD PTR tv285[ebp], eax
	jne	$LN152@sobolev
	mov	ebx, DWORD PTR _web+236
	fstp	ST(0)
$LN85@sobolev:

; 386  : 
; 387  :   /* fill in */
; 388  :   FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR tv997[ebp]
	mov	eax, DWORD PTR [edx+ebx]
	mov	edx, DWORD PTR [eax]
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL86@sobolev
$LN84@sobolev:

; 440  :     }
; 441  :   }
; 442  :      
; 443  : if ( hess_debug )

	cmp	DWORD PTR _hess_debug, 0
	je	$LN150@sobolev

; 444  : { printf("Gradient: \n");

	push	OFFSET ??_C@_0M@CMIHHFGD@Gradient?3?5?6?$AA@
	call	_printf

; 445  :   FOR_ALL_VERTICES(v_id)

	mov	ebx, DWORD PTR _web+48
	mov	edi, ebx
	shr	edi, 28					; 0000001cH
	add	esp, 4
	and	edi, 1
	je	$LN150@sobolev
	mov	eax, DWORD PTR _web+12
$LL153@sobolev:
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN47@sobolev

; 446  :   { vc = get_vertex_vhead(v_id);

	mov	edx, DWORD PTR _vhead_attr
	mov	eax, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+eax+64]
	mov	esi, DWORD PTR [ecx+edx]
	shl	esi, 5
	add	esi, DWORD PTR _vhead

; 447  :     if ( vc->freedom == 0 ) continue;

	cmp	DWORD PTR [esi+8], 0
	je	$LN47@sobolev

; 448  :     printf("n: %s  ",ELNAME(v_id));

	test	edi, edi
	je	SHORT $LN90@sobolev
	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN91@sobolev
$LN90@sobolev:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN91@sobolev:
	push	eax
	push	OFFSET ??_C@_07IJGBKAHB@n?3?5?$CFs?5?5?$AA@
	call	_printf

; 449  :     for ( j = 0 ; j < SDIM ; j++ ) printf ("%f ",(DOUBLE)rs[vc->rownum+j]);

	xor	edi, edi
	add	esp, 8
	cmp	DWORD PTR _web+616, edi
	jle	SHORT $LN40@sobolev
	npad	7
$LL42@sobolev:
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR _rs$[ebp]
	add	ecx, edi
	fld	QWORD PTR [edx+ecx*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_03JAIJOMNP@?$CFf?5?$AA@
	call	_printf
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR _web+616
	jl	SHORT $LL42@sobolev
$LN40@sobolev:

; 450  :     printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	add	esp, 4
$LN47@sobolev:

; 445  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	ebx, DWORD PTR [ecx]
	mov	edi, ebx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	$LL153@sobolev
$LN150@sobolev:

; 451  :   }
; 452  : }
; 453  : 
; 454  :   /* extract stuff from hash table */
; 455  :   sp_hash_end(&S,S.A_rows,S.total_rows,A_OFF);

	mov	edx, DWORD PTR _S$[ebp+28]
	mov	eax, DWORD PTR _S$[ebp+12]
	push	1
	push	edx
	push	eax
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_sp_hash_end

; 456  : 
; 457  :   /* solve system */
; 458  :   memcpy((char*)rs_save,(char*)rs,sizeof(REAL)*S.A_rows);

	mov	edx, DWORD PTR _S$[ebp+12]
	mov	ecx, DWORD PTR _rs$[ebp]
	lea	eax, DWORD PTR [edx*8]
	mov	edx, DWORD PTR _rs_save$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_memcpy

; 459  :   (*sp_AIJ_setup_func)(S.A_rows,&S);

	mov	ecx, DWORD PTR _S$[ebp+12]
	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	push	ecx
	call	DWORD PTR _sp_AIJ_setup_func

; 460  :   (*sp_constraint_setup_func)
; 461  :             (web.skel[BODY].max_ord+1 + gen_quant_count,&S);

	mov	eax, DWORD PTR _web+404
	mov	ecx, DWORD PTR _web+5528
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	call	DWORD PTR _sp_constraint_setup_func

; 462  :   if ( sp_ordering_func ) (*sp_ordering_func)(&S);

	mov	eax, DWORD PTR _sp_ordering_func
	add	esp, 44					; 0000002cH
	test	eax, eax
	je	SHORT $LN39@sobolev
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	eax
	add	esp, 4
$LN39@sobolev:

; 463  :   sp_factor(&S,MKL_POS_DEF);

	lea	edx, DWORD PTR _S$[ebp]
	push	2
	push	edx
	call	_sp_factor

; 464  :   (*sp_hess_project_setup_func)(&S);

	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	call	DWORD PTR _sp_hess_project_setup_func

; 465  :   sp_hessian_solve(&S,rs,rstmp,NO_SET_PRESSURE);

	mov	esi, DWORD PTR _rstmp$[ebp]
	mov	edi, DWORD PTR _rs$[ebp]
	push	0
	push	esi
	lea	ecx, DWORD PTR _S$[ebp]
	push	edi
	push	ecx
	call	_sp_hessian_solve

; 466  :   for ( j = 0 ; j < S.N ; j++ ) rs[j] = rstmp[j];

	xor	ecx, ecx
	add	esp, 28					; 0000001cH
	cmp	DWORD PTR _S$[ebp+4], ecx
	jle	SHORT $LN157@sobolev
	mov	edx, esi
	mov	eax, edi
	sub	edx, edi
	npad	1
$LL38@sobolev:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _S$[ebp+4]
	jl	SHORT $LL38@sobolev
$LN157@sobolev:

; 467  : 
; 468  : if ( hess_debug )

	cmp	DWORD PTR _hess_debug, 0
	je	$LN35@sobolev

; 469  : { printf("Motion: \n");

	push	OFFSET ??_C@_09EAELABLM@Motion?3?5?6?$AA@
	call	_printf

; 470  :   for ( n = 0, vc = vhead ; n < vhead_count ; n++, vc++ )

	mov	edi, DWORD PTR _vhead
	xor	ebx, ebx
	add	esp, 4
	cmp	DWORD PTR _vhead_count, ebx
	jle	SHORT $LN32@sobolev

; 469  : { printf("Motion: \n");

	add	edi, 12					; 0000000cH
	npad	2
$LL34@sobolev:

; 471  :   { if ( vc->freedom == 0 ) continue;

	cmp	DWORD PTR [edi-4], 0
	je	SHORT $LN33@sobolev

; 472  :      printf("n: %d  ",n);

	push	ebx
	push	OFFSET ??_C@_07EEKPMPFH@n?3?5?$CFd?5?5?$AA@
	call	_printf

; 473  :      for ( j = 0 ; j < SDIM ; j++ ) printf ("%f ",(DOUBLE)rs[vc->rownum+j]);

	xor	esi, esi
	add	esp, 8
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN28@sobolev
	npad	2
$LL30@sobolev:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR _rs$[ebp]
	add	edx, esi
	fld	QWORD PTR [eax+edx*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_03JAIJOMNP@?$CFf?5?$AA@
	call	_printf
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL30@sobolev
$LN28@sobolev:

; 474  :      printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	add	esp, 4
$LN33@sobolev:

; 470  :   for ( n = 0, vc = vhead ; n < vhead_count ; n++, vc++ )

	inc	ebx
	add	edi, 32					; 00000020H
	cmp	ebx, DWORD PTR _vhead_count
	jl	SHORT $LL34@sobolev
$LN32@sobolev:

; 475  :   }
; 476  :   printf("Dot with gradient: %f\n",(DOUBLE)dot(rs,rs_save,S.A_rows));

	mov	ecx, DWORD PTR _S$[ebp+12]
	mov	edx, DWORD PTR _rs_save$[ebp]
	mov	eax, DWORD PTR _rs$[ebp]
	push	ecx
	push	edx
	push	eax
	call	_dot
	fstp	QWORD PTR [esp+4]
	add	esp, 4
	push	OFFSET ??_C@_0BH@NCCFEMD@Dot?5with?5gradient?3?5?$CFf?6?$AA@
	call	_printf
	add	esp, 12					; 0000000cH
$LN35@sobolev:

; 477  : }
; 478  :   /* move vertices */
; 479  :   if ( seekmode == 0 ) { best_scale = 1.0; }

	cmp	DWORD PTR _seekmode$[ebp], 0
	jne	SHORT $LN27@sobolev
	fld1

; 480  :   else

	jmp	$LN210@sobolev
$LN27@sobolev:

; 481  :   { REAL energies[3]; 
; 482  :     REAL denom;
; 483  :     int k;
; 484  : 
; 485  :      save_coords(&saved,SAVE_IN_ATTR);  /* in case this doesn't work */

	push	1
	push	OFFSET _saved
	call	_save_coords

; 486  :      energies[0] = web.total_energy;

	fld	QWORD PTR _web+1240
	fstp	QWORD PTR _energies$89463[ebp]
	add	esp, 8

; 487  :      for ( scale = 1.0, k = 1 ; k < 3 ; scale += 1.0, k++ ) 

	fld1
	mov	DWORD PTR _k$89465[ebp], 1
	fst	QWORD PTR _scale$[ebp]
	jmp	SHORT $LN25@sobolev
$LN205@sobolev:
	fstp	ST(1)
$LN25@sobolev:

; 488  :      { FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	$LN203@sobolev
	mov	edi, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
$LN22@sobolev:
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	esi, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv1206[ebp], eax
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN21@sobolev

; 489  :        { REAL *coord;
; 490  :          vc = get_vertex_vhead(v_id);

	mov	edx, DWORD PTR _vhead_attr
	imul	edx, 240				; 000000f0H
	add	edx, edi
	mov	eax, DWORD PTR [edx+ebx+64]
	mov	edx, DWORD PTR [esi+eax]
	shl	edx, 5
	add	edx, DWORD PTR _vhead

; 491  :          if ( vc->freedom == 0 ) continue;

	cmp	DWORD PTR [edx+8], ecx
	je	SHORT $LN21@sobolev

; 492  :          coord = get_coord(v_id);

	mov	ecx, DWORD PTR [edi+ebx+64]

; 493  :          for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	add	ecx, esi
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN21@sobolev
	mov	esi, DWORD PTR _rs$[ebp]
$LN16@sobolev:

; 494  :              coord[j] = coord[j] - scale*rs[vc->rownum+j];

	mov	edi, DWORD PTR [edx+12]
	add	edi, eax
	fld	QWORD PTR [esi+edi*8]
	inc	eax
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [ecx+eax*8-8]
	fstp	QWORD PTR [ecx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN16@sobolev

; 493  :          for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
$LN21@sobolev:

; 488  :      { FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR tv1206[ebp]
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LN22@sobolev
$LN203@sobolev:

; 495  :        }
; 496  :        global_timestamp++;

	inc	DWORD PTR _global_timestamp
	fstp	ST(0)

; 497  :        calc_energy();  /* energy after motion */

	call	_calc_energy

; 498  :        if ( hess_debug || itdebug )

	cmp	DWORD PTR _hess_debug, 0
	jne	SHORT $LN12@sobolev
	cmp	DWORD PTR _itdebug, 0
	je	SHORT $LN13@sobolev
$LN12@sobolev:

; 499  : #ifdef FLOAT128
; 500  :           printf("scale %f energy %*.*Qf\n",(DOUBLE)scale,DWIDTH,DPREC,web.total_energy);
; 501  : #elif defined(LONGDOUBLE)
; 502  :           printf("scale %f energy %*.*Lf\n",(DOUBLE)scale,DWIDTH,DPREC,web.total_energy);
; 503  : #else
; 504  :           printf("scale %f energy %20.15f\n",(DOUBLE)scale,web.total_energy);

	fld	QWORD PTR _web+1240
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _scale$[ebp]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BJ@DPGPLKJJ@scale?5?$CFf?5energy?5?$CF20?415f?6?$AA@
	call	_printf
	add	esp, 20					; 00000014H
$LN13@sobolev:

; 505  : #endif 
; 506  :          energies[k] = web.total_energy;

	fld	QWORD PTR _web+1240
	mov	esi, DWORD PTR _k$89465[ebp]

; 507  :         restore_coords(&saved,SAVE_IN_ATTR);

	push	1
	fstp	QWORD PTR _energies$89463[ebp+esi*8]
	push	OFFSET _saved
	call	_restore_coords
	fld	QWORD PTR _scale$[ebp]
	fld1
	inc	esi
	fadd	ST(1), ST(0)
	add	esp, 8
	fxch	ST(1)
	mov	DWORD PTR _k$89465[ebp], esi
	fst	QWORD PTR _scale$[ebp]
	cmp	esi, 3
	jl	$LN205@sobolev

; 508  :      }
; 509  :      denom = energies[0] - 2*energies[1] + energies[2];

	fstp	ST(0)
	fld	QWORD PTR _energies$89463[ebp+8]
	fld	ST(0)
	fadd	ST(0), ST(1)
	fld	QWORD PTR _energies$89463[ebp]
	fld	ST(0)
	fsubrp	ST(2), ST(0)
	fld	QWORD PTR _energies$89463[ebp+16]
	fadd	ST(2), ST(0)

; 510  :      if ( denom <= 0.0 ) 

	fldz
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN208@sobolev
	fstp	ST(2)
	fstp	ST(2)
	fstp	ST(1)
	fstp	ST(0)

; 511  :         best_scale = 1.0;  /* energy not convex */

	jmp	SHORT $LN210@sobolev
$LN208@sobolev:

; 510  :      if ( denom <= 0.0 ) 

	fstp	ST(4)

; 512  :      else best_scale = 0.5*(3*energies[0]-4*energies[1]+energies[2])/denom;

	fmul	QWORD PTR __real@4008000000000000
	fxch	ST(2)
	fmul	QWORD PTR __real@4010000000000000
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3fe0000000000000
	fdivrp	ST(1), ST(0)
$LN210@sobolev:

; 513  :   }
; 514  :   scale = best_scale;
; 515  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	fst	QWORD PTR _best_scale$[ebp]
	test	eax, 268435456				; 10000000H
	je	$LN187@sobolev
	mov	edi, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
$LN9@sobolev:
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	esi, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv1206[ebp], eax
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN8@sobolev

; 516  :   { REAL *coord;
; 517  :     vc = get_vertex_vhead(v_id);

	mov	edx, DWORD PTR _vhead_attr
	imul	edx, 240				; 000000f0H
	add	edx, edi
	mov	eax, DWORD PTR [edx+ebx+64]
	mov	edx, DWORD PTR [esi+eax]
	shl	edx, 5
	add	edx, DWORD PTR _vhead

; 518  :     if ( vc->freedom == 0 ) continue;

	cmp	DWORD PTR [edx+8], ecx
	je	SHORT $LN8@sobolev

; 519  :     coord = get_coord(v_id);

	mov	ecx, DWORD PTR [edi+ebx+64]

; 520  :     for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	add	ecx, esi
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN8@sobolev
	mov	esi, DWORD PTR _rs$[ebp]
$LN3@sobolev:

; 521  :       coord[j] = coord[j] - scale*rs[vc->rownum+j];

	mov	edi, DWORD PTR [edx+12]
	add	edi, eax
	fld	QWORD PTR [esi+edi*8]
	inc	eax
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [ecx+eax*8-8]
	fstp	QWORD PTR [ecx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@sobolev

; 520  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
$LN8@sobolev:

; 513  :   }
; 514  :   scale = best_scale;
; 515  :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR tv1206[ebp]
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LN9@sobolev
$LN187@sobolev:

; 522  :   }
; 523  : 
; 524  :   temp_free((char*)rs);

	mov	ecx, DWORD PTR _rs$[ebp]
	fstp	ST(0)
	push	ecx
	call	_temp_free

; 525  :   temp_free((char*)rs_save);

	mov	edx, DWORD PTR _rs_save$[ebp]
	push	edx
	call	_temp_free

; 526  :   temp_free((char*)rstmp);

	mov	eax, DWORD PTR _rstmp$[ebp]
	push	eax
	call	_temp_free

; 527  :   free_system(&S);

	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_free_system

; 528  :   hessian_exit(NULL);

	push	0
	call	_hessian_exit

; 529  : 
; 530  :   return best_scale;

	fld	QWORD PTR _best_scale$[ebp]

; 531  : } // end sobolev()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_sobolev ENDP
_TEXT	ENDS
PUBLIC	_householder
; Function compile flags: /Ogtp
;	COMDAT _householder
_TEXT	SEGMENT
_x$ = 8							; size = 4
_v$ = 12						; size = 4
_n$ = 16						; size = 4
_householder PROC					; COMDAT

; 553  : { REAL maxx;

	push	ebp
	mov	ebp, esp

; 554  :   REAL a = 0.0,b;

	fldz

; 555  :   int i;
; 556  : 
; 557  :   for ( maxx = 0.0, i = 0 ; i < n ; i++ )

	mov	edx, DWORD PTR _x$[ebp]
	push	ebx
	fld	ST(0)
	push	esi
	push	edi
	mov	edi, DWORD PTR _n$[ebp]
	xor	esi, esi
	cmp	edi, 4
	jl	SHORT $LN26@householde

; 554  :   REAL a = 0.0,b;

	lea	ecx, DWORD PTR [edi-4]
	shr	ecx, 2
	inc	ecx
	lea	ebx, DWORD PTR [edx+16]
	lea	esi, DWORD PTR [ecx*4]

; 555  :   int i;
; 556  : 
; 557  :   for ( maxx = 0.0, i = 0 ; i < n ; i++ )

$LN22@householde:

; 558  :      if ( fabs(x[i]) > maxx ) maxx = fabs(x[i]);

	fld	QWORD PTR [ebx-16]
	fabs
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN32@householde
	fstp	ST(2)
	jmp	SHORT $LN18@householde
$LN32@householde:
	fstp	ST(0)
$LN18@householde:
	fld	QWORD PTR [ebx-8]
	fabs
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN35@householde
	fstp	ST(2)
	jmp	SHORT $LN19@householde
$LN35@householde:
	fstp	ST(0)
$LN19@householde:
	fld	QWORD PTR [ebx]
	fabs
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN38@householde
	fstp	ST(2)
	jmp	SHORT $LN20@householde
$LN38@householde:
	fstp	ST(0)
$LN20@householde:
	fld	QWORD PTR [ebx+8]
	fabs
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN41@householde
	fstp	ST(2)
	jmp	SHORT $LN21@householde
$LN41@householde:
	fstp	ST(0)
$LN21@householde:

; 554  :   REAL a = 0.0,b;

	add	ebx, 32					; 00000020H
	dec	ecx
	jne	SHORT $LN22@householde
$LN26@householde:

; 555  :   int i;
; 556  : 
; 557  :   for ( maxx = 0.0, i = 0 ; i < n ; i++ )

	cmp	esi, edi
	jge	SHORT $LN16@householde
$LC7@householde:

; 558  :      if ( fabs(x[i]) > maxx ) maxx = fabs(x[i]);

	fld	QWORD PTR [edx+esi*8]
	fabs
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN46@householde
	fstp	ST(2)
	jmp	SHORT $LN6@householde
$LN46@householde:
	fstp	ST(0)
$LN6@householde:
	inc	esi

; 555  :   int i;
; 556  : 
; 557  :   for ( maxx = 0.0, i = 0 ; i < n ; i++ )

	cmp	esi, edi
	jl	SHORT $LC7@householde
$LN16@householde:

; 559  :   for ( i = 0 ; i < n ; i++ )

	mov	esi, DWORD PTR _v$[ebp]
	xor	ebx, ebx
	cmp	edi, 4
	jl	SHORT $LC24@householde
	lea	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [esi+8]

; 561  :     a += v[i]*v[i];

	sub	esi, edx
	lea	edx, DWORD PTR [edi-4]
	shr	edx, 2
	inc	edx
	lea	ebx, DWORD PTR [edx*4]
$LN25@householde:
	fld	QWORD PTR [eax-16]
	add	ecx, 32					; 00000020H
	fdiv	ST(0), ST(2)
	add	eax, 32					; 00000020H
	dec	edx
	fstp	QWORD PTR [ecx-40]
	fld	QWORD PTR [eax-40]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [ecx-32]
	fld	QWORD PTR [eax-32]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [eax+esi-32]
	fld	QWORD PTR [eax-24]
	fdiv	ST(0), ST(2)
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [ecx-16]
	fld	QWORD PTR [ecx-40]
	fld	QWORD PTR [ecx-32]
	fld	QWORD PTR [eax+esi-32]
	fld	ST(2)
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	faddp	ST(4), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(3), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LN25@householde

; 559  :   for ( i = 0 ; i < n ; i++ )

	mov	esi, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
$LC24@householde:
	cmp	ebx, edi
	jge	SHORT $LN58@householde
	mov	ecx, edx
	sub	ecx, esi
	lea	eax, DWORD PTR [esi+ebx*8]
	sub	edi, ebx
$LC3@householde:

; 560  :   { v[i] = x[i]/maxx;

	fld	QWORD PTR [ecx+eax]
	add	eax, 8
	dec	edi
	fdiv	ST(0), ST(2)
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [eax-8]

; 561  :     a += v[i]*v[i];

	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LC3@householde
$LN58@householde:

; 559  :   for ( i = 0 ; i < n ; i++ )

	fstp	ST(1)

; 562  :   }
; 563  :   a = sqrt(a);

	call	__CIsqrt

; 564  :   b = 1/a/(a+fabs(v[0]));

	fld1
	fdiv	ST(0), ST(1)
	fld	QWORD PTR [esi]
	fabs
	fadd	ST(0), ST(2)
	fdivp	ST(1), ST(0)

; 565  :   v[0] += v[0]<0.0 ? -a : a;

	fldz
	fcomp	QWORD PTR [esi]
	fnstsw	ax
	fxch	ST(1)
	test	ah, 65					; 00000041H
	jne	SHORT $LN11@householde
	fchs
$LN11@householde:
	fadd	QWORD PTR [esi]
	pop	edi
	fstp	QWORD PTR [esi]
	pop	esi
	pop	ebx

; 566  :   return b;
; 567  : }  // end householder()

	pop	ebp
	ret	0
_householder ENDP
_TEXT	ENDS
PUBLIC	_sturm
; Function compile flags: /Ogtp
;	COMDAT _sturm
_TEXT	SEGMENT
_n$ = 8							; size = 4
_alpha$ = 12						; size = 4
_beta$ = 16						; size = 4
_x$ = 20						; size = 8
_changes$ = 24						; size = 4
_sturm	PROC						; COMDAT

; 583  : { int i;

	push	ebp
	mov	ebp, esp

; 584  :   int changes;
; 585  :   REAL p,pp,t;
; 586  : 
; 587  :   /* Sturm sequence for number of eigenvalues below x */ 
; 588  :   pp = 1.0;
; 589  :   p = alpha[0] - x;

	mov	ecx, DWORD PTR _alpha$[ebp]
	fld1
	fld	QWORD PTR [ecx]
	fld	QWORD PTR _x$[ebp]
	fsub	ST(1), ST(0)

; 590  :   changes = p < 0.0 ? 1 : 0;

	fldz
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN7@sturm
	mov	edx, 1
	mov	DWORD PTR _changes$[ebp], edx
	jmp	SHORT $LN8@sturm
$LN7@sturm:
	mov	DWORD PTR _changes$[ebp], 0
	mov	edx, DWORD PTR _changes$[ebp]
$LN8@sturm:

; 591  :   for ( i = 1 ; i < n ; i++ )

	mov	eax, DWORD PTR _n$[ebp]
	push	edi
	mov	edi, 1
	cmp	eax, edi
	jle	$LN47@sturm
	push	esi
	lea	esi, DWORD PTR [eax-1]
	cmp	esi, 4
	jl	$LC12@sturm

; 594  :      pp = p; p = t;

	push	ebx
	mov	ebx, DWORD PTR _beta$[ebp]
	lea	edx, DWORD PTR [ecx+24]
	lea	esi, DWORD PTR [ebx+16]
	sub	ebx, ecx
	lea	ecx, DWORD PTR [eax-5]
	shr	ecx, 2
	inc	ecx
	lea	edi, DWORD PTR [ecx*4+1]
$LN17@sturm:

; 592  :   { t = (alpha[i] - x)*p - beta[i-1]*beta[i-1]*pp;

	fld	QWORD PTR [esi-16]
	fld	QWORD PTR [edx-16]
	fsub	ST(0), ST(3)
	fmul	ST(0), ST(4)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fmulp	ST(5), ST(0)
	fsubrp	ST(4), ST(0)

; 593  :      if ( t*p < 0.0 ) changes++;

	fld	ST(3)
	fmul	ST(0), ST(3)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN13@sturm
	inc	DWORD PTR _changes$[ebp]
$LN13@sturm:

; 594  :      pp = p; p = t;

	fld	ST(3)
	fld	QWORD PTR [esi-8]
	fld	QWORD PTR [edx-8]
	fsub	ST(0), ST(4)
	fmulp	ST(6), ST(0)
	fmul	ST(0), ST(0)
	fmulp	ST(4), ST(0)
	fxch	ST(4)
	fsubrp	ST(3), ST(0)
	fld	ST(2)
	fmul	ST(0), ST(4)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN14@sturm

; 593  :      if ( t*p < 0.0 ) changes++;

	inc	DWORD PTR _changes$[ebp]
$LN14@sturm:

; 594  :      pp = p; p = t;

	fld	ST(2)
	fld	QWORD PTR [esi]
	fld	QWORD PTR [edx]
	fsub	ST(0), ST(4)
	fmulp	ST(5), ST(0)
	fmul	ST(0), ST(0)
	fmulp	ST(5), ST(0)
	fxch	ST(3)
	fsubrp	ST(4), ST(0)
	fld	ST(3)
	fmul	ST(0), ST(3)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN15@sturm

; 593  :      if ( t*p < 0.0 ) changes++;

	inc	DWORD PTR _changes$[ebp]
$LN15@sturm:

; 594  :      pp = p; p = t;

	fld	ST(3)
	fld	QWORD PTR [ebx+edx]
	fld	QWORD PTR [edx+8]
	fsub	ST(0), ST(4)
	fmulp	ST(6), ST(0)
	fmul	ST(0), ST(0)
	fmulp	ST(4), ST(0)
	fxch	ST(4)
	fsubrp	ST(3), ST(0)
	fld	ST(2)
	fmul	ST(0), ST(4)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN16@sturm

; 593  :      if ( t*p < 0.0 ) changes++;

	inc	DWORD PTR _changes$[ebp]
$LN16@sturm:

; 594  :      pp = p; p = t;

	add	esi, 32					; 00000020H
	add	edx, 32					; 00000020H
	dec	ecx
	jne	$LN17@sturm
	mov	eax, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _changes$[ebp]
	pop	ebx
$LC12@sturm:

; 591  :   for ( i = 1 ; i < n ; i++ )

	pop	esi
	cmp	edi, eax
	jge	SHORT $LN47@sturm
	mov	eax, DWORD PTR _beta$[ebp]
	lea	ecx, DWORD PTR [eax+edi*8-8]
	jmp	SHORT $LC4@sturm
$LN55@sturm:
	fxch	ST(2)
	fxch	ST(3)
	fxch	ST(2)
$LC4@sturm:

; 592  :   { t = (alpha[i] - x)*p - beta[i-1]*beta[i-1]*pp;

	mov	eax, DWORD PTR _alpha$[ebp]
	fld	QWORD PTR [ecx]
	fld	QWORD PTR [eax+edi*8]
	fsub	ST(0), ST(3)
	fmul	ST(0), ST(4)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fmulp	ST(5), ST(0)
	fsubrp	ST(4), ST(0)

; 593  :      if ( t*p < 0.0 ) changes++;

	fld	ST(3)
	fmul	ST(0), ST(3)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN20@sturm
	inc	edx
$LN20@sturm:
	inc	edi

; 591  :   for ( i = 1 ; i < n ; i++ )

	add	ecx, 8
	cmp	edi, DWORD PTR _n$[ebp]
	jl	SHORT $LN55@sturm
	fstp	ST(3)

; 595  :   }
; 596  :   return changes;

	mov	eax, edx
	fstp	ST(0)
	pop	edi
	fstp	ST(1)
	fstp	ST(0)

; 597  : } // end sturm()

	pop	ebp
	ret	0
$LN47@sturm:

; 591  :   for ( i = 1 ; i < n ; i++ )

	fstp	ST(2)

; 595  :   }
; 596  :   return changes;

	mov	eax, edx
	fstp	ST(0)
	pop	edi
	fstp	ST(0)
	fstp	ST(0)

; 597  : } // end sturm()

	pop	ebp
	ret	0
_sturm	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@CPOAFIB@?$CFd?5at?5?$CF2?415g?6?$AA@	; `string'
PUBLIC	_ev_bisect
EXTRN	_outstring:PROC
EXTRN	_msg:DWORD
EXTRN	_machine_eps:QWORD
;	COMDAT ??_C@_0O@CPOAFIB@?$CFd?5at?5?$CF2?415g?6?$AA@
CONST	SEGMENT
??_C@_0O@CPOAFIB@?$CFd?5at?5?$CF2?415g?6?$AA@ DB '%d at %2.15g', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _ev_bisect
_TEXT	SEGMENT
_lowev$ = -16						; size = 8
_mid$ = -8						; size = 8
_left$ = 8						; size = 8
_right$ = 16						; size = 8
_cleft$ = 24						; size = 4
_cright$ = 28						; size = 4
_n$ = 32						; size = 4
_alpha$ = 36						; size = 4
_beta$ = 40						; size = 4
_ev_bisect PROC						; COMDAT

; 616  : { int cmid;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 617  :   REAL mid;
; 618  :   REAL lowev = 0.0;

	fldz
	fstp	QWORD PTR _lowev$[ebp]

; 619  : 
; 620  :   mid = (left+right)/2;

	fld	QWORD PTR _left$[ebp]
	fld	ST(0)
	fld	QWORD PTR _right$[ebp]
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR _mid$[ebp]

; 621  :   if ( right-left < 3*machine_eps )

	fxch	ST(1)
	fsubrp	ST(2), ST(0)
	fld	QWORD PTR _machine_eps
	fmul	QWORD PTR __real@4008000000000000
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@ev_bisect

; 622  :   { 
; 623  : #ifdef FLOAT128
; 624  :      sprintf(msg,"%d at %2.*Qg\n",DPREC,cright-cleft,mid);
; 625  : #elif defined(LONGDOUBLE)
; 626  :      sprintf(msg,"%d at %2.*Lg\n",DPREC,cright-cleft,mid);
; 627  : #else
; 628  :      sprintf(msg,"%d at %2.15g\n",cright-cleft,mid);

	mov	eax, DWORD PTR _cright$[ebp]
	sub	eax, DWORD PTR _cleft$[ebp]
	mov	ecx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	push	OFFSET ??_C@_0O@CPOAFIB@?$CFd?5at?5?$CF2?415g?6?$AA@
	push	ecx
	call	_sprintf

; 629  : #endif 
; 630  :      outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 631  :      return mid;

	fld	QWORD PTR _mid$[ebp]
	add	esp, 24					; 00000018H

; 638  :   return lowev; 
; 639  : } // end ev_bisect()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@ev_bisect:

; 632  :   }
; 633  :   cmid = sturm(n,alpha,beta,mid);

	mov	eax, DWORD PTR _n$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _alpha$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _beta$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	push	ebx
	push	eax
	call	_sturm
	mov	esi, eax

; 634  :   if ( cmid < cright )

	mov	eax, DWORD PTR _cright$[ebp]
	add	esp, 20					; 00000014H
	cmp	esi, eax
	jge	SHORT $LN6@ev_bisect

; 635  :      lowev = ev_bisect(mid,right,cmid,cright,n,alpha,beta);

	mov	ecx, DWORD PTR _n$[ebp]
	fld	QWORD PTR _right$[ebp]
	push	edi
	push	ebx
	push	ecx
	push	eax
	push	esi
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _mid$[ebp]
	fstp	QWORD PTR [esp]
	call	_ev_bisect
	add	esp, 36					; 00000024H
	jmp	SHORT $LN2@ev_bisect
$LN6@ev_bisect:
	fld	QWORD PTR _lowev$[ebp]
$LN2@ev_bisect:

; 636  :   if ( cleft < cmid )

	mov	eax, DWORD PTR _cleft$[ebp]
	cmp	eax, esi
	jge	SHORT $LN1@ev_bisect

; 637  :      lowev = ev_bisect(left,mid,cleft,cmid,n,alpha,beta);

	mov	edx, DWORD PTR _n$[ebp]
	fstp	ST(0)
	fld	QWORD PTR _mid$[ebp]
	push	edi
	push	ebx
	push	edx
	push	esi
	push	eax
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _left$[ebp]
	fstp	QWORD PTR [esp]
	call	_ev_bisect
	add	esp, 36					; 00000024H
$LN1@ev_bisect:
	pop	edi
	pop	esi
	pop	ebx

; 638  :   return lowev; 
; 639  : } // end ev_bisect()

	mov	esp, ebp
	pop	ebp
	ret	0
_ev_bisect ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@FBOLJFJE@?$CF4d?4?5?5rayleigh?5?$CF2?415g?6?$AA@ ; `string'
PUBLIC	__real@3ff3333333333333
PUBLIC	__real@3fa47ae147ae147b
PUBLIC	__real@4039000000000000
PUBLIC	??_C@_0CB@JCNLBACD@?$CF4d?4?5?5rayleigh?5?$CF2?415g?5?5maxev?5?$CFg?6@ ; `string'
PUBLIC	__real@3fefae147ae147ae
PUBLIC	__real@3e45798ee2308c3a
PUBLIC	__real@c000000000000000
PUBLIC	__real@4000000000000000
PUBLIC	??_C@_0BB@PABLIDCN@Max?5iterations?3?5?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_chebychev_ev
EXTRN	_last_eigenvalue:QWORD
EXTRN	_sp_mul_func:DWORD
EXTRN	_drand48:PROC
EXTRN	_atoi:PROC
EXTRN	_prompt:PROC
;	COMDAT ??_C@_0BH@FBOLJFJE@?$CF4d?4?5?5rayleigh?5?$CF2?415g?6?$AA@
CONST	SEGMENT
??_C@_0BH@FBOLJFJE@?$CF4d?4?5?5rayleigh?5?$CF2?415g?6?$AA@ DB '%4d.  rayl'
	DB	'eigh %2.15g', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT __real@3ff3333333333333
CONST	SEGMENT
__real@3ff3333333333333 DQ 03ff3333333333333r	; 1.2
CONST	ENDS
;	COMDAT __real@3fa47ae147ae147b
CONST	SEGMENT
__real@3fa47ae147ae147b DQ 03fa47ae147ae147br	; 0.04
CONST	ENDS
;	COMDAT __real@4039000000000000
CONST	SEGMENT
__real@4039000000000000 DQ 04039000000000000r	; 25
CONST	ENDS
;	COMDAT ??_C@_0CB@JCNLBACD@?$CF4d?4?5?5rayleigh?5?$CF2?415g?5?5maxev?5?$CFg?6@
CONST	SEGMENT
??_C@_0CB@JCNLBACD@?$CF4d?4?5?5rayleigh?5?$CF2?415g?5?5maxev?5?$CFg?6@ DB '%'
	DB	'4d.  rayleigh %2.15g  maxev %g', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@3fefae147ae147ae
CONST	SEGMENT
__real@3fefae147ae147ae DQ 03fefae147ae147aer	; 0.99
CONST	ENDS
;	COMDAT __real@3e45798ee2308c3a
CONST	SEGMENT
__real@3e45798ee2308c3a DQ 03e45798ee2308c3ar	; 1e-008
CONST	ENDS
;	COMDAT __real@c000000000000000
CONST	SEGMENT
__real@c000000000000000 DQ 0c000000000000000r	; -2
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT ??_C@_0BB@PABLIDCN@Max?5iterations?3?5?$AA@
CONST	SEGMENT
??_C@_0BB@PABLIDCN@Max?5iterations?3?5?$AA@ DB 'Max iterations: ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _chebychev_ev
_TEXT	SEGMENT
_norm$89625 = -104					; size = 8
_minev$ = -96						; size = 8
_v$ = -88						; size = 4
_nextev$ = -84						; size = 8
_maxev$ = -76						; size = 8
_coeffc$ = -68						; size = 8
_coeffA$ = -60						; size = 8
_X$ = -52						; size = 4
_maxk$ = -48						; size = 4
_rayleigh$ = -44					; size = 8
_tmp$89624 = -40					; size = 4
_k$ = -36						; size = 4
_w$ = -32						; size = 4
_r$ = -28						; size = 4
_response$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_chebychev_ev PROC					; COMDAT

; 651  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 652  :   REAL *v,*w;    /* working vectors  */
; 653  :   REAL *r;
; 654  :   REAL t;      /* temp */
; 655  :   int i,k;
; 656  :   REAL maxev; /* eigenvalue upper bound */
; 657  :   REAL minev; /* eigenvalue lower bound */
; 658  :   REAL nextev;
; 659  :   REAL coeffA,coeffc;
; 660  :   REAL rayleigh=1.0;  /* Rayleigh quotient */

	fld1
	push	ebx
	push	esi
	fstp	QWORD PTR _rayleigh$[ebp]
	mov	esi, DWORD PTR _S$[ebp]

; 661  :   int maxk;
; 662  :   char response[20];
; 663  :   REAL *X;
; 664  : 
; 665  :   v = (REAL *)temp_calloc(S->N+S->concount+1,sizeof(REAL));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+144]
	push	edi
	push	665					; 00000299H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	edx, DWORD PTR [eax+ecx+1]
	push	8
	push	edx
	call	_kb_temp_calloc

; 666  :   w = (REAL *)temp_calloc(S->N+S->concount+1,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+144]
	push	666					; 0000029aH
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+4]
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	edx, DWORD PTR [eax+ecx+1]
	push	8
	push	edx
	mov	DWORD PTR _v$[ebp], ebx
	call	_kb_temp_calloc

; 667  :   r = (REAL *)temp_calloc(S->N+S->concount+1,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+144]
	push	667					; 0000029bH
	mov	DWORD PTR _w$[ebp], eax
	mov	eax, DWORD PTR [esi+4]
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	edx, DWORD PTR [eax+ecx+1]
	push	8
	push	edx
	call	_kb_temp_calloc

; 668  :   X = (REAL *)temp_calloc(S->N+S->concount+1,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+144]
	push	668					; 0000029cH
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, DWORD PTR [esi+4]
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	edx, DWORD PTR [eax+ecx+1]
	push	8
	push	edx
	call	_kb_temp_calloc

; 669  : 
; 670  :   /* first, need to find upper bound on eigenvalues */
; 671  :   maxev = 1.0;

	fld1
	fstp	QWORD PTR _maxev$[ebp]
	add	esp, 64					; 00000040H

; 672  :   nextev = 0.0;

	fldz
	mov	DWORD PTR _X$[ebp], eax
	fst	QWORD PTR _nextev$[ebp]

; 673  :   minev = 0.0;

	fstp	QWORD PTR _minev$[ebp]
	jmp	SHORT $LN30@chebychev_
$LL89@chebychev_:
	fstp	ST(0)
$LN30@chebychev_:

; 674  :   do
; 675  :   {
; 676  :      prompt("Max iterations: ",response,sizeof(response)); 

	push	20					; 00000014H
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@PABLIDCN@Max?5iterations?3?5?$AA@
	call	_prompt

; 677  :      maxk = atoi(response);

	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	call	_atoi
	fld	QWORD PTR _nextev$[ebp]
	fld	QWORD PTR _minev$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _maxk$[ebp], eax
	jmp	SHORT $LN27@chebychev_
$LN86@chebychev_:

; 712  :      } while ( k < maxk );

	fstp	ST(2)
$LN27@chebychev_:

; 678  :      do
; 679  :      {
; 680  :        coeffA = 2/(maxev-nextev);

	fld	QWORD PTR _maxev$[ebp]
	fsub	ST(0), ST(2)
	fld	QWORD PTR __real@4000000000000000
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _coeffA$[ebp]

; 681  :        coeffc = -2*nextev/(maxev-nextev) - 1;

	fxch	ST(2)
	fmul	QWORD PTR __real@c000000000000000
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fsub	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR _coeffc$[ebp]

; 682  :        if ( minev >= 0.0 )

	fldz
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN54@chebychev_

; 683  :           for ( i = 0 ; i < S->N ; i++ ) w[i] = drand48() - .5;

	xor	edi, edi
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN54@chebychev_
	npad	7
$LL23@chebychev_:
	call	_drand48
	fsub	QWORD PTR __real@3fe0000000000000
	mov	edx, DWORD PTR _w$[ebp]
	inc	edi
	fstp	QWORD PTR [edx+edi*8-8]
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL23@chebychev_
$LN54@chebychev_:

; 684  :        (*sp_mul_func)(S,w,v);

	mov	edi, DWORD PTR _w$[ebp]
	push	ebx
	push	edi
	push	esi
	call	DWORD PTR _sp_mul_func

; 685  :        for ( i = 0 ; i < S->N ; i++ )

	fld	QWORD PTR _coeffA$[ebp]
	fld	QWORD PTR _coeffc$[ebp]
	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN18@chebychev_
	mov	edx, edi
	mov	edi, DWORD PTR _r$[ebp]
	sub	edx, ebx
	mov	eax, ebx
	sub	edi, ebx
$LN20@chebychev_:

; 686  :           r[i] = coeffA*v[i] + coeffc*w[i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edi+eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LN20@chebychev_
$LN18@chebychev_:

; 687  :        coeffA *= 2; coeffc *= 2;
; 688  :        for ( k = 0 ; k < maxk ; k++ )

	cmp	DWORD PTR _maxk$[ebp], 0
	fld	QWORD PTR __real@4000000000000000
	fmul	ST(2), ST(0)
	mov	DWORD PTR _k$[ebp], 0
	fxch	ST(2)
	fstp	QWORD PTR _coeffA$[ebp]
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR _coeffc$[ebp]
	jg	SHORT $LN53@chebychev_

; 699  :          { maxev = 1.2*rayleigh + .5; break; }

	fld	QWORD PTR _rayleigh$[ebp]
$LN15@chebychev_:

; 708  :          }
; 709  :        }
; 710  :        if ( rayleigh < minev-.00000001 ) 

	fld	QWORD PTR _minev$[ebp]
	fld	QWORD PTR __real@3e45798ee2308c3a
	fsubr	ST(0), ST(1)
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN52@chebychev_
	fstp	ST(0)

; 711  :        { minev = rayleigh; nextev = 0.99*rayleigh; }

	fld	ST(0)
	fst	QWORD PTR _minev$[ebp]
	fld	ST(1)
	fmul	QWORD PTR __real@3fefae147ae147ae
	fst	QWORD PTR _nextev$[ebp]
	jmp	$LN26@chebychev_
	npad	7
$LL78@chebychev_:

; 687  :        coeffA *= 2; coeffc *= 2;
; 688  :        for ( k = 0 ; k < maxk ; k++ )

	fstp	ST(0)
$LN53@chebychev_:

; 689  :        { REAL *tmp;
; 690  :          REAL norm;
; 691  :          tmp = r; r = w; w = tmp;

	mov	edi, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR _w$[ebp]

; 692  :          (*sp_mul_func)(S,w,v);

	push	ebx
	push	edi
	push	esi
	mov	DWORD PTR _tmp$89624[ebp], edi
	mov	DWORD PTR _r$[ebp], eax
	mov	DWORD PTR _w$[ebp], edi
	call	DWORD PTR _sp_mul_func

; 693  :          for ( i = 0 ; i < S->N ; i++ )

	xor	edx, edx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN12@chebychev_
	mov	eax, DWORD PTR _r$[ebp]
	fld	QWORD PTR _coeffA$[ebp]
	fld	QWORD PTR _coeffc$[ebp]
	sub	edi, ebx
	sub	ebx, eax
$LN14@chebychev_:

; 694  :            r[i] = coeffA*v[i] + coeffc*w[i] - r[i];

	lea	ecx, DWORD PTR [ebx+eax]
	fld	QWORD PTR [ecx+edi]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fld	ST(2)
	fmul	QWORD PTR [ecx]
	faddp	ST(1), ST(0)
	fsub	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LN14@chebychev_

; 693  :          for ( i = 0 ; i < S->N ; i++ )

	mov	ebx, DWORD PTR _v$[ebp]
	fstp	ST(1)
	mov	edi, DWORD PTR _tmp$89624[ebp]
	fstp	ST(0)
$LN12@chebychev_:

; 695  :          /* periodically check Rayleigh quotient to see if bound needs raising */
; 696  :          norm = dot(w,w,S->N);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	push	edi
	push	edi
	call	_dot
	fstp	QWORD PTR _norm$89625[ebp]

; 697  :          rayleigh = dot(w,v,S->N)/norm;

	mov	edx, DWORD PTR [esi+4]
	push	edx
	push	ebx
	push	edi
	call	_dot
	fld	QWORD PTR _norm$89625[ebp]
	fdiv	ST(1), ST(0)
	add	esp, 24					; 00000018H
	fxch	ST(1)
	fst	QWORD PTR _rayleigh$[ebp]

; 698  :          if ( rayleigh > maxev ) 

	fld	QWORD PTR _maxev$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	$LN66@chebychev_

; 700  :          /* just some checking */
; 701  :          if ( (k % 50)==0 )

	mov	ecx, DWORD PTR _k$[ebp]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	imul	eax, 50					; 00000032H
	mov	edx, ecx
	sub	edx, eax
	jne	SHORT $LN69@chebychev_

; 702  :            printf("%4d.  rayleigh %2.15g  maxev %g\n",k,(DOUBLE)rayleigh,(DOUBLE)maxev);

	fstp	ST(2)
	sub	esp, 16					; 00000010H
	fxch	ST(1)
	fstp	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	ecx
	push	OFFSET ??_C@_0CB@JCNLBACD@?$CF4d?4?5?5rayleigh?5?$CF2?415g?5?5maxev?5?$CFg?6@
	call	_printf
	fld	QWORD PTR _rayleigh$[ebp]
	fld	QWORD PTR _norm$89625[ebp]
	add	esp, 24					; 00000018H
	fxch	ST(1)
$LN10@chebychev_:

; 703  :          /* renormalize occasionally */
; 704  :          if ( (norm > 25.0) || (norm < .04) )

	fld	QWORD PTR __real@4039000000000000
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN75@chebychev_
	fld	QWORD PTR __real@3fa47ae147ae147b
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN76@chebychev_
$LN75@chebychev_:
	fstp	ST(0)

; 705  :          { t = 1/sqrt(norm);

	call	__CIsqrt
	fld1

; 706  :            for ( i = 0 ; i < S->N ; i++ )

	xor	edx, edx
	fdivrp	ST(1), ST(0)
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN97@chebychev_
	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, edi
	sub	ecx, eax
$LN7@chebychev_:

; 707  :               { w[i] *= t; r[i] *= t; }

	fld	QWORD PTR [ecx+eax]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [ecx+eax-8]
	fld	ST(0)
	fmul	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LN7@chebychev_
$LN97@chebychev_:

; 706  :            for ( i = 0 ; i < S->N ; i++ )

	fstp	ST(0)
	fld	QWORD PTR _rayleigh$[ebp]
	jmp	SHORT $LN16@chebychev_
$LN69@chebychev_:

; 702  :            printf("%4d.  rayleigh %2.15g  maxev %g\n",k,(DOUBLE)rayleigh,(DOUBLE)maxev);

	fstp	ST(0)

; 700  :          /* just some checking */
; 701  :          if ( (k % 50)==0 )

	jmp	SHORT $LN10@chebychev_
$LN76@chebychev_:

; 706  :            for ( i = 0 ; i < S->N ; i++ )

	fstp	ST(1)
$LN16@chebychev_:

; 687  :        coeffA *= 2; coeffc *= 2;
; 688  :        for ( k = 0 ; k < maxk ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _maxk$[ebp]
	jl	$LL78@chebychev_

; 698  :          if ( rayleigh > maxev ) 

	jmp	$LN15@chebychev_
$LN66@chebychev_:
	fstp	ST(2)
	fstp	ST(1)

; 699  :          { maxev = 1.2*rayleigh + .5; break; }

	fld	QWORD PTR __real@3ff3333333333333
	fmul	ST(0), ST(1)
	fadd	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR _maxev$[ebp]
	jmp	$LN15@chebychev_
$LN52@chebychev_:

; 711  :        { minev = rayleigh; nextev = 0.99*rayleigh; }

	fld	QWORD PTR _nextev$[ebp]
$LN26@chebychev_:

; 712  :      } while ( k < maxk );

	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _maxk$[ebp]
	jl	$LN86@chebychev_
	fstp	ST(0)
	fstp	ST(0)

; 713  :   } while ( k > 0 );

	test	eax, eax
	jg	$LL89@chebychev_

; 714  : 
; 715  :   printf("%4d.  rayleigh %2.15g\n",k,(DOUBLE)rayleigh);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	push	OFFSET ??_C@_0BH@FBOLJFJE@?$CF4d?4?5?5rayleigh?5?$CF2?415g?6?$AA@
	call	_printf

; 716  :   last_eigenvalue = rayleigh;

	fld	QWORD PTR _rayleigh$[ebp]

; 717  : 
; 718  :   /* else try again with increased maxev */
; 719  : 
; 720  :   /* now have got eigenvector for neg eigenvalue */
; 721  :   t = 1/sqrt(dot(r,r,S->N));

	mov	edi, DWORD PTR _r$[ebp]
	fstp	QWORD PTR _last_eigenvalue
	mov	eax, DWORD PTR [esi+4]
	push	eax
	push	edi
	push	edi
	call	_dot
	add	esp, 28					; 0000001cH
	call	__CIsqrt
	fld1

; 722  :   for ( i = 0 ; i < S->N ; i++ ) X[i] = t*r[i];    /* normalized */

	xor	ecx, ecx
	fdivrp	ST(1), ST(0)
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN95@chebychev_
	mov	eax, DWORD PTR _X$[ebp]
	mov	edx, edi
	sub	edx, eax
$LN3@chebychev_:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LN3@chebychev_
$LN95@chebychev_:

; 723  : 
; 724  :   temp_free((char*)w);

	mov	ecx, DWORD PTR _w$[ebp]
	fstp	ST(0)
	push	ecx
	call	_temp_free

; 725  :   temp_free((char*)v);

	push	ebx
	call	_temp_free

; 726  :   temp_free((char*)r);

	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	call	_temp_free

; 727  :   temp_free((char*)X);

	mov	eax, DWORD PTR _X$[ebp]
	push	eax
	call	_temp_free

; 728  : } /* end chebychev_ev() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_chebychev_ev ENDP
_TEXT	ENDS
PUBLIC	__real@3feccccccccccccd
PUBLIC	_chebychev_hess
;	COMDAT __real@3feccccccccccccd
CONST	SEGMENT
__real@3feccccccccccccd DQ 03feccccccccccccdr	; 0.9
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _chebychev_hess
_TEXT	SEGMENT
_nextev$ = -72						; size = 8
_minev$ = -64						; size = 8
_norm$89687 = -56					; size = 8
_maxev$ = -48						; size = 8
_coeffc$ = -40						; size = 8
_coeffA$ = -32						; size = 8
_rayleigh$ = -24					; size = 8
_tmp$89686 = -20					; size = 4
_X$ = -16						; size = 4
_r$ = -12						; size = 4
_v$ = -8						; size = 4
_w$ = -4						; size = 4
tv468 = 8						; size = 4
_k$ = 8							; size = 4
_S$ = 8							; size = 4
_chebychev_hess PROC					; COMDAT

; 741  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi

; 742  :   REAL *v,*w;    /* working vectors  */
; 743  :   REAL *r;
; 744  :   REAL t;      /* temp */
; 745  :   int i,k;
; 746  :   REAL maxev; /* eigenvalue upper bound */
; 747  :   REAL minev; /* eigenvalue lower bound */
; 748  :   REAL nextev;
; 749  :   REAL coeffA,coeffc;
; 750  :   REAL rayleigh=0.0;  /* Rayleigh quotient */
; 751  :   REAL *X;
; 752  : 
; 753  :   v = (REAL *)temp_calloc(S->N+1,sizeof(REAL));

	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+4]
	push	edi
	push	753					; 000002f1H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	inc	eax
	push	8
	push	eax
	call	_kb_temp_calloc

; 754  :   w = (REAL *)temp_calloc(S->N+1,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+4]
	push	754					; 000002f2H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	inc	ecx
	push	8
	push	ecx
	mov	DWORD PTR _v$[ebp], eax
	call	_kb_temp_calloc

; 755  :   r = (REAL *)temp_calloc(S->N+1,sizeof(REAL));

	mov	edx, DWORD PTR [esi+4]
	push	755					; 000002f3H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	inc	edx
	push	8
	push	edx
	mov	DWORD PTR _w$[ebp], eax
	call	_kb_temp_calloc

; 756  :   X = (REAL *)temp_calloc(S->N+1,sizeof(REAL));

	push	756					; 000002f4H
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+4]
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	inc	eax
	push	8
	push	eax
	call	_kb_temp_calloc

; 757  : 
; 758  :   /* first, need to find upper bound on eigenvalues */
; 759  :   maxev = 1.0;

	fld1
	fstp	QWORD PTR _maxev$[ebp]
	add	esp, 64					; 00000040H

; 760  :   nextev = 0.0;

	fldz
	mov	DWORD PTR _X$[ebp], eax
	fld	ST(0)
	fst	QWORD PTR _nextev$[ebp]

; 761  :   minev = 0.0;

	fxch	ST(1)
	fst	QWORD PTR _minev$[ebp]
	jmp	SHORT $LN26@chebychev_@2
$LL84@chebychev_@2:

; 796  :   } while ( k < 200 );

	fstp	ST(1)
	fld	QWORD PTR _nextev$[ebp]
$LN85@chebychev_@2:

; 761  :   minev = 0.0;

	fxch	ST(1)
$LN26@chebychev_@2:

; 762  :   do
; 763  :   {
; 764  :      coeffA = 2/(maxev-nextev);

	fld	QWORD PTR _maxev$[ebp]
	fsub	ST(0), ST(2)
	fld	QWORD PTR __real@4000000000000000
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _coeffA$[ebp]

; 765  :      coeffc = -2*nextev/(maxev-nextev) - 1;

	fxch	ST(2)
	fmul	QWORD PTR __real@c000000000000000
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fsub	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR _coeffc$[ebp]

; 766  :      if ( minev >= 0.0 )

	fldz
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN48@chebychev_@2

; 767  :         for ( i = 0 ; i < S->N ; i++ ) w[i] = drand48() - .5;

	xor	edi, edi
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN48@chebychev_@2
$LL51@chebychev_@2:
	call	_drand48
	fsub	QWORD PTR __real@3fe0000000000000
	mov	ecx, DWORD PTR _w$[ebp]
	inc	edi
	fstp	QWORD PTR [ecx+edi*8-8]
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL51@chebychev_@2
$LN48@chebychev_@2:

; 768  :      (*sp_mul_func)(S,w,v);

	mov	edi, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	push	edi
	push	edx
	push	esi
	call	DWORD PTR _sp_mul_func

; 769  :      for ( i = 0 ; i < S->N ; i++ )

	fld	QWORD PTR _coeffA$[ebp]
	fld	QWORD PTR _coeffc$[ebp]
	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN17@chebychev_@2
	mov	edx, DWORD PTR _w$[ebp]
	sub	edx, edi
	mov	DWORD PTR tv468[ebp], edx
	mov	edx, ebx
	mov	eax, edi
	sub	edx, edi
	mov	edi, DWORD PTR tv468[ebp]
$LN52@chebychev_@2:

; 770  :         r[i] = coeffA*v[i] + coeffc*w[i];

	fld	QWORD PTR [edi+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx+eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LN52@chebychev_@2
$LN17@chebychev_@2:

; 771  :      coeffA *= 2; coeffc *= 2;

	fld	QWORD PTR __real@4000000000000000

; 772  :      for ( k = 0 ; k < 200 ; k++ )

	mov	DWORD PTR _k$[ebp], 0
	fmul	ST(2), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR _coeffA$[ebp]
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR _coeffc$[ebp]
	jmp	SHORT $LN53@chebychev_@2
	npad	1
$LL75@chebychev_@2:
	fstp	ST(0)
$LN53@chebychev_@2:

; 773  :      { REAL *tmp;
; 774  :         REAL norm;
; 775  :         tmp = r; r = w; w = tmp;
; 776  :         (*sp_mul_func)(S,w,v);

	mov	eax, DWORD PTR _v$[ebp]
	mov	edi, ebx
	mov	ebx, DWORD PTR _w$[ebp]
	push	eax
	push	edi
	push	esi
	mov	DWORD PTR _tmp$89686[ebp], edi
	mov	DWORD PTR _r$[ebp], ebx
	mov	DWORD PTR _w$[ebp], edi
	call	DWORD PTR _sp_mul_func

; 777  :         for ( i = 0 ; i < S->N ; i++ )

	xor	edx, edx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN11@chebychev_@2
	fld	QWORD PTR _coeffA$[ebp]
	mov	eax, ebx
	mov	ebx, DWORD PTR _v$[ebp]
	fld	QWORD PTR _coeffc$[ebp]
	sub	edi, ebx
	sub	ebx, eax
$LN54@chebychev_@2:

; 778  :           r[i] = coeffA*v[i] + coeffc*w[i] - r[i];

	lea	ecx, DWORD PTR [ebx+eax]
	fld	QWORD PTR [ecx+edi]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fld	QWORD PTR [ecx]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fsub	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LN54@chebychev_@2

; 777  :         for ( i = 0 ; i < S->N ; i++ )

	mov	ebx, DWORD PTR _r$[ebp]
	fstp	ST(1)
	mov	edi, DWORD PTR _tmp$89686[ebp]
	fstp	ST(0)
$LN11@chebychev_@2:

; 779  :         /* periodically check Rayleigh quotient to see if bound needs raising */
; 780  :         norm = dot(w,w,S->N);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	push	edi
	push	edi
	call	_dot
	fstp	QWORD PTR _norm$89687[ebp]

; 781  :         rayleigh = dot(w,v,S->N)/norm;

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _v$[ebp]
	push	edx
	push	eax
	push	edi
	call	_dot
	fdiv	QWORD PTR _norm$89687[ebp]
	add	esp, 24					; 00000018H
	fst	QWORD PTR _rayleigh$[ebp]

; 782  :         if ( rayleigh > maxev ) 

	fld	QWORD PTR _maxev$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	$LN66@chebychev_@2

; 784  :         /* just some checking */
; 785  :         if ( (k % 50)==0 )

	mov	ecx, DWORD PTR _k$[ebp]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	imul	eax, 50					; 00000032H
	mov	edx, ecx
	sub	edx, eax
	jne	SHORT $LN69@chebychev_@2

; 786  :           printf("%4d.  rayleigh %2.15g  maxev %g\n",k,(DOUBLE)rayleigh,(DOUBLE)maxev);

	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	ecx
	push	OFFSET ??_C@_0CB@JCNLBACD@?$CF4d?4?5?5rayleigh?5?$CF2?415g?5?5maxev?5?$CFg?6@
	call	_printf
	fld	QWORD PTR _rayleigh$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	add	esp, 24					; 00000018H
	jmp	SHORT $LN9@chebychev_@2
$LN69@chebychev_@2:
	fstp	ST(0)
$LN9@chebychev_@2:

; 787  :         /* renormalize occasionally */
; 788  :         if ( (k&0xFFF0) == 0 )

	test	ecx, 65520				; 0000fff0H
	jne	SHORT $LN15@chebychev_@2
	fstp	ST(0)

; 789  :         { t = 1/sqrt(norm);

	fld	QWORD PTR _norm$89687[ebp]
	call	__CIsqrt
	fld1

; 790  :           for ( i = 0 ; i < S->N ; i++ )

	xor	edx, edx
	fdivrp	ST(1), ST(0)
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN92@chebychev_@2
	mov	ecx, edi
	sub	ecx, DWORD PTR _r$[ebp]
	mov	eax, ebx
$LN55@chebychev_@2:

; 791  :               { w[i] *= t; r[i] *= t; }

	fld	QWORD PTR [ecx+eax]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [ecx+eax-8]
	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LN55@chebychev_@2

; 790  :           for ( i = 0 ; i < S->N ; i++ )

	mov	ebx, DWORD PTR _r$[ebp]
$LN92@chebychev_@2:
	mov	ecx, DWORD PTR _k$[ebp]
	fstp	ST(0)
	fld	QWORD PTR _rayleigh$[ebp]
$LN15@chebychev_@2:

; 772  :      for ( k = 0 ; k < 200 ; k++ )

	inc	ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ecx, 200				; 000000c8H
	jl	$LL75@chebychev_@2

; 782  :         if ( rayleigh > maxev ) 

	jmp	SHORT $LN14@chebychev_@2
$LN66@chebychev_@2:
	fstp	ST(0)

; 783  :         { maxev = rayleigh + .5; break; }

	fld	QWORD PTR __real@3fe0000000000000
	fadd	ST(0), ST(1)
	fstp	QWORD PTR _maxev$[ebp]
$LN14@chebychev_@2:

; 792  :         }
; 793  :      }
; 794  :      if ( rayleigh < minev-.00000001 ) 

	fld	QWORD PTR _minev$[ebp]
	fld	QWORD PTR __real@3e45798ee2308c3a
	fsubr	ST(0), ST(1)
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN25@chebychev_@2
	fstp	ST(0)

; 795  :      { minev = rayleigh; nextev = 0.9*rayleigh; k = 0; continue; }

	fld	ST(0)
	fst	QWORD PTR _minev$[ebp]
	fxch	ST(1)
	fmul	QWORD PTR __real@3feccccccccccccd
	fst	QWORD PTR _nextev$[ebp]

; 796  :   } while ( k < 200 );

	jmp	$LN85@chebychev_@2
$LN25@chebychev_@2:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, 200				; 000000c8H
	jl	$LL84@chebychev_@2

; 797  :   printf("%4d.  rayleigh %2.15g\n",k,(DOUBLE)rayleigh);

	sub	esp, 8
	fstp	ST(0)
	fstp	QWORD PTR [esp]
	push	eax
	push	OFFSET ??_C@_0BH@FBOLJFJE@?$CF4d?4?5?5rayleigh?5?$CF2?415g?6?$AA@
	call	_printf

; 798  :   /* else try again with increased maxev */
; 799  : 
; 800  :   /* now have got eigenvector for neg eigenvalue */
; 801  :   t = 1/sqrt(dot(r,r,S->N));

	mov	eax, DWORD PTR [esi+4]
	push	eax
	push	ebx
	push	ebx
	call	_dot
	add	esp, 28					; 0000001cH
	call	__CIsqrt
	fld1

; 802  :   for ( i = 0 ; i < S->N ; i++ ) X[i] = t*r[i];    /* normalized */

	xor	ecx, ecx
	fdivrp	ST(1), ST(0)
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN90@chebychev_@2
	mov	eax, DWORD PTR _X$[ebp]
	mov	edx, ebx
	sub	edx, eax
$LN56@chebychev_@2:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LN56@chebychev_@2
$LN90@chebychev_@2:

; 803  : 
; 804  :   temp_free((char*)w);

	push	edi
	fstp	ST(0)
	call	_temp_free

; 805  :   temp_free((char*)v);

	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	call	_temp_free

; 806  :   temp_free((char*)r);

	push	ebx
	call	_temp_free

; 807  :   temp_free((char*)X);

	mov	edx, DWORD PTR _X$[ebp]
	push	edx
	call	_temp_free
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 808  : } /* end chebychev_hess() */

	mov	esp, ebp
	pop	ebp
	ret	0
_chebychev_hess ENDP
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	??_C@_0BC@GPPINECM@?$CFd?5?5ev?5?$DN?5?$CF20?415f?6?$AA@ ; `string'
PUBLIC	__real@46293e5939a08cea
PUBLIC	??_C@_0CG@NAMCFDKN@Eigencounts?3?5?5?5?5?$CFd?5?$DM?0?5?5?$CFd?5?$DN?$DN?0?5?5?$CF@ ; `string'
PUBLIC	_eigenprobe_command
EXTRN	_sparse_metric_dot:PROC
EXTRN	_star_metric_setup:PROC
EXTRN	_linear_metric_setup:PROC
EXTRN	_Met:BYTE
EXTRN	_hessian_linear_metric_flag:DWORD
EXTRN	_hessian_fill:PROC
EXTRN	_rhs_flag:DWORD
EXTRN	_hessian_normal_flag:DWORD
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT ??_C@_0BC@GPPINECM@?$CFd?5?5ev?5?$DN?5?$CF20?415f?6?$AA@
CONST	SEGMENT
??_C@_0BC@GPPINECM@?$CFd?5?5ev?5?$DN?5?$CF20?415f?6?$AA@ DB '%d  ev = %20'
	DB	'.15f', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@46293e5939a08cea
CONST	SEGMENT
__real@46293e5939a08cea DQ 046293e5939a08cear	; 1e+030
CONST	ENDS
;	COMDAT ??_C@_0CG@NAMCFDKN@Eigencounts?3?5?5?5?5?$CFd?5?$DM?0?5?5?$CFd?5?$DN?$DN?0?5?5?$CF@
CONST	SEGMENT
??_C@_0CG@NAMCFDKN@Eigencounts?3?5?5?5?5?$CFd?5?$DM?0?5?5?$CFd?5?$DN?$DN?0?5?5?$CF@ DB 'E'
	DB	'igencounts:    %d <,  %d ==,  %d > ', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _eigenprobe_command
_TEXT	SEGMENT
_S$ = -260						; size = 232
_oldt$ = -28						; size = 8
_oldv0$89746 = -20					; size = 8
_t$ = -12						; size = 8
_W$ = -4						; size = 4
_lambda$ = 8						; size = 8
_k$ = 12						; size = 4
_iters$ = 16						; size = 4
_eigenprobe_command PROC				; COMDAT

; 823  : { struct linsys S;

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H

; 824  :   int i,k;
; 825  :   REAL t,oldt;
; 826  :   REAL *W = NULL; /* for use when metric is needed */
; 827  :   REAL *X = NULL; /* for eigenvector */
; 828  :   hmode = hessian_normal_flag;

	mov	eax, DWORD PTR _hessian_normal_flag
	push	esi
	push	edi
	xor	edi, edi

; 829  :   hessian_init(&S,NULL);

	lea	ecx, DWORD PTR _S$[ebp]
	push	edi
	push	ecx
	mov	DWORD PTR _W$[ebp], edi
	xor	esi, esi
	mov	DWORD PTR _hmode, eax
	call	_hessian_init

; 830  :   hess_flag = 1; rhs_flag = 0; 
; 831  :   hessian_fill(&S,NULL); 

	lea	edx, DWORD PTR _S$[ebp]
	push	edi
	push	edx
	mov	DWORD PTR _hess_flag, 1
	mov	DWORD PTR _rhs_flag, edi
	call	_hessian_fill

; 832  :   S.lambda = lambda;

	fld	QWORD PTR _lambda$[ebp]

; 833  :    
; 834  : 
; 835  :   (*sp_AIJ_setup_func)(S.A_rows,&S);

	mov	ecx, DWORD PTR _S$[ebp+12]
	fstp	QWORD PTR _S$[ebp+112]
	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	push	ecx
	call	DWORD PTR _sp_AIJ_setup_func

; 836  :   (*sp_constraint_setup_func)
; 837  :        (web.skel[BODY].max_ord+1 + gen_quant_count,&S);

	mov	eax, DWORD PTR _web+404
	mov	ecx, DWORD PTR _web+5528
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	call	DWORD PTR _sp_constraint_setup_func

; 838  :   if ( sp_ordering_func ) (*sp_ordering_func)(&S);

	mov	eax, DWORD PTR _sp_ordering_func
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN38@eigenprobe
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	eax
	add	esp, 4
$LN38@eigenprobe:

; 839  :   if ( hessian_linear_metric_flag )

	cmp	DWORD PTR _hessian_linear_metric_flag, edi
	je	SHORT $LN37@eigenprobe

; 840  :   { 
; 841  :     linear_metric_setup(&S,&Met);

	lea	edx, DWORD PTR _S$[ebp]
	push	OFFSET _Met
	push	edx
	call	_linear_metric_setup
	jmp	SHORT $LN83@eigenprobe
$LN37@eigenprobe:

; 842  :   }
; 843  :   else if ( web.area_norm_flag )

	cmp	DWORD PTR _web+876, edi
	je	SHORT $LN53@eigenprobe

; 844  :   { 
; 845  :     star_metric_setup(&S,&Met);

	lea	eax, DWORD PTR _S$[ebp]
	push	OFFSET _Met
	push	eax
	call	_star_metric_setup
$LN83@eigenprobe:
	add	esp, 8
$LN53@eigenprobe:
	push	ebx

; 846  :   }
; 847  : 
; 848  :  sp_factor(&S,MKL_INDEF);

	lea	ecx, DWORD PTR _S$[ebp]
	push	-2					; fffffffeH
	push	ecx
	call	_sp_factor

; 849  : 
; 850  :  (*sp_hess_project_setup_func)(&S);

	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	DWORD PTR _sp_hess_project_setup_func

; 851  : 
; 852  :   sprintf(msg,"Eigencounts:    %d <,  %d ==,  %d > \n",S.neg,S.zero,S.pos);

	mov	eax, DWORD PTR _S$[ebp+184]
	mov	ecx, DWORD PTR _S$[ebp+192]
	mov	edx, DWORD PTR _S$[ebp+188]
	push	eax
	mov	eax, DWORD PTR _msg
	push	ecx
	push	edx
	push	OFFSET ??_C@_0CG@NAMCFDKN@Eigencounts?3?5?5?5?5?$CFd?5?$DM?0?5?5?$CFd?5?$DN?$DN?0?5?5?$CF@
	push	eax
	call	_sprintf

; 853  :   outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring

; 854  :   
; 855  :   if ( iters <= 0 ) goto ep_exit;

	mov	ebx, DWORD PTR _iters$[ebp]
	add	esp, 36					; 00000024H
	cmp	ebx, edi
	jle	$ep_exit$89730

; 856  : 
; 857  :   if ( web.area_norm_flag || hessian_linear_metric_flag )

	cmp	DWORD PTR _web+876, edi
	jne	SHORT $LN32@eigenprobe
	cmp	DWORD PTR _hessian_linear_metric_flag, edi
	je	SHORT $LN33@eigenprobe
$LN32@eigenprobe:

; 858  :      W = (REAL*)temp_calloc(S.N,sizeof(REAL));

	mov	edx, DWORD PTR _S$[ebp+4]
	push	858					; 0000035aH
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	push	8
	push	edx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _W$[ebp], eax
$LN33@eigenprobe:

; 859  :   X = (REAL*)temp_calloc(S.N,sizeof(REAL));

	mov	eax, DWORD PTR _S$[ebp+4]
	push	859					; 0000035bH
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc
	mov	esi, eax

; 860  :   /* inverse iteration */
; 861  :   /* random starting vector */
; 862  :   for ( i = 0 ; i < S.N ; i++ ) X[i] = drand48();

	mov	eax, DWORD PTR _S$[ebp+4]
	add	esp, 16					; 00000010H
	test	eax, eax
	jle	SHORT $LN29@eigenprobe
$LL31@eigenprobe:
	call	_drand48
	fstp	QWORD PTR [esi+edi*8]
	mov	eax, DWORD PTR _S$[ebp+4]
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL31@eigenprobe
$LN29@eigenprobe:

; 863  :   t = 1/sqrt(dot(X,X,S.N));

	push	eax
	push	esi
	push	esi
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fld1
	fdivrp	ST(1), ST(0)

; 864  :   for ( i = 0 ; i < S.N ; i++ ) X[i] *= t;

	mov	edi, DWORD PTR _S$[ebp+4]
	xor	eax, eax
	fst	QWORD PTR _t$[ebp]
	test	edi, edi
	jle	SHORT $LN26@eigenprobe
$LN28@eigenprobe:
	fld	QWORD PTR [esi+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi+eax*8-8]
	mov	edi, DWORD PTR _S$[ebp+4]
	cmp	eax, edi
	jl	SHORT $LN28@eigenprobe
$LN26@eigenprobe:

; 865  :   oldt = 1e30; /* for convergence test */

	fld	QWORD PTR __real@46293e5939a08cea

; 866  :   for ( k = 0 ; k < iters ; k++ )

	mov	DWORD PTR _k$[ebp], 0
	fstp	QWORD PTR _oldt$[ebp]
	test	ebx, ebx
	jle	$LN56@eigenprobe
$LN82@eigenprobe:
	fstp	ST(0)

; 867  :   { REAL oldv0=1.0; /* for sign */
; 868  :      int oldvi=0;     /* index of nonzero component */

	xor	ebx, ebx

; 869  :      REAL eps = 1/sqrt((REAL)(S.N))/2;

	fild	DWORD PTR _S$[ebp+4]
	call	__CIsqrt
	fdivr	QWORD PTR __real@3fe0000000000000

; 870  :      for ( i = 0, oldv0 = 0.0 ; i < S.N ; i++ )

	xor	ecx, ecx
	fldz
	fstp	QWORD PTR _oldv0$89746[ebp]
	test	edi, edi
	jle	SHORT $LN64@eigenprobe
$LN22@eigenprobe:

; 871  :         if ( fabs(X[i]) > eps ) { oldvi = i; oldv0 = X[i]; break; }

	fld	QWORD PTR [esi+ecx*8]
	fabs
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN67@eigenprobe

; 870  :      for ( i = 0, oldv0 = 0.0 ; i < S.N ; i++ )

	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LN22@eigenprobe
$LN64@eigenprobe:

; 871  :         if ( fabs(X[i]) > eps ) { oldvi = i; oldv0 = X[i]; break; }

	fstp	ST(0)
$LN20@eigenprobe:

; 872  :      if ( web.area_norm_flag || hessian_linear_metric_flag )

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN17@eigenprobe
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN17@eigenprobe

; 874  :      else W = X;

	mov	DWORD PTR _W$[ebp], esi
	jmp	SHORT $LN16@eigenprobe
$LN67@eigenprobe:

; 871  :         if ( fabs(X[i]) > eps ) { oldvi = i; oldv0 = X[i]; break; }

	fstp	ST(0)
	mov	ebx, ecx
	fld	QWORD PTR [esi+ecx*8]
	fstp	QWORD PTR _oldv0$89746[ebp]
	jmp	SHORT $LN20@eigenprobe
$LN17@eigenprobe:

; 873  :          (*sp_mul_func)(&Met,X,W);

	mov	ecx, DWORD PTR _W$[ebp]
	push	ecx
	push	esi
	push	OFFSET _Met
	call	DWORD PTR _sp_mul_func
	add	esp, 12					; 0000000cH
$LN16@eigenprobe:

; 875  :      sp_hessian_solve(&S,W,X,NO_SET_PRESSURE);

	mov	edx, DWORD PTR _W$[ebp]
	push	0
	push	esi
	push	edx
	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	call	_sp_hessian_solve
	add	esp, 16					; 00000010H

; 876  :      if ( web.area_norm_flag || hessian_linear_metric_flag )

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN14@eigenprobe
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN14@eigenprobe

; 878  :      else t = 1/sqrt(dot(X,X,S.N));

	mov	ecx, DWORD PTR _S$[ebp+4]
	push	ecx
	push	esi
	push	esi
	call	_dot
	jmp	SHORT $LN84@eigenprobe
$LN14@eigenprobe:

; 877  :         t = 1/sqrt(sparse_metric_dot(X,X,&Met));

	push	OFFSET _Met
	push	esi
	push	esi
	call	_sparse_metric_dot
$LN84@eigenprobe:
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fld1
	fdivrp	ST(1), ST(0)
	fst	QWORD PTR _t$[ebp]

; 879  :      if ( X[oldvi]*oldv0 < 0. ) t = -t;  /* get sign right */

	fld	QWORD PTR [esi+ebx*8]
	fmul	QWORD PTR _oldv0$89746[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN12@eigenprobe
	fchs
	fst	QWORD PTR _t$[ebp]
$LN12@eigenprobe:

; 880  : #ifdef FLOAT128
; 881  :      if ( k % 10 == 0 ) printf("%d  ev = %*.*Qf\n",k,DWIDTH,DPREC,S.lambda+t);
; 882  : #elif defined(LONGDOUBLE)
; 883  :      if ( k % 10 == 0 ) printf("%d  ev = %*.*Lf\n",k,DWIDTH,DPREC,S.lambda+t);
; 884  : #else
; 885  :      if ( k % 10 == 0 ) printf("%d  ev = %20.15f\n",k,S.lambda+t);

	mov	ecx, DWORD PTR _k$[ebp]
	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 3
	lea	edx, DWORD PTR [edx+edx*4]
	add	edx, edx
	mov	eax, ecx
	sub	eax, edx
	jne	SHORT $LN55@eigenprobe
	fadd	QWORD PTR _S$[ebp+112]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	push	OFFSET ??_C@_0BC@GPPINECM@?$CFd?5?5ev?5?$DN?5?$CF20?415f?6?$AA@
	call	_printf
	fld	QWORD PTR _t$[ebp]
	add	esp, 16					; 00000010H
$LN55@eigenprobe:

; 886  : #endif 
; 887  :      for ( i = 0 ; i < S.N ; i++ ) X[i] *= t;

	mov	edi, DWORD PTR _S$[ebp+4]
	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN8@eigenprobe
$LN10@eigenprobe:
	fld	QWORD PTR [esi+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi+eax*8-8]
	mov	edi, DWORD PTR _S$[ebp+4]
	cmp	eax, edi
	jl	SHORT $LN10@eigenprobe
$LN8@eigenprobe:

; 888  :      if ( fabs(t-oldt) <= 100*machine_eps*fabs(t) )

	fld	QWORD PTR _oldt$[ebp]
	fsubr	ST(0), ST(1)
	fabs
	fld	ST(1)
	fabs
	fld	QWORD PTR _machine_eps
	fmul	QWORD PTR __real@4059000000000000
	fmulp	ST(1), ST(0)
	fcompp
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN56@eigenprobe

; 889  :       { 
; 890  :          break;
; 891  :       }
; 892  :      oldt = t;

	mov	eax, DWORD PTR _k$[ebp]
	fst	QWORD PTR _oldt$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _iters$[ebp]
	jl	$LN82@eigenprobe
$LN56@eigenprobe:

; 893  :   }
; 894  : #ifdef FLOAT128
; 895  :   printf("%d  ev = %*.*Qf\n",k,DWIDTH,DPREC,S.lambda+t);
; 896  : #elif defined(LONGDOUBLE)
; 897  :   printf("%d  ev = %*.*Lf\n",k,DWIDTH,DPREC,S.lambda+t);
; 898  : #else
; 899  :   printf("%d  ev = %20.15f\n",k,S.lambda+t);

	fadd	QWORD PTR _S$[ebp+112]
	mov	ecx, DWORD PTR _k$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	push	OFFSET ??_C@_0BC@GPPINECM@?$CFd?5?5ev?5?$DN?5?$CF20?415f?6?$AA@
	call	_printf
	add	esp, 16					; 00000010H

; 900  : #endif 
; 901  :   if ( S.zero != 0 ) last_eigenvalue = S.lambda;

	cmp	DWORD PTR _S$[ebp+192], 0
	je	SHORT $LN6@eigenprobe
	fld	QWORD PTR _S$[ebp+112]

; 902  :   else

	jmp	SHORT $LN85@eigenprobe
$LN6@eigenprobe:

; 903  :   last_eigenvalue = S.lambda+t;

	fld	QWORD PTR _t$[ebp]
	fadd	QWORD PTR _S$[ebp+112]
$LN85@eigenprobe:

; 904  :   if ( web.area_norm_flag || hessian_linear_metric_flag )

	cmp	DWORD PTR _web+876, 0
	fstp	QWORD PTR _last_eigenvalue
	jne	SHORT $LN3@eigenprobe
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $ep_exit$89730
$LN3@eigenprobe:

; 905  :       temp_free((char*)W);

	mov	edx, DWORD PTR _W$[ebp]
	push	edx
	call	_temp_free
	add	esp, 4
$ep_exit$89730:

; 906  :   
; 907  : ep_exit:
; 908  :   free_system(&S);

	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	call	_free_system
	add	esp, 4

; 909  :   if ( hessian_linear_metric_flag || web.area_norm_flag ) free_system(&Met);

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	pop	ebx
	jne	SHORT $LN1@eigenprobe
	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN2@eigenprobe
$LN1@eigenprobe:
	push	OFFSET _Met
	call	_free_system
	add	esp, 4
$LN2@eigenprobe:

; 910  :   hessian_exit(X);

	push	esi
	call	_hessian_exit

; 911  :   temp_free((char*)X);

	push	esi
	call	_temp_free
	add	esp, 8
	pop	edi
	pop	esi

; 912  : } /* end eigenprobe_command() */

	mov	esp, ebp
	pop	ebp
	ret	0
_eigenprobe_command ENDP
_TEXT	ENDS
PUBLIC	_realabs_comp
; Function compile flags: /Ogtp
;	COMDAT _realabs_comp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_realabs_comp PROC					; COMDAT

; 978  : {if(fabs(*a)<fabs(*b))return-1;else if (fabs(*a)>fabs(*b))return 1;return 0;}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _a$[ebp]
	fld	QWORD PTR [eax]
	mov	ecx, DWORD PTR _b$[ebp]
	fabs
	fld	QWORD PTR [ecx]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@realabs_co
	fstp	ST(0)
	or	eax, -1
	fstp	ST(0)
	pop	ebp
	ret	0
$LN3@realabs_co:
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@realabs_co
	mov	eax, 1
	pop	ebp
	ret	0
$LN1@realabs_co:
	xor	eax, eax
	pop	ebp
	ret	0
_realabs_comp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@OCJELPGI@Over?530?5iterations?5in?5QL?5algorit@ ; `string'
PUBLIC	_tridiag_QL
;	COMDAT ??_C@_0DN@OCJELPGI@Over?530?5iterations?5in?5QL?5algorit@
CONST	SEGMENT
??_C@_0DN@OCJELPGI@Over?530?5iterations?5in?5QL?5algorit@ DB 'Over 30 ite'
	DB	'rations in QL algorithm solving for eigenvalues.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _tridiag_QL
_TEXT	SEGMENT
_b$ = -48						; size = 8
_f$ = -40						; size = 8
_s$ = -40						; size = 8
_p$ = -32						; size = 8
_c$ = -24						; size = 8
_g$ = -24						; size = 8
tv1501 = -16						; size = 4
_iter$ = -12						; size = 4
_l$ = -8						; size = 4
tv948 = -4						; size = 4
_d$ = 8							; size = 4
_e$ = 12						; size = 4
_n$ = 16						; size = 4
_tridiag_QL PROC					; COMDAT

; 1218 : { int m,l,iter,i;

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 1219 :   REAL s,r,p,g,f,dd,c,b;
; 1220 : 
; 1221 :   d--;e--;  /* to agree with Numerical Recipes indexing */

	mov	ecx, DWORD PTR _d$[ebp]

; 1222 : 
; 1223 :   e[n] = 0.0;

	fldz
	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	sub	eax, 8
	sub	ecx, 8
	fstp	QWORD PTR [eax+edx*8]
	mov	DWORD PTR _d$[ebp], ecx
	mov	DWORD PTR _e$[ebp], eax

; 1224 :   for ( l = 1 ;l <= n ; l++ )

	mov	DWORD PTR _l$[ebp], 1
	cmp	edx, 1
	jl	$LN15@tridiag_QL
	fld1
	push	ebx
	push	esi
	lea	esi, DWORD PTR [ecx+8]
	sub	eax, ecx
	push	edi
	mov	DWORD PTR tv1501[ebp], esi
	mov	DWORD PTR tv948[ebp], eax
$LN17@tridiag_QL:

; 1225 :   { iter = 0;

	mov	DWORD PTR _iter$[ebp], 0
$LN14@tridiag_QL:

; 1224 :   for ( l = 1 ;l <= n ; l++ )

	mov	ebx, DWORD PTR _n$[ebp]

; 1226 :      do 
; 1227 :      { for ( m=l ; m <= n-1 ; m++ )    /* test matrix splitting */

	mov	eax, DWORD PTR _l$[ebp]
	dec	ebx
	mov	edi, eax
	cmp	eax, ebx
	jg	$LN39@tridiag_QL
	mov	ecx, ebx
	sub	ecx, eax
	inc	ecx
	cmp	ecx, 4
	jl	$LC30@tridiag_QL
	mov	edx, DWORD PTR tv948[ebp]
	lea	edx, DWORD PTR [edx+esi+24]
	lea	ecx, DWORD PTR [esi+8]
$LN34@tridiag_QL:

; 1228 :         { dd = fabs(d[m]) + fabs(d[m+1]);

	fld	QWORD PTR [ecx]
	fabs
	fld	QWORD PTR [ecx-8]
	fabs
	fadd	ST(0), ST(1)

; 1229 :           if ( fabs(e[m]) + dd == dd ) break;

	fld	QWORD PTR [edx-24]
	fabs
	fadd	ST(0), ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN51@tridiag_QL
	fld	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR tv948[ebp]
	fabs
	fld	ST(0)
	faddp	ST(2), ST(0)
	fld	QWORD PTR [eax+ecx]
	fabs
	fadd	ST(0), ST(2)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	SHORT $LN54@tridiag_QL

; 1228 :         { dd = fabs(d[m]) + fabs(d[m+1]);

	fld	QWORD PTR [ecx+16]
	fabs
	fadd	ST(1), ST(0)

; 1229 :           if ( fabs(e[m]) + dd == dd ) break;

	fld	QWORD PTR [edx-8]
	fabs
	fadd	ST(0), ST(2)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	$LN57@tridiag_QL

; 1228 :         { dd = fabs(d[m]) + fabs(d[m+1]);

	fld	QWORD PTR [ecx+24]
	fabs
	faddp	ST(1), ST(0)

; 1229 :           if ( fabs(e[m]) + dd == dd ) break;

	fld	QWORD PTR [edx]
	fabs
	fadd	ST(0), ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN33@tridiag_QL

; 1226 :      do 
; 1227 :      { for ( m=l ; m <= n-1 ; m++ )    /* test matrix splitting */

	add	edi, 4
	lea	eax, DWORD PTR [ebx-3]
	add	ecx, 32					; 00000020H
	add	edx, 32					; 00000020H
	cmp	edi, eax
	jle	$LN34@tridiag_QL
$LC30@tridiag_QL:
	cmp	edi, ebx
	jg	SHORT $LN38@tridiag_QL
	mov	ecx, DWORD PTR _d$[ebp]
	lea	ecx, DWORD PTR [ecx+edi*8]
$LN37@tridiag_QL:

; 1228 :         { dd = fabs(d[m]) + fabs(d[m+1]);

	fld	QWORD PTR [ecx+8]

; 1229 :           if ( fabs(e[m]) + dd == dd ) break;

	mov	edx, DWORD PTR tv948[ebp]
	fabs
	fld	QWORD PTR [ecx]
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx+ecx]
	fabs
	fadd	ST(0), ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN38@tridiag_QL

; 1226 :      do 
; 1227 :      { for ( m=l ; m <= n-1 ; m++ )    /* test matrix splitting */

	inc	edi
	add	ecx, 8
	cmp	edi, ebx
	jle	SHORT $LN37@tridiag_QL
	jmp	SHORT $LN38@tridiag_QL
$LN54@tridiag_QL:

; 1229 :           if ( fabs(e[m]) + dd == dd ) break;

	inc	edi
$LN51@tridiag_QL:
	fstp	ST(0)
$LN38@tridiag_QL:

; 1230 :         }
; 1231 :         if ( m != l )

	mov	eax, DWORD PTR _l$[ebp]
	cmp	edi, eax
	je	$LN39@tridiag_QL

; 1232 :         { if ( iter++ >= 30 ) 

	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, eax
	inc	eax
	mov	DWORD PTR _iter$[ebp], eax
	cmp	ecx, 30					; 0000001eH
	jl	SHORT $LN6@tridiag_QL

; 1233 :              kb_error(1654,"Over 30 iterations in QL algorithm solving for eigenvalues.\n",RECOVERABLE); 

	push	1
	fstp	ST(0)
	push	OFFSET ??_C@_0DN@OCJELPGI@Over?530?5iterations?5in?5QL?5algorit@
	push	1654					; 00000676H
	call	_kb_error
	fld1
	add	esp, 12					; 0000000cH
$LN6@tridiag_QL:

; 1234 :           g = (d[l+1]-d[l])/(2*e[l]);    /* form shift */

	fld	QWORD PTR [esi+8]
	mov	edx, DWORD PTR tv948[ebp]
	fsub	QWORD PTR [esi]
	fld	QWORD PTR [edx+esi]
	fadd	ST(0), ST(0)
	fdivp	ST(1), ST(0)
	fst	QWORD PTR _g$[ebp]

; 1235 :           r = sqrt(g*g+1.0);

	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt

; 1236 :           g = d[m] - d[l] + e[l]/(g + SIGN(r,g));

	fldz
	fld	QWORD PTR _g$[ebp]
	fcom	ST(1)
	fnstsw	ax
	fxch	ST(2)
	fabs
	test	ah, 5
	jp	SHORT $LN21@tridiag_QL
	fchs
$LN21@tridiag_QL:
	mov	eax, DWORD PTR tv948[ebp]
	faddp	ST(2), ST(0)
	fld	QWORD PTR [eax+esi]
	mov	eax, DWORD PTR _d$[ebp]

; 1237 :           s = c = 1.0;
; 1238 :           p = 0.0;
; 1239 :           for ( i = m-1 ; i >= l ; i-- )

	lea	ebx, DWORD PTR [edi-1]
	fdivrp	ST(2), ST(0)
	fld	QWORD PTR [eax+edi*8]
	fsub	QWORD PTR [esi]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _g$[ebp]
	fld1
	fld	ST(0)
	fld	ST(1)
	fld	ST(4)
	fst	QWORD PTR _p$[ebp]
	cmp	ebx, DWORD PTR _l$[ebp]
	jl	$LN72@tridiag_QL
	fstp	ST(5)
	lea	esi, DWORD PTR [eax+ebx*8+8]
	fstp	ST(4)
	jmp	SHORT $LN5@tridiag_QL
$LN57@tridiag_QL:

; 1229 :           if ( fabs(e[m]) + dd == dd ) break;

	add	edi, 2
	jmp	$LN51@tridiag_QL
$LN33@tridiag_QL:
	add	edi, 3
	jmp	$LN38@tridiag_QL
$LN80@tridiag_QL:

; 1237 :           s = c = 1.0;
; 1238 :           p = 0.0;
; 1239 :           for ( i = m-1 ; i >= l ; i-- )

	fstp	ST(1)
	fxch	ST(2)
	fxch	ST(1)
$LN5@tridiag_QL:

; 1240 :           { f = s*e[i];

	mov	eax, DWORD PTR _e$[ebp]
	fld	QWORD PTR [eax+ebx*8]
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	fst	QWORD PTR _f$[ebp]

; 1241 :              b = c*e[i];

	fld	QWORD PTR [eax+ebx*8]
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	fstp	QWORD PTR _b$[ebp]

; 1242 :              if ( fabs(f) >= fabs(g) ) 

	fld	ST(2)
	fabs
	fld	ST(2)
	fabs
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN2@tridiag_QL

; 1243 :              { c = g/f;

	fxch	ST(1)
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _c$[ebp]

; 1244 :                 r = sqrt(c*c + 1.0);

	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt

; 1245 :                 e[i+1] = f*r;

	fld	QWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR tv948[ebp]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [ecx+esi]

; 1246 :                 c *= (s = 1/r);

	fld1
	fld	ST(0)
	fdivrp	ST(2), ST(0)
	fld	QWORD PTR _c$[ebp]
	fmul	ST(0), ST(2)

; 1247 :              }
; 1248 :              else

	jmp	SHORT $LN1@tridiag_QL
$LN2@tridiag_QL:

; 1249 :              { s = f/g;

	fxch	ST(2)
	fdivrp	ST(1), ST(0)
	fst	QWORD PTR _s$[ebp]

; 1250 :                 r = sqrt(s*s + 1.0);

	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt

; 1251 :                 e[i+1] = g*r;

	fld	QWORD PTR _g$[ebp]
	mov	edx, DWORD PTR tv948[ebp]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx+esi]

; 1252 :                 s *= (c = 1/r);

	fld1
	fld	ST(0)
	fdivrp	ST(2), ST(0)
	fld	ST(1)
	fmul	QWORD PTR _s$[ebp]
	fxch	ST(2)
$LN1@tridiag_QL:

; 1253 :              }
; 1254 :              g = d[i+1] - p;

	fld	QWORD PTR [esi]
	dec	ebx
	fsub	QWORD PTR _p$[ebp]
	sub	esi, 8

; 1255 :              r = (d[i] - g)*s + 2*c*b;

	fld	QWORD PTR [esi]
	fsub	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fld	ST(2)
	fadd	ST(0), ST(0)
	fld	QWORD PTR _b$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(2)
	faddp	ST(1), ST(0)

; 1256 :              p = s*r;

	fld	ST(5)
	fmul	ST(0), ST(1)
	fst	QWORD PTR _p$[ebp]

; 1257 :              d[i+1] = g + p;

	fld	ST(0)
	faddp	ST(4), ST(0)
	fxch	ST(3)
	fstp	QWORD PTR [esi+8]

; 1258 :              g = c*r - b;

	fmul	ST(0), ST(3)
	fsubrp	ST(1), ST(0)
	fst	QWORD PTR _g$[ebp]
	cmp	ebx, DWORD PTR _l$[ebp]
	jge	$LN80@tridiag_QL

; 1237 :           s = c = 1.0;
; 1238 :           p = 0.0;
; 1239 :           for ( i = m-1 ; i >= l ; i-- )

	mov	esi, DWORD PTR tv1501[ebp]
	fstp	ST(2)
	fstp	ST(3)
	fldz
	fxch	ST(3)
	fxch	ST(1)
	fxch	ST(2)
	fxch	ST(1)
$LN36@tridiag_QL:

; 1259 :           }
; 1260 :           d[l] -= p;

	fsubr	QWORD PTR [esi]

; 1261 :           e[l] = g;

	mov	eax, DWORD PTR tv948[ebp]

; 1262 :           e[m] = 0.0;

	mov	ecx, DWORD PTR _e$[ebp]
	fstp	QWORD PTR [esi]
	fxch	ST(1)
	fstp	QWORD PTR [eax+esi]
	fxch	ST(1)
	fstp	QWORD PTR [ecx+edi*8]

; 1263 :         }
; 1264 :      } while ( m != l );

	jmp	$LN14@tridiag_QL
$LN72@tridiag_QL:

; 1237 :           s = c = 1.0;
; 1238 :           p = 0.0;
; 1239 :           for ( i = m-1 ; i >= l ; i-- )

	fstp	ST(2)
	fstp	ST(0)
	jmp	SHORT $LN36@tridiag_QL
$LN39@tridiag_QL:

; 1224 :   for ( l = 1 ;l <= n ; l++ )

	inc	eax
	add	esi, 8
	mov	DWORD PTR _l$[ebp], eax
	mov	DWORD PTR tv1501[ebp], esi
	cmp	eax, DWORD PTR _n$[ebp]
	jle	$LN17@tridiag_QL
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx
$LN15@tridiag_QL:

; 1265 :   }
; 1266 : } /* end tridiagonal_QL () */

	mov	esp, ebp
	pop	ebp
	ret	0
_tridiag_QL ENDP
_TEXT	ENDS
PUBLIC	_LQ_decomp
; Function compile flags: /Ogtp
;	COMDAT _LQ_decomp
_TEXT	SEGMENT
tv2199 = -20						; size = 4
tv2178 = -16						; size = 4
_j$ = -12						; size = 4
_k$ = -12						; size = 4
tv2183 = -8						; size = 4
_i$ = -4						; size = 4
_A$ = 8							; size = 4
_rows$ = 12						; size = 4
_cols$ = 16						; size = 4
_Q$ = 20						; size = 4
_L$ = 24						; size = 4
_M$ = 28						; size = 4
_LQ_decomp PROC						; COMDAT

; 1284 : { int i,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1285 :   REAL t;
; 1286 : 
; 1287 :   for ( i = 0 ; i < rows ; i++ )

	cmp	DWORD PTR _rows$[ebp], 0
	mov	DWORD PTR _i$[ebp], 0
	jle	$LN15@LQ_decomp
	mov	ecx, DWORD PTR _Q$[ebp]
	mov	edx, DWORD PTR _A$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _L$[ebp]
	sub	edx, ebx
	push	esi
	sub	ebx, ecx
	push	edi
	mov	esi, ecx
	mov	DWORD PTR tv2178[ebp], edx
	mov	DWORD PTR tv2183[ebp], ebx
	jmp	SHORT $LN17@LQ_decomp
$LL47@LQ_decomp:
	mov	ecx, DWORD PTR _Q$[ebp]
	mov	edx, DWORD PTR tv2178[ebp]
	mov	ebx, DWORD PTR tv2183[ebp]
$LN17@LQ_decomp:

; 1288 :   { if ( Q != A )/* copy over */
; 1289 :       for ( k = 0 ; k < cols ; k++ ) 

	mov	edi, DWORD PTR _cols$[ebp]
	cmp	ecx, DWORD PTR _A$[ebp]
	je	$LN50@LQ_decomp
	xor	eax, eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	edi, 4
	jl	SHORT $LN43@LQ_decomp
	add	ebx, edx
	mov	ecx, DWORD PTR [ebx+esi]
	mov	ebx, DWORD PTR [esi]
	lea	edx, DWORD PTR [ecx+24]

; 1290 :         Q[i][k] = A[i][k];

	sub	ecx, ebx
	mov	DWORD PTR tv2199[ebp], ecx
	lea	ecx, DWORD PTR [edi-4]
	shr	ecx, 2
	lea	eax, DWORD PTR [ebx+8]
	inc	ecx
	lea	ebx, DWORD PTR [ecx*4]
	mov	DWORD PTR _k$[ebp], ebx
	mov	ebx, DWORD PTR tv2199[ebp]
$LL36@LQ_decomp:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	add	edx, 32					; 00000020H
	dec	ecx
	fld	QWORD PTR [ebx+eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LL36@LQ_decomp

; 1288 :   { if ( Q != A )/* copy over */
; 1289 :       for ( k = 0 ; k < cols ; k++ ) 

	mov	ecx, DWORD PTR _Q$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR tv2178[ebp]
	mov	ebx, DWORD PTR tv2183[ebp]
$LN43@LQ_decomp:
	cmp	eax, edi
	jge	SHORT $LN50@LQ_decomp
	mov	ecx, DWORD PTR [esi]
	add	ebx, edx
	mov	ebx, DWORD PTR [ebx+esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	sub	ebx, ecx
	mov	ecx, edi
	sub	ecx, DWORD PTR _k$[ebp]
	npad	7
$LC13@LQ_decomp:

; 1290 :         Q[i][k] = A[i][k];

	fld	QWORD PTR [eax+ebx]
	add	eax, 8
	dec	ecx
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC13@LQ_decomp

; 1288 :   { if ( Q != A )/* copy over */
; 1289 :       for ( k = 0 ; k < cols ; k++ ) 

	mov	ecx, DWORD PTR _Q$[ebp]
$LN50@LQ_decomp:

; 1291 :      for ( j = 0 ; j < i ; j++ )

	xor	ebx, ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	DWORD PTR _i$[ebp], ebx
	jle	$LN45@LQ_decomp
	jmp	SHORT $LN10@LQ_decomp
	npad	1
$LL46@LQ_decomp:
	mov	ecx, DWORD PTR _Q$[ebp]
$LN10@LQ_decomp:

; 1292 :      { t = M ? sparse_metric_dot(Q[j],Q[i],M) :  dot(Q[j],Q[i],cols);

	mov	eax, DWORD PTR _M$[ebp]
	test	eax, eax
	je	SHORT $LN20@LQ_decomp
	mov	ecx, DWORD PTR [ecx+ebx*4]
	push	eax
	mov	eax, DWORD PTR [esi]
	push	eax
	push	ecx
	call	_sparse_metric_dot
	jmp	SHORT $LN76@LQ_decomp
$LN20@LQ_decomp:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+ebx*4]
	push	edi
	push	edx
	push	eax
	call	_dot
$LN76@LQ_decomp:

; 1293 :         L[i][j] = t;

	mov	ecx, DWORD PTR tv2183[ebp]
	mov	edx, DWORD PTR [ecx+esi]
	add	esp, 12					; 0000000cH
	fst	QWORD PTR [edx+ebx*8]

; 1294 :         for ( k = 0 ; k < cols ; k++ )

	xor	edi, edi
	cmp	DWORD PTR _cols$[ebp], 4
	jl	SHORT $LC38@LQ_decomp
	mov	eax, DWORD PTR _Q$[ebp]
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	edi, DWORD PTR [esi]

; 1295 :           Q[i][k] -= t*Q[j][k];

	mov	ebx, ecx
	lea	edx, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR _cols$[ebp]
	add	ecx, -4					; fffffffcH
	sub	ebx, edi
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [edi+8]
	lea	edi, DWORD PTR [ecx*4]
$LN39@LQ_decomp:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	dec	ecx
	fsubr	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax+ebx-32]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN39@LQ_decomp

; 1293 :         L[i][j] = t;

	mov	ebx, DWORD PTR _j$[ebp]
$LC38@LQ_decomp:

; 1294 :         for ( k = 0 ; k < cols ; k++ )

	cmp	edi, DWORD PTR _cols$[ebp]
	jge	SHORT $LN62@LQ_decomp
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _Q$[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	lea	eax, DWORD PTR [ecx+edi*8]
	sub	edx, ecx
	mov	ecx, DWORD PTR _cols$[ebp]
	sub	ecx, edi
$LC7@LQ_decomp:

; 1295 :           Q[i][k] -= t*Q[j][k];

	fld	QWORD PTR [eax+edx]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC7@LQ_decomp
$LN62@LQ_decomp:

; 1291 :      for ( j = 0 ; j < i ; j++ )

	mov	edi, DWORD PTR _cols$[ebp]

; 1294 :         for ( k = 0 ; k < cols ; k++ )

	fstp	ST(0)
	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, DWORD PTR _i$[ebp]
	jl	$LL46@LQ_decomp
$LN45@LQ_decomp:

; 1296 :      }
; 1297 :      t = M ? sparse_metric_dot(Q[i],Q[i],M) :  dot(Q[i],Q[i],cols);

	mov	ecx, DWORD PTR _M$[ebp]
	mov	eax, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN22@LQ_decomp
	push	ecx
	push	eax
	push	eax
	call	_sparse_metric_dot
	jmp	SHORT $LN77@LQ_decomp
$LN22@LQ_decomp:
	push	edi
	push	eax
	push	eax
	call	_dot
$LN77@LQ_decomp:

; 1298 :      if ( t != 0.0 )

	fld	ST(0)
	add	esp, 12					; 0000000cH
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN75@LQ_decomp

; 1299 :      { L[i][i] = t = sqrt(t);

	call	__CIsqrt
	mov	eax, DWORD PTR tv2183[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [eax+esi]
	fst	QWORD PTR [ecx+edx*8]

; 1300 :         t = 1/t;
; 1301 :         for ( k = 0 ; k < cols ; k++ )

	xor	edx, edx
	fld1
	fdivrp	ST(1), ST(0)
	cmp	edi, 4
	jl	SHORT $LN48@LQ_decomp

; 1299 :      { L[i][i] = t = sqrt(t);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi-4]
	shr	ecx, 2
	add	eax, 16					; 00000010H
	inc	ecx
	lea	edx, DWORD PTR [ecx*4]

; 1300 :         t = 1/t;
; 1301 :         for ( k = 0 ; k < cols ; k++ )

$LN42@LQ_decomp:

; 1302 :           Q[i][k] *= t;

	fld	ST(0)
	add	eax, 32					; 00000020H
	dec	ecx
	fmul	QWORD PTR [eax-48]
	fstp	QWORD PTR [eax-48]
	fld	QWORD PTR [eax-40]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-40]
	fld	ST(0)
	fmul	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [eax-24]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN42@LQ_decomp
$LN48@LQ_decomp:

; 1300 :         t = 1/t;
; 1301 :         for ( k = 0 ; k < cols ; k++ )

	cmp	edx, edi
	jge	SHORT $LN75@LQ_decomp
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edx*8]
	sub	edi, edx
$LC3@LQ_decomp:

; 1302 :           Q[i][k] *= t;

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	edi
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC3@LQ_decomp
$LN75@LQ_decomp:

; 1285 :   REAL t;
; 1286 : 
; 1287 :   for ( i = 0 ; i < rows ; i++ )

	mov	eax, DWORD PTR _i$[ebp]

; 1300 :         t = 1/t;
; 1301 :         for ( k = 0 ; k < cols ; k++ )

	fstp	ST(0)
	inc	eax
	add	esi, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _rows$[ebp]
	jl	$LL47@LQ_decomp
	pop	edi
	pop	esi
	pop	ebx
$LN15@LQ_decomp:

; 1303 :      }
; 1304 :   }
; 1305 : } /* end LQ_decomp() */

	mov	esp, ebp
	pop	ebp
	ret	0
_LQ_decomp ENDP
_TEXT	ENDS
PUBLIC	__real@408f400000000000
PUBLIC	??_C@_0BF@MNMBIANK@QR?5residual?5?$CF20?415f?6?$AA@ ; `string'
PUBLIC	_QR_full
EXTRN	_mat_mult:PROC
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT ??_C@_0BF@MNMBIANK@QR?5residual?5?$CF20?415f?6?$AA@
CONST	SEGMENT
??_C@_0BF@MNMBIANK@QR?5residual?5?$CF20?415f?6?$AA@ DB 'QR residual %20.1'
	DB	'5f', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _QR_full
_TEXT	SEGMENT
_resid$ = -20						; size = 8
tv1098 = -12						; size = 4
_Q$ = -12						; size = 4
tv1094 = -8						; size = 4
_count$ = -8						; size = 4
tv890 = -4						; size = 4
_L$ = -4						; size = 4
_A$ = 8							; size = 4
_evalues$ = 12						; size = 4
_n$ = 16						; size = 4
_M$ = 20						; size = 4
_QR_full PROC						; COMDAT

; 1323 : { REAL **Q,**L;

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi

; 1324 :   int i,j;
; 1325 :   REAL resid;
; 1326 :   int count = 0;
; 1327 :  
; 1328 :   Q = dmatrix(0,n-1,0,n-1);

	mov	edi, DWORD PTR _n$[ebp]
	push	1328					; 00000530H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	ebx, DWORD PTR [edi-1]
	push	ebx
	push	0
	push	ebx
	push	0
	mov	DWORD PTR _count$[ebp], 0
	call	_kb_dmatrix

; 1329 :   L = dmatrix(0,n-1,0,n-1);

	push	1329					; 00000531H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	push	ebx
	push	0
	mov	esi, eax
	push	ebx
	push	0
	mov	DWORD PTR _Q$[ebp], esi
	call	_kb_dmatrix
	mov	ebx, DWORD PTR _A$[ebp]
	add	esp, 48					; 00000030H
	mov	DWORD PTR _L$[ebp], eax
	npad	2
$LL13@QR_full:

; 1330 :   do 
; 1331 :   { LQ_decomp(A,n,n,Q,L,M);

	mov	eax, DWORD PTR _M$[ebp]
	mov	ecx, DWORD PTR _L$[ebp]
	push	eax
	push	ecx
	push	esi
	push	edi
	push	edi
	push	ebx
	call	_LQ_decomp

; 1332 :      mat_mult(Q,L,A,n,n,n);

	mov	edx, DWORD PTR _L$[ebp]
	push	edi
	push	edi
	push	edi
	push	ebx
	push	edx
	push	esi
	call	_mat_mult

; 1333 :      for ( i = 0, resid = 0.0 ; i < n ; i++ )

	fldz
	add	esp, 48					; 00000030H
	fst	QWORD PTR _resid$[ebp]
	xor	edx, edx
	test	edi, edi
	jle	SHORT $LN8@QR_full
$LN30@QR_full:

; 1334 :       for ( j = 0 ; j < i ; j++ )

	xor	esi, esi
	cmp	edx, 4
	jl	SHORT $LC24@QR_full
	mov	eax, DWORD PTR [ebx+edx*4]
	lea	ecx, DWORD PTR [edx-4]
	shr	ecx, 2
	add	eax, 16					; 00000010H
	inc	ecx
	lea	esi, DWORD PTR [ecx*4]
$LN25@QR_full:

; 1335 :          resid += fabs(A[i][j]);

	fld	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	ecx
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax-40]
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax-32]
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax-24]
	fabs
	faddp	ST(1), ST(0)
	jne	SHORT $LN25@QR_full
$LC24@QR_full:

; 1334 :       for ( j = 0 ; j < i ; j++ )

	cmp	esi, edx
	jge	SHORT $LN9@QR_full
	mov	eax, DWORD PTR [ebx+edx*4]
	lea	ecx, DWORD PTR [eax+esi*8]
	mov	eax, edx
	sub	eax, esi
$LC7@QR_full:

; 1335 :          resid += fabs(A[i][j]);

	fld	QWORD PTR [ecx]
	add	ecx, 8
	dec	eax
	fabs
	faddp	ST(1), ST(0)
	jne	SHORT $LC7@QR_full
$LN9@QR_full:

; 1333 :      for ( i = 0, resid = 0.0 ; i < n ; i++ )

	inc	edx
	cmp	edx, edi
	jl	SHORT $LN30@QR_full
	mov	esi, DWORD PTR _Q$[ebp]

; 1335 :          resid += fabs(A[i][j]);

	fst	QWORD PTR _resid$[ebp]
$LN8@QR_full:

; 1336 : #ifdef FLOAT128
; 1337 :      sprintf(msg,"QR residual %*.*Qf\n",DWIDTH,DPREC,resid);
; 1338 : #elif defined(LONGDOUBLE)
; 1339 :      sprintf(msg,"QR residual %*.*Lf\n",DWIDTH,DPREC,resid);
; 1340 : #else
; 1341 :      sprintf(msg,"QR residual %20.15f\n",resid);

	mov	ecx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BF@MNMBIANK@QR?5residual?5?$CF20?415f?6?$AA@
	push	ecx
	call	_sprintf

; 1342 : #endif 
; 1343 :      outstring (msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 1344 :   } while ( (resid > 1000*machine_eps) && (count++ < 20) );

	fld	QWORD PTR _machine_eps
	fmul	QWORD PTR __real@408f400000000000
	add	esp, 20					; 00000014H
	fcomp	QWORD PTR _resid$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@QR_full
	mov	eax, DWORD PTR _count$[ebp]
	mov	ecx, eax
	inc	eax
	mov	DWORD PTR _count$[ebp], eax
	cmp	ecx, 20					; 00000014H
	jl	$LL13@QR_full
$LN4@QR_full:

; 1345 :   for ( i = 0 ; i < n ; i++ ) evalues[i] = A[i][i];

	mov	edx, DWORD PTR _evalues$[ebp]
	xor	esi, esi
	cmp	edi, 4
	jl	$LC27@QR_full
	lea	ecx, DWORD PTR [ebx+8]
	lea	eax, DWORD PTR [edx+16]
	mov	esi, 8
	sub	esi, edx
	mov	ebx, -16				; fffffff0H
	sub	ebx, edx
	lea	edx, DWORD PTR [edi-4]
	shr	edx, 2
	inc	edx
	mov	DWORD PTR tv1094[ebp], esi
	mov	DWORD PTR tv890[ebp], 16		; 00000010H
	mov	DWORD PTR tv1098[ebp], ebx
	lea	esi, DWORD PTR [edx*4]
	jmp	SHORT $LN28@QR_full
	npad	4
$LL29@QR_full:
	mov	ebx, DWORD PTR tv1098[ebp]
$LN28@QR_full:
	lea	edi, DWORD PTR [eax+ebx]
	mov	ebx, DWORD PTR [ecx-8]
	fld	QWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR [ecx-4]
	fstp	QWORD PTR [eax-16]
	add	ecx, 16					; 00000010H
	fld	QWORD PTR [ebx+edi+8]
	mov	edi, DWORD PTR [ecx-16]
	mov	ebx, DWORD PTR tv890[ebp]
	fstp	QWORD PTR [eax-8]
	fld	QWORD PTR [ebx+edi]
	mov	edi, DWORD PTR [ecx-12]
	mov	ebx, DWORD PTR tv1094[ebp]
	fstp	QWORD PTR [eax]
	add	DWORD PTR tv890[ebp], 32		; 00000020H
	add	edi, eax
	fld	QWORD PTR [edi+ebx]
	add	eax, 32					; 00000020H
	dec	edx
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LL29@QR_full
	mov	edi, DWORD PTR _n$[ebp]
	mov	ebx, DWORD PTR _A$[ebp]
	mov	edx, DWORD PTR _evalues$[ebp]
$LC27@QR_full:
	cmp	esi, edi
	jge	SHORT $LN26@QR_full
	npad	4
$LC3@QR_full:
	mov	eax, DWORD PTR [ebx+esi*4]
	fld	QWORD PTR [eax+esi*8]
	inc	esi
	fstp	QWORD PTR [edx+esi*8-8]
	cmp	esi, edi
	jl	SHORT $LC3@QR_full
$LN26@QR_full:
	pop	edi
	pop	esi
	pop	ebx

; 1346 : } /* end QR_full() */

	mov	esp, ebp
	pop	ebp
	ret	0
_QR_full ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EE@DCKAOFM@Iterations?3?5?$CFd?4?5Total?5eigenvalue@ ; `string'
PUBLIC	??_C@_0O@ICJCGDAH@?$CF3d?4?5?$CF18?413f?6?$AA@	; `string'
PUBLIC	??_C@_0BB@ELNCOLAC@?$CF3d?4?5Singular?$DP?$DP?6?$AA@ ; `string'
PUBLIC	__real@45f431e0fae6d721
PUBLIC	__real@4024000000000000
PUBLIC	??_C@_0O@BKJJHFFP@?$CF3d?4?5?$CF20?415f?6?$AA@	; `string'
PUBLIC	__real@c3abc16d674ec800
PUBLIC	??_C@_0CE@GOFIEKCK@Ritz?5dimension?5cannot?5be?5negativ@ ; `string'
PUBLIC	_do_ritz
EXTRN	_set_eigenvalue_list_global:PROC
EXTRN	_tr_mat_mul:PROC
EXTRN	_jacobi_eigenpairs:PROC
EXTRN	_mat_mul_tr:PROC
EXTRN	_augmented_hessian_flag:DWORD
EXTRN	_sp_hessian_solve_multi:PROC
EXTRN	_bk_mul:PROC
EXTRN	_breakflag:DWORD
EXTRN	_iterate_flag:DWORD
EXTRN	_realloc:PROC
EXTRN	_augmented_hessian_mode:DWORD
;	COMDAT ??_C@_0EE@DCKAOFM@Iterations?3?5?$CFd?4?5Total?5eigenvalue@
CONST	SEGMENT
??_C@_0EE@DCKAOFM@Iterations?3?5?$CFd?4?5Total?5eigenvalue@ DB 'Iteration'
	DB	's: %d. Total eigenvalue changes in last iteration: %10.8g', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ICJCGDAH@?$CF3d?4?5?$CF18?413f?6?$AA@
CONST	SEGMENT
??_C@_0O@ICJCGDAH@?$CF3d?4?5?$CF18?413f?6?$AA@ DB '%3d. %18.13f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ELNCOLAC@?$CF3d?4?5Singular?$DP?$DP?6?$AA@
CONST	SEGMENT
??_C@_0BB@ELNCOLAC@?$CF3d?4?5Singular?$DP?$DP?6?$AA@ DB '%3d. Singular??', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __real@45f431e0fae6d721
CONST	SEGMENT
__real@45f431e0fae6d721 DQ 045f431e0fae6d721r	; 1e+029
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT ??_C@_0O@BKJJHFFP@?$CF3d?4?5?$CF20?415f?6?$AA@
CONST	SEGMENT
??_C@_0O@BKJJHFFP@?$CF3d?4?5?$CF20?415f?6?$AA@ DB '%3d. %20.15f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@c3abc16d674ec800
CONST	SEGMENT
__real@c3abc16d674ec800 DQ 0c3abc16d674ec800r	; -1e+018
CONST	ENDS
;	COMDAT ??_C@_0CE@GOFIEKCK@Ritz?5dimension?5cannot?5be?5negativ@
CONST	SEGMENT
??_C@_0CE@GOFIEKCK@Ritz?5dimension?5cannot?5be?5negativ@ DB 'Ritz dimensi'
	DB	'on cannot be negative.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _do_ritz
_TEXT	SEGMENT
_diff$ = -76						; size = 8
_maxrr$ = -68						; size = 8
_rtmp$90276 = -64					; size = 4
_old_breakflag$ = -64					; size = 4
_work$ = -60						; size = 4
_evectors$ = -56					; size = 4
_Lmat$ = -52						; size = 4
tv3062 = -48						; size = 4
tv2948 = -48						; size = 4
tv2914 = -48						; size = 4
tv1184 = -48						; size = 4
tv594 = -48						; size = 4
_M$ = -44						; size = 4
_A$ = -40						; size = 4
_mw$ = -36						; size = 4
tv909 = -32						; size = 4
_iter$ = -32						; size = 4
tv1183 = -28						; size = 4
tv824 = -28						; size = 4
tv1612 = -24						; size = 4
_oldevalues$ = -20					; size = 4
_Arbasis$ = -16						; size = 4
_ritzwanted$ = -12					; size = 4
_rbasis$ = -8						; size = 4
_converged$ = -4					; size = 4
_S$ = 8							; size = 4
_lambda$ = 12						; size = 8
_ritzdim$ = 20						; size = 4
_ritzvec$ = 24						; size = 4
_do_ritz PROC						; COMDAT

; 1411 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 1412 :   int i,j;
; 1413 :   REAL **Lmat,**rbasis,**Arbasis;
; 1414 :   REAL resid;
; 1415 :   REAL **A;
; 1416 :   REAL *oldevalues;
; 1417 :   REAL **evectors;
; 1418 :   int converged; /* number of eigenvectors converged */
; 1419 :   int iter;
; 1420 :   REAL diff = 1e30,olddiff=1e30;
; 1421 :   REAL **mw;
; 1422 :   struct linsys *M; /* metric to use */
; 1423 :   REAL *work;
; 1424 :   int ritzwanted;
; 1425 :   int maxritz;
; 1426 :   int old_breakflag;
; 1427 :   REAL maxrr;
; 1428 :   vertex_id v_id;
; 1429 : 
; 1430 :   /* see if user wants extra ritz vectors */
; 1431 :   ritzwanted = ritzdim % 1000;

	mov	ecx, DWORD PTR _ritzdim$[ebp]
	fld	QWORD PTR __real@46293e5939a08cea
	mov	eax, 274877907				; 10624dd3H
	fstp	QWORD PTR _diff$[ebp]
	imul	ecx
	push	ebx
	push	edi
	sar	edx, 6
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	mov	eax, edi
	imul	eax, 1000				; 000003e8H
	sub	ecx, eax
	mov	ebx, ecx

; 1432 :   ritzdim    = (ritzdim/1000) +  ritzwanted;

	add	edi, ebx
	mov	DWORD PTR _ritzwanted$[ebp], ebx
	mov	DWORD PTR _ritzdim$[ebp], edi

; 1433 : 
; 1434 :   if ( ritzdim < 0 ) 

	jns	SHORT $LN96@do_ritz

; 1435 :     { outstring("Ritz dimension cannot be negative.\n"); return; }

	push	OFFSET ??_C@_0CE@GOFIEKCK@Ritz?5dimension?5cannot?5be?5negativ@
	call	_outstring
	add	esp, 4
	pop	edi
	pop	ebx

; 1607 : } /* end do_ritz() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN96@do_ritz:

; 1436 :   S->lambda = lambda;

	fld	QWORD PTR _lambda$[ebp]
	push	esi
	mov	esi, DWORD PTR _S$[ebp]

; 1437 :   sp_factor(S,MKL_INDEF);

	push	-2					; fffffffeH
	fstp	QWORD PTR [esi+112]
	push	esi
	call	_sp_factor

; 1438 :   (*sp_hess_project_setup_func)(S);

	push	esi
	call	DWORD PTR _sp_hess_project_setup_func

; 1439 :   sprintf(msg,"Eigencounts:    %d <,  %d ==,  %d > \n",S->neg,S->zero,S->pos);

	mov	ecx, DWORD PTR [esi+184]
	mov	edx, DWORD PTR [esi+192]
	mov	eax, DWORD PTR [esi+188]
	push	ecx
	mov	ecx, DWORD PTR _msg
	push	edx
	push	eax
	push	OFFSET ??_C@_0CG@NAMCFDKN@Eigencounts?3?5?5?5?5?$CFd?5?$DM?0?5?5?$CFd?5?$DN?$DN?0?5?5?$CF@
	push	ecx
	call	_sprintf

; 1440 :   outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 36					; 00000024H

; 1441 : 
; 1442 :   if ( ritzdim == 0 ) return;

	test	edi, edi
	je	$LN162@do_ritz

; 1443 : 
; 1444 :   maxritz = S->N - (augmented_hessian_mode ? 2 : 1)* S->CN; 

	mov	eax, DWORD PTR [esi+4]
	xor	ecx, ecx
	cmp	DWORD PTR _augmented_hessian_mode, ecx
	setne	cl
	inc	ecx
	imul	ecx, DWORD PTR [esi+148]
	sub	eax, ecx

; 1445 :   if ( ritzdim > maxritz )

	cmp	edi, eax
	jle	SHORT $LN94@do_ritz

; 1446 :     ritzdim = maxritz;

	mov	edi, eax
	mov	DWORD PTR _ritzdim$[ebp], eax
$LN94@do_ritz:

; 1447 :   if ( ritzwanted > ritzdim ) ritzwanted = ritzdim;

	cmp	ebx, edi
	jle	SHORT $LN93@do_ritz
	mov	DWORD PTR _ritzwanted$[ebp], edi
$LN93@do_ritz:

; 1448 : 
; 1449 :   /* now find near-invariant subspace by power iteration and orthog */
; 1450 :   Lmat = dmatrix(0,ritzdim-1,0,ritzdim-1); /* for QR decomp */

	push	1450					; 000005aaH
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	ebx, DWORD PTR [edi-1]
	push	ebx
	push	0
	push	ebx
	push	0
	call	_kb_dmatrix
	mov	DWORD PTR _Lmat$[ebp], eax

; 1451 :   if ( ritzvec ) rbasis = ritzvec;

	mov	eax, DWORD PTR _ritzvec$[ebp]
	add	esp, 24					; 00000018H
	test	eax, eax

; 1452 :   else

	jne	SHORT $LN268@do_ritz

; 1453 :       rbasis = dmatrix(0,ritzdim-1,0,S->N-1+S->concount);

	mov	edx, DWORD PTR [esi+144]
	mov	eax, DWORD PTR [esi+4]
	push	1453					; 000005adH
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	ecx, DWORD PTR [edx+eax-1]
	push	ecx
	push	0
	push	ebx
	push	0
	call	_kb_dmatrix
	add	esp, 24					; 00000018H
$LN268@do_ritz:

; 1454 :   Arbasis = dmatrix(0,ritzdim-1,0,S->N-1+S->concount); /* multiplied basis */

	mov	edx, DWORD PTR [esi+144]
	push	1454					; 000005aeH
	mov	DWORD PTR _rbasis$[ebp], eax
	mov	eax, DWORD PTR [esi+4]
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	ecx, DWORD PTR [edx+eax-1]
	push	ecx
	push	0
	push	ebx
	push	0
	call	_kb_dmatrix

; 1455 :   A = dmatrix(0,ritzdim-1,0,ritzdim-1);

	push	1455					; 000005afH
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	push	ebx
	push	0
	push	ebx
	push	0
	mov	DWORD PTR _Arbasis$[ebp], eax
	call	_kb_dmatrix

; 1456 :   mw = dmatrix(0,ritzdim-1,0,S->N+S->concount);

	mov	edx, DWORD PTR [esi+144]
	add	edx, DWORD PTR [esi+4]
	push	1456					; 000005b0H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	push	edx
	push	0
	push	ebx
	push	0
	mov	DWORD PTR _A$[ebp], eax
	call	_kb_dmatrix

; 1457 :   evalues = (REAL*)realloc(evalues,ritzdim*sizeof(REAL));

	mov	ecx, DWORD PTR _evalues
	mov	DWORD PTR _mw$[ebp], eax
	add	esp, 72					; 00000048H
	lea	eax, DWORD PTR [edi*8]
	push	eax
	push	ecx
	call	_realloc

; 1458 : 
; 1459 :   oldevalues = (REAL*)temp_calloc(ritzdim,sizeof(REAL));

	push	1459					; 000005b3H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	push	8
	push	edi
	mov	DWORD PTR _evalues, eax
	call	_kb_temp_calloc

; 1460 :   work = (REAL*)temp_calloc(2*S->N,sizeof(REAL));

	mov	edx, DWORD PTR [esi+4]
	push	1460					; 000005b4H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	add	edx, edx
	push	8
	push	edx
	mov	DWORD PTR _oldevalues$[ebp], eax
	call	_kb_temp_calloc
	add	esp, 40					; 00000028H
	mov	DWORD PTR _work$[ebp], eax

; 1461 :   for ( i = 0 ; i < ritzdim ; i++ ) oldevalues[i] = -1e18;  /* unlikely value */ 

	test	edi, edi
	jle	SHORT $LN90@do_ritz

; 1454 :   Arbasis = dmatrix(0,ritzdim-1,0,S->N-1+S->concount); /* multiplied basis */

	mov	esi, DWORD PTR _oldevalues$[ebp]
	fld	QWORD PTR __real@c3abc16d674ec800
	mov	ecx, DWORD PTR _ritzdim$[ebp]
	fstp	QWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx*8-5]
	lea	edi, DWORD PTR [esi+8]
	shr	ecx, 2
	rep movsd
	mov	esi, DWORD PTR _S$[ebp]
	mov	edi, DWORD PTR _ritzdim$[ebp]
$LN90@do_ritz:

; 1462 : 
; 1463 :   evectors = dmatrix(0,ritzdim-1,0,ritzdim-1);

	push	1463					; 000005b7H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	push	ebx
	push	0
	push	ebx
	push	0
	call	_kb_dmatrix
	add	esp, 24					; 00000018H
	mov	DWORD PTR _evectors$[ebp], eax

; 1464 :   /* for augmented hessian, want augmented part of rhs 0 always */
; 1465 :   for ( i = 0 ; i < ritzdim ; i++ )

	test	edi, edi
	jle	SHORT $LN158@do_ritz

; 1462 : 
; 1463 :   evectors = dmatrix(0,ritzdim-1,0,ritzdim-1);

	mov	ebx, DWORD PTR _rbasis$[ebp]
	mov	DWORD PTR tv909[ebp], edi
$LL87@do_ritz:

; 1466 :      for ( j = 0 ; j < S->A_rows ; j++ ) rbasis[i][j] = drand48() - .5;

	xor	edi, edi
	cmp	DWORD PTR [esi+12], edi
	jle	SHORT $LN86@do_ritz
$LL84@do_ritz:
	call	_drand48
	fsub	QWORD PTR __real@3fe0000000000000
	mov	eax, DWORD PTR [ebx]
	inc	edi
	fstp	QWORD PTR [eax+edi*8-8]
	cmp	edi, DWORD PTR [esi+12]
	jl	SHORT $LL84@do_ritz
$LN86@do_ritz:

; 1464 :   /* for augmented hessian, want augmented part of rhs 0 always */
; 1465 :   for ( i = 0 ; i < ritzdim ; i++ )

	add	ebx, 4
	dec	DWORD PTR tv909[ebp]
	jne	SHORT $LL87@do_ritz
$LN158@do_ritz:
	xor	eax, eax

; 1467 :   iter = 0;

	mov	DWORD PTR _iter$[ebp], eax

; 1468 :   converged = 0;

	mov	DWORD PTR _converged$[ebp], eax

; 1469 :   iterate_flag = 1; /* for politer interrupt message */

	mov	DWORD PTR _iterate_flag, 1

; 1470 :   if ( web.area_norm_flag || hessian_linear_metric_flag ) M =  &Met;

	cmp	DWORD PTR _web+876, eax
	jne	SHORT $LN80@do_ritz

; 1471 :   else M = NULL;

	mov	DWORD PTR _M$[ebp], eax
	cmp	DWORD PTR _hessian_linear_metric_flag, eax
	je	SHORT $LN79@do_ritz
$LN80@do_ritz:

; 1470 :   if ( web.area_norm_flag || hessian_linear_metric_flag ) M =  &Met;

	mov	DWORD PTR _M$[ebp], OFFSET _Met
$LN79@do_ritz:

; 1472 :   old_breakflag = breakflag;

	mov	ecx, DWORD PTR _breakflag
	mov	ebx, DWORD PTR _S$[ebp]
	mov	DWORD PTR _old_breakflag$[ebp], ecx
	jmp	SHORT $LN78@do_ritz
$LL198@do_ritz:
	fstp	ST(0)
$LN78@do_ritz:

; 1473 :   do
; 1474 :   {
; 1475 :     if ( web.area_norm_flag || hessian_linear_metric_flag )

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN74@do_ritz
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN74@do_ritz

; 1480 :     }
; 1481 :     else sp_hessian_solve_multi(S,rbasis+converged,Arbasis+converged,
; 1482 :           ritzdim-converged);

	mov	edi, DWORD PTR _converged$[ebp]
	mov	esi, DWORD PTR _ritzdim$[ebp]
	mov	edx, DWORD PTR _Arbasis$[ebp]
	sub	esi, edi
	lea	eax, DWORD PTR [edx+edi*4]
	push	esi
	mov	DWORD PTR tv1183[ebp], eax
	push	eax
	mov	eax, DWORD PTR _rbasis$[ebp]
	jmp	SHORT $LN269@do_ritz
$LN74@do_ritz:

; 1476 :     { for ( i = converged ; i < ritzdim ; i++ )

	mov	edi, DWORD PTR _converged$[ebp]
	mov	eax, DWORD PTR _ritzdim$[ebp]
	cmp	edi, eax
	jge	SHORT $LN156@do_ritz
	mov	edx, DWORD PTR _rbasis$[ebp]
	mov	ecx, DWORD PTR _mw$[ebp]
	sub	ecx, edx
	sub	eax, edi
	lea	esi, DWORD PTR [edx+edi*4]
	mov	DWORD PTR tv1612[ebp], ecx
	mov	DWORD PTR tv824[ebp], eax
	npad	6
$LL73@do_ritz:

; 1477 :         bk_mul(&Met,rbasis[i],mw[i]);

	mov	edx, DWORD PTR tv1612[ebp]
	mov	eax, DWORD PTR [edx+esi]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	push	OFFSET _Met
	call	_bk_mul
	add	esp, 12					; 0000000cH
	add	esi, 4
	dec	DWORD PTR tv824[ebp]
	jne	SHORT $LL73@do_ritz
$LN156@do_ritz:

; 1478 :       sp_hessian_solve_multi(S,mw+converged,Arbasis+converged,
; 1479 :          ritzdim-converged);

	mov	esi, DWORD PTR _ritzdim$[ebp]
	mov	edx, DWORD PTR _Arbasis$[ebp]
	sub	esi, edi
	lea	eax, DWORD PTR [edx+edi*4]
	push	esi
	mov	DWORD PTR tv1183[ebp], eax
	push	eax
	mov	eax, DWORD PTR _mw$[ebp]
$LN269@do_ritz:
	lea	ecx, DWORD PTR [eax+edi*4]
	push	ecx
	push	ebx
	call	_sp_hessian_solve_multi
	add	esp, 16					; 00000010H

; 1483 :     if  ( augmented_hessian_mode )

	cmp	DWORD PTR _augmented_hessian_mode, 0
	je	SHORT $LN157@do_ritz

; 1484 :     { /* set augmented part to 0 */
; 1485 :       for ( i = converged ; i < ritzdim ; i++ )

	mov	edx, edi
	cmp	edi, DWORD PTR _ritzdim$[ebp]
	jge	SHORT $LN157@do_ritz
	fldz
$LN68@do_ritz:

; 1486 :         for ( j = S->A_rows ; j < S->N ; j++ )

	mov	eax, DWORD PTR [ebx+12]
	cmp	eax, DWORD PTR [ebx+4]
	jge	SHORT $LN67@do_ritz
	mov	ecx, DWORD PTR _Arbasis$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	lea	ecx, DWORD PTR [ecx+eax*8]
$LN65@do_ritz:

; 1487 :           Arbasis[i][j] = 0.0;

	fst	QWORD PTR [ecx]
	inc	eax
	add	ecx, 8
	cmp	eax, DWORD PTR [ebx+4]
	jl	SHORT $LN65@do_ritz
$LN67@do_ritz:

; 1484 :     { /* set augmented part to 0 */
; 1485 :       for ( i = converged ; i < ritzdim ; i++ )

	inc	edx
	cmp	edx, DWORD PTR _ritzdim$[ebp]
	jl	SHORT $LN68@do_ritz
	fstp	ST(0)
$LN157@do_ritz:

; 1488 :     }
; 1489 :     LQ_decomp(Arbasis,ritzdim,S->A_rows,rbasis,Lmat,M);

	mov	edx, DWORD PTR _M$[ebp]
	mov	eax, DWORD PTR _Lmat$[ebp]
	mov	ecx, DWORD PTR _rbasis$[ebp]
	push	edx
	mov	edx, DWORD PTR [ebx+12]
	push	eax
	mov	eax, DWORD PTR _ritzdim$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _Arbasis$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_LQ_decomp

; 1490 :     iter ++;

	inc	DWORD PTR _iter$[ebp]
	add	esp, 24					; 00000018H

; 1491 :     /* add up off-diagonal residuals */
; 1492 :     for ( i = 0, resid = 0.0 ; i < ritzdim ; i++ )
; 1493 :       for ( j = 0 ; j < i ; j++ )
; 1494 :         resid += fabs(Lmat[i][j]);
; 1495 : 
; 1496 :     /* get matrix in Rayleigh-Ritz subspace */
; 1497 :     for ( i = converged ; i < ritzdim ; i++ )

	cmp	edi, DWORD PTR _ritzdim$[ebp]
	jge	SHORT $LN54@do_ritz
	mov	edx, DWORD PTR _rbasis$[ebp]
	mov	ecx, DWORD PTR _mw$[ebp]
	mov	eax, DWORD PTR _converged$[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv1612[ebp], ecx
	mov	ecx, DWORD PTR _ritzdim$[ebp]
	sub	ecx, eax
	lea	edi, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv594[ebp], ecx
$LL56@do_ritz:

; 1498 :     { if ( web.area_norm_flag || hessian_linear_metric_flag )

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN52@do_ritz
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN55@do_ritz
$LN52@do_ritz:

; 1499 :       { bk_mul(&Met,rbasis[i],mw[i]);

	mov	edx, DWORD PTR tv1612[ebp]
	mov	eax, DWORD PTR [edi+edx]
	mov	ecx, DWORD PTR [edi]
	push	eax
	push	ecx
	push	OFFSET _Met
	call	_bk_mul

; 1500 :         memcpy((char*)(rbasis[i]),(char*)(mw[i]),Met.N*sizeof(REAL));

	mov	edx, DWORD PTR _Met+4
	mov	ecx, DWORD PTR tv1612[ebp]
	lea	eax, DWORD PTR [edx*8]
	mov	edx, DWORD PTR [edi+ecx]
	push	eax
	mov	eax, DWORD PTR [edi]
	push	edx
	push	eax
	call	_memcpy
	add	esp, 24					; 00000018H
$LN55@do_ritz:

; 1491 :     /* add up off-diagonal residuals */
; 1492 :     for ( i = 0, resid = 0.0 ; i < ritzdim ; i++ )
; 1493 :       for ( j = 0 ; j < i ; j++ )
; 1494 :         resid += fabs(Lmat[i][j]);
; 1495 : 
; 1496 :     /* get matrix in Rayleigh-Ritz subspace */
; 1497 :     for ( i = converged ; i < ritzdim ; i++ )

	add	edi, 4
	dec	DWORD PTR tv594[ebp]
	jne	SHORT $LL56@do_ritz
	mov	edi, DWORD PTR _converged$[ebp]
$LN54@do_ritz:

; 1501 :       }
; 1502 :     }
; 1503 :     sp_hessian_solve_multi(S,rbasis+converged,Arbasis+converged,
; 1504 :               ritzdim-converged);

	mov	ecx, DWORD PTR _rbasis$[ebp]
	mov	edx, DWORD PTR tv1183[ebp]
	push	esi
	lea	eax, DWORD PTR [ecx+edi*4]
	push	edx
	push	eax
	push	ebx
	mov	DWORD PTR tv1184[ebp], eax
	call	_sp_hessian_solve_multi
	add	esp, 16					; 00000010H

; 1505 :     if ( augmented_hessian_flag )

	cmp	DWORD PTR _augmented_hessian_flag, 0
	je	SHORT $LN48@do_ritz

; 1506 :     { /* set augmented part to 0 */
; 1507 :       for ( i = converged ; i < ritzdim ; i++ )

	cmp	edi, DWORD PTR _ritzdim$[ebp]
	jge	SHORT $LN48@do_ritz
	fldz
	mov	edx, DWORD PTR _Arbasis$[ebp]
$LN50@do_ritz:

; 1508 :         for ( j = S->A_rows ; j < S->N ; j++ )

	mov	eax, DWORD PTR [ebx+12]
	cmp	eax, DWORD PTR [ebx+4]
	jge	SHORT $LN49@do_ritz
	mov	ecx, DWORD PTR [edx+edi*4]
	lea	ecx, DWORD PTR [ecx+eax*8]
$LN47@do_ritz:

; 1509 :           Arbasis[i][j] = 0.0;

	fst	QWORD PTR [ecx]
	inc	eax
	add	ecx, 8
	cmp	eax, DWORD PTR [ebx+4]
	jl	SHORT $LN47@do_ritz
$LN49@do_ritz:

; 1506 :     { /* set augmented part to 0 */
; 1507 :       for ( i = converged ; i < ritzdim ; i++ )

	inc	edi
	cmp	edi, DWORD PTR _ritzdim$[ebp]
	jl	SHORT $LN50@do_ritz
	fstp	ST(0)
$LN48@do_ritz:

; 1510 :     }
; 1511 :     mat_mul_tr(rbasis+converged,Arbasis+converged,A,ritzdim-converged,
; 1512 :                       S->A_rows,ritzdim-converged);

	mov	edx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR _A$[ebp]
	mov	ecx, DWORD PTR tv1183[ebp]
	push	esi
	push	edx
	mov	edx, DWORD PTR tv1184[ebp]
	push	esi
	push	eax
	push	ecx
	push	edx
	call	_mat_mul_tr

; 1513 :     jacobi_eigenpairs(A,ritzdim-converged,evalues+converged,evectors+converged,work);

	mov	ecx, DWORD PTR _converged$[ebp]
	mov	eax, DWORD PTR _evectors$[ebp]
	mov	edx, DWORD PTR _work$[ebp]
	push	edx
	lea	edi, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _evalues
	push	edi
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _A$[ebp]
	push	edx
	push	esi
	push	eax
	call	_jacobi_eigenpairs

; 1514 :     msg[0] = 0 ;

	mov	ecx, DWORD PTR _msg

; 1515 : 
; 1516 :     /* get eigenvector basis for subspace */
; 1517 :     tr_mat_mul(evectors+converged,Arbasis+converged,rbasis+converged,
; 1518 :          ritzdim-converged,ritzdim-converged,S->A_rows);

	mov	eax, DWORD PTR tv1184[ebp]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR tv1183[ebp]
	push	edx
	push	esi
	push	esi
	push	eax
	push	ecx
	push	edi
	call	_tr_mat_mul

; 1519 : 
; 1520 :     for ( i = converged ; i < ritzdim ; i++ )

	mov	edi, DWORD PTR _converged$[ebp]
	add	esp, 68					; 00000044H
	cmp	edi, DWORD PTR _ritzdim$[ebp]
	jge	SHORT $LN149@do_ritz
$LL44@do_ritz:
	mov	esi, DWORD PTR _evalues

; 1521 :       if ( evalues[i] == oldevalues[i] )

	fld	QWORD PTR [esi+edi*8]
	mov	edx, DWORD PTR _oldevalues$[ebp]
	fld	QWORD PTR [edx+edi*8]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN41@do_ritz

; 1522 :       { converged++;
; 1523 : #ifdef FLOAT128
; 1524 :         sprintf(msg,"%3d. %*.*Qf\n",converged,DWIDTH,DPREC,1/evalues[i]+lambda);
; 1525 : #elif defined(LONGDOUBLE)
; 1526 :         sprintf(msg,"%3d. %*.*Lf\n",converged,DWIDTH,DPREC,1/evalues[i]+lambda);
; 1527 : #else
; 1528 :         sprintf(msg,"%3d. %20.15f\n",converged,1/evalues[i]+lambda);

	fld1
	mov	eax, DWORD PTR _converged$[ebp]
	fdiv	QWORD PTR [esi+edi*8]
	sub	esp, 8
	inc	eax
	mov	DWORD PTR _converged$[ebp], eax
	fadd	QWORD PTR _lambda$[ebp]
	fstp	QWORD PTR [esp]
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0O@BKJJHFFP@?$CF3d?4?5?$CF20?415f?6?$AA@
	push	eax
	call	_sprintf

; 1529 : #endif 
; 1530 :         outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	inc	edi
	add	esp, 24					; 00000018H
	cmp	edi, DWORD PTR _ritzdim$[ebp]
	jl	SHORT $LL44@do_ritz
$LN149@do_ritz:

; 1519 : 
; 1520 :     for ( i = converged ; i < ritzdim ; i++ )

	mov	esi, DWORD PTR _evalues
$LN41@do_ritz:

; 1531 :       }
; 1532 :       else break; 
; 1533 :     olddiff = diff;

	fld	QWORD PTR _diff$[ebp]

; 1534 :     for ( diff = 0.0 ; i < ritzwanted ; i++ )

	fldz
	fld	ST(0)
	fst	QWORD PTR _diff$[ebp]
	cmp	edi, DWORD PTR _ritzwanted$[ebp]
	jge	$LN77@do_ritz
	mov	edx, DWORD PTR _ritzwanted$[ebp]
	sub	edx, edi
	cmp	edx, 4
	jl	SHORT $LC141@do_ritz

; 1536 :       oldevalues[i] = evalues[i];

	mov	edx, DWORD PTR _oldevalues$[ebp]
	lea	eax, DWORD PTR [edx+edi*8+8]
	lea	ecx, DWORD PTR [esi+edi*8+24]
	sub	esi, edx
	mov	edx, DWORD PTR _ritzwanted$[ebp]
	sub	edx, edi
	sub	edx, 4
	shr	edx, 2
	inc	edx
	lea	edi, DWORD PTR [edi+edx*4]
$LN142@do_ritz:
	fld	QWORD PTR [ecx-24]
	add	eax, 32					; 00000020H
	fsub	QWORD PTR [eax-40]
	add	ecx, 32					; 00000020H
	dec	edx
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-56]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [esi+eax-32]
	fsub	QWORD PTR [eax-32]
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi+eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx-40]
	fsub	QWORD PTR [eax-24]
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-40]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [ecx-32]
	fsub	QWORD PTR [eax-16]
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-32]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN142@do_ritz
	mov	esi, DWORD PTR _evalues
	fst	QWORD PTR _diff$[ebp]
$LC141@do_ritz:

; 1534 :     for ( diff = 0.0 ; i < ritzwanted ; i++ )

	mov	ecx, DWORD PTR _ritzwanted$[ebp]
	cmp	edi, ecx
	jge	SHORT $LN77@do_ritz
	mov	edx, DWORD PTR _oldevalues$[ebp]
	sub	esi, edx
	lea	eax, DWORD PTR [edx+edi*8]
	sub	ecx, edi
$LC39@do_ritz:

; 1535 :     { diff += fabs(evalues[i] - oldevalues[i]);

	fld	QWORD PTR [esi+eax]
	add	eax, 8
	dec	ecx
	fsub	QWORD PTR [eax-8]
	fabs
	faddp	ST(1), ST(0)

; 1536 :       oldevalues[i] = evalues[i];

	fld	QWORD PTR [esi+eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC39@do_ritz

; 1535 :     { diff += fabs(evalues[i] - oldevalues[i]);

	mov	esi, DWORD PTR _evalues
	fst	QWORD PTR _diff$[ebp]
$LN77@do_ritz:

; 1537 :     }
; 1538 : 
; 1539 :   } while ( (iter<1000) && ((diff < olddiff)||(diff > 10*S->N*machine_eps))
; 1540 :        && (diff > 100*machine_eps) && !breakflag );

	cmp	DWORD PTR _iter$[ebp], 1000		; 000003e8H
	jge	SHORT $LN195@do_ritz
	fcom	ST(2)
	fnstsw	ax
	fstp	ST(2)
	fld	QWORD PTR _machine_eps
	test	ah, 5
	jnp	SHORT $LN35@do_ritz
	mov	eax, DWORD PTR [ebx+4]
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	mov	DWORD PTR tv2948[ebp], eax
	fild	DWORD PTR tv2948[ebp]
	fmul	ST(0), ST(1)
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN195@do_ritz
$LN35@do_ritz:
	fmul	QWORD PTR __real@4059000000000000
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN36@do_ritz
	cmp	DWORD PTR _breakflag, 0
	je	$LL198@do_ritz
	jmp	SHORT $LN36@do_ritz
$LN195@do_ritz:
	fstp	ST(0)
	fstp	ST(1)
$LN36@do_ritz:

; 1541 :   breakflag = old_breakflag;

	mov	ecx, DWORD PTR _old_breakflag$[ebp]

; 1542 : 
; 1543 :   /* normalize eigenvectors so largest component is 1/10 size of surface */
; 1544 :   maxrr = 0.0; 

	fst	QWORD PTR _maxrr$[ebp]

; 1545 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	DWORD PTR _breakflag, ecx
	test	eax, 268435456				; 10000000H
	je	SHORT $LN32@do_ritz
$LN34@do_ritz:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN33@do_ritz

; 1546 :   { REAL *x = get_coord(v_id);

	mov	eax, DWORD PTR _web+104
	fstp	ST(0)
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+64]
	add	eax, ecx

; 1547 :     REAL rr = SDIM_dot(x,x);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	push	eax
	push	eax
	call	_dot

; 1548 :     if ( rr > maxrr ) maxrr = rr;

	fld	QWORD PTR _maxrr$[ebp]
	fcom	ST(1)
	add	esp, 12					; 0000000cH
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN266@do_ritz
	fstp	ST(0)
	fst	QWORD PTR _maxrr$[ebp]
	jmp	SHORT $LN33@do_ritz
$LN266@do_ritz:
	fstp	ST(1)
$LN33@do_ritz:

; 1545 :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN34@do_ritz
	mov	esi, DWORD PTR _evalues
$LN32@do_ritz:

; 1549 :   }
; 1550 :   maxrr = sqrt(maxrr)/10;

	call	__CIsqrt
	fdiv	QWORD PTR __real@4024000000000000

; 1551 :   for ( i = 0 ; i < ritzdim ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _ritzdim$[ebp], edi
	jle	SHORT $LN207@do_ritz
	fldz
$LN161@do_ritz:

; 1554 :     for ( j = 0 ; j < S->A_rows ; j++ )

	mov	esi, DWORD PTR [ebx+12]
	fld	ST(0)
	test	esi, esi
	jle	SHORT $LN23@do_ritz

; 1552 :   { REAL mag;
; 1553 :     REAL big = 0.0;

	mov	ecx, DWORD PTR _rbasis$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	edx, esi
$LN25@do_ritz:

; 1555 :       if ( fabs(rbasis[i][j]) > big )

	fld	QWORD PTR [ecx]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN215@do_ritz

; 1556 :         big = fabs(rbasis[i][j]);

	fstp	ST(1)
	jmp	SHORT $LN24@do_ritz
$LN215@do_ritz:
	fstp	ST(0)
$LN24@do_ritz:

; 1554 :     for ( j = 0 ; j < S->A_rows ; j++ )

	add	ecx, 8
	dec	edx
	jne	SHORT $LN25@do_ritz
$LN23@do_ritz:

; 1557 :      mag = maxrr/big;
; 1558 :      for ( j = 0 ; j < S->A_rows ; j++ ) rbasis[i][j] *= mag;

	xor	ecx, ecx
	fdivr	ST(0), ST(2)
	test	esi, esi
	jle	SHORT $LN221@do_ritz

; 1551 :   for ( i = 0 ; i < ritzdim ; i++ )

	mov	edx, DWORD PTR _rbasis$[ebp]
	mov	eax, DWORD PTR [edx+edi*4]
$LN21@do_ritz:

; 1557 :      mag = maxrr/big;
; 1558 :      for ( j = 0 ; j < S->A_rows ; j++ ) rbasis[i][j] *= mag;

	fld	ST(0)
	inc	ecx
	fmul	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [ebx+12]
	jl	SHORT $LN21@do_ritz
$LN221@do_ritz:

; 1551 :   for ( i = 0 ; i < ritzdim ; i++ )

	inc	edi

; 1557 :      mag = maxrr/big;
; 1558 :      for ( j = 0 ; j < S->A_rows ; j++ ) rbasis[i][j] *= mag;

	fstp	ST(0)
	cmp	edi, DWORD PTR _ritzdim$[ebp]
	jl	SHORT $LN161@do_ritz

; 1551 :   for ( i = 0 ; i < ritzdim ; i++ )

	mov	esi, DWORD PTR _evalues
	fstp	ST(1)
	jmp	SHORT $LN26@do_ritz
$LN207@do_ritz:
	fstp	ST(0)
	fldz
$LN26@do_ritz:

; 1559 :   }
; 1560 : 
; 1561 :   /* list, ones near probe value */
; 1562 :   
; 1563 :   /* convert and insertion sort */
; 1564 :   for ( i = 0 ; i < ritzwanted ; i++ )

	xor	ebx, ebx
	cmp	DWORD PTR _ritzwanted$[ebp], ebx
	jle	$LN226@do_ritz
	mov	ecx, DWORD PTR _converged$[ebp]
	fld1
	fld	QWORD PTR __real@46293e5939a08cea
	neg	ecx
	fld	QWORD PTR _lambda$[ebp]
	mov	DWORD PTR tv2914[ebp], ecx
$LN18@do_ritz:

; 1565 :   { REAL eig;
; 1566 :      REAL *rtmp;
; 1567 :      if ( evalues[i] == 0.0 ) eig = 1e30;

	fld	QWORD PTR [esi+ebx*8]
	fld	ST(4)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@do_ritz
	fld	ST(1)
	jmp	SHORT $LN14@do_ritz
$LN15@do_ritz:

; 1568 :      else eig = 1/evalues[i] + lambda;

	fld	ST(2)
	fdiv	QWORD PTR [esi+ebx*8]
	fadd	ST(0), ST(1)
$LN14@do_ritz:

; 1569 :      rtmp = rbasis[i];

	mov	eax, DWORD PTR _rbasis$[ebp]
	mov	edx, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _rtmp$90276[ebp], edx

; 1570 :      for ( j = i ; j > converged ; j-- )

	mov	edx, ebx
	cmp	ebx, DWORD PTR _converged$[ebp]
	jle	$LN159@do_ritz
	cmp	ecx, 4
	jl	$LC143@do_ritz

; 1572 :         { evalues[j] = evalues[j-1]; rbasis[j] = rbasis[j-1]; }

	lea	ecx, DWORD PTR [ebx*8-16]
	lea	edi, DWORD PTR [eax+ebx*4-8]
$LN147@do_ritz:

; 1571 :      { if ( evalues[j-1] > eig ) 

	fcom	QWORD PTR [ecx+esi+8]
	fnstsw	ax
	test	ah, 5
	jp	$LN159@do_ritz

; 1572 :         { evalues[j] = evalues[j-1]; rbasis[j] = rbasis[j-1]; }

	fld	QWORD PTR [ecx+esi+8]
	mov	eax, DWORD PTR [edi+4]
	fstp	QWORD PTR [ecx+esi+16]
	mov	DWORD PTR [edi+8], eax
	mov	esi, DWORD PTR _evalues
	fcom	QWORD PTR [ecx+esi]
	fnstsw	ax
	test	ah, 5
	jp	$LN144@do_ritz
	fld	QWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [edi]
	fstp	QWORD PTR [ecx+esi+8]
	mov	DWORD PTR [edi+4], eax
	mov	esi, DWORD PTR _evalues
	fcom	QWORD PTR [ecx+esi-8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN145@do_ritz
	fld	QWORD PTR [ecx+esi-8]
	mov	eax, DWORD PTR [edi-4]
	fstp	QWORD PTR [ecx+esi]
	mov	DWORD PTR [edi], eax
	mov	esi, DWORD PTR _evalues
	fcom	QWORD PTR [ecx+esi-16]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN146@do_ritz
	mov	eax, DWORD PTR [edi-8]
	fld	QWORD PTR [ecx+esi-16]
	mov	DWORD PTR [edi-4], eax
	fstp	QWORD PTR [ecx+esi-8]
	mov	eax, DWORD PTR _converged$[ebp]
	mov	esi, DWORD PTR _evalues
	sub	edx, 4
	add	eax, 3
	sub	ecx, 32					; 00000020H
	sub	edi, 16					; 00000010H
	cmp	edx, eax
	jg	$LN147@do_ritz
$LC143@do_ritz:

; 1570 :      for ( j = i ; j > converged ; j-- )

	cmp	edx, DWORD PTR _converged$[ebp]
	jle	SHORT $LN159@do_ritz
	mov	ecx, DWORD PTR _rbasis$[ebp]
	mov	edi, DWORD PTR _converged$[ebp]
$LC13@do_ritz:

; 1571 :      { if ( evalues[j-1] > eig ) 

	fcom	QWORD PTR [esi+edx*8-8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN159@do_ritz

; 1572 :         { evalues[j] = evalues[j-1]; rbasis[j] = rbasis[j-1]; }

	fld	QWORD PTR [esi+edx*8-8]
	mov	eax, DWORD PTR [ecx+edx*4-4]
	fstp	QWORD PTR [esi+edx*8]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	esi, DWORD PTR _evalues
	dec	edx
	cmp	edx, edi
	jg	SHORT $LC13@do_ritz
	jmp	SHORT $LN159@do_ritz
$LN144@do_ritz:

; 1571 :      { if ( evalues[j-1] > eig ) 

	dec	edx
	jmp	SHORT $LN159@do_ritz
$LN145@do_ritz:
	sub	edx, 2
	jmp	SHORT $LN159@do_ritz
$LN146@do_ritz:
	sub	edx, 3
$LN159@do_ritz:

; 1573 :         else break;
; 1574 :      }
; 1575 :      evalues[j] = eig;
; 1576 :      rbasis[j] = rtmp;

	mov	ecx, DWORD PTR _rbasis$[ebp]
	fstp	QWORD PTR [esi+edx*8]
	mov	eax, DWORD PTR _rtmp$90276[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR tv2914[ebp]
	mov	esi, DWORD PTR _evalues
	inc	ebx
	inc	ecx
	mov	DWORD PTR tv2914[ebp], ecx
	cmp	ebx, DWORD PTR _ritzwanted$[ebp]
	jl	$LN18@do_ritz

; 1559 :   }
; 1560 : 
; 1561 :   /* list, ones near probe value */
; 1562 :   
; 1563 :   /* convert and insertion sort */
; 1564 :   for ( i = 0 ; i < ritzwanted ; i++ )

	fstp	ST(2)
	fstp	ST(1)
	fstp	ST(0)
$LN226@do_ritz:

; 1577 :   }
; 1578 : 
; 1579 :   for ( i = converged ; i < ritzwanted ; i++ )

	mov	ecx, DWORD PTR _converged$[ebp]
	fstp	ST(0)
	cmp	ecx, DWORD PTR _ritzwanted$[ebp]
	jge	$LN6@do_ritz
	mov	eax, ecx
	mov	ecx, DWORD PTR _ritzwanted$[ebp]
	sub	ecx, eax
	lea	ebx, DWORD PTR [eax+1]
	lea	edi, DWORD PTR [eax*8]
	mov	DWORD PTR tv3062[ebp], ecx
	jmp	SHORT $LN8@do_ritz
	npad	7
$LL154@do_ritz:
	mov	esi, DWORD PTR _evalues
$LN8@do_ritz:

; 1580 :   { if ( evalues[i] > 1e29 ) sprintf(msg,"%3d. Singular??\n",i+1);

	fld	QWORD PTR __real@45f431e0fae6d721
	fcomp	QWORD PTR [edi+esi]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN5@do_ritz
	mov	edx, DWORD PTR _msg
	push	ebx
	push	OFFSET ??_C@_0BB@ELNCOLAC@?$CF3d?4?5Singular?$DP?$DP?6?$AA@
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN4@do_ritz
$LN5@do_ritz:

; 1581 : #ifdef FLOAT128
; 1582 :      else sprintf(msg,"%3d. %*.*Qf\n",i+1,DWIDTH,DPREC,evalues[i]);
; 1583 : #elif defined(LONGDOUBLE)
; 1584 :      else sprintf(msg,"%3d. %*.*Lf\n",i+1,DWIDTH,DPREC,evalues[i]);
; 1585 : #else
; 1586 :      else sprintf(msg,"%3d. %18.13f\n",i+1,evalues[i]);

	fld	QWORD PTR [edi+esi]
	mov	eax, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ebx
	push	OFFSET ??_C@_0O@ICJCGDAH@?$CF3d?4?5?$CF18?413f?6?$AA@
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H
$LN4@do_ritz:

; 1587 : #endif 
; 1588 :      outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 4
	add	edi, 8
	inc	ebx
	dec	DWORD PTR tv3062[ebp]
	jne	SHORT $LL154@do_ritz
$LN6@do_ritz:

; 1589 :   }
; 1590 :   sprintf(msg,
; 1591 :      "Iterations: %d. Total eigenvalue changes in last iteration: %10.8g\n",
; 1592 :         iter,(DOUBLE)diff);

	fld	QWORD PTR _diff$[ebp]
	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	push	OFFSET ??_C@_0EE@DCKAOFM@Iterations?3?5?$CFd?4?5Total?5eigenvalue@
	push	eax
	call	_sprintf

; 1593 :   outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring

; 1594 :   if ( (S->zero != 0) && (S->neg == 0)) last_eigenvalue = S->lambda;

	mov	eax, DWORD PTR _S$[ebp]
	mov	ecx, DWORD PTR _evalues
	add	esp, 24					; 00000018H
	cmp	DWORD PTR [eax+192], 0
	je	SHORT $LN3@do_ritz
	cmp	DWORD PTR [eax+188], 0
	jne	SHORT $LN3@do_ritz
	fld	QWORD PTR [eax+112]

; 1595 :   else

	jmp	SHORT $LN270@do_ritz
$LN3@do_ritz:

; 1596 :   last_eigenvalue = evalues[0];

	fld	QWORD PTR [ecx]
$LN270@do_ritz:

; 1597 :   set_eigenvalue_list_global(evalues,ritzdim);

	mov	edx, DWORD PTR _ritzdim$[ebp]
	fstp	QWORD PTR _last_eigenvalue
	push	edx
	push	ecx
	call	_set_eigenvalue_list_global

; 1598 : 
; 1599 :   free_matrix(Lmat);

	mov	eax, DWORD PTR _Lmat$[ebp]
	push	eax
	call	_free_matrix

; 1600 :   free_matrix(A);

	mov	ecx, DWORD PTR _A$[ebp]
	push	ecx
	call	_free_matrix
	add	esp, 16					; 00000010H

; 1601 :   if ( ritzvec == NULL ) free_matrix(rbasis);

	cmp	DWORD PTR _ritzvec$[ebp], 0
	jne	SHORT $LN1@do_ritz
	mov	edx, DWORD PTR _rbasis$[ebp]
	push	edx
	call	_free_matrix
	add	esp, 4
$LN1@do_ritz:

; 1602 :   free_matrix(Arbasis);

	mov	eax, DWORD PTR _Arbasis$[ebp]
	push	eax
	call	_free_matrix

; 1603 :   free_matrix(evectors);

	mov	ecx, DWORD PTR _evectors$[ebp]
	push	ecx
	call	_free_matrix

; 1604 :   temp_free((char*)oldevalues);

	mov	edx, DWORD PTR _oldevalues$[ebp]
	push	edx
	call	_temp_free

; 1605 :   temp_free((char*)work);

	mov	eax, DWORD PTR _work$[ebp]
	push	eax
	call	_temp_free

; 1606 :   free_matrix(mw);

	mov	ecx, DWORD PTR _mw$[ebp]
	push	ecx
	call	_free_matrix
	add	esp, 20					; 00000014H
$LN162@do_ritz:
	pop	esi
	pop	edi
	pop	ebx

; 1607 : } /* end do_ritz() */

	mov	esp, ebp
	pop	ebp
	ret	0
_do_ritz ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@NKNMFOPA@premature?5subdiag?5?$DN?50?6?$AA@ ; `string'
PUBLIC	_lanczos
EXTRN	_qsort:PROC
;	COMDAT ??_C@_0BH@NKNMFOPA@premature?5subdiag?5?$DN?50?6?$AA@
CONST	SEGMENT
??_C@_0BH@NKNMFOPA@premature?5subdiag?5?$DN?50?6?$AA@ DB 'premature subdi'
	DB	'ag = 0', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _lanczos
_TEXT	SEGMENT
tv1393 = -28						; size = 4
tv617 = -28						; size = 4
_i$ = -28						; size = 4
_r$ = -24						; size = 4
_mw$ = -20						; size = 4
_subdiag$ = -16						; size = 4
_j$ = -12						; size = 4
_diag$ = -8						; size = 4
_w$ = -4						; size = 4
_v$ = 8							; size = 4
_S$ = 8							; size = 4
_krydim$ = 12						; size = 4
_evalues$ = 16						; size = 4
_nprint$ = 20						; size = 4
_lanczos PROC						; COMDAT

; 986  : { REAL *diag;  /* main diagonal of tridiagonal */

	push	ebp
	mov	ebp, esp

; 987  :   REAL *subdiag;    /* subdiagonal */
; 988  :   REAL *v,*w,*mw;    /* working vectors; w is Lanczos vector  */
; 989  :   REAL *r;
; 990  :   REAL t;      /* temp */
; 991  :   int i,j;
; 992  : 
; 993  :   if ( krydim > S->N-S->CN ) krydim = S->N-S->CN;

	mov	ecx, DWORD PTR _krydim$[ebp]
	sub	esp, 28					; 0000001cH
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+4]
	sub	eax, DWORD PTR [esi+148]
	cmp	ecx, eax
	jle	SHORT $LN50@lanczos
	mov	ecx, eax
	mov	DWORD PTR _krydim$[ebp], ecx
$LN50@lanczos:

; 994  :   if ( nprint > krydim ) nprint = krydim;

	cmp	DWORD PTR _nprint$[ebp], ecx
	jle	SHORT $LN49@lanczos
	mov	DWORD PTR _nprint$[ebp], ecx
$LN49@lanczos:
	push	ebx
	push	edi

; 995  : 
; 996  :   diag = (REAL *)temp_calloc(krydim+1,sizeof(REAL));

	mov	edi, DWORD PTR _krydim$[ebp]
	push	996					; 000003e4H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	inc	edi
	push	8
	push	edi
	call	_kb_temp_calloc

; 997  :   subdiag = (REAL *)temp_calloc(krydim+1,sizeof(REAL));

	push	997					; 000003e5H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	mov	ebx, eax
	push	8
	push	edi
	mov	DWORD PTR _diag$[ebp], ebx
	call	_kb_temp_calloc

; 998  :   v = (REAL *)temp_calloc(S->N+S->concount+1,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+144]
	push	998					; 000003e6H
	mov	DWORD PTR _subdiag$[ebp], eax
	mov	eax, DWORD PTR [esi+4]
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	edx, DWORD PTR [eax+ecx+1]
	push	8
	push	edx
	call	_kb_temp_calloc

; 999  :   w = (REAL *)temp_calloc(S->N+S->concount+1,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+144]
	push	999					; 000003e7H
	mov	DWORD PTR _v$[ebp], eax
	mov	eax, DWORD PTR [esi+4]
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	edx, DWORD PTR [eax+ecx+1]
	push	8
	push	edx
	call	_kb_temp_calloc

; 1000 :   r = (REAL *)temp_calloc(S->N+S->concount+1,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+144]
	add	esp, 64					; 00000040H
	push	1000					; 000003e8H
	mov	DWORD PTR _w$[ebp], eax
	mov	eax, DWORD PTR [esi+4]
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	edx, DWORD PTR [eax+ecx+1]
	push	8
	push	edx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H

; 1001 :   if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	mov	DWORD PTR _r$[ebp], eax
	jne	SHORT $LN47@lanczos
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN47@lanczos

; 1003 :   else mw = NULL;

	mov	DWORD PTR _mw$[ebp], 0
	jmp	SHORT $LN46@lanczos
$LN47@lanczos:

; 1002 :      mw = (REAL *)temp_calloc(S->N+S->concount+1,sizeof(REAL));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+144]
	push	1002					; 000003eaH
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	edx, DWORD PTR [eax+ecx+1]
	push	8
	push	edx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _mw$[ebp], eax
$LN46@lanczos:

; 1004 : 
; 1005 :   /* Lanczos iteration to tridiagonal, starting at index 1 in diag and subdiag */
; 1006 :   /* not doing any re-orthogonalization, so multiple eigenvalues can
; 1007 :       let large eigenvalues creep in spuriously multiple */
; 1008 : 
; 1009 : 
; 1010 :   for ( i = 0 ; i < S->N ; i++ ) w[i] = drand48() - .5;

	xor	edi, edi
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN43@lanczos
	npad	4
$LL45@lanczos:
	call	_drand48
	fsub	QWORD PTR __real@3fe0000000000000
	mov	eax, DWORD PTR _w$[ebp]
	inc	edi
	fstp	QWORD PTR [eax+edi*8-8]
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL45@lanczos
$LN43@lanczos:

; 1011 :   if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN41@lanczos
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN41@lanczos

; 1013 :   else t = 1/sqrt(dot(w,w,S->N));

	mov	ecx, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _w$[ebp]
	push	ecx
	push	edi
	push	edi
	call	_dot
	jmp	SHORT $LN158@lanczos
$LN41@lanczos:

; 1012 :       t = 1/sqrt(sparse_metric_dot(w,w,&Met));

	mov	edi, DWORD PTR _w$[ebp]
	push	OFFSET _Met
	push	edi
	push	edi
	call	_sparse_metric_dot
$LN158@lanczos:
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fld1

; 1014 :   for ( i = 0 ; i < S->N ; i++ ) w[i] *= t;

	xor	eax, eax
	fld	ST(0)
	fdivrp	ST(2), ST(0)
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN106@lanczos
$LN39@lanczos:
	fld	ST(1)
	inc	eax
	fmul	QWORD PTR [edi+eax*8-8]
	fstp	QWORD PTR [edi+eax*8-8]
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LN39@lanczos
$LN106@lanczos:

; 1015 :   subdiag[0] = 1.0;
; 1016 :   for ( j = 0 ; j < krydim ;  )

	mov	edi, DWORD PTR _krydim$[ebp]
	fstp	ST(1)
	mov	edx, DWORD PTR _subdiag$[ebp]
	fstp	QWORD PTR [edx]
	mov	DWORD PTR _j$[ebp], 0
	test	edi, edi
	jle	$LN35@lanczos
	mov	edi, edx
	sub	ebx, edi
	mov	DWORD PTR tv1393[ebp], ebx
	npad	2
$LL36@lanczos:

; 1017 :   { if ( subdiag[j] == 0.0 )

	fld	QWORD PTR [edi]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN62@lanczos

; 1019 :      if ( j > 0 ) 

	cmp	DWORD PTR _j$[ebp], 0
	jle	SHORT $LN96@lanczos

; 1020 :      { for ( i = 0 ; i < S->N ; i++ )

	xor	edx, edx
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN96@lanczos
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	sub	ecx, eax
$LL32@lanczos:

; 1021 :         { t = w[i]; w[i] = v[i]/subdiag[j]; v[i] = -subdiag[j]*t; }

	fld	QWORD PTR [ecx+eax]
	inc	edx
	fld	QWORD PTR [eax]
	add	eax, 8
	fdiv	QWORD PTR [edi]
	fstp	QWORD PTR [ecx+eax-8]
	fmul	QWORD PTR [edi]
	fchs
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LL32@lanczos
$LN96@lanczos:

; 1022 :      }
; 1023 :      
; 1024 :      /* v = Aw + v */
; 1025 :      if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN28@lanczos
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN28@lanczos

; 1028 :      }
; 1029 :      else sp_hessian_solve(S,w,r,NO_SET_PRESSURE);

	mov	ebx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR _w$[ebp]
	push	0
	push	ebx
	push	eax
	push	esi
	call	_sp_hessian_solve
	add	esp, 16					; 00000010H
	jmp	SHORT $LN27@lanczos
$LN28@lanczos:

; 1026 :      { bk_mul(&Met,w,mw);

	mov	ecx, DWORD PTR _mw$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	push	ecx
	push	edx
	push	OFFSET _Met
	call	_bk_mul

; 1027 :         sp_hessian_solve(S,mw,r,NO_SET_PRESSURE);

	mov	ebx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR _mw$[ebp]
	push	0
	push	ebx
	push	eax
	push	esi
	call	_sp_hessian_solve
	add	esp, 28					; 0000001cH
$LN27@lanczos:

; 1030 :      for ( i = 0 ; i < S->N ; i++ ) v[i] += r[i];

	xor	ecx, ecx
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN100@lanczos
	mov	eax, DWORD PTR _v$[ebp]
	mov	edx, ebx
	sub	edx, eax
	npad	5
$LL26@lanczos:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LL26@lanczos
$LN100@lanczos:

; 1031 : 
; 1032 :      j = j + 1;

	inc	DWORD PTR _j$[ebp]
	add	edi, 8

; 1033 :      if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN22@lanczos
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN22@lanczos

; 1035 :      else diag[j] = dot(w,v,S->N);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _w$[ebp]
	push	ecx
	push	edx
	push	eax
	call	_dot
	jmp	SHORT $LN159@lanczos
$LN22@lanczos:

; 1034 :          diag[j] = sparse_metric_dot(w,v,&Met);

	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	push	OFFSET _Met
	push	ecx
	push	edx
	call	_sparse_metric_dot
$LN159@lanczos:
	mov	ebx, DWORD PTR tv1393[ebp]

; 1036 :      for ( i = 0 ; i < S->N ; i++ ) v[i] -= diag[j]*w[i];

	xor	ecx, ecx
	fstp	QWORD PTR [ebx+edi]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN99@lanczos
	mov	eax, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	sub	edx, eax
$LL20@lanczos:
	fld	QWORD PTR [eax+edx]
	inc	ecx
	fmul	QWORD PTR [ebx+edi]
	add	eax, 8
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LL20@lanczos
$LN99@lanczos:

; 1037 :      if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN16@lanczos
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN16@lanczos

; 1039 :      else subdiag[j] = sqrt(dot(v,v,S->N));

	mov	eax, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	push	eax
	call	_dot
	jmp	SHORT $LN160@lanczos
$LN16@lanczos:

; 1038 :          subdiag[j] = sqrt(sparse_metric_dot(v,v,&Met));

	mov	eax, DWORD PTR _v$[ebp]
	push	OFFSET _Met
	push	eax
	push	eax
	call	_sparse_metric_dot
$LN160@lanczos:
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fstp	QWORD PTR [edi]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _krydim$[ebp]
	jl	$LL36@lanczos

; 1017 :   { if ( subdiag[j] == 0.0 )

	jmp	SHORT $LN161@lanczos
$LN62@lanczos:

; 1018 :         { outstring("premature subdiag = 0\n"); break; }

	push	OFFSET ??_C@_0BH@NKNMFOPA@premature?5subdiag?5?$DN?50?6?$AA@
	call	_outstring
	add	esp, 4
$LN161@lanczos:
	mov	edi, DWORD PTR _krydim$[ebp]
	mov	ebx, DWORD PTR _diag$[ebp]
$LN35@lanczos:

; 1040 :   }
; 1041 : 
; 1042 :   /* solve tridiagonal */
; 1043 :   tridiag_QL(diag+1,subdiag+1,krydim);

	mov	edx, DWORD PTR _subdiag$[ebp]
	push	edi
	add	edx, 8
	lea	eax, DWORD PTR [ebx+8]
	push	edx
	push	eax
	call	_tridiag_QL

; 1044 : 
; 1045 :   /* sort eigenvalues */
; 1046 :   qsort((char*)(diag+1),krydim,sizeof(REAL),FCAST realabs_comp);

	push	OFFSET _realabs_comp
	push	8
	lea	eax, DWORD PTR [ebx+8]
	push	edi
	push	eax
	call	_qsort
	fldz
	fld1
	add	esp, 28					; 0000001cH

; 1047 : 
; 1048 :   /* unshift */
; 1049 :   for ( i = 1 ; i <= krydim ; i++ )

	mov	edx, 1
	cmp	edi, 4
	jl	$LC72@lanczos

; 1040 :   }
; 1041 : 
; 1042 :   /* solve tridiagonal */
; 1043 :   tridiag_QL(diag+1,subdiag+1,krydim);

	mov	eax, edi
	shr	eax, 2
	lea	ecx, DWORD PTR [ebx+24]
	mov	DWORD PTR tv617[ebp], eax
	lea	edx, DWORD PTR [eax*4+1]

; 1047 : 
; 1048 :   /* unshift */
; 1049 :   for ( i = 1 ; i <= krydim ; i++ )

$LN81@lanczos:

; 1050 :      if ( diag[i] == 0.0 ) diag[i] = S->lambda;

	fld	QWORD PTR [ecx-16]
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN73@lanczos
	fld	QWORD PTR [esi+112]
	jmp	SHORT $LN162@lanczos
$LN73@lanczos:

; 1051 :      else diag[i] = S->lambda + 1/diag[i];

	fld	ST(0)
	fdiv	QWORD PTR [ecx-16]
	fadd	QWORD PTR [esi+112]
$LN162@lanczos:
	fstp	QWORD PTR [ecx-16]
	fld	QWORD PTR [ecx-8]
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN75@lanczos

; 1050 :      if ( diag[i] == 0.0 ) diag[i] = S->lambda;

	fld	QWORD PTR [esi+112]
	jmp	SHORT $LN163@lanczos
$LN75@lanczos:

; 1051 :      else diag[i] = S->lambda + 1/diag[i];

	fld	ST(0)
	fdiv	QWORD PTR [ecx-8]
	fadd	QWORD PTR [esi+112]
$LN163@lanczos:
	fstp	QWORD PTR [ecx-8]
	fld	QWORD PTR [ecx]
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN77@lanczos

; 1050 :      if ( diag[i] == 0.0 ) diag[i] = S->lambda;

	fld	QWORD PTR [esi+112]
	jmp	SHORT $LN164@lanczos
$LN77@lanczos:

; 1051 :      else diag[i] = S->lambda + 1/diag[i];

	fld	ST(0)
	fdiv	QWORD PTR [ecx]
	fadd	QWORD PTR [esi+112]
$LN164@lanczos:
	fstp	QWORD PTR [ecx]
	fld	QWORD PTR [ecx+8]
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN79@lanczos

; 1050 :      if ( diag[i] == 0.0 ) diag[i] = S->lambda;

	fld	QWORD PTR [esi+112]
	jmp	SHORT $LN165@lanczos
$LN79@lanczos:

; 1051 :      else diag[i] = S->lambda + 1/diag[i];

	fld	ST(0)
	fdiv	QWORD PTR [ecx+8]
	fadd	QWORD PTR [esi+112]
$LN165@lanczos:
	fstp	QWORD PTR [ecx+8]
	add	ecx, 32					; 00000020H
	dec	DWORD PTR tv617[ebp]
	jne	SHORT $LN81@lanczos
$LC72@lanczos:

; 1047 : 
; 1048 :   /* unshift */
; 1049 :   for ( i = 1 ; i <= krydim ; i++ )

	cmp	edx, edi
	jg	SHORT $LN133@lanczos
$LC14@lanczos:

; 1050 :      if ( diag[i] == 0.0 ) diag[i] = S->lambda;

	fld	QWORD PTR [ebx+edx*8]
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@lanczos
	fld	QWORD PTR [esi+112]
	jmp	SHORT $LN166@lanczos
$LN11@lanczos:

; 1051 :      else diag[i] = S->lambda + 1/diag[i];

	fld	ST(0)
	fdiv	QWORD PTR [ebx+edx*8]
	fadd	QWORD PTR [esi+112]
$LN166@lanczos:
	fstp	QWORD PTR [ebx+edx*8]
	inc	edx
	cmp	edx, edi
	jle	SHORT $LC14@lanczos
$LN133@lanczos:

; 1052 : 
; 1053 :   /* uniqify */
; 1054 :   for ( i = 2, j = 1; i <= krydim ; i++ )

	mov	edx, 2
	fstp	ST(1)
	fstp	ST(0)
	lea	ecx, DWORD PTR [edx-1]
	cmp	edi, edx
	jl	$LN82@lanczos
	fld	QWORD PTR __real@4059000000000000
	lea	eax, DWORD PTR [edi-1]
	cmp	eax, 4
	jl	$LN93@lanczos

; 1055 :   { if ( fabs(diag[j] - diag[i]) < 100*machine_eps ) continue;

	mov	edi, DWORD PTR _krydim$[ebp]
	dec	edi
	shr	edi, 2
	lea	eax, DWORD PTR [edi*4+2]
	lea	edx, DWORD PTR [ebx+8]
	lea	esi, DWORD PTR [ebx+32]
	mov	DWORD PTR _i$[ebp], eax
$LN88@lanczos:
	fld	QWORD PTR [edx]
	fsub	QWORD PTR [esi-16]
	fabs
	fld	QWORD PTR _machine_eps
	fmul	ST(0), ST(2)
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN84@lanczos

; 1056 :      diag[++j] = diag[i];

	fld	QWORD PTR [esi-16]
	inc	ecx
	lea	edx, DWORD PTR [ebx+ecx*8]
	fstp	QWORD PTR [edx]
$LN84@lanczos:

; 1055 :   { if ( fabs(diag[j] - diag[i]) < 100*machine_eps ) continue;

	fld	QWORD PTR [edx]
	fsub	QWORD PTR [esi-8]
	fabs
	fld	QWORD PTR _machine_eps
	fmul	ST(0), ST(2)
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN85@lanczos

; 1056 :      diag[++j] = diag[i];

	fld	QWORD PTR [esi-8]
	inc	ecx
	lea	edx, DWORD PTR [ebx+ecx*8]
	fstp	QWORD PTR [edx]
$LN85@lanczos:

; 1055 :   { if ( fabs(diag[j] - diag[i]) < 100*machine_eps ) continue;

	fld	QWORD PTR [edx]
	fsub	QWORD PTR [esi]
	fabs
	fld	QWORD PTR _machine_eps
	fmul	ST(0), ST(2)
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN86@lanczos

; 1056 :      diag[++j] = diag[i];

	fld	QWORD PTR [esi]
	inc	ecx
	lea	edx, DWORD PTR [ebx+ecx*8]
	fstp	QWORD PTR [edx]
$LN86@lanczos:

; 1055 :   { if ( fabs(diag[j] - diag[i]) < 100*machine_eps ) continue;

	fld	QWORD PTR [edx]
	fsub	QWORD PTR [esi+8]
	fabs
	fld	QWORD PTR _machine_eps
	fmul	ST(0), ST(2)
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN101@lanczos

; 1056 :      diag[++j] = diag[i];

	fld	QWORD PTR [esi+8]
	inc	ecx
	lea	edx, DWORD PTR [ebx+ecx*8]
	fstp	QWORD PTR [edx]
$LN101@lanczos:

; 1055 :   { if ( fabs(diag[j] - diag[i]) < 100*machine_eps ) continue;

	add	esi, 32					; 00000020H
	dec	edi
	jne	$LN88@lanczos
	mov	edx, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR _krydim$[ebp]
$LN93@lanczos:

; 1052 : 
; 1053 :   /* uniqify */
; 1054 :   for ( i = 2, j = 1; i <= krydim ; i++ )

	cmp	edx, edi
	jg	SHORT $LN157@lanczos
$LC9@lanczos:

; 1055 :   { if ( fabs(diag[j] - diag[i]) < 100*machine_eps ) continue;

	fld	QWORD PTR [ebx+ecx*8]
	fsub	QWORD PTR [ebx+edx*8]
	fabs
	fld	QWORD PTR _machine_eps
	fmul	ST(0), ST(2)
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN8@lanczos

; 1056 :      diag[++j] = diag[i];

	fld	QWORD PTR [ebx+edx*8]
	inc	ecx
	fstp	QWORD PTR [ebx+ecx*8]
$LN8@lanczos:

; 1052 : 
; 1053 :   /* uniqify */
; 1054 :   for ( i = 2, j = 1; i <= krydim ; i++ )

	inc	edx
	cmp	edx, edi
	jle	SHORT $LC9@lanczos
$LN157@lanczos:

; 1056 :      diag[++j] = diag[i];

	fstp	ST(0)
$LN82@lanczos:

; 1057 :   }
; 1058 :   krydim = j;
; 1059 :   if ( nprint > krydim ) nprint = krydim;

	cmp	DWORD PTR _nprint$[ebp], ecx
	jle	SHORT $LN5@lanczos
	mov	DWORD PTR _nprint$[ebp], ecx
$LN5@lanczos:

; 1060 : 
; 1061 :   /* list, ones near probe value */
; 1062 :   for ( i = 0 ; i < nprint ; i++ ) evalues[i] = diag[krydim-i];

	mov	ebx, DWORD PTR _evalues$[ebp]
	xor	edi, edi
	cmp	DWORD PTR _nprint$[ebp], 4
	jl	SHORT $LC90@lanczos
	mov	esi, DWORD PTR _nprint$[ebp]
	mov	edx, DWORD PTR _diag$[ebp]
	add	esi, -4					; fffffffcH
	shr	esi, 2
	inc	esi
	lea	eax, DWORD PTR [ebx+16]
	lea	edx, DWORD PTR [edx+ecx*8-16]
	lea	edi, DWORD PTR [esi*4]
	npad	4
$LL91@lanczos:
	fld	QWORD PTR [edx+16]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-48]
	sub	edx, 32					; 00000020H
	dec	esi
	fld	QWORD PTR [edx+40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [edx+32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx+24]
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LL91@lanczos
$LC90@lanczos:
	mov	esi, DWORD PTR _nprint$[ebp]
	cmp	edi, esi
	jge	SHORT $LN97@lanczos
	mov	eax, DWORD PTR _diag$[ebp]
	sub	ecx, edi
	lea	ecx, DWORD PTR [eax+ecx*8]
$LC4@lanczos:
	fld	QWORD PTR [ecx]
	inc	edi
	fstp	QWORD PTR [ebx+edi*8-8]
	sub	ecx, 8
	cmp	edi, esi
	jl	SHORT $LC4@lanczos
$LN97@lanczos:

; 1063 : 
; 1064 :   temp_free((char*)diag);

	mov	ecx, DWORD PTR _diag$[ebp]
	push	ecx
	call	_temp_free

; 1065 :   temp_free((char*)subdiag);

	mov	edx, DWORD PTR _subdiag$[ebp]
	push	edx
	call	_temp_free

; 1066 :   temp_free((char*)v);

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	call	_temp_free

; 1067 :   temp_free((char*)w);

	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	call	_temp_free

; 1068 :   temp_free((char*)r);

	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	call	_temp_free

; 1069 :   if ( mw ) temp_free((char*)mw);

	mov	eax, DWORD PTR _mw$[ebp]
	add	esp, 20					; 00000014H
	pop	edi
	pop	ebx
	test	eax, eax
	je	SHORT $LN92@lanczos
	push	eax
	call	_temp_free
	add	esp, 4
$LN92@lanczos:

; 1070 : 
; 1071 :   return nprint;

	mov	eax, esi
	pop	esi

; 1072 : } /* end lanczos() */

	mov	esp, ebp
	pop	ebp
	ret	0
_lanczos ENDP
_TEXT	ENDS
PUBLIC	_selective_lanczos
; Function compile flags: /Ogtp
;	COMDAT _selective_lanczos
_TEXT	SEGMENT
_v$ = -48						; size = 4
_basis$ = -44						; size = 4
_subdiag$ = -40						; size = 4
_k$ = -36						; size = 4
_rayleigh$ = -32					; size = 4
_r$ = -28						; size = 4
_mw$ = -24						; size = 4
_j$ = -20						; size = 4
tv1659 = -16						; size = 4
tv1589 = -12						; size = 4
_diag$ = -8						; size = 4
_basis_count$ = -4					; size = 4
_w$ = 8							; size = 4
_S$ = 8							; size = 4
_krydim$ = 12						; size = 4
_evalues$ = 16						; size = 4
_nprint$ = 20						; size = 4
_selective_lanczos PROC					; COMDAT

; 1091 : { REAL *diag;  /* main diagonal of tridiagonal */

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 1092 :   REAL *subdiag;    /* subdiagonal */
; 1093 :   REAL *v,*w,*mw;    /* working vectors; w is Lanczos vector  */
; 1094 :   REAL *r;
; 1095 :   REAL t;      /* temp */
; 1096 :   int i,j,k;
; 1097 :   REAL **basis; /* for saving basis vectors for reortho */
; 1098 :   REAL *rayleigh; /* rayleigh quotients associated to basis vectors */
; 1099 :   int basis_count = 0;  /* how many basis vectors saved */
; 1100 :   REAL growth;
; 1101 : 
; 1102 :   if ( krydim > S->N ) krydim = S->N;

	mov	ecx, DWORD PTR _krydim$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR _basis_count$[ebp], 0
	cmp	ecx, eax
	jle	SHORT $LN60@selective_
	mov	ecx, eax
	mov	DWORD PTR _krydim$[ebp], ecx
$LN60@selective_:

; 1103 :   if ( nprint > krydim ) nprint = krydim;

	cmp	DWORD PTR _nprint$[ebp], ecx
	jle	SHORT $LN59@selective_
	mov	DWORD PTR _nprint$[ebp], ecx
$LN59@selective_:

; 1104 : 
; 1105 :   diag = (REAL *)temp_calloc(krydim+1,sizeof(REAL));

	mov	edi, DWORD PTR _krydim$[ebp]
	push	1105					; 00000451H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	inc	edi
	push	8
	push	edi
	call	_kb_temp_calloc

; 1106 :   subdiag = (REAL *)temp_calloc(krydim+1,sizeof(REAL));

	push	1106					; 00000452H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	push	8
	push	edi
	mov	DWORD PTR _diag$[ebp], eax
	call	_kb_temp_calloc

; 1107 :   v = (REAL *)temp_calloc(S->N+S->concount+1,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+4]
	push	1107					; 00000453H
	mov	DWORD PTR _subdiag$[ebp], eax
	mov	eax, DWORD PTR [esi+144]
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	edx, DWORD PTR [eax+ecx+1]
	push	8
	push	edx
	call	_kb_temp_calloc

; 1108 :   w = (REAL *)temp_calloc(S->N+S->concount+1,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+4]
	push	1108					; 00000454H
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+144]
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	edx, DWORD PTR [eax+ecx+1]
	push	8
	push	edx
	mov	DWORD PTR _v$[ebp], ebx
	call	_kb_temp_calloc

; 1109 :   r = (REAL *)temp_calloc(S->N+S->concount+1,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 64					; 00000040H
	push	1109					; 00000455H
	mov	DWORD PTR _w$[ebp], eax
	mov	eax, DWORD PTR [esi+144]
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	edx, DWORD PTR [eax+ecx+1]
	push	8
	push	edx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H

; 1110 :   if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	mov	DWORD PTR _r$[ebp], eax
	jne	SHORT $LN57@selective_
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN57@selective_

; 1112 :   else mw = NULL;

	mov	DWORD PTR _mw$[ebp], 0
	jmp	SHORT $LN56@selective_
$LN57@selective_:

; 1111 :       mw = (REAL *)temp_calloc(S->N+S->concount+1,sizeof(REAL));

	mov	eax, DWORD PTR [esi+144]
	mov	ecx, DWORD PTR [esi+4]
	push	1111					; 00000457H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	lea	edx, DWORD PTR [eax+ecx+1]
	push	8
	push	edx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _mw$[ebp], eax
$LN56@selective_:

; 1113 :   basis = dmatrix(0,nprint-1,0,S->N-1);

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _nprint$[ebp]
	push	1113					; 00000459H
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	dec	eax
	push	eax
	push	0
	lea	ecx, DWORD PTR [edi-1]
	push	ecx
	push	0
	call	_kb_dmatrix

; 1114 :   rayleigh = (REAL*)temp_calloc(nprint,sizeof(REAL));

	push	1114					; 0000045aH
	push	OFFSET ??_C@_0L@FBOHLLIG@HESSIAN2?4C?$AA@
	push	8
	push	edi
	mov	DWORD PTR _basis$[ebp], eax
	call	_kb_temp_calloc

; 1115 : 
; 1116 :   /* Lanczos iteration to tridiagonal, starting at index 1 in diag and subdiag */
; 1117 : 
; 1118 :   for ( i = 0 ; i < S->N ; i++ ) w[i] = drand48() - .5;

	xor	edi, edi
	add	esp, 40					; 00000028H
	mov	DWORD PTR _rayleigh$[ebp], eax
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN53@selective_
$LL55@selective_:
	call	_drand48
	fsub	QWORD PTR __real@3fe0000000000000
	mov	edx, DWORD PTR _w$[ebp]
	inc	edi
	fstp	QWORD PTR [edx+edi*8-8]
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL55@selective_
$LN53@selective_:

; 1119 :   if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN51@selective_
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN51@selective_

; 1121 :   else t = 1/sqrt(dot(w,w,S->N));

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _w$[ebp]
	push	eax
	push	edi
	push	edi
	call	_dot
	jmp	SHORT $LN155@selective_
$LN51@selective_:

; 1120 :       t = 1/sqrt(sparse_metric_dot(w,w,&Met));

	mov	edi, DWORD PTR _w$[ebp]
	push	OFFSET _Met
	push	edi
	push	edi
	call	_sparse_metric_dot
$LN155@selective_:
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fld1

; 1122 :   for ( i = 0 ; i < S->N ; i++ ) w[i] *= t;

	xor	eax, eax
	fld	ST(0)
	fdivrp	ST(2), ST(0)
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN107@selective_
$LN49@selective_:
	fld	QWORD PTR [edi+eax*8]
	inc	eax
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [edi+eax*8-8]
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LN49@selective_
$LN107@selective_:

; 1123 :   subdiag[0] = 1.0;
; 1124 :   for ( j = 0 ; j < krydim ;  )

	cmp	DWORD PTR _krydim$[ebp], 0
	fstp	ST(1)
	mov	eax, DWORD PTR _subdiag$[ebp]
	fstp	QWORD PTR [eax]
	mov	DWORD PTR _j$[ebp], 0
	jle	$LN45@selective_
	mov	ecx, DWORD PTR _diag$[ebp]
	sub	ecx, eax
	mov	DWORD PTR tv1589[ebp], eax
	mov	DWORD PTR tv1659[ebp], ecx
$LL46@selective_:

; 1125 :   { if ( subdiag[j] == 0.0 )

	mov	edi, DWORD PTR tv1589[ebp]
	fld	QWORD PTR [edi]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN74@selective_

; 1127 :      if ( j > 0 ) 

	cmp	DWORD PTR _j$[ebp], 0
	jle	SHORT $LN101@selective_

; 1128 :      { for ( i = 0 ; i < S->N ; i++ )

	xor	edx, edx
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN101@selective_
	mov	ecx, DWORD PTR _w$[ebp]
	mov	eax, ebx
	sub	ecx, ebx
	npad	1
$LL42@selective_:

; 1129 :         { t = w[i]; w[i] = v[i]/subdiag[j]; v[i] = -subdiag[j]*t; }

	fld	QWORD PTR [ecx+eax]
	inc	edx
	fld	QWORD PTR [eax]
	add	eax, 8
	fdiv	QWORD PTR [edi]
	fstp	QWORD PTR [ecx+eax-8]
	fmul	QWORD PTR [edi]
	fchs
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LL42@selective_
$LN101@selective_:

; 1130 :      }
; 1131 :      
; 1132 :      /* v = Aw + v */
; 1133 :      if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN38@selective_
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN38@selective_

; 1136 :      }
; 1137 :      else sp_hessian_solve(S,w,r,NO_SET_PRESSURE);

	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	push	0
	push	ecx
	push	edx
	push	esi
	call	_sp_hessian_solve
	add	esp, 16					; 00000010H
	jmp	SHORT $LN37@selective_
$LN38@selective_:

; 1134 :      { bk_mul(&Met,w,mw);

	mov	eax, DWORD PTR _mw$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	push	eax
	push	ecx
	push	OFFSET _Met
	call	_bk_mul

; 1135 :         sp_hessian_solve(S,mw,r,NO_SET_PRESSURE);

	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR _mw$[ebp]
	push	0
	push	edx
	push	eax
	push	esi
	call	_sp_hessian_solve
	add	esp, 28					; 0000001cH
$LN37@selective_:

; 1138 :      for ( i = 0 ; i < S->N ; i++ ) v[i] += r[i];

	xor	ecx, ecx
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN34@selective_
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, ebx
	sub	edx, ebx
$LL36@selective_:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LL36@selective_
$LN34@selective_:

; 1139 : 
; 1140 :      j = j + 1;

	inc	DWORD PTR _j$[ebp]
	add	edi, 8

; 1141 :      if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	mov	DWORD PTR tv1589[ebp], edi
	jne	SHORT $LN32@selective_
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN32@selective_

; 1143 :      else diag[j] = dot(w,v,S->N);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _w$[ebp]
	push	ecx
	push	ebx
	push	edx
	call	_dot
	mov	eax, DWORD PTR tv1659[ebp]
	fstp	QWORD PTR [eax+edi]
	jmp	SHORT $LN156@selective_
$LN32@selective_:

; 1142 :         diag[j] = sparse_metric_dot(w,v,&Met);

	mov	ecx, DWORD PTR _w$[ebp]
	push	OFFSET _Met
	push	ebx
	push	ecx
	call	_sparse_metric_dot
	mov	edx, DWORD PTR tv1659[ebp]
	fstp	QWORD PTR [edx+edi]
$LN156@selective_:

; 1144 :      for ( i = 0 ; i < S->N ; i++ ) v[i] -= diag[j]*w[i];

	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN102@selective_
	mov	edx, DWORD PTR _w$[ebp]
	mov	eax, ebx
	sub	edx, ebx
	mov	ebx, DWORD PTR tv1659[ebp]
$LL30@selective_:
	fld	QWORD PTR [eax+edx]
	inc	ecx
	fmul	QWORD PTR [ebx+edi]
	add	eax, 8
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LL30@selective_
	mov	ebx, DWORD PTR _v$[ebp]
$LN102@selective_:

; 1145 :      /* reorthogonalize */
; 1146 :      for ( k = 0 ; k < basis_count ; k++ )

	cmp	DWORD PTR _basis_count$[ebp], 0
	mov	DWORD PTR _k$[ebp], 0
	jle	SHORT $LN25@selective_
	npad	11
$LL27@selective_:

; 1147 :      { REAL d;
; 1148 :         REAL *p = basis[k];
; 1149 :         if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	mov	eax, DWORD PTR _basis$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR [eax+ecx*4]
	jne	SHORT $LN23@selective_
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN23@selective_

; 1151 :         else d = dot(basis[k],v,S->N);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	push	ebx
	push	edi
	call	_dot
	jmp	SHORT $LN157@selective_
$LN23@selective_:

; 1150 :             d = sparse_metric_dot(basis[k],v,&Met);

	push	OFFSET _Met
	push	ebx
	push	edi
	call	_sparse_metric_dot
$LN157@selective_:

; 1152 :         for ( i = 0 ; i < S->N ; i++,p++ ) v[i] -= d*(*p);

	xor	eax, eax
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN111@selective_
$LN21@selective_:
	fld	QWORD PTR [edi]
	inc	eax
	fmul	ST(0), ST(1)
	add	edi, 8
	fsubr	QWORD PTR [ebx+eax*8-8]
	fstp	QWORD PTR [ebx+eax*8-8]
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LN21@selective_
$LN111@selective_:

; 1145 :      /* reorthogonalize */
; 1146 :      for ( k = 0 ; k < basis_count ; k++ )

	mov	eax, DWORD PTR _k$[ebp]

; 1152 :         for ( i = 0 ; i < S->N ; i++,p++ ) v[i] -= d*(*p);

	fstp	ST(0)
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _basis_count$[ebp]
	jl	SHORT $LL27@selective_
$LN25@selective_:

; 1153 :      }
; 1154 :      if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN17@selective_
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN17@selective_

; 1156 :      else subdiag[j] = sqrt(dot(v,v,S->N));

	mov	eax, DWORD PTR [esi+4]
	push	eax
	push	ebx
	push	ebx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	mov	eax, DWORD PTR tv1589[ebp]
	fstp	QWORD PTR [eax]
	jmp	SHORT $LN16@selective_
$LN17@selective_:

; 1155 :          subdiag[j] = sqrt(sparse_metric_dot(v,v,&Met));

	push	OFFSET _Met
	push	ebx
	push	ebx
	call	_sparse_metric_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	mov	ecx, DWORD PTR tv1589[ebp]
	fstp	QWORD PTR [ecx]
	mov	eax, ecx
$LN16@selective_:

; 1157 : 
; 1158 :      /* maybe save this basis vector for orthogonalization */
; 1159 :      growth = 
; 1160 :         sqrt(subdiag[j]*subdiag[j]+diag[j]*diag[j]+subdiag[j-1]*subdiag[j-1]);

	fld	QWORD PTR [eax]
	mov	edx, DWORD PTR tv1659[ebp]
	fld	QWORD PTR [edx+eax]
	fld	QWORD PTR [eax-8]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fld	ST(2)
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt

; 1161 :      if ( growth > 1.0 )

	fld1
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	$LN120@selective_

; 1162 :      { /* save */
; 1163 :         int which = -1; /* which to replace, with non-replace initial value */
; 1164 :         if ( basis_count < nprint ) which = basis_count++;

	mov	eax, DWORD PTR _basis_count$[ebp]
	or	edx, -1
	cmp	eax, DWORD PTR _nprint$[ebp]
	jge	SHORT $LN14@selective_
	mov	edx, eax
	inc	eax
	mov	DWORD PTR _basis_count$[ebp], eax

; 1165 :         else  /* maybe replace smaller growth vector */

	jmp	$LN85@selective_
$LN14@selective_:

; 1166 :         { REAL diff = 0.0;

	fldz

; 1167 :           for ( i = 0 ; i < basis_count ; i++ )

	xor	ecx, ecx
	cmp	eax, 4
	jl	SHORT $LC86@selective_

; 1166 :         { REAL diff = 0.0;

	mov	edi, DWORD PTR _rayleigh$[ebp]
	add	edi, 16					; 00000010H

; 1167 :           for ( i = 0 ; i < basis_count ; i++ )

$LN91@selective_:

; 1168 :              if ( growth - rayleigh[i] > diff ) 

	fld	ST(1)
	fsub	QWORD PTR [edi-16]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN127@selective_

; 1169 :                 { diff = growth - rayleigh[i]; which = i; }

	fstp	ST(1)
	mov	edx, ecx
	jmp	SHORT $LN87@selective_
$LN127@selective_:
	fstp	ST(0)
$LN87@selective_:

; 1168 :              if ( growth - rayleigh[i] > diff ) 

	fld	ST(1)
	fsub	QWORD PTR [edi-8]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN130@selective_

; 1166 :         { REAL diff = 0.0;

	fstp	ST(1)
	lea	edx, DWORD PTR [ecx+1]
	jmp	SHORT $LN88@selective_
$LN130@selective_:
	fstp	ST(0)
$LN88@selective_:

; 1168 :              if ( growth - rayleigh[i] > diff ) 

	fld	ST(1)
	fsub	QWORD PTR [edi]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN133@selective_

; 1166 :         { REAL diff = 0.0;

	fstp	ST(1)
	lea	edx, DWORD PTR [ecx+2]
	jmp	SHORT $LN89@selective_
$LN133@selective_:
	fstp	ST(0)
$LN89@selective_:

; 1168 :              if ( growth - rayleigh[i] > diff ) 

	fld	ST(1)
	fsub	QWORD PTR [edi+8]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN136@selective_

; 1166 :         { REAL diff = 0.0;

	fstp	ST(1)
	lea	edx, DWORD PTR [ecx+3]
	jmp	SHORT $LN90@selective_
$LN136@selective_:
	fstp	ST(0)
$LN90@selective_:
	mov	eax, DWORD PTR _basis_count$[ebp]
	add	ecx, 4
	add	eax, -3					; fffffffdH
	add	edi, 32					; 00000020H
	cmp	ecx, eax
	jl	SHORT $LN91@selective_
$LC86@selective_:

; 1167 :           for ( i = 0 ; i < basis_count ; i++ )

	cmp	ecx, DWORD PTR _basis_count$[ebp]
	jge	SHORT $LN145@selective_
	mov	edi, DWORD PTR _basis_count$[ebp]
$LC12@selective_:

; 1168 :              if ( growth - rayleigh[i] > diff ) 

	mov	eax, DWORD PTR _rayleigh$[ebp]
	fld	ST(1)
	fsub	QWORD PTR [eax+ecx*8]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN143@selective_

; 1169 :                 { diff = growth - rayleigh[i]; which = i; }

	fstp	ST(1)
	mov	edx, ecx
	jmp	SHORT $LN11@selective_
$LN143@selective_:
	fstp	ST(0)
$LN11@selective_:
	inc	ecx

; 1167 :           for ( i = 0 ; i < basis_count ; i++ )

	cmp	ecx, edi
	jl	SHORT $LC12@selective_
$LN145@selective_:

; 1169 :                 { diff = growth - rayleigh[i]; which = i; }

	fstp	ST(0)
$LN85@selective_:

; 1170 :         }
; 1171 :         if ( which >= 0 )

	test	edx, edx
	js	SHORT $LN120@selective_

; 1172 :         { rayleigh[which] = growth;

	mov	ecx, DWORD PTR _rayleigh$[ebp]
	fstp	QWORD PTR [ecx+edx*8]

; 1173 :           memcpy((char*)(basis[which]),(char*)w,S->N*sizeof(REAL));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _w$[ebp]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	mov	eax, DWORD PTR _basis$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN98@selective_
$LN120@selective_:

; 1170 :         }
; 1171 :         if ( which >= 0 )

	fstp	ST(0)
$LN98@selective_:

; 1123 :   subdiag[0] = 1.0;
; 1124 :   for ( j = 0 ; j < krydim ;  )

	mov	edx, DWORD PTR _krydim$[ebp]
	cmp	DWORD PTR _j$[ebp], edx
	jl	$LL46@selective_

; 1125 :   { if ( subdiag[j] == 0.0 )

	jmp	SHORT $LN45@selective_
$LN74@selective_:

; 1126 :         { outstring("premature subdiag = 0\n"); break; }

	push	OFFSET ??_C@_0BH@NKNMFOPA@premature?5subdiag?5?$DN?50?6?$AA@
	call	_outstring
	add	esp, 4
$LN45@selective_:

; 1174 :         }
; 1175 :      }
; 1176 :   }
; 1177 : 
; 1178 :   /* solve tridiagonal */
; 1179 :   tridiag_QL(diag+1,subdiag+1,krydim);

	mov	eax, DWORD PTR _krydim$[ebp]
	mov	ecx, DWORD PTR _subdiag$[ebp]
	mov	edi, DWORD PTR _diag$[ebp]
	push	eax
	add	ecx, 8
	push	ecx
	add	edi, 8
	push	edi
	call	_tridiag_QL

; 1180 : 
; 1181 :   /* sort eigenvalues */
; 1182 :   qsort((char*)(diag+1),krydim,sizeof(REAL),FCAST realabs_comp);

	mov	edx, DWORD PTR _krydim$[ebp]
	push	OFFSET _realabs_comp
	push	8
	push	edx
	push	edi
	call	_qsort
	fld1
	add	esp, 28					; 0000001cH

; 1183 : 
; 1184 :   /* unshift */
; 1185 :   for ( i = 1 ; i <= krydim ; i++ )

	cmp	DWORD PTR _krydim$[ebp], 4
	mov	ecx, 1
	jl	SHORT $LC93@selective_

; 1174 :         }
; 1175 :      }
; 1176 :   }
; 1177 : 
; 1178 :   /* solve tridiagonal */
; 1179 :   tridiag_QL(diag+1,subdiag+1,krydim);

	mov	eax, DWORD PTR _diag$[ebp]
	mov	edx, DWORD PTR _krydim$[ebp]
	add	eax, 24					; 00000018H
	shr	edx, 2
	lea	ecx, DWORD PTR [edx*4+1]

; 1183 : 
; 1184 :   /* unshift */
; 1185 :   for ( i = 1 ; i <= krydim ; i++ )

$LN94@selective_:

; 1186 :   diag[i] = S->lambda + 1/diag[i];

	fld	ST(0)
	add	eax, 32					; 00000020H
	dec	edx
	fdiv	QWORD PTR [eax-48]
	fadd	QWORD PTR [esi+112]
	fstp	QWORD PTR [eax-48]
	fld	ST(0)
	fdiv	QWORD PTR [eax-40]
	fadd	QWORD PTR [esi+112]
	fstp	QWORD PTR [eax-40]
	fld	ST(0)
	fdiv	QWORD PTR [eax-32]
	fadd	QWORD PTR [esi+112]
	fstp	QWORD PTR [eax-32]
	fld	ST(0)
	fdiv	QWORD PTR [eax-24]
	fadd	QWORD PTR [esi+112]
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN94@selective_
$LC93@selective_:

; 1183 : 
; 1184 :   /* unshift */
; 1185 :   for ( i = 1 ; i <= krydim ; i++ )

	mov	edx, DWORD PTR _krydim$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN154@selective_
	mov	eax, DWORD PTR _diag$[ebp]
$LC7@selective_:

; 1186 :   diag[i] = S->lambda + 1/diag[i];

	fld	ST(0)
	inc	ecx
	fdiv	QWORD PTR [eax+ecx*8-8]
	fadd	QWORD PTR [esi+112]
	fstp	QWORD PTR [eax+ecx*8-8]
	cmp	ecx, edx
	jle	SHORT $LC7@selective_
$LN154@selective_:

; 1187 : 
; 1188 :   /* list, ones near probe value */
; 1189 :   for ( i = 0 ; i < nprint ; i++ ) evalues[i] = diag[krydim-i];

	mov	edi, DWORD PTR _evalues$[ebp]
	fstp	ST(0)
	xor	esi, esi
	cmp	DWORD PTR _nprint$[ebp], 4
	jl	SHORT $LC96@selective_
	mov	edx, DWORD PTR _krydim$[ebp]
	mov	ecx, DWORD PTR _diag$[ebp]
	lea	ecx, DWORD PTR [ecx+edx*8-16]
	mov	edx, DWORD PTR _nprint$[ebp]
	add	edx, -4					; fffffffcH
	shr	edx, 2
	inc	edx
	lea	eax, DWORD PTR [edi+16]
	lea	esi, DWORD PTR [edx*4]
	npad	8
$LL97@selective_:
	fld	QWORD PTR [ecx+16]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-48]
	sub	ecx, 32					; 00000020H
	dec	edx
	fld	QWORD PTR [ecx+40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [ecx+32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx+24]
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LL97@selective_
$LC96@selective_:
	mov	ecx, DWORD PTR _nprint$[ebp]
	cmp	esi, ecx
	jge	SHORT $LN95@selective_
	mov	eax, DWORD PTR _krydim$[ebp]
	mov	edx, DWORD PTR _diag$[ebp]
	sub	eax, esi
	lea	eax, DWORD PTR [edx+eax*8]
$LC4@selective_:
	fld	QWORD PTR [eax]
	inc	esi
	fstp	QWORD PTR [edi+esi*8-8]
	sub	eax, 8
	cmp	esi, ecx
	jl	SHORT $LC4@selective_
$LN95@selective_:

; 1190 : 
; 1191 :   temp_free((char*)diag);

	mov	eax, DWORD PTR _diag$[ebp]
	push	eax
	call	_temp_free

; 1192 :   temp_free((char*)subdiag);

	mov	ecx, DWORD PTR _subdiag$[ebp]
	push	ecx
	call	_temp_free

; 1193 :   temp_free((char*)v);

	push	ebx
	call	_temp_free

; 1194 :   temp_free((char*)w);

	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	call	_temp_free

; 1195 :   if ( mw ) temp_free((char*)mw);

	mov	eax, DWORD PTR _mw$[ebp]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN1@selective_
	push	eax
	call	_temp_free
	add	esp, 4
$LN1@selective_:

; 1196 :   temp_free((char*)r);

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	call	_temp_free

; 1197 :   temp_free((char*)rayleigh);

	mov	ecx, DWORD PTR _rayleigh$[ebp]
	push	ecx
	call	_temp_free

; 1198 :   free_matrix(basis);

	mov	edx, DWORD PTR _basis$[ebp]
	push	edx
	call	_free_matrix

; 1199 :   return nprint;

	mov	eax, DWORD PTR _nprint$[ebp]
	add	esp, 12					; 0000000cH

; 1200 : } /* end selective_lanczos() */

	mov	esp, ebp
	pop	ebp
	ret	0
_selective_lanczos ENDP
_TEXT	ENDS
PUBLIC	_ritz_command
EXTRN	_sparse_constraints_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _ritz_command
_TEXT	SEGMENT
_S$ = -236						; size = 232
_rhs$ = -4						; size = 4
_lambda$ = 8						; size = 8
_ritzdim$ = 16						; size = 4
_ritz_command PROC					; COMDAT

; 1360 : { struct linsys S;

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH

; 1361 :   REAL *rhs;
; 1362 :   memset((char*)&S,0,sizeof(struct linsys)); 

	push	232					; 000000e8H
	lea	eax, DWORD PTR _S$[ebp]
	push	0
	push	eax
	call	_memset

; 1363 :   
; 1364 :   hmode = hessian_normal_flag;

	mov	ecx, DWORD PTR _hessian_normal_flag

; 1365 :   hessian_init(&S,&rhs);

	lea	edx, DWORD PTR _rhs$[ebp]
	push	edx
	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	mov	DWORD PTR _hmode, ecx
	call	_hessian_init

; 1366 :   hess_flag = 1; rhs_flag = 0; 
; 1367 :   hessian_fill(&S,&rhs); 

	lea	ecx, DWORD PTR _rhs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	mov	DWORD PTR _hess_flag, 1
	mov	DWORD PTR _rhs_flag, 0
	call	_hessian_fill
	add	esp, 28					; 0000001cH

; 1368 :   if ( sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, 0
	je	SHORT $LN8@ritz_comma

; 1369 :     (*sp_AIJ_setup_func)(S.total_rows,&S);

	mov	ecx, DWORD PTR _S$[ebp+28]
	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	push	ecx

; 1370 :   else

	jmp	SHORT $LN11@ritz_comma
$LN8@ritz_comma:

; 1371 :     (*sp_AIJ_setup_func)(S.A_rows,&S);

	mov	eax, DWORD PTR _S$[ebp+12]
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	push	eax
$LN11@ritz_comma:
	call	DWORD PTR _sp_AIJ_setup_func

; 1372 :   (*sp_constraint_setup_func)
; 1373 :        (web.skel[BODY].max_ord+1 + gen_quant_count,&S);

	mov	edx, DWORD PTR _web+404
	mov	eax, DWORD PTR _web+5528
	add	esp, 8
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	lea	ecx, DWORD PTR [eax+edx+1]
	push	ecx
	call	DWORD PTR _sp_constraint_setup_func

; 1374 :   if ( sp_ordering_func ) (*sp_ordering_func)(&S);

	mov	eax, DWORD PTR _sp_ordering_func
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@ritz_comma
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	eax
	add	esp, 4
$LN6@ritz_comma:

; 1375 :   if ( hessian_linear_metric_flag )

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN5@ritz_comma

; 1376 :   {
; 1377 :     linear_metric_setup(&S,&Met);

	lea	eax, DWORD PTR _S$[ebp]
	push	OFFSET _Met
	push	eax
	call	_linear_metric_setup
	jmp	SHORT $LN12@ritz_comma
$LN5@ritz_comma:

; 1378 :   }
; 1379 :   else if ( web.area_norm_flag )

	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN3@ritz_comma

; 1380 :   { 
; 1381 :     star_metric_setup(&S,&Met);

	lea	ecx, DWORD PTR _S$[ebp]
	push	OFFSET _Met
	push	ecx
	call	_star_metric_setup
$LN12@ritz_comma:
	add	esp, 8
$LN3@ritz_comma:

; 1382 :   }
; 1383 :   do_ritz(&S,lambda,ritzdim,NULL);

	mov	edx, DWORD PTR _ritzdim$[ebp]
	fld	QWORD PTR _lambda$[ebp]
	push	0
	push	edx
	sub	esp, 8
	lea	eax, DWORD PTR _S$[ebp]
	fstp	QWORD PTR [esp]
	push	eax
	call	_do_ritz

; 1384 : 
; 1385 :   free_system(&S);

	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_free_system
	add	esp, 24					; 00000018H

; 1386 :   if ( hessian_linear_metric_flag || web.area_norm_flag ) free_system(&Met);

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN1@ritz_comma
	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN2@ritz_comma
$LN1@ritz_comma:
	push	OFFSET _Met
	call	_free_system
	add	esp, 4
$LN2@ritz_comma:

; 1387 :   temp_free((char*)rhs);

	mov	edx, DWORD PTR _rhs$[ebp]
	push	edx
	call	_temp_free

; 1388 :   hessian_exit(NULL);

	push	0
	call	_hessian_exit
	add	esp, 8

; 1389 : } /* end ritz_command() */

	mov	esp, ebp
	pop	ebp
	ret	0
_ritz_command ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@MLAFAOKO@?$CFd?5?5?$CF20?415f?6?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_lanczos_command
;	COMDAT ??_C@_0N@MLAFAOKO@?$CFd?5?5?$CF20?415f?6?$AA@
CONST	SEGMENT
??_C@_0N@MLAFAOKO@?$CFd?5?5?$CF20?415f?6?$AA@ DB '%d  %20.15f', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _lanczos_command
_TEXT	SEGMENT
_S$ = -356						; size = 232
_evalues$ = -124					; size = 120
__$ArrayPad$ = -4					; size = 4
_lambda$ = 8						; size = 8
_krydim$ = 16						; size = 4
_lanczos_command PROC					; COMDAT

; 925  : { struct linsys S;

	push	ebp
	mov	ebp, esp
	sub	esp, 356				; 00000164H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 926  :   REAL evalues[NPRINT];
; 927  :   int i,nprint;
; 928  :   
; 929  :   hmode = hessian_normal_flag;

	mov	eax, DWORD PTR _hessian_normal_flag

; 930  :   hessian_init(&S,NULL);

	lea	ecx, DWORD PTR _S$[ebp]
	push	0
	push	ecx
	mov	DWORD PTR _hmode, eax
	call	_hessian_init

; 931  :   hess_flag = 1; rhs_flag = 0; 
; 932  :   hessian_fill(&S,NULL); 

	lea	edx, DWORD PTR _S$[ebp]
	push	0
	push	edx
	mov	DWORD PTR _hess_flag, 1
	mov	DWORD PTR _rhs_flag, 0
	call	_hessian_fill

; 933  :   S.lambda = lambda;

	fld	QWORD PTR _lambda$[ebp]

; 934  :   (*sp_AIJ_setup_func)(S.A_rows,&S);

	mov	ecx, DWORD PTR _S$[ebp+12]
	fstp	QWORD PTR _S$[ebp+112]
	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	push	ecx
	call	DWORD PTR _sp_AIJ_setup_func

; 935  :   (*sp_constraint_setup_func)
; 936  :       (web.skel[BODY].max_ord+1 + gen_quant_count,&S);

	mov	eax, DWORD PTR _web+5528
	mov	ecx, DWORD PTR _web+404
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	lea	edx, DWORD PTR [eax+ecx+1]
	push	edx
	call	DWORD PTR _sp_constraint_setup_func

; 937  :   if ( sp_ordering_func ) (*sp_ordering_func)(&S);

	mov	eax, DWORD PTR _sp_ordering_func
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN9@lanczos_co
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	eax
	add	esp, 4
$LN9@lanczos_co:

; 938  :   if ( hessian_linear_metric_flag )

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN8@lanczos_co

; 939  :   {
; 940  :     linear_metric_setup(&S,&Met);

	lea	edx, DWORD PTR _S$[ebp]
	push	OFFSET _Met
	push	edx
	call	_linear_metric_setup
	jmp	SHORT $LN14@lanczos_co
$LN8@lanczos_co:

; 941  :   }
; 942  :   else if ( web.area_norm_flag )

	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN6@lanczos_co

; 943  :   {
; 944  :     star_metric_setup(&S,&Met);

	lea	eax, DWORD PTR _S$[ebp]
	push	OFFSET _Met
	push	eax
	call	_star_metric_setup
$LN14@lanczos_co:
	add	esp, 8
$LN6@lanczos_co:
	push	edi

; 945  :   }
; 946  :   sp_factor(&S,MKL_INDEF);

	lea	ecx, DWORD PTR _S$[ebp]
	push	-2					; fffffffeH
	push	ecx
	call	_sp_factor

; 947  :   (*sp_hess_project_setup_func)(&S);

	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	DWORD PTR _sp_hess_project_setup_func

; 948  :   sprintf(msg,"Eigencounts:    %d <,  %d ==,  %d > \n",S.neg,S.zero,S.pos);

	mov	eax, DWORD PTR _S$[ebp+184]
	mov	ecx, DWORD PTR _S$[ebp+192]
	mov	edx, DWORD PTR _S$[ebp+188]
	push	eax
	mov	eax, DWORD PTR _msg
	push	ecx
	push	edx
	push	OFFSET ??_C@_0CG@NAMCFDKN@Eigencounts?3?5?5?5?5?$CFd?5?$DM?0?5?5?$CFd?5?$DN?$DN?0?5?5?$CF@
	push	eax
	call	_sprintf

; 949  :   outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring

; 950  :   nprint = lanczos(&S,krydim,evalues,NPRINT);

	mov	eax, DWORD PTR _krydim$[ebp]
	push	15					; 0000000fH
	lea	edx, DWORD PTR _evalues$[ebp]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_lanczos
	mov	edi, eax
	add	esp, 52					; 00000034H

; 951  :   /* list, ones near probe value */
; 952  :   for ( i = 0 ; i < nprint ; i++ )

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN3@lanczos_co
	push	esi
	npad	9
$LL5@lanczos_co:

; 953  :   {
; 954  : #ifdef FLOAT128
; 955  :      sprintf(msg,"%d  %*.*Qf\n",i+1,DWIDTH,DPREC,evalues[i]);
; 956  : #elif defined(LONGDOUBLE)
; 957  :      sprintf(msg,"%d  %*.*Lf\n",i+1,DWIDTH,DPREC,evalues[i]);
; 958  : #else
; 959  :      sprintf(msg,"%d  %20.15f\n",i+1,evalues[i]);

	fld	QWORD PTR _evalues$[ebp+eax*8]
	mov	edx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	esi, DWORD PTR [eax+1]
	push	esi
	push	OFFSET ??_C@_0N@MLAFAOKO@?$CFd?5?5?$CF20?415f?6?$AA@
	push	edx
	call	_sprintf

; 960  : #endif 
; 961  :      outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	mov	eax, esi
	add	esp, 24					; 00000018H
	cmp	eax, edi
	jl	SHORT $LL5@lanczos_co
	pop	esi
$LN3@lanczos_co:

; 962  :   }
; 963  :   free_system(&S);

	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_free_system
	add	esp, 4

; 964  :   if ( hessian_linear_metric_flag || web.area_norm_flag ) free_system(&Met);

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	pop	edi
	jne	SHORT $LN1@lanczos_co
	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN2@lanczos_co
$LN1@lanczos_co:
	push	OFFSET _Met
	call	_free_system
	add	esp, 4
$LN2@lanczos_co:

; 965  :   hessian_exit(NULL);

	push	0
	call	_hessian_exit

; 966  : } /* end lanczos_command() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	add	esp, 4
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_lanczos_command ENDP
_TEXT	ENDS
END
