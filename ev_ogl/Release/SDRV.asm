; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\SDRV.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_0BJ@KDBBLPMG@?5Forcing?5positive?5to?5?$CFg?4?$AA@ ; `string'
PUBLIC	??_C@_0EA@BDEGLPOM@sdrv?3?5Intermediate?5matrix?5not?5po@ ; `string'
PUBLIC	??_C@_0DP@MABDCIDA@Internal?5error?3?5sdrv?3?5Diag?$FL?$CFd?$FN?5?$DN@ ; `string'
PUBLIC	__real@3eb0c6f7a0b5ed8d
PUBLIC	??_C@_0P@IEJDBMFO@ysmp?5fill?3?5?$CFd?6?$AA@	; `string'
PUBLIC	__real@0000000000000000
PUBLIC	_snfmod_
EXTRN	_make_pos_def_flag:DWORD
EXTRN	_errmsg:BYTE
EXTRN	_kb_error:PROC
EXTRN	_sprintf:PROC
EXTRN	_msg:DWORD
EXTRN	_hessian_epsilon:QWORD
EXTRN	_printf:PROC
EXTRN	_hessian_quiet_flag:DWORD
EXTRN	_pos_def_warning_flag:DWORD
EXTRN	_mat_null:DWORD
EXTRN	_mat_index:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@3ff0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\sdrv.c
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_0BJ@KDBBLPMG@?5Forcing?5positive?5to?5?$CFg?4?$AA@
CONST	SEGMENT
??_C@_0BJ@KDBBLPMG@?5Forcing?5positive?5to?5?$CFg?4?$AA@ DB ' Forcing pos'
	DB	'itive to %g.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@BDEGLPOM@sdrv?3?5Intermediate?5matrix?5not?5po@
CONST	SEGMENT
??_C@_0EA@BDEGLPOM@sdrv?3?5Intermediate?5matrix?5not?5po@ DB 'sdrv: Inter'
	DB	'mediate matrix not positive definite. Diag[%d] = %g;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@MABDCIDA@Internal?5error?3?5sdrv?3?5Diag?$FL?$CFd?$FN?5?$DN@
CONST	SEGMENT
??_C@_0DP@MABDCIDA@Internal?5error?3?5sdrv?3?5Diag?$FL?$CFd?$FN?5?$DN@ DB 'I'
	DB	'nternal error: sdrv: Diag[%d] = %g; max in row: %g; adding %g'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __real@3eb0c6f7a0b5ed8d
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-006
CONST	ENDS
;	COMDAT ??_C@_0P@IEJDBMFO@ysmp?5fill?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0P@IEJDBMFO@ysmp?5fill?3?5?$CFd?6?$AA@ DB 'ysmp fill: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _snfmod_
_TEXT	SEGMENT
_bound$ = -56						; size = 8
_del$ = -48						; size = 8
tv4367 = -40						; size = 4
_dk$ = -36						; size = 8
_nexti$ = -32						; size = 4
tv4371 = -28						; size = 4
tv4362 = -24						; size = 4
tv4354 = -20						; size = 4
_elt2$ = -16						; size = 8
_i$ = -12						; size = 4
tv1039 = -8						; size = 4
_mu$ = -4						; size = 4
_irow$ = 8						; size = 4
_k$ = 8							; size = 4
_n$ = 8							; size = 4
tv4124 = 12						; size = 4
tv3006 = 12						; size = 4
_j$ = 12						; size = 4
_p$ = 12						; size = 4
_ip$ = 16						; size = 4
_ia$ = 20						; size = 4
_ja$ = 24						; size = 4
_a$ = 28						; size = 4
tv4252 = 32						; size = 4
_d$ = 32						; size = 4
_iju$ = 36						; size = 4
_ju$ = 40						; size = 4
_iu$ = 44						; size = 4
_u$ = 48						; size = 4
tv2999 = 52						; size = 4
_jmax$ = 52						; size = 4
_umax$ = 52						; size = 4
_il$ = 56						; size = 4
_jl$ = 60						; size = 4
_flag_$ = 64						; size = 4
_emax$ = 68						; size = 4
_snfmod_ PROC						; COMDAT

; 433  : {

	push	ebp
	mov	ebp, esp

; 434  :      /* System generated locals */
; 435  :      integer i__1, i__2;
; 436  :      doublereal d__1, d__2, d__3;
; 437  : 
; 438  :      /* Local variables */
; 439  :      STATIC integer jmin, jmax;
; 440  :      STATIC doublereal zero;
; 441  :      STATIC integer irow, i, j, k;
; 442  :      STATIC doublereal sgamma, ukidi, bound;
; 443  :      STATIC integer kkmin, kkmax, nexti, jumuj;
; 444  :      STATIC doublereal dk;
; 445  :      STATIC integer kk, vj;
; 446  :      STATIC doublereal xi;
; 447  :      STATIC integer mu;
; 448  :      STATIC doublereal eltnew, del;
; 449  :      STATIC integer ili;
; 450  :      STATIC doublereal elt, eps, xin, elt2, eps1;
; 451  : 
; 452  :      mat_index = 0 ;  /* number of negatives on diagonal. K.B.*/ 
; 453  :      mat_null = 0 ;  /* number of zeroes on diagonal. K.B.*/ 
; 454  :      pos_def_warning_flag = 0; /* K.B. */
; 455  : 
; 456  : /* ==================================================================end */
; 457  : 
; 458  : /*  ADDITIONAL PARAMETERS */
; 459  : 
; 460  : /*     IL     - INTEGER ONE-DIMENSIONAL WORK ARRAY;  DIMENSION = N */
; 461  : 
; 462  : /*     JL     - INTEGER ONE-DIMENSIONAL WORK ARRAY;  DIMENSION = N */
; 463  : 
; 464  : /*  DEFINITIONS OF INTERNAL PARAMETERS (DURING K-TH STAGE OF ELIMINATION) */
; 465  : 
; 466  : /*     (D(I),I=K,N) CONTAINS THE K-TH ROW OF U (EXPANDED) */
; 467  : 
; 468  : /*     IL(I) POINTS TO THE FIRST NONZERO ELEMENT IN COLUMNS K,...,N OF */
; 469  : /*        ROW I OF U */
; 470  : 
; 471  : /*     JL CONTAINS LISTS OF ROWS TO BE ADDED TO UNELIMINATED ROWS -- */
; 472  : /*        I GE K => JL(I) IS THE FIRST ROW TO BE ADDED TO ROW I */
; 473  : /*        I LT K => JL(I) IS THE ROW FOLLOWING ROW I IN SOME LIST OF ROWS */
; 474  : 
; 475  : /*        IN EITHER CASE, JL(I) = 0 INDICATES THE END OF A LIST */
; 476  : 
; 477  : /*     EMAX is returned as max diagonal addition -- RFA, August 1991 */
; 478  : 
; 479  : /* ----------------------------------------------------------------------- */
; 480  : 
; 481  : /*         REAL  A(1),  D(1), U(1),  DK, UKIDI */
; 482  : 
; 483  : /* ====================  change #2  (insertion) =======================2 */
; 484  : /*         real GAMMA,XI,XIN,EPS,DEL,EPS1,ELT,ELT2,ELTNEW, */
; 485  : /*     *      BOUND,W,EMAX,EK,ZERO */
; 486  :      /* Parameter adjustments */
; 487  :      --jl; --il; --u; --iu; --ju; --iju; --d; --a; --ja; --ia; --ip; --p;

	mov	ecx, DWORD PTR _iu$[ebp]

; 488  : 
; 489  :      /* Function Body */
; 490  :      *flag_ = 0;
; 491  :      zero = 0.;
; 492  :      *emax = zero;

	fldz
	sub	esp, 56					; 00000038H
	mov	edx, 4
	sub	DWORD PTR _il$[ebp], edx
	sub	DWORD PTR _ju$[ebp], edx
	sub	DWORD PTR _iju$[ebp], edx
	sub	DWORD PTR _ja$[ebp], edx
	sub	DWORD PTR _ia$[ebp], edx
	sub	DWORD PTR _ip$[ebp], edx
	sub	DWORD PTR _p$[ebp], edx
	push	ebx
	push	esi
	mov	esi, DWORD PTR _d$[ebp]
	xor	eax, eax
	sub	ecx, edx
	push	edi
	mov	edi, DWORD PTR _jl$[ebp]
	sub	edi, edx
	mov	edx, DWORD PTR _flag_$[ebp]
	mov	DWORD PTR _mat_index, eax
	mov	DWORD PTR _mat_null, eax
	mov	DWORD PTR _pos_def_warning_flag, eax
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _emax$[ebp]

; 493  : /* ==================================================================end */
; 494  : 
; 495  : /* ----CHECK FOR SUFFICIENT STORAGE FOR U */
; 496  :      if (iu[*n + 1] - 1 > *umax) {

	mov	edx, DWORD PTR _n$[ebp]
	fst	QWORD PTR [eax]
	mov	eax, DWORD PTR [edx]
	mov	ebx, 8
	sub	DWORD PTR _u$[ebp], ebx
	sub	DWORD PTR _a$[ebp], ebx
	mov	DWORD PTR _iu$[ebp], ecx
	mov	ecx, DWORD PTR [ecx+eax*4+4]
	sub	esi, ebx
	mov	ebx, DWORD PTR _umax$[ebp]
	lea	edx, DWORD PTR [ecx-1]
	mov	DWORD PTR _jl$[ebp], edi
	cmp	edx, DWORD PTR [ebx]
	jle	SHORT $LN40@snfmod_

; 739  : 
; 740  : /* ** ERROR -- INSUFFICIENT STORAGE FOR U */
; 741  : L107:
; 742  :      *flag_ = *n * 7 + 1;

	mov	edx, DWORD PTR _flag_$[ebp]
	fstp	ST(0)
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	pop	edi
	inc	ecx
	pop	esi
$L107$89402:
	mov	DWORD PTR [edx], ecx
	xor	eax, eax
	pop	ebx

; 743  :      return 0;
; 744  : 
; 745  : } /* snfmod_() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@snfmod_:

; 497  :           goto L107;
; 498  :      }
; 499  : if ( !hessian_quiet_flag ) printf("ysmp fill: %d\n",iu[*n+1]);

	cmp	DWORD PTR _hessian_quiet_flag, 0
	jne	SHORT $LN39@snfmod_
	push	ecx
	fstp	ST(0)
	push	OFFSET ??_C@_0P@IEJDBMFO@ysmp?5fill?3?5?$CFd?6?$AA@
	call	_printf
	fldz
	add	esp, 8
$LN39@snfmod_:

; 500  : 
; 501  : /* ----INITIALIZATION */
; 502  :      i__1 = *n;

	mov	edx, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [edx]

; 503  :      for (k = 1; k <= i__1; ++k) {

	mov	eax, 1
	cmp	ecx, eax
	jl	SHORT $LN36@snfmod_
$LN38@snfmod_:

; 504  :           d[k] = 0.;

	fst	QWORD PTR [esi+eax*8]

; 505  : /* L1: */
; 506  :           jl[k] = 0;

	mov	DWORD PTR [edi+eax*4], 0
	inc	eax
	cmp	eax, ecx
	jle	SHORT $LN38@snfmod_
$LN36@snfmod_:

; 507  :      }
; 508  : /* ====================  change #3  (insertion) =======================3 */
; 509  : /* Calculate GAMMA and XI, the largest magnitudes of the diag. and  off- */
; 510  : /* diag. elements, respectively. When the diag. elts. are stored first */
; 511  : /* in A in each row (PATH = 4 or 5 in ODRV), GAMMA=max(GAMMA,A(IA(i))), */
; 512  : /* i=1,...,IA(n+1)-1. We assume that this IS the case. (If this were */
; 513  : /* later changed, then for each row I we would have to loop through KK */
; 514  : /* = KKMIN,..., KKMAX  where KKMIN = IA(I), KKMAX = IA(I+1)-1, and test */
; 515  : /* whether I = JA(KK), ie. row index = column index. If this equality */
; 516  : /* holds, the element is a diagonal). Then calculate DEL and BOUND: */
; 517  : /* DEL =  max ( max(XI,GAMMA)*EPS, EPS) where EPS is a small given */
; 518  : /* number, and  BOUND = max ( XI/N, GAMMA, EPS). */
; 519  : /* ===================================================================== 
; 520  : */
; 521  :      eps = 1e-6;
; 522  :      sgamma = zero;
; 523  :      xi = zero;
; 524  :      i__1 = *n;

	mov	eax, DWORD PTR [edx]
	fld	ST(0)
	fld	ST(1)
	mov	DWORD PTR tv1039[ebp], eax

; 525  :      for (irow = 1; irow <= i__1; ++irow) {

	mov	DWORD PTR _irow$[ebp], 1
	cmp	eax, 1
	jl	$LN47@snfmod_
$LN35@snfmod_:

; 526  : /* Computing MAX */
; 527  :           d__2 = sgamma, d__3 = (d__1 = a[ia[irow]], fabs(d__1));

	mov	edi, DWORD PTR _ia$[ebp]
	mov	edx, DWORD PTR _irow$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [edi+edx*4]
	fld	QWORD PTR [eax+ecx*8]
	fabs

; 528  :           sgamma = max(d__2,d__3);

	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN139@snfmod_
	fstp	ST(2)
	jmp	SHORT $LN44@snfmod_
$LN139@snfmod_:
	fstp	ST(0)
$LN44@snfmod_:

; 529  :           kkmin = ia[irow] + 1;
; 530  :           kkmax = ia[irow + 1] - 1;

	mov	edx, DWORD PTR [edi+edx*4+4]
	lea	eax, DWORD PTR [ecx+1]
	dec	edx

; 531  :           if (kkmin > kkmax) {

	cmp	eax, edx
	jg	$L21$89412

; 532  :                 goto L21;
; 533  :           }
; 534  :           i__2 = kkmax;
; 535  :           for (kk = kkmin; kk <= i__2; ++kk) {

	mov	ecx, edx
	sub	ecx, eax
	inc	ecx
	mov	ebx, eax
	cmp	ecx, 4
	jl	SHORT $LC81@snfmod_
	mov	ecx, DWORD PTR _a$[ebp]
	lea	edi, DWORD PTR [ecx+eax*8+16]
	mov	ecx, edx
	sub	ecx, eax
	sub	ecx, 3
	shr	ecx, 2
	inc	ecx
	lea	ebx, DWORD PTR [eax+ecx*4]
$LN90@snfmod_:

; 536  : /* Computing MAX */
; 537  :                 d__2 = xi, d__3 = (d__1 = a[kk], fabs(d__1));

	fld	QWORD PTR [edi-16]
	fabs

; 538  :                 xi = max(d__2,d__3);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN149@snfmod_
	fstp	ST(1)
	jmp	SHORT $LN83@snfmod_
$LN149@snfmod_:
	fstp	ST(0)
$LN83@snfmod_:

; 536  : /* Computing MAX */
; 537  :                 d__2 = xi, d__3 = (d__1 = a[kk], fabs(d__1));

	fld	QWORD PTR [edi-8]
	fabs

; 538  :                 xi = max(d__2,d__3);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN152@snfmod_
	fstp	ST(1)
	jmp	SHORT $LN85@snfmod_
$LN152@snfmod_:
	fstp	ST(0)
$LN85@snfmod_:

; 536  : /* Computing MAX */
; 537  :                 d__2 = xi, d__3 = (d__1 = a[kk], fabs(d__1));

	fld	QWORD PTR [edi]
	fabs

; 538  :                 xi = max(d__2,d__3);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN155@snfmod_
	fstp	ST(1)
	jmp	SHORT $LN87@snfmod_
$LN155@snfmod_:
	fstp	ST(0)
$LN87@snfmod_:

; 536  : /* Computing MAX */
; 537  :                 d__2 = xi, d__3 = (d__1 = a[kk], fabs(d__1));

	fld	QWORD PTR [edi+8]
	fabs

; 538  :                 xi = max(d__2,d__3);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN158@snfmod_
	fstp	ST(1)
	jmp	SHORT $LN89@snfmod_
$LN158@snfmod_:
	fstp	ST(0)
$LN89@snfmod_:

; 532  :                 goto L21;
; 533  :           }
; 534  :           i__2 = kkmax;
; 535  :           for (kk = kkmin; kk <= i__2; ++kk) {

	add	edi, 32					; 00000020H
	dec	ecx
	jne	SHORT $LN90@snfmod_
$LC81@snfmod_:
	cmp	ebx, edx
	jg	SHORT $L21$89412
	mov	ecx, DWORD PTR _a$[ebp]
$LC31@snfmod_:

; 536  : /* Computing MAX */
; 537  :                 d__2 = xi, d__3 = (d__1 = a[kk], fabs(d__1));

	fld	QWORD PTR [ecx+ebx*8]
	fabs

; 538  :                 xi = max(d__2,d__3);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN164@snfmod_
	fstp	ST(1)
	jmp	SHORT $LN46@snfmod_
$LN164@snfmod_:
	fstp	ST(0)
$LN46@snfmod_:
	inc	ebx

; 532  :                 goto L21;
; 533  :           }
; 534  :           i__2 = kkmax;
; 535  :           for (kk = kkmin; kk <= i__2; ++kk) {

	cmp	ebx, edx
	jle	SHORT $LC31@snfmod_
$L21$89412:

; 525  :      for (irow = 1; irow <= i__1; ++irow) {

	mov	eax, DWORD PTR _irow$[ebp]
	inc	eax
	mov	DWORD PTR _irow$[ebp], eax
	cmp	eax, DWORD PTR tv1039[ebp]
	jle	$LN35@snfmod_

; 539  : /* L20: */
; 540  :           }
; 541  : L21:
; 542  :           ;
; 543  :      }
; 544  :      eps1 = max(sgamma,xi) * eps;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN47@snfmod_
	fld	ST(1)
	jmp	SHORT $LN48@snfmod_
$LN47@snfmod_:
	fld	ST(0)
$LN48@snfmod_:
	fld	QWORD PTR __real@3eb0c6f7a0b5ed8d
	fmul	ST(1), ST(0)

; 545  :      del = max(eps,eps1);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN49@snfmod_
	fstp	ST(1)
	fst	QWORD PTR _del$[ebp]
	jmp	SHORT $LN50@snfmod_
$LN49@snfmod_:
	fxch	ST(1)
	fstp	QWORD PTR _del$[ebp]
$LN50@snfmod_:

; 546  :      xin = (doublereal) (*n);
; 547  :      xin = xi / xin;

	fild	DWORD PTR tv1039[ebp]
	fdivp	ST(2), ST(0)

; 548  : /* Computing MAX */
; 549  :      d__1 = max(sgamma,xin);

	fxch	ST(2)
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN176@snfmod_
	fstp	ST(1)
	jmp	SHORT $LN52@snfmod_
$LN176@snfmod_:
	fstp	ST(0)
$LN52@snfmod_:

; 550  :      bound = max(d__1,eps);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN180@snfmod_
	fstp	ST(1)
	jmp	SHORT $LN306@snfmod_
$LN180@snfmod_:
	fstp	ST(0)
$LN306@snfmod_:

; 551  : /* ==================================================================end 
; 552  : */
; 553  : 
; 554  : /* ----FOR EACH ROW K */
; 555  :      i__1 = *n;
; 556  :      for (k = 1; k <= i__1; ++k) {

	mov	eax, 1
	fstp	QWORD PTR _bound$[ebp]
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR tv1039[ebp], eax
	jl	$LN304@snfmod_
	mov	eax, DWORD PTR _iu$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, eax
	mov	DWORD PTR tv4354[ebp], ecx
	mov	ecx, DWORD PTR _iju$[ebp]
	sub	ecx, eax
	mov	DWORD PTR tv4362[ebp], ecx
	mov	ecx, DWORD PTR _il$[ebp]
	sub	ecx, eax
	mov	DWORD PTR tv4367[ebp], ecx
	mov	ecx, DWORD PTR _jl$[ebp]
	lea	edx, DWORD PTR [eax+4]
	sub	ecx, eax
	mov	DWORD PTR tv4252[ebp], edx
	mov	DWORD PTR tv4371[ebp], ecx
$LN120@snfmod_:

; 557  : 
; 558  : /* ------INITIALIZE K-TH ROW WITH ELEMENTS NONZERO IN ROW P(K) OF M */
; 559  : 
; 560  : /* L3: */
; 561  :           jmin = ia[p[k]];

	mov	eax, DWORD PTR tv4354[ebp]
	mov	edi, DWORD PTR tv4252[ebp]
	mov	ecx, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR _ia$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	lea	ecx, DWORD PTR [edx+ecx*4]

; 562  :           jmax = ia[p[k] + 1] - 1;

	mov	ecx, DWORD PTR [ecx+4]
	dec	ecx
	mov	DWORD PTR _jmax$[ebp], ecx

; 563  :           if (jmin > jmax) {

	cmp	eax, ecx
	jg	$L5$89421

; 564  :                 goto L5;
; 565  :           }
; 566  :           i__2 = jmax;
; 567  :           for (j = jmin; j <= i__2; ++j) {

	mov	ebx, ecx
	sub	ebx, eax
	inc	ebx
	mov	edx, eax
	cmp	ebx, 4
	jl	SHORT $LN121@snfmod_
	mov	edx, DWORD PTR _a$[ebp]
	sub	ecx, eax
	sub	ecx, 3
	lea	edi, DWORD PTR [edx+eax*8+16]
	mov	edx, DWORD PTR _ja$[ebp]
	shr	ecx, 2
	inc	ecx
	lea	edx, DWORD PTR [edx+eax*4+8]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _j$[ebp], eax
$LN119@snfmod_:

; 568  :                 vj = ip[ja[j]];

	mov	eax, DWORD PTR [edx-8]
	mov	ebx, DWORD PTR _ip$[ebp]
	mov	eax, DWORD PTR [ebx+eax*4]

; 569  :                 if (k <= vj) {

	cmp	DWORD PTR _k$[ebp], eax
	jg	SHORT $LN93@snfmod_

; 570  :                      d[vj] = a[j];

	fld	QWORD PTR [edi-16]
	fstp	QWORD PTR [esi+eax*8]
$LN93@snfmod_:

; 568  :                 vj = ip[ja[j]];

	mov	eax, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [ebx+eax*4]

; 569  :                 if (k <= vj) {

	cmp	DWORD PTR _k$[ebp], eax
	jg	SHORT $LN94@snfmod_

; 570  :                      d[vj] = a[j];

	fld	QWORD PTR [edi-8]
	fstp	QWORD PTR [esi+eax*8]
$LN94@snfmod_:

; 568  :                 vj = ip[ja[j]];

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [ebx+eax*4]

; 569  :                 if (k <= vj) {

	cmp	DWORD PTR _k$[ebp], eax
	jg	SHORT $LN95@snfmod_

; 570  :                      d[vj] = a[j];

	fld	QWORD PTR [edi]
	fstp	QWORD PTR [esi+eax*8]
$LN95@snfmod_:

; 568  :                 vj = ip[ja[j]];

	mov	eax, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ebx+eax*4]

; 569  :                 if (k <= vj) {

	cmp	DWORD PTR _k$[ebp], eax
	jg	SHORT $LN96@snfmod_

; 570  :                      d[vj] = a[j];

	fld	QWORD PTR [edi+8]
	fstp	QWORD PTR [esi+eax*8]
$LN96@snfmod_:

; 564  :                 goto L5;
; 565  :           }
; 566  :           i__2 = jmax;
; 567  :           for (j = jmin; j <= i__2; ++j) {

	add	edx, 16					; 00000010H
	add	edi, 32					; 00000020H
	dec	ecx
	jne	SHORT $LN119@snfmod_
	mov	edx, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _jmax$[ebp]
	mov	edi, DWORD PTR tv4252[ebp]
$LN121@snfmod_:
	cmp	edx, ecx
	jg	SHORT $L5$89421
$LC24@snfmod_:

; 568  :                 vj = ip[ja[j]];

	mov	eax, DWORD PTR _ja$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	ebx, DWORD PTR _ip$[ebp]
	mov	eax, DWORD PTR [ebx+eax*4]

; 569  :                 if (k <= vj) {

	cmp	DWORD PTR _k$[ebp], eax
	jg	SHORT $LN23@snfmod_

; 570  :                      d[vj] = a[j];

	mov	ebx, DWORD PTR _a$[ebp]
	fld	QWORD PTR [ebx+edx*8]
	fstp	QWORD PTR [esi+eax*8]
$LN23@snfmod_:

; 564  :                 goto L5;
; 565  :           }
; 566  :           i__2 = jmax;
; 567  :           for (j = jmin; j <= i__2; ++j) {

	inc	edx
	cmp	edx, ecx
	jle	SHORT $LC24@snfmod_
$L5$89421:

; 571  :                 }
; 572  : /* L4: */
; 573  :           }
; 574  : 
; 575  : /* ------MODIFY K-TH ROW BY ADDING IN THOSE ROWS I WITH U(I,K) NE 0 */
; 576  : 
; 577  : /* ------FOR EACH ROW I TO BE ADDED IN */
; 578  : L5:
; 579  :           dk = d[k];
; 580  :           i = jl[k];

	mov	edx, DWORD PTR tv4371[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR [edx+edi]
	fld	QWORD PTR [esi+ecx*8]
	fst	QWORD PTR _dk$[ebp]
	mov	DWORD PTR _i$[ebp], eax

; 581  : L6:
; 582  :           if (i == 0) {

	test	eax, eax
	je	$L9$89428
	mov	ebx, DWORD PTR _u$[ebp]
$L6$89426:

; 583  :                 goto L9;
; 584  :           }
; 585  :           nexti = jl[i];
; 586  : 
; 587  : /* --------COMPUTE MULTIPLIER AND UPDATE DIAGONAL ELEMENT */
; 588  :           ili = il[i];

	mov	edx, DWORD PTR _il$[ebp]

; 589  :           ukidi = -u[ili] * d[i];

	fld	QWORD PTR [esi+eax*8]
	mov	edi, DWORD PTR [edx+eax*4]
	fmul	QWORD PTR [ebx+edi*8]
	mov	ecx, DWORD PTR _jl$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]

; 591  :           u[ili] = ukidi;
; 592  : 
; 593  : /* --------ADD MULTIPLE OF ROW I TO K-TH ROW ... */
; 594  :           jmin = ili + 1;
; 595  :           jmax = iu[i + 1] - 1;

	mov	edx, DWORD PTR _iu$[ebp]
	fchs
	inc	edi
	fld	QWORD PTR [ebx+edi*8-8]
	mov	DWORD PTR _nexti$[ebp], ecx
	fmul	ST(0), ST(1)
	faddp	ST(2), ST(0)
	fst	QWORD PTR [ebx+edi*8-8]
	mov	edx, DWORD PTR [edx+eax*4+4]
	dec	edx
	mov	DWORD PTR _jmax$[ebp], edx

; 596  :           if (jmin > jmax) {

	cmp	edi, edx
	jg	$LN217@snfmod_

; 597  :                 goto L8;
; 598  :           }
; 599  :           mu = iju[i] - iu[i];

	mov	ecx, DWORD PTR _iju$[ebp]
	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _iu$[ebp]
	sub	ebx, DWORD PTR [ecx+eax*4]

; 600  :           i__2 = jmax;
; 601  :           for (j = jmin; j <= i__2; ++j) {

	mov	ecx, edx
	sub	ecx, edi
	inc	ecx
	mov	DWORD PTR _mu$[ebp], ebx
	mov	DWORD PTR _j$[ebp], edi
	cmp	ecx, 4
	jl	SHORT $LN116@snfmod_

; 597  :                 goto L8;
; 598  :           }
; 599  :           mu = iju[i] - iu[i];

	mov	eax, DWORD PTR _u$[ebp]
	sub	edx, edi
	sub	edx, 3
	lea	ecx, DWORD PTR [eax+edi*8+16]
	mov	eax, DWORD PTR _ju$[ebp]
	add	ebx, edi
	shr	edx, 2
	inc	edx
	lea	eax, DWORD PTR [eax+ebx*4]
	lea	ebx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR _j$[ebp], ebx

; 600  :           i__2 = jmax;
; 601  :           for (j = jmin; j <= i__2; ++j) {

$LN100@snfmod_:

; 602  : /* L7: */
; 603  :                 d[ju[mu + j]] += ukidi * u[j];

	fld	QWORD PTR [ecx-16]
	mov	ebx, DWORD PTR [eax]
	fmul	ST(0), ST(1)
	lea	ebx, DWORD PTR [esi+ebx*8]
	add	eax, 16					; 00000010H
	add	ecx, 32					; 00000020H
	dec	edx
	fadd	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [eax-12]
	fld	QWORD PTR [ecx-40]
	lea	ebx, DWORD PTR [esi+ebx*8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [eax-8]
	fld	QWORD PTR [ecx-32]
	lea	ebx, DWORD PTR [esi+ebx*8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [eax-4]
	fld	QWORD PTR [ecx-24]
	lea	ebx, DWORD PTR [esi+ebx*8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]
	jne	SHORT $LN100@snfmod_

; 597  :                 goto L8;
; 598  :           }
; 599  :           mu = iju[i] - iu[i];

	mov	ebx, DWORD PTR _mu$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _jmax$[ebp]
$LN116@snfmod_:

; 600  :           i__2 = jmax;
; 601  :           for (j = jmin; j <= i__2; ++j) {

	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN226@snfmod_
	add	ebx, ecx
	mov	ecx, DWORD PTR _ju$[ebp]
	lea	ecx, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR tv2999[ebp], ecx
	mov	ecx, DWORD PTR _j$[ebp]
$LC18@snfmod_:

; 602  : /* L7: */
; 603  :                 d[ju[mu + j]] += ukidi * u[j];

	mov	ebx, DWORD PTR tv2999[ebp]
	mov	ebx, DWORD PTR [ebx]
	add	DWORD PTR tv2999[ebp], 4
	lea	ebx, DWORD PTR [esi+ebx*8]
	mov	DWORD PTR tv3006[ebp], ebx
	mov	ebx, DWORD PTR _u$[ebp]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR tv3006[ebp]
	fmul	ST(0), ST(1)
	inc	ecx
	fadd	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]
	cmp	ecx, edx
	jle	SHORT $LC18@snfmod_

; 600  :           i__2 = jmax;
; 601  :           for (j = jmin; j <= i__2; ++j) {

	mov	ebx, DWORD PTR _mu$[ebp]
$LN226@snfmod_:

; 604  :           }
; 605  : 
; 606  : /* --------... AND ADD I TO ROW LIST FOR NEXT NONZERO ENTRY */
; 607  :           il[i] = jmin;

	mov	edx, DWORD PTR _il$[ebp]
	mov	ecx, DWORD PTR _jl$[ebp]
	mov	DWORD PTR [edx+eax*4], edi

; 608  :           j = ju[mu + jmin];

	mov	edx, DWORD PTR _ju$[ebp]
	add	ebx, edi
	mov	edx, DWORD PTR [edx+ebx*4]

; 609  :           jl[i] = jl[j];

	mov	edi, DWORD PTR [ecx+edx*4]

; 610  :           jl[j] = i;

	mov	ebx, DWORD PTR _u$[ebp]
	mov	DWORD PTR [ecx+eax*4], edi
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR _nexti$[ebp]
$LN217@snfmod_:
	fstp	ST(0)
$L8$89430:

; 611  : 
; 612  : L8:
; 613  :           i = nexti;

	mov	eax, ecx
	mov	DWORD PTR _i$[ebp], ecx
	test	ecx, ecx
	jne	$L6$89426

; 590  :           dk += ukidi * u[ili];

	mov	edi, DWORD PTR tv4252[ebp]
	fst	QWORD PTR _dk$[ebp]
$L9$89428:

; 614  :           goto L6;
; 615  : 
; 616  : /* ====================  change #4  (replacement) =====================4 */
; 617  : /* WAS: */
; 618  : /* ------CHECK FOR ZERO PIVOT */
; 619  : /*  9        IF (DK.EQ.0)  GO TO 108 */
; 620  : /* ===================================================================== */
; 621  : /* STATEMENT 9 ABOVE WILL BE MODIFIED TO RESET Dk IN THE EVENT THE */
; 622  : /* THE MATRIX IS NOT SUFF. POSITIVE-DEFINITE. NOTE THAT EVEN WHEN Dk>0, */
; 623  : /* IT MAY BE MODIFIED IF THE MATRIX IS NOT POS. DEF! */
; 624  : 
; 625  : /* Dk is set as:  Dk = MAX ( ABS(Dk), DEL, (ELT**2)/BOUND), where */
; 626  : /* ELT is the largest magnitude among the elements in the Kth row of U. */
; 627  : /* This restriction guarantees that all elts. of D are strictly positive */
; 628  : /* and that the elts. of the factors satisfy a uniform bound. */
; 629  : /* [    Recall that we work with the auxiliary quantities  Vik = Uik * Dk. */
; 630  : /*      The bound we want to impose on the elts. of U, */
; 631  : /*             ( max(Uik)**2 )  * Dk  <=  BOUND, is equivalent to */
; 632  : /*             ( max(Vik)**2 )  / Dk  <=  BOUND, or */
; 633  : /*             Dk    >=     (max(Vik)**2) / BOUND.) */
; 634  : /*      The value for ELT = max(Vik), max over i for fixed k, is found by */
; 635  : /*      looping through the appropriate elements of U. These elements */
; 636  : /*      are currently stored in part of D.  ] */
; 637  : 
; 638  : /* ===================================================================== */
; 639  : 
; 640  : L9:
; 641  : /* ===================================================================== */
; 642  :           elt = zero;
; 643  :           jmin = iu[k];
; 644  :           jmax = iu[k + 1] - 1;
; 645  :           mu = iju[k] - jmin;

	mov	ecx, DWORD PTR tv4362[ebp]
	fld	ST(1)
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [ecx+edi]
	dec	edx
	sub	ebx, eax

; 646  :           if (jmin > jmax) {

	cmp	eax, edx
	jg	$L28$89435

; 650  :           for (j = jmin; j <= i__2; ++j) {

	mov	ecx, edx
	sub	ecx, eax
	inc	ecx
	mov	DWORD PTR _j$[ebp], eax
	cmp	ecx, 4
	jl	SHORT $LN123@snfmod_

; 647  :                 goto L28;
; 648  :           }
; 649  :           i__2 = jmax;

	mov	edi, DWORD PTR _ju$[ebp]
	lea	ecx, DWORD PTR [ebx+eax]
	lea	edi, DWORD PTR [edi+ecx*4+8]
	mov	ecx, edx
	sub	ecx, eax
	sub	ecx, 3
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _j$[ebp], eax

; 650  :           for (j = jmin; j <= i__2; ++j) {

$LN111@snfmod_:

; 651  :                 eltnew = (d__1 = d[ju[mu + j]], fabs(d__1));

	mov	eax, DWORD PTR [edi-8]
	fld	QWORD PTR [esi+eax*8]
	fabs

; 652  :                 elt = max(elt,eltnew);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN242@snfmod_
	fstp	ST(1)
	jmp	SHORT $LN104@snfmod_
$LN242@snfmod_:
	fstp	ST(0)
$LN104@snfmod_:

; 651  :                 eltnew = (d__1 = d[ju[mu + j]], fabs(d__1));

	mov	eax, DWORD PTR [edi-4]
	fld	QWORD PTR [esi+eax*8]
	fabs

; 652  :                 elt = max(elt,eltnew);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN245@snfmod_
	fstp	ST(1)
	jmp	SHORT $LN106@snfmod_
$LN245@snfmod_:
	fstp	ST(0)
$LN106@snfmod_:

; 651  :                 eltnew = (d__1 = d[ju[mu + j]], fabs(d__1));

	mov	eax, DWORD PTR [edi]
	fld	QWORD PTR [esi+eax*8]
	fabs

; 652  :                 elt = max(elt,eltnew);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN248@snfmod_
	fstp	ST(1)
	jmp	SHORT $LN108@snfmod_
$LN248@snfmod_:
	fstp	ST(0)
$LN108@snfmod_:

; 651  :                 eltnew = (d__1 = d[ju[mu + j]], fabs(d__1));

	mov	eax, DWORD PTR [edi+4]
	fld	QWORD PTR [esi+eax*8]
	fabs

; 652  :                 elt = max(elt,eltnew);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN251@snfmod_
	fstp	ST(1)
	jmp	SHORT $LN110@snfmod_
$LN251@snfmod_:
	fstp	ST(0)
$LN110@snfmod_:

; 647  :                 goto L28;
; 648  :           }
; 649  :           i__2 = jmax;

	add	edi, 16					; 00000010H
	dec	ecx
	jne	SHORT $LN111@snfmod_
	mov	edi, DWORD PTR tv4252[ebp]
$LN123@snfmod_:

; 650  :           for (j = jmin; j <= i__2; ++j) {

	cmp	DWORD PTR _j$[ebp], edx
	jg	SHORT $L28$89435
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _ju$[ebp]
	add	ebx, eax
	sub	edx, eax
	lea	ecx, DWORD PTR [ecx+ebx*4]
	inc	edx
$LC14@snfmod_:

; 651  :                 eltnew = (d__1 = d[ju[mu + j]], fabs(d__1));

	mov	eax, DWORD PTR [ecx]
	fld	QWORD PTR [esi+eax*8]
	fabs

; 652  :                 elt = max(elt,eltnew);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN259@snfmod_
	fstp	ST(1)
	jmp	SHORT $LN56@snfmod_
$LN259@snfmod_:
	fstp	ST(0)
$LN56@snfmod_:

; 650  :           for (j = jmin; j <= i__2; ++j) {

	add	ecx, 4
	dec	edx
	jne	SHORT $LC14@snfmod_
$L28$89435:

; 653  : /* L26: */
; 654  :           }
; 655  : L28:
; 656  : 
; 657  :           elt2 = elt * elt;

	fld	ST(0)
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _elt2$[ebp]

; 658  : #ifdef OLDWAY
; 659  : /* Computing MAX */
; 660  :           d__1 = fabs(dk), d__1 = max(d__1,del), d__2 = elt2 / bound;
; 661  :           dk = max(d__1,d__2);
; 662  :           ek = dk - w;
; 663  :           if (ek > *emax) {
; 664  :                 *emax = ek;
; 665  :                 *flag_ = -p[k];
; 666  :           }
; 667  : #else
; 668  :     /* don't try to make pos def; just keep diag nonzero */
; 669  :     /* K.B. 8/7/93 */
; 670  :     if ( fabs(dk) <= hessian_epsilon )

	fld	ST(1)
	fabs
	fld	QWORD PTR _hessian_epsilon
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 1
	jne	$LN262@snfmod_

; 671  :      {  
; 672  :         sprintf(msg,"Internal error: sdrv: Diag[%d] = %g; max in row: %g; adding %g",k,(DOUBLE)dk,(DOUBLE)elt,(DOUBLE)hessian_epsilon);

	mov	ecx, DWORD PTR _k$[ebp]

; 676  : 
; 677  :         mat_null++;

	fstp	ST(3)
	mov	edx, DWORD PTR _msg
	fxch	ST(2)
	sub	esp, 24					; 00000018H
	fstp	QWORD PTR [esp+16]
	fxch	ST(1)
	fstp	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	ecx
	push	OFFSET ??_C@_0DP@MABDCIDA@Internal?5error?3?5sdrv?3?5Diag?$FL?$CFd?$FN?5?$DN@
	push	edx
	call	_sprintf
	add	esp, 36					; 00000024H
	cmp	DWORD PTR _hessian_quiet_flag, 0
	jne	SHORT $LN126@snfmod_

; 673  :         if ( !hessian_quiet_flag ) 
; 674  :           kb_error(1647,msg,WARNING);

	mov	eax, DWORD PTR _msg
	push	2
	push	eax
	push	1647					; 0000066fH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN126@snfmod_:

; 675  :         dk = hessian_epsilon;

	fld	QWORD PTR _hessian_epsilon

; 676  : 
; 677  :         mat_null++;

	inc	DWORD PTR _mat_null
	fld	ST(0)
	fst	QWORD PTR _dk$[ebp]
	fldz
	fxch	ST(2)
$LN127@snfmod_:

; 678  :      }
; 679  :     /* K.B. 12/28/93 */
; 680  :     if ( dk < -hessian_epsilon )

	fchs
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN9@snfmod_

; 681  :      {
; 682  :         mat_index++;
; 683  :         sprintf(errmsg,"sdrv: Intermediate matrix not positive definite. Diag[%d] = %g;",k,(DOUBLE)dk);

	mov	ecx, DWORD PTR _k$[ebp]

; 694  : 
; 695  :         pos_def_warning_flag = 1;

	fstp	ST(1)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	push	OFFSET ??_C@_0EA@BDEGLPOM@sdrv?3?5Intermediate?5matrix?5not?5po@
	mov	ebx, 1
	add	DWORD PTR _mat_index, ebx
	push	OFFSET _errmsg
	call	_sprintf
	mov	ecx, DWORD PTR _emax$[ebp]
	fld	QWORD PTR [ecx]
	add	esp, 20					; 00000014H
	fld	QWORD PTR _dk$[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN8@snfmod_

; 684  :         if ( dk < *emax ) { *emax = dk; *flag_ = -p[k];  }

	mov	edx, DWORD PTR tv4354[ebp]
	fst	QWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+edi]
	mov	ecx, DWORD PTR _flag_$[ebp]
	neg	eax
	mov	DWORD PTR [ecx], eax
$LN8@snfmod_:

; 685  :         if ( make_pos_def_flag )

	cmp	DWORD PTR _make_pos_def_flag, 0
	je	SHORT $LN7@snfmod_

; 686  :         {
; 687  :           d__1 = fabs(dk), d__1 = max(d__1,del), d__2 = elt2 / bound;

	fabs
	fld	QWORD PTR _del$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN274@snfmod_
	fstp	ST(1)
	jmp	SHORT $LN58@snfmod_
$LN262@snfmod_:

; 676  : 
; 677  :         mat_null++;

	fstp	ST(1)

; 658  : #ifdef OLDWAY
; 659  : /* Computing MAX */
; 660  :           d__1 = fabs(dk), d__1 = max(d__1,del), d__2 = elt2 / bound;
; 661  :           dk = max(d__1,d__2);
; 662  :           ek = dk - w;
; 663  :           if (ek > *emax) {
; 664  :                 *emax = ek;
; 665  :                 *flag_ = -p[k];
; 666  :           }
; 667  : #else
; 668  :     /* don't try to make pos def; just keep diag nonzero */
; 669  :     /* K.B. 8/7/93 */
; 670  :     if ( fabs(dk) <= hessian_epsilon )

	jmp	SHORT $LN127@snfmod_
$LN274@snfmod_:

; 686  :         {
; 687  :           d__1 = fabs(dk), d__1 = max(d__1,del), d__2 = elt2 / bound;

	fstp	ST(0)
$LN58@snfmod_:
	fld	QWORD PTR _elt2$[ebp]
	fdiv	QWORD PTR _bound$[ebp]

; 688  :           dk = max(d__1,d__2);

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN277@snfmod_
	fstp	ST(0)
	jmp	SHORT $LN307@snfmod_
$LN277@snfmod_:
	fstp	ST(1)
$LN307@snfmod_:

; 689  :           sprintf(errmsg+strlen(msg)," Forcing positive to %g.",(DOUBLE)dk);

	mov	eax, DWORD PTR _msg
	fst	QWORD PTR _dk$[ebp]
	lea	edx, DWORD PTR [eax+1]
$LN115@snfmod_:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LN115@snfmod_
	sub	esp, 8
	sub	eax, edx
	fstp	QWORD PTR [esp]
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BJ@KDBBLPMG@?5Forcing?5positive?5to?5?$CFg?4?$AA@
	push	edx
	call	_sprintf
	fld	QWORD PTR _dk$[ebp]
	add	esp, 16					; 00000010H
$LN7@snfmod_:

; 690  :         }
; 691  :         if (!pos_def_warning_flag) 

	cmp	DWORD PTR _pos_def_warning_flag, 0
	jne	SHORT $LN5@snfmod_

; 692  :         if ( !hessian_quiet_flag )  

	cmp	DWORD PTR _hessian_quiet_flag, 0
	jne	SHORT $LN5@snfmod_

; 693  :           kb_error(1648,errmsg,WARNING);

	push	2
	fstp	ST(0)
	push	OFFSET _errmsg
	push	1648					; 00000670H
	call	_kb_error
	fld	QWORD PTR _dk$[ebp]
	add	esp, 12					; 0000000cH
$LN5@snfmod_:

; 694  : 
; 695  :         pos_def_warning_flag = 1;

	fldz
	mov	DWORD PTR _pos_def_warning_flag, ebx
	fxch	ST(1)
$LN9@snfmod_:

; 696  :      }
; 697  : #endif
; 698  : 
; 699  : /* =================================================================e
; 700  : nd */
; 701  : /* L30: */
; 702  : /* ------SAVE DIAGONAL ELEMENT */
; 703  :           d[k] = 1 / dk;

	fld1
	mov	eax, DWORD PTR _k$[ebp]
	fdivrp	ST(1), ST(0)
	fstp	QWORD PTR [esi+eax*8]

; 704  : 
; 705  : /* ------SAVE NONZERO ENTRIES IN K-TH ROW OF U ... */
; 706  :           jmin = iu[k];

	mov	eax, DWORD PTR tv4252[ebp]

; 707  :           jmax = iu[k + 1] - 1;

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax]
	dec	edx
	mov	DWORD PTR _jmax$[ebp], edx

; 708  :           if (jmin > jmax) {

	cmp	edi, edx
	jg	$L11$89455

; 709  :                 goto L11;
; 710  :           }
; 711  :           mu = iju[k] - jmin;

	mov	ecx, DWORD PTR tv4362[ebp]
	mov	ebx, DWORD PTR [ecx+eax]

; 712  :           i__2 = jmax;
; 713  :           for (j = jmin; j <= i__2; ++j) {

	mov	ecx, edx
	sub	ecx, edi
	sub	ebx, edi
	inc	ecx
	mov	DWORD PTR _mu$[ebp], ebx
	mov	eax, edi
	cmp	ecx, 4
	jl	SHORT $LC113@snfmod_

; 709  :                 goto L11;
; 710  :           }
; 711  :           mu = iju[k] - jmin;

	mov	eax, DWORD PTR _u$[ebp]
	sub	edx, edi
	sub	edx, 3
	lea	ecx, DWORD PTR [eax+edi*8+16]
	mov	eax, DWORD PTR _ju$[ebp]
	add	ebx, edi
	shr	edx, 2
	inc	edx
	lea	eax, DWORD PTR [eax+ebx*4+8]
	lea	ebx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR _j$[ebp], ebx

; 712  :           i__2 = jmax;
; 713  :           for (j = jmin; j <= i__2; ++j) {

$LN114@snfmod_:

; 714  :                 jumuj = ju[mu + j];

	mov	ebx, DWORD PTR [eax-8]

; 715  :                 u[j] = d[jumuj];

	fld	QWORD PTR [esi+ebx*8]

; 716  : /* L10: */
; 717  :                 d[jumuj] = 0.;

	add	eax, 16					; 00000010H
	fstp	QWORD PTR [ecx-16]
	add	ecx, 32					; 00000020H
	dec	edx
	fst	QWORD PTR [esi+ebx*8]
	mov	ebx, DWORD PTR [eax-20]
	fld	QWORD PTR [esi+ebx*8]
	fstp	QWORD PTR [ecx-40]
	fst	QWORD PTR [esi+ebx*8]
	mov	ebx, DWORD PTR [eax-16]
	fld	QWORD PTR [esi+ebx*8]
	fstp	QWORD PTR [ecx-32]
	fst	QWORD PTR [esi+ebx*8]
	mov	ebx, DWORD PTR [eax-12]
	fld	QWORD PTR [esi+ebx*8]
	fstp	QWORD PTR [ecx-24]
	fst	QWORD PTR [esi+ebx*8]
	jne	SHORT $LN114@snfmod_

; 709  :                 goto L11;
; 710  :           }
; 711  :           mu = iju[k] - jmin;

	mov	ebx, DWORD PTR _mu$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _jmax$[ebp]
$LC113@snfmod_:

; 712  :           i__2 = jmax;
; 713  :           for (j = jmin; j <= i__2; ++j) {

	cmp	eax, edx
	jg	SHORT $LN118@snfmod_
	mov	ecx, DWORD PTR _ju$[ebp]
	add	ebx, eax
	lea	ecx, DWORD PTR [ecx+ebx*4]
	mov	ebx, DWORD PTR _u$[ebp]
	mov	DWORD PTR tv4124[ebp], ecx
$LC3@snfmod_:

; 714  :                 jumuj = ju[mu + j];

	mov	ecx, DWORD PTR tv4124[ebp]
	mov	ecx, DWORD PTR [ecx]

; 715  :                 u[j] = d[jumuj];

	fld	QWORD PTR [esi+ecx*8]
	add	DWORD PTR tv4124[ebp], 4
	fstp	QWORD PTR [ebx+eax*8]
	inc	eax

; 716  : /* L10: */
; 717  :                 d[jumuj] = 0.;

	fst	QWORD PTR [esi+ecx*8]
	cmp	eax, edx
	jle	SHORT $LC3@snfmod_

; 712  :           i__2 = jmax;
; 713  :           for (j = jmin; j <= i__2; ++j) {

	mov	ebx, DWORD PTR _mu$[ebp]
$LN118@snfmod_:

; 718  :           }
; 719  : 
; 720  : /* ------... AND ADD K TO ROW LIST FOR FIRST NONZERO ENTRY IN K-TH ROW
; 721  :  */
; 722  :           il[k] = jmin;

	mov	eax, DWORD PTR tv4252[ebp]
	mov	edx, DWORD PTR tv4367[ebp]

; 723  :           i = ju[mu + jmin];

	mov	ecx, DWORD PTR _ju$[ebp]
	mov	DWORD PTR [edx+eax], edi
	add	ebx, edi
	mov	edx, DWORD PTR [ecx+ebx*4]

; 724  :           jl[k] = jl[i];

	mov	ecx, DWORD PTR _jl$[ebp]
	mov	edi, DWORD PTR [ecx+edx*4]
	mov	ebx, DWORD PTR tv4371[ebp]
	mov	DWORD PTR [ebx+eax], edi

; 725  :           jl[i] = k;

	mov	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	eax, DWORD PTR tv4252[ebp]
$L11$89455:

; 551  : /* ==================================================================end 
; 552  : */
; 553  : 
; 554  : /* ----FOR EACH ROW K */
; 555  :      i__1 = *n;
; 556  :      for (k = 1; k <= i__1; ++k) {

	mov	ecx, DWORD PTR _k$[ebp]
	inc	ecx
	add	eax, 4
	mov	DWORD PTR _k$[ebp], ecx
	mov	DWORD PTR tv4252[ebp], eax
	cmp	ecx, DWORD PTR tv1039[ebp]
	jle	$LN120@snfmod_
$LN304@snfmod_:
	pop	edi

; 712  :           i__2 = jmax;
; 713  :           for (j = jmin; j <= i__2; ++j) {

	fstp	ST(0)
	pop	esi

; 726  : L11:
; 727  :           ;
; 728  :      }
; 729  : 
; 730  : /* uncomment next line to print out the largest diagonal modification */
; 731  : /*        IF (FLAG .LT. 0) WRITE (6,800) EMAX,-FLAG */
; 732  : /* L800: */
; 733  : /* ====================  change #5  (deletion) ========================5 
; 734  : */
; 735  : /* WAS:      FLAG = 0 */
; 736  : /* ==================================================================end 
; 737  : */
; 738  :      return 0;

	xor	eax, eax
	pop	ebx

; 743  :      return 0;
; 744  : 
; 745  : } /* snfmod_() */

	mov	esp, ebp
	pop	ebp
	ret	0
_snfmod_ ENDP
_TEXT	ENDS
PUBLIC	_ssf_
; Function compile flags: /Ogtp
;	COMDAT _ssf_
_TEXT	SEGMENT
_i__1$ = -64						; size = 4
tv1125 = -60						; size = 4
tv1044 = -56						; size = 4
_jmin$ = -52						; size = 4
_i__2$ = -48						; size = 4
_tag$ = -48						; size = 4
tv1032 = -44						; size = 4
tv1043 = -40						; size = 4
tv1037 = -36						; size = 4
_i$ = -32						; size = 4
_jmax$ = -32						; size = 4
tv921 = -28						; size = 4
_jumin$ = -24						; size = 4
_lmax$ = -20						; size = 4
_clique$ = -20						; size = 4
tv1052 = -16						; size = 4
_j$ = -12						; size = 4
_juptr$ = -8						; size = 4
_k$ = -4						; size = 4
_n$ = 8							; size = 4
_p$ = 12						; size = 4
_ip$ = 16						; size = 4
_ia$ = 20						; size = 4
_ja$ = 24						; size = 4
_iju$ = 28						; size = 4
_ju$ = 32						; size = 4
_iu$ = 36						; size = 4
_jumax$ = 40						; size = 4
_luk$ = 44						; size = 4
_q$ = 44						; size = 4
_mark$ = 48						; size = 4
_jl$ = 52						; size = 4
_flag_$ = 56						; size = 4
_ssf_	PROC						; COMDAT

; 755  : { /* System generated locals */

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 756  :      integer i__1, i__2, i__3;
; 757  :      /* Local variables */
; 758  :      STATIC integer jmin, jmax, lmax, i, j, k, m, jumin, juptr, vj, qm;
; 759  :      STATIC logical clique;
; 760  :      STATIC integer tag, lui, luk;
; 761  : 
; 762  : /*  ADDITIONAL PARAMETERS */
; 763  : /*     Q      - INTEGER ONE-DIMENSIONAL WORK ARRAY;  DIMENSION = N */
; 764  : /*     MARK  - INTEGER ONE-DIMENSIONAL WORK ARRAY;  DIMENSION = N */
; 765  : /*     JL     - INTEGER ONE-DIMENSIONAL WORK ARRAY;  DIMENSION = N */
; 766  : 
; 767  : /*  DEFINITIONS OF INTERNAL PARAMETERS (DURING K-TH STAGE OF ELIMINATION) */
; 768  : /*     Q CONTAINS AN ORDERED LINKED LIST REPRESENTATION OF THE NONZERO      */
; 769  : /*        STRUCTURE OF THE K-TH ROW OF U --                                            */
; 770  : /*          Q(K) IS THE FIRST COLUMN WITH A NONZERO ENTRY                         */
; 771  : /*          Q(I) IS THE NEXT COLUMN WITH A NONZERO ENTRY AFTER COLUMN I      */
; 772  : /*        IN EITHER CASE, Q(I) = N+1 INDICATES THE END OF THE LIST             */
; 773  : /*     JL CONTAINS LISTS OF ROWS TO BE MERGED INTO UNELIMINATED ROWS --     */
; 774  : /*          I GE K => JL(I) IS THE FIRST ROW TO BE MERGED INTO ROW I          */
; 775  : /*          I LT K => JL(I) IS THE ROW FOLLOWING ROW I IN SOME LIST OF ROWS */
; 776  : /*        IN EITHER CASE, JL(I) = 0 INDICATES THE END OF A LIST                 */
; 777  : /*     MARK(I) IS THE LAST ROW STORED IN JU FOR WHICH U(MARK(I),I) NE 0     */
; 778  : /*     JUMIN AND JUPTR ARE THE INDICES IN JU OF THE FIRST AND LAST            */
; 779  : /*        ELEMENTS IN THE LAST ROW SAVED IN JU                                        */
; 780  : /*     LUK IS THE NUMBER OF NONZERO ENTRIES IN THE K-TH ROW                     */
; 781  : /* -----------------------------------------------------------------------*/
; 782  : 
; 783  : /* ----INITIALIZATION */
; 784  :      /* Parameter adjustments */
; 785  :      --jl; --mark; --q; --iu; --ju; --iju; --ja; --ia; --ip; --p;

	mov	eax, DWORD PTR _iu$[ebp]
	mov	ecx, 4
	sub	DWORD PTR _jl$[ebp], ecx
	sub	DWORD PTR _mark$[ebp], ecx
	sub	DWORD PTR _ju$[ebp], ecx
	sub	DWORD PTR _ja$[ebp], ecx
	sub	DWORD PTR _ia$[ebp], ecx
	sub	DWORD PTR _ip$[ebp], ecx
	push	ebx
	mov	ebx, DWORD PTR _p$[ebp]
	sub	eax, ecx
	push	esi
	mov	esi, DWORD PTR _q$[ebp]

; 786  : 
; 787  :      /* Function Body */
; 788  :      jumin = 1;

	mov	edx, 1
	push	edi
	mov	edi, DWORD PTR _iju$[ebp]

; 789  :      juptr = 0;
; 790  :      iu[1] = 1;

	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR _iu$[ebp], eax

; 791  :      i__1 = *n;

	mov	eax, DWORD PTR _n$[ebp]
	sub	edi, ecx
	sub	ebx, ecx
	sub	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iju$[ebp], edi
	mov	DWORD PTR _p$[ebp], ebx
	mov	DWORD PTR _jumin$[ebp], edx
	mov	DWORD PTR _juptr$[ebp], 0

; 792  :      for (k = 1; k <= i__1; ++k) {

	cmp	ecx, edx
	jl	SHORT $LN40@ssf_

; 793  :           mark[k] = 0;

	mov	eax, DWORD PTR _jl$[ebp]
	mov	edx, DWORD PTR _mark$[ebp]
	add	eax, 4
	sub	edx, DWORD PTR _jl$[ebp]
	npad	12
$LL42@ssf_:
	mov	DWORD PTR [edx+eax], 0

; 794  : /* L1: */
; 795  :           jl[k] = 0;

	mov	DWORD PTR [eax], 0
	add	eax, 4
	dec	ecx
	jne	SHORT $LL42@ssf_

; 792  :      for (k = 1; k <= i__1; ++k) {

	mov	edx, 1
$LN40@ssf_:

; 796  :      }
; 797  : 
; 798  : /* ----FOR EACH ROW K */
; 799  :      i__1 = *n;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _i__1$[ebp], eax

; 800  :      for (k = 1; k <= i__1; ++k) {

	mov	DWORD PTR _k$[ebp], edx
	cmp	eax, edx
	jl	$LN37@ssf_
	mov	eax, DWORD PTR _mark$[ebp]
	mov	ecx, DWORD PTR _iu$[ebp]
	sub	eax, ebx
	mov	DWORD PTR tv1032[ebp], eax
	mov	eax, esi
	sub	eax, ebx
	sub	ebx, edi
	mov	DWORD PTR tv1043[ebp], ebx
	mov	ebx, DWORD PTR _jl$[ebp]
	sub	ebx, edi
	lea	edx, DWORD PTR [edi+4]
	sub	ecx, edi
	mov	DWORD PTR tv921[ebp], edx
	mov	DWORD PTR tv1037[ebp], eax
	mov	DWORD PTR tv1052[ebp], ebx
	mov	DWORD PTR tv1125[ebp], ecx
	jmp	SHORT $LN39@ssf_
$LL75@ssf_:
	mov	eax, DWORD PTR tv1037[ebp]
$LN39@ssf_:

; 801  :           luk = 0;
; 802  :           q[k] = *n + 1;

	mov	ecx, DWORD PTR tv1043[ebp]
	lea	edi, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edi+eax], ecx

; 803  : 
; 804  :           tag = mark[k];

	mov	eax, DWORD PTR tv1032[ebp]
	mov	ecx, DWORD PTR [edi+eax]
	mov	DWORD PTR _tag$[ebp], ecx

; 805  :           clique = FALSE_;
; 806  :           if (jl[k] != 0) {

	mov	ecx, DWORD PTR [edx+ebx]
	mov	DWORD PTR _luk$[ebp], 0
	mov	DWORD PTR tv1044[ebp], edi
	mov	DWORD PTR _clique$[ebp], 0
	test	ecx, ecx
	je	SHORT $LN36@ssf_

; 807  :                 clique = jl[jl[k]] == 0;

	mov	ebx, DWORD PTR _jl$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [ebx+ecx*4], eax
	mov	ebx, DWORD PTR tv1052[ebp]
	sete	al
	mov	DWORD PTR _clique$[ebp], eax
$LN36@ssf_:

; 808  :           }
; 809  : 
; 810  : /* ------INITIALIZE NONZERO STRUCTURE OF K-TH ROW TO ROW P(K) OF M */
; 811  :           jmin = ia[p[k]];

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR _ia$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [eax]

; 812  :           jmax = ia[p[k] + 1] - 1;

	mov	eax, DWORD PTR [eax+4]
	dec	eax
	mov	DWORD PTR _jmax$[ebp], eax

; 813  :           if (jmin > jmax) {

	cmp	ecx, eax
	jg	SHORT $L4$89512

; 814  :                 goto L4;
; 815  :           }
; 816  :           i__2 = jmax;
; 817  :           for (j = jmin; j <= i__2; ++j) {

	mov	DWORD PTR _j$[ebp], ecx
$LL76@ssf_:

; 818  :                 vj = ip[ja[j]];

	mov	edi, DWORD PTR _ja$[ebp]
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _ip$[ebp]
	mov	ecx, DWORD PTR [edi+ecx*4]

; 819  :                 if (vj <= k) {

	mov	edi, DWORD PTR _k$[ebp]
	cmp	ecx, edi
	jle	SHORT $L3$89517

; 820  :                      goto L3;
; 821  :                 }
; 822  : 
; 823  :                 qm = k;

	mov	eax, edi
$L2$89518:

; 824  : L2:
; 825  :                 m = qm;

	mov	ebx, eax

; 826  :                 qm = q[m];

	mov	eax, DWORD PTR [esi+eax*4]

; 827  :                 if (qm < vj) {

	cmp	eax, ecx
	jl	SHORT $L2$89518

; 828  :                      goto L2;
; 829  :                 }
; 830  :                 if (qm == vj) {

	je	$L102$89521

; 831  :                      goto L102;
; 832  :                 }
; 833  :                 ++luk;
; 834  :                 q[m] = vj;
; 835  :                 q[vj] = qm;
; 836  :                 if (mark[vj] != tag) {

	mov	edi, DWORD PTR _mark$[ebp]
	inc	DWORD PTR _luk$[ebp]
	mov	DWORD PTR [esi+ebx*4], ecx
	mov	DWORD PTR [esi+ecx*4], eax
	mov	eax, DWORD PTR _tag$[ebp]
	cmp	DWORD PTR [edi+ecx*4], eax

; 837  :                      clique = FALSE_;

	mov	eax, DWORD PTR _jmax$[ebp]
	je	SHORT $L3$89517
	mov	DWORD PTR _clique$[ebp], 0
$L3$89517:

; 814  :                 goto L4;
; 815  :           }
; 816  :           i__2 = jmax;
; 817  :           for (j = jmin; j <= i__2; ++j) {

	mov	ecx, DWORD PTR _j$[ebp]
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, eax
	jle	SHORT $LL76@ssf_
	mov	ebx, DWORD PTR tv1052[ebp]
$L4$89512:

; 838  :                 }
; 839  : 
; 840  : L3:
; 841  :                 ;
; 842  :           }
; 843  : 
; 844  : /* ------IF EXACTLY ONE ROW IS TO BE MERGED INTO THE K-TH ROW AND THERE IS */
; 845  : /* ------A NONZERO ENTRY IN EVERY COLUMN IN THAT ROW IN WHICH THERE IS A */
; 846  : /* ------NONZERO ENTRY IN ROW P(K) OF M, THEN DO NOT COMPUTE FILL-IN, JUST */
; 847  : /* ------USE THE COLUMN INDICES FOR THE ROW WHICH WAS TO HAVE BEEN MERGED */
; 848  : L4:
; 849  :           if (! clique) {

	cmp	DWORD PTR _clique$[ebp], 0
	jne	$LN27@ssf_

; 854  :           goto L17;
; 855  : 
; 856  : /* ------MODIFY NONZERO STRUCTURE OF K-TH ROW BY COMPUTING FILL-IN */
; 857  : /* ------FOR EACH ROW I TO BE MERGED IN */
; 858  : L5:
; 859  :           lmax = 0;
; 860  :           iju[k] = juptr;

	mov	ecx, DWORD PTR _juptr$[ebp]
	mov	DWORD PTR [edx], ecx

; 861  : 
; 862  :           i = k;
; 863  : L6:
; 864  :           i = jl[i];

	mov	ebx, DWORD PTR [edx+ebx]
$L5$89524:
	mov	DWORD PTR _lmax$[ebp], 0
	mov	DWORD PTR _i$[ebp], ebx

; 865  :           if (i == 0) {

	test	ebx, ebx
	je	$L10$89528
	npad	9
$L6$89526:

; 866  :                 goto L10;
; 867  :           }
; 868  : 
; 869  : /* --------MERGE ROW I INTO K-TH ROW */
; 870  :           lui = iu[i + 1] - (iu[i] + 1);

	mov	eax, DWORD PTR _iu$[ebp]
	mov	edx, DWORD PTR [eax+ebx*4+4]
	sub	edx, DWORD PTR [eax+ebx*4]

; 871  :           jmin = iju[i] + 1;

	mov	eax, DWORD PTR _iju$[ebp]
	mov	ecx, DWORD PTR [eax+ebx*4]

; 872  :           jmax = iju[i] + lui;
; 873  :           qm = k;

	mov	eax, DWORD PTR _k$[ebp]
	lea	edi, DWORD PTR [ecx+1]
	dec	edx
	add	ecx, edx
	mov	DWORD PTR _jmin$[ebp], edi
	mov	DWORD PTR _i__2$[ebp], ecx

; 874  : 
; 875  :           i__2 = jmax;
; 876  :           for (j = jmin; j <= i__2; ++j) {

	mov	DWORD PTR _j$[ebp], edi
	cmp	edi, ecx
	jg	SHORT $LN23@ssf_
$LL25@ssf_:

; 877  :                 vj = ju[j];

	mov	ecx, DWORD PTR _ju$[ebp]
	mov	edi, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	npad	1
$L7$89532:

; 878  : L7:
; 879  :                 m = qm;

	mov	edi, eax

; 880  :                 qm = q[m];

	mov	eax, DWORD PTR [esi+eax*4]

; 881  :                 if (qm < vj) {

	cmp	eax, ecx
	jl	SHORT $L7$89532

; 882  :                      goto L7;
; 883  :                 }
; 884  :                 if (qm == vj) {

	je	SHORT $L8$89535

; 885  :                      goto L8;
; 886  :                 }
; 887  :                 ++luk;

	inc	DWORD PTR _luk$[ebp]

; 888  :                 q[m] = vj;
; 889  :                 q[vj] = qm;
; 890  :                 qm = vj;

	mov	ebx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [esi+edi*4], ecx
	mov	DWORD PTR [esi+ecx*4], eax
	mov	eax, ecx
$L8$89535:

; 874  : 
; 875  :           i__2 = jmax;
; 876  :           for (j = jmin; j <= i__2; ++j) {

	mov	ecx, DWORD PTR _j$[ebp]
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR _i__2$[ebp]
	jle	SHORT $LL25@ssf_
	mov	edi, DWORD PTR _jmin$[ebp]
$LN23@ssf_:

; 891  : L8:
; 892  :                 ;
; 893  :           }
; 894  : 
; 895  : /* --------REMEMBER LENGTH AND POSITION IN JU OF LONGEST ROW MERGED */
; 896  : 
; 897  :           if (lui <= lmax) {

	cmp	edx, DWORD PTR _lmax$[ebp]
	jle	SHORT $L9$89537

; 898  :                 goto L9;
; 899  :           }
; 900  :           lmax = lui;

	mov	DWORD PTR _lmax$[ebp], edx

; 901  :           iju[k] = jmin;

	mov	edx, DWORD PTR tv921[ebp]
	mov	DWORD PTR [edx], edi
$L9$89537:

; 861  : 
; 862  :           i = k;
; 863  : L6:
; 864  :           i = jl[i];

	mov	eax, DWORD PTR _jl$[ebp]
	mov	ebx, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _i$[ebp], ebx

; 865  :           if (i == 0) {

	test	ebx, ebx
	jne	SHORT $L6$89526
	mov	edx, DWORD PTR tv921[ebp]
$L10$89528:

; 902  : 
; 903  : L9:
; 904  :           goto L6;
; 905  : 
; 906  : /* ------IF THE K-TH ROW IS THE SAME LENGTH AS THE LONGEST ROW MERGED,
; 907  :  */
; 908  : /* ------THEN USE THE COLUMN INDICES FOR THAT ROW */
; 909  : L10:
; 910  :           if (luk == lmax) {

	mov	ecx, DWORD PTR _lmax$[ebp]
	cmp	DWORD PTR _luk$[ebp], ecx
	je	$L17$89525

; 911  :                 goto L17;
; 912  :           }
; 913  : 
; 914  : /* ------IF THE TAIL OF THE LAST ROW SAVED IN JU IS THE SAME AS THE HEAD */
; 915  : /* ------OF THE K-TH ROW, THEN OVERLAP THE TWO SETS OF COLUMN INDICES -- */
; 916  : /* --------SEARCH LAST ROW SAVED FOR FIRST NONZERO ENTRY IN K-TH ROW ... */
; 917  :           i = q[k];
; 918  :           if (jumin > juptr) {

	mov	ebx, DWORD PTR _jumin$[ebp]
	mov	edi, DWORD PTR _juptr$[ebp]
	mov	eax, DWORD PTR tv1044[ebp]
	mov	ecx, DWORD PTR tv1037[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	cmp	ebx, edi
	jg	SHORT $L12$89540
$LL17@ssf_:

; 923  :                 if ((i__3 = ju[jmin] - i) < 0) {

	mov	eax, DWORD PTR _ju$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	sub	eax, ecx
	jns	SHORT $LN14@ssf_

; 919  :                 goto L12;
; 920  :           }
; 921  :           i__2 = juptr;
; 922  :           for (jmin = jumin; jmin <= i__2; ++jmin) {

	inc	ebx
$L11$89545:
	cmp	ebx, edi
	jle	SHORT $LL17@ssf_

; 956  :           juptr += luk;
; 957  :           if (juptr > *jumax) {

	jmp	SHORT $L12$89540
$LN14@ssf_:

; 924  :                      goto L11;
; 925  :                 } else if (i__3 == 0) {

	test	eax, eax
	jne	SHORT $L12$89540
$L13$89548:

; 926  :                      goto L13;
; 927  :                 } else {
; 928  :                      goto L12;
; 929  :                 }
; 930  : L11:
; 931  :                 ;
; 932  :           }
; 933  : L12:
; 934  :           goto L15;
; 935  : 
; 936  : /* --------... AND THEN TEST WHETHER TAIL MATCHES HEAD OF K-TH ROW */
; 937  : L13:
; 938  :           iju[k] = jmin;

	mov	DWORD PTR [edx], ebx

; 939  :           i__2 = juptr;
; 940  :           for (j = jmin; j <= i__2; ++j) {

	mov	eax, ebx
	cmp	ebx, edi
	jg	SHORT $LN74@ssf_
$LL70@ssf_:

; 941  :                 if (ju[j] != i) {

	mov	edi, DWORD PTR _ju$[ebp]
	cmp	DWORD PTR [edi+eax*4], ecx
	jne	SHORT $L12$89540

; 942  :                      goto L15;
; 943  :                 }
; 944  :                 i = q[i];

	mov	ecx, DWORD PTR [esi+ecx*4]

; 945  :                 if (i > *n) {

	mov	edi, DWORD PTR _n$[ebp]
	cmp	ecx, DWORD PTR [edi]
	jg	SHORT $L17$89525

; 939  :           i__2 = juptr;
; 940  :           for (j = jmin; j <= i__2; ++j) {

	inc	eax
	cmp	eax, DWORD PTR _juptr$[ebp]
	jle	SHORT $LL70@ssf_
$LN74@ssf_:

; 946  :                      goto L17;
; 947  :                 }
; 948  : /* L14: */
; 949  :           }
; 950  :           juptr = jmin - 1;

	dec	ebx
	mov	DWORD PTR _juptr$[ebp], ebx
$L12$89540:

; 951  : 
; 952  : /* ------SAVE NONZERO STRUCTURE OF K-TH ROW IN JU */
; 953  : L15:
; 954  :           i = k;
; 955  :           jumin = juptr + 1;

	mov	eax, DWORD PTR _juptr$[ebp]

; 956  :           juptr += luk;
; 957  :           if (juptr > *jumax) {

	mov	edi, DWORD PTR _jumax$[ebp]
	lea	ecx, DWORD PTR [eax+1]
	add	eax, DWORD PTR _luk$[ebp]
$L15$89550:
	mov	DWORD PTR _jumin$[ebp], ecx
	mov	DWORD PTR _juptr$[ebp], eax
	cmp	eax, DWORD PTR [edi]
	jg	$L106$89557

; 958  :                 goto L106;
; 959  :           }
; 960  :           i__2 = juptr;
; 961  :           for (j = jumin; j <= i__2; ++j) {

	cmp	ecx, eax
	jg	SHORT $LN2@ssf_

; 800  :      for (k = 1; k <= i__1; ++k) {

	mov	eax, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR _mark$[ebp]
	add	eax, eax
	add	eax, eax
$LL69@ssf_:

; 962  :                 i = q[i];

	mov	eax, DWORD PTR [eax+esi]

; 963  :                 ju[j] = i;

	mov	ebx, DWORD PTR _ju$[ebp]
	mov	DWORD PTR [ebx+ecx*4], eax

; 964  : /* L16: */
; 965  :                 mark[i] = k;

	mov	ebx, DWORD PTR _k$[ebp]
	add	eax, eax
	add	eax, eax
	inc	ecx
	mov	DWORD PTR [eax+edi], ebx
	cmp	ecx, DWORD PTR _juptr$[ebp]
	jle	SHORT $LL69@ssf_

; 958  :                 goto L106;
; 959  :           }
; 960  :           i__2 = juptr;
; 961  :           for (j = jumin; j <= i__2; ++j) {

	mov	ecx, DWORD PTR _jumin$[ebp]
$LN2@ssf_:

; 966  :           }
; 967  :           iju[k] = jumin;

	mov	DWORD PTR [edx], ecx
	jmp	SHORT $L17$89525
$LN27@ssf_:

; 850  :                 goto L5;
; 851  :           }
; 852  :           iju[k] = iju[jl[k]] + 1;

	mov	ecx, DWORD PTR [edx+ebx]
	mov	eax, DWORD PTR _iju$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	inc	ecx
	mov	DWORD PTR [edx], ecx

; 853  :           luk = iu[jl[k] + 1] - (iu[jl[k]] + 1);

	mov	ecx, DWORD PTR _iu$[ebp]
	mov	eax, DWORD PTR [edx+ebx]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [eax]
	dec	ecx
	mov	DWORD PTR _luk$[ebp], ecx
$L17$89525:

; 968  : 
; 969  : /* ------ADD K TO ROW LIST FOR FIRST NONZERO ELEMENT IN K-TH ROW */
; 970  : L17:
; 971  :           if (luk <= 1) {

	cmp	DWORD PTR _luk$[ebp], 1

; 975  :           jl[k] = jl[i];

	mov	ebx, DWORD PTR tv1052[ebp]
	jle	SHORT $L18$89562

; 972  :                 goto L18;
; 973  :           }
; 974  :           i = ju[iju[k]];

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ju$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]

; 975  :           jl[k] = jl[i];

	mov	ecx, DWORD PTR _jl$[ebp]
	mov	edi, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+ebx], edi

; 976  :           jl[i] = k;

	mov	edi, DWORD PTR _k$[ebp]
	mov	DWORD PTR [ecx+eax*4], edi
$L18$89562:

; 977  : 
; 978  : L18:
; 979  :           iu[k + 1] = iu[k] + luk;

	mov	eax, DWORD PTR tv1125[ebp]
	mov	ecx, DWORD PTR [edx+eax]
	add	ecx, DWORD PTR _luk$[ebp]
	add	edx, 4
	mov	DWORD PTR [edx+eax], ecx
	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	mov	DWORD PTR tv921[ebp], edx
	cmp	eax, DWORD PTR _i__1$[ebp]
	jle	$LL75@ssf_
$LN37@ssf_:

; 980  :      }
; 981  : 
; 982  :      *flag_ = 0;

	mov	eax, DWORD PTR _flag_$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 0

; 983  :      return 0;

	xor	eax, eax
	pop	ebx

; 992  :      return 0;
; 993  : 
; 994  : } /* end ssf_() */

	mov	esp, ebp
	pop	ebp
	ret	0
$L102$89521:

; 984  : 
; 985  : /* ** ERROR -- DUPLICATE ENTRY IN A */
; 986  : L102:
; 987  :      *flag_ = (*n << 1) + p[k];

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR _flag_$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], edx
	xor	eax, eax
	pop	ebx

; 992  :      return 0;
; 993  : 
; 994  : } /* end ssf_() */

	mov	esp, ebp
	pop	ebp
	ret	0
$L106$89557:

; 988  :      return 0;
; 989  : /* ** ERROR -- INSUFFICIENT STORAGE FOR JU */
; 990  : L106:
; 991  :      *flag_ = *n * 6 + k;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _k$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	edx, DWORD PTR _flag_$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx], ecx
	xor	eax, eax
	pop	ebx

; 992  :      return 0;
; 993  : 
; 994  : } /* end ssf_() */

	mov	esp, ebp
	pop	ebp
	ret	0
_ssf_	ENDP
_TEXT	ENDS
PUBLIC	_sns_
; Function compile flags: /Ogtp
;	COMDAT _sns_
_TEXT	SEGMENT
tv2058 = -16						; size = 4
tv2103 = -12						; size = 4
tv2008 = -8						; size = 4
_jmax$ = -4						; size = 4
tv3066 = 8						; size = 4
_n$ = 8							; size = 4
tv2983 = 12						; size = 4
_p$ = 12						; size = 4
_mu$ = 16						; size = 4
_d$ = 16						; size = 4
tv3091 = 20						; size = 4
_iju$ = 20						; size = 4
_ju$ = 24						; size = 4
tv2987 = 28						; size = 4
_iu$ = 28						; size = 4
_u$ = 32						; size = 4
_z$ = 36						; size = 4
tv2053 = 40						; size = 4
_i__1$ = 40						; size = 4
_b$ = 40						; size = 4
tv2014 = 44						; size = 4
tv574 = 44						; size = 4
_tmp$ = 44						; size = 4
_sns_	PROC						; COMDAT

; 1007 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1008 :      /* System generated locals */
; 1009 :      integer i__1, i__2;
; 1010 : 
; 1011 :      /* Local variables */
; 1012 :      STATIC integer jmin, jmax;
; 1013 :      STATIC doublereal tmpk;
; 1014 :      STATIC integer i, j, k, mu;
; 1015 :      STATIC doublereal sum;
; 1016 : 
; 1017 : /*         REAL  D(1), U(1),  Z(1), B(1),  TMP(1),  TMPK, SUM */
; 1018 : 
; 1019 : /*  ADDITIONAL PARAMETERS */
; 1020 : 
; 1021 : /*     TMP    - REAL ONE-DIMENSIONAL WORK ARRAY;  DIMENSION = N */
; 1022 : 
; 1023 : /* -----------------------------------------------------------------------
; 1024 :  */
; 1025 : 
; 1026 : /* ----SET TMP TO PERMUTED B */
; 1027 :      /* Parameter adjustments */
; 1028 :      --tmp;

	mov	eax, DWORD PTR _tmp$[ebp]
	push	ebx
	mov	ecx, 8

; 1029 :      --b;
; 1030 :      --z;

	sub	DWORD PTR _z$[ebp], ecx

; 1031 :      --u;

	sub	DWORD PTR _u$[ebp], ecx

; 1032 :      --iu;
; 1033 :      --ju;
; 1034 :      --iju;
; 1035 :      --d;

	sub	DWORD PTR _d$[ebp], ecx
	push	esi
	mov	esi, DWORD PTR _b$[ebp]
	mov	ebx, 4
	sub	DWORD PTR _iu$[ebp], ebx
	sub	DWORD PTR _ju$[ebp], ebx
	sub	DWORD PTR _iju$[ebp], ebx
	sub	eax, ecx
	sub	esi, ecx

; 1036 :      --p;
; 1037 : 
; 1038 :      /* Function Body */
; 1039 :      i__1 = *n;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR _p$[ebp]
	sub	edi, ebx
	mov	DWORD PTR _p$[ebp], edi
	mov	DWORD PTR _i__1$[ebp], edx

; 1040 :      for (k = 1; k <= i__1; ++k) {

	lea	ecx, DWORD PTR [ebx-3]
	cmp	edx, ebx
	jl	SHORT $LC31@sns_

; 1008 :      /* System generated locals */
; 1009 :      integer i__1, i__2;
; 1010 : 
; 1011 :      /* Local variables */
; 1012 :      STATIC integer jmin, jmax;
; 1013 :      STATIC doublereal tmpk;
; 1014 :      STATIC integer i, j, k, mu;
; 1015 :      STATIC doublereal sum;
; 1016 : 
; 1017 : /*         REAL  D(1), U(1),  Z(1), B(1),  TMP(1),  TMPK, SUM */
; 1018 : 
; 1019 : /*  ADDITIONAL PARAMETERS */
; 1020 : 
; 1021 : /*     TMP    - REAL ONE-DIMENSIONAL WORK ARRAY;  DIMENSION = N */
; 1022 : 
; 1023 : /* -----------------------------------------------------------------------
; 1024 :  */
; 1025 : 
; 1026 : /* ----SET TMP TO PERMUTED B */
; 1027 :      /* Parameter adjustments */
; 1028 :      --tmp;

	add	edi, 12					; 0000000cH
	shr	edx, 2
	lea	ebx, DWORD PTR [eax+24]
	mov	DWORD PTR tv574[ebp], edx
	lea	ecx, DWORD PTR [edx*4+1]
	npad	7

; 1040 :      for (k = 1; k <= i__1; ++k) {

$LL32@sns_:

; 1041 : /* L1: */
; 1042 :           tmp[k] = b[p[k]];

	mov	edx, DWORD PTR [edi-8]
	fld	QWORD PTR [esi+edx*8]
	add	edi, 16					; 00000010H
	fstp	QWORD PTR [ebx-16]
	mov	edx, DWORD PTR [edi-20]
	fld	QWORD PTR [esi+edx*8]
	add	ebx, 32					; 00000020H
	dec	DWORD PTR tv574[ebp]
	fstp	QWORD PTR [ebx-40]
	mov	edx, DWORD PTR [edi-16]
	fld	QWORD PTR [esi+edx*8]
	fstp	QWORD PTR [ebx-32]
	mov	edx, DWORD PTR [edi-12]
	fld	QWORD PTR [esi+edx*8]
	fstp	QWORD PTR [ebx-24]
	jne	SHORT $LL32@sns_

; 1008 :      /* System generated locals */
; 1009 :      integer i__1, i__2;
; 1010 : 
; 1011 :      /* Local variables */
; 1012 :      STATIC integer jmin, jmax;
; 1013 :      STATIC doublereal tmpk;
; 1014 :      STATIC integer i, j, k, mu;
; 1015 :      STATIC doublereal sum;
; 1016 : 
; 1017 : /*         REAL  D(1), U(1),  Z(1), B(1),  TMP(1),  TMPK, SUM */
; 1018 : 
; 1019 : /*  ADDITIONAL PARAMETERS */
; 1020 : 
; 1021 : /*     TMP    - REAL ONE-DIMENSIONAL WORK ARRAY;  DIMENSION = N */
; 1022 : 
; 1023 : /* -----------------------------------------------------------------------
; 1024 :  */
; 1025 : 
; 1026 : /* ----SET TMP TO PERMUTED B */
; 1027 :      /* Parameter adjustments */
; 1028 :      --tmp;

	mov	edx, DWORD PTR _i__1$[ebp]
	mov	edi, DWORD PTR _p$[ebp]
$LC31@sns_:

; 1040 :      for (k = 1; k <= i__1; ++k) {

	cmp	ecx, edx
	jg	SHORT $LN30@sns_
	npad	7
$LC17@sns_:

; 1041 : /* L1: */
; 1042 :           tmp[k] = b[p[k]];

	mov	ebx, DWORD PTR [edi+ecx*4]
	fld	QWORD PTR [esi+ebx*8]
	inc	ecx
	fstp	QWORD PTR [eax+ecx*8-8]
	cmp	ecx, edx
	jle	SHORT $LC17@sns_
$LN30@sns_:

; 1043 :      }
; 1044 : 
; 1045 : /* ----SOLVE  UT D Y = B  BY FORWARD SUBSTITUTION */
; 1046 :      i__1 = *n;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [ecx]

; 1047 :      for (k = 1; k <= i__1; ++k) {

	cmp	ecx, 1
	jl	$LN12@sns_
	mov	esi, DWORD PTR _iu$[ebp]
	mov	ebx, DWORD PTR _iju$[ebp]
	lea	edi, DWORD PTR [esi+4]
	sub	ebx, esi
	mov	esi, DWORD PTR _d$[ebp]
	lea	edx, DWORD PTR [eax+8]
	sub	esi, eax
	mov	DWORD PTR tv2008[ebp], edx
	mov	DWORD PTR tv2014[ebp], edi
	mov	DWORD PTR tv2053[ebp], ebx
	mov	DWORD PTR tv2058[ebp], esi
	mov	DWORD PTR tv2103[ebp], ecx
	jmp	SHORT $LN14@sns_
$LL40@sns_:

; 1043 :      }
; 1044 : 
; 1045 : /* ----SOLVE  UT D Y = B  BY FORWARD SUBSTITUTION */
; 1046 :      i__1 = *n;

	mov	ebx, DWORD PTR tv2053[ebp]
$LN14@sns_:

; 1048 :           tmpk = tmp[k];
; 1049 :           jmin = iu[k];

	mov	ecx, DWORD PTR tv2014[ebp]
	fld	QWORD PTR [edx]

; 1050 :           jmax = iu[k + 1] - 1;

	mov	esi, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	dec	esi
	mov	DWORD PTR _jmax$[ebp], esi

; 1051 :           if (jmin > jmax) {

	cmp	edi, esi
	jg	$L3$89601

; 1052 :                 goto L3;
; 1053 :           }
; 1054 :           mu = iju[k] - jmin;

	mov	ecx, DWORD PTR [ecx+ebx]

; 1055 :           i__2 = jmax;
; 1056 :           for (j = jmin; j <= i__2; ++j) {

	mov	edx, esi
	sub	edx, edi
	sub	ecx, edi
	inc	edx
	mov	DWORD PTR _mu$[ebp], ecx
	mov	ebx, edi
	cmp	edx, 4
	jl	SHORT $LN41@sns_

; 1052 :                 goto L3;
; 1053 :           }
; 1054 :           mu = iju[k] - jmin;

	mov	ebx, DWORD PTR _ju$[ebp]
	mov	edx, DWORD PTR _u$[ebp]
	sub	esi, edi
	sub	esi, 3
	add	ecx, edi
	shr	esi, 2
	inc	esi
	lea	ecx, DWORD PTR [ebx+ecx*4]
	lea	edx, DWORD PTR [edx+edi*8+16]
	lea	ebx, DWORD PTR [edi+esi*4]

; 1055 :           i__2 = jmax;
; 1056 :           for (j = jmin; j <= i__2; ++j) {

$LN35@sns_:

; 1057 : /* L2: */
; 1058 :                 tmp[ju[mu + j]] += u[j] * tmpk;

	fld	QWORD PTR [edx-16]
	mov	edi, DWORD PTR [ecx]
	fmul	ST(0), ST(1)
	lea	edi, DWORD PTR [eax+edi*8]
	add	ecx, 16					; 00000010H
	add	edx, 32					; 00000020H
	dec	esi
	fadd	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [ecx-12]
	fld	QWORD PTR [edx-40]
	lea	edi, DWORD PTR [eax+edi*8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [ecx-8]
	fld	QWORD PTR [edx-32]
	lea	edi, DWORD PTR [eax+edi*8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [ecx-4]
	fld	QWORD PTR [edx-24]
	lea	edi, DWORD PTR [eax+edi*8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	jne	SHORT $LN35@sns_

; 1052 :                 goto L3;
; 1053 :           }
; 1054 :           mu = iju[k] - jmin;

	mov	esi, DWORD PTR _jmax$[ebp]
	mov	ecx, DWORD PTR _mu$[ebp]
$LN41@sns_:

; 1055 :           i__2 = jmax;
; 1056 :           for (j = jmin; j <= i__2; ++j) {

	cmp	ebx, esi
	jg	SHORT $L3$89601
	mov	edx, DWORD PTR _ju$[ebp]
	add	ecx, ebx
	lea	edx, DWORD PTR [edx+ecx*4]
$LC10@sns_:

; 1057 : /* L2: */
; 1058 :                 tmp[ju[mu + j]] += u[j] * tmpk;

	mov	ecx, DWORD PTR [edx]
	lea	edi, DWORD PTR [eax+ecx*8]
	mov	ecx, DWORD PTR _u$[ebp]
	fld	QWORD PTR [ecx+ebx*8]
	inc	ebx
	fmul	ST(0), ST(1)
	add	edx, 4
	fadd	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	cmp	ebx, esi
	jle	SHORT $LC10@sns_
$L3$89601:

; 1059 :           }
; 1060 : L3:
; 1061 :           tmp[k] = tmpk * d[k];

	mov	edx, DWORD PTR tv2008[ebp]
	mov	ecx, DWORD PTR tv2058[ebp]
	fmul	QWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR tv2014[ebp]
	add	ecx, 4
	add	edx, 8
	dec	DWORD PTR tv2103[ebp]
	fstp	QWORD PTR [edx-8]
	mov	DWORD PTR tv2014[ebp], ecx
	mov	DWORD PTR tv2008[ebp], edx
	jne	$LL40@sns_

; 1047 :      for (k = 1; k <= i__1; ++k) {

	mov	edi, DWORD PTR _p$[ebp]
$LN12@sns_:

; 1062 :      }
; 1063 : 
; 1064 : /* ----SOLVE  U X = Y  BY BACK SUBSTITUTION */
; 1065 :      k = *n;

	mov	edx, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [edx]

; 1066 :      i__1 = *n;
; 1067 :      for (i = 1; i <= i__1; ++i) {

	cmp	ecx, 1
	jl	$LN39@sns_

; 1062 :      }
; 1063 : 
; 1064 : /* ----SOLVE  U X = Y  BY BACK SUBSTITUTION */
; 1065 :      k = *n;

	mov	ebx, DWORD PTR _iu$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR tv2983[ebp], edx

; 1066 :      i__1 = *n;
; 1067 :      for (i = 1; i <= i__1; ++i) {

	mov	edx, DWORD PTR _iju$[ebp]
	sub	edx, ebx
	lea	esi, DWORD PTR [ebx+ecx*4]
	sub	edi, ebx
	mov	DWORD PTR tv2987[ebp], esi
	mov	DWORD PTR tv2053[ebp], edx
	mov	DWORD PTR tv3066[ebp], edi
	mov	DWORD PTR tv3091[ebp], ecx
	jmp	SHORT $LN7@sns_
	npad	2
$LL44@sns_:

; 1062 :      }
; 1063 : 
; 1064 : /* ----SOLVE  U X = Y  BY BACK SUBSTITUTION */
; 1065 :      k = *n;

	mov	edx, DWORD PTR tv2053[ebp]
$LN7@sns_:

; 1068 :           sum = tmp[k];
; 1069 :           jmin = iu[k];
; 1070 :           jmax = iu[k + 1] - 1;

	mov	ebx, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR tv2983[ebp]
	fld	QWORD PTR [ecx]
	dec	ebx
	mov	DWORD PTR _jmax$[ebp], ebx

; 1071 :           if (jmin > jmax) {

	cmp	edi, ebx
	jg	$L5$89609

; 1072 :                 goto L5;
; 1073 :           }
; 1074 :           mu = iju[k] - jmin;

	mov	edx, DWORD PTR [esi+edx]

; 1075 :           i__2 = jmax;
; 1076 :           for (j = jmin; j <= i__2; ++j) {

	mov	ecx, ebx
	sub	ecx, edi
	sub	edx, edi
	inc	ecx
	mov	DWORD PTR _mu$[ebp], edx
	cmp	ecx, 4
	jl	SHORT $LC37@sns_

; 1072 :                 goto L5;
; 1073 :           }
; 1074 :           mu = iju[k] - jmin;

	mov	ecx, DWORD PTR _u$[ebp]
	lea	esi, DWORD PTR [ecx+edi*8+16]
	mov	ecx, DWORD PTR _ju$[ebp]
	add	edx, edi
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, ebx
	sub	ecx, edi
	sub	ecx, 3
	shr	ecx, 2
	inc	ecx
	lea	edi, DWORD PTR [edi+ecx*4]

; 1075 :           i__2 = jmax;
; 1076 :           for (j = jmin; j <= i__2; ++j) {

$LN38@sns_:

; 1077 : /* L4: */
; 1078 :                 sum += u[j] * tmp[ju[mu + j]];

	mov	ebx, DWORD PTR [edx]
	fld	QWORD PTR [eax+ebx*8]
	mov	ebx, DWORD PTR [edx+4]
	fmul	QWORD PTR [esi-16]
	add	edx, 16					; 00000010H
	add	esi, 32					; 00000020H
	dec	ecx
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax+ebx*8]
	mov	ebx, DWORD PTR [edx-8]
	fmul	QWORD PTR [esi-40]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax+ebx*8]
	mov	ebx, DWORD PTR [edx-4]
	fmul	QWORD PTR [esi-32]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax+ebx*8]
	fmul	QWORD PTR [esi-24]
	faddp	ST(1), ST(0)
	jne	SHORT $LN38@sns_

; 1072 :                 goto L5;
; 1073 :           }
; 1074 :           mu = iju[k] - jmin;

	mov	esi, DWORD PTR tv2987[ebp]
	mov	edx, DWORD PTR _mu$[ebp]
	mov	ebx, DWORD PTR _jmax$[ebp]
$LC37@sns_:

; 1075 :           i__2 = jmax;
; 1076 :           for (j = jmin; j <= i__2; ++j) {

	cmp	edi, ebx
	jg	SHORT $L5$89609
	mov	ecx, DWORD PTR _ju$[ebp]
	add	edx, edi
	lea	ecx, DWORD PTR [ecx+edx*4]
$LC3@sns_:

; 1077 : /* L4: */
; 1078 :                 sum += u[j] * tmp[ju[mu + j]];

	mov	edx, DWORD PTR [ecx]
	fld	QWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _u$[ebp]
	fmul	QWORD PTR [edx+edi*8]
	inc	edi
	add	ecx, 4
	faddp	ST(1), ST(0)
	cmp	edi, ebx
	jle	SHORT $LC3@sns_
$L5$89609:

; 1079 :           }
; 1080 : L5:
; 1081 :           tmp[k] = sum;

	mov	ecx, DWORD PTR tv2983[ebp]

; 1082 :           z[p[k]] = sum;

	mov	edx, DWORD PTR tv3066[ebp]
	fst	QWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+esi]
	mov	edi, DWORD PTR _z$[ebp]

; 1083 : /* L6: */
; 1084 :           --k;

	sub	ecx, 8
	fstp	QWORD PTR [edi+edx*8]
	sub	esi, 4
	dec	DWORD PTR tv3091[ebp]
	mov	DWORD PTR tv2983[ebp], ecx
	mov	DWORD PTR tv2987[ebp], esi
	jne	$LL44@sns_
$LN39@sns_:
	pop	edi
	pop	esi

; 1085 :      }
; 1086 : 
; 1087 :      return 0;

	xor	eax, eax
	pop	ebx

; 1088 : 
; 1089 : } /* end sns_() */

	mov	esp, ebp
	pop	ebp
	ret	0
_sns_	ENDP
_TEXT	ENDS
PUBLIC	_ysmp_negvector
; Function compile flags: /Ogtp
;	COMDAT _ysmp_negvector
_TEXT	SEGMENT
tv1922 = -4						; size = 4
tv1853 = 8						; size = 4
_n$ = 8							; size = 4
tv1806 = 12						; size = 4
_p$ = 12						; size = 4
_d$ = 16						; size = 4
tv1902 = 20						; size = 4
_iju$ = 20						; size = 4
_ju$ = 24						; size = 4
tv1810 = 28						; size = 4
_iu$ = 28						; size = 4
_u$ = 32						; size = 4
_z$ = 36						; size = 4
_mu$ = 40						; size = 4
_i__1$ = 40						; size = 4
_b$ = 40						; size = 4
tv70 = 44						; size = 4
_jmax$ = 44						; size = 4
_tmp$ = 44						; size = 4
_ysmp_negvector PROC					; COMDAT

; 1106 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1127 :      --b;

	mov	eax, DWORD PTR _b$[ebp]
	push	ebx
	push	esi

; 1128 :      --z;
; 1129 :      --u;
; 1130 :      --iu;
; 1131 :      --ju;
; 1132 :      --iju;
; 1133 :      --d;
; 1134 :      --p;

	mov	esi, DWORD PTR _p$[ebp]
	mov	ecx, 8
	sub	DWORD PTR _z$[ebp], ecx
	sub	DWORD PTR _u$[ebp], ecx
	push	edi
	mov	edi, DWORD PTR _tmp$[ebp]
	mov	ebx, 4
	sub	DWORD PTR _iu$[ebp], ebx
	sub	DWORD PTR _ju$[ebp], ebx
	sub	DWORD PTR _iju$[ebp], ebx
	sub	edi, ecx
	sub	eax, ecx

; 1135 : 
; 1136 :      /* Function Body */
; 1137 :      i__1 = *n;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [ecx]
	sub	esi, ebx
	mov	DWORD PTR _p$[ebp], esi
	mov	DWORD PTR _i__1$[ebp], ecx

; 1138 :      for (k = 1; k <= i__1; ++k) {

	lea	edx, DWORD PTR [ebx-3]
	cmp	ecx, ebx
	jl	SHORT $LC20@ysmp_negve

; 1107 :      /* System generated locals */
; 1108 :      integer i__1, i__2;
; 1109 : 
; 1110 :      /* Local variables */
; 1111 :      STATIC integer jmin, jmax;
; 1112 :      STATIC integer i, j, k, mu;
; 1113 :      STATIC doublereal sum;
; 1114 : 
; 1115 : /*         REAL  D(1), U(1),  Z(1), B(1),  TMP(1),  TMPK, SUM */
; 1116 : 
; 1117 : /*  ADDITIONAL PARAMETERS */
; 1118 : 
; 1119 : /*     TMP    - REAL ONE-DIMENSIONAL WORK ARRAY;  DIMENSION = N */
; 1120 : 
; 1121 : /* -----------------------------------------------------------------------
; 1122 :  */
; 1123 : 
; 1124 : /* ----SET TMP TO PERMUTED B */
; 1125 :      /* Parameter adjustments */
; 1126 :      --tmp;

	add	esi, 12					; 0000000cH
	shr	ecx, 2
	lea	ebx, DWORD PTR [edi+24]
	mov	DWORD PTR tv70[ebp], ecx
	lea	edx, DWORD PTR [ecx*4+1]

; 1138 :      for (k = 1; k <= i__1; ++k) {

$LL21@ysmp_negve:

; 1139 : /* L1: */
; 1140 :           tmp[k] = b[p[k]];

	mov	ecx, DWORD PTR [esi-8]
	fld	QWORD PTR [eax+ecx*8]
	add	esi, 16					; 00000010H
	fstp	QWORD PTR [ebx-16]
	mov	ecx, DWORD PTR [esi-20]
	fld	QWORD PTR [eax+ecx*8]
	add	ebx, 32					; 00000020H
	dec	DWORD PTR tv70[ebp]
	fstp	QWORD PTR [ebx-40]
	mov	ecx, DWORD PTR [esi-16]
	fld	QWORD PTR [eax+ecx*8]
	fstp	QWORD PTR [ebx-32]
	mov	ecx, DWORD PTR [esi-12]
	fld	QWORD PTR [eax+ecx*8]
	fstp	QWORD PTR [ebx-24]
	jne	SHORT $LL21@ysmp_negve

; 1107 :      /* System generated locals */
; 1108 :      integer i__1, i__2;
; 1109 : 
; 1110 :      /* Local variables */
; 1111 :      STATIC integer jmin, jmax;
; 1112 :      STATIC integer i, j, k, mu;
; 1113 :      STATIC doublereal sum;
; 1114 : 
; 1115 : /*         REAL  D(1), U(1),  Z(1), B(1),  TMP(1),  TMPK, SUM */
; 1116 : 
; 1117 : /*  ADDITIONAL PARAMETERS */
; 1118 : 
; 1119 : /*     TMP    - REAL ONE-DIMENSIONAL WORK ARRAY;  DIMENSION = N */
; 1120 : 
; 1121 : /* -----------------------------------------------------------------------
; 1122 :  */
; 1123 : 
; 1124 : /* ----SET TMP TO PERMUTED B */
; 1125 :      /* Parameter adjustments */
; 1126 :      --tmp;

	mov	ecx, DWORD PTR _i__1$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
$LC20@ysmp_negve:

; 1138 :      for (k = 1; k <= i__1; ++k) {

	cmp	edx, ecx
	jg	SHORT $LN28@ysmp_negve
	npad	3
$LC10@ysmp_negve:

; 1139 : /* L1: */
; 1140 :           tmp[k] = b[p[k]];

	mov	ebx, DWORD PTR [esi+edx*4]
	fld	QWORD PTR [eax+ebx*8]
	inc	edx
	fstp	QWORD PTR [edi+edx*8-8]
	cmp	edx, ecx
	jle	SHORT $LC10@ysmp_negve
$LN28@ysmp_negve:

; 1141 :      }
; 1142 : 
; 1143 : /* ----SOLVE  U X = Y  BY BACK SUBSTITUTION */
; 1144 :      k = *n;

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edx]

; 1145 :      i__1 = *n;
; 1146 :      for (i = 1; i <= i__1; ++i) {

	cmp	eax, 1
	jl	$LN25@ysmp_negve
	mov	edx, DWORD PTR _iu$[ebp]
	mov	ebx, DWORD PTR _iju$[ebp]
	lea	ecx, DWORD PTR [edi+eax*8]
	sub	ebx, edx
	mov	DWORD PTR tv1806[ebp], ecx
	lea	ecx, DWORD PTR [edx+eax*4]
	sub	esi, edx
	mov	DWORD PTR tv1810[ebp], ecx
	mov	DWORD PTR tv1853[ebp], ebx
	mov	DWORD PTR tv1922[ebp], esi
	mov	DWORD PTR tv1902[ebp], eax
	jmp	SHORT $LN7@ysmp_negve
	npad	2
$LL27@ysmp_negve:

; 1141 :      }
; 1142 : 
; 1143 : /* ----SOLVE  U X = Y  BY BACK SUBSTITUTION */
; 1144 :      k = *n;

	mov	ebx, DWORD PTR tv1853[ebp]
$LN7@ysmp_negve:

; 1147 :           sum = tmp[k];
; 1148 :           jmin = iu[k];
; 1149 :           jmax = iu[k + 1] - 1;

	mov	eax, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv1806[ebp]
	fld	QWORD PTR [edx]
	dec	eax
	mov	DWORD PTR _jmax$[ebp], eax

; 1150 :           if (jmin > jmax) {

	cmp	esi, eax
	jg	$L5$89650

; 1151 :                 goto L5;
; 1152 :           }
; 1153 :           mu = iju[k] - jmin;

	mov	ebx, DWORD PTR [ebx+ecx]

; 1154 :           i__2 = jmax;
; 1155 :           for (j = jmin; j <= i__2; ++j) {

	mov	edx, eax
	sub	edx, esi
	sub	ebx, esi
	inc	edx
	mov	DWORD PTR _mu$[ebp], ebx
	cmp	edx, 4
	jl	SHORT $LC23@ysmp_negve

; 1151 :                 goto L5;
; 1152 :           }
; 1153 :           mu = iju[k] - jmin;

	mov	ecx, DWORD PTR _u$[ebp]
	sub	eax, esi
	sub	eax, 3
	lea	edx, DWORD PTR [ecx+esi*8+16]
	mov	ecx, DWORD PTR _ju$[ebp]
	add	ebx, esi
	shr	eax, 2
	inc	eax
	lea	ecx, DWORD PTR [ecx+ebx*4]
	lea	esi, DWORD PTR [esi+eax*4]

; 1154 :           i__2 = jmax;
; 1155 :           for (j = jmin; j <= i__2; ++j) {

$LN24@ysmp_negve:

; 1156 : /* L4: */
; 1157 :                 sum += u[j] * tmp[ju[mu + j]];

	mov	ebx, DWORD PTR [ecx]
	fld	QWORD PTR [edi+ebx*8]
	mov	ebx, DWORD PTR [ecx+4]
	fmul	QWORD PTR [edx-16]
	add	ecx, 16					; 00000010H
	add	edx, 32					; 00000020H
	dec	eax
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+ebx*8]
	mov	ebx, DWORD PTR [ecx-8]
	fmul	QWORD PTR [edx-40]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+ebx*8]
	mov	ebx, DWORD PTR [ecx-4]
	fmul	QWORD PTR [edx-32]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+ebx*8]
	fmul	QWORD PTR [edx-24]
	faddp	ST(1), ST(0)
	jne	SHORT $LN24@ysmp_negve

; 1151 :                 goto L5;
; 1152 :           }
; 1153 :           mu = iju[k] - jmin;

	mov	eax, DWORD PTR _jmax$[ebp]
	mov	ebx, DWORD PTR _mu$[ebp]
	mov	ecx, DWORD PTR tv1810[ebp]
$LC23@ysmp_negve:

; 1154 :           i__2 = jmax;
; 1155 :           for (j = jmin; j <= i__2; ++j) {

	cmp	esi, eax
	jg	SHORT $L5$89650
	lea	edx, DWORD PTR [esi+ebx]
	mov	ebx, DWORD PTR _ju$[ebp]
	lea	edx, DWORD PTR [ebx+edx*4]
$LC3@ysmp_negve:

; 1156 : /* L4: */
; 1157 :                 sum += u[j] * tmp[ju[mu + j]];

	mov	ebx, DWORD PTR [edx]
	fld	QWORD PTR [edi+ebx*8]
	mov	ebx, DWORD PTR _u$[ebp]
	fmul	QWORD PTR [ebx+esi*8]
	inc	esi
	add	edx, 4
	faddp	ST(1), ST(0)
	cmp	esi, eax
	jle	SHORT $LC3@ysmp_negve
$L5$89650:

; 1158 :           }
; 1159 : L5:
; 1160 :           tmp[k] = sum;

	mov	eax, DWORD PTR tv1806[ebp]

; 1161 :           z[p[k]] = sum;

	mov	edx, DWORD PTR tv1922[ebp]
	fst	QWORD PTR [eax]
	mov	edx, DWORD PTR [edx+ecx]
	mov	esi, DWORD PTR _z$[ebp]

; 1162 : /* L6: */
; 1163 :           --k;

	sub	eax, 8
	fstp	QWORD PTR [esi+edx*8]
	sub	ecx, 4
	dec	DWORD PTR tv1902[ebp]
	mov	DWORD PTR tv1806[ebp], eax
	mov	DWORD PTR tv1810[ebp], ecx
	jne	$LL27@ysmp_negve
$LN25@ysmp_negve:
	pop	edi
	pop	esi

; 1164 :      }
; 1165 : 
; 1166 :      return 0;

	xor	eax, eax
	pop	ebx

; 1167 : 
; 1168 : } /* end ysmp_negvector() */

	mov	esp, ebp
	pop	ebp
	ret	0
_ysmp_negvector ENDP
_TEXT	ENDS
PUBLIC	_sdrvmd_
; Function compile flags: /Ogtp
;	COMDAT _sdrvmd_
_TEXT	SEGMENT
_il$ = -20						; size = 4
_tmp$ = -16						; size = 4
_mark$ = -16						; size = 4
_jl$ = -12						; size = 4
_d$ = -8						; size = 4
_q$ = -8						; size = 4
_u$ = -4						; size = 4
_n$ = 8							; size = 4
_p$ = 12						; size = 4
_ip$ = 16						; size = 4
_ia$ = 20						; size = 4
_ja$ = 24						; size = 4
_a$ = 28						; size = 4
_b$ = 32						; size = 4
_z$ = 36						; size = 4
_nsp$ = 40						; size = 4
_umax$ = 44						; size = 4
_jumax$ = 44						; size = 4
_isp$ = 44						; size = 4
_rsp$ = 48						; size = 4
_esp$ = 52						; size = 4
tv362 = 56						; size = 4
_path$ = 56						; size = 4
_flag_$ = 60						; size = 4
_emax$ = 64						; size = 4
_sdrvmd_ PROC						; COMDAT

; 70   : {

	push	ebp
	mov	ebp, esp

; 71   :      /* Initialized data */
; 72   : 
; 73   :      STATIC integer ratio = 2;
; 74   : 
; 75   :      STATIC integer mark, umax, d, q, u, jumax, il, jl, iu, ju;
; 76   :      STATIC integer iju;
; 77   :      STATIC integer tmp;
; 78   : 
; 79   : /* ==================================================================end 
; 80   : */
; 81   : 
; 82   : /*  DESCRIPTION */
; 83   : 
; 84   : /* ====================  change #2  (replacement) =====================2 
; 85   : */
; 86   : /* WAS: SDRV SOLVES SPARSE SYMMETRIC POSITIVE DEFINITE SYSTEMS OF LINEAR 
; 87   : */
; 88   : /* ===================================================================== 
; 89   : */
; 90   : /*     SDRVMD SOLVES SPARSE SYMMETRIC SYSTEMS OF LINEAR */
; 91   : /* ==================================================================end 
; 92   : */
; 93   : /*     EQUATIONS.  THE SOLUTION PROCESS IS DIVIDED INTO THREE STAGES -- */
; 94   : 
; 95   : /*        SSF - THE COEFFICIENT MATRIX M IS FACTORED SYMBOLICALLY TO */
; 96   : /*                DETERMINE WHERE FILLIN WILL OCCUR DURING THE NUMERIC */
; 97   : /*                FACTORIZATION. */
; 98   : 
; 99   : /* ====================  change #3  (replacement) =====================3 
; 100  : */
; 101  : /* WAS: SNF - M IS FACTORED NUMERICALLY INTO THE PRODUCT UT-D-U, WHERE */
; 102  : /* ===================================================================== 
; 103  : */
; 104  : /*        SNFMOD - M+E IS FACTORED NUMERICALLY BY THE GILL/MURRAY/WRIGHT */
; 105  : /*                MODIFIED CHOLESKY FACTORIZATION: M + E = UT-D-U, WHERE */
; 106  : /*                E IS DIAGONAL, */
; 107  : /* ==================================================================end 
; 108  : */
; 109  : /*                D IS DIAGONAL AND U IS UNIT UPPER TRIANGULAR. */
; 110  : 
; 111  : /*        SNS - THE LINEAR SYSTEM  MX = B  IS SOLVED USING THE UT-D-U */
; 112  : /*                FACTORIZATION FROM SNF. */
; 113  : 
; 114  : /*     FOR SEVERAL SYSTEMS WITH THE SAME COEFFICIENT MATRIX, SSF AND SNF */
; 115  : 
; 116  : /*     NEED BE DONE ONLY ONCE (FOR THE FIRST SYSTEM);  THEN SNS IS DONE */
; 117  : /*     ONCE FOR EACH ADDITIONAL RIGHT-HAND SIDE.  FOR SEVERAL SYSTEMS */
; 118  : /*     WHOSE COEFFICIENT MATRICES HAVE THE SAME NONZERO STRUCTURE, SSF */
; 119  : /*     NEED BE DONE ONLY ONCE (FOR THE FIRST SYSTEM);  THEN SNF AND SNS */
; 120  : /*     ARE DONE ONCE FOR EACH ADDITIONAL SYSTEM. */
; 121  : 
; 122  : 
; 123  : /*  STORAGE OF SPARSE MATRICES */
; 124  : 
; 125  : /*     THE NONZERO ENTRIES OF THE MATRIX M ARE STORED ROW-BY-ROW IN THE */
; 126  : /*     ARRAY A.  TO IDENTIFY THE INDIVIDUAL NONZERO ENTRIES IN EACH ROW, */
; 127  : 
; 128  : /*     WE NEED TO KNOW IN WHICH COLUMN EACH ENTRY LIES.  THESE COLUMN */
; 129  : /*     INDICES ARE STORED IN THE ARRAY JA;  I.E., IF  A(K) = M(I,J),  THEN 
; 130  : */
; 131  : /*     JA(K) = J.  TO IDENTIFY THE INDIVIDUAL ROWS, WE NEED TO KNOW WHERE 
; 132  : */
; 133  : /*     EACH ROW STARTS.  THESE ROW POINTERS ARE STORED IN THE ARRAY IA; */
; 134  : /*     I.E., IF M(I,J) IS THE FIRST NONZERO ENTRY (STORED) IN THE I-TH ROW 
; 135  : */
; 136  : /*     AND  A(K) = M(I,J),  THEN  IA(I) = K.  MOREOVER, IA(N+1) POINTS TO 
; 137  : */
; 138  : /*     THE FIRST LOCATION FOLLOWING THE LAST ELEMENT IN THE LAST ROW. */
; 139  : /*     THUS, THE NUMBER OF ENTRIES IN THE I-TH ROW IS  IA(I+1) - IA(I), */
; 140  : /*     THE NONZERO ENTRIES IN THE I-TH ROW ARE STORED CONSECUTIVELY IN */
; 141  : 
; 142  : /*                A(IA(I)),  A(IA(I)+1),  ..., A(IA(I+1)-1), */
; 143  : 
; 144  : /*     AND THE CORRESPONDING COLUMN INDICES ARE STORED CONSECUTIVELY IN */
; 145  : 
; 146  : /*                JA(IA(I)), JA(IA(I)+1), ..., JA(IA(I+1)-1). */
; 147  : 
; 148  : /*     SINCE THE COEFFICIENT MATRIX IS SYMMETRIC, ONLY THE NONZERO ENTRIES 
; 149  : */
; 150  : /*     IN THE UPPER TRIANGLE NEED BE STORED, FOR EXAMPLE, THE MATRIX */
; 151  : 
; 152  : /*                 ( 1  0  2  3  0 ) */
; 153  : /*                 ( 0  4  0  0  0 ) */
; 154  : /*            M = ( 2  0  5  6  0 ) */
; 155  : /*                 ( 3  0  6  7  8 ) */
; 156  : /*                 ( 0  0  0  8  9 ) */
; 157  : 
; 158  : /*     COULD BE STORED AS */
; 159  : 
; 160  : /*                \ 1  2  3  4  5  6  7  8  9 10 11 12 13 */
; 161  : /*            ---+-------------------------------------- */
; 162  : /*            IA \ 1  4  5  8 12 14 */
; 163  : /*            JA \ 1  3  4  2  1  3  4  1  3  4  5  4  5 */
; 164  : /*             A \ 1  2  3  4  2  5  6  3  6  7  8  8  9 */
; 165  : 
; 166  : /*     OR (SYMMETRICALLY) AS */
; 167  : 
; 168  : /*                \ 1  2  3  4  5  6  7  8  9 */
; 169  : /*            ---+-------------------------- */
; 170  : /*            IA \ 1  4  5  7  9 10 */
; 171  : /*            JA \ 1  3  4  2  3  4  4  5  5 */
; 172  : /*             A \ 1  2  3  4  5  6  7  8  9             . */
; 173  : 
; 174  : 
; 175  : /*  REORDERING THE ROWS AND COLUMNS OF M */
; 176  : 
; 177  : /*     A SYMMETRIC PERMUTATION OF THE ROWS AND COLUMNS OF THE COEFFICIENT 
; 178  : */
; 179  : /*     MATRIX M (E.G., WHICH REDUCES FILLIN OR ENHANCES NUMERICAL */
; 180  : /*     STABILITY) MUST BE SPECIFIED.  THE SOLUTION Z IS RETURNED IN THE */
; 181  : /*     ORIGINAL ORDER. */
; 182  : 
; 183  : /*     TO SPECIFY THE TRIVIAL ORDERING (I.E., THE IDENTITY PERMUTATION), */
; 184  : 
; 185  : /*     SET  P(I) = IP(I) = I,  I=1,...,N.  IN THIS CASE, P AND IP CAN BE */
; 186  : 
; 187  : /*     THE SAME ARRAY. */
; 188  : 
; 189  : /*     IF A NONTRIVIAL ORDERING (I.E., NOT THE IDENTITY PERMUTATION) IS */
; 190  : /*     SPECIFIED AND M IS STORED SYMMETRICALLY (I.E., NOT BOTH M(I,J) AND 
; 191  : */
; 192  : /*     M(J,I) ARE STORED FOR I NE J), THEN ODRV SHOULD BE CALLED (WITH */
; 193  : /*     PATH = 3 OR 5) TO SYMMETRICALLY REORDER (IA,JA,A) BEFORE CALLING */
; 194  : /*     SDRV.  THIS IS TO ENSURE THAT IF M(I,J) WILL BE IN THE UPPER */
; 195  : /*     TRIANGLE OF M WITH RESPECT TO THE NEW ORDERING, THEN M(I,J) IS */
; 196  : /*     STORED IN ROW I (AND THUS M(J,I) IS NOT STORED);  WHEREAS IF M(I,J) 
; 197  : */
; 198  : /*     WILL BE IN THE STRICT LOWER TRIANGLE OF M, THEN M(J,I) IS STORED IN 
; 199  : */
; 200  : /*     ROW J (AND THUS M(I,J) IS NOT STORED). */
; 201  : 
; 202  : 
; 203  : /*  PARAMETERS */
; 204  : 
; 205  : /*     N     - NUMBER OF VARIABLES/EQUATIONS */
; 206  : 
; 207  : /*     P     - INTEGER ONE-DIMENSIONAL ARRAY SPECIFYING A PERMUTATION OF */
; 208  : /*              THE ROWS AND COLUMNS OF M;  DIMENSION = N */
; 209  : 
; 210  : /*     IP    - INTEGER ONE-DIMENSIONAL ARRAY CONTAINING THE INVERSE OF THE 
; 211  : */
; 212  : /*              PERMUTATION SPECIFIED IN P;  I.E., IP(P(I)) = I, I=1,...,N; 
; 213  : */
; 214  : /*              DIMENSION = N */
; 215  : 
; 216  : /*     IA    - INTEGER ONE-DIMENSIONAL ARRAY CONTAINING POINTERS TO DELIMIT 
; 217  : */
; 218  : /*              ROWS IN JA AND A;  DIMENSION = N+1 */
; 219  : 
; 220  : /*     JA    - INTEGER ONE-DIMENSIONAL ARRAY CONTAINING THE COLUMN INDICES 
; 221  : */
; 222  : /*              CORRESPONDING TO THE ELEMENTS OF A;  DIMENSION = NUMBER OF */
; 223  : 
; 224  : /*              NONZERO ENTRIES IN M STORED */
; 225  : 
; 226  : /*     A     - REAL ONE-DIMENSIONAL ARRAY CONTAINING THE NONZERO ENTRIES IN 
; 227  : */
; 228  : /*              THE COEFFICIENT MATRIX M, STORED BY ROWS;  DIMENSION = */
; 229  : /*              NUMBER OF NONZERO ENTRIES IN M STORED */
; 230  : 
; 231  : /*     B     - REAL ONE-DIMENSIONAL ARRAY CONTAINING THE RIGHT-HAND SIDE B; 
; 232  : */
; 233  : /*              B AND Z CAN BE THE SAME ARRAY;  DIMENSION = N */
; 234  : 
; 235  : /*     Z     - REAL ONE-DIMENSIONAL ARRAY CONTAINING THE SOLUTION X;  Z AND 
; 236  : */
; 237  : /*              B CAN BE THE SAME ARRAY;  DIMENSION = N */
; 238  : 
; 239  : /*     NSP  - DECLARED DIMENSION OF THE ONE-DIMENSIONAL ARRAYS ISP AND */
; 240  : /*              RSP;  NSP MUST BE (SUBSTANTIALLY) LARGER THAN  3N+2K,  WHERE 
; 241  : */
; 242  : /*              K = NUMBER OF NONZERO ENTRIES IN THE UPPER TRIANGLE OF M */
; 243  : 
; 244  : /*     ISP  - INTEGER ONE-DIMENSIONAL ARRAY USED FOR WORKING STORAGE;  ISP 
; 245  : */
; 246  : /*              AND RSP SHOULD BE EQUIVALENCED;  DIMENSION = NSP */
; 247  : 
; 248  : /*     RSP  - REAL ONE-DIMENSIONAL ARRAY USED FOR WORKING STORAGE;  RSP */
; 249  : /*              AND ISP SHOULD BE EQUIVALENCED;  DIMENSION = NSP */
; 250  : 
; 251  : /*     ESP  - INTEGER VARIABLE;  IF SUFFICIENT STORAGE WAS AVAILABLE TO */
; 252  : /*              PERFORM THE SYMBOLIC FACTORIZATION (SSF), THEN ESP IS SET TO 
; 253  : */
; 254  : /*              THE AMOUNT OF EXCESS STORAGE PROVIDED (NEGATIVE IF */
; 255  : /*              INSUFFICIENT STORAGE WAS AVAILABLE TO PERFORM THE NUMERIC */
; 256  : /*              FACTORIZATION (SNF)) */
; 257  : 
; 258  : /*     PATH - INTEGER PATH SPECIFICATION;  VALUES AND THEIR MEANINGS ARE - 
; 259  : */
; 260  : /*                 1  PERFORM SSF, SNF, AND SNS */
; 261  : /*                 2  PERFORM SNF AND SNS (ISP/RSP IS ASSUMED TO HAVE BEEN */
; 262  : /*                        SET UP IN AN EARLIER CALL TO SDRV (FOR SSF)) */
; 263  : /*                 3  PERFORM SNS ONLY (ISP/RSP IS ASSUMED TO HAVE BEEN SET */
; 264  : /*                        UP IN AN EARLIER CALL TO SDRV (FOR SSF AND SNF)) */
; 265  : /*                 4  PERFORM SSF */
; 266  : /*                 5  PERFORM SSF AND SNF */
; 267  : /*                 6  PERFORM SNF ONLY (ISP/RSP IS ASSUMED TO HAVE BEEN SET */
; 268  : /*                        UP IN AN EARLIER CALL TO SDRV (FOR SSF)) */
; 269  : /* K.B.          7  Perform semi-SNS to convert B from D coordinates to 
; 270  :                             M coordinates.  Useful for finding downhill
; 271  :                             vector for semidefinite matrix.    12/28/93  */
; 272  : 
; 273  : /*     FLAG - INTEGER ERROR FLAG;  VALUES AND THEIR MEANINGS ARE - */
; 274  : 
; 275  : /*                    0      NO ERRORS DETECTED */
; 276  : /*                  2N+K    DUPLICATE ENTRY IN A  --  ROW = K */
; 277  : /*                  6N+K    INSUFFICIENT STORAGE IN SSF  --  ROW = K */
; 278  : /*                  7N+1    INSUFFICIENT STORAGE IN SNF */
; 279  : /*                  8N+K    ZERO PIVOT  --  ROW = K */
; 280  : /*                 10N+1    INSUFFICIENT STORAGE IN SDRV */
; 281  : /*                 11N+1    ILLEGAL PATH SPECIFICATION */
; 282  : 
; 283  : /* ====================  change #4  (insertion) =======================4 */
; 284  : /*                  <0      MATRIX NOT SUFF. POS-DEF (detected in SNFMOD) */
; 285  : /*                            FLAG IS SET TO MINUS THE INDEX (IN THE ORIGINAL */
; 286  : /*                            MATRIX) OF THE LARGEST ADDITION in E */
; 287  : /*                        Flag is minus number of negative diagonals.  */
; 288  : /* ==================================================================end */
; 289  : 
; 290  : 
; 291  : /*  CONVERSION FROM REAL TO DOUBLE PRECISION */
; 292  : 
; 293  : /*     CHANGE THE REAL DECLARATIONS IN SDRV, SNF, AND SNS TO DOUBLE */
; 294  : /*     PRECISION DECLARATIONS;  AND CHANGE THE VALUE IN THE DATA STATEMENT 
; 295  : */
; 296  : /*     FOR THE INTEGER VARIABLE RATIO (IN SDRV) FROM 1 TO 2. */
; 297  : 
; 298  : /*  NOTE: FOR CRAY, SET RATIO to 1! */
; 299  : /* -----------------------------------------------------------------------
; 300  :  */
; 301  : 
; 302  : /*         REAL  A(1),  B(1),  Z(1),  RSP(1) */
; 303  : /*         DATA  RATIO/1/ */
; 304  :      /* Parameter adjustments */
; 305  :      --rsp;

	mov	ecx, DWORD PTR _rsp$[ebp]

; 306  :      --isp;

	mov	eax, 4

; 307  :      --z;
; 308  :      --b;
; 309  :      --a;
; 310  :      --ja;

	sub	DWORD PTR _ja$[ebp], eax

; 311  :      --ia;

	sub	DWORD PTR _ia$[ebp], eax

; 312  :      --ip;

	sub	DWORD PTR _ip$[ebp], eax

; 313  :      --p;

	sub	DWORD PTR _p$[ebp], eax
	sub	esp, 20					; 00000014H
	push	esi
	mov	esi, DWORD PTR _isp$[ebp]
	sub	esi, eax

; 314  : 
; 315  :      /* Function Body */
; 316  : 
; 317  : /* ----VALIDATE PATH SPECIFICATION */
; 318  :      if (*path < 1 || 7 < *path) {

	mov	eax, DWORD PTR _path$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	edx, 8
	sub	DWORD PTR _z$[ebp], edx
	sub	DWORD PTR _b$[ebp], edx
	sub	DWORD PTR _a$[ebp], edx
	sub	ecx, edx
	mov	DWORD PTR _rsp$[ebp], ecx
	cmp	eax, 1
	jl	$L111$89320
	cmp	eax, 7
	jg	$L111$89320

; 319  :           goto L111;
; 320  :      }
; 321  : 
; 322  : /* ----ALLOCATE STORAGE AND FACTOR M SYMBOLICALLY TO DETERMINE FILL-IN */
; 323  :      iju = 1;
; 324  :      iu = iju + *n;

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edx]
	push	ebx
	push	edi
	lea	edi, DWORD PTR [eax+1]

; 325  :      jl = iu + *n + 1;

	lea	edx, DWORD PTR [eax+edi+1]

; 326  :      ju = jl + *n;

	lea	ebx, DWORD PTR [eax+edx]
	mov	DWORD PTR _jl$[ebp], edx

; 327  :      q = *nsp + 1 - *n;

	mov	edx, DWORD PTR _nsp$[ebp]
	mov	edx, DWORD PTR [edx]
	sub	edx, eax
	inc	edx
	mov	DWORD PTR _q$[ebp], edx

; 328  :      mark = q - *n;

	sub	edx, eax

; 329  :      jumax = mark - ju;
; 330  : 
; 331  :      if ((*path - 1) * (*path - 4) * (*path - 5) != 0) {

	mov	eax, DWORD PTR _path$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _mark$[ebp], edx
	sub	edx, ebx
	mov	DWORD PTR _jumax$[ebp], edx
	lea	edx, DWORD PTR [eax-5]
	add	eax, -4					; fffffffcH
	imul	edx, eax
	mov	eax, DWORD PTR _path$[ebp]
	mov	eax, DWORD PTR [eax]
	dec	eax
	imul	edx, eax
	test	edx, edx
	jne	SHORT $L1$89322

; 332  :           goto L1;
; 333  :      }
; 334  :      if (jumax <= 0) {

	cmp	DWORD PTR _jumax$[ebp], edx
	jle	$L110$89324

; 335  :           goto L110;
; 336  :      }
; 337  :      ssf_(n, &p[1], &ip[1], &ia[1], &ja[1], &isp[iju], &isp[ju], &isp[iu], &
; 338  :                 jumax, &isp[q], &isp[mark], &isp[jl], flag_);

	mov	ecx, DWORD PTR _flag_$[ebp]
	mov	edx, DWORD PTR _jl$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _mark$[ebp]
	lea	eax, DWORD PTR [esi+edx*4]
	push	eax
	mov	eax, DWORD PTR _q$[ebp]
	lea	edx, DWORD PTR [esi+ecx*4]
	push	edx
	lea	ecx, DWORD PTR [esi+eax*4]
	push	ecx
	lea	edx, DWORD PTR _jumax$[ebp]
	push	edx
	lea	eax, DWORD PTR [esi+edi*4]
	push	eax
	mov	eax, DWORD PTR _ja$[ebp]
	lea	ecx, DWORD PTR [esi+ebx*4]
	push	ecx
	mov	ecx, DWORD PTR _ia$[ebp]
	lea	edx, DWORD PTR [esi+4]
	push	edx
	mov	edx, DWORD PTR _ip$[ebp]
	add	eax, 4
	push	eax
	mov	eax, DWORD PTR _p$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _n$[ebp]
	add	edx, 4
	push	edx
	add	eax, 4
	push	eax
	push	ecx
	call	_ssf_

; 339  :      if (*flag_ != 0) {

	mov	edx, DWORD PTR _flag_$[ebp]
	add	esp, 52					; 00000034H
	cmp	DWORD PTR [edx], 0
	jne	$LN22@sdrvmd_
	mov	ecx, DWORD PTR _rsp$[ebp]
$L1$89322:

; 340  :           goto L100;
; 341  :      }
; 342  : 
; 343  : /* ----ALLOCATE STORAGE AND FACTOR M NUMERICALLY */
; 344  : L1:
; 345  :      il = ju + isp[iju + (*n - 1)];

	mov	eax, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+eax*4]
	add	eax, ebx
	mov	DWORD PTR _il$[ebp], eax

; 346  :      tmp = (il - 1 + (ratio - 1)) / ratio + 1;

	cdq
	sub	eax, edx

; 347  :      d = tmp + *n;

	mov	edx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [edx]
	sar	eax, 1
	inc	eax
	add	edx, eax
	mov	DWORD PTR _tmp$[ebp], eax

; 348  :      u = d + *n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _d$[ebp], edx
	add	edx, eax

; 349  :      umax = *nsp + 1 - u;

	mov	eax, DWORD PTR _nsp$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, edx
	inc	eax
	mov	DWORD PTR _u$[ebp], edx

; 350  :      *esp = umax - (isp[iu + *n] - 1);

	mov	edx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR _umax$[ebp], eax
	add	edx, edi
	sub	eax, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR _esp$[ebp]
	inc	eax
	mov	DWORD PTR [edx], eax

; 351  : 
; 352  :      if ((*path - 1) * (*path - 2) * (*path - 5) * (*path - 6) != 0) {

	mov	eax, DWORD PTR _path$[ebp]
	mov	eax, DWORD PTR [eax]
	lea	edx, DWORD PTR [eax-6]
	add	eax, -5					; fffffffbH
	imul	edx, eax
	mov	eax, DWORD PTR _path$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, -2					; fffffffeH
	imul	edx, eax
	mov	eax, DWORD PTR _path$[ebp]
	mov	eax, DWORD PTR [eax]
	dec	eax
	imul	edx, eax
	test	edx, edx
	jne	SHORT $L2$89328

; 353  :           goto L2;
; 354  :      }
; 355  :      if (umax <= 0) {

	cmp	DWORD PTR _umax$[ebp], edx
	jle	$L110$89324

; 356  :           goto L110;
; 357  :      }
; 358  : /* ====================  change #5  (replacement) =====================5 
; 359  : */
; 360  : /*  WAS:    CALL SNF */
; 361  : /* ==================================================================end 
; 362  : */
; 363  :      snfmod_(n, &p[1], &ip[1], &ia[1], &ja[1], &a[1], &rsp[d], &isp[iju], &isp[
; 364  :                 ju], &isp[iu], &rsp[u], &umax, &isp[il], &isp[jl], flag_, emax);

	mov	edx, DWORD PTR _emax$[ebp]
	mov	eax, DWORD PTR _flag_$[ebp]
	push	edx
	mov	edx, DWORD PTR _jl$[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR _il$[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+edx*4]
	push	eax
	mov	eax, DWORD PTR _u$[ebp]
	lea	edx, DWORD PTR _umax$[ebp]
	push	edx
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	lea	eax, DWORD PTR [esi+edi*4]
	push	eax
	lea	edx, DWORD PTR [esi+ebx*4]
	push	edx
	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [esi+4]
	push	eax
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _ja$[ebp]
	push	eax
	mov	eax, DWORD PTR _ia$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _ip$[ebp]
	add	edx, 4
	push	edx
	mov	edx, DWORD PTR _p$[ebp]
	add	eax, 4
	push	eax
	mov	eax, DWORD PTR _n$[ebp]
	add	ecx, 4
	push	ecx
	add	edx, 4
	push	edx
	push	eax
	call	_snfmod_

; 365  : /* ====================  change #6  (replacement) =====================6 
; 366  : */
; 367  : /*  WAS:            IF (FLAG.NE.0)  GO TO 100 */
; 368  : /* ==================================================================end 
; 369  : */
; 370  :      if (*flag_ > 0) {

	mov	ecx, DWORD PTR _flag_$[ebp]
	add	esp, 64					; 00000040H
	cmp	DWORD PTR [ecx], 0

; 387  : 
; 388  : L3:
; 389  :      return 0;
; 390  : 
; 391  : /* ** ERROR -- ERROR DETECTED IN SSF, SNF, OR SNS */
; 392  : L100:
; 393  :      return 0;

	jg	SHORT $LN22@sdrvmd_

; 365  : /* ====================  change #6  (replacement) =====================6 
; 366  : */
; 367  : /*  WAS:            IF (FLAG.NE.0)  GO TO 100 */
; 368  : /* ==================================================================end 
; 369  : */
; 370  :      if (*flag_ > 0) {

	mov	ecx, DWORD PTR _rsp$[ebp]
$L2$89328:

; 371  :           goto L100;
; 372  :      }
; 373  : 
; 374  : /* ----SOLVE SYSTEM OF LINEAR EQUATIONS  MX = B */
; 375  : L2:
; 376  :      if ((*path - 1) * (*path - 2) * (*path - 3) * (*path - 7) != 0) {

	mov	edx, DWORD PTR _path$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	edx, DWORD PTR [eax-7]
	mov	DWORD PTR tv362[ebp], eax
	add	eax, -3					; fffffffdH
	imul	edx, eax
	mov	eax, DWORD PTR tv362[ebp]
	add	eax, -2					; fffffffeH
	imul	edx, eax
	mov	eax, DWORD PTR tv362[ebp]
	dec	eax
	imul	edx, eax
	test	edx, edx
	jne	SHORT $LN22@sdrvmd_

; 377  :           goto L3;
; 378  :      }
; 379  :      if (umax <= 0) {

	cmp	DWORD PTR _umax$[ebp], edx
	jg	SHORT $LN3@sdrvmd_
$L110$89324:

; 394  : /* ** ERROR -- INSUFFICIENT STORAGE */
; 395  : L110:
; 396  :      *flag_ = *n * 10 + 1;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flag_$[ebp]
	lea	edx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+edx+1]
	mov	DWORD PTR [ecx], eax
$LN22@sdrvmd_:

; 397  :      return 0;

	pop	edi
	pop	ebx
	xor	eax, eax
	pop	esi

; 401  :      return 0;
; 402  : 
; 403  : } /* end sdrvmd_() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@sdrvmd_:

; 380  :           goto L110;
; 381  :      }
; 382  :      if ( *path == 7 ) /* K.B. */

	cmp	DWORD PTR tv362[ebp], 7
	jne	SHORT $LN2@sdrvmd_

; 383  :         ysmp_negvector(n, &p[1], &rsp[d], &isp[iju], &isp[ju], &isp[iu], 
; 384  :             &rsp[u], &z[1], &b[1], &rsp[tmp]);

	mov	edx, DWORD PTR _tmp$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	edx, DWORD PTR _b$[ebp]
	push	eax
	mov	eax, DWORD PTR _z$[ebp]
	add	edx, 8
	push	edx
	mov	edx, DWORD PTR _u$[ebp]
	add	eax, 8
	push	eax
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	lea	edx, DWORD PTR [esi+edi*4]
	push	edx
	mov	edx, DWORD PTR _d$[ebp]
	lea	eax, DWORD PTR [esi+ebx*4]
	push	eax
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	add	esi, 4
	push	esi
	push	eax
	add	ecx, 4
	push	ecx
	push	edx
	call	_ysmp_negvector

; 385  :      else  sns_(n, &p[1], &rsp[d], &isp[iju], &isp[ju], &isp[iu], 
; 386  :             &rsp[u], &z[1], &b[1], &rsp[tmp]);

	add	esp, 40					; 00000028H
	pop	edi
	pop	ebx
$L100$89326:
$L3$89332:

; 397  :      return 0;

	xor	eax, eax
	pop	esi

; 401  :      return 0;
; 402  : 
; 403  : } /* end sdrvmd_() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@sdrvmd_:

; 385  :      else  sns_(n, &p[1], &rsp[d], &isp[iju], &isp[ju], &isp[iu], 
; 386  :             &rsp[u], &z[1], &b[1], &rsp[tmp]);

	mov	eax, DWORD PTR _tmp$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _b$[ebp]
	push	edx
	mov	edx, DWORD PTR _z$[ebp]
	add	eax, 8
	push	eax
	mov	eax, DWORD PTR _u$[ebp]
	add	edx, 8
	push	edx
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	lea	eax, DWORD PTR [esi+edi*4]
	push	eax
	mov	eax, DWORD PTR _d$[ebp]
	lea	edx, DWORD PTR [esi+ebx*4]
	push	edx
	mov	edx, DWORD PTR _p$[ebp]
	add	esi, 4
	push	esi
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _n$[ebp]
	push	ecx
	add	edx, 4
	push	edx
	push	eax
	call	_sns_
	add	esp, 40					; 00000028H
	pop	edi
	pop	ebx
$L100_1$89326:
$L3_2$89332:

; 397  :      return 0;

	xor	eax, eax
	pop	esi

; 401  :      return 0;
; 402  : 
; 403  : } /* end sdrvmd_() */

	mov	esp, ebp
	pop	ebp
	ret	0
$L111$89320:

; 398  : /* ** ERROR -- ILLEGAL PATH SPECIFICATION */
; 399  : L111:
; 400  :      *flag_ = *n * 11 + 1;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _flag_$[ebp]
	imul	edx, 11					; 0000000bH
	inc	edx
	mov	DWORD PTR [eax], edx
	xor	eax, eax
	pop	esi

; 401  :      return 0;
; 402  : 
; 403  : } /* end sdrvmd_() */

	mov	esp, ebp
	pop	ebp
	ret	0
_sdrvmd_ ENDP
_TEXT	ENDS
END
