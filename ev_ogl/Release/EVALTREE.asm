; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\EVALTREE.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_debugging_flag:DWORD
COMM	_breakcount:DWORD
COMM	_subshell_frame:DWORD:064H
COMM	_current_debug_line:DWORD
COMM	_breaklist:QWORD:064H
_DATA	ENDS
PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_unset_attr
; Function compile flags: /Ogtp
;	COMDAT _unset_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_unset_attr PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 29   :   elptr(id)->attr &= ~attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	not	ecx
	and	DWORD PTR [eax+8], ecx
	not	edx
	and	DWORD PTR [eax+12], edx

; 30   : }

	pop	ebp
	ret	0
_unset_attr ENDP
_TEXT	ENDS
PUBLIC	_get_fe_edge
; Function compile flags: /Ogtp
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _get_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_facet PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp

; 84   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 85   :     return inverse_id(feptr(fe_id)->nextfacet[1]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]
	xor	eax, 134217728				; 08000000H

; 88   : }

	pop	ebp
	ret	0
$LN2@get_prev_f:

; 86   :   else 
; 87   :     return feptr(fe_id)->nextfacet[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]

; 88   : }

	pop	ebp
	ret	0
_get_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_get_edge_wrap
EXTRN	_sym_inverse:DWORD
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_wrap PROC					; COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  :   WRAPTYPE wrap = *EINT(e_id,E_WRAP_ATTR) ;

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+784]
	mov	eax, DWORD PTR [eax+edx]
	pop	esi

; 165  :   return    ( inverted(e_id) ? (*sym_inverse)(wrap) : wrap );

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN4@get_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@get_edge_w:

; 166  : }

	pop	ebp
	ret	0
_get_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_@2
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_@2:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_@2
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_@2:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	_get_body_facet
; Function compile flags: /Ogtp
;	COMDAT _get_body_facet
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_facet PROC					; COMDAT

; 279  : { return ( valid_id(b_id) ? bptr(b_id)->f_id : NULLID ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+400]
	pop	ebp
	ret	0
$LN3@get_body_f:
	xor	eax, eax
	pop	ebp
	ret	0
_get_body_facet ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_get_body_density
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_body_density
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_density PROC					; COMDAT

; 305  :     { return  ( valid_id(b_id) ?  bptr(b_id)->density : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_d
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+344]
	pop	ebp
	ret	0
$LN3@get_body_d:
	fldz
	pop	ebp
	ret	0
_get_body_density ENDP
_TEXT	ENDS
PUBLIC	_get_body_volume
; Function compile flags: /Ogtp
;	COMDAT _get_body_volume
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volume PROC					; COMDAT

; 308  :     { return    ( valid_id(b_id) ?  bptr(b_id)->volume : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]
	pop	ebp
	ret	0
$LN3@get_body_v:
	fldz
	pop	ebp
	ret	0
_get_body_volume ENDP
_TEXT	ENDS
PUBLIC	_get_body_fixvol
; Function compile flags: /Ogtp
;	COMDAT _get_body_fixvol
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_fixvol PROC					; COMDAT

; 311  :      { return ( valid_id(b_id) ?  bptr(b_id)->fixvol : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f@2
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+32]
	pop	ebp
	ret	0
$LN3@get_body_f@2:
	fldz
	pop	ebp
	ret	0
_get_body_fixvol ENDP
_TEXT	ENDS
PUBLIC	_get_body_pressure
; Function compile flags: /Ogtp
;	COMDAT _get_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_pressure PROC					; COMDAT

; 317  :     { return  ( valid_id(b_id) ?    bptr(b_id)->pressure : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_p
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+312]
	pop	ebp
	ret	0
$LN3@get_body_p:
	fldz
	pop	ebp
	ret	0
_get_body_pressure ENDP
_TEXT	ENDS
PUBLIC	_get_body_volconst
; Function compile flags: /Ogtp
;	COMDAT _get_body_volconst
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volconst PROC					; COMDAT

; 320  :   { return    ( valid_id(b_id) ?  bptr(b_id)->volconst : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v@2
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+328]
	pop	ebp
	ret	0
$LN3@get_body_v@2:
	fldz
	pop	ebp
	ret	0
_get_body_volconst ENDP
_TEXT	ENDS
PUBLIC	_set_body_density
; Function compile flags: /Ogtp
;	COMDAT _set_body_density
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_density PROC					; COMDAT

; 323  :       {         ( valid_id(b_id) ?  bptr(b_id)->density = (v) : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@set_body_d
	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+344]
$LN3@set_body_d:
	pop	ebp
	ret	0
_set_body_density ENDP
_TEXT	ENDS
PUBLIC	_set_body_pressure
; Function compile flags: /Ogtp
;	COMDAT _set_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_pressure PROC					; COMDAT

; 326  :       {         ( valid_id(b_id) ?  bptr(b_id)->pressure = (v) : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@set_body_p
	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+312]
$LN3@set_body_p:
	pop	ebp
	ret	0
_set_body_pressure ENDP
_TEXT	ENDS
PUBLIC	_get_extra
; Function compile flags: /Ogtp
;	COMDAT _get_extra
_TEXT	SEGMENT
_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_extra PROC						; COMDAT

; 348  : { int type = id_type(id);

	push	ebp
	mov	ebp, esp

; 349  : 
; 350  :   return ( (char*)elptr(id) + EXTRAS(type)[n].offset);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	shr	eax, 29					; 0000001dH
	imul	esi, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, esi
	add	eax, DWORD PTR [edi+ecx+64]
	pop	edi
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_get_extra ENDP
_TEXT	ENDS
PUBLIC	_get_meth_offset
; Function compile flags: /Ogtp
;	COMDAT _get_meth_offset
_TEXT	SEGMENT
_type$ = 8						; size = 4
_get_meth_offset PROC					; COMDAT

; 376  : { int meth_offset;

	push	ebp
	mov	ebp, esp

; 377  :   meth_offset = EXTRAS(type)[web.meth_attr[type]].offset; 

	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR _web[eax*4+5664]
	imul	eax, 112				; 00000070H

; 378  :   return meth_offset;

	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR [ecx+edx+64]

; 379  : }

	pop	ebp
	ret	0
_get_meth_offset ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@NNFNJGIL@T1?5swaps?3?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0BD@BBGPJFJF@Edges?5swapped?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@KACBHHOP@pop_quad_to_quad?5count?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@PEDKAOCI@pop_edge_to_tri?5count?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@JEEKMHGC@pop_tri_to_edge?5count?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@BGIMLONO@Edges?5popped?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@CLGHNEFK@Vertices?5popped?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@DMMMGPBB@Facets?5reversed?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@PLMNHAIE@Edges?5reversed?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@PPJACOKD@Bodies?5dissolved?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@LAICONBO@Facets?5dissolved?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@DACAILMK@Edges?5dissolved?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@HONGIAHG@Vertices?5dissolved?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@GMOPDIEK@Facets?5refined?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@LKFIBJDB@Edges?5refined?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@LJHADBKI@Facets?5deleted?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@GPMHBAND@Edges?5deleted?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@GPJLFDDO@Edges?5equiangulated?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0N@FKKKIJJJ@Unfixed?3?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0L@GNADMKFE@Fixed?3?5?$CFd?6?$AA@		; `string'
PUBLIC	_flush_counts
EXTRN	_outstring:PROC
EXTRN	_sprintf:PROC
EXTRN	_msg:DWORD
;	COMDAT ??_C@_0O@NNFNJGIL@T1?5swaps?3?5?$CFd?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\evaltree.c
CONST	SEGMENT
??_C@_0O@NNFNJGIL@T1?5swaps?3?5?$CFd?6?$AA@ DB 'T1 swaps: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BBGPJFJF@Edges?5swapped?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BD@BBGPJFJF@Edges?5swapped?3?5?$CFd?6?$AA@ DB 'Edges swapped: %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KACBHHOP@pop_quad_to_quad?5count?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BM@KACBHHOP@pop_quad_to_quad?5count?3?5?$CFd?6?$AA@ DB 'pop_quad_t'
	DB	'o_quad count: %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PEDKAOCI@pop_edge_to_tri?5count?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BL@PEDKAOCI@pop_edge_to_tri?5count?3?5?$CFd?6?$AA@ DB 'pop_edge_to'
	DB	'_tri count: %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JEEKMHGC@pop_tri_to_edge?5count?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BL@JEEKMHGC@pop_tri_to_edge?5count?3?5?$CFd?6?$AA@ DB 'pop_tri_to_'
	DB	'edge count: %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BGIMLONO@Edges?5popped?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BC@BGIMLONO@Edges?5popped?3?5?$CFd?6?$AA@ DB 'Edges popped: %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CLGHNEFK@Vertices?5popped?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BF@CLGHNEFK@Vertices?5popped?3?5?$CFd?6?$AA@ DB 'Vertices popped: '
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DMMMGPBB@Facets?5reversed?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BF@DMMMGPBB@Facets?5reversed?3?5?$CFd?6?$AA@ DB 'Facets reversed: '
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PLMNHAIE@Edges?5reversed?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BE@PLMNHAIE@Edges?5reversed?3?5?$CFd?6?$AA@ DB 'Edges reversed: %d'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PPJACOKD@Bodies?5dissolved?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BG@PPJACOKD@Bodies?5dissolved?3?5?$CFd?6?$AA@ DB 'Bodies dissolved'
	DB	': %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LAICONBO@Facets?5dissolved?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BG@LAICONBO@Facets?5dissolved?3?5?$CFd?6?$AA@ DB 'Facets dissolved'
	DB	': %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DACAILMK@Edges?5dissolved?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BF@DACAILMK@Edges?5dissolved?3?5?$CFd?6?$AA@ DB 'Edges dissolved: '
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HONGIAHG@Vertices?5dissolved?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BI@HONGIAHG@Vertices?5dissolved?3?5?$CFd?6?$AA@ DB 'Vertices disso'
	DB	'lved: %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GMOPDIEK@Facets?5refined?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BE@GMOPDIEK@Facets?5refined?3?5?$CFd?6?$AA@ DB 'Facets refined: %d'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LKFIBJDB@Edges?5refined?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BD@LKFIBJDB@Edges?5refined?3?5?$CFd?6?$AA@ DB 'Edges refined: %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LJHADBKI@Facets?5deleted?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BE@LJHADBKI@Facets?5deleted?3?5?$CFd?6?$AA@ DB 'Facets deleted: %d'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GPMHBAND@Edges?5deleted?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BD@GPMHBAND@Edges?5deleted?3?5?$CFd?6?$AA@ DB 'Edges deleted: %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GPJLFDDO@Edges?5equiangulated?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BJ@GPJLFDDO@Edges?5equiangulated?3?5?$CFd?6?$AA@ DB 'Edges equiang'
	DB	'ulated: %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FKKKIJJJ@Unfixed?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0N@FKKKIJJJ@Unfixed?3?5?$CFd?6?$AA@ DB 'Unfixed: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GNADMKFE@Fixed?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@GNADMKFE@Fixed?3?5?$CFd?6?$AA@ DB 'Fixed: %d', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _flush_counts
_TEXT	SEGMENT
_flush_counts PROC					; COMDAT

; 6462 :      if ( web.counts_changed & fix_count_bit )

	test	DWORD PTR _web+5524, 524288		; 00080000H
	je	SHORT $LN20@flush_coun

; 6463 :      { sprintf(msg,"Fixed: %d\n",web.fix_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5508
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0L@GNADMKFE@Fixed?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN20@flush_coun:

; 6464 : 
; 6465 :      if ( web.counts_changed & unfix_count_bit )

	test	DWORD PTR _web+5524, 1048576		; 00100000H
	je	SHORT $LN19@flush_coun

; 6466 :      { sprintf(msg,"Unfixed: %d\n",web.unfix_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5512
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0N@FKKKIJJJ@Unfixed?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN19@flush_coun:

; 6467 : 
; 6468 :      if ( web.counts_changed & equi_count_bit )

	test	BYTE PTR _web+5524, 1
	je	SHORT $LN18@flush_coun

; 6469 :      { sprintf(msg,"Edges equiangulated: %d\n",web.equi_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5432
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BJ@GPJLFDDO@Edges?5equiangulated?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN18@flush_coun:

; 6470 : 
; 6471 :      if ( web.counts_changed & edge_delete_count_bit )

	test	BYTE PTR _web+5524, 4
	je	SHORT $LN17@flush_coun

; 6472 :      { sprintf(msg,"Edges deleted: %d\n",web.edge_delete_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5436
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BD@GPMHBAND@Edges?5deleted?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN17@flush_coun:

; 6473 : 
; 6474 :      if ( web.counts_changed & facet_delete_count_bit )

	test	BYTE PTR _web+5524, 8
	je	SHORT $LN16@flush_coun

; 6475 :      { sprintf(msg,"Facets deleted: %d\n",web.facet_delete_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5440
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BE@LJHADBKI@Facets?5deleted?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN16@flush_coun:

; 6476 : 
; 6477 :      if ( web.counts_changed & edge_refine_count_bit )

	test	BYTE PTR _web+5524, 16			; 00000010H
	je	SHORT $LN15@flush_coun

; 6478 :      { sprintf(msg,"Edges refined: %d\n",web.edge_refine_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5444
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BD@LKFIBJDB@Edges?5refined?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN15@flush_coun:

; 6479 : 
; 6480 :      if ( web.counts_changed & facet_refine_count_bit )

	test	BYTE PTR _web+5524, 32			; 00000020H
	je	SHORT $LN14@flush_coun

; 6481 :      { sprintf(msg,"Facets refined: %d\n",web.facet_refine_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5448
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BE@GMOPDIEK@Facets?5refined?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN14@flush_coun:

; 6482 : 
; 6483 :      if ( web.counts_changed & vertex_dissolve_count_bit )

	test	BYTE PTR _web+5524, -128		; ffffff80H
	je	SHORT $LN13@flush_coun

; 6484 :      { sprintf(msg,"Vertices dissolved: %d\n",web.vertex_dissolve_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5452
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BI@HONGIAHG@Vertices?5dissolved?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN13@flush_coun:

; 6485 : 
; 6486 :      if ( web.counts_changed & edge_dissolve_count_bit )

	test	DWORD PTR _web+5524, 256		; 00000100H
	je	SHORT $LN12@flush_coun

; 6487 :      { sprintf(msg, "Edges dissolved: %d\n",web.edge_dissolve_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5456
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BF@DACAILMK@Edges?5dissolved?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN12@flush_coun:

; 6488 : 
; 6489 :      if ( web.counts_changed & facet_dissolve_count_bit )

	test	DWORD PTR _web+5524, 512		; 00000200H
	je	SHORT $LN11@flush_coun

; 6490 :      { sprintf(msg,"Facets dissolved: %d\n",web.facet_dissolve_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5460
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BG@LAICONBO@Facets?5dissolved?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN11@flush_coun:

; 6491 : 
; 6492 :      if ( web.counts_changed & body_dissolve_count_bit )

	test	DWORD PTR _web+5524, 1024		; 00000400H
	je	SHORT $LN10@flush_coun

; 6493 :      { sprintf(msg,"Bodies dissolved: %d\n",web.body_dissolve_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5464
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BG@PPJACOKD@Bodies?5dissolved?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN10@flush_coun:

; 6494 : 
; 6495 :      if ( web.counts_changed & edge_reverse_count_bit )

	test	DWORD PTR _web+5524, 4194304		; 00400000H
	je	SHORT $LN9@flush_coun

; 6496 :      { sprintf(msg, "Edges reversed: %d\n",web.edge_reverse_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5468
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BE@PLMNHAIE@Edges?5reversed?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN9@flush_coun:

; 6497 : 
; 6498 :      if ( web.counts_changed & facet_reverse_count_bit )

	test	DWORD PTR _web+5524, 8388608		; 00800000H
	je	SHORT $LN8@flush_coun

; 6499 :      { sprintf(msg, "Facets reversed: %d\n",web.facet_reverse_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5472
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BF@DMMMGPBB@Facets?5reversed?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN8@flush_coun:

; 6500 : 
; 6501 :      if ( web.counts_changed & vertex_pop_count_bit )

	test	DWORD PTR _web+5524, 2048		; 00000800H
	je	SHORT $LN7@flush_coun

; 6502 :      { sprintf(msg,"Vertices popped: %d\n",web.vertex_pop_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5476
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BF@CLGHNEFK@Vertices?5popped?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN7@flush_coun:

; 6503 : 
; 6504 :      if ( web.counts_changed & edge_pop_count_bit )

	test	DWORD PTR _web+5524, 4096		; 00001000H
	je	SHORT $LN6@flush_coun

; 6505 :      { sprintf(msg,"Edges popped: %d\n",web.edge_pop_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5480
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BC@BGIMLONO@Edges?5popped?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN6@flush_coun:

; 6506 : 
; 6507 :      if ( web.counts_changed & pop_tri_to_edge_count_bit )

	test	DWORD PTR _web+5524, 16384		; 00004000H
	je	SHORT $LN5@flush_coun

; 6508 :      { sprintf(msg,"pop_tri_to_edge count: %d\n",web.pop_tri_to_edge_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5484
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BL@JEEKMHGC@pop_tri_to_edge?5count?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN5@flush_coun:

; 6509 : 
; 6510 :      if ( web.counts_changed & pop_edge_to_tri_count_bit )

	test	DWORD PTR _web+5524, 32768		; 00008000H
	je	SHORT $LN4@flush_coun

; 6511 :      { sprintf(msg,"pop_edge_to_tri count: %d\n",web.pop_edge_to_tri_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5488
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BL@PEDKAOCI@pop_edge_to_tri?5count?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN4@flush_coun:

; 6512 : 
; 6513 :      if ( web.counts_changed & pop_quad_to_quad_count_bit )

	test	DWORD PTR _web+5524, 65536		; 00010000H
	je	SHORT $LN3@flush_coun

; 6514 :      { sprintf(msg,"pop_quad_to_quad count: %d\n",web.pop_quad_to_quad_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5492
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BM@KACBHHOP@pop_quad_to_quad?5count?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN3@flush_coun:

; 6515 : 
; 6516 :      if ( web.counts_changed & edgeswap_count_bit )

	test	DWORD PTR _web+5524, 262144		; 00040000H
	je	SHORT $LN2@flush_coun

; 6517 :      { sprintf(msg,"Edges swapped: %d\n",web.edgeswap_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5500
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BD@BBGPJFJF@Edges?5swapped?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN2@flush_coun:

; 6518 : 
; 6519 :      if ( web.counts_changed & t1_edgeswap_count_bit )

	test	DWORD PTR _web+5524, 2097152		; 00200000H
	je	SHORT $LN23@flush_coun

; 6520 :      { sprintf(msg,"T1 swaps: %d\n",web.t1_edgeswap_count); outstring(msg); }

	mov	eax, DWORD PTR _web+5504
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0O@NNFNJGIL@T1?5swaps?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN23@flush_coun:

; 6521 : 
; 6522 : 
; 6523 :      web.counts_reported = ~0;
; 6524 :      web.counts_changed  = 0;

	mov	DWORD PTR _web+5524, 0
	mov	DWORD PTR _web+5520, -1

; 6525 : 
; 6526 : }  // end flush_counts()

	ret	0
_flush_counts ENDP
_TEXT	ENDS
PUBLIC	_reset_counts
; Function compile flags: /Ogtp
;	COMDAT _reset_counts
_TEXT	SEGMENT
_reset_counts PROC					; COMDAT

; 6538 :      web.equi_count = 0;

	xor	eax, eax
	mov	DWORD PTR _web+5432, eax

; 6539 :      web.edge_delete_count = 0;

	mov	DWORD PTR _web+5436, eax

; 6540 :      web.facet_delete_count = 0;

	mov	DWORD PTR _web+5440, eax

; 6541 :      web.edge_refine_count = 0;

	mov	DWORD PTR _web+5444, eax

; 6542 :      web.facet_refine_count = 0;

	mov	DWORD PTR _web+5448, eax

; 6543 :      web.notch_count = 0;
; 6544 :      web.vertex_dissolve_count = 0;

	mov	DWORD PTR _web+5452, eax

; 6545 :      web.edge_dissolve_count = 0;

	mov	DWORD PTR _web+5456, eax

; 6546 :      web.facet_dissolve_count = 0;

	mov	DWORD PTR _web+5460, eax

; 6547 :      web.body_dissolve_count = 0;

	mov	DWORD PTR _web+5464, eax

; 6548 :      web.edge_reverse_count = 0;

	mov	DWORD PTR _web+5468, eax

; 6549 :      web.facet_reverse_count = 0;

	mov	DWORD PTR _web+5472, eax

; 6550 :      web.vertex_pop_count = 0;

	mov	DWORD PTR _web+5476, eax

; 6551 :      web.edge_pop_count = 0;

	mov	DWORD PTR _web+5480, eax

; 6552 :      web.pop_tri_to_edge_count = 0;

	mov	DWORD PTR _web+5484, eax

; 6553 :      web.pop_edge_to_tri_count = 0;

	mov	DWORD PTR _web+5488, eax

; 6554 :      web.pop_quad_to_quad_count = 0;

	mov	DWORD PTR _web+5492, eax

; 6555 :      web.where_count = 0;

	mov	DWORD PTR _web+5496, eax

; 6556 :      web.edgeswap_count = 0;

	mov	DWORD PTR _web+5500, eax

; 6557 :      web.fix_count = 0;

	mov	DWORD PTR _web+5508, eax

; 6558 :      web.unfix_count = 0;

	mov	DWORD PTR _web+5512, eax

; 6559 :      web.t1_edgeswap_count = 0;

	mov	DWORD PTR _web+5504, eax

; 6560 :      web.notch_count = 0;

	mov	DWORD PTR _web+5516, eax

; 6561 : 
; 6562 :      web.counts_reported = 0;

	mov	DWORD PTR _web+5520, eax

; 6563 :      web.counts_changed  = 0; 

	mov	DWORD PTR _web+5524, eax

; 6564 : 
; 6565 : #ifdef PROFILING_ENABLED
; 6566 :    { int i;
; 6567 :      for ( i = LOW_INST ; i < meth_inst_count ; i++ )
; 6568 :      { struct method_instance *mi = METH_INSTANCE(i);
; 6569 :        mi->value_call_count = mi->grad_call_count = mi->hess_call_count = 0;
; 6570 :        mi->value_elapsed_time = mi->grad_elapsed_time 
; 6571 :          = mi->hess_elapsed_time = 0.0;
; 6572 :      }
; 6573 :      for ( i = 0 ; i < 2 ; i++ )
; 6574 :      { element_setup_elapsed_time[i] = 0;
; 6575 :        calc_quants_elapsed_time[i] = 0;
; 6576 :        calc_quant_grads_elapsed_time[i] = 0;
; 6577 :        calc_quant_hess_elapsed_time[i] = 0;
; 6578 :        exparse_elapsed_time[i] = 0;
; 6579 :        yyparse_elapsed_time[i] = 0;
; 6580 :        yylex_elapsed_time[i] = 0;
; 6581 :        kblex_elapsed_time[i] = 0;
; 6582 :        hessian_solve_elapsed_time[i] = 0;
; 6583 :        hessian_mul_elapsed_time[i] = 0;
; 6584 :        hessian_AIJ_setup_elapsed_time[i] = 0;
; 6585 :        hessian_constraint_setup_elapsed_time[i] = 0;
; 6586 :        hessian_project_setup_elapsed_time[i] = 0;
; 6587 :        hessian_factor_elapsed_time[i] = 0;
; 6588 :        hessian_CHinvC_elapsed_time[i] = 0;
; 6589 :      }
; 6590 :      find_cpu_speed();
; 6591 :    }
; 6592 : #endif
; 6593 : } // end reset_counts()

	ret	0
_reset_counts ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@JKBABGKM@Facet?5index?0?5?$CFd?0?5exceeds?5number?5@ ; `string'
PUBLIC	??_C@_0DL@GPAGLJBP@Vertex?5index?0?5?$CFd?0?5exceeds?5number@ ; `string'
PUBLIC	??_C@_0DG@HHKGBCBA@Edge?5index?0?5?$CFd?0?5exceeds?5number?5o@ ; `string'
PUBLIC	??_C@_0BF@MJOFPPG@Facet?5has?5no?5edges?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@CJDPOKNP@Facet?5?$CFd?5does?5not?5have?5body?5of?5i@ ; `string'
PUBLIC	??_C@_0CO@JEIJBJNB@Illegal?5facet?5body?5index?5?$CFd?$DL?5mus@ ; `string'
PUBLIC	??_C@_0DL@DGCEOMEP@Index?0?5?$CFd?0?5exceeds?5the?5number?5of@ ; `string'
PUBLIC	??_C@_0DH@NEGIGCFB@Facet?5index?0?5?$CFd?0?5exceeds?5number?5@ ; `string'
PUBLIC	??_C@_0DC@GLCPPLLK@Facetedge?5index?0?5?$CFd?0?5exceeds?5val@ ; `string'
PUBLIC	??_C@_0BI@OGEBOFAD@Edge?5?$CFs?5has?5no?5facets?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@OBODHBMJ@Edge?5index?5?$CFd?5exceeds?5valence?5of@ ; `string'
PUBLIC	??_C@_0BJ@MADMBEHM@Vertex?5?$CFs?5has?5no?5edges?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DE@IJLDHHGO@Facet?5index?5?$CFd?5exceeds?5facet?5val@ ; `string'
PUBLIC	??_C@_0BK@JCLNBKGI@Vertex?5?$CFs?5has?5no?5facets?4?6?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@GFIPANE@Element?5index?5must?5be?5positive?5i@ ; `string'
PUBLIC	_get_indexed_subtype
EXTRN	_get_next_body_facet:PROC
EXTRN	_oid:PROC
EXTRN	_get_next_vertex_facet:PROC
EXTRN	_elnames:BYTE
EXTRN	_valid_element:PROC
EXTRN	_get_vertex_first_facet:PROC
EXTRN	_kb_error:PROC
EXTRN	_file_names:DWORD
EXTRN	_errmsg:BYTE
;	COMDAT ??_C@_0DH@JKBABGKM@Facet?5index?0?5?$CFd?0?5exceeds?5number?5@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DH@JKBABGKM@Facet?5index?0?5?$CFd?0?5exceeds?5number?5@ DB 'Facet '
	DB	'index, %d, exceeds number of facets on body %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GPAGLJBP@Vertex?5index?0?5?$CFd?0?5exceeds?5number@
CONST	SEGMENT
??_C@_0DL@GPAGLJBP@Vertex?5index?0?5?$CFd?0?5exceeds?5number@ DB 'Vertex '
	DB	'index, %d, exceeds number of vertices on facet %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HHKGBCBA@Edge?5index?0?5?$CFd?0?5exceeds?5number?5o@
CONST	SEGMENT
??_C@_0DG@HHKGBCBA@Edge?5index?0?5?$CFd?0?5exceeds?5number?5o@ DB 'Edge i'
	DB	'ndex, %d, exceeds number of edges on facet %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MJOFPPG@Facet?5has?5no?5edges?4?6?$AA@
CONST	SEGMENT
??_C@_0BF@MJOFPPG@Facet?5has?5no?5edges?4?6?$AA@ DB 'Facet has no edges.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CJDPOKNP@Facet?5?$CFd?5does?5not?5have?5body?5of?5i@
CONST	SEGMENT
??_C@_0CK@CJDPOKNP@Facet?5?$CFd?5does?5not?5have?5body?5of?5i@ DB 'Facet '
	DB	'%d does not have body of index %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JEIJBJNB@Illegal?5facet?5body?5index?5?$CFd?$DL?5mus@
CONST	SEGMENT
??_C@_0CO@JEIJBJNB@Illegal?5facet?5body?5index?5?$CFd?$DL?5mus@ DB 'Illeg'
	DB	'al facet body index %d; must be 1 or 2.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@DGCEOMEP@Index?0?5?$CFd?0?5exceeds?5the?5number?5of@
CONST	SEGMENT
??_C@_0DL@DGCEOMEP@Index?0?5?$CFd?0?5exceeds?5the?5number?5of@ DB 'Index,'
	DB	' %d, exceeds the number of vertices on an edge, %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@NEGIGCFB@Facet?5index?0?5?$CFd?0?5exceeds?5number?5@
CONST	SEGMENT
??_C@_0DH@NEGIGCFB@Facet?5index?0?5?$CFd?0?5exceeds?5number?5@ DB 'Facet '
	DB	'index, %d, exceeds number of facets on edge %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@GLCPPLLK@Facetedge?5index?0?5?$CFd?0?5exceeds?5val@
CONST	SEGMENT
??_C@_0DC@GLCPPLLK@Facetedge?5index?0?5?$CFd?0?5exceeds?5val@ DB 'Faceted'
	DB	'ge index, %d, exceeds valence on edge %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OGEBOFAD@Edge?5?$CFs?5has?5no?5facets?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@OGEBOFAD@Edge?5?$CFs?5has?5no?5facets?4?6?$AA@ DB 'Edge %s has '
	DB	'no facets.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@OBODHBMJ@Edge?5index?5?$CFd?5exceeds?5valence?5of@
CONST	SEGMENT
??_C@_0CN@OBODHBMJ@Edge?5index?5?$CFd?5exceeds?5valence?5of@ DB 'Edge ind'
	DB	'ex %d exceeds valence of vertex %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MADMBEHM@Vertex?5?$CFs?5has?5no?5edges?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@MADMBEHM@Vertex?5?$CFs?5has?5no?5edges?4?6?$AA@ DB 'Vertex %s h'
	DB	'as no edges.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IJLDHHGO@Facet?5index?5?$CFd?5exceeds?5facet?5val@
CONST	SEGMENT
??_C@_0DE@IJLDHHGO@Facet?5index?5?$CFd?5exceeds?5facet?5val@ DB 'Facet in'
	DB	'dex %d exceeds facet valence of vertex %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JCLNBKGI@Vertex?5?$CFs?5has?5no?5facets?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@JCLNBKGI@Vertex?5?$CFs?5has?5no?5facets?4?6?$AA@ DB 'Vertex %s '
	DB	'has no facets.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@ DB '('
	DB	'source file %s, line %d)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GFIPANE@Element?5index?5must?5be?5positive?5i@
CONST	SEGMENT
??_C@_0CH@GFIPANE@Element?5index?5must?5be?5positive?5i@ DB 'Element inde'
	DB	'x must be positive in %s.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\evaltree.c
CONST	ENDS
;	COMDAT _get_indexed_subtype
_TEXT	SEGMENT
tv1097 = -8						; size = 4
tv972 = -8						; size = 4
tv967 = -8						; size = 4
_first$ = -8						; size = 4
_id$ = -8						; size = 4
_next_id$ = -4						; size = 4
_node$ = 8						; size = 4
_n$ = 12						; size = 4
_ord$ = 12						; size = 4
tv480 = 16						; size = 4
_parent$ = 16						; size = 4
_ex$ = 20						; size = 4
_get_indexed_subtype PROC				; COMDAT

; 6609 : { element_id next_id = NULLID;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6610 :   element_id id;
; 6611 :   int n,i;
; 6612 :   facetedge_id fe;
; 6613 : 
; 6614 :           int ptype = id_type(parent);

	mov	ecx, DWORD PTR _parent$[ebp]
	push	ebx

; 6615 :           element_id first; /* sentinel for looping */
; 6616 : 
; 6617 :           if ( ord < 0 )

	mov	ebx, DWORD PTR _ord$[ebp]
	push	esi
	mov	esi, DWORD PTR _node$[ebp]
	push	edi
	mov	edi, ecx
	shr	edi, 29					; 0000001dH
	mov	DWORD PTR _next_id$[ebp], 0
	test	ebx, ebx
	jns	SHORT $LN106@get_indexe

; 6618 :           { sprintf(errmsg,"Element index must be positive in %s.\n",ex->name);

	mov	eax, DWORD PTR _ex$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0CH@GFIPANE@Element?5index?5must?5be?5positive?5i@
	push	OFFSET _errmsg
	call	_sprintf

; 6619 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6620 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL163@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL163@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6621 :             kb_error(1275,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1275					; 000004fbH
	call	_kb_error
	mov	ecx, DWORD PTR _parent$[ebp]
	add	esp, 28					; 0000001cH
$LN106@get_indexe:

; 6622 :           }
; 6623 :           id=NULLID;
; 6624 :           switch ( ptype )

	cmp	edi, 4
	ja	$LN3@get_indexe
	jmp	DWORD PTR $LN189@get_indexe[edi*4]
$LN103@get_indexe:

; 6625 :           { 
; 6626 :              case VERTEX:
; 6627 :              switch ( node->op1.eltype )/* subtype */ 

	mov	eax, DWORD PTR [esi+32]
	dec	eax
	je	$LN100@get_indexe
	dec	eax
	jne	$LN3@get_indexe

; 6648 :                break;
; 6649 :               
; 6650 :               case FACET: /* indexed facet of vertex */
; 6651 : 
; 6652 :               id = first = get_vertex_first_facet(parent);

	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_get_vertex_first_facet
	mov	ebx, eax

; 6653 :               if ( !valid_element(id) )

	push	ebx
	mov	edi, ebx
	call	_valid_element
	add	esp, 8
	test	eax, eax
	jne	$LN93@get_indexe

; 6654 :               { sprintf(errmsg,"Vertex %s has no facets.\n",ELNAME(parent));

	test	DWORD PTR _parent$[ebp], 268435456	; 10000000H
	je	SHORT $LN113@get_indexe
	mov	edx, DWORD PTR _parent$[ebp]
	and	edx, 134217727				; 07ffffffH
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN114@get_indexe
$LN113@get_indexe:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN114@get_indexe:
	push	eax
	push	OFFSET ??_C@_0BK@JCLNBKGI@Vertex?5?$CFs?5has?5no?5facets?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 6655 :                 sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6656 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL164@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL164@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6657 :                 kb_error(1278,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1278					; 000004feH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN93@get_indexe:

; 6658 :               }
; 6659 :               for ( n = 1 ; n <= ord ; n++ )

	mov	eax, DWORD PTR _ord$[ebp]
	cmp	eax, 1
	jl	$LN90@get_indexe
	mov	DWORD PTR tv1097[ebp], eax
	npad	1
$LL92@get_indexe:

; 6660 :               { id = get_next_vertex_facet(parent,id);

	mov	ecx, DWORD PTR _parent$[ebp]
	push	edi
	push	ecx
	call	_get_next_vertex_facet
	mov	edi, eax
	add	esp, 8

; 6661 :                 if ( equal_id(id,first) )

	cmp	edi, ebx
	jne	$LN91@get_indexe

; 6662 :                 { sprintf(errmsg,
; 6663 :                     "Facet index %d exceeds facet valence of vertex %s.\n",
; 6664 :                        ord+1,ELNAME(parent));

	test	DWORD PTR _parent$[ebp], 268435456	; 10000000H
	je	SHORT $LN115@get_indexe
	mov	edx, DWORD PTR _parent$[ebp]
	and	edx, 134217727				; 07ffffffH
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN116@get_indexe
$LN115@get_indexe:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN116@get_indexe:
	push	eax
	mov	eax, DWORD PTR _ord$[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_0DE@IJLDHHGO@Facet?5index?5?$CFd?5exceeds?5facet?5val@
	push	OFFSET _errmsg
	call	_sprintf

; 6665 :                   sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6666 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL165@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL165@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6667 :                   kb_error(1279,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1279					; 000004ffH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN91@get_indexe:

; 6658 :               }
; 6659 :               for ( n = 1 ; n <= ord ; n++ )

	dec	DWORD PTR tv1097[ebp]
	jne	$LL92@get_indexe
$LN90@get_indexe:

; 6668 :                 }
; 6669 :               }
; 6670 :               if ( id_type(id) == FACETEDGE )

	mov	ecx, edi
	and	ecx, -536870912				; e0000000H
	cmp	ecx, -2147483648			; 80000000H
	jne	SHORT $LN88@get_indexe

; 6671 :                 id = get_fe_facet(id);

	push	edi
	call	_get_fe_facet
	add	esp, 4
	mov	edi, eax
$LN88@get_indexe:

; 6672 :               next_id = positive_id(id);

	and	edi, -134217729				; f7ffffffH
	mov	DWORD PTR _next_id$[ebp], edi

; 6912 :              }
; 6913 :              break;
; 6914 :           }
; 6915 : 
; 6916 :           return next_id;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN100@get_indexe:

; 6628 :              { 
; 6629 :                case EDGE:  /* indexed edge of vertex */
; 6630 :                id = first = get_vertex_edge(parent);

	mov	edi, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+edi*4]
	mov	ebx, DWORD PTR [eax+28]

; 6631 :                if ( !valid_element(id) )

	push	ebx
	mov	DWORD PTR _first$[ebp], ebx
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	$LN182@get_indexe

; 6632 :                { sprintf(errmsg,"Vertex %s has no edges.\n",ELNAME(parent));

	test	DWORD PTR _parent$[ebp], 268435456	; 10000000H
	je	SHORT $LN109@get_indexe
	inc	edi
	push	edi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN110@get_indexe
$LN109@get_indexe:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN110@get_indexe:
	push	eax
	push	OFFSET ??_C@_0BJ@MADMBEHM@Vertex?5?$CFs?5has?5no?5edges?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 6633 :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6634 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL166@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL166@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6635 :                  kb_error(1276,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1276					; 000004fcH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN182@get_indexe:

; 6636 :                }
; 6637 :                for ( n = 1 ; n <= ord ; n++ )

	mov	edi, DWORD PTR _ord$[ebp]
	cmp	edi, 1
	jl	$LN96@get_indexe
	mov	DWORD PTR tv480[ebp], edi
$LL98@get_indexe:

; 6638 :                { id = get_next_tail_edge(id);

	mov	edx, DWORD PTR _web+124
	mov	ecx, ebx
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ebx*4]
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	ebx, DWORD PTR [eax+ecx*4+32]

; 6639 :                  if ( equal_id(id,first) )

	cmp	ebx, DWORD PTR _first$[ebp]
	jne	$LN97@get_indexe

; 6640 :                  { sprintf(errmsg,"Edge index %d exceeds valence of vertex %s.\n",
; 6641 :                      ord+1,ELNAME(id));

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN111@get_indexe
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN112@get_indexe
$LN111@get_indexe:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN112@get_indexe:
	push	eax
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	OFFSET ??_C@_0CN@OBODHBMJ@Edge?5index?5?$CFd?5exceeds?5valence?5of@
	push	OFFSET _errmsg
	call	_sprintf

; 6642 :                    sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6643 :                       file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL167@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL167@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6644 :                    kb_error(1277,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1277					; 000004fdH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN97@get_indexe:

; 6636 :                }
; 6637 :                for ( n = 1 ; n <= ord ; n++ )

	dec	DWORD PTR tv480[ebp]
	jne	$LL98@get_indexe
$LN96@get_indexe:
	pop	edi
	pop	esi

; 6645 :                  }
; 6646 :                }
; 6647 :                next_id = id;

	mov	DWORD PTR _next_id$[ebp], ebx

; 6912 :              }
; 6913 :              break;
; 6914 :           }
; 6915 : 
; 6916 :           return next_id;

	mov	eax, ebx
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN87@get_indexe:

; 6673 :               break;
; 6674 : 
; 6675 :              }
; 6676 :              break;
; 6677 : 
; 6678 :          case EDGE:
; 6679 :             switch ( node->op1.eltype /* subtype */ )

	mov	eax, DWORD PTR [esi+32]
	sub	eax, 0
	je	$LN84@get_indexe
	sub	eax, 2
	je	$LN75@get_indexe
	sub	eax, 2
	jne	$LN3@get_indexe

; 6722 :              break;
; 6723 : 
; 6724 :              case FACETEDGE: 
; 6725 :               id = first = get_edge_fe(parent);

	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_get_edge_fe
	mov	edi, eax

; 6726 :               if ( !valid_element(id) )

	push	edi
	mov	ebx, edi
	call	_valid_element
	add	esp, 8
	test	eax, eax
	jne	$LN68@get_indexe

; 6727 :               { sprintf(errmsg,"Edge %s has no facets.\n",ELNAME(parent));

	test	DWORD PTR _parent$[ebp], 268435456	; 10000000H
	je	SHORT $LN123@get_indexe
	mov	edx, DWORD PTR _parent$[ebp]
	and	edx, 134217727				; 07ffffffH
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN124@get_indexe
$LN123@get_indexe:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN124@get_indexe:
	push	eax
	push	OFFSET ??_C@_0BI@OGEBOFAD@Edge?5?$CFs?5has?5no?5facets?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 6728 :                 sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6729 :                      file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL168@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL168@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6730 :                 kb_error(1281,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1281					; 00000501H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN68@get_indexe:

; 6731 :               }
; 6732 :               for ( n = 1 ; n <= ord ; n++ )

	mov	eax, DWORD PTR _ord$[ebp]
	cmp	eax, 1
	jl	$LN65@get_indexe
	mov	DWORD PTR tv967[ebp], eax
	npad	2
$LL67@get_indexe:

; 6733 :               { id = get_next_facet(id);

	push	ebx
	call	_get_next_facet
	mov	ebx, eax
	add	esp, 4

; 6734 :                 if ( equal_id(id,first) )

	cmp	ebx, edi
	jne	$LN66@get_indexe

; 6735 :                 { sprintf(errmsg,
; 6736 :                     "Facetedge index, %d, exceeds valence on edge %s.\n",
; 6737 :                        ord+1,ELNAME(parent));

	test	DWORD PTR _parent$[ebp], 268435456	; 10000000H
	je	SHORT $LN125@get_indexe
	mov	ecx, DWORD PTR _parent$[ebp]
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN126@get_indexe
$LN125@get_indexe:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN126@get_indexe:
	mov	edx, DWORD PTR _ord$[ebp]
	push	eax
	inc	edx
	push	edx
	push	OFFSET ??_C@_0DC@GLCPPLLK@Facetedge?5index?0?5?$CFd?0?5exceeds?5val@
	push	OFFSET _errmsg
	call	_sprintf

; 6738 :                   sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6739 :                        file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL169@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL169@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6740 :                   kb_error(1282,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1282					; 00000502H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN66@get_indexe:

; 6731 :               }
; 6732 :               for ( n = 1 ; n <= ord ; n++ )

	dec	DWORD PTR tv967[ebp]
	jne	$LL67@get_indexe
$LN65@get_indexe:
	pop	edi
	pop	esi

; 6741 :                 }
; 6742 :               }
; 6743 :               next_id = id;

	mov	DWORD PTR _next_id$[ebp], ebx

; 6912 :              }
; 6913 :              break;
; 6914 :           }
; 6915 : 
; 6916 :           return next_id;

	mov	eax, ebx
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN75@get_indexe:

; 6698 :                  } 
; 6699 :               break;
; 6700 : 
; 6701 :             case FACET:
; 6702 :               id = first = get_edge_fe(parent);

	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_get_edge_fe
	mov	edi, eax

; 6703 :               if ( !valid_element(id) )

	push	edi
	mov	ebx, edi
	call	_valid_element
	add	esp, 8
	test	eax, eax
	jne	$LN74@get_indexe

; 6704 :               { sprintf(errmsg,"Edge %s has no facets.\n",ELNAME(parent));

	test	DWORD PTR _parent$[ebp], 268435456	; 10000000H
	je	SHORT $LN119@get_indexe
	mov	edx, DWORD PTR _parent$[ebp]
	and	edx, 134217727				; 07ffffffH
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN120@get_indexe
$LN119@get_indexe:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN120@get_indexe:
	push	eax
	push	OFFSET ??_C@_0BI@OGEBOFAD@Edge?5?$CFs?5has?5no?5facets?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 6705 :                 sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6706 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL170@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL170@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6707 :                 kb_error(1176,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1176					; 00000498H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN74@get_indexe:

; 6708 :               }
; 6709 :               for ( n = 1 ; n <= ord ; n++ )

	mov	eax, DWORD PTR _ord$[ebp]
	cmp	eax, 1
	jl	$LN71@get_indexe
	mov	DWORD PTR tv972[ebp], eax
$LL73@get_indexe:

; 6710 :               { id = get_next_facet(id);

	push	ebx
	call	_get_next_facet
	mov	ebx, eax
	add	esp, 4

; 6711 :                 if ( equal_id(id,first) )

	cmp	ebx, edi
	jne	$LN72@get_indexe

; 6712 :                 { sprintf(errmsg,
; 6713 :                      "Facet index, %d, exceeds number of facets on edge %s.\n",
; 6714 :                           ord+1,ELNAME(parent));

	test	DWORD PTR _parent$[ebp], 268435456	; 10000000H
	je	SHORT $LN121@get_indexe
	mov	ecx, DWORD PTR _parent$[ebp]
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN122@get_indexe
$LN121@get_indexe:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN122@get_indexe:
	mov	edx, DWORD PTR _ord$[ebp]
	push	eax
	inc	edx
	push	edx
	push	OFFSET ??_C@_0DH@NEGIGCFB@Facet?5index?0?5?$CFd?0?5exceeds?5number?5@
	push	OFFSET _errmsg
	call	_sprintf

; 6715 :                   sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6716 :                        file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL171@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL171@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6717 :                   kb_error(1186,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1186					; 000004a2H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN72@get_indexe:

; 6708 :               }
; 6709 :               for ( n = 1 ; n <= ord ; n++ )

	dec	DWORD PTR tv972[ebp]
	jne	$LL73@get_indexe
$LN71@get_indexe:

; 6718 :                 }
; 6719 : 
; 6720 :               }
; 6721 :              next_id = get_fe_facet(id);

	push	ebx
	call	_get_fe_facet

; 6910 :              { case EDGE: next_id = get_fe_edge(parent); break;

	add	esp, 4
	pop	edi
	pop	esi
	mov	DWORD PTR _next_id$[ebp], eax
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN84@get_indexe:

; 6680 :             { case VERTEX:
; 6681 :               if ( ord >= web.skel[EDGE].ctrlpts )

	mov	eax, DWORD PTR _web+120
	cmp	ebx, eax
	jl	SHORT $LN83@get_indexe

; 6682 :               { sprintf(errmsg,
; 6683 :                  "Index, %d, exceeds the number of vertices on an edge, %d.\n",
; 6684 :                      ord+1,web.skel[EDGE].ctrlpts);

	push	eax
	lea	ecx, DWORD PTR [ebx+1]
	push	ecx
	push	OFFSET ??_C@_0DL@DGCEOMEP@Index?0?5?$CFd?0?5exceeds?5the?5number?5of@
	push	OFFSET _errmsg
	call	_sprintf

; 6685 :                 sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6686 :                    file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL172@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL172@get_indexe
	mov	ecx, DWORD PTR [esi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [esi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 6687 :                 kb_error(1280,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1280					; 00000500H
	call	_kb_error
	mov	eax, DWORD PTR _web+120
	mov	ecx, DWORD PTR _parent$[ebp]
	add	esp, 28					; 0000001cH
$LN83@get_indexe:

; 6688 :               } 
; 6689 :               if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	jne	SHORT $LN82@get_indexe

; 6690 :               { next_id = get_edge_vertices(parent)
; 6691 :                   [inverted(parent) ? web.skel[EDGE].ctrlpts-ord-1 : ord]; 

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN117@get_indexe
	sub	eax, ebx
	dec	eax
	jmp	SHORT $LN118@get_indexe
$LN117@get_indexe:
	mov	eax, ebx
$LN118@get_indexe:
	mov	edx, DWORD PTR _web+124
	mov	esi, DWORD PTR _dymem
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	add	ecx, DWORD PTR [edx+esi+304]
	pop	edi
	mov	eax, DWORD PTR [ecx+eax*4]
	pop	esi

; 6910 :              { case EDGE: next_id = get_fe_edge(parent); break;

	mov	DWORD PTR _next_id$[ebp], eax
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN82@get_indexe:

; 6692 :               }
; 6693 :               else 
; 6694 :                  switch ( ord )

	mov	eax, ebx
	sub	eax, 0
	je	SHORT $LN78@get_indexe
	dec	eax
	je	SHORT $LN77@get_indexe
	dec	eax
	jne	$LN3@get_indexe

; 6697 :                    case 2: next_id = get_edge_midv(parent); break;

	mov	edx, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	edx, DWORD PTR [eax+ecx+8]
	pop	edi
	pop	esi
	mov	DWORD PTR _next_id$[ebp], edx

; 6912 :              }
; 6913 :              break;
; 6914 :           }
; 6915 : 
; 6916 :           return next_id;

	mov	eax, edx
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN77@get_indexe:

; 6696 :                    case 1: next_id = get_edge_headv(parent); break;

	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_get_edge_headv

; 6910 :              { case EDGE: next_id = get_fe_edge(parent); break;

	add	esp, 4
	pop	edi
	pop	esi
	mov	DWORD PTR _next_id$[ebp], eax
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN78@get_indexe:

; 6695 :                  { case 0: next_id = get_edge_tailv(parent); break;

	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_get_edge_tailv

; 6910 :              { case EDGE: next_id = get_fe_edge(parent); break;

	add	esp, 4
	pop	edi
	pop	esi
	mov	DWORD PTR _next_id$[ebp], eax
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@get_indexe:

; 6744 :               break;
; 6745 :             }
; 6746 :             break;
; 6747 :           
; 6748 :          case FACET:
; 6749 :              switch ( node->op1.eltype /* subtype */ )

	mov	eax, DWORD PTR [esi+32]
	sub	eax, 0
	je	$LN60@get_indexe
	dec	eax
	je	$LN33@get_indexe
	sub	eax, 2
	jne	$LN3@get_indexe

; 6856 :                  break;
; 6857 :              
; 6858 :                 case BODY:
; 6859 :                   switch ( ord )

	mov	eax, ebx
	sub	eax, 0
	je	SHORT $LN18@get_indexe
	dec	eax
	je	SHORT $LN17@get_indexe

; 6863 :                     default: 
; 6864 :                       sprintf(errmsg,
; 6865 :                        "Illegal facet body index %d; must be 1 or 2.\n",ord+1);

	lea	edx, DWORD PTR [ebx+1]
	push	edx
	push	OFFSET ??_C@_0CO@JEIJBJNB@Illegal?5facet?5body?5index?5?$CFd?$DL?5mus@
	push	OFFSET _errmsg
	call	_sprintf

; 6866 :                       sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6867 :                        file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL173@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL173@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6868 :                       kb_error(1287,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1287					; 00000507H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 6869 :                       break;

	jmp	SHORT $LN19@get_indexe
$LN17@get_indexe:

; 6861 :                     case 1: next_id = get_facet_body(inverse_id(parent)); 

	mov	ecx, DWORD PTR _parent$[ebp]
	xor	ecx, 134217728				; 08000000H
	push	ecx

; 6862 :                             break;

	jmp	SHORT $LN187@get_indexe
$LN18@get_indexe:

; 6860 :                   { case 0: next_id = get_facet_body(parent); break;

	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
$LN187@get_indexe:
	call	_get_facet_body
	mov	DWORD PTR _next_id$[ebp], eax
	add	esp, 4
$LN19@get_indexe:

; 6870 :                  }
; 6871 :                  if ( !valid_id(next_id) )

	test	DWORD PTR _next_id$[ebp], 268435456	; 10000000H
	jne	$LN3@get_indexe

; 6872 :                  { sprintf(errmsg,"Facet %d does not have body of index %d.\n",
; 6873 :                       oid(parent),ord+1);

	mov	eax, DWORD PTR _parent$[ebp]
	inc	ebx
	push	ebx
	push	eax
	call	_oid
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CK@CJDPOKNP@Facet?5?$CFd?5does?5not?5have?5body?5of?5i@
	push	OFFSET _errmsg
	call	_sprintf

; 6874 :                    sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6875 :                      file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL174@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL174@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6876 :                    kb_error(2070,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2070					; 00000816H
	call	_kb_error

; 6912 :              }
; 6913 :              break;
; 6914 :           }
; 6915 : 
; 6916 :           return next_id;

	mov	eax, DWORD PTR _next_id$[ebp]
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@get_indexe:

; 6823 : 
; 6824 :                 break;
; 6825 : 
; 6826 :                case EDGE:
; 6827 :                  id = first = get_facet_fe(parent);

	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_get_facet_fe
	mov	ebx, eax

; 6828 :                  if ( !valid_element(id) )

	push	ebx
	mov	DWORD PTR _first$[ebp], ebx
	mov	edi, ebx
	call	_valid_element
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@get_indexe

; 6829 :                  { sprintf(errmsg,"Facet has no edges.\n");

	push	OFFSET ??_C@_0BF@MJOFPPG@Facet?5has?5no?5edges?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 6830 :                    sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6831 :                         file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL175@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL175@get_indexe
	mov	ecx, DWORD PTR [esi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [esi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 6832 :                    kb_error(1285,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1285					; 00000505H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN32@get_indexe:

; 6833 :                  }
; 6834 : 
; 6835 :                  if ( inverted(parent) && (web.representation == STRING) ) 

	test	DWORD PTR _parent$[ebp], 134217728	; 08000000H
	je	SHORT $LN183@get_indexe
	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN183@get_indexe

; 6836 :                  { facetedge_id nextfe=id,startfe=id;

	mov	eax, ebx
$LL30@get_indexe:

; 6837 :                    /* go back round to find start */
; 6838 :                    do
; 6839 :                    { id = nextfe;
; 6840 :                      nextfe = get_prev_edge(id);

	push	eax
	mov	edi, eax
	call	_get_prev_edge
	add	esp, 4

; 6841 :                    } while ( valid_id(nextfe) && !equal_id(nextfe,startfe) );

	test	eax, 268435456				; 10000000H
	je	SHORT $LN27@get_indexe
	cmp	eax, ebx
	jne	SHORT $LL30@get_indexe
$LN27@get_indexe:

; 6842 :                    first = id;

	mov	DWORD PTR _first$[ebp], edi
$LN183@get_indexe:

; 6843 :                  }
; 6844 :                  for ( n = 1 ; n <= ord ; n++ )

	cmp	DWORD PTR _ord$[ebp], 1
	jl	$LN24@get_indexe
	mov	ebx, DWORD PTR _ord$[ebp]
	npad	4
$LL26@get_indexe:

; 6845 :                    { id = get_next_edge(id);

	push	edi
	call	_get_next_edge
	mov	edi, eax
	add	esp, 4

; 6846 :                      if ( !valid_id(id) || equal_id(id,first) )

	test	edi, 268435456				; 10000000H
	je	SHORT $LN22@get_indexe
	cmp	edi, DWORD PTR _first$[ebp]
	jne	$LN25@get_indexe
$LN22@get_indexe:

; 6847 :                      { sprintf(errmsg,
; 6848 :                     "Edge index, %d, exceeds number of edges on facet %s.\n",
; 6849 :                           ord+1,ELNAME(parent));

	test	DWORD PTR _parent$[ebp], 268435456	; 10000000H
	je	SHORT $LN133@get_indexe
	mov	eax, DWORD PTR _parent$[ebp]
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN134@get_indexe
$LN133@get_indexe:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN134@get_indexe:
	mov	ecx, DWORD PTR _ord$[ebp]
	push	eax
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_0DG@HHKGBCBA@Edge?5index?0?5?$CFd?0?5exceeds?5number?5o@
	push	OFFSET _errmsg
	call	_sprintf

; 6850 :                       sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6851 :                           file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL176@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL176@get_indexe
	mov	ecx, DWORD PTR [esi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [esi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 6852 :                        kb_error(1286,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1286					; 00000506H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN25@get_indexe:

; 6843 :                  }
; 6844 :                  for ( n = 1 ; n <= ord ; n++ )

	dec	ebx
	jne	$LL26@get_indexe
$LN24@get_indexe:

; 6853 :                      }
; 6854 :                    }
; 6855 :                    next_id = get_fe_edge(id);

	mov	ecx, DWORD PTR _web+460
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	and	edi, 134217728				; 08000000H
	xor	edi, DWORD PTR [edx+20]
	mov	DWORD PTR _next_id$[ebp], edi

; 6912 :              }
; 6913 :              break;
; 6914 :           }
; 6915 : 
; 6916 :           return next_id;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN60@get_indexe:

; 6750 :              { case VERTEX:
; 6751 :                  if ( (web.representation == SIMPLEX) ||
; 6752 :                       (web.modeltype == LAGRANGE) )

	mov	eax, DWORD PTR _web+624
	cmp	eax, 3
	je	$LN58@get_indexe
	cmp	DWORD PTR _web+628, 3
	je	$LN58@get_indexe

; 6762 :                    break;
; 6763 :                  }
; 6764 :                  if ( web.representation == SOAPFILM )

	cmp	eax, 2
	jne	$LN56@get_indexe

; 6765 :                  { if ( ord >= web.skel[FACET].ctrlpts )

	cmp	ebx, DWORD PTR _web+232
	jl	$LN55@get_indexe

; 6766 :                    { sprintf(errmsg,
; 6767 :                   "Vertex index, %d, exceeds number of vertices on facet %s.\n",
; 6768 :                         ord+1,ELNAME(parent));

	test	DWORD PTR _parent$[ebp], 268435456	; 10000000H
	je	SHORT $LN129@get_indexe
	mov	eax, DWORD PTR _parent$[ebp]
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN130@get_indexe
$LN129@get_indexe:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN130@get_indexe:
	push	eax
	lea	ecx, DWORD PTR [ebx+1]
	push	ecx
	push	OFFSET ??_C@_0DL@GPAGLJBP@Vertex?5index?0?5?$CFd?0?5exceeds?5number@
	push	OFFSET _errmsg
	call	_sprintf

; 6769 :                     sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6770 :                           file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL177@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL177@get_indexe
	mov	ecx, DWORD PTR [esi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [esi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 6771 :                      kb_error(3504,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3504					; 00000db0H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN55@get_indexe:

; 6772 :                    }
; 6773 :                    fe = get_facet_fe(parent);

	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_get_facet_fe
	add	esp, 4

; 6774 :                    if ( ord < 3 )

	cmp	ebx, 3
	jge	SHORT $LN188@get_indexe

; 6775 :                    { for ( i = 0 ; i < ord ; i++ )

	test	ebx, ebx
	jle	SHORT $LN51@get_indexe
	mov	esi, ebx
$LL53@get_indexe:

; 6776 :                        fe = get_next_edge(fe);

	push	eax
	call	_get_next_edge
	add	esp, 4
	dec	esi
	jne	SHORT $LL53@get_indexe
$LN51@get_indexe:

; 6777 :                      next_id = get_fe_tailv(fe);

	push	eax
	call	_get_fe_edge
	push	eax
	call	_get_edge_tailv
	add	esp, 8
	pop	edi
	pop	esi

; 6910 :              { case EDGE: next_id = get_fe_edge(parent); break;

	mov	DWORD PTR _next_id$[ebp], eax
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN188@get_indexe:

; 6778 :                    }
; 6779 :                    else 
; 6780 :                    { for ( i = 3 ; i < ord ; i++ )

	jle	SHORT $LN47@get_indexe
	lea	esi, DWORD PTR [ebx-3]
$LL49@get_indexe:

; 6781 :                        fe = get_next_edge(fe);

	push	eax
	call	_get_next_edge
	add	esp, 4
	dec	esi
	jne	SHORT $LL49@get_indexe
$LN47@get_indexe:

; 6782 :                      next_id = get_fe_midv(fe);

	push	eax
	call	_get_fe_edge
	mov	ecx, DWORD PTR _web+124
	add	esp, 4
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	ecx, DWORD PTR [edx+eax+8]
	pop	edi
	pop	esi
	mov	DWORD PTR _next_id$[ebp], ecx

; 6912 :              }
; 6913 :              break;
; 6914 :           }
; 6915 : 
; 6916 :           return next_id;

	mov	eax, ecx
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@get_indexe:

; 6783 :                    }
; 6784 :                    break;
; 6785 :                  }
; 6786 : 
; 6787 :                  /* now string */
; 6788 :                  id = first = get_facet_fe(parent);

	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_get_facet_fe

; 6789 :                  if ( !valid_element(id) )

	push	eax
	mov	DWORD PTR _first$[ebp], eax
	mov	edi, eax
	call	_valid_element
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN46@get_indexe

; 6790 :                  {  sprintf(errmsg,"Facet has no edges.\n");

	push	OFFSET ??_C@_0BF@MJOFPPG@Facet?5has?5no?5edges?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 6791 :                     sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6792 :                          file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL178@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL178@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6793 :                     kb_error(1283,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1283					; 00000503H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN46@get_indexe:

; 6794 :                  }
; 6795 :                  if ( inverted(parent) ) 

	test	DWORD PTR _parent$[ebp], 134217728	; 08000000H
	je	SHORT $LN45@get_indexe

; 6796 :                  { facetedge_id nextfe=id,startfe=id;

	mov	eax, DWORD PTR _first$[ebp]
	npad	5
$LL44@get_indexe:

; 6797 :                    /* go back round to find start */
; 6798 :                    do
; 6799 :                    { id = nextfe;
; 6800 :                      nextfe = get_prev_edge(id);

	push	eax
	mov	edi, eax
	call	_get_prev_edge
	add	esp, 4

; 6801 :                    } while ( valid_id(nextfe) && !equal_id(nextfe,startfe) );

	test	eax, 268435456				; 10000000H
	je	SHORT $LN41@get_indexe
	cmp	eax, DWORD PTR _first$[ebp]
	jne	SHORT $LL44@get_indexe
$LN41@get_indexe:

; 6802 :                    first = id;

	mov	DWORD PTR _first$[ebp], edi
$LN45@get_indexe:

; 6803 :                  }
; 6804 :                  for ( n = 1 ; n <= ord ; n++ )

	mov	DWORD PTR _n$[ebp], 1
	cmp	ebx, 1
	jl	$LN38@get_indexe
	npad	6
$LL40@get_indexe:

; 6805 :                    { edge_id next_edge = get_next_edge(id);

	push	edi
	call	_get_next_edge

; 6806 :                      if ( !valid_id(next_edge) && n == ord )

	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	add	esp, 4
	and	ecx, 1
	jne	SHORT $LN184@get_indexe
	cmp	DWORD PTR _n$[ebp], ebx
	je	$LN152@get_indexe
$LN184@get_indexe:

; 6809 :                        break;
; 6810 :                      } 
; 6811 :                      id = next_edge;

	mov	edi, eax

; 6812 :                      if ( !valid_id(id) || equal_id(id,first) )

	test	ecx, ecx
	je	SHORT $LN35@get_indexe
	cmp	eax, DWORD PTR _first$[ebp]
	jne	$LN39@get_indexe
$LN35@get_indexe:

; 6813 :                      { sprintf(errmsg,
; 6814 :                     "Vertex index, %d, exceeds number of vertices on facet %s.\n",
; 6815 :                           ord+1,ELNAME(parent));

	test	DWORD PTR _parent$[ebp], 268435456	; 10000000H
	je	SHORT $LN131@get_indexe
	mov	ecx, DWORD PTR _parent$[ebp]
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN132@get_indexe
$LN131@get_indexe:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN132@get_indexe:
	push	eax
	lea	edx, DWORD PTR [ebx+1]
	push	edx
	push	OFFSET ??_C@_0DL@GPAGLJBP@Vertex?5index?0?5?$CFd?0?5exceeds?5number@
	push	OFFSET _errmsg
	call	_sprintf

; 6816 :                       sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6817 :                           file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL179@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL179@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6818 :                        kb_error(1284,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1284					; 00000504H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN39@get_indexe:

; 6803 :                  }
; 6804 :                  for ( n = 1 ; n <= ord ; n++ )

	mov	eax, DWORD PTR _n$[ebp]
	inc	eax
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, ebx
	jle	$LL40@get_indexe

; 6889 :                 if ( equal_id(id,first) )

	jmp	SHORT $LN38@get_indexe
$LN152@get_indexe:

; 6807 :                      { next_id = get_fe_headv(id);

	push	edi
	call	_get_fe_edge
	push	eax
	call	_get_edge_headv
	add	esp, 8
	mov	DWORD PTR _next_id$[ebp], eax

; 6808 :                        id = NULLID;

	xor	edi, edi
$LN38@get_indexe:

; 6819 :                      }
; 6820 :                    }
; 6821 :                  if ( valid_id(id) ) 

	test	edi, 268435456				; 10000000H
	je	$LN3@get_indexe

; 6822 :                     next_id = get_fe_tailv(id);

	push	edi
	call	_get_fe_edge
	push	eax
	call	_get_edge_tailv
	add	esp, 8
	pop	edi
	pop	esi

; 6910 :              { case EDGE: next_id = get_fe_edge(parent); break;

	mov	DWORD PTR _next_id$[ebp], eax
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN58@get_indexe:

; 6753 :                  { if ( ord >= web.skel[FACET].ctrlpts )

	cmp	ebx, DWORD PTR _web+232
	jl	$LN57@get_indexe

; 6754 :                    { sprintf(errmsg,
; 6755 :                   "Vertex index, %d, exceeds number of vertices on facet %s.\n",
; 6756 :                         ord+1,ELNAME(parent));

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN127@get_indexe
	mov	ecx, DWORD PTR _parent$[ebp]
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN128@get_indexe
$LN127@get_indexe:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN128@get_indexe:
	push	eax
	lea	edx, DWORD PTR [ebx+1]
	push	edx
	push	OFFSET ??_C@_0DL@GPAGLJBP@Vertex?5index?0?5?$CFd?0?5exceeds?5number@
	push	OFFSET _errmsg
	call	_sprintf

; 6757 :                     sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6758 :                           file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL180@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL180@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6759 :                      kb_error(3503,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3503					; 00000dafH
	call	_kb_error
	mov	ecx, DWORD PTR _parent$[ebp]
	add	esp, 28					; 0000001cH
$LN57@get_indexe:

; 6760 :                    }
; 6761 :                    next_id = get_facet_vertices(parent)[ord];

	mov	edx, DWORD PTR _web+236
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+304]
	pop	edi
	mov	eax, DWORD PTR [eax+ebx*4]
	pop	esi

; 6910 :              { case EDGE: next_id = get_fe_edge(parent); break;

	mov	DWORD PTR _next_id$[ebp], eax
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@get_indexe:

; 6877 :                  }
; 6878 :                  break;
; 6879 :              } 
; 6880 :              break;
; 6881 :          case BODY:
; 6882 :              switch ( node->op1.eltype /* subtype */ )

	mov	eax, DWORD PTR [esi+32]
	sub	eax, 2
	jne	$LN3@get_indexe

; 6883 :              { case FACET:
; 6884 : 
; 6885 :              id = first = get_body_facet(parent);

	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_get_body_facet

; 6886 :              for ( n = 1 ; n <= ord ; n++ )

	mov	edi, 1
	add	esp, 4
	mov	ebx, eax
	mov	DWORD PTR _id$[ebp], ebx
	cmp	DWORD PTR _ord$[ebp], edi
	jl	SHORT $LN8@get_indexe
	npad	3
$LL10@get_indexe:

; 6887 :               {
; 6888 :                 id = get_next_body_facet(id);

	mov	edx, DWORD PTR _id$[ebp]
	push	edx
	call	_get_next_body_facet
	add	esp, 4
	mov	DWORD PTR _id$[ebp], eax

; 6889 :                 if ( equal_id(id,first) )

	cmp	eax, ebx
	je	SHORT $LN153@get_indexe

; 6886 :              for ( n = 1 ; n <= ord ; n++ )

	inc	edi
	cmp	edi, DWORD PTR _ord$[ebp]
	jle	SHORT $LL10@get_indexe

; 6889 :                 if ( equal_id(id,first) )

	jmp	SHORT $LN8@get_indexe
$LN153@get_indexe:

; 6890 :                 { id = NULLID; 

	mov	DWORD PTR _id$[ebp], 0
$LN8@get_indexe:

; 6891 :                   break;
; 6892 :                 }
; 6893 :                }
; 6894 :                if ( !valid_id(id) )

	mov	eax, 268435456				; 10000000H
	test	DWORD PTR _id$[ebp], eax
	jne	$LN6@get_indexe

; 6895 :                 { sprintf(errmsg,
; 6896 :                    "Facet index, %d, exceeds number of facets on body %s.\n",
; 6897 :                          ord+1, ELNAME(parent));

	test	DWORD PTR _parent$[ebp], eax
	je	SHORT $LN135@get_indexe
	mov	eax, DWORD PTR _parent$[ebp]
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN136@get_indexe
$LN135@get_indexe:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN136@get_indexe:
	push	eax
	mov	eax, DWORD PTR _ord$[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_0DH@JKBABGKM@Facet?5index?0?5?$CFd?0?5exceeds?5number?5@
	push	OFFSET _errmsg
	call	_sprintf

; 6898 :                   sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6899 :                      file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL181@get_indexe:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL181@get_indexe
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 6900 :                         kb_error(1288,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1288					; 00000508H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN6@get_indexe:

; 6901 :                 }
; 6902 :               
; 6903 :              next_id = id;

	mov	ecx, DWORD PTR _id$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR _next_id$[ebp], ecx

; 6912 :              }
; 6913 :              break;
; 6914 :           }
; 6915 : 
; 6916 :           return next_id;

	mov	eax, ecx
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@get_indexe:

; 6904 :             break;
; 6905 :            }
; 6906 :            break;
; 6907 : 
; 6908 :          case FACETEDGE:
; 6909 :              switch ( node->op1.eltype /* subtype */ )

	mov	esi, DWORD PTR [esi+32]
	dec	esi
	je	SHORT $LN2@get_indexe
	dec	esi
	jne	SHORT $LN3@get_indexe

; 6911 :                case FACET: next_id = get_fe_facet(parent); break;

	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_get_fe_facet
	add	esp, 4
	pop	edi
	pop	esi
	mov	DWORD PTR _next_id$[ebp], eax
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@get_indexe:

; 6910 :              { case EDGE: next_id = get_fe_edge(parent); break;

	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_get_fe_edge
	add	esp, 4
	mov	DWORD PTR _next_id$[ebp], eax
$LN3@get_indexe:

; 6912 :              }
; 6913 :              break;
; 6914 :           }
; 6915 : 
; 6916 :           return next_id;

	mov	eax, DWORD PTR _next_id$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 6917 : 
; 6918 :        } // end get_indexed_subtype()

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN189@get_indexe:
	DD	$LN103@get_indexe
	DD	$LN87@get_indexe
	DD	$LN63@get_indexe
	DD	$LN14@get_indexe
	DD	$LN5@get_indexe
_get_indexed_subtype ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@KHJAAIFB@Internal?5error?3?5Stack?5misalignme@ ; `string'
PUBLIC	??_C@_0BM@GBPBJJDP@Evaluation?5stack?5overflow?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@EFKCGIKP@BAD?5EVAL?5STACK?6?$AA@	; `string'
PUBLIC	??_C@_0CI@OEJLGIBG@Command?5aborted?5due?5to?5user?5inte@ ; `string'
PUBLIC	??_C@_0CN@MKCBCDPJ@Command?5aborted?5due?5to?5break_aft@ ; `string'
PUBLIC	??_C@_0BL@DGMPENFC@Variable?5?$CFs?5is?5read?9only?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DO@MAANDGDB@Index?5?$CFd?5of?5left?5side?5is?5?$CFd?0?5ind@ ; `string'
PUBLIC	??_C@_0CM@JKKPHDDL@Mismatched?5sizes?5in?5matrix?5multi@ ; `string'
PUBLIC	??_C@_0DN@OGAILEKP@Index?5?$CFd?5of?5left?5side?5is?5?$CFd?0?5ind@ ; `string'
PUBLIC	??_C@_0CO@PIJDLECB@Mismatched?5sizes?5in?5matrix?5multi@ ; `string'
PUBLIC	??_C@_0DG@JLMOMNLE@Mismatched?5sizes?5in?5matrix?5multi@ ; `string'
PUBLIC	??_C@_0DF@LLDCAMHI@Mismatched?5sizes?5in?5matrix?5multi@ ; `string'
PUBLIC	??_C@_0BP@DNKGECGN@Dividing?5array?5by?5zero?5in?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CO@EJMBOHDJ@Array?5addition?3?5Arrays?5have?5diff@ ; `string'
PUBLIC	??_C@_0EE@BENIIKAP@Invalid?5string?5assignment?5operat@ ; `string'
PUBLIC	__real@7e0bbe3ac8d3bd70
PUBLIC	??_C@_0DC@MJPKIDCD@constraint_normal?3?5Constraint?5?$CFd@ ; `string'
PUBLIC	??_C@_0BC@DICJIAOM@Command?5aborted?4?6?$AA@	; `string'
PUBLIC	??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@	; `string'
PUBLIC	??_C@_0DI@KHNAHFIG@Array?5index?5?$CFd?5of?5array?5?$CFs?5is?5?$CFd@ ; `string'
PUBLIC	??_C@_0DH@DOJNKOOH@Array?5index?5?$CFd?5of?5array?5?$CFs?5is?5?$CFd@ ; `string'
PUBLIC	??_C@_0DD@IDPGEBFJ@Internal?5error?$DL?5SET?5node?5?$CFd?5reac@ ; `string'
PUBLIC	??_C@_0CI@EMPMINAB@Parameter?5number?5is?5?$CFd?$DL?5maximum?5@ ; `string'
PUBLIC	??_C@_0DN@PDLOKPJK@Cannot?5set?5?$CFs?5?$CFs?5on?5a?5constraint@ ; `string'
PUBLIC	??_C@_0CA@KOHHCGIN@Illegal?5constraint?5number?3?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DA@ILOKBJND@Must?5unset?5body?5target?5before?5fi@ ; `string'
PUBLIC	??_C@_0DA@GLPHHFLM@Must?5unset?5body?5pressure?5before?5@ ; `string'
PUBLIC	??_C@_0CE@MDJIMOLA@Trying?5to?5unset?5body?5of?5non?9face@ ; `string'
PUBLIC	??_C@_0CA@CHBGMBCP@Bad?5element?5type?5for?5boundary?4?6?$AA@ ; `string'
PUBLIC	??_C@_0EK@PDNAEKOB@Cannot?5put?5?$CFs?5?$CFs?5on?5boundary?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0BL@HEGGOIJJ@Boundary?5?$CFd?5is?5not?5valid?4?6?$AA@ ; `string'
PUBLIC	??_C@_0EF@DIFGONKI@Cannot?5put?5?$CFs?5?$CFs?5on?5a?5boundary?5s@ ; `string'
PUBLIC	??_C@_0CC@GMFFIBPI@Bad?5element?5type?5for?5constraint?4@ ; `string'
PUBLIC	??_C@_0EJ@GDFDELKD@Changing?5NONCONTENT?5not?5implemen@ ; `string'
PUBLIC	??_C@_0BB@GFLDKPMN@NaN?5?5?5?5?5?5?5?5?5?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@HMFEOHID@?5?5?5?5?5?5?5?5?5?5?$DM?$DN?50?40?5?5?5?5?5?5?5?5?5?5?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@HAEINGLM@?$CF10?45g?5?9?5?$CF10?45g?5?5?5?5?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@LIPFBHGH@No?5qualifying?5values?4?6?$AA@ ; `string'
PUBLIC	__real@7e37e43c8800759c
PUBLIC	__real@fe37e43c8800759c
PUBLIC	__real@4024000000000000
PUBLIC	__real@4034000000000000
PUBLIC	__real@4035000000000000
PUBLIC	??_C@_0CI@BOPKOLFN@Internal?5error?3?5Bad?5aggregate?5ty@ ; `string'
PUBLIC	__real@47d2ced32a16a1b1
PUBLIC	__real@c7d2ced32a16a1b1
PUBLIC	??_C@_0EI@DJBIKLIA@?1?1?5?5?5?5id?5?5?5?5?5?5?5edge?5?5?5?5facet?5?5pr@ ; `string'
PUBLIC	??_C@_0BB@BBHHCCHN@?1?1?5Id?5?5?5?5facets?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@PJOLDBBB@?1?1?5Id?5?5?5?5edges?6?$AA@	; `string'
PUBLIC	??_C@_0BF@FCNHMFEN@?1?1?5Id?5?5?5?5?5?5vertices?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@OOAKAHKL@?1?1?5Id?5?5?5?5endpoints?6?$AA@ ; `string'
PUBLIC	??_C@_0DI@OJNBJBKG@?1?1?5Id?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5X?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CI@MDNPENBI@?1?1?5Id?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5X?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0BL@MACKFC@?$CFs?5index?5?$CFd?5is?5not?5valid?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@PJIGNBKB@No?5element?5for?5SELF?5to?5refer?5to?5@ ; `string'
PUBLIC	??_C@_0CE@JPLNIPHC@Can?8t?5do?5boundary?5on?5a?5?$CFs?5?$CIin?5?$CFs@ ; `string'
PUBLIC	??_C@_0DC@LFBDKEHN@Can?5do?5hit_constraints?5only?5on?5v@ ; `string'
PUBLIC	??_C@_0CM@IPCEGKDM@Can?5only?5do?5constraint?5value?5for@ ; `string'
PUBLIC	??_C@_0DE@HOHHBAGN@Can?8t?5do?5constraints?5on?5this?5typ@ ; `string'
PUBLIC	__real@41f0000000000000
PUBLIC	??_C@_0DJ@FLIAONNC@Attribute?5?$CFs?5is?5?$CFs?5attribute?0?5no@ ; `string'
PUBLIC	??_C@_0DF@MPPJKLHD@Attribute?5?$CFs?5index?5?$CFd?5is?5?$CFd?$DL?5max@ ; `string'
PUBLIC	??_C@_0DK@LPLOMNDN@?$CCshow?$CC?5attribute?5applied?5to?5wron@ ; `string'
PUBLIC	??_C@_0DD@EKGPLGNI@Cannot?5do?5MIDV?5except?5in?5QUADRAT@ ; `string'
PUBLIC	??_C@_0CG@KOBCBKLB@Density?5of?5wrong?5type?5element?5in@ ; `string'
PUBLIC	??_C@_0CE@HKCJIFBL@Phase?5of?5wrong?5type?5element?5in?5?$CF@ ; `string'
PUBLIC	??_C@_0DI@FIBFOHNK@Instance?5name?5?8?$CFs?8?5needs?5attribu@ ; `string'
PUBLIC	??_C@_0DI@DLLIPIEC@Quantity?5name?5?8?$CFs?8?5needs?5attribu@ ; `string'
PUBLIC	??_C@_0CC@MAFBFHON@Pressure?5only?5for?5bodies?0?5in?5?$CFs?4@ ; `string'
PUBLIC	??_C@_0EE@DJGKMPPD@Invalid?5index?5?$CFd?5for?5vertexnorma@ ; `string'
PUBLIC	??_C@_02KGHIDFGE@?$HN?6?$AA@			; `string'
PUBLIC	??_C@_07CFKABON@?$CF17?415g?$AA@		; `string'
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	??_C@_01HCONENDN@?$HL?$AA@			; `string'
PUBLIC	??_C@_0CE@JGNMBEAC@Can?8t?5have?5indexed?5x?5on?5?$CFs?0?5in?5?$CF@ ; `string'
PUBLIC	??_C@_0EE@NBEFOKMP@Invalid?5index?5?$CFd?5for?5x?5in?5?$CFs?$DL?5mu@ ; `string'
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_0CH@GIHCGDLE@Log?5of?5zero?5or?5negative?5number?5i@ ; `string'
PUBLIC	??_C@_0CO@OHNNCNNA@Log?5of?5zero?5or?5negative?5number?5i@ ; `string'
PUBLIC	??_C@_0DB@MOMMLDEO@Atanh?5argument?5magnitude?5not?5les@ ; `string'
PUBLIC	??_C@_0DI@PCBKKEME@Atanh?5argument?5magnitude?5not?5les@ ; `string'
PUBLIC	__real@4000000000000000
PUBLIC	??_C@_0CD@HNAOPDML@Acosh?5argument?5less?5than?51?5in?5?$CFs@ ; `string'
PUBLIC	??_C@_0CK@LLHODBDC@Acosh?5argument?5less?5than?51?5in?5?$CFs@ ; `string'
PUBLIC	__real@3fe0000000000000
PUBLIC	??_C@_0CK@LOFDGDAB@Square?5root?5of?5negative?5number?5?$CF@ ; `string'
PUBLIC	??_C@_0DB@GKAOKNCG@Square?5root?5of?5negative?5number?5?$CF@ ; `string'
PUBLIC	__real@c059000000000000
PUBLIC	__real@46293e5939a08cea
PUBLIC	??_C@_0CP@OEGDEOLM@Non?9integer?5power?5of?5a?5negative?5@ ; `string'
PUBLIC	??_C@_0DG@JFAPMCOO@Non?9integer?5power?5of?5a?5negative?5@ ; `string'
PUBLIC	??_C@_0CE@DJIGLCFH@Negative?5power?5?$CI?$CFd?$CJ?5of?5zero?5in?5?$CF@ ; `string'
PUBLIC	??_C@_0CL@MCPCMAIK@Negative?5power?5?$CI?$CFd?$CJ?5of?5zero?5in?5?$CF@ ; `string'
PUBLIC	??_C@_0BK@EOENHDHL@Modulus?5base?5zero?5in?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@HIHGBPJM@Modulus?5base?5zero?5in?5?$CFs?0?5?$CFs?5?$CFs?4?6@ ; `string'
PUBLIC	??_C@_0BJ@DKCGOBDB@Division?5by?5zero?5in?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@MCBMPDHE@Division?5by?5zero?5in?5?$CFs?0?5?$CFs?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DP@CDGHBNOO@Must?5use?5dynamic?5load?5function?5?$CF@ ; `string'
PUBLIC	__real@4005bf0a8b145769
PUBLIC	__real@400921fb54442d18
PUBLIC	??_C@_0DE@HGELOKGG@Internal?5error?3?5Internal?5variabl@ ; `string'
PUBLIC	??_C@_0DF@KGAJMGKH@Really?5strange?5configuration?5aro@ ; `string'
PUBLIC	??_C@_0CA@CLIEDLCM@Bad?5delete?5element?5type?5in?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@FBECANMH@Only?5vertices?5and?5edges?5poppable@ ; `string'
PUBLIC	??_C@_0CA@NGOPNEKB@Bad?5refine?5element?5type?5in?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@BGHMKKAN@Bad?5LIST?5element?5type?5in?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@LGOPNDFF@Internal?5error?3?5no?5FINISH?5node?5a@ ; `string'
PUBLIC	??_C@_0BH@FDCGEHJN@redefined?5command?5?8?$CFc?8?$AA@ ; `string'
PUBLIC	??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@		; `string'
PUBLIC	??_C@_0BI@CLILKIPO@show?5expression?5for?5?$CFs?4?$AA@ ; `string'
PUBLIC	??_C@_0DG@HCIHCCDE@Procedure?5?$CC?$CFs?$CC?5definition?5has?5no@ ; `string'
PUBLIC	??_C@_0DF@HMCCGFBA@Function?5?$CC?$CFs?$CC?5definition?5has?5not@ ; `string'
PUBLIC	??_C@_0BA@LDMPFPFF@Enter?5command?3?5?$AA@	; `string'
PUBLIC	??_C@_0CM@NLOJJBMG@Calling?5permload?5in?5non?9permanen@ ; `string'
PUBLIC	__real@3abef2d0f5da7dd9
PUBLIC	??_C@_0BK@OMAPGNOH@Cannot?5open?5datafile?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@KDKEJCJM@Can?8t?5reload?5in?5a?5subcommand?4?6?$AA@ ; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_0DC@KLMKCJCH@Changing?5to?5LAGRANGE?5?$CFd?5model?4?5?$CI@ ; `string'
PUBLIC	??_C@_0CN@NAGKEEOG@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@ ; `string'
PUBLIC	??_C@_0CK@JBOLHCFI@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@ ; `string'
PUBLIC	??_C@_0CN@BFEEPGEG@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@ ; `string'
PUBLIC	??_C@_0CL@IKOBFHOD@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@ ; `string'
PUBLIC	??_C@_0CK@JMIEKNGL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5L@ ; `string'
PUBLIC	??_C@_0CL@FEBBPANL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5Q@ ; `string'
PUBLIC	??_C@_0DE@ODNKLDLP@free_discards?5called?5inside?5elem@ ; `string'
PUBLIC	??_C@_06FAPHFCKA@?5?5?5?$CFs?6?$AA@		; `string'
PUBLIC	??_C@_09PBNAGJKF@?5?5?5?$CFs?3?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0BA@FJFLMGGP@File?5?$CFs?0?5?$CFs?3?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@JMDJOALI@Cannot?5find?5instruction?5on?5line?5@ ; `string'
PUBLIC	??_C@_0BB@MMHOCNOI@Subcommand?$CI?$CFd?$CJ?3?5?$AA@ ; `string'
PUBLIC	??_C@_0N@FIJGDPF@Subcommand?3?5?$AA@		; `string'
PUBLIC	__real@41684bfe477e06cc
PUBLIC	??_C@_0BE@EMCFOMCB@Debug?5command?$CI?$CFd?$CJ?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BH@MOAJHJDH@Debug?5?$CI?$CC?$CFs?$CC?5line?5?$CFd?$CJ?3?5?$AA@ ; `string'
PUBLIC	??_C@_0CK@NIDPEGMM@Internal?5error?5in?5eval?$CI?$CJ?3?5no?5fra@ ; `string'
PUBLIC	??_C@_0CM@CBLOAPAC@Trying?5to?5evaluate?5null?5expressi@ ; `string'
PUBLIC	_self_id$GSCopy$
PUBLIC	_params$GSCopy$
PUBLIC	_ex_original$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_eval
EXTRN	_longjmp:PROC
EXTRN	_loadjumpbuf:BYTE
EXTRN	_exit_flag:DWORD
EXTRN	_other_stuff:PROC
EXTRN	_free:PROC
EXTRN	_myfree:PROC
EXTRN	_KB_realloc:PROC
EXTRN	_get_name_name:PROC
EXTRN	_eval_all:PROC
EXTRN	_main_thread_id:DWORD
EXTRN	_threadflag:DWORD
EXTRN	_hessian_iterate_flag:DWORD
EXTRN	_dont_resize_flag:DWORD
EXTRN	_kb_temp_realloc:PROC
EXTRN	_unapply_quantity:PROC
EXTRN	_apply_quantity:PROC
EXTRN	_project_v_constr:PROC
EXTRN	_set_v_constraint_map:PROC
EXTRN	_set_e_constraint_map:PROC
EXTRN	_set_f_constraint_map:PROC
EXTRN	_facet_alpha:QWORD
EXTRN	_set_body_fixvol:PROC
EXTRN	_set_body:PROC
EXTRN	_set_facet_body:PROC
EXTRN	_unapply_method:PROC
EXTRN	_fixup_edge_content_meths:PROC
EXTRN	_fixup_vertex_content_meths:PROC
EXTRN	_apply_method_num:PROC
EXTRN	_unset_v_constraint_map:PROC
EXTRN	_unset_e_constraint_map:PROC
EXTRN	_unset_f_constraint_map:PROC
EXTRN	_some_no_transforms_flag:DWORD
EXTRN	_everything_quantities_flag:DWORD
EXTRN	_mpi_subtask_command_flag:DWORD
EXTRN	_temp_free:PROC
EXTRN	_kb_temp_calloc:PROC
EXTRN	_aggregate_depth:DWORD
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	_E_BOUNDARY_ATTR:DWORD
EXTRN	_F_BOUNDARY_ATTR:DWORD
EXTRN	_get_v_constraint_status:PROC
EXTRN	_v_on_constraint:PROC
EXTRN	_e_on_constraint:PROC
EXTRN	_f_on_constraint:PROC
EXTRN	_autorecalc_flag:DWORD
EXTRN	_interp_facet_attribute:PROC
EXTRN	_interp_edge_attribute:PROC
EXTRN	_no_wall_flag:DWORD
EXTRN	_bdry_showflag:DWORD
EXTRN	_opacity_attr:DWORD
EXTRN	_calc_content:PROC
EXTRN	_info_volume_timestamp:DWORD
EXTRN	_global_timestamp:DWORD
EXTRN	_fixed_volume_timestamp:DWORD
EXTRN	_F_PHASE_ATTR:DWORD
EXTRN	_B_PHASE_ATTR:DWORD
EXTRN	_instance_attribute:PROC
EXTRN	_meth_inst_list:DWORD
EXTRN	_quantity_attribute:PROC
EXTRN	_gen_quant_list:DWORD
EXTRN	_recalc_facet_area:PROC
EXTRN	_get_body_valence:PROC
EXTRN	_get_facet_valence:PROC
EXTRN	_get_edge_valence:PROC
EXTRN	_get_vertex_evalence:PROC
EXTRN	_get_vertex_fvalence:PROC
EXTRN	_vertex_angle:PROC
EXTRN	_dihedral:PROC
EXTRN	_get_edge_length:PROC
EXTRN	_calc_edge:PROC
EXTRN	_vertex_mean_curvature:PROC
EXTRN	_vertex_sq_mean_curvature:PROC
EXTRN	_dot:PROC
EXTRN	_new_calc_vertex_normal:PROC
EXTRN	_mat2d_setup:PROC
EXTRN	_get_edge_side:PROC
EXTRN	_get_facet_normal:PROC
EXTRN	_incompleteEllipticE:PROC
EXTRN	_incompleteEllipticF:PROC
EXTRN	_ellipticE:PROC
EXTRN	_ellipticK:PROC
EXTRN	_ceil:PROC
EXTRN	_machine_eps:QWORD
EXTRN	_sym_compose:DWORD
EXTRN	_userfunc:BYTE
EXTRN	_int_val:DWORD
EXTRN	_optparam:BYTE
EXTRN	_optparamcount:DWORD
EXTRN	_free_element:PROC
EXTRN	_delete_edge:PROC
EXTRN	_delete_facet:PROC
EXTRN	_new_vertex_average:PROC
EXTRN	_reverse_orientation_edge:PROC
EXTRN	_reverse_orientation_facet:PROC
EXTRN	_dissolve_body:PROC
EXTRN	_dissolve_facet:PROC
EXTRN	_dissolve_edge:PROC
EXTRN	_dissolve_vertex:PROC
EXTRN	_equiangulate_edge:PROC
EXTRN	_t1_edgeswap:PROC
EXTRN	_edgeswap:PROC
EXTRN	_pop_quad_to_quad:PROC
EXTRN	_pop_edge_to_tri:PROC
EXTRN	_pop_tri_to_edge:PROC
EXTRN	_pop_given_vertex:PROC
EXTRN	_pop_one_edge:PROC
EXTRN	_edge_refine:PROC
EXTRN	_face_triangulate:PROC
EXTRN	_facetedge_dump:PROC
EXTRN	_body_dump:PROC
EXTRN	_facet_dump:PROC
EXTRN	_edge_dump:PROC
EXTRN	_vertex_dump:PROC
EXTRN	_outfd:DWORD
EXTRN	_quiet_flag:DWORD
EXTRN	_fgetc:PROC
EXTRN	_l_brfd:DWORD
EXTRN	_cProgramBreakDelay:DWORD
EXTRN	_ProgramBreakDelay:DWORD
EXTRN	_l_evolver_mode:DWORD
EXTRN	_gocount:DWORD
EXTRN	_locals_copy_perm:PROC
EXTRN	_perm_free_expr:PROC
EXTRN	_proc_timestamp:DWORD
EXTRN	_locals_copy:PROC
EXTRN	_free_expr:PROC
EXTRN	_update_display:PROC
EXTRN	_do_show:PROC
EXTRN	_go_display_flag:DWORD
EXTRN	_OOGL_flag:DWORD
EXTRN	_show_command:BYTE
EXTRN	_kb_calloc:PROC
EXTRN	_typenames:BYTE
EXTRN	_tree_copy:PROC
EXTRN	_show_expr:BYTE
EXTRN	_show_expr_table:BYTE
EXTRN	_matrix_determinant_command:PROC
EXTRN	_matrix_multiply_command:PROC
EXTRN	_matrix_inverse_command:PROC
EXTRN	_get_name_arrayptr:PROC
EXTRN	_single_redefine:BYTE
EXTRN	_commandfd:DWORD
EXTRN	_startup:PROC
EXTRN	_strncpy:PROC
EXTRN	_loadfilename:BYTE
EXTRN	_perm_tree_copy:PROC
EXTRN	_replace_load_flag:DWORD
EXTRN	_free_element_lists:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	_resize:PROC
EXTRN	_view:DWORD
EXTRN	_pop_commandfd:PROC
EXTRN	_initialize:PROC
EXTRN	_cmdptr:DWORD
EXTRN	_datafile_input_flag:DWORD
EXTRN	_addload_flag:DWORD
EXTRN	_datafile_flag:DWORD
EXTRN	_read_depth:DWORD
EXTRN	_push_commandfd:PROC
EXTRN	__imp__MsgWaitForMultipleObjects@20:PROC
EXTRN	_graphmutex:DWORD
EXTRN	_locking_thread:DWORD
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	_path_open:PROC
EXTRN	_get_full_id:PROC
EXTRN	_lagrange_to_lagrange:PROC
EXTRN	_quad_to_lagrange:PROC
EXTRN	_linear_to_lagrange:PROC
EXTRN	_lagrange_to_quad:PROC
EXTRN	_linear_to_quad:PROC
EXTRN	_lagrange_to_linear:PROC
EXTRN	_quad_to_linear:PROC
EXTRN	_letter_command:PROC
EXTRN	_free_discards:PROC
EXTRN	_recalc:PROC
EXTRN	_detorus:PROC
EXTRN	_eval_stack_trace:BYTE
EXTRN	_eval_stack_trace_spot:DWORD
EXTRN	_realloc:PROC
EXTRN	_exec_commands:PROC
EXTRN	_jumpbuf:BYTE
EXTRN	_subshell_depth:DWORD
EXTRN	_single_step_debugging:DWORD
EXTRN	_breakflag:DWORD
EXTRN	_l_evolver_break:DWORD
EXTRN	_iterate_flag:DWORD
EXTRN	_win_get_thread_data:PROC
EXTRN	_thread_data_key:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__CIatan:PROC
EXTRN	__CIacos:PROC
EXTRN	__CIasin:PROC
EXTRN	__CIlog:PROC
EXTRN	__CIexp:PROC
EXTRN	__CItan:PROC
EXTRN	__CIcos:PROC
EXTRN	__CIsin:PROC
EXTRN	__CIsqrt:PROC
EXTRN	__CIatan2:PROC
EXTRN	__CIpow:PROC
EXTRN	_floor:PROC
EXTRN	_memcpy:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_memset:PROC
EXTRN	__setjmp3:PROC
;	COMDAT ??_C@_0DE@KHJAAIFB@Internal?5error?3?5Stack?5misalignme@
CONST	SEGMENT
??_C@_0DE@KHJAAIFB@Internal?5error?3?5Stack?5misalignme@ DB 'Internal err'
	DB	'or: Stack misalignment by %d in eval()', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GBPBJJDP@Evaluation?5stack?5overflow?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@GBPBJJDP@Evaluation?5stack?5overflow?4?6?$AA@ DB 'Evaluation st'
	DB	'ack overflow.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EFKCGIKP@BAD?5EVAL?5STACK?6?$AA@
CONST	SEGMENT
??_C@_0BA@EFKCGIKP@BAD?5EVAL?5STACK?6?$AA@ DB 'BAD EVAL STACK', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OEJLGIBG@Command?5aborted?5due?5to?5user?5inte@
CONST	SEGMENT
??_C@_0CI@OEJLGIBG@Command?5aborted?5due?5to?5user?5inte@ DB 'Command abo'
	DB	'rted due to user interrupt.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MKCBCDPJ@Command?5aborted?5due?5to?5break_aft@
CONST	SEGMENT
??_C@_0CN@MKCBCDPJ@Command?5aborted?5due?5to?5break_aft@ DB 'Command abor'
	DB	'ted due to break_after_warning.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DGMPENFC@Variable?5?$CFs?5is?5read?9only?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@DGMPENFC@Variable?5?$CFs?5is?5read?9only?4?6?$AA@ DB 'Variable '
	DB	'%s is read-only.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@MAANDGDB@Index?5?$CFd?5of?5left?5side?5is?5?$CFd?0?5ind@
CONST	SEGMENT
??_C@_0DO@MAANDGDB@Index?5?$CFd?5of?5left?5side?5is?5?$CFd?0?5ind@ DB 'In'
	DB	'dex %d of left side is %d, index %d of second factor is %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@JKKPHDDL@Mismatched?5sizes?5in?5matrix?5multi@
CONST	SEGMENT
??_C@_0CM@JKKPHDDL@Mismatched?5sizes?5in?5matrix?5multi@ DB 'Mismatched s'
	DB	'izes in matrix multiplication.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@OGAILEKP@Index?5?$CFd?5of?5left?5side?5is?5?$CFd?0?5ind@
CONST	SEGMENT
??_C@_0DN@OGAILEKP@Index?5?$CFd?5of?5left?5side?5is?5?$CFd?0?5ind@ DB 'In'
	DB	'dex %d of left side is %d, index %d of first factor is %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PIJDLECB@Mismatched?5sizes?5in?5matrix?5multi@
CONST	SEGMENT
??_C@_0CO@PIJDLECB@Mismatched?5sizes?5in?5matrix?5multi@ DB 'Mismatched s'
	DB	'izes in matrix multiplication.  ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JLMOMNLE@Mismatched?5sizes?5in?5matrix?5multi@
CONST	SEGMENT
??_C@_0DG@JLMOMNLE@Mismatched?5sizes?5in?5matrix?5multi@ DB 'Mismatched s'
	DB	'izes in matrix multiplication, %d vs %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LLDCAMHI@Mismatched?5sizes?5in?5matrix?5multi@
CONST	SEGMENT
??_C@_0DF@LLDCAMHI@Mismatched?5sizes?5in?5matrix?5multi@ DB 'Mismatched s'
	DB	'izes in matrix multiplication, %d vs %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DNKGECGN@Dividing?5array?5by?5zero?5in?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@DNKGECGN@Dividing?5array?5by?5zero?5in?5?$CFs?4?6?$AA@ DB 'Divi'
	DB	'ding array by zero in %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@EJMBOHDJ@Array?5addition?3?5Arrays?5have?5diff@
CONST	SEGMENT
??_C@_0CO@EJMBOHDJ@Array?5addition?3?5Arrays?5have?5diff@ DB 'Array addit'
	DB	'ion: Arrays have different sizes.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@BENIIKAP@Invalid?5string?5assignment?5operat@
CONST	SEGMENT
??_C@_0EE@BENIIKAP@Invalid?5string?5assignment?5operat@ DB 'Invalid strin'
	DB	'g assignment operator; only plain assignment allowed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@7e0bbe3ac8d3bd70
CONST	SEGMENT
__real@7e0bbe3ac8d3bd70 DQ 07e0bbe3ac8d3bd70r	; 1.45151e+299
CONST	ENDS
;	COMDAT ??_C@_0DC@MJPKIDCD@constraint_normal?3?5Constraint?5?$CFd@
CONST	SEGMENT
??_C@_0DC@MJPKIDCD@constraint_normal?3?5Constraint?5?$CFd@ DB 'constraint'
	DB	'_normal: Constraint %d does not exist.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DICJIAOM@Command?5aborted?4?6?$AA@
CONST	SEGMENT
??_C@_0BC@DICJIAOM@Command?5aborted?4?6?$AA@ DB 'Command aborted.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@
CONST	SEGMENT
??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@ DB 'Division by zero.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@KHNAHFIG@Array?5index?5?$CFd?5of?5array?5?$CFs?5is?5?$CFd@
CONST	SEGMENT
??_C@_0DI@KHNAHFIG@Array?5index?5?$CFd?5of?5array?5?$CFs?5is?5?$CFd@ DB 'A'
	DB	'rray index %d of array %s is %d; exceeds bound of %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@DOJNKOOH@Array?5index?5?$CFd?5of?5array?5?$CFs?5is?5?$CFd@
CONST	SEGMENT
??_C@_0DH@DOJNKOOH@Array?5index?5?$CFd?5of?5array?5?$CFs?5is?5?$CFd@ DB 'A'
	DB	'rray index %d of array %s is %d. Indexes start at 1.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IDPGEBFJ@Internal?5error?$DL?5SET?5node?5?$CFd?5reac@
CONST	SEGMENT
??_C@_0DD@IDPGEBFJ@Internal?5error?$DL?5SET?5node?5?$CFd?5reac@ DB 'Inter'
	DB	'nal error; SET node %d reached unexpectedly.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EMPMINAB@Parameter?5number?5is?5?$CFd?$DL?5maximum?5@
CONST	SEGMENT
??_C@_0CI@EMPMINAB@Parameter?5number?5is?5?$CFd?$DL?5maximum?5@ DB 'Param'
	DB	'eter number is %d; maximum is %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@PDLOKPJK@Cannot?5set?5?$CFs?5?$CFs?5on?5a?5constraint@
CONST	SEGMENT
??_C@_0DN@PDLOKPJK@Cannot?5set?5?$CFs?5?$CFs?5on?5a?5constraint@ DB 'Cann'
	DB	'ot set %s %s on a constraint since it is on a boundary.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KOHHCGIN@Illegal?5constraint?5number?3?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@KOHHCGIN@Illegal?5constraint?5number?3?5?$CFd?4?6?$AA@ DB 'Ille'
	DB	'gal constraint number: %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@ILOKBJND@Must?5unset?5body?5target?5before?5fi@
CONST	SEGMENT
??_C@_0DA@ILOKBJND@Must?5unset?5body?5target?5before?5fi@ DB 'Must unset '
	DB	'body target before fixing pressure.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@GLPHHFLM@Must?5unset?5body?5pressure?5before?5@
CONST	SEGMENT
??_C@_0DA@GLPHHFLM@Must?5unset?5body?5pressure?5before?5@ DB 'Must unset '
	DB	'body pressure before fixing target.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MDJIMOLA@Trying?5to?5unset?5body?5of?5non?9face@
CONST	SEGMENT
??_C@_0CE@MDJIMOLA@Trying?5to?5unset?5body?5of?5non?9face@ DB 'Trying to '
	DB	'unset body of non-facet.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CHBGMBCP@Bad?5element?5type?5for?5boundary?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@CHBGMBCP@Bad?5element?5type?5for?5boundary?4?6?$AA@ DB 'Bad ele'
	DB	'ment type for boundary.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@PDNAEKOB@Cannot?5put?5?$CFs?5?$CFs?5on?5boundary?5?$CFd?5@
CONST	SEGMENT
??_C@_0EK@PDNAEKOB@Cannot?5put?5?$CFs?5?$CFs?5on?5boundary?5?$CFd?5@ DB 'C'
	DB	'annot put %s %s on boundary %d since it is already on another'
	DB	' boundary.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HEGGOIJJ@Boundary?5?$CFd?5is?5not?5valid?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@HEGGOIJJ@Boundary?5?$CFd?5is?5not?5valid?4?6?$AA@ DB 'Boundary '
	DB	'%d is not valid.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@DIFGONKI@Cannot?5put?5?$CFs?5?$CFs?5on?5a?5boundary?5s@
CONST	SEGMENT
??_C@_0EF@DIFGONKI@Cannot?5put?5?$CFs?5?$CFs?5on?5a?5boundary?5s@ DB 'Can'
	DB	'not put %s %s on a boundary since it is already on a constrai'
	DB	'nt.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GMFFIBPI@Bad?5element?5type?5for?5constraint?4@
CONST	SEGMENT
??_C@_0CC@GMFFIBPI@Bad?5element?5type?5for?5constraint?4@ DB 'Bad element'
	DB	' type for constraint.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@GDFDELKD@Changing?5NONCONTENT?5not?5implemen@
CONST	SEGMENT
??_C@_0EJ@GDFDELKD@Changing?5NONCONTENT?5not?5implemen@ DB 'Changing NONC'
	DB	'ONTENT not implemented for everything_quantities mode yet.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GFLDKPMN@NaN?5?5?5?5?5?5?5?5?5?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BB@GFLDKPMN@NaN?5?5?5?5?5?5?5?5?5?5?$CFd?6?$AA@ DB 'NaN          %'
	DB	'd', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HMFEOHID@?5?5?5?5?5?5?5?5?5?5?$DM?$DN?50?40?5?5?5?5?5?5?5?5?5?5?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BP@HMFEOHID@?5?5?5?5?5?5?5?5?5?5?$DM?$DN?50?40?5?5?5?5?5?5?5?5?5?5?5?$CFd?6?$AA@ DB ' '
	DB	'         <= 0.0           %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HAEINGLM@?$CF10?45g?5?9?5?$CF10?45g?5?5?5?5?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BI@HAEINGLM@?$CF10?45g?5?9?5?$CF10?45g?5?5?5?5?5?$CFd?6?$AA@ DB '%'
	DB	'10.5g - %10.5g     %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIPFBHGH@No?5qualifying?5values?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@LIPFBHGH@No?5qualifying?5values?4?6?$AA@ DB 'No qualifying valu'
	DB	'es.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@7e37e43c8800759c
CONST	SEGMENT
__real@7e37e43c8800759c DQ 07e37e43c8800759cr	; 1e+300
CONST	ENDS
;	COMDAT __real@fe37e43c8800759c
CONST	SEGMENT
__real@fe37e43c8800759c DQ 0fe37e43c8800759cr	; -1e+300
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@4034000000000000
CONST	SEGMENT
__real@4034000000000000 DQ 04034000000000000r	; 20
CONST	ENDS
;	COMDAT __real@4035000000000000
CONST	SEGMENT
__real@4035000000000000 DQ 04035000000000000r	; 21
CONST	ENDS
;	COMDAT ??_C@_0CI@BOPKOLFN@Internal?5error?3?5Bad?5aggregate?5ty@
CONST	SEGMENT
??_C@_0CI@BOPKOLFN@Internal?5error?3?5Bad?5aggregate?5ty@ DB 'Internal er'
	DB	'ror: Bad aggregate type %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@47d2ced32a16a1b1
CONST	SEGMENT
__real@47d2ced32a16a1b1 DQ 047d2ced32a16a1b1r	; 1e+038
CONST	ENDS
;	COMDAT __real@c7d2ced32a16a1b1
CONST	SEGMENT
__real@c7d2ced32a16a1b1 DQ 0c7d2ced32a16a1b1r	; -1e+038
CONST	ENDS
;	COMDAT ??_C@_0EI@DJBIKLIA@?1?1?5?5?5?5id?5?5?5?5?5?5?5edge?5?5?5?5facet?5?5pr@
CONST	SEGMENT
??_C@_0EI@DJBIKLIA@?1?1?5?5?5?5id?5?5?5?5?5?5?5edge?5?5?5?5facet?5?5pr@ DB '/'
	DB	'/    id       edge    facet  prevedge nextedge    prevfacet n'
	DB	'extfacet', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BBHHCCHN@?1?1?5Id?5?5?5?5facets?6?$AA@
CONST	SEGMENT
??_C@_0BB@BBHHCCHN@?1?1?5Id?5?5?5?5facets?6?$AA@ DB '// Id    facets', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PJOLDBBB@?1?1?5Id?5?5?5?5edges?6?$AA@
CONST	SEGMENT
??_C@_0BA@PJOLDBBB@?1?1?5Id?5?5?5?5edges?6?$AA@ DB '// Id    edges', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FCNHMFEN@?1?1?5Id?5?5?5?5?5?5vertices?6?$AA@
CONST	SEGMENT
??_C@_0BF@FCNHMFEN@?1?1?5Id?5?5?5?5?5?5vertices?6?$AA@ DB '// Id      ver'
	DB	'tices', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OOAKAHKL@?1?1?5Id?5?5?5?5endpoints?6?$AA@
CONST	SEGMENT
??_C@_0BE@OOAKAHKL@?1?1?5Id?5?5?5?5endpoints?6?$AA@ DB '// Id    endpoint'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@OJNBJBKG@?1?1?5Id?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5X?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0DI@OJNBJBKG@?1?1?5Id?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5X?5?5?5?5?5?5?5?5?5?5?5@ DB '/'
	DB	'/ Id               X                Y               Z', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MDNPENBI@?1?1?5Id?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5X?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CI@MDNPENBI@?1?1?5Id?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5X?5?5?5?5?5?5?5?5?5?5?5@ DB '/'
	DB	'/ Id               X                Y', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MACKFC@?$CFs?5index?5?$CFd?5is?5not?5valid?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@MACKFC@?$CFs?5index?5?$CFd?5is?5not?5valid?4?6?$AA@ DB '%s inde'
	DB	'x %d is not valid.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PJIGNBKB@No?5element?5for?5SELF?5to?5refer?5to?5@
CONST	SEGMENT
??_C@_0CI@PJIGNBKB@No?5element?5for?5SELF?5to?5refer?5to?5@ DB 'No elemen'
	DB	't for SELF to refer to in %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JPLNIPHC@Can?8t?5do?5boundary?5on?5a?5?$CFs?5?$CIin?5?$CFs@
CONST	SEGMENT
??_C@_0CE@JPLNIPHC@Can?8t?5do?5boundary?5on?5a?5?$CFs?5?$CIin?5?$CFs@ DB 'C'
	DB	'an''t do boundary on a %s (in %s).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LFBDKEHN@Can?5do?5hit_constraints?5only?5on?5v@
CONST	SEGMENT
??_C@_0DC@LFBDKEHN@Can?5do?5hit_constraints?5only?5on?5v@ DB 'Can do hit_'
	DB	'constraints only on vertices (in %s).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IPCEGKDM@Can?5only?5do?5constraint?5value?5for@
CONST	SEGMENT
??_C@_0CM@IPCEGKDM@Can?5only?5do?5constraint?5value?5for@ DB 'Can only do'
	DB	' constraint value for vertices.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HOHHBAGN@Can?8t?5do?5constraints?5on?5this?5typ@
CONST	SEGMENT
??_C@_0DE@HOHHBAGN@Can?8t?5do?5constraints?5on?5this?5typ@ DB 'Can''t do '
	DB	'constraints on this type element (in %s).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
CONST	ENDS
;	COMDAT ??_C@_0DJ@FLIAONNC@Attribute?5?$CFs?5is?5?$CFs?5attribute?0?5no@
CONST	SEGMENT
??_C@_0DJ@FLIAONNC@Attribute?5?$CFs?5is?5?$CFs?5attribute?0?5no@ DB 'Attr'
	DB	'ibute %s is %s attribute, not %s attribute (in %s).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@MPPJKLHD@Attribute?5?$CFs?5index?5?$CFd?5is?5?$CFd?$DL?5max@
CONST	SEGMENT
??_C@_0DF@MPPJKLHD@Attribute?5?$CFs?5index?5?$CFd?5is?5?$CFd?$DL?5max@ DB 'A'
	DB	'ttribute %s index %d is %d; maximum is %d (in %s).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@LPLOMNDN@?$CCshow?$CC?5attribute?5applied?5to?5wron@
CONST	SEGMENT
??_C@_0DK@LPLOMNDN@?$CCshow?$CC?5attribute?5applied?5to?5wron@ DB '"show"'
	DB	' attribute applied to wrong type of element in %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EKGPLGNI@Cannot?5do?5MIDV?5except?5in?5QUADRAT@
CONST	SEGMENT
??_C@_0DD@EKGPLGNI@Cannot?5do?5MIDV?5except?5in?5QUADRAT@ DB 'Cannot do M'
	DB	'IDV except in QUADRATIC model (in %s).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KOBCBKLB@Density?5of?5wrong?5type?5element?5in@
CONST	SEGMENT
??_C@_0CG@KOBCBKLB@Density?5of?5wrong?5type?5element?5in@ DB 'Density of '
	DB	'wrong type element in %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HKCJIFBL@Phase?5of?5wrong?5type?5element?5in?5?$CF@
CONST	SEGMENT
??_C@_0CE@HKCJIFBL@Phase?5of?5wrong?5type?5element?5in?5?$CF@ DB 'Phase o'
	DB	'f wrong type element in %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@FIBFOHNK@Instance?5name?5?8?$CFs?8?5needs?5attribu@
CONST	SEGMENT
??_C@_0DI@FIBFOHNK@Instance?5name?5?8?$CFs?8?5needs?5attribu@ DB 'Instanc'
	DB	'e name ''%s'' needs attribute like .value (in %s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DLLIPIEC@Quantity?5name?5?8?$CFs?8?5needs?5attribu@
CONST	SEGMENT
??_C@_0DI@DLLIPIEC@Quantity?5name?5?8?$CFs?8?5needs?5attribu@ DB 'Quantit'
	DB	'y name ''%s'' needs attribute like .value (in %s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MAFBFHON@Pressure?5only?5for?5bodies?0?5in?5?$CFs?4@
CONST	SEGMENT
??_C@_0CC@MAFBFHON@Pressure?5only?5for?5bodies?0?5in?5?$CFs?4@ DB 'Pressu'
	DB	're only for bodies, in %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@DJGKMPPD@Invalid?5index?5?$CFd?5for?5vertexnorma@
CONST	SEGMENT
??_C@_0EE@DJGKMPPD@Invalid?5index?5?$CFd?5for?5vertexnorma@ DB 'Invalid i'
	DB	'ndex %d for vertexnormal in %s; must be between 1 and %d.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02KGHIDFGE@?$HN?6?$AA@
CONST	SEGMENT
??_C@_02KGHIDFGE@?$HN?6?$AA@ DB '}', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CFKABON@?$CF17?415g?$AA@
CONST	SEGMENT
??_C@_07CFKABON@?$CF17?415g?$AA@ DB '%17.15g', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL?$AA@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL?$AA@ DB '{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JGNMBEAC@Can?8t?5have?5indexed?5x?5on?5?$CFs?0?5in?5?$CF@
CONST	SEGMENT
??_C@_0CE@JGNMBEAC@Can?8t?5have?5indexed?5x?5on?5?$CFs?0?5in?5?$CF@ DB 'C'
	DB	'an''t have indexed x on %s, in %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@NBEFOKMP@Invalid?5index?5?$CFd?5for?5x?5in?5?$CFs?$DL?5mu@
CONST	SEGMENT
??_C@_0EE@NBEFOKMP@Invalid?5index?5?$CFd?5for?5x?5in?5?$CFs?$DL?5mu@ DB 'I'
	DB	'nvalid index %d for x in %s; must be between 1 and %d, inclus'
	DB	'ive.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_0CH@GIHCGDLE@Log?5of?5zero?5or?5negative?5number?5i@
CONST	SEGMENT
??_C@_0CH@GIHCGDLE@Log?5of?5zero?5or?5negative?5number?5i@ DB 'Log of zer'
	DB	'o or negative number in %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@OHNNCNNA@Log?5of?5zero?5or?5negative?5number?5i@
CONST	SEGMENT
??_C@_0CO@OHNNCNNA@Log?5of?5zero?5or?5negative?5number?5i@ DB 'Log of zer'
	DB	'o or negative number in %s, %s %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MOMMLDEO@Atanh?5argument?5magnitude?5not?5les@
CONST	SEGMENT
??_C@_0DB@MOMMLDEO@Atanh?5argument?5magnitude?5not?5les@ DB 'Atanh argume'
	DB	'nt magnitude not less than 1 in %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@PCBKKEME@Atanh?5argument?5magnitude?5not?5les@
CONST	SEGMENT
??_C@_0DI@PCBKKEME@Atanh?5argument?5magnitude?5not?5les@ DB 'Atanh argume'
	DB	'nt magnitude not less than 1 in %s, %s %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT ??_C@_0CD@HNAOPDML@Acosh?5argument?5less?5than?51?5in?5?$CFs@
CONST	SEGMENT
??_C@_0CD@HNAOPDML@Acosh?5argument?5less?5than?51?5in?5?$CFs@ DB 'Acosh a'
	DB	'rgument less than 1 in %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LLHODBDC@Acosh?5argument?5less?5than?51?5in?5?$CFs@
CONST	SEGMENT
??_C@_0CK@LLHODBDC@Acosh?5argument?5less?5than?51?5in?5?$CFs@ DB 'Acosh a'
	DB	'rgument less than 1 in %s, %s %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT ??_C@_0CK@LOFDGDAB@Square?5root?5of?5negative?5number?5?$CF@
CONST	SEGMENT
??_C@_0CK@LOFDGDAB@Square?5root?5of?5negative?5number?5?$CF@ DB 'Square r'
	DB	'oot of negative number %g in %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GKAOKNCG@Square?5root?5of?5negative?5number?5?$CF@
CONST	SEGMENT
??_C@_0DB@GKAOKNCG@Square?5root?5of?5negative?5number?5?$CF@ DB 'Square r'
	DB	'oot of negative number %g in %s, %s %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@c059000000000000
CONST	SEGMENT
__real@c059000000000000 DQ 0c059000000000000r	; -100
CONST	ENDS
;	COMDAT __real@46293e5939a08cea
CONST	SEGMENT
__real@46293e5939a08cea DQ 046293e5939a08cear	; 1e+030
CONST	ENDS
;	COMDAT ??_C@_0CP@OEGDEOLM@Non?9integer?5power?5of?5a?5negative?5@
CONST	SEGMENT
??_C@_0CP@OEGDEOLM@Non?9integer?5power?5of?5a?5negative?5@ DB 'Non-intege'
	DB	'r power of a negative number in %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JFAPMCOO@Non?9integer?5power?5of?5a?5negative?5@
CONST	SEGMENT
??_C@_0DG@JFAPMCOO@Non?9integer?5power?5of?5a?5negative?5@ DB 'Non-intege'
	DB	'r power of a negative number in %s, %s %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DJIGLCFH@Negative?5power?5?$CI?$CFd?$CJ?5of?5zero?5in?5?$CF@
CONST	SEGMENT
??_C@_0CE@DJIGLCFH@Negative?5power?5?$CI?$CFd?$CJ?5of?5zero?5in?5?$CF@ DB 'N'
	DB	'egative power (%d) of zero in %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MCPCMAIK@Negative?5power?5?$CI?$CFd?$CJ?5of?5zero?5in?5?$CF@
CONST	SEGMENT
??_C@_0CL@MCPCMAIK@Negative?5power?5?$CI?$CFd?$CJ?5of?5zero?5in?5?$CF@ DB 'N'
	DB	'egative power (%d) of zero in %s, %s %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EOENHDHL@Modulus?5base?5zero?5in?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@EOENHDHL@Modulus?5base?5zero?5in?5?$CFs?4?6?$AA@ DB 'Modulus ba'
	DB	'se zero in %s.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HIHGBPJM@Modulus?5base?5zero?5in?5?$CFs?0?5?$CFs?5?$CFs?4?6@
CONST	SEGMENT
??_C@_0CB@HIHGBPJM@Modulus?5base?5zero?5in?5?$CFs?0?5?$CFs?5?$CFs?4?6@ DB 'M'
	DB	'odulus base zero in %s, %s %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DKCGOBDB@Division?5by?5zero?5in?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@DKCGOBDB@Division?5by?5zero?5in?5?$CFs?4?6?$AA@ DB 'Division by'
	DB	' zero in %s.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MCBMPDHE@Division?5by?5zero?5in?5?$CFs?0?5?$CFs?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@MCBMPDHE@Division?5by?5zero?5in?5?$CFs?0?5?$CFs?5?$CFs?4?6?$AA@ DB 'D'
	DB	'ivision by zero in %s, %s %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@CDGHBNOO@Must?5use?5dynamic?5load?5function?5?$CF@
CONST	SEGMENT
??_C@_0DP@CDGHBNOO@Must?5use?5dynamic?5load?5function?5?$CF@ DB 'Must use'
	DB	' dynamic load function %s in context with parameters.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4005bf0a8b145769
CONST	SEGMENT
__real@4005bf0a8b145769 DQ 04005bf0a8b145769r	; 2.71828
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT ??_C@_0DE@HGELOKGG@Internal?5error?3?5Internal?5variabl@
CONST	SEGMENT
??_C@_0DE@HGELOKGG@Internal?5error?3?5Internal?5variabl@ DB 'Internal err'
	DB	'or: Internal variable %s type not set.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KGAJMGKH@Really?5strange?5configuration?5aro@
CONST	SEGMENT
??_C@_0DF@KGAJMGKH@Really?5strange?5configuration?5aro@ DB 'Really strang'
	DB	'e configuration around deleted edge %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CLIEDLCM@Bad?5delete?5element?5type?5in?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@CLIEDLCM@Bad?5delete?5element?5type?5in?5?$CFs?4?6?$AA@ DB 'Bad'
	DB	' delete element type in %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FBECANMH@Only?5vertices?5and?5edges?5poppable@
CONST	SEGMENT
??_C@_0CD@FBECANMH@Only?5vertices?5and?5edges?5poppable@ DB 'Only vertice'
	DB	's and edges poppable.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NGOPNEKB@Bad?5refine?5element?5type?5in?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@NGOPNEKB@Bad?5refine?5element?5type?5in?5?$CFs?4?6?$AA@ DB 'Bad'
	DB	' refine element type in %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BGHMKKAN@Bad?5LIST?5element?5type?5in?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@BGHMKKAN@Bad?5LIST?5element?5type?5in?5?$CFs?4?6?$AA@ DB 'Bad L'
	DB	'IST element type in %s.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LGOPNDFF@Internal?5error?3?5no?5FINISH?5node?5a@
CONST	SEGMENT
??_C@_0CN@LGOPNDFF@Internal?5error?3?5no?5FINISH?5node?5a@ DB 'Internal e'
	DB	'rror: no FINISH node after RETURN', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FDCGEHJN@redefined?5command?5?8?$CFc?8?$AA@
CONST	SEGMENT
??_C@_0BH@FDCGEHJN@redefined?5command?5?8?$CFc?8?$AA@ DB 'redefined comma'
	DB	'nd ''%c''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@
CONST	SEGMENT
??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@ DB 'EVALTREE.C', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CLILKIPO@show?5expression?5for?5?$CFs?4?$AA@
CONST	SEGMENT
??_C@_0BI@CLILKIPO@show?5expression?5for?5?$CFs?4?$AA@ DB 'show expressio'
	DB	'n for %s.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HCIHCCDE@Procedure?5?$CC?$CFs?$CC?5definition?5has?5no@
CONST	SEGMENT
??_C@_0DG@HCIHCCDE@Procedure?5?$CC?$CFs?$CC?5definition?5has?5no@ DB 'Pro'
	DB	'cedure "%s" definition has not been executed yet.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HMCCGFBA@Function?5?$CC?$CFs?$CC?5definition?5has?5not@
CONST	SEGMENT
??_C@_0DF@HMCCGFBA@Function?5?$CC?$CFs?$CC?5definition?5has?5not@ DB 'Fun'
	DB	'ction "%s" definition has not been executed yet.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LDMPFPFF@Enter?5command?3?5?$AA@
CONST	SEGMENT
??_C@_0BA@LDMPFPFF@Enter?5command?3?5?$AA@ DB 'Enter command: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NLOJJBMG@Calling?5permload?5in?5non?9permanen@
CONST	SEGMENT
??_C@_0CM@NLOJJBMG@Calling?5permload?5in?5non?9permanen@ DB 'Calling perm'
	DB	'load in non-permanent command.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@3abef2d0f5da7dd9
CONST	SEGMENT
__real@3abef2d0f5da7dd9 DQ 03abef2d0f5da7dd9r	; 1e-025
CONST	ENDS
;	COMDAT ??_C@_0BK@OMAPGNOH@Cannot?5open?5datafile?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@OMAPGNOH@Cannot?5open?5datafile?5?$CFs?4?6?$AA@ DB 'Cannot open'
	DB	' datafile %s.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KDKEJCJM@Can?8t?5reload?5in?5a?5subcommand?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@KDKEJCJM@Can?8t?5reload?5in?5a?5subcommand?4?6?$AA@ DB 'Can''t '
	DB	'reload in a subcommand.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_0DC@KLMKCJCH@Changing?5to?5LAGRANGE?5?$CFd?5model?4?5?$CI@
CONST	SEGMENT
??_C@_0DC@KLMKCJCH@Changing?5to?5LAGRANGE?5?$CFd?5model?4?5?$CI@ DB 'Chan'
	DB	'ging to LAGRANGE %d model. (was LAGRANGE %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NAGKEEOG@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@
CONST	SEGMENT
??_C@_0CN@NAGKEEOG@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@ DB 'Changing'
	DB	' to LAGRANGE model. (was QUADRATIC)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JBOLHCFI@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@
CONST	SEGMENT
??_C@_0CK@JBOLHCFI@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@ DB 'Changing'
	DB	' to LAGRANGE model. (was LINEAR)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BFEEPGEG@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@
CONST	SEGMENT
??_C@_0CN@BFEEPGEG@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@ DB 'Changing'
	DB	' to QUADRATIC model. (was LAGRANGE)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IKOBFHOD@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@
CONST	SEGMENT
??_C@_0CL@IKOBFHOD@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@ DB 'Changing'
	DB	' to QUADRATIC model. (was LINEAR)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JMIEKNGL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5L@
CONST	SEGMENT
??_C@_0CK@JMIEKNGL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5L@ DB 'Changin'
	DB	'g to LINEAR model. (was LAGRANGE)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FEBBPANL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5Q@
CONST	SEGMENT
??_C@_0CL@FEBBPANL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5Q@ DB 'Changin'
	DB	'g to LINEAR model. (was QUADRATIC)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@ODNKLDLP@free_discards?5called?5inside?5elem@
CONST	SEGMENT
??_C@_0DE@ODNKLDLP@free_discards?5called?5inside?5elem@ DB 'free_discards'
	DB	' called inside element loop. Ignored.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FAPHFCKA@?5?5?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_06FAPHFCKA@?5?5?5?$CFs?6?$AA@ DB '   %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PBNAGJKF@?5?5?5?$CFs?3?$CFd?6?$AA@
CONST	SEGMENT
??_C@_09PBNAGJKF@?5?5?5?$CFs?3?$CFd?6?$AA@ DB '   %s:%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FJFLMGGP@File?5?$CFs?0?5?$CFs?3?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BA@FJFLMGGP@File?5?$CFs?0?5?$CFs?3?$CFd?6?$AA@ DB 'File %s, %s:%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JMDJOALI@Cannot?5find?5instruction?5on?5line?5@
CONST	SEGMENT
??_C@_0CN@JMDJOALI@Cannot?5find?5instruction?5on?5line?5@ DB 'Cannot find'
	DB	' instruction on line %d of "%s".', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MMHOCNOI@Subcommand?$CI?$CFd?$CJ?3?5?$AA@
CONST	SEGMENT
??_C@_0BB@MMHOCNOI@Subcommand?$CI?$CFd?$CJ?3?5?$AA@ DB 'Subcommand(%d): ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FIJGDPF@Subcommand?3?5?$AA@
CONST	SEGMENT
??_C@_0N@FIJGDPF@Subcommand?3?5?$AA@ DB 'Subcommand: ', 00H ; `string'
CONST	ENDS
;	COMDAT __real@41684bfe477e06cc
CONST	SEGMENT
__real@41684bfe477e06cc DQ 041684bfe477e06ccr	; 1.27385e+007
CONST	ENDS
;	COMDAT ??_C@_0BE@EMCFOMCB@Debug?5command?$CI?$CFd?$CJ?3?5?$AA@
CONST	SEGMENT
??_C@_0BE@EMCFOMCB@Debug?5command?$CI?$CFd?$CJ?3?5?$AA@ DB 'Debug command'
	DB	'(%d): ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MOAJHJDH@Debug?5?$CI?$CC?$CFs?$CC?5line?5?$CFd?$CJ?3?5?$AA@
CONST	SEGMENT
??_C@_0BH@MOAJHJDH@Debug?5?$CI?$CC?$CFs?$CC?5line?5?$CFd?$CJ?3?5?$AA@ DB 'D'
	DB	'ebug ("%s" line %d): ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NIDPEGMM@Internal?5error?5in?5eval?$CI?$CJ?3?5no?5fra@
CONST	SEGMENT
??_C@_0CK@NIDPEGMM@Internal?5error?5in?5eval?$CI?$CJ?3?5no?5fra@ DB 'Inte'
	DB	'rnal error in eval(): no frame setup', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CBLOAPAC@Trying?5to?5evaluate?5null?5expressi@
CONST	SEGMENT
??_C@_0CM@CBLOAPAC@Trying?5to?5evaluate?5null?5expressi@ DB 'Trying to ev'
	DB	'aluate null expression for %s.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _eval
_TEXT	SEGMENT
_normalqXvS$90303 = -5868				; size = 24
_normalqXvS$90324 = -5844				; size = 24
_normalqXvS$92033 = -5820				; size = 24
_eattr$90768 = -5796					; size = 8
_fval$92048 = -5788					; size = 8
_fattr$90792 = -5780					; size = 8
_attr$90515 = -5772					; size = 8
_pspots$92161 = -5764					; size = 32
_qspots$92162 = -5732					; size = 32
_qspots$92705 = -5700					; size = 32
_pspots$93020 = -5668					; size = 32
_sspots$92706 = -5636					; size = 32
_pspots$92704 = -5604					; size = 32
_pspots$92602 = -5572					; size = 32
_qspots$92882 = -5540					; size = 32
_qspots$92603 = -5508					; size = 32
_sspots$93022 = -5476					; size = 32
_sspots$92604 = -5444					; size = 32
_qspots$93021 = -5412					; size = 32
_qspots$92510 = -5380					; size = 32
_sspots$92883 = -5348					; size = 32
_pspots$92796 = -5316					; size = 32
_qspots$92797 = -5284					; size = 32
_pspots$92881 = -5252					; size = 32
_pspots$92509 = -5220					; size = 32
_density$91690 = -5188					; size = 8
_return_value$ = -5180					; size = 8
_scalar$92790 = -5172					; size = 8
_mag$90307 = -5164					; size = 8
_spot$90825 = -5156					; size = 4
_ex_original$GSCopy$ = -5152				; size = 4
_v_id$ = -5148						; size = 4
_qint$92715 = -5144					; size = 4
_x$91560 = -5140					; size = 4
_param$91803 = -5136					; size = 4
_subshell_stack$89500 = -5132				; size = 4
_rhs$91851 = -5128					; size = 8
_oldp$93037 = -5120					; size = 4
_old_trace_spot$89499 = -5116				; size = 4
_datastart1$89752 = -5112				; size = 4
_b$89755 = -5108					; size = 4
_old_flag$ = -5104					; size = 4
_stemp$93036 = -5100					; size = 4
_datastart1$89742 = -5096				; size = 4
_datastart2$89750 = -5092				; size = 4
_rtemp$93035 = -5088					; size = 4
_e_id$91174 = -5084					; size = 4
_hi$ = -5080						; size = 8
_scalar$92247 = -5072					; size = 8
_ptemp$93034 = -5064					; size = 4
_asvalue$92595 = -5060					; size = 4
_lcount$92168 = -5056					; size = 4
_lastsize$92711 = -5052					; size = 4
_eptr$91004 = -5048					; size = 4
_did_graphlock_here$89651 = -5044			; size = 4
_eptr$90988 = -5040					; size = 4
_binsize$91363 = -5036					; size = 8
_testb$90953 = -5028					; size = 4
_did_graphlock_here$89665 = -5024			; size = 4
_entry_flag$ = -5020					; size = 4
_stackused$89452 = -5016				; size = 4
tv25856 = -5012						; size = 8
tv25819 = -5012						; size = 8
_v$91703 = -5012					; size = 8
tv18539 = -5004						; size = 8
_sign$92717 = -5004					; size = 8
_rcount$92612 = -4996					; size = 4
tv21369 = -4992						; size = 4
_array_info$92805 = -4992				; size = 4
_histo_max$ = -4988					; size = 4
_alvalue$92593 = -4984					; size = 4
_pointercount$92720 = -4980				; size = 4
tv31090 = -4976						; size = 4
_sint$92716 = -4976					; size = 4
$T94754 = -4972						; size = 4
_lastsize$92801 = -4972					; size = 4
tv28924 = -4968						; size = 4
_a$89744 = -4968					; size = 4
_asvalue$92697 = -4964					; size = 4
tv30621 = -4960						; size = 4
_array_info$92718 = -4960				; size = 4
_td$ = -4956						; size = 4
_return_node$ = -4952					; size = 4
_alvalue$92695 = -4948					; size = 4
_g$93184 = -4944					; size = 4
_lowdim$92362 = -4940					; size = 4
_p$92157 = -4936					; size = 4
_a$91953 = -4932					; size = 4
_rcount$92712 = -4928					; size = 4
_arvalue$92789 = -4924					; size = 4
_g$92325 = -4920					; size = 4
_pp$92379 = -4916					; size = 4
_alvalue$92788 = -4912					; size = 4
_q$92158 = -4908					; size = 4
_lo$ = -4904						; size = 8
tv20559 = -4896						; size = 4
_s$92329 = -4896					; size = 4
tv26617 = -4892						; size = 4
tv18554 = -4892						; size = 4
_f_ptr$91272 = -4892					; size = 4
_sdim$93032 = -4888					; size = 4
_lastsize$92609 = -4884					; size = 4
_rcount$93029 = -4880					; size = 4
_sint$92617 = -4876					; size = 4
_s$92878 = -4872					; size = 4
_g$91950 = -4868					; size = 4
_lastsize$92514 = -4864					; size = 4
_q$92877 = -4860					; size = 4
_pint$92615 = -4856					; size = 4
_rdim$92894 = -4852					; size = 4
_qint$92616 = -4848					; size = 4
_pointercount$92900 = -4844				; size = 4
tv30084 = -4840						; size = 4
_lcount$92610 = -4840					; size = 4
_a$91849 = -4836					; size = 4
_pint$92170 = -4832					; size = 4
_q$92700 = -4828					; size = 4
tv31164 = -4824						; size = 4
$T94753 = -4824						; size = 4
_qint$92804 = -4824					; size = 4
_p$92597 = -4820					; size = 4
_scount$92613 = -4816					; size = 4
tv9094 = -4816						; size = 4
_q$92598 = -4812					; size = 4
_p$92505 = -4808					; size = 4
tv29133 = -4804						; size = 4
tv29124 = -4804						; size = 4
_breakline$89528 = -4804				; size = 4
_scount$92713 = -4800					; size = 4
tv8795 = -4800						; size = 4
_pint$92519 = -4796					; size = 4
tv13149 = -4792						; size = 4
_v_id$92046 = -4792					; size = 4
_scount$93030 = -4788					; size = 4
_value$91850 = -4784					; size = 8
_p$92876 = -4776					; size = 4
_arvalue$93012 = -4772					; size = 4
_sdim$92893 = -4768					; size = 4
_histo_data$ = -4764					; size = 4
_alvalue$92872 = -4760					; size = 4
_lastsize$93026 = -4756					; size = 4
_arvalue$92873 = -4752					; size = 4
_g$91855 = -4748					; size = 4
_dim$92803 = -4744					; size = 4
_update_display_flag$ = -4740				; size = 4
_arvalue$92696 = -4736					; size = 4
_id$ = -4732						; size = 4
_dim$92614 = -4728					; size = 4
_prevpp$92364 = -4724					; size = 4
_ldim$93031 = -4720					; size = 4
tv29108 = -4716						; size = 4
_pbase$92359 = -4716					; size = 4
tv29571 = -4712						; size = 4
_q$92506 = -4712					; size = 4
_asvalue$92874 = -4708					; size = 4
tv30675 = -4704						; size = 4
_s$92701 = -4704					; size = 4
_dim$92518 = -4700					; size = 4
_histo_count$ = -4696					; size = 4
tv29569 = -4692						; size = 4
_rcount$92517 = -4692					; size = 4
tv30086 = -4688						; size = 4
_s$92599 = -4688					; size = 4
_dim$92167 = -4684					; size = 4
tv29110 = -4680						; size = 4
_alvalue$92357 = -4680					; size = 4
tv19078 = -4676						; size = 4
_fr$89673 = -4676					; size = 4
_pp$92456 = -4672					; size = 4
_p$93015 = -4668					; size = 4
_alvalue$93011 = -4664					; size = 4
_ldim$92892 = -4660					; size = 4
_bdry$ = -4656						; size = 4
_p$92792 = -4652					; size = 4
_lcount$93027 = -4648					; size = 4
_p$92699 = -4644					; size = 4
_k$ = -4640						; size = 4
_params$GSCopy$ = -4636					; size = 4
_lastsize$92166 = -4632					; size = 4
_localcount$ = -4628					; size = 4
_qint$92520 = -4624					; size = 4
_qr$92639 = -4620					; size = 4
_pr$92189 = -4616					; size = 4
_pr$92538 = -4612					; size = 4
_qint$92171 = -4608					; size = 4
_qi$92637 = -4604					; size = 4
_si$92641 = -4600					; size = 4
tv27649 = -4596						; size = 4
_asvalue$93013 = -4596					; size = 4
_sr$92643 = -4592					; size = 4
_dim$92714 = -4588					; size = 4
_s$93017 = -4584					; size = 4
_pi$92633 = -4580					; size = 4
_pi$92187 = -4576					; size = 4
_pi$92536 = -4572					; size = 4
_g$ = -4568						; size = 4
tv20303 = -4564						; size = 4
_q$92793 = -4564					; size = 4
_q$93016 = -4560					; size = 4
tv17681 = -4556						; size = 4
_showflag$90794 = -4556					; size = 4
tv32424 = -4552						; size = 4
tv31696 = -4552						; size = 4
_pointercount$92807 = -4552				; size = 4
tv28928 = -4548						; size = 4
tv28401 = -4548						; size = 4
_a$92072 = -4548					; size = 4
tv30623 = -4544						; size = 4
tv30008 = -4544						; size = 4
tv29567 = -4544						; size = 4
tv20730 = -4544						; size = 4
_k$92251 = -4544					; size = 4
tv488 = -4544						; size = 4
tv27959 = -4540						; size = 4
tv27367 = -4540						; size = 4
_fe_id$90771 = -4540					; size = 4
tv29131 = -4536						; size = 8
tv29122 = -4536						; size = 8
tv28291 = -4536						; size = 8
tv28281 = -4536						; size = 8
tv28271 = -4536						; size = 8
tv24442 = -4536						; size = 8
tv24440 = -4536						; size = 8
tv24438 = -4536						; size = 8
tv24436 = -4536						; size = 8
tv24434 = -4536						; size = 8
tv18540 = -4536						; size = 8
_p$91711 = -4536					; size = 8
_rdim$93033 = -4528					; size = 4
_ext$90824 = -4524					; size = 4
tv28382 = -4520						; size = 4
tv28293 = -4520						; size = 4
tv28284 = -4520						; size = 4
tv28278 = -4520						; size = 4
tv28273 = -4520						; size = 4
tv28268 = -4520						; size = 4
_a$89754 = -4520					; size = 4
tv19769 = -4516						; size = 4
tv17732 = -4516						; size = 4
tv17378 = -4516						; size = 4
tv17012 = -4516						; size = 4
_found$91006 = -4516					; size = 4
tv32420 = -4512						; size = 4
tv32344 = -4512						; size = 4
_lastsize$92887 = -4512					; size = 4
tv32342 = -4508						; size = 4
tv20300 = -4508						; size = 4
_rcount$92802 = -4508					; size = 4
tv28399 = -4504						; size = 4
tv28191 = -4504						; size = 4
tv28095 = -4504						; size = 4
_connum$92050 = -4504					; size = 4
_pp$92415 = -4500					; size = 4
tv11163 = -4496						; size = 4
tv11150 = -4496						; size = 4
tv11133 = -4496						; size = 4
_lcount$92516 = -4496					; size = 4
tv3308 = -4496						; size = 4
tv3265 = -4496						; size = 4
_n$ = -4492						; size = 4
tv27145 = -4488						; size = 4
tv27143 = -4488						; size = 4
tv27141 = -4488						; size = 4
tv27139 = -4488						; size = 4
tv27109 = -4488						; size = 4
tv27107 = -4488						; size = 4
tv27105 = -4488						; size = 4
tv27060 = -4488						; size = 4
_oldflag$90855 = -4488					; size = 4
tv30010 = -4484						; size = 4
tv29433 = -4484						; size = 4
tv25616 = -4484						; size = 4
tv25615 = -4484						; size = 4
tv25610 = -4484						; size = 4
tv25609 = -4484						; size = 4
tv25605 = -4484						; size = 4
tv20352 = -4484						; size = 4
_normal$92035 = -4484					; size = 4
tv18233 = -4480						; size = 4
_showflag$90770 = -4480					; size = 4
tv27151 = -4476						; size = 4
tv27148 = -4476						; size = 4
tv25904 = -4476						; size = 4
tv25898 = -4476						; size = 4
tv25893 = -4476						; size = 4
tv25762 = -4476						; size = 4
tv25754 = -4476						; size = 4
tv25751 = -4476						; size = 4
tv25617 = -4476						; size = 4
tv25611 = -4476						; size = 4
tv25606 = -4476						; size = 4
tv24967 = -4476						; size = 4
tv21884 = -4476						; size = 4
tv21867 = -4476						; size = 4
tv21612 = -4476						; size = 4
_dim$92891 = -4476					; size = 4
_lastsize$92361 = -4472					; size = 4
tv17206 = -4468						; size = 4
tv17191 = -4468						; size = 4
tv17142 = -4468						; size = 4
tv17081 = -4468						; size = 4
tv16824 = -4468						; size = 4
tv12505 = -4468						; size = 4
tv12490 = -4468						; size = 4
_rcount$92169 = -4468					; size = 4
tv31186 = -4464						; size = 4
tv31110 = -4464						; size = 4
tv21942 = -4464						; size = 4
tv21662 = -4464						; size = 4
_qi$92767 = -4464					; size = 4
tv11268 = -4464						; size = 4
tv7490 = -4464						; size = 4
tv6070 = -4464						; size = 4
tv28170 = -4460						; size = 4
tv27980 = -4460						; size = 4
tv27884 = -4460						; size = 4
tv27808 = -4460						; size = 4
tv27733 = -4460						; size = 4
_one_bin_flag$91364 = -4460				; size = 4
_self_id$GSCopy$ = -4456				; size = 4
tv27768 = -4452						; size = 4
tv27766 = -4452						; size = 4
tv27764 = -4452						; size = 4
tv27762 = -4452						; size = 4
tv27760 = -4452						; size = 4
tv27756 = -4452						; size = 4
tv27752 = -4452						; size = 4
tv27717 = -4452						; size = 4
tv27586 = -4452						; size = 4
tv27585 = -4452						; size = 4
tv27575 = -4452						; size = 4
tv27574 = -4452						; size = 4
tv23353 = -4452						; size = 4
_normal$90305 = -4452					; size = 4
tv28724 = -4448						; size = 4
tv25903 = -4448						; size = 4
tv25902 = -4448						; size = 4
tv25897 = -4448						; size = 4
tv25896 = -4448						; size = 4
tv25858 = -4448						; size = 4
tv25846 = -4448						; size = 4
tv25844 = -4448						; size = 4
tv25834 = -4448						; size = 4
tv25832 = -4448						; size = 4
tv25821 = -4448						; size = 4
tv25761 = -4448						; size = 4
tv25760 = -4448						; size = 4
tv25759 = -4448						; size = 4
tv25758 = -4448						; size = 4
tv19976 = -4448						; size = 4
_xx$91808 = -4448					; size = 4
_recalc_flag$ = -4444					; size = 4
_i$ = -4440						; size = 4
tv29137 = -4438						; size = 2
tv29127 = -4438						; size = 2
tv28296 = -4438						; size = 2
tv28287 = -4438						; size = 2
tv28276 = -4438						; size = 2
tv25861 = -4438						; size = 2
tv25849 = -4438						; size = 2
tv25837 = -4438						; size = 2
tv25824 = -4438						; size = 2
tv18640 = -4436						; size = 4
tv5499 = -4436						; size = 4
tv5404 = -4436						; size = 4
tv5365 = -4436						; size = 4
tv5331 = -4436						; size = 4
tv5317 = -4436						; size = 4
tv5263 = -4436						; size = 4
tv5223 = -4436						; size = 4
tv5125 = -4436						; size = 4
tv4908 = -4436						; size = 4
tv4881 = -4436						; size = 4
tv3076 = -4436						; size = 4
tv3038 = -4436						; size = 4
tv3025 = -4436						; size = 4
tv3012 = -4436						; size = 4
tv2999 = -4436						; size = 4
tv2986 = -4436						; size = 4
tv2973 = -4436						; size = 4
_did_graphlock_here$89774 = -4436			; size = 4
_localstack$ = -4432					; size = 4
_localbase$ = -4428					; size = 4
_q_id$ = -4424						; size = 4
_node$ = -4420						; size = 4
_keeplist$89672 = -4416					; size = 104
_bqnode$89762 = -4312					; size = 104
_ex_current$ = -4208					; size = 104
_ta$92898 = -4104					; size = 56
_normalxJ$92034 = -4048					; size = 288
_normalxJ$90325 = -3760					; size = 288
_normalxJ$90304 = -3472					; size = 288
_inx$92698 = -3184					; size = 400
_inx$92791 = -2784					; size = 400
_inx$92156 = -2384					; size = 400
_inx$92504 = -1984					; size = 400
_inx$92596 = -1584					; size = 400
_minsize$92710 = -1184					; size = 32
_minsize$92800 = -1152					; size = 32
_minsize$92513 = -1120					; size = 32
_minsize$92165 = -1088					; size = 32
_sstride$92607 = -1056					; size = 32
_pstride$92707 = -1024					; size = 32
_qstride$93024 = -992					; size = 32
_qstride$92164 = -960					; size = 32
_pstride$93023 = -928					; size = 32
_qstride$92708 = -896					; size = 32
_qstride$92885 = -864					; size = 32
_minsize$92608 = -832					; size = 32
_pstride$92884 = -800					; size = 32
_qstride$92512 = -768					; size = 32
_qstride$92799 = -736					; size = 32
_pstride$92163 = -704					; size = 32
_pstride$92798 = -672					; size = 32
_sstride$92709 = -640					; size = 32
_qstride$92606 = -608					; size = 32
_pstride$92605 = -576					; size = 32
_pstride$92511 = -544					; size = 32
_inx$92875 = -512					; size = 32
_sstride$93025 = -480					; size = 32
_inx$93014 = -448					; size = 32
_vect$ = -416						; size = 48
_sstride$92886 = -368					; size = 32
_pspots$92365 = -336					; size = 32
_prompt_string$89497 = -304				; size = 100
_prompt_string$89429 = -204				; size = 100
_prompt_string$89438 = -104				; size = 100
__$ArrayPad$ = -4					; size = 4
_ex_original$ = 8					; size = 4
_params$ = 12						; size = 4
_self_id$ = 16						; size = 4
_parent_frame$ = 20					; size = 4
_eval	PROC						; COMDAT

; 83   : { 

	push	ebp
	mov	ebp, esp
	mov	eax, 5868				; 000016ecH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 84   :   struct treenode *node; /* currently executing node */
; 85   : 
; 86   :   struct thread_data *td = GET_THREAD_DATA;

	mov	edx, DWORD PTR _thread_data_key

; 87   :   #define newstack  (td->eval_stack)
; 88   :   #define stackmax  (td->eval_stack_size)
; 89   :   #define stacktop  (td->stack_top)
; 90   :   #define this_frame ((struct eval_frame*)(newstack + td->frame_spot))
; 91   : 
; 92   :   int entry_flag = BASE_OF_EVAL; /* so can set frame flag marking entry to eval() */

	mov	eax, DWORD PTR _params$[ebp]
	mov	ecx, DWORD PTR _self_id$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _ex_original$[ebp]
	push	edi
	push	edx

; 5554 : 
; 5555 :       case ARRAY_ADD_NODE:   // result to temp array 
; 5556 :       case ARRAY_SUBTRACT_NODE:
; 5557 :         { 
; 5558 :           struct array *alvalue;
; 5559 :           struct array *arvalue= get_name_arrayptr(node->op3.name_id,newstack + localstack,localbase);

	mov	DWORD PTR _ex_original$GSCopy$[ebp], esi
	mov	DWORD PTR _params$GSCopy$[ebp], eax
	mov	DWORD PTR _self_id$GSCopy$[ebp], ecx
	call	_win_get_thread_data
	mov	ebx, eax
	mov	eax, DWORD PTR _self_id$GSCopy$[ebp]
	mov	ecx, 26					; 0000001aH
	lea	edi, DWORD PTR _ex_current$[ebp]
	rep movsd
	mov	ecx, DWORD PTR _iterate_flag
	mov	DWORD PTR _q_id$[ebp], eax
	xor	eax, eax
	add	esp, 4
	mov	DWORD PTR _td$[ebp], ebx
	mov	DWORD PTR _entry_flag$[ebp], 2
	mov	DWORD PTR _return_node$[ebp], eax
	mov	DWORD PTR _old_flag$[ebp], ecx
	mov	DWORD PTR _recalc_flag$[ebp], eax
	mov	DWORD PTR _update_display_flag$[ebp], eax
	cmp	DWORD PTR _l_evolver_break, eax
	je	SHORT $LN1996@eval

; 93   :   
; 94   :   /* variables that act like registers for stack gymnastics */
; 95   :   struct expnode ex_current = *ex_original;
; 96   : 
; 97   :   struct locallist_t *localbase;
; 98   :   int localcount;
; 99   :   element_id q_id = self_id;  /* innermost loop element */
; 100  :   REAL return_value;
; 101  :   struct treenode *return_node = NULL;
; 102  :   int localstack; /* offset of base of local stack, after frame structure */
; 103  : 
; 104  :   /* miscellaneous local variables useful in executing nodes */
; 105  :   int k,n,i;
; 106  :   REAL x,y;
; 107  :   element_id id; 
; 108  :   REAL *bins;
; 109  :   REAL hi;
; 110  :   REAL lo;
; 111  :   REAL val;
; 112  :   int old_flag = iterate_flag;
; 113  :   facet_id f_id;
; 114  :   REAL vect[MAXCOORD];
; 115  :   facetedge_id fe;
; 116  :   vertex_id v_id;
; 117  :   int recalc_flag = 0;
; 118  :   int update_display_flag = 0;
; 119  :   struct boundary *bdry;
; 120  :   REAL *histo_data;
; 121  :   int histo_max;
; 122  :   int histo_count;
; 123  :   struct global *g;
; 124  :   int oldquiet;
; 125  : #ifdef PROF_EVALS
; 126  :   struct expnode *ex_profiling = ex_original; // purely for profiling
; 127  : #endif
; 128  : #ifdef __L_EVOLVER__
; 129  :         if (l_evolver_break)
; 130  :           {
; 131  :           breakflag = BREAKFULL;	
; 132  :           //breakflag = BREAKABORT;	
; 133  : 		  l_evolver_break=FALSE;

	mov	DWORD PTR _breakflag, 1
	mov	DWORD PTR _l_evolver_break, eax
$LN1996@eval:

; 134  :           } 
; 135  : 
; 136  : #endif
; 137  :   
; 138  :   if ( ex_original == NULL ) return 0.0;
; 139  :   ex_current = *ex_original;

	mov	esi, DWORD PTR _ex_original$GSCopy$[ebp]
	mov	ecx, 26					; 0000001aH
	lea	edi, DWORD PTR _ex_current$[ebp]
	rep movsd

; 140  : 
; 141  :   if ( ex_current.start == NULL )

	mov	eax, DWORD PTR _ex_current$[ebp]
	test	eax, eax
	jne	SHORT $LN1994@eval

; 142  :   { sprintf(errmsg,"Trying to evaluate null expression for %s.\n",ex_current.name);

	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	OFFSET ??_C@_0CM@CBLOAPAC@Trying?5to?5evaluate?5null?5expressi@
	push	OFFSET _errmsg
	call	_sprintf

; 143  :     kb_error(1253,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1253					; 000004e5H
	call	_kb_error

; 6448 :   stacktop--; /* since points to occupied spot */
; 6449 :   td->frame_spot = this_frame->parent_frame_spot;
; 6450 :   return 0.0;

	fldz
	add	esp, 24					; 00000018H

; 6451 : } /* end eval() */

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1994@eval:

; 144  :     return 0.0;
; 145  :   }
; 146  : 
; 147  :   PROF_EVAL_START(ex_profiling);
; 148  :   PROF_COUNT_INCR(ex_profiling);
; 149  : 
; 150  :   if ( !breakflag ) iterate_flag = 2; /* for interrupt handler */

	cmp	DWORD PTR _breakflag, 0
	jne	SHORT $LN1993@eval
	mov	DWORD PTR _iterate_flag, 2
$LN1993@eval:

; 151  : 
; 152  :   if ( ex_current.start[1].type != SETUP_FRAME_NODE )

	cmp	DWORD PTR [eax+168], 10001		; 00002711H
	je	SHORT $LN1992@eval

; 153  :   { sprintf(errmsg,"Internal error in eval(): no frame setup\n");

	push	OFFSET ??_C@_0CK@NIDPEGMM@Internal?5error?5in?5eval?$CI?$CJ?3?5no?5fra@
	push	OFFSET _errmsg
	call	_sprintf

; 154  :     sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 155  :                  file_names[ex_current.start[1].file_no],ex_current.start[1].line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL2789@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2789@eval
	mov	ecx, DWORD PTR _ex_current$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+180]
	mov	ecx, DWORD PTR [ecx+184]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 156  :     kb_error(3987,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3987					; 00000f93H
	call	_kb_error
	mov	eax, DWORD PTR _ex_current$[ebp]
	add	esp, 28					; 0000001cH
$LN1992@eval:

; 157  :   }
; 158  :  
; 159  :   for ( node = ex_current.start+1 ; ; node++ )

	add	eax, 168				; 000000a8H
	mov	DWORD PTR _node$[ebp], eax
	npad	4
$LL1991@eval:

; 160  :   {
; 161  :     if ( single_step_debugging && (node->line_no != current_debug_line) )

	cmp	DWORD PTR _single_step_debugging, 0
	je	$LN1988@eval
	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+12]
	cmp	eax, DWORD PTR _current_debug_line
	je	$LN1988@eval

; 162  :     { char prompt_string[100];
; 163  :       current_debug_line = node->line_no;

	mov	DWORD PTR _current_debug_line, eax

; 164  :       subshell_depth++;

	mov	eax, DWORD PTR _subshell_depth
	mov	edi, 1
	add	eax, edi
	mov	DWORD PTR _subshell_depth, eax

; 165  :       subshell_frame[subshell_depth] = this_frame;

	mov	ecx, DWORD PTR [ebx+52]
	mov	edx, DWORD PTR [ebx+40]
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _subshell_frame[eax*4], ecx

; 166  :       setjmp(jumpbuf[subshell_depth]);

	shl	eax, 6
	xor	esi, esi
	add	eax, OFFSET _jumpbuf
	push	esi
	push	eax
	call	__setjmp3

; 167  :       if ( subshell_depth == 1 )

	mov	eax, DWORD PTR _subshell_depth
	add	esp, 8
	cmp	eax, edi
	jne	SHORT $LN1987@eval

; 168  :         sprintf(prompt_string,"Debug (\"%s\" line %d): ",ex_current.name,node->line_no);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR _ex_current$[ebp+20]
	push	ecx
	lea	edx, DWORD PTR _prompt_string$89429[ebp]
	push	OFFSET ??_C@_0BH@MOAJHJDH@Debug?5?$CI?$CC?$CFs?$CC?5line?5?$CFd?$CJ?3?5?$AA@
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 169  :       else

	jmp	SHORT $LN1986@eval
$LN1987@eval:

; 170  :       { sprintf(prompt_string,"Debug command(%d): ",subshell_depth);

	push	eax
	lea	eax, DWORD PTR _prompt_string$89429[ebp]
	push	OFFSET ??_C@_0BE@EMCFOMCB@Debug?5command?$CI?$CFd?$CJ?3?5?$AA@
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1986@eval:

; 171  :       }
; 172  :       /* command read and execute loop */
; 173  :       debugging_flag = 1;
; 174  :       single_step_debugging = 0;
; 175  :       exec_commands(NULL,prompt_string);

	lea	ecx, DWORD PTR _prompt_string$89429[ebp]
	push	ecx
	push	esi
	mov	DWORD PTR _debugging_flag, edi
	mov	DWORD PTR _single_step_debugging, esi
	call	_exec_commands
	add	esp, 8

; 176  :       subshell_depth--;

	sub	DWORD PTR _subshell_depth, edi

; 177  :       debugging_flag = 0;

	mov	DWORD PTR _debugging_flag, esi

; 178  :     }  
; 179  :     else

	jmp	$LN3947@eval
$LN1988@eval:

; 180  :     /* have reached node set to a breakpoint */
; 181  :     if ( node->flags & BREAKPOINT_NODE )

	mov	edx, DWORD PTR _node$[ebp]
	test	DWORD PTR [edx+24], 4096		; 00001000H
	je	$LN1984@eval

; 182  :     { char prompt_string[100];
; 183  :       current_debug_line = node->line_no;

	mov	eax, edx
	mov	ecx, DWORD PTR [eax+12]

; 184  :       subshell_depth++;

	mov	eax, DWORD PTR _subshell_depth
	mov	esi, 1
	add	eax, esi
	mov	DWORD PTR _subshell_depth, eax
	mov	DWORD PTR _current_debug_line, ecx

; 185  :       subshell_frame[subshell_depth] = this_frame;

	mov	edx, DWORD PTR [ebx+52]
	mov	ecx, DWORD PTR [ebx+40]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _subshell_frame[eax*4], edx

; 186  :       setjmp(jumpbuf[subshell_depth]);

	shl	eax, 6
	add	eax, OFFSET _jumpbuf
	push	0
	push	eax
	call	__setjmp3

; 187  :       if ( subshell_depth == 1 )

	mov	eax, DWORD PTR _subshell_depth
	add	esp, 8
	cmp	eax, esi
	jne	SHORT $LN1983@eval

; 188  :         sprintf(prompt_string,"Debug (\"%s\" line %d): ",ex_current.name,node->line_no);

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	lea	eax, DWORD PTR _prompt_string$89438[ebp]
	push	OFFSET ??_C@_0BH@MOAJHJDH@Debug?5?$CI?$CC?$CFs?$CC?5line?5?$CFd?$CJ?3?5?$AA@
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 189  :       else

	jmp	SHORT $LN1982@eval
$LN1983@eval:

; 190  :       { sprintf(prompt_string,"Debug command(%d): ",subshell_depth);

	push	eax
	lea	ecx, DWORD PTR _prompt_string$89438[ebp]
	push	OFFSET ??_C@_0BE@EMCFOMCB@Debug?5command?$CI?$CFd?$CJ?3?5?$AA@
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1982@eval:

; 191  :       }
; 192  :       /* command read and execute loop */
; 193  :       debugging_flag = 1;
; 194  :       exec_commands(NULL,prompt_string);

	lea	edx, DWORD PTR _prompt_string$89438[ebp]
	push	edx
	push	0
	mov	DWORD PTR _debugging_flag, esi
	call	_exec_commands
	add	esp, 8

; 195  :       subshell_depth--;

	sub	DWORD PTR _subshell_depth, esi

; 196  :       debugging_flag = 0;

	mov	DWORD PTR _debugging_flag, 0
$LN3947@eval:
	mov	ebx, DWORD PTR _td$[ebp]
$LN1984@eval:

; 197  :     }
; 198  : 
; 199  : //mem_sanity_check();
; 200  : 
; 201  :     switch ( node->type )

	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [edx-10001]
	cmp	eax, 385				; 00000181H
	ja	$LN18@eval
	jmp	DWORD PTR $LN4028@eval[eax*4]
$LN1979@eval:

; 202  :     {
; 203  :       struct treenode *where,*enode,*eroot;
; 204  : 
; 205  :       case SETUP_FRAME_NODE: /* first node of any procedure */
; 206  :         { int parent_frame_spot;
; 207  :           int stackused = (int)(stacktop-newstack);

	mov	edx, DWORD PTR [ebx+48]
	sub	edx, DWORD PTR [ebx+40]

; 208  :           
; 209  :           /* check stack space */
; 210  :           localbase = ex_current.locals;

	mov	eax, DWORD PTR _ex_current$[ebp+8]
	sar	edx, 3
	mov	DWORD PTR _stackused$89452[ebp], edx
	mov	DWORD PTR _localbase$[ebp], eax

; 211  :           if ( ex_current.locals )

	test	eax, eax
	je	SHORT $LN1978@eval

; 212  :             localcount = ex_current.locals->totalsize;

	mov	eax, DWORD PTR [eax+12]
	jmp	SHORT $LN3948@eval
$LN1978@eval:

; 213  :           else localcount = 0;

	xor	eax, eax
$LN3948@eval:
	mov	DWORD PTR _localcount$[ebp], eax

; 214  :           if ( stackmax  <  stackused + localcount + ex_current.stack_max + FRAME_SPACE + 20 ) 

	add	eax, DWORD PTR _ex_current$[ebp+16]
	add	eax, edx
	lea	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ebx+44], ecx
	jge	SHORT $LN1976@eval

; 215  :           { 
; 216  :             stackmax = stackused + localcount + ex_current.stack_max + FRAME_SPACE + 300;

	add	eax, 316				; 0000013cH

; 217  :             newstack = (REAL*)realloc(newstack,stackmax*sizeof(REAL) );

	lea	edx, DWORD PTR [eax*8]
	mov	DWORD PTR [ebx+44], eax
	mov	eax, DWORD PTR [ebx+40]
	push	edx
	push	eax
	call	_realloc

; 218  :             stacktop = newstack + stackused;
; 219  :             newstack[stackmax-1]  = STACKMAGIC;  /* sentinel */         

	fld	QWORD PTR __real@41684bfe477e06cc
	mov	ecx, DWORD PTR _stackused$89452[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [ebx+40], eax
	mov	DWORD PTR [ebx+48], edx
	mov	eax, DWORD PTR [ebx+44]
	mov	ecx, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR _stackused$89452[ebp]
	fstp	QWORD PTR [ecx+eax*8-8]
	add	esp, 8
$LN1976@eval:

; 220  :           } 
; 221  : 
; 222  :           /* find parent frame, if any */
; 223  :           parent_frame_spot = td->frame_spot;
; 224  :           if ( stacktop == newstack  )

	mov	ecx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [ebx+52]
	cmp	ecx, DWORD PTR [ebx+40]
	jne	SHORT $LN1975@eval

; 225  :              parent_frame = NULL;

	mov	DWORD PTR _parent_frame$[ebp], 0

; 226  : 
; 227  :           else

	jmp	SHORT $LN1974@eval
$LN1975@eval:

; 228  :              parent_frame = (struct eval_frame*)(newstack + parent_frame_spot);

	mov	ecx, DWORD PTR [ebx+40]
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _parent_frame$[ebp], ecx
$LN1974@eval:

; 229  :           stacktop++;

	add	DWORD PTR [ebx+48], 8

; 230  : 
; 231  :           /* Set up first frame at current stack position */
; 232  :           td->frame_spot = (int)(stacktop - newstack);  /* sets this_frame by macro */

	mov	ecx, DWORD PTR [ebx+48]
	sub	ecx, DWORD PTR [ebx+40]
	sar	ecx, 3
	mov	DWORD PTR [ebx+52], ecx

; 233  :           stacktop += FRAME_SPACE-1;

	add	DWORD PTR [ebx+48], 120			; 00000078H

; 234  :           this_frame->base_ex = ex_current;

	mov	ecx, DWORD PTR [ebx+52]
	mov	esi, DWORD PTR [ebx+40]
	lea	edi, DWORD PTR [esi+ecx*8+8]
	mov	ecx, 26					; 0000001aH
	lea	esi, DWORD PTR _ex_current$[ebp]
	rep movsd

; 235  :           this_frame->basenode = &node;  

	mov	ecx, DWORD PTR [ebx+52]
	mov	esi, DWORD PTR [ebx+40]
	lea	edi, DWORD PTR _node$[ebp]
	mov	DWORD PTR [esi+ecx*8], edi

; 236  :           this_frame->parent_frame_spot = parent_frame_spot;

	mov	ecx, DWORD PTR [ebx+52]
	mov	esi, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+ecx*8+116], eax

; 237  :           td->frame_spot = (int)((REAL*)this_frame - newstack);  // redundant?

	mov	eax, DWORD PTR [ebx+52]

; 238  :           this_frame->self_id = self_id;

	mov	esi, DWORD PTR _self_id$GSCopy$[ebp]

; 239  :           this_frame->return_node = return_node;
; 240  :           this_frame->flags = entry_flag;

	mov	edi, DWORD PTR _entry_flag$[ebp]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	sar	eax, 3
	mov	DWORD PTR [ebx+52], eax
	mov	ecx, DWORD PTR [ebx+40]
	mov	DWORD PTR [ecx+eax*8+112], esi
	mov	eax, DWORD PTR [ebx+52]
	mov	esi, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR _return_node$[ebp]
	mov	DWORD PTR [esi+eax*8+120], ecx
	mov	eax, DWORD PTR [ebx+52]
	mov	esi, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+eax*8+124], edi

; 241  :           if ( stackused == 0 )

	test	edx, edx
	jne	SHORT $LN1973@eval

; 242  :             this_frame->flags |= BASE_OF_WHOLE_STACK;

	mov	edx, DWORD PTR [ebx+52]
	mov	eax, DWORD PTR [ebx+40]
	or	DWORD PTR [eax+edx*8+124], 4
	lea	eax, DWORD PTR [eax+edx*8+124]
$LN1973@eval:

; 243  :           entry_flag = 0;
; 244  :           if ( parent_frame ) 

	mov	edx, DWORD PTR _parent_frame$[ebp]
	mov	DWORD PTR _entry_flag$[ebp], 0
	test	edx, edx
	je	SHORT $LN1971@eval

; 245  :           { this_frame->flags |= parent_frame->flags  & IN_ELEMENT_LOOP;

	mov	eax, DWORD PTR [ebx+52]
	mov	esi, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR [edx+124]
	and	edx, 2048				; 00000800H
	or	DWORD PTR [esi+eax*8+124], edx
	lea	eax, DWORD PTR [esi+eax*8+124]

; 246  :             if ( return_node )

	test	ecx, ecx
	je	SHORT $LN1971@eval

; 247  :                 this_frame->flags |= return_node->flags & IN_ELEMENT_LOOP;

	mov	eax, DWORD PTR [ebx+52]
	mov	edx, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [ecx+24]
	lea	eax, DWORD PTR [edx+eax*8+124]
	and	ecx, 2048				; 00000800H
	or	DWORD PTR [eax], ecx
$LN1971@eval:

; 248  :           }   
; 249  :           localstack = (int)((stacktop + 1) - newstack);

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, eax
	sub	ecx, DWORD PTR [ebx+40]
	add	ecx, 8
	sar	ecx, 3

; 250  :           
; 251  :           /* local variables after frame */
; 252  :           if ( localcount )

	cmp	DWORD PTR _localcount$[ebp], 0
	mov	DWORD PTR _localstack$[ebp], ecx
	je	$LN1980@eval

; 253  :           { stacktop++;
; 254  :             memset((char*)stacktop,0,localcount*sizeof(REAL));

	mov	esi, DWORD PTR _localcount$[ebp]
	add	esi, esi
	add	esi, esi
	add	esi, esi
	push	esi
	add	eax, 8
	push	0
	push	eax
	mov	DWORD PTR [ebx+48], eax
	call	_memset

; 255  :             stacktop += localcount-1; /* room for local variables */

	add	esi, -8					; fffffff8H
	add	esp, 12					; 0000000cH
	add	DWORD PTR [ebx+48], esi

; 256  :           }
; 257  : 
; 258  :         }
; 259  :         break;  /* end SETUP_FRAME_NODE */

	jmp	$LN1980@eval
$LN1969@eval:

; 260  : 
; 261  :       case ABORT_NODE:
; 262  : /*
; 263  :           if ( subshell_depth )
; 264  :           { exit_flag = 1;
; 265  :             break;
; 266  :           }
; 267  : */
; 268  :           breakflag = BREAKABORT;

	mov	DWORD PTR _breakflag, 5

; 269  :           break;

	jmp	$LN2783@eval
$LN1968@eval:

; 270  : 
; 271  :       case SUBCOMMAND_NODE:
; 272  :     { char prompt_string[100];
; 273  :       char *pmpt;
; 274  :       int old_trace_spot = eval_stack_trace_spot;
; 275  :       REAL *subshell_stack;
; 276  :       subshell_depth++;

	mov	eax, DWORD PTR _subshell_depth
	mov	edx, DWORD PTR _eval_stack_trace_spot
	inc	eax
	mov	DWORD PTR _subshell_depth, eax

; 277  :       subshell_frame[subshell_depth] = this_frame;

	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR _old_trace_spot$89499[ebp], edx
	mov	edx, DWORD PTR [ebx+40]
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _subshell_frame[eax*4], ecx

; 278  :       subshell_stack = stacktop;

	mov	edx, DWORD PTR [ebx+48]

; 279  :       setjmp(jumpbuf[subshell_depth]);

	shl	eax, 6
	add	eax, OFFSET _jumpbuf
	push	0
	push	eax
	mov	DWORD PTR _subshell_stack$89500[ebp], edx
	call	__setjmp3

; 280  :       stacktop = subshell_stack;  // set stack properly on return from error

	mov	eax, DWORD PTR _subshell_stack$89500[ebp]
	mov	ebx, DWORD PTR _td$[ebp]
	mov	DWORD PTR [ebx+48], eax

; 281  :       if ( subshell_depth == 1 )

	mov	eax, DWORD PTR _subshell_depth
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN1967@eval

; 282  :        pmpt = "Subcommand: ";

	mov	ecx, OFFSET ??_C@_0N@FIJGDPF@Subcommand?3?5?$AA@

; 283  :       else

	jmp	SHORT $LN1966@eval
$LN1967@eval:

; 284  :       { sprintf(prompt_string,"Subcommand(%d): ",subshell_depth);

	push	eax
	lea	ecx, DWORD PTR _prompt_string$89497[ebp]
	push	OFFSET ??_C@_0BB@MMHOCNOI@Subcommand?$CI?$CFd?$CJ?3?5?$AA@
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 285  :         pmpt = prompt_string;

	lea	ecx, DWORD PTR _prompt_string$89497[ebp]
$LN1966@eval:

; 286  :       }
; 287  :       PUSH_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	cmp	eax, 100				; 00000064H
	jl	SHORT $LN1965@eval
	xor	eax, eax
$LN1965@eval:
	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _eval_stack_trace[eax*4], edx

; 288  :       /* command read and execute loop */
; 289  :       exec_commands(NULL,pmpt);

	push	ecx
	inc	eax
	push	0
	mov	DWORD PTR _eval_stack_trace_spot, eax
	call	_exec_commands

; 290  :       subshell_depth--;
; 291  :       eval_stack_trace_spot = old_trace_spot;

	mov	eax, DWORD PTR _old_trace_spot$89499[ebp]
	add	esp, 8
	dec	DWORD PTR _subshell_depth
	mov	DWORD PTR _eval_stack_trace_spot, eax

; 292  :       break;

	jmp	$LN1980@eval
$LN1964@eval:

; 293  :     }
; 294  : 
; 295  :       case SET_BREAKPOINT_NODE:
; 296  :     { int breakline = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], esi

; 297  :       struct expnode *proc;
; 298  :       struct treenode *nodespot;
; 299  :       int found = 0;
; 300  :       /* now set flag bit in first node on line */
; 301  :       proc =  &(globals(node->op1.name_id)->value.proc); 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	edi, edx
	and	edi, -16777216				; ff000000H
	cmp	edi, 268435456				; 10000000H
	je	SHORT $LN1999@eval
	cmp	edi, 805306368				; 30000000H
	jne	SHORT $LN2001@eval
	mov	ecx, DWORD PTR _localbase$[ebp]
	and	edx, 16777215				; 00ffffffH
	mov	esi, edx
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [ecx]
	jmp	SHORT $LN2000@eval
$LN2001@eval:
	cmp	edi, 536870912				; 20000000H
	jne	SHORT $LN1999@eval
	mov	ecx, DWORD PTR _web+5656
	and	edx, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2000@eval
$LN1999@eval:
	mov	ecx, DWORD PTR _web+5652
	mov	esi, DWORD PTR _dymem
	and	edx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	esi, DWORD PTR [ecx+esi]
$LN2000@eval:

; 302  :       for ( nodespot = proc->start+1 ; nodespot != proc->root ; nodespot++ )

	mov	ecx, DWORD PTR [esi+64]
	mov	esi, DWORD PTR [esi+68]
	add	ecx, 168				; 000000a8H
	cmp	ecx, esi
	je	SHORT $LN1961@eval
$LL1963@eval:

; 303  :         if ( nodespot->line_no == breakline )

	cmp	DWORD PTR [ecx+12], eax
	je	SHORT $LN2609@eval

; 302  :       for ( nodespot = proc->start+1 ; nodespot != proc->root ; nodespot++ )

	add	ecx, 168				; 000000a8H
	cmp	ecx, esi
	jne	SHORT $LL1963@eval
$LN1961@eval:

; 313  :       { sprintf(msg,"Cannot find instruction on line %d of \"%s\".\n",
; 314  :            breakline,globals(node->op1.name_id)->name);

	cmp	edi, 268435456				; 10000000H
	je	SHORT $LN2005@eval
	cmp	edi, 805306368				; 30000000H
	jne	SHORT $LN2007@eval
	mov	ecx, DWORD PTR _localbase$[ebp]
	imul	edx, 224				; 000000e0H
	add	edx, DWORD PTR [ecx]
	jmp	SHORT $LN2006@eval
$LN2609@eval:

; 304  :         { nodespot->flags |= BREAKPOINT_NODE;

	or	DWORD PTR [ecx+24], 4096		; 00001000H

; 305  :           /* record for unset */
; 306  :           breaklist[breakcount].name_id = node->op1.name_id;

	mov	ecx, DWORD PTR _breakcount
	mov	edx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [edx+32]
	mov	DWORD PTR _breaklist[ecx*8], edx

; 307  :           breaklist[breakcount].line = breakline;

	mov	DWORD PTR _breaklist[ecx*8+4], eax

; 308  :           breakcount++;

	inc	ecx
	mov	DWORD PTR _breakcount, ecx

; 309  :           found = 1;
; 310  :           break;
; 311  :         }
; 312  :       if ( !found )

	jmp	$LN1980@eval
$LN2007@eval:

; 313  :       { sprintf(msg,"Cannot find instruction on line %d of \"%s\".\n",
; 314  :            breakline,globals(node->op1.name_id)->name);

	cmp	edi, 536870912				; 20000000H
	jne	SHORT $LN2005@eval
	mov	ecx, DWORD PTR _web+5656
	mov	edx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2006@eval
$LN2005@eval:
	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ecx]
$LN2006@eval:
	push	edx
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0CN@JMDJOALI@Cannot?5find?5instruction?5on?5line?5@
	push	edx
	call	_sprintf

; 315  :         outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H

; 316  :       }
; 317  :       break;

	jmp	$LN1980@eval
$LN1958@eval:

; 318  :     }
; 319  : 
; 320  :       case UNSET_BREAKPOINT_NODE:
; 321  :     { 
; 322  :       struct expnode *proc;
; 323  :       struct treenode *nodespot;
; 324  : 
; 325  :       if ( node->left ) /* particular */

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	$LN1957@eval

; 326  :       {
; 327  :         int breakline = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], esi

; 328  :         /* unmark breakpoint node */
; 329  :         proc =  &(globals(node->op1.name_id)->value.proc);  

	mov	edx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	mov	esi, DWORD PTR _dymem
	mov	edi, DWORD PTR _web+5652
	mov	edx, ecx
	and	edx, -16777216				; ff000000H
	mov	DWORD PTR _breakline$89528[ebp], eax
	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN2011@eval
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN2013@eval
	mov	edx, DWORD PTR _localbase$[ebp]
	and	ecx, 16777215				; 00ffffffH
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN2012@eval
$LN2013@eval:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN2011@eval
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN2012@eval
$LN2011@eval:
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+esi]
$LN2012@eval:

; 330  :         for ( nodespot = proc->start ; nodespot != proc->root ; nodespot++ )

	mov	edx, DWORD PTR [ecx+64]
	cmp	edx, DWORD PTR [ecx+68]
	je	SHORT $LN1954@eval
	mov	esi, -4097				; ffffefffH
	npad	3
$LL1956@eval:

; 331  :           if ( nodespot->line_no == breakline )

	cmp	DWORD PTR [edx+12], eax
	jne	SHORT $LN1955@eval

; 332  :             nodespot->flags &= ~BREAKPOINT_NODE;

	and	DWORD PTR [edx+24], esi
$LN1955@eval:

; 330  :         for ( nodespot = proc->start ; nodespot != proc->root ; nodespot++ )

	add	edx, 168				; 000000a8H
	cmp	edx, DWORD PTR [ecx+68]
	jne	SHORT $LL1956@eval
$LN1954@eval:

; 333  :         /* remove from breakpoint list */
; 334  :         for ( i = 0 ; i < breakcount ; i++ )

	mov	edx, DWORD PTR _breakcount
	xor	esi, esi
	test	edx, edx
	jle	$LN1980@eval
	mov	ecx, OFFSET _breaklist
	npad	8
$LL1952@eval:

; 335  :           if ( (breaklist[i].name_id == node->op1.name_id) &&
; 336  :                 (breaklist[i].line == breakline) )

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR _node$[ebp]
	cmp	eax, DWORD PTR [edi+32]
	jne	SHORT $LN1951@eval
	mov	eax, DWORD PTR _breakline$89528[ebp]
	cmp	DWORD PTR [ecx+4], eax
	jne	SHORT $LN1951@eval

; 337  :           { breaklist[i] = breaklist[--breakcount];

	mov	eax, DWORD PTR _breaklist[edx*8-8]
	dec	edx
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _breaklist[edx*8+4]
	mov	DWORD PTR _breakcount, edx
	mov	DWORD PTR [ecx+4], eax
$LN1951@eval:

; 333  :         /* remove from breakpoint list */
; 334  :         for ( i = 0 ; i < breakcount ; i++ )

	inc	esi
	add	ecx, 8
	cmp	esi, edx
	jl	SHORT $LL1952@eval

; 338  :           }
; 339  :       }
; 340  :       else /* all */

	jmp	$LN1980@eval
$LN1957@eval:

; 341  :       {
; 342  :         for ( i = 0 ; i < breakcount ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _breakcount, edi
	jle	$LN1945@eval
	mov	esi, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	npad	7
$LL1947@eval:

; 343  :         { proc =  &(globals(breaklist[i].name_id)->value.proc); 

	mov	eax, DWORD PTR _breaklist[edi*8]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	and	eax, 16777215				; 00ffffffH
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN2021@eval
	lea	ecx, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [ecx+edx]
	jmp	SHORT $LN2018@eval
$LN2021@eval:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2019@eval
	mov	ecx, DWORD PTR _localbase$[ebp]
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN2018@eval
$LN2019@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2017@eval
	mov	ecx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN2018@eval
$LN2017@eval:
	lea	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+edx]
$LN2018@eval:

; 344  :           for ( nodespot = proc->start ; nodespot != proc->root ; nodespot++ )

	mov	ecx, DWORD PTR [eax+64]
	cmp	ecx, DWORD PTR [eax+68]
	je	SHORT $LN1946@eval
	mov	edx, -4097				; ffffefffH
$LL1944@eval:

; 345  :             nodespot->flags &= ~BREAKPOINT_NODE;

	and	DWORD PTR [ecx+24], edx
	add	ecx, 168				; 000000a8H
	cmp	ecx, DWORD PTR [eax+68]
	jne	SHORT $LL1944@eval

; 344  :           for ( nodespot = proc->start ; nodespot != proc->root ; nodespot++ )

	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR _web+5652
$LN1946@eval:

; 341  :       {
; 342  :         for ( i = 0 ; i < breakcount ; i++ )

	inc	edi
	cmp	edi, DWORD PTR _breakcount
	jl	$LL1947@eval
$LN1945@eval:

; 346  :         }
; 347  :         breakcount = 0;

	mov	DWORD PTR _breakcount, 0

; 348  :       }
; 349  :       break;

	jmp	$LN1980@eval
$LN1941@eval:

; 350  :     }
; 351  : 
; 352  :       case DETORUS_NODE: detorus(); recalc(); break;

	call	_detorus
	call	_recalc
	jmp	$LN1980@eval
$LN1940@eval:

; 353  : 
; 354  :       case WHEREAMI_COMMAND_NODE: /* for use in debugging or subshells */
; 355  :         { struct eval_frame *frame = subshell_frame[subshell_depth];
; 356  :            if ( eval_stack_trace_spot > 0 )

	mov	edi, DWORD PTR _eval_stack_trace_spot
	mov	ecx, DWORD PTR _subshell_depth
	mov	esi, DWORD PTR _subshell_frame[ecx*4]
	test	edi, edi
	jle	SHORT $LN1939@eval

; 357  :            { 
; 358  :              for ( i = eval_stack_trace_spot ; i >= 0 ; i-- )

	js	SHORT $LN1936@eval
$LN1938@eval:

; 359  :              { struct treenode *node = eval_stack_trace[i];

	mov	eax, DWORD PTR _eval_stack_trace[edi*4]

; 360  :                if ( node==NULL ) continue;

	test	eax, eax
	je	SHORT $LN1937@eval

; 361  :                sprintf(errmsg,"File %s, %s:%d\n",
; 362  :                   file_names[node->file_no],frame->base_ex.name,node->line_no);

	mov	edx, DWORD PTR [eax+12]
	push	edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _file_names
	lea	ecx, DWORD PTR [esi+28]
	push	ecx
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	push	OFFSET ??_C@_0BA@FJFLMGGP@File?5?$CFs?0?5?$CFs?3?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 363  :                outstring(errmsg);

	push	OFFSET _errmsg
	call	_outstring

; 364  :                frame = (struct eval_frame*)(newstack + frame->parent_frame_spot);

	mov	edx, DWORD PTR [esi+116]
	mov	eax, DWORD PTR [ebx+40]
	add	esp, 24					; 00000018H
	lea	esi, DWORD PTR [eax+edx*8]
$LN1937@eval:

; 357  :            { 
; 358  :              for ( i = eval_stack_trace_spot ; i >= 0 ; i-- )

	dec	edi
	jns	SHORT $LN1938@eval
$LN1936@eval:

; 365  :              }
; 366  :              outstring("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring
	add	esp, 4
$LN1939@eval:

; 367  :           }
; 368  :           frame = subshell_frame[subshell_depth];

	mov	ecx, DWORD PTR _subshell_depth
	mov	esi, DWORD PTR _subshell_frame[ecx*4]

; 369  :           while ( frame )

	test	esi, esi
	je	$LN1980@eval
	npad	7
$LL1934@eval:

; 370  :           { if ( frame->return_node )

	cmp	DWORD PTR [esi+120], 0
	je	SHORT $LN1932@eval

; 371  :                sprintf(msg,"   %s:%d\n",frame->base_ex.name,frame->return_node->line_no);

	mov	edx, DWORD PTR [esi+120]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _msg
	push	eax
	lea	ecx, DWORD PTR [esi+28]
	push	ecx
	push	OFFSET ??_C@_09PBNAGJKF@?5?5?5?$CFs?3?$CFd?6?$AA@
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 372  :             else

	jmp	SHORT $LN1931@eval
$LN1932@eval:

; 373  :                sprintf(msg,"   %s\n",frame->base_ex.name);

	mov	ecx, DWORD PTR _msg
	lea	eax, DWORD PTR [esi+28]
	push	eax
	push	OFFSET ??_C@_06FAPHFCKA@?5?5?5?$CFs?6?$AA@
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1931@eval:

; 374  :             outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 4

; 375  :             if ( frame->flags & BASE_OF_WHOLE_STACK )

	test	BYTE PTR [esi+124], 4
	jne	$LN1980@eval

; 376  :               frame = NULL;
; 377  :             else
; 378  :               frame = (struct eval_frame*)(newstack + frame->parent_frame_spot);

	mov	eax, DWORD PTR [esi+116]
	mov	ecx, DWORD PTR [ebx+40]
	lea	esi, DWORD PTR [ecx+eax*8]
	test	esi, esi
	jne	SHORT $LL1934@eval

; 379  :           };
; 380  :           break;

	jmp	$LN1980@eval
$LN1928@eval:

; 381  :         }
; 382  : 
; 383  :       case FREE_DISCARDS_NODE:
; 384  :         if ( (node->flags & IN_ELEMENT_LOOP) || 
; 385  :                  ( this_frame->flags & IN_ELEMENT_LOOP ) )

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, 2048				; 00000800H
	test	DWORD PTR [edx+24], eax
	jne	SHORT $LN1926@eval
	mov	ecx, DWORD PTR [ebx+52]
	mov	edx, DWORD PTR [ebx+40]
	test	DWORD PTR [edx+ecx*8+124], eax
	jne	SHORT $LN1926@eval

; 390  :         }
; 391  :         else
; 392  :           free_discards(DISCARDS_ALL); 

	push	1
	call	_free_discards
	add	esp, 4
	jmp	$LN1980@eval
$LN1926@eval:

; 386  :         { sprintf(errmsg,"free_discards called inside element loop. Ignored.\n");

	push	OFFSET ??_C@_0DE@ODNKLDLP@free_discards?5called?5inside?5elem@
	push	OFFSET _errmsg
	call	_sprintf

; 387  :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 388  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	esi, DWORD PTR [eax+1]
	npad	1
$LL2790@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2790@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 389  :           kb_error(1904,errmsg, WARNING);

	push	2
	push	OFFSET _errmsg
	push	1904					; 00000770H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 393  :         break;

	jmp	$LN1980@eval
$LN1924@eval:

; 394  : 
; 395  :       case SINGLE_LETTER_NODE:
; 396  :           if ( debugging_flag && node->op1.letter == 'n' )  /* special for debugging prompt */

	cmp	DWORD PTR _debugging_flag, 0
	je	SHORT $LN1923@eval
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+32], 110			; 0000006eH
	je	$LN2625@eval
$LN1923@eval:

; 399  :             goto the_exit;
; 400  :             break;
; 401  :           }
; 402  :           if ( !(node->flags & IN_ELEMENT_LOOP) &&
; 403  :                !(this_frame->flags & IN_ELEMENT_LOOP) )

	mov	ecx, DWORD PTR _node$[ebp]
	test	DWORD PTR [ecx+24], 2048		; 00000800H
	jne	SHORT $LN1922@eval
	mov	edx, DWORD PTR [ebx+52]
	mov	eax, DWORD PTR [ebx+40]
	test	DWORD PTR [eax+edx*8+124], 2048		; 00000800H
	jne	SHORT $LN1922@eval

; 404  :               free_discards(DISCARDS_SOME);

	push	2
	call	_free_discards
	add	esp, 4
$LN1922@eval:

; 405  :           letter_command(node->op1.letter);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_letter_command
	add	esp, 4

; 406  :           break;

	jmp	$LN1980@eval
$LN1921@eval:

; 407  : 
; 408  : 
; 409  :       case LINEAR_NODE:
; 410  :           if ( web.modeltype == QUADRATIC )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	SHORT $LN1920@eval

; 411  :           { outstring("Changing to LINEAR model. (was QUADRATIC)\n");

	push	OFFSET ??_C@_0CL@FEBBPANL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5Q@
	call	_outstring
	add	esp, 4

; 412  :             quad_to_linear();

	call	_quad_to_linear
	jmp	$LN1980@eval
$LN1920@eval:

; 413  :           }
; 414  :           else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	$LN1980@eval

; 415  :           { outstring("Changing to LINEAR model. (was LAGRANGE)\n");

	push	OFFSET ??_C@_0CK@JMIEKNGL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5L@
	call	_outstring
	add	esp, 4

; 416  :             lagrange_to_linear();

	call	_lagrange_to_linear

; 417  :           }
; 418  :           break;

	jmp	$LN1980@eval
$LN1917@eval:

; 419  : 
; 420  :       case QUADRATIC_NODE:
; 421  :           if ( !(node->flags & IN_ELEMENT_LOOP) &&
; 422  :                !(this_frame->flags & IN_ELEMENT_LOOP) )

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, 2048				; 00000800H
	test	DWORD PTR [ecx+24], eax
	jne	SHORT $LN1916@eval
	mov	edx, DWORD PTR [ebx+52]
	mov	ecx, DWORD PTR [ebx+40]
	test	DWORD PTR [ecx+edx*8+124], eax
	jne	SHORT $LN1916@eval

; 423  :               free_discards(DISCARDS_SOME);

	push	2
	call	_free_discards
	add	esp, 4
$LN1916@eval:

; 424  :           if ( web.modeltype == LINEAR )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	jne	SHORT $LN1915@eval

; 425  :           { outstring("Changing to QUADRATIC model. (was LINEAR)\n");

	push	OFFSET ??_C@_0CL@IKOBFHOD@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@
	call	_outstring
	add	esp, 4

; 426  :             linear_to_quad(); 

	call	_linear_to_quad
	jmp	$LN1980@eval
$LN1915@eval:

; 427  :           }
; 428  :           else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	$LN1980@eval

; 429  :           { outstring("Changing to QUADRATIC model. (was LAGRANGE)\n");

	push	OFFSET ??_C@_0CN@BFEEPGEG@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@
	call	_outstring
	add	esp, 4

; 430  :             lagrange_to_quad();

	call	_lagrange_to_quad

; 431  :           }
; 432  :           break;

	jmp	$LN1980@eval
$LN1912@eval:

; 433  : 
; 434  :       case LAGRANGE_NODE:
; 435  :           if ( !(node->flags & IN_ELEMENT_LOOP) &&
; 436  :                !(this_frame->flags & IN_ELEMENT_LOOP) )

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, 2048				; 00000800H
	test	DWORD PTR [edx+24], eax
	jne	SHORT $LN1911@eval
	mov	ecx, DWORD PTR [ebx+52]
	mov	edx, DWORD PTR [ebx+40]
	test	DWORD PTR [edx+ecx*8+124], eax
	jne	SHORT $LN1911@eval

; 437  :               free_discards(DISCARDS_SOME);

	push	2
	call	_free_discards
	add	esp, 4
$LN1911@eval:

; 438  :           if ( web.modeltype == LINEAR )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	jne	SHORT $LN1910@eval

; 439  :           { outstring("Changing to LAGRANGE model. (was LINEAR)\n");

	push	OFFSET ??_C@_0CK@JBOLHCFI@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@
	call	_outstring

; 440  :             linear_to_lagrange((int)(*stacktop--)); 

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	push	eax
	mov	DWORD PTR [ebx+48], esi
	call	_linear_to_lagrange
	add	esp, 8
	jmp	$LN1980@eval
$LN1910@eval:

; 441  :           }
; 442  :           else if ( web.modeltype == QUADRATIC )

	cmp	eax, 2
	jne	SHORT $LN1908@eval

; 443  :           { outstring("Changing to LAGRANGE model. (was QUADRATIC)\n");

	push	OFFSET ??_C@_0CN@NAGKEEOG@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@
	call	_outstring

; 444  :             quad_to_lagrange((int)(*stacktop--));

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	push	eax
	mov	DWORD PTR [ebx+48], esi
	call	_quad_to_lagrange
	add	esp, 8

; 445  :           }
; 446  :           else

	jmp	$LN1980@eval
$LN1908@eval:

; 447  :           { sprintf(msg,
; 448  :                        "Changing to LAGRANGE %d model. (was LAGRANGE %d)\n",
; 449  :                            (int)stacktop[0],web.lagrange_order);

	mov	eax, DWORD PTR _web+632
	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	push	eax
	call	__ftol2_sse
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0DC@KLMKCJCH@Changing?5to?5LAGRANGE?5?$CFd?5model?4?5?$CI@
	push	edx
	call	_sprintf

; 450  :             outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 451  :             lagrange_to_lagrange((int)(*stacktop--));

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	push	eax
	mov	DWORD PTR [ebx+48], esi
	call	_lagrange_to_lagrange
	add	esp, 24					; 00000018H

; 452  :           }
; 453  : 
; 454  :           break;

	jmp	$LN1980@eval
$LN1906@eval:

; 455  : 
; 456  :       case ELINDEX_NODE: /* id possibly with mpi task number */
; 457  :          /* creates typeless valid id */
; 458  :          {
; 459  :            if ( *stacktop == 0 )

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN1905@eval

; 460  :              id = NULLID;

	xor	eax, eax
	fstp	ST(0)

; 469  :            }
; 470  : #ifdef MPI_EVOLVER
; 471  :          { int task;
; 472  :            if ( node->right )
; 473  :               task = (int)(*stacktop--);
; 474  :            else task = this_task;
; 475  :            if ( task < 0 || task >= mpi_nprocs )
; 476  :            { sprintf(errmsg,
; 477  :                 "Illegal task number %d.  Must be between 1 and %d.\n",task,mpi_nprocs);
; 478  :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 479  :                  file_names[node->file_no],node->line_no);
; 480  :              kb_error(1915,errmsg,RECOVERABLE);
; 481  :            }
; 482  :            id |= (element_id)task << TASK_ID_SHIFT;
; 483  :          }
; 484  : #endif
; 485  :           
; 486  :            *(element_id *)stacktop = id;

	mov	DWORD PTR [ecx], eax

; 487  :            break;

	jmp	$LN1980@eval
$LN1905@eval:

; 461  :            else 
; 462  :            { if ( *stacktop > 0.0 )

	fcomp	QWORD PTR [ecx]
	fnstsw	ax

; 463  :              id = ((int)(*stacktop)-1);

	fld	QWORD PTR [ecx]
	test	ah, 5
	jp	SHORT $LN1903@eval
	fnstcw	WORD PTR tv29137[ebp]
	movzx	eax, WORD PTR tv29137[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv29133[ebp], eax
	fldcw	WORD PTR tv29133[ebp]
	fistp	QWORD PTR tv29131[ebp]
	mov	eax, DWORD PTR tv29131[ebp]
	dec	eax

; 467  :              }
; 468  :              id |= VALIDMASK;

	or	eax, 268435456				; 10000000H

; 469  :            }
; 470  : #ifdef MPI_EVOLVER
; 471  :          { int task;
; 472  :            if ( node->right )
; 473  :               task = (int)(*stacktop--);
; 474  :            else task = this_task;
; 475  :            if ( task < 0 || task >= mpi_nprocs )
; 476  :            { sprintf(errmsg,
; 477  :                 "Illegal task number %d.  Must be between 1 and %d.\n",task,mpi_nprocs);
; 478  :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 479  :                  file_names[node->file_no],node->line_no);
; 480  :              kb_error(1915,errmsg,RECOVERABLE);
; 481  :            }
; 482  :            id |= (element_id)task << TASK_ID_SHIFT;
; 483  :          }
; 484  : #endif
; 485  :           
; 486  :            *(element_id *)stacktop = id;

	mov	DWORD PTR [ecx], eax
	fldcw	WORD PTR tv29137[ebp]

; 487  :            break;

	jmp	$LN1980@eval
$LN1903@eval:

; 464  :              else 
; 465  :              { id = -((int)(*stacktop)+1);         
; 466  :                invert(id); 

	fnstcw	WORD PTR tv29127[ebp]
	movzx	eax, WORD PTR tv29127[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv29124[ebp], eax
	or	eax, -1
	fldcw	WORD PTR tv29124[ebp]
	fistp	QWORD PTR tv29122[ebp]
	mov	edx, DWORD PTR tv29122[ebp]
	sub	eax, edx
	xor	eax, 134217728				; 08000000H

; 467  :              }
; 468  :              id |= VALIDMASK;

	or	eax, 268435456				; 10000000H
	fldcw	WORD PTR tv29127[ebp]

; 469  :            }
; 470  : #ifdef MPI_EVOLVER
; 471  :          { int task;
; 472  :            if ( node->right )
; 473  :               task = (int)(*stacktop--);
; 474  :            else task = this_task;
; 475  :            if ( task < 0 || task >= mpi_nprocs )
; 476  :            { sprintf(errmsg,
; 477  :                 "Illegal task number %d.  Must be between 1 and %d.\n",task,mpi_nprocs);
; 478  :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 479  :                  file_names[node->file_no],node->line_no);
; 480  :              kb_error(1915,errmsg,RECOVERABLE);
; 481  :            }
; 482  :            id |= (element_id)task << TASK_ID_SHIFT;
; 483  :          }
; 484  : #endif
; 485  :           
; 486  :            *(element_id *)stacktop = id;

	mov	DWORD PTR [ecx], eax

; 487  :            break;

	jmp	$LN1980@eval
$LN1901@eval:

; 488  :          }
; 489  :  
; 490  :       case PUSH_ELEMENT_ID_NODE:
; 491  :          *(element_id *)(++stacktop) = node->op1.id;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax], edx

; 492  :          break;

	jmp	$LN1980@eval
$LN1900@eval:

; 493  : 
; 494  :       case VALID_ELEMENT_NODE:
; 495  :          id = get_full_id(node->op1.eltype,*(element_id*)stacktop);

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	ecx
	push	eax
	call	_get_full_id

; 496  :          *stacktop = valid_element(id) ? 1.0 : 0.0; 

	push	eax
	call	_valid_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2023@eval
	fld1
	mov	ecx, DWORD PTR [ebx+48]
	fstp	QWORD PTR [ecx]

; 497  :          break;

	jmp	$LN1980@eval
$LN2023@eval:

; 496  :          *stacktop = valid_element(id) ? 1.0 : 0.0; 

	fldz
	mov	ecx, DWORD PTR [ebx+48]
	fstp	QWORD PTR [ecx]

; 497  :          break;

	jmp	$LN1980@eval
$LN1899@eval:

; 498  :  
; 499  :       case VALID_CONSTRAINT_NODE:
; 500  :          { int connum = (int)*stacktop;

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 501  :            if ( (connum<0) || (connum>=web.maxcon) || !(get_constraint(connum)->attr & IN_USE))

	test	eax, eax
	js	$LN1897@eval
	cmp	eax, DWORD PTR _web+644
	jge	$LN1897@eval
	mov	edx, DWORD PTR _web+652
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	mov	eax, DWORD PTR [eax+edx+32]
$LN4013@eval:
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN1897@eval

; 502  :               *stacktop = 0.0;
; 503  :            else 
; 504  :               *stacktop = 1.0;

	fld1
$LN4014@eval:
	fstp	QWORD PTR [esi]
	jmp	$LN1980@eval
$LN1895@eval:

; 505  :            break;
; 506  :          }
; 507  :  
; 508  :       case VALID_BOUNDARY_NODE:
; 509  :          { int bnum = (int)*stacktop;

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 510  :            if ( (bnum<0) || (bnum>=web.bdrymax) || !(web.boundaries[bnum].attr & IN_USE))

	test	eax, eax
	js	$LN1897@eval
	cmp	eax, DWORD PTR _web+768
	jge	$LN1897@eval
	mov	ecx, DWORD PTR _web+776
	imul	eax, 136				; 00000088H
	mov	eax, DWORD PTR [eax+ecx+32]

; 511  :               *stacktop = 0.0;
; 512  :            else 
; 513  :               *stacktop = 1.0;

	jmp	SHORT $LN4013@eval
$LN1891@eval:

; 514  :            break;
; 515  :          }
; 516  : 
; 517  :       case LOAD_NODE:
; 518  :          if ( subshell_depth )

	cmp	DWORD PTR _subshell_depth, 0
	je	$LN1890@eval

; 519  :          { sprintf(errmsg,"Can't reload in a subcommand.\n");

	push	OFFSET ??_C@_0BP@KDKEJCJM@Can?8t?5reload?5in?5a?5subcommand?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 520  :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 521  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	esi, DWORD PTR [eax+1]
	npad	7
$LL2791@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2791@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 522  :            kb_error(3634,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	3634					; 00000e32H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 523  :            stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H

; 524  :            break;

	jmp	$LN1980@eval
$LN1889@eval:

; 531  : #endif
; 532  :          break;
; 533  : 
; 534  :       case ADDLOAD_NODE:
; 535  :         { FILE *newfd;
; 536  :           int old_read_depth;
; 537  :           char *name = *(char**)(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	mov	esi, DWORD PTR [eax]
	add	eax, -8					; fffffff8H

; 538  :           newfd = path_open(name,NOTDATAFILENAME);

	push	0
	push	esi
	mov	DWORD PTR [ebx+48], eax
	call	_path_open
	mov	edi, eax
	add	esp, 8

; 539  :           if (newfd == NULL)

	test	edi, edi
	jne	SHORT $LN1888@eval

; 540  :           { if ( name[0] )

	cmp	BYTE PTR [esi], al
	je	$LN1980@eval

; 541  :             {
; 542  :               sprintf(errmsg,"Cannot open datafile %s.\n",name);

	push	esi
	push	OFFSET ??_C@_0BK@OMAPGNOH@Cannot?5open?5datafile?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 543  :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 544  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
	npad	3
$LL2792@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2792@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 545  :               kb_error(5431,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5431					; 00001537H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 546  :             }
; 547  :             break; /* continue with old */

	jmp	$LN1980@eval
$LN1888@eval:

; 548  :           }
; 549  : 
; 550  : 
; 551  :           ENTER_GRAPH_MUTEX;

	call	DWORD PTR __imp__GetCurrentThreadId@0
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN1886@eval
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89651[ebp], 1
	jmp	SHORT $LN1885@eval
$LN1886@eval:
	mov	DWORD PTR _did_graphlock_here$89651[ebp], 0
$LN1885@eval:

; 552  : 
; 553  :           push_commandfd(newfd,name); /* start #include stack */

	push	esi
	push	edi
	call	_push_commandfd

; 554  :           datafile_flag = 1;  /* so parser knows */
; 555  :           addload_flag = 1;
; 556  :           datafile_input_flag = 1;  /* so lex input knows */
; 557  :           cmdptr = 0;
; 558  :           old_read_depth = read_depth;

	mov	esi, DWORD PTR _read_depth
	mov	eax, 1
	add	esp, 8
	mov	DWORD PTR _datafile_flag, eax
	mov	DWORD PTR _addload_flag, eax
	mov	DWORD PTR _datafile_input_flag, eax
	mov	DWORD PTR _cmdptr, 0

; 559  :           initialize();

	call	_initialize

; 560  :           if ( read_depth >= old_read_depth )

	cmp	DWORD PTR _read_depth, esi
	jl	SHORT $LN1884@eval

; 561  :             pop_commandfd();

	call	_pop_commandfd
$LN1884@eval:

; 562  :           datafile_flag = 0;
; 563  :           addload_flag = 0;
; 564  :           if ( fabs(view[0][0])+fabs(view[1][1])+fabs(view[2][2]) < 1e-25 )

	mov	eax, DWORD PTR _view
	xor	esi, esi
	mov	DWORD PTR _datafile_flag, esi
	mov	DWORD PTR _addload_flag, esi
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	fld	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+8]
	fabs
	fld	QWORD PTR [edx]
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax+16]
	fabs
	faddp	ST(1), ST(0)
	fcomp	QWORD PTR __real@3abef2d0f5da7dd9
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1883@eval

; 565  :             resize();

	call	_resize
$LN1883@eval:

; 566  :   
; 567  :           LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89651[ebp], esi
$LN4016@eval:
	je	SHORT $LN1882@eval
	mov	ecx, DWORD PTR _graphmutex
	push	ecx
	mov	DWORD PTR _locking_thread, esi
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1882@eval:

; 568  :           recalc();

	call	_recalc

; 569  :           break;

	jmp	$LN1980@eval
$LN1881@eval:

; 570  :        }
; 571  : 
; 572  :       case REPLACE_LOAD_NODE:
; 573  :         { FILE *newfd;
; 574  :           int old_read_depth;
; 575  :           char *name = *(char**)(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	mov	esi, DWORD PTR [eax]
	add	eax, -8					; fffffff8H

; 576  : 
; 577  :           newfd = path_open(name,NOTDATAFILENAME);

	push	0
	push	esi
	mov	DWORD PTR [ebx+48], eax
	call	_path_open
	mov	edi, eax
	add	esp, 8

; 578  :           if (newfd == NULL)

	test	edi, edi
	jne	SHORT $LN1880@eval

; 579  :           { if ( name[0] )

	cmp	BYTE PTR [esi], al
	je	$LN1980@eval

; 580  :             {
; 581  :               sprintf(errmsg,"Cannot open datafile %s.\n",name);

	push	esi
	push	OFFSET ??_C@_0BK@OMAPGNOH@Cannot?5open?5datafile?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 582  :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 583  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
$LL2793@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2793@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 584  :               kb_error(5432,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5432					; 00001538H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 585  :             }
; 586  :             break; /* continue with old */

	jmp	$LN1980@eval
$LN1880@eval:

; 587  :           }
; 588  : 
; 589  : 
; 590  :           ENTER_GRAPH_MUTEX;

	call	DWORD PTR __imp__GetCurrentThreadId@0
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN1878@eval
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89665[ebp], 1
	jmp	SHORT $LN1877@eval
$LN1878@eval:
	mov	DWORD PTR _did_graphlock_here$89665[ebp], 0
$LN1877@eval:

; 591  : 
; 592  :           free_element_lists();

	call	_free_element_lists

; 593  : #ifdef HHHH
; 594  :         { body_id b_id;
; 595  :           facet_id f_id;
; 596  :           edge_id e_id;
; 597  :           vertex_id v_id;
; 598  : 
; 599  :           // Dissolve current surface
; 600  :           FOR_ALL_BODIES(b_id) dissolve_body(b_id);
; 601  :           FOR_ALL_FACETS(f_id) dissolve_facet(f_id);
; 602  :           FOR_ALL_EDGES(e_id)  dissolve_edge(e_id);
; 603  :           FOR_ALL_VERTICES(v_id) dissolve_vertex(v_id);
; 604  :           free_discards(DISCARDS_ALL);
; 605  :         }
; 606  : #endif
; 607  :           // Now proceed as in addload
; 608  : 
; 609  :           push_commandfd(newfd,name); /* start #include stack */

	push	esi
	push	edi
	call	_push_commandfd

; 610  :           datafile_flag = 1;  /* so parser knows */
; 611  :           addload_flag = 1;
; 612  :           replace_load_flag = 1;
; 613  :           datafile_input_flag = 1;  /* so lex input knows */
; 614  :           cmdptr = 0;
; 615  :           old_read_depth = read_depth;

	mov	esi, DWORD PTR _read_depth
	mov	eax, 1
	add	esp, 8
	mov	DWORD PTR _datafile_flag, eax
	mov	DWORD PTR _addload_flag, eax
	mov	DWORD PTR _replace_load_flag, eax
	mov	DWORD PTR _datafile_input_flag, eax
	mov	DWORD PTR _cmdptr, 0

; 616  :           initialize();

	call	_initialize

; 617  :           if ( read_depth >= old_read_depth )

	cmp	DWORD PTR _read_depth, esi
	jl	SHORT $LN1876@eval

; 618  :             pop_commandfd();

	call	_pop_commandfd
$LN1876@eval:

; 619  :           datafile_flag = 0;
; 620  :           addload_flag = 0;
; 621  :           replace_load_flag = 0;
; 622  :           if ( fabs(view[0][0])+fabs(view[1][1])+fabs(view[2][2]) < 1e-25 )

	mov	eax, DWORD PTR _view
	xor	esi, esi
	mov	DWORD PTR _datafile_flag, esi
	mov	DWORD PTR _addload_flag, esi
	mov	DWORD PTR _replace_load_flag, esi
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	fld	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+8]
	fabs
	fld	QWORD PTR [edx]
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax+16]
	fabs
	faddp	ST(1), ST(0)
	fcomp	QWORD PTR __real@3abef2d0f5da7dd9
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1875@eval

; 623  :             resize();

	call	_resize
$LN1875@eval:

; 624  :   
; 625  :           LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89665[ebp], esi

; 626  :           recalc();
; 627  :           break;

	jmp	$LN4016@eval
$LN1873@eval:

; 628  :        }
; 629  : 
; 630  :       case PERMLOAD_NODE:  /* keep going with same command */
; 631  :              /* with contortions to preserve current list */
; 632  :        { struct expnode keeplist;
; 633  :          struct eval_frame *fr;
; 634  :          size_t spot;
; 635  :          if ( subshell_depth )

	cmp	DWORD PTR _subshell_depth, 0
	je	SHORT $LN1872@eval

; 636  :          { sprintf(errmsg,"Can't reload in a subcommand.\n");

	push	OFFSET ??_C@_0BP@KDKEJCJM@Can?8t?5reload?5in?5a?5subcommand?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 637  :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 638  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	esi, DWORD PTR [eax+1]
	npad	2
$LL2794@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2794@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 639  :            kb_error(3635,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	3635					; 00000e33H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 640  :            stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H

; 641  :            break;

	jmp	$LN1980@eval
$LN1872@eval:

; 642  : 
; 643  :          }
; 644  : 
; 645  :          /* make sure all parent frames permanent (except very first frame
; 646  :             corresponding to original user command */
; 647  :          for ( fr = this_frame; fr != NULL ; 
; 648  :             fr = (struct eval_frame*)(newstack + fr->parent_frame_spot) )

	mov	eax, DWORD PTR [ebx+52]
	mov	ecx, DWORD PTR [ebx+40]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _fr$89673[ebp], eax
	test	eax, eax
	je	$LN2610@eval
$LL1871@eval:

; 649  :          { if ( !(fr->flags & BASE_OF_WHOLE_STACK) && !(fr->base_ex.start->flags & PERMNODE) )

	test	BYTE PTR [eax+124], 4
	jne	$LN2610@eval
	mov	edx, DWORD PTR [eax+8]
	test	BYTE PTR [edx+24], -128			; ffffff80H
	jne	SHORT $LN1868@eval

; 650  :            { strcpy(errmsg, "Calling permload in non-permanent command.\n");

	mov	ecx, 11					; 0000000bH
	mov	esi, OFFSET ??_C@_0CM@NLOJJBMG@Calling?5permload?5in?5non?9permanen@
	mov	edi, OFFSET _errmsg

; 651  :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 652  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	rep movsd
	lea	edx, DWORD PTR [eax+1]
$LL2795@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2795@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 653  :              kb_error(3364,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3364					; 00000d24H
	call	_kb_error
	mov	eax, DWORD PTR _fr$89673[ebp]
	add	esp, 28					; 0000001cH
$LN1868@eval:

; 654  :            }
; 655  :            if ( fr->flags & BASE_OF_WHOLE_STACK ) break; 

	test	BYTE PTR [eax+124], 4
	jne	SHORT $LN2610@eval

; 642  : 
; 643  :          }
; 644  : 
; 645  :          /* make sure all parent frames permanent (except very first frame
; 646  :             corresponding to original user command */
; 647  :          for ( fr = this_frame; fr != NULL ; 
; 648  :             fr = (struct eval_frame*)(newstack + fr->parent_frame_spot) )

	mov	eax, DWORD PTR [eax+116]
	mov	ecx, DWORD PTR [ebx+40]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _fr$89673[ebp], eax
	test	eax, eax
	jne	$LL1871@eval
$LN2610@eval:

; 656  :          }
; 657  :          if ( !(fr->base_ex.start->flags & PERMNODE) )

	mov	edx, DWORD PTR [eax+8]
	test	BYTE PTR [edx+24], -128			; ffffff80H
	lea	edi, DWORD PTR [eax+8]
	jne	SHORT $LN1866@eval

; 658  :          { /* have to kludge to preserve current command list */
; 659  :            memset(&keeplist,0,sizeof(keeplist));

	push	104					; 00000068H
	lea	eax, DWORD PTR _keeplist$89672[ebp]
	push	0
	push	eax
	call	_memset

; 660  :            perm_tree_copy(&keeplist,fr->base_ex.root);

	mov	esi, DWORD PTR _fr$89673[ebp]
	mov	ecx, DWORD PTR [esi+12]
	push	ecx
	lea	edx, DWORD PTR _keeplist$89672[ebp]
	push	edx
	call	_perm_tree_copy

; 661  :            spot = (*(fr->basenode) - (fr->base_ex.start));

	mov	esi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR [edi]
	mov	eax, 818089009				; 30c30c31H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 662  :            *(fr->basenode) = keeplist.start + spot; 

	imul	eax, 168				; 000000a8H
	add	eax, DWORD PTR _keeplist$89672[ebp]

; 663  :            memset(&(fr->base_ex),0,sizeof(struct expnode)); /* so doesn't do free_expr()later */        

	push	104					; 00000068H
	push	0
	push	edi
	mov	DWORD PTR [esi], eax
	call	_memset

; 664  :            fr->base_ex = keeplist;

	mov	ecx, 26					; 0000001aH
	lea	esi, DWORD PTR _keeplist$89672[ebp]
	add	esp, 32					; 00000020H
	rep movsd
$LN1866@eval:

; 665  :          }
; 666  :          strncpy(loadfilename,*(char**)(stacktop--),sizeof(loadfilename));

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	push	1000					; 000003e8H
	push	ecx
	add	eax, -8					; fffffff8H
	push	OFFSET _loadfilename
	mov	DWORD PTR [ebx+48], eax
	call	_strncpy

; 667  :          startup(loadfilename);

	push	OFFSET _loadfilename
	call	_startup

; 668  :          exec_commands(commandfd,"Enter command: "); /* from end of datafile */

	mov	eax, DWORD PTR _commandfd
	push	OFFSET ??_C@_0BA@LDMPFPFF@Enter?5command?3?5?$AA@
	push	eax
	call	_exec_commands
	add	esp, 24					; 00000018H

; 669  :          /* keeplist permanently allocated, but we'll live with memory leak
; 670  :             as price for not doing shenanigans every eval() just to avoid leak. */
; 671  :        }
; 672  :        break;

	jmp	$LN1980@eval
$LN1865@eval:

; 673  : 
; 674  :       case FUNCTION_CALL_NODE:
; 675  :         { struct global *g = globals(node->op1.name_id);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN2025@eval
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2027@eval
	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	mov	edi, eax
	jmp	SHORT $LN2026@eval
$LN2027@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2025@eval
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN2026@eval
$LN2025@eval:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [eax+ecx]
$LN2026@eval:

; 676  : 
; 677  :           if ( g->value.proc.root == NULL )

	cmp	DWORD PTR [edi+68], 0
	jne	SHORT $LN1864@eval

; 678  :           { sprintf(errmsg,
; 679  :             "Function \"%s\" definition has not been executed yet.\n",g->name);

	push	edi
	push	OFFSET ??_C@_0DF@HMCCGFBA@Function?5?$CC?$CFs?$CC?5definition?5has?5not@
	push	OFFSET _errmsg
	call	_sprintf

; 680  :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 681  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
	npad	1
$LL2796@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2796@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 682  :             kb_error(2621,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2621					; 00000a3dH
$LN3997@eval:
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1864@eval:

; 683  :           }
; 684  :           
; 685  :           ex_current = g->value.proc;
; 686  :           
; 687  :           PROF_EVAL_PUSH_AND_SWITCH(&g->value.proc);
; 688  :           PUSH_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	lea	edx, DWORD PTR [edi+64]
	mov	ecx, 26					; 0000001aH
	mov	esi, edx
	lea	edi, DWORD PTR _ex_current$[ebp]
	rep movsd
	cmp	eax, 100				; 00000064H
	jl	SHORT $LN1863@eval
	xor	eax, eax
$LN1863@eval:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _eval_stack_trace[eax*4], ecx
	inc	eax
	mov	DWORD PTR _eval_stack_trace_spot, eax

; 689  :           return_node = node;
; 690  :           node = g->value.proc.start;

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _return_node$[ebp], ecx
	mov	DWORD PTR _node$[ebp], eax

; 691  :           break;

	jmp	$LN1980@eval
$LN1862@eval:

; 692  :         }
; 693  :         
; 694  :       case FUNCTION_CALL_RETURN_NODE:
; 695  :         { PROF_EVAL_POP;
; 696  :           stacktop -= node->op2.argcount; /* pop arguments */

	mov	ecx, DWORD PTR _node$[ebp]

; 697  :           *(++stacktop) = return_value;

	fld	QWORD PTR _return_value$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	mov	eax, 8
	sub	eax, edx
	add	DWORD PTR [ebx+48], eax
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
$LN3999@eval:

; 698  :           POP_TRACE;

	cmp	DWORD PTR _eval_stack_trace_spot, 0
	jle	$LN1980@eval
	mov	eax, DWORD PTR _eval_stack_trace_spot
$LN4000@eval:
	mov	DWORD PTR _eval_stack_trace[eax*4], 0
	dec	eax
	mov	DWORD PTR _eval_stack_trace_spot, eax

; 699  :           break;

	jmp	$LN1980@eval
$LN1860@eval:

; 700  :         }
; 701  : 
; 702  :       case PROCEDURE_CALL_NODE: /* with arguments */
; 703  :         { struct global *g = globals(node->op1.name_id);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN2031@eval
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2033@eval
	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	mov	edi, eax
	jmp	SHORT $LN2032@eval
$LN2033@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2031@eval
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN2032@eval
$LN2031@eval:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [eax+ecx]
$LN2032@eval:

; 704  :           if ( g->value.proc.root == NULL )

	cmp	DWORD PTR [edi+68], 0
	jne	$LN1864@eval

; 705  :           { sprintf(errmsg,
; 706  :             "Procedure \"%s\" definition has not been executed yet.\n",g->name);

	push	edi
	push	OFFSET ??_C@_0DG@HCIHCCDE@Procedure?5?$CC?$CFs?$CC?5definition?5has?5no@
	push	OFFSET _errmsg
	call	_sprintf

; 707  :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 708  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
$LL2797@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2797@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 709  :             kb_error(2622,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2622					; 00000a3eH

; 710  :           }
; 711  : 
; 712  :           ex_current = g->value.proc;
; 713  :                     
; 714  :           PROF_EVAL_PUSH_AND_SWITCH(&g->value.proc);
; 715  :           PUSH_TRACE;
; 716  :           return_node = node;
; 717  :           node = g->value.proc.start;             
; 718  :           break;

	jmp	$LN3997@eval
$LN1857@eval:

; 719  :         }
; 720  :         
; 721  :       case PROCEDURE_CALL_RETURN_NODE:    
; 722  :           PROF_EVAL_POP;
; 723  :           stacktop -= node->op2.argcount; /* pop arguments */

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	neg	edx
	add	edx, edx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [ebx+48], edx

; 724  :           POP_TRACE;
; 725  :           break;

	jmp	$LN3999@eval
$LN1855@eval:

; 726  :         
; 727  : 
; 728  :       case PROCEDURE_NODE:
; 729  :         { struct global *g = globals(node->op1.name_id);

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN2037@eval
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2039@eval
	mov	ecx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN2038@eval
$LN2039@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2037@eval
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN2038@eval
$LN2037@eval:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN2038@eval:

; 730  :           PROF_EVAL_END(ex_profiling);
; 731  :           PUSH_TRACE;

	cmp	DWORD PTR _eval_stack_trace_spot, 100	; 00000064H
	jl	SHORT $LN1854@eval
	mov	DWORD PTR _eval_stack_trace_spot, 0
$LN1854@eval:
	mov	ecx, DWORD PTR _eval_stack_trace_spot
	mov	edx, DWORD PTR _node$[ebp]

; 732  :           eval(&(g->value.proc),NULL,NULLID,NULL);

	push	0
	push	0
	mov	DWORD PTR _eval_stack_trace[ecx*4], edx
	add	eax, 64					; 00000040H
	inc	ecx
	push	0
	push	eax
	mov	DWORD PTR _eval_stack_trace_spot, ecx
	call	_eval
	fstp	ST(0)

; 733  :           PROF_EVAL_START(ex_profiling);
; 734  :           POP_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	add	esp, 16					; 00000010H
	test	eax, eax
	jle	$LN1980@eval

; 735  :           break;

	jmp	$LN4000@eval
$LN1852@eval:

; 736  :         }
; 737  : 
; 738  :       case PERM_PROCEDURE_NODE:
; 739  :         { struct expnode *newex;
; 740  :           struct global *g = perm_globals(node->op1.name_id);         

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]

; 741  :           PROF_EVAL_END(ex_profiling);
; 742  :           newex = &(g->value.proc);
; 743  :           newex->start->flags |= PERMNODE;

	mov	eax, DWORD PTR [ecx+64]
	or	DWORD PTR [eax+24], 128			; 00000080H

; 744  :           PUSH_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	add	ecx, 64					; 00000040H
	cmp	eax, 100				; 00000064H
	jl	SHORT $LN1851@eval
	xor	eax, eax
$LN1851@eval:
	mov	edx, DWORD PTR _node$[ebp]

; 745  :           eval(newex,NULL,NULLID,NULL);

	push	0
	push	0
	mov	DWORD PTR _eval_stack_trace[eax*4], edx
	inc	eax
	push	0
	push	ecx
	mov	DWORD PTR _eval_stack_trace_spot, eax
	call	_eval
	fstp	ST(0)
	add	esp, 16					; 00000010H

; 746  :           POP_TRACE;
; 747  :           PROF_EVAL_START(ex_profiling);
; 748  :           break;

	jmp	$LN3999@eval
$LN1846@eval:

; 749  :         }
; 750  : 
; 751  :       case CMDLIST_NODE: case COMMAND_BLOCK_NODE:
; 752  :           /* no action, just holds tree together */
; 753  :           break;
; 754  :    
; 755  :       case DECLARE_LOCAL_NODE: break;
; 756  :       case LOCAL_LIST_START_NODE: break;
; 757  :     
; 758  :       case SINGLE_REDEFD_NODE:
; 759  :           if ( single_redefine[node->op1.letter].start )

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	ecx, eax
	imul	ecx, 104				; 00000068H
	cmp	DWORD PTR _single_redefine[ecx], 0
	je	SHORT $LN1845@eval

; 760  :           {
; 761  :             PROF_EVAL_END(ex_profiling);
; 762  :             PUSH_TRACE;

	cmp	DWORD PTR _eval_stack_trace_spot, 100	; 00000064H
	jl	SHORT $LN1844@eval
	mov	DWORD PTR _eval_stack_trace_spot, 0
$LN1844@eval:
	mov	ecx, DWORD PTR _eval_stack_trace_spot
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _eval_stack_trace[ecx*4], eax
	inc	ecx
	mov	DWORD PTR _eval_stack_trace_spot, ecx

; 763  :             eval(&single_redefine[node->op1.letter],NULL,NULLID,NULL);

	mov	edx, DWORD PTR [eax+32]
	imul	edx, 104				; 00000068H
	push	0
	push	0
	add	edx, OFFSET _single_redefine
	push	0
	push	edx
	call	_eval
	add	esp, 16					; 00000010H
	fstp	ST(0)

; 764  :             POP_TRACE;
; 765  :             PROF_EVAL_START(ex_profiling);
; 766  :           }
; 767  :           else letter_command(node->op1.letter);

	jmp	$LN3999@eval
$LN1845@eval:
	push	eax
	call	_letter_command
	add	esp, 4

; 768  :           break;

	jmp	$LN1980@eval
$LN1841@eval:

; 769  : 
; 770  : 
; 771  :       case MATRIX_INVERSE_NODE: 
; 772  :         { REAL *datastart2 = *(REAL**)(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	mov	edi, DWORD PTR [eax]

; 773  :           REAL *datastart1 = *(REAL**)(stacktop--);
; 774  :           struct array *a = get_name_arrayptr(node->op1.name_id,newstack+localstack,localbase);

	mov	esi, DWORD PTR _localstack$[ebp]
	mov	edx, DWORD PTR _localbase$[ebp]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	mov	eax, DWORD PTR [ebx+40]
	add	esi, esi
	add	esi, esi
	push	edx
	mov	DWORD PTR _datastart1$89742[ebp], ecx
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	add	esi, esi
	add	eax, esi
	push	eax
	push	edx
	call	_get_name_arrayptr

; 775  :           struct array *b = get_name_arrayptr(node->op2.name_id,newstack+localstack,localbase);

	mov	ecx, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _a$89744[ebp], eax
	mov	eax, DWORD PTR _localbase$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+136]
	add	ecx, esi
	push	ecx
	push	eax
	call	_get_name_arrayptr

; 776  :  
; 777  :            *(++stacktop) = (REAL)matrix_inverse_command(a,
; 778  :                  b,datastart1,datastart2);

	mov	ecx, DWORD PTR _datastart1$89742[ebp]
	mov	edx, DWORD PTR _a$89744[ebp]
	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	edi
	push	ecx
	push	eax
	push	edx
	call	_matrix_inverse_command
	mov	DWORD PTR tv28924[ebp], eax
	fild	DWORD PTR tv28924[ebp]
	add	esp, 40					; 00000028H
	fstp	QWORD PTR [esi]

; 779  :         }
; 780  :            break;

	jmp	$LN1980@eval
$LN1840@eval:

; 781  : 
; 782  :       case MATRIX_MULTIPLY_NODE: 
; 783  :         { REAL *datastart3 = *(REAL**)(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	mov	edi, DWORD PTR [eax]

; 784  :           REAL *datastart2 = *(REAL**)(stacktop--);  
; 785  :           REAL *datastart1 = *(REAL**)(stacktop--); 
; 786  :           struct array *a = get_name_arrayptr(node->op1.name_id,newstack+localstack,localbase);

	mov	esi, DWORD PTR _localstack$[ebp]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	mov	edx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	mov	eax, DWORD PTR _localbase$[ebp]
	add	esi, esi
	mov	DWORD PTR _datastart2$89750[ebp], ecx
	mov	ecx, DWORD PTR [ebx+40]
	add	esi, esi
	push	eax
	mov	DWORD PTR _datastart1$89752[ebp], edx
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	add	esi, esi
	add	ecx, esi
	push	ecx
	push	eax
	call	_get_name_arrayptr

; 787  :           struct array *b = get_name_arrayptr(node->op2.name_id,newstack+localstack,localbase);

	mov	ecx, DWORD PTR _localbase$[ebp]
	mov	edx, DWORD PTR [ebx+40]
	push	ecx
	mov	DWORD PTR _a$89754[ebp], eax
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	add	edx, esi
	push	edx
	push	ecx
	call	_get_name_arrayptr

; 788  :           struct array *c = get_name_arrayptr(node->op3.name_id,newstack+localstack,localbase);

	mov	edx, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _b$89755[ebp], eax
	mov	eax, DWORD PTR [ebx+40]
	push	edx
	mov	edx, DWORD PTR [ecx+140]
	add	eax, esi
	push	eax
	push	edx
	call	_get_name_arrayptr

; 789  :           matrix_multiply_command(a,b,c,datastart1,datastart2,datastart3);

	mov	ecx, DWORD PTR _datastart2$89750[ebp]
	mov	edx, DWORD PTR _datastart1$89752[ebp]
	push	edi
	push	ecx
	mov	ecx, DWORD PTR _a$89754[ebp]
	push	edx
	push	eax
	mov	eax, DWORD PTR _b$89755[ebp]
	push	eax
	push	ecx
	call	_matrix_multiply_command
	add	esp, 60					; 0000003cH

; 790  :         }
; 791  :         break;

	jmp	$LN1980@eval
$LN1839@eval:

; 792  : 
; 793  :       case MATRIX_DETERMINANT_NODE:
; 794  :         { REAL *datastart1 = *(REAL**)(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	mov	esi, DWORD PTR [eax]

; 795  :           struct array *a = get_name_arrayptr(node->op1.name_id,newstack+localstack,localbase);

	mov	edx, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR _localstack$[ebp]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	mov	eax, DWORD PTR [ebx+40]
	push	edx
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	edx
	push	ecx
	call	_get_name_arrayptr

; 796  :           *(++stacktop) = matrix_determinant_command(a,datastart1);

	add	DWORD PTR [ebx+48], 8
	mov	edi, DWORD PTR [ebx+48]
	push	esi
	push	eax
	call	_matrix_determinant_command
	fstp	QWORD PTR [edi]
	add	esp, 20					; 00000014H

; 797  :         }
; 798  :         break;

	jmp	$LN1980@eval
$LN1838@eval:

; 799  : 
; 800  :       case BACKQUOTE_START_NODE:
; 801  :         { struct expnode bqnode = ex_current;
; 802  :           bqnode.start = node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, 26					; 0000001aH
	lea	esi, DWORD PTR _ex_current$[ebp]
	lea	edi, DWORD PTR _bqnode$89762[ebp]
	rep movsd
	mov	DWORD PTR _bqnode$89762[ebp], eax

; 803  :           bqnode.root = node+node->op1.skipsize;

	mov	edx, DWORD PTR [eax+32]
	imul	edx, 168				; 000000a8H
	add	edx, eax

; 804  :           bqnode.locals = localbase;
; 805  : 
; 806  :           PROF_EVAL_END(ex_profiling);
; 807  :           PUSH_TRACE;

	cmp	DWORD PTR _eval_stack_trace_spot, 100	; 00000064H
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	DWORD PTR _bqnode$89762[ebp+4], edx
	mov	DWORD PTR _bqnode$89762[ebp+8], eax
	jl	SHORT $LN1837@eval
	mov	DWORD PTR _eval_stack_trace_spot, 0
$LN1837@eval:
	mov	eax, DWORD PTR _eval_stack_trace_spot
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _eval_stack_trace[eax*4], ecx
	inc	eax
	mov	DWORD PTR _eval_stack_trace_spot, eax

; 808  :           eval(&bqnode,params,self_id,this_frame);

	mov	edx, DWORD PTR [ebx+52]
	mov	eax, DWORD PTR [ebx+40]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _self_id$GSCopy$[ebp]
	mov	eax, DWORD PTR _params$GSCopy$[ebp]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _bqnode$89762[ebp]
	push	ecx
	call	_eval
	fstp	ST(0)

; 809  :           POP_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	add	esp, 16					; 00000010H
	test	eax, eax
	jle	SHORT $LN1836@eval
	mov	DWORD PTR _eval_stack_trace[eax*4], 0
	dec	eax
	mov	DWORD PTR _eval_stack_trace_spot, eax
$LN1836@eval:

; 810  :           PROF_EVAL_START(ex_profiling);
; 811  :           node += node->op1.skipsize; /* skip what was evaluated */

	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+32]
	imul	edx, 168				; 000000a8H
	add	eax, edx
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN1830@eval:

; 812  :         }
; 813  :         break;
; 814  :       case BACKQUOTE_END_NODE: break;  /* just a placeholder */
; 815  :       case ACOMMANDEXPR_NODE: /* backquoted command at start of expression */
; 816  :            break;
; 817  : 
; 818  :       case INDEXSET_NODE: break; /* just accumulate index values */
; 819  :       case DIMENSIONSET_NODE: break; /* just accumulate index values */
; 820  :       case DEFINE_FIXED_LOCAL_ARRAY_NODE: break; /* was allocated on stack */
; 821  : 
; 822  :       case SHOW_NODE:
; 823  :       case SHOW_EXPR_NODE:
; 824  :       { int etype; /* element type */  
; 825  :         ENTER_GRAPH_MUTEX

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN1829@eval
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89774[ebp], 1
	jmp	SHORT $LN1828@eval
$LN1829@eval:
	mov	DWORD PTR _did_graphlock_here$89774[ebp], 0
$LN1828@eval:

; 826  :         where = node + node->op1.skipsize;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 168				; 000000a8H
	add	ecx, eax

; 827  :         if ( where->type == WHERE_NODE ) /* condition */

	cmp	DWORD PTR [ecx], 10262			; 00002816H
	jne	$LN1827@eval

; 828  :           { /* copy over expression */
; 829  :              enode = where + where->left; /* NEXT */

	mov	esi, DWORD PTR [ecx+4]

; 830  :              eroot = where + where->right;

	mov	eax, DWORD PTR [ecx+8]
	imul	esi, 168				; 000000a8H
	imul	eax, 168				; 000000a8H
	add	esi, ecx
	add	eax, ecx

; 831  :              etype = enode[enode->left].op1.eltype;

	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, 168				; 000000a8H
	mov	edi, DWORD PTR [ecx+esi+32]

; 832  :              show_expr[etype] = show_expr_table + etype;

	mov	edx, edi
	imul	edx, 104				; 00000068H
	lea	ecx, DWORD PTR _show_expr_table[edx]

; 833  :              tree_copy(show_expr[etype],eroot);

	push	eax
	push	ecx
	mov	DWORD PTR _show_expr[edi*4], ecx
	call	_tree_copy

; 834  :              sprintf(show_expr[etype]->name,"show expression for %s.",
; 835  :                 typenames[etype]);

	mov	eax, DWORD PTR _typenames[edi*4]
	mov	ecx, DWORD PTR _show_expr[edi*4]
	push	eax
	add	ecx, 20					; 00000014H
	push	OFFSET ??_C@_0BI@CLILKIPO@show?5expression?5for?5?$CFs?4?$AA@
	push	ecx
	call	_sprintf

; 836  :              /* can use first slot to record type of element */
; 837  :              /* element location */
; 838  :              show_expr[etype]->start->op2.eltype = enode->op2.eltype;

	mov	edx, DWORD PTR _show_expr[edi*4]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [esi+136]
	mov	DWORD PTR [eax+136], ecx

; 839  :              enode += enode->left; /* INIT */

	mov	edx, DWORD PTR [esi+4]

; 840  :              show_expr[etype]->start->op1.eltype = enode->op1.eltype;

	mov	eax, DWORD PTR _show_expr[edi*4]
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi+edx+32]

; 841  :              // copy over local variable data
; 842  :              show_expr[etype]->locals = (struct locallist_t*)mycalloc(1,sizeof(struct locallist_t));

	push	842					; 0000034aH
	push	OFFSET ??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@
	push	24					; 00000018H
	push	1
	mov	DWORD PTR [ecx+32], edx
	call	_kb_calloc
	mov	ecx, DWORD PTR _show_expr[edi*4]
	mov	DWORD PTR [ecx+8], eax

; 843  :              *(show_expr[etype]->locals) = *(ex_current.locals);

	mov	eax, DWORD PTR _ex_current$[ebp+8]
	mov	edx, DWORD PTR _show_expr[edi*4]
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]

; 844  :              show_expr[etype]->locals->list = 
; 845  :                   (struct localvar_t *)mycalloc(ex_current.locals->count,
; 846  :                              sizeof(struct localvar_t));

	push	846					; 0000034eH
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR _ex_current$[ebp+8]
	mov	edx, DWORD PTR [ecx+8]
	push	OFFSET ??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@
	push	224					; 000000e0H
	push	edx
	call	_kb_calloc
	mov	ecx, DWORD PTR _show_expr[edi*4]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 847  :              memcpy(show_expr[etype]->locals->list,ex_current.locals->list,ex_current.locals->count*
; 848  :                               sizeof(struct localvar_t));

	mov	eax, DWORD PTR _ex_current$[ebp+8]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax]
	imul	ecx, 224				; 000000e0H
	mov	eax, DWORD PTR _show_expr[edi*4]
	push	ecx
	mov	ecx, DWORD PTR [eax+8]
	push	edx
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 64					; 00000040H

; 849  :           }
; 850  :          else

	jmp	SHORT $LN1826@eval
$LN1827@eval:

; 851  :             { etype =  where[where->left].op1.eltype;

	mov	eax, DWORD PTR [ecx+4]
	imul	eax, 168				; 000000a8H
	mov	edi, DWORD PTR [eax+ecx+32]

; 852  :               tree_copy(show_expr[etype],NULL);

	mov	ecx, DWORD PTR _show_expr[edi*4]
	push	0
	push	ecx
	call	_tree_copy
	add	esp, 8

; 853  :               show_expr[etype] = NULL;

	mov	DWORD PTR _show_expr[edi*4], 0
$LN1826@eval:

; 854  :             }
; 855  :          /* save for dump */ 
; 856  :          tree_copy(show_command+etype,node+node->op1.skipsize+1);

	mov	eax, DWORD PTR _node$[ebp]
	imul	edi, 104				; 00000068H
	mov	edx, DWORD PTR [eax+32]
	inc	edx
	imul	edx, 168				; 000000a8H
	add	edx, eax
	push	edx
	add	edi, OFFSET _show_command
	push	edi
	call	_tree_copy
	add	esp, 8

; 857  :          LEAVE_GRAPH_MUTEX

	cmp	DWORD PTR _did_graphlock_here$89774[ebp], 0
	je	SHORT $LN1825@eval
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1825@eval:

; 858  :          if ( (node->type == SHOW_NODE) && !OOGL_flag && !go_display_flag)

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx], 10042			; 0000273aH
	jne	SHORT $LN1824@eval
	cmp	DWORD PTR _OOGL_flag, 0
	jne	SHORT $LN1824@eval
	cmp	DWORD PTR _go_display_flag, 0
	jne	SHORT $LN1824@eval

; 859  :             do_show();

	call	_do_show

; 861  :          node += node->op1.skipsize; /* skip over expression */

	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+32]
	imul	edx, 168				; 000000a8H
	add	eax, edx
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN1824@eval:

; 860  :          else update_display();

	call	_update_display

; 861  :          node += node->op1.skipsize; /* skip over expression */

	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+32]
	imul	edx, 168				; 000000a8H
	add	eax, edx
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN1822@eval:

; 862  :          break;
; 863  :        }
; 864  : 
; 865  :       case UNREDEFINE_SINGLE_NODE:
; 866  :         free_expr(&single_redefine[node->op1.letter]);

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 104				; 00000068H
	add	ecx, OFFSET _single_redefine
	push	ecx
	call	_free_expr
	add	esp, 4

; 867  :         break;

	jmp	$LN1980@eval
$LN1821@eval:

; 868  :           
; 869  :       case REDEFINE_SINGLE_NODE:
; 870  :         tree_copy(&single_redefine[node->op1.letter],node+node->op2.jumpsize);

	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+136]
	imul	edx, 168				; 000000a8H
	add	edx, eax
	mov	eax, DWORD PTR [eax+32]
	imul	eax, 104				; 00000068H
	push	edx
	add	eax, OFFSET _single_redefine
	push	eax
	call	_tree_copy

; 871  :         sprintf(single_redefine[node->op1.letter].name,"redefined command '%c'",
; 872  :              node->op1.letter);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	push	eax
	imul	eax, 104				; 00000068H
	add	eax, OFFSET _single_redefine+20
	push	OFFSET ??_C@_0BH@FDCGEHJN@redefined?5command?5?8?$CFc?8?$AA@
	push	eax
	call	_sprintf

; 873  :         single_redefine[node->op1.letter].flag = USERCOPY;

	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+32]
	imul	edx, 104				; 00000068H
	mov	DWORD PTR _single_redefine[edx+12], 1

; 874  :         locals_copy(&(single_redefine[node->op1.letter].locals),
; 875  :                 node->op5.locals); 

	mov	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [eax+152]
	imul	edx, 104				; 00000068H
	push	ecx
	add	edx, OFFSET _single_redefine+8
	push	edx
	call	_locals_copy
	add	esp, 28					; 0000001cH
$LN4017@eval:

; 876  :         node += node->op2.jumpsize; /* skip over procedure */

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	imul	ecx, 168				; 000000a8H
	add	eax, ecx
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN1820@eval:

; 877  :         break;
; 878  : 
; 879  :       case SET_PROCEDURE_NODE:
; 880  :         g = globals(node->op1.name_id);

	mov	edx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [edx+32]
	mov	eax, esi
	and	eax, -16777216				; ff000000H
	and	esi, 16777215				; 00ffffffH
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN2047@eval
	mov	eax, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+edx]
	jmp	SHORT $LN2044@eval
$LN2047@eval:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN2045@eval
	mov	eax, DWORD PTR _localbase$[ebp]
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [eax]
	jmp	SHORT $LN2044@eval
$LN2045@eval:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN2043@eval
	mov	ecx, DWORD PTR _web+5656
	mov	esi, DWORD PTR [ecx+esi*4]
	jmp	SHORT $LN2044@eval
$LN2043@eval:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [eax+ecx]
$LN2044@eval:

; 881  :         free_expr(&g->value.proc);

	lea	edi, DWORD PTR [esi+64]
	push	edi
	call	_free_expr

; 882  :         tree_copy(&g->value.proc, node+node->op2.jumpsize);

	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+136]
	imul	edx, 168				; 000000a8H
	add	edx, eax
	push	edx
	push	edi
	call	_tree_copy
	add	esp, 12					; 0000000cH

; 883  :         strcpy(g->value.proc.name, g->name);

	mov	eax, esi
$LL2049@eval:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [eax+84], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL2049@eval

; 884  :         g->attr.procstuff.proc_timestamp = proc_timestamp++;

	mov	eax, DWORD PTR _proc_timestamp
	mov	DWORD PTR [esi+176], eax

; 885  :         locals_copy(&(g->value.proc.locals),node->op5.locals);

	mov	ecx, DWORD PTR _node$[ebp]
	inc	DWORD PTR _proc_timestamp
	mov	edx, DWORD PTR [ecx+152]
	push	edx
	add	esi, 72					; 00000048H
	push	esi
	call	_locals_copy
	add	esp, 8

; 886  :         node += node->op2.jumpsize; /* skip over procedure */
; 887  :         break;

	jmp	$LN4017@eval
$LN1819@eval:

; 888  : 
; 889  :       case SET_PERM_PROCEDURE_NODE:
; 890  :         g = perm_globals(node->op1.name_id);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]

; 891  :         perm_free_expr(&g->value.proc);

	lea	edi, DWORD PTR [esi+64]
	push	edi
	call	_perm_free_expr

; 892  :         perm_tree_copy(&g->value.proc, node+node->op2.jumpsize);

	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+136]
	imul	edx, 168				; 000000a8H
	add	edx, eax
	push	edx
	push	edi
	call	_perm_tree_copy
	add	esp, 12					; 0000000cH

; 893  :         strcpy(g->value.proc.name, g->name);

	mov	eax, esi
	npad	6
$LL2050@eval:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [eax+84], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL2050@eval

; 894  :         g->attr.procstuff.proc_timestamp = proc_timestamp++;

	mov	eax, DWORD PTR _proc_timestamp
	mov	DWORD PTR [esi+176], eax

; 895  :         locals_copy_perm(&(g->value.proc.locals),node->op5.locals);

	mov	ecx, DWORD PTR _node$[ebp]
	inc	DWORD PTR _proc_timestamp
	mov	edx, DWORD PTR [ecx+152]
	push	edx
	add	esi, 72					; 00000048H
	push	esi
	call	_locals_copy_perm
	add	esp, 8

; 896  :         node += node->op2.jumpsize; /* skip over procedure */
; 897  :         break;

	jmp	$LN4017@eval
$LN1815@eval:

; 898  : 
; 899  :       case SET_FUNCTION_NODE: break;
; 900  :       case FUNCTION_HEAD_NODE: break;
; 901  :       case ARGLIST_NODE: break;
; 902  : 
; 903  :       case FUNCTION_DEF_START_NODE:
; 904  :         g = globals(node->op1.name_id);

	mov	edx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [edx+32]
	mov	eax, esi
	and	eax, -16777216				; ff000000H
	and	esi, 16777215				; 00ffffffH
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN2055@eval
	mov	eax, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+edx]
	jmp	SHORT $LN2052@eval
$LN2055@eval:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN2053@eval
	mov	eax, DWORD PTR _localbase$[ebp]
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [eax]
	jmp	SHORT $LN2052@eval
$LN2053@eval:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN2051@eval
	mov	ecx, DWORD PTR _web+5656
	mov	esi, DWORD PTR [ecx+esi*4]
	jmp	SHORT $LN2052@eval
$LN2051@eval:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [eax+ecx]
$LN2052@eval:

; 905  :         free_expr(&g->value.proc);

	lea	edi, DWORD PTR [esi+64]
	push	edi
	call	_free_expr

; 906  :         tree_copy(&g->value.proc, node+node->op2.jumpsize);

	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+136]
	imul	edx, 168				; 000000a8H
	add	edx, eax
	push	edx
	push	edi
	call	_tree_copy

; 907  :         g->value.proc.start[2].type = FUNCTION_START_NODE;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+336], 10053		; 00002745H
	add	esp, 12					; 0000000cH

; 908  :         strcpy(g->value.proc.name, g->name);

	mov	eax, esi
	npad	7
$LL2057@eval:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [eax+84], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL2057@eval
$LN4019@eval:

; 909  :         g->attr.procstuff.proc_timestamp = proc_timestamp++;

	mov	ecx, DWORD PTR _proc_timestamp
	mov	DWORD PTR [esi+176], ecx

; 910  :         locals_copy(&(g->value.proc.locals),node->op5.locals);

	mov	edx, DWORD PTR _node$[ebp]
	inc	DWORD PTR _proc_timestamp
	mov	eax, DWORD PTR [edx+152]
	push	eax
	add	esi, 72					; 00000048H
	push	esi
	call	_locals_copy
	add	esp, 8

; 911  :         node += node->op2.jumpsize; /* skip over procedure */
; 912  :         break;

	jmp	$LN4017@eval
$LN1814@eval:

; 913  : 
; 914  :       case FUNCTION_PROTO_START_NODE:
; 915  :         node += node->op2.jumpsize; /* skip over stuff */

	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+136]
	imul	edx, 168				; 000000a8H
	add	eax, edx
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN1813@eval:

; 916  :         break;
; 917  : 
; 918  :       case FUNCTION_START_NODE:  /* function entry code */
; 919  :         /* copy arguments over to local variable space */
; 920  :           memcpy((char*)(stacktop-localcount+1),
; 921  :            (char*)(((REAL*)this_frame)-(node->op3.argcount+PROF_SPACE)),
; 922  :              node->op3.argcount*sizeof(REAL));

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+140]
	mov	edx, DWORD PTR [ebx+52]
	lea	ecx, DWORD PTR [eax*8]
	push	ecx
	sub	edx, eax
	mov	eax, DWORD PTR [ebx+40]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _localcount$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [ebx+48]
	lea	eax, DWORD PTR [edx*8]
	sub	ecx, eax
	add	ecx, 8
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 923  :         break;

	jmp	$LN1980@eval
$LN1810@eval:

; 924  : 
; 925  :       case SET_ARGSPROC_NODE: break;
; 926  :       case PROCEDURE_HEAD_NODE: break;
; 927  : 
; 928  :       case PROCEDURE_DEF_START_NODE:
; 929  :         g = globals(node->op1.name_id);

	mov	edx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [edx+32]
	mov	eax, esi
	and	eax, -16777216				; ff000000H
	and	esi, 16777215				; 00ffffffH
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN2062@eval
	mov	eax, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+edx]
	jmp	SHORT $LN2059@eval
$LN2062@eval:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN2060@eval
	mov	eax, DWORD PTR _localbase$[ebp]
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [eax]
	jmp	SHORT $LN2059@eval
$LN2060@eval:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN2058@eval
	mov	ecx, DWORD PTR _web+5656
	mov	esi, DWORD PTR [ecx+esi*4]
	jmp	SHORT $LN2059@eval
$LN2058@eval:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [eax+ecx]
$LN2059@eval:

; 930  :         free_expr(&g->value.proc);

	lea	edi, DWORD PTR [esi+64]
	push	edi
	call	_free_expr

; 931  :         tree_copy(&g->value.proc, node+node->op2.jumpsize);

	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+136]
	imul	edx, 168				; 000000a8H
	add	edx, eax
	push	edx
	push	edi
	call	_tree_copy

; 932  :         g->value.proc.start[2].type = PROCEDURE_START_NODE;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+336], 10058		; 0000274aH
	add	esp, 12					; 0000000cH

; 933  :         strcpy(g->value.proc.name, g->name);

	mov	eax, esi
	npad	4
$LL2064@eval:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [eax+84], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL2064@eval

; 934  :         g->attr.procstuff.proc_timestamp = proc_timestamp++;
; 935  :         locals_copy(&(g->value.proc.locals),node->op5.locals);
; 936  :         node += node->op2.jumpsize; /* skip over procedure */
; 937  :         break;

	jmp	$LN4019@eval
$LN1808@eval:

; 938  : 
; 939  :       case PROCEDURE_PROTO_START_NODE:
; 940  :         node += node->op2.jumpsize; /* skip over stuff */ 
; 941  :         break;
; 942  : 
; 943  :       case PROCEDURE_START_NODE:  /* function entry code */
; 944  :         /* copy arguments over to local variable space */
; 945  :         if ( node->op3.argcount )

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+140]
	test	eax, eax
	je	$LN1980@eval

; 946  :           memcpy((char*)(stacktop-localcount+1),
; 947  :            (char*)(((REAL*)this_frame)-(node->op3.argcount+PROF_SPACE)),
; 948  :              node->op3.argcount*sizeof(REAL));

	mov	edx, DWORD PTR [ebx+52]
	lea	ecx, DWORD PTR [eax*8]
	push	ecx
	sub	edx, eax
	mov	eax, DWORD PTR [ebx+40]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _localcount$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [ebx+48]
	lea	eax, DWORD PTR [edx*8]
	sub	ecx, eax
	add	ecx, 8
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 949  :         break;

	jmp	$LN1980@eval
$LN1806@eval:

; 950  : 
; 951  :       case RETURN_NODE:
; 952  :         if ( node->left ) 

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 0

; 953  :         { newstack[localstack + localbase->totalsize] = *stacktop;

	mov	eax, DWORD PTR [ebx+40]
	je	SHORT $LN1805@eval
	mov	edx, DWORD PTR _localbase$[ebp]
	mov	edi, DWORD PTR [edx+12]
	mov	esi, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR _localstack$[ebp]
	fld	QWORD PTR [esi]
	add	edi, ecx
	fstp	QWORD PTR [eax+edi*8]

; 954  :           stacktop = newstack + localstack + localbase->totalsize;

	mov	edx, DWORD PTR [edx+12]
	add	edx, ecx
	lea	eax, DWORD PTR [eax+edx*8]
	mov	DWORD PTR [ebx+48], eax

; 955  :         }
; 956  :         else 

	jmp	SHORT $LN1804@eval
$LN1805@eval:

; 957  :           stacktop = newstack + localstack + localbase->totalsize - 1;

	mov	ecx, DWORD PTR _localbase$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _localstack$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8-8]
	mov	DWORD PTR [ebx+48], ecx
$LN1804@eval:

; 958  :         node = ex_current.root; /* since next node should be FINISHED_NODE */

	mov	eax, DWORD PTR _ex_current$[ebp+4]
	mov	DWORD PTR _node$[ebp], eax

; 959  :         if ( node[1].type != FINISHED_NODE )

	cmp	DWORD PTR [eax+168], 10386		; 00002892H
	je	$LN1980@eval

; 960  :         { sprintf(errmsg,"Internal error: no FINISH node after RETURN\n");

	push	OFFSET ??_C@_0CN@LGOPNDFF@Internal?5error?3?5no?5FINISH?5node?5a@
	push	OFFSET _errmsg
	call	_sprintf

; 961  :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 962  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	esi, DWORD PTR [eax+1]
	npad	5
$LL2798@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2798@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 963  :           kb_error(4578,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4578					; 000011e2H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 964  :         }
; 965  :         break;

	jmp	$LN1980@eval
$LN1802@eval:

; 966  :         
; 967  : 
; 968  :          /********************/
; 969  :          /* repeated command */
; 970  :          /********************/
; 971  : 
; 972  :       case REPEAT_INIT_NODE:
; 973  :         /* target on stack, then iteration count */
; 974  :         gocount = (int)*stacktop; 

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	call	__ftol2_sse

; 975  :         *(++stacktop) = 0; /* iterations done */

	fldz
	mov	DWORD PTR _gocount, eax
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 976  :         if ( gocount <= 0 ) 

	cmp	DWORD PTR _gocount, 0
	jg	$LN1980@eval

; 977  :         { stacktop -= 2; /* pop counts */

	add	DWORD PTR [ebx+48], -16			; fffffff0H

; 978  :           node += node->op1.skipsize; /* skip loop */

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 168				; 000000a8H
	add	eax, ecx
	mov	DWORD PTR _node$[ebp], eax

; 979  :           gocount = 1;

	mov	DWORD PTR _gocount, 1

; 980  :         }
; 981  :         break;

	jmp	$LN1980@eval
$LN1800@eval:

; 982  : 
; 983  :       case REPEAT_NODE:
; 984  :       { struct treenode *rnode = node + node->left;

	mov	eax, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [eax+4]
	imul	esi, 168				; 000000a8H
	add	esi, eax

; 985  :        
; 986  :         stacktop[0] += 1;

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [eax]

; 987  :         gocount = (int)(stacktop[-1] - stacktop[0]);

	fld	QWORD PTR [eax-8]
	fsub	QWORD PTR [eax]
	call	__ftol2_sse

; 988  : #if defined(MAC_APP) || defined(MAC_CW)
; 989  :         break_check();
; 990  : #endif
; 991  :        #ifdef __L_EVOLVER__
; 992  :         if (l_evolver_mode)

	xor	edi, edi
	mov	DWORD PTR _gocount, eax
	cmp	DWORD PTR _l_evolver_mode, edi
	je	SHORT $LN1797@eval

; 993  :           {
; 994  :           if (ProgramBreakDelay>0 && ++cProgramBreakDelay==ProgramBreakDelay) 

	mov	ecx, DWORD PTR _ProgramBreakDelay
	cmp	ecx, edi
	jle	SHORT $LN1797@eval
	mov	eax, DWORD PTR _cProgramBreakDelay
	inc	eax
	mov	DWORD PTR _cProgramBreakDelay, eax
	cmp	eax, ecx
	jne	SHORT $LN1797@eval

; 995  : 			  {
; 996  : 			  cProgramBreakDelay = 0;
; 997  : //            breakflag = BREAKABORT;
; 998  : 			  //breakflag = BREAKFULL;	 			
; 999  : 		      if (fgetc(l_brfd)!=EOF) 

	mov	edx, DWORD PTR _l_brfd
	push	edx
	mov	DWORD PTR _cProgramBreakDelay, edi
	call	_fgetc
	add	esp, 4
	cmp	eax, -1
	je	SHORT $LN1797@eval

; 1000 : 				  l_evolver_break = TRUE;

	mov	DWORD PTR _l_evolver_break, 1
$LN1797@eval:

; 1001 : 			  //+- for go 9999 testing
; 1002 : 			  //gocount=0;
; 1003 : 			  //goto LEVBRK;
; 1004 : 			  //stacktop -= 2; breakflag = 0; break;
; 1005 : 			  //end +-
; 1006 : 		      }
; 1007 :           }
; 1008 : 
; 1009 : #endif
; 1010 :         if ( breakflag  ) 

	cmp	DWORD PTR _breakflag, edi
	je	SHORT $LN1796@eval

; 1011 :         { stacktop -= 2; breakflag = 0; break; }

	add	DWORD PTR [ebx+48], -16			; fffffff0H
	mov	DWORD PTR _breakflag, edi
	jmp	$LN14@eval
$LN1796@eval:

; 1012 :         if ( (gocount > 0) && !breakflag )

	cmp	DWORD PTR _gocount, edi
	jle	SHORT $LEVBRK$89841

; 1013 :           { node = rnode;  /* do again */

	mov	DWORD PTR _node$[ebp], esi

; 1014 :              /* loop increment will step over REPEAT_INIT_ node */
; 1015 :           }
; 1016 :         else 

	jmp	$LN1980@eval
$LEVBRK$89841:

; 1017 :         { 
; 1018 : #ifdef __L_EVOLVER__
; 1019 : 		LEVBRK:
; 1020 : #endif
; 1021 :   		  stacktop -= 2; /* pop gocount and total count */

	add	DWORD PTR [ebx+48], -16			; fffffff0H

; 1022 :           gocount = 1;   /* so prints as 1 when no count given */

	mov	DWORD PTR _gocount, 1

; 1023 :         }
; 1024 :       }
; 1025 :       break;

	jmp	$LN1980@eval
$LN1793@eval:

; 1026 : 
; 1027 : 
; 1028 :       /*******************/
; 1029 :       /* flow of control */
; 1030 :       /*******************/
; 1031 : 
; 1032 :       case IFTEST_NODE:
; 1033 :       case COND_TEST_NODE:
; 1034 :         if ( *(stacktop--) == 0. )

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	add	ecx, -8					; fffffff8H
	fldz
	mov	DWORD PTR [ebx+48], ecx
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN1980@eval
$LN1776@eval:

; 1035 :         { /* jump */
; 1036 :           node += node->op1.skipsize;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 168				; 000000a8H
	add	eax, ecx
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN1790@eval:

; 1037 :         }
; 1038 :         break;
; 1039 : 
; 1040 :       case IF_NODE:
; 1041 :       case COND_EXPR_NODE:
; 1042 :          /* did first command, so skip second */
; 1043 :          node += node->op1.skipsize;
; 1044 :          break;
; 1045 : 
; 1046 :       case CONTINUE_NODE:
; 1047 :          node += node->op1.skipsize; /* back to loop top */

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	imul	eax, 168				; 000000a8H
	add	ecx, eax
	mov	DWORD PTR _node$[ebp], ecx

; 1048 :          stacktop = newstack + localstack + *(size_t*)(newstack + localstack+node->stackpos);

	mov	edx, DWORD PTR [ecx+160]
	mov	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	add	edx, ecx
	mov	edx, DWORD PTR [eax+edx*8]
	add	edx, ecx
	lea	eax, DWORD PTR [eax+edx*8]
	mov	DWORD PTR [ebx+48], eax

; 1049 :          node += node->op4.contjump; /* jump to expr */

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	imul	ecx, 168				; 000000a8H
	add	eax, ecx
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN1789@eval:

; 1050 :          break;
; 1051 : 
; 1052 :       case BREAK_NODE:
; 1053 :          node += node->op1.skipsize; /* back to loop top */

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	imul	edx, 168				; 000000a8H
	add	ecx, edx
	mov	DWORD PTR _node$[ebp], ecx

; 1054 :          stacktop = newstack + localstack + *(size_t*)(newstack + localstack+node->stackpos);

	mov	edx, DWORD PTR [ecx+160]
	mov	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	add	edx, ecx
	mov	edx, DWORD PTR [eax+edx*8]
	add	edx, ecx
	lea	eax, DWORD PTR [eax+edx*8]
	mov	DWORD PTR [ebx+48], eax

; 1055 :          node += node->op3.breakjump; /* jump to end */

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	imul	ecx, 168				; 000000a8H
	add	eax, ecx
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN1788@eval:

; 1056 :          break;
; 1057 : 
; 1058 :       case WHILE_TOP_NODE:
; 1059 :          /* break and continue jumps */
; 1060 :          *(size_t*)(newstack + localstack + node->stackpos) = stacktop - (newstack + localstack) - 1;

	mov	ecx, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [ebx+40]
	lea	edx, DWORD PTR [ecx*8]
	sub	esi, edx
	mov	edx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [edx+160]
	sub	esi, eax
	sar	esi, 3
	add	edx, ecx
	dec	esi
	mov	DWORD PTR [eax+edx*8], esi

; 1061 :          /* jumptest if expr false */
; 1062 :          if ( (*(stacktop--) == 0.) || breakflag )

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	add	ecx, -8					; fffffff8H
	fldz
	mov	DWORD PTR [ebx+48], ecx
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN1786@eval
	cmp	DWORD PTR _breakflag, 0
	je	$LN14@eval
$LN1786@eval:

; 1063 :            node += node->op1.skipsize;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 168				; 000000a8H
	add	eax, ecx
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN1784@eval:

; 1064 :          break;
; 1065 : 
; 1066 :       case WHILE_END_NODE:
; 1067 :          /* loop back */
; 1068 :          node += node->op1.skipsize;
; 1069 :          break;
; 1070 : 
; 1071 :       case DO_TOP_NODE: 
; 1072 :          /* break and continue jumps */
; 1073 :          *(size_t*)(newstack + localstack + node->stackpos) = stacktop - (newstack + localstack);

	mov	ecx, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [ebx+40]
	lea	edx, DWORD PTR [ecx*8]
	sub	esi, edx
	mov	edx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [edx+160]
	sub	esi, eax
	sar	esi, 3
	add	edx, ecx
	mov	DWORD PTR [eax+edx*8], esi

; 1074 :          break;

	jmp	$LN1980@eval
$LN1782@eval:

; 1075 : 
; 1076 :       case DO_ENTRY_NODE: 
; 1077 :          /* break and continue jumps */
; 1078 :          *(size_t*)(newstack + localstack + node->stackpos) = stacktop - (newstack + localstack);
; 1079 :          break;
; 1080 : 
; 1081 :       case DO_END_NODE:
; 1082 :          /* loop back if true */
; 1083 :          if ( *(stacktop--) && !breakflag )

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	add	ecx, -8					; fffffff8H
	fldz
	mov	DWORD PTR [ebx+48], ecx
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN1980@eval
	cmp	DWORD PTR _breakflag, 0
	jne	$LN2783@eval

; 1084 :            node += node->op1.skipsize;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 168				; 000000a8H
	add	eax, ecx
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN1779@eval:

; 1085 :          break;
; 1086 : 
; 1087 :       case FOR_ENTRY_NODE:
; 1088 :          /* break and continue jumps */
; 1089 :          *(size_t*)(newstack + localstack + node->stackpos) = stacktop - (newstack + localstack);
; 1090 :          break;
; 1091 : 
; 1092 :       case FOR_HEAD_NODE: 
; 1093 :          if ( *(stacktop--) && !breakflag )

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	add	ecx, -8					; fffffff8H
	fldz
	mov	DWORD PTR [ebx+48], ecx
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN1814@eval
	cmp	DWORD PTR _breakflag, 0
	jne	$LN1814@eval

; 1094 :            node += node->op1.skipsize;  /* loop body */

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 168				; 000000a8H
	add	eax, ecx
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN1774@eval:

; 1095 :          else
; 1096 :            node += node->op2.jumpsize; /* break out of loop */
; 1097 :          break;
; 1098 : 
; 1099 :       case FOR_TOP_NODE:
; 1100 :          node += node->op1.skipsize; /* jump to test expr */
; 1101 :          break;
; 1102 : 
; 1103 :       case FOR_END_NODE:
; 1104 :          node += node->op1.skipsize; /* jump to increment command */
; 1105 :          break;
; 1106 : 
; 1107 : 
; 1108 :       
; 1109 :          /*******************/
; 1110 :          /* aggregate verbs */
; 1111 :          /*******************/
; 1112 : 
; 1113 :       case LIST_NODE:
; 1114 :         oldquiet = quiet_flag; quiet_flag = 0;

	mov	esi, DWORD PTR _quiet_flag

; 1115 :         switch ( node->op2.eltype )

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _quiet_flag, 0
	mov	eax, DWORD PTR [eax+136]
	cmp	eax, 4
	ja	$LN1766@eval
	jmp	DWORD PTR $LN4029@eval[eax*4]
$LN1771@eval:

; 1116 :         { 
; 1117 :            case VERTEX:
; 1118 :              vertex_dump(positive_id(q_id),outfd);

	mov	ecx, DWORD PTR _outfd
	mov	edx, DWORD PTR _q_id$[ebp]
	push	ecx
	and	edx, -134217729				; f7ffffffH
	push	edx
	call	_vertex_dump
	add	esp, 8

; 1119 :              break;

	jmp	$LN1772@eval
$LN1770@eval:

; 1120 : 
; 1121 :            case EDGE:
; 1122 :              edge_dump(positive_id(q_id),outfd);

	mov	eax, DWORD PTR _outfd
	mov	ecx, DWORD PTR _q_id$[ebp]
	push	eax
	and	ecx, -134217729				; f7ffffffH
	push	ecx
	call	_edge_dump
	add	esp, 8

; 1123 :              break;

	jmp	$LN1772@eval
$LN1769@eval:

; 1124 : 
; 1125 :            case FACET:
; 1126 :              facet_dump(positive_id(q_id),outfd);

	mov	edx, DWORD PTR _outfd
	mov	eax, DWORD PTR _q_id$[ebp]
	push	edx
	and	eax, -134217729				; f7ffffffH
	push	eax
	call	_facet_dump
	add	esp, 8

; 1127 :              break;

	jmp	$LN1772@eval
$LN1768@eval:

; 1128 : 
; 1129 :            case BODY:
; 1130 :              body_dump(positive_id(q_id),outfd);

	mov	ecx, DWORD PTR _outfd
	mov	edx, DWORD PTR _q_id$[ebp]
	push	ecx
	and	edx, -134217729				; f7ffffffH
	push	edx
	call	_body_dump
	add	esp, 8

; 1131 :              break;

	jmp	$LN1772@eval
$LN1767@eval:

; 1132 : 
; 1133 :            case FACETEDGE:
; 1134 :              facetedge_dump(positive_id(q_id),outfd);

	mov	eax, DWORD PTR _outfd
	mov	ecx, DWORD PTR _q_id$[ebp]
	push	eax
	and	ecx, -134217729				; f7ffffffH
	push	ecx
	call	_facetedge_dump
	add	esp, 8

; 1135 :              break;

	jmp	SHORT $LN1772@eval
$LN1766@eval:

; 1136 : 
; 1137 :            default: 
; 1138 :              sprintf(errmsg,"Bad LIST element type in %s.\n",ex_current.name);

	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	OFFSET ??_C@_0BO@BGHMKKAN@Bad?5LIST?5element?5type?5in?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1139 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1140 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL2799@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2799@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1141 :              quiet_flag = oldquiet;   
; 1142 :              kb_error(1255,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1255					; 000004e7H
	mov	DWORD PTR _quiet_flag, esi
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1772@eval:

; 1143 : 
; 1144 :          }
; 1145 :         quiet_flag = oldquiet;   

	mov	DWORD PTR _quiet_flag, esi
$LN1707@eval:

; 1146 :         node += node->op1.skipsize - 1;  /* back to start of loop */

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
$LN4002@eval:
	imul	ecx, 168				; 000000a8H
	lea	edx, DWORD PTR [eax+ecx-168]
	mov	DWORD PTR _node$[ebp], edx

; 1147 :         break;

	jmp	$LN1980@eval
$LN1765@eval:

; 1148 : 
; 1149 :       /***********************
; 1150 :       * commands with counts *
; 1151 :       ***********************/
; 1152 :       case REFINE_NODE:
; 1153 :          switch ( node->op2.eltype )

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	dec	eax
	je	$LN1762@eval
	dec	eax
	je	SHORT $LN1759@eval

; 1180 :             default: 
; 1181 :               sprintf(errmsg,"Bad refine element type in %s.\n",ex_current.name);

	lea	ecx, DWORD PTR _ex_current$[ebp+20]
	push	ecx
	push	OFFSET ??_C@_0CA@NGOPNEKB@Bad?5refine?5element?5type?5in?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1182 :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1183 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL2800@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2800@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1184 :               kb_error(1256,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1256					; 000004e8H
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	$LN1760@eval
$LN1759@eval:

; 1165 :               }
; 1166 :               break;
; 1167 :             case FACET:
; 1168 :               face_triangulate(q_id,FACET_EDGES);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	3
	push	eax
	call	_face_triangulate
	add	esp, 8

; 1169 :               n = 1;
; 1170 :               if ( web.counts_reported & facet_refine_count_bit )

	test	BYTE PTR _web+5520, 32			; 00000020H
	je	SHORT $LN1758@eval

; 1171 :               { web.facet_refine_count = 0; 
; 1172 :                 web.counts_reported &= ~facet_refine_count_bit;

	and	DWORD PTR _web+5520, -33		; ffffffdfH
	mov	DWORD PTR _web+5448, 0
$LN1758@eval:

; 1173 :               }
; 1174 :               if ( n )
; 1175 :               { web.facet_refine_count += n; 

	mov	eax, 1
	add	DWORD PTR _web+5448, eax

; 1176 :                 web.counts_changed |= facet_refine_count_bit;

	or	DWORD PTR _web+5524, 32			; 00000020H

; 1177 :                 recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], eax

; 1178 :               }
; 1179 :               break;

	jmp	SHORT $LN1760@eval
$LN1762@eval:

; 1154 :          { 
; 1155 :             case EDGE:
; 1156 :               n = valid_id(edge_refine(q_id));

	mov	ecx, DWORD PTR _q_id$[ebp]
	push	ecx
	call	_edge_refine
	shr	eax, 28					; 0000001cH
	add	esp, 4
	and	eax, 1

; 1157 :               if ( web.counts_reported & edge_refine_count_bit )

	test	BYTE PTR _web+5520, 16			; 00000010H
	je	SHORT $LN1761@eval

; 1158 :               { web.edge_refine_count = 0; 
; 1159 :                 web.counts_reported &= ~edge_refine_count_bit;

	and	DWORD PTR _web+5520, -17		; ffffffefH
	mov	DWORD PTR _web+5444, 0
$LN1761@eval:

; 1160 :               }
; 1161 :               if ( n )

	test	eax, eax
	je	SHORT $LN1760@eval

; 1162 :               { web.edge_refine_count += n; 

	add	DWORD PTR _web+5444, eax

; 1163 :                 web.counts_changed |= edge_refine_count_bit;

	or	DWORD PTR _web+5524, 16			; 00000010H

; 1164 :                 recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], 1
$LN1760@eval:

; 1185 : 
; 1186 :          }
; 1187 :          node += node->op1.skipsize - 1;  /* back to start of loop */

	mov	eax, DWORD PTR _node$[ebp]
$LN813@eval:
	mov	edx, DWORD PTR [eax+32]
	imul	edx, 168				; 000000a8H
	lea	eax, DWORD PTR [eax+edx-168]
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN1755@eval:

; 1188 :          break;
; 1189 : 
; 1190 :       case POP_NODE:
; 1191 :          n = 0;
; 1192 :          if ( id_type(q_id) == EDGE )

	mov	eax, DWORD PTR _q_id$[ebp]
	shr	eax, 29					; 0000001dH
	xor	esi, esi
	cmp	eax, 1
	jne	SHORT $LN1754@eval

; 1193 :          { n = pop_one_edge(q_id); 

	mov	ecx, DWORD PTR _q_id$[ebp]
	push	ecx
	call	_pop_one_edge
	add	esp, 4

; 1194 :            if ( web.counts_reported & edge_pop_count_bit )

	test	DWORD PTR _web+5520, 4096		; 00001000H
	mov	esi, eax
	je	SHORT $LN1753@eval

; 1195 :            { web.edge_pop_count = 0; 
; 1196 :              web.counts_reported &= ~edge_pop_count_bit;

	and	DWORD PTR _web+5520, -4097		; ffffefffH
	mov	DWORD PTR _web+5480, 0
$LN1753@eval:

; 1197 :            }
; 1198 :            if ( n )

	test	esi, esi
	je	$LN1747@eval

; 1199 :            { web.edge_pop_count += n; 

	add	DWORD PTR _web+5480, esi

; 1200 :              web.counts_changed |= edge_pop_count_bit;

	or	DWORD PTR _web+5524, 4096		; 00001000H

; 1201 :            }

	jmp	$LN1747@eval
$LN1754@eval:

; 1202 :          }
; 1203 :          else if ( id_type(q_id) == VERTEX )

	test	eax, eax
	jne	SHORT $LN1750@eval

; 1204 :          { n = pop_given_vertex(q_id); 

	mov	edx, DWORD PTR _q_id$[ebp]
	push	edx
	call	_pop_given_vertex
	mov	esi, eax

; 1205 :            if ( web.counts_reported & vertex_pop_count_bit )

	mov	eax, 2048				; 00000800H
	add	esp, 4
	test	DWORD PTR _web+5520, eax
	je	SHORT $LN1749@eval

; 1206 :            { web.vertex_pop_count = 0; 
; 1207 :              web.counts_reported &= ~vertex_pop_count_bit;

	and	DWORD PTR _web+5520, -2049		; fffff7ffH
	mov	DWORD PTR _web+5476, 0
$LN1749@eval:

; 1208 :            }
; 1209 :            if ( n )

	test	esi, esi
	je	SHORT $LN1747@eval

; 1210 :            { web.vertex_pop_count += n; 

	add	DWORD PTR _web+5476, esi

; 1211 :              web.counts_changed |= vertex_pop_count_bit;

	or	DWORD PTR _web+5524, eax

; 1212 :            }
; 1213 :          }
; 1214 :          else 

	jmp	SHORT $LN1747@eval
$LN1750@eval:

; 1215 :          { sprintf(errmsg,"Only vertices and edges poppable.\n");

	push	OFFSET ??_C@_0CD@FBECANMH@Only?5vertices?5and?5edges?5poppable@
	push	OFFSET _errmsg
	call	_sprintf

; 1216 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1217 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL2801@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2801@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1218 :            kb_error(3356,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3356					; 00000d1cH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1747@eval:

; 1219 :          }
; 1220 :          node += node->op1.skipsize - 1;  /* back to start of loop */

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 168				; 000000a8H
	lea	edx, DWORD PTR [eax+ecx-168]
	mov	DWORD PTR _node$[ebp], edx

; 1221 :          if ( n )  recalc_flag = 1; 

	test	esi, esi
	je	$LN1980@eval
	mov	DWORD PTR _recalc_flag$[ebp], 1

; 1222 :          break;

	jmp	$LN1980@eval
$LN1745@eval:

; 1223 : 
; 1224 :       case POP_TRI_TO_EDGE_NODE:
; 1225 :          n = pop_tri_to_edge(q_id); 

	mov	eax, DWORD PTR _q_id$[ebp]
	push	eax
	call	_pop_tri_to_edge

; 1226 :          if ( web.counts_reported & pop_tri_to_edge_count_bit )

	mov	ecx, 16384				; 00004000H
	add	esp, 4
	test	DWORD PTR _web+5520, ecx
	je	SHORT $LN1744@eval

; 1227 :          { web.pop_tri_to_edge_count = 0;
; 1228 :            web.counts_reported &= ~pop_tri_to_edge_count_bit;

	and	DWORD PTR _web+5520, -16385		; ffffbfffH
	mov	DWORD PTR _web+5484, 0
$LN1744@eval:

; 1229 :          }
; 1230 :          if ( n )

	test	eax, eax
	je	SHORT $LN1743@eval

; 1231 :          { web.pop_tri_to_edge_count += n; 

	add	DWORD PTR _web+5484, eax
$LN4003@eval:

; 1232 :            web.counts_changed |= pop_tri_to_edge_count_bit;

	or	DWORD PTR _web+5524, ecx
$LN1743@eval:

; 1233 :          }
; 1234 :          node += node->op1.skipsize - 1;  /* back to start of loop */

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	imul	edx, 168				; 000000a8H
	lea	ecx, DWORD PTR [ecx+edx-168]
	mov	DWORD PTR _node$[ebp], ecx

; 1235 :          if ( n )  recalc_flag = 1; 

	test	eax, eax
$LN4004@eval:
	je	$LN1980@eval
	mov	DWORD PTR _recalc_flag$[ebp], 1

; 1236 :          break;

	jmp	$LN1980@eval
$LN1741@eval:

; 1237 : 
; 1238 :       case POP_EDGE_TO_TRI_NODE:
; 1239 :          n = pop_edge_to_tri(q_id); 

	mov	edx, DWORD PTR _q_id$[ebp]
	push	edx
	call	_pop_edge_to_tri

; 1240 :          if ( web.counts_reported & pop_edge_to_tri_count_bit )

	mov	ecx, 32768				; 00008000H
	add	esp, 4
	test	DWORD PTR _web+5520, ecx
	je	SHORT $LN1740@eval

; 1241 :            { web.pop_edge_to_tri_count = 0; 
; 1242 :              web.counts_reported &= ~pop_edge_to_tri_count_bit;

	and	DWORD PTR _web+5520, -32769		; ffff7fffH
	mov	DWORD PTR _web+5488, 0
$LN1740@eval:

; 1243 :            }
; 1244 :          if ( n )

	test	eax, eax
	je	SHORT $LN1743@eval

; 1245 :            { web.pop_edge_to_tri_count += n; 

	add	DWORD PTR _web+5488, eax

; 1246 :              web.counts_changed |= pop_edge_to_tri_count_bit;
; 1247 :            }
; 1248 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 1249 :          if ( n )  recalc_flag = 1; 
; 1250 :          break;

	jmp	SHORT $LN4003@eval
$LN1737@eval:

; 1251 : 
; 1252 :       case POP_QUAD_TO_QUAD_NODE:
; 1253 :          n = pop_quad_to_quad(q_id); 

	mov	edx, DWORD PTR _q_id$[ebp]
	push	edx
	call	_pop_quad_to_quad

; 1254 :          if ( web.counts_reported & pop_quad_to_quad_count_bit )

	mov	ecx, 65536				; 00010000H
	add	esp, 4
	test	DWORD PTR _web+5520, ecx
	je	SHORT $LN1736@eval

; 1255 :            { web.pop_quad_to_quad_count = 0; 
; 1256 :              web.counts_reported &= ~pop_quad_to_quad_count_bit;

	and	DWORD PTR _web+5520, -65537		; fffeffffH
	mov	DWORD PTR _web+5492, 0
$LN1736@eval:

; 1257 :            }
; 1258 :          if ( n )

	test	eax, eax
	je	$LN1743@eval

; 1259 :            { web.pop_quad_to_quad_count += n; 

	add	DWORD PTR _web+5492, eax

; 1260 :              web.counts_changed |= pop_quad_to_quad_count_bit;
; 1261 :            }
; 1262 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 1263 :          if ( n )  recalc_flag = 1;
; 1264 :          break;

	jmp	$LN4003@eval
$LN1733@eval:

; 1265 : 
; 1266 :       case EDGESWAP_NODE:
; 1267 :          n = edgeswap(q_id); 

	mov	edx, DWORD PTR _q_id$[ebp]
	push	edx
	call	_edgeswap

; 1268 :          if ( web.counts_reported & edgeswap_count_bit )

	mov	ecx, 262144				; 00040000H
	add	esp, 4
	test	DWORD PTR _web+5520, ecx
	je	SHORT $LN1732@eval

; 1269 :            { web.edgeswap_count = 0; 
; 1270 :              web.counts_reported &= ~edgeswap_count_bit;

	and	DWORD PTR _web+5520, -262145		; fffbffffH
	mov	DWORD PTR _web+5500, 0
$LN1732@eval:

; 1271 :            }
; 1272 :          if ( n )

	test	eax, eax
	je	$LN1743@eval

; 1273 :            { web.edgeswap_count += n; 

	add	DWORD PTR _web+5500, eax

; 1274 :              web.counts_changed |= edgeswap_count_bit;
; 1275 :            }
; 1276 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 1277 :          if ( n ) recalc_flag = 1;
; 1278 :          break;

	jmp	$LN4003@eval
$LN1729@eval:

; 1279 : 
; 1280 :       case T1_EDGESWAP_NODE:
; 1281 :          n = t1_edgeswap(q_id); 

	mov	edx, DWORD PTR _q_id$[ebp]
	push	edx
	call	_t1_edgeswap

; 1282 :          if ( web.counts_reported & t1_edgeswap_count_bit )

	mov	ecx, 2097152				; 00200000H
	add	esp, 4
	test	DWORD PTR _web+5520, ecx
	je	SHORT $LN1728@eval

; 1283 :            { web.t1_edgeswap_count = 0; 
; 1284 :              web.counts_reported &= ~t1_edgeswap_count_bit;

	and	DWORD PTR _web+5520, -2097153		; ffdfffffH
	mov	DWORD PTR _web+5504, 0
$LN1728@eval:

; 1285 :            }
; 1286 :          if ( n )

	test	eax, eax
	je	$LN1743@eval

; 1287 :            { web.t1_edgeswap_count += n; 

	add	DWORD PTR _web+5504, eax

; 1288 :              web.counts_changed |= t1_edgeswap_count_bit;
; 1289 :            }
; 1290 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 1291 :          if ( n )  recalc_flag = 1;
; 1292 :          break;

	jmp	$LN4003@eval
$LN1725@eval:

; 1293 : 
; 1294 :       case EQUIANGULATE_NODE:
; 1295 :          n = equiangulate_edge(q_id); 

	mov	edx, DWORD PTR _q_id$[ebp]
	push	edx
	call	_equiangulate_edge
	add	esp, 4

; 1296 :          if ( web.counts_reported & equi_count_bit )

	test	BYTE PTR _web+5520, 1
	je	SHORT $LN1724@eval

; 1297 :            { web.equi_count = 0; 
; 1298 :              web.counts_reported &= ~equi_count_bit;

	and	DWORD PTR _web+5520, -2			; fffffffeH
	mov	DWORD PTR _web+5432, 0
$LN1724@eval:

; 1299 :            }
; 1300 :          if ( n )

	test	eax, eax
	je	$LN1743@eval

; 1301 :            { web.equi_count += n; 

	add	DWORD PTR _web+5432, eax

; 1302 :              web.counts_changed |= equi_count_bit;

	or	DWORD PTR _web+5524, 1

; 1303 :            }
; 1304 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 1305 :          if ( n ) recalc_flag = 1; 
; 1306 :          
; 1307 :          break;

	jmp	$LN1743@eval
$LN1721@eval:

; 1308 : 
; 1309 :       case DISSOLVE_NODE:
; 1310 :          switch ( node->op2.eltype )

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+136]
	cmp	eax, 3
	ja	$LN1707@eval
	jmp	DWORD PTR $LN4030@eval[eax*4]
$LN1718@eval:

; 1311 :          {  case VERTEX: 
; 1312 :               n = dissolve_vertex(q_id); 

	mov	eax, DWORD PTR _q_id$[ebp]
	push	eax
	call	_dissolve_vertex
	add	esp, 4

; 1313 :               if ( web.counts_reported & vertex_dissolve_count_bit )

	test	BYTE PTR _web+5520, -128		; ffffff80H
	je	SHORT $LN1717@eval

; 1314 :               { web.vertex_dissolve_count = 0; 
; 1315 :                 web.counts_reported &= ~vertex_dissolve_count_bit;

	and	DWORD PTR _web+5520, -129		; ffffff7fH
	mov	DWORD PTR _web+5452, 0
$LN1717@eval:

; 1316 :               }
; 1317 :               if ( n )

	test	eax, eax
	je	$LN1707@eval

; 1318 :               { web.vertex_dissolve_count += n; 

	add	DWORD PTR _web+5452, eax

; 1319 :                 web.counts_changed |= vertex_dissolve_count_bit;

	or	DWORD PTR _web+5524, 128		; 00000080H

; 1356 :                 recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], 1

; 1357 :               }
; 1358 :               break;
; 1359 :           }
; 1360 :           node += node->op1.skipsize - 1;  /* back to start of loop */
; 1361 :           break;

	jmp	$LN1707@eval
$LN1715@eval:

; 1320 :                 recalc_flag = 1;
; 1321 :               }
; 1322 :               break;
; 1323 :             case EDGE:
; 1324 :               n = dissolve_edge(q_id); 

	mov	ecx, DWORD PTR _q_id$[ebp]
	push	ecx
	call	_dissolve_edge
	add	esp, 4

; 1325 :               if ( web.counts_reported & edge_dissolve_count_bit )

	test	DWORD PTR _web+5520, 256		; 00000100H
	je	SHORT $LN1714@eval

; 1326 :               { web.edge_dissolve_count = 0; 
; 1327 :                 web.counts_reported &= ~edge_dissolve_count_bit;

	and	DWORD PTR _web+5520, -257		; fffffeffH
	mov	DWORD PTR _web+5456, 0
$LN1714@eval:

; 1328 :               }
; 1329 :               if ( n )

	test	eax, eax
	je	$LN1707@eval

; 1330 :               { web.edge_dissolve_count += n; 

	add	DWORD PTR _web+5456, eax

; 1331 :                 web.counts_changed |= edge_dissolve_count_bit;

	or	DWORD PTR _web+5524, 256		; 00000100H

; 1356 :                 recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], 1

; 1357 :               }
; 1358 :               break;
; 1359 :           }
; 1360 :           node += node->op1.skipsize - 1;  /* back to start of loop */
; 1361 :           break;

	jmp	$LN1707@eval
$LN1712@eval:

; 1332 :                 recalc_flag = 1;
; 1333 :               }
; 1334 :               break;
; 1335 :             case FACET:
; 1336 :               n = dissolve_facet(q_id); 

	mov	edx, DWORD PTR _q_id$[ebp]
	push	edx
	call	_dissolve_facet

; 1337 :               if ( web.counts_reported & facet_dissolve_count_bit )

	mov	ecx, 512				; 00000200H
	add	esp, 4
	test	DWORD PTR _web+5520, ecx
	je	SHORT $LN1711@eval

; 1338 :               { web.facet_dissolve_count = 0; 
; 1339 :                 web.counts_reported &= ~facet_dissolve_count_bit;

	and	DWORD PTR _web+5520, -513		; fffffdffH
	mov	DWORD PTR _web+5460, 0
$LN1711@eval:

; 1340 :               }
; 1341 :               if ( n )

	test	eax, eax
	je	$LN1707@eval

; 1342 :               { web.facet_dissolve_count += n; 

	add	DWORD PTR _web+5460, eax

; 1343 :                 web.counts_changed |= facet_dissolve_count_bit;

	or	DWORD PTR _web+5524, ecx

; 1356 :                 recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], 1

; 1357 :               }
; 1358 :               break;
; 1359 :           }
; 1360 :           node += node->op1.skipsize - 1;  /* back to start of loop */
; 1361 :           break;

	jmp	$LN1707@eval
$LN1709@eval:

; 1344 :                 recalc_flag = 1;
; 1345 :               }
; 1346 :               break;
; 1347 :             case BODY:
; 1348 :               n = dissolve_body(q_id); 

	mov	eax, DWORD PTR _q_id$[ebp]
	push	eax
	call	_dissolve_body
	add	esp, 4

; 1349 :               if ( web.counts_reported & body_dissolve_count_bit )

	test	DWORD PTR _web+5520, 1024		; 00000400H
	je	SHORT $LN1708@eval

; 1350 :               { web.body_dissolve_count = 0; 
; 1351 :                 web.counts_reported &= ~body_dissolve_count_bit;

	and	DWORD PTR _web+5520, -1025		; fffffbffH
	mov	DWORD PTR _web+5464, 0
$LN1708@eval:

; 1352 :               }
; 1353 :               if ( n )

	test	eax, eax
	je	$LN1707@eval

; 1354 :               { web.body_dissolve_count += n; 

	add	DWORD PTR _web+5464, eax

; 1355 :                 web.counts_changed |= body_dissolve_count_bit;

	or	DWORD PTR _web+5524, 1024		; 00000400H

; 1356 :                 recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], 1

; 1357 :               }
; 1358 :               break;
; 1359 :           }
; 1360 :           node += node->op1.skipsize - 1;  /* back to start of loop */
; 1361 :           break;

	jmp	$LN1707@eval
$LN1706@eval:

; 1362 : 
; 1363 : 
; 1364 :       case REVERSE_ORIENTATION_NODE:
; 1365 :          switch ( node->op2.eltype )

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	dec	eax
	je	SHORT $LN1703@eval
	dec	eax
	jne	$LN1707@eval

; 1377 :               
; 1378 :               break;
; 1379 :             case FACET:
; 1380 :               reverse_orientation_facet(q_id); 

	mov	ecx, DWORD PTR _q_id$[ebp]
	push	ecx
	call	_reverse_orientation_facet

; 1381 :               if ( web.counts_reported & facet_reverse_count_bit )

	mov	ecx, 8388608				; 00800000H
	add	esp, 4
	test	DWORD PTR _web+5520, ecx
	je	SHORT $LN1700@eval

; 1382 :               { web.facet_reverse_count = 0; 
; 1383 :                 web.counts_reported &= ~facet_reverse_count_bit;

	and	DWORD PTR _web+5520, -8388609		; ff7fffffH
	mov	DWORD PTR _web+5472, 0
$LN1700@eval:

; 1384 :               }
; 1385 :               
; 1386 :               web.facet_reverse_count += 1; 

	mov	eax, 1
	add	DWORD PTR _web+5472, eax
	or	DWORD PTR _web+5524, ecx
	mov	DWORD PTR _recalc_flag$[ebp], eax

; 1387 :               web.counts_changed |= facet_reverse_count_bit;
; 1388 :               recalc_flag = 1;
; 1389 :               
; 1390 :               break;
; 1391 :           }
; 1392 :           node += node->op1.skipsize - 1;  /* back to start of loop */
; 1393 :           break;

	jmp	$LN1707@eval
$LN1703@eval:

; 1366 :          { 
; 1367 :             case EDGE:
; 1368 :               reverse_orientation_edge(q_id); 

	mov	edx, DWORD PTR _q_id$[ebp]
	push	edx
	call	_reverse_orientation_edge

; 1369 :               if ( web.counts_reported & edge_reverse_count_bit )

	mov	ecx, 4194304				; 00400000H
	add	esp, 4
	test	DWORD PTR _web+5520, ecx
	je	SHORT $LN1702@eval

; 1370 :               { web.edge_reverse_count = 0; 
; 1371 :                 web.counts_reported &= ~edge_reverse_count_bit;

	and	DWORD PTR _web+5520, -4194305		; ffbfffffH
	mov	DWORD PTR _web+5468, 0
$LN1702@eval:

; 1372 :               }
; 1373 :               
; 1374 :               web.edge_reverse_count += 1; 

	mov	eax, 1
	add	DWORD PTR _web+5468, eax

; 1375 :               web.counts_changed |= edge_reverse_count_bit;

	or	DWORD PTR _web+5524, ecx

; 1376 :               recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], eax

; 1387 :               web.counts_changed |= facet_reverse_count_bit;
; 1388 :               recalc_flag = 1;
; 1389 :               
; 1390 :               break;
; 1391 :           }
; 1392 :           node += node->op1.skipsize - 1;  /* back to start of loop */
; 1393 :           break;

	jmp	$LN1707@eval
$LN1699@eval:

; 1394 : 
; 1395 :       case FIX_NODE: 
; 1396 :          if ( web.counts_reported & fix_count_bit )

	test	DWORD PTR _web+5520, 524288		; 00080000H
	je	SHORT $LN1698@eval

; 1397 :          { web.fix_count = 0; 
; 1398 :            web.counts_reported &= ~fix_count_bit;

	and	DWORD PTR _web+5520, -524289		; fff7ffffH
	mov	DWORD PTR _web+5508, 0
$LN1698@eval:

; 1399 :          }
; 1400 :          if ( !(get_attr(q_id)&FIXED) )

	mov	eax, DWORD PTR _q_id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN1707@eval

; 1401 :          { set_attr(q_id,FIXED); 

	push	eax
	mov	eax, DWORD PTR _q_id$[ebp]
	push	64					; 00000040H
	push	eax
	call	_set_attr

; 1402 :            web.fix_count += 1; 

	inc	DWORD PTR _web+5508
	add	esp, 12					; 0000000cH

; 1403 :            web.counts_changed |= fix_count_bit;

	or	DWORD PTR _web+5524, 524288		; 00080000H

; 1404 :          }
; 1405 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 1406 :          break;

	jmp	$LN1707@eval
$LN1696@eval:

; 1407 : 
; 1408 :       case UNFIX_NODE:
; 1409 :          if ( web.counts_reported & unfix_count_bit )

	test	DWORD PTR _web+5520, 1048576		; 00100000H
	je	SHORT $LN1695@eval

; 1410 :          { web.unfix_count = 0; 
; 1411 :            web.counts_reported &= ~unfix_count_bit;

	and	DWORD PTR _web+5520, -1048577		; ffefffffH
	mov	DWORD PTR _web+5512, 0
$LN1695@eval:

; 1412 :          }
; 1413 :          if ( get_attr(q_id) & FIXED )

	mov	eax, DWORD PTR _q_id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN1707@eval

; 1414 :          { unset_attr(q_id,FIXED); 

	mov	eax, DWORD PTR _q_id$[ebp]
	push	ecx
	push	64					; 00000040H
	push	eax
	call	_unset_attr

; 1415 :            web.unfix_count += 1; 

	inc	DWORD PTR _web+5512
	add	esp, 12					; 0000000cH

; 1416 :            web.counts_changed |= unfix_count_bit;

	or	DWORD PTR _web+5524, 1048576		; 00100000H

; 1417 :          }
; 1418 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 1419 :          break;

	jmp	$LN1707@eval
$LN1693@eval:

; 1420 : 
; 1421 :       case VERTEX_AVERAGE_NODE:
; 1422 :          if ( new_vertex_average(q_id,VOLKEEP) ) recalc_flag = 1;

	mov	eax, DWORD PTR _q_id$[ebp]
	push	1
	push	eax
	call	_new_vertex_average
	add	esp, 8
	test	eax, eax
	je	$LN1707@eval
	mov	DWORD PTR _recalc_flag$[ebp], 1

; 1423 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 1424 :          break;

	jmp	$LN1707@eval
$LN1691@eval:

; 1425 : 
; 1426 :       case RAW_VERTEX_AVERAGE_NODE:
; 1427 :          if ( new_vertex_average(q_id,NOVOLKEEP) ) recalc_flag = 1;

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	eax
	call	_new_vertex_average
	add	esp, 8
	test	eax, eax
	je	$LN1707@eval
	mov	DWORD PTR _recalc_flag$[ebp], 1

; 1428 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 1429 :          break;

	jmp	$LN1707@eval
$LN1689@eval:

; 1430 : 
; 1431 :       case RAWEST_VERTEX_AVERAGE_NODE:
; 1432 :          if ( new_vertex_average(q_id,RAWEST) ) recalc_flag = 1;

	mov	eax, DWORD PTR _q_id$[ebp]
	push	2
	push	eax
	call	_new_vertex_average
	add	esp, 8
	test	eax, eax
	je	$LN1707@eval
	mov	DWORD PTR _recalc_flag$[ebp], 1

; 1433 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 1434 :          break;

	jmp	$LN1707@eval
$LN1687@eval:

; 1435 : 
; 1436 :       case DELETE_NODE:
; 1437 :          id = q_id;
; 1438 :          switch ( node->op2.eltype )

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	dec	eax
	je	$LN1684@eval
	dec	eax
	je	SHORT $LN1678@eval

; 1477 :                 recalc_flag = 1;
; 1478 :               }
; 1479 :                 
; 1480 :               break;
; 1481 : 
; 1482 :             default: 
; 1483 :               sprintf(errmsg,"Bad delete element type in %s.\n",ex_current.name);

	lea	ecx, DWORD PTR _ex_current$[ebp+20]
	push	ecx
	push	OFFSET ??_C@_0CA@CLIEDLCM@Bad?5delete?5element?5type?5in?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1484 :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1485 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL2802@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2802@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1486 :               kb_error(1257,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1257					; 000004e9H
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	$LN1707@eval
$LN1678@eval:

; 1461 :               }
; 1462 :               break;
; 1463 :             case FACET:
; 1464 :               n = delete_facet(id);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	eax
	call	_delete_facet
	add	esp, 4

; 1465 :               if ( web.counts_reported & facet_delete_count_bit )

	test	BYTE PTR _web+5520, 8
	je	SHORT $LN1677@eval

; 1466 :               { web.facet_delete_count = 0; 
; 1467 :                 web.counts_reported &= ~facet_delete_count_bit;

	and	DWORD PTR _web+5520, -9			; fffffff7H
	mov	DWORD PTR _web+5440, 0
$LN1677@eval:

; 1468 :               }
; 1469 :               if ( n > 0 )

	test	eax, eax
	jle	SHORT $LN3953@eval

; 1470 :               { web.facet_delete_count += n; 

	add	DWORD PTR _web+5440, eax

; 1471 :                 web.counts_changed |= facet_delete_count_bit;

	or	DWORD PTR _web+5524, 8

; 1472 :                 recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], 1

; 1473 :               }
; 1474 :               if ( n < 0 ) /* from string_delete_edge, partial elim */

	test	eax, eax
$LN3953@eval:
	jns	$LN1707@eval

; 1475 :               { web.edge_delete_count += -n;

	sub	DWORD PTR _web+5436, eax

; 1476 :                 web.counts_reported &= ~edge_delete_count_bit;

	and	DWORD PTR _web+5520, -5			; fffffffbH
	mov	DWORD PTR _recalc_flag$[ebp], 1

; 1487 :          }
; 1488 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 1489 :          break;

	jmp	$LN1707@eval
$LN1684@eval:

; 1439 :          { 
; 1440 :             case EDGE:
; 1441 :               n = delete_edge(id);

	mov	esi, DWORD PTR _q_id$[ebp]
	push	esi
	call	_delete_edge
	mov	edi, eax
	add	esp, 4

; 1442 :               if ( n ) 

	test	edi, edi
	je	$LN1681@eval

; 1443 :               { if ( !valid_element(id) )

	push	esi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	$LN1682@eval

; 1444 :                 { sprintf(errmsg,"Really strange configuration around deleted edge %s\n",
; 1445 :                      ELNAME(id));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN2065@eval
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN2066@eval
$LN2065@eval:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN2066@eval:
	push	eax
	push	OFFSET ??_C@_0DF@KGAJMGKH@Really?5strange?5configuration?5aro@
	push	OFFSET _errmsg
	call	_sprintf

; 1446 :                   sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1447 :                                 file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL2803@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2803@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1448 :                   kb_error(1919,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1919					; 0000077fH
	call	_kb_error
	add	esp, 28					; 0000001cH

; 1449 :                 }
; 1450 :                 else

	jmp	SHORT $LN1681@eval
$LN1682@eval:

; 1451 :                   free_element(id);

	push	esi
	call	_free_element
	add	esp, 4
$LN1681@eval:

; 1452 :               }
; 1453 :               if ( web.counts_reported & edge_delete_count_bit )

	test	BYTE PTR _web+5520, 4
	je	SHORT $LN1680@eval

; 1454 :               { web.edge_delete_count = 0; 
; 1455 :                 web.counts_reported &= ~edge_delete_count_bit;

	and	DWORD PTR _web+5520, -5			; fffffffbH
	mov	DWORD PTR _web+5436, 0
$LN1680@eval:

; 1456 :               }
; 1457 :               if ( n )

	test	edi, edi
	je	$LN1707@eval

; 1458 :               { web.edge_delete_count += n; 

	add	DWORD PTR _web+5436, edi

; 1459 :                 web.counts_changed |= edge_delete_count_bit;

	or	DWORD PTR _web+5524, 4

; 1460 :                 recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], 1

; 1487 :          }
; 1488 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 1489 :          break;

	jmp	$LN1707@eval
$LN1673@eval:

; 1490 : 
; 1491 :          /***************/
; 1492 :          /* expressions */
; 1493 :          /***************/
; 1494 : 
; 1495 :       case REPLACECONST_NODE:
; 1496 :          *stacktop = node->op1.real;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx+32]
	fstp	QWORD PTR [eax]

; 1497 :         break;

	jmp	$LN1980@eval
$LN1672@eval:

; 1498 : 
; 1499 :       case PUSHCONST_NODE:
; 1500 :          *++stacktop = node->op1.real;

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx+32]
	fstp	QWORD PTR [eax]

; 1501 :         break;

	jmp	$LN1980@eval
$LN1671@eval:

; 1502 : 
; 1503 :       case PUSHDELTA_NODE:
; 1504 :         { struct global *g = globals(node->op1.name_id);

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN2067@eval
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2069@eval
	mov	ecx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]

; 1505 :           *++stacktop = g->attr.varstuff.delta;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx+168]
	fstp	QWORD PTR [eax]

; 1506 :           break;

	jmp	$LN1980@eval
$LN2069@eval:

; 1502 : 
; 1503 :       case PUSHDELTA_NODE:
; 1504 :         { struct global *g = globals(node->op1.name_id);

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2067@eval
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]

; 1505 :           *++stacktop = g->attr.varstuff.delta;

	add	DWORD PTR [ebx+48], 8
	fld	QWORD PTR [ecx+168]
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 1506 :           break;

	jmp	$LN1980@eval
$LN2067@eval:

; 1502 : 
; 1503 :       case PUSHDELTA_NODE:
; 1504 :         { struct global *g = globals(node->op1.name_id);

	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+eax]

; 1505 :           *++stacktop = g->attr.varstuff.delta;

	add	DWORD PTR [ebx+48], 8
	fld	QWORD PTR [ecx+168]
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 1506 :           break;

	jmp	$LN1980@eval
$LN1670@eval:

; 1507 :         }
; 1508 : 
; 1509 :       case PUSH_PARAM_SCALE_NODE:
; 1510 :         { struct global *g = globals(node->op1.name_id);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN2073@eval
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2075@eval
	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]

; 1511 :           *++stacktop = g->attr.varstuff.pscale;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx+176]
	fstp	QWORD PTR [eax]

; 1512 :           break;

	jmp	$LN1980@eval
$LN2075@eval:

; 1507 :         }
; 1508 : 
; 1509 :       case PUSH_PARAM_SCALE_NODE:
; 1510 :         { struct global *g = globals(node->op1.name_id);

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2073@eval
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]

; 1511 :           *++stacktop = g->attr.varstuff.pscale;

	add	DWORD PTR [ebx+48], 8
	fld	QWORD PTR [ecx+176]
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 1512 :           break;

	jmp	$LN1980@eval
$LN2073@eval:

; 1507 :         }
; 1508 : 
; 1509 :       case PUSH_PARAM_SCALE_NODE:
; 1510 :         { struct global *g = globals(node->op1.name_id);

	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+ecx]

; 1511 :           *++stacktop = g->attr.varstuff.pscale;

	add	DWORD PTR [ebx+48], 8
	fld	QWORD PTR [ecx+176]
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 1512 :           break;

	jmp	$LN1980@eval
$LN1669@eval:

; 1513 :        }
; 1514 :       case PUSH_PARAM_FIXED_NODE:
; 1515 :         { struct global *g = globals(node->op1.name_id);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN2079@eval
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2081@eval
	mov	ecx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN2080@eval
$LN2081@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2079@eval
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN2080@eval
$LN2079@eval:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN2080@eval:

; 1516 :           *++stacktop = (g->flags & OPTIMIZING_PARAMETER)?0.0:1.0;

	test	DWORD PTR [eax+192], 32768		; 00008000H
	je	SHORT $LN2085@eval
	fldz
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 1517 :           break;

	jmp	$LN1980@eval
$LN2085@eval:

; 1516 :           *++stacktop = (g->flags & OPTIMIZING_PARAMETER)?0.0:1.0;

	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 1517 :           break;

	jmp	$LN1980@eval
$LN1668@eval:

; 1518 :         }
; 1519 :       case PUSH_PARAM_FORCE_NODE:
; 1520 :       { int i;
; 1521 :           for ( i = 0 ; i < optparamcount ; i++ )

	mov	edx, DWORD PTR _optparamcount
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN1665@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [ecx+32]
	mov	ecx, OFFSET _optparam
	npad	1
$LL1667@eval:

; 1522 :             if ( optparam[i].pnum == node->op1.name_id )

	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN2611@eval

; 1518 :         }
; 1519 :       case PUSH_PARAM_FORCE_NODE:
; 1520 :       { int i;
; 1521 :           for ( i = 0 ; i < optparamcount ; i++ )

	inc	eax
	add	ecx, 56					; 00000038H
	cmp	eax, edx
	jl	SHORT $LL1667@eval

; 6334 :                 a = NULL;
; 6335 :               }
; 6336 :             }
; 6337 :          }
; 6338 :         if ( this_frame->flags & BASE_OF_EVAL )

	jmp	SHORT $LN1665@eval
$LN2611@eval:

; 1523 :             {  *++stacktop = optparam[i].grad;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [ebx+48]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	fld	QWORD PTR _optparam[edx*8+8]
	fstp	QWORD PTR [ecx]
	mov	edx, DWORD PTR _optparamcount
$LN1665@eval:

; 1524 :                break;
; 1525 :             }
; 1526 :           if ( i == optparamcount ) *++stacktop = 0.0;

	cmp	eax, edx
$LN4005@eval:
	jne	$LN1980@eval
$LN1372@eval:
	add	DWORD PTR [ebx+48], 8
$LN1459@eval:
	fldz
$LN4022@eval:
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
$adfadf$92124:

; 1527 :           break;

	jmp	$LN1980@eval
$LN1662@eval:

; 1528 :        }
; 1529 :       case PUSH_PARAM_VELOCITY_NODE:
; 1530 :       { int i;
; 1531 :           for ( i = 0 ; i < optparamcount ; i++ )

	mov	edx, DWORD PTR _optparamcount
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN1659@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [ecx+32]
	mov	ecx, OFFSET _optparam
	npad	1
$LL1661@eval:

; 1532 :             if ( optparam[i].pnum == node->op1.name_id )

	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN2612@eval

; 1528 :        }
; 1529 :       case PUSH_PARAM_VELOCITY_NODE:
; 1530 :       { int i;
; 1531 :           for ( i = 0 ; i < optparamcount ; i++ )

	inc	eax
	add	ecx, 56					; 00000038H
	cmp	eax, edx
	jl	SHORT $LL1661@eval

; 6334 :                 a = NULL;
; 6335 :               }
; 6336 :             }
; 6337 :          }
; 6338 :         if ( this_frame->flags & BASE_OF_EVAL )

	jmp	SHORT $LN1659@eval
$LN2612@eval:

; 1533 :             {  *++stacktop = optparam[i].velocity;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [ebx+48]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	fld	QWORD PTR _optparam[edx*8+16]
	fstp	QWORD PTR [ecx]
	mov	edx, DWORD PTR _optparamcount
$LN1659@eval:

; 1534 :                break;
; 1535 :             }
; 1536 :           if ( i == optparamcount ) *++stacktop = 0.0;

	cmp	eax, edx
	jne	$LN1980@eval
	add	DWORD PTR [ebx+48], 8
	fldz
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 1537 :           break;

	jmp	$LN1980@eval
$LN1656@eval:

; 1538 :        }
; 1539 :       case PUSH_PARAM_EXTRA_NODE:
; 1540 :         { int i;
; 1541 :           for ( i = 0 ; i < optparamcount ; i++ )

	mov	edx, DWORD PTR _optparamcount
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN1650@eval
	mov	edi, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [edi+32]
	mov	ecx, OFFSET _optparam
	npad	1
$LL1655@eval:

; 1542 :             if ( optparam[i].pnum == node->op1.name_id )

	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN2613@eval

; 1538 :        }
; 1539 :       case PUSH_PARAM_EXTRA_NODE:
; 1540 :         { int i;
; 1541 :           for ( i = 0 ; i < optparamcount ; i++ )

	inc	eax
	add	ecx, 56					; 00000038H
	cmp	eax, edx
	jl	SHORT $LL1655@eval

; 6334 :                 a = NULL;
; 6335 :               }
; 6336 :             }
; 6337 :          }
; 6338 :         if ( this_frame->flags & BASE_OF_EVAL )

	jmp	SHORT $LN1650@eval
$LN2613@eval:

; 1543 :             { switch ( node->op2.extranum )

	mov	ecx, DWORD PTR [edi+136]
	sub	ecx, 3
	je	SHORT $LN1648@eval
	dec	ecx
	jne	SHORT $LN1650@eval

; 1544 :               { case V_VELOCITY_ATTR:
; 1545 :                   *++stacktop = optparam[i].velocity;

	add	DWORD PTR [ebx+48], 8
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	fld	QWORD PTR _optparam[edx*8+16]

; 1546 :                   break;

	jmp	SHORT $LN3955@eval
$LN1648@eval:

; 1547 :                 case V_FORCE_ATTR:
; 1548 :                   *++stacktop = optparam[i].grad;

	add	DWORD PTR [ebx+48], 8
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	fld	QWORD PTR _optparam[edx*8+8]
$LN3955@eval:
	mov	ecx, DWORD PTR [ebx+48]
	fstp	QWORD PTR [ecx]
	mov	edx, DWORD PTR _optparamcount
$LN1650@eval:

; 1549 :                   break;
; 1550 :               }
; 1551 :               break;
; 1552 :             }
; 1553 :           if ( i == optparamcount ) *++stacktop = 0.0;

	cmp	eax, edx
	jne	$LN1980@eval
	add	DWORD PTR [ebx+48], 8
	fldz
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 1554 :           break;

	jmp	$LN1980@eval
$LN1646@eval:

; 1555 :        }
; 1556 : 
; 1557 :       case PUSHGLOBAL_NODE:
; 1558 :       case STRINGGLOBAL_NODE:
; 1559 :       case PUSH_PERM_GLOBAL_NODE:
; 1560 :       case PERM_STRINGGLOBAL_NODE:
; 1561 :         { struct global *g = globals(node->op1.name_id);

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN2087@eval
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2089@eval
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _localbase$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN2088@eval
$LN2089@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2087@eval
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN2088@eval
$LN2087@eval:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN2088@eval:

; 1562 :           if ( g->flags & GLOB_LOCALVAR )

	mov	ecx, DWORD PTR [eax+192]
	test	ecx, 524288				; 00080000H
	je	SHORT $LN1645@eval

; 1563 :              *++stacktop = newstack[localstack+g->value.offset];

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR [eax+64]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax+edx*8]
	fstp	QWORD PTR [ecx]
	jmp	$LN1980@eval
$LN1645@eval:

; 1564 :           else if ( g->flags & FILE_VALUES )

	test	cl, 2
	je	SHORT $LN1643@eval

; 1565 :              *++stacktop = g->value.file.values[int_val];

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR [eax+64]
	mov	eax, DWORD PTR _int_val
	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx+eax*8]
	fstp	QWORD PTR [ecx]
	jmp	$LN1980@eval
$LN1643@eval:

; 1566 :           else if ( g->flags & STRINGVAL )

	test	ecx, 8192				; 00002000H
	je	SHORT $LN1641@eval

; 1567 :           { int pp = (sizeof(REAL)+sizeof(char*)-1)/sizeof(char*);
; 1568 :             int nn; 
; 1569 :             stacktop++;

	add	DWORD PTR [ebx+48], 8
	xor	ecx, ecx
	npad	4
$LL1640@eval:

; 1570 :             for ( nn = 0 ; nn < pp ; nn++ )
; 1571 :                ((char **)stacktop)[nn] = g->value.string;

	mov	edx, DWORD PTR [ebx+48]
	mov	esi, DWORD PTR [eax+64]
	mov	DWORD PTR [ecx+edx], esi
	add	ecx, 4
	cmp	ecx, 8
	jl	SHORT $LL1640@eval

; 1572 :           }
; 1573 :           else if ( g->flags & INTERNAL_NAME )

	jmp	$LN1980@eval
$LN1641@eval:
	test	ecx, 4194304				; 00400000H
	je	$LN1636@eval

; 1574 :           { if ( g->flags & INTVAL )

	test	ecx, 16777216				; 01000000H
	je	SHORT $LN1635@eval

; 1575 :               *++stacktop = *(int*)(g->value.dataptr);

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [eax+64]
	fild	DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebx+48]
	fstp	QWORD PTR [ecx]
	jmp	$LN1980@eval
$LN1635@eval:

; 1576 :             else if ( g->flags & REALVAL )

	test	ecx, 33554432				; 02000000H
	je	SHORT $LN1633@eval

; 1577 :               *++stacktop = *(REAL*)(g->value.dataptr);

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR [eax+64]
	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx]
	fstp	QWORD PTR [ecx]

; 1578 :             else

	jmp	$LN1980@eval
$LN1633@eval:

; 1579 :             { sprintf(errmsg,
; 1580 :                "Internal error: Internal variable %s type not set.\n",g->name);

	push	eax
	push	OFFSET ??_C@_0DE@HGELOKGG@Internal?5error?3?5Internal?5variabl@
	push	OFFSET _errmsg
	call	_sprintf

; 1581 :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1582 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
$LL2804@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2804@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1583 :               kb_error(2851,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2851					; 00000b23H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 1584 :             }
; 1585 :           }
; 1586 :           else

	jmp	$LN1980@eval
$LN1636@eval:

; 1587 :             *++stacktop = g->value.real;

	add	DWORD PTR [ebx+48], 8
	fld	QWORD PTR [eax+64]
	mov	ecx, DWORD PTR [ebx+48]
	fstp	QWORD PTR [ecx]

; 1588 :         }
; 1589 :         break;

	jmp	$LN1980@eval
$LN1630@eval:

; 1590 : 
; 1591 :       case PUSHPI_NODE:
; 1592 :          *++stacktop = M_PI;

	add	DWORD PTR [ebx+48], 8
	fld	QWORD PTR __real@400921fb54442d18
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 1593 :         break;

	jmp	$LN1980@eval
$LN1629@eval:

; 1594 : 
; 1595 :       case PUSHE_NODE:
; 1596 :          *++stacktop = M_E;

	add	DWORD PTR [ebx+48], 8
	fld	QWORD PTR __real@4005bf0a8b145769
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 1597 :         break;

	jmp	$LN1980@eval
$LN1628@eval:

; 1598 : 
; 1599 :       case PUSHG_NODE:
; 1600 :          *++stacktop = web.gravflag ? web.grav_const : 0.0;

	cmp	DWORD PTR _web+824, 0
	je	SHORT $LN2093@eval
	fld	QWORD PTR _web+832
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 1601 :         break;

	jmp	$LN1980@eval
$LN2093@eval:

; 1598 : 
; 1599 :       case PUSHG_NODE:
; 1600 :          *++stacktop = web.gravflag ? web.grav_const : 0.0;

	fldz
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 1601 :         break;

	jmp	$LN1980@eval
$LN1627@eval:

; 1602 : 
; 1603 :       case PUSHPARAM_NODE:
; 1604 :          *++stacktop = params[node->op1.coordnum];

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _params$GSCopy$[ebp]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx+edx*8]
	fstp	QWORD PTR [eax]

; 1605 :         break;

	jmp	$LN1980@eval
$LN1626@eval:

; 1606 : 
; 1607 :       case USERFUNC_NODE:
; 1608 :         *++stacktop = (*userfunc[node->op1.userfunc])(params);

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _params$GSCopy$[ebp]
	mov	edx, DWORD PTR _userfunc[eax*4]
	mov	esi, DWORD PTR [ebx+48]
	push	ecx
	call	edx
	fstp	QWORD PTR [esi]
	add	esp, 4

; 1609 :         break;

	jmp	$LN1980@eval
$LN1625@eval:

; 1610 : 
; 1611 :       case DYNAMIC_LOAD_FUNC_NODE:
; 1612 :         if ( ! params )

	cmp	DWORD PTR _params$GSCopy$[ebp], 0
	jne	$LN1624@eval

; 1613 :         { sprintf(errmsg,
; 1614 :            "Must use dynamic load function %s in context with parameters.\n",
; 1615 :              globals(node->op2.name_id)->name);

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN2095@eval
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2097@eval
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _localbase$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN2096@eval
$LN2097@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2095@eval
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN2096@eval
$LN2095@eval:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN2096@eval:
	push	eax
	push	OFFSET ??_C@_0DP@CDGHBNOO@Must?5use?5dynamic?5load?5function?5?$CF@
	push	OFFSET _errmsg
	call	_sprintf

; 1616 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1617 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
$LL2805@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2805@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1618 :           kb_error(2059,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2059					; 0000080bH
	call	_kb_error
	add	esp, 28					; 0000001cH

; 1619 :         } else

	jmp	$LN1980@eval
$LN1624@eval:

; 1620 :         (*node->op1.funcptr)(FUNC_VALUE,params,(struct dstack*)(++stacktop));

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	eax
	mov	eax, DWORD PTR _params$GSCopy$[ebp]
	push	eax
	push	1
	call	edx
	add	esp, 12					; 0000000cH

; 1621 :         break;

	jmp	$LN1980@eval
$LN1622@eval:

; 1622 : 
; 1623 :       case GT_NODE:
; 1624 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	ecx, DWORD PTR [ebx+48]

; 1625 :         stacktop[0] = (REAL)(stacktop[0] > stacktop[1]);

	fld	QWORD PTR [ecx+8]
	mov	DWORD PTR tv2973[ebp], 1
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN2102@eval
	mov	DWORD PTR tv2973[ebp], 0
$LN2102@eval:
	fild	DWORD PTR tv2973[ebp]
	fstp	QWORD PTR [ecx]

; 1626 :         break;

	jmp	$LN1980@eval
$LN1621@eval:

; 1627 : 
; 1628 :       case LT_NODE:
; 1629 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	ecx, DWORD PTR [ebx+48]

; 1630 :         stacktop[0] = (REAL)(stacktop[0] < stacktop[1]);

	fld	QWORD PTR [ecx+8]
	mov	DWORD PTR tv2986[ebp], 1
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN2104@eval
	mov	DWORD PTR tv2986[ebp], 0
$LN2104@eval:
	fild	DWORD PTR tv2986[ebp]
	fstp	QWORD PTR [ecx]

; 1631 :         break;

	jmp	$LN1980@eval
$LN1620@eval:

; 1632 : 
; 1633 :       case LE_NODE:
; 1634 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	ecx, DWORD PTR [ebx+48]

; 1635 :         stacktop[0] = (REAL)(stacktop[0] <= stacktop[1]);

	fld	QWORD PTR [ecx+8]
	mov	DWORD PTR tv2999[ebp], 1
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN2106@eval
	mov	DWORD PTR tv2999[ebp], 0
$LN2106@eval:
	fild	DWORD PTR tv2999[ebp]
	fstp	QWORD PTR [ecx]

; 1636 :         break;

	jmp	$LN1980@eval
$LN1619@eval:

; 1637 : 
; 1638 :       case GE_NODE:
; 1639 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	ecx, DWORD PTR [ebx+48]

; 1640 :         stacktop[0] = (REAL)(stacktop[0] >= stacktop[1]);

	fld	QWORD PTR [ecx+8]
	mov	DWORD PTR tv3012[ebp], 1
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN2108@eval
	mov	DWORD PTR tv3012[ebp], 0
$LN2108@eval:
	fild	DWORD PTR tv3012[ebp]
	fstp	QWORD PTR [ecx]

; 1641 :         break;

	jmp	$LN1980@eval
$LN1618@eval:

; 1642 : 
; 1643 :       case NE_NODE:
; 1644 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	ecx, DWORD PTR [ebx+48]

; 1645 :         stacktop[0] = (REAL)(stacktop[0] != stacktop[1]);

	fld	QWORD PTR [ecx]
	mov	DWORD PTR tv3025[ebp], 1
	fld	QWORD PTR [ecx+8]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN2110@eval
	mov	DWORD PTR tv3025[ebp], 0
$LN2110@eval:
	fild	DWORD PTR tv3025[ebp]
	fstp	QWORD PTR [ecx]

; 1646 :         break;

	jmp	$LN1980@eval
$LN1617@eval:

; 1647 : 
; 1648 :       case EQ_NODE:
; 1649 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	ecx, DWORD PTR [ebx+48]

; 1650 :         stacktop[0] = (REAL)(stacktop[0] == stacktop[1]);

	fld	QWORD PTR [ecx]
	mov	DWORD PTR tv3038[ebp], 1
	fld	QWORD PTR [ecx+8]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2112@eval
	mov	DWORD PTR tv3038[ebp], 0
$LN2112@eval:
	fild	DWORD PTR tv3038[ebp]
	fstp	QWORD PTR [ecx]

; 1651 :         break;

	jmp	$LN1980@eval
$LN1616@eval:

; 1652 : 
; 1653 :       case AND_NODE: /* short-circuit */
; 1654 :         if ( *stacktop == 0.0 )

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	$LN3164@eval

; 1655 :         { *(++stacktop) = 0.0;

	lea	eax, DWORD PTR [ecx+8]
	fstp	QWORD PTR [eax]
	mov	DWORD PTR [ebx+48], eax

; 1656 :           node += node->op1.skipsize; /* leave 0 as result */

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 168				; 000000a8H
	add	eax, ecx
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN1614@eval:

; 1657 :         }
; 1658 :         break;
; 1659 : 
; 1660 :       case CONJUNCTION_END_NODE:    
; 1661 :         /* short-circuiting results in second arg being answer */
; 1662 :         /* get proper 1 for true */
; 1663 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	eax, DWORD PTR [ebx+48]

; 1664 :         *stacktop = stacktop[1];

	fld	QWORD PTR [eax+8]

; 1665 :         if ( *stacktop ) *stacktop = 1.0;

	mov	ecx, eax
	fstp	QWORD PTR [eax]
	fld	QWORD PTR [ecx]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN1980@eval
	fld1
	fstp	QWORD PTR [ecx]

; 1666 :         break;

	jmp	$LN1980@eval
$LN1612@eval:

; 1667 : 
; 1668 :       case OR_NODE: /* short-circuit */
; 1669 :         if ( *stacktop != 0.0 )

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN1980@eval

; 1670 :         { *(++stacktop) = 1.0;

	fld1
	lea	eax, DWORD PTR [ecx+8]
	fstp	QWORD PTR [eax]
	mov	DWORD PTR [ebx+48], eax

; 1671 :           node += node->op1.skipsize; /* leave as result */

	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+32]
	imul	edx, 168				; 000000a8H
	add	eax, edx
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN1610@eval:

; 1672 :         }
; 1673 :         break;
; 1674 : 
; 1675 :       case NOT_NODE:
; 1676 :         stacktop[0] = (REAL)(!stacktop[0]);

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	mov	DWORD PTR tv3076[ebp], 1
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2114@eval
	mov	DWORD PTR tv3076[ebp], 0
$LN2114@eval:
	fild	DWORD PTR tv3076[ebp]
	fstp	QWORD PTR [ecx]

; 1677 :         break;

	jmp	$LN1980@eval
$LN1609@eval:

; 1678 : 
; 1679 :       case PLUS_NODE:
; 1680 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	eax, DWORD PTR [ebx+48]

; 1681 :         stacktop[0] += stacktop[1];

	fld	QWORD PTR [eax+8]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 1682 :         break;

	jmp	$LN1980@eval
$LN1608@eval:

; 1683 : 
; 1684 :       case MINUS_NODE:
; 1685 :       case EQUATE_NODE:
; 1686 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	eax, DWORD PTR [ebx+48]

; 1687 :         stacktop[0] -= stacktop[1];

	fld	QWORD PTR [eax]
	fsub	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax]

; 1688 :         break;

	jmp	$LN1980@eval
$LN1607@eval:

; 1689 : 
; 1690 :       case TIMES_NODE:
; 1691 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	eax, DWORD PTR [ebx+48]

; 1692 :         stacktop[0] *= stacktop[1];

	fld	QWORD PTR [eax+8]
	fmul	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 1693 :         break;

	jmp	$LN1980@eval
$LN1606@eval:

; 1694 : 
; 1695 :       case DIVIDE_NODE:
; 1696 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	eax, DWORD PTR [ebx+48]

; 1697 :         if ( stacktop[1] == 0.0 ) 

	fld	QWORD PTR [eax+8]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN1605@eval

; 1698 :         { if ( valid_id(self_id) ) 

	test	DWORD PTR _self_id$GSCopy$[ebp], 268435456 ; 10000000H
	je	SHORT $LN1604@eval

; 1699 :           sprintf(errmsg,"Division by zero in %s, %s %s.\n",ex_current.name, 
; 1700 :              typenames[id_type(self_id)],ELNAME(self_id));

	mov	esi, DWORD PTR _self_id$GSCopy$[ebp]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	push	OFFSET _elnames
	shr	esi, 29					; 0000001dH
	mov	ecx, DWORD PTR _typenames[esi*4]
	push	ecx
	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	OFFSET ??_C@_0CA@MCBMPDHE@Division?5by?5zero?5in?5?$CFs?0?5?$CFs?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 32					; 00000020H
	jmp	SHORT $LN1603@eval
$LN1604@eval:

; 1701 :           else sprintf(errmsg,"Division by zero in %s.\n",ex_current.name);

	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	OFFSET ??_C@_0BJ@DKCGOBDB@Division?5by?5zero?5in?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1603@eval:

; 1702 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1703 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
$LL2806@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2806@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1704 :           kb_error(1258,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1258					; 000004eaH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1605@eval:

; 1705 :         }
; 1706 :         stacktop[0] /= stacktop[1];

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	fdiv	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax]

; 1707 :         break;

	jmp	$LN1980@eval
$LN1602@eval:

; 1708 : 
; 1709 :       case REALMOD_NODE:
; 1710 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	eax, DWORD PTR [ebx+48]

; 1711 :         if ( stacktop[1] == 0.0 ) 

	fld	QWORD PTR [eax+8]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN1601@eval

; 1712 :         { if ( valid_id(self_id) )

	test	DWORD PTR _self_id$GSCopy$[ebp], 268435456 ; 10000000H
	je	SHORT $LN1600@eval

; 1713 :             sprintf(errmsg,"Modulus base zero in %s, %s %s.\n",ex_current.name,
; 1714 :              typenames[id_type(self_id)],ELNAME(self_id));

	mov	esi, DWORD PTR _self_id$GSCopy$[ebp]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	push	OFFSET _elnames
	shr	esi, 29					; 0000001dH
	mov	ecx, DWORD PTR _typenames[esi*4]
	push	ecx
	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	OFFSET ??_C@_0CB@HIHGBPJM@Modulus?5base?5zero?5in?5?$CFs?0?5?$CFs?5?$CFs?4?6@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 32					; 00000020H
	jmp	SHORT $LN1599@eval
$LN1600@eval:

; 1715 :           else sprintf(errmsg,"Modulus base zero in %s.\n",ex_current.name);

	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	OFFSET ??_C@_0BK@EOENHDHL@Modulus?5base?5zero?5in?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1599@eval:

; 1716 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1717 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
$LL2807@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2807@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1718 :           kb_error(1259,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1259					; 000004ebH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1601@eval:

; 1719 :         }
; 1720 :         stacktop[0] = stacktop[0] - floor(stacktop[0]/stacktop[1])
; 1721 :                               *stacktop[1];

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	sub	esp, 8
	fdiv	QWORD PTR [esi+8]
	fstp	QWORD PTR [esp]
	call	_floor
	fmul	QWORD PTR [esi+8]
	add	esp, 8
	fsubr	QWORD PTR [esi]
	fstp	QWORD PTR [esi]

; 1722 :         break;

	jmp	$LN1980@eval
$LN1598@eval:

; 1723 : 
; 1724 :       case IMOD_NODE:
; 1725 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	eax, DWORD PTR [ebx+48]

; 1726 :         if ( stacktop[1] == 0.0 ) 

	fld	QWORD PTR [eax+8]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN1597@eval

; 1727 :         { if ( valid_id(self_id) )

	test	DWORD PTR _self_id$GSCopy$[ebp], 268435456 ; 10000000H
	je	SHORT $LN1596@eval

; 1728 :             sprintf(errmsg,"Modulus base zero in %s, %s %s.\n",ex_current.name,
; 1729 :              typenames[id_type(self_id)],ELNAME(self_id));

	mov	esi, DWORD PTR _self_id$GSCopy$[ebp]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	push	OFFSET _elnames
	shr	esi, 29					; 0000001dH
	mov	ecx, DWORD PTR _typenames[esi*4]
	push	ecx
	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	OFFSET ??_C@_0CB@HIHGBPJM@Modulus?5base?5zero?5in?5?$CFs?0?5?$CFs?5?$CFs?4?6@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 32					; 00000020H
	jmp	SHORT $LN1595@eval
$LN1596@eval:

; 1730 :           else sprintf(errmsg,"Modulus base zero in %s.\n",ex_current.name);

	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	OFFSET ??_C@_0BK@EOENHDHL@Modulus?5base?5zero?5in?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1595@eval:

; 1731 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1732 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL2808@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2808@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1733 :           kb_error(1260,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1260					; 000004ecH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1597@eval:

; 1734 :         }
; 1735 :         stacktop[0] = floor(stacktop[0]) - 
; 1736 :             floor(floor(stacktop[0])/floor(stacktop[1]))
; 1737 :                               *floor(stacktop[1]);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR tv18539[ebp]
	fld	QWORD PTR [esi+8]
	fstp	QWORD PTR [esp]
	call	_floor
	fst	QWORD PTR tv18540[ebp]
	fdivr	QWORD PTR tv18539[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	fmul	QWORD PTR tv18540[ebp]
	add	esp, 8
	fsubr	QWORD PTR tv18539[ebp]
	fstp	QWORD PTR [esi]

; 1738 :         break;

	jmp	$LN1980@eval
$LN1594@eval:

; 1739 : 
; 1740 :       case IDIV_NODE:
; 1741 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	eax, DWORD PTR [ebx+48]

; 1742 :         if ( (int)stacktop[1] == 0 ) 

	fld	QWORD PTR [eax+8]
	call	__ftol2_sse
	test	eax, eax
	jne	$LN1593@eval

; 1743 :         { if ( valid_id(self_id) )

	mov	esi, DWORD PTR _self_id$GSCopy$[ebp]
	test	esi, 268435456				; 10000000H
	je	SHORT $LN1592@eval

; 1744 :             sprintf(errmsg,"Division by zero in %s, %s %s.\n",ex_current.name,
; 1745 :              typenames[id_type(self_id)],ELNAME(self_id));

	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	push	OFFSET _elnames
	shr	esi, 29					; 0000001dH
	mov	ecx, DWORD PTR _typenames[esi*4]
	push	ecx
	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	OFFSET ??_C@_0CA@MCBMPDHE@Division?5by?5zero?5in?5?$CFs?0?5?$CFs?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 32					; 00000020H
	jmp	SHORT $LN1591@eval
$LN1592@eval:

; 1746 :           else sprintf(errmsg,"Division by zero in %s.\n",ex_current.name);

	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	OFFSET ??_C@_0BJ@DKCGOBDB@Division?5by?5zero?5in?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1591@eval:

; 1747 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1748 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL2809@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2809@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1749 :           kb_error(1261,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1261					; 000004edH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1593@eval:

; 1750 :         }
; 1751 :         stacktop[0] = (REAL)((int)(stacktop[0])/(int)(stacktop[1]));

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi+8]
	call	__ftol2_sse
	fld	QWORD PTR [esi]
	mov	edi, eax
	call	__ftol2_sse
	cdq
	idiv	edi
	mov	DWORD PTR tv28382[ebp], eax
	fild	DWORD PTR tv28382[ebp]
	fstp	QWORD PTR [esi]

; 1752 :         break;

	jmp	$LN1980@eval
$LN1590@eval:

; 1753 : 
; 1754 :       case INTPOW_NODE:
; 1755 :          /* cases n = 0,1,2 taken care of in parsing */
; 1756 :          x = *stacktop;
; 1757 :          k = node->op1.intpow < 0 ? -node->op1.intpow : node->op1.intpow;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	test	ecx, ecx
	jns	SHORT $LN2123@eval
	neg	ecx
$LN2123@eval:

; 1758 :          for ( n = 1 ; n < k ; n++ )

	cmp	ecx, 1
	jle	SHORT $LN3171@eval
	fld	QWORD PTR [eax]
	dec	ecx
$LN1589@eval:
	dec	ecx

; 1759 :            *stacktop *= x;

	fmul	ST(0), ST(1)
	jne	SHORT $LN1589@eval

; 1758 :          for ( n = 1 ; n < k ; n++ )

	fstp	ST(1)
	fstp	QWORD PTR [eax]
	jmp	SHORT $LN1587@eval
$LN3171@eval:
	fstp	ST(0)
$LN1587@eval:

; 1760 :          if ( node->op1.intpow < 0 )

	mov	edx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [edx+32]
	test	edx, edx
	jns	$LN1980@eval

; 1761 :          { if ( *stacktop == 0.0 ) 

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN1585@eval

; 1762 :            { if ( valid_id(self_id) )

	test	DWORD PTR _self_id$GSCopy$[ebp], 268435456 ; 10000000H
	je	SHORT $LN1584@eval

; 1763 :                sprintf(errmsg,"Negative power (%d) of zero in %s, %s %s.\n",
; 1764 :                  node->op1.intpow,ex_current.name,
; 1765 :                  typenames[id_type(self_id)],ELNAME(self_id));

	mov	esi, DWORD PTR _self_id$GSCopy$[ebp]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	eax, DWORD PTR _node$[ebp]
	push	OFFSET _elnames
	shr	esi, 29					; 0000001dH
	mov	ecx, DWORD PTR _typenames[esi*4]
	push	ecx
	mov	ecx, DWORD PTR [eax+32]
	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	ecx
	push	OFFSET ??_C@_0CL@MCPCMAIK@Negative?5power?5?$CI?$CFd?$CJ?5of?5zero?5in?5?$CF@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 36					; 00000024H

; 1766 :              else sprintf(errmsg,"Negative power (%d) of zero in %s.\n",

	jmp	SHORT $LN1583@eval
$LN1584@eval:

; 1767 :                  node->op1.intpow,ex_current.name);

	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	edx
	push	OFFSET ??_C@_0CE@DJIGLCFH@Negative?5power?5?$CI?$CFd?$CJ?5of?5zero?5in?5?$CF@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 16					; 00000010H
$LN1583@eval:

; 1768 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1769 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	lea	esi, DWORD PTR [eax+1]
	npad	2
$LL2810@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2810@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1770 :              kb_error(1262,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1262					; 000004eeH
	call	_kb_error
	add	esp, 28					; 0000001cH

; 1771 :            }
; 1772 :            else

	jmp	$LN1980@eval
$LN1585@eval:

; 1773 :              *stacktop = 1/(*stacktop);

	fld1
	fdiv	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]

; 1774 :          } 
; 1775 :          break;

	jmp	$LN1980@eval
$LN1581@eval:

; 1776 : 
; 1777 :       case POW_NODE:
; 1778 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H

; 1779 :         if ( (stacktop[0] < 0.0) && (floor(stacktop[1]) != stacktop[1]) )

	fldz
	mov	esi, DWORD PTR [ebx+48]
	fcomp	QWORD PTR [esi]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN1580@eval
	fld	QWORD PTR [esi+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	fld	QWORD PTR [esi+8]
	add	esp, 8
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN1580@eval

; 1780 :         { if ( valid_id(self_id) )

	mov	esi, DWORD PTR _self_id$GSCopy$[ebp]
	test	esi, 268435456				; 10000000H
	je	SHORT $LN1579@eval

; 1781 :             sprintf(errmsg,
; 1782 :               "Non-integer power of a negative number in %s, %s %s.\n",
; 1783 :               ex_current.name, typenames[id_type(self_id)],ELNAME(self_id));

	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	push	OFFSET _elnames
	shr	esi, 29					; 0000001dH
	mov	ecx, DWORD PTR _typenames[esi*4]
	push	ecx
	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	OFFSET ??_C@_0DG@JFAPMCOO@Non?9integer?5power?5of?5a?5negative?5@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 32					; 00000020H

; 1784 :           else sprintf(errmsg,"Non-integer power of a negative number in %s.\n",

	jmp	SHORT $LN1578@eval
$LN1579@eval:

; 1785 :               ex_current.name);

	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	OFFSET ??_C@_0CP@OEGDEOLM@Non?9integer?5power?5of?5a?5negative?5@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1578@eval:

; 1786 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1787 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL2811@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2811@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1788 :           kb_error(2060,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2060					; 0000080cH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1580@eval:

; 1789 :         }
; 1790 :         if ( stacktop[0] == 0.0 )

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN3177@eval

; 1791 :         { if ( stacktop[1] >= 0.0 ) *stacktop = 0.0;

	fcom	QWORD PTR [esi+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	$LN4014@eval
	fstp	ST(0)

; 1792 :           else *stacktop = 1e30;

	fld	QWORD PTR __real@46293e5939a08cea
	fstp	QWORD PTR [esi]
	jmp	$LN1980@eval
$LN3177@eval:

; 1789 :         }
; 1790 :         if ( stacktop[0] == 0.0 )

	fstp	ST(0)

; 1793 :         }
; 1794 :         else  *stacktop = pow(stacktop[0],stacktop[1]);

	fld	QWORD PTR [esi]
	fld	QWORD PTR [esi+8]
	call	__CIpow
	fstp	QWORD PTR [esi]

; 1795 :         /* Note: pow recognizes integer powers, so OK for neg x */
; 1796 :         break;

	jmp	$LN1980@eval
$LN1573@eval:

; 1797 : 
; 1798 :       case MAXIMUM_NODE:
; 1799 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	ecx, DWORD PTR [ebx+48]

; 1800 :          *stacktop = (stacktop[0] > stacktop[1]) ? stacktop[0] : stacktop[1];

	fld	QWORD PTR [ecx+8]
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2129@eval
	fld	QWORD PTR [ecx]
	mov	eax, ecx
	fstp	QWORD PTR [eax]

; 1801 :         break;

	jmp	$LN1980@eval
$LN2129@eval:

; 1800 :          *stacktop = (stacktop[0] > stacktop[1]) ? stacktop[0] : stacktop[1];

	fld	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 1801 :         break;

	jmp	$LN1980@eval
$LN1572@eval:

; 1802 : 
; 1803 :       case MINIMUM_NODE:
; 1804 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	ecx, DWORD PTR [ebx+48]

; 1805 :          *stacktop = (stacktop[0] < stacktop[1]) ? stacktop[0] : stacktop[1];

	fld	QWORD PTR [ecx+8]
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2131@eval
	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]

; 1806 :         break;

	jmp	$LN1980@eval
$LN2131@eval:

; 1805 :          *stacktop = (stacktop[0] < stacktop[1]) ? stacktop[0] : stacktop[1];

	fld	QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ebx+48]
	fstp	QWORD PTR [ecx]

; 1806 :         break;

	jmp	$LN1980@eval
$LN1571@eval:

; 1807 : 
; 1808 :       case WRAP_COMPOSE_NODE:
; 1809 :           stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H

; 1810 :           if ( sym_compose )

	cmp	DWORD PTR _sym_compose, 0
	mov	ecx, DWORD PTR [ebx+48]
	je	$LN1980@eval

; 1811 :           *stacktop = (REAL)(*sym_compose)((unsigned int)stacktop[0],(unsigned int)stacktop[1]);

	fld	QWORD PTR [ecx+8]
	fnstcw	WORD PTR tv28296[ebp]
	movzx	eax, WORD PTR tv28296[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv28293[ebp], eax
	fldcw	WORD PTR tv28293[ebp]
	fistp	QWORD PTR tv28291[ebp]
	mov	edx, DWORD PTR tv28291[ebp]
	push	edx
	fldcw	WORD PTR tv28296[ebp]
	fld	QWORD PTR [ecx]
	fnstcw	WORD PTR tv28287[ebp]
	movzx	eax, WORD PTR tv28287[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv28284[ebp], eax
	fldcw	WORD PTR tv28284[ebp]
	fistp	QWORD PTR tv28281[ebp]
	mov	eax, DWORD PTR tv28281[ebp]
	push	eax
	fldcw	WORD PTR tv28287[ebp]
	call	DWORD PTR _sym_compose
	mov	ecx, DWORD PTR [ebx+48]
	mov	DWORD PTR tv28278[ebp], eax
	add	esp, 8
	fild	DWORD PTR tv28278[ebp]
	fstp	QWORD PTR [ecx]

; 1812 :           break;

	jmp	$LN1980@eval
$LN1569@eval:

; 1813 : 
; 1814 :       case WRAP_INVERSE_NODE:
; 1815 :           if ( sym_compose )

	cmp	DWORD PTR _sym_compose, 0
	je	$LN1980@eval

; 1816 :           *stacktop = (REAL)(*sym_inverse)((unsigned int)stacktop[0]);

	mov	edx, DWORD PTR [ebx+48]
	fnstcw	WORD PTR tv28276[ebp]
	movzx	eax, WORD PTR tv28276[ebp]
	fld	QWORD PTR [edx]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv28273[ebp], eax
	fldcw	WORD PTR tv28273[ebp]
	fistp	QWORD PTR tv28271[ebp]
	mov	eax, DWORD PTR tv28271[ebp]
	push	eax
	fldcw	WORD PTR tv28276[ebp]
	call	DWORD PTR _sym_inverse
	mov	ecx, DWORD PTR [ebx+48]
	mov	DWORD PTR tv28268[ebp], eax
	add	esp, 4
	fild	DWORD PTR tv28268[ebp]
	fstp	QWORD PTR [ecx]

; 1817 :            break;

	jmp	$LN1980@eval
$LN1567@eval:

; 1818 : 
; 1819 :       case ATAN2_NODE:
; 1820 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	esi, DWORD PTR [ebx+48]

; 1821 :          *stacktop = atan2(stacktop[0],stacktop[1]);

	fld	QWORD PTR [esi]
	fld	QWORD PTR [esi+8]
	call	__CIatan2
	fstp	QWORD PTR [esi]

; 1822 :         break;

	jmp	$LN1980@eval
$LN1566@eval:

; 1823 : 
; 1824 :       case SQR_NODE:
; 1825 :          *stacktop *= *stacktop;

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	fmul	ST(0), ST(0)
	fstp	QWORD PTR [eax]

; 1826 :         break;

	jmp	$LN1980@eval
$LN1565@eval:

; 1827 : 
; 1828 :       case SQRT_NODE:
; 1829 :         if ( *stacktop < 0.0 )

	fldz
	mov	esi, DWORD PTR [ebx+48]
	fcom	QWORD PTR [esi]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN3185@eval

; 1830 :         { if ( *stacktop > -100*machine_eps ) *stacktop = 0.0;

	fld	QWORD PTR _machine_eps
	fmul	QWORD PTR __real@c059000000000000
	fcomp	QWORD PTR [esi]
	fnstsw	ax
	test	ah, 5

; 1831 :           else 

	jnp	$LN4014@eval

; 1832 :           { if ( valid_id(self_id) )

	test	DWORD PTR _self_id$GSCopy$[ebp], 268435456 ; 10000000H
	fstp	ST(0)
	je	SHORT $LN1561@eval

; 1833 :              sprintf(errmsg,"Square root of negative number %g in %s, %s %s.\n",*stacktop,
; 1834 :                ex_current.name,typenames[id_type(self_id)],ELNAME(self_id));

	mov	esi, DWORD PTR _self_id$GSCopy$[ebp]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	edx, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx]
	add	esp, 12					; 0000000cH
	push	OFFSET _elnames
	shr	esi, 29					; 0000001dH
	mov	eax, DWORD PTR _typenames[esi*4]
	push	eax
	lea	ecx, DWORD PTR _ex_current$[ebp+20]
	push	ecx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0DB@GKAOKNCG@Square?5root?5of?5negative?5number?5?$CF@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 28					; 0000001cH

; 1835 :             else 

	jmp	SHORT $LN1560@eval
$LN1561@eval:

; 1836 :              sprintf(errmsg,"Square root of negative number %g in %s.\n",*stacktop,ex_current.name);

	fld	QWORD PTR [esi]
	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CK@LOFDGDAB@Square?5root?5of?5negative?5number?5?$CF@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 20					; 00000014H
$LN1560@eval:

; 1837 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1838 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	lea	esi, DWORD PTR [eax+1]
	npad	7
$LL2812@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2812@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1839 :             kb_error(1263,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1263					; 000004efH
	call	_kb_error
	add	esp, 28					; 0000001cH

; 1840 :           }

	jmp	$LN1980@eval
$LN3185@eval:

; 1827 : 
; 1828 :       case SQRT_NODE:
; 1829 :         if ( *stacktop < 0.0 )

	fstp	ST(0)

; 1841 :         }
; 1842 :         else *stacktop = sqrt(*stacktop);

	fld	QWORD PTR [esi]
	call	__CIsqrt
	fstp	QWORD PTR [esi]

; 1843 :         break;

	jmp	$LN1980@eval
$LN1558@eval:

; 1844 : 
; 1845 :       case CEIL_NODE:
; 1846 :           *stacktop = ceil(*stacktop);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_ceil
	mov	ecx, DWORD PTR [ebx+48]
	fstp	QWORD PTR [ecx]
	add	esp, 8

; 1847 :           break;

	jmp	$LN1980@eval
$LN1557@eval:

; 1848 : 
; 1849 :       case FLOOR_NODE:
; 1850 :           *stacktop = floor(*stacktop);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR [esi]
	add	esp, 8

; 1851 :           break;

	jmp	$LN1980@eval
$LN1556@eval:

; 1852 : 
; 1853 :       case ABS_NODE:
; 1854 :          *stacktop = fabs(*stacktop);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	fabs
	fstp	QWORD PTR [eax]

; 1855 :         break;

	jmp	$LN1980@eval
$LN1555@eval:

; 1856 : 
; 1857 :       case SIN_NODE:
; 1858 :          *stacktop = sin(*stacktop);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__CIsin
	fstp	QWORD PTR [esi]

; 1859 :         break;

	jmp	$LN1980@eval
$LN1554@eval:

; 1860 : 
; 1861 :       case COS_NODE:
; 1862 :          *stacktop = cos(*stacktop);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__CIcos
	fstp	QWORD PTR [esi]

; 1863 :         break;

	jmp	$LN1980@eval
$LN1553@eval:

; 1864 : 
; 1865 :       case TAN_NODE:
; 1866 :          *stacktop = tan(*stacktop);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__CItan
	fstp	QWORD PTR [esi]

; 1867 :         break;

	jmp	$LN1980@eval
$LN1552@eval:

; 1868 : 
; 1869 :       case EXP_NODE:
; 1870 :          *stacktop = exp(*stacktop);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__CIexp
	fstp	QWORD PTR [esi]

; 1871 :         break;

	jmp	$LN1980@eval
$LN1551@eval:

; 1872 : 
; 1873 :       case SINH_NODE:
; 1874 :          *stacktop = (exp(*stacktop)-exp(-*stacktop))/2;

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__CIexp
	fstp	QWORD PTR tv24434[ebp]
	fld	QWORD PTR [esi]
	fchs
	call	__CIexp
	fsubr	QWORD PTR tv24434[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [esi]

; 1875 :         break;

	jmp	$LN1980@eval
$LN1550@eval:

; 1876 : 
; 1877 :       case COSH_NODE:
; 1878 :          *stacktop = (exp(*stacktop)+exp(-*stacktop))/2;

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	fchs
	call	__CIexp
	fstp	QWORD PTR tv24436[ebp]
	fld	QWORD PTR [esi]
	call	__CIexp
	fadd	QWORD PTR tv24436[ebp]
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [esi]

; 1879 :         break;

	jmp	$LN1980@eval
$LN1549@eval:

; 1880 : 
; 1881 :       case TANH_NODE:
; 1882 :          y = exp(*stacktop);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__CIexp

; 1883 :          *stacktop = (y*y-1)/(y*y+1) ;

	fmul	ST(0), ST(0)
	fld	ST(0)
	fld1
	fsub	ST(1), ST(0)
	faddp	ST(2), ST(0)
	fdivrp	ST(1), ST(0)
	fstp	QWORD PTR [esi]

; 1884 :         break;

	jmp	$LN1980@eval
$LN1548@eval:

; 1885 : 
; 1886 :       case ASINH_NODE:
; 1887 :          *stacktop = log(*stacktop + sqrt(*stacktop*(*stacktop) + 1));

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	fmul	ST(0), ST(0)
	fadd	QWORD PTR __real@3ff0000000000000
	call	__CIsqrt
	fadd	QWORD PTR [esi]
	call	__CIlog
	fstp	QWORD PTR [esi]

; 1888 :          break;

	jmp	$LN1980@eval
$LN1547@eval:

; 1889 : 
; 1890 :       case ACOSH_NODE:
; 1891 :          if ( *stacktop < 1.0 )

	fld1
	mov	edx, DWORD PTR [ebx+48]
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN1546@eval

; 1892 :          { if ( valid_id(self_id) )

	test	DWORD PTR _self_id$GSCopy$[ebp], 268435456 ; 10000000H
	je	SHORT $LN1545@eval

; 1893 :              sprintf(errmsg,"Acosh argument less than 1 in %s, %s %s.\n",
; 1894 :                ex_current.name,typenames[id_type(self_id)],ELNAME(self_id));

	mov	esi, DWORD PTR _self_id$GSCopy$[ebp]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	push	OFFSET _elnames
	shr	esi, 29					; 0000001dH
	mov	ecx, DWORD PTR _typenames[esi*4]
	push	ecx
	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	OFFSET ??_C@_0CK@LLHODBDC@Acosh?5argument?5less?5than?51?5in?5?$CFs@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 32					; 00000020H
	jmp	SHORT $LN1544@eval
$LN1545@eval:

; 1895 :            else sprintf(errmsg,"Acosh argument less than 1 in %s.\n",ex_current.name);

	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	OFFSET ??_C@_0CD@HNAOPDML@Acosh?5argument?5less?5than?51?5in?5?$CFs@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1544@eval:

; 1896 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1897 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
$LL2813@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2813@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1898 :            kb_error(2557,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2557					; 000009fdH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1546@eval:

; 1899 :          }
; 1900 :          *stacktop = 2*log(sqrt(*stacktop+1) + sqrt(*stacktop - 1)) - log(2.0);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	fsub	QWORD PTR __real@3ff0000000000000
	call	__CIsqrt
	fstp	QWORD PTR tv24438[ebp]
	fld	QWORD PTR [esi]
	fadd	QWORD PTR __real@3ff0000000000000
	call	__CIsqrt
	fadd	QWORD PTR tv24438[ebp]
	call	__CIlog
	fld	QWORD PTR __real@4000000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv24440[ebp]
	call	__CIlog
	fsubr	QWORD PTR tv24440[ebp]
	fstp	QWORD PTR [esi]

; 1901 :          break;

	jmp	$LN1980@eval
$LN1543@eval:

; 1902 : 
; 1903 :       case ATANH_NODE:
; 1904 :          if ( fabs(*stacktop) >= 1.0 )

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	fabs
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 1
	jne	$LN1542@eval

; 1905 :          { if ( valid_id(self_id) )

	test	DWORD PTR _self_id$GSCopy$[ebp], 268435456 ; 10000000H
	je	SHORT $LN1541@eval

; 1906 :              sprintf(errmsg,
; 1907 :                "Atanh argument magnitude not less than 1 in %s, %s %s.\n",
; 1908 :                 ex_current.name,typenames[id_type(self_id)],ELNAME(self_id));

	mov	esi, DWORD PTR _self_id$GSCopy$[ebp]
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	push	OFFSET _elnames
	shr	esi, 29					; 0000001dH
	mov	edx, DWORD PTR _typenames[esi*4]
	push	edx
	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	OFFSET ??_C@_0DI@PCBKKEME@Atanh?5argument?5magnitude?5not?5les@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 32					; 00000020H

; 1909 :            else

	jmp	SHORT $LN1540@eval
$LN1541@eval:

; 1910 :             sprintf(errmsg,"Atanh argument magnitude not less than 1 in %s.\n",
; 1911 :               ex_current.name);

	lea	ecx, DWORD PTR _ex_current$[ebp+20]
	push	ecx
	push	OFFSET ??_C@_0DB@MOMMLDEO@Atanh?5argument?5magnitude?5not?5les@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1540@eval:

; 1912 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1913 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
$LL2814@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2814@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1914 :            kb_error(2559,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2559					; 000009ffH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1542@eval:

; 1915 :          }
; 1916 :          *stacktop = log(*stacktop+1)/2 - log(1-*stacktop)/2; 

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	fadd	QWORD PTR __real@3ff0000000000000
	call	__CIlog
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR tv24442[ebp]
	fld1
	fsub	QWORD PTR [esi]
	call	__CIlog
	fmul	QWORD PTR __real@3fe0000000000000
	fsubr	QWORD PTR tv24442[ebp]
	fstp	QWORD PTR [esi]

; 1917 :          break;

	jmp	$LN1980@eval
$LN1539@eval:

; 1918 : 
; 1919 :       case LOG_NODE:
; 1920 :          if ( *stacktop <= 0.0 )

	mov	eax, DWORD PTR [ebx+48]
	fldz
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 1
	jne	$LN1538@eval

; 1921 :          { if ( valid_id(self_id) )

	test	DWORD PTR _self_id$GSCopy$[ebp], 268435456 ; 10000000H
	je	SHORT $LN1537@eval

; 1922 :              sprintf(errmsg,"Log of zero or negative number in %s, %s %s.\n",
; 1923 :                ex_current.name,typenames[id_type(self_id)],ELNAME(self_id));

	mov	esi, DWORD PTR _self_id$GSCopy$[ebp]
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	push	OFFSET _elnames
	shr	esi, 29					; 0000001dH
	mov	edx, DWORD PTR _typenames[esi*4]
	push	edx
	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	OFFSET ??_C@_0CO@OHNNCNNA@Log?5of?5zero?5or?5negative?5number?5i@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 32					; 00000020H

; 1924 :            else sprintf(errmsg,"Log of zero or negative number in %s.\n",

	jmp	SHORT $LN1536@eval
$LN1537@eval:

; 1925 :               ex_current.name);

	lea	ecx, DWORD PTR _ex_current$[ebp+20]
	push	ecx
	push	OFFSET ??_C@_0CH@GIHCGDLE@Log?5of?5zero?5or?5negative?5number?5i@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1536@eval:

; 1926 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1927 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL2815@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2815@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1928 :            kb_error(1264,errmsg, RECOVERABLE );

	push	1
	push	OFFSET _errmsg
	push	1264					; 000004f0H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1538@eval:

; 1929 :          }
; 1930 :          *stacktop = log(*stacktop);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__CIlog
	fstp	QWORD PTR [esi]

; 1931 :         break;

	jmp	$LN1980@eval
$LN1535@eval:

; 1932 : 
; 1933 :       case ASIN_NODE:
; 1934 :          if ( *stacktop > 1.0 ) *stacktop = asin(1.0);

	fld1
	mov	esi, DWORD PTR [ebx+48]
	fcom	QWORD PTR [esi]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3191@eval
	call	__CIasin
	fstp	QWORD PTR [esi]
	jmp	$LN1980@eval
$LN3191@eval:
	fstp	ST(0)

; 1935 :          else if ( *stacktop < -1.0 ) *stacktop = asin(-1.0);

	fld	QWORD PTR __real@bff0000000000000
	fcom	QWORD PTR [esi]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3194@eval
	call	__CIasin
	fstp	QWORD PTR [esi]
	jmp	$LN1980@eval
$LN3194@eval:
	fstp	ST(0)

; 1936 :          else *stacktop = asin(*stacktop);

	fld	QWORD PTR [esi]
	call	__CIasin
	fstp	QWORD PTR [esi]

; 1937 :         break;

	jmp	$LN1980@eval
$LN1530@eval:

; 1938 : 
; 1939 :       case ACOS_NODE:
; 1940 :          if ( *stacktop > 1.0 ) *stacktop = 0.0;

	fld1
	mov	esi, DWORD PTR [ebx+48]
	fcomp	QWORD PTR [esi]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1529@eval
$LN1897@eval:
	fldz
	fstp	QWORD PTR [esi]
	jmp	$LN1980@eval
$LN1529@eval:

; 1941 :          else if ( *stacktop < -1.0 ) *stacktop = M_PI;

	fld	QWORD PTR __real@bff0000000000000
	fcomp	QWORD PTR [esi]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1527@eval
	fld	QWORD PTR __real@400921fb54442d18
	fstp	QWORD PTR [esi]
	jmp	$LN1980@eval
$LN1527@eval:

; 1942 :          else *stacktop = acos(*stacktop);

	fld	QWORD PTR [esi]
	call	__CIacos
	fstp	QWORD PTR [esi]

; 1943 :         break;

	jmp	$LN1980@eval
$LN1525@eval:

; 1944 : 
; 1945 :       case ATAN_NODE:
; 1946 :          *stacktop = atan(*stacktop);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__CIatan
	fstp	QWORD PTR [esi]

; 1947 :         break;

	jmp	$LN1980@eval
$LN1524@eval:

; 1948 :       
; 1949 :       case ELLIPTICK_NODE:
; 1950 :          *stacktop = ellipticK(*stacktop);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_ellipticK
	mov	ecx, DWORD PTR [ebx+48]
	fstp	QWORD PTR [ecx]
	add	esp, 8

; 1951 :         break;

	jmp	$LN1980@eval
$LN1523@eval:

; 1952 : 
; 1953 :       case ELLIPTICE_NODE:
; 1954 :          *stacktop = ellipticE(*stacktop);

	mov	edx, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_ellipticE
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	add	esp, 8

; 1955 :         break;

	jmp	$LN1980@eval
$LN1522@eval:

; 1956 : 
; 1957 :       case INCOMPLETE_ELLIPTICF_NODE:
; 1958 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	eax, DWORD PTR [ebx+48]

; 1959 :          *stacktop = incompleteEllipticF(stacktop[0],stacktop[1]);

	fld	QWORD PTR [eax+8]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [eax]
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticF
	mov	ecx, DWORD PTR [ebx+48]
	fstp	QWORD PTR [ecx]
	add	esp, 16					; 00000010H

; 1960 :         break;

	jmp	$LN1980@eval
$LN1521@eval:

; 1961 : 
; 1962 :       case INCOMPLETE_ELLIPTICE_NODE:
; 1963 :         stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	eax, DWORD PTR [ebx+48]

; 1964 :          *stacktop = incompleteEllipticE(stacktop[0],stacktop[1]);

	fld	QWORD PTR [eax+8]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [eax]
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticE
	mov	edx, DWORD PTR [ebx+48]
	fstp	QWORD PTR [edx]
	add	esp, 16					; 00000010H

; 1965 :         break;

	jmp	$LN1980@eval
$LN1520@eval:

; 1966 : 
; 1967 :       case CHS_NODE:
; 1968 :          *stacktop = -*stacktop;

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	fchs
	fstp	QWORD PTR [eax]

; 1969 :         break;

	jmp	$LN1980@eval
$LN1519@eval:

; 1970 :       
; 1971 :       case INV_NODE:
; 1972 :          if ( *stacktop == 0.0 )

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN1518@eval

; 1973 :          { if ( valid_id(self_id) )

	test	DWORD PTR _self_id$GSCopy$[ebp], 268435456 ; 10000000H
	je	SHORT $LN1517@eval

; 1974 :              sprintf(errmsg,"Division by zero in %s, %s %s.\n",ex_current.name,
; 1975 :              typenames[id_type(self_id)],ELNAME(self_id));

	mov	esi, DWORD PTR _self_id$GSCopy$[ebp]
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	push	OFFSET _elnames
	shr	esi, 29					; 0000001dH
	mov	edx, DWORD PTR _typenames[esi*4]
	push	edx
	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	OFFSET ??_C@_0CA@MCBMPDHE@Division?5by?5zero?5in?5?$CFs?0?5?$CFs?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 32					; 00000020H
	jmp	SHORT $LN1516@eval
$LN1517@eval:

; 1976 :            else sprintf(errmsg,"Division by zero in %s.\n",ex_current.name);

	lea	ecx, DWORD PTR _ex_current$[ebp+20]
	push	ecx
	push	OFFSET ??_C@_0BJ@DKCGOBDB@Division?5by?5zero?5in?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN1516@eval:

; 1977 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1978 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
$LL2816@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2816@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1979 :            kb_error(2560,errmsg,RECOVERABLE); 

	push	1
	push	OFFSET _errmsg
	push	2560					; 00000a00H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1518@eval:

; 1980 :          }
; 1981 :          *stacktop = 1/(*stacktop);

	mov	eax, DWORD PTR [ebx+48]
	fld1
	fdiv	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 1982 :         break;

	jmp	$LN1980@eval
$LN1515@eval:

; 1983 : 
; 1984 :       /* here are attributes for queries */
; 1985 :       case COORD_NODE:
; 1986 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1514@eval

; 1987 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1513@eval
$LN1514@eval:

; 1988 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1513@eval:

; 1989 :         switch ( id_type(id) )

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	sub	ecx, 0
	je	SHORT $LN1510@eval
	dec	ecx
	je	SHORT $LN1509@eval
	dec	ecx
	jne	$LN1980@eval

; 1996 :              break;
; 1997 :           case FACET:
; 1998 :              get_facet_normal(id,vect);

	lea	ecx, DWORD PTR _vect$[ebp]
	push	ecx
	push	eax
	call	_get_facet_normal
	add	esp, 8

; 1999 :              *++stacktop = vect[node->op2.coordnum];

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [edx+136]
	fld	QWORD PTR _vect$[ebp+ecx*8]
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
$adfadf_1$92124:
	jmp	$LN1980@eval
$LN1509@eval:

; 1992 :              break;
; 1993 :           case EDGE:
; 1994 :              get_edge_side(id,vect);

	lea	edx, DWORD PTR _vect$[ebp]
	push	edx
	push	eax
	call	_get_edge_side
	add	esp, 8

; 1995 :              *++stacktop = vect[node->op2.coordnum];

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	fld	QWORD PTR _vect$[ebp+edx*8]
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
$adfadf_2$92124:
	jmp	$LN1980@eval
$LN1510@eval:

; 1990 :         { case VERTEX:
; 1991 :              *++stacktop = get_coord(id)[node->op2.coordnum];

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR _web+12
	mov	esi, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ebx+48]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [esi+edx+64]
	mov	edx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [edx+136]
	fld	QWORD PTR [eax+edx*8]
	fstp	QWORD PTR [ecx]

; 2000 :              break;
; 2001 :          }
; 2002 :         break;

	jmp	$LN1980@eval
$LN1507@eval:

; 2003 : 
; 2004 :       case INDEXED_COORD_NODE:
; 2005 :       { int k = (int)*stacktop - 1;  /* 1 based indexing */

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	mov	esi, eax
	dec	esi

; 2006 :         if ( k < 0 || k >= SDIM )

	js	SHORT $LN1505@eval
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LN1506@eval
$LN1505@eval:

; 2007 :         { sprintf(errmsg,
; 2008 :          "Invalid index %d for x in %s; must be between 1 and %d, inclusive.\n",
; 2009 :             k+1,ex_current.name,SDIM);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	lea	eax, DWORD PTR [esi+1]
	push	eax
	push	OFFSET ??_C@_0EE@NBEFOKMP@Invalid?5index?5?$CFd?5for?5x?5in?5?$CFs?$DL?5mu@
	push	OFFSET _errmsg
	call	_sprintf

; 2010 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2011 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 20					; 00000014H
	lea	edi, DWORD PTR [eax+1]
	npad	6
$LL2817@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2817@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, edi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2012 :           kb_error(2061,errmsg,RECOVERABLE );

	push	1
	push	OFFSET _errmsg
	push	2061					; 0000080dH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1506@eval:

; 2013 :         }
; 2014 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1504@eval

; 2015 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1503@eval
$LN1504@eval:

; 2016 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1503@eval:

; 2017 :         switch( id_type(id) )

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	mov	edx, ecx
	sub	edx, 0
	je	$LN1500@eval
	dec	edx
	je	$LN1499@eval
	dec	edx
	je	SHORT $LN1498@eval

; 2029 :           default: 
; 2030 :              sprintf(errmsg,"Can't have indexed x on %s, in %s.\n",
; 2031 :                typenames[id_type(id)], ex_current.name);

	mov	ecx, DWORD PTR _typenames[ecx*4]
	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	ecx
	push	OFFSET ??_C@_0CE@JGNMBEAC@Can?8t?5have?5indexed?5x?5on?5?$CFs?0?5in?5?$CF@
	push	OFFSET _errmsg
	call	_sprintf

; 2032 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2033 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	esi, DWORD PTR [eax+1]
	npad	7
$LL2818@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2818@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2034 :              kb_error(2062,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2062					; 0000080eH
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	$LN1980@eval
$LN1498@eval:

; 2025 :           case FACET:
; 2026 :              get_facet_normal(id,vect);

	lea	ecx, DWORD PTR _vect$[ebp]
	push	ecx
	push	eax
	call	_get_facet_normal

; 2027 :              *stacktop = vect[k];

	fld	QWORD PTR _vect$[ebp+esi*8]
	mov	edx, DWORD PTR [ebx+48]
	fstp	QWORD PTR [edx]
	add	esp, 8

; 2028 :              break;

	jmp	$LN1980@eval
$LN1499@eval:

; 2020 :              break;
; 2021 :           case EDGE:
; 2022 :              get_edge_side(id,vect);

	lea	ecx, DWORD PTR _vect$[ebp]
	push	ecx
	push	eax
	call	_get_edge_side

; 2023 :              *stacktop = vect[k];

	fld	QWORD PTR _vect$[ebp+esi*8]
	mov	edx, DWORD PTR [ebx+48]
	fstp	QWORD PTR [edx]
	add	esp, 8

; 2024 :              break;

	jmp	$LN1980@eval
$LN1500@eval:

; 2018 :          { case VERTEX:
; 2019 :              *stacktop = get_coord(id)[k];

	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	add	edx, DWORD PTR [ecx+eax+64]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx+esi*8]
	fstp	QWORD PTR [eax]

; 2035 :          }
; 2036 :        }
; 2037 :        break;

	jmp	$LN1980@eval
$LN1496@eval:

; 2038 : 
; 2039 :       case PRINT_VERTEXNORMAL_NODE:
; 2040 :          { MAT2D(normal,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	ecx, DWORD PTR _normalxJ$90304[ebp]
	push	ecx
	lea	edx, DWORD PTR _normalqXvS$90303[ebp]
	push	edx
	call	_mat2d_setup
	mov	esi, eax

; 2041 :            REAL mag;
; 2042 :            int i;
; 2043 :            int normcount;
; 2044 : 
; 2045 :            if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _normal$90305[ebp], esi
	test	eax, eax
	je	SHORT $LN1495@eval

; 2046 :              id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1494@eval
$LN1495@eval:

; 2047 :            else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1494@eval:

; 2048 :            normcount = new_calc_vertex_normal(id,normal); 

	push	esi
	push	eax
	call	_new_calc_vertex_normal

; 2049 :         //   project_vertex_normals(id,normal,normcount);
; 2050 :            mag = sqrt(SDIM_dot(normal[0],normal[0]));

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	eax
	push	eax
	call	_dot
	add	esp, 20					; 00000014H
	call	__CIsqrt
	fst	QWORD PTR _mag$90307[ebp]

; 2051 :            if ( mag == 0.0 ) 

	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1493@eval

; 2052 :            { mag = 1; memset(normal[0],0,SDIM*sizeof(REAL));}

	mov	edx, DWORD PTR _web+616
	fld1
	mov	ecx, DWORD PTR [esi]
	fstp	QWORD PTR _mag$90307[ebp]
	lea	eax, DWORD PTR [edx*8]
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN1493@eval:

; 2053 :            sprintf(msg,"{");

	mov	edx, DWORD PTR _msg
	push	OFFSET ??_C@_01HCONENDN@?$HL?$AA@
	push	edx
	call	_sprintf

; 2054 :            for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	add	esp, 8
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN1490@eval
$LN1492@eval:

; 2055 :            { if ( i > 0 ) strcat(msg,",");

	test	esi, esi
	jle	SHORT $LN1489@eval
	mov	edi, DWORD PTR _msg
	dec	edi
$LL2819@eval:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL2819@eval
	mov	ax, WORD PTR ??_C@_01IHBHIGKO@?0?$AA@
	mov	WORD PTR [edi], ax
$LN1489@eval:

; 2056 : #ifdef FLOAT128
; 2057 :              sprintf(msg+strlen(msg),"%#*.*Qf",DWIDTH,DPREC,normal[0][i]/mag); 
; 2058 : #elif defined(LONGDOUBLE)
; 2059 :              sprintf(msg+strlen(msg),"%#*.*Lf",DWIDTH,DPREC,normal[0][i]/mag); 
; 2060 : #else
; 2061 :              sprintf(msg+strlen(msg),"%17.15g",normal[0][i]/mag); 

	mov	edx, DWORD PTR _msg
	mov	eax, edx
	lea	edi, DWORD PTR [eax+1]
$LL2820@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2820@eval
	mov	ecx, DWORD PTR _normal$90305[ebp]
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [ecx+esi*8]
	sub	esp, 8
	fdiv	QWORD PTR _mag$90307[ebp]
	sub	eax, edi
	add	eax, edx
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_07CFKABON@?$CF17?415g?$AA@
	push	eax
	call	_sprintf
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LN1492@eval
$LN1490@eval:

; 2062 : #endif
; 2063 :            }
; 2064 :            strcat(msg,"}\n");

	mov	eax, DWORD PTR _msg
	dec	eax
$LL2821@eval:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2821@eval
	mov	dx, WORD PTR ??_C@_02KGHIDFGE@?$HN?6?$AA@
	mov	WORD PTR [eax], dx
	mov	cl, BYTE PTR ??_C@_02KGHIDFGE@?$HN?6?$AA@+2
	mov	BYTE PTR [eax+2], cl

; 2065 :            outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 4

; 2066 :            break;

	jmp	$LN1980@eval
$LN1488@eval:

; 2067 :          }
; 2068 : 
; 2069 :       case GET_VERTEXNORMAL_NODE:     
; 2070 :          { MAT2D(normal,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _normalxJ$90325[ebp]
	push	eax
	lea	ecx, DWORD PTR _normalqXvS$90324[ebp]
	push	ecx
	call	_mat2d_setup

; 2071 :            int k = (int)*stacktop - 1;  /* 1 based indexing */

	mov	edx, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx]
	add	esp, 16					; 00000010H
	mov	edi, eax
	call	__ftol2_sse
	mov	esi, eax
	dec	esi

; 2072 :            REAL mag;
; 2073 :            int normcount;
; 2074 : 
; 2075 :            if ( k < 0 || k >= SDIM )

	mov	eax, DWORD PTR _web+616
	js	SHORT $LN1486@eval
	cmp	esi, eax
	jl	SHORT $LN1487@eval
$LN1486@eval:

; 2076 :              { sprintf(errmsg,
; 2077 :         "Invalid index %d for vertexnormal in %s; must be between 1 and %d.\n",
; 2078 :                  k+1,ex_current.name,SDIM);

	push	eax
	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	lea	ecx, DWORD PTR [esi+1]
	push	ecx
	push	OFFSET ??_C@_0EE@DJGKMPPD@Invalid?5index?5?$CFd?5for?5vertexnorma@
	push	OFFSET _errmsg
	call	_sprintf

; 2079 :                sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2080 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL2822@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2822@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2081 :                kb_error(2063,errmsg,RECOVERABLE );

	push	1
	push	OFFSET _errmsg
	push	2063					; 0000080fH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1487@eval:

; 2082 :              }
; 2083 :            if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1485@eval

; 2084 :              id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1484@eval
$LN1485@eval:

; 2085 :            else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1484@eval:

; 2086 :            normcount = new_calc_vertex_normal(id,normal); 

	push	edi
	push	eax
	call	_new_calc_vertex_normal

; 2087 :       //     project_vertex_normals(id,normal,normcount);
; 2088 :            mag = sqrt(SDIM_dot(normal[0],normal[0]));

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [edi]
	push	ecx
	push	eax
	push	eax
	call	_dot
	add	esp, 20					; 00000014H
	call	__CIsqrt

; 2089 :            *stacktop = mag == 0.0 ? 0.0 : normal[0][k]/mag;

	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN3197@eval
	mov	eax, DWORD PTR [ebx+48]
	fstp	ST(1)
	fstp	QWORD PTR [eax]

; 2090 :          }
; 2091 :         break;

	jmp	$LN1980@eval
$LN3197@eval:

; 2089 :            *stacktop = mag == 0.0 ? 0.0 : normal[0][k]/mag;

	mov	edx, DWORD PTR [edi]
	fstp	ST(0)
	fdivr	QWORD PTR [edx+esi*8]
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 2090 :          }
; 2091 :         break;

	jmp	$LN1980@eval
$LN1483@eval:

; 2092 : 
; 2093 :       case PARAM_NODE:
; 2094 :         if ( node->op1.localnum ) 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN1482@eval

; 2095 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+40]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN1481@eval
$LN1482@eval:

; 2096 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1481@eval:

; 2097 :          *++stacktop = get_param(id)[node->op2.coordnum];

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR _web+12
	mov	esi, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ebx+48]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [esi+edx+544]
	mov	edx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [edx+136]
	fld	QWORD PTR [eax+edx*8]
	fstp	QWORD PTR [ecx]

; 2098 :         break;

	jmp	$LN1980@eval
$LN1480@eval:

; 2099 : 
; 2100 : 
; 2101 :       case GET_SQ_MEAN_CURV_NODE:
; 2102 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1479@eval

; 2103 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1478@eval
$LN1479@eval:

; 2104 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1478@eval:

; 2105 :          *++stacktop = vertex_sq_mean_curvature(id);

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	call	_vertex_sq_mean_curvature
	fstp	QWORD PTR [esi]
	add	esp, 4

; 2106 :         break;

	jmp	$LN1980@eval
$LN1477@eval:

; 2107 : 
; 2108 :       case GET_FIXEDVOL_NODE:
; 2109 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1476@eval

; 2110 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1475@eval
$LN1476@eval:

; 2111 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1475@eval:

; 2112 :          *++stacktop = get_battr(id)&FIXEDVOL ? 1.0 : 0.0;

	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1474@eval:

; 2113 :         break;
; 2114 : 
; 2115 :       case GET_CENTEROFMASS_NODE:
; 2116 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1473@eval

; 2117 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1472@eval
$LN1473@eval:

; 2118 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1472@eval:

; 2119 :          *++stacktop = get_battr(id)&WANT_CENTEROFMASS ? 1.0 : 0.0;

	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 2
	xor	eax, eax
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1471@eval:

; 2120 :         break;
; 2121 : 
; 2122 :       case GET_MEANCURV_NODE:
; 2123 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1470@eval

; 2124 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1469@eval
$LN1470@eval:

; 2125 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1469@eval:

; 2126 :          *++stacktop = vertex_mean_curvature(id);

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	call	_vertex_mean_curvature
	fstp	QWORD PTR [esi]
	add	esp, 4

; 2127 :         break;

	jmp	$LN1980@eval
$LN1468@eval:

; 2128 : 
; 2129 :       case GET_LENGTH_NODE:
; 2130 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1467@eval

; 2131 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	edi, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1466@eval
$LN1467@eval:

; 2132 :         else id = q_id;

	mov	edi, DWORD PTR _q_id$[ebp]
$LN1466@eval:

; 2133 :         if ( web.representation != STRING ) calc_edge(id);

	cmp	DWORD PTR _web+624, 1
	je	SHORT $LN1465@eval
	push	edi
	call	_calc_edge
	add	esp, 4
$LN1465@eval:

; 2134 :          *++stacktop = get_edge_length(id);

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	edi
	call	_get_edge_length
	fstp	QWORD PTR [esi]
	add	esp, 4

; 2135 :         break;

	jmp	$LN1980@eval
$LN1464@eval:

; 2136 : 
; 2137 :       case GET_DIHEDRAL_NODE:
; 2138 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1463@eval

; 2139 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1462@eval
$LN1463@eval:

; 2140 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1462@eval:

; 2141 :         if ( id_type(id) == EDGE ) *++stacktop = dihedral(id);

	add	DWORD PTR [ebx+48], 8
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	cmp	ecx, 1
	jne	SHORT $LN1461@eval
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	call	_dihedral
	fstp	QWORD PTR [esi]
	add	esp, 4
	jmp	$LN1980@eval
$LN1461@eval:

; 2142 :         else if ( id_type(id) == VERTEX ) *++stacktop = vertex_angle(id);

	test	ecx, ecx
	jne	$LN1459@eval
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	call	_vertex_angle
	fstp	QWORD PTR [esi]
	add	esp, 4
	jmp	$LN1980@eval
$LN1457@eval:

; 2143 :         else *++stacktop = 0.0;
; 2144 :         break;
; 2145 : 
; 2146 :       case GET_ORIENTATION_NODE:
; 2147 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1456@eval

; 2148 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1455@eval
$LN1456@eval:

; 2149 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1455@eval:

; 2150 :         *++stacktop = (get_attr(id) & NEGBOUNDARY) ? -1.0 : 1.0;

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN2085@eval
	add	DWORD PTR [ebx+48], 8
	fld	QWORD PTR __real@bff0000000000000
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1454@eval:

; 2151 :         break;
; 2152 : 
; 2153 :       case VALENCE_NODE:
; 2154 :       case GET_VALENCE_NODE:
; 2155 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1453@eval

; 2156 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1452@eval
$LN1453@eval:

; 2157 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1452@eval:

; 2158 :         switch ( id_type(id) )

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	cmp	ecx, 3
	ja	$LN1980@eval
	jmp	DWORD PTR $LN4031@eval[ecx*4]
$LN1449@eval:

; 2159 :          { case VERTEX:
; 2160 :               if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3

; 2161 :                 *++stacktop = (REAL)get_vertex_fvalence(id);

	push	eax
	jne	SHORT $LN1448@eval
	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	call	_get_vertex_fvalence
	mov	DWORD PTR tv27768[ebp], eax
	fild	DWORD PTR tv27768[ebp]
	add	esp, 4
	fstp	QWORD PTR [esi]
	jmp	$LN1980@eval
$LN1448@eval:

; 2162 :               else 
; 2163 :                 *++stacktop = (REAL)get_vertex_evalence(id);

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	call	_get_vertex_evalence
	mov	DWORD PTR tv27766[ebp], eax
	fild	DWORD PTR tv27766[ebp]
	add	esp, 4
	fstp	QWORD PTR [esi]
	jmp	$LN1980@eval
$LN1446@eval:

; 2164 :               break;
; 2165 :             case EDGE:
; 2166 :               *++stacktop = (REAL)get_edge_valence(id);

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	call	_get_edge_valence
	mov	DWORD PTR tv27764[ebp], eax
	fild	DWORD PTR tv27764[ebp]
	add	esp, 4
	fstp	QWORD PTR [esi]
	jmp	$LN1980@eval
$LN1445@eval:

; 2167 :               break;
; 2168 :             case FACET:
; 2169 :               *++stacktop = (REAL)get_facet_valence(id);

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	call	_get_facet_valence
	mov	DWORD PTR tv27762[ebp], eax
	fild	DWORD PTR tv27762[ebp]
	add	esp, 4
	fstp	QWORD PTR [esi]
	jmp	$LN1980@eval
$LN1444@eval:

; 2170 :               break;
; 2171 :             case BODY:
; 2172 :               *++stacktop = (REAL)get_body_valence(id);

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	call	_get_body_valence
	mov	DWORD PTR tv27760[ebp], eax
	fild	DWORD PTR tv27760[ebp]
	add	esp, 4
	fstp	QWORD PTR [esi]

; 2173 :               break;
; 2174 :          }
; 2175 :         break;

	jmp	$LN1980@eval
$LN1443@eval:

; 2176 : 
; 2177 :       case GET_EDGE_NODE:
; 2178 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1442@eval

; 2179 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1441@eval
$LN1442@eval:

; 2180 :         else id = q_id;

	mov	esi, DWORD PTR _q_id$[ebp]
$LN1441@eval:

; 2181 :          *++stacktop = (REAL)(ordinal(get_fe_edge(id))+1);

	push	esi
	call	_get_fe_edge
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2151@eval
	push	esi
	call	_get_fe_edge
	add	esp, 4
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN2152@eval
$LN2151@eval:
	or	eax, -1
$LN2152@eval:
	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [ebx+48]
	inc	eax
	mov	DWORD PTR tv27756[ebp], eax
	fild	DWORD PTR tv27756[ebp]
	fstp	QWORD PTR [ecx]

; 2182 :         break;

	jmp	$LN1980@eval
$LN1440@eval:

; 2183 : 
; 2184 :       case GET_FACET_NODE:
; 2185 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1439@eval

; 2186 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1438@eval
$LN1439@eval:

; 2187 :         else id = q_id;

	mov	esi, DWORD PTR _q_id$[ebp]
$LN1438@eval:

; 2188 :          *++stacktop = (REAL)(ordinal(get_fe_facet(id))+1);

	push	esi
	call	_get_fe_facet
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2153@eval
	push	esi
	call	_get_fe_facet
	add	esp, 4
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN2154@eval
$LN2153@eval:
	or	eax, -1
$LN2154@eval:
	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [ebx+48]
	inc	eax
	mov	DWORD PTR tv27752[ebp], eax
	fild	DWORD PTR tv27752[ebp]
	fstp	QWORD PTR [ecx]

; 2189 :         break;

	jmp	$LN1980@eval
$LN1437@eval:

; 2190 : 
; 2191 :       case AREA_NODE:
; 2192 :       case GET_AREA_NODE:
; 2193 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1436@eval

; 2194 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1435@eval
$LN1436@eval:

; 2195 :         else id = q_id;

	mov	esi, DWORD PTR _q_id$[ebp]
$LN1435@eval:

; 2196 :         *++stacktop = get_facet_area(id);

	push	esi
	call	_recalc_facet_area
	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR _web+236
	mov	eax, DWORD PTR [ebx+48]
	add	esp, 4
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	fld	QWORD PTR [edx+40]
	fstp	QWORD PTR [eax]

; 2197 :         break;

	jmp	$LN1980@eval
$LN1434@eval:

; 2198 : 
; 2199 :       case GET_MID_EDGE_NODE:
; 2200 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1433@eval

; 2201 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1432@eval
$LN1433@eval:

; 2202 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1432@eval:

; 2203 :         *++stacktop = get_vattr(id) & (Q_MIDEDGE|Q_MIDPOINT) ? 1.0 : 0.0; 

	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 4325376				; 00420000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1431@eval:

; 2204 :         break;
; 2205 : 
; 2206 :       case GET_MID_FACET_NODE:
; 2207 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1430@eval

; 2208 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1429@eval
$LN1430@eval:

; 2209 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1429@eval:

; 2210 :         *++stacktop = get_vattr(id) & Q_MIDFACET ? 1.0 : 0.0; 

	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2097152				; 00200000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1428@eval:

; 2211 :         break;
; 2212 : 
; 2213 :       case GET_WRAP_NODE:
; 2214 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1427@eval

; 2215 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1426@eval
$LN1427@eval:

; 2216 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1426@eval:

; 2217 :         *++stacktop = web.symmetry_flag ? (REAL)get_edge_wrap(id) : 0; 

	cmp	DWORD PTR _web+856, 0
	je	$LN2093@eval
	push	eax
	call	_get_edge_wrap
	mov	DWORD PTR tv27717[ebp], eax
	fild	DWORD PTR tv27717[ebp]
	add	esp, 4
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1425@eval:

; 2218 :         break;
; 2219 : 
; 2220 :       case GET_PRESSURE_NODE:
; 2221 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1424@eval

; 2222 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1423@eval
$LN1424@eval:

; 2223 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1423@eval:

; 2224 :         switch ( id_type(id) )

	mov	ecx, eax
	and	ecx, -536870912				; e0000000H
	cmp	ecx, 1610612736				; 60000000H
	je	SHORT $LN1420@eval

; 2227 :              default: 
; 2228 :               sprintf(errmsg,"Pressure only for bodies, in %s.\n",ex_current.name);

	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	OFFSET ??_C@_0CC@MAFBFHON@Pressure?5only?5for?5bodies?0?5in?5?$CFs?4@
	push	OFFSET _errmsg
	call	_sprintf

; 2229 :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2230 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
$LL2823@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2823@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2231 :               kb_error(1267,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1267					; 000004f3H
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	$LN1980@eval
$LN1420@eval:

; 2225 :           { 
; 2226 :              case BODY: *++stacktop = get_body_pressure(id); break;

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	call	_get_body_pressure
	fstp	QWORD PTR [esi]
	add	esp, 4

; 2232 : 
; 2233 :           }
; 2234 :         break;

	jmp	$LN1980@eval
$LN1418@eval:

; 2235 : 
; 2236 :       case GET_QUANTITY_NODE:
; 2237 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1417@eval

; 2238 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	edi, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1416@eval
$LN1417@eval:

; 2239 :         else id = q_id;

	mov	edi, DWORD PTR _q_id$[ebp]
$LN1416@eval:

; 2240 :         if ( !valid_id(id) )

	test	edi, 268435456				; 10000000H
	jne	$LN1415@eval

; 2241 :         { sprintf(errmsg,
; 2242 :            "Quantity name '%s' needs attribute like .value (in %s)\n",
; 2243 :                GEN_QUANT(node->op2.quant_id)->name,ex_current.name);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	imul	edx, 368				; 00000170H
	add	edx, DWORD PTR _gen_quant_list
	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	edx
	push	OFFSET ??_C@_0DI@DLLIPIEC@Quantity?5name?5?8?$CFs?8?5needs?5attribu@
	push	OFFSET _errmsg
	call	_sprintf

; 2244 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2245 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL2824@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2824@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2246 :           kb_error(2064,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2064					; 00000810H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1415@eval:

; 2247 :         }
; 2248 :         *++stacktop = quantity_attribute(id,node->op2.quant_id);

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	esi, DWORD PTR [ebx+48]
	push	ecx
	push	edi
	call	_quantity_attribute
	fstp	QWORD PTR [esi]
	add	esp, 8

; 2249 :         break;

	jmp	$LN1980@eval
$LN1414@eval:

; 2250 : 
; 2251 :       case GET_INSTANCE_NODE:
; 2252 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1413@eval

; 2253 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	edi, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1412@eval
$LN1413@eval:

; 2254 :         else id = q_id;

	mov	edi, DWORD PTR _q_id$[ebp]
$LN1412@eval:

; 2255 :         if ( !valid_id(id) )

	test	edi, 268435456				; 10000000H
	jne	$LN1411@eval

; 2256 :         { sprintf(errmsg,
; 2257 :            "Instance name '%s' needs attribute like .value (in %s)\n",
; 2258 :              METH_INSTANCE(node->op2.meth_id)->name,ex_current.name);

	mov	ecx, DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	mov	eax, DWORD PTR [ecx+136]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list
	push	eax
	push	OFFSET ??_C@_0DI@FIBFOHNK@Instance?5name?5?8?$CFs?8?5needs?5attribu@
	push	OFFSET _errmsg
	call	_sprintf

; 2259 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2260 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL2825@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2825@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2261 :           kb_error(2065,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2065					; 00000811H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1411@eval:

; 2262 :         }
; 2263 :         *++stacktop = instance_attribute(id,node->op2.meth_id);

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	esi, DWORD PTR [ebx+48]
	push	ecx
	push	edi
	call	_instance_attribute
	fstp	QWORD PTR [esi]
	add	esp, 8

; 2264 :         break;

	jmp	$LN1980@eval
$LN1410@eval:

; 2265 : 
; 2266 :       case GET_PHASE_NODE:
; 2267 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	xor	edx, edx
	cmp	eax, edx
	je	SHORT $LN1409@eval

; 2268 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	mov	eax, DWORD PTR [eax+ecx*8]
	jmp	SHORT $LN1408@eval
$LN1409@eval:

; 2269 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1408@eval:

; 2270 :         switch ( id_type(id) )

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	sub	ecx, 2
	je	$LN1405@eval
	dec	ecx
	je	SHORT $LN1404@eval

; 2274 :              default: 
; 2275 :                sprintf(errmsg,"Phase of wrong type element in %s.\n",ex_current.name);

	lea	ecx, DWORD PTR _ex_current$[ebp+20]
	push	ecx
	push	OFFSET ??_C@_0CE@HKCJIFBL@Phase?5of?5wrong?5type?5element?5in?5?$CF@
	push	OFFSET _errmsg
	call	_sprintf

; 2276 :                sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2277 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
$LL2826@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2826@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2278 :                kb_error(1268,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1268					; 000004f4H
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	$LN1980@eval
$LN1404@eval:

; 2273 :              case BODY: *++stacktop = (REAL)get_b_phase(id); break;

	mov	ecx, DWORD PTR _B_PHASE_ATTR
	mov	esi, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+440
	cmp	DWORD PTR [ecx+esi+88], edx
	je	SHORT $LN2163@eval
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2163@eval
	mov	edx, DWORD PTR _web+348
	mov	ecx, DWORD PTR [ecx+esi+64]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+ecx]
$LN2163@eval:
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR tv4908[ebp], edx
	fild	DWORD PTR tv4908[ebp]
$adfadf_3$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1405@eval:

; 2271 :           { 
; 2272 :              case FACET: *++stacktop = (REAL)get_f_phase(id); break;

	mov	ecx, DWORD PTR _F_PHASE_ATTR
	mov	esi, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+328
	cmp	DWORD PTR [ecx+esi+88], edx
	je	SHORT $LN2161@eval
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2161@eval
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ecx+esi+64]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+ecx]
$LN2161@eval:
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR tv4881[ebp], edx
	fild	DWORD PTR tv4881[ebp]
	fstp	QWORD PTR [eax]

; 2279 :           }
; 2280 :         break;

	jmp	$LN1980@eval
$LN1402@eval:

; 2281 : 
; 2282 :       case DENSITY_NODE:
; 2283 :       case GET_DENSITY_NODE:
; 2284 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1401@eval

; 2285 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1400@eval
$LN1401@eval:

; 2286 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1400@eval:

; 2287 :         switch ( id_type(id) )

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	dec	ecx
	je	$LN1397@eval
	dec	ecx
	je	$LN1396@eval
	dec	ecx
	je	SHORT $LN1395@eval

; 2291 :           default: 
; 2292 :             sprintf(errmsg,"Density of wrong type element in %s.\n",ex_current.name);

	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	OFFSET ??_C@_0CG@KOBCBKLB@Density?5of?5wrong?5type?5element?5in@
	push	OFFSET _errmsg
	call	_sprintf

; 2293 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2294 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
	npad	3
$LL2827@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2827@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2295 :             kb_error(1269,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1269					; 000004f5H
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	$LN1980@eval
$LN1395@eval:

; 2290 :           case BODY: *++stacktop = get_body_density(id); break;

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	call	_get_body_density
	fstp	QWORD PTR [esi]
	add	esp, 4
	jmp	$LN1980@eval
$LN1396@eval:

; 2289 :           case FACET: *++stacktop = get_facet_density(id); break;

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ebx+48]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	fld	QWORD PTR [eax+32]
	fstp	QWORD PTR [ecx]
	jmp	$LN1980@eval
$LN1397@eval:

; 2288 :         { case EDGE: *++stacktop = get_edge_density(id); break;

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ebx+48]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	fld	QWORD PTR [eax+40]
	fstp	QWORD PTR [ecx]

; 2296 :           }
; 2297 :         break;

	jmp	$LN1980@eval
$LN1393@eval:

; 2298 : 
; 2299 :       case VOLUME_NODE:
; 2300 :       case GET_VOLUME_NODE:
; 2301 :       { ATTR attr;
; 2302 :         if ( node->op1.localnum ) 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN1392@eval

; 2303 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+40]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	edi, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN1391@eval
$LN1392@eval:

; 2304 :         else id = q_id;

	mov	edi, DWORD PTR _q_id$[ebp]
$LN1391@eval:

; 2305 :         attr = get_battr(id);

	mov	edx, DWORD PTR _web+348
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR _attr$90515[ebp+4], ecx

; 2306 :         if ( attr & FIXEDVOL )

	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN1390@eval

; 2307 :         { if (fixed_volume_timestamp < global_timestamp) 

	mov	edx, DWORD PTR _fixed_volume_timestamp
	cmp	edx, DWORD PTR _global_timestamp
	jge	SHORT $LN1387@eval

; 2308 :             calc_content(Q_FIXED);

	push	2

; 2309 :         }
; 2310 :         else 

	jmp	SHORT $LN3956@eval
$LN1390@eval:

; 2311 :           if (  (info_volume_timestamp < global_timestamp) )

	mov	eax, DWORD PTR _info_volume_timestamp
	cmp	eax, DWORD PTR _global_timestamp
	jge	SHORT $LN1387@eval

; 2312 :            calc_content(Q_INFO|Q_ENERGY);

	push	5
$LN3956@eval:
	call	_calc_content
	fstp	ST(0)
	add	esp, 4
$LN1387@eval:

; 2313 :         *++stacktop = get_body_volume(id);

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	edi
	call	_get_body_volume
	fstp	QWORD PTR [esi]
	add	esp, 4

; 2314 :         break;

	jmp	$LN1980@eval
$LN1386@eval:

; 2315 :        }
; 2316 : 
; 2317 :       case GET_VOLCONST_NODE:
; 2318 :         if ( node->op1.localnum ) 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN1385@eval

; 2319 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+40]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN1384@eval
$LN1385@eval:

; 2320 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1384@eval:

; 2321 :         *++stacktop = get_body_volconst(id);

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	call	_get_body_volconst
	fstp	QWORD PTR [esi]
	add	esp, 4

; 2322 :         break;

	jmp	$LN1980@eval
$LN1383@eval:

; 2323 : 
; 2324 :       case GET_TARGET_NODE:
; 2325 :         if ( node->op1.localnum ) 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN1382@eval

; 2326 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+40]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN1381@eval
$LN1382@eval:

; 2327 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1381@eval:

; 2328 :         *++stacktop = get_body_fixvol(id);

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	call	_get_body_fixvol
	fstp	QWORD PTR [esi]
	add	esp, 4

; 2329 :         break;

	jmp	$LN1980@eval
$LN1380@eval:

; 2330 : 
; 2331 :       case ID_NODE:
; 2332 :       case GET_ID_NODE:
; 2333 :       case GET_OID_NODE:
; 2334 :         if ( node->op1.localnum ) 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN1379@eval

; 2335 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [eax+ecx*8]
	jmp	SHORT $LN1378@eval
$LN1379@eval:

; 2336 :         else id = q_id;

	mov	ecx, DWORD PTR _q_id$[ebp]
$LN1378@eval:

; 2337 :         if ( (node->type == GET_OID_NODE) && inverted(id) )

	cmp	edx, 10195				; 000027d3H
	jne	SHORT $LN1377@eval
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN1377@eval

; 2338 :           *++stacktop = -(REAL)(ordinal(id)+1);

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN2165@eval
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	mov	DWORD PTR tv27586[ebp], ecx
	fild	DWORD PTR tv27586[ebp]
$adfadf_4$92124:
	fchs
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN2165@eval:
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	or	ecx, -1
	inc	ecx
	mov	DWORD PTR tv27586[ebp], ecx
	fild	DWORD PTR tv27586[ebp]
$adfadf_5$92124:
	fchs
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1377@eval:

; 2339 :         else *++stacktop = (REAL)(ordinal(id)+1);

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN2167@eval
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN2168@eval
$LN2167@eval:
	or	ecx, -1
$LN2168@eval:
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	inc	ecx
	mov	DWORD PTR tv27585[ebp], ecx
	fild	DWORD PTR tv27585[ebp]
	fstp	QWORD PTR [eax]

; 2340 :         break;

	jmp	$LN1980@eval
$LN1375@eval:

; 2341 : 
; 2342 :       case ORIGINAL_NODE:
; 2343 :       case GET_ORIGINAL_NODE:  /* as user's element id number */
; 2344 :         if ( node->op1.localnum ) 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN1374@eval

; 2345 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+40]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN1373@eval
$LN1374@eval:

; 2346 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1373@eval:

; 2347 :         *++stacktop = valid_id(id) ? (REAL)ordinal(get_original(id))+1 : 0;

	test	eax, 268435456				; 10000000H
	je	$LN2093@eval
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+20]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2169@eval
	and	eax, 134217727				; 07ffffffH
	add	DWORD PTR [ebx+48], 8
	mov	DWORD PTR tv5125[ebp], eax
	fild	DWORD PTR tv5125[ebp]
	mov	eax, DWORD PTR [ebx+48]
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN2169@eval:

; 1598 : 
; 1599 :       case PUSHG_NODE:
; 1600 :          *++stacktop = web.gravflag ? web.grav_const : 0.0;

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]

; 2347 :         *++stacktop = valid_id(id) ? (REAL)ordinal(get_original(id))+1 : 0;

	mov	DWORD PTR tv5125[ebp], -1
	fild	DWORD PTR tv5125[ebp]
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1369@eval:

; 2348 :         break;
; 2349 : 
; 2350 :       case GET_MPI_TASK_NODE:
; 2351 :         if ( node->op1.localnum ) 
; 2352 :            id = *(element_id*)get_localp(node->op1.localnum);
; 2353 :         else id = q_id;
; 2354 :         *++stacktop = id_task(id);
; 2355 :         break;
; 2356 : 
; 2357 : 
; 2358 :       case GET_COLOR_NODE:
; 2359 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1368@eval

; 2360 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1367@eval
$LN1368@eval:

; 2361 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1367@eval:

; 2365 :            default: *++stacktop = 0.0;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	dec	ecx
	je	SHORT $LN1364@eval

; 2362 :         switch ( id_type(id) )

	dec	ecx

; 2365 :            default: *++stacktop = 0.0;

	jne	$LN1459@eval

; 2364 :            case FACET: *++stacktop = (REAL)get_facet_color(id); break;

	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ebx+48]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [eax+48]
	mov	DWORD PTR tv27575[ebp], edx
	fild	DWORD PTR tv27575[ebp]
	fstp	QWORD PTR [ecx]
	jmp	$LN1980@eval
$LN1364@eval:

; 2363 :          { case EDGE:  *++stacktop = (REAL)get_edge_color(id); break;

	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ebx+48]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	movsx	edx, WORD PTR [eax+56]
	mov	DWORD PTR tv27574[ebp], edx
	fild	DWORD PTR tv27574[ebp]
	fstp	QWORD PTR [ecx]

; 2366 :          }
; 2367 :         break;

	jmp	$LN1980@eval
$LN1361@eval:

; 2368 : 
; 2369 :       case GET_FRONTCOLOR_NODE:
; 2370 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1360@eval

; 2371 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1359@eval
$LN1360@eval:

; 2372 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1359@eval:

; 2373 :         switch ( id_type(id) )

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	sub	ecx, 2

; 2375 :             default: *++stacktop = 0.0;

	jne	$LN1372@eval

; 2374 :          { case FACET:  *++stacktop = (REAL)get_facet_frontcolor(id); break;

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2173@eval
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	movsx	eax, WORD PTR [edx+50]
	add	DWORD PTR [ebx+48], 8
	mov	DWORD PTR tv5223[ebp], eax
	mov	eax, DWORD PTR [ebx+48]
	fild	DWORD PTR tv5223[ebp]
	fstp	QWORD PTR [eax]

; 2376 :          }
; 2377 :         break;

	jmp	$LN1980@eval
$LN2173@eval:

; 2374 :          { case FACET:  *++stacktop = (REAL)get_facet_frontcolor(id); break;

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	movsx	eax, WORD PTR [edx+48]
	add	DWORD PTR [ebx+48], 8
	mov	DWORD PTR tv5223[ebp], eax
	mov	eax, DWORD PTR [ebx+48]
	fild	DWORD PTR tv5223[ebp]
	fstp	QWORD PTR [eax]

; 2376 :          }
; 2377 :         break;

	jmp	$LN1980@eval
$LN1354@eval:

; 2378 : 
; 2379 :       case GET_BACKCOLOR_NODE:
; 2380 :         if ( node->op1.localnum ) 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN1353@eval

; 2381 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+40]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN1352@eval
$LN1353@eval:

; 2382 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1352@eval:

; 2383 :         switch ( id_type(id) )

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	sub	ecx, 2

; 2385 :             default: *++stacktop = 0.0;

	jne	$LN1372@eval

; 2384 :          { case FACET:  *++stacktop = (REAL)get_facet_backcolor(id); break;

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2175@eval
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	movsx	eax, WORD PTR [edx+48]
	add	DWORD PTR [ebx+48], 8
	mov	DWORD PTR tv5263[ebp], eax
	mov	eax, DWORD PTR [ebx+48]
	fild	DWORD PTR tv5263[ebp]
	fstp	QWORD PTR [eax]

; 2386 :          }
; 2387 :         break;

	jmp	$LN1980@eval
$LN2175@eval:

; 2384 :          { case FACET:  *++stacktop = (REAL)get_facet_backcolor(id); break;

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	movsx	eax, WORD PTR [edx+50]
	add	DWORD PTR [ebx+48], 8
	mov	DWORD PTR tv5263[ebp], eax
	mov	eax, DWORD PTR [ebx+48]
	fild	DWORD PTR tv5263[ebp]
	fstp	QWORD PTR [eax]

; 2386 :          }
; 2387 :         break;

	jmp	$LN1980@eval
$LN1347@eval:

; 2388 : 
; 2389 :       case GET_FRONTBODY_NODE:
; 2390 :         if ( node->op1.localnum ) 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN1346@eval

; 2391 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+40]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN1345@eval
$LN1346@eval:

; 2392 :         else id = q_id;

	mov	esi, DWORD PTR _q_id$[ebp]
$LN1345@eval:

; 2393 :         switch ( id_type(id) )

	mov	eax, esi
	shr	eax, 29					; 0000001dH
	dec	eax
	je	SHORT $LN1342@eval
	dec	eax

; 2404 :               break;
; 2405 :             default: *++stacktop = 0.0;

	jne	$LN1372@eval

; 2401 :              break;
; 2402 :            case FACET:  
; 2403 :               *++stacktop = (REAL)ordinal(get_facet_body(id))+1; 

	push	esi
	call	_get_facet_body
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2179@eval
	push	esi
	call	_get_facet_body
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv5331[ebp], eax
	fild	DWORD PTR tv5331[ebp]
	add	esp, 4
	add	DWORD PTR [ebx+48], 8
	fadd	QWORD PTR __real@3ff0000000000000
	mov	eax, DWORD PTR [ebx+48]
$adfadf_6$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN2179@eval:
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR tv5331[ebp], -1
	fild	DWORD PTR tv5331[ebp]
$adfadf_7$92124:
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1342@eval:

; 2394 :          { case EDGE: 
; 2395 :              fe = get_edge_fe(id);

	push	esi
	call	_get_edge_fe
	mov	edi, eax
	add	esp, 4

; 2396 :              if ( !valid_id(fe) ) {*++stacktop = 0.0; break;}

	test	edi, 268435456				; 10000000H
	je	$LN1372@eval

; 2397 :              f_id = get_fe_facet(fe);

	push	edi
	call	_get_fe_facet
	mov	esi, eax
	add	esp, 4

; 2398 :              if ( inverted(f_id) ) f_id = get_fe_facet(get_next_facet(fe));

	test	esi, 134217728				; 08000000H
	je	SHORT $LN1339@eval
	push	edi
	call	_get_next_facet
	push	eax
	call	_get_fe_facet
	mov	esi, eax
	add	esp, 8

; 2399 :              if ( inverted(f_id) ) { *++stacktop = 0.0; break;}

	test	esi, 134217728				; 08000000H
	jne	$LN1372@eval
$LN1339@eval:

; 2400 :              *++stacktop = (REAL)ordinal(get_facet_body(f_id))+1; 

	push	esi
	call	_get_facet_body
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2177@eval
	push	esi
	call	_get_facet_body
	add	esp, 4
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv5317[ebp], eax
	jmp	SHORT $LN2178@eval
$LN2177@eval:
	mov	DWORD PTR tv5317[ebp], -1
$LN2178@eval:
	fild	DWORD PTR tv5317[ebp]
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [eax]

; 2406 :          }
; 2407 :         break;

	jmp	$LN1980@eval
$LN1336@eval:

; 2408 : 
; 2409 :       case GET_BACKBODY_NODE:
; 2410 :     if ( node->op1.localnum ) 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN1335@eval

; 2411 :        id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+40]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN1334@eval
$LN1335@eval:

; 2412 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1334@eval:

; 2413 :         switch ( id_type(id) )

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	dec	ecx
	je	SHORT $LN1330@eval
	dec	ecx

; 2424 :              break;
; 2425 :             default: *++stacktop = 0.0;

	jne	$LN1372@eval

; 2414 :          { case FACET:  *++stacktop =
; 2415 :               (REAL)ordinal(get_facet_body(inverse_id(id)))+1;

	mov	esi, eax
	xor	esi, 134217728				; 08000000H
	push	esi
	call	_get_facet_body
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2181@eval
	push	esi
	call	_get_facet_body
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv5365[ebp], eax
	fild	DWORD PTR tv5365[ebp]
	add	esp, 4
	add	DWORD PTR [ebx+48], 8
	fadd	QWORD PTR __real@3ff0000000000000
	mov	eax, DWORD PTR [ebx+48]
$adfadf_8$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN2181@eval:
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR tv5365[ebp], -1
	fild	DWORD PTR tv5365[ebp]
$adfadf_9$92124:
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1330@eval:

; 2416 :             break;
; 2417 :            case EDGE: 
; 2418 :              fe = get_edge_fe(id);

	push	eax
	call	_get_edge_fe
	mov	esi, eax
	add	esp, 4

; 2419 :              if ( !valid_id(fe) ) {*++stacktop = 0.0; break;}

	test	esi, 268435456				; 10000000H
	je	$LN1372@eval

; 2420 :              f_id = get_fe_facet(fe);

	push	esi
	call	_get_fe_facet
	add	esp, 4

; 2421 :              if ( !inverted(f_id) ) f_id = get_fe_facet(get_next_facet(fe));

	test	eax, 134217728				; 08000000H
	jne	SHORT $LN1327@eval
	push	esi
	call	_get_next_facet
	push	eax
	call	_get_fe_facet
	add	esp, 8

; 2422 :              if ( !inverted(f_id) ) { *++stacktop = 0.0; break;}

	test	eax, 134217728				; 08000000H
	je	$LN1372@eval
$LN1327@eval:

; 2423 :              *++stacktop = (REAL)ordinal(get_facet_body(inverse_id(f_id)))+1; 

	mov	esi, eax
	xor	esi, 134217728				; 08000000H
	push	esi
	call	_get_facet_body
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2183@eval
	push	esi
	call	_get_facet_body
	add	esp, 4
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv5404[ebp], eax
	jmp	SHORT $LN2184@eval
$LN2183@eval:
	mov	DWORD PTR tv5404[ebp], -1
$LN2184@eval:
	fild	DWORD PTR tv5404[ebp]
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [eax]

; 2426 :          }
; 2427 :         break;

	jmp	$LN1980@eval
$LN1325@eval:

; 2428 : 
; 2429 :       case GET_BARE_NODE:
; 2430 :         if ( node->op1.localnum ) 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN1324@eval

; 2431 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+40]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN1323@eval
$LN1324@eval:

; 2432 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1323@eval:

; 2433 :         *++stacktop = (get_attr(id) & BARE_NAKED) ? 1.0 : 0.0;

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 65536				; 00010000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1322@eval:

; 2434 :         break;
; 2435 : 
; 2436 :       case GET_MIDV_NODE:
; 2437 :         if ( web.modeltype != QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	je	SHORT $LN1321@eval

; 2438 :         { sprintf(errmsg,"Cannot do MIDV except in QUADRATIC model (in %s).\n",
; 2439 :               ex_current.name);

	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	OFFSET ??_C@_0DD@EKGPLGNI@Cannot?5do?5MIDV?5except?5in?5QUADRAT@
	push	OFFSET _errmsg
	call	_sprintf

; 2440 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2441 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
$LL2828@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2828@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2442 :           kb_error(2066,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2066					; 00000812H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1321@eval:

; 2443 :         }
; 2444 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN1320@eval

; 2445 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1319@eval
$LN1320@eval:

; 2446 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1319@eval:

; 2447 :         *++stacktop = ordinal(get_edge_midv(id)) + 1.0;

	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax+8]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2187@eval
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv5499[ebp], eax
	jmp	SHORT $LN2188@eval
$LN2187@eval:
	mov	DWORD PTR tv5499[ebp], -1
$LN2188@eval:
	fild	DWORD PTR tv5499[ebp]
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [eax]

; 2448 :         break;

	jmp	$LN1980@eval
$LN1318@eval:

; 2449 : 
; 2450 :       case FIXED_NODE:
; 2451 :       case GET_FIXED_NODE:
; 2452 :         if ( node->op1.localnum ) 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN1317@eval

; 2453 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+40]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN1316@eval
$LN1317@eval:

; 2454 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1316@eval:

; 2455 :         if ( id_type(id) == BODY )

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH

; 2456 :           *++stacktop = get_battr(id)&FIXEDVOL ? 1.0 : 0.0;

	and	eax, 134217727				; 07ffffffH
	cmp	ecx, 3
	jne	SHORT $LN1315@eval
	mov	ecx, DWORD PTR _web+348
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN2189@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
$adfadf_10$92124:
	jmp	$LN1980@eval
$LN2189@eval:
	fldz
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
$adfadf_11$92124:
	jmp	$LN1980@eval
$LN1315@eval:

; 2457 :         else *++stacktop = (get_attr(id) & FIXED) ? 1.0 : 0.0;

	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1313@eval:

; 2458 :         break;
; 2459 : 
; 2460 :       case GET_OPACITY_NODE:
; 2461 :              if ( !opacity_attr ) *(++stacktop) = 1.0;

	cmp	DWORD PTR _opacity_attr, 0
	jne	SHORT $LN1312@eval
	add	DWORD PTR [ebx+48], 8
	fld1
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
$adfadf_12$92124:
	jmp	$LN1980@eval
$LN1312@eval:

; 2462 :              else
; 2463 :              { if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1310@eval

; 2464 :                  id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1309@eval
$LN1310@eval:

; 2465 :                else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1309@eval:

; 2466 :                *(++stacktop) = *(REAL*)(get_extra(id,opacity_attr));

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR _opacity_attr
	mov	esi, DWORD PTR [ebx+48]
	push	ecx
	push	eax
	call	_get_extra
	fld	QWORD PTR [eax]
	fstp	QWORD PTR [esi]
	add	esp, 8

; 2467 :              }
; 2468 :              break;

	jmp	$LN1980@eval
$LN1308@eval:

; 2469 : 
; 2470 : 
; 2471 :       case GET_NO_DISPLAY_NODE:
; 2472 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1307@eval

; 2473 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1306@eval
$LN1307@eval:

; 2474 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1306@eval:

; 2475 :         *++stacktop = (get_attr(id) & NODISPLAY) ? 1.0 : 0.0;

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2
	xor	ecx, ecx
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1305@eval:

; 2476 :         break;
; 2477 : 
; 2478 :       case GET_NONCONTENT_NODE:
; 2479 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1304@eval

; 2480 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1303@eval
$LN1304@eval:

; 2481 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1303@eval:

; 2482 :         *++stacktop = (get_attr(id) & NONCONTENT) ? 1.0 : 0.0;

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1302@eval:

; 2483 :         break;
; 2484 : 
; 2485 :       case GET_HIT_PARTNER_NODE:
; 2486 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1301@eval

; 2487 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1300@eval
$LN1301@eval:

; 2488 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1300@eval:

; 2489 :         *++stacktop = (get_attr(id) & HIT_PARTNER) ? 1.0 : 0.0;

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 32768				; 00008000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1299@eval:

; 2490 :         break;
; 2491 : 
; 2492 :       case GET_NO_REFINE_NODE:
; 2493 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1298@eval

; 2494 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1297@eval
$LN1298@eval:

; 2495 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1297@eval:

; 2496 :         *++stacktop = (get_attr(id) & NO_REFINE) ? 1.0 : 0.0;

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 16777216				; 01000000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1296@eval:

; 2497 :         break;
; 2498 : 
; 2499 :       case GET_NO_TRANSFORM_NODE:
; 2500 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1295@eval

; 2501 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1294@eval
$LN1295@eval:

; 2502 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1294@eval:

; 2503 :         *++stacktop = (get_attr(id) & NO_TRANSFORM) ? 1.0 : 0.0;

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 1
	xor	eax, eax
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1293@eval:

; 2504 :         break;
; 2505 : 
; 2506 :       case GET_TRIPLE_PT_NODE:
; 2507 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1292@eval

; 2508 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1291@eval
$LN1292@eval:

; 2509 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1291@eval:

; 2510 :         *++stacktop = (get_attr(id) & TRIPLE_PT) ? 1.0 : 0.0;

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 524288				; 00080000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1290@eval:

; 2511 :         break;
; 2512 : 
; 2513 :       case GET_TETRA_PT_NODE:
; 2514 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1289@eval

; 2515 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1288@eval
$LN1289@eval:

; 2516 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1288@eval:

; 2517 :         *++stacktop = (get_attr(id) & TETRA_PT) ? 1.0 : 0.0;

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 262144				; 00040000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1287@eval:

; 2518 :         break;
; 2519 : 
; 2520 :       case GET_NO_HESSIAN_NORMAL_NODE:
; 2521 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1286@eval

; 2522 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1285@eval
$LN1286@eval:

; 2523 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1285@eval:

; 2524 :         *++stacktop = (get_attr(id) & NO_HESSIAN_NORMAL_ATTR) ? 1.0 : 0.0;

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, -2147483648			; 80000000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1284@eval:

; 2525 :         break;
; 2526 : 
; 2527 :       case GET_AXIAL_POINT_NODE:
; 2528 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1283@eval

; 2529 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1282@eval
$LN1283@eval:

; 2530 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1282@eval:

; 2531 :         *++stacktop = (get_attr(id) & AXIAL_POINT) ? 1.0 : 0.0;

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 8388608				; 00800000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1281@eval:

; 2532 :         break;
; 2533 : 
; 2534 :       case GET_SHOW_NODE:
; 2535 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	xor	edx, edx
	cmp	eax, edx
	je	SHORT $LN1280@eval

; 2536 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR _id$[ebp], ecx
	jmp	SHORT $LN1279@eval
$LN1280@eval:

; 2537 :         else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
	mov	DWORD PTR _id$[ebp], eax
$LN1279@eval:

; 2538 :         if ( id_type(id) == EDGE )

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	cmp	eax, 1
	jne	$LN1278@eval

; 2539 :         { ATTR  eattr = get_eattr(id);

	mov	edx, DWORD PTR _web+124
	mov	edi, ecx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edx+edi]
	mov	esi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]

; 2540 :           int showflag = 0;
; 2541 :           facetedge_id fe_id = get_edge_fe(id);

	push	ecx
	mov	DWORD PTR tv18640[ebp], edi
	mov	DWORD PTR _eattr$90768[ebp+4], eax
	mov	DWORD PTR _showflag$90770[ebp], 0
	call	_get_edge_fe
	mov	DWORD PTR _fe_id$90771[ebp], eax

; 2542 :  
; 2543 :           if ( eattr & BOUNDARY ) showflag = 1;

	mov	eax, esi
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	add	esp, 4
	or	eax, ecx
	je	SHORT $LN1277@eval
	mov	DWORD PTR _showflag$90770[ebp], 1
$LN1277@eval:

; 2544 :           if ( equal_id(get_next_facet(fe_id),fe_id) ) /* valence 1 */

	mov	ecx, DWORD PTR _fe_id$90771[ebp]
	push	ecx
	call	_get_next_facet
	add	esp, 4
	cmp	eax, DWORD PTR _fe_id$90771[ebp]

; 2545 :               showflag = 1;

	je	SHORT $LN4023@eval

; 2546 :           else if  ( !equal_id(get_next_facet(fe_id),get_prev_facet(fe_id)) )

	mov	edi, DWORD PTR _fe_id$90771[ebp]
	push	edi
	call	_get_next_facet
	push	edi
	mov	DWORD PTR tv23353[ebp], eax
	call	_get_prev_facet

; 2547 :               showflag = 1;

	mov	edi, DWORD PTR tv18640[ebp]
	add	esp, 8
	cmp	DWORD PTR tv23353[ebp], eax
	je	SHORT $LN1274@eval
$LN4023@eval:
	mov	DWORD PTR _showflag$90770[ebp], 1
$LN1274@eval:

; 2548 :           if ( eattr & HIT_WALL )  showflag = 1;

	mov	eax, esi
	and	eax, 8192				; 00002000H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN1273@eval
	mov	DWORD PTR _showflag$90770[ebp], 1
$LN1273@eval:

; 2549 :           if ( eattr & FIXED ) showflag = 1;

	and	esi, 64					; 00000040H
	xor	eax, eax
	or	esi, eax
	je	SHORT $LN1272@eval
	mov	DWORD PTR _showflag$90770[ebp], 1
$LN1272@eval:

; 2550 :           if ( show_expr[EDGE] && show_expr[EDGE]->start )

	mov	ecx, DWORD PTR _show_expr+4
	test	ecx, ecx
	je	SHORT $LN1269@eval
	cmp	DWORD PTR [ecx], eax
	je	SHORT $LN1269@eval

; 2551 :           {
; 2552 :             PROF_EVAL_END(ex_profiling);
; 2553 :             PUSH_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	cmp	eax, 100				; 00000064H
	jl	SHORT $LN1270@eval
	xor	eax, eax
$LN1270@eval:
	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _eval_stack_trace[eax*4], edx
	inc	eax

; 2554 :             showflag = eval(show_expr[EDGE],NULL,id,NULL) ? 1 : 0; 

	xor	esi, esi
	mov	DWORD PTR _eval_stack_trace_spot, eax
	mov	eax, DWORD PTR _id$[ebp]
	push	esi
	push	eax
	push	esi
	push	ecx
	call	_eval
	fldz
	fucompp
	add	esp, 16					; 00000010H
	mov	DWORD PTR _showflag$90770[ebp], 1
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN2212@eval
	mov	DWORD PTR _showflag$90770[ebp], esi
$LN2212@eval:

; 2555 :             POP_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	cmp	eax, esi
	jle	SHORT $LN1269@eval
	mov	DWORD PTR _eval_stack_trace[eax*4], esi
	dec	eax
	mov	DWORD PTR _eval_stack_trace_spot, eax
$LN1269@eval:

; 2556 :             PROF_EVAL_START(ex_profiling);
; 2557 :           }
; 2558 :           if ( get_edge_color(id) == CLEAR ) showflag = 0;

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [ecx+edi]
	cmp	WORD PTR [edx+56], -1
	jne	SHORT $LN1268@eval
	mov	DWORD PTR _showflag$90770[ebp], 0
$LN1268@eval:

; 2559 :           *++stacktop = showflag;

	fild	DWORD PTR _showflag$90770[ebp]
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
$adfadf_13$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1278@eval:

; 2560 :         }
; 2561 :         else if ( id_type(id) == FACET )

	cmp	eax, 2
	jne	$LN1266@eval

; 2562 :         { ATTR fattr = get_fattr(id);

	mov	eax, DWORD PTR _web+236
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _fattr$90792[ebp+4], eax

; 2563 :           int showflag = 1;
; 2564 : 
; 2565 :           if ( (fattr & (BOUNDARY|CONSTRAINT)) && !bdry_showflag )

	mov	eax, ecx
	and	eax, 1152				; 00000480H
	or	eax, edx
	mov	DWORD PTR _showflag$90794[ebp], 1
	je	SHORT $LN1265@eval
	cmp	DWORD PTR _bdry_showflag, edx
	jne	SHORT $LN1265@eval

; 2566 :             showflag = 0;

	mov	DWORD PTR _showflag$90794[ebp], edx
$LN1265@eval:

; 2567 :           if ( fattr & NODISPLAY )

	and	ecx, 2
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN1264@eval

; 2568 :              showflag = 0;

	mov	DWORD PTR _showflag$90794[ebp], edx
$LN1264@eval:

; 2569 : 
; 2570 :           if ( no_wall_flag )

	cmp	DWORD PTR _no_wall_flag, edx
	je	$LN1260@eval

; 2571 :           { /* skip facets with all three vertices on walls */
; 2572 :             fe = get_facet_fe(id);

	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	call	_get_facet_fe
	mov	esi, eax

; 2573 :             if ( get_vattr(get_fe_headv(fe)) & (HIT_WALL|CONSTRAINT) )

	push	esi
	call	_get_fe_edge
	push	eax
	call	_get_edge_headv
	mov	edi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 9216				; 00002400H
	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	or	eax, ecx
	je	SHORT $LN1260@eval

; 2574 :             if ( get_vattr(get_fe_tailv(fe)) & (HIT_WALL|CONSTRAINT) ) 

	push	esi
	call	_get_fe_edge
	push	eax
	call	_get_edge_tailv
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 9216				; 00002400H
	xor	ecx, ecx
	add	esp, 8
	or	eax, ecx
	je	SHORT $LN1260@eval

; 2575 :             { fe = get_next_edge(fe);

	push	esi
	call	_get_next_edge

; 2576 :               if ( get_vattr(get_fe_headv(fe)) & (HIT_WALL|CONSTRAINT) )

	push	eax
	call	_get_fe_edge
	push	eax
	call	_get_edge_headv
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 9216				; 00002400H
	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	or	eax, ecx
	je	SHORT $LN1260@eval

; 2577 :                showflag = 0;

	mov	DWORD PTR _showflag$90794[ebp], ecx
$LN1260@eval:

; 2578 :             }
; 2579 :           }      
; 2580 : 
; 2581 :           if ( show_expr[FACET] && show_expr[FACET]->start )

	mov	eax, DWORD PTR _show_expr+8
	test	eax, eax
	je	SHORT $LN1258@eval
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1258@eval

; 2582 :           { 
; 2583 :             PROF_EVAL_END(ex_profiling);
; 2584 :             if ( !eval(show_expr[FACET],NULL,id,NULL) ) 

	mov	edx, DWORD PTR _id$[ebp]
	push	0
	push	edx
	push	0
	push	eax
	call	_eval
	fldz
	fucompp
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1258@eval

; 2585 :                showflag = 0;

	mov	DWORD PTR _showflag$90794[ebp], 0
$LN1258@eval:

; 2586 :             PROF_EVAL_START(ex_profiling);
; 2587 :           }
; 2588 :           *++stacktop = showflag;

	fild	DWORD PTR _showflag$90794[ebp]
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
$adfadf_14$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1266@eval:

; 2589 :          }
; 2590 :          else
; 2591 :          { sprintf(errmsg,
; 2592 :              "\"show\" attribute applied to wrong type of element in %s.\n",
; 2593 :                 ex_current.name);

	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	OFFSET ??_C@_0DK@LPLOMNDN@?$CCshow?$CC?5attribute?5applied?5to?5wron@
	push	OFFSET _errmsg
	call	_sprintf

; 2594 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2595 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
	npad	2
$LL2829@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2829@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2596 :            kb_error(2067,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2067					; 00000813H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 2597 :          }
; 2598 :          break;

	jmp	$LN1980@eval
$LN1255@eval:

; 2599 : 
; 2600 :       case ATTR_FUNCTION_NODE:
; 2601 :            node += node->op1.skipsize - 1;
; 2602 :            break;
; 2603 :       case ATTR_FUNCTION_END_NODE:
; 2604 :          { struct extra *ext = EXTRAS(node->op2.eltype) + node->op1.extranum;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+136]
	mov	ecx, DWORD PTR [ecx+32]
	lea	edx, DWORD PTR [eax*8]
	imul	ecx, 240				; 000000f0H
	sub	edx, eax
	shl	edx, 4
	mov	eax, DWORD PTR _web[edx+104]
	add	eax, ecx
	add	eax, DWORD PTR _dymem

; 2605 :            ext->flags |= FUNCTION_ATTR;

	or	DWORD PTR [eax+232], 2

; 2606 :            tree_copy(&ext->code,node + node->right);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	imul	edx, 168				; 000000a8H
	add	edx, ecx
	push	edx
	sub	eax, -128				; ffffff80H
	push	eax
	call	_tree_copy
	add	esp, 8

; 2607 :            break;

	jmp	$LN1980@eval
$LN1254@eval:

; 2608 :          }
; 2609 : 
; 2610 :       case GET_EXTRA_ATTR_NODE:
; 2611 :        { struct extra *ext;
; 2612 :          int spot;
; 2613 :          n = node->op3.extranum; /* attribute number */

	mov	edx, DWORD PTR _node$[ebp]

; 2614 :          if ( node->op1.localnum ) 

	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [edx+140]
	xor	esi, esi
	mov	DWORD PTR _n$[ebp], ecx
	cmp	eax, esi
	je	SHORT $LN1253@eval

; 2615 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edi, DWORD PTR [eax*8]
	sub	edi, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	edi, 5
	mov	eax, DWORD PTR [edi+eax+216]
	add	eax, DWORD PTR _localstack$[ebp]
	mov	edi, DWORD PTR [ebx+40]
	mov	edi, DWORD PTR [edi+eax*8]
	jmp	SHORT $LN1252@eval
$LN1253@eval:

; 2616 :          else id = q_id;

	mov	edi, DWORD PTR _q_id$[ebp]
$LN1252@eval:

; 2617 :          ext = EXTRAS(node->op2.eltype) + n;

	mov	eax, DWORD PTR [edx+136]
	imul	ecx, 240				; 000000f0H
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	shl	edx, 4
	mov	eax, DWORD PTR _web[edx+104]
	add	eax, ecx
	add	eax, DWORD PTR _dymem
	mov	DWORD PTR tv19078[ebp], ecx
	mov	DWORD PTR _ext$90824[ebp], eax

; 2618 :          /* get index */
; 2619 :          spot = 0;
; 2620 :          for ( k = 0 ; k < ext->array_spec.dim ; k++ )

	mov	DWORD PTR _k$[ebp], esi
	cmp	DWORD PTR [eax+76], esi
	jle	$LN1249@eval

; 2617 :          ext = EXTRAS(node->op2.eltype) + n;

	add	eax, 96					; 00000060H
	mov	DWORD PTR tv27367[ebp], eax
	npad	4
$LL1251@eval:

; 2621 :          { int j = (int)(stacktop[-ext->array_spec.dim+k+1]);

	mov	edx, DWORD PTR _ext$90824[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, DWORD PTR [edx+76]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax+ecx*8+8]
	call	__ftol2_sse

; 2622 :            spot *= ext->array_spec.sizes[k];

	mov	ecx, DWORD PTR tv27367[ebp]
	mov	ecx, DWORD PTR [ecx]
	imul	esi, ecx
	mov	DWORD PTR _spot$90825[ebp], esi

; 2623 :            if ( (j < 1) || (j > ext->array_spec.sizes[k]) )

	cmp	eax, 1
	jl	SHORT $LN1247@eval
	cmp	eax, ecx
	jle	$LN1248@eval
$LN1247@eval:

; 2624 :            { sprintf(errmsg,
; 2625 :                 "Attribute %s index %d is %d; maximum is %d (in %s).\n",
; 2626 :                  ext->name,k+1,j,ext->array_spec.sizes[k],ex_current.name);

	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _ext$90824[ebp]
	push	eax
	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DF@MPPJKLHD@Attribute?5?$CFs?5index?5?$CFd?5is?5?$CFd?$DL?5max@
	push	OFFSET _errmsg
	call	_sprintf

; 2627 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2628 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 28					; 0000001cH
	lea	esi, DWORD PTR [eax+1]
	npad	5
$LL2830@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2830@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2629 :              kb_error(1270,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1270					; 000004f6H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1248@eval:

; 2630 :            }
; 2631 :            spot += (int)(stacktop[-ext->array_spec.dim+k+1]) - 1;

	mov	eax, DWORD PTR _ext$90824[ebp]
	mov	eax, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR [ebx+48]
	sub	ecx, eax
	fld	QWORD PTR [edx+ecx*8+8]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _spot$90825[ebp]
	mov	edx, DWORD PTR _ext$90824[ebp]
	add	DWORD PTR tv27367[ebp], 4
	lea	esi, DWORD PTR [ecx+eax-1]
	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR [edx+76]
	jl	$LL1251@eval
$LN1249@eval:

; 2632 :          }
; 2633 :          stacktop -= ext->array_spec.dim;

	mov	eax, DWORD PTR _ext$90824[ebp]
	mov	ecx, DWORD PTR [eax+76]
	neg	ecx
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [ebx+48], ecx

; 2634 :          if ( id_type(id) != node->op2.eltype )

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+136]
	mov	ecx, edi
	shr	ecx, 29					; 0000001dH
	cmp	ecx, eax
	je	$LN1242@eval

; 2635 :          { if ( (id_type(id)==EDGE) && (node->op2.eltype==VERTEX) && params )

	mov	edx, DWORD PTR _params$GSCopy$[ebp]
	cmp	ecx, 1
	jne	SHORT $LN1245@eval
	test	eax, eax
	jne	SHORT $LN1245@eval
	test	edx, edx
	je	SHORT $LN1245@eval

; 2636 :            { ext = EXTRAS(VERTEX) + n;

	mov	eax, DWORD PTR _web+104
	add	eax, DWORD PTR tv19078[ebp]
	add	eax, DWORD PTR _dymem

; 2637 :              *++stacktop = interp_edge_attribute(id,ext,spot,(int)params[2*SDIM]);

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR _ext$90824[ebp], eax
	mov	eax, DWORD PTR [ebx+48]
	add	ecx, ecx
	fld	QWORD PTR [edx+ecx*8]
	mov	DWORD PTR tv17681[ebp], eax
	call	__ftol2_sse
	mov	edx, DWORD PTR _ext$90824[ebp]
	push	eax
	push	esi
	push	edx
	push	edi
	call	_interp_edge_attribute
	mov	eax, DWORD PTR tv17681[ebp]
	fstp	QWORD PTR [eax]
	add	esp, 16					; 00000010H

; 2638 :              break;

	jmp	$LN1980@eval
$LN1245@eval:

; 2639 :            }
; 2640 :            else 
; 2641 :            if ( (id_type(id)==FACET) && (node->op2.eltype==VERTEX) && params )

	cmp	ecx, 2
	jne	SHORT $LN1243@eval
	test	eax, eax
	jne	SHORT $LN1243@eval
	test	edx, edx
	je	SHORT $LN1243@eval

; 2642 :            { ext = EXTRAS(VERTEX) + n;

	mov	eax, DWORD PTR tv19078[ebp]
	add	eax, DWORD PTR _web+104
	add	eax, DWORD PTR _dymem

; 2643 :              *++stacktop = interp_facet_attribute(id,ext,spot,(int)params[2*SDIM]);

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [ebx+48]
	mov	DWORD PTR _ext$90824[ebp], eax
	mov	eax, DWORD PTR _web+616
	add	eax, eax
	fld	QWORD PTR [edx+eax*8]
	mov	DWORD PTR tv17681[ebp], ecx
	call	__ftol2_sse
	mov	ecx, DWORD PTR _ext$90824[ebp]
	push	eax
	push	esi
	push	ecx
	push	edi
	call	_interp_facet_attribute
	mov	edx, DWORD PTR tv17681[ebp]
	fstp	QWORD PTR [edx]
	add	esp, 16					; 00000010H

; 2644 :              break;

	jmp	$LN1980@eval
$LN1243@eval:

; 2645 :            }
; 2646 :            else 
; 2647 :            { sprintf(errmsg,
; 2648 :                "Attribute %s is %s attribute, not %s attribute (in %s).\n",
; 2649 :                EXTRAS(node->op2.eltype)[n].name,
; 2650 :                  typenames[node->op2.eltype], typenames[id_type(id)],ex_current.name);

	mov	ecx, DWORD PTR _typenames[ecx*4]
	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	mov	edx, DWORD PTR _typenames[eax*4]
	push	ecx
	push	edx
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 4
	mov	edx, DWORD PTR _web[ecx+104]
	add	edx, DWORD PTR tv19078[ebp]
	add	edx, DWORD PTR _dymem
	push	edx
	push	OFFSET ??_C@_0DJ@FLIAONNC@Attribute?5?$CFs?5is?5?$CFs?5attribute?0?5no@
	push	OFFSET _errmsg
	call	_sprintf

; 2651 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2652 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 24					; 00000018H
	lea	ecx, DWORD PTR [eax+1]
$LL2831@eval:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL2831@eval
	sub	eax, ecx
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2653 :              kb_error(2068,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2068					; 00000814H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1242@eval:

; 2654 :            }
; 2655 :          }
; 2656 :          if ( ext->code.start ) 

	mov	ecx, DWORD PTR _ext$90824[ebp]
	sub	ecx, -128				; ffffff80H
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1241@eval

; 2657 :          { int oldflag = autorecalc_flag;

	mov	eax, DWORD PTR _autorecalc_flag
	mov	DWORD PTR _oldflag$90855[ebp], eax

; 2658 :            autorecalc_flag = 0;
; 2659 : 
; 2660 :            PROF_EVAL_END(ex_profiling);
; 2661 :            PUSH_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	mov	DWORD PTR _autorecalc_flag, 0
	cmp	eax, 100				; 00000064H
	jl	SHORT $LN1240@eval
	xor	eax, eax
$LN1240@eval:
	mov	edx, DWORD PTR _node$[ebp]

; 2662 :            eval(&ext->code,NULL,id,NULL);  /* side-effect fills in values */

	push	0
	push	edi
	mov	DWORD PTR _eval_stack_trace[eax*4], edx
	inc	eax
	push	0
	push	ecx
	mov	DWORD PTR _eval_stack_trace_spot, eax
	call	_eval
	fstp	ST(0)

; 2663 :            POP_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	add	esp, 16					; 00000010H
	test	eax, eax
	jle	SHORT $LN1239@eval
	mov	DWORD PTR _eval_stack_trace[eax*4], 0
	dec	eax
	mov	DWORD PTR _eval_stack_trace_spot, eax
$LN1239@eval:

; 2664 :            PROF_EVAL_START(ex_profiling);
; 2665 :            autorecalc_flag = oldflag;

	mov	eax, DWORD PTR _oldflag$90855[ebp]
	mov	DWORD PTR _autorecalc_flag, eax
$LN1241@eval:

; 2666 :           }
; 2667 :          switch ( ext->type )

	mov	ecx, DWORD PTR _ext$90824[ebp]
	mov	eax, DWORD PTR [ecx+68]
	dec	eax
	cmp	eax, 22					; 00000016H
	ja	$LN1980@eval
	movzx	edx, BYTE PTR $LN2832@eval[eax]
	jmp	DWORD PTR $LN4032@eval[edx*4]
$LN1236@eval:

; 2668 :          { case REAL_TYPE: *++stacktop = ((REAL*)get_extra(id,n))[spot]; 

	mov	eax, DWORD PTR _n$[ebp]
	add	DWORD PTR [ebx+48], 8
	push	eax
	push	edi
	call	_get_extra
	fld	QWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	add	esp, 8
$adfadf_15$92124:
	jmp	$LN1980@eval
$LN1235@eval:

; 2669 :               break;
; 2670 :            case INTEGER_TYPE: 
; 2671 :            case CONSTRAINT_TYPE:
; 2672 :            case BOUNDARY_TYPE:
; 2673 :            case QUANTITY_TYPE:
; 2674 :            case INSTANCE_TYPE:
; 2675 :            case PROCEDURE_TYPE:
; 2676 :              *++stacktop = (REAL)((int*)get_extra(id,n))[spot];

	mov	ecx, DWORD PTR _n$[ebp]
	add	DWORD PTR [ebx+48], 8
	push	ecx
	push	edi
	call	_get_extra
	fild	DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	add	esp, 8
	fstp	QWORD PTR [eax]
$adfadf_16$92124:
	jmp	$LN1980@eval
$LN1234@eval:

; 2677 :               break;
; 2678 :            case UINT_TYPE: 
; 2679 :              *++stacktop = (REAL)((unsigned int*)get_extra(id,n))[spot];

	mov	edx, DWORD PTR _n$[ebp]
	add	DWORD PTR [ebx+48], 8
	push	edx
	push	edi
	call	_get_extra
	mov	eax, DWORD PTR [eax+esi*4]
	add	esp, 8
	mov	DWORD PTR tv27151[ebp], eax
	fild	DWORD PTR tv27151[ebp]
	test	eax, eax
	jns	$LN4022@eval
	fadd	QWORD PTR __real@41f0000000000000
	mov	eax, DWORD PTR [ebx+48]
$adfadf_17$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1233@eval:

; 2680 :               break;
; 2681 :            case ULONG_TYPE: 
; 2682 :              *++stacktop = (REAL)((unsigned long*)get_extra(id,n))[spot];

	mov	ecx, DWORD PTR _n$[ebp]
	add	DWORD PTR [ebx+48], 8
	push	ecx
	push	edi
	call	_get_extra
	fild	DWORD PTR [eax+esi*4]
	mov	edx, DWORD PTR [eax+esi*4]
	add	esp, 8
	test	edx, edx
	jns	$LN4022@eval
	fadd	QWORD PTR __real@41f0000000000000
	mov	eax, DWORD PTR [ebx+48]
$adfadf_18$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1232@eval:

; 2683 :               break;
; 2684 :            case LONG_TYPE: 
; 2685 :              *++stacktop = (REAL)((long*)get_extra(id,n))[spot];

	mov	eax, DWORD PTR _n$[ebp]
	add	DWORD PTR [ebx+48], 8
	push	eax
	push	edi
	call	_get_extra
	fild	DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	add	esp, 8
	fstp	QWORD PTR [eax]
$adfadf_19$92124:
	jmp	$LN1980@eval
$LN1231@eval:

; 2686 :               break;
; 2687 :            case UCHAR_TYPE: 
; 2688 :              *++stacktop = (REAL)((unsigned char*)get_extra(id,n))[spot];

	mov	ecx, DWORD PTR _n$[ebp]
	add	DWORD PTR [ebx+48], 8
	push	ecx
	push	edi
	call	_get_extra
	movzx	edx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR tv27145[ebp], edx
	add	esp, 8
	fild	DWORD PTR tv27145[ebp]
$adfadf_20$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1230@eval:

; 2689 :               break;
; 2690 :            case CHAR_TYPE: 
; 2691 :              *++stacktop = (REAL)((char*)get_extra(id,n))[spot];

	mov	eax, DWORD PTR _n$[ebp]
	add	DWORD PTR [ebx+48], 8
	push	eax
	push	edi
	call	_get_extra
	movsx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR tv27143[ebp], ecx
	add	esp, 8
	fild	DWORD PTR tv27143[ebp]
$adfadf_21$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1229@eval:

; 2692 :               break;
; 2693 :            case SHORT_TYPE: 
; 2694 :              *++stacktop = (REAL)((short int*)get_extra(id,n))[spot];

	mov	edx, DWORD PTR _n$[ebp]
	add	DWORD PTR [ebx+48], 8
	push	edx
	push	edi
	call	_get_extra
	movsx	eax, WORD PTR [eax+esi*2]
	mov	DWORD PTR tv27141[ebp], eax
	mov	eax, DWORD PTR [ebx+48]
	fild	DWORD PTR tv27141[ebp]
	add	esp, 8
$adfadf_22$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1228@eval:

; 2695 :               break;
; 2696 :            case USHORT_TYPE: 
; 2697 :              *++stacktop = (REAL)((unsigned short int*)get_extra(id,n))[spot];

	mov	ecx, DWORD PTR _n$[ebp]
	add	DWORD PTR [ebx+48], 8
	push	ecx
	push	edi
	call	_get_extra
	movzx	edx, WORD PTR [eax+esi*2]
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR tv27139[ebp], edx
	add	esp, 8
	fild	DWORD PTR tv27139[ebp]
$adfadf_23$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1227@eval:

; 2698 :               break;
; 2699 :            case ELEMENTID_TYPE: 
; 2700 :            case VERTEX_TYPE: 
; 2701 :            case EDGE_TYPE: 
; 2702 :            case FACET_TYPE: 
; 2703 :            case BODY_TYPE: 
; 2704 :            case FACETEDGE_TYPE: 
; 2705 :              *(element_id*)(++stacktop) = 
; 2706 :                 ((element_id*)get_extra(id,n))[spot];

	mov	eax, DWORD PTR _n$[ebp]
	push	eax

; 2707 :               break;

	jmp	SHORT $LN4024@eval
$LN1226@eval:

; 2708 :            case PTR_TYPE: 
; 2709 :              *((char**)++stacktop) =  (((char**)get_extra(id,n))[spot]);

	mov	edx, DWORD PTR _n$[ebp]
	push	edx
$LN4024@eval:
	add	DWORD PTR [ebx+48], 8
	push	edi
	call	_get_extra
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	add	esp, 8
	mov	DWORD PTR [eax], ecx

; 2710 :               break;
; 2711 :          }
; 2712 :        }
; 2713 :        break; 

	jmp	$LN1980@eval
$LN1225@eval:

; 2714 : 
; 2715 :       case ON_CONSTRAINT_NODE:
; 2716 :       case ON_CONSTRAINT_NAME_NODE:
; 2717 :       { int testcon = (node->type == ON_CONSTRAINT_NODE) ? (int)*(stacktop--)
; 2718 :                             : node->op3.connum;

	cmp	edx, 10222				; 000027eeH
	jne	SHORT $LN2213@eval
	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], esi
	jmp	SHORT $LN2214@eval
$LN2213@eval:
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+140]
$LN2214@eval:

; 2719 :         if ( node->op1.localnum ) 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	test	ecx, ecx
	je	SHORT $LN1224@eval

; 2720 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	ecx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	ecx, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [ecx]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [ecx+edx*8]
	jmp	SHORT $LN1223@eval
$LN1224@eval:

; 2721 :         else id = q_id;

	mov	ecx, DWORD PTR _q_id$[ebp]
$LN1223@eval:

; 2722 :         switch(id_type(id))

	mov	edx, ecx
	shr	edx, 29					; 0000001dH
	sub	edx, 0
	je	$LN1220@eval
	dec	edx
	je	$LN1219@eval
	dec	edx
	je	SHORT $LN1218@eval

; 2726 :            default: 
; 2727 :               sprintf(errmsg,
; 2728 :                  "Can't do constraints on this type element (in %s).\n",
; 2729 :                      ex_current.name);

	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	OFFSET ??_C@_0DE@HOHHBAGN@Can?8t?5do?5constraints?5on?5this?5typ@
	push	OFFSET _errmsg
	call	_sprintf

; 2730 :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2731 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
$LL2833@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2833@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2732 :               kb_error(1272,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1272					; 000004f8H
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	$LN1980@eval
$LN1218@eval:

; 2725 :            case FACET : *++stacktop = (REAL)f_on_constraint(id,testcon); break;

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	push	ecx
	call	_f_on_constraint
	mov	DWORD PTR tv27109[ebp], eax
	fild	DWORD PTR tv27109[ebp]
	add	esp, 8
	fstp	QWORD PTR [esi]
	jmp	$LN1980@eval
$LN1219@eval:

; 2724 :            case EDGE  : *++stacktop = (REAL)e_on_constraint(id,testcon); break;

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	push	ecx
	call	_e_on_constraint
	mov	DWORD PTR tv27107[ebp], eax
	fild	DWORD PTR tv27107[ebp]
	add	esp, 8
	fstp	QWORD PTR [esi]
	jmp	$LN1980@eval
$LN1220@eval:

; 2723 :          { case VERTEX: *++stacktop = (REAL)v_on_constraint(id,testcon); break;

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	push	ecx
	call	_v_on_constraint
	mov	DWORD PTR tv27105[ebp], eax
	fild	DWORD PTR tv27105[ebp]
	add	esp, 8
	fstp	QWORD PTR [esi]

; 2733 :          }
; 2734 :        }
; 2735 :       break;

	jmp	$LN1980@eval
$LN1216@eval:

; 2736 : 
; 2737 :       case CONSTRAINT_VALUE_NODE:
; 2738 :       case CONSTRAINT_NAME_VALUE_NODE:
; 2739 :       { int connum = (node->type == CONSTRAINT_VALUE_NODE) ? (int)*(stacktop--)
; 2740 :                             : node->op3.connum;

	cmp	edx, 10224				; 000027f0H
	jne	SHORT $LN2215@eval
	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	mov	edi, eax
	mov	DWORD PTR [ebx+48], esi
	jmp	SHORT $LN2216@eval
$LN2215@eval:
	mov	eax, DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR [eax+140]
$LN2216@eval:

; 2741 :         if ( node->op1.localnum ) 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN1215@eval

; 2742 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+40]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN1214@eval
$LN1215@eval:

; 2743 :         else id = q_id;

	mov	esi, DWORD PTR _q_id$[ebp]
$LN1214@eval:

; 2744 :         if ( id_type(id) != VERTEX )

	test	esi, -536870912				; e0000000H
	je	SHORT $LN1213@eval

; 2745 :         { sprintf(errmsg,"Can only do constraint value for vertices.\n");

	push	OFFSET ??_C@_0CM@IPCEGKDM@Can?5only?5do?5constraint?5value?5for@
	push	OFFSET _errmsg
	call	_sprintf

; 2746 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2747 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL2834@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2834@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2748 :           kb_error(4272,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4272					; 000010b0H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1213@eval:

; 2749 :         }
; 2750 :         PUSH_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	cmp	eax, 100				; 00000064H
	jl	SHORT $LN1212@eval
	xor	eax, eax
$LN1212@eval:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _eval_stack_trace[eax*4], ecx
	inc	eax
	mov	DWORD PTR _eval_stack_trace_spot, eax

; 2751 :         *++stacktop = eval(get_constraint(connum)->formula ,get_coord(id), id, NULL);

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR _web+12
	push	0
	push	esi
	and	edi, 1073741823				; 3fffffffH
	mov	DWORD PTR tv17681[ebp], edx
	imul	edi, 176				; 000000b0H
	mov	edx, DWORD PTR _dymem
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _web+104
	add	ecx, DWORD PTR [eax+edx+64]
	push	ecx
	mov	ecx, DWORD PTR _web+652
	mov	edx, DWORD PTR [edi+ecx+40]
	push	edx
	call	_eval
	mov	eax, DWORD PTR tv17681[ebp]
	fstp	QWORD PTR [eax]

; 2752 :         POP_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	add	esp, 16					; 00000010H
	test	eax, eax
	jle	$LN1980@eval

; 2753 :       }
; 2754 :       break;

	jmp	$LN4000@eval
$LN1210@eval:

; 2755 : 
; 2756 :       case HIT_CONSTRAINT_NODE:
; 2757 :       case HIT_CONSTRAINT_NAME_NODE:
; 2758 :       { int testcon = (node->type == HIT_CONSTRAINT_NODE) ? (int)*(stacktop--)
; 2759 :                             : node->op3.connum;

	cmp	edx, 10226				; 000027f2H
	jne	SHORT $LN2217@eval
	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], esi
	jmp	SHORT $LN2218@eval
$LN2217@eval:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+140]
$LN2218@eval:

; 2760 :         if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	test	ecx, ecx
	je	SHORT $LN1209@eval

; 2761 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	ecx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	ecx, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [ecx]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [ecx+edx*8]
	jmp	SHORT $LN1208@eval
$LN1209@eval:

; 2762 :         else id = q_id;

	mov	ecx, DWORD PTR _q_id$[ebp]
$LN1208@eval:

; 2763 :         switch(id_type(id))

	test	ecx, -536870912				; e0000000H
	je	$LN1205@eval

; 2765 :               break;
; 2766 :           default: 
; 2767 :              sprintf(errmsg, 
; 2768 :                 "Can do hit_constraints only on vertices (in %s).\n",ex_current.name);

	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	OFFSET ??_C@_0DC@LFBDKEHN@Can?5do?5hit_constraints?5only?5on?5v@
	push	OFFSET _errmsg
	call	_sprintf

; 2769 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2770 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
$LL2835@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2835@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2771 :              kb_error(1273,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1273					; 000004f9H
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	$LN1980@eval
$LN1205@eval:

; 2764 :         { case VERTEX: *++stacktop = (REAL)get_v_constraint_status(id,testcon); 

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	push	ecx
	call	_get_v_constraint_status
	mov	DWORD PTR tv27060[ebp], eax
	fild	DWORD PTR tv27060[ebp]
	add	esp, 8
	fstp	QWORD PTR [esi]

; 2772 :         }
; 2773 :       }
; 2774 :       break;

	jmp	$LN1980@eval
$LN1203@eval:

; 2775 : 
; 2776 :       case ON_BOUNDARY_NODE:
; 2777 :       case ON_BOUNDARY_NAME_NODE:
; 2778 :        { struct boundary *b=NULL;

	xor	esi, esi

; 2779 :          int testb = (node->type == ON_BOUNDARY_NODE) ? (int)*(stacktop--)
; 2780 :                             : node->op3.bdrynum;

	cmp	edx, 10228				; 000027f4H
	jne	SHORT $LN2219@eval
	mov	edi, DWORD PTR [ebx+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	add	edi, -8					; fffffff8H
	mov	DWORD PTR _testb$90953[ebp], eax
	mov	DWORD PTR [ebx+48], edi
	jmp	SHORT $LN2220@eval
$LN2219@eval:
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR _testb$90953[ebp], ecx
$LN2220@eval:

; 2781 :          if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1202@eval

; 2782 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1201@eval
$LN1202@eval:

; 2783 :          else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1201@eval:

; 2784 :          if ( !(get_attr(id) & BOUNDARY) )

	mov	ecx, eax
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edi, DWORD PTR [eax+eax]
	shr	ecx, 29					; 0000001dH
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 4
	mov	edx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR [edx+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	jne	SHORT $LN1200@eval

; 2785 :          { *++stacktop = 0.0;

	add	DWORD PTR [ebx+48], 8
	fldz
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 2786 :            break;

	jmp	$LN1980@eval
$LN1200@eval:

; 2787 :          }
; 2788 :          switch(id_type(id))

	mov	eax, ecx
	sub	eax, 0
	je	$LN1197@eval
	dec	eax
	je	$LN1196@eval
	dec	eax
	je	$LN1195@eval

; 2792 :            default: 
; 2793 :               sprintf(errmsg,
; 2794 :                  "Can't do boundary on a %s (in %s).\n",
; 2795 :                     typenames[id_type(id)],ex_current.name);

	mov	ecx, DWORD PTR _typenames[ecx*4]
	lea	eax, DWORD PTR _ex_current$[ebp+20]
	push	eax
	push	ecx
	push	OFFSET ??_C@_0CE@JPLNIPHC@Can?8t?5do?5boundary?5on?5a?5?$CFs?5?$CIin?5?$CFs@
	push	OFFSET _errmsg
	call	_sprintf

; 2796 :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2797 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL2836@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2836@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2798 :               kb_error(1274,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1274					; 000004faH
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	$LN2222@eval
$LN1195@eval:

; 2791 :            case FACET : b = get_facet_boundary(id); break;

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	test	eax, eax
	je	$LN2221@eval
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR _web+236
	jmp	SHORT $LN3961@eval
$LN1196@eval:

; 2790 :            case EDGE  : b = get_edge_boundary(id); break;

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN2221@eval
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edx, DWORD PTR [ecx+edi]
	mov	esi, DWORD PTR [eax+edx]
	imul	esi, 136				; 00000088H
	add	esi, DWORD PTR _web+776
	jmp	SHORT $LN2222@eval
$LN1197@eval:

; 2789 :          { case VERTEX: b = get_boundary(id); break;

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN2221@eval
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR _web+12
$LN3961@eval:
	mov	ecx, DWORD PTR [eax+edi]
	mov	esi, DWORD PTR [edx+ecx]
	imul	esi, 136				; 00000088H
	add	esi, DWORD PTR _web+776
	jmp	SHORT $LN2222@eval
$LN2221@eval:
	xor	esi, esi
$LN2222@eval:

; 2799 :          }
; 2800 :          *++stacktop = (b == web.boundaries+testb) ? 1.0 : 0.0;

	mov	eax, DWORD PTR _testb$90953[ebp]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	cmp	esi, eax
	jne	$LN2093@eval
	fld1
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN1193@eval:

; 2801 :        }
; 2802 :        break;
; 2803 : 
; 2804 :       case ON_METHOD_INSTANCE_NODE:
; 2805 :        { struct element *eptr;
; 2806 :          int *mptr;
; 2807 :          if ( node->op1.localnum ) 

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN1192@eval

; 2808 :            id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1191@eval
$LN1192@eval:

; 2809 :          else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1191@eval:

; 2810 :          eptr = elptr(id);

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	edx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+eax*4]

; 2811 :          mptr = (int*)((char*)eptr+get_meth_offset(id_type(id)));

	push	ecx
	mov	DWORD PTR _eptr$90988[ebp], edi
	call	_get_meth_offset

; 2812 :          for ( i = 0 ; i < eptr->method_count ; i++ )

	movzx	esi, WORD PTR [edi+24]
	add	esp, 4
	lea	ecx, DWORD PTR [edi+eax]
	mov	DWORD PTR _i$[ebp], 0
	test	esi, esi
	jle	SHORT $LN1188@eval

; 2813 :            if ( abs(node->op2.meth_id) == abs(mptr[i]) )

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
	npad	8
$LL1190@eval:
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	edi, eax
	je	SHORT $LN2614@eval

; 2812 :          for ( i = 0 ; i < eptr->method_count ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, esi
	jl	SHORT $LL1190@eval

; 2814 :            { *++stacktop = 1.0;

	mov	edi, DWORD PTR _eptr$90988[ebp]

; 2815 :              break;
; 2816 :            }
; 2817 :          if ( i == eptr->method_count ) 

	movzx	eax, WORD PTR [edi+24]
	cmp	DWORD PTR _i$[ebp], eax

; 2818 :            *++stacktop = 0.0;
; 2819 :          break;

	jmp	$LN4005@eval
$LN2614@eval:

; 2814 :            { *++stacktop = 1.0;

	add	DWORD PTR [ebx+48], 8
	fld1
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
	mov	edi, DWORD PTR _eptr$90988[ebp]
$LN1188@eval:

; 2815 :              break;
; 2816 :            }
; 2817 :          if ( i == eptr->method_count ) 

	movzx	eax, WORD PTR [edi+24]
	cmp	DWORD PTR _i$[ebp], eax

; 2818 :            *++stacktop = 0.0;
; 2819 :          break;

	jmp	$LN4005@eval
$LN1185@eval:

; 2820 :        } 
; 2821 : 
; 2822 :       case ON_QUANTITY_NODE:
; 2823 :        { struct element *eptr;
; 2824 :          int *mptr;
; 2825 :          int found = 0;
; 2826 :          int j;
; 2827 :          struct method_instance *mi;
; 2828 :          if ( node->op1.localnum ) 

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR _found$91006[ebp], 0
	test	eax, eax
	je	SHORT $LN1184@eval

; 2829 :            id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+40]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN1183@eval
$LN1184@eval:

; 2830 :          else id = q_id;

	mov	eax, DWORD PTR _q_id$[ebp]
$LN1183@eval:

; 2831 :          eptr = elptr(id);

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	edx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+eax*4]

; 2832 :          mptr = (int*)((char*)eptr+get_meth_offset(id_type(id)));

	push	ecx
	mov	DWORD PTR _eptr$91004[ebp], esi
	call	_get_meth_offset

; 2833 :          for ( i = 0 ; i < eptr->method_count ; i++ )

	mov	ecx, DWORD PTR _eptr$91004[ebp]
	lea	edi, DWORD PTR [esi+eax]
	xor	eax, eax
	add	esp, 4
	xor	esi, esi
	cmp	ax, WORD PTR [ecx+24]
	jae	SHORT $LN1180@eval
$LL1182@eval:

; 2834 :          { mi = METH_INSTANCE(abs(mptr[i]));

	mov	eax, DWORD PTR [edi+esi*4]
	cdq
	xor	eax, edx
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _node$[ebp]
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list
	mov	edx, DWORD PTR [edx+136]

; 2835 :            for ( j = 0 ; j < MMAXQUANTS ; j++ )

	xor	ecx, ecx
	add	eax, 152				; 00000098H
$LL1179@eval:

; 2836 :              if ( mi->quants[j] == node->op2.quant_id )

	cmp	DWORD PTR [eax], edx
	je	SHORT $LN2615@eval

; 2835 :            for ( j = 0 ; j < MMAXQUANTS ; j++ )

	inc	ecx
	add	eax, 4
	cmp	ecx, 8
	jl	SHORT $LL1179@eval

; 6334 :                 a = NULL;
; 6335 :               }
; 6336 :             }
; 6337 :          }
; 6338 :         if ( this_frame->flags & BASE_OF_EVAL )

	jmp	SHORT $LN1181@eval
$LN2615@eval:

; 2837 :              { *++stacktop = 1.0;

	add	DWORD PTR [ebx+48], 8
	fld1
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]

; 2838 :                found = 1;

	mov	DWORD PTR _found$91006[ebp], 1
$LN1181@eval:

; 2833 :          for ( i = 0 ; i < eptr->method_count ; i++ )

	mov	eax, DWORD PTR _eptr$91004[ebp]
	movzx	ecx, WORD PTR [eax+24]
	inc	esi
	cmp	esi, ecx
	jl	SHORT $LL1182@eval
$LN1180@eval:

; 2839 :                break;
; 2840 :              }
; 2841 :          }
; 2842 :          if ( !found ) 

	cmp	DWORD PTR _found$91006[ebp], 0

; 2843 :            *++stacktop = 0.0;
; 2844 :          break;

	jmp	$LN4005@eval
$LN1174@eval:

; 2845 :        } 
; 2846 : 
; 2847 :       case SELF_ELEMENT_NODE:
; 2848 :         if ( !valid_id(self_id) )

	test	DWORD PTR _self_id$GSCopy$[ebp], 268435456 ; 10000000H
	jne	SHORT $LN1173@eval

; 2849 :         { sprintf(errmsg,"No element for SELF to refer to in %s.\n",ex_current.name);

	lea	edx, DWORD PTR _ex_current$[ebp+20]
	push	edx
	push	OFFSET ??_C@_0CI@PJIGNBKB@No?5element?5for?5SELF?5to?5refer?5to?5@
	push	OFFSET _errmsg
	call	_sprintf

; 2850 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2851 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL2837@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2837@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2852 :           kb_error(2069,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2069					; 00000815H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1173@eval:

; 2853 :         }
; 2854 :         *(element_id*)get_localp(node->op2.localnum) = self_id;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR _self_id$GSCopy$[ebp]
	mov	DWORD PTR [edx+ecx*8], eax

; 2855 :         break;

	jmp	$LN1980@eval
$LN1171@eval:

; 2856 : 
; 2857 :       case SYMBOL_ELEMENT_NODE:
; 2858 :         break;
; 2859 : 
; 2860 :       case SINGLE_ELEMENT_EXPR_NODE:
; 2861 :           *(element_id*)(++stacktop) = 
; 2862 :               *(element_id*)get_localp(node[node->left].op2.localnum);

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+4]
	imul	edx, 168				; 000000a8H
	mov	eax, DWORD PTR [edx+eax+136]
	mov	ecx, DWORD PTR [ebx+48]
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+eax+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR [ecx], edx

; 2863 :           break;

	jmp	$LN1980@eval
$LN1170@eval:

; 2864 : 
; 2865 :       case ELEMENT_IDENT_NODE:
; 2866 :           *(element_id*)get_localp(node->op2.localnum)
; 2867 :              = globals(node->op3.name_id)->value.id;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN2229@eval
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2231@eval
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR [eax]
	jmp	SHORT $LN2230@eval
$LN2231@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2229@eval
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN2230@eval
$LN2229@eval:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [eax+ecx]
$LN2230@eval:
	mov	eax, DWORD PTR [edx+136]
	mov	ecx, DWORD PTR [ecx+64]
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+eax+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR [eax+edx*8], ecx

; 2868 :           break;

	jmp	$LN1980@eval
$LN1169@eval:

; 2869 : 
; 2870 :       case INDEXED_SUBTYPE_NODE:  /* like ee.vertex[1] */
; 2871 :         { element_id next_id;
; 2872 :           int ord = (int)*(stacktop--) - 1;  /* which one */

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], esi

; 2873 :           element_id parent = node[node->left].op2.localnum ?
; 2874 :             *(element_id*)get_localp(node[node->left].op2.localnum) : q_id;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 168				; 000000a8H
	mov	edx, DWORD PTR [edx+ecx+136]
	dec	eax
	test	edx, edx
	je	SHORT $LN2235@eval
	and	edx, 16777215				; 00ffffffH
	lea	esi, DWORD PTR [edx*8]
	sub	esi, edx
	mov	edx, DWORD PTR _localbase$[ebp]
	mov	edx, DWORD PTR [edx]
	shl	esi, 5
	mov	edx, DWORD PTR [esi+edx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR [esi+edx*8]
	jmp	SHORT $LN2236@eval
$LN2235@eval:
	mov	edx, DWORD PTR _q_id$[ebp]
$LN2236@eval:

; 2875 :           next_id = get_indexed_subtype(node,ord,parent,&ex_current);

	lea	esi, DWORD PTR _ex_current$[ebp]
	push	esi
	push	edx
	push	eax
	push	ecx
	call	_get_indexed_subtype

; 2876 :           *(element_id*)get_localp(node->op2.localnum) = next_id;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [ecx+136]
	and	ecx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	ecx, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [ecx]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	mov	ecx, DWORD PTR [ebx+40]
	add	esp, 16					; 00000010H
	add	edx, DWORD PTR _localstack$[ebp]
	mov	DWORD PTR [ecx+edx*8], eax

; 2877 :         } break;  /* end INDEXED_SUBTYPE */

	jmp	$LN1980@eval
$LN1168@eval:

; 2878 : 
; 2879 :       case INDEXED_ELEMENT_NODE:
; 2880 :        { element_id partid = *(element_id*)(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	mov	edi, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax

; 2881 :          element_id id;
; 2882 :          id = get_full_id(node->op1.eltype,partid);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	edi
	push	eax
	call	_get_full_id
	mov	esi, eax
	add	esp, 8

; 2883 :          if ( !valid_id(id) ) 

	test	esi, 268435456				; 10000000H
	jne	$LN1167@eval

; 2884 :          { sprintf(errmsg,"%s index %d is not valid.\n",
; 2885 :               typenames[node->op1.eltype],
; 2886 :               valid_id(partid) ? (int)(partid & OFFSETMASK)+1 : 0);

	test	edi, 268435456				; 10000000H
	je	SHORT $LN2237@eval
	and	edi, 134217727				; 07ffffffH
	inc	edi
	jmp	SHORT $LN2238@eval
$LN2237@eval:
	xor	edi, edi
$LN2238@eval:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _typenames[edx*4]
	push	edi
	push	eax
	push	OFFSET ??_C@_0BL@MACKFC@?$CFs?5index?5?$CFd?5is?5not?5valid?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 2887 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2888 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL2838@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2838@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2889 :            kb_error(1200,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1200					; 000004b0H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1167@eval:

; 2890 :          }
; 2891 :          *(element_id *)get_localp(node->op2.localnum) = id;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	DWORD PTR [edx+ecx*8], esi

; 2892 :          break;

	jmp	$LN1980@eval
$LN1165@eval:

; 2893 :        }
; 2894 : 
; 2895 :       case QUALIFIED_ATTRIBUTE_NODE:
; 2896 :           break; /* just a no-op in execution */
; 2897 : 
; 2898 :          /****************************/
; 2899 :          /* aggregate initialization */
; 2900 :          /****************************/
; 2901 : 
; 2902 :       case SET_INIT_NODE: 
; 2903 :         web.where_count = 0;
; 2904 :         /* break and continue jumps */
; 2905 :         *(size_t*)(newstack + localstack + node->stackpos) = stacktop - (newstack + localstack) + 3;

	mov	ecx, DWORD PTR _localstack$[ebp]
	mov	DWORD PTR _web+5496, 0
	mov	esi, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [ebx+40]
	lea	edx, DWORD PTR [ecx*8]
	sub	esi, edx
	mov	edx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [edx+160]
	sub	esi, eax
	sar	esi, 3
	add	esi, 3
	add	edx, ecx
	mov	DWORD PTR [eax+edx*8], esi

; 2906 : #ifdef MPI_EVOLVER
; 2907 :         if ( this_task == MASTER_TASK ) 
; 2908 :         { mpi_subtask_command_flag = 1;
; 2909 :           mpi_aggregate(node,&ex_current);
; 2910 :         }
; 2911 : #endif
; 2912 :         break;

	jmp	$LN1980@eval
$LN1164@eval:

; 2913 : 
; 2914 :       case AGGREGATE_INIT_NODE:
; 2915 :         aggregate_depth++;

	inc	DWORD PTR _aggregate_depth

; 2916 :         web.where_count = 0;
; 2917 :         /* break and continue jumps */
; 2918 :         *(size_t*)(newstack + localstack + node->stackpos) = stacktop - (newstack + localstack) + 3; 

	mov	ecx, DWORD PTR _localstack$[ebp]
	mov	DWORD PTR _web+5496, 0
	mov	esi, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [ebx+40]
	lea	edx, DWORD PTR [ecx*8]
	sub	esi, edx
	mov	edx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [edx+160]
	sub	esi, eax
	sar	esi, 3
	add	edx, ecx
	add	esi, 3
	mov	DWORD PTR [eax+edx*8], esi

; 2919 :         switch ( node->op1.aggrtype )

	mov	edx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	mov	eax, ecx
	cmp	eax, 10339				; 00002863H
	jg	$LN2239@eval
	je	$LN1160@eval
	sub	eax, 10077				; 0000275dH
	cmp	eax, 16					; 00000010H
	ja	$LN1126@eval
	movzx	eax, BYTE PTR $LN2839@eval[eax]
	jmp	DWORD PTR $LN4033@eval[eax*4]
$LN1151@eval:

; 2956 : 
; 2957 :               case LIST_NODE: /* print column headers */
; 2958 : #ifdef MPI_EVOLVER
; 2959 :                if ( (this_task == MASTER_TASK) || !mpi_subtask_command_flag )
; 2960 : #endif
; 2961 :                 switch ( node->op2.eltype )

	mov	edx, DWORD PTR [edx+136]
	cmp	edx, 4
	ja	$LN1980@eval
	jmp	DWORD PTR $LN4034@eval[edx*4]
$LN1148@eval:

; 2962 :                 { case VERTEX:
; 2963 :                   if ( SDIM == 2 )

	cmp	DWORD PTR _web+616, 2
	jne	SHORT $LN1147@eval

; 2964 :      outstring("// Id               X                Y\n");

	push	OFFSET ??_C@_0CI@MDNPENBI@?1?1?5Id?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5X?5?5?5?5?5?5?5?5?5?5?5@
	call	_outstring
	add	esp, 4

; 2965 :                 else

	jmp	$LN1980@eval
$LN1147@eval:

; 2966 :      outstring("// Id               X                Y               Z\n");

	push	OFFSET ??_C@_0DI@OJNBJBKG@?1?1?5Id?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5X?5?5?5?5?5?5?5?5?5?5?5@
	call	_outstring
	add	esp, 4

; 2967 :                     break;

	jmp	$LN1980@eval
$LN1145@eval:

; 2968 :                  case EDGE:
; 2969 :                     outstring("// Id    endpoints\n");

	push	OFFSET ??_C@_0BE@OOAKAHKL@?1?1?5Id?5?5?5?5endpoints?6?$AA@
	call	_outstring
	add	esp, 4

; 2970 :                     break;

	jmp	$LN1980@eval
$LN1144@eval:

; 2971 :                  case FACET:
; 2972 :                     if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN1143@eval

; 2973 :                       outstring("// Id      vertices\n");

	push	OFFSET ??_C@_0BF@FCNHMFEN@?1?1?5Id?5?5?5?5?5?5vertices?6?$AA@
	call	_outstring
	add	esp, 4
	jmp	$LN1980@eval
$LN1143@eval:

; 2974 :                     else outstring("// Id    edges\n");

	push	OFFSET ??_C@_0BA@PJOLDBBB@?1?1?5Id?5?5?5?5edges?6?$AA@
	call	_outstring
	add	esp, 4

; 2975 :                     break;

	jmp	$LN1980@eval
$LN1141@eval:

; 2976 :                  case BODY:
; 2977 :                     outstring("// Id    facets\n");

	push	OFFSET ??_C@_0BB@BBHHCCHN@?1?1?5Id?5?5?5?5facets?6?$AA@
	call	_outstring
	add	esp, 4

; 2978 :                     break;

	jmp	$LN1980@eval
$LN1140@eval:

; 2979 :                  case FACETEDGE:
; 2980 :                     outstring("//    id       edge    facet  prevedge nextedge    prevfacet nextfacet\n");

	push	OFFSET ??_C@_0EI@DJBIKLIA@?1?1?5?5?5?5id?5?5?5?5?5?5?5edge?5?5?5?5facet?5?5pr@
	call	_outstring
	add	esp, 4

; 2981 :                     break;
; 2982 :                 }
; 2983 :               break;

	jmp	$LN1980@eval
$LN1160@eval:

; 2920 :           {  case FOREACH_NODE:
; 2921 :              case SET_ATTRIBUTE_LOOP_NODE:
; 2922 :                 break;
; 2923 : 
; 2924 :               case MAX_NODE:
; 2925 :                 *++stacktop = -MAXDOUBLE; /* max of empty set */

	add	DWORD PTR [ebx+48], 8
	fld	QWORD PTR __real@c7d2ced32a16a1b1
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
$adfadf_24$92124:
	jmp	$LN1980@eval
$LN2239@eval:

; 2919 :         switch ( node->op1.aggrtype )

	sub	eax, 10340				; 00002864H
	cmp	eax, 7
	ja	$LN1126@eval
	jmp	DWORD PTR $LN4035@eval[eax*4]
$LN1159@eval:

; 2926 :                 break;
; 2927 : 
; 2928 :               case MIN_NODE:
; 2929 :                 *++stacktop = MAXDOUBLE; /* min of empty set */

	add	DWORD PTR [ebx+48], 8
	fld	QWORD PTR __real@47d2ced32a16a1b1
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
$adfadf_25$92124:
	jmp	$LN1980@eval
$LN1157@eval:

; 2930 :                 break;
; 2931 : 
; 2932 :               case SUM_NODE: 
; 2933 :                 *++stacktop = 0.0; /* sum */
; 2934 :                 break;
; 2935 : 
; 2936 :               case AVG_NODE:
; 2937 :                 *++stacktop = 0.0; /* count */

	fldz
	mov	ecx, 8
	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]

; 2938 :                 *++stacktop = 0.0; /* sum */

	add	DWORD PTR [ebx+48], ecx
	fst	QWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+48]
	fstp	QWORD PTR [eax]
$adfadf_26$92124:
	jmp	$LN1980@eval
$LN1155@eval:

; 2939 :                 break;
; 2940 : 
; 2941 :               case COUNT_NODE:
; 2942 :                 *++stacktop = 0.0; /* count */
; 2943 :                 break;
; 2944 : 
; 2945 :               case HISTOGRAM_NODE:
; 2946 :               case LOGHISTOGRAM_NODE:
; 2947 :                 *++stacktop = 0.0; /* first phase counter */

	fldz
	mov	edx, 8
	add	DWORD PTR [ebx+48], edx
	mov	eax, DWORD PTR [ebx+48]

; 2948 :                 *++stacktop = MAXDOUBLE;  /* min */

	add	DWORD PTR [ebx+48], edx
	fst	QWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR __real@47d2ced32a16a1b1

; 2949 :                 *++stacktop = -MAXDOUBLE; /* max */

	add	DWORD PTR [ebx+48], edx
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR __real@c7d2ced32a16a1b1
	fstp	QWORD PTR [eax]
	mov	ecx, 22					; 00000016H
$LN1154@eval:

; 2951 :                   *++stacktop = 0.0;

	add	eax, edx
	dec	ecx
	fst	QWORD PTR [eax]
	jne	SHORT $LN1154@eval

; 2950 :                 for ( n = 0 ; n < HISTBINS+1 ; n++ )

	mov	DWORD PTR [ebx+48], eax
	fstp	ST(0)

; 2952 :                 histo_max = web.skel[node->op2.eltype].count + 5;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+136]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax

; 2953 :                 histo_data = (REAL*)temp_calloc(histo_max,sizeof(REAL));

	push	2953					; 00000b89H
	shl	edx, 4
	mov	eax, DWORD PTR _web[edx+64]
	push	OFFSET ??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@
	add	eax, 5
	push	8
	push	eax
	mov	DWORD PTR _histo_max$[ebp], eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _histo_data$[ebp], eax

; 2954 :                 histo_count = 0;

	mov	DWORD PTR _histo_count$[ebp], 0

; 2955 :                 break;

	jmp	$LN1980@eval
$LN1126@eval:

; 2984 : 
; 2985 :               case REFINE_NODE: 
; 2986 : #ifdef MPI_EVOLVER
; 2987 :                if ( (this_task != MASTER_TASK) && mpi_subtask_command_flag 
; 2988 :                  &&  node->op2.eltype == EDGE )
; 2989 :                      mpi_edge_refine_init();
; 2990 : #endif
; 2991 :                 break;
; 2992 :               
; 2993 :               case DISSOLVE_NODE:
; 2994 :                 break;
; 2995 : 
; 2996 :               case DELETE_NODE:
; 2997 : #ifdef MPI_EVOLVER
; 2998 :                if ( this_task == MASTER_TASK )
; 2999 :                  mpi_set_corona(THIN_CORONA);
; 3000 : 
; 3001 :                if ( (this_task != MASTER_TASK) && mpi_subtask_command_flag )
; 3002 :                      mpi_delete_init();
; 3003 : #endif
; 3004 :                 break;
; 3005 :               
; 3006 :               case FIX_NODE:
; 3007 :                 break;
; 3008 : 
; 3009 :               case UNFIX_NODE:
; 3010 :                 break;
; 3011 :               case REVERSE_ORIENTATION_NODE: break;
; 3012 :               case EDGESWAP_NODE: break;
; 3013 :               case T1_EDGESWAP_NODE: break;
; 3014 :               case EQUIANGULATE_NODE: break;
; 3015 : 
; 3016 :               case POP_NODE: case POP_TRI_TO_EDGE_NODE:
; 3017 :               case POP_EDGE_TO_TRI_NODE: case POP_QUAD_TO_QUAD_NODE:
; 3018 :                 break;
; 3019 : 
; 3020 :               case VERTEX_AVERAGE_NODE: break;
; 3021 :               case RAW_VERTEX_AVERAGE_NODE: break;
; 3022 :               case RAWEST_VERTEX_AVERAGE_NODE: break;
; 3023 : 
; 3024 :               default: 
; 3025 :                  sprintf(errmsg,"Internal error: Bad aggregate type %d.\n",
; 3026 :                       node->op1.aggrtype);

	push	ecx
	push	OFFSET ??_C@_0CI@BOPKOLFN@Internal?5error?3?5Bad?5aggregate?5ty@
	push	OFFSET _errmsg
	call	_sprintf

; 3027 :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 3028 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
	npad	4
$LL2840@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2840@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 3029 :                  kb_error(1290,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1290					; 0000050aH
	call	_kb_error
	add	esp, 28					; 0000001cH

; 3030 :                  break;
; 3031 :             }
; 3032 : #ifdef MPI_EVOLVER
; 3033 :                 if ( this_task == MASTER_TASK ) 
; 3034 :                 { mpi_subtask_command_flag = 1;
; 3035 :                   mpi_aggregate(node,&ex_current);
; 3036 :                 }
; 3037 : #endif
; 3038 : 
; 3039 :          break;

	jmp	$LN1980@eval
$LN1125@eval:

; 3040 :          /* end case AGGREGATE_INIT */
; 3041 : 
; 3042 :         /************************/
; 3043 :         /* next element in loop */
; 3044 :         /************************/
; 3045 :          
; 3046 :       case SINGLE_ELEMENT_NODE: 
; 3047 :           q_id = *(element_id*)get_localp(node[node->left].op2.localnum);

	mov	edx, DWORD PTR _node$[ebp]

; 3048 :           if ( stacktop[-1] > 0.0 ) /* done */

	fldz
	mov	eax, DWORD PTR [edx+4]
	imul	eax, 168				; 000000a8H
	mov	eax, DWORD PTR [eax+edx+136]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR _q_id$[ebp], ecx
	mov	ecx, DWORD PTR [ebx+48]
	fcomp	QWORD PTR [ecx-8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1124@eval

; 3049 :               node += node->op1.skipsize;

	mov	eax, DWORD PTR [edx+32]
	imul	eax, 168				; 000000a8H
	add	edx, eax
	mov	DWORD PTR _node$[ebp], edx
	jmp	$LN1980@eval
$LN1124@eval:

; 3050 :           else stacktop[-1] = 1.0;

	fld1
	fstp	QWORD PTR [ecx-8]

; 3051 :           break;

	jmp	$LN1980@eval
$LN1122@eval:

; 3052 : 
; 3053 :       case NEXT_VERTEX_NODE: /* all vertices */
; 3054 :        { 
; 3055 :          vertex_id *vp;
; 3056 :          vp = (element_id *)(stacktop - 0);

	mov	ecx, DWORD PTR [ebx+48]

; 3057 :          if ( !valid_id(*vp) || breakflag )

	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	je	$LN1707@eval
	cmp	DWORD PTR _breakflag, 0
	jne	$LN1707@eval

; 3058 :          { /* done */ 
; 3059 :            node += node->op1.skipsize - 1;
; 3060 :            break;
; 3061 :          }
; 3062 :          q_id = *vp;

	mov	edx, eax

; 3063 :          *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	and	eax, 16777215				; 00ffffffH
	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	esi, 5
	mov	eax, DWORD PTR [esi+eax+216]
	add	eax, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+eax*8], edx

; 3064 :          /* check sentinel; set for next time around */
; 3065 :          if ( equal_id(*vp,*(vertex_id*)(stacktop-1)) ) *vp = NULLID;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _q_id$[ebp], edx
	mov	edx, DWORD PTR [ebx+48]
	cmp	eax, DWORD PTR [edx-8]
	jne	SHORT $LN1119@eval
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN1118@eval
$LN1119@eval:

; 3066 :          else *vp = vptr(*vp)->forechain;

	mov	edx, DWORD PTR _web+12
$LN4026@eval:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
$LN1118@eval:

; 3067 : 
; 3068 :          if ( !valid_element(q_id) ) node--;    /* skip body of loop */

	mov	eax, DWORD PTR _q_id$[ebp]
$LN4009@eval:
	push	eax
$LN4008@eval:
	call	_valid_element
	add	esp, 4
	test	eax, eax
$LN4011@eval:
	jne	$LN1980@eval
	sub	DWORD PTR _node$[ebp], 168		; 000000a8H

; 3069 : #ifdef MPI_EVOLVER
; 3070 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3071 :             node--;  /* don't count foreign vertices in global aggregate */
; 3072 : #endif
; 3073 :         }
; 3074 :         break; 

	jmp	$LN1980@eval
$LN1116@eval:

; 3075 : 
; 3076 :       case NEXT_EDGE_VERTEX_NODE: /* edge vertices */
; 3077 :        {
; 3078 :          int *numptr;
; 3079 :          vertex_id *vp;
; 3080 :          numptr = (int *)(stacktop - 1);

	mov	ecx, DWORD PTR [ebx+48]

; 3081 :          if ( *numptr== web.skel[EDGE].ctrlpts ) 

	mov	edx, DWORD PTR [ecx-8]
	cmp	edx, DWORD PTR _web+120

; 3082 :             { /* done */
; 3083 :               node += node->op1.skipsize - 1;
; 3084 :               break;

	je	$LN1707@eval

; 3085 :             }
; 3086 :          vp = *(element_id **)(stacktop - 0);

	mov	eax, DWORD PTR [ecx]

; 3087 :          q_id = vp[*numptr];

	mov	edx, DWORD PTR [eax+edx*4]

; 3088 :          *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	and	eax, 16777215				; 00ffffffH
	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	esi, 5
	mov	eax, DWORD PTR [esi+eax+216]
	add	eax, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+eax*8], edx

; 3089 :          (*numptr)++;

	inc	DWORD PTR [ecx-8]
	mov	DWORD PTR _q_id$[ebp], edx

; 3090 : 
; 3091 :           if ( !valid_element(q_id) ) node--;    /* skip body of loop */

	push	edx

; 3092 : #ifdef MPI_EVOLVER
; 3093 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3094 :             node--;  /* don't count foreign elements in global aggregate */
; 3095 : #endif 
; 3096 :          break;

	jmp	SHORT $LN4008@eval
$LN1113@eval:

; 3097 :        }
; 3098 : 
; 3099 :       case NEXT_FACET_VERTEX_NODE: /* facet vertices */
; 3100 :         {
; 3101 : 
; 3102 :           facetedge_id *fe_ptr;
; 3103 :           facet_id *f_ptr;
; 3104 :           if ( (web.representation == SIMPLEX) ||
; 3105 :               (web.modeltype==LAGRANGE) )

	mov	ecx, DWORD PTR _web+624
	cmp	ecx, 3
	je	$LN1111@eval
	mov	eax, DWORD PTR _web+628
	cmp	eax, 3
	je	$LN1111@eval

; 3114 :           }
; 3115 :           else if ( (web.modeltype == QUADRATIC) 
; 3116 :                       && (web.representation == SOAPFILM) )

	cmp	eax, 2
	jne	$LN1108@eval
	cmp	ecx, eax
	jne	$LN1108@eval

; 3117 :           { int *numptr = (int *)(stacktop - 1);

	mov	eax, DWORD PTR [ebx+48]

; 3118 :             if ( *numptr >= web.skel[FACET].ctrlpts ) /* see if done */

	mov	esi, DWORD PTR [eax-8]
	cmp	esi, DWORD PTR _web+232

; 3119 :             { node += node->op1.skipsize - 1;
; 3120 :               break;

	jge	$LN1707@eval

; 3121 :             }
; 3122 :             f_id = *(facet_id *)(stacktop);

	mov	eax, DWORD PTR [eax]

; 3123 :             fe = get_facet_fe(f_id);

	push	eax
	call	_get_facet_fe
	add	esp, 4

; 3124 :             if ( *numptr < 3 )

	cmp	esi, 3
	jge	SHORT $LN3964@eval

; 3125 :             { for ( i = 0 ; i < *numptr ; i++ )

	test	esi, esi
	jle	SHORT $LN1103@eval
	mov	edi, esi
	npad	7
$LL1105@eval:

; 3126 :                 fe = get_next_edge(fe);

	push	eax
	call	_get_next_edge
	add	esp, 4
	dec	edi
	jne	SHORT $LL1105@eval
$LN1103@eval:

; 3127 :               q_id = get_fe_tailv(fe);

	push	eax
	call	_get_fe_edge
	push	eax
	call	_get_edge_tailv
	add	esp, 8
	mov	DWORD PTR _q_id$[ebp], eax

; 3133 :             }
; 3134 :             (*numptr)++;

	mov	eax, DWORD PTR [ebx+48]
	inc	esi
	mov	DWORD PTR [eax-8], esi

; 3135 :           }
; 3136 :           else

	jmp	$LN1092@eval
$LN3964@eval:

; 3128 :             }
; 3129 :             else 
; 3130 :             { for ( i = 3 ; i < *numptr ; i++ )

	jle	SHORT $LN1099@eval
	lea	edi, DWORD PTR [esi-3]
$LL1101@eval:

; 3131 :                 fe = get_next_edge(fe);

	push	eax
	call	_get_next_edge
	add	esp, 4
	dec	edi
	jne	SHORT $LL1101@eval
$LN1099@eval:

; 3132 :               q_id = get_fe_midv(fe);

	push	eax
	call	_get_fe_edge
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	ecx, DWORD PTR [edx+eax+8]

; 3133 :             }
; 3134 :             (*numptr)++;

	mov	eax, DWORD PTR [ebx+48]
	add	esp, 4
	inc	esi
	mov	DWORD PTR _q_id$[ebp], ecx
	mov	DWORD PTR [eax-8], esi

; 3135 :           }
; 3136 :           else

	jmp	$LN1092@eval
$LN1108@eval:

; 3137 :           { fe_ptr = (element_id *)(stacktop - 0);

	mov	edi, DWORD PTR [ebx+48]

; 3138 :             if ( !valid_id(*fe_ptr) ) /* see if done */

	mov	esi, DWORD PTR [edi]
	test	esi, 268435456				; 10000000H

; 3139 :             { node += node->op1.skipsize - 1;
; 3140 :               break;

	je	$LN1760@eval

; 3141 :             }
; 3142 :             if ( id_type(*fe_ptr) == VERTEX )

	test	esi, -536870912				; e0000000H
	jne	SHORT $LN1096@eval

; 3143 :             { /* last vertex in string unclosed facet */
; 3144 :               q_id = *fe_ptr; *fe_ptr = NULLID;

	mov	DWORD PTR _q_id$[ebp], esi
	mov	DWORD PTR [edi], 0

; 3145 :             }
; 3146 :             else

	jmp	$LN1092@eval
$LN1096@eval:

; 3147 :             { edge_id e_id = get_fe_edge(*fe_ptr);

	push	esi
	call	_get_fe_edge

; 3148 :               q_id = get_edge_tailv(e_id);

	push	eax
	mov	DWORD PTR _e_id$91174[ebp], eax
	call	_get_edge_tailv

; 3149 :               *fe_ptr = get_next_edge(*fe_ptr);

	push	esi
	mov	DWORD PTR _q_id$[ebp], eax
	call	_get_next_edge
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi], eax

; 3150 :               if ( !valid_id(*fe_ptr) ) 

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN1094@eval

; 3151 :                 *fe_ptr = get_edge_headv(e_id); /* end of string facet */

	mov	ecx, DWORD PTR _e_id$91174[ebp]
	push	ecx
	call	_get_edge_headv
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 3152 :               else if ( !valid_element(*fe_ptr) 

	jmp	SHORT $LN1092@eval
$LN1094@eval:

; 3153 :                     || equal_id(*fe_ptr,*(element_id *)(stacktop-1)))

	push	eax
	call	_valid_element
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1091@eval
	mov	edx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [edx-8]
	jne	SHORT $LN1092@eval
$LN1091@eval:

; 3154 :                 *fe_ptr = NULLID; /* last one */

	mov	DWORD PTR [edi], 0
	jmp	SHORT $LN1092@eval
$LN1111@eval:

; 3106 :           { int *numptr = (int *)(stacktop - 1);

	mov	eax, DWORD PTR [ebx+48]

; 3107 :             if ( *numptr > web.skel[FACET].ctrlpts )

	mov	ecx, DWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+232

; 3108 :             { node += node->op1.skipsize - 1;
; 3109 :               break;

	jg	$LN1707@eval

; 3110 :             }
; 3111 :             f_ptr = (facet_id *)(stacktop);
; 3112 :             q_id = get_facet_vertices(*f_ptr)[*numptr];

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR _web+236
	mov	edi, DWORD PTR _dymem
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR _web+328
	add	edx, DWORD PTR [esi+edi+304]

; 3113 :             (*numptr)++;

	inc	ecx
	mov	edx, DWORD PTR [edx+ecx*4-4]
	mov	DWORD PTR _q_id$[ebp], edx
	mov	DWORD PTR [eax-8], ecx
$LN1092@eval:

; 3155 :             }
; 3156 :          }
; 3157 :          *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR _q_id$[ebp]
	mov	DWORD PTR [edx+ecx*8], eax

; 3158 :          if ( !valid_element(q_id) ) node--;    /* skip body of loop */
; 3159 : #ifdef MPI_EVOLVER
; 3160 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3161 :             node--;  /* don't count foreign elements in global aggregate */
; 3162 : #endif 
; 3163 :          break;

	jmp	$LN4009@eval
$LN1088@eval:

; 3164 :         }
; 3165 : 
; 3166 :       case NEXT_BODY_VERTEX_NODE: /* body vertices */   
; 3167 :         break;
; 3168 : 
; 3169 :       case NEXT_EDGE_NODE: /* all edges */
; 3170 :        { 
; 3171 :          edge_id *ep; 
; 3172 :          ep = (element_id *)(stacktop - 0);

	mov	ecx, DWORD PTR [ebx+48]

; 3173 :          if ( !valid_id(*ep) || breakflag )

	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	je	$LN1707@eval
	cmp	DWORD PTR _breakflag, 0
	jne	$LN1707@eval

; 3174 :          {  /* done */
; 3175 :             node += node->op1.skipsize - 1;
; 3176 :             break;
; 3177 :          }
; 3178 :          q_id = *ep;

	mov	edx, eax

; 3179 :          *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	and	eax, 16777215				; 00ffffffH
	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	esi, 5
	mov	eax, DWORD PTR [esi+eax+216]
	add	eax, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+eax*8], edx

; 3180 :          /* check sentinel; set for next time around */
; 3181 :          if ( equal_id(*ep,*(edge_id*)(stacktop-1)) ) *ep = NULLID;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _q_id$[ebp], edx
	mov	edx, DWORD PTR [ebx+48]
	cmp	eax, DWORD PTR [edx-8]
	jne	SHORT $LN1085@eval
	mov	DWORD PTR [ecx], 0
	jmp	$LN1118@eval
$LN1085@eval:

; 3182 :          else  *ep = eptr(*ep)->forechain; 

	mov	edx, DWORD PTR _web+124

; 3183 : 
; 3184 :          if ( !valid_element(q_id) ) node--;    /* skip body of loop */
; 3185 : #ifdef MPI_EVOLVER
; 3186 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3187 :             node--;  /* don't count foreign elements in global aggregate */
; 3188 : #endif 
; 3189 :        }
; 3190 :        break;

	jmp	$LN4026@eval
$LN1082@eval:

; 3191 : 
; 3192 :       case NEXT_VERTEX_EDGE_NODE: /* vertex edges */
; 3193 :        { edge_id *e_ptr;
; 3194 : 
; 3195 :          e_ptr = (element_id *)(stacktop - 0);

	mov	esi, DWORD PTR [ebx+48]

; 3196 :          if ( !valid_id(*e_ptr) ) /* see if done */

	mov	eax, DWORD PTR [esi]
	test	eax, 268435456				; 10000000H

; 3197 :          { node += node->op1.skipsize - 1;
; 3198 :            break;

	je	$LN1707@eval

; 3199 :          }
; 3200 :          q_id = *e_ptr;

	mov	ecx, eax

; 3201 :          *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+eax+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR [eax+edx*8], ecx
	mov	DWORD PTR _q_id$[ebp], ecx

; 3202 :          if ( get_attr(*(element_id *)(stacktop-2)) & (Q_MIDPOINT|Q_MIDEDGE) )

	mov	ecx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [ecx-16]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 4325376				; 00420000H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN1080@eval

; 3203 :             *e_ptr = NULLID; /* last one */

	mov	DWORD PTR [esi], ecx

; 3204 :          else

	jmp	$LN1118@eval
$LN1080@eval:

; 3205 :          { *e_ptr = get_next_tail_edge(*e_ptr);

	mov	edx, DWORD PTR [esi]
	push	edx
	call	_get_next_tail_edge

; 3206 :            if ( !valid_element(*e_ptr)
; 3207 :                   || equal_id(*e_ptr,get_vertex_edge(get_edge_tailv(*e_ptr))))

	push	eax
	mov	DWORD PTR [esi], eax
	call	_valid_element
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1077@eval
	mov	edi, DWORD PTR [esi]
	push	edi
	call	_get_edge_tailv
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	add	esp, 4
	cmp	edi, DWORD PTR [edx+28]
	jne	$LN1118@eval
$LN1077@eval:

; 3208 :            *e_ptr = NULLID; /* last one */

	mov	DWORD PTR [esi], 0

; 3209 :          }
; 3210 : 
; 3211 :          if ( !valid_element(q_id) ) node--;    /* skip body of loop */
; 3212 : #ifdef MPI_EVOLVER
; 3213 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3214 :             node--;  /* don't count foreign elements in global aggregate */
; 3215 : #endif 
; 3216 :          break;

	jmp	$LN1118@eval
$LN1075@eval:

; 3217 :        }
; 3218 : 
; 3219 :       case NEXT_FACET_EDGE_NODE: /* facet edges */
; 3220 :        { 
; 3221 :          facetedge_id *fe_ptr;
; 3222 :          fe_ptr = (element_id *)(stacktop - 0);

	mov	esi, DWORD PTR [ebx+48]

; 3223 :          if ( !valid_id(*fe_ptr) ) /* see if done */

	mov	eax, DWORD PTR [esi]
	test	eax, 268435456				; 10000000H

; 3224 :          { node += node->op1.skipsize - 1;
; 3225 :            break;

	je	$LN1707@eval

; 3226 :          }
; 3227 :          q_id = get_fe_edge(*fe_ptr);

	push	eax
	call	_get_fe_edge

; 3228 :          *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	edx, DWORD PTR _localbase$[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	DWORD PTR _q_id$[ebp], edi
	mov	DWORD PTR [edx+ecx*8], edi

; 3229 :          *fe_ptr = get_next_edge(*fe_ptr);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	_get_next_edge

; 3230 :          if ( web.representation == STRING )

	mov	ecx, 1
	add	esp, 8
	mov	DWORD PTR [esi], eax
	cmp	DWORD PTR _web+624, ecx
	jne	SHORT $LN1073@eval

; 3231 :          {
; 3232 :            if ( !valid_element(*fe_ptr) 
; 3233 :                || equal_id(*fe_ptr,*(element_id *)(stacktop-1)))

	push	eax
	call	_valid_element
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1071@eval
	mov	ecx, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [ecx-8]

; 3234 :             *fe_ptr = NULLID; /* last one */
; 3235 :          }
; 3236 :          else

	jmp	SHORT $LN3965@eval
$LN1073@eval:

; 3237 :          { if ( ++(*(int*)(stacktop-1)) == FACET_VERTS )

	mov	eax, DWORD PTR [ebx+48]
	add	DWORD PTR [eax-8], ecx
	cmp	DWORD PTR [eax-8], 3
$LN3965@eval:
	jne	SHORT $LN1069@eval
$LN1071@eval:

; 3238 :            *fe_ptr = NULLID; /* last one */

	mov	DWORD PTR [esi], 0
$LN1069@eval:

; 3239 :          }
; 3240 :          if ( !valid_element(q_id) ) node--;    /* skip body of loop */

	push	edi

; 3241 : #ifdef MPI_EVOLVER
; 3242 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3243 :             node--;  /* don't count foreign elements in global aggregate */
; 3244 : #endif 
; 3245 :          break;

	jmp	$LN4008@eval
$LN1066@eval:

; 3246 :        }
; 3247 : 
; 3248 :       case NEXT_BODY_EDGE_NODE: /* body edges */
; 3249 :         break;
; 3250 : 
; 3251 :       case NEXT_FACET_NODE:  /* all facets */
; 3252 :        { 
; 3253 :          facet_id *fp; 
; 3254 :          fp = (element_id *)(stacktop - 0);

	mov	ecx, DWORD PTR [ebx+48]

; 3255 :          if ( !valid_id(*fp)|| breakflag  )

	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	je	$LN1707@eval
	cmp	DWORD PTR _breakflag, 0
	jne	$LN1707@eval

; 3256 :          { node += node->op1.skipsize - 1; /* skip to end */
; 3257 :            break;
; 3258 :          }
; 3259 :          q_id = *fp;

	mov	edx, eax

; 3260 :          *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	and	eax, 16777215				; 00ffffffH
	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	esi, 5
	mov	eax, DWORD PTR [esi+eax+216]
	add	eax, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+eax*8], edx

; 3261 :          /* check sentinel; set for next time around */
; 3262 :          if ( equal_id(*fp,*(facet_id*)(stacktop-1)) ) *fp = NULLID;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _q_id$[ebp], edx
	mov	edx, DWORD PTR [ebx+48]
	cmp	eax, DWORD PTR [edx-8]
	jne	SHORT $LN1063@eval
	mov	DWORD PTR [ecx], 0
	jmp	$LN1118@eval
$LN1063@eval:

; 3263 :          else *fp = fptr(*fp)->forechain;

	mov	edx, DWORD PTR _web+236

; 3264 :          if ( !valid_element(q_id) ) node--;    /* skip body of loop */
; 3265 : #ifdef MPI_EVOLVER
; 3266 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3267 :             node--;  /* don't count foreign elements in global aggregate */
; 3268 : #endif 
; 3269 :        }
; 3270 :        break;

	jmp	$LN4026@eval
$LN1060@eval:

; 3271 : 
; 3272 :       case NEXT_EDGE_FACET_NODE:  /* all facets on edge */
; 3273 :        { 
; 3274 :          facetedge_id *fe_ptr;
; 3275 :          fe_ptr = (element_id *)(stacktop - 0);

	mov	esi, DWORD PTR [ebx+48]

; 3276 :          if ( !valid_id(*fe_ptr) ) /* see if done */

	mov	eax, DWORD PTR [esi]
	test	eax, 268435456				; 10000000H

; 3277 :          { node += node->op1.skipsize - 1;
; 3278 :            break;

	je	$LN1707@eval

; 3279 :          }
; 3280 :          q_id = get_fe_facet(*fe_ptr);

	push	eax
	call	_get_fe_facet
	mov	ecx, eax

; 3281 :          *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+eax+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR _q_id$[ebp], ecx
	mov	DWORD PTR [eax+edx*8], ecx

; 3282 :          *fe_ptr = get_next_facet(*fe_ptr);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	_get_next_facet

; 3283 :          if ( !valid_element(*fe_ptr) || 
; 3284 :                   equal_element(*fe_ptr,get_edge_fe(get_fe_edge(*fe_ptr))))

	push	eax
	mov	DWORD PTR [esi], eax
	call	_valid_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1057@eval
	mov	edi, DWORD PTR [esi]
	push	edi
	call	_get_fe_edge
	push	eax
	call	_get_edge_fe
	or	eax, 134217728				; 08000000H
	or	edi, 134217728				; 08000000H
	add	esp, 8
	cmp	edi, eax
	jne	SHORT $LN1058@eval
$LN1057@eval:

; 3285 :                   *fe_ptr = NULLID; /* last one */

	mov	DWORD PTR [esi], 0
$LN1058@eval:

; 3286 : 
; 3287 :          if ( !valid_element(q_id) ) node--;    /* skip body of loop */

	mov	edx, DWORD PTR _q_id$[ebp]
	push	edx

; 3288 : #ifdef MPI_EVOLVER
; 3289 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3290 :             node--;  /* don't count foreign elements in global aggregate */
; 3291 : #endif 
; 3292 :          break;

	jmp	$LN4008@eval
$LN1055@eval:

; 3293 :        }
; 3294 : 
; 3295 :       case NEXT_EDGE_FACETEDGE_NODE:  /* all facetedges on edge */
; 3296 :        { 
; 3297 :          facetedge_id *fe_ptr;
; 3298 :          fe_ptr = (element_id *)(stacktop - 0);

	mov	esi, DWORD PTR [ebx+48]

; 3299 :          if ( !valid_id(*fe_ptr) ) /* see if done */

	mov	eax, DWORD PTR [esi]
	test	eax, 268435456				; 10000000H

; 3300 :          { node += node->op1.skipsize - 1;
; 3301 :            break;

	je	$LN1707@eval

; 3302 :          }
; 3303 :          q_id = *fe_ptr;

	mov	ecx, eax

; 3304 :          *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+eax+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR _q_id$[ebp], ecx
	mov	DWORD PTR [eax+edx*8], ecx

; 3305 :          *fe_ptr = get_next_facet(*fe_ptr);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	_get_next_facet

; 3306 :          if ( !valid_element(*fe_ptr) || 
; 3307 :                   equal_element(*fe_ptr,get_edge_fe(get_fe_edge(*fe_ptr))))

	push	eax
	mov	DWORD PTR [esi], eax
	call	_valid_element
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1052@eval
	mov	edi, DWORD PTR [esi]
	push	edi
	call	_get_fe_edge
	push	eax
	call	_get_edge_fe
	or	eax, 134217728				; 08000000H
	or	edi, 134217728				; 08000000H
	add	esp, 8
	cmp	edi, eax
	jne	SHORT $LN1053@eval
$LN1052@eval:

; 3308 :                   *fe_ptr = NULLID; /* last one */

	mov	DWORD PTR [esi], 0
$LN1053@eval:

; 3309 : 
; 3310 :          if ( !valid_element(q_id) ) node--;    /* skip body of loop */

	mov	edx, DWORD PTR _q_id$[ebp]
	push	edx

; 3311 : #ifdef MPI_EVOLVER
; 3312 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3313 :             node--;  /* don't count foreign elements in global aggregate */
; 3314 : #endif 
; 3315 :          break;

	jmp	$LN4008@eval
$LN1050@eval:

; 3316 :        }
; 3317 : 
; 3318 :       case NEXT_VERTEX_FACET_NODE: /* facets adjacent to vertex */
; 3319 : 
; 3320 :        { 
; 3321 :          facet_id *f_ptr,first_f;
; 3322 :          f_ptr = (element_id *)(stacktop - 0);

	mov	esi, DWORD PTR [ebx+48]

; 3323 :          if ( !valid_id(*f_ptr) ) /* see if done */

	mov	eax, DWORD PTR [esi]
	test	eax, 268435456				; 10000000H

; 3324 :          { 
; 3325 :            node += node->op1.skipsize - 1;
; 3326 :            break;

	je	$LN1707@eval

; 3327 :          }
; 3328 :          q_id = *f_ptr;

	mov	DWORD PTR _q_id$[ebp], eax

; 3329 :          if ( id_type(q_id) == FACETEDGE )

	and	eax, -536870912				; e0000000H
	cmp	eax, -2147483648			; 80000000H
	jne	SHORT $LN3029@eval

; 3330 :            q_id = get_fe_facet(q_id);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	eax
	call	_get_fe_facet
	add	esp, 4
	mov	ecx, eax
	jmp	SHORT $LN1048@eval
$LN3029@eval:
	mov	ecx, DWORD PTR _q_id$[ebp]
$LN1048@eval:

; 3331 :          q_id = positive_id(q_id);
; 3332 :          *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+136]
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+eax+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	and	ecx, -134217729				; f7ffffffH
	mov	DWORD PTR [eax+edx*8], ecx

; 3333 :          v_id = *(vertex_id*)(stacktop-2);
; 3334 :          *f_ptr=get_next_vertex_facet(v_id,*f_ptr);

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR _q_id$[ebp], ecx
	mov	ecx, DWORD PTR [ebx+48]
	mov	edi, DWORD PTR [ecx-16]
	push	edx
	push	edi
	mov	DWORD PTR _v_id$[ebp], edi
	call	_get_next_vertex_facet

; 3335 :          first_f = get_vertex_first_facet(v_id); /* might have changed */

	push	edi
	mov	DWORD PTR [esi], eax
	call	_get_vertex_first_facet
	add	esp, 12					; 0000000cH

; 3336 :          if ( equal_id(*f_ptr,first_f) )

	cmp	DWORD PTR [esi], eax
	jne	$LN1118@eval

; 3337 :            *f_ptr = NULLID;

	mov	DWORD PTR [esi], 0

; 3338 :          if ( !valid_element(q_id) ) node--;    /* skip body of loop */
; 3339 : #ifdef MPI_EVOLVER
; 3340 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3341 :             node--;  /* don't count foreign elements in global aggregate */
; 3342 : #endif 
; 3343 :         }
; 3344 :         break;

	jmp	$LN1118@eval
$LN1045@eval:

; 3345 : 
; 3346 :       case NEXT_BODY_FACET_NODE: /* facets on body */
; 3347 :        { 
; 3348 :          facet_id *f_ptr;
; 3349 :          f_ptr = (element_id *)(stacktop - 0);

	mov	esi, DWORD PTR [ebx+48]

; 3350 :          if ( !valid_id(*f_ptr) ) /* see if done */

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _f_ptr$91272[ebp], esi
	test	eax, 268435456				; 10000000H

; 3351 :          { node += node->op1.skipsize - 1;
; 3352 :            break;

	je	$LN1707@eval

; 3353 :          }
; 3354 :          q_id = *f_ptr;

	mov	ecx, eax

; 3355 :          *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+eax+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR _q_id$[ebp], ecx
	mov	DWORD PTR [eax+edx*8], ecx

; 3356 :          *f_ptr = get_next_body_facet(*f_ptr);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	_get_next_body_facet

; 3357 :          if ( (get_fattr(*f_ptr)& (inverted(*f_ptr)?DID_BODYBACKFACET:DID_BODYFRONTFACET))
; 3358 :                || equal_id(*f_ptr,q_id) || 
; 3359 :                        equal_id(*f_ptr,*(element_id *)(stacktop-1)))

	mov	edx, eax
	shr	edx, 27					; 0000001bH
	add	esp, 4
	and	edx, 1
	mov	DWORD PTR [esi], eax
	mov	edi, 1048576				; 00100000H
	jne	SHORT $LN2241@eval
	mov	edi, 524288				; 00080000H
$LN2241@eval:
	mov	esi, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+12]
	and	ecx, edi
	xor	edi, edi
	and	esi, edi
	or	ecx, esi
	jne	SHORT $LN1042@eval
	cmp	eax, DWORD PTR _q_id$[ebp]
	je	SHORT $LN1042@eval
	mov	ecx, DWORD PTR [ebx+48]
	cmp	eax, DWORD PTR [ecx-8]
	je	SHORT $LN1042@eval

; 3361 :          else set_attr(*f_ptr,
; 3362 :                 (inverted(*f_ptr) ? DID_BODYBACKFACET : DID_BODYFRONTFACET) );

	mov	ecx, 1048576				; 00100000H
	test	edx, edx
	jne	SHORT $LN3966@eval
	mov	ecx, 524288				; 00080000H
$LN3966@eval:
	xor	edx, edx
	push	edx
	push	ecx
	push	eax
	call	_set_attr
	add	esp, 12					; 0000000cH
	jmp	$LN1118@eval
$LN1042@eval:

; 3360 :             *f_ptr = NULLID; /* last one */

	mov	edx, DWORD PTR _f_ptr$91272[ebp]
	mov	DWORD PTR [edx], edi

; 3363 :          if ( !valid_element(q_id) ) node--;    /* skip body of loop */
; 3364 :  #ifdef MPI_EVOLVER
; 3365 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3366 :             node--;  /* don't count foreign elements in global aggregate */
; 3367 : #endif 
; 3368 :       }
; 3369 : 
; 3370 :        break;

	jmp	$LN1118@eval
$LN1039@eval:

; 3371 : 
; 3372 :       case NEXT_BODY_NODE: /* all bodies */
; 3373 :        { 
; 3374 :          body_id *bp; 
; 3375 :          bp = (element_id *)(stacktop - 0);

	mov	ecx, DWORD PTR [ebx+48]

; 3376 :          if ( !valid_id(*bp)|| breakflag  )

	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	je	$LN1707@eval
	cmp	DWORD PTR _breakflag, 0
	jne	$LN1707@eval

; 3377 :          { node += node->op1.skipsize - 1;
; 3378 :            break;
; 3379 :          }  
; 3380 :          q_id = *bp;

	mov	edx, eax

; 3381 :          *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	and	eax, 16777215				; 00ffffffH
	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	esi, 5
	mov	eax, DWORD PTR [esi+eax+216]
	add	eax, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+eax*8], edx

; 3382 :          /* check sentinel; set for next time around */
; 3383 :          if ( equal_id(*bp,*(body_id*)(stacktop-1)) ) *bp = NULLID;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _q_id$[ebp], edx
	mov	edx, DWORD PTR [ebx+48]
	cmp	eax, DWORD PTR [edx-8]
	jne	SHORT $LN1036@eval
	mov	DWORD PTR [ecx], 0
	jmp	$LN1118@eval
$LN1036@eval:

; 3384 :          else *bp = bptr(*bp)->forechain;

	mov	edx, DWORD PTR _web+348

; 3385 : 
; 3386 :          if ( !valid_element(q_id) ) node--;    /* skip body of loop */
; 3387 : #ifdef MPI_EVOLVER
; 3388 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3389 :             node--;  /* don't count foreign elements in global aggregate */
; 3390 : #endif 
; 3391 :        }
; 3392 :          break;

	jmp	$LN4026@eval
$LN1033@eval:

; 3393 : 
; 3394 :          case NEXT_FACET_BODY_NODE: /* both bodies on facet */
; 3395 :          { 
; 3396 :             int *numptr = (int *)(stacktop - 1);

	mov	ecx, DWORD PTR [ebx+48]

; 3397 :             f_id = *(facet_id *)(stacktop - 2); /* facet */

	mov	eax, DWORD PTR [ecx-16]

; 3398 :             (*numptr)++;

	inc	DWORD PTR [ecx-8]
	mov	ecx, DWORD PTR [ecx-8]

; 3399 :             if ( *numptr == 3 ) /* see if done */

	cmp	ecx, 3

; 3400 :             { /* done */
; 3401 :               node += node->op1.skipsize - 1;
; 3402 :               break;

	je	$LN1707@eval

; 3403 :             }
; 3404 :             if ( *numptr == 1 ) /* first */

	cmp	ecx, 1
	jne	SHORT $LN1031@eval

; 3405 :             { 
; 3406 :               q_id = get_facet_body(f_id);

	push	eax
	call	_get_facet_body

; 3407 :               *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [ecx+136]

; 3408 :               if ( !valid_id(q_id) )
; 3409 :                 node--;  /* try again */
; 3410 :              }
; 3411 :              else /* *numptr == 2 */

	jmp	SHORT $LN4027@eval
$LN1031@eval:

; 3412 :              { q_id = get_facet_body(inverse_id(f_id));

	xor	eax, 134217728				; 08000000H
	push	eax
	call	_get_facet_body

; 3413 :                *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	edx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [edx+136]
$LN4027@eval:
	and	ecx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	ecx, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [ecx]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	add	esp, 4
	mov	DWORD PTR _q_id$[ebp], eax
	mov	DWORD PTR [ecx+edx*8], eax

; 3414 :                if ( !valid_id(q_id) )

	test	eax, 268435456				; 10000000H

; 3415 :                node--;  /* try again */
; 3416 :              }
; 3417 : 
; 3418 :              break;

	jmp	$LN4011@eval
$LN1025@eval:

; 3419 :          }
; 3420 : 
; 3421 :       case NEXT_VERTEX_BODY_NODE: /* bodies adjacent to vertex */
; 3422 :         break;
; 3423 :       case NEXT_EDGE_BODY_NODE: /* bodies adjacent to edge */
; 3424 :         break;
; 3425 : 
; 3426 :       case NEXT_FACETEDGE_NODE: /* all facetedges */
; 3427 :        { 
; 3428 :          facetedge_id *fep;
; 3429 :          fep = (element_id *)(stacktop - 0);

	mov	ecx, DWORD PTR [ebx+48]

; 3430 :          if ( !valid_id(*fep)|| breakflag  )

	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	je	$LN1707@eval
	cmp	DWORD PTR _breakflag, 0
	jne	$LN1707@eval

; 3431 :          { /* done */ 
; 3432 :            node += node->op1.skipsize - 1;
; 3433 :            break;
; 3434 :          }
; 3435 :          q_id = *fep;

	mov	edx, eax

; 3436 :          *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	and	eax, 16777215				; 00ffffffH
	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	esi, 5
	mov	eax, DWORD PTR [esi+eax+216]
	add	eax, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+eax*8], edx

; 3437 :          /* check sentinel; set for next time around */
; 3438 :          if ( equal_id(*fep,*(facetedge_id*)(stacktop-1)) ) *fep = NULLID;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _q_id$[ebp], edx
	mov	edx, DWORD PTR [ebx+48]
	cmp	eax, DWORD PTR [edx-8]
	jne	SHORT $LN1022@eval
	mov	DWORD PTR [ecx], 0
	jmp	$LN1118@eval
$LN1022@eval:

; 3439 :          else *fep = feptr(*fep)->forechain;

	mov	edx, DWORD PTR _web+460

; 3440 : 
; 3441 :           if ( !valid_element(q_id) ) node--;    /* skip body of loop */
; 3442 : #ifdef MPI_EVOLVER
; 3443 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3444 :             node--;  /* don't count foreign elements in global aggregate */
; 3445 : #endif 
; 3446 :         }
; 3447 :         break; 

	jmp	$LN4026@eval
$LN1019@eval:

; 3448 : 
; 3449 : 
; 3450 :       case NEXT_FACETEDGE_EDGE_NODE: /* edge on facetedge */
; 3451 :        { 
; 3452 :          edge_id *e_ptr;
; 3453 :          e_ptr = (element_id *)(stacktop - 0);

	mov	ecx, DWORD PTR [ebx+48]

; 3454 :          if ( !valid_id(*e_ptr) ) /* see if done */

	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H

; 3455 :          { node += node->op1.skipsize - 1;
; 3456 :            break;

	je	$LN1707@eval
$LN1018@eval:

; 3457 :          }
; 3458 :          q_id = *e_ptr;

	mov	edx, eax

; 3459 :          *(element_id*)get_localp(node->op2.localnum) = q_id;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	and	eax, 16777215				; 00ffffffH
	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	esi, 5
	mov	eax, DWORD PTR [esi+eax+216]
	add	eax, DWORD PTR _localstack$[ebp]
	mov	esi, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+eax*8], edx
	mov	DWORD PTR _q_id$[ebp], edx

; 3460 :          *e_ptr = NULLID; /* last one */

	mov	DWORD PTR [ecx], 0

; 3461 :          if ( !valid_element(q_id) ) node--;    /* skip body of loop */

	push	edx

; 3462 :  #ifdef MPI_EVOLVER
; 3463 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3464 :             node--;  /* don't count foreign elements in global aggregate */
; 3465 : #endif 
; 3466 :       }
; 3467 :        break;

	jmp	$LN4008@eval
$LN1016@eval:

; 3468 : 
; 3469 : 
; 3470 :       case NEXT_FACETEDGE_FACET_NODE: /* facet on facetedge */
; 3471 :        { 
; 3472 :          facet_id *f_ptr;
; 3473 :          f_ptr = (element_id *)(stacktop - 0);

	mov	ecx, DWORD PTR [ebx+48]

; 3474 :          if ( !valid_id(*f_ptr) ) /* see if done */

	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN1018@eval

; 3475 :          { node += node->op1.skipsize - 1;
; 3476 :            break;

	jmp	$LN1707@eval
$LN1013@eval:

; 3477 :          }
; 3478 :          q_id = *f_ptr;
; 3479 :          *(element_id*)get_localp(node->op2.localnum) = q_id;
; 3480 :          *f_ptr = NULLID; /* last one */
; 3481 :          if ( !valid_element(q_id) ) node--;    /* skip body of loop */
; 3482 : #ifdef MPI_EVOLVER
; 3483 :          if ( mpi_subtask_command_flag && (id_task(q_id) != this_task) )
; 3484 :             node--;  /* don't count foreign elements in global aggregate */
; 3485 : #endif 
; 3486 :        }
; 3487 :        break;
; 3488 : 
; 3489 :         /***********************/
; 3490 :         /* aggregate condition */
; 3491 :         /***********************/
; 3492 : 
; 3493 :       case WHERE_NODE: /* see if element qualifies */
; 3494 :           if ( *(stacktop--) == 0.0 )

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	add	ecx, -8					; fffffff8H
	fldz
	mov	DWORD PTR [ebx+48], ecx
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H

; 3495 :           node += node->left-1;  /* no, go back to generator */

	mov	eax, DWORD PTR _node$[ebp]
	jp	SHORT $LN1012@eval
	mov	ecx, DWORD PTR [eax+4]
	jmp	$LN4002@eval
$LN1012@eval:

; 3496 :           else node->op1.wherecount++; /* where count   NONREENTRANT */

	inc	DWORD PTR [eax+32]

; 3497 :           break;  /* else continue with current element */

	jmp	$LN1980@eval
$LN1010@eval:

; 3498 : 
; 3499 :       case SINGLE_ASSIGN_NODE:
; 3500 :           /* restore old q_id */
; 3501 :           q_id = *(element_id *)(stacktop - 2);

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax-16]

; 3502 :           stacktop -= 3;  /* erase locals */

	add	eax, -24				; ffffffe8H
	mov	DWORD PTR _q_id$[ebp], ecx
	mov	DWORD PTR [ebx+48], eax

; 3503 :           break;

	jmp	$LN1980@eval
$LN1009@eval:

; 3504 : 
; 3505 : 
; 3506 :         /*****************/
; 3507 :         /* aggregate end */
; 3508 :         /*****************/
; 3509 : 
; 3510 :       case AGGREGATE_END_NODE:
; 3511 :           aggregate_depth--;
; 3512 :           /* restore old q_id */
; 3513 :           q_id = *(element_id *)(stacktop - 2);
; 3514 :           where = node+node->right;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	esi, 1
	sub	DWORD PTR _aggregate_depth, esi
	mov	edx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [edx-16]
	mov	DWORD PTR _q_id$[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	imul	eax, 168				; 000000a8H

; 3515 :           where = where+where->left;

	mov	edx, DWORD PTR [eax+ecx+4]
	add	eax, ecx
	imul	edx, 168				; 000000a8H

; 3516 :           if ( where->type == WHERE_NODE )

	cmp	DWORD PTR [eax+edx], 10262		; 00002816H
	jne	SHORT $LN1008@eval

; 3517 :           { web.where_count = where->op1.wherecount;

	mov	ecx, DWORD PTR [eax+edx+32]
	mov	DWORD PTR _web+5496, ecx

; 3518 :             where->op1.wherecount = 0; /* reset where count */

	mov	DWORD PTR [eax+edx+32], 0
	mov	ecx, DWORD PTR _node$[ebp]
$LN1008@eval:

; 3519 :           }
; 3520 :           switch ( node->op1.aggrtype )

	mov	edx, DWORD PTR [ecx+32]
	mov	eax, edx
	mov	DWORD PTR tv17732[ebp], edx
	cmp	eax, 10336				; 00002860H
	jg	SHORT $LN2244@eval
	cmp	eax, 10335				; 0000285fH
	jge	SHORT $LN953@eval
	sub	eax, 10077				; 0000275dH
	cmp	eax, 236				; 000000ecH
	ja	SHORT $LN1005@eval
	movzx	edx, BYTE PTR $LN2841@eval[eax]
	jmp	DWORD PTR $LN4036@eval[edx*4]
$LN954@eval:

; 3732 :             }
; 3733 : 
; 3734 :              case LIST_NODE:
; 3735 :              stacktop -= 3;  /* erase locals */
; 3736 :              break;
; 3737 : 
; 3738 :              case SET_COLOR_NODE: 
; 3739 :              case SET_FRONTCOLOR_NODE: 
; 3740 :              case SET_BACKCOLOR_NODE: 
; 3741 :              case SET_OPACITY_NODE:
; 3742 :              stacktop -= 3;  /* erase locals */

	add	DWORD PTR [ebx+48], -24			; ffffffe8H

; 3743 :              update_display_flag = 1;

	mov	DWORD PTR _update_display_flag$[ebp], esi

; 3744 :              break;

	jmp	$LN1980@eval
$LN953@eval:

; 3745 : 
; 3746 :              case SET_FIXED_NODE: case SET_NO_REFINE_NODE: case SET_NO_DISPLAY_NODE:
; 3747 :              case SET_NO_TRANSFORM_NODE: case UNSET_NO_TRANSFORM_NODE:
; 3748 :              case SET_DENSITY_NODE: case UNSET_DENSITY_NODE:  case SET_BARE_NODE:
; 3749 :              case SET_CONSTRAINT_NODE: case UNSET_CONSTRAINT_NODE:
; 3750 :              case SET_CONSTRAINT_NAME_NODE: case UNSET_CONSTRAINT_NAME_NODE:
; 3751 :              case SET_VOLUME_NODE: case SET_PRESSURE_NODE: case SET_NONCONTENT_NODE:
; 3752 :              case UNSET_BOUNDARY_NODE: case UNSET_BOUNDARY_NAME_NODE:
; 3753 :              case UNSET_FIXED_NODE: case UNSET_PRESSURE_NODE: 
; 3754 :              case SET_NAMED_QUANTITY_NODE: case UNSET_NO_REFINE_NODE: case UNSET_BARE_NODE:
; 3755 :              case UNSET_NAMED_QUANTITY_NODE: case UNSET_NO_DISPLAY_NODE:
; 3756 :              case SET_METHOD_INSTANCE_NODE: case UNSET_METHOD_INSTANCE_NODE:
; 3757 :              case UNSET_TRIPLE_PT_NODE: case UNSET_TETRA_PT_NODE:
; 3758 :              case UNSET_NONCONTENT_NODE: case SET_BOUNDARY_NODE:
; 3759 :              case SET_HIT_PARTNER_NODE: case UNSET_HIT_PARTNER_NODE:
; 3760 :              case UNSET_CENTEROFMASS_NODE: case SET_CENTEROFMASS_NODE:
; 3761 :              case SET_NO_HESSIAN_NORMAL_NODE: case UNSET_NO_HESSIAN_NORMAL_NODE:
; 3762 :              stacktop -= 3;  /* erase locals */

	add	DWORD PTR [ebx+48], -24			; ffffffe8H

; 3763 :              recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], esi

; 3764 :              break;

	jmp	$LN1980@eval
$LN2244@eval:

; 3519 :           }
; 3520 :           switch ( node->op1.aggrtype )

	sub	eax, 10339				; 00002863H
	cmp	eax, 8
	ja	SHORT $LN1005@eval
	jmp	DWORD PTR $LN4037@eval[eax*4]
$LN1005@eval:

; 3521 :           {
; 3522 :             case FOREACH_NODE:
; 3523 :             case SET_ATTRIBUTE_LOOP_NODE:
; 3524 :               stacktop -= 3;  /* erase locals */

	add	DWORD PTR [ebx+48], -24			; ffffffe8H

; 3525 :               break; 

	jmp	$LN1980@eval
$LN1000@eval:

; 3526 : 
; 3527 :             case MAX_NODE:  
; 3528 :               stacktop -= 3;  /* erase locals */
; 3529 : #ifdef MPI_EVOLVER
; 3530 :               if ( mpi_subtask_command_flag && (aggregate_depth==0))
; 3531 :               { REAL total;
; 3532 :                 MPI_Reduce(stacktop,&total,1,MPI_REAL,MPI_MAX,
; 3533 :                     MASTER_TASK,MPI_COMM_WORLD);
; 3534 :                 if ( this_task == MASTER_TASK )
; 3535 :                   stacktop[0] = total;
; 3536 :               }
; 3537 : #endif
; 3538 :               break;
; 3539 : 
; 3540 :             case MIN_NODE: 
; 3541 :               stacktop -= 3;  /* erase locals */
; 3542 : #ifdef MPI_EVOLVER
; 3543 :               if ( mpi_subtask_command_flag && (aggregate_depth==0))
; 3544 :               { REAL total;
; 3545 :                 MPI_Reduce(stacktop,&total,1,MPI_REAL,MPI_MIN,
; 3546 :                     MASTER_TASK,MPI_COMM_WORLD);
; 3547 :                 if ( this_task == MASTER_TASK )
; 3548 :                   stacktop[0] = total;
; 3549 :               }
; 3550 : #endif
; 3551 :               break;
; 3552 : 
; 3553 :             case SUM_NODE: 
; 3554 :               stacktop -= 3;  /* erase locals */
; 3555 : #ifdef MPI_EVOLVER
; 3556 :               if ( mpi_subtask_command_flag && (aggregate_depth==0))
; 3557 :               { REAL total;
; 3558 :                 MPI_Reduce(stacktop,&total,1,MPI_REAL,MPI_SUM,
; 3559 :                     MASTER_TASK,MPI_COMM_WORLD);
; 3560 :                 if ( this_task == MASTER_TASK )
; 3561 :                   stacktop[0] = total;
; 3562 :               }
; 3563 : #endif
; 3564 :               break;
; 3565 : 
; 3566 :             case COUNT_NODE:
; 3567 :               stacktop -= 3;  /* erase locals */
; 3568 : #ifdef MPI_EVOLVER
; 3569 :               if ( mpi_subtask_command_flag && (aggregate_depth==0))
; 3570 :               { REAL total;
; 3571 :                 MPI_Reduce(stacktop,&total,1,MPI_REAL,MPI_SUM,
; 3572 :                     MASTER_TASK,MPI_COMM_WORLD);
; 3573 :                 if ( this_task == MASTER_TASK )
; 3574 :                   stacktop[0] = total;            
; 3575 :               }
; 3576 : #endif
; 3577 :               break;
; 3578 : 
; 3579 :             case AVG_NODE:
; 3580 :               stacktop -= 4;  /* erase locals */

	add	DWORD PTR [ebx+48], -32			; ffffffe0H

; 3581 : #ifdef MPI_EVOLVER
; 3582 :               if ( mpi_subtask_command_flag && (aggregate_depth==0) )
; 3583 :               { REAL total[2];
; 3584 :                 MPI_Reduce(stacktop,total,2,MPI_REAL,MPI_SUM,
; 3585 :                     MASTER_TASK,MPI_COMM_WORLD);
; 3586 :                 if ( this_task == MASTER_TASK )
; 3587 :                 { stacktop[0] = total[0];
; 3588 :                   stacktop[1] = total[1];
; 3589 :                 }
; 3590 :               }
; 3591 : #endif
; 3592 :               if ( stacktop[0] > 0.0 )

	fldz
	mov	ecx, DWORD PTR [ebx+48]
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 5
	jp	$LN1980@eval

; 3593 :                  stacktop[0] = stacktop[1]/stacktop[0];

	fld	QWORD PTR [ecx+8]
	fdiv	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]

; 3594 :               /* else leave avg as 0 */
; 3595 :               break;

	jmp	$LN1980@eval
$LN998@eval:

; 3596 : 
; 3597 :              case LOGHISTOGRAM_NODE:
; 3598 :              case HISTOGRAM_NODE:
; 3599 :               { int i;
; 3600 :                 REAL binsize;
; 3601 :                 int one_bin_flag = 0;
; 3602 : 
; 3603 :                 bins = stacktop - (HISTBINS+1) + 1 - 3;
; 3604 : 
; 3605 :                 /* find hi and lo */
; 3606 :                 hi = -MAXDOUBLE; lo = MAXDOUBLE;

	fld	QWORD PTR __real@c7d2ced32a16a1b1

; 3607 :                 for ( i = 0 ; i < histo_count ; i++ )

	mov	esi, DWORD PTR _histo_count$[ebp]
	mov	edi, DWORD PTR [ebx+48]
	fst	QWORD PTR _hi$[ebp]
	fld	QWORD PTR __real@47d2ced32a16a1b1
	xor	ecx, ecx
	fst	QWORD PTR _lo$[ebp]
	mov	DWORD PTR _one_bin_flag$91364[ebp], 0
	fldz
	test	esi, esi
	jle	SHORT $LN3014@eval
	mov	edx, DWORD PTR _histo_data$[ebp]
	jmp	SHORT $LN997@eval
$LN3239@eval:
	fxch	ST(2)
	fxch	ST(1)
$LN997@eval:

; 3608 :                 { if ( histo_data[i] < lo ) 

	fxch	ST(1)
	fcom	QWORD PTR [edx+ecx*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN993@eval

; 3609 :                     if ( (node->op1.aggrtype == HISTOGRAM_NODE) || ( histo_data[i] > 0.0) )

	cmp	DWORD PTR tv17732[ebp], 10344		; 00002868H
	je	SHORT $LN3231@eval
	fxch	ST(1)
	fcom	QWORD PTR [edx+ecx*8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3233@eval
	fstp	ST(1)

; 3610 :                       lo = histo_data[i];

	fld	QWORD PTR [edx+ecx*8]
	jmp	SHORT $LN993@eval
$LN3231@eval:

; 3609 :                     if ( (node->op1.aggrtype == HISTOGRAM_NODE) || ( histo_data[i] > 0.0) )

	fstp	ST(0)

; 3610 :                       lo = histo_data[i];

	fld	QWORD PTR [edx+ecx*8]
	jmp	SHORT $LN993@eval
$LN3233@eval:

; 3609 :                     if ( (node->op1.aggrtype == HISTOGRAM_NODE) || ( histo_data[i] > 0.0) )

	fxch	ST(1)
$LN993@eval:

; 3611 :                   if ( histo_data[i] > hi ) hi = histo_data[i];

	fxch	ST(2)
	fcom	QWORD PTR [edx+ecx*8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN996@eval
	fstp	ST(0)
	fld	QWORD PTR [edx+ecx*8]
$LN996@eval:

; 3607 :                 for ( i = 0 ; i < histo_count ; i++ )

	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LN3239@eval
	mov	edx, DWORD PTR tv17732[ebp]

; 3611 :                   if ( histo_data[i] > hi ) hi = histo_data[i];

	fst	QWORD PTR _hi$[ebp]
	fxch	ST(2)
	fst	QWORD PTR _lo$[ebp]
	jmp	SHORT $LN995@eval
$LN3014@eval:

; 3607 :                 for ( i = 0 ; i < histo_count ; i++ )

	fxch	ST(1)
$LN995@eval:

; 3612 :                 }
; 3613 : #ifdef MPI_EVOLVER
; 3614 :                if ( mpi_subtask_command_flag && (aggregate_depth==0))
; 3615 :                 { /* synchronize max-min values */
; 3616 :                   DOUBLE localhi = hi,locallo = lo;
; 3617 :                   DOUBLE globalhi,globallo;
; 3618 :                   MPI_Allreduce(&localhi,&globalhi,1,MPI_REAL,MPI_MAX,
; 3619 :                       MPI_COMM_WORLD);
; 3620 :                   hi = globalhi;
; 3621 :                   MPI_Allreduce(&locallo,&globallo,1,MPI_REAL,MPI_MIN,
; 3622 :                       MPI_COMM_WORLD);
; 3623 :                   lo = globallo;
; 3624 :                 }
; 3625 : #endif
; 3626 :              if (node->op1.aggrtype == HISTOGRAM_NODE )

	cmp	edx, 10344				; 00002868H
	jne	SHORT $LN990@eval
	fstp	ST(1)

; 3627 :              { if ( hi == lo )

	fld	ST(1)
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN989@eval

; 3628 :                { binsize = 1.0; /* will put everything in first bin */

	fld1

; 3629 :                  one_bin_flag = 1;

	mov	DWORD PTR _one_bin_flag$91364[ebp], 1
	jmp	$LN981@eval
$LN989@eval:

; 3630 :                }
; 3631 :                else binsize = (hi-lo)/HISTBINS;/* binsize */

	fld	ST(1)
	fsub	ST(0), ST(1)
	fdiv	QWORD PTR __real@4035000000000000

; 3632 :              }
; 3633 :              else /* first bin for 0 values for log histogram */

	jmp	SHORT $LN981@eval
$LN990@eval:

; 3634 :               { if ( hi <= 0.0 ) binsize = 0.0;

	fxch	ST(2)
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H

; 3635 :                 else 

	jnp	SHORT $LN3292@eval

; 3634 :               { if ( hi <= 0.0 ) binsize = 0.0;

	fstp	ST(1)
	fstp	ST(1)

; 3636 :                 { hi = log(hi);

	call	__CIlog
	fst	QWORD PTR _hi$[ebp]

; 3637 :                   if ( lo <= 0.0 ) 

	fldz
	fld	QWORD PTR _lo$[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jp	SHORT $LN3294@eval
	fstp	ST(0)

; 3638 :                   { binsize = 1.0; lo = hi-(HISTBINS-1); }

	fld1
	fld	ST(1)
	fsub	QWORD PTR __real@4034000000000000
	fst	QWORD PTR _lo$[ebp]

; 3639 :                   else 

	jmp	SHORT $LN3296@eval
$LN3294@eval:

; 3637 :                   if ( lo <= 0.0 ) 

	fstp	ST(1)

; 3640 :                   { lo = log(lo); 

	call	__CIlog
	fst	QWORD PTR _lo$[ebp]

; 3641 :                     if ( hi == lo ) 

	fld	QWORD PTR _hi$[ebp]
	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN982@eval

; 3642 :                     { binsize = 1.0;

	fld1

; 3643 :                       one_bin_flag = 1;

	mov	DWORD PTR _one_bin_flag$91364[ebp], 1

; 3644 :                     }
; 3645 :                     else

	jmp	SHORT $LN3301@eval
$LN982@eval:

; 3646 :                       binsize = (hi-lo)/(HISTBINS-1);

	fld	ST(0)
	fsub	ST(0), ST(2)
	fdiv	QWORD PTR __real@4034000000000000
$LN3301@eval:
	fxch	ST(1)
$LN3292@eval:
	fxch	ST(2)
$LN3296@eval:
	fxch	ST(1)
$LN981@eval:

; 3647 :                   }
; 3648 :                 }
; 3649 :               }
; 3650 :              binsize *= 1+10*machine_eps; /* for rounding margin */

	fld	QWORD PTR _machine_eps
	fmul	QWORD PTR __real@4024000000000000
	fld	QWORD PTR __real@3ff0000000000000
	fadd	ST(0), ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _binsize$91363[ebp]

; 3651 :              if ( lo != 0.0 ) lo -= 10*machine_eps*binsize;

	fld	ST(2)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3250@eval
	fld	ST(0)
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	fsubrp	ST(1), ST(0)
	fst	QWORD PTR _lo$[ebp]
	fxch	ST(1)
$LN980@eval:

; 3652 :              /* construct histogram */
; 3653 :              for ( i = 0 ; i < histo_count ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _histo_count$[ebp], esi
	jle	$LN977@eval
$LN979@eval:

; 3654 :              { val = histo_data[i];

	mov	eax, DWORD PTR _histo_data$[ebp]
	fld	QWORD PTR [eax+esi*8]

; 3655 :                 if ( !is_finite(val) ) 

	fld	QWORD PTR __real@fe37e43c8800759c
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	$LN3261@eval
	fld	QWORD PTR __real@7e37e43c8800759c
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN3261@eval

; 3657 :                 else if ( node->op1.aggrtype == HISTOGRAM_NODE )

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+32], 10344		; 00002868H
	jne	SHORT $LN973@eval

; 3658 :                   k = (int)((val-lo)/binsize);

	fsub	ST(0), ST(2)
	fdiv	ST(0), ST(1)
	call	__ftol2_sse
	jmp	SHORT $LN970@eval
$LN3250@eval:

; 3651 :              if ( lo != 0.0 ) lo -= 10*machine_eps*binsize;

	fstp	ST(1)
	jmp	SHORT $LN980@eval
$LN973@eval:

; 3659 :                 else if ( val <= 0.0 ) k = 0;

	fldz
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN3269@eval
	fstp	ST(0)
	xor	eax, eax

; 3660 :                 else

	jmp	SHORT $LN970@eval
$LN3269@eval:

; 3659 :                 else if ( val <= 0.0 ) k = 0;

	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(1)

; 3661 :                  { val = log(val);

	call	__CIlog

; 3662 :                    k = (int)((val-lo)/binsize)+1;

	fld	QWORD PTR _lo$[ebp]
	fsub	ST(1), ST(0)
	fld	QWORD PTR _binsize$91363[ebp]
	fdiv	ST(2), ST(0)
	fxch	ST(2)
	call	__ftol2_sse
	fld	QWORD PTR _hi$[ebp]
	inc	eax
	fxch	ST(2)
$LN970@eval:

; 3663 :                  }
; 3664 :                 bins[k] += 1.0;

	fld	QWORD PTR [edi+eax*8-192]
	inc	esi
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [edi+eax*8-192]
	cmp	esi, DWORD PTR _histo_count$[ebp]
	jl	$LN979@eval
$LN977@eval:

; 3665 :              }
; 3666 : #ifdef MPI_EVOLVER
; 3667 :              if ( mpi_subtask_command_flag && (aggregate_depth==0))
; 3668 :              { /* accumulate histogram data on master */
; 3669 :                REAL recvbuf[HISTBINS+1];
; 3670 :                MPI_Reduce(bins,recvbuf,HISTBINS+1,MPI_REAL,MPI_SUM,
; 3671 :                  MASTER_TASK, MPI_COMM_WORLD);
; 3672 :                if ( this_task == MASTER_TASK )
; 3673 :                  for ( k = 0, histo_count = 0 ; k <= HISTBINS ; k++ )
; 3674 :                  { bins[k] = recvbuf[k];
; 3675 :                    histo_count += (int)bins[k];
; 3676 :                  }
; 3677 :              }
; 3678 : #endif
; 3679 :              /* print histogram */
; 3680 : #ifdef MPI_EVOLVER
; 3681 :              if ( (this_task == MASTER_TASK) || !mpi_subtask_command_flag )
; 3682 : #endif
; 3683 :              {
; 3684 :              if ( histo_count == 0 )

	mov	esi, DWORD PTR _histo_count$[ebp]
	test	esi, esi
	jne	SHORT $LN969@eval
	fstp	ST(1)

; 3685 :              { 
; 3686 :                outstring("No qualifying values.\n");

	push	OFFSET ??_C@_0BH@LIPFBHGH@No?5qualifying?5values?4?6?$AA@
	fstp	ST(0)
	fstp	ST(0)
	call	_outstring
	add	esp, 4

; 3687 :                stacktop -= HISTBINS+1 + 3 + 3;

	add	DWORD PTR [ebx+48], -224		; ffffff20H

; 3688 :                break;

	jmp	$LN1980@eval
$LN3261@eval:

; 3655 :                 if ( !is_finite(val) ) 

	fstp	ST(0)

; 3656 :                     k = HISTBINS;  /* NaN */ 

	mov	eax, 21					; 00000015H
	jmp	SHORT $LN970@eval
$LN969@eval:

; 3689 :              }
; 3690 :              if ( one_bin_flag )

	cmp	DWORD PTR _one_bin_flag$91364[ebp], 0
	je	SHORT $LN3276@eval

; 3691 :              { if (node->op1.aggrtype == HISTOGRAM_NODE )

	mov	edx, DWORD PTR _node$[ebp]
	fstp	ST(1)
	cmp	DWORD PTR [edx+32], 10344		; 00002868H
	fstp	ST(0)
	jne	SHORT $LN967@eval

; 3692 :                   sprintf(msg,"%10.5g - %10.5g     %d\n",
; 3693 :                   (DOUBLE)hi,(DOUBLE)hi,histo_count);

	mov	eax, DWORD PTR _msg
	push	esi
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BI@HAEINGLM@?$CF10?45g?5?9?5?$CF10?45g?5?5?5?5?5?$CFd?6?$AA@
	push	eax

; 3694 :                 else sprintf(msg,"%10.5g - %10.5g     %d\n",

	jmp	SHORT $LN3967@eval
$LN967@eval:

; 3695 :                   (DOUBLE)exp(hi),(DOUBLE)exp(hi),histo_count);

	call	__CIexp
	mov	ecx, DWORD PTR _msg
	push	esi
	sub	esp, 16					; 00000010H
	fst	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BI@HAEINGLM@?$CF10?45g?5?9?5?$CF10?45g?5?5?5?5?5?$CFd?6?$AA@
	push	ecx
$LN3967@eval:
	call	_sprintf

; 3696 :                outstring(msg);

	mov	edx, DWORD PTR _msg
	add	esp, 28					; 0000001cH
	push	edx
	call	_outstring
	add	esp, 4

; 3697 :                stacktop -= HISTBINS+1 + 3 + 3;

	add	DWORD PTR [ebx+48], -224		; ffffff20H

; 3698 :                break;

	jmp	$LN1980@eval
$LN3276@eval:

; 3699 :              }
; 3700 :              if (node->op1.aggrtype == HISTOGRAM_NODE )

	mov	eax, DWORD PTR _node$[ebp]
	fstp	ST(2)
	cmp	DWORD PTR [eax+32], 10344		; 00002868H
	jne	$LN965@eval

; 3701 :               for ( n = 0 ; n < HISTBINS ; n++ )

	xor	eax, eax
	mov	DWORD PTR _n$[ebp], eax
	jmp	SHORT $LN964@eval
	npad	6
$LL2987@eval:
	fld	QWORD PTR _binsize$91363[ebp]
	fld	QWORD PTR _lo$[ebp]
$LN964@eval:

; 3702 :                 { sprintf(msg,"%10.5g - %10.5g     %d\n",
; 3703 :                   (DOUBLE)(lo + n*binsize),(DOUBLE)(lo + (n+1)*binsize),
; 3704 :                      (int)bins[n]);

	fld	QWORD PTR [edi+eax*8-192]
	lea	esi, DWORD PTR [eax+1]
	mov	DWORD PTR tv18554[ebp], esi
	call	__ftol2_sse
	fild	DWORD PTR tv18554[ebp]
	mov	ecx, DWORD PTR _msg
	push	eax
	fmul	ST(0), ST(2)
	sub	esp, 16					; 00000010H
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [esp+8]
	fild	DWORD PTR _n$[ebp]
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BI@HAEINGLM@?$CF10?45g?5?9?5?$CF10?45g?5?5?5?5?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf

; 3705 :                   outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	mov	eax, esi
	add	esp, 32					; 00000020H
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, 21					; 00000015H
	jl	SHORT $LL2987@eval

; 3706 :                 }
; 3707 :               else /* log histogram */

	jmp	$LN957@eval
$LN965@eval:

; 3708 :                 { int zeroes = (int)bins[0];

	fld	QWORD PTR [edi-192]
	call	__ftol2_sse

; 3709 :                   if ( zeroes )

	test	eax, eax
	je	SHORT $LN960@eval

; 3710 :                   { sprintf(msg,"          <= 0.0           %d\n",zeroes);

	push	eax
	fstp	ST(0)
	mov	eax, DWORD PTR _msg
	fstp	ST(0)
	push	OFFSET ??_C@_0BP@HMFEOHID@?5?5?5?5?5?5?5?5?5?5?$DM?$DN?50?40?5?5?5?5?5?5?5?5?5?5?5?$CFd?6?$AA@
	push	eax
	call	_sprintf

; 3711 :                     outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	fld	QWORD PTR _binsize$91363[ebp]
	fld	QWORD PTR _lo$[ebp]
	add	esp, 16					; 00000010H
$LN960@eval:

; 3712 :                   }
; 3713 :                   
; 3714 :                   for ( n = 1 ; n < HISTBINS ; n++ )

	mov	esi, 1
	mov	DWORD PTR _n$[ebp], esi
	jmp	SHORT $LN959@eval
	npad	2
$LL2988@eval:
	fld	QWORD PTR _binsize$91363[ebp]
	fld	QWORD PTR _lo$[ebp]
$LN959@eval:

; 3715 :                   { sprintf(msg,"%10.5g - %10.5g     %d\n",
; 3716 :                      (DOUBLE)(exp(lo + (n-1)*binsize)),
; 3717 :                      (DOUBLE)(exp(lo + n*binsize)),
; 3718 :                      (int)bins[n]);

	fld	QWORD PTR [edi+esi*8-192]
	call	__ftol2_sse
	fild	DWORD PTR _n$[ebp]
	push	eax
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIexp
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	edx, DWORD PTR [esi-1]
	mov	DWORD PTR tv26617[ebp], edx
	fild	DWORD PTR tv26617[ebp]
	fmul	QWORD PTR _binsize$91363[ebp]
	fadd	QWORD PTR _lo$[ebp]
	call	__CIexp
	mov	eax, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BI@HAEINGLM@?$CF10?45g?5?9?5?$CF10?45g?5?5?5?5?5?$CFd?6?$AA@
	push	eax
	call	_sprintf

; 3719 :                     outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	inc	esi
	add	esp, 32					; 00000020H
	mov	DWORD PTR _n$[ebp], esi
	cmp	esi, 21					; 00000015H
	jl	SHORT $LL2988@eval
$LN957@eval:

; 3720 :                   }
; 3721 :                 }
; 3722 :               if ( bins[HISTBINS] > 0.0 ) 

	fldz
	fcomp	QWORD PTR [edi-24]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN956@eval

; 3723 :               { sprintf(msg,"NaN          %d\n",(int)bins[HISTBINS]);

	fld	QWORD PTR [edi-24]
	call	__ftol2_sse
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BB@GFLDKPMN@NaN?5?5?5?5?5?5?5?5?5?5?$CFd?6?$AA@
	push	edx
	call	_sprintf

; 3724 :                 outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
$LN956@eval:

; 3725 :               }
; 3726 :               }
; 3727 : 
; 3728 :               temp_free((char*)histo_data);

	mov	ecx, DWORD PTR _histo_data$[ebp]
	push	ecx
	call	_temp_free
	add	esp, 4

; 3729 :               stacktop -= HISTBINS+1 + 3 + 3;  /* erase locals */

	add	DWORD PTR [ebx+48], -224		; ffffff20H

; 3730 :               mpi_subtask_command_flag = 0;

	mov	DWORD PTR _mpi_subtask_command_flag, 0

; 3731 :               break;

	jmp	$LN1980@eval
$LN945@eval:

; 3765 : 
; 3766 :              case SET_FRONTBODY_NODE:
; 3767 :              case SET_BACKBODY_NODE:
; 3768 :              case UNSET_FRONTBODY_NODE:
; 3769 :              case UNSET_BACKBODY_NODE:
; 3770 :              case UNSET_FACET_BODY_NODE:
; 3771 :                  /*make_bfacet_lists();  */ /* so lists legal */
; 3772 :                  stacktop -= 3;  /* erase locals */
; 3773 :                  recalc_flag = 1;
; 3774 :                  break;
; 3775 : 
; 3776 :               case REFINE_NODE:
; 3777 :                 stacktop -= 3;  /* erase locals */
; 3778 : #ifdef MPI_EVOLVER
; 3779 :                if ( (this_task != MASTER_TASK) && mpi_subtask_command_flag )
; 3780 :                   mpi_task_edge_refine_wrapup();
; 3781 : #endif
; 3782 :                 break;
; 3783 : 
; 3784 :               case DISSOLVE_NODE:
; 3785 :                 stacktop -= 3;  /* erase locals */
; 3786 :                 break;
; 3787 : 
; 3788 :               case DELETE_NODE:
; 3789 :                 stacktop -= 3;  /* erase locals */
; 3790 : #ifdef MPI_EVOLVER
; 3791 :                if ( (this_task != MASTER_TASK) && mpi_subtask_command_flag )
; 3792 :                   mpi_task_delete_wrapup();
; 3793 : #endif
; 3794 :                 break;
; 3795 : 
; 3796 :               case FIX_NODE:
; 3797 :                 stacktop -= 3;  /* erase locals */
; 3798 :                 break;
; 3799 : 
; 3800 :               case UNFIX_NODE:
; 3801 :                 stacktop -= 3;  /* erase locals */
; 3802 :                 break;
; 3803 : 
; 3804 :               default:
; 3805 :                 stacktop -= 3;  /* erase locals */
; 3806 :                 break; 
; 3807 :           } break; /* end AGGREGATE_END */
; 3808 : 
; 3809 :         /*********************/
; 3810 :         /* attribute setting */
; 3811 :         /* aggregate verbs    */
; 3812 :         /*********************/
; 3813 : 
; 3814 :       case SET_FIXED_NODE:
; 3815 :         set_attr(q_id,FIXED);

	mov	edx, DWORD PTR _q_id$[ebp]
	push	0
	push	64					; 00000040H
	push	edx
	call	_set_attr
	add	esp, 12					; 0000000cH

; 3816 :         /* go back to next element generator */
; 3817 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3818 :         break;

	jmp	$LN1707@eval
$LN944@eval:

; 3819 : 
; 3820 :       case UNSET_FIXED_NODE:
; 3821 :         unset_attr(q_id,FIXED);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	64					; 00000040H
	push	eax
	call	_unset_attr
	add	esp, 12					; 0000000cH

; 3822 :         /* go back to next element generator */
; 3823 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3824 :         break;

	jmp	$LN1707@eval
$LN943@eval:

; 3825 : 
; 3826 :       case SET_BARE_NODE:
; 3827 :         set_attr(q_id,BARE_NAKED);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	65536					; 00010000H
	push	eax
	call	_set_attr
	add	esp, 12					; 0000000cH

; 3828 :         /* go back to next element generator */
; 3829 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3830 :         break;

	jmp	$LN1707@eval
$LN942@eval:

; 3831 : 
; 3832 :       case UNSET_BARE_NODE:
; 3833 :         unset_attr(q_id,BARE_NAKED);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	65536					; 00010000H
	push	eax
	call	_unset_attr
	add	esp, 12					; 0000000cH

; 3834 :         /* go back to next element generator */
; 3835 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3836 :         break;

	jmp	$LN1707@eval
$LN941@eval:

; 3837 : 
; 3838 :       case UNSET_CENTEROFMASS_NODE:
; 3839 :         unset_attr(q_id,WANT_CENTEROFMASS);

	mov	esi, DWORD PTR _q_id$[ebp]
	push	2
	push	0
	push	esi
	call	_unset_attr

; 3840 :         unset_attr(q_id,HAVE_CENTEROFMASS);

	push	0
	push	32768					; 00008000H
	push	esi
	call	_unset_attr
	add	esp, 24					; 00000018H

; 3841 : 
; 3842 :         /* go back to next element generator */
; 3843 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3844 :         break;

	jmp	$LN1707@eval
$LN940@eval:

; 3845 : 
; 3846 :       case SET_CENTEROFMASS_NODE:
; 3847 :         set_attr(q_id,WANT_CENTEROFMASS);

	mov	esi, DWORD PTR _q_id$[ebp]
	push	2
	push	0
	push	esi
	call	_set_attr

; 3848 :         { REAL *cm = get_body_cm(q_id);  /* in unit cell coordinates */

	mov	eax, DWORD PTR _web+348
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+esi*4]

; 3849 :           for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+616, ecx
	jle	$LN1707@eval
	fld	QWORD PTR __real@3fe0000000000000
$LN939@eval:

; 3850 :             cm[i] = 0.5;

	fst	QWORD PTR [eax+ecx*8+352]
	inc	ecx
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN939@eval
$LN3315@eval:

; 3849 :           for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)

; 3851 :         }
; 3852 : 
; 3853 :         /* go back to next element generator */
; 3854 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3855 :         break;

	jmp	$LN1707@eval
$LN936@eval:

; 3856 : 
; 3857 :       case SET_NO_DISPLAY_NODE:
; 3858 :         set_attr(q_id,NODISPLAY);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	2
	push	eax
	call	_set_attr
	add	esp, 12					; 0000000cH

; 3859 :         /* go back to next element generator */
; 3860 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3861 :         break;

	jmp	$LN1707@eval
$LN935@eval:

; 3862 : 
; 3863 :       case UNSET_NO_DISPLAY_NODE:
; 3864 :         unset_attr(q_id,NODISPLAY);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	2
	push	eax
	call	_unset_attr
	add	esp, 12					; 0000000cH

; 3865 :         /* go back to next element generator */
; 3866 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3867 :         break;

	jmp	$LN1707@eval
$LN934@eval:

; 3868 : 
; 3869 :       case SET_NONCONTENT_NODE:
; 3870 :         if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN933@eval

; 3871 :         { sprintf(errmsg,"Changing NONCONTENT not implemented for everything_quantities mode yet.\n");

	push	OFFSET ??_C@_0EJ@GDFDELKD@Changing?5NONCONTENT?5not?5implemen@
	push	OFFSET _errmsg
	call	_sprintf

; 3872 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 3873 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL2842@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2842@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 3874 :           kb_error(2484,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2484					; 000009b4H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN933@eval:

; 3875 :         }
; 3876 :         set_attr(q_id,NONCONTENT);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	536870912				; 20000000H
	push	eax
	call	_set_attr
	add	esp, 12					; 0000000cH

; 3877 :         /* go back to next element generator */
; 3878 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3879 :         break;

	jmp	$LN1707@eval
$LN932@eval:

; 3880 : 
; 3881 :       case UNSET_NONCONTENT_NODE:
; 3882 :         if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN931@eval

; 3883 :         { sprintf(errmsg,"Changing NONCONTENT not implemented for everything_quantities mode yet.\n");

	push	OFFSET ??_C@_0EJ@GDFDELKD@Changing?5NONCONTENT?5not?5implemen@
	push	OFFSET _errmsg
	call	_sprintf

; 3884 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 3885 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL2843@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2843@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 3886 :           kb_error(2595,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2595					; 00000a23H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN931@eval:

; 3887 :         }
; 3888 :         unset_attr(q_id,NONCONTENT);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	536870912				; 20000000H
	push	eax
	call	_unset_attr
	add	esp, 12					; 0000000cH

; 3889 :         /* go back to next element generator */
; 3890 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3891 :         break;

	jmp	$LN1707@eval
$LN930@eval:

; 3892 : 
; 3893 :       case SET_HIT_PARTNER_NODE:
; 3894 :         set_attr(q_id,HIT_PARTNER);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	32768					; 00008000H
	push	eax
	call	_set_attr
	add	esp, 12					; 0000000cH

; 3895 :         /* go back to next element generator */
; 3896 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3897 :         break;

	jmp	$LN1707@eval
$LN929@eval:

; 3898 : 
; 3899 :       case UNSET_HIT_PARTNER_NODE:
; 3900 :         unset_attr(q_id,HIT_PARTNER);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	32768					; 00008000H
	push	eax
	call	_unset_attr
	add	esp, 12					; 0000000cH

; 3901 :         /* go back to next element generator */
; 3902 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3903 :         break;

	jmp	$LN1707@eval
$LN928@eval:

; 3904 : 
; 3905 :       case SET_NO_HESSIAN_NORMAL_NODE:
; 3906 :         set_attr(q_id,NO_HESSIAN_NORMAL_ATTR);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	-2147483648				; 80000000H
	push	eax
	call	_set_attr
	add	esp, 12					; 0000000cH

; 3907 :         /* go back to next element generator */
; 3908 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3909 :         break;

	jmp	$LN1707@eval
$LN927@eval:

; 3910 : 
; 3911 :       case UNSET_NO_HESSIAN_NORMAL_NODE:
; 3912 :         unset_attr(q_id,NO_HESSIAN_NORMAL_ATTR);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	-2147483648				; 80000000H
	push	eax
	call	_unset_attr
	add	esp, 12					; 0000000cH

; 3913 :         /* go back to next element generator */
; 3914 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3915 :         break;

	jmp	$LN1707@eval
$LN926@eval:

; 3916 : 
; 3917 :       case SET_NO_REFINE_NODE:
; 3918 :         set_attr(q_id,NO_REFINE);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	16777216				; 01000000H
	push	eax
	call	_set_attr
	add	esp, 12					; 0000000cH

; 3919 :         /* go back to next element generator */
; 3920 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3921 :         break;

	jmp	$LN1707@eval
$LN925@eval:

; 3922 : 
; 3923 :       case UNSET_NO_REFINE_NODE:
; 3924 :         unset_attr(q_id,NO_REFINE);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	16777216				; 01000000H
	push	eax
	call	_unset_attr
	add	esp, 12					; 0000000cH

; 3925 :         /* go back to next element generator */
; 3926 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3927 :         break;

	jmp	$LN1707@eval
$LN924@eval:

; 3928 : 
; 3929 :       case SET_NO_TRANSFORM_NODE:
; 3930 :         set_attr(q_id,NO_TRANSFORM);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	1
	push	0
	push	eax
	call	_set_attr
	add	esp, 12					; 0000000cH

; 3931 :         some_no_transforms_flag = 1; // have to disable transforms via graphics hardware

	mov	DWORD PTR _some_no_transforms_flag, 1

; 3932 :         /* go back to next element generator */
; 3933 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3934 :         break;

	jmp	$LN1707@eval
$LN923@eval:

; 3935 : 
; 3936 :       case UNSET_NO_TRANSFORM_NODE:
; 3937 :         unset_attr(q_id,NO_TRANSFORM);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	1
	push	0
	push	eax
	call	_unset_attr
	add	esp, 12					; 0000000cH

; 3938 :         /* go back to next element generator */
; 3939 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3940 :         break;

	jmp	$LN1707@eval
$LN922@eval:

; 3941 : 
; 3942 :       case UNSET_PRESSURE_NODE:
; 3943 :         unset_attr(q_id,PRESSURE);

	mov	esi, DWORD PTR _q_id$[ebp]
	push	0
	push	2048					; 00000800H
	push	esi
	call	_unset_attr
	add	esp, 12					; 0000000cH

; 3944 :         if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN1707@eval

; 3945 :         { struct gen_quant *q = GEN_QUANT(get_body_volquant(q_id));

	mov	eax, DWORD PTR _web+348

; 3946 :           q->modulus = 1;

	fld1
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ecx+404]
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list
	fstp	QWORD PTR [eax+176]
$LN4020@eval:

; 3947 :           q->flags &= ~(Q_ENERGY|Q_FIXED|Q_CONSERVED);

	mov	edx, DWORD PTR [eax+136]
	and	edx, -12				; fffffff4H

; 3948 :           q->flags |= Q_INFO;

	or	edx, 4
	mov	DWORD PTR [eax+136], edx

; 3949 :         }
; 3950 :         /* go back to next element generator */
; 3951 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3952 :         break;

	jmp	$LN1707@eval
$LN920@eval:

; 3953 : 
; 3954 :       case UNSET_CONSTRAINT_NODE:
; 3955 :       case UNSET_CONSTRAINT_NAME_NODE:
; 3956 :         if  (node->type == UNSET_CONSTRAINT_NODE) 

	cmp	edx, 10284				; 0000282cH
	jne	SHORT $LN919@eval

; 3957 :           k = (int)*(stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], esi

; 3958 :         else

	jmp	SHORT $LN918@eval
$LN919@eval:

; 3959 :           k =  node->op3.connum;

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+140]
$LN918@eval:

; 3960 :         k &= CONMASK; /* so will ignore hit bit */

	and	eax, 1073741823				; 3fffffffH

; 3961 :         if ( k < web.maxcon )

	cmp	eax, DWORD PTR _web+644
	jge	$LN1707@eval

; 3962 :         switch ( id_type(q_id) )

	mov	edx, DWORD PTR _q_id$[ebp]
	mov	ecx, edx
	shr	ecx, 29					; 0000001dH
	sub	ecx, 0
	je	$LN914@eval
	dec	ecx
	je	$LN913@eval
	dec	ecx
	je	SHORT $LN912@eval

; 3971 :              break;
; 3972 :           default: 
; 3973 :              sprintf(errmsg,"Bad element type for constraint.\n");

	push	OFFSET ??_C@_0CC@GMFFIBPI@Bad?5element?5type?5for?5constraint?4@
	push	OFFSET _errmsg
	call	_sprintf

; 3974 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 3975 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	esi, DWORD PTR [eax+1]
$LL2844@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2844@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 3976 :              kb_error(1292,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1292					; 0000050cH
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	$LN1707@eval
$LN912@eval:

; 3968 :              break;
; 3969 :           case FACET:
; 3970 :              unset_f_constraint_map(q_id,k);

	push	eax
	push	edx
	call	_unset_f_constraint_map
	add	esp, 8

; 3977 :         }
; 3978 :         /* go back to next element generator */
; 3979 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3980 :         break;

	jmp	$LN1707@eval
$LN913@eval:

; 3965 :              break;
; 3966 :           case EDGE:
; 3967 :              unset_e_constraint_map(q_id,k);

	push	eax
	push	edx
	call	_unset_e_constraint_map
	add	esp, 8

; 3977 :         }
; 3978 :         /* go back to next element generator */
; 3979 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3980 :         break;

	jmp	$LN1707@eval
$LN914@eval:

; 3963 :         { case VERTEX:
; 3964 :              unset_v_constraint_map(q_id,k);

	push	eax
	push	edx
	call	_unset_v_constraint_map
	add	esp, 8

; 3977 :         }
; 3978 :         /* go back to next element generator */
; 3979 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 3980 :         break;

	jmp	$LN1707@eval
$LN910@eval:

; 3981 : 
; 3982 :       case SET_BOUNDARY_NODE:
; 3983 :         k =  (int)*(stacktop--);  /* boundary number */

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 3984 :         if ( get_attr(v_id) & CONSTRAINT )

	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	DWORD PTR _k$[ebp], eax
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	add	esi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], esi
	shl	edx, 4
	mov	eax, DWORD PTR _web[edx+12]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN909@eval

; 3985 :         { sprintf(errmsg,"Cannot put %s %s on a boundary since it is already on a constraint.\n",
; 3986 :              typenames[id_type(q_id)],ELNAME(q_id));

	mov	esi, DWORD PTR _q_id$[ebp]
	test	esi, 268435456				; 10000000H
	je	SHORT $LN2245@eval
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN2246@eval
$LN2245@eval:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN2246@eval:
	push	eax
	shr	esi, 29					; 0000001dH
	mov	edx, DWORD PTR _typenames[esi*4]
	push	edx
	push	OFFSET ??_C@_0EF@DIFGONKI@Cannot?5put?5?$CFs?5?$CFs?5on?5a?5boundary?5s@
	push	OFFSET _errmsg
	call	_sprintf

; 3987 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 3988 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL2845@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2845@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 3989 :           kb_error(5999,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5999					; 0000176fH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN909@eval:

; 3990 :         }
; 3991 :         bdry = web.boundaries+abs(k);

	mov	esi, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR _web+776
	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	ecx, eax
	imul	ecx, 136				; 00000088H
	add	ecx, edi
	mov	DWORD PTR tv19769[ebp], eax
	mov	DWORD PTR _bdry$[ebp], ecx

; 3992 :         if (  (abs(k) >= web.bdrymax) || !(bdry->attr&IN_USE) ) 

	cmp	eax, DWORD PTR _web+768
	jge	SHORT $LN907@eval
	mov	eax, DWORD PTR [ecx+32]
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN908@eval
$LN907@eval:

; 3993 :         { sprintf(errmsg,"Boundary %d is not valid.\n",k);

	push	esi
	push	OFFSET ??_C@_0BL@HEGGOIJJ@Boundary?5?$CFd?5is?5not?5valid?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 3994 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 3995 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL2846@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2846@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 3996 :           kb_error(2998,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2998					; 00000bb6H
	call	_kb_error
	mov	edi, DWORD PTR _web+776
	add	esp, 28					; 0000001cH
$LN908@eval:

; 3997 :         }
; 3998 :         if ( get_attr(q_id) & BOUNDARY )

	mov	esi, DWORD PTR _q_id$[ebp]
	mov	eax, esi
	shr	eax, 29					; 0000001dH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 4
	mov	edx, DWORD PTR _web[ecx+12]
	mov	DWORD PTR tv18233[ebp], eax
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN3124@eval

; 3999 :         { struct boundary *qbdry;
; 4000 :           switch ( id_type(q_id) )

	mov	eax, DWORD PTR tv18233[ebp]
	mov	edx, DWORD PTR _V_BOUNDARY_ATTR
	sub	eax, ecx
	mov	ecx, DWORD PTR _dymem
	je	SHORT $LN903@eval
	dec	eax
	je	SHORT $LN902@eval
	dec	eax

; 4004 :             default:     qbdry = NULL;  /* error message below */

	jne	$LN2247@eval

; 4003 :             case FACET:  qbdry = get_facet_boundary(q_id); break;

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	test	eax, eax
	je	$LN2247@eval
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [eax+edx]
	imul	eax, 136				; 00000088H
	add	eax, edi
	jmp	SHORT $LN2248@eval
$LN902@eval:

; 4002 :             case EDGE:   qbdry = get_edge_boundary(q_id); break;

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN2247@eval
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [eax+edx]
	imul	eax, 136				; 00000088H
	add	eax, edi
	jmp	SHORT $LN2248@eval
$LN903@eval:

; 4001 :           { case VERTEX: qbdry = get_boundary(q_id); break;

	test	edx, edx
	je	SHORT $LN2247@eval
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR [edx+ecx+64]
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [eax+edx]
	imul	eax, 136				; 00000088H
	add	eax, edi
	jmp	SHORT $LN2248@eval
$LN2247@eval:
	xor	eax, eax
$LN2248@eval:

; 4005 :           }
; 4006 :           if ( qbdry == bdry ) break;

	cmp	eax, DWORD PTR _bdry$[ebp]
	je	$LN1980@eval

; 4007 :           sprintf(errmsg,"Cannot put %s %s on boundary %d since it is already on another boundary.\n",
; 4008 :              typenames[id_type(q_id)],ELNAME(q_id),abs(k));

	test	DWORD PTR _q_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN2253@eval
	lea	eax, DWORD PTR [esi+1]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN2254@eval
$LN2253@eval:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN2254@eval:
	mov	edi, DWORD PTR tv19769[ebp]
	mov	ecx, DWORD PTR tv18233[ebp]
	mov	edx, DWORD PTR _typenames[ecx*4]
	push	edi
	push	eax
	push	edx
	push	OFFSET ??_C@_0EK@PDNAEKOB@Cannot?5put?5?$CFs?5?$CFs?5on?5boundary?5?$CFd?5@
	push	OFFSET _errmsg
	call	_sprintf

; 4009 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4010 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR [eax+1]
$LL2847@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2847@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4011 :           kb_error(2999,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2999					; 00000bb7H
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN906@eval
$LN3124@eval:
	mov	edi, DWORD PTR tv19769[ebp]
$LN906@eval:

; 4012 :         }
; 4013 :         set_attr(q_id,BOUNDARY);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	128					; 00000080H
	push	eax
	call	_set_attr
	add	esp, 12					; 0000000cH

; 4014 :         if ( k < 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jge	SHORT $LN898@eval

; 4015 :           set_attr(q_id,NEGBOUNDARY);

	mov	ecx, DWORD PTR _q_id$[ebp]
	push	0
	push	256					; 00000100H
	push	ecx
	call	_set_attr
	add	esp, 12					; 0000000cH
$LN898@eval:

; 4016 :  
; 4017 :         switch(id_type(q_id))

	mov	eax, DWORD PTR tv18233[ebp]
	sub	eax, 0
	je	$LN895@eval
	dec	eax
	je	$LN888@eval
	dec	eax
	je	SHORT $LN887@eval

; 4038 :             default: 
; 4039 :              sprintf(errmsg,"Bad element type for boundary.\n");

	push	OFFSET ??_C@_0CA@CHBGMBCP@Bad?5element?5type?5for?5boundary?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4040 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4041 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	esi, DWORD PTR [eax+1]
$LL2848@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2848@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4042 :              kb_error(3000,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3000					; 00000bb8H
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	$LN892@eval
$LN887@eval:

; 4035 :             case FACET:
; 4036 :              set_facet_boundary_num(q_id,abs(k));

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	test	eax, eax
	je	$LN892@eval
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [edx+ecx], edi

; 4037 :              break;

	jmp	$LN892@eval
$LN888@eval:

; 4028 :                 PROF_EVAL_START(ex_profiling);
; 4029 :               }
; 4030 :               break;
; 4031 :             }
; 4032 :             case EDGE:
; 4033 :              set_edge_boundary_num(q_id,abs(k));

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	eax, eax
	je	$LN892@eval
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx], edi

; 4034 :              break;

	jmp	$LN892@eval
$LN895@eval:

; 4018 :           { case VERTEX:
; 4019 :             { REAL *x = get_coord(q_id);

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax+64]
	add	eax, ecx
	mov	DWORD PTR _x$91560[ebp], eax

; 4020 :               int n;
; 4021 :               set_boundary_num(q_id,abs(k));

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN2255@eval
	imul	eax, 240				; 000000f0H
	add	eax, edx
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+64]
	mov	DWORD PTR [ecx+eax], edi
$LN2255@eval:

; 4022 :               for ( n = 0 ; n < SDIM ; n++ )

	xor	edi, edi
	cmp	DWORD PTR _web+616, edi
	jle	$LN892@eval
	mov	ecx, DWORD PTR _bdry$[ebp]
	mov	eax, DWORD PTR _eval_stack_trace_spot
	add	ecx, 48					; 00000030H
	mov	DWORD PTR tv27649[ebp], ecx
	npad	10
$LL894@eval:

; 4023 :               if ( bdry->coordf[n]->root != NULL )

	mov	edx, DWORD PTR tv27649[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	DWORD PTR [ecx+4], 0
	je	$LN893@eval

; 4024 :               { PROF_EVAL_END(ex_profiling);
; 4025 :                 PUSH_TRACE;

	cmp	eax, 100				; 00000064H
	jl	SHORT $LN890@eval
	xor	eax, eax
$LN890@eval:
	mov	edx, DWORD PTR _node$[ebp]

; 4026 :                 x[n] = eval(bdry->coordf[n],get_param(q_id),q_id,NULL);

	mov	ecx, DWORD PTR _web+104
	mov	DWORD PTR _eval_stack_trace[eax*4], edx
	mov	edx, DWORD PTR _dymem
	inc	eax
	mov	DWORD PTR _eval_stack_trace_spot, eax
	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	eax
	mov	eax, DWORD PTR [ecx+edx+544]
	mov	ecx, DWORD PTR _web+12
	add	eax, DWORD PTR [ecx+esi*4]
	mov	edx, DWORD PTR tv27649[ebp]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_eval
	mov	ecx, DWORD PTR _x$91560[ebp]
	fstp	QWORD PTR [ecx+edi*8]

; 4027 :                 POP_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	add	esp, 16					; 00000010H
	test	eax, eax
	jle	SHORT $LN893@eval
	mov	DWORD PTR _eval_stack_trace[eax*4], 0
	dec	eax
	mov	DWORD PTR _eval_stack_trace_spot, eax
$LN893@eval:

; 4022 :               for ( n = 0 ; n < SDIM ; n++ )

	add	DWORD PTR tv27649[ebp], 4
	inc	edi
	cmp	edi, DWORD PTR _web+616
	jl	$LL894@eval
$LN892@eval:

; 4043 :            }
; 4044 :           if ( bdry->attr & CON_ENERGY )

	mov	esi, DWORD PTR _bdry$[ebp]
	mov	eax, DWORD PTR [esi+32]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN885@eval

; 4045 :              apply_method_num(q_id,bdry->energy_method);

	mov	edx, DWORD PTR [esi+124]
	mov	eax, DWORD PTR _q_id$[ebp]
	push	edx
	push	eax
	call	_apply_method_num
	add	esp, 8
$LN885@eval:

; 4046 :           if ( bdry->attr & CON_CONTENT )

	mov	eax, DWORD PTR [esi+32]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN1707@eval

; 4047 :           { if ( (web.representation == STRING) && (id_type(q_id) == VERTEX) )

	mov	eax, DWORD PTR _web+624
	cmp	eax, 1
	jne	SHORT $LN883@eval
	cmp	DWORD PTR tv18233[ebp], ecx
	jne	SHORT $LN883@eval

; 4048 :               fixup_vertex_content_meths(q_id);

	mov	ecx, DWORD PTR _q_id$[ebp]
	push	ecx
	call	_fixup_vertex_content_meths

; 4050 :               fixup_edge_content_meths(q_id);

	add	esp, 4

; 4051 :           }
; 4052 :         
; 4053 :         /* go back to next element generator */
; 4054 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 4055 :         break;

	jmp	$LN1707@eval
$LN883@eval:

; 4049 :             else if ( (web.representation == SOAPFILM) && (id_type(q_id) == EDGE) )

	cmp	eax, 2
	jne	$LN1707@eval
	cmp	DWORD PTR tv18233[ebp], 1
$LN4021@eval:
	jne	$LN1707@eval

; 4050 :               fixup_edge_content_meths(q_id);

	mov	edx, DWORD PTR _q_id$[ebp]
	push	edx
	call	_fixup_edge_content_meths
	add	esp, 4

; 4051 :           }
; 4052 :         
; 4053 :         /* go back to next element generator */
; 4054 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 4055 :         break;

	jmp	$LN1707@eval
$LN880@eval:

; 4056 : 
; 4057 :       case UNSET_BOUNDARY_NODE:
; 4058 :       case UNSET_BOUNDARY_NAME_NODE:
; 4059 :         k = (node->type == UNSET_BOUNDARY_NODE) ? (int)*(stacktop--)
; 4060 :                : node->op3.bdrynum;

	cmp	edx, 10287				; 0000282fH
	jne	SHORT $LN2261@eval
	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], esi
	jmp	SHORT $LN2262@eval
$LN2261@eval:
	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+140]
$LN2262@eval:

; 4061 :         if ( k >= web.bdrymax ) break;

	cmp	eax, DWORD PTR _web+768
	jge	$LN1980@eval

; 4062 :         bdry = web.boundaries+k;

	mov	esi, DWORD PTR _web+776
	imul	eax, 136				; 00000088H
	add	eax, esi
	mov	DWORD PTR _bdry$[ebp], eax

; 4063 :         if ( get_attr(q_id) & BOUNDARY )

	mov	eax, DWORD PTR _q_id$[ebp]
	mov	edi, eax
	shr	edi, 29					; 0000001dH
	and	eax, 134217727				; 07ffffffH
	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	shl	ecx, 4
	mov	edx, DWORD PTR _web[ecx+12]
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [edx+eax]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 128				; 00000080H
	xor	edx, edx
	or	ecx, edx
	mov	DWORD PTR tv18233[ebp], edi
	je	$LN1707@eval

; 4064 :         {
; 4065 :           switch ( id_type(q_id) )

	mov	ecx, edi
	sub	ecx, edx
	je	$LN875@eval
	dec	ecx
	je	$LN873@eval
	dec	ecx
	je	SHORT $LN871@eval

; 4084 :              default: 
; 4085 :              sprintf(errmsg,"Bad element type for boundary.\n");

	push	OFFSET ??_C@_0CA@CHBGMBCP@Bad?5element?5type?5for?5boundary?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4086 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4087 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	esi, DWORD PTR [eax+1]
$LL2849@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2849@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4088 :              kb_error(1293,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1293					; 0000050dH
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	$LN874@eval
$LN871@eval:

; 4078 :             case FACET:
; 4079 :              if ( get_facet_boundary(q_id) == bdry )

	mov	edx, DWORD PTR _F_BOUNDARY_ATTR
	test	edx, edx
	je	SHORT $LN2271@eval
	mov	edi, DWORD PTR _dymem
	mov	ecx, edx
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+328
	mov	ecx, DWORD PTR [ecx+edi+64]
	mov	edi, DWORD PTR _web+236
	mov	edi, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [ecx+edi]
	mov	edi, DWORD PTR tv18233[ebp]
	imul	ecx, 136				; 00000088H
	add	ecx, esi
	jmp	SHORT $LN2272@eval
$LN2271@eval:
	xor	ecx, ecx
$LN2272@eval:
	cmp	ecx, DWORD PTR _bdry$[ebp]
	jne	$LN874@eval

; 4080 :               { set_facet_boundary_num(q_id,0);

	test	edx, edx
	je	SHORT $LN2273@eval
	mov	ecx, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+328
	mov	edx, DWORD PTR [edx+ecx+64]
	mov	ecx, DWORD PTR _web+236
$LN3972@eval:
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+eax], 0
$LN2273@eval:

; 4081 :                 unset_attr(q_id,BOUNDARY);

	push	0
	push	128					; 00000080H

; 4082 :               }
; 4083 :              break;

	jmp	$LN3971@eval
$LN873@eval:

; 4070 :               }
; 4071 :              break;
; 4072 :             case EDGE:
; 4073 :              if ( get_edge_boundary(q_id) == bdry )

	mov	edx, DWORD PTR _E_BOUNDARY_ATTR
	test	edx, edx
	je	SHORT $LN2267@eval
	mov	edi, DWORD PTR _dymem
	mov	ecx, edx
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edi+64]
	mov	edi, DWORD PTR _web+124
	mov	edi, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [ecx+edi]
	mov	edi, DWORD PTR tv18233[ebp]
	imul	ecx, 136				; 00000088H
	add	ecx, esi
	jmp	SHORT $LN2268@eval
$LN2267@eval:
	xor	ecx, ecx
$LN2268@eval:
	cmp	ecx, DWORD PTR _bdry$[ebp]
	jne	$LN874@eval

; 4074 :               { set_edge_boundary_num(q_id,0);

	test	edx, edx
	je	SHORT $LN2273@eval
	mov	ecx, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ecx+64]
	mov	ecx, DWORD PTR _web+124

; 4075 :                 unset_attr(q_id,BOUNDARY);
; 4076 :               }
; 4077 :              break;

	jmp	$LN3972@eval
$LN875@eval:

; 4066 :           { case VERTEX:
; 4067 :              if ( get_boundary(q_id) == bdry )

	mov	edx, DWORD PTR _V_BOUNDARY_ATTR
	test	edx, edx
	je	SHORT $LN2263@eval
	mov	edi, DWORD PTR _dymem
	mov	ecx, edx
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+edi+64]
	mov	edi, DWORD PTR _web+12
	mov	edi, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [ecx+edi]
	mov	edi, DWORD PTR tv18233[ebp]
	imul	ecx, 136				; 00000088H
	add	ecx, esi
	jmp	SHORT $LN2264@eval
$LN2263@eval:
	xor	ecx, ecx
$LN2264@eval:
	cmp	ecx, DWORD PTR _bdry$[ebp]
	jne	SHORT $LN874@eval

; 4068 :               { set_boundary_num(q_id,0);

	test	edx, edx
	je	SHORT $LN2265@eval
	mov	ecx, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+ecx+64]
	mov	ecx, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+eax], 0
$LN2265@eval:

; 4069 :                 unset_attr(q_id,BOUNDARY|HIT_PARTNER);

	push	0
	push	32896					; 00008080H
$LN3971@eval:
	mov	ecx, DWORD PTR _q_id$[ebp]
	push	ecx
	call	_unset_attr
	add	esp, 12					; 0000000cH
$LN874@eval:

; 4089 :            }
; 4090 :           if ( bdry->attr & CON_ENERGY )

	mov	esi, DWORD PTR _bdry$[ebp]
	mov	eax, DWORD PTR [esi+32]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN868@eval

; 4091 :              unapply_method(q_id,bdry->energy_method);

	mov	edx, DWORD PTR [esi+124]
	mov	eax, DWORD PTR _q_id$[ebp]
	push	edx
	push	eax
	call	_unapply_method
	add	esp, 8
$LN868@eval:

; 4092 :           if ( bdry->attr & CON_CONTENT )

	mov	eax, DWORD PTR [esi+32]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN1707@eval

; 4093 :            { if ( (web.representation == STRING) && (id_type(q_id) == VERTEX) )

	mov	eax, DWORD PTR _web+624
	cmp	eax, 1
	jne	SHORT $LN866@eval
	test	edi, edi
	jne	SHORT $LN866@eval

; 4094 :               fixup_vertex_content_meths(q_id);

	mov	ecx, DWORD PTR _q_id$[ebp]
	push	ecx
	call	_fixup_vertex_content_meths
	add	esp, 4
	jmp	$LN1707@eval
$LN866@eval:

; 4095 :             else if ( (web.representation == SOAPFILM) && (id_type(q_id) == EDGE) )

	cmp	eax, 2
	jne	$LN1707@eval
	cmp	edi, 1

; 4096 :               fixup_edge_content_meths(q_id);
; 4097 :           }
; 4098 :         }
; 4099 :         /* go back to next element generator */
; 4100 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 4101 :         break;

	jmp	$LN4021@eval
$LN863@eval:

; 4102 : 
; 4103 :       case UNSET_VOLUME_NODE:
; 4104 :       case UNSET_TARGET_NODE:
; 4105 :         if ( get_attr(q_id) & FIXEDVOL)

	mov	eax, DWORD PTR _q_id$[ebp]
	mov	esi, eax
	shr	eax, 29					; 0000001dH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	and	esi, 134217727				; 07ffffffH
	shl	ecx, 4
	mov	edx, DWORD PTR _web[ecx+12]
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [edx+esi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN1707@eval

; 4106 :          { unset_attr(q_id,FIXEDVOL);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	ecx
	push	32					; 00000020H
	push	eax
	call	_unset_attr
	add	esp, 12					; 0000000cH

; 4107 :            if (everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN1707@eval

; 4108 :            { struct gen_quant *q = GEN_QUANT(get_body_volquant(q_id));

	mov	ecx, DWORD PTR _web+348

; 4109 :              q->target = 0.0;

	fldz
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+404]
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list
	fstp	QWORD PTR [eax+144]

; 4110 :              if ( !(q->flags & Q_INFO) )

	mov	ecx, DWORD PTR [eax+136]
	test	cl, 4
	jne	SHORT $LN860@eval

; 4111 :              { q->flags &= ~(Q_FIXED|Q_ENERGY|Q_CONSERVED);

	and	ecx, -12				; fffffff4H

; 4112 :                 q->flags |= Q_INFO;

	or	ecx, 4
	mov	DWORD PTR [eax+136], ecx
$LN860@eval:

; 4113 :              }
; 4114 :              if ( web.pressure_flag )

	cmp	DWORD PTR _web+868, 0
	je	$LN1707@eval

; 4115 :              { q = GEN_QUANT(get_body_ambquant(q_id));

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ecx+408]
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list

; 4116 :                q->flags &= ~(Q_FIXED|Q_ENERGY|Q_CONSERVED);
; 4117 :                q->flags |= Q_INFO;
; 4118 :              }
; 4119 :            }
; 4120 :          }
; 4121 :         /* go back to next element generator */
; 4122 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 4123 :         break;

	jmp	$LN4020@eval
$LN858@eval:

; 4124 : 
; 4125 :       case UNSET_FACET_BODY_NODE:
; 4126 :         if ( id_type(q_id) != FACET  )

	mov	eax, DWORD PTR _q_id$[ebp]
	and	eax, -536870912				; e0000000H
	cmp	eax, 1073741824				; 40000000H
	je	SHORT $LN857@eval

; 4127 :         { sprintf(errmsg,"Trying to unset body of non-facet.\n");

	push	OFFSET ??_C@_0CE@MDJIMOLA@Trying?5to?5unset?5body?5of?5non?9face@
	push	OFFSET _errmsg
	call	_sprintf

; 4128 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4129 :                 file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL2850@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2850@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4130 :           kb_error(1294,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1294					; 0000050eH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN857@eval:

; 4131 :         }
; 4132 :         set_facet_body(q_id,NULLID);

	mov	esi, DWORD PTR _q_id$[ebp]
	push	0
	push	esi
	call	_set_facet_body

; 4133 :         set_facet_body(inverse_id(q_id),NULLID);

	push	0
	xor	esi, 134217728				; 08000000H
	push	esi
	call	_set_facet_body
	add	esp, 16					; 00000010H

; 4134 :         /* go back to next element generator */
; 4135 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 4136 :         break;

	jmp	$LN1707@eval
$LN856@eval:

; 4137 : 
; 4138 :       case UNSET_FRONTBODY_NODE:
; 4139 :       case UNSET_BACKBODY_NODE:
; 4140 :        set_body(node->type==UNSET_FRONTBODY_NODE?q_id:inverse_id(q_id),NULLID);

	mov	eax, DWORD PTR _q_id$[ebp]
	cmp	edx, 10292				; 00002834H
	je	SHORT $LN2276@eval
	xor	eax, 134217728				; 08000000H
$LN2276@eval:
	push	0
	push	eax
	call	_set_body
	add	esp, 8

; 4141 :        recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], 1

; 4142 :        node += node->op1.skipsize - 1;  /* back to start of loop */
; 4143 :        break;

	jmp	$LN1707@eval
$LN855@eval:

; 4144 : 
; 4145 :       case UNSET_DENSITY_NODE:
; 4146 :         unset_attr(q_id,DENSITY);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	16					; 00000010H
	push	eax
	call	_unset_attr
	add	esp, 12					; 0000000cH

; 4147 :         /* go back to next element generator */
; 4148 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 4149 :         break;

	jmp	$LN1707@eval
$LN854@eval:

; 4150 :  
; 4151 :       case SET_TRIPLE_PT_NODE:
; 4152 :         set_attr(q_id,TRIPLE_PT);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	524288					; 00080000H
	push	eax
	call	_set_attr
	add	esp, 12					; 0000000cH

; 4153 :         /* go back to next element generator */
; 4154 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 4155 :         break;

	jmp	$LN1707@eval
$LN853@eval:

; 4156 : 
; 4157 :       case UNSET_TRIPLE_PT_NODE:
; 4158 :         unset_attr(q_id,TRIPLE_PT);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	524288					; 00080000H
	push	eax
	call	_unset_attr
	add	esp, 12					; 0000000cH

; 4159 :         /* go back to next element generator */
; 4160 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 4161 :         break;

	jmp	$LN1707@eval
$LN852@eval:

; 4162 : 
; 4163 :       case SET_TETRA_PT_NODE:
; 4164 :         set_attr(q_id,TETRA_PT);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	262144					; 00040000H
	push	eax
	call	_set_attr
	add	esp, 12					; 0000000cH

; 4165 :         /* go back to next element generator */
; 4166 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 4167 :         break;

	jmp	$LN1707@eval
$LN851@eval:

; 4168 : 
; 4169 :       case UNSET_TETRA_PT_NODE:
; 4170 :         unset_attr(q_id,TETRA_PT);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	262144					; 00040000H
	push	eax
	call	_unset_attr
	add	esp, 12					; 0000000cH

; 4171 :         /* go back to next element generator */
; 4172 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 4173 :         break;

	jmp	$LN1707@eval
$LN850@eval:

; 4174 : 
; 4175 :       case SET_AXIAL_POINT_NODE:
; 4176 :         set_attr(q_id,AXIAL_POINT);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	8388608					; 00800000H
	push	eax
	call	_set_attr
	add	esp, 12					; 0000000cH

; 4177 :         /* go back to next element generator */
; 4178 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 4179 :         break;

	jmp	$LN1707@eval
$LN849@eval:

; 4180 : 
; 4181 :       case UNSET_AXIAL_POINT_NODE:
; 4182 :         unset_attr(q_id,AXIAL_POINT);

	mov	eax, DWORD PTR _q_id$[ebp]
	push	0
	push	8388608					; 00800000H
	push	eax
	call	_unset_attr
	add	esp, 12					; 0000000cH

; 4183 :         /* go back to next element generator */
; 4184 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 4185 :         break;

	jmp	$LN1707@eval
$LN848@eval:

; 4186 : 
; 4187 :       case SET_DENSITY_NODE:
; 4188 :       { REAL density = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	fst	QWORD PTR _density$91690[ebp]
	mov	DWORD PTR [ebx+48], eax

; 4189 :          if ( density != 1.0 ) set_attr(q_id,DENSITY);

	fld	ST(0)
	fld1
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN847@eval
	mov	eax, DWORD PTR _q_id$[ebp]
	fstp	ST(0)
	push	0
	push	16					; 00000010H
	push	eax
	call	_set_attr
	fld	QWORD PTR _density$91690[ebp]
	add	esp, 12					; 0000000cH
$LN847@eval:

; 4190 :          switch ( node->op2.eltype )

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+136]
	dec	eax
	je	SHORT $LN844@eval
	dec	eax
	je	SHORT $LN843@eval
	dec	eax
	jne	$LN3315@eval

; 4193 :               case BODY: set_body_density(q_id,density); break;

	mov	edx, DWORD PTR _q_id$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	call	_set_body_density
	add	esp, 12					; 0000000cH
	jmp	$LN1707@eval
$LN843@eval:

; 4192 :               case FACET: set_facet_density(q_id,density); break;

	mov	eax, DWORD PTR _q_id$[ebp]
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+32]
	jmp	$LN1707@eval
$LN844@eval:

; 4191 :             { case EDGE: set_edge_density(q_id,density); break;

	mov	eax, DWORD PTR _q_id$[ebp]
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+40]
	jmp	$LN1707@eval
$LN841@eval:

; 4194 :             }
; 4195 :          /* go back to next element generator */
; 4196 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4197 :         }
; 4198 :       break;
; 4199 : 
; 4200 :       case SET_VOLUME_NODE: 
; 4201 :       { REAL v = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]

; 4202 :         if ( get_attr(q_id) & PRESSURE )

	mov	ecx, DWORD PTR _q_id$[ebp]
	add	eax, -8					; fffffff8H
	fstp	QWORD PTR _v$91703[ebp]
	mov	DWORD PTR [ebx+48], eax
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	shl	edx, 4
	mov	eax, DWORD PTR _web[edx+12]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2048				; 00000800H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN840@eval

; 4203 :         { sprintf(errmsg,"Must unset body pressure before fixing target.\n");

	push	OFFSET ??_C@_0DA@GLPHHFLM@Must?5unset?5body?5pressure?5before?5@
	push	OFFSET _errmsg
	call	_sprintf

; 4204 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4205 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL2851@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2851@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4206 :           kb_error(2071,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2071					; 00000817H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN840@eval:

; 4207 :         }
; 4208 :         set_attr(q_id,FIXEDVOL);

	mov	esi, DWORD PTR _q_id$[ebp]
	push	0
	push	32					; 00000020H
	push	esi
	call	_set_attr

; 4209 :         set_body_fixvol(q_id,v); 

	fld	QWORD PTR _v$91703[ebp]
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	esi
	call	_set_body_fixvol
	add	esp, 12					; 0000000cH

; 4210 :          /* go back to next element generator */
; 4211 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4212 :         break;

	jmp	$LN1707@eval
$LN839@eval:

; 4213 :       }
; 4214 : 
; 4215 :       case SET_PRESSURE_NODE: 
; 4216 :       { REAL p = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	fstp	QWORD PTR _p$91711[ebp]

; 4217 :         if ( get_attr(q_id) & FIXEDVOL )

	mov	eax, DWORD PTR _q_id$[ebp]
	mov	esi, eax
	shr	eax, 29					; 0000001dH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	and	esi, 134217727				; 07ffffffH
	shl	ecx, 4
	mov	edx, DWORD PTR _web[ecx+12]
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [edx+esi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN838@eval

; 4218 :         { sprintf(errmsg,"Must unset body target before fixing pressure.\n");

	push	OFFSET ??_C@_0DA@ILOKBJND@Must?5unset?5body?5target?5before?5fi@
	push	OFFSET _errmsg
	call	_sprintf

; 4219 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4220 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL2852@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2852@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4221 :           kb_error(2521,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2521					; 000009d9H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN838@eval:

; 4222 :         }
; 4223 :         set_attr(q_id,PRESSURE);

	mov	edi, DWORD PTR _q_id$[ebp]
	push	0
	push	2048					; 00000800H
	push	edi
	call	_set_attr

; 4224 :         set_body_pressure(q_id,p); 

	fld	QWORD PTR _p$91711[ebp]
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	edi
	call	_set_body_pressure
	add	esp, 12					; 0000000cH

; 4225 :         if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN1760@eval

; 4226 :         { struct gen_quant *q = GEN_QUANT(get_body_volquant(q_id));

	mov	eax, DWORD PTR _web+348

; 4227 :           q->modulus = -p;

	fld	QWORD PTR _p$91711[ebp]
	mov	ecx, DWORD PTR [esi+eax]
	fchs
	mov	eax, DWORD PTR [ecx+404]
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list
	fstp	QWORD PTR [eax+176]

; 4228 :           if ( !(q->flags & Q_ENERGY) )

	mov	ecx, DWORD PTR [eax+136]
	test	cl, 1
	jne	$LN1760@eval

; 4229 :           { q->flags &= ~(Q_INFO|Q_FIXED|Q_CONSERVED);

	and	ecx, -15				; fffffff1H

; 4230 :             q->flags |= Q_ENERGY;

	or	ecx, 1
	mov	DWORD PTR [eax+136], ecx

; 4231 :           }
; 4232 :         }
; 4233 :          /* go back to next element generator */
; 4234 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4235 :         break;

	jmp	$LN1760@eval
$LN835@eval:

; 4236 :       }
; 4237 : 
; 4238 :       case SET_OPACITY_NODE:
; 4239 :         facet_alpha = *(stacktop)--;

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	fstp	QWORD PTR _facet_alpha
	add	DWORD PTR [ebx+48], -8			; fffffff8H

; 4240 :          /* go back to next element generator */
; 4241 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4242 :         break;

	jmp	$LN1760@eval
$LN834@eval:

; 4243 : 
; 4244 :       case SET_CONSTRAINT_NODE: 
; 4245 :       case SET_CONSTRAINT_NAME_NODE:
; 4246 :        { int con = (node->type==SET_CONSTRAINT_NODE) ? (int)*(stacktop--)
; 4247 :                 : node->op3.connum;

	cmp	edx, 10305				; 00002841H
	jne	SHORT $LN2277@eval
	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	mov	edi, eax
	mov	DWORD PTR [ebx+48], esi
	jmp	SHORT $LN2278@eval
$LN2277@eval:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR [ecx+140]
$LN2278@eval:

; 4248 :          if ( (con<0) || (con>=web.maxcon) || !(get_constraint(con)->attr & IN_USE))

	test	edi, edi
	js	SHORT $LN832@eval
	cmp	edi, DWORD PTR _web+644
	jge	SHORT $LN832@eval
	mov	edx, DWORD PTR _web+652
	mov	eax, edi
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	mov	eax, DWORD PTR [eax+edx+32]
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN833@eval
$LN832@eval:

; 4249 :          { sprintf(errmsg,"Illegal constraint number: %d.\n",con);

	push	edi
	push	OFFSET ??_C@_0CA@KOHHCGIN@Illegal?5constraint?5number?3?5?$CFd?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4250 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4251 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
	npad	7
$LL2853@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2853@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4252 :            kb_error(1295,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1295					; 0000050fH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN833@eval:

; 4253 :          }
; 4254 :          if ( get_attr(q_id) & BOUNDARY )

	mov	esi, DWORD PTR _q_id$[ebp]
	mov	eax, esi
	shr	eax, 29					; 0000001dH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	shl	edx, 4
	mov	eax, DWORD PTR _web[edx+12]
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	$LN831@eval

; 4255 :          { sprintf(errmsg,
; 4256 :              "Cannot set %s %s on a constraint since it is on a boundary.\n",
; 4257 :                 typenames[node->op2.eltype],ELNAME(q_id));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN2279@eval
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN2280@eval
$LN2279@eval:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN2280@eval:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	push	eax
	mov	eax, DWORD PTR _typenames[edx*4]
	push	eax
	push	OFFSET ??_C@_0DN@PDLOKPJK@Cannot?5set?5?$CFs?5?$CFs?5on?5a?5constraint@
	push	OFFSET _errmsg
	call	_sprintf

; 4258 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4259 :                  file_names[node->file_no],node->line_no); 

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	esi, DWORD PTR [eax+1]
$LL2854@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2854@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4260 :            kb_error(4002,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4002					; 00000fa2H
	call	_kb_error
	mov	esi, DWORD PTR _q_id$[ebp]
	add	esp, 28					; 0000001cH
$LN831@eval:

; 4261 :          }
; 4262 :          switch ( node->op2.eltype )

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	sub	eax, 0
	je	SHORT $LN828@eval
	dec	eax
	je	SHORT $LN827@eval
	dec	eax
	jne	$LN1707@eval

; 4267 :               case FACET: set_f_constraint_map(q_id,con); break;

	push	edi
	push	esi
	call	_set_f_constraint_map
	add	esp, 8
	jmp	$LN1707@eval
$LN827@eval:

; 4265 :                            break;
; 4266 :               case EDGE: set_e_constraint_map(q_id,con); break;

	push	edi
	push	esi
	call	_set_e_constraint_map
	add	esp, 8
	jmp	$LN1707@eval
$LN828@eval:

; 4263 :             { case VERTEX: set_v_constraint_map(q_id,con);

	push	edi
	push	esi
	call	_set_v_constraint_map

; 4264 :                            project_v_constr(q_id,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	push	1
	push	1
	push	esi
	call	_project_v_constr
	add	esp, 20					; 00000014H

; 4268 :             }
; 4269 :          /* go back to next element generator */
; 4270 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4271 :        }
; 4272 :        break;

	jmp	$LN1707@eval
$LN825@eval:

; 4273 : 
; 4274 :       case SET_NAMED_QUANTITY_NODE:
; 4275 :        { int qnum = (int)*(stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 4276 :          apply_quantity(q_id,qnum);

	push	eax
	mov	eax, DWORD PTR _q_id$[ebp]
	add	esi, -8					; fffffff8H
	push	eax
	mov	DWORD PTR [ebx+48], esi
	call	_apply_quantity
	add	esp, 8

; 4277 :          /* go back to next element generator */
; 4278 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4279 :         }
; 4280 :         break;

	jmp	$LN1707@eval
$LN824@eval:

; 4281 : 
; 4282 :       case UNSET_NAMED_QUANTITY_NODE:
; 4283 :        { int qnum = (int)*(stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 4284 :          unapply_quantity(q_id,qnum);

	push	eax
	mov	eax, DWORD PTR _q_id$[ebp]
	add	esi, -8					; fffffff8H
	push	eax
	mov	DWORD PTR [ebx+48], esi
	call	_unapply_quantity
	add	esp, 8

; 4285 :          /* go back to next element generator */
; 4286 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4287 :        }
; 4288 :        break;

	jmp	$LN1707@eval
$LN823@eval:

; 4289 : 
; 4290 :       case SET_METHOD_INSTANCE_NODE:
; 4291 :        { int qnum = (int)*(stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 4292 :          apply_method_num(q_id,qnum);

	push	eax
	mov	eax, DWORD PTR _q_id$[ebp]
	add	esi, -8					; fffffff8H
	push	eax
	mov	DWORD PTR [ebx+48], esi
	call	_apply_method_num
	add	esp, 8

; 4293 :          /* go back to next element generator */
; 4294 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4295 :        }
; 4296 :        break;

	jmp	$LN1707@eval
$LN822@eval:

; 4297 : 
; 4298 :       case UNSET_METHOD_INSTANCE_NODE:
; 4299 :        { int qnum = (int)*(stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 4300 :          unapply_method(q_id,qnum);

	push	eax
	mov	eax, DWORD PTR _q_id$[ebp]
	add	esi, -8					; fffffff8H
	push	eax
	mov	DWORD PTR [ebx+48], esi
	call	_unapply_method
	add	esp, 8

; 4301 :          /* go back to next element generator */
; 4302 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4303 :        }
; 4304 :        break;

	jmp	$LN1707@eval
$LN821@eval:

; 4305 : 
; 4306 :       case SET_COLOR_NODE:
; 4307 :        { int color = (int)*(stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], esi

; 4308 :          switch ( node->op2.eltype )

	mov	ecx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [ecx+136]
	dec	ecx
	je	SHORT $LN818@eval
	dec	ecx
	jne	SHORT $LN819@eval

; 4310 :               case FACET: set_facet_color(q_id,color); break;

	mov	ecx, DWORD PTR _q_id$[ebp]
	mov	edx, DWORD PTR _web+236
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [ecx+edx]
	mov	WORD PTR [edx+50], ax
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ecx+edx]
	mov	WORD PTR [ecx+48], ax
	jmp	SHORT $LN819@eval
$LN818@eval:

; 4309 :             { case EDGE: set_edge_color(q_id,color); break;

	mov	edx, DWORD PTR _q_id$[ebp]
	mov	ecx, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	WORD PTR [edx+56], ax
$LN819@eval:

; 4311 :             }
; 4312 :          /* go back to next element generator */
; 4313 :          node += node->op1.skipsize - 1;  /* back to start of loop */

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 168				; 000000a8H
	lea	edx, DWORD PTR [eax+ecx-168]
	mov	DWORD PTR _node$[ebp], edx

; 4314 :          update_display_flag = 1;

	mov	DWORD PTR _update_display_flag$[ebp], 1

; 4315 :        }
; 4316 :        break;

	jmp	$LN1980@eval
$LN816@eval:

; 4317 : 
; 4318 :       case SET_FRONTCOLOR_NODE:
; 4319 :       { int color = (int)*(stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 4320 :          set_facet_frontcolor(q_id,color);

	mov	ecx, DWORD PTR _q_id$[ebp]
	add	esi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], esi
	mov	edx, DWORD PTR _web+236
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN2281@eval
$LN2283@eval:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	WORD PTR [ecx+50], ax
	jmp	SHORT $LN2282@eval
$LN2281@eval:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	WORD PTR [ecx+48], ax
$LN2282@eval:

; 4321 :          /* go back to next element generator */
; 4322 :          node += node->op1.skipsize - 1;  /* back to start of loop */

	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+32]
	imul	edx, 168				; 000000a8H
	lea	eax, DWORD PTR [eax+edx-168]
	mov	DWORD PTR _node$[ebp], eax

; 4323 :          update_display_flag = 1;

	mov	DWORD PTR _update_display_flag$[ebp], 1

; 4324 :         }
; 4325 :         break;

	jmp	$LN1980@eval
$LN815@eval:

; 4326 : 
; 4327 :       case SET_BACKCOLOR_NODE:
; 4328 :       { int color = (int)*(stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 4329 :          set_facet_backcolor(q_id,color);

	mov	ecx, DWORD PTR _q_id$[ebp]
	add	esi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], esi
	mov	edx, DWORD PTR _web+236
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN2283@eval
	jmp	SHORT $LN2281@eval
$LN814@eval:

; 4330 :          /* go back to next element generator */
; 4331 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4332 :          update_display_flag = 1;
; 4333 :         }
; 4334 :         break;
; 4335 : 
; 4336 :       case SET_COORD_NODE:
; 4337 :       case SET_COORD_1_NODE:  // Listing all cases here for node_extract
; 4338 :       case SET_COORD_2_NODE:
; 4339 :       case SET_COORD_3_NODE:
; 4340 :       case SET_COORD_4_NODE:
; 4341 :       case SET_COORD_5_NODE:
; 4342 :       case SET_COORD_6_NODE:
; 4343 :       case SET_COORD_7_NODE:
; 4344 :       case SET_COORD_8_NODE:
; 4345 :       case SET_COORD_9_NODE:
; 4346 :       case SET_COORD_10_NODE:
; 4347 :          get_coord(q_id)[node->op2.coordnum] = *(stacktop--);

	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR _q_id$[ebp]
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+esi+64]
	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	fstp	QWORD PTR [edx+eax*8]

; 4348 :          if ( node->op2.coordnum <= SDIM ) recalc_flag = 1;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	cmp	ecx, DWORD PTR _web+616
	jg	$LN813@eval
	mov	DWORD PTR _recalc_flag$[ebp], 1

; 4349 :          /* go back to next element generator */
; 4350 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4351 :         break;

	jmp	$LN813@eval
$LN812@eval:

; 4352 : 
; 4353 :       case SET_PARAM_NODE:
; 4354 :       case SET_PARAM_1_NODE:
; 4355 :       case SET_PARAM_2_NODE:
; 4356 :       case SET_PARAM_3_NODE:
; 4357 :       case SET_PARAM_4_NODE:
; 4358 :       case SET_PARAM_5_NODE:
; 4359 :       case SET_PARAM_6_NODE:
; 4360 :       case SET_PARAM_7_NODE:
; 4361 :       case SET_PARAM_8_NODE:
; 4362 :        if ( get_vattr(q_id) & BOUNDARY )

	mov	ecx, DWORD PTR _q_id$[ebp]
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	xor	edx, edx
	or	ecx, edx
	je	$LN811@eval

; 4363 :           { struct boundary *boundary = get_boundary(q_id);

	mov	esi, DWORD PTR _V_BOUNDARY_ATTR
	mov	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	test	esi, esi
	je	SHORT $LN2285@eval
	imul	esi, 240				; 000000f0H
	add	esi, edx
	mov	esi, DWORD PTR [esi+ecx+64]
	mov	edi, DWORD PTR [esi+eax]
	imul	edi, 136				; 00000088H
	add	edi, DWORD PTR _web+776
	jmp	SHORT $LN2286@eval
$LN2285@eval:
	xor	edi, edi
$LN2286@eval:

; 4364 :              REAL *param = get_param(q_id);

	mov	esi, DWORD PTR [edx+ecx+544]

; 4365 :              REAL *xx = get_coord(q_id);

	mov	ecx, DWORD PTR [edx+ecx+64]
	add	ecx, eax
	add	esi, eax

; 4366 :              if ( node->op2.coordnum > boundary->pcount )

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+136]
	mov	DWORD PTR _xx$91808[ebp], ecx
	mov	ecx, DWORD PTR [edi+40]
	mov	DWORD PTR _param$91803[ebp], esi
	cmp	eax, ecx
	jle	SHORT $LN810@eval

; 4367 :              { sprintf(errmsg,"Parameter number is %d; maximum is %d.\n",
; 4368 :                  node->op2.coordnum,boundary->pcount); 

	push	ecx
	push	eax
	push	OFFSET ??_C@_0CI@EMPMINAB@Parameter?5number?5is?5?$CFd?$DL?5maximum?5@
	push	OFFSET _errmsg
	call	_sprintf

; 4369 :                sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4370 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL2855@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2855@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4371 :                kb_error(1296,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1296					; 00000510H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN810@eval:

; 4372 :              }
; 4373 :              param[node->op2.coordnum] = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR _node$[ebp]
	fld	QWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+136]
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	fstp	QWORD PTR [esi+edx*8]

; 4374 :              PROF_EVAL_END(ex_profiling);
; 4375 :              PUSH_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	cmp	eax, 100				; 00000064H
	jl	SHORT $LN809@eval
	xor	eax, eax
$LN809@eval:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _eval_stack_trace[eax*4], ecx
	inc	eax

; 4376 :              for ( k = 0 ; k < SDIM ; k++ )

	xor	esi, esi
	mov	DWORD PTR _eval_stack_trace_spot, eax
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN806@eval

; 4374 :              PROF_EVAL_END(ex_profiling);
; 4375 :              PUSH_TRACE;

	add	edi, 48					; 00000030H
	npad	4
$LL808@eval:

; 4377 :                xx[k] = eval(boundary->coordf[k],param,q_id,NULL);

	mov	edx, DWORD PTR _q_id$[ebp]
	mov	eax, DWORD PTR _param$91803[ebp]
	mov	ecx, DWORD PTR [edi]
	push	0
	push	edx
	push	eax
	push	ecx
	call	_eval
	mov	edx, DWORD PTR _xx$91808[ebp]
	fstp	QWORD PTR [edx+esi*8]
	inc	esi
	add	esp, 16					; 00000010H
	add	edi, 4
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL808@eval
$LN806@eval:

; 4378 :              POP_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	test	eax, eax
	jle	SHORT $LN805@eval
	mov	DWORD PTR _eval_stack_trace[eax*4], 0
	dec	eax
	mov	DWORD PTR _eval_stack_trace_spot, eax
$LN805@eval:

; 4379 :              PROF_EVAL_START(ex_profiling);
; 4380 :              recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], 1

; 4381 :           }
; 4382 :          else

	jmp	$LN1707@eval
$LN811@eval:

; 4383 :           { /* probably just handy for storage */
; 4384 :              REAL *param = get_param(q_id);

	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+edx+544]

; 4385 :              param[node->op2.coordnum] = *(stacktop--);

	mov	edx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [edx+136]
	add	ecx, eax
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	fstp	QWORD PTR [ecx+edx*8]

; 4386 :           }
; 4387 :          /* go back to next element generator */
; 4388 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4389 :         break;

	jmp	$LN1707@eval
$LN803@eval:

; 4390 : 
; 4391 :       case SET_EXTRA_ATTR_NODE:
; 4392 :       case SET_FRONTBODY_NODE:
; 4393 :       case SET_BACKBODY_NODE:
; 4394 :       case SET_ORIGINAL_NODE:
; 4395 :       case SET_ORIENTATION_NODE:
; 4396 :        sprintf(errmsg,"Internal error; SET node %d reached unexpectedly.\n",node->type);

	push	edx
	push	OFFSET ??_C@_0DD@IDPGEBFJ@Internal?5error?$DL?5SET?5node?5?$CFd?5reac@
	push	OFFSET _errmsg
	call	_sprintf

; 4397 :        sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4398 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
$LL2856@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2856@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4399 :        kb_error(5387,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5387					; 0000150bH
	call	_kb_error
	add	esp, 28					; 0000001cH

; 4400 :        break;

	jmp	$LN1980@eval
$LN802@eval:

; 4401 : 
; 4402 :         /************************/
; 4403 :         /* numerical aggregates */
; 4404 :         /************************/
; 4405 : 
; 4406 : 
; 4407 :       case MAX_NODE: 
; 4408 :        { REAL *aggrptr;
; 4409 : 
; 4410 :          val = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	lea	ecx, DWORD PTR [eax-8]

; 4411 :          aggrptr = (REAL *)(stacktop - 3);
; 4412 :          if ( val > *aggrptr ) *aggrptr = val;

	fcom	QWORD PTR [ecx-24]
	mov	DWORD PTR [ebx+48], ecx
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN3315@eval
	fstp	QWORD PTR [ecx-24]
	jmp	$LN1707@eval
$LN800@eval:

; 4413 :          /* go back to next element generator */
; 4414 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4415 :        }
; 4416 :        break;
; 4417 : 
; 4418 :       case MIN_NODE: 
; 4419 :        {
; 4420 :          REAL *aggrptr;
; 4421 : 
; 4422 :          val = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	lea	ecx, DWORD PTR [eax-8]

; 4423 :          aggrptr = (REAL *)(stacktop - 3);
; 4424 :          if ( val < *aggrptr ) *aggrptr = val;

	fcom	QWORD PTR [ecx-24]
	mov	DWORD PTR [ebx+48], ecx
	fnstsw	ax
	test	ah, 5
	jp	$LN3315@eval
	fstp	QWORD PTR [ecx-24]
	jmp	$LN1707@eval
$LN798@eval:

; 4425 :          /* go back to next element generator */
; 4426 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4427 :        }
; 4428 :        break;
; 4429 : 
; 4430 :       case SUM_NODE: 
; 4431 :          stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	eax, DWORD PTR [ebx+48]

; 4432 :          stacktop[-3] += stacktop[1];

	fld	QWORD PTR [eax+8]
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]

; 4433 :          /* go back to next element generator */
; 4434 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4435 :          break;

	jmp	$LN1707@eval
$LN797@eval:

; 4436 : 
; 4437 :       case AVG_NODE: 
; 4438 :          stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	eax, DWORD PTR [ebx+48]

; 4439 :          stacktop[-3] += stacktop[1]; /* sum */

	fld	QWORD PTR [eax+8]
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]

; 4440 :          stacktop[-4] += 1.0; /* count */

	fld	QWORD PTR [eax-32]
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [eax-32]

; 4441 :          /* go back to next element generator */
; 4442 :          node += node->op1.skipsize - 1;  /* back to start of loop */
; 4443 :          break;

	jmp	$LN1707@eval
$LN796@eval:

; 4444 : 
; 4445 :       case COUNT_NODE: 
; 4446 :           stacktop--;

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	eax, DWORD PTR [ebx+48]

; 4447 :           stacktop[-3] += 1.0;

	fld	QWORD PTR [eax-24]
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [eax-24]

; 4448 :             /* go back to next element generator */
; 4449 :               node += node->op1.skipsize - 1;  /* back to start of loop */
; 4450 :           break;

	jmp	$LN1707@eval
$LN795@eval:

; 4451 : 
; 4452 :       case HISTOGRAM_NODE:   
; 4453 :       case LOGHISTOGRAM_NODE:
; 4454 :           if ( histo_count >= histo_max )

	mov	eax, DWORD PTR _histo_count$[ebp]
	cmp	eax, DWORD PTR _histo_max$[ebp]
	jl	SHORT $LN794@eval

; 4455 :           { histo_data = (REAL*)temp_realloc((char*)histo_data,
; 4456 :                   2*histo_max*sizeof(REAL));

	mov	esi, DWORD PTR _histo_max$[ebp]
	mov	edx, DWORD PTR _histo_data$[ebp]
	push	4456					; 00001168H
	mov	ecx, esi
	push	OFFSET ??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@
	shl	ecx, 4
	push	ecx
	push	edx
	call	_kb_temp_realloc
	mov	DWORD PTR _histo_data$[ebp], eax

; 4457 :             histo_max *= 2;

	lea	eax, DWORD PTR [esi+esi]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _histo_max$[ebp], eax
$LN794@eval:

; 4458 :           }
; 4459 :           histo_data[histo_count++] = *(stacktop--);

	mov	ecx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR _histo_count$[ebp]
	fld	QWORD PTR [ecx]
	mov	edx, DWORD PTR _histo_data$[ebp]
	fstp	QWORD PTR [edx+eax*8]
	inc	eax
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	mov	DWORD PTR _histo_count$[ebp], eax

; 4460 :           node += node->op1.skipsize - 1;  /* back to start of loop */
; 4461 :         break;

	jmp	$LN1707@eval
$LN791@eval:

; 4462 : 
; 4463 :       case FOREACH_NODE:
; 4464 :       case SET_ATTRIBUTE_LOOP_NODE:
; 4465 :         node += node->op1.skipsize - 1;  /* back to start of loop */
; 4466 :         break;
; 4467 : 
; 4468 :       case ARRAY_HEAD_NODE: break;  /* let indices accumulate */
; 4469 : 
; 4470 :       case ARRAYASSIGN_NODE: 
; 4471 :       { struct array *a;
; 4472 :         REAL value=0.0,rhs;
; 4473 :         int i,offset;
; 4474 :         void *lvalue;
; 4475 :         struct global *g = globals(node->op2.name_id);

	mov	eax, DWORD PTR _node$[ebp]
	fldz
	mov	eax, DWORD PTR [eax+136]
	fstp	QWORD PTR _value$91850[ebp]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN2287@eval
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2289@eval
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	ecx, DWORD PTR _localbase$[ebp]
	shl	edx, 5
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _g$91855[ebp], edx
	jmp	SHORT $LN2288@eval
$LN2289@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2287@eval
	mov	ecx, DWORD PTR _web+5656
	mov	edx, eax
	and	edx, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _g$91855[ebp], edx
	jmp	SHORT $LN2288@eval
$LN2287@eval:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _g$91855[ebp], ecx
$LN2288@eval:

; 4476 :  
; 4477 :         a = get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	edx, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	push	edx
	mov	edx, DWORD PTR _localstack$[ebp]
	lea	ecx, DWORD PTR [ecx+edx*8]
	push	ecx
	push	eax
	call	_get_name_arrayptr
	mov	ecx, eax

; 4478 : 
; 4479 :         rhs = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	fst	QWORD PTR _rhs$91851[ebp]

; 4480 :         for ( i = 0 ; i < a->dim ; i++ )

	mov	eax, DWORD PTR [ecx+4]
	add	esp, 12					; 0000000cH
	xor	edi, edi
	mov	DWORD PTR _a$91849[ebp], ecx
	test	eax, eax
	jle	$LN788@eval

; 4476 :  
; 4477 :         a = get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	add	ecx, 24					; 00000018H
	mov	DWORD PTR tv27733[ebp], ecx
$LN790@eval:

; 4481 :         { int k = (int)stacktop[i+1-a->dim];

	mov	edx, edi
	sub	edx, eax
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax+edx*8+8]
	call	__ftol2_sse
	mov	esi, eax

; 4482 :           if ( k < 1 )

	cmp	esi, 1
	jge	$LN787@eval

; 4483 :           { sprintf(errmsg,
; 4484 :              "Array index %d of array %s is %d. Indexes start at 1.\n",
; 4485 :                i+1,g->name,k);

	mov	ecx, DWORD PTR _g$91855[ebp]
	fstp	ST(0)
	push	esi
	push	ecx
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	OFFSET ??_C@_0DH@DOJNKOOH@Array?5index?5?$CFd?5of?5array?5?$CFs?5is?5?$CFd@
	push	OFFSET _errmsg
	call	_sprintf

; 4486 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4487 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR [eax+1]
$LL2857@eval:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL2857@eval
	sub	eax, ecx
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4488 :             kb_error(3011,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3011					; 00000bc3H
	call	_kb_error
	fld	QWORD PTR _rhs$91851[ebp]
	add	esp, 28					; 0000001cH
$LN787@eval:

; 4489 :           }
; 4490 :           if ( k > a->sizes[i] && (!(node->flags & IS_VIRTUAL_ATTR) ||(k > SDIM)) )

	mov	eax, DWORD PTR tv27733[ebp]
	mov	eax, DWORD PTR [eax]
	cmp	esi, eax
	jle	$LN789@eval
	mov	ecx, DWORD PTR _node$[ebp]
	test	DWORD PTR [ecx+24], 65536		; 00010000H
	je	SHORT $LN3336@eval
	cmp	esi, DWORD PTR _web+616
	jle	$LN789@eval
$LN3336@eval:

; 4491 :           { sprintf(errmsg,"Array index %d of array %s is %d; exceeds bound of %d.\n",
; 4492 :                i+1,g->name,k,a->sizes[i]);

	mov	edx, DWORD PTR _g$91855[ebp]
	fstp	ST(0)
	push	eax
	push	esi
	push	edx
	lea	eax, DWORD PTR [edi+1]
	push	eax
	push	OFFSET ??_C@_0DI@KHNAHFIG@Array?5index?5?$CFd?5of?5array?5?$CFs?5is?5?$CFd@
	push	OFFSET _errmsg
	call	_sprintf

; 4493 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4494 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 24					; 00000018H
	lea	esi, DWORD PTR [eax+1]
$LL2858@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2858@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4495 :             kb_error(3012,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3012					; 00000bc4H
	call	_kb_error
	fld	QWORD PTR _rhs$91851[ebp]
	add	esp, 28					; 0000001cH
$LN789@eval:

; 4480 :         for ( i = 0 ; i < a->dim ; i++ )

	mov	eax, DWORD PTR _a$91849[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	DWORD PTR tv27733[ebp], 4
	inc	edi
	cmp	edi, eax
	jl	$LN790@eval
$LN788@eval:

; 4496 :           }
; 4497 :         }
; 4498 :         for ( i = 1, offset = (int)stacktop[1-a->dim]-1 ; i < a->dim ; i++ )

	mov	ecx, DWORD PTR _a$91849[ebp]
	mov	edi, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ebx+48]
	lea	edx, DWORD PTR [edi*8]
	sub	esi, edx
	fld	QWORD PTR [esi+8]
	mov	DWORD PTR tv19976[ebp], esi
	call	__ftol2_sse
	dec	eax
	cmp	edi, 1
	jle	SHORT $LN3105@eval
	mov	ecx, DWORD PTR _a$91849[ebp]
	mov	esi, DWORD PTR [ebx+48]
	mov	edx, 2
	add	ecx, 28					; 0000001cH
	sub	edx, edi
	dec	edi
	mov	DWORD PTR tv27808[ebp], ecx
	lea	esi, DWORD PTR [esi+edx*8]
	mov	DWORD PTR tv17012[ebp], edi
$LN784@eval:

; 4499 :         { offset *= a->sizes[i];

	mov	ecx, DWORD PTR tv27808[ebp]

; 4500 :           offset += (int)stacktop[i+1-a->dim]-1;  /* 1-based indexing */

	fld	QWORD PTR [esi]
	mov	edi, DWORD PTR [ecx]
	imul	edi, eax
	call	__ftol2_sse
	add	DWORD PTR tv27808[ebp], 4
	add	esi, 8
	dec	DWORD PTR tv17012[ebp]
	lea	eax, DWORD PTR [edi+eax-1]
	jne	SHORT $LN784@eval

; 4496 :           }
; 4497 :         }
; 4498 :         for ( i = 1, offset = (int)stacktop[1-a->dim]-1 ; i < a->dim ; i++ )

	mov	esi, DWORD PTR tv19976[ebp]
$LN3105@eval:
	mov	edi, DWORD PTR _a$91849[ebp]

; 4501 :         }
; 4502 :         stacktop -= a->dim;

	mov	DWORD PTR [ebx+48], esi

; 4503 :         lvalue = ((char *)a) + a->datastart + offset*a->itemsize;

	mov	esi, DWORD PTR [edi+12]
	imul	esi, eax
	add	esi, DWORD PTR [edi+20]

; 4504 :         switch ( a->datatype )

	mov	eax, DWORD PTR [edi+8]
	dec	eax
	add	esi, edi
	cmp	eax, 17					; 00000011H
	ja	SHORT $LN778@eval
	jmp	DWORD PTR $LN4038@eval[eax*4]
$LN779@eval:

; 4505 :         { case REAL_TYPE: value = *(REAL*)(lvalue);  break;

	fld	QWORD PTR [esi]
	fst	QWORD PTR _value$91850[ebp]
	jmp	$LN780@eval
$LN778@eval:

; 4506 :           case INTEGER_TYPE: value = *(int*)(lvalue); break;

	fild	DWORD PTR [esi]
	fst	QWORD PTR _value$91850[ebp]
	jmp	$LN780@eval
$LN777@eval:

; 4507 :           case UINT_TYPE: value = *(unsigned int*)(lvalue); break;

	mov	edx, DWORD PTR [esi]
	fild	DWORD PTR [esi]
	test	edx, edx
	jns	SHORT $LN3936@eval
	fadd	QWORD PTR __real@41f0000000000000
$LN3936@eval:
	fst	QWORD PTR _value$91850[ebp]
	jmp	$LN780@eval
$LN776@eval:

; 4508 :           case SHORT_TYPE: value = *(short int*)(lvalue); break;

	movsx	eax, WORD PTR [esi]
	mov	DWORD PTR tv25903[ebp], eax
	fild	DWORD PTR tv25903[ebp]
	fst	QWORD PTR _value$91850[ebp]
	jmp	SHORT $LN780@eval
$LN775@eval:

; 4509 :           case USHORT_TYPE: value = *(unsigned short int*)(lvalue); break;

	movzx	ecx, WORD PTR [esi]
	mov	DWORD PTR tv25902[ebp], ecx
	fild	DWORD PTR tv25902[ebp]
	fst	QWORD PTR _value$91850[ebp]
	jmp	SHORT $LN780@eval
$LN772@eval:

; 4510 :           case LONG_TYPE: value = *(long int*)(lvalue); break;
; 4511 :           case ULONG_TYPE: value = *(unsigned long int*)(lvalue); break;
; 4512 :           case CHAR_TYPE: value = *(char*)(lvalue); break;

	movsx	eax, BYTE PTR [esi]
	mov	DWORD PTR tv25897[ebp], eax
	fild	DWORD PTR tv25897[ebp]
	fst	QWORD PTR _value$91850[ebp]
	jmp	SHORT $LN780@eval
$LN771@eval:

; 4513 :           case UCHAR_TYPE: value = *(unsigned char*)(lvalue); break;

	movzx	ecx, BYTE PTR [esi]
	mov	DWORD PTR tv25896[ebp], ecx
	fild	DWORD PTR tv25896[ebp]
	fst	QWORD PTR _value$91850[ebp]
	jmp	SHORT $LN780@eval
$LN2990@eval:

; 4514 :           case PTR_TYPE: value = (unsigned long int)*(char**)(lvalue); break;
; 4515 :           case VERTEX_TYPE:
; 4516 :           case EDGE_TYPE:
; 4517 :           case FACET_TYPE:
; 4518 :           case BODY_TYPE:
; 4519 :           case FACETEDGE_TYPE:
; 4520 :           case ELEMENTID_TYPE:  break;
; 4521 :           default: value = *(int*)(lvalue); break;

	fld	QWORD PTR _value$91850[ebp]
$LN780@eval:

; 4522 :         
; 4523 :         }
; 4524 :         switch ( node->op1.assigntype )

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	$LN3365@eval
	jmp	DWORD PTR $LN4039@eval[eax*4]
$LN3370@eval:
	fstp	ST(0)

; 4525 :         {
; 4526 :           case ASSIGN_OP:  value = rhs;  break;

	jmp	$LN766@eval
$LN764@eval:

; 4527 :           case PLUSASSIGN_OP: value += rhs; break;

	faddp	ST(1), ST(0)
	jmp	$LN766@eval
$LN763@eval:

; 4528 :           case SUBASSIGN_OP: value -= rhs;   break;

	fsubrp	ST(1), ST(0)
	jmp	$LN766@eval
$LN762@eval:

; 4529 :           case MULTASSIGN_OP: value *= rhs; break;

	fmulp	ST(1), ST(0)
	jmp	$LN766@eval
$LN761@eval:

; 4530 :           case DIVASSIGN_OP:
; 4531 :             if( rhs == 0.0 )

	fld	ST(1)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN760@eval

; 4532 :             { sprintf(errmsg,"Division by zero.\n");

	push	OFFSET ??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@
	fstp	ST(0)
	push	OFFSET _errmsg
	fstp	ST(0)
	call	_sprintf

; 4533 :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4534 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL2859@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2859@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4535 :               kb_error(3015,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3015					; 00000bc7H
	call	_kb_error
	fld	QWORD PTR _rhs$91851[ebp]
	fld	QWORD PTR _value$91850[ebp]
	add	esp, 28					; 0000001cH
$LN760@eval:

; 4536 :             }
; 4537 :             value /= rhs;  break;

	fdivrp	ST(1), ST(0)
	jmp	SHORT $LN766@eval
$LN3365@eval:

; 4522 :         
; 4523 :         }
; 4524 :         switch ( node->op1.assigntype )

	fstp	ST(1)
$LN766@eval:

; 4538 :         } 
; 4539 :         switch ( a->datatype )

	mov	eax, DWORD PTR [edi+8]
	dec	eax
	cmp	eax, 17					; 00000011H
	ja	SHORT $LN756@eval
	movzx	eax, BYTE PTR $LN2860@eval[eax]
	jmp	DWORD PTR $LN4040@eval[eax*4]
$LN757@eval:

; 4540 :         { case REAL_TYPE: *(REAL*)(lvalue) = value;    break;

	fstp	QWORD PTR [esi]
	jmp	$LN758@eval
$LN756@eval:

; 4541 :           case INTEGER_TYPE: *(int*)(lvalue) = (int)value; break;

	call	__ftol2_sse
	mov	DWORD PTR [esi], eax
	jmp	$LN758@eval
$LN755@eval:

; 4542 :           case UINT_TYPE: *(unsigned int*)(lvalue) = (unsigned int)value; break;

	fnstcw	WORD PTR tv25861[ebp]
	movzx	eax, WORD PTR tv25861[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv25858[ebp], eax
	fldcw	WORD PTR tv25858[ebp]
	fistp	QWORD PTR tv25856[ebp]
	mov	ecx, DWORD PTR tv25856[ebp]
	mov	DWORD PTR [esi], ecx
	fldcw	WORD PTR tv25861[ebp]
	jmp	$LN758@eval
$LN754@eval:

; 4543 :           case CHAR_TYPE: *(char*)(lvalue) = (char)value; break;

	call	__ftol2_sse
	mov	BYTE PTR [esi], al
	jmp	$LN758@eval
$LN753@eval:

; 4544 :           case UCHAR_TYPE: *(unsigned char*)(lvalue) = (unsigned char)value; break;

	fnstcw	WORD PTR tv25849[ebp]
	movzx	eax, WORD PTR tv25849[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv25846[ebp], eax
	fldcw	WORD PTR tv25846[ebp]
	fistp	DWORD PTR tv25844[ebp]
	mov	dl, BYTE PTR tv25844[ebp]
	mov	BYTE PTR [esi], dl
	fldcw	WORD PTR tv25849[ebp]
	jmp	$LN758@eval
$LN752@eval:

; 4545 :           case SHORT_TYPE: *(short*)(lvalue) = (short)value; break;

	call	__ftol2_sse
	mov	WORD PTR [esi], ax
	jmp	$LN758@eval
$LN751@eval:

; 4546 :           case USHORT_TYPE: *(unsigned short*)(lvalue) = (unsigned short)value; break;

	fnstcw	WORD PTR tv25837[ebp]
	movzx	eax, WORD PTR tv25837[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv25834[ebp], eax
	fldcw	WORD PTR tv25834[ebp]
	fistp	DWORD PTR tv25832[ebp]
	mov	ax, WORD PTR tv25832[ebp]
	mov	WORD PTR [esi], ax
	fldcw	WORD PTR tv25837[ebp]
	jmp	SHORT $LN758@eval
$LN749@eval:

; 4547 :           case LONG_TYPE: *(long*)(lvalue) = (long)value; break;
; 4548 :           case ULONG_TYPE: *(unsigned long*)(lvalue) = (unsigned long)value; break;

	fnstcw	WORD PTR tv25824[ebp]
	movzx	eax, WORD PTR tv25824[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv25821[ebp], eax
	fldcw	WORD PTR tv25821[ebp]
	fistp	QWORD PTR tv25819[ebp]
	mov	ecx, DWORD PTR tv25819[ebp]
	mov	DWORD PTR [esi], ecx
	fldcw	WORD PTR tv25824[ebp]
	jmp	SHORT $LN758@eval
$LN3375@eval:

; 4549 :           case VERTEX_TYPE:
; 4550 :           case EDGE_TYPE:
; 4551 :           case FACET_TYPE:
; 4552 :           case BODY_TYPE:
; 4553 :           case FACETEDGE_TYPE:
; 4554 :           case ELEMENTID_TYPE:  break;
; 4555 :           default: *(int*)(lvalue) = (int)value; break;

	fstp	ST(0)
$LN758@eval:

; 4556 :         
; 4557 :         }
; 4558 :         if ( g->flags & RECALC_PARAMETER )

	mov	edx, DWORD PTR _g$91855[ebp]
	test	BYTE PTR [edx+192], 8
	je	SHORT $LN746@eval

; 4559 :             recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], 1
$LN746@eval:

; 4560 :         if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'

	mov	eax, DWORD PTR _node$[ebp]
$LN599@eval:
	test	DWORD PTR [eax+24], 131072		; 00020000H
$LN4012@eval:
	je	$LN1980@eval

; 4561 :             dont_resize_flag = 1;

	mov	DWORD PTR _dont_resize_flag, 1

; 4562 : 
; 4563 :       }
; 4564 :       break;

	jmp	$LN1980@eval
$LN744@eval:

; 4565 : 
; 4566 : 
; 4567 :       case ARRAYEVAL_NODE:
; 4568 :       { 
; 4569 :         struct global *g = globals(node->op2.name_id);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+136]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN2297@eval
	mov	ecx, DWORD PTR _web+5652
	mov	edx, eax
	and	edx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _g$91950[ebp], edx
	jmp	$LN2294@eval
$LN2297@eval:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2295@eval
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	ecx, DWORD PTR _localbase$[ebp]
	shl	edx, 5
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _g$91950[ebp], edx
	jmp	SHORT $LN2294@eval
$LN2295@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2293@eval
	mov	ecx, DWORD PTR _web+5656
	mov	edx, eax
	and	edx, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _g$91950[ebp], edx
	jmp	SHORT $LN2294@eval
$LN2293@eval:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _g$91950[ebp], ecx
$LN2294@eval:

; 4570 :         struct array *a;
; 4571 :         REAL value=0.0;
; 4572 :         int i,offset;
; 4573 :         void *lvalue;
; 4574 :  
; 4575 :         a = get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	edx, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	push	edx
	mov	edx, DWORD PTR _localstack$[ebp]
	lea	ecx, DWORD PTR [ecx+edx*8]
	push	ecx
	push	eax
	call	_get_name_arrayptr
	mov	ecx, eax

; 4576 : 
; 4577 :         for ( i = 0 ; i < a->dim ; i++ )

	mov	eax, DWORD PTR [ecx+4]
	add	esp, 12					; 0000000cH
	xor	edi, edi
	mov	DWORD PTR _a$91953[ebp], ecx
	test	eax, eax
	jle	$LN741@eval

; 4570 :         struct array *a;
; 4571 :         REAL value=0.0;
; 4572 :         int i,offset;
; 4573 :         void *lvalue;
; 4574 :  
; 4575 :         a = get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	add	ecx, 24					; 00000018H
	mov	DWORD PTR tv27884[ebp], ecx
	npad	3
$LL743@eval:

; 4578 :         { int k = (int)stacktop[i+1-a->dim];

	mov	edx, edi
	sub	edx, eax
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax+edx*8+8]
	call	__ftol2_sse
	mov	esi, eax

; 4579 :           if ( k < 1 )

	cmp	esi, 1
	jge	$LN740@eval

; 4580 :           { sprintf(errmsg,
; 4581 :               "Array index %d of array %s is %d. Indexes start at 1.\n",
; 4582 :                i+1,g->name,k);

	mov	ecx, DWORD PTR _g$91950[ebp]
	push	esi
	push	ecx
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	OFFSET ??_C@_0DH@DOJNKOOH@Array?5index?5?$CFd?5of?5array?5?$CFs?5is?5?$CFd@
	push	OFFSET _errmsg
	call	_sprintf

; 4583 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4584 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR [eax+1]
$LL2861@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2861@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4585 :             kb_error(2047,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2047					; 000007ffH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN740@eval:

; 4586 :           }
; 4587 :           if ( k > a->sizes[i] )

	mov	eax, DWORD PTR tv27884[ebp]
	mov	eax, DWORD PTR [eax]
	cmp	esi, eax
	jle	$LN742@eval

; 4588 :           { sprintf(errmsg,
; 4589 :              "Array index %d of array %s is %d; exceeds bound of %d.\n",
; 4590 :                i+1,g->name,k,a->sizes[i]);

	mov	ecx, DWORD PTR _g$91950[ebp]
	push	eax
	push	esi
	push	ecx
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	OFFSET ??_C@_0DI@KHNAHFIG@Array?5index?5?$CFd?5of?5array?5?$CFs?5is?5?$CFd@
	push	OFFSET _errmsg
	call	_sprintf

; 4591 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4592 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 24					; 00000018H
	lea	esi, DWORD PTR [eax+1]
	npad	3
$LL2862@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2862@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4593 :             kb_error(2048,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2048					; 00000800H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN742@eval:

; 4576 : 
; 4577 :         for ( i = 0 ; i < a->dim ; i++ )

	mov	eax, DWORD PTR _a$91953[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	DWORD PTR tv27884[ebp], 4
	inc	edi
	cmp	edi, eax
	jl	$LL743@eval
$LN741@eval:

; 4594 :           }
; 4595 :         }
; 4596 :         for ( i = 1, offset = (int)stacktop[1-a->dim]-1 ; i < a->dim ; i++ )

	mov	ecx, DWORD PTR _a$91953[ebp]
	mov	edi, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ebx+48]
	lea	edx, DWORD PTR [edi*8]
	sub	esi, edx
	fld	QWORD PTR [esi+8]
	call	__ftol2_sse
	dec	eax
	cmp	edi, 1
	jle	SHORT $LN736@eval
	mov	ecx, DWORD PTR _a$91953[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR tv27959[ebp], ecx
	mov	ecx, DWORD PTR [ebx+48]
	mov	edx, 2
	sub	edx, edi
	lea	ecx, DWORD PTR [ecx+edx*8]
	dec	edi
	mov	DWORD PTR tv27980[ebp], ecx
	mov	DWORD PTR tv17378[ebp], edi
	npad	6
$LL738@eval:

; 4597 :         { offset *= a->sizes[i];

	mov	edx, DWORD PTR tv27959[ebp]
	mov	edi, DWORD PTR [edx]
	imul	edi, eax

; 4598 :           offset += (int)stacktop[i+1-a->dim]-1;  /* 1-based indexing */

	mov	eax, DWORD PTR tv27980[ebp]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	add	DWORD PTR tv27980[ebp], 8
	add	DWORD PTR tv27959[ebp], 4
	dec	DWORD PTR tv17378[ebp]
	lea	eax, DWORD PTR [edi+eax-1]
	jne	SHORT $LL738@eval
$LN736@eval:

; 4599 :         }
; 4600 :         stacktop -= a->dim;
; 4601 :         lvalue = ((char *)a) + a->datastart + offset*a->itemsize;

	mov	edx, DWORD PTR _a$91953[ebp]
	mov	DWORD PTR [ebx+48], esi
	mov	ecx, DWORD PTR [edx+12]
	imul	ecx, eax
	add	ecx, DWORD PTR [edx+20]

; 4602 :         switch ( a->datatype )

	mov	eax, DWORD PTR [edx+8]
	dec	eax
	add	ecx, edx
	cmp	eax, 17					; 00000011H
	ja	$LN722@eval
	jmp	DWORD PTR $LN4041@eval[eax*4]
$LN733@eval:

; 4603 :         { case REAL_TYPE: value = *(REAL*)(lvalue);    break;

	fld	QWORD PTR [ecx]

; 4620 :         }
; 4621 :         *(++stacktop) = value;

	lea	eax, DWORD PTR [esi+8]
	fstp	QWORD PTR [eax]
	mov	DWORD PTR [ebx+48], eax
$adfadf_27$92124:
	jmp	$LN1980@eval
$LN731@eval:

; 4604 :           case INTEGER_TYPE: value = *(int*)(lvalue);    break;
; 4605 :           case UINT_TYPE: value = *(unsigned int*)(lvalue);    break;

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR tv25762[ebp], ecx
	fild	DWORD PTR tv25762[ebp]
	test	ecx, ecx
	jns	$LN734@eval
	fadd	QWORD PTR __real@41f0000000000000

; 4620 :         }
; 4621 :         *(++stacktop) = value;

	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+48], eax
$adfadf_28$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN730@eval:

; 4606 :           case CHAR_TYPE: value = *(char*)(lvalue);    break;

	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv25761[ebp], edx

; 4620 :         }
; 4621 :         *(++stacktop) = value;

	lea	eax, DWORD PTR [esi+8]
	fild	DWORD PTR tv25761[ebp]
	mov	DWORD PTR [ebx+48], eax
$adfadf_29$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN729@eval:

; 4607 :           case UCHAR_TYPE: value = *(unsigned char*)(lvalue);    break;

	movzx	eax, BYTE PTR [ecx]
	mov	DWORD PTR tv25760[ebp], eax

; 4620 :         }
; 4621 :         *(++stacktop) = value;

	lea	eax, DWORD PTR [esi+8]
	fild	DWORD PTR tv25760[ebp]
	mov	DWORD PTR [ebx+48], eax
$adfadf_30$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN728@eval:

; 4608 :           case SHORT_TYPE: value = *(short int*)(lvalue);    break;

	movsx	ecx, WORD PTR [ecx]
	mov	DWORD PTR tv25759[ebp], ecx

; 4620 :         }
; 4621 :         *(++stacktop) = value;

	lea	eax, DWORD PTR [esi+8]
	fild	DWORD PTR tv25759[ebp]
	mov	DWORD PTR [ebx+48], eax
$adfadf_31$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN727@eval:

; 4609 :           case USHORT_TYPE: value = *(unsigned short int*)(lvalue);    break;

	movzx	edx, WORD PTR [ecx]
	mov	DWORD PTR tv25758[ebp], edx

; 4620 :         }
; 4621 :         *(++stacktop) = value;

	lea	eax, DWORD PTR [esi+8]
	fild	DWORD PTR tv25758[ebp]
	mov	DWORD PTR [ebx+48], eax
$adfadf_32$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN725@eval:

; 4610 :           case LONG_TYPE: value = *(long*)(lvalue);    break;
; 4611 :           case ULONG_TYPE: value = *(unsigned long*)(lvalue);    break;

	mov	eax, DWORD PTR [ecx]
	fild	DWORD PTR [ecx]
	test	eax, eax
	jns	SHORT $LN734@eval
	fadd	QWORD PTR __real@41f0000000000000

; 4620 :         }
; 4621 :         *(++stacktop) = value;

	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+48], eax
$adfadf_33$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN724@eval:

; 4612 :           case PTR_TYPE: value = (unsigned long)*(char**)(lvalue);    break;

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR tv25751[ebp], ecx
	fild	DWORD PTR tv25751[ebp]
	test	ecx, ecx
	jns	SHORT $LN734@eval
	fadd	QWORD PTR __real@41f0000000000000

; 4620 :         }
; 4621 :         *(++stacktop) = value;

	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+48], eax
$adfadf_34$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN722@eval:

; 4613 :           case VERTEX_TYPE:
; 4614 :           case EDGE_TYPE:
; 4615 :           case FACET_TYPE:
; 4616 :           case BODY_TYPE:
; 4617 :           case FACETEDGE_TYPE:
; 4618 :           case ELEMENTID_TYPE: value = (int)*(element_id*)(lvalue); break;
; 4619 :           default: value = *(int*)(lvalue); break;

	fild	DWORD PTR [ecx]
$LN734@eval:

; 4620 :         }
; 4621 :         *(++stacktop) = value;

	lea	eax, DWORD PTR [esi+8]
	fstp	QWORD PTR [eax]
	mov	DWORD PTR [ebx+48], eax
$adfadf_35$92124:
	jmp	$LN1980@eval
$LN721@eval:

; 4622 :       }
; 4623 :       break;
; 4624 : 
; 4625 :     /* whole array syntax */
; 4626 :     
; 4627 :       case ARRAYIDENT_NODE: /* push datastart for array */
; 4628 :         { struct global *glvalue = globals(node->op2.name_id);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+136]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN2303@eval
	mov	edx, DWORD PTR _web+5652
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR [ecx+edx]
	jmp	SHORT $LN2300@eval
$LN2303@eval:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2301@eval
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	lea	esi, DWORD PTR [ecx*8]
	sub	esi, ecx
	mov	ecx, DWORD PTR _localbase$[ebp]
	shl	esi, 5
	add	esi, DWORD PTR [ecx]
	jmp	SHORT $LN2300@eval
$LN2301@eval:
	mov	edx, eax
	and	edx, 16777215				; 00ffffffH
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2299@eval
	mov	ecx, DWORD PTR _web+5656
	mov	esi, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2300@eval
$LN2299@eval:
	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+ecx]
$LN2300@eval:

; 4629 :           struct array *alvalue;
; 4630 :           alvalue = get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	edx, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	edi, DWORD PTR _localstack$[ebp]
	push	edx
	lea	edx, DWORD PTR [ecx+edi*8]
	push	edx
	push	eax
	call	_get_name_arrayptr
	add	esp, 12					; 0000000cH

; 4631 :           if ( glvalue->flags & FIXED_SIZE_ARRAY )

	test	DWORD PTR [esi+192], 268435456		; 10000000H
	je	SHORT $LN720@eval

; 4632 :             *(REAL**)(++stacktop) = 
; 4633 :                 newstack + localstack + glvalue->attr.arrayptr->datastart;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [esi+168]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ebx+40]
	mov	eax, DWORD PTR [ebx+48]
	add	edx, edi
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR [eax], edx

; 4634 :           else 

	jmp	$LN1980@eval
$LN720@eval:

; 4635 :             *(char**)(++stacktop) = (char*)alvalue + alvalue->datastart;

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR [ebx+48]
	add	edx, eax
	mov	DWORD PTR [ecx], edx

; 4636 :           break;

	jmp	$LN1980@eval
$LN718@eval:

; 4637 :         }
; 4638 : 
; 4639 :         case FIXED_ARRAY_RVAL_NODE: /* push fixed index entry of fixed-size local */
; 4640 :         { 
; 4641 :           struct array *alvalue;
; 4642 :           alvalue = get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	esi, DWORD PTR _localstack$[ebp]
	push	eax
	mov	eax, DWORD PTR _node$[ebp]
	lea	edx, DWORD PTR [ecx+esi*8]
	mov	ecx, DWORD PTR [eax+136]
	push	edx
	push	ecx
	call	_get_name_arrayptr

; 4643 :           *(++stacktop) = 
; 4644 :                 *(newstack + localstack + alvalue->datastart + node->op3.offset);

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _node$[ebp]
	add	edx, DWORD PTR [eax+140]
	mov	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [ebx+48]
	add	edx, esi
	fld	QWORD PTR [eax+edx*8]
	add	esp, 12					; 0000000cH
	fstp	QWORD PTR [ecx]

; 4645 :           node += node->op4.skip;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	imul	ecx, 168				; 000000a8H
	add	eax, ecx
	mov	DWORD PTR _node$[ebp], eax
	jmp	$LN1980@eval
$LN717@eval:

; 4646 :           break;
; 4647 :         }
; 4648 : 
; 4649 :       case ATTRIB_LVALUE_NODE:  /* push datastart for attribute array */
; 4650 :         { element_id id;
; 4651 :           n = node->op2.name_id & GLOBMASK; /* attribute number */

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+136]

; 4652 :           if ( node->op1.localnum )

	mov	ecx, DWORD PTR [ecx+32]
	and	eax, 16777215				; 00ffffffH
	test	ecx, ecx
	je	SHORT $LN716@eval

; 4653 :             id = *(element_id*)get_localp(node->op1.localnum);

	and	ecx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	ecx, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [ecx]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [ecx+edx*8]
	jmp	SHORT $LN715@eval
$LN716@eval:

; 4654 :           else id = q_id;

	mov	ecx, DWORD PTR _q_id$[ebp]
$LN715@eval:

; 4655 :           *(char**)(++stacktop) = (char*)get_extra(id,n);

	add	DWORD PTR [ebx+48], 8
	mov	esi, DWORD PTR [ebx+48]
	push	eax
	push	ecx
	call	_get_extra
	add	esp, 8
	mov	DWORD PTR [esi], eax

; 4656 :         }
; 4657 :         break;

	jmp	$LN1980@eval
$LN714@eval:

; 4658 : 
; 4659 :       case ARRAY_VERTEX_NORMAL_NODE:
; 4660 :       case ARRAY_EDGE_VECTOR_NODE:
; 4661 :       case ARRAY_FACET_NORMAL_NODE:
; 4662 :         { element_id id;
; 4663 :           REAL *datastart =  get_localp(node->op3.localnum);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	edi, DWORD PTR _localbase$[ebp]
	mov	edx, DWORD PTR [edi]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 5
	mov	eax, DWORD PTR [ecx+edx+216]
	mov	edx, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR _localstack$[ebp]

; 4664 :           *(REAL**)(++stacktop) = datastart;

	add	DWORD PTR [ebx+48], 8
	add	eax, ecx
	lea	esi, DWORD PTR [edx+eax*8]
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 4665 :           if ( node->flags & IS_RVALUE )

	mov	edx, DWORD PTR _node$[ebp]
	test	DWORD PTR [edx+24], 8192		; 00002000H
	je	$LN1980@eval

; 4666 :           { if ( node->op1.localnum )

	mov	eax, DWORD PTR [edx+32]
	test	eax, eax
	je	SHORT $LN712@eval

; 4667 :               id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [edi]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+eax+216]
	mov	eax, DWORD PTR [ebx+40]
	add	edx, ecx
	mov	edi, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _node$[ebp]
	jmp	SHORT $LN711@eval
$LN712@eval:

; 4668 :             else id = q_id;

	mov	edi, DWORD PTR _q_id$[ebp]
$LN711@eval:

; 4669 :             switch ( node->type )

	mov	eax, DWORD PTR [edx]
	sub	eax, 10354				; 00002872H
	je	SHORT $LN708@eval
	dec	eax
	je	SHORT $LN703@eval
	dec	eax
	jne	$LN1980@eval

; 4687 :               case ARRAY_FACET_NORMAL_NODE:
; 4688 :                  get_facet_normal(id,datastart);

	push	esi
	push	edi
	call	_get_facet_normal
	add	esp, 8

; 4689 :                  break;

	jmp	$LN1980@eval
$LN703@eval:

; 4681 :               
; 4682 :                  break;
; 4683 :                 }
; 4684 :               case ARRAY_EDGE_VECTOR_NODE:
; 4685 :                  get_edge_side(id,datastart);

	push	esi
	push	edi
	call	_get_edge_side
	add	esp, 8

; 4686 :                  break;

	jmp	$LN1980@eval
$LN708@eval:

; 4670 :             { case ARRAY_VERTEX_NORMAL_NODE:
; 4671 :                { MAT2D(normal,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	ecx, DWORD PTR _normalxJ$92034[ebp]
	push	ecx
	lea	edx, DWORD PTR _normalqXvS$92033[ebp]
	push	edx
	call	_mat2d_setup

; 4672 :                  REAL mag;
; 4673 :                  int normcount;
; 4674 : 
; 4675 :                  normcount = new_calc_vertex_normal(id,normal);

	push	eax
	push	edi
	mov	DWORD PTR _normal$92035[ebp], eax
	call	_new_calc_vertex_normal

; 4676 :            //      project_vertex_normals(id,normal,normcount);
; 4677 :                  mag = sqrt(SDIM_dot(normal[0],normal[0]));

	mov	ecx, DWORD PTR _web+616
	mov	edi, DWORD PTR _normal$92035[ebp]
	mov	eax, DWORD PTR [edi]
	push	ecx
	push	eax
	push	eax
	call	_dot
	add	esp, 36					; 00000024H
	call	__CIsqrt

; 4678 :                  if ( mag == 0.0 ) mag = 1;

	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN707@eval
	fstp	ST(0)
	fld1
$LN707@eval:

; 4679 :                  for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN3164@eval
	mov	ecx, DWORD PTR [edi]
	sub	ecx, esi
$LN706@eval:

; 4680 :                     datastart[i] = normal[0][i]/mag;

	fld	QWORD PTR [ecx+esi]
	inc	eax
	fdiv	ST(0), ST(1)
	add	esi, 8
	fstp	QWORD PTR [esi-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN706@eval
$LN3164@eval:

; 1652 : 
; 1653 :       case AND_NODE: /* short-circuit */
; 1654 :         if ( *stacktop == 0.0 )

	fstp	ST(0)
$LN1980@eval:

; 6361 :         break;
; 6362 :       
; 6363 :     }      
; 6364 : 
; 6365 :     if ( breakflag && !hessian_iterate_flag && (!threadflag || (this_thread == main_thread_id)) )

	cmp	DWORD PTR _breakflag, 0
	je	$LN14@eval
$LN2783@eval:
	cmp	DWORD PTR _hessian_iterate_flag, 0
	jne	$LN14@eval
	cmp	DWORD PTR _threadflag, 0
	je	SHORT $LN16@eval
	call	DWORD PTR __imp__GetCurrentThreadId@0
	cmp	eax, DWORD PTR _main_thread_id
	jne	$LN14@eval
$LN16@eval:

; 6366 :     {
; 6367 :       switch ( breakflag )

	mov	eax, DWORD PTR _breakflag
	dec	eax
	je	$LN13@eval
	sub	eax, 3
	je	$LN11@eval
	dec	eax
	jne	$LN14@eval

; 6373 :         }
; 6374 :         break;
; 6375 :          
; 6376 :       case BREAKABORT:
; 6377 :         { sprintf(errmsg,"Command aborted.\n");

	push	OFFSET ??_C@_0BC@DICJIAOM@Command?5aborted?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 6378 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6379 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	esi, DWORD PTR [eax+1]
$LL2883@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2883@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 6380 :           kb_error(3234,errmsg, RECOVERABLE_ABORT);

	push	10					; 0000000aH
	push	OFFSET _errmsg
	push	3234					; 00000ca2H

; 6381 :         }
; 6382 :         break;

	jmp	$LN4015@eval
$LN701@eval:

; 4690 :             }
; 4691 :           }
; 4692 :         }
; 4693 :         break;
; 4694 : 
; 4695 :       case ARRAY_VERTEX_CONSTRAINT_NORMAL_NODE:
; 4696 :         { vertex_id v_id;
; 4697 :           REAL *datastart =  get_localp(node->op3.localnum);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	edx, DWORD PTR _localbase$[ebp]

; 4698 :           REAL fval; // dummy for eval_all()
; 4699 :           REAL mag;
; 4700 :           int connum = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	lea	edi, DWORD PTR [edx+ecx*8]
	call	__ftol2_sse

; 4701 :           struct constraint *con;
; 4702 : 
; 4703 :           *(REAL**)(++stacktop) = datastart;

	mov	DWORD PTR [ebx+48], esi
	mov	DWORD PTR _connum$92050[ebp], eax
	mov	DWORD PTR [esi], edi

; 4704 :           if ( node->op1.localnum )

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN700@eval

; 4705 :               v_id = *(element_id*)get_localp(node->op1.localnum);

	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+40]
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _v_id$92046[ebp], eax
	jmp	SHORT $LN699@eval
$LN700@eval:

; 4706 :           else v_id = q_id;

	mov	ecx, DWORD PTR _q_id$[ebp]
	mov	DWORD PTR _v_id$92046[ebp], ecx
$LN699@eval:

; 4707 :           if ( connum < 0 || connum >= web.maxcon )

	mov	eax, DWORD PTR _connum$92050[ebp]
	test	eax, eax
	js	SHORT $LN697@eval
	cmp	eax, DWORD PTR _web+644
	jl	SHORT $LN698@eval
$LN697@eval:

; 4708 :           { sprintf(errmsg,"constraint_normal: Constraint %d does not exist.\n",connum);

	push	eax
	push	OFFSET ??_C@_0DC@MJPKIDCD@constraint_normal?3?5Constraint?5?$CFd@
	push	OFFSET _errmsg
	call	_sprintf

; 4709 :             kb_error(4322,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4322					; 000010e2H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN698@eval:

; 4710 :           }
; 4711 :           con = get_constraint(connum);

	mov	esi, DWORD PTR _connum$92050[ebp]
	and	esi, 1073741823				; 3fffffffH
	imul	esi, 176				; 000000b0H
	add	esi, DWORD PTR _web+652

; 4712 :           if ( !(con->attr & IN_USE) )

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+32]
	and	eax, 32					; 00000020H
	or	eax, ecx
	jne	SHORT $LN696@eval

; 4713 :           { sprintf(errmsg,"constraint_normal: Constraint %d does not exist.\n",connum);

	mov	edx, DWORD PTR _connum$92050[ebp]
	push	edx
	push	OFFSET ??_C@_0DC@MJPKIDCD@constraint_normal?3?5Constraint?5?$CFd@
	push	OFFSET _errmsg
	call	_sprintf

; 4714 :             kb_error(4323,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4323					; 000010e3H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN696@eval:

; 4715 :           }
; 4716 :           eval_all(con->formula,get_coord(v_id),SDIM,&fval,datastart,v_id);

	mov	eax, DWORD PTR _v_id$92046[ebp]
	mov	edx, DWORD PTR _web+616
	push	eax
	push	edi
	lea	ecx, DWORD PTR _fval$92048[ebp]
	push	ecx
	mov	ecx, DWORD PTR _web+12
	push	edx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	add	edx, DWORD PTR [ecx+eax+64]
	push	edx
	mov	edx, DWORD PTR [esi+40]
	push	edx
	call	_eval_all

; 4717 :           // normalize
; 4718 :           mag = SDIM_dot(datastart,datastart);

	mov	eax, DWORD PTR _web+616
	push	eax
	push	edi
	push	edi
	call	_dot

; 4719 :           if ( mag > 0 )

	fldz
	fcomp	ST(1)
	add	esp, 36					; 00000024H
	fnstsw	ax
	test	ah, 5
	jp	$LN3164@eval

; 4720 :           { mag = sqrt(mag);

	call	__CIsqrt

; 4721 :             for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	$LN3164@eval
$LN694@eval:

; 4722 :                 datastart[i] /= mag;

	fld	QWORD PTR [edi+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [edi+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN694@eval

; 4723 :           }
; 4724 :         }
; 4725 :         break;

	jmp	$LN3164@eval
$LN691@eval:

; 4726 : 
; 4727 :       case ARRAY_LVALUE_INDEXED_NODE:
; 4728 :       case ARRAY_RVALUE_INDEXED_NODE:
; 4729 :       { 
; 4730 :         struct array *a;
; 4731 :         int offset;
; 4732 : 
; 4733 :         /* Adjust datastart on stack by indexes */
; 4734 :         if ( node->op5.indexcount == 0 )

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+152], 0
	je	$LN1980@eval

; 4735 :           break;  // no indices, so no adjustment needed
; 4736 :           
; 4737 :         a = get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	edx, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR _localstack$[ebp]
	push	edx
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	push	edx
	push	ecx
	call	_get_name_arrayptr

; 4738 : 
; 4739 :         for ( i = 0 ; i < node->op5.indexcount ; i++ )

	mov	esi, DWORD PTR _node$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+152]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _a$92072[ebp], ecx
	mov	DWORD PTR _i$[ebp], 0
	test	eax, eax
	jle	$LN687@eval

; 4735 :           break;  // no indices, so no adjustment needed
; 4736 :           
; 4737 :         a = get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	add	ecx, 24					; 00000018H
	mov	DWORD PTR tv28095[ebp], ecx
$LL689@eval:

; 4740 :         { int k = (int)stacktop[i+1-node->op5.indexcount];

	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, eax
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax+edx*8+8]
	call	__ftol2_sse
	mov	edi, eax

; 4741 :           if ( k < 1 )

	cmp	edi, 1
	jge	$LN686@eval

; 4742 :           { sprintf(errmsg,
; 4743 :              "Array index %d of array %s is %d. Indexes start at 1.\n",
; 4744 :                i+1,get_name_name(node->op2.name_id,localbase),k);

	mov	ecx, DWORD PTR _localbase$[ebp]
	mov	edx, DWORD PTR [esi+136]
	push	edi
	push	ecx
	push	edx
	call	_get_name_name
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_0DH@DOJNKOOH@Array?5index?5?$CFd?5of?5array?5?$CFs?5is?5?$CFd@
	push	OFFSET _errmsg
	call	_sprintf

; 4745 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4746 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 20					; 00000014H
	lea	esi, DWORD PTR [eax+1]
	npad	2
$LL2863@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2863@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4747 :             kb_error(3022,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3022					; 00000bceH
	call	_kb_error
	mov	esi, DWORD PTR _node$[ebp]
	add	esp, 28					; 0000001cH
$LN686@eval:

; 4748 :           }
; 4749 :           if ( k > a->sizes[i] && (!(node->flags & IS_VIRTUAL_ATTR) ||(k > SDIM)) )

	mov	eax, DWORD PTR tv28095[ebp]
	mov	eax, DWORD PTR [eax]
	cmp	edi, eax
	jle	$LN688@eval
	test	DWORD PTR [esi+24], 65536		; 00010000H
	je	SHORT $LN684@eval
	cmp	edi, DWORD PTR _web+616
	jle	$LN688@eval
$LN684@eval:

; 4750 :           {sprintf(errmsg,"Array index %d of array %s is %d; exceeds bound of %d.\n",
; 4751 :                i+1,get_name_name(node->op2.name_id,localbase),k,a->sizes[i]);

	mov	ecx, DWORD PTR _localbase$[ebp]
	mov	edx, DWORD PTR [esi+136]
	push	eax
	push	edi
	push	ecx
	push	edx
	call	_get_name_name
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_0DI@KHNAHFIG@Array?5index?5?$CFd?5of?5array?5?$CFs?5is?5?$CFd@
	push	OFFSET _errmsg
	call	_sprintf

; 4752 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4753 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 24					; 00000018H
	lea	esi, DWORD PTR [eax+1]
	npad	5
$LL2864@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2864@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4754 :             kb_error(3023,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3023					; 00000bcfH
	call	_kb_error
	mov	esi, DWORD PTR _node$[ebp]
	add	esp, 28					; 0000001cH
$LN688@eval:

; 4738 : 
; 4739 :         for ( i = 0 ; i < node->op5.indexcount ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [esi+152]
	add	DWORD PTR tv28095[ebp], 4
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, eax
	jl	$LL689@eval
$LN687@eval:

; 4755 :           }
; 4756 :         }
; 4757 : 
; 4758 :         for ( i = 1, offset = (int)stacktop[1-node->op5.indexcount]-1 ; i < node->op5.indexcount ; i++ )

	mov	edi, DWORD PTR [esi+152]
	mov	esi, DWORD PTR [ebx+48]
	lea	eax, DWORD PTR [edi*8]
	sub	esi, eax
	fld	QWORD PTR [esi+8]
	mov	DWORD PTR _i$[ebp], 1
	call	__ftol2_sse
	dec	eax
	cmp	edi, 1
	jle	$LN681@eval
	mov	ecx, DWORD PTR _a$92072[ebp]
	add	ecx, 28					; 0000001cH
	mov	edx, 2
	sub	edx, edi
	mov	DWORD PTR tv28170[ebp], ecx
	mov	ecx, DWORD PTR [ebx+48]
	dec	edi
	mov	DWORD PTR tv13149[ebp], edi
	lea	ecx, DWORD PTR [ecx+edx*8]
	inc	edi
	mov	DWORD PTR tv28191[ebp], ecx
	mov	DWORD PTR _i$[ebp], edi
	npad	5
$LL683@eval:

; 4759 :         { offset *= a->sizes[i];

	mov	edx, DWORD PTR tv28170[ebp]
	mov	edi, DWORD PTR [edx]
	imul	edi, eax

; 4760 :           offset += (int)stacktop[i+1-node->op5.indexcount]-1;  /* 1-based indexing */

	mov	eax, DWORD PTR tv28191[ebp]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	add	DWORD PTR tv28191[ebp], 8
	add	DWORD PTR tv28170[ebp], 4
	dec	DWORD PTR tv13149[ebp]
	lea	eax, DWORD PTR [edi+eax-1]
	jne	SHORT $LL683@eval
$LN681@eval:

; 4755 :           }
; 4756 :         }
; 4757 : 
; 4758 :         for ( i = 1, offset = (int)stacktop[1-node->op5.indexcount]-1 ; i < node->op5.indexcount ; i++ )

	mov	ecx, DWORD PTR _a$92072[ebp]
	mov	edx, DWORD PTR [ecx+4]

; 4761 :         }
; 4762 :         for ( ; i < a->dim ; i++ )

	mov	edi, DWORD PTR _i$[ebp]
	cmp	edi, edx
	jge	SHORT $LN678@eval
	lea	ecx, DWORD PTR [ecx+edi*4+24]
	sub	edx, edi
	npad	5
$LL680@eval:

; 4763 :           offset *= a->sizes[i];

	imul	eax, DWORD PTR [ecx]
	add	ecx, 4
	dec	edx
	jne	SHORT $LL680@eval

; 4761 :         }
; 4762 :         for ( ; i < a->dim ; i++ )

	mov	ecx, DWORD PTR _a$92072[ebp]
$LN678@eval:

; 4764 :         stacktop -= node->op5.indexcount;

	mov	DWORD PTR [ebx+48], esi

; 4765 :         *(char**)(stacktop) += offset*a->itemsize;

	mov	ecx, DWORD PTR [ecx+12]
	imul	ecx, eax
	add	DWORD PTR [esi], ecx

; 4766 : 
; 4767 :         // fix up *a for use at actual assignment
; 4768 :         /*
; 4769 :         a->datacount = 1;
; 4770 :         for ( i = node->op5.indexcount ; i < a->dim ; i++ )
; 4771 :         { a->datacount *= a->sizes[i];
; 4772 :           a->sizes[i-node->op5.indexcount] = a->sizes[i];
; 4773 :         }
; 4774 :         a->dim -= node->op5.indexcount;
; 4775 :         for ( i = 0 ; i < node->op5.indexcount ; i++ )
; 4776 :           a->sizes[a->dim+i] = 0;
; 4777 :           */
; 4778 : 
; 4779 :         break;

	jmp	$LN1980@eval
$LN676@eval:

; 4780 :       }
; 4781 : 
; 4782 :       case ARRAY_RVALUE_NODE:
; 4783 :         break;
; 4784 :         
; 4785 :       case DOT_NODE:  /* dot product */
; 4786 :         { struct array *a,*b;
; 4787 :           int name1 = node->op2.name_id;

	mov	eax, DWORD PTR _node$[ebp]

; 4788 :           int name2 = node->op3.name_id;
; 4789 :           REAL *datastart1,*datastart2;
; 4790 :           REAL sum;
; 4791 :           int counta,countb,count;
; 4792 :           if ( node[node->left].flags & IS_VIRTUAL_ATTR )

	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+136]
	imul	edx, 168				; 000000a8H
	test	DWORD PTR [edx+eax+24], 65536		; 00010000H
	mov	edi, DWORD PTR [eax+140]
	je	SHORT $LN675@eval

; 4793 :             counta = SDIM;

	mov	esi, DWORD PTR _web+616

; 4794 :           else

	jmp	SHORT $LN674@eval
$LN675@eval:

; 4795 :           { a = get_name_arrayptr(name1,newstack+localstack,localbase);

	mov	eax, DWORD PTR _localbase$[ebp]
	mov	edx, DWORD PTR [ebx+40]
	push	eax
	mov	eax, DWORD PTR _localstack$[ebp]
	lea	edx, DWORD PTR [edx+eax*8]
	push	edx
	push	ecx
	call	_get_name_arrayptr

; 4796 :             counta = a->sizes[a->dim-1];

	mov	ecx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax+ecx*4+20]
	mov	eax, DWORD PTR _node$[ebp]
	add	esp, 12					; 0000000cH
$LN674@eval:

; 4797 :           }
; 4798 :           if ( node[node->right].flags & IS_VIRTUAL_ATTR )

	mov	edx, DWORD PTR [eax+8]
	imul	edx, 168				; 000000a8H
	test	DWORD PTR [edx+eax+24], 65536		; 00010000H
	je	SHORT $LN673@eval

; 4799 :             countb = SDIM;

	mov	eax, DWORD PTR _web+616

; 4800 :           else

	jmp	SHORT $LN672@eval
$LN673@eval:

; 4801 :           { b = get_name_arrayptr(name2,newstack+localstack,localbase);

	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR _localstack$[ebp]
	push	eax
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	push	edi
	call	_get_name_arrayptr

; 4802 :             countb = b->sizes[b->dim-1];

	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+ecx*4+20]
	add	esp, 12					; 0000000cH
$LN672@eval:

; 4803 :           }
; 4804 :           count = (counta < countb) ? counta : countb;

	cmp	esi, eax
	jl	SHORT $LN2306@eval
	mov	esi, eax
$LN2306@eval:

; 4805 :           datastart1 = *(REAL**)(stacktop--);

	mov	eax, DWORD PTR [ebx+48]

; 4806 :           datastart2 = *(REAL**)(stacktop--);
; 4807 :           for ( sum = 0.0, i = 0 ; i < count ; i++ )

	fldz
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	mov	edx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	test	esi, esi
	jle	SHORT $LN669@eval
	sub	edx, ecx
$LN671@eval:

; 4808 :             sum += datastart1[i]*datastart2[i];

	fld	QWORD PTR [edx+ecx]
	add	ecx, 8
	dec	esi
	fmul	QWORD PTR [ecx-8]
	faddp	ST(1), ST(0)
	jne	SHORT $LN671@eval
$LN669@eval:

; 4809 :           *(++stacktop) = sum;

	add	eax, 8
	fstp	QWORD PTR [eax]
	mov	DWORD PTR [ebx+48], eax
$adfadf_36$92124:
	jmp	$LN1980@eval
$LN668@eval:

; 4810 :           break;
; 4811 :         }
; 4812 :  
; 4813 :  
; 4814 :       case ARRAY_EVAL_NODE:  /* rexpr: arraylvalue indexset */
; 4815 :       { /* use info on stack to push value of array element.
; 4816 :              stack: datastart index-values -> rexpr */
; 4817 :         REAL value=0.0;
; 4818 :         void *lvalue;
; 4819 : 
; 4820 :         lvalue = *(char**)(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax

; 4821 :         
; 4822 :         switch ( node[node->left].datatype )

	mov	edx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [edx+4]
	imul	esi, 168				; 000000a8H
	mov	edx, DWORD PTR [esi+edx+20]
	dec	edx
	cmp	edx, 17					; 00000011H
	ja	$LN653@eval
	jmp	DWORD PTR $LN4042@eval[edx*4]
$LN665@eval:

; 4823 :         { case STRING_TYPE: *(char**)(++stacktop) = *(char**)lvalue; goto adfadf;  // just keep pointer to string

	add	eax, 8
	mov	DWORD PTR [ebx+48], eax
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	$LN1980@eval
$LN664@eval:

; 4824 :           case REAL_TYPE: value = *(REAL*)(lvalue);  break;

	fld	QWORD PTR [ecx]

; 4841 :         
; 4842 :         }
; 4843 :         *(++stacktop) = value;

	add	eax, 8
	fstp	QWORD PTR [eax]
	mov	DWORD PTR [ebx+48], eax
$adfadf_37$92124:
	jmp	$LN1980@eval
$LN662@eval:

; 4825 :           case INTEGER_TYPE: value = *(int*)(lvalue); break;
; 4826 :           case UINT_TYPE: value = *(unsigned int*)(lvalue); break;

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR tv25617[ebp], ecx
	fild	DWORD PTR tv25617[ebp]
	test	ecx, ecx
	jns	$LN666@eval
	fadd	QWORD PTR __real@41f0000000000000

; 4841 :         
; 4842 :         }
; 4843 :         *(++stacktop) = value;

	add	eax, 8
	mov	DWORD PTR [ebx+48], eax
$adfadf_38$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN661@eval:

; 4827 :           case SHORT_TYPE: value = *(short int*)(lvalue); break;

	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR tv25616[ebp], edx

; 4841 :         
; 4842 :         }
; 4843 :         *(++stacktop) = value;

	add	eax, 8
	fild	DWORD PTR tv25616[ebp]
	mov	DWORD PTR [ebx+48], eax
$adfadf_39$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN660@eval:

; 4828 :           case USHORT_TYPE: value = *(unsigned short int*)(lvalue); break;

	movzx	ecx, WORD PTR [ecx]
	mov	DWORD PTR tv25615[ebp], ecx

; 4841 :         
; 4842 :         }
; 4843 :         *(++stacktop) = value;

	add	eax, 8
	fild	DWORD PTR tv25615[ebp]
	mov	DWORD PTR [ebx+48], eax
$adfadf_40$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN658@eval:

; 4829 :           case LONG_TYPE: value = *(long int*)(lvalue); break;
; 4830 :           case ULONG_TYPE: value = *(unsigned long int*)(lvalue); break;

	mov	edx, DWORD PTR [ecx]
	fild	DWORD PTR [ecx]
	test	edx, edx
	jns	$LN666@eval
	fadd	QWORD PTR __real@41f0000000000000

; 4841 :         
; 4842 :         }
; 4843 :         *(++stacktop) = value;

	add	eax, 8
	mov	DWORD PTR [ebx+48], eax
$adfadf_41$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN657@eval:

; 4831 :           case CHAR_TYPE: value = *(char*)(lvalue); break;

	movsx	ecx, BYTE PTR [ecx]
	mov	DWORD PTR tv25610[ebp], ecx

; 4841 :         
; 4842 :         }
; 4843 :         *(++stacktop) = value;

	add	eax, 8
	fild	DWORD PTR tv25610[ebp]
	mov	DWORD PTR [ebx+48], eax
$adfadf_42$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN656@eval:

; 4832 :           case UCHAR_TYPE: value = *(unsigned char*)(lvalue); break;

	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv25609[ebp], edx

; 4841 :         
; 4842 :         }
; 4843 :         *(++stacktop) = value;

	add	eax, 8
	fild	DWORD PTR tv25609[ebp]
	mov	DWORD PTR [ebx+48], eax
$adfadf_43$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN655@eval:

; 4833 :           case PTR_TYPE: value = (unsigned long int)*(char**)(lvalue); break;

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR tv25606[ebp], ecx
	fild	DWORD PTR tv25606[ebp]
	test	ecx, ecx
	jns	$LN666@eval
	fadd	QWORD PTR __real@41f0000000000000

; 4841 :         
; 4842 :         }
; 4843 :         *(++stacktop) = value;

	add	eax, 8
	mov	DWORD PTR [ebx+48], eax
$adfadf_44$92124:
	fstp	QWORD PTR [eax]
	jmp	$LN1980@eval
$LN654@eval:

; 4834 :           case VERTEX_TYPE:
; 4835 :           case EDGE_TYPE:
; 4836 :           case FACET_TYPE:
; 4837 :           case BODY_TYPE:
; 4838 :           case FACETEDGE_TYPE:
; 4839 :           case ELEMENTID_TYPE: value = ordinal(*(element_id*)lvalue)+1; break;

	mov	ecx, DWORD PTR [ecx]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN2307@eval
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	mov	DWORD PTR tv25605[ebp], ecx
	fild	DWORD PTR tv25605[ebp]

; 4841 :         
; 4842 :         }
; 4843 :         *(++stacktop) = value;

	add	eax, 8
	mov	DWORD PTR [ebx+48], eax
	fstp	QWORD PTR [eax]
$adfadf_45$92124:
	jmp	$LN1980@eval
$LN2307@eval:

; 4834 :           case VERTEX_TYPE:
; 4835 :           case EDGE_TYPE:
; 4836 :           case FACET_TYPE:
; 4837 :           case BODY_TYPE:
; 4838 :           case FACETEDGE_TYPE:
; 4839 :           case ELEMENTID_TYPE: value = ordinal(*(element_id*)lvalue)+1; break;

	or	ecx, -1
	inc	ecx
	mov	DWORD PTR tv25605[ebp], ecx
	fild	DWORD PTR tv25605[ebp]

; 4841 :         
; 4842 :         }
; 4843 :         *(++stacktop) = value;

	add	eax, 8
	mov	DWORD PTR [ebx+48], eax
	fstp	QWORD PTR [eax]
$adfadf_46$92124:
	jmp	$LN1980@eval
$LN653@eval:

; 4840 :           default: value = *(int*)(lvalue); break;

	fild	DWORD PTR [ecx]
$LN666@eval:

; 4841 :         
; 4842 :         }
; 4843 :         *(++stacktop) = value;

	add	eax, 8
	fstp	QWORD PTR [eax]
	mov	DWORD PTR [ebx+48], eax
$adfadf_47$92124:
	jmp	$LN1980@eval
$LN652@eval:

; 4844 : adfadf:
; 4845 :         break;
; 4846 :       }
; 4847 :         
; 4848 :       case ARRAY_ASSIGNOP_ARRAY_NODE:
; 4849 :         { 
; 4850 :           struct array *alvalue= get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	edi, DWORD PTR _localstack$[ebp]
	mov	edx, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR _node$[ebp]
	add	edi, edi
	add	edi, edi
	push	edx
	mov	edx, DWORD PTR [ecx+136]
	add	edi, edi
	add	eax, edi
	push	eax
	push	edx
	call	_get_name_arrayptr

; 4851 :           struct array *arvalue = get_name_arrayptr(node->op3.name_id,newstack + localstack,localbase);

	mov	ecx, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR _node$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR _localbase$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+140]
	add	ecx, edi
	push	ecx
	push	eax
	call	_get_name_arrayptr
	mov	edx, eax

; 4852 :           int inx[100]; /* keep track of indices */
; 4853 :           char *p,*q;
; 4854 :           int j,k;
; 4855 :           char *pspots[MAXARRAYDIMS],*qspots[MAXARRAYDIMS];
; 4856 :           int pstride[MAXARRAYDIMS],qstride[MAXARRAYDIMS];
; 4857 :           int minsize[MAXARRAYDIMS],lastsize;
; 4858 :           int dim;
; 4859 :           int lcount = node[node->left].op5.indexcount;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 168				; 000000a8H
	mov	ecx, DWORD PTR [ecx+eax+152]
	mov	DWORD PTR _lcount$92168[ebp], ecx

; 4860 :           int rcount = node[node->right].op5.indexcount;

	mov	ecx, DWORD PTR [eax+8]
	imul	ecx, 168				; 000000a8H
	mov	edi, DWORD PTR [ecx+eax+152]

; 4861 :           int pint = (alvalue->datatype == INTEGER_TYPE);

	xor	ecx, ecx
	mov	eax, 2
	add	esp, 24					; 00000018H
	cmp	DWORD PTR [esi+8], eax
	mov	DWORD PTR _rcount$92169[ebp], edi
	sete	cl

; 4862 :           int qint = (arvalue->datatype == INTEGER_TYPE);
; 4863 :           
; 4864 :           /* Was checked in parser that the arrays have the same number
; 4865 :              of indices, but might be different sizes. 
; 4866 :            */
; 4867 :  
; 4868 :           /* pop datastarts off stack */
; 4869 :           q = *(char**)(stacktop--);
; 4870 :           p = *(char**)(stacktop--);
; 4871 : 
; 4872 :           dim = arvalue->dim - rcount;
; 4873 :           for ( i = 0 ; i < dim ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _pint$92170[ebp], ecx
	xor	ecx, ecx
	cmp	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ebx+48]
	sete	cl
	add	eax, -8					; fffffff8H
	mov	DWORD PTR _qint$92171[ebp], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ebx+48], eax
	add	eax, -8					; fffffff8H
	mov	DWORD PTR _q$92158[ebp], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ebx+48], eax
	mov	eax, DWORD PTR [edx+4]
	sub	eax, edi
	mov	DWORD PTR _p$92157[ebp], ecx
	mov	DWORD PTR _dim$92167[ebp], eax
	test	eax, eax
	jle	$LN649@eval

; 4844 : adfadf:
; 4845 :         break;
; 4846 :       }
; 4847 :         
; 4848 :       case ARRAY_ASSIGNOP_ARRAY_NODE:
; 4849 :         { 
; 4850 :           struct array *alvalue= get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	eax, DWORD PTR _lcount$92168[ebp]
	lea	ecx, DWORD PTR [esi+eax*4+24]
	mov	DWORD PTR tv28399[ebp], ecx
	mov	eax, edi
	lea	ecx, DWORD PTR [edx+eax*4+24]
	mov	eax, DWORD PTR _q$92158[ebp]
	mov	DWORD PTR tv28401[ebp], ecx
	mov	ecx, DWORD PTR _dim$92167[ebp]
	add	ecx, ecx
	add	ecx, ecx
	shr	ecx, 2
	lea	edi, DWORD PTR _qspots$92162[ebp]
	rep stosd

; 4877 :             pspots[i] = p;

	mov	ecx, DWORD PTR _dim$92167[ebp]
	mov	eax, DWORD PTR _p$92157[ebp]
	add	ecx, ecx
	add	ecx, ecx
	shr	ecx, 2
	lea	edi, DWORD PTR _pspots$92161[ebp]
	rep stosd
	mov	ecx, DWORD PTR _dim$92167[ebp]
	add	ecx, ecx
	add	ecx, ecx
	shr	ecx, 2
	xor	eax, eax
	lea	edi, DWORD PTR _inx$92156[ebp]
	rep stosd
	mov	eax, DWORD PTR _i$[ebp]
	npad	11
$LL651@eval:

; 4874 :           { inx[i] = 0;
; 4875 :             minsize[i] = arvalue->sizes[rcount+i] < alvalue->sizes[lcount+i] ?
; 4876 :                           arvalue->sizes[rcount+i] : alvalue->sizes[lcount+i] ;

	mov	ecx, DWORD PTR tv28401[ebp]
	mov	edi, DWORD PTR tv28399[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [edi]
	cmp	ecx, edi
	jl	SHORT $LN2310@eval
	mov	ecx, edi
$LN2310@eval:
	mov	DWORD PTR _minsize$92165[ebp+eax*4], ecx
	mov	ecx, 4
	add	DWORD PTR tv28401[ebp], ecx
	add	DWORD PTR tv28399[ebp], ecx
	inc	eax
	cmp	eax, DWORD PTR _dim$92167[ebp]
	jl	SHORT $LL651@eval
$LN649@eval:

; 4878 :             qspots[i] = q;
; 4879 :           }
; 4880 :           if ( dim >= 2 )

	mov	edi, DWORD PTR _dim$92167[ebp]
	cmp	edi, 2
	jl	$LN642@eval

; 4881 :           {
; 4882 :             pstride[dim-2] = alvalue->sizes[alvalue->dim-1]*alvalue->itemsize;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+eax*4+20]
	imul	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _pstride$92163[ebp+edi*4-8], ecx

; 4883 :             qstride[dim-2] = arvalue->sizes[arvalue->dim-1]*arvalue->itemsize;

	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4+20]
	imul	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _qstride$92164[ebp+edi*4-8], ecx

; 4884 :             for ( i = alvalue->dim - 3 ; i >= lcount ; i-- )

	mov	ecx, DWORD PTR _lcount$92168[ebp]
	add	eax, -3					; fffffffdH
	cmp	eax, ecx
	jl	SHORT $LN645@eval

; 4881 :           {
; 4882 :             pstride[dim-2] = alvalue->sizes[alvalue->dim-1]*alvalue->itemsize;

	lea	esi, DWORD PTR [esi+eax*4+28]
	npad	5
$LL647@eval:

; 4885 :               pstride[i] = pstride[i+1]*alvalue->sizes[i+1];

	mov	edi, DWORD PTR _pstride$92163[ebp+eax*4+4]
	imul	edi, DWORD PTR [esi]
	mov	DWORD PTR _pstride$92163[ebp+eax*4], edi
	dec	eax
	sub	esi, 4
	cmp	eax, ecx
	jge	SHORT $LL647@eval

; 4884 :             for ( i = alvalue->dim - 3 ; i >= lcount ; i-- )

	mov	edi, DWORD PTR _dim$92167[ebp]
$LN645@eval:

; 4886 :             for ( i = arvalue->dim - 3 ; i >= rcount ; i-- )

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _rcount$92169[ebp]
	add	eax, -3					; fffffffdH
	cmp	eax, ecx
	jl	SHORT $LN642@eval
	lea	edx, DWORD PTR [edx+eax*4+28]
$LL644@eval:

; 4887 :               qstride[i] = qstride[i+1]*arvalue->sizes[i+1];

	mov	esi, DWORD PTR _qstride$92164[ebp+eax*4+4]
	imul	esi, DWORD PTR [edx]
	mov	DWORD PTR _qstride$92164[ebp+eax*4], esi
	dec	eax
	sub	edx, 4
	cmp	eax, ecx
	jge	SHORT $LL644@eval
$LN642@eval:

; 4888 :           }
; 4889 :           lastsize = minsize[dim-1];

	mov	edx, DWORD PTR _minsize$92165[ebp+edi*4-4]
	add	edi, -2					; fffffffeH
	mov	DWORD PTR _lastsize$92166[ebp], edx

; 4944 :               { p = pspots[j];

	mov	DWORD PTR tv20352[ebp], edi
$LN641@eval:

; 4890 : 
; 4891 :           do
; 4892 :           { /* do a row */
; 4893 :            
; 4894 :                 int *pi = (int*)p;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _p$92157[ebp]

; 4895 :                 REAL *pr = (REAL*)p;
; 4896 :                 int *qi = (int*)q;
; 4897 :                 REAL *qr = (REAL*)q;
; 4898 :                  switch ( node->op1.assigntype )

	mov	eax, DWORD PTR [eax+32]
	mov	esi, DWORD PTR _q$92158[ebp]
	add	eax, -30001				; ffff8acfH
	mov	edx, ecx
	mov	DWORD PTR _pi$92187[ebp], edx
	mov	DWORD PTR _pr$92189[ebp], ecx
	mov	edi, esi
	cmp	eax, 4
	ja	$LN609@eval
	jmp	DWORD PTR $LN4043@eval[eax*4]
$LN636@eval:

; 4899 :                 { case ASSIGN_OP:
; 4900 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	cmp	DWORD PTR _lastsize$92166[ebp], 0
	jle	$LN609@eval
	mov	eax, DWORD PTR _lastsize$92166[ebp]
	mov	DWORD PTR tv17206[ebp], eax
$LL635@eval:

; 4901 :                        if ( pint )

	cmp	DWORD PTR _pint$92170[ebp], 0
	je	SHORT $LN632@eval

; 4902 :                          *(pi++) = qint ? *(qi++) : (int)*(qr++);

	cmp	DWORD PTR _qint$92171[ebp], 0
	je	SHORT $LN2311@eval
	mov	eax, DWORD PTR [esi]
	add	esi, 4
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR _pi$92187[ebp], edx

; 4903 :                        else

	jmp	SHORT $LN634@eval
$LN2311@eval:

; 4902 :                          *(pi++) = qint ? *(qi++) : (int)*(qr++);

	fld	QWORD PTR [edi]
	call	__ftol2_sse
	mov	edx, DWORD PTR _pi$92187[ebp]
	mov	ecx, DWORD PTR _pr$92189[ebp]
	add	edi, 8
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR _pi$92187[ebp], edx

; 4903 :                        else

	jmp	SHORT $LN634@eval
$LN632@eval:

; 4904 :                          *(pr++) = qint ? *(qi++) : *(qr++);

	cmp	DWORD PTR _qint$92171[ebp], 0
	je	SHORT $LN2313@eval
	fild	DWORD PTR [esi]
	add	esi, 4
	jmp	SHORT $LN2314@eval
$LN2313@eval:
	fld	QWORD PTR [edi]
	add	edi, 8
$LN2314@eval:
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	mov	DWORD PTR _pr$92189[ebp], ecx
$LN634@eval:

; 4899 :                 { case ASSIGN_OP:
; 4900 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	dec	DWORD PTR tv17206[ebp]
	jne	SHORT $LL635@eval

; 4905 :                      break;

	jmp	$LN609@eval
$LN630@eval:

; 4906 :                   case PLUSASSIGN_OP:
; 4907 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	cmp	DWORD PTR _lastsize$92166[ebp], 0
	jle	$LN609@eval
	mov	eax, DWORD PTR _lastsize$92166[ebp]
	mov	DWORD PTR tv12505[ebp], eax
$LL629@eval:

; 4908 :                        if ( pint )

	cmp	DWORD PTR _pint$92170[ebp], 0
	je	SHORT $LN626@eval

; 4909 :                          *(pi++) += qint ? *(qi++) : (int)*(qr++);

	cmp	DWORD PTR _qint$92171[ebp], 0
	je	SHORT $LN2315@eval
	mov	eax, DWORD PTR [esi]
	add	DWORD PTR [edx], eax
	add	esi, 4
	add	edx, 4
	mov	DWORD PTR _pi$92187[ebp], edx

; 4910 :                        else

	jmp	SHORT $LN628@eval
$LN2315@eval:

; 4909 :                          *(pi++) += qint ? *(qi++) : (int)*(qr++);

	fld	QWORD PTR [edi]
	call	__ftol2_sse
	mov	edx, DWORD PTR _pi$92187[ebp]
	add	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _pr$92189[ebp]
	add	edi, 8
	add	edx, 4
	mov	DWORD PTR _pi$92187[ebp], edx

; 4910 :                        else

	jmp	SHORT $LN628@eval
$LN626@eval:

; 4911 :                          *(pr++) += qint ? *(qi++) : *(qr++);

	cmp	DWORD PTR _qint$92171[ebp], 0
	je	SHORT $LN2317@eval
	fild	DWORD PTR [esi]
	add	esi, 4
	jmp	SHORT $LN2318@eval
$LN2317@eval:
	fld	QWORD PTR [edi]
	add	edi, 8
$LN2318@eval:
	fadd	QWORD PTR [ecx]
	add	ecx, 8
	mov	DWORD PTR _pr$92189[ebp], ecx
	fstp	QWORD PTR [ecx-8]
$LN628@eval:

; 4906 :                   case PLUSASSIGN_OP:
; 4907 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	dec	DWORD PTR tv12505[ebp]
	jne	SHORT $LL629@eval

; 4912 :                      break;

	jmp	$LN609@eval
$LN624@eval:

; 4913 :                   case SUBASSIGN_OP:
; 4914 :                     for ( i = 0 ; i < lastsize ; i++ ) 

	cmp	DWORD PTR _lastsize$92166[ebp], 0
	jle	$LN609@eval
	mov	eax, DWORD PTR _lastsize$92166[ebp]
	mov	DWORD PTR tv12490[ebp], eax
$LL623@eval:

; 4915 :                        if ( pint )

	cmp	DWORD PTR _pint$92170[ebp], 0
	je	SHORT $LN620@eval

; 4916 :                          *(pi++) -= qint ? *(qi++) : (int)*(qr++);

	cmp	DWORD PTR _qint$92171[ebp], 0
	je	SHORT $LN2319@eval
	mov	eax, DWORD PTR [esi]
	sub	DWORD PTR [edx], eax
	add	esi, 4
	add	edx, 4
	mov	DWORD PTR _pi$92187[ebp], edx

; 4917 :                        else

	jmp	SHORT $LN622@eval
$LN2319@eval:

; 4916 :                          *(pi++) -= qint ? *(qi++) : (int)*(qr++);

	fld	QWORD PTR [edi]
	call	__ftol2_sse
	mov	edx, DWORD PTR _pi$92187[ebp]
	sub	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _pr$92189[ebp]
	add	edi, 8
	add	edx, 4
	mov	DWORD PTR _pi$92187[ebp], edx

; 4917 :                        else

	jmp	SHORT $LN622@eval
$LN620@eval:

; 4918 :                          *(pr++) -= qint ? *(qi++) : *(qr++);

	cmp	DWORD PTR _qint$92171[ebp], 0
	je	SHORT $LN2321@eval
	fild	DWORD PTR [esi]
	add	esi, 4
	jmp	SHORT $LN2322@eval
$LN2321@eval:
	fld	QWORD PTR [edi]
	add	edi, 8
$LN2322@eval:
	fsubr	QWORD PTR [ecx]
	add	ecx, 8
	mov	DWORD PTR _pr$92189[ebp], ecx
	fstp	QWORD PTR [ecx-8]
$LN622@eval:

; 4913 :                   case SUBASSIGN_OP:
; 4914 :                     for ( i = 0 ; i < lastsize ; i++ ) 

	dec	DWORD PTR tv12490[ebp]
	jne	SHORT $LL623@eval

; 4919 :                      break;                       

	jmp	$LN609@eval
$LN618@eval:

; 4920 :                   case MULTASSIGN_OP:
; 4921 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	cmp	DWORD PTR _lastsize$92166[ebp], 0
	jle	$LN609@eval
	mov	eax, DWORD PTR _lastsize$92166[ebp]
	mov	DWORD PTR tv17191[ebp], eax
$LL617@eval:

; 4922 :                        if ( pint )

	cmp	DWORD PTR _pint$92170[ebp], 0
	je	SHORT $LN614@eval

; 4923 :                          *(pi++) *= qint ? *(qi++) : (int)*(qr++);

	cmp	DWORD PTR _qint$92171[ebp], 0
	je	SHORT $LN2323@eval
	mov	eax, DWORD PTR [esi]
	add	esi, 4
	jmp	SHORT $LN2324@eval
$LN2323@eval:
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	mov	edx, DWORD PTR _pi$92187[ebp]
	add	edi, 8
$LN2324@eval:
	mov	ecx, DWORD PTR [edx]
	imul	ecx, eax
	mov	DWORD PTR [edx], ecx

; 4924 :                        else

	mov	ecx, DWORD PTR _pr$92189[ebp]
	add	edx, 4
	mov	DWORD PTR _pi$92187[ebp], edx
	jmp	SHORT $LN616@eval
$LN614@eval:

; 4925 :                          *(pr++) *= qint ? *(qi++) : *(qr++);

	cmp	DWORD PTR _qint$92171[ebp], 0
	je	SHORT $LN2325@eval
	fild	DWORD PTR [esi]
	add	esi, 4
	jmp	SHORT $LN2326@eval
$LN2325@eval:
	fld	QWORD PTR [edi]
	add	edi, 8
$LN2326@eval:
	fmul	QWORD PTR [ecx]
	add	ecx, 8
	mov	DWORD PTR _pr$92189[ebp], ecx
	fstp	QWORD PTR [ecx-8]
$LN616@eval:

; 4920 :                   case MULTASSIGN_OP:
; 4921 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	dec	DWORD PTR tv17191[ebp]
	jne	SHORT $LL617@eval

; 4926 :                      break;

	jmp	$LN609@eval
$LN612@eval:

; 4927 :                   case DIVASSIGN_OP:
; 4928 :                     for ( i = 0 ; i < lastsize ; i++ ) 

	mov	eax, DWORD PTR _lastsize$92166[ebp]
	test	eax, eax
	jle	$LN609@eval
	mov	DWORD PTR tv16824[ebp], eax
	mov	eax, DWORD PTR _qint$92171[ebp]
$LN611@eval:

; 4929 :                        if ( pint )

	cmp	DWORD PTR _pint$92170[ebp], 0
	je	SHORT $LN608@eval

; 4930 :                        { *pi = (int)(*pi /(qint ? (REAL)*(qi++) : *(qr++)));

	test	eax, eax
	je	SHORT $LN2327@eval
	fild	DWORD PTR [esi]
	add	esi, 4
	jmp	SHORT $LN2328@eval
$LN2327@eval:
	fld	QWORD PTR [edi]
	add	edi, 8
$LN2328@eval:
	mov	edx, DWORD PTR _pi$92187[ebp]
	fidivr	DWORD PTR [edx]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _pi$92187[ebp]
	mov	DWORD PTR [ecx], eax

; 4931 :                           pi++;
; 4932 :                        }
; 4933 :                        else

	mov	eax, DWORD PTR _qint$92171[ebp]
	add	ecx, 4
	mov	DWORD PTR _pi$92187[ebp], ecx
	mov	ecx, DWORD PTR _pr$92189[ebp]
	jmp	SHORT $LN610@eval
$LN608@eval:

; 4934 :                          *(pr++) /= qint ? (REAL)*(qi++) : *(qr++);

	test	eax, eax
	je	SHORT $LN2329@eval
	fild	DWORD PTR [esi]
	add	esi, 4
	jmp	SHORT $LN2330@eval
$LN2329@eval:
	fld	QWORD PTR [edi]
	add	edi, 8
$LN2330@eval:
	fdivr	QWORD PTR [ecx]
	add	ecx, 8
	mov	DWORD PTR _pr$92189[ebp], ecx
	fstp	QWORD PTR [ecx-8]
$LN610@eval:

; 4927 :                   case DIVASSIGN_OP:
; 4928 :                     for ( i = 0 ; i < lastsize ; i++ ) 

	dec	DWORD PTR tv16824[ebp]
	jne	SHORT $LN611@eval
$LN609@eval:

; 4935 :                      break;
; 4936 :                 }
; 4937 :              
; 4938 : 
; 4939 :             /* increment pointers */
; 4940 :             for ( j = dim-2 ; j >= 0 ; j-- )

	mov	edx, DWORD PTR tv20352[ebp]
	test	edx, edx
	js	$LN3977@eval
	mov	esi, 1
	npad	5
$LL606@eval:

; 4941 :             { pspots[j] += pstride[j];

	mov	eax, DWORD PTR _pstride$92163[ebp+edx*4]
	add	DWORD PTR _pspots$92161[ebp+edx*4], eax

; 4942 :               qspots[j] += qstride[j];

	mov	eax, DWORD PTR _qstride$92164[ebp+edx*4]
	add	DWORD PTR _qspots$92162[ebp+edx*4], eax

; 4943 :               if ( ++inx[j] < minsize[j] )

	add	DWORD PTR _inx$92156[ebp+edx*4], esi
	mov	eax, DWORD PTR _inx$92156[ebp+edx*4]
	mov	ecx, DWORD PTR _pspots$92161[ebp+edx*4]
	mov	edi, DWORD PTR _qspots$92162[ebp+edx*4]
	cmp	eax, DWORD PTR _minsize$92165[ebp+edx*4]
	jl	SHORT $LN2616@eval

; 4948 :                   qspots[k] = q;
; 4949 :                 }
; 4950 :                 break;
; 4951 :               }
; 4952 :               inx[j] = 0 ;

	mov	DWORD PTR _inx$92156[ebp+edx*4], 0
	sub	edx, esi
	jns	SHORT $LL606@eval

; 6334 :                 a = NULL;
; 6335 :               }
; 6336 :             }
; 6337 :          }
; 6338 :         if ( this_frame->flags & BASE_OF_EVAL )

	jmp	SHORT $LN640@eval
$LN2616@eval:

; 4945 :                 q = qspots[j];
; 4946 :                 for ( k = j+1 ; k < dim-1 ; k++ )

	mov	eax, DWORD PTR _dim$92167[ebp]
	mov	DWORD PTR _p$92157[ebp], ecx
	lea	ecx, DWORD PTR [edx+1]
	dec	eax
	mov	DWORD PTR _q$92158[ebp], edi
	cmp	ecx, eax
	jge	SHORT $LN640@eval

; 4944 :               { p = pspots[j];

	sub	eax, ecx
	lea	esi, DWORD PTR _pspots$92161[ebp+ecx*4]
	add	eax, eax
	lea	edi, DWORD PTR _qspots$92162[ebp+ecx*4]
	mov	DWORD PTR tv28724[ebp], esi
	lea	esi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _q$92158[ebp]
	mov	ecx, esi
	shr	ecx, 2
	rep stosd

; 4947 :                 { pspots[k] = p;

	mov	eax, DWORD PTR _p$92157[ebp]
	mov	edi, DWORD PTR tv28724[ebp]
	mov	ecx, esi
	shr	ecx, 2
	rep stosd
$LN640@eval:

; 4953 :             }  
; 4954 :            } while ( j >= 0 ); 

	test	edx, edx
	jns	$LN641@eval
$LN3977@eval:

; 4955 :               
; 4956 :           if ( node->flags & RECALC_FLAG )

	mov	eax, DWORD PTR _node$[ebp]
	test	DWORD PTR [eax+24], 32768		; 00008000H
	je	$LN599@eval

; 4957 :             recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], 1

; 4958 :           if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'
; 4959 :             dont_resize_flag = 1;
; 4960 : 
; 4961 :           break;

	jmp	$LN599@eval
$LN597@eval:

; 4962 :         } /* end ARRAY_ASSIGNOP_ARRAY_ */
; 4963 : 
; 4964 :       case ARRAY_ASSIGNOP_SCALAR_NODE: 
; 4965 :         { 
; 4966 :           struct array *alvalue= get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	ecx, DWORD PTR _localbase$[ebp]
	mov	edx, DWORD PTR [ebx+40]
	mov	eax, DWORD PTR _localstack$[ebp]
	push	ecx
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+136]
	push	ecx
	push	eax
	call	_get_name_arrayptr

; 4967 :           REAL scalar = *(stacktop--);

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	lea	edx, DWORD PTR [ecx-8]
	mov	DWORD PTR [ebx+48], edx
	fst	QWORD PTR _scalar$92247[ebp]

; 4968 :           char *p;
; 4969 :           int lastsize = alvalue->datacount;
; 4970 : 
; 4971 :           if ( node[node->left].type == ARRAY_LVALUE_INDEXED_NODE )

	mov	ecx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [eax+16]
	imul	esi, 168				; 000000a8H
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [ecx+esi], 10358		; 00002876H
	jne	SHORT $LN593@eval

; 4974 :             for ( k = node[node->left].op5.indexcount ; k < alvalue->dim ; k++ )

	mov	ecx, DWORD PTR [ecx+esi+152]
	mov	esi, DWORD PTR [eax+4]
	mov	edi, 1
	mov	DWORD PTR _k$92251[ebp], ecx
	cmp	ecx, esi
	jge	SHORT $LN593@eval

; 4972 :           { int k;
; 4973 :             lastsize = 1;

	sub	esi, DWORD PTR _k$92251[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4+24]
	mov	DWORD PTR tv17142[ebp], esi
$LN595@eval:

; 4975 :               lastsize *= alvalue->sizes[k];

	imul	edi, DWORD PTR [ecx]
	add	ecx, 4
	dec	DWORD PTR tv17142[ebp]
	jne	SHORT $LN595@eval
$LN593@eval:

; 4976 :           }
; 4977 :           p = *(char**)(stacktop--);

	mov	esi, DWORD PTR [edx]
	add	edx, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], edx

; 4978 :           switch ( alvalue->datatype )

	mov	eax, DWORD PTR [eax+8]
	dec	eax
	je	$LN590@eval
	dec	eax
	jne	$LN3479@eval

; 5010 :                      break;
; 5011 :                 }
; 5012 :                 break; /* end REAL_TYPE */
; 5013 :               }
; 5014 : 
; 5015 :               case INTEGER_TYPE:
; 5016 :               { int intscalar = (int)floor(scalar);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse

; 5017 :                 int *pp = (int*)p;
; 5018 : 
; 5019 :                 switch ( node->op1.assigntype )

	mov	ecx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [ecx+32]
	add	ecx, -30001				; ffff8acfH
	cmp	ecx, 4
	ja	$LN3977@eval
	jmp	DWORD PTR $LN4044@eval[ecx*4]
$LN563@eval:

; 5020 :                 { case ASSIGN_OP:
; 5021 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	test	edi, edi
	jle	$LN3977@eval
	mov	ecx, edi
	mov	edi, esi
	rep stosd

; 5022 :                        *(pp++) = intscalar;
; 5023 :                      break;

	jmp	$LN3977@eval
$LN559@eval:

; 5024 :                   case PLUSASSIGN_OP:
; 5025 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	test	edi, edi
	jle	$LN3977@eval
$LL558@eval:

; 5026 :                        *(pp++) += intscalar;

	add	DWORD PTR [esi], eax
	add	esi, 4
	dec	edi
	jne	SHORT $LL558@eval

; 5027 :                      break;

	jmp	$LN3977@eval
$LN555@eval:

; 5028 :                   case SUBASSIGN_OP:
; 5029 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	test	edi, edi
	jle	$LN3977@eval
$LL554@eval:

; 5030 :                        *(pp++) -= intscalar;

	sub	DWORD PTR [esi], eax
	add	esi, 4
	dec	edi
	jne	SHORT $LL554@eval

; 5031 :                      break;                        

	jmp	$LN3977@eval
$LN551@eval:

; 5032 :                   case MULTASSIGN_OP:
; 5033 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	test	edi, edi
	jle	$LN3977@eval
	fld	QWORD PTR _scalar$92247[ebp]
$LN550@eval:

; 5034 :                      { *pp = (int)(*(int*)pp * scalar);

	fild	DWORD PTR [esi]
	fmul	ST(0), ST(1)
	call	__ftol2_sse
	mov	DWORD PTR [esi], eax

; 5035 :                        pp++;

	add	esi, 4
	dec	edi
	jne	SHORT $LN550@eval

; 5044 :                      }
; 5045 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	fstp	ST(0)

; 5048 :                      }
; 5049 :                      break;
; 5050 :                 }
; 5051 :               }
; 5052 :               break; /* end INTEGER_TYPE */
; 5053 :             }         
; 5054 : 
; 5055 :            if ( node->flags & RECALC_FLAG )
; 5056 :              recalc_flag = 1;
; 5057 :            if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'
; 5058 :              dont_resize_flag = 1;
; 5059 : 
; 5060 :          } /* end ARRAY_ASSIGNOP_SCALAR */
; 5061 :          break;

	jmp	$LN3977@eval
$LN547@eval:

; 5036 :                      }
; 5037 :                      break;
; 5038 :                   case DIVASSIGN_OP:
; 5039 :                      if ( scalar == 0.0 )

	fld	QWORD PTR _scalar$92247[ebp]
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN546@eval

; 5040 :                      { sprintf(errmsg,"Division by zero.\n");

	push	OFFSET ??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@
	fstp	ST(0)
	push	OFFSET _errmsg
	call	_sprintf

; 5041 :                        sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 5042 :                           file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL2865@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2865@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 5043 :                        kb_error(4679,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4679					; 00001247H
	call	_kb_error
	fld	QWORD PTR _scalar$92247[ebp]
	add	esp, 28					; 0000001cH
$LN546@eval:

; 5044 :                      }
; 5045 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	test	edi, edi
	jle	$LN3479@eval
$LN545@eval:

; 5046 :                      { *pp = (int)((*(int*)pp) / scalar);

	fild	DWORD PTR [esi]
	fdiv	ST(0), ST(1)
	call	__ftol2_sse
	mov	DWORD PTR [esi], eax

; 5047 :                         pp++;

	add	esi, 4
	dec	edi
	jne	SHORT $LN545@eval

; 5044 :                      }
; 5045 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	fstp	ST(0)

; 5048 :                      }
; 5049 :                      break;
; 5050 :                 }
; 5051 :               }
; 5052 :               break; /* end INTEGER_TYPE */
; 5053 :             }         
; 5054 : 
; 5055 :            if ( node->flags & RECALC_FLAG )
; 5056 :              recalc_flag = 1;
; 5057 :            if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'
; 5058 :              dont_resize_flag = 1;
; 5059 : 
; 5060 :          } /* end ARRAY_ASSIGNOP_SCALAR */
; 5061 :          break;

	jmp	$LN3977@eval
$LN590@eval:

; 4979 :           { case REAL_TYPE:
; 4980 :             { REAL *pp = (REAL*)p;
; 4981 : 
; 4982 :                 switch ( node->op1.assigntype )

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	$LN3479@eval
	jmp	DWORD PTR $LN4045@eval[eax*4]
$LN587@eval:

; 4983 :                 { case ASSIGN_OP:
; 4984 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	test	edi, edi
	jle	$LN3479@eval
	lea	ecx, DWORD PTR [edi*8-5]
	fstp	QWORD PTR [esi]
	shr	ecx, 2
	lea	edi, DWORD PTR [esi+8]
	rep movsd

; 4985 :                        *(pp++) = scalar;
; 4986 :                      break;

	jmp	$LN3977@eval
$LN583@eval:

; 4987 :                   case PLUSASSIGN_OP:
; 4988 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	test	edi, edi
	jle	$LN3479@eval
$LN582@eval:

; 4989 :                        *(pp++) += scalar;

	fld	QWORD PTR [esi]
	add	esi, 8
	dec	edi
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [esi-8]
	jne	SHORT $LN582@eval

; 5044 :                      }
; 5045 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	fstp	ST(0)

; 5048 :                      }
; 5049 :                      break;
; 5050 :                 }
; 5051 :               }
; 5052 :               break; /* end INTEGER_TYPE */
; 5053 :             }         
; 5054 : 
; 5055 :            if ( node->flags & RECALC_FLAG )
; 5056 :              recalc_flag = 1;
; 5057 :            if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'
; 5058 :              dont_resize_flag = 1;
; 5059 : 
; 5060 :          } /* end ARRAY_ASSIGNOP_SCALAR */
; 5061 :          break;

	jmp	$LN3977@eval
$LN579@eval:

; 4990 :                      break;
; 4991 :                   case SUBASSIGN_OP:
; 4992 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	test	edi, edi
	jle	$LN3479@eval
$LN578@eval:

; 4993 :                        *(pp++) -= scalar;

	fld	QWORD PTR [esi]
	add	esi, 8
	dec	edi
	fsub	ST(0), ST(1)
	fstp	QWORD PTR [esi-8]
	jne	SHORT $LN578@eval

; 5044 :                      }
; 5045 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	fstp	ST(0)

; 5048 :                      }
; 5049 :                      break;
; 5050 :                 }
; 5051 :               }
; 5052 :               break; /* end INTEGER_TYPE */
; 5053 :             }         
; 5054 : 
; 5055 :            if ( node->flags & RECALC_FLAG )
; 5056 :              recalc_flag = 1;
; 5057 :            if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'
; 5058 :              dont_resize_flag = 1;
; 5059 : 
; 5060 :          } /* end ARRAY_ASSIGNOP_SCALAR */
; 5061 :          break;

	jmp	$LN3977@eval
$LN575@eval:

; 4994 :                      break;                        
; 4995 :                   case MULTASSIGN_OP:
; 4996 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	test	edi, edi
	jle	$LN3479@eval
$LN574@eval:

; 4997 :                        *(pp++) *= scalar;

	fld	QWORD PTR [esi]
	add	esi, 8
	dec	edi
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [esi-8]
	jne	SHORT $LN574@eval

; 5044 :                      }
; 5045 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	fstp	ST(0)

; 5048 :                      }
; 5049 :                      break;
; 5050 :                 }
; 5051 :               }
; 5052 :               break; /* end INTEGER_TYPE */
; 5053 :             }         
; 5054 : 
; 5055 :            if ( node->flags & RECALC_FLAG )
; 5056 :              recalc_flag = 1;
; 5057 :            if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'
; 5058 :              dont_resize_flag = 1;
; 5059 : 
; 5060 :          } /* end ARRAY_ASSIGNOP_SCALAR */
; 5061 :          break;

	jmp	$LN3977@eval
$LN571@eval:

; 4998 :                      break;
; 4999 :                   case DIVASSIGN_OP:
; 5000 :                      if ( scalar == 0.0 )

	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN570@eval

; 5001 :                      {
; 5002 :                        sprintf(errmsg,"Division by zero.\n");

	push	OFFSET ??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@
	fstp	ST(0)
	push	OFFSET _errmsg
	call	_sprintf

; 5003 :                        sprintf(errmsg+strlen(errmsg),
; 5004 :                           "(source file %s, line %d)\n",
; 5005 :                              file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL2866@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2866@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 5006 :                        kb_error(4676,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4676					; 00001244H
	call	_kb_error
	fld	QWORD PTR _scalar$92247[ebp]
	add	esp, 28					; 0000001cH
$LN570@eval:

; 5007 :                      }
; 5008 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	test	edi, edi
	jle	SHORT $LN3479@eval
$LN569@eval:

; 5009 :                        *(pp++) /= scalar;

	fld	QWORD PTR [esi]
	add	esi, 8
	dec	edi
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [esi-8]
	jne	SHORT $LN569@eval
$LN3479@eval:

; 5044 :                      }
; 5045 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	fstp	ST(0)

; 5048 :                      }
; 5049 :                      break;
; 5050 :                 }
; 5051 :               }
; 5052 :               break; /* end INTEGER_TYPE */
; 5053 :             }         
; 5054 : 
; 5055 :            if ( node->flags & RECALC_FLAG )
; 5056 :              recalc_flag = 1;
; 5057 :            if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'
; 5058 :              dont_resize_flag = 1;
; 5059 : 
; 5060 :          } /* end ARRAY_ASSIGNOP_SCALAR */
; 5061 :          break;

	jmp	$LN3977@eval
$LN540@eval:

; 5062 : 
; 5063 :       case ARRAY_ASSIGNOP_STRING_NODE: 
; 5064 :         { struct global *g = globals(node->op1.name_id);

	mov	eax, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN2331@eval
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2333@eval
	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 5
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN3978@eval
$LN2333@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2331@eval
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _g$92325[ebp], edx
	jmp	SHORT $LN2332@eval
$LN2331@eval:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+eax]
$LN3978@eval:
	mov	DWORD PTR _g$92325[ebp], ecx
$LN2332@eval:

; 5065 :           struct array *alvalue= get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	edx, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR _localstack$[ebp]
	push	edx
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	push	edx
	push	ecx
	call	_get_name_arrayptr

; 5066 :           char *s = *(char**)(stacktop--);

	mov	ecx, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ecx]
	lea	edi, DWORD PTR [ecx-8]
	mov	DWORD PTR [ebx+48], edi

; 5067 :           char **p;
; 5068 :           char **pp;
; 5069 :           int lastsize = alvalue->datacount;

	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _s$92329[ebp], edx

; 5070 : 
; 5071 :           if ( node[node->left].type == ARRAY_LVALUE_INDEXED_NODE )

	mov	edx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [edx+4]
	imul	esi, 168				; 000000a8H
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [edx+esi], 10358		; 00002876H
	jne	SHORT $LN536@eval

; 5074 :             for ( k = node[node->left].op5.indexcount ; k < alvalue->dim ; k++ )

	mov	edx, DWORD PTR [edx+esi+152]
	mov	esi, DWORD PTR [eax+4]
	mov	ecx, 1
	cmp	edx, esi
	jge	SHORT $LN536@eval

; 5072 :           { int k;
; 5073 :             lastsize = 1;

	lea	eax, DWORD PTR [eax+edx*4+24]
	sub	esi, edx
	npad	1
$LL538@eval:

; 5075 :               lastsize *= alvalue->sizes[k];

	imul	ecx, DWORD PTR [eax]
	add	eax, 4
	dec	esi
	jne	SHORT $LL538@eval
$LN536@eval:

; 5076 :           }
; 5077 :           p = *(char***)(stacktop--);

	mov	esi, DWORD PTR [edi]
	add	edi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], edi
	mov	edi, DWORD PTR _s$92329[ebp]

; 5078 :           pp = p;
; 5079 : 
; 5080 :           for ( i = 0 ; i < lastsize ; i++,pp++ ) 

	test	ecx, ecx
	jle	$LN533@eval

; 5076 :           }
; 5077 :           p = *(char***)(stacktop--);

	mov	DWORD PTR tv17081[ebp], ecx
	npad	11
$LL535@eval:

; 5081 :           { if ( g->flags & GLOB_LOCALVAR )

	mov	eax, DWORD PTR _g$92325[ebp]
	test	DWORD PTR [eax+192], 524288		; 00080000H
	je	SHORT $LN532@eval

; 5082 :               *(char**)pp = temp_realloc(*(char**)pp,(s?strlen(s):0)+1);

	test	edi, edi
	je	SHORT $LN2337@eval
	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL2867@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2867@eval
	sub	eax, edx
	jmp	SHORT $LN2338@eval
$LN2337@eval:
	xor	eax, eax
$LN2338@eval:
	mov	ecx, DWORD PTR [esi]
	push	5082					; 000013daH
	push	OFFSET ??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@
	inc	eax
	push	eax
	push	ecx
	call	_kb_temp_realloc

; 5083 :             else

	jmp	SHORT $LN3979@eval
$LN532@eval:

; 5084 :               *(char**)pp = kb_realloc(*(char**)pp,(s?strlen(s):0)+1);

	test	edi, edi
	je	SHORT $LN2339@eval
	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL2868@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2868@eval
	sub	eax, edx
	jmp	SHORT $LN2340@eval
$LN2339@eval:
	xor	eax, eax
$LN2340@eval:
	mov	edx, DWORD PTR [esi]
	push	5084					; 000013dcH
	push	OFFSET ??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@
	inc	eax
	push	eax
	push	edx
	call	_KB_realloc
$LN3979@eval:
	mov	DWORD PTR [esi], eax
	add	esp, 16					; 00000010H

; 5085 :             strcpy(*(char**)pp,s);

	mov	ecx, edi
	mov	edx, eax
	npad	6
$LL2341@eval:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL2341@eval

; 5078 :           pp = p;
; 5079 : 
; 5080 :           for ( i = 0 ; i < lastsize ; i++,pp++ ) 

	add	esi, 4
	dec	DWORD PTR tv17081[ebp]
	jne	$LL535@eval
$LN533@eval:

; 5086 :           }
; 5087 :                
; 5088 :           if ( node->left && (node[node->left].flags & DEALLOCATE_POINTER) )

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN530@eval
	imul	eax, 168				; 000000a8H
	test	DWORD PTR [eax+ecx+24], 1024		; 00000400H
	je	SHORT $LN530@eval

; 5089 :             myfree(s);  // for sprintf source of right side

	push	edi
	call	_myfree
	mov	ecx, DWORD PTR _node$[ebp]
	add	esp, 4
$LN530@eval:

; 5090 : 
; 5091 :            if ( node->flags & RECALC_FLAG )

	test	DWORD PTR [ecx+24], 32768		; 00008000H
	je	SHORT $LN529@eval

; 5092 :              recalc_flag = 1;

	mov	DWORD PTR _recalc_flag$[ebp], 1
$LN529@eval:

; 5093 :            if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'

	test	DWORD PTR [ecx+24], 131072		; 00020000H

; 5094 :              dont_resize_flag = 1;
; 5095 : 
; 5096 :          } /* end ARRAY_ASSIGNOP_STRING_NODE */
; 5097 :          break;

	jmp	$LN4012@eval
$LN526@eval:

; 5098 : 
; 5099 :         case ARRAYLIST_NODE:
; 5100 :           break;
; 5101 : 
; 5102 :         case ARRAYEXPR_NODE:
; 5103 :           // push marker and dimension level
; 5104 :           *(++stacktop) = ARRAYINIT_MARKER;

	fld	QWORD PTR __real@7e0bbe3ac8d3bd70
	mov	ecx, 8
	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]

; 5105 :           *(int *)(++stacktop) = node->op4.arraydim;

	add	DWORD PTR [ebx+48], ecx
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR [eax], edx

; 5106 :           break;

	jmp	$LN1980@eval
$LN525@eval:

; 5107 : 
; 5108 :         case ARRAYEXPR_ASSIGN_NODE: // initializer syntax on the right 
; 5109 :         { 
; 5110 :           struct array *alvalue= get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR _localstack$[ebp]
	push	eax
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	push	eax
	push	edx
	call	_get_name_arrayptr

; 5111 :           REAL *spot = stacktop - node->op3.argcount + 1;  // start of data

	mov	ecx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [ecx+140]
	mov	edx, DWORD PTR [ebx+48]
	add	esi, esi
	add	esi, esi
	add	esi, esi
	sub	edx, esi

; 5112 :           void *pbase = *(void**)(stacktop - node->op3.argcount);  // destination data pointer

	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR _alvalue$92357[ebp], eax
	lea	esi, DWORD PTR [edx+8]

; 5113 :           int lastsize = alvalue->sizes[alvalue->dim-1];  // row size

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edx*4+20]
	mov	DWORD PTR _lastsize$92361[ebp], eax

; 5114 :           int lowdim = node->op5.indexcount;

	mov	eax, DWORD PTR [ecx+152]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lowdim$92362[ebp], eax

; 5115 :           int poffset; // number of elements linear offset in destination
; 5116 :           void *prevpp = pbase;  // for filling with zeros since last spot
; 5117 :           int pspots[MAXARRAYDIMS];  // indices of current slice
; 5118 : 
; 5119 :        /* NEED INDEXCOUNT IN NODE.OP5, OR DIM OF RHS */
; 5120 : 
; 5121 :           memset(pspots,0,sizeof(pspots));

	xor	eax, eax
	mov	DWORD PTR _pbase$92359[ebp], edi
	mov	DWORD PTR _prevpp$92364[ebp], edi
	mov	DWORD PTR _pspots$92365[ebp], eax
	mov	DWORD PTR _pspots$92365[ebp+4], eax
	mov	DWORD PTR _pspots$92365[ebp+8], eax
	mov	DWORD PTR _pspots$92365[ebp+12], eax
	mov	DWORD PTR _pspots$92365[ebp+16], eax
	mov	DWORD PTR _pspots$92365[ebp+20], eax
	mov	DWORD PTR _pspots$92365[ebp+24], eax
	mov	DWORD PTR _pspots$92365[ebp+28], eax

; 5274 :                pspots[i] = 0;                     
; 5275 : 
; 5276 :           } // end for

	jmp	SHORT $LN524@eval
$LL3076@eval:
	mov	ecx, DWORD PTR _node$[ebp]
$LN524@eval:

; 5122 : 
; 5123 :           for(;;)
; 5124 :           {  int d;
; 5125 :             
; 5126 :             // first, calculate destination spot
; 5127 :             int size;  // of slice so far, in items
; 5128 :             for ( i = alvalue->dim-1, size = 1, poffset = 0 ; i >= lowdim ; i-- )

	dec	edx
	xor	edi, edi
	mov	eax, 1
	cmp	edx, DWORD PTR _lowdim$92362[ebp]
	jl	SHORT $LN520@eval
	mov	ecx, DWORD PTR _alvalue$92357[ebp]
	lea	ecx, DWORD PTR [ecx+edx*4+24]
	mov	DWORD PTR tv28928[ebp], ecx
	npad	6
$LL522@eval:

; 5129 :             { poffset += size*pspots[i];

	mov	ecx, DWORD PTR _pspots$92365[ebp+edx*4]
	imul	ecx, eax
	add	edi, ecx

; 5130 :               size *= alvalue->sizes[i];

	mov	ecx, DWORD PTR tv28928[ebp]
	mov	ecx, DWORD PTR [ecx]
	sub	DWORD PTR tv28928[ebp], 4
	imul	eax, ecx
	dec	edx
	cmp	edx, DWORD PTR _lowdim$92362[ebp]
	jge	SHORT $LL522@eval

; 5122 : 
; 5123 :           for(;;)
; 5124 :           {  int d;
; 5125 :             
; 5126 :             // first, calculate destination spot
; 5127 :             int size;  // of slice so far, in items
; 5128 :             for ( i = alvalue->dim-1, size = 1, poffset = 0 ; i >= lowdim ; i-- )

	mov	ecx, DWORD PTR _node$[ebp]
$LN520@eval:

; 5131 :             }
; 5132 : 
; 5133 :             switch ( alvalue->datatype )

	mov	edx, DWORD PTR _alvalue$92357[ebp]
	mov	eax, DWORD PTR [edx+8]
	dec	eax
	je	$LN517@eval
	dec	eax
	je	$LN487@eval
	sub	eax, 9
	jne	$LN488@eval

; 5219 : 
; 5220 :               case STRING_TYPE:
; 5221 :               { char **pp = (char**)pbase + poffset;
; 5222 :                 
; 5223 : 
; 5224 :                 switch ( node->op1.assigntype )

	cmp	DWORD PTR [ecx+32], 30001		; 00007531H
	mov	eax, DWORD PTR _pbase$92359[ebp]
	lea	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _pp$92456[ebp], edx
	je	SHORT $LN454@eval

; 5239 :                      break;
; 5240 :                    }
; 5241 :                   default: 
; 5242 :                     kb_error(2665,"Invalid string assignment operator; only plain assignment allowed.\n",
; 5243 :                       RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EE@BENIIKAP@Invalid?5string?5assignment?5operat@
	push	2665					; 00000a69H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	$LN488@eval
$LN454@eval:

; 5225 :                 { case ASSIGN_OP:
; 5226 :                    { char **ppp = (char**)prevpp; 

	mov	eax, DWORD PTR _prevpp$92364[ebp]

; 5227 :                      for ( ; ppp != pp ; ppp++ )  // fill with 0 since last spot

	cmp	eax, edx
	je	SHORT $LN451@eval
	npad	8
$LL453@eval:

; 5228 :                        *ppp = 0;

	mov	DWORD PTR [eax], 0
	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL453@eval
$LN451@eval:

; 5229 :                      for ( i = 0; (i < lastsize) && (*spot != ARRAYINIT_MARKER); i++ )

	cmp	DWORD PTR _lastsize$92361[ebp], 0
	mov	DWORD PTR _i$[ebp], 0
	jle	$LN448@eval
$LN450@eval:
	fld	QWORD PTR [esi]
	fld	QWORD PTR __real@7e0bbe3ac8d3bd70
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN448@eval

; 5230 :                      { char **cspot = (char**)spot;
; 5231 :                        char *s = kb_realloc(*pp,strlen(*cspot)+2);

	mov	eax, DWORD PTR [esi]
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL2869@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2869@eval
	mov	ecx, DWORD PTR _pp$92456[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx]
	push	5231					; 0000146fH
	push	OFFSET ??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@
	add	eax, 2
	push	eax
	push	edx
	call	_KB_realloc

; 5232 :                        strcpy(s,*cspot);

	mov	edx, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	mov	edi, eax
	npad	4
$LL2342@eval:
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax], cl
	inc	edx
	inc	eax
	test	cl, cl
	jne	SHORT $LL2342@eval

; 5233 :                        *(pp++) = s;

	mov	eax, DWORD PTR _pp$92456[ebp]
	mov	DWORD PTR [eax], edi
	add	eax, 4
	mov	DWORD PTR _pp$92456[ebp], eax
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax

; 5234 :                        spot++;

	add	esi, 8
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _lastsize$92361[ebp]
	jl	SHORT $LN450@eval
$LN448@eval:

; 5235 :                      }
; 5236 :                      for ( ; i < lastsize ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _lastsize$92361[ebp]
	jge	SHORT $LN447@eval
	mov	edx, DWORD PTR _lastsize$92361[ebp]
	mov	edi, DWORD PTR _pp$92456[ebp]
	sub	edx, eax
	xor	eax, eax
	mov	ecx, edx
	rep stosd
	mov	eax, DWORD PTR _pp$92456[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _pp$92456[ebp], ecx
$LN447@eval:

; 5237 :                        *(pp++) = 0;
; 5238 :                      prevpp = pp;

	mov	edx, DWORD PTR _pp$92456[ebp]
	mov	DWORD PTR _prevpp$92364[ebp], edx

; 5244 :                 }
; 5245 :               }
; 5246 :               break; /* end STRING_TYPE */

	jmp	$LN488@eval
$LN487@eval:

; 5172 :                      break;
; 5173 : 
; 5174 :                  }
; 5175 :                 break; /* end REAL_TYPE */
; 5176 :               }
; 5177 : 
; 5178 :               case INTEGER_TYPE:
; 5179 :               { 
; 5180 :                 int *pp = (int*)pbase + poffset;

	mov	eax, DWORD PTR _pbase$92359[ebp]
	lea	edi, DWORD PTR [eax+edi*4]

; 5181 : 
; 5182 :                 switch ( node->op1.assigntype )

	mov	eax, DWORD PTR [ecx+32]
	add	eax, -30001				; ffff8acfH
	mov	DWORD PTR _pp$92415[ebp], edi
	cmp	eax, 4
	ja	$LN488@eval
	jmp	DWORD PTR $LN4046@eval[eax*4]
$LN484@eval:

; 5183 :                 { case ASSIGN_OP:
; 5184 :                    { int *ppp = (int*)prevpp; 

	mov	eax, DWORD PTR _prevpp$92364[ebp]

; 5185 :                      for ( ; ppp != pp ; ppp++ )  // fill with 0 since last spot

	cmp	eax, edi
	je	SHORT $LN481@eval
	npad	10
$LL483@eval:

; 5186 :                        *ppp = 0;

	mov	DWORD PTR [eax], 0
	add	eax, 4
	cmp	eax, edi
	jne	SHORT $LL483@eval
$LN481@eval:

; 5187 :                      for ( i = 0; (i < lastsize) && (*spot != ARRAYINIT_MARKER); i++ )

	xor	edi, edi
	cmp	edi, DWORD PTR _lastsize$92361[ebp]
	jge	$LN477@eval
$LN480@eval:
	fld	QWORD PTR [esi]
	fld	QWORD PTR __real@7e0bbe3ac8d3bd70
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN478@eval

; 5188 :                        *(pp++) = (int)floor(*(spot++));

	fld	QWORD PTR [esi]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	add	esi, 8
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, DWORD PTR _pp$92415[ebp]
	mov	DWORD PTR [ecx], eax
	add	ecx, 4
	inc	edi
	mov	DWORD PTR _pp$92415[ebp], ecx
	cmp	edi, DWORD PTR _lastsize$92361[ebp]
	jl	SHORT $LN480@eval
$LN478@eval:

; 5189 :                      for ( ; i < lastsize ; i++ )

	cmp	edi, DWORD PTR _lastsize$92361[ebp]
	jge	SHORT $LN477@eval
	mov	edx, DWORD PTR _lastsize$92361[ebp]
	sub	edx, edi
	mov	edi, DWORD PTR _pp$92415[ebp]
	mov	ecx, edx
	xor	eax, eax
	rep stosd
	mov	ecx, DWORD PTR _pp$92415[ebp]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _pp$92415[ebp], edx
$LN477@eval:

; 5190 :                        *(pp++) = 0;
; 5191 :                      prevpp = pp;

	mov	eax, DWORD PTR _pp$92415[ebp]
	mov	DWORD PTR _prevpp$92364[ebp], eax

; 5192 :                      break;

	jmp	$LN488@eval
$LN474@eval:

; 5193 :                    }
; 5194 :                   case PLUSASSIGN_OP:
; 5195 :                      for ( i = 0; (i < lastsize) && (*spot != ARRAYINIT_MARKER); i++ )

	xor	edi, edi
	cmp	DWORD PTR _lastsize$92361[ebp], edi
	jle	$LN488@eval
$LN473@eval:
	fld	QWORD PTR [esi]
	fld	QWORD PTR __real@7e0bbe3ac8d3bd70
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN488@eval

; 5196 :                        *(pp++) += (int)floor(*(spot++));

	fld	QWORD PTR [esi]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	add	esi, 8
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, DWORD PTR _pp$92415[ebp]
	add	DWORD PTR [ecx], eax
	add	ecx, 4
	inc	edi
	mov	DWORD PTR _pp$92415[ebp], ecx
	cmp	edi, DWORD PTR _lastsize$92361[ebp]
	jl	SHORT $LN473@eval

; 5197 :                      break;

	jmp	$LN488@eval
$LN470@eval:

; 5198 :                   case SUBASSIGN_OP:
; 5199 :                      for ( i = 0; (i < lastsize) && (*spot != ARRAYINIT_MARKER); i++ )

	xor	edi, edi
	cmp	DWORD PTR _lastsize$92361[ebp], edi
	jle	$LN488@eval
$LN469@eval:
	fld	QWORD PTR [esi]
	fld	QWORD PTR __real@7e0bbe3ac8d3bd70
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN488@eval

; 5200 :                        *(pp++) -= (int)floor(*(spot++));

	fld	QWORD PTR [esi]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	add	esi, 8
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, DWORD PTR _pp$92415[ebp]
	sub	DWORD PTR [ecx], eax
	add	ecx, 4
	inc	edi
	mov	DWORD PTR _pp$92415[ebp], ecx
	cmp	edi, DWORD PTR _lastsize$92361[ebp]
	jl	SHORT $LN469@eval

; 5201 :                      break;                        

	jmp	$LN488@eval
$LN466@eval:

; 5202 :                   case MULTASSIGN_OP:
; 5203 :                      for ( i = 0; (i < lastsize) && (*spot != ARRAYINIT_MARKER); i++ )

	xor	edi, edi
	cmp	DWORD PTR _lastsize$92361[ebp], edi
	jle	$LN488@eval
$LN465@eval:
	fld	QWORD PTR [esi]
	fld	QWORD PTR __real@7e0bbe3ac8d3bd70
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN488@eval

; 5204 :                        *(pp++) *= (int)floor(*(spot++));

	fld	QWORD PTR [esi]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	add	esi, 8
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, eax
	mov	eax, DWORD PTR _pp$92415[ebp]
	imul	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	inc	edi
	mov	DWORD PTR _pp$92415[ebp], eax
	cmp	edi, DWORD PTR _lastsize$92361[ebp]
	jl	SHORT $LN465@eval

; 5205 :                      break;

	jmp	$LN488@eval
$LN462@eval:

; 5206 :                   case DIVASSIGN_OP:
; 5207 :                      if ( *spot == 0.0 )

	fld	QWORD PTR [esi]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN461@eval

; 5208 :                      { sprintf(errmsg,"Division by zero.\n");

	push	OFFSET ??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 5209 :                        sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 5210 :                           file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL2870@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2870@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 5211 :                        kb_error(4678,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4678					; 00001246H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN461@eval:

; 5212 :                      }
; 5213 :                      for ( i = 0; (i < lastsize) && (*spot != ARRAYINIT_MARKER); i++ )

	xor	edi, edi
	cmp	DWORD PTR _lastsize$92361[ebp], edi
	jle	$LN488@eval
$LN460@eval:
	fld	QWORD PTR [esi]
	fld	QWORD PTR __real@7e0bbe3ac8d3bd70
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN488@eval

; 5214 :                        *(pp++) /= (int)floor(*(spot++));

	fld	QWORD PTR [esi]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	add	esi, 8
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	edx, DWORD PTR _pp$92415[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx]
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR _pp$92415[ebp]
	add	ecx, 4
	inc	edi
	mov	DWORD PTR _pp$92415[ebp], ecx
	mov	DWORD PTR [ecx-4], eax
	cmp	edi, DWORD PTR _lastsize$92361[ebp]
	jl	SHORT $LN460@eval

; 5215 :                      break;
; 5216 :                 }
; 5217 :               } 
; 5218 :               break; /* end INTEGER_TYPE */

	jmp	$LN488@eval
$LN517@eval:

; 5134 :             { case REAL_TYPE:
; 5135 :               { REAL *pp = (REAL*)pbase + poffset;

	mov	eax, DWORD PTR _pbase$92359[ebp]
	lea	edi, DWORD PTR [eax+edi*8]

; 5136 : 
; 5137 :                 switch ( node->op1.assigntype )

	mov	eax, DWORD PTR [ecx+32]
	add	eax, -30001				; ffff8acfH
	mov	DWORD PTR _pp$92379[ebp], edi
	cmp	eax, 4
	ja	$LN488@eval
	jmp	DWORD PTR $LN4047@eval[eax*4]
$LN514@eval:

; 5138 :                 { case ASSIGN_OP:
; 5139 :                    { REAL *ppp = (REAL*)prevpp; 

	mov	eax, DWORD PTR _prevpp$92364[ebp]

; 5140 :                      for ( ; ppp != pp ; ppp++ )  // fill with 0 since last spot

	cmp	eax, edi
	je	SHORT $LN511@eval
	fldz
$LN513@eval:

; 5141 :                        *ppp = 0;

	fst	QWORD PTR [eax]
	add	eax, 8
	cmp	eax, edi
	jne	SHORT $LN513@eval

; 5140 :                      for ( ; ppp != pp ; ppp++ )  // fill with 0 since last spot

	fstp	ST(0)
$LN511@eval:

; 5142 :                      for ( i = 0; (i < lastsize) && (*spot != ARRAYINIT_MARKER); i++ )

	mov	edx, DWORD PTR _lastsize$92361[ebp]
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN508@eval
	fld	QWORD PTR __real@7e0bbe3ac8d3bd70
$LN510@eval:
	fld	QWORD PTR [esi]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3489@eval

; 5143 :                        *(pp++) = *(spot++);

	fld	QWORD PTR [esi]
	add	edi, 8
	fstp	QWORD PTR [edi-8]
	inc	ecx
	add	esi, 8
	mov	DWORD PTR _pp$92379[ebp], edi
	cmp	ecx, edx
	jl	SHORT $LN510@eval
$LN3489@eval:

; 5142 :                      for ( i = 0; (i < lastsize) && (*spot != ARRAYINIT_MARKER); i++ )

	fstp	ST(0)
$LN508@eval:

; 5144 :                      for ( ; i < lastsize ; i++ )

	cmp	ecx, edx
	jge	SHORT $LN507@eval
	mov	eax, DWORD PTR _lastsize$92361[ebp]
	mov	edx, DWORD PTR _pp$92379[ebp]
	sub	eax, ecx
	mov	ecx, eax
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	mov	DWORD PTR tv488[ebp], eax
	mov	edi, edx
	xor	eax, eax
	rep stosd
	mov	ecx, DWORD PTR tv488[ebp]
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _pp$92379[ebp], edx
	mov	edi, edx
$LN507@eval:

; 5145 :                        *(pp++) = 0;
; 5146 :                      prevpp = pp;

	mov	DWORD PTR _prevpp$92364[ebp], edi

; 5147 :                      break;

	jmp	$LN488@eval
$LN504@eval:

; 5148 :                    }
; 5149 :                   case PLUSASSIGN_OP:
; 5150 :                      for ( i = 0; (i < lastsize) && (*spot != ARRAYINIT_MARKER); i++ )

	mov	edx, DWORD PTR _lastsize$92361[ebp]
	xor	ecx, ecx
	test	edx, edx
	jle	$LN488@eval
	fld	QWORD PTR __real@7e0bbe3ac8d3bd70
	sub	edi, esi
$LN503@eval:
	fld	QWORD PTR [esi]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN3513@eval

; 5151 :                        *(pp++) += *(spot++);

	fld	QWORD PTR [esi]
	inc	ecx
	fadd	QWORD PTR [edi+esi]
	add	esi, 8
	fstp	QWORD PTR [edi+esi-8]
	cmp	ecx, edx
	jl	SHORT $LN503@eval

; 5152 :                      break;

	jmp	$LN3513@eval
$LN500@eval:

; 5153 :                   case SUBASSIGN_OP:
; 5154 :                      for ( i = 0; (i < lastsize) && (*spot != ARRAYINIT_MARKER); i++ )

	mov	edx, DWORD PTR _lastsize$92361[ebp]
	xor	ecx, ecx
	test	edx, edx
	jle	$LN488@eval
	fld	QWORD PTR __real@7e0bbe3ac8d3bd70
$LN499@eval:
	fld	QWORD PTR [esi]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN3513@eval

; 5155 :                        *(pp++) -= *(spot++);

	fld	QWORD PTR [edi]
	inc	ecx
	fsub	QWORD PTR [esi]
	add	esi, 8
	add	edi, 8
	fstp	QWORD PTR [edi-8]
	cmp	ecx, edx
	jl	SHORT $LN499@eval

; 5156 :                      break;                        

	jmp	$LN3513@eval
$LN496@eval:

; 5157 :                   case MULTASSIGN_OP:
; 5158 :                      for ( i = 0; (i < lastsize) && (*spot != ARRAYINIT_MARKER); i++ )

	mov	edx, DWORD PTR _lastsize$92361[ebp]
	xor	ecx, ecx
	test	edx, edx
	jle	$LN488@eval
	fld	QWORD PTR __real@7e0bbe3ac8d3bd70
$LN495@eval:
	fld	QWORD PTR [esi]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN3513@eval

; 5159 :                        *(pp++) *= *(spot++);

	fld	QWORD PTR [edi]
	inc	ecx
	fmul	QWORD PTR [esi]
	add	esi, 8
	add	edi, 8
	fstp	QWORD PTR [edi-8]
	cmp	ecx, edx
	jl	SHORT $LN495@eval

; 5160 :                      break;

	jmp	$LN3513@eval
$LN492@eval:

; 5161 :                   case DIVASSIGN_OP:
; 5162 :                      if ( *spot == 0.0 )

	fld	QWORD PTR [esi]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN491@eval

; 5163 :                      {
; 5164 :                        sprintf(errmsg,"Division by zero.\n");

	push	OFFSET ??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 5165 :                        sprintf(errmsg+strlen(errmsg),
; 5166 :                           "(source file %s, line %d)\n",
; 5167 :                              file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL2871@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2871@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 5168 :                        kb_error(4677,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4677					; 00001245H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN491@eval:

; 5169 :                      }
; 5170 :                      for ( i = 0; (i < lastsize) && (*spot != ARRAYINIT_MARKER); i++ )

	mov	edx, DWORD PTR _lastsize$92361[ebp]
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN488@eval
	fld	QWORD PTR __real@7e0bbe3ac8d3bd70
$LN490@eval:
	fld	QWORD PTR [esi]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3513@eval

; 5171 :                        *(pp++) /= *(spot++);

	fld	QWORD PTR [edi]
	inc	ecx
	fdiv	QWORD PTR [esi]
	add	esi, 8
	add	edi, 8
	fstp	QWORD PTR [edi-8]
	cmp	ecx, edx
	jl	SHORT $LN490@eval
$LN3513@eval:

; 5169 :                      }
; 5170 :                      for ( i = 0; (i < lastsize) && (*spot != ARRAYINIT_MARKER); i++ )

	fstp	ST(0)
$LN488@eval:

; 5247 : 
; 5248 :               kb_error(5567,"Illegal array initializer type.\n",RECOVERABLE);
; 5249 :             }         
; 5250 : 
; 5251 :             // if too many initializers, skip rest
; 5252 :             while ( *spot != ARRAYINIT_MARKER )

	fld	QWORD PTR [esi]
	fld	QWORD PTR __real@7e0bbe3ac8d3bd70
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2523@eval
$LN443@eval:
	fld	QWORD PTR [esi+8]

; 5253 :               spot++;

	add	esi, 8
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN443@eval
$LN2523@eval:

; 5254 : 
; 5255 :             // update destination pointer
; 5256 :             for(;;)
; 5257 :             { spot++;
; 5258 :               d = *(int*)(spot++) + lowdim;

	mov	ecx, DWORD PTR [esi+8]

; 5259 :               if ( d == alvalue->dim ) break;

	mov	edi, DWORD PTR _alvalue$92357[ebp]
	add	ecx, DWORD PTR _lowdim$92362[ebp]
	mov	edx, DWORD PTR [edi+4]
	add	esi, 16					; 00000010H
	mov	DWORD PTR tv20559[ebp], edx
	cmp	ecx, edx
	je	SHORT $LN3981@eval
$LN441@eval:

; 5260 :               // update pspots
; 5261 :               pspots[alvalue->dim-d-1]++;

	sub	edx, ecx
	inc	DWORD PTR _pspots$92365[ebp+edx*4-4]
	mov	eax, DWORD PTR _pspots$92365[ebp+edx*4-4]

; 5262 :               if ( pspots[alvalue->dim-d-1] == alvalue->sizes[alvalue->dim-d-1] )

	cmp	eax, DWORD PTR [edi+edx*4+20]
	jne	SHORT $LN3525@eval

; 5263 :               { // find proper marker in initializer
; 5264 :                 d++;

	mov	edx, DWORD PTR _lowdim$92362[ebp]
$LN437@eval:

; 5265 :                 while ( !((*spot == ARRAYINIT_MARKER) && (*(int*)(spot+1) == d-lowdim)) )

	fld	QWORD PTR [esi]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN435@eval
	lea	eax, DWORD PTR [ecx+1]
	sub	eax, edx
	cmp	DWORD PTR [esi+8], eax
	je	SHORT $LN436@eval
$LN435@eval:

; 5266 :                   spot++;

	add	esi, 8
	jmp	SHORT $LN437@eval
$LN436@eval:

; 5254 : 
; 5255 :             // update destination pointer
; 5256 :             for(;;)
; 5257 :             { spot++;
; 5258 :               d = *(int*)(spot++) + lowdim;

	mov	ecx, DWORD PTR [esi+8]
	add	ecx, edx

; 5259 :               if ( d == alvalue->dim ) break;

	mov	edx, DWORD PTR tv20559[ebp]
	add	esi, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LN441@eval
	jmp	SHORT $LN3981@eval
$LN3525@eval:
	mov	edx, DWORD PTR tv20559[ebp]
$LN3981@eval:

; 5262 :               if ( pspots[alvalue->dim-d-1] == alvalue->sizes[alvalue->dim-d-1] )

	fstp	ST(0)

; 5267 :               }
; 5268 :               else break;
; 5269 :             }
; 5270 :             if ( d == alvalue->dim ) break;  // all done

	cmp	ecx, edx
	je	SHORT $LN2618@eval

; 5271 : 
; 5272 :             // reset inner slice indices
; 5273 :             for ( i = alvalue->dim-d ; i < alvalue->dim ; i++ )

	mov	eax, edx
	sub	eax, ecx
	cmp	eax, edx
	jge	$LL3076@eval
	mov	ecx, edx
	lea	edi, DWORD PTR _pspots$92365[ebp+eax*4]
	sub	ecx, eax
	xor	eax, eax
	rep stosd

; 5274 :                pspots[i] = 0;                     
; 5275 : 
; 5276 :           } // end for

	jmp	$LL3076@eval
$LN2618@eval:

; 5277 : 
; 5278 :           // pop stuff
; 5279 :           stacktop -= node->op3.argcount + 1;  // +1 for destination pointer

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	mov	eax, -8					; fffffff8H
	sub	eax, edx
	add	DWORD PTR [ebx+48], eax

; 5280 : 
; 5281 :           if ( node->flags & RECALC_FLAG )
; 5282 :             recalc_flag = 1;
; 5283 :           if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'
; 5284 :              dont_resize_flag = 1;
; 5285 : 
; 5286 :         } /* end ARRAYEXPR_ASSIGN */
; 5287 :         break;

	jmp	$LN3977@eval
$LN427@eval:

; 5288 : 
; 5289 :       case ARRAY_ASSIGNOP_S_X_A_NODE:
; 5290 :         { struct array *alvalue= get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	edi, DWORD PTR _localstack$[ebp]
	mov	ecx, DWORD PTR _localbase$[ebp]
	mov	edx, DWORD PTR [ebx+40]
	mov	eax, DWORD PTR _node$[ebp]
	add	edi, edi
	add	edi, edi
	push	ecx
	mov	ecx, DWORD PTR [eax+136]
	add	edi, edi
	add	edx, edi
	push	edx
	push	ecx
	call	_get_name_arrayptr

; 5291 :           struct array *arvalue= get_name_arrayptr(node->op3.name_id,newstack + localstack,localbase);

	mov	edx, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR [ebx+40]
	push	edx
	mov	edx, DWORD PTR [ecx+140]
	add	eax, edi
	push	eax
	push	edx
	call	_get_name_arrayptr
	mov	edx, eax

; 5292 :           int inx[100]; /* keep track of indices */
; 5293 :           char *p,*q;
; 5294 :           int j,k;
; 5295 :           char *pspots[MAXARRAYDIMS],*qspots[MAXARRAYDIMS];
; 5296 :           int pstride[MAXARRAYDIMS],qstride[MAXARRAYDIMS];
; 5297 :           int minsize[MAXARRAYDIMS],lastsize;
; 5298 :           REAL scalar;
; 5299 :           int lcount = node[node->left].op5.indexcount;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 168				; 000000a8H
	mov	ecx, DWORD PTR [ecx+eax+152]
	mov	DWORD PTR _lcount$92516[ebp], ecx

; 5300 :           int rcount = node[node[node->right].right].op5.indexcount;

	mov	ecx, DWORD PTR [eax+8]
	imul	ecx, 168				; 000000a8H
	mov	ecx, DWORD PTR [ecx+eax+8]
	imul	ecx, 168				; 000000a8H
	mov	eax, DWORD PTR [ecx+eax+152]

; 5301 :           int dim;
; 5302 :           int pint = (alvalue->datatype == INTEGER_TYPE);

	xor	ecx, ecx
	mov	edi, 2
	add	esp, 24					; 00000018H
	cmp	DWORD PTR [esi+8], edi
	mov	DWORD PTR _rcount$92517[ebp], eax
	sete	cl

; 5303 :           int qint = (arvalue->datatype == INTEGER_TYPE);

	xor	eax, eax
	cmp	DWORD PTR [edx+8], edi

; 5304 : 
; 5305 :           /* Was checked in parser that the arrays have the same number
; 5306 :              of indices, but might be different sizes.  So do
; 5307 :              intersection. */
; 5308 :           /* pop datastarts off stack */
; 5309 :           q = *(char**)(stacktop--);
; 5310 :           scalar = *(stacktop--);
; 5311 :           p = *(char**)(stacktop--);
; 5312 : 
; 5313 :           dim = arvalue->dim - rcount;
; 5314 :           for ( i = 0 ; i < dim ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	sete	al
	mov	DWORD PTR _pint$92519[ebp], ecx
	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx-8]
	add	ecx, -16				; fffffff0H
	mov	DWORD PTR _qint$92520[ebp], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [ebx+48], ecx
	mov	edi, DWORD PTR [ecx]
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], ecx
	mov	ecx, DWORD PTR [edx+4]
	sub	ecx, DWORD PTR _rcount$92517[ebp]
	mov	DWORD PTR _p$92505[ebp], edi
	mov	DWORD PTR _dim$92518[ebp], ecx
	test	ecx, ecx
	jle	$LN424@eval

; 5288 : 
; 5289 :       case ARRAY_ASSIGNOP_S_X_A_NODE:
; 5290 :         { struct array *alvalue= get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	ecx, DWORD PTR _lcount$92516[ebp]
	lea	ecx, DWORD PTR [esi+ecx*4+24]
	mov	DWORD PTR tv29108[ebp], ecx
	mov	ecx, DWORD PTR _rcount$92517[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4+24]
	mov	DWORD PTR tv29110[ebp], ecx
	mov	ecx, DWORD PTR _dim$92518[ebp]
	add	ecx, ecx
	add	ecx, ecx
	shr	ecx, 2
	lea	edi, DWORD PTR _qspots$92510[ebp]
	rep stosd

; 5318 :             pspots[i] = p;

	mov	ecx, DWORD PTR _dim$92518[ebp]
	mov	eax, DWORD PTR _p$92505[ebp]
	add	ecx, ecx
	add	ecx, ecx
	shr	ecx, 2
	lea	edi, DWORD PTR _pspots$92509[ebp]
	rep stosd
	mov	ecx, DWORD PTR _dim$92518[ebp]
	add	ecx, ecx
	add	ecx, ecx
	shr	ecx, 2
	xor	eax, eax
	lea	edi, DWORD PTR _inx$92504[ebp]
	rep stosd
	mov	eax, DWORD PTR _i$[ebp]
$LN426@eval:

; 5315 :           { inx[i] = 0;
; 5316 :             minsize[i] = arvalue->sizes[rcount+i] < alvalue->sizes[lcount+i] ?
; 5317 :                           arvalue->sizes[rcount+i] : alvalue->sizes[lcount+i] ;

	mov	ecx, DWORD PTR tv29110[ebp]
	mov	edi, DWORD PTR tv29108[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [edi]
	cmp	ecx, edi
	jl	SHORT $LN2344@eval
	mov	ecx, edi
$LN2344@eval:
	mov	DWORD PTR _minsize$92513[ebp+eax*4], ecx
	mov	ecx, 4
	add	DWORD PTR tv29110[ebp], ecx
	add	DWORD PTR tv29108[ebp], ecx
	inc	eax
	cmp	eax, DWORD PTR _dim$92518[ebp]
	jl	SHORT $LN426@eval
$LN424@eval:

; 5319 :             qspots[i] = q;
; 5320 :           }
; 5321 :           if ( dim >= 2 )

	mov	edi, DWORD PTR _dim$92518[ebp]
	cmp	edi, 2
	jl	$LN417@eval

; 5322 :           {
; 5323 :             pstride[dim-2] = alvalue->sizes[alvalue->dim-1]*alvalue->itemsize;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+eax*4+20]
	imul	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _pstride$92511[ebp+edi*4-8], ecx

; 5324 :             qstride[dim-2] = arvalue->sizes[arvalue->dim-1]*arvalue->itemsize;

	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4+20]
	imul	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _qstride$92512[ebp+edi*4-8], ecx

; 5325 :             for ( i = alvalue->dim - 3 ; i >= lcount ; i-- )

	mov	ecx, DWORD PTR _lcount$92516[ebp]
	add	eax, -3					; fffffffdH
	cmp	eax, ecx
	jl	SHORT $LN420@eval

; 5322 :           {
; 5323 :             pstride[dim-2] = alvalue->sizes[alvalue->dim-1]*alvalue->itemsize;

	lea	esi, DWORD PTR [esi+eax*4+28]
$LN422@eval:

; 5326 :               pstride[i] = pstride[i+1]*alvalue->sizes[i+1];

	mov	edi, DWORD PTR _pstride$92511[ebp+eax*4+4]
	imul	edi, DWORD PTR [esi]
	mov	DWORD PTR _pstride$92511[ebp+eax*4], edi
	dec	eax
	sub	esi, 4
	cmp	eax, ecx
	jge	SHORT $LN422@eval

; 5325 :             for ( i = alvalue->dim - 3 ; i >= lcount ; i-- )

	mov	edi, DWORD PTR _dim$92518[ebp]
$LN420@eval:

; 5327 :             for ( i = arvalue->dim - 3 ; i >= rcount ; i-- )

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _rcount$92517[ebp]
	add	eax, -3					; fffffffdH
	cmp	eax, ecx
	jl	SHORT $LN417@eval
	lea	edx, DWORD PTR [edx+eax*4+28]
$LN419@eval:

; 5328 :               qstride[i] = qstride[i+1]*arvalue->sizes[i+1];

	mov	esi, DWORD PTR _qstride$92512[ebp+eax*4+4]
	imul	esi, DWORD PTR [edx]
	mov	DWORD PTR _qstride$92512[ebp+eax*4], esi
	dec	eax
	sub	edx, 4
	cmp	eax, ecx
	jge	SHORT $LN419@eval
$LN417@eval:

; 5329 :             
; 5330 :           }
; 5331 :           lastsize = minsize[dim-1];

	mov	edx, DWORD PTR _minsize$92513[ebp+edi*4-4]

; 5332 : 
; 5333 :           p = pspots[0];

	mov	eax, DWORD PTR _pspots$92509[ebp]

; 5334 :           q = qspots[0];

	mov	ecx, DWORD PTR _qspots$92510[ebp]
	add	edi, -2					; fffffffeH
	mov	DWORD PTR _lastsize$92514[ebp], edx
	mov	DWORD PTR _p$92505[ebp], eax
	mov	DWORD PTR _q$92506[ebp], ecx

; 5388 :               { p = pspots[j];

	mov	DWORD PTR tv20730[ebp], edi
$LN416@eval:

; 5335 :           do
; 5336 :           { /* do a row */
; 5337 : 
; 5338 :                 int *pi = (int*)p;
; 5339 :                 REAL *pr = (REAL*)p;
; 5340 :                 int *qi = (int*)q;
; 5341 :                 REAL *qr = (REAL*)q;
; 5342 :                 
; 5343 :                  switch ( node->op1.assigntype )

	mov	eax, DWORD PTR _p$92505[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR _q$92506[ebp]
	mov	ecx, eax
	mov	DWORD PTR _pi$92536[ebp], eax
	mov	eax, DWORD PTR [edx+32]
	add	eax, -30001				; ffff8acfH
	mov	DWORD PTR _pr$92538[ebp], ecx
	mov	edi, esi
	cmp	eax, 4
	ja	$LN384@eval
	jmp	DWORD PTR $LN4048@eval[eax*4]
$LN411@eval:

; 5344 :                 { case ASSIGN_OP:
; 5345 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	mov	eax, DWORD PTR _lastsize$92514[ebp]
	test	eax, eax
	jle	$LN384@eval
	mov	DWORD PTR tv11163[ebp], eax
	mov	eax, DWORD PTR _qint$92520[ebp]
$LN410@eval:

; 5346 :                        if ( pint )

	cmp	DWORD PTR _pint$92519[ebp], 0
	je	SHORT $LN407@eval

; 5347 :                          *(pi++) = (int)((qint ? *(qi++) : *(qr++))*scalar);

	test	eax, eax
	je	SHORT $LN2345@eval
	fild	DWORD PTR [edi]
	add	edi, 4
	jmp	SHORT $LN2346@eval
$LN2345@eval:
	fld	QWORD PTR [esi]
	add	esi, 8
$LN2346@eval:
	fmul	ST(0), ST(1)
	call	__ftol2_sse
	mov	ecx, DWORD PTR _pi$92536[ebp]
	mov	DWORD PTR [ecx], eax

; 5348 :                        else

	mov	eax, DWORD PTR _qint$92520[ebp]
	add	ecx, 4
	mov	DWORD PTR _pi$92536[ebp], ecx
	mov	ecx, DWORD PTR _pr$92538[ebp]
	jmp	SHORT $LN409@eval
$LN407@eval:

; 5349 :                          *(pr++) = (qint ? *(qi++) : *(qr++))*scalar;

	test	eax, eax
	je	SHORT $LN2347@eval
	fild	DWORD PTR [edi]
	add	edi, 4
	jmp	SHORT $LN2348@eval
$LN2347@eval:
	fld	QWORD PTR [esi]
	add	esi, 8
$LN2348@eval:
	fmul	ST(0), ST(1)
	add	ecx, 8
	mov	DWORD PTR _pr$92538[ebp], ecx
	fstp	QWORD PTR [ecx-8]
$LN409@eval:

; 5344 :                 { case ASSIGN_OP:
; 5345 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	dec	DWORD PTR tv11163[ebp]
	jne	SHORT $LN410@eval

; 5350 :                      break;

	jmp	$LN384@eval
$LN405@eval:

; 5351 :                   case PLUSASSIGN_OP:
; 5352 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	mov	eax, DWORD PTR _lastsize$92514[ebp]
	test	eax, eax
	jle	$LN384@eval
	mov	DWORD PTR tv3265[ebp], eax
	mov	eax, DWORD PTR _qint$92520[ebp]
$LN404@eval:

; 5353 :                        if ( pint )

	cmp	DWORD PTR _pint$92519[ebp], 0
	je	SHORT $LN401@eval

; 5354 :                          *(pi++) += (int)((qint ? *(qi++) : *(qr++))*scalar);

	test	eax, eax
	je	SHORT $LN2349@eval
	fild	DWORD PTR [edi]
	add	edi, 4
	jmp	SHORT $LN2350@eval
$LN2349@eval:
	fld	QWORD PTR [esi]
	add	esi, 8
$LN2350@eval:
	fmul	ST(0), ST(1)
	call	__ftol2_sse
	mov	ecx, DWORD PTR _pi$92536[ebp]
	add	DWORD PTR [ecx], eax

; 5355 :                        else

	mov	eax, DWORD PTR _qint$92520[ebp]
	add	ecx, 4
	mov	DWORD PTR _pi$92536[ebp], ecx
	mov	ecx, DWORD PTR _pr$92538[ebp]
	jmp	SHORT $LN403@eval
$LN401@eval:

; 5356 :                          *(pr++) += (qint ? *(qi++) : *(qr++))*scalar;

	test	eax, eax
	je	SHORT $LN2351@eval
	fild	DWORD PTR [edi]
	add	edi, 4
	jmp	SHORT $LN2352@eval
$LN2351@eval:
	fld	QWORD PTR [esi]
	add	esi, 8
$LN2352@eval:
	fmul	ST(0), ST(1)
	add	ecx, 8
	mov	DWORD PTR _pr$92538[ebp], ecx
	fadd	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
$LN403@eval:

; 5351 :                   case PLUSASSIGN_OP:
; 5352 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	dec	DWORD PTR tv3265[ebp]
	jne	SHORT $LN404@eval

; 5357 :                      break;

	jmp	$LN384@eval
$LN399@eval:

; 5358 :                   case SUBASSIGN_OP:
; 5359 :                     for ( i = 0 ; i < lastsize ; i++ ) 

	mov	eax, DWORD PTR _lastsize$92514[ebp]
	test	eax, eax
	jle	$LN384@eval
	mov	DWORD PTR tv3308[ebp], eax
	mov	eax, DWORD PTR _qint$92520[ebp]
$LN398@eval:

; 5360 :                        if ( pint )

	cmp	DWORD PTR _pint$92519[ebp], 0
	je	SHORT $LN395@eval

; 5361 :                          *(pi++) -= (int)((qint ? *(qi++) : *(qr++))*scalar);

	test	eax, eax
	je	SHORT $LN2353@eval
	fild	DWORD PTR [edi]
	add	edi, 4
	jmp	SHORT $LN2354@eval
$LN2353@eval:
	fld	QWORD PTR [esi]
	add	esi, 8
$LN2354@eval:
	fmul	ST(0), ST(1)
	call	__ftol2_sse
	mov	ecx, DWORD PTR _pi$92536[ebp]
	sub	DWORD PTR [ecx], eax

; 5362 :                        else

	mov	eax, DWORD PTR _qint$92520[ebp]
	add	ecx, 4
	mov	DWORD PTR _pi$92536[ebp], ecx
	mov	ecx, DWORD PTR _pr$92538[ebp]
	jmp	SHORT $LN397@eval
$LN395@eval:

; 5363 :                          *(pr++) -= (qint ? *(qi++) : *(qr++))*scalar;

	test	eax, eax
	je	SHORT $LN2355@eval
	fild	DWORD PTR [edi]
	add	edi, 4
	jmp	SHORT $LN2356@eval
$LN2355@eval:
	fld	QWORD PTR [esi]
	add	esi, 8
$LN2356@eval:
	fmul	ST(0), ST(1)
	add	ecx, 8
	mov	DWORD PTR _pr$92538[ebp], ecx
	fsubr	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
$LN397@eval:

; 5358 :                   case SUBASSIGN_OP:
; 5359 :                     for ( i = 0 ; i < lastsize ; i++ ) 

	dec	DWORD PTR tv3308[ebp]
	jne	SHORT $LN398@eval

; 5364 :                      break;                       

	jmp	$LN384@eval
$LN393@eval:

; 5365 :                   case MULTASSIGN_OP:
; 5366 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	mov	eax, DWORD PTR _lastsize$92514[ebp]
	test	eax, eax
	jle	$LN384@eval
	mov	DWORD PTR tv11150[ebp], eax
	mov	eax, DWORD PTR _qint$92520[ebp]
$LN392@eval:

; 5367 :                        if ( pint )

	cmp	DWORD PTR _pint$92519[ebp], 0
	je	SHORT $LN389@eval

; 5368 :                          *(pi++) *= (int)((qint ? *(qi++) : *(qr++))*scalar);

	test	eax, eax
	je	SHORT $LN2357@eval
	fild	DWORD PTR [edi]
	add	edi, 4
	jmp	SHORT $LN2358@eval
$LN2357@eval:
	fld	QWORD PTR [esi]
	add	esi, 8
$LN2358@eval:
	fmul	ST(0), ST(1)
	call	__ftol2_sse
	mov	ecx, eax
	mov	eax, DWORD PTR _pi$92536[ebp]
	imul	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax], ecx

; 5369 :                        else

	mov	ecx, DWORD PTR _pr$92538[ebp]
	add	eax, 4
	mov	DWORD PTR _pi$92536[ebp], eax
	mov	eax, DWORD PTR _qint$92520[ebp]
	jmp	SHORT $LN391@eval
$LN389@eval:

; 5370 :                          *(pr++) *= (qint ? *(qi++) : *(qr++))*scalar;

	test	eax, eax
	je	SHORT $LN2359@eval
	fild	DWORD PTR [edi]
	add	edi, 4
	jmp	SHORT $LN2360@eval
$LN2359@eval:
	fld	QWORD PTR [esi]
	add	esi, 8
$LN2360@eval:
	fmul	ST(0), ST(1)
	add	ecx, 8
	mov	DWORD PTR _pr$92538[ebp], ecx
	fmul	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
$LN391@eval:

; 5365 :                   case MULTASSIGN_OP:
; 5366 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	dec	DWORD PTR tv11150[ebp]
	jne	SHORT $LN392@eval

; 5371 :                      break;

	jmp	$LN384@eval
$LN387@eval:

; 5372 :                   case DIVASSIGN_OP:
; 5373 :                     for ( i = 0 ; i < lastsize ; i++ ) 

	mov	eax, DWORD PTR _lastsize$92514[ebp]
	test	eax, eax
	jle	$LN384@eval
	mov	DWORD PTR tv11133[ebp], eax
	mov	eax, DWORD PTR _qint$92520[ebp]
$LN386@eval:

; 5374 :                        if ( pint )

	cmp	DWORD PTR _pint$92519[ebp], 0
	je	SHORT $LN383@eval

; 5375 :                        { *pi = (int)(*pi/((qint ? *(qi++) : *(qr++))*scalar));

	test	eax, eax
	je	SHORT $LN2361@eval
	fild	DWORD PTR [edi]
	add	edi, 4
	jmp	SHORT $LN2362@eval
$LN2361@eval:
	fld	QWORD PTR [esi]
	add	esi, 8
$LN2362@eval:
	mov	edx, DWORD PTR _pi$92536[ebp]
	fild	DWORD PTR [edx]
	fld	ST(2)
	fmulp	ST(2), ST(0)
	fdivrp	ST(1), ST(0)
	call	__ftol2_sse
	mov	ecx, DWORD PTR _pi$92536[ebp]
	mov	DWORD PTR [ecx], eax

; 5376 :                           pi++;
; 5377 :                        }
; 5378 :                        else

	mov	eax, DWORD PTR _qint$92520[ebp]
	add	ecx, 4
	mov	DWORD PTR _pi$92536[ebp], ecx
	mov	ecx, DWORD PTR _pr$92538[ebp]
	jmp	SHORT $LN385@eval
$LN383@eval:

; 5379 :                          *(pr++) /= (qint ? *(qi++) : *(qr++))*scalar;

	test	eax, eax
	je	SHORT $LN2363@eval
	fild	DWORD PTR [edi]
	add	edi, 4
	jmp	SHORT $LN2364@eval
$LN2363@eval:
	fld	QWORD PTR [esi]
	add	esi, 8
$LN2364@eval:
	fmul	ST(0), ST(1)
	add	ecx, 8
	mov	DWORD PTR _pr$92538[ebp], ecx
	fdivr	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
$LN385@eval:

; 5372 :                   case DIVASSIGN_OP:
; 5373 :                     for ( i = 0 ; i < lastsize ; i++ ) 

	dec	DWORD PTR tv11133[ebp]
	jne	SHORT $LN386@eval
$LN384@eval:

; 5380 :                      break;
; 5381 :                 } 
; 5382 : 
; 5383 :             /* increment pointers */
; 5384 :             for ( j = dim-2 ; j >= 0 ; j-- )

	mov	edx, DWORD PTR tv20730[ebp]
	test	edx, edx
	js	$LN3983@eval
	mov	esi, 1
$LN381@eval:

; 5385 :             { pspots[j] += pstride[j];

	mov	eax, DWORD PTR _pstride$92511[ebp+edx*4]
	add	DWORD PTR _pspots$92509[ebp+edx*4], eax

; 5386 :               qspots[j] += qstride[j];

	mov	eax, DWORD PTR _qstride$92512[ebp+edx*4]
	add	DWORD PTR _qspots$92510[ebp+edx*4], eax

; 5387 :               if ( ++inx[j] < minsize[j] )

	add	DWORD PTR _inx$92504[ebp+edx*4], esi
	mov	eax, DWORD PTR _inx$92504[ebp+edx*4]
	mov	ecx, DWORD PTR _pspots$92509[ebp+edx*4]
	mov	edi, DWORD PTR _qspots$92510[ebp+edx*4]
	cmp	eax, DWORD PTR _minsize$92513[ebp+edx*4]
	jl	SHORT $LN2619@eval

; 5392 :                   qspots[k] = q;
; 5393 :                 }
; 5394 :                 break;
; 5395 :               }
; 5396 :               inx[j] = 0 ;

	mov	DWORD PTR _inx$92504[ebp+edx*4], 0
	sub	edx, esi
	jns	SHORT $LN381@eval

; 6334 :                 a = NULL;
; 6335 :               }
; 6336 :             }
; 6337 :          }
; 6338 :         if ( this_frame->flags & BASE_OF_EVAL )

	jmp	SHORT $LN415@eval
$LN2619@eval:

; 5389 :                 q = qspots[j];
; 5390 :                 for ( k = j+1 ; k < dim-1 ; k++ )

	mov	eax, DWORD PTR _dim$92518[ebp]
	mov	DWORD PTR _p$92505[ebp], ecx
	lea	ecx, DWORD PTR [edx+1]
	dec	eax
	mov	DWORD PTR _q$92506[ebp], edi
	cmp	ecx, eax
	jge	SHORT $LN415@eval

; 5388 :               { p = pspots[j];

	sub	eax, ecx
	lea	esi, DWORD PTR _pspots$92509[ebp+ecx*4]
	add	eax, eax
	lea	edi, DWORD PTR _qspots$92510[ebp+ecx*4]
	mov	DWORD PTR tv29433[ebp], esi
	lea	esi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _q$92506[ebp]
	mov	ecx, esi
	shr	ecx, 2
	rep stosd

; 5391 :                 { pspots[k] = p;

	mov	eax, DWORD PTR _p$92505[ebp]
	mov	edi, DWORD PTR tv29433[ebp]
	mov	ecx, esi
	shr	ecx, 2
	rep stosd
$LN415@eval:

; 5397 :             }  
; 5398 :            } while ( j >= 0 );    

	test	edx, edx
	jns	$LN416@eval
$LN3983@eval:
	fstp	ST(0)

; 5399 :  
; 5400 :           if ( node->flags & RECALC_FLAG )
; 5401 :             recalc_flag = 1;
; 5402 :           if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'
; 5403 :             dont_resize_flag = 1;
; 5404 : 
; 5405 :           break;

	jmp	$LN3977@eval
$LN372@eval:

; 5406 :         } /* end ARRAY_ASSIGNOP_S_X_A_ */
; 5407 : 
; 5408 :       case ARRAY_ASSIGNOP_A_P_A_NODE:
; 5409 :       case ARRAY_ASSIGNOP_A_S_A_NODE:
; 5410 :         { 
; 5411 :           struct array *alvalue= get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	edi, DWORD PTR _localstack$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	esi, DWORD PTR _localbase$[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+136]
	add	edi, edi
	add	edi, edi
	add	edi, edi
	push	esi
	add	ecx, edi
	push	ecx
	push	eax
	call	_get_name_arrayptr

; 5412 :           struct array *arvalue= get_name_arrayptr(node->op3.name_id,newstack + localstack,localbase);

	mov	ecx, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR _node$[ebp]
	push	esi
	add	ecx, edi
	mov	DWORD PTR _alvalue$92593[ebp], eax
	mov	eax, DWORD PTR [edx+140]
	push	ecx
	push	eax
	call	_get_name_arrayptr

; 5413 :           struct array *asvalue= get_name_arrayptr(node->op4.name_id,newstack + localstack,localbase);

	mov	ecx, DWORD PTR _localbase$[ebp]
	mov	edx, DWORD PTR [ebx+40]
	push	ecx
	mov	esi, eax
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	add	edx, edi
	push	edx
	push	ecx
	call	_get_name_arrayptr

; 5414 :           int inx[100]; /* keep track of indices */
; 5415 :           char *p,*q,*s;
; 5416 :           int j,k;
; 5417 :           char *pspots[MAXARRAYDIMS],*qspots[MAXARRAYDIMS],*sspots[MAXARRAYDIMS];
; 5418 :           int pstride[MAXARRAYDIMS],qstride[MAXARRAYDIMS],sstride[MAXARRAYDIMS];
; 5419 :           int minsize[MAXARRAYDIMS],lastsize;
; 5420 :           int lcount = node[node->left].op5.indexcount;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 168				; 000000a8H
	mov	edi, eax
	mov	eax, DWORD PTR [edx+ecx+152]
	mov	DWORD PTR _lcount$92610[ebp], eax

; 5421 :           struct treenode *rvalue_node = node + node->right;

	mov	eax, DWORD PTR [ecx+8]
	imul	eax, 168				; 000000a8H

; 5422 :           int rcount = rvalue_node[rvalue_node->left].op5.indexcount;

	mov	edx, DWORD PTR [eax+ecx+4]
	add	eax, ecx
	imul	edx, 168				; 000000a8H
	mov	edx, DWORD PTR [edx+eax+152]
	mov	DWORD PTR _rcount$92612[ebp], edx

; 5423 :           int scount = rvalue_node[rvalue_node->right].op5.indexcount;

	mov	edx, DWORD PTR [eax+8]
	imul	edx, 168				; 000000a8H
	mov	eax, DWORD PTR [edx+eax+152]

; 5424 :           int dim;
; 5425 :           int pint = (alvalue->datatype == INTEGER_TYPE);

	xor	edx, edx
	add	esp, 36					; 00000024H
	mov	DWORD PTR _scount$92613[ebp], eax
	mov	eax, DWORD PTR _alvalue$92593[ebp]
	cmp	DWORD PTR [eax+8], 2

; 5426 :           int qint = (arvalue->datatype == INTEGER_TYPE);

	mov	eax, 2
	sete	dl
	mov	DWORD PTR _asvalue$92595[ebp], edi
	mov	DWORD PTR _pint$92615[ebp], edx
	xor	edx, edx
	cmp	DWORD PTR [esi+8], eax
	sete	dl
	mov	DWORD PTR _qint$92616[ebp], edx

; 5427 :           int sint = (asvalue->datatype == INTEGER_TYPE);

	xor	edx, edx
	cmp	DWORD PTR [edi+8], eax
	sete	dl

; 5428 :           REAL sign = (node->type==ARRAY_ASSIGNOP_A_P_A_NODE) ? 1.0 : -1.0;

	cmp	DWORD PTR [ecx], 10370			; 00002882H
	mov	DWORD PTR _sint$92617[ebp], edx
	jne	SHORT $LN2365@eval
	fld1
	jmp	SHORT $LN2366@eval
$LN2365@eval:
	fld	QWORD PTR __real@bff0000000000000
$LN2366@eval:

; 5429 : 
; 5430 :           /* Was checked in parser that the arrays have the same number
; 5431 :              of indices, but might be different sizes.  So do
; 5432 :              intersection. */
; 5433 :           /* pop datastarts off stack */
; 5434 :           s = *(char**)(stacktop--);

	mov	ecx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [ecx]
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], ecx

; 5435 :           q = *(char**)(stacktop--);

	mov	edx, DWORD PTR [ecx]
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], ecx
	mov	DWORD PTR _q$92598[ebp], edx

; 5436 :           p = *(char**)(stacktop--);

	mov	edx, DWORD PTR [ecx]
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], ecx

; 5437 :           
; 5438 :           dim = arvalue->dim - rcount;

	mov	edi, DWORD PTR [esi+4]
	sub	edi, DWORD PTR _rcount$92612[ebp]
	mov	DWORD PTR _p$92597[ebp], edx
	mov	DWORD PTR _dim$92614[ebp], edi

; 5439 :           for ( i = 0 ; i < dim ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	edi, edi
	jle	$LN369@eval

; 5429 : 
; 5430 :           /* Was checked in parser that the arrays have the same number
; 5431 :              of indices, but might be different sizes.  So do
; 5432 :              intersection. */
; 5433 :           /* pop datastarts off stack */
; 5434 :           s = *(char**)(stacktop--);

	mov	edx, DWORD PTR _scount$92613[ebp]
	mov	ecx, DWORD PTR _asvalue$92595[ebp]
	lea	ecx, DWORD PTR [ecx+edx*4+24]
	mov	edx, DWORD PTR _alvalue$92593[ebp]
	mov	DWORD PTR tv29567[ebp], ecx
	mov	ecx, DWORD PTR _lcount$92610[ebp]
	lea	edx, DWORD PTR [edx+ecx*4+24]
	mov	ecx, DWORD PTR _rcount$92612[ebp]
	mov	DWORD PTR tv29569[ebp], edx
	lea	edx, DWORD PTR [esi+ecx*4+24]
	mov	DWORD PTR tv29571[ebp], edx
	mov	edx, edi
	add	edx, edx
	add	edx, edx
	mov	ecx, edx
	shr	ecx, 2
	lea	edi, DWORD PTR _sspots$92604[ebp]
	rep stosd

; 5445 :             pspots[i] = p;
; 5446 :             qspots[i] = q;

	mov	eax, DWORD PTR _q$92598[ebp]
	mov	ecx, edx
	shr	ecx, 2
	lea	edi, DWORD PTR _qspots$92603[ebp]
	rep stosd
	mov	eax, DWORD PTR _p$92597[ebp]
	mov	ecx, edx
	shr	ecx, 2
	lea	edi, DWORD PTR _pspots$92602[ebp]
	rep stosd
	mov	ecx, edx
	shr	ecx, 2
	xor	eax, eax
	lea	edi, DWORD PTR _inx$92596[ebp]
	rep stosd
	mov	eax, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR tv29567[ebp]
$LN371@eval:

; 5440 :           { inx[i] = 0;
; 5441 :             minsize[i] = arvalue->sizes[rcount+i] < alvalue->sizes[lcount+i] ?
; 5442 :                           arvalue->sizes[rcount+i] : alvalue->sizes[lcount+i] ;

	mov	ecx, DWORD PTR tv29571[ebp]
	mov	edx, DWORD PTR tv29569[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx]
	cmp	ecx, edx
	jl	SHORT $LN2368@eval
	mov	ecx, edx
$LN2368@eval:

; 5443 :             if ( minsize[i] > asvalue->sizes[scount+i] )

	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR _minsize$92608[ebp+eax*4], ecx
	cmp	ecx, edx
	jle	SHORT $LN368@eval

; 5444 :                minsize[i] = asvalue->sizes[scount+i];

	mov	DWORD PTR _minsize$92608[ebp+eax*4], edx
$LN368@eval:

; 5439 :           for ( i = 0 ; i < dim ; i++ )

	mov	ecx, 4
	add	DWORD PTR tv29571[ebp], ecx
	add	DWORD PTR tv29569[ebp], ecx
	inc	eax
	add	edi, ecx
	cmp	eax, DWORD PTR _dim$92614[ebp]
	jl	SHORT $LN371@eval
	mov	edi, DWORD PTR _dim$92614[ebp]
$LN369@eval:

; 5447 :             sspots[i] = s;
; 5448 :           }
; 5449 :           if ( dim >= 2 )

	cmp	edi, 2
	jl	$LN364@eval

; 5450 :           {
; 5451 :             pstride[dim-2] = alvalue->sizes[dim-1]*alvalue->itemsize;

	mov	ecx, DWORD PTR _alvalue$92593[ebp]

; 5452 :             qstride[dim-2] = arvalue->sizes[dim-1]*arvalue->itemsize;

	mov	edx, DWORD PTR [esi+edi*4+20]
	imul	edx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [ecx+edi*4+20]
	imul	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _pstride$92605[ebp+edi*4-8], eax
	mov	DWORD PTR _qstride$92606[ebp+edi*4-8], edx

; 5453 :             sstride[dim-2] = asvalue->sizes[dim-1]*asvalue->itemsize;

	mov	edx, DWORD PTR _asvalue$92595[ebp]
	mov	eax, DWORD PTR [edx+edi*4+20]
	imul	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _sstride$92607[ebp+edi*4-8], eax

; 5454 :             for ( i = dim - 3 ; i >= 0 ; i-- )

	lea	eax, DWORD PTR [edi-3]
	test	eax, eax
	js	SHORT $LN364@eval

; 5450 :           {
; 5451 :             pstride[dim-2] = alvalue->sizes[dim-1]*alvalue->itemsize;

	mov	edi, DWORD PTR _scount$92613[ebp]
	add	edi, eax
	lea	edx, DWORD PTR [edx+edi*4+28]
	mov	edi, DWORD PTR _rcount$92612[ebp]
	add	edi, eax
	lea	esi, DWORD PTR [esi+edi*4+28]
	mov	edi, DWORD PTR _lcount$92610[ebp]
	add	edi, eax
	lea	ecx, DWORD PTR [ecx+edi*4+28]
$LN366@eval:

; 5455 :             { pstride[i] = pstride[i+1]*alvalue->sizes[lcount+i+1];

	mov	edi, DWORD PTR _pstride$92605[ebp+eax*4+4]
	imul	edi, DWORD PTR [ecx]
	mov	DWORD PTR _pstride$92605[ebp+eax*4], edi

; 5456 :               qstride[i] = qstride[i+1]*arvalue->sizes[rcount+i+1];

	mov	edi, DWORD PTR _qstride$92606[ebp+eax*4+4]
	imul	edi, DWORD PTR [esi]
	mov	DWORD PTR _qstride$92606[ebp+eax*4], edi

; 5457 :               sstride[i] = sstride[i+1]*asvalue->sizes[scount+i+1];

	mov	edi, DWORD PTR _sstride$92607[ebp+eax*4+4]
	imul	edi, DWORD PTR [edx]
	mov	DWORD PTR _sstride$92607[ebp+eax*4], edi
	sub	ecx, 4
	sub	esi, 4
	sub	edx, 4
	dec	eax
	jns	SHORT $LN366@eval

; 5454 :             for ( i = dim - 3 ; i >= 0 ; i-- )

	mov	edi, DWORD PTR _dim$92614[ebp]
$LN364@eval:

; 5458 :             }
; 5459 :           }
; 5460 :           lastsize = minsize[dim-1];

	mov	ecx, DWORD PTR _minsize$92608[ebp+edi*4-4]

; 5461 : 
; 5462 :           p = pspots[0];

	mov	edx, DWORD PTR _pspots$92602[ebp]

; 5463 :           q = qspots[0];

	mov	eax, DWORD PTR _qspots$92603[ebp]
	mov	DWORD PTR _lastsize$92609[ebp], ecx

; 5464 :           s = sspots[0];

	mov	ecx, DWORD PTR _sspots$92604[ebp]
	mov	DWORD PTR _p$92597[ebp], edx
	mov	DWORD PTR _q$92598[ebp], eax
	mov	DWORD PTR _s$92599[ebp], ecx
$LN363@eval:

; 5465 :           do
; 5466 :           { /* do a row */
; 5467 : 
; 5468 :                 int *pi = (int*)p;
; 5469 :                 REAL *pr = (REAL*)p;
; 5470 :                 int *qi = (int*)q;

	mov	eax, DWORD PTR _q$92598[ebp]

; 5471 :                 REAL *qr = (REAL*)q;
; 5472 :                 int *si = (int*)s;
; 5473 :                 REAL *sr = (REAL*)s;
; 5474 :                 REAL rvalue;
; 5475 :                 
; 5476 :                 switch ( node->op1.assigntype )

	mov	edx, DWORD PTR _node$[ebp]
	mov	edi, DWORD PTR _p$92597[ebp]
	mov	DWORD PTR _qi$92637[ebp], eax
	mov	DWORD PTR _qr$92639[ebp], eax
	mov	eax, DWORD PTR _s$92599[ebp]
	mov	DWORD PTR _si$92641[ebp], eax
	mov	DWORD PTR _sr$92643[ebp], eax
	mov	eax, DWORD PTR [edx+32]
	add	eax, -30001				; ffff8acfH
	mov	DWORD PTR _pi$92633[ebp], edi
	cmp	eax, 4
	ja	$LN331@eval
	jmp	DWORD PTR $LN4049@eval[eax*4]
$LN358@eval:

; 5477 :                 { case ASSIGN_OP:
; 5478 :                      for ( i = 0 ; i < lastsize ; i++ )

	mov	esi, DWORD PTR _lastsize$92609[ebp]
	test	esi, esi
	jle	$LN331@eval
$LN357@eval:

; 5479 :                      { rvalue = (qint ? *(qi++):*(qr++)) + sign*(sint ? *(si++):*(sr++));

	cmp	DWORD PTR _qint$92616[ebp], 0
	je	SHORT $LN2369@eval
	mov	eax, DWORD PTR _qi$92637[ebp]
	fild	DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR _qi$92637[ebp], eax
	jmp	SHORT $LN2370@eval
$LN2369@eval:
	mov	eax, DWORD PTR _qr$92639[ebp]
	fld	QWORD PTR [eax]
	add	eax, 8
	mov	DWORD PTR _qr$92639[ebp], eax
$LN2370@eval:
	cmp	DWORD PTR _sint$92617[ebp], 0
	je	SHORT $LN2371@eval
	mov	eax, DWORD PTR _si$92641[ebp]
	fild	DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR _si$92641[ebp], eax
	jmp	SHORT $LN2372@eval
$LN2371@eval:
	mov	eax, DWORD PTR _sr$92643[ebp]
	fld	QWORD PTR [eax]
	add	eax, 8
	mov	DWORD PTR _sr$92643[ebp], eax
$LN2372@eval:

; 5480 :                        if ( pint )

	cmp	DWORD PTR _pint$92615[ebp], 0
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	je	SHORT $LN354@eval

; 5481 :                          *(pi++) = (int)rvalue;

	call	__ftol2_sse
	mov	ecx, DWORD PTR _pi$92633[ebp]
	mov	DWORD PTR [ecx], eax
	add	ecx, 4
	mov	DWORD PTR _pi$92633[ebp], ecx

; 5482 :                        else

	jmp	SHORT $LN356@eval
$LN354@eval:

; 5483 :                          *(pr++) = rvalue;

	fstp	QWORD PTR [edi]
	add	edi, 8
$LN356@eval:

; 5477 :                 { case ASSIGN_OP:
; 5478 :                      for ( i = 0 ; i < lastsize ; i++ )

	dec	esi
	jne	$LN357@eval

; 5484 :                      }
; 5485 :                      break;

	jmp	$LN331@eval
$LN352@eval:

; 5486 :                   case PLUSASSIGN_OP:
; 5487 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	mov	esi, DWORD PTR _lastsize$92609[ebp]
	test	esi, esi
	jle	$LN331@eval
$LN351@eval:

; 5488 :                      { rvalue = (qint ? *(qi++):*(qr++)) + sign*(sint ? *(si++):*(sr++));

	cmp	DWORD PTR _qint$92616[ebp], 0
	je	SHORT $LN2373@eval
	mov	eax, DWORD PTR _qi$92637[ebp]
	fild	DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR _qi$92637[ebp], eax
	jmp	SHORT $LN2374@eval
$LN2373@eval:
	mov	eax, DWORD PTR _qr$92639[ebp]
	fld	QWORD PTR [eax]
	add	eax, 8
	mov	DWORD PTR _qr$92639[ebp], eax
$LN2374@eval:
	cmp	DWORD PTR _sint$92617[ebp], 0
	je	SHORT $LN2375@eval
	mov	eax, DWORD PTR _si$92641[ebp]
	fild	DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR _si$92641[ebp], eax
	jmp	SHORT $LN2376@eval
$LN2375@eval:
	mov	eax, DWORD PTR _sr$92643[ebp]
	fld	QWORD PTR [eax]
	add	eax, 8
	mov	DWORD PTR _sr$92643[ebp], eax
$LN2376@eval:

; 5489 :                        if ( pint )

	cmp	DWORD PTR _pint$92615[ebp], 0
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	je	SHORT $LN348@eval

; 5490 :                          *(pi++) += (int)rvalue;

	call	__ftol2_sse
	mov	ecx, DWORD PTR _pi$92633[ebp]
	add	DWORD PTR [ecx], eax
	add	ecx, 4
	mov	DWORD PTR _pi$92633[ebp], ecx

; 5491 :                        else

	jmp	SHORT $LN350@eval
$LN348@eval:

; 5492 :                          *(pr++) += rvalue;

	fadd	QWORD PTR [edi]
	add	edi, 8
	fstp	QWORD PTR [edi-8]
$LN350@eval:

; 5486 :                   case PLUSASSIGN_OP:
; 5487 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	dec	esi
	jne	$LN351@eval

; 5493 :                      }
; 5494 :                      break;

	jmp	$LN331@eval
$LN346@eval:

; 5495 :                   case SUBASSIGN_OP:
; 5496 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	mov	esi, DWORD PTR _lastsize$92609[ebp]
	test	esi, esi
	jle	$LN331@eval
$LN345@eval:

; 5497 :                      { rvalue = (qint ? *(qi++):*(qr++)) + sign*(sint ? *(si++):*(sr++));

	cmp	DWORD PTR _qint$92616[ebp], 0
	je	SHORT $LN2377@eval
	mov	eax, DWORD PTR _qi$92637[ebp]
	fild	DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR _qi$92637[ebp], eax
	jmp	SHORT $LN2378@eval
$LN2377@eval:
	mov	eax, DWORD PTR _qr$92639[ebp]
	fld	QWORD PTR [eax]
	add	eax, 8
	mov	DWORD PTR _qr$92639[ebp], eax
$LN2378@eval:
	cmp	DWORD PTR _sint$92617[ebp], 0
	je	SHORT $LN2379@eval
	mov	eax, DWORD PTR _si$92641[ebp]
	fild	DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR _si$92641[ebp], eax
	jmp	SHORT $LN2380@eval
$LN2379@eval:
	mov	eax, DWORD PTR _sr$92643[ebp]
	fld	QWORD PTR [eax]
	add	eax, 8
	mov	DWORD PTR _sr$92643[ebp], eax
$LN2380@eval:

; 5498 :                        if ( pint )

	cmp	DWORD PTR _pint$92615[ebp], 0
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	je	SHORT $LN342@eval

; 5499 :                          *(pi++) -= (int)rvalue;

	call	__ftol2_sse
	mov	ecx, DWORD PTR _pi$92633[ebp]
	sub	DWORD PTR [ecx], eax
	add	ecx, 4
	mov	DWORD PTR _pi$92633[ebp], ecx

; 5500 :                        else

	jmp	SHORT $LN344@eval
$LN342@eval:

; 5501 :                          *(pr++) -= rvalue;

	fsubr	QWORD PTR [edi]
	add	edi, 8
	fstp	QWORD PTR [edi-8]
$LN344@eval:

; 5495 :                   case SUBASSIGN_OP:
; 5496 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	dec	esi
	jne	$LN345@eval

; 5502 :                      }
; 5503 :                      break;                        

	jmp	$LN331@eval
$LN340@eval:

; 5504 :                   case MULTASSIGN_OP:
; 5505 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	mov	esi, DWORD PTR _lastsize$92609[ebp]
	test	esi, esi
	jle	$LN331@eval
$LN339@eval:

; 5506 :                      { rvalue = (qint ? *(qi++):*(qr++)) + sign*(sint ? *(si++):*(sr++));

	cmp	DWORD PTR _qint$92616[ebp], 0
	je	SHORT $LN2381@eval
	mov	eax, DWORD PTR _qi$92637[ebp]
	fild	DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR _qi$92637[ebp], eax
	jmp	SHORT $LN2382@eval
$LN2381@eval:
	mov	eax, DWORD PTR _qr$92639[ebp]
	fld	QWORD PTR [eax]
	add	eax, 8
	mov	DWORD PTR _qr$92639[ebp], eax
$LN2382@eval:
	cmp	DWORD PTR _sint$92617[ebp], 0
	je	SHORT $LN2383@eval
	mov	eax, DWORD PTR _si$92641[ebp]
	fild	DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR _si$92641[ebp], eax
	jmp	SHORT $LN2384@eval
$LN2383@eval:
	mov	eax, DWORD PTR _sr$92643[ebp]
	fld	QWORD PTR [eax]
	add	eax, 8
	mov	DWORD PTR _sr$92643[ebp], eax
$LN2384@eval:

; 5507 :                        if ( pint )

	cmp	DWORD PTR _pint$92615[ebp], 0
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	je	SHORT $LN336@eval

; 5508 :                          *(pi++) *= (int)rvalue;

	call	__ftol2_sse
	mov	ecx, eax
	mov	eax, DWORD PTR _pi$92633[ebp]
	imul	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	mov	DWORD PTR _pi$92633[ebp], eax

; 5509 :                        else

	jmp	SHORT $LN338@eval
$LN336@eval:

; 5510 :                          *(pr++) *= rvalue;

	fmul	QWORD PTR [edi]
	add	edi, 8
	fstp	QWORD PTR [edi-8]
$LN338@eval:

; 5504 :                   case MULTASSIGN_OP:
; 5505 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	dec	esi
	jne	$LN339@eval

; 5511 :                      }
; 5512 :                      break;

	jmp	$LN331@eval
$LN334@eval:

; 5513 :                   case DIVASSIGN_OP:
; 5514 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	mov	esi, DWORD PTR _lastsize$92609[ebp]
	test	esi, esi
	jle	$LN331@eval
$LN333@eval:

; 5515 :                      { rvalue = (qint ? *(qi++):*(qr++)) + sign*(sint ? *(si++):*(sr++));

	cmp	DWORD PTR _qint$92616[ebp], 0
	je	SHORT $LN2385@eval
	mov	eax, DWORD PTR _qi$92637[ebp]
	fild	DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR _qi$92637[ebp], eax
	jmp	SHORT $LN2386@eval
$LN2385@eval:
	mov	eax, DWORD PTR _qr$92639[ebp]
	fld	QWORD PTR [eax]
	add	eax, 8
	mov	DWORD PTR _qr$92639[ebp], eax
$LN2386@eval:
	cmp	DWORD PTR _sint$92617[ebp], 0
	je	SHORT $LN2387@eval
	mov	eax, DWORD PTR _si$92641[ebp]
	fild	DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR _si$92641[ebp], eax
	jmp	SHORT $LN2388@eval
$LN2387@eval:
	mov	eax, DWORD PTR _sr$92643[ebp]
	fld	QWORD PTR [eax]
	add	eax, 8
	mov	DWORD PTR _sr$92643[ebp], eax
$LN2388@eval:

; 5516 :                        if ( pint )

	cmp	DWORD PTR _pint$92615[ebp], 0
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	je	SHORT $LN330@eval

; 5517 :                        { *pi = (int)(*pi/rvalue);

	mov	edx, DWORD PTR _pi$92633[ebp]
	fidivr	DWORD PTR [edx]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _pi$92633[ebp]
	mov	DWORD PTR [ecx], eax

; 5518 :                           pi++;

	add	ecx, 4
	mov	DWORD PTR _pi$92633[ebp], ecx

; 5519 :                        }
; 5520 :                        else

	jmp	SHORT $LN332@eval
$LN330@eval:

; 5521 :                          *(pr++) /= rvalue;

	fdivr	QWORD PTR [edi]
	add	edi, 8
	fstp	QWORD PTR [edi-8]
$LN332@eval:

; 5513 :                   case DIVASSIGN_OP:
; 5514 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	dec	esi
	jne	$LN333@eval
$LN331@eval:

; 5522 :                      }
; 5523 :                      break;
; 5524 :               
; 5525 :                  } 
; 5526 : 
; 5527 :             /* increment pointers */
; 5528 :             for ( j = dim-2 ; j >= 0 ; j-- )

	mov	edx, DWORD PTR _dim$92614[ebp]
	add	edx, -2					; fffffffeH
	js	$LN362@eval
$LN328@eval:

; 5529 :             { pspots[j] += pstride[j];

	mov	eax, DWORD PTR _pstride$92605[ebp+edx*4]
	add	DWORD PTR _pspots$92602[ebp+edx*4], eax

; 5530 :               qspots[j] += qstride[j];

	mov	eax, DWORD PTR _qstride$92606[ebp+edx*4]
	add	DWORD PTR _qspots$92603[ebp+edx*4], eax

; 5531 :               sspots[j] += sstride[j];

	mov	eax, DWORD PTR _sstride$92607[ebp+edx*4]
	add	DWORD PTR _sspots$92604[ebp+edx*4], eax

; 5532 :               if ( ++inx[j] < minsize[j] )

	inc	DWORD PTR _inx$92596[ebp+edx*4]
	mov	eax, DWORD PTR _inx$92596[ebp+edx*4]
	mov	ecx, DWORD PTR _pspots$92602[ebp+edx*4]
	mov	esi, DWORD PTR _qspots$92603[ebp+edx*4]
	mov	edi, DWORD PTR _sspots$92604[ebp+edx*4]
	cmp	eax, DWORD PTR _minsize$92608[ebp+edx*4]
	jl	SHORT $LN2620@eval

; 5539 :                   sspots[k] = s;
; 5540 :                  }
; 5541 :                 break;
; 5542 :               }
; 5543 :               inx[j] = 0 ;

	dec	edx
	mov	DWORD PTR _inx$92596[ebp+edx*4+4], 0
	jns	SHORT $LN328@eval

; 6334 :                 a = NULL;
; 6335 :               }
; 6336 :             }
; 6337 :          }
; 6338 :         if ( this_frame->flags & BASE_OF_EVAL )

	jmp	$LN362@eval
$LN2620@eval:

; 5533 :               { p = pspots[j];

	mov	DWORD PTR _p$92597[ebp], ecx

; 5534 :                 q = qspots[j];
; 5535 :                 s = sspots[j];
; 5536 :                 for ( k = j+1 ; k < dim-1 ; k++ )

	mov	ecx, DWORD PTR _dim$92614[ebp]
	lea	eax, DWORD PTR [edx+1]
	dec	ecx
	mov	DWORD PTR _q$92598[ebp], esi
	mov	DWORD PTR _s$92599[ebp], edi
	cmp	eax, ecx
	jge	SHORT $LN362@eval

; 5533 :               { p = pspots[j];

	sub	ecx, eax
	add	ecx, ecx
	lea	esi, DWORD PTR _qspots$92603[ebp+eax*4]
	mov	DWORD PTR tv30008[ebp], esi
	lea	esi, DWORD PTR _pspots$92602[ebp+eax*4]
	mov	DWORD PTR tv30010[ebp], esi
	lea	esi, DWORD PTR [ecx+ecx]
	lea	edi, DWORD PTR _sspots$92604[ebp+eax*4]
	mov	eax, DWORD PTR _s$92599[ebp]
	mov	ecx, esi
	shr	ecx, 2
	rep stosd

; 5537 :                 { pspots[k] = p;
; 5538 :                   qspots[k] = q;

	mov	eax, DWORD PTR _q$92598[ebp]
	mov	edi, DWORD PTR tv30008[ebp]
	mov	ecx, esi
	shr	ecx, 2
	rep stosd
	mov	eax, DWORD PTR _p$92597[ebp]
	mov	edi, DWORD PTR tv30010[ebp]
	mov	ecx, esi
	shr	ecx, 2
	rep stosd
$LN362@eval:

; 5544 :             }  
; 5545 :            } while ( j >= 0 );    

	test	edx, edx
	jns	$LN363@eval
	fstp	ST(0)

; 5546 :        
; 5547 :          if ( node->flags & RECALC_FLAG )
; 5548 :            recalc_flag = 1;
; 5549 :          if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'
; 5550 :            dont_resize_flag = 1;
; 5551 :        
; 5552 :          } /* end ARRAY_ASSIGNOP_A_P_A_, ARRAY_ASSIGNOP_A_S_A_ */
; 5553 :          break;

	jmp	$LN3977@eval
$LN319@eval:

; 5554 : 
; 5555 :       case ARRAY_ADD_NODE:   // result to temp array 
; 5556 :       case ARRAY_SUBTRACT_NODE:
; 5557 :         { 
; 5558 :           struct array *alvalue;
; 5559 :           struct array *arvalue= get_name_arrayptr(node->op3.name_id,newstack + localstack,localbase);

	mov	esi, DWORD PTR _localstack$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	edi, DWORD PTR _localbase$[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+140]
	add	esi, esi
	add	esi, esi
	add	esi, esi
	push	edi
	add	ecx, esi
	push	ecx
	push	eax
	call	_get_name_arrayptr

; 5560 :           struct array *asvalue= get_name_arrayptr(node->op4.name_id,newstack + localstack,localbase);

	mov	ecx, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR _node$[ebp]
	push	edi
	add	ecx, esi
	mov	DWORD PTR _arvalue$92696[ebp], eax
	mov	eax, DWORD PTR [edx+148]
	push	ecx
	push	eax
	call	_get_name_arrayptr
	mov	esi, eax

; 5561 :           int inx[100]; /* keep track of indices */
; 5562 :           char *p,*q,*s;
; 5563 :           int j,k;
; 5564 :           char *pspots[MAXARRAYDIMS],*qspots[MAXARRAYDIMS],*sspots[MAXARRAYDIMS];
; 5565 :           int pstride[MAXARRAYDIMS],qstride[MAXARRAYDIMS],sstride[MAXARRAYDIMS];
; 5566 :           int minsize[MAXARRAYDIMS],lastsize;
; 5567 :           int rcount = node[node->left].op5.indexcount;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [ecx+eax+152]

; 5568 :           int scount = node[node->right].op5.indexcount;

	mov	ecx, DWORD PTR [eax+8]
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR _rcount$92712[ebp], edx
	mov	edx, DWORD PTR [ecx+eax+152]

; 5569 :           int dim;
; 5570 :           int qint = (arvalue->datatype == INTEGER_TYPE);

	xor	ecx, ecx
	add	esp, 24					; 00000018H
	mov	DWORD PTR _scount$92713[ebp], edx
	mov	edx, DWORD PTR _arvalue$92696[ebp]
	cmp	DWORD PTR [edx+8], 2
	mov	DWORD PTR _asvalue$92697[ebp], esi
	sete	cl
	mov	DWORD PTR _qint$92715[ebp], ecx

; 5571 :           int sint = (asvalue->datatype == INTEGER_TYPE);

	xor	ecx, ecx
	cmp	DWORD PTR [esi+8], 2
	sete	cl

; 5572 :           REAL sign = (node->type==ARRAY_ADD_NODE) ? 1.0 : -1.0;

	cmp	DWORD PTR [eax], 10372			; 00002884H
	mov	DWORD PTR _sint$92716[ebp], ecx
	jne	SHORT $LN2389@eval
	fld1
	jmp	SHORT $LN3984@eval
$LN2389@eval:
	fld	QWORD PTR __real@bff0000000000000
$LN3984@eval:

; 5573 :           struct array **array_info;
; 5574 :           int size;
; 5575 :           int pointercount;
; 5576 :           
; 5577 :           g = globals(node->op2.name_id);

	mov	eax, DWORD PTR [eax+136]
	fst	QWORD PTR _sign$92717[ebp]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	and	eax, 16777215				; 00ffffffH
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN2395@eval
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _g$[ebp], edx
	jmp	SHORT $LN2392@eval
$LN2395@eval:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2393@eval
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 5
	add	ecx, DWORD PTR [edi]
	jmp	SHORT $LN3985@eval
$LN2393@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2391@eval
	mov	ecx, DWORD PTR _web+5656
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _g$[ebp], edx
	jmp	SHORT $LN2392@eval
$LN2391@eval:
	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+eax]
$LN3985@eval:
	mov	DWORD PTR _g$[ebp], ecx
$LN2392@eval:

; 5578 :           alvalue = g->attr.arrayptr;  // has dim for temp

	mov	eax, DWORD PTR _g$[ebp]
	mov	esi, DWORD PTR [eax+168]

; 5579 :           
; 5580 :           /* Was checked in parser that the arrays have the same number
; 5581 :              of indices, but might be different sizes.  But do have
; 5582 :              to check actual sizes now. */
; 5583 :           dim = alvalue->dim;  // common dimension after fixed indices

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _alvalue$92695[ebp], esi
	mov	DWORD PTR _dim$92714[ebp], ecx

; 5584 :           for ( i = 0, size = 1, pointercount = 0 ; i < dim ; i++ )

	mov	edi, 1
	mov	DWORD PTR _pointercount$92720[ebp], 0
	test	ecx, ecx
	jle	$LN316@eval

; 5578 :           alvalue = g->attr.arrayptr;  // has dim for temp

	mov	edx, DWORD PTR _arvalue$92696[ebp]
	mov	eax, DWORD PTR _rcount$92712[ebp]
	mov	ecx, DWORD PTR _asvalue$92697[ebp]
	lea	eax, DWORD PTR [edx+eax*4+24]
	mov	edx, DWORD PTR _scount$92713[ebp]
	lea	ecx, DWORD PTR [ecx+edx*4+24]
	mov	edx, DWORD PTR _dim$92714[ebp]
	mov	DWORD PTR tv30084[ebp], eax
	mov	DWORD PTR tv30086[ebp], ecx
	mov	DWORD PTR tv9094[ebp], edx
$LN318@eval:

; 5585 :           { if ( arvalue->sizes[rcount+i] != asvalue->sizes[scount+i] )

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR tv30086[ebp]
	cmp	ecx, DWORD PTR [edx]
	je	$LN315@eval

; 5586 :             { sprintf(errmsg,"Array addition: Arrays have different sizes.\n");

	push	OFFSET ??_C@_0CO@EJMBOHDJ@Array?5addition?3?5Arrays?5have?5diff@
	fstp	ST(0)
	push	OFFSET _errmsg
	call	_sprintf

; 5587 :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 5588 :                           file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL2872@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2872@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 5589 :               kb_error(5844,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5844					; 000016d4H
	call	_kb_error
	fld	QWORD PTR _sign$92717[ebp]
	mov	eax, DWORD PTR tv30084[ebp]
	add	esp, 28					; 0000001cH
$LN315@eval:

; 5590 :             }
; 5591 :             pointercount += size;           

	add	DWORD PTR _pointercount$92720[ebp], edi

; 5592 :             size *= arvalue->sizes[rcount+i];

	imul	edi, DWORD PTR [eax]
	add	DWORD PTR tv30086[ebp], 4
	add	eax, 4
	dec	DWORD PTR tv9094[ebp]
	mov	DWORD PTR tv30084[ebp], eax
	jne	$LN318@eval

; 5584 :           for ( i = 0, size = 1, pointercount = 0 ; i < dim ; i++ )

	mov	ecx, DWORD PTR _dim$92714[ebp]
	mov	eax, DWORD PTR _g$[ebp]
$LN316@eval:

; 5593 :           }
; 5594 : 
; 5595 :           /* Set up temp array for destination */
; 5596 : 
; 5597 :           if ( !(g->flags & FIXED_SIZE_ARRAY) )

	test	DWORD PTR [eax+192], 268435456		; 10000000H
	jne	$LN314@eval

; 5598 :           { alvalue = NULL;
; 5599 :             array_info = (struct array **)(newstack+localstack+g->value.offset);

	mov	edx, DWORD PTR [eax+64]
	add	edx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	lea	eax, DWORD PTR [eax+edx*8]
	xor	esi, esi
	mov	DWORD PTR _alvalue$92695[ebp], esi
	mov	DWORD PTR _array_info$92718[ebp], eax

; 5600 :             if ( array_info )

	test	eax, eax
	je	SHORT $LN310@eval

; 5601 :             { // see if existing storage enough
; 5602 :               if ( *array_info )

	cmp	DWORD PTR [eax], esi
	je	SHORT $LN310@eval

; 5603 :               { alvalue = *array_info;

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _alvalue$92695[ebp], esi

; 5604 :                 if ( alvalue->datacount >= size )

	cmp	DWORD PTR [esi+16], edi
	jl	$LN3836@eval

; 5605 :                   p = (char*)(alvalue + 1);

	lea	edx, DWORD PTR [esi+56]
	mov	DWORD PTR _p$92699[ebp], edx
$LN310@eval:

; 5608 :                   alvalue = NULL;
; 5609 :                 }
; 5610 :               }
; 5611 :             }
; 5612 :             if ( alvalue == NULL )

	test	esi, esi
	jne	SHORT $LN309@eval
	fstp	ST(0)
$LN2785@eval:

; 5613 :             {
; 5614 :               alvalue = *array_info = (struct array*)temp_calloc( sizeof(struct array) +
; 5615 :                  (size+1)*sizeof(REAL)+pointercount*sizeof(REAL*),1);  /* extra for alignment */

	mov	eax, DWORD PTR _pointercount$92720[ebp]
	push	5615					; 000015efH
	lea	ecx, DWORD PTR [eax+edi*2+16]
	push	OFFSET ??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@
	add	ecx, ecx
	add	ecx, ecx
	push	1
	push	ecx
	call	_kb_temp_calloc

; 5616 :               alvalue->flags |= ARRAY_TEMP;
; 5617 :               p = (char*)(alvalue + 1); // for data

	fld	QWORD PTR _sign$92717[ebp]
	mov	edx, DWORD PTR _array_info$92718[ebp]
	mov	ecx, DWORD PTR _dim$92714[ebp]
	mov	esi, eax
	mov	DWORD PTR [edx], eax
	lea	eax, DWORD PTR [esi+56]
	add	esp, 16					; 00000010H
	or	DWORD PTR [esi], 32768			; 00008000H
	mov	DWORD PTR _alvalue$92695[ebp], esi
	mov	DWORD PTR _p$92699[ebp], eax
$LN309@eval:

; 5618 :             }
; 5619 :             alvalue->dim = dim;

	mov	DWORD PTR [esi+4], ecx

; 5620 :             alvalue->datatype = REAL_TYPE;

	mov	DWORD PTR [esi+8], 1

; 5621 :             alvalue->itemsize = sizeof(REAL);

	mov	DWORD PTR [esi+12], 8

; 5622 :             alvalue->datacount = size;

	mov	DWORD PTR [esi+16], edi

; 5623 :             for ( i = 0 ; i < dim ; i++ )

	test	ecx, ecx
	jle	SHORT $LN306@eval

; 5618 :             }
; 5619 :             alvalue->dim = dim;

	mov	edx, DWORD PTR _rcount$92712[ebp]
	mov	eax, DWORD PTR _arvalue$92696[ebp]
	lea	eax, DWORD PTR [eax+edx*4+24]
	mov	edx, DWORD PTR _dim$92714[ebp]
	lea	ecx, DWORD PTR [esi+24]
$LN308@eval:

; 5624 :               alvalue->sizes[i] = arvalue->sizes[rcount+i];

	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	add	eax, 4
	add	ecx, 4
	dec	edx
	jne	SHORT $LN308@eval
$LN306@eval:

; 5625 :             localbase->flags |= LL_HAS_ARRAY;

	mov	eax, DWORD PTR _localbase$[ebp]
	or	DWORD PTR [eax+20], 1

; 5626 :           }
; 5627 :           else 

	jmp	SHORT $LN305@eval
$LN3836@eval:

; 5606 :                 else
; 5607 :                 { temp_free((char*)alvalue);

	push	esi
	fstp	ST(0)
	call	_temp_free
	add	esp, 4

; 5608 :                   alvalue = NULL;
; 5609 :                 }
; 5610 :               }
; 5611 :             }
; 5612 :             if ( alvalue == NULL )

	jmp	$LN2785@eval
$LN314@eval:

; 5628 :             p = (char*)(newstack+localstack+g->value.offset);

	mov	ecx, DWORD PTR [eax+64]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	edx, DWORD PTR [ebx+40]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _p$92699[ebp], eax
$LN305@eval:

; 5629 : 
; 5630 :           /* pop datastarts off stack */
; 5631 :           s = *(char**)(stacktop--);

	mov	ecx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [ecx]
	add	ecx, -8					; fffffff8H

; 5632 :           q = *(char**)(stacktop--);
; 5633 :           
; 5634 :           // push result datastart on stack
; 5635 :           *(REAL**)(++stacktop) = (REAL*)p;  
; 5636 :           
; 5637 :           for ( i = 0 ; i < dim ; i++ )

	cmp	DWORD PTR _dim$92714[ebp], 0
	mov	DWORD PTR [ebx+48], ecx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _q$92700[ebp], edx
	mov	edx, DWORD PTR _p$92699[ebp]
	mov	DWORD PTR [ebx+48], ecx
	mov	DWORD PTR [ecx], edx
	jle	SHORT $LN304@eval

; 5629 : 
; 5630 :           /* pop datastarts off stack */
; 5631 :           s = *(char**)(stacktop--);

	mov	ecx, DWORD PTR _arvalue$92696[ebp]
	mov	edx, DWORD PTR _rcount$92712[ebp]
	lea	esi, DWORD PTR [ecx+edx*4+24]
	mov	edx, DWORD PTR _dim$92714[ebp]
	add	edx, edx
	add	edx, edx
	mov	ecx, edx
	shr	ecx, 2
	lea	edi, DWORD PTR _sspots$92706[ebp]
	rep stosd

; 5638 :           { inx[i] = 0;
; 5639 :             minsize[i] = arvalue->sizes[rcount+i];
; 5640 :             pspots[i] = p;
; 5641 :             qspots[i] = q;

	mov	eax, DWORD PTR _q$92700[ebp]
	mov	ecx, edx
	shr	ecx, 2
	lea	edi, DWORD PTR _qspots$92705[ebp]
	rep stosd
	mov	eax, DWORD PTR _p$92699[ebp]
	mov	ecx, edx
	shr	ecx, 2
	lea	edi, DWORD PTR _pspots$92704[ebp]
	rep stosd
	mov	ecx, edx
	shr	ecx, 2
	lea	edi, DWORD PTR _minsize$92710[ebp]
	rep movsd
	mov	esi, DWORD PTR _alvalue$92695[ebp]
	mov	ecx, edx
	shr	ecx, 2
	xor	eax, eax
	lea	edi, DWORD PTR _inx$92698[ebp]
	rep stosd
$LN304@eval:

; 5642 :             sspots[i] = s;
; 5643 :           }
; 5644 :           if ( dim >= 2 )

	cmp	DWORD PTR _dim$92714[ebp], 2
	jl	$LN298@eval

; 5645 :           {
; 5646 :             pstride[dim-2] = alvalue->sizes[dim-1]*alvalue->itemsize;

	mov	eax, DWORD PTR _dim$92714[ebp]
	mov	ecx, DWORD PTR [esi+eax*4+20]
	imul	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _pstride$92707[ebp+eax*4-8], ecx

; 5647 :             qstride[dim-2] = arvalue->sizes[dim-1]*arvalue->itemsize;

	mov	ecx, DWORD PTR _arvalue$92696[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+20]
	imul	edx, DWORD PTR [ecx+12]

; 5648 :             sstride[dim-2] = asvalue->sizes[dim-1]*asvalue->itemsize;

	mov	ecx, DWORD PTR _asvalue$92697[ebp]
	mov	DWORD PTR _qstride$92708[ebp+eax*4-8], edx
	mov	edx, DWORD PTR [ecx+eax*4+20]
	imul	edx, DWORD PTR [ecx+12]

; 5649 :             for ( i = dim - 3 ; i >= 0 ; i-- )

	add	eax, -3					; fffffffdH
	mov	DWORD PTR _sstride$92709[ebp+eax*4+4], edx
	js	SHORT $LN298@eval

; 5645 :           {
; 5646 :             pstride[dim-2] = alvalue->sizes[dim-1]*alvalue->itemsize;

	mov	ecx, DWORD PTR _scount$92713[ebp]
	mov	edx, DWORD PTR _asvalue$92697[ebp]
	mov	edi, DWORD PTR _arvalue$92696[ebp]
	add	ecx, eax
	lea	edx, DWORD PTR [edx+ecx*4+28]
	mov	ecx, DWORD PTR _rcount$92712[ebp]
	add	ecx, eax
	lea	ecx, DWORD PTR [edi+ecx*4+28]
	lea	esi, DWORD PTR [esi+eax*4+28]
$LN300@eval:

; 5650 :             { pstride[i] = pstride[i+1]*alvalue->sizes[i+1];

	mov	edi, DWORD PTR _pstride$92707[ebp+eax*4+4]
	imul	edi, DWORD PTR [esi]
	mov	DWORD PTR _pstride$92707[ebp+eax*4], edi

; 5651 :               qstride[i] = qstride[i+1]*arvalue->sizes[rcount+i+1];

	mov	edi, DWORD PTR _qstride$92708[ebp+eax*4+4]
	imul	edi, DWORD PTR [ecx]
	mov	DWORD PTR _qstride$92708[ebp+eax*4], edi

; 5652 :               sstride[i] = sstride[i+1]*asvalue->sizes[scount+i+1];

	mov	edi, DWORD PTR _sstride$92709[ebp+eax*4+4]
	imul	edi, DWORD PTR [edx]
	mov	DWORD PTR _sstride$92709[ebp+eax*4], edi
	sub	esi, 4
	sub	ecx, 4
	sub	edx, 4
	dec	eax
	jns	SHORT $LN300@eval
$LN298@eval:

; 5653 :             }
; 5654 :           }
; 5655 :           lastsize = minsize[dim-1];
; 5656 : 
; 5657 :           p = pspots[0];

	mov	ecx, DWORD PTR _pspots$92704[ebp]
	mov	edx, DWORD PTR _dim$92714[ebp]
	mov	eax, DWORD PTR _minsize$92710[ebp+edx*4-4]

; 5658 :           q = qspots[0];

	mov	esi, DWORD PTR _qspots$92705[ebp]
	mov	DWORD PTR _p$92699[ebp], ecx

; 5659 :           s = sspots[0];

	mov	ecx, DWORD PTR _sspots$92706[ebp]
	mov	DWORD PTR _lastsize$92711[ebp], eax
	mov	DWORD PTR _q$92700[ebp], esi
	mov	DWORD PTR _s$92701[ebp], ecx
	jmp	SHORT $LN297@eval
$LN3151@eval:
	mov	ecx, DWORD PTR _s$92701[ebp]
	mov	esi, DWORD PTR _q$92700[ebp]
$LN297@eval:

; 5664 :             int *qi = (int*)q;
; 5665 :             REAL *qr = (REAL*)q;
; 5666 :             int *si = (int*)s;
; 5667 :             REAL *sr = (REAL*)s;
; 5668 : 
; 5669 :             for ( i = 0 ; i < lastsize ; i++ )

	cmp	DWORD PTR _lastsize$92711[ebp], 0
	mov	eax, DWORD PTR _p$92699[ebp]
	mov	DWORD PTR _qi$92767[ebp], esi
	mov	edx, ecx
	jle	SHORT $LN292@eval

; 5660 :           do
; 5661 :           { /* do a row */
; 5662 : 
; 5663 :             REAL *pr = (REAL*)p;

	mov	edi, DWORD PTR _lastsize$92711[ebp]
	mov	DWORD PTR tv8795[ebp], edi
$LN294@eval:

; 5670 :               *(pr++) = (qint ? *(qi++):*(qr++)) + sign*(sint ? *(si++):*(sr++));             

	cmp	DWORD PTR _qint$92715[ebp], 0
	je	SHORT $LN2397@eval
	mov	edi, DWORD PTR _qi$92767[ebp]
	fild	DWORD PTR [edi]
	add	edi, 4
	mov	DWORD PTR _qi$92767[ebp], edi
	jmp	SHORT $LN2398@eval
$LN2397@eval:
	fld	QWORD PTR [esi]
	add	esi, 8
$LN2398@eval:
	cmp	DWORD PTR _sint$92716[ebp], 0
	je	SHORT $LN2399@eval
	fild	DWORD PTR [edx]
	add	edx, 4
	jmp	SHORT $LN2400@eval
$LN2399@eval:
	fld	QWORD PTR [ecx]
	add	ecx, 8
$LN2400@eval:
	fmul	ST(0), ST(2)
	add	eax, 8
	dec	DWORD PTR tv8795[ebp]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LN294@eval
$LN292@eval:

; 5671 : 
; 5672 :             /* increment pointers */
; 5673 :             for ( j = dim-2 ; j >= 0 ; j-- )

	mov	edx, DWORD PTR _dim$92714[ebp]
	add	edx, -2					; fffffffeH
	js	$LN296@eval
$LN291@eval:

; 5674 :             { pspots[j] += pstride[j];

	mov	eax, DWORD PTR _pstride$92707[ebp+edx*4]
	add	DWORD PTR _pspots$92704[ebp+edx*4], eax

; 5675 :               qspots[j] += qstride[j];

	mov	eax, DWORD PTR _qstride$92708[ebp+edx*4]
	add	DWORD PTR _qspots$92705[ebp+edx*4], eax

; 5676 :               sspots[j] += sstride[j];

	mov	eax, DWORD PTR _sstride$92709[ebp+edx*4]
	add	DWORD PTR _sspots$92706[ebp+edx*4], eax

; 5677 :               if ( ++inx[j] < minsize[j] )

	inc	DWORD PTR _inx$92698[ebp+edx*4]
	mov	eax, DWORD PTR _inx$92698[ebp+edx*4]
	mov	ecx, DWORD PTR _pspots$92704[ebp+edx*4]
	mov	esi, DWORD PTR _qspots$92705[ebp+edx*4]
	mov	edi, DWORD PTR _sspots$92706[ebp+edx*4]
	cmp	eax, DWORD PTR _minsize$92710[ebp+edx*4]
	jl	SHORT $LN2621@eval

; 5684 :                   sspots[k] = s;
; 5685 :                  }
; 5686 :                 break;
; 5687 :               }
; 5688 :               inx[j] = 0 ;

	dec	edx
	mov	DWORD PTR _inx$92698[ebp+edx*4+4], 0
	jns	SHORT $LN291@eval

; 6334 :                 a = NULL;
; 6335 :               }
; 6336 :             }
; 6337 :          }
; 6338 :         if ( this_frame->flags & BASE_OF_EVAL )

	jmp	$LN296@eval
$LN2621@eval:

; 5678 :               { p = pspots[j];

	mov	DWORD PTR _p$92699[ebp], ecx

; 5679 :                 q = qspots[j];
; 5680 :                 s = sspots[j];
; 5681 :                 for ( k = j+1 ; k < dim-1 ; k++ )

	mov	ecx, DWORD PTR _dim$92714[ebp]
	lea	eax, DWORD PTR [edx+1]
	dec	ecx
	mov	DWORD PTR _q$92700[ebp], esi
	mov	DWORD PTR _s$92701[ebp], edi
	cmp	eax, ecx
	jge	SHORT $LN296@eval

; 5678 :               { p = pspots[j];

	sub	ecx, eax
	add	ecx, ecx
	lea	esi, DWORD PTR _qspots$92705[ebp+eax*4]
	mov	DWORD PTR tv30621[ebp], esi
	lea	esi, DWORD PTR _pspots$92704[ebp+eax*4]
	mov	DWORD PTR tv30623[ebp], esi
	lea	esi, DWORD PTR [ecx+ecx]
	lea	edi, DWORD PTR _sspots$92706[ebp+eax*4]
	mov	eax, DWORD PTR _s$92701[ebp]
	mov	ecx, esi
	shr	ecx, 2
	rep stosd

; 5682 :                 { pspots[k] = p;
; 5683 :                   qspots[k] = q;

	mov	eax, DWORD PTR _q$92700[ebp]
	mov	edi, DWORD PTR tv30621[ebp]
	mov	ecx, esi
	shr	ecx, 2
	rep stosd
	mov	eax, DWORD PTR _p$92699[ebp]
	mov	edi, DWORD PTR tv30623[ebp]
	mov	ecx, esi
	shr	ecx, 2
	rep stosd
$LN296@eval:

; 5689 :             }  
; 5690 :            } while ( j >= 0 );    

	test	edx, edx
	jns	$LN3151@eval
	fstp	ST(0)

; 5691 :        
; 5692 :          if ( node->flags & RECALC_FLAG )
; 5693 :            recalc_flag = 1;
; 5694 :           if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'
; 5695 :             dont_resize_flag = 1;
; 5696 : 
; 5697 :          } /* end ARRAY_ADD_NODE */
; 5698 :          break;

	jmp	$LN3977@eval
$LN282@eval:

; 5699 : 
; 5700 :       case ARRAY_SCALAR_MULTIPLY_NODE:
; 5701 :       case ARRAY_SCALAR_DIVIDE_NODE:
; 5702 :         { // scalar multiply to temp array.  Scalar pushed on stack first.
; 5703 :           struct array *alvalue;
; 5704 :           struct array *arvalue= get_name_arrayptr(node->op3.name_id,newstack + localstack,localbase);

	mov	ecx, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR _localstack$[ebp]
	mov	edi, DWORD PTR _localbase$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	push	edi
	push	eax
	push	edx
	call	_get_name_arrayptr

; 5705 :           REAL scalar;
; 5706 :           int inx[100]; /* keep track of indices */
; 5707 :           char *p,*q;
; 5708 :           int j,k;
; 5709 :           char *pspots[MAXARRAYDIMS],*qspots[MAXARRAYDIMS];
; 5710 :           int pstride[MAXARRAYDIMS],qstride[MAXARRAYDIMS];
; 5711 :           int minsize[MAXARRAYDIMS],lastsize;
; 5712 :           int rcount = node[node->right].op5.indexcount;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR [ecx+8]
	imul	eax, 168				; 000000a8H
	mov	edx, DWORD PTR [eax+ecx+152]

; 5713 :           int dim;
; 5714 :           int qint = (arvalue->datatype == INTEGER_TYPE);

	xor	eax, eax
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+8], 2
	mov	DWORD PTR _arvalue$92789[ebp], esi
	sete	al
	mov	DWORD PTR _rcount$92802[ebp], edx
	mov	DWORD PTR _qint$92804[ebp], eax

; 5715 :           struct array **array_info;
; 5716 :           int size;
; 5717 :           int pointercount;
; 5718 :           
; 5719 :           g = globals(node->op2.name_id);

	mov	eax, DWORD PTR [ecx+136]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	and	eax, 16777215				; 00ffffffH
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN2405@eval
	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+eax]
	jmp	SHORT $LN2402@eval
$LN2405@eval:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2403@eval
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 5
	add	ecx, DWORD PTR [edi]
	jmp	SHORT $LN2402@eval
$LN2403@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2401@eval
	mov	ecx, DWORD PTR _web+5656
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN2402@eval
$LN2401@eval:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+ecx]
$LN2402@eval:

; 5720 :           alvalue = g->attr.arrayptr;  // has dim for temp

	mov	edi, DWORD PTR [ecx+168]

; 5721 :           
; 5722 :           dim = alvalue->dim;  // common dimension after fixed indices

	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR _alvalue$92788[ebp], edi
	mov	DWORD PTR _dim$92803[ebp], edx

; 5723 :           for ( i = 0, size = 1, pointercount = 0 ; i < dim ; i++ )

	mov	esi, 1
	mov	DWORD PTR _pointercount$92807[ebp], 0
	test	edx, edx
	jle	SHORT $LN279@eval

; 5720 :           alvalue = g->attr.arrayptr;  // has dim for temp

	mov	edx, DWORD PTR _rcount$92802[ebp]
	mov	eax, DWORD PTR _arvalue$92789[ebp]
	lea	edx, DWORD PTR [eax+edx*4+24]
	mov	DWORD PTR tv30675[ebp], edx
	mov	edx, DWORD PTR _dim$92803[ebp]
	mov	DWORD PTR tv11268[ebp], edx
$LN281@eval:

; 5724 :           { 
; 5725 :             pointercount += size;           
; 5726 :             size *= arvalue->sizes[rcount+i];

	mov	eax, DWORD PTR tv30675[ebp]
	add	DWORD PTR _pointercount$92807[ebp], esi
	mov	eax, DWORD PTR [eax]
	add	DWORD PTR tv30675[ebp], 4
	imul	esi, eax
	dec	DWORD PTR tv11268[ebp]
	jne	SHORT $LN281@eval
$LN279@eval:

; 5727 :           }
; 5728 : 
; 5729 :           /* Set up temp array for destination */
; 5730 : 
; 5731 :           if ( !(g->flags & FIXED_SIZE_ARRAY) )

	test	DWORD PTR [ecx+192], 268435456		; 10000000H

; 5732 :           { alvalue = NULL;
; 5733 :             array_info = (struct array **)(newstack+localstack+g->value.offset);

	mov	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [ecx+64]
	jne	$LN278@eval
	add	ecx, DWORD PTR _localstack$[ebp]
	xor	edi, edi
	lea	eax, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR _alvalue$92788[ebp], edi
	mov	DWORD PTR _array_info$92805[ebp], eax

; 5734 :             if ( array_info )

	test	eax, eax
	je	SHORT $LN274@eval

; 5735 :             { // see if existing storage enough
; 5736 :               if ( *array_info )

	cmp	DWORD PTR [eax], edi
	je	SHORT $LN274@eval

; 5737 :               { alvalue = *array_info;

	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR _alvalue$92788[ebp], edi

; 5738 :                 if ( alvalue->datacount >= size )

	cmp	DWORD PTR [edi+16], esi
	jl	$LN275@eval

; 5739 :                   p = (char*)(alvalue + 1);

	lea	ecx, DWORD PTR [edi+56]
	mov	DWORD PTR _p$92792[ebp], ecx
$LN274@eval:

; 5742 :                   alvalue = NULL;
; 5743 :                 }
; 5744 :               }
; 5745 :             }
; 5746 :             if ( alvalue == NULL )

	test	edi, edi
	jne	SHORT $LN273@eval
$LN2786@eval:

; 5747 :             { alvalue = *array_info = (struct array*)temp_calloc( sizeof(struct array) +
; 5748 :                  (size+1)*sizeof(REAL)+pointercount*sizeof(REAL*),1);  /* extra for alignment */  

	mov	edx, DWORD PTR _pointercount$92807[ebp]
	push	5748					; 00001674H
	lea	eax, DWORD PTR [edx+esi*2+16]
	push	OFFSET ??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@
	add	eax, eax
	add	eax, eax
	push	1
	push	eax
	call	_kb_temp_calloc
	mov	ecx, DWORD PTR _array_info$92805[ebp]
	mov	edi, eax

; 5749 :               alvalue->flags |= ARRAY_TEMP;
; 5750 :               p = (char*)(alvalue + 1); // for data

	lea	edx, DWORD PTR [edi+56]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx], eax
	or	DWORD PTR [edi], 32768			; 00008000H
	mov	DWORD PTR _p$92792[ebp], edx
	mov	edx, DWORD PTR _dim$92803[ebp]
	mov	DWORD PTR _alvalue$92788[ebp], edi
$LN273@eval:

; 5751 :             }
; 5752 :             alvalue->dim = dim;

	mov	DWORD PTR [edi+4], edx

; 5753 :             alvalue->datatype = REAL_TYPE;

	mov	DWORD PTR [edi+8], 1

; 5754 :             alvalue->itemsize = sizeof(REAL);

	mov	DWORD PTR [edi+12], 8

; 5755 :             alvalue->datacount = size;

	mov	DWORD PTR [edi+16], esi

; 5756 :             for ( i = 0 ; i < dim ; i++ )

	test	edx, edx
	jle	SHORT $LN270@eval

; 5751 :             }
; 5752 :             alvalue->dim = dim;

	mov	eax, DWORD PTR _arvalue$92789[ebp]
	mov	esi, DWORD PTR _rcount$92802[ebp]
	lea	ecx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR [eax+esi*4+24]
	mov	DWORD PTR tv7490[ebp], edx
$LL272@eval:

; 5757 :               alvalue->sizes[i] = arvalue->sizes[rcount+i];

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi
	add	eax, 4
	add	ecx, 4
	dec	DWORD PTR tv7490[ebp]
	jne	SHORT $LL272@eval
$LN270@eval:

; 5758 :             localbase->flags |= LL_HAS_ARRAY;

	mov	eax, DWORD PTR _localbase$[ebp]
	or	DWORD PTR [eax+20], 1

; 5759 :           }
; 5760 :           else 

	jmp	SHORT $LN269@eval
$LN275@eval:

; 5740 :                 else
; 5741 :                 { temp_free((char*)alvalue);

	push	edi
	call	_temp_free
	add	esp, 4

; 5742 :                   alvalue = NULL;
; 5743 :                 }
; 5744 :               }
; 5745 :             }
; 5746 :             if ( alvalue == NULL )

	jmp	$LN2786@eval
$LN278@eval:

; 5761 :             p = (char*)(newstack+localstack+g->value.offset);

	add	ecx, DWORD PTR _localstack$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR _p$92792[ebp], ecx
$LN269@eval:

; 5762 : 
; 5763 :           /* pop datastarts off stack */
; 5764 :           q = *(char**)(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]

; 5765 :           scalar = *(stacktop--);

	fld	QWORD PTR [eax-8]
	add	eax, -16				; fffffff0H
	fst	QWORD PTR _scalar$92790[ebp]
	mov	DWORD PTR [ebx+48], eax

; 5766 :           if ( node->type == ARRAY_SCALAR_DIVIDE_NODE )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 10375			; 00002887H
	mov	DWORD PTR _q$92793[ebp], ecx
	jne	$LN266@eval

; 5767 :           { if ( scalar == 0.0 ) 

	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN267@eval

; 5768 :             { sprintf(errmsg,"Dividing array by zero in %s.\n",ex_current.name);

	lea	ecx, DWORD PTR _ex_current$[ebp+20]
	fstp	ST(0)
	push	ecx
	push	OFFSET ??_C@_0BP@DNKGECGN@Dividing?5array?5by?5zero?5in?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 5769 :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 5770 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL2873@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2873@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 5771 :               kb_error(5258,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5258					; 0000148aH
	call	_kb_error

; 5772 :             }
; 5773 :             else

	fld	QWORD PTR _scalar$92790[ebp]
	mov	edx, DWORD PTR _dim$92803[ebp]
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN266@eval
$LN267@eval:

; 5774 :               scalar = 1/scalar;

	fld1
	fdivrp	ST(1), ST(0)
$LN266@eval:

; 5775 :           }
; 5776 :           
; 5777 :           // push result datastart on stack
; 5778 :           *(REAL**)(++stacktop) = (REAL*)p;  

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR _p$92792[ebp]
	mov	DWORD PTR [eax], ecx

; 5779 :           
; 5780 :           for ( i = 0 ; i < dim ; i++ )

	test	edx, edx
	jle	SHORT $LN265@eval

; 5775 :           }
; 5776 :           
; 5777 :           // push result datastart on stack
; 5778 :           *(REAL**)(++stacktop) = (REAL*)p;  

	mov	edx, DWORD PTR _arvalue$92789[ebp]
	mov	eax, DWORD PTR _rcount$92802[ebp]
	lea	esi, DWORD PTR [edx+eax*4+24]
	mov	edx, DWORD PTR _dim$92803[ebp]
	mov	eax, DWORD PTR _q$92793[ebp]
	add	edx, edx
	add	edx, edx
	mov	ecx, edx
	shr	ecx, 2
	lea	edi, DWORD PTR _qspots$92797[ebp]
	rep stosd

; 5781 :           { inx[i] = 0;
; 5782 :             minsize[i] = arvalue->sizes[rcount+i];
; 5783 :             pspots[i] = p;

	mov	eax, DWORD PTR _p$92792[ebp]
	mov	ecx, edx
	shr	ecx, 2
	lea	edi, DWORD PTR _pspots$92796[ebp]
	rep stosd
	mov	ecx, edx
	shr	ecx, 2
	lea	edi, DWORD PTR _minsize$92800[ebp]
	rep movsd
	mov	ecx, edx
	mov	edx, DWORD PTR _dim$92803[ebp]
	shr	ecx, 2
	xor	eax, eax
	lea	edi, DWORD PTR _inx$92791[ebp]
	rep stosd
	mov	edi, DWORD PTR _alvalue$92788[ebp]
$LN265@eval:

; 5784 :             qspots[i] = q;
; 5785 :           }
; 5786 :           if ( dim >= 2 )

	cmp	edx, 2
	jl	SHORT $LN259@eval

; 5787 :           {
; 5788 :             pstride[dim-2] = alvalue->sizes[dim-1]*alvalue->itemsize;

	mov	ecx, DWORD PTR [edi+edx*4+20]
	imul	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR _pstride$92798[ebp+edx*4-8], ecx

; 5789 :             qstride[dim-2] = arvalue->sizes[dim-1]*arvalue->itemsize;

	mov	ecx, DWORD PTR _arvalue$92789[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+20]
	imul	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _qstride$92799[ebp+edx*4-8], eax

; 5790 :             for ( i = dim - 3 ; i >= 0 ; i-- )

	lea	eax, DWORD PTR [edx-3]
	test	eax, eax
	js	SHORT $LN259@eval

; 5787 :           {
; 5788 :             pstride[dim-2] = alvalue->sizes[dim-1]*alvalue->itemsize;

	mov	esi, DWORD PTR _rcount$92802[ebp]
	add	esi, eax
	lea	ecx, DWORD PTR [ecx+esi*4+28]
	lea	edi, DWORD PTR [edi+eax*4+28]
$LN261@eval:

; 5791 :             { pstride[i] = pstride[i+1]*alvalue->sizes[i+1];

	mov	esi, DWORD PTR _pstride$92798[ebp+eax*4+4]
	imul	esi, DWORD PTR [edi]
	mov	DWORD PTR _pstride$92798[ebp+eax*4], esi

; 5792 :               qstride[i] = qstride[i+1]*arvalue->sizes[rcount+i+1];

	mov	esi, DWORD PTR _qstride$92799[ebp+eax*4+4]
	imul	esi, DWORD PTR [ecx]
	mov	DWORD PTR _qstride$92799[ebp+eax*4], esi
	sub	edi, 4
	sub	ecx, 4
	dec	eax
	jns	SHORT $LN261@eval
$LN259@eval:

; 5793 :             }
; 5794 :           }
; 5795 :           lastsize = minsize[dim-1];
; 5796 : 
; 5797 :           p = pspots[0];

	mov	ecx, DWORD PTR _pspots$92796[ebp]
	mov	esi, DWORD PTR _minsize$92800[ebp+edx*4-4]
	mov	DWORD PTR _p$92792[ebp], ecx

; 5798 :           q = qspots[0];

	mov	ecx, DWORD PTR _qspots$92797[ebp]
	add	edx, -2					; fffffffeH
	mov	DWORD PTR _lastsize$92801[ebp], esi
	mov	DWORD PTR _q$92793[ebp], ecx
	mov	DWORD PTR tv21369[ebp], edx

; 5814 :               { p = pspots[j];

	jmp	SHORT $LN258@eval
$LN3152@eval:
	mov	ecx, DWORD PTR _q$92793[ebp]
	mov	esi, DWORD PTR _lastsize$92801[ebp]
$LN258@eval:

; 5803 :             int *qi = (int*)q;

	mov	eax, DWORD PTR _p$92792[ebp]
	mov	edx, ecx

; 5804 :             REAL *qr = (REAL*)q;
; 5805 : 
; 5806 :             for ( i = 0 ; i < lastsize ; i++ )

	test	esi, esi
	jle	SHORT $LN253@eval

; 5799 :           do
; 5800 :           { /* do a row */
; 5801 : 
; 5802 :             REAL *pr = (REAL*)p;

	mov	edi, DWORD PTR _qint$92804[ebp]
$LN255@eval:

; 5807 :                 *(pr++) = scalar*(qint ? *(qi++):*(qr++)); 

	test	edi, edi
	je	SHORT $LN2407@eval
	fild	DWORD PTR [edx]
	add	edx, 4
	jmp	SHORT $LN2408@eval
$LN2407@eval:
	fld	QWORD PTR [ecx]
	add	ecx, 8
$LN2408@eval:
	fmul	ST(0), ST(1)
	add	eax, 8
	dec	esi
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LN255@eval
$LN253@eval:

; 5808 :  
; 5809 :             /* increment pointers */
; 5810 :             for ( j = dim-2 ; j >= 0 ; j-- )

	mov	edx, DWORD PTR tv21369[ebp]
	test	edx, edx
	js	$LN3987@eval
	mov	esi, 1
$LN252@eval:

; 5811 :             { pspots[j] += pstride[j];

	mov	eax, DWORD PTR _pstride$92798[ebp+edx*4]
	add	DWORD PTR _pspots$92796[ebp+edx*4], eax

; 5812 :               qspots[j] += qstride[j];

	mov	eax, DWORD PTR _qstride$92799[ebp+edx*4]
	add	DWORD PTR _qspots$92797[ebp+edx*4], eax

; 5813 :               if ( ++inx[j] < minsize[j] )

	add	DWORD PTR _inx$92791[ebp+edx*4], esi
	mov	eax, DWORD PTR _inx$92791[ebp+edx*4]
	mov	ecx, DWORD PTR _pspots$92796[ebp+edx*4]
	mov	edi, DWORD PTR _qspots$92797[ebp+edx*4]
	cmp	eax, DWORD PTR _minsize$92800[ebp+edx*4]
	jl	SHORT $LN2622@eval

; 5818 :                   qspots[k] = q;
; 5819 :                  }
; 5820 :                 break;
; 5821 :               }
; 5822 :               inx[j] = 0 ;

	mov	DWORD PTR _inx$92791[ebp+edx*4], 0
	sub	edx, esi
	jns	SHORT $LN252@eval

; 6334 :                 a = NULL;
; 6335 :               }
; 6336 :             }
; 6337 :          }
; 6338 :         if ( this_frame->flags & BASE_OF_EVAL )

	jmp	SHORT $LN257@eval
$LN2622@eval:

; 5815 :                 q = qspots[j];
; 5816 :                 for ( k = j+1 ; k < dim-1 ; k++ )

	mov	eax, DWORD PTR _dim$92803[ebp]
	mov	DWORD PTR _p$92792[ebp], ecx
	lea	ecx, DWORD PTR [edx+1]
	dec	eax
	mov	DWORD PTR _q$92793[ebp], edi
	cmp	ecx, eax
	jge	SHORT $LN257@eval

; 5814 :               { p = pspots[j];

	sub	eax, ecx
	lea	esi, DWORD PTR _pspots$92796[ebp+ecx*4]
	add	eax, eax
	lea	edi, DWORD PTR _qspots$92797[ebp+ecx*4]
	mov	DWORD PTR tv31090[ebp], esi
	lea	esi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _q$92793[ebp]
	mov	ecx, esi
	shr	ecx, 2
	rep stosd

; 5817 :                 { pspots[k] = p;

	mov	eax, DWORD PTR _p$92792[ebp]
	mov	edi, DWORD PTR tv31090[ebp]
	mov	ecx, esi
	shr	ecx, 2
	rep stosd
$LN257@eval:

; 5823 :             }  
; 5824 :            } while ( j >= 0 );    

	test	edx, edx
	jns	$LN3152@eval
$LN3987@eval:
	fstp	ST(0)

; 5825 :        
; 5826 :          if ( node->flags & RECALC_FLAG )
; 5827 :            recalc_flag = 1;
; 5828 :          if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'
; 5829 :             dont_resize_flag = 1;
; 5830 : 
; 5831 :          } /* end ARRAY_SCALAR_MULTIPLY_NODE */
; 5832 :          break;

	jmp	$LN3977@eval
$LN243@eval:

; 5833 : 
; 5834 :       
; 5835 :       case ARRAY_MULTIPLY_NODE:
; 5836 :         { /* standard matrix multiplication, result in temp matrix */
; 5837 :           /* Like P[I][J][K] = Q[I][J][M]*R[M][K] */
; 5838 :           struct array *alvalue= get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	edi, DWORD PTR _localstack$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	esi, DWORD PTR _localbase$[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+136]
	add	edi, edi
	add	edi, edi
	add	edi, edi
	push	esi
	add	ecx, edi
	push	ecx
	push	eax
	call	_get_name_arrayptr

; 5839 :           struct array *arvalue= get_name_arrayptr(node->op3.name_id,newstack + localstack,localbase);

	mov	ecx, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+140]
	push	esi
	add	ecx, edi
	push	ecx
	push	eax
	call	_get_name_arrayptr

; 5840 :           struct array *asvalue= get_name_arrayptr(node->op4.name_id,newstack + localstack,localbase);

	mov	ecx, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR _node$[ebp]
	push	esi
	add	ecx, edi
	mov	DWORD PTR _arvalue$92873[ebp], eax
	mov	eax, DWORD PTR [edx+148]
	push	ecx
	push	eax
	call	_get_name_arrayptr
	mov	DWORD PTR _asvalue$92874[ebp], eax

; 5841 :           int inx[MAXARRAYDIMS]; /* keep track of indices */
; 5842 :           char *p,*q,*s;
; 5843 :           int j,k;
; 5844 :           char *pspots[MAXARRAYDIMS],*qspots[MAXARRAYDIMS],*sspots[MAXARRAYDIMS];
; 5845 :           int pstride[MAXARRAYDIMS],qstride[MAXARRAYDIMS],sstride[MAXARRAYDIMS];
; 5846 :           int lastsize;
; 5847 :           struct array **array_info; // temp array struct pointer on stack
; 5848 :           int rcount = node[node->left].op5.indexcount;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [ecx+eax+152]

; 5849 :           int scount = node[node->right].op5.indexcount;

	mov	ecx, DWORD PTR [eax+8]
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR tv20300[ebp], edx
	mov	edx, DWORD PTR [ecx+eax+152]

; 5850 :           int dim,ldim,sdim,rdim;
; 5851 :  
; 5852 :           /* Set up temp array for destination */
; 5853 :           g = globals(node->op2.name_id);

	mov	eax, DWORD PTR [eax+136]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 36					; 00000024H
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR tv20303[ebp], edx
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN2413@eval
	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+eax]
	jmp	SHORT $LN3988@eval
$LN2413@eval:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2411@eval
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 5
	add	ecx, DWORD PTR [esi]
	jmp	SHORT $LN3988@eval
$LN2411@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2409@eval
	mov	ecx, DWORD PTR _web+5656
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN3988@eval
$LN2409@eval:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+ecx]
$LN3988@eval:

; 5854 :           alvalue = g->attr.arrayptr;
; 5855 :           dim = alvalue->dim;
; 5856 :           if ( !(g->flags & FIXED_SIZE_ARRAY) )

	test	DWORD PTR [ecx+192], 268435456		; 10000000H
	mov	edx, DWORD PTR [ecx+168]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _g$[ebp], ecx
	mov	DWORD PTR _alvalue$92872[ebp], edx
	mov	DWORD PTR _dim$92891[ebp], eax
	jne	$LN242@eval

; 5857 :           { struct array ta;    
; 5858 :             int size,pointercount; 
; 5859 :             for ( i=0,size=1,pointercount=0 ;
; 5860 :               i + node[node->left].op5.indexcount < arvalue->dim-1 ; i++ )

	mov	eax, DWORD PTR _arvalue$92873[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esi, DWORD PTR tv20300[ebp]
	xor	edx, edx
	dec	eax
	lea	edi, DWORD PTR [edx+1]
	mov	DWORD PTR _pointercount$92900[ebp], edx
	mov	DWORD PTR $T94753[ebp], eax
	cmp	esi, eax
	jge	SHORT $LN239@eval
	lea	ecx, DWORD PTR [esi*4]
	mov	DWORD PTR tv31110[ebp], esi
	mov	eax, ecx
$LN241@eval:

; 5861 :             { pointercount += size;
; 5862 :               ta.sizes[i] = arvalue->sizes[node[node->left].op5.indexcount + i];

	mov	esi, DWORD PTR _arvalue$92873[ebp]
	mov	ecx, DWORD PTR [esi+ecx+24]
	mov	esi, DWORD PTR tv31110[ebp]
	add	DWORD PTR _pointercount$92900[ebp], edi

; 5863 :               size *= ta.sizes[i];

	imul	edi, ecx
	mov	DWORD PTR _ta$92898[ebp+edx*4+24], ecx
	inc	esi
	add	eax, 4
	inc	edx
	mov	DWORD PTR tv31110[ebp], esi
	mov	ecx, eax
	cmp	esi, DWORD PTR $T94753[ebp]
	jl	SHORT $LN241@eval

; 5857 :           { struct array ta;    
; 5858 :             int size,pointercount; 
; 5859 :             for ( i=0,size=1,pointercount=0 ;
; 5860 :               i + node[node->left].op5.indexcount < arvalue->dim-1 ; i++ )

	mov	ecx, DWORD PTR _g$[ebp]
$LN239@eval:

; 5864 :             }
; 5865 :             for ( j = 1 ;
; 5866 :               j + node[node->right].op5.indexcount < asvalue->dim ; j++,i++ )

	mov	eax, DWORD PTR tv20303[ebp]

; 5901 :             p = (char*)(newstack+localstack+g->value.offset);

	mov	esi, DWORD PTR _asvalue$92874[ebp]
	mov	esi, DWORD PTR [esi+4]
	inc	eax
	mov	DWORD PTR $T94754[ebp], esi
	cmp	eax, esi
	jge	SHORT $LN236@eval

; 5864 :             }
; 5865 :             for ( j = 1 ;
; 5866 :               j + node[node->right].op5.indexcount < asvalue->dim ; j++,i++ )

	lea	ecx, DWORD PTR [eax*4]
	mov	DWORD PTR tv31186[ebp], eax
	mov	eax, DWORD PTR tv20303[ebp]
	lea	edx, DWORD PTR _ta$92898[ebp+edx*4+24]
	lea	eax, DWORD PTR [eax*4+4]
	jmp	SHORT $LN238@eval
	npad	1
$LL3086@eval:
	mov	ecx, DWORD PTR tv31164[ebp]
$LN238@eval:

; 5867 :             { pointercount += size;
; 5868 :               ta.sizes[i] = asvalue->sizes[node[node->right].op5.indexcount + j];

	mov	esi, DWORD PTR _asvalue$92874[ebp]
	mov	ecx, DWORD PTR [esi+ecx+24]
	add	DWORD PTR _pointercount$92900[ebp], edi

; 5869 :               size *= ta.sizes[i];

	imul	edi, ecx
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR tv31186[ebp]
	inc	ecx
	add	eax, 4
	add	edx, 4
	mov	DWORD PTR tv31186[ebp], ecx
	mov	DWORD PTR tv31164[ebp], eax
	cmp	ecx, DWORD PTR $T94754[ebp]
	jl	SHORT $LL3086@eval

; 5864 :             }
; 5865 :             for ( j = 1 ;
; 5866 :               j + node[node->right].op5.indexcount < asvalue->dim ; j++,i++ )

	mov	ecx, DWORD PTR _g$[ebp]
$LN236@eval:

; 5870 :             }
; 5871 : 
; 5872 :             alvalue = NULL;
; 5873 :             array_info = (struct array **)(newstack+localstack+g->value.offset);

	mov	ecx, DWORD PTR [ecx+64]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	xor	edx, edx
	lea	esi, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR _alvalue$92872[ebp], edx

; 5874 :             if ( array_info )

	test	esi, esi
	je	SHORT $LN232@eval

; 5875 :             { // see if existing storage enough
; 5876 :               if ( *array_info )

	cmp	DWORD PTR [esi], edx
	je	SHORT $LN232@eval

; 5877 :               { alvalue = *array_info;

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR _alvalue$92872[ebp], edx

; 5878 :                 if ( alvalue->datacount >= size )

	cmp	DWORD PTR [edx+16], edi
	jl	$LN233@eval

; 5879 :                   p = (char*)(alvalue + 1);

	lea	ecx, DWORD PTR [edx+56]
	mov	DWORD PTR _p$92876[ebp], ecx
$LN232@eval:

; 5882 :                   alvalue = NULL;
; 5883 :                 }
; 5884 :               }
; 5885 :             }
; 5886 :             if ( alvalue == NULL )

	test	edx, edx
	jne	SHORT $LN231@eval
$LN2787@eval:

; 5887 :             { alvalue = *array_info = (struct array*)temp_calloc( sizeof(struct array) +
; 5888 :                  (size+1)*sizeof(REAL)+pointercount*sizeof(REAL*),1);  /* extra for alignment */

	mov	edx, DWORD PTR _pointercount$92900[ebp]
	push	5888					; 00001700H
	lea	eax, DWORD PTR [edx+edi*2+16]
	push	OFFSET ??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@
	add	eax, eax
	add	eax, eax
	push	1
	push	eax
	call	_kb_temp_calloc
	mov	edx, eax

; 5889 :               alvalue->flags |= ARRAY_TEMP;
; 5890 :               p = (char*)(alvalue + 1); // for data

	lea	ecx, DWORD PTR [edx+56]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi], eax
	or	DWORD PTR [edx], 32768			; 00008000H
	mov	DWORD PTR _alvalue$92872[ebp], edx
	mov	DWORD PTR _p$92876[ebp], ecx
$LN231@eval:

; 5891 :             }
; 5892 :             alvalue->dim = dim;

	mov	ecx, DWORD PTR _dim$92891[ebp]
	mov	DWORD PTR [edx+4], ecx

; 5893 :             alvalue->datatype = REAL_TYPE;

	mov	DWORD PTR [edx+8], 1

; 5894 :             alvalue->itemsize = sizeof(REAL);

	mov	DWORD PTR [edx+12], 8

; 5895 :             alvalue->datacount = size;

	mov	DWORD PTR [edx+16], edi

; 5896 :             for ( i = 0 ; i < dim ; i++ )

	test	ecx, ecx
	jle	SHORT $LN230@eval

; 5891 :             }
; 5892 :             alvalue->dim = dim;

	mov	edi, DWORD PTR _alvalue$92872[ebp]
	mov	esi, DWORD PTR tv20300[ebp]
	mov	edx, DWORD PTR _alvalue$92872[ebp]
	add	edi, 24					; 00000018H
	lea	esi, DWORD PTR _ta$92898[ebp+esi*4+24]
	rep movsd
$LN230@eval:

; 5897 :               alvalue->sizes[i] = ta.sizes[rcount+i];
; 5898 :             localbase->flags |= LL_HAS_ARRAY;

	mov	eax, DWORD PTR _localbase$[ebp]
	or	DWORD PTR [eax+20], 1

; 5899 :           }
; 5900 :           else 

	jmp	SHORT $LN227@eval
$LN233@eval:

; 5880 :                 else
; 5881 :                 { temp_free((char*)alvalue);

	push	edx
	call	_temp_free
	add	esp, 4

; 5882 :                   alvalue = NULL;
; 5883 :                 }
; 5884 :               }
; 5885 :             }
; 5886 :             if ( alvalue == NULL )

	jmp	$LN2787@eval
$LN242@eval:

; 5901 :             p = (char*)(newstack+localstack+g->value.offset);

	mov	eax, DWORD PTR [ecx+64]
	add	eax, DWORD PTR _localstack$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _p$92876[ebp], eax
$LN227@eval:

; 5902 : 
; 5903 :           /* pop datastarts off stack */
; 5904 :           s = *(char**)(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR _s$92878[ebp], ecx
	mov	DWORD PTR [ebx+48], eax

; 5905 :           q = *(char**)(stacktop--);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _q$92877[ebp], ecx

; 5906 :           
; 5907 :            // push result datastart on stack
; 5908 :           *(REAL**)(++stacktop) = (REAL*)p; 

	mov	ecx, DWORD PTR _p$92876[ebp]
	mov	DWORD PTR [ebx+48], eax
	mov	DWORD PTR [eax], ecx

; 5909 :           
; 5910 :           ldim = alvalue->dim;
; 5911 :           rdim = arvalue->dim - rcount;

	mov	ecx, DWORD PTR _arvalue$92873[ebp]
	mov	esi, DWORD PTR [ecx+4]

; 5912 :           sdim = asvalue->dim - scount;

	mov	ecx, DWORD PTR _asvalue$92874[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	sub	esi, DWORD PTR tv20300[ebp]
	sub	ecx, DWORD PTR tv20303[ebp]
	mov	DWORD PTR _ldim$92892[ebp], eax
	mov	DWORD PTR _rdim$92894[ebp], esi
	mov	DWORD PTR _sdim$92893[ebp], ecx

; 5913 : 
; 5914 :           for ( i = 0 ; i < ldim ; i++ ) 

	test	eax, eax
	jle	SHORT $LN226@eval

; 5902 : 
; 5903 :           /* pop datastarts off stack */
; 5904 :           s = *(char**)(stacktop--);

	mov	ecx, eax
	add	ecx, ecx
	add	ecx, ecx
	shr	ecx, 2
	xor	eax, eax
	lea	edi, DWORD PTR _inx$92875[ebp]
	rep stosd

; 5915 :           { pspots[i] = p;

	mov	ecx, DWORD PTR _ldim$92892[ebp]
	mov	eax, DWORD PTR _p$92876[ebp]
	add	ecx, ecx
	add	ecx, ecx
	shr	ecx, 2
	lea	edi, DWORD PTR _pspots$92881[ebp]
	rep stosd
	mov	ecx, DWORD PTR _sdim$92893[ebp]
	mov	eax, DWORD PTR _ldim$92892[ebp]
$LN226@eval:

; 5916 :             inx[i] = 0;
; 5917 :           }
; 5918 :           for ( i = 0 ; i < rdim ; i++ ) 

	test	esi, esi
	jle	SHORT $LN223@eval
	mov	eax, DWORD PTR _q$92877[ebp]
	mov	ecx, esi
	lea	edi, DWORD PTR _qspots$92882[ebp]
	rep stosd
	mov	ecx, DWORD PTR _sdim$92893[ebp]
	mov	eax, DWORD PTR _ldim$92892[ebp]
$LN223@eval:

; 5919 :             qspots[i] = q;
; 5920 :           for ( i = 0 ; i < sdim ; i++ ) 

	test	ecx, ecx
	jle	SHORT $LN220@eval
	mov	eax, DWORD PTR _s$92878[ebp]
	mov	ecx, DWORD PTR _sdim$92893[ebp]
	lea	edi, DWORD PTR _sspots$92883[ebp]
	rep stosd
	mov	ecx, DWORD PTR _sdim$92893[ebp]
	mov	eax, DWORD PTR _ldim$92892[ebp]
$LN220@eval:

; 5921 :             sspots[i] = s;
; 5922 :           
; 5923 :           if ( ldim >= 1 )

	cmp	eax, 1
	jl	SHORT $LN214@eval

; 5925 :             for ( i = ldim - 2 ; i >= 0 ; i-- )

	add	eax, -2					; fffffffeH
	mov	edi, DWORD PTR [edx+12]
	mov	DWORD PTR _pstride$92884[ebp+eax*4+4], edi
	js	SHORT $LN214@eval

; 5924 :           { pstride[ldim-1] = alvalue->itemsize;

	lea	edx, DWORD PTR [edx+eax*4+28]
	npad	9
$LL216@eval:

; 5926 :               pstride[i] = pstride[i+1]*alvalue->sizes[i+1];

	mov	edi, DWORD PTR _pstride$92884[ebp+eax*4+4]
	imul	edi, DWORD PTR [edx]
	mov	DWORD PTR _pstride$92884[ebp+eax*4], edi
	sub	edx, 4
	dec	eax
	jns	SHORT $LL216@eval
$LN214@eval:

; 5927 :           }
; 5928 :           if ( rdim >= 1 )
; 5929 :           {
; 5930 :             qstride[rdim-1] = arvalue->itemsize;            

	mov	edi, DWORD PTR _arvalue$92873[ebp]
	cmp	esi, 1
	jl	SHORT $LN210@eval
	mov	edx, DWORD PTR [edi+12]

; 5931 :             for ( i = rdim - 2 ; i >= 0 ; i-- )

	lea	eax, DWORD PTR [esi-2]
	mov	DWORD PTR _qstride$92885[ebp+esi*4-4], edx
	test	eax, eax
	js	SHORT $LN210@eval

; 5927 :           }
; 5928 :           if ( rdim >= 1 )
; 5929 :           {
; 5930 :             qstride[rdim-1] = arvalue->itemsize;            

	mov	edx, DWORD PTR tv20300[ebp]
	add	edx, eax
	lea	edx, DWORD PTR [edi+edx*4+28]
	npad	1
$LL212@eval:

; 5932 :               qstride[i] = qstride[i+1]*arvalue->sizes[rcount+i+1];              

	mov	esi, DWORD PTR _qstride$92885[ebp+eax*4+4]
	imul	esi, DWORD PTR [edx]
	mov	DWORD PTR _qstride$92885[ebp+eax*4], esi
	sub	edx, 4
	dec	eax
	jns	SHORT $LL212@eval
$LN210@eval:

; 5933 :           }
; 5934 :           if ( sdim >= 1 )
; 5935 :           {
; 5936 :             sstride[sdim-1] = asvalue->itemsize;

	mov	edx, DWORD PTR _asvalue$92874[ebp]
	cmp	ecx, 1
	jl	SHORT $LN206@eval
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _sstride$92886[ebp+ecx*4-4], eax

; 5937 :             for ( i = sdim - 2 ; i >= 0 ; i-- )

	lea	eax, DWORD PTR [ecx-2]
	test	eax, eax
	js	SHORT $LN206@eval

; 5933 :           }
; 5934 :           if ( sdim >= 1 )
; 5935 :           {
; 5936 :             sstride[sdim-1] = asvalue->itemsize;

	mov	ecx, DWORD PTR tv20303[ebp]
	add	ecx, eax
	lea	ecx, DWORD PTR [edx+ecx*4+28]
	npad	1
$LL208@eval:

; 5938 :               sstride[i] = sstride[i+1]*asvalue->sizes[scount+i+1];            

	mov	esi, DWORD PTR _sstride$92886[ebp+eax*4+4]
	imul	esi, DWORD PTR [ecx]
	mov	DWORD PTR _sstride$92886[ebp+eax*4], esi
	sub	ecx, 4
	dec	eax
	jns	SHORT $LL208@eval
$LN206@eval:

; 5939 :           }
; 5940 :           lastsize = arvalue->sizes[arvalue->dim-1];

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+eax*4+20]

; 5941 :           if ( lastsize != asvalue->sizes[scount] )

	mov	eax, DWORD PTR tv20303[ebp]
	mov	eax, DWORD PTR [edx+eax*4+24]
	mov	DWORD PTR _lastsize$92887[ebp], ecx
	cmp	ecx, eax
	je	SHORT $LN205@eval

; 5942 :           { sprintf(errmsg,"Mismatched sizes in matrix multiplication, %d vs %d\n",
; 5943 :                 lastsize,asvalue->sizes[scount] );

	push	eax
	push	ecx
	push	OFFSET ??_C@_0DF@LLDCAMHI@Mismatched?5sizes?5in?5matrix?5multi@
	push	OFFSET _errmsg
	call	_sprintf

; 5944 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 5945 :                           file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL2874@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2874@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 5946 :             kb_error(1916,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1916					; 0000077cH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN205@eval:

; 5947 :           }
; 5948 : 
; 5949 :           p = pspots[0];

	mov	esi, DWORD PTR _pspots$92881[ebp]

; 5950 :           q = qspots[0];

	mov	eax, DWORD PTR _qspots$92882[ebp]

; 5951 :           s = sspots[0];

	mov	ecx, DWORD PTR _sspots$92883[ebp]
	mov	edi, DWORD PTR _sstride$92886[ebp]
	mov	DWORD PTR _p$92876[ebp], esi
	mov	DWORD PTR _q$92877[ebp], eax
	mov	DWORD PTR _s$92878[ebp], ecx
	npad	1
$LL204@eval:

; 5952 :           do
; 5953 :           { 
; 5954 :             REAL *pp = (REAL*)p;
; 5955 :             char *qq = q;
; 5956 :             char *ss = s;
; 5957 :             *pp = 0.0;

	fldz

; 5958 :              if ( (arvalue->datatype == INTEGER_TYPE) && (asvalue->datatype == INTEGER_TYPE) )

	mov	edx, DWORD PTR _arvalue$92873[ebp]
	mov	eax, DWORD PTR _q$92877[ebp]
	fstp	QWORD PTR [esi]
	mov	edx, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _s$92878[ebp]
	mov	DWORD PTR tv21612[ebp], edx
	cmp	edx, 2
	jne	SHORT $LN196@eval
	mov	edx, DWORD PTR _asvalue$92874[ebp]
	cmp	DWORD PTR [edx+8], 2
	jne	SHORT $LN3080@eval

; 5959 :                for ( i = 0 ; i < lastsize ; i++ ) 

	mov	edx, DWORD PTR _lastsize$92887[ebp]
	test	edx, edx
	jle	$LN184@eval
	mov	DWORD PTR tv6070[ebp], edx
$LL200@eval:

; 5960 :                { *pp += (*(int*)qq)*(*(int*)ss);

	mov	edx, DWORD PTR [ecx]
	imul	edx, DWORD PTR [eax]
	mov	DWORD PTR tv24967[ebp], edx

; 5961 :                   qq += sizeof(int);

	add	eax, 4
	fild	DWORD PTR tv24967[ebp]

; 5962 :                   ss += sstride[0];

	add	ecx, edi
	dec	DWORD PTR tv6070[ebp]
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	jne	SHORT $LL200@eval

; 5963 :                }
; 5964 :              else if ( arvalue->datatype == INTEGER_TYPE )

	jmp	SHORT $LN184@eval
$LN3080@eval:
	mov	edx, DWORD PTR tv21612[ebp]
	cmp	edx, 2
	jne	SHORT $LN196@eval

; 5965 :                for ( i = 0 ; i < lastsize ; i++ ) 

	mov	edx, DWORD PTR _lastsize$92887[ebp]
	test	edx, edx
	jle	SHORT $LN184@eval
	npad	3
$LL195@eval:

; 5966 :                { *pp += (*(int*)qq)*(*(REAL*)ss);

	fild	DWORD PTR [eax]

; 5967 :                   qq += sizeof(int);

	add	eax, 4
	fmul	QWORD PTR [ecx]

; 5968 :                   ss += sstride[0];

	add	ecx, edi
	dec	edx
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	jne	SHORT $LL195@eval

; 5969 :                }
; 5970 :             else if ( asvalue->datatype == INTEGER_TYPE )

	jmp	SHORT $LN184@eval
$LN196@eval:
	mov	edx, DWORD PTR _asvalue$92874[ebp]
	cmp	DWORD PTR [edx+8], 2

; 5971 :                for ( i = 0 ; i < lastsize ; i++ ) 

	mov	edx, DWORD PTR _lastsize$92887[ebp]
	jne	SHORT $LN191@eval
	test	edx, edx
	jle	SHORT $LN184@eval
$LL190@eval:

; 5972 :                { *pp += (*(REAL*)qq)*(*(int*)ss);

	fild	DWORD PTR [ecx]

; 5973 :                   qq += sizeof(REAL);

	add	eax, 8

; 5974 :                   ss += sstride[0];

	add	ecx, edi
	dec	edx
	fmul	QWORD PTR [eax-8]
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	jne	SHORT $LL190@eval

; 5975 :                }
; 5976 :             else 

	jmp	SHORT $LN184@eval
$LN191@eval:

; 5977 :                for ( i = 0 ; i < lastsize ; i++ ) 

	test	edx, edx
	jle	SHORT $LN184@eval
	npad	1
$LL186@eval:

; 5978 :                { *pp += (*(REAL*)qq)*(*(REAL*)ss);

	fld	QWORD PTR [ecx]

; 5979 :                   qq += sizeof(REAL);

	add	eax, 8
	fmul	QWORD PTR [eax-8]

; 5980 :                   ss += sstride[0];

	add	ecx, edi
	dec	edx
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	jne	SHORT $LL186@eval
$LN184@eval:

; 5981 :                }
; 5982 : 
; 5983 :             /* increment pointers */
; 5984 :             for ( j = ldim-1 ; j >= 0 ; j-- )

	mov	edx, DWORD PTR _ldim$92892[ebp]
	dec	edx
	js	$LN203@eval
	mov	eax, DWORD PTR _alvalue$92872[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+24]
	mov	eax, edx
	sub	eax, DWORD PTR _rdim$92894[ebp]
	mov	DWORD PTR tv31696[ebp], ecx
	add	eax, eax
	add	eax, eax
$LN183@eval:

; 5985 :             { pspots[j] += pstride[j];

	mov	ecx, DWORD PTR _pstride$92884[ebp+edx*4]
	add	DWORD PTR _pspots$92881[ebp+edx*4], ecx

; 5986 :               if ( j < rdim-1 )

	mov	ecx, DWORD PTR _rdim$92894[ebp]
	dec	ecx
	cmp	edx, ecx
	jge	SHORT $LN180@eval

; 5987 :                 qspots[j] += qstride[j];

	mov	ecx, DWORD PTR _qstride$92885[ebp+edx*4]
	add	DWORD PTR _qspots$92882[ebp+edx*4], ecx

; 5988 :               else

	jmp	SHORT $LN179@eval
$LN180@eval:

; 5989 :                 sspots[j-rdim+2] += sstride[j-rdim+2];

	mov	ecx, DWORD PTR _sstride$92886[ebp+eax+8]
	add	DWORD PTR _sspots$92883[ebp+eax+8], ecx
$LN179@eval:

; 5990 :               if ( ++inx[j] < alvalue->sizes[j] )

	inc	DWORD PTR _inx$92875[ebp+edx*4]
	mov	ecx, DWORD PTR _inx$92875[ebp+edx*4]
	mov	edi, DWORD PTR tv31696[ebp]
	cmp	ecx, DWORD PTR [edi]
	jl	SHORT $LN2623@eval

; 5999 :                   sspots[k] = s;
; 6000 :                  
; 6001 :                 break;
; 6002 :               }
; 6003 :               inx[j] = 0 ;

	sub	DWORD PTR tv31696[ebp], 4
	mov	DWORD PTR _inx$92875[ebp+edx*4], 0
	sub	eax, 4
	dec	edx
	jns	SHORT $LN183@eval

; 6334 :                 a = NULL;
; 6335 :               }
; 6336 :             }
; 6337 :          }
; 6338 :         if ( this_frame->flags & BASE_OF_EVAL )

	jmp	$LN3990@eval
$LN2623@eval:

; 5992 :                 q = qspots[j];

	mov	eax, DWORD PTR _qspots$92882[ebp+edx*4]
	mov	esi, DWORD PTR _pspots$92881[ebp+edx*4]
	mov	DWORD PTR _q$92877[ebp], eax

; 5993 :                 s = sspots[j-rdim+2];

	mov	eax, edx
	sub	eax, DWORD PTR _rdim$92894[ebp]
	mov	ecx, DWORD PTR _sspots$92883[ebp+eax*4+8]
	mov	DWORD PTR _s$92878[ebp], ecx

; 5994 :                 for ( k = j+1 ; k < ldim ; k++ )

	lea	ecx, DWORD PTR [edx+1]
	mov	DWORD PTR tv21662[ebp], eax
	cmp	ecx, DWORD PTR _ldim$92892[ebp]
	jge	SHORT $LN3079@eval

; 5991 :               { p = pspots[j];                

	mov	ecx, DWORD PTR _ldim$92892[ebp]
	lea	eax, DWORD PTR [edx+1]
	lea	edi, DWORD PTR _pspots$92881[ebp+eax*4]
	sub	ecx, eax
	mov	eax, esi
	rep stosd
	mov	eax, DWORD PTR tv21662[ebp]
$LN3079@eval:
	mov	edi, DWORD PTR _sstride$92886[ebp]

; 5995 :                   pspots[k] = p;
; 5996 :                 for ( k = j+1 ; k < rdim ; k++ )

	lea	ecx, DWORD PTR [edx+1]
	cmp	ecx, DWORD PTR _rdim$92894[ebp]
	jge	SHORT $LN174@eval
	mov	ecx, DWORD PTR _rdim$92894[ebp]
	lea	eax, DWORD PTR [edx+1]
	lea	edi, DWORD PTR _qspots$92882[ebp+eax*4]
	sub	ecx, eax
	mov	eax, DWORD PTR _q$92877[ebp]
	rep stosd
	mov	eax, DWORD PTR tv21662[ebp]
	mov	edi, DWORD PTR _sstride$92886[ebp]
$LN174@eval:

; 5997 :                   qspots[k] = q;
; 5998 :                 for ( k = j-rdim+2 ; k < sdim ; k++ )

	add	eax, 2
	cmp	eax, DWORD PTR _sdim$92893[ebp]
	jge	SHORT $LN203@eval
	mov	ecx, DWORD PTR _sdim$92893[ebp]
	lea	edi, DWORD PTR _sspots$92883[ebp+eax*4]
	sub	ecx, eax
	mov	eax, DWORD PTR _s$92878[ebp]
	rep stosd
$LN3990@eval:
	mov	edi, DWORD PTR _sstride$92886[ebp]
$LN203@eval:

; 6004 :             }  
; 6005 :            } while ( j >= 0 );         

	test	edx, edx
	jns	$LL204@eval

; 5991 :               { p = pspots[j];                

	mov	DWORD PTR _p$92876[ebp], esi

; 6006 : 
; 6007 :           if ( node->flags & RECALC_FLAG )
; 6008 :             recalc_flag = 1;
; 6009 :           if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'
; 6010 :             dont_resize_flag = 1;
; 6011 :      
; 6012 : 
; 6013 :          } /* end ARRAY_MULTIPLY_NODE */
; 6014 :          break;

	jmp	$LN3977@eval
$LN166@eval:

; 6015 : 
; 6016 :       case ARRAY_ASSIGNOP_A_X_A_NODE:
; 6017 :         { /* standard matrix multiplication */
; 6018 :           /* Like P[I][J][K] = Q[I][J][M]*R[M][K] */
; 6019 :           struct array *alvalue= get_name_arrayptr(node->op2.name_id,newstack + localstack,localbase);

	mov	edi, DWORD PTR _localstack$[ebp]
	mov	edx, DWORD PTR [ebx+40]
	mov	esi, DWORD PTR _localbase$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	add	edi, edi
	add	edi, edi
	add	edi, edi
	push	esi
	add	edx, edi
	push	edx
	push	ecx
	call	_get_name_arrayptr

; 6020 :           struct array *arvalue= get_name_arrayptr(node->op3.name_id,newstack + localstack,localbase);

	mov	edx, DWORD PTR [ebx+40]
	mov	DWORD PTR _alvalue$93011[ebp], eax
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	esi
	add	edx, edi
	push	edx
	push	ecx
	call	_get_name_arrayptr

; 6021 :           struct array *asvalue= get_name_arrayptr(node->op4.name_id,newstack + localstack,localbase);

	mov	edx, DWORD PTR [ebx+40]
	mov	DWORD PTR _arvalue$93012[ebp], eax
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	push	esi
	add	edx, edi
	push	edx
	push	ecx
	call	_get_name_arrayptr

; 6022 :           int inx[MAXARRAYDIMS]; /* keep track of indices */
; 6023 :           char *p,*q,*s;
; 6024 :           int j,k;
; 6025 :           char *pspots[MAXARRAYDIMS],*qspots[MAXARRAYDIMS],*sspots[MAXARRAYDIMS];
; 6026 :           int pstride[MAXARRAYDIMS],qstride[MAXARRAYDIMS],sstride[MAXARRAYDIMS];
; 6027 :           int lastsize;
; 6028 :           int lcount = node[node->left].op5.indexcount;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, eax
	mov	eax, DWORD PTR [ecx+4]
	imul	eax, 168				; 000000a8H
	mov	edi, DWORD PTR [eax+ecx+152]

; 6029 :           struct treenode *rvalue_node = node + node->right;

	mov	eax, DWORD PTR [ecx+8]
	imul	eax, 168				; 000000a8H
	add	eax, ecx

; 6030 :           int rcount = rvalue_node[rvalue_node->left].op5.indexcount;

	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 168				; 000000a8H
	mov	ecx, DWORD PTR [ecx+eax+152]
	mov	DWORD PTR _rcount$93029[ebp], ecx

; 6031 :           int scount = rvalue_node[rvalue_node->right].op5.indexcount;

	mov	ecx, DWORD PTR [eax+8]
	imul	ecx, 168				; 000000a8H
	mov	esi, DWORD PTR [ecx+eax+152]

; 6032 : 
; 6033 :           int ldim,sdim,rdim;
; 6034 :           REAL *ptemp,*rtemp,*stemp;
; 6035 :           int *oldp; /* destination integer array */
; 6036 :  
; 6037 :           /* Was checked in parser that the arrays have the same number
; 6038 :              of indices, but might be different sizes.  So do
; 6039 :              intersection. */
; 6040 :           /* pop datastarts off stack */
; 6041 :           s = *(char**)(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax

; 6042 :           q = *(char**)(stacktop--);

	add	eax, -8					; fffffff8H
	mov	DWORD PTR _s$93017[ebp], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ebx+48], eax

; 6043 :           p = *(char**)(stacktop--);

	add	eax, -8					; fffffff8H
	mov	DWORD PTR _q$93016[ebp], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ebx+48], eax
	mov	DWORD PTR _p$93015[ebp], ecx

; 6044 :           
; 6045 :           ldim = alvalue->dim - lcount;

	mov	ecx, DWORD PTR _alvalue$93011[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, edi
	mov	DWORD PTR _ldim$93031[ebp], eax

; 6046 :           rdim = arvalue->dim - rcount;

	mov	eax, DWORD PTR _arvalue$93012[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR _rcount$93029[ebp]
	mov	DWORD PTR _asvalue$93013[ebp], edx

; 6047 :           sdim = asvalue->dim - scount;

	mov	edx, DWORD PTR [edx+4]
	sub	edx, esi
	add	esp, 36					; 00000024H

; 6048 : 
; 6049 :           /* Temp arrays in case of integer data */
; 6050 :           if ( alvalue->datatype == INTEGER_TYPE )

	cmp	DWORD PTR [ecx+8], 2
	mov	DWORD PTR _lcount$93027[ebp], edi
	mov	DWORD PTR _scount$93030[ebp], esi
	mov	DWORD PTR _rdim$93033[ebp], eax
	mov	DWORD PTR _sdim$93032[ebp], edx
	jne	$LN165@eval

; 6051 :           { int count;
; 6052 :             for ( count = 1, j = 0 ; j < ldim ; j++ )

	mov	ecx, DWORD PTR _ldim$93031[ebp]
	mov	edi, 1
	test	ecx, ecx
	jle	SHORT $LN162@eval
	mov	edx, DWORD PTR _alvalue$93011[ebp]
	mov	eax, DWORD PTR _lcount$93027[ebp]
	lea	eax, DWORD PTR [edx+eax*4+24]
	npad	2
$LL164@eval:

; 6053 :                 count *= alvalue->sizes[lcount+j];

	imul	edi, DWORD PTR [eax]
	add	eax, 4
	dec	ecx
	jne	SHORT $LL164@eval
$LN162@eval:

; 6054 :             ptemp = (REAL*)temp_calloc(count,sizeof(REAL));

	push	6054					; 000017a6H
	push	OFFSET ??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@
	push	8
	push	edi
	call	_kb_temp_calloc

; 6055 :             oldp = (int*)p;

	mov	edx, DWORD PTR _p$93015[ebp]
	mov	ecx, eax

; 6056 :             if ( node->op1.assigntype != ASSIGN_OP )

	mov	eax, DWORD PTR _node$[ebp]
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [eax+32], 30001		; 00007531H
	mov	DWORD PTR _ptemp$93034[ebp], ecx
	mov	DWORD PTR _oldp$93037[ebp], edx
	je	SHORT $LN158@eval

; 6057 :               for ( j = 0 ; j < count ; j++ )

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN158@eval
$LL160@eval:

; 6058 :                 ptemp[j] = ((int*)p)[j];

	fild	DWORD PTR [edx+eax*4]
	inc	eax
	fstp	QWORD PTR [ecx+eax*8-8]
	cmp	eax, edi
	jl	SHORT $LL160@eval
$LN158@eval:

; 6059 :             p = (char*)ptemp;

	mov	DWORD PTR _p$93015[ebp], ecx
$LN165@eval:

; 6060 :           }
; 6061 : 
; 6062 :           /* Temp arrays in case of integer data */
; 6063 :           if ( arvalue->datatype == INTEGER_TYPE )

	mov	eax, DWORD PTR _arvalue$93012[ebp]
	mov	esi, 2
	cmp	DWORD PTR [eax+8], esi
	jne	SHORT $LN157@eval

; 6064 :           { int count;
; 6065 :             for ( count = 1, j = 0 ; j < rdim ; j++ )

	mov	ecx, DWORD PTR _rdim$93033[ebp]
	lea	edi, DWORD PTR [esi-1]
	test	ecx, ecx
	jle	SHORT $LN154@eval
	mov	edx, DWORD PTR _rcount$93029[ebp]
	lea	eax, DWORD PTR [eax+edx*4+24]
$LL156@eval:

; 6066 :                 count *= arvalue->sizes[rcount+j];

	imul	edi, DWORD PTR [eax]
	add	eax, 4
	dec	ecx
	jne	SHORT $LL156@eval
$LN154@eval:

; 6067 :             rtemp = (REAL*)temp_calloc(count,sizeof(REAL));

	push	6067					; 000017b3H
	push	OFFSET ??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@
	push	8
	push	edi
	call	_kb_temp_calloc
	mov	ecx, eax
	add	esp, 16					; 00000010H

; 6068 :             for ( j = 0 ; j < count ; j++ )

	xor	eax, eax
	mov	DWORD PTR _rtemp$93035[ebp], ecx
	test	edi, edi
	jle	SHORT $LN151@eval
	mov	edx, DWORD PTR _q$93016[ebp]
$LL153@eval:

; 6069 :               rtemp[j] = ((int*)q)[j];

	fild	DWORD PTR [edx+eax*4]
	inc	eax
	fstp	QWORD PTR [ecx+eax*8-8]
	cmp	eax, edi
	jl	SHORT $LL153@eval
$LN151@eval:

; 6070 :             q = (char*)rtemp;

	mov	DWORD PTR _q$93016[ebp], ecx
$LN157@eval:

; 6071 :           }
; 6072 : 
; 6073 :           /* Temp arrays in case of integer data */
; 6074 :           if ( asvalue->datatype == INTEGER_TYPE )

	mov	eax, DWORD PTR _asvalue$93013[ebp]
	cmp	DWORD PTR [eax+8], esi

; 6075 :           { int count;
; 6076 :             for ( count = 1, j = 0 ; j < sdim ; j++ )

	mov	esi, DWORD PTR _sdim$93032[ebp]
	jne	SHORT $LN150@eval
	mov	edi, 1
	test	esi, esi
	jle	SHORT $LN147@eval
	mov	edx, DWORD PTR _scount$93030[ebp]
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx+edx*4+24]
	mov	ecx, esi
	npad	4
$LL149@eval:

; 6077 :                 count *= asvalue->sizes[scount+j];

	imul	edi, DWORD PTR [eax]
	add	eax, 4
	dec	ecx
	jne	SHORT $LL149@eval
$LN147@eval:

; 6078 :             stemp = (REAL*)temp_calloc(count,sizeof(REAL));

	push	6078					; 000017beH
	push	OFFSET ??_C@_0L@HDDEKBBF@EVALTREE?4C?$AA@
	push	8
	push	edi
	call	_kb_temp_calloc
	mov	ecx, eax
	add	esp, 16					; 00000010H

; 6079 :             for ( j = 0 ; j < count ; j++ )

	xor	eax, eax
	mov	DWORD PTR _stemp$93036[ebp], ecx
	test	edi, edi
	jle	SHORT $LN144@eval
	mov	edx, DWORD PTR _s$93017[ebp]
$LL146@eval:

; 6080 :               stemp[j] = ((int*)s)[j];

	fild	DWORD PTR [edx+eax*4]
	inc	eax
	fstp	QWORD PTR [ecx+eax*8-8]
	cmp	eax, edi
	jl	SHORT $LL146@eval
$LN144@eval:

; 6081 :             s = (char*)stemp;

	mov	DWORD PTR _s$93017[ebp], ecx
$LN150@eval:

; 6082 :           }
; 6083 : 
; 6084 :           for ( i = 0 ; i < ldim ; i++ ) 

	mov	edx, DWORD PTR _ldim$93031[ebp]
	test	edx, edx
	jle	SHORT $LN143@eval
	lea	esi, DWORD PTR [edx*4]
	mov	ecx, esi
	shr	ecx, 2
	xor	eax, eax
	lea	edi, DWORD PTR _inx$93014[ebp]
	rep stosd

; 6085 :           { pspots[i] = p;

	mov	eax, DWORD PTR _p$93015[ebp]
	mov	ecx, esi
	mov	esi, DWORD PTR _sdim$93032[ebp]
	shr	ecx, 2
	lea	edi, DWORD PTR _pspots$93020[ebp]
	rep stosd
$LN143@eval:

; 6086 :             inx[i] = 0;
; 6087 :           }
; 6088 :           for ( i = 0 ; i < rdim ; i++ ) 

	mov	edi, DWORD PTR _rdim$93033[ebp]
	test	edi, edi
	jle	SHORT $LN140@eval
	mov	eax, DWORD PTR _q$93016[ebp]
	mov	ecx, edi
	lea	edi, DWORD PTR _qspots$93021[ebp]
	rep stosd
	mov	edi, DWORD PTR _rdim$93033[ebp]
$LN140@eval:

; 6089 :             qspots[i] = q;
; 6090 :           for ( i = 0 ; i < sdim ; i++ ) 

	test	esi, esi
	jle	SHORT $LN137@eval
	mov	eax, DWORD PTR _s$93017[ebp]
	mov	ecx, esi
	lea	edi, DWORD PTR _sspots$93022[ebp]
	rep stosd
	mov	edi, DWORD PTR _rdim$93033[ebp]
$LN137@eval:

; 6091 :             sspots[i] = s;
; 6092 :           
; 6093 :           if ( ldim >= 1 )

	cmp	edx, 1
	jl	SHORT $LN131@eval

; 6095 :             for ( i = ldim - 2 ; i >= 0 ; i-- )

	lea	eax, DWORD PTR [edx-2]
	mov	DWORD PTR _pstride$93023[ebp+edx*4-4], 8
	test	eax, eax
	js	SHORT $LN131@eval

; 6094 :           { pstride[ldim-1] = sizeof(DOUBLE);

	mov	ecx, DWORD PTR _lcount$93027[ebp]
	lea	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _alvalue$93011[ebp]
	lea	ecx, DWORD PTR [ecx+edx*4+28]
$LL133@eval:

; 6096 :               pstride[i] = pstride[i+1]*alvalue->sizes[lcount+i+1];

	mov	edx, DWORD PTR _pstride$93023[ebp+eax*4+4]
	imul	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pstride$93023[ebp+eax*4], edx
	sub	ecx, 4
	dec	eax
	jns	SHORT $LL133@eval
$LN131@eval:

; 6097 :           }
; 6098 :           if ( rdim >= 1 )

	cmp	edi, 1
	jl	SHORT $LN3136@eval

; 6101 :             for ( i = rdim - 2 ; i >= 0 ; i-- )

	lea	eax, DWORD PTR [edi-2]
	mov	DWORD PTR _qstride$93024[ebp+edi*4-4], 8
	test	eax, eax
	js	SHORT $LN3136@eval

; 6099 :           {
; 6100 :             qstride[rdim-1] = sizeof(DOUBLE);            

	mov	ecx, DWORD PTR _rcount$93029[ebp]
	mov	edx, DWORD PTR _arvalue$93012[ebp]
	add	ecx, eax
	lea	ecx, DWORD PTR [edx+ecx*4+28]
$LL129@eval:

; 6102 :               qstride[i] = qstride[i+1]*arvalue->sizes[rcount+i+1];              

	mov	edi, DWORD PTR _qstride$93024[ebp+eax*4+4]
	imul	edi, DWORD PTR [ecx]
	mov	DWORD PTR _qstride$93024[ebp+eax*4], edi
	sub	ecx, 4
	dec	eax
	jns	SHORT $LL129@eval

; 6101 :             for ( i = rdim - 2 ; i >= 0 ; i-- )

	jmp	SHORT $LN127@eval
$LN3136@eval:
	mov	edx, DWORD PTR _arvalue$93012[ebp]
$LN127@eval:

; 6103 :           }
; 6104 :          if ( sdim >= 1 )

	cmp	esi, 1
	jl	SHORT $LN123@eval

; 6107 :             for ( i = sdim - 2 ; i >= 0 ; i-- )

	lea	eax, DWORD PTR [esi-2]
	mov	DWORD PTR _sstride$93025[ebp+esi*4-4], 8
	test	eax, eax
	js	SHORT $LN123@eval

; 6105 :           {
; 6106 :             sstride[sdim-1] = sizeof(DOUBLE);

	mov	ecx, DWORD PTR _scount$93030[ebp]
	mov	esi, DWORD PTR _asvalue$93013[ebp]
	add	ecx, eax
	lea	ecx, DWORD PTR [esi+ecx*4+28]
	npad	7
$LL125@eval:

; 6108 :               sstride[i] = sstride[i+1]*asvalue->sizes[scount+i+1];            

	mov	esi, DWORD PTR _sstride$93025[ebp+eax*4+4]
	imul	esi, DWORD PTR [ecx]
	mov	DWORD PTR _sstride$93025[ebp+eax*4], esi
	sub	ecx, 4
	dec	eax
	jns	SHORT $LL125@eval
$LN123@eval:

; 6109 :           }
; 6110 :           lastsize = arvalue->sizes[arvalue->dim-1];

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+eax*4+20]

; 6111 :           if ( lastsize != asvalue->sizes[scount] )

	mov	eax, DWORD PTR _scount$93030[ebp]
	mov	edx, DWORD PTR _asvalue$93013[ebp]
	lea	esi, DWORD PTR [edx+eax*4+24]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _lastsize$93026[ebp], ecx
	mov	DWORD PTR tv21867[ebp], esi
	cmp	ecx, eax
	je	SHORT $LN122@eval

; 6112 :           { sprintf(errmsg,"Mismatched sizes in matrix multiplication, %d vs %d.\n",lastsize,
; 6113 :                asvalue->sizes[scount]);

	push	eax
	push	ecx
	push	OFFSET ??_C@_0DG@JLMOMNLE@Mismatched?5sizes?5in?5matrix?5multi@
	push	OFFSET _errmsg
	call	_sprintf

; 6114 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6115 :                           file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL2875@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2875@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 6116 :             kb_error(1917,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1917					; 0000077dH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN122@eval:

; 6117 :           }
; 6118 :           for ( j = 0 ; j < rdim-1 ; j++ )

	mov	ecx, DWORD PTR _rdim$93033[ebp]
	lea	eax, DWORD PTR [ecx-1]
	xor	edi, edi
	test	eax, eax
	jle	$LN3138@eval
	mov	edx, DWORD PTR _alvalue$93011[ebp]
	mov	eax, DWORD PTR _lcount$93027[ebp]
	lea	eax, DWORD PTR [edx+eax*4+24]
	mov	edx, DWORD PTR _arvalue$93012[ebp]
	mov	DWORD PTR tv32342[ebp], eax
	mov	eax, DWORD PTR _rcount$93029[ebp]
	lea	edx, DWORD PTR [edx+eax*4+24]
	mov	DWORD PTR tv32344[ebp], edx
	lea	edx, DWORD PTR [edi+4]
	npad	9
$LL121@eval:

; 6119 :           { if ( alvalue->sizes[lcount+j] != arvalue->sizes[rcount+j] )

	mov	eax, DWORD PTR tv32342[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR tv32344[ebp]
	cmp	eax, DWORD PTR [esi]
	je	$LN120@eval

; 6120 :             { sprintf(errmsg,"Mismatched sizes in matrix multiplication.  \n");

	push	OFFSET ??_C@_0CO@PIJDLECB@Mismatched?5sizes?5in?5matrix?5multi@
	push	OFFSET _errmsg
	call	_sprintf

; 6121 :               sprintf(errmsg+strlen(errmsg),"Index %d of left side is %d, index %d of first factor is %d\n",
; 6122 :                 lcount+j+1,alvalue->sizes[lcount+j],rcount+j+1,arvalue->sizes[rcount+j]);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	esi, DWORD PTR [eax+1]
$LL2876@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2876@eval
	mov	ecx, DWORD PTR tv32344[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _rcount$93029[ebp]
	push	edx
	lea	edx, DWORD PTR [edi+ecx+1]
	mov	ecx, DWORD PTR tv32342[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _lcount$93027[ebp]
	push	edx
	lea	edx, DWORD PTR [edi+ecx+1]
	push	edx
	sub	eax, esi
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0DN@OGAILEKP@Index?5?$CFd?5of?5left?5side?5is?5?$CFd?0?5ind@
	push	eax
	call	_sprintf

; 6123 :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6124 :                           file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 24					; 00000018H
	lea	esi, DWORD PTR [eax+1]
	npad	3
$LL2877@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2877@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 6125 :               kb_error(4530,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4530					; 000011b2H
	call	_kb_error
	mov	ecx, DWORD PTR _rdim$93033[ebp]
	add	esp, 28					; 0000001cH
	mov	edx, 4
$LN120@eval:

; 6117 :           }
; 6118 :           for ( j = 0 ; j < rdim-1 ; j++ )

	add	DWORD PTR tv32344[ebp], edx
	add	DWORD PTR tv32342[ebp], edx
	inc	edi
	lea	eax, DWORD PTR [ecx-1]
	cmp	edi, eax
	jl	$LL121@eval
	mov	esi, DWORD PTR tv21867[ebp]
	jmp	SHORT $LN119@eval
$LN3138@eval:
	mov	edx, 4
$LN119@eval:

; 6126 :             }
; 6127 :           }
; 6128 :           for ( j = 0 ; j < scount-1 ; j++ )

	mov	eax, DWORD PTR _scount$93030[ebp]
	dec	eax
	xor	edi, edi
	test	eax, eax
	jle	$LN115@eval
	mov	eax, DWORD PTR _lcount$93027[ebp]
	add	eax, ecx
	mov	ecx, DWORD PTR _alvalue$93011[ebp]
	mov	DWORD PTR tv21884[ebp], eax
	lea	eax, DWORD PTR [ecx+eax*4+24]
	mov	DWORD PTR tv32420[ebp], esi
	mov	DWORD PTR tv32424[ebp], eax
	npad	6
$LL117@eval:

; 6129 :           { if ( alvalue->sizes[lcount+rdim+j] != asvalue->sizes[scount+j+1] )

	mov	ecx, DWORD PTR tv32424[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv32420[ebp]
	cmp	eax, DWORD PTR [ecx+4]
	je	$LN116@eval

; 6130 :             { sprintf(errmsg,"Mismatched sizes in matrix multiplication.\n");

	push	OFFSET ??_C@_0CM@JKKPHDDL@Mismatched?5sizes?5in?5matrix?5multi@
	push	OFFSET _errmsg
	call	_sprintf

; 6131 :               sprintf(errmsg+strlen(errmsg),"Index %d of left side is %d, index %d of second factor is %d\n",
; 6132 :                 lcount+rdim+j+1,alvalue->sizes[lcount+j],scount+j+1,asvalue->sizes[scount+j]);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	esi, DWORD PTR [eax+1]
$LL2878@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2878@eval
	mov	edx, DWORD PTR tv32420[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _scount$93030[ebp]
	push	ecx
	lea	ecx, DWORD PTR [edi+edx+1]
	mov	edx, DWORD PTR _lcount$93027[ebp]
	push	ecx
	lea	ecx, DWORD PTR [edi+edx]
	mov	edx, DWORD PTR _alvalue$93011[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+24]
	mov	edx, DWORD PTR tv21884[ebp]
	push	ecx
	lea	ecx, DWORD PTR [edx+edi+1]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0DO@MAANDGDB@Index?5?$CFd?5of?5left?5side?5is?5?$CFd?0?5ind@
	push	edx
	call	_sprintf

; 6133 :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6134 :                           file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 24					; 00000018H
	lea	esi, DWORD PTR [eax+1]
	npad	7
$LL2879@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2879@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 6135 :               kb_error(1918,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1918					; 0000077eH
	call	_kb_error
	add	esp, 28					; 0000001cH
	mov	edx, 4
$LN116@eval:

; 6126 :             }
; 6127 :           }
; 6128 :           for ( j = 0 ; j < scount-1 ; j++ )

	mov	eax, DWORD PTR _scount$93030[ebp]
	add	DWORD PTR tv32424[ebp], edx
	add	DWORD PTR tv32420[ebp], edx
	inc	edi
	dec	eax
	cmp	edi, eax
	jl	$LL117@eval
$LN115@eval:

; 6136 :             }
; 6137 :           }
; 6138 : 
; 6139 :           
; 6140 :           p = pspots[0];

	mov	eax, DWORD PTR _pspots$93020[ebp]

; 6141 :           q = qspots[0];

	mov	ecx, DWORD PTR _qspots$93021[ebp]

; 6142 :           s = sspots[0];

	mov	edx, DWORD PTR _sspots$93022[ebp]
	mov	DWORD PTR _p$93015[ebp], eax
	mov	DWORD PTR _q$93016[ebp], ecx
	mov	DWORD PTR _s$93017[ebp], edx
$LN113@eval:

; 6143 :           do
; 6144 :           { 
; 6145 :             
; 6146 :                 REAL *pp = (REAL*)p;
; 6147 :                 REAL *qq = (REAL*)q;
; 6148 :                 REAL *ss = (REAL*)s;
; 6149 :                 switch ( node->op1.assigntype )

	mov	esi, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR [esi+32]
	mov	eax, DWORD PTR _p$93015[ebp]
	mov	ecx, DWORD PTR _q$93016[ebp]
	mov	edx, DWORD PTR _s$93017[ebp]
	add	esi, -30001				; ffff8acfH
	cmp	esi, 4
	ja	$LN89@eval
	jmp	DWORD PTR $LN4050@eval[esi*4]
$LN108@eval:

; 6150 :                 { case ASSIGN_OP:
; 6151 :                      { *pp = 0.0;

	fldz

; 6152 :                         for ( i = 0 ; i < lastsize ; i++ ) 

	mov	esi, DWORD PTR _lastsize$93026[ebp]
	fstp	QWORD PTR [eax]
	test	esi, esi
	jle	$LN89@eval
	npad	3
$LL107@eval:

; 6153 :                         { *pp += (*qq)*(*ss);

	fld	QWORD PTR [edx]

; 6154 :                            qq++;
; 6155 :                            ss = (REAL*)((char*)ss+sstride[0]);

	add	edx, DWORD PTR _sstride$93025[ebp]
	fmul	QWORD PTR [ecx]
	add	ecx, 8
	dec	esi
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	jne	SHORT $LL107@eval

; 6156 :                         }
; 6157 :                       }
; 6158 :                      break;

	jmp	$LN89@eval
$LN104@eval:

; 6159 :                   case PLUSASSIGN_OP:
; 6160 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	mov	esi, DWORD PTR _lastsize$93026[ebp]
	test	esi, esi
	jle	$LN89@eval
	mov	edi, DWORD PTR _q$93016[ebp]
	mov	edx, DWORD PTR _s$93017[ebp]
	sub	edx, edi
	sub	edi, eax
$LL103@eval:

; 6161 :                        *(pp++) += *(qq++) + *(ss++);

	lea	ecx, DWORD PTR [edi+eax]
	fld	QWORD PTR [ecx+edx]
	add	eax, 8
	dec	esi
	fadd	QWORD PTR [ecx]
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LL103@eval

; 6162 :                      break;

	jmp	$LN89@eval
$LN100@eval:

; 6163 :                   case SUBASSIGN_OP:
; 6164 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	mov	esi, DWORD PTR _lastsize$93026[ebp]
	test	esi, esi
	jle	$LN89@eval
	mov	edi, DWORD PTR _q$93016[ebp]
	mov	edx, DWORD PTR _s$93017[ebp]
	sub	edx, edi
	sub	edi, eax
	npad	2
$LL99@eval:

; 6165 :                        *(pp++) -= *(qq++) + *(ss++);

	lea	ecx, DWORD PTR [edi+eax]
	fld	QWORD PTR [ecx+edx]
	add	eax, 8
	dec	esi
	fadd	QWORD PTR [ecx]
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LL99@eval

; 6166 :                      break;                        

	jmp	$LN89@eval
$LN96@eval:

; 6167 :                   case MULTASSIGN_OP:
; 6168 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	mov	esi, DWORD PTR _lastsize$93026[ebp]
	test	esi, esi
	jle	SHORT $LN89@eval
	mov	edi, DWORD PTR _q$93016[ebp]
	mov	edx, DWORD PTR _s$93017[ebp]
	sub	edx, edi
	sub	edi, eax
$LL95@eval:

; 6169 :                        *(pp++) *= *(qq++) + *(ss++);

	lea	ecx, DWORD PTR [edi+eax]
	fld	QWORD PTR [ecx+edx]
	add	eax, 8
	dec	esi
	fadd	QWORD PTR [ecx]
	fmul	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LL95@eval

; 6170 :                      break;

	jmp	SHORT $LN89@eval
$LN92@eval:

; 6171 :                   case DIVASSIGN_OP:
; 6172 :                      for ( i = 0 ; i < lastsize ; i++ ) 

	cmp	DWORD PTR _lastsize$93026[ebp], 0
	jle	SHORT $LN89@eval
	mov	edi, DWORD PTR _q$93016[ebp]
	mov	edx, DWORD PTR _s$93017[ebp]
	mov	esi, DWORD PTR _lastsize$93026[ebp]
	sub	edx, edi
	sub	edi, DWORD PTR _p$93015[ebp]
	npad	4
$LL91@eval:

; 6173 :                        *(pp++) /= *(qq++) + *(ss++);

	lea	ecx, DWORD PTR [edi+eax]
	fld	QWORD PTR [ecx+edx]
	add	eax, 8
	dec	esi
	fadd	QWORD PTR [ecx]
	fdivr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LL91@eval
$LN89@eval:

; 6174 :                      break;
; 6175 :                 }
; 6176 :       
; 6177 : 
; 6178 :             /* increment pointers */
; 6179 :             for ( j = ldim-1 ; j >= 0 ; j-- )

	mov	edx, DWORD PTR _ldim$93031[ebp]
	dec	edx
	js	$LN112@eval
	mov	eax, DWORD PTR _lcount$93027[ebp]
	lea	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _alvalue$93011[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4+24]
	mov	eax, edx
	sub	eax, DWORD PTR _rdim$93033[ebp]
	add	eax, eax
	add	eax, eax
$LL88@eval:

; 6180 :             { pspots[j] += pstride[j];

	mov	esi, DWORD PTR _pstride$93023[ebp+edx*4]
	add	DWORD PTR _pspots$93020[ebp+edx*4], esi

; 6181 :               if ( j < rdim-1 )

	mov	esi, DWORD PTR _rdim$93033[ebp]
	mov	edi, DWORD PTR _pspots$93020[ebp+edx*4]
	dec	esi
	cmp	edx, esi
	jge	SHORT $LN85@eval

; 6182 :                 qspots[j] += qstride[j];

	mov	esi, DWORD PTR _qstride$93024[ebp+edx*4]
	add	DWORD PTR _qspots$93021[ebp+edx*4], esi

; 6183 :               else

	jmp	SHORT $LN84@eval
$LN85@eval:

; 6184 :                 sspots[j-rdim+2] += sstride[j-rdim+2];

	mov	esi, DWORD PTR _sstride$93025[ebp+eax+8]
	add	DWORD PTR _sspots$93022[ebp+eax+8], esi
$LN84@eval:

; 6185 :               if ( ++inx[j] < alvalue->sizes[lcount+j] )

	inc	DWORD PTR _inx$93014[ebp+edx*4]
	mov	esi, DWORD PTR _inx$93014[ebp+edx*4]
	cmp	esi, DWORD PTR [ecx]
	jl	SHORT $LN2624@eval

; 6194 :                   sspots[k] = s;
; 6195 :                  
; 6196 :                 break;
; 6197 :               }
; 6198 :               inx[j] = 0 ;

	mov	DWORD PTR _inx$93014[ebp+edx*4], 0
	sub	eax, 4
	sub	ecx, 4
	dec	edx
	jns	SHORT $LL88@eval

; 6334 :                 a = NULL;
; 6335 :               }
; 6336 :             }
; 6337 :          }
; 6338 :         if ( this_frame->flags & BASE_OF_EVAL )

	jmp	$LN112@eval
$LN2624@eval:

; 6187 :                 q = qspots[j];

	mov	ecx, DWORD PTR _qspots$93021[ebp+edx*4]

; 6188 :                 s = sspots[j-rdim+2];

	mov	eax, edx
	sub	eax, DWORD PTR _rdim$93033[ebp]
	mov	DWORD PTR _q$93016[ebp], ecx
	mov	ecx, DWORD PTR _sspots$93022[ebp+eax*4+8]

; 6189 :                 for ( k = j+1 ; k < ldim ; k++ )

	lea	esi, DWORD PTR [edx+1]
	mov	DWORD PTR _p$93015[ebp], edi
	mov	DWORD PTR tv21942[ebp], eax
	mov	DWORD PTR _s$93017[ebp], ecx
	cmp	esi, DWORD PTR _ldim$93031[ebp]
	jge	SHORT $LN82@eval

; 6186 :               { p = pspots[j];                

	mov	ecx, DWORD PTR _ldim$93031[ebp]
	mov	eax, DWORD PTR _p$93015[ebp]
	lea	edi, DWORD PTR _pspots$93020[ebp+esi*4]
	sub	ecx, esi
	rep stosd
	mov	eax, DWORD PTR tv21942[ebp]
$LN82@eval:

; 6190 :                   pspots[k] = p;
; 6191 :                 for ( k = j+1 ; k < rdim ; k++ )

	cmp	esi, DWORD PTR _rdim$93033[ebp]
	jge	SHORT $LN79@eval
	mov	ecx, DWORD PTR _rdim$93033[ebp]
	mov	eax, DWORD PTR _q$93016[ebp]
	lea	edi, DWORD PTR _qspots$93021[ebp+esi*4]
	sub	ecx, esi
	rep stosd
	mov	eax, DWORD PTR tv21942[ebp]
$LN79@eval:

; 6192 :                   qspots[k] = q;
; 6193 :                 for ( k = j-rdim+2 ; k < sdim ; k++ )

	add	eax, 2
	cmp	eax, DWORD PTR _sdim$93032[ebp]
	jge	SHORT $LN112@eval
	mov	ecx, DWORD PTR _sdim$93032[ebp]
	lea	edi, DWORD PTR _sspots$93022[ebp+eax*4]
	sub	ecx, eax
	mov	eax, DWORD PTR _s$93017[ebp]
	rep stosd
$LN112@eval:

; 6199 :             }  
; 6200 :            } while ( j >= 0 );    

	test	edx, edx
	jns	$LN113@eval

; 6201 :        
; 6202 :           /* Temp arrays in case of integer data */
; 6203 :           if ( alvalue->datatype == INTEGER_TYPE )

	mov	eax, DWORD PTR _alvalue$93011[ebp]
	cmp	DWORD PTR [eax+8], 2
	jne	SHORT $LN73@eval

; 6204 :           { int count;
; 6205 :             for ( count = 1, j = 0 ; j < ldim ; j++ )

	mov	ecx, DWORD PTR _ldim$93031[ebp]
	mov	esi, 1
	test	ecx, ecx
	jle	SHORT $LN70@eval
	mov	edx, DWORD PTR _lcount$93027[ebp]
	lea	eax, DWORD PTR [eax+edx*4+24]
$LL72@eval:

; 6206 :                 count *= alvalue->sizes[lcount+j];

	imul	esi, DWORD PTR [eax]
	add	eax, 4
	dec	ecx
	jne	SHORT $LL72@eval
$LN70@eval:

; 6207 :             for ( j = 0 ; j < count ; j++ )

	xor	edi, edi
	test	esi, esi
	jle	SHORT $LN67@eval
$LL69@eval:

; 6208 :               oldp[j] = (int)(ptemp[j]);

	mov	eax, DWORD PTR _ptemp$93034[ebp]
	fld	QWORD PTR [eax+edi*8]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _oldp$93037[ebp]
	mov	DWORD PTR [ecx+edi*4], eax
	inc	edi
	cmp	edi, esi
	jl	SHORT $LL69@eval
$LN67@eval:

; 6209 :             temp_free((char*)ptemp);

	mov	edx, DWORD PTR _ptemp$93034[ebp]
	push	edx
	call	_temp_free
	add	esp, 4
$LN73@eval:

; 6210 :           }
; 6211 :           if ( arvalue->datatype == INTEGER_TYPE )

	mov	eax, DWORD PTR _arvalue$93012[ebp]
	cmp	DWORD PTR [eax+8], 2
	jne	SHORT $LN66@eval

; 6212 :             temp_free((char*)rtemp);

	mov	ecx, DWORD PTR _rtemp$93035[ebp]
	push	ecx
	call	_temp_free
	add	esp, 4
$LN66@eval:

; 6213 :           if ( asvalue->datatype == INTEGER_TYPE )

	mov	edx, DWORD PTR _asvalue$93013[ebp]
	cmp	DWORD PTR [edx+8], 2
	jne	$LN3977@eval

; 6214 :             temp_free((char*)stemp);

	mov	eax, DWORD PTR _stemp$93036[ebp]
	push	eax
	call	_temp_free
	add	esp, 4

; 6215 : 
; 6216 : 
; 6217 :          if ( node->flags & RECALC_FLAG )
; 6218 :            recalc_flag = 1;
; 6219 :          if ( node->flags & DONT_RESIZE_FLAG )  // for modifying view_matrix before 's'
; 6220 :            dont_resize_flag = 1;
; 6221 : 
; 6222 :        
; 6223 :          } /* end ARRAY_ASSIGNOP_A_X_A_ */
; 6224 :          break;

	jmp	$LN3977@eval
$LN62@eval:

; 6225 : 
; 6226 :      /* end whole-array syntax */
; 6227 :     
; 6228 :       case PLUSASSIGN_NODE:
; 6229 :       case SUBASSIGN_NODE:
; 6230 :       case MULTASSIGN_NODE:
; 6231 :       case DIVASSIGN_NODE:
; 6232 :       case SET_GLOBAL_NODE:
; 6233 :        { struct global *g = globals(node->op1.name_id);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN2415@eval
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2417@eval
	mov	edx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	edi, DWORD PTR [eax*8]
	sub	edi, eax
	shl	edi, 5
	add	edi, DWORD PTR [edx]
	jmp	SHORT $LN3991@eval
$LN2417@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2415@eval
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN3991@eval
$LN2415@eval:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [eax+ecx]
$LN3991@eval:

; 6234 :          REAL *x;
; 6235 : 
; 6236 :          if ( g->flags & GLOB_LOCALVAR )

	mov	ecx, DWORD PTR [edi+192]
	mov	edx, ecx
	and	edx, 524288				; 00080000H
	mov	DWORD PTR _g$93184[ebp], edi
	je	SHORT $LN61@eval

; 6237 :             x = newstack + localstack + g->value.offset;

	mov	esi, DWORD PTR [edi+64]
	add	esi, DWORD PTR _localstack$[ebp]
	lea	eax, DWORD PTR [edi+64]
	mov	edi, DWORD PTR [ebx+40]
	lea	esi, DWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR _g$93184[ebp]
	jmp	SHORT $LN58@eval
$LN61@eval:

; 6238 :          else if ( g->flags & ORDINARY_PARAM )

	test	cl, 1
	je	$LN59@eval

; 6239 :             x = &g->value.real;

	lea	eax, DWORD PTR [edi+64]
	mov	esi, eax
$LN58@eval:

; 6246 :          }
; 6247 : 
; 6248 :          if ( g->flags & STRINGVAL )

	test	ecx, 8192				; 00002000H
	je	SHORT $LN57@eval

; 6249 :          { if ( g->flags & GLOB_LOCALVAR )

	test	edx, edx
	je	SHORT $LN56@eval

; 6250 :              myfree(*(char**)x); 

	mov	edx, DWORD PTR [esi]
	push	edx
	jmp	SHORT $LN3992@eval
$LN56@eval:

; 6251 :            else  myfree(g->value.string);

	mov	eax, DWORD PTR [eax]
	push	eax
$LN3992@eval:
	call	_myfree
	add	esp, 4

; 6252 :            g->flags &= ~STRINGVAL; 

	and	DWORD PTR [edi+192], -8193		; ffffdfffH
$LN57@eval:

; 6253 :          }
; 6254 : 
; 6255 :          switch(node->type)

	mov	ecx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [ecx]
	add	eax, -10378				; ffffd776H
	cmp	eax, 4
	ja	$LN53@eval
	jmp	DWORD PTR $LN4051@eval[eax*4]
$LN52@eval:

; 6256 :          { 
; 6257 :             case SET_GLOBAL_NODE: *x = *(stacktop--); break;

	mov	edx, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx]
	jmp	$LN3993@eval
$LN51@eval:

; 6258 :             case PLUSASSIGN_NODE: *x += *(stacktop--); break;

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	fadd	QWORD PTR [esi]
	jmp	$LN3993@eval
$LN50@eval:

; 6259 :             case SUBASSIGN_NODE: *x -= *(stacktop--); break;

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	fsub	QWORD PTR [ecx]
	jmp	$LN3993@eval
$LN49@eval:

; 6260 :             case MULTASSIGN_NODE: *x *= *(stacktop--); break;

	mov	edx, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx]
	fmul	QWORD PTR [esi]
	jmp	$LN3993@eval
$LN48@eval:

; 6261 :             case DIVASSIGN_NODE: 
; 6262 :               if ( *stacktop == 0.0 )

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN47@eval

; 6263 :               { sprintf(errmsg,"Division by zero.\n");

	push	OFFSET ??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 6264 :                 sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6265 :                    file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL2880@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2880@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 6266 :                 kb_error(2562,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2562					; 00000a02H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN47@eval:

; 6267 :               }
; 6268 :               *x /= *(stacktop--); break;

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	fdiv	QWORD PTR [eax]
$LN3993@eval:
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	fstp	QWORD PTR [esi]
$LN53@eval:

; 6269 :          }
; 6270 :          if ( g->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [edi+188]
	test	eax, eax
	je	$LN44@eval

; 6271 :          { struct  global *gg = globals(g->attr.varstuff.on_assign_call);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN2421@eval
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2423@eval
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _localbase$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN2422@eval
$LN2423@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2421@eval
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN2422@eval
$LN2421@eval:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN2422@eval:

; 6272 :            PUSH_TRACE;

	cmp	DWORD PTR _eval_stack_trace_spot, 100	; 00000064H
	jl	SHORT $LN45@eval
	mov	DWORD PTR _eval_stack_trace_spot, 0
$LN45@eval:
	mov	ecx, DWORD PTR _eval_stack_trace_spot
	mov	edx, DWORD PTR _node$[ebp]

; 6273 :            eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	mov	DWORD PTR _eval_stack_trace[ecx*4], edx
	add	eax, 64					; 00000040H
	inc	ecx
	push	0
	push	eax
	mov	DWORD PTR _eval_stack_trace_spot, ecx
	call	_eval
	fstp	ST(0)

; 6274 :            POP_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	add	esp, 16					; 00000010H
	test	eax, eax
	jle	SHORT $LN44@eval
	mov	DWORD PTR _eval_stack_trace[eax*4], 0
	dec	eax
	mov	DWORD PTR _eval_stack_trace_spot, eax
$LN44@eval:

; 6275 :          }
; 6276 :          if ( g->flags & RECALC_PARAMETER )

	test	BYTE PTR [edi+192], 8

; 6277 :             recalc_flag = 1;
; 6278 : 
; 6279 :        }
; 6280 :        break;

	jmp	$LN4004@eval
$LN59@eval:

; 6240 :          else 
; 6241 :          { sprintf(errmsg, "Variable %s is read-only.\n",g->name);

	push	edi
	push	OFFSET ??_C@_0BL@DGMPENFC@Variable?5?$CFs?5is?5read?9only?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 6242 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6243 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
$LL2881@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2881@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 6244 :            kb_error(3455,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	3455					; 00000d7fH
	call	_kb_error
	add	esp, 28					; 0000001cH

; 6245 :            break;

	jmp	$LN1980@eval
$LN42@eval:

; 6281 : 
; 6282 :       case PRE_INCREMENT_NODE: case POST_INCREMENT_NODE:
; 6283 :        { struct global *g = globals(node->op1.name_id);

	mov	esi, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [esi+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN2427@eval
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN2429@eval
	mov	ecx, DWORD PTR _localbase$[ebp]
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	shl	edx, 5
	add	edx, DWORD PTR [ecx]
	jmp	SHORT $LN2428@eval
$LN2429@eval:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN2427@eval
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN2428@eval
$LN2427@eval:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax]
$LN2428@eval:

; 6284 :          REAL *x;
; 6285 : 
; 6286 :          if ( g->flags & GLOB_LOCALVAR )

	mov	eax, DWORD PTR [edx+192]
	test	eax, 524288				; 00080000H
	je	SHORT $LN41@eval

; 6287 :             x = newstack + localstack + g->value.offset;

	mov	ecx, DWORD PTR [edx+64]
	add	ecx, DWORD PTR _localstack$[ebp]
	mov	eax, DWORD PTR [ebx+40]
	lea	eax, DWORD PTR [eax+ecx*8]
	jmp	SHORT $LN38@eval
$LN41@eval:

; 6288 :          else if ( g->flags & ORDINARY_PARAM )

	test	al, 1
	je	SHORT $LN39@eval

; 6289 :             x = &g->value.real;

	lea	eax, DWORD PTR [edx+64]
$LN38@eval:

; 6296 :          }
; 6297 : 
; 6298 :          switch(node->op2.assigntype)

	mov	ecx, DWORD PTR [esi+136]
	sub	ecx, 30006				; 00007536H
	je	SHORT $LN35@eval
	dec	ecx
	jne	SHORT $LN36@eval

; 6301 :             case MINUSMINUS_OP: *x -= 1; break;

	fld	QWORD PTR [eax]
	fsub	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [eax]

; 6302 :          }
; 6303 :          if ( g->flags & RECALC_PARAMETER )

	test	BYTE PTR [edx+192], 8

; 6304 :             recalc_flag = 1;
; 6305 :        }
; 6306 :        break;

	jmp	$LN4004@eval
$LN35@eval:

; 6299 :          { 
; 6300 :             case PLUSPLUS_OP: *x += 1; break;

	fld	QWORD PTR [eax]
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [eax]
$LN36@eval:

; 6302 :          }
; 6303 :          if ( g->flags & RECALC_PARAMETER )

	test	BYTE PTR [edx+192], 8

; 6304 :             recalc_flag = 1;
; 6305 :        }
; 6306 :        break;

	jmp	$LN4004@eval
$LN39@eval:

; 6290 :          else 
; 6291 :          { sprintf(errmsg, "Variable %s is read-only.\n",g->name);

	push	edx
	push	OFFSET ??_C@_0BL@DGMPENFC@Variable?5?$CFs?5is?5read?9only?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 6292 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6293 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	esi, DWORD PTR [eax+1]
$LL2882@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2882@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 6294 :            kb_error(4455,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	4455					; 00001167H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 6295 :            break;

	jmp	$LN1980@eval
$LN32@eval:

; 6307 : 
; 6308 :       case SET_PERM_GLOBAL_NODE:
; 6309 :        { struct global *g = perm_globals(node->op1.name_id);

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [edx+ecx*4]

; 6310 :          REAL *x;
; 6311 : 
; 6312 :          if ( g->flags & STRINGVAL )

	test	DWORD PTR [esi+192], 8192		; 00002000H
	je	SHORT $LN31@eval

; 6313 :          { free(g->value.string); g->flags &= ~STRINGVAL; }

	mov	eax, DWORD PTR [esi+64]
	push	eax
	call	_free
	add	esp, 4
	and	DWORD PTR [esi+192], -8193		; ffffdfffH
$LN31@eval:

; 6314 : 
; 6315 :          x = &g->value.real;
; 6316 :          *x = *(stacktop--); 

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	fstp	QWORD PTR [esi+64]

; 6317 :          if ( g->flags & RECALC_PARAMETER )

	test	BYTE PTR [esi+192], 8

; 6318 :             recalc_flag = 1;
; 6319 :        }
; 6320 :        break;

	jmp	$LN4004@eval
$LN29@eval:

; 6321 : 
; 6322 : 
; 6323 : 
; 6324 : 
; 6325 :       case FINISHED_NODE:
; 6326 :          if ( localbase && (localbase->flags & LL_HAS_ARRAY) )

	mov	edx, DWORD PTR _localbase$[ebp]
	test	edx, edx
	je	SHORT $LN25@eval
	test	BYTE PTR [edx+20], 1
	je	SHORT $LN25@eval

; 6327 :           { /* de-allocate local array storage */
; 6328 :             int n;
; 6329 :             for ( n = 0 ; n < localbase->count ; n++ )

	xor	edi, edi
	cmp	DWORD PTR [edx+8], edi
	jle	SHORT $LN25@eval
	xor	esi, esi
	npad	5
$LL27@eval:

; 6330 :             { struct global *g = &(localbase->list[n].g);

	mov	eax, DWORD PTR [edx]

; 6331 :               if ( (g->flags & ARRAY_PARAM) && !(g->flags & FIXED_SIZE_ARRAY) )

	mov	ecx, DWORD PTR [eax+esi+192]
	test	ecx, 2048				; 00000800H
	je	SHORT $LN26@eval
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN26@eval

; 6332 :               { struct array *a = *(struct array**)(newstack + localstack + g->value.offset);

	mov	eax, DWORD PTR [eax+esi+64]
	add	eax, DWORD PTR _localstack$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	eax, DWORD PTR [ecx+eax*8]

; 6333 :                 if ( a ) temp_free((char*)a);

	test	eax, eax
	je	SHORT $LN26@eval
	push	eax
	call	_temp_free
	mov	edx, DWORD PTR _localbase$[ebp]
	add	esp, 4
$LN26@eval:

; 6327 :           { /* de-allocate local array storage */
; 6328 :             int n;
; 6329 :             for ( n = 0 ; n < localbase->count ; n++ )

	inc	edi
	add	esi, 224				; 000000e0H
	cmp	edi, DWORD PTR [edx+8]
	jl	SHORT $LL27@eval
$LN25@eval:

; 6334 :                 a = NULL;
; 6335 :               }
; 6336 :             }
; 6337 :          }
; 6338 :         if ( this_frame->flags & BASE_OF_EVAL )

	mov	edx, DWORD PTR [ebx+52]
	mov	eax, DWORD PTR [ebx+40]
	test	BYTE PTR [eax+edx*8+124], 2
	lea	eax, DWORD PTR [eax+edx*8]
	jne	$the_exit$89581

; 6339 :         { /* want to exit from eval() */
; 6340 :           goto the_exit; 
; 6341 :         }       
; 6342 :         else /* want to return within eval() */
; 6343 :         {          
; 6344 :           return_value = *stacktop;

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]

; 6345 :           stacktop = (REAL*)this_frame;
; 6346 :           stacktop--; /* since points to occupied spot */

	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	fstp	QWORD PTR _return_value$[ebp]

; 6347 :           node = this_frame->return_node;

	mov	edx, DWORD PTR [ebx+52]
	mov	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [eax+edx*8+120]
	mov	DWORD PTR _node$[ebp], ecx

; 6348 :           td->frame_spot = this_frame->parent_frame_spot;

	mov	edx, DWORD PTR [ebx+52]
	mov	eax, DWORD PTR [ebx+40]
	mov	eax, DWORD PTR [eax+edx*8+116]

; 6349 :           localstack = (int)((REAL*)(this_frame)+FRAME_SPACE - newstack);

	lea	ecx, DWORD PTR [eax*8+128]
	sar	ecx, 3
	mov	DWORD PTR [ebx+52], eax
	mov	DWORD PTR _localstack$[ebp], ecx

; 6350 :           ex_current = this_frame->base_ex;

	mov	ecx, DWORD PTR [ebx+40]
	lea	esi, DWORD PTR [ecx+eax*8+8]
	mov	ecx, 26					; 0000001aH
	lea	edi, DWORD PTR _ex_current$[ebp]
	rep movsd

; 6351 :           localbase = ex_current.locals;

	mov	eax, DWORD PTR _ex_current$[ebp+8]
	mov	DWORD PTR _localbase$[ebp], eax

; 6352 :           if ( ex_current.locals )

	test	eax, eax
	je	SHORT $LN20@eval

; 6353 :             localcount = ex_current.locals->totalsize;

	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _localcount$[ebp], edx
	jmp	$LN1980@eval
$LN20@eval:

; 6354 :           else localcount = 0;

	mov	DWORD PTR _localcount$[ebp], 0

; 6355 :         }      
; 6356 :         break;

	jmp	$LN1980@eval
$LN18@eval:

; 6357 : 
; 6358 :     default:
; 6359 :         other_stuff(node,&recalc_flag,
; 6360 :             &update_display_flag,q_id,newstack + localstack,localbase);

	mov	eax, DWORD PTR _localbase$[ebp]
	mov	ecx, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR _localstack$[ebp]
	push	eax
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _q_id$[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _node$[ebp]
	lea	edx, DWORD PTR _update_display_flag$[ebp]
	push	edx
	lea	eax, DWORD PTR _recalc_flag$[ebp]
	push	eax
	push	ecx
	call	_other_stuff
	add	esp, 24					; 00000018H
	jmp	$LN1980@eval
$LN11@eval:

; 6383 :       case BREAKAFTERWARNING: 
; 6384 :         { sprintf(errmsg,"Command aborted due to break_after_warning.\n");

	push	OFFSET ??_C@_0CN@MKCBCDPJ@Command?5aborted?5due?5to?5break_aft@
	push	OFFSET _errmsg
	call	_sprintf

; 6385 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6386 :                 file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	esi, DWORD PTR [eax+1]
$LL2884@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2884@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 6387 :           kb_error(3109,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3109					; 00000c25H
	jmp	SHORT $LN4015@eval
$LN13@eval:

; 6368 :       { case BREAKFULL:
; 6369 :         { sprintf(errmsg,"Command aborted due to user interrupt.\n");

	push	OFFSET ??_C@_0CI@OEJLGIBG@Command?5aborted?5due?5to?5user?5inte@
	push	OFFSET _errmsg
	call	_sprintf

; 6370 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6371 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	esi, DWORD PTR [eax+1]
	npad	5
$LL2885@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2885@eval
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 6372 :           kb_error(2073,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2073					; 00000819H
$LN4015@eval:
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN14@eval:

; 6388 :         }
; 6389 :       }
; 6390 :     }
; 6391 : 
; 6392 : #ifdef _XXDEBUG
; 6393 :    { static int didwarn;
; 6394 :     /* Check predicted stack alignment.  There are circumstances when alignment
; 6395 :        is not equal (e.g. skipping procedure bodies when assigning them,
; 6396 :        so just check there is room. */
; 6397 :     if ( (node[1].type != SETUP_FRAME_NODE) &&
; 6398 :             (stacktop > (REAL*)this_frame + FRAME_SPACE + localcount + node->stack_spot) )
; 6399 :     { sprintf(errmsg,"Intermediate stack misalignment after node type %d.\n",
; 6400 :          node->type);
; 6401 :       sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6402 :                  file_names[node->file_no],node->line_no);
; 6403 :       if ( ! didwarn )  /* to prevent error cascade */
; 6404 :          kb_error(2671,errmsg,WARNING);
; 6405 :       didwarn = 1;
; 6406 :     }
; 6407 :     else didwarn = 0;
; 6408 :    }
; 6409 : #endif
; 6410 : 
; 6411 : if ( td->stack_top < td->eval_stack )

	mov	eax, DWORD PTR [ebx+48]
	cmp	eax, DWORD PTR [ebx+40]
	jae	SHORT $LN10@eval

; 6412 :   kb_error(5243,"BAD EVAL STACK\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BA@EFKCGIKP@BAD?5EVAL?5STACK?6?$AA@
	push	5243					; 0000147bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN10@eval:

; 6413 :   
; 6414 :     if ( newstack[stackmax-1] != STACKMAGIC ) /* nearing overflow */

	mov	ecx, DWORD PTR [ebx+44]
	mov	edx, DWORD PTR [ebx+40]
	fld	QWORD PTR [edx+ecx*8-8]
	fld	QWORD PTR __real@41684bfe477e06cc
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN1990@eval

; 6415 :     { kb_error(3488,"Evaluation stack overflow.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BM@GBPBJJDP@Evaluation?5stack?5overflow?4?6?$AA@
	push	3488					; 00000da0H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1990@eval:

; 157  :   }
; 158  :  
; 159  :   for ( node = ex_current.start+1 ; ; node++ )

	add	DWORD PTR _node$[ebp], 168		; 000000a8H
	jmp	$LL1991@eval
$LN2625@eval:

; 397  :           { single_step_debugging = 1;

	mov	eax, 1
	mov	DWORD PTR _single_step_debugging, eax

; 398  :             exit_flag = 1;

	mov	DWORD PTR _exit_flag, eax
$the_exit$89581:

; 6416 :     }
; 6417 :   }
; 6418 : the_exit:
; 6419 : 
; 6420 :  
; 6421 :   if ( !params )

	cmp	DWORD PTR _params$GSCopy$[ebp], 0
	jne	$LN4@eval

; 6422 :   { if ( web.counts_changed && (this_thread == main_thread_id) )

	cmp	DWORD PTR _web+5524, 0
	je	SHORT $LN7@eval
	call	DWORD PTR __imp__GetCurrentThreadId@0
	cmp	eax, DWORD PTR _main_thread_id
	jne	SHORT $LN7@eval

; 6423 :        flush_counts();

	call	_flush_counts
$LN7@eval:

; 6424 : 
; 6425 :     if ( recalc_flag && autorecalc_flag ) recalc();

	cmp	DWORD PTR _recalc_flag$[ebp], 0
	je	SHORT $LN6@eval
	cmp	DWORD PTR _autorecalc_flag, 0
	je	SHORT $LN6@eval
	call	_recalc
	jmp	SHORT $LN4@eval
$LN1890@eval:

; 525  :          }
; 526  :          strncpy(loadfilename,*(char**)(stacktop--),sizeof(loadfilename));

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	push	1000					; 000003e8H
	push	ecx
	add	eax, -8					; fffffff8H
	push	OFFSET _loadfilename
	mov	DWORD PTR [ebx+48], eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 527  : #ifdef __cplusplus
; 528  :          loadstub();  /* indirect throw of exception */
; 529  : #else
; 530  :          longjmp(loadjumpbuf,1);

	push	1
	push	OFFSET _loadjumpbuf
	call	_longjmp
$LN4052@eval:
$LN6@eval:

; 6426 :     else if ( update_display_flag ) update_display();

	cmp	DWORD PTR _update_display_flag$[ebp], 0
	je	SHORT $LN4@eval
	call	_update_display
$LN4@eval:

; 6427 :   }
; 6428 :   PROF_EVAL_END(ex_original);
; 6429 :   iterate_flag = old_flag; 

	mov	eax, DWORD PTR _old_flag$[ebp]

; 6430 :   if ( stacktop == (REAL*)this_frame + FRAME_SPACE + localcount  ) 

	mov	ecx, DWORD PTR _localcount$[ebp]
	mov	DWORD PTR _iterate_flag, eax
	mov	edx, DWORD PTR [ebx+52]
	mov	eax, DWORD PTR [ebx+48]
	lea	esi, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [ebx+40]
	lea	edi, DWORD PTR [ecx+esi*8+128]
	cmp	eax, edi
	jne	SHORT $LN3@eval

; 6431 :   { /* Have return value on stack */
; 6432 :     REAL retval = *(stacktop--);

	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax

; 6433 :     stacktop = (REAL*)this_frame;

	mov	edx, DWORD PTR [ebx+52]

; 6434 :     stacktop--; /* since points to occupied spot */

	mov	eax, DWORD PTR [ebx+40]
	lea	ecx, DWORD PTR [eax+edx*8-8]
	mov	DWORD PTR [ebx+48], ecx

; 6435 :     td->frame_spot = this_frame->parent_frame_spot;

	mov	edx, DWORD PTR [ebx+52]
	mov	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [eax+edx*8+116]
	mov	DWORD PTR [ebx+52], ecx

; 6451 : } /* end eval() */

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@eval:

; 6436 :     return retval; 
; 6437 :   }
; 6438 :   else if ( stacktop != (REAL*)this_frame + FRAME_SPACE + localcount - 1)

	lea	esi, DWORD PTR [ecx+esi*8+120]
	cmp	eax, esi
	je	$LN1@eval

; 6439 :   { 
; 6440 :     sprintf(errmsg,"Internal error: Stack misalignment by %d in eval()\n",
; 6441 :        (int)(stacktop-(REAL*)this_frame-localcount-FRAME_SPACE+1));

	add	edx, edx
	add	edx, edx
	add	edx, edx
	sub	eax, edx
	sub	eax, ecx
	sar	eax, 3
	sub	eax, DWORD PTR _localcount$[ebp]
	sub	eax, 15					; 0000000fH
	push	eax
	push	OFFSET ??_C@_0DE@KHJAAIFB@Internal?5error?3?5Stack?5misalignme@
	push	OFFSET _errmsg
	call	_sprintf

; 6442 :     sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 6443 :              file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL2886@eval:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL2886@eval
	mov	ecx, DWORD PTR _node$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 6444 :     kb_error(1298,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1298					; 00000512H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1@eval:

; 6445 :   }
; 6446 :   
; 6447 :   stacktop = (REAL*)this_frame;

	mov	eax, DWORD PTR [ebx+52]

; 6448 :   stacktop--; /* since points to occupied spot */
; 6449 :   td->frame_spot = this_frame->parent_frame_spot;
; 6450 :   return 0.0;

	fldz
	mov	ecx, DWORD PTR [ebx+40]
	lea	edx, DWORD PTR [ecx+eax*8-8]
	mov	DWORD PTR [ebx+48], edx
	mov	ecx, DWORD PTR [ebx+40]
	mov	eax, DWORD PTR [ebx+52]
	mov	edx, DWORD PTR [ecx+eax*8+116]

; 6451 : } /* end eval() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+52], edx
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3945@eval:
	npad	2
$LN4028@eval:
	DD	$LN1979@eval
	DD	$LN1969@eval
	DD	$LN1968@eval
	DD	$LN1964@eval
	DD	$LN1958@eval
	DD	$LN1941@eval
	DD	$LN1940@eval
	DD	$LN1928@eval
	DD	$LN1924@eval
	DD	$LN1921@eval
	DD	$LN1917@eval
	DD	$LN1912@eval
	DD	$LN1906@eval
	DD	$LN1901@eval
	DD	$LN1900@eval
	DD	$LN1899@eval
	DD	$LN1895@eval
	DD	$LN1891@eval
	DD	$LN1889@eval
	DD	$LN1881@eval
	DD	$LN1873@eval
	DD	$LN1865@eval
	DD	$LN1862@eval
	DD	$LN1860@eval
	DD	$LN1857@eval
	DD	$LN1855@eval
	DD	$LN1852@eval
	DD	$LN1980@eval
	DD	$LN1980@eval
	DD	$LN1980@eval
	DD	$LN1980@eval
	DD	$LN1846@eval
	DD	$LN1841@eval
	DD	$LN1840@eval
	DD	$LN1839@eval
	DD	$LN1838@eval
	DD	$LN1980@eval
	DD	$LN1980@eval
	DD	$LN1980@eval
	DD	$LN1980@eval
	DD	$LN1980@eval
	DD	$LN1830@eval
	DD	$LN1830@eval
	DD	$LN1822@eval
	DD	$LN1821@eval
	DD	$LN1820@eval
	DD	$LN1819@eval
	DD	$LN1980@eval
	DD	$LN1980@eval
	DD	$LN1980@eval
	DD	$LN1815@eval
	DD	$LN1814@eval
	DD	$LN1813@eval
	DD	$LN1980@eval
	DD	$LN1980@eval
	DD	$LN1810@eval
	DD	$LN1814@eval
	DD	$LN1808@eval
	DD	$LN1806@eval
	DD	$LN1802@eval
	DD	$LN1800@eval
	DD	$LN1793@eval
	DD	$LN1793@eval
	DD	$LN1836@eval
	DD	$LN1836@eval
	DD	$LN1790@eval
	DD	$LN1789@eval
	DD	$LN1788@eval
	DD	$LN1836@eval
	DD	$LN1784@eval
	DD	$LN1784@eval
	DD	$LN1782@eval
	DD	$LN1784@eval
	DD	$LN1779@eval
	DD	$LN1776@eval
	DD	$LN1836@eval
	DD	$LN1774@eval
	DD	$LN1765@eval
	DD	$LN1755@eval
	DD	$LN1745@eval
	DD	$LN1741@eval
	DD	$LN1737@eval
	DD	$LN1733@eval
	DD	$LN1729@eval
	DD	$LN1725@eval
	DD	$LN1721@eval
	DD	$LN1706@eval
	DD	$LN1699@eval
	DD	$LN1696@eval
	DD	$LN1693@eval
	DD	$LN1691@eval
	DD	$LN1689@eval
	DD	$LN1687@eval
	DD	$LN1673@eval
	DD	$LN1672@eval
	DD	$LN1671@eval
	DD	$LN1670@eval
	DD	$LN1669@eval
	DD	$LN1668@eval
	DD	$LN1662@eval
	DD	$LN1656@eval
	DD	$LN1646@eval
	DD	$LN1646@eval
	DD	$LN1646@eval
	DD	$LN1646@eval
	DD	$LN1630@eval
	DD	$LN1629@eval
	DD	$LN1628@eval
	DD	$LN1627@eval
	DD	$LN1626@eval
	DD	$LN1625@eval
	DD	$LN1622@eval
	DD	$LN1621@eval
	DD	$LN1620@eval
	DD	$LN1619@eval
	DD	$LN1618@eval
	DD	$LN1617@eval
	DD	$LN1616@eval
	DD	$LN1614@eval
	DD	$LN1612@eval
	DD	$LN1610@eval
	DD	$LN1609@eval
	DD	$LN1608@eval
	DD	$LN1608@eval
	DD	$LN1607@eval
	DD	$LN1606@eval
	DD	$LN1602@eval
	DD	$LN1598@eval
	DD	$LN1594@eval
	DD	$LN1590@eval
	DD	$LN1581@eval
	DD	$LN1573@eval
	DD	$LN1572@eval
	DD	$LN1571@eval
	DD	$LN1569@eval
	DD	$LN1567@eval
	DD	$LN1566@eval
	DD	$LN1565@eval
	DD	$LN1558@eval
	DD	$LN1557@eval
	DD	$LN1556@eval
	DD	$LN1555@eval
	DD	$LN1554@eval
	DD	$LN1553@eval
	DD	$LN1552@eval
	DD	$LN1551@eval
	DD	$LN1550@eval
	DD	$LN1549@eval
	DD	$LN1548@eval
	DD	$LN1547@eval
	DD	$LN1543@eval
	DD	$LN1539@eval
	DD	$LN1535@eval
	DD	$LN1530@eval
	DD	$LN1525@eval
	DD	$LN1524@eval
	DD	$LN1523@eval
	DD	$LN1522@eval
	DD	$LN1521@eval
	DD	$LN1520@eval
	DD	$LN1519@eval
	DD	$LN1515@eval
	DD	$LN1507@eval
	DD	$LN1496@eval
	DD	$LN1488@eval
	DD	$LN1483@eval
	DD	$LN1480@eval
	DD	$LN1477@eval
	DD	$LN1474@eval
	DD	$LN1471@eval
	DD	$LN1468@eval
	DD	$LN1464@eval
	DD	$LN1457@eval
	DD	$LN1454@eval
	DD	$LN1454@eval
	DD	$LN1443@eval
	DD	$LN1440@eval
	DD	$LN1437@eval
	DD	$LN1437@eval
	DD	$LN1434@eval
	DD	$LN1431@eval
	DD	$LN1428@eval
	DD	$LN1425@eval
	DD	$LN1418@eval
	DD	$LN1414@eval
	DD	$LN1410@eval
	DD	$LN1402@eval
	DD	$LN1402@eval
	DD	$LN1393@eval
	DD	$LN1393@eval
	DD	$LN1386@eval
	DD	$LN1383@eval
	DD	$LN1380@eval
	DD	$LN1380@eval
	DD	$LN1380@eval
	DD	$LN1375@eval
	DD	$LN1375@eval
	DD	$LN1372@eval
	DD	$LN1369@eval
	DD	$LN1361@eval
	DD	$LN1354@eval
	DD	$LN1347@eval
	DD	$LN1336@eval
	DD	$LN1325@eval
	DD	$LN1322@eval
	DD	$LN1318@eval
	DD	$LN1318@eval
	DD	$LN1313@eval
	DD	$LN1308@eval
	DD	$LN1305@eval
	DD	$LN1302@eval
	DD	$LN1299@eval
	DD	$LN1296@eval
	DD	$LN1293@eval
	DD	$LN1290@eval
	DD	$LN1287@eval
	DD	$LN1284@eval
	DD	$LN1281@eval
	DD	$LN1707@eval
	DD	$LN1255@eval
	DD	$LN1254@eval
	DD	$LN1225@eval
	DD	$LN1225@eval
	DD	$LN1216@eval
	DD	$LN1216@eval
	DD	$LN1210@eval
	DD	$LN1210@eval
	DD	$LN1203@eval
	DD	$LN1203@eval
	DD	$LN1193@eval
	DD	$LN1185@eval
	DD	$LN1174@eval
	DD	$LN1980@eval
	DD	$LN1171@eval
	DD	$LN1170@eval
	DD	$LN1169@eval
	DD	$LN1168@eval
	DD	$LN1980@eval
	DD	$LN1165@eval
	DD	$LN1164@eval
	DD	$LN1125@eval
	DD	$LN1122@eval
	DD	$LN1116@eval
	DD	$LN1113@eval
	DD	$LN1980@eval
	DD	$LN1088@eval
	DD	$LN1082@eval
	DD	$LN1075@eval
	DD	$LN1980@eval
	DD	$LN1066@eval
	DD	$LN1060@eval
	DD	$LN1055@eval
	DD	$LN1050@eval
	DD	$LN1045@eval
	DD	$LN1039@eval
	DD	$LN1033@eval
	DD	$LN1980@eval
	DD	$LN1980@eval
	DD	$LN1025@eval
	DD	$LN1019@eval
	DD	$LN1016@eval
	DD	$LN1013@eval
	DD	$LN1010@eval
	DD	$LN1009@eval
	DD	$LN945@eval
	DD	$LN944@eval
	DD	$LN943@eval
	DD	$LN942@eval
	DD	$LN941@eval
	DD	$LN940@eval
	DD	$LN936@eval
	DD	$LN935@eval
	DD	$LN934@eval
	DD	$LN932@eval
	DD	$LN930@eval
	DD	$LN929@eval
	DD	$LN928@eval
	DD	$LN927@eval
	DD	$LN926@eval
	DD	$LN925@eval
	DD	$LN924@eval
	DD	$LN923@eval
	DD	$LN922@eval
	DD	$LN920@eval
	DD	$LN920@eval
	DD	$LN910@eval
	DD	$LN880@eval
	DD	$LN880@eval
	DD	$LN863@eval
	DD	$LN863@eval
	DD	$LN858@eval
	DD	$LN856@eval
	DD	$LN856@eval
	DD	$LN855@eval
	DD	$LN854@eval
	DD	$LN853@eval
	DD	$LN852@eval
	DD	$LN851@eval
	DD	$LN850@eval
	DD	$LN849@eval
	DD	$LN848@eval
	DD	$LN841@eval
	DD	$LN839@eval
	DD	$LN835@eval
	DD	$LN834@eval
	DD	$LN834@eval
	DD	$LN825@eval
	DD	$LN824@eval
	DD	$LN823@eval
	DD	$LN822@eval
	DD	$LN821@eval
	DD	$LN816@eval
	DD	$LN815@eval
	DD	$LN814@eval
	DD	$LN814@eval
	DD	$LN814@eval
	DD	$LN814@eval
	DD	$LN814@eval
	DD	$LN814@eval
	DD	$LN814@eval
	DD	$LN814@eval
	DD	$LN814@eval
	DD	$LN814@eval
	DD	$LN814@eval
	DD	$LN812@eval
	DD	$LN812@eval
	DD	$LN812@eval
	DD	$LN812@eval
	DD	$LN812@eval
	DD	$LN812@eval
	DD	$LN812@eval
	DD	$LN812@eval
	DD	$LN812@eval
	DD	$LN803@eval
	DD	$LN803@eval
	DD	$LN803@eval
	DD	$LN803@eval
	DD	$LN803@eval
	DD	$LN802@eval
	DD	$LN800@eval
	DD	$LN798@eval
	DD	$LN797@eval
	DD	$LN796@eval
	DD	$LN795@eval
	DD	$LN795@eval
	DD	$LN1707@eval
	DD	$LN1707@eval
	DD	$LN1980@eval
	DD	$LN791@eval
	DD	$LN744@eval
	DD	$LN721@eval
	DD	$LN718@eval
	DD	$LN717@eval
	DD	$LN714@eval
	DD	$LN714@eval
	DD	$LN714@eval
	DD	$LN701@eval
	DD	$LN691@eval
	DD	$LN691@eval
	DD	$LN1980@eval
	DD	$LN676@eval
	DD	$LN668@eval
	DD	$LN652@eval
	DD	$LN597@eval
	DD	$LN540@eval
	DD	$LN1980@eval
	DD	$LN526@eval
	DD	$LN525@eval
	DD	$LN427@eval
	DD	$LN372@eval
	DD	$LN372@eval
	DD	$LN319@eval
	DD	$LN319@eval
	DD	$LN282@eval
	DD	$LN282@eval
	DD	$LN243@eval
	DD	$LN166@eval
	DD	$LN62@eval
	DD	$LN62@eval
	DD	$LN62@eval
	DD	$LN62@eval
	DD	$LN62@eval
	DD	$LN42@eval
	DD	$LN42@eval
	DD	$LN32@eval
	DD	$LN29@eval
$LN4029@eval:
	DD	$LN1771@eval
	DD	$LN1770@eval
	DD	$LN1769@eval
	DD	$LN1768@eval
	DD	$LN1767@eval
$LN4030@eval:
	DD	$LN1718@eval
	DD	$LN1715@eval
	DD	$LN1712@eval
	DD	$LN1709@eval
$LN4031@eval:
	DD	$LN1449@eval
	DD	$LN1446@eval
	DD	$LN1445@eval
	DD	$LN1444@eval
$LN4032@eval:
	DD	$LN1236@eval
	DD	$LN1235@eval
	DD	$LN1233@eval
	DD	$LN1231@eval
	DD	$LN1228@eval
	DD	$LN1234@eval
	DD	$LN1232@eval
	DD	$LN1230@eval
	DD	$LN1229@eval
	DD	$LN1226@eval
	DD	$LN1227@eval
	DD	$LN1980@eval
$LN2832@eval:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	9
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	npad	1
$LN4033@eval:
	DD	$LN1151@eval
	DD	$LN1980@eval
$LN2839@eval:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	npad	3
$LN4034@eval:
	DD	$LN1148@eval
	DD	$LN1145@eval
	DD	$LN1144@eval
	DD	$LN1141@eval
	DD	$LN1140@eval
$LN4035@eval:
	DD	$LN1159@eval
	DD	$LN1372@eval
	DD	$LN1157@eval
	DD	$LN1372@eval
	DD	$LN1155@eval
	DD	$LN1155@eval
	DD	$LN1980@eval
	DD	$LN1980@eval
$LN4036@eval:
	DD	$LN1005@eval
	DD	$LN953@eval
	DD	$LN954@eval
	DD	$LN1005@eval
$LN2841@eval:
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	0
	DB	3
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	3
	DB	3
	DB	1
	DB	1
	DB	1
	DB	1
	DB	3
	DB	1
	DB	3
	DB	1
	DB	3
	DB	3
	DB	1
	DB	1
	DB	1
	DB	2
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	npad	3
$LN4037@eval:
	DD	$LN1005@eval
	DD	$LN1005@eval
	DD	$LN1005@eval
	DD	$LN1000@eval
	DD	$LN1005@eval
	DD	$LN998@eval
	DD	$LN998@eval
	DD	$LN1005@eval
	DD	$LN1005@eval
$LN4038@eval:
	DD	$LN779@eval
	DD	$LN778@eval
	DD	$LN777@eval
	DD	$LN771@eval
	DD	$LN775@eval
	DD	$LN777@eval
	DD	$LN778@eval
	DD	$LN772@eval
	DD	$LN776@eval
	DD	$LN778@eval
	DD	$LN778@eval
	DD	$LN777@eval
	DD	$LN2990@eval
	DD	$LN2990@eval
	DD	$LN2990@eval
	DD	$LN2990@eval
	DD	$LN2990@eval
	DD	$LN2990@eval
$LN4039@eval:
	DD	$LN3370@eval
	DD	$LN764@eval
	DD	$LN763@eval
	DD	$LN762@eval
	DD	$LN761@eval
$LN4040@eval:
	DD	$LN757@eval
	DD	$LN756@eval
	DD	$LN749@eval
	DD	$LN753@eval
	DD	$LN751@eval
	DD	$LN755@eval
	DD	$LN754@eval
	DD	$LN752@eval
	DD	$LN3375@eval
	DD	$LN756@eval
$LN2860@eval:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	1
	DB	6
	DB	7
	DB	9
	DB	9
	DB	9
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	npad	2
$LN4041@eval:
	DD	$LN733@eval
	DD	$LN722@eval
	DD	$LN725@eval
	DD	$LN729@eval
	DD	$LN727@eval
	DD	$LN731@eval
	DD	$LN722@eval
	DD	$LN730@eval
	DD	$LN728@eval
	DD	$LN722@eval
	DD	$LN722@eval
	DD	$LN724@eval
	DD	$LN722@eval
	DD	$LN722@eval
	DD	$LN722@eval
	DD	$LN722@eval
	DD	$LN722@eval
	DD	$LN722@eval
$LN4042@eval:
	DD	$LN664@eval
	DD	$LN653@eval
	DD	$LN658@eval
	DD	$LN656@eval
	DD	$LN660@eval
	DD	$LN662@eval
	DD	$LN653@eval
	DD	$LN657@eval
	DD	$LN661@eval
	DD	$LN653@eval
	DD	$LN665@eval
	DD	$LN655@eval
	DD	$LN654@eval
	DD	$LN654@eval
	DD	$LN654@eval
	DD	$LN654@eval
	DD	$LN654@eval
	DD	$LN654@eval
$LN4043@eval:
	DD	$LN636@eval
	DD	$LN630@eval
	DD	$LN624@eval
	DD	$LN618@eval
	DD	$LN612@eval
$LN4044@eval:
	DD	$LN563@eval
	DD	$LN559@eval
	DD	$LN555@eval
	DD	$LN551@eval
	DD	$LN547@eval
$LN4045@eval:
	DD	$LN587@eval
	DD	$LN583@eval
	DD	$LN579@eval
	DD	$LN575@eval
	DD	$LN571@eval
$LN4046@eval:
	DD	$LN484@eval
	DD	$LN474@eval
	DD	$LN470@eval
	DD	$LN466@eval
	DD	$LN462@eval
$LN4047@eval:
	DD	$LN514@eval
	DD	$LN504@eval
	DD	$LN500@eval
	DD	$LN496@eval
	DD	$LN492@eval
$LN4048@eval:
	DD	$LN411@eval
	DD	$LN405@eval
	DD	$LN399@eval
	DD	$LN393@eval
	DD	$LN387@eval
$LN4049@eval:
	DD	$LN358@eval
	DD	$LN352@eval
	DD	$LN346@eval
	DD	$LN340@eval
	DD	$LN334@eval
$LN4050@eval:
	DD	$LN108@eval
	DD	$LN104@eval
	DD	$LN100@eval
	DD	$LN96@eval
	DD	$LN92@eval
$LN4051@eval:
	DD	$LN51@eval
	DD	$LN50@eval
	DD	$LN49@eval
	DD	$LN48@eval
	DD	$LN52@eval
_eval	ENDP
_TEXT	ENDS
END
